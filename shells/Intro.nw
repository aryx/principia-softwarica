%\chapter{Introduction}
The goal of this book is to explain with full details the source code of
a {shell}.

\section{Motivations}

Why a shell? 
Because I think you are a better programmer if
you fully understand how things work under the hood, and
%
the shell is the central piece of the {\em command-line user interface} (CLI).
\n other pieces are kernel and especially /dev/cons (said later)
\l CLI instead?
%
\n def
The shell is a thin layer around the {kernel} (hence its name) % \book{Kernel}
allowing you to {run commands} in a {terminal}.
\n terminal is keyboard and monitor (said later)
\n actually more than command interpreter, but it is its essence (said later)

%without:
Most users now use a {\em graphical user interface} (GUI) to execute programs
(e.g., macOS, Microsoft Windows, X Window), but
\n also rio \book{Windows}, but rio relies on shell to launch program actually
most programmers still spend a significant portion of their time in a shell
to run 
compilation commands, % (see the \book{Builder}), 
editors, % (see the \book{Editor}),
debuggers, % (see the \book{Debugger}),
or {\em scripts} to automate repetitive tasks.
%
Integrated Development Environments (IDEs) can handle some of those
use cases, but the shell still reigns when a programmer needs more flexibility.
%
The power of 
{pipes}, 
{redirections}, 
{variables}, and 
basic {control flow constructs}
\n sequence is already great, especially in a script file (said later)
allows sometimes in one command-line
to perform tasks that would require hundreds of lines in a regular 
programming language\footnote{
For example, \cite{literate-pearl} contrasts writing a program
to count words in Pascal and in a shell.
}.
\n one-liner, command-line hence CLI
\n building blocks, components (said later)

There are very few books explaining how a shell works. I can cite
{\em Advanced UNIX Programming}~\cite{unix-rochkind},
but it explains only the code of a mini-shell.
%
This is a pity because the implementation of a real shell covers many
interesting topics (e.g.,
programming language design, 
compilation, 
interpretation,
system programming, etc.) as you will see soon in this book.
\l redundant with Compiler? No, cos usually use (bytecode) interpreter
\l interesting design constraints compared to regular PL; DSL spirit


Here are a few questions I hope this book will answer:
\begin{itemize}

\item What is the difference between a shell and a terminal?
What is the difference between a shell and a login program?
\n rc vs /dev/cons
\l rc vs login or telnet or ssh (plan9 has no login program)

\item What happens when the user type [[ls]] in a terminal?
What is the trace of such a command through the different layers
of the software stack?

\item What are the main features of a shell?

\item How are implemented redirections and pipes? 
What are the system calls involved?

\item Why [[ls]] and [[rm]] are regular programs but not [[cd]]?
Why [[cd]] has to be a shell {builtin}? What is a shell builtin?

\item How does [[C-c]], which interrupts a process, work?
Which process receives the signal after an interruption?
The shell or the command ran from the shell?

%\item How does [[C-z]], which suspends a process, work?
%not under \plan; need less job control when have multiple windows anyway,
% job suspended when blocked on output in window!


\end{itemize}
%less: relation between login shell (.profile), user shell (bashrc)
% but rc does not have this issue I think.

%bash shellshock context in oct 2014, good idea to look at shell
% implementation :)

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl): (use ??)
% - growing_array (codebuf, waitpids)
% - ???
%algorithms (beyond search/sort): (actually use neither search nor sort?)
% - globbing? with does some string matching with regexp ('*' '?' '[...]'? )
% - ???


\section{The \plan shell: [[rc]]}

I will explain in this book the code of the \plan shell
[[rc]]~\cite{rc}\footnote{See 
\url{http://plan9.bell-labs.com/magic/man2html/1/rc} for its manual page.}
(for [[R]]un [[C]]ommands), which contains about 6700 lines of code (LOC).
%
[[rc]] is written mostly in C, with its parser using also Yacc~\cite{yacc}.

%dup: Assembler.nw
Like for most books in \principia, I chose a \plan program because
those programs are simple, small, elegant, open source, and 
they form together a coherent set.
%
Moreover, [[rc]] is arguably simpler to use and to understand 
than [[sh]]~\cite{sh}, the \unix shell, or any of its derivatives 
(e.g., [[bash]]~\cite{bash}, the most popular shell under Linux).
%
For example, by treating the content
of any variables uniformly as a list of strings, [[rc]] does not 
need the extra operator [[$@]] used in [[sh]] ([[$*]] is enough).
\l also [[$status]] clearer than [[$0]] (said later?)
\t also PATH does not need special : separator, which is different than other special vars; use consistently [[var=( ... )]]
Moreover,
The syntax of [[rc]], specified formally and succintely by a small grammar,
is also easier to learn than the (unspecified) syntax of [[sh]], partly
because [[rc]] is inspired by the syntax of C with its 
curly braces ([[sh]], instead, is using multiple keywords inspired by Algol).
\l actually rc seems used as a fork basis for other advanced shells (es, other?)
\l actually grammar of sh in sh article, but Duff says it's not valid 
\l used also outside plan9 by a few open source software. Portable.
\l Still used in Go :)
\t need for external programs: test '[' expr, ugly ;;, lots of bad stuff in sh
%Contrast the two equivalent snippets of code, one written in [[rc]] and
% the other in [[sh]].
% if [ ... -ne ...]; then
% vs
% if(~ ...) {
% ...
% }
% [[sh]] requires the [[then]] keyword to be preceded by a newline or
% a semicolon, leading to a weird syntax for conditionals. Moreover,
% [[sh]] requires the use of the unconventional [[-ne]] operator and \[ 
% bracket, which is actually an external program ([[/usr/bin/[]]).
\l why? interactive requirement?
%footnote{To be fair, [[rc]] uses also un unconventional operator [[~]],
% which is described in Section{X}}.


[[rc]] itself lacks many of the interactive features found in other
shells (e.g., [[bash]]) such as 
{filename completion}, 
{command-line editing}, 
job control, etc.
This is partly because
under \plan, the terminal of the windowing system [[rio]] 
is providing instead those features (see the \book{Windows}).
\n job control less useful when have multiple windows


\section{Other shells}

Here are a few shells that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

%history:
\item The first \unix shell, originally called [[sh]], was written
by Ken Thompson, the original author of the \unix kernel.
\n Not first one, before shell for CTSS and Multics, RUNCOM (said later?)
\n and probably there was very basic command interpreter before too
%
[[sh]] started as an assembly program in 
\unix V1\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=V1/sh.s}
and finished as a C program in
\unix V6\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/source/s2/sh.c}.
%
Ken Thompson's shell introduced the 
pipe ([['|']]), 
redirections ([['>']] and [['<']]), as well as
wildcard matching\footnote{Also known as globbing.} ([['*']]).
\l also command sequence ([[;]]), background job ([[&]])
%
The syntax of those features remained the same in all subsequent shells.
\n actually was using different syntax originally for pipe >cmd> but confusing
%
Ken Thompson's shell contains only 899 LOC, but it is just a 
basic command interpreter, not a full scripting language like [[rc]].
\n 3 man pages
\n recursive descent parsing,
\l if/goto (and glob) were external programs

%history:
\item The Bourne shell~\cite{sh}, also called [[sh]], superseded 
Ken Thompson's shell (which was renamed [[osh]]) in 
\unix V7\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/cmd/sh/}.
%
It was written by Stephen Bourne and contains 4145 LOC of C.
\n 6 man pages
%
It is arguably the most famous shell because it defined first
the main features that we expect now from a shell:
the ability to run commands with pipes and redirections, but also
the use of variables and control flow constructs to write {scripts}.
\n and functions? not in sh (but scripts were kinda functions)
\l said later?
%
The Bourne shell is both an interactive command interpreter and
a full programming language.
%
Most subsequent shells tried to remain backward compatible with the Bourne
shell.

The syntax of the Bourne shell was inspired by Algol 
\l cite?
with pair of keywords (e.g., [[begin/end]], [[do/done]], [[case/esac]]) 
\n not od because conflict with unix program od
instead of the curly braces of C\footnote{
Stephen Bourne was such as fan of Algol that the C source
code of [[sh]] itself looks like Algol, thanks to macros such as
[[THEN]], [[BEGIN]], [[END]], etc.}.
\n apparently it inspires the IOCCC contest :) says the wikipedia page of sh
%
The code of [[sh]] is smaller than the code of [[rc]], but it is
also harder to understand. 
\l also use own allocator, macros, no libs
\l understanding and porting bourne shell to new unix version
\l cite Tour of C shell that talks about that?
% For example, there is no clear grammar
as in [[rc]], but instead a complex recursive descent parser.
\l Actually Duff says nobody knows the grammar
%  of sh (even though sh article by Bourne contains a grammar in appendix).
\l design of sh by bourne: https://www.youtube.com/watch?v=2kEJoWfobpA

%\item C shell lots of interactive features.
%\item Korn shell lots of interactive features.


\item Bash~\cite{bash,learning-bash}\furl{https://www.gnu.org/software/bash/}
(for Bourne-Again Shell) is an open-source shell similar
to the Bourne shell (hence its name) from the 
GNU project\furl{http://www.gnu.org}.
%
It is the default shell in most Linux distributions.
\l used to be default in macOS but now zsh is
\l also ported to Windows
%dup: (but different context) intro/rc
It provides many interactive features not found in the Bourne
shell such as filename completion, command-line editing,
interactive history, job control, etc.
\n  arrow key, C-r, need raw mode 
%
Many of those features were partly inspired by the C shell~\cite{csh}, 
an older shell originating in BSD \unix using a syntax more similar to C.
\l actually not very C: if/then/endif compared to rc

Bash relies on the GNU Readline library\furl{https://tiswww.case.edu/php/chet/readline/rltop.html}
for many of those interactive features
%dup: intro/rc
([[rc]] relies instead on [[rio]]'s terminal to provide similar features).
%
However, the codebase of Bash is very large with more than 100~000 LOC
(not including the code of the Readline library, which would add
another 33~000 LOC), which
is more than an order of magnitude more code than in [[rc]].
Bash's grammar file [[parse.y]] contains alone 6268 LOC.
%http://www.aosabook.org/en/bash.html
\n 110 man pages. 75 pages in pdf of man page. and bash reference man is 172p.

\item The Z shell~\cite{bash-to-zsh}\furl{http://www.zsh.org/}
is another open-source shell popular among advanced Linux users.
%
It is extensible through plugins and themes\footnote{See 
\url{https://github.com/robbyrussell/oh-my-zsh} for a large repository
of such contributions.}.
%
It contains most of the features found in other shells (e.g., Bash,
the C Shell, the Korn Shell~\cite{ksh, ksh-usenix}) and introduced 
many new interactive features such as 
programmable completion,
\l now also in bash
recursive wildcarding with [[**/*]] (eliminating the need for
the program [[find]]),
and more.
%
However, all those features come at a price: the code
of the Z shell contains more than 145 000 LOC (not including the tests).

\end{itemize}


\begin{figure}[]\centering
\includegraphics[height=0.45\textheight]{lineage}
\caption{Shells timeline}
\label{fig:lineage}
\end{figure}
\l big hole because switch to GUI, and scripting languages (Perl/...) instead of
\l  shells, which even if they have a REPL are not really shells

%dup: Assembler.nw
Figure~\ref{fig:lineage} presents a timeline of major \unix shells
(and a few non-\unix shells).
%
I think [[rc]] represents the best compromise for this book: 
it implements the essential features of a shell while still having
%dup: intro/rc
a small and understandable codebase (6700 LOC).

%history:
% - RUN command monitor provided by machine? ex: in PDP11
% - http://www.multicians.org/shell.html
%   history of the shell by Louis Pouzin, RUNCOM first shell
% - the original shell of Ken Thompson. Ported and extended to C in V5.
%   http://v6shell.org  http://v6shell.org/history/sh.c
%   understanding the shell of v6: http://experiments.oskarth.com/unix01/ DEAD?
% - Mashey shell by PWB group, added control flow but remained backward
%   compatible with Ken Thompson shell so strong limiting constraint
% - original bourne shell, in unix-history-repo, 4145 LOC for V7
% - csh apparently introduced many interactive features, by
%   Bill Joy: history, alias, dir stack, tilde, filename completion,
%   job control. but No way to define function on multiple lines;
%   just provided alias, and hacky and fragile parser.
% - ksh
% - bash
%   http://samrowe.com/wordpress/advancing-in-the-bash-shell/
%education:
% - xinu shell in appendix of xinu book
% - a shell for xv6
%   https://github.com/oskarth/xv6/blob/master/homework/sh.c
% - minix had a shell too
%mini:
% - sh.c in plan9, simple shell used for early porting with
%   many programs as builtins! really useful.
% - sash (stand-alone-shell), precursor to busybox; far smaller.
%   many builtins there such as ed, tar are included in busybox.
%   1500 LOC (without the cmd_xxx.c) by David I Bell :) of mini-X
%   but mini-shell, not full PL
% - hush, a small reimplem of sh (9300 LOC in busybox, not so small)
% - http://runtimeterror.com/tech/lil/
% - Tcl in 500 LOC http://antirez.com/picol/picol.c.txt
%   https://github.com/zserge/partcl mini Tcl again
%other:
% - ash Almquist shell https://en.wikipedia.org/wiki/Almquist_shell
%   used for Debian startup scripts (called dash), android, busybox
%   many variants: http://www.in-ulm.de/~mascheck/various/ash/
%   17 000 LOC (ash.c is 11 000 LOC in busybox, but maybe use other files)
%   used in minix, seems mostly a rewrite or bourne shell
% - busybox, includes ash and hush, with many programs as builtins.
% - rc fork by Byron Rakitzis (in infomagic 94) that then made es?
%   which now is maintained at http://tobold.org/article/rc
% - es: extensible shell, based on rc: 13 000 LOC
%   http://wryun.github.io/es-shell/
%   http://wryun.github.io/es-shell/paper.html inspired by scheme and ML
% - another rc fork? 
% - ape/pdksh/, 23 000 LOC vs rc 6300 (or 10 000 when wc *.nw instead)
% - oil shell (also shell in python) osh (bash compatible) and oil (new one)
%   http://www.oilshell.org/blog/2017/02/11.html
%   "Why create a new unix shell?":
%   http://www.oilshell.org/blog/2018/01/28.html
% - PowerShell, recently open sourced, written in C#, huge
%   contains shell but also utilities. Apparently can have typed pipes.
%   Maybe like in Automator?
% - DOS? they had a shell? command.com? 4dos?
% - cicada, shell in rust https://github.com/mitnk/cicada
% - ion, shell in rust from redox project
%exotic:
% - scsh
%   more orthogonal, but then more verbose, remove what makes a shell a bit.
%   I could present it, but then it's yet another language to present (Scheme)
% - eshell!! pager a la plan9, so no need pager like less/more/most actually
%   http://www.howardism.org/Technical/Emacs/eshell-fun.html
% - Automator, visual pipes! not really a shell, a kind of visual shell
% - wish
% - goosh, the google shell
% - yubnub: the command-line of the web
%research/recent:
% - fish shell (friendly shell), lots of interactive features
%   50 000 LOC (without tests), written in C++
%   rely on ncurses (uses also PCRE)
% - https://elvish.io/, with structured-data in pipes (e.g., JSON)
% - next generation shell
%   https://github.com/ilyash/ngs/
% - xonsh http://xon.sh/ (a superset of pyhton)
% - mosh, mobile shell, allow disconnection over Wifi apparently
%   but not really a shell, more a replacement for ssh
% - https://github.com/ergonomica/ergonomica a cross-platform shell written
%   in Python
% - ssh? actually it's not really a shell, its name (secure shell) is misleading
% - http://www.jonathanturner.org/2019/08/introducing-nushell.html 
%related:
% - GNOME Shell: called a shell but it's really the GUI of Gnome

% https://en.wikipedia.org/wiki/Comparison_of_command_shells
%  exhaustive list
% http://xon.sh/#comparison 
%  nice comparison of modern shells
% evolution of shells:
% https://www.ibm.com/developerworks/library/l-linux-shells/
%  nice diagram of history of shells, very nice resource list with further links
% list of terminals and shells:
%  https://github.com/k4m4/terminals-are-sexy
% write your own shell:
% - https://linuxgazette.net/111/ramankutty.html
% - %https://brennan.io/2015/01/16/write-a-shell-in-c/
% - http://www.davidpashley.com/articles/writing-robust-shell-scripts/
% - https://indradhanush.github.io/blog/writing-a-unix-shell-part-1/
%   https://indradhanush.github.io/blog/writing-a-unix-shell-part-2/
% - https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
%   from https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/
% basic command, pipe, quotes, use PEG parser (meh)
%  https://www.destroyallsoftware.com/screencasts/catalog/shell-from-scratch
% scriptometer
%   http://rigaux.org/language-study/scripting-language/
% https://drewdevault.com/2018/12/28/Anatomy-of-a-shell.html

\l there is also an article in oasa book about bash
% (available in bash/doc/aosa-bash.pdf)

\section{Getting started}
\label{sec:getting-started}

%dup: Assembler.nw
To play with [[rc]], you will first need to install
the \plan fork used in \principia (see \urlinstall).
\l also under unix with plan9port, also author of es got a unix port apparently
%
Once installed, you do not need to do anything to run [[rc]]
because it is the program started by default by the kernel 
(see the \book{Kernel}).
%
Once the kernel finished to boot,
you should see a percent sign, called the {\em prompt}, 
after which you can type any commands as in the following:

\begin{verbatim}
1   % ls /
2   bin
3   boot
4   ...
5   srv
6   % rc -help
7   Usage: rc [-SsrdiIlxepvV] [-c arg] [-m command] [file [arg...]]
8   % rc
9   % prompt='$ '
10  $ ls /
11  bin
12  boot
13  ...
14  srv
15  $ exit
16  %
\end{verbatim}

Line~1 runs the program [[ls]] to list the content
of the root directory. % see \book{Utilities}
%
Line~6 and Line~8 show that [[rc]] is a regular program
(just like [[ls]] at Line~1):
you can run a shell program under a shell.
\n under unix you can change shell if you are not satisified: chsh (said later)
%
Line~8 and Line~9 seem to indicate that typing [[rc]] has no effect, but 
the percent sign shown at the beginning of Line~9 is in fact displayed 
by the [[rc]] process started by Line~8, not the original [[rc]] process 
started by the kernel.
%
Line~9 modifies the {\em special variable} [[prompt]] 
(see Section~\ref{sec:special-variables} 
for a list of those special variables)
%
to better differentiate the two shell processes.
Indeed, Line~10 shows
that [['$ ']] is the new prompt replacing the percent sign. %$
%
Finally, Line~15 shows the use of the {\em builtin} [[exit]]
(see Chapter~\ref{chap:builtins} for more information on builtins)
to exit from the shell.
%
Doing so goes back to the preceding shell process
(the one launched by the kernel)
with the original percent prompt at Line~16.
\l Modify variable in current process (and children), not parent process.


\section{Requirements}

%dup: Assembler
Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
To understand Chapter~\ref{chap:parsing}, you will also
need to know Yacc~\cite{lexyacc}.
\l Can read \book{Compiler} :) and \book{Generators} :) but a bit self-ref.


%dup: Assembler.
Note that this book is not an introduction to the shell or 
to shell scripting.
%
I assume you are already familiar with at least one shell,
for instance a derivative of [[sh]] such as [[bash]],
%
and so are familiar with concepts such as
a {pipe},
a {redirection}, 
what [[#!]] means,
or what a {script} is.
%
If not, I suggest you to read either the book introducing
the \unix programming environment~\cite{unix-pike},
or the original [[sh]] tutorial~\cite{sh}, or any
more recent books on 
shell scripting~\cite{shell-scripting, learning-bash, bash-to-zsh}.


%dup: intro/motivations
A shell is a thin layer on top of a kernel,
%
and so a shell relies heavily on the services offered by the kernel:
system calls (e.g., [[rfork()]] [[exec()]], [[wait()]], [[chdir()]]),
but also device files (e.g., [[/dev/cons]] to read and write characters
on the terminal).
%
Thus, it can be useful to know how the \plan kernel works 
(see the \book{Kernel}), or at least be familiar
with {sytem programming} under \unix~\cite{unix-rochkind,unix-stevens}, 
to fully understand some of the code in this book.

%dup: intro/related-work/sh
A shell is also a full programming language, and as you will see soon,
%
[[rc]] is internally both a {compiler} and a {bytecode interpreter}.
%
I assume you also have a basic understanding of how a compiler
works, and for example that you know what a lexer or parser is
(see the \book{Compiler}).

\l table? Compiler, Kernel? more books? Libcore?

%dup: Windows.nw
If, while reading this book,
you have specific questions on the syntax and interface of [[rc]],
I suggest you to consult the man page of [[rc]]
at [[docs/man/1/rc]] in my \plan repository.

%dup: Make.nw
Note that the [[shells/docs/]] directory in my \plan repository
contains documents describing either [[rc]]~\cite{rc-plan9}
or [[sh]]~\cite{sh-talk}.
%
Those documents are useful to understand some of the 
design decisions presented in this book, especially how and why
[[rc]] differs from [[sh]].


\section{About this document}
%old: was #include "../docs/latex/About.nw"
% but syncweb -web_to_tex does not process #include inside included file
% for now, so can use #include just in top Make.nw
\input{../docs/latex/About}

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[rc]], Tom Duff, 
who wrote in some sense most of this book.




\chapter{Overview}

%trans: %dup: Assembler.nw
Before showing the source code of [[rc]] in the following chapters, 
%toc:
I first give an overview in this chapter
of the general features of a shell.
%
I also quickly describe the command-line interface of [[rc]]
and the specific language supported by [[rc]].
%dup: Assembler.nw
I also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.

\section{Essential shell features}
\label{sec:principles}

%toc:
The following sections will explain the essential features of a shell.
%
A shell is a strange beast:
\l \cite{unix-pike}, put quote? (found in abstract of paper about es-shell)
%dup: intro/related-work/sh
it must be both 
an interactive command interpreter, 
allowing to run commands easily on one line in a terminal, and
a proper programming language, 
allowing to write complex script in a file.
\l complex program

\l do a minishell before showing rc?

%without:? can have hardcoded in kernel, but restricted.
% at least need command interpreter taking path, or GUI
\t look PDP11 RUN command monitor? hardcoded many operations in it
% instead in UNIX split in many programs, extensible,
% and can pass arguments! no need recompile!

\t principle of shell is be external program. Not with kernel.

\subsection{Running commands}

%dup: intro/motiv intro/rc intro/related-work 
The first job of a shell is to allow the user to run commands\footnote{ 
%history:
The very first shell, which was written for the CTSS operating system in 1964,
was called [[RUNCOM]]\cite{runcom}.}.
Most shells offer a minimalist syntax for running commands, so we can
type those commands quickly.
%
Indeed, contrast the shell command [[ls /]] with the equivalent C program:

<<[[ls_root.c]]>>=
#include <u.h>
#include <libc.h>

void main(){
  char* args[] = {"/"};
  exec("/bin/ls", args);
}
@
\l also print(readdir("/")) ... also fork; exec ...
%without: but would still need something to run ls_root ... chicken and egg
%ocaml: do system("ls /") but it actually relies on sh below

Here are a few notes on the minimalist syntax used by shells:

\begin{itemize}
\item {\em No Parenthesis:} to call a program, 
you do not need any parenthesis; 
just type the program name next to its arguments.
\n curry syntax :)


\item {\em No quotes:} to pass arguments to the program, 
you usually do not need any quotes or commas; 
just type the arguments separated by space.
For example, [[foo]], [[--help]], [[42]], [[/a/b/c]] are all
valid arguments\footnote{
You can even sometimes avoid to specify fully all the arguments
by using {shortcuts}, for example, {wildcards} as explained 
in Chapter~\ref{chap:globbing}.
}.
%
The only time you need to enclose an argument in a quote is
when you want to use one of the {special character} used by the shell
(e.g., [['#']], [['$']], [['&']], etc. with [[rc]]), %$
also known as {\em meta-characters}.
\l or space itself
\t see X for more information on quotation

\item {\em No full path:} to call a program, you do not need
to specify its path in the filesystem;
just type the name of the program and the shell will automatically
find its location.
%unix:
Under \unix, the [[PATH]] environment variable stores the
candidate locations to find programs.

\item {\em No special ending character:} to finish your command,
you do not need any special character like a semicolon;
just type a newline and the shell will start interpreting 
your command\footnote{You can also enter commands on multiple lines, 
which requires to {\em escape} the newline as
explained in Section~\ref{sec:escaping-newline}.}.
\l also skipnl
%real-world: ocaml needs ;; but then no need for skipnl tricks


\item {\em No types:} to enter a command, you do not need to
specify any types such as [[char*]] as in C. The arguments are
always strings.
\l even better with rc, a var is a list of string

\end{itemize}

Once the command you ran finished, the shell gets back in control
and displays another {\em prompt} to indicate that you can type another
command.

\subsection{Redirections}

The second important feature of a shell is to allow to {\em redirect}
the output and input of a program, as in [[ls / > listing.txt]].
\l can put redirection after or before the command actually


Many programs (e.g., [[ls]], [[find]], [[rm]], [[grep]]) live in
the command-line world and simply use {text} for their input and output.
%
By using redirections, you can easily save the output of those programs
in a file, or use a previously saved file as input for those 
programs\footnote{
[[rc]] allows to redirect not just the standard input and output,
as explained in Section~\ref{sec:advanced-redirection}.}, 
\l also advanced pipe, advanced double redir, advanced dup
without even changing the code of those programs.
%
In fact, because under \unix and \plan ``everything is a file'', 
including devices,
you can use the same program in many different ways.
%
For example, you can print the listing of the root directory by
simply typing [[ls / > /dev/printer]].
\l interpreted by shell, not additional arg passed to ls!
\l in fact can also be put before the command

\subsection{Pipes}

Because of the universality of plain text, you can easily combine
many command-line programs.
%
For example, you can list all the C files in your home directory by 
combining [[find]] and [[grep]] with the two commands
[[find /home/pad/ > /tmp/list.txt]] and
[[grep '\.c$' < /tmp/list.txt]]. %$
\l could use [[find ~]] but tilde is not supported by rc
\l can also pass list.txt as argument to grep, Perl [[<>]] operator
In fact, thanks to another great feature of the shell, the {\em pipe}, you
can just use one command: [[find /home/pad | grep '\.c$']]. %$
%
This is not only shorter, but also more efficient, and it gives
results more quickly.
%
You can even use multiple pipes in the same command as in
[[find | grep '\.c$' | xargs cat | grep foo]]. %$
\l filters
\l pipes popularized the use of ``filters'', program that takes input,
% transform it in some ways and output result
% (e.g., grep, sort, sed, awk).

Pipes allow to combine easily full programs, just like you can
combine functions in a functional language.
%
Pipes are one of the greatest innovations introduced by \unix, and
one of the first programming construct allowing a form of
{\em component-oriented programming}.
%
Each program can be treated as a component, which can be combined with
other components. You do not program at the granularity of functions but
at the higher granularity of programs.
\l cite literate-pearls? also pearl that does spell checker?

%implem:
% to implement pipes and redirections you just need to alter
% slightly the environment of the forked process, which shows fork's beauty



\subsection{Storing commands in a script}

Just like 
you can type a series of commands separated by newlines in a terminal,
you can save those same commands in a file, a {\em script}, and
execute this script with the shell.
\l syntax, either rc script or use of [[#!]] and chmod x (said later?)
\l  dont even need to add .rc extension so abstract away
%history:
% originally was handle by sh itself, but then it was handled by the kernel
% (see wikipedia page on Shebang)
%
As the author of the first shell said~\cite{runcom}:
``commands should be usable as building blocks for writing more commands,
just like subroutine libraries''.

\t shell procedure in sh [[$0]]%$ 

Scripts allow to automate easily repetitive tasks. Moreover, 
because scripts are commands themselves, they can also be combined, 
leading to more forms of components-oriented programming.
\l can be used as "filters" in pipes too.
\l many commands are actually small wrapper scripts setting up
\l   environment for actual binary to execute ex: firefox, gcc? ghc
\l In fact, the Bourne shell did not have support to defune functions
\l like rc, or bash. Because you can save a set of commands in a script
\l (called originally a shell procedure), this script can be called
\l like it was a function. dollar1, dollar2 for arguments 

\subsection{A shell as a scripting language}
\l Scripting! definition of such a language? hybrid lang? easy to "script" :) 
\l scriptometer of pixel

Once you can write a sequence of commands in a script, you quickly
want more, such as the ability to use conditionals or loops.
\l rare to use control flow construct from the command-line
%
Thus, most shells are also full programming languages,
often referred as {\em scripting languages},
with {\em variables} and many {\em control flow} constructs, and even
function definitions.
%
A scripting language acts like a {glue}, allowing to combine many
programs together.


Because a scripting language must also support the basic commands you
type on the command-line, it shares many characteristics with those
basic commands: a scripting language does not use types and is interpreted.
%and relies on a garbage collector.

A scripting language operates mainly on strings.
\l no bool, no int, especially in rc
Because the string arguments you type on the command-line
do not usually require any quotes, the use of variables requires
then a special operator.
%
Most shells use [['$']] as a prefix to differentiate %$
variables from regular string arguments, for example,
[[find $home]].%$
\l in the same way, newline special



% interactive and scripting language. Same engine.
% (ken thompson v6 shell was not scriptable; only interactive)
% So for interactive use, and for programming.

% dynamic language. arbitrary strings length (maybe big deal at the time
%  when compared to C, but compared to Lisp??)
% no memory management.

% evolved gradually. But to still allow simplicify of syntax for
% running commands, without quotes, with just newline,
% had to alter a few things:
% - variable prefix with $. To make diff with regular arguments to
%   commands which can be anything
% - skipnl trick for statements we usually want on multiple lines
% - just strings for values
% - actually list of strings is better basis (so no need PATH : split,
%   no need $* vs $@)

% However this goes in conflict with the ability
% to easily run command and the minimal syntax.
% rc uses lots of lexing tricks to mix full PL and DSL for
% running command (ex: SUB hack, skipnl, etc)

% no types. just strings.

% no bool. Basis is really the cmd you run.
% so control flow based on return status of the cmd.
% (and just ~ word words otherwise, and again here because basis is the
% string, the only operator is really a string matching operator).

% Even if string only citezen, still wants sometimes numerical tests.
% Enter 'test', which is really a separate program, for argument of if
% for numerical-classic-like tests.

% Shells started this "Scripting language" and also DSLs (sed/awk/...)
% that you can combine. Later Perl/Ruby/Python came, integrating
% in one lang, but not as interactive as shell.


%\subsection{A DSL}
% now in grammar

%\subsection{A universal read-eval-print loop (REPL)}
% shell is also idea of universal repl! not like Lisp machine, Squeak, etc.
% see Kernel.nw note on this.
% call function from repl, pass argument, modify globals. can even get
% help via whatis :) or man :) and return boolean result (status)
% (as well as effect on stdout/stderr that can be captured)
% In fact very similar to function call in PL: 
%  - arguments to function via argv
%  - globals via environment variables (sometimes globals are useful)
%  - other?
% support multiple programming environment (Multics goal too).
% cf stevens book, shell basis = read a line, parse, fork, exec, wait!
% RPFEW

%\subsection{An interactive interpreter}
% csh, zsh, fish: lots of interactive features outside language.

%\subsection{Asynchronous jobs and job control}
% also handling signals in child process?

%\subsection{Globbing}





\section{[[rc]] command-line interface}

%trans: %dup: Windows.nw
I just described the main features of a shell.
%and illustrated some of those principles with examples from RCS, CVS, or Git.
I will now focus exclusively on [[rc]] and give more details about
its command-line interface.


It is rare to run [[rc]] itself on the command-line,
like you run [[ls]], [[cp]], [[grep]], etc.
\n not [[cd]] here! builtin
%
After all, if you have a command-line, you already are in a shell.
\l very meta! command line interface of the command line interface!
%dup: intro/getting-started
However, as I said in Section~\ref{sec:getting-started}, the shell
under \unix (and \plan) is a regular program.
%
You can run a shell under a shell, which can be useful for example if you
do not like the default shell when you 
%unix:
log-in\footnote{Under \unix, you can also use the special program [[chsh]]
to change your login shell.}.
To run [[rc]], simply type [[rc]] on the command-line without any arguments,
as I did in Section~\ref{sec:getting-started} Line~8.
\l can run rc under sh in unix with plan9port


You can also pass to [[rc]] the name of a {script} as an argument , as well 
as the arguments of this script, for example, [[rc foo.rc arg1 arg2]]. 
\l can do [[rc ls]]? probably not.
%
However, this is usually not necessary because most scripts 
use [[#!/bin/rc]] at the beginning, which is recognized by 
the kernel (see the \book{Kernel}).
\n special comment in fact (said later)


Here is the full command-line interface of [[rc]]:
\begin{verbatim}
% rc -help
Usage: rc [-SsrdiIlxepvV] [-c arg] [-m command] [file [arg...]]
\end{verbatim}
\n autogenerated by Getflags.usage

The [[-c]] flag allows to execute commands from a string
passed as an argument instead of from the content of a script
(see Section~\ref{sec:rc-c} for the code handling [[rc -c]]).
\l -c for command

The [[-m]] flag allows to specify the initialization
script of [[rc]]. I will explain fully the complex initialization
process of [[rc]] and the code of [[rc -m]] 
in Chapter~\ref{chap:initialization-real}.
\l -m for rc_Main probably

%dup: Make.nw
Finally, [[rc]] supports a few options to provide advanced features or
to help debug [[rc]] itself.
%chunks:
I will present gradually those options in this book.
\l see rc.ps

% -l??
% -i => interactive (default when no argument given and isatty, see main())
% -I => not interactive 
%    only diff is prompt not displayed between commands
% -s => debug returned status when error status from subprocess
% -e => stops at first error (called like that from mk)
% -m => change init script? not rcmain but something else?
% -r => debug bytecodes output (convenient)

% Kernel run? init program? init.rc ! where at the end login program?


\section{[[boot.rc]]}

%toc:
In this section, I will present an example of an [[rc]] script 
showing a few features of [[rc]]'s scripting language.
\l rc the program vs the language? should be clear with context. will use rc
\l not tutorial, see books for that.
%trans:
The goal here is to illustrate the general features of a shell
you have seen in Section~\ref{sec:principles} with the concrete
syntax of [[rc]]'s scripting language.
%
This will also help you understand the grammar of [[rc]]
I will present in Chapter~\ref{chap:parsing}.
%
Finally, this example will introduce a few concepts specifics to [[rc]]
that are useful to have in mind while I will explain
the code of [[rc]] in the rest of the document.


[[boot.rc]], below, is the first program executed by the kernel when running
on an ARM machine (see the \book{Kernel}).
%toc:
The following sections will explain the main features of [[rc]]
used in this script.
%
%rc but syntax for those features very similar in other shells.
\n just for variable and list and special var path above

<<kernel/init/user/boot/arm/boot.rc>>=
#!/boot/rc -m /boot/rcmain

/boot/echo booooooooting...

path=(/bin /boot)

# basic devices
bind -c '#e' /env
...

# storage
bind -a '#S' /dev
fdisk -p /dev/sdM0/data >/dev/sdM0/ctl
dossrv
mount -c /srv/dos /root /dev/sdM0/dos
bind -a -c /root /

bind -a /arm/bin /bin
bind -a /rc/bin /bin
...

# to use 5c, 5a, 5l by default in mk
objtype=arm
...

exec /boot/rc -m /boot/rcmain -i
@
%#if (! ~ $#init 0)
%#	exec `{echo $init}
%#if (~ $service cpu)
%#	exec /$cputype/init -c
%#if not
%#	exec /$cputype/init -t


\subsection{[[#!]]}

\begin{verbatim}

%dup: 
% mentioned before?

% shebang! handled by kernel
%history: \unix V8 started to handle that, before was handled by sh itself
% but restricted because you could not exec() a shell script, so it was
% working only when the script was run from a shell

% scripts as regular commands! can become filter. components,
% building blocks!
% Before had to prefix command file with shell name (rc foo)

\n and comment (said later)












\end{verbatim}

\subsection{Initialization script}

\begin{verbatim}

% : [[rc -m]]

% -m, /boot/ because default is /xxx and not accessible at boot time


unix: .profile, .login, etc.








\end{verbatim}

\ref{chap:initialization-real}
\ref{sec:rcmain}

%\subsection{Running commands}

\begin{verbatim}

% execute program qualify full, universal REPL
%  also to echo things need external program! no special support in rc

\end{verbatim}

\subsection{Variables} %$

\begin{verbatim}

% variables list with () and separated by space




\end{verbatim}


\subsection{[[$path]]} %$


\begin{verbatim}

%  and special path variable

% plan9 support union dirs, so path usually small compared
% to Linux. Also no need /usr/bin/env ugly intermediate for #!


\end{verbatim}

\ref{sec:path-management}

\subsection{Comments}

\begin{verbatim}

% so for #! when pass file as argument,
%  parse file and skip this line because comment









\end{verbatim}

\subsection{Quoting and escaping}


\begin{verbatim}

% quote for # otherwise comment, escaping
% also ^?









\end{verbatim}

\ref{sec:quoting}

\subsection{The environment}

\begin{verbatim}

% variables exported to process launch from rc, so objtype
%  convenient for mk










\end{verbatim}

\ref{chap:environment}

\subsection{Builtins}
% : [[exec]]


\begin{verbatim}

% cant be command because modify things in current shell process.
% ex: chdir. As you will see soon, when execute commands,
% fork/exec, so chdir in child will have no effect on further commands.
% chdir modify state of shell!

% exec here is to replace current process by another, here same
% rc but with -i for interactive.

% exec builtin et -i for interactive!
% (not needed otherwise because detect Isatty, not
%  sure why we need it here














\end{verbatim}

\ref{chap:builtins}

\subsection{Other features}

\begin{verbatim}

% pipe, redirection seen before.
% control flow construct, shown before too.

% async, globbing (wildcard), 
% Present gradually in grammar chapter X







\end{verbatim}



%\section{Input shell language}

% run command (obviously), argv
% DSL for pipe, redirection, async, globbing
% mini classic language with control flow statement and variables, globals
% job control? has & but no fg/bg? (but has wait $apid)
% rc PL =~ dynamic
% basic DS = list of strings (List), with operator like ^
%  so different from bash here already. But better basis
%  to have list as core value, because no need PATH=: separator,
%  no need $* vs $@ . Just simpler.
% quite similar to bash
% main difference? for var stuff? 'if not' instead of 'else'.
%grouping! subshell! cool:
%	(for d in utils parsing typing bytecomp asmcomp driver tools/toplevel; \
%         do $(CAMLDEP) $(DEPFLAGS) $$d/*.mli $$d/*.ml; \
%         done) > .depend
% without this would have to do some initial >, and then some >>

%missing:
% - C-z (use multiple windows so no need job control)
% - history (use rio scroll and copy paste)
% - filename completion (use rio)
% - command completion
