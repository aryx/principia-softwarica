\section{[[misc/]]}

\subsection*{[[misc/echo.c]]}

<<function main>>=
void
main(int argc, char *argv[])
{
    int nflag;
    int i, len;
    char *buf, *p;

    nflag = 0;
    if(argc > 1 && strcmp(argv[1], "-n") == 0)
        nflag = 1;

    len = 1;
    for(i = 1+nflag; i < argc; i++)
        len += strlen(argv[i])+1;

    buf = malloc(len);
    if(buf == 0)
        exits("no memory");

    p = buf;
    for(i = 1+nflag; i < argc; i++){
        strcpy(p, argv[i]);
        p += strlen(p);
        if(i < argc-1)
            *p++ = ' ';
    }
        
    if(!nflag)
        *p++ = '\n';

    if(write(1, buf, p-buf) < 0){
        fprint(2, "echo: write error: %r\n");
        exits("write error");
    }

    exits((char *)0);
}
@


%-------------------------------------------------------------

<<misc/echo.c>>=
#include <u.h>
#include <libc.h>

<<function main>>
@


\subsection*{[[misc/pwd.c]]}

<<function main (misc/pwd.c)>>=
/*
 * Print working (current) directory
 */

void
main(int argc, char *argv[])
{
    char pathname[512];

    USED(argc, argv);
    if(getwd(pathname, sizeof(pathname)) == 0) {
        fprint(2, "pwd: %r\n");
        exits("getwd");
    }
    print("%s\n", pathname);
    exits(0);
}
@


%-------------------------------------------------------------

<<misc/pwd.c>>=
#include <u.h>
#include <libc.h>
<<function main (misc/pwd.c)>>
@


\subsection*{[[misc/test.c]]}

<<function EQ>>=
#define EQ(a,b)	((tmp=a)==0?0:(strcmp(tmp,b)==0))
@

<<global ap>>=
int	ap;
@

<<global ac>>=
int	ac;
@

<<global av>>=
char	**av;
@

<<global tmp>>=
static char	*tmp;
@

<<function main (misc/test.c)>>=
void
main(int argc, char *argv[])
{
    int r;
    char *c;

    ac = argc; av = argv; ap = 1;
    if(EQ(argv[0],"[")) {
        if(!EQ(argv[--ac],"]"))
            synbad("] missing","");
    }
    argv[ac] = 0;
    if (ac<=1)
        exits("usage");
    r = e();
    /*
     * nice idea but short-circuit -o and -a operators may have
     * not consumed their right-hand sides.
     */
    if(0 && (c = nxtarg(1)) != nil)
        synbad("unexpected operator/operand: ", c);
    exits(r?0:"false");
}
@

<<function nxtarg>>=
char *
nxtarg(int mt)
{
    if(ap>=ac){
        if(mt){
            ap++;
            return(0);
        }
        synbad("argument expected","");
    }
    return(av[ap++]);
}
@

<<function nxtintarg>>=
int
nxtintarg(int *pans)
{
    if(ap<ac && isint(av[ap], pans)){
        ap++;
        return 1;
    }
    return 0;
}
@

<<function e>>=
int
e(void)
{
    int p1;

    p1 = e1();
    if (EQ(nxtarg(1), "-o"))
        return(p1 || e());
    ap--;
    return(p1);
}
@

<<function e1>>=
int
e1(void)
{
    int p1;

    p1 = e2();
    if (EQ(nxtarg(1), "-a"))
        return (p1 && e1());
    ap--;
    return(p1);
}
@

<<function e2>>=
int
e2(void)
{
    if (EQ(nxtarg(0), "!"))
        return(!e2());
    ap--;
    return(e3());
}
@

<<function e3>>=
int
e3(void)
{
    int p1, int1, int2;
    char *a, *p2;

    a = nxtarg(0);
    if(EQ(a, "(")) {
        p1 = e();
        if(!EQ(nxtarg(0), ")"))
            synbad(") expected","");
        return(p1);
    }

    if(EQ(a, "-A"))
        return(hasmode(nxtarg(0), DMAPPEND));

    if(EQ(a, "-L"))
        return(hasmode(nxtarg(0), DMEXCL));

    if(EQ(a, "-T"))
        return(hasmode(nxtarg(0), DMTMP));

    if(EQ(a, "-f"))
        return(isreg(nxtarg(0)));

    if(EQ(a, "-d"))
        return(isdir(nxtarg(0)));

    if(EQ(a, "-r"))
        return(tio(nxtarg(0), 4));

    if(EQ(a, "-w"))
        return(tio(nxtarg(0), 2));

    if(EQ(a, "-x"))
        return(tio(nxtarg(0), 1));

    if(EQ(a, "-e"))
        return(tio(nxtarg(0), 0));

    if(EQ(a, "-c"))
        return(0);

    if(EQ(a, "-b"))
        return(0);

    if(EQ(a, "-u"))
        return(0);

    if(EQ(a, "-g"))
        return(0);

    if(EQ(a, "-s"))
        return(fsizep(nxtarg(0)));

    if(EQ(a, "-t"))
        if(ap>=ac)
            return(isatty(1));
        else if(nxtintarg(&int1))
            return(isatty(int1));
        else
            synbad("not a valid file descriptor number ", "");

    if(EQ(a, "-n"))
        return(!EQ(nxtarg(0), ""));
    if(EQ(a, "-z"))
        return(EQ(nxtarg(0), ""));

    p2 = nxtarg(1);
    if (p2==0)
        return(!EQ(a,""));
    if(EQ(p2, "="))
        return(EQ(nxtarg(0), a));

    if(EQ(p2, "!="))
        return(!EQ(nxtarg(0), a));

    if(EQ(p2, "-older"))
        return(isolder(nxtarg(0), a));

    if(EQ(p2, "-ot"))
        return(isolderthan(nxtarg(0), a));

    if(EQ(p2, "-nt"))
        return(isnewerthan(nxtarg(0), a));

    if(!isint(a, &int1))
        synbad("unexpected operator/operand: ", p2);

    if(nxtintarg(&int2)){
        if(EQ(p2, "-eq"))
            return(int1==int2);
        if(EQ(p2, "-ne"))
            return(int1!=int2);
        if(EQ(p2, "-gt"))
            return(int1>int2);
        if(EQ(p2, "-lt"))
            return(int1<int2);
        if(EQ(p2, "-ge"))
            return(int1>=int2);
        if(EQ(p2, "-le"))
            return(int1<=int2);
    }

    synbad("unknown operator ",p2);
    return 0;		/* to shut ken up */
}
@

<<function tio>>=
int
tio(char *a, int f)
{
    return access (a, f) >= 0;
}
@

<<function hasmode>>=
/*
 * note that the name strings pointed to by Dir members are
 * allocated with the Dir itself (by the same call to malloc),
 * but are not included in sizeof(Dir), so copying a Dir won't
 * copy the strings it points to.
 */

int
hasmode(char *f, ulong m)
{
    int r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return 0;
    r = (dir->mode & m) != 0;
    free(dir);
    return r;
}
@

<<function isdir>>=
int
isdir(char *f)
{
    return hasmode(f, DMDIR);
}
@

<<function isreg>>=
int
isreg(char *f)
{
    int r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return 0;
    r = (dir->mode & DMDIR) == 0;
    free(dir);
    return r;
}
@

<<function isatty>>=
int
isatty(int fd)
{
    int r;
    Dir *d1, *d2;

    d1 = dirfstat(fd);
    d2 = dirstat("/dev/cons");
    if (d1 == nil || d2 == nil)
        r = 0;
    else
        r = d1->type == d2->type && d1->dev == d2->dev &&
            d1->qid.path == d2->qid.path;
    free(d1);
    free(d2);
    return r;
}
@

<<function fsizep>>=
int
fsizep(char *f)
{
    int r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return 0;
    r = dir->length > 0;
    free(dir);
    return r;
}
@

<<function synbad>>=
void
synbad(char *s1, char *s2)
{
    int len;

    write(2, "test: ", 6);
    if ((len = strlen(s1)) != 0)
        write(2, s1, len);
    if ((len = strlen(s2)) != 0)
        write(2, s2, len);
    write(2, "\n", 1);
    exits("bad syntax");
}
@

<<function isint>>=
int
isint(char *s, int *pans)
{
    char *ep;

    *pans = strtol(s, &ep, 0);
    return (*ep == 0);
}
@

<<function isolder>>=
int
isolder(char *pin, char *f)
{
    int r, rel;
    ulong n, m;
    char *p = pin;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return 0;

    /* parse time */
    n = 0;
    rel = 0;
    while(*p){
        m = strtoul(p, &p, 0);
        switch(*p){
        case 0:
            n = m;
            break;
        case 'y':
            m *= 12;
            /* fall through */
        case 'M':
            m *= 30;
            /* fall through */
        case 'd':
            m *= 24;
            /* fall through */
        case 'h':
            m *= 60;
            /* fall through */
        case 'm':
            m *= 60;
            /* fall through */
        case 's':
            n += m;
            p++;
            rel = 1;
            break;
        default:
            synbad("bad time syntax, ", pin);
        }
    }
    if (!rel)
        m = n;
    else{
        m = time(0);
        if (n > m)		/* before epoch? */
            m = 0;
        else
            m -= n;
    }
    r = dir->mtime < m;
    free(dir);
    return r;
}
@

<<function isolderthan>>=
int
isolderthan(char *a, char *b)
{
    int r;
    Dir *ad, *bd;

    ad = dirstat(a);
    bd = dirstat(b);
    if (ad == nil || bd == nil)
        r = 0;
    else
        r = ad->mtime > bd->mtime;
    free(ad);
    free(bd);
    return r;
}
@

<<function isnewerthan>>=
int
isnewerthan(char *a, char *b)
{
    int r;
    Dir *ad, *bd;

    ad = dirstat(a);
    bd = dirstat(b);
    if (ad == nil || bd == nil)
        r = 0;
    else
        r = ad->mtime < bd->mtime;
    free(ad);
    free(bd);
    return r;
}
@


%-------------------------------------------------------------

<<misc/test.c>>=
/*
 * POSIX standard
 *	test expression
 *	[ expression ]
 *
 * Plan 9 additions:
 *	-A file exists and is append-only
 *	-L file exists and is exclusive-use
 *	-T file exists and is temporary
 */

#include <u.h>
#include <libc.h>

<<function EQ>>

<<global ap>>
<<global ac>>
<<global av>>
<<global tmp>>

void	synbad(char *, char *);
int	fsizep(char *);
int	isdir(char *);
int	isreg(char *);
int	isatty(int);
int	isint(char *, int *);
int	isolder(char *, char *);
int	isolderthan(char *, char *);
int	isnewerthan(char *, char *);
int	hasmode(char *, ulong);
int	tio(char *, int);
int	e(void), e1(void), e2(void), e3(void);
char	*nxtarg(int);

<<function main (misc/test.c)>>

<<function nxtarg>>

<<function nxtintarg>>

<<function e>>

<<function e1>>

<<function e2>>

<<function e3>>

<<function tio>>

<<function hasmode>>

<<function isdir>>

<<function isreg>>

<<function isatty>>

<<function fsizep>>

<<function synbad>>

<<function isint>>

<<function isolder>>

<<function isolderthan>>

<<function isnewerthan>>
@


\section{[[sh/]]}

\subsection*{[[sh/sh.c]]}

<<constant MAXLINE>>=
#define MAXLINE 200		/* maximum line length */
@

<<constant WORD>>=
#define WORD 256		/* token code for words */
@

<<constant EOF>>=
#define EOF -1			/* token code for end of file */
@

<<function ispunct>>=
#define ispunct(c)		(c=='|' || c=='&' || c==';' || c=='<' || \
                 c=='>' || c=='(' || c==')' || c=='\n')
@

<<function isspace>>=
#define isspace(c)		(c==' ' || c=='\t')
@

<<function execute>>=
#define execute(np)		(ignored = (np? (*(np)->op)(np) : 0))
@

<<struct Node>>=
struct Node {			/* parse tree node */
    int (*op)(Node *); 	/* operator function */
    Node *args[2];		/* argument nodes */
    char *argv[100];	/* argument pointers */
    char *io[3];		/* i/o redirection */
};
@

<<global nodes>>=
Node	nodes[25];		/* node pool */
@

<<global nfree>>=
Node	*nfree;			/* next available node */
@

<<global strspace>>=
char	strspace[10*MAXLINE];	/* string storage */
@

<<global sfree>>=
char	*sfree;			/* next free character in strspace */
@

<<global t>>=
int	t;			/* current token code */
@

<<global token>>=
char 	*token;			/* current token text (in strspace) */
@

<<global putback>>=
int	putback = 0;		/* lookahead */
@

<<global status>>=
char	status[256];		/* exit status of most recent command */
@

<<global cflag>>=
int	cflag = 0;		/* command is argument to sh */
@

<<global tflag>>=
int	tflag = 0;		/* read only one line */
@

<<global interactive>>=
int	interactive = 0;	/* prompt */
@

<<global cflagp>>=
char	*cflagp;		/* command line for cflag */
@

<<global path>>=
char	*path[] ={"/bin", 0};
@

<<global ignored>>=
int	ignored;
@

<<function main (sh/sh.c)>>=
void
main(int argc, char *argv[])
{
    Node *np;

    if(argc>1 && strcmp(argv[1], "-t")==0)
        tflag++;
    else if(argc>2 && strcmp(argv[1], "-c")==0){
        cflag++;
        cflagp = argv[2];
    }else if(argc>1){
        close(0);
        if(open(argv[1], 0) != 0){
            error(": can't open", argv[1]);
            exits("argument");
        }
    }else
        interactive = 1;
    for(;;){
        if(interactive)
            fprint(2, "%d$ ", getpid());
        nfree = nodes;
        sfree = strspace;
        if((t=gettoken()) == EOF)
            break;
        if(t != '\n')
            if(np = list())
                execute(np);
            else
                error("syntax error", "");
        while(t!=EOF && t!='\n')	/* flush syntax errors */
            t = gettoken();
    }
    exits(status);
}
@

<<function alloc>>=
/* alloc - allocate for op and return a node */
Node*
alloc(int (*op)(Node *))
{
    if(nfree < nodes+sizeof(nodes)){
        nfree->op = op;
        nfree->args[0] = nfree->args[1] = 0;
        nfree->argv[0] = nfree->argv[1] = 0;
        nfree->io[0] = nfree->io[1] = nfree->io[2] = 0;
        return nfree++;
    }
    error("node storage overflow", "");
    exits("node storage overflow");
    return nil;
}
@

<<function builtin>>=
/* builtin - check np for builtin command and, if found, execute it */
int
builtin(Node *np)
{
    int n = 0;
    char name[MAXLINE];
    Waitmsg *wmsg;

    if(np->argv[1])
        n = strtoul(np->argv[1], 0, 0);
    if(strcmp(np->argv[0], "cd") == 0){
        if(chdir(np->argv[1]? np->argv[1] : "/") == -1)
            error(": bad directory", np->argv[0]);
        return 1;
    }else if(strcmp(np->argv[0], "exit") == 0)
        exits(np->argv[1]? np->argv[1] : status);
    else if(strcmp(np->argv[0], "bind") == 0){
        if(np->argv[1]==0 || np->argv[2]==0)
            error("usage: bind new old", "");
        else if(bind(np->argv[1], np->argv[2], 0)==-1)
            error("bind failed", "");
        return 1;
//#ifdef asdf
//	}else if(strcmp(np->argv[0], "unmount") == 0){
//		if(np->argv[1] == 0)
//			error("usage: unmount [new] old", "");
//		else if(np->argv[2] == 0){
//			if(unmount((char *)0, np->argv[1]) == -1)
//				error("unmount:", "");
//		}else if(unmount(np->argv[1], np->argv[2]) == -1)
//			error("unmount", "");
//		return 1;
//#endif
    }else if(strcmp(np->argv[0], "wait") == 0){
        while((wmsg = wait()) != nil){
            strncpy(status, wmsg->msg, sizeof(status)-1);
            if(n && wmsg->pid==n){
                n = 0;
                free(wmsg);
                break;
            }
            free(wmsg);
        }
        if(n)
            error("wait error", "");
        return 1;
    }else if(strcmp(np->argv[0], "rfork") == 0){
        char *p;
        int mask;

        p = np->argv[1];
        if(p == 0 || *p == 0)
            p = "ens";
        mask = 0;

        while(*p)
            switch(*p++){
            case 'n': mask |= RFNAMEG; break;
            case 'N': mask |= RFCNAMEG; break;
            case 'e': mask |= RFENVG; break;
            case 'E': mask |= RFCENVG; break;
            case 's': mask |= RFNOTEG; break;
            case 'f': mask |= RFFDG; break;
            case 'F': mask |= RFCFDG; break;
            case 'm': mask |= RFNOMNT; break;
            default: error(np->argv[1], "bad rfork flag");
            }
        rfork(mask);

        return 1;
    }else if(strcmp(np->argv[0], "exec") == 0){
        redirect(np);
        if(np->argv[1] == (char *) 0)
            return 1;
        exec(np->argv[1], &np->argv[1]);
        n = np->argv[1][0];
        if(n!='/' && n!='#' && (n!='.' || np->argv[1][1]!='/'))
            for(n = 0; path[n]; n++){
                sprint(name, "%s/%s", path[n], np->argv[1]);
                exec(name, &np->argv[1]);
            }
        error(": not found", np->argv[1]);
        return 1;
    }
    return 0;
}
@

<<function command>>=
/* command - ( list ) [ ( < | > | >> ) word ]* | simple */
Node*
command(void)
{
    Node *np;

    if(t != '(')
        return simple();
    np = alloc(xsubshell);
    t = gettoken();
    if((np->args[0]=list())==0 || t!=')')
        return 0;
    while((t=gettoken())=='<' || t=='>')
        if(!setio(np))
            return 0;
    return np;
}
@

<<function getch>>=
/* getch - get next, possibly pushed back, input character */
int
getch(void)
{
    unsigned char c;
    static int done=0;

    if(putback){
        c = putback;
        putback = 0;
    }else if(tflag){
        if(done || read(0, &c, 1)!=1){
            done = 1;
            return EOF;
        }
        if(c == '\n')
            done = 1;
    }else if(cflag){
        if(done)
            return EOF;
        if((c=*cflagp++) == 0){
            done = 1;
            c = '\n';
        }
    }else if(read(0, &c, 1) != 1)
        return EOF;
    return c;
}
@

<<function gettoken>>=
/* gettoken - get next token into string space, return token code */
int
gettoken(void)
{
    int c;

    while((c = getch()) != EOF)
        if(!isspace(c))
            break;
    if(c==EOF || ispunct(c))
        return c;
    token = sfree;
    do{
        if(sfree >= strspace+sizeof(strspace) - 1){
            error("string storage overflow", "");
            exits("string storage overflow");
        }
        *sfree++ = c;
    }while((c=getch()) != EOF && !ispunct(c) && !isspace(c));
    *sfree++ = 0;
    putback = c;
    return WORD;
}
@

<<function list>>=
/* list - pipeline ( ( ; | & ) pipeline )* [ ; | & ]  (not LL(1), but ok) */
Node*
list(void)
{
    Node *np, *np1;

    np = alloc(0);
    if((np->args[1]=pipeline()) == 0)
        return 0;
    while(t==';' || t=='&'){
        np->op = (t==';')? xwait : xnowait;
        t = gettoken();
        if(t==')' || t=='\n')	/* tests ~first(pipeline) */
            break;
        np1 = alloc(0);
        np1->args[0] = np;
        if((np1->args[1]=pipeline()) == 0)
            return 0;
        np = np1;
    }
    if(np->op == 0)
        np->op = xwait;
    return np;
}
@

<<function error>>=
/* error - print error message s, prefixed by t */
void
error(char *s, char *t)
{
    char buf[256];

    fprint(2, "%s%s", t, s);
    errstr(buf, sizeof buf);
    fprint(2, ": %s\n", buf);
}
@

<<function pipeline>>=
/* pipeline - command ( | command )* */
Node*
pipeline(void)
{
    Node *np, *np1;

    if((np=command()) == 0)
        return 0;
    while(t == '|'){
        np1 = alloc(xpipeline);
        np1->args[0] = np;
        t = gettoken();
        if((np1->args[1]=command()) == 0)
            return 0;
        np = np1;
    }
    return np;
}
@

<<function redirect>>=
/* redirect - redirect i/o according to np->io[] values */
void
redirect(Node *np)
{
    int fd;

    if(np->io[0]){
        if((fd = open(np->io[0], 0)) < 0){
            error(": can't open", np->io[0]);
            exits("open");
        }
        dup(fd, 0);
        close(fd);
    }
    if(np->io[1]){
        if((fd = create(np->io[1], 1, 0666L)) < 0){
            error(": can't create", np->io[1]);
            exits("create");
        }
        dup(fd, 1);
        close(fd);
    }
    if(np->io[2]){
        if((fd = open(np->io[2], 1)) < 0 && (fd = create(np->io[2], 1, 0666L)) < 0){
            error(": can't write", np->io[2]);
            exits("write");
        }
        dup(fd, 1);
        close(fd);
        seek(1, 0, 2);
    }
}
@

<<function setio>>=
/* setio - ( < | > | >> ) word; fill in np->io[] */
int
setio(Node *np)
{
    if(t == '<'){
        t = gettoken();
        np->io[0] = token;
    }else if(t == '>'){
        t = gettoken();
        if(t == '>'){
            t = gettoken();
            np->io[2] = token;
            }else
            np->io[1] = token;
    }else
        return 0;
    if(t != WORD)
        return 0;
    return 1;
}
@

<<function simple>>=
/* simple - word ( [ < | > | >> ] word )* */
Node*
simple(void)
{
    Node *np;
    int n = 1;

    if(t != WORD)
        return 0;
    np = alloc(xsimple);
    np->argv[0] = token;
    while((t = gettoken())==WORD || t=='<' || t=='>')
        if(t == WORD)
            np->argv[n++] = token;
        else if(!setio(np))
            return 0;
    np->argv[n] = 0;
    return np;
}
@

<<function xpipeline>>=
/* xpipeline - execute cmd | cmd */
int
xpipeline(Node *np)
{
    int pid, fd[2];

    if(pipe(fd) < 0){
        error("can't create pipe", "");
        return 0;
    }
    if((pid=fork()) == 0){	/* left side; redirect stdout */
        dup(fd[1], 1);
        close(fd[0]);
        close(fd[1]);
        execute(np->args[0]);
        exits(status);
    }else if(pid == -1){
        error("can't create process", "");
        return 0;
    }
    if((pid=fork()) == 0){	/* right side; redirect stdin */
        dup(fd[0], 0);
        close(fd[0]);
        close(fd[1]);
        pid = execute(np->args[1]); /*BUG: this is wrong sometimes*/
        if(pid > 0)
            while(waitpid()!=pid)
                ;
        exits(0);
    }else if(pid == -1){
        error("can't create process", "");
        return 0;
    }
    close(fd[0]);	/* avoid using up fd's */
    close(fd[1]);
    return pid;
}
@

<<function xsimple>>=
/* xsimple - execute a simple command */
int
xsimple(Node *np)
{
    char name[MAXLINE];
    int pid, i;

    if(builtin(np))
        return 0;
    if(pid = fork()){
        if(pid == -1)
            error(": can't create process", np->argv[0]);
        return pid;
    }
    redirect(np);	/* child process */
    exec(np->argv[0], &np->argv[0]);
    i = np->argv[0][0];
    if(i!='/' && i!='#' && (i!='.' || np->argv[0][1]!='/'))
        for(i = 0; path[i]; i++){
            sprint(name, "%s/%s", path[i], np->argv[0]);
            exec(name, &np->argv[0]);
        }
    error(": not found", np->argv[0]);
    exits("not found");
    return -1;		// suppress compiler warnings
}
@

<<function xsubshell>>=
/* xsubshell - execute (cmd) */
int
xsubshell(Node *np)
{
    int pid;

    if(pid = fork()){
        if(pid == -1)
            error("can't create process", "");
        return pid;
    }
    redirect(np);	/* child process */
    execute(np->args[0]);
    exits(status);
    return -1;		// suppress compiler warnings
}
@

<<function xnowait>>=
/* xnowait - execute cmd & */
int
xnowait(Node *np)
{
    int pid;

    execute(np->args[0]);
    pid = execute(np->args[1]);
    if(interactive)
        fprint(2, "%d\n", pid);
    return 0;
}
@

<<function xwait>>=
/* xwait - execute cmd ; */
int xwait(Node *np)
{
    int pid;
    Waitmsg *wmsg;

    execute(np->args[0]);
    pid = execute(np->args[1]);
    if(pid > 0){
        while((wmsg = wait()) != nil){
            if(wmsg->pid == pid)
                break;
            free(wmsg);
        }
        if(wmsg == nil)
            error("wait error", "");
        else {
            strncpy(status, wmsg->msg, sizeof(status)-1);
            free(wmsg);
        }
    }
    return 0;
}
@


%-------------------------------------------------------------

<<sh/sh.c>>=
/* sh - simple shell - great for early stages of porting */
#include <u.h>
#include <libc.h>

<<constant MAXLINE>>
<<constant WORD>>
<<constant EOF>>
<<function ispunct>>
<<function isspace>>
<<function execute>>

typedef struct Node	Node;
<<struct Node>>

<<global nodes>>
<<global nfree>>
<<global strspace>>
<<global sfree>>
<<global t>>
<<global token>>
<<global putback>>
<<global status>>
<<global cflag>>
<<global tflag>>
<<global interactive>>
<<global cflagp>>
<<global path>>
<<global ignored>>

Node	*alloc(int (*op)(Node *));
int	builtin(Node *np);
Node	*command(void);
int	getch(void);
int	gettoken(void);
Node	*list(void);
void	error(char *s, char *t);
Node	*pipeline(void);
void	redirect(Node *np);
int	setio(Node *np);
Node	*simple(void);
int	xpipeline(Node *np);
int	xsimple(Node *np);
int	xsubshell(Node *np);
int	xnowait(Node *np);
int	xwait(Node *np);

<<function main (sh/sh.c)>>

<<function alloc>>

<<function builtin>>

<<function command>>

<<function getch>>

<<function gettoken>>

<<function list>>

<<function error>>

<<function pipeline>>

<<function redirect>>

<<function setio>>
            
<<function simple>>

<<function xpipeline>>

<<function xsimple>>

<<function xsubshell>>

<<function xnowait>>

<<function xwait>>
@


\section{[[rc/]]}

\subsection*{[[rc/fns.h]]}

%-------------------------------------------------------------

<<rc/fns.h>>=
void	Abort(void);
void	Closedir(int);
int	Creat(char*);
int	Dup(int, int);
int	Dup1(int);
int	Eintr(void);
int	Executable(char*);
void	Execute(word*,  word*);
void	Exit(char*);
int	Globsize(char*);
int	Isatty(int);
void	Memcpy(void*, void*, long);
void	Noerror(void);
int	Opendir(char*);
long	Read(int, void*, long);
int	Readdir(int, void*, int);
long	Seek(int, long, long);
void	Trapinit(void);
void	Unlink(char*);
void	Updenv(void);
void	Vinit(void);
int	Waitfor(int, int);
long	Write(int, void*, long);

void	addwaitpid(int);
int	advance(void);
void	cleanhere(char*);
void	codefree(code*);
int	compile(tree*);
int	count(word*);
void	deglob(void*);
void	dotrap(void);
void	freenodes(void);
void	freewords(word*);
void	globlist(void);
int	idchr(int);
void	inttoascii(char*, long);
void	kinit(void);
int	match(void*, void*, int);
void	clearwaitpids(void);
void	panic(char*, int);
void	poplist(void);
void	popword(void);
void	pprompt(void);
void	pushlist(void);
void	pushredir(int, int, int);
void	pushword(char*);
void	readhere(void);
void	setstatus(char*);
void	setvar(char*, word*);
//@Scheck: used in syn.y
void	skipnl(void);
void	start(code*, int, var*);
int	truestatus(void);
void	usage(char*);
void	yyerror(char*);
int	yylex(void);
//@Scheck: defined in syn.y and y.tab.c
int	yyparse(void);
@


\subsection*{[[rc/getflags.h]]}



%-------------------------------------------------------------

<<rc/getflags.h>>=
<<constant NFLAG>>

extern char **flag[NFLAG];
extern char *flagset[];

int getflags(int, char*[], char*, int);
@


\subsection*{[[rc/io.h]]}

%-------------------------------------------------------------

<<rc/io.h>>=
<<constant EOF (rc/io.h)>>
<<constant NBUF>>

<<struct io>>

extern io *err;

io *openfd(int);
io *openstr(void);
io *opencore(char *, int);
void pchr(io*, int);
int rchr(io*);
int rutf(io*, char*, Rune*);
void closeio(io*);
void flush(io*);
void pstr(io*, char*);
void pcmd(io*, tree*);
void pfnc(io*, thread*);
void pfmt(io*, char*, ...);
@


\subsection*{[[rc/rc.h]]}




% TODO enum!! redirection_kind?
<<constant APPEND>>=
#define	APPEND	1
@

<<constant WRITE>>=
#define	WRITE	2
@

<<constant READ>>=
#define	READ	3
@

<<constant HERE>>=
#define	HERE	4
@

<<constant DUPFD>>=
#define	DUPFD	5
@

<<constant CLOSE>>=
#define	CLOSE	6
@

<<constant RDWR>>=
#define RDWR	7
@



<<constant GLOB>>=
/*
 * Glob character escape in strings:
 *	In a string, GLOB must be followed by *?[ or GLOB.
 *	GLOB* matches any string
 *	GLOB? matches any single character
 *	GLOB[...] matches anything in the brackets
 *	GLOBGLOB matches GLOB
 */
#define	GLOB	'\001'
@

<<constant PRD>>=
/*
 * Which fds are the reading/writing end of a pipe?
 * Unfortunately, this can vary from system to system.
 * 9th edition Unix doesn't care, the following defines
 * work on plan 9.
 */
#define	PRD	0
@

<<constant PWR>>=
#define	PWR	1
@


%-------------------------------------------------------------

<<rc/rc.h>>=
/*
 * Assume plan 9 by default; if Unix is defined, assume unix.
 * Please don't litter the code with ifdefs.  The five below should be enough.
 */

//#ifndef Unix
/* plan 9 */
#include <u.h>
#include <libc.h>

<<constant NSIG>>
<<constant SIGINT>>
<<constant SIGQUIT>>

//#define fcntl(fd, op, arg) /* unix compatibility */
//#define F_SETFD  
//#define FD_CLOEXEC 

//#else
//#include "unix.h"
//#endif

#ifndef ERRMAX
<<constant ERRMAX>>
#endif

<<constant YYMAXDEPTH>>

//#ifndef YYPREFIX
#ifndef PAREN
//#include "x.tab.h"
//pad: better like that, otherwise get some "redefined FOR macro" error
#endif
//#endif

typedef struct Tree tree;
typedef struct Word word;
typedef struct Io io;
typedef union Code code;
typedef struct Var var;
typedef struct List list;
typedef struct Redir redir;
typedef struct Thread thread;
typedef struct Builtin builtin;

//#ifndef Unix
#pragma incomplete word
#pragma incomplete io
//#endif

<<struct tree>>

tree *newtree(void);
tree *token(char*, int);
tree *klook(char*);
//@Scheck: useful, for syn.y, and not just for tree.c
tree *tree1(int, tree*);
tree *tree2(int, tree*, tree*);
//@Scheck: useful, for syn.y, and not just for tree.c
tree *tree3(int, tree*, tree*, tree*);
tree *mung1(tree*, tree*);
tree *mung2(tree*, tree*, tree*);
tree *mung3(tree*, tree*, tree*, tree*);
tree *epimung(tree*, tree*);
tree *simplemung(tree*);
tree *heredoc(tree*);


<<struct code>>

extern char *promptstr;
extern bool doprompt;

<<constant NTOK>>

extern char tok[NTOK + UTFmax];

<<constant APPEND>>
<<constant WRITE>>
<<constant READ>>
<<constant HERE>>
<<constant DUPFD>>
<<constant CLOSE>>
<<constant RDWR>>

<<struct var>>

var *vlook(char*);
var *gvlook(char*);
var *newvar(char*, var*);

<<constant NVAR>>

extern var *gvar[NVAR];		/* hash for globals */

#define	new(type)	((type *)emalloc(sizeof(type)))

void *emalloc(long);
void *Malloc(ulong);
void efree(void *);

<<struct here>>
extern int mypid;

<<constant GLOB>>

extern int nerror;		/* number of errors encountered during compilation */
<<constant PRD>>
<<constant PWR>>

extern char *Rcmain, *Fdprefix;
extern int ndot;
char *getstatus(void);

extern int lastc;
extern bool lastword;

@


\subsection*{[[rc/exec.h]]}


<<constant NSTATUS>>=
#define	NSTATUS	ERRMAX			/* length of status (from plan 9) */
@

<<constant ROPEN>>=
/*
 * redir types
 */
#define	ROPEN	1			/* dup2(from, to); close(from); */
@

<<constant RDUP>>=
#define	RDUP	2			/* dup2(from, to); */
@

<<constant RCLOSE>>=
#define	RCLOSE	3			/* close(from); */
@


<<struct builtin>>=
struct Builtin {
    char *name;
    void (*fnc)(void);
};
@


%-------------------------------------------------------------

<<rc/exec.h>>=
/*
 * Definitions used in the interpreter
 */
extern void Xappend(void), Xasync(void), Xbackq(void), Xbang(void), Xclose(void);
extern void Xconc(void), Xcount(void), Xdelfn(void), Xdol(void), Xqdol(void), Xdup(void);
extern void Xexit(void), Xfalse(void), Xfn(void), Xfor(void), Xglob(void);
extern void Xjump(void), Xmark(void), Xmatch(void), Xpipe(void), Xread(void);
extern void Xrdwr(void);
extern void Xrdfn(void), Xreturn(void), Xsubshell(void);
extern void Xtrue(void), Xword(void), Xwrite(void), Xpipefd(void), Xcase(void);
extern void Xlocal(void), Xunlocal(void), Xassign(void), Xsimple(void), Xpopm(void);
extern void Xrdcmds(void), Xwastrue(void), Xif(void), Xifnot(void), Xpipewait(void);
extern void Xdelhere(void), Xpopredir(void), Xsub(void), Xeflag(void), Xsettrue(void);
extern void Xerror(char*);
extern void Xerror1(char*);

<<struct word>>
<<struct list>>
word *newword(char *, word *);
word *copywords(word *, word *);

<<struct redir>>

<<constant NSTATUS>>
<<constant ROPEN>>
<<constant RDUP>>
<<constant RCLOSE>>
<<struct thread>>

code *codecopy(code*);

extern thread *runq;
extern code *codebuf;				/* compiler output */
extern int ntrap;				/* number of outstanding traps */
extern int trap[NSIG];				/* number of outstanding traps per type */
extern bool eflagok;			/* kludge flag so that -e doesn't exit in startup */
extern bool havefork;

<<struct builtin>>
extern struct Builtin Builtin[];

void execcd(void);
void execwhatis(void);
void execeval(void);
void execexec(void);
int  execforkexec(void);
void execexit(void);
void execshift(void);
void execwait(void);
void execdot(void);
void execflag(void);
void execcmds(io *);
@


\subsection*{[[rc/globals.c]]}


<<globals.c>>=
#include "rc.h"
#include "exec.h"

// was in rc.h
<<global tok>>
<<global lastc>>
<<global mypid>>
<<global gvar>>
<<global ndot>>
<<global promptstr>>
<<global nerror>>
<<global err>>

// was in exec.h
<<global runq>>
<<global codebuf>>
<<global ntrap>>
<<global trap>>
<<global eflagok>>

@

\subsection*{[[rc/getflags.c]]}



<<global cmdname>>=
char *cmdname;
@

<<global flagarg>>=
static char *flagarg="";
@




<<global reason>>=
static int reason;
@

<<constant RESET>>=
#define	RESET	1
@

<<constant FEWARGS>>=
#define	FEWARGS	2
@

<<constant FLAGSYN>>=
#define	FLAGSYN	3
@

<<constant BADFLAG>>=
#define	BADFLAG	4
@

<<global badflag>>=
static int badflag;
@

<<function getflags>>=
int
getflags(int argc, char *argv[], char *flags, int stop)
{
    char *s;
    int i, j, c, count;
    flagarg = flags;
    if(cmdname==0)
        cmdname = argv[0];

    i = 1;
    while(i!=argc){
        if(argv[i][0] != '-' || argv[i][1] == '\0'){
            if(stop)		/* always true in rc */
                return argc;
            i++;
            continue;
        }
        s = argv[i]+1;
        while(*s){
            c=*s++;
            count = scanflag(c, flags);
            if(count==-1)
                return -1;
            if(flag[c]){ reason = RESET; badflag = c; return -1; }
            if(count==0){
                flag[c] = flagset;
                if(*s=='\0'){
                    for(j = i+1;j<=argc;j++)
                        argv[j-1] = argv[j];
                    --argc;
                }
            }
            else{
                if(*s=='\0'){
                    for(j = i+1;j<=argc;j++)
                        argv[j-1] = argv[j];
                    --argc;
                    s = argv[i];
                }
                if(argc-i<count){
                    reason = FEWARGS;
                    badflag = c;
                    return -1;
                }
                reverse(argv+i, argv+argc);
                reverse(argv+i, argv+argc-count);
                reverse(argv+argc-count+1, argv+argc);
                argc-=count;
                flag[c] = argv+argc+1;
                flag[c][0] = s;
                s="";
            }
        }
    }
    return argc;
}
@

<<function reverse>>=
static void
reverse(char **p, char **q)
{
    char *t;
    for(;p<q;p++,--q){ t=*p; *p=*q; *q = t; }
}
@

<<function scanflag>>=
static int
scanflag(int c, char *f)
{
    int fc, count;
    if(0<=c && c<NFLAG)
        while(*f){
            if(*f==' '){
                f++;
                continue;
            }
            fc=*f++;
            if(*f==':'){
                f++;
                if(*f<'0' || '9'<*f){ reason = FLAGSYN; return -1; }
                count = 0;
                while('0'<=*f && *f<='9') count = count*10+*f++-'0';
            }
            else
                count = 0;
            if(*f=='['){
                do{
                    f++;
                    if(*f=='\0'){ reason = FLAGSYN; return -1; }
                }while(*f!=']');
                f++;
            }
            if(c==fc)
                return count;
        }
    reason = BADFLAG;
    badflag = c;
    return -1;
}
@

<<function usage>>=
void
usage(char *tail)
{
    char *s, *t, c;
    int count, nflag = 0;
    switch(reason){
    case RESET:
        errs("Flag -");
        errc(badflag);
        errs(": set twice\n");
        break;
    case FEWARGS:
        errs("Flag -");
        errc(badflag);
        errs(": too few arguments\n");
        break;
    case FLAGSYN:
        errs("Bad argument to getflags!\n");
        break;
    case BADFLAG:
        errs("Illegal flag -");
        errc(badflag);
        errc('\n');
        break;
    }
    errs("Usage: ");
    errs(cmdname);
    for(s = flagarg;*s;){
        c=*s;
        if(*s++==' ')
            continue;
        if(*s==':'){
            s++;
            count = 0;
            while('0'<=*s && *s<='9') count = count*10+*s++-'0';
        }
        else count = 0;
        if(count==0){
            if(nflag==0)
                errs(" [-");
            nflag++;
            errc(c);
        }
        if(*s=='['){
            s++;
            while(*s!=']' && *s!='\0') s++;
            if(*s==']')
                s++;
        }
    }
    if(nflag)
        errs("]");
    for(s = flagarg;*s;){
        c=*s;
        if(*s++==' ')
            continue;
        if(*s==':'){
            s++;
            count = 0;
            while('0'<=*s && *s<='9') count = count*10+*s++-'0';
        }
        else count = 0;
        if(count!=0){
            errs(" [-");
            errc(c);
            if(*s=='['){
                s++;
                t = s;
                while(*s!=']' && *s!='\0') s++;
                errs(" ");
                errn(t, s-t);
                if(*s==']')
                    s++;
            }
            else
                while(count--) errs(" arg");
            errs("]");
        }
        else if(*s=='['){
            s++;
            while(*s!=']' && *s!='\0') s++;
            if(*s==']')
                s++;
        }
    }
    if(tail){
        errs(" ");
        errs(tail);
    }
    errs("\n");
    Exit("bad flags");
}
@

<<function errn>>=
static void
errn(char *s, int count)
{
    while(count){ errc(*s++); --count; }
}
@

<<function errs>>=
static void
errs(char *s)
{
    while(*s) errc(*s++);
}
@

<<constant NBUF (rc/getflags.c)>>=
#define	NBUF	80
@

<<function errc>>=
static void
errc(int c)
{
    *bufp++=c;
    if(bufp==&buf[NBUF] || c=='\n'){
        Write(2, buf, bufp-buf);
        bufp = buf;
    }
}
@


%-------------------------------------------------------------

<<rc/getflags.c>>=
#include "rc.h"
#include "getflags.h"
#include "fns.h"

static void reverse(char**, char**);
static int scanflag(int, char*);
static void errn(char*, int);
static void errs(char*);
static void errc(int);

<<global flagset>>
<<global flag>>
<<global cmdname>>
<<global flagarg>>
<<global reason>>

<<constant RESET>>
<<constant FEWARGS>>
<<constant FLAGSYN>>
<<constant BADFLAG>>

<<global badflag>>

<<function getflags>>

<<function reverse>>

<<function scanflag>>

<<function usage>>

<<function errn>>

<<function errs>>
<<constant NBUF (rc/getflags.c)>>
static char buf[NBUF], *bufp = buf;

<<function errc>>
@


\subsection*{[[rc/io.c]]}


<<function pchr>>=
void
pchr(io *b, int c)
{
    if(b->bufp==b->ebuf)
        fullbuf(b, c);
    else *b->bufp++=c;
}
@

<<function rchr>>=
int
rchr(io *b)
{
    if(b->bufp==b->ebuf)
        return emptybuf(b);
    return *b->bufp++;
}
@

<<function rutf>>=
int
rutf(io *b, char *buf, Rune *r)
{
    int n, i, c;

    c = rchr(b);
    if(c == EOF)
        return EOF;
    *buf = c;
    if(c < Runesync){
        *r = c;
        return 1;
    }
    for(i = 1; (c = rchr(b)) != EOF; ){
        buf[i++] = c;
        buf[i] = 0;
        if(fullrune(buf, i)){
            n = chartorune(r, buf);
            b->bufp -= i - n;	/* push back unconsumed bytes */
            assert(b->fd == -1 || b->bufp > b->buf);
            return n;
        }
    }
    /* at eof */
    b->bufp -= i - 1;			/* consume 1 byte */
    *r = Runeerror;
    return runetochar(buf, r);
}
@

<<function pquo>>=
void
pquo(io *f, char *s)
{
    pchr(f, '\'');
    for(;*s;s++)
        if(*s=='\'')
            pfmt(f, "''");
        else pchr(f, *s);
    pchr(f, '\'');
}
@

<<function pwrd>>=
void
pwrd(io *f, char *s)
{
    char *t;
    for(t = s;*t;t++) if(*t >= 0 && needsrcquote(*t)) break;
    if(t==s || *t)
        pquo(f, s);
    else pstr(f, s);
}
@

<<function pptr>>=
void
pptr(io *f, void *v)
{
    int n;
    uintptr p;

    p = (uintptr)v;
    if(sizeof(uintptr) == sizeof(uvlong) && p>>32)
        for(n = 60;n>=32;n-=4) pchr(f, "0123456789ABCDEF"[(p>>n)&0xF]);

    for(n = 28;n>=0;n-=4) pchr(f, "0123456789ABCDEF"[(p>>n)&0xF]);
}
@

<<function pstr>>=
void
pstr(io *f, char *s)
{
    if(s==0)
        s="(null)";
    while(*s) pchr(f, *s++);
}
@

<<function pdec>>=
void
pdec(io *f, int n)
{
    if(n<0){
        n=-n;
        if(n>=0){
            pchr(f, '-');
            pdec(f, n);
            return;
        }
        /* n is two's complement minimum integer */
        n = 1-n;
        pchr(f, '-');
        pdec(f, n/10);
        pchr(f, n%10+'1');
        return;
    }
    if(n>9)
        pdec(f, n/10);
    pchr(f, n%10+'0');
}
@

<<function poct>>=
void
poct(io *f, unsigned n)
{
    if(n>7)
        poct(f, n>>3);
    pchr(f, (n&7)+'0');
}
@

<<function pval>>=
void
pval(io *f, word *a)
{
    if(a){
        while(a->next && a->next->word){
            pwrd(f, (char *)a->word);
            pchr(f, ' ');
            a = a->next;
        }
        pwrd(f, (char *)a->word);
    }
}
@

<<function fullbuf>>=
int
fullbuf(io *f, int c)
{
    flush(f);
    return *f->bufp++=c;
}
@



<<function openstr>>=
io*
openstr(void)
{
    io *f = new(struct Io);

    f->fd = -1;
    f->bufp = f->strp = emalloc(Stralloc+1);
    f->ebuf = f->bufp + Stralloc;
    memset(f->bufp, '\0', Stralloc+1);
    return f;
}
@

<<function opencore>>=
/*
 * Open a corebuffer to read.  EOF occurs after reading len
 * characters from buf.
 */

io*
opencore(char *s, int len)
{
    io *f = new(struct Io);
    uchar *buf = emalloc(len);

    f->fd = -1 /*open("/dev/null", 0)*/;
    f->bufp = f->strp = buf;
    f->ebuf = buf+len;
    Memcpy(buf, s, len);
    return f;
}
@

<<function closeio>>=
void
closeio(io *io)
{
    if(io->fd>=0)
        close(io->fd);
    if(io->strp)
        efree(io->strp);
    efree(io);
}
@

<<function emptybuf>>=
int
emptybuf(io *f)
{
    int n;
    if(f->fd==-1 || (n = Read(f->fd, f->buf, NBUF))<=0) return EOF;
    f->bufp = f->buf;
    f->ebuf = f->buf + n;
    return *f->bufp++;
}
@


%-------------------------------------------------------------

<<rc/io.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

<<enum _anon_>>

<<global pfmtnest>>

int emptybuf(io*);
int fullbuf(io*, int);
void pdec(io*, int);
void poct(io*, unsigned);
void pptr(io*, void*);
void pval(io*, word*);
void pquo(io*, char*);
void pwrd(io*, char*);


<<function pfmt>>

<<function pchr>>

<<function rchr>>

<<function rutf>>

<<function pquo>>

<<function pwrd>>

<<function pptr>>

<<function pstr>>

<<function pdec>>

<<function poct>>

<<function pval>>

<<function fullbuf>>

<<function flush>>

<<function openfd>>

<<function openstr>>
<<function opencore>>

<<function closeio>>

<<function emptybuf>>
@


\subsection*{[[rc/var.c]]}



%-------------------------------------------------------------

<<rc/var.c>>=
#include "rc.h"
#include "exec.h"
#include "fns.h"
#include "x.tab.h"

<<function hash>>

<<constant NKW>>
<<global kw>>

<<function kenter>>

<<function kinit>>

<<function klook>>

<<function gvlook>>

<<function vlook>>

<<function setvar>>
@


\subsection*{[[rc/subr.c]]}


%-------------------------------------------------------------

<<rc/subr.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

<<function emalloc>>

<<function efree>>
extern bool lastword;
extern bool lastdol;

<<function yyerror>>
<<global bp>>

<<function iacvt>>

<<function inttoascii>>

<<function panic>>
@


\subsection*{[[rc/plan9.c]]}

<<enum _anon_ (rc/plan9.c)>>=
enum {
    Maxenvname = 256,	/* undocumented limit */
};
@


<<global Fdprefix>>=
char *Fdprefix = "/fd/";
@


<<function Vinit>>=
void
Vinit(void)
{
    int dir, f, len, i, n, nent;
    char *buf, *s;
    char envname[Maxenvname];
    word *val;
    Dir *ent;

    dir = open("/env", OREAD);
    if(dir<0){
        pfmt(err, "rc: can't open /env: %r\n");
        return;
    }
    ent = nil;
    for(;;){
        nent = dirread(dir, &ent);
        if(nent <= 0)
            break;
        for(i = 0; i<nent; i++){
            len = ent[i].length;
            if(len && strncmp(ent[i].name, "fn#", 3)!=0){
                snprint(envname, sizeof envname, "/env/%s", ent[i].name);
                if((f = open(envname, 0))>=0){
                    buf = emalloc(len+1);
                    n = readn(f, buf, len);
                    if (n <= 0)
                        buf[0] = '\0';
                    else
                        buf[n] = '\0';
                    val = 0;
                    /* Charitably add a 0 at the end if need be */
                    if(buf[len-1])
                        buf[len++]='\0';
                    s = buf+len-1;
                    for(;;){
                        while(s!=buf && s[-1]!='\0') --s;
                        val = newword(s, val);
                        if(s==buf)
                            break;
                        --s;
                    }
                    setvar(ent[i].name, val);
                    vlook(ent[i].name)->changed = false;
                    close(f);
                    efree(buf);
                }
            }
        }
        free(ent);
    }
    close(dir);
}
@

<<global envdir>>=
int envdir;
@

<<function Xrdfn>>=
void
Xrdfn(void)
{
    int f, len;
    Dir *e;
    char envname[Maxenvname];
    static Dir *ent, *allocent;
    static int nent;

    for(;;){
        if(nent == 0){
            free(allocent);
            nent = dirread(envdir, &allocent);
            ent = allocent;
        }
        if(nent <= 0)
            break;
        while(nent){
            e = ent++;
            nent--;
            len = e->length;
            if(len && strncmp(e->name, "fn#", 3)==0){
                snprint(envname, sizeof envname, "/env/%s", e->name);
                if((f = open(envname, 0))>=0){
                    execcmds(openfd(f));
                    return;
                }
            }
        }
    }
    close(envdir);
    Xreturn();
}
@

<<global rdfns>>=
union Code rdfns[4];
@

<<function execfinit>>=
void
execfinit(void)
{
    static int first = 1;
    if(first){
        rdfns[0].i = 1;
        rdfns[1].f = Xrdfn;
        rdfns[2].f = Xjump;
        rdfns[3].i = 1;
        first = 0;
    }
    Xpopm();
    envdir = open("/env", 0);
    if(envdir<0){
        pfmt(err, "rc: can't open /env: %r\n");
        return;
    }
    start(rdfns, 1, runq->local);
}
@

<<function Waitfor>>=
int
Waitfor(int pid, int)
{
    thread *p;
    Waitmsg *w;
    char errbuf[ERRMAX];

    if(pid >= 0 && !havewaitpid(pid))
        return 0;

    while((w = wait()) != nil){
        delwaitpid(w->pid);
        if(w->pid==pid){
            setstatus(w->msg);
            free(w);
            return 0;
        }
        for(p = runq->ret;p;p = p->ret)
            if(p->pid==w->pid){
                p->pid=-1;
                strcpy(p->status, w->msg);
            }
        free(w);
    }

    errstr(errbuf, sizeof errbuf);
    if(strcmp(errbuf, "interrupted")==0) return -1;
    return 0;
}
@

<<function mkargv>>=
char **
mkargv(word *a)
{
    char **argv = (char **)emalloc((count(a)+2)*sizeof(char *));
    char **argp = argv+1;	/* leave one at front for runcoms */
    for(;a;a = a->next) *argp++=a->word;
    *argp = 0;
    return argv;
}
@

<<function addenv>>=
void
addenv(var *v)
{
    char envname[Maxenvname];
    word *w;
    int f;
    io *fd;
    if(v->changed){
        v->changed = false;
        snprint(envname, sizeof envname, "/env/%s", v->name);
        if((f = Creat(envname))<0)
            pfmt(err, "rc: can't open %s: %r\n", envname);
        else{
            for(w = v->val;w;w = w->next)
                write(f, w->word, strlen(w->word)+1L);
            close(f);
        }
    }
    if(v->fnchanged){
        v->fnchanged = 0;
        snprint(envname, sizeof envname, "/env/fn#%s", v->name);
        if((f = Creat(envname))<0)
            pfmt(err, "rc: can't open %s: %r\n", envname);
        else{
            if(v->fn){
                fd = openfd(f);
                pfmt(fd, "fn %q %s\n", v->name, v->fn[v->pc-1].s);
                closeio(fd);
            }
            close(f);
        }
    }
}
@

<<function updenvlocal>>=
void
updenvlocal(var *v)
{
    if(v){
        updenvlocal(v->next);
        addenv(v);
    }
}
@

<<function Updenv>>=
void
Updenv(void)
{
    var *v, **h;
    for(h = gvar;h!=&gvar[NVAR];h++)
        for(v=*h;v;v = v->next)
            addenv(v);
    if(runq)
        updenvlocal(runq->local);
}
@

<<function ForkExecute>>=
@

<<function Execute>>=
void
Execute(word *args, word *path)
{
    char **argv = mkargv(args);
    char file[1024], errstr[1024];
    int nc;

    Updenv();
    errstr[0] = '\0';
    for(;path;path = path->next){
        nc = strlen(path->word);
        if(nc < sizeof file - 1){	/* 1 for / */
            strcpy(file, path->word);
            if(file[0]){
                strcat(file, "/");
                nc++;
            }
            if(nc + strlen(argv[1]) < sizeof file){
                strcat(file, argv[1]);
                exec(file, argv+1);
                rerrstr(errstr, sizeof errstr);
                /*
                 * if file exists and is executable, exec should
                 * have worked, unless it's a directory or an
                 * executable for another architecture.  in
                 * particular, if it failed due to lack of
                 * swap/vm (e.g., arg. list too long) or other
                 * allocation failure, stop searching and print
                 * the reason for failure.
                 */
                if (strstr(errstr, " allocat") != nil ||
                    strstr(errstr, " full") != nil)
                    break;
            }
            else werrstr("command name too long");
        }
    }
    pfmt(err, "%s: %s\n", argv[1], errstr);
    efree((char *)argv);
}
@

<<constant NDIR>>=
#define	NDIR	256		/* shoud be a better way */
@

<<function Globsize>>=
int
Globsize(char *p)
{
    int isglob = 0, globlen = NDIR+1;
    for(;*p;p++){
        if(*p==GLOB){
            p++;
            if(*p!=GLOB)
                isglob++;
            globlen+=*p=='*'?NDIR:1;
        }
        else
            globlen++;
    }
    return isglob?globlen:0;
}
@

<<constant NFD>>=
#define	NFD	50
@

<<global dir>>=
struct{
    Dir	*dbuf;
    int	i;
    int	n;
}dir[NFD];
@

<<function Opendir>>=
int
Opendir(char *name)
{
    Dir *db;
    int f;
    f = open(name, 0);
    if(f==-1)
        return f;
    db = dirfstat(f);
    if(db!=nil && (db->mode&DMDIR)){
        if(f<NFD){
            dir[f].i = 0;
            dir[f].n = 0;
        }
        free(db);
        return f;
    }
    free(db);
    close(f);
    return -1;
}
@

<<function trimdirs>>=
static int
trimdirs(Dir *d, int nd)
{
    int r, w;

    for(r=w=0; r<nd; r++)
        if(d[r].mode&DMDIR)
            d[w++] = d[r];
    return w;
}
@

<<function Readdir>>=
/*
 * onlydirs is advisory -- it means you only
 * need to return the directories.  it's okay to
 * return files too (e.g., on unix where you can't
 * tell during the readdir), but that just makes 
 * the globber work harder.
 */
int
Readdir(int f, void *p, int onlydirs)
{
    int n;

    if(f<0 || f>=NFD)
        return 0;
Again:
    if(dir[f].i==dir[f].n){	/* read */
        free(dir[f].dbuf);
        dir[f].dbuf = 0;
        n = dirread(f, &dir[f].dbuf);
        if(n>0){
            if(onlydirs){
                n = trimdirs(dir[f].dbuf, n);
                if(n == 0)
                    goto Again;
            }	
            dir[f].n = n;
        }else
            dir[f].n = 0;
        dir[f].i = 0;
    }
    if(dir[f].i == dir[f].n)
        return 0;
    strcpy(p, dir[f].dbuf[dir[f].i].name);
    dir[f].i++;
    return 1;
}
@

<<function Closedir>>=
void
Closedir(int f)
{
    if(f>=0 && f<NFD){
        free(dir[f].dbuf);
        dir[f].i = 0;
        dir[f].n = 0;
        dir[f].dbuf = 0;
    }
    close(f);
}
@

<<global interrupted>>=
int interrupted = 0;
@

<<function notifyf>>=
void
notifyf(void*, char *s)
{
    int i;
    for(i = 0;syssigname[i];i++) if(strncmp(s, syssigname[i], strlen(syssigname[i]))==0){
        if(strncmp(s, "sys: ", 5)!=0) interrupted = 1;
        goto Out;
    }
    pfmt(err, "rc: note: %s\n", s);
    noted(NDFLT);
    return;
Out:
    if(strcmp(s, "interrupt")!=0 || trap[i]==0){
        trap[i]++;
        ntrap++;
    }
    if(ntrap>=32){	/* rc is probably in a trap loop */
        pfmt(err, "rc: Too many traps (trap %s), aborting\n", s);
        abort();
    }
    noted(NCONT);
}
@

<<function Trapinit>>=
void
Trapinit(void)
{
    notify(notifyf);
}
@

<<function Unlink>>=
void
Unlink(char *name)
{
    remove(name);
}
@

<<function Write>>=
long
Write(int fd, void *buf, long cnt)
{
    return write(fd, buf, cnt);
}
@

<<function Read>>=
long
Read(int fd, void *buf, long cnt)
{
    return read(fd, buf, cnt);
}
@

<<function Seek>>=
long
Seek(int fd, long cnt, long whence)
{
    return seek(fd, cnt, whence);
}
@

<<function Executable>>=
int
Executable(char *file)
{
    Dir *statbuf;
    int ret;

    statbuf = dirstat(file);
    if(statbuf == nil)
        return 0;
    ret = ((statbuf->mode&0111)!=0 && (statbuf->mode&DMDIR)==0);
    free(statbuf);
    return ret;
}
@

<<function Creat>>=
int
Creat(char *file)
{
    return create(file, 1, 0666L);
}
@

<<function Dup>>=
int
Dup(int a, int b)
{
    return dup(a, b);
}
@

<<function Dup1>>=
int
Dup1(int)
{
    return -1;
}
@

<<function Exit>>=
void
Exit(char *stat)
{
    Updenv();
    setstatus(stat);
    exits(truestatus()?"":getstatus());
}
@

<<function Eintr>>=
int
Eintr(void)
{
    return interrupted;
}
@

<<function Noerror>>=
void
Noerror(void)
{
    interrupted = 0;
}
@

<<function Isatty>>=
int
Isatty(int fd)
{
    char buf[64];

    if(fd2path(fd, buf, sizeof buf) != 0)
        return 0;

    /* might be #c/cons during boot - fixed 22 april 2005, remove this later */
    if(strcmp(buf, "#c/cons") == 0)
        return 1;

    /* might be /mnt/term/dev/cons */
    return strlen(buf) >= 9 && strcmp(buf+strlen(buf)-9, "/dev/cons") == 0;
}
@

<<function Abort>>=
void
Abort(void)
{
    pfmt(err, "aborting\n");
    flush(err);
    Exit("aborting");
}
@

<<function Memcpy>>=
void
Memcpy(void *a, void *b, long n)
{
    memmove(a, b, n);
}
@


<<global waitpids>>=
int *waitpids;
@

<<global nwaitpids>>=
int nwaitpids;
@

<<function addwaitpid>>=
void
addwaitpid(int pid)
{
    waitpids = realloc(waitpids, (nwaitpids+1)*sizeof waitpids[0]);
    if(waitpids == 0)
        panic("Can't realloc %d waitpids", nwaitpids+1);
    waitpids[nwaitpids++] = pid;
}
@

<<function delwaitpid>>=
void
delwaitpid(int pid)
{
    int r, w;
    
    for(r=w=0; r<nwaitpids; r++)
        if(waitpids[r] != pid)
            waitpids[w++] = waitpids[r];
    nwaitpids = w;
}
@

<<function clearwaitpids>>=
void
clearwaitpids(void)
{
    nwaitpids = 0;
}
@

<<function havewaitpid>>=
int
havewaitpid(int pid)
{
    int i;

    for(i=0; i<nwaitpids; i++)
        if(waitpids[i] == pid)
            return 1;
    return 0;
}
@

<<function _efgfmt>>=
/* avoid loading any floating-point library code */
//@Scheck: weird, probably linker trick
int _efgfmt(Fmt *)
{
    return -1;
}
@


%-------------------------------------------------------------

<<rc/plan9.c>>=
/*
 * Plan 9 versions of system-specific functions
 *	By convention, exported routines herein have names beginning with an
 *	upper case letter.
 */
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"
#include "getflags.h"

char**	mkargv(word*);
void	delwaitpid(int);
int	havewaitpid(int);

<<enum _anon_ (rc/plan9.c)>>

<<global Signame>>
<<global syssigname>>
<<global Rcmain>>
<<global Fdprefix>>

void execfinit(void);
void execnewpgrp(void);

<<global Builtin>>

<<function execnewpgrp>>

<<function Vinit>>
<<global envdir>>

<<function Xrdfn>>
<<global rdfns>>

<<function execfinit>>

<<function Waitfor>>

<<function mkargv>>

<<function addenv>>

<<function updenvlocal>>

<<function Updenv>>

<<function ForkExecute>>

<<function Execute>>
<<constant NDIR>>

<<function Globsize>>
<<constant NFD>>

<<global dir>>

<<function Opendir>>

<<function trimdirs>>

<<function Readdir>>

<<function Closedir>>
<<global interrupted>>
<<function notifyf>>

<<function Trapinit>>

<<function Unlink>>

<<function Write>>

<<function Read>>

<<function Seek>>

<<function Executable>>

<<function Creat>>

<<function Dup>>

<<function Dup1>>

<<function Exit>>

<<function Eintr>>

<<function Noerror>>

<<function Isatty>>

<<function Abort>>

<<function Memcpy>>

<<function Malloc>>

<<global waitpids>>
<<global nwaitpids>>

<<function addwaitpid>>

<<function delwaitpid>>

<<function clearwaitpids>>

<<function havewaitpid>>

<<function _efgfmt>>
@


\subsection*{[[rc/glob.c]]}



%-------------------------------------------------------------

<<rc/glob.c>>=
#include "rc.h"
#include "exec.h"
#include "fns.h"

int	matchfn(void*, void*);

<<global globname>>
<<global globv>>
<<function deglob>>

<<function globcmp>>

<<function globsort>>
<<function globdir>>
<<function glob>>

<<function equtf>>

<<function nextutf>>

<<function unicode>>

<<function matchfn>>

<<function match>>

<<function globlist1>>

<<function globlist>>
@


\subsection*{[[rc/exec.c]]}





<<function popword>>=
void
popword(void)
{
    word *p;
    if(runq->argv==0)
        panic("popword but no argv!", 0);
    p = runq->argv->words;
    if(p==0)
        panic("popword but no word!", 0);
    runq->argv->words = p->next;
    efree(p->word);
    efree((char *)p);
}
@

<<function freelist>>=
void
freelist(word *w)
{
    word *nw;
    while(w){
        nw = w->next;
        efree(w->word);
        efree((char *)w);
        w = nw;
    }
}
@


<<function poplist>>=
void
poplist(void)
{
    list *p = runq->argv;
    if(p==0)
        panic("poplist but no argv", 0);
    freelist(p->words);
    runq->argv = p->next;
    efree((char *)p);
}
@

<<function count>>=
int
count(word *w)
{
    int n;
    for(n = 0;w;n++) w = w->next;
    return n;
}
@

<<function pushredir>>=
void
pushredir(int type, int from, int to)
{
    redir * rp = new(redir);
    rp->type = type;
    rp->from = from;
    rp->to = to;
    rp->next = runq->redir;
    runq->redir = rp;
}
@

<<function newvar>>=
var*
newvar(char *name, var *next)
{
    var *v = new(var);
    v->name = name;
    v->val = 0;
    v->fn = 0;
    v->changed = false;
    v->fnchanged = 0;
    v->next = next;
    return v;
}
@


<<function Xappend>>=
void
Xappend(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1(">> requires singleton");
        return;
    case 0:
        Xerror1(">> requires file");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, 1))<0 && (f = Creat(file))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    Seek(f, 0L, 2);
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@

<<function Xsettrue>>=
void
Xsettrue(void)
{
    setstatus("");
}
@

<<function Xbang>>=
void
Xbang(void)
{
    setstatus(truestatus()?"false":"");
}
@

<<function Xclose>>=
void
Xclose(void)
{
    pushredir(RCLOSE, runq->code[runq->pc].i, 0);
    runq->pc++;
}
@

<<function Xdup>>=
void
Xdup(void)
{
    pushredir(RDUP, runq->code[runq->pc].i, runq->code[runq->pc+1].i);
    runq->pc+=2;
}
@

<<function Xeflag>>=
void
Xeflag(void)
{
    if(eflagok && !truestatus()) Xexit();
}
@

<<function Xexit>>=
void
Xexit(void)
{
    struct Var *trapreq;
    struct Word *starval;
    static int beenhere = 0;
    if(getpid()==mypid && !beenhere){
        trapreq = vlook("sigexit");
        if(trapreq->fn){
            beenhere = 1;
            --runq->pc;
            starval = vlook("*")->val;
            start(trapreq->fn, trapreq->pc, (struct Var *)0);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)0);
            runq->local->changed = true;
            runq->redir = runq->startredir = 0;
            return;
        }
    }
    Exit(getstatus());
}
@

<<function Xfalse>>=
void
Xfalse(void)
{
    if(truestatus()) runq->pc = runq->code[runq->pc].i;
    else runq->pc++;
}
@

<<global ifnot>>=
int ifnot;		/* dynamic if not flag */
@

<<function Xifnot>>=
void
Xifnot(void)
{
    if(ifnot)
        runq->pc++;
    else
        runq->pc = runq->code[runq->pc].i;
}
@

<<function Xjump>>=
void
Xjump(void)
{
    runq->pc = runq->code[runq->pc].i;
}
@

<<function Xmark>>=
void
Xmark(void)
{
    pushlist();
}
@

<<function Xpopm>>=
void
Xpopm(void)
{
    poplist();
}
@

<<function Xread>>=
void
Xread(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1("< requires singleton\n");
        return;
    case 0:
        Xerror1("< requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, 0))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@

<<function Xrdwr>>=
void
Xrdwr(void)
{
    char *file;
    int f;

    switch(count(runq->argv->words)){
    default:
        Xerror1("<> requires singleton\n");
        return;
    case 0:
        Xerror1("<> requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, ORDWR))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@

<<function turfredir>>=
void
turfredir(void)
{
    while(runq->redir!=runq->startredir)
        Xpopredir();
}
@

<<function Xpopredir>>=
void
Xpopredir(void)
{
    struct Redir *rp = runq->redir;
    if(rp==0)
        panic("turfredir null!", 0);
    runq->redir = rp->next;
    if(rp->type==ROPEN)
        close(rp->from);
    efree((char *)rp);
}
@

<<function Xreturn>>=
void
Xreturn(void)
{
    struct Thread *p = runq;
    turfredir();
    while(p->argv) poplist();
    codefree(p->code);
    runq = p->ret;
    efree((char *)p);
    if(runq==0)
        Exit(getstatus());
}
@

<<function Xtrue>>=
void
Xtrue(void)
{
    if(truestatus()) runq->pc++;
    else runq->pc = runq->code[runq->pc].i;
}
@

<<function Xif>>=
void
Xif(void)
{
    ifnot = 1;
    if(truestatus()) runq->pc++;
    else runq->pc = runq->code[runq->pc].i;
}
@

<<function Xwastrue>>=
void
Xwastrue(void)
{
    ifnot = 0;
}
@

<<function Xword>>=
void
Xword(void)
{
    pushword(runq->code[runq->pc++].s);
}
@

<<function Xwrite>>=
void
Xwrite(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1("> requires singleton\n");
        return;
    case 0:
        Xerror1("> requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = Creat(file))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@

<<function list2str>>=
char*
list2str(word *words)
{
    char *value, *s, *t;
    int len = 0;
    word *ap;
    for(ap = words;ap;ap = ap->next)
        len+=1+strlen(ap->word);
    value = emalloc(len+1);
    s = value;
    for(ap = words;ap;ap = ap->next){
        for(t = ap->word;*t;) *s++=*t++;
        *s++=' ';
    }
    if(s==value)
        *s='\0';
    else s[-1]='\0';
    return value;
}
@

<<function Xmatch>>=
void
Xmatch(void)
{
    word *p;
    char *subject;
    subject = list2str(runq->argv->words);
    setstatus("no match");
    for(p = runq->argv->next->words;p;p = p->next)
        if(match(subject, p->word, '\0')){
            setstatus("");
            break;
        }
    efree(subject);
    poplist();
    poplist();
}
@

<<function Xcase>>=
void
Xcase(void)
{
    word *p;
    char *s;
    int ok = 0;
    s = list2str(runq->argv->next->words);
    for(p = runq->argv->words;p;p = p->next){
        if(match(s, p->word, '\0')){
            ok = 1;
            break;
        }
    }
    efree(s);
    if(ok)
        runq->pc++;
    else
        runq->pc = runq->code[runq->pc].i;
    poplist();
}
@

<<function conclist>>=
word*
conclist(word *lp, word *rp, word *tail)
{
    char *buf;
    word *v;
    if(lp->next || rp->next)
        tail = conclist(lp->next==0? lp: lp->next,
            rp->next==0? rp: rp->next, tail);
    buf = emalloc(strlen(lp->word)+strlen((char *)rp->word)+1);
    strcpy(buf, lp->word);
    strcat(buf, rp->word);
    v = newword(buf, tail);
    efree(buf);
    return v;
}
@

<<function Xconc>>=
void
Xconc(void)
{
    word *lp = runq->argv->words;
    word *rp = runq->argv->next->words;
    word *vp = runq->argv->next->next->words;
    int lc = count(lp), rc = count(rp);
    if(lc!=0 || rc!=0){
        if(lc==0 || rc==0){
            Xerror1("null list in concatenation");
            return;
        }
        if(lc!=1 && rc!=1 && lc!=rc){
            Xerror1("mismatched list lengths in concatenation");
            return;
        }
        vp = conclist(lp, rp, vp);
    }
    poplist();
    poplist();
    runq->argv->words = vp;
}
@

<<function Xassign>>=
void
Xassign(void)
{
    var *v;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    deglob(runq->argv->words->word);
    v = vlook(runq->argv->words->word);
    poplist();
    globlist();
    freewords(v->val);
    v->val = runq->argv->words;
    v->changed = true;
    runq->argv->words = 0;
    poplist();
}
@

<<function copywords>>=
/*
 * copy arglist a, adding the copy to the front of tail
 */

word*
copywords(word *a, word *tail)
{
    word *v = 0, **end;
    for(end=&v;a;a = a->next,end=&(*end)->next)
        *end = newword(a->word, 0);
    *end = tail;
    return v;
}
@

<<function Xdol>>=
void
Xdol(void)
{
    word *a, *star;
    char *s, *t;
    int n;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);
    n = 0;
    for(t = s;'0'<=*t && *t<='9';t++) n = n*10+*t-'0';
    a = runq->argv->next->words;
    if(n==0 || *t)
        a = copywords(vlook(s)->val, a);
    else{
        star = vlook("*")->val;
        if(star && 1<=n && n<=count(star)){
            while(--n) star = star->next;
            a = newword(star->word, a);
        }
    }
    poplist();
    runq->argv->words = a;
}
@

<<function Xqdol>>=
void
Xqdol(void)
{
    word *a, *p;
    char *s;
    int n;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);
    a = vlook(s)->val;
    poplist();
    n = count(a);
    if(n==0){
        pushword("");
        return;
    }
    for(p = a;p;p = p->next) n+=strlen(p->word);
    s = emalloc(n);
    if(a){
        strcpy(s, a->word);
        for(p = a->next;p;p = p->next){
            strcat(s, " ");
            strcat(s, p->word);
        }
    }
    else
        s[0]='\0';
    pushword(s);
    efree(s);
}
@

<<function copynwords>>=
word*
copynwords(word *a, word *tail, int n)
{
    word *v, **end;
    
    v = 0;
    end = &v;
    while(n-- > 0){
        *end = newword(a->word, 0);
        end = &(*end)->next;
        a = a->next;
    }
    *end = tail;
    return v;
}
@

<<function subwords>>=
word*
subwords(word *val, int len, word *sub, word *a)
{
    int n, m;
    char *s;
    if(!sub)
        return a;
    a = subwords(val, len, sub->next, a);
    s = sub->word;
    deglob(s);
    m = 0;
    n = 0;
    while('0'<=*s && *s<='9')
        n = n*10+ *s++ -'0';
    if(*s == '-'){
        if(*++s == 0)
            m = len - n;
        else{
            while('0'<=*s && *s<='9')
                m = m*10+ *s++ -'0';
            m -= n;
        }
    }
    if(n<1 || n>len || m<0)
        return a;
    if(n+m>len)
        m = len-n;
    while(--n > 0)
        val = val->next;
    return copynwords(val, a, m+1);
}
@

<<function Xsub>>=
void
Xsub(void)
{
    word *a, *v;
    char *s;
    if(count(runq->argv->next->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->next->words->word;
    deglob(s);
    a = runq->argv->next->next->words;
    v = vlook(s)->val;
    a = subwords(v, count(v), runq->argv->words, a);
    poplist();
    poplist();
    runq->argv->words = a;
}
@

<<function Xcount>>=
void
Xcount(void)
{
    word *a;
    char *s, *t;
    int n;
    char num[12];
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);
    n = 0;
    for(t = s;'0'<=*t && *t<='9';t++) n = n*10+*t-'0';
    if(n==0 || *t){
        a = vlook(s)->val;
        inttoascii(num, count(a));
    }
    else{
        a = vlook("*")->val;
        inttoascii(num, a && 1<=n && n<=count(a)?1:0);
    }
    poplist();
    pushword(num);
}
@

<<function Xlocal>>=
void
Xlocal(void)
{
    if(count(runq->argv->words)!=1){
        Xerror1("variable name must be singleton\n");
        return;
    }
    deglob(runq->argv->words->word);
    runq->local = newvar(strdup(runq->argv->words->word), runq->local);
    poplist();
    globlist();
    runq->local->val = runq->argv->words;
    runq->local->changed = true;
    runq->argv->words = 0;
    poplist();
}
@

<<function Xunlocal>>=
void
Xunlocal(void)
{
    var *v = runq->local, *hid;
    if(v==0)
        panic("Xunlocal: no locals!", 0);
    runq->local = v->next;
    hid = vlook(v->name);
    hid->changed = true;
    efree(v->name);
    freewords(v->val);
    efree((char *)v);
}
@


<<function Xfn>>=
void
Xfn(void)
{
    var *v;
    word *a;
    int end;
    end = runq->code[runq->pc].i;
    globlist();
    for(a = runq->argv->words;a;a = a->next){
        v = gvlook(a->word);
        if(v->fn)
            codefree(v->fn);
        v->fn = codecopy(runq->code);
        v->pc = runq->pc+2;
        v->fnchanged = 1;
    }
    runq->pc = end;
    poplist();
}
@

<<function Xdelfn>>=
void
Xdelfn(void)
{
    var *v;
    word *a;
    for(a = runq->argv->words;a;a = a->next){
        v = gvlook(a->word);
        if(v->fn)
            codefree(v->fn);
        v->fn = 0;
        v->fnchanged = 1;
    }
    poplist();
}
@

<<function concstatus>>=
char*
concstatus(char *s, char *t)
{
    static char v[NSTATUS+1];
    int n = strlen(s);
    strncpy(v, s, NSTATUS);
    if(n<NSTATUS){
        v[n]='|';
        strncpy(v+n+1, t, NSTATUS-n-1);
    }
    v[NSTATUS]='\0';
    return v;
}
@

<<function Xpipewait>>=
void
Xpipewait(void)
{
    char status[NSTATUS+1];
    if(runq->pid==-1)
        setstatus(concstatus(runq->status, getstatus()));
    else{
        strncpy(status, getstatus(), NSTATUS);
        status[NSTATUS]='\0';
        Waitfor(runq->pid, 1);
        runq->pid=-1;
        setstatus(concstatus(getstatus(), status));
    }
}
@


<<function Xerror>>=
void
Xerror(char *s)
{
    if(strcmp(argv0, "rc")==0 || strcmp(argv0, "/bin/rc")==0)
        pfmt(err, "rc: %s: %r\n", s);
    else
        pfmt(err, "rc (%s): %s: %r\n", argv0, s);
    flush(err);
    setstatus("error");
    while(!runq->iflag) Xreturn();
}
@

<<function Xerror1>>=
void
Xerror1(char *s)
{
    if(strcmp(argv0, "rc")==0 || strcmp(argv0, "/bin/rc")==0)
        pfmt(err, "rc: %s\n", s);
    else
        pfmt(err, "rc (%s): %s\n", argv0, s);
    flush(err);
    setstatus("error");
    while(!runq->iflag) Xreturn();
}
@

<<function setstatus>>=
void
setstatus(char *s)
{
    setvar("status", newword(s, (word *)0));
}
@

<<function getstatus>>=
char*
getstatus(void)
{
    var *status = vlook("status");
    return status->val?status->val->word:"";
}
@

<<function truestatus>>=
int
truestatus(void)
{
    char *s;
    for(s = getstatus();*s;s++)
        if(*s!='|' && *s!='0')
            return 0;
    return 1;
}
@

<<function Xdelhere>>=
void
Xdelhere(void)
{
    Unlink(runq->code[runq->pc++].s);
}
@

<<function Xfor>>=
void
Xfor(void)
{
    if(runq->argv->words==0){
        poplist();
        runq->pc = runq->code[runq->pc].i;
    }
    else{
        freelist(runq->local->val);
        runq->local->val = runq->argv->words;
        runq->local->changed = true;
        runq->argv->words = runq->argv->words->next;
        runq->local->val->next = 0;
        runq->pc++;
    }
}
@

<<function Xglob>>=
void
Xglob(void)
{
    globlist();
}
@


%-------------------------------------------------------------

<<rc/exec.c>>=
#include "rc.h"
#include "getflags.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

char*	list2str(word*);

<<global argv0>>

<<function start>>

<<function newword>>

<<function pushword>>

<<function popword>>

<<function freelist>>

<<function pushlist>>

<<function poplist>>

<<function count>>

<<function pushredir>>

<<function newvar>>

/*
 * get command line flags.
 * initialize keywords & traps.
 * get values from environment.
 * set $pid, $cflag, $*
 * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)
 * start interpreting code
 */
<<function main (rc/exec.c)>>

/*
 * Opcode routines
 * Arguments on stack (...)
 * Arguments in line [...]
 * Code in line with jump around {...}
 *
 * Xappend(file)[fd]			open file to append
 * Xassign(name, val)			assign val to name
 * Xasync{... Xexit}			make thread for {}, no wait
 * Xbackq{... Xreturn}			make thread for {}, push stdout
 * Xbang				complement condition
 * Xcase(pat, value){...}		exec code on match, leave (value) on
 * 					stack
 * Xclose[i]				close file descriptor
 * Xconc(left, right)			concatenate, push results
 * Xcount(name)				push var count
 * Xdelfn(name)				delete function definition
 * Xdelhere
 * Xdol(name)				get variable value
 * Xdup[i j]				dup file descriptor
 * Xeflag
 * Xerror
 * Xexit				rc exits with status
 * Xfalse{...}				execute {} if false
 * Xfn(name){... Xreturn}			define function
 * Xfor(var, list){... Xreturn}		for loop
 * Xglob
 * Xif
 * Xifnot
 * Xjump[addr]				goto
 * Xlocal(name, val)			create local variable, assign value
 * Xmark				mark stack
 * Xmatch(pat, str)			match pattern, set status
 * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,
 * 					wait for both
 * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output,
 * 					depending on type), push /dev/fd/??
 * Xpipewait
 * Xpopm(value)				pop value from stack
 * Xpopredir
 * Xrdcmds
 * Xrdfn
 * Xrdwr(file)[fd]			open file for reading and writing
 * Xread(file)[fd]			open file to read
 * Xqdol(name)				concatenate variable components
 * Xreturn				kill thread
 * Xsimple(args)			run command and wait
 * Xsub
 * Xsubshell{... Xexit}			execute {} in a subshell and wait
 * Xtrue{...}				execute {} if true
 * Xunlocal				delete local variable
 * Xwastrue
 * Xword[string]			push string
 * Xwrite(file)[fd]			open file to write
 */

<<function Xappend>>

<<function Xsettrue>>

<<function Xbang>>

<<function Xclose>>

<<function Xdup>>

<<function Xeflag>>

<<function Xexit>>

<<function Xfalse>>
<<global ifnot>>

<<function Xifnot>>

<<function Xjump>>

<<function Xmark>>

<<function Xpopm>>

<<function Xread>>

<<function Xrdwr>>

<<function turfredir>>

<<function Xpopredir>>

<<function Xreturn>>

<<function Xtrue>>

<<function Xif>>

<<function Xwastrue>>

<<function Xword>>

<<function Xwrite>>

<<function list2str>>

<<function Xmatch>>

<<function Xcase>>

<<function conclist>>

<<function Xconc>>

<<function Xassign>>
<<function copywords>>

<<function Xdol>>

<<function Xqdol>>

<<function copynwords>>

<<function subwords>>

<<function Xsub>>

<<function Xcount>>

<<function Xlocal>>

<<function Xunlocal>>

<<function freewords>>

<<function Xfn>>

<<function Xdelfn>>

<<function concstatus>>

<<function Xpipewait>>

<<function Xrdcmds>>

<<function Xerror>>

<<function Xerror1>>

<<function setstatus>>

<<function getstatus>>

<<function truestatus>>

<<function Xdelhere>>

<<function Xfor>>

<<function Xglob>>
@


\subsection*{[[rc/havefork.c]]}

<<global havefork>>=
bool havefork = true;
@

<<function Xasync>>=
void
Xasync(void)
{
    int null = open("/dev/null", 0);
    int pid;
    char npid[10];
    if(null<0){
        Xerror("Can't open /dev/null\n");
        return;
    }
    switch(pid = rfork(RFFDG|RFPROC|RFNOTEG)){
    case -1:
        close(null);
        Xerror("try again");
        break;
    case 0:
        clearwaitpids();
        pushredir(ROPEN, null, 0);
        start(runq->code, runq->pc+1, runq->local);
        runq->ret = 0;
        break;
    default:
        addwaitpid(pid);
        close(null);
        runq->pc = runq->code[runq->pc].i;
        inttoascii(npid, pid);
        setvar("apid", newword(npid, (word *)0));
        break;
    }
}
@

<<function Xpipe>>=
void
Xpipe(void)
{
    struct Thread *p = runq;
    int pc = p->pc, forkid;
    int lfd = p->code[pc++].i;
    int rfd = p->code[pc++].i;
    int pfd[2];
    if(pipe(pfd)<0){
        Xerror("can't get pipe");
        return;
    }
    switch(forkid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0:
        clearwaitpids();
        start(p->code, pc+2, runq->local);
        runq->ret = 0;
        close(pfd[PRD]);
        pushredir(ROPEN, pfd[PWR], lfd);
        break;
    default:
        addwaitpid(forkid);
        start(p->code, p->code[pc].i, runq->local);
        close(pfd[PWR]);
        pushredir(ROPEN, pfd[PRD], rfd);
        p->pc = p->code[pc+1].i;
        p->pid = forkid;
        break;
    }
}
@

<<function Xbackq>>=
/*
 * Who should wait for the exit from the fork?
 */
void
Xbackq(void)
{
    int n, pid;
    int pfd[2];
    char *stop;
    char utf[UTFmax+1];
    struct Io *f;
    var *ifs = vlook("ifs");
    word *v, *nextv;
    Rune r;
    String *word;

    stop = ifs->val? ifs->val->word: "";
    if(pipe(pfd)<0){
        Xerror("can't make pipe");
        return;
    }
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        close(pfd[PRD]);
        close(pfd[PWR]);
        return;
    case 0:
        clearwaitpids();
        close(pfd[PRD]);
        start(runq->code, runq->pc+1, runq->local);
        pushredir(ROPEN, pfd[PWR], 1);
        return;
    default:
        addwaitpid(pid);
        close(pfd[PWR]);
        f = openfd(pfd[PRD]);
        word = s_new();
        v = nil;
        /* rutf requires at least UTFmax+1 bytes in utf */
        while((n = rutf(f, utf, &r)) != EOF){
            utf[n] = '\0';
            if(utfutf(stop, utf) == nil)
                s_nappend(word, utf, n);
            else
                /*
                 * utf/r is an ifs rune (e.g., \t, \n), thus
                 * ends the current word, if any.
                 */
                if(s_len(word) > 0){
                    v = newword(s_to_c(word), v);
                    s_reset(word);
                }
        }
        if(s_len(word) > 0)
            v = newword(s_to_c(word), v);
        s_free(word);
        closeio(f);
        Waitfor(pid, 0);
        /* v points to reversed arglist -- reverse it onto argv */
        while(v){
            nextv = v->next;
            v->next = runq->argv->words;
            runq->argv->words = v;
            v = nextv;
        }
        runq->pc = runq->code[runq->pc].i;
        return;
    }
}
@

<<function Xpipefd>>=
void
Xpipefd(void)
{
    struct Thread *p = runq;
    int pc = p->pc, pid;
    char name[40];
    int pfd[2];
    int sidefd, mainfd;
    if(pipe(pfd)<0){
        Xerror("can't get pipe");
        return;
    }
    if(p->code[pc].i==READ){
        sidefd = pfd[PWR];
        mainfd = pfd[PRD];
    }
    else{
        sidefd = pfd[PRD];
        mainfd = pfd[PWR];
    }
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0:
        clearwaitpids();
        start(p->code, pc+2, runq->local);
        close(mainfd);
        pushredir(ROPEN, sidefd, p->code[pc].i==READ?1:0);
        runq->ret = 0;
        break;
    default:
        addwaitpid(pid);
        close(sidefd);
        pushredir(ROPEN, mainfd, mainfd);	/* isn't this a noop? */
        strcpy(name, Fdprefix);
        inttoascii(name+strlen(name), mainfd);
        pushword(name);
        p->pc = p->code[pc+1].i;
        break;
    }
}
@

<<function Xsubshell>>=
void
Xsubshell(void)
{
    int pid;
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0:
        clearwaitpids();
        start(runq->code, runq->pc+1, runq->local);
        runq->ret = 0;
        break;
    default:
        addwaitpid(pid);
        Waitfor(pid, 1);
        runq->pc = runq->code[runq->pc].i;
        break;
    }
}
@

<<function execforkexec>>=
int
execforkexec(void)
{
    int pid;
    int n;
    char buf[ERRMAX];

    switch(pid = fork()){
    case -1:
        return -1;
    case 0:
        clearwaitpids();
        pushword("exec");
        execexec();
        strcpy(buf, "can't exec: ");
        n = strlen(buf);
        errstr(buf+n, ERRMAX-n);
        Exit(buf);
    }
    addwaitpid(pid);
    return pid;
}
@


%-------------------------------------------------------------

<<rc/havefork.c>>=
#include "rc.h"
#include "getflags.h"
#include "exec.h"
#include "io.h"
#include "fns.h"
#include <string.h>

<<global havefork>>

<<function Xasync>>

<<function Xpipe>>

<<function Xbackq>>

<<function Xpipefd>>

<<function Xsubshell>>

<<function execforkexec>>
@


\subsection*{[[rc/tree.c]]}


<<function mung1>>=
//@Scheck: used by syn.y
tree* mung1(tree *t, tree *c0)
{
    t->child[0] = c0;
    return t;
}
@

<<function mung2>>=
//@Scheck: used by syn.y
tree* mung2(tree *t, tree *c0, tree *c1)
{
    t->child[0] = c0;
    t->child[1] = c1;
    return t;
}
@

<<function mung3>>=
//@Scheck: used by syn.y
tree* mung3(tree *t, tree *c0, tree *c1, tree *c2)
{
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@

<<function epimung>>=
//@Scheck: used by syn.y
tree* epimung(tree *comp, tree *epi)
{
    tree *p;
    if(epi==0)
        return comp;
    for(p = epi;p->child[1];p = p->child[1]);
    p->child[1] = comp;
    return epi;
}
@

<<function simplemung>>=
/*
 * Add a SIMPLE node at the root of t and percolate all the redirections
 * up to the root.
 */
//@Scheck: used by syn.y
tree* simplemung(tree *t)
{
    tree *u;
    struct Io *s;

    t = tree1(SIMPLE, t);
    s = openstr();
    pfmt(s, "%t", t);
    t->str = strdup((char *)s->strp);
    closeio(s);
    for(u = t->child[0];u->type==ARGLIST;u = u->child[0]){
        if(u->child[1]->type==DUP
        || u->child[1]->type==REDIR){
            u->child[1]->child[1] = t;
            t = u->child[1];
            u->child[1] = 0;
        }
    }
    return t;
}
@


%-------------------------------------------------------------

<<rc/tree.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"
#include "x.tab.h"

void freetree(tree*);

<<global treenodes>>
<<function newtree>>

<<function freenodes>>

<<function tree1>>

<<function tree2>>

<<function tree3>>

<<function mung1>>

<<function mung2>>

<<function mung3>>

<<function epimung>>
<<function simplemung>>

<<function token>>

<<function freetree>>
@


\subsection*{[[rc/lex.c]]}


<<function idchr>>=
int
idchr(int c)
{
    /*
     * Formerly:
     * return 'a'<=c && c<='z' || 'A'<=c && c<='Z' || '0'<=c && c<='9'
     *	|| c=='_' || c=='*';
     */
    return c>' ' && !strchr("!\"#$%&'()+,-./:;<=>?@[\\]^`{|}~", c);
}
@
%$




<<function pprompt>>=
void
pprompt(void)
{
    var *prompt;
    if(runq->iflag){
        pstr(err, promptstr);
        flush(err);
        prompt = vlook("prompt");
        if(prompt->val && prompt->val->next)
            promptstr = prompt->val->next->word;
        else
            promptstr="\t";
    }
    runq->lineno++;
    doprompt = false;
}
@




<<function addtok>>=
char*
addtok(char *p, int val)
{
    if(p==0)
        return 0;
    if(p >= &tok[NTOK]){
        *p = 0;
        yyerror("token buffer too short");
        return 0;
    }
    *p++=val;
    return p;
}
@

<<function addutf>>=
char*
addutf(char *p, int c)
{
    uchar b, m;
    int i;

    p = addtok(p, c);	/* 1-byte UTF runes are special */
    if(c < Runeself)
        return p;

    m = 0xc0;
    b = 0x80;
    for(i=1; i < UTFmax; i++){
        if((c&m) == b)
            break;
        p = addtok(p, advance());
        b = m;
        m = (m >> 1)|0x80;
    }
    return p;
}
@

%-------------------------------------------------------------

<<rc/lex.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "getflags.h"
#include "fns.h"
#include "x.tab.h"

int getnext(void);


<<function wordchr>>

<<function idchr>>

<<global future>>
<<global doprompt>>
<<global inquote>>
<<global incomm>>

<<function nextc>>
<<function advance>>
<<function getnext>>

<<function pprompt>>

<<function skipwhite>>

<<function skipnl>>

<<function nextis>>

<<function addtok>>

<<function addutf>>

<<global lastdol>>
<<global lastword (rc/lex.c)>>

<<function yylex>>
@


\subsection*{[[rc/trap.c]]}


%-------------------------------------------------------------

<<rc/trap.c>>=
#include "rc.h"
#include "exec.h"
#include "fns.h"
#include "io.h"
extern char *Signame[];

<<function dotrap>>
@


\subsection*{[[rc/simple.c]]}

<<function exitnext>>=
/*
 * Search through the following code to see if we're just going to exit.
 */
int
exitnext(void){
    union Code *c=&runq->code[runq->pc];
    while(c->f==Xpopredir) c++;
    return c->f==Xexit;
}
@

<<function Xsimple>>=
void
Xsimple(void)
{
    word *a;
    thread *p = runq;
    var *v;
    struct Builtin *bp;
    int pid;

    globlist();
    a = runq->argv->words;
    if(a==nil){
        Xerror1("empty argument list");
        return;
    }
    if(flag['x'])
        pfmt(err, "%v\n", p->argv->words); /* wrong, should do redirs */

    v = gvlook(a->word);
    if(v->fn)
        execfunc(v);
    else{
        if(strcmp(a->word, "builtin")==0){
            if(count(a)==1){
                pfmt(err, "builtin: empty argument list\n");
                setstatus("empty arg list");
                poplist();
                return;
            }
            a = a->next;
            popword();
        }
        for(bp = Builtin;bp->name;bp++)
            if(strcmp(a->word, bp->name)==0){
                (*bp->fnc)();
                return;
            }
        if(exitnext()){
            /* fork and wait is redundant */
            pushword("exec");
            execexec();
            Xexit();
        }
        else{
            flush(err);
            Updenv();	/* necessary so changes don't go out again */
            if((pid = execforkexec()) < 0){
                Xerror("try again");
                return;
            }

            /* interrupts don't get us out */
            poplist();
            while(Waitfor(pid, 1) < 0)
                ;
        }
    }
}
@

<<global nullpath>>=
struct Word nullpath = { "", 0};
@

<<function doredir>>=
void
doredir(redir *rp)
{
    if(rp){
        doredir(rp->next);
        switch(rp->type){
        case ROPEN:
            if(rp->from!=rp->to){
                Dup(rp->from, rp->to);
                close(rp->from);
            }
            break;
        case RDUP:
            Dup(rp->from, rp->to);
            break;
        case RCLOSE:
            close(rp->from);
            break;
        }
    }
}
@

<<function searchpath>>=
word*
searchpath(char *w)
{
    word *path;
    if(strncmp(w, "/", 1)==0
    || strncmp(w, "#", 1)==0
    || strncmp(w, "./", 2)==0
    || strncmp(w, "../", 3)==0
    || (path = vlook("path")->val)==0)
        path=&nullpath;
    return path;
}
@


<<function execfunc>>=
void
execfunc(var *func)
{
    word *starval;
    popword();
    starval = runq->argv->words;
    runq->argv->words = 0;
    poplist();
    start(func->fn, func->pc, runq->local);
    runq->local = newvar(strdup("*"), runq->local);
    runq->local->val = starval;
    runq->local->changed = true;
}
@


<<function appfile>>=
static char *
appfile(char *dir, char *comp)
{
    int dirlen, complen;
    char *s, *p;

    dirlen = strlen(dir);
    complen = strlen(comp);
    s = emalloc(dirlen + 1 + complen + 1);
    memmove(s, dir, dirlen);
    p = s + dirlen;
    *p++ = '/';
    memmove(p, comp, complen);
    p[complen] = '\0';
    return s;
}
@




<<function mapfd>>=
int
mapfd(int fd)
{
    redir *rp;
    for(rp = runq->redir;rp;rp = rp->next){
        switch(rp->type){
        case RCLOSE:
            if(rp->from==fd)
                fd=-1;
            break;
        case RDUP:
        case ROPEN:
            if(rp->to==fd)
                fd = rp->from;
            break;
        }
    }
    return fd;
}
@









%-------------------------------------------------------------

<<rc/simple.c>>=
/*
 * Maybe `simple' is a misnomer.
 */
#include "rc.h"
#include "getflags.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

word*	searchpath(char*);
void execfunc(var*);
int	mapfd(int);

<<function exitnext>>

<<function Xsimple>>
<<global nullpath>>

<<function doredir>>

<<function searchpath>>

<<function execexec>>

<<function execfunc>>

<<function dochdir>>

<<function appfile>>

<<function execcd>>

<<function execexit>>

<<function execshift>>

<<function mapfd>>
<<global rdcmds>>

<<function execcmds>>

<<function execeval>>
<<global dotcmds>>

<<function execdot>>

<<function execflag>>

<<function execwhatis>>

<<function execwait>>
@


\subsection*{[[rc/pcmd.c]]}


%-------------------------------------------------------------

<<rc/pcmd.c>>=
#include "rc.h"
#include "io.h"
#include "fns.h"
#include "x.tab.h"
<<global nl>>
<<constant c0>>
<<constant c1>>
<<constant c2>>

<<function pdeglob>>

<<function pcmd>>
@


\subsection*{[[rc/here.c]]}

<<global ser>>=
int ser = 0;
@

<<global tmp (rc/here.c)>>=
char tmp[] = "/tmp/here0000.0000";
@

<<global hex>>=
char hex[] = "0123456789abcdef";
@

<<function hexnum>>=
void
hexnum(char *p, int n)
{
    *p++ = hex[(n>>12)&0xF];
    *p++ = hex[(n>>8)&0xF];
    *p++ = hex[(n>>4)&0xF];
    *p = hex[n&0xF];
}
@

<<function heredoc>>=
//@Scheck: used by syn.y
tree* heredoc(tree *tag)
{
    struct Here *h = new(struct Here);

    if(tag->type != WORD)
        yyerror("Bad here tag");
    h->next = 0;
    if(here)
        *ehere = h;
    else
        here = h;
    ehere = &h->next;
    h->tag = tag;
    hexnum(&tmp[9], getpid());
    hexnum(&tmp[14], ser++);
    h->name = strdup(tmp);
    return token(tmp, WORD);
}
@


<<function psubst>>=
void
psubst(io *f, uchar *s)
{
    int savec, n;
    uchar *t, *u;
    Rune r;
    word *star;

    while(*s){
        if(*s != '$'){		/* copy plain text rune */
            if(*s < Runeself)
                pchr(f, *s++);
            else{
                n = chartorune(&r, (char *)s);
                while(n-- > 0)
                    pchr(f, *s++);
            }
        }else{			/* $something -- perform substitution */
            t = ++s;
            if(*t == '$')
                pchr(f, *t++);
            else{
                while(*t && idchr(*t))
                    t++;
                savec = *t;
                *t = '\0';
                n = 0;
                for(u = s; *u && '0' <= *u && *u <= '9'; u++)
                    n = n*10 + *u - '0';
                if(n && *u == '\0'){
                    star = vlook("*")->val;
                    if(star && 1 <= n && n <= count(star)){
                        while(--n)
                            star = star->next;
                        pstr(f, star->word);
                    }
                }else
                    pstrs(f, vlook((char *)s)->val);
                *t = savec;
                if(savec == '^')
                    t++;
            }
            s = t;
        }
    }
}
@
%$

<<function pstrs>>=
void
pstrs(io *f, word *a)
{
    if(a){
        while(a->next && a->next->word){
            pstr(f, a->word);
            pchr(f, ' ');
            a = a->next;
        }
        pstr(f, a->word);
    }
}
@


%-------------------------------------------------------------



<<rc/here.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"
#include "x.tab.h"

<<global here>>
<<global ehere>>
<<global ser>>
<<global tmp (rc/here.c)>>
<<global hex>>

void psubst(io*, uchar*);
void pstrs(io*, word*);

<<function hexnum>>

<<function heredoc>>

<<constant NLINE>>

<<function readhere>>

<<function psubst>>

<<function pstrs>>
@


\subsection*{[[rc/code.c]]}

<<constant c0 (rc/code.c)>>=
#define	c0	t->child[0]
@

<<constant c1 (rc/code.c)>>=
#define	c1	t->child[1]
@

<<constant c2 (rc/code.c)>>=
#define	c2	t->child[2]
@



<<function stuffdot>>=
void
stuffdot(int a)
{
    if(a<0 || codep<=a)
        panic("Bad address %d in stuffdot", a);
    codebuf[a].i = codep;
}
@


<<function cleanhere>>=
void
cleanhere(char *f)
{
    emitf(Xdelhere);
    emits(strdup(f));
}
@

<<function fnstr>>=
char*
fnstr(tree *t)
{
    io *f = openstr();
    void *v;
    extern char nl;
    char svnl = nl;

    nl = ';';
    pfmt(f, "%t", t);
    nl = svnl;
    v = f->strp;
    f->strp = 0;
    closeio(f);
    return v;
}
@


<<function codeswitch>>=
/*
 * switch code looks like this:
 *	Xmark
 *	(get switch value)
 *	Xjump	1f
 * out:	Xjump	leave
 * 1:	Xmark
 *	(get case values)
 *	Xcase	1f
 *	(commands)
 *	Xjump	out
 * 1:	Xmark
 *	(get case values)
 *	Xcase	1f
 *	(commands)
 *	Xjump	out
 * 1:
 * leave:
 *	Xpopm
 */

void
codeswitch(tree *t, int eflag)
{
    int leave;		/* patch jump address to leave switch */
    int out;		/* jump here to leave switch */
    int nextcase;	/* patch jump address to next case */
    tree *tt;
    if(c1->child[0]==nil
    || c1->child[0]->type!=';'
    || !iscase(c1->child[0]->child[0])){
        yyerror("case missing in switch");
        return;
    }
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xjump);
    nextcase = emiti(0);
    out = emitf(Xjump);
    leave = emiti(0);
    stuffdot(nextcase);
    t = c1->child[0];
    while(t->type==';'){
        tt = c1;
        emitf(Xmark);
        for(t = c0->child[0];t->type==ARGLIST;t = c0) outcode(c1, eflag);
        emitf(Xcase);
        nextcase = emiti(0);
        t = tt;
        for(;;){
            if(t->type==';'){
                if(iscase(c0)) break;
                outcode(c0, eflag);
                t = c1;
            }
            else{
                if(!iscase(t)) outcode(t, eflag);
                break;
            }
        }
        emitf(Xjump);
        emiti(out);
        stuffdot(nextcase);
    }
    stuffdot(leave);
    emitf(Xpopm);
}
@

<<function iscase>>=
int
iscase(tree *t)
{
    if(t->type!=SIMPLE)
        return 0;
    do t = c0; while(t->type==ARGLIST);
    return t->type==WORD && !t->quoted && strcmp(t->str, "case")==0;
}
@


<<function codefree>>=
void
codefree(code *cp)
{
    code *p;
    if(--cp[0].i!=0)
        return;
    for(p = cp+1;p->f;p++){
        if(p->f==Xappend || p->f==Xclose || p->f==Xread || p->f==Xwrite
        || p->f==Xrdwr
        || p->f==Xasync || p->f==Xbackq || p->f==Xcase || p->f==Xfalse
        || p->f==Xfor || p->f==Xjump
        || p->f==Xsubshell || p->f==Xtrue) p++;
        else if(p->f==Xdup || p->f==Xpipefd) p+=2;
        else if(p->f==Xpipe) p+=4;
        else if(p->f==Xword || p->f==Xdelhere) efree((++p)->s);
        else if(p->f==Xfn){
            efree(p[2].s);
            p+=2;
        }
    }
    efree((char *)cp);
}
@


%-------------------------------------------------------------


<<rc/code.c>>=
#include "rc.h"
#include "io.h"
#include "exec.h"
#include "fns.h"
#include "getflags.h"
#include "x.tab.h"

<<constant c0 (rc/code.c)>>
<<constant c1 (rc/code.c)>>
<<constant c2 (rc/code.c)>>
<<global codep>>
<<global ncode>>
<<function emitf>>
<<function emiti>>
<<function emits>>
void stuffdot(int);
char *fnstr(tree*);
void outcode(tree*, int);
void codeswitch(tree*, int);
int iscase(tree*);
code *codecopy(code*);
void codefree(code*);

<<function morecode>>

<<function stuffdot>>

<<function compile>>

<<function cleanhere>>

<<function fnstr>>

<<function outcode>>
<<function codeswitch>>

<<function iscase>>

<<function codecopy>>

<<function codefree>>
@


\subsection*{[[rc/pfnc.c]]}

%-------------------------------------------------------------

<<rc/pfnc.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

<<global fname>>

<<function pfnc>>
@


