\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
%  - removed deadcode (Thread.treenodes, Tree.iskw, freetree? ...)

%thx to codemap/codegraph/scheck:
%  - removed deadcode (many dead functions)

%thx to this manual, I better understand sh:
% - TODO fancy redirection syntax, especially 2>&1 ?? I never remember
%   but in rc it's   ls /xxx >[2] /tmp/logs
% - TODO operator priorities (; vs & vs | vs >)
% - TODO $*, variable for return status of process
% - TODO escaping nightmares
% - TODO multiline editing
% - TODO subshell power? ex?
%     (for d in utils parsing typing bytecomp asmcomp driver tools/toplevel; \
%              do boot/ocamlrun tools/misc/ocamldep -I utils -I parsing -I typing -I bytecomp -I asmcomp -I driver -I tools/toplevel $d/*.mli $d/*.ml; \
%              done) > .depend
% - to not use ';' but instead && for eflag -e to work

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, builtin, opcode
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - SEMI nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Shell [[rc]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Tom Duff
}

\maketitle 
\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a {shell}.

\section{Motivations}

Why a shell? 
Because I think you are a better programmer if
you fully understand how things work under the hood, and
the shell is a central piece of the {command-line user interface}.
%
The shell sits on top of the kernel and allows you to execute other
programs.
\l without shell around kernel (hence the name shell), then kernel
\l  is useless. shell is UI.



Here are a few questions I hope this book will answer:
\begin{itemize}

\item What happens when the user type [[ls]] in a terminal?
What are the programs involved in such a command? What
is the trace of such a command through the different layers
of the software stack?

\item How are implemented redirection and pipes? What are
the system calls involved?

\item Why [[cd]] has to be a shell built-in? Why can not it be a
regular command such as [[ls]]?


\item How do [[C-c]] or [[C-z]], which interrupts or suspends
processes, work?

% relation between login program, shell, terminal

\end{itemize}


%bash shellshock context in oct 2014, good idea to look at shell
% implementation :)


\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl): (use ??)
% - growing_array (codebuf)


%algorithms (beyond search/sort): (actually use neither search nor sort?)


\section{[[rc]]}

% gonna present rc, for run command.
% 6300 LOC

% actually seems used as a fork basis for other advanced shells
% (es, other?)

\section{Other shells}

Here are a few shells that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

\item Bourne shell
% the shell of xv6? 
%   https://github.com/oskarth/xv6/blob/master/homework/sh.c
% design of sh by bourne:
%  TODO https://www.youtube.com/watch?v=2kEJoWfobpA

\item Bash (Bourne Again Shell) has a pretty big codebase
%http://www.aosabook.org/en/bash.html

\item zsh
% oh my zsh cult

\item scsh
\l more orthogonal

\end{itemize}

%history:
% - http://www.multicians.org/shell.html
% - http://v6shell.org/history/sh.c the original shell
% - original bourne shell, in unix-history-repo, 3000 LOC
%education:
% - xinu shell in appendix of xinu book
% - osh, shell v6:
%   http://v6shell.org/
%   understanding the shell of v6:
%   http://experiments.oskarth.com/unix01/
%mini:
% - one used by busybox, probably many builtins or simple code:
%   https://en.wikipedia.org/wiki/Almquist_shell
%other:
% - rc fork: http://tobold.org/article/rc
% - extensible shell, based on rc:
%   http://wryun.github.io/es-shell/
%   http://wryun.github.io/es-shell/paper.html
% - ape/pdksh/, 23 000 LOC vs rc 6300 (or 10 000 when wc *.nw instead)
% - other worthwhile? eshell :)
% - PowerShell, recently open sourced, written in C#, huge
%   contains shell but also utilities. Apparently can have typed pipes.
%   Maybe like in Automator?
%research/recent:
% - fish shell
% - mosh, mobile shell, allow disconnection over Wifi apparently
% - next generation shell
%   https://github.com/ilyash/ngs/
% - xonsh http://xon.sh/ (a superset of pyhton)
% - Automator, visual pipes! not really a shell, a kind of visual shell

% https://en.wikipedia.org/wiki/Comparison_of_command_shells
% http://xon.sh/#comparison contains  nice comparison of modern shells:

%evolution of shells:
% https://www.ibm.com/developerworks/library/l-linux-shells/
% nice diagram of history of shells, very nice resource list with further links


% missing stuff:
%  - filename completion (but apparently rio has some support for it)


\section{Getting started}

\section{Requirements}

% there is an article in oasa book about bash
% (available in bash/doc/aosa-bash.pdf)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[rc]], Tom Duff, 
who wrote in some sense most of this book.




\chapter{Overview}

\section{Shell principles}

% shell = stuff around a kernel in a coquillage.
% history: multics.
% A shell is a bastard. See bourne article in docs/articles/unix/ about sh.

% do a minishell before showing rc?

\subsection{Running commands}

% shell is first to run commands (hence the name of rc)!

% Hence syntax. Compare  ls /foo  vs  print(readdir("/foo")).
% no parenthesis (curry syntax :) ), no string. implicit.
% no full path either thx to PATH variable.

%\subsection{A DSL}

% DSL. |, <, >. 
% handle * expansion (before was delegated to another program called glob)

% for a long time actually there was no (external) shell. Shell was
% part of OS. With Unix it changed and shell can be a regular
% user program. 

% It then opened the way for complex job control language.
% More features.

%dup in grammar:
% interesting DSL. must be easy to issue a command.
% don't want to do 'system("ls");' like in other languages.
% and want newline to have a special semantic role, a kind of implicit ';'
% but also want to have multiline statements ... so newline must be allowed
%  and not run the command sometimes.
% -xxx, /a/b, are treated as regular words! only ;&${[^ are specials


\subsection{A universal REPL}

% shell is also idea of universal repl! not like Lisp machine, squeak, etc.
% see Kernel.nw note on this.
% call function from repl, pass argument, modify globals. can even get
% help via whatis :) or man :) and return boolean result (status)
% (as well as effect on stdout/stderr that can be captured)

% cf stevens book, shell basis = read a line, parse, fork, exec, wait!
% RPFEW

\subsection{Pipes and redirections}

% to handle pipe and redirection it's little variations that shows also
% the beauty of fork!

% again DSL. minimal syntax. To do that in C requires
% lots of work.

%\subsection{Asynchronous jobs and job control}

%\subsection{Globbing}

\subsection{A full programming language}

% However this goes in conflict with the ability
% to easily run command and the minimal syntax.
% rc uses lots of lexing tricks to mix full PL and DSL for
% running command (ex: SUB hack, skipnl, etc)

\section{[[rc]] command-line interface}
\l very meta! command line interface of the command line interface!
\l can run shell from shell

% see rc.ps

% -l??

% -i => interactive (default when no argument given and isatty, see main())
% -I => not interactive (only diff is prompt not displayed between commands)

% -r => debug opcodes output (convenient)
% -s => debug returned status when error status from subprocess

% -e stops at first error (called like that from mk)

\section{Input shell language}

% run command (obviously), argv
% DSL for pipe, redirection, async, globbing
% mini classic language with control flow statement and variables, globals

% job control? has & but no fg/bg?

% rc PL =~ dynamic
% basic DS = list of strings (List), with operator like ^
% so different from bash here already. But better basis
% to have list as core value, because no need PATH=: separator,
% no need $@ I think. Just simpler.

% quite similar to bash
% main difference? for var stuff? 'if not' instead of 'else'.

% do it needs the ugly "$@"?

%grouping! subshell! cool:
%	(for d in utils parsing typing bytecomp asmcomp driver tools/toplevel; \
%         do $(CAMLDEP) $(DEPFLAGS) $$d/*.mli $$d/*.ml; \
%         done) > .depend
% without this would have to do some initial >, and then some >>


\section{Code organization}

%getflags.c: getopt + specific flag setting
%io.c: fmt + buffered IO + specific debug
%pcmd.c: debugging (tree) (should rename file and function name)
%pfnc.c: debugging (runq and opcode) (should rename file too)

%plan9.c: for portability

%globals.c: a few globals
%subr.c: helper routines

%tree.c: AST builder helpers
%lex.c: lexer, yylex()
%syn.y: parser, yyparse() in generated y.tab.c
%code.c: opcode generation from tree, compile() and outcode()

%exec.c: main(), opcode interpreter loop, many Xxxx() opcode interpretation
%simple.c: Xsimple opcode interpreter, and builtins
%havefork.c: opcodes related to process (Xpipe, Xasync, etc)

%here.c: here document feature
%glob.c: globbing feature

%trap.c: interrupt
%var.c: variables

\section{Software architecture}

% pipeline archi? like compiler? not exactly as it's actually an interpreter

% string -> lexing(yylex) -> parsing(yyparse) -> ast(treexx) -> bytecode(compile)
% (note that actually not lexing -> parsing  for efficiency parsing call lexer
%  on demand, so need to keep only one token in memory)
%
% but how the parsing chain is called?
% main() -> 
%   - build boostrap[] which essentially contain a Xrdcmds opcode
%      (actually it has a Xsimple "." rcmain and so
%      will run execdot which will run Xrdcmds)
%   - calls start() to setup runq from boostrap[]
%   - setup runq->argv
%   - start interpreting bootstrap runq->code[pc-1].f()
%       -> Xrdcmds() -> yyparse() -> yylex() (print prompt actually too)
%                                 -> compile() -> outcode() (modify codebuf)
%                    -> start(codebuf)
%                    -> Xreturn and loop


%Xxxx = opcodes
%execxxx = builtins (Xsimple of specially interpreted command)

% chapter with a simple traduction of a simple command? like 'ls /' ?

\section{Book structure}



%###############################################################################

\chapter{Core Data Structures}

\section{[[Token]]}

<<token declarations>>=
%token FOR IN WHILE IF NOT SWITCH FN
%token TWIDDLE BANG  /** ~ ! */
%token REDIR PIPE /** {>, <, <<, >>} | */
%token ANDAND OROR /** && || */
%token COUNT SUB /** $# ( */
%token WORD /** anything else (e.g. foo, --help, 42, /a/b/c, etc) */
@
%old: was using %term instead of %token (probably for %terminal?)
%old: also ANDAND was mentioned only in %left, but better declare everything

% see pcmd() for the chars not mentioned above:
%  '$', '"', '&', '^', '`', ';', '='
% not sure why treats different ~ (with TWIDDLE) and = (without a %token)
% actually see also the grammar, there are a few more chars not mentioned above:
% '(' (different from SUB, lexer trick), ')', '{', '}'

%typedef int Token_kind; (union { char; enum token_kind })
% see x.tab.h (a set of #define but could be an enum)
% with also ascii char into it
% so can also be ';' (see tree3() that actually look for that)




\section{Abstract syntax tree [[Tree]]}
% rc has a command language!

% AST tree of the command, ex "ls | wc" =>  ?

<<struct tree>>=
struct Tree {

    // either<enum<Token_kind>, char>
    int	type;
    // string of the token or AST dump of the whole subtree for certain nodes
    char *str;

    // array<option<ref_own<Tree>>
    tree	*child[3];

    <<[[Tree]] other fields>>

    // Extra
    <<[[Tree]] extra fields>>
};
@
%dead: bool iskw;

% str contain string of the tree. Used to store
% function in the environment.
% Used probably also for debugging for dumping.

% when use the 3 children?

% type is token kind, or character.
% Introduced also a few more token without syntax but part of enum.

<<token declarations>>=
/* not used in syntax */
%token SIMPLE ARGLIST WORDS
%token BRACE PAREN 
@

% why BRACE and not { ?




% set in newtree() called to build AST in yyparse()
<<global treenodes>>=
// list<ref_own<Tree>> (next = Tree.next)
tree *treenodes;
@

<<[[Tree]] extra fields>>=
tree	*next;
@


<<function newtree>>=
/*
 * create and clear a new tree node, and add it
 * to the node list.
 */
tree*
newtree(void)
{
    tree *t = new(tree);
    t->str = nil;
    t->child[0] = t->child[1] = t->child[2] = nil;

    // add_list(t, treenodes)
    t->next = treenodes;
    treenodes = t;

    return t;
}
@
%dead:    t->iskw = false;

% dead?
<<function freetree>>=
void
freetree(tree *p)
{
    if(p==nil)
        return;	
    freetree(p->child[0]);
    freetree(p->child[1]);
    freetree(p->child[2]);
    if(p->str)
        efree(p->str);
    efree((char *)p);
}
@

% efree = emalloc = wrapper around free but handling error.

<<function freenodes>>=
void
freenodes(void)
{
    tree *t, *u;
    for(t = treenodes;t;t = u){
        u = t->next;
        if(t->str)
            efree(t->str);
        efree((char *)t);
    }
    treenodes = nil;
}
@
% and does not call freetree()? all trees are linked together
% in newtree anyway, so here enough to explore flatten list instead
% of complex tree.

% used in syn.y
<<function tree1>>=
tree*
tree1(int type, tree *c0)
{
    return tree3(type, c0, (tree *)nil, (tree *)nil);
}
@

<<function tree2>>=
//@Scheck: used by syn.y
tree* tree2(int type, tree *c0, tree *c1)
{
    return tree3(type, c0, c1, (tree *)nil);
}
@

<<function tree3>>=
tree*
tree3(int type, tree *c0, tree *c1, tree *c2)
{
    tree *t;

    <<[[tree3]] if some empty sequence>>
    // else
    t = newtree();
    t->type = type;
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@
% no check for c2 when use ';'? no because binary operator?


% opti
<<[[tree3]] if some empty sequence>>=
if(type==';'){
    if(c0==nil)
        return c1;
    if(c1==nil)
        return c0;
}
@



\section{Op[[Code]] and [[codebuf]]}

% shell = interpreter. Actually source -> AST -> opcode
% and then opcode interpreter, a bit like an actual processor
% (or Java). A little stack based interpreter.

<<global codebuf>>=
// growing_array<ref_own<Code>>
code *codebuf;				/* compiler output */
@
%ocaml: maybe could just interpret from AST itself.
% not sure needs this intermediate opcode data structure
%ocaml: ugly to use a global again.

<<struct code>>=
/*
 * The first word of any code vector is a reference count.
 * Always create a new reference to a code vector by calling codecopy(.).
 * Always call codefree(.) when deleting a reference.
 */
union Code {
    void	(*f)(void); // Xxxx() opcode
    int	i;
    char	*s;
};
@

% show bootstrap code?
% or show trace of rc -r ? with my simple bootstrap code!



% * Opcode routines
% * Arguments on stack (...)
% * Arguments in line [...]
% * Code in line with jump around {...}


% * Xsimple(args)			run command and wait
% * Xrdcmds !!! call yyparse()

% * Xmark				mark stack
% * Xword[string]			push string
% * Xpopm(value)			pop value from stack
% * Xcount(name)			push var count
% * Xconc(left, right)			concatenate, push results

% * Xassign(name, val)			assign val to name
% * Xdol(name)				get variable value
% * Xsub
% * Xlocal(name, val)			create local variable, assign value
% * Xunlocal				delete local variable

% * Xexit				rc exits with status
% * Xreturn				kill thread
% * Xerror

% * Xread(file)[fd]			open file to read
% * Xwrite(file)[fd]			open file to write
% * Xrdwr(file)[fd]			open file for reading and writing
% * Xappend(file)[fd]			open file to append
% * Xclose[i]				close file descriptor
% * Xdup[i j]				dup file descriptor

% * Xif
% * Xifnot
% * Xbang				complement condition
% * Xwastrue
% * Xfalse{...}				execute {} if false
% * Xtrue{...}				execute {} if true
% * Xcase(pat, value){...}		exec code on match, leave (value) on stack
% * Xmatch(pat, str)			match pattern, set status
% * Xfor(var, list){... Xreturn}	for loop
% * Xjump[addr]				goto

% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,	wait for both
% * Xpipewait
% * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output, depending on type), push /dev/fd/??

% * Xfn(name){... Xreturn}			define function
% * Xdelfn(name)				delete function definition

% * Xsubshell{... Xexit}		execute {} in a subshell and wait
% * Xasync{... Xexit}			make thread for {}, no wait
% * Xbackq{... Xreturn}			make thread for {}, push stdout

% * Xglob

% ???
% * Xdelhere
% * Xeflag
% * Xpopredir
% * Xrdfn
% * Xqdol(name)				concatenate variable components

% list of opcodes with comments were in exec.c but sorted alphabetically
% better to group them for explanation

% dol = dollar


% first element is a reference count, which is why codecopy()
% does cp[0].i++;

% Xfn -> <> 
<<function codecopy>>=
code*
codecopy(code *cp)
{
    cp[0].i++;
    return cp;
}
@
%ocaml: just use Gc? 

% when opcodes are shared? just for bootstrap? need this reference count?
% when define functions.

% Xreturn | Xfn | Xdelfn -> <>
<<function codefree>>=
void
codefree(code *cp)
{
    code *p;
    if(--cp[0].i != 0)
        return;

    for(p = cp+1; p->f; p++){
        if(p->f==Xappend || p->f==Xclose || p->f==Xread || p->f==Xwrite
        || p->f==Xrdwr
        || p->f==Xasync || p->f==Xbackq || p->f==Xcase || p->f==Xfalse
        || p->f==Xfor || p->f==Xjump
        || p->f==Xsubshell || p->f==Xtrue)
            p++;
        else if(p->f==Xdup || p->f==Xpipefd) 
                 p+=2;
        else if(p->f==Xpipe) 
                 p+=4;
        else if(p->f==Xword || p->f==Xdelhere) 
                 efree((++p)->s);
        else if(p->f==Xfn){
                 efree(p[2].s);
                 p+=2;
              }
    }
    efree((char *)cp);
}
@




\section{[[Thread]] and [[runq]]}

% why called threads?
% because they contains opcodes to execute.
% They are not the process. When interpreting the opcodes
% they may generate new process but they are not themselves
% processes.
% Still thread is maybe confusing.
% Maybe rename Program? but true that contains code, and pc!
% So it is a unit of execution (then maybe thread is a good name).


<<struct thread>>=
struct Thread {
    union Code *code;		/* code for this thread */
    int pc;			/* code[pc] is the next instruction */

    <<[[Thread]] other fields>>

    // Extra
    <<[[Thread]] extra fields>>
};
@
%dead fld:  tree *treenodes;		/* tree nodes created by this process */

<<global runq>>=
// stack<ref_own<Thread>> (next = Thread.ret)
thread *runq;
@
% x; y; z  would form a list of threads with x at the top and linked to y
% (and ultimately linked to the bootstrap thread)

% when put stuff on stack? when run commands, do x;y, then
% has opcodes of repl in stack, and add more process on top of it.

<<[[Thread]] extra fields>>=
thread *ret;		/* who continues when this finishes */
@


% freethread()? with reference count handling?

% important one!!
<<[[Thread]] other fields>>=
// list<list<ref_own<word>>> (next = List.next)
struct List *argv;		/* argument stack */
@
% list of list of words?

% runq->argv->words->next->word
% todo define macro? argv1()? argv0() ?


% really intepreter small language, have locals!
% TODO rename local -> locals?
<<[[Thread]] other fields>>=
// list<ref_own<Var>> (next = Var.next)
struct Var *local;		/* list of local variables */
@


% Similar to a machine emulator. Code, pc, stack, and heap (the vars).






\section{Words and lists}
% in appendix?

% saw argv in Thread before.

\subsection{[[Word]]s}

<<struct word>>=
/*
 * word lists are in correct order,
 * i.e. word0->word1->word2->word3->nil
 */
struct Word {
    char *word;

    // Extra
    word *next;
};
@
% could define W = nil so avoid those (word*)nil
%dup: similar to the one in Make.nw?

<<function newword>>=
word*
newword(char *wd, word *next)
{
    word *p = new(struct Word);
    p->word = strdup(wd);
    p->next = next;
    return p;
}
@
% =~ cons

% could also have mksingleword that does not take next.
% many calls to newword(foo, (word*)nil) that could be shorter.

<<function count>>=
int
count(word *w)
{
    int n;
    for(n = 0;w;n++) 
        w = w->next;
    return n;
}
@

<<function copywords>>=
/*
 * copy arglist a, adding the copy to the front of tail
 */
word*
copywords(word *a, word *tail)
{
    word *v = nil;
    word **end;

    for(end=&v;a;a = a->next,end=&(*end)->next)
        *end = newword(a->word, nil);
    *end = tail;
    return v;
}
@


<<function copynwords>>=
word*
copynwords(word *a, word *tail, int n)
{
    word *v = nil;
    word **end = &v;
    
    while(n-- > 0){
        *end = newword(a->word, 0);
        end = &(*end)->next;
        a = a->next;
    }
    *end = tail;
    return v;
}
@



<<function freewords>>=
void
freewords(word *w)
{
    word *nw;
    while(w){
        efree(w->word);
        nw = w->next;
        efree((char *)w);
        w = nw;
    }
}
@


% diff with freewords???
<<function freelist>>=
void
freelist(word *w)
{
    word *nw;
    while(w){
        nw = w->next;
        efree(w->word);
        efree((char *)w);
        w = nw;
    }
}
@


\subsection{[[List]] of lists of words}

<<struct list>>=
struct List {
    // list<ref_own<Word>> (next = Word.next)
    word *words;

    // Extra
    list *next;
};
@
% so it's actually a list of list (so fast concatenation?)







\section{[[Var]] and [[gvar]]}

% saw local vars in Thread before.

% what need vars for?
% when do X=1 in shell.
% also for setting status of special variable like "status".

<<struct var>>=
struct Var {
    // key
    char	*name;		/* ascii name */
    // value
    word	*val;		/* value */

    <<[[Var]] other fields>>
    // Extra
    <<[[Var]] extra fields>>
};
@
% when have local vars? when need that?

<<[[Var]] extra fields>>=
var	*next;		/* next on hash or local list */
@
% #define V (struct Var*)nil
% like for other soft, or use VarNil?



<<function setvar>>=
void
setvar(char *name, word *val)
{
    struct Var *v = vlook(name);
    freewords(v->val);
    v->val = val;
    v->changed = true;
}
@
% changed is for optimization reason to avoid rewriting in /env/xxx


<<function vlook>>=
var*
vlook(char *name)
{
    var *v;
    if(runq)
        for(v = runq->local;v;v = v->next)
            if(strcmp(v->name, name)==0) return v;

    return gvlook(name);
}
@
% use global runq again
% look for locals first, then gvlook




<<constant NVAR>>=
#define	NVAR	521
@

<<global gvar>>=
// map<string, ref_own<Var>> (next = Var.next in bucket list)
var *gvar[NVAR];		/* hash for globals */
@
% vs locals




<<function gvlook>>=
var*
gvlook(char *name)
{
    int h = hash(name, NVAR);
    var *v;

    for(v = gvar[h];v;v = v->next) 
        if(strcmp(v->name, name)==0) 
            return v;
    gvar[h] = newvar(strdup(name), gvar[h]);
    return gvar[h];
}
@
%old: return gvar[h] = newvar(strdup(name), gvar[h]);

<<function hash>>=
unsigned
hash(char *as, int n)
{
    int i = 1;
    unsigned h = 0;
    uchar *s;

    s = (uchar *)as;
    while (*s)
        h += *s++ * i++;
    return h % n;
}
@


<<function newvar>>=
var*
newvar(char *name, var *next)
{
    var *v = new(var);
    v->name = name;
    v->val = 0;

    v->fn = nil;
    v->changed = false;
    v->fnchanged = false;

    v->next = next;
    return v;
}
@
% changed and fnchanged are for optimization reason, to try
% to avoid writing in /env/xx when no need

% special variable, e.g. vlook("home"), vlook("*")








\chapter{[[main()]]}




\section{Overview}

<<[[main()]] locals>>=
code bootstrap[17];
@
% indeed 17 lines below about bootstrap. A bit ugly though

% see Chapter X for actual boostrap. I will simplify for now.

% mv comment back in Extra? less confusing with actual bootstrap vs simple one
%/*
% * get command line flags.
% * initialize keywords & traps.
% * get values from environment.
% * set $pid, $cflag, $*
% * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)
% * start interpreting code
% */

<<function main (rc/exec.c)>>=
void main(int argc, char *argv[])
{
    <<[[main()]] locals>>

    <<[[main()]] argc argv processing, modify flags>>

    <<[[main()]] initialisation>>
    <<[[main()]] initialize [[boostrap]]>>
    <<[[main()]] initialize runq with bootstrap code>>
    <<[[main()]] initialize runq->argv>>

    <<[[main()]] interpreter loop>>
}
@

\section{Command-line arguments processing, [[getflags()]]}


<<global flag>>=
// map<char, option<array<string>>>
char **flag[NFLAG];
@
% mv to bool flag[NFLAG]; ?
<<constant NFLAG>>=
#define	NFLAG	128
@
% #chars in ASCII

% =~ true (a bit ugly)
<<global flagset>>=
char *flagset[] = {"<flag>"};
@
%TODO: could transform global flag in bool flag[NFLAG] ?

<<[[main()]] argc argv processing, modify flags>>=
argc = getflags(argc, argv, "SsrdiIlxepvVc:1m:1[command]", 1);

if(argc==-1)
    usage("[file [arg ...]]");

if(argv[0][0]=='-')
    flag['l'] = flagset;
<<[[main()]] set -i flag>>
@
% what is '-' ?

% getflags() defined?


\subsection{Interactive mode, [[rc -i]]}

% mv later? advanced feature? hmm interactive is important notion.
<<[[main()]] set -i flag>>=
if(flag['I'])
    flag['i'] = nil;
else 
    if(flag['i']==nil && argc==1 && Isatty(STDIN)) 
       flag['i'] = flagset;
@

% interactive mode if no arguments!

<<function Isatty>>=
bool
Isatty(fdt fd)
{
    char buf[64];

    if(fd2path(fd, buf, sizeof buf) != 0)
        return false;

    /* might be #c/cons during boot - fixed 22 april 2005, remove this later */
    if(strcmp(buf, "#c/cons") == 0)
        return true;

    /* might be /mnt/term/dev/cons */
    return strlen(buf) >= 9 && strcmp(buf+strlen(buf)-9, "/dev/cons") == 0;
}
@


\section{Initialisation}

% put back global err here, with its Io type?

<<[[main()]] initialisation>>=
err = openfd(STDERR);
@
% err = openfd, use buffered IO lib, see appendix for error management.

<<[[main()]] initialisation>>=
kinit();    // initialize keywords
Trapinit(); // notify() function setup
Vinit();    // read environment variables and add them in gvar
@


\section{Bootstrapping opcodes (simplified)}

\ifallcode
<<[[main()]] locals>>=
int i;
@
\fi


% simplified bootstrap:
% Xrdcmds (which will call yyparse()->compile()->outcode()
%  which will read a line, compile it, and add a Xreturn
%when want to experiment with simplified bootstrap
% (don't forget to also modify mkfile and put 'rc2' for TARG
%OPTIONAL
<<[[main()]] initialize [[boostrap]]XXXXX>>=
memset(bootstrap, 0, sizeof bootstrap);

i = 0;
bootstrap[i++].i = 1; // reference count
bootstrap[i++].f = Xrdcmds;
bootstrap[i].i = 0;
@
%bootstrap[i++].f = XMark; ? necessary?
%bootstrap[i++].f = Xexit; ? Xexit never reached I think.
% 1 to reference count? why? they put 0 in compile() for new opcodes

\section{Setting [[runq]]}
% [[start()]]

<<[[main()]] initialize runq with bootstrap code>>=
start(bootstrap, 1, (var *)nil);
@
% starts at 1, 0 is for the reference count

% modify runq! usually called with pc = 1
% main | Xrdcmds | ??? -> <>
<<function start>>=
void
start(code *c, int pc, var *local)
{
    struct Thread *p = new(struct Thread);

    p->code = codecopy(c);
    p->pc = pc;

    p->argv = nil;
    p->local = local;
    p->lineno = 1;

    p->redir = p->startredir = runq ? runq->redir : nil;

    p->cmdfile = nil;
    p->cmdfd = nil;
    p->eof = false;
    p->iflag = false;

    // add_stack(runq, p)
    p->ret = runq;
    runq = p;
}
@
% not reset iflast to false?

% will go back to previous Thread (put in runq stack) if
% the new code does some Xreturn.
% So idea of subcomputation. With then fresh argv, fresh code list.

% When call start()? main, Xrdcmds. Xrdcmds is really
% a read/eval/print loop.

% very first time runq should be nil so p->ret points to nil.

\section{Setting [[runq->argv]]}

% now that runq set.

<<global argv0>>=
/*
 * Start executing the given code at the given pc with the given redirection
 */
char *argv0="rc";
@

<<[[main()]] initialize runq->argv>>=
/* prime bootstrap argv */
pushlist();
argv0 = strdup(argv[0]);
for(i = argc-1; i!=0; --i) 
    pushword(argv[i]);
@
% start from end because stack so at the end the top of the stack will
% be the first argument of the command


% see pushlist() below

% this list is actually manipulatd by Xmark, etc
% so runq->argv is the argument to the opcodes, not just
% to the simple command!

% main | Xmark ->  <>
<<function pushlist>>=
void
pushlist(void)
{
    list *p = new(list);

    // add_list(p, runq->argv)
    p->next = runq->argv;
    p->words = nil;
    runq->argv = p;
}
@
% use runq


<<function pushword>>=
void
pushword(char *wd)
{
    if(runq->argv==nil)
        panic("pushword but no argv!", 0);
    runq->argv->words = newword(wd, runq->argv->words);
}
@
% use global runq
% note that newword take the old value of the list so indeed
%  it adds wd in the list of words.



\section{Opcode interpreter loop}

<<[[main()]] interpreter loop>>=
for(;;){
    <<[[main()]] debug runq in interpreter loop>>

    runq->pc++;
    (*runq->code[runq->pc-1].f)();

    <<[[main()]] handing trap if necessary in interpreter loop>>
}
@
\section{The REPL, [[Xrdcmds()]]}
% X(opcode) read commands

% Xrdcmds =~ REPL, 
%  read (yylex+yyparse),
%  eval (compile+outcode+return to interpreter)
%  print? hmm partly in yylex for the prompt, the rest the program does it

<<function Xrdcmds>>=
void
Xrdcmds(void)
{
    struct Thread *p = runq;
    bool error;
    <<[[Xrdcmds()]] other locals>>

    <<[[Xrdcmds()]] flush errors and reset error count>>
    <<[[Xrdcmds()]] print status if -s>>
    <<[[Xrdcmds()]] set promptstr if interactive mode>>
    <<[[Xrdcmds()]] calls Noerror() before yyparse()>>

    // read cmd, compiles it, and modifies codebuf global
    error = yyparse();

    <<[[Xrdcmds()]] if yyparse() returned an error>>
    else{
        <<[[Xrdcmds()]] reset ntrap>>
        --p->pc;	/* re-execute Xrdcmds after codebuf runs */
        // modifies runq, new thread (linked to bootstrap one)
        start(codebuf, 1, runq->local);
    }
    freenodes(); // allocated in yyparse()
}
@
% will go back to Xrdcmds because of the Xreturn inserted in
% the codebuf by compile()
%ugly: use some globals everywhere. treenodes, codebuf
% so here yyparse call internally compile that modifies codebuf, but
% hard to see

% flow a bit complicated, but
% interpreter loop on runq->code -> Xrdcmds() -> yyparse() -> start(codebuf)
%  will go back in loop with a new runq! and once the command is done
%  with a Xreturn it will resume to Xrdcmds runq (the bootstrap queue)
%  and because of the --p->pc, it will restart on the Xrdcmds


% yyparse() use runq global, and special additional fields:
% (actually it's yylex())

<<[[Thread]] other fields>>=
struct Io *cmdfd;	/* file descriptor for Xrdcmd */
char *cmdfile;		/* file name in Xrdcmd */
bool iflag;		/* interactive? */
@
% who sets cmdfd? see below.

%OPTIONAL (really?)
<<[[main()]] initialize runq with bootstrap code>>=
runq->cmdfd = openfd(STDIN); // reading from stdin
runq->cmdfile = "<stdin>";
runq->iflag = flag['i']? true : false;// interactive mode; will print a prompt
@
% eof set to false in start()
% cmdfile setting is not necessary, but it's used in yyerror() so why 
% not set it

% this can be changed when do '.' ? to source a script?
% or when -c ?

% note that start() reset those fields.

% where cmdfd is used? in yylex() getnextc(), called from yyparse()


%XXX
% C-d generates an EOF?
<<[[Xrdcmds()]] if yyparse() returned an error>>=
if(error){
    if(!p->iflag  ||  p->eof && !Eintr()){
        if(p->cmdfile)
            efree(p->cmdfile);
        closeio(p->cmdfd);
        Xreturn();	/* should this be omitted? */
    }else{
        if(Eintr()){
            pchr(err, '\n');
            p->eof = false;
        }
        --p->pc;	/* go back for next command */
    }
}
@
% mv later?



\chapter{Input}
% so Lexing chapter cleaner

\section{Overview}

% yyparse() -> yylex() -> nextc() -> getnextc() which use runq->cmdfd to
% read stuff.


\section{Reading a character, [[getnext()]]}

% why return an int and not a char? because unicode? then use Rune!
% yylex -> nextc -> <>
<<function getnext>>=
/*
 * read a character from the input stream
 */	
int
getnext(void)
{
    int c;
    <<[[getnext()]] other locals>>

    <<[[getnext()]] peekc handling>>
    <<[[getnext()]] return if already at EOF>>
    <<[[getnext()]] prompt management part1>>

    c = rchr(runq->cmdfd);

    <<[[getnext()]] handle backslash>>
    <<[[getnext()]] prompt management part2>>
    <<[[getnext()]] if EOF>>
    <<[[getnext()]] if not EOF but verbose mode, print character read>>

    return c;
}
@
%old: was runq->eof++; ugly

% rchr() in annex? bufio library?


%XXX
% ndot??
<<[[getnext()]] if not EOF but verbose mode, print character read>>=
else 
    if(flag['V'] || ndot>=2 && flag['v'])
        pchr(err, c);
@
% mv later?

\subsection{End-of-file management}

<<constant EOF (rc/io.h)>>=
#define	EOF	(-1)
@

<<[[getnext()]] if EOF>>=
if(c==EOF)
    runq->eof = true;
@

<<[[Thread]] other fields>>=
bool eof;		/* is cmdfd at eof? */
@


<<[[getnext()]] return if already at EOF>>=
if(runq->eof)
    return EOF;
@

\subsection{Multi-lines and backslash}
% more on newlines later.

% if backslash, dont return backslash char, return after
% but only if not in a string, hence the !inquote guard below.

<<[[getnext()]] handle backslash>>=
if(!inquote && c=='\\'){

    c = rchr(runq->cmdfd);

    if(c=='\n' && !incomm){		/* don't continue a comment */
        <<[[getnext()]] when backslash and newline, set doprompt>>=
        c=' ';
    }
    else{
        peekc = c;
        c='\\';
    }
}
@
% need to look ahead to see if \\\n, so if was not \n, then
% return backslash and go back in input stream.
% but do that via peekc technique. Classic.


<<[[getnext()]] other locals>>=
static int peekc = EOF;
@

<<[[getnext()]] peekc handling>>=
if(peekc!=EOF){
    c = peekc;
    peekc = EOF;
    return c;
}
@



\subsection{Prompt}

% so $prompt is actually a 2 words list, first word = original
% and second word when it's a multiline command?

<<global doprompt>>=
bool doprompt = true;
@

% could be moved in another section?
<<global promptstr>>=
char *promptstr;
@

<<[[Xrdcmds()]] other locals>>=
word *prompt;
@
<<[[Xrdcmds()]] set promptstr if interactive mode>>=
if(runq->iflag){
    prompt = vlook("prompt")->val;
    if(prompt)
        promptstr = prompt->word;
    else
        promptstr="% ";
}
@



<<[[getnext()]] prompt management part1>>=
if(doprompt)
    // set doprompt back to false at the end
    pprompt();
@

<<function pprompt>>=
void
pprompt(void)
{
    var *prompt;

    if(runq->iflag){
        pstr(err, promptstr);
        flush(err);

        prompt = vlook("prompt");
        if(prompt->val && prompt->val->next)
            promptstr = prompt->val->next->word;
        else
            promptstr="\t";
    }
    runq->lineno++;
    doprompt = false;
}
@
% ?? why not % for the prompt? why changing the promptstr here?
% when multiline command! enter if(ls) ENTER => get a \t prompt


% so can display in prompt which command we are. useful also for history?
% to run a past command?
<<[[Thread]] other fields>>=
int lineno;			/* linenumber */
@


<<[[getnext()]] prompt management part2>>=
doprompt = doprompt || c=='\n' || c==EOF;
@

<<[[getnext()]] when backslash and newline, set doprompt>>=
doprompt = true;
@


\section{Look ahead, [[nextc()]] and [[advance()]]}

<<global future>>=
int future = EOF;
@

% yylex | advance | skipnl | nextis -> <>
<<function nextc>>=
/*
 * Look ahead in the input stream
 */
int
nextc(void)
{
    if(future==EOF)
        future = getnext();
    return future;
}
@
% future and peekc??
% so return same char until call advance().
% So can call nextc() from multiple places. nextc() acts then
% like a global.

% nextis -> <>
<<function advance>>=
/*
 * Consume the lookahead character.
 */
int
advance(void)
{
    int c = nextc();
    <<[[advance()]] save future in lastc>>
    future = EOF;
    return c;
}
@


% yylex -> <>
<<function nextis>>=
bool
nextis(int c)
{
    if(nextc()==c){
        advance();
        return true;
    }
    return false;
}
@
% check and then consume



\section{Multiline editing}

% special prompt, cf above.
% if enter {, then also special prompt indent (but just one level,
% does not handle more depth)




\chapter{Lexing}

% why not using lex? they like yacc but not lex apparently
% (because lex != flex? or because of multiline editing tricks
% that may be harder to implement with lex?)


\section{[[yylex()]]}

% lots of ugly lexing tricks:
% - newline and skipnl() after some operators
%   but kinda need it
% - keywords are transformed back into word after first word
%   on the line is parsed
% - SUB vs (
%   function def or call vs array subscript
% - special handling of [] after redirection and
%   parsing and AST building inside lexer (hmmm)

<<function yylex>>=
//@Scheck: called from yyparse()
int yylex(void)
{
    int c;
    <<[[yylex()]] other locals>>

    <<[[yylex()]] hack for SUB>>
    <<[[yylex()]] initialisations>>

    skipwhite();

    switch(c = advance()){
    <<[[yylex()]] switch c cases>>
    }
    // else
    <<[[yylex()]] if c is not a word character>>
    // else
    <<[[yylex()]] if c is a word character>>
}
@
%$
%todo:    // lastdol = false; factorize code?


% word character
<<function wordchr>>=
int
wordchr(int c)
{
    return !strchr("\n \t#;&|^$=`'{}()<>", c) && c!=EOF;
}
@
%$

% slash allowed here. A word can be a filename (e.g., path of a command
% /bin/ls, arg to a command /mnt, etc)


% identifier character
<<function idchr>>=
int
idchr(int c)
{
    /*
     * Formerly:
     * return 'a'<=c && c<='z' || 'A'<=c && c<='Z' || '0'<=c && c<='9'
     *	|| c=='_' || c=='*';
     */
    return c > ' ' && !strchr("!\"#$%&'()+,-./:;<=>?@[\\]^`{|}~", c);
}
@
%$
% slash not allowed here



<<[[yylex()]] switch c cases>>=
case EOF:
    lastdol = false;
    strcpy(tok, "EOF");
    return EOF;
@

<<global tok>>=
char tok[NTOK + UTFmax];
@
% why need that? can not store in yylval? just for debugging?
<<constant NTOK>>=
#define	NTOK	8192		/* maximum bytes in a word (token) */
@


\section{Spaces and comments}

<<global incomm>>=
bool incomm;
@
% global used also by getnext (<- nextc), because semantic of \
% is different when inside a comment

<<function skipwhite>>=
void
skipwhite(void)
{
    int c;
    for(;;){
        c = nextc();
        /* Why did this used to be  if(!inquote && c=='#') ?? */
        if(c=='#'){
            incomm = true;
            for(;;){
                c = nextc();
                if(c=='\n' || c==EOF) {
                    incomm = false;
                    break;
                }
                advance();
            }
        }
        if(c==' ' || c=='\t')
            advance();
        else 
            return;
    }
}
@
%could be a switch? clearer

% remember that nextc() does not advance. so basically like
% access a global next_character.


\section{Newlines}

% subtle! called from grammar, weird
% normally newlines marks the end of a command line to be processed.
% but when use |, &&, ||, it is common to enter a newline
% but this newline should be considered a whitespace to skip.
% But sometimes not. So sometimes in the lexer
% there are calls to skipnl to consume those whitespace and newlines

<<function skipnl>>=
void
skipnl(void)
{
    int c;
    for(;;){
        skipwhite();
        c = nextc();
        if(c!='\n')
            return;
        // consume the newline
        advance();
    }
}
@

\section{Operators}


<<[[yylex()]] switch c cases>>=
case '&':
    lastdol = false;
    if(nextis('&')){
        skipnl();
        strcpy(tok, "&&");
        return ANDAND;
    }
    strcpy(tok, "&");
    return '&';
@
% skipnl? so newline after && is not considered a command terminator.
% lexer trick again.
% MV to advanced feature? or remove?



<<[[yylex()]] switch c cases>>=
case '$':
    lastdol = true;
    if(nextis('#')){
        strcpy(tok, "$#");
        return COUNT;
    }
    if(nextis('"')){
        strcpy(tok, "$\"");
        return '"';
    }
    strcpy(tok, "$");
    return '$';
@
%$
% what is dollar and quote after?

<<global lastdol>>=
bool lastdol;	/* was the last token read '$' or '$#' or '"'? */
@
% dol = dollar




<<[[yylex()]] switch c cases>>=
case '|':
    lastdol = false;
    if(nextis('|')){
        skipnl();
        strcpy(tok, "||");
        return OROR;
    }
    // FALLTHROUGH
case '<':
case '>':
    lastdol = false;
    <<[[yylex()]] in switch when redirection character>>
@
% ugly that does some parsing inside lexer. Should be done in grammar.
% he even included a grammar in the comment. hmm



<<[[yylex()]] other locals>>=
char *w = tok;
@
<<[[yylex()]] other locals>>=
struct Tree *t;
@

<<[[yylex()]] initialisations>>=
yylval.tree = nil;
@

<<[[yylex()]] in switch when redirection character>>=
/*
 * funny redirection tokens:
 *	redir:	arrow | arrow '[' fd ']'
 *	arrow:	'<' | '<<' | '>' | '>>' | '|'
 *	fd:	digit | digit '=' | digit '=' digit
 *	digit:	'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
 * some possibilities are nonsensical and get a message.
 */
*w++=c;
t = newtree();
switch(c){
<<[[yylex()]] in switch when redirection character, switch c cases>>
}
<<[[yylex()]] in switch when redirection character, if bracket after>>
*w='\0';
yylval.tree = t;
if(t->type==PIPE)
    skipnl();
return t->type;
@




% MV LATER, anyway used where?
%an important set of field are for redirection, when type = REDIR
% in which case the kind of redirection is in rtype
<<[[Tree]] other fields>>=
//enum<Redirection_kind>
int	rtype;

fdt fd0;
fdt fd1;	/* details of REDIR PIPE DUP tokens */
@
% why need that in every AST nodes? can not encode info via some child?
% has fd0 fd1 because redirection in plan9 is very general. Can
% do lots of stuff.



<<constant WRITE>>=
#define	WRITE	2
@
<<constant READ>>=
#define	READ	3
@
% TODO enum!! redirection_kind?
<<constant APPEND>>=
#define	APPEND	1
@





<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '|':
    t->type = PIPE;
    t->fd0 = 1;
    t->fd1 = 0;
    break;
@

<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '>':
    t->type = REDIR;
    if(nextis('>')){
        t->rtype = APPEND;
        *w++=c;
    }
    else 
        t->rtype = WRITE;
    t->fd0 = 1;
    break;
@

<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '<':
    t->type = REDIR;
    <<[[yylex()]] in switch when redirection character, if here document>>
    <<[[yylex()]] in switch when redirection character, if read/write redirect>>
    else 
        t->rtype = READ;
    t->fd0 = 0;
    break;
@






<<[[yylex()]] if c is not a word character>>=
if(!wordchr(c)){
    lastdol = false;
    tok[0] = c;
    tok[1]='\0';
    return c;
}
@
% why need set tok? anyway it is a single character here

\section{Strings}


<<global inquote>>=
bool inquote;
@
% used before already

<<[[yylex()]] initialisations>>=
inquote = false;
@


<<global lastword (rc/lex.c)>>=
bool lastword;	/* was the last token read a word or compound word terminator? */
@
% rename last_tok_was_a_word

<<[[yylex()]] switch c cases>>=
case '\'':
    inquote = true;
    lastword = true;
    lastdol = false;
    for(;;){
        c = advance();
        if(c==EOF)
            break;
        if(c=='\''){
            if(nextc()!='\'')
                break;
            advance();
        }
        w = addutf(w, c);
    }
    if(w != nil)
        *w='\0';

    t = token(tok, WORD);
    t->quoted = true;

    yylval.tree = t;
    return t->type;
@
% classic double '' to represent a quote

% addutf in advanced topics, but essentially add character
% and if character start of unicode char, then consume more chars
% first.

<<[[Tree]] other fields>>=
bool	quoted;
@


% todo: rename tree_of_token?
<<function token>>=
tree*
token(char *str, int type)
{
    tree *t = newtree();

    t->type = type;
    t->str = strdup(str);
    return t;
}
@




\section{Keywords and identifiers}


<<[[yylex()]] if c is a word character>>=
for(;;){
    <<[[yylex()]] when c is a word character, if glob character>>
    w = addutf(w, c);

    c = nextc();
    if(lastdol ? !idchr(c) : !wordchr(c)) 
        break;
    advance();
}

lastword = true;
lastdol = false;
if(w!=nil)
    *w='\0';

t = klook(tok);
if(t->type != WORD)
    lastword = false;

t->quoted = false;

yylval.tree = t;
return t->type;
@

% after a dollar we accept only idchr.

%old:    if(lastdol ? !idchr(c) : !wordchr(c))  if inside if, hmmm




<<function klook>>=
tree*
klook(char *name)
{
    struct Kw *p;
    tree *t = token(name, WORD);

    for(p = kw[hash(name, NKW)];p;p = p->next)
        if(strcmp(p->name, name)==0){
            t->type = p->type;
            break;
        }
    return t;
}
@
% see token() in Code DS chapter
%dead:       t->iskw = true;


<<global kw>>=
struct Kw {
    char *name;
    int type;

    struct Kw *next;
} *kw[NKW];
@

<<constant NKW>>=
#define	NKW	30
@




% main() -> kinit()
<<function kinit>>=
void
kinit(void)
{
    kenter(FOR, "for");
    kenter(IN, "in");
    kenter(WHILE, "while");
    kenter(IF, "if");
    kenter(NOT, "not");
    kenter(SWITCH, "switch");
    kenter(FN, "fn");

    kenter(TWIDDLE, "~");
    kenter(BANG, "!");
    kenter(SUBSHELL, "@");
}
@
%new: I reordered

<<function kenter>>=
void
kenter(int type, char *name)
{
    int h = hash(name, NKW);
    struct Kw *p = new(struct Kw);
    p->type = type;
    p->name = name;
    p->next = kw[h];
    kw[h] = p;
}
@




\section{Array subscript}
% and automatic carret

% ( vs SUB. Call? vs array subscript.
% need two tokens otherwise ambiguity in grammar?
% 

<<[[yylex()]] other locals>>=
int d = nextc();
@

<<[[yylex()]] hack for SUB>>=
/*
 * Embarassing sneakiness:  if the last token read was a quoted or unquoted
 * WORD then we alter the meaning of what follows.  If the next character
 * is `(', we return SUB (a subscript paren) and consume the `('. Otherwise,
 * if the next character is the first character of a simple or compound word,
 * we insert a `^' before it.
 */
if(lastword){
    lastword = false;
    if(d=='('){
        advance();
        strcpy(tok, "( [SUB]");
        return SUB;
    }
    if(wordchr(d) || d=='\'' || d=='`' || d=='$' || d=='"'){
        strcpy(tok, "^");
        return '^';
    }
}
@
%$

% what is this ^ ?



\chapter{Parsing}

\section{Overview}

% I assume you understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.nw :) )
%(compared to ocamlyacc can have actions in the middle, and those actions
% count as indexable elements for the $xxx numbering ($1, $2, etc))

<<rc/syn.y>>=
%{
#include "rc.h"
#include "fns.h"
%}

%union {
 struct Tree *tree;
};

<<token declarations>>
<<priority and associativity declarations>>
<<type declarations>>

%%
<<grammar>>
@

 
<<priority and associativity declarations>>=
/* operator priorities -- lowest first */
%left IF WHILE FOR SWITCH ')' NOT
%left ANDAND OROR
%left BANG SUBSHELL
%left PIPE
%left '^'
%right '$' COUNT '"'
%left SUB
@


<<type declarations>>=
%type<tree> line cmd simple word comword
@

% comword for command word?

%less: rename? cmd -> statement, simple -> expression, word -> argument?

<<grammar>>=
rc: 
    /*empty*/       { return ERROR_1;}
|   line '\n'       { return !compile($1);}

<<line rule>>
<<cmd rule>>
<<simple rule>>
<<word rule>>
<<comword rule>>

<<other rules>>
@
%$

% if compile() return 0 it's an error, so here 1 = an error
% TODO: be more consistent, return compile() would be cleaner so no need
%  explanation
% Xrdcmds -> yyparse() ?

% newline has a semantic here!

% interesting DSL. must be easy to issue a command.
% don't want to do 'system("ls");' like in other languages.
% and want newline to have a special semantic role, a kind of implicit ';'
% but also want to have multiline statements ... so newline must be allowed
%  and not run the command sometimes.
% -xxx, /a/b, are treated as regular words! only ;&${[^ are specials







\ifallcode
<<type declarations>>=
%type<tree> first keyword words
%type<tree> paren brace body cmdsa cmdsan assign epilog redir
%type<tree> FOR IN WHILE IF NOT SWITCH FN
%type<tree> TWIDDLE BANG SUBSHELL  REDIR DUP PIPE    WORD
@
\fi

\ifallcode
<<constant YYMAXDEPTH>>=
//@Scheck: used in y.tab.c
#define	YYMAXDEPTH	500
@
\fi


\section{Simple commands}

% a line can have a single command (stmt)
<<line rule>>=
line:   
    cmd
<<line rule other cases>>
@
% can have ; and & here (why not in cmd? because newline issue?)

% a (single) command can be a simple "expression"
<<cmd rule>>=
cmd: 
    /*empty*/           {$$=nil;}
|   simple              {$$=simplemung($1);}
<<cmd rule other cases>>
@
%$
% can have complex stmt here

% simplemung() shown below later.
% "mung" means destructive update.

% an expression can be a "progcall" which is a simple serie of words
% (separated by spaces, curry style :) )
% with first word has some restrictions (the "function" name)
<<simple rule>>=
simple:
    first
|   simple word         {$$=tree2(ARGLIST, $1, $2);}
<<simple rule other cases>>
@
% can have redirection here in the other cases

% actually first can correspond to a progran, or a function, or a builtin.





<<other rules>>=
first:  
    comword 
|   first '^' word      {$$=tree2('^', $1, $3);}
@
% diff with word? first cannot be a keyword !!!


% basic identifier, a kind of primary expression
% -xxx, /a/b, are treated as regular words
<<comword rule>>=
comword: 
    WORD
<<comword rule other cases>>
@
% can have variables $XX and other complex arguments in other cases
% can have some kind of redirection also in other cases (??)


% a word can be any identifier or symbol or integer (WORD)
<<word rule>>=
word:   
    comword
|   word '^' word       {$$=tree2('^', $1, $3);}
|   keyword             {lastword=true; $1->type=WORD;}
@
%$

% keyword is ok after the first word and transformed as a WORD.
%ocaml: ugly? but true that you dont know which argument you gonna
% pass to some commands

<<other rules>>=
keyword: FOR|IN|WHILE|IF|NOT|TWIDDLE|BANG|SUBSHELL|SWITCH|FN
@


<<other rules>>=
words: 
    /*empty*/       {$$=(struct Tree*)nil;}
|   words word      {$$=tree2(WORDS, $1, $2);}
@
%$
% not used yet.




<<function simplemung>>=
/*
 * Add a SIMPLE node at the root of t and percolate all the redirections
 * up to the root.
 */
//@Scheck: used by syn.y
tree* simplemung(tree *t)
{
    tree *u;
    struct Io *s;

    t = tree1(SIMPLE, t);

    s = openstr();
    pfmt(s, "%t", t);
    t->str = strdup((char *)s->strp);
    closeio(s);

    <<[[simplemung()]] percolate redirections up to the root>>
    return t;
}
@
% saw ARGLIST above


<<[[simplemung()]] percolate redirections up to the root>>=
for(u = t->child[0]; u->type==ARGLIST; u = u->child[0]){
    if(u->child[1]->type==REDIR || u->child[1]->type==DUP){
        u->child[1]->child[1] = t;
        t = u->child[1];
        u->child[1] = nil;
    }
}
@
%ocaml: maybe should have redirection allowed only at the end?
% so then easy to put it also at the root of the AST.

\section{Operators}

% actually operators are at different levels, line rule, cmd rule,
% simple rule and so have different priotities.
% redirection is lower, then pipe and logic operators, then sequence

\subsection{Sequence}

<<line rule other cases>>=
|   cmdsa line      {$$=tree2(';', $1, $2);}
@

<<other rules>>=
cmdsa:  
    cmd ';'
|   cmd '&'         {$$=tree1('&', $1);}
@
%$
% separator, not terminator. Newline is the terminator

% cmdsa = command sequence or and

% x & y is really (x&); y

% newline is also a form of sequence when in the body { } of something

\subsection{Logical operators}
% Other operators?
% && ||  |  &  !?
% >> << > <

<<cmd rule other cases>>=
|   cmd ANDAND cmd      {$$=tree2(ANDAND, $1, $3);}
|   cmd OROR cmd        {$$=tree2(OROR, $1, $3);}
@
% why not merge with ; and & ?

% when argument of if/while in general
<<cmd rule other cases>>=
|   BANG cmd            {$$=mung1($1, $2);}
|   TWIDDLE word words  {$$=mung2($1, $2, $3);}
@
%$
% could also just do tree2(BANG, $2) I think

% redir is in simple/expr, so has more prirority


<<function mung1>>=
//@Scheck: used by syn.y
tree* mung1(tree *t, tree *c0)
{
    t->child[0] = c0;
    return t;
}
@

<<function mung2>>=
//@Scheck: used by syn.y
tree* mung2(tree *t, tree *c0, tree *c1)
{
    t->child[0] = c0;
    t->child[1] = c1;
    return t;
}
@

<<function mung3>>=
//@Scheck: used by syn.y
tree* mung3(tree *t, tree *c0, tree *c1, tree *c2)
{
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@

\subsection{Pipe}

<<cmd rule other cases>>=
|   cmd PIPE cmd        {$$=mung2($2, $1, $3);}
@
%$

\subsection{Redirections}

% at level of simple, below cmd, so higher prio than ||, &&, ;, etc
<<simple rule other cases>>=
|   simple redir        {$$=tree2(ARGLIST, $1, $2);}
@
% means can have multiple redir, ls < foo > bar, but after the funcall!
% means also that can have extra arguments still after the redir (ugly)

% ARGLIST but will be percolated back to the root in simplemung()

<<other rules>>=
redir:  
    REDIR word      {$$=mung1($1, $1->rtype==HERE ? heredoc($2) : $2);}
<<redir rule other cases>>
@



% other redirections!
% XXX?
<<cmd rule other cases>>=
|   brace epilog        {$$=epimung($1, $2);}
@

<<function epimung>>=
//@Scheck: used by syn.y
tree* epimung(tree *comp, tree *epi)
{
    tree *p;
    if(epi==0)
        return comp;
    for(p = epi;p->child[1];p = p->child[1]);
    p->child[1] = comp;
    return epi;
}
@


<<other rules>>=
epilog: 
    /*empty*/           {$$=nil;}
|   redir epilog        {$$=mung2($1, $1->child[0], $2);}
@
%$



% infix style
<<cmd rule other cases>>=
|   redir cmd  %prec BANG
        {$$=mung2($1, $1->child[0], $2);}
@
%$
% really need to support that?

\section{Control flow statements}

<<cmd rule other cases>>=
|   IF paren {skipnl();} cmd  {$$=mung2($1, $2, $4);}
|   IF NOT   {skipnl();} cmd  {$$=mung1($2, $4);}

|   WHILE paren {skipnl();} cmd    {$$=mung2($1, $2, $4);}
|   SWITCH word {skipnl();} brace  {$$=tree2(SWITCH, $2, $4);}

 /*
  * if ``words'' is nil, we need a tree element to distinguish between 
  * for(i in ) and for(i), the former being a loop over the empty set
  * and the latter being the implicit argument loop.  so if $5 is nil
  * (the empty set), we represent it as "()".  don't parenthesize non-nil
  * functions, to avoid growing parentheses every time we reread the
  * definition.
  */
|   FOR '(' word IN words ')' {skipnl();} cmd
    {$$=mung3($1, $3,    $5 ? $5 : tree1(PAREN, $5), $8);}

|   FOR '(' word ')' {skipnl();} cmd
    {$$=mung3($1, $3, (struct Tree *)0, $6);}
@
% why IF NOT? Why not simply ELSE?

% for(x) iterate over $*

<<other rules>>=
paren:  '(' body ')'        {$$=tree1(PCMD, $2);}
@
%$

<<token declarations>>=
%token PCMD
@
% but really like brace for semantic.
% but different from parens inside the For where it is a list of things
% then


<<other rules>>=
brace:  '{' body '}'        {$$=tree1(BRACE, $2);}
@
%$



% so multiline, or ;
% so first language using vertical layout :) not haskell :)
<<other rules>>=
body:   
    cmd
|   cmdsan body     {$$=tree2(';', $1, $2);}

cmdsan: 
    cmdsa
|   cmd '\n'
@
%$
% cmd sequence or and or newline





\section{Functions}

<<cmd rule other cases>>=
|   FN words brace  {$$=tree2(FN, $2, $3);}
|   FN words        {$$=tree1(FN, $2);}
@
%$
% words? fn with multiple words? can define alias on the same line?

% second line is for delfn. if type
% fn foo   without anything, then means delete the function.

\section{Variables}

% definitions

<<cmd rule other cases>>=
|   assign cmd %prec BANG   
      {$$=mung3($1, $1->child[0], $1->child[1], $2);}
@
% just add cmd as third child of =
% remember that cmd can be empty. In fact, if empty the semantic
% of the assignment changes. The binding is not just for the current command.

% A=1 ls

<<other rules>>=
assign: first '=' word      {$$=tree2('=', $1, $3);}
@
%$
% not words here? no cos cmd can contain list of words?
% but then variables contain a single word? not a list?
% for a list of words use () so X=(a b c d)


% uses

<<comword rule other cases>>=
|   '$' word        {$$=tree1('$', $2);}
|   COUNT word      {$$=tree1(COUNT, $2);}
|   '$' word SUB words ')'  {$$=tree2(SUB, $2, $4);}
@
%$

% SUB = '(' when after a word, subscript
% but what that mean? subscript, array access

\section{Lists}

<<comword rule other cases>>=
|   '(' words ')'   {$$=tree1(PAREN, $2);}
@
%$








\chapter{Opcode Generation and Interpretation}
% or Code generation? or Bytecode generation?
\n i merged Opcode Generation and Intepretation in one chapter
\n  because it helps to see the code generated from a tree.
\n We could also group with the related parsing, but maybe it would
\n  be too much, and parsing can be understood in isolation.

\section{Overview}

% recall main flow: main() -> ... -> Xrdcmds() -> yyparse() -> compile()

\subsection{[[emitxxx()]]}

% see codebuf in Core DS chapter (could be moved here too)

<<global codep>>=
// idx in codebuf
int codep;
@

% for the emitxxx() to realloc when necessary
<<global ncode>>=
int ncode;
@

% emit int
<<function emiti>>=
#define	emiti(x) ((codep!=ncode || morecode()), codebuf[codep].i = (x), codep++)
@
% return codep before! so can store for creating jmp

% emit function
<<function emitf>>=
#define	emitf(x) ((codep!=ncode || morecode()), codebuf[codep].f = (x), codep++)
@

% emit string
<<function emits>>=
#define	emits(x) ((codep!=ncode || morecode()), codebuf[codep].s = (x), codep++)
@

% growing array
<<function morecode>>=
//@Scheck: used by the macros above (why marked as dead then??? TODO)
int morecode(void)
{
    ncode+=100;
    codebuf = (code *)realloc((char *)codebuf, ncode*sizeof codebuf[0]);
    if(codebuf==nil)
        panic("Can't realloc %d bytes in morecode!", ncode*sizeof(code));
    return OK_0;
}
@


\subsection{[[compile()]]}


% modify codebuf!
<<function compile>>=
//@Scheck: called from syn.y
error0 compile(tree *t)
{
    ncode = 100;
    codep = 0;
    codebuf = (code *)emalloc(ncode*sizeof(code));

    emiti(0);			/* reference count */

    outcode(t, flag['e'] ? true : false);

    if(nerror){
        efree((char *)codebuf);
        return ERROR_0;
    }

    readhere();

    emitf(Xreturn);
    emitf(nil);

    return OK_1;
}
@

%readhere()?



\subsection{[[outcode()]]}

%UGLY
<<constant c0 (rc/code.c)>>=
#define	c0	t->child[0]
@

<<constant c1 (rc/code.c)>>=
#define	c1	t->child[1]
@

<<constant c2 (rc/code.c)>>=
#define	c2	t->child[2]
@


% modify codebuf via all those emitxxx()
% todo: could return errorcode instead of using nerror global
<<function outcode>>=
void
outcode(tree *t, bool eflag)
{
    <<[[outcode()]] locals>>

    if(t==nil)
        return;

    <<[[outcode()]] set iflast before switch>>
    switch(t->type){
    <<[[outcode()]] cases>>
    default:
        pfmt(err, "bad type %d in outcode\n", t->type);
        break;
    }
    <<[[outcode()]] set iflast after switch>>
}
@
%$

% XXX
<<[[outcode()]] locals>>=
tree *tt;
@

\subsection{[[argv]] management}

% used for each word in the compiled command
<<function Xword>>=
void
Xword(void)
{
    pushword(runq->code[runq->pc++].s);
}
@

% pushword() shown before.


% used to start a new list of words for a new command
% used when compiling SIMPLE commands
% used also for TWIDDLE, FOR, etc.
<<function Xmark>>=
void
Xmark(void)
{
    pushlist();
}
@

% pushlist() shown before

% used by swich only. Mv later?
<<function Xpopm>>=
void
Xpopm(void)
{
    poplist();
}
@

<<function poplist>>=
void
poplist(void)
{
    list *p = runq->argv;
    if(p==nil)
        panic("poplist but no argv", 0);
    freelist(p->words);
    runq->argv = p->next;
    efree((char *)p);
}
@




% execexec -> <>
<<function popword>>=
void
popword(void)
{
    word *p;
    if(runq->argv==nil)
        panic("popword but no argv!", 0);
    p = runq->argv->words;
    if(p==nil)
        panic("popword but no word!", 0);
    runq->argv->words = p->next;
    efree(p->word);
    efree((char *)p);
}
@


\subsection{Process status managment}

% was $$ in bash

<<function setstatus>>=
void
setstatus(char *s)
{
    setvar("status", newword(s, (word *)nil));
}
@

<<function getstatus>>=
char*
getstatus(void)
{
    var *status = vlook("status");
    return status->val ? status->val->word : "";
}
@

<<function truestatus>>=
bool
truestatus(void)
{
    char *s;
    for(s = getstatus();*s;s++)
        if(*s!='|' && *s!='0')
            return false;
    return true;
}
@
% what is this pipe in status? because when do ls | wc 
%  then rc combine the return status of both in one string
%  with | in the middle. so if 0|0 then everthing is file,
%  but if error in one of then then should return an error.
% so if return string is empty, or contains only 0 or |, then fine

\subsection{Subprocesses managment}
% children

<<global waitpids>>=
// growing_array<pid> (but really a list)
int *waitpids;
@
<<global nwaitpids>>=
int nwaitpids;
@

<<function addwaitpid>>=
void
addwaitpid(int pid)
{
    waitpids = realloc(waitpids, (nwaitpids+1)*sizeof waitpids[0]);
    if(waitpids == nil)
        panic("Can't realloc %d waitpids", nwaitpids+1);
    waitpids[nwaitpids++] = pid;
}
@

<<function delwaitpid>>=
void
delwaitpid(int pid)
{
    int r, w;
    
    for(r=w=0; r<nwaitpids; r++)
        if(waitpids[r] != pid)
            waitpids[w++] = waitpids[r];
    nwaitpids = w;
}
@

<<function clearwaitpids>>=
void
clearwaitpids(void)
{
    nwaitpids = 0;
}
@

<<function havewaitpid>>=
bool
havewaitpid(int pid)
{
    int i;

    for(i=0; i<nwaitpids; i++)
        if(waitpids[i] == pid)
            return true;
    return false;
}
@

\section{Simple commands}
% or builtins or functions


\subsection{Opcode generation}

% SIMPLE node built in simplemung()

<<[[outcode()]] cases>>=
case SIMPLE:
    emitf(Xmark);
    outcode(c0, eflag); // the arguments and argv0
    emitf(Xsimple);
    <<[[outcode()]] emit Xeflag after Xsimple>>
    break;
@

% Xmark so new argv for this command
% then this will do some Xword and put in runq->argv a bunch
%  of words
% then Xsimple executuon

% ARGLIST is for the parameters of the simple command, the arguments,
% which are mostly word and so push in the stack (runq->argv)
% and also final = argv0
<<[[outcode()]] cases>>=
case ARGLIST:
    outcode(c1, eflag);
    outcode(c0, eflag);
    break;
@
% put in reverse order, cos this will lead to some
% Xword which will populate argv stack, so must be in reverse
% order so last word emited in codebuf is first in the runq->words stack.

<<[[outcode()]] cases>>=
case WORDS:
    outcode(c1, eflag);
    outcode(c0, eflag);
    break;
@

<<[[outcode()]] cases>>=
case WORD:
    emitf(Xword);
    emits(strdup(t->str));
    break;
@
% the string is inline in codebuf


\subsection{[[Xsimple()]]}

% * Xsimple(args)			run command and wait
<<function Xsimple>>=
void
Xsimple(void)
{
    word *a;
    thread *p = runq;
    int pid;
    <<[[Xsimple()]] other locals>>

    globlist();

    a = runq->argv->words;
    if(a==nil){
        Xerror1("empty argument list");
        return;
    }
    if(flag['x'])
        pfmt(err, "%v\n", p->argv->words); /* wrong, should do redirs */

    <<[[Xsimple()]] if argv0 is a function>>
    else{
        <<[[Xsimple()]] if argv0 is a builtin>>
        <<[[Xsimple()]] if exitnext()>>
        else{
            flush(err);
            Updenv();	/* necessary so changes don't go out again */
            if((pid = execforkexec()) < 0){
                Xerror("try again");
                return;
            }

            /* interrupts don't get us out */
            poplist();
            while(Waitfor(pid, 1) < 0)
                ;
        }
    }
}
@

% globlist is for globbing. See advanced topics.

<<function Xerror>>=
void
Xerror(char *s)
{
    if(strcmp(argv0, "rc")==0 || strcmp(argv0, "/bin/rc")==0)
        pfmt(err, "rc: %s: %r\n", s);
    else
        pfmt(err, "rc (%s): %s: %r\n", argv0, s);
    flush(err);
    setstatus("error");
    while(!runq->iflag) 
        Xreturn();
}
@

% diff with Xerror? does not print the %r
<<function Xerror1>>=
void
Xerror1(char *s)
{
    if(strcmp(argv0, "rc")==0 || strcmp(argv0, "/bin/rc")==0)
        pfmt(err, "rc: %s\n", s);
    else
        pfmt(err, "rc (%s): %s\n", argv0, s);
    flush(err);
    setstatus("error");
    while(!runq->iflag) 
        Xreturn();
}
@

\subsection{Fork}

% fundamental of a shell! fork exec wait
<<function execforkexec>>=
int
execforkexec(void)
{
    int pid;
    int n;
    char buf[ERRMAX];

    // fork()!!
    switch(pid = fork()){
    case -1:
        return -1;
    case 0: // child
        clearwaitpids();
        pushword("exec");
        execexec();

        // should not be reached!
        strcpy(buf, "can't exec: ");
        n = strlen(buf);
        errstr(buf+n, ERRMAX-n);
        Exit(buf);
    }
    // parent
    addwaitpid(pid);
    return pid;
}
@

\subsection{Exec}

% execforkexec | ?? -> <>
<<function execexec>>=
void
execexec(void)
{
    popword();	/* "exec" */
    if(runq->argv->words==nil){
        Xerror1("empty argument list");
        return;
    }
    doredir(runq->redir);

    Execute(runq->argv->words, searchpath(runq->argv->words->word));
    // should not be reached!
    poplist();
}
@
% why push exec if after you pop it anyway?
% pass argv0 to searchpath


<<function searchpath>>=
word*
searchpath(char *w)
{
    word *path;

    if(strncmp(w, "/", 1)==0
    || strncmp(w, "#", 1)==0
    || strncmp(w, "./", 2)==0
    || strncmp(w, "../", 3)==0
    || (path = vlook("path")->val)==nil)
        path=&nullpath;
    return path;
}
@
% # is for device path in plan9

<<global nullpath>>=
struct Word nullpath = { "", nil};
@



<<function Execute>>=
void
Execute(word *args, word *path)
{
    char **argv = mkargv(args);
    char file[1024], errstr[1024];
    int nc;

    Updenv();
    errstr[0] = '\0';

    for(;path;path = path->next){
        nc = strlen(path->word);
        if(nc < sizeof file - 1){	/* 1 for / */
            strcpy(file, path->word);
            if(file[0]){
                strcat(file, "/");
                nc++;
            }
            if(nc + strlen(argv[1]) < sizeof file){
                strcat(file, argv[1]);

                // The actual exec() system call!
                exec(file, argv+1);

                // should not be reached!
                rerrstr(errstr, sizeof errstr);
                /*
                 * if file exists and is executable, exec should
                 * have worked, unless it's a directory or an
                 * executable for another architecture.  in
                 * particular, if it failed due to lack of
                 * swap/vm (e.g., arg. list too long) or other
                 * allocation failure, stop searching and print
                 * the reason for failure.
                 */
                if (strstr(errstr, " allocat") != nil ||
                    strstr(errstr, " full") != nil)
                    break;
            }
            else werrstr("command name too long");
        }
    }
    // should not be reached if found an actual binary to exec
    pfmt(err, "%s: %s\n", argv[1], errstr);
    efree((char *)argv);
}
@

<<function mkargv>>=
char **
mkargv(word *a)
{
    char **argv = (char **)emalloc((count(a)+2) * sizeof(char *));
    char **argp = argv+1;	/* leave one at front for runcoms */

    for(;a;a = a->next) 
        *argp++=a->word;
    *argp = nil;
    return argv;
}
@

\subsection{Wait}

% In the mean time, in the parent process

% Xsimple -> <>
<<function Waitfor>>=
int
Waitfor(int pid, int)
{
    thread *p;
    Waitmsg *w;
    char errbuf[ERRMAX];

    if(pid >= 0 && !havewaitpid(pid))
        return 0;

    // wait()!!
    while((w = wait()) != nil){
        delwaitpid(w->pid);
        if(w->pid==pid){
            setstatus(w->msg);
            free(w);
            return 0;
        }
        // else
        for(p = runq->ret;p;p = p->ret)
            if(p->pid==w->pid){
                p->pid=-1;
                strcpy(p->status, w->msg);
            }
        free(w);
    }

    errstr(errbuf, sizeof errbuf);
    if(strcmp(errbuf, "interrupted")==0) 
        return -1;
    return 0;
}
@

<<[[Thread]] other fields>>=
char status[NSTATUS];	/* status for Xpipewait */
@
<<constant NSTATUS>>=
#define	NSTATUS	ERRMAX			/* length of status (from plan 9) */
@



\subsection{Fork optimization}

% it is an optimisation then? mv to advanced topics?
%  when have exit in codebuf?
<<[[Xsimple()]] if exitnext()>>=
if(exitnext()){
    /* fork and wait is redundant */
    pushword("exec");
    execexec();
    Xexit();
}
@

<<function exitnext>>=
/*
 * Search through the following code to see if we're just going to exit.
 */
int
exitnext(void){
    union Code *c = &runq->code[runq->pc];
    while(c->f==Xpopredir) 
        c++;
    return c->f==Xexit;
}
@

\section{Operators}

\subsection{Sequence}

<<[[outcode()]] cases>>=
case ';':
    outcode(c0, eflag);
    outcode(c1, eflag);
    break;
@
% simple :)




\subsection{Logical operators}

<<[[outcode()]] locals>>=
int p;
@

<<[[outcode()]] cases>>=
case ANDAND:
    outcode(c0, false);
    emitf(Xtrue);
    p = emiti(0);
    outcode(c1, eflag);
    stuffdot(p);
    break;
@
% pass false to outcode, cos dont care about checking error status
%  of first cmd in  cmd1 && cmd2

% jump technique
<<function stuffdot>>=
void
stuffdot(int a)
{
    if(a<0 || codep<=a)
        panic("Bad address %d in stuffdot", a);
    codebuf[a].i = codep;
}
@
% stuffdot meaning?
% so this allow to generate a jump forward.



<<[[outcode()]] cases>>=
case OROR:
    outcode(c0, false);
    emitf(Xfalse);
    p = emiti(0);
    outcode(c1, eflag);
    stuffdot(p);
    break;
@

<<function Xtrue>>=
void
Xtrue(void)
{
    if(truestatus()) runq->pc++;
    else runq->pc = runq->code[runq->pc].i;
}
@

<<function Xfalse>>=
void
Xfalse(void)
{
    if(truestatus()) runq->pc = runq->code[runq->pc].i;
    else runq->pc++;
}
@




<<[[outcode()]] cases>>=
case BANG:
    outcode(c0, eflag);
    emitf(Xbang);
    break;
@

<<function Xbang>>=
void
Xbang(void)
{
    setstatus(truestatus()? "false" : "");
}
@


\subsection{String matching}


<<[[outcode()]] cases>>=
case TWIDDLE:
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xmatch);
    if(eflag)
        emitf(Xeflag);
    break;
@

<<function Xmatch>>=
void
Xmatch(void)
{
    word *p;
    char *subject;
    subject = list2str(runq->argv->words);
    setstatus("no match");
    for(p = runq->argv->next->words;p;p = p->next)
        if(match(subject, p->word, '\0')){
            setstatus("");
            break;
        }
    efree(subject);
    poplist();
    poplist();
}
@



% see also /bin/test! often used as argument to if()

\subsection{Asynchronous execution}

<<[[outcode()]] cases>>=
case '&':
    emitf(Xasync);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    break;
@



% * Xasync{... Xexit}			make thread for {}, no wait
<<function Xasync>>=
void
Xasync(void)
{
    fdt null = open("/dev/null", 0);
    int pid;
    char npid[10];
    if(null<0){
        Xerror("Can't open /dev/null\n");
        return;
    }
    switch(pid = rfork(RFFDG|RFPROC|RFNOTEG)){
    case -1:
        close(null);
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        pushredir(ROPEN, null, 0);
        // start a new Thread runq->pc+1 so skip pointer to code after &
        start(runq->code, runq->pc+1, runq->local);
        runq->ret = 0;
        break;
    default: // parent
        addwaitpid(pid);
        close(null);
        // jump to code after &
        runq->pc = runq->code[runq->pc].i;
        inttoascii(npid, pid);
        setvar("apid", newword(npid, (word *)nil));
        break;
    }
}
@

% mypid is global set at the very beginning
<<function Xexit>>=
void
Xexit(void)
{
    struct Var *trapreq;
    struct Word *starval;
    static bool beenhere = false;

    if(getpid()==mypid && !beenhere){
        trapreq = vlook("sigexit");
        if(trapreq->fn){
            beenhere = true;
            --runq->pc;
            starval = vlook("*")->val;
            start(trapreq->fn, trapreq->pc, (struct Var *)0);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)0);
            runq->local->changed = true;
            runq->redir = runq->startredir = 0;
            return;
        }
    }
    Exit(getstatus());
}
@




\subsection{Pipe}


<<[[outcode()]] locals>>=
int q;
@


% ls | wc => 

% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,
% * 					wait for both
% * Xpipewait

<<[[outcode()]] cases>>=
case PIPE:
    emitf(Xpipe);
    emiti(t->fd0); // 1
    emiti(t->fd1); // 0
    p = emiti(0);
    q = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    outcode(c1, eflag);
    emitf(Xreturn);
    stuffdot(q);
    emitf(Xpipewait);
    break;
@


<<function Xreturn>>=
void
Xreturn(void)
{
    struct Thread *p = runq;
    turfredir();
    while(p->argv) 
        poplist();
    codefree(p->code);

    // pop(runq)
    runq = p->ret;

    efree((char *)p);
    if(runq==nil)
        Exit(getstatus());
}
@






% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,	wait for both

<<function Xpipe>>=
void
Xpipe(void)
{
    struct Thread *p = runq;
    int pc = p->pc;
    int forkid;
    fdt lfd = p->code[pc++].i;
    fdt rfd = p->code[pc++].i;
    fdt pfd[2];
    if(pipe(pfd)<0){
        Xerror("can't get pipe");
        return;
    }
    switch(forkid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        start(p->code, pc+2, runq->local);
        runq->ret = 0;
        close(pfd[PRD]);
        pushredir(ROPEN, pfd[PWR], lfd);
        break;
    default: // parent
        addwaitpid(forkid);
        start(p->code, p->code[pc].i, runq->local);
        close(pfd[PWR]);
        pushredir(ROPEN, pfd[PRD], rfd);
        p->pc = p->code[pc+1].i;
        p->pid = forkid;
        break;
    }
}
@

<<[[Thread]] other fields>>=
int pid;		/* process for Xpipewait to wait for */
@



<<function Xpipewait>>=
void
Xpipewait(void)
{
    char status[NSTATUS+1];
    if(runq->pid==-1)
        setstatus(concstatus(runq->status, getstatus()));
    else{
        strncpy(status, getstatus(), NSTATUS);
        status[NSTATUS]='\0';
        Waitfor(runq->pid, 1);
        runq->pid=-1;
        setstatus(concstatus(getstatus(), status));
    }
}
@

<<function concstatus>>=
char*
concstatus(char *s, char *t)
{
    static char v[NSTATUS+1];
    int n = strlen(s);
    strncpy(v, s, NSTATUS);
    if(n<NSTATUS){
        v[n]='|';
        strncpy(v+n+1, t, NSTATUS-n-1);
    }
    v[NSTATUS]='\0';
    return v;
}
@











\subsection{Redirection}

<<[[outcode()]] cases>>=
case REDIR:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xglob);

    switch(t->rtype){
    <<[[outcode()]] when REDIR case, switch redirection type cases>>
    }
    emiti(t->fd0);
    outcode(c1, eflag);
    emitf(Xpopredir);
    break;
@

<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case WRITE:
    emitf(Xwrite);
    break;
@


<<function Xwrite>>=
void
Xwrite(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1("> requires singleton\n");
        return;
    case 0:
        Xerror1("> requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = Creat(file))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@



<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case READ:
case HERE:
    emitf(Xread);
    break;
@


<<function Xread>>=
void
Xread(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1("< requires singleton\n");
        return;
    case 0:
        Xerror1("< requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, 0))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@


<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case APPEND:
    emitf(Xappend);
    break;
@


<<function Xappend>>=
void
Xappend(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1(">> requires singleton");
        return;
    case 0:
        Xerror1(">> requires file");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, 1))<0 && (f = Creat(file))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    Seek(f, 0L, 2);
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@







<<[[Thread]] other fields>>=
struct Redir *redir;	/* redirection stack */
@


<<function pushredir>>=
void
pushredir(int type, int from, int to)
{
    redir * rp = new(redir);
    rp->type = type;
    rp->from = from;
    rp->to = to;
    rp->next = runq->redir;
    runq->redir = rp;
}
@

<<[[Thread]] other fields>>=
struct Redir *startredir;	/* redir inheritance point */
@


<<function turfredir>>=
void
turfredir(void)
{
    while(runq->redir != runq->startredir)
        Xpopredir();
}
@

<<function Xpopredir>>=
void
Xpopredir(void)
{
    struct Redir *rp = runq->redir;
    if(rp==0)
        panic("turfredir null!", 0);
    runq->redir = rp->next;
    if(rp->type==ROPEN)
        close(rp->from);
    efree((char *)rp);
}
@


% execexec -> <>
<<function doredir>>=
void
doredir(redir *rp)
{
    if(rp){
        doredir(rp->next);
        switch(rp->type){
        <<[[doredir()]] switch redir type cases>>
        }
    }
}
@


<<[[doredir()]] switch redir type cases>>=
case ROPEN:
    if(rp->from!=rp->to){
        Dup(rp->from, rp->to);
        close(rp->from);
    }
    break;
@

<<constant ROPEN>>=
/*
 * redir types
 */
#define	ROPEN	1			/* dup2(from, to); close(from); */
@



<<struct redir>>=
struct Redir {
    // enum<redirection_kind_bis>
    char type;	/* what to do */

    /* what to do it to */
    short from;
    short to;

    struct Redir *next;		/* what else to do (reverse order) */
};
@







\section{Control flow statements}

\subsection{If}

% remember than in rc there is   'if ( )' and 'if not' for else.

<<[[outcode()]] cases>>=
case IF:
    outcode(c0, false);
    emitf(Xif);
    p = emiti(0);
    outcode(c1, eflag);
    emitf(Xwastrue);
    stuffdot(p);
    break;
@


<<function Xif>>=
void
Xif(void)
{
    ifnot = true;
    if(truestatus()) 
        runq->pc++;
    else 
        runq->pc = runq->code[runq->pc].i;
}
@

<<global ifnot>>=
bool ifnot;		/* dynamic if not flag */
@


<<function Xwastrue>>=
void
Xwastrue(void)
{
    ifnot = false;
}
@




<<[[outcode()]] cases>>=
case NOT:
    <<[[outcode()]] when NOT, sanity check last command was an if>>=
    emitf(Xifnot);
    p = emiti(0);
    outcode(c0, eflag);
    stuffdot(p);
    break;
@

<<function Xifnot>>=
void
Xifnot(void)
{
    if(ifnot)
        runq->pc++;
    else
        runq->pc = runq->code[runq->pc].i;
}
@


<<[[outcode()]] when NOT, sanity check last command was an if>>=
if(!runq->iflast)
    yyerror("`if not' does not follow `if(...)'");
@

% should be handled via grammar
<<[[Thread]] other fields>>=
bool iflast;		/* static `if not' checking */
@

<<[[outcode()]] set iflast after switch>>=
if(t->type!=NOT && t->type!=';')
    runq->iflast = t->type==IF;
else 
   if(c0) 
       runq->iflast = c0->type==IF;
@

<<[[outcode()]] set iflast before switch>>=
if(t->type!=NOT && t->type!=';')
    runq->iflast = false;
@


\subsection{While}

<<[[outcode()]] cases>>=
case WHILE:
    q = codep;
    outcode(c0, false);
    if(q==codep)
        emitf(Xsettrue);	/* empty condition == while(true) */
    emitf(Xtrue);
    p = emiti(0);
    outcode(c1, eflag);
    emitf(Xjump);
    emiti(q);
    stuffdot(p);
    break;
@

<<function Xsettrue>>=
void
Xsettrue(void)
{
    setstatus("");
}
@

<<function Xjump>>=
void
Xjump(void)
{
    runq->pc = runq->code[runq->pc].i;
}
@

\subsection{For}

% why Xmark?

<<[[outcode()]] cases>>=
case FOR:
    emitf(Xmark);
    if(c1){
        outcode(c1, eflag);
        emitf(Xglob);
    }
    else{
        emitf(Xmark);
        emitf(Xword);
        emits(strdup("*"));
        emitf(Xdol);
    }
    emitf(Xmark);		/* dummy value for Xlocal */
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xlocal);
    p = emitf(Xfor);
    q = emiti(0);
    outcode(c2, eflag);
    emitf(Xjump);
    emiti(p);
    stuffdot(q);
    emitf(Xunlocal);
    break;
@

<<function Xfor>>=
void
Xfor(void)
{
    if(runq->argv->words==0){
        poplist();
        runq->pc = runq->code[runq->pc].i;
    }
    else{
        freelist(runq->local->val);
        runq->local->val = runq->argv->words;
        runq->local->changed = true;
        runq->argv->words = runq->argv->words->next;
        runq->local->val->next = 0;
        runq->pc++;
    }
}
@


\subsection{Switch}

<<[[outcode()]] cases>>=
case SWITCH:
    codeswitch(t, eflag);
    break;
@

<<function codeswitch>>=
/*
 * switch code looks like this:
 *	Xmark
 *	(get switch value)
 *	Xjump	1f
 * out:	Xjump	leave
 * 1:	Xmark
 *	(get case values)
 *	Xcase	1f
 *	(commands)
 *	Xjump	out
 * 1:	Xmark
 *	(get case values)
 *	Xcase	1f
 *	(commands)
 *	Xjump	out
 * 1:
 * leave:
 *	Xpopm
 */
void
codeswitch(tree *t, bool eflag)
{
    int leave;		/* patch jump address to leave switch */
    int out;		/* jump here to leave switch */
    int nextcase;	/* patch jump address to next case */
    tree *tt;
    if(c1->child[0]==nil
    || c1->child[0]->type!=';'
    || !iscase(c1->child[0]->child[0])){
        yyerror("case missing in switch");
        return;
    }
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xjump);
    nextcase = emiti(0);
    out = emitf(Xjump);
    leave = emiti(0);
    stuffdot(nextcase);
    t = c1->child[0];
    while(t->type==';'){
        tt = c1;
        emitf(Xmark);
        for(t = c0->child[0];t->type==ARGLIST;t = c0) outcode(c1, eflag);
        emitf(Xcase);
        nextcase = emiti(0);
        t = tt;
        for(;;){
            if(t->type==';'){
                if(iscase(c0)) break;
                outcode(c0, eflag);
                t = c1;
            }
            else{
                if(!iscase(t)) outcode(t, eflag);
                break;
            }
        }
        emitf(Xjump);
        emiti(out);
        stuffdot(nextcase);
    }
    stuffdot(leave);
    emitf(Xpopm);
}
@

<<function iscase>>=
bool
iscase(tree *t)
{
    if(t->type!=SIMPLE)
        return false;
    do { t = c0; } while(t->type==ARGLIST);
    return t->type==WORD && !t->quoted && strcmp(t->str, "case")==0;
}
@

% * Xcase(pat, value){...}		exec code on match, leave (value) on

<<function Xcase>>=
void
Xcase(void)
{
    word *p;
    char *s;
    int ok = 0;
    s = list2str(runq->argv->next->words);
    for(p = runq->argv->words;p;p = p->next){
        if(match(s, p->word, '\0')){
            ok = 1;
            break;
        }
    }
    efree(s);
    if(ok)
        runq->pc++;
    else
        runq->pc = runq->code[runq->pc].i;
    poplist();
}
@

<<function list2str>>=
char*
list2str(word *words)
{
    char *value, *s, *t;
    int len = 0;
    word *ap;
    for(ap = words;ap;ap = ap->next)
        len+=1+strlen(ap->word);
    value = emalloc(len+1);
    s = value;
    for(ap = words;ap;ap = ap->next){
        for(t = ap->word;*t;) *s++=*t++;
        *s++=' ';
    }
    if(s==value)
        *s='\0';
    else s[-1]='\0';
    return value;
}
@


\subsection{Blocks}

<<[[outcode()]] cases>>=
case PAREN:
    outcode(c0, eflag);
    break;
@

<<[[outcode()]] cases>>=
case PCMD:
case BRACE:
    outcode(c0, eflag);
    break;
@


\section{Functions}


<<[[Var]] other fields>>=
code	*fn;		/* pointer to function's code vector */
int	pc;		/* pc of start of function */
bool	fnchanged;
@

% defs

% * Xfn(name){... Xreturn}			define function
% * Xdelfn(name)				delete function definition
<<[[outcode()]] cases>>=
case FN:
    emitf(Xmark);
    outcode(c0, eflag);
    if(c1){
        emitf(Xfn);
        p = emiti(0);
        emits(fnstr(c1));
        outcode(c1, eflag);
        emitf(Xunlocal);	/* get rid of $* */ //$
        emitf(Xreturn);
        stuffdot(p);
    }
    else
        emitf(Xdelfn);
    break;
@

<<function fnstr>>=
char*
fnstr(tree *t)
{
    void *v;
    extern char nl;
    char svnl = nl;
    io *f = openstr();

    nl = ';';
    pfmt(f, "%t", t);
    nl = svnl;
    v = f->strp;
    f->strp = nil;
    closeio(f);
    return v;
}
@



<<function Xfn>>=
void
Xfn(void)
{
    var *v;
    word *a;
    int end;

    end = runq->code[runq->pc].i;
    globlist();
    for(a = runq->argv->words;a;a = a->next){
        v = gvlook(a->word);
        if(v->fn)
            codefree(v->fn);
        v->fn = codecopy(runq->code);
        v->pc = runq->pc+2;
        v->fnchanged = true;
    }
    runq->pc = end;
    poplist();
}
@

<<function Xdelfn>>=
void
Xdelfn(void)
{
    var *v;
    word *a;
    for(a = runq->argv->words;a;a = a->next){
        v = gvlook(a->word);
        if(v->fn)
            codefree(v->fn);
        v->fn = 0;
        v->fnchanged = 1;
    }
    poplist();
}
@


% uses


<<[[Xsimple()]] other locals>>=
var *v;
@

<<[[Xsimple()]] if argv0 is a function>>=
v = gvlook(a->word);
if(v->fn)
    execfunc(v);
@

<<function execfunc>>=
void
execfunc(var *func)
{
    word *starval;

    popword();
    starval = runq->argv->words;
    runq->argv->words = nil;
    poplist();
    start(func->fn, func->pc, runq->local);
    runq->local = newvar(strdup("*"), runq->local);
    runq->local->val = starval;
    runq->local->changed = true;
}
@

\section{Variables}

\subsection{Variable definitions}

<<[[outcode()]] cases>>=
case '=':
    tt = t;
    for(;t && t->type=='='; t = c2);
    if(t){					/* var=value cmd */
        for(t = tt;t->type=='=';t = c2){
            emitf(Xmark);
            outcode(c1, eflag);
            emitf(Xmark);
            outcode(c0, eflag);
            emitf(Xlocal);		/* push var for cmd */
        }
        outcode(t, eflag);		/* gen. code for cmd */
        for(t = tt; t->type == '='; t = c2)
            emitf(Xunlocal);	/* pop var */
    }
    else{					/* var=value */
        for(t = tt;t;t = c2){
            emitf(Xmark);
            outcode(c1, eflag);
            emitf(Xmark);
            outcode(c0, eflag);
            emitf(Xassign);	/* set var permanently */
        }
    }
    t = tt;	/* so tests below will work */
    break;
@

<<function Xassign>>=
void
Xassign(void)
{
    var *v;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    deglob(runq->argv->words->word);
    v = vlook(runq->argv->words->word);
    poplist();
    globlist();
    freewords(v->val);
    v->val = runq->argv->words;
    v->changed = true;
    runq->argv->words = 0;
    poplist();
}
@



<<function Xlocal>>=
void
Xlocal(void)
{
    if(count(runq->argv->words)!=1){
        Xerror1("variable name must be singleton\n");
        return;
    }
    deglob(runq->argv->words->word);
    runq->local = newvar(strdup(runq->argv->words->word), runq->local);
    poplist();
    globlist();
    runq->local->val = runq->argv->words;
    runq->local->changed = true;
    runq->argv->words = 0;
    poplist();
}
@

<<function Xunlocal>>=
void
Xunlocal(void)
{
    var *v = runq->local, *hid;
    if(v==0)
        panic("Xunlocal: no locals!", 0);
    runq->local = v->next;
    hid = vlook(v->name);
    hid->changed = true;
    efree(v->name);
    freewords(v->val);
    efree((char *)v);
}
@


\subsection{Variable uses}

<<[[outcode()]] cases>>=
case '$': //$
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xdol);
    break;
@

<<function Xdol>>=
void
Xdol(void)
{
    word *a, *star;
    char *s, *t;
    int n;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);
    n = 0;
    for(t = s;'0'<=*t && *t<='9';t++) n = n*10+*t-'0';
    a = runq->argv->next->words;
    if(n==0 || *t)
        a = copywords(vlook(s)->val, a);
    else{
        star = vlook("*")->val;
        if(star && 1<=n && n<=count(star)){
            while(--n) star = star->next;
            a = newword(star->word, a);
        }
    }
    poplist();
    runq->argv->words = a;
}
@




<<[[outcode()]] cases>>=
case COUNT:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xcount);
    break;
@


<<function Xcount>>=
void
Xcount(void)
{
    word *a;
    char *s, *t;
    int n;
    char num[12];
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);
    n = 0;
    for(t = s;'0'<=*t && *t<='9';t++) n = n*10+*t-'0';
    if(n==0 || *t){
        a = vlook(s)->val;
        inttoascii(num, count(a));
    }
    else{
        a = vlook("*")->val;
        inttoascii(num, a && 1<=n && n<=count(a)?1:0);
    }
    poplist();
    pushword(num);
}
@



<<[[outcode()]] cases>>=
case SUB:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xsub);
    break;
@


<<function Xsub>>=
void
Xsub(void)
{
    word *a, *v;
    char *s;
    if(count(runq->argv->next->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->next->words->word;
    deglob(s);
    a = runq->argv->next->next->words;
    v = vlook(s)->val;
    a = subwords(v, count(v), runq->argv->words, a);
    poplist();
    poplist();
    runq->argv->words = a;
}
@

<<function subwords>>=
word*
subwords(word *val, int len, word *sub, word *a)
{
    int n, m;
    char *s;
    if(!sub)
        return a;
    a = subwords(val, len, sub->next, a);
    s = sub->word;
    deglob(s);
    m = 0;
    n = 0;
    while('0'<=*s && *s<='9')
        n = n*10+ *s++ -'0';
    if(*s == '-'){
        if(*++s == 0)
            m = len - n;
        else{
            while('0'<=*s && *s<='9')
                m = m*10+ *s++ -'0';
            m -= n;
        }
    }
    if(n<1 || n>len || m<0)
        return a;
    if(n+m>len)
        m = len-n;
    while(--n > 0)
        val = val->next;
    return copynwords(val, a, m+1);
}
@



<<[[outcode()]] cases>>=
case '^':
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xconc);
    break;
@

<<function Xconc>>=
void
Xconc(void)
{
    word *lp = runq->argv->words;
    word *rp = runq->argv->next->words;
    word *vp = runq->argv->next->next->words;
    int lc = count(lp), rc = count(rp);
    if(lc!=0 || rc!=0){
        if(lc==0 || rc==0){
            Xerror1("null list in concatenation");
            return;
        }
        if(lc!=1 && rc!=1 && lc!=rc){
            Xerror1("mismatched list lengths in concatenation");
            return;
        }
        vp = conclist(lp, rp, vp);
    }
    poplist();
    poplist();
    runq->argv->words = vp;
}
@

<<function conclist>>=
word*
conclist(word *lp, word *rp, word *tail)
{
    char *buf;
    word *v;
    if(lp->next || rp->next)
        tail = conclist(lp->next==0? lp: lp->next,
            rp->next==0? rp: rp->next, tail);
    buf = emalloc(strlen(lp->word)+strlen((char *)rp->word)+1);
    strcpy(buf, lp->word);
    strcat(buf, rp->word);
    v = newword(buf, tail);
    efree(buf);
    return v;
}
@



\chapter{Builtins}

\section{Overview}

% called from Xsimple when first word is actually recognized as a builtin

<<struct builtin>>=
struct Builtin {
    char *name;
    void (*fnc)(void);
};
@

% plan9.c
% rename Builtin -> builtins
<<global Builtin>>=
builtin Builtin[] = {
    "cd",		execcd,
    "exit",		execexit,
    ".",		execdot,
    "eval",		execeval,

    "whatis",		execwhatis,

    "exec",		execexec,	/* but with popword first */
    "rfork",		execnewpgrp,
    "wait",		execwait,

    "shift",		execshift,
    "finit",		execfinit,
    "flag",		execflag,
    0
};
@

<<[[Xsimple()]] other locals>>=
struct Builtin *bp;
@

% 2 ways to call, either directly 'xxx' or via 'builtin xxx'
% (not sure why need the first form)
<<[[Xsimple()]] if argv0 is a builtin>>=
if(strcmp(a->word, "builtin")==0){
    if(count(a)==1){
        pfmt(err, "builtin: empty argument list\n");
        setstatus("empty arg list");
        poplist();
        return;
    }
    a = a->next;
    popword();
}
for(bp = Builtin;bp->name;bp++)
    if(strcmp(a->word, bp->name)==0){
        (*bp->fnc)();
        return;
    }
@


\section{[[$ cd]]}
%$

<<function execcd>>=
void
execcd(void)
{
    word *a = runq->argv->words;
    word *cdpath;
    char *dir;

    setstatus("can't cd");
    cdpath = vlook("cdpath")->val;

    switch(count(a)){
    case 1:
        a = vlook("home")->val;
        if(count(a)>=1){
            if(dochdir(a->word)>=0)
                setstatus("");
            else
                pfmt(err, "Can't cd %s: %r\n", a->word);
        }
        else
            pfmt(err, "Can't cd -- $home empty\n"); //$
        break;
    case 2:
        if(a->next->word[0]=='/' || cdpath==nil)
            cdpath = &nullpath;
        for(; cdpath; cdpath = cdpath->next){
            if(cdpath->word[0] != '\0')
                dir = appfile(cdpath->word, a->next->word);
            else
                dir = strdup(a->next->word);

            if(dochdir(dir) >= 0){
                if(cdpath->word[0] != '\0' &&
                    strcmp(cdpath->word, ".") != 0)
                    pfmt(err, "%s\n", dir);
                free(dir);
                setstatus("");
                break;
            }
            free(dir);
        }
        if(cdpath==nil)
            pfmt(err, "Can't cd %s: %r\n", a->next->word);
        break;
    default:
        pfmt(err, "Usage: cd [directory]\n");
        break;
    }
    poplist();
}
@
%$

<<function appfile>>=
static char *
appfile(char *dir, char *comp)
{
    int dirlen, complen;
    char *s, *p;

    dirlen = strlen(dir);
    complen = strlen(comp);
    s = emalloc(dirlen + 1 + complen + 1);
    memmove(s, dir, dirlen);
    p = s + dirlen;
    *p++ = '/';
    memmove(p, comp, complen);
    p[complen] = '\0';
    return s;
}
@


% /dev/wdir?

<<function dochdir>>=
errorneg1
dochdir(char *word)
{
    /* report to /dev/wdir if it exists and we're interactive */
    static int wdirfd = -2;

    // the actual syscall
    if(chdir(word)<0) 
        return ERROR_NEG1;

    if(flag['i']!=nil){
        if(wdirfd==-2)	/* try only once */
            wdirfd = open("/dev/wdir", OWRITE|OCEXEC);
        if(wdirfd>=0) {
            //fcntl(wdirfd, F_SETFD, FD_CLOEXEC);
            write(wdirfd, word, strlen(word));
        }
    }
    return OK_1;
}
@

\section{[[$ exit]]}
%$

<<function execexit>>=
void
execexit(void)
{
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: exit [status]\nExiting anyway\n");
        // FALLTHROUGH
    case 2:
        setstatus(runq->argv->words->next->word);
        // FALLTHROUGH
    case 1:	
        Xexit();
    }
}
@

\section{[[$ .]]}
%$ 

<<global dotcmds>>=
union Code dotcmds[14];
@

<<global ndot>>=
/*
 * How many dot commands have we executed?
 * Used to ensure that -v flag doesn't print rcmain.
 */
int ndot;
@



<<function execdot>>=
void
execdot(void)
{
    bool iflag = false;
    int fd;
    list *av;
    thread *p = runq;
    char *zero, *file;
    word *path;
    static bool first = true;

    if(first){
        dotcmds[0].i = 1;
        dotcmds[1].f = Xmark;
        dotcmds[2].f = Xword;
        dotcmds[3].s="0";
        dotcmds[4].f = Xlocal;
        dotcmds[5].f = Xmark;
        dotcmds[6].f = Xword;
        dotcmds[7].s="*";
        dotcmds[8].f = Xlocal;
        dotcmds[9].f = Xrdcmds;
        dotcmds[10].f = Xunlocal;
        dotcmds[11].f = Xunlocal;
        dotcmds[12].f = Xreturn;
        first = false;
    }
    else
        eflagok = true;

    popword();
    if(p->argv->words && strcmp(p->argv->words->word, "-i")==0){
        iflag = true;
        popword();
    }
    /* get input file */
    if(p->argv->words==nil){
        Xerror1("Usage: . [-i] file [arg ...]");
        return;
    }
    zero = strdup(p->argv->words->word);
    popword();
    fd = -1;
    for(path = searchpath(zero); path; path = path->next){
        if(path->word[0] != '\0')
            file = appfile(path->word, zero);
        else
            file = strdup(zero);

        fd = open(file, 0);
        free(file);
        if(fd >= 0)
            break;
        if(strcmp(file, "/dev/stdin")==0){	/* for sun & ucb */
            fd = Dup1(0);
            if(fd>=0)
                break;
        }
    }
    if(fd<0){
        pfmt(err, "%s: ", zero);
        setstatus("can't open");
        Xerror(".: can't open");
        return;
    }

    /* set up for a new command loop */
    start(dotcmds, 1, (struct Var *)nil);

    pushredir(RCLOSE, fd, 0);
    runq->cmdfile = zero;
    runq->cmdfd = openfd(fd);
    runq->iflag = iflag;
    runq->iflast = false;
    /* push $* value */
    pushlist();
    runq->argv->words = p->argv->words;
    /* free caller's copy of $* */
    av = p->argv;
    p->argv = av->next;
    efree((char *)av);
    /* push $0 value */
    pushlist();
    pushword(zero);
    ndot++;
}
@
%$

<<function Dup1>>=
int
Dup1(int)
{
    return -1;
}
@

\section{[[$ eval]]}
%$

% TODO What is the point of eval? the interpreter loop is already an
% eval that does call Xrdcmds ...

<<function execeval>>=
void
execeval(void)
{
    char *cmdline, *s, *t;
    int len = 0;
    word *ap;

    if(count(runq->argv->words)<=1){
        Xerror1("Usage: eval cmd ...");
        return;
    }
    eflagok = true;
    for(ap = runq->argv->words->next;ap;ap = ap->next)
        len+=1+strlen(ap->word);
    cmdline = emalloc(len);
    s = cmdline;
    for(ap = runq->argv->words->next;ap;ap = ap->next){
        for(t = ap->word;*t;) *s++=*t++;
        *s++=' ';
    }
    s[-1]='\n';
    poplist();
    execcmds(opencore(cmdline, len));
    efree(cmdline);
}
@

<<global rdcmds>>=
union Code rdcmds[4];
@

<<function execcmds>>=
void
execcmds(io *f)
{
    static bool first = true;
    if(first){
        rdcmds[0].i = 1;
        rdcmds[1].f = Xrdcmds;
        rdcmds[2].f = Xreturn;
        first = false;
    }
    start(rdcmds, 1, runq->local);
    runq->cmdfd = f;
    runq->iflast = false;
}
@



\chapter{Variables}
% and function definition?

% diff with bash here, see rc design document

%$#x

\section{Environment}


% called from Xsimple() and Execute()
% why double? anyway with 'changed' field it should be ok
<<function Updenv>>=
void
Updenv(void)
{
    var *v, **h;

    for(h = gvar;h!=&gvar[NVAR];h++)
        for(v=*h;v;v = v->next)
            addenv(v);
    if(runq)
        updenvlocal(runq->local);
}
@

<<function updenvlocal>>=
void
updenvlocal(var *v)
{
    if(v){
        updenvlocal(v->next);
        addenv(v);
    }
}
@


<<enum _anon_ (rc/plan9.c)>>=
enum {
    Maxenvname = 256,	/* undocumented limit */
};
@

<<[[Var]] other fields>>=
bool	changed;
@

<<function addenv>>=
void
addenv(var *v)
{
    char envname[Maxenvname];
    word *w;
    int f;
    io *fd;

    if(v->changed){
        v->changed = false;
        snprint(envname, sizeof envname, "/env/%s", v->name);
        if((f = Creat(envname))<0)
            pfmt(err, "rc: can't open %s: %r\n", envname);
        else{
            for(w = v->val;w;w = w->next)
                write(f, w->word, strlen(w->word)+1L);
            close(f);
        }
    }
    if(v->fnchanged){
        v->fnchanged = false;
        snprint(envname, sizeof envname, "/env/fn#%s", v->name);
        if((f = Creat(envname))<0)
            pfmt(err, "rc: can't open %s: %r\n", envname);
        else{
            if(v->fn){
                fd = openfd(f);
                pfmt(fd, "fn %q %s\n", v->name, v->fn[v->pc-1].s);
                closeio(fd);
            }
            close(f);
        }
    }
}
@







<<global Fdprefix>>=
char *Fdprefix = "/fd/";
@


<<function Vinit>>=
void
Vinit(void)
{
    int dir, f, len, i, n, nent;
    char *buf, *s;
    char envname[Maxenvname];
    word *val;
    Dir *ent;

    dir = open("/env", OREAD);
    if(dir<0){
        pfmt(err, "rc: can't open /env: %r\n");
        return;
    }
    ent = nil;
    for(;;){
        nent = dirread(dir, &ent);
        if(nent <= 0)
            break;
        for(i = 0; i<nent; i++){
            len = ent[i].length;
            if(len && strncmp(ent[i].name, "fn#", 3)!=0){
                snprint(envname, sizeof envname, "/env/%s", ent[i].name);
                if((f = open(envname, 0))>=0){
                    buf = emalloc(len+1);
                    n = readn(f, buf, len);
                    if (n <= 0)
                        buf[0] = '\0';
                    else
                        buf[n] = '\0';
                    val = 0;
                    /* Charitably add a 0 at the end if need be */
                    if(buf[len-1])
                        buf[len++]='\0';
                    s = buf+len-1;
                    for(;;){
                        while(s!=buf && s[-1]!='\0') --s;
                        val = newword(s, val);
                        if(s==buf)
                            break;
                        --s;
                    }
                    setvar(ent[i].name, val);
                    vlook(ent[i].name)->changed = false;
                    close(f);
                    efree(buf);
                }
            }
        }
        free(ent);
    }
    close(dir);
}
@

<<global envdir>>=
int envdir;
@




<<function Xrdfn>>=
void
Xrdfn(void)
{
    int f, len;
    Dir *e;
    char envname[Maxenvname];
    static Dir *ent, *allocent;
    static int nent;

    for(;;){
        if(nent == 0){
            free(allocent);
            nent = dirread(envdir, &allocent);
            ent = allocent;
        }
        if(nent <= 0)
            break;
        while(nent){
            e = ent++;
            nent--;
            len = e->length;
            if(len && strncmp(e->name, "fn#", 3)==0){
                snprint(envname, sizeof envname, "/env/%s", e->name);
                if((f = open(envname, 0))>=0){
                    execcmds(openfd(f));
                    return;
                }
            }
        }
    }
    close(envdir);
    Xreturn();
}
@

<<global rdfns>>=
union Code rdfns[4];
@

<<function execfinit>>=
void
execfinit(void)
{
    static int first = 1;
    if(first){
        rdfns[0].i = 1;
        rdfns[1].f = Xrdfn;
        rdfns[2].f = Xjump;
        rdfns[3].i = 1;
        first = 0;
    }
    Xpopm();
    envdir = open("/env", 0);
    if(envdir<0){
        pfmt(err, "rc: can't open /env: %r\n");
        return;
    }
    start(rdfns, 1, runq->local);
}
@


\section{Interpolation}

% looks like "" actually distribute to the element in a list

\section{Special variables}

%vlook("xxx"):
% home, cdpath, path
% prompt, 
% *, 
% status, sigexit
% ifs?

\chapter{Globbing}
% could be in advanced topics, but important feature in a shell


\section{Lexing globbing characters}

<<constant GLOB>>=
/*
 * Glob character escape in strings:
 *	In a string, GLOB must be followed by *?[ or GLOB.
 *	GLOB* matches any string
 *	GLOB? matches any single character
 *	GLOB[...] matches anything in the brackets
 *	GLOBGLOB matches GLOB
 */
#define	GLOB	'\001'
@


<<[[yylex()]] when c is a word character, if glob character>>=
if(c=='*' || c=='[' || c=='?' || c==GLOB)
    w = addtok(w, GLOB);
@

<<function addtok>>=
char*
addtok(char *p, int val)
{
    if(p==nil)
        return nil;
    if(p >= &tok[NTOK]){
        *p = '\0';
        yyerror("token buffer too short");
        return nil;
    }
    *p++=val;
    return p;
}
@
% diff with addutf()?

\section{Expanding globbing characters}

<<global globv>>=
struct Word *globv;
@


% Xsimple | ... -> <>
<<function globlist>>=
void
globlist(void)
{
    word *a;
    globv = nil;

    globlist1(runq->argv->words);
    poplist();
    pushlist();

    if(globv){
        for(a = globv;a->next;a = a->next)
            ;
        a->next = runq->argv->words;
        runq->argv->words = globv;
    }
}
@

<<function globlist1>>=
void
globlist1(word *gl)
{
    if(gl){
        globlist1(gl->next);
        glob(gl->word);
    }
}
@


% Why not add Xglob for SIMPLE cases too? generate a Xglob instead
%  of calling yourself globlist() in Xsimple ?

% outcode (REDIR and FOR cases) -> <>
<<function Xglob>>=
void
Xglob(void)
{
    globlist();
}
@

\section{[[glob()]]}

<<global globname>>=
char *globname;
@

<<function glob>>=
/*
 * Push all file names matched by p on the current thread's stack.
 * If there are no matches, the list consists of p.
 */
void
glob(void *ap)
{
    uchar *p = ap;
    word *svglobv = globv;
    int globlen = Globsize(ap);

    if(!globlen){
        deglob(p);
        globv = newword((char *)p, globv);
        return;
    }
    globname = emalloc(globlen);
    globname[0]='\0';
    globdir(p, (uchar *)globname);
    efree(globname);
    if(svglobv==globv){
        deglob(p);
        globv = newword((char *)p, globv);
    }
    else
        globsort(globv, svglobv);
}
@













<<function deglob>>=
/*
 * delete all the GLOB marks from s, in place
 */
void
deglob(void *as)
{
    char *s = as;
    char *t = s;
    do{
        if(*t==GLOB)
            t++;
        *s++=*t;
    }while(*t++);
}
@

<<function globcmp>>=
int
globcmp(const void *s, const void *t)
{
    return strcmp(*(char**)s, *(char**)t);
}
@

<<function globsort>>=
void
globsort(word *left, word *right)
{
    char **list;
    word *a;
    int n = 0;
    for(a = left;a!=right;a = a->next) n++;
    list = (char **)emalloc(n*sizeof(char *));
    for(a = left,n = 0;a!=right;a = a->next,n++) list[n] = a->word;
    qsort((void *)list, n, sizeof(void *), globcmp);
    for(a = left,n = 0;a!=right;a = a->next,n++) a->word = list[n];
    efree((char *)list);
}
@

<<function globdir>>=
/*
 * Push names prefixed by globname and suffixed by a match of p onto the astack.
 * namep points to the end of the prefix in globname.
 */
void
globdir(uchar *p, uchar *namep)
{
    uchar *t, *newp;
    int f;
    /* scan the pattern looking for a component with a metacharacter in it */
    if(*p=='\0'){
        globv = newword(globname, globv);
        return;
    }
    t = namep;
    newp = p;
    while(*newp){
        if(*newp==GLOB)
            break;
        *t=*newp++;
        if(*t++=='/'){
            namep = t;
            p = newp;
        }
    }
    /* If we ran out of pattern, append the name if accessible */
    if(*newp=='\0'){
        *t='\0';
        if(access(globname, 0)==0)
            globv = newword(globname, globv);
        return;
    }
    /* read the directory and recur for any entry that matches */
    *namep='\0';
    if((f = Opendir(globname[0]?globname:"."))<0) return;
    while(*newp!='/' && *newp!='\0') newp++;
    while(Readdir(f, namep, *newp=='/')){
        if(matchfn(namep, p)){
            for(t = namep;*t;t++);
            globdir(newp, t);
        }
    }
    Closedir(f);
}
@


<<function equtf>>=
/*
 * Do p and q point at equal utf codes
 */
bool
equtf(uchar *p, uchar *q)
{
    Rune pr, qr;
    if(*p!=*q)
        return false;
    
    chartorune(&pr, (char*)p);
    chartorune(&qr, (char*)q);
    return pr == qr;
}
@

<<function nextutf>>=
/*
 * Return a pointer to the next utf code in the string,
 * not jumping past nuls in broken utf codes!
 */
uchar*
nextutf(uchar *p)
{
    Rune dummy;
    return p + chartorune(&dummy, (char*)p);
}
@

<<function unicode>>=
/*
 * Convert the utf code at *p to a unicode value
 */
int
unicode(uchar *p)
{
    Rune r;

    chartorune(&r, (char*)p);
    return r;
}
@

<<function matchfn>>=
/*
 * Does the string s match the pattern p
 * . and .. are only matched by patterns starting with .
 * * matches any sequence of characters
 * ? matches any single character
 * [...] matches the enclosed list of characters
 */
bool
matchfn(void *as, void *ap)
{
    uchar *s = as, *p = ap;

    if(s[0]=='.' && (s[1]=='\0' || s[1]=='.' && s[2]=='\0') && p[0]!='.')
        return false;
    return match(s, p, '/');
}
@

<<function match>>=
bool
match(void *as, void *ap, int stop)
{
    int compl, hit, lo, hi, t, c;
    uchar *s = as, *p = ap;

    for(; *p!=stop && *p!='\0'; s = nextutf(s), p = nextutf(p)){
        if(*p!=GLOB){
            if(!equtf(p, s)) return false;
        }
        else switch(*++p){
        case GLOB:
            if(*s!=GLOB)
                return false;
            break;
        case '*':
            for(;;){
                if(match(s, nextutf(p), stop)) return 1;
                if(!*s)
                    break;
                s = nextutf(s);
            }
            return false;
        case '?':
            if(*s=='\0')
                return false;
            break;
        case '[':
            if(*s=='\0')
                return false;
            c = unicode(s);
            p++;
            compl=*p=='~';
            if(compl)
                p++;
            hit = 0;
            while(*p!=']'){
                if(*p=='\0')
                    return false;		/* syntax error */
                lo = unicode(p);
                p = nextutf(p);
                if(*p!='-')
                    hi = lo;
                else{
                    p++;
                    if(*p=='\0')
                        return false;	/* syntax error */
                    hi = unicode(p);
                    p = nextutf(p);
                    if(hi<lo){ t = lo; lo = hi; hi = t; }
                }
                if(lo<=c && c<=hi)
                    hit = 1;
            }
            if(compl)
                hit=!hit;
            if(!hit)
                return false;
            break;
        }
    }
    return *s=='\0';
}
@





<<constant NDIR>>=
#define	NDIR	256		/* shoud be a better way */
@

<<function Globsize>>=
int
Globsize(char *p)
{
    int isglob = 0, globlen = NDIR+1;
    for(;*p;p++){
        if(*p==GLOB){
            p++;
            if(*p!=GLOB)
                isglob++;
            globlen+=*p=='*'?NDIR:1;
        }
        else
            globlen++;
    }
    return isglob?globlen:0;
}
@


<<constant NFD>>=
#define	NFD	50
@

<<global dir>>=
struct{
    Dir	*dbuf;
    int	i;
    int	n;
}dir[NFD];
@

<<function Opendir>>=
int
Opendir(char *name)
{
    Dir *db;
    int f;
    f = open(name, 0);
    if(f==-1)
        return f;
    db = dirfstat(f);
    if(db!=nil && (db->mode&DMDIR)){
        if(f<NFD){
            dir[f].i = 0;
            dir[f].n = 0;
        }
        free(db);
        return f;
    }
    free(db);
    close(f);
    return -1;
}
@


<<function trimdirs>>=
static int
trimdirs(Dir *d, int nd)
{
    int r, w;

    for(r=w=0; r<nd; r++)
        if(d[r].mode&DMDIR)
            d[w++] = d[r];
    return w;
}
@

<<function Readdir>>=
/*
 * onlydirs is advisory -- it means you only
 * need to return the directories.  it's okay to
 * return files too (e.g., on unix where you can't
 * tell during the readdir), but that just makes 
 * the globber work harder.
 */
int
Readdir(int f, void *p, int onlydirs)
{
    int n;

    if(f<0 || f>=NFD)
        return 0;
Again:
    if(dir[f].i==dir[f].n){	/* read */
        free(dir[f].dbuf);
        dir[f].dbuf = 0;
        n = dirread(f, &dir[f].dbuf);
        if(n>0){
            if(onlydirs){
                n = trimdirs(dir[f].dbuf, n);
                if(n == 0)
                    goto Again;
            }	
            dir[f].n = n;
        }else
            dir[f].n = 0;
        dir[f].i = 0;
    }
    if(dir[f].i == dir[f].n)
        return 0;
    strcpy(p, dir[f].dbuf[dir[f].i].name);
    dir[f].i++;
    return 1;
}
@

<<function Closedir>>=
void
Closedir(int f)
{
    if(f>=0 && f<NFD){
        free(dir[f].dbuf);
        dir[f].i = 0;
        dir[f].n = 0;
        dir[f].dbuf = 0;
    }
    close(f);
}
@


\chapter{Signals}


% C-d generate an Xsimple (exit 1) ?

<<constant NSIG>>=
#define	NSIG	32
@

<<constant SIGINT>>=
#define	SIGINT	2
@

<<constant SIGQUIT>>=
#define	SIGQUIT	3
@


% plan9.c
<<global syssigname>>=
char *syssigname[] = {
    "exit",		/* can't happen */
    "hangup",
    "interrupt",
    "quit",		/* can't happen */
    "alarm",
    "kill",
    "sys: fp: ",
    "term",
    0
};
@

% plan9.c
<<global Signame>>=
char *Signame[] = {
    "sigexit",	
    "sighup",	
    "sigint",	
    "sigquit",
    "sigalrm",	
    "sigkill",	
    "sigfpe",	
    "sigterm",
    0
};
@


<<global ntrap>>=
int ntrap;				/* number of outstanding traps */
@

<<global trap>>=
int trap[NSIG];				/* number of outstanding traps per type */
@



% main() -> Trapinit()
<<function Trapinit>>=
void
Trapinit(void)
{
    notify(notifyf);
}
@

<<function notifyf>>=
void
notifyf(void*, char *s)
{
    int i;
    for(i = 0;syssigname[i];i++) 
     if(strncmp(s, syssigname[i], strlen(syssigname[i]))==0){
        if(strncmp(s, "sys: ", 5)!=0) 
            interrupted = true;
        goto Out;
    }
    pfmt(err, "rc: note: %s\n", s);
    noted(NDFLT);
    return;
Out:
    if(strcmp(s, "interrupt")!=0 || trap[i]==0){
        trap[i]++;
        ntrap++;
    }
    if(ntrap>=32){	/* rc is probably in a trap loop */
        pfmt(err, "rc: Too many traps (trap %s), aborting\n", s);
        abort();
    }
    noted(NCONT);
}
@


<<[[main()]] handing trap if necessary in interpreter loop>>=
if(ntrap)
    dotrap();
@




% trap.c
% main() -> dotrap() after having interpreter one bytecode
<<function dotrap>>=
void
dotrap(void)
{
    int i;
    struct Var *trapreq;
    struct Word *starval;

    starval = vlook("*")->val;
    while(ntrap) 
     for(i = 0;i!=NSIG;i++) 
      while(trap[i]){
        --trap[i];
        --ntrap;
        if(getpid()!=mypid) 
            Exit(getstatus());
        trapreq = vlook(Signame[i]);
        if(trapreq->fn){
            start(trapreq->fn, trapreq->pc, (struct Var *)nil);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)nil);
            runq->local->changed = true;
            runq->redir = runq->startredir = 0;
        }
        else if(i==SIGINT || i==SIGQUIT){
            /*
             * run the stack down until we uncover the
             * command reading loop.  Xreturn will exit
             * if there is none (i.e. if this is not
             * an interactive rc.)
             */
            while(!runq->iflag) 
                Xreturn();
        }
        else 
            Exit(getstatus());
    }
}
@




<<global interrupted>>=
bool interrupted = false;
@

<<function Eintr>>=
bool
Eintr(void)
{
    return interrupted;
}
@


<<[[Xrdcmds()]] calls Noerror() before yyparse()>>=
Noerror();
@

<<function Noerror>>=
void
Noerror(void)
{
    interrupted = false;
}
@

<<[[Xrdcmds()]] reset ntrap>>=
ntrap = 0;	/* avoid double-interrupts during blocked writes */
@


\chapter{Initialisation}

\section{Actual bootstrapping}

% see main() comment:
% * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)

%main() -> bootstrap -> execdot -> Xreadcmds() -> yyparse() -> compile() -> outcode() -> back to interpreter loop with new codebuf (chained to bootstrap)

%plan9.c
<<global Rcmain>>=
char *Rcmain = "/rc/lib/rcmain";
@

<<[[main()]] locals>>=
char *rcmain;
@

<<[[main()]] initialisation>>=
rcmain = flag['m'] ? flag['m'][0] : Rcmain; 
@

%OPTIONAL
<<[[main()]] initialize [[boostrap]]>>=
memset(bootstrap, 0, sizeof bootstrap);

i = 0;
bootstrap[i++].i=1;
bootstrap[i++].f = Xmark;
bootstrap[i++].f = Xword;
bootstrap[i++].s="*";

bootstrap[i++].f = Xassign;
bootstrap[i++].f = Xmark;
bootstrap[i++].f = Xmark;

bootstrap[i++].f = Xword;
bootstrap[i++].s="*";
bootstrap[i++].f = Xdol;

bootstrap[i++].f = Xword;
bootstrap[i++].s = rcmain;

bootstrap[i++].f = Xword;
bootstrap[i++].s=".";

bootstrap[i++].f = Xsimple;

bootstrap[i++].f = Xexit;

bootstrap[i].i = 0;
@


\section{Actual environment}

<<global mypid>>=
int mypid;
@

<<[[main()]] locals>>=
char num[12];
@
%ocaml: no need for declaration, just do  'let num = int_to_string(mypid)'

<<[[main()]] initialisation>>=
mypid = getpid();
inttoascii(num, mypid);
setvar("pid", newword(num, (word *)nil));

setvar("cflag", flag['c']? newword(flag['c'][0], (word *)nil) : (word *)nil);

setvar("rcname", newword(argv[0], (word *)nil));
@







\chapter{Advanced Topics}

\section{[[rc -e]]}


<<[[outcode()]] emit Xeflag after Xsimple>>=
if(eflag)
    emitf(Xeflag);
@

% super important actually, remember in recursive make 
% where a failure in a subsubdir should stop the entire thing. 
% Fortunately mk calls rc with -e so any error in a loop for 
% instance stop the whole thing
% (but not error  in   X || Y, nor error in if (X), etc, so
% need do eflag check only a certain places)

<<global eflagok>>=
bool eflagok;	/* kludge flag so that -e doesn't exit in startup */
@
% who sets that? execdot, execval

<<function Xeflag>>=
void
Xeflag(void)
{
    if(eflagok && !truestatus()) 
        Xexit();
}
@

% exit at first error!
% kind of a 'use strict;' :)

% very useful

\section{Unicode}

<<function addutf>>=
char*
addutf(char *p, int c)
{
    uchar b, m;
    int i;

    p = addtok(p, c);	/* 1-byte UTF runes are special */
    if(c < Runeself)
        return p;

    m = 0xc0;
    b = 0x80;
    for(i=1; i < UTFmax; i++){
        if((c&m) == b)
            break;
        p = addtok(p, advance());
        b = m;
        m = (m >> 1)|0x80;
    }
    return p;
}
@

\section{Advanced constructs}


<<token declarations>>=
%token PIPEFD 
@

\subsection{Subshell, [[@ command]]}

<<token declarations>>=
%token SUBSHELL /** @ */
@

% @ xxx
<<cmd rule other cases>>=
|   SUBSHELL cmd        {$$=mung1($1, $2);}
@


<<[[outcode()]] cases>>=
case SUBSHELL:
    emitf(Xsubshell);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    if(eflag)
        emitf(Xeflag);
    break;
@

% * Xsubshell{... Xexit}		execute {} in a subshell and wai


<<function Xsubshell>>=
void
Xsubshell(void)
{
    int pid;
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0:
        clearwaitpids();
        start(runq->code, runq->pc+1, runq->local);
        runq->ret = 0;
        break;
    default:
        addwaitpid(pid);
        Waitfor(pid, 1);
        runq->pc = runq->code[runq->pc].i;
        break;
    }
}
@



\subsection{Here documents, [[<< HERE]]}
% >>

<<constant HERE>>=
#define	HERE	4
@

<<[[yylex()]] in switch when redirection character, if here document>>=
if(nextis(c)){
    t->rtype = HERE;
    *w++=c;
}
@


<<struct here>>=
struct Here {
    tree	*tag;
    char	*name;
    struct Here *next;
};
@

<<global here>>=
struct Here *here;
@


<<global ehere>>=
struct Here **ehere;
@


<<constant NLINE>>=
/*
 * bug: lines longer than NLINE get split -- this can cause spurious
 * missubstitution, or a misrecognized EOF marker.
 */
#define	NLINE	4096
@

<<function readhere>>=
void
readhere(void)
{
    int c, subst;
    char *s, *tag;
    char line[NLINE+1];
    io *f;
    struct Here *h, *nexth;

    for(h = here; h; h = nexth){
        subst = !h->tag->quoted;
        tag = h->tag->str;
        c = Creat(h->name);
        if(c < 0)
            yyerror("can't create here document");
        f = openfd(c);
        s = line;
        pprompt();
        while((c = rchr(runq->cmdfd)) != EOF){
            if(c == '\n' || s == &line[NLINE]){
                *s = '\0';
                if(tag && strcmp(line, tag) == 0)
                    break;
                if(subst)
                    psubst(f, (uchar *)line);
                else
                    pstr(f, line);
                s = line;
                if(c == '\n'){
                    pprompt();
                    pchr(f, c);
                }else
                    *s++ = c;
            }else
                *s++ = c;
        }
        flush(f);
        closeio(f);
        cleanhere(h->name);
        nexth = h->next;
        efree((char *)h);
    }
    here = nil;
    doprompt = true;
}
@


<<function cleanhere>>=
void
cleanhere(char *f)
{
    emitf(Xdelhere);
    emits(strdup(f));
}
@

<<function Xdelhere>>=
void
Xdelhere(void)
{
    Unlink(runq->code[runq->pc++].s);
}
@

<<function Unlink>>=
void
Unlink(char *name)
{
    remove(name);
}
@




<<global ser>>=
int ser = 0;
@

<<global tmp (rc/here.c)>>=
char tmp[] = "/tmp/here0000.0000";
@

<<global hex>>=
char hex[] = "0123456789abcdef";
@

<<function hexnum>>=
void
hexnum(char *p, int n)
{
    *p++ = hex[(n>>12)&0xF];
    *p++ = hex[(n>>8)&0xF];
    *p++ = hex[(n>>4)&0xF];
    *p = hex[n&0xF];
}
@

<<function heredoc>>=
//@Scheck: used by syn.y
tree* heredoc(tree *tag)
{
    struct Here *h = new(struct Here);

    if(tag->type != WORD)
        yyerror("Bad here tag");
    h->next = 0;
    if(here)
        *ehere = h;
    else
        here = h;
    ehere = &h->next;
    h->tag = tag;
    hexnum(&tmp[9], getpid());
    hexnum(&tmp[14], ser++);
    h->name = strdup(tmp);
    return token(tmp, WORD);
}
@


<<function psubst>>=
void
psubst(io *f, uchar *s)
{
    int savec, n;
    uchar *t, *u;
    Rune r;
    word *star;

    while(*s){
        if(*s != '$'){		/* copy plain text rune */
            if(*s < Runeself)
                pchr(f, *s++);
            else{
                n = chartorune(&r, (char *)s);
                while(n-- > 0)
                    pchr(f, *s++);
            }
        }else{			/* $something -- perform substitution */
            t = ++s;
            if(*t == '$')
                pchr(f, *t++);
            else{
                while(*t && idchr(*t))
                    t++;
                savec = *t;
                *t = '\0';
                n = 0;
                for(u = s; *u && '0' <= *u && *u <= '9'; u++)
                    n = n*10 + *u - '0';
                if(n && *u == '\0'){
                    star = vlook("*")->val;
                    if(star && 1 <= n && n <= count(star)){
                        while(--n)
                            star = star->next;
                        pstr(f, star->word);
                    }
                }else
                    pstrs(f, vlook((char *)s)->val);
                *t = savec;
                if(savec == '^')
                    t++;
            }
            s = t;
        }
    }
}
@
%$

<<function pstrs>>=
void
pstrs(io *f, word *a)
{
    if(a){
        while(a->next && a->next->word){
            pstr(f, a->word);
            pchr(f, ' ');
            a = a->next;
        }
        pstr(f, a->word);
    }
}
@

\subsection{Read-write redirections, [[<> file]]}

<<constant RDWR>>=
#define RDWR	7
@


<<[[yylex()]] in switch when redirection character, if read/write redirect>>=
else if (nextis('>')){
    t->rtype = RDWR;
    *w++=c;
}
@

<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case RDWR:
    emitf(Xrdwr);
    break;
@

<<function Xrdwr>>=
void
Xrdwr(void)
{
    char *file;
    int f;

    switch(count(runq->argv->words)){
    default:
        Xerror1("<> requires singleton\n");
        return;
    case 0:
        Xerror1("<> requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, ORDWR))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@


\subsection{Advanced redirections, [[>[2] file]]}

% fancy lexing redirect, see rc manual

% Lexing

<<[[yylex()]] in switch when redirection character, if bracket after>>=
if(nextis('[')){
    *w++='[';
    c = advance();
    *w++=c;
    if(c<'0' || '9'<c){
    RedirErr:
        *w = 0;
        yyerror(t->type==PIPE?"pipe syntax"
                :"redirection syntax");
        return EOF;
    }
    t->fd0 = 0;
    do{
        t->fd0 = t->fd0*10+c-'0';
        *w++=c;
        c = advance();
    }while('0'<=c && c<='9');
    if(c=='='){
        *w++='=';
        if(t->type==REDIR)
            t->type = DUP;
        c = advance();
        if('0'<=c && c<='9'){
            t->rtype = DUPFD;
            t->fd1 = t->fd0;
            t->fd0 = 0;
            do{
                t->fd0 = t->fd0*10+c-'0';
                *w++=c;
                c = advance();
            }while('0'<=c && c<='9');
        }
        else{
            if(t->type==PIPE)
                goto RedirErr;
            t->rtype = CLOSE;
        }
    }
    if(c!=']'
    || t->type==DUP && (t->rtype==HERE || t->rtype==APPEND))
        goto RedirErr;
    *w++=']';
}
@


<<constant CLOSE>>=
#define	CLOSE	6
@


\subsection{Advanced dup, [[>[fd0=fd1]] ], [[<>[fd0=fd1] ]], [[>[fd0=fd1] ]]}

<<token declarations>>=
%token DUP
@

<<constant DUPFD>>=
#define	DUPFD	5
@

<<redir rule other cases>>=
|   DUP
@


<<[[outcode()]] cases>>=
case DUP:
    if(t->rtype==DUPFD){
        emitf(Xdup);
        emiti(t->fd0);
        emiti(t->fd1);
    }
    else{
        emitf(Xclose);
        emiti(t->fd0);
    }
    outcode(c1, eflag);
    emitf(Xpopredir);
    break;
@

<<function Xdup>>=
void
Xdup(void)
{
    pushredir(RDUP, runq->code[runq->pc].i, runq->code[runq->pc+1].i);
    runq->pc+=2;
}
@

<<constant RDUP>>=
#define	RDUP	2			/* dup2(from, to); */
@


<<constant RCLOSE>>=
#define	RCLOSE	3			/* close(from); */
@

<<function Xclose>>=
void
Xclose(void)
{
    pushredir(RCLOSE, runq->code[runq->pc].i, 0);
    runq->pc++;
}
@


<<[[doredir()]] switch redir type cases>>=
case RDUP:
    Dup(rp->from, rp->to);
    break;
@

<<[[doredir()]] switch redir type cases>>=
case RCLOSE:
    close(rp->from);
    break;
@



\subsection{Advanced pipes, [[|[fd] ]], [[|[fd0=fd1] ]]}

% see man/1/rc:


% * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output,
% * 					depending on type), push /dev/fd/??

<<[[outcode()]] cases>>=
case PIPEFD:
    emitf(Xpipefd);
    emiti(t->rtype);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    break;
@

<<constant PRD>>=
/*
 * Which fds are the reading/writing end of a pipe?
 * Unfortunately, this can vary from system to system.
 * 9th edition Unix doesn't care, the following defines
 * work on plan 9.
 */
#define	PRD	0
@

<<constant PWR>>=
#define	PWR	1
@


<<function Xpipefd>>=
void
Xpipefd(void)
{
    struct Thread *p = runq;
    int pc = p->pc, pid;
    char name[40];
    int pfd[2];
    int sidefd, mainfd;
    if(pipe(pfd)<0){
        Xerror("can't get pipe");
        return;
    }
    if(p->code[pc].i==READ){
        sidefd = pfd[PWR];
        mainfd = pfd[PRD];
    }
    else{
        sidefd = pfd[PRD];
        mainfd = pfd[PWR];
    }
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0:
        clearwaitpids();
        start(p->code, pc+2, runq->local);
        close(mainfd);
        pushredir(ROPEN, sidefd, p->code[pc].i==READ?1:0);
        runq->ret = 0;
        break;
    default:
        addwaitpid(pid);
        close(sidefd);
        pushredir(ROPEN, mainfd, mainfd);	/* isn't this a noop? */
        strcpy(name, Fdprefix);
        inttoascii(name+strlen(name), mainfd);
        pushword(name);
        p->pc = p->code[pc+1].i;
        break;
    }
}
@


\subsection{Advanced pipes and redirections, [[<{command}]], [[>{command}]]}

<<comword rule other cases>>=
|   REDIR brace     {$$=mung1($1, $2); $$->type=PIPEFD;}
@
% ???


% dup here? XpipeFD? see rc manual

% see man/1/rc:
% cmp <{old} <{new}


\subsection{Stringification of variables, [[$"foo]]} %$

<<comword rule other cases>>=
|   '"' word        {$$=tree1('"', $2);}
@
%$
% no ending "? No, it is used for stringification of a variable.
% a list2str.

<<[[outcode()]] cases>>=
case '"':
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xqdol);
    break;
@


<<function Xqdol>>=
void
Xqdol(void)
{
    word *a, *p;
    char *s;
    int n;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);
    a = vlook(s)->val;
    poplist();
    n = count(a);
    if(n==0){
        pushword("");
        return;
    }
    for(p = a;p;p = p->next) n+=strlen(p->word);
    s = emalloc(n);
    if(a){
        strcpy(s, a->word);
        for(p = a->next;p;p = p->next){
            strcat(s, " ");
            strcat(s, p->word);
        }
    }
    else
        s[0]='\0';
    pushword(s);
    efree(s);
}
@


\subsection{Command output capture, [[`{command}]]}

<<comword rule other cases>>=
|   '`' brace       {$$=tree1('`', $2);}
@
%$
% rc use the `{} syntax for backquote (See Make.nw)


<<[[outcode()]] cases>>=
case '`':
    emitf(Xbackq);
    p = emiti(0);
    outcode(c0, 0);
    emitf(Xexit);
    stuffdot(p);
    break;
@

% * Xbackq{... Xreturn}			make thread for {}, push stdout

<<function Xbackq>>=
/*
 * Who should wait for the exit from the fork?
 */
void
Xbackq(void)
{
    int n, pid;
    int pfd[2];
    char *stop;
    char utf[UTFmax+1];
    struct Io *f;
    var *ifs = vlook("ifs");
    word *v, *nextv;
    Rune r;
    String *word;

    stop = ifs->val? ifs->val->word: "";
    if(pipe(pfd)<0){
        Xerror("can't make pipe");
        return;
    }
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        close(pfd[PRD]);
        close(pfd[PWR]);
        return;
    case 0:
        clearwaitpids();
        close(pfd[PRD]);
        start(runq->code, runq->pc+1, runq->local);
        pushredir(ROPEN, pfd[PWR], 1);
        return;
    default:
        addwaitpid(pid);
        close(pfd[PWR]);
        f = openfd(pfd[PRD]);
        word = s_new();
        v = nil;
        /* rutf requires at least UTFmax+1 bytes in utf */
        while((n = rutf(f, utf, &r)) != EOF){
            utf[n] = '\0';
            if(utfutf(stop, utf) == nil)
                s_nappend(word, utf, n);
            else
                /*
                 * utf/r is an ifs rune (e.g., \t, \n), thus
                 * ends the current word, if any.
                 */
                if(s_len(word) > 0){
                    v = newword(s_to_c(word), v);
                    s_reset(word);
                }
        }
        if(s_len(word) > 0)
            v = newword(s_to_c(word), v);
        s_free(word);
        closeio(f);
        Waitfor(pid, 0);
        /* v points to reversed arglist -- reverse it onto argv */
        while(v){
            nextv = v->next;
            v->next = runq->argv->words;
            runq->argv->words = v;
            v = nextv;
        }
        runq->pc = runq->code[runq->pc].i;
        return;
    }
}
@



\section{Advanced builtins}

\subsection{[[$ exec]]}
%$

% actually called from Xsimple()

\subsection{[[$ whatis]]}
%$

<<function execwhatis>>=
void
execwhatis(void){	/* mildly wrong -- should fork before writing */
    word *a, *b, *path;
    var *v;
    struct Builtin *bp;
    char *file;
    struct Io out[1];
    int found, sep;
    a = runq->argv->words->next;
    if(a==0){
        Xerror1("Usage: whatis name ...");
        return;
    }
    setstatus("");
    memset(out, 0, sizeof out);
    out->fd = mapfd(1);
    out->bufp = out->buf;
    out->ebuf = &out->buf[NBUF];
    out->strp = nil;
    for(;a;a = a->next){
        v = vlook(a->word);
        if(v->val){
            pfmt(out, "%s=", a->word);
            if(v->val->next==0)
                pfmt(out, "%q\n", v->val->word);
            else{
                sep='(';
                for(b = v->val;b && b->word;b = b->next){
                    pfmt(out, "%c%q", sep, b->word);
                    sep=' ';
                }
                pfmt(out, ")\n");
            }
            found = 1;
        }
        else
            found = 0;
        v = gvlook(a->word);
        if(v->fn)
            pfmt(out, "fn %q %s\n", v->name, v->fn[v->pc-1].s);
        else{
            for(bp = Builtin;bp->name;bp++)
                if(strcmp(a->word, bp->name)==0){
                    pfmt(out, "builtin %s\n", a->word);
                    break;
                }
            if(!bp->name){
                for(path = searchpath(a->word); path;
                    path = path->next){
                    if(path->word[0] != '\0')
                        file = appfile(path->word, a->word);
                    else
                        file = strdup(a->word);
                    if(Executable(file)){
                        pfmt(out, "%s\n", file);
                        free(file);
                        break;
                    }
                    free(file);
                }
                if(!path && !found){
                    pfmt(err, "%s: not found\n", a->word);
                    setstatus("not found");
                }
            }
        }
    }
    poplist();
    flush(err);
}
@

<<function mapfd>>=
int
mapfd(int fd)
{
    redir *rp;
    for(rp = runq->redir;rp;rp = rp->next){
        switch(rp->type){
        case RCLOSE:
            if(rp->from==fd)
                fd=-1;
            break;
        case RDUP:
        case ROPEN:
            if(rp->to==fd)
                fd = rp->from;
            break;
        }
    }
    return fd;
}
@


<<function Executable>>=
bool
Executable(char *file)
{
    Dir *statbuf;
    bool ret;

    statbuf = dirstat(file);
    if(statbuf == nil)
        return false;
    ret = ((statbuf->mode&0111)!=0 && (statbuf->mode&DMDIR)==0);
    free(statbuf);
    return ret;
}
@



\subsection{[[$ rfork]]}
%$

%rfork
<<function execnewpgrp>>=
void
execnewpgrp(void)
{
    int arg;
    char *s;
    switch(count(runq->argv->words)){
    case 1:
        arg = RFENVG|RFNAMEG|RFNOTEG;
        break;
    case 2:
        arg = 0;
        for(s = runq->argv->words->next->word;*s;s++) switch(*s){
        default:
            goto Usage;
        case 'n':
            arg|=RFNAMEG;  break;
        case 'N':
            arg|=RFCNAMEG;
            break;
        case 'm':
            arg|=RFNOMNT;  break;
        case 'e':
            arg|=RFENVG;   break;
        case 'E':
            arg|=RFCENVG;  break;
        case 's':
            arg|=RFNOTEG;  break;
        case 'f':
            arg|=RFFDG;    break;
        case 'F':
            arg|=RFCFDG;   break;
        }
        break;
    default:
    Usage:
        pfmt(err, "Usage: %s [fnesFNEm]\n", runq->argv->words->word);
        setstatus("rfork usage");
        poplist();
        return;
    }
    if(rfork(arg)==-1){
        pfmt(err, "rc: %s failed\n", runq->argv->words->word);
        setstatus("rfork failed");
    }
    else
        setstatus("");
    poplist();
}
@

\subsection{[[$ wait]]}
%$

<<function execwait>>=
void
execwait(void)
{
    switch(count(runq->argv->words)){
    default:
        Xerror1("Usage: wait [pid]");
        return;
    case 2:
        Waitfor(atoi(runq->argv->words->next->word), 0);
        break;
    case 1:
        Waitfor(-1, 0);
        break;
    }
    poplist();
}
@

\subsection{[[$ flag]]}
%$

<<function execflag>>=
void
execflag(void)
{
    char *letter, *val;
    switch(count(runq->argv->words)){
    case 2:
        setstatus(flag[(uchar)runq->argv->words->next->word[0]]?"":"flag not set");
        break;
    case 3:
        letter = runq->argv->words->next->word;
        val = runq->argv->words->next->next->word;
        if(strlen(letter)==1){
            if(strcmp(val, "+")==0){
                flag[(uchar)letter[0]] = flagset;
                break;
            }
            if(strcmp(val, "-")==0){
                flag[(uchar)letter[0]] = 0;
                break;
            }
        }
    default:
        Xerror1("Usage: flag [letter] [+-]");
        return;
    }
    poplist();
}
@

\subsection{[[$ shift]]}
%$

<<function execshift>>=
void
execshift(void)
{
    int n;
    word *a;
    var *star;
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: shift [n]\n");
        setstatus("shift usage");
        poplist();
        return;
    case 2:
        n = atoi(runq->argv->words->next->word);
        break;
    case 1:
        n = 1;
        break;
    }
    star = vlook("*");
    for(;n && star->val;--n){
        a = star->val->next;
        efree(star->val->word);
        efree((char *)star->val);
        star->val = a;
        star->changed = true;
    }
    setstatus("");
    poplist();
}
@



\chapter{Conclusion}

% Lex and Yacc to understand some parts. Kernel.




\appendix

\chapter{Debugging}

\section{[[rc -???]] printing AST}

% pcmd.c

<<global nl>>=
char nl='\n';		/* change to semicolon for bourne-proofing */
@

% TODO ugly and dupe with the one in code.c
<<constant c0>>=
#define	c0	t->child[0]
@

<<constant c1>>=
#define	c1	t->child[1]
@

<<constant c2>>=
#define	c2	t->child[2]
@

% called from pfmt %t
<<function pcmd>>=
void
pcmd(io *f, tree *t)
{
    if(t==nil)
        return;
    assert(f != nil);

    switch(t->type){
    case '$':	pfmt(f, "$%t", c0); break;
    case '"':	pfmt(f, "$\"%t", c0); break;
    case '&':	pfmt(f, "%t&", c0); break;
    case '^':	pfmt(f, "%t^%t", c0, c1); break;
    case '`':	pfmt(f, "`%t", c0); break;
    case ANDAND:pfmt(f, "%t && %t", c0, c1); break;
    case OROR:	pfmt(f, "%t || %t", c0, c1); break;
    case BANG:	pfmt(f, "! %t", c0); break;
    case BRACE:	pfmt(f, "{%t}", c0); break;
    case COUNT:	pfmt(f, "$#%t", c0); break;
    case FN:	pfmt(f, "fn %t %t", c0, c1); break;
    case IF:	pfmt(f, "if%t%t", c0, c1); break;
    case NOT:	pfmt(f, "if not %t", c0); break;
    case PCMD:
    case PAREN:	pfmt(f, "(%t)", c0); break;
    case SUB:	pfmt(f, "$%t(%t)", c0, c1); break;
    case SIMPLE:	pfmt(f, "%t", c0); break;
    case SUBSHELL:	pfmt(f, "@ %t", c0); break;
    case SWITCH:	pfmt(f, "switch %t %t", c0, c1); break;
    case TWIDDLE:	pfmt(f, "~ %t %t", c0, c1); break;
    case WHILE:		pfmt(f, "while %t%t", c0, c1); break;

    case ARGLIST:
        if(c0==nil)
            pfmt(f, "%t", c1);
        else if(c1==nil)
            pfmt(f, "%t", c0);
        else
            pfmt(f, "%t %t", c0, c1);
        break;
    case ';':
        if(c0){
            if(c1)
                pfmt(f, "%t%c%t", c0, nl, c1);
            else pfmt(f, "%t", c0);
        }
        else pfmt(f, "%t", c1);
        break;
    case WORDS:
        if(c0)
            pfmt(f, "%t ", c0);
        pfmt(f, "%t", c1);
        break;
    case FOR:
        pfmt(f, "for(%t", c0);
        if(c1)
            pfmt(f, " in %t", c1);
        pfmt(f, ")%t", c2);
        break;
    case WORD:
        if(t->quoted)
            pfmt(f, "%Q", t->str);
        else pdeglob(f, t->str);
        break;
    case DUP:
        if(t->rtype==DUPFD)
            pfmt(f, ">[%d=%d]", t->fd1, t->fd0); /* yes, fd1, then fd0; read lex.c */
        else
            pfmt(f, ">[%d=]", t->fd0);
        pfmt(f, "%t", c1);
        break;
    case PIPEFD:
    case REDIR:
        switch(t->rtype){
        case HERE:
            pchr(f, '<');
        case READ:
        case RDWR:
            pchr(f, '<');
            if(t->rtype==RDWR)
                pchr(f, '>');
            if(t->fd0!=0)
                pfmt(f, "[%d]", t->fd0);
            break;
        case APPEND:
            pchr(f, '>');
        case WRITE:
            pchr(f, '>');
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
            break;
        }
        pfmt(f, "%t", c0);
        if(c1)
            pfmt(f, " %t", c1);
        break;
    case '=':
        pfmt(f, "%t=%t", c0, c1);
        if(c2)
            pfmt(f, " %t", c2);
        break;
    case PIPE:
        pfmt(f, "%t|", c0);
        if(t->fd1==0){
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
        }
        else pfmt(f, "[%d=%d]", t->fd0, t->fd1);
        pfmt(f, "%t", c1);
        break;

    default:	
        pfmt(f, "bad cmd %d %p %p %p", t->type, c0, c1, c2);
        break;
    }
}
@
%$

<<function pdeglob>>=
void
pdeglob(io *f, char *s)
{
    while(*s){
        if(*s==GLOB)
            s++;
        pchr(f, *s++);
    }
}
@




\section{[[rc -r]] printing opcodes}

<<[[main()]] debug runq in interpreter loop>>=
if(flag['r'])
    pfnc(err, runq);
@

% pfnc.c
<<global fname>>=
struct{
    void	(*f)(void);
    char	*name;
} fname[] = {
    Xappend, "Xappend",
    Xassign, "Xassign",
    Xasync, "Xasync",
    Xbackq, "Xbackq",
    Xbang, "Xbang",
    Xcase, "Xcase",
    Xclose, "Xclose",
    Xconc, "Xconc",
    Xcount, "Xcount",
    Xdelfn, "Xdelfn",
    Xdelhere, "Xdelhere",
    Xdol, "Xdol",
    Xdup, "Xdup",
    Xeflag, "Xeflag",
    (void (*)(void))Xerror, "Xerror",
    Xexit, "Xexit",
    Xfalse, "Xfalse",
    Xfn, "Xfn",
    Xfor, "Xfor",
    Xglob, "Xglob",
    Xif, "Xif",
    Xifnot, "Xifnot",
    Xjump, "Xjump",
    Xlocal, "Xlocal",
    Xmark, "Xmark",
    Xmatch, "Xmatch",
    Xpipe, "Xpipe",
    Xpipefd, "Xpipefd",
    Xpipewait, "Xpipewait",
    Xpopm, "Xpopm",
    Xpopredir, "Xpopredir",
    Xqdol, "Xqdol",
    Xrdcmds, "Xrdcmds",
    Xrdfn, "Xrdfn",
    Xrdwr, "Xrdwr",
    Xread, "Xread",
    Xreturn, "Xreturn",
    Xsimple, "Xsimple",
    Xsub, "Xsub",
    Xsubshell, "Xsubshell",
    Xtrue, "Xtrue",
    Xunlocal, "Xunlocal",
    Xwastrue, "Xwastrue",
    Xword, "Xword",
    Xwrite, "Xwrite",
    0
};
@

% fnc??
% called from main interpreter loop, also called from pfmt %?
<<function pfnc>>=
void
pfnc(io *fd, thread *t)
{
    int i;
    void (*fn)(void) = t->code[t->pc].f;
    list *a;

    pfmt(fd, "pid %d cycle %p %d ", getpid(), t->code, t->pc);
    for (i = 0; fname[i].f; i++) 
        if (fname[i].f == fn) {
            pstr(fd, fname[i].name);
            break;
        }
    if (!fname[i].f)
        pfmt(fd, "%p", fn);
    for (a = t->argv; a; a = a->next) 
        pfmt(fd, " (%v)", a->words);
    pchr(fd, '\n');
    flush(fd);
}
@


\section{[[rc -s]] printing subprocesses status}

<<[[Xrdcmds()]] print status if -s>>=
if(flag['s'] && !truestatus())
    pfmt(err, "status=%v\n", vlook("status")->val);
@




\chapter{Error Managment}

<<constant ERRMAX>>=
#define ERRMAX 128
@

<<global err>>=
io *err;
@

<<global nerror>>=
int nerror;		/* number of errors encountered during compilation */
@

<<[[Xrdcmds()]] flush errors and reset error count>>=
flush(err);
nerror = 0;
@

% from yylex() (and also maybe yyparse?)
<<function yyerror>>=
void
yyerror(char *m)
{
    pfmt(err, "rc: ");
    if(runq->cmdfile && !runq->iflag)
        pfmt(err, "%s:%d: ", runq->cmdfile, runq->lineno);
    else if(runq->cmdfile)
        pfmt(err, "%s: ", runq->cmdfile);
    else if(!runq->iflag)
        pfmt(err, "line %d: ", runq->lineno);
    if(tok[0] && tok[0]!='\n')
        pfmt(err, "token %q: ", tok);
    pfmt(err, "%s\n", m);
    flush(err);
    lastword = false;
    lastdol = false;

    while(lastc!='\n' && lastc!=EOF) 
        advance();

    nerror++;
    setvar("status", newword(m, (word *)nil));
}
@

% future, peekc, lastc, hmmm
<<global lastc>>=
int lastc;
@
% who uses that? yyerror

<<[[advance()]] save future in lastc>>=
lastc = future;
@

% internal error, no more memory, etc, called from many places
<<function panic>>=
void
panic(char *s, int n)
{
    pfmt(err, "rc: ");
    pfmt(err, s, n);
    pchr(err, '\n');
    flush(err);
    Abort();
}
@

% just called from panic(), so could be inlined there
<<function Abort>>=
void
Abort(void)
{
    pfmt(err, "aborting\n");
    flush(err);
    Exit("aborting");
}
@

% called from a few places, including Xexit
<<function Exit>>=
void
Exit(char *stat)
{
    Updenv();
    setstatus(stat);
    exits(truestatus() ? "" : getstatus());
}
@


\chapter{Libc}

<<function _efgfmt>>=
/* avoid loading any floating-point library code */
//@Scheck: weird, probably linker trick
int _efgfmt(Fmt *)
{
    return -1;
}
@

\section{Memory managment}

%#define	new(type)	((type *)emalloc(sizeof(type)))

<<function emalloc>>=
void *
emalloc(long n)
{
    void *p = Malloc(n);

    if(p==nil)
        panic("Can't malloc %d bytes", n);
/*	if(err){ pfmt(err, "malloc %d->%p\n", n, p); flush(err); } /**/
    return p;
}
@

% plan9
<<function Malloc>>=
void*
Malloc(ulong n)
{
    return mallocz(n, 1);
}
@


<<function efree>>=
void
efree(void *p)
{
    if(p)
        free(p);
    else pfmt(err, "free 0\n");
}
@
%old: /*	pfmt(err, "free %p\n", p); flush(err); /**/
% nice trick the /**/ at the end :)

\section{Command-line arguments processing, [[getflags()]]}
% getopt

% why not use ARGBEGIN/ARGEND?

<<global cmdname>>=
char *cmdname;
@

<<global flagarg>>=
static char *flagarg="";
@




<<global reason>>=
static int reason;
@

<<constant RESET>>=
#define	RESET	1
@

<<constant FEWARGS>>=
#define	FEWARGS	2
@

<<constant FLAGSYN>>=
#define	FLAGSYN	3
@

<<constant BADFLAG>>=
#define	BADFLAG	4
@

<<global badflag>>=
static int badflag;
@

<<function getflags>>=
int
getflags(int argc, char *argv[], char *flags, int stop)
{
    char *s;
    int i, j, c, count;
    flagarg = flags;
    if(cmdname==0)
        cmdname = argv[0];

    i = 1;
    while(i!=argc){
        if(argv[i][0] != '-' || argv[i][1] == '\0'){
            if(stop)		/* always true in rc */
                return argc;
            i++;
            continue;
        }
        s = argv[i]+1;
        while(*s){
            c=*s++;
            count = scanflag(c, flags);
            if(count==-1)
                return -1;
            if(flag[c]){ reason = RESET; badflag = c; return -1; }
            if(count==0){
                flag[c] = flagset;
                if(*s=='\0'){
                    for(j = i+1;j<=argc;j++)
                        argv[j-1] = argv[j];
                    --argc;
                }
            }
            else{
                if(*s=='\0'){
                    for(j = i+1;j<=argc;j++)
                        argv[j-1] = argv[j];
                    --argc;
                    s = argv[i];
                }
                if(argc-i<count){
                    reason = FEWARGS;
                    badflag = c;
                    return -1;
                }
                reverse(argv+i, argv+argc);
                reverse(argv+i, argv+argc-count);
                reverse(argv+argc-count+1, argv+argc);
                argc-=count;
                flag[c] = argv+argc+1;
                flag[c][0] = s;
                s="";
            }
        }
    }
    return argc;
}
@

<<function reverse>>=
static void
reverse(char **p, char **q)
{
    char *t;
    for(;p<q;p++,--q){ t=*p; *p=*q; *q = t; }
}
@

<<function scanflag>>=
static int
scanflag(int c, char *f)
{
    int fc, count;
    if(0<=c && c<NFLAG)
        while(*f){
            if(*f==' '){
                f++;
                continue;
            }
            fc=*f++;
            if(*f==':'){
                f++;
                if(*f<'0' || '9'<*f){ reason = FLAGSYN; return -1; }
                count = 0;
                while('0'<=*f && *f<='9') count = count*10+*f++-'0';
            }
            else
                count = 0;
            if(*f=='['){
                do{
                    f++;
                    if(*f=='\0'){ reason = FLAGSYN; return -1; }
                }while(*f!=']');
                f++;
            }
            if(c==fc)
                return count;
        }
    reason = BADFLAG;
    badflag = c;
    return -1;
}
@

<<function usage>>=
void
usage(char *tail)
{
    char *s, *t, c;
    int count, nflag = 0;
    switch(reason){
    case RESET:
        errs("Flag -");
        errc(badflag);
        errs(": set twice\n");
        break;
    case FEWARGS:
        errs("Flag -");
        errc(badflag);
        errs(": too few arguments\n");
        break;
    case FLAGSYN:
        errs("Bad argument to getflags!\n");
        break;
    case BADFLAG:
        errs("Illegal flag -");
        errc(badflag);
        errc('\n');
        break;
    }
    errs("Usage: ");
    errs(cmdname);
    for(s = flagarg;*s;){
        c=*s;
        if(*s++==' ')
            continue;
        if(*s==':'){
            s++;
            count = 0;
            while('0'<=*s && *s<='9') count = count*10+*s++-'0';
        }
        else count = 0;
        if(count==0){
            if(nflag==0)
                errs(" [-");
            nflag++;
            errc(c);
        }
        if(*s=='['){
            s++;
            while(*s!=']' && *s!='\0') s++;
            if(*s==']')
                s++;
        }
    }
    if(nflag)
        errs("]");
    for(s = flagarg;*s;){
        c=*s;
        if(*s++==' ')
            continue;
        if(*s==':'){
            s++;
            count = 0;
            while('0'<=*s && *s<='9') count = count*10+*s++-'0';
        }
        else count = 0;
        if(count!=0){
            errs(" [-");
            errc(c);
            if(*s=='['){
                s++;
                t = s;
                while(*s!=']' && *s!='\0') s++;
                errs(" ");
                errn(t, s-t);
                if(*s==']')
                    s++;
            }
            else
                while(count--) errs(" arg");
            errs("]");
        }
        else if(*s=='['){
            s++;
            while(*s!=']' && *s!='\0') s++;
            if(*s==']')
                s++;
        }
    }
    if(tail){
        errs(" ");
        errs(tail);
    }
    errs("\n");
    Exit("bad flags");
}
@

<<function errn>>=
static void
errn(char *s, int count)
{
    while(count){ errc(*s++); --count; }
}
@

<<function errs>>=
static void
errs(char *s)
{
    while(*s) errc(*s++);
}
@

<<constant NBUF (rc/getflags.c)>>=
#define	NBUF	80
@

<<global buf>>=
static char buf[NBUF];
@
<<global bufp>>=
static char *bufp = buf;
@

<<function errc>>=
static void
errc(int c)
{
    *bufp++=c;
    if(bufp==&buf[NBUF] || c=='\n'){
        Write(2, buf, bufp-buf);
        bufp = buf;
    }
}
@



\section{Buffered IO}
% again, reimplement the same thing

<<constant NBUF>>=
#define	NBUF	512
@

<<struct io>>=
struct Io {
    fdt	fd;
    byte	*bufp, *ebuf, *strp;
    byte	buf[NBUF];
};
@


<<function openfd>>=
io*
openfd(fdt fd)
{
    io *f = new(struct Io);
    f->fd = fd;
    f->bufp = f->ebuf = f->buf;
    f->strp = nil;
    return f;
}
@

<<enum _anon_>>=
enum { Stralloc = 100, };
@

<<function flush>>=
void
flush(io *f)
{
    int n;

    if(f->strp){
        n = f->ebuf - f->strp;
        f->strp = realloc(f->strp, n+Stralloc+1);
        if(f->strp==0)
            panic("Can't realloc %d bytes in flush!", n+Stralloc+1);
        f->bufp = f->strp + n;
        f->ebuf = f->bufp + Stralloc;
        memset(f->bufp, '\0', Stralloc+1);
    }
    else{
        n = f->bufp-f->buf;
        if(n && Write(f->fd, f->buf, n) != n){
            Write(2, "Write error\n", 12);
            if(ntrap)
                dotrap();
        }
        f->bufp = f->buf;
        f->ebuf = f->buf+NBUF;
    }
}
@

<<function pchr>>=
void
pchr(io *b, int c)
{
    if(b->bufp==b->ebuf)
        fullbuf(b, c);
    else *b->bufp++=c;
}
@

<<function fullbuf>>=
int
fullbuf(io *f, int c)
{
    flush(f);
    return *f->bufp++=c;
}
@


<<function rchr>>=
int
rchr(io *b)
{
    if(b->bufp==b->ebuf)
        return emptybuf(b);
    return *b->bufp++;
}
@

<<function emptybuf>>=
int
emptybuf(io *f)
{
    int n;
    if(f->fd==-1 || (n = Read(f->fd, f->buf, NBUF))<=0) return EOF;
    f->bufp = f->buf;
    f->ebuf = f->buf + n;
    return *f->bufp++;
}
@


<<function rutf>>=
int
rutf(io *b, char *buf, Rune *r)
{
    int n, i, c;

    c = rchr(b);
    if(c == EOF)
        return EOF;
    *buf = c;
    if(c < Runesync){
        *r = c;
        return 1;
    }
    for(i = 1; (c = rchr(b)) != EOF; ){
        buf[i++] = c;
        buf[i] = 0;
        if(fullrune(buf, i)){
            n = chartorune(r, buf);
            b->bufp -= i - n;	/* push back unconsumed bytes */
            assert(b->fd == -1 || b->bufp > b->buf);
            return n;
        }
    }
    /* at eof */
    b->bufp -= i - 1;			/* consume 1 byte */
    *r = Runeerror;
    return runetochar(buf, r);
}
@







<<function closeio>>=
void
closeio(io *io)
{
    if(io->fd>=0)
        close(io->fd);
    if(io->strp)
        efree(io->strp);
    efree(io);
}
@



<<function openstr>>=
io*
openstr(void)
{
    io *f = new(struct Io);

    f->fd = -1;
    f->bufp = f->strp = emalloc(Stralloc+1);
    f->ebuf = f->bufp + Stralloc;
    memset(f->bufp, '\0', Stralloc+1);
    return f;
}
@

<<function opencore>>=
/*
 * Open a corebuffer to read.  EOF occurs after reading len
 * characters from buf.
 */

io*
opencore(char *s, int len)
{
    io *f = new(struct Io);
    uchar *buf = emalloc(len);

    f->fd = -1 /*open("/dev/null", 0)*/;
    f->bufp = f->strp = buf;
    f->ebuf = buf+len;
    Memcpy(buf, s, len);
    return f;
}
@

<<function Memcpy>>=
void
Memcpy(void *a, void *b, long n)
{
    memmove(a, b, n);
}
@




\section{Format}

<<global pfmtnest>>=
int pfmtnest = 0;
@

% io.c
% could use fmtinstall instead? or because wanted to be portable to other OSes?
<<function pfmt>>=
void
pfmt(io *f, char *fmt, ...)
{
    va_list ap;
    char err[ERRMAX];

    va_start(ap, fmt);
    pfmtnest++;
    for(;*fmt;fmt++) {
        if(*fmt!='%') {
            pchr(f, *fmt);
            continue;
        }
        if(*++fmt == '\0')		/* "blah%"? */
            break;
        switch(*fmt){
        case 'c':
            pchr(f, va_arg(ap, int));
            break;
        case 'd':
            pdec(f, va_arg(ap, int));
            break;
        case 'o':
            poct(f, va_arg(ap, unsigned));
            break;
        case 'p':
            pptr(f, va_arg(ap, void*));
            break;
        case 'Q':
            pquo(f, va_arg(ap, char *));
            break;
        case 'q':
            pwrd(f, va_arg(ap, char *));
            break;
        case 'r':
            errstr(err, sizeof err); pstr(f, err);
            break;
        case 's':
            pstr(f, va_arg(ap, char *));
            break;

        // rc specific, TODO LP split here
        case 't':
            pcmd(f, va_arg(ap, struct Tree *));
            break;
        case 'v':
            pval(f, va_arg(ap, struct Word *));
            break;

        default:
            pchr(f, *fmt);
            break;
        }
    }
    va_end(ap);
    if(--pfmtnest==0)
        flush(f);
}
@
% could add 'x' pcmd for the opcode




<<function pstr>>=
void
pstr(io *f, char *s)
{
    if(s==0)
        s="(null)";
    while(*s) pchr(f, *s++);
}
@

<<function pdec>>=
void
pdec(io *f, int n)
{
    if(n<0){
        n=-n;
        if(n>=0){
            pchr(f, '-');
            pdec(f, n);
            return;
        }
        /* n is two's complement minimum integer */
        n = 1-n;
        pchr(f, '-');
        pdec(f, n/10);
        pchr(f, n%10+'1');
        return;
    }
    if(n>9)
        pdec(f, n/10);
    pchr(f, n%10+'0');
}
@

<<function poct>>=
void
poct(io *f, unsigned n)
{
    if(n>7)
        poct(f, n>>3);
    pchr(f, (n&7)+'0');
}
@

<<function pquo>>=
void
pquo(io *f, char *s)
{
    pchr(f, '\'');
    for(;*s;s++)
        if(*s=='\'')
            pfmt(f, "''");
        else pchr(f, *s);
    pchr(f, '\'');
}
@

<<function pwrd>>=
void
pwrd(io *f, char *s)
{
    char *t;
    for(t = s;*t;t++) if(*t >= 0 && needsrcquote(*t)) break;
    if(t==s || *t)
        pquo(f, s);
    else pstr(f, s);
}
@

<<function pptr>>=
void
pptr(io *f, void *v)
{
    int n;
    uintptr p;

    p = (uintptr)v;
    if(sizeof(uintptr) == sizeof(uvlong) && p>>32)
        for(n = 60;n>=32;n-=4) pchr(f, "0123456789ABCDEF"[(p>>n)&0xF]);

    for(n = 28;n>=0;n-=4) pchr(f, "0123456789ABCDEF"[(p>>n)&0xF]);
}
@


<<function pval>>=
void
pval(io *f, word *a)
{
    if(a){
        while(a->next && a->next->word){
            pwrd(f, (char *)a->word);
            pchr(f, ' ');
            a = a->next;
        }
        pwrd(f, (char *)a->word);
    }
}
@


\section{String conversions}

<<global bp>>=
char *bp;
@

<<function inttoascii>>=
void
inttoascii(char *s, long n)
{
    bp = s;
    iacvt(n);
    *bp='\0';
}
@

<<function iacvt>>=
static void
iacvt(int n)
{
    if(n<0){
        *bp++='-';
        n=-n;	/* doesn't work for n==-inf */
    }
    if(n/10)
        iacvt(n/10);
    *bp++=n%10+'0';
}
@

\section{Portable wrappers}

%less: could delete them, I don't care about other OSes

<<function Write>>=
long
Write(int fd, void *buf, long cnt)
{
    return write(fd, buf, cnt);
}
@

<<function Read>>=
long
Read(int fd, void *buf, long cnt)
{
    return read(fd, buf, cnt);
}
@

<<function Seek>>=
long
Seek(int fd, long cnt, long whence)
{
    return seek(fd, cnt, whence);
}
@

<<function Creat>>=
int
Creat(char *file)
{
    return create(file, 1, 0666L);
}
@

<<function Dup>>=
int
Dup(int a, int b)
{
    return dup(a, b);
}
@




\chapter{Extra Code}

\ifallcode
#include "Shell_extra.nw"
\fi



%\chapter{Changelog}
% code via make loc = 6300 LOC, after full lpized  ? LOC
% orig Shell.nw = 7500 LOC, after full lpized and comments in sections ??
% now: =~ ?? LOC so added ?? LOE (Lines of explanations)
% rc in ocaml: ?? LOC (but not all features)


\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}




\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
