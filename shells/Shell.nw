\documentclass[12pt]{report}
%12pt, twocolumn, landscape

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
%  - removed deadcode (Thread.treenodes, Tree.iskw, freetree, ...)

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps (only 20: 1.5% down from 4.61%), introduced
%   error.c, main.c, utils.c, words.c, globals.c, fmt.c,
%   path.c, status.c, builtins.c, env.c, executils.c, input.c, processes.c
%   and spread around plan9.c, 
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)


%thx to rc in ocaml, I learned a lot:
%  - Xerror and walk up the stack
%  - Xasssign and double Xmark
%  - lots of stuff

%thx to this manual, I better understand sh:
% - SEMI fancy redirection syntax, especially 2>&1 ?? I never remember
%   but in rc it's   ls /xxx >[2=1] > /tmp/errors
% - SEMI operator priorities (; vs & vs | vs >)
% - SEMI $*, variable for return status of process ($status in rc, simpler)
% - $* vs $@ (actually rc does not have the problem)
% - TODO escaping nightmares (less pb in rc)
% - SEMI multiline editing
% - TODO subshell power? ex?
%     (for d in utils parsing typing bytecomp asmcomp driver tools/toplevel; \
%              do boot/ocamlrun tools/misc/ocamldep -I utils -I parsing -I typing -I bytecomp -I asmcomp -I driver -I tools/toplevel $d/*.mli $d/*.ml; \
%              done) > .depend
% - to not use ';' but instead && for eflag -e to work
% - interactive vs non-interactive mode. It's mainly for the prompt,
%   to print it or not (note that it is printed on stderr also).
% - SEMI login vs non-login shell (one launch /home/lib/profile)
% - SEMI why need 'test' and why it is an external program

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, builtin, bytecode
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - SEMI nullify, boolify, typeify,    scheckify
% - SEMI aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{xspace}
\usepackage{verbatim}
%note: required by 'syncweb -to_tex' for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

\input{../docs/latex/Config}
\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../docs/latex/syncweb}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Shell [[rc]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Tom Duff
}

\maketitle 
%\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a {shell}.

\section{Motivations}

Why a shell? 
Because I think you are a better programmer if
you fully understand how things work under the hood, and
the shell is the central piece of the {command-line user interface}.
% and it is places where reside programmer most of the time. 
% IDE, GUI, but shell still central place!
%
The shell sits on top of the kernel and allows you to execute other
programs.
% command interpreter.
\l without shell around kernel (hence the name shell), then kernel
\l  is useless. shell is UI.
% interpreter so different from compiler. interesting. also kinda DSL
% so interesting designs.

% No book again on how to implement a shell.
% Not that interesting? Maybe. Redundant with Compiler? Nos cos usually
% use interpreter or bytecode interpreter technique, so interesting.
% Also interesting design constraints compared to regular PL.

Here are a few questions I hope this book will answer:
\begin{itemize}

\item What is the difference between a shell and a terminal?
What is the difference between a shell and a login program?
\n rc vs /dev/cons
\l rc vs login or telnet or ssh (plan9 has no login program)

\item What happens when the user type [[ls]] in a terminal?
What are the programs involved in such a command? 
What is the trace of such a command through the different layers
of the software stack?

\item What are the main features of a shell?

\item How are implemented redirection and pipes? 
What are the system calls involved?

\item Why [[ls]] and [[rm]] are regular programs but not [[cd]]?
Why [[cd]] has to be a shell {builtin}? What is a shell builtin?
%Why can not it be a regular command such as [[ls]]?

\item How does [[C-c]], which interrupts a processe, work?
Which process receives the signal after an interruption?
The shell or the command ran from the shell?

\item How does [[C-z]], which suspends a process, work?


\end{itemize}
%less: relation between login shell (.profile), user shell (bashrc), terminal
% but rc does not have this issue I think.

%bash shellshock context in oct 2014, good idea to look at shell
% implementation :)

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl): (use ??)
% - growing_array (codebuf, waitpids)

%algorithms (beyond search/sort): (actually use neither search nor sort?)
% - globing?


\section{The \plan shell: [[rc]]}

%http://plan9.bell-labs.com/magic/man2html/1/rc

% gonna present rc, for run command.
% 6300 LOC.

% classic plan9. Simpler. cleanup bourne stuff. Notably 
% string vs list of strings so less corner cases.
% More C-like than Algol-like.

% actually seems used as a fork basis for other advanced shells
% (es, other?)
\l used also outside plan9 by a few open source software. Portable.

% missing stuff: lots of interactive stuff apparently introduced in 
% Bill Joy's csh. See Conclusion.

% Still used in Go :)

\section{Other shells}

Here are a few shells that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

\item Thompson's shell
% introduced pipe notation? globbing?

\item Bourne shell
% Classic. Not first one, thompson before, and before shell for multics, 
%  but most famous.
% Algol spirit, do/done, case/esac. Rc use { }
%  note that no do/od because od was an octal dump.
% 4145 LOC in V7, 6 man pages. use WHILE THEN macros :) really Algol fan.
% design of sh by bourne:
%  TODO https://www.youtube.com/watch?v=2kEJoWfobpA
% but many corner cases. Actually Duff says nobody knows the grammar
%  of sh (even though sh article by Bourne contains a grammar in appendix).
%  Not in yacc, recursive descent, and hacky he says.
% http://samrowe.com/wordpress/advancing-in-the-bash-shell/

\item Bash (Bourne Again Shell) 
% big codebase
%http://www.aosabook.org/en/bash.html
%110 man pages. 75 pages in pdf of man page. and bash reference manual is 172
% pages.
% more interactive, arrow key, C-r. Completion. But need readline and
%  raw mode (similar features provided instead by window terminal in rio)

\item zsh
% oh-my-zsh cult
% **/*, pcomplete, 

\item scsh
\l more orthogonal, but then more verbose, remove what makes a shell a bit.

\end{itemize}

%history:
% - http://www.multicians.org/shell.html
%   history of the shell by Louis Pouzin, RUNCOM first shell (also rc)
%    "commands should be usable as building blocks for writing more commands,
%     just like subroutine libraries"
% - http://v6shell.org/history/sh.c the original shell of Ken Thompson
%   3 man pages
% - mashey shell by PWB group
% - original bourne shell, in unix-history-repo, 4145 LOC for V7
%   6 man pages
% - original csh (apparently introduced many interactive features) by
%   Bill Joy
%education:
% - xinu shell in appendix of xinu book
% - osh, shell v6:
%   http://v6shell.org/
%   understanding the shell of v6:
%   http://experiments.oskarth.com/unix01/
% - a shell for xv6
%   https://github.com/oskarth/xv6/blob/master/homework/sh.c
%mini:
% - sh.c in plan9, simple shell used for early porting with
%   many programs as builtins! really useful.
% - sash (stand-alone-shell), precursor to busybox; far smaller.
%   many builtins there such as ed, tar are included in busybox.
%   1500 LOC (without the cmd_xxx.c)
% - http://runtimeterror.com/tech/lil/
% - Tcl in 500 LOC http://antirez.com/picol/picol.c.txt
% - https://github.com/zserge/partcl mini Tcl again
%other:
% - ash Almquist shell https://en.wikipedia.org/wiki/Almquist_shell
%   used for Debian startup scripts (called dash), android, busybox
%   many variants: http://www.in-ulm.de/~mascheck/various/ash/
%   17 000 LOC (ash.c is 11 000 LOC in busybox, but maybe use other files)
% - hush, a reimplem of sh (9300 LOC in busybox)
% - busybox, includes ash and hush, with many programs as builtins.
% - rc fork: http://tobold.org/article/rc
% - extensible shell, based on rc:
%   http://wryun.github.io/es-shell/
%   http://wryun.github.io/es-shell/paper.html
% - ape/pdksh/, 23 000 LOC vs rc 6300 (or 10 000 when wc *.nw instead)
% - eshell!! pager a la plan9, so no need pager like less/more/most actually
%   http://www.howardism.org/Technical/Emacs/eshell-fun.html
% - PowerShell, recently open sourced, written in C#, huge
%   contains shell but also utilities. Apparently can have typed pipes.
%   Maybe like in Automator?
% - DOS? they had a shell?
% - cicada, shell in rust https://github.com/mitnk/cicada
% - https://elvish.io/
%research/recent:
% - fish shell (friendly shell), lots of interactive features
%   50 000 LOC (without tests), written in C++
%   rely on ncurses (uses also PCRE)
% - next generation shell
%   https://github.com/ilyash/ngs/
% - xonsh http://xon.sh/ (a superset of pyhton)
% - oil shell (also shell in python) 
%   http://www.oilshell.org/blog/2017/02/11.html
% - Automator, visual pipes! not really a shell, a kind of visual shell
% - mosh, mobile shell, allow disconnection over Wifi apparently
%   but not really a shell, more a replacement for ssh
% - https://github.com/ergonomica/ergonomica a cross-platform shell written
%   in Python

% https://en.wikipedia.org/wiki/Comparison_of_command_shells
% http://xon.sh/#comparison contains  nice comparison of modern shells:

%evolution of shells:
% https://www.ibm.com/developerworks/library/l-linux-shells/
% nice diagram of history of shells, very nice resource list with further links

%https://brennan.io/2015/01/16/write-a-shell-in-c/
%http://www.davidpashley.com/articles/writing-robust-shell-scripts/

% list of terminals and shells:
%  https://github.com/k4m4/terminals-are-sexy

%https://indradhanush.github.io/blog/writing-a-unix-shell-part-1/
%https://indradhanush.github.io/blog/writing-a-unix-shell-part-2/

%https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
% from https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/

% basic command, pipe, quotes, use PEG parser (meh)
%https://www.destroyallsoftware.com/screencasts/catalog/shell-from-scratch

\section{Getting started}

\section{Requirements}

% see docs/ for design, especially how and why differences with bourne shell

% Also Bourne slides are great for other design decisions.

% Original bourne article in unix programmer's manual edition 7

% there is an article in oasa book about bash
% (available in bash/doc/aosa-bash.pdf)

% A tour through UNIX shell - article, but meh, document
%  bourne shell, and how they ported it to use malloc
% A tour through ASH (but bof)



\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[rc]], Tom Duff, 
who wrote in some sense most of this book.




\chapter{Overview}

\section{Shell principles}

%without:? can have hardcoded in kernel, but restricted.

% shell = stuff around a kernel in a coquillage.
% history: multics.
% A shell is a bastard. See bourne article in docs/articles/unix/ about sh.

\l do a minishell before showing rc?

% for a long time actually there was no (external) shell. Shell was
% part of OS. With Unix it changed and shell can be a regular user program. 

% for interactive use, and for programming. Both uses, 
% and different features for those 2 things.

\subsection{Running commands}

% shell is first to run commands (hence the name of rc)! entered
%  interactively.
% In fact very first shell was called RUNCOM.

% Hence minimalist syntax. Compare  ls /foo  vs  print(readdir("/foo"));
%  (or worse: fork; ... exec (/bin/ls); ...)
% no parenthesis (curry syntax :) ), no quotes. implicit.
% no full path either thx to PATH variable.
% no special character to end, just newline (but then need backslash
%  and then need skipnl)
% no types (actually really has no types. just list of strings)
%real-world: ocaml needs ;; but then no need for skipnl tricks

%dup: 
%    "commands should be usable as building blocks for writing more commands,
%     just like subroutine libraries" - Pouzin


%\subsection{A DSL}

% so sugar for running command with PATH searching.
% also feature for arguments, filenames. globbing!
% handle * expansion (before was delegated to another program called glob)
% also ? and []

% note that different from regexp, does not do .* because .
% used too much in filename for extension, so *.c is better than .*\\.c

% see redirection soon. |, <, >. 

% It then opened the way for complex job control language. More features.

%dup in grammar:
% interesting DSL. must be easy to issue a command.
% don't want to do 'system("ls");' like in other languages.
% and want newline to have a special semantic role, a kind of implicit ';'
% but also want to have multiline statements ... so newline must be allowed
%  and not run the command sometimes.
% -xxx, /a/b, are treated as regular words! only ;&${[^ are specials


\subsection{A universal read-eval-print loop (REPL)}

% shell is also idea of universal repl! not like Lisp machine, Squeak, etc.
% see Kernel.nw note on this.
% call function from repl, pass argument, modify globals. can even get
% help via whatis :) or man :) and return boolean result (status)
% (as well as effect on stdout/stderr that can be captured)
% In fact very similar to function call in PL: 
%  - arguments to function via argv
%  - globals via environment variables (sometimes globals are useful)
%  - other?

% support multiple programming environment
% (Multics goal too).

% cf stevens book, shell basis = read a line, parse, fork, exec, wait!
% RPFEW


\subsection{Pipes and redirections}

% most prog originated in command-line world. Simple. Basic.
% input and output are strings. Then idea of combining function, so
% why not combining programs. Input can be output of other since same type!
% Universal text power.

% to handle pipe and redirection it's little variations that shows also
% the beauty of fork!

% again DSL. minimal syntax. To do that in C requires lots of work.

% RC has advanced syntax for pipes and redir but we will
% focus on simpler ones: >, <, >>.
% See chapter X for advanced.

%\subsection{Asynchronous jobs and job control}
% also handling signals in child process?

%\subsection{Globbing}

\subsection{A scripting language}
% Scripting! definition of such a language? hybrid lang? easy to "script" :) 
% scriptometer of pixel

% Not just function calls and combination combinator. Want full PL.

% interactive and scripting language. Same engine.
% (ken thompson v6 shell was not scriptable; only interactive)
% So for interactive use, and for programming.

% dynamic language. arbitrary strings length (maybe big deal at the time
%  when compared to C, but compared to Lisp??)
% no memory management.

% evolved gradually. But to still allow simplicify of syntax for
% running commands, without quotes, with just newline,
% had to alter a few things:
% - variable prefix with $. To make diff with regular arguments to
%   commands which can be anything
% - skipnl trick for statements we usually want on multiple lines
% - just strings for values
% - actually list of strings is better basis (so no need PATH : split,
%   no need $* vs $@)

% However this goes in conflict with the ability
% to easily run command and the minimal syntax.
% rc uses lots of lexing tricks to mix full PL and DSL for
% running command (ex: SUB hack, skipnl, etc)

% no types. just strings.

% no bool. Basis is really the cmd you run.
% so control flow based on return status of the cmd.
% (and just ~ word words otherwise, and again here because basis is the
% string, the only operator is really a string matching operator).

% Even if string only citezen, still wants sometimes numerical tests.
% Enter 'test', which is really a separate program, for argument of if
% for numerical-classic-like tests.

\section{[[rc]] command-line interface}
\l very meta! command line interface of the command line interface!
\l can run shell from shell

% see rc.ps

% -l??

% -i => interactive (default when no argument given and isatty, see main())
% -I => not interactive 
% only diff is prompt not displayed between commands

% -s => debug returned status when error status from subprocess
% -e stops at first error (called like that from mk)
% -m => change init script? not rcmain but something else?

% -r => debug bytecodes output (convenient)


\section{Input shell language}

% run command (obviously), argv
% DSL for pipe, redirection, async, globbing
% mini classic language with control flow statement and variables, globals

% job control? has & but no fg/bg? (but has wait $apid)

% rc PL =~ dynamic
% basic DS = list of strings (List), with operator like ^
% so different from bash here already. But better basis
% to have list as core value, because no need PATH=: separator,
% no need $* vs $@ I think. Just simpler.

% quite similar to bash
% main difference? for var stuff? 'if not' instead of 'else'.


%grouping! subshell! cool:
%	(for d in utils parsing typing bytecomp asmcomp driver tools/toplevel; \
%         do $(CAMLDEP) $(DEPFLAGS) $$d/*.mli $$d/*.ml; \
%         done) > .depend
% without this would have to do some initial >, and then some >>

%missing:
% - C-z ?
% - history
% - filename completion
% - command completion

\section{Code organization}

%dup: (and adapted) from Assembler.nw
Table~\ref{tab:code-orga} presents short descriptions
of the source files of [[rc]], together with
the main entities (e.g., structures, functions, globals) the file defines,
and the corresponding chapters in this document in which the code
contained in the file is primarily discussed.
\n sorted by chapters, make more sense than sorted by dir

\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lcllr}
\toprule
{\bf Function}                 & {\bf Ch.}                     & {\bf File}     & {\bf Entities}                                  & {\bf LOC} \\
\otoprule
main data structures           & \ref{chap:core-ds}            & [[rc.h]]       & [<Tree>] [<Code>] [<Word>] [<List>] [<Var>]     & \\ % Here
execution data structures      & \ref{chap:core-ds}            & [[exec.h]]     & [<Thread>]                                      & \\ % Redir Builtin
AST helpers                    & \ref{chap:core-ds}            & [[tree.c]]     & [<newtree()>] [<tree1()>] [<tree2()>]           & \\ % treenodes mung[123] epimung simplemung  [tree3()>] [freenodes()>]
globals                        & \ref{chap:core-ds}            & [[globals.c]]  & [<codebuf>] [<runq>]                            & \\ %
list of strings (words)        & \ref{chap:core-ds}            & [[words.c]]    & [<newword()>] [<count()>] [<freewords()>]       & \\ % copywords freelist? [copynwords()>]
shell variables                & \ref{chap:core-ds}            & [[var.c]]      & [<setvar()>] [<vlook()>] [<gvar>] [<gvlook()>]  & \\ % kenter kinit [newvar()>] 
function prototypes            & \ref{chap:core-ds}            & [[fns.h]]      & \\ %
\midrule

entry point                    & \ref{chap:main}               & [[main.c]]     & [<main()>]                                      & \\ % isatty Rcmain
execution utilities            & \ref{chap:main}               & [[executils.c]]& [<start()>] [<pushlist()>] [<pushword()>]   & \\ %  [Xerror()>] [Xreturn()>] Xpopredir poplist popword argv0

\midrule
character input and prompt     & \ref{chap:input}              & [[input.c]]    & [<getnext()>] [<pprompt()>] [<nextc()>] \\ % [token()>] [klook()>]
lexer                          & \ref{chap:lexing}             & [[lex.c]]      & [<yylex()>]                                     & \\ % wordchr idchr skipwhite skipnl  [<yyerror()>]
parser                         & \ref{chap:parsing}            & [[syn.y]]      & [<yyparse()>]                                   & \\ 

\midrule
bytecode generation            & \ref{chap:compile-interpret}  & [[code.c]]     & [<emitf()>] [<compile()>] [<outcode()>]         & \\ % 
process status                 & \ref{chap:compile-interpret}  & [[status.c]]   & [<setstatus()>] [<getstatus()>]                 & \\ % truestatus convstatuts
simple command bytecode        & \ref{chap:compile-interpret}  & [[simple.c]]   & [<Xsimple()>] [<execexec()>] [<doredir()>]      & \\ % execcmds execfunc (fn)
[[$path]] management           & \ref{chap:compile-interpret}  & [[path.c]]     & [<searchpath()>]                                & \\ %$
process-related bytecodes      & \ref{chap:compile-interpret}  & [[processes.c]] & [<execforkexec()>] [<Xpipe()>] [<Xasync()>]     & \\ % Xbackq Xpipefd Xsubshell 
other bytecodes                & \ref{chap:compile-interpret}  & [[exec.c]]     & [<Xtrue()>] [<Xjump()>] [<Xfn()>] & \\ % [Xwrite()>] [Xassign()>]

\midrule
shell builtins                 & \ref{chap:builtins}           & [[builtins.c]] & [<execcd()>] [<execexit()>] [<execdot()>]       & \\ % execshift execeval execflag [execwait()>]  [execwhatis()>]
shell environment              & \ref{chap:environment}        & [[env.c]]      & [<addenv()>] [<Vinit()>]                        & \\ % Updenv
[['*']] management (globbing)  & \ref{chap:globbing}           & [[glob.c]]     & [<glob()>] [<match()>]                          & \\ % globlist Xglob
signal management              & \ref{chap:signals}            & [[trap.c]]     & [<dotrap()>]                                    & \\ %

\midrule
% initialization chapter?
[['<<']] management (here doc) & \ref{chap:advanced-topics}    & [[here.c]]     & [<readhere()>] [<heredoc()>]                    & \\ %

\midrule
AST dumper                     & \ref{chap:debugging-appendix} & [[pcmd.c]]     & [<pcmd()>]                                      & \\ %
bytecode dumper                & \ref{chap:debugging-appendix} & [[pfnc.c]]     & [<pfnc()>]                                      & \\ %
error management               & \ref{chap:error}              & [[error.c]]    & [<panic()>]                                     & \\ %
memory management              & \ref{chap:utilities}          & [[utils.c]]    & [<emalloc()>] [<efree()>]                       & \\ % Dup Creat Unlink Malloc [inttoascii()>] ...
command-line flags             & \ref{chap:utilities}          & [[getflags.c]] & [<getflags()>] [<usage()>]                      & \\ % getflags.h flagset [flag>] 
buffered IO                    & \ref{chap:utilities}          & [[io.c]]       & [<openfd()>] [<rchr()>]                         & \\ % io.h openstr opencore
pretty printer                 & \ref{chap:utilities}          & [[fmt.c]]      & [<pfmt()>]                                      & \\ %
%misc utilities                 & \ref{chap:utilities}          & [[subr.c]]     &                                 & \\ % iacvt

\otoprule
Total                          &                               &                &                                                 & 6800 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Chapters and associated [[rc]] source files.}
\label{tab:code-orga}
\end{table*}

%pad: I reorganized quite heavily the source files. Similar to the
% assembler/linker/compiler/, I simplified things by removing support
% for other operating systems (unix and win32) to focus only on
% plan9, so I removed plan9.c, unix.c, and spread it in other files.
% This led to far less circular deps. I also removed the havefork.c
% vs havenfork.c and support only OS that have fork.
%old: havenfork.c (and havefork.c): removed, no need to handle such OS
%old: unix.c, win32.c (and plan9.c): removed, we need to handle only one OS

<<includes>>=
#include "rc.h"
#include "exec.h"
#include "fns.h"
#include "getflags.h"
#include "io.h"
@
%pad: I factorized most include and changed the order. Not worth
% having different #include in each file

\section{Software architecture}

% pipeline archi? like compiler? not exactly as it's actually an interpreter

% string -> lexing(yylex) -> parsing(yyparse) -> ast(treexx) -> bytecode(compile)
% (note that actually not lexing -> parsing  for efficiency parsing call lexer
%  on demand, so need to keep only one token in memory)
%
% but how the parsing chain is called?
% main() -> 
%   - build boostrap[] which essentially contain a Xrdcmds bytecode
%      (actually it has a Xsimple "." rcmain and so
%      will run execdot which will run Xrdcmds)
%   - calls start() to setup runq from boostrap[]
%   - setup runq->argv
%   - start interpreting bootstrap runq->code[pc-1].f()
%       -> Xrdcmds() -> yyparse() -> yylex() (print prompt actually too)
%                                 -> compile() -> outcode() (modify codebuf)
%                    -> start(codebuf)
%                    -> Xreturn and loop


%Xxxx = bytecodes
%execxxx = builtins (Xsimple of specially interpreted command)

% chapter with a simple traduction of a simple command? like 'ls /' ?

%\subsection{Trace of a simple command}

% show rc -r ? great to understand (see Appendix X)

%\subsection{Trace of a pipe}

% when do   % ls | wc -l, what happens?
% first REPL bootstrapped thread t1, 
% then read, compile, and start new thread t2 for that (which when it will
% return, we return to the REPL).
% FIGURE? 

% execute bytecodes, see Pipe byecode. Then fork, in child1 execute
% bytecodes for ls (still in interpreter!). This child1 eventually will
% arrive on a simple command and so forkexec a child2 that will execute
% ls. In the mean time child1 will Waitfor child2. child1 is still interpreter
% and once it has wait, it exits with return status.
% Why forkexec child2, child2 seems like he does not do much.
% But because in that case ls was a simple command. But what if
%  (ls | grep) | wc -l! 
% (actually I think there is an opti that makes child1 exec directly ls).

% So child1 terminated.
% In the mean time the parent when to start a new thread t3 for [wc -l],
% and once this thread finish, it does Xpipewait to wait for either
% left part or right part.
% this new thread t3 does a forkexec child3. T3 also wait for child3
% (but actually can have got the waitfor status of child1)
% and return once done to t2.
% t2 then Xpipewait and wait for either child1 (if not finished yet)
% or concatenate the status.
% once done it returns to REPL t2.

% so see that even if cmd1 | cmd2 there is actually 3 forks!

%\subsection{Trace of a redirection}

% ls > foo
% can also be  {ls; echo bar} > foo

% actually memorize info that will need to redirect. open file
% but do not do yet the redir. Need to wait to be in forked of
% simple command, just before the exec, and then apply the redirection
% information.
% (but then need to popredir)

\section{Book structure}



%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\section{[[Token]]}

<<token declarations>>=
%token FOR IN WHILE IF NOT SWITCH FN
%token TWIDDLE BANG  /** ~ ! */
%token REDIR PIPE /** {>, <, <<, >>} | */
%token ANDAND OROR /** && || */
%token COUNT SUB /** $# ( */
%token WORD /** anything else (e.g. foo, --help, 42, /a/b/c, etc) */
@
%old: was using %term instead of %token (probably for %terminal?)
%old: also ANDAND was mentioned only in %left, but better declare everything


% see pcmd() (and syn.y) for the chars not mentioned above:
%  '$', '"', '&', '^', '`', ';', '=' 
%  '(' (different from SUB, lexer trick), ')', '{', '}'
% not sure why treats different ~ (with TWIDDLE) and = (without a %token)


%typedef int Token_kind; (union { char; enum token_kind })
% see x.tab.h (a set of #define but could be an enum)
% with also ascii char into it
% so can also be ';' (see tree3() that actually look for that)

\section{Abstract syntax [[Tree]]}
% rc has a command language!

% AST tree of the command, ex "ls | wc" =>  ?

<<struct [[Tree]]>>=
struct Tree {

    // either<enum<Token_kind>, char>
    int	type;
    // string of the token or AST dump of the whole subtree for certain nodes
    char *str;

    // array<option<ref_own<Tree>>
    tree	*child[3];

    <<[[Tree]] redirection and pipe specific fields>>
    <<[[Tree]] word specific fields>>

    // Extra
    <<[[Tree]] extra fields>>
};
@
%dead: bool iskw;
%ocaml: a more precise AST

% str contain string of the tree. Used to store
% function in the environment.
% Used probably also for debugging for dumping.

% when use the 3 children?

% type is token kind, or character.
% Introduced also a few more token without syntax but part of enum.

<<token declarations>>=
/* not used in syntax */
%token SIMPLE 
%token ARGLIST WORDS
%token BRACE PAREN 
@
% why BRACE and not keep '{' 
%ocaml: use directly list for ARGLIST, WORDS, and use list also
%  for BRACE and PAREN




% populated in newtree() (which is called to build AST in yyparse())
<<global [[treenodes]]>>=
// list<ref_own<Tree>> (next = Tree.next)
tree *treenodes;
@
% record the list of all allocated nodes there, so they can be
% freed in Xrdcmds once the tree has been compiled
% (but could do via tree exploration from root too)
%ocaml: ugly global

<<[[Tree]] extra fields>>=
tree	*next;
@


<<function [[newtree]]>>=
/*
 * create and clear a new tree node, and add it
 * to the node list.
 */
tree*
newtree(void)
{
    tree *t = new(tree);
    t->str = nil;
    t->child[0] = t->child[1] = t->child[2] = nil;

    // add_list(t, treenodes)
    t->next = treenodes;
    treenodes = t;

    return t;
}
@
%dead:    t->iskw = false;
%ocaml: build directly

% dead: it uses freenodes now.
%<<function freetree>>=
%void
%freetree(tree *p)
%{
%    if(p==nil)
%        return;	
%    freetree(p->child[0]);
%    freetree(p->child[1]);
%    freetree(p->child[2]);
%    if(p->str)
%        efree(p->str);
%    efree((char *)p);
%}
%@
%ocaml: use gc

% efree = emalloc = wrapper around free but handling error.

<<function [[freenodes]]>>=
void
freenodes(void)
{
    tree *t, *u;
    for(t = treenodes;t;t = u){
        u = t->next;
        if(t->str)
            efree(t->str);
        efree((char *)t);
    }
    treenodes = nil;
}
@
% and does not call freetree()? all trees are linked together
% in newtree anyway, so here enough to explore flatten list instead
% of "complex" tree.
%ocaml: use gc


% used in syn.y
<<function [[tree1]]>>=
tree*
tree1(int type, tree *c0)
{
    return tree3(type, c0, (tree *)nil, (tree *)nil);
}
@
%ocaml: use precise AST so no need shove everything in tree with 3 children.

<<function [[tree2]]>>=
//@Scheck: used by syn.y
tree* tree2(int type, tree *c0, tree *c1)
{
    return tree3(type, c0, c1, (tree *)nil);
}
@

<<function [[tree3]]>>=
tree*
tree3(int type, tree *c0, tree *c1, tree *c2)
{
    tree *t;

    <<[[tree3]] if some empty sequence>>
    // else
    t = newtree();
    t->type = type;
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@
% no check for c2 when use ';'? no because binary operator?


% opti but useful because get lots of empty commands
% for instance when if() {\n ... \n} then get already two
% empty command for the two newlines.
<<[[tree3]] if some empty sequence>>=
if(type==';'){
    if(c0==nil)
        return c1;
    if(c1==nil)
        return c0;
}
@



\section{Byte[[Code]] and [[codebuf]]}
%old: was called Opcode in original code, but I prefer bytecode

% shell = interpreter. Actually source -> AST -> bytecode
% and then bytecode interpreter, a bit like an actual processor
% (or Java). A little stack based interpreter.

<<global [[codebuf]]>>=
// growing_array<ref_own<Code>>
code *codebuf;				/* compiler output */
@
%ocaml: maybe could just interpret from AST itself.
% not sure needs this intermediate bytecode data structure
%ocaml: ugly to use a global again. Better compile returns codebuf

<<struct [[Code]]>>=
/*
 * The first word of any code vector is a reference count.
 * Always create a new reference to a code vector by calling codecopy(.).
 * Always call codefree(.) when deleting a reference.
 */
union Code {
    void	(*f)(void); // Xxxx() bytecode
    int	i;
    char	*s;
};
@
%ocaml: use variant. Still need the integer for the jumps
% (but no need for reference counting), and also for file descriptor arguments
% for certain bytecodes like Pipe, Dup, etc.

% show bootstrap code?
% or show trace of rc -r ? with my simple bootstrap code!


% * Opcode routines
% * Arguments on stack (...)
% * Arguments in line [...]
% * Code in line with jump around {...}
\t change comment below, use (left)(right) for instance
\t  a closer to output by -r

% * Xrdcmds !!! call yyparse()

% * Xsimple(args)			run command and wait

% * Xmark				mark stack
% * Xword[string]			push string
% * Xpopm(value)			pop value from stack
% * Xcount(name)			push var count
% * Xconc(left, right)			concatenate, push results
% * Xqdol(name)				concatenate variable components

% * Xassign(name, val)			assign val to name
% * Xdol(name)				get variable value
% * Xsub
% * Xglob
% * Xlocal(name, val)			create local variable, assign value
% * Xunlocal				delete local variable

% * Xexit				rc exits with status
% * Xreturn				kill thread

% * Xeflag

% * Xread(file)[fd]			open file to read
% * Xwrite(file)[fd]			open file to write
% * Xrdwr(file)[fd]			open file for reading and writing
% * Xappend(file)[fd]			open file to append
% * Xclose[i]				close file descriptor
% * Xdup[i j]				dup file descriptor
% * Xpopredir

% * Xif
% * Xifnot
% * Xbang				complement condition
% * Xwastrue
% * Xfalse{...}				execute {} if false
% * Xtrue{...}				execute {} if true
% * Xmatch(pat, str)			match pattern, set status
% * Xcase(pat, value){...}		exec code on match, leave (value) on stack
% * Xfor(var, list){... Xreturn}	for loop
% * Xjump[addr]				goto

% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,	wait for both
% * Xpipewait
% * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output, depending on type), push /dev/fd/??

% * Xfn(name){... Xreturn}			define function
% * Xdelfn(name)				delete function definition
% * Xrdfn

% * Xsubshell{... Xexit}		execute {} in a subshell and wait
% * Xasync{... Xexit}			make thread for {}, no wait
% * Xbackq{... Xreturn}			make thread for {}, push stdout


% ???
% * Xdelhere

% * Xerror // print error message and then Xreturn while not interactive thread
%   but it not a generated bytecode! should rename just error

% list of bytecodes with comments were in exec.c but sorted alphabetically
% better to group them for explanation

% dol = dollar

% first element is a reference count, which is why codecopy()
% does cp[0].i++;

% why inline vs in stack? Because many things require evaluation
% and are not known at compile-time. For instance, Fn
% could have a string name after inline in the codevec, but
% actually the argument to fn is a word, which can be a^b, or
% use $, so we need evalation.

% FIGURE where see all argv

% Xfn -> <> 
<<function [[codecopy]]>>=
code*
codecopy(code *cp)
{
    cp[0].i++;
    return cp;
}
@
%ocaml: just use Gc

% when bytecodes are shared? just for bootstrap? need this reference count?
% when define functions.

% Xreturn | Xfn | Xdelfn -> <>
<<function [[codefree]]>>=
void
codefree(code *cp)
{
    code *p;
    if(--cp[0].i != 0)
        return;

    for(p = cp+1; p->f; p++){
        if(p->f==Xappend || p->f==Xclose || p->f==Xread || p->f==Xwrite
        || p->f==Xrdwr
        || p->f==Xasync || p->f==Xbackq || p->f==Xcase || p->f==Xfalse
        || p->f==Xfor || p->f==Xjump
        || p->f==Xsubshell || p->f==Xtrue)
            p++;
        else if(p->f==Xdup || p->f==Xpipefd) 
                 p+=2;
        else if(p->f==Xpipe) 
                 p+=4;
        else if(p->f==Xword || p->f==Xdelhere) 
                 efree((++p)->s);
        else if(p->f==Xfn){
                 efree(p[2].s);
                 p+=2;
              }
    }
    efree((char *)cp);
}
@
%ocaml: just use Gc




\section{[[Thread]] and [[runq]]eue}

% why called threads?
% because they contains bytecodes to execute.
% They are not the process. When interpreting the bytecodes
% they may generate new process but they are not themselves
% processes.
% Still thread is maybe confusing.
% Maybe rename Program? but true that contains code, and pc!
% So it is a unit of execution (then maybe thread is a good name).


<<struct [[Thread]]>>=
struct Thread {
    union Code *code;		/* code for this thread */
    int pc;			/* code[pc] is the next instruction */

    <<[[Thread]] other fields>>

    // Extra
    <<[[Thread]] extra fields>>
};
@
%dead fld:  tree *treenodes;		/* tree nodes created by this process */

<<global [[runq]]>>=
// stack<ref_own<Thread>> (next = Thread.ret)
thread *runq;
@
% x; y; z  would form a list of threads with x at the top and linked to y
% (and ultimately linked to the bootstrap thread)

% when put stuff on stack? when run commands, do x;y, then
% has bytecodes of repl in stack, and add more process on top of it.

<<[[Thread]] extra fields>>=
thread *ret;		/* who continues when this finishes */
@
%ocaml: just use a list for runq, but then need extra function
% to access head of the list. Could also have run and runq.

% freethread()? with reference count handling?

% important one!!
<<[[Thread]] other fields>>=
// list<list<ref_own<word>>> (next = List.next)
struct List *argv;		/* argument stack */
@
% list of list of words?
%ocaml: split Thread.argv and Thread.argv_stack

% runq->argv->words->next->word
% todo define macro? argv1()? argv0() ?


% really intepreter small language, have locals!
% TODO rename local -> locals?
<<[[Thread]] other fields>>=
// list<ref_own<Var>> (next = Var.next)
struct Var *local;		/* list of local variables */
@


% Similar to a machine emulator. Code, pc, stack, and heap (the vars).






\section{Words and lists}
% in appendix?

% saw argv in Thread before.

\subsection{[[Word]]s}

<<struct [[Word]]>>=
/*
 * word lists are in correct order,
 * i.e. word0->word1->word2->word3->nil
 */
struct Word {
    char *word;

    // Extra
    word *next;
};
@
% could define W = nil so avoid those (word*)nil
%dup: similar to the one in Make.nw?
%ocaml: just use list

<<function [[newword]]>>=
word*
newword(char *wd, word *next)
{
    word *p = new(struct Word);
    p->word = strdup(wd);
    p->next = next;
    return p;
}
@
%ocaml: cons ::

% could also have mksingleword that does not take next.
% many calls to newword(foo, (word*)nil) that could be shorter.

<<function [[count]]>>=
int
count(word *w)
{
    int n;
    for(n = 0;w;n++) 
        w = w->next;
    return n;
}
@
%ocaml: List.length


<<function [[copynwords]]>>=
word*
copynwords(word *a, word *tail, int n)
{
    word *v = nil;
    word **end = &v;
    
    while(n-- > 0){
        *end = newword(a->word, 0);
        end = &(*end)->next;
        a = a->next;
    }
    *end = tail;
    return v;
}
@

<<function [[copywords]]>>=
/*
 * copy arglist a, adding the copy to the front of tail
 */
word*
copywords(word *a, word *tail)
{
    word *v = nil;
    word **end;

    for(end=&v;a;a = a->next,end=&(*end)->next)
        *end = newword(a->word, nil);
    *end = tail;
    return v;
}
@
%ocaml: use gc so copy for free, and just use @ to concat


<<function [[freewords]]>>=
void
freewords(word *w)
{
    word *nw;
    while(w){
        efree(w->word);
        nw = w->next;
        efree((char *)w);
        w = nw;
    }
}
@
%ocaml: use gc


% diff with freewords???
<<function [[freelist]]>>=
void
freelist(word *w)
{
    word *nw;
    while(w){
        nw = w->next;
        efree(w->word);
        efree((char *)w);
        w = nw;
    }
}
@


\subsection{[[List]] of lists of words}

<<struct [[List]]>>=
struct List {
    // list<ref_own<Word>> (next = Word.next)
    word *words;

    // Extra
    list *next;
};
@
% so it's actually a list of list (so fast concatenation?)







\section{[[Var]]iables}
%  and [[gvar]]

% saw local vars in Thread before.

% what need vars for?
% when do X=1 in shell.
% also for setting status of special variable like "status".

<<struct [[Var]]>>=
struct Var {
    // key
    char	*name;		/* ascii name */
    // value
    word	*val;		/* value */

    <<[[Var]] other fields>>
    // Extra
    <<[[Var]] extra fields>>
};
@
% when have local vars? when need that?

<<[[Var]] extra fields>>=
var	*next;		/* next on hash or local list */
@
% #define V (struct Var*)nil
% like for other soft, or use VarNil?



<<function [[setvar]]>>=
void
setvar(char *name, word *val)
{
    struct Var *v = vlook(name);
    freewords(v->val);
    v->val = val;
    v->changed = true;
}
@
% changed is for optimization reason to avoid rewriting in /env/xxx


<<function [[vlook]]>>=
var*
vlook(char *name)
{
    var *v;
    if(runq)
        for(v = runq->local;v;v = v->next)
            if(strcmp(v->name, name)==0) 
                return v;

    return gvlook(name);
}
@
% use global runq again
% look for locals first, then gvlook
% cases where runq is empty? call vlook very early?




<<constant [[NVAR]]>>=
#define	NVAR	521
@

<<global [[gvar]]>>=
// map<string, ref_own<Var>> (next = Var.next in bucket list)
var *gvar[NVAR];		/* hash for globals */
@
% vs locals
%ocaml: use Hashtbl


% populate if not already there
<<function [[gvlook]]>>=
var*
gvlook(char *name)
{
    int h = hash(name, NVAR);
    var *v;

    for(v = gvar[h];v;v = v->next) 
        if(strcmp(v->name, name)==0) 
            return v;
    gvar[h] = newvar(strdup(name), gvar[h]);
    return gvar[h];
}
@
%old: return gvar[h] = newvar(strdup(name), gvar[h]);

<<function [[hash]]>>=
unsigned
hash(char *as, int n)
{
    int i = 1;
    unsigned h = 0;
    uchar *s;

    s = (uchar *)as;
    while (*s)
        h += *s++ * i++;
    return h % n;
}
@


<<function [[newvar]]>>=
var*
newvar(char *name, var *next)
{
    var *v = new(var);
    v->name = name;
    v->val = nil;

    v->fn = nil;
    v->changed = false;
    v->fnchanged = false;

    v->next = next;
    return v;
}
@
% changed and fnchanged are for optimization reason, to try
% to avoid writing in /env/xx when no need

% special variable, e.g. vlook("home"), vlook("*")








\chapter{[[main()]]}
\label{chap:main}


\section{Overview}

<<[[main()]] locals>>=
code bootstrap[17];
@
% indeed 17 lines below about bootstrap. A bit ugly though

% see Chapter X for actual boostrap. I will simplify for now.

% mv comment back in Extra? less confusing with actual bootstrap vs simple one
%/*
% * get command line flags.
% * initialize keywords & traps.
% * get values from environment.
% * set $pid, $cflag, $*
% * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)
% * start interpreting code
% */

<<function main (rc/exec.c)>>=
void main(int argc, char *argv[])
{
    <<[[main()]] locals>>

    <<[[main()]] argc argv processing, modify flags>>

    <<[[main()]] initialisation>>
    <<[[main()]] initialize [[boostrap]]>>
    <<[[main()]] initialize runq with bootstrap code>>
    <<[[main()]] initialize runq->argv>>

    <<[[main()]] interpreter loop>>
}
@

\section{Command-line arguments processing}
% [[getflags()]]


<<global [[flag]]>>=
// map<char, option<array<string>>>
char **flag[NFLAG];
@
%could transform global flag in bool flag[NFLAG] ?
% no cos other places use flags for -m where except elements after
% But need array of elements?
% maybe would need just string, but getflags is generic library probably.
%ocaml: use Arg

<<constant [[NFLAG]]>>=
#define	NFLAG	128
@
% #chars in ASCII

% =~ true (a bit ugly)
<<global [[flagset]]>>=
char *flagset[] = {"<flag>"};
@

<<[[main()]] argc argv processing, modify flags>>=
argc = getflags(argc, argv, "SsrdiIlxepvVc:1m:1[command]", 1);
if(argc==-1)
    usage("[file [arg ...]]");
@
% getflags() defined in Appendix.
%-d and -p are actually dead
%ocaml: Arg is cleaner than this getflags where everything needs to be
% an array of string, even a boolean flag.

% usage is generic, part of getflags.c (use global to remember
%  format passed to getflags?)

% so c:1 so -c except one argument.
% same for -m.


% when do  sh foo.sh <some arguments>
% can we have conflicts in some arguments with flags that sh would
% interpret?

\subsection{Login mode: [[rc -l]]}
% or nothing but - in argv0

<<[[main()]] argc argv processing, modify flags>>=
if(argv[0][0]=='-')
    flag['l'] = flagset;
@
% if -l or first char is - then means login shell.
% so read $home/lib/profile

\subsection{Interactive mode: [[rc -i]]}
% or nothing but can detect Isatty

% mv later? advanced feature? hmm interactive is important notion.
<<[[main()]] argc argv processing, modify flags>>=
if(flag['I'])
    flag['i'] = nil;
else 
    if(flag['i']==nil && argc==1 && Isatty(STDIN)) 
       flag['i'] = flagset;
@

% interactive mode if no arguments!

<<function [[Isatty]]>>=
bool
Isatty(fdt fd)
{
    char buf[64];

    if(fd2path(fd, buf, sizeof buf) != 0)
        return false;

    /* might be #c/cons during boot - fixed 22 april 2005, remove this later */
    if(strcmp(buf, "#c/cons") == 0)
        return true;

    /* might be /mnt/term/dev/cons */
    return strlen(buf) >= 9 && strcmp(buf+strlen(buf)-9, "/dev/cons") == 0;
}
@

%chunks:
% far more flags presented gradually

\section{Initialization}

% put back global err here, with its Io type?

<<[[main()]] initialisation>>=
err = openfd(STDERR);
@
% err = openfd, use buffered IO lib, see appendix for error management.
%ocaml: stderr already use buffered IO.

<<[[main()]] initialisation>>=
kinit();    // initialize keywords
Trapinit(); // notify() function setup
Vinit();    // read environment variables and add them in gvar
@
%ocaml: kinit -> use ocamlllex


\section{Bootstrapping bytecodes (simplified)}

\ifallcode
<<[[main()]] locals>>=
int i;
@
\fi


% simplified bootstrap:
% Xrdcmds (which will call yyparse()->compile()->outcode()
%  which will read a line, compile it, and add a Xreturn
%when want to experiment with simplified bootstrap
% (don't forget to also modify mkfile and put 'rc2' for TARG
%OPTIONAL
<<[[main()]] initialize [[boostrap]]XXXXX>>=
memset(bootstrap, 0, sizeof bootstrap);

i = 0;
bootstrap[i++].i = 1; // reference count
bootstrap[i++].f = Xrdcmds;
bootstrap[i].i = 0;
@
%bootstrap[i++].f = XMark; ? necessary?
%bootstrap[i++].f = Xexit; ? Xexit never reached I think.
% 1 to reference count? why? they put 0 in compile() for new bytecodes
%ocaml: no need end of list, no need reference count

\section{Setting [[runq]]}
% [[start()]]

<<[[main()]] initialize runq with bootstrap code>>=
start(bootstrap, 1, (var *)nil);
@
% starts at 1; 0 is for the reference count

% modify runq! usually called with pc = 1
% main | Xrdcmds | ??? -> <>
<<function [[start]]>>=
void
start(code *c, int pc, var *local)
{
    struct Thread *p = new(struct Thread);

    p->code = codecopy(c);
    p->pc = pc;

    p->argv = nil;
    p->local = local;

    p->cmdfile = nil;
    p->cmdfd = nil;
    p->lineno = 1;
    p->eof = false;
    p->iflag = false;

    <<[[start()]] set redir>>

    // add_stack(runq, p)
    p->ret = runq;
    runq = p;
}
@
% not reset iflast to false?
\t maybe should call it new_thread() because it does not
\t  start it right away, and should do the add_stack in the caller.
%ocaml: I renamed it mk_thread and do runq := t::!run in the caller. clearer.

% called sometimes with pc different of 1? yes, for async, trap,
%  pipe, etc.

% will go back to previous Thread (put in runq stack) if
% the new code does some Xreturn.
% So idea of subcomputation. With then fresh argv, fresh code list.

% When call start()? main, Xrdcmds. Xrdcmds is really
% a read/eval/print loop.

% very first time runq should be nil so p->ret points to nil.

\section{Setting [[runq->argv]]}

% now that runq set.

<<global [[argv0]]>>=
/*
 * Start executing the given code at the given pc with the given redirection
 */
char *argv0="rc";
@
% used by? it is override below, but used by what after?

<<[[main()]] initialize runq->argv>>=
/* prime bootstrap argv */
pushlist();
argv0 = strdup(argv[0]);
for(i = argc-1; i!=0; --i) 
    pushword(argv[i]);
@
% start from end because list/stack so at the end the top of the stack will
% be the first argument of the command
% does getflags consume argv and argc? Yes! so push only non flags
%ocaml: no need to call pushlist() here. Already have working argv.
% no nil in OCaml!

% so runq->argv is populated, and as you will see later,
% bootstrap code assign it in $*!


% see pushlist() below

% this list is actually manipulatd by Xmark, etc
% so runq->argv is the argument to the bytecodes, not just
% to the simple command (but actually simple commands become
% Xsimple so this bytecode look at runq->argv)

% main | Xmark ->  <>
<<function [[pushlist]]>>=
void
pushlist(void)
{
    list *p = new(list);

    // add_list(p, runq->argv)
    p->next = runq->argv;
    p->words = nil;
    runq->argv = p;
}
@
% use runq, assume runq not nil! otherwise segfault


<<function [[pushword]]>>=
void
pushword(char *wd)
{
    if(runq->argv==nil)
        panic("pushword but no argv!", 0);
    runq->argv->words = newword(wd, runq->argv->words);
}
@
% use global runq
% note that newword take the old value of the list so indeed
%  it adds wd in the list of words.
%ocaml: no need for panic, argv always at least empty list


\section{Bytecode interpreter loop}

<<[[main()]] interpreter loop>>=
for(;;){
    <<[[main()]] debug runq in interpreter loop>>

    runq->pc++;
    (*runq->code[runq->pc-1].f)();

    <<[[main()]] handing trap if necessary in interpreter loop>>
}
@
%ocaml: how sure that a function? not typesafe.


\section{The REPL: [[Xrdcmds()]]}
% X(bytecode) read commands

% Xrdcmds =~ REPL, 
%  read (yylex+yyparse),
%  eval (compile+outcode+return to interpreter)
%  print? hmm partly in yylex for the prompt, the rest the program does it
%  loop? kinda because do a pc-- below so do its own loop
%  inside the enclosing interpreter loop

% should be called Xrdline though.
<<function [[Xrdcmds]]>>=
void
Xrdcmds(void)
{
    struct Thread *p = runq;
    bool error;
    <<[[Xrdcmds()]] other locals>>

    <<[[Xrdcmds()]] flush errors and reset error count>>
    <<[[Xrdcmds()]] print status if -s>>
    <<[[Xrdcmds()]] set promptstr if interactive mode>>

    <<[[Xrdcmds()]] calls Noerror() before yyparse()>>
    // read one cmd line, compiles it, and modifies codebuf global
    error = yyparse();

    <<[[Xrdcmds()]] if yyparse() returned an error>>
    else{
        <<[[Xrdcmds()]] reset ntrap>>
        --p->pc;	/* re-execute Xrdcmds after codebuf runs */
        // modifies runq, new thread (linked to bootstrap one)
        start(codebuf, 1, runq->local);
    }
    freenodes(); // allocated in yyparse()
}
@
% will go back to Xrdcmds because of the Xreturn inserted in
% the codebuf by compile()
%ocaml: ugly: use some globals everywhere. treenodes, codebuf
% so here yyparse call internally compile that modifies codebuf, but hard to see

\l pass local so share ? so after execute a line, the parent
\l  thread has its local modified too.

% flow a bit complicated, but
% interpreter loop on runq->code -> Xrdcmds() -> yyparse() -> start(codebuf)
%  will go back in loop with a new runq! and once the command is done
%  with a Xreturn it will resume to Xrdcmds runq (the bootstrap queue)
%  and because of the --p->pc, it will restart on the Xrdcmds


% yyparse() use runq global, and special additional fields:
% (actually it's yylex())

<<[[Thread]] other fields>>=
struct Io *cmdfd;	/* file descriptor for Xrdcmd */
char *cmdfile;		/* file name in Xrdcmd */
bool iflag;		/* interactive? */
@
% who sets cmdfd? see below.

%OPTIONAL (really?)
<<[[main()]] initialize runq with bootstrap code>>=
runq->cmdfd = openfd(STDIN); // reading from stdin
runq->cmdfile = "<stdin>";
runq->iflag = flag['i']? true : false;// interactive mode; will print a prompt
@
% eof set to false in start()
% cmdfile setting is not necessary, but it's used in yyerror() so why not set it

% for iflag, why not always use global? why need an extra field?
%  someone can alter iflag?

% those fields can be changed when do '.' ? to source a script?
% or when -c ? This is why they are fields and not globals?

% note that start() reset those fields.

% where cmdfd is used? in yylex() getnextc(), called from yyparse()


% when execute a script, cmdfd is the fd for the script, but not
% that yyparse still parse one line at a time, and so Xrdcmds
% will read one line, compile it, execute, and then go to other line.
% Also means that if modify script while running, might have weird
% behavior.

%XXX
% C-d generates an EOF?
<<[[Xrdcmds()]] if yyparse() returned an error>>=
if(error){
    if(!p->iflag  ||  p->eof && !Eintr()){
        if(p->cmdfile)
            efree(p->cmdfile);
        closeio(p->cmdfd);

        Xreturn();	/* should this be omitted? */
    }else{
        if(Eintr()){
            pchr(err, '\n');
            p->eof = false;
        }
        --p->pc;	/* go back for next command */
    }
}
@
% mv later?

% Xreturn does something special? 

% no error reporting? or rely on yyerror also called by yyparse? 



\chapter{Input}
\label{chap:input}
% so Lexing chapter cleaner

\section{Overview}

% main -> Xrdcmds -> yyparse() -> yylex() -> nextc() -> getnextc() 
%  which use runq->cmdfd to read stuff.


\section{Reading a character: [[getnext()]]}

% why return an int and not a char? because unicode? then use Rune!
% yylex -> nextc -> <>
<<function [[getnext]]>>=
/*
 * read a character from the input stream
 */	
int
getnext(void)
{
    int c;
    <<[[getnext()]] other locals>>

    <<[[getnext()]] peekc handling>>
    <<[[getnext()]] return if already at EOF>>
    <<[[getnext()]] prompt management before reading the character>>

    c = rchr(runq->cmdfd);

    <<[[getnext()]] handle backslash>>
    <<[[getnext()]] prompt management after the character is read>>
    <<[[getnext()]] if character read is EOF>>
    <<[[getnext()]] if not EOF but verbose mode, print character read>>

    return c;
}
@
%old: was runq->eof++; ugly

% rchr() in annex? bufio library?



\subsection{End-of-file management}

<<constant EOF (rc/io.h)>>=
#define	EOF	(-1)
@
% possibly returned by rchr()

<<[[getnext()]] if character read is EOF>>=
if(c==EOF)
    runq->eof = true;
@
%ocaml: not sure we need this.

<<[[Thread]] other fields>>=
bool eof;		/* is cmdfd at eof? */
@
% used for? for next getnext(), but otherwise?


<<[[getnext()]] return if already at EOF>>=
if(runq->eof)
    return EOF;
@

%ocaml: ocamllex handles that already?

\subsection{Multi-lines and backslash}
% more on newlines later.

% if backslash, dont return backslash char, return after
% but only if not in a string, hence the !inquote guard below.

<<[[getnext()]] handle backslash>>=
if(!inquote && c=='\\'){

    c = rchr(runq->cmdfd);

    if(c=='\n' && !incomm){		/* don't continue a comment */
        <<[[getnext()]] when backslash and newline, set doprompt>>
        c=' ';
    }
    else{
        peekc = c;
        c='\\';
    }
}
@
% need to look ahead to see if \\\n, so if was not \n, then
% return backslash and go back in input stream.
% but do that via peekc technique. Classic.

%ocaml: ocamllex does the longest match and handle peek internally I think

<<[[getnext()]] other locals>>=
static int peekc = EOF;
@

<<[[getnext()]] peekc handling>>=
if(peekc!=EOF){
    c = peekc;
    peekc = EOF;
    return c;
}
@



\subsection{Displaying the prompt}

% so $prompt is actually a 2 words list, first word = original
% and second word when it's a multiline command?

<<global [[doprompt]]>>=
bool doprompt = true;
@
% set to true by default! so first time run rc, will
% get a prompt.

% could be moved in another section?
<<global [[promptstr]]>>=
char *promptstr;
@

<<[[Xrdcmds()]] other locals>>=
word *prompt;
@
<<[[Xrdcmds()]] set promptstr if interactive mode>>=
if(runq->iflag){
    prompt = vlook("prompt")->val;
    if(prompt)
        promptstr = prompt->word;
    else
        promptstr="% ";
}
@



<<[[getnext()]] prompt management before reading the character>>=
if(doprompt)
    // pprompt() internally set doprompt back to false at the end
    pprompt();
@
% remember that set to true in global at startup.
% so first character read we will get a prompt.

<<function [[pprompt]]>>=
void
pprompt(void)
{
    var *prompt;

    if(runq->iflag){
        // printing the prompt
        pstr(err, promptstr);
        flush(err);

        // set promptstr for the next pprompt()
        prompt = vlook("prompt");
        if(prompt->val && prompt->val->next)
            promptstr = prompt->val->next->word;
        else
            promptstr="\t";
    }
    runq->lineno++;
    doprompt = false;
}
@
% ?? why not % for the prompt? why changing the promptstr here?
% when multiline command! enter if(ls) ENTER => get a \t prompt
%ocaml: maybe a bit ugly to couple the prompt stuff and lineno.

% note that print prompt on stderr

% flush cos no newline in prompt but still want it displayed ASAP.

% if enter {, then also special prompt indent (but just one level,
% does not handle more depth)

% so can display in prompt which command we are. useful also for history?
% to run a past command?
<<[[Thread]] other fields>>=
int lineno;			/* linenumber */
@
% useful for error reporting I think, when running a script!


<<[[getnext()]] prompt management after the character is read>>=
doprompt = doprompt || c=='\n' || c==EOF;
@
% doprompt case before because when \\n then c becomes space
%  but still want the doprompt and indeed doprompt is set in backslash
%  code handling
%ocaml: can do that in lexer?

% do that also for EOF so once parsed a script, and goes back
% to Xrdcmds loop, the next getc will print a prompt


<<[[getnext()]] when backslash and newline, set doprompt>>=
doprompt = true;
@


\section{Looking ahead: [[nextc()]] and [[advance()]]}

<<global [[future]]>>=
int future = EOF;
@
%ocaml: let ocamllex handles that

% yylex | advance | skipnl | nextis -> <>
<<function [[nextc]]>>=
/*
 * Look ahead in the input stream
 */
int
nextc(void)
{
    if(future==EOF)
        future = getnext();
    return future;
}
@
% future and peekc??
% so return same char until call advance().
% So can call nextc() from multiple places. nextc() acts then
% like a global.

% note that calls getnext()! so anything consuming a new character
%  will get all the backslash and doprompt logic.

% nextis -> <>
<<function [[advance]]>>=
/*
 * Consume the lookahead character.
 */
int
advance(void)
{
    int c = nextc();
    <<[[advance()]] save future in lastc>>
    future = EOF;
    return c;
}
@


% yylex -> <>
<<function [[nextis]]>>=
bool
nextis(int c)
{
    if(nextc()==c){
        advance();
        return true;
    }
    return false;
}
@
% check and then consume





\chapter{Lexing}
\label{chap:lexing}

% why not using lex? they like yacc but not lex apparently
% (because lex != flex? or because of multiline editing tricks
% that may be harder to implement with lex?)


\section{[[yylex()]]}

% lots of ugly lexing tricks:
% - newline and skipnl() after some operators
%   but kinda need it
% - keywords are accepted as word after first word
%   on the line is parsed (via grammar)
% - SUB vs (
%   function def or call vs array subscript
% - special handling of [] after redirection and
%   parsing and AST building inside lexer (hmmm)

<<function [[yylex]]>>=
//@Scheck: called from yyparse()
int yylex(void)
{
    int c;
    <<[[yylex()]] other locals>>

    <<[[yylex()]] hack for SUB>>
    <<[[yylex()]] initialisations>>

    skipwhite();

    switch(c = advance()){
    <<[[yylex()]] switch c cases>>
    }
    // else
    <<[[yylex()]] if c is not a word character>>
    // else
    <<[[yylex()]] if c is a word character>>
}
@
%$
%todo:    // lastdol = false; factorize code?


% word character
<<function [[wordchr]]>>=
int
wordchr(int c)
{
    return !strchr("\n \t#;&|^$=`'{}()<>", c) && c!=EOF;
}
@
%$

% slash allowed here. A word can be a filename (e.g., path of a command
% /bin/ls, arg to a command /mnt, etc)


% identifier character
<<function [[idchr]]>>=
int
idchr(int c)
{
    /*
     * Formerly:
     * return 'a'<=c && c<='z' || 'A'<=c && c<='Z' || '0'<=c && c<='9'
     *	|| c=='_' || c=='*';
     */
    return c > ' ' && !strchr("!\"#$%&'()+,-./:;<=>?@[\\]^`{|}~", c);
}
@
%$
% slash not allowed here



<<[[yylex()]] switch c cases>>=
case EOF:
    lastdol = false;
    strcpy(tok, "EOF");
    return EOF;
@

<<global [[tok]]>>=
char tok[NTOK + UTFmax];
@
% why need that? can not store in yylval? just for debugging?
<<constant [[NTOK]]>>=
#define	NTOK	8192		/* maximum bytes in a word (token) */
@


\section{Spaces and comments ([['#']])}

<<global [[incomm]]>>=
bool incomm;
@
% global used also by getnext (<- nextc), because semantic of \
% is different when inside a comment

<<function [[skipwhite]]>>=
void
skipwhite(void)
{
    int c;
    for(;;){
        c = nextc();
        /* Why did this used to be  if(!inquote && c=='#') ?? */
        if(c=='#'){
            incomm = true;
            for(;;){
                c = nextc();
                if(c=='\n' || c==EOF) {
                    incomm = false;
                    break;
                }
                advance();
            }
        }
        if(c==' ' || c=='\t')
            advance();
        else 
            return;
    }
}
@
%could be a switch? clearer

% remember that nextc() does not advance. so basically like
% access a global next_character.


\section{Newlines}

% will be covered by general code later returning single
% char.

% subtle! called from grammar, weird
% normally newlines marks the end of a command line to be processed.
% but when use |, &&, ||, it is common to enter a newline
% but this newline should be considered a whitespace to skip.
% But sometimes not. So sometimes in the lexer
% there are calls to skipnl to consume those whitespace and newlines

% Do that when knows a newline can not terminate a command because
% we are waiting for something else, for instance with binary operators
% like ||, &&, even |.
% We dont want the next newline to be derived as empty command

<<function [[skipnl]]>>=
void
skipnl(void)
{
    int c;
    for(;;){
        skipwhite();
        c = nextc();
        if(c!='\n')
            return;
        // consume the newline
        advance();
    }
}
@
% lineno incremented correctly here? yes cos 
%   skipnl -> nextc -> getnextc -> pprompt
%alt: use a 'newlines_opt' in the grammar?

% note that in a loop, so will accept multiple empty lines
% until non whitespace character

\section{Operators (e.g., [['&']])}


<<[[yylex()]] switch c cases>>=
case '&':
    lastdol = false;
    if(nextis('&')){
        skipnl();
        strcpy(tok, "&&");
        return ANDAND;
    }
    strcpy(tok, "&");
    return '&';
@
% skipnl? so newline after && is not considered a command terminator.
% lexer trick again.




<<[[yylex()]] switch c cases>>=
case '$':
    lastdol = true;
    if(nextis('#')){
        strcpy(tok, "$#");
        return COUNT;
    }
    if(nextis('"')){
        strcpy(tok, "$\"");
        return '"';
    }
    strcpy(tok, "$");
    return '$';
@
%$
% what is dollar and quote after?

<<global [[lastdol]]>>=
bool lastdol;	/* was the last token read '$' or '$#' or '"'? */
@
% dol = dollar




<<[[yylex()]] switch c cases>>=
case '|':
    lastdol = false;
    if(nextis('|')){
        skipnl();
        strcpy(tok, "||");
        return OROR;
    }
    // FALLTHROUGH
case '<':
case '>':
    lastdol = false;
    <<[[yylex()]] in switch when redirection character>>
@
% ugly that does some parsing inside lexer. Should be done in grammar.
% he even included a grammar in the comment. hmm



<<[[yylex()]] other locals>>=
char *w = tok;
@
<<[[yylex()]] other locals>>=
struct Tree *t;
@

<<[[yylex()]] initialisations>>=
yylval.tree = nil;
@

<<[[yylex()]] in switch when redirection character>>=
/*
 * funny redirection tokens:
 *	redir:	arrow | arrow '[' fd ']'
 *	arrow:	'<' | '<<' | '>' | '>>' | '|'
 *	fd:	digit | digit '=' | digit '=' digit
 *	digit:	'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
 * some possibilities are nonsensical and get a message.
 */
*w++=c;
t = newtree();
switch(c){
<<[[yylex()]] in switch when redirection character, switch c cases>>
}
<<[[yylex()]] in switch when redirection character, if bracket after>>
*w='\0';
yylval.tree = t;
if(t->type==PIPE)
    skipnl();
return t->type;
@
% ugly to do that in lexer, but then dont want to have [
% as a separate token

\l could put the skipnl() for PIPE before?



% MV LATER, anyway used where?
%an important set of field are for redirection, when type = REDIR
% in which case the kind of redirection is in rtype
<<[[Tree]] redirection and pipe specific fields>>=
//enum<Redirection_kind>
int	rtype;

// For a pipe, fd0 is the left fd of the pipe, and fd1 the right fd.
// For a redirection, fd0 is what we redirect (stdout for >, stdin for <)
// and fd1 is what we possibly redirect to (when DUP).
fdt fd0;
fdt fd1;	/* details of REDIR PIPE DUP tokens */
@
% why need that in every AST nodes? can not encode info via some child?
% has fd0 fd1 because redirection (and pipes) in rc is very general. 
% Can do lots of stuff.
%ocaml: just put that as additional elements in the constructor for Pipe/Redir


<<constant [[WRITE]]>>=
#define	WRITE	2
@
<<constant [[READ]]>>=
#define	READ	3
@
% TODO enum!! redirection_kind?
<<constant [[APPEND]]>>=
#define	APPEND	1
@





<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '|':
    t->type = PIPE;
    t->fd0 = 1; // left fd of pipe (stdout of left cmd)
    t->fd1 = 0; // right fd of pipe (stdin of right cmd)
    break;
@

<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '>':
    t->type = REDIR;
    if(nextis('>')){
        t->rtype = APPEND;
        *w++=c;
    }
    else 
        t->rtype = WRITE;
    t->fd0 = 1;
    break;
@

<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '<':
    t->type = REDIR;
    <<[[yylex()]] in switch when redirection character, if here document>>
    <<[[yylex()]] in switch when redirection character, if read/write redirect>>
    else 
        t->rtype = READ;
    t->fd0 = 0;
    break;
@






<<[[yylex()]] if c is not a word character>>=
if(!wordchr(c)){
    lastdol = false;
    tok[0] = c;
    tok[1]='\0';
    return c;
}
@
% why need set tok? anyway it is a single character here
%  for yyerror? for fn storage?
%ocaml: be explicit and handle each character in lexer

% so newline is handled by this code above.

\section{Quoted strings ([['...']])}


<<global [[inquote]]>>=
bool inquote;
@
% used before already, for getnextc to handle backslash differently
%ocaml: treat backslash differently by using different lexer function

<<[[yylex()]] initialisations>>=
inquote = false;
@


<<global [[lastword]]>>=
// used also by syn.y
bool lastword;	/* was the last token read a word or compound word terminator? */
@
% rename last_tok_was_a_word

<<[[yylex()]] switch c cases>>=
case '\'':
    inquote = true;
    lastword = true;
    lastdol = false;
    for(;;){
        c = advance();
        if(c==EOF)
            break;
        if(c=='\''){
            if(nextc()!='\'')
                break;
            advance();
        }
        w = addutf(w, c);
    }
    if(w != nil)
        *w='\0';

    t = token(tok, WORD);
    t->quoted = true;

    yylval.tree = t;
    return t->type;
@
% classic double '' to represent a quote
%meta, also in C need escape

% addutf in advanced topics, but essentially add character
% and if character start of unicode char, then consume more chars
% first.

<<[[Tree]] word specific fields>>=
bool	quoted;
@
%ocaml: use a pair,  Word of string * bool in AST

% todo: rename tree_of_token?
<<function [[token]]>>=
tree*
token(char *str, int type)
{
    tree *t = newtree();

    t->type = type;
    t->str = strdup(str);
    return t;
}
@


% rc does not use \ to escape?
% so do echo ';'  not echo \;

% in rc no "", no \, less troubles.



\section{Keywords and identifiers (e.g., [[if]])}


<<[[yylex()]] if c is a word character>>=
for(;;){
    <<[[yylex()]] when c is a word character, if glob character>>
    w = addutf(w, c);

    c = nextc();
    if(lastdol ? !idchr(c) : !wordchr(c)) 
        break;
    advance();
}

lastword = true;
lastdol = false;
if(w!=nil)
    *w='\0';

t = klook(tok);
if(t->type != WORD)
    lastword = false;

t->quoted = false;

yylval.tree = t;
return t->type;
@

% after a dollar we accept only idchr.

%old:    if(lastdol ? !idchr(c) : !wordchr(c)) break  if inside if, hmmm
\t rewrite this if, too hard to read




<<function [[klook]]>>=
tree*
klook(char *name)
{
    struct Kw *p;
    tree *t = token(name, WORD);

    for(p = kw[hash(name, NKW)];p;p = p->next)
        if(strcmp(p->name, name)==0){
            t->type = p->type;
            break;
        }
    return t;
}
@
% see token() in Code DS chapter
%dead:       t->iskw = true;
%ocaml: just hashtbl or simple pattern matching

<<struct [[Kw]]>>=
struct Kw {
    char *name;
    int type;

    struct Kw *next;
};
@
%old: was with kw before, but better split type definitions and global decls

<<global [[kw]]>>=
struct Kw *kw[NKW];
@

<<constant [[NKW]]>>=
#define	NKW	30
@




% main() -> kinit()
<<function [[kinit]]>>=
void
kinit(void)
{
    kenter(FOR, "for");
    kenter(IN, "in");
    kenter(WHILE, "while");
    kenter(IF, "if");
    kenter(NOT, "not");
    kenter(SWITCH, "switch");
    kenter(FN, "fn");

    kenter(TWIDDLE, "~");
    kenter(BANG, "!");
    kenter(SUBSHELL, "@");
}
@
%new: I reordered
%ocaml: just use pattern matching

<<function [[kenter]]>>=
void
kenter(int type, char *name)
{
    int h = hash(name, NKW);
    struct Kw *p = new(struct Kw);
    p->type = type;
    p->name = name;
    p->next = kw[h];
    kw[h] = p;
}
@




\section{Array subscript ([[<arr>(<n>)]])}
% and automatic carret

% ( vs SUB. Call? vs array subscript.
% need two tokens otherwise ambiguity in grammar?
% 

<<[[yylex()]] other locals>>=
int d = nextc();
@

<<[[yylex()]] hack for SUB>>=
/*
 * Embarassing sneakiness:  if the last token read was a quoted or unquoted
 * WORD then we alter the meaning of what follows.  If the next character
 * is `(', we return SUB (a subscript paren) and consume the `('. Otherwise,
 * if the next character is the first character of a simple or compound word,
 * we insert a `^' before it.
 */
if(lastword){
    lastword = false;
    if(d=='('){
        advance();
        strcpy(tok, "( [SUB]");
        return SUB;
    }
    if(wordchr(d) || d=='\'' || d=='`' || d=='$' || d=='"'){
        strcpy(tok, "^");
        return '^';
    }
}
@
%$

% what is this ^ ? it's to concatenate word
% when we do foo  -x$flag, we do not want to pass 2 args to foo program
% such as ["-x"; "$flag"].
% we want one single arg that is the result of a concatenation.
% enter ^.

% but right now because we skip whitespace and generate 3 tokens
% (one for '-x', one for '$' which accept comples values, not just
% a direct varname, and one for 'flag')
% there is no way to disambigute between -x $ flag and -x$flag
% hence the implicit caret thing.






\chapter{Parsing}
\label{chap:parsing}

\section{Overview}

% I assume you understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.nw :) )
%(compared to ocamlyacc can have actions in the middle, and those actions
% count as indexable elements for the $xxx numbering ($1, $2, etc))

<<rc/syn.y>>=
%{
#include "rc.h"
#include "fns.h"
%}

%union {
 struct Tree *tree;
};

<<token declarations>>
<<priority and associativity declarations>>
<<type [[declarations]]>>

%%
<<grammar>>
@

% for syncweb -to_tex
<<function [[yyparse]]>>=
... generated code from syn.y by yacc ...
@

 
<<priority and associativity declarations>>=
/* operator priorities -- lowest first */
%left IF WHILE FOR SWITCH ')' NOT
%left ANDAND OROR
%left BANG SUBSHELL
%left PIPE
%left '^'
%right '$' COUNT '"'
%left SUB
@

% why right for $? anyway when do $$A semantic? no ambiguity
% dont want (($ $) A) want ($ ($ A))


<<type [[declarations]]>>=
%type<tree> line cmd simple word comword
@

% comword for command word?

%less: rename? cmd -> statement, simple -> expression, word -> argument?

<<grammar>>=
rc: 
    /*empty*/       { return ERROR_1;}
|   line '\n'       { return !compile($1);}

<<line rule>>
<<cmd rule>>
<<simple rule>>

<<word rule>>
<<comword rule>>

<<other rules>>
@
%$

% empty case is when EOF?

% if compile() return 0 it's an error, so here 1 = an error
% TODO: be more consistent, return compile() would be cleaner so no need
%  explanation
% Xrdcmds -> yyparse() ?

% newline has a semantic here!

% interesting DSL. must be easy to issue a command.
% don't want to do 'system("ls");' like in other languages.
% and want newline to have a special semantic role, a kind of implicit ';'
% but also want to have multiline statements ... so newline must be allowed
%  and not run the command sometimes.
% -xxx, /a/b, are treated as regular words! only ;&${[^ are specials







\ifallcode
<<type [[declarations]]>>=
%type<tree> first keyword words
%type<tree> paren brace body cmdsa cmdsan assign epilog redir
%type<tree> FOR IN WHILE IF NOT SWITCH FN
%type<tree> TWIDDLE BANG SUBSHELL  REDIR DUP PIPE    WORD
@
\fi

\ifallcode
<<constant [[YYMAXDEPTH]]>>=
//@Scheck: used in y.tab.c
#define	YYMAXDEPTH	500
@

%pad: put here just to please syncweb -to_tex
<<rc/x.tab.h>>=
@

\fi


\section{Simple commands ([[<cmd> <arg1>...<argn>]]) }

% a line can have a single command (stmt)
<<line rule>>=
line:   
    cmd
<<line rule other cases>>
@
% can have ; and & here (why not in cmd? because newline issue?)

% a (single) command can be a simple "expression"
<<cmd rule>>=
cmd: 
    /*empty*/           {$$=nil;}
|   simple              {$$=simplemung($1);}
<<cmd rule other cases>>
@
%$
% can have complex stmt here

% simplemung() shown below later.
% "mung" means destructive update.

% an expression can be a "progcall" which is a simple serie of words
% (separated by spaces, curry style :) )
% with first word has some restrictions (the "function" name)
<<simple rule>>=
simple:
    first
|   simple word         {$$=tree2(ARGLIST, $1, $2);}
<<simple rule other cases>>
@
% can have redirection here in the other cases

% actually first can correspond to a progran, or a function, or a builtin.





<<other rules>>=
first:  
    comword 
|   first '^' word      {$$=tree2('^', $1, $3);}
@
% diff with word? first cannot be a keyword !!!


% basic identifier, a kind of primary expression
% -xxx, /a/b, are treated as regular words
<<comword rule>>=
comword: 
    WORD
<<comword rule other cases>>
@
% can have variables $XX and other complex arguments in other cases
% can have some kind of redirection also in other cases (??)


% a word can be any identifier or symbol or integer (WORD)
<<word rule>>=
word:   
    comword
|   word '^' word       {$$=tree2('^', $1, $3);}
|   keyword             {lastword=true; $1->type=WORD;}
@
%$

% keyword is ok after the first word and transformed as a WORD.
%ocaml: ugly? but true that you dont know which argument you gonna
% pass to some commands

<<other rules>>=
keyword: FOR|IN|WHILE|IF|NOT|TWIDDLE|BANG|SUBSHELL|SWITCH|FN
@


<<other rules>>=
words: 
    /*empty*/       {$$=(struct Tree*)nil;}
|   words word      {$$=tree2(WORDS, $1, $2);}
@
%$
% used for ~ word words




<<function [[simplemung]]>>=
/*
 * Add a SIMPLE node at the root of t and percolate all the redirections
 * up to the root.
 */
//@Scheck: used by syn.y
tree* simplemung(tree *t)
{
    tree *u;
    struct Io *s;

    t = tree1(SIMPLE, t);

    s = openstr();
    pfmt(s, "%t", t);
    t->str = strdup((char *)s->strp);
    closeio(s);

    <<[[simplemung()]] percolate redirections up to the root>>
    return t;
}
@
% saw ARGLIST above
%ocaml: build directly AST

\t why store string in t->str?? who will uses that anyway?

<<[[simplemung()]] percolate redirections up to the root>>=
for(u = t->child[0]; u->type==ARGLIST; u = u->child[0]){
    if(u->child[1]->type==REDIR || u->child[1]->type==DUP){
        u->child[1]->child[1] = t;
        t = u->child[1];
        u->child[1] = nil;
    }
}
@
%ocaml: maybe should have redirection allowed only at the end?
% so then easy to put it also at the root of the AST.


% when do  ls /tmp/x > foo < bar /tmp/y
% then want to transform in   (> foo (< bar (ls /tmp/x /tmp/y))) in AST


\section{Operators}

% actually operators are at different levels, line rule, cmd rule,
% simple rule and so have different priotities.
% redirection is lower, then pipe and logic operators, then sequence

\subsection{Sequence (e.g., [[';']])}

<<line rule other cases>>=
|   cmdsa line      {$$=tree2(';', $1, $2);}
@

<<other rules>>=
cmdsa:  
    cmd ';'
|   cmd '&'         {$$=tree1('&', $1);}
@
%$
% separator, not terminator. Newline is the terminator

% cmdsa = command sequence or and

% x & y is really (x&); y

% newline is also a form of sequence when in the body { } of something

\subsection{Logical operators  (e.g., [['&&']])}
% Other operators?
% && ||  |  &  !?
% >> << > <

<<cmd rule other cases>>=
|   cmd ANDAND cmd      {$$=tree2(ANDAND, $1, $3);}
|   cmd OROR cmd        {$$=tree2(OROR, $1, $3);}
@
% why not merge with ; and & ?

% when argument of if/while in general
<<cmd rule other cases>>=
|   BANG cmd            {$$=mung1($1, $2);}
@
% could also just do tree2(BANG, $2) I think



% redir is in simple/expr, so has more prirority


<<function [[mung1]]>>=
//@Scheck: used by syn.y
tree* mung1(tree *t, tree *c0)
{
    t->child[0] = c0;
    return t;
}
@
%ocaml: build directly


<<function [[mung3]]>>=
//@Scheck: used by syn.y
tree* mung3(tree *t, tree *c0, tree *c1, tree *c2)
{
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@
%ocaml: build directly

\subsection{String matching  (\texttt{'\textasciitilde'})}

% Fundamental type is list of string. No int, no float, just strings.
% So fundamental operator is string matching ~.
% Can be used for arithmetic too,  if(~ $#xxx 0)


<<cmd rule other cases>>=
|   TWIDDLE word words  {$$=mung2($1, $2, $3);}
@
%$

<<function [[mung2]]>>=
//@Scheck: used by syn.y
tree* mung2(tree *t, tree *c0, tree *c1)
{
    t->child[0] = c0;
    t->child[1] = c1;
    return t;
}
@
%ocaml: build directly

\subsection{Pipe  ([['|']])}

<<cmd rule other cases>>=
|   cmd PIPE cmd        {$$=mung2($2, $1, $3);}
@
%$

% what if second cmd derives the EmptyCommand?

\subsection{Redirections  (e.g., [['>']])}

% at level of simple, below cmd, so higher prio than ||, &&, ;, etc
<<simple rule other cases>>=
|   simple redir        {$$=tree2(ARGLIST, $1, $2);}
@
% means can have multiple redir, ls < foo > bar, but after the funcall!
% means also that can have extra arguments still after the redir (ugly)

% ARGLIST but will be percolated back to the root in simplemung()

<<other rules>>=
redir:  
    REDIR word      {$$=mung1($1, $1->rtype==HERE ? heredoc($2) : $2);}
<<redir rule other cases>>
@



% other redirections!
% XXX?
<<cmd rule other cases>>=
|   brace epilog        {$$=epimung($1, $2);}
@
%ocaml: why not have just  simple: brace, like 
% in expression where primary_expr can derive paren expr.
% because does not work, because would allow
% brace redir word.
% but what is this word after brace? an argument to what?



<<other rules>>=
epilog: 
    /*empty*/           {$$=nil;}
|   redir epilog        {$$=mung2($1, $1->child[0], $2);}
@
%$

<<function [[epimung]]>>=
//@Scheck: used by syn.y
tree* epimung(tree *comp, tree *epi)
{
    tree *p;
    if(epi==0)
        return comp;
    for(p = epi;p->child[1];p = p->child[1]);
    p->child[1] = comp;
    return epi;
}
@



% infix style
<<cmd rule other cases>>=
|   redir cmd  %prec BANG
        {$$=mung2($1, $1->child[0], $2);}
@
%$
% really need to support that?
%ocaml: do not support that

\section{Control flow statements (e.g., [[if]])} 

<<cmd rule other cases>>=
|   IF paren {skipnl();} cmd  {$$=mung2($1, $2, $4);}
|   IF NOT   {skipnl();} cmd  {$$=mung1($2, $4);}

|   WHILE paren {skipnl();} cmd    {$$=mung2($1, $2, $4);}
|   SWITCH word {skipnl();} brace  {$$=tree2(SWITCH, $2, $4);}

 /*
  * if ``words'' is nil, we need a tree element to distinguish between 
  * for(i in ) and for(i), the former being a loop over the empty set
  * and the latter being the implicit argument loop.  so if $5 is nil
  * (the empty set), we represent it as "()".  don't parenthesize non-nil
  * functions, to avoid growing parentheses every time we reread the
  * definition.
  */
|   FOR '(' word IN words ')' {skipnl();} cmd
    {$$=mung3($1, $3,    $5 ? $5 : tree1(PAREN, $5), $8);}

|   FOR '(' word ')' {skipnl();} cmd
    {$$=mung3($1, $3, (struct Tree *)0, $6);}
@
% why IF NOT? Why not simply ELSE? just to indicate that this thing is
% fishy. See rc(1) note about it.
% Also normally else requires lookahead but "the shell cannot afford
%  to do lookahead since it is an interactive language"
% It has to process  if(...) cmd NEWLINE.
% It can not wait to check if there is an else (anyway it can
% already proceed). But then else is really another separate command,
% hence the special indication.

% for(x) iterate over $*
% can do before *=`{ ... } for instance

<<other rules>>=
paren:  '(' body ')'        {$$=tree1(PCMD, $2);}
@
%$

<<token declarations>>=
%token PCMD
@
% but really like brace for semantic.
% but different from parens inside the For where it is a list of things then.
% Also use different token so when pretty print the tree get the
%  right syntax.


<<other rules>>=
brace:  '{' body '}'        {$$=tree1(BRACE, $2);}
@
%$



% so multiline, or ;
% so first language using vertical layout :) not haskell :)
<<other rules>>=
body:   
    cmd
|   cmdsan body     {$$=tree2(';', $1, $2);}

cmdsan: 
    cmdsa
|   cmd '\n'
@
%$
% cmd sequence or and or newline





\section{Functions ([[fn]])}

<<cmd rule other cases>>=
|   FN words brace  {$$=tree2(FN, $2, $3);}
|   FN words        {$$=tree1(FN, $2);}
@
%$
% words? fn with multiple words? can define alias on the same line?
%ocaml: could be at line level? also why allow words here?

% second line is for delfn. if type
% fn foo   without anything, then means delete the function.

\section{Variables ([[<x> = ...]])}

% definitions

<<cmd rule other cases>>=
|   assign cmd %prec BANG   
      {$$=mung3($1, $1->child[0], $1->child[1], $2);}
@
% just add cmd as third child of =
% remember that cmd can be empty. In fact, if empty the semantic
% of the assignment changes. The binding is not just for the current command.

% why this syntax? why before?
% Bourne says that cc, make have x=y in its argument, so have to
% do assign before cmd.

% explain %prec?
% if remove it then get ambiguity with cmd && cmd.
%60: shift/reduce conflict (shift 51, reduce 22) on TAndAnd
%60: shift/reduce conflict (shift 52, reduce 22) on TOrOr
%60: shift/reduce conflict (shift 53, reduce 22) on TPipe
%state 60
%	cmd : cmd . TAndAnd cmd  (9)
%	cmd : cmd . TOrOr cmd  (10)
%	cmd : cmd . TPipe cmd  (13)
%	cmd : assign cmd .  (22)

% how parse:   X=1 ls && echo done ??
%  as   (X=1 ls) && echo done
%  or   X=1 (ls && echo done)
% ?
% with %prec BANG, it says to use priority of BANG
%  (between AndAnd and the Pipe)
% so probably get different results if operator is pipe or &&.
% ugly.


% A=1 ls


% what if do A='*'
% and then  echo $A
% will you get the glob?
% bash does?

% fish mentioned that bash does word splitting and globbing
% after variable expansion. With RC vars are always list of strings
% so simpler?
% http://mywiki.wooledge.org/BashPitfalls

<<other rules>>=
assign: first '=' word      {$$=tree2('=', $1, $3);}
@
%$
% not words here? no cos cmd can contain list of words?
% but then variables contain a single word? not a list?
% for a list of words use () so X=(a b c d)
% but then how derive () from word? see below.


% no export in rc?

% uses

<<comword rule other cases>>=
|   '$' word        {$$=tree1('$', $2);}
|   COUNT word      {$$=tree1(COUNT, $2);}
|   '$' word SUB words ')'  {$$=tree2(SUB, $2, $4);}
@
%$

% SUB = '(' when after a word, subscript
% but what that mean? subscript, array access

\section{Lists ([[(...)]])}

<<comword rule other cases>>=
|   '(' words ')'   {$$=tree1(PAREN, $2);}
@
%$

% a bit hard to call it word then ... when it is really a list of words.





%\chapter{Checking}
% no type checking
% no checking at all (just if not but because ugly)

% Bourne says he was doing checks such as detecting cat >x | wc  errors.
% I could do?


\chapter{Bytecode Generation and Interpretation}
\label{chap:compile-interpret}

% or Code generation? or Bytecode generation?
\n i merged Bytecode Generation and Intepretation in one chapter
\n  because it helps to see the code generated from a tree.
\n We could also group with the related parsing, but maybe it would
\n  be too much, and parsing can be understood in isolation.

\section{Overview}

% recall main flow: main() -> ... -> Xrdcmds() -> yyparse() -> compile()

\subsection{[[emitxxx()]]}

% see codebuf in Core DS chapter (could be moved here too)

<<global [[codep]]>>=
// idx in codebuf
int codep;
@

% for the emitxxx() to realloc when necessary
<<global [[ncode]]>>=
int ncode;
@

% emit int
<<function [[emiti]]>>=
#define	emiti(x) ((codep!=ncode || morecode()), codebuf[codep].i = (x), codep++)
@
% return codep before! so can store for creating jmp

% emit function
<<function [[emitf]]>>=
#define	emitf(x) ((codep!=ncode || morecode()), codebuf[codep].f = (x), codep++)
@
% emit string
<<function [[emits]]>>=
#define	emits(x) ((codep!=ncode || morecode()), codebuf[codep].s = (x), codep++)
@
%ocaml: need just one emit(); can then pass variant

% growing array
<<function [[morecode]]>>=
//@Scheck: used by the macros above (why marked as dead then??? TODO)
int morecode(void)
{
    ncode+=100;
    codebuf = (code *)realloc((char *)codebuf, ncode*sizeof codebuf[0]);
    if(codebuf==nil)
        panic("Can't realloc %d bytes in morecode!", ncode*sizeof(code));
    return OK_0;
}
@
% need return an int? need OK_0? just return;

\subsection{[[compile()]]}


% modify codebuf!
<<function [[compile]]>>=
//@Scheck: called from syn.y
error0 compile(tree *t)
{
    ncode = 100;
    codep = 0;
    codebuf = (code *)emalloc(ncode*sizeof(code));

    emiti(0);			/* reference count */
    outcode(t, flag['e'] ? true : false);

    <<[[compile()]] check nerror>>
    <<[[compile()]] after outcode and error management, read heredoc>>

    emitf(Xreturn);
    emitf(nil);

    return OK_1;
}
@

% note that compile is called for each line entered interactively,
% and also inline of a script.
% So for each line in a script there are set of bytecodes for this line
% followed by a Xreturn to go back to the REPL to read the next line!

<<[[compile()]] check nerror>>=
if(nerror){
    efree((char *)codebuf);
    return ERROR_0;
}
@
%ocaml: use exception



\subsection{[[outcode()]]}

%ugly
<<constant c0 (rc/code.c)>>=
#define	c0	t->child[0]
@
<<constant c1 (rc/code.c)>>=
#define	c1	t->child[1]
@
<<constant c2 (rc/code.c)>>=
#define	c2	t->child[2]
@
%ocaml: just use precise AST and pattern matching to deconstruct

% modify codebuf via all those emitxxx()
% todo: could return errorcode instead of using nerror global
<<function [[outcode]]>>=
void
outcode(tree *t, bool eflag)
{
    <<[[outcode()]] locals>>

    if(t==nil)
        return;

    <<[[outcode()]] set iflast before switch>>
    switch(t->type){
    <<[[outcode()]] cases>>
    default:
        pfmt(err, "bad type %d in outcode\n", t->type);
        break;
    }
    <<[[outcode()]] set iflast after switch>>
}
@
%$

% test t == nil because call outcode on child that can be nil sometimes.
% Moreover when process a list of commands, at some points the sequence
% is empty.


\subsection{[[argv]] management}

%trans: before compile for main AST element, 
% a few common things in compilation scheme.
% - dealing with argv
% - dealing with return status
% - dealing with subprocesses

% used for each word in the compiled command
<<function [[Xword]]>>=
void
Xword(void)
{
    pushword(runq->code[runq->pc++].s);
}
@

% pushword() shown before.


% used to start a new list of words for a new command
% used when compiling SIMPLE commands
% used also for TWIDDLE, FOR, etc.
<<function [[Xmark]]>>=
void
Xmark(void)
{
    pushlist();
}
@
% why need multiple argv list? Because some bytecodes requires
% multiple things in the stack, but clearly separated.
% Many things can expand to list of strings, so when you need to operate
% over 2 list of strings, you need a special mark.

% pushlist() shown before


% used by Xsimple after having executed a command. Used by Xassign too.
% Each time we use Xmark to set a new context, we use poplist later.
<<function [[poplist]]>>=
void
poplist(void)
{
    list *p = runq->argv;
    if(p==nil)
        panic("poplist but no argv", 0);
    freelist(p->words);
    runq->argv = p->next;
    efree((char *)p);
}
@
%ocaml: need that too

% panic? see appendix.


% execexec -> <>
<<function [[popword]]>>=
void
popword(void)
{
    word *p;
    <<[[popword()]] sanity check argv>>
    p = runq->argv->words;
    <<[[popword()]] sanity check argv words>>
    runq->argv->words = p->next;
    efree(p->word);
    efree((char *)p);
}
@

<<[[popword()]] sanity check argv>>=
if(runq->argv==nil)
    panic("popword but no argv!", 0);
@
%ocaml: always have an argv, no need for this check

<<[[popword()]] sanity check argv words>>=
if(p==nil)
    panic("popword but no word!", 0);
@


\subsection{Process status management}

% was $$ in bash

<<function [[setstatus]]>>=
void
setstatus(char *s)
{
    setvar("status", newword(s, (word *)nil));
}
@

<<function [[getstatus]]>>=
char*
getstatus(void)
{
    var *status = vlook("status");
    return status->val ? status->val->word : "";
}
@

<<function [[truestatus]]>>=
bool
truestatus(void)
{
    char *s;
    for(s = getstatus();*s;s++)
        if(*s!='|' && *s!='0')
            return false;
    return true;
}
@
% what is this pipe in status? because when do ls | wc 
%  then rc combine the return status of both in one string
%  with | in the middle. so if 0|0 then everthing is file,
%  but if error in one of then then should return an error.
% so if return string is empty, or contains only 0 or |, then fine

\subsection{Subprocesses management}
% children

\t why need waitpids? anyway do Waitfor(pid, ...) in Xsimple
\t so why need also to record the current set of child process?

<<global [[waitpids]]>>=
// growing_array<pid> (but really a list)
int *waitpids;
@
<<global [[nwaitpids]]>>=
int nwaitpids;
@

<<function [[addwaitpid]]>>=
void
addwaitpid(int pid)
{
    waitpids = realloc(waitpids, (nwaitpids+1)*sizeof waitpids[0]);
    if(waitpids == nil)
        panic("Can't realloc %d waitpids", nwaitpids+1);
    waitpids[nwaitpids++] = pid;
}
@
%ocaml: use Hashtbl?

<<function [[delwaitpid]]>>=
void
delwaitpid(int pid)
{
    int r, w;
    
    for(r=w=0; r<nwaitpids; r++)
        if(waitpids[r] != pid)
            waitpids[w++] = waitpids[r];
    nwaitpids = w;
}
@

<<function [[clearwaitpids]]>>=
void
clearwaitpids(void)
{
    nwaitpids = 0;
}
@

<<function [[havewaitpid]]>>=
bool
havewaitpid(int pid)
{
    int i;

    for(i=0; i<nwaitpids; i++)
        if(waitpids[i] == pid)
            return true;
    return false;
}
@

\section{Simple commands}
% or builtins or functions


\subsection{Bytecode generation}

% SIMPLE node built in simplemung()

<<[[outcode()]] cases>>=
case SIMPLE:
    emitf(Xmark);
    outcode(c0, eflag); // the arguments and argv0
    emitf(Xsimple);
    <<[[outcode()]] emit Xeflag after Xsimple>>
    break;
@

% Xmark so new argv for this command
% then this will do some Xword and put in runq->argv a bunch
%  of words
% then Xsimple executuon

% ARGLIST is for the parameters of the simple command, the arguments,
% which are mostly word and so push in the stack (runq->argv)
% and also final = argv0
<<[[outcode()]] cases>>=
case ARGLIST:
    outcode(c1, eflag);
    outcode(c0, eflag);
    break;
@
% put in reverse order, cos this will lead to some
% Xword which will populate argv stack, so must be in reverse
% order so last word emited in codebuf is first in the runq->words stack.

<<[[outcode()]] cases>>=
case WORDS:
    outcode(c1, eflag);
    outcode(c0, eflag);
    break;
@

<<[[outcode()]] cases>>=
case WORD:
    emitf(Xword);
    emits(strdup(t->str));
    break;
@
% the string is inline in codebuf


\subsection{[[Xsimple()]]}

% * Xsimple(args)			run command and wait
<<function [[Xsimple]]>>=
void
Xsimple(void)
{
    word *a;
    thread *p = runq;
    int pid;
    <<[[Xsimple()]] other locals>>

    <<[[Xsimple()]] initializations, [[globlist()]]>>

    a = runq->argv->words;
    <<[[Xsimple()]] sanity check a>>

    <<[[Xsimple()]] if -x>>

    <<[[Xsimple()]] if argv0 is a function>>
    else{
        <<[[Xsimple()]] if argv0 is a builtin>>
        <<[[Xsimple()]] if exitnext()>>
        else{
            flush(err);
            Updenv();	/* necessary so changes don't go out again */
            if((pid = execforkexec()) < 0){
                Xerror("try again");
                return;
            }

            /* interrupts don't get us out */
            poplist();
            while(Waitfor(pid, 1) < 0)
                ;
        }
    }
}
@
% why the flush?

% <0 means wait was interrupted, but we still do it.
% What it means? Can not C-c ? if really big command,
% and do C-c, then child should die, then wait interrupted,
% and then when we do wait again it should return??

<<[[Xsimple()]] sanity check a>>=
if(a==nil){
    Xerror1("empty argument list");
    return;
}
@
% should have at least name of command in arg0!
% maybe should change error message?
% Can happen if do A=()\n and then $A\n, then after resolution
% of dollar argv becomes empty


% globlist is for globbing. See advanced topics.

% actually not an bytecode. Never generated by compile()
<<function [[Xerror]]>>=
void
Xerror(char *s)
{
    if(strcmp(argv0, "rc")==0 || strcmp(argv0, "/bin/rc")==0)
        pfmt(err, "rc: %s: %r\n", s);
    else
        pfmt(err, "rc (%s): %s: %r\n", argv0, s);
    flush(err);
    setstatus("error");

    while(!runq->iflag) 
        Xreturn();
}
@
% a bit like exception. Go up thread/call stack until
% the top where have interactive thread.
% As we go back we call Xreturn which will do the appropriate cleanups.


% diff with Xerror? does not print the %r
<<function [[Xerror1]]>>=
void
Xerror1(char *s)
{
    if(strcmp(argv0, "rc")==0 || strcmp(argv0, "/bin/rc")==0)
        pfmt(err, "rc: %s\n", s);
    else
        pfmt(err, "rc (%s): %s\n", argv0, s);
    flush(err);
    setstatus("error");

    while(!runq->iflag) 
        Xreturn();
}
@

\subsection{Fork}


% fundamental of a shell! fork exec wait
<<function [[execforkexec]]>>=
int
execforkexec(void)
{
    int pid;
    int n;
    char buf[ERRMAX];

    // fork()!!
    switch(pid = fork()){
    case -1:
        return -1;
    case 0: // child
        clearwaitpids();
        pushword("exec");
        execexec();

        // should not be reached! unless the command did not exist
        strcpy(buf, "can't exec: ");
        n = strlen(buf);
        errstr(buf+n, ERRMAX-n);
        Exit(buf);
    }
    // parent
    addwaitpid(pid);
    return pid;
}
@
% why execforkexec? why not just forkexec? 
% to be consistent with execexec below (which you can not just
% call exec since it conflicts with syscall)
%ocaml: let the module system handle conflict.

%clearwaitpids because child process is not responsible for
% waiting for some child

% note that if pb with exec, will exit, but this is done from
% the child, so the parent will still be ok

% why the pushword("exec")? because exec is also a builtin
% with code execexec, so here we want to reuse the same execexec function
% so we need to recreate the same conditions, the same argv.

\subsection{Exec}

% execforkexec | builtin "exec" -> <>
<<function [[execexec]]>>=
void
execexec(void)
{
    popword();	/* "exec" */
    <<[[execexec()]] sanity check arguments>>
    <<[[execexec()]] perform the redirections>>

    Execute(runq->argv->words, searchpath(runq->argv->words->word));
    // should not be reached! unless command did not exist
    poplist();
}
@

% doredir!!! now that is in child process, ready to exec,
%  that is when we can do the change to the file descriptors.

<<[[execexec()]] sanity check arguments>>=
if(runq->argv->words==nil){
    Xerror1("empty argument list");
    return;
}
@

% why push exec if after you pop it anyway?
% because execexec is also a builtin and in that case
% exec is in argv0.

% pass argv0 to searchpath

\subsection{[[$path]]}
%$

<<function [[searchpath]]>>=
word*
searchpath(char *w)
{
    word *path;

    if(strncmp(w, "/", 1)==0
    || strncmp(w, "#", 1)==0
    || strncmp(w, "./", 2)==0
    || strncmp(w, "../", 3)==0
    || (path = vlook("path")->val)==nil)
        path=&nullpath;
    return path;
}
@
% # is for device path in plan9

<<global [[nullpath]]>>=
struct Word nullpath = { "", nil};
@
% note that nullpath does not mean it will look for current directory

% how to allow to look in current path? cannot, have to use ./foo
% but then it does "/./foo" no?
%real-world: bash can forbid that by putting or not "." in PATH


<<function [[Execute]]>>=
void
Execute(word *args, word *path)
{
    char **argv = mkargv(args);
    char file[1024];
    char errstr[1024];
    int nc;

    Updenv();
    errstr[0] = '\0';

    for(;path;path = path->next){
        nc = strlen(path->word);
        if(nc < sizeof file - 1){	/* 1 for / */
            strcpy(file, path->word);
            if(file[0]){
                strcat(file, "/");
                nc++;
            }
            if(nc + strlen(argv[1]) < sizeof file){
                strcat(file, argv[1]);

                // The actual exec() system call!
                exec(file, argv+1);

                // reached if the file does not exist

                rerrstr(errstr, sizeof errstr);
                /*
                 * if file exists and is executable, exec should
                 * have worked, unless it's a directory or an
                 * executable for another architecture.  in
                 * particular, if it failed due to lack of
                 * swap/vm (e.g., arg. list too long) or other
                 * allocation failure, stop searching and print
                 * the reason for failure.
                 */
                if (strstr(errstr, " allocat") != nil ||
                    strstr(errstr, " full") != nil)
                    break;
            }
            else werrstr("command name too long");
        }
    }
    // should not be reached if found an actual binary to exec
    pfmt(err, "%s: %s\n", argv[1], errstr);
    efree((char *)argv);
}
@
%ocaml: no need fixed buffer and all those checks that cmd not too long

<<function [[mkargv]]>>=
char **
mkargv(word *a)
{
    char **argv = (char **)emalloc((count(a)+2) * sizeof(char *));
    char **argp = argv+1;	/* leave one at front for runcoms */

    for(;a;a = a->next) 
        *argp++=a->word;
    *argp = nil;
    return argv;
}
@
% what is the one at the front??? for runcoms???
%ocaml: Array.of_list

\subsection{Wait}

% In the mean time, in the parent process

% Xsimple -> <>
<<function [[Waitfor]]>>=
int
Waitfor(int pid, int)
{
    thread *p;
    Waitmsg *w;
    char errbuf[ERRMAX];

    if(pid >= 0 && !havewaitpid(pid))
        return 0;

    // wait()!! until we found it
    while((w = wait()) != nil){
        delwaitpid(w->pid);

        if(w->pid==pid){
            setstatus(w->msg);
            free(w);
            return 0;
        }
        <<[[Waitfor()]] in while loop, if wait returns another pid>>
    }

    errstr(errbuf, sizeof errbuf);
    if(strcmp(errbuf, "interrupted")==0) 
        return -1;
    return 0;
}
@
\t remove second argument, it is not used anyway



\subsection{Fork optimization}

% it is an optimisation then? mv to advanced topics?
%  when have exit in codebuf?
<<[[Xsimple()]] if exitnext()>>=
if(exitnext()){
    /* fork and wait is redundant */
    pushword("exec");
    execexec();
    Xexit();
}
@

<<function [[exitnext]]>>=
/*
 * Search through the following code to see if we're just going to exit.
 */
int
exitnext(void){
    union Code *c = &runq->code[runq->pc];
    while(c->f==Xpopredir) 
        c++;
    return c->f==Xexit;
}
@
% popredir does not matter? because all fd will be closed once
% exit from execed process?

\section{Operators}

\subsection{Sequence}

<<[[outcode()]] cases>>=
case ';':
    outcode(c0, eflag);
    outcode(c1, eflag);
    break;
@
% simple :)




\subsection{Logical operators}

<<[[outcode()]] locals>>=
int p;
@

<<[[outcode()]] cases>>=
case ANDAND:
    outcode(c0, false);
    emitf(Xtrue);
    p = emiti(0);
    outcode(c1, eflag);
    stuffdot(p);
    break;
@
% pass false to outcode, cos dont care about checking error status
%  of first cmd in  cmd1 && cmd2

% jump technique
<<function [[stuffdot]]>>=
void
stuffdot(int a)
{
    if(a<0 || codep<=a)
        panic("Bad address %d in stuffdot", a);
    codebuf[a].i = codep;
}
@
% stuffdot meaning?
% so this allow to generate a jump forward.



<<[[outcode()]] cases>>=
case OROR:
    outcode(c0, false);
    emitf(Xfalse);
    p = emiti(0);
    outcode(c1, eflag);
    stuffdot(p);
    break;
@

<<function [[Xtrue]]>>=
void
Xtrue(void)
{
    if(truestatus()) runq->pc++;
    else runq->pc = runq->code[runq->pc].i;
}
@

<<function [[Xfalse]]>>=
void
Xfalse(void)
{
    if(truestatus()) runq->pc = runq->code[runq->pc].i;
    else runq->pc++;
}
@




<<[[outcode()]] cases>>=
case BANG:
    outcode(c0, eflag);
    emitf(Xbang);
    break;
@

<<function [[Xbang]]>>=
void
Xbang(void)
{
    setstatus(truestatus()? "false" : "");
}
@


\subsection{String matching}


<<[[outcode()]] cases>>=
case TWIDDLE:
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xmatch);
    if(eflag)
        emitf(Xeflag);
    break;
@
% why Xeflag here? no command, just word, so why exit early?

<<function [[Xmatch]]>>=
void
Xmatch(void)
{
    word *p;
    char *subject;

    subject = list2str(runq->argv->words);
    setstatus("no match");
    for(p = runq->argv->next->words;p;p = p->next)
        if(match(subject, p->word, '\0')){
            setstatus("");
            break;
        }
    efree(subject);
    poplist();
    poplist();
}
@
% but list of words should contain only one element no?
% no cos pattern can be the content of a variable

<<function [[list2str]]>>=
char*
list2str(word *words)
{
    char *value, *s, *t;
    int len = 0;
    word *ap;

    for(ap = words;ap;ap = ap->next)
        len += 1+strlen(ap->word);
    value = emalloc(len+1);

    s = value;
    for(ap = words;ap;ap = ap->next){
        for(t = ap->word;*t;) 
            *s++=*t++;
        *s++=' ';
    }
    if(s==value)
        *s='\0';
    else s[-1]='\0';
    return value;
}
@
%ocaml: String.concat " "


% see also /bin/test! often used as argument to if()

\subsection{Redirection}

% note that when we see a redirection command, we can not
% redirect yet our own stdout and stdin. We need to do that
% in the child process we fork that runs a simple command.
% So when we see a redir, we need to store in the thread
% future redirections we will need to do in the child process.


% Then at some point we execute those redirections:
<<[[execexec()]] perform the redirections>>=
doredir(runq->redir);
@

% inherit redir from parent thread? why need that? for subshell stuff?
<<[[start()]] set redir>>=
p->redir = p->startredir = runq ? runq->redir : nil;
@
% and then why need remember starting point? because in case of
% error we need to popredir everything that was opened from this thread.
% And we often create new threads.
%ocaml: use list of list instead of having redir and startredir


\subsubsection{[[Redir]]}

<<struct [[Redir]]>>=
struct Redir {
    // enum<redirection_kind_bis>
    char type;	/* what to do */

    /* what to do it to */
    short from;
    short to;

    // Extra
    <<[[Redir]] extra fields>>
};
@


<<[[Thread]] other fields>>=
// list<ref_own<Redir>> (next = Redir.next)
struct Redir *redir;	/* redirection stack */
@

<<[[Redir]] extra fields>>=
struct Redir *next;		/* what else to do (reverse order) */
@

<<function [[pushredir]]>>=
void
pushredir(int type, int from, int to)
{
    redir * rp = new(redir);
    rp->type = type;
    rp->from = from;
    rp->to = to;

    // add_list(runq->redir, rp)
    rp->next = runq->redir;
    runq->redir = rp;
}
@
%ocaml: just use :: and create directly with constructor.


\subsubsection{[[doredir()]]}

% execexec -> <>
<<function [[doredir]]>>=
void
doredir(redir *rp)
{
    if(rp){
        // recurse first, so do them in the reverse order of the list
        doredir(rp->next);

        switch(rp->type){
        <<[[doredir()]] switch redir type cases>>
        }
    }
}
@

% so when do cmd > foo < bar, what is done first?
% more importantly when do cmd > foo >[2=1] ?  vs cmd >[2=1] > foo ?

<<[[doredir()]] switch redir type cases>>=
case ROPEN:
    if(rp->from != rp->to){
        Dup(rp->from, rp->to);
        close(rp->from);
    }
    break;
@

<<constant [[ROPEN]]>>=
/*
 * redir types
 */
#define	ROPEN	1			/* dup2(from, to); close(from); */
@




\subsubsection{Bytecode generation}

<<[[outcode()]] cases>>=
case REDIR:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xglob);

    switch(t->rtype){
    <<[[outcode()]] when REDIR case, switch redirection type cases>>
    }
    emiti(t->fd0);
    outcode(c1, eflag);
    emitf(Xpopredir);
    break;
@

% the popredir is here because when do
%  cmd1 > foo; cmd2; cmd3
% we want the redirection to be value only while executing cmd1.
% so once this is done, and start cmd2, we need to pop the redir.


\subsubsection{[[Xwrite()]]}

<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case WRITE:
    emitf(Xwrite);
    break;
@

<<function [[Xwrite]]>>=
void
Xwrite(void)
{
    char *file;
    fdt f;
    switch(count(runq->argv->words)){
    default:
        Xerror1("> requires singleton\n");
        return;
    case 0:
        Xerror1("> requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = Creat(file))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@


<<function [[Xpopredir]]>>=
void
Xpopredir(void)
{
    struct Redir *rp = runq->redir;

    if(rp==nil)
        panic("turfredir null!", 0);

    // pop_list(runq->redir);
    runq->redir = rp->next;

    if(rp->type==ROPEN)
        close(rp->from);

    efree((char *)rp);
}
@

% also when get an error, we must not forget when we raise the exception
% to close what was opened here!
% See turfredir().

\subsubsection{[[Xread()]]}


<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case READ:
case HERE:
    emitf(Xread);
    break;
@


<<function [[Xread]]>>=
void
Xread(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1("< requires singleton\n");
        return;
    case 0:
        Xerror1("< requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, 0))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@

\subsubsection{[[Xappend()]]}

<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case APPEND:
    emitf(Xappend);
    break;
@


<<function [[Xappend]]>>=
void
Xappend(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1(">> requires singleton");
        return;
    case 0:
        Xerror1(">> requires file");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, 1))<0 && (f = Creat(file))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    Seek(f, 0L, 2);
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@


\subsubsection{Closing redirection opened files}

% why need remember the redir when we started? because 
% if we got an error in the thread, we need to close every redirections
% that happens since we started this new thread.
% In fact, when we Xreturn we also need to close what was opened.

<<[[Thread]] other fields>>=
struct Redir *startredir;	/* redir inheritance point */
@
%ocaml: use list of list for redir instead, so no "inheritance" need
% just use List.flatten in doredir() instead

% (Xerror | ...) -> Xreturn -> <>
<<function [[turfredir]]>>=
void
turfredir(void)
{
    while(runq->redir != runq->startredir)
        Xpopredir();
}
@
%ocaml: just pop the list

<<[[Xreturn()]] pop the redirections from this thread>>=
turfredir();
@



\subsection{Pipe}

% arguably the most important operator

<<[[outcode()]] locals>>=
int q;
@



% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,
% * 					wait for both
% * Xpipewait

<<[[outcode()]] cases>>=
case PIPE:
    emitf(Xpipe);
    emiti(t->fd0); // 1 in the normal case
    emiti(t->fd1); // 0 in the normal case
    p = emiti(0);
    q = emiti(0);

    // for first child
    outcode(c0, eflag);
    emitf(Xexit);

    // for second child
    stuffdot(p);
    outcode(c1, eflag);
    emitf(Xreturn);
 
    // for parent (rc)
    stuffdot(q);
    emitf(Xpipewait);
    break;
@


<<function [[Xreturn]]>>=
void
Xreturn(void)
{
    struct Thread *p = runq;

    <<[[Xreturn()]] pop the redirections from this thread>>
    // free p
    while(p->argv) 
        poplist();
    codefree(p->code);
    // pop(runq)
    runq = p->ret;
    efree((char *)p);

    if(runq==nil)
        Exit(getstatus());
}
@
%ocaml: no need poplist, codefree, just use Gc

% as goes up the call stack, you need to close the opened redirections
% see turfredir.



<<constant [[PRD]]>>=
/*
 * Which fds are the reading/writing end of a pipe?
 * Unfortunately, this can vary from system to system.
 * 9th edition Unix doesn't care, the following defines
 * work on plan 9.
 */
#define	PRD	0
@
<<constant [[PWR]]>>=
#define	PWR	1
@
%ocaml: pipe returns a pair, and you can bind to clear names as in
%  let (pipe_read, pipe_write) = Unix.pipe () in

% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,	wait for both

<<function [[Xpipe]]>>=
void
Xpipe(void)
{
    struct Thread *p = runq;
    int pc = p->pc;
    int forkid;
    fdt lfd = p->code[pc++].i;
    fdt rfd = p->code[pc++].i;
    fdt pfd[2];

    if(pipe(pfd)<0){
        Xerror("can't get pipe");
        return;
    }
    switch(forkid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        // pc+2 so jump the jump addresses
        start(p->code, pc+2, runq->local);
        runq->ret = nil;
        close(pfd[PRD]);
        pushredir(ROPEN, pfd[PWR], lfd);
        break;
    default: // parent
        addwaitpid(forkid);
        start(p->code, p->code[pc].i, runq->local);
        close(pfd[PWR]);
        pushredir(ROPEN, pfd[PRD], rfd);
        p->pc = p->code[pc+1].i;
        p->pid = forkid;
        break;
    }
}
@
% note that execute left part in a fork, so cant modify stuff there.
% but for right part there is no fork, so right part can do 
% some assignments that will be seen after.

% note that the break in the child
% will return to interpreter loop that will execute this new thread

% try  % while() $a=1 | while () $b=2
% echo $a $b


<<[[Thread]] other fields>>=
// option<int> (None = -1)
int pid;		/* process for Xpipewait to wait for */
@
% could pass value through argv? maybe, but anyway need to
% store in the list of threads in runq which thread is waiting
% for which pid so when do wait(), know which one have already
% been handled in which case Xpipewait should not wait().

% Note that can not just do the wait in Xpipe. We need to let
% the right cmd pipe execute in its thread first! once it is done
% then we can continue and do the wait for it in the parent (rc) process.


<<[[Thread]] other fields>>=
char status[NSTATUS];	/* status for Xpipewait */
@
<<constant [[NSTATUS]]>>=
#define	NSTATUS	ERRMAX			/* length of status (from plan 9) */
@
%ocaml: a waitstatus type = WaitFor of int | ChildStatus of string


<<function [[Xpipewait]]>>=
void
Xpipewait(void)
{
    char status[NSTATUS+1];
    if(runq->pid==-1)
        setstatus(concstatus(runq->status, getstatus()));
    else{
        strncpy(status, getstatus(), NSTATUS);
        status[NSTATUS]='\0';
        Waitfor(runq->pid, 1);
        runq->pid=-1;
        setstatus(concstatus(getstatus(), status));
    }
}
@
% get status from left child and concatenate with our own status
% (right child should have returned it through a Xreturn)


<<[[Waitfor()]] in while loop, if wait returns another pid>>=
// else
for(p = runq->ret;p;p = p->ret)
    if(p->pid==w->pid){
        p->pid=-1;
        strcpy(p->status, w->msg);
    }
free(w);
@

% the wait() syscall does not accept a specific pid, so when you wait,
% you can get any child. When in rc you do  cmd1 | cmd2 | cmd3
% you dont know which one will terminate first, but you need
% to remember which thread is waiting for certain pid.
% enter Thread.pid and the loop above.


<<function [[concstatus]]>>=
char*
concstatus(char *s, char *t)
{
    static char v[NSTATUS+1];
    int n = strlen(s);
    strncpy(v, s, NSTATUS);
    if(n<NSTATUS){
        v[n]='|';
        strncpy(v+n+1, t, NSTATUS-n-1);
    }
    v[NSTATUS]='\0';
    return v;
}
@
%ocaml: hmm, just use ^ or sprintf










\subsection{Asynchronous execution}

<<[[outcode()]] cases>>=
case '&':
    emitf(Xasync);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    break;
@



% * Xasync{... Xexit}			make thread for {}, no wait
<<function [[Xasync]]>>=
void
Xasync(void)
{
    fdt null = open("/dev/null", 0);
    int pid;
    char npid[10];
    if(null<0){
        Xerror("Can't open /dev/null\n");
        return;
    }
    switch(pid = rfork(RFFDG|RFPROC|RFNOTEG)){
    case -1:
        close(null);
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        pushredir(ROPEN, null, 0);
        // start a new Thread runq->pc+1 so skip pointer to code after &
        start(runq->code, runq->pc+1, runq->local);
        runq->ret = 0;
        break;
    default: // parent
        addwaitpid(pid);
        close(null);
        // jump to code after &
        runq->pc = runq->code[runq->pc].i;
        inttoascii(npid, pid);
        setvar("apid", newword(npid, (word *)nil));
        break;
    }
}
@

% mypid is global set at the very beginning
<<function [[Xexit]]>>=
void
Xexit(void)
{
    struct Var *trapreq;
    struct Word *starval;
    static bool beenhere = false;

    if(getpid()==mypid && !beenhere){
        trapreq = vlook("sigexit");
        if(trapreq->fn){
            beenhere = true;
            --runq->pc;
            starval = vlook("*")->val;
            start(trapreq->fn, trapreq->pc, (struct Var *)0);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)0);
            runq->local->changed = true;
            runq->redir = runq->startredir = nil;
            return;
        }
    }
    Exit(getstatus());
}
@

% Xexit vs Exit vs exits



\section{Control flow statements}

\subsection{[[if]]}

% remember than in rc there is   'if ( )' and 'if not' for else.

<<[[outcode()]] cases>>=
case IF:
    outcode(c0, false);
    emitf(Xif);
    p = emiti(0);
    outcode(c1, eflag);
    emitf(Xwastrue);
    stuffdot(p);
    break;
@


<<function [[Xif]]>>=
void
Xif(void)
{
    ifnot = true;
    if(truestatus()) 
        runq->pc++;
    else 
        runq->pc = runq->code[runq->pc].i;
}
@

<<global [[ifnot]]>>=
bool ifnot;		/* dynamic if not flag */
@


<<function [[Xwastrue]]>>=
void
Xwastrue(void)
{
    ifnot = false;
}
@




<<[[outcode()]] cases>>=
case NOT:
    <<[[outcode()]] when NOT, sanity check last command was an if>>
    emitf(Xifnot);
    p = emiti(0);
    outcode(c0, eflag);
    stuffdot(p);
    break;
@

<<function [[Xifnot]]>>=
void
Xifnot(void)
{
    if(ifnot)
        runq->pc++;
    else
        runq->pc = runq->code[runq->pc].i;
}
@


<<[[outcode()]] when NOT, sanity check last command was an if>>=
if(!runq->iflast)
    yyerror("`if not' does not follow `if(...)'");
@

% should be handled via grammar
<<[[Thread]] other fields>>=
bool iflast;		/* static `if not' checking */
@

<<[[outcode()]] set iflast after switch>>=
if(t->type!=NOT && t->type!=';')
    runq->iflast = t->type==IF;
else 
   if(c0) 
       runq->iflast = c0->type==IF;
@

<<[[outcode()]] set iflast before switch>>=
if(t->type!=NOT && t->type!=';')
    runq->iflast = false;
@


\subsection{[[while]]}

<<[[outcode()]] cases>>=
case WHILE:
    q = codep;
    outcode(c0, false);
    if(q==codep)
        emitf(Xsettrue);	/* empty condition == while(true) */
    emitf(Xtrue);
    p = emiti(0);
    outcode(c1, eflag);
    emitf(Xjump);
    emiti(q);
    stuffdot(p);
    break;
@

<<function [[Xsettrue]]>>=
void
Xsettrue(void)
{
    setstatus("");
}
@

<<function [[Xjump]]>>=
void
Xjump(void)
{
    runq->pc = runq->code[runq->pc].i;
}
@

\subsection{[[for]]}

% why Xmark?

<<[[outcode()]] cases>>=
case FOR:
    emitf(Xmark);
    if(c1){
        outcode(c1, eflag);
        emitf(Xglob);
    }
    else{
        emitf(Xmark);
        emitf(Xword);
        emits(strdup("*"));
        emitf(Xdol);
    }
    emitf(Xmark);		/* dummy value for Xlocal */
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xlocal);
    p = emitf(Xfor);
    q = emiti(0);
    outcode(c2, eflag);
    emitf(Xjump);
    emiti(p);
    stuffdot(q);
    emitf(Xunlocal);
    break;
@

<<function [[Xfor]]>>=
void
Xfor(void)
{
    if(runq->argv->words==0){
        poplist();
        runq->pc = runq->code[runq->pc].i;
    }
    else{
        freelist(runq->local->val);
        runq->local->val = runq->argv->words;
        runq->local->changed = true;
        runq->argv->words = runq->argv->words->next;
        runq->local->val->next = 0;
        runq->pc++;
    }
}
@


\subsection{[[switch]]}
% mv in advanced topic?

<<[[outcode()]] cases>>=
case SWITCH:
    codeswitch(t, eflag);
    break;
@

<<function [[codeswitch]]>>=
/*
 * switch code looks like this:
 *	Xmark
 *	(get switch value)
 *	Xjump	1f
 * out:	Xjump	leave
 * 1:	Xmark
 *	(get case values)
 *	Xcase	1f
 *	(commands)
 *	Xjump	out
 * 1:	Xmark
 *	(get case values)
 *	Xcase	1f
 *	(commands)
 *	Xjump	out
 * 1:
 * leave:
 *	Xpopm
 */
void
codeswitch(tree *t, bool eflag)
{
    int leave;		/* patch jump address to leave switch */
    int out;		/* jump here to leave switch */
    int nextcase;	/* patch jump address to next case */
    tree *tt;

    // c1 is BRACE { ; ; ; }
    if(c1->child[0]==nil
    || c1->child[0]->type != ';'
    || !iscase(c1->child[0]->child[0])){
        yyerror("case missing in switch");
        return;
    }

    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xjump);

    nextcase = emiti(0);
    out = emitf(Xjump);
    leave = emiti(0);

    stuffdot(nextcase);

    // from now on c0, c1, ... refer to this new t
    t = c1->child[0];
    while(t->type==';'){
        tt = c1;
        emitf(Xmark);
        for(t = c0->child[0];t->type==ARGLIST;t = c0) 
            outcode(c1, eflag);
        emitf(Xcase);
        nextcase = emiti(0);
        t = tt;
        for(;;){
            if(t->type==';'){
                if(iscase(c0)) 
                    break;
                outcode(c0, eflag);
                t = c1;
            }
            else{
                if(!iscase(t)) 
                    outcode(t, eflag);
                break;
            }
        }
        emitf(Xjump);
        emiti(out);
        stuffdot(nextcase);
    }
    stuffdot(leave);
    emitf(Xpopm);
}
@
%ocaml: easier in ocaml, more precise AST, so less jungle with c0, c1
% and also first word of simple command is directly accessible. No need
% to go through ARGLIST.

% funny that case is not a keyword. It's just a word, but
% it's recognized specially by rc
% but must be alone on its line (or need to use ; so case 1; cmd1; cmd2 etc)

% remember that foo arg1 arg2 is represented as a tree of ARGLIST
%  where foo is in depth.
% remember that list of commands in a switch is represented as a 
%  list with ';' for the node, and the top node has BRACE.

% used by swich only. So could mv later.
% In fact could remove the need for List, just have a single argv.
<<function [[Xpopm]]>>=
void
Xpopm(void)
{
    poplist();
}
@
% why not call directly poplist then? because would be dependency
% to runtime from compile!



<<function [[iscase]]>>=
bool
iscase(tree *t)
{
    if(t->type!=SIMPLE)
        return false;
    do { t = c0; } while(t->type==ARGLIST);
    return t->type==WORD && !t->quoted && strcmp(t->str, "case")==0;
}
@
%ocaml: just use pattern match, much cleaner, much more typesafe

% * Xcase(pat, value){...}		exec code on match, leave (value) on

<<function [[Xcase]]>>=
void
Xcase(void)
{
    word *p;
    char *s;
    bool ok = false;

    s = list2str(runq->argv->next->words);
    for(p = runq->argv->words;p;p = p->next){
        if(match(s, p->word, '\0')){
            ok = true;
            break;
        }
    }
    efree(s);
    if(ok)
        runq->pc++;
    else
        runq->pc = runq->code[runq->pc].i;
    poplist();
}
@


\subsection{Blocks: \texttt{'\{...\}'}}

<<[[outcode()]] cases>>=
case PAREN:
    outcode(c0, eflag);
    break;
@
% not really for {}, it is for () as in A=(1 2 3)

<<[[outcode()]] cases>>=
case PCMD:
case BRACE:
    outcode(c0, eflag);
    break;
@


\section{Functions}


<<[[Var]] other fields>>=
code	*fn;		/* pointer to function's code vector */
int	pc;		/* pc of start of function */
bool	fnchanged;
@
%ocaml: put in another type, not with Var



\subsection{Definitions ([[fn <foo> { ... }]])}
% defs

% * Xfn(name){... Xreturn}			define function
% * Xdelfn(name)				delete function definition
<<[[outcode()]] cases>>=
case FN:
    emitf(Xmark);
    outcode(c0, eflag);
    if(c1){
        emitf(Xfn);
        p = emiti(0);
        emits(fnstr(c1));
        outcode(c1, eflag); // body of the function
        emitf(Xunlocal);	/* get rid of $* */ //$
        emitf(Xreturn);
        stuffdot(p);
    }
    else
        emitf(Xdelfn);
    break;
@

<<function [[fnstr]]>>=
char*
fnstr(tree *t)
{
    void *v;
    extern char nl;
    char svnl = nl;
    io *f = openstr();

    nl = ';';
    pfmt(f, "%t", t);
    nl = svnl;
    v = f->strp;
    f->strp = nil;
    closeio(f);
    return v;
}
@



<<function [[Xfn]]>>=
void
Xfn(void)
{
    var *v;
    word *a;
    int end;

    end = runq->code[runq->pc].i;
    globlist();
    for(a = runq->argv->words;a;a = a->next){
        v = gvlook(a->word);
        if(v->fn)
            codefree(v->fn);
        v->fn = codecopy(runq->code);
        v->pc = runq->pc+2;
        v->fnchanged = true;
    }
    runq->pc = end;
    poplist();
}
@

<<function [[Xdelfn]]>>=
void
Xdelfn(void)
{
    var *v;
    word *a;

    for(a = runq->argv->words;a;a = a->next){
        v = gvlook(a->word);
        if(v->fn)
            codefree(v->fn);
        v->fn = nil;
        v->fnchanged = true;
    }
    poplist();
}
@
% can delete a list of functions. meh.

\subsection{Uses ([[<foo>(...)]])}

<<[[Xsimple()]] other locals>>=
var *v;
@

<<[[Xsimple()]] if argv0 is a function>>=
v = gvlook(a->word);
if(v->fn)
    execfunc(v);
@

<<function [[execfunc]]>>=
void
execfunc(var *func)
{
    word *starval;

    popword();
    starval = runq->argv->words;
    runq->argv->words = nil;
    poplist();
    start(func->fn, func->pc, runq->local);
    runq->local = newvar(strdup("*"), runq->local);
    runq->local->val = starval;
    runq->local->changed = true;
}
@

\section{Variables}

\subsection{Definitions ([[<x>=...]])}

<<[[outcode()]] locals>>=
tree *tt;
@

% note that can have A=b C=d cmd
% so to know if it's a local or global assignment, we need to look
% at the very right after the '=' nodes.

<<[[outcode()]] cases>>=
case '=':
    tt = t;
    for(;t && t->type=='='; t = c2);

    if(t){					/* var=value cmd */
        for(t = tt;t->type=='=';t = c2){
            emitf(Xmark);
            outcode(c1, eflag);
            emitf(Xmark);
            outcode(c0, eflag);
            emitf(Xlocal);		/* push var for cmd */
        }
        outcode(t, eflag);		/* gen. code for cmd */
        for(t = tt; t->type == '='; t = c2)
            emitf(Xunlocal);	/* pop var */
    }
    else{					/* var=value */
        for(t = tt;t;t = c2){
            emitf(Xmark);
            outcode(c1, eflag);
            emitf(Xmark);
            outcode(c0, eflag);
            emitf(Xassign);	/* set var permanently */
        }
    }
    t = tt;	/* so tests below will work */
    break;
@

<<function [[Xassign]]>>=
void
Xassign(void)
{
    var *v;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    deglob(runq->argv->words->word); // remove the special \001 mark
    v = vlook(runq->argv->words->word);
    poplist();

    globlist();
    freewords(v->val);
    v->val = runq->argv->words;
    v->changed = true;
    runq->argv->words = nil;
    poplist();
}
@
% set to nil because dont want poplist to free it. 
% it has been borrowed by v->val.
%ocaml: just use the Gc

% no globbing here! cos can do *=(...); for(i) { ... }
% anyway since we expect a single varname on the left of =,
% it would not make sense to glob.

% deglob is to remove the \001 inserted during lexing

% FIGURE to understand the double pop_list()?

<<function [[Xlocal]]>>=
void
Xlocal(void)
{
    if(count(runq->argv->words)!=1){
        Xerror1("variable name must be singleton\n");
        return;
    }
    deglob(runq->argv->words->word);
    runq->local = newvar(strdup(runq->argv->words->word), runq->local);
    poplist();
    globlist();
    runq->local->val = runq->argv->words;
    runq->local->changed = true;
    // change ownership
    runq->argv->words = nil;
    poplist();
}
@

<<function [[Xunlocal]]>>=
void
Xunlocal(void)
{
    var *v = runq->local, *hid;
    if(v==0)
        panic("Xunlocal: no locals!", 0);
    runq->local = v->next;
    hid = vlook(v->name);
    hid->changed = true;
    efree(v->name);
    freewords(v->val);
    efree((char *)v);
}
@


\subsection{Uses ([[$<x>]])} %$

<<[[outcode()]] cases>>=
case '$': //$
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xdol);
    break;
@

<<function [[Xdol]]>>=
void
Xdol(void)
{
    word *a, *star;
    char *s, *t;
    int n;

    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);

    n = 0;
    for(t = s;'0'<=*t && *t<='9';t++) 
        n = n*10+*t-'0';

    a = runq->argv->next->words;
    if(n==0 || *t)
        a = copywords(vlook(s)->val, a);
    else{
        star = vlook("*")->val;
        if(star && 1 <= n && n <= count(star)){
            while(--n) 
                star = star->next;
            a = newword(star->word, a);
        }
    }
    poplist();
    runq->argv->words = a;
}
@
%ocaml: be more strict when array index out of bound





<<[[outcode()]] cases>>=
case COUNT:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xcount);
    break;
@


<<function [[Xcount]]>>=
void
Xcount(void)
{
    word *a;
    char *s, *t;
    int n;
    char num[12];

    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);

    // n = int_of_string(s)
    n = 0;
    for(t = s;'0'<=*t && *t<='9';t++) 
        n = n*10 + *t - '0';
    if(n==0 || *t){
        a = vlook(s)->val;
        inttoascii(num, count(a));
    }
    else{
        a = vlook("*")->val;
        inttoascii(num, (a && 1<=n && n<=count(a)) ? 1 : 0);
    }
    poplist();
    pushword(num);
}
@
%ocaml: factorize in a vlook_varname_or_index with code for Xdol?
% a bit hard to factorize, different logic


<<[[outcode()]] cases>>=
case SUB:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xsub);
    break;
@


<<function [[Xsub]]>>=
void
Xsub(void)
{
    word *a, *v;
    char *s;
    if(count(runq->argv->next->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->next->words->word;
    deglob(s);
    a = runq->argv->next->next->words;
    v = vlook(s)->val;
    a = subwords(v, count(v), runq->argv->words, a);
    poplist();
    poplist();
    runq->argv->words = a;
}
@

<<function [[subwords]]>>=
word*
subwords(word *val, int len, word *sub, word *a)
{
    int n, m;
    char *s;
    if(!sub)
        return a;
    a = subwords(val, len, sub->next, a);
    s = sub->word;
    deglob(s);
    m = 0;
    n = 0;
    while('0'<=*s && *s<='9')
        n = n*10+ *s++ -'0';
    if(*s == '-'){
        if(*++s == 0)
            m = len - n;
        else{
            while('0'<=*s && *s<='9')
                m = m*10+ *s++ -'0';
            m -= n;
        }
    }
    if(n<1 || n>len || m<0)
        return a;
    if(n+m>len)
        m = len-n;
    while(--n > 0)
        val = val->next;
    return copynwords(val, a, m+1);
}
@



<<[[outcode()]] cases>>=
case '^':
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xconc);
    break;
@

<<function [[Xconc]]>>=
void
Xconc(void)
{
    word *lp = runq->argv->words;
    word *rp = runq->argv->next->words;
    word *vp = runq->argv->next->next->words;
    int lc = count(lp), rc = count(rp);
    if(lc!=0 || rc!=0){
        if(lc==0 || rc==0){
            Xerror1("null list in concatenation");
            return;
        }
        if(lc!=1 && rc!=1 && lc!=rc){
            Xerror1("mismatched list lengths in concatenation");
            return;
        }
        vp = conclist(lp, rp, vp);
    }
    poplist();
    poplist();
    runq->argv->words = vp;
}
@

<<function [[conclist]]>>=
word*
conclist(word *lp, word *rp, word *tail)
{
    char *buf;
    word *v;
    if(lp->next || rp->next)
        tail = conclist(lp->next==0? lp: lp->next,
            rp->next==0? rp: rp->next, tail);
    buf = emalloc(strlen(lp->word)+strlen((char *)rp->word)+1);
    strcpy(buf, lp->word);
    strcat(buf, rp->word);
    v = newword(buf, tail);
    efree(buf);
    return v;
}
@


%\subsection{Interpolation}

% There is no "" vs '' in rc. Just '' to quote (hence the use of a _quote_
% character). If you want to construct an argument with space
% that includes dollars, use ^.


\subsection{Special variables}

%vlook("xxx"):
% home, cdpath, path
% prompt, 
% *, 
% status, sigexit
% ifs?

\chapter{Builtins}
\label{chap:builtins}



\section{Overview}

% called from Xsimple when first word is actually recognized as a builtin

<<struct [[Builtin]]>>=
struct Builtin {
    char *name;
    void (*fnc)(void);
};
@

% plan9.c
% rename Builtin -> builtins
<<global [[builtins]]>>=
builtin builtins[] = {
    "cd"     ,      execcd,
    "exit"   ,      execexit,
    "."      ,      execdot,
    "eval"   ,      execeval,

    "whatis" ,      execwhatis,

    "exec"   ,      execexec,   /* but with popword first */
    "rfork"  ,      execnewpgrp,
    "wait"   ,      execwait,

    "shift"  ,      execshift,
    "finit"  ,      execfinit,
    "flag"   ,      execflag,
    0
};
@
%old: was Builtin but conflict with struct def and bad convention

<<[[Xsimple()]] other locals>>=
struct Builtin *bp;
@

% 2 ways to call, either directly 'xxx' or via 'builtin xxx'
<<[[Xsimple()]] if argv0 is a builtin>>=
<<[[Xsimple()]] if argv0 is the builtin keyword>>
for(bp = builtins;bp->name;bp++)
    if(strcmp(a->word, bp->name)==0){
        (*bp->fnc)();
        return;
    }
@

<<[[Xsimple()]] if argv0 is the builtin keyword>>=
if(strcmp(a->word, "builtin")==0){
    if(count(a)==1){
        pfmt(err, "builtin: empty argument list\n");
        setstatus("empty arg list");
        poplist();
        return;
    }
    a = a->next;
    popword();
}
@

% remember that also have function, so if cd is a function
% but want the builtin, need "builtin" prefix to escape
% the function resolution mechanism.


\section{[[$ cd]]}
%$

<<function [[execcd]]>>=
void
execcd(void)
{
    word *a = runq->argv->words;
    word *cdpath;
    char *dir;

    setstatus("can't cd");
    cdpath = vlook("cdpath")->val;

    switch(count(a)){
    case 1:
        a = vlook("home")->val;
        if(count(a)>=1){
            if(dochdir(a->word)>=0)
                setstatus("");
            else
                pfmt(err, "Can't cd %s: %r\n", a->word);
        }
        else
            pfmt(err, "Can't cd -- $home empty\n"); //$
        break;
    case 2:
        if(a->next->word[0]=='/' || cdpath==nil)
            cdpath = &nullpath;
        for(; cdpath; cdpath = cdpath->next){
            if(cdpath->word[0] != '\0')
                dir = appfile(cdpath->word, a->next->word);
            else
                dir = strdup(a->next->word);

            if(dochdir(dir) >= 0){
                if(cdpath->word[0] != '\0' &&
                    strcmp(cdpath->word, ".") != 0)
                    pfmt(err, "%s\n", dir);
                free(dir);
                setstatus("");
                break;
            }
            free(dir);
        }
        if(cdpath==nil)
            pfmt(err, "Can't cd %s: %r\n", a->next->word);
        break;
    default:
        pfmt(err, "Usage: cd [directory]\n");
        break;
    }
    poplist();
}
@
%$

<<function [[appfile]]>>=
static char *
appfile(char *dir, char *comp)
{
    int dirlen, complen;
    char *s, *p;

    dirlen = strlen(dir);
    complen = strlen(comp);
    s = emalloc(dirlen + 1 + complen + 1);
    memmove(s, dir, dirlen);
    p = s + dirlen;
    *p++ = '/';
    memmove(p, comp, complen);
    p[complen] = '\0';
    return s;
}
@
%ocaml: Filename.concat

% /dev/wdir?

%XXX what is this wdirfd???
<<function [[dochdir]]>>=
errorneg1
dochdir(char *word)
{
    /* report to /dev/wdir if it exists and we're interactive */
    static fdt wdirfd = -2;

    // the actual syscall
    if(chdir(word)<0) 
        return ERROR_NEG1;

    if(flag['i']!=nil){
        if(wdirfd==-2)  /* try only once */
            wdirfd = open("/dev/wdir", OWRITE|OCEXEC);
        if(wdirfd>=0) {
            //fcntl(wdirfd, F_SETFD, FD_CLOEXEC);
            write(wdirfd, word, strlen(word));
        }
    }
    return OK_1;
}
@

\section{[[$ exit]]}
%$

<<function [[execexit]]>>=
void
execexit(void)
{
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: exit [status]\nExiting anyway\n");
        // FALLTHROUGH
    case 2:
        setstatus(runq->argv->words->next->word);
        // FALLTHROUGH
    case 1: 
        Xexit();
    }
}
@

\section{[[$ .]]}
%$ 



<<function [[execdot]]>>=
void
execdot(void)
{
    thread *p = runq;
    bool iflag = false;
    fdt fd;
    list *av;
    char *zero; // new stdin
    char *file;
    word *path;
    <<[[execdot()]] other locals>>

    <<[[execdot()]] if first>>
    <<[[execdot()]] if not first execution>>

    popword(); // "."
    if(p->argv->words && strcmp(p->argv->words->word, "-i")==0){
        iflag = true;
        popword();
    }

    /* get input file */
    if(p->argv->words==nil){
        Xerror1("Usage: . [-i] file [arg ...]");
        return;
    }
    zero = strdup(p->argv->words->word);
    popword();

    fd = -1;
    for(path = searchpath(zero); path; path = path->next){
        if(path->word[0] != '\0')
            file = appfile(path->word, zero);
        else
            file = strdup(zero);

        fd = open(file, 0);
        free(file);
        if(fd >= 0)
            break;
    }
    if(fd<0){
        pfmt(err, "%s: ", zero);
        setstatus("can't open"); // what for? it is reseted by Xerror anyway
        Xerror(".: can't open");
        return;
    }

    /* set up for a new command loop */
    start(dotcmds, 1, (struct Var *)nil);

    pushredir(RCLOSE, fd, 0);
    runq->cmdfile = zero;
    runq->cmdfd = openfd(fd);
    runq->iflag = iflag;

    runq->iflast = false;

    /* push $* value */
    pushlist();
    runq->argv->words = p->argv->words;

    /* free caller's copy of $* */
    av = p->argv;
    p->argv = av->next;
    efree((char *)av);

    /* push $0 value */
    pushlist();
    pushword(zero);

    ndot++;
}
@
%$

<<global [[ndot]]>>=
/*
 * How many dot commands have we executed?
 * Used to ensure that -v flag doesn't print rcmain.
 */
int ndot;
@

<<global [[dotcmds]]>>=
union Code dotcmds[14];
@

<<[[execdot()]] other locals>>=
static bool first = true;
@
<<[[execdot()]] if first>>=
if(first){
    dotcmds[0].i = 1;
    dotcmds[1].f = Xmark;
      dotcmds[2].f = Xword;
      dotcmds[3].s = "0";
    dotcmds[4].f = Xlocal; // will pop_list twice

    dotcmds[5].f = Xmark;
      dotcmds[6].f = Xword;
      dotcmds[7].s="*";
    dotcmds[8].f = Xlocal; // will pop_list twice

    dotcmds[9].f = Xrdcmds; // the REPL

    dotcmds[10].f = Xunlocal;
    dotcmds[11].f = Xunlocal;
    dotcmds[12].f = Xreturn;

    first = false;
}
@
%ocaml: just build at toplevel in an array directly. no need 'first' contorsion




%dead: no support for sun or ucb
%        if(strcmp(file, "/dev/stdin")==0){	/* for sun & ucb */
%            fd = Dup1(0);
%            if(fd>=0)
%                break;
%        }

%dead: because of code removed above
% <<function [[Dup1]]>>=
% int
% Dup1(int)
% {
%     return -1;
% }
% @

\section{[[$ eval]]}
%$

% TODO What is the point of eval? the interpreter loop is already an
% eval that does call Xrdcmds ...

<<function [[execeval]]>>=
void
execeval(void)
{
    char *cmdline, *s, *t;
    int len = 0;
    word *ap;

    if(count(runq->argv->words)<=1){
        Xerror1("Usage: eval cmd ...");
        return;
    }
    eflagok = true;
    for(ap = runq->argv->words->next;ap;ap = ap->next)
        len+=1+strlen(ap->word);

    cmdline = emalloc(len);
    s = cmdline;
    for(ap = runq->argv->words->next;ap;ap = ap->next){
        for(t = ap->word;*t;) *s++=*t++;
        *s++=' ';
    }
    s[-1]='\n';
    poplist();

    execcmds(opencore(cmdline, len));
    efree(cmdline);
}
@

<<global [[rdcmds]]>>=
union Code rdcmds[4];
@

<<function [[execcmds]]>>=
void
execcmds(io *f)
{
    static bool first = true;
    if(first){
        rdcmds[0].i = 1;
        rdcmds[1].f = Xrdcmds;
        rdcmds[2].f = Xreturn;
        first = false;
    }

    start(rdcmds, 1, runq->local);
    runq->cmdfd = f;
    runq->iflast = false;
}
@


\section{[[$ wait]]}
%$

<<function [[execwait]]>>=
void
execwait(void)
{
    switch(count(runq->argv->words)){
    default:
        Xerror1("Usage: wait [pid]");
        return;
    case 2:
        Waitfor(atoi(runq->argv->words->next->word), 0);
        break;
    case 1:
        Waitfor(-1, 0);
        break;
    }
    poplist();
}
@


\chapter{Environment}
\label{chap:environment}

\section{[[Updenv()]]}

% called from Xsimple() and Execute()
% why double? anyway with 'changed' field it should be ok
<<function [[Updenv]]>>=
void
Updenv(void)
{
    var *v, **h;

    for(h = gvar;h!=&gvar[NVAR];h++)
        for(v=*h;v;v = v->next)
            addenv(v);
    if(runq)
        updenvlocal(runq->local);
}
@

<<function [[updenvlocal]]>>=
void
updenvlocal(var *v)
{
    if(v){
        updenvlocal(v->next);
        addenv(v);
    }
}
@


<<enum [[MiscPlan9]]>>=
enum {
    Maxenvname = 256,	/* undocumented limit */
};
@

<<[[Var]] other fields>>=
bool	changed;
@

<<function [[addenv]]>>=
void
addenv(var *v)
{
    char envname[Maxenvname];
    word *w;
    int f;
    io *fd;

    if(v->changed){
        v->changed = false;
        snprint(envname, sizeof envname, "/env/%s", v->name);
        if((f = Creat(envname))<0)
            pfmt(err, "rc: can't open %s: %r\n", envname);
        else{
            for(w = v->val;w;w = w->next)
                write(f, w->word, strlen(w->word)+1L);
            close(f);
        }
    }
    if(v->fnchanged){
        v->fnchanged = false;
        snprint(envname, sizeof envname, "/env/fn#%s", v->name);
        if((f = Creat(envname))<0)
            pfmt(err, "rc: can't open %s: %r\n", envname);
        else{
            if(v->fn){
                fd = openfd(f);
                pfmt(fd, "fn %q %s\n", v->name, v->fn[v->pc-1].s);
                closeio(fd);
            }
            close(f);
        }
    }
}
@



\section{[[Vinit()]]}

% main -> <>
<<function [[Vinit]]>>=
void
Vinit(void)
{
    int dir, f, len, i, n, nent;
    char *buf, *s;
    char envname[Maxenvname];
    word *val;
    Dir *ent;

    dir = open("/env", OREAD);
    if(dir<0){
        pfmt(err, "rc: can't open /env: %r\n");
        return;
    }
    ent = nil;
    for(;;){
        nent = dirread(dir, &ent);
        if(nent <= 0)
            break;
        for(i = 0; i<nent; i++){
            len = ent[i].length;
            if(len && strncmp(ent[i].name, "fn#", 3)!=0){
                snprint(envname, sizeof envname, "/env/%s", ent[i].name);
                if((f = open(envname, 0))>=0){
                    buf = emalloc(len+1);
                    n = readn(f, buf, len);
                    if (n <= 0)
                        buf[0] = '\0';
                    else
                        buf[n] = '\0';
                    val = 0;
                    /* Charitably add a 0 at the end if need be */
                    if(buf[len-1])
                        buf[len++]='\0';
                    s = buf+len-1;
                    for(;;){
                        while(s!=buf && s[-1]!='\0') --s;
                        val = newword(s, val);
                        if(s==buf)
                            break;
                        --s;
                    }
                    setvar(ent[i].name, val);
                    vlook(ent[i].name)->changed = false;
                    close(f);
                    efree(buf);
                }
            }
        }
        free(ent);
    }
    close(dir);
}
@

<<global [[envdir]]>>=
fdt envdir;
@

%\section{Functions in the environment}
% see later with finit


\chapter{Globbing}
\label{chap:globbing}
% could be in advanced topics, but important feature in a shell


\section{Lexing globbing characters}

<<constant [[GLOB]]>>=
/*
 * Glob character escape in strings:
 *	In a string, GLOB must be followed by *?[ or GLOB.
 *	GLOB* matches any string
 *	GLOB? matches any single character
 *	GLOB[...] matches anything in the brackets
 *	GLOBGLOB matches GLOB
 */
#define	GLOB	'\001'
@


<<[[yylex()]] when c is a word character, if glob character>>=
if(c=='*' || c=='[' || c=='?' || c==GLOB)
    w = addtok(w, GLOB);
@

<<function [[addtok]]>>=
char*
addtok(char *p, int val)
{
    if(p==nil)
        return nil;
    if(p >= &tok[NTOK]){
        *p = '\0';
        yyerror("token buffer too short");
        return nil;
    }
    *p++=val;
    return p;
}
@
% diff with addutf()?

\section{Expanding globbing characters}

<<global [[globv]]>>=
struct Word *globv;
@


<<[[Xsimple()]] initializations, [[globlist()]]>>=
globlist();
@

% Xsimple | ... -> <>
<<function [[globlist]]>>=
void
globlist(void)
{
    word *a;
    globv = nil;

    globlist1(runq->argv->words);
    poplist();
    pushlist();

    if(globv){
        for(a = globv;a->next;a = a->next)
            ;
        a->next = runq->argv->words;
        runq->argv->words = globv;
    }
}
@

<<function [[globlist1]]>>=
void
globlist1(word *gl)
{
    if(gl){
        globlist1(gl->next);
        glob(gl->word);
    }
}
@


% Why not add Xglob for SIMPLE cases too? generate a Xglob instead
%  of calling yourself globlist() in Xsimple ?

% outcode (REDIR and FOR cases) -> <>
<<function [[Xglob]]>>=
void
Xglob(void)
{
    globlist();
}
@

\section{[[glob()]]}

<<global [[globname]]>>=
char *globname;
@

<<function [[glob]]>>=
/*
 * Push all file names matched by p on the current thread's stack.
 * If there are no matches, the list consists of p.
 */
void
glob(void *ap)
{
    uchar *p = ap;
    word *svglobv = globv;
    int globlen = Globsize(ap);

    if(!globlen){
        deglob(p);
        globv = newword((char *)p, globv);
        return;
    }
    globname = emalloc(globlen);
    globname[0]='\0';
    globdir(p, (uchar *)globname);
    efree(globname);
    if(svglobv==globv){
        deglob(p);
        globv = newword((char *)p, globv);
    }
    else
        globsort(globv, svglobv);
}
@













<<function [[deglob]]>>=
/*
 * delete all the GLOB marks from s, in place
 */
void
deglob(void *as)
{
    char *s = as;
    char *t = s;
    do{
        if(*t==GLOB)
            t++;
        *s++=*t;
    }while(*t++);
}
@

<<function [[globcmp]]>>=
int
globcmp(const void *s, const void *t)
{
    return strcmp(*(char**)s, *(char**)t);
}
@

<<function [[globsort]]>>=
void
globsort(word *left, word *right)
{
    char **list;
    word *a;
    int n = 0;
    for(a = left;a!=right;a = a->next) n++;
    list = (char **)emalloc(n*sizeof(char *));
    for(a = left,n = 0;a!=right;a = a->next,n++) list[n] = a->word;
    qsort((void *)list, n, sizeof(void *), globcmp);
    for(a = left,n = 0;a!=right;a = a->next,n++) a->word = list[n];
    efree((char *)list);
}
@

<<function [[globdir]]>>=
/*
 * Push names prefixed by globname and suffixed by a match of p onto the astack.
 * namep points to the end of the prefix in globname.
 */
void
globdir(uchar *p, uchar *namep)
{
    uchar *t, *newp;
    int f;
    /* scan the pattern looking for a component with a metacharacter in it */
    if(*p=='\0'){
        globv = newword(globname, globv);
        return;
    }
    t = namep;
    newp = p;
    while(*newp){
        if(*newp==GLOB)
            break;
        *t=*newp++;
        if(*t++=='/'){
            namep = t;
            p = newp;
        }
    }
    /* If we ran out of pattern, append the name if accessible */
    if(*newp=='\0'){
        *t='\0';
        if(access(globname, 0)==0)
            globv = newword(globname, globv);
        return;
    }
    /* read the directory and recur for any entry that matches */
    *namep='\0';
    if((f = Opendir(globname[0]?globname:"."))<0) return;
    while(*newp!='/' && *newp!='\0') newp++;
    while(Readdir(f, namep, *newp=='/')){
        if(matchfn(namep, p)){
            for(t = namep;*t;t++);
            globdir(newp, t);
        }
    }
    Closedir(f);
}
@


<<function [[equtf]]>>=
/*
 * Do p and q point at equal utf codes
 */
bool
equtf(uchar *p, uchar *q)
{
    Rune pr, qr;
    if(*p!=*q)
        return false;
    
    chartorune(&pr, (char*)p);
    chartorune(&qr, (char*)q);
    return pr == qr;
}
@

<<function [[nextutf]]>>=
/*
 * Return a pointer to the next utf code in the string,
 * not jumping past nuls in broken utf codes!
 */
uchar*
nextutf(uchar *p)
{
    Rune dummy;
    return p + chartorune(&dummy, (char*)p);
}
@

<<function [[unicode]]>>=
/*
 * Convert the utf code at *p to a unicode value
 */
int
unicode(uchar *p)
{
    Rune r;

    chartorune(&r, (char*)p);
    return r;
}
@

<<function [[matchfn]]>>=
/*
 * Does the string s match the pattern p
 * . and .. are only matched by patterns starting with .
 * * matches any sequence of characters
 * ? matches any single character
 * [...] matches the enclosed list of characters
 */
bool
matchfn(void *as, void *ap)
{
    uchar *s = as, *p = ap;

    if(s[0]=='.' && (s[1]=='\0' || s[1]=='.' && s[2]=='\0') && p[0]!='.')
        return false;
    return match(s, p, '/');
}
@

<<function [[match]]>>=
bool
match(void *as, void *ap, int stop)
{
    int compl, hit, lo, hi, t, c;
    uchar *s = as, *p = ap;

    for(; *p!=stop && *p!='\0'; s = nextutf(s), p = nextutf(p)){
        if(*p!=GLOB){
            if(!equtf(p, s)) return false;
        }
        else switch(*++p){
        case GLOB:
            if(*s!=GLOB)
                return false;
            break;
        case '*':
            for(;;){
                if(match(s, nextutf(p), stop)) return 1;
                if(!*s)
                    break;
                s = nextutf(s);
            }
            return false;
        case '?':
            if(*s=='\0')
                return false;
            break;
        case '[':
            if(*s=='\0')
                return false;
            c = unicode(s);
            p++;
            compl=*p=='~';
            if(compl)
                p++;
            hit = 0;
            while(*p!=']'){
                if(*p=='\0')
                    return false;		/* syntax error */
                lo = unicode(p);
                p = nextutf(p);
                if(*p!='-')
                    hi = lo;
                else{
                    p++;
                    if(*p=='\0')
                        return false;	/* syntax error */
                    hi = unicode(p);
                    p = nextutf(p);
                    if(hi<lo){ t = lo; lo = hi; hi = t; }
                }
                if(lo<=c && c<=hi)
                    hit = 1;
            }
            if(compl)
                hit=!hit;
            if(!hit)
                return false;
            break;
        }
    }
    return *s=='\0';
}
@





<<constant [[NDIR]]>>=
#define	NDIR	256		/* shoud be a better way */
@

<<function [[Globsize]]>>=
int
Globsize(char *p)
{
    int isglob = 0, globlen = NDIR+1;
    for(;*p;p++){
        if(*p==GLOB){
            p++;
            if(*p!=GLOB)
                isglob++;
            globlen+=*p=='*'?NDIR:1;
        }
        else
            globlen++;
    }
    return isglob?globlen:0;
}
@


<<constant [[NFD]]>>=
#define	NFD	50
@

<<struct [[DirEntryWrapper]]>>=
struct DirEntryWrapper {
    Dir	*dbuf;
    int	i;
    int	n;
};
@
%old: was mixed with dir below and was an anonymous structure

<<global [[dir]]>>=
struct DirEntryWrapper dir[NFD];
@

<<function [[Opendir]]>>=
int
Opendir(char *name)
{
    Dir *db;
    int f;
    f = open(name, 0);
    if(f==-1)
        return f;
    db = dirfstat(f);
    if(db!=nil && (db->mode&DMDIR)){
        if(f<NFD){
            dir[f].i = 0;
            dir[f].n = 0;
        }
        free(db);
        return f;
    }
    free(db);
    close(f);
    return -1;
}
@


<<function [[trimdirs]]>>=
static int
trimdirs(Dir *d, int nd)
{
    int r, w;

    for(r=w=0; r<nd; r++)
        if(d[r].mode&DMDIR)
            d[w++] = d[r];
    return w;
}
@

<<function [[Readdir]]>>=
/*
 * onlydirs is advisory -- it means you only
 * need to return the directories.  it's okay to
 * return files too (e.g., on unix where you can't
 * tell during the readdir), but that just makes 
 * the globber work harder.
 */
int
Readdir(int f, void *p, int onlydirs)
{
    int n;

    if(f<0 || f>=NFD)
        return 0;
Again:
    if(dir[f].i==dir[f].n){	/* read */
        free(dir[f].dbuf);
        dir[f].dbuf = 0;
        n = dirread(f, &dir[f].dbuf);
        if(n>0){
            if(onlydirs){
                n = trimdirs(dir[f].dbuf, n);
                if(n == 0)
                    goto Again;
            }	
            dir[f].n = n;
        }else
            dir[f].n = 0;
        dir[f].i = 0;
    }
    if(dir[f].i == dir[f].n)
        return 0;
    strcpy(p, dir[f].dbuf[dir[f].i].name);
    dir[f].i++;
    return 1;
}
@

<<function [[Closedir]]>>=
void
Closedir(int f)
{
    if(f>=0 && f<NFD){
        free(dir[f].dbuf);
        dir[f].i = 0;
        dir[f].n = 0;
        dir[f].dbuf = 0;
    }
    close(f);
}
@


\chapter{Signals}
\label{chap:signals}

% code of nohup utility?


% C-d generate an Xsimple (exit 1) ?

<<constant [[NSIG]]>>=
#define	NSIG	32
@

<<constant [[SIGINT]]>>=
#define	SIGINT	2
@

<<constant [[SIGQUIT]]>>=
#define	SIGQUIT	3
@


% plan9.c
<<global [[syssigname]]>>=
char *syssigname[] = {
    "exit",		/* can't happen */
    "hangup",
    "interrupt",
    "quit",		/* can't happen */
    "alarm",
    "kill",
    "sys: fp: ",
    "term",
    0
};
@

% plan9.c
<<global [[signame]]>>=
char *signame[] = {
    "sigexit",	
    "sighup",	
    "sigint",	
    "sigquit",
    "sigalrm",	
    "sigkill",	
    "sigfpe",	
    "sigterm",
    0
};
@
%old: was Signame but not consistent naming of globals


<<global [[ntrap]]>>=
int ntrap;				/* number of outstanding traps */
@

<<global [[trap]]>>=
int trap[NSIG];				/* number of outstanding traps per type */
@



% main() -> Trapinit()
<<function [[Trapinit]]>>=
void
Trapinit(void)
{
    notify(notifyf);
}
@

<<function [[notifyf]]>>=
void
notifyf(void*, char *s)
{
    int i;
    for(i = 0;syssigname[i];i++) 
     if(strncmp(s, syssigname[i], strlen(syssigname[i]))==0){
        if(strncmp(s, "sys: ", 5)!=0) 
            interrupted = true;
        goto Out;
    }
    pfmt(err, "rc: note: %s\n", s);
    noted(NDFLT);
    return;
Out:
    if(strcmp(s, "interrupt")!=0 || trap[i]==0){
        trap[i]++;
        ntrap++;
    }
    if(ntrap>=32){	/* rc is probably in a trap loop */
        pfmt(err, "rc: Too many traps (trap %s), aborting\n", s);
        abort();
    }
    noted(NCONT);
}
@


<<[[main()]] handing trap if necessary in interpreter loop>>=
if(ntrap)
    dotrap();
@




% trap.c
% main() -> dotrap() after having interpreter one bytecode
<<function [[dotrap]]>>=
void
dotrap(void)
{
    int i;
    struct Var *trapreq;
    struct Word *starval;

    starval = vlook("*")->val;
    while(ntrap) 
     for(i = 0;i!=NSIG;i++) 
      while(trap[i]){
        --trap[i];
        --ntrap;
        if(getpid()!=mypid) 
            Exit(getstatus());
        trapreq = vlook(signame[i]);
        if(trapreq->fn){
            start(trapreq->fn, trapreq->pc, (struct Var *)nil);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)nil);
            runq->local->changed = true;
            runq->redir = runq->startredir = nil;
        }
        else if(i==SIGINT || i==SIGQUIT){
            /*
             * run the stack down until we uncover the
             * command reading loop.  Xreturn will exit
             * if there is none (i.e. if this is not
             * an interactive rc.)
             */
            while(!runq->iflag) 
                Xreturn();
        }
        else 
            Exit(getstatus());
    }
}
@




<<global [[interrupted]]>>=
bool interrupted = false;
@

<<function [[Eintr]]>>=
bool
Eintr(void)
{
    return interrupted;
}
@


<<[[Xrdcmds()]] calls Noerror() before yyparse()>>=
Noerror();
@

<<function [[Noerror]]>>=
void
Noerror(void)
{
    interrupted = false;
}
@

<<[[Xrdcmds()]] reset ntrap>>=
ntrap = 0;	/* avoid double-interrupts during blocked writes */
@


\chapter{Initialization}
\label{chap:initialization-real}

\section{Actual bootstrapping code and [[rc -m /path/to/rcmain]]}

% see main() comment:
% * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)

%main() -> bootstrap -> execdot -> Xreadcmds() -> yyparse() -> compile() -> outcode() -> back to interpreter loop with new codebuf (chained to bootstrap)

%plan9.c
<<global [[Rcmain]]>>=
char *Rcmain = "/rc/lib/rcmain";
@

<<[[main()]] locals>>=
char *rcmain;
@

<<[[main()]] initialisation>>=
rcmain = flag['m'] ? flag['m'][0] : Rcmain; 
@
% can change startup script, -m 

%OPTIONAL
<<[[main()]] initialize [[boostrap]]>>=
memset(bootstrap, 0, sizeof bootstrap);

i = 0;
bootstrap[i++].i=1;
// runq->argv is populated with the arguments to rc
// we just need to add '*=(argv)'
bootstrap[i++].f = Xmark;
  bootstrap[i++].f = Xword;
  bootstrap[i++].s="*";
bootstrap[i++].f = Xassign; // will pop_list() x2

bootstrap[i++].f = Xmark;
  bootstrap[i++].f = Xmark;
    bootstrap[i++].f = Xword;
    bootstrap[i++].s="*";
  bootstrap[i++].f = Xdol; // will pop_list()
  bootstrap[i++].f = Xword;
  bootstrap[i++].s = rcmain;
  bootstrap[i++].f = Xword;
  bootstrap[i++].s=".";
bootstrap[i++].f = Xsimple; // will pop_list()

bootstrap[i++].f = Xexit;

bootstrap[i].i = 0;
@
%new: I indented to better see which Xmark correspond to what.

% It is Xassign (varname)(vals)
% but there is only one XMark above. Because runq->argv is initialized
%  with argv[]

\t how endup in REPL after . has finished executing rcmain then ??
\t  I think because rcmain contains call to finit?

% show rc foo bar -r
% great resource to see the bytecodes, argv.


\section{Actual environment}

<<global [[mypid]]>>=
int mypid;
@

<<[[main()]] locals>>=
char num[12];
@
%ocaml: no need for declaration, just do  'let num = int_to_string(mypid)'

<<[[main()]] initialisation>>=
mypid = getpid();
inttoascii(num, mypid);
setvar("pid", newword(num, (word *)nil));
@

<<[[main()]] initialisation>>=
setvar("rcname", newword(argv[0], (word *)nil));
@


% cflag will contain the -c arguments!




\chapter{Advanced Topics TODO}
\label{chap:advanced-topics}

\section{Reading commands from a string: [[rc -c]]}

<<[[main()]] initialisation>>=
setvar("cflag", flag['c']? newword(flag['c'][0], (word *)nil) : (word *)nil);
@

\section{Failing fast: [[rc -e]]}


<<[[outcode()]] emit Xeflag after Xsimple>>=
if(eflag)
    emitf(Xeflag);
@

% super important actually, remember in recursive make 
% where a failure in a subsubdir should stop the entire thing. 
% Fortunately mk calls rc with -e so any error in a loop for 
% instance stop the whole thing
% (but not error  in   X || Y, nor error in if (X), etc, so
% need do eflag check only a certain places)

<<global [[eflagok]]>>=
bool eflagok;	/* kludge flag so that -e doesn't exit in startup */
@
% who sets that? execdot, execval

<<[[execdot()]] if not first execution>>=
else
    eflagok = true;
@

<<function [[Xeflag]]>>=
void
Xeflag(void)
{
    if(eflagok && !truestatus()) 
        Xexit();
}
@

% exit at first error!
% kind of a 'use strict;' :)

% very useful

\section{Unicode}

<<function [[addutf]]>>=
char*
addutf(char *p, int c)
{
    uchar b, m;
    int i;

    p = addtok(p, c);	/* 1-byte UTF runes are special */
    if(c < Runeself)
        return p;

    m = 0xc0;
    b = 0x80;
    for(i=1; i < UTFmax; i++){
        if((c&m) == b)
            break;
        p = addtok(p, advance());
        b = m;
        m = (m >> 1)|0x80;
    }
    return p;
}
@

\section{Advanced constructs}



\subsection{Subshell: [[@ <cmd>]]}

% why need that? () not enough? { } not enough?
% no because side effect done in { } will be propagated, e.g., cd!
% any side effect in command such as setting variables will not be seen 
% in parent process.

% see mkfile for plan9:
%.directories:V:
%	for(i in $DIRS) @{
%		cd $i
%		echo $i/
%		mk $MKFLAGS $stem
%	}
\t also why -e does not work here!! does not stop!! because in subshell?


<<token declarations>>=
%token SUBSHELL /** @ */
@

% @ xxx
<<cmd rule other cases>>=
|   SUBSHELL cmd        {$$=mung1($1, $2);}
@


<<[[outcode()]] cases>>=
case SUBSHELL:
    emitf(Xsubshell);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    if(eflag)
        emitf(Xeflag);
    break;
@

% * Xsubshell{... Xexit}		execute {} in a subshell and wait


<<function [[Xsubshell]]>>=
void
Xsubshell(void)
{
    int pid;
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        start(runq->code, runq->pc+1, runq->local);
        runq->ret = nil;
        break;
    default: // parent
        addwaitpid(pid);
        Waitfor(pid, 1);
        runq->pc = runq->code[runq->pc].i;
        break;
    }
}
@



\subsection{Here documents: [[<< <HERE>]]}
% >>

% again spirit of interactive REPL. enter data from command line.
% Yes, but more importantly, ancestor of Bundle! Prog and data
% in one file. Can have a script with a database (see example
% of 'tel' command in Bourne paper) included in the file.
% can mv around the script. no problem.

<<constant [[HERE]]>>=
#define	HERE	4
@

<<[[yylex()]] in switch when redirection character, if here document>>=
if(nextis(c)){
    t->rtype = HERE;
    *w++=c;
}
@
\t mv c to '<' ?

<<struct [[Here]]>>=
struct Here {
    tree	*tag;
    char	*name;
    struct Here *next;
};
@

<<global [[here]]>>=
struct Here *here;
@


<<global [[ehere]]>>=
struct Here **ehere;
@


<<constant [[NLINE]]>>=
/*
 * bug: lines longer than NLINE get split -- this can cause spurious
 * missubstitution, or a misrecognized EOF marker.
 */
#define	NLINE	4096
@


<<[[compile()]] after outcode and error management, read heredoc>>=
readhere();
@

<<function [[readhere]]>>=
void
readhere(void)
{
    int c, subst;
    char *s, *tag;
    char line[NLINE+1];
    io *f;
    struct Here *h, *nexth;

    for(h = here; h; h = nexth){
        subst = !h->tag->quoted;
        tag = h->tag->str;
        c = Creat(h->name);
        if(c < 0)
            yyerror("can't create here document");
        f = openfd(c);
        s = line;
        pprompt();
        while((c = rchr(runq->cmdfd)) != EOF){
            if(c == '\n' || s == &line[NLINE]){
                *s = '\0';
                if(tag && strcmp(line, tag) == 0)
                    break;
                if(subst)
                    psubst(f, (uchar *)line);
                else
                    pstr(f, line);
                s = line;
                if(c == '\n'){
                    pprompt();
                    pchr(f, c);
                }else
                    *s++ = c;
            }else
                *s++ = c;
        }
        flush(f);
        closeio(f);
        cleanhere(h->name);
        nexth = h->next;
        efree((char *)h);
    }
    here = nil;
    doprompt = true;
}
@


<<function [[cleanhere]]>>=
void
cleanhere(char *f)
{
    emitf(Xdelhere);
    emits(strdup(f));
}
@

<<function [[Xdelhere]]>>=
void
Xdelhere(void)
{
    Unlink(runq->code[runq->pc++].s);
}
@

<<function [[Unlink]]>>=
void
Unlink(char *name)
{
    remove(name);
}
@




<<global [[ser]]>>=
int ser = 0;
@

<<global tmp (rc/here.c)>>=
char tmp[] = "/tmp/here0000.0000";
@

<<global [[hex]]>>=
char hex[] = "0123456789abcdef";
@

<<function [[hexnum]]>>=
void
hexnum(char *p, int n)
{
    *p++ = hex[(n>>12)&0xF];
    *p++ = hex[(n>>8)&0xF];
    *p++ = hex[(n>>4)&0xF];
    *p = hex[n&0xF];
}
@

<<function [[heredoc]]>>=
//@Scheck: used by syn.y
tree* heredoc(tree *tag)
{
    struct Here *h = new(struct Here);

    if(tag->type != WORD)
        yyerror("Bad here tag");
    h->next = 0;
    if(here)
        *ehere = h;
    else
        here = h;
    ehere = &h->next;
    h->tag = tag;
    hexnum(&tmp[9], getpid());
    hexnum(&tmp[14], ser++);
    h->name = strdup(tmp);
    return token(tmp, WORD);
}
@


<<function [[psubst]]>>=
void
psubst(io *f, uchar *s)
{
    int savec, n;
    uchar *t, *u;
    Rune r;
    word *star;

    while(*s){
        if(*s != '$'){		/* copy plain text rune */
            if(*s < Runeself)
                pchr(f, *s++);
            else{
                n = chartorune(&r, (char *)s);
                while(n-- > 0)
                    pchr(f, *s++);
            }
        }else{			/* $something -- perform substitution */
            t = ++s;
            if(*t == '$')
                pchr(f, *t++);
            else{
                while(*t && idchr(*t))
                    t++;
                savec = *t;
                *t = '\0';
                n = 0;
                for(u = s; *u && '0' <= *u && *u <= '9'; u++)
                    n = n*10 + *u - '0';
                if(n && *u == '\0'){
                    star = vlook("*")->val;
                    if(star && 1 <= n && n <= count(star)){
                        while(--n)
                            star = star->next;
                        pstr(f, star->word);
                    }
                }else
                    pstrs(f, vlook((char *)s)->val);
                *t = savec;
                if(savec == '^')
                    t++;
            }
            s = t;
        }
    }
}
@
%$

<<function [[pstrs]]>>=
void
pstrs(io *f, word *a)
{
    if(a){
        while(a->next && a->next->word){
            pstr(f, a->word);
            pchr(f, ' ');
            a = a->next;
        }
        pstr(f, a->word);
    }
}
@

\subsection{Read-write redirections: [[<> <file>]]}

<<constant [[RDWR]]>>=
#define RDWR	7
@


<<[[yylex()]] in switch when redirection character, if read/write redirect>>=
else if (nextis('>')){
    t->rtype = RDWR;
    *w++=c;
}
@

<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case RDWR:
    emitf(Xrdwr);
    break;
@

<<function [[Xrdwr]]>>=
void
Xrdwr(void)
{
    char *file;
    int f;

    switch(count(runq->argv->words)){
    default:
        Xerror1("<> requires singleton\n");
        return;
    case 0:
        Xerror1("<> requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, ORDWR))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@


\subsection{General redirections: [[>[2] <file>]]}

% fancy lexing redirect, see rc manual

% Lexing

<<[[yylex()]] in switch when redirection character, if bracket after>>=
if(nextis('[')){
    *w++='[';
    c = advance();
    *w++=c;
    if(c<'0' || '9'<c){
    RedirErr:
        *w = 0;
        yyerror(t->type==PIPE?"pipe syntax"
                :"redirection syntax");
        return EOF;
    }
    t->fd0 = 0;
    do{
        t->fd0 = t->fd0*10 + c-'0';
        *w++=c;
        c = advance();
    }while('0'<=c && c<='9');

    if(c=='='){
        *w++='=';
        if(t->type==REDIR)
            // change the token type
            t->type = DUP;
        c = advance();
        if('0'<=c && c<='9'){
            t->rtype = DUPFD;
            t->fd1 = t->fd0;
            t->fd0 = 0;
            do{
                t->fd0 = t->fd0*10+c-'0';
                *w++=c;
                c = advance();
            }while('0'<=c && c<='9');
        }
        else{
            if(t->type==PIPE)
                goto RedirErr;
            t->rtype = CLOSE;
        }
    }
    if(c!=']'
    || t->type==DUP && (t->rtype==HERE || t->rtype==APPEND))
        goto RedirErr;
    *w++=']';
}
@


<<constant [[CLOSE]]>>=
#define	CLOSE	6
@


\subsection{Advanced dup: [[>[<fd0>=<fd1>]] ], [[<>[<fd0>=<fd1>] ]], [[<[<fd0>=<fd1>] ]]}

% so can print on stderr with echo in kmem.rc:
%	echo 'usage: kmem [kernel]' >[1=2]

<<token declarations>>=
%token DUP
@

<<redir rule other cases>>=
|   DUP
@
% does not take any word


<<constant [[DUPFD]]>>=
#define	DUPFD	5
@



<<[[outcode()]] cases>>=
case DUP:
    if(t->rtype==DUPFD){
        emitf(Xdup);
        emiti(t->fd0);
        emiti(t->fd1);
    }
    else{
        emitf(Xclose);
        emiti(t->fd0);
    }
    outcode(c1, eflag);
    emitf(Xpopredir);
    break;
@

<<function [[Xdup]]>>=
void
Xdup(void)
{
    pushredir(RDUP, runq->code[runq->pc].i, runq->code[runq->pc+1].i);
    runq->pc+=2;
}
@

<<constant [[RDUP]]>>=
#define	RDUP	2			/* dup2(from, to); */
@


<<constant [[RCLOSE]]>>=
#define	RCLOSE	3			/* close(from); */
@

<<function [[Xclose]]>>=
void
Xclose(void)
{
    pushredir(RCLOSE, runq->code[runq->pc].i, 0);
    runq->pc++;
}
@


<<[[doredir()]] switch redir type cases>>=
case RDUP:
    Dup(rp->from, rp->to);
    break;
@

<<[[doredir()]] switch redir type cases>>=
case RCLOSE:
    close(rp->from);
    break;
@



\subsection{Advanced pipes: [[|[<fd>] ]], [[|[<fd0>=<fd1>] ]]}

% see man/1/rc:



\subsection{Command output as a file: \texttt{'<\{<cmd>\}'}}

<<comword rule other cases>>=
|   REDIR brace     {$$=mung1($1, $2); $$->type=PIPEFD;}
@

% see man/1/rc:
% cmp <{old} <{new}

% it is in comword rule because really it resolved in a filename
% to /dev/fd/xxx connected to output of command.


<<token declarations>>=
%token PIPEFD 
@

% * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output,
% * 					depending on type), push /dev/fd/??

<<[[outcode()]] cases>>=
case PIPEFD:
    emitf(Xpipefd);
    emiti(t->rtype);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    break;
@



<<global [[Fdprefix]]>>=
char *Fdprefix = "/fd/";
@

<<function [[Xpipefd]]>>=
void
Xpipefd(void)
{
    struct Thread *p = runq;
    int pc = p->pc, pid;
    char name[40];
    int pfd[2];
    int sidefd, mainfd;
    if(pipe(pfd)<0){
        Xerror("can't get pipe");
        return;
    }
    if(p->code[pc].i==READ){
        sidefd = pfd[PWR];
        mainfd = pfd[PRD];
    }
    else{
        sidefd = pfd[PRD];
        mainfd = pfd[PWR];
    }
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        start(p->code, pc+2, runq->local);
        close(mainfd);
        pushredir(ROPEN, sidefd, p->code[pc].i==READ?1:0);
        runq->ret = 0;
        break;
    default: // parent
        addwaitpid(pid);
        close(sidefd);
        pushredir(ROPEN, mainfd, mainfd);	/* isn't this a noop? */
        strcpy(name, Fdprefix);
        inttoascii(name+strlen(name), mainfd);
        pushword(name);
        p->pc = p->code[pc+1].i;
        break;
    }
}
@



\subsection{Command substitution: \texttt{`\{<cmd>\}}}
% Command output as arguments

% by using `{} instead of ``
% it allows to easily nest (see Design chapter in rc paper).

<<comword rule other cases>>=
|   '`' brace       {$$=tree1('`', $2);}
@
%$
% rc use the `{} syntax for backquote (See Make.nw)


<<[[outcode()]] cases>>=
case '`':
    emitf(Xbackq);
    p = emiti(0);
    outcode(c0, false);
    emitf(Xexit);
    stuffdot(p);
    break;
@
% false eflag here

% * Xbackq{... Xreturn}			make thread for {}, push stdout

<<function [[Xbackq]]>>=
/*
 * Who should wait for the exit from the fork?
 */
void
Xbackq(void)
{
    int n, pid;
    int pfd[2];
    char *stop;
    char utf[UTFmax+1];
    struct Io *f;
    var *ifs = vlook("ifs");
    word *v, *nextv;
    Rune r;
    String *word;

    stop = ifs->val? ifs->val->word: "";
    if(pipe(pfd)<0){
        Xerror("can't make pipe");
        return;
    }
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        close(pfd[PRD]);
        close(pfd[PWR]);
        return;
    case 0: // child
        clearwaitpids();
        close(pfd[PRD]);
        start(runq->code, runq->pc+1, runq->local);
        pushredir(ROPEN, pfd[PWR], 1);
        return;
    default: // parent
        addwaitpid(pid);
        close(pfd[PWR]);
        f = openfd(pfd[PRD]);
        word = s_new();
        v = nil;
        /* rutf requires at least UTFmax+1 bytes in utf */
        while((n = rutf(f, utf, &r)) != EOF){
            utf[n] = '\0';
            if(utfutf(stop, utf) == nil)
                s_nappend(word, utf, n);
            else
                /*
                 * utf/r is an ifs rune (e.g., \t, \n), thus
                 * ends the current word, if any.
                 */
                if(s_len(word) > 0){
                    v = newword(s_to_c(word), v);
                    s_reset(word);
                }
        }
        if(s_len(word) > 0)
            v = newword(s_to_c(word), v);
        s_free(word);
        closeio(f);
        Waitfor(pid, 0);
        /* v points to reversed arglist -- reverse it onto argv */
        while(v){
            nextv = v->next;
            v->next = runq->argv->words;
            runq->argv->words = v;
            v = nextv;
        }
        runq->pc = runq->code[runq->pc].i;
        return;
    }
}
@



\subsection{Stringification of variables: [[$"<foo>]]} %$

<<comword rule other cases>>=
|   '"' word        {$$=tree1('"', $2);}
@
%$
% no ending "? No, it is used for stringification of a variable.
% a list2str.

<<[[outcode()]] cases>>=
case '"':
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xqdol);
    break;
@


<<function [[Xqdol]]>>=
void
Xqdol(void)
{
    word *a, *p;
    char *s;
    int n;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);
    a = vlook(s)->val;
    poplist();
    n = count(a);
    if(n==0){
        pushword("");
        return;
    }
    for(p = a;p;p = p->next) n+=strlen(p->word);
    s = emalloc(n);
    if(a){
        strcpy(s, a->word);
        for(p = a->next;p;p = p->next){
            strcat(s, " ");
            strcat(s, p->word);
        }
    }
    else
        s[0]='\0';
    pushword(s);
    efree(s);
}
@


\section{Advanced builtins}

% could have echo here. and test. but true that they can also
% be external programs.

% has read? How can you read from a script?

\subsection{[[$ exec]]}
%$

% actually called from Xsimple()
% but it complicates the code.
% I was not sure you really need that builtin, but
% many scripts use it.


\subsection{[[$ whatis]]}
%$

<<function [[execwhatis]]>>=
void
execwhatis(void){   /* mildly wrong -- should fork before writing */
    word *a, *b, *path;
    var *v;
    struct Builtin *bp;
    char *file;
    struct Io out[1];
    int found, sep;
    a = runq->argv->words->next;
    if(a==0){
        Xerror1("Usage: whatis name ...");
        return;
    }
    setstatus("");
    memset(out, 0, sizeof out);
    out->fd = mapfd(1);
    out->bufp = out->buf;
    out->ebuf = &out->buf[NBUF];
    out->strp = nil;
    for(;a;a = a->next){
        v = vlook(a->word);
        if(v->val){
            pfmt(out, "%s=", a->word);
            if(v->val->next==0)
                pfmt(out, "%q\n", v->val->word);
            else{
                sep='(';
                for(b = v->val;b && b->word;b = b->next){
                    pfmt(out, "%c%q", sep, b->word);
                    sep=' ';
                }
                pfmt(out, ")\n");
            }
            found = 1;
        }
        else
            found = 0;
        v = gvlook(a->word);
        if(v->fn)
            pfmt(out, "fn %q %s\n", v->name, v->fn[v->pc-1].s);
        else{
            for(bp = builtins;bp->name;bp++)
                if(strcmp(a->word, bp->name)==0){
                    pfmt(out, "builtin %s\n", a->word);
                    break;
                }
            if(!bp->name){
                for(path = searchpath(a->word); path;
                    path = path->next){
                    if(path->word[0] != '\0')
                        file = appfile(path->word, a->word);
                    else
                        file = strdup(a->word);
                    if(Executable(file)){
                        pfmt(out, "%s\n", file);
                        free(file);
                        break;
                    }
                    free(file);
                }
                if(!path && !found){
                    pfmt(err, "%s: not found\n", a->word);
                    setstatus("not found");
                }
            }
        }
    }
    poplist();
    flush(err);
}
@

<<function [[mapfd]]>>=
int
mapfd(int fd)
{
    redir *rp;
    for(rp = runq->redir;rp;rp = rp->next){
        switch(rp->type){
        case RCLOSE:
            if(rp->from==fd)
                fd=-1;
            break;
        case RDUP:
        case ROPEN:
            if(rp->to==fd)
                fd = rp->from;
            break;
        }
    }
    return fd;
}
@


<<function [[Executable]]>>=
bool
Executable(char *file)
{
    Dir *statbuf;
    bool ret;

    statbuf = dirstat(file);
    if(statbuf == nil)
        return false;
    ret = ((statbuf->mode&0111)!=0 && (statbuf->mode&DMDIR)==0);
    free(statbuf);
    return ret;
}
@



\subsection{[[$ rfork]]}
%$

%rfork
<<function [[execnewpgrp]]>>=
void
execnewpgrp(void)
{
    int arg;
    char *s;
    switch(count(runq->argv->words)){
    case 1:
        arg = RFENVG|RFNAMEG|RFNOTEG;
        break;
    case 2:
        arg = 0;
        for(s = runq->argv->words->next->word;*s;s++) switch(*s){
        default:
            goto Usage;
        case 'n':
            arg|=RFNAMEG;  break;
        case 'N':
            arg|=RFCNAMEG;
            break;
        case 'm':
            arg|=RFNOMNT;  break;
        case 'e':
            arg|=RFENVG;   break;
        case 'E':
            arg|=RFCENVG;  break;
        case 's':
            arg|=RFNOTEG;  break;
        case 'f':
            arg|=RFFDG;    break;
        case 'F':
            arg|=RFCFDG;   break;
        }
        break;
    default:
    Usage:
        pfmt(err, "Usage: %s [fnesFNEm]\n", runq->argv->words->word);
        setstatus("rfork usage");
        poplist();
        return;
    }
    if(rfork(arg)==-1){
        pfmt(err, "rc: %s failed\n", runq->argv->words->word);
        setstatus("rfork failed");
    }
    else
        setstatus("");
    poplist();
}
@

\subsection{[[$ flag]]}
%$

<<function [[execflag]]>>=
void
execflag(void)
{
    char *letter, *val;

    switch(count(runq->argv->words)){
    case 2:
        setstatus(flag[(uchar)runq->argv->words->next->word[0]]?"":"flag not set");
        break;
    case 3:
        letter = runq->argv->words->next->word;
        val = runq->argv->words->next->next->word;
        if(strlen(letter)==1){
            if(strcmp(val, "+")==0){
                flag[(uchar)letter[0]] = flagset;
                break;
            }
            if(strcmp(val, "-")==0){
                flag[(uchar)letter[0]] = 0;
                break;
            }
        }
    default:
        Xerror1("Usage: flag [letter] [+-]");
        return;
    }
    poplist();
}
@

\subsection{[[$ shift]]}
%$

<<function [[execshift]]>>=
void
execshift(void)
{
    int n;
    word *a;
    var *star;
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: shift [n]\n");
        setstatus("shift usage");
        poplist();
        return;
    case 2:
        n = atoi(runq->argv->words->next->word);
        break;
    case 1:
        n = 1;
        break;
    }
    star = vlook("*");
    for(;n && star->val;--n){
        a = star->val->next;
        efree(star->val->word);
        efree((char *)star->val);
        star->val = a;
        star->changed = true;
    }
    setstatus("");
    poplist();
}
@


\subsection{[[$ finit]]}
%$

<<global [[rdfns]]>>=
union Code rdfns[4];
@

% "finit" builtin -> <>
<<function [[execfinit]]>>=
void
execfinit(void)
{
    static bool first = true;
    if(first){
        rdfns[0].i = 1;
        rdfns[1].f = Xrdfn;
        rdfns[2].f = Xjump;
        rdfns[3].i = 1;
        first = false;
    }
    Xpopm(); // pop_list()
    envdir = open("/env", 0);
    if(envdir<0){
        pfmt(err, "rc: can't open /env: %r\n");
        return;
    }
    start(rdfns, 1, runq->local);
}
@
\l should call pop_list(), not Xpopm

% really need that? nice that enclosing script
% can define function that can be used in callee
% bug could also do it by using '.'
<<function [[Xrdfn]]>>=
void
Xrdfn(void)
{
    int f, len;
    Dir *e;
    char envname[Maxenvname];
    static Dir *ent, *allocent;
    static int nent;

    for(;;){
        if(nent == 0){
            free(allocent);
            nent = dirread(envdir, &allocent);
            ent = allocent;
        }
        if(nent <= 0)
            break;
        while(nent){
            e = ent++;
            nent--;
            len = e->length;
            if(len && strncmp(e->name, "fn#", 3)==0){
                snprint(envname, sizeof envname, "/env/%s", e->name);
                if((f = open(envname, 0))>=0){
                    execcmds(openfd(f));
                    return;
                }
            }
        }
    }
    close(envdir);
    Xreturn();
}
@



\chapter{Conclusion}
\label{chap:conclusion}

% Lex and Yacc to understand some parts. 
% Kernel for other parts.

% future work:more interactive! need readline. 

%  - interactive filename completion with TAB (readline, need raw mode)
%    (but apparently rio has some support for it)
%  - command completion with TAB
%  - history with arrow keys
%    (rio has kinda, just go up in the window and copy paste)
%  - history search (C-r)
%  - aliases 
%    (just use fn and saves them somewhere so persistent)
%  - pushd/popd (but could be functions?)
%  - job control (bg, fg)
%    (but can do  'wait $apid')
%  - C-z??? bourne says early-sh had 'wait is interruptible'
%  - fish features!


\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

\section{AST dumper}

% used only for saving functions in the env for now, so could
%  be moved earlier.

% pcmd.c

<<global [[nl]]>>=
char nl='\n';		/* change to semicolon for bourne-proofing */
@

% TODO ugly and dupe with the one in code.c
<<constant [[c0]]>>=
#define	c0	t->child[0]
@

<<constant [[c1]]>>=
#define	c1	t->child[1]
@

<<constant [[c2]]>>=
#define	c2	t->child[2]
@

% simplemung | fnstr -> pfmt %t -> <>
<<function [[pcmd]]>>=
void
pcmd(io *f, tree *t)
{
    if(t==nil)
        return;
    assert(f != nil);

    switch(t->type){
    case '$':	pfmt(f, "$%t", c0); break;
    case '"':	pfmt(f, "$\"%t", c0); break;
    case '&':	pfmt(f, "%t&", c0); break;
    case '^':	pfmt(f, "%t^%t", c0, c1); break;
    case '`':	pfmt(f, "`%t", c0); break;
    case ANDAND:pfmt(f, "%t && %t", c0, c1); break;
    case OROR:	pfmt(f, "%t || %t", c0, c1); break;
    case BANG:	pfmt(f, "! %t", c0); break;
    case BRACE:	pfmt(f, "{%t}", c0); break;
    case COUNT:	pfmt(f, "$#%t", c0); break;
    case FN:	pfmt(f, "fn %t %t", c0, c1); break;
    case IF:	pfmt(f, "if%t%t", c0, c1); break;
    case NOT:	pfmt(f, "if not %t", c0); break;
    case PCMD:
    case PAREN:	pfmt(f, "(%t)", c0); break;
    case SUB:	pfmt(f, "$%t(%t)", c0, c1); break;
    case SIMPLE:	pfmt(f, "%t", c0); break;
    case SUBSHELL:	pfmt(f, "@ %t", c0); break;
    case SWITCH:	pfmt(f, "switch %t %t", c0, c1); break;
    case TWIDDLE:	pfmt(f, "~ %t %t", c0, c1); break;
    case WHILE:		pfmt(f, "while %t%t", c0, c1); break;

    case ARGLIST:
        if(c0==nil)
            pfmt(f, "%t", c1);
        else if(c1==nil)
            pfmt(f, "%t", c0);
        else
            pfmt(f, "%t %t", c0, c1);
        break;
    case ';':
        if(c0){
            if(c1)
                pfmt(f, "%t%c%t", c0, nl, c1);
            else pfmt(f, "%t", c0);
        }
        else pfmt(f, "%t", c1);
        break;
    case WORDS:
        if(c0)
            pfmt(f, "%t ", c0);
        pfmt(f, "%t", c1);
        break;
    case FOR:
        pfmt(f, "for(%t", c0);
        if(c1)
            pfmt(f, " in %t", c1);
        pfmt(f, ")%t", c2);
        break;
    case WORD:
        if(t->quoted)
            pfmt(f, "%Q", t->str);
        else pdeglob(f, t->str);
        break;
    case DUP:
        if(t->rtype==DUPFD)
            pfmt(f, ">[%d=%d]", t->fd1, t->fd0); /* yes, fd1, then fd0; read lex.c */
        else
            pfmt(f, ">[%d=]", t->fd0);
        pfmt(f, "%t", c1);
        break;
    case PIPEFD:
    case REDIR:
        switch(t->rtype){
        case HERE:
            pchr(f, '<');
        case READ:
        case RDWR:
            pchr(f, '<');
            if(t->rtype==RDWR)
                pchr(f, '>');
            if(t->fd0!=0)
                pfmt(f, "[%d]", t->fd0);
            break;
        case APPEND:
            pchr(f, '>');
        case WRITE:
            pchr(f, '>');
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
            break;
        }
        pfmt(f, "%t", c0);
        if(c1)
            pfmt(f, " %t", c1);
        break;
    case '=':
        pfmt(f, "%t=%t", c0, c1);
        if(c2)
            pfmt(f, " %t", c2);
        break;
    case PIPE:
        pfmt(f, "%t|", c0);
        if(t->fd1==0){
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
        }
        else pfmt(f, "[%d=%d]", t->fd0, t->fd1);
        pfmt(f, "%t", c1);
        break;

    default:	
        pfmt(f, "bad cmd %d %p %p %p", t->type, c0, c1, c2);
        break;
    }
}
@
%$

% pcmd -> <>
<<function [[pdeglob]]>>=
void
pdeglob(io *f, char *s)
{
    while(*s){
        if(*s==GLOB)
            s++;
        pchr(f, *s++);
    }
}
@




\section{Bytecode dumper: [[rc -r]]}

% nice output:

%  % ls
%  pid 20834 cycle 00007F7FF3F00400 1 Xmark
%  pid 20834 cycle 00007F7FF3F00400 2 Xword ()
%  pid 20834 cycle 00007F7FF3F00400 4 Xsimple (ls)
%  CHANGES       LICENSE	TODO  config	 dist  include	    install.txt  lp    man   plumb	 rcmain  tmac
%  CONTRIBUTORS  Makefile	acid  configure  face  install.log  lib		 mac   ndb   postscript  sky	 troff
%  INSTALL       README	bin   dict	 font  install.sum  log		 mail  news  proto	 src	 unix
%  pid 20834 cycle 00007F7FF3F00400 5 Xreturn
%  pid 20834 cycle 000000010E241DB0 9 Xrdcmds

% useful to debug compile(), interpreter, pids, etc.

<<[[main()]] debug runq in interpreter loop>>=
if(flag['r'])
    pfnc(err, runq);
@

% pfnc.c
<<global [[fname]]>>=
struct{
    void	(*f)(void);
    char	*name;
} fname[] = {
    Xappend, "Xappend",
    Xassign, "Xassign",
    Xasync, "Xasync",
    Xbackq, "Xbackq",
    Xbang, "Xbang",
    Xcase, "Xcase",
    Xclose, "Xclose",
    Xconc, "Xconc",
    Xcount, "Xcount",
    Xdelfn, "Xdelfn",
    Xdelhere, "Xdelhere",
    Xdol, "Xdol",
    Xdup, "Xdup",
    Xeflag, "Xeflag",
    (void (*)(void))Xerror, "Xerror",
    Xexit, "Xexit",
    Xfalse, "Xfalse",
    Xfn, "Xfn",
    Xfor, "Xfor",
    Xglob, "Xglob",
    Xif, "Xif",
    Xifnot, "Xifnot",
    Xjump, "Xjump",
    Xlocal, "Xlocal",
    Xmark, "Xmark",
    Xmatch, "Xmatch",
    Xpipe, "Xpipe",
    Xpipefd, "Xpipefd",
    Xpipewait, "Xpipewait",
    Xpopm, "Xpopm",
    Xpopredir, "Xpopredir",
    Xqdol, "Xqdol",
    Xrdcmds, "Xrdcmds",
    Xrdfn, "Xrdfn",
    Xrdwr, "Xrdwr",
    Xread, "Xread",
    Xreturn, "Xreturn",
    Xsimple, "Xsimple",
    Xsub, "Xsub",
    Xsubshell, "Xsubshell",
    Xtrue, "Xtrue",
    Xunlocal, "Xunlocal",
    Xwastrue, "Xwastrue",
    Xword, "Xword",
    Xwrite, "Xwrite",
    0
};
@

% fnc??
% called from main interpreter loop, also called from pfmt %?
<<function [[pfnc]]>>=
void
pfnc(io *fd, thread *t)
{
    int i;
    void (*fn)(void) = t->code[t->pc].f;
    list *a;

    pfmt(fd, "pid %d cycle %p %d ", getpid(), t->code, t->pc);
    for (i = 0; fname[i].f; i++) 
        if (fname[i].f == fn) {
            pstr(fd, fname[i].name);
            break;
        }
    if (!fname[i].f)
        pfmt(fd, "%p", fn);
    for (a = t->argv; a; a = a->next) 
        pfmt(fd, " (%v)", a->words);
    pchr(fd, '\n');
    flush(fd);
}
@
% %v below

\section{Printing subprocesses status: [[rc -s]]}
% debugging feature or general feature used by people?

<<[[Xrdcmds()]] print status if -s>>=
if(flag['s'] && !truestatus())
    pfmt(err, "status=%v\n", vlook("status")->val);
@
% %v? nil or list of strings?
% why not call getstatus()?

\section{Printing commands: [[rc -x]]}

<<[[Xsimple()]] if -x>>=
if(flag['x'])
    pfmt(err, "%v\n", p->argv->words); /* wrong, should do redirs */
@

\section{Printing characters: [[rc -v]]}

% ndot for not printing the characters procssed from a . (e.g. . rcmain)
<<[[getnext()]] if not EOF but verbose mode, print character read>>=
else 
    if(flag['V'] || ndot>=2 && flag['v'])
        pchr(err, c);
@


\section{Printing all characters: [[rc -V]]}

% so get also the content of the rcmain

\chapter{Error Management}
\label{chap:error}

<<constant [[ERRMAX]]>>=
#define ERRMAX 128
@

<<global [[err]]>>=
io *err;
@

<<global [[nerror]]>>=
int nerror;		/* number of errors encountered during compilation */
@

<<[[Xrdcmds()]] flush errors and reset error count>>=
flush(err);
nerror = 0;
@

% from yylex() (and also yyparse)
<<function [[yyerror]]>>=
void
yyerror(char *m)
{
    pfmt(err, "rc: ");
    if(runq->cmdfile && !runq->iflag)
        pfmt(err, "%s:%d: ", runq->cmdfile, runq->lineno);
    else if(runq->cmdfile)
        pfmt(err, "%s: ", runq->cmdfile);
    else if(!runq->iflag)
        pfmt(err, "line %d: ", runq->lineno);

    if(tok[0] && tok[0]!='\n')
        pfmt(err, "token %q: ", tok);
    pfmt(err, "%s\n", m);
    flush(err);
    lastword = false;
    lastdol = false;

    while(lastc!='\n' && lastc!=EOF) 
        advance();

    nerror++;
    setvar("status", newword(m, (word *)nil));
}
@
\t %q?
\t could use setstatus()

% future, peekc, lastc, hmmm
<<global [[lastc]]>>=
int lastc;
@
% who uses that? yyerror

<<[[advance()]] save future in lastc>>=
lastc = future;
@

% internal error, no more memory, etc, called from many places
<<function [[panic]]>>=
void
panic(char *s, int n)
{
    pfmt(err, "rc: ");
    pfmt(err, s, n);
    pchr(err, '\n');
    flush(err);
    Abort();
}
@

% just called from panic(), so could be inlined there
<<function [[Abort]]>>=
void
Abort(void)
{
    pfmt(err, "aborting\n");
    flush(err);
    Exit("aborting");
}
@

% called from a few places, including Xexit
<<function [[Exit]]>>=
void
Exit(char *stat)
{
    Updenv();
    setstatus(stat);
    exits(truestatus() ? "" : getstatus());
}
@


\chapter{Utilities}
\label{chap:utilities}

<<function [[_efgfmt]]>>=
/* avoid loading any floating-point library code */
//@Scheck: weird, probably linker trick
int _efgfmt(Fmt *)
{
    return -1;
}
@

\section{Memory management}

%#define	new(type)	((type *)emalloc(sizeof(type)))

<<function [[emalloc]]>>=
void *
emalloc(long n)
{
    void *p = Malloc(n);

    if(p==nil)
        panic("Can't malloc %d bytes", n);
    return p;
}
@
%old: /*	if(err){ pfmt(err, "malloc %d->%p\n", n, p); flush(err); } /**/
%ocaml: use Gc.

% plan9
<<function [[Malloc]]>>=
void*
Malloc(ulong n)
{
    return mallocz(n, 1);
}
@


<<function [[efree]]>>=
void
efree(void *p)
{
    if(p)
        free(p);
    else pfmt(err, "free 0\n");
}
@
%old: /*	pfmt(err, "free %p\n", p); flush(err); /**/
% nice trick the /**/ at the end :) but can also simply use //

\section{Command-line arguments: [[getflags()]]}
% getopt

%ocaml: use Arg.ml

% why not use ARGBEGIN/ARGEND? because getflags() is more powerful.

<<global [[cmdname]]>>=
char *cmdname;
@

<<global [[flagarg]]>>=
static char *flagarg="";
@




<<global [[reason]]>>=
static int reason;
@

<<constant [[RESET]]>>=
#define	RESET	1
@

<<constant [[FEWARGS]]>>=
#define	FEWARGS	2
@

<<constant [[FLAGSYN]]>>=
#define	FLAGSYN	3
@

<<constant [[BADFLAG]]>>=
#define	BADFLAG	4
@

<<global [[badflag]]>>=
static int badflag;
@

<<function [[getflags]]>>=
int
getflags(int argc, char *argv[], char *flags, int stop)
{
    char *s;
    int i, j, c, count;
    flagarg = flags;
    if(cmdname==0)
        cmdname = argv[0];

    i = 1;
    while(i!=argc){
        if(argv[i][0] != '-' || argv[i][1] == '\0'){
            if(stop)		/* always true in rc */
                return argc;
            i++;
            continue;
        }
        s = argv[i]+1;
        while(*s){
            c=*s++;
            count = scanflag(c, flags);
            if(count==-1)
                return -1;
            if(flag[c]){ reason = RESET; badflag = c; return -1; }
            if(count==0){
                flag[c] = flagset;
                if(*s=='\0'){
                    for(j = i+1;j<=argc;j++)
                        argv[j-1] = argv[j];
                    --argc;
                }
            }
            else{
                if(*s=='\0'){
                    for(j = i+1;j<=argc;j++)
                        argv[j-1] = argv[j];
                    --argc;
                    s = argv[i];
                }
                if(argc-i<count){
                    reason = FEWARGS;
                    badflag = c;
                    return -1;
                }
                reverse(argv+i, argv+argc);
                reverse(argv+i, argv+argc-count);
                reverse(argv+argc-count+1, argv+argc);
                argc-=count;
                flag[c] = argv+argc+1;
                flag[c][0] = s;
                s="";
            }
        }
    }
    return argc;
}
@

<<function [[reverse]]>>=
static void
reverse(char **p, char **q)
{
    char *t;
    for(;p<q;p++,--q){ t=*p; *p=*q; *q = t; }
}
@

<<function [[scanflag]]>>=
static int
scanflag(int c, char *f)
{
    int fc, count;
    if(0<=c && c<NFLAG)
        while(*f){
            if(*f==' '){
                f++;
                continue;
            }
            fc=*f++;
            if(*f==':'){
                f++;
                if(*f<'0' || '9'<*f){ reason = FLAGSYN; return -1; }
                count = 0;
                while('0'<=*f && *f<='9') count = count*10+*f++-'0';
            }
            else
                count = 0;
            if(*f=='['){
                do{
                    f++;
                    if(*f=='\0'){ reason = FLAGSYN; return -1; }
                }while(*f!=']');
                f++;
            }
            if(c==fc)
                return count;
        }
    reason = BADFLAG;
    badflag = c;
    return -1;
}
@

<<function [[usage]]>>=
void
usage(char *tail)
{
    char *s, *t, c;
    int count, nflag = 0;
    switch(reason){
    case RESET:
        errs("Flag -");
        errc(badflag);
        errs(": set twice\n");
        break;
    case FEWARGS:
        errs("Flag -");
        errc(badflag);
        errs(": too few arguments\n");
        break;
    case FLAGSYN:
        errs("Bad argument to getflags!\n");
        break;
    case BADFLAG:
        errs("Illegal flag -");
        errc(badflag);
        errc('\n');
        break;
    }
    errs("Usage: ");
    errs(cmdname);
    for(s = flagarg;*s;){
        c=*s;
        if(*s++==' ')
            continue;
        if(*s==':'){
            s++;
            count = 0;
            while('0'<=*s && *s<='9') count = count*10+*s++-'0';
        }
        else count = 0;
        if(count==0){
            if(nflag==0)
                errs(" [-");
            nflag++;
            errc(c);
        }
        if(*s=='['){
            s++;
            while(*s!=']' && *s!='\0') s++;
            if(*s==']')
                s++;
        }
    }
    if(nflag)
        errs("]");
    for(s = flagarg;*s;){
        c=*s;
        if(*s++==' ')
            continue;
        if(*s==':'){
            s++;
            count = 0;
            while('0'<=*s && *s<='9') count = count*10+*s++-'0';
        }
        else count = 0;
        if(count!=0){
            errs(" [-");
            errc(c);
            if(*s=='['){
                s++;
                t = s;
                while(*s!=']' && *s!='\0') s++;
                errs(" ");
                errn(t, s-t);
                if(*s==']')
                    s++;
            }
            else
                while(count--) errs(" arg");
            errs("]");
        }
        else if(*s=='['){
            s++;
            while(*s!=']' && *s!='\0') s++;
            if(*s==']')
                s++;
        }
    }
    if(tail){
        errs(" ");
        errs(tail);
    }
    errs("\n");
    Exit("bad flags");
}
@

<<function [[errn]]>>=
static void
errn(char *s, int count)
{
    while(count){ errc(*s++); --count; }
}
@

<<function [[errs]]>>=
static void
errs(char *s)
{
    while(*s) errc(*s++);
}
@

<<constant NBUF (rc/getflags.c)>>=
#define	NBUF	80
@

<<global [[buf]]>>=
static char buf[NBUF];
@
<<global [[bufp]]>>=
static char *bufp = buf;
@

<<function [[errc]]>>=
static void
errc(int c)
{
    *bufp++=c;
    if(bufp==&buf[NBUF] || c=='\n'){
        Write(2, buf, bufp-buf);
        bufp = buf;
    }
}
@



\section{Buffered IO}
% again, reimplement the same thing

%ocaml: stdlib does that by default

<<constant [[NBUF]]>>=
#define	NBUF	512
@

<<struct [[Io]]>>=
struct Io {
    fdt	fd;
    byte	*bufp, *ebuf, *strp;
    byte	buf[NBUF];
};
@


<<function [[openfd]]>>=
io*
openfd(fdt fd)
{
    io *f = new(struct Io);
    f->fd = fd;
    f->bufp = f->ebuf = f->buf;
    f->strp = nil;
    return f;
}
@

<<enum [[MiscConstants]]>>=
enum { Stralloc = 100, };
@

<<function [[flush]]>>=
void
flush(io *f)
{
    int n;

    if(f->strp){
        n = f->ebuf - f->strp;
        f->strp = realloc(f->strp, n+Stralloc+1);
        if(f->strp==0)
            panic("Can't realloc %d bytes in flush!", n+Stralloc+1);
        f->bufp = f->strp + n;
        f->ebuf = f->bufp + Stralloc;
        memset(f->bufp, '\0', Stralloc+1);
    }
    else{
        n = f->bufp-f->buf;
        if(n && Write(f->fd, f->buf, n) != n){
            Write(2, "Write error\n", 12);
            if(ntrap)
                dotrap();
        }
        f->bufp = f->buf;
        f->ebuf = f->buf+NBUF;
    }
}
@

<<function [[pchr]]>>=
void
pchr(io *b, int c)
{
    if(b->bufp==b->ebuf)
        fullbuf(b, c);
    else *b->bufp++=c;
}
@

<<function [[fullbuf]]>>=
int
fullbuf(io *f, int c)
{
    flush(f);
    return *f->bufp++=c;
}
@


<<function [[rchr]]>>=
int
rchr(io *b)
{
    if(b->bufp==b->ebuf)
        return emptybuf(b);
    return *b->bufp++;
}
@

<<function [[emptybuf]]>>=
int
emptybuf(io *f)
{
    int n;
    if(f->fd==-1 || (n = Read(f->fd, f->buf, NBUF))<=0) return EOF;
    f->bufp = f->buf;
    f->ebuf = f->buf + n;
    return *f->bufp++;
}
@


<<function [[rutf]]>>=
int
rutf(io *b, char *buf, Rune *r)
{
    int n, i, c;

    c = rchr(b);
    if(c == EOF)
        return EOF;
    *buf = c;
    if(c < Runesync){
        *r = c;
        return 1;
    }
    for(i = 1; (c = rchr(b)) != EOF; ){
        buf[i++] = c;
        buf[i] = 0;
        if(fullrune(buf, i)){
            n = chartorune(r, buf);
            b->bufp -= i - n;	/* push back unconsumed bytes */
            assert(b->fd == -1 || b->bufp > b->buf);
            return n;
        }
    }
    /* at eof */
    b->bufp -= i - 1;			/* consume 1 byte */
    *r = Runeerror;
    return runetochar(buf, r);
}
@







<<function [[closeio]]>>=
void
closeio(io *io)
{
    if(io->fd>=0)
        close(io->fd);
    if(io->strp)
        efree(io->strp);
    efree(io);
}
@



<<function [[openstr]]>>=
io*
openstr(void)
{
    io *f = new(struct Io);

    f->fd = -1;
    f->bufp = f->strp = emalloc(Stralloc+1);
    f->ebuf = f->bufp + Stralloc;
    memset(f->bufp, '\0', Stralloc+1);
    return f;
}
@

<<function [[opencore]]>>=
/*
 * Open a corebuffer to read.  EOF occurs after reading len
 * characters from buf.
 */

io*
opencore(char *s, int len)
{
    io *f = new(struct Io);
    uchar *buf = emalloc(len);

    f->fd = -1 /*open("/dev/null", 0)*/;
    f->bufp = f->strp = buf;
    f->ebuf = buf+len;
    Memcpy(buf, s, len);
    return f;
}
@





\section{Format}

%ocaml: use Printf, or ocamltarzan generated dumper

<<global [[pfmtnest]]>>=
int pfmtnest = 0;
@

% io.c
% could use fmtinstall instead? or because wanted to be portable to other OSes?
<<function [[pfmt]]>>=
void
pfmt(io *f, char *fmt, ...)
{
    va_list ap;
    char err[ERRMAX];

    va_start(ap, fmt);
    pfmtnest++;
    for(;*fmt;fmt++) {
        if(*fmt!='%') {
            pchr(f, *fmt);
            continue;
        }
        if(*++fmt == '\0')		/* "blah%"? */
            break;
        switch(*fmt){
        case 'c':
            pchr(f, va_arg(ap, int));
            break;
        case 'd':
            pdec(f, va_arg(ap, int));
            break;
        case 'o':
            poct(f, va_arg(ap, unsigned int));
            break;
        case 'p':
            pptr(f, va_arg(ap, void*));
            break;
        case 'Q':
            pquo(f, va_arg(ap, char *));
            break;
        case 'q':
            pwrd(f, va_arg(ap, char *));
            break;
        case 's':
            pstr(f, va_arg(ap, char *));
            break;

        case 'r':
            errstr(err, sizeof err); pstr(f, err);
            break;

        // rc specific, TODO LP split here
        case 't':
            pcmd(f, va_arg(ap, struct Tree *));
            break;
        case 'v':
            pval(f, va_arg(ap, struct Word *));
            break;

        default:
            pchr(f, *fmt);
            break;
        }
    }
    va_end(ap);
    if(--pfmtnest==0)
        flush(f);
}
@
% could add 'x' pcmd for the bytecode




<<function [[pstr]]>>=
void
pstr(io *f, char *s)
{
    if(s==0)
        s="(null)";
    while(*s) pchr(f, *s++);
}
@

<<function [[pdec]]>>=
void
pdec(io *f, int n)
{
    if(n<0){
        n=-n;
        if(n>=0){
            pchr(f, '-');
            pdec(f, n);
            return;
        }
        /* n is two's complement minimum integer */
        n = 1-n;
        pchr(f, '-');
        pdec(f, n/10);
        pchr(f, n%10+'1');
        return;
    }
    if(n>9)
        pdec(f, n/10);
    pchr(f, n%10+'0');
}
@

<<function [[poct]]>>=
void
poct(io *f, unsigned int n)
{
    if(n>7)
        poct(f, n>>3);
    pchr(f, (n&7)+'0');
}
@

<<function [[pquo]]>>=
void
pquo(io *f, char *s)
{
    pchr(f, '\'');
    for(;*s;s++)
        if(*s=='\'')
            pfmt(f, "''");
        else pchr(f, *s);
    pchr(f, '\'');
}
@

<<function [[pwrd]]>>=
void
pwrd(io *f, char *s)
{
    char *t;
    for(t = s;*t;t++) if(*t >= 0 && needsrcquote(*t)) break;
    if(t==s || *t)
        pquo(f, s);
    else pstr(f, s);
}
@

<<function [[pptr]]>>=
void
pptr(io *f, void *v)
{
    int n;
    uintptr p;

    p = (uintptr)v;
    if(sizeof(uintptr) == sizeof(uvlong) && p>>32)
        for(n = 60;n>=32;n-=4) pchr(f, "0123456789ABCDEF"[(p>>n)&0xF]);

    for(n = 28;n>=0;n-=4) pchr(f, "0123456789ABCDEF"[(p>>n)&0xF]);
}
@


<<function [[pval]]>>=
void
pval(io *f, word *a)
{
    if(a){
        while(a->next && a->next->word){
            pwrd(f, (char *)a->word);
            pchr(f, ' ');
            a = a->next;
        }
        pwrd(f, (char *)a->word);
    }
}
@


\section{String conversions}

<<global [[bp]]>>=
char *bp;
@

<<function [[inttoascii]]>>=
void
inttoascii(char *s, long n)
{
    bp = s;
    iacvt(n);
    *bp='\0';
}
@

<<function [[iacvt]]>>=
static void
iacvt(int n)
{
    if(n<0){
        *bp++='-';
        n=-n;	/* doesn't work for n==-inf */
    }
    if(n/10)
        iacvt(n/10);
    *bp++=n%10+'0';
}
@

\section{Portable wrappers}

%less: could delete them, I don't care about other OSes

<<function [[Write]]>>=
long
Write(int fd, void *buf, long cnt)
{
    return write(fd, buf, cnt);
}
@

<<function [[Read]]>>=
long
Read(int fd, void *buf, long cnt)
{
    return read(fd, buf, cnt);
}
@

<<function [[Seek]]>>=
long
Seek(int fd, long cnt, long whence)
{
    return seek(fd, cnt, whence);
}
@

<<function [[Creat]]>>=
int
Creat(char *file)
{
    return create(file, 1, 0666L);
}
@

<<function [[Dup]]>>=
int
Dup(int a, int b)
{
    return dup(a, b);
}
@

<<function [[Memcpy]]>>=
void
Memcpy(void *a, void *b, long n)
{
    memmove(a, b, n);
}
@


\chapter{Examples of [[rc]] scripts TODO}
\label{chap:examples}

\section{[[/rc/lib/rcmain]]}

\section{[[/home/pad/lib/profile]]}


\chapter{Extra Code}

#include "Shell_extra.nw"

%\chapter{Changelog}
% code via make loc = 6300 LOC, after full lpized  ? LOC
% orig Shell.nw = 7500 LOC, after full lpized and comments in sections ??
% now: =~ ?? LOC so added ?? LOE (Lines of explanations)
% rc in ocaml: 2300 LOC (but not all features)

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}




\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
