\documentclass[12pt]{report}
%12pt, twocolumn, landscape

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
%  - removed deadcode (Thread.treenodes, Tree.iskw, freetree, ...)

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps (only 20: 1.5% down from 4.61%), introduced
%   error.c, main.c, utils.c, words.c, globals.c, fmt.c,
%   path.c, status.c, builtins.c, env.c, executils.c, input.c, processes.c
%   and spread around plan9.c, 
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)

%thx to rc in ocaml, I learned a lot:
%  - Xerror and walk up the stack
%  - Xassign and double Xmark
%  - lots of stuff

%thx to this manual, I better understand sh:
% - SEMI fancy redirection syntax, especially 2>&1 ?? I never remember
%   but in rc it's   ls /xxx >[2=1] > /tmp/errors
% - SEMI operator priorities (; vs & vs | vs >)
% - SEMI $*, variable for return status of process ($status in rc, simpler)
% - $* vs $@ (actually rc does not have the problem)
% - TODO escaping nightmares (less pb in rc)
% - SEMI multiline editing
% - TODO subshell power? ex?
%     (for d in utils parsing typing bytecomp asmcomp driver tools/toplevel; \
%              do boot/ocamlrun tools/misc/ocamldep -I utils -I parsing -I typing -I bytecomp -I asmcomp -I driver -I tools/toplevel $d/*.mli $d/*.ml; \
%              done) > .depend
% - to not use ';' but instead && for eflag -e to work
% - interactive vs non-interactive mode. It's mainly for the prompt,
%   to print it or not (note that it is printed on stderr also).
% - SEMI login vs non-login shell (one launch /home/lib/profile)
% - SEMI why need 'test' and why it is an external program

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, builtin, bytecode
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - SEMI nullify, boolify, typeify,    scheckify
% - SEMI aspecify advanced features!
% - SEMI add figures
% - SEMI add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{xspace}
\usepackage{verbatim}
%note: required by 'syncweb -to_tex' for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

\input{../docs/latex/Config}
\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../docs/latex/syncweb}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Shell [[rc]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Tom Duff
}

\maketitle 
%\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a {shell}.

\section{Motivations}

Why a shell? 
Because I think you are a better programmer if
you fully understand how things work under the hood, and
%
the shell is the central piece of the {\em command-line user interface} (CLI).
\n other pieces are kernel and especially /dev/cons (said later)
\l CLI instead?
%
\n def
The shell is a thin layer around the {kernel} (hence its name) % \book{Kernel}
allowing you to {run commands} in a {terminal}.
\n terminal is keyboard and monitor (said later)
\n actually more than command interpreter, but it is its essence (said later)

%without:
Most users now use a {\em graphical user interface} (GUI) to execute programs
(e.g., macOS, Microsoft Windows, X Window), but
\n also rio \book{Windows}, but rio relies on shell to launch program actually
most programmers still spend a significant portion of their time in a shell
to run 
compilation commands, % (see the \book{Builder}), 
editors, % (see the \book{Editor}),
debuggers, % (see the \book{Debugger}),
or {\em scripts} to automate repetitive tasks.
%
Integrated Development Environments (IDEs) can handle some of those
use cases, but the shell still reigns when a programmer needs more flexibility.
%
The power of 
{pipes}, 
{redirections}, 
{variables}, and 
basic {control flow constructs}
\n sequence is already great, especially in a script file (said later)
allows sometimes in one command-line
to perform tasks that would require hundreds of lines in a regular 
programming language\footnote{
For example, \cite{literate-pearl} contrasts writing a program
to count words in Pascal and in a shell.
}.
\n one-liner, command-line hence CLI
\n building blocks, components (said later)

There are very few books explaining how a shell works. I can cite
{\em Advanced UNIX Programming}~\cite{unix-rochkind},
but it explains only the code of a mini-shell.
%
This is a pity because the implementation of a real shell covers many
interesting topics (e.g.,
programming language design, 
compilation, 
interpretation,
system programming, etc.) as you will see soon in this book.
\l redundant with Compiler? No, cos usually use (bytecode) interpreter
\l interesting design constraints compared to regular PL; DSL spirit


Here are a few questions I hope this book will answer:
\begin{itemize}

\item What is the difference between a shell and a terminal?
What is the difference between a shell and a login program?
\n rc vs /dev/cons
\l rc vs login or telnet or ssh (plan9 has no login program)

\item What happens when the user type [[ls]] in a terminal?
What is the trace of such a command through the different layers
of the software stack?

\item What are the main features of a shell?

\item How are implemented redirections and pipes? 
What are the system calls involved?

\item Why [[ls]] and [[rm]] are regular programs but not [[cd]]?
Why [[cd]] has to be a shell {builtin}? What is a shell builtin?

\item How does [[C-c]], which interrupts a process, work?
Which process receives the signal after an interruption?
The shell or the command ran from the shell?

%\item How does [[C-z]], which suspends a process, work?
%not under \plan; need less job control when have multiple windows anyway,
% job suspended when blocked on output in window!


\end{itemize}
%less: relation between login shell (.profile), user shell (bashrc)
% but rc does not have this issue I think.

%bash shellshock context in oct 2014, good idea to look at shell
% implementation :)

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl): (use ??)
% - growing_array (codebuf, waitpids)
% - ???
%algorithms (beyond search/sort): (actually use neither search nor sort?)
% - globbing? with does some string matching with regexp ('*' '?' '[...]'? )
% - ???


\section{The \plan shell: [[rc]]}

I will explain in this book the code of the \plan shell
[[rc]]~\cite{rc}\footnote{See 
\url{http://plan9.bell-labs.com/magic/man2html/1/rc} for its manual page.}
(for [[R]]un [[C]]ommands), which contains about 6700 lines of code (LOC).
%
[[rc]] is written mostly in C, with its parser using also Yacc~\cite{yacc}.

%dup: Assembler.nw
Like for most books in \principia, I chose a \plan program because
those programs are simple, small, elegant, open source, and 
they form together a coherent set.
%
Moreover, [[rc]] is arguably simpler to use and to understand 
than [[sh]]~\cite{sh}, the \unix shell, or any of its derivatives 
(e.g., [[bash]]~\cite{bash}, the most popular shell under Linux).
%
For example, by treating the content
of any variables uniformly as a list of strings, [[rc]] does not 
need the extra operator [[$@]] used in [[sh]] ([[$*]] is enough).
\l also [[$status]] clearer than [[$0]] (said later?)
Moreover,
The syntax of [[rc]], specified formally and succintely by a small grammar,
is also easier to learn than the (unspecified) syntax of [[sh]], partly
because [[rc]] is inspired by the syntax of C with its 
curly braces ([[sh]], instead, is using multiple keywords inspired by Algol).
\l actually rc seems used as a fork basis for other advanced shells (es, other?)
\l actually grammar of sh in sh article, but Duff says it's not valid 
\l used also outside plan9 by a few open source software. Portable.
\l Still used in Go :)
\t need for external programs: test '[' expr, ugly ;;, lots of bad stuff in sh
%Contrast the two equivalent snippets of code, one written in [[rc]] and
% the other in [[sh]].
% if [ ... -ne ...]; then
% vs
% if(~ ...) {
% ...
% }
% [[sh]] requires the [[then]] keyword to be preceded by a newline or
% a semicolon, leading to a weird syntax for conditionals. Moreover,
% [[sh]] requires the use of the unconventional [[-ne]] operator and \[ 
% bracket, which is actually an external program ([[/usr/bin/[]]).
\l why? interactive requirement?
%footnote{To be fair, [[rc]] uses also un unconventional operator [[~]],
% which is described in Section{X}}.


[[rc]] itself lacks many of the interactive features found in other
shells (e.g., [[bash]]) such as 
{filename completion}, 
{command-line editing}, 
job control, etc.
This is partly because
under \plan, the terminal of the windowing system [[rio]] 
is providing instead those features (see the \book{Windows}).
\n job control less useful when have multiple windows


\section{Other shells}

Here are a few shells that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

%history:
\item The first \unix shell, originally called [[sh]], was written
by Ken Thompson, the original author of the \unix kernel.
\n Not first one, before shell for CTSS and Multics, RUNCOM (said later?)
\n and probably there was very basic command interpreter before too
%
[[sh]] started as an assembly program in 
\unix V1\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=V1/sh.s}
and finished as a C program in
\unix V6\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6/usr/source/s2/sh.c}.
%
Ken Thompson's shell introduced the 
pipe ([['|']]), 
redirections ([['>']] and [['<']]), as well as
wildcard matching\footnote{Also known as globbing.} ([['*']]).
\l also command sequence ([[;]]), background job ([[&]])
%
The syntax of those features remained the same in all subsequent shells.
\n actually was using different syntax originally for pipe >cmd> but confusing
%
Ken Thompson's shell contains only 899 LOC, but it is just a 
basic command interpreter, not a full scripting language like [[rc]].
\n 3 man pages
\n recursive descent parsing,
\l if/goto (and glob) were external programs

%history:
\item The Bourne shell~\cite{sh}, also called [[sh]], superseded 
Ken Thompson's shell (which was renamed [[osh]]) in 
\unix V7\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/cmd/sh/}.
%
It was written by Stephen Bourne and contains 4145 LOC of C.
\n 6 man pages
%
It is arguably the most famous shell because it defined first
the main features that we expect now from a shell:
the ability to run commands with pipes and redirections, but also
the use of variables and control flow constructs to write {scripts}.
\n and functions? not in sh (but scripts were kinda functions)
\l said later?
%
The Bourne shell is both an interactive command interpreter and
a full programming language.
%
Most subsequent shells tried to remain backward compatible with the Bourne
shell.

The syntax of the Bourne shell was inspired by Algol 
\l cite?
with pair of keywords (e.g., [[begin/end]], [[do/done]], [[case/esac]]) 
\n not od because conflict with unix program od
instead of the curly braces of C\footnote{
Stephen Bourne was such as fan of Algol that the C source
code of [[sh]] itself looks like Algol, thanks to macros such as
[[THEN]], [[BEGIN]], [[END]], etc.}.
\n apparently it inspires the IOCCC contest :) says the wikipedia page of sh
%
The code of [[sh]] is smaller than the code of [[rc]], but it is
also harder to understand. 
\l also use own allocator, macros, no libs
\l understanding and porting bourne shell to new unix version
\l cite Tour of C shell that talks about that?
% For example, there is no clear grammar
as in [[rc]], but instead a complex recursive descent parser.
\l Actually Duff says nobody knows the grammar
%  of sh (even though sh article by Bourne contains a grammar in appendix).
\l design of sh by bourne: https://www.youtube.com/watch?v=2kEJoWfobpA

%\item C shell lots of interactive features.
%\item Korn shell lots of interactive features.


\item Bash~\cite{bash,learning-bash}\furl{https://www.gnu.org/software/bash/}
(for Bourne-Again Shell) is an open-source shell similar
to the Bourne shell (hence its name) from the 
GNU project\furl{http://www.gnu.org}.
%
It is the default shell in most Linux distributions and in macOS.
\l also ported to Windows
%dup: (but different context) intro/rc
It provides many interactive features not found in the Bourne
shell such as filename completion, command-line editing,
interactive history, job control, etc.
\n  arrow key, C-r, need raw mode 
%
Many of those features were partly inspired by the C shell~\cite{csh}, 
an older shell originating in BSD \unix using a syntax more similar to C.
\l actually not very C: if/then/endif compared to rc

Bash relies on the GNU Readline library\furl{https://tiswww.case.edu/php/chet/readline/rltop.html}
for many of those interactive features
%dup: intro/rc
([[rc]] relies instead on [[rio]]'s terminal to provide similar features).
%
However, the codebase of Bash is very large with more than 100~000 LOC
(not including the code of the Readline library, which would add
another 33~000 LOC), which
is more than an order of magnitude more code than in [[rc]].
Bash's grammar file [[parse.y]] contains alone 6268 LOC.
%http://www.aosabook.org/en/bash.html
\n 110 man pages. 75 pages in pdf of man page. and bash reference man is 172p.

\item The Z shell~\cite{bash-to-zsh}\furl{http://www.zsh.org/}
is another open-source shell popular among advanced Linux users.
%
It is extensible through plugins and themes\footnote{See 
\url{https://github.com/robbyrussell/oh-my-zsh} for a large repository
of such contributions.}.
%
It contains most of the features found in other shells (e.g., Bash,
the C Shell, the Korn Shell~\cite{ksh, ksh-usenix}) and introduced 
many new interactive features such as 
programmable completion,
\l now also in bash
recursive wildcarding with [[**/*]] (eliminating the need for
the program [[find]]),
and more.
%
However, all those features come at a price: the code
of the Z shell contains more than 145 000 LOC (not including the tests).

\end{itemize}


\begin{figure}[]\centering
\includegraphics[height=0.45\textheight]{lineage}
\caption{Shells timeline}
\label{fig:lineage}
\end{figure}
\l big hole because switch to GUI, and scripting languages (Perl/...) instead of
\l  shells, which even if they have a REPL are not really shells

%dup: Assembler.nw
Figure~\ref{fig:lineage} presents a timeline of major \unix shells
(and a few non-\unix shells).
%
I think [[rc]] represents the best compromise for this book: 
it implements the essential features of a shell while still having
%dup: intro/rc
a small and understandable codebase (6700 LOC).

%history:
% - RUN command monitor provided by machine? ex: in PDP11
% - http://www.multicians.org/shell.html
%   history of the shell by Louis Pouzin, RUNCOM first shell
% - the original shell of Ken Thompson. Ported and extended to C in V5.
%   http://v6shell.org  http://v6shell.org/history/sh.c
%   understanding the shell of v6: http://experiments.oskarth.com/unix01/ DEAD?
% - Mashey shell by PWB group, added control flow but remained backward
%   compatible with Ken Thompson shell so strong limiting constraint
% - original bourne shell, in unix-history-repo, 4145 LOC for V7
% - csh apparently introduced many interactive features, by
%   Bill Joy: history, alias, dir stack, tilde, filename completion,
%   job control. but No way to define function on multiple lines;
%   just provided alias, and hacky and fragile parser.
% - ksh
% - bash
%   http://samrowe.com/wordpress/advancing-in-the-bash-shell/
%education:
% - xinu shell in appendix of xinu book
% - a shell for xv6
%   https://github.com/oskarth/xv6/blob/master/homework/sh.c
% - minix had a shell too
%mini:
% - sh.c in plan9, simple shell used for early porting with
%   many programs as builtins! really useful.
% - sash (stand-alone-shell), precursor to busybox; far smaller.
%   many builtins there such as ed, tar are included in busybox.
%   1500 LOC (without the cmd_xxx.c) by David I Bell :) of mini-X
%   but mini-shell, not full PL
% - hush, a small reimplem of sh (9300 LOC in busybox, not so small)
% - http://runtimeterror.com/tech/lil/
% - Tcl in 500 LOC http://antirez.com/picol/picol.c.txt
%   https://github.com/zserge/partcl mini Tcl again
%other:
% - ash Almquist shell https://en.wikipedia.org/wiki/Almquist_shell
%   used for Debian startup scripts (called dash), android, busybox
%   many variants: http://www.in-ulm.de/~mascheck/various/ash/
%   17 000 LOC (ash.c is 11 000 LOC in busybox, but maybe use other files)
%   used in minix, seems mostly a rewrite or bourne shell
% - busybox, includes ash and hush, with many programs as builtins.
% - rc fork by Byron Rakitzis (in infomagic 94) that then made es?
%   which now is maintained at http://tobold.org/article/rc
% - es: extensible shell, based on rc: 13 000 LOC
%   http://wryun.github.io/es-shell/
%   http://wryun.github.io/es-shell/paper.html inspired by scheme and ML
% - another rc fork? 
% - ape/pdksh/, 23 000 LOC vs rc 6300 (or 10 000 when wc *.nw instead)
% - oil shell (also shell in python) osh (bash compatible) and oil (new one)
%   http://www.oilshell.org/blog/2017/02/11.html
%   "Why create a new unix shell?":
%   http://www.oilshell.org/blog/2018/01/28.html
% - PowerShell, recently open sourced, written in C#, huge
%   contains shell but also utilities. Apparently can have typed pipes.
%   Maybe like in Automator?
% - DOS? they had a shell? command.com? 4dos?
% - cicada, shell in rust https://github.com/mitnk/cicada
% - ion, shell in rust from redox project
%exotic:
% - scsh
%   more orthogonal, but then more verbose, remove what makes a shell a bit.
%   I could present it, but then it's yet another language to present (Scheme)
% - eshell!! pager a la plan9, so no need pager like less/more/most actually
%   http://www.howardism.org/Technical/Emacs/eshell-fun.html
% - Automator, visual pipes! not really a shell, a kind of visual shell
% - wish
% - goosh, the google shell
% - yubnub: the command-line of the web
%research/recent:
% - fish shell (friendly shell), lots of interactive features
%   50 000 LOC (without tests), written in C++
%   rely on ncurses (uses also PCRE)
% - https://elvish.io/, with structured-data in pipes (e.g., JSON)
% - next generation shell
%   https://github.com/ilyash/ngs/
% - xonsh http://xon.sh/ (a superset of pyhton)
% - mosh, mobile shell, allow disconnection over Wifi apparently
%   but not really a shell, more a replacement for ssh
% - https://github.com/ergonomica/ergonomica a cross-platform shell written
%   in Python
% - ssh? actually it's not really a shell, its name (secure shell) is misleading
%related:
% - GNOME Shell: called a shell but it's really the GUI of Gnome

% https://en.wikipedia.org/wiki/Comparison_of_command_shells
%  exhaustive list
% http://xon.sh/#comparison 
%  nice comparison of modern shells
% evolution of shells:
% https://www.ibm.com/developerworks/library/l-linux-shells/
%  nice diagram of history of shells, very nice resource list with further links
% list of terminals and shells:
%  https://github.com/k4m4/terminals-are-sexy
% write your own shell:
% - https://linuxgazette.net/111/ramankutty.html
% - %https://brennan.io/2015/01/16/write-a-shell-in-c/
% - http://www.davidpashley.com/articles/writing-robust-shell-scripts/
% - https://indradhanush.github.io/blog/writing-a-unix-shell-part-1/
%   https://indradhanush.github.io/blog/writing-a-unix-shell-part-2/
% - https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
%   from https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/
% basic command, pipe, quotes, use PEG parser (meh)
%  https://www.destroyallsoftware.com/screencasts/catalog/shell-from-scratch
% scriptometer
%   http://rigaux.org/language-study/scripting-language/

\l there is also an article in oasa book about bash
% (available in bash/doc/aosa-bash.pdf)

\section{Getting started}
\label{sec:getting-started}

%dup: Assembler.nw
To play with [[rc]], you will first need to install
the \plan fork used in \principia (see \urlinstall).
\l also under unix with plan9port, also author of es got a unix port apparently
%
Once installed, you do not need to do anything to run [[rc]]
because it is the program started by default by the kernel 
(see the \book{Kernel}).
%
Once the kernel finished to boot,
you should see a percent sign, called the {\em prompt}, 
after which you can type any commands as in the following:

\begin{verbatim}
1   % ls /
2   bin
3   boot
4   ...
5   srv
6   % rc -help
7   Usage: rc [-SsrdiIlxepvV] [-c arg] [-m command] [file [arg...]]
8   % rc
9   % prompt='$ '
10  $ ls /
11  bin
12  boot
13  ...
14  srv
15  $ exit
16  %
\end{verbatim}

Line~1 runs the program [[ls]] to list the content
of the root directory. % see \book{Utilities}
%
Line~6 and Line~8 show that [[rc]] is a regular program
(just like [[ls]] at Line~1):
you can run a shell program under a shell.
\n under unix you can change shell if you are not satisified: chsh (said later)
%
Line~8 and Line~9 seem to indicate that typing [[rc]] has no effect, but 
the percent sign shown at the beginning of Line~9 is in fact displayed 
by the [[rc]] process started by Line~8, not the original [[rc]] process 
started by the kernel.
%
Line~9 modifies the {\em special variable} [[prompt]] 
(see Section~\ref{sec:special-variables} 
for a list of those special variables)
%
to better differentiate the two shell processes.
Indeed, Line~10 shows
that [['$ ']] is the new prompt replacing the percent sign. %$
%
Finally, Line~15 shows the use of the {\em builtin} [[exit]]
(see Chapter~\ref{chap:builtins} for more information on builtins)
to exit from the shell.
%
Doing so goes back to the preceding shell process
(the one launched by the kernel)
with the original percent prompt at Line~16.
\l Modify variable in current process (and children), not parent process.


\section{Requirements}

%dup: Assembler
Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
To understand Chapter~\ref{chap:parsing}, you will also
need to know Yacc~\cite{lexyacc}.
\l Can read \book{Compiler} :) and \book{Generators} :) but a bit self-ref.


%dup: Assembler.
Note that this book is not an introduction to the shell or 
to shell scripting.
%
I assume you are already familiar with at least one shell,
for instance a derivative of [[sh]] such as [[bash]],
%
and so are familiar with concepts such as
a {pipe},
a {redirection}, 
what [[#!]] means,
or what a {script} is.
%
If not, I suggest you to read either the book introducing
the \unix programming environment~\cite{unix-pike},
or the original [[sh]] tutorial~\cite{sh}, or any
more recent books on 
shell scripting~\cite{shell-scripting, learning-bash, bash-to-zsh}.


%dup: intro/motivations
A shell is a thin layer on top of a kernel,
%
and so a shell relies heavily on the services offered by the kernel:
system calls (e.g., [[rfork()]] [[exec()]], [[wait()]], [[chdir()]]),
but also device files (e.g., [[/dev/cons]] to read and write characters
on the terminal).
%
Thus, it can be useful to know how the \plan kernel works 
(see the \book{Kernel}), or at least be familiar
with {sytem programming} under \unix~\cite{unix-rochkind,unix-stevens}, 
to fully understand some of the code in this book.

%dup: intro/related-work/sh
A shell is also a full programming language, and as you will see soon,
%
[[rc]] is internally both a {compiler} and a {bytecode interpreter}.
%
I assume you also have a basic understanding of how a compiler
works, and for example that you know what a lexer or parser is
(see the \book{Compiler}).

\l table? Compiler, Kernel? more books? Libcore?

%dup: Windows.nw
If, while reading this book,
you have specific questions on the syntax and interface of [[rc]],
I suggest you to consult the man page of [[rc]]
at [[docs/man/1/rc]] in my \plan repository.

%dup: Make.nw
Note that the [[shells/docs/]] directory in my \plan repository
contains documents describing either [[rc]]~\cite{rc-plan9}
or [[sh]]~\cite{sh-talk}.
%
Those documents are useful to understand some of the 
design decisions presented in this book, especially how and why
[[rc]] differs from [[sh]].


\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[rc]], Tom Duff, 
who wrote in some sense most of this book.




\chapter{Overview}

%trans: %dup: Assembler.nw
Before showing the source code of [[rc]] in the following chapters, 
%toc:
I first give an overview in this chapter
of the general features of a shell.
%
I also quickly describe the command-line interface of [[rc]]
and the specific language supported by [[rc]].
%dup: Assembler.nw
I also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.

\section{Essential shell features}
\label{sec:principles}

%toc:
The following sections will explain the essential features of a shell.
%
A shell is a strange beast:
\l \cite{unix-pike}, put quote? (found in abstract of paper about es-shell)
%dup: intro/related-work/sh
it must be both 
an interactive command interpreter, 
allowing to run commands easily on one line in a terminal, and
a proper programming language, 
allowing to write complex script in a file.
\l complex program

\l do a minishell before showing rc?

%without:? can have hardcoded in kernel, but restricted.
% at least need command interpreter taking path, or GUI
\t look PDP11 RUN command monitor? hardcoded many operations in it
% instead in UNIX split in many programs, extensible,
% and can pass arguments! no need recompile!

\t principle of shell is be external program. Not with kernel.

\subsection{Running commands}

%dup: intro/motiv intro/rc intro/related-work 
The first job of a shell is to allow the user to run commands\footnote{ 
%history:
The very first shell, which was written for the CTSS operating system in 1964,
was called [[RUNCOM]]\cite{runcom}.}.
Most shells offer a minimalist syntax for running commands, so we can
type those commands quickly.
%
Indeed, contrast the shell command [[ls /]] with the equivalent C program:

<<[[ls_root.c]]>>=
#include <u.h>
#include <libc.h>

void main(){
  char* args[] = {"/"};
  exec("/bin/ls", args);
}
@
\l also print(readdir("/")) ... also fork; exec ...
%without: but would still need something to run ls_root ... chicken and egg
%ocaml: do system("ls /") but it actually relies on sh below

Here are a few notes on the minimalist syntax used by shells:

\begin{itemize}
\item {\em No Parenthesis:} to call a program, 
you do not need any parenthesis; 
just type the program name next to its arguments.
\n curry syntax :)


\item {\em No quotes:} to pass arguments to the program, 
you usually do not need any quotes or commas; 
just type the arguments separated by space.
For example, [[foo]], [[--help]], [[42]], [[/a/b/c]] are all
valid arguments\footnote{
You can even sometimes avoid to specify fully all the arguments
by using {shortcuts}, for example, {wildcards} as explained 
in Chapter~\ref{chap:globbing}.
}.
%
The only time you need to enclose an argument in a quote is
when you want to use one of the {special character} used by the shell
(e.g., [['#']], [['$']], [['&']], etc. with [[rc]]), %$
also known as {\em meta-characters}.
\l or space itself
\t see X for more information on quotation

\item {\em No full path:} to call a program, you do not need
to specify its path in the filesystem;
just type the name of the program and the shell will automatically
find its location.
%unix:
Under \unix, the [[PATH]] environment variable stores the
candidate locations to find programs.

\item {\em No special ending character:} to finish your command,
you do not need any special character like a semicolon;
just type a newline and the shell will start interpreting 
your command\footnote{You can also enter commands on multiple lines, 
which requires to {\em escape} the newline as
explained in Section~\ref{sec:escaping-newline}.}.
\l also skipnl
%real-world: ocaml needs ;; but then no need for skipnl tricks


\item {\em No types:} to enter a command, you do not need to
specify any types such as [[char*]] as in C. The arguments are
always strings.
\l even better with rc, a var is a list of string

\end{itemize}

Once the command you ran finished, the shell gets back in control
and displays another {\em prompt} to indicate that you can type another
command.

\subsection{Redirections}

The second important feature of a shell is to allow to {\em redirect}
the output and input of a program, as in [[ls / > listing.txt]].
\l can put redirection after or before the command actually


Many programs (e.g., [[ls]], [[find]], [[rm]], [[grep]]) live in
the command-line world and simply use {text} for their input and output.
%
By using redirections, you can easily save the output of those programs
in a file, or use a previously saved file as input for those 
programs\footnote{
[[rc]] allows to redirect not just the standard input and output,
as explained in Section~\ref{sec:advanced-redirection}.}, 
\l also advanced pipe, advanced double redir, advanced dup
without even changing the code of those programs.
%
In fact, because under \unix and \plan ``everything is a file'', 
including devices,
you can use the same program in many different ways.
%
For example, you can print the listing of the root directory by
simply typing [[ls / > /dev/printer]].
\l interpreted by shell, not additional arg passed to ls!
\l in fact can also be put before the command

\subsection{Pipes}

Because of the universality of plain text, you can easily combine
many command-line programs.
%
For example, you can list all the C files in your home directory by 
combining [[find]] and [[grep]] with the two commands
[[find /home/pad/ > /tmp/list.txt]] and
[[grep '\.c$' < /tmp/list.txt]]. %$
\l could use [[find ~]] but tilde is not supported by rc
\l can also pass list.txt as argument to grep, Perl [[<>]] operator
In fact, thanks to another great feature of the shell, the {\em pipe}, you
can just use one command: [[find /home/pad | grep '\.c$']]. %$
%
This is not only shorter, but also more efficient, and it gives
results more quickly.
%
You can even use multiple pipes in the same command as in
[[find | grep '\.c$' | xargs cat | grep foo]]. %$
\l filters
\l pipes popularized the use of ``filters'', program that takes input,
% transform it in some ways and output result
% (e.g., grep, sort, sed, awk).

Pipes allow to combine easily full programs, just like you can
combine functions in a functional language.
%
Pipes are one of the greatest innovations introduced by \unix, and
one of the first programming construct allowing a form of
{\em component-oriented programming}.
%
Each program can be treated as a component, which can be combined with
other components. You do not program at the granularity of functions but
at the higher granularity of programs.
\l cite literate-pearls? also pearl that does spell checker?

%implem:
% to implement pipes and redirections you just need to alter
% slightly the environment of the forked process, which shows fork's beauty



\subsection{Storing commands in a script}

Just like 
you can type a series of commands separated by newlines in a terminal,
you can save those same commands in a file, a {\em script}, and
execute this script with the shell.
\l syntax, either rc script or use of [[#!]] and chmod x (said later?)
\l  dont even need to add .rc extension so abstract away
%history:
% originally was handle by sh itself, but then it was handled by the kernel
% (see wikipedia page on Shebang)
%
As the author of the first shell said~\cite{runcom}:
``commands should be usable as building blocks for writing more commands,
just like subroutine libraries''.

\t shell procedure in sh [[$0]]%$ 

Scripts allow to automate easily repetitive tasks. Moreover, 
because scripts are commands themselves, they can also be combined, 
leading to more forms of components-oriented programming.
\l can be used as "filters" in pipes too.
\l many commands are actually small wrapper scripts setting up
\l   environment for actual binary to execute ex: firefox, gcc? ghc
\l In fact, the Bourne shell did not have support to defune functions
\l like rc, or bash. Because you can save a set of commands in a script
\l (called originally a shell procedure), this script can be called
\l like it was a function. dollar1, dollar2 for arguments 

\subsection{A shell as a scripting language}
\l Scripting! definition of such a language? hybrid lang? easy to "script" :) 
\l scriptometer of pixel

Once you can write a sequence of commands in a script, you quickly
want more, such as the ability to use conditionals or loops.
\l rare to use control flow construct from the command-line
%
Thus, most shells are also full programming languages,
often referred as {\em scripting languages},
with {\em variables} and many {\em control flow} constructs, and even
function definitions.
%
A scripting language acts like a {glue}, allowing to combine many
programs together.


Because a scripting language must also support the basic commands you
type on the command-line, it shares many characteristics with those
basic commands: a scripting language does not use types and is interpreted.
%and relies on a garbage collector.

A scripting language operates mainly on strings.
\l no bool, no int, especially in rc
Because the string arguments you type on the command-line
do not usually require any quotes, the use of variables requires
then a special operator.
%
Most shells use [['$']] as a prefix to differentiate %$
variables from regular string arguments, for example,
[[find $home]].%$
\l in the same way, newline special



% interactive and scripting language. Same engine.
% (ken thompson v6 shell was not scriptable; only interactive)
% So for interactive use, and for programming.

% dynamic language. arbitrary strings length (maybe big deal at the time
%  when compared to C, but compared to Lisp??)
% no memory management.

% evolved gradually. But to still allow simplicify of syntax for
% running commands, without quotes, with just newline,
% had to alter a few things:
% - variable prefix with $. To make diff with regular arguments to
%   commands which can be anything
% - skipnl trick for statements we usually want on multiple lines
% - just strings for values
% - actually list of strings is better basis (so no need PATH : split,
%   no need $* vs $@)

% However this goes in conflict with the ability
% to easily run command and the minimal syntax.
% rc uses lots of lexing tricks to mix full PL and DSL for
% running command (ex: SUB hack, skipnl, etc)

% no types. just strings.

% no bool. Basis is really the cmd you run.
% so control flow based on return status of the cmd.
% (and just ~ word words otherwise, and again here because basis is the
% string, the only operator is really a string matching operator).

% Even if string only citezen, still wants sometimes numerical tests.
% Enter 'test', which is really a separate program, for argument of if
% for numerical-classic-like tests.

% Shells started this "Scripting language" and also DSLs (sed/awk/...)
% that you can combine. Later Perl/Ruby/Python came, integrating
% in one lang, but not as interactive as shell.


%\subsection{A DSL}
% now in grammar

%\subsection{A universal read-eval-print loop (REPL)}
% shell is also idea of universal repl! not like Lisp machine, Squeak, etc.
% see Kernel.nw note on this.
% call function from repl, pass argument, modify globals. can even get
% help via whatis :) or man :) and return boolean result (status)
% (as well as effect on stdout/stderr that can be captured)
% In fact very similar to function call in PL: 
%  - arguments to function via argv
%  - globals via environment variables (sometimes globals are useful)
%  - other?
% support multiple programming environment (Multics goal too).
% cf stevens book, shell basis = read a line, parse, fork, exec, wait!
% RPFEW

%\subsection{An interactive interpreter}
% csh, zsh, fish: lots of interactive features outside language.

%\subsection{Asynchronous jobs and job control}
% also handling signals in child process?

%\subsection{Globbing}





\section{[[rc]] command-line interface}

%trans: %dup: Windows.nw
I just described the main features of a shell.
%and illustrated some of those principles with examples from RCS, CVS, or Git.
I will now focus exclusively on [[rc]] and give more details about
its command-line interface.


It is rare to run [[rc]] itself on the command-line,
like you run [[ls]], [[cp]], [[grep]], etc.
\n not [[cd]] here! builtin
%
After all, if you have a command-line, you already are in a shell.
\l very meta! command line interface of the command line interface!
%dup: intro/getting-started
However, as I said in Section~\ref{sec:getting-started}, the shell
under \unix (and \plan) is a regular program.
%
You can run a shell under a shell, which can be useful for example if you
do not like the default shell when you 
%unix:
log-in\footnote{Under \unix, you can also use the special program [[chsh]]
to change your login shell.}.
To run [[rc]], simply type [[rc]] on the command-line without any arguments,
as I did in Section~\ref{sec:getting-started} Line~8.
\l can run rc under sh in unix with plan9port


You can also pass to [[rc]] the name of a {script} as an argument , as well 
as the arguments of this script, for example, [[rc foo.rc arg1 arg2]]. 
\l can do [[rc ls]]? probably not.
%
However, this is usually not necessary because most scripts 
use [[#!/bin/rc]] at the beginning, which is recognized by 
the kernel (see the \book{Kernel}).
\n special comment in fact (said later)


Here is the full command-line interface of [[rc]]:
\begin{verbatim}
% rc -help
Usage: rc [-SsrdiIlxepvV] [-c arg] [-m command] [file [arg...]]
\end{verbatim}
\n autogenerated by Getflags.usage

The [[-c]] flag allows to execute commands from a string
passed as an argument instead of from the content of a script
(see Section~\ref{sec:rc-c} for the code handling [[rc -c]]).
\l -c for command

The [[-m]] flag allows to specify the initialization
script of [[rc]]. I will explain fully the complex initialization
process of [[rc]] and the code of [[rc -m]] 
in Chapter~\ref{chap:initialization-real}.
\l -m for rc_Main probably

%dup: Make.nw
Finally, [[rc]] supports a few options to provide advanced features or
to help debug [[rc]] itself.
%chunks:
I will present gradually those options in this book.
\l see rc.ps

% -l??
% -i => interactive (default when no argument given and isatty, see main())
% -I => not interactive 
%    only diff is prompt not displayed between commands
% -s => debug returned status when error status from subprocess
% -e => stops at first error (called like that from mk)
% -m => change init script? not rcmain but something else?
% -r => debug bytecodes output (convenient)

% Kernel run? init program? init.rc ! where at the end login program?


\section{[[boot.rc]]}

%toc:
In this section, I will present an example of an [[rc]] script 
showing a few features of [[rc]]'s scripting language.
\l rc the program vs the language? should be clear with context. will use rc
\l not tutorial, see books for that.
%trans:
The goal here is to illustrate the general features of a shell
you have seen in Section~\ref{sec:principles} with the concrete
syntax of [[rc]]'s scripting language.
%
This will also help you understand the grammar of [[rc]]
I will present in Chapter~\ref{chap:parsing}.
%
Finally, this example will introduce a few concepts specifics to [[rc]]
that are useful to have in mind while I will explain
the code of [[rc]] in the rest of the document.


[[boot.rc]], below, is the first program executed by the kernel when running
on an ARM machine (see the \book{Kernel}).
%toc:
The following sections will explain the main features of [[rc]]
used in this script.
%
%rc but syntax for those features very similar in other shells.
\n just for variable and list and special var path above

<<kernel/init/user/boot/arm/boot.rc>>=
#!/boot/rc -m /boot/rcmain

/boot/echo booooooooting...

path=(/bin /boot)

# basic devices
bind -c '#e' /env
...

# storage
bind -a '#S' /dev
fdisk -p /dev/sdM0/data >/dev/sdM0/ctl
dossrv
mount -c /srv/dos /root /dev/sdM0/dos
bind -a -c /root /

bind -a /arm/bin /bin
bind -a /rc/bin /bin
...

# to use 5c, 5a, 5l by default in mk
objtype=arm
...

exec /boot/rc -m /boot/rcmain -i
@
%#if (! ~ $#init 0)
%#	exec `{echo $init}
%#if (~ $service cpu)
%#	exec /$cputype/init -c
%#if not
%#	exec /$cputype/init -t


\subsection{[[#!]]}

\begin{verbatim}

%dup: 
% mentioned before?

% shebang! handled by kernel
%history: \unix V8 started to handle that, before was handled by sh itself
% but restricted because you could not exec() a shell script, so it was
% working only when the script was run from a shell

% scripts as regular commands! can become filter. components,
% building blocks!
% Before had to prefix command file with shell name (rc foo)

\n and comment (said later)












\end{verbatim}

\subsection{Initialization script}

\begin{verbatim}

% : [[rc -m]]

% -m, /boot/ because default is /xxx and not accessible at boot time


unix: .profile, .login, etc.








\end{verbatim}

\ref{chap:initialization-real}
\ref{sec:rcmain}

%\subsection{Running commands}

\begin{verbatim}

% execute program qualify full, universal REPL
%  also to echo things need external program! no special support in rc

\end{verbatim}

\subsection{Variables} %$

\begin{verbatim}

% variables list with () and separated by space




\end{verbatim}


\subsection{[[$path]]} %$


\begin{verbatim}

%  and special path variable

% plan9 support union dirs, so path usually small compared
% to Linux. Also no need /usr/bin/env ugly intermediate for #!


\end{verbatim}

\ref{sec:path-management}

\subsection{Comments}

\begin{verbatim}

% so for #! when pass file as argument,
%  parse file and skip this line because comment









\end{verbatim}

\subsection{Quoting and escaping}


\begin{verbatim}

% quote for # otherwise comment, escaping
% also ^?









\end{verbatim}

\ref{sec:quoting}

\subsection{The environment}

\begin{verbatim}

% variables exported to process launch from rc, so objtype
%  convenient for mk










\end{verbatim}

\ref{chap:environment}

\subsection{Builtins}
% : [[exec]]


\begin{verbatim}

% cant be command because modify things in current shell process.
% ex: chdir. As you will see soon, when execute commands,
% fork/exec, so chdir in child will have no effect on further commands.
% chdir modify state of shell!

% exec here is to replace current process by another, here same
% rc but with -i for interactive.

% exec builtin et -i for interactive!
% (not needed otherwise because detect Isatty, not
%  sure why we need it here














\end{verbatim}

\ref{chap:builtins}

\subsection{Other features}

\begin{verbatim}

% pipe, redirection seen before.
% control flow construct, shown before too.

% async, globbing (wildcard), 
% Present gradually in grammar chapter X







\end{verbatim}



%\section{Input shell language}

% run command (obviously), argv
% DSL for pipe, redirection, async, globbing
% mini classic language with control flow statement and variables, globals
% job control? has & but no fg/bg? (but has wait $apid)
% rc PL =~ dynamic
% basic DS = list of strings (List), with operator like ^
%  so different from bash here already. But better basis
%  to have list as core value, because no need PATH=: separator,
%  no need $* vs $@ . Just simpler.
% quite similar to bash
% main difference? for var stuff? 'if not' instead of 'else'.
%grouping! subshell! cool:
%	(for d in utils parsing typing bytecomp asmcomp driver tools/toplevel; \
%         do $(CAMLDEP) $(DEPFLAGS) $$d/*.mli $$d/*.ml; \
%         done) > .depend
% without this would have to do some initial >, and then some >>

%missing:
% - C-z (use multiple windows so no need job control)
% - history (use rio scroll and copy paste)
% - filename completion (use rio)
% - command completion

\section{Code organization}
\l after soft archi?

%dup: Assembler.nw
Table~\ref{tab:code-orga} presents short descriptions
of the source files of [[rc]], together with
the main entities (e.g., structures, functions, globals) the file defines,
and the corresponding chapter in this document in which the code
contained in the file is primarily discussed.

\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lcllr}
\toprule
{\bf Function}                 & {\bf Ch.}                     & {\bf File}     & {\bf Entities}                                  & {\bf LOC} \\
\otoprule
main data structures           & \ref{chap:core-ds}            & [[rc.h]]       & [<Tree>] [<Code>] [<Word>] [<Var>]     & \\ % Here PipeRdWr RedirEnum1 
execution data structures      & \ref{chap:core-ds}            & [[exec.h]]     & [<Thread>] [<List>]                                      & \\ % Redir Builtin and RedirEnum2
AST helpers                    & \ref{chap:core-ds}            & [[tree.c]]     & [<newtree()>] [<tree1()>] [<tree2()>]           & \\ % treenodes mung[123] epimung simplemung  [tree3()>] [freenodes()>]
globals                        & \ref{chap:core-ds}            & [[globals.c]]  & [<codebuf>] [<runq>]                            & \\ %
list of strings (words)        & \ref{chap:core-ds}            & [[words.c]]    & [<newword()>] [<count()>] [<freewords()>]       & \\ % copywords freelist? [copynwords()>]
shell variables                & \ref{chap:core-ds}            & [[var.c]]      & [<setvar()>] [<vlook()>] [<gvar>] [<gvlook()>]  & \\ % kenter kinit [newvar()>] 
function prototypes            & \ref{chap:core-ds}            & [[fns.h]]      & \\ %
\midrule

entry point                    & \ref{chap:main}               & [[main.c]]     & [<main()>]                                      & \\ % isatty Rcmain
execution utilities            & \ref{chap:main}               & [[executils.c]]& [<start()>] [<pushlist()>] [<pushword()>]   & \\ %  [Xerror()>] [Xreturn()>] Xpopredir poplist popword argv0

\midrule
character input and prompt     & \ref{chap:input}              & [[input.c]]    & [<getnext()>] [<pprompt()>] [<nextc()>] \\ % [token()>] [klook()>]
lexer                          & \ref{chap:lexing}             & [[lex.c]]      & [<yylex()>]                                     & \\ % wordchr idchr skipwhite skipnl  [<yyerror()>]
parser                         & \ref{chap:parsing}            & [[syn.y]]      & [<yyparse()>]                                   & \\ 

\midrule
bytecode generation            & \ref{chap:compile-interpret}  & [[code.c]]     & [<emitf()>] [<compile()>] [<outcode()>]         & \\ % 
process status                 & \ref{chap:compile-interpret}  & [[status.c]]   & [<setstatus()>] [<getstatus()>]                 & \\ % truestatus convstatuts
simple command bytecode        & \ref{chap:compile-interpret}  & [[simple.c]]   & [<Xsimple()>] [<execexec()>] [<doredir()>]      & \\ % execcmds execfunc (fn)
[[$path]] management           & \ref{chap:compile-interpret}  & [[path.c]]     & [<searchpath()>]                                & \\ %$
process-related bytecodes      & \ref{chap:compile-interpret}  & [[processes.c]] & [<execforkexec()>] [<Xpipe()>] [<Xasync()>]     & \\ % Xbackq Xpipefd Xsubshell 
other bytecodes                & \ref{chap:compile-interpret}  & [[exec.c]]     & [<Xtrue()>] [<Xjump()>] [<Xfn()>] & \\ % [Xwrite()>] [Xassign()>]

\midrule
shell builtins                 & \ref{chap:builtins}           & [[builtins.c]] & [<execcd()>] [<execexit()>] [<execdot()>]       & \\ % execshift execeval execflag [execwait()>]  [execwhatis()>]
shell environment              & \ref{chap:environment}        & [[env.c]]      & [<addenv()>] [<Vinit()>]                        & \\ % Updenv
wildcard matching              & \ref{chap:globbing}           & [[glob.c]]     & [<glob()>] [<match()>]                          & \\ % globlist Xglob
signal management              & \ref{chap:signals}            & [[trap.c]]     & [<dotrap()>]                                    & \\ %

\midrule
% initialization chapter?
here documents & \ref{chap:advanced-topics}    & [[here.c]]     & [<readhere()>] [<heredoc()>]                    & \\ %

\midrule
AST dumper                     & \ref{chap:debugging-appendix} & [[pcmd.c]]     & [<pcmd()>]                                      & \\ %
bytecode dumper                & \ref{chap:debugging-appendix} & [[pfnc.c]]     & [<pfnc()>]                                      & \\ %
error management               & \ref{chap:error}              & [[error.c]]    & [<panic()>]                                     & \\ %
memory management              & \ref{chap:utilities}          & [[utils.c]]    & [<emalloc()>] [<efree()>]                       & \\ % Dup Creat Unlink Malloc [inttoascii()>] ...
command-line flags             & \ref{chap:utilities}          & [[getflags.c]] & [<getflags()>] [<usage()>]                      & \\ % getflags.h flagset [flag>] 
buffered IO                    & \ref{chap:utilities}          & [[io.c]]       & [<openfd()>] [<rchr()>]                         & \\ % io.h openstr opencore
pretty printer                 & \ref{chap:utilities}          & [[fmt.c]]      & [<pfmt()>]                                      & \\ %
%misc utilities                 & \ref{chap:utilities}          & [[subr.c]]     &                                 & \\ % iacvt

\otoprule
Total                          &                               &                &                                                 & 6800 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Chapters and associated [[rc]] source files.}
\label{tab:code-orga}
\end{table*}

% still remains backward/mutual dependencies with codegraph on mk/ because:
%  - lots of ugly stuff

%pad: I reorganized quite heavily the source files of rc. Similar to the
% assembler/linker/compiler/, I simplified things by removing support
% for other operating systems (unix and win32) to focus only on
% plan9, so I removed unix.c, and spread plan9.c in other files.
% This led to far less circular deps. I also removed the havefork.c
% vs havenfork.c to support only OS that have fork.
%old: havenfork.c (and havefork.c): removed, no need to handle such OS
%old: unix.c, win32.c (and plan9.c): removed, we need to handle only one OS

<<includes>>=
#include "rc.h"
#include "exec.h"
#include "fns.h"
#include "getflags.h"
#include "io.h"
@
%pad: I factorized most include and changed the order. Not worth
% having different #include in each file

\section{Software architecture}

%toc: before presenting soft archi of rc itself, useful to see context
% and how rc fits in the big picture.

\subsection{The command-line user interface}
\n terminal, shell, login

The shell is only one {component} of the command-line user interface (CLI).
Figure~\ref{fig:cui-plan9} shows the components supporting
the CLI under \plan (the components for the CLI under \unix are very similar).

To run commands, the shell needs first a kernel to create processes. 
%dup: intro/requirements
The kernel provides services to applications (including the shell) through its
{\em system call interface} (also known as {\em syscalls}).
For example, under \plan, [[rfork()]] creates a new process in which
the shell can then [[exec()]] a program (see \book{Kernel}).

\begin{figure}[!tbp]\centering
\begin{verbatim}
   filesystem           +---------------+ +-------------------+
    interface           |               | |                   |  A
   |-- bin              |     Shell     | |command (e.g., ls) |  P
   |   |-- cp  +--------+-> stdin       | |      stdin        |  P
   |   |-- ls  |      +-+---stdout      | |      stdout       |  S
   |   |-- rc  |      | +---------------+ +-------------------+
   |   `-- ... |      |------------syscall interface------------
   |-- boot    |      | +-------------------------------------+
   |-- dev     |      | |               Kernel                |
   |   |--  cons <----+ |                                     |  K
   |   |         < - - +|  device drivers-+                   |  E
   |   |--  draw        |  |              |                   |  R
   |   |--  mouse      +|- + >console     |                   |  N
   |   `--  ...         |  |              |                   |  E
   |-- env           + -|- + -display     |                   |  L
   |-- sys              |  |  keyboard- - |                   |
   `-- ...           |  |  |  mouse - - -|+ - - - - - - +     |
                        |  |              |                   |
                     |  |  +-------------++             |     |
                        +-------------------------------------+
                     v                   |              |        D
                + - - - - - - -                                  E
                               |         v              v        V
                |   Monitor      + - - - - -      + - - - - -    I
                               |   keyboard |        mouse   |   C
                + - - - - - - -  + - - - - -      + - - - - -    E
                            Terminal                             S
                           (console)
\end{verbatim}
\caption{Components of the command-line user interface under \plan.}
\label{fig:cui-plan9}
\end{figure}

A shell needs also device drivers in the kernel handling
the terminal with its keyboard and monitor.
%
To access those devices, the kernel provides a {\em filesystem interface}
(called a {\em namespace} under \plan).
%
An application can [[open()]], [[read()]], [[write()]], or [[close()]]
\n also seek, actually pread(), pwrite()
files in this filesystem. Under \unix and \plan, devices are represented
as files. For example, [[/dev/cons]] (for console) is a file representing
the terminal. 
%dup: intro/requirements
To read characters from the keyboard, an application can simply
read characters from [[/dev/cons]].
%
To write characters on the monitor, an application can simply
write characters in [[/dev/cons]].
\l also /dev/draw, see \book{Graphics}
%
\t when kernel start, connect first process to /dev/cons and
\t following process inherits this configuration when fork, including rc.

\t separate program! huge innovation.

\begin{verbatim}

\t stdin stdout regular program
%plan9:
\t under \plan kernel run rc (see \book{Kernel} and Section{boot.rc}).
%unix:
\t Under \unix run init, then login, then shell in terminal. Even virtual
\t  terminal in Linux, 
\t under windowing system like rio also virtual terminals connected
\t stdin and stdout of process (see \book{Windows}).
% Figure X presents archi for plan9.

% shell = stuff around a kernel in a coquillage.
% history: multics.
% A shell is a bastard. See es paper quote in abstract
%  that reference unix programmnig environment book

% separate prog from kernel, can change shell!
%history: originated in Multics (one of the 2 things Thompson liked about
% Multics, the other being the hierarchical filesystem)

% for a long time actually there was no (external) shell? Shell was
% part of kernel? With Unix it changed and shell can be a regular user program.

% for interactive use, and for programming. Both uses, 
% and different features for those 2 things.

% regular program
% backspace handled by kerne
% line editing not shell
% \footnote not libreadline raw mode, completion


\end{verbatim}

\subsection{[[rc]]'s components}

%dup: (reverted order if figures) Assembler.nw
Figure~\ref{fig:dataflow}    describes the main data    flow of [[rc]], whereas
Figure~\ref{fig:controlflow} describes the main control flow of [[rc]].
%dup: intro/requirements
At its core, [[rc]] is both a {compiler} and a {bytecode interpreter}.
\l like OCaml, Perl, Ruby, etc.
As shown by Figure~\ref{fig:dataflow}, given a series of characters
(coming either from what you typed in the terminal or 
from the content of a script),
[[rc]] first groups those characters in {tokens} (with [<yylex()>]). Then,
[[rc]] parses those tokens (with [<yyparse()>]) and 
builds an {abstract syntax tree} (AST) of the program (see [<Tree>]). Finally,
\n actually not lexing -> parsing; for efficiency, parser calls lexer
\n on demand, so it can keep only one token in memory (opti, less important)
[[rc]] transforms this tree in a series of {bytecodes} (see [<Code>]).
%
This is similar to what a compiler such as [[5c]] does (see \book{Compiler}),
except a bytecode here is not an instruction 
from a concrete machine but
from a {\em virtual machine}.

\begin{figure}[!tbp]\centering
\begin{verbatim}
Input characters --> tokens --> AST --> bytecodes --> threads --> processes
\end{verbatim}
\caption{Data flow diagram of [[rc]].}\label{fig:dataflow}
\end{figure}

After this compilation, [[rc]] goes through the series of bytecodes and 
{interprets} them. [[rc]] keeps track of what is currently executing
in a [<Thread>] data structure and in a queue [<runq>]. This data structure
is called a ``thread'' because [[rc]] must sometimes manage 
multiple threads of execution. Indeed,
some of the bytecodes can create new processes running concurrently
(e.g., [<Xpipe()>], the bytecode handling pipes).
\l confusing then process vs thread? not fully clear in my head too


\begin{figure}[!tbp]\centering
\begin{verbatim}
                             +------------+
                             |    main    |
                             +-+----+-----+
                               |    |
                  .------------+----v-----------------.
                 (      bytecod| interpreter loop      ) (interpreting)
                  `------------+----+-----------------'
                               |    |
            +------------------++---+-------------+--------------------+
            |        +---------+|                 |                    |
     +------v-----+  |   +------v-----+   +-------v----+        +------v-----+
     |  Xrdcmds   |  |   |   Xpipe    |   |  Xsimple   |   ...  |    Xif     | bytecodes
     +-----+------+  |   +--+---------+   +--+-----+---+|       +------------+
           ||        |      |   |            |     |    |
           |+--------+---+  |   | +----------v-+   |   +v-----------+
     +-----+         |   |  |   | |execforkexec|  .|.  |   execcd   | shell builtins
     |            +--v---v--v--+| +------------+   |   +----------+-+
     |            |   start    ||        |         |              |
     v            +------------+|        |         |              |
+---------+                     |        |         |              |
| yyparse | (parsing)   +-------+-+      |         +----+         |
+----+-+--+             |         |      |              |         |
     | +-------+        |         |  +---+----+         |         |
+----v--+  +---v-----+  |         |  |        |         |         |
| yylex |  | compile |  |         |  |        |         |         |
+----+--+  +---------+  |         |  |        |         |         |
     |     (compiling)  |         |  |        |         |         |
+----v--+               |         |  |        |         |         |
| nextc |               v         v  v        v         v         v
+-------+        +--------+  +--------+  +--------+  +--------+  +--------+
                 |  pipe  |  |  fork  |  |  exec  |  |  wait  |  | chdir  |  syscalls
                 +--------+  +--------+  +--------+  +--------+  +--------+

\end{verbatim}
\caption{Control flow diagram of [[rc]].}\label{fig:controlflow}
\end{figure}

%trans:
In fact, [[rc]] does not start by compiling, but by interpreting. 
Indeed, [[rc]] starts first by interpreting some special bytecodes,
called the {\em bootstrap}, that contains a bytecode ([<Xrdcmds()>])
that then triggers the compiler.
\n lie a bit, there is call to finit instead (said later)
%trans: %dup: Assembler.nw
I will now explain briefly the control flow of [[rc]], starting from 
the top of Figure~\ref{fig:controlflow}.
\l and left to right


After some basic initializations,
\n no talk about command-line processing, confusing with command-line user
[<main()>] sets its local [<bootstrap>] to contain the initial set
of bytecodes to execute. It then calls [<start()>] with [<bootstrap>]
as an argument, to start interpreting this series of bytecodes.
%
Internally, [<start()>] just modifies the global [<runq>] to point to
a newly created [<Thread>], and sets the field [<Thread.code>] to 
the content of [<bootstrap>].
%
After [<start()>] returns, [<main()>] goes in a loop that interprets
the bytecodes in [[runq->code]].
\n [[runq->code[pc-1].f()]], 
\l also main set [[runq->argv]]


The most important bytecode in [<bootstrap>] is [<Xrdcmds()>],
\l actually it has a Xsimple "." rcmain and so will run execdot which
\l  will run Xrdcmds (said later?)
which reads a command (hence its name) and starts a new [<Thread>].
%
[<Xrdcmds()>] first calls the parser [<yyparse()>], which calls
the lexer [<yylex()>], which calls the input routine [<nextc()>] to
get the next character.
\l also yylex print prompt
%
By default, [<nextc()>] reads characters from the standard input, and
so it waits for the characters you type in a terminal.
\n old: "on the command-line" but better terminal, more precise
\n or script
Once you finished to enter a command with a {newline},
\l can be something else when command on multiple lines because skipnl
[<yyparse()>] will call [<compile()>] with the tree it built during
parsing as an argument.
%
Internally, [<compile()>] modifies the global [<codebuf>] to store
the bytecodes deriving from the tree.
\n via outcode
Then, after [<yyparse()>] returned, [<Xrdcmds()>] calls
[<start()>] to start a new thread with [<codebuf>] as a parameter.
%
[<start()>] then modifies again the global [<runq>], and when [<Xrdcmds()>]
returns, the main bytecode interpreter loop will process 
a new series of bytecodes stored in [[runq.code]].


Note that before modifying [<runq>], [<start()>] first links
the newly created thread with the old thread (through the
[<Thread.ret>] field). 
%
Moreover,[<compile()>] adds the bytecode [<Xreturn()>] at the end of
\l also called if error after yyparse, 
\l also exn mechanism?
the series of bytecodes deriving from your command.
%
Thus, after [<main()>] finished interpreting the bytecodes of your command,
it will process [<Xreturn()>], which will modify [<runq>] to point
to the old thread, the one containing the bootstrap bytecodes.
%
Then, after [<Xreturn()>] returns, the main bytecode interpreter loop
will process again the bytecodes from the bootstrap, which
will read another command through [<Xrdcmds()>].
\n actually Xrdcommands does a [[runq->pc--]] before start, but too specific


In [[rc]], the bytecodes are represented by regular C functions
starting by convention with an [[X]] 
(e.g., [<Xrdcmds()>], [<Xpipe()>], [<Xif()>]).
%
Thus, the bytecode interpreter is mainly a function dispatcher.
%
Internally those functions perform {system calls} to the kernel
to create a pipe ([[pipe()]]), 
to fork a new process ([[fork()]]),
to wait for a child process ([[wait()]]),
or to change directory ([[chdir()]]).
%
An important bytecode is [<Xsimple()>], which [[rc]] uses
to run a ``simple'' command.
\n basic, or atomic, one not containing a pipe, or redir
[<Xsimple()>] represents the essence of a shell: with
the series of system calls [[fork()]], [[exec()]], and [[wait()]],
[[rc]] can run a command in a new process and wait for
its termination (or interruption).
\l link to signal chapter.
%
[<Xsimple()>] is also responsible for managing the multiple shell builtins.
Indeed, if the name of the ``simple'' command is a builtin (e.g., [[cd]]),
then [<Xsimple()>] dispatches the appropriate function (e.g., [[execcd]])
\n another dispatch
instead of forking a new process.
%By convention, the functions representing builtins start with exec
\t except execforkexec which is confusing!

\subsection{Trace of a simple command: [[ls /]]}

You can see the bytecodes and the threads created internally by [[rc]] 
by running [[rc]] with the [[-r]] flag.
Here is an example of a {trace} of the simple command [[ls /]]:

\begin{verbatim}
% rc -r
pid 39 cycle 0002D930 1 Xmark ()
...
pid 38 cycle 0001984C 9 Xrdcmds
% ls /
pid 38 cycle 0002CBD0 1 Xmark
pid 38 cycle 0002CBD0 2 Xword ()
pid 38 cycle 0002CBD0 4 Xword (/)
pid 38 cycle 0002CBD0 6 Xsimple (ls /)
bin
boot
...
srv
pid 38 cycle 0002CBD0 7 Xreturn
pid 38 cycle 0001984C 9 Xrdcmds
\end{verbatim}

It is not important to fully understand the format of this trace
(see Section~\ref{sec:rc-r} for the full explanation and
for the code handling [[rc -r]]), but you can recognize a few of
the bytecodes I mentioned before: 
[<Xrdcmds()>], 
[<Xsimple()>], and 
[<Xreturn()>].
%
I will explain [<Xmark()>] and [<Xword()>] later in this document.

\begin{verbatim}

% It is interesting to understand the full trace of a simple command
% through the multiple layers of the software stack.
% Here is again the trace of the command [[ls /<newline>]] 
% entered in a terminal:

\t full trace ls\n 
\begin{enumerate}
\item After [[rc]] displayed its prompt,
\t 1 shell read(), sysread, connected to /dev/cons, consread
\t blocked (see \book{kernel})

\t item l

\t item s space /

\t item newline
\end{enumerate}

\end{verbatim}

%\subsection{Trace of a pipe}
% later
%\subsection{Trace of a redirection}
% later

\section{Book structure}

%trans: %dup: Assembler.nw
You now have enough background to understand the source code of [[rc]].
%toc:
The rest of the book is organized as follows.
%
I will start by describing the core data structures of [[rc]]
in Chapter~\ref{chap:core-ds}. 
%
Then, I will use a top-down approach, starting with Chapter~\ref{chap:main}
with the description of [<main()>], 
the initialization of [[rc]],
the bytecode interpreter loop, and 
the function [<Xrdcmds()>].
%
The following chapters will describe the main components of the compiler pipeline:
Chapter~\ref{chap:input} will present the input routines,
Chapter~\ref{chap:lexing} the lexer,
Chapter~\ref{chap:parsing} the parser, and finally
Chapter~\ref{chap:compile-interpret} the bytecode generator and bytecode
interpreter for the main features of [[rc]].
%
In Chapter~\ref{chap:builtins}, I will present the code of the different
shell builtins (e.g., [<execcd()>] for [[cd]]).
%
Chapter~\ref{chap:environment} contains the code to manage the environment
of the processes launched from the shell, and
Chapter~\ref{chap:signals} the code to manage the signals sent to
the processes (also known as {\em notes} under \plan).
%
Chapter~\ref{chap:initialization-real} presents the actual code
initializing [[rc]]. Indeed, Chapter~\ref{chap:main} presents
only a simplified initialization to not introduce too much
complexity early-on.
%dup: Assembler.nw
Then, I will present advanced features of [[rc]] that I did not present 
before to simplify the explanations, for instance,
wildcard matching (e.g., [[ls *.c]]) in Chapter~\ref{chap:globbing},
or command substitutions (e.g., \verb+`{ls}+) in Chapter~\ref{chap:advanced-topics}.
%dup: Assembler.nw
Those advanced features tend to crosscut
many components of [[rc]] with extensions to the lexer, the parser,
the bytecode generator, and the bytecode interpreter.
%
Finally, Chapter~\ref{chap:conclusion} concludes
and gives pointers to other books in the \principia series.

%toc:
Some appendices present the code of non-functional properties:
code to help debug [[rc]] itself in Appendix~\ref{chap:debugging-appendix} and
code to manage errors in Appendix~\ref{chap:error}.
%
Appendix~\ref{chap:utilities} contains the code of
utility functions used by [[rc]] but that are not specific to [[rc]]
(e.g., a library to manage string buffers).
%
Finally, Appendix~\ref{chap:examples} presents examples of [[rc]] scripts.



%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}


%toc:
In this chapter, I will present the core data structures of [[rc]].
%trans:
Most of those data structures are listed in Figure~\ref{fig:dataflow},
which presented the data flow of [[rc]].
%toc:
The first three sections will present the data structures
of the compiler part of [[rc]]: 
the token, 
the abstract syntax tree, and
the bytecode.
%
The bytecode is a data structure used both by the compiler and interpreter.
%toc:
The following sections will present the remaining data structures
of the interpreter part of [[rc]]: 
the thread, and the variable.
\l which is  by a list of words.


\section{[[Token]]}

<<token declarations>>=
%token FOR IN WHILE IF NOT SWITCH FN
%token TWIDDLE BANG  /** ~ ! */
%token REDIR PIPE /** {>, <, <<, >>} | */
%token ANDAND OROR /** && || */
%token COUNT SUB /** $# ( */
%token WORD /** anything else (e.g. foo, --help, 42, /a/b/c, etc) */
@
%old: was using %term instead of %token (probably for %terminal?)
%old: also ANDAND was mentioned only in %left, but better declare everything


% see pcmd() (and syn.y) for the chars not mentioned above:
%  '$', '"', '&', '^', '`', ';', '=' 
%  '(' (different from SUB, lexer trick), ')', '{', '}'
% not sure why treats different ~ (with TWIDDLE) and = (without a %token)


%typedef int Token_kind; (union { char; enum token_kind })
% see x.tab.h (a set of #define but could be an enum)
% with also ascii char into it
% so can also be ';' (see tree3() that actually look for that)

\section{Abstract syntax [[Tree]]}
% rc has a command language!

<<struct [[Tree]]>>=
struct Tree {

    // either<enum<Token_kind>, char>
    int	type;
    // string of the token or AST dump of the whole subtree for certain nodes
    char *str;

    // array<option<ref_own<Tree>>
    tree	*child[3];

    <<[[Tree]] redirection and pipe specific fields>>
    <<[[Tree]] word specific fields>>

    // Extra
    <<[[Tree]] extra fields>>
};
@
%dead: bool iskw;
%ocaml: a more precise AST

% AST tree of the command, ex "ls | wc" =>  ?
% can dump AST?

% str contain string of the tree. Used to store
% function in the environment.
% Used probably also for debugging for dumping.

% when use the 3 children?

% type is token kind, or character.
% Introduced also a few more token without syntax but part of enum.

<<token declarations>>=
/* not used in syntax */
%token SIMPLE 
%token ARGLIST WORDS
%token BRACE PAREN 
@
% why BRACE and not keep '{' 
%ocaml: use directly list for ARGLIST, WORDS, and use list also
%  for BRACE and PAREN
\l looks not like Abstract Syntax Tree if carry BRACE and PARENS in AST
\l  but here it's really abused to represent a construct




% populated in newtree() (which is called to build AST in yyparse())
<<global [[treenodes]]>>=
// list<ref_own<Tree>> (next = Tree.next)
tree *treenodes;
@
% record the list of all allocated nodes there, so they can be
% freed in Xrdcmds once the tree has been compiled
% (but could do via tree exploration from root too)
%ocaml: ugly global

<<[[Tree]] extra fields>>=
tree	*next;
@


<<function [[newtree]]>>=
/*
 * create and clear a new tree node, and add it
 * to the node list.
 */
tree*
newtree(void)
{
    tree *t = new(tree);
    t->str = nil;
    t->child[0] = t->child[1] = t->child[2] = nil;

    // add_list(t, treenodes)
    t->next = treenodes;
    treenodes = t;

    return t;
}
@
%dead:    t->iskw = false;
%ocaml: build directly

% dead: it uses freenodes now.
%<<function freetree>>=
%void
%freetree(tree *p)
%{
%    if(p==nil)
%        return;	
%    freetree(p->child[0]);
%    freetree(p->child[1]);
%    freetree(p->child[2]);
%    if(p->str)
%        efree(p->str);
%    efree((char *)p);
%}
%@
%ocaml: use gc

% efree = emalloc = wrapper around free but handling error.

<<function [[freenodes]]>>=
void
freenodes(void)
{
    tree *t, *u;
    for(t = treenodes;t;t = u){
        u = t->next;
        if(t->str)
            efree(t->str);
        efree((char *)t);
    }
    treenodes = nil;
}
@
% and does not call freetree()? all trees are linked together
% in newtree anyway, so here enough to explore flatten list instead
% of "complex" tree.
%ocaml: use gc


% used in syn.y
<<function [[tree1]]>>=
tree*
tree1(int type, tree *c0)
{
    return tree3(type, c0, (tree *)nil, (tree *)nil);
}
@
%ocaml: use precise AST so no need shove everything in tree with 3 children.

<<function [[tree2]]>>=
//@Scheck: used by syn.y
tree* tree2(int type, tree *c0, tree *c1)
{
    return tree3(type, c0, c1, (tree *)nil);
}
@

<<function [[tree3]]>>=
tree*
tree3(int type, tree *c0, tree *c1, tree *c2)
{
    tree *t;

    <<[[tree3]] if some empty sequence>>
    // else
    t = newtree();
    t->type = type;
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@
% no check for c2 when use ';'? no because binary operator?


% opti but useful because get lots of empty commands
% for instance when if() {\n ... \n} then get already two
% empty command for the two newlines.
<<[[tree3]] if some empty sequence>>=
if(type==';'){
    if(c0==nil)
        return c1;
    if(c1==nil)
        return c0;
}
@



\section{Byte[[Code]] and [[codebuf]]}
%old: was called 'Opcode' in original comments, but I prefer 'bytecode'

% shell = interpreter. Actually source -> AST -> bytecode
% and then bytecode interpreter, a bit like an actual processor
% (or Java). A little stack based interpreter.

<<global [[codebuf]]>>=
// growing_array<ref_own<Code>>
code *codebuf;				/* compiler output */
@
%ocaml: maybe could just interpret from AST itself.
% not sure needs this intermediate bytecode data structure
%ocaml: ugly to use a global again. Better compile returns codebuf

<<struct [[Code]]>>=
/*
 * The first word of any code vector is a reference count.
 * Always create a new reference to a code vector by calling codecopy(.).
 * Always call codefree(.) when deleting a reference.
 */
union Code {
    void	(*f)(void); // Xxxx() bytecode
    int	i;
    char	*s;
};
@
%ocaml: use variant. Still need the integer for the jumps
% (but no need for reference counting), and also for file descriptor arguments
% for certain bytecodes like Pipe, Dup, etc.

% show bootstrap code?
% or show trace of rc -r ? with my simple bootstrap code!


% * Opcode routines
% * Arguments on stack (...)
% * Arguments in line [...]
% * Code in line with jump around {...}
\t change comment below, use (left)(right) for instance
\t  a closer to output by -r

% * Xrdcmds !!! call yyparse()

% * Xsimple(args)			run command and wait

% * Xmark				mark stack
% * Xword[string]			push string
% * Xpopm(value)			pop value from stack
% * Xcount(name)			push var count
% * Xconc(left, right)			concatenate, push results
% * Xqdol(name)				concatenate variable components

% * Xassign(name, val)			assign val to name
% * Xdol(name)				get variable value
% * Xsub
% * Xglob
% * Xlocal(name, val)			create local variable, assign value
% * Xunlocal				delete local variable

% * Xexit				rc exits with status
% * Xreturn				kill thread

% * Xeflag

% * Xread(file)[fd]			open file to read
% * Xwrite(file)[fd]			open file to write
% * Xrdwr(file)[fd]			open file for reading and writing
% * Xappend(file)[fd]			open file to append
% * Xclose[i]				close file descriptor
% * Xdup[i j]				dup file descriptor
% * Xpopredir

% * Xif
% * Xifnot
% * Xbang				complement condition
% * Xwastrue
% * Xfalse{...}				execute {} if false
% * Xtrue{...}				execute {} if true
% * Xmatch(pat, str)			match pattern, set status
% * Xcase(pat, value){...}		exec code on match, leave (value) on stack
% * Xfor(var, list){... Xreturn}	for loop
% * Xjump[addr]				goto

% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,	wait for both
% * Xpipewait
% * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output, depending on type), push /dev/fd/??

% * Xfn(name){... Xreturn}			define function
% * Xdelfn(name)				delete function definition
% * Xrdfn

% * Xsubshell{... Xexit}		execute {} in a subshell and wait
% * Xasync{... Xexit}			make thread for {}, no wait
% * Xbackq{... Xreturn}			make thread for {}, push stdout


% ???
% * Xdelhere

% * Xerror // print error message and then Xreturn while not interactive thread
%   but it not a generated bytecode! should rename just error

% list of bytecodes with comments were in exec.c but sorted alphabetically
% better to group them for explanation

% dol = dollar

% first element is a reference count, which is why codecopy()
% does cp[0].i++;

% why inline vs in stack? Because many things require evaluation
% and are not known at compile-time. For instance, Fn
% could have a string name after inline in the codevec, but
% actually the argument to fn is a word, which can be a^b, or
% use $, so we need evalation.

% FIGURE where see all argv

% Xfn -> <> 
<<function [[codecopy]]>>=
code*
codecopy(code *cp)
{
    cp[0].i++;
    return cp;
}
@
%ocaml: just use Gc

% when bytecodes are shared? just for bootstrap? need this reference count?
% when define functions.

% Xreturn | Xfn | Xdelfn -> <>
<<function [[codefree]]>>=
void
codefree(code *cp)
{
    code *p;
    // check ref count
    if(--cp[0].i != 0)
        return;

    for(p = cp+1; p->f; p++){
        <<[[codefree()]] in loop over code [[cp]], switch bytecode cases>>
    }
    efree((char *)cp);
}
@
%ocaml: just use Gc


<<[[codefree()]] in loop over code [[cp]], switch bytecode cases>>=
if(p->f==Xfalse || p->f==Xtrue
|| p->f==Xread || p->f==Xwrite || p->f==Xrdwr
|| p->f==Xappend || p->f==Xclose 
|| p->f==Xasync || p->f==Xbackq || p->f==Xcase 
|| p->f==Xfor || p->f==Xjump
|| p->f==Xsubshell)
    p++;
@






\section{[[Thread]] and [[runq]]eue}

% why called threads?
% because they contains bytecodes to execute.
% They are not the process. When interpreting the bytecodes
% they may generate new process but they are not themselves
% processes.
% Still thread is maybe confusing.
% Maybe rename Program? but true that contains code, and pc!
% So it is a unit of execution (then maybe thread is a good name).


<<struct [[Thread]]>>=
struct Thread {
    union Code *code;		/* code for this thread */
    int pc;			/* code[pc] is the next instruction */

    <<[[Thread]] other fields>>

    // Extra
    <<[[Thread]] extra fields>>
};
@
%dead fld:  tree *treenodes;		/* tree nodes created by this process */

<<global [[runq]]>>=
// stack<ref_own<Thread>> (next = Thread.ret)
thread *runq;
@
% x; y; z  would form a list of threads with x at the top and linked to y
% (and ultimately linked to the bootstrap thread)

% when put stuff on stack? when run commands, do x;y, then
% has bytecodes of repl in stack, and add more process on top of it.

<<[[Thread]] extra fields>>=
thread *ret;		/* who continues when this finishes */
@
%ocaml: just use a list for runq, but then need extra function
% to access head of the list. Could also have run and runq.

% freethread()? with reference count handling?

% important one!!
<<[[Thread]] other fields>>=
// list<list<ref_own<word>>> (next = List.next)
struct List *argv;		/* argument stack */
@
% list of list of words?
%ocaml: split Thread.argv and Thread.argv_stack

% runq->argv->words->next->word
% todo define macro? argv1()? argv0() ?


% really intepreter small language, have locals!
% TODO rename local -> locals?
<<[[Thread]] other fields>>=
// list<ref_own<Var>> (next = Var.next)
struct Var *local;		/* list of local variables */
@


% Similar to a machine emulator. Code, pc, stack, and heap (the vars).






\section{Words and lists of words}
% in appendix?

%trans:
% saw argv in Thread before, list, but really list
% of sequence of words, so see words first.

\subsection{[[Word]]s}

<<struct [[Word]]>>=
/*
 * word lists are in correct order,
 * i.e. word0->word1->word2->word3->nil
 */
struct Word {
    char *word;

    // Extra
    word *next;
};
@
% could define W = nil so avoid those (word*)nil
%dup: similar to the one in Make.nw?
%ocaml: just use list

<<function [[newword]]>>=
word*
newword(char *wd, word *next)
{
    word *p = new(struct Word);
    p->word = strdup(wd);
    p->next = next;
    return p;
}
@
%ocaml: cons ::

% could also have mksingleword that does not take next.
% many calls to newword(foo, (word*)nil) that could be shorter.

<<function [[count]]>>=
int
count(word *w)
{
    int n;
    for(n = 0;w;n++) 
        w = w->next;
    return n;
}
@
%ocaml: List.length


<<function [[copynwords]]>>=
word*
copynwords(word *a, word *tail, int n)
{
    word *v = nil;
    word **end = &v;
    
    while(n-- > 0){
        *end = newword(a->word, 0);
        end = &(*end)->next;
        a = a->next;
    }
    *end = tail;
    return v;
}
@

<<function [[copywords]]>>=
/*
 * copy arglist a, adding the copy to the front of tail
 */
word*
copywords(word *a, word *tail)
{
    word *v = nil;
    word **end;

    for(end=&v;a;a = a->next,end=&(*end)->next)
        *end = newword(a->word, nil);
    *end = tail;
    return v;
}
@
%ocaml: use gc so copy for free, and just use @ to concat


<<function [[freewords]]>>=
void
freewords(word *w)
{
    word *nw;
    while(w){
        efree(w->word);
        nw = w->next;
        efree((char *)w);
        w = nw;
    }
}
@
%ocaml: use gc


% diff with freewords???
<<function [[freelist]]>>=
void
freelist(word *w)
{
    word *nw;
    while(w){
        nw = w->next;
        efree(w->word);
        efree((char *)w);
        w = nw;
    }
}
@


\subsection{[[List]] of sequence of words}

% used in Thread for argv.

<<struct [[List]]>>=
struct List {
    // list<ref_own<Word>> (next = Word.next)
    word *words;

    // Extra
    list *next;
};
@
% so it's actually a list of list (so fast concatenation?)




\section{[[Var]]iables}
%  and [[gvar]]

% saw 'local' vars in Thread before?

% what need vars for?
% when do X=1 in shell.
% also for setting status of special variable like "status".

<<struct [[Var]]>>=
struct Var {
    // key
    char	*name;		/* ascii name */
    // value
    word	*val;		/* value */

    <<[[Var]] other fields>>
    // Extra
    <<[[Var]] extra fields>>
};
@
% when have local vars? when need that?

<<[[Var]] extra fields>>=
var	*next;		/* next on hash or local list */
@
% #define V (struct Var*)nil
% like for other soft, or use VarNil?



<<function [[setvar]]>>=
void
setvar(char *name, word *val)
{
    struct Var *v = vlook(name);
    freewords(v->val);
    v->val = val;
    v->changed = true;
}
@
% changed is for optimization reason to avoid rewriting in /env/xxx


<<function [[vlook]]>>=
var*
vlook(char *name)
{
    var *v;
    if(runq)
        for(v = runq->local;v;v = v->next)
            if(strcmp(v->name, name)==0) 
                return v;

    return gvlook(name);
}
@
% use global runq again
% look for locals first, then gvlook
% cases where runq is empty? call vlook very early?




<<constant [[NVAR]]>>=
#define	NVAR	521
@

<<global [[gvar]]>>=
// map<string, ref_own<Var>> (next = Var.next in bucket list)
var *gvar[NVAR];		/* hash for globals */
@
% vs locals
%ocaml: use Hashtbl


% populate if not already there
<<function [[gvlook]]>>=
var*
gvlook(char *name)
{
    int h = hash(name, NVAR);
    var *v;

    for(v = gvar[h];v;v = v->next) 
        if(strcmp(v->name, name)==0) 
            return v;
    gvar[h] = newvar(strdup(name), gvar[h]);
    return gvar[h];
}
@
%old: return gvar[h] = newvar(strdup(name), gvar[h]);

<<function [[hash]]>>=
unsigned
hash(char *as, int n)
{
    int i = 1;
    unsigned h = 0;
    uchar *s;

    s = (uchar *)as;
    while (*s)
        h += *s++ * i++;
    return h % n;
}
@


<<function [[newvar]]>>=
var*
newvar(char *name, var *next)
{
    var *v = new(var);
    v->name = name;
    v->val = nil;

    v->fn = nil;
    v->changed = false;
    v->fnchanged = false;

    v->next = next;
    return v;
}
@
% changed and fnchanged are for optimization reason, to try
% to avoid writing in /env/xx when no need

% special variable, e.g. vlook("home"), vlook("*")








\chapter{[[main()]]}
\label{chap:main}


\section{Overview}

<<[[main()]] locals>>=
code bootstrap[17];
@
\swdefs{bootstrap}
% indeed 17 lines below about bootstrap. A bit ugly though

% see Chapter X for actual boostrap. I will simplify for now.

% mv comment back in Extra? less confusing with actual bootstrap vs simple one
%/*
% * get command line flags.
% * initialize keywords & traps.
% * get values from environment.
% * set $pid, $cflag, $*
% * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)
% * start interpreting code
% */

<<function main (rc/exec.c)>>=
void main(int argc, char *argv[])
{
    <<[[main()]] locals>>

    <<[[main()]] argc argv processing, modify flags>>

    <<[[main()]] initialisation>>
    <<[[main()]] initialize [[boostrap]]>>
    <<[[main()]] initialize [[runq]] with bootstrap code>>
    <<[[main()]] initialize [[runq->argv]]>>

    <<[[main()]] interpreter loop>>
}
@

\section{Command-line arguments processing}
% [[getflags()]]


<<global [[flag]]>>=
// map<char, option<array<string>>>
char **flag[NFLAG];
@
%could transform global flag in bool flag[NFLAG] ?
% no cos other places use flags for -m where except elements after
% But need array of elements?
% maybe would need just string, but getflags is generic library probably.
%ocaml: use Arg

<<constant [[NFLAG]]>>=
#define	NFLAG	128
@
% #chars in ASCII

% =~ true (a bit ugly)
<<global [[flagset]]>>=
char *flagset[] = {"<flag>"};
@

<<[[main()]] argc argv processing, modify flags>>=
argc = getflags(argc, argv, "SsrdiIlxepvVc:1m:1[command]", 1);
if(argc==-1)
    usage("[file [arg ...]]");
@
% getflags() defined in Appendix.
%-d and -p are actually dead
%ocaml: Arg is cleaner than this getflags where everything needs to be
% an array of string, even a boolean flag.

% usage is generic, part of getflags.c (use global to remember
%  format passed to getflags?)

% so c:1 so -c except one argument.
% same for -m.


% when do  sh foo.sh <some arguments>
% can we have conflicts in some arguments with flags that sh would
% interpret?

\subsection{Login mode: [[rc -l]]}
% or nothing but - in argv0

<<[[main()]] argc argv processing, modify flags>>=
if(argv[0][0]=='-')
    flag['l'] = flagset;
@
% if -l or first char is - then means login shell.
% so read $home/lib/profile

\subsection{Interactive mode: [[rc -i]]}
% or nothing but can detect Isatty

%history: also in bourne shell

% mv later? advanced feature? hmm interactive is important notion.
<<[[main()]] argc argv processing, modify flags>>=
if(flag['I'])
    flag['i'] = nil;
else 
    if(flag['i']==nil && argc==1 && Isatty(STDIN)) 
       flag['i'] = flagset;
@

% interactive mode if no arguments!

<<function [[Isatty]]>>=
bool
Isatty(fdt fd)
{
    char buf[64];

    if(fd2path(fd, buf, sizeof buf) != 0)
        return false;

    /* might be #c/cons during boot - fixed 22 april 2005, remove this later */
    if(strcmp(buf, "#c/cons") == 0)
        return true;

    /* might be /mnt/term/dev/cons */
    return strlen(buf) >= 9 && strcmp(buf+strlen(buf)-9, "/dev/cons") == 0;
}
@

% runq->iflag = flag['i']? true : false;// interactive mode; will print a prompt
% code using iflag:
\ref{sec:display-prompt}

%chunks:
% far more flags presented gradually

\section{Initialization}

% put back global err here, with its Io type?

<<[[main()]] initialisation>>=
err = openfd(STDERR);
@
% err = openfd, use buffered IO lib, see appendix for error management.
%ocaml: stderr already use buffered IO.

<<[[main()]] initialisation>>=
kinit();    // initialize keywords
Trapinit(); // notify() function setup
Vinit();    // read environment variables and add them in gvar
@
%ocaml: kinit -> use ocamlllex


\section{Bootstrapping bytecodes (simplified)}

\ifallcode
<<[[main()]] locals>>=
int i;
@
\fi


% simplified bootstrap:
% Xrdcmds (which will call yyparse()->compile()->outcode()
%  which will read a line, compile it, and add a Xreturn
%when want to experiment with simplified bootstrap
% (don't forget to also modify mkfile and put 'rc2' for TARG
%OPTIONAL
<<[[main()]] initialize [[boostrap]] (simplified)>>=
memset(bootstrap, 0, sizeof bootstrap);

i = 0;
bootstrap[i++].i = 1; // reference count
bootstrap[i++].f = Xrdcmds;
bootstrap[i].i = 0;
@
%bootstrap[i++].f = XMark; ? necessary?
%bootstrap[i++].f = Xexit; ? Xexit never reached I think.
% 1 to reference count? why? they put 0 in compile() for new bytecodes
%ocaml: no need end of list, no need reference count

\section{Setting [[runq]]}
% [[start()]]

<<[[main()]] initialize [[runq]] with bootstrap code>>=
start(bootstrap, 1, (var *)nil);
@
% starts at 1; 0 is for the reference count

% modify runq! usually called with pc = 1
% main | Xrdcmds | ??? -> <>
<<function [[start]]>>=
void
start(code *c, int pc, var *local)
{
    struct Thread *p = new(struct Thread);

    p->code = codecopy(c);
    p->pc = pc;

    p->argv = nil;
    p->local = local;

    p->cmdfile = nil;
    p->cmdfd = nil;
    p->lineno = 1;
    p->eof = false;
    p->iflag = false;

    <<[[start()]] set redir>>

    // add_stack(runq, p)
    p->ret = runq;
    runq = p;
}
@
% not reset iflast to false?
\t maybe should call it new_thread() because it does not
\t  start it right away, and should do the add_stack in the caller.
%ocaml: I renamed it mk_thread and do runq := t::!run in the caller. clearer.

% called sometimes with pc different of 1? yes, for async, trap,
%  pipe, etc.

% will go back to previous Thread (put in runq stack) if
% the new code does some Xreturn.
% So idea of subcomputation. With then fresh argv, fresh code list.

% When call start()? main, Xrdcmds. Xrdcmds is really
% a read/eval/print loop.

% very first time runq should be nil so p->ret points to nil.

\section{Setting [[runq->argv]]}

% now that runq set.

<<global [[argv0]]>>=
/*
 * Start executing the given code at the given pc with the given redirection
 */
char *argv0="rc";
@
% used by? it is override below, but used by what after?

<<[[main()]] initialize [[runq->argv]]>>=
/* prime bootstrap argv */
pushlist();
argv0 = strdup(argv[0]);
for(i = argc-1; i!=0; --i) 
    pushword(argv[i]);
@
% start from end because list/stack so at the end the top of the stack will
% be the first argument of the command
% does getflags consume argv and argc? Yes! so push only non flags
%ocaml: no need to call pushlist() here. Already have working argv.
% no nil in OCaml!

% so runq->argv is populated, and as you will see later,
% bootstrap code assign it in $*!


% see pushlist() below

% this list is actually manipulatd by Xmark, etc
% so runq->argv is the argument to the bytecodes, not just
% to the simple command (but actually simple commands become
% Xsimple so this bytecode look at runq->argv)

% main | Xmark ->  <>
<<function [[pushlist]]>>=
void
pushlist(void)
{
    list *p = new(list);

    // add_list(p, runq->argv)
    p->next = runq->argv;
    p->words = nil;
    runq->argv = p;
}
@
% use runq, assume runq not nil! otherwise segfault


<<function [[pushword]]>>=
void
pushword(char *wd)
{
    if(runq->argv==nil)
        panic("pushword but no argv!", 0);
    runq->argv->words = newword(wd, runq->argv->words);
}
@
% use global runq
% note that newword take the old value of the list so indeed
%  it adds wd in the list of words.
%ocaml: no need for panic, argv always at least empty list


\section{Bytecode interpreter loop}

<<[[main()]] interpreter loop>>=
for(;;){
    <<[[main()]] debug runq in interpreter loop>>

    runq->pc++;
    (*runq->code[runq->pc-1].f)();

    <<[[main()]] handing trap if necessary in interpreter loop>>
}
@
%ocaml: how sure that a function? not typesafe.


\section{Reading commands: [[Xrdcmds()]]}
\n the REPL? not just Xrdcmds, the loop is in main and print in program

% X(bytecode) read commands

% Xrdcmds =~ REPL, but not really
%  read (yylex+yyparse),
%  eval (compile+outcode+return to interpreter)
%  print? hmm partly in yylex for the prompt, the rest the program does it
%  loop? kinda because do a pc-- below so do its own loop
%  inside the enclosing interpreter loop

% should be called Xrdline though.
<<function [[Xrdcmds]]>>=
void
Xrdcmds(void)
{
    struct Thread *p = runq;
    bool error;
    <<[[Xrdcmds()]] other locals>>

    <<[[Xrdcmds()]] flush errors and reset error count>>
    <<[[Xrdcmds()]] print status if -s>>
    <<[[Xrdcmds()]] set promptstr if interactive mode>>

    <<[[Xrdcmds()]] calls Noerror() before yyparse()>>
    // read one cmd line, compiles it, and modifies codebuf global
    error = yyparse();

    <<[[Xrdcmds()]] if yyparse() returned an error>>
    else{
        <<[[Xrdcmds()]] reset ntrap>>
        --p->pc;	/* re-execute Xrdcmds after codebuf runs */
        // modifies runq, new thread (linked to bootstrap one)
        start(codebuf, 1, runq->local);
    }
    freenodes(); // allocated in yyparse()
}
@
% will go back to Xrdcmds because of the Xreturn inserted in
% the codebuf by compile()
%ocaml: ugly: use some globals everywhere. treenodes, codebuf
% so here yyparse call internally compile that modifies codebuf, but hard to see

\l pass local so share ? so after execute a line, the parent
\l  thread has its local modified too.

% flow a bit complicated, but
% interpreter loop on runq->code -> Xrdcmds() -> yyparse() -> start(codebuf)
%  will go back in loop with a new runq! and once the command is done
%  with a Xreturn it will resume to Xrdcmds runq (the bootstrap queue)
%  and because of the --p->pc, it will restart on the Xrdcmds


% yyparse() use runq global, and special additional fields:
% (actually it's yylex())

<<[[Thread]] other fields>>=
struct Io *cmdfd;	/* file descriptor for Xrdcmd */
char *cmdfile;		/* file name in Xrdcmd */
bool iflag;		/* interactive? */
@
% who sets cmdfd? see below.

%OPTIONAL (really?)
<<[[main()]] initialize [[runq]] with bootstrap code>>=
runq->cmdfd = openfd(STDIN); // reading from stdin
runq->cmdfile = "<stdin>";
runq->iflag = flag['i']? true : false;// interactive mode; will print a prompt
@
% eof set to false in start()
% cmdfile setting is not necessary, but it's used in yyerror() so why not set it

% for iflag, why not always use global? why need an extra field?
%  someone can alter iflag?

% those fields can be changed when do '.' ? to source a script?
% or when -c ? This is why they are fields and not globals?

% note that start() reset those fields.

% where cmdfd is used? in yylex() getnextc(), called from yyparse()


% when execute a script, cmdfd is the fd for the script, but not
% that yyparse still parse one line at a time, and so Xrdcmds
% will read one line, compile it, execute, and then go to other line.
% Also means that if modify script while running, might have weird
% behavior.

%XXX
% C-d generates an EOF?
<<[[Xrdcmds()]] if yyparse() returned an error>>=
if(error){
    if(!p->iflag  ||  p->eof && !Eintr()){
        if(p->cmdfile)
            efree(p->cmdfile);
        closeio(p->cmdfd);

        Xreturn();	/* should this be omitted? */
    }else{
        if(Eintr()){
            pchr(err, '\n');
            p->eof = false;
        }
        --p->pc;	/* go back for next command */
    }
}
@
% mv later?

% Xreturn does something special? 

% no error reporting? or rely on yyerror also called by yyparse? 



\chapter{Input}
\label{chap:input}
% so Lexing chapter cleaner

%trans: before yyparse, see routines used by yylex, called from yyparse.

\section{Overview}

% main -> Xrdcmds -> yyparse() -> yylex() -> nextc() -> getnextc() 
%  which use runq->cmdfd to read stuff.


\section{Reading a character: [[getnext()]]}

% why return an int and not a char? because unicode? then use Rune!
% yylex -> nextc -> <>
<<function [[getnext]]>>=
/*
 * read a character from the input stream
 */	
int
getnext(void)
{
    int c;
    <<[[getnext()]] other locals>>

    <<[[getnext()]] peekc handling>>
    <<[[getnext()]] return if already at EOF>>
    <<[[getnext()]] prompt management before reading the character>>

    c = rchr(runq->cmdfd);

    <<[[getnext()]] handle backslash>>
    <<[[getnext()]] prompt management after the character is read>>
    <<[[getnext()]] if character read is EOF>>
    <<[[getnext()]] if not EOF but verbose mode, print character read>>

    return c;
}
@
%old: was runq->eof++; ugly

% rchr() in annex? bufio library?



\subsection{End-of-file management}

<<constant EOF (rc/io.h)>>=
#define	EOF	(-1)
@
% possibly returned by rchr()

<<[[getnext()]] if character read is EOF>>=
if(c==EOF)
    runq->eof = true;
@
%ocaml: not sure we need this.

<<[[Thread]] other fields>>=
bool eof;		/* is cmdfd at eof? */
@
% used for? for next getnext(), but otherwise?


<<[[getnext()]] return if already at EOF>>=
if(runq->eof)
    return EOF;
@

%ocaml: ocamllex handles that already?

\subsection{Multiple lines commands and escaped newlines}
\label{sec:escaping-newline}

% more on newlines later.

% if backslash, dont return backslash char, return after
% but only if not in a string, hence the !inquote guard below.

<<[[getnext()]] handle backslash>>=
if(!inquote && c=='\\'){

    c = rchr(runq->cmdfd);

    if(c=='\n' && !incomm){		/* don't continue a comment */
        <<[[getnext()]] when backslash and newline, set doprompt>>
        c=' ';
    }
    else{
        peekc = c;
        c='\\';
    }
}
@
% need to look ahead to see if \\\n, so if was not \n, then
% return backslash and go back in input stream.
% but do that via peekc technique. Classic.

%ocaml: ocamllex does the longest match and handle peek internally I think

<<[[getnext()]] other locals>>=
static int peekc = EOF;
@

<<[[getnext()]] peekc handling>>=
if(peekc!=EOF){
    c = peekc;
    peekc = EOF;
    return c;
}
@



\subsection{Displaying the prompt}
\label{sec:display-prompt}

% so $prompt is actually a 2 words list, first word = original
% and second word when it's a multiline command?

<<global [[doprompt]]>>=
bool doprompt = true;
@
% set to true by default! so first time run rc, will
% get a prompt.

% could be moved in another section?
<<global [[promptstr]]>>=
char *promptstr;
@

<<[[Xrdcmds()]] other locals>>=
word *prompt;
@
<<[[Xrdcmds()]] set promptstr if interactive mode>>=
if(runq->iflag){
    prompt = vlook("prompt")->val;
    if(prompt)
        promptstr = prompt->word;
    else
        promptstr="% ";
}
@



<<[[getnext()]] prompt management before reading the character>>=
if(doprompt)
    // pprompt() internally set doprompt back to false at the end
    pprompt();
@
% remember that set to true in global at startup.
% so first character read we will get a prompt.

<<function [[pprompt]]>>=
void
pprompt(void)
{
    var *prompt;

    if(runq->iflag){
        // printing the prompt
        pstr(err, promptstr);
        flush(err);

        // set promptstr for the next pprompt()
        prompt = vlook("prompt");
        if(prompt->val && prompt->val->next)
            promptstr = prompt->val->next->word;
        else
            promptstr="\t";
    }
    runq->lineno++;
    doprompt = false;
}
@
% ?? why not % for the prompt? why changing the promptstr here?
% when multiline command! enter if(ls) ENTER => get a \t prompt
%ocaml: maybe a bit ugly to couple the prompt stuff and lineno.

% note that print prompt on stderr

% flush cos no newline in prompt but still want it displayed ASAP.

% if enter {, then also special prompt indent (but just one level,
% does not handle more depth)

% so can display in prompt which command we are. useful also for history?
% to run a past command?
<<[[Thread]] other fields>>=
int lineno;			/* linenumber */
@
% useful for error reporting I think, when running a script!


<<[[getnext()]] prompt management after the character is read>>=
doprompt = doprompt || c=='\n' || c==EOF;
@
% doprompt case before because when \\n then c becomes space
%  but still want the doprompt and indeed doprompt is set in backslash
%  code handling
%ocaml: can do that in lexer?

% do that also for EOF so once parsed a script, and goes back
% to Xrdcmds loop, the next getc will print a prompt


<<[[getnext()]] when backslash and newline, set doprompt>>=
doprompt = true;
@


\section{Looking ahead: [[nextc()]] and [[advance()]]}

% often need look ahead in lexing (or the dual: backtracking)

<<global [[future]]>>=
int future = EOF;
@
%ocaml: let ocamllex handles that

% yylex | advance | skipnl | nextis -> <>
<<function [[nextc]]>>=
/*
 * Look ahead in the input stream
 */
int
nextc(void)
{
    if(future==EOF)
        future = getnext();
    return future;
}
@
% future and peekc??
% so return same char until call advance().
% So can call nextc() from multiple places. nextc() acts then
% like a global.

% note that calls getnext()! so anything consuming a new character
%  will get all the backslash and doprompt logic.

% nextis -> <>
<<function [[advance]]>>=
/*
 * Consume the lookahead character.
 */
int
advance(void)
{
    int c = nextc();
    <<[[advance()]] save future in lastc>>
    future = EOF;
    return c;
}
@


% yylex -> <>
<<function [[nextis]]>>=
bool
nextis(int c)
{
    if(nextc()==c){
        advance();
        return true;
    }
    return false;
}
@
% check and then consume





\chapter{Lexing}
\label{chap:lexing}

%trans:
% now lexer, yylex, called from yyparse.

% why not using lex? they like yacc but not lex apparently
% (because lex != flex? or because of multiline editing tricks
% that may be harder to implement with lex?)


\section{[[yylex()]]}

% lots of ugly lexing tricks:
% - newline and skipnl() after some operators
%   but kinda need it
% - keywords are accepted as word after first word
%   on the line is parsed (via grammar)
% - SUB vs (
%   function def or call vs array subscript
% - special handling of [] after redirection and
%   parsing and AST building inside lexer (hmmm)

<<function [[yylex]]>>=
//@Scheck: called from yyparse()
int yylex(void)
{
    int c;
    <<[[yylex()]] other locals>>

    <<[[yylex()]] hack for SUB>>
    <<[[yylex()]] initialisations>>

    skipwhite();

    switch(c = advance()){
    <<[[yylex()]] switch c cases>>
    }
    // else
    <<[[yylex()]] if c is not a word character>>
    // else
    <<[[yylex()]] if c is a word character>>
}
@
%$
%todo:    // lastdol = false; factorize code?


% word character
<<function [[wordchr]]>>=
int
wordchr(int c)
{
    return !strchr("\n \t#;&|^$=`'{}()<>", c) && c!=EOF;
}
@
%$

% slash allowed here. A word can be a filename (e.g., path of a command
% /bin/ls, arg to a command /mnt, etc)


% identifier character
<<function [[idchr]]>>=
int
idchr(int c)
{
    /*
     * Formerly:
     * return 'a'<=c && c<='z' || 'A'<=c && c<='Z' || '0'<=c && c<='9'
     *	|| c=='_' || c=='*';
     */
    return c > ' ' && !strchr("!\"#$%&'()+,-./:;<=>?@[\\]^`{|}~", c);
}
@
%$
% slash not allowed here



<<[[yylex()]] switch c cases>>=
case EOF:
    lastdol = false;
    strcpy(tok, "EOF");
    return EOF;
@

<<global [[tok]]>>=
char tok[NTOK + UTFmax];
@
% why need that? can not store in yylval? just for debugging?
<<constant [[NTOK]]>>=
#define	NTOK	8192		/* maximum bytes in a word (token) */
@


\section{Spaces and comments ([['#']])}

<<global [[incomm]]>>=
bool incomm;
@
% global used also by getnext (<- nextc), because semantic of \
% is different when inside a comment

<<function [[skipwhite]]>>=
void
skipwhite(void)
{
    int c;
    for(;;){
        c = nextc();
        /* Why did this used to be  if(!inquote && c=='#') ?? */
        if(c=='#'){
            incomm = true;
            for(;;){
                c = nextc();
                if(c=='\n' || c==EOF) {
                    incomm = false;
                    break;
                }
                advance();
            }
        }
        if(c==' ' || c=='\t')
            advance();
        else 
            return;
    }
}
@
%could be a switch? clearer

% remember that nextc() does not advance. so basically like
% access a global next_character.


\section{Newlines}

% will be covered by general code later returning single
% char.

% command terminator

% subtle! called from grammar, weird
% normally newlines marks the end of a command line to be processed.
% but when use |, &&, ||, it is common to enter a newline
% but this newline should be considered a whitespace to skip.
% But sometimes not. So sometimes in the lexer
% there are calls to skipnl to consume those whitespace and newlines

% Do that when knows a newline can not terminate a command because
% we are waiting for something else, for instance with binary operators
% like ||, &&, even |.
% We dont want the next newline to be derived as empty command

<<function [[skipnl]]>>=
void
skipnl(void)
{
    int c;
    for(;;){
        skipwhite();
        c = nextc();
        if(c!='\n')
            return;
        // consume the newline
        advance();
    }
}
@
% lineno incremented correctly here? yes cos 
%   skipnl -> nextc -> getnextc -> pprompt
%alt: use a 'newlines_opt' in the grammar?

% note that in a loop, so will accept multiple empty lines
% until non whitespace character

\section{Operators ([['&']], [['&&']], [['|']], [['||']], [['<']], [['>']], [['$']], \ldots)}


<<[[yylex()]] switch c cases>>=
case '&':
    lastdol = false;
    if(nextis('&')){
        skipnl();
        strcpy(tok, "&&");
        return ANDAND;
    }
    strcpy(tok, "&");
    return '&';
@
% skipnl? so newline after && is not considered a command terminator.
% lexer trick again.




<<[[yylex()]] switch c cases>>=
case '$':
    lastdol = true;
    if(nextis('#')){
        strcpy(tok, "$#");
        return COUNT;
    }
    if(nextis('"')){
        strcpy(tok, "$\"");
        return '"';
    }
    strcpy(tok, "$");
    return '$';
@
%$
% what is dollar and quote after?

<<global [[lastdol]]>>=
bool lastdol;	/* was the last token read '$' or '$#' or '"'? */
@
% dol = dollar




<<[[yylex()]] switch c cases>>=
case '|':
    lastdol = false;
    if(nextis('|')){
        skipnl();
        strcpy(tok, "||");
        return OROR;
    }
    // FALLTHROUGH
case '<':
case '>':
    lastdol = false;
    <<[[yylex()]] in switch when redirection character>>
@
% ugly that does some parsing inside lexer. Should be done in grammar.
% he even included a grammar in the comment. hmm



<<[[yylex()]] other locals>>=
char *w = tok;
@
<<[[yylex()]] other locals>>=
struct Tree *t;
@

<<[[yylex()]] initialisations>>=
yylval.tree = nil;
@

<<[[yylex()]] in switch when redirection character>>=
/*
 * funny redirection tokens:
 *	redir:	arrow | arrow '[' fd ']'
 *	arrow:	'<' | '<<' | '>' | '>>' | '|'
 *	fd:	digit | digit '=' | digit '=' digit
 *	digit:	'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
 * some possibilities are nonsensical and get a message.
 */
*w++=c;
t = newtree();
switch(c){
<<[[yylex()]] in switch when redirection character, switch c cases>>
}
<<[[yylex()]] in switch when redirection character, if bracket after>>
*w='\0';
yylval.tree = t;
if(t->type==PIPE)
    skipnl();
return t->type;
@
% ugly to do that in lexer, but then dont want to have [
% as a separate token

\l could put the skipnl() for PIPE before?



% MV LATER, anyway used where?
%an important set of field are for redirection, when type = REDIR
% in which case the kind of redirection is in rtype
<<[[Tree]] redirection and pipe specific fields>>=
//enum<Redirection_kind>
int	rtype;

// For a pipe, fd0 is the left fd of the pipe, and fd1 the right fd.
// For a redirection, fd0 is what we redirect (stdout for >, stdin for <)
// and fd1 is what we possibly redirect to (when DUP).
fdt fd0;
fdt fd1;	/* details of REDIR PIPE DUP tokens */
@
% why need that in every AST nodes? can not encode info via some child?
% has fd0 fd1 because redirection (and pipes) in rc is very general. 
% Can do lots of stuff.
%ocaml: just put that as additional elements in the constructor for Pipe/Redir


<<constant [[WRITE]]>>=
#define	WRITE	2
@
<<constant [[READ]]>>=
#define	READ	3
@
% TODO enum!! redirection_kind?
<<constant [[APPEND]]>>=
#define	APPEND	1
@





<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '|':
    t->type = PIPE;
    t->fd0 = 1; // left fd of pipe (stdout of left cmd)
    t->fd1 = 0; // right fd of pipe (stdin of right cmd)
    break;
@

<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '>':
    t->type = REDIR;
    if(nextis('>')){
        t->rtype = APPEND;
        *w++=c;
    }
    else 
        t->rtype = WRITE;
    t->fd0 = 1;
    break;
@

<<[[yylex()]] in switch when redirection character, switch c cases>>=
case '<':
    t->type = REDIR;
    <<[[yylex()]] in switch when redirection character, if here document>>
    <<[[yylex()]] in switch when redirection character, if read/write redirect>>
    else 
        t->rtype = READ;
    t->fd0 = 0;
    break;
@






<<[[yylex()]] if c is not a word character>>=
if(!wordchr(c)){
    lastdol = false;
    tok[0] = c;
    tok[1]='\0';
    return c;
}
@
% why need set tok? anyway it is a single character here
%  for yyerror? for fn storage?
%ocaml: be explicit and handle each character in lexer

% so newline is handled by this code above.

\section{Quoted strings ([['...']])}
\label{sec:quoting}


<<global [[inquote]]>>=
bool inquote;
@
% used before already, for getnextc to handle backslash differently
%ocaml: treat backslash differently by using different lexer function

<<[[yylex()]] initialisations>>=
inquote = false;
@


<<global [[lastword]]>>=
// used also by syn.y
bool lastword;	/* was the last token read a word or compound word terminator? */
@
% rename last_tok_was_a_word

<<[[yylex()]] switch c cases>>=
case '\'':
    inquote = true;
    lastword = true;
    lastdol = false;
    for(;;){
        c = advance();
        if(c==EOF)
            break;
        if(c=='\''){
            if(nextc()!='\'')
                break;
            advance();
        }
        w = addutf(w, c);
    }
    if(w != nil)
        *w='\0';

    t = token(tok, WORD);
    t->quoted = true;

    yylval.tree = t;
    return t->type;
@
% classic double '' to represent a quote
%meta, also in C need escape

% addutf in advanced topics, but essentially add character
% and if character start of unicode char, then consume more chars
% first.

<<[[Tree]] word specific fields>>=
bool	quoted;
@
%ocaml: use a pair,  Word of string * bool in AST

% todo: rename tree_of_token?
<<function [[token]]>>=
tree*
token(char *str, int type)
{
    tree *t = newtree();

    t->type = type;
    t->str = strdup(str);
    return t;
}
@


% rc does not use \ to escape?
% so do echo ';'  not echo \;

% in rc no "", no \, less troubles.



\section{Keywords and identifiers ([[if]], [[for]], [[while]], [[switch]], [[fn]], \ldots )}


<<[[yylex()]] if c is a word character>>=
for(;;){
    <<[[yylex()]] when c is a word character, if glob character>>
    w = addutf(w, c);

    c = nextc();
    if(lastdol ? !idchr(c) : !wordchr(c)) 
        break;
    advance();
}

lastword = true;
lastdol = false;
if(w!=nil)
    *w='\0';

t = klook(tok);
if(t->type != WORD)
    lastword = false;

t->quoted = false;

yylval.tree = t;
return t->type;
@

% after a dollar we accept only idchr.

%old:    if(lastdol ? !idchr(c) : !wordchr(c)) break  if inside if, hmmm
\t rewrite this if, too hard to read




<<function [[klook]]>>=
tree*
klook(char *name)
{
    struct Kw *p;
    tree *t = token(name, WORD);

    for(p = kw[hash(name, NKW)];p;p = p->next)
        if(strcmp(p->name, name)==0){
            t->type = p->type;
            break;
        }
    return t;
}
@
% see token() in Code DS chapter
%dead:       t->iskw = true;
%ocaml: just hashtbl or simple pattern matching

<<struct [[Kw]]>>=
struct Kw {
    char *name;
    int type;

    struct Kw *next;
};
@
%old: was with kw before, but better split type definitions and global decls

<<global [[kw]]>>=
struct Kw *kw[NKW];
@

<<constant [[NKW]]>>=
#define	NKW	30
@




% main() -> kinit()
<<function [[kinit]]>>=
void
kinit(void)
{
    kenter(FOR, "for");
    kenter(IN, "in");
    kenter(WHILE, "while");
    kenter(IF, "if");
    kenter(NOT, "not");
    kenter(SWITCH, "switch");
    kenter(FN, "fn");

    kenter(TWIDDLE, "~");
    kenter(BANG, "!");
    kenter(SUBSHELL, "@");
}
@
%new: I reordered
%ocaml: just use pattern matching

<<function [[kenter]]>>=
void
kenter(int type, char *name)
{
    int h = hash(name, NKW);
    struct Kw *p = new(struct Kw);
    p->type = type;
    p->name = name;
    p->next = kw[h];
    kw[h] = p;
}
@




\section{Array subscript ([[<arr>(<n>)]])}
% and automatic carret

% ( vs SUB. Call? vs array subscript.
% need two tokens otherwise ambiguity in grammar?
% 

<<[[yylex()]] other locals>>=
int d = nextc();
@

<<[[yylex()]] hack for SUB>>=
/*
 * Embarassing sneakiness:  if the last token read was a quoted or unquoted
 * WORD then we alter the meaning of what follows.  If the next character
 * is `(', we return SUB (a subscript paren) and consume the `('. Otherwise,
 * if the next character is the first character of a simple or compound word,
 * we insert a `^' before it.
 */
if(lastword){
    lastword = false;
    if(d=='('){
        advance();
        strcpy(tok, "( [SUB]");
        return SUB;
    }
    if(wordchr(d) || d=='\'' || d=='`' || d=='$' || d=='"'){
        strcpy(tok, "^");
        return '^';
    }
}
@
%$

% what is this ^ ? it's to concatenate word
% when we do foo  -x$flag, we do not want to pass 2 args to foo program
% such as ["-x"; "$flag"].
% we want one single arg that is the result of a concatenation.
% enter ^.

% but right now because we skip whitespace and generate 3 tokens
% (one for '-x', one for '$' which accept comples values, not just
% a direct varname, and one for 'flag')
% there is no way to disambigute between -x $ flag and -x$flag
% hence the implicit caret thing.






\chapter{Parsing}
\label{chap:parsing}

\section{Overview}

% I assume you understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.nw :) )
%(compared to ocamlyacc can have actions in the middle, and those actions
% count as indexable elements for the $xxx numbering ($1, $2, etc))

<<rc/syn.y>>=
%{
#include "rc.h"
#include "fns.h"
%}

%union {
 struct Tree *tree;
};

<<token declarations>>
<<priority and associativity declarations>>
<<type [[declarations]]>>

%%
<<grammar>>
@

% for syncweb -to_tex
<<function [[yyparse]]>>=
... generated code from syn.y by yacc ...
@

 
<<priority and associativity declarations>>=
/* operator priorities -- lowest first */
%left IF WHILE FOR SWITCH ')' NOT
%left ANDAND OROR
%left BANG SUBSHELL
%left PIPE
%left '^'
%right '$' COUNT '"'
%left SUB
@

% why right for $? anyway when do $$A semantic? no ambiguity
% dont want (($ $) A) want ($ ($ A))


<<type [[declarations]]>>=
%type<tree> line cmd simple word comword
@

% comword for command word?

%less: rename? cmd -> statement, simple -> expression, word -> argument?

<<grammar>>=
rc: 
    /*empty*/       { return ERROR_1;}
|   line '\n'       { return !compile($1);}

<<line rule>>
<<cmd rule>>
<<simple rule>>

<<word rule>>
<<comword rule>>

<<other rules>>
@
%$

% empty case is when EOF?

% if compile() return 0 it's an error, so here 1 = an error
% TODO: be more consistent, return compile() would be cleaner so no need
%  explanation
% Xrdcmds -> yyparse() ?

% newline has a semantic here!

% interesting DSL. must be easy to issue a command.
% don't want to do 'system("ls");' like in other languages.
% and want newline to have a special semantic role, a kind of implicit ';'
% but also want to have multiline statements ... so newline must be allowed
%  and not run the command sometimes.
% -xxx, /a/b, are treated as regular words! only ;&${[^ are specials






\ifallcode
<<type [[declarations]]>>=
%type<tree> first keyword words
%type<tree> paren brace body cmdsa cmdsan assign epilog redir
%type<tree> FOR IN WHILE IF NOT SWITCH FN
%type<tree> TWIDDLE BANG SUBSHELL  REDIR DUP PIPE    WORD
@
\fi

\ifallcode
<<constant [[YYMAXDEPTH]]>>=
//@Scheck: used in y.tab.c
#define	YYMAXDEPTH	500
@

%pad: put here just to please syncweb -to_tex
<<rc/x.tab.h>>=
@

\fi


\section{Simple commands ([[<cmd> <arg1>...<argn>]]) }

% a line can have a single command (stmt)
<<line rule>>=
line:   
    cmd
<<line rule other cases>>
@
% can have ; and & here (why not in cmd? because newline issue?)

% a (single) command can be a simple "expression"
<<cmd rule>>=
cmd: 
    /*empty*/           {$$=nil;}
|   simple              {$$=simplemung($1);}
<<cmd rule other cases>>
@
%$
% can have complex stmt here

% simplemung() shown below later.
% "mung" means destructive update.

% an expression can be a "progcall" which is a simple serie of words
% (separated by spaces, curry style :) )
% with first word has some restrictions (the "function" name)
<<simple rule>>=
simple:
    first
|   simple word         {$$=tree2(ARGLIST, $1, $2);}
<<simple rule other cases>>
@
% can have redirection here in the other cases

% actually first can correspond to a progran, or a function, or a builtin.





<<other rules>>=
first:  
    comword 
|   first '^' word      {$$=tree2('^', $1, $3);}
@
% diff with word? first cannot be a keyword !!!


% basic identifier, a kind of primary expression
% -xxx, /a/b, are treated as regular words
<<comword rule>>=
comword: 
    WORD
<<comword rule other cases>>
@
% can have variables $XX and other complex arguments in other cases
% can have some kind of redirection also in other cases (??)


% a word can be any identifier or symbol or integer (WORD)
<<word rule>>=
word:   
    comword
|   word '^' word       {$$=tree2('^', $1, $3);}
|   keyword             {lastword=true; $1->type=WORD;}
@
%$

% keyword is ok after the first word and transformed as a WORD.
%ocaml: ugly? but true that you dont know which argument you gonna
% pass to some commands

<<other rules>>=
keyword: FOR|IN|WHILE|IF|NOT|TWIDDLE|BANG|SUBSHELL|SWITCH|FN
@


<<other rules>>=
words: 
    /*empty*/       {$$=(struct Tree*)nil;}
|   words word      {$$=tree2(WORDS, $1, $2);}
@
%$
% used for ~ word words




<<function [[simplemung]]>>=
/*
 * Add a SIMPLE node at the root of t and percolate all the redirections
 * up to the root.
 */
//@Scheck: used by syn.y
tree* simplemung(tree *t)
{
    tree *u;
    struct Io *s;

    t = tree1(SIMPLE, t);

    s = openstr();
    pfmt(s, "%t", t);
    t->str = strdup((char *)s->strp);
    closeio(s);

    <<[[simplemung()]] percolate redirections up to the root>>
    return t;
}
@
% saw ARGLIST above
%ocaml: build directly AST

\t why store string in t->str?? who will uses that anyway?

<<[[simplemung()]] percolate redirections up to the root>>=
for(u = t->child[0]; u->type==ARGLIST; u = u->child[0]){
    if(u->child[1]->type==REDIR || u->child[1]->type==DUP){
        u->child[1]->child[1] = t;
        t = u->child[1];
        u->child[1] = nil;
    }
}
@
%ocaml: maybe should have redirection allowed only at the end?
% so then easy to put it also at the root of the AST.


% when do  ls /tmp/x > foo < bar /tmp/y
% then want to transform in   (> foo (< bar (ls /tmp/x /tmp/y))) in AST


\section{Operators}

% actually operators are at different levels, line rule, cmd rule,
% simple rule and so have different priotities.
% redirection is lower, then pipe and logic operators, then sequence

\subsection{Sequences ([[';']], [['&']])}
\t and async execution!

% known as Joining in csh terminology.

<<line rule other cases>>=
|   cmdsa line      {$$=tree2(';', $1, $2);}
@

<<other rules>>=
cmdsa:  
    cmd ';'
|   cmd '&'         {$$=tree1('&', $1);}
@
%$
% separator, not terminator. Newline is the terminator

% cmdsa = command sequence or and

% x & y is really (x&); y

% newline is also a form of sequence when in the body { } of something

\subsection{Logical operators  ([['&&']], [['||']], [['!']])}
% Other operators?
% && ||  |  &  !?
% >> << > <

<<cmd rule other cases>>=
|   cmd ANDAND cmd      {$$=tree2(ANDAND, $1, $3);}
|   cmd OROR cmd        {$$=tree2(OROR, $1, $3);}
@
% why not merge with ; and & ?

% when argument of if/while in general
<<cmd rule other cases>>=
|   BANG cmd            {$$=mung1($1, $2);}
@
% could also just do tree2(BANG, $2) I think



% redir is in simple/expr, so has more prirority


<<function [[mung1]]>>=
//@Scheck: used by syn.y
tree* mung1(tree *t, tree *c0)
{
    t->child[0] = c0;
    return t;
}
@
%ocaml: build directly


<<function [[mung3]]>>=
//@Scheck: used by syn.y
tree* mung3(tree *t, tree *c0, tree *c1, tree *c2)
{
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@
%ocaml: build directly

\subsection{String matching  (\texttt{'\textasciitilde'})}

% Fundamental type is list of string. No int, no float, just strings.
% So fundamental operator is string matching ~.
% Can be used for arithmetic too,  if(~ $#xxx 0)

%csh: had expression grammar, so could do $i < 365
%sh: ugly external 'test' program and '[' but need for -gt, -lt

<<cmd rule other cases>>=
|   TWIDDLE word words  {$$=mung2($1, $2, $3);}
@
%$

<<function [[mung2]]>>=
//@Scheck: used by syn.y
tree* mung2(tree *t, tree *c0, tree *c1)
{
    t->child[0] = c0;
    t->child[1] = c1;
    return t;
}
@
%ocaml: build directly

\subsection{Pipe  ([['|']])}

<<cmd rule other cases>>=
|   cmd PIPE cmd        {$$=mung2($2, $1, $3);}
@
%$

% what if second cmd derives the EmptyCommand?

\subsection{Redirections  ([['>']], [['<']])}

% at level of simple, below cmd, so higher prio than ||, &&, ;, etc
<<simple rule other cases>>=
|   simple redir        {$$=tree2(ARGLIST, $1, $2);}
@
% means can have multiple redir, ls < foo > bar, but after the funcall!
% means also that can have extra arguments still after the redir (ugly)

% ARGLIST but will be percolated back to the root in simplemung()

<<other rules>>=
redir:  
    REDIR word      {$$=mung1($1, $1->rtype==HERE ? heredoc($2) : $2);}
<<redir rule other cases>>
@



% other redirections!
% XXX?
<<cmd rule other cases>>=
|   brace epilog        {$$=epimung($1, $2);}
@
%ocaml: why not have just  simple: brace, like 
% in expression where primary_expr can derive paren expr.
% because does not work, because would allow
% brace redir word.
% but what is this word after brace? an argument to what?

\t Note that there is no paren in cmd, so if you want to parenthesize
\t  experssions like  ~ foo foobar, then you need to use braces, not parens!


<<other rules>>=
epilog: 
    /*empty*/           {$$=nil;}
|   redir epilog        {$$=mung2($1, $1->child[0], $2);}
@
%$

<<function [[epimung]]>>=
//@Scheck: used by syn.y
tree* epimung(tree *comp, tree *epi)
{
    tree *p;
    if(epi==0)
        return comp;
    for(p = epi;p->child[1];p = p->child[1]);
    p->child[1] = comp;
    return epi;
}
@



% infix style
<<cmd rule other cases>>=
|   redir cmd  %prec BANG
        {$$=mung2($1, $1->child[0], $2);}
@
%$
% really need to support that?
%ocaml: do not support that

\section{Control flow statements ([[if]], [[if not]], [[while]], [[switch]], [[for]])} 

<<cmd rule other cases>>=
|   IF paren {skipnl();} cmd  {$$=mung2($1, $2, $4);}
|   IF NOT   {skipnl();} cmd  {$$=mung1($2, $4);}

|   WHILE paren {skipnl();} cmd    {$$=mung2($1, $2, $4);}
|   SWITCH word {skipnl();} brace  {$$=tree2(SWITCH, $2, $4);}

 /*
  * if ``words'' is nil, we need a tree element to distinguish between 
  * for(i in ) and for(i), the former being a loop over the empty set
  * and the latter being the implicit argument loop.  so if $5 is nil
  * (the empty set), we represent it as "()".  don't parenthesize non-nil
  * functions, to avoid growing parentheses every time we reread the
  * definition.
  */
|   FOR '(' word IN words ')' {skipnl();} cmd
    {$$=mung3($1, $3,    $5 ? $5 : tree1(PAREN, $5), $8);}

|   FOR '(' word ')' {skipnl();} cmd
    {$$=mung3($1, $3, (struct Tree *)0, $6);}
@
% why IF NOT? Why not simply ELSE? just to indicate that this thing is
% fishy. See rc(1) note about it.
% Also normally else requires lookahead but "the shell cannot afford
%  to do lookahead since it is an interactive language"
% It has to process  if(...) cmd NEWLINE.
% It can not wait to check if there is an else (anyway it can
% already proceed). But then else is really another separate command,
% hence the special indication.

% for(x) iterate over $*
% can do before *=`{ ... } for instance

<<other rules>>=
paren:  '(' body ')'        {$$=tree1(PCMD, $2);}
@
%$

<<token declarations>>=
%token PCMD
@
% but really like brace for semantic.
% but different from parens inside the For where it is a list of things then.
% Also use different token so when pretty print the tree get the
%  right syntax.


<<other rules>>=
brace:  '{' body '}'        {$$=tree1(BRACE, $2);}
@
%$



% so multiline, or ;
% so first language using vertical layout :) not haskell :)
<<other rules>>=
body:   
    cmd
|   cmdsan body     {$$=tree2(';', $1, $2);}

cmdsan: 
    cmdsa
|   cmd '\n'
@
%$
% cmd sequence or and or newline





\section{Functions ([[fn]])}

<<cmd rule other cases>>=
|   FN words brace  {$$=tree2(FN, $2, $3);}
|   FN words        {$$=tree1(FN, $2);}
@
%$
% words? fn with multiple words? can define alias on the same line?
%ocaml: could be at line level? also why allow words here?

% second line is for delfn. if type
% fn foo   without anything, then means delete the function.

\section{Variables ([[<x> = ...]])}

% definitions

<<cmd rule other cases>>=
|   assign cmd %prec BANG   
      {$$=mung3($1, $1->child[0], $1->child[1], $2);}
@
% just add cmd as third child of =
% remember that cmd can be empty. In fact, if empty the semantic
% of the assignment changes. The binding is not just for the current command.

% why this syntax? why before?
% Bourne says that cc, make have x=y in its argument, so have to
% do assign before cmd.

% explain %prec?
% if remove it then get ambiguity with cmd && cmd.
%60: shift/reduce conflict (shift 51, reduce 22) on TAndAnd
%60: shift/reduce conflict (shift 52, reduce 22) on TOrOr
%60: shift/reduce conflict (shift 53, reduce 22) on TPipe
%state 60
%	cmd : cmd . TAndAnd cmd  (9)
%	cmd : cmd . TOrOr cmd  (10)
%	cmd : cmd . TPipe cmd  (13)
%	cmd : assign cmd .  (22)

% how parse:   X=1 ls && echo done ??
%  as   (X=1 ls) && echo done
%  or   X=1 (ls && echo done)
% ?
% with %prec BANG, it says to use priority of BANG
%  (between AndAnd and the Pipe)
% so probably get different results if operator is pipe or &&.
% ugly.


% A=1 ls


% what if do A='*'
% and then  echo $A
% will you get the glob?
% bash does?

% fish mentioned that bash does word splitting and globbing
% after variable expansion. With RC vars are always list of strings
% so simpler?
% http://mywiki.wooledge.org/BashPitfalls

<<other rules>>=
assign: first '=' word      {$$=tree2('=', $1, $3);}
@
%$
% not words here? no cos cmd can contain list of words?
% but then variables contain a single word? not a list?
% for a list of words use () so X=(a b c d)
% but then how derive () from word? see below.


% no export in rc?

% uses

<<comword rule other cases>>=
|   '$' word        {$$=tree1('$', $2);}
|   COUNT word      {$$=tree1(COUNT, $2);}
|   '$' word SUB words ')'  {$$=tree2(SUB, $2, $4);}
@
%$

% SUB = '(' when after a word, subscript
% but what that mean? subscript, array access

\section{Lists ([[(...)]])}

<<comword rule other cases>>=
|   '(' words ')'   {$$=tree1(PAREN, $2);}
@
%$

% a bit hard to call it word then ... when it is really a list of words.





%\chapter{Checking}
% no type checking
% no checking at all (just if not but because ugly)

% Bourne says he was doing checks such as detecting cat >x | wc  errors.
% I could do?


\chapter{Bytecode Generation and Interpretation}
\label{chap:compile-interpret}

% or Code generation? or Bytecode generation?
\n i merged Bytecode Generation and Intepretation in one chapter
\n  because it helps to see the code generated from a tree.
\n We could also group with the related parsing, but maybe it would
\n  be too much, and parsing can be understood in isolation.

\section{Overview}

% recall main flow: main() -> ... -> Xrdcmds() -> yyparse() -> compile()

\subsection{[[emitxxx()]]}

% see codebuf in Core DS chapter (could be moved here too)

<<global [[codep]]>>=
// idx in codebuf
int codep;
@

% for the emitxxx() to realloc when necessary
<<global [[ncode]]>>=
int ncode;
@

% emit int
<<function [[emiti]]>>=
#define	emiti(x) ((codep!=ncode || morecode()), codebuf[codep].i = (x), codep++)
@
% return codep before! so can store for creating jmp

% emit function
<<function [[emitf]]>>=
#define	emitf(x) ((codep!=ncode || morecode()), codebuf[codep].f = (x), codep++)
@
% emit string
<<function [[emits]]>>=
#define	emits(x) ((codep!=ncode || morecode()), codebuf[codep].s = (x), codep++)
@
%ocaml: need just one emit(); can then pass variant

% growing array
<<function [[morecode]]>>=
//@Scheck: used by the macros above (why marked as dead then??? TODO)
int morecode(void)
{
    ncode+=100;
    codebuf = (code *)realloc((char *)codebuf, ncode*sizeof codebuf[0]);
    if(codebuf==nil)
        panic("Can't realloc %d bytes in morecode!", ncode*sizeof(code));
    return OK_0;
}
@
% need return an int? need OK_0? just return;

\subsection{[[compile()]]}


% modify codebuf!
<<function [[compile]]>>=
//@Scheck: called from syn.y
error0 compile(tree *t)
{
    ncode = 100;
    codep = 0;
    codebuf = (code *)emalloc(ncode*sizeof(code));

    emiti(0);			/* reference count */
    outcode(t, flag['e'] ? true : false);

    <<[[compile()]] check nerror>>
    <<[[compile()]] after outcode and error management, read heredoc>>

    emitf(Xreturn);
    emitf(nil);

    return OK_1;
}
@

% note that compile is called for each line entered interactively,
% and also inline of a script.
% So for each line in a script there are set of bytecodes for this line
% followed by a Xreturn to go back to the loop to read the next line!

<<[[compile()]] check nerror>>=
if(nerror){
    efree((char *)codebuf);
    return ERROR_0;
}
@
%ocaml: use exception



\subsection{[[outcode()]]}

%ugly
<<constant c0 (rc/code.c)>>=
#define	c0	t->child[0]
@
<<constant c1 (rc/code.c)>>=
#define	c1	t->child[1]
@
<<constant c2 (rc/code.c)>>=
#define	c2	t->child[2]
@
%ocaml: just use precise AST and pattern matching to deconstruct

% modify codebuf via all those emitxxx()
% todo: could return errorcode instead of using nerror global
<<function [[outcode]]>>=
void
outcode(tree *t, bool eflag)
{
    <<[[outcode()]] locals>>

    if(t==nil)
        return;

    <<[[outcode()]] set iflast before switch>>
    switch(t->type){
    <<[[outcode()]] cases>>
    default:
        pfmt(err, "bad type %d in outcode\n", t->type);
        break;
    }
    <<[[outcode()]] set iflast after switch>>
}
@
%$

% test t == nil because call outcode on child that can be nil sometimes.
% Moreover when process a list of commands, at some points the sequence
% is empty.


\subsection{[[argv]] management}

%trans: before compile for main AST element, 
% a few common things in compilation scheme.
% - dealing with argv
% - dealing with return status
% - dealing with subprocesses

% used for each word in the compiled command
<<function [[Xword]]>>=
void
Xword(void)
{
    pushword(runq->code[runq->pc++].s);
}
@

% pushword() shown before.


% used to start a new list of words for a new command
% used when compiling SIMPLE commands
% used also for TWIDDLE, FOR, etc.
<<function [[Xmark]]>>=
void
Xmark(void)
{
    pushlist();
}
@
% why need multiple argv list? Because some bytecodes requires
% multiple things in the stack, but clearly separated.
% Many things can expand to list of strings, so when you need to operate
% over 2 list of strings, you need a special mark.

% pushlist() shown before


% used by Xsimple after having executed a command. Used by Xassign too.
% Each time we use Xmark to set a new context, we use poplist later.
<<function [[poplist]]>>=
void
poplist(void)
{
    list *p = runq->argv;
    if(p==nil)
        panic("poplist but no argv", 0);
    freelist(p->words);
    runq->argv = p->next;
    efree((char *)p);
}
@
%ocaml: need that too

% panic? see appendix.


% execexec -> <>
<<function [[popword]]>>=
void
popword(void)
{
    word *p;
    <<[[popword()]] sanity check argv>>
    p = runq->argv->words;
    <<[[popword()]] sanity check argv words>>
    runq->argv->words = p->next;
    efree(p->word);
    efree((char *)p);
}
@

<<[[popword()]] sanity check argv>>=
if(runq->argv==nil)
    panic("popword but no argv!", 0);
@
%ocaml: always have an argv, no need for this check

<<[[popword()]] sanity check argv words>>=
if(p==nil)
    panic("popword but no word!", 0);
@


\subsection{Process status management}

% was $$ in bash

<<function [[setstatus]]>>=
void
setstatus(char *s)
{
    setvar("status", newword(s, (word *)nil));
}
@

<<function [[getstatus]]>>=
char*
getstatus(void)
{
    var *status = vlook("status");
    return status->val ? status->val->word : "";
}
@

<<function [[truestatus]]>>=
bool
truestatus(void)
{
    char *s;
    for(s = getstatus();*s;s++)
        if(*s!='|' && *s!='0')
            return false;
    return true;
}
@
% what is this pipe in status? because when do ls | wc 
%  then rc combine the return status of both in one string
%  with | in the middle. so if 0|0 then everthing is file,
%  but if error in one of then then should return an error.
% so if return string is empty, or contains only 0 or |, then fine

\subsection{Subprocesses management}
% children

\t why need waitpids? anyway do Waitfor(pid, ...) in Xsimple
\t so why need also to record the current set of child process?
\t it's annoying because in each child then you need clearwaitpids

<<global [[waitpids]]>>=
// growing_array<pid> (but really a list)
int *waitpids;
@
<<global [[nwaitpids]]>>=
int nwaitpids;
@

<<function [[addwaitpid]]>>=
void
addwaitpid(int pid)
{
    <<[[addwaitpid()]] grow [[waitpids]] if needed>>
    waitpids[nwaitpids++] = pid;
}
@
%ocaml: use Hashtbl?

<<[[addwaitpid()]] grow [[waitpids]] if needed>>=
waitpids = realloc(waitpids, (nwaitpids+1)*sizeof waitpids[0]);
if(waitpids == nil)
    panic("Can't realloc %d waitpids", nwaitpids+1);
@

<<function [[delwaitpid]]>>=
void
delwaitpid(int pid)
{
    int r, w;
    
    for(r=w=0; r<nwaitpids; r++)
        if(waitpids[r] != pid)
            waitpids[w++] = waitpids[r];
    nwaitpids = w;
}
@

<<function [[clearwaitpids]]>>=
void
clearwaitpids(void)
{
    nwaitpids = 0;
}
@

<<function [[havewaitpid]]>>=
bool
havewaitpid(int pid)
{
    int i;

    for(i=0; i<nwaitpids; i++)
        if(waitpids[i] == pid)
            return true;
    return false;
}
@

\section{Simple commands}
% or builtins or functions


\subsection{Bytecode generation}

% SIMPLE node built in simplemung()

<<[[outcode()]] cases>>=
case SIMPLE:
    emitf(Xmark);
    outcode(c0, eflag); // the arguments and argv0
    emitf(Xsimple);
    <<[[outcode()]] emit Xeflag after Xsimple>>
    break;
@

% Xmark so new argv for this command
% then this will do some Xword and put in runq->argv a bunch
%  of words
% then Xsimple executuon

% ARGLIST is for the parameters of the simple command, the arguments,
% which are mostly word and so push in the stack (runq->argv)
% and also final = argv0
<<[[outcode()]] cases>>=
case ARGLIST:
    outcode(c1, eflag);
    outcode(c0, eflag);
    break;
@
% put in reverse order, cos this will lead to some
% Xword which will populate argv stack, so must be in reverse
% order so last word emited in codebuf is first in the runq->words stack.

<<[[outcode()]] cases>>=
case WORDS:
    outcode(c1, eflag);
    outcode(c0, eflag);
    break;
@

<<[[outcode()]] cases>>=
case WORD:
    emitf(Xword);
    emits(strdup(t->str));
    break;
@
% the string is inline in codebuf


<<[[codefree()]] in loop over code [[cp]], switch bytecode cases>>=
else if(p->f==Xword || p->f==Xdelhere) 
         efree((++p)->s);
@


\subsection{[[Xsimple()]]}

% * Xsimple(args)			run command and wait
<<function [[Xsimple]]>>=
void
Xsimple(void)
{
    word *a;
    thread *p = runq;
    int pid;
    <<[[Xsimple()]] other locals>>

    <<[[Xsimple()]] initializations, [[globlist()]]>>

    a = runq->argv->words;
    <<[[Xsimple()]] sanity check a>>

    <<[[Xsimple()]] if -x>>

    <<[[Xsimple()]] if argv0 is a function>>
    else{
        <<[[Xsimple()]] if argv0 is a builtin>>
        <<[[Xsimple()]] if exitnext()>>
        else{
            flush(err);
            Updenv();	/* necessary so changes don't go out again */
            if((pid = execforkexec()) < 0){
                Xerror("try again");
                return;
            }

            /* interrupts don't get us out */
            poplist();
            while(Waitfor(pid, 1) < 0)
                ;
        }
    }
}
@
% why the flush?

% <0 means wait was interrupted, but we still do it.
% What it means? Can not C-c ? if really big command,
% and do C-c, then child should die, then wait interrupted,
% and then when we do wait again it should return??

<<[[Xsimple()]] sanity check a>>=
if(a==nil){
    Xerror1("empty argument list");
    return;
}
@
% should have at least name of command in arg0!
% maybe should change error message?
% Can happen if do A=()\n and then $A\n, then after resolution
% of dollar argv becomes empty


% globlist is for globbing. See advanced topics.

% actually not an bytecode. Never generated by compile()
<<function [[Xerror]]>>=
void
Xerror(char *s)
{
    if(strcmp(argv0, "rc")==0 || strcmp(argv0, "/bin/rc")==0)
        pfmt(err, "rc: %s: %r\n", s);
    else
        pfmt(err, "rc (%s): %s: %r\n", argv0, s);
    flush(err);
    setstatus("error");

    while(!runq->iflag) 
        Xreturn();
}
@
% a bit like exception. Go up thread/call stack until
% the top where have interactive thread.
% As we go back we call Xreturn which will do the appropriate cleanups.


% diff with Xerror? does not print the %r
<<function [[Xerror1]]>>=
void
Xerror1(char *s)
{
    if(strcmp(argv0, "rc")==0 || strcmp(argv0, "/bin/rc")==0)
        pfmt(err, "rc: %s\n", s);
    else
        pfmt(err, "rc (%s): %s\n", argv0, s);
    flush(err);
    setstatus("error");

    while(!runq->iflag) 
        Xreturn();
}
@

\subsection{Fork}


% fundamental of a shell! fork exec wait
<<function [[execforkexec]]>>=
int
execforkexec(void)
{
    int pid;
    int n;
    char buf[ERRMAX];

    // fork()!!
    switch(pid = fork()){
    case -1:
        return -1;
    case 0: // child
        clearwaitpids();
        pushword("exec");
        execexec();

        // should not be reached! unless the command did not exist
        strcpy(buf, "can't exec: ");
        n = strlen(buf);
        errstr(buf+n, ERRMAX-n);
        Exit(buf);
    }
    // parent
    addwaitpid(pid);
    return pid;
}
@
% why execforkexec? why not just forkexec? 
% to be consistent with execexec below (which you can not just
% call exec since it conflicts with syscall)
%ocaml: let the module system handle conflict.

%clearwaitpids because child process is not responsible for
% waiting for some child

% note that if pb with exec, will exit, but this is done from
% the child, so the parent will still be ok

% why the pushword("exec")? because exec is also a builtin
% with code execexec, so here we want to reuse the same execexec function
% so we need to recreate the same conditions, the same argv.

\subsection{Exec}

% execforkexec | builtin "exec" -> <>
<<function [[execexec]]>>=
void
execexec(void)
{
    popword();	/* "exec" */
    <<[[execexec()]] sanity check arguments>>
    <<[[execexec()]] perform the redirections>>

    Execute(runq->argv->words, searchpath(runq->argv->words->word));
    // should not be reached! unless command did not exist
    poplist();
}
@

% doredir!!! now that is in child process, ready to exec,
%  that is when we can do the change to the file descriptors.

<<[[execexec()]] sanity check arguments>>=
if(runq->argv->words==nil){
    Xerror1("empty argument list");
    return;
}
@

% why push exec if after you pop it anyway?
% because execexec is also a builtin and in that case
% exec is in argv0.

% pass argv0 to searchpath

\subsection{[[$path]] management}
%$
\label{sec:path-management}

<<function [[searchpath]]>>=
word*
searchpath(char *w)
{
    word *path;

    if(strncmp(w, "/", 1)==0
    || strncmp(w, "#", 1)==0
    || strncmp(w, "./", 2)==0
    || strncmp(w, "../", 3)==0
    || (path = vlook("path")->val)==nil)
        path=&nullpath;
    return path;
}
@
% # is for device path in plan9

<<global [[nullpath]]>>=
struct Word nullpath = { "", nil};
@
% note that nullpath does not mean it will look for current directory

% how to allow to look in current path? cannot, have to use ./foo
% but then it does "/./foo" no?
%real-world: bash can forbid that by putting or not "." in PATH


<<function [[Execute]]>>=
void
Execute(word *args, word *path)
{
    char **argv = mkargv(args);
    char file[1024];
    char errstr[1024];
    int nc;

    Updenv();
    errstr[0] = '\0';

    for(;path;path = path->next){
        nc = strlen(path->word);
        if(nc < sizeof file - 1){	/* 1 for / */
            strcpy(file, path->word);
            if(file[0]){
                strcat(file, "/");
                nc++;
            }
            if(nc + strlen(argv[1]) < sizeof file){
                strcat(file, argv[1]);

                // The actual exec() system call!
                exec(file, argv+1);

                // reached if the file does not exist

                rerrstr(errstr, sizeof errstr);
                /*
                 * if file exists and is executable, exec should
                 * have worked, unless it's a directory or an
                 * executable for another architecture.  in
                 * particular, if it failed due to lack of
                 * swap/vm (e.g., arg. list too long) or other
                 * allocation failure, stop searching and print
                 * the reason for failure.
                 */
                if (strstr(errstr, " allocat") != nil ||
                    strstr(errstr, " full") != nil)
                    break;
            }
            else werrstr("command name too long");
        }
    }
    // should not be reached if found an actual binary to exec
    pfmt(err, "%s: %s\n", argv[1], errstr);
    efree((char *)argv);
}
@
%ocaml: no need fixed buffer and all those checks that cmd not too long

<<function [[mkargv]]>>=
char **
mkargv(word *a)
{
    char **argv = (char **)emalloc((count(a)+2) * sizeof(char *));
    char **argp = argv+1;	/* leave one at front for runcoms */

    for(;a;a = a->next) 
        *argp++=a->word;
    *argp = nil;
    return argv;
}
@
% what is the one at the front??? for runcoms???
%ocaml: Array.of_list

\subsection{Wait}

% In the mean time, in the parent process

% Xsimple -> <>
<<function [[Waitfor]]>>=
int
Waitfor(int pid, int)
{
    thread *p;
    Waitmsg *w;
    char errbuf[ERRMAX];

    if(pid >= 0 && !havewaitpid(pid))
        return 0;

    // wait()!! until we found it
    while((w = wait()) != nil){
        delwaitpid(w->pid);

        if(w->pid==pid){
            setstatus(w->msg);
            free(w);
            return 0;
        }
        <<[[Waitfor()]] in while loop, if wait returns another pid>>
    }

    errstr(errbuf, sizeof errbuf);
    if(strcmp(errbuf, "interrupted")==0) 
        return -1;
    return 0;
}
@
\t remove second argument, it is not used anyway



\subsection{Fork optimization}

% it is an optimisation then? mv to advanced topics?
%  when have exit in codebuf?
<<[[Xsimple()]] if exitnext()>>=
if(exitnext()){
    /* fork and wait is redundant */
    pushword("exec");
    execexec();
    Xexit();
}
@

<<function [[exitnext]]>>=
/*
 * Search through the following code to see if we're just going to exit.
 */
int
exitnext(void){
    union Code *c = &runq->code[runq->pc];
    while(c->f==Xpopredir) 
        c++;
    return c->f==Xexit;
}
@
% popredir does not matter? because all fd will be closed once
% exit from execed process?

\section{Operators}

\subsection{Basic sequence}

<<[[outcode()]] cases>>=
case ';':
    outcode(c0, eflag);
    outcode(c1, eflag);
    break;
@
% simple :)




\subsection{Logical operators}

<<[[outcode()]] locals>>=
int p;
@

<<[[outcode()]] cases>>=
case ANDAND:
    outcode(c0, false);
    emitf(Xtrue);
    p = emiti(0);
    outcode(c1, eflag);
    stuffdot(p);
    break;
@
% pass false to outcode, cos dont care about checking error status
%  of first cmd in  cmd1 && cmd2

% jump technique
<<function [[stuffdot]]>>=
void
stuffdot(int a)
{
    if(a<0 || codep<=a)
        panic("Bad address %d in stuffdot", a);
    codebuf[a].i = codep;
}
@
% stuffdot meaning?
% so this allow to generate a jump forward.



<<[[outcode()]] cases>>=
case OROR:
    outcode(c0, false);
    emitf(Xfalse);
    p = emiti(0);
    outcode(c1, eflag);
    stuffdot(p);
    break;
@

<<function [[Xtrue]]>>=
void
Xtrue(void)
{
    if(truestatus()) runq->pc++;
    else runq->pc = runq->code[runq->pc].i;
}
@

<<function [[Xfalse]]>>=
void
Xfalse(void)
{
    if(truestatus()) runq->pc = runq->code[runq->pc].i;
    else runq->pc++;
}
@




<<[[outcode()]] cases>>=
case BANG:
    outcode(c0, eflag);
    emitf(Xbang);
    break;
@

<<function [[Xbang]]>>=
void
Xbang(void)
{
    setstatus(truestatus()? "false" : "");
}
@


\subsection{String matching}


<<[[outcode()]] cases>>=
case TWIDDLE:
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xmatch);
    if(eflag)
        emitf(Xeflag);
    break;
@
% why Xeflag here? no command, just word, so why exit early?

<<function [[Xmatch]]>>=
void
Xmatch(void)
{
    word *p;
    char *subject;

    subject = list2str(runq->argv->words);
    setstatus("no match");
    for(p = runq->argv->next->words;p;p = p->next)
        if(match(subject, p->word, '\0')){
            setstatus("");
            break;
        }
    efree(subject);
    poplist();
    poplist();
}
@
% but list of words should contain only one element no?
% no cos pattern can be the content of a variable

<<function [[list2str]]>>=
char*
list2str(word *words)
{
    char *value, *s, *t;
    int len = 0;
    word *ap;

    for(ap = words;ap;ap = ap->next)
        len += 1+strlen(ap->word);
    value = emalloc(len+1);

    s = value;
    for(ap = words;ap;ap = ap->next){
        for(t = ap->word;*t;) 
            *s++=*t++;
        *s++=' ';
    }
    if(s==value)
        *s='\0';
    else s[-1]='\0';
    return value;
}
@
%ocaml: String.concat " "


% see also /bin/test! often used as argument to if()

\subsection{Redirection}

%\subsection{Trace of a redirection}
% ls > foo
% can also be  {ls; echo bar} > foo

% actually memorize info that will need to redirect. open file
% but do not do yet the redir. Need to wait to be in forked of
% simple command, just before the exec, and then apply the redirection
% information.
% (but then need to popredir)


% note that when we see a redirection command, we can not
% redirect yet our own stdout and stdin. We need to do that
% in the child process we fork that runs a simple command.
% So when we see a redir, we need to store in the thread
% future redirections we will need to do in the child process.


% Then at some point we execute those redirections:
<<[[execexec()]] perform the redirections>>=
doredir(runq->redir);
@

% inherit redir from parent thread? why need that? for subshell stuff?
<<[[start()]] set redir>>=
p->redir = p->startredir = runq ? runq->redir : nil;
@
% and then why need remember starting point? because in case of
% error we need to popredir everything that was opened from this thread.
% And we often create new threads.
%ocaml: use list of list instead of having redir and startredir


\subsubsection{[[Redir]]}

<<struct [[Redir]]>>=
struct Redir {
    // enum<redirection_kind_bis>
    char type;	/* what to do */

    /* what to do it to */
    short from;
    short to;

    // Extra
    <<[[Redir]] extra fields>>
};
@


<<[[Thread]] other fields>>=
// list<ref_own<Redir>> (next = Redir.next)
struct Redir *redir;	/* redirection stack */
@

<<[[Redir]] extra fields>>=
struct Redir *next;		/* what else to do (reverse order) */
@

<<function [[pushredir]]>>=
void
pushredir(int type, int from, int to)
{
    redir * rp = new(redir);
    rp->type = type;
    rp->from = from;
    rp->to = to;

    // add_list(runq->redir, rp)
    rp->next = runq->redir;
    runq->redir = rp;
}
@
%ocaml: just use :: and create directly with constructor.


\subsubsection{[[doredir()]]}

% execexec -> <>
<<function [[doredir]]>>=
void
doredir(redir *rp)
{
    if(rp){
        // recurse first, so do them in the reverse order of the list
        doredir(rp->next);

        switch(rp->type){
        <<[[doredir()]] switch redir type cases>>
        }
    }
}
@

% so when do cmd > foo < bar, what is done first?
% more importantly when do cmd > foo >[2=1] ?  vs cmd >[2=1] > foo ?

<<[[doredir()]] switch redir type cases>>=
case ROPEN:
    if(rp->from != rp->to){
        Dup(rp->from, rp->to);
        close(rp->from);
    }
    break;
@

<<constant [[ROPEN]]>>=
/*
 * redir types
 */
#define	ROPEN	1			/* dup2(from, to); close(from); */
@




\subsubsection{Bytecode generation}

<<[[outcode()]] cases>>=
case REDIR:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xglob);

    switch(t->rtype){
    <<[[outcode()]] when REDIR case, switch redirection type cases>>
    }
    emiti(t->fd0);
    outcode(c1, eflag);
    emitf(Xpopredir);
    break;
@

% the popredir is here because when do
%  cmd1 > foo; cmd2; cmd3
% we want the redirection to be value only while executing cmd1.
% so once this is done, and start cmd2, we need to pop the redir.


\subsubsection{[[Xwrite()]]}

<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case WRITE:
    emitf(Xwrite);
    break;
@

<<function [[Xwrite]]>>=
void
Xwrite(void)
{
    char *file;
    fdt f;
    switch(count(runq->argv->words)){
    default:
        Xerror1("> requires singleton\n");
        return;
    case 0:
        Xerror1("> requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = Creat(file))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@


<<function [[Xpopredir]]>>=
void
Xpopredir(void)
{
    struct Redir *rp = runq->redir;

    if(rp==nil)
        panic("turfredir null!", 0);

    // pop_list(runq->redir);
    runq->redir = rp->next;

    if(rp->type==ROPEN)
        close(rp->from);

    efree((char *)rp);
}
@

% also when get an error, we must not forget when we raise the exception
% to close what was opened here!
% See turfredir().

\subsubsection{[[Xread()]]}


<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case READ:
case HERE:
    emitf(Xread);
    break;
@


<<function [[Xread]]>>=
void
Xread(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1("< requires singleton\n");
        return;
    case 0:
        Xerror1("< requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, 0))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@

\subsubsection{[[Xappend()]]}

<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case APPEND:
    emitf(Xappend);
    break;
@


<<function [[Xappend]]>>=
void
Xappend(void)
{
    char *file;
    int f;
    switch(count(runq->argv->words)){
    default:
        Xerror1(">> requires singleton");
        return;
    case 0:
        Xerror1(">> requires file");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, 1))<0 && (f = Creat(file))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    Seek(f, 0L, 2);
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@


\subsubsection{Closing redirection opened files}

% why need remember the redir when we started? because 
% if we got an error in the thread, we need to close every redirections
% that happens since we started this new thread.
% In fact, when we Xreturn we also need to close what was opened.

<<[[Thread]] other fields>>=
struct Redir *startredir;	/* redir inheritance point */
@
%ocaml: use list of list for redir instead, so no "inheritance" need
% just use List.flatten in doredir() instead

% (Xerror | ...) -> Xreturn -> <>
<<function [[turfredir]]>>=
void
turfredir(void)
{
    while(runq->redir != runq->startredir)
        Xpopredir();
}
@
%ocaml: just pop the list

<<[[Xreturn()]] pop the redirections from this thread>>=
turfredir();
@



\subsection{Pipe}

% arguably the most important operator

%\subsubsection{Trace of a pipe}

% when do   % ls | wc -l, what happens?
% first bootstrapped thread t1, 
% then read, compile, and start new thread t2 for that (which when it will
% return, we return to the loop).
% FIGURE? 

% execute bytecodes, see Pipe byecode. Then fork, in child1 execute
% bytecodes for ls (still in interpreter!). This child1 eventually will
% arrive on a simple command and so forkexec a child2 that will execute
% ls. In the mean time child1 will Waitfor child2. child1 is still interpreter
% and once it has wait, it exits with return status.
% Why forkexec child2, child2 seems like he does not do much.
% But because in that case ls was a simple command. But what if
%  (ls | grep) | wc -l! 
% (actually I think there is an opti that makes child1 exec directly ls).

% So child1 terminated.
% In the mean time the parent when to start a new thread t3 for [wc -l],
% and once this thread finish, it does Xpipewait to wait for either
% left part or right part.
% this new thread t3 does a forkexec child3. T3 also wait for child3
% (but actually can have got the waitfor status of child1)
% and return once done to t2.
% t2 then Xpipewait and wait for either child1 (if not finished yet)
% or concatenate the status.
% once done it returns to loop and thread t2.

% so see that even if cmd1 | cmd2 there is actually 3 forks!



<<[[outcode()]] locals>>=
int q;
@



% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,
% * 					wait for both
% * Xpipewait

<<[[outcode()]] cases>>=
case PIPE:
    emitf(Xpipe);
    emiti(t->fd0); // 1 in the normal case
    emiti(t->fd1); // 0 in the normal case
    p = emiti(0);
    q = emiti(0);

    // for first child
    outcode(c0, eflag);
    emitf(Xexit);

    // for second child
    stuffdot(p);
    outcode(c1, eflag);
    emitf(Xreturn);
 
    // for parent (rc)
    stuffdot(q);
    emitf(Xpipewait);
    break;
@


<<[[codefree()]] in loop over code [[cp]], switch bytecode cases>>=
else if(p->f==Xpipe) 
         p+=4;
@


<<function [[Xreturn]]>>=
void
Xreturn(void)
{
    struct Thread *p = runq;

    <<[[Xreturn()]] pop the redirections from this thread>>
    // free p
    while(p->argv) 
        poplist();
    codefree(p->code);
    // pop(runq)
    runq = p->ret;
    efree((char *)p);

    if(runq==nil)
        Exit(getstatus());
}
@
%ocaml: no need poplist, codefree, just use Gc

% as goes up the call stack, you need to close the opened redirections
% see turfredir.



<<constant [[PRD]]>>=
/*
 * Which fds are the reading/writing end of a pipe?
 * Unfortunately, this can vary from system to system.
 * 9th edition Unix doesn't care, the following defines
 * work on plan 9.
 */
#define	PRD	0
@
<<constant [[PWR]]>>=
#define	PWR	1
@
%ocaml: pipe returns a pair, and you can bind to clear names as in
%  let (pipe_read, pipe_write) = Unix.pipe () in

% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,	wait for both

<<function [[Xpipe]]>>=
void
Xpipe(void)
{
    struct Thread *p = runq;
    int pc = p->pc;
    int forkid;
    fdt lfd = p->code[pc++].i;
    fdt rfd = p->code[pc++].i;
    fdt pfd[2];

    if(pipe(pfd)<0){
        Xerror("can't get pipe");
        return;
    }
    switch(forkid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        // pc+2 so jump the jump addresses
        start(p->code, pc+2, runq->local);
        runq->ret = nil;
        close(pfd[PRD]);
        pushredir(ROPEN, pfd[PWR], lfd);
        break;
    default: // parent
        addwaitpid(forkid);
        start(p->code, p->code[pc].i, runq->local);
        close(pfd[PWR]);
        pushredir(ROPEN, pfd[PRD], rfd);
        p->pc = p->code[pc+1].i;
        p->pid = forkid;
        break;
    }
}
@
% note that execute left part in a fork, so cant modify stuff there.
% but for right part there is no fork, so right part can do 
% some assignments that will be seen after.

% note that the break in the child
% will return to interpreter loop that will execute this new thread

% try  % while() $a=1 | while () $b=2
% echo $a $b


<<[[Thread]] other fields>>=
// option<int> (None = -1)
int pid;		/* process for Xpipewait to wait for */
@
% could pass value through argv? maybe, but anyway need to
% store in the list of threads in runq which thread is waiting
% for which pid so when do wait(), know which one have already
% been handled in which case Xpipewait should not wait().

% Note that can not just do the wait in Xpipe. We need to let
% the right cmd pipe execute in its thread first! once it is done
% then we can continue and do the wait for it in the parent (rc) process.


<<[[Thread]] other fields>>=
char status[NSTATUS];	/* status for Xpipewait */
@
<<constant [[NSTATUS]]>>=
#define	NSTATUS	ERRMAX			/* length of status (from plan 9) */
@
%ocaml: a waitstatus type = WaitFor of int | ChildStatus of string


<<function [[Xpipewait]]>>=
void
Xpipewait(void)
{
    char status[NSTATUS+1];
    if(runq->pid==-1)
        setstatus(concstatus(runq->status, getstatus()));
    else{
        strncpy(status, getstatus(), NSTATUS);
        status[NSTATUS]='\0';
        Waitfor(runq->pid, 1);
        runq->pid=-1;
        setstatus(concstatus(getstatus(), status));
    }
}
@
% get status from left child and concatenate with our own status
% (right child should have returned it through a Xreturn)


<<[[Waitfor()]] in while loop, if wait returns another pid>>=
// else
for(p = runq->ret;p;p = p->ret)
    if(p->pid==w->pid){
        p->pid=-1;
        strcpy(p->status, w->msg);
    }
free(w);
@

% the wait() syscall does not accept a specific pid, so when you wait,
% you can get any child. When in rc you do  cmd1 | cmd2 | cmd3
% you dont know which one will terminate first, but you need
% to remember which thread is waiting for certain pid.
% enter Thread.pid and the loop above.


<<function [[concstatus]]>>=
char*
concstatus(char *s, char *t)
{
    static char v[NSTATUS+1];
    int n = strlen(s);
    strncpy(v, s, NSTATUS);
    if(n<NSTATUS){
        v[n]='|';
        strncpy(v+n+1, t, NSTATUS-n-1);
    }
    v[NSTATUS]='\0';
    return v;
}
@
%ocaml: hmm, just use ^ or sprintf










\subsection{Asynchronous execution}

<<[[outcode()]] cases>>=
case '&':
    emitf(Xasync);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    break;
@



% * Xasync{... Xexit}			make thread for {}, no wait
<<function [[Xasync]]>>=
void
Xasync(void)
{
    fdt null = open("/dev/null", 0);
    int pid;
    char npid[10];
    if(null<0){
        Xerror("Can't open /dev/null\n");
        return;
    }
    switch(pid = rfork(RFFDG|RFPROC|RFNOTEG)){
    case -1:
        close(null);
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        pushredir(ROPEN, null, 0);
        // start a new Thread runq->pc+1 so skip pointer to code after &
        start(runq->code, runq->pc+1, runq->local);
        runq->ret = 0;
        break;
    default: // parent
        addwaitpid(pid);
        close(null);
        // jump to code after &
        runq->pc = runq->code[runq->pc].i;
        inttoascii(npid, pid);
        setvar("apid", newword(npid, (word *)nil));
        break;
    }
}
@

% mypid is global set at the very beginning
<<function [[Xexit]]>>=
void
Xexit(void)
{
    struct Var *trapreq;
    struct Word *starval;
    static bool beenhere = false;

    if(getpid()==mypid && !beenhere){
        trapreq = vlook("sigexit");
        if(trapreq->fn){
            beenhere = true;
            --runq->pc;
            starval = vlook("*")->val;
            start(trapreq->fn, trapreq->pc, (struct Var *)0);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)0);
            runq->local->changed = true;
            runq->redir = runq->startredir = nil;
            return;
        }
    }
    Exit(getstatus());
}
@

% Xexit vs Exit vs exits



\section{Control flow statements}

\subsection{[[if]]}

% remember than in rc there is   'if ( )' and 'if not' for else.

<<[[outcode()]] cases>>=
case IF:
    outcode(c0, false);
    emitf(Xif);
    p = emiti(0);
    outcode(c1, eflag);
    emitf(Xwastrue);
    stuffdot(p);
    break;
@


<<function [[Xif]]>>=
void
Xif(void)
{
    ifnot = true;
    if(truestatus()) 
        runq->pc++;
    else 
        runq->pc = runq->code[runq->pc].i;
}
@

<<global [[ifnot]]>>=
bool ifnot;		/* dynamic if not flag */
@


<<function [[Xwastrue]]>>=
void
Xwastrue(void)
{
    ifnot = false;
}
@




<<[[outcode()]] cases>>=
case NOT:
    <<[[outcode()]] when NOT, sanity check last command was an if>>
    emitf(Xifnot);
    p = emiti(0);
    outcode(c0, eflag);
    stuffdot(p);
    break;
@

<<function [[Xifnot]]>>=
void
Xifnot(void)
{
    if(ifnot)
        runq->pc++;
    else
        runq->pc = runq->code[runq->pc].i;
}
@


<<[[outcode()]] when NOT, sanity check last command was an if>>=
if(!runq->iflast)
    yyerror("`if not' does not follow `if(...)'");
@

% should be handled via grammar
<<[[Thread]] other fields>>=
bool iflast;		/* static `if not' checking */
@

<<[[outcode()]] set iflast after switch>>=
if(t->type!=NOT && t->type!=';')
    runq->iflast = t->type==IF;
else 
   if(c0) 
       runq->iflast = c0->type==IF;
@

<<[[outcode()]] set iflast before switch>>=
if(t->type!=NOT && t->type!=';')
    runq->iflast = false;
@


\subsection{[[while]]}

<<[[outcode()]] cases>>=
case WHILE:
    q = codep;
    outcode(c0, false);
    if(q==codep)
        emitf(Xsettrue);	/* empty condition == while(true) */
    emitf(Xtrue);
    p = emiti(0);
    outcode(c1, eflag);
    emitf(Xjump);
    emiti(q);
    stuffdot(p);
    break;
@

<<function [[Xsettrue]]>>=
void
Xsettrue(void)
{
    setstatus("");
}
@

<<function [[Xjump]]>>=
void
Xjump(void)
{
    runq->pc = runq->code[runq->pc].i;
}
@

\subsection{[[for]]}

% why Xmark?

<<[[outcode()]] cases>>=
case FOR:
    emitf(Xmark);
    if(c1){
        outcode(c1, eflag);
        emitf(Xglob);
    }
    else{
        emitf(Xmark);
        emitf(Xword);
        emits(strdup("*"));
        emitf(Xdol);
    }
    emitf(Xmark);		/* dummy value for Xlocal */
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xlocal);
    p = emitf(Xfor);
    q = emiti(0);
    outcode(c2, eflag);
    emitf(Xjump);
    emiti(p);
    stuffdot(q);
    emitf(Xunlocal);
    break;
@

<<function [[Xfor]]>>=
void
Xfor(void)
{
    if(runq->argv->words==0){
        poplist();
        runq->pc = runq->code[runq->pc].i;
    }
    else{
        freelist(runq->local->val);
        runq->local->val = runq->argv->words;
        runq->local->changed = true;
        runq->argv->words = runq->argv->words->next;
        runq->local->val->next = 0;
        runq->pc++;
    }
}
@


\subsection{[[switch]]}
% mv in advanced topic?

<<[[outcode()]] cases>>=
case SWITCH:
    codeswitch(t, eflag);
    break;
@

<<function [[codeswitch]]>>=
/*
 * switch code looks like this:
 *	Xmark
 *	(get switch value)
 *	Xjump	1f
 * out:	Xjump	leave
 * 1:	Xmark
 *	(get case values)
 *	Xcase	1f
 *	(commands)
 *	Xjump	out
 * 1:	Xmark
 *	(get case values)
 *	Xcase	1f
 *	(commands)
 *	Xjump	out
 * 1:
 * leave:
 *	Xpopm
 */
void
codeswitch(tree *t, bool eflag)
{
    int leave;		/* patch jump address to leave switch */
    int out;		/* jump here to leave switch */
    int nextcase;	/* patch jump address to next case */
    tree *tt;

    // c1 is BRACE { ; ; ; }
    if(c1->child[0]==nil
    || c1->child[0]->type != ';'
    || !iscase(c1->child[0]->child[0])){
        yyerror("case missing in switch");
        return;
    }

    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xjump);

    nextcase = emiti(0);
    out = emitf(Xjump);
    leave = emiti(0);

    stuffdot(nextcase);

    // from now on c0, c1, ... refer to this new t
    t = c1->child[0];
    while(t->type==';'){
        tt = c1;
        emitf(Xmark);
        for(t = c0->child[0];t->type==ARGLIST;t = c0) 
            outcode(c1, eflag);
        emitf(Xcase);
        nextcase = emiti(0);
        t = tt;
        for(;;){
            if(t->type==';'){
                if(iscase(c0)) 
                    break;
                outcode(c0, eflag);
                t = c1;
            }
            else{
                if(!iscase(t)) 
                    outcode(t, eflag);
                break;
            }
        }
        emitf(Xjump);
        emiti(out);
        stuffdot(nextcase);
    }
    stuffdot(leave);
    emitf(Xpopm);
}
@
%ocaml: easier in ocaml, more precise AST, so less jungle with c0, c1
% and also first word of simple command is directly accessible. No need
% to go through ARGLIST.

% funny that case is not a keyword. It's just a word, but
% it's recognized specially by rc
% but must be alone on its line (or need to use ; so case 1; cmd1; cmd2 etc)

% remember that foo arg1 arg2 is represented as a tree of ARGLIST
%  where foo is in depth.
% remember that list of commands in a switch is represented as a 
%  list with ';' for the node, and the top node has BRACE.

% used by swich only. So could mv later.
% In fact could remove the need for List, just have a single argv.
<<function [[Xpopm]]>>=
void
Xpopm(void)
{
    poplist();
}
@
% why not call directly poplist then? because would be dependency
% to runtime from compile!



<<function [[iscase]]>>=
bool
iscase(tree *t)
{
    if(t->type!=SIMPLE)
        return false;
    do { t = c0; } while(t->type==ARGLIST);
    return t->type==WORD && !t->quoted && strcmp(t->str, "case")==0;
}
@
%ocaml: just use pattern match, much cleaner, much more typesafe

% * Xcase(pat, value){...}		exec code on match, leave (value) on

<<function [[Xcase]]>>=
void
Xcase(void)
{
    word *p;
    char *s;
    bool ok = false;

    s = list2str(runq->argv->next->words);
    for(p = runq->argv->words;p;p = p->next){
        if(match(s, p->word, '\0')){
            ok = true;
            break;
        }
    }
    efree(s);
    if(ok)
        runq->pc++;
    else
        runq->pc = runq->code[runq->pc].i;
    poplist();
}
@


\subsection{Blocks: \texttt{'\{...\}'}}

<<[[outcode()]] cases>>=
case PAREN:
    outcode(c0, eflag);
    break;
@
% not really for {}, it is for () as in A=(1 2 3)

<<[[outcode()]] cases>>=
case PCMD:
case BRACE:
    outcode(c0, eflag);
    break;
@


\section{Functions}


<<[[Var]] other fields>>=
code	*fn;		/* pointer to function's code vector */
int	pc;		/* pc of start of function */
bool	fnchanged;
@
%ocaml: put in another type, not with Var



\subsection{Function definitions ([[fn <foo> { ... }]])}
% defs

% * Xfn(name){... Xreturn}			define function
% * Xdelfn(name)				delete function definition
<<[[outcode()]] cases>>=
case FN:
    emitf(Xmark);
    outcode(c0, eflag);
    if(c1){
        emitf(Xfn);
        p = emiti(0);
        emits(fnstr(c1));
        outcode(c1, eflag); // body of the function
        emitf(Xunlocal);	/* get rid of $* */ //$
        emitf(Xreturn);
        stuffdot(p);
    }
    else
        emitf(Xdelfn);
    break;
@

<<[[codefree()]] in loop over code [[cp]], switch bytecode cases>>=
else if(p->f==Xfn){
         efree(p[2].s);
         p+=2;
      }
@

<<function [[fnstr]]>>=
char*
fnstr(tree *t)
{
    void *v;
    extern char nl;
    char svnl = nl;
    io *f = openstr();

    nl = ';';
    pfmt(f, "%t", t);
    nl = svnl;
    v = f->strp;
    f->strp = nil;
    closeio(f);
    return v;
}
@



<<function [[Xfn]]>>=
void
Xfn(void)
{
    var *v;
    word *a;
    int end;

    end = runq->code[runq->pc].i;
    globlist();
    for(a = runq->argv->words;a;a = a->next){
        v = gvlook(a->word);
        if(v->fn)
            codefree(v->fn);
        v->fn = codecopy(runq->code);
        v->pc = runq->pc+2;
        v->fnchanged = true;
    }
    runq->pc = end;
    poplist();
}
@

<<function [[Xdelfn]]>>=
void
Xdelfn(void)
{
    var *v;
    word *a;

    for(a = runq->argv->words;a;a = a->next){
        v = gvlook(a->word);
        if(v->fn)
            codefree(v->fn);
        v->fn = nil;
        v->fnchanged = true;
    }
    poplist();
}
@
% can delete a list of functions. meh.

\subsection{Function uses ([[<foo>(...)]])}

<<[[Xsimple()]] other locals>>=
var *v;
@

<<[[Xsimple()]] if argv0 is a function>>=
v = gvlook(a->word);
if(v->fn)
    execfunc(v);
@

<<function [[execfunc]]>>=
void
execfunc(var *func)
{
    word *starval;

    popword();
    starval = runq->argv->words;
    runq->argv->words = nil;
    poplist();
    start(func->fn, func->pc, runq->local);
    runq->local = newvar(strdup("*"), runq->local);
    runq->local->val = starval;
    runq->local->changed = true;
}
@

\section{Variables}

\subsection{Variable definitions ([[<x>=...]])}

<<[[outcode()]] locals>>=
tree *tt;
@

% note that can have A=b C=d cmd
% so to know if it's a local or global assignment, we need to look
% at the very right after the '=' nodes.

<<[[outcode()]] cases>>=
case '=':
    tt = t;
    for(;t && t->type=='='; t = c2);

    if(t){					/* var=value cmd */
        for(t = tt;t->type=='=';t = c2){
            emitf(Xmark);
            outcode(c1, eflag);
            emitf(Xmark);
            outcode(c0, eflag);
            emitf(Xlocal);		/* push var for cmd */
        }
        outcode(t, eflag);		/* gen. code for cmd */
        for(t = tt; t->type == '='; t = c2)
            emitf(Xunlocal);	/* pop var */
    }
    else{					/* var=value */
        for(t = tt;t;t = c2){
            emitf(Xmark);
            outcode(c1, eflag);
            emitf(Xmark);
            outcode(c0, eflag);
            emitf(Xassign);	/* set var permanently */
        }
    }
    t = tt;	/* so tests below will work */
    break;
@

<<function [[Xassign]]>>=
void
Xassign(void)
{
    var *v;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    deglob(runq->argv->words->word); // remove the special \001 mark
    v = vlook(runq->argv->words->word);
    poplist();

    globlist();
    freewords(v->val);
    v->val = runq->argv->words;
    v->changed = true;
    runq->argv->words = nil;
    poplist();
}
@
% set to nil because dont want poplist to free it. 
% it has been borrowed by v->val.
%ocaml: just use the Gc

% no globbing here! cos can do *=(...); for(i) { ... }
% anyway since we expect a single varname on the left of =,
% it would not make sense to glob.

% deglob is to remove the \001 inserted during lexing

% FIGURE to understand the double pop_list()?

<<function [[Xlocal]]>>=
void
Xlocal(void)
{
    if(count(runq->argv->words)!=1){
        Xerror1("variable name must be singleton\n");
        return;
    }
    deglob(runq->argv->words->word);
    runq->local = newvar(strdup(runq->argv->words->word), runq->local);
    poplist();
    globlist();
    runq->local->val = runq->argv->words;
    runq->local->changed = true;
    // change ownership
    runq->argv->words = nil;
    poplist();
}
@

<<function [[Xunlocal]]>>=
void
Xunlocal(void)
{
    var *v = runq->local, *hid;
    if(v==0)
        panic("Xunlocal: no locals!", 0);
    runq->local = v->next;
    hid = vlook(v->name);
    hid->changed = true;
    efree(v->name);
    freewords(v->val);
    efree((char *)v);
}
@


\subsection{Variable uses ([[$<x>]])} %$

<<[[outcode()]] cases>>=
case '$': //$
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xdol);
    break;
@

<<function [[Xdol]]>>=
void
Xdol(void)
{
    word *a, *star;
    char *s, *t;
    int n;

    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);

    n = 0;
    for(t = s;'0'<=*t && *t<='9';t++) 
        n = n*10+*t-'0';

    a = runq->argv->next->words;
    if(n==0 || *t)
        a = copywords(vlook(s)->val, a);
    else{
        star = vlook("*")->val;
        if(star && 1 <= n && n <= count(star)){
            while(--n) 
                star = star->next;
            a = newword(star->word, a);
        }
    }
    poplist();
    runq->argv->words = a;
}
@
%ocaml: be more strict when array index out of bound





<<[[outcode()]] cases>>=
case COUNT:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xcount);
    break;
@


<<function [[Xcount]]>>=
void
Xcount(void)
{
    word *a;
    char *s, *t;
    int n;
    char num[12];

    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);

    // n = int_of_string(s)
    n = 0;
    for(t = s;'0'<=*t && *t<='9';t++) 
        n = n*10 + *t - '0';
    if(n==0 || *t){
        a = vlook(s)->val;
        inttoascii(num, count(a));
    }
    else{
        a = vlook("*")->val;
        inttoascii(num, (a && 1<=n && n<=count(a)) ? 1 : 0);
    }
    poplist();
    pushword(num);
}
@
%ocaml: factorize in a vlook_varname_or_index with code for Xdol?
% a bit hard to factorize, different logic


<<[[outcode()]] cases>>=
case SUB:
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xsub);
    break;
@


<<function [[Xsub]]>>=
void
Xsub(void)
{
    word *a, *v;
    char *s;
    if(count(runq->argv->next->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->next->words->word;
    deglob(s);
    a = runq->argv->next->next->words;
    v = vlook(s)->val;
    a = subwords(v, count(v), runq->argv->words, a);
    poplist();
    poplist();
    runq->argv->words = a;
}
@

<<function [[subwords]]>>=
word*
subwords(word *val, int len, word *sub, word *a)
{
    int n, m;
    char *s;
    if(!sub)
        return a;
    a = subwords(val, len, sub->next, a);
    s = sub->word;
    deglob(s);
    m = 0;
    n = 0;
    while('0'<=*s && *s<='9')
        n = n*10+ *s++ -'0';
    if(*s == '-'){
        if(*++s == 0)
            m = len - n;
        else{
            while('0'<=*s && *s<='9')
                m = m*10+ *s++ -'0';
            m -= n;
        }
    }
    if(n<1 || n>len || m<0)
        return a;
    if(n+m>len)
        m = len-n;
    while(--n > 0)
        val = val->next;
    return copynwords(val, a, m+1);
}
@



<<[[outcode()]] cases>>=
case '^':
    emitf(Xmark);
    outcode(c1, eflag);
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xconc);
    break;
@

<<function [[Xconc]]>>=
void
Xconc(void)
{
    word *lp = runq->argv->words;
    word *rp = runq->argv->next->words;
    word *vp = runq->argv->next->next->words;
    int lc = count(lp), rc = count(rp);
    if(lc!=0 || rc!=0){
        if(lc==0 || rc==0){
            Xerror1("null list in concatenation");
            return;
        }
        if(lc!=1 && rc!=1 && lc!=rc){
            Xerror1("mismatched list lengths in concatenation");
            return;
        }
        vp = conclist(lp, rp, vp);
    }
    poplist();
    poplist();
    runq->argv->words = vp;
}
@

<<function [[conclist]]>>=
word*
conclist(word *lp, word *rp, word *tail)
{
    char *buf;
    word *v;
    if(lp->next || rp->next)
        tail = conclist(lp->next==0? lp: lp->next,
            rp->next==0? rp: rp->next, tail);
    buf = emalloc(strlen(lp->word)+strlen((char *)rp->word)+1);
    strcpy(buf, lp->word);
    strcat(buf, rp->word);
    v = newword(buf, tail);
    efree(buf);
    return v;
}
@


%\subsection{Interpolation}

% There is no "" vs '' in rc. Just '' to quote (hence the use of a _quote_
% character). If you want to construct an argument with space
% that includes dollars, use ^.


\subsection{Special variables}
\label{sec:special-variables}
% list them all!

%vlook("xxx"):
% home, cdpath, path
% prompt, 
% * (TODO aspectize vlook("*") code)
% status, sigexit
% ifs?

% $status far clearer than $0
% and under plan9 string, not int so clearer

\chapter{Builtins}
\label{chap:builtins}



\section{Overview}

% called from Xsimple when first word is actually recognized as a builtin

<<struct [[Builtin]]>>=
struct Builtin {
    char *name;
    void (*fnc)(void);
};
@

% plan9.c
% rename Builtin -> builtins
<<global [[builtins]]>>=
builtin builtins[] = {
    "cd"     ,      execcd,
    "exit"   ,      execexit,
    "."      ,      execdot,
    "eval"   ,      execeval,

    "whatis" ,      execwhatis,

    "exec"   ,      execexec,   /* but with popword first */
    "rfork"  ,      execnewpgrp,
    "wait"   ,      execwait,

    "shift"  ,      execshift,
    "finit"  ,      execfinit,
    "flag"   ,      execflag,
    0
};
@
%old: was Builtin but conflict with struct def and bad convention

<<[[Xsimple()]] other locals>>=
struct Builtin *bp;
@

% 2 ways to call, either directly 'xxx' or via 'builtin xxx'
<<[[Xsimple()]] if argv0 is a builtin>>=
<<[[Xsimple()]] if argv0 is the builtin keyword>>
for(bp = builtins;bp->name;bp++)
    if(strcmp(a->word, bp->name)==0){
        (*bp->fnc)();
        return;
    }
@

<<[[Xsimple()]] if argv0 is the builtin keyword>>=
if(strcmp(a->word, "builtin")==0){
    if(count(a)==1){
        pfmt(err, "builtin: empty argument list\n");
        setstatus("empty arg list");
        poplist();
        return;
    }
    a = a->next;
    popword();
}
@

% remember that also have function, so if cd is a function
% but want the builtin, need "builtin" prefix to escape
% the function resolution mechanism.


\section{[[$ cd]]}
%$

<<function [[execcd]]>>=
void
execcd(void)
{
    word *a = runq->argv->words;
    word *cdpath;
    char *dir;

    setstatus("can't cd");
    cdpath = vlook("cdpath")->val;

    switch(count(a)){
    case 1:
        a = vlook("home")->val;
        if(count(a)>=1){
            if(dochdir(a->word)>=0)
                setstatus("");
            else
                pfmt(err, "Can't cd %s: %r\n", a->word);
        }
        else
            pfmt(err, "Can't cd -- $home empty\n"); //$
        break;
    case 2:
        if(a->next->word[0]=='/' || cdpath==nil)
            cdpath = &nullpath;
        for(; cdpath; cdpath = cdpath->next){
            if(cdpath->word[0] != '\0')
                dir = appfile(cdpath->word, a->next->word);
            else
                dir = strdup(a->next->word);

            if(dochdir(dir) >= 0){
                if(cdpath->word[0] != '\0' &&
                    strcmp(cdpath->word, ".") != 0)
                    pfmt(err, "%s\n", dir);
                free(dir);
                setstatus("");
                break;
            }
            free(dir);
        }
        if(cdpath==nil)
            pfmt(err, "Can't cd %s: %r\n", a->next->word);
        break;
    default:
        pfmt(err, "Usage: cd [directory]\n");
        break;
    }
    poplist();
}
@
%$

<<function [[appfile]]>>=
static char *
appfile(char *dir, char *comp)
{
    int dirlen, complen;
    char *s, *p;

    dirlen = strlen(dir);
    complen = strlen(comp);
    s = emalloc(dirlen + 1 + complen + 1);
    memmove(s, dir, dirlen);
    p = s + dirlen;
    *p++ = '/';
    memmove(p, comp, complen);
    p[complen] = '\0';
    return s;
}
@
%ocaml: Filename.concat

% /dev/wdir?

%XXX what is this wdirfd???
<<function [[dochdir]]>>=
errorneg1
dochdir(char *word)
{
    <<[[dochdir()]] locals>>

    // the actual syscall
    if(chdir(word)<0) 
        return ERROR_NEG1;

    <<[[dochdir()]] adjust [[/dev/wdir]] if run under [[rio]]>>
    return OK_1;
}
@




<<[[dochdir()]] locals>>=
/* report to /dev/wdir if it exists and we're interactive */
static fdt wdirfd = -2;
@
<<[[dochdir()]] adjust [[/dev/wdir]] if run under [[rio]]>>=
if(flag['i']!=nil){
    if(wdirfd==-2)  /* try only once */
        wdirfd = open("/dev/wdir", OWRITE|OCEXEC);
    if(wdirfd>=0) {
        //fcntl(wdirfd, F_SETFD, FD_CLOEXEC);
        write(wdirfd, word, strlen(word));
    }
}
@
\book{Windows}

\section{[[$ exit]]}
%$

<<function [[execexit]]>>=
void
execexit(void)
{
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: exit [status]\nExiting anyway\n");
        // FALLTHROUGH
    case 2:
        setstatus(runq->argv->words->next->word);
        // FALLTHROUGH
    case 1: 
        Xexit();
    }
}
@

\section{[[$ .]]}
%$ 



<<function [[execdot]]>>=
void
execdot(void)
{
    thread *p = runq;
    bool iflag = false;
    fdt fd;
    list *av;
    char *zero; // new stdin
    char *file;
    word *path;
    <<[[execdot()]] other locals>>

    <<[[execdot()]] if first>>
    <<[[execdot()]] if not first execution>>

    popword(); // "."
    if(p->argv->words && strcmp(p->argv->words->word, "-i")==0){
        iflag = true;
        popword();
    }

    /* get input file */
    if(p->argv->words==nil){
        Xerror1("Usage: . [-i] file [arg ...]");
        return;
    }
    zero = strdup(p->argv->words->word);
    popword();

    fd = -1;
    for(path = searchpath(zero); path; path = path->next){
        if(path->word[0] != '\0')
            file = appfile(path->word, zero);
        else
            file = strdup(zero);

        fd = open(file, 0);
        free(file);
        if(fd >= 0)
            break;
    }
    if(fd<0){
        pfmt(err, "%s: ", zero);
        setstatus("can't open"); // what for? it is reseted by Xerror anyway
        Xerror(".: can't open");
        return;
    }

    /* set up for a new command loop */
    start(dotcmds, 1, (struct Var *)nil);

    pushredir(RCLOSE, fd, 0);
    runq->cmdfile = zero;
    runq->cmdfd = openfd(fd);
    runq->iflag = iflag;

    runq->iflast = false;

    /* push $* value */
    pushlist();
    runq->argv->words = p->argv->words;

    /* free caller's copy of $* */
    av = p->argv;
    p->argv = av->next;
    efree((char *)av);

    /* push $0 value */
    pushlist();
    pushword(zero);

    ndot++;
}
@
%$

<<global [[ndot]]>>=
/*
 * How many dot commands have we executed?
 * Used to ensure that -v flag doesn't print rcmain.
 */
int ndot;
@

<<global [[dotcmds]]>>=
union Code dotcmds[14];
@

<<[[execdot()]] other locals>>=
static bool first = true;
@
<<[[execdot()]] if first>>=
if(first){
    dotcmds[0].i = 1;
    dotcmds[1].f = Xmark;
      dotcmds[2].f = Xword;
      dotcmds[3].s = "0";
    dotcmds[4].f = Xlocal; // will pop_list twice

    dotcmds[5].f = Xmark;
      dotcmds[6].f = Xword;
      dotcmds[7].s="*";
    dotcmds[8].f = Xlocal; // will pop_list twice

    dotcmds[9].f = Xrdcmds; // =~ a REPL

    dotcmds[10].f = Xunlocal;
    dotcmds[11].f = Xunlocal;
    dotcmds[12].f = Xreturn;

    first = false;
}
@
%ocaml: just build at toplevel in an array directly. no need 'first' contorsion




%dead: no support for sun or ucb
%        if(strcmp(file, "/dev/stdin")==0){	/* for sun & ucb */
%            fd = Dup1(0);
%            if(fd>=0)
%                break;
%        }

%dead: because of code removed above
% <<function [[Dup1]]>>=
% int
% Dup1(int)
% {
%     return -1;
% }
% @

\section{[[$ eval]]}
%$

% TODO What is the point of eval? the interpreter loop is already an
% eval that does call Xrdcmds ...

<<function [[execeval]]>>=
void
execeval(void)
{
    char *cmdline, *s, *t;
    int len = 0;
    word *ap;

    if(count(runq->argv->words)<=1){
        Xerror1("Usage: eval cmd ...");
        return;
    }
    eflagok = true;
    for(ap = runq->argv->words->next;ap;ap = ap->next)
        len+=1+strlen(ap->word);

    cmdline = emalloc(len);
    s = cmdline;
    for(ap = runq->argv->words->next;ap;ap = ap->next){
        for(t = ap->word;*t;) *s++=*t++;
        *s++=' ';
    }
    s[-1]='\n';
    poplist();

    execcmds(opencore(cmdline, len));
    efree(cmdline);
}
@

<<global [[rdcmds]]>>=
union Code rdcmds[4];
@

<<function [[execcmds]]>>=
void
execcmds(io *f)
{
    static bool first = true;
    if(first){
        rdcmds[0].i = 1;
        rdcmds[1].f = Xrdcmds;
        rdcmds[2].f = Xreturn;
        first = false;
    }

    start(rdcmds, 1, runq->local);
    runq->cmdfd = f;
    runq->iflast = false;
}
@


\section{[[$ wait]]}
%$
% related to job control? because of &? I never used wait ...

<<function [[execwait]]>>=
void
execwait(void)
{
    switch(count(runq->argv->words)){
    default:
        Xerror1("Usage: wait [pid]");
        return;
    case 2:
        Waitfor(atoi(runq->argv->words->next->word), 0);
        break;
    case 1:
        Waitfor(-1, 0);
        break;
    }
    poplist();
}
@


\chapter{Environment}
\label{chap:environment}

\section{[[Updenv()]]}

% called from Xsimple() and Execute()
% why double? anyway with 'changed' field it should be ok
<<function [[Updenv]]>>=
void
Updenv(void)
{
    var *v, **h;

    for(h = gvar;h!=&gvar[NVAR];h++)
        for(v=*h;v;v = v->next)
            addenv(v);
    if(runq)
        updenvlocal(runq->local);
}
@

<<function [[updenvlocal]]>>=
void
updenvlocal(var *v)
{
    if(v){
        updenvlocal(v->next);
        addenv(v);
    }
}
@


<<enum [[MiscPlan9]]>>=
enum {
    Maxenvname = 256,	/* undocumented limit */
};
@

<<[[Var]] other fields>>=
bool	changed;
@

<<function [[addenv]]>>=
void
addenv(var *v)
{
    char envname[Maxenvname];
    word *w;
    int f;
    io *fd;

    if(v->changed){
        v->changed = false;
        snprint(envname, sizeof envname, "/env/%s", v->name);
        if((f = Creat(envname))<0)
            pfmt(err, "rc: can't open %s: %r\n", envname);
        else{
            for(w = v->val;w;w = w->next)
                write(f, w->word, strlen(w->word)+1L);
            close(f);
        }
    }
    if(v->fnchanged){
        v->fnchanged = false;
        snprint(envname, sizeof envname, "/env/fn#%s", v->name);
        if((f = Creat(envname))<0)
            pfmt(err, "rc: can't open %s: %r\n", envname);
        else{
            if(v->fn){
                fd = openfd(f);
                pfmt(fd, "fn %q %s\n", v->name, v->fn[v->pc-1].s);
                closeio(fd);
            }
            close(f);
        }
    }
}
@



\section{[[Vinit()]]}

% main -> <>
<<function [[Vinit]]>>=
void
Vinit(void)
{
    int dir, f, len, i, n, nent;
    char *buf, *s;
    char envname[Maxenvname];
    word *val;
    Dir *ent;

    dir = open("/env", OREAD);
    if(dir<0){
        pfmt(err, "rc: can't open /env: %r\n");
        return;
    }
    ent = nil;
    for(;;){
        nent = dirread(dir, &ent);
        if(nent <= 0)
            break;
        for(i = 0; i<nent; i++){
            len = ent[i].length;
            if(len && strncmp(ent[i].name, "fn#", 3)!=0){
                snprint(envname, sizeof envname, "/env/%s", ent[i].name);
                if((f = open(envname, 0))>=0){
                    buf = emalloc(len+1);
                    n = readn(f, buf, len);
                    if (n <= 0)
                        buf[0] = '\0';
                    else
                        buf[n] = '\0';
                    val = 0;
                    /* Charitably add a 0 at the end if need be */
                    if(buf[len-1])
                        buf[len++]='\0';
                    s = buf+len-1;
                    for(;;){
                        while(s!=buf && s[-1]!='\0') --s;
                        val = newword(s, val);
                        if(s==buf)
                            break;
                        --s;
                    }
                    setvar(ent[i].name, val);
                    vlook(ent[i].name)->changed = false;
                    close(f);
                    efree(buf);
                }
            }
        }
        free(ent);
    }
    close(dir);
}
@

<<global [[envdir]]>>=
fdt envdir;
@

%\section{Functions in the environment}
% see later with finit


\chapter{Signals}
\label{chap:signals}

% code of nohup utility?


% C-d generate an Xsimple (exit 1) ?

<<constant [[NSIG]]>>=
#define	NSIG	32
@

<<constant [[SIGINT]]>>=
#define	SIGINT	2
@

<<constant [[SIGQUIT]]>>=
#define	SIGQUIT	3
@


% plan9.c
<<global [[syssigname]]>>=
char *syssigname[] = {
    "exit",		/* can't happen */
    "hangup",
    "interrupt",
    "quit",		/* can't happen */
    "alarm",
    "kill",
    "sys: fp: ",
    "term",
    0
};
@

% plan9.c
<<global [[signame]]>>=
char *signame[] = {
    "sigexit",	
    "sighup",	
    "sigint",	
    "sigquit",
    "sigalrm",	
    "sigkill",	
    "sigfpe",	
    "sigterm",
    0
};
@
%old: was Signame but not consistent naming of globals


<<global [[ntrap]]>>=
int ntrap;				/* number of outstanding traps */
@

<<global [[trap]]>>=
int trap[NSIG];				/* number of outstanding traps per type */
@



% main() -> Trapinit()
<<function [[Trapinit]]>>=
void
Trapinit(void)
{
    notify(notifyf);
}
@

<<function [[notifyf]]>>=
void
notifyf(void*, char *s)
{
    int i;
    for(i = 0;syssigname[i];i++) 
     if(strncmp(s, syssigname[i], strlen(syssigname[i]))==0){
        if(strncmp(s, "sys: ", 5)!=0) 
            interrupted = true;
        goto Out;
    }
    pfmt(err, "rc: note: %s\n", s);
    noted(NDFLT);
    return;
Out:
    if(strcmp(s, "interrupt")!=0 || trap[i]==0){
        trap[i]++;
        ntrap++;
    }
    if(ntrap>=32){	/* rc is probably in a trap loop */
        pfmt(err, "rc: Too many traps (trap %s), aborting\n", s);
        abort();
    }
    noted(NCONT);
}
@


<<[[main()]] handing trap if necessary in interpreter loop>>=
if(ntrap)
    dotrap();
@




% trap.c
% main() -> dotrap() after having interpreter one bytecode
<<function [[dotrap]]>>=
void
dotrap(void)
{
    int i;
    struct Var *trapreq;
    struct Word *starval;

    starval = vlook("*")->val;
    while(ntrap) 
     for(i = 0;i!=NSIG;i++) 
      while(trap[i]){
        --trap[i];
        --ntrap;
        if(getpid()!=mypid) 
            Exit(getstatus());
        trapreq = vlook(signame[i]);
        if(trapreq->fn){
            start(trapreq->fn, trapreq->pc, (struct Var *)nil);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)nil);
            runq->local->changed = true;
            runq->redir = runq->startredir = nil;
        }
        else if(i==SIGINT || i==SIGQUIT){
            /*
             * run the stack down until we uncover the
             * command reading loop.  Xreturn will exit
             * if there is none (i.e. if this is not
             * an interactive rc.)
             */
            while(!runq->iflag) 
                Xreturn();
        }
        else 
            Exit(getstatus());
    }
}
@




<<global [[interrupted]]>>=
bool interrupted = false;
@

<<function [[Eintr]]>>=
bool
Eintr(void)
{
    return interrupted;
}
@


<<[[Xrdcmds()]] calls Noerror() before yyparse()>>=
Noerror();
@

<<function [[Noerror]]>>=
void
Noerror(void)
{
    interrupted = false;
}
@

<<[[Xrdcmds()]] reset ntrap>>=
ntrap = 0;	/* avoid double-interrupts during blocked writes */
@


\chapter{Initialization}
\label{chap:initialization-real}

\section{Actual bootstrapping code}

% see main() comment:
% * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)

%main() -> bootstrap -> execdot -> Xreadcmds() -> yyparse() -> compile() -> outcode() -> back to interpreter loop with new codebuf (chained to bootstrap)

%OPTIONAL
<<[[main()]] initialize [[boostrap]]>>=
memset(bootstrap, 0, sizeof bootstrap);

i = 0;
bootstrap[i++].i=1;
// runq->argv is populated with the arguments to rc
// we just need to add '*=(argv)'
bootstrap[i++].f = Xmark;
  bootstrap[i++].f = Xword;
  bootstrap[i++].s="*";
bootstrap[i++].f = Xassign; // will pop_list() x2

bootstrap[i++].f = Xmark;
  bootstrap[i++].f = Xmark;
    bootstrap[i++].f = Xword;
    bootstrap[i++].s="*";
  bootstrap[i++].f = Xdol; // will pop_list()
  bootstrap[i++].f = Xword;
  bootstrap[i++].s = rcmain;
  bootstrap[i++].f = Xword;
  bootstrap[i++].s=".";
bootstrap[i++].f = Xsimple; // will pop_list()

bootstrap[i++].f = Xexit;

bootstrap[i].i = 0;
@
%new: I indented to better see which Xmark correspond to what.

% It is Xassign (varname)(vals)
% but there is only one XMark above. Because runq->argv is initialized
%  with argv[]


% show rc foo bar -r
% great resource to see the bytecodes, argv.


\section{Intitialization script and [[rc -m /path/to/rcmain]]}

%plan9.c
<<global [[Rcmain]]>>=
char *Rcmain = "/rc/lib/rcmain";
@

<<[[main()]] locals>>=
char *rcmain;
@

<<[[main()]] initialisation>>=
rcmain = flag['m'] ? flag['m'][0] : Rcmain; 
@
% can change startup script, -m 

% Content of rcmain in Appendix.

\t how endup in REPL after . has finished executing rcmain then ??
\t  I think because rcmain contains call to finit?

\section{Actual environment}

<<global [[mypid]]>>=
int mypid;
@

<<[[main()]] locals>>=
char num[12];
@
%ocaml: no need for declaration, just do  'let num = int_to_string(mypid)'

<<[[main()]] initialisation>>=
mypid = getpid();
inttoascii(num, mypid);
setvar("pid", newword(num, (word *)nil));
@

<<[[main()]] initialisation>>=
setvar("rcname", newword(argv[0], (word *)nil));
@


% cflag will contain the -c arguments!




\chapter{Globbing}
\label{chap:globbing}
\n could be in advanced topics, but important feature in a shell

% patterns. wildcards.

% Give responsibility to shell to interpter '*' not program

%history: 
% was actually an external program in osh: glob (with also if, and goto)

%pro: factorize functionality
%cons: ugly corners (see Unix Haters Handbook)


% handle * expansion (before was delegated to another program called glob)
% also ? and []
% note that different from regexp, does not do .* because .
% used too much in filename for extension, so *.c is better than .*\\.c

\section{Lexing globbing characters}

<<constant [[GLOB]]>>=
/*
 * Glob character escape in strings:
 *	In a string, GLOB must be followed by *?[ or GLOB.
 *	GLOB* matches any string
 *	GLOB? matches any single character
 *	GLOB[...] matches anything in the brackets
 *	GLOBGLOB matches GLOB
 */
#define	GLOB	'\001'
@


<<[[yylex()]] when c is a word character, if glob character>>=
if(c=='*' || c=='[' || c=='?' || c==GLOB)
    w = addtok(w, GLOB);
@

<<function [[addtok]]>>=
char*
addtok(char *p, int val)
{
    if(p==nil)
        return nil;
    if(p >= &tok[NTOK]){
        *p = '\0';
        yyerror("token buffer too short");
        return nil;
    }
    *p++=val;
    return p;
}
@
% diff with addutf()?

\section{Expanding globbing characters}

<<global [[globv]]>>=
struct Word *globv;
@


<<[[Xsimple()]] initializations, [[globlist()]]>>=
globlist();
@

% Xsimple | ... -> <>
<<function [[globlist]]>>=
void
globlist(void)
{
    word *a;
    globv = nil;

    globlist1(runq->argv->words);
    poplist();
    pushlist();

    if(globv){
        for(a = globv;a->next;a = a->next)
            ;
        a->next = runq->argv->words;
        runq->argv->words = globv;
    }
}
@

<<function [[globlist1]]>>=
void
globlist1(word *gl)
{
    if(gl){
        globlist1(gl->next);
        glob(gl->word);
    }
}
@


% Why not add Xglob for SIMPLE cases too? generate a Xglob instead
%  of calling yourself globlist() in Xsimple ?

% outcode (REDIR and FOR cases) -> <>
<<function [[Xglob]]>>=
void
Xglob(void)
{
    globlist();
}
@

\section{[[glob()]]}

<<global [[globname]]>>=
char *globname;
@

<<function [[glob]]>>=
/*
 * Push all file names matched by p on the current thread's stack.
 * If there are no matches, the list consists of p.
 */
void
glob(void *ap)
{
    uchar *p = ap;
    word *svglobv = globv;
    int globlen = Globsize(ap);

    if(!globlen){
        deglob(p);
        globv = newword((char *)p, globv);
        return;
    }
    globname = emalloc(globlen);
    globname[0]='\0';
    globdir(p, (uchar *)globname);
    efree(globname);
    if(svglobv==globv){
        deglob(p);
        globv = newword((char *)p, globv);
    }
    else
        globsort(globv, svglobv);
}
@
\t on Linux emalloc(globlen) is not enough, I get some errors under valgrind












<<function [[deglob]]>>=
/*
 * delete all the GLOB marks from s, in place
 */
void
deglob(void *as)
{
    char *s = as;
    char *t = s;
    do{
        if(*t==GLOB)
            t++;
        *s++=*t;
    }while(*t++);
}
@

<<function [[globcmp]]>>=
int
globcmp(const void *s, const void *t)
{
    return strcmp(*(char**)s, *(char**)t);
}
@

<<function [[globsort]]>>=
void
globsort(word *left, word *right)
{
    char **list;
    word *a;
    int n = 0;
    for(a = left;a!=right;a = a->next) n++;
    list = (char **)emalloc(n*sizeof(char *));
    for(a = left,n = 0;a!=right;a = a->next,n++) list[n] = a->word;
    qsort((void *)list, n, sizeof(void *), globcmp);
    for(a = left,n = 0;a!=right;a = a->next,n++) a->word = list[n];
    efree((char *)list);
}
@

<<function [[globdir]]>>=
/*
 * Push names prefixed by globname and suffixed by a match of p onto the astack.
 * namep points to the end of the prefix in globname.
 */
void
globdir(uchar *p, uchar *namep)
{
    uchar *t, *newp;
    int f;
    /* scan the pattern looking for a component with a metacharacter in it */
    if(*p=='\0'){
        globv = newword(globname, globv);
        return;
    }
    t = namep;
    newp = p;
    while(*newp){
        if(*newp==GLOB)
            break;
        *t=*newp++;
        if(*t++=='/'){
            namep = t;
            p = newp;
        }
    }
    /* If we ran out of pattern, append the name if accessible */
    if(*newp=='\0'){
        *t='\0';
        if(access(globname, 0)==0)
            globv = newword(globname, globv);
        return;
    }
    /* read the directory and recur for any entry that matches */
    *namep='\0';
    if((f = Opendir(globname[0]?globname:"."))<0) return;
    while(*newp!='/' && *newp!='\0') newp++;
    while(Readdir(f, namep, *newp=='/')){
        if(matchfn(namep, p)){
            for(t = namep;*t;t++);
            globdir(newp, t);
        }
    }
    Closedir(f);
}
@


<<function [[equtf]]>>=
/*
 * Do p and q point at equal utf codes
 */
bool
equtf(uchar *p, uchar *q)
{
    Rune pr, qr;
    if(*p!=*q)
        return false;
    
    chartorune(&pr, (char*)p);
    chartorune(&qr, (char*)q);
    return pr == qr;
}
@

<<function [[nextutf]]>>=
/*
 * Return a pointer to the next utf code in the string,
 * not jumping past nuls in broken utf codes!
 */
uchar*
nextutf(uchar *p)
{
    Rune dummy;
    return p + chartorune(&dummy, (char*)p);
}
@

<<function [[unicode]]>>=
/*
 * Convert the utf code at *p to a unicode value
 */
int
unicode(uchar *p)
{
    Rune r;

    chartorune(&r, (char*)p);
    return r;
}
@

\section{[[match()]]}

<<function [[matchfn]]>>=
/*
 * Does the string s match the pattern p
 * . and .. are only matched by patterns starting with .
 * * matches any sequence of characters
 * ? matches any single character
 * [...] matches the enclosed list of characters
 */
bool
matchfn(void *as, void *ap)
{
    uchar *s = as, *p = ap;

    if(s[0]=='.' && (s[1]=='\0' || s[1]=='.' && s[2]=='\0') && p[0]!='.')
        return false;
    return match(s, p, '/');
}
@

<<function [[match]]>>=
bool
match(void *as, void *ap, int stop)
{
    int compl, hit, lo, hi, t, c;
    uchar *s = as, *p = ap;

    for(; *p!=stop && *p!='\0'; s = nextutf(s), p = nextutf(p)){
        if(*p!=GLOB){
            if(!equtf(p, s)) return false;
        }
        else switch(*++p){
        case GLOB:
            if(*s!=GLOB)
                return false;
            break;
        case '*':
            for(;;){
                if(match(s, nextutf(p), stop)) return 1;
                if(!*s)
                    break;
                s = nextutf(s);
            }
            return false;
        case '?':
            if(*s=='\0')
                return false;
            break;
        case '[':
            if(*s=='\0')
                return false;
            c = unicode(s);
            p++;
            compl=*p=='~';
            if(compl)
                p++;
            hit = 0;
            while(*p!=']'){
                if(*p=='\0')
                    return false;		/* syntax error */
                lo = unicode(p);
                p = nextutf(p);
                if(*p!='-')
                    hi = lo;
                else{
                    p++;
                    if(*p=='\0')
                        return false;	/* syntax error */
                    hi = unicode(p);
                    p = nextutf(p);
                    if(hi<lo){ t = lo; lo = hi; hi = t; }
                }
                if(lo<=c && c<=hi)
                    hit = 1;
            }
            if(compl)
                hit=!hit;
            if(!hit)
                return false;
            break;
        }
    }
    return *s=='\0';
}
@





<<constant [[NDIR]]>>=
#define	NDIR	256		/* shoud be a better way */
@

<<function [[Globsize]]>>=
int
Globsize(char *p)
{
    int isglob = 0, globlen = NDIR+1;
    for(;*p;p++){
        if(*p==GLOB){
            p++;
            if(*p!=GLOB)
                isglob++;
            globlen+=*p=='*'?NDIR:1;
        }
        else
            globlen++;
    }
    return isglob?globlen:0;
}
@


<<constant [[NFD]]>>=
#define	NFD	50
@

<<struct [[DirEntryWrapper]]>>=
struct DirEntryWrapper {
    Dir	*dbuf;
    int	i;
    int	n;
};
@
%old: was mixed with dir below and was an anonymous structure

<<global [[dir]]>>=
struct DirEntryWrapper dir[NFD];
@

<<function [[Opendir]]>>=
int
Opendir(char *name)
{
    Dir *db;
    int f;
    f = open(name, 0);
    if(f==-1)
        return f;
    db = dirfstat(f);
    if(db!=nil && (db->mode&DMDIR)){
        if(f<NFD){
            dir[f].i = 0;
            dir[f].n = 0;
        }
        free(db);
        return f;
    }
    free(db);
    close(f);
    return -1;
}
@


<<function [[trimdirs]]>>=
static int
trimdirs(Dir *d, int nd)
{
    int r, w;

    for(r=w=0; r<nd; r++)
        if(d[r].mode&DMDIR)
            d[w++] = d[r];
    return w;
}
@

<<function [[Readdir]]>>=
/*
 * onlydirs is advisory -- it means you only
 * need to return the directories.  it's okay to
 * return files too (e.g., on unix where you can't
 * tell during the readdir), but that just makes 
 * the globber work harder.
 */
int
Readdir(int f, void *p, int onlydirs)
{
    int n;

    if(f<0 || f>=NFD)
        return 0;
Again:
    if(dir[f].i==dir[f].n){	/* read */
        free(dir[f].dbuf);
        dir[f].dbuf = 0;
        n = dirread(f, &dir[f].dbuf);
        if(n>0){
            if(onlydirs){
                n = trimdirs(dir[f].dbuf, n);
                if(n == 0)
                    goto Again;
            }	
            dir[f].n = n;
        }else
            dir[f].n = 0;
        dir[f].i = 0;
    }
    if(dir[f].i == dir[f].n)
        return 0;
    strcpy(p, dir[f].dbuf[dir[f].i].name);
    dir[f].i++;
    return 1;
}
@

<<function [[Closedir]]>>=
void
Closedir(int f)
{
    if(f>=0 && f<NFD){
        free(dir[f].dbuf);
        dir[f].i = 0;
        dir[f].n = 0;
        dir[f].dbuf = 0;
    }
    close(f);
}
@


\chapter{Advanced Topics TODO}
\label{chap:advanced-topics}


%\section{Shell-like features implemented outside [[rc]]}
% job control: multiple windows
%  C-z: rio terminal where stopping scroll block the process
% command-line editing: rio terminal
% history: ???
% aliases: ??
% filename completion: rio terminal (but how does he know the current dir?)

% See also Conclusion

\section{Reading commands from a string: [[rc -c]]}
\label{sec:rc-c}

%history: also in bourne shell

<<[[main()]] initialisation>>=
setvar("cflag", flag['c']? newword(flag['c'][0], (word *)nil) : (word *)nil);
@

\section{Failing fast: [[rc -e]]}


<<[[outcode()]] emit Xeflag after Xsimple>>=
if(eflag)
    emitf(Xeflag);
@

% super important actually, remember in recursive make 
% where a failure in a subsubdir should stop the entire thing. 
% Fortunately mk calls rc with -e so any error in a loop for 
% instance stop the whole thing
% (but not error  in   X || Y, nor error in if (X), etc, so
% need do eflag check only a certain places)

<<global [[eflagok]]>>=
bool eflagok;	/* kludge flag so that -e doesn't exit in startup */
@
% who sets that? execdot, execval

<<[[execdot()]] if not first execution>>=
else
    eflagok = true;
@

<<function [[Xeflag]]>>=
void
Xeflag(void)
{
    if(eflagok && !truestatus()) 
        Xexit();
}
@

% exit at first error!
% kind of a 'use strict;' :)

% very useful

\section{Unicode}

<<function [[addutf]]>>=
char*
addutf(char *p, int c)
{
    uchar b, m;
    int i;

    p = addtok(p, c);	/* 1-byte UTF runes are special */
    if(c < Runeself)
        return p;

    m = 0xc0;
    b = 0x80;
    for(i=1; i < UTFmax; i++){
        if((c&m) == b)
            break;
        p = addtok(p, advance());
        b = m;
        m = (m >> 1)|0x80;
    }
    return p;
}
@

\section{Advanced constructs}



\subsection{Subshell: [[@ <cmd>]]}

% why need that? () not enough? { } not enough?
% no because side effect done in { } will be propagated, e.g., cd!
% any side effect in command such as setting variables will not be seen 
% in parent process.

% see mkfile for plan9:
%.directories:V:
%	for(i in $DIRS) @{
%		cd $i
%		echo $i/
%		mk $MKFLAGS $stem
%	}
\t also why -e does not work here!! does not stop!! because in subshell?


<<token declarations>>=
%token SUBSHELL /** @ */
@

% @ xxx
<<cmd rule other cases>>=
|   SUBSHELL cmd        {$$=mung1($1, $2);}
@


<<[[outcode()]] cases>>=
case SUBSHELL:
    emitf(Xsubshell);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    if(eflag)
        emitf(Xeflag);
    break;
@

% * Xsubshell{... Xexit}		execute {} in a subshell and wait


<<function [[Xsubshell]]>>=
void
Xsubshell(void)
{
    int pid;
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        start(runq->code, runq->pc+1, runq->local);
        runq->ret = nil;
        break;
    default: // parent
        addwaitpid(pid);
        Waitfor(pid, 1);
        runq->pc = runq->code[runq->pc].i;
        break;
    }
}
@


%in rcsh, the code is Updenv() before ForkExecute() because
% they do not rely on a fork that will have the same process image
% in which runq->local will contain the local values of variables,
% so they need first to modify the environment with Updenv() before
% executing.

\subsection{Here documents: [[<< <HERE>]]}
% >>

%history: also in bourne shell

% when write script, and uses data, convenient embed data
% directly in script, so no external file deps.
%ocaml: I do the same sometimes in GUI for some resources like icons

% again spirit of interactive REPL. enter data from command line.
% Yes, but more importantly, ancestor of Bundle! Prog and data
% in one file. Can have a script with a database (see example
% of 'tel' command in Bourne paper) included in the file.
% can mv around the script. no problem.

<<constant [[HERE]]>>=
#define	HERE	4
@

<<[[yylex()]] in switch when redirection character, if here document>>=
if(nextis(c)){
    t->rtype = HERE;
    *w++=c;
}
@
\t mv c to '<' ?

<<struct [[Here]]>>=
struct Here {
    tree	*tag;
    char	*name;
    struct Here *next;
};
@

<<global [[here]]>>=
struct Here *here;
@


<<global [[ehere]]>>=
struct Here **ehere;
@


<<constant [[NLINE]]>>=
/*
 * bug: lines longer than NLINE get split -- this can cause spurious
 * missubstitution, or a misrecognized EOF marker.
 */
#define	NLINE	4096
@


<<[[compile()]] after outcode and error management, read heredoc>>=
readhere();
@

<<function [[readhere]]>>=
void
readhere(void)
{
    int c, subst;
    char *s, *tag;
    char line[NLINE+1];
    io *f;
    struct Here *h, *nexth;

    for(h = here; h; h = nexth){
        subst = !h->tag->quoted;
        tag = h->tag->str;
        c = Creat(h->name);
        if(c < 0)
            yyerror("can't create here document");
        f = openfd(c);
        s = line;
        pprompt();
        while((c = rchr(runq->cmdfd)) != EOF){
            if(c == '\n' || s == &line[NLINE]){
                *s = '\0';
                if(tag && strcmp(line, tag) == 0)
                    break;
                if(subst)
                    psubst(f, (uchar *)line);
                else
                    pstr(f, line);
                s = line;
                if(c == '\n'){
                    pprompt();
                    pchr(f, c);
                }else
                    *s++ = c;
            }else
                *s++ = c;
        }
        flush(f);
        closeio(f);
        cleanhere(h->name);
        nexth = h->next;
        efree((char *)h);
    }
    here = nil;
    doprompt = true;
}
@


<<function [[cleanhere]]>>=
void
cleanhere(char *f)
{
    emitf(Xdelhere);
    emits(strdup(f));
}
@

<<function [[Xdelhere]]>>=
void
Xdelhere(void)
{
    Unlink(runq->code[runq->pc++].s);
}
@

<<function [[Unlink]]>>=
void
Unlink(char *name)
{
    remove(name);
}
@




<<global [[ser]]>>=
int ser = 0;
@

<<global tmp (rc/here.c)>>=
char tmp[] = "/tmp/here0000.0000";
@

<<global [[hex]]>>=
char hex[] = "0123456789abcdef";
@

<<function [[hexnum]]>>=
void
hexnum(char *p, int n)
{
    *p++ = hex[(n>>12)&0xF];
    *p++ = hex[(n>>8)&0xF];
    *p++ = hex[(n>>4)&0xF];
    *p = hex[n&0xF];
}
@

<<function [[heredoc]]>>=
//@Scheck: used by syn.y
tree* heredoc(tree *tag)
{
    struct Here *h = new(struct Here);

    if(tag->type != WORD)
        yyerror("Bad here tag");
    h->next = 0;
    if(here)
        *ehere = h;
    else
        here = h;
    ehere = &h->next;
    h->tag = tag;
    hexnum(&tmp[9], getpid());
    hexnum(&tmp[14], ser++);
    h->name = strdup(tmp);
    return token(tmp, WORD);
}
@


<<function [[psubst]]>>=
void
psubst(io *f, uchar *s)
{
    int savec, n;
    uchar *t, *u;
    Rune r;
    word *star;

    while(*s){
        if(*s != '$'){		/* copy plain text rune */
            if(*s < Runeself)
                pchr(f, *s++);
            else{
                n = chartorune(&r, (char *)s);
                while(n-- > 0)
                    pchr(f, *s++);
            }
        }else{			/* $something -- perform substitution */
            t = ++s;
            if(*t == '$')
                pchr(f, *t++);
            else{
                while(*t && idchr(*t))
                    t++;
                savec = *t;
                *t = '\0';
                n = 0;
                for(u = s; *u && '0' <= *u && *u <= '9'; u++)
                    n = n*10 + *u - '0';
                if(n && *u == '\0'){
                    star = vlook("*")->val;
                    if(star && 1 <= n && n <= count(star)){
                        while(--n)
                            star = star->next;
                        pstr(f, star->word);
                    }
                }else
                    pstrs(f, vlook((char *)s)->val);
                *t = savec;
                if(savec == '^')
                    t++;
            }
            s = t;
        }
    }
}
@
%$

<<function [[pstrs]]>>=
void
pstrs(io *f, word *a)
{
    if(a){
        while(a->next && a->next->word){
            pstr(f, a->word);
            pchr(f, ' ');
            a = a->next;
        }
        pstr(f, a->word);
    }
}
@

\subsection{Read-write redirections: [[<> <file>]]}

<<constant [[RDWR]]>>=
#define RDWR	7
@


<<[[yylex()]] in switch when redirection character, if read/write redirect>>=
else if (nextis('>')){
    t->rtype = RDWR;
    *w++=c;
}
@

<<[[outcode()]] when REDIR case, switch redirection type cases>>=
case RDWR:
    emitf(Xrdwr);
    break;
@

<<function [[Xrdwr]]>>=
void
Xrdwr(void)
{
    char *file;
    int f;

    switch(count(runq->argv->words)){
    default:
        Xerror1("<> requires singleton\n");
        return;
    case 0:
        Xerror1("<> requires file\n");
        return;
    case 1:
        break;
    }
    file = runq->argv->words->word;
    if((f = open(file, ORDWR))<0){
        pfmt(err, "%s: ", file);
        Xerror("can't open");
        return;
    }
    pushredir(ROPEN, f, runq->code[runq->pc].i);
    runq->pc++;
    poplist();
}
@


\subsection{General redirections: [[>[2] <file>]]}
\label{sec:advanced-redirection}

% fancy lexing redirect, see rc manual

% Lexing

<<[[yylex()]] in switch when redirection character, if bracket after>>=
if(nextis('[')){
    *w++='[';
    c = advance();
    *w++=c;
    if(c<'0' || '9'<c){
    RedirErr:
        *w = 0;
        yyerror(t->type==PIPE?"pipe syntax"
                :"redirection syntax");
        return EOF;
    }
    t->fd0 = 0;
    do{
        t->fd0 = t->fd0*10 + c-'0';
        *w++=c;
        c = advance();
    }while('0'<=c && c<='9');

    if(c=='='){
        *w++='=';
        if(t->type==REDIR)
            // change the token type
            t->type = DUP;
        c = advance();
        if('0'<=c && c<='9'){
            t->rtype = DUPFD;
            t->fd1 = t->fd0;
            t->fd0 = 0;
            do{
                t->fd0 = t->fd0*10+c-'0';
                *w++=c;
                c = advance();
            }while('0'<=c && c<='9');
        }
        else{
            if(t->type==PIPE)
                goto RedirErr;
            t->rtype = CLOSE;
        }
    }
    if(c!=']'
    || t->type==DUP && (t->rtype==HERE || t->rtype==APPEND))
        goto RedirErr;
    *w++=']';
}
@


<<constant [[CLOSE]]>>=
#define	CLOSE	6
@


\subsection{Advanced dup: [[>[<fd0>=<fd1>]] ], [[<>[<fd0>=<fd1>] ]], [[<[<fd0>=<fd1>] ]]}

% so can print on stderr with echo in kmem.rc:
%	echo 'usage: kmem [kernel]' >[1=2]

<<token declarations>>=
%token DUP
@

<<redir rule other cases>>=
|   DUP
@
% does not take any word


<<constant [[DUPFD]]>>=
#define	DUPFD	5
@



<<[[outcode()]] cases>>=
case DUP:
    if(t->rtype==DUPFD){
        emitf(Xdup);
        emiti(t->fd0);
        emiti(t->fd1);
    }
    else{
        emitf(Xclose);
        emiti(t->fd0);
    }
    outcode(c1, eflag);
    emitf(Xpopredir);
    break;
@

<<function [[Xdup]]>>=
void
Xdup(void)
{
    pushredir(RDUP, runq->code[runq->pc].i, runq->code[runq->pc+1].i);
    runq->pc+=2;
}
@

<<[[codefree()]] in loop over code [[cp]], switch bytecode cases>>=
else if(p->f==Xdup || p->f==Xpipefd) 
         p+=2;
@


<<constant [[RDUP]]>>=
#define	RDUP	2			/* dup2(from, to); */
@


<<constant [[RCLOSE]]>>=
#define	RCLOSE	3			/* close(from); */
@

<<function [[Xclose]]>>=
void
Xclose(void)
{
    pushredir(RCLOSE, runq->code[runq->pc].i, 0);
    runq->pc++;
}
@


<<[[doredir()]] switch redir type cases>>=
case RDUP:
    Dup(rp->from, rp->to);
    break;
@

<<[[doredir()]] switch redir type cases>>=
case RCLOSE:
    close(rp->from);
    break;
@



\subsection{Advanced pipes: [[|[<fd>] ]], [[|[<fd0>=<fd1>] ]]}

% see man/1/rc:



\subsection{Command output as a file: \texttt{'<\{<cmd>\}'}}

<<comword rule other cases>>=
|   REDIR brace     {$$=mung1($1, $2); $$->type=PIPEFD;}
@

% see man/1/rc:
% cmp <{old} <{new}

% it is in comword rule because really it resolved in a filename
% to /dev/fd/xxx connected to output of command.


<<token declarations>>=
%token PIPEFD 
@

% * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output,
% * 					depending on type), push /dev/fd/??

<<[[outcode()]] cases>>=
case PIPEFD:
    emitf(Xpipefd);
    emiti(t->rtype);
    p = emiti(0);
    outcode(c0, eflag);
    emitf(Xexit);
    stuffdot(p);
    break;
@



<<global [[Fdprefix]]>>=
char *Fdprefix = "/fd/";
@

<<function [[Xpipefd]]>>=
void
Xpipefd(void)
{
    struct Thread *p = runq;
    int pc = p->pc, pid;
    char name[40];
    int pfd[2];
    int sidefd, mainfd;
    if(pipe(pfd)<0){
        Xerror("can't get pipe");
        return;
    }
    if(p->code[pc].i==READ){
        sidefd = pfd[PWR];
        mainfd = pfd[PRD];
    }
    else{
        sidefd = pfd[PRD];
        mainfd = pfd[PWR];
    }
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        break;
    case 0: // child
        clearwaitpids();
        start(p->code, pc+2, runq->local);
        close(mainfd);
        pushredir(ROPEN, sidefd, p->code[pc].i==READ?1:0);
        runq->ret = 0;
        break;
    default: // parent
        addwaitpid(pid);
        close(sidefd);
        pushredir(ROPEN, mainfd, mainfd);	/* isn't this a noop? */
        strcpy(name, Fdprefix);
        inttoascii(name+strlen(name), mainfd);
        pushword(name);
        p->pc = p->code[pc+1].i;
        break;
    }
}
@



\subsection{Command substitution: \texttt{`\{<cmd>\}}}
% Command output as arguments

% just like easy to run command, pretty easy to capture output
% of command in a var. Natural extension.
%history: also in bourne shell

% by using `{} instead of ``
% it allows to easily nest (see Design chapter in rc paper).

<<comword rule other cases>>=
|   '`' brace       {$$=tree1('`', $2);}
@
%$
% rc use the `{} syntax for backquote (See Make.nw)


<<[[outcode()]] cases>>=
case '`':
    emitf(Xbackq);
    p = emiti(0);
    outcode(c0, false);
    emitf(Xexit);
    stuffdot(p);
    break;
@
% false eflag here

% * Xbackq{... Xreturn}			make thread for {}, push stdout

<<function [[Xbackq]]>>=
/*
 * Who should wait for the exit from the fork?
 */
void
Xbackq(void)
{
    int n, pid;
    int pfd[2];
    char *stop;
    char utf[UTFmax+1];
    struct Io *f;
    var *ifs = vlook("ifs");
    word *v, *nextv;
    Rune r;
    String *word;

    stop = ifs->val? ifs->val->word: "";
    if(pipe(pfd)<0){
        Xerror("can't make pipe");
        return;
    }
    switch(pid = fork()){
    case -1:
        Xerror("try again");
        close(pfd[PRD]);
        close(pfd[PWR]);
        return;
    case 0: // child
        clearwaitpids();
        close(pfd[PRD]);
        start(runq->code, runq->pc+1, runq->local);
        pushredir(ROPEN, pfd[PWR], 1);
        return;
    default: // parent
        addwaitpid(pid);
        close(pfd[PWR]);
        f = openfd(pfd[PRD]);
        word = s_new();
        v = nil;
        /* rutf requires at least UTFmax+1 bytes in utf */
        while((n = rutf(f, utf, &r)) != EOF){
            utf[n] = '\0';
            if(utfutf(stop, utf) == nil)
                s_nappend(word, utf, n);
            else
                /*
                 * utf/r is an ifs rune (e.g., \t, \n), thus
                 * ends the current word, if any.
                 */
                if(s_len(word) > 0){
                    v = newword(s_to_c(word), v);
                    s_reset(word);
                }
        }
        if(s_len(word) > 0)
            v = newword(s_to_c(word), v);
        s_free(word);
        closeio(f);
        Waitfor(pid, 0);
        /* v points to reversed arglist -- reverse it onto argv */
        while(v){
            nextv = v->next;
            v->next = runq->argv->words;
            runq->argv->words = v;
            v = nextv;
        }
        runq->pc = runq->code[runq->pc].i;
        return;
    }
}
@



\subsection{Stringification of variables: [[$"<foo>]]} %$

<<comword rule other cases>>=
|   '"' word        {$$=tree1('"', $2);}
@
%$
% no ending "? No, it is used for stringification of a variable.
% a list2str.

<<[[outcode()]] cases>>=
case '"':
    emitf(Xmark);
    outcode(c0, eflag);
    emitf(Xqdol);
    break;
@


<<function [[Xqdol]]>>=
void
Xqdol(void)
{
    word *a, *p;
    char *s;
    int n;
    if(count(runq->argv->words)!=1){
        Xerror1("variable name not singleton!");
        return;
    }
    s = runq->argv->words->word;
    deglob(s);
    a = vlook(s)->val;
    poplist();
    n = count(a);
    if(n==0){
        pushword("");
        return;
    }
    for(p = a;p;p = p->next) n+=strlen(p->word);
    s = emalloc(n);
    if(a){
        strcpy(s, a->word);
        for(p = a->next;p;p = p->next){
            strcat(s, " ");
            strcat(s, p->word);
        }
    }
    else
        s[0]='\0';
    pushword(s);
    efree(s);
}
@


\section{Advanced builtins}

% could have echo here. and test. but true that they can also
% be external programs.

% has read? How can you read from a script?

\subsection{[[$ exec]]}
%$

% actually called from Xsimple()
% but it complicates the code.
% I was not sure you really need that builtin, but
% many scripts use it.


\subsection{[[$ whatis]]}
%$

<<function [[execwhatis]]>>=
void
execwhatis(void){   /* mildly wrong -- should fork before writing */
    word *a, *b, *path;
    var *v;
    struct Builtin *bp;
    char *file;
    struct Io out[1];
    int found, sep;
    a = runq->argv->words->next;
    if(a==0){
        Xerror1("Usage: whatis name ...");
        return;
    }
    setstatus("");
    memset(out, 0, sizeof out);
    out->fd = mapfd(1);
    out->bufp = out->buf;
    out->ebuf = &out->buf[NBUF];
    out->strp = nil;
    for(;a;a = a->next){
        v = vlook(a->word);
        if(v->val){
            pfmt(out, "%s=", a->word);
            if(v->val->next==0)
                pfmt(out, "%q\n", v->val->word);
            else{
                sep='(';
                for(b = v->val;b && b->word;b = b->next){
                    pfmt(out, "%c%q", sep, b->word);
                    sep=' ';
                }
                pfmt(out, ")\n");
            }
            found = 1;
        }
        else
            found = 0;
        v = gvlook(a->word);
        if(v->fn)
            pfmt(out, "fn %q %s\n", v->name, v->fn[v->pc-1].s);
        else{
            for(bp = builtins;bp->name;bp++)
                if(strcmp(a->word, bp->name)==0){
                    pfmt(out, "builtin %s\n", a->word);
                    break;
                }
            if(!bp->name){
                for(path = searchpath(a->word); path;
                    path = path->next){
                    if(path->word[0] != '\0')
                        file = appfile(path->word, a->word);
                    else
                        file = strdup(a->word);
                    if(Executable(file)){
                        pfmt(out, "%s\n", file);
                        free(file);
                        break;
                    }
                    free(file);
                }
                if(!path && !found){
                    pfmt(err, "%s: not found\n", a->word);
                    setstatus("not found");
                }
            }
        }
    }
    poplist();
    flush(err);
}
@

<<function [[mapfd]]>>=
int
mapfd(int fd)
{
    redir *rp;
    for(rp = runq->redir;rp;rp = rp->next){
        switch(rp->type){
        case RCLOSE:
            if(rp->from==fd)
                fd=-1;
            break;
        case RDUP:
        case ROPEN:
            if(rp->to==fd)
                fd = rp->from;
            break;
        }
    }
    return fd;
}
@


<<function [[Executable]]>>=
bool
Executable(char *file)
{
    Dir *statbuf;
    bool ret;

    statbuf = dirstat(file);
    if(statbuf == nil)
        return false;
    ret = ((statbuf->mode&0111)!=0 && (statbuf->mode&DMDIR)==0);
    free(statbuf);
    return ret;
}
@



\subsection{[[$ rfork]]}
%$

%rfork
<<function [[execnewpgrp]]>>=
void
execnewpgrp(void)
{
    int arg;
    char *s;
    switch(count(runq->argv->words)){
    case 1:
        arg = RFENVG|RFNAMEG|RFNOTEG;
        break;
    case 2:
        arg = 0;
        for(s = runq->argv->words->next->word;*s;s++) switch(*s){
        default:
            goto Usage;
        case 'n':
            arg|=RFNAMEG;  break;
        case 'N':
            arg|=RFCNAMEG;
            break;
        case 'm':
            arg|=RFNOMNT;  break;
        case 'e':
            arg|=RFENVG;   break;
        case 'E':
            arg|=RFCENVG;  break;
        case 's':
            arg|=RFNOTEG;  break;
        case 'f':
            arg|=RFFDG;    break;
        case 'F':
            arg|=RFCFDG;   break;
        }
        break;
    default:
    Usage:
        pfmt(err, "Usage: %s [fnesFNEm]\n", runq->argv->words->word);
        setstatus("rfork usage");
        poplist();
        return;
    }
    if(rfork(arg)==-1){
        pfmt(err, "rc: %s failed\n", runq->argv->words->word);
        setstatus("rfork failed");
    }
    else
        setstatus("");
    poplist();
}
@

\subsection{[[$ flag]]}
%$

<<function [[execflag]]>>=
void
execflag(void)
{
    char *letter, *val;

    switch(count(runq->argv->words)){
    case 2:
        setstatus(flag[(uchar)runq->argv->words->next->word[0]]?"":"flag not set");
        break;
    case 3:
        letter = runq->argv->words->next->word;
        val = runq->argv->words->next->next->word;
        if(strlen(letter)==1){
            if(strcmp(val, "+")==0){
                flag[(uchar)letter[0]] = flagset;
                break;
            }
            if(strcmp(val, "-")==0){
                flag[(uchar)letter[0]] = 0;
                break;
            }
        }
    default:
        Xerror1("Usage: flag [letter] [+-]");
        return;
    }
    poplist();
}
@

\subsection{[[$ shift]]}
%$

<<function [[execshift]]>>=
void
execshift(void)
{
    int n;
    word *a;
    var *star;
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: shift [n]\n");
        setstatus("shift usage");
        poplist();
        return;
    case 2:
        n = atoi(runq->argv->words->next->word);
        break;
    case 1:
        n = 1;
        break;
    }
    star = vlook("*");
    for(;n && star->val;--n){
        a = star->val->next;
        efree(star->val->word);
        efree((char *)star->val);
        star->val = a;
        star->changed = true;
    }
    setstatus("");
    poplist();
}
@


\subsection{[[$ finit]]}
%$

<<global [[rdfns]]>>=
union Code rdfns[4];
@

% "finit" builtin -> <>
<<function [[execfinit]]>>=
void
execfinit(void)
{
    static bool first = true;
    if(first){
        rdfns[0].i = 1;
        rdfns[1].f = Xrdfn;
        rdfns[2].f = Xjump;
        rdfns[3].i = 1;
        first = false;
    }
    Xpopm(); // pop_list()
    envdir = open("/env", 0);
    if(envdir<0){
        pfmt(err, "rc: can't open /env: %r\n");
        return;
    }
    start(rdfns, 1, runq->local);
}
@
\l should call pop_list(), not Xpopm

% really need that? nice that enclosing script
% can define function that can be used in callee
% bug could also do it by using '.'
<<function [[Xrdfn]]>>=
void
Xrdfn(void)
{
    int f, len;
    Dir *e;
    char envname[Maxenvname];
    static Dir *ent, *allocent;
    static int nent;

    for(;;){
        if(nent == 0){
            free(allocent);
            nent = dirread(envdir, &allocent);
            ent = allocent;
        }
        if(nent <= 0)
            break;
        while(nent){
            e = ent++;
            nent--;
            len = e->length;
            if(len && strncmp(e->name, "fn#", 3)==0){
                snprint(envname, sizeof envname, "/env/%s", e->name);
                if((f = open(envname, 0))>=0){
                    execcmds(openfd(f));
                    return;
                }
            }
        }
    }
    close(envdir);
    Xreturn();
}
@



\chapter{Conclusion}
\label{chap:conclusion}

% connection to other books:
% Lex and Yacc to understand what is generated from grammar files. 
% Kernel to understand what is behind fork, exec, wait, chdir.
% Compiler for deeper.

% future work:more interactive! need readline.
% However, many of those features are covered by rio's terminals:

%  - interactive filename completion with TAB (readline, need raw mode)
%    (but apparently rio has some support for it)
%  - command completion with TAB
%  - history with arrow keys
%    (rio has kinda, just go up in the window and copy paste)
%  - history search (C-r)
%  - aliases 
%    (just use fn and saves them somewhere so persistent)
%  - pushd/popd (but could be functions?)
%  - job control (bg, fg)
%    (but can do  'wait $apid')
%  - C-z??? bourne says early-sh had 'wait is interruptible'
%  - fish features!


\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

\section{AST dumper}

% used only for saving functions in the env for now, so could
%  be moved earlier.

% pcmd.c

<<global [[nl]]>>=
char nl='\n';		/* change to semicolon for bourne-proofing */
@

% TODO ugly and dupe with the one in code.c
<<constant [[c0]]>>=
#define	c0	t->child[0]
@

<<constant [[c1]]>>=
#define	c1	t->child[1]
@

<<constant [[c2]]>>=
#define	c2	t->child[2]
@

% simplemung | fnstr -> pfmt %t -> <>
<<function [[pcmd]]>>=
void
pcmd(io *f, tree *t)
{
    if(t==nil)
        return;
    assert(f != nil);

    switch(t->type){
    case '$':	pfmt(f, "$%t", c0); break;
    case '"':	pfmt(f, "$\"%t", c0); break;
    case '&':	pfmt(f, "%t&", c0); break;
    case '^':	pfmt(f, "%t^%t", c0, c1); break;
    case '`':	pfmt(f, "`%t", c0); break;
    case ANDAND:pfmt(f, "%t && %t", c0, c1); break;
    case OROR:	pfmt(f, "%t || %t", c0, c1); break;
    case BANG:	pfmt(f, "! %t", c0); break;
    case BRACE:	pfmt(f, "{%t}", c0); break;
    case COUNT:	pfmt(f, "$#%t", c0); break;
    case FN:	pfmt(f, "fn %t %t", c0, c1); break;
    case IF:	pfmt(f, "if%t%t", c0, c1); break;
    case NOT:	pfmt(f, "if not %t", c0); break;
    case PCMD:
    case PAREN:	pfmt(f, "(%t)", c0); break;
    case SUB:	pfmt(f, "$%t(%t)", c0, c1); break;
    case SIMPLE:	pfmt(f, "%t", c0); break;
    case SUBSHELL:	pfmt(f, "@ %t", c0); break;
    case SWITCH:	pfmt(f, "switch %t %t", c0, c1); break;
    case TWIDDLE:	pfmt(f, "~ %t %t", c0, c1); break;
    case WHILE:		pfmt(f, "while %t%t", c0, c1); break;

    case ARGLIST:
        if(c0==nil)
            pfmt(f, "%t", c1);
        else if(c1==nil)
            pfmt(f, "%t", c0);
        else
            pfmt(f, "%t %t", c0, c1);
        break;
    case ';':
        if(c0){
            if(c1)
                pfmt(f, "%t%c%t", c0, nl, c1);
            else pfmt(f, "%t", c0);
        }
        else pfmt(f, "%t", c1);
        break;
    case WORDS:
        if(c0)
            pfmt(f, "%t ", c0);
        pfmt(f, "%t", c1);
        break;
    case FOR:
        pfmt(f, "for(%t", c0);
        if(c1)
            pfmt(f, " in %t", c1);
        pfmt(f, ")%t", c2);
        break;
    case WORD:
        if(t->quoted)
            pfmt(f, "%Q", t->str);
        else pdeglob(f, t->str);
        break;
    case DUP:
        if(t->rtype==DUPFD)
            pfmt(f, ">[%d=%d]", t->fd1, t->fd0); /* yes, fd1, then fd0; read lex.c */
        else
            pfmt(f, ">[%d=]", t->fd0);
        pfmt(f, "%t", c1);
        break;
    case PIPEFD:
    case REDIR:
        switch(t->rtype){
        case HERE:
            pchr(f, '<');
        case READ:
        case RDWR:
            pchr(f, '<');
            if(t->rtype==RDWR)
                pchr(f, '>');
            if(t->fd0!=0)
                pfmt(f, "[%d]", t->fd0);
            break;
        case APPEND:
            pchr(f, '>');
        case WRITE:
            pchr(f, '>');
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
            break;
        }
        pfmt(f, "%t", c0);
        if(c1)
            pfmt(f, " %t", c1);
        break;
    case '=':
        pfmt(f, "%t=%t", c0, c1);
        if(c2)
            pfmt(f, " %t", c2);
        break;
    case PIPE:
        pfmt(f, "%t|", c0);
        if(t->fd1==0){
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
        }
        else pfmt(f, "[%d=%d]", t->fd0, t->fd1);
        pfmt(f, "%t", c1);
        break;

    default:	
        pfmt(f, "bad cmd %d %p %p %p", t->type, c0, c1, c2);
        break;
    }
}
@
%$

% pcmd -> <>
<<function [[pdeglob]]>>=
void
pdeglob(io *f, char *s)
{
    while(*s){
        if(*s==GLOB)
            s++;
        pchr(f, *s++);
    }
}
@




\section{Bytecode generator trace: [[rc -r]]}
\label{sec:rc-r}
% also trace threads

% nice output:

%  % ls
%  pid 20834 cycle 00007F7FF3F00400 1 Xmark
%  pid 20834 cycle 00007F7FF3F00400 2 Xword ()
%  pid 20834 cycle 00007F7FF3F00400 4 Xsimple (ls)
%  CHANGES       LICENSE	TODO  config	 dist  include	    install.txt  lp    man   plumb	 rcmain  tmac
%  CONTRIBUTORS  Makefile	acid  configure  face  install.log  lib		 mac   ndb   postscript  sky	 troff
%  INSTALL       README	bin   dict	 font  install.sum  log		 mail  news  proto	 src	 unix
%  pid 20834 cycle 00007F7FF3F00400 5 Xreturn
%  pid 20834 cycle 000000010E241DB0 9 Xrdcmds

% useful to debug compile(), interpreter, pids, etc.

<<[[main()]] debug runq in interpreter loop>>=
if(flag['r'])
    pfnc(err, runq);
@

% pfnc.c
<<global [[fname]]>>=
struct{
    void	(*f)(void);
    char	*name;
} fname[] = {
    Xappend, "Xappend",
    Xassign, "Xassign",
    Xasync, "Xasync",
    Xbackq, "Xbackq",
    Xbang, "Xbang",
    Xcase, "Xcase",
    Xclose, "Xclose",
    Xconc, "Xconc",
    Xcount, "Xcount",
    Xdelfn, "Xdelfn",
    Xdelhere, "Xdelhere",
    Xdol, "Xdol",
    Xdup, "Xdup",
    Xeflag, "Xeflag",
    (void (*)(void))Xerror, "Xerror",
    Xexit, "Xexit",
    Xfalse, "Xfalse",
    Xfn, "Xfn",
    Xfor, "Xfor",
    Xglob, "Xglob",
    Xif, "Xif",
    Xifnot, "Xifnot",
    Xjump, "Xjump",
    Xlocal, "Xlocal",
    Xmark, "Xmark",
    Xmatch, "Xmatch",
    Xpipe, "Xpipe",
    Xpipefd, "Xpipefd",
    Xpipewait, "Xpipewait",
    Xpopm, "Xpopm",
    Xpopredir, "Xpopredir",
    Xqdol, "Xqdol",
    Xrdcmds, "Xrdcmds",
    Xrdfn, "Xrdfn",
    Xrdwr, "Xrdwr",
    Xread, "Xread",
    Xreturn, "Xreturn",
    Xsimple, "Xsimple",
    Xsub, "Xsub",
    Xsubshell, "Xsubshell",
    Xtrue, "Xtrue",
    Xunlocal, "Xunlocal",
    Xwastrue, "Xwastrue",
    Xword, "Xword",
    Xwrite, "Xwrite",
    0
};
@

% fnc??
% called from main interpreter loop, also called from pfmt %?
<<function [[pfnc]]>>=
void
pfnc(io *fd, thread *t)
{
    int i;
    void (*fn)(void) = t->code[t->pc].f;
    list *a;

    pfmt(fd, "pid %d cycle %p %d ", getpid(), t->code, t->pc);
    for (i = 0; fname[i].f; i++) 
        if (fname[i].f == fn) {
            pstr(fd, fname[i].name);
            break;
        }
    if (!fname[i].f)
        pfmt(fd, "%p", fn);
    for (a = t->argv; a; a = a->next) 
        pfmt(fd, " (%v)", a->words);
    pchr(fd, '\n');
    flush(fd);
}
@
% %v below

\section{Printing subprocesses status: [[rc -s]]}
% debugging feature or general feature used by people?

<<[[Xrdcmds()]] print status if -s>>=
if(flag['s'] && !truestatus())
    pfmt(err, "status=%v\n", vlook("status")->val);
@
% %v? nil or list of strings?
% why not call getstatus()?

\section{Printing commands: [[rc -x]]}

%history: also in bourne shell, to print final command after
% substitution

<<[[Xsimple()]] if -x>>=
if(flag['x'])
    pfmt(err, "%v\n", p->argv->words); /* wrong, should do redirs */
@

\section{Printing characters: [[rc -v]]}

% ndot for not printing the characters procssed from a . (e.g. . rcmain)
<<[[getnext()]] if not EOF but verbose mode, print character read>>=
else 
    if(flag['V'] || ndot>=2 && flag['v'])
        pchr(err, c);
@


\section{Printing all characters: [[rc -V]]}

% so get also the content of the rcmain

\chapter{Error Management}
\label{chap:error}

<<constant [[ERRMAX]]>>=
#define ERRMAX 128
@

<<global [[err]]>>=
io *err;
@

<<global [[nerror]]>>=
int nerror;		/* number of errors encountered during compilation */
@

<<[[Xrdcmds()]] flush errors and reset error count>>=
flush(err);
nerror = 0;
@

% from yylex() (and also yyparse)
<<function [[yyerror]]>>=
void
yyerror(char *m)
{
    pfmt(err, "rc: ");
    if(runq->cmdfile && !runq->iflag)
        pfmt(err, "%s:%d: ", runq->cmdfile, runq->lineno);
    else if(runq->cmdfile)
        pfmt(err, "%s: ", runq->cmdfile);
    else if(!runq->iflag)
        pfmt(err, "line %d: ", runq->lineno);

    if(tok[0] && tok[0]!='\n')
        pfmt(err, "token %q: ", tok);
    pfmt(err, "%s\n", m);
    flush(err);
    lastword = false;
    lastdol = false;

    while(lastc!='\n' && lastc!=EOF) 
        advance();

    nerror++;
    setvar("status", newword(m, (word *)nil));
}
@
\t %q?
\t could use setstatus()

% future, peekc, lastc, hmmm
<<global [[lastc]]>>=
int lastc;
@
% who uses that? yyerror

<<[[advance()]] save future in lastc>>=
lastc = future;
@

% internal error, no more memory, etc, called from many places
<<function [[panic]]>>=
void
panic(char *s, int n)
{
    pfmt(err, "rc: ");
    pfmt(err, s, n);
    pchr(err, '\n');
    flush(err);
    Abort();
}
@

% just called from panic(), so could be inlined there
<<function [[Abort]]>>=
void
Abort(void)
{
    pfmt(err, "aborting\n");
    flush(err);
    Exit("aborting");
}
@

% called from a few places, including Xexit
<<function [[Exit]]>>=
void
Exit(char *stat)
{
    Updenv();
    setstatus(stat);
    exits(truestatus() ? "" : getstatus());
}
@


\chapter{Utilities}
\label{chap:utilities}

<<function [[_efgfmt]]>>=
/* avoid loading any floating-point library code */
//@Scheck: weird, probably linker trick
int _efgfmt(Fmt *)
{
    return -1;
}
@

\section{Memory management}

%#define	new(type)	((type *)emalloc(sizeof(type)))

<<function [[emalloc]]>>=
void *
emalloc(long n)
{
    void *p = Malloc(n);

    if(p==nil)
        panic("Can't malloc %d bytes", n);
    return p;
}
@
%old: /*	if(err){ pfmt(err, "malloc %d->%p\n", n, p); flush(err); } /**/
%ocaml: use Gc.

% plan9
<<function [[Malloc]]>>=
void*
Malloc(ulong n)
{
    return mallocz(n, 1);
}
@


<<function [[efree]]>>=
void
efree(void *p)
{
    if(p)
        free(p);
    else pfmt(err, "free 0\n");
}
@
%old: /*	pfmt(err, "free %p\n", p); flush(err); /**/
% nice trick the /**/ at the end :) but can also simply use //

\section{Command-line arguments}
%: [[getflags()]]
% getopt

%ocaml: use Arg.ml

% why not use ARGBEGIN/ARGEND? because getflags() is more powerful.

<<global [[cmdname]]>>=
char *cmdname;
@

<<global [[flagarg]]>>=
static char *flagarg="";
@




<<global [[reason]]>>=
static int reason;
@

<<constant [[RESET]]>>=
#define	RESET	1
@

<<constant [[FEWARGS]]>>=
#define	FEWARGS	2
@

<<constant [[FLAGSYN]]>>=
#define	FLAGSYN	3
@

<<constant [[BADFLAG]]>>=
#define	BADFLAG	4
@

<<global [[badflag]]>>=
static int badflag;
@

<<function [[getflags]]>>=
int
getflags(int argc, char *argv[], char *flags, int stop)
{
    char *s;
    int i, j, c, count;
    flagarg = flags;
    if(cmdname==0)
        cmdname = argv[0];

    i = 1;
    while(i!=argc){
        if(argv[i][0] != '-' || argv[i][1] == '\0'){
            if(stop)		/* always true in rc */
                return argc;
            i++;
            continue;
        }
        s = argv[i]+1;
        while(*s){
            c=*s++;
            count = scanflag(c, flags);
            if(count==-1)
                return -1;
            if(flag[c]){ reason = RESET; badflag = c; return -1; }
            if(count==0){
                flag[c] = flagset;
                if(*s=='\0'){
                    for(j = i+1;j<=argc;j++)
                        argv[j-1] = argv[j];
                    --argc;
                }
            }
            else{
                if(*s=='\0'){
                    for(j = i+1;j<=argc;j++)
                        argv[j-1] = argv[j];
                    --argc;
                    s = argv[i];
                }
                if(argc-i<count){
                    reason = FEWARGS;
                    badflag = c;
                    return -1;
                }
                reverse(argv+i, argv+argc);
                reverse(argv+i, argv+argc-count);
                reverse(argv+argc-count+1, argv+argc);
                argc-=count;
                flag[c] = argv+argc+1;
                flag[c][0] = s;
                s="";
            }
        }
    }
    return argc;
}
@

<<function [[reverse]]>>=
static void
reverse(char **p, char **q)
{
    char *t;
    for(;p<q;p++,--q){ t=*p; *p=*q; *q = t; }
}
@

<<function [[scanflag]]>>=
static int
scanflag(int c, char *f)
{
    int fc, count;
    if(0<=c && c<NFLAG)
        while(*f){
            if(*f==' '){
                f++;
                continue;
            }
            fc=*f++;
            if(*f==':'){
                f++;
                if(*f<'0' || '9'<*f){ reason = FLAGSYN; return -1; }
                count = 0;
                while('0'<=*f && *f<='9') count = count*10+*f++-'0';
            }
            else
                count = 0;
            if(*f=='['){
                do{
                    f++;
                    if(*f=='\0'){ reason = FLAGSYN; return -1; }
                }while(*f!=']');
                f++;
            }
            if(c==fc)
                return count;
        }
    reason = BADFLAG;
    badflag = c;
    return -1;
}
@

<<function [[usage]]>>=
void
usage(char *tail)
{
    char *s, *t, c;
    int count, nflag = 0;
    switch(reason){
    case RESET:
        errs("Flag -");
        errc(badflag);
        errs(": set twice\n");
        break;
    case FEWARGS:
        errs("Flag -");
        errc(badflag);
        errs(": too few arguments\n");
        break;
    case FLAGSYN:
        errs("Bad argument to getflags!\n");
        break;
    case BADFLAG:
        errs("Illegal flag -");
        errc(badflag);
        errc('\n');
        break;
    }
    errs("Usage: ");
    errs(cmdname);
    for(s = flagarg;*s;){
        c=*s;
        if(*s++==' ')
            continue;
        if(*s==':'){
            s++;
            count = 0;
            while('0'<=*s && *s<='9') count = count*10+*s++-'0';
        }
        else count = 0;
        if(count==0){
            if(nflag==0)
                errs(" [-");
            nflag++;
            errc(c);
        }
        if(*s=='['){
            s++;
            while(*s!=']' && *s!='\0') s++;
            if(*s==']')
                s++;
        }
    }
    if(nflag)
        errs("]");
    for(s = flagarg;*s;){
        c=*s;
        if(*s++==' ')
            continue;
        if(*s==':'){
            s++;
            count = 0;
            while('0'<=*s && *s<='9') count = count*10+*s++-'0';
        }
        else count = 0;
        if(count!=0){
            errs(" [-");
            errc(c);
            if(*s=='['){
                s++;
                t = s;
                while(*s!=']' && *s!='\0') s++;
                errs(" ");
                errn(t, s-t);
                if(*s==']')
                    s++;
            }
            else
                while(count--) errs(" arg");
            errs("]");
        }
        else if(*s=='['){
            s++;
            while(*s!=']' && *s!='\0') s++;
            if(*s==']')
                s++;
        }
    }
    if(tail){
        errs(" ");
        errs(tail);
    }
    errs("\n");
    Exit("bad flags");
}
@

<<function [[errn]]>>=
static void
errn(char *s, int count)
{
    while(count){ errc(*s++); --count; }
}
@

<<function [[errs]]>>=
static void
errs(char *s)
{
    while(*s) errc(*s++);
}
@

<<constant NBUF (rc/getflags.c)>>=
#define	NBUF	80
@

<<global [[buf]]>>=
static char buf[NBUF];
@
<<global [[bufp]]>>=
static char *bufp = buf;
@

<<function [[errc]]>>=
static void
errc(int c)
{
    *bufp++=c;
    if(bufp==&buf[NBUF] || c=='\n'){
        Write(2, buf, bufp-buf);
        bufp = buf;
    }
}
@



\section{Buffered IO}
% again, reimplement the same thing

%ocaml: stdlib does that by default

<<constant [[NBUF]]>>=
#define	NBUF	512
@

<<struct [[Io]]>>=
struct Io {
    fdt	fd;
    byte	*bufp, *ebuf, *strp;
    byte	buf[NBUF];
};
@


<<function [[openfd]]>>=
io*
openfd(fdt fd)
{
    io *f = new(struct Io);
    f->fd = fd;
    f->bufp = f->ebuf = f->buf;
    f->strp = nil;
    return f;
}
@

<<enum [[MiscConstants]]>>=
enum { Stralloc = 100, };
@

<<function [[flush]]>>=
void
flush(io *f)
{
    int n;

    if(f->strp){
        n = f->ebuf - f->strp;
        f->strp = realloc(f->strp, n+Stralloc+1);
        if(f->strp==0)
            panic("Can't realloc %d bytes in flush!", n+Stralloc+1);
        f->bufp = f->strp + n;
        f->ebuf = f->bufp + Stralloc;
        memset(f->bufp, '\0', Stralloc+1);
    }
    else{
        n = f->bufp-f->buf;
        if(n && Write(f->fd, f->buf, n) != n){
            Write(2, "Write error\n", 12);
            if(ntrap)
                dotrap();
        }
        f->bufp = f->buf;
        f->ebuf = f->buf+NBUF;
    }
}
@

<<function [[pchr]]>>=
void
pchr(io *b, int c)
{
    if(b->bufp==b->ebuf)
        fullbuf(b, c);
    else *b->bufp++=c;
}
@

<<function [[fullbuf]]>>=
int
fullbuf(io *f, int c)
{
    flush(f);
    return *f->bufp++=c;
}
@


<<function [[rchr]]>>=
int
rchr(io *b)
{
    if(b->bufp==b->ebuf)
        return emptybuf(b);
    return *b->bufp++;
}
@

<<function [[emptybuf]]>>=
int
emptybuf(io *f)
{
    int n;
    if(f->fd==-1 || (n = Read(f->fd, f->buf, NBUF))<=0) return EOF;
    f->bufp = f->buf;
    f->ebuf = f->buf + n;
    return *f->bufp++;
}
@


<<function [[rutf]]>>=
int
rutf(io *b, char *buf, Rune *r)
{
    int n, i, c;

    c = rchr(b);
    if(c == EOF)
        return EOF;
    *buf = c;
    if(c < Runesync){
        *r = c;
        return 1;
    }
    for(i = 1; (c = rchr(b)) != EOF; ){
        buf[i++] = c;
        buf[i] = 0;
        if(fullrune(buf, i)){
            n = chartorune(r, buf);
            b->bufp -= i - n;	/* push back unconsumed bytes */
            assert(b->fd == -1 || b->bufp > b->buf);
            return n;
        }
    }
    /* at eof */
    b->bufp -= i - 1;			/* consume 1 byte */
    *r = Runeerror;
    return runetochar(buf, r);
}
@







<<function [[closeio]]>>=
void
closeio(io *io)
{
    if(io->fd>=0)
        close(io->fd);
    if(io->strp)
        efree(io->strp);
    efree(io);
}
@



<<function [[openstr]]>>=
io*
openstr(void)
{
    io *f = new(struct Io);

    f->fd = -1;
    f->bufp = f->strp = emalloc(Stralloc+1);
    f->ebuf = f->bufp + Stralloc;
    memset(f->bufp, '\0', Stralloc+1);
    return f;
}
@

<<function [[opencore]]>>=
/*
 * Open a corebuffer to read.  EOF occurs after reading len
 * characters from buf.
 */

io*
opencore(char *s, int len)
{
    io *f = new(struct Io);
    uchar *buf = emalloc(len);

    f->fd = -1 /*open("/dev/null", 0)*/;
    f->bufp = f->strp = buf;
    f->ebuf = buf+len;
    Memcpy(buf, s, len);
    return f;
}
@





\section{Format}

%ocaml: use Printf, or ocamltarzan generated dumper

<<global [[pfmtnest]]>>=
int pfmtnest = 0;
@

% io.c
% could use fmtinstall instead? or because wanted to be portable to other OSes?
<<function [[pfmt]]>>=
void
pfmt(io *f, char *fmt, ...)
{
    va_list ap;
    char err[ERRMAX];

    va_start(ap, fmt);
    pfmtnest++;
    for(;*fmt;fmt++) {
        if(*fmt!='%') {
            pchr(f, *fmt);
            continue;
        }
        if(*++fmt == '\0')		/* "blah%"? */
            break;
        switch(*fmt){
        case 'c':
            pchr(f, va_arg(ap, int));
            break;
        case 'd':
            pdec(f, va_arg(ap, int));
            break;
        case 'o':
            poct(f, va_arg(ap, unsigned int));
            break;
        case 'p':
            pptr(f, va_arg(ap, void*));
            break;
        case 'Q':
            pquo(f, va_arg(ap, char *));
            break;
        case 'q':
            pwrd(f, va_arg(ap, char *));
            break;
        case 's':
            pstr(f, va_arg(ap, char *));
            break;

        case 'r':
            errstr(err, sizeof err); pstr(f, err);
            break;

        // rc specific, TODO LP split here
        case 't':
            pcmd(f, va_arg(ap, struct Tree *));
            break;
        case 'v':
            pval(f, va_arg(ap, struct Word *));
            break;

        default:
            pchr(f, *fmt);
            break;
        }
    }
    va_end(ap);
    if(--pfmtnest==0)
        flush(f);
}
@
% could add 'x' pcmd for the bytecode




<<function [[pstr]]>>=
void
pstr(io *f, char *s)
{
    if(s==0)
        s="(null)";
    while(*s) pchr(f, *s++);
}
@

<<function [[pdec]]>>=
void
pdec(io *f, int n)
{
    if(n<0){
        n=-n;
        if(n>=0){
            pchr(f, '-');
            pdec(f, n);
            return;
        }
        /* n is two's complement minimum integer */
        n = 1-n;
        pchr(f, '-');
        pdec(f, n/10);
        pchr(f, n%10+'1');
        return;
    }
    if(n>9)
        pdec(f, n/10);
    pchr(f, n%10+'0');
}
@

<<function [[poct]]>>=
void
poct(io *f, unsigned int n)
{
    if(n>7)
        poct(f, n>>3);
    pchr(f, (n&7)+'0');
}
@

<<function [[pquo]]>>=
void
pquo(io *f, char *s)
{
    pchr(f, '\'');
    for(;*s;s++)
        if(*s=='\'')
            pfmt(f, "''");
        else pchr(f, *s);
    pchr(f, '\'');
}
@

<<function [[pwrd]]>>=
void
pwrd(io *f, char *s)
{
    char *t;
    for(t = s;*t;t++) if(*t >= 0 && needsrcquote(*t)) break;
    if(t==s || *t)
        pquo(f, s);
    else pstr(f, s);
}
@

<<function [[pptr]]>>=
void
pptr(io *f, void *v)
{
    int n;
    uintptr p;

    p = (uintptr)v;
    if(sizeof(uintptr) == sizeof(uvlong) && p>>32)
        for(n = 60;n>=32;n-=4) pchr(f, "0123456789ABCDEF"[(p>>n)&0xF]);

    for(n = 28;n>=0;n-=4) pchr(f, "0123456789ABCDEF"[(p>>n)&0xF]);
}
@


<<function [[pval]]>>=
void
pval(io *f, word *a)
{
    if(a){
        while(a->next && a->next->word){
            pwrd(f, (char *)a->word);
            pchr(f, ' ');
            a = a->next;
        }
        pwrd(f, (char *)a->word);
    }
}
@


\section{String conversions}

<<global [[bp]]>>=
char *bp;
@

<<function [[inttoascii]]>>=
void
inttoascii(char *s, long n)
{
    bp = s;
    iacvt(n);
    *bp='\0';
}
@

<<function [[iacvt]]>>=
static void
iacvt(int n)
{
    if(n<0){
        *bp++='-';
        n=-n;	/* doesn't work for n==-inf */
    }
    if(n/10)
        iacvt(n/10);
    *bp++=n%10+'0';
}
@

\section{Misc}
\t delete them, I don't care about other OSes

<<function [[Write]]>>=
long
Write(int fd, void *buf, long cnt)
{
    return write(fd, buf, cnt);
}
@

<<function [[Read]]>>=
long
Read(int fd, void *buf, long cnt)
{
    return read(fd, buf, cnt);
}
@

<<function [[Seek]]>>=
long
Seek(int fd, long cnt, long whence)
{
    return seek(fd, cnt, whence);
}
@

<<function [[Creat]]>>=
int
Creat(char *file)
{
    return create(file, 1, 0666L);
}
@

<<function [[Dup]]>>=
int
Dup(int a, int b)
{
    return dup(a, b);
}
@

<<function [[Memcpy]]>>=
void
Memcpy(void *a, void *b, long n)
{
    memmove(a, b, n);
}
@


\chapter{Examples of [[rc]] scripts TODO}
\label{chap:examples}

\section{[[/rc/lib/rcmain]]}
\label{sec:rcmain}

\section{[[/home/pad/lib/profile]]}


\chapter{Extra Code}

#include "Shell_extra.nw"

%\chapter{Changelog}
% code via make loc = 6300 LOC, after full lpized  ? LOC
% orig Shell.nw = 7500 LOC, after full lpized and comments in sections ??
% now: =~ ?? LOC so added ?? LOE (Lines of explanations)
% rc in ocaml: 2300 LOC (but not all features)

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
LOC = Lines Of Code
CLI = Command-Line Interface
GUI = Graphical User Interface
IDE = Integrated Development Environment
\end{verbatim}




\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
