\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:

%thx to this manual, better understand sh:

%history LP-ization:
% - skeleton, mostly copy paste of Kernel.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the file before
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 Shell
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a shell.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present rc, for run command.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item sh
\item bash
\item zsh
\item scsh
\end{itemize}

% other worthwhile? eshell :)


%bash shellshock context in oct 2014, good idea to look at shell
% implementation :)

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Shell principles}
% for a long time actually there was no (external) shell. Shell was
% part of OS. With unix it changed and shell can be a regular
% user program which then opened the way for complex job control language.

\section{[[rc]] services}

\section{Input shell language}
% rc PL
% quite similar to bash
% main difference? for var stuff?
% if not instead of else.

\section{Code organization}

% getflags.c: getopt + specific
% io.c: fmt + specific

\section{Architecture overview}

% pipeline archi? like compiler?

% lexing -> parsing -> ast -> bytecode? -> ???

%Xxxx? bytecode?
%execxxx? builtins?

%###############################################################################

\chapter{Core Data Structures}

\section{[[Token]]}

% can also be ';', see tree3() that actually look for that

\section{Abstract syntax tree [[Tree]]}
% rc has a command language!

% AST tree of the command, ex "ls | wc" =>  ?

<<struct tree>>=
struct Tree {

    // enum<token_kind>
    int	type;

    // array<option<ref_own<Tree>>
    tree	*child[3];

    bool iskw;

    char *str;

    //enum<redirection_kind>
    int	rtype;
    int fd0, fd1;	/* details of REDIR PIPE DUP tokens */
    int	quoted;

    tree	*next;
};
@


<<global treenodes>>=
// list<ref_own<tree>> (next = Tree.next)
tree *treenodes;
@

<<function newtree>>=
/*
 * create and clear a new tree node, and add it
 * to the node list.
 */
tree*
newtree(void)
{
    tree *t = new(tree);
    t->iskw = false;
    t->str = nil;
    t->child[0] = t->child[1] = t->child[2] = nil;
    t->next = treenodes;
    treenodes = t;
    return t;
}
@

<<function freetree>>=
void
freetree(tree *p)
{
    if(p==nil)
        return;	
    freetree(p->child[0]);
    freetree(p->child[1]);
    freetree(p->child[2]);
    if(p->str)
        efree(p->str);
    efree((char *)p);
}
@


<<function freenodes>>=
void
freenodes(void)
{
    tree *t, *u;
    for(t = treenodes;t;t = u){
        u = t->next;
        if(t->str)
            efree(t->str);
        efree((char *)t);
    }
    treenodes = nil;
}
@
% and does not call freetree()?

% used in syn.y
<<function tree1>>=
tree*
tree1(int type, tree *c0)
{
    return tree3(type, c0, (tree *)nil, (tree *)nil);
}
@

<<function tree2>>=
//@Scheck: used by syn.y
tree* tree2(int type, tree *c0, tree *c1)
{
    return tree3(type, c0, c1, (tree *)nil);
}
@

<<function tree3>>=
tree*
tree3(int type, tree *c0, tree *c1, tree *c2)
{
    tree *t;
    if(type==';'){
        if(c0==nil)
            return c1;
        if(c1==nil)
            return c0;
    }
    t = newtree();
    t->type = type;
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@
% no check for c2 when use ';'? no because binary operator?

\section{Bytecode [[Code]] and [[codebuf]]}

<<struct code>>=
/*
 * The first word of any code vector is a reference count.
 * Always create a new reference to a code vector by calling codecopy(.).
 * Always call codefree(.) when deleting a reference.
 */
union Code {
    void	(*f)(void); // Xxxx()
    int	i;
    char	*s;
};
@

<<global codebuf>>=
code *codebuf;				/* compiler output */
@

% first element is a reference count, which is why codecopy()
% does cp[0].i++;


% show bootstrap code?
% or show trace of rc -r ?

\section{[[Thread]] and [[runq]]}
% manage subprocesses

<<struct thread>>=
struct Thread {
    union Code *code;		/* code for this thread */
    int pc;			/* code[pc] is the next instruction */

    int lineno;			/* linenumber */

    // list<ref_own<Var>> (next = Var.next)
    struct Var *local;		/* list of local variables */

    struct List *argv;		/* argument stack */
    struct Redir *redir;	/* redirection stack */
    struct Redir *startredir;	/* redir inheritance point */

    char *cmdfile;		/* file name in Xrdcmd */
    struct Io *cmdfd;		/* file descriptor for Xrdcmd */

    int iflast;			/* static `if not' checking */
    bool eof;			/* is cmdfd at eof? */
    bool iflag;			/* interactive? */

    int pid;			/* process for Xpipewait to wait for */
    char status[NSTATUS];	/* status for Xpipewait */

    tree *treenodes;		/* tree nodes created by this process */

    thread *ret;		/* who continues when this finishes */
};
@

<<global runq>>=
// list<ref_own<Thread>> (next = Thread.ret)
thread *runq;
@

\section{[[Word]], [[List]]}

<<struct word>>=
/*
 * word lists are in correct order,
 * i.e. word0->word1->word2->word3->0
 */
struct Word {
    char *word;

    word *next;
};
@
% could define W = nil so avoid those (word*)nil

<<function newword>>=
word*
newword(char *wd, word *next)
{
    word *p = new(struct Word);
    p->word = strdup(wd);
    p->next = next;
    return p;
}
@


<<function freewords>>=
void
freewords(word *w)
{
    word *nw;
    while(w){
        efree(w->word);
        nw = w->next;
        efree((char *)w);
        w = nw;
    }
}
@





<<struct list>>=
struct List {
    // list<ref_own<Word>> (next = Word.next)
    word *words;

    list *next;
};
@
% so it's actually a list of list (so fast concatenation?)

% see pushlist() below



\section{[[Var]] and [[gvar]]}

<<struct var>>=
struct Var {
    char	*name;		/* ascii name */
    word	*val;		/* value */

    bool	changed;
    code	*fn;		/* pointer to function's code vector */
    int	fnchanged;
    int	pc;		/* pc of start of function */

    var	*next;		/* next on hash or local list */
};
@
% #define V (struct Var*)nil
% like for other soft, or use VarNil?

<<constant NVAR>>=
#define	NVAR	521
@

<<global gvar>>=
// hash<string, ref<Var>> (next = Var.next)
var *gvar[NVAR];		/* hash for globals */
@


<<function setvar>>=
void
setvar(char *name, word *val)
{
    struct Var *v = vlook(name);
    freewords(v->val);
    v->val = val;
    v->changed = true;
}
@

<<function vlook>>=
var*
vlook(char *name)
{
    var *v;
    if(runq)
        for(v = runq->local;v;v = v->next)
            if(strcmp(v->name, name)==0) return v;
    return gvlook(name);
}
@

<<function gvlook>>=
var*
gvlook(char *name)
{
    int h = hash(name, NVAR);
    var *v;
    for(v = gvar[h];v;v = v->next) if(strcmp(v->name, name)==0) return v;
    return gvar[h] = newvar(strdup(name), gvar[h]);
}
@

\chapter{[[main()]]}

%plan9.c
<<global Rcmain>>=
char *Rcmain = "/rc/lib/rcmain";
@

<<[[main()]] locals>>=
char *rcmain;
@

<<[[main()]] locals>>=
code bootstrap[17];
@
% indeed 17 lines below about bootstrap. A bit ugly though

<<function main (rc/exec.c)>>=
/*
 * get command line flags, initialize keywords & traps.
 * get values from environment.
 * set $pid, $cflag, $*
 * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)
 * start interpreting code
 */
//@Scheck: not dead! entry point!
void main(int argc, char *argv[])
{
    <<[[main()]] locals>>

    <<[[main()]] argc argv processing, modify flags>>
    
    rcmain = flag['m'] ? flag['m'][0] : Rcmain; 

    err = openfd(2);

    <<[[main()]] initialisation>>
    
    <<[[main()]] initialize [[boostrap]]>>

    // initialize runq with bootstrap code
    start(bootstrap, 1, (var *)nil);

    // initialize runq->argv
    <<[[main()]] bootstrap argv>>

    for(;;){
        <<[[main()]] debug runq>>

        runq->pc++;
        (*runq->code[runq->pc-1].f)();

        <<[[main()]] handing trap if necessary>>
    }
}
@

% err = openfd, use buffered IO lib, see appendix X.y

\section{[[getflags()]]}

<<constant NFLAG>>=
#define	NFLAG	128
@

<<global flag>>=
char **flag[NFLAG];
@


<<global flagset>>=
char *flagset[] = {"<flag>"};
@

<<[[main()]] argc argv processing, modify flags>>=
argc = getflags(argc, argv, "SsrdiIlxepvVc:1m:1[command]", 1);

if(argc==-1)
    usage("[file [arg ...]]");
if(argv[0][0]=='-')
    flag['l'] = flagset;

if(flag['I'])
    flag['i'] = 0;
else 
    if(flag['i']==0 && argc==1 && Isatty(0)) 
       flag['i'] = flagset;
@


\section{Initialisation}

<<global mypid>>=
int mypid;
@

% if things was more functional I would not need those declarations ...
% I would do 'let num = int_to_string(mypid)'
<<[[main()]] locals>>=
char num[12];
@

<<[[main()]] initialisation>>=
kinit();
Trapinit();
Vinit();

mypid = getpid();
inttoascii(num, mypid);

setvar("pid", newword(num, (word *)nil));
setvar("cflag", flag['c']? newword(flag['c'][0], (word *)nil) : (word *)nil);
setvar("rcname", newword(argv[0], (word *)nil));
@

\section{Bootstrapping}

\ifallcode
<<[[main()]] locals>>=
int i;
@
\fi

% see main() comment:
% * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)

<<[[main()]] initialize [[boostrap]]>>=
memset(bootstrap, 0, sizeof bootstrap);

i = 0;
bootstrap[i++].i = 1; // reference count
bootstrap[i++].f = Xmark;
bootstrap[i++].f = Xword;
bootstrap[i++].s="*";
bootstrap[i++].f = Xassign;
bootstrap[i++].f = Xmark;
bootstrap[i++].f = Xmark;
bootstrap[i++].f = Xword;
bootstrap[i++].s="*";
bootstrap[i++].f = Xdol;
bootstrap[i++].f = Xword;
bootstrap[i++].s = rcmain;
bootstrap[i++].f = Xword;
bootstrap[i++].s=".";
bootstrap[i++].f = Xsimple;
bootstrap[i++].f = Xexit;
bootstrap[i].i = 0;
@

\section{Setting [[runq]], [[start()]]}

% modify runq!
<<function start>>=
void
start(code *c, int pc, var *local)
{
    struct Thread *p = new(struct Thread);

    p->code = codecopy(c);
    p->pc = pc;

    p->argv = nil;
    p->redir = p->startredir = runq ? runq->redir : nil;
    p->local = local;
    p->cmdfile = nil;
    p->cmdfd = nil;
    p->eof = false;
    p->iflag = false;
    p->lineno = 1;

    p->ret = runq;
    runq = p;
}
@

<<function codecopy>>=
code*
codecopy(code *cp)
{
    cp[0].i++;
    return cp;
}
@

\section{Setting [[runq->argv]]}

<<global argv0>>=
/*
 * Start executing the given code at the given pc with the given redirection
 */
char *argv0="rc";
@

<<[[main()]] bootstrap argv>>=
/* prime bootstrap argv */
pushlist();
argv0 = strdup(argv[0]);
for(i = argc-1;i!=0;--i) 
    pushword(argv[i]);
@


<<function pushlist>>=
void
pushlist(void)
{
    list *p = new(list);
    p->next = runq->argv;
    p->words = nil;
    runq->argv = p;
}
@

<<function pushword>>=
void
pushword(char *wd)
{
    if(runq->argv==nil)
        panic("pushword but no argv!", 0);
    runq->argv->words = newword(wd, runq->argv->words);
}
@

\section{Interpreter loop}

\chapter{IO}


\chapter{Lexing}

<<constant NTOK>>=
#define	NTOK	8192		/* maximum bytes in a word (token) */
@

<<global tok>>=
char tok[NTOK + UTFmax];
@


<<function yylex>>=
//@Scheck: called from yyparse()
int yylex(void)
{
    int c, d = nextc();
    char *w = tok;
    struct Tree *t;
    yylval.tree = 0;
    /*
     * Embarassing sneakiness:  if the last token read was a quoted or unquoted
     * WORD then we alter the meaning of what follows.  If the next character
     * is `(', we return SUB (a subscript paren) and consume the `('.  Otherwise,
     * if the next character is the first character of a simple or compound word,
     * we insert a `^' before it.
     */
    if(lastword){
        lastword = 0;
        if(d=='('){
            advance();
            strcpy(tok, "( [SUB]");
            return SUB;
        }
        if(wordchr(d) || d=='\'' || d=='`' || d=='$' || d=='"'){
            strcpy(tok, "^");
            return '^';
        }
    }
    inquote = 0;
    skipwhite();
    switch(c = advance()){
    case EOF:
        lastdol = 0;
        strcpy(tok, "EOF");
        return EOF;
    case '$':
        lastdol = 1;
        if(nextis('#')){
            strcpy(tok, "$#");
            return COUNT;
        }
        if(nextis('"')){
            strcpy(tok, "$\"");
            return '"';
        }
        strcpy(tok, "$");
        return '$';
    case '&':
        lastdol = 0;
        if(nextis('&')){
            skipnl();
            strcpy(tok, "&&");
            return ANDAND;
        }
        strcpy(tok, "&");
        return '&';
    case '|':
        lastdol = 0;
        if(nextis(c)){
            skipnl();
            strcpy(tok, "||");
            return OROR;
        }
    case '<':
    case '>':
        lastdol = 0;
        /*
         * funny redirection tokens:
         *	redir:	arrow | arrow '[' fd ']'
         *	arrow:	'<' | '<<' | '>' | '>>' | '|'
         *	fd:	digit | digit '=' | digit '=' digit
         *	digit:	'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
         * some possibilities are nonsensical and get a message.
         */
        *w++=c;
        t = newtree();
        switch(c){
        case '|':
            t->type = PIPE;
            t->fd0 = 1;
            t->fd1 = 0;
            break;
        case '>':
            t->type = REDIR;
            if(nextis(c)){
                t->rtype = APPEND;
                *w++=c;
            }
            else t->rtype = WRITE;
            t->fd0 = 1;
            break;
        case '<':
            t->type = REDIR;
            if(nextis(c)){
                t->rtype = HERE;
                *w++=c;
            } else if (nextis('>')){
                t->rtype = RDWR;
                *w++=c;
            } else t->rtype = READ;
            t->fd0 = 0;
            break;
        }
        if(nextis('[')){
            *w++='[';
            c = advance();
            *w++=c;
            if(c<'0' || '9'<c){
            RedirErr:
                *w = 0;
                yyerror(t->type==PIPE?"pipe syntax"
                        :"redirection syntax");
                return EOF;
            }
            t->fd0 = 0;
            do{
                t->fd0 = t->fd0*10+c-'0';
                *w++=c;
                c = advance();
            }while('0'<=c && c<='9');
            if(c=='='){
                *w++='=';
                if(t->type==REDIR)
                    t->type = DUP;
                c = advance();
                if('0'<=c && c<='9'){
                    t->rtype = DUPFD;
                    t->fd1 = t->fd0;
                    t->fd0 = 0;
                    do{
                        t->fd0 = t->fd0*10+c-'0';
                        *w++=c;
                        c = advance();
                    }while('0'<=c && c<='9');
                }
                else{
                    if(t->type==PIPE)
                        goto RedirErr;
                    t->rtype = CLOSE;
                }
            }
            if(c!=']'
            || t->type==DUP && (t->rtype==HERE || t->rtype==APPEND))
                goto RedirErr;
            *w++=']';
        }
        *w='\0';
        yylval.tree = t;
        if(t->type==PIPE)
            skipnl();
        return t->type;
    case '\'':
        lastdol = 0;
        lastword = 1;
        inquote = 1;
        for(;;){
            c = advance();
            if(c==EOF)
                break;
            if(c=='\''){
                if(nextc()!='\'')
                    break;
                advance();
            }
            w = addutf(w, c);
        }
        if(w!=0)
            *w='\0';
        t = token(tok, WORD);
        t->quoted = 1;
        yylval.tree = t;
        return t->type;
    }
    if(!wordchr(c)){
        lastdol = 0;
        tok[0] = c;
        tok[1]='\0';
        return c;
    }
    for(;;){
        if(c=='*' || c=='[' || c=='?' || c==GLOB)
            w = addtok(w, GLOB);
        w = addutf(w, c);
        c = nextc();
        if(lastdol?!idchr(c):!wordchr(c)) break;
        advance();
    }

    lastword = 1;
    lastdol = 0;
    if(w!=0)
        *w='\0';
    t = klook(tok);
    if(t->type!=WORD)
        lastword = 0;
    t->quoted = 0;
    yylval.tree = t;
    return t->type;
}
@
%$

\chapter{Parsing}

<<constant YYMAXDEPTH>>=
//@Scheck: used in y.tab.c
#define	YYMAXDEPTH	500
@

<<rc/syn.y>>=
%term FOR IN WHILE IF NOT TWIDDLE BANG SUBSHELL SWITCH FN
%term WORD REDIR DUP PIPE SUB
%term SIMPLE ARGLIST WORDS BRACE PAREN PCMD PIPEFD /* not used in syntax */

/* operator priorities -- lowest first */
%left IF WHILE FOR SWITCH ')' NOT
%left ANDAND OROR
%left BANG SUBSHELL
%left PIPE
%left '^'
%right '$' COUNT '"'
%left SUB

%{
#include "rc.h"
#include "fns.h"
%}

%union{
 struct Tree *tree;

};

%type<tree> line paren brace body cmdsa cmdsan assign epilog redir
%type<tree> cmd simple first word comword keyword words
%type<tree> NOT FOR IN WHILE IF TWIDDLE BANG SUBSHELL SWITCH FN
%type<tree> WORD REDIR DUP PIPE

%%
rc:				{ return 1;}
|	line '\n'		{return !compile($1);}
line:	cmd
|	cmdsa line		{$$=tree2(';', $1, $2);}
body:	cmd
|	cmdsan body		{$$=tree2(';', $1, $2);}
cmdsa:	cmd ';'
|	cmd '&'			{$$=tree1('&', $1);}
cmdsan:	cmdsa
|	cmd '\n'
brace:	'{' body '}'		{$$=tree1(BRACE, $2);}
paren:	'(' body ')'		{$$=tree1(PCMD, $2);}
assign:	first '=' word		{$$=tree2('=', $1, $3);}
epilog:				{$$=0;}
|	redir epilog		{$$=mung2($1, $1->child[0], $2);}
redir:	REDIR word		{$$=mung1($1, $1->rtype==HERE?heredoc($2):$2);}
|	DUP
cmd:				{$$=0;}
|	brace epilog		{$$=epimung($1, $2);}
|	IF paren {skipnl();} cmd
    {$$=mung2($1, $2, $4);}
|	IF NOT {skipnl();} cmd	{$$=mung1($2, $4);}
|	FOR '(' word IN words ')' {skipnl();} cmd
 /*
  * if ``words'' is nil, we need a tree element to distinguish between 
  * for(i in ) and for(i), the former being a loop over the empty set
  * and the latter being the implicit argument loop.  so if $5 is nil
  * (the empty set), we represent it as "()".  don't parenthesize non-nil
  * functions, to avoid growing parentheses every time we reread the
  * definition.
  */
    {$$=mung3($1, $3, $5 ? $5 : tree1(PAREN, $5), $8);}
|	FOR '(' word ')' {skipnl();} cmd
    {$$=mung3($1, $3, (struct Tree *)0, $6);}
|	WHILE paren {skipnl();} cmd
    {$$=mung2($1, $2, $4);}
|	SWITCH word {skipnl();} brace
    {$$=tree2(SWITCH, $2, $4);}
|	simple			{$$=simplemung($1);}
|	TWIDDLE word words	{$$=mung2($1, $2, $3);}
|	cmd ANDAND cmd		{$$=tree2(ANDAND, $1, $3);}
|	cmd OROR cmd		{$$=tree2(OROR, $1, $3);}
|	cmd PIPE cmd		{$$=mung2($2, $1, $3);}
|	redir cmd  %prec BANG	{$$=mung2($1, $1->child[0], $2);}
|	assign cmd %prec BANG	{$$=mung3($1, $1->child[0], $1->child[1], $2);}
|	BANG cmd		{$$=mung1($1, $2);}
|	SUBSHELL cmd		{$$=mung1($1, $2);}
|	FN words brace		{$$=tree2(FN, $2, $3);}
|	FN words		{$$=tree1(FN, $2);}
simple:	first
|	simple word		{$$=tree2(ARGLIST, $1, $2);}
|	simple redir		{$$=tree2(ARGLIST, $1, $2);}
first:	comword	
|	first '^' word		{$$=tree2('^', $1, $3);}
word:	keyword			{lastword=1; $1->type=WORD;}
|	comword
|	word '^' word		{$$=tree2('^', $1, $3);}
comword: '$' word		{$$=tree1('$', $2);}
|	'$' word SUB words ')'	{$$=tree2(SUB, $2, $4);}
|	'"' word		{$$=tree1('"', $2);}
|	COUNT word		{$$=tree1(COUNT, $2);}
|	WORD
|	'`' brace		{$$=tree1('`', $2);}
|	'(' words ')'		{$$=tree1(PAREN, $2);}
|	REDIR brace		{$$=mung1($1, $2); $$->type=PIPEFD;}
keyword: FOR|IN|WHILE|IF|NOT|TWIDDLE|BANG|SUBSHELL|SWITCH|FN
words:				{$$=(struct Tree*)0;}
|	words word		{$$=tree2(WORDS, $1, $2);}
@


\section{Here documents}

\chapter{Code Generation}
% in shell context???

<<function compile>>=
//@Scheck: called from syn.y
int compile(tree *t)
{
    ncode = 100;
    codebuf = (code *)emalloc(ncode*sizeof codebuf[0]);
    codep = 0;
    emiti(0);			/* reference count */
    outcode(t, flag['e']?1:0);
    if(nerror){
        efree((char *)codebuf);
        return 0;
    }
    readhere();
    emitf(Xreturn);
    emitf(0);
    return 1;
}
@

<<function outcode>>=
void
outcode(tree *t, int eflag)
{
    int p, q;
    tree *tt;
    if(t==0)
        return;
    if(t->type!=NOT && t->type!=';')
        runq->iflast = 0;
    switch(t->type){
    default:
        pfmt(err, "bad type %d in outcode\n", t->type);
        break;
    case '$':
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xdol);
        break;
    case '"':
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xqdol);
        break;
    case SUB:
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xmark);
        outcode(c1, eflag);
        emitf(Xsub);
        break;
    case '&':
        emitf(Xasync);
        if(havefork){
            p = emiti(0);
            outcode(c0, eflag);
            emitf(Xexit);
            stuffdot(p);
        } else
            emits(fnstr(c0));
        break;
    case ';':
        outcode(c0, eflag);
        outcode(c1, eflag);
        break;
    case '^':
        emitf(Xmark);
        outcode(c1, eflag);
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xconc);
        break;
    case '`':
        emitf(Xbackq);
        if(havefork){
            p = emiti(0);
            outcode(c0, 0);
            emitf(Xexit);
            stuffdot(p);
        } else
            emits(fnstr(c0));
        break;
    case ANDAND:
        outcode(c0, 0);
        emitf(Xtrue);
        p = emiti(0);
        outcode(c1, eflag);
        stuffdot(p);
        break;
    case ARGLIST:
        outcode(c1, eflag);
        outcode(c0, eflag);
        break;
    case BANG:
        outcode(c0, eflag);
        emitf(Xbang);
        break;
    case PCMD:
    case BRACE:
        outcode(c0, eflag);
        break;
    case COUNT:
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xcount);
        break;
    case FN:
        emitf(Xmark);
        outcode(c0, eflag);
        if(c1){
            emitf(Xfn);
            p = emiti(0);
            emits(fnstr(c1));
            outcode(c1, eflag);
            emitf(Xunlocal);	/* get rid of $* */
            emitf(Xreturn);
            stuffdot(p);
        }
        else
            emitf(Xdelfn);
        break;
    case IF:
        outcode(c0, 0);
        emitf(Xif);
        p = emiti(0);
        outcode(c1, eflag);
        emitf(Xwastrue);
        stuffdot(p);
        break;
    case NOT:
        if(!runq->iflast)
            yyerror("`if not' does not follow `if(...)'");
        emitf(Xifnot);
        p = emiti(0);
        outcode(c0, eflag);
        stuffdot(p);
        break;
    case OROR:
        outcode(c0, 0);
        emitf(Xfalse);
        p = emiti(0);
        outcode(c1, eflag);
        stuffdot(p);
        break;
    case PAREN:
        outcode(c0, eflag);
        break;
    case SIMPLE:
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xsimple);
        if(eflag)
            emitf(Xeflag);
        break;
    case SUBSHELL:
        emitf(Xsubshell);
        if(havefork){
            p = emiti(0);
            outcode(c0, eflag);
            emitf(Xexit);
            stuffdot(p);
        } else
            emits(fnstr(c0));
        if(eflag)
            emitf(Xeflag);
        break;
    case SWITCH:
        codeswitch(t, eflag);
        break;
    case TWIDDLE:
        emitf(Xmark);
        outcode(c1, eflag);
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xmatch);
        if(eflag)
            emitf(Xeflag);
        break;
    case WHILE:
        q = codep;
        outcode(c0, 0);
        if(q==codep)
            emitf(Xsettrue);	/* empty condition == while(true) */
        emitf(Xtrue);
        p = emiti(0);
        outcode(c1, eflag);
        emitf(Xjump);
        emiti(q);
        stuffdot(p);
        break;
    case WORDS:
        outcode(c1, eflag);
        outcode(c0, eflag);
        break;
    case FOR:
        emitf(Xmark);
        if(c1){
            outcode(c1, eflag);
            emitf(Xglob);
        }
        else{
            emitf(Xmark);
            emitf(Xword);
            emits(strdup("*"));
            emitf(Xdol);
        }
        emitf(Xmark);		/* dummy value for Xlocal */
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xlocal);
        p = emitf(Xfor);
        q = emiti(0);
        outcode(c2, eflag);
        emitf(Xjump);
        emiti(p);
        stuffdot(q);
        emitf(Xunlocal);
        break;
    case WORD:
        emitf(Xword);
        emits(strdup(t->str));
        break;
    case DUP:
        if(t->rtype==DUPFD){
            emitf(Xdup);
            emiti(t->fd0);
            emiti(t->fd1);
        }
        else{
            emitf(Xclose);
            emiti(t->fd0);
        }
        outcode(c1, eflag);
        emitf(Xpopredir);
        break;
    case PIPEFD:
        emitf(Xpipefd);
        emiti(t->rtype);
        if(havefork){
            p = emiti(0);
            outcode(c0, eflag);
            emitf(Xexit);
            stuffdot(p);
        } else {
            emits(fnstr(c0));
        }
        break;
    case REDIR:
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xglob);
        switch(t->rtype){
        case APPEND:
            emitf(Xappend);
            break;
        case WRITE:
            emitf(Xwrite);
            break;
        case READ:
        case HERE:
            emitf(Xread);
            break;
        case RDWR:
            emitf(Xrdwr);
            break;
        }
        emiti(t->fd0);
        outcode(c1, eflag);
        emitf(Xpopredir);
        break;
    case '=':
        tt = t;
        for(;t && t->type=='=';t = c2);
        if(t){					/* var=value cmd */
            for(t = tt;t->type=='=';t = c2){
                emitf(Xmark);
                outcode(c1, eflag);
                emitf(Xmark);
                outcode(c0, eflag);
                emitf(Xlocal);		/* push var for cmd */
            }
            outcode(t, eflag);		/* gen. code for cmd */
            for(t = tt; t->type == '='; t = c2)
                emitf(Xunlocal);	/* pop var */
        }
        else{					/* var=value */
            for(t = tt;t;t = c2){
                emitf(Xmark);
                outcode(c1, eflag);
                emitf(Xmark);
                outcode(c0, eflag);
                emitf(Xassign);	/* set var permanently */
            }
        }
        t = tt;	/* so tests below will work */
        break;
    case PIPE:
        emitf(Xpipe);
        emiti(t->fd0);
        emiti(t->fd1);
        if(havefork){
            p = emiti(0);
            q = emiti(0);
            outcode(c0, eflag);
            emitf(Xexit);
            stuffdot(p);
        } else {
            emits(fnstr(c0));
            q = emiti(0);
        }
        outcode(c1, eflag);
        emitf(Xreturn);
        stuffdot(q);
        emitf(Xpipewait);
        break;
    }
    if(t->type!=NOT && t->type!=';')
        runq->iflast = t->type==IF;
    else if(c0) runq->iflast = c0->type==IF;
}
@
%$

\chapter{Execution}

\chapter{Builtins}

% plan9.c
<<global Builtin>>=
builtin Builtin[] = {
    "cd",		execcd,
    "whatis",		execwhatis,
    "eval",		execeval,
    "exec",		execexec,	/* but with popword first */
    "exit",		execexit,
    "shift",		execshift,
    "wait",		execwait,
    ".",		execdot,
    "finit",		execfinit,
    "flag",		execflag,
    "rfork",		execnewpgrp,
    0
};
@

\section{[[cd]]}

<<function execcd>>=
void
execcd(void)
{
    word *a = runq->argv->words;
    word *cdpath;
    char *dir;

    setstatus("can't cd");
    cdpath = vlook("cdpath")->val;
    switch(count(a)){
    default:
        pfmt(err, "Usage: cd [directory]\n");
        break;
    case 2:
        if(a->next->word[0]=='/' || cdpath==0)
            cdpath = &nullpath;
        for(; cdpath; cdpath = cdpath->next){
            if(cdpath->word[0] != '\0')
                dir = appfile(cdpath->word, a->next->word);
            else
                dir = strdup(a->next->word);

            if(dochdir(dir) >= 0){
                if(cdpath->word[0] != '\0' &&
                    strcmp(cdpath->word, ".") != 0)
                    pfmt(err, "%s\n", dir);
                free(dir);
                setstatus("");
                break;
            }
            free(dir);
        }
        if(cdpath==0)
            pfmt(err, "Can't cd %s: %r\n", a->next->word);
        break;
    case 1:
        a = vlook("home")->val;
        if(count(a)>=1){
            if(dochdir(a->word)>=0)
                setstatus("");
            else
                pfmt(err, "Can't cd %s: %r\n", a->word);
        }
        else
            pfmt(err, "Can't cd -- $home empty\n");
        break;
    }
    poplist();
}
@
%$

\section{[[exit]]}

<<function execexit>>=
void
execexit(void)
{
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: exit [status]\nExiting anyway\n");
    case 2:
        setstatus(runq->argv->words->next->word);
    case 1:	Xexit();
    }
}
@

\section{[[.]]}

\section{[[eval]]}

\section{Other builtins]}

%rfork
<<function execnewpgrp>>=
void
execnewpgrp(void)
{
    int arg;
    char *s;
    switch(count(runq->argv->words)){
    case 1:
        arg = RFENVG|RFNAMEG|RFNOTEG;
        break;
    case 2:
        arg = 0;
        for(s = runq->argv->words->next->word;*s;s++) switch(*s){
        default:
            goto Usage;
        case 'n':
            arg|=RFNAMEG;  break;
        case 'N':
            arg|=RFCNAMEG;
            break;
        case 'm':
            arg|=RFNOMNT;  break;
        case 'e':
            arg|=RFENVG;   break;
        case 'E':
            arg|=RFCENVG;  break;
        case 's':
            arg|=RFNOTEG;  break;
        case 'f':
            arg|=RFFDG;    break;
        case 'F':
            arg|=RFCFDG;   break;
        }
        break;
    default:
    Usage:
        pfmt(err, "Usage: %s [fnesFNEm]\n", runq->argv->words->word);
        setstatus("rfork usage");
        poplist();
        return;
    }
    if(rfork(arg)==-1){
        pfmt(err, "rc: %s failed\n", runq->argv->words->word);
        setstatus("rfork failed");
    }
    else
        setstatus("");
    poplist();
}
@


\chapter{Variables}

% diff with bash here, see rc design document

%$#x


\chapter{Prompt}

<<global promptstr>>=
char *promptstr;
@

\chapter{Environment}

\chapter{Redirection}

<<struct redir>>=
struct Redir {
    char type;			/* what to do */
    short from, to;			/* what to do it to */
    struct Redir *next;		/* what else to do (reverse order) */
};
@

\chapter{Pipe}

\chapter{Globbing}

<<global globname>>=
char *globname;
@

<<global globv>>=
struct Word *globv;
@

<<function deglob>>=
/*
 * delete all the GLOB marks from s, in place
 */
void
deglob(void *as)
{
    char *s = as;
    char *t = s;
    do{
        if(*t==GLOB)
            t++;
        *s++=*t;
    }while(*t++);
}
@

<<function globcmp>>=
int
globcmp(const void *s, const void *t)
{
    return strcmp(*(char**)s, *(char**)t);
}
@

<<function globsort>>=
void
globsort(word *left, word *right)
{
    char **list;
    word *a;
    int n = 0;
    for(a = left;a!=right;a = a->next) n++;
    list = (char **)emalloc(n*sizeof(char *));
    for(a = left,n = 0;a!=right;a = a->next,n++) list[n] = a->word;
    qsort((void *)list, n, sizeof(void *), globcmp);
    for(a = left,n = 0;a!=right;a = a->next,n++) a->word = list[n];
    efree((char *)list);
}
@

<<function globdir>>=
/*
 * Push names prefixed by globname and suffixed by a match of p onto the astack.
 * namep points to the end of the prefix in globname.
 */
void
globdir(uchar *p, uchar *namep)
{
    uchar *t, *newp;
    int f;
    /* scan the pattern looking for a component with a metacharacter in it */
    if(*p=='\0'){
        globv = newword(globname, globv);
        return;
    }
    t = namep;
    newp = p;
    while(*newp){
        if(*newp==GLOB)
            break;
        *t=*newp++;
        if(*t++=='/'){
            namep = t;
            p = newp;
        }
    }
    /* If we ran out of pattern, append the name if accessible */
    if(*newp=='\0'){
        *t='\0';
        if(access(globname, 0)==0)
            globv = newword(globname, globv);
        return;
    }
    /* read the directory and recur for any entry that matches */
    *namep='\0';
    if((f = Opendir(globname[0]?globname:"."))<0) return;
    while(*newp!='/' && *newp!='\0') newp++;
    while(Readdir(f, namep, *newp=='/')){
        if(matchfn(namep, p)){
            for(t = namep;*t;t++);
            globdir(newp, t);
        }
    }
    Closedir(f);
}
@

<<function glob>>=
/*
 * Push all file names matched by p on the current thread's stack.
 * If there are no matches, the list consists of p.
 */
void
glob(void *ap)
{
    uchar *p = ap;
    word *svglobv = globv;
    int globlen = Globsize(ap);

    if(!globlen){
        deglob(p);
        globv = newword((char *)p, globv);
        return;
    }
    globname = emalloc(globlen);
    globname[0]='\0';
    globdir(p, (uchar *)globname);
    efree(globname);
    if(svglobv==globv){
        deglob(p);
        globv = newword((char *)p, globv);
    }
    else
        globsort(globv, svglobv);
}
@

<<function equtf>>=
/*
 * Do p and q point at equal utf codes
 */
int
equtf(uchar *p, uchar *q)
{
    Rune pr, qr;
    if(*p!=*q)
        return 0;
    
    chartorune(&pr, (char*)p);
    chartorune(&qr, (char*)q);
    return pr == qr;
}
@

<<function nextutf>>=
/*
 * Return a pointer to the next utf code in the string,
 * not jumping past nuls in broken utf codes!
 */
uchar*
nextutf(uchar *p)
{
    Rune dummy;
    return p + chartorune(&dummy, (char*)p);
}
@

<<function unicode>>=
/*
 * Convert the utf code at *p to a unicode value
 */
int
unicode(uchar *p)
{
    Rune r;

    chartorune(&r, (char*)p);
    return r;
}
@

<<function matchfn>>=
/*
 * Does the string s match the pattern p
 * . and .. are only matched by patterns starting with .
 * * matches any sequence of characters
 * ? matches any single character
 * [...] matches the enclosed list of characters
 */
int
matchfn(void *as, void *ap)
{
    uchar *s = as, *p = ap;

    if(s[0]=='.' && (s[1]=='\0' || s[1]=='.' && s[2]=='\0') && p[0]!='.')
        return 0;
    return match(s, p, '/');
}
@

<<function match>>=
int
match(void *as, void *ap, int stop)
{
    int compl, hit, lo, hi, t, c;
    uchar *s = as, *p = ap;

    for(; *p!=stop && *p!='\0'; s = nextutf(s), p = nextutf(p)){
        if(*p!=GLOB){
            if(!equtf(p, s)) return 0;
        }
        else switch(*++p){
        case GLOB:
            if(*s!=GLOB)
                return 0;
            break;
        case '*':
            for(;;){
                if(match(s, nextutf(p), stop)) return 1;
                if(!*s)
                    break;
                s = nextutf(s);
            }
            return 0;
        case '?':
            if(*s=='\0')
                return 0;
            break;
        case '[':
            if(*s=='\0')
                return 0;
            c = unicode(s);
            p++;
            compl=*p=='~';
            if(compl)
                p++;
            hit = 0;
            while(*p!=']'){
                if(*p=='\0')
                    return 0;		/* syntax error */
                lo = unicode(p);
                p = nextutf(p);
                if(*p!='-')
                    hi = lo;
                else{
                    p++;
                    if(*p=='\0')
                        return 0;	/* syntax error */
                    hi = unicode(p);
                    p = nextutf(p);
                    if(hi<lo){ t = lo; lo = hi; hi = t; }
                }
                if(lo<=c && c<=hi)
                    hit = 1;
            }
            if(compl)
                hit=!hit;
            if(!hit)
                return 0;
            break;
        }
    }
    return *s=='\0';
}
@

<<function globlist1>>=
void
globlist1(word *gl)
{
    if(gl){
        globlist1(gl->next);
        glob(gl->word);
    }
}
@

<<function globlist>>=
void
globlist(void)
{
    word *a;
    globv = 0;
    globlist1(runq->argv->words);
    poplist();
    pushlist();
    if(globv){
        for(a = globv;a->next;a = a->next);
        a->next = runq->argv->words;
        runq->argv->words = globv;
    }
}
@


\chapter{Signals}

<<constant NSIG>>=
#define	NSIG	32
@

<<constant SIGINT>>=
#define	SIGINT	2
@

<<constant SIGQUIT>>=
#define	SIGQUIT	3
@

<<global ntrap>>=
int ntrap;				/* number of outstanding traps */
@

<<global trap>>=
int trap[NSIG];				/* number of outstanding traps per type */
@


<<[[main()]] handing trap if necessary>>=
if(ntrap)
    dotrap();
@


% plan9.c
<<global Signame>>=
char *Signame[] = {
    "sigexit",	"sighup",	"sigint",	"sigquit",
    "sigalrm",	"sigkill",	"sigfpe",	"sigterm",
    0
};
@

% plan9.c
<<global syssigname>>=
char *syssigname[] = {
    "exit",		/* can't happen */
    "hangup",
    "interrupt",
    "quit",		/* can't happen */
    "alarm",
    "kill",
    "sys: fp: ",
    "term",
    0
};
@

% trap.c
% main() -> dotrap() after having interpreter one bytecode
<<function dotrap>>=
void
dotrap(void)
{
    int i;
    struct Var *trapreq;
    struct Word *starval;
    starval = vlook("*")->val;
    while(ntrap) for(i = 0;i!=NSIG;i++) while(trap[i]){
        --trap[i];
        --ntrap;
        if(getpid()!=mypid) Exit(getstatus());
        trapreq = vlook(Signame[i]);
        if(trapreq->fn){
            start(trapreq->fn, trapreq->pc, (struct Var *)0);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)0);
            runq->local->changed = true;
            runq->redir = runq->startredir = 0;
        }
        else if(i==SIGINT || i==SIGQUIT){
            /*
             * run the stack down until we uncover the
             * command reading loop.  Xreturn will exit
             * if there is none (i.e. if this is not
             * an interactive rc.)
             */
            while(!runq->iflag) Xreturn();
        }
        else Exit(getstatus());
    }
}
@


\chapter{Advanced Topics}

\chapter{Conclusion}

\appendix

\chapter{Debugging}


% pcmd.c

<<global nl>>=
char nl='\n';		/* change to semicolon for bourne-proofing */
@

<<constant c0>>=
#define	c0	t->child[0]
@

<<constant c1>>=
#define	c1	t->child[1]
@

<<constant c2>>=
#define	c2	t->child[2]
@

<<function pcmd>>=
void
pcmd(io *f, tree *t)
{
    if(t==nil)
        return;
    assert(f != nil);

    switch(t->type){
    case '$':	pfmt(f, "$%t", c0); break;
    case '"':	pfmt(f, "$\"%t", c0); break;
    case '&':	pfmt(f, "%t&", c0); break;
    case '^':	pfmt(f, "%t^%t", c0, c1); break;
    case '`':	pfmt(f, "`%t", c0); break;
    case ANDAND:pfmt(f, "%t && %t", c0, c1); break;
    case OROR:	pfmt(f, "%t || %t", c0, c1); break;
    case BANG:	pfmt(f, "! %t", c0); break;
    case BRACE:	pfmt(f, "{%t}", c0); break;
    case COUNT:	pfmt(f, "$#%t", c0); break;
    case FN:	pfmt(f, "fn %t %t", c0, c1); break;
    case IF:	pfmt(f, "if%t%t", c0, c1); break;
    case NOT:	pfmt(f, "if not %t", c0); break;
    case PCMD:
    case PAREN:	pfmt(f, "(%t)", c0); break;
    case SUB:	pfmt(f, "$%t(%t)", c0, c1); break;
    case SIMPLE:	pfmt(f, "%t", c0); break;
    case SUBSHELL:	pfmt(f, "@ %t", c0); break;
    case SWITCH:	pfmt(f, "switch %t %t", c0, c1); break;
    case TWIDDLE:	pfmt(f, "~ %t %t", c0, c1); break;
    case WHILE:		pfmt(f, "while %t%t", c0, c1); break;

    case ARGLIST:
        if(c0==nil)
            pfmt(f, "%t", c1);
        else if(c1==nil)
            pfmt(f, "%t", c0);
        else
            pfmt(f, "%t %t", c0, c1);
        break;
    case ';':
        if(c0){
            if(c1)
                pfmt(f, "%t%c%t", c0, nl, c1);
            else pfmt(f, "%t", c0);
        }
        else pfmt(f, "%t", c1);
        break;
    case WORDS:
        if(c0)
            pfmt(f, "%t ", c0);
        pfmt(f, "%t", c1);
        break;
    case FOR:
        pfmt(f, "for(%t", c0);
        if(c1)
            pfmt(f, " in %t", c1);
        pfmt(f, ")%t", c2);
        break;
    case WORD:
        if(t->quoted)
            pfmt(f, "%Q", t->str);
        else pdeglob(f, t->str);
        break;
    case DUP:
        if(t->rtype==DUPFD)
            pfmt(f, ">[%d=%d]", t->fd1, t->fd0); /* yes, fd1, then fd0; read lex.c */
        else
            pfmt(f, ">[%d=]", t->fd0);
        pfmt(f, "%t", c1);
        break;
    case PIPEFD:
    case REDIR:
        switch(t->rtype){
        case HERE:
            pchr(f, '<');
        case READ:
        case RDWR:
            pchr(f, '<');
            if(t->rtype==RDWR)
                pchr(f, '>');
            if(t->fd0!=0)
                pfmt(f, "[%d]", t->fd0);
            break;
        case APPEND:
            pchr(f, '>');
        case WRITE:
            pchr(f, '>');
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
            break;
        }
        pfmt(f, "%t", c0);
        if(c1)
            pfmt(f, " %t", c1);
        break;
    case '=':
        pfmt(f, "%t=%t", c0, c1);
        if(c2)
            pfmt(f, " %t", c2);
        break;
    case PIPE:
        pfmt(f, "%t|", c0);
        if(t->fd1==0){
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
        }
        else pfmt(f, "[%d=%d]", t->fd0, t->fd1);
        pfmt(f, "%t", c1);
        break;

    default:	
        pfmt(f, "bad cmd %d %p %p %p", t->type, c0, c1, c2);
        break;
    }
}
@
%$

<<function pdeglob>>=
void
pdeglob(io *f, char *s)
{
    while(*s){
        if(*s==GLOB)
            s++;
        pchr(f, *s++);
    }
}
@




\section{[[rc -r]] printing runqueue}

<<[[main()]] debug runq>>=
if(flag['r'])
    pfnc(err, runq);
@

% pfnc.c
<<global fname>>=
struct{
    void	(*f)(void);
    char	*name;
} fname[] = {
    Xappend, "Xappend",
    Xassign, "Xassign",
    Xasync, "Xasync",
    Xbackq, "Xbackq",
    Xbang, "Xbang",
    Xcase, "Xcase",
    Xclose, "Xclose",
    Xconc, "Xconc",
    Xcount, "Xcount",
    Xdelfn, "Xdelfn",
    Xdelhere, "Xdelhere",
    Xdol, "Xdol",
    Xdup, "Xdup",
    Xeflag, "Xeflag",
    (void (*)(void))Xerror, "Xerror",
    Xexit, "Xexit",
    Xfalse, "Xfalse",
    Xfn, "Xfn",
    Xfor, "Xfor",
    Xglob, "Xglob",
    Xif, "Xif",
    Xifnot, "Xifnot",
    Xjump, "Xjump",
    Xlocal, "Xlocal",
    Xmark, "Xmark",
    Xmatch, "Xmatch",
    Xpipe, "Xpipe",
    Xpipefd, "Xpipefd",
    Xpipewait, "Xpipewait",
    Xpopm, "Xpopm",
    Xpopredir, "Xpopredir",
    Xqdol, "Xqdol",
    Xrdcmds, "Xrdcmds",
    Xrdfn, "Xrdfn",
    Xrdwr, "Xrdwr",
    Xread, "Xread",
    Xreturn, "Xreturn",
    Xsimple, "Xsimple",
    Xsub, "Xsub",
    Xsubshell, "Xsubshell",
    Xtrue, "Xtrue",
    Xunlocal, "Xunlocal",
    Xwastrue, "Xwastrue",
    Xword, "Xword",
    Xwrite, "Xwrite",
    0
};
@

% fnc??
<<function pfnc>>=
void
pfnc(io *fd, thread *t)
{
    int i;
    void (*fn)(void) = t->code[t->pc].f;
    list *a;

    pfmt(fd, "pid %d cycle %p %d ", getpid(), t->code, t->pc);
    for (i = 0; fname[i].f; i++) 
        if (fname[i].f == fn) {
            pstr(fd, fname[i].name);
            break;
        }
    if (!fname[i].f)
        pfmt(fd, "%p", fn);
    for (a = t->argv; a; a = a->next) 
        pfmt(fd, " (%v)", a->words);
    pchr(fd, '\n');
    flush(fd);
}
@


\chapter{Error Managment}

<<constant ERRMAX>>=
#define ERRMAX 128
@

<<global err>>=
io *err;
@

<<global nerror>>=
int nerror;		/* number of errors encountered during compilation */
@


<<function yyerror>>=
void
yyerror(char *m)
{
    pfmt(err, "rc: ");
    if(runq->cmdfile && !runq->iflag)
        pfmt(err, "%s:%d: ", runq->cmdfile, runq->lineno);
    else if(runq->cmdfile)
        pfmt(err, "%s: ", runq->cmdfile);
    else if(!runq->iflag)
        pfmt(err, "line %d: ", runq->lineno);
    if(tok[0] && tok[0]!='\n')
        pfmt(err, "token %q: ", tok);
    pfmt(err, "%s\n", m);
    flush(err);
    lastword = 0;
    lastdol = 0;
    while(lastc!='\n' && lastc!=EOF) advance();
    nerror++;
    setvar("status", newword(m, (word *)0));
}
@

<<function panic>>=
void
panic(char *s, int n)
{
    pfmt(err, "rc: ");
    pfmt(err, s, n);
    pchr(err, '\n');
    flush(err);
    Abort();
}
@


\chapter{Libc}

\section{Memory managment}

%#define	new(type)	((type *)emalloc(sizeof(type)))

<<function emalloc>>=
void *
emalloc(long n)
{
    void *p = Malloc(n);

    if(p==nil)
        panic("Can't malloc %d bytes", n);
/*	if(err){ pfmt(err, "malloc %d->%p\n", n, p); flush(err); } /**/
    return p;
}
@

% plan9
<<function Malloc>>=
void*
Malloc(ulong n)
{
    return mallocz(n, 1);
}
@


<<function efree>>=
void
efree(void *p)
{
/*	pfmt(err, "free %p\n", p); flush(err); /**/
    if(p)
        free(p);
    else pfmt(err, "free 0\n");
}
@

\section{Command line arguments processing}
% getopt


\section{Buffered IO}
% again, reimplement the same thing

<<constant NBUF>>=
#define	NBUF	512
@

<<struct io>>=
struct Io {
    fdt	fd;
    byte	*bufp, *ebuf, *strp;
    byte	buf[NBUF];
};
@

<<constant EOF (rc/io.h)>>=
#define	EOF	(-1)
@


<<function openfd>>=
io*
openfd(fdt fd)
{
    io *f = new(struct Io);
    f->fd = fd;
    f->bufp = f->ebuf = f->buf;
    f->strp = nil;
    return f;
}
@

<<enum _anon_>>=
enum { Stralloc = 100, };
@

<<function flush>>=
void
flush(io *f)
{
    int n;

    if(f->strp){
        n = f->ebuf - f->strp;
        f->strp = realloc(f->strp, n+Stralloc+1);
        if(f->strp==0)
            panic("Can't realloc %d bytes in flush!", n+Stralloc+1);
        f->bufp = f->strp + n;
        f->ebuf = f->bufp + Stralloc;
        memset(f->bufp, '\0', Stralloc+1);
    }
    else{
        n = f->bufp-f->buf;
        if(n && Write(f->fd, f->buf, n) != n){
            Write(2, "Write error\n", 12);
            if(ntrap)
                dotrap();
        }
        f->bufp = f->buf;
        f->ebuf = f->buf+NBUF;
    }
}
@

\section{Format}

<<global pfmtnest>>=
int pfmtnest = 0;
@

% io.c
% could use fmtinstall instead? or because wanted to be portable to other OSes?
<<function pfmt>>=
void
pfmt(io *f, char *fmt, ...)
{
    va_list ap;
    char err[ERRMAX];

    va_start(ap, fmt);
    pfmtnest++;
    for(;*fmt;fmt++) {
        if(*fmt!='%') {
            pchr(f, *fmt);
            continue;
        }
        if(*++fmt == '\0')		/* "blah%"? */
            break;
        switch(*fmt){
        case 'c':
            pchr(f, va_arg(ap, int));
            break;
        case 'd':
            pdec(f, va_arg(ap, int));
            break;
        case 'o':
            poct(f, va_arg(ap, unsigned));
            break;
        case 'p':
            pptr(f, va_arg(ap, void*));
            break;
        case 'Q':
            pquo(f, va_arg(ap, char *));
            break;
        case 'q':
            pwrd(f, va_arg(ap, char *));
            break;
        case 'r':
            errstr(err, sizeof err); pstr(f, err);
            break;
        case 's':
            pstr(f, va_arg(ap, char *));
            break;
        case 't':
            pcmd(f, va_arg(ap, struct Tree *));
            break;
        case 'v':
            pval(f, va_arg(ap, struct Word *));
            break;
        default:
            pchr(f, *fmt);
            break;
        }
    }
    va_end(ap);
    if(--pfmtnest==0)
        flush(f);
}
@


\section{String conversions}

<<global bp>>=
char *bp;
@

<<function inttoascii>>=
void
inttoascii(char *s, long n)
{
    bp = s;
    iacvt(n);
    *bp='\0';
}
@

<<function iacvt>>=
static void
iacvt(int n)
{
    if(n<0){
        *bp++='-';
        n=-n;	/* doesn't work for n==-inf */
    }
    if(n/10)
        iacvt(n/10);
    *bp++=n%10+'0';
}
@


\chapter{Extra Code}

\ifallcode
#include "Shell_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
