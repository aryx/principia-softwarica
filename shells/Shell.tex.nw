\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:

%thx to this manual, better understand sh:

%history LP-ization:
% - skeleton, mostly copy paste of Kernel.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, builtin, opcode
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the file before
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 Shell
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a shell.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present rc, for run command.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item sh
\item bash
\item zsh
\item scsh
\end{itemize}

% other worthwhile? eshell :)


%bash shellshock context in oct 2014, good idea to look at shell
% implementation :)

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Shell principles}
% for a long time actually there was no (external) shell. Shell was
% part of OS. With unix it changed and shell can be a regular
% user program which then opened the way for complex job control language.


% cf stevens book, shell basis = readline, fork, exec, wait!
% and to handle pipe and redirection it's little variations

% do a minishell before showing rc?

\section{[[rc]] services}

% run command
% pipe, redirection, async
% variable
% mini language with control flow statement
% globbing

% job control?

\section{Input shell language}
% rc PL
% quite similar to bash
% main difference? for var stuff?
% if not instead of else.

\section{Code organization}

%getflags.c: getopt + specific flag setting
%io.c: fmt + buffered IO + specific debug
%pcmd.c: debugging
%pfnc.c: debugging

%plan9.c: for portability

%globals.c:
%subr.c: routines

%tree.c: AST helpers
%lex.c: lexer, yylex()
%syn.y: parser, yyparse() in generated y.tab.c
%code.c: opcode generation from tree, compile() and outcode()

%exec.c: opcode interpreter and main()
%simple.c: Xsimple opcode interpreter, and builtins
%havefork.c: opcodes related to process (Xpipe, Xasync, etc)

%here.c: here document feature
%glob.c: globing feature

%trap.c: interrupt
%var.c: variables




\section{Architecture overview}

% pipeline archi? like compiler?

% string -> lexing(yylex) -> parsing(yyparse) -> ast(treexx) -> bytecode(compile)
%
% but how the parsing chain is called?
% main() -> 
%   - build boostrap
%   - start() setup runq
%   - setup runq->argv
%   - start interpreting bootstrap runq->code[pc-1].f()
%   -
%
%  Xrdcmds() -> yyparse() -> yylex()
%                         -> compile()
% (note that not lexing -> parsing  for efficiency parsing call lexer
%  on demand, so need to keep only one token in memory)

%Xxxx? bytecode?
%execxxx? builtins?


% chapter with a simple traduction of a simple command? like 'ls /' ?

%###############################################################################

\chapter{Core Data Structures}

\section{[[Token]]}

<<token declarations>>=
%token <tree> FOR IN WHILE IF NOT SWITCH FN
%token <tree> WORD
%token <tree> TWIDDLE BANG SUBSHELL 
%token <tree> REDIR DUP PIPE
%token ANDAND OROR
%token COUNT SUB
%token SIMPLE ARGLIST WORDS BRACE PAREN PCMD PIPEFD /* not used in syntax */
@
% was using %term instead of %token (probably for %terminal?)
% also ANDAND were mentioned only in %left, but better declare everything


% can also be ';', see tree3() that actually look for that


% todo: rename tree_of_token?
<<function token>>=
tree*
token(char *str, int type)
{
    tree *t = newtree();

    t->type = type;
    t->str = strdup(str);
    return t;
}
@

\section{Abstract syntax tree [[Tree]]}
% rc has a command language!

% AST tree of the command, ex "ls | wc" =>  ?

<<struct tree>>=
struct Tree {

    // enum<token_kind>
    int	type;
    char *str;

    // array<option<ref_own<Tree>>
    tree	*child[3];

    bool iskw;

    //enum<redirection_kind>
    int	rtype;
    int fd0, fd1;	/* details of REDIR PIPE DUP tokens */
    bool	quoted;

    tree	*next;
};
@


<<global treenodes>>=
// list<ref_own<tree>> (next = Tree.next)
tree *treenodes;
@

<<function newtree>>=
/*
 * create and clear a new tree node, and add it
 * to the node list.
 */
tree*
newtree(void)
{
    tree *t = new(tree);
    t->iskw = false;
    t->str = nil;
    t->child[0] = t->child[1] = t->child[2] = nil;
    t->next = treenodes;
    treenodes = t;
    return t;
}
@

<<function freetree>>=
void
freetree(tree *p)
{
    if(p==nil)
        return;	
    freetree(p->child[0]);
    freetree(p->child[1]);
    freetree(p->child[2]);
    if(p->str)
        efree(p->str);
    efree((char *)p);
}
@


<<function freenodes>>=
void
freenodes(void)
{
    tree *t, *u;
    for(t = treenodes;t;t = u){
        u = t->next;
        if(t->str)
            efree(t->str);
        efree((char *)t);
    }
    treenodes = nil;
}
@
% and does not call freetree()?

% used in syn.y
<<function tree1>>=
tree*
tree1(int type, tree *c0)
{
    return tree3(type, c0, (tree *)nil, (tree *)nil);
}
@

<<function tree2>>=
//@Scheck: used by syn.y
tree* tree2(int type, tree *c0, tree *c1)
{
    return tree3(type, c0, c1, (tree *)nil);
}
@

<<function tree3>>=
tree*
tree3(int type, tree *c0, tree *c1, tree *c2)
{
    tree *t;
    if(type==';'){
        if(c0==nil)
            return c1;
        if(c1==nil)
            return c0;
    }
    t = newtree();
    t->type = type;
    t->child[0] = c0;
    t->child[1] = c1;
    t->child[2] = c2;
    return t;
}
@
% no check for c2 when use ';'? no because binary operator?

\section{Opcode [[Code]] and [[codebuf]]}

<<struct code>>=
/*
 * The first word of any code vector is a reference count.
 * Always create a new reference to a code vector by calling codecopy(.).
 * Always call codefree(.) when deleting a reference.
 */
union Code {
    void	(*f)(void); // Xxxx()
    int	i;
    char	*s;
};
@

<<global codebuf>>=
code *codebuf;				/* compiler output */
@

% first element is a reference count, which is why codecopy()
% does cp[0].i++;

% show bootstrap code?
% or show trace of rc -r ?


% * Opcode routines
% * Arguments on stack (...)
% * Arguments in line [...]
% * Code in line with jump around {...}


% * Xsimple(args)			run command and wait
%
% * Xrdcmds !!! call yyparse()

% * Xmark				mark stack
% * Xword[string]			push string
% * Xpopm(value)			pop value from stack

% * Xcount(name)			push var count
% * Xconc(left, right)			concatenate, push results

% * Xassign(name, val)			assign val to name
% * Xlocal(name, val)			create local variable, assign value
% * Xunlocal				delete local variable
% * Xdol(name)				get variable value

% * Xexit				rc exits with status
% * Xreturn				kill thread
% * Xerror

% * Xread(file)[fd]			open file to read
% * Xwrite(file)[fd]			open file to write
% * Xrdwr(file)[fd]			open file for reading and writing
% * Xappend(file)[fd]			open file to append
% * Xclose[i]				close file descriptor
% * Xdup[i j]				dup file descriptor

% * Xif
% * Xifnot
% * Xbang				complement condition
% * Xwastrue
% * Xfalse{...}				execute {} if false
% * Xtrue{...}				execute {} if true
% * Xcase(pat, value){...}		exec code on match, leave (value) on stack
% * Xmatch(pat, str)			match pattern, set status
% * Xfor(var, list){... Xreturn}	for loop
% * Xjump[addr]				goto

% * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,	wait for both
% * Xpipewait
% * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output, depending on type), push /dev/fd/??

% * Xfn(name){... Xreturn}			define function
% * Xdelfn(name)				delete function definition

% * Xsubshell{... Xexit}		execute {} in a subshell and wait
% * Xasync{... Xexit}			make thread for {}, no wait
% * Xbackq{... Xreturn}			make thread for {}, push stdout

% * Xglob

% * Xdelhere
% * Xeflag
% * Xpopredir
% * Xrdfn
% * Xqdol(name)				concatenate variable components
% * Xsub

% list of opcodes with comments were in exec.c but sorted alphabetically
% better to group them for explanation

\section{[[Thread]] and [[runq]]}
% manage subprocesses

<<struct thread>>=
struct Thread {
    union Code *code;		/* code for this thread */
    int pc;			/* code[pc] is the next instruction */

    int lineno;			/* linenumber */

    // list<ref_own<Var>> (next = Var.next)
    struct Var *local;		/* list of local variables */

    // list<list<ref_own<word>>> (next = List.next)
    struct List *argv;		/* argument stack */

    struct Redir *redir;	/* redirection stack */
    struct Redir *startredir;	/* redir inheritance point */

    char *cmdfile;		/* file name in Xrdcmd */
    struct Io *cmdfd;		/* file descriptor for Xrdcmd */

    bool iflast;			/* static `if not' checking */
    bool eof;			/* is cmdfd at eof? */
    bool iflag;			/* interactive? */

    int pid;			/* process for Xpipewait to wait for */
    char status[NSTATUS];	/* status for Xpipewait */

    tree *treenodes;		/* tree nodes created by this process */

    thread *ret;		/* who continues when this finishes */
};
@

<<global runq>>=
// list<ref_own<Thread>> (next = Thread.ret)
thread *runq;
@

\section{[[Word]], [[List]]}

<<struct word>>=
/*
 * word lists are in correct order,
 * i.e. word0->word1->word2->word3->0
 */
struct Word {
    char *word;

    // Extra
    word *next;
};
@
% could define W = nil so avoid those (word*)nil

<<function newword>>=
word*
newword(char *wd, word *next)
{
    word *p = new(struct Word);
    p->word = strdup(wd);
    p->next = next;
    return p;
}
@


<<function freewords>>=
void
freewords(word *w)
{
    word *nw;
    while(w){
        efree(w->word);
        nw = w->next;
        efree((char *)w);
        w = nw;
    }
}
@





<<struct list>>=
struct List {
    // list<ref_own<Word>> (next = Word.next)
    word *words;

    // Extra
    list *next;
};
@
% so it's actually a list of list (so fast concatenation?)

% see pushlist() below

<<function pushlist>>=
void
pushlist(void)
{
    list *p = new(list);
    p->next = runq->argv;
    p->words = nil;
    runq->argv = p;
}
@

% this list is actually manipulatd by Xmark, etc
% so runq->argv is the argument to the opcodes, not just
% to the simple command!


\section{[[Var]] and [[gvar]]}

<<struct var>>=
struct Var {
    char	*name;		/* ascii name */
    word	*val;		/* value */

    bool	changed;
    code	*fn;		/* pointer to function's code vector */
    int	fnchanged;
    int	pc;		/* pc of start of function */

    var	*next;		/* next on hash or local list */
};
@
% #define V (struct Var*)nil
% like for other soft, or use VarNil?

<<constant NVAR>>=
#define	NVAR	521
@

<<global gvar>>=
// hash<string, ref<Var>> (next = Var.next)
var *gvar[NVAR];		/* hash for globals */
@


<<function setvar>>=
void
setvar(char *name, word *val)
{
    struct Var *v = vlook(name);
    freewords(v->val);
    v->val = val;
    v->changed = true;
}
@

<<function vlook>>=
var*
vlook(char *name)
{
    var *v;
    if(runq)
        for(v = runq->local;v;v = v->next)
            if(strcmp(v->name, name)==0) return v;
    return gvlook(name);
}
@

<<function gvlook>>=
var*
gvlook(char *name)
{
    int h = hash(name, NVAR);
    var *v;
    for(v = gvar[h];v;v = v->next) if(strcmp(v->name, name)==0) return v;
    return gvar[h] = newvar(strdup(name), gvar[h]);
}
@

\chapter{[[main()]]}

\section{Overview}

%plan9.c
<<global Rcmain>>=
char *Rcmain = "/rc/lib/rcmain";
@

<<[[main()]] locals>>=
char *rcmain;
@

<<[[main()]] locals>>=
code bootstrap[17];
@
% indeed 17 lines below about bootstrap. A bit ugly though

<<function main (rc/exec.c)>>=
/*
 * get command line flags, initialize keywords & traps.
 * get values from environment.
 * set $pid, $cflag, $*
 * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)
 * start interpreting code
 */
//@Scheck: not dead! entry point!
void main(int argc, char *argv[])
{
    <<[[main()]] locals>>

    <<[[main()]] argc argv processing, modify flags>>
    
    rcmain = flag['m'] ? flag['m'][0] : Rcmain; 

    err = openfd(2);

    <<[[main()]] initialisation>>
    
    <<[[main()]] initialize [[boostrap]]>>

    // initialize runq with bootstrap code
    start(bootstrap, 1, (var *)nil);

    // initialize runq->argv
    <<[[main()]] bootstrap argv>>

    for(;;){
        <<[[main()]] debug runq>>

        runq->pc++;
        (*runq->code[runq->pc-1].f)();

        <<[[main()]] handing trap if necessary>>
    }
}
@

% err = openfd, use buffered IO lib, see appendix X.y

\section{[[getflags()]]}

<<constant NFLAG>>=
#define	NFLAG	128
@

<<global flag>>=
char **flag[NFLAG];
@


<<global flagset>>=
char *flagset[] = {"<flag>"};
@

<<[[main()]] argc argv processing, modify flags>>=
argc = getflags(argc, argv, "SsrdiIlxepvVc:1m:1[command]", 1);

if(argc==-1)
    usage("[file [arg ...]]");
if(argv[0][0]=='-')
    flag['l'] = flagset;

if(flag['I'])
    flag['i'] = 0;
else 
    if(flag['i']==0 && argc==1 && Isatty(0)) 
       flag['i'] = flagset;
@


\section{Initialisation}

<<global mypid>>=
int mypid;
@

% if things was more functional I would not need those declarations ...
% I would do 'let num = int_to_string(mypid)'
<<[[main()]] locals>>=
char num[12];
@

<<[[main()]] initialisation>>=
kinit();
Trapinit();
Vinit();

mypid = getpid();
inttoascii(num, mypid);

setvar("pid", newword(num, (word *)nil));
setvar("cflag", flag['c']? newword(flag['c'][0], (word *)nil) : (word *)nil);
setvar("rcname", newword(argv[0], (word *)nil));
@

\section{Bootstrapping opcodes}

\ifallcode
<<[[main()]] locals>>=
int i;
@
\fi

% see main() comment:
% * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)

<<[[main()]] initialize [[boostrap]]>>=
memset(bootstrap, 0, sizeof bootstrap);

i = 0;
bootstrap[i++].i = 1; // reference count
bootstrap[i++].f = Xmark;

bootstrap[i++].f = Xword;
bootstrap[i++].s="*";

bootstrap[i++].f = Xassign;
bootstrap[i++].f = Xmark;
bootstrap[i++].f = Xmark;

bootstrap[i++].f = Xword;
bootstrap[i++].s="*";

bootstrap[i++].f = Xdol;

bootstrap[i++].f = Xword;
bootstrap[i++].s = rcmain;

bootstrap[i++].f = Xword;
bootstrap[i++].s=".";

bootstrap[i++].f = Xsimple;
bootstrap[i++].f = Xexit;

bootstrap[i].i = 0;
@

\section{Setting [[runq]], [[start()]]}

% modify runq!
<<function start>>=
void
start(code *c, int pc, var *local)
{
    struct Thread *p = new(struct Thread);

    p->code = codecopy(c);
    p->pc = pc;

    p->argv = nil;
    p->redir = p->startredir = runq ? runq->redir : nil;
    p->local = local;
    p->cmdfile = nil;
    p->cmdfd = nil;
    p->eof = false;
    p->iflag = false;
    p->lineno = 1;

    p->ret = runq;
    runq = p;
}
@

<<function codecopy>>=
code*
codecopy(code *cp)
{
    cp[0].i++;
    return cp;
}
@

\section{Setting [[runq->argv]]}

<<global argv0>>=
/*
 * Start executing the given code at the given pc with the given redirection
 */
char *argv0="rc";
@

<<[[main()]] bootstrap argv>>=
/* prime bootstrap argv */
pushlist();
argv0 = strdup(argv[0]);
for(i = argc-1;i!=0;--i) 
    pushword(argv[i]);
@



<<function pushword>>=
void
pushword(char *wd)
{
    if(runq->argv==nil)
        panic("pushword but no argv!", 0);
    runq->argv->words = newword(wd, runq->argv->words);
}
@

\section{Opcode interpreter loop}

\chapter{Lexing}
% why not using lex?

\section{Overview}

\section{Input}

<<constant EOF (rc/io.h)>>=
#define	EOF	(-1)
@

<<global future>>=
int future = EOF;
@

<<function nextc>>=
/*
 * Look ahead in the input stream
 */
int
nextc(void)
{
    if(future==EOF)
        future = getnext();
    return future;
}
@



<<function getnext>>=
/*
 * read a character from the input stream
 */	
int
getnext(void)
{
    int c;
    static int peekc = EOF;

    if(peekc!=EOF){
        c = peekc;
        peekc = EOF;
        return c;
    }
    if(runq->eof)
        return EOF;
    if(doprompt)
        pprompt();

    c = rchr(runq->cmdfd);
    if(!inquote && c=='\\'){
        c = rchr(runq->cmdfd);
        if(c=='\n' && !incomm){		/* don't continue a comment */
            doprompt = true;
            c=' ';
        }
        else{
            peekc = c;
            c='\\';
        }
    }
    doprompt = doprompt || c=='\n' || c==EOF;
    if(c==EOF)
        runq->eof++; // ->eof = true cleaner no?
    else 
        if(flag['V'] || ndot>=2 && flag['v'])
            pchr(err, c);

    return c;
}
@




<<global lastc>>=
int lastc;
@



<<function advance>>=
/*
 * Consume the lookahead character.
 */

int
advance(void)
{
    int c = nextc();
    lastc = future;
    future = EOF;
    return c;
}
@


<<global doprompt>>=
bool doprompt = true;
@



<<function nextis>>=
bool
nextis(int c)
{
    if(nextc()==c){
        advance();
        return true;
    }
    return false;
}
@

\section{[[yylex()]]}

<<constant NTOK>>=
#define	NTOK	8192		/* maximum bytes in a word (token) */
@

<<global tok>>=
char tok[NTOK + UTFmax];
@


<<global lastword (rc/lex.c)>>=
bool lastword;	/* was the last token read a word or compound word terminator? */
@

<<global lastdol>>=
bool lastdol;	/* was the last token read '$' or '$#' or '"'? */
@

<<global inquote>>=
bool inquote;
@


<<function wordchr>>=
int
wordchr(int c)
{
    return !strchr("\n \t#;&|^$=`'{}()<>", c) && c!=EOF;
}
@
%$




<<function yylex>>=
//@Scheck: called from yyparse()
int yylex(void)
{
    int c;
    int d = nextc();
    char *w = tok;
    struct Tree *t;

    yylval.tree = 0;
    /*
     * Embarassing sneakiness:  if the last token read was a quoted or unquoted
     * WORD then we alter the meaning of what follows.  If the next character
     * is `(', we return SUB (a subscript paren) and consume the `('.  Otherwise,
     * if the next character is the first character of a simple or compound word,
     * we insert a `^' before it.
     */
    if(lastword){
        lastword = false;
        if(d=='('){
            advance();
            strcpy(tok, "( [SUB]");
            return SUB;
        }
        if(wordchr(d) || d=='\'' || d=='`' || d=='$' || d=='"'){ //$
            strcpy(tok, "^");
            return '^';
        }
    }
    inquote = false;
    skipwhite();

    switch(c = advance()){
    case EOF:
        lastdol = false;
        strcpy(tok, "EOF");
        return EOF;
    case '$':
        lastdol = true;
        if(nextis('#')){
            strcpy(tok, "$#");
            return COUNT;
        }
        if(nextis('"')){
            strcpy(tok, "$\"");
            return '"';
        }
        strcpy(tok, "$");
        return '$'; //$
    case '&':
        lastdol = false;
        if(nextis('&')){
            skipnl();
            strcpy(tok, "&&");
            return ANDAND;
        }
        strcpy(tok, "&");
        return '&';
    case '|':
        lastdol = false;
        if(nextis('|')){
            skipnl();
            strcpy(tok, "||");
            return OROR;
        }
        // FALLTHROUGH
    case '<':
    case '>':
        lastdol = false;
        /*
         * funny redirection tokens:
         *	redir:	arrow | arrow '[' fd ']'
         *	arrow:	'<' | '<<' | '>' | '>>' | '|'
         *	fd:	digit | digit '=' | digit '=' digit
         *	digit:	'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
         * some possibilities are nonsensical and get a message.
         */
        *w++=c;
        t = newtree();
        switch(c){
        case '|':
            t->type = PIPE;
            t->fd0 = 1;
            t->fd1 = 0;
            break;
        case '>':
            t->type = REDIR;
            if(nextis(c)){
                t->rtype = APPEND;
                *w++=c;
            }
            else t->rtype = WRITE;
            t->fd0 = 1;
            break;
        case '<':
            t->type = REDIR;
            if(nextis(c)){
                t->rtype = HERE;
                *w++=c;
            } else if (nextis('>')){
                t->rtype = RDWR;
                *w++=c;
            } else t->rtype = READ;
            t->fd0 = 0;
            break;
        }
        if(nextis('[')){
            *w++='[';
            c = advance();
            *w++=c;
            if(c<'0' || '9'<c){
            RedirErr:
                *w = 0;
                yyerror(t->type==PIPE?"pipe syntax"
                        :"redirection syntax");
                return EOF;
            }
            t->fd0 = 0;
            do{
                t->fd0 = t->fd0*10+c-'0';
                *w++=c;
                c = advance();
            }while('0'<=c && c<='9');
            if(c=='='){
                *w++='=';
                if(t->type==REDIR)
                    t->type = DUP;
                c = advance();
                if('0'<=c && c<='9'){
                    t->rtype = DUPFD;
                    t->fd1 = t->fd0;
                    t->fd0 = 0;
                    do{
                        t->fd0 = t->fd0*10+c-'0';
                        *w++=c;
                        c = advance();
                    }while('0'<=c && c<='9');
                }
                else{
                    if(t->type==PIPE)
                        goto RedirErr;
                    t->rtype = CLOSE;
                }
            }
            if(c!=']'
            || t->type==DUP && (t->rtype==HERE || t->rtype==APPEND))
                goto RedirErr;
            *w++=']';
        }
        *w='\0';
        yylval.tree = t;
        if(t->type==PIPE)
            skipnl();
        return t->type;

    case '\'':
        lastdol = false;
        lastword = true;
        inquote = true;
        for(;;){
            c = advance();
            if(c==EOF)
                break;
            if(c=='\''){
                if(nextc()!='\'')
                    break;
                advance();
            }
            w = addutf(w, c);
        }
        if(w!=nil)
            *w='\0';

        t = token(tok, WORD);

        t->quoted = true;
        yylval.tree = t;
        return t->type;
    } // end switch

    if(!wordchr(c)){
        lastdol = false;
        tok[0] = c;
        tok[1]='\0';
        return c;
    }
    for(;;){
        if(c=='*' || c=='[' || c=='?' || c==GLOB)
            w = addtok(w, GLOB);
        w = addutf(w, c);
        c = nextc();
        if(lastdol ? !idchr(c) : !wordchr(c)) break;
        advance();
    }

    lastword = true;
    lastdol = false;
    if(w!=nil)
        *w='\0';
    t = klook(tok);
    if(t->type!=WORD)
        lastword = false;
    t->quoted = false;
    yylval.tree = t;
    return t->type;
}
@
%$



\section{Comments}

<<global incomm>>=
bool incomm;
@

<<function skipwhite>>=
void
skipwhite(void)
{
    int c;
    for(;;){
        c = nextc();
        /* Why did this used to be  if(!inquote && c=='#') ?? */
        if(c=='#'){
            incomm = true;
            for(;;){
                c = nextc();
                if(c=='\n' || c==EOF) {
                    incomm = false;
                    break;
                }
                advance();
            }
        }
        if(c==' ' || c=='\t')
            advance();
        else return;
    }
}
@


<<function skipnl>>=
void
skipnl(void)
{
    int c;
    for(;;){
        skipwhite();
        c = nextc();
        if(c!='\n')
            return;
        advance();
    }
}
@

\section{Keywords and identifiers}

<<constant NKW>>=
#define	NKW	30
@

<<global kw>>=
struct Kw {
    char *name;
    int type;
    struct Kw *next;
} *kw[NKW];
@

<<function kenter>>=
void
kenter(int type, char *name)
{
    int h = hash(name, NKW);
    struct Kw *p = new(struct Kw);
    p->type = type;
    p->name = name;
    p->next = kw[h];
    kw[h] = p;
}
@

<<function hash>>=
unsigned
hash(char *as, int n)
{
    int i = 1;
    unsigned h = 0;
    uchar *s;

    s = (uchar *)as;
    while (*s)
        h += *s++ * i++;
    return h % n;
}
@

% main() -> kinit()
<<function kinit>>=
void
kinit(void)
{
    kenter(FOR, "for");
    kenter(IN, "in");
    kenter(WHILE, "while");
    kenter(IF, "if");
    kenter(NOT, "not");
    kenter(TWIDDLE, "~");
    kenter(BANG, "!");
    kenter(SUBSHELL, "@");
    kenter(SWITCH, "switch");
    kenter(FN, "fn");
}
@


<<function klook>>=
tree*
klook(char *name)
{
    struct Kw *p;
    tree *t = token(name, WORD);

    for(p = kw[hash(name, NKW)];p;p = p->next)
        if(strcmp(p->name, name)==0){
            t->type = p->type;
            t->iskw = true;
            break;
        }
    return t;
}
@
% see token() in Code DS chapter

\section{Operators}

\section{Strings}

\chapter{Parsing}

\section{Overview}

% I assume you understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.tex.nw :) )
%(compared to ocamlyacc can have actions in the middle, and they count
% as indexable elements for the $xxx ($1, $2, etc))

<<rc/syn.y>>=
%{
#include "rc.h"
#include "fns.h"
%}

%union {
 struct Tree *tree;
};

<<token declarations>>
<<priority and associativity declarations>>
<<type declarations>>

%%
<<grammar>>
@

 
<<priority and associativity declarations>>=
/* operator priorities -- lowest first */
%left IF WHILE FOR SWITCH ')' NOT
%left ANDAND OROR
%left BANG SUBSHELL
%left PIPE
%left '^'
%right '$' COUNT '"'
%left SUB
@


<<type declarations>>=
%type<tree> line paren brace body cmdsa cmdsan assign epilog redir
%type<tree> cmd simple first word comword keyword words
@

% if compile return 0 it's an error, so here 1 = an error
% ??? -> yyparse() ?
<<grammar>>=
rc: 
    /*empty*/       { return 1;}
|   line '\n'       { return !compile($1);}

line:   
    cmd
|   cmdsa line      {$$=tree2(';', $1, $2);}

cmdsa:  
    cmd ';'
|   cmd '&'         {$$=tree1('&', $1);}


cmd: 
    /*empty*/           {$$=nil;}
|   simple              {$$=simplemung($1);}

|   brace epilog        {$$=epimung($1, $2);}

|   cmd ANDAND cmd      {$$=tree2(ANDAND, $1, $3);}
|   cmd OROR cmd        {$$=tree2(OROR, $1, $3);}
|   cmd PIPE cmd        {$$=mung2($2, $1, $3);}

|   IF paren {skipnl();} cmd  {$$=mung2($1, $2, $4);}
|   IF NOT   {skipnl();} cmd  {$$=mung1($2, $4);}

 /*
  * if ``words'' is nil, we need a tree element to distinguish between 
  * for(i in ) and for(i), the former being a loop over the empty set
  * and the latter being the implicit argument loop.  so if $5 is nil
  * (the empty set), we represent it as "()".  don't parenthesize non-nil
  * functions, to avoid growing parentheses every time we reread the
  * definition.
  */
|   FOR '(' word IN words ')' {skipnl();} cmd
    {$$=mung3($1, $3,    $5 ? $5 : tree1(PAREN, $5), $8);}

|   FOR '(' word ')' {skipnl();} cmd
    {$$=mung3($1, $3, (struct Tree *)0, $6);}

|   WHILE paren {skipnl();} cmd    {$$=mung2($1, $2, $4);}
|   SWITCH word {skipnl();} brace  {$$=tree2(SWITCH, $2, $4);}

|   TWIDDLE word words  {$$=mung2($1, $2, $3);}

|   redir cmd  %prec BANG   {$$=mung2($1, $1->child[0], $2);}
|   assign cmd %prec BANG   {$$=mung3($1, $1->child[0], $1->child[1], $2);}

|   BANG cmd            {$$=mung1($1, $2);}
|   SUBSHELL cmd        {$$=mung1($1, $2);}

|   FN words brace  {$$=tree2(FN, $2, $3);}
|   FN words        {$$=tree1(FN, $2);}


brace:  '{' body '}'        {$$=tree1(BRACE, $2);}
paren:  '(' body ')'        {$$=tree1(PCMD, $2);}

body:   
    cmd
|   cmdsan body     {$$=tree2(';', $1, $2);}

cmdsan: 
    cmdsa
|   cmd '\n'

epilog: 
    /*empty*/           {$$=nil;}
|   redir epilog        {$$=mung2($1, $1->child[0], $2);}


assign: first '=' word      {$$=tree2('=', $1, $3);}


redir:  
    REDIR word      {$$=mung1($1, $1->rtype==HERE ? heredoc($2) : $2);}
|   DUP


simple:
    first
|   simple word         {$$=tree2(ARGLIST, $1, $2);}
|   simple redir        {$$=tree2(ARGLIST, $1, $2);}

/* diff with word? first cannot be a keyword */
first:  
    comword 
|   first '^' word      {$$=tree2('^', $1, $3);}

word:   
    comword
|   word '^' word       {$$=tree2('^', $1, $3);}
|   keyword             {lastword=true; $1->type=WORD;}

comword: 
    WORD
|   '$' word       {$$=tree1('$', $2);}
|   '$' word SUB words ')'  {$$=tree2(SUB, $2, $4);}
|   COUNT word      {$$=tree1(COUNT, $2);}
|   '"' word        {$$=tree1('"', $2);}
|   '`' brace       {$$=tree1('`', $2);}
|   '(' words ')'   {$$=tree1(PAREN, $2);}
|   REDIR brace     {$$=mung1($1, $2); $$->type=PIPEFD;}

keyword: FOR|IN|WHILE|IF|NOT|TWIDDLE|BANG|SUBSHELL|SWITCH|FN

words: 
    /*empty*/       {$$=(struct Tree*)nil;}
|   words word      {$$=tree2(WORDS, $1, $2);}
@
%$


\ifallcode
<<constant YYMAXDEPTH>>=
//@Scheck: used in y.tab.c
#define	YYMAXDEPTH	500
@
\fi


\section{Line}

\section{Simple commands}

\section{Operators}
% && ||  |  &  !?
% >> << > <

\section{Control flow statements}

\section{XXX}

\chapter{Opcode Generation and Interpretation}
% in shell context???
% or Code generation? or Bytecode generation?
% or merge Opcode Generation and Intepretation?
% because helps to see the code generated from a tree

\section{Overview}

\section{[[compile()]]}

% see codebuf in Core DS chapter (could be moved here too)

<<global codep>>=
// idx in codebuf
int codep;
@

<<global ncode>>=
int ncode;
@

% return 0 for error 1 for ok
<<function compile>>=
//@Scheck: called from syn.y
int compile(tree *t)
{
    ncode = 100;
    codep = 0;
    codebuf = (code *)emalloc(ncode*sizeof(code));

    emiti(0);			/* reference count */

    outcode(t, flag['e'] ? true : false);

    if(nerror){
        efree((char *)codebuf);
        return 0;
    }

    readhere();

    emitf(Xreturn);
    emitf(nil);

    return 1;
}
@

<<function emiti>>=
#define	emiti(x) ((codep!=ncode || morecode()), codebuf[codep].i = (x), codep++)
@
% return codep before! so can store for creating jmp

<<function emitf>>=
#define	emitf(x) ((codep!=ncode || morecode()), codebuf[codep].f = (x), codep++)
@

<<function emits>>=
#define	emits(x) ((codep!=ncode || morecode()), codebuf[codep].s = (x), codep++)
@


% growing array
<<function morecode>>=
//@Scheck: used by the macros above (why marked as dead then??? TODO)
int morecode(void)
{
    ncode+=100;
    codebuf = (code *)realloc((char *)codebuf, ncode*sizeof codebuf[0]);
    if(codebuf==nil)
        panic("Can't realloc %d bytes in morecode!", ncode*sizeof(code));
    return 0;
}
@


\section{[[outcode()]]}

% modify codebuf via all those emitxxx()
<<function outcode>>=
void
outcode(tree *t, bool eflag)
{
    int p, q;
    tree *tt;

    if(t==nil)
        return;
    if(t->type!=NOT && t->type!=';')
        runq->iflast = false;

    switch(t->type){
    case SIMPLE:
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xsimple);
        if(eflag)
            emitf(Xeflag);
        break;


    case '$': //$
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xdol);
        break;
    case '"':
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xqdol);
        break;

    case SUB:
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xmark);
        outcode(c1, eflag);
        emitf(Xsub);
        break;

    case '&':
        emitf(Xasync);
        if(havefork){
            p = emiti(0);
            outcode(c0, eflag);
            emitf(Xexit);
            stuffdot(p);
        } else
            emits(fnstr(c0));
        break;
    case ';':
        outcode(c0, eflag);
        outcode(c1, eflag);
        break;

    case '^':
        emitf(Xmark);
        outcode(c1, eflag);
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xconc);
        break;
    case '`':
        emitf(Xbackq);
        if(havefork){
            p = emiti(0);
            outcode(c0, 0);
            emitf(Xexit);
            stuffdot(p);
        } else
            emits(fnstr(c0));
        break;

    case ANDAND:
        outcode(c0, false);
        emitf(Xtrue);
        p = emiti(0);
        outcode(c1, eflag);
        stuffdot(p);
        break;
    case OROR:
        outcode(c0, 0);
        emitf(Xfalse);
        p = emiti(0);
        outcode(c1, eflag);
        stuffdot(p);
        break;

    case ARGLIST:
        outcode(c1, eflag);
        outcode(c0, eflag);
        break;

    case BANG:
        outcode(c0, eflag);
        emitf(Xbang);
        break;

    case PCMD:
    case BRACE:
        outcode(c0, eflag);
        break;
    case COUNT:
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xcount);
        break;
    case FN:
        emitf(Xmark);
        outcode(c0, eflag);
        if(c1){
            emitf(Xfn);
            p = emiti(0);
            emits(fnstr(c1));
            outcode(c1, eflag);
            emitf(Xunlocal);	/* get rid of $* */ //$
            emitf(Xreturn);
            stuffdot(p);
        }
        else
            emitf(Xdelfn);
        break;

    case IF:
        outcode(c0, false);
        emitf(Xif);
        p = emiti(0);
        outcode(c1, eflag);
        emitf(Xwastrue);
        stuffdot(p);
        break;
    case NOT:
        if(!runq->iflast)
            yyerror("`if not' does not follow `if(...)'");
        emitf(Xifnot);
        p = emiti(0);
        outcode(c0, eflag);
        stuffdot(p);
        break;

    case PAREN:
        outcode(c0, eflag);
        break;


    case SUBSHELL:
        emitf(Xsubshell);
        if(havefork){
            p = emiti(0);
            outcode(c0, eflag);
            emitf(Xexit);
            stuffdot(p);
        } else
            emits(fnstr(c0));
        if(eflag)
            emitf(Xeflag);
        break;

    case SWITCH:
        codeswitch(t, eflag);
        break;

    case TWIDDLE:
        emitf(Xmark);
        outcode(c1, eflag);
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xmatch);
        if(eflag)
            emitf(Xeflag);
        break;

    case WHILE:
        q = codep;
        outcode(c0, false);
        if(q==codep)
            emitf(Xsettrue);	/* empty condition == while(true) */
        emitf(Xtrue);
        p = emiti(0);
        outcode(c1, eflag);
        emitf(Xjump);
        emiti(q);
        stuffdot(p);
        break;

    case WORDS:
        outcode(c1, eflag);
        outcode(c0, eflag);
        break;

    case FOR:
        emitf(Xmark);
        if(c1){
            outcode(c1, eflag);
            emitf(Xglob);
        }
        else{
            emitf(Xmark);
            emitf(Xword);
            emits(strdup("*"));
            emitf(Xdol);
        }
        emitf(Xmark);		/* dummy value for Xlocal */
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xlocal);
        p = emitf(Xfor);
        q = emiti(0);
        outcode(c2, eflag);
        emitf(Xjump);
        emiti(p);
        stuffdot(q);
        emitf(Xunlocal);
        break;

    case WORD:
        emitf(Xword);
        emits(strdup(t->str));
        break;

    case DUP:
        if(t->rtype==DUPFD){
            emitf(Xdup);
            emiti(t->fd0);
            emiti(t->fd1);
        }
        else{
            emitf(Xclose);
            emiti(t->fd0);
        }
        outcode(c1, eflag);
        emitf(Xpopredir);
        break;

    case PIPEFD:
        emitf(Xpipefd);
        emiti(t->rtype);
        if(havefork){
            p = emiti(0);
            outcode(c0, eflag);
            emitf(Xexit);
            stuffdot(p);
        } else {
            emits(fnstr(c0));
        }
        break;

    case REDIR:
        emitf(Xmark);
        outcode(c0, eflag);
        emitf(Xglob);
        switch(t->rtype){
        case APPEND:
            emitf(Xappend);
            break;
        case WRITE:
            emitf(Xwrite);
            break;
        case READ:
        case HERE:
            emitf(Xread);
            break;
        case RDWR:
            emitf(Xrdwr);
            break;
        }
        emiti(t->fd0);
        outcode(c1, eflag);
        emitf(Xpopredir);
        break;

    case '=':
        tt = t;
        for(;t && t->type=='=';t = c2);
        if(t){					/* var=value cmd */
            for(t = tt;t->type=='=';t = c2){
                emitf(Xmark);
                outcode(c1, eflag);
                emitf(Xmark);
                outcode(c0, eflag);
                emitf(Xlocal);		/* push var for cmd */
            }
            outcode(t, eflag);		/* gen. code for cmd */
            for(t = tt; t->type == '='; t = c2)
                emitf(Xunlocal);	/* pop var */
        }
        else{					/* var=value */
            for(t = tt;t;t = c2){
                emitf(Xmark);
                outcode(c1, eflag);
                emitf(Xmark);
                outcode(c0, eflag);
                emitf(Xassign);	/* set var permanently */
            }
        }
        t = tt;	/* so tests below will work */
        break;

    case PIPE:
        emitf(Xpipe);
        emiti(t->fd0);
        emiti(t->fd1);
        if(havefork){
            p = emiti(0);
            q = emiti(0);
            outcode(c0, eflag);
            emitf(Xexit);
            stuffdot(p);
        } else {
            emits(fnstr(c0));
            q = emiti(0);
        }
        outcode(c1, eflag);
        emitf(Xreturn);
        stuffdot(q);
        emitf(Xpipewait);
        break;

    default:
        pfmt(err, "bad type %d in outcode\n", t->type);
        break;
    }

    if(t->type!=NOT && t->type!=';')
        runq->iflast = t->type==IF;
    else 
       if(c0) 
           runq->iflast = c0->type==IF;
}
@
%$

\section{Simple commands}

\section{Pipe}

\section{Redirection}

<<struct redir>>=
struct Redir {
    char type;			/* what to do */
    short from, to;			/* what to do it to */
    struct Redir *next;		/* what else to do (reverse order) */
};
@

\section{Control flow statements}

\section{XXX}

\chapter{Builtins}

% plan9.c
<<global Builtin>>=
builtin Builtin[] = {
    "cd",		execcd,
    "exit",		execexit,
    "exec",		execexec,	/* but with popword first */
    ".",		execdot,
    "eval",		execeval,
    "whatis",		execwhatis,

    "shift",		execshift,
    "wait",		execwait,
    "finit",		execfinit,
    "flag",		execflag,
    "rfork",		execnewpgrp,
    0
};
@

\section{[[$ cd]]}
%$

<<function execcd>>=
void
execcd(void)
{
    word *a = runq->argv->words;
    word *cdpath;
    char *dir;

    setstatus("can't cd");
    cdpath = vlook("cdpath")->val;
    switch(count(a)){
    default:
        pfmt(err, "Usage: cd [directory]\n");
        break;
    case 2:
        if(a->next->word[0]=='/' || cdpath==0)
            cdpath = &nullpath;
        for(; cdpath; cdpath = cdpath->next){
            if(cdpath->word[0] != '\0')
                dir = appfile(cdpath->word, a->next->word);
            else
                dir = strdup(a->next->word);

            if(dochdir(dir) >= 0){
                if(cdpath->word[0] != '\0' &&
                    strcmp(cdpath->word, ".") != 0)
                    pfmt(err, "%s\n", dir);
                free(dir);
                setstatus("");
                break;
            }
            free(dir);
        }
        if(cdpath==0)
            pfmt(err, "Can't cd %s: %r\n", a->next->word);
        break;
    case 1:
        a = vlook("home")->val;
        if(count(a)>=1){
            if(dochdir(a->word)>=0)
                setstatus("");
            else
                pfmt(err, "Can't cd %s: %r\n", a->word);
        }
        else
            pfmt(err, "Can't cd -- $home empty\n");
        break;
    }
    poplist();
}
@
%$


<<function dochdir>>=
int
dochdir(char *word)
{
    /* report to /dev/wdir if it exists and we're interactive */
    static int wdirfd = -2;
    if(chdir(word)<0) return -1;
    if(flag['i']!=0){
        if(wdirfd==-2)	/* try only once */
            wdirfd = open("/dev/wdir", OWRITE|OCEXEC);
        if(wdirfd>=0) {
            //fcntl(wdirfd, F_SETFD, FD_CLOEXEC);
            write(wdirfd, word, strlen(word));
        }
    }
    return 1;
}
@

\section{[[$ exit]]}
%$

<<function execexit>>=
void
execexit(void)
{
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: exit [status]\nExiting anyway\n");
    case 2:
        setstatus(runq->argv->words->next->word);
    case 1:	Xexit();
    }
}
@

\section{[[$ exec]]}
%$

<<function execexec>>=
void
execexec(void)
{
    popword();	/* "exec" */
    if(runq->argv->words==0){
        Xerror1("empty argument list");
        return;
    }
    doredir(runq->redir);
    Execute(runq->argv->words, searchpath(runq->argv->words->word));
    poplist();
}
@

\section{[[$ .]]}
%$ 

<<global dotcmds>>=
union Code dotcmds[14];
@

<<global ndot>>=
/*
 * How many dot commands have we executed?
 * Used to ensure that -v flag doesn't print rcmain.
 */
int ndot;
@

<<global eflagok>>=
bool eflagok;	/* kludge flag so that -e doesn't exit in startup */
@


<<function execdot>>=
void
execdot(void)
{
    bool iflag = false;
    int fd;
    list *av;
    thread *p = runq;
    char *zero, *file;
    word *path;
    static bool first = true;

    if(first){
        dotcmds[0].i = 1;
        dotcmds[1].f = Xmark;
        dotcmds[2].f = Xword;
        dotcmds[3].s="0";
        dotcmds[4].f = Xlocal;
        dotcmds[5].f = Xmark;
        dotcmds[6].f = Xword;
        dotcmds[7].s="*";
        dotcmds[8].f = Xlocal;
        dotcmds[9].f = Xrdcmds;
        dotcmds[10].f = Xunlocal;
        dotcmds[11].f = Xunlocal;
        dotcmds[12].f = Xreturn;
        first = false;
    }
    else
        eflagok = true;
    popword();
    if(p->argv->words && strcmp(p->argv->words->word, "-i")==0){
        iflag = true;
        popword();
    }
    /* get input file */
    if(p->argv->words==0){
        Xerror1("Usage: . [-i] file [arg ...]");
        return;
    }
    zero = strdup(p->argv->words->word);
    popword();
    fd = -1;
    for(path = searchpath(zero); path; path = path->next){
        if(path->word[0] != '\0')
            file = appfile(path->word, zero);
        else
            file = strdup(zero);

        fd = open(file, 0);
        free(file);
        if(fd >= 0)
            break;
        if(strcmp(file, "/dev/stdin")==0){	/* for sun & ucb */
            fd = Dup1(0);
            if(fd>=0)
                break;
        }
    }
    if(fd<0){
        pfmt(err, "%s: ", zero);
        setstatus("can't open");
        Xerror(".: can't open");
        return;
    }

    /* set up for a new command loop */
    start(dotcmds, 1, (struct Var *)nil);

    pushredir(RCLOSE, fd, 0);
    runq->cmdfile = zero;
    runq->cmdfd = openfd(fd);
    runq->iflag = iflag;
    runq->iflast = false;
    /* push $* value */
    pushlist();
    runq->argv->words = p->argv->words;
    /* free caller's copy of $* */
    av = p->argv;
    p->argv = av->next;
    efree((char *)av);
    /* push $0 value */
    pushlist();
    pushword(zero);
    ndot++;
}
@
%$

\section{[[$ eval]]}
%$

<<function execeval>>=
void
execeval(void)
{
    char *cmdline, *s, *t;
    int len = 0;
    word *ap;
    if(count(runq->argv->words)<=1){
        Xerror1("Usage: eval cmd ...");
        return;
    }
    eflagok = true;
    for(ap = runq->argv->words->next;ap;ap = ap->next)
        len+=1+strlen(ap->word);
    cmdline = emalloc(len);
    s = cmdline;
    for(ap = runq->argv->words->next;ap;ap = ap->next){
        for(t = ap->word;*t;) *s++=*t++;
        *s++=' ';
    }
    s[-1]='\n';
    poplist();
    execcmds(opencore(cmdline, len));
    efree(cmdline);
}
@

\section{[[$ whatis]]}
%$

<<function execwhatis>>=
void
execwhatis(void){	/* mildly wrong -- should fork before writing */
    word *a, *b, *path;
    var *v;
    struct Builtin *bp;
    char *file;
    struct Io out[1];
    int found, sep;
    a = runq->argv->words->next;
    if(a==0){
        Xerror1("Usage: whatis name ...");
        return;
    }
    setstatus("");
    memset(out, 0, sizeof out);
    out->fd = mapfd(1);
    out->bufp = out->buf;
    out->ebuf = &out->buf[NBUF];
    out->strp = 0;
    for(;a;a = a->next){
        v = vlook(a->word);
        if(v->val){
            pfmt(out, "%s=", a->word);
            if(v->val->next==0)
                pfmt(out, "%q\n", v->val->word);
            else{
                sep='(';
                for(b = v->val;b && b->word;b = b->next){
                    pfmt(out, "%c%q", sep, b->word);
                    sep=' ';
                }
                pfmt(out, ")\n");
            }
            found = 1;
        }
        else
            found = 0;
        v = gvlook(a->word);
        if(v->fn)
            pfmt(out, "fn %q %s\n", v->name, v->fn[v->pc-1].s);
        else{
            for(bp = Builtin;bp->name;bp++)
                if(strcmp(a->word, bp->name)==0){
                    pfmt(out, "builtin %s\n", a->word);
                    break;
                }
            if(!bp->name){
                for(path = searchpath(a->word); path;
                    path = path->next){
                    if(path->word[0] != '\0')
                        file = appfile(path->word,
                            a->word);
                    else
                        file = strdup(a->word);
                    if(Executable(file)){
                        pfmt(out, "%s\n", file);
                        free(file);
                        break;
                    }
                    free(file);
                }
                if(!path && !found){
                    pfmt(err, "%s: not found\n", a->word);
                    setstatus("not found");
                }
            }
        }
    }
    poplist();
    flush(err);
}
@

\section{Other builtins]}

%rfork
<<function execnewpgrp>>=
void
execnewpgrp(void)
{
    int arg;
    char *s;
    switch(count(runq->argv->words)){
    case 1:
        arg = RFENVG|RFNAMEG|RFNOTEG;
        break;
    case 2:
        arg = 0;
        for(s = runq->argv->words->next->word;*s;s++) switch(*s){
        default:
            goto Usage;
        case 'n':
            arg|=RFNAMEG;  break;
        case 'N':
            arg|=RFCNAMEG;
            break;
        case 'm':
            arg|=RFNOMNT;  break;
        case 'e':
            arg|=RFENVG;   break;
        case 'E':
            arg|=RFCENVG;  break;
        case 's':
            arg|=RFNOTEG;  break;
        case 'f':
            arg|=RFFDG;    break;
        case 'F':
            arg|=RFCFDG;   break;
        }
        break;
    default:
    Usage:
        pfmt(err, "Usage: %s [fnesFNEm]\n", runq->argv->words->word);
        setstatus("rfork usage");
        poplist();
        return;
    }
    if(rfork(arg)==-1){
        pfmt(err, "rc: %s failed\n", runq->argv->words->word);
        setstatus("rfork failed");
    }
    else
        setstatus("");
    poplist();
}
@


<<function execwait>>=
void
execwait(void)
{
    switch(count(runq->argv->words)){
    default:
        Xerror1("Usage: wait [pid]");
        return;
    case 2:
        Waitfor(atoi(runq->argv->words->next->word), 0);
        break;
    case 1:
        Waitfor(-1, 0);
        break;
    }
    poplist();
}
@

<<function execflag>>=
void
execflag(void)
{
    char *letter, *val;
    switch(count(runq->argv->words)){
    case 2:
        setstatus(flag[(uchar)runq->argv->words->next->word[0]]?"":"flag not set");
        break;
    case 3:
        letter = runq->argv->words->next->word;
        val = runq->argv->words->next->next->word;
        if(strlen(letter)==1){
            if(strcmp(val, "+")==0){
                flag[(uchar)letter[0]] = flagset;
                break;
            }
            if(strcmp(val, "-")==0){
                flag[(uchar)letter[0]] = 0;
                break;
            }
        }
    default:
        Xerror1("Usage: flag [letter] [+-]");
        return;
    }
    poplist();
}
@

<<function execshift>>=
void
execshift(void)
{
    int n;
    word *a;
    var *star;
    switch(count(runq->argv->words)){
    default:
        pfmt(err, "Usage: shift [n]\n");
        setstatus("shift usage");
        poplist();
        return;
    case 2:
        n = atoi(runq->argv->words->next->word);
        break;
    case 1:
        n = 1;
        break;
    }
    star = vlook("*");
    for(;n && star->val;--n){
        a = star->val->next;
        efree(star->val->word);
        efree((char *)star->val);
        star->val = a;
        star->changed = true;
    }
    setstatus("");
    poplist();
}
@

\chapter{Variables}

% diff with bash here, see rc design document

%$#x


\chapter{Prompt}

<<global promptstr>>=
char *promptstr;
@

\chapter{Environment}

\chapter{Globbing}

<<global globname>>=
char *globname;
@

<<global globv>>=
struct Word *globv;
@

<<function deglob>>=
/*
 * delete all the GLOB marks from s, in place
 */
void
deglob(void *as)
{
    char *s = as;
    char *t = s;
    do{
        if(*t==GLOB)
            t++;
        *s++=*t;
    }while(*t++);
}
@

<<function globcmp>>=
int
globcmp(const void *s, const void *t)
{
    return strcmp(*(char**)s, *(char**)t);
}
@

<<function globsort>>=
void
globsort(word *left, word *right)
{
    char **list;
    word *a;
    int n = 0;
    for(a = left;a!=right;a = a->next) n++;
    list = (char **)emalloc(n*sizeof(char *));
    for(a = left,n = 0;a!=right;a = a->next,n++) list[n] = a->word;
    qsort((void *)list, n, sizeof(void *), globcmp);
    for(a = left,n = 0;a!=right;a = a->next,n++) a->word = list[n];
    efree((char *)list);
}
@

<<function globdir>>=
/*
 * Push names prefixed by globname and suffixed by a match of p onto the astack.
 * namep points to the end of the prefix in globname.
 */
void
globdir(uchar *p, uchar *namep)
{
    uchar *t, *newp;
    int f;
    /* scan the pattern looking for a component with a metacharacter in it */
    if(*p=='\0'){
        globv = newword(globname, globv);
        return;
    }
    t = namep;
    newp = p;
    while(*newp){
        if(*newp==GLOB)
            break;
        *t=*newp++;
        if(*t++=='/'){
            namep = t;
            p = newp;
        }
    }
    /* If we ran out of pattern, append the name if accessible */
    if(*newp=='\0'){
        *t='\0';
        if(access(globname, 0)==0)
            globv = newword(globname, globv);
        return;
    }
    /* read the directory and recur for any entry that matches */
    *namep='\0';
    if((f = Opendir(globname[0]?globname:"."))<0) return;
    while(*newp!='/' && *newp!='\0') newp++;
    while(Readdir(f, namep, *newp=='/')){
        if(matchfn(namep, p)){
            for(t = namep;*t;t++);
            globdir(newp, t);
        }
    }
    Closedir(f);
}
@

<<function glob>>=
/*
 * Push all file names matched by p on the current thread's stack.
 * If there are no matches, the list consists of p.
 */
void
glob(void *ap)
{
    uchar *p = ap;
    word *svglobv = globv;
    int globlen = Globsize(ap);

    if(!globlen){
        deglob(p);
        globv = newword((char *)p, globv);
        return;
    }
    globname = emalloc(globlen);
    globname[0]='\0';
    globdir(p, (uchar *)globname);
    efree(globname);
    if(svglobv==globv){
        deglob(p);
        globv = newword((char *)p, globv);
    }
    else
        globsort(globv, svglobv);
}
@

<<function equtf>>=
/*
 * Do p and q point at equal utf codes
 */
int
equtf(uchar *p, uchar *q)
{
    Rune pr, qr;
    if(*p!=*q)
        return 0;
    
    chartorune(&pr, (char*)p);
    chartorune(&qr, (char*)q);
    return pr == qr;
}
@

<<function nextutf>>=
/*
 * Return a pointer to the next utf code in the string,
 * not jumping past nuls in broken utf codes!
 */
uchar*
nextutf(uchar *p)
{
    Rune dummy;
    return p + chartorune(&dummy, (char*)p);
}
@

<<function unicode>>=
/*
 * Convert the utf code at *p to a unicode value
 */
int
unicode(uchar *p)
{
    Rune r;

    chartorune(&r, (char*)p);
    return r;
}
@

<<function matchfn>>=
/*
 * Does the string s match the pattern p
 * . and .. are only matched by patterns starting with .
 * * matches any sequence of characters
 * ? matches any single character
 * [...] matches the enclosed list of characters
 */
int
matchfn(void *as, void *ap)
{
    uchar *s = as, *p = ap;

    if(s[0]=='.' && (s[1]=='\0' || s[1]=='.' && s[2]=='\0') && p[0]!='.')
        return 0;
    return match(s, p, '/');
}
@

<<function match>>=
int
match(void *as, void *ap, int stop)
{
    int compl, hit, lo, hi, t, c;
    uchar *s = as, *p = ap;

    for(; *p!=stop && *p!='\0'; s = nextutf(s), p = nextutf(p)){
        if(*p!=GLOB){
            if(!equtf(p, s)) return 0;
        }
        else switch(*++p){
        case GLOB:
            if(*s!=GLOB)
                return 0;
            break;
        case '*':
            for(;;){
                if(match(s, nextutf(p), stop)) return 1;
                if(!*s)
                    break;
                s = nextutf(s);
            }
            return 0;
        case '?':
            if(*s=='\0')
                return 0;
            break;
        case '[':
            if(*s=='\0')
                return 0;
            c = unicode(s);
            p++;
            compl=*p=='~';
            if(compl)
                p++;
            hit = 0;
            while(*p!=']'){
                if(*p=='\0')
                    return 0;		/* syntax error */
                lo = unicode(p);
                p = nextutf(p);
                if(*p!='-')
                    hi = lo;
                else{
                    p++;
                    if(*p=='\0')
                        return 0;	/* syntax error */
                    hi = unicode(p);
                    p = nextutf(p);
                    if(hi<lo){ t = lo; lo = hi; hi = t; }
                }
                if(lo<=c && c<=hi)
                    hit = 1;
            }
            if(compl)
                hit=!hit;
            if(!hit)
                return 0;
            break;
        }
    }
    return *s=='\0';
}
@

<<function globlist1>>=
void
globlist1(word *gl)
{
    if(gl){
        globlist1(gl->next);
        glob(gl->word);
    }
}
@

<<function globlist>>=
void
globlist(void)
{
    word *a;
    globv = 0;
    globlist1(runq->argv->words);
    poplist();
    pushlist();
    if(globv){
        for(a = globv;a->next;a = a->next);
        a->next = runq->argv->words;
        runq->argv->words = globv;
    }
}
@


\chapter{Signals}

<<constant NSIG>>=
#define	NSIG	32
@

<<constant SIGINT>>=
#define	SIGINT	2
@

<<constant SIGQUIT>>=
#define	SIGQUIT	3
@

<<global ntrap>>=
int ntrap;				/* number of outstanding traps */
@

<<global trap>>=
int trap[NSIG];				/* number of outstanding traps per type */
@


<<[[main()]] handing trap if necessary>>=
if(ntrap)
    dotrap();
@


% plan9.c
<<global Signame>>=
char *Signame[] = {
    "sigexit",	"sighup",	"sigint",	"sigquit",
    "sigalrm",	"sigkill",	"sigfpe",	"sigterm",
    0
};
@

% plan9.c
<<global syssigname>>=
char *syssigname[] = {
    "exit",		/* can't happen */
    "hangup",
    "interrupt",
    "quit",		/* can't happen */
    "alarm",
    "kill",
    "sys: fp: ",
    "term",
    0
};
@

% trap.c
% main() -> dotrap() after having interpreter one bytecode
<<function dotrap>>=
void
dotrap(void)
{
    int i;
    struct Var *trapreq;
    struct Word *starval;
    starval = vlook("*")->val;
    while(ntrap) for(i = 0;i!=NSIG;i++) while(trap[i]){
        --trap[i];
        --ntrap;
        if(getpid()!=mypid) Exit(getstatus());
        trapreq = vlook(Signame[i]);
        if(trapreq->fn){
            start(trapreq->fn, trapreq->pc, (struct Var *)0);
            runq->local = newvar(strdup("*"), runq->local);
            runq->local->val = copywords(starval, (struct Word *)0);
            runq->local->changed = true;
            runq->redir = runq->startredir = 0;
        }
        else if(i==SIGINT || i==SIGQUIT){
            /*
             * run the stack down until we uncover the
             * command reading loop.  Xreturn will exit
             * if there is none (i.e. if this is not
             * an interactive rc.)
             */
            while(!runq->iflag) Xreturn();
        }
        else Exit(getstatus());
    }
}
@


\chapter{Advanced Topics}

\section{Here documents}

<<struct here>>=
struct Here {
    tree	*tag;
    char	*name;
    struct Here *next;
};
@

<<global here>>=
struct Here *here;
@


<<global ehere>>=
struct Here **ehere;
@


<<constant NLINE>>=
/*
 * bug: lines longer than NLINE get split -- this can cause spurious
 * missubstitution, or a misrecognized EOF marker.
 */
#define	NLINE	4096
@

<<function readhere>>=
void
readhere(void)
{
    int c, subst;
    char *s, *tag;
    char line[NLINE+1];
    io *f;
    struct Here *h, *nexth;

    for(h = here; h; h = nexth){
        subst = !h->tag->quoted;
        tag = h->tag->str;
        c = Creat(h->name);
        if(c < 0)
            yyerror("can't create here document");
        f = openfd(c);
        s = line;
        pprompt();
        while((c = rchr(runq->cmdfd)) != EOF){
            if(c == '\n' || s == &line[NLINE]){
                *s = '\0';
                if(tag && strcmp(line, tag) == 0)
                    break;
                if(subst)
                    psubst(f, (uchar *)line);
                else
                    pstr(f, line);
                s = line;
                if(c == '\n'){
                    pprompt();
                    pchr(f, c);
                }else
                    *s++ = c;
            }else
                *s++ = c;
        }
        flush(f);
        closeio(f);
        cleanhere(h->name);
        nexth = h->next;
        efree((char *)h);
    }
    here = nil;
    doprompt = true;
}
@

\chapter{Conclusion}

\appendix

\chapter{Debugging}


% pcmd.c

<<global nl>>=
char nl='\n';		/* change to semicolon for bourne-proofing */
@

<<constant c0>>=
#define	c0	t->child[0]
@

<<constant c1>>=
#define	c1	t->child[1]
@

<<constant c2>>=
#define	c2	t->child[2]
@

<<function pcmd>>=
void
pcmd(io *f, tree *t)
{
    if(t==nil)
        return;
    assert(f != nil);

    switch(t->type){
    case '$':	pfmt(f, "$%t", c0); break;
    case '"':	pfmt(f, "$\"%t", c0); break;
    case '&':	pfmt(f, "%t&", c0); break;
    case '^':	pfmt(f, "%t^%t", c0, c1); break;
    case '`':	pfmt(f, "`%t", c0); break;
    case ANDAND:pfmt(f, "%t && %t", c0, c1); break;
    case OROR:	pfmt(f, "%t || %t", c0, c1); break;
    case BANG:	pfmt(f, "! %t", c0); break;
    case BRACE:	pfmt(f, "{%t}", c0); break;
    case COUNT:	pfmt(f, "$#%t", c0); break;
    case FN:	pfmt(f, "fn %t %t", c0, c1); break;
    case IF:	pfmt(f, "if%t%t", c0, c1); break;
    case NOT:	pfmt(f, "if not %t", c0); break;
    case PCMD:
    case PAREN:	pfmt(f, "(%t)", c0); break;
    case SUB:	pfmt(f, "$%t(%t)", c0, c1); break;
    case SIMPLE:	pfmt(f, "%t", c0); break;
    case SUBSHELL:	pfmt(f, "@ %t", c0); break;
    case SWITCH:	pfmt(f, "switch %t %t", c0, c1); break;
    case TWIDDLE:	pfmt(f, "~ %t %t", c0, c1); break;
    case WHILE:		pfmt(f, "while %t%t", c0, c1); break;

    case ARGLIST:
        if(c0==nil)
            pfmt(f, "%t", c1);
        else if(c1==nil)
            pfmt(f, "%t", c0);
        else
            pfmt(f, "%t %t", c0, c1);
        break;
    case ';':
        if(c0){
            if(c1)
                pfmt(f, "%t%c%t", c0, nl, c1);
            else pfmt(f, "%t", c0);
        }
        else pfmt(f, "%t", c1);
        break;
    case WORDS:
        if(c0)
            pfmt(f, "%t ", c0);
        pfmt(f, "%t", c1);
        break;
    case FOR:
        pfmt(f, "for(%t", c0);
        if(c1)
            pfmt(f, " in %t", c1);
        pfmt(f, ")%t", c2);
        break;
    case WORD:
        if(t->quoted)
            pfmt(f, "%Q", t->str);
        else pdeglob(f, t->str);
        break;
    case DUP:
        if(t->rtype==DUPFD)
            pfmt(f, ">[%d=%d]", t->fd1, t->fd0); /* yes, fd1, then fd0; read lex.c */
        else
            pfmt(f, ">[%d=]", t->fd0);
        pfmt(f, "%t", c1);
        break;
    case PIPEFD:
    case REDIR:
        switch(t->rtype){
        case HERE:
            pchr(f, '<');
        case READ:
        case RDWR:
            pchr(f, '<');
            if(t->rtype==RDWR)
                pchr(f, '>');
            if(t->fd0!=0)
                pfmt(f, "[%d]", t->fd0);
            break;
        case APPEND:
            pchr(f, '>');
        case WRITE:
            pchr(f, '>');
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
            break;
        }
        pfmt(f, "%t", c0);
        if(c1)
            pfmt(f, " %t", c1);
        break;
    case '=':
        pfmt(f, "%t=%t", c0, c1);
        if(c2)
            pfmt(f, " %t", c2);
        break;
    case PIPE:
        pfmt(f, "%t|", c0);
        if(t->fd1==0){
            if(t->fd0!=1)
                pfmt(f, "[%d]", t->fd0);
        }
        else pfmt(f, "[%d=%d]", t->fd0, t->fd1);
        pfmt(f, "%t", c1);
        break;

    default:	
        pfmt(f, "bad cmd %d %p %p %p", t->type, c0, c1, c2);
        break;
    }
}
@
%$

<<function pdeglob>>=
void
pdeglob(io *f, char *s)
{
    while(*s){
        if(*s==GLOB)
            s++;
        pchr(f, *s++);
    }
}
@




\section{[[rc -r]] printing runqueue}

<<[[main()]] debug runq>>=
if(flag['r'])
    pfnc(err, runq);
@

% pfnc.c
<<global fname>>=
struct{
    void	(*f)(void);
    char	*name;
} fname[] = {
    Xappend, "Xappend",
    Xassign, "Xassign",
    Xasync, "Xasync",
    Xbackq, "Xbackq",
    Xbang, "Xbang",
    Xcase, "Xcase",
    Xclose, "Xclose",
    Xconc, "Xconc",
    Xcount, "Xcount",
    Xdelfn, "Xdelfn",
    Xdelhere, "Xdelhere",
    Xdol, "Xdol",
    Xdup, "Xdup",
    Xeflag, "Xeflag",
    (void (*)(void))Xerror, "Xerror",
    Xexit, "Xexit",
    Xfalse, "Xfalse",
    Xfn, "Xfn",
    Xfor, "Xfor",
    Xglob, "Xglob",
    Xif, "Xif",
    Xifnot, "Xifnot",
    Xjump, "Xjump",
    Xlocal, "Xlocal",
    Xmark, "Xmark",
    Xmatch, "Xmatch",
    Xpipe, "Xpipe",
    Xpipefd, "Xpipefd",
    Xpipewait, "Xpipewait",
    Xpopm, "Xpopm",
    Xpopredir, "Xpopredir",
    Xqdol, "Xqdol",
    Xrdcmds, "Xrdcmds",
    Xrdfn, "Xrdfn",
    Xrdwr, "Xrdwr",
    Xread, "Xread",
    Xreturn, "Xreturn",
    Xsimple, "Xsimple",
    Xsub, "Xsub",
    Xsubshell, "Xsubshell",
    Xtrue, "Xtrue",
    Xunlocal, "Xunlocal",
    Xwastrue, "Xwastrue",
    Xword, "Xword",
    Xwrite, "Xwrite",
    0
};
@

% fnc??
<<function pfnc>>=
void
pfnc(io *fd, thread *t)
{
    int i;
    void (*fn)(void) = t->code[t->pc].f;
    list *a;

    pfmt(fd, "pid %d cycle %p %d ", getpid(), t->code, t->pc);
    for (i = 0; fname[i].f; i++) 
        if (fname[i].f == fn) {
            pstr(fd, fname[i].name);
            break;
        }
    if (!fname[i].f)
        pfmt(fd, "%p", fn);
    for (a = t->argv; a; a = a->next) 
        pfmt(fd, " (%v)", a->words);
    pchr(fd, '\n');
    flush(fd);
}
@


\chapter{Error Managment}

<<constant ERRMAX>>=
#define ERRMAX 128
@

<<global err>>=
io *err;
@

<<global nerror>>=
int nerror;		/* number of errors encountered during compilation */
@


<<function yyerror>>=
void
yyerror(char *m)
{
    pfmt(err, "rc: ");
    if(runq->cmdfile && !runq->iflag)
        pfmt(err, "%s:%d: ", runq->cmdfile, runq->lineno);
    else if(runq->cmdfile)
        pfmt(err, "%s: ", runq->cmdfile);
    else if(!runq->iflag)
        pfmt(err, "line %d: ", runq->lineno);
    if(tok[0] && tok[0]!='\n')
        pfmt(err, "token %q: ", tok);
    pfmt(err, "%s\n", m);
    flush(err);
    lastword = false;
    lastdol = false;
    while(lastc!='\n' && lastc!=EOF) advance();
    nerror++;
    setvar("status", newword(m, (word *)0));
}
@

<<function panic>>=
void
panic(char *s, int n)
{
    pfmt(err, "rc: ");
    pfmt(err, s, n);
    pchr(err, '\n');
    flush(err);
    Abort();
}
@


\chapter{Libc}

\section{Memory managment}

%#define	new(type)	((type *)emalloc(sizeof(type)))

<<function emalloc>>=
void *
emalloc(long n)
{
    void *p = Malloc(n);

    if(p==nil)
        panic("Can't malloc %d bytes", n);
/*	if(err){ pfmt(err, "malloc %d->%p\n", n, p); flush(err); } /**/
    return p;
}
@

% plan9
<<function Malloc>>=
void*
Malloc(ulong n)
{
    return mallocz(n, 1);
}
@


<<function efree>>=
void
efree(void *p)
{
/*	pfmt(err, "free %p\n", p); flush(err); /**/
    if(p)
        free(p);
    else pfmt(err, "free 0\n");
}
@

\section{Command line arguments processing}
% getopt


\section{Buffered IO}
% again, reimplement the same thing

<<constant NBUF>>=
#define	NBUF	512
@

<<struct io>>=
struct Io {
    fdt	fd;
    byte	*bufp, *ebuf, *strp;
    byte	buf[NBUF];
};
@


<<function openfd>>=
io*
openfd(fdt fd)
{
    io *f = new(struct Io);
    f->fd = fd;
    f->bufp = f->ebuf = f->buf;
    f->strp = nil;
    return f;
}
@

<<enum _anon_>>=
enum { Stralloc = 100, };
@

<<function flush>>=
void
flush(io *f)
{
    int n;

    if(f->strp){
        n = f->ebuf - f->strp;
        f->strp = realloc(f->strp, n+Stralloc+1);
        if(f->strp==0)
            panic("Can't realloc %d bytes in flush!", n+Stralloc+1);
        f->bufp = f->strp + n;
        f->ebuf = f->bufp + Stralloc;
        memset(f->bufp, '\0', Stralloc+1);
    }
    else{
        n = f->bufp-f->buf;
        if(n && Write(f->fd, f->buf, n) != n){
            Write(2, "Write error\n", 12);
            if(ntrap)
                dotrap();
        }
        f->bufp = f->buf;
        f->ebuf = f->buf+NBUF;
    }
}
@

\section{Format}

<<global pfmtnest>>=
int pfmtnest = 0;
@

% io.c
% could use fmtinstall instead? or because wanted to be portable to other OSes?
<<function pfmt>>=
void
pfmt(io *f, char *fmt, ...)
{
    va_list ap;
    char err[ERRMAX];

    va_start(ap, fmt);
    pfmtnest++;
    for(;*fmt;fmt++) {
        if(*fmt!='%') {
            pchr(f, *fmt);
            continue;
        }
        if(*++fmt == '\0')		/* "blah%"? */
            break;
        switch(*fmt){
        case 'c':
            pchr(f, va_arg(ap, int));
            break;
        case 'd':
            pdec(f, va_arg(ap, int));
            break;
        case 'o':
            poct(f, va_arg(ap, unsigned));
            break;
        case 'p':
            pptr(f, va_arg(ap, void*));
            break;
        case 'Q':
            pquo(f, va_arg(ap, char *));
            break;
        case 'q':
            pwrd(f, va_arg(ap, char *));
            break;
        case 'r':
            errstr(err, sizeof err); pstr(f, err);
            break;
        case 's':
            pstr(f, va_arg(ap, char *));
            break;
        case 't':
            pcmd(f, va_arg(ap, struct Tree *));
            break;
        case 'v':
            pval(f, va_arg(ap, struct Word *));
            break;
        default:
            pchr(f, *fmt);
            break;
        }
    }
    va_end(ap);
    if(--pfmtnest==0)
        flush(f);
}
@


\section{String conversions}

<<global bp>>=
char *bp;
@

<<function inttoascii>>=
void
inttoascii(char *s, long n)
{
    bp = s;
    iacvt(n);
    *bp='\0';
}
@

<<function iacvt>>=
static void
iacvt(int n)
{
    if(n<0){
        *bp++='-';
        n=-n;	/* doesn't work for n==-inf */
    }
    if(n/10)
        iacvt(n/10);
    *bp++=n%10+'0';
}
@


\chapter{Extra Code}

\ifallcode
#include "Shell_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
