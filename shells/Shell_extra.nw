\section{[[misc/]]}

\subsection*{[[misc/echo.c]]}

<<function [[main]]>>=
void
main(int argc, char *argv[])
{
    int nflag;
    int i, len;
    char *buf, *p;

    nflag = 0;
    if(argc > 1 && strcmp(argv[1], "-n") == 0)
        nflag = 1;

    len = 1;
    for(i = 1+nflag; i < argc; i++)
        len += strlen(argv[i])+1;

    buf = malloc(len);
    if(buf == 0)
        exits("no memory");

    p = buf;
    for(i = 1+nflag; i < argc; i++){
        strcpy(p, argv[i]);
        p += strlen(p);
        if(i < argc-1)
            *p++ = ' ';
    }
        
    if(!nflag)
        *p++ = '\n';

    if(write(1, buf, p-buf) < 0){
        fprint(2, "echo: write error: %r\n");
        exits("write error");
    }

    exits((char *)nil);
}
@


%-------------------------------------------------------------

<<misc/echo.c>>=
#include <u.h>
#include <libc.h>

<<function [[main]]>>
@


\subsection*{[[misc/pwd.c]]}

<<function main (misc/pwd.c)>>=
/*
 * Print working (current) directory
 */

void
main(int argc, char *argv[])
{
    char pathname[512];

    USED(argc, argv);
    if(getwd(pathname, sizeof(pathname)) == 0) {
        fprint(2, "pwd: %r\n");
        exits("getwd");
    }
    print("%s\n", pathname);
    exits(nil);
}
@


%-------------------------------------------------------------

<<misc/pwd.c>>=
#include <u.h>
#include <libc.h>
<<function main (misc/pwd.c)>>
@


\subsection*{[[misc/test.c]]}

<<function [[EQ]]>>=
#define EQ(a,b)	((tmp=a)==0?0:(strcmp(tmp,b)==0))
@

<<global [[ap]]>>=
int	ap;
@

<<global [[ac]]>>=
int	ac;
@

<<global [[av]]>>=
char	**av;
@

<<global [[tmp]]>>=
static char	*tmp;
@

<<function main (misc/test.c)>>=
void
main(int argc, char *argv[])
{
    int r;
    char *c;

    ac = argc; av = argv; ap = 1;
    if(EQ(argv[0],"[")) {
        if(!EQ(argv[--ac],"]"))
            synbad("] missing","");
    }
    argv[ac] = 0;
    if (ac<=1)
        exits("usage");
    r = e();
    /*
     * nice idea but short-circuit -o and -a operators may have
     * not consumed their right-hand sides.
     */
    if(false && (c = nxtarg(1)) != nil)
        synbad("unexpected operator/operand: ", c);
    exits(r? nil : "false");
}
@

<<function [[nxtarg]]>>=
char *
nxtarg(int mt)
{
    if(ap>=ac){
        if(mt){
            ap++;
            return(0);
        }
        synbad("argument expected","");
    }
    return(av[ap++]);
}
@

<<function [[nxtintarg]]>>=
bool
nxtintarg(int *pans)
{
    if(ap<ac && isint(av[ap], pans)){
        ap++;
        return true;
    }
    return false;
}
@

<<function [[e]]>>=
int
e(void)
{
    int p1;

    p1 = e1();
    if (EQ(nxtarg(1), "-o"))
        return(p1 || e());
    ap--;
    return(p1);
}
@

<<function [[e1]]>>=
int
e1(void)
{
    int p1;

    p1 = e2();
    if (EQ(nxtarg(1), "-a"))
        return (p1 && e1());
    ap--;
    return(p1);
}
@

<<function [[e2]]>>=
int
e2(void)
{
    if (EQ(nxtarg(0), "!"))
        return(!e2());
    ap--;
    return(e3());
}
@

<<function [[e3]]>>=
bool
e3(void)
{
    int p1, int1, int2;
    char *a, *p2;

    a = nxtarg(0);
    if(EQ(a, "(")) {
        p1 = e();
        if(!EQ(nxtarg(0), ")"))
            synbad(") expected","");
        return(p1);
    }

    if(EQ(a, "-A"))
        return(hasmode(nxtarg(0), DMAPPEND));

    if(EQ(a, "-L"))
        return(hasmode(nxtarg(0), DMEXCL));

    if(EQ(a, "-T"))
        return(hasmode(nxtarg(0), DMTMP));

    if(EQ(a, "-f"))
        return(isreg(nxtarg(0)));

    if(EQ(a, "-d"))
        return(isdir(nxtarg(0)));

    if(EQ(a, "-r"))
        return(tio(nxtarg(0), 4));

    if(EQ(a, "-w"))
        return(tio(nxtarg(0), 2));

    if(EQ(a, "-x"))
        return(tio(nxtarg(0), 1));

    if(EQ(a, "-e"))
        return(tio(nxtarg(0), 0));

    if(EQ(a, "-c"))
        return false;

    if(EQ(a, "-b"))
        return false;

    if(EQ(a, "-u"))
        return false;

    if(EQ(a, "-g"))
        return false;

    if(EQ(a, "-s"))
        return(fsizep(nxtarg(0)));

    if(EQ(a, "-t"))
        if(ap>=ac)
            return(isatty(1));
        else if(nxtintarg(&int1))
            return(isatty(int1));
        else
            synbad("not a valid file descriptor number ", "");

    if(EQ(a, "-n"))
        return(!EQ(nxtarg(0), ""));
    if(EQ(a, "-z"))
        return(EQ(nxtarg(0), ""));

    p2 = nxtarg(1);
    if (p2==0)
        return(!EQ(a,""));
    if(EQ(p2, "="))
        return(EQ(nxtarg(0), a));

    if(EQ(p2, "!="))
        return(!EQ(nxtarg(0), a));

    if(EQ(p2, "-older"))
        return(isolder(nxtarg(0), a));

    if(EQ(p2, "-ot"))
        return(isolderthan(nxtarg(0), a));

    if(EQ(p2, "-nt"))
        return(isnewerthan(nxtarg(0), a));

    if(!isint(a, &int1))
        synbad("unexpected operator/operand: ", p2);

    if(nxtintarg(&int2)){
        if(EQ(p2, "-eq"))
            return(int1==int2);
        if(EQ(p2, "-ne"))
            return(int1!=int2);
        if(EQ(p2, "-gt"))
            return(int1>int2);
        if(EQ(p2, "-lt"))
            return(int1<int2);
        if(EQ(p2, "-ge"))
            return(int1>=int2);
        if(EQ(p2, "-le"))
            return(int1<=int2);
    }

    synbad("unknown operator ",p2);
    return false;		/* to shut ken up */
}
@

<<function [[tio]]>>=
bool
tio(char *a, int f)
{
    return access (a, f) >= 0;
}
@

<<function [[hasmode]]>>=
/*
 * note that the name strings pointed to by Dir members are
 * allocated with the Dir itself (by the same call to malloc),
 * but are not included in sizeof(Dir), so copying a Dir won't
 * copy the strings it points to.
 */
bool
hasmode(char *f, ulong m)
{
    bool r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return false;
    r = (dir->mode & m) != 0;
    free(dir);
    return r;
}
@

<<function [[isdir]]>>=
bool
isdir(char *f)
{
    return hasmode(f, DMDIR);
}
@

<<function [[isreg]]>>=
bool
isreg(char *f)
{
    bool r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return false;
    r = (dir->mode & DMDIR) == 0;
    free(dir);
    return r;
}
@

<<function [[isatty]]>>=
int
isatty(int fd)
{
    int r;
    Dir *d1, *d2;

    d1 = dirfstat(fd);
    d2 = dirstat("/dev/cons");
    if (d1 == nil || d2 == nil)
        r = 0;
    else
        r = d1->type == d2->type && d1->dev == d2->dev &&
            d1->qid.path == d2->qid.path;
    free(d1);
    free(d2);
    return r;
}
@

<<function [[fsizep]]>>=
bool
fsizep(char *f)
{
    bool r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return false;
    r = dir->length > 0;
    free(dir);
    return r;
}
@

<<function [[synbad]]>>=
void
synbad(char *s1, char *s2)
{
    int len;

    write(2, "test: ", 6);
    if ((len = strlen(s1)) != 0)
        write(2, s1, len);
    if ((len = strlen(s2)) != 0)
        write(2, s2, len);
    write(2, "\n", 1);
    exits("bad syntax");
}
@

<<function [[isint]]>>=
int
isint(char *s, int *pans)
{
    char *ep;

    *pans = strtol(s, &ep, 0);
    return (*ep == 0);
}
@

<<function [[isolder]]>>=
bool
isolder(char *pin, char *f)
{
    int r, rel;
    ulong n, m;
    char *p = pin;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return false;

    /* parse time */
    n = 0;
    rel = 0;
    while(*p){
        m = strtoul(p, &p, 0);
        switch(*p){
        case 0:
            n = m;
            break;
        case 'y':
            m *= 12;
            /* fall through */
        case 'M':
            m *= 30;
            /* fall through */
        case 'd':
            m *= 24;
            /* fall through */
        case 'h':
            m *= 60;
            /* fall through */
        case 'm':
            m *= 60;
            /* fall through */
        case 's':
            n += m;
            p++;
            rel = 1;
            break;
        default:
            synbad("bad time syntax, ", pin);
        }
    }
    if (!rel)
        m = n;
    else{
        m = time(0);
        if (n > m)		/* before epoch? */
            m = 0;
        else
            m -= n;
    }
    r = dir->mtime < m;
    free(dir);
    return r;
}
@

<<function [[isolderthan]]>>=
int
isolderthan(char *a, char *b)
{
    int r;
    Dir *ad, *bd;

    ad = dirstat(a);
    bd = dirstat(b);
    if (ad == nil || bd == nil)
        r = 0;
    else
        r = ad->mtime > bd->mtime;
    free(ad);
    free(bd);
    return r;
}
@

<<function [[isnewerthan]]>>=
int
isnewerthan(char *a, char *b)
{
    int r;
    Dir *ad, *bd;

    ad = dirstat(a);
    bd = dirstat(b);
    if (ad == nil || bd == nil)
        r = 0;
    else
        r = ad->mtime < bd->mtime;
    free(ad);
    free(bd);
    return r;
}
@


%-------------------------------------------------------------

<<misc/test.c>>=
/*
 * POSIX standard
 *	test expression
 *	[ expression ]
 *
 * Plan 9 additions:
 *	-A file exists and is append-only
 *	-L file exists and is exclusive-use
 *	-T file exists and is temporary
 */

#include <u.h>
#include <libc.h>

<<function [[EQ]]>>

<<global [[ap]]>>
<<global [[ac]]>>
<<global [[av]]>>
<<global [[tmp]]>>

void	synbad(char *, char *);
int	fsizep(char *);
int	isdir(char *);
int	isreg(char *);
int	isatty(int);
int	isint(char *, int *);
int	isolder(char *, char *);
int	isolderthan(char *, char *);
int	isnewerthan(char *, char *);
int	hasmode(char *, ulong);
int	tio(char *, int);
int	e(void), e1(void), e2(void), e3(void);
char	*nxtarg(int);

<<function main (misc/test.c)>>

<<function [[nxtarg]]>>

<<function [[nxtintarg]]>>

<<function [[e]]>>

<<function [[e1]]>>

<<function [[e2]]>>

<<function [[e3]]>>

<<function [[tio]]>>

<<function [[hasmode]]>>

<<function [[isdir]]>>

<<function [[isreg]]>>

<<function [[isatty]]>>

<<function [[fsizep]]>>

<<function [[synbad]]>>

<<function [[isint]]>>

<<function [[isolder]]>>

<<function [[isolderthan]]>>

<<function [[isnewerthan]]>>
@


\section{[[sh/]]}

%helps understand high-level code orga and flow.
%cmd1 | cmd2 
%actually does 2 forks, and the interpreter continues! because
%maybe this pipe is part of a bigger command.
%
%also need to return pid in interpreter.

\subsection*{[[sh/sh.c]]}

<<constant [[MAXLINE]]>>=
#define MAXLINE 200		/* maximum line length */
@

<<constant [[WORD]]>>=
#define WORD 256		/* token code for words */
@

<<constant [[EOF]]>>=
#define EOF -1			/* token code for end of file */
@

<<function [[ispunct]]>>=
#define ispunct(c)		(c=='|' || c=='&' || c==';' || c=='<' || \
                 c=='>' || c=='(' || c==')' || c=='\n')
@

<<function [[isspace]]>>=
#define isspace(c)		(c==' ' || c=='\t')
@

<<function [[execute]]>>=
#define execute(np)		(ignored = (np? (*(np)->op)(np) : 0))
@

<<struct [[Node]]>>=
struct Node {			/* parse tree node */
    int (*op)(Node *); 	/* operator function */
    Node *args[2];		/* argument nodes */
    char *argv[100];	/* argument pointers */
    char *io[3];		/* i/o redirection */
};
@

<<global [[nodes]]>>=
Node	nodes[25];		/* node pool */
@

<<global [[nfree]]>>=
Node	*nfree;			/* next available node */
@

<<global [[strspace]]>>=
char	strspace[10*MAXLINE];	/* string storage */
@

<<global [[sfree]]>>=
char	*sfree;			/* next free character in strspace */
@

<<global [[t]]>>=
int	t;			/* current token code */
@

<<global [[token]]>>=
char 	*token;			/* current token text (in strspace) */
@

<<global [[putback]]>>=
int	putback = 0;		/* lookahead */
@

<<global [[status]]>>=
char	status[256];		/* exit status of most recent command */
@

<<global [[cflag]]>>=
int	cflag = 0;		/* command is argument to sh */
@

<<global [[tflag]]>>=
int	tflag = 0;		/* read only one line */
@

<<global [[interactive]]>>=
bool	interactive = false;	/* prompt */
@

<<global [[cflagp]]>>=
char	*cflagp;		/* command line for cflag */
@

<<global [[path]]>>=
char	*path[] ={"/bin", 0};
@

<<global [[ignored]]>>=
int	ignored;
@

<<function main (sh/sh.c)>>=
void
main(int argc, char *argv[])
{
    Node *np;

    if(argc>1 && strcmp(argv[1], "-t")==0)
        tflag++;
    else if(argc>2 && strcmp(argv[1], "-c")==0){
        cflag++;
        cflagp = argv[2];
    }else if(argc>1){
        close(0);
        if(open(argv[1], 0) != 0){
            error(": can't open", argv[1]);
            exits("argument");
        }
    }else
        interactive = true;
    for(;;){
        if(interactive)
            fprint(2, "%d$ ", getpid());
        nfree = nodes;
        sfree = strspace;
        if((t=gettoken()) == EOF)
            break;
        if(t != '\n')
            if(np = list())
                execute(np);
            else
                error("syntax error", "");
        while(t!=EOF && t!='\n')	/* flush syntax errors */
            t = gettoken();
    }
    exits(status);
}
@

<<function [[alloc]]>>=
/* alloc - allocate for op and return a node */
Node*
alloc(int (*op)(Node *))
{
    if(nfree < nodes+sizeof(nodes)){
        nfree->op = op;
        nfree->args[0] = nfree->args[1] = 0;
        nfree->argv[0] = nfree->argv[1] = 0;
        nfree->io[0] = nfree->io[1] = nfree->io[2] = 0;
        return nfree++;
    }
    error("node storage overflow", "");
    exits("node storage overflow");
    return nil;
}
@

% return bool and do side effect of executing command before
<<function [[builtin]]>>=
/* builtin - check np for builtin command and, if found, execute it */
bool
builtin(Node *np)
{
    int n = 0;
    char name[MAXLINE];
    Waitmsg *wmsg;

    if(np->argv[1])
        n = strtoul(np->argv[1], 0, 0);
    if(strcmp(np->argv[0], "cd") == 0){
        if(chdir(np->argv[1]? np->argv[1] : "/") == -1)
            error(": bad directory", np->argv[0]);
        return true;
    }else if(strcmp(np->argv[0], "exit") == 0)
        exits(np->argv[1]? np->argv[1] : status);
    else if(strcmp(np->argv[0], "bind") == 0){
        if(np->argv[1]==0 || np->argv[2]==0)
            error("usage: bind new old", "");
        else if(bind(np->argv[1], np->argv[2], 0)==-1)
            error("bind failed", "");
        return true;
//#ifdef asdf
//	}else if(strcmp(np->argv[0], "unmount") == 0){
//		if(np->argv[1] == 0)
//			error("usage: unmount [new] old", "");
//		else if(np->argv[2] == 0){
//			if(unmount((char *)0, np->argv[1]) == -1)
//				error("unmount:", "");
//		}else if(unmount(np->argv[1], np->argv[2]) == -1)
//			error("unmount", "");
//		return true;
//#endif
    }else if(strcmp(np->argv[0], "wait") == 0){
        while((wmsg = wait()) != nil){
            strncpy(status, wmsg->msg, sizeof(status)-1);
            if(n && wmsg->pid==n){
                n = 0;
                free(wmsg);
                break;
            }
            free(wmsg);
        }
        if(n)
            error("wait error", "");
        return true;
    }else if(strcmp(np->argv[0], "rfork") == 0){
        char *p;
        int mask;

        p = np->argv[1];
        if(p == 0 || *p == 0)
            p = "ens";
        mask = 0;

        while(*p)
            switch(*p++){
            case 'n': mask |= RFNAMEG; break;
            case 'N': mask |= RFCNAMEG; break;
            case 'e': mask |= RFENVG; break;
            case 'E': mask |= RFCENVG; break;
            case 's': mask |= RFNOTEG; break;
            case 'f': mask |= RFFDG; break;
            case 'F': mask |= RFCFDG; break;
            case 'm': mask |= RFNOMNT; break;
            default: error(np->argv[1], "bad rfork flag");
            }
        rfork(mask);

        return OK_1;
    }else if(strcmp(np->argv[0], "exec") == 0){
        redirect(np);
        if(np->argv[1] == (char *) 0)
            return 1;
        exec(np->argv[1], &np->argv[1]);
        n = np->argv[1][0];
        if(n!='/' && n!='#' && (n!='.' || np->argv[1][1]!='/'))
            for(n = 0; path[n]; n++){
                sprint(name, "%s/%s", path[n], np->argv[1]);
                exec(name, &np->argv[1]);
            }
        error(": not found", np->argv[1]);
        return true;
    }
    // no builtin found
    return false;
}
@

<<function [[command]]>>=
/* command - ( list ) [ ( < | > | >> ) word ]* | simple */
Node*
command(void)
{
    Node *np;

    if(t != '(')
        return simple();
    np = alloc(xsubshell);
    t = gettoken();
    if((np->args[0]=list())==0 || t!=')')
        return nil;
    while((t=gettoken())=='<' || t=='>')
        if(!setio(np))
            return nil;
    return np;
}
@

<<function [[getch]]>>=
/* getch - get next, possibly pushed back, input character */
int
getch(void)
{
    unsigned char c;
    static int done=0;

    if(putback){
        c = putback;
        putback = 0;
    }else if(tflag){
        if(done || read(0, &c, 1)!=1){
            done = 1;
            return EOF;
        }
        if(c == '\n')
            done = 1;
    }else if(cflag){
        if(done)
            return EOF;
        if((c=*cflagp++) == 0){
            done = 1;
            c = '\n';
        }
    }else if(read(0, &c, 1) != 1)
        return EOF;
    return c;
}
@

<<function [[gettoken]]>>=
/* gettoken - get next token into string space, return token code */
int
gettoken(void)
{
    int c;

    while((c = getch()) != EOF)
        if(!isspace(c))
            break;
    if(c==EOF || ispunct(c))
        return c;
    token = sfree;
    do{
        if(sfree >= strspace+sizeof(strspace) - 1){
            error("string storage overflow", "");
            exits("string storage overflow");
        }
        *sfree++ = c;
    }while((c=getch()) != EOF && !ispunct(c) && !isspace(c));
    *sfree++ = 0;
    putback = c;
    return WORD;
}
@

<<function [[list]]>>=
/* list - pipeline ( ( ; | & ) pipeline )* [ ; | & ]  (not LL(1), but ok) */
Node*
list(void)
{
    Node *np, *np1;

    np = alloc(0);
    if((np->args[1]=pipeline()) == 0)
        return nil;
    while(t==';' || t=='&'){
        np->op = (t==';')? xwait : xnowait;
        t = gettoken();
        if(t==')' || t=='\n')	/* tests ~first(pipeline) */
            break;
        np1 = alloc(0);
        np1->args[0] = np;
        if((np1->args[1]=pipeline()) == 0)
            return nil;
        np = np1;
    }
    if(np->op == 0)
        np->op = xwait;
    return np;
}
@

<<function [[error]]>>=
/* error - print error message s, prefixed by t */
void
error(char *s, char *t)
{
    char buf[256];

    fprint(2, "%s%s", t, s);
    errstr(buf, sizeof buf);
    fprint(2, ": %s\n", buf);
}
@

<<function [[pipeline]]>>=
/* pipeline - command ( | command )* */
Node*
pipeline(void)
{
    Node *np, *np1;

    if((np=command()) == 0)
        return nil;
    while(t == '|'){
        np1 = alloc(xpipeline);
        np1->args[0] = np;
        t = gettoken();
        if((np1->args[1]=command()) == 0)
            return nil;
        np = np1;
    }
    return np;
}
@

<<function [[redirect]]>>=
/* redirect - redirect i/o according to np->io[] values */
void
redirect(Node *np)
{
    int fd;

    if(np->io[0]){
        if((fd = open(np->io[0], 0)) < 0){
            error(": can't open", np->io[0]);
            exits("open");
        }
        dup(fd, 0);
        close(fd);
    }
    if(np->io[1]){
        if((fd = create(np->io[1], 1, 0666L)) < 0){
            error(": can't create", np->io[1]);
            exits("create");
        }
        dup(fd, 1);
        close(fd);
    }
    if(np->io[2]){
        if((fd = open(np->io[2], 1)) < 0 && (fd = create(np->io[2], 1, 0666L)) < 0){
            error(": can't write", np->io[2]);
            exits("write");
        }
        dup(fd, 1);
        close(fd);
        seek(1, 0, 2);
    }
}
@

<<function [[setio]]>>=
/* setio - ( < | > | >> ) word; fill in np->io[] */
error0
setio(Node *np)
{
    if(t == '<'){
        t = gettoken();
        np->io[0] = token;
    }else if(t == '>'){
        t = gettoken();
        if(t == '>'){
            t = gettoken();
            np->io[2] = token;
            }else
            np->io[1] = token;
    }else
        return ERROR_0;
    if(t != WORD)
        return ERROR_0;
    return OK_1;
}
@

<<function [[simple]]>>=
/* simple - word ( [ < | > | >> ] word )* */
Node*
simple(void)
{
    Node *np;
    int n = 1;

    if(t != WORD)
        return nil;
    np = alloc(xsimple);
    np->argv[0] = token;
    while((t = gettoken())==WORD || t=='<' || t=='>')
        if(t == WORD)
            np->argv[n++] = token;
        else if(!setio(np))
            return nil;
    np->argv[n] = 0;
    return np;
}
@

<<function [[xpipeline]]>>=
/* xpipeline - execute cmd | cmd */
int
xpipeline(Node *np)
{
    int pid, fd[2];

    if(pipe(fd) < 0){
        error("can't create pipe", "");
        return 0;
    }
    if((pid=fork()) == 0){	/* left side; redirect stdout */
        dup(fd[1], 1);
        close(fd[0]);
        close(fd[1]);
        execute(np->args[0]);
        exits(status);
    }else if(pid == -1){
        error("can't create process", "");
        return 0;
    }
    if((pid=fork()) == 0){	/* right side; redirect stdin */
        dup(fd[0], 0);
        close(fd[0]);
        close(fd[1]);
        pid = execute(np->args[1]); /*BUG: this is wrong sometimes*/
        if(pid > 0)
            while(waitpid()!=pid)
                ;
        exits(nil);
    }else if(pid == -1){
        error("can't create process", "");
        return 0;
    }
    close(fd[0]);	/* avoid using up fd's */
    close(fd[1]);
    return pid;
}
@

<<function [[xsimple]]>>=
/* xsimple - execute a simple command */
int
xsimple(Node *np)
{
    char name[MAXLINE];
    int pid, i;

    if(builtin(np))
        return 0;

    if(pid = fork()){
        if(pid == -1)
            error(": can't create process", np->argv[0]);
        return pid;
    }
    redirect(np);	/* child process */
    exec(np->argv[0], &np->argv[0]);
    i = np->argv[0][0];

    if(i!='/' && i!='#' && (i!='.' || np->argv[0][1]!='/'))
        for(i = 0; path[i]; i++){
            sprint(name, "%s/%s", path[i], np->argv[0]);
            exec(name, &np->argv[0]);
        }
    error(": not found", np->argv[0]);
    exits("not found");
    return -1;		// suppress compiler warnings
}
@

<<function [[xsubshell]]>>=
/* xsubshell - execute (cmd) */
int
xsubshell(Node *np)
{
    int pid;

    if(pid = fork()){
        if(pid == -1)
            error("can't create process", "");
        return pid;
    }
    redirect(np);	/* child process */
    execute(np->args[0]);
    exits(status);
    return -1;		// suppress compiler warnings
}
@

<<function [[xnowait]]>>=
/* xnowait - execute cmd & */
int
xnowait(Node *np)
{
    int pid;

    execute(np->args[0]);
    pid = execute(np->args[1]);
    if(interactive)
        fprint(2, "%d\n", pid);
    return 0;
}
@

<<function [[xwait]]>>=
/* xwait - execute cmd ; */
int xwait(Node *np)
{
    int pid;
    Waitmsg *wmsg;

    execute(np->args[0]);
    pid = execute(np->args[1]);
    if(pid > 0){
        while((wmsg = wait()) != nil){
            if(wmsg->pid == pid)
                break;
            free(wmsg);
        }
        if(wmsg == nil)
            error("wait error", "");
        else {
            strncpy(status, wmsg->msg, sizeof(status)-1);
            free(wmsg);
        }
    }
    return 0;
}
@


%-------------------------------------------------------------

<<sh/sh.c>>=
/* sh - simple shell - great for early stages of porting */
#include <u.h>
#include <libc.h>

<<constant [[MAXLINE]]>>
<<constant [[WORD]]>>
<<constant [[EOF]]>>
<<function [[ispunct]]>>
<<function [[isspace]]>>
<<function [[execute]]>>

typedef struct Node	Node;
<<struct [[Node]]>>

<<global [[nodes]]>>
<<global [[nfree]]>>
<<global [[strspace]]>>
<<global [[sfree]]>>
<<global [[t]]>>
<<global [[token]]>>
<<global [[putback]]>>
<<global [[status]]>>
<<global [[cflag]]>>
<<global [[tflag]]>>
<<global [[interactive]]>>
<<global [[cflagp]]>>
<<global [[path]]>>
<<global [[ignored]]>>

// lexer
int	gettoken(void);
int	getch(void);
// parser (recursive descent)
Node	*list(void);
Node	*command(void);
Node	*simple(void);
Node	*pipeline(void);
int	setio(Node *np);
// interpreter
// see execute macro above
int	builtin(Node *np);


void	redirect(Node *np);

int	xpipeline(Node *np);
int	xsimple(Node *np);
int	xsubshell(Node *np);
int	xnowait(Node *np);
int	xwait(Node *np);

// error management
void	error(char *s, char *t);
// memory management
Node	*alloc(int (*op)(Node *));

<<function main (sh/sh.c)>>

<<function [[alloc]]>>

<<function [[builtin]]>>

<<function [[command]]>>

<<function [[getch]]>>

<<function [[gettoken]]>>

<<function [[list]]>>

<<function [[error]]>>

<<function [[pipeline]]>>

<<function [[redirect]]>>

<<function [[setio]]>>
            
<<function [[simple]]>>

<<function [[xpipeline]]>>

<<function [[xsimple]]>>

<<function [[xsubshell]]>>

<<function [[xnowait]]>>

<<function [[xwait]]>>
@
















\section{[[rc/]]}

\subsection*{[[rc/fns.h]]}

%-------------------------------------------------------------

<<rc/fns.h>>=
void	Abort(void);
void	Closedir(int);
int	Creat(char*);
int	Dup(int, int);
int	Dup1(int);
int	Eintr(void);
int	Executable(char*);
void	Execute(word*,  word*);
void	Exit(char*);
int	Globsize(char*);
int	Isatty(int);
void	Memcpy(void*, void*, long);
void	Noerror(void);
int	Opendir(char*);
long	Read(int, void*, long);
int	Readdir(int, void*, int);
long	Seek(int, long, long);
void	Trapinit(void);
void	Unlink(char*);
void	Updenv(void);
void	Vinit(void);
int	Waitfor(int, int);
long	Write(int, void*, long);

void	addwaitpid(int);
int	advance(void);
void	cleanhere(char*);
void	codefree(code*);
error0	compile(tree*);
int	count(word*);
void	deglob(void*);
void	dotrap(void);
void	freenodes(void);
void	freewords(word*);
void	globlist(void);
int	idchr(int);
void	inttoascii(char*, long);
void	kinit(void);
int	match(void*, void*, int);
void	clearwaitpids(void);
void	panic(char*, int);
void	poplist(void);
void	popword(void);
void	pprompt(void);
void	pushlist(void);
void	pushredir(int, int, int);
void	pushword(char*);
void	readhere(void);
void	setstatus(char*);
void	setvar(char*, word*);
//@Scheck: used in syn.y
void	skipnl(void);
void	start(code*, int, var*);
int	truestatus(void);
void	usage(char*);
void	yyerror(char*);
int	yylex(void);
//@Scheck: defined in syn.y and y.tab.c
int	yyparse(void);
@


\subsection*{[[rc/getflags.h]]}

%-------------------------------------------------------------

<<rc/getflags.h>>=
<<constant [[NFLAG]]>>

extern char **flag[NFLAG];
extern char *flagset[];

int getflags(int, char*[], char*, int);
@


\subsection*{[[rc/io.h]]}

%-------------------------------------------------------------

<<rc/io.h>>=
<<constant EOF (rc/io.h)>>
<<constant [[NBUF]]>>

<<struct [[Io]]>>

extern io *err;

io *openfd(fdt);
io *openstr(void);
io *opencore(char *, int);
void pchr(io*, int);
int rchr(io*);
int rutf(io*, char*, Rune*);
void closeio(io*);
void flush(io*);
void pstr(io*, char*);
void pfmt(io*, char*, ...);

void pcmd(io*, tree*);
void pfnc(io*, thread*);
@


\subsection*{[[rc/rc.h]]}


%-------------------------------------------------------------

<<rc/rc.h>>=
/*
 * Assume plan 9 by default; if Unix is defined, assume unix.
 * Please don't litter the code with ifdefs.  The five below should be enough.
 */

//#ifndef Unix
/* plan 9 */
#include <u.h>
#include <libc.h>

<<constant [[NSIG]]>>
<<constant [[SIGINT]]>>
<<constant [[SIGQUIT]]>>

//#define fcntl(fd, op, arg) /* unix compatibility */
//#define F_SETFD  
//#define FD_CLOEXEC 

//#else
//#include "unix.h"
//#endif

#ifndef ERRMAX
<<constant [[ERRMAX]]>>
#endif

<<constant [[YYMAXDEPTH]]>>

//#ifndef YYPREFIX
#ifndef PAREN
//#include "x.tab.h"
//pad: better like that, otherwise get some "redefined FOR macro" error
#endif
//#endif

typedef struct Tree tree;
typedef struct Word word;
typedef struct Io io;
typedef union Code code;
typedef struct Var var;
typedef struct List list;
typedef struct Redir redir;
typedef struct Thread thread;
typedef struct Builtin builtin;

//#ifndef Unix
#pragma incomplete word
#pragma incomplete io
//#endif

<<struct [[Tree]]>>

tree *newtree(void);
tree *token(char*, int);
tree *klook(char*);
//@Scheck: useful, for syn.y, and not just for tree.c
tree *tree1(int, tree*);
tree *tree2(int, tree*, tree*);
//@Scheck: useful, for syn.y, and not just for tree.c
tree *tree3(int, tree*, tree*, tree*);
tree *mung1(tree*, tree*);
tree *mung2(tree*, tree*, tree*);
tree *mung3(tree*, tree*, tree*, tree*);
tree *epimung(tree*, tree*);
tree *simplemung(tree*);
tree *heredoc(tree*);


<<struct [[Code]]>>

extern char *promptstr;
extern bool doprompt;

<<constant [[NTOK]]>>

extern char tok[NTOK + UTFmax];

<<constant [[APPEND]]>>
<<constant [[WRITE]]>>
<<constant [[READ]]>>
<<constant [[HERE]]>>
<<constant [[DUPFD]]>>
<<constant [[CLOSE]]>>
<<constant [[RDWR]]>>

<<struct [[Var]]>>

var *vlook(char*);
var *gvlook(char*);
var *newvar(char*, var*);

<<constant [[NVAR]]>>
extern var *gvar[NVAR];		/* hash for globals */

#define	new(type)	((type *)emalloc(sizeof(type)))

void *emalloc(long);
void *Malloc(ulong);
void efree(void *);

<<struct [[Here]]>>
extern int mypid;

<<constant [[GLOB]]>>

extern int nerror;	/* number of errors encountered during compilation */
<<constant [[PRD]]>>
<<constant [[PWR]]>>

extern char *Rcmain;
extern char *Fdprefix;
extern int ndot;
char *getstatus(void);

extern int lastc;
extern bool lastword;

@


\subsection*{[[rc/exec.h]]}


%-------------------------------------------------------------

<<rc/exec.h>>=
/*
 * Definitions used in the interpreter
 */
extern void Xappend(void), Xasync(void), Xbackq(void), Xbang(void), Xclose(void);
extern void Xconc(void), Xcount(void), Xdelfn(void), Xdol(void), Xqdol(void), Xdup(void);
extern void Xexit(void), Xfalse(void), Xfn(void), Xfor(void), Xglob(void);
extern void Xjump(void), Xmark(void), Xmatch(void), Xpipe(void), Xread(void);
extern void Xrdwr(void);
extern void Xrdfn(void), Xreturn(void), Xsubshell(void);
extern void Xtrue(void), Xword(void), Xwrite(void), Xpipefd(void), Xcase(void);
extern void Xlocal(void), Xunlocal(void), Xassign(void), Xsimple(void), Xpopm(void);
extern void Xrdcmds(void), Xwastrue(void), Xif(void), Xifnot(void), Xpipewait(void);
extern void Xdelhere(void), Xpopredir(void), Xsub(void), Xeflag(void), Xsettrue(void);
extern void Xerror(char*);
extern void Xerror1(char*);

<<struct [[Word]]>>
<<struct [[List]]>>
word *newword(char *, word *);
word *copywords(word *, word *);

<<struct [[Redir]]>>

<<constant [[NSTATUS]]>>
<<constant [[ROPEN]]>>
<<constant [[RDUP]]>>
<<constant [[RCLOSE]]>>
<<struct [[Thread]]>>

code *codecopy(code*);

extern thread *runq;
extern code *codebuf;		/* compiler output */
extern int ntrap;		/* number of outstanding traps */
extern int trap[NSIG];		/* number of outstanding traps per type */
extern bool eflagok;		/* kludge flag so that -e doesn't exit in startup */

<<struct [[Builtin]]>>
extern struct Builtin builtins[];

void execcd(void);
void execwhatis(void);
void execeval(void);
void execexec(void);
int  execforkexec(void);
void execexit(void);
void execshift(void);
void execwait(void);
void execdot(void);
void execflag(void);
void execcmds(io *);
@


\subsection*{[[rc/globals.c]]}


<<globals.c>>=
#include "rc.h"
#include "exec.h"

// was in rc.h
<<global [[tok]]>>
<<global [[lastc]]>>
<<global [[mypid]]>>
<<global [[gvar]]>>
<<global [[ndot]]>>
<<global [[promptstr]]>>
<<global [[nerror]]>>
<<global [[err]]>>

// was in exec.h
<<global [[runq]]>>
<<global [[codebuf]]>>
<<global [[ntrap]]>>
<<global [[trap]]>>
<<global [[eflagok]]>>

@

\subsection*{[[rc/getflags.c]]}


%-------------------------------------------------------------

<<rc/getflags.c>>=
#include "rc.h"
#include "getflags.h"
#include "fns.h"

static void reverse(char**, char**);
static int scanflag(int, char*);
static void errn(char*, int);
static void errs(char*);
static void errc(int);

<<global [[flagset]]>>
<<global [[flag]]>>
<<global [[cmdname]]>>
<<global [[flagarg]]>>
<<global [[reason]]>>

<<constant [[RESET]]>>
<<constant [[FEWARGS]]>>
<<constant [[FLAGSYN]]>>
<<constant [[BADFLAG]]>>

<<global [[badflag]]>>

<<function [[getflags]]>>

<<function [[reverse]]>>

<<function [[scanflag]]>>

<<function [[usage]]>>

<<function [[errn]]>>

<<function [[errs]]>>
<<constant NBUF (rc/getflags.c)>>
<<global [[buf]]>>
<<global [[bufp]]>>

<<function [[errc]]>>
@


\subsection*{[[rc/io.c]]}


%-------------------------------------------------------------

<<rc/io.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

<<enum [[MiscConstants]]>>

<<global [[pfmtnest]]>>

int emptybuf(io*);
int fullbuf(io*, int);
void pdec(io*, int);
void poct(io*, unsigned int);
void pptr(io*, void*);
void pval(io*, word*);
void pquo(io*, char*);
void pwrd(io*, char*);

<<function [[pfmt]]>>

<<function [[pchr]]>>

<<function [[rchr]]>>

<<function [[rutf]]>>

<<function [[pquo]]>>

<<function [[pwrd]]>>

<<function [[pptr]]>>

<<function [[pstr]]>>

<<function [[pdec]]>>

<<function [[poct]]>>

<<function [[pval]]>>

<<function [[fullbuf]]>>

<<function [[flush]]>>

<<function [[openfd]]>>

<<function [[openstr]]>>
<<function [[opencore]]>>

<<function [[closeio]]>>

<<function [[emptybuf]]>>
@


\subsection*{[[rc/var.c]]}


%-------------------------------------------------------------

<<rc/var.c>>=
#include "rc.h"
#include "exec.h"
#include "fns.h"
#include "x.tab.h"

<<function [[hash]]>>

<<constant [[NKW]]>>
<<struct [[Kw]]>>
<<global [[kw]]>>

<<function [[kenter]]>>

<<function [[kinit]]>>

<<function [[klook]]>>

<<function [[gvlook]]>>

<<function [[vlook]]>>

<<function [[setvar]]>>
@


\subsection*{[[rc/subr.c]]}


%-------------------------------------------------------------

<<rc/subr.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

<<function [[emalloc]]>>

<<function [[efree]]>>
extern bool lastword;
extern bool lastdol;

<<function [[yyerror]]>>
<<global [[bp]]>>

<<function [[iacvt]]>>

<<function [[inttoascii]]>>

<<function [[panic]]>>
@


\subsection*{[[rc/plan9.c]]}

%-------------------------------------------------------------

<<rc/plan9.c>>=
/*
 * Plan 9 versions of system-specific functions
 *	By convention, exported routines herein have names beginning with an
 *	upper case letter.
 */
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"
#include "getflags.h"

char**	mkargv(word*);
void	delwaitpid(int);
int	havewaitpid(int);

<<enum [[MiscPlan9]]>>

<<global [[signame]]>>
<<global [[syssigname]]>>
<<global [[Rcmain]]>>
<<global [[Fdprefix]]>>

void execfinit(void);
void execnewpgrp(void);

<<global [[builtins]]>>

<<function [[execnewpgrp]]>>

<<function [[Vinit]]>>
<<global [[envdir]]>>

<<function [[Xrdfn]]>>
<<global [[rdfns]]>>

<<function [[execfinit]]>>

<<function [[Waitfor]]>>

<<function [[mkargv]]>>

<<function [[addenv]]>>

<<function [[updenvlocal]]>>

<<function [[Updenv]]>>


<<function [[Execute]]>>
<<constant [[NDIR]]>>

<<function [[Globsize]]>>
<<constant [[NFD]]>>

<<struct [[DirEntryWrapper]]>>
<<global [[dir]]>>

<<function [[Opendir]]>>

<<function [[trimdirs]]>>

<<function [[Readdir]]>>

<<function [[Closedir]]>>
<<global [[interrupted]]>>
<<function [[notifyf]]>>

<<function [[Trapinit]]>>

<<function [[Unlink]]>>

<<function [[Write]]>>

<<function [[Read]]>>

<<function [[Seek]]>>

<<function [[Executable]]>>

<<function [[Creat]]>>

<<function [[Dup]]>>

<<function [[Dup1]]>>

<<function [[Exit]]>>

<<function [[Eintr]]>>

<<function [[Noerror]]>>

<<function [[Isatty]]>>

<<function [[Abort]]>>

<<function [[Memcpy]]>>

<<function [[Malloc]]>>

<<global [[waitpids]]>>
<<global [[nwaitpids]]>>

<<function [[addwaitpid]]>>

<<function [[delwaitpid]]>>

<<function [[clearwaitpids]]>>

<<function [[havewaitpid]]>>

<<function [[_efgfmt]]>>
@


\subsection*{[[rc/glob.c]]}


%-------------------------------------------------------------

<<rc/glob.c>>=
#include "rc.h"
#include "exec.h"
#include "fns.h"

int	matchfn(void*, void*);

<<global [[globname]]>>
<<global [[globv]]>>
<<function [[deglob]]>>

<<function [[globcmp]]>>

<<function [[globsort]]>>
<<function [[globdir]]>>
<<function [[glob]]>>

<<function [[equtf]]>>

<<function [[nextutf]]>>

<<function [[unicode]]>>

<<function [[matchfn]]>>

<<function [[match]]>>

<<function [[globlist1]]>>

<<function [[globlist]]>>
@


\subsection*{[[rc/exec.c]]}

%-------------------------------------------------------------

<<rc/exec.c>>=
#include "rc.h"
#include "getflags.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

char*	list2str(word*);

<<global [[argv0]]>>

<<function [[start]]>>

<<function [[newword]]>>

<<function [[pushword]]>>

<<function [[popword]]>>

<<function [[freelist]]>>

<<function [[pushlist]]>>

<<function [[poplist]]>>

<<function [[count]]>>

<<function [[pushredir]]>>

<<function [[newvar]]>>

/*
 * get command line flags.
 * initialize keywords & traps.
 * get values from environment.
 * set $pid, $cflag, $*
 * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)
 * start interpreting code
 */
<<function main (rc/exec.c)>>

/*
 * Opcode routines
 * Arguments on stack (...)
 * Arguments in line [...]
 * Code in line with jump around {...}
 *
 * Xappend(file)[fd]			open file to append
 * Xassign(name, val)			assign val to name
 * Xasync{... Xexit}			make thread for {}, no wait
 * Xbackq{... Xreturn}			make thread for {}, push stdout
 * Xbang				complement condition
 * Xcase(pat, value){...}		exec code on match, leave (value) on
 * 					stack
 * Xclose[i]				close file descriptor
 * Xconc(left, right)			concatenate, push results
 * Xcount(name)				push var count
 * Xdelfn(name)				delete function definition
 * Xdelhere
 * Xdol(name)				get variable value
 * Xdup[i j]				dup file descriptor
 * Xeflag
 * Xerror
 * Xexit				rc exits with status
 * Xfalse{...}				execute {} if false
 * Xfn(name){... Xreturn}			define function
 * Xfor(var, list){... Xreturn}		for loop
 * Xglob
 * Xif
 * Xifnot
 * Xjump[addr]				goto
 * Xlocal(name, val)			create local variable, assign value
 * Xmark				mark stack
 * Xmatch(pat, str)			match pattern, set status
 * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,
 * 					wait for both
 * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output,
 * 					depending on type), push /dev/fd/??
 * Xpipewait
 * Xpopm(value)				pop value from stack
 * Xpopredir
 * Xrdcmds
 * Xrdfn
 * Xrdwr(file)[fd]			open file for reading and writing
 * Xread(file)[fd]			open file to read
 * Xqdol(name)				concatenate variable components
 * Xreturn				kill thread
 * Xsimple(args)			run command and wait
 * Xsub
 * Xsubshell{... Xexit}			execute {} in a subshell and wait
 * Xtrue{...}				execute {} if true
 * Xunlocal				delete local variable
 * Xwastrue
 * Xword[string]			push string
 * Xwrite(file)[fd]			open file to write
 */

<<function [[Xappend]]>>

<<function [[Xsettrue]]>>

<<function [[Xbang]]>>

<<function [[Xclose]]>>

<<function [[Xdup]]>>

<<function [[Xeflag]]>>

<<function [[Xexit]]>>

<<function [[Xfalse]]>>
<<global [[ifnot]]>>

<<function [[Xifnot]]>>

<<function [[Xjump]]>>

<<function [[Xmark]]>>

<<function [[Xpopm]]>>

<<function [[Xread]]>>

<<function [[Xrdwr]]>>

<<function [[turfredir]]>>

<<function [[Xpopredir]]>>

<<function [[Xreturn]]>>

<<function [[Xtrue]]>>

<<function [[Xif]]>>

<<function [[Xwastrue]]>>

<<function [[Xword]]>>

<<function [[Xwrite]]>>

<<function [[list2str]]>>

<<function [[Xmatch]]>>

<<function [[Xcase]]>>

<<function [[conclist]]>>

<<function [[Xconc]]>>

<<function [[Xassign]]>>
<<function [[copywords]]>>

<<function [[Xdol]]>>

<<function [[Xqdol]]>>

<<function [[copynwords]]>>

<<function [[subwords]]>>

<<function [[Xsub]]>>

<<function [[Xcount]]>>

<<function [[Xlocal]]>>

<<function [[Xunlocal]]>>

<<function [[freewords]]>>

<<function [[Xfn]]>>

<<function [[Xdelfn]]>>

<<function [[concstatus]]>>

<<function [[Xpipewait]]>>

<<function [[Xrdcmds]]>>

<<function [[Xerror]]>>

<<function [[Xerror1]]>>

<<function [[setstatus]]>>

<<function [[getstatus]]>>

<<function [[truestatus]]>>

<<function [[Xdelhere]]>>

<<function [[Xfor]]>>

<<function [[Xglob]]>>
@


\subsection*{[[rc/havefork.c]]}


%-------------------------------------------------------------

<<rc/havefork.c>>=
#include "rc.h"
#include "getflags.h"
#include "exec.h"
#include "io.h"
#include "fns.h"
#include <string.h>

<<function [[Xasync]]>>

<<function [[Xpipe]]>>

<<function [[Xbackq]]>>

<<function [[Xpipefd]]>>

<<function [[Xsubshell]]>>

<<function [[execforkexec]]>>
@


\subsection*{[[rc/tree.c]]}


%-------------------------------------------------------------

<<rc/tree.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"
#include "x.tab.h"

void freetree(tree*);

<<global [[treenodes]]>>
<<function [[newtree]]>>

<<function [[freenodes]]>>

<<function [[tree1]]>>

<<function [[tree2]]>>

<<function [[tree3]]>>

<<function [[mung1]]>>

<<function [[mung2]]>>

<<function [[mung3]]>>

<<function [[epimung]]>>
<<function [[simplemung]]>>

<<function [[token]]>>

@
%dead: <<function freetree>>

\subsection*{[[rc/lex.c]]}


%-------------------------------------------------------------

<<rc/lex.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "getflags.h"
#include "fns.h"
#include "x.tab.h"

int getnext(void);


<<function [[wordchr]]>>

<<function [[idchr]]>>

<<global [[future]]>>
<<global [[doprompt]]>>
<<global [[inquote]]>>
<<global [[incomm]]>>

<<function [[nextc]]>>
<<function [[advance]]>>
<<function [[getnext]]>>

<<function [[pprompt]]>>

<<function [[skipwhite]]>>

<<function [[skipnl]]>>

<<function [[nextis]]>>

<<function [[addtok]]>>

<<function [[addutf]]>>

<<global [[lastdol]]>>
<<global lastword (rc/lex.c)>>

<<function [[yylex]]>>
@


\subsection*{[[rc/trap.c]]}


%-------------------------------------------------------------

<<rc/trap.c>>=
#include "rc.h"
#include "exec.h"
#include "fns.h"
#include "io.h"
extern char *signame[];

<<function [[dotrap]]>>
@


\subsection*{[[rc/simple.c]]}


%-------------------------------------------------------------

<<rc/simple.c>>=
/*
 * Maybe `simple' is a misnomer.
 */
#include "rc.h"
#include "getflags.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

word*	searchpath(char*);
void execfunc(var*);
int	mapfd(int);

<<function [[exitnext]]>>

<<function [[Xsimple]]>>
<<global [[nullpath]]>>

<<function [[doredir]]>>

<<function [[searchpath]]>>

<<function [[execexec]]>>

<<function [[execfunc]]>>

<<function [[dochdir]]>>

<<function [[appfile]]>>

<<function [[execcd]]>>

<<function [[execexit]]>>

<<function [[execshift]]>>

<<function [[mapfd]]>>
<<global [[rdcmds]]>>

<<function [[execcmds]]>>

<<function [[execeval]]>>
<<global [[dotcmds]]>>

<<function [[execdot]]>>

<<function [[execflag]]>>

<<function [[execwhatis]]>>

<<function [[execwait]]>>
@


\subsection*{[[rc/pcmd.c]]}


%-------------------------------------------------------------

<<rc/pcmd.c>>=
#include "rc.h"
#include "io.h"
#include "fns.h"
#include "x.tab.h"
<<global [[nl]]>>
<<constant [[c0]]>>
<<constant [[c1]]>>
<<constant [[c2]]>>

<<function [[pdeglob]]>>

<<function [[pcmd]]>>
@


\subsection*{[[rc/here.c]]}

%-------------------------------------------------------------

<<rc/here.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"
#include "x.tab.h"

<<global [[here]]>>
<<global [[ehere]]>>
<<global [[ser]]>>
<<global tmp (rc/here.c)>>
<<global [[hex]]>>

void psubst(io*, uchar*);
void pstrs(io*, word*);

<<function [[hexnum]]>>

<<function [[heredoc]]>>

<<constant [[NLINE]]>>

<<function [[readhere]]>>

<<function [[psubst]]>>

<<function [[pstrs]]>>
@


\subsection*{[[rc/code.c]]}

%-------------------------------------------------------------


<<rc/code.c>>=
#include "rc.h"
#include "io.h"
#include "exec.h"
#include "fns.h"
#include "getflags.h"
#include "x.tab.h"

<<constant c0 (rc/code.c)>>
<<constant c1 (rc/code.c)>>
<<constant c2 (rc/code.c)>>
<<global [[codep]]>>
<<global [[ncode]]>>
<<function [[emitf]]>>
<<function [[emiti]]>>
<<function [[emits]]>>
void stuffdot(int);
char *fnstr(tree*);
void outcode(tree*, int);
void codeswitch(tree*, int);
int iscase(tree*);
code *codecopy(code*);
void codefree(code*);

<<function [[morecode]]>>

<<function [[stuffdot]]>>

<<function [[compile]]>>

<<function [[cleanhere]]>>

<<function [[fnstr]]>>

<<function [[outcode]]>>
<<function [[codeswitch]]>>

<<function [[iscase]]>>

<<function [[codecopy]]>>

<<function [[codefree]]>>
@


\subsection*{[[rc/pfnc.c]]}

%-------------------------------------------------------------

<<rc/pfnc.c>>=
#include "rc.h"
#include "exec.h"
#include "io.h"
#include "fns.h"

<<global [[fname]]>>

<<function [[pfnc]]>>
@
