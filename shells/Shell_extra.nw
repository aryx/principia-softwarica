\chapter{Extra Code}

\section{[[misc/]]}

\subsection{[[misc/echo.c]]}

<<function [[main]]>>=
void
main(int argc, char *argv[])
{
    int nflag;
    int i, len;
    char *buf, *p;

    nflag = 0;
    if(argc > 1 && strcmp(argv[1], "-n") == 0)
        nflag = 1;

    len = 1;
    for(i = 1+nflag; i < argc; i++)
        len += strlen(argv[i])+1;

    buf = malloc(len);
    if(buf == 0)
        exits("no memory");

    p = buf;
    for(i = 1+nflag; i < argc; i++){
        strcpy(p, argv[i]);
        p += strlen(p);
        if(i < argc-1)
            *p++ = ' ';
    }
        
    if(!nflag)
        *p++ = '\n';

    if(write(1, buf, p-buf) < 0){
        fprint(2, "echo: write error: %r\n");
        exits("write error");
    }

    exits((char *)nil);
}
@


%-------------------------------------------------------------

<<misc/echo.c>>=
#include <u.h>
#include <libc.h>

<<function [[main]]>>
@


\subsection{[[misc/pwd.c]]}

<<function main (misc/pwd.c)>>=
/*
 * Print working (current) directory
 */
void
main(int argc, char *argv[])
{
    char pathname[512];

    USED(argc, argv);
    if(getwd(pathname, sizeof(pathname)) == 0) {
        fprint(2, "pwd: %r\n");
        exits("getwd");
    }
    print("%s\n", pathname);
    exits(nil);
}
@


%-------------------------------------------------------------

<<misc/pwd.c>>=
#include <u.h>
#include <libc.h>

<<function main (misc/pwd.c)>>
@


\subsection{[[misc/test.c]]}

<<function [[EQ]]>>=
#define EQ(a,b)	((tmp=a)==0?0:(strcmp(tmp,b)==0))
@

<<global [[ap]]>>=
int	ap;
@

<<global [[ac]]>>=
int	ac;
@

<<global [[av]]>>=
char	**av;
@

<<global [[tmp]]>>=
static char	*tmp;
@

<<function main (misc/test.c)>>=
void
main(int argc, char *argv[])
{
    int r;
    char *c;

    ac = argc; av = argv; ap = 1;
    if(EQ(argv[0],"[")) {
        if(!EQ(argv[--ac],"]"))
            synbad("] missing","");
    }
    argv[ac] = 0;
    if (ac<=1)
        exits("usage");
    r = e();
    /*
     * nice idea but short-circuit -o and -a operators may have
     * not consumed their right-hand sides.
     */
    if(false && (c = nxtarg(1)) != nil)
        synbad("unexpected operator/operand: ", c);
    exits(r? nil : "false");
}
@

<<function [[nxtarg]]>>=
char *
nxtarg(int mt)
{
    if(ap>=ac){
        if(mt){
            ap++;
            return(0);
        }
        synbad("argument expected","");
    }
    return(av[ap++]);
}
@

<<function [[nxtintarg]]>>=
bool
nxtintarg(int *pans)
{
    if(ap<ac && isint(av[ap], pans)){
        ap++;
        return true;
    }
    return false;
}
@

<<function [[e]]>>=
int
e(void)
{
    int p1;

    p1 = e1();
    if (EQ(nxtarg(1), "-o"))
        return(p1 || e());
    ap--;
    return(p1);
}
@

<<function [[e1]]>>=
int
e1(void)
{
    int p1;

    p1 = e2();
    if (EQ(nxtarg(1), "-a"))
        return (p1 && e1());
    ap--;
    return(p1);
}
@

<<function [[e2]]>>=
int
e2(void)
{
    if (EQ(nxtarg(0), "!"))
        return(!e2());
    ap--;
    return(e3());
}
@

<<function [[e3]]>>=
bool
e3(void)
{
    int p1, int1, int2;
    char *a, *p2;

    a = nxtarg(0);
    if(EQ(a, "(")) {
        p1 = e();
        if(!EQ(nxtarg(0), ")"))
            synbad(") expected","");
        return(p1);
    }

    if(EQ(a, "-A"))
        return(hasmode(nxtarg(0), DMAPPEND));

    if(EQ(a, "-L"))
        return(hasmode(nxtarg(0), DMEXCL));

    if(EQ(a, "-T"))
        return(hasmode(nxtarg(0), DMTMP));

    if(EQ(a, "-f"))
        return(isreg(nxtarg(0)));

    if(EQ(a, "-d"))
        return(isdir(nxtarg(0)));

    if(EQ(a, "-r"))
        return(tio(nxtarg(0), 4));

    if(EQ(a, "-w"))
        return(tio(nxtarg(0), 2));

    if(EQ(a, "-x"))
        return(tio(nxtarg(0), 1));

    if(EQ(a, "-e"))
        return(tio(nxtarg(0), 0));

    if(EQ(a, "-c"))
        return false;

    if(EQ(a, "-b"))
        return false;

    if(EQ(a, "-u"))
        return false;

    if(EQ(a, "-g"))
        return false;

    if(EQ(a, "-s"))
        return(fsizep(nxtarg(0)));

    if(EQ(a, "-t"))
        if(ap>=ac)
            return(isatty(1));
        else if(nxtintarg(&int1))
            return(isatty(int1));
        else
            synbad("not a valid file descriptor number ", "");

    if(EQ(a, "-n"))
        return(!EQ(nxtarg(0), ""));
    if(EQ(a, "-z"))
        return(EQ(nxtarg(0), ""));

    p2 = nxtarg(1);
    if (p2==0)
        return(!EQ(a,""));
    if(EQ(p2, "="))
        return(EQ(nxtarg(0), a));

    if(EQ(p2, "!="))
        return(!EQ(nxtarg(0), a));

    if(EQ(p2, "-older"))
        return(isolder(nxtarg(0), a));

    if(EQ(p2, "-ot"))
        return(isolderthan(nxtarg(0), a));

    if(EQ(p2, "-nt"))
        return(isnewerthan(nxtarg(0), a));

    if(!isint(a, &int1))
        synbad("unexpected operator/operand: ", p2);

    if(nxtintarg(&int2)){
        if(EQ(p2, "-eq"))
            return(int1==int2);
        if(EQ(p2, "-ne"))
            return(int1!=int2);
        if(EQ(p2, "-gt"))
            return(int1>int2);
        if(EQ(p2, "-lt"))
            return(int1<int2);
        if(EQ(p2, "-ge"))
            return(int1>=int2);
        if(EQ(p2, "-le"))
            return(int1<=int2);
    }

    synbad("unknown operator ",p2);
    return false;		/* to shut ken up */
}
@

<<function [[tio]]>>=
bool
tio(char *a, int f)
{
    return access (a, f) >= 0;
}
@

<<function [[hasmode]]>>=
/*
 * note that the name strings pointed to by Dir members are
 * allocated with the Dir itself (by the same call to malloc),
 * but are not included in sizeof(Dir), so copying a Dir won't
 * copy the strings it points to.
 */
bool
hasmode(char *f, ulong m)
{
    bool r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return false;
    r = (dir->mode & m) != 0;
    free(dir);
    return r;
}
@

<<function [[isdir]]>>=
bool
isdir(char *f)
{
    return hasmode(f, DMDIR);
}
@

<<function [[isreg]]>>=
bool
isreg(char *f)
{
    bool r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return false;
    r = (dir->mode & DMDIR) == 0;
    free(dir);
    return r;
}
@

<<function [[isatty]]>>=
int
isatty(int fd)
{
    int r;
    Dir *d1, *d2;

    d1 = dirfstat(fd);
    d2 = dirstat("/dev/cons");
    if (d1 == nil || d2 == nil)
        r = 0;
    else
        r = d1->type == d2->type && d1->dev == d2->dev &&
            d1->qid.path == d2->qid.path;
    free(d1);
    free(d2);
    return r;
}
@

<<function [[fsizep]]>>=
bool
fsizep(char *f)
{
    bool r;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return false;
    r = dir->length > 0;
    free(dir);
    return r;
}
@

<<function [[synbad]]>>=
void
synbad(char *s1, char *s2)
{
    int len;

    write(2, "test: ", 6);
    if ((len = strlen(s1)) != 0)
        write(2, s1, len);
    if ((len = strlen(s2)) != 0)
        write(2, s2, len);
    write(2, "\n", 1);
    exits("bad syntax");
}
@

<<function [[isint]]>>=
int
isint(char *s, int *pans)
{
    char *ep;

    *pans = strtol(s, &ep, 0);
    return (*ep == 0);
}
@

<<function [[isolder]]>>=
bool
isolder(char *pin, char *f)
{
    int r, rel;
    ulong n, m;
    char *p = pin;
    Dir *dir;

    dir = dirstat(f);
    if (dir == nil)
        return false;

    /* parse time */
    n = 0;
    rel = 0;
    while(*p){
        m = strtoul(p, &p, 0);
        switch(*p){
        case 0:
            n = m;
            break;
        case 'y':
            m *= 12;
            /* fall through */
        case 'M':
            m *= 30;
            /* fall through */
        case 'd':
            m *= 24;
            /* fall through */
        case 'h':
            m *= 60;
            /* fall through */
        case 'm':
            m *= 60;
            /* fall through */
        case 's':
            n += m;
            p++;
            rel = 1;
            break;
        default:
            synbad("bad time syntax, ", pin);
        }
    }
    if (!rel)
        m = n;
    else{
        m = time(0);
        if (n > m)		/* before epoch? */
            m = 0;
        else
            m -= n;
    }
    r = dir->mtime < m;
    free(dir);
    return r;
}
@

<<function [[isolderthan]]>>=
int
isolderthan(char *a, char *b)
{
    int r;
    Dir *ad, *bd;

    ad = dirstat(a);
    bd = dirstat(b);
    if (ad == nil || bd == nil)
        r = 0;
    else
        r = ad->mtime > bd->mtime;
    free(ad);
    free(bd);
    return r;
}
@

<<function [[isnewerthan]]>>=
int
isnewerthan(char *a, char *b)
{
    int r;
    Dir *ad, *bd;

    ad = dirstat(a);
    bd = dirstat(b);
    if (ad == nil || bd == nil)
        r = 0;
    else
        r = ad->mtime < bd->mtime;
    free(ad);
    free(bd);
    return r;
}
@


%-------------------------------------------------------------

<<misc/test.c>>=
/*
 * POSIX standard
 *	test expression
 *	[ expression ]
 *
 * Plan 9 additions:
 *	-A file exists and is append-only
 *	-L file exists and is exclusive-use
 *	-T file exists and is temporary
 */

#include <u.h>
#include <libc.h>

<<function [[EQ]]>>

<<global [[ap]]>>
<<global [[ac]]>>
<<global [[av]]>>
<<global [[tmp]]>>

void	synbad(char *, char *);
int	fsizep(char *);
int	isdir(char *);
int	isreg(char *);
int	isatty(int);
int	isint(char *, int *);
int	isolder(char *, char *);
int	isolderthan(char *, char *);
int	isnewerthan(char *, char *);
int	hasmode(char *, ulong);
int	tio(char *, int);
int	e(void), e1(void), e2(void), e3(void);
char	*nxtarg(int);

<<function main (misc/test.c)>>

<<function [[nxtarg]]>>

<<function [[nxtintarg]]>>

<<function [[e]]>>

<<function [[e1]]>>

<<function [[e2]]>>

<<function [[e3]]>>

<<function [[tio]]>>

<<function [[hasmode]]>>

<<function [[isdir]]>>

<<function [[isreg]]>>

<<function [[isatty]]>>

<<function [[fsizep]]>>

<<function [[synbad]]>>

<<function [[isint]]>>

<<function [[isolder]]>>

<<function [[isolderthan]]>>

<<function [[isnewerthan]]>>
@


\section{[[sh/]]}

%TODO? maybe add an explain the sh.c code 
% (there is another small sh.c I don't remember where)
% in an appendix?

%helps understand high-level code orga and flow.
%cmd1 | cmd2 
%actually does 2 forks, and the interpreter continues! because
%maybe this pipe is part of a bigger command.
%
%also need to return pid in interpreter.

\subsection{[[sh/sh.c]]}

<<constant [[MAXLINE]]>>=
#define MAXLINE 200		/* maximum line length */
@

<<constant [[WORD]]>>=
#define WORD 256		/* token code for words */
@

<<constant [[EOF]]>>=
#define EOF -1			/* token code for end of file */
@

<<function [[ispunct]]>>=
#define ispunct(c)		(c=='|' || c=='&' || c==';' || c=='<' || \
                 c=='>' || c=='(' || c==')' || c=='\n')
@

<<function [[isspace]]>>=
#define isspace(c)		(c==' ' || c=='\t')
@

<<function [[execute]]>>=
#define execute(np)		(ignored = (np? (*(np)->op)(np) : 0))
@

<<struct [[Node]]>>=
struct Node {			/* parse tree node */
    int (*op)(Node *); 	/* operator function */
    Node *args[2];		/* argument nodes */
    char *argv[100];	/* argument pointers */
    char *io[3];		/* i/o redirection */
};
@

<<global [[nodes]]>>=
Node	nodes[25];		/* node pool */
@

<<global [[nfree]]>>=
Node	*nfree;			/* next available node */
@

<<global [[strspace]]>>=
char	strspace[10*MAXLINE];	/* string storage */
@

<<global [[sfree]]>>=
char	*sfree;			/* next free character in strspace */
@

<<global [[t]]>>=
int	t;			/* current token code */
@

<<global [[token]]>>=
char 	*token;			/* current token text (in strspace) */
@

<<global [[putback]]>>=
int	putback = 0;		/* lookahead */
@

<<global [[status]]>>=
char	status[256];		/* exit status of most recent command */
@

<<global [[cflag]]>>=
int	cflag = 0;		/* command is argument to sh */
@

<<global [[tflag]]>>=
int	tflag = 0;		/* read only one line */
@

<<global [[interactive]]>>=
bool	interactive = false;	/* prompt */
@

<<global [[cflagp]]>>=
char	*cflagp;		/* command line for cflag */
@

<<global [[path]]>>=
char	*path[] ={"/bin", 0};
@

<<global [[ignored]]>>=
int	ignored;
@

<<function main (sh/sh.c)>>=
void
main(int argc, char *argv[])
{
    Node *np;

    if(argc>1 && strcmp(argv[1], "-t")==0)
        tflag++;
    else if(argc>2 && strcmp(argv[1], "-c")==0){
        cflag++;
        cflagp = argv[2];
    }else if(argc>1){
        close(0);
        if(open(argv[1], 0) != 0){
            error(": can't open", argv[1]);
            exits("argument");
        }
    }else
        interactive = true;
    for(;;){
        if(interactive)
            fprint(2, "%d$ ", getpid());
        nfree = nodes;
        sfree = strspace;
        if((t=gettoken()) == EOF)
            break;
        if(t != '\n')
            if(np = list())
                execute(np);
            else
                error("syntax error", "");
        while(t!=EOF && t!='\n')	/* flush syntax errors */
            t = gettoken();
    }
    exits(status);
}
@

<<function [[alloc]]>>=
/* alloc - allocate for op and return a node */
Node*
alloc(int (*op)(Node *))
{
    if(nfree < nodes+sizeof(nodes)){
        nfree->op = op;
        nfree->args[0] = nfree->args[1] = 0;
        nfree->argv[0] = nfree->argv[1] = 0;
        nfree->io[0] = nfree->io[1] = nfree->io[2] = 0;
        return nfree++;
    }
    error("node storage overflow", "");
    exits("node storage overflow");
    return nil;
}
@

% return bool and do side effect of executing command before
<<function [[builtin]]>>=
/* builtin - check np for builtin command and, if found, execute it */
bool
builtin(Node *np)
{
    int n = 0;
    char name[MAXLINE];
    Waitmsg *wmsg;

    if(np->argv[1])
        n = strtoul(np->argv[1], 0, 0);
    if(strcmp(np->argv[0], "cd") == 0){
        if(chdir(np->argv[1]? np->argv[1] : "/") == -1)
            error(": bad directory", np->argv[0]);
        return true;
    }else if(strcmp(np->argv[0], "exit") == 0)
        exits(np->argv[1]? np->argv[1] : status);
    else if(strcmp(np->argv[0], "bind") == 0){
        if(np->argv[1]==0 || np->argv[2]==0)
            error("usage: bind new old", "");
        else if(bind(np->argv[1], np->argv[2], 0)==-1)
            error("bind failed", "");
        return true;
//#ifdef asdf
//	}else if(strcmp(np->argv[0], "unmount") == 0){
//		if(np->argv[1] == 0)
//			error("usage: unmount [new] old", "");
//		else if(np->argv[2] == 0){
//			if(unmount((char *)0, np->argv[1]) == -1)
//				error("unmount:", "");
//		}else if(unmount(np->argv[1], np->argv[2]) == -1)
//			error("unmount", "");
//		return true;
//#endif
    }else if(strcmp(np->argv[0], "wait") == 0){
        while((wmsg = wait()) != nil){
            strncpy(status, wmsg->msg, sizeof(status)-1);
            if(n && wmsg->pid==n){
                n = 0;
                free(wmsg);
                break;
            }
            free(wmsg);
        }
        if(n)
            error("wait error", "");
        return true;
    }else if(strcmp(np->argv[0], "rfork") == 0){
        char *p;
        int mask;

        p = np->argv[1];
        if(p == 0 || *p == 0)
            p = "ens";
        mask = 0;

        while(*p)
            switch(*p++){
            case 'n': mask |= RFNAMEG; break;
            case 'N': mask |= RFCNAMEG; break;
            case 'e': mask |= RFENVG; break;
            case 'E': mask |= RFCENVG; break;
            case 's': mask |= RFNOTEG; break;
            case 'f': mask |= RFFDG; break;
            case 'F': mask |= RFCFDG; break;
            case 'm': mask |= RFNOMNT; break;
            default: error(np->argv[1], "bad rfork flag");
            }
        rfork(mask);

        return OK_1;
    }else if(strcmp(np->argv[0], "exec") == 0){
        redirect(np);
        if(np->argv[1] == (char *) 0)
            return 1;
        exec(np->argv[1], &np->argv[1]);
        n = np->argv[1][0];
        if(n!='/' && n!='#' && (n!='.' || np->argv[1][1]!='/'))
            for(n = 0; path[n]; n++){
                sprint(name, "%s/%s", path[n], np->argv[1]);
                exec(name, &np->argv[1]);
            }
        error(": not found", np->argv[1]);
        return true;
    }
    // no builtin found
    return false;
}
@

<<function [[command]]>>=
/* command - ( list ) [ ( < | > | >> ) word ]* | simple */
Node*
command(void)
{
    Node *np;

    if(t != '(')
        return simple();
    np = alloc(xsubshell);
    t = gettoken();
    if((np->args[0]=list())==0 || t!=')')
        return nil;
    while((t=gettoken())=='<' || t=='>')
        if(!setio(np))
            return nil;
    return np;
}
@

<<function [[getch]]>>=
/* getch - get next, possibly pushed back, input character */
int
getch(void)
{
    unsigned char c;
    static int done=0;

    if(putback){
        c = putback;
        putback = 0;
    }else if(tflag){
        if(done || read(0, &c, 1)!=1){
            done = 1;
            return EOF;
        }
        if(c == '\n')
            done = 1;
    }else if(cflag){
        if(done)
            return EOF;
        if((c=*cflagp++) == 0){
            done = 1;
            c = '\n';
        }
    }else if(read(0, &c, 1) != 1)
        return EOF;
    return c;
}
@

<<function [[gettoken]]>>=
/* gettoken - get next token into string space, return token code */
int
gettoken(void)
{
    int c;

    while((c = getch()) != EOF)
        if(!isspace(c))
            break;
    if(c==EOF || ispunct(c))
        return c;
    token = sfree;
    do{
        if(sfree >= strspace+sizeof(strspace) - 1){
            error("string storage overflow", "");
            exits("string storage overflow");
        }
        *sfree++ = c;
    }while((c=getch()) != EOF && !ispunct(c) && !isspace(c));
    *sfree++ = 0;
    putback = c;
    return WORD;
}
@

<<function [[list]]>>=
/* list - pipeline ( ( ; | & ) pipeline )* [ ; | & ]  (not LL(1), but ok) */
Node*
list(void)
{
    Node *np, *np1;

    np = alloc(0);
    if((np->args[1]=pipeline()) == 0)
        return nil;
    while(t==';' || t=='&'){
        np->op = (t==';')? xwait : xnowait;
        t = gettoken();
        if(t==')' || t=='\n')	/* tests ~first(pipeline) */
            break;
        np1 = alloc(0);
        np1->args[0] = np;
        if((np1->args[1]=pipeline()) == 0)
            return nil;
        np = np1;
    }
    if(np->op == 0)
        np->op = xwait;
    return np;
}
@

<<function [[error]]>>=
/* error - print error message s, prefixed by t */
void
error(char *s, char *t)
{
    char buf[256];

    fprint(2, "%s%s", t, s);
    errstr(buf, sizeof buf);
    fprint(2, ": %s\n", buf);
}
@

<<function [[pipeline]]>>=
/* pipeline - command ( | command )* */
Node*
pipeline(void)
{
    Node *np, *np1;

    if((np=command()) == 0)
        return nil;
    while(t == '|'){
        np1 = alloc(xpipeline);
        np1->args[0] = np;
        t = gettoken();
        if((np1->args[1]=command()) == 0)
            return nil;
        np = np1;
    }
    return np;
}
@

<<function [[redirect]]>>=
/* redirect - redirect i/o according to np->io[] values */
void
redirect(Node *np)
{
    int fd;

    if(np->io[0]){
        if((fd = open(np->io[0], 0)) < 0){
            error(": can't open", np->io[0]);
            exits("open");
        }
        dup(fd, 0);
        close(fd);
    }
    if(np->io[1]){
        if((fd = create(np->io[1], 1, 0666L)) < 0){
            error(": can't create", np->io[1]);
            exits("create");
        }
        dup(fd, 1);
        close(fd);
    }
    if(np->io[2]){
        if((fd = open(np->io[2], 1)) < 0 && (fd = create(np->io[2], 1, 0666L)) < 0){
            error(": can't write", np->io[2]);
            exits("write");
        }
        dup(fd, 1);
        close(fd);
        seek(1, 0, 2);
    }
}
@

<<function [[setio]]>>=
/* setio - ( < | > | >> ) word; fill in np->io[] */
error0
setio(Node *np)
{
    if(t == '<'){
        t = gettoken();
        np->io[0] = token;
    }else if(t == '>'){
        t = gettoken();
        if(t == '>'){
            t = gettoken();
            np->io[2] = token;
            }else
            np->io[1] = token;
    }else
        return ERROR_0;
    if(t != WORD)
        return ERROR_0;
    return OK_1;
}
@

<<function [[simple]]>>=
/* simple - word ( [ < | > | >> ] word )* */
Node*
simple(void)
{
    Node *np;
    int n = 1;

    if(t != WORD)
        return nil;
    np = alloc(xsimple);
    np->argv[0] = token;
    while((t = gettoken())==WORD || t=='<' || t=='>')
        if(t == WORD)
            np->argv[n++] = token;
        else if(!setio(np))
            return nil;
    np->argv[n] = 0;
    return np;
}
@

<<function [[xpipeline]]>>=
/* xpipeline - execute cmd | cmd */
int
xpipeline(Node *np)
{
    int pid, fd[2];

    if(pipe(fd) < 0){
        error("can't create pipe", "");
        return 0;
    }
    if((pid=fork()) == 0){	/* left side; redirect stdout */
        dup(fd[1], 1);
        close(fd[0]);
        close(fd[1]);
        execute(np->args[0]);
        exits(status);
    }else if(pid == -1){
        error("can't create process", "");
        return 0;
    }
    if((pid=fork()) == 0){	/* right side; redirect stdin */
        dup(fd[0], 0);
        close(fd[0]);
        close(fd[1]);
        pid = execute(np->args[1]); /*BUG: this is wrong sometimes*/
        if(pid > 0)
            while(waitpid()!=pid)
                ;
        exits(nil);
    }else if(pid == -1){
        error("can't create process", "");
        return 0;
    }
    close(fd[0]);	/* avoid using up fd's */
    close(fd[1]);
    return pid;
}
@

<<function [[xsimple]]>>=
/* xsimple - execute a simple command */
int
xsimple(Node *np)
{
    char name[MAXLINE];
    int pid, i;

    if(builtin(np))
        return 0;

    if(pid = fork()){
        if(pid == -1)
            error(": can't create process", np->argv[0]);
        return pid;
    }
    redirect(np);	/* child process */
    exec(np->argv[0], &np->argv[0]);
    i = np->argv[0][0];

    if(i!='/' && i!='#' && (i!='.' || np->argv[0][1]!='/'))
        for(i = 0; path[i]; i++){
            sprint(name, "%s/%s", path[i], np->argv[0]);
            exec(name, &np->argv[0]);
        }
    error(": not found", np->argv[0]);
    exits("not found");
    return -1;		// suppress compiler warnings
}
@

<<function [[xsubshell]]>>=
/* xsubshell - execute (cmd) */
int
xsubshell(Node *np)
{
    int pid;

    if(pid = fork()){
        if(pid == -1)
            error("can't create process", "");
        return pid;
    }
    redirect(np);	/* child process */
    execute(np->args[0]);
    exits(status);
    return -1;		// suppress compiler warnings
}
@

<<function [[xnowait]]>>=
/* xnowait - execute cmd & */
int
xnowait(Node *np)
{
    int pid;

    execute(np->args[0]);
    pid = execute(np->args[1]);
    if(interactive)
        fprint(2, "%d\n", pid);
    return 0;
}
@

<<function [[xwait]]>>=
/* xwait - execute cmd ; */
int xwait(Node *np)
{
    int pid;
    Waitmsg *wmsg;

    execute(np->args[0]);
    pid = execute(np->args[1]);
    if(pid > 0){
        while((wmsg = wait()) != nil){
            if(wmsg->pid == pid)
                break;
            free(wmsg);
        }
        if(wmsg == nil)
            error("wait error", "");
        else {
            strncpy(status, wmsg->msg, sizeof(status)-1);
            free(wmsg);
        }
    }
    return 0;
}
@


%-------------------------------------------------------------

<<sh/sh.c>>=
/* sh - simple shell - great for early stages of porting */
#include <u.h>
#include <libc.h>

<<constant [[MAXLINE]]>>
<<constant [[WORD]]>>
<<constant [[EOF]]>>
<<function [[ispunct]]>>
<<function [[isspace]]>>
<<function [[execute]]>>

typedef struct Node	Node;
<<struct [[Node]]>>

<<global [[nodes]]>>
<<global [[nfree]]>>
<<global [[strspace]]>>
<<global [[sfree]]>>
<<global [[t]]>>
<<global [[token]]>>
<<global [[putback]]>>
<<global [[status]]>>
<<global [[cflag]]>>
<<global [[tflag]]>>
<<global [[interactive]]>>
<<global [[cflagp]]>>
<<global [[path]]>>
<<global [[ignored]]>>

// lexer
int	gettoken(void);
int	getch(void);
// parser (recursive descent)
Node	*list(void);
Node	*command(void);
Node	*simple(void);
Node	*pipeline(void);
int	setio(Node *np);
// interpreter
// see execute macro above
int	builtin(Node *np);


void	redirect(Node *np);

int	xpipeline(Node *np);
int	xsimple(Node *np);
int	xsubshell(Node *np);
int	xnowait(Node *np);
int	xwait(Node *np);

// error management
void	error(char *s, char *t);
// memory management
Node	*alloc(int (*op)(Node *));

<<function main (sh/sh.c)>>

<<function [[alloc]]>>

<<function [[builtin]]>>

<<function [[command]]>>

<<function [[getch]]>>

<<function [[gettoken]]>>

<<function [[list]]>>

<<function [[error]]>>

<<function [[pipeline]]>>

<<function [[redirect]]>>

<<function [[setio]]>>
            
<<function [[simple]]>>

<<function [[xpipeline]]>>

<<function [[xsimple]]>>

<<function [[xsubshell]]>>

<<function [[xnowait]]>>

<<function [[xwait]]>>
@






\section{[[rc/]]}

\subsection{[[rc/fns.h]]}

%-------------------------------------------------------------

<<rc/fns.h>>=

// for var.c, words.c, tree.c: see rc.h
// see also io.h and getflags.h

// input.c
int getnext(void);
int advance(void);
int nextc(void);
bool nextis(int c);
void	pprompt(void);
void	kinit(void);
tree *token(char*, int);
tree *klook(char*);

// lex.c
int	yylex(void);
//@Scheck: used in syn.y
void	skipnl(void);
int	idchr(int);

// syn.y
//@Scheck: defined in syn.y and y.tab.c
int	yyparse(void);

// executils.c
void	start(code*, int, var*);
void	pushlist(void);
void	poplist(void);
void	pushword(char*);
void	popword(void);
void	pushredir(int, int, int);

// status.c
char *getstatus(void);
void	setstatus(char*);
char* concstatus(char *s, char *t);
bool	truestatus(void);

// path.c
word*	searchpath(char*);

// env.c
void	Updenv(void);
void	Vinit(void);

// processes.c
int	Waitfor(int, bool);
void	Execute(word*,  word*);

// code.c
error0	compile(tree*);
code *codecopy(code*);
void	codefree(code*);
void	cleanhere(char*);

// trap.c
void	dotrap(void);
void	Trapinit(void);
bool	Eintr(void);
void	Noerror(void);

// here.c
void	readhere(void);
tree *heredoc(tree*);

// glob.c
void	deglob(void*);
void	globlist(void);
bool	match(void*, void*, int);

// utils.c
#define	new(type)	((type *)emalloc(sizeof(type)))
void *emalloc(long);
void efree(void *);
void	Memcpy(void*, void*, long);
long	Read(int, void*, long);
long	Write(int, void*, long);
long	Seek(int, long, long);
void	Unlink(char*);
int	Creat(char*);
int	Dup(int, int);
int	Opendir(char*);
int	Readdir(int, void*, int);
void	Closedir(int);
void	inttoascii(char*, long);

// error.c
void	panic(char*, int);
void	yyerror(char*);
void	Exit(char*, char*);

@


\subsection{[[rc/getflags.h]]}

%-------------------------------------------------------------

<<rc/getflags.h>>=
<<constant [[NFLAG]]>>

extern char **flag[NFLAG];
extern char *flagset[];

int getflags(int, char*[], char*, int);
void	usage(char*);
@


\subsection{[[rc/io.h]]}

%-------------------------------------------------------------

<<rc/io.h>>=
<<constant EOF (rc/io.h)>>
<<constant [[NBUF]]>>

<<struct [[Io]]>>

extern io *err;

// io.c
io *openfd(fdt);
io *openstr(void);
io *opencore(char *, int);
void closeio(io*);
void flush(io*);

int rchr(io*);
int rutf(io*, char*, Rune*);

// fmt.c
void pchr(io*, int);
void pstr(io*, char*);
void pfmt(io*, char*, ...);

// pcmd.c
void pcmd(io*, tree*);
// pfnc.c
void pfnc(io*, thread*);
@


\subsection{[[rc/rc.h]]}

%old:

%-------------------------------------------------------------

<<rc/rc.h>>=
/*
 * Assume plan 9 by default; if Unix is defined, assume unix.
 * Please don't litter the code with ifdefs.  The five below should be enough.
 */
#ifndef Unix
/* plan 9 */
#include <u.h>
#include <libc.h>

// could be in trap.c
<<constant [[NSIG]]>>
<<constant [[SIGINT]]>>
<<constant [[SIGQUIT]]>>

//???
//#define fcntl(fd, op, arg) /* unix compatibility */
//#define F_SETFD
//#define FD_CLOEXEC

//TODO:
#define __LOC__ "NO__LOC__INFO"

#else
#include "unix.h"

// magic incantation for cpp (found by chatGPT)
#define STR2(x) #x
#define STR(x) STR2(x)
#define __LOC__ __FILE__ ":" STR(__LINE__)

#endif

//#ifndef YYPREFIX
//#ifndef PAREN
//#include "x.tab.h"
//pad: better like that, otherwise get some "redefined FOR macro" error
//#endif
//#endif

//#ifndef Unix
//#pragma incomplete word
//#pragma incomplete io
//#endif


// MiscPlan9 is back in plan9.c

#ifndef ERRMAX
<<constant [[ERRMAX]]>>
#endif

<<constant [[YYMAXDEPTH]]>>

// forward decls
typedef struct Tree tree;
typedef struct Word word;
typedef struct Io io;
typedef union Code code;
typedef struct Var var;
typedef struct List list;
typedef struct Redir redir;
typedef struct Thread thread;
typedef struct Builtin builtin;

<<struct [[Tree]]>>

// tree.c
tree *newtree(void);
//@Scheck: useful, for syn.y, and not just for tree.c
tree *tree1(int, tree*);
tree *tree2(int, tree*, tree*);
//@Scheck: useful, for syn.y, and not just for tree.c
tree *tree3(int, tree*, tree*, tree*);
tree *mung1(tree*, tree*);
tree *mung2(tree*, tree*, tree*);
tree *mung3(tree*, tree*, tree*, tree*);
tree *epimung(tree*, tree*);
tree *simplemung(tree*);
void	freenodes(void);

<<struct [[Code]]>>

<<constant [[APPEND]]>>
<<constant [[WRITE]]>>
<<constant [[READ]]>>
<<constant [[HERE]]>>
<<constant [[DUPFD]]>>
<<constant [[CLOSE]]>>
<<constant [[RDWR]]>>

<<struct [[Word]]>>

// words.c
word *newword(char *, word *);
word *copywords(word *, word *);
word* copynwords(word *a, word *tail, int n);
void freelist(word *w);
void	freewords(word*);
int	count(word*);

<<struct [[Var]]>>

// var.c
var *vlook(char*);
var *gvlook(char*);
var *newvar(char*, var*);
void	setvar(char*, word*);

<<constant [[NVAR]]>>
extern var *gvar[NVAR];		/* hash for globals */

<<struct [[Here]]>>

<<constant [[GLOB]]>>

<<constant [[PRD]]>>
<<constant [[PWR]]>>

// globals.c
extern int mypid;
extern char *promptstr;
extern int ndot;
// input.c
extern bool doprompt;
extern bool inquote;
extern bool incomm;
extern int lastc;
// lex.c
extern bool lastword;
// error.c
extern int nerror;	/* number of errors encountered during compilation */

@


\subsection{[[rc/exec.h]]}


%-------------------------------------------------------------

<<rc/exec.h>>=
/*
 * Definitions used in the interpreter
 */
extern void Xappend(void), Xasync(void), Xbackq(void), Xbang(void), Xclose(void);
extern void Xconc(void), Xcount(void), Xdelfn(void), Xdol(void), Xqdol(void), Xdup(void);
extern void Xexit(void), Xfalse(void), Xfn(void), Xfor(void), Xglob(void);
extern void Xjump(void), Xmark(void), Xmatch(void), Xpipe(void), Xread(void);
extern void Xrdwr(void);
extern void Xrdfn(void), Xreturn(void), Xsubshell(void);
extern void Xtrue(void), Xword(void), Xwrite(void), Xpipefd(void), Xcase(void);
extern void Xlocal(void), Xunlocal(void), Xassign(void), Xsimple(void), Xpopm(void);
extern void Xrdcmds(void), Xwastrue(void), Xif(void), Xifnot(void), Xpipewait(void);
extern void Xdelhere(void), Xpopredir(void), Xsub(void), Xeflag(void), Xsettrue(void);
extern void Xerror(char*);
extern void Xerror1(char*);

<<struct [[Redir]]>>

<<constant [[NSTATUS]]>>
<<constant [[ROPEN]]>>
<<constant [[RDUP]]>>
<<constant [[RCLOSE]]>>

<<struct [[List]]>>

<<struct [[Thread]]>>

<<struct [[Builtin]]>>

// globals.c
extern thread *runq;
extern code *codebuf;		/* compiler output */
extern bool eflagok;		/* kludge flag so that -e doesn't exit in startup */
// path.c
extern word nullpath;
// trap.c
extern int ntrap;		/* number of outstanding traps */
// builtins.c
extern struct Builtin builtins[];

// simple.c
void execexec(void);
void execcmds(io *);
// processes.c
int  execforkexec(void);

@


\subsection{[[rc/globals.c]]}
%pad: I created this file, was in rc.h before (without not even the EXTERN trick)

<<rc/globals.c>>=
<<includes>>

// was in rc.h
<<global [[mypid]]>>
<<global [[promptstr]]>>
<<global [[ndot]]>>

// was in exec.h
<<global [[runq]]>>
<<global [[codebuf]]>>
<<global [[eflagok]]>>

@

\subsection{[[rc/getflags.c]]}


%-------------------------------------------------------------

<<rc/getflags.c>>=
#include "getflags.h"

extern void	Exit(char*, char*);
extern long	Write(int, void*, long);

static void reverse(char**, char**);
static int scanflag(int, char*);
static void errn(char*, int);
static void errs(char*);
static void errc(int);

<<global [[flagset]]>>
<<global [[flag]]>>
<<global [[cmdname]]>>
<<global [[flagarg]]>>
<<global [[reason]]>>

<<constant [[RESET]]>>
<<constant [[FEWARGS]]>>
<<constant [[FLAGSYN]]>>
<<constant [[BADFLAG]]>>

<<global [[badflag]]>>

<<function [[getflags]]>>

<<function [[reverse]]>>

<<function [[scanflag]]>>

<<function [[usage]]>>

<<function [[errn]]>>

<<function [[errs]]>>
<<constant NBUF (rc/getflags.c)>>
<<global [[buf]]>>
<<global [[bufp]]>>

<<function [[errc]]>>
@


\subsection{[[rc/io.c]]}


%-------------------------------------------------------------

<<rc/io.c>>=
<<includes>>

<<enum [[MiscConstants]]>>

// forward decls
int emptybuf(io*);
int fullbuf(io*, int);

<<function [[rchr]]>>

<<function [[rutf]]>>

<<function [[fullbuf]]>>

<<function [[flush]]>>

<<function [[openfd]]>>

<<function [[openstr]]>>

<<function [[opencore]]>>

<<function [[closeio]]>>

<<function [[emptybuf]]>>
@


\subsection{[[rc/input.c]]}
%pad: I created this file, its content was in var.c, tree.c, and lex.c

%-------------------------------------------------------------

<<rc/input.c>>=
<<includes>>
#include "y.tab.h"

// was in lex.c

<<global [[future]]>>
<<global [[doprompt]]>>
<<global [[inquote]]>>
<<global [[incomm]]>>

// was in rc.h
<<global [[lastc]]>>

// forward decl
int getnext(void);

<<function [[nextc]]>>
<<function [[advance]]>>
<<function [[getnext]]>>

<<function [[pprompt]]>>


<<function [[nextis]]>>


extern unsigned hash(char *as, int n);

// was in tree.c

<<function [[token]]>>

// was in var.c

<<constant [[NKW]]>>
<<struct [[Kw]]>>
<<global [[kw]]>>

<<function [[kenter]]>>

<<function [[kinit]]>>

<<function [[klook]]>>


@

\subsection{[[rc/var.c]]}


%-------------------------------------------------------------

<<rc/var.c>>=
<<includes>>

// was in rc.h
<<global [[gvar]]>>

<<function [[hash]]>>


<<function [[gvlook]]>>

<<function [[vlook]]>>

<<function [[setvar]]>>

<<function [[newvar]]>>

@


%\subsection{[[rc/subr.c]]}
%pad: merged with utils.c (that I created)

% <<rc/subr.c>>=
% <<includes>>
% 
% <<global [[bp]]>>
% 
% <<function [[iacvt]]>>
% 
% <<function [[inttoascii]]>>
% 
% @


\subsection{[[rc/env.c]]}
%pad: I created this file, its content was in plan9.c before

%-------------------------------------------------------------

<<rc/env.c>>=
<<includes>>

// the Vxxx are back in plan9.c
@


\subsection{[[rc/glob.c]]}

%-------------------------------------------------------------

<<rc/glob.c>>=
<<includes>>

bool	matchfn(void*, void*);

// NDIR and Globsize are back in plan9.c
extern int Globsize(char *p);

<<global [[globname]]>>
<<global [[globv]]>>
<<function [[deglob]]>>

<<function [[globcmp]]>>

<<function [[globsort]]>>
<<function [[globdir]]>>
<<function [[glob]]>>

<<function [[equtf]]>>

<<function [[nextutf]]>>

<<function [[unicode]]>>

<<function [[matchfn]]>>

<<function [[match]]>>

<<function [[globlist1]]>>

<<function [[globlist]]>>
@


\subsection{[[rc/executils.c]]}
%pad: I created this file, its content was in exec.c

%-------------------------------------------------------------

<<rc/executils.c>>=
<<includes>>

<<global [[argv0]]>>

<<function [[start]]>>


<<function [[pushword]]>>

<<function [[popword]]>>

<<function [[pushlist]]>>

<<function [[poplist]]>>


<<function [[pushredir]]>>


<<function [[Xerror]]>>

<<function [[Xerror1]]>>


<<function [[turfredir]]>>

<<function [[Xpopredir]]>>

<<function [[Xreturn]]>>

@

\subsection{[[rc/exec.c]]}

%-------------------------------------------------------------

<<rc/exec.c>>=
<<includes>>

/*
 * Opcode routines
 * Arguments on stack (...)
 * Arguments in line [...]
 * Code in line with jump around {...}
 *
 * Xappend(file)[fd]			open file to append
 * Xassign(name, val)			assign val to name
 * Xasync{... Xexit}			make thread for {}, no wait
 * Xbackq{... Xreturn}			make thread for {}, push stdout
 * Xbang				complement condition
 * Xcase(pat, value){...}		exec code on match, leave (value) on
 * 					stack
 * Xclose[i]				close file descriptor
 * Xconc(left, right)			concatenate, push results
 * Xcount(name)				push var count
 * Xdelfn(name)				delete function definition
 * Xdelhere
 * Xdol(name)				get variable value
 * Xdup[i j]				dup file descriptor
 * Xeflag
 * Xerror
 * Xexit				rc exits with status
 * Xfalse{...}				execute {} if false
 * Xfn(name){... Xreturn}			define function
 * Xfor(var, list){... Xreturn}		for loop
 * Xglob
 * Xif
 * Xifnot
 * Xjump[addr]				goto
 * Xlocal(name, val)			create local variable, assign value
 * Xmark				mark stack
 * Xmatch(pat, str)			match pattern, set status
 * Xpipe[i j]{... Xreturn}{... Xreturn}	construct a pipe between 2 new threads,
 * 					wait for both
 * Xpipefd[type]{... Xreturn}		connect {} to pipe (input or output,
 * 					depending on type), push /dev/fd/??
 * Xpipewait
 * Xpopm(value)				pop value from stack
 * Xpopredir
 * Xrdcmds
 * Xrdfn
 * Xrdwr(file)[fd]			open file for reading and writing
 * Xread(file)[fd]			open file to read
 * Xqdol(name)				concatenate variable components
 * Xreturn				kill thread
 * Xsimple(args)			run command and wait
 * Xsub
 * Xsubshell{... Xexit}			execute {} in a subshell and wait
 * Xtrue{...}				execute {} if true
 * Xunlocal				delete local variable
 * Xwastrue
 * Xword[string]			push string
 * Xwrite(file)[fd]			open file to write
 */

<<function [[Xappend]]>>

<<function [[Xsettrue]]>>

<<function [[Xbang]]>>

<<function [[Xclose]]>>

<<function [[Xdup]]>>

<<function [[Xeflag]]>>

<<function [[Xexit]]>>

<<function [[Xfalse]]>>
<<global [[ifnot]]>>

<<function [[Xifnot]]>>

<<function [[Xjump]]>>

<<function [[Xmark]]>>

<<function [[Xpopm]]>>

<<function [[Xread]]>>

<<function [[Xrdwr]]>>

<<function [[Xtrue]]>>

<<function [[Xif]]>>

<<function [[Xwastrue]]>>

<<function [[Xword]]>>

<<function [[Xwrite]]>>

<<function [[list2str]]>>

<<function [[Xmatch]]>>

<<function [[Xcase]]>>

<<function [[conclist]]>>

<<function [[Xconc]]>>

<<function [[Xassign]]>>

<<function [[Xdol]]>>

<<function [[Xqdol]]>>

<<function [[subwords]]>>

<<function [[Xsub]]>>

<<function [[Xcount]]>>

<<function [[Xlocal]]>>

<<function [[Xunlocal]]>>

<<function [[Xfn]]>>

<<function [[Xdelfn]]>>

<<function [[Xpipewait]]>>

<<function [[Xrdcmds]]>>

<<function [[Xdelhere]]>>

<<function [[Xfor]]>>

<<function [[Xglob]]>>

<<global [[envdir]]>>

// Xrdfn is back in plan9.c
@


\subsection{[[rc/processes.c]]}
%pad: this was called havefork.c before, and there was a
% haventfork.c file used for Microsoft Windows.

%-------------------------------------------------------------

<<rc/processes.c>>=
<<includes>>
//#include <string.h>

// Fdprefix, delwaitpid(), havewaitpid() Waitfor() are back in plan9.c
extern char *Fdprefix;

<<global [[waitpids]]>>
<<global [[nwaitpids]]>>
<<function [[addwaitpid]]>>
<<function [[clearwaitpids]]>>


<<function [[mkargv]]>>

<<function [[Execute]]>>

// was in havefork.c

<<function [[Xasync]]>>

<<function [[Xpipe]]>>

<<function [[Xbackq]]>>

<<function [[Xpipefd]]>>

<<function [[Xsubshell]]>>

<<function [[execforkexec]]>>
@


\subsection{[[rc/tree.c]]}


%-------------------------------------------------------------

<<rc/tree.c>>=
<<includes>>
#include "y.tab.h"

<<global [[treenodes]]>>
<<function [[newtree]]>>

<<function [[freenodes]]>>

<<function [[tree1]]>>

<<function [[tree2]]>>

<<function [[tree3]]>>

<<function [[mung1]]>>

<<function [[mung2]]>>

<<function [[mung3]]>>

<<function [[epimung]]>>
<<function [[simplemung]]>>

@
%dead: <<function freetree>>

\subsection{[[rc/lex.c]]}


%-------------------------------------------------------------

<<rc/lex.c>>=
<<includes>>
#include "y.tab.h"

<<constant [[NTOK]]>>

// was used by subr.c
<<global [[lastdol]]>>
<<global [[lastword]]>>
// was in rc.h
<<global [[tok]]>>

<<function [[wordchr]]>>

<<function [[idchr]]>>


<<function [[yyerror]]>>


<<function [[skipwhite]]>>

<<function [[skipnl]]>>

<<function [[addtok]]>>

<<function [[addutf]]>>

<<function [[yylex]]>>
@


\subsection{[[rc/trap.c]]}

%old: extern char *signame[];

%-------------------------------------------------------------

<<rc/trap.c>>=
<<includes>>

// NSIG, SIGINT, SIGQUIT are back in rc.h (under an ifdef for plan9)

// was in exec.h
<<global [[ntrap]]>>
<<global [[trap]]>>

// signame, syssigname, interrputed are back in plan9.c
// notifyf(), Trapinit(), Eintr(), Noerror() are back in plan9.c
extern char *signame[];

// generic part independent of plan9
<<function [[dotrap]]>>
@


\subsection{[[rc/simple.c]]}


%-------------------------------------------------------------

<<rc/simple.c>>=
/*
 * Maybe `simple' is a misnomer.
 */
<<includes>>

// forward decls
void execfunc(var*);

<<function [[exitnext]]>>

<<function [[Xsimple]]>>

<<function [[doredir]]>>

<<function [[execexec]]>>

<<function [[execfunc]]>>

<<global [[rdcmds]]>>

<<function [[execcmds]]>>

@


\subsection{[[rc/pcmd.c]]}


%-------------------------------------------------------------

<<rc/pcmd.c>>=
<<includes>>
#include "y.tab.h"

<<global [[nl]]>>
<<constant [[c0]]>>
<<constant [[c1]]>>
<<constant [[c2]]>>

<<function [[pdeglob]]>>

<<function [[pcmd]]>>
@


\subsection{[[rc/here.c]]}

%-------------------------------------------------------------

<<rc/here.c>>=
<<includes>>
#include "y.tab.h"

<<global [[here]]>>
<<global [[ehere]]>>
<<global [[ser]]>>
<<global tmp (rc/here.c)>>
<<global [[hex]]>>

void psubst(io*, uchar*);
void pstrs(io*, word*);

<<function [[hexnum]]>>

<<function [[heredoc]]>>

<<constant [[NLINE]]>>

<<function [[readhere]]>>

<<function [[psubst]]>>

<<function [[pstrs]]>>
@


\subsection{[[rc/code.c]]}

%-------------------------------------------------------------


<<rc/code.c>>=
<<includes>>
#include "y.tab.h"

<<constant c0 (rc/code.c)>>
<<constant c1 (rc/code.c)>>
<<constant c2 (rc/code.c)>>
<<global [[codep]]>>
<<global [[ncode]]>>
<<function [[emitf]]>>
<<function [[emiti]]>>
<<function [[emits]]>>


// forward decls
void outcode(tree*, bool);
void codeswitch(tree*, bool);
bool iscase(tree*);

<<function [[morecode]]>>

<<function [[stuffdot]]>>

<<function [[compile]]>>

<<function [[cleanhere]]>>

<<function [[fnstr]]>>

<<function [[outcode]]>>
<<function [[codeswitch]]>>

<<function [[iscase]]>>

<<function [[codecopy]]>>

<<function [[codefree]]>>
@


\subsection{[[rc/pfnc.c]]}

%-------------------------------------------------------------

<<rc/pfnc.c>>=
<<includes>>

<<global [[fname]]>>

<<function [[pfnc]]>>
@

\subsection{[[rc/utils.c]]}
%pad: I created this file, its content was mostly in subr.c and plan9.c

%-------------------------------------------------------------

<<rc/utils.c>>=
<<includes>>

// Opendir, Closedir and so on are back in plan9.c

<<function [[Unlink]]>>

<<function [[Write]]>>

<<function [[Read]]>>

<<function [[Seek]]>>

<<function [[Creat]]>>

<<function [[Dup]]>>


<<function [[Memcpy]]>>

// back in plan9.c
extern void* Malloc(ulong n);
<<function [[emalloc]]>>

<<function [[efree]]>>


<<global [[bp]]>>

<<function [[iacvt]]>>

<<function [[inttoascii]]>>

@

\subsection{[[rc/status.c]]}
%pad: I created this file, its content was in exec.c

%-------------------------------------------------------------

<<rc/status.c>>=
<<includes>>

<<function [[setstatus]]>>

<<function [[getstatus]]>>

<<function [[truestatus]]>>

<<function [[concstatus]]>>

@

\subsection{[[rc/builtins.c]]}
%pad: I created this file, its content was mostly in simple.c and plan9.c

%-------------------------------------------------------------

<<rc/builtins.c>>=
<<includes>>

<<function [[dochdir]]>>

<<function [[appfile]]>>

<<function [[mapfd]]>>


<<function [[execcd]]>>

<<function [[execexit]]>>

<<function [[execeval]]>>

<<function [[execflag]]>>

// was in plan9.c

<<function [[Executable]]>>

<<function [[execwhatis]]>>


<<function [[execshift]]>>


<<global [[dotcmds]]>>

<<function [[execdot]]>>


<<function [[execwait]]>>


<<function [[execnewpgrp]]>>


<<global [[rdfns]]>>

extern fdt envdir;

<<function [[execfinit]]>>


<<global [[builtins]]>>

@

\subsection{[[rc/path.c]]}
%pad: I created this file, its content was in simple.c

%-------------------------------------------------------------

<<rc/path.c>>=
<<includes>>

<<global [[nullpath]]>>

<<function [[searchpath]]>>

@

\subsection{[[rc/fmt.c]]}
%pad: I created this file, its content was mostly in io.c

%-------------------------------------------------------------

<<rc/fmt.c>>=
<<includes>>

<<global [[pfmtnest]]>>

// forward decls
void pdec(io*, int);
void poct(io*, unsigned int);
void pptr(io*, void*);
void pval(io*, word*);
void pquo(io*, char*);
void pwrd(io*, char*);

// in io.c
int fullbuf(io*, int);

<<function [[pfmt]]>>

<<function [[pchr]]>>

<<function [[pquo]]>>

<<function [[pwrd]]>>

<<function [[pptr]]>>

<<function [[pstr]]>>

<<function [[pdec]]>>

<<function [[poct]]>>

<<function [[pval]]>>

// _efgfmt is back in plan9.c
@

\subsection{[[rc/words.c]]}
%pad: I created this file, its content was mostly in exec.c

%-------------------------------------------------------------
<<rc/words.c>>=
<<includes>>

<<function [[newword]]>>

<<function [[freewords]]>>

<<function [[count]]>>

<<function [[copynwords]]>>

<<function [[copywords]]>>

<<function [[freelist]]>>

@

\subsection{[[rc/error.c]]}
%pad: I created this file, its content was mostly in subr.c

%-------------------------------------------------------------

<<rc/error.c>>=
<<includes>>

// was in rc.h
<<global [[nerror]]>>
<<global [[err]]>>

// forward decls
void Abort(void);

<<function [[panic]]>>

// Exit is back in plan9.c

<<function [[Abort]]>>

@

\subsection{[[rc/main.c]]}
%pad: I created this file, its content was mostly in exec.c

%-------------------------------------------------------------

<<rc/main.c>>=
<<includes>>

// Rcmain and Isatty are back in plan9.c
extern char* Rcmain;
extern bool Isatty(fdt fd);

/*
 * get command line flags.
 * initialize keywords & traps.
 * get values from environment.
 * set $pid, $cflag, $*
 * fabricate bootstrap code and start it (*=(argv);. /usr/lib/rcmain $*)
 * start interpreting code
 */
<<function main (rc/exec.c)>>

@



\subsection{[[rc/plan9.c]]}
%pad: I used to spread the content of plan9.c around
% but with goken I reintroduced it so we could have rc for unix too

%old: void execnewpgrp(void);

%-------------------------------------------------------------

<<rc/plan9.c>>=
/*
 * Plan 9 versions of system-specific functions
 *	By convention, exported routines herein have names beginning with an
 *	upper case letter.
 */
<<includes>>

// could be in main.c
<<global [[Rcmain]]>>
<<function [[Isatty]]>>

// could be in rc.h
<<enum [[MiscPlan9]]>>

// defined in trap.c
extern int trap[NSIG];
// defined in exec.c
extern fdt envdir;

// could be in env.c
<<function [[Vinit]]>>
<<function [[addenv]]>>
<<function [[updenvlocal]]>>
<<function [[Updenv]]>>

// could be in glob.c
<<constant [[NDIR]]>>
<<function [[Globsize]]>>

// could be in processes.c
<<global [[Fdprefix]]>>

// in processes.c
extern int *waitpids;
extern int nwaitpids;

<<function [[delwaitpid]]>>
<<function [[havewaitpid]]>>
<<function [[Waitfor]]>>

// could be in trap.c
<<global [[signame]]>>
<<global [[syssigname]]>>
<<global [[interrupted]]>>
<<function [[notifyf]]>>
<<function [[Trapinit]]>>
<<function [[Eintr]]>>
<<function [[Noerror]]>>

// could be in fmt.c
<<function [[_efgfmt]]>>

// could be in error.c
<<function [[Exit]]>>

// could be in exec.c
<<function [[Xrdfn]]>>

// could be in utils.c
<<function [[Malloc]]>>

// could be in utils.c
<<constant [[NFD]]>>
<<struct [[DirEntryWrapper]]>>
<<global [[dir]]>>
<<function [[trimdirs]]>>
<<function [[Readdir]]>>
<<function [[Opendir]]>>
<<function [[Closedir]]>>

@

\subsection{[[rc/unix.c]]}
%LATER: be more consistent with mk and choose Posix.c or unix.c

%-------------------------------------------------------------

<<rc/unix.c>>=
/*
 * Unix versions of system-specific functions
 * By convention, exported routines herein have names beginning with an
 * upper case letter.
 */
// to avoid conflict for wait(), waitpid() signatures
#define NOPLAN9DEFINES
#include "rc.h"
#include "io.h"
#include "exec.h"
#include "getflags.h"

//TODO? use plan9port errstr instead?
#include <errno.h>

// system-specific globals defined here but used in other files
char *Rcmain = "/usr/lib/rcmain";
char *Fdprefix = "/dev/fd/";

//******************************************************************************
// Environment
//******************************************************************************

#define	SEP	'\1'

word*
enval(char *s)
{
  char *t, c;
  word *v;
  for(t = s; *t && *t!=SEP; t++);
  c=*t;
  *t='\0';
  v = newword(s, c=='\0'?(word *)0:enval(t+1));
  *t = c;
  return v;
}

// set in Vinit()
char **environp;

void
Vinit(void)
{
  // see Unix environ(7) man page
  extern char **environ;
  char *s;
  char **env = environ;
  word* wd;
  environp = env;
  for(; *env; env++){
    for(s=*env; *s && *s!='(' && *s!='='; s++);
    switch(*s){
    case '\0':
      pfmt(err, "environment %q?\n", *env);
      break;
    case '=':
      *s='\0';
      wd = enval(s+1);
      setvar(*env, wd);
      //TODO: should generalize this in main.c so it also applies for Plan9
      if(strcmp(*env, "RCMAIN") == 0) {
 Rcmain = strdup(wd->word);
      }
      *s='=';
      break;
    case '(':	/* ignore functions for now */
      break;
    }
  }
}

//TODO: should be set in execfinit
char **envp = nil;

void
Xrdfn(void)
{
  char *s;
  int len;
  for(;*envp;envp++){
    for(s=*envp;*s && *s!='(' && *s!='=';s++);
    switch(*s){
    case '\0':
      pfmt(err, "environment %q?\n", *envp);
      break;
    case '=':	/* ignore variables */
      break;
    case '(':		/* Bourne again */
      s=*envp+3;
      envp++;
      len = strlen(s);
      s[len]='\n';
      execcmds(opencore(s, len+1));
      s[len]='\0';
      return;
    }
  }
  Xreturn();
}
//
//union code rdfns[4];
//
//void
//execfinit(void)
//{
//	static int first = 1;
//	if(first){
//		rdfns[0].i = 1;
//		rdfns[1].f = Xrdfn;
//		rdfns[2].f = Xjump;
//		rdfns[3].i = 1;
//		first = 0;
//	}
//	Xpopm();
//	envp = environp;
//	start(rdfns, 1, runq->local);
//}
//
//int
//cmpenv(const void *aa, const void *ab)
//{
//	char **a = aa, **b = ab;
//
//	return strcmp(*a, *b);
//}
//
//char **
//mkenv(void)
//{
//	char **env, **ep, *p, *q;
//	struct var **h, *v;
//	struct word *a;
//	int nvar = 0, nchr = 0, sep;
//
//	/*
//	 * Slightly kludgy loops look at locals then globals.
//	 * locals no longer exist - geoff
//	 */
//	for(h = gvar-1; h != &gvar[NVAR]; h++)
//	for(v = h >= gvar? *h: runq->local; v ;v = v->next){
//		if((v==vlook(v->name)) && v->val){
//			nvar++;
//			nchr+=strlen(v->name)+1;
//			for(a = v->val;a;a = a->next)
//				nchr+=strlen(a->word)+1;
//		}
//		if(v->fn){
//			nvar++;
//			nchr+=strlen(v->name)+strlen(v->fn[v->pc-1].s)+8;
//		}
//	}
//	env = (char **)emalloc((nvar+1)*sizeof(char *)+nchr);
//	ep = env;
//	p = (char *)&env[nvar+1];
//	for(h = gvar-1; h != &gvar[NVAR]; h++)
//	for(v = h >= gvar? *h: runq->local;v;v = v->next){
//		if((v==vlook(v->name)) && v->val){
//			*ep++=p;
//			q = v->name;
//			while(*q) *p++=*q++;
//			sep='=';
//			for(a = v->val;a;a = a->next){
//				*p++=sep;
//				sep = SEP;
//				q = a->word;
//				while(*q) *p++=*q++;
//			}
//			*p++='\0';
//		}
//		if(v->fn){
//			*ep++=p;
//			*p++='#'; *p++='('; *p++=')';	/* to fool Bourne */
//			*p++='f'; *p++='n'; *p++=' ';
//			q = v->name;
//			while(*q) *p++=*q++;
//			*p++=' ';
//			q = v->fn[v->pc-1].s;
//			while(*q) *p++=*q++;
//			*p++='\0';
//		}
//	}
//	*ep = 0;
//	qsort((void *)env, nvar, sizeof ep[0], cmpenv);
//	return env;	
//}

void
Updenv(void)
{
}

//******************************************************************************
// Signals/notes and Waitfor()
//******************************************************************************

char *sigmsg[] = {
/*  0 normal  */ 0,
/*  1 SIGHUP  */ "Hangup",
/*  2 SIGINT  */ 0,
/*  3 SIGQUIT */ "Quit",
/*  4 SIGILL  */ "Illegal instruction",
/*  5 SIGTRAP */ "Trace/BPT trap",
/*  6 SIGIOT  */ "abort",
/*  7 SIGEMT  */ "EMT trap",
/*  8 SIGFPE  */ "Floating exception",
/*  9 SIGKILL */ "Killed",
/* 10 SIGBUS  */ "Bus error",
/* 11 SIGSEGV */ "Memory fault",
/* 12 SIGSYS  */ "Bad system call",
/* 13 SIGPIPE */ 0,
/* 14 SIGALRM */ "Alarm call",
/* 15 SIGTERM */ "Terminated",
/* 16 unused  */ "signal 16",
/* 17 SIGSTOP */ "Process stopped",
/* 18 unused  */ "signal 18",
/* 19 SIGCONT */ "Process continued",
/* 20 SIGCHLD */ "Child death",
};

//pad: Note that plan9 Waitfor(), that was in processes.c (now in plan9.c), was
// compiling correctly also under Unix and I originally used it and rc
// was partially working. However, when called from mk (via MKSHELL), I had
// weird bugs like the $status was containing weird strings and so
// failing mk even if the command was run correctly.
// Anyway, simpler to uncomment and use the Waitfor() below.
void
Waitfor(int pid, bool persist)
{
 int wpid, sig;
 thread *p;
 int wstat;
 char wstatstr[12];

 for(;;){
  errno = 0;
  wpid = wait(&wstat);
  if(errno==EINTR && persist)
   continue;
  if(wpid==-1)
   break;
  sig = wstat&0177;
  if(sig==0177){
   pfmt(err, "trace: ");
   sig = (wstat>>8)&0177;
  }
  if(sig>(sizeof sigmsg/sizeof sigmsg[0]) || sigmsg[sig]){
   if(pid!=wpid)
    pfmt(err, "%d: ", wpid);
   if(sig<=(sizeof sigmsg/sizeof sigmsg[0]))
    pfmt(err, "%s", sigmsg[sig]);
   else if(sig==0177) pfmt(err, "stopped by ptrace");
   else pfmt(err, "signal %d", sig);
   if(wstat&0200)pfmt(err, " -- core dumped");
   pfmt(err, "\n");
  }
  wstat = sig?sig+1000:(wstat>>8)&0xFF;
  if(wpid==pid){
   inttoascii(wstatstr, wstat);
   setstatus(wstatstr);
   break;
  }
  else{
   for(p = runq->ret;p;p = p->ret)
    if(p->pid==wpid){
     p->pid=-1;
     inttoascii(p->status, wstat);
     break;
    }
  }
 }
}

char *signame[] = {
  "sigexit",	"sighup",	"sigint",	"sigquit",
  "sigill",	"sigtrap",	"sigiot",	"sigemt",
  "sigfpe",	"sigkill",	"sigbus",	"sigsegv",
  "sigsys",	"sigpipe",	"sigalrm",	"sigterm",
  "sig16",	"sigstop",	"sigtstp",	"sigcont",
  "sigchld",	"sigttin",	"sigttou",	"sigtint",
  "sigxcpu",	"sigxfsz",	"sig26",	"sig27",
  "sig28",	"sig29",	"sig30",	"sig31",
  0,
};

// defined in trap.c
extern int trap[NSIG];

void
gettrap(int sig)
{
  signal(sig, gettrap);
  trap[sig]++;
  ntrap++;
  if(ntrap>=NSIG){
    pfmt(err, "rc: Too many traps (trap %d), dumping core\n", sig);
    signal(SIGABRT, (void (*)())0);
    kill(getpid(), SIGABRT);
  }
}

void
Trapinit(void)
{
  int i;
  void (*sig)();

  if(1 || flag['d']){	/* wrong!!! */
    sig = signal(SIGINT, gettrap);
    if(sig==SIG_IGN)
      signal(SIGINT, SIG_IGN);
  }
  else{
    for(i = 1;i<=NSIG;i++) if(i!=SIGCHLD){
 sig = signal(i, gettrap);
 if(sig==SIG_IGN)
   signal(i, SIG_IGN);
      }
  }
}

//******************************************************************************
// Errno
//******************************************************************************

bool
Eintr(void){
  return errno==EINTR;
}

void
Noerror(void)
{
  errno = 0;
}

//******************************************************************************
// Directories
//******************************************************************************

#define	NDIR	14		/* should get this from param.h */
int
Globsize(char *p)
{
  int isglob = 0, globlen = NDIR+1;
  for(;*p;p++){
    if(*p==GLOB){
      p++;
      if(*p!=GLOB)
 isglob++;
      globlen+=*p=='*'?NDIR:1;
    }
    else
      globlen++;
  }
  return isglob?globlen:0;
}

#include <sys/types.h>
#include <dirent.h>

#define	NDIRLIST	50

DIR *dirlist[NDIRLIST];

Opendir(name)
     char *name;
{
  DIR **dp;
  for(dp = dirlist;dp!=&dirlist[NDIRLIST];dp++)
    if(*dp==0){
      *dp = opendir(name);
      return *dp?dp-dirlist:-1;
    }
  return -1;
}

int
Readdir(int f, char *p, int onlydirs)
{
  struct dirent *dp = readdir(dirlist[f]);

  if(dp==0)
    return 0;
  strcpy(p, dp->d_name);
  return 1;
}

void
Closedir(int f)
{
  closedir(dirlist[f]);
  dirlist[f] = 0;
}

//******************************************************************************
// Misc
//******************************************************************************

//char **
//mkargv(a)
//register struct word *a;
//{
//	char **argv = (char **)emalloc((count(a)+2)*sizeof(char *));
//	char **argp = argv+1;	/* leave one at front for runcoms */
//
//	for(;a;a = a->next)
//		*argp++=a->word;
//	*argp = 0;
//	return argv;
//}
//

//void
//Execute(struct word *args, struct word *path)
//{
//	char *msg="not found";
//	int txtbusy = 0;
//	char **env = mkenv();
//	char **argv = mkargv(args);
//	char file[512];
//
//	for(;path;path = path->next){
//		strcpy(file, path->word);
//		if(file[0])
//			strcat(file, "/");
//		strcat(file, argv[1]);
//ReExec:
//		execve(file, argv+1, env);
//		switch(errno){
//		case ENOEXEC:
//			pfmt(err, "%s: Bourne again\n", argv[1]);
//			argv[0]="sh";
//			argv[1] = strdup(file);
//			execve("/bin/sh", argv, env);
//			goto Bad;
//		case ETXTBSY:
//			if(++txtbusy!=5){
//				sleep(txtbusy);
//				goto ReExec;
//			}
//			msg="text busy"; goto Bad;
//		case EACCES:
//			msg="no access";
//			break;
//		case ENOMEM:
//			msg="not enough memory"; goto Bad;
//		case E2BIG:
//			msg="too big"; goto Bad;
//		}
//	}
//Bad:
//	pfmt(err, "%s: %s\n", argv[1], msg);
//	efree((char *)env);
//	efree((char *)argv);
//}


/*
 * Wrong:  should go through components of a|b|c and return the maximum.
 */
void
Exit(char *stat, char* loc)
{
  int n = 0;
  USED(loc);
  //if(flag['s'])
  //  fprint(STDERR, "Exit from %s: %s\n", loc, stat);

  while(*stat){
    if(*stat!='|'){
      if(*stat<'0' || '9'<*stat)
 exit(1);
      else n = n*10+*stat-'0';
    }
    stat++;
  }
  exit(n);
}

bool Isatty(fdt fd){
  return isatty(fd);
}

//void
//execumask(void)		/* wrong -- should fork before writing */
//{
//	int m;
//	struct io out[1];
//	switch(count(runq->argv->words)){
//	default:
//		pfmt(err, "Usage: umask [umask]\n");
//		setstatus("umask usage");
//		poplist();
//		return;
//	case 2:
//		umask(octal(runq->argv->words->next->word));
//		break;
//	case 1: 
//		umask(m = umask(0));
//		out->fd = mapfd(1);
//		out->bufp = out->buf;
//		out->ebuf=&out->buf[NBUF];
//		out->strp = 0;
//		pfmt(out, "%o\n", m);
//		break;
//	}
//	setstatus("");
//	poplist();
//}


void*
Malloc(unsigned long n)
{
  return (void *)malloc(n);
}

int
needsrcquote(int c)
{
  if(c <= ' ')
    return 1;
  if(strchr("`^#*[]=|\\?${}()'<>&;", c))
    return 1;
  return 0;
}

//void
//delwaitpid(int pid)
//{
//	int r, w;
//	
//	for(r=w=0; r<nwaitpids; r++)
//		if(waitpids[r] != pid)
//			waitpids[w++] = waitpids[r];
//	nwaitpids = w;
//}

//int
//havewaitpid(int pid)
//{
//	int i;
//
//	for(i=0; i<nwaitpids; i++)
//		if(waitpids[i] == pid)
//			return 1;
//	return 0;
//
//}

@
