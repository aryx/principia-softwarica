\documentclass[12pt]{report}
%alt: [12pt, twocolumn, landscape]

\input{../docs/latex/Packages}
\input{../docs/latex/Config}
\input{../docs/latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:

%thx to codemap/codegraph/scheck:

%thx to utilities in ocaml: (see also the %ocaml-found: tag in this file)

%thx to this manual, I better understand utilities:
% - tee: for seeing and logging to a file a command output
% - xargs: accept -p so can run jobs in parallel! easy parallelism
% - more/less/p: use of /dev/tty for interactive and stdin reading
% - ed: I learned to use ed! pretty cool tool and fun to understand g/re/p origin

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - SEMI put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * SEMI function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations


\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Utilities
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
many people
}

\maketitle 
%\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

%******************************************************************************
\chapter{Introduction}
%******************************************************************************

The goal of this book is to explain with full details the source code of
many {utilities}, especially utilities that are useful for the programmer
such as [[grep]] and [[sed]].

\section{Motivations}

% CLI is mandatory for programmer. Toolbox.

% cite great book by Kernighan on Software tools, lots of string processing tools
%  but use ratfor instead of C

% cite also "Unix programming environment" by Pike and Kernighan
% The code of most of the utilities used in this book are shown in this book!

\section{The \plan utilities}

\section{Other utilities}

%UNIX V5, OpenBSD, Plan 9, FreeBSD, and GNU coreutils implementations of echo.c
%https://gist.github.com/dchest/1091803
% evolution of a program :)

% suckless version in C: http://git.suckless.org/sbase/tree/README

% in Rust: https://github.com/uutils/coreutils/
% in Go: https://github.com/polegone/gonix
% in Javascript: https://github.com/dthree/cash/

% - busybox
%  https://en.wikipedia.org/wiki/BusyBox
% many commands in one binary, including shell ash
% the repository has lots of commands. 256 000 LOC in total.
% - toybox, BSD-licensed busybox-like, used in Android

% Lisp machine, Oberon, where REPL instead of separate CLI tools.


\section{Getting started}
\label{sec:getting-started}

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}


%******************************************************************************
\chapter{Overview}
%******************************************************************************

\section{Utilities principles}
% Unix philosophy: do one thing, separation of concern, minimalist
% CLI args and while(<>) of Perl style.

% Cite McIlroy spell paper comparing unix to Knuth style.

%high level explanations of coreutils:
% http://maizure.org/projects/decoded-gnu-coreutils/

% list of utilities specified in POSIX 1002.3
% see MISC/BIG/ape_cmd/README

\section{Command-line interfaces}

% -x flags, using one short letter (no GNU long opt and getopt stuff)
% a bit more cryptic but also simpler and discourage too many
% flags actually.
% CLI library is very simple, 3 macros in libc.h!

\section{Code organization}

\section{Software architecture}

<<plan9 includes>>=
#include <u.h>
#include <libc.h>
@

\section{Book structure}

%******************************************************************************
\chapter{Files and Directories}
%******************************************************************************

% could be part of the shell as builtin (in fact busybox/ash does that?)

\section{[[cat]]}
% see also pr(1), print listing

%trans: let's start with simplest one (LOC).

% 'cat' for concatenate but can be used also with single file to see its content
% and also without for copy stdin to stdout (usecase?)

% argv0 assignment is for sysfatal() which relies on this global.
% (why not automatic set in lib9/main ?)
<<function [[main]](cat.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    fdt f;

    argv0 = "cat";
    if(argc == 1)
        cat(STDIN, "<stdin>");
    else for(i=1; i<argc; i++){
        f = open(argv[i], OREAD);
        if(f < 0)
            sysfatal("can't open %s: %r", argv[i]);
        else{
            cat(f, argv[i]);
            close(f);
        }
    }
    exits(nil);
}
@
% %r is cool plan9 extension for errstr

<<function [[cat]]>>=
void
cat(fdt f, char *origin)
{
    char buf[8192];
    long n;

    while((n=read(f, buf, (long)sizeof buf))>0)
        if(write(STDOUT, buf, n)!=n)
            sysfatal("write error copying %s: %r", origin);
    if(n < 0)
        sysfatal("error reading %s: %r", origin);
}
@

\section{[[ls]]}

%toc:
% pretty big. > 1000 LOC
% first show minimal ls, then separate subsection for advanced usage

<<[[main]](ls.c) default case with usage>>=
fprint(STDERR, "usage: ls [-dlmnpqrstuFQT] [file ...]\n");
exits("usage");
@



<<struct [[NDir]]>>=
struct NDir
{
    // ref_own<Dir>
    Dir *d;
    // ?? for ls -lr ?
    char    *prefix;
};
@

% main data structure
<<globals ls.c>>=
// growing_array<ref_own<NDir> (size = ndirbuf, valid max = ndir)
NDir*   dirbuf;
int ndirbuf;
int ndir;
@


<<globals ls.c>>=
Biobuf  bin;
@
% ?? should be bout really

<<globals ls.c>>=
bool errs = false;
@

<<function [[main]](ls.c)>>=
void
main(int argc, char *argv[])
{
    int i;

    Binit(&bin, STDOUT, OWRITE);
    ARGBEGIN{
    <<[[main]](ls.c) switch flag character cases>>
    default:
       <<[[main]](ls.c) default case with usage>>
    }ARGEND

    //XXX: doquote = needsrcquote;
    quotefmtinstall();
    //XXX: fmtinstall('M', dirmodefmt);

    <<[[main]](ls.c) if [[lflag]]>>
    if(argc == 0)
        errs = ls(".", false);
    else for(i=0; i<argc; i++)
        errs |= ls(argv[i], true);

    output();
    exits(errs? "errors" : nil);
}
@

\subsection*{Basic listing}

% fill dirbuf for output() to work
<<function [[ls]]>>=
error1
ls(char *s, bool multi)
{
    fdt fd;
    long i, n;
    char *p;
    Dir *db;

    db = dirstat(s);
    if(db == nil){
    error:
        fprint(STDERR, "ls: %s: %r\n", s);
        return ERROR_1;
    }
    if((db->qid.type&QTDIR) && !dflag){
        free(db);
        output();
        fd = open(s, OREAD);
        if(fd == -1)
            goto error;
        n = dirreadall(fd, &db);
        if(n < 0)
            goto error;
        xcleanname(s);
        growto(ndir+n);
        for(i=0; i<n; i++){
            dirbuf[ndir+i].d = db+i;
            dirbuf[ndir+i].prefix = multi? s : nil;
        }
        ndir += n;
        close(fd);
        // why output() here? will be done in main() anyway
        output();
    }else{
        growto(ndir+1);
        dirbuf[ndir].d = db;
        dirbuf[ndir].prefix = nil;
        xcleanname(s);
        p = utfrrune(s, '/');
        if(p){
            dirbuf[ndir].prefix = s;
            *p = 0;
        }
        ndir++;
        // no output() ? will be done in main
    }
    return OK_0;
}
@

<<function [[growto]](ls.c)>>=
void
growto(long n)
{
    if(n <= ndirbuf)
        return;
    ndirbuf = n;
    dirbuf=(NDir *)realloc(dirbuf, ndirbuf*sizeof(NDir));
    if(dirbuf == nil){
        fprint(STDERR, "ls: malloc fail\n");
        exits("malloc fail");
    }
}
@

<<function [[xcleanname]](ls.c)>>=
/*
 * Compress slashes, remove trailing slash.  Don't worry about . and ..
 */
char*
xcleanname(char *name)
{
    char *r, *w;

    for(r=w=name; *r; r++){
        if(*r=='/' && r>name && *(r-1)=='/')
            continue;
        if(w != r)
            *w = *r;
        w++;
    }
    *w = '\0';
    while(w-1>name && *(w-1)=='/')
        *--w = '\0';
    return name;
}
@

<<function [[output]](ls.c)>>=
void
output(void)
{
    int i;
    char buf[4096];
    char *s;

    if(!nflag)
        qsort(dirbuf, ndir, sizeof dirbuf[0], (int (*)(const void*, const void*))compar);

    for(i=0; i<ndir; i++)
        dowidths(dirbuf[i].d);

    for(i=0; i<ndir; i++) {
        if(!pflag && (s = dirbuf[i].prefix)) {
            if(strcmp(s, "/") ==0)  /* / is a special case */
                s = "";
            sprint(buf, "%s/%s", s, dirbuf[i].d->name);
            format(dirbuf[i].d, buf);
        } else
            format(dirbuf[i].d, dirbuf[i].d->name);
    }
    ndir = 0;
    Bflush(&bin);
}
@

<<function [[compar]](ls.c)>>=
ord
compar(const NDir *a, const NDir *b)
{
    ord i;
    Dir *ad, *bd;

    ad = a->d;
    bd = b->d;

    if(tflag){
        if(uflag)
            i = bd->atime-ad->atime;
        else
            i = bd->mtime-ad->mtime;
    }else{
        if(a->prefix && b->prefix){
            i = strcmp(a->prefix, b->prefix);
            if(i == ORD__EQ)
                i = strcmp(ad->name, bd->name);
        }else if(a->prefix){
            i = strcmp(a->prefix, bd->name);
            if(i == ORD__EQ)
                i = ORD__SUP;  /* a is longer than b */
        }else if(b->prefix){
            i = strcmp(ad->name, b->prefix);
            if(i == ORD__EQ)
                i = ORD__INF; /* b is longer than a */
        }else
            i = strcmp(ad->name, bd->name);
    }
    if(i == ORD__EQ)
        i = (a<b? ORD__INF : ORD__SUP);
    if(rflag)
        i = -i;
    return i;
}
@

<<function [[format]](ls.c)>>=
void
format(Dir *db, char *name)
{
    int i;

    if(sflag)
        Bprint(&bin, "%*llud ",
            swidth, (db->length+1023)/1024);
    if(mflag){
        Bprint(&bin, "[%q] ", db->muid);
        for(i=2+strlen(db->muid); i<mwidth; i++)
            Bprint(&bin, " ");
    }
    if(qflag)
        Bprint(&bin, "(%.16llux %*lud %.2ux) ",
            db->qid.path,
            qwidth, db->qid.vers,
            db->qid.type);
    if(Tflag)
        Bprint(&bin, "%c ", (db->mode&DMTMP)? 't': '-');

    if(lflag)
        Bprint(&bin, "%M %C %*ud %*q %*q %*llud %s ",
            db->mode, db->type,
            vwidth, db->dev,
            -uwidth, db->uid,
            -gwidth, db->gid,
            lwidth, db->length,
            asciitime(uflag? db->atime: db->mtime));

    Bprint(&bin, Qflag? "%s%s\n": "%q%s\n", name, fileflag(db));
}
@


\subsection*{Advanced listings}

<<global flags ls.c>>=
// ??
bool dflag;
// ??
bool lflag;
// ??
bool mflag;
// ??
bool nflag;
// ??
bool pflag;
// ??
bool qflag;
// ??
bool Qflag;
// ??
bool rflag;
// ??
bool sflag;
// ??
bool tflag;
// ??
bool Tflag;
// ??
bool uflag;
// ??
bool Fflag;
@

<<[[main]](ls.c) switch flag character cases>>=
case 'F':   Fflag = true; break;
case 'd':   dflag = true; break;
case 'l':   lflag = true; break;
case 'm':   mflag = true; break;
case 'n':   nflag = true; break;
case 'p':   pflag = true; break;
case 'q':   qflag = true; break;
case 'Q':   Qflag = true; break;
case 'r':   rflag = true; break;
case 's':   sflag = true; break;
case 't':   tflag = true; break;
case 'T':   Tflag = true; break;
case 'u':   uflag = true; break;
@

<<globals ls.c>>=
int swidth;         /* max width of -s size */
int qwidth;         /* max width of -q version */
int vwidth;         /* max width of dev */
int uwidth;         /* max width of userid */
int mwidth;         /* max width of muid */
int lwidth;         /* max width of length */
int gwidth;         /* max width of groupid */
@

<<globals ls.c>>=
ulong   clk;
@

<<[[main]](ls.c) if [[lflag]]>>=
if(lflag)
    clk = time(0);
@



% for -F
<<function [[fileflag]](ls.c)>>=
char*
fileflag(Dir *db)
{
    if(!Fflag)
        return "";
    if(QTDIR & db->qid.type)
        return "/";
    if(0111 & db->mode)
        return "*";
    return "";
}
@


<<function [[dowidths]](ls.c)>>=
void
dowidths(Dir *db)
{
    char buf[256];
    int n;

    if(sflag) {
        n = sprint(buf, "%llud", (db->length+1023)/1024);
        if(n > swidth)
            swidth = n;
    }
    if(qflag) {
        n = sprint(buf, "%lud", db->qid.vers);
        if(n > qwidth)
            qwidth = n;
    }
    if(mflag) {
        n = snprint(buf, sizeof buf, "[%q]", db->muid);
        if(n > mwidth)
            mwidth = n;
    }
    if(lflag) {
        n = sprint(buf, "%ud", db->dev);
        if(n > vwidth)
            vwidth = n;
        n = sprint(buf, "%q", db->uid);
        if(n > uwidth)
            uwidth = n;
        n = sprint(buf, "%q", db->gid);
        if(n > gwidth)
            gwidth = n;
        n = sprint(buf, "%llud", db->length);
        if(n > lwidth)
            lwidth = n;
    }
}
@

<<function [[asciitime]](ls.c)>>=
char*
asciitime(long l)
{
    static char buf[32];
    char *t;

    t = ctime(l);
    /* 6 months in the past or a day in the future */
    if(l<clk-180L*24*60*60 || clk+24L*60*60<l){
        memmove(buf, t+4, 7);       /* month and day */
        memmove(buf+7, t+23, 5);        /* year */
    }else
        memmove(buf, t+4, 12);      /* skip day of week */
    buf[12] = '\0';
    return buf;
}
@

\section{[[touch]]}

% -c for nocreate if file not exist in the first place
<<function [[usage]](touch.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: touch [-c] [-t time] files\n");
    exits("usage");
}
@

<<global [[now]](touch.c)>>=
ulong now;
@

% strtoul str to ulong, and 0 3rd param is base.
% second param is ??
<<function [[main]](touch.c)>>=
void
main(int argc, char **argv)
{
    char *t, *s;
    bool nocreate = false;
    errorn status = OK_0;

    now = time(0);
    ARGBEGIN{
    case 't':
        t = EARGF(usage());
        now = strtoul(t, &s, 0);
        if(s == t || *s != '\0')
            usage();
        break;
    case 'c':
        nocreate = true;
        break;
    default:    
        usage();
    }ARGEND

    if(!*argv)
        usage();
    while(*argv)
        status += touch(nocreate, *argv++);
    if(status)
        exits("touch");
    exits(nil);
}
@

%nulldir?
%stbuff stat buffer?
<<function [[touch]]>>=
error1
touch(bool nocreate, char *name)
{
    Dir stbuff;
    fdt fd;

    nulldir(&stbuff);
    stbuff.mtime = now;
    if(dirwstat(name, &stbuff) >= 0)
        return OK_0;
    //else
    if(nocreate){
        fprint(STDERR, "touch: %s: cannot wstat: %r\n", name);
        return ERROR_1;
    }
    if((fd = create(name, OREAD|OEXCL, 0666)) < 0){
        fprint(STDERR, "touch: %s: cannot create: %r\n", name);
        return ERROR_1;
    }
    dirfwstat(fd, &stbuff);
    close(fd);
    return OK_0;
}
@

\section{[[mkdir]]}

% -p for creating intermediate dirs (p for parent dirs)
<<function [[usage]](mkdir.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: mkdir [-p] [-m mode] dir...\n");
    exits("usage");
}
@

<<global [[mode]](mkdir.c)>>=
ulong mode = 0777L;
@

<<global [[e]](mkdir.c)>>=
// error
char *e;
@

<<function [[main]](mkdir.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    bool pflag = false;
    char *m;

    ARGBEGIN{
    case 'm':
        m = ARGF();
        if(m == nil)
            usage();
        mode = strtoul(m, &m, 8);
        if(mode > 0777)
            usage();
        break;
    case 'p':
        pflag = true;
        break;
    default:
        usage();
    }ARGEND

    for(i=0; i<argc; i++){
        if(pflag)
            mkdirp(argv[i]);
        else
            makedir(argv[i]);
    }
    exits(e);
}
@

% return value used from mkdirp but not from main
<<function [[makedir]]>>=
errorneg1
makedir(char *s)
{
    fdt f;

    if(access(s, AEXIST) == 0){
        fprint(STDERR, "mkdir: %s already exists\n", s);
        e = "error";
        return ERROR_NEG1;
    }
    f = create(s, OREAD, DMDIR | mode);
    if(f < 0){
        fprint(STDERR, "mkdir: can't create %s: %r\n", s);
        e = "error";
        return ERROR_NEG1;
    }
    close(f);
    return OK_0;
}
@

<<function [[mkdirp]]>>=
void
mkdirp(char *s)
{
    char *p;

    for(p=strchr(s+1, '/'); p; p=strchr(p+1, '/')){
        *p = '\0';
        if(access(s, AEXIST) != 0 && makedir(s) == ERROR_NEG1)
            return;
        *p = '/';
    }
    if(access(s, AEXIST) != 0)
        makedir(s);
}
@

\section{[[rm]]}

<<global [[ignerr]](rm.c)>>=
// for 'rm -f'
bool ignerr = false;
@
% default value?? nil?
<<global [[errbuf]](rm.c)>>=
char errbuf[ERRMAX];
@

% remove() below is syscall
<<function [[main]](rm.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    // rm -r
    bool recurse = false;
    char *f;
    Dir *db;

    ARGBEGIN{
    case 'r':
        recurse = true;
        break;
    case 'f':
        ignerr = true;
        break;
    default:
        fprint(STDERR, "usage: rm [-fr] file ...\n");
        exits("usage");
    }ARGEND

    for(i=0; i<argc; i++){
        f = argv[i];
        if(remove(f) != ERROR_NEG1)
            continue;
        //else
        db = nil;
        if(recurse && (db=dirstat(f))!=nil && (db->qid.type&QTDIR))
            rmdir_(f);
        else
            err(f);
        free(db);
    }
    exits(errbuf);
}
@

<<function [[rmdir]]>>=
/*
 * f is a non-empty directory. Remove its contents and then it.
 */
void
rmdir_(char *f)
{
    char *name;
    int i, j, n, ndir, nname;
    fdt fd;
    Dir *dirbuf;

    fd = open(f, OREAD);
    if(fd < 0){
        err(f);
        return;
    }
    //else
    n = dirreadall(fd, &dirbuf);
    close(fd);
    if(n < 0){
        err("dirreadall");
        return;
    }

    nname = strlen(f)+1+STATMAX+1;  /* plenty! */
    name = malloc(nname);
    if(name == nil){
        err("memory allocation");
        return;
    }

    ndir = 0;
    for(i=0; i<n; i++){
        snprint(name, nname, "%s/%s", f, dirbuf[i].name);
        if(remove(name) != ERROR_NEG1)
            dirbuf[i].qid.type = QTFILE;    /* so we won't recurse */
        else{
            if(dirbuf[i].qid.type & QTDIR)
                ndir++;
            else
                err(name);
        }
    }
    if(ndir)
        for(j=0; j<n; j++)
            if(dirbuf[j].qid.type & QTDIR){
                snprint(name, nname, "%s/%s", f, dirbuf[j].name);
                // recurse
                rmdir_(name);
            }
    if(remove(f) == ERROR_NEG1)
        err(f);
    free(name);
    free(dirbuf);
}
@

<<function [[err]](rm.c)>>=
void
err(char *f)
{
    if(!ignerr){
        errbuf[0] = '\0';
        errstr(errbuf, sizeof errbuf);
        fprint(STDERR, "rm: %s: %s\n", f, errbuf);
    }
}
@

\section{[[cp]]}

<<global [[failed]](cp.c)>>=
bool failed;
@

<<global flags(cp.c)>>=
// keep gid
bool gflag = false;
// keep uid (-u implies -g)
bool uflag = false;
// keep time and mode
bool xflag = false;
@

<<label [[usage]] in [[main]](cp.c)>>=
usage:
    fprint(STDERR, "usage:\tcp [-gux] fromfile tofile\n");
    fprint(STDERR, "\tcp [-x] fromfile ... todir\n");
    exits("usage");
@

<<function [[main]](cp.c)>>=
void
main(int argc, char *argv[])
{
    Dir *dirb;
    int i;
    bool todir = false;

    ARGBEGIN {
    case 'g':
        gflag = true;
        break;
    case 'u':
        uflag = true;
        gflag = true;
        break;
    case 'x':
        xflag = true;
        break;
    default:
        goto usage;
    } ARGEND

    if(argc < 2)
        goto usage;

    dirb = dirstat(argv[argc-1]);
    if(dirb!=nil && (dirb->mode&DMDIR))
        todir=true;
    if(argc>2 && !todir){
        fprint(STDERR, "cp: %s not a directory\n", argv[argc-1]);
        exits("bad usage");
    }

    for(i=0; i<argc-1; i++)
        copy(argv[i], argv[argc-1], todir);

    if(failed)
        exits("errors");
    exits(nil);
<<label [[usage]] in [[main]](cp.c)>>
}
@

<<function [[copy]]>>=
void
copy(char *from, char *to, bool todir)
{
    Dir *dirb, dirt;
    char name[256];
    // fd from, fd to
    fdt fdf, fdt;
    int mode;

    if(todir){
        char *s, *elem;
        elem=s=from;
        while(*s++)
            if(s[-1]=='/')
                elem=s;
        sprint(name, "%s/%s", to, elem);
        to=name;
    }

    if((dirb=dirstat(from))==nil){
        fprint(STDERR,"cp: can't stat %s: %r\n", from);
        failed = true;
        return;
    }
    mode = dirb->mode;
    if(mode&DMDIR){
        fprint(STDERR, "cp: %s is a directory\n", from);
        free(dirb);
        failed = true;
        return;
    }
    if(samefile(dirb, from, to)){
        free(dirb);
        failed = true;
        return;
    }
    mode &= 0777;
    fdf=open(from, OREAD);
    if(fdf<0){
        fprint(STDERR, "cp: can't open %s: %r\n", from);
        free(dirb);
        failed = true;
        return;
    }
    fdt=create(to, OWRITE, mode);
    if(fdt<0){
        fprint(STDERR, "cp: can't create %s: %r\n", to);
        close(fdf);
        free(dirb);
        failed = true;
        return;
    }
    if(copy1(fdf, fdt, from, to)==OK_0 && (xflag || gflag || uflag)){
        nulldir(&dirt);
        if(xflag){
            dirt.mtime = dirb->mtime;
            dirt.mode = dirb->mode;
        }
        if(uflag)
            dirt.uid = dirb->uid;
        if(gflag)
            dirt.gid = dirb->gid;
        if(dirfwstat(fdt, &dirt) < 0)
            fprint(STDERR, "cp: warning: can't wstat %s: %r\n", to);
    }           
    free(dirb);
    close(fdf);
    close(fdt);
}
@

<<constant [[DEFB]](cp.c)>>=
#define DEFB    (8*1024)
@

<<function [[copy1]]>>=
errorneg1
copy1(fdt fdf, fdt fdt, char *from, char *to)
{
    char *buf;
    long n, n1, rcount;
    errorneg1 rv = OK_0;
    char err[ERRMAX];

    buf = malloc(DEFB);
    /* clear any residual error */
    err[0] = '\0';
    errstr(err, ERRMAX);

    // copy (read and write) as long as n read <= 0
    for(rcount=0;; rcount++) {
        n = read(fdf, buf, DEFB);
        if(n <= 0)
            break;
        n1 = write(fdt, buf, n);
        if(n1 != n) {
            fprint(STDERR, "cp: error writing %s: %r\n", to);
            failed = true;
            rv = ERROR_NEG1;
            break;
        }
    }
    if(n < 0) {
        fprint(2, "cp: error reading %s: %r\n", from);
        failed = true;
        rv = ERROR_NEG1;
    }
    free(buf);
    return rv;
}
@

<<function [[samefile]](cp.c)>>=
bool
samefile(Dir *a, char *an, char *bn)
{
    Dir *b;
    bool ret = false;

    b=dirstat(bn);
    if(b != nil)
    if(b->qid.type==a->qid.type)
    if(b->qid.path==a->qid.path)
    if(b->qid.vers==a->qid.vers)
    if(b->dev==a->dev)
    if(b->type==a->type){
        fprint(STDERR, "cp: %s and %s are the same file\n", an, bn);
        ret = true;
    }
    free(b);
    return ret;
}
@

\section{[[mv]]}

%mv: Can't do mv *.jpg *.JPEG :(
% unix haters handbook :)

<<function [[main]](mv.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    errorn failed = OK_0;
    Dir *dirto, *dirfrom;
    char *todir, *toelem;

    if(argc<3){
        fprint(STDERR, "usage: mv fromfile tofile\n");
        fprint(STDERR, "   mv fromfile ... todir\n");
        exits("bad usage");
    }

    /* prepass to canonicalise names before splitting, etc. */
    for(i=1; i < argc; i++)
        cleanname(argv[i]);

    if((dirto = dirstat(argv[argc-1])) != nil && (dirto->mode&DMDIR)){
        dirfrom = nil;
        if(argc == 3
        && (dirfrom = dirstat(argv[1])) != nil
        && (dirfrom->mode & DMDIR)) 
            split(argv[argc-1], &todir, &toelem); /* mv dir1 dir2 */
        else{               /* mv file... dir */
            todir = argv[argc-1];
            toelem = nil;       /* toelem will be fromelem */
        }
        free(dirfrom);
    }else
        split(argv[argc-1], &todir, &toelem);   /* mv file1 file2 */
    free(dirto);
    if(argc>3 && toelem != nil){
        fprint(STDERR, "mv: %s not a directory\n", argv[argc-1]);
        exits("bad usage");
    }

    for(i=1; i < argc-1; i++)
        if(mv(argv[i], todir, toelem) == ERROR_NEG1)
            failed++;
    if(failed)
        exits("failure");
    exits(nil);
}
@

<<function [[mv]]>>=
errorneg1
mv(char *from, char *todir, char *toelem)
{
    errorneg1 stat;
    Dir *dirb;

    dirb = dirstat(from);
    if(dirb == nil){
        fprint(STDERR, "mv: can't stat %s: %r\n", from);
        return ERROR_NEG1;
    }
    stat = mv1(from, dirb, todir, toelem);
    free(dirb);
    return stat;
}
@

<<function [[mv1]]>>=
errorneg1
mv1(char *from, Dir *dirb, char *todir, char *toelem)
{
    // fd from, fd to
    fdt fdf, fdt;
    int i, j;
    errorneg1 stat;
    char toname[4096], fromname[4096];
    char *fromdir, *fromelem;
    Dir *dirt, null;

    strncpy(fromname, from, sizeof fromname);
    split(from, &fromdir, &fromelem);
    if(toelem == nil)
        toelem = fromelem;
    i = strlen(toelem);
    if(i==0){
        fprint(STDERR, "mv: null last name element moving %s\n", fromname);
        return ERROR_NEG1;
    }
    j = strlen(todir);
    if(i + j + 2 > sizeof toname){
        fprint(STDERR, "mv: path too big (max %d): %s/%s\n",
            sizeof toname, todir, toelem);
        return ERROR_NEG1;
    }
    memmove(toname, todir, j);
    toname[j] = '/';
    memmove(toname+j+1, toelem, i);
    toname[i+j+1] = '\0';

    if(samefile(fromdir, todir)){
        if(samefile(fromname, toname)){
            fprint(STDERR, "mv: %s and %s are the same\n",
                fromname, toname);
            return ERROR_NEG1;
        }

        /* remove target if present */
        dirt = dirstat(toname);
        if(dirt != nil) {
            hardremove(toname);
            free(dirt);
        }

        /* try wstat */
        nulldir(&null);
        null.name = toelem;
        if(dirwstat(fromname, &null) >= 0)
            return OK_0;
        if(dirb->mode & DMDIR){
            fprint(STDERR, "mv: can't rename directory %s: %r\n",
                fromname);
            return ERROR_NEG1;
        }
    }
    /*
     * Renaming won't work --- must copy
     */
    if(dirb->mode & DMDIR){
        fprint(STDERR, "mv: %s is a directory, not copied to %s\n",
            fromname, toname);
        return ERROR_NEG1;
    }
    fdf = open(fromname, OREAD);
    if(fdf < 0){
        fprint(STDERR, "mv: can't open %s: %r\n", fromname);
        return ERROR_NEG1;
    }

    dirt = dirstat(toname);
    if(dirt != nil && (dirt->mode & DMAPPEND))
        hardremove(toname);  /* because create() won't truncate file */
    free(dirt);

    fdt = create(toname, OWRITE, dirb->mode);
    if(fdt < 0){
        fprint(STDERR, "mv: can't create %s: %r\n", toname);
        close(fdf);
        return ERROR_NEG1;
    }
    stat = copy1(fdf, fdt, fromname, toname);
    close(fdf);

    if(stat >= 0){
        nulldir(&null);
        null.mtime = dirb->mtime;
        null.mode = dirb->mode;
        dirfwstat(fdt, &null);  /* ignore errors; e.g. user none always fails */
        if(remove(fromname) < 0){
            fprint(STDERR, "mv: can't remove %s: %r\n", fromname);
            stat = ERROR_NEG1;
        }
    }
    close(fdt);
    return stat;
}
@

% could factorize with cp copy1
<<function [[copy1]](mv.c)>>=
errorneg1
copy1(fdt fdf, fdt fdt, char *from, char *to)
{
    char buf[8192];
    long n, n1;

    while ((n = read(fdf, buf, sizeof buf)) > 0) {
        n1 = write(fdt, buf, n);
        if(n1 != n){
            fprint(STDERR, "mv: error writing %s: %r\n", to);
            return ERROR_NEG1;
        }
    }
    if(n < 0){
        fprint(STDERR, "mv: error reading %s: %r\n", from);
        return ERROR_NEG1;
    }
    return OK_0;
}
@

<<function [[split]](mv.c)>>=
void
split(char *name, char **pdir, char **pelem)
{
    char *s;

    s = utfrrune(name, '/');
    if(s){
        *s = '\0';
        *pelem = s+1;
        *pdir = name;
    }else if(strcmp(name, "..") == ORD__EQ){
        *pdir = "..";
        *pelem = ".";
    }else{
        *pdir = ".";
        *pelem = name;
    }
}
@

<<function [[samefile]](mv.c)>>=
bool
samefile(char *a, char *b)
{
    Dir *da, *db;
    bool ret;

    if(strcmp(a, b) == ORD__EQ)
        return true;
    da = dirstat(a);
    db = dirstat(b);
    ret = (da != nil && db != nil &&
        da->qid.type==db->qid.type &&
        da->qid.path==db->qid.path &&
        da->qid.vers==db->qid.vers &&
        da->dev==db->dev &&
        da->type==db->type);
    free(da);
    free(db);
    return ret;
}
@

<<function [[hardremove]](mv.c)>>=
void
hardremove(char *a)
{
    if(remove(a) == ERROR_NEG1){
        fprint(STDERR, "mv: can't remove %s: %r\n", a);
        exits("mv");
    }
    //????
    while(remove(a) != ERROR_NEG1)
        ;
}
@

\section{[[chmod]]}

<<macros chmod.c>>=
#define U(x) (x<<6)
#define G(x) (x<<3)
#define O(x) (x)
#define A(x) (U(x)|G(x)|O(x))

#define DMRWE (DMREAD|DMWRITE|DMEXEC)
@

<<function [[main]](chmod.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    Dir *dir, ndir;
    ulong mode, mask;
    char *p;

    if(argc < 3){
        fprint(STDERR, "usage: chmod 0777 file ... or chmod [who]op[rwxalt] file ...\n");
        exits("usage");
    }
    mode = strtol(argv[1], &p, 8);
    if(*p == '\0')
        mask = A(DMRWE);
    else if(parsemode(argv[1], &mask, &mode) == ERROR_0){
        fprint(STDERR, "chmod: bad mode: %s\n", argv[1]);
        exits("mode");
    }
    nulldir(&ndir);
    for(i=2; i<argc; i++){
        dir = dirstat(argv[i]);
        if(dir == nil){
            fprint(STDERR, "chmod: can't stat %s: %r\n", argv[i]);
            continue;
        }
        ndir.mode = (dir->mode & ~mask) | (mode & mask);
        free(dir);
        if(dirwstat(argv[i], &ndir)==-1){
            fprint(STDERR, "chmod: can't wstat %s: %r\n", argv[i]);
            continue;
        }
    }
    exits(nil);
}
@

<<function [[parsemode]](chmod.c)>>=
error0
parsemode(char *spec, ulong *pmask, ulong *pmode)
{
    ulong mode, mask;
    bool done;
    int op;
    char *s;

    s = spec;
    mask = DMAPPEND | DMEXCL | DMTMP;
    for(done=false; !done; ){
        switch(*s){
        case 'u':
            mask |= U(DMRWE); break;
        case 'g':
            mask |= G(DMRWE); break;
        case 'o':
            mask |= O(DMRWE); break;
        case 'a':
            mask |= A(DMRWE); break;
        case 0:
            return ERROR_0;
        default:
            done = true;
        }
        if(!done)
            s++;
    }
    if(s == spec)
        mask |= A(DMRWE);
    op = *s++;
    if(op != '+' && op != '-' && op != '=')
        return ERROR_0;
    mode = 0;
    for(; *s ; s++){
        switch(*s){
        case 'r':
            mode |= A(DMREAD); break;
        case 'w':
            mode |= A(DMWRITE); break;
        case 'x':
            mode |= A(DMEXEC); break;
        case 'a':
            mode |= DMAPPEND; break;
        case 'l':
            mode |= DMEXCL; break;
        case 't':
            mode |= DMTMP; break;
        default:
            return ERROR_0;
        }
    }
    if(*s != 0)
        return ERROR_0;
    if(op == '+' || op == '-')
        mask &= mode;
    if(op == '-')
        mode = ~mode;
    *pmask = mask;
    *pmode = mode;
    return OK_1;
}
@

\section{[[chgrp]]}

<<global [[uflag]](chgrp.c)>>=
// change uid of file (instead of gid)
bool uflag;
@

<<function [[main]](chgrp.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    Dir dir;
    char *group;
    char *errs = nil;

    ARGBEGIN {
    default:
    usage:
        fprint(STDERR, "usage: chgrp [ -uo ] group file ....\n");
        exits("usage");
        return;
    case 'u':
    case 'o':
        uflag = true;
        break;
    } ARGEND
    if(argc < 1)
        goto usage;

    group = argv[0];
    for(i=1; i<argc; i++){
        nulldir(&dir);
        if(uflag)
            dir.uid = group;
        else
            dir.gid = group;
        if(dirwstat(argv[i], &dir) == ERROR_NEG1) {
            fprint(STDERR, "chgrp: can't wstat %s: %r\n", argv[i]);
            errs = "can't wstat";
            continue;
        }
    }
    exits(errs);
}
@

\section{[[pwd]]}
% in shell book actually
%TODO: not synced actually and not in Utilities_extra.nw

<<function [[main]](pwd.c)>>=
void
main(int argc, char *argv[])
{
    char pathname[512];

    USED(argc, argv);
    if(getwd(pathname, sizeof(pathname)) == ERROR_0) {
        fprint(STDERR, "pwd: %r\n");
        exits("getwd");
    }
    print("%s\n", pathname);
    exits(nil);
}
@

\section{[[mtime]]}
% print the mtime of a file or set of files
% seems useless given ls -l give the same info.
% in fact Linux does not have an mtime command

<<function [[usage]](mtime.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: mtime file...\n");
    exits("usage");
}
@

<<function [[main]](mtime.c)>>=
void
main(int argc, char **argv)
{
    bool errors = false;
    int i;
    Dir *d;

    ARGBEGIN{
    default:
        usage();
    }ARGEND

    for(i=0; i<argc; i++){
        if((d = dirstat(argv[i])) == nil){
            fprint(STDERR, "stat %s: %r\n", argv[i]);
            errors = true;
        }else{
            print("%11lud %s\n", d->mtime, argv[i]);
            free(d);
        }
    }
    exits(errors ? "errors" : nil);
}
@

%******************************************************************************
%\chapter{Statistics}
%******************************************************************************
%alt: merged with previous chapter as wc/du are kind of stats for files/dirs

\section{[[wc]]}

% default to 0 or false thx to plan9 memset(0) of data section
% but unix does the same?
<<globals wc.c>>=
/* flags, per-file counts, and total counts */
static bool pline, pword, prune, pbadr, pchar;
static uvlong nline, nword, nrune, nbadr, nchar;
static uvlong tnline, tnword, tnrune, tnbadr, tnchar;
@

<<function [[main]](wc.c)>>=
void
main(int argc, char *argv[])
{
    char *sts = nil;
    Biobuf sin, *bin;
    int i;

    ARGBEGIN {
    case 'l': pline = true; break;
    case 'w': pword = true; break;
    case 'c': pchar = true; break;
    // plan9 new: -r for runes
    case 'r': prune = true; break;
    // ??
    case 'b': pbadr = true; break;
    default:
        fprint(STDERR, "Usage: %s [-lwrbc] [file ...]\n", argv0);
        exits("usage");
    } ARGEND
    if(!pline && !pword && !prune && !pbadr && !pchar){
        // defaults
        pline = true;
        pword = true;
        pchar = true;
    }
    if(argc == 0){
        Binit(&sin, STDIN, OREAD);
        wc(&sin);
        report(nline, nword, nrune, nbadr, nchar, nil);
        Bterm(&sin);
    }else{
        for(i = 0; i < argc; i++){
            bin = Bopen(argv[i], OREAD);
            if(bin == nil){
                perror(argv[i]);
                sts = "can't open";
                continue;
            }
            wc(bin);
            report(nline, nword, nrune, nbadr, nchar, argv[i]);
            Bterm(bin);
        }
        if(argc>1)
            report(tnline, tnword, tnrune, tnbadr, tnchar, "total");
    }
    exits(sts);
}
@

<<enum wc.c>>=
enum{Space, Word};
@

<<function [[wc]]>>=
static void
wc(Biobuf *bin)
{
    int where;
    long r;

    nline = 0;
    nword = 0;
    nrune = 0;
    nbadr = 0;
    where = Space;
    while ((long)(r = Bgetrune(bin)) >= 0) {
        nrune++;
        if(r == Runeerror) {
            nbadr++;
            continue;
        }
        if(r == '\n')
            nline++;
        if(where == Word){
            if(isspacerune(r))
                where = Space;
        }else
            if(isspacerune(r) == 0){
                where = Word;
                nword++;
            }
    }
    nchar = Boffset(bin);
    tnline += nline;
    tnword += nword;
    tnrune += nrune;
    tnbadr += nbadr;
    tnchar += nchar;
}
@

<<function [[report]](wc.c)>>=
static void
report(uvlong nline, uvlong nword, uvlong nrune, uvlong nbadr, uvlong nchar, char *fname)
{
    char line[1024], *s, *e;

    s = line;
    e = line + sizeof line;
    line[0] = '\0';
    if(pline)
        s = seprint(s, e, " %7llud", nline);
    if(pword)
        s = seprint(s, e, " %7llud", nword);
    if(prune)
        s = seprint(s, e, " %7llud", nrune);
    if(pbadr)
        s = seprint(s, e, " %7llud", nbadr);
    if(pchar)
        s = seprint(s, e, " %7llud", nchar);
    if(fname != nil)
        seprint(s, e, " %s",   fname);
    print("%s\n", line+1);
}
@

\section{[[du]]}

%******************************************************************************
%\chapter{String Processing}
%******************************************************************************
% head tail?

%******************************************************************************
\chapter{[[ed]]}
%******************************************************************************

\section{Introduction}

% ed for editor.
% originally written by Ken Thompson in the 1970's

% see appendix 1 of "Unix programming environment"
% for tutorial and motivations for the study of ed!
% screen editors nowaday, but still useful to know ed! especially good
% for scripting (in fact see mkenam in plan9 code)
% also if need quick and dirty write a file with a few lines => ed!

% Can already create file content with echo and shell redirection
% (>, >> for append); can do a lot, but still not as power as ed.

% s/re/g
% g/re/p comes from ed!

% See also \book{Editor}

% ex of powerful ed command used in goken mkenam:
\begin{verbatim}
ed - ../5l/5.out.h <<'!'
v/^	A/d
,s/^	A/	"/
g/ .*$/s///
,s/,*$/",/
1i
char*	anames[] =
{
.
$a
};
.
w enam.c
Q
!
\end{verbatim}

% by end of chapter you will understand this script :)

% Note that unicode-ready editor!

\section{Data structures}

<<globals ed.c>>=
ulong   nlall = 128;
int*    zero; // size: (nlall+5)*sizeof(int*)
char*   tfname; // temporary filename (/tmp/eXXXX)
@

<<globals ed.c>>=
int*    dot;
int*    dol;
@
% dot = current line
% dol = ?

<<globals ed.c>>=
char    line[70];
char*   linp    = line;
int col;
@

%TODO: Figure?

\section{[[main()]]}
% main, init, quit

<<globals ed.c>>=
// ??
bool vflag   = true;
// ??
bool oflag;
@

<<globals ed.c>>=
// console buffered input
Biobuf  bcons;
@

<<constants ed.c>>=
FNSIZE  = 128,      /* file name */
@
<<globals ed.c>>=
// for w, r, f
char    savedfile[FNSIZE];
@



<<function [[main]](ed.c)>>=
void
main(int argc, char *argv[])
{
    char *p1, *p2;

    Binit(&bcons, STDIN, OREAD);
    notify(notifyf);

    ARGBEGIN {
    case 'o':
        oflag = true;
        vflag = false;
        break;
    } ARGEND

    USED(argc);
    if(*argv && (strcmp(*argv, "-") == ORD__EQ)) {
        argv++;
        vflag = false;
    }
    if(oflag) {
        p1 = "/fd/1";
        p2 = savedfile;
        while(*p2++ = *p1++)
            ;
        globp = L"a";
    } else
    if(*argv) {
        p1 = *argv;
        p2 = savedfile;
        while(*p2++ = *p1++)
            if(p2 >= &savedfile[sizeof(savedfile)])
                p2--;
        globp = L"r";
    }
    zero = malloc((nlall+5)*sizeof(int*));
    tfname = mktemp(template);

    init();
    setjmp(savej);
    commands();
    quit();
}
@


%ex: mktemp("/tmp/eXXXXX") -> ??
<<function [[mktemp]](ed.c)>>=
char*
mktemp(char *as)
{
    char *s;
    unsigned pid;
    int i;

    pid = getpid();
    s = as;
    while(*s++)
        ;
    s--;
    while(*--s == 'X') {
        *s = pid % 10 + '0';
        pid /= 10;
    }
    s++;
    i = 'a';
    while(access(as, 0) != -1) {
        if(i == 'z')
            return "/";
        *s = i++;
    }
    return as;
}
@

<<globals ed.c>>=
fdt tfile   = -1;
int tline;
int names[26];
int subnewa;
int anymarks;
int iblock;
int oblock;
int ichanged;
@


<<function [[init]](ed.c)>>=
void
init(void)
{
    int *markp;

    close(tfile);
    tline = 2;
    for(markp = names; markp < &names[26]; )
        *markp++ = 0;
    subnewa = 0;
    anymarks = 0;
    iblock = -1;
    oblock = -1;
    ichanged = 0;
    if((tfile = create(tfname, ORDWR, 0600)) < 0){
        error_1(T);
        exits(nil);
    }
    dot = dol = zero;
}
@

<<globals ed.c>>=
bool fchange;
@
<<globals ed.c>>=
char    Q[] = "";
@

<<function [[quit]](ed.c)>>=
void
quit(void)
{
    if(vflag && fchange && dol!=zero) {
        fchange = false;
        error(Q);
    }
    remove(tfname);
    exits(nil);
}
@

% ?? seems dead, called by? like regerror weird
<<function [[onquit]](ed.c)>>=
void
onquit(int sig)
{
    USED(sig);
    quit();
}
@

\section{Error management}

<<globals ed.c>>=
jmp_buf savej;
@


<<function [[error]](ed.c)>>=
void
error(char *s)
{
    error_1(s);
    longjmp(savej, 1);
}
@
% longtmp =~ exn to jump just after commands() to reread commands!


<<globals ed.c>>=
int listn;
bool pflag;
@

<<constants ed.c>>=
EOF = -1,
@

<<function [[error_1]](ed.c)>>=
void
error_1(char *s)
{
    int c;

    wrapp = false;
    listf = 0;
    listn = 0;
    count = 0;

    seek(STDIN, 0, SEEK__END);
    pflag = false;

    if(globp)
        lastc = '\n';
    globp = nil;

    peekc = lastc;
    if(lastc)
        for(;;) {
            c = getchr();
            if(c == '\n' || c == EOF)
                break;
        }

    if(io > 0) {
        close(io);
        io = -1;
    }

    putchr(L'?');
    putst(s);
}
@
% show '?' to display problem and then possible error message

<<globals ed.c>>=
bool rescuing;
bool waiting;
@

<<function [[notifyf]](ed.c)>>=
void
notifyf(void *a, char *s)
{
    if(strcmp(s, "interrupt") == ORD__EQ){
        if(rescuing || waiting)
            noted(NCONT);
        putchr(L'\n');
        lastc = '\n';
        error_1(Q);
        notejmp(a, savej, 0);
    }
    if(strcmp(s, "hangup") == ORD__EQ){
        if(rescuing)
            noted(NDFLT);
        rescue();
    }
    fprint(STDERR, "ed: note: %s\n", s);
    abort();
}
@
% notejmp??

<<function [[rescue]](ed.c)>>=
void
rescue(void)
{
    rescuing = true;
    if(dol > zero) {
        addr1 = zero+1;
        addr2 = dol;
        io = create("ed.hup", OWRITE, 0666);
        if(io > 0){
            Binit(&iobuf, io, OWRITE);
            putfile();
        }
    }
    fchange = false;
    quit();
}
@

% ??? seems unused. Callback when libregexp fails?
<<function [[regerror]](ed.c)>>=
void
regerror(char *s)
{
    USED(s);
    error(Q);
}
@

\section{Displaying text}

<<globals ed.c>>=
// ??
int listf;
@

% error | ... -> <>
<<function [[putchr]](ed.c)>>=
void
putchr(int ac)
{
    char *lp;
    int c;
    Rune rune;

    lp = linp;
    c = ac;
    if(listf) {
        if(c == '\n') {
            if(linp != line && linp[-1] == ' ') {
                *lp++ = '\\';
                *lp++ = 'n';
            }
        } else {
            if(col > (72-6-2)) {
                col = 8;
                *lp++ = '\\';
                *lp++ = '\n';
                *lp++ = '\t';
            }
            col++;
            if(c=='\b' || c=='\t' || c=='\\') {
                *lp++ = '\\';
                if(c == '\b')
                    c = 'b';
                else
                if(c == '\t')
                    c = 't';
                col++;
            } else
            if(c<' ' || c>='\177') {
                *lp++ = '\\';
                *lp++ = 'x';
                *lp++ =  hex[c>>12];
                *lp++ =  hex[c>>8&0xF];
                *lp++ =  hex[c>>4&0xF];
                c     =  hex[c&0xF];
                col += 5;
            }
        }
    }

    rune = c;
    lp += runetochar(lp, &rune);

    if(c == '\n' || lp >= &line[sizeof(line)-5]) {
        linp = line;
        write(oflag? STDERR: STDOUT, line, lp-line);
        return;
    }
    linp = lp;
}
@

<<function [[putstr]](ed.c)>>=
void
putst(char *sp)
{
    Rune r;

    col = 0;
    for(;;) {
        sp += chartorune(&r, sp);
        if(r == 0)
            break;
        putchr(r);
    }
    putchr(L'\n');
}
@

\section{Reading characters}

<<globals ed.c>>=
int lastc;
int peekc;
// ??
Rune*   globp;
@

<<function [[getchr]](ed.c)>>=
int
getchr(void)
{
    if(lastc = peekc) {
        peekc = 0;
        return lastc;
    }
    if(globp) {
        if((lastc=*globp++) != 0)
            return lastc;
        globp = nil;
        return EOF;
    }
    lastc = Bgetrune(&bcons);
    return lastc;
}
@

<<constants ed.c>>=
LBSIZE  = 4096,     /* max line size */
@

<<globals ed.c>>=
Rune    linebuf[LBSIZE];
@

<<function [[gety]](ed.c)>>=
int
gety(void)
{
    int c;
    Rune *gf, *p;

    p = linebuf;
    gf = globp;
    for(;;) {
        c = getchr();
        if(c == '\n') {
            *p = 0;
            return 0;
        }
        if(c == EOF) {
            if(gf)
                peekc = c;
            return c;
        }
        if(c == 0)
            continue;
        *p++ = c;
        if(p >= &linebuf[LBSIZE-sizeof(Rune)])
            error(Q);
    }
}
@

<<function [[gettty]](ed.c)>>=
int
gettty(void)
{
    int rc;

    rc = gety();
    if(rc)
        return rc;
    if(linebuf[0] == '.' && linebuf[1] == 0)
        return EOF;
    return 0;
}
@

\section{[[commands()]]}

<<globals ed.c>>=
int*    addr1;
int*    addr2;
@

<<globals ed.c>>=
bool given;
@

<<function [[commands]](ed.c)>>=
void
commands(void)
{
    int *a1, c;
    int temp;
    char lastsep;
    Dir *d;

    for(;;) {
        if(pflag) {
            pflag = false;
            addr1 = addr2 = dot;
            printcom();
        }
        c = '\n';
        for(addr1 = nil;;) {
            lastsep = c;
            a1 = address();
            c = getchr();
            if(c != ',' && c != ';')
                break;

            if(lastsep == ',')
                error(Q);
            if(a1 == nil) {
                a1 = zero+1;
                if(a1 > dol)
                    a1--;
            }
            addr1 = a1;
            if(c == ';')
                dot = a1;
        }
        if(lastsep != '\n' && a1 == nil)
            a1 = dol;
        if((addr2=a1) == nil) {
            given = false;
            addr2 = dot;    
        } else
            given = true;
        if(addr1 == nil)
            addr1 = addr2;

        switch(c) {
        <<[[commands()]] switch [[c]] cases (ed.c)>>
        }
        error(Q);
    }
}
@
% error(Q) ? so just jump to before commands() ?


% "each command can be preceded by one or two line numbers ..."
<<function [[address]](ed.c)>>=
int*
address(void)
{
    int sign, *a, opcnt, nextopand, *b, c;

    nextopand = -1;
    sign = 1;
    opcnt = 0;
    a = dot;
    do {
        do {
            c = getchr();
        } while(c == ' ' || c == '\t');
        if(c >= '0' && c <= '9') {
            peekc = c;
            if(!opcnt)
                a = zero;
            a += sign*getnum();
        } else
        switch(c) {
        case '$':
            a = dol;
        case '.':
            if(opcnt)
                error(Q);
            break;
        case '\'':
            c = getchr();
            if(opcnt || c < 'a' || c > 'z')
                error(Q);
            a = zero;
            do {
                a++;
            } while(a <= dol && names[c-'a'] != (*a & ~01));
            break;
        case '?':
            sign = -sign;
        case '/':
            compile(c);
            b = a;
            for(;;) {
                a += sign;
                if(a <= zero)
                    a = dol;
                if(a > dol)
                    a = zero;
                if(match(a))
                    break;
                if(a == b)
                    error(Q);
            }
            break;
        default:
            if(nextopand == opcnt) {
                a += sign;
                if(a < zero || dol < a)
                    continue;       /* error(Q); */
            }
            if(c != '+' && c != '-' && c != '^') {
                peekc = c;
                if(opcnt == 0)
                    a = 0;
                return a;
            }
            sign = 1;
            if(c != '+')
                sign = -sign;
            nextopand = ++opcnt;
            continue;
        }
        sign = 1;
        opcnt++;
    } while(zero <= a && a <= dol);
    error(Q);
    return 0;
}
@


<<function [[getnum]](ed.c)>>=
int
getnum(void)
{
    int r, c;

    r = 0;
    for(;;) {
        c = getchr();
        if(c < '0' || c > '9')
            break;
        r = r*10 + (c-'0');
    }
    peekc = c;
    return r;
}
@

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case EOF:
    return;
@

\section{Main commands}

%toc:
% classic tutorial on 'ed' is to use commands 'a', 'w', and 'q'
% so we will do that

\subsection{[[a]]ppend and [[i]]nsert: [[a]], [[i]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'a':
    add(0);
    continue;
@

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'i':
    add(-1);
    continue;
@


<<function [[add]](ed.c)>>=
void
add(int i)
{
    if(i && (given || dol > zero)) {
        addr1--;
        addr2--;
    }
    squeeze(0);
    newline();
    append(gettty, addr2);
}
@

<<function [[squeeze]](ed.c)>>=
void
squeeze(int i)
{
    if(addr1 < zero+i || addr2 > dol || addr1 > addr2)
        error(Q);
}
@

<<function [[newline]](ed.c)>>=
void
newline(void)
{
    int c;

    c = getchr();
    if(c == '\n' || c == EOF)
        return;
    if(c == 'p' || c == 'l' || c == 'n') {
        pflag++;
        if(c == 'l')
            listf++;
        else
        if(c == 'n')
            listn++;
        c = getchr();
        if(c == '\n')
            return;
    }
    error(Q);
}
@

<<function [[append]](ed.c)>>=
int
append(int (*f)(void), int *a)
{
    int *a1, *a2, *rdot, nline, tl;

    nline = 0;
    dot = a;
    while((*f)() == 0) {
        if((dol-zero) >= nlall) {

            nlall += 512;
            a1 = realloc(zero, (nlall+5)*sizeof(int*));
            if(a1 == nil) {
                error("MEM?");
                rescue();
            }
            tl = a1 - zero; /* relocate pointers */
            zero += tl;
            addr1 += tl;
            addr2 += tl;
            dol += tl;
            dot += tl;
        }
        tl = putline();
        nline++;
        a1 = ++dol;
        a2 = a1+1;
        rdot = ++dot;
        while(a1 > rdot)
            *--a2 = *--a1;
        *rdot = tl;
    }
    return nline;
}
@

% move in separate section with getline?
<<function [[putline]](ed.c)>>=
int
putline(void)
{
    Rune *lp, *bp;
    int nl, tl;

    fchange = true;
    lp = linebuf;
    tl = tline;
    bp = getblock(tl, OWRITE);
    nl = nleft;
    tl &= ~((BLKSIZE/sizeof(Rune))-1);
    while(*bp = *lp++) {
        if(*bp++ == '\n') {
            bp[-1] = 0;
            linebp = lp;
            break;
        }
        nl -= sizeof(Rune);
        if(nl == 0) {
            tl += BLKSIZE/sizeof(Rune);
            bp = getblock(tl, OWRITE);
            nl = nleft;
        }
    }
    nl = tline;
    tline += ((lp-linebuf) + 03) & 077776;
    return nl;
}
@

<<function [[getblock]](ed.c)>>=
Rune*
getblock(int atl, int iof)
{
    int bno, off;
    
    static uchar ibuff[BLKSIZE];
    static uchar obuff[BLKSIZE];

    bno = atl / (BLKSIZE/sizeof(Rune));
    /* &~3 so the ptr is aligned to 4 (?) */
    off = (atl*sizeof(Rune)) & (BLKSIZE-1) & ~3;
    if(bno >= NBLK) {
        lastc = '\n';
        error(T);
    }
    nleft = BLKSIZE - off;
    if(bno == iblock) {
        ichanged |= iof;
        return (Rune*)(ibuff+off);
    }
    if(bno == oblock)
        return (Rune*)(obuff+off);
    if(iof == OREAD) {
        if(ichanged)
            blkio(iblock, ibuff, write);
        ichanged = 0;
        iblock = bno;
        blkio(bno, ibuff, read);
        return (Rune*)(ibuff+off);
    }
    if(oblock >= 0)
        blkio(oblock, obuff, write);
    oblock = bno;
    return (Rune*)(obuff+off);
}
@

<<function [[blkio]](ed.c)>>=
void
blkio(int b, uchar *buf, long (*iofcn)(int, void *, long))
{
    seek(tfile, b*BLKSIZE, SEEK__START);
    if((*iofcn)(tfile, buf, BLKSIZE) != BLKSIZE) {
        error(T);
    }
}
@

\subsection{[[w]]riting to a file: [[w]]}

<<globals ed.c>>=
char    file[FNSIZE];
fdt io;
Biobuf  iobuf;
@

<<globals ed.c>>=
// write append
bool wrapp;
@

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'W':
    wrapp = true;
case 'w':
    setwide();
    squeeze(dol>zero);

    temp = getchr();
    if(temp != 'q' && temp != 'Q') {
        peekc = temp;
        temp = 0;
    }
    filename(c);

    if(!wrapp ||
      ((io = open(file, OWRITE)) == -1) ||
      ((seek(io, 0L, 2)) == -1))
        if((io = create(file, OWRITE, 0666)) < 0)
            error(file);

    Binit(&iobuf, io, OWRITE);
    wrapp = false;
    if(dol > zero)
        putfile();

    exfile(OWRITE);

    if(addr1<=zero+1 && addr2==dol)
        fchange = false;
    if(temp == 'Q')
        fchange = false;
    if(temp)
        quit();
    continue;
@

<<globals ed.c>>=
long count;
@

<<function [[putfile]](ex.c)>>=
void
putfile(void)
{
    int *a1;
    Rune *lp;
    long c;

    a1 = addr1;
    do {
        lp = getline(*a1++);
        for(;;) {
            count++;
            c = *lp++;
            if(c == 0) {
                if(Bputrune(&iobuf, '\n') < 0)
                    error(Q);
                break;
            }
            if(Bputrune(&iobuf, c) < 0)
                error(Q);
        }
    } while(a1 <= addr2);
    if(Bflush(&iobuf) < 0)
        error(Q);
}
@

<<function [[getline]](ed.c)>>=
Rune*
getline(int tl)
{
    Rune *lp, *bp;
    int nl;

    lp = linebuf;
    bp = getblock(tl, OREAD);
    nl = nleft;
    tl &= ~((BLKSIZE/sizeof(Rune)) - 1);
    while(*lp++ = *bp++) {
        nl -= sizeof(Rune);
        if(nl == 0) {
            tl += BLKSIZE/sizeof(Rune);
            bp = getblock(tl, OREAD);
            nl = nleft;
        }
    }
    return linebuf;
}
@

<<function [[exfile]](ed.c)>>=
void
exfile(int om)
{

    if(om == OWRITE)
        if(Bflush(&iobuf) < 0)
            error(Q);
    close(io);
    io = -1;
    if(vflag) {
        putd();
        putchr(L'\n');
    }
}
@

<<function [[putd]](ex.c)>>=
void
putd(void)
{
    int r;

    r = count%10;
    count /= 10;
    if(count)
        putd();
    putchr(r + L'0');
}
@

<<function [[setwide]](ed.c)>>=
void
setwide(void)
{
    if(!given) {
        addr1 = zero + (dol>zero);
        addr2 = dol;
    }
}
@

<<function [[filename]](ed.c)>>=
void
filename(int comm)
{
    char *p1, *p2;
    Rune rune;
    int c;

    count = 0;
    c = getchr();
    if(c == '\n' || c == EOF) {
        p1 = savedfile;
        if(*p1 == 0 && comm != 'f')
            error(Q);
        p2 = file;
        while(*p2++ = *p1++)
            ;
        return;
    }
    if(c != ' ')
        error(Q);
    while((c=getchr()) == ' ')
        ;
    if(c == '\n')
        error(Q);
    p1 = file;
    do {
        if(p1 >= &file[sizeof(file)-6] || c == ' ' || c == EOF)
            error(Q);
        rune = c;
        p1 += runetochar(p1, &rune);
    } while((c=getchr()) != '\n');
    *p1 = 0;
    if(savedfile[0] == 0 || comm == 'e' || comm == 'f') {
        p1 = savedfile;
        p2 = file;
        while(*p1++ = *p2++)
            ;
    }
}
@

\subsection{[[q]]uitting: [[q]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'Q':
    fchange = false;
case 'q':
    setnoaddr();
    newline();
    quit();
@

<<function [[setnoaddr]](ed.c)>>=
void
setnoaddr(void)
{
    if(given)
        error(Q);
}
@

\subsection{running a shell command: [[!]]}
% still M-! on Emacs? 

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case '!':
    callunix();
    continue;
@

<<function [[callunix]](ed.c)>>=
void
callunix(void)
{
    int c, pid;
    Rune rune;
    char buf[512];
    char *p;

    setnoaddr();

    p = buf;
    while((c=getchr()) != EOF && c != '\n')
        if(p < &buf[sizeof(buf) - 6]) {
            rune = c;
            p += runetochar(p, &rune);
        }
    *p = 0;

    pid = fork();
    if(pid == 0) {
        execl("/bin/rc", "rc", "-c", buf, nil);
        // should not be reached
        exits("execl failed");
    }
    waiting = true;
    while(waitpid() != pid)
        ;
    waiting = false;
    if(vflag)
        putst("!");
}
@

\subsection{[[p]]rinting lines: [[p]]}
% printing 3p   1,$p
% maybe can show address() powerful args for [[p]]

% see also g/re/p later

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'l':
    listf++;
case 'p':
case 'P':
    newline();
    printcom();
    continue;
@

<<function [[printcom]](ed.c)>>=
void
printcom(void)
{
    int *a1;

    nonzero();
    a1 = addr1;
    do {
        if(listn) {
            count = a1-zero;
            putd();
            putchr(L'\t');
        }
        putshst(getline(*a1++));
    } while(a1 <= addr2);
    dot = addr2;
    listf = 0;
    listn = 0;
    pflag = false;
}
@

% put sh st ??
<<function [[putshst]](ed.c)>>=
void
putshst(Rune *sp)
{
    col = 0;
    while(*sp)
        putchr(*sp++);
    putchr(L'\n');
}
@

<<function [[nonzero]](ed.c)>>=
void
nonzero(void)
{
    squeeze(1);
}
@

% print also when no command specified? like 1\n ? default to print?
<<[[commands()]] switch [[c]] cases (ed.c)>>=
case '\n':
    if(a1==0) {
        a1 = dot+1;
        addr2 = a1;
        addr1 = a1;
    }
    if(lastsep==';')
        addr1 = a1;
    printcom();
    continue;
@

\subsection{printing line number: [[=]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case '=':
    setwide();
    squeeze(0);
    newline();
    count = addr2 - zero;
    putd();
    putchr(L'\n');
    continue;
@


\subsection{[[d]]eleting lines: [[d]]}
% delete

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'd':
    nonzero();
    newline();
    rdelete(addr1, addr2);
    continue;
@

% r ? vs gdelete? global delete, right delete?
<<function [[rdelete]](ed.c)>>=
void
rdelete(int *ad1, int *ad2)
{
    int *a1, *a2, *a3;

    a1 = ad1;
    a2 = ad2+1;
    a3 = dol;
    dol -= a2 - a1;
    do {
        *a1++ = *a2++;
    } while(a2 <= a3);
    a1 = ad1;
    if(a1 > dol)
        a1 = dol;
    dot = a1;
    fchange = true;
}
@

\subsection{[[c]]hanging lines: [[c]]}
% change

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'c':
    nonzero();
    newline();
    rdelete(addr1, addr2);
    append(gettty, addr1-1);
    continue;
@

\subsection{[[m]]oving and copying lines: [[m]] and [[t]]}
% 't' because 'c' was already used for change

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'm':
    move(0);
    continue;
@

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 't':
    move(1);
    continue;
@

<<function [[move]](ed.c)>>=
void
move(int cflag)
{
    int *adt, *ad1, *ad2;

    nonzero();
    if((adt = address())==0)    /* address() guarantees addr is in range */
        error(Q);
    newline();
    if(cflag) {
        int *ozero, delta;
        ad1 = dol;
        ozero = zero;
        append(getcopy, ad1++);
        ad2 = dol;
        delta = zero - ozero;
        ad1 += delta;
        adt += delta;
    } else {
        ad2 = addr2;
        for(ad1 = addr1; ad1 <= ad2;)
            *ad1++ &= ~01;
        ad1 = addr1;
    }
    ad2++;
    if(adt<ad1) {
        dot = adt + (ad2-ad1);
        if((++adt)==ad1)
            return;
        reverse(adt, ad1);
        reverse(ad1, ad2);
        reverse(adt, ad2);
    } else
    if(adt >= ad2) {
        dot = adt++;
        reverse(ad1, ad2);
        reverse(ad2, adt);
        reverse(ad1, adt);
    } else
        error(Q);
    fchange = true;
}
@

<<function [[getcopy]](ed.c)>>=
int
getcopy(void)
{
    if(addr1 > addr2)
        return EOF;
    getline(*addr1++);
    return 0;
}
@

<<function [[reverse]](ed.c)>>=
void
reverse(int *a1, int *a2)
{
    int t;

    for(;;) {
        t = *--a2;
        if(a2 <= a1)
            return;
        *a2 = *a1;
        *a1++ = t;
    }
}
@

\section{Search and replace}
% regexp, regular expressions

\subsection{[[g]]lobal commands: [[g/re/cmd]] and [[v/re/cmd]]}

%g/re/cmd
% => g/re/p => grep :)


<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'g':
    global(1);
    continue;
@

% negative of pattern
<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'v':
    global(0);
    continue;
@

<<constants ed.c>>=
GBSIZE  = 256,      /* max size of global command */
@

<<function [[global]](ed.c)>>=
void
global(int k)
{
    Rune *gp, globuf[GBSIZE];
    int c, *a1;

    if(globp)
        error(Q);

    setwide();
    squeeze(dol > zero);

    c = getchr();
    if(c == '\n')
        error(Q);

    compile(c);

    gp = globuf;
    while((c=getchr()) != '\n') {
        if(c == EOF)
            error(Q);
        if(c == '\\') {
            c = getchr();
            if(c != '\n')
                *gp++ = '\\';
        }
        *gp++ = c;
        if(gp >= &globuf[GBSIZE-2])
            error(Q);
    }
    if(gp == globuf)
        *gp++ = 'p';
    *gp++ = '\n';
    *gp = 0;
    for(a1=zero; a1<=dol; a1++) {
        *a1 &= ~01;
        if(a1 >= addr1 && a1 <= addr2 && match(a1) == k)
            *a1 |= 01;
    }

    /*
     * Special case: g/.../d (avoid n^2 algorithm)
     */
    if(globuf[0] == 'd' && globuf[1] == '\n' && globuf[2] == 0) {
        gdelete();
        return;
    }
    for(a1=zero; a1<=dol; a1++) {
        if(*a1 & 01) {
            *a1 &= ~01;
            dot = a1;
            globp = globuf;
            commands();
            a1 = zero;
        }
    }
}
@

<<function [[gdelete]](ed.c)>>=
void
gdelete(void)
{
    int *a1, *a2, *a3;

    a3 = dol;
    for(a1=zero; (*a1&01)==0; a1++)
        if(a1>=a3)
            return;
    for(a2=a1+1; a2<=a3;) {
        if(*a2 & 01) {
            a2++;
            dot = a1;
        } else
            *a1++ = *a2++;
    }
    dol = a1-1;
    if(dot > dol)
        dot = dol;
    fchange = true;
}
@

<<constants ed.c>>=
ESIZE   = 256,      /* max size of reg exp */
@

<<globals ed.c>>=
Reprog  *pattern;
@

<<function [[compile]](ed.c)>>=
void
compile(int eof)
{
    Rune c;
    char *ep;
    char expbuf[ESIZE];

    if((c = getchr()) == '\n') {
        peekc = c;
        c = eof;
    }
    if(c == eof) {
        if(!pattern)
            error(Q);
        return;
    }
    if(pattern) {
        free(pattern);
        pattern = nil;
    }
    ep = expbuf;
    do {
        if(c == '\\') {
            if(ep >= expbuf+sizeof(expbuf)) {
                error(Q);
                return;
            }
            ep += runetochar(ep, &c);
            if((c = getchr()) == '\n') {
                error(Q);
                return;
            }
        }
        if(ep >= expbuf+sizeof(expbuf)) {
            error(Q);
            return;
        }
        ep += runetochar(ep, &c);
    } while((c = getchr()) != eof && c != '\n');
    if(c == '\n')
        peekc = c;
    *ep = 0;
    pattern = regcomp(expbuf);
}
@
% see libregexp book

\subsection{[[s]]ubstitute: [[s]]}
% s//g like sed!

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 's':
    nonzero();
    substitute(globp != 0);
    continue;
@

<<function [[substitute]](ed.c)>>=
void
substitute(int inglob)
{
    int *mp, *a1, nl, gsubf, n;

    n = getnum();   /* OK even if n==0 */
    gsubf = compsub();
    for(a1 = addr1; a1 <= addr2; a1++) {
        if(match(a1)){
            int *ozero;
            int m = n;

            do {
                int span = loc2-loc1;

                if(--m <= 0) {
                    dosub();
                    if(!gsubf)
                        break;
                    if(span == 0) { /* null RE match */
                        if(*loc2 == 0)
                            break;
                        loc2++;
                    }
                }
            } while(match(0));
            if(m <= 0) {
                inglob |= 01;
                subnewa = putline();
                *a1 &= ~01;
                if(anymarks) {
                    for(mp=names; mp<&names[26]; mp++)
                        if(*mp == *a1)
                            *mp = subnewa;
                }
                subolda = *a1;
                *a1 = subnewa;
                ozero = zero;
                nl = append(getsub, a1);
                addr2 += nl;
                nl += zero-ozero;
                a1 += nl;
            }
        }
    }
    if(inglob == 0)
        error(Q);
}
@


<<function [[dosub]](ed.c)>>=
void
dosub(void)
{
    Rune *lp, *sp, *rp;
    int c, n;

    lp = linebuf;
    sp = genbuf;
    rp = rhsbuf;
    while(lp < loc1)
        *sp++ = *lp++;
    while(c = *rp++) {
        if(c == '&'){
            sp = place(sp, loc1, loc2);
            continue;
        }
        if(c == ESCFLG && (c = *rp++) >= '1' && c < MAXSUB+'0') {
            n = c-'0';
            if(subexp[n].s.rsp && subexp[n].e.rep) {
                sp = place(sp, subexp[n].s.rsp, subexp[n].e.rep);
                continue;
            }
            error(Q);
        }
        *sp++ = c;
        if(sp >= &genbuf[LBSIZE])
            error(Q);
    }
    lp = loc2;
    loc2 = sp - genbuf + linebuf;
    while(*sp++ = *lp++)
        if(sp >= &genbuf[LBSIZE])
            error(Q);
    lp = linebuf;
    sp = genbuf;
    while(*lp++ = *sp++)
        ;
}
@

<<function [[place]](ed.c)>>=
Rune*
place(Rune *sp, Rune *l1, Rune *l2)
{

    while(l1 < l2) {
        *sp++ = *l1++;
        if(sp >= &genbuf[LBSIZE])
            error(Q);
    }
    return sp;
}
@

<<function [[getsub]](ed.c)>>=
int
getsub(void)
{
    Rune *p1, *p2;

    p1 = linebuf;
    if((p2 = linebp) == 0)
        return EOF;
    while(*p1++ = *p2++)
        ;
    linebp = 0;
    return 0;
}
@

<<function [[match]](ed.c)>>=
int
match(int *addr)
{
    if(!pattern)
        return 0;
    if(addr){
        if(addr == zero)
            return 0;
        subexp[0].s.rsp = getline(*addr);
    } else
        subexp[0].s.rsp = loc2;
    subexp[0].e.rep = 0;
    if(rregexec(pattern, linebuf, subexp, MAXSUB)) {
        loc1 = subexp[0].s.rsp;
        loc2 = subexp[0].e.rep;
        return 1;
    }
    loc1 = loc2 = 0;
    return 0;
    
}
@

<<function [[compsub]](ed.c)>>=
int
compsub(void)
{
    int seof, c;
    Rune *p;

    seof = getchr();
    if(seof == '\n' || seof == ' ')
        error(Q);
    compile(seof);
    p = rhsbuf;
    for(;;) {
        c = getchr();
        if(c == '\\') {
            c = getchr();
            *p++ = ESCFLG;
            if(p >= &rhsbuf[LBSIZE/sizeof(Rune)])
                error(Q);
        } else
        if(c == '\n' && (!globp || !globp[0])) {
            peekc = c;
            pflag++;
            break;
        } else
        if(c == seof)
            break;
        *p++ = c;
        if(p >= &rhsbuf[LBSIZE/sizeof(Rune)])
            error(Q);
    }
    *p = 0;
    peekc = getchr();
    if(peekc == 'g') {
        peekc = 0;
        newline();
        return 1;
    }
    newline();
    return 0;
}
@

\subsection{[[u]]ndo substitution: [[u]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'u':
    nonzero();
    newline();
    if((*addr2&~01) != subnewa)
        error(Q);
    *addr2 = subolda;
    dot = addr2;
    continue;
@

\section{Other commands}

\subsection{[[j]]oining lines: [[j]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'j':
    if(!given)
        addr2++;
    newline();
    join();
    continue;
@

<<function [[join]](ed.c)>>=
void
join(void)
{
    Rune *gp, *lp;
    int *a1;

    nonzero();
    gp = genbuf;
    for(a1=addr1; a1<=addr2; a1++) {
        lp = getline(*a1);
        while(*gp = *lp++)
            if(gp++ >= &genbuf[LBSIZE-sizeof(Rune)])
                error(Q);
    }
    lp = linebuf;
    gp = genbuf;
    while(*lp++ = *gp++)
        ;
    *addr1 = putline();
    if(addr1 < addr2)
        rdelete(addr1+1, addr2);
    dot = addr1;
}
@

\subsection{[[r]]ead files: [[r]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'r':
    filename(c);
caseread:
    if((io=open(file, OREAD)) < 0) {
        lastc = '\n';
        error(file);
    }
    if((d = dirfstat(io)) != nil){
        if(d->mode & DMAPPEND)
            print("warning: %s is append only\n", file);
        free(d);
    }
    Binit(&iobuf, io, OREAD);
    setwide();
    squeeze(0);
    c = zero != dol;
    append(getfile, addr2);
    exfile(OREAD);

    fchange = c;
    continue;
@

<<function [[getfile]](ed.c)>>=
int
getfile(void)
{
    int c;
    Rune *lp;

    lp = linebuf;
    do {
        c = Bgetrune(&iobuf);
        if(c < 0) {
            if(lp > linebuf) {
                putst("'\\n' appended");
                c = '\n';
            } else
                return EOF;
        }
        if(lp >= &linebuf[LBSIZE]) {
            lastc = '\n';
            error(Q);
        }
        *lp++ = c;
        count++;
    } while(c != '\n');
    lp[-1] = 0;
    return 0;
}
@

\subsection{printing remembered [[f]]ile: [[f]]}
% "remembered" either by [[r]] or [[w]]

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'f':
    setnoaddr();
    filename(c);
    putst(savedfile);
    continue;
@

\subsection{[[b]]rowse: [[b]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'b':
    nonzero();
    browse();
    continue;
@
% ???

<<function [[browse]](ed.c)>>=
void
browse(void)
{
    int forward, n;
    static int bformat, bnum; /* 0 */

    forward = 1;
    peekc = getchr();
    if(peekc != '\n'){
        if(peekc == '-' || peekc == '+') {
            if(peekc == '-')
                forward = 0;
            getchr();
        }
        n = getnum();
        if(n > 0)
            bpagesize = n;
    }
    newline();
    if(pflag) {
        bformat = listf;
        bnum = listn;
    } else {
        listf = bformat;
        listn = bnum;
    }
    if(forward) {
        addr1 = addr2;
        addr2 += bpagesize;
        if(addr2 > dol)
            addr2 = dol;
    } else {
        addr1 = addr2-bpagesize;
        if(addr1 <= zero)
            addr1 = zero+1;
    }
    printcom();
}
@

\subsection{[[e]]dit remembered file: [[e]]}

% edit, reset savedfile or something
<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'E':
    fchange = false;
    c = 'e';
case 'e':
    setnoaddr();
    if(vflag && fchange) {
        fchange = false;
        error(Q);
    }
    filename(c);
    init();
    addr2 = zero;
    goto caseread;
@

\subsection{mar[[k]]: [[k]]}

% mark something
<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'k':
    nonzero();
    c = getchr();
    if(c < 'a' || c > 'z')
        error(Q);
    newline();
    names[c-'a'] = *addr2 & ~01;
    anymarks |= 01;
    continue;
@

\subsection{[[n]]: [[n]]}

<<[[commands()]] switch [[c]] cases (ed.c)>>=
case 'n':
    listn++;
    newline();
    printcom();
    continue;
@
% ??





%******************************************************************************
%\chapter{[[awk]]}
%******************************************************************************

%******************************************************************************
\chapter{Search and Replace}
%******************************************************************************
% super useful for programmer.
% now more advanced semantic search and replace tools, IDE, but still
% grep/sed are great

\section{[[grep]]}
% g re p

\l also show code of libregexp here? Maybe better than in Libcore.nw ?

\section{[[sed]]}
% stream editor
% According to {unix-pike} it was designed and implemented by Lee McMahon
% based on ed

\section{[[tr]]}

\section{[[find]]}
% no equivalent in plan9, weird
% du -a is closest, but list also size

\section{[[which]]}

%******************************************************************************
\chapter{Compare}
%******************************************************************************
% super useful too for a programmer

\section{[[cmp]]}
% part of posix?

% useful utility for regression testing for example for a programmer
% where compare output to snapshot.

<<function [[usage]](cmp.c)>>=
static void
usage(void)
{
    print("usage: cmp [-lLs] file1 file2 [offset1 [offset2] ]\n");
    exits("usage");
}
@

<<global flags (cmp.c)>>=
// print nothing for differing files (shutup) but set exit status
bool sflag = false;
// print byte number (decimal) and differing bytes (hexa)
bool lflag = false;
// print the line number of the first differing bytes
bool Lflag = false;
@

<<constant [[BUF]](cmp.c)>>=
#define     BUF     65536
@

% name -> fdt -> buf -> start/end b1 b2
<<[[main]] locals (cmp.c)>>=
char *name1, *name2;
fdt f1, f2;
uchar buf1[BUF], buf2[BUF];
uchar *b1s, *b1e, *b2s, *b2e;
@


<<[[main]] locals (cmp.c)>>=
int n, i;
@
<<[[main]] locals (cmp.c)>>=
uchar *p, *q;
@
<<[[main]] locals (cmp.c)>>=
// ??
vlong nc = 1;
// line
vlong l = 1;
@

<<function [[main]](cmp.c)>>=
void
main(int argc, char *argv[])
{
    <<[[main]] locals (cmp.c)>>

    ARGBEGIN{
    case 's':   sflag = true; break;
    case 'l':   lflag = true; break;
    case 'L':   Lflag = true; break;
    default:    usage();
    }ARGEND

    if(argc < 2 || argc > 4)
        usage();

    if((f1 = open(name1 = *argv++, OREAD)) == -1){
        if(!sflag) perror(name1);
        exits("open");
    }
    if((f2 = open(name2 = *argv++, OREAD)) == -1){
        if(!sflag) perror(name2);
        exits("open");
    }
    argv = seekoff(f1, name1, argv);
    argv = seekoff(f2, name2, argv);
    if(*argv)
        usage();

    b1s = b1e = buf1;
    b2s = b2e = buf2;

    for(;;){
        if(b1s >= b1e){
            if(b1s >= &buf1[BUF])
                b1s = buf1;
            n = read(f1, b1s,  &buf1[BUF] - b1s);
            b1e = b1s + n;
        }
        if(b2s >= b2e){
            if(b2s >= &buf2[BUF])
                b2s = buf2;
            n = read(f2, b2s,  &buf2[BUF] - b2s);
            b2e = b2s + n;
        }
        n = b2e - b2s;
        if(n > b1e - b1s)
            n = b1e - b1s;
        if(n <= 0)
            break;

        if(memcmp((void *)b1s, (void *)b2s, n) != 0){
            if(sflag)
                exits("differ");
            for(p = b1s, q = b2s, i = 0; i < n; p++, q++, i++) {
                if(*p == '\n')
                    l++;
                if(*p != *q){
                    if(!lflag){
                        print("%s %s differ: char %lld",
                            name1, name2, nc+i);
                        print(Lflag?" line %lld\n":"\n", l);
                        exits("differ");
                    }
                    print("%6lld 0x%.2x 0x%.2x\n", nc+i, *p, *q);
                }
            }
        }       
        if(Lflag)
            for(p = b1s; p < b1e;)
                if(*p++ == '\n')
                    l++;
        nc += n;
        b1s += n;
        b2s += n;
    } // end for (;;)

    if (b1e - b1s < 0 || b2e - b2s < 0) {
        if (!sflag) {
            if (b1e - b1s < 0)
                print("error on %s after %lld bytes\n",
                    name1, nc-1);
            if (b2e - b2s < 0)
                print("error on %s after %lld bytes\n",
                    name2, nc-1);
        }
        exits("read error");
    }

    // files are the same, exit 0
    if(b1e - b1s == b2e - b2s)
        exits(nil);

    if(!sflag)
        print("EOF on %s after %lld bytes\n",
            (b1e - b1s > b2e - b2s)? name2 : name1, nc-1);
    exits("EOF");
}
@

<<function [[seekoff]](cmp.c)>>=
char **
seekoff(fdt fd, char *name, char **argv)
{
    vlong o;

    if(*argv){
        if (!isascii(**argv) || !isdigit(**argv))
            usage();
        o = strtoll(*argv++, nil, 0);
        if(seek(fd, o, SEEK__START) < 0){
            if(!sflag) fprint(STDERR, "cmp: %s: seek by %lld: %r\n",
                name, o);
            exits("seek");
        }
    }
    return argv;
}
@

\section{[[comm]]}
% part of posix

% "select or reject lines common to two sorted files" in comm(1) man page

<<[[main]] label [[usage]] (comm.c)>>=
Usage:
    fprint(STDERR, "usage: comm [-123] file1 file2\n");
    exits("usage");
@

% comm -123 file1 file2  col1, col2 (common), col3

<<global flags comm.c>>=
bool one;
bool two;
bool three;
@

<<globals comm.c>>=
char    *ldr[3];
@

<<globals comm.c>>=
Biobuf *ib1;
Biobuf *ib2;
@

<<constant [[LB]](comm.c)>>=
#define LB 2048
@

<<function [[main]](comm.c)>>=
void
main(int argc, char *argv[])
{
    int l;
    char    lb1[LB],lb2[LB];

    ldr[0] = "";
    ldr[1] = "\t";
    ldr[2] = "\t\t";
    l = 1;

    ARGBEGIN{
    case '1':
        if(!one) {
            one = true;
            ldr[1][0] = '\0';
            ldr[2][l--] = '\0';
        }
        break;

    case '2':
        if(!two) {
            two = true;
            ldr[2][l--] = '\0';
        }
        break;

    case '3':
        three = true;
        break;

    default:
        goto Usage;

    }ARGEND

    if(argc < 2) {
    <<[[main]] label [[usage]] (comm.c)>>
    }

    ib1 = openfil(argv[0]);
    ib2 = openfil(argv[1]);

    if(rd(ib1,lb1) < 0){
        if(rd(ib2,lb2) < 0)
            exits(nil);
        copy(ib2,lb2,2);
    }
    if(rd(ib2,lb2) < 0)
        copy(ib1,lb1,1);

    for(;;){
        switch(compare(lb1,lb2)) {
        case 0:
            wr(lb1,3);
            if(rd(ib1,lb1) < 0) {
                if(rd(ib2,lb2) < 0)
                    exits(nil);
                copy(ib2,lb2,2);
            }
            if(rd(ib2,lb2) < 0)
                copy(ib1,lb1,1);
            continue;

        case 1:
            wr(lb1,1);
            if(rd(ib1,lb1) < 0)
                copy(ib2,lb2,2);
            continue;

        case 2:
            wr(lb2,2);
            if(rd(ib2,lb2) < 0)
                copy(ib1,lb1,1);
            continue;
        }
    }
}
@

<<function [[openfil]](comm.c)>>=
Biobuf*
openfil(char *s)
{
    Biobuf *b;

    if(s[0]=='-' && s[1]=='\0')
        s = "/fd/0";
    b = Bopen(s, OREAD);
    if(b)
        return b;
    fprint(STDERR, "comm: cannot open %s: %r\n",s);
    exits("open");
    // never reached
    return nil;   /* shut up ken */
}
@
% what is this "shut up ken" comment? :) to disable warnings of kencc ?

<<function [[rd]](comm.c)>>=
int
rd(Biobuf *file, char *buf)
{
    int i, c;

    i = 0;
    while((c = Bgetc(file)) != Beof) {
        *buf = c;
        if(c == '\n' || i > LB-2) {
            *buf = '\0';
            return 0;
        }
        i++;
        buf++;
    }
    return -1;
}
@

<<function [[compare]](comm.c)>>=
int
compare(char *a, char *b)
{
    while(*a == *b){
        if(*a == '\0')
            return 0;
        a++;
        b++;
    }
    if(*a < *b)
        return 1;
    return 2;
}
@
% not very standard to use 0 1 2 instead of 0, -1, 1

<<function [[wr]](comm.c)>>=
void
wr(char *str, int n)
{

    switch(n){
        case 1:
            if(one)
                return;
            break;

        case 2:
            if(two)
                return;
            break;

        case 3:
            if(three)
                return;
    }
    print("%s%s\n", ldr[n-1],str);
}
@

<<function [[copy]](comm.c)>>=
void
copy(Biobuf *ibuf, char *lbuf, int n)
{
    do
        wr(lbuf,n);
    while(rd(ibuf,lbuf) >= 0);
    exits(nil);
}
@

\section{[[diff]]}
% super useful for a programmer!
% See also \book{VCS}

\section{[[patch]]}
% Larry Wall. 8500 LOC.

%******************************************************************************
\chapter{Processes}
%******************************************************************************
% also useful for the programmer

\section{[[ps]]}

\section{[[pstree]]}

%******************************************************************************
\chapter{Archiving}
%******************************************************************************

% also useful for the programmer

\section{[[tar]]}

%for tar:
% ocaml-tar in mirage

\section{[[gzip]]}
% http://jvns.ca/blog/2013/10/16/day-11-how-does-gzip-work/

\l also show code of libflate?

%******************************************************************************
\chapter{Time}
%******************************************************************************

\section{[[date]]}

%bugfix: this used to segfault in goken because ctime() has
% different sig in plan9 vs unix, so had to use plan9port ctime.c

<<global flags(date.c)>>=
// UTC time, which is mostly the same than GMT
bool uflg;
// number of seconds since the (UNIX) epoch, 1/1/1970:00:00
bool nflg;
@

% strtoul again
<<function [[main]](date.c)>>=
void
main(int argc, char *argv[])
{
    ulong now;

    ARGBEGIN{
    case 'n':   nflg = true; break;
    case 'u':   uflg = true; break;
    default:    fprint(STDERR, "usage: date [-un] [seconds]\n"); exits("usage");
    }ARGEND

    if(argc == 1)
        now = strtoul(*argv, nil, 0);
    else
        now = time(0);

    if(nflg)
        print("%ld\n", now);
    else if(uflg)
        print("%s", asctime(gmtime(now)));
    else
        print("%s", ctime(now));
    
    exits(nil);
}
@

\section{[[cal]]}

%******************************************************************************
\chapter{Pipes}
%******************************************************************************
%alt: Pipe filters

\section{[[tee]]}

% Read from stdin and write on stdout AND on a file (or files).
% Useful for logging a command while also seeing its output
% as  in     <cmd> | tee log.txt

<<global flags(tee.c)>>=
// append mode
bool aflag;
// deprecated
bool uflag;
@

% usually just one file
<<global [[openf]](tee.c)>>=
fdt *openf;
@

<<global [[in]](tee.c)>>=
// read buffer
char in[8192];
@

<<function [[main]](tee.c)>>=
void
main(int argc, char **argv)
{
    int i;
    int r, n;

    ARGBEGIN {
    case 'a':
        aflag = true;
        break;

    case 'i':
        atnotify(intignore, true); // register
        break;

    case 'u':
        uflag = true;
        /* uflag is ignored and undocumented; it's a relic from Unix */
        break;

    default:
        fprint(STDERR, "usage: tee [-ai] [file ...]\n");
        exits("usage");
    } ARGEND

    openf = malloc((1+argc)*sizeof(int));
    if(openf == nil)
        sysfatal("out of memory: %r");

    n = 0;
    while(*argv) {
        if(aflag) {
            openf[n] = open(argv[0], OWRITE);
            if(openf[n] < 0)
                openf[n] = create(argv[0], OWRITE, 0666);
            seek(openf[n], 0L, SEEK__END);
        } else
            openf[n] = create(argv[0], OWRITE, 0666);
        if(openf[n] < 0) {
            fprint(STDERR, "tee: cannot open %s: %r\n", argv[0]);
        } else
            n++;
        argv++;
    }
    openf[n++] = STDOUT;

    for(;;) {
        r = read(STDIN, in, sizeof in);
        if(r <= 0)
            exits(nil);
        for(i=0; i<n; i++)
            write(openf[i], in, r);
    }
}
@

<<function [[intignore]](tee.c)>>=
bool
intignore(void *a, char *msg)
{
    USED(a);
    if(strcmp(msg, "interrupt") == ORD__EQ)
        return true;
    return false;
}
@

\section{[[sort]]}

%sort. can't do sort foo.txt > foo.txt, hence one option of sort for that
% (mentioned in Unix Readers article)

\subsection*{Basic sort}

\subsection*{Advanced sort}

\section{[[uniq]]}

% remove duplicate. Usually preceded by | sort | uniq in a pipe chain

<<globals uniq.c>>=
int fields  = 0;
int letters = 0;
// 'u' or 'd' or 'c' or 's' (meaning??)
char    mode;
@

<<globals uniq.c>>=
int linec   = 0;
@
<<globals uniq.c>>=
bool uniq;
@

<<globals uniq.c>>=
char    *b1, *b2;
long    bsize = SIZE;
@
<<globals uniq.c>>=
Biobuf  fin;
Biobuf  fout;
@

<<constant [[SIZE]](uniq.c)>>=
#define SIZE    8000
@

% No ARGBEGIN/ARGEND here because ?? non-standard flag management?
% which is why need set argv0 manually because ARGBEGIN is doing it
% and some error function probably rely on this global?
<<function [[main]](uniq.c)>>=
void
main(int argc, char *argv[])
{
    fdt f = STDIN;

    argv0 = argv[0]; // use??
    b1 = malloc(bsize);
    b2 = malloc(bsize);
    while(argc > 1) {
        if(*argv[1] == '-') {
            if(isdigit(argv[1][1]))
                fields = atoi(&argv[1][1]);
            else
                mode = argv[1][1];
            argc--;
            argv++;
            continue;
        }
        if(*argv[1] == '+') {
            letters = atoi(&argv[1][1]);
            argc--;
            argv++;
            continue;
        }
        f = open(argv[1], OREAD);
        if(f < 0)
            sysfatal("cannot open %s", argv[1]);
        break;
    }
    if(argc > 2)
        sysfatal("unexpected argument %s", argv[2]);
    Binit(&fin, f, OREAD);
    Binit(&fout, STDOUT, OWRITE);

    if(gline(b1))
        exits(nil);

    for(;;) {
        linec++;
        if(gline(b2)) {
            pline(b1);
            exits(nil);
        }
        if(!equal(b1, b2)) {
            pline(b1);
            linec = 0;
            do {
                linec++;
                if(gline(b1)) {
                    pline(b2);
                    exits(nil);
                }
            } while(equal(b2, b1));
            pline(b2);
            linec = 0;
        }
    }
}
@

% 'g' for ?? grab?
% return whether was EOF
<<function [[gline]](uniq.c)>>=
bool
gline(char *buf)
{
    int len;
    char *p;

    p = Brdline(&fin, '\n');
    if(p == nil)
        return true;
    len = Blinelen(&fin);
    if(len >= bsize-1)
        sysfatal("line too long");
    memmove(buf, p, len);
    buf[len-1] = '\0';
    return false;
}
@

% 'p' for print line?
<<function [[pline]](uniq.c)>>=
void
pline(char *buf)
{
    switch(mode) {

    case 'u':
        if(uniq) {
            uniq = false;
            return;
        }
        break;

    case 'd':
        if(uniq)
            break;
        return;

    case 'c':
        Bprint(&fout, "%4d ", linec);
    }
    uniq = false;
    Bprint(&fout, "%s\n", buf);
}
@

<<function [[equal]](uniq.c)>>=
bool
equal(char *b1, char *b2)
{
    char c;

    if(fields || letters) {
        b1 = skip(b1);
        b2 = skip(b2);
    }
    for(;;) {
        c = *b1++;
        if(c != *b2++) {
            if(c == '\0' && mode == 's')
                return true;
            return false;
        }
        if(c == '\0') {
            uniq = true;
            return true;
        }
    }
}
@

<<function [[skip]](uniq.c)>>=
char*
skip(char *s)
{
    int nf, nl;

    nf = nl = 0;
    while(nf++ < fields) {
        while(*s == ' ' || *s == '\t')
            s++;
        while(!(*s == ' ' || *s == '\t' || *s == '\0') ) 
            s++;
    }
    while(nl++ < letters && *s != '\0') 
            s++;
    return s;
}
@

\section{[[xargs]]}

% find | grep .c | xargs ls -l
% power of xargs!
% also can do stuff in parallel!! xargs -p 20  grep foo

<<function [[usage]](xargs.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: xargs [ -n lines ] [ -p procs ] args ...\n");
    exits("usage");
}
@

<<function [[main]](xargs.c)>>=
void
main(int argc, char **argv)
{
    int lines = 10;
    int procs = 1;
    int i, j, run;
    char **nargv, **args, **p;
    static Biobuf bp;
    
    ARGBEGIN {
    case 'n': lines = atoi(EARGF(usage())); break;
    case 'p': procs = atoi(EARGF(usage())); break;
    default: usage();
    } ARGEND;
    if(argc < 1)
        usage();
    
    nargv = malloc(sizeof(char *) * (argc + lines + 1));
    if(nargv == nil)
        sysfatal("malloc: %r");
    memcpy(nargv, argv, sizeof(char *) * argc);
    args = nargv + argc;

    if(Binit(&bp, STDIN, OREAD) < 0)
        sysfatal("Binit: %r");

    //PAD: Blethal(&bp, nil); only in 9front
    atexit(dowait);

    for(j = 0, run = 1; run; j++){
        if(j >= procs)
            waitpid();
        memset(args, 0, sizeof(char *) * (lines + 1));
        for(i = 0; i < lines; i++)
            if((args[i] = Brdstr(&bp, '\n', 1)) == nil){
                if(i == 0)
                    exits(nil);
                run = 0;
                break;
            }

        switch(fork()){
        case ERROR_NEG1:
            sysfatal("fork: %r");
        // child case
        case 0:
            exec(*nargv, nargv);
            // here if ??
            if(**nargv != '/' && strncmp(*nargv, "./", 2) != 0 &&
                    strncmp(*nargv, "../", 3) != 0){
                *nargv = smprint("/bin/%s", *nargv);
                // try again
                exec(*nargv, nargv);
            }
            sysfatal("exec: %r");
        }
        // else, parent
        for(p = args; *p; p++)
            free(*p);
    }
    exits(nil);
}
@

<<function [[dowait]](xargs.c)>>=
void
dowait(void)
{
    while(waitpid() != ERROR_NEG1)
        ;
}
@

\section{paginate: [[p]] ([[more]], [[less]])}
% p for page for paginate

<<constant [[DEF]](p.c)>>=
#define DEF 22  /* lines in chunk: 3*DEF == 66, #lines per nroff page */
@

% why need /dev/cons?
% because [[p]] reads stdin from pipe to get the content, but
% at the same time read interactive command from /dev/cons!
% How to do in unix??
<<globals p.c>>=
Biobuf *cons;
Biobuf bout;

int pglen = DEF;
@

<<function [[main]](p.c)>>=
void
main(int argc, char *argv[])
{
    int n;
    fdt f;

    // plan9 uses /dev/cons and Linux /dev/tty (both virtual devices)
    if((cons = Bopen("/dev/cons", OREAD)) == nil) {
        if((cons = Bopen("/dev/tty", OREAD)) == nil) {
            fprint(STDERR, "p: can't open /dev/cons or /dev/tty\n");
            exits("missing /dev/cons or /dev/tty");
        }
    }
    Binit(&bout, STDOUT, OWRITE);
    n = 0;
    while(argc > 1) {
        --argc; argv++;
        if(*argv[0] == '-'){
            pglen = atoi(&argv[0][1]);
            if(pglen <= 0)
                pglen = DEF;
        } else {
            n++;
            f = open(argv[0], OREAD);
            if(f < 0){
                fprint(STDERR, "p: can't open %s - %r\n", argv[0]);
                continue;
            }
            printfile(f);
            close(f);
        }
    }
    if(n == 0)
        printfile(STDIN);
    exits(nil);
}
@

<<function [[printfile]](p.c)>>=
void
printfile(fdt f)
{
    int i, j, n;
    char *s, *cmd;
    Biobuf *b;

    b = malloc(sizeof(Biobuf));
    Binit(b, f, OREAD);
    for(;;){
        for(i=1; i <= pglen; i++) {
            s = Brdline(b, '\n');
            if(s == 0){
                n = Blinelen(b);
                if(n > 0)   /* line too long for Brdline */
                    for(j=0; j<n; j++)
                        Bputc(&bout, Bgetc(b));
                else{       /* true EOF */
                    free(b);
                    return;
                }
            }else{
                Bwrite(&bout, s, Blinelen(b)-1);
                if(i < pglen)
                    Bwrite(&bout, "\n", 1);
            }
        }
        Bflush(&bout);
        getcmd:
        cmd = Brdline(cons, '\n');
        if(cmd == nil || *cmd == 'q')
            exits(nil);
        cmd[Blinelen(cons)-1] = 0;
        if(*cmd == '!'){
            if(fork() == 0){
                dup(Bfildes(cons), 0);
                execl("/bin/rc", "rc", "-c", cmd+1, nil);
            }
            waitpid();
            goto getcmd;
        }
    }
}
@


\section{columnate: [[mc]]}
% columnate
% multi column print

% good defaults
<<constants mc.c>>=
#define WIDTH           80
#define TAB 4
@

<<globals mc.c>>=
int linewidth=WIDTH;
@


<<global flags mc.c>>=
// ??
bool colonflag = false;
@

<<global flags mc.c>>=
// set to true in acme
bool tabflag = false;  /* -t flag turned off forever */
@

<<globals mc.c>>=
Biobuf  bin;
Biobuf  bout;
@

<<constants mc.c>>=
#define ALLOC_QUANTA        4096
#define WORD_ALLOC_QUANTA   1024
@
<<globals mc.c>>=
Rune *cbuf, *cbufp;
Rune **word;
@


<<function [[main]](mc.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    bool lineset = false;
    fdt ifd;

    Binit(&bout, STDOUT, OWRITE);

    // Why no ARGBEGIN/ARGEND?
    while(argc > 1 && argv[1][0] == '-'){
        --argc; argv++;
        switch(argv[0][1]){
        case '\0':
            colonflag = true;
            break;
        // useful only for acme
        case 't':
            tabflag = false;
            break;
        default:
            linewidth = atoi(&argv[0][1]);
            if(linewidth <= 1)
                linewidth = WIDTH;
            lineset = true;
            break;
        }
    }

    if(!lineset){
        getwidth();
        if(linewidth <= 1){
            linewidth = WIDTH;
            font = nil;
        }
    }

    cbuf = cbufp = malloc(ALLOC_QUANTA*(sizeof *cbuf));
    word = malloc(WORD_ALLOC_QUANTA*(sizeof *word));
    if(word == nil || cbuf == nil)
        error("out of memory");

    if(argc == 1)
        readbuf(STDIN);
    else{
        for(i = 1; i < argc; i++){
            if((ifd = open(*++argv, OREAD)) == -1)
                fprint(STDERR, "mc: can't open %s (%r)\n", *argv);
            else{
                readbuf(ifd);
                Bflush(&bin);
                close(ifd);
            }
        }
    }
    columnate();
    exits(nil);
}
@

<<function [[error]](mc.c)>>=
void
error(char *s)
{
    fprint(STDERR, "mc: %s\n", s);
    exits(s);
}
@


<<globals mc.c>>=
int nalloc=ALLOC_QUANTA;
int nchars=0;
@

<<function [[readbuf]](mc.c)>>=
void
readbuf(fdt fd)
{
    int lastwascolon = 0;
    int linesiz = 0;
    long c;

    Binit(&bin, fd, OREAD);
    do{
        if(nchars++ >= nalloc)
            morechars();
        *cbufp++ = c = Bgetrune(&bin);
        linesiz++;
        if(c == '\t') {
            cbufp[-1] = L' ';
            while(linesiz%TAB != 0) {
                if(nchars++ >= nalloc)
                    morechars();
                *cbufp++ = L' ';
                linesiz++;
            }
        }
        if(colonflag && c == ':')
            lastwascolon++;
        else if(lastwascolon){
            if(c == '\n'){
                --nchars;   /* skip newline */
                *cbufp = L'\0';
                while(nchars > 0 && cbuf[--nchars] != '\n')
                    ;
                if(nchars)
                    nchars++;
                columnate();
                if (nchars)
                    Bputc(&bout, '\n');
                Bprint(&bout, "%S", cbuf+nchars);
                nchars = 0;
                cbufp = cbuf;
            }
            lastwascolon = 0;
        }
        if(c == '\n')
            linesiz = 0;
    }while(c >= 0);
}
@

<<function [[morechars]](mc.c)>>=
void
morechars(void)
{
    nalloc += ALLOC_QUANTA;
    if((cbuf = realloc(cbuf, nalloc*sizeof(*cbuf))) == nil)
        error("out of memory");
    cbufp = cbuf+nchars-1;
}
@

<<function [[getwidth]](mc.c)(unix)>>=
void getwidth(void)
{
}
@
<<function [[wordwidth]](mc.c)(unix)>>=
int
wordwidth(Rune *w, int nw)
{
    return nw;
}
@

<<globals mc.c>>=
int nwords=0;
int mintab=1;
int maxwidth=0;
@

<<function [[columnate]](mc.c)>>=
void
columnate(void)
{
    int i, j;
    int words_per_line;
    int nlines;
    int col;
    int endcol;


    scanwords();
    if(nwords==0)
        return;
    maxwidth = nexttab(maxwidth+mintab-1);
    words_per_line = linewidth/maxwidth;
    if(words_per_line <= 0)
        words_per_line = 1;
    nlines=(nwords+words_per_line-1)/words_per_line;
    for(i = 0; i < nlines; i++){
        col = endcol = 0;
        for(j = i; j < nwords; j += nlines){
            endcol += maxwidth;
            Bprint(&bout, "%S", word[j]);
            col += wordwidth(word[j], runestrlen(word[j]));
            if(j+nlines < nwords){
                if(tabflag) {
                    while(col < endcol){
                        Bputc(&bout, '\t');
                        col = nexttab(col);
                    }
                }else{
                    while(col < endcol){
                        Bputc(&bout, ' ');
                        col++;
                    }
                }
            }
        }
        Bputc(&bout, '\n');
    }
}
@

<<globals mc.c>>=
int nwalloc=WORD_ALLOC_QUANTA;
@

<<function [[scanwords]](mc.c)>>=
void
scanwords(void)
{
    Rune *p, *q;
    int i, w;

    nwords=0;
    maxwidth=0;
    for(p = q = cbuf, i = 0; i < nchars; i++){
        if(*p++ == L'\n'){
            if(nwords >= nwalloc){
                nwalloc += WORD_ALLOC_QUANTA;
                if((word = realloc(word, nwalloc*sizeof(*word)))==0)
                    error("out of memory");
            }
            word[nwords++] = q;
            p[-1] = L'\0';
            w = wordwidth(q, p-q-1);
            if(w > maxwidth)
                maxwidth = w;
            q = p;
        }
    }
}
@

<<globals mc.c>>=
int tabwidth=0;
@

<<function [[nexttab]](mc.c)>>=
int
nexttab(int col)
{
    if(tabwidth){
        col += tabwidth;
        col -= col%tabwidth;
        return col;
    }
    return col+1;
}
@

%******************************************************************************
%\chapter{Calculators}
%******************************************************************************
%\section{[[bc]]}
%\section{[[dc]]}
%\section{[[hoc]]}

%******************************************************************************
\chapter{Bytes}
%******************************************************************************

\section{[[xd]]}
% hexadecimal dumper?

\section{[[od]]}
% octal dump?

\section{[[dd]]}
% dd = ? disk dump?

\section{[[split]]}

<<function [[usage]](split.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: split [-n num] [-e exp] [-f stem] [-s suff] [-x] [-i] [file]\n");
    exits("usage");
}
@

<<[[main]](split.c) locals>>=
int n = 1000;
@

<<[[main]](split.c) locals>>=
// ??
bool xflag = false;
// ??
bool iflag = false;
@


<<globals split.c>>=
char    *stem = "x";
@

<<globals split.c>>=
char    *suffix = "";
@

<<[[main]](split.c) switch flag character cases>>=
case 'l':
case 'n':
    n=atoi(EARGF(usage()));
    break;
case 'e':
    pattern = strdup(EARGF(usage()));
    break;
case 'f':
    stem = strdup(EARGF(usage()));
    break;
case 's':
    suffix = strdup(EARGF(usage()));
    break;
case 'x':
    xflag = true;
    break;
case 'i':
    iflag = true;
    break;
@



<<globals split.c>>=
char    digit[] = "0123456789";
char    suff[] = "aa";
char    name[200];
@

<<globals split.c>>=
Biobuf  bout;
Biobuf  *output = &bout;
@

<<[[main]](split.c) locals>>=
Biobuf bin;
Biobuf *b = &bin;
@


<<[[main]](split.c) locals>>=
char *line;
@

<<[[main]](split.c) locals>>=
char buf[256];
@

<<function [[main]](split.c)>>=
void
main(int argc, char *argv[])
{
    <<[[main]](split.c) locals>>

    ARGBEGIN {
    <<[[main]](split.c) switch flag character cases>>
    default:
        usage();
        break;

    } ARGEND;

    if(argc < 0 || argc > 1)
        usage();

    if(argc != 0) {
        b = Bopen(argv[0], OREAD);
        if(b == nil) {
            fprint(STDERR, "split: can't open %s: %r\n", argv[0]);
            exits("open");
        }
    } else
        Binit(b, STDIN, OREAD);

    <<[[main()]](split.c) if [[pattern]]>>
    else {
        int linecnt = n;

        while((line=Brdline(b,'\n')) != 0) {
            if(++linecnt > n) {
                nextfile();
                linecnt = 1;
            }
            Bwrite(output, line, Blinelen(b));
        }

        /*
         * in case we didn't end with a newline, tack whatever's 
         * left onto the last file
         */
        while((n = Bread(b, buf, sizeof(buf))) > 0)
            Bwrite(output, buf, n);
    }
    if(b != nil)
        Bterm(b);
    exits(nil);
}
@


\subsection*{Basic usage}

<<function [[nextfile]](split.c)>>=
bool
nextfile(void)
{
    static bool canopen = true;

    if(suff[0] > 'z') {
        if(canopen)
            fprint(STDERR, "split: file %szz not split\n",stem);
        canopen = false;
    } else {
        snprint(name, sizeof name, "%s%s", stem, suff);
        if(++suff[1] > 'z') 
            suff[1] = 'a', ++suff[0];
        openf();
    }
    return canopen;
}
@

<<function [[openf]](split.c)>>=
void
openf(void)
{
    static fdt fd = 0;

    Bflush(output);
    Bterm(output);
    if(fd > 0)
        close(fd);
    fd = create(name,OWRITE,0666);
    if(fd < 0) {
        fprint(STDERR, "grep: can't create %s: %r\n", name);
        exits("create");
    }
    Binit(output, fd, OWRITE);
}
@
% grep: ??? it's split!! in the error message :)

\subsection*{Advanced usage}

<<globals split.c>>=
char *pattern = nil;
@

<<[[main]](split.c) locals>>=
Reprog *exp;
@

<<[[main()]](split.c) if [[pattern]]>>=
if(pattern) {
    Resub match[2];

    if(!(exp = regcomp(iflag? fold(pattern, strlen(pattern)):
        pattern)))
        badexp();
    memset(match, 0, sizeof match);
    matchfile(match);
    while((line=Brdline(b,'\n')) != 0) {
        memset(match, 0, sizeof match);
        line[Blinelen(b)-1] = 0;
        if(regexec(exp, iflag? fold(line, Blinelen(b)-1): line,
            match, 2)) {
            if(matchfile(match) && xflag)
                continue;
        } else if(output == 0)
            nextfile(); /* at most once */
        Bwrite(output, line, Blinelen(b)-1);
        Bputc(output, '\n');
    }
}
@

<<function [[badexp]](split.c)>>=
void
badexp(void)
{
    fprint(STDERR, "split: bad regular expression\n");
    exits("bad regular expression");
}
@

<<function [[fold]](split.c)>>=
char *
fold(char *s, int n)
{
    static char *fline;
    static int linesize = 0;
    char *t;

    if(linesize < n+1){
        fline = realloc(fline,n+1);
        linesize = n+1;
    }
    for(t=fline; *t++ = tolower(*s++); )
        continue;
        /* we assume the 'A'-'Z' only appear as themselves
         * in a utf encoding.
         */
    return fline;
}
@

<<function [[matchfile]](split.c)>>=
int
matchfile(Resub *match)
{
    if(match[1].s.sp) {
        int len = match[1].e.ep - match[1].s.sp;

        strncpy(name, match[1].s.sp, len);
        strcpy(name+len, suffix);
        openf();
        return 1;
    } 
    return nextfile();
}
@

%******************************************************************************
\chapter{Misc}
%******************************************************************************

%\section{[[dirname]]}
% part of posix 

\section{[[basename]]}

<<function [[main]](basename.c)>>=
void
main(int argc, char *argv[])
{
    char *pr;
    int n;
    bool dflag = false;

    if(argc>1 && strcmp(argv[1], "-d") == ORD__EQ){
        --argc;
        ++argv;
        dflag = true;
    }
    if(argc < 2 || argc > 3){
        fprint(STDERR, "usage: basename [-d] string [suffix]\n");
        exits("usage");
    }
    pr = utfrrune(argv[1], '/');
    if(dflag){
        if(pr){
            *pr = '\0';
            print("%s\n", argv[1]);
            exits(nil);
        }
        // else
        print(".\n");
        exits(nil);
    }
    if(pr)
        pr++;
    else
        pr = argv[1];

    if(argc==3){
        n = strlen(pr)-strlen(argv[2]);
        if(n >= 0 && !strcmp(pr+n, argv[2]))
            pr[n] = '\0';
    }
    print("%s\n", pr);
    exits(nil);
}
@

\section{[[file]]}

\section{[[iconv]]}

\section{[[strings]]}

\section{[[unicode]]}

\section{[[sleep]]}

\section{[[reboot]]}

% part of posix
%\section{[[cut]]}
%\section{[[join]]}
%\section{[[command]]}

%******************************************************************************
\chapter{Advanced topics}
%******************************************************************************

%list of commands useful for administration:
% - http://cb.vu/unixtoolbox.xhtml

\section{Optimizations}

% how to optimize even simple utilities like 'yes' to have huge throuput:
%https://www.reddit.com/r/unix/comments/6gxduc/how_is_gnu_yes_so_fast/?st=j3v3iw3c&sh=5651ea3c
% maybe better blog post about yes evolution:
%  https://matthias-endler.de/2017/yes/

\section{Internationalization}
% i18n
% actually already good with plan9 and unicode/utf8 (actually
% invented by plan9 people, see hello world paper)


%******************************************************************************
\chapter{Conclusion}
%******************************************************************************
\label{chap:conclusion}

%\ifallcode
#include "Utilities_extra.nw"
%\fi

%******************************************************************************
\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
LOC = Lines Of Code
CLI = Command-Line Interface
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
