\documentclass[12pt]{report}
%alt: [12pt, twocolumn, landscape]

\input{../docs/latex/Packages}
\input{../docs/latex/Config}
\input{../docs/latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:

%thx to codemap/codegraph/scheck:

%thx to utilities in ocaml: (see also the %ocaml-found: tag in this file)

%thx to this manual, I better understand utilities:
% - tee for seeing and logging to a file a command output
% - xargs accept -p so can run jobs in parallel! easy parallelism

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - SEMI put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * SEMI function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations


\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Utilities
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
many people
}

\maketitle 
%\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

%******************************************************************************
\chapter{Introduction}
%******************************************************************************

The goal of this book is to explain with full details the source code of
many {utilities}, especially utilities that are useful for the programmer
such as [[grep]] and [[sed]].

\section{Motivations}

% CLI is mandatory for programmer. Toolbox.

% cite great book by Kernighan on Software tools, lots of string processing tools
%  but use ratfor instead of C
% cite also "Unix programming environment" by Pike and Kernighan

\section{The \plan utilities}

\section{Other utilities}

%UNIX V5, OpenBSD, Plan 9, FreeBSD, and GNU coreutils implementations of echo.c
%https://gist.github.com/dchest/1091803
% evolution of a program :)

% suckless version in C: http://git.suckless.org/sbase/tree/README

% in Rust: https://github.com/uutils/coreutils/
% in Go: https://github.com/polegone/gonix
% in Javascript: https://github.com/dthree/cash/

% - busybox
%  https://en.wikipedia.org/wiki/BusyBox
% many commands in one binary, including shell ash
% the repository has lots of commands. 256 000 LOC in total.
% - toybox, BSD-licensed busybox-like, used in Android

% Lisp machine, Oberon, where REPL instead of separate CLI tools.


\section{Getting started}
\label{sec:getting-started}

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}


%******************************************************************************
\chapter{Overview}
%******************************************************************************

\section{Utilities principles}
% Unix philosophy: do one thing, separation of concern, minimalist
% CLI args and while(<>) of Perl style.

%high level explanations of coreutils:
% http://maizure.org/projects/decoded-gnu-coreutils/

% list of utilities specified in POSIX 1002.3
% see MISC/BIG/ape_cmd/README

\section{Command-line interfaces}

\section{Code organization}

\section{Software architecture}

<<plan9 includes>>=
#include <u.h>
#include <libc.h>
@

\section{Book structure}

%******************************************************************************
\chapter{Files and Directories}
%******************************************************************************

% could be part of the shell as builtin (in fact busybox/ash does that?)

\section{[[cat]]}

%trans: let's start with simplest one (LOC).

% 'cat' for concatenate but can be used also with single file to see its content
% and also without for copy stdin to stdout (usecase?)

% argv0 assignment is for sysfatal() which relies on this global.
% (why not automatic set in lib9/main ?)
<<function [[main]](cat.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    fdt f;

    argv0 = "cat";
    if(argc == 1)
        cat(STDIN, "<stdin>");
    else for(i=1; i<argc; i++){
        f = open(argv[i], OREAD);
        if(f < 0)
            sysfatal("can't open %s: %r", argv[i]);
        else{
            cat(f, argv[i]);
            close(f);
        }
    }
    exits(nil);
}
@
% %r is cool plan9 extension for errstr

<<function [[cat]]>>=
void
cat(fdt f, char *origin)
{
    char buf[8192];
    long n;

    while((n=read(f, buf, (long)sizeof buf))>0)
        if(write(STDOUT, buf, n)!=n)
            sysfatal("write error copying %s: %r", origin);
    if(n < 0)
        sysfatal("error reading %s: %r", origin);
}
@

\section{[[ls]]}

% pretty big. > 1000 LOC

\section{[[touch]]}

% -c for nocreate if file not exist in the first place
<<function [[usage]](touch.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: touch [-c] [-t time] files\n");
    exits("usage");
}
@

<<global [[now]](touch.c)>>=
ulong now;
@

% strtoul str to ulong, and 0 3rd param is base.
% second param is ??
<<function [[main]](touch.c)>>=
void
main(int argc, char **argv)
{
    char *t, *s;
    bool nocreate = false;
    errorn status = OK_0;

    now = time(0);
    ARGBEGIN{
    case 't':
        t = EARGF(usage());
        now = strtoul(t, &s, 0);
        if(s == t || *s != '\0')
            usage();
        break;
    case 'c':
        nocreate = true;
        break;
    default:    
        usage();
    }ARGEND

    if(!*argv)
        usage();
    while(*argv)
        status += touch(nocreate, *argv++);
    if(status)
        exits("touch");
    exits(nil);
}
@

%nulldir?
%stbuff stat buffer?
<<function [[touch]]>>=
error1
touch(bool nocreate, char *name)
{
    Dir stbuff;
    fdt fd;

    nulldir(&stbuff);
    stbuff.mtime = now;
    if(dirwstat(name, &stbuff) >= 0)
        return OK_0;
    //else
    if(nocreate){
        fprint(STDERR, "touch: %s: cannot wstat: %r\n", name);
        return ERROR_1;
    }
    if((fd = create(name, OREAD|OEXCL, 0666)) < 0){
        fprint(STDERR, "touch: %s: cannot create: %r\n", name);
        return ERROR_1;
    }
    dirfwstat(fd, &stbuff);
    close(fd);
    return OK_0;
}
@

\section{[[mkdir]]}

% -p for creating intermediate dirs (p for parent dirs)
<<function [[usage]](mkdir.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: mkdir [-p] [-m mode] dir...\n");
    exits("usage");
}
@

<<global [[mode]](mkdir.c)>>=
ulong mode = 0777L;
@

<<global [[e]](mkdir.c)>>=
// error
char *e;
@

<<function [[main]](mkdir.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    bool pflag = false;
    char *m;

    ARGBEGIN{
    case 'm':
        m = ARGF();
        if(m == nil)
            usage();
        mode = strtoul(m, &m, 8);
        if(mode > 0777)
            usage();
        break;
    case 'p':
        pflag = true;
        break;
    default:
        usage();
    }ARGEND

    for(i=0; i<argc; i++){
        if(pflag)
            mkdirp(argv[i]);
        else
            makedir(argv[i]);
    }
    exits(e);
}
@

% return value used from mkdirp but not from main
<<function [[makedir]]>>=
errorneg1
makedir(char *s)
{
    fdt f;

    if(access(s, AEXIST) == 0){
        fprint(STDERR, "mkdir: %s already exists\n", s);
        e = "error";
        return ERROR_NEG1;
    }
    f = create(s, OREAD, DMDIR | mode);
    if(f < 0){
        fprint(STDERR, "mkdir: can't create %s: %r\n", s);
        e = "error";
        return ERROR_NEG1;
    }
    close(f);
    return OK_0;
}
@

<<function [[mkdirp]]>>=
void
mkdirp(char *s)
{
    char *p;

    for(p=strchr(s+1, '/'); p; p=strchr(p+1, '/')){
        *p = '\0';
        if(access(s, AEXIST) != 0 && makedir(s) == ERROR_NEG1)
            return;
        *p = '/';
    }
    if(access(s, AEXIST) != 0)
        makedir(s);
}
@

\section{[[rm]]}

<<global [[ignerr]](rm.c)>>=
// for 'rm -f'
bool ignerr = false;
@
% default value?? nil?
<<global [[errbuf]](rm.c)>>=
char errbuf[ERRMAX];
@

% remove() below is syscall
<<function [[main]](rm.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    // rm -r
    bool recurse = false;
    char *f;
    Dir *db;

    ARGBEGIN{
    case 'r':
        recurse = true;
        break;
    case 'f':
        ignerr = true;
        break;
    default:
        fprint(STDERR, "usage: rm [-fr] file ...\n");
        exits("usage");
    }ARGEND

    for(i=0; i<argc; i++){
        f = argv[i];
        if(remove(f) != ERROR_NEG1)
            continue;
        //else
        db = nil;
        if(recurse && (db=dirstat(f))!=nil && (db->qid.type&QTDIR))
            rmdir_(f);
        else
            err(f);
        free(db);
    }
    exits(errbuf);
}
@

<<function [[rmdir]]>>=
/*
 * f is a non-empty directory. Remove its contents and then it.
 */
void
rmdir_(char *f)
{
    char *name;
    int i, j, n, ndir, nname;
    fdt fd;
    Dir *dirbuf;

    fd = open(f, OREAD);
    if(fd < 0){
        err(f);
        return;
    }
    //else
    n = dirreadall(fd, &dirbuf);
    close(fd);
    if(n < 0){
        err("dirreadall");
        return;
    }

    nname = strlen(f)+1+STATMAX+1;  /* plenty! */
    name = malloc(nname);
    if(name == nil){
        err("memory allocation");
        return;
    }

    ndir = 0;
    for(i=0; i<n; i++){
        snprint(name, nname, "%s/%s", f, dirbuf[i].name);
        if(remove(name) != ERROR_NEG1)
            dirbuf[i].qid.type = QTFILE;    /* so we won't recurse */
        else{
            if(dirbuf[i].qid.type & QTDIR)
                ndir++;
            else
                err(name);
        }
    }
    if(ndir)
        for(j=0; j<n; j++)
            if(dirbuf[j].qid.type & QTDIR){
                snprint(name, nname, "%s/%s", f, dirbuf[j].name);
                // recurse
                rmdir_(name);
            }
    if(remove(f) == ERROR_NEG1)
        err(f);
    free(name);
    free(dirbuf);
}
@

<<function [[err]](rm.c)>>=
void
err(char *f)
{
    if(!ignerr){
        errbuf[0] = '\0';
        errstr(errbuf, sizeof errbuf);
        fprint(STDERR, "rm: %s: %s\n", f, errbuf);
    }
}
@

\section{[[cp]]}

<<global [[failed]](cp.c)>>=
bool failed;
@

<<global flags(cp.c)>>=
// keep gid
bool gflag = false;
// keep uid (-u implies -g)
bool uflag = false;
// keep time and mode
bool xflag = false;
@

<<label [[usage]] in [[main]](cp.c)>>=
usage:
    fprint(STDERR, "usage:\tcp [-gux] fromfile tofile\n");
    fprint(STDERR, "\tcp [-x] fromfile ... todir\n");
    exits("usage");
@

<<function [[main]](cp.c)>>=
void
main(int argc, char *argv[])
{
    Dir *dirb;
    int i;
    bool todir = false;

    ARGBEGIN {
    case 'g':
        gflag = true;
        break;
    case 'u':
        uflag = true;
        gflag = true;
        break;
    case 'x':
        xflag = true;
        break;
    default:
        goto usage;
    } ARGEND

    if(argc < 2)
        goto usage;

    dirb = dirstat(argv[argc-1]);
    if(dirb!=nil && (dirb->mode&DMDIR))
        todir=true;
    if(argc>2 && !todir){
        fprint(STDERR, "cp: %s not a directory\n", argv[argc-1]);
        exits("bad usage");
    }

    for(i=0; i<argc-1; i++)
        copy(argv[i], argv[argc-1], todir);

    if(failed)
        exits("errors");
    exits(nil);
<<label [[usage]] in [[main]](cp.c)>>
}
@

<<function [[copy]]>>=
void
copy(char *from, char *to, bool todir)
{
    Dir *dirb, dirt;
    char name[256];
    // fd from, fd to
    fdt fdf, fdt;
    int mode;

    if(todir){
        char *s, *elem;
        elem=s=from;
        while(*s++)
            if(s[-1]=='/')
                elem=s;
        sprint(name, "%s/%s", to, elem);
        to=name;
    }

    if((dirb=dirstat(from))==nil){
        fprint(STDERR,"cp: can't stat %s: %r\n", from);
        failed = true;
        return;
    }
    mode = dirb->mode;
    if(mode&DMDIR){
        fprint(STDERR, "cp: %s is a directory\n", from);
        free(dirb);
        failed = true;
        return;
    }
    if(samefile(dirb, from, to)){
        free(dirb);
        failed = true;
        return;
    }
    mode &= 0777;
    fdf=open(from, OREAD);
    if(fdf<0){
        fprint(STDERR, "cp: can't open %s: %r\n", from);
        free(dirb);
        failed = true;
        return;
    }
    fdt=create(to, OWRITE, mode);
    if(fdt<0){
        fprint(STDERR, "cp: can't create %s: %r\n", to);
        close(fdf);
        free(dirb);
        failed = true;
        return;
    }
    if(copy1(fdf, fdt, from, to)==OK_0 && (xflag || gflag || uflag)){
        nulldir(&dirt);
        if(xflag){
            dirt.mtime = dirb->mtime;
            dirt.mode = dirb->mode;
        }
        if(uflag)
            dirt.uid = dirb->uid;
        if(gflag)
            dirt.gid = dirb->gid;
        if(dirfwstat(fdt, &dirt) < 0)
            fprint(STDERR, "cp: warning: can't wstat %s: %r\n", to);
    }           
    free(dirb);
    close(fdf);
    close(fdt);
}
@

<<constant [[DEFB]](cp.c)>>=
#define DEFB    (8*1024)
@

<<function [[copy1]]>>=
errorneg1
copy1(fdt fdf, fdt fdt, char *from, char *to)
{
    char *buf;
    long n, n1, rcount;
    errorneg1 rv = OK_0;
    char err[ERRMAX];

    buf = malloc(DEFB);
    /* clear any residual error */
    err[0] = '\0';
    errstr(err, ERRMAX);

    // copy (read and write) as long as n read <= 0
    for(rcount=0;; rcount++) {
        n = read(fdf, buf, DEFB);
        if(n <= 0)
            break;
        n1 = write(fdt, buf, n);
        if(n1 != n) {
            fprint(STDERR, "cp: error writing %s: %r\n", to);
            failed = true;
            rv = ERROR_NEG1;
            break;
        }
    }
    if(n < 0) {
        fprint(2, "cp: error reading %s: %r\n", from);
        failed = true;
        rv = ERROR_NEG1;
    }
    free(buf);
    return rv;
}
@

<<function [[samefile]](cp.c)>>=
bool
samefile(Dir *a, char *an, char *bn)
{
    Dir *b;
    bool ret = false;

    b=dirstat(bn);
    if(b != nil)
    if(b->qid.type==a->qid.type)
    if(b->qid.path==a->qid.path)
    if(b->qid.vers==a->qid.vers)
    if(b->dev==a->dev)
    if(b->type==a->type){
        fprint(STDERR, "cp: %s and %s are the same file\n", an, bn);
        ret = true;
    }
    free(b);
    return ret;
}
@

\section{[[mv]]}

%mv: Can't do mv *.jpg *.JPEG :(
% unix haters handbook :)

<<function [[main]](mv.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    errorn failed = OK_0;
    Dir *dirto, *dirfrom;
    char *todir, *toelem;

    if(argc<3){
        fprint(STDERR, "usage: mv fromfile tofile\n");
        fprint(STDERR, "   mv fromfile ... todir\n");
        exits("bad usage");
    }

    /* prepass to canonicalise names before splitting, etc. */
    for(i=1; i < argc; i++)
        cleanname(argv[i]);

    if((dirto = dirstat(argv[argc-1])) != nil && (dirto->mode&DMDIR)){
        dirfrom = nil;
        if(argc == 3
        && (dirfrom = dirstat(argv[1])) != nil
        && (dirfrom->mode & DMDIR)) 
            split(argv[argc-1], &todir, &toelem); /* mv dir1 dir2 */
        else{               /* mv file... dir */
            todir = argv[argc-1];
            toelem = nil;       /* toelem will be fromelem */
        }
        free(dirfrom);
    }else
        split(argv[argc-1], &todir, &toelem);   /* mv file1 file2 */
    free(dirto);
    if(argc>3 && toelem != nil){
        fprint(STDERR, "mv: %s not a directory\n", argv[argc-1]);
        exits("bad usage");
    }

    for(i=1; i < argc-1; i++)
        if(mv(argv[i], todir, toelem) == ERROR_NEG1)
            failed++;
    if(failed)
        exits("failure");
    exits(nil);
}
@

<<function [[mv]]>>=
errorneg1
mv(char *from, char *todir, char *toelem)
{
    errorneg1 stat;
    Dir *dirb;

    dirb = dirstat(from);
    if(dirb == nil){
        fprint(STDERR, "mv: can't stat %s: %r\n", from);
        return ERROR_NEG1;
    }
    stat = mv1(from, dirb, todir, toelem);
    free(dirb);
    return stat;
}
@

<<function [[mv1]]>>=
errorneg1
mv1(char *from, Dir *dirb, char *todir, char *toelem)
{
    // fd from, fd to
    fdt fdf, fdt;
    int i, j;
    errorneg1 stat;
    char toname[4096], fromname[4096];
    char *fromdir, *fromelem;
    Dir *dirt, null;

    strncpy(fromname, from, sizeof fromname);
    split(from, &fromdir, &fromelem);
    if(toelem == nil)
        toelem = fromelem;
    i = strlen(toelem);
    if(i==0){
        fprint(STDERR, "mv: null last name element moving %s\n", fromname);
        return ERROR_NEG1;
    }
    j = strlen(todir);
    if(i + j + 2 > sizeof toname){
        fprint(STDERR, "mv: path too big (max %d): %s/%s\n",
            sizeof toname, todir, toelem);
        return ERROR_NEG1;
    }
    memmove(toname, todir, j);
    toname[j] = '/';
    memmove(toname+j+1, toelem, i);
    toname[i+j+1] = '\0';

    if(samefile(fromdir, todir)){
        if(samefile(fromname, toname)){
            fprint(STDERR, "mv: %s and %s are the same\n",
                fromname, toname);
            return ERROR_NEG1;
        }

        /* remove target if present */
        dirt = dirstat(toname);
        if(dirt != nil) {
            hardremove(toname);
            free(dirt);
        }

        /* try wstat */
        nulldir(&null);
        null.name = toelem;
        if(dirwstat(fromname, &null) >= 0)
            return OK_0;
        if(dirb->mode & DMDIR){
            fprint(STDERR, "mv: can't rename directory %s: %r\n",
                fromname);
            return ERROR_NEG1;
        }
    }
    /*
     * Renaming won't work --- must copy
     */
    if(dirb->mode & DMDIR){
        fprint(STDERR, "mv: %s is a directory, not copied to %s\n",
            fromname, toname);
        return ERROR_NEG1;
    }
    fdf = open(fromname, OREAD);
    if(fdf < 0){
        fprint(STDERR, "mv: can't open %s: %r\n", fromname);
        return ERROR_NEG1;
    }

    dirt = dirstat(toname);
    if(dirt != nil && (dirt->mode & DMAPPEND))
        hardremove(toname);  /* because create() won't truncate file */
    free(dirt);

    fdt = create(toname, OWRITE, dirb->mode);
    if(fdt < 0){
        fprint(STDERR, "mv: can't create %s: %r\n", toname);
        close(fdf);
        return ERROR_NEG1;
    }
    stat = copy1(fdf, fdt, fromname, toname);
    close(fdf);

    if(stat >= 0){
        nulldir(&null);
        null.mtime = dirb->mtime;
        null.mode = dirb->mode;
        dirfwstat(fdt, &null);  /* ignore errors; e.g. user none always fails */
        if(remove(fromname) < 0){
            fprint(STDERR, "mv: can't remove %s: %r\n", fromname);
            stat = ERROR_NEG1;
        }
    }
    close(fdt);
    return stat;
}
@

% could factorize with cp copy1
<<function [[copy1]](mv.c)>>=
errorneg1
copy1(fdt fdf, fdt fdt, char *from, char *to)
{
    char buf[8192];
    long n, n1;

    while ((n = read(fdf, buf, sizeof buf)) > 0) {
        n1 = write(fdt, buf, n);
        if(n1 != n){
            fprint(STDERR, "mv: error writing %s: %r\n", to);
            return ERROR_NEG1;
        }
    }
    if(n < 0){
        fprint(STDERR, "mv: error reading %s: %r\n", from);
        return ERROR_NEG1;
    }
    return OK_0;
}
@

<<function [[split]](mv.c)>>=
void
split(char *name, char **pdir, char **pelem)
{
    char *s;

    s = utfrrune(name, '/');
    if(s){
        *s = '\0';
        *pelem = s+1;
        *pdir = name;
    }else if(strcmp(name, "..") == 0){
        *pdir = "..";
        *pelem = ".";
    }else{
        *pdir = ".";
        *pelem = name;
    }
}
@

<<function [[samefile]](mv.c)>>=
bool
samefile(char *a, char *b)
{
    Dir *da, *db;
    bool ret;

    if(strcmp(a, b) == 0)
        return true;
    da = dirstat(a);
    db = dirstat(b);
    ret = (da != nil && db != nil &&
        da->qid.type==db->qid.type &&
        da->qid.path==db->qid.path &&
        da->qid.vers==db->qid.vers &&
        da->dev==db->dev &&
        da->type==db->type);
    free(da);
    free(db);
    return ret;
}
@

<<function [[hardremove]](mv.c)>>=
void
hardremove(char *a)
{
    if(remove(a) == ERROR_NEG1){
        fprint(STDERR, "mv: can't remove %s: %r\n", a);
        exits("mv");
    }
    //????
    while(remove(a) != ERROR_NEG1)
        ;
}
@

\section{[[chmod]]}

<<function [[main]](chmod.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    Dir *dir, ndir;
    ulong mode, mask;
    char *p;

    if(argc < 3){
        fprint(STDERR, "usage: chmod 0777 file ... or chmod [who]op[rwxalt] file ...\n");
        exits("usage");
    }
    mode = strtol(argv[1], &p, 8);
    if(*p == '\0')
        mask = A(DMRWE);
    else if(parsemode(argv[1], &mask, &mode) == ERROR_0){
        fprint(STDERR, "chmod: bad mode: %s\n", argv[1]);
        exits("mode");
    }
    nulldir(&ndir);
    for(i=2; i<argc; i++){
        dir = dirstat(argv[i]);
        if(dir == nil){
            fprint(STDERR, "chmod: can't stat %s: %r\n", argv[i]);
            continue;
        }
        ndir.mode = (dir->mode & ~mask) | (mode & mask);
        free(dir);
        if(dirwstat(argv[i], &ndir)==-1){
            fprint(STDERR, "chmod: can't wstat %s: %r\n", argv[i]);
            continue;
        }
    }
    exits(nil);
}
@

<<function [[parsemode]](chmod.c)>>=
error0
parsemode(char *spec, ulong *pmask, ulong *pmode)
{
    ulong mode, mask;
    bool done;
    int op;
    char *s;

    s = spec;
    mask = DMAPPEND | DMEXCL | DMTMP;
    for(done=false; !done; ){
        switch(*s){
        case 'u':
            mask |= U(DMRWE); break;
        case 'g':
            mask |= G(DMRWE); break;
        case 'o':
            mask |= O(DMRWE); break;
        case 'a':
            mask |= A(DMRWE); break;
        case 0:
            return ERROR_0;
        default:
            done = true;
        }
        if(!done)
            s++;
    }
    if(s == spec)
        mask |= A(DMRWE);
    op = *s++;
    if(op != '+' && op != '-' && op != '=')
        return ERROR_0;
    mode = 0;
    for(; *s ; s++){
        switch(*s){
        case 'r':
            mode |= A(DMREAD); break;
        case 'w':
            mode |= A(DMWRITE); break;
        case 'x':
            mode |= A(DMEXEC); break;
        case 'a':
            mode |= DMAPPEND; break;
        case 'l':
            mode |= DMEXCL; break;
        case 't':
            mode |= DMTMP; break;
        default:
            return ERROR_0;
        }
    }
    if(*s != 0)
        return ERROR_0;
    if(op == '+' || op == '-')
        mask &= mode;
    if(op == '-')
        mode = ~mode;
    *pmask = mask;
    *pmode = mode;
    return OK_1;
}
@

\section{[[chgrp]]}

<<global [[uflag]](chgrp.c)>>=
// change uid of file (instead of gid)
bool uflag;
@

<<function [[main]](chgrp.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    Dir dir;
    char *group;
    char *errs = nil;

    ARGBEGIN {
    default:
    usage:
        fprint(STDERR, "usage: chgrp [ -uo ] group file ....\n");
        exits("usage");
        return;
    case 'u':
    case 'o':
        uflag = true;
        break;
    } ARGEND
    if(argc < 1)
        goto usage;

    group = argv[0];
    for(i=1; i<argc; i++){
        nulldir(&dir);
        if(uflag)
            dir.uid = group;
        else
            dir.gid = group;
        if(dirwstat(argv[i], &dir) == ERROR_NEG1) {
            fprint(STDERR, "chgrp: can't wstat %s: %r\n", argv[i]);
            errs = "can't wstat";
            continue;
        }
    }
    exits(errs);
}
@

\section{[[pwd]]}
% in shell book actually
%TODO: not synced actually and not in Utilities_extra.nw

<<function [[main]](pwd.c)>>=
void
main(int argc, char *argv[])
{
    char pathname[512];

    USED(argc, argv);
    if(getwd(pathname, sizeof(pathname)) == 0) {
        fprint(STDERR, "pwd: %r\n");
        exits("getwd");
    }
    print("%s\n", pathname);
    exits(nil);
}
@

\section{[[mtime]]}
% print the mtime of a file or set of files
% seems useless given ls -l give the same info.
% in fact Linux does not have an mtime command

<<function [[usage]](mtime.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: mtime file...\n");
    exits("usage");
}
@

<<function [[main]](mtime.c)>>=
void
main(int argc, char **argv)
{
    bool errors = false;
    int i;
    Dir *d;

    ARGBEGIN{
    default:
        usage();
    }ARGEND

    for(i=0; i<argc; i++){
        if((d = dirstat(argv[i])) == nil){
            fprint(STDERR, "stat %s: %r\n", argv[i]);
            errors = true;
        }else{
            print("%11lud %s\n", d->mtime, argv[i]);
            free(d);
        }
    }
    exits(errors ? "errors" : nil);
}
@

%******************************************************************************
\chapter{Statistics}
%******************************************************************************

\section{[[wc]]}

<<globals wc.c>>=
/* flags, per-file counts, and total counts */
static bool pline, pword, prune, pbadr, pchar;
static uvlong nline, nword, nrune, nbadr, nchar;
static uvlong tnline, tnword, tnrune, tnbadr, tnchar;
@

<<function [[main]](wc.c)>>=
void
main(int argc, char *argv[])
{
    char *sts = nil;
    Biobuf sin, *bin;
    int i;

    ARGBEGIN {
    case 'l': pline = true; break;
    case 'w': pword = true; break;
    case 'c': pchar = true; break;
    // plan9 new: -r for runes
    case 'r': prune = true; break;
    // ??
    case 'b': pbadr = true; break;
    default:
        fprint(STDERR, "Usage: %s [-lwrbc] [file ...]\n", argv0);
        exits("usage");
    } ARGEND
    if(pline || pword || prune || pbadr || pchar == false){
        // defaults
        pline = true;
        pword = true;
        pchar = true;
    }
    if(argc == 0){
        Binit(&sin, STDIN, OREAD);
        wc(&sin);
        report(nline, nword, nrune, nbadr, nchar, nil);
        Bterm(&sin);
    }else{
        for(i = 0; i < argc; i++){
            bin = Bopen(argv[i], OREAD);
            if(bin == nil){
                perror(argv[i]);
                sts = "can't open";
                continue;
            }
            wc(bin);
            report(nline, nword, nrune, nbadr, nchar, argv[i]);
            Bterm(bin);
        }
        if(argc>1)
            report(tnline, tnword, tnrune, tnbadr, tnchar, "total");
    }
    exits(sts);
}
@

<<enum wc.c>>=
enum{Space, Word};
@

<<function [[wc]]>>=
static void
wc(Biobuf *bin)
{
    int where;
    long r;

    nline = 0;
    nword = 0;
    nrune = 0;
    nbadr = 0;
    where = Space;
    while ((long)(r = Bgetrune(bin)) >= 0) {
        nrune++;
        if(r == Runeerror) {
            nbadr++;
            continue;
        }
        if(r == '\n')
            nline++;
        if(where == Word){
            if(isspacerune(r))
                where = Space;
        }else
            if(isspacerune(r) == 0){
                where = Word;
                nword++;
            }
    }
    nchar = Boffset(bin);
    tnline += nline;
    tnword += nword;
    tnrune += nrune;
    tnbadr += nbadr;
    tnchar += nchar;
}
@

<<function [[report]](wc.c)>>=
static void
report(uvlong nline, uvlong nword, uvlong nrune, uvlong nbadr, uvlong nchar, char *fname)
{
    char line[1024], *s, *e;

    s = line;
    e = line + sizeof line;
    line[0] = '\0';
    if(pline)
        s = seprint(s, e, " %7llud", nline);
    if(pword)
        s = seprint(s, e, " %7llud", nword);
    if(prune)
        s = seprint(s, e, " %7llud", nrune);
    if(pbadr)
        s = seprint(s, e, " %7llud", nbadr);
    if(pchar)
        s = seprint(s, e, " %7llud", nchar);
    if(fname != nil)
        seprint(s, e, " %s",   fname);
    print("%s\n", line+1);
}
@

\section{[[du]]}

%******************************************************************************
%\chapter{String Processing}
%******************************************************************************
% head tail?

%******************************************************************************
\chapter{Bytes}
%******************************************************************************

\section{[[xd]]}
% hexadecimal dumper?

\section{[[dd]]}
% dd = ? disk dump?

\section{[[split]]}

%******************************************************************************
\chapter{Search and Replace}
%******************************************************************************
% super useful for programmer.
% now more advanced semantic search and replace tools, IDE, but still
% grep/sed are great

\section{[[grep]]}
% g re p

\section{[[sed]]}
% stream editor

\section{[[tr]]}

\section{[[find]]}
% no equivalent in plan9, weird
% du -a is closest, but list also size

%******************************************************************************
\chapter{[[diff]]}
%******************************************************************************
% super useful too for a programmer
% See also \book{VCS}

%\section{[[patch]]}
% Larry Wall. 8500 LOC.

%******************************************************************************
\chapter{[[ed]]}
%******************************************************************************
% See also \book{Editor}

% appendix 1 of "Unix programming environment"

%******************************************************************************
%\chapter{[[awk]]}
%******************************************************************************

%******************************************************************************
\chapter{Processes}
%******************************************************************************
% also useful for the programmer

\section{[[ps]]}

\section{[[pstree]]}

%******************************************************************************
\chapter{Archiving}
%******************************************************************************

% also useful for the programmer

\section{[[tar]]}

%for tar:
% ocaml-tar in mirage

\section{[[gzip]]}
% http://jvns.ca/blog/2013/10/16/day-11-how-does-gzip-work/


%******************************************************************************
\chapter{Time}
%******************************************************************************

\section{[[date]]}

%bugfix: this used to segfault in goken because ctime() has
% different sig in plan9 vs unix, so had to use plan9port ctime.c

<<global flags(date.c)>>=
// UTC time, which is mostly the same than GMT
bool uflg;
// number of seconds since the (UNIX) epoch, 1/1/1970:00:00
bool nflg;
@

% strtoul again
<<function [[main]](date.c)>>=
void
main(int argc, char *argv[])
{
    ulong now;

    ARGBEGIN{
    case 'n':   nflg = true; break;
    case 'u':   uflg = true; break;
    default:    fprint(STDERR, "usage: date [-un] [seconds]\n"); exits("usage");
    }ARGEND

    if(argc == 1)
        now = strtoul(*argv, 0, 0);
    else
        now = time(0);

    if(nflg)
        print("%ld\n", now);
    else if(uflg)
        print("%s", asctime(gmtime(now)));
    else
        print("%s", ctime(now));
    
    exits(nil);
}
@

\section{[[cal]]}

%******************************************************************************
\chapter{Pipes}
%******************************************************************************
%alt: Pipe filters

\section{[[tee]]}

% Read from stdin and write on stdout AND on a file (or files).
% Useful for logging a command while also seeing its output
% as  in     <cmd> | tee log.txt

<<global flags(tee.c)>>=
// append mode
bool aflag;
// deprecated
bool uflag;
@

% usually just one file
<<global [[openf]](tee.c)>>=
fdt *openf;
@

<<global [[in]](tee.c)>>=
// read buffer
char in[8192];
@

<<function [[main]](tee.c)>>=
void
main(int argc, char **argv)
{
    int i;
    int r, n;

    ARGBEGIN {
    case 'a':
        aflag = true;
        break;

    case 'i':
        atnotify(intignore, true); // register
        break;

    case 'u':
        uflag = true;
        /* uflag is ignored and undocumented; it's a relic from Unix */
        break;

    default:
        fprint(STDERR, "usage: tee [-ai] [file ...]\n");
        exits("usage");
    } ARGEND

    openf = malloc((1+argc)*sizeof(int));
    if(openf == nil)
        sysfatal("out of memory: %r");

    n = 0;
    while(*argv) {
        if(aflag) {
            openf[n] = open(argv[0], OWRITE);
            if(openf[n] < 0)
                openf[n] = create(argv[0], OWRITE, 0666);
            seek(openf[n], 0L, SEEK__END);
        } else
            openf[n] = create(argv[0], OWRITE, 0666);
        if(openf[n] < 0) {
            fprint(STDERR, "tee: cannot open %s: %r\n", argv[0]);
        } else
            n++;
        argv++;
    }
    openf[n++] = STDOUT;

    for(;;) {
        r = read(STDIN, in, sizeof in);
        if(r <= 0)
            exits(nil);
        for(i=0; i<n; i++)
            write(openf[i], in, r);
    }
}
@

<<function [[intignore]](tee.c)>>=
bool
intignore(void *a, char *msg)
{
    USED(a);
    if(strcmp(msg, "interrupt") == 0)
        return true;
    return false;
}
@

\section{[[sort]]}

%sort. can't do sort foo.txt > foo.txt, hence one option of sort for that
% (mentioned in Unix Readers article)

\section{[[uniq]]}

% remove duplicate. Usually preceded by | sort | uniq in a pipe chain

<<globals uniq.c>>=
int fields  = 0;
int letters = 0;
// 'u' or 'd' or 'c' or 's' (meaning??)
char    mode;
@

<<globals uniq.c>>=
int linec   = 0;
@
<<globals uniq.c>>=
bool uniq;
@

<<globals uniq.c>>=
char    *b1, *b2;
long    bsize = SIZE;
@
<<globals uniq.c>>=
Biobuf  fin;
Biobuf  fout;
@

<<constant [[SIZE]](uniq.c)>>=
#define SIZE    8000
@

% No ARGBEGIN/ARGEND here because ?? non-standard flag management?
% which is why need set argv0 manually because ARGBEGIN is doing it
% and some error function probably rely on this global?
<<function [[main]](uniq.c)>>=
void
main(int argc, char *argv[])
{
    fdt f = STDIN;

    argv0 = argv[0]; // use??
    b1 = malloc(bsize);
    b2 = malloc(bsize);
    while(argc > 1) {
        if(*argv[1] == '-') {
            if(isdigit(argv[1][1]))
                fields = atoi(&argv[1][1]);
            else
                mode = argv[1][1];
            argc--;
            argv++;
            continue;
        }
        if(*argv[1] == '+') {
            letters = atoi(&argv[1][1]);
            argc--;
            argv++;
            continue;
        }
        f = open(argv[1], OREAD);
        if(f < 0)
            sysfatal("cannot open %s", argv[1]);
        break;
    }
    if(argc > 2)
        sysfatal("unexpected argument %s", argv[2]);
    Binit(&fin, f, OREAD);
    Binit(&fout, STDOUT, OWRITE);

    if(gline(b1))
        exits(nil);

    for(;;) {
        linec++;
        if(gline(b2)) {
            pline(b1);
            exits(nil);
        }
        if(!equal(b1, b2)) {
            pline(b1);
            linec = 0;
            do {
                linec++;
                if(gline(b1)) {
                    pline(b2);
                    exits(nil);
                }
            } while(equal(b2, b1));
            pline(b2);
            linec = 0;
        }
    }
}
@

% 'g' for ?? grab?
% return whether was EOF
<<function [[gline]](uniq.c)>>=
bool
gline(char *buf)
{
    int len;
    char *p;

    p = Brdline(&fin, '\n');
    if(p == nil)
        return true;
    len = Blinelen(&fin);
    if(len >= bsize-1)
        sysfatal("line too long");
    memmove(buf, p, len);
    buf[len-1] = '\0';
    return false;
}
@

% 'p' for print line?
<<function [[pline]](uniq.c)>>=
void
pline(char *buf)
{
    switch(mode) {

    case 'u':
        if(uniq) {
            uniq = false;
            return;
        }
        break;

    case 'd':
        if(uniq)
            break;
        return;

    case 'c':
        Bprint(&fout, "%4d ", linec);
    }
    uniq = false;
    Bprint(&fout, "%s\n", buf);
}
@

<<function [[equal]](uniq.c)>>=
bool
equal(char *b1, char *b2)
{
    char c;

    if(fields || letters) {
        b1 = skip(b1);
        b2 = skip(b2);
    }
    for(;;) {
        c = *b1++;
        if(c != *b2++) {
            if(c == '\0' && mode == 's')
                return true;
            return false;
        }
        if(c == '\0') {
            uniq = true;
            return true;
        }
    }
}
@

<<function [[skip]](uniq.c)>>=
char*
skip(char *s)
{
    int nf, nl;

    nf = nl = 0;
    while(nf++ < fields) {
        while(*s == ' ' || *s == '\t')
            s++;
        while(!(*s == ' ' || *s == '\t' || *s == '\0') ) 
            s++;
    }
    while(nl++ < letters && *s != '\0') 
            s++;
    return s;
}
@

\section{[[xargs]]}

% find | grep .c | xargs ls -l
% power of xargs!
% also can do stuff in parallel!! xargs -p 20  grep foo

<<function [[usage]](xargs.c)>>=
void
usage(void)
{
    fprint(STDERR, "usage: xargs [ -n lines ] [ -p procs ] args ...\n");
    exits("usage");
}
@

<<function [[main]](xargs.c)>>=
void
main(int argc, char **argv)
{
    int lines = 10;
    int procs = 1;
    int i, j, run;
    char **nargv, **args, **p;
    static Biobuf bp;
    
    ARGBEGIN {
    case 'n': lines = atoi(EARGF(usage())); break;
    case 'p': procs = atoi(EARGF(usage())); break;
    default: usage();
    } ARGEND;
    if(argc < 1)
        usage();
    
    nargv = malloc(sizeof(char *) * (argc + lines + 1));
    if(nargv == nil)
        sysfatal("malloc: %r");
    memcpy(nargv, argv, sizeof(char *) * argc);
    args = nargv + argc;

    if(Binit(&bp, STDIN, OREAD) < 0)
        sysfatal("Binit: %r");

    //PAD: Blethal(&bp, nil); only in 9front
    atexit(dowait);

    for(j = 0, run = 1; run; j++){
        if(j >= procs)
            waitpid();
        memset(args, 0, sizeof(char *) * (lines + 1));
        for(i = 0; i < lines; i++)
            if((args[i] = Brdstr(&bp, '\n', 1)) == nil){
                if(i == 0)
                    exits(nil);
                run = 0;
                break;
            }

        switch(fork()){
        case ERROR_NEG1:
            sysfatal("fork: %r");
        // child case
        case 0:
            exec(*nargv, nargv);
            // here if ??
            if(**nargv != '/' && strncmp(*nargv, "./", 2) != 0 &&
                    strncmp(*nargv, "../", 3) != 0){
                *nargv = smprint("/bin/%s", *nargv);
                // try again
                exec(*nargv, nargv);
            }
            sysfatal("exec: %r");
        }
        // else, parent
        for(p = args; *p; p++)
            free(*p);
    }
    exits(nil);
}
@

<<function [[dowait]](xargs.c)>>=
void
dowait(void)
{
    while(waitpid() != ERROR_NEG1)
        ;
}
@

\section{paginate: [[p]] ([[more]], [[less]])}
% p for page for paginate

\section{columnate: [[mc]]}
% columnate

%******************************************************************************
%\chapter{Calculators}
%******************************************************************************
%\section{[[bc]]}
%\section{[[dc]]}
%\section{[[hoc]]}

%******************************************************************************
\chapter{Misc}
%******************************************************************************

%\section{[[dirname]]}
% part of posix 

\section{[[basename]]}

<<function [[main]](basename.c)>>=
void
main(int argc, char *argv[])
{
    char *pr;
    int n;
    bool dflag = false;

    if(argc>1 && strcmp(argv[1], "-d") == 0){
        --argc;
        ++argv;
        dflag = true;
    }
    if(argc < 2 || argc > 3){
        fprint(STDERR, "usage: basename [-d] string [suffix]\n");
        exits("usage");
    }
    pr = utfrrune(argv[1], '/');
    if(dflag){
        if(pr){
            *pr = '\0';
            print("%s\n", argv[1]);
            exits(nil);
        }
        // else
        print(".\n");
        exits(nil);
    }
    if(pr)
        pr++;
    else
        pr = argv[1];

    if(argc==3){
        n = strlen(pr)-strlen(argv[2]);
        if(n >= 0 && !strcmp(pr+n, argv[2]))
            pr[n] = '\0';
    }
    print("%s\n", pr);
    exits(nil);
}
@

\section{[[file]]}

\section{[[iconv]]}

\section{[[strings]]}

\section{[[unicode]]}

\section{[[sleep]]}

\section{[[reboot]]}

% part of posix
%\section{[[cmp]]}
%\section{[[cut]]}
%\section{[[comm]]}
%\section{[[join]]}
%\section{[[command]]}

%******************************************************************************
\chapter{Advanced topics}
%******************************************************************************

%list of commands useful for administration:
% - http://cb.vu/unixtoolbox.xhtml

\section{Optimizations}

% how to optimize even simple utilities like 'yes' to have huge throuput:
%https://www.reddit.com/r/unix/comments/6gxduc/how_is_gnu_yes_so_fast/?st=j3v3iw3c&sh=5651ea3c
% maybe better blog post about yes evolution:
%  https://matthias-endler.de/2017/yes/

\section{Internationalization}
% i18n
% actually already good with plan9 and unicode/utf8 (actually
% invented by plan9 people, see hello world paper)


%******************************************************************************
\chapter{Conclusion}
%******************************************************************************
\label{chap:conclusion}

%\ifallcode
#include "Utilities_extra.nw"
%\fi

%******************************************************************************
\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
LOC = Lines Of Code
CLI = Command-Line Interface
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
