\chapter{Extra Code}

\section{[[files/]]}

\subsection{[[files/cat.c]]}

%-------------------------------------------------------------

<<files/cat.c>>=
<<plan9 includes>>

<<function [[cat]]>>
<<function [[main]](cat.c)>>
@

\subsection{[[files/ls.c]]}

%-------------------------------------------------------------

<<files/ls.c>>=
<<plan9 includes>>
#include <bio.h>
#ifdef Unix
#else
//DEAD include? remove the whole ifdef?
#include <fcall.h>
#endif

typedef struct NDir NDir;
<<struct [[NDir]]>>

<<global flags ls.c>>
<<globals ls.c>>

// forward decls
error1  ls(char*, bool);
ord     compar(const NDir*, const NDir*);
char*   asciitime(long);
char*   darwx(long);
void    rwx(long, char*);
void    growto(long);
void    dowidths(Dir*);
void    format(Dir*, char*);
void    output(void);
char*   xcleanname(char*);

<<function [[main]](ls.c)>>

<<function [[ls]]>>

<<function [[output]](ls.c)>>
<<function [[dowidths]](ls.c)>>
<<function [[fileflag]](ls.c)>>
<<function [[format]](ls.c)>>

<<function [[growto]](ls.c)>>
<<function [[compar]](ls.c)>>
<<function [[asciitime]](ls.c)>>
<<function [[xcleanname]](ls.c)>>
@

\subsection{[[files/touch.c]]}

%-------------------------------------------------------------

<<files/touch.c>>=
<<plan9 includes>>

// forward decls
error1 touch(bool, char *);

<<global [[now]](touch.c)>>

<<function [[usage]](touch.c)>>
<<function [[main]](touch.c)>>

<<function [[touch]]>>
@

\subsection{[[files/mkdir.c]]}

%-------------------------------------------------------------

<<files/mkdir.c>>=
<<plan9 includes>>

<<global [[e]](mkdir.c)>>
<<global [[mode]](mkdir.c)>>

<<function [[usage]](mkdir.c)>>
<<function [[makedir]]>>
<<function [[mkdirp]]>>

<<function [[main]](mkdir.c)>>
@

\subsection{[[files/rm.c]]}

%-------------------------------------------------------------

<<files/rm.c>>=
<<plan9 includes>>

<<global [[errbuf]](rm.c)>>
<<global [[ignerr]](rm.c)>>

<<function [[err]](rm.c)>>
<<function [[rmdir]]>>

<<function [[main]](rm.c)>>
@

\subsection{[[files/cp.c]]}

%-------------------------------------------------------------

<<files/cp.c>>=
<<plan9 includes>>

<<constant [[DEFB]](cp.c)>>

<<global [[failed]](cp.c)>>
<<global flags(cp.c)>>

// forward decls
void copy(char *from, char *to, bool todir);
errorneg1 copy1(fdt fdf, fdt fdt, char *from, char *to);

<<function [[main]](cp.c)>>

<<function [[samefile]](cp.c)>>
<<function [[copy]]>>
<<function [[copy1]]>>
@

\subsection{[[files/mv.c]]}

%-------------------------------------------------------------

<<files/mv.c>>=
<<plan9 includes>>

// forward decls
errorneg1 copy1(fdt fdf, fdt fdt, char *from, char *to);
void      hardremove(char *);
errorneg1 mv(char *from, char *todir, char *toelem);
errorneg1 mv1(char *from, Dir *dirb, char *todir, char *toelem);
bool      samefile(char *, char *);
void      split(char *, char **, char **);

<<function [[main]](mv.c)>>

<<function [[mv]]>>
<<function [[mv1]]>>
<<function [[copy1]](mv.c)>>
<<function [[split]](mv.c)>>
<<function [[samefile]](mv.c)>>
<<function [[hardremove]](mv.c)>>
@

\subsection{[[files/chmod.c]]}

%-------------------------------------------------------------

<<files/chmod.c>>=
<<plan9 includes>>

<<macros chmod.c>>

// forward decls
error0 parsemode(char *, ulong *, ulong *);

<<function [[main]](chmod.c)>>

<<function [[parsemode]](chmod.c)>>
@

\subsection{[[files/chgrp.c]]}

%-------------------------------------------------------------

<<files/chgrp.c>>=
<<plan9 includes>>

<<global [[uflag]](chgrp.c)>>

<<function [[main]](chgrp.c)>>
@

\subsection{[[files/mtime.c]]}

%-------------------------------------------------------------

<<files/mtime.c>>=
<<plan9 includes>>

<<function [[usage]](mtime.c)>>
<<function [[main]](mtime.c)>>
@

\subsection{[[files/wc.c]]}

%-------------------------------------------------------------

<<misc/wc.c>>=
/*
 * Count bytes within runes, if it fits in a uvlong, and other things.
 */
<<plan9 includes>>
#include <bio.h>

<<globals wc.c>>

<<enum wc.c>>

<<function [[wc]]>>
<<function [[report]](wc.c)>>

<<function [[main]](wc.c)>>
@


\subsection{[[files/du.c]]}

%-------------------------------------------------------------

<<misc/du.c>>=
/*
 * du - print disk usage
 */
<<plan9 includes>>
#include <str.h>

// forward decls
extern  vlong   du(char*, Dir*);
extern  void    err(char*);
extern  vlong   blkmultiple(vlong);
extern  int seen(Dir*);
extern  int warn(char*);

enum {
    Vkilo = 1024LL,
};

/* rounding up, how many units does amt occupy? */
#define HOWMANY(amt, unit)  (((amt)+(unit)-1) / (unit))
#define ROUNDUP(amt, unit)  (HOWMANY(amt, unit) * (unit))

int aflag;
int autoscale;
int fflag;
int fltflag;
int qflag;
int readflg;
int sflag;
int tflag;
int uflag;

char    *fmt = "%llud\t%q\n";
char    *readbuf;
vlong   blocksize = Vkilo;  /* actually more likely to be 4K or 8K */
vlong   unit;           /* scale factor for output */

static char *pfxes[] = {    /* SI prefixes for units > 1 */
    "",
    "k", "M", "G",
    "T", "P", "E",
    "Z", "Y",
    nil,
};

void
usage(void)
{
    fprint(2, "usage: du [-aefhnqstu] [-b size] [-p si-pfx] [file ...]\n");
    exits("usage");
}

void
printamt(vlong amt, char *name)
{
    if (readflg)
        return;
    if (autoscale) {
        int scale = 0;
        double val = (double)amt/unit;

        while (fabs(val) >= 1024 && scale < nelem(pfxes)-1) {
            scale++;
            val /= 1024;
        }
        print("%.6g%s\t%q\n", val, pfxes[scale], name);
    } else if (fltflag)
        print("%.6g\t%q\n", (double)amt/unit, name);
    else
        print(fmt, HOWMANY(amt, unit), name);
}

void
main(int argc, char *argv[])
{
    int i, scale;
    char *s, *ss, *name;

    //XXX: doquote = needsrcquote;
    quotefmtinstall();

    ARGBEGIN {
    case 'a':   /* all files */
        aflag = 1;
        break;
    case 'b':   /* block size */
        s = ARGF();
        if(s) {
            blocksize = strtoul(s, &ss, 0);
            if(s == ss)
                blocksize = 1;
            while(*ss++ == 'k')
                blocksize *= 1024;
        }
        break;
    case 'e':   /* print in %g notation */
        fltflag = 1;
        break;
    case 'f':   /* don't print warnings */
        fflag = 1;
        break;
    case 'h':   /* similar to -h in bsd but more precise */
        autoscale = 1;
        break;
    case 'n':   /* all files, number of bytes */
        aflag = 1;
        blocksize = 1;
        unit = 1;
        break;
    case 'p':
        s = ARGF();
        if(s) {
            for (scale = 0; pfxes[scale] != nil; scale++)
                if (cistrcmp(s, pfxes[scale]) == 0)
                    break;
            if (pfxes[scale] == nil)
                sysfatal("unknown suffix %s", s);
            unit = 1;
            while (scale-- > 0)
                unit *= Vkilo;
        }
        break;
    case 'q':   /* qid */
        fmt = "%.16llux\t%q\n";
        qflag = 1;
        break;
    case 'r':
        /* undocumented: just read & ignore every block of every file */
        readflg = 1;
        break;
    case 's':   /* only top level */
        sflag = 1;
        break;
    case 't':   /* return modified/accessed time */
        tflag = 1;
        break;
    case 'u':   /* accessed time */
        uflag = 1;
        break;
    default:
        usage();
    } ARGEND

    if (unit == 0)
        if (qflag || tflag || uflag || autoscale)
            unit = 1;
        else
            unit = Vkilo;
    if (blocksize < 1)
        blocksize = 1;

    if (readflg) {
        readbuf = malloc(blocksize);
        if (readbuf == nil)
            sysfatal("out of memory");
    }
    if(argc==0)
        printamt(du(".", dirstat(".")), ".");
    else
        for(i=0; i<argc; i++) {
            name = argv[i];
            printamt(du(name, dirstat(name)), name);
        }
    exits(0);
}

vlong
dirval(Dir *d, vlong size)
{
    if(qflag)
        return d->qid.path;
    else if(tflag) {
        if(uflag)
            return d->atime;
        return d->mtime;
    } else
        return size;
}

void
readfile(char *name)
{
    int n, fd = open(name, OREAD);

    if(fd < 0) {
        warn(name);
        return;
    }
    while ((n = read(fd, readbuf, blocksize)) > 0)
        continue;
    if (n < 0)
        warn(name);
    close(fd);
}

vlong
dufile(char *name, Dir *d)
{
    vlong t = blkmultiple(d->length);

    if(aflag || readflg) {
        String *file = s_copy(name);

        s_append(file, "/");
        s_append(file, d->name);
        if (readflg)
            readfile(s_to_c(file));
        t = dirval(d, t);
        printamt(t, s_to_c(file));
        s_free(file);
    }
    return t;
}

vlong
du(char *name, Dir *dir)
{
    int fd, i, n;
    Dir *buf, *d;
    String *file;
    vlong nk, t;

    if(dir == nil)
        return warn(name);

    if((dir->qid.type&QTDIR) == 0)
        return dirval(dir, blkmultiple(dir->length));

    fd = open(name, OREAD);
    if(fd < 0)
        return warn(name);
    nk = 0;
    while((n=dirread(fd, &buf)) > 0) {
        d = buf;
        for(i = n; i > 0; i--, d++) {
            if((d->qid.type&QTDIR) == 0) {
                nk += dufile(name, d);
                continue;
            }

            if(strcmp(d->name, ".") == 0 ||
               strcmp(d->name, "..") == 0 ||
               /* !readflg && */ seen(d))
                continue;   /* don't get stuck */

            file = s_copy(name);
            s_append(file, "/");
            s_append(file, d->name);

            t = du(s_to_c(file), d);

            nk += t;
            t = dirval(d, t);
            if(!sflag)
                printamt(t, s_to_c(file));
            s_free(file);
        }
        free(buf);
    }
    if(n < 0)
        warn(name);
    close(fd);
    return dirval(dir, nk);
}

#define NCACHE  256 /* must be power of two */

typedef struct
{
    Dir*    cache;
    int n;
    int max;
} Cache;
Cache cache[NCACHE];

int
seen(Dir *dir)
{
    Dir *dp;
    int i;
    Cache *c;

    c = &cache[dir->qid.path&(NCACHE-1)];
    dp = c->cache;
    for(i=0; i<c->n; i++, dp++)
        if(dir->qid.path == dp->qid.path &&
           dir->type == dp->type &&
           dir->dev == dp->dev)
            return 1;
    if(c->n == c->max){
        if (c->max == 0)
            c->max = 8;
        else
            c->max += c->max/2;
        c->cache = realloc(c->cache, c->max*sizeof(Dir));
        if(c->cache == nil)
            err("malloc failure");
    }
    c->cache[c->n++] = *dir;
    return 0;
}

void
err(char *s)
{
    fprint(2, "du: %s: %r\n", s);
    exits(s);
}

int
warn(char *s)
{
    if(fflag == 0)
        fprint(2, "du: %s: %r\n", s);
    return 0;
}

/* round up n to nearest block */
vlong
blkmultiple(vlong n)
{
    if(blocksize == 1)      /* no quantization */
        return n;
    return ROUNDUP(n, blocksize);
}
@

\section{[[byte/]]}

\subsection{[[byte/xd.c]]}

%-------------------------------------------------------------

<<byte/xd.c>>=
<<plan9 includes>>
#include <bio.h>

uchar       odata[16];
uchar       data[32];
int     ndata;
int     nread;
ulong       addr;
int     repeats;
int     swizzle;
int     flush;
int     abase=2;
int     xd(char *, int);
void        xprint(char *, ...);
void        initarg(void), swizz(void);
enum{
    Narg=10,

    TNone=0,
    TAscii,
    TRune,
};
typedef struct Arg Arg;
typedef void fmtfn(char *);
struct Arg
{
    int chartype;       /* TNone, TAscii, TRunes */
    int loglen;     /* 0==1, 1==2, 2==4, 3==8 */
    int base;       /* 0==8, 1==10, 2==16 */
    fmtfn   *fn;        /* function to call with data */
    char    *afmt;      /* format to use to print address */
    char    *fmt;       /* format to use to print data */
}arg[Narg];
int narg;

fmtfn   fmt0, fmt1, fmt2, fmt3, fmtc, fmtr;
fmtfn *fmt[4] = {
    fmt0,
    fmt1,
    fmt2,
    fmt3
};

char *dfmt[4][3] = {
    " %.3uo",   " %.3ud",   " %.2ux",
    " %.6uo",   " %.5ud",   " %.4ux",
    " %.11luo", " %.10lud", " %.8lux",
    " %.22lluo",    " %.20llud",    " %.16llux",
};

char *cfmt[3][3] = {
    "   %c",    "   %c",    "  %c",
    " %.3s",    " %.3s",    " %.2s",
    " %.3uo",   " %.3ud",   " %.2ux",
};

char *rfmt[1][1] = {
    " %2.2C",
};

char *afmt[2][3] = {
    "%.7luo ",  "%.7lud ",  "%.7lux ",
    "%7luo ",   "%7lud ",   "%7lux ",
};

Biobuf  bin;
Biobuf  bout;

void
main(int argc, char *argv[])
{
    int i, err;
    Arg *ap;

    Binit(&bout, 1, OWRITE);
    err = 0;
    ap = 0;
    while(argc>1 && argv[1][0]=='-' && argv[1][1]){
        --argc;
        argv++;
        argv[0]++;
        if(argv[0][0] == 'r'){
            repeats = 1;
            if(argv[0][1])
                goto Usage;
            continue;
        }
        if(argv[0][0] == 's'){
            swizzle = 1;
            if(argv[0][1])
                goto Usage;
            continue;
        }
        if(argv[0][0] == 'u'){
            flush = 1;
            if(argv[0][1])
                goto Usage;
            continue;
        }
        if(argv[0][0] == 'a'){
            argv[0]++;
            switch(argv[0][0]){
            case 'o':
                abase = 0;
                break;
            case 'd':
                abase = 1;
                break;
            case 'x':
                abase = 2;
                break;
            default:
                goto Usage;
            }
            if(argv[0][1])
                goto Usage;
            continue;
        }
        ap = &arg[narg];
        initarg();
        while(argv[0][0]){
            switch(argv[0][0]){
            case 'c':
                ap->chartype = TAscii;
                ap->loglen = 0;
                if(argv[0][1] || argv[0][-1]!='-')
                    goto Usage;
                break;
            case 'R':
                ap->chartype = TRune;
                ap->loglen = 0;
                if(argv[0][1] || argv[0][-1]!='-')
                    goto Usage;
                break;
            case 'o':
                ap->base = 0;
                break;
            case 'd':
                ap->base = 1;
                break;
            case 'x':
                ap->base = 2;
                break;
            case 'b':
            case '1':
                ap->loglen = 0;
                break;
            case 'w':
            case '2':
                ap->loglen = 1;
                break;
            case 'l':
            case '4':
                ap->loglen = 2;
                break;
            case 'v':
            case '8':
                ap->loglen = 3;
                break;
            default:
            Usage:
   fprint(2, "usage: xd [-u] [-r] [-s] [-a{odx}] [-c|{b1w2l4v8}{odx}] ... file ...\n");
                exits("usage");
            }
            argv[0]++;
        }
        if(ap->chartype == TRune)
            ap->fn = fmtr;
        else if(ap->chartype == TAscii)
            ap->fn = fmtc;
        else
            ap->fn = fmt[ap->loglen];
        ap->fmt = dfmt[ap->loglen][ap->base];
        ap->afmt = afmt[ap>arg][abase];
    }
    if(narg == 0)
        initarg();
    if(argc == 1)
        err = xd(0, 0);
    else if(argc == 2)
        err = xd(argv[1], 0);
    else for(i=1; i<argc; i++)
        err |= xd(argv[i], 1);
    exits(err? "error" : 0);
}

void
initarg(void)
{
    Arg *ap;

    ap = &arg[narg++];
    if(narg >= Narg){
        fprint(2, "xd: too many formats (max %d)\n", Narg);
        exits("usage");
    }
    ap->chartype = TNone;
    ap->loglen = 2;
    ap->base = 2;
    ap->fn = fmt2;
    ap->fmt = dfmt[ap->loglen][ap->base];
    ap->afmt = afmt[narg>1][abase];
}

int
xd(char *name, int title)
{
    int fd;
    int i, star, nsee, nleft;
    Arg *ap;
    Biobuf *bp;

    fd = 0;
    if(name){
        bp = Bopen(name, OREAD);
        if(bp == 0){
            fprint(2, "xd: can't open %s\n", name);
            return 1;
        }
    }else{
        bp = &bin;
        Binit(bp, fd, OREAD);
    }
    if(title)
        xprint("%s\n", name);
    addr = 0;
    star = 0;
    nsee = 16;
    nleft = 0;
    /* read 32 but see only 16 so that runes are happy */
    while((ndata=Bread(bp, data + nleft, 32 - nleft)) >= 0){
        ndata += nleft;
        nleft = 0;
        nread = ndata;
        if(ndata>nsee)
            ndata = nsee;
        else if(ndata<nsee)
            for(i=ndata; i<nsee; i++)
                data[i] = 0;
        if(swizzle)
            swizz();
        if(ndata==nsee && repeats){
            if(addr>0 && data[0]==odata[0]){
                for(i=1; i<nsee; i++)
                    if(data[i] != odata[i])
                        break;
                if(i == nsee){
                    addr += nsee;
                    if(star == 0){
                        star++;
                        xprint("*\n", 0);
                    }
                    continue;
                }
            }
            for(i=0; i<nsee; i++)
                odata[i] = data[i];
            star = 0;
        }
        for(ap=arg; ap<&arg[narg]; ap++){
            xprint(ap->afmt, addr);
            (*ap->fn)(ap->fmt);
            xprint("\n", 0);
            if(flush)
                Bflush(&bout);
        }
        addr += ndata;
        if(ndata<nsee){
            xprint(afmt[0][abase], addr);
            xprint("\n", 0);
            if(flush)
                Bflush(&bout);
            break;
        }
        if(nread>nsee){
            nleft = nread - nsee;
            memmove(data, data + nsee, nleft);
        }
    }
    Bterm(bp);
    return 0;
}

void
swizz(void)
{
    uchar *p, *q;
    int i;
    uchar swdata[16];

    p = data;
    q = swdata;
    for(i=0; i<16; i++)
        *q++ = *p++;
    p = data;
    q = swdata;
    for(i=0; i<4; i++){
        p[0] = q[3];
        p[1] = q[2];
        p[2] = q[1];
        p[3] = q[0];
        p += 4;
        q += 4;
    }
}

void
fmt0(char *f)
{
    int i;
    for(i=0; i<ndata; i++)
        xprint(f, data[i]);
}

void
fmt1(char *f)
{
    int i;
    for(i=0; i<ndata; i+=sizeof(ushort))
        xprint(f, (data[i]<<8)|data[i+1]);
}

void
fmt2(char *f)
{
    int i;
    for(i=0; i<ndata; i+=sizeof(ulong))
        xprint(f, (data[i]<<24)|(data[i+1]<<16)|(data[i+2]<<8)|data[i+3]);
}

void
fmt3(char *f)
{
    int i;
    uvlong v;

    for(i=0; i<ndata; i+=sizeof(uvlong)){
        v = (data[i]<<24)|(data[i+1]<<16)|(data[i+2]<<8)|data[i+3];
        v <<= 32;
        v |= (data[i+4]<<24)|(data[i+1+4]<<16)|(data[i+2+4]<<8)|data[i+3+4];
        if(Bprint(&bout, f, v)<0){
            fprint(2, "xd: i/o error\n");
            exits("i/o error");
        }
    }
}

void
onefmtc(uchar c)
{
    switch(c){
    case '\t':
        xprint(cfmt[1][2], "\\t");
        break;
    case '\r':
        xprint(cfmt[1][2], "\\r");
        break;
    case '\n':
        xprint(cfmt[1][2], "\\n");
        break;
    case '\b':
        xprint(cfmt[1][2], "\\b");
        break;
    default:
        if(c>=0x7F || ' '>c)
            xprint(cfmt[2][2], c);
        else
            xprint(cfmt[0][2], c);
        break;
    }
}

void
fmtc(char *f)
{
    int i;

    USED(f);
    for(i=0; i<ndata; i++)
        onefmtc(data[i]);
}

void
fmtr(char *f)
{
    int i, w, cw;
    Rune r;
    static int nstart;

    USED(f);
    if(nstart)  
        xprint("%*c", 3*nstart, ' ');
    for(i=nstart; i<ndata; )
        if(data[i] < Runeself)
            onefmtc(data[i++]);
        else{
            w = chartorune(&r, (char *)data+i);
            if(w == 1 || i + w>nread)
                onefmtc(data[i++]);
            else{
                cw = w;
                if(i + w>ndata)
                    cw = ndata - i;
                xprint(rfmt[0][0], r);  
                xprint("%*c", 3*cw-3, ' ');
                i += w;
            }
        }
    if(i > ndata)
        nstart = i - ndata;
    else
        nstart = 0;
}

void
xprint(char *fmt, ...)
{
    va_list arglist;

    va_start(arglist, fmt);
    if(Bvprint(&bout, fmt, arglist)<0){
        fprint(2, "xd: i/o error\n");
        exits("i/o error");
    }
    va_end(arglist);
}
@

\subsection{[[byte/split.c]]}

%-------------------------------------------------------------

<<byte/split.c>>=
<<plan9 includes>>
#include <bio.h>
#include <regexp.h>

<<globals split.c>>

// forward decls
extern bool nextfile(void);
extern int matchfile(Resub*);
extern void openf(void);
extern char *fold(char*,int);
extern void usage(void);
extern void badexp(void);

<<function [[main]](split.c)>>

<<function [[nextfile]](split.c)>>
<<function [[matchfile]](split.c)>>
<<function [[openf]](split.c)>>
<<function [[fold]](split.c)>>
<<function [[usage]](split.c)>>
<<function [[badexp]](split.c)>>
@

\subsection{[[byte/dd.c]]}

%-------------------------------------------------------------

<<byte/dd.c>>=
<<plan9 includes>>

#define BIG ((1UL<<31)-1)
#define VBIG    ((1ULL<<63)-1)
#define LCASE   (1<<0)
#define UCASE   (1<<1)
#define SWAB    (1<<2)
#define NERR    (1<<3)
#define SYNC    (1<<4)

int cflag;
int fflag;

char    *string;
char    *ifile;
char    *ofile;
char    *ibuf;
char    *obuf;

vlong   skip;
vlong   oseekn;
vlong   iseekn;
vlong   oseekb;
vlong   iseekb;
vlong   count;

long    files   = 1;
long    ibs = 512;
long    obs = 512;
long    bs;
long    cbs;
long    ibc;
long    obc;
long    cbc;
long    nifr;
long    nipr;
long    nofr;
long    nopr;
long    ntrunc;

int dotrunc = 1;
int ibf;
int obf;

char    *op;
int nspace;

uchar   etoa[256];
uchar   atoe[256];
uchar   atoibm[256];

int quiet;

void    flsh(void);
int match(char *s);
vlong   number(vlong big);
void    cnull(int cc);
void    null(int c);
void    ascii(int cc);
void    unblock(int cc);
void    ebcdic(int cc);
void    ibm(int cc);
void    block(int cc);
void    term(char*);
void    stats(void);

#define iskey(s)    ((key[0] == '-') && (strcmp(key+1, s) == 0))

int
main(int argc, char *argv[])
{
    void (*conv)(int);
    char *ip;
    char *key;
    int a, c;

    conv = null;
    for(c=1; c<argc; c++) {
        key = argv[c++];
        if(c >= argc){
            fprint(2, "dd: arg %s needs a value\n", key);
            exits("arg");
        }
        string = argv[c];
        if(iskey("ibs")) {
            ibs = number(BIG);
            continue;
        }
        if(iskey("obs")) {
            obs = number(BIG);
            continue;
        }
        if(iskey("cbs")) {
            cbs = number(BIG);
            continue;
        }
        if(iskey("bs")) {
            bs = number(BIG);
            continue;
        }
        if(iskey("if")) {
            ifile = string;
            continue;
        }
        if(iskey("of")) {
            ofile = string;
            continue;
        }
        if(iskey("trunc")) {
            dotrunc = number(BIG);
            continue;
        }
        if(iskey("quiet")) {
            quiet = number(BIG);
            continue;
        }
        if(iskey("skip")) {
            skip = number(VBIG);
            continue;
        }
        if(iskey("seek") || iskey("oseek")) {
            oseekn = number(VBIG);
            continue;
        }
        if(iskey("iseek")) {
            iseekn = number(VBIG);
            continue;
        }
        if(iskey("iseekb")) {
            iseekb = number(VBIG);
            continue;
        }
        if(iskey("oseekb")) {
            oseekb = number(VBIG);
            continue;
        }
        if(iskey("count")) {
            count = number(VBIG);
            continue;
        }
        if(iskey("files")) {
            files = number(BIG);
            continue;
        }
        if(iskey("conv")) {
        cloop:
            if(match(","))
                goto cloop;
            if(*string == '\0')
                continue;
            if(match("ebcdic")) {
                conv = ebcdic;
                goto cloop;
            }
            if(match("ibm")) {
                conv = ibm;
                goto cloop;
            }
            if(match("ascii")) {
                conv = ascii;
                goto cloop;
            }
            if(match("block")) {
                conv = block;
                goto cloop;
            }
            if(match("unblock")) {
                conv = unblock;
                goto cloop;
            }
            if(match("lcase")) {
                cflag |= LCASE;
                goto cloop;
            }
            if(match("ucase")) {
                cflag |= UCASE;
                goto cloop;
            }
            if(match("swab")) {
                cflag |= SWAB;
                goto cloop;
            }
            if(match("noerror")) {
                cflag |= NERR;
                goto cloop;
            }
            if(match("sync")) {
                cflag |= SYNC;
                goto cloop;
            }
            fprint(2, "dd: bad conv %s\n", argv[c]);
            exits("arg");
        }
        fprint(2, "dd: bad arg: %s\n", key);
        exits("arg");
    }
    if(conv == null && cflag&(LCASE|UCASE))
        conv = cnull;
    if(ifile)
        ibf = open(ifile, 0);
    else
        ibf = dup(0, -1);
    if(ibf < 0) {
        fprint(2, "dd: open %s: %r\n", ifile);
        exits("open");
    }
    if(ofile){
        if(dotrunc)
            obf = create(ofile, 1, 0664);
        else
            obf = open(ofile, 1);
        if(obf < 0) {
            fprint(2, "dd: create %s: %r\n", ofile);
            exits("create");
        }
    }else{
        obf = dup(1, -1);
        if(obf < 0) {
            fprint(2, "dd: can't dup file descriptor: %s: %r\n", ofile);
            exits("dup");
        }
    }
    if(bs)
        ibs = obs = bs;
    if(ibs == obs && conv == null)
        fflag++;
    if(ibs == 0 || obs == 0) {
        fprint(2, "dd: counts: cannot be zero\n");
        exits("counts");
    }
    ibuf = sbrk(ibs);
    if(fflag)
        obuf = ibuf;
    else
        obuf = sbrk(obs);
    sbrk(64);   /* For good measure */
    if(ibuf == (char *)-1 || obuf == (char *)-1) {
        fprint(2, "dd: not enough memory: %r\n");
        exits("memory");
    }
    ibc = 0;
    obc = 0;
    cbc = 0;
    op = obuf;

/*
    if(signal(SIGINT, SIG_IGN) != SIG_IGN)
        signal(SIGINT, term);
*/
    seek(obf, obs*oseekn, 1);
    seek(ibf, ibs*iseekn, 1);
    if(iseekb)
        seek(ibf, iseekb, 0);
    if(oseekb)
        seek(obf, oseekb, 0);
    while(skip) {
        read(ibf, ibuf, ibs);
        skip--;
    }

    ip = 0;
loop:
    if(ibc-- == 0) {
        ibc = 0;
        if(count==0 || nifr+nipr!=count) {
            if(cflag&(NERR|SYNC))
            for(ip=ibuf+ibs; ip>ibuf;)
                *--ip = 0;
            ibc = read(ibf, ibuf, ibs);
        }
        if(ibc == -1) {
            perror("read");
            if((cflag&NERR) == 0) {
                flsh();
                term("errors");
            }
            ibc = 0;
            for(c=0; c<ibs; c++)
                if(ibuf[c] != 0)
                    ibc = c+1;
            seek(ibf, ibs, 1);
            stats();
        }else if(ibc == 0 && --files<=0) {
            flsh();
            term(nil);
        }
        if(ibc != ibs) {
            nipr++;
            if(cflag&SYNC)
                ibc = ibs;
        } else
            nifr++;
        ip = ibuf;
        c = (ibc>>1) & ~1;
        if(cflag&SWAB && c)
        do {
            a = *ip++;
            ip[-1] = *ip;
            *ip++ = a;
        } while(--c);
        ip = ibuf;
        if(fflag) {
            obc = ibc;
            flsh();
            ibc = 0;
        }
        goto loop;
    }
    c = 0;
    c |= *ip++;
    c &= 0377;
    (*conv)(c);
    goto loop;
}

void
flsh(void)
{
    int c;

    if(obc) {
        /* don't perror dregs of previous errors on a short write */
        werrstr("");
        c = write(obf, obuf, obc);
        if(c != obc) {
            if(c > 0)
                ++nopr;
            perror("write");
            term("errors");
        }
        if(obc == obs)
            nofr++;
        else
            nopr++;
        obc = 0;
    }
}

int
match(char *s)
{
    char *cs;

    cs = string;
    while(*cs++ == *s)
        if(*s++ == '\0')
            goto true;
    if(*s != '\0')
        return 0;

true:
    cs--;
    string = cs;
    return 1;
}

vlong
number(vlong big)
{
    char *cs;
    uvlong n;

    cs = string;
    n = 0;
    while(*cs >= '0' && *cs <= '9')
        n = n*10 + *cs++ - '0';
    for(;;)
    switch(*cs++) {

    case 'k':
        n *= 1024;
        continue;

    case 'b':
        n *= 512;
        continue;

/*  case '*':*/
    case 'x':
        string = cs;
        n *= number(VBIG);

    case '\0':
        if(n > big) {
            fprint(2, "dd: argument %llud out of range\n", n);
            exits("range");
        }
        return n;
    }
    /* never gets here */
}

void
cnull(int cc)
{
    int c;

    c = cc;
    if((cflag&UCASE) && c>='a' && c<='z')
        c += 'A'-'a';
    if((cflag&LCASE) && c>='A' && c<='Z')
        c += 'a'-'A';
    null(c);
}

void
null(int c)
{

    *op = c;
    op++;
    if(++obc >= obs) {
        flsh();
        op = obuf;
    }
}

void
ascii(int cc)
{
    int c;

    c = etoa[cc];
    if(cbs == 0) {
        cnull(c);
        return;
    }
    if(c == ' ') {
        nspace++;
        goto out;
    }
    while(nspace > 0) {
        null(' ');
        nspace--;
    }
    cnull(c);

out:
    if(++cbc >= cbs) {
        null('\n');
        cbc = 0;
        nspace = 0;
    }
}

void
unblock(int cc)
{
    int c;

    c = cc & 0377;
    if(cbs == 0) {
        cnull(c);
        return;
    }
    if(c == ' ') {
        nspace++;
        goto out;
    }
    while(nspace > 0) {
        null(' ');
        nspace--;
    }
    cnull(c);

out:
    if(++cbc >= cbs) {
        null('\n');
        cbc = 0;
        nspace = 0;
    }
}

void
ebcdic(int cc)
{
    int c;

    c = cc;
    if(cflag&UCASE && c>='a' && c<='z')
        c += 'A'-'a';
    if(cflag&LCASE && c>='A' && c<='Z')
        c += 'a'-'A';
    c = atoe[c];
    if(cbs == 0) {
        null(c);
        return;
    }
    if(cc == '\n') {
        while(cbc < cbs) {
            null(atoe[' ']);
            cbc++;
        }
        cbc = 0;
        return;
    }
    if(cbc == cbs)
        ntrunc++;
    cbc++;
    if(cbc <= cbs)
        null(c);
}

void
ibm(int cc)
{
    int c;

    c = cc;
    if(cflag&UCASE && c>='a' && c<='z')
        c += 'A'-'a';
    if(cflag&LCASE && c>='A' && c<='Z')
        c += 'a'-'A';
    c = atoibm[c] & 0377;
    if(cbs == 0) {
        null(c);
        return;
    }
    if(cc == '\n') {
        while(cbc < cbs) {
            null(atoibm[' ']);
            cbc++;
        }
        cbc = 0;
        return;
    }
    if(cbc == cbs)
        ntrunc++;
    cbc++;
    if(cbc <= cbs)
        null(c);
}

void
block(int cc)
{
    int c;

    c = cc;
    if(cflag&UCASE && c>='a' && c<='z')
        c += 'A'-'a';
    if(cflag&LCASE && c>='A' && c<='Z')
        c += 'a'-'A';
    c &= 0377;
    if(cbs == 0) {
        null(c);
        return;
    }
    if(cc == '\n') {
        while(cbc < cbs) {
            null(' ');
            cbc++;
        }
        cbc = 0;
        return;
    }
    if(cbc == cbs)
        ntrunc++;
    cbc++;
    if(cbc <= cbs)
        null(c);
}

void
term(char *status)
{
    stats();
    exits(status);
}

void
stats(void)
{
    if(quiet)
        return;
    fprint(2, "%lud+%lud records in\n", nifr, nipr);
    fprint(2, "%lud+%lud records out\n", nofr, nopr);
    if(ntrunc)
        fprint(2, "%lud truncated records\n", ntrunc);
}

uchar   etoa[] =
{
    0000,0001,0002,0003,0234,0011,0206,0177,
    0227,0215,0216,0013,0014,0015,0016,0017,
    0020,0021,0022,0023,0235,0205,0010,0207,
    0030,0031,0222,0217,0034,0035,0036,0037,
    0200,0201,0202,0203,0204,0012,0027,0033,
    0210,0211,0212,0213,0214,0005,0006,0007,
    0220,0221,0026,0223,0224,0225,0226,0004,
    0230,0231,0232,0233,0024,0025,0236,0032,
    0040,0240,0241,0242,0243,0244,0245,0246,
    0247,0250,0133,0056,0074,0050,0053,0041,
    0046,0251,0252,0253,0254,0255,0256,0257,
    0260,0261,0135,0044,0052,0051,0073,0136,
    0055,0057,0262,0263,0264,0265,0266,0267,
    0270,0271,0174,0054,0045,0137,0076,0077,
    0272,0273,0274,0275,0276,0277,0300,0301,
    0302,0140,0072,0043,0100,0047,0075,0042,
    0303,0141,0142,0143,0144,0145,0146,0147,
    0150,0151,0304,0305,0306,0307,0310,0311,
    0312,0152,0153,0154,0155,0156,0157,0160,
    0161,0162,0313,0314,0315,0316,0317,0320,
    0321,0176,0163,0164,0165,0166,0167,0170,
    0171,0172,0322,0323,0324,0325,0326,0327,
    0330,0331,0332,0333,0334,0335,0336,0337,
    0340,0341,0342,0343,0344,0345,0346,0347,
    0173,0101,0102,0103,0104,0105,0106,0107,
    0110,0111,0350,0351,0352,0353,0354,0355,
    0175,0112,0113,0114,0115,0116,0117,0120,
    0121,0122,0356,0357,0360,0361,0362,0363,
    0134,0237,0123,0124,0125,0126,0127,0130,
    0131,0132,0364,0365,0366,0367,0370,0371,
    0060,0061,0062,0063,0064,0065,0066,0067,
    0070,0071,0372,0373,0374,0375,0376,0377,
};
uchar   atoe[] =
{
    0000,0001,0002,0003,0067,0055,0056,0057,
    0026,0005,0045,0013,0014,0015,0016,0017,
    0020,0021,0022,0023,0074,0075,0062,0046,
    0030,0031,0077,0047,0034,0035,0036,0037,
    0100,0117,0177,0173,0133,0154,0120,0175,
    0115,0135,0134,0116,0153,0140,0113,0141,
    0360,0361,0362,0363,0364,0365,0366,0367,
    0370,0371,0172,0136,0114,0176,0156,0157,
    0174,0301,0302,0303,0304,0305,0306,0307,
    0310,0311,0321,0322,0323,0324,0325,0326,
    0327,0330,0331,0342,0343,0344,0345,0346,
    0347,0350,0351,0112,0340,0132,0137,0155,
    0171,0201,0202,0203,0204,0205,0206,0207,
    0210,0211,0221,0222,0223,0224,0225,0226,
    0227,0230,0231,0242,0243,0244,0245,0246,
    0247,0250,0251,0300,0152,0320,0241,0007,
    0040,0041,0042,0043,0044,0025,0006,0027,
    0050,0051,0052,0053,0054,0011,0012,0033,
    0060,0061,0032,0063,0064,0065,0066,0010,
    0070,0071,0072,0073,0004,0024,0076,0341,
    0101,0102,0103,0104,0105,0106,0107,0110,
    0111,0121,0122,0123,0124,0125,0126,0127,
    0130,0131,0142,0143,0144,0145,0146,0147,
    0150,0151,0160,0161,0162,0163,0164,0165,
    0166,0167,0170,0200,0212,0213,0214,0215,
    0216,0217,0220,0232,0233,0234,0235,0236,
    0237,0240,0252,0253,0254,0255,0256,0257,
    0260,0261,0262,0263,0264,0265,0266,0267,
    0270,0271,0272,0273,0274,0275,0276,0277,
    0312,0313,0314,0315,0316,0317,0332,0333,
    0334,0335,0336,0337,0352,0353,0354,0355,
    0356,0357,0372,0373,0374,0375,0376,0377,
};
uchar   atoibm[] =
{
    0000,0001,0002,0003,0067,0055,0056,0057,
    0026,0005,0045,0013,0014,0015,0016,0017,
    0020,0021,0022,0023,0074,0075,0062,0046,
    0030,0031,0077,0047,0034,0035,0036,0037,
    0100,0132,0177,0173,0133,0154,0120,0175,
    0115,0135,0134,0116,0153,0140,0113,0141,
    0360,0361,0362,0363,0364,0365,0366,0367,
    0370,0371,0172,0136,0114,0176,0156,0157,
    0174,0301,0302,0303,0304,0305,0306,0307,
    0310,0311,0321,0322,0323,0324,0325,0326,
    0327,0330,0331,0342,0343,0344,0345,0346,
    0347,0350,0351,0255,0340,0275,0137,0155,
    0171,0201,0202,0203,0204,0205,0206,0207,
    0210,0211,0221,0222,0223,0224,0225,0226,
    0227,0230,0231,0242,0243,0244,0245,0246,
    0247,0250,0251,0300,0117,0320,0241,0007,
    0040,0041,0042,0043,0044,0025,0006,0027,
    0050,0051,0052,0053,0054,0011,0012,0033,
    0060,0061,0032,0063,0064,0065,0066,0010,
    0070,0071,0072,0073,0004,0024,0076,0341,
    0101,0102,0103,0104,0105,0106,0107,0110,
    0111,0121,0122,0123,0124,0125,0126,0127,
    0130,0131,0142,0143,0144,0145,0146,0147,
    0150,0151,0160,0161,0162,0163,0164,0165,
    0166,0167,0170,0200,0212,0213,0214,0215,
    0216,0217,0220,0232,0233,0234,0235,0236,
    0237,0240,0252,0253,0254,0255,0256,0257,
    0260,0261,0262,0263,0264,0265,0266,0267,
    0270,0271,0272,0273,0274,0275,0276,0277,
    0312,0313,0314,0315,0316,0317,0332,0333,
    0334,0335,0336,0337,0352,0353,0354,0355,
    0356,0357,0372,0373,0374,0375,0376,0377,
};
@

\section{[[compare/]]}

\subsection{[[compare/cmp.c]]}

%-------------------------------------------------------------

<<compare/cmp.c>>=
<<plan9 includes>>
#include <ctype.h>

<<constant [[BUF]](cmp.c)>>

<<global flags (cmp.c)>>

// forward decl
static void usage(void);

<<function [[seekoff]](cmp.c)>>

<<function [[main]](cmp.c)>>

<<function [[usage]](cmp.c)>>
@

\subsection{[[compare/comm.c]]}

%-------------------------------------------------------------

<<compare/comm.c>>=
<<plan9 includes>>
#include <bio.h>

<<constant [[LB]](comm.c)>>
<<global flags comm.c>>
<<globals comm.c>>

// forward decls
Biobuf* openfil(char*);
int     rd(Biobuf*, char*);
void    wr(char*, int);
void    copy(Biobuf*, char*, int);
int     compare(char*, char*);

<<function [[main]](comm.c)>>

<<function [[rd]](comm.c)>>
<<function [[wr]](comm.c)>>
<<function [[copy]](comm.c)>>
<<function [[compare]](comm.c)>>
<<function [[openfil]](comm.c)>>
@

\section{[[pipe/]]}

\subsection{[[pipe/mc.c]]}

%-------------------------------------------------------------

<<pipe/mc.c>>=
/*
 * mc - columnate
 *
 * mc[-][-LINEWIDTH][-t][file...]
 *  - causes break on colon
 *  -LINEWIDTH sets width of line in which to columnate(default 80)
 *  -t suppresses expanding multiple blanks into tabs
 *
 */
<<plan9 includes>>
#include    <bio.h>

#ifdef Unix
char* font;
#else
#include    <draw.h>
Font *font;
#endif

<<constants mc.c>>
<<global flags mc.c>>
<<globals mc.c>>

// forward decls
void getwidth(void), readbuf(int), error(char *);
void scanwords(void), columnate(void), morechars(void);
int wordwidth(Rune*, int);
int nexttab(int);

<<function [[main]](mc.c)>>

<<function [[error]](mc.c)>>
<<function [[readbuf]](mc.c)>>
<<function [[scanwords]](mc.c)>>
<<function [[columnate]](mc.c)>>
<<function [[nexttab]](mc.c)>>
<<function [[morechars]](mc.c)>>

#ifdef Unix
<<function [[getwidth]](mc.c)(unix)>>
<<function [[wordwidth]](mc.c)(unix)>>
#else
int
wordwidth(Rune *w, int nw)
{
    if(font)
        return runestringnwidth(font, w, nw);
    return nw;
}

/*
 * These routines discover the width of the display.
 * It takes some work.  If we do the easy calls to the
 * draw library, the screen flashes due to repainting
 * when mc exits.
 */

jmp_buf drawjmp;

void
terror(Display*, char*)
{
    longjmp(drawjmp, 1);
}

void
getwidth(void)
{
    int n, fd;
    char buf[128], *f[10], *p;

    if(access("/dev/acme", OREAD) >= 0){
        if((fd = open("/dev/acme/ctl", OREAD)) < 0)
            return;
        n = read(fd, buf, sizeof buf-1);
        close(fd);
        if(n <= 0)
            return;
        buf[n] = 0;
        n = tokenize(buf, f, nelem(f));
        if(n < 7)
            return;
        if((font = openfont(nil, f[6])) == nil)
            return;
        if(n >= 8)
            tabwidth = atoi(f[7]);
        else
            tabwidth = 4*stringwidth(font, "0");
        mintab = stringwidth(font, "0");
        linewidth = atoi(f[5]);
        tabflag = 1;
        return;
    }

    if((p = getenv("font")) == nil)
        return;
    if((font = openfont(nil, p)) == nil)
        return;
    if((fd = open("/dev/window", OREAD)) < 0){
        font = nil;
        return;
    }
    n = read(fd, buf, 5*12);
    close(fd);
    if(n < 5*12){
        font = nil;
        return;
    }
    buf[n] = 0;
    
    /* window stucture:
        4 bit left edge
        1 bit gap
        12 bit scrollbar
        4 bit gap
        text
        4 bit right edge
    */
    linewidth = atoi(buf+3*12) - atoi(buf+1*12) - (4+1+12+4+4);
    mintab = stringwidth(font, "0");
    if((p = getenv("tabstop")) != nil)
        tabwidth = atoi(p)*stringwidth(font, "0");
    if(tabwidth == 0)
        tabwidth = 4*stringwidth(font, "0");
    tabflag = 1;
}
#endif
@

\subsection{[[pipe/p.c]]}

%-------------------------------------------------------------

<<pipe/p.c>>=
<<plan9 includes>>
#include <bio.h>

<<constant [[DEF]](p.c)>>
<<globals p.c>>

// forward decls
void printfile(fdt);

<<function [[main]](p.c)>>

<<function [[printfile]](p.c)>>
@

\subsection{[[pipe/sort.c]]}

%-------------------------------------------------------------

<<pipe/sort.c>>=
<<plan9 includes>>
#include    <bio.h>

/*
bugs:
    00/ff for end of file can conflict with 00/ff characters
*/

enum
{
    Nline   = 100000,       /* default max number of lines saved in memory */
    Nmerge  = 10,           /* max number of temporary files merged */
    Nfield  = 20,           /* max number of argument fields */

    Bflag   = 1<<0,         /* flags per field */
    B1flag  = 1<<1,

    Dflag   = 1<<2,
    Fflag   = 1<<3,
    Gflag   = 1<<4,
    Iflag   = 1<<5,
    Mflag   = 1<<6,
    Nflag   = 1<<7,
    Rflag   = 1<<8,
    Wflag   = 1<<9,

    NSstart = 0,            /* states for number to key decoding */
    NSsign,
    NSzero,
    NSdigit,
    NSpoint,
    NSfract,
    NSzerofract,
    NSexp,
    NSexpsign,
    NSexpdigit,
};

typedef struct  Line    Line;
typedef struct  Key Key;
typedef struct  Merge   Merge;
typedef struct  Field   Field;

struct  Line
{
    Key*    key;
    int llen;       /* always >= 1 */
    uchar   line[1];    /* always ends in '\n' */
};

struct  Merge
{
    Key*    key;        /* copy of line->key so (Line*) looks like (Merge*) */
    Line*   line;       /* line at the head of a merged temp file */
    int fd;     /* file descriptor */
    Biobuf  b;      /* iobuf for reading a temp file */
};

struct  Key
{
    int klen;
    uchar   key[1];
};

struct  Field
{
    int beg1;
    int beg2;
    int end1;
    int end2;

    long    flags;
    uchar   mapto[1+255];

    void    (*dokey)(Key*, uchar*, uchar*, Field*);
};

struct args
{
    char*   ofile;
    char*   tname;
    Rune    tabchar;
    char    cflag;
    char    uflag;
    char    vflag;
    int nfield;
    int nfile;
    Field   field[Nfield];

    Line**  linep;
    long    nline;          /* number of lines in this temp file */
    long    lineno;         /* overall ordinal for -s option */
    int ntemp;
    long    mline;          /* max lines per file */
} args;

extern  Rune*   month[12];

void    buildkey(Line*);
void    doargs(int, char*[]);
void    dofield(char*, int*, int*, int, int);
void    dofile(Biobuf*);
void    dokey_(Key*, uchar*, uchar*, Field*);
void    dokey_dfi(Key*, uchar*, uchar*, Field*);
void    dokey_gn(Key*, uchar*, uchar*, Field*);
void    dokey_m(Key*, uchar*, uchar*, Field*);
void    dokey_r(Key*, uchar*, uchar*, Field*);
void    done(char*);
int kcmp(Key*, Key*);
void    makemapd(Field*);
void    makemapm(Field*);
void    mergefiles(int, int, Biobuf*);
void    mergeout(Biobuf*);
void    newfield(void);
Line*   newline(Biobuf*);
void    nomem(void);
void    notifyf(void*, char*);
void    printargs(void);
void    printout(Biobuf*);
void    setfield(int, int);
uchar*  skip(uchar*, int, int, int, int);
void    sort4(void*, ulong);
char*   tempfile(int);
void    tempout(void);
void    lineout(Biobuf*, Line*);

void
main(int argc, char *argv[])
{
    int i, f;
    char *s;
    Biobuf bbuf;

    notify(notifyf);    /**/
    doargs(argc, argv);
    if(args.vflag)
        printargs();

    for(i=1; i<argc; i++) {
        s = argv[i];
        if(s == 0)
            continue;
        if(strcmp(s, "-") == 0) {
            Binit(&bbuf, 0, OREAD);
            dofile(&bbuf);
            Bterm(&bbuf);
            continue;
        }
        f = open(s, OREAD);
        if(f < 0) {
            fprint(2, "sort: open %s: %r\n", s);
            done("open");
        }
        Binit(&bbuf, f, OREAD);
        dofile(&bbuf);
        Bterm(&bbuf);
        close(f);
    }
    if(args.nfile == 0) {
        Binit(&bbuf, 0, OREAD);
        dofile(&bbuf);
        Bterm(&bbuf);
    }
    if(args.cflag)
        done(0);
    if(args.vflag)
        fprint(2, "=========\n");

    f = 1;
    if(args.ofile) {
        f = create(args.ofile, OWRITE, 0666);
        if(f < 0) {
            fprint(2, "sort: create %s: %r\n", args.ofile);
            done("create");
        }
    }

    Binit(&bbuf, f, OWRITE);
    if(args.ntemp) {
        tempout();
        mergeout(&bbuf);
    } else {
        printout(&bbuf);
    }
    Bterm(&bbuf);
    done(0);
}

void
dofile(Biobuf *b)
{
    Line *l, *ol;
    int n;

    if(args.cflag) {
        ol = newline(b);
        if(ol == 0)
            return;
        for(;;) {
            l = newline(b);
            if(l == 0)
                break;
            n = kcmp(ol->key, l->key);
            if(n > 0 || (n == 0 && args.uflag)) {
                fprint(2, "sort: -c file not in sort\n"); /**/
                done("order");
            }
            free(ol->key);
            free(ol);
            ol = l;
        }
        return;
    }

    if(args.linep == 0) {
        args.linep = malloc(args.mline * sizeof(args.linep));
        if(args.linep == 0)
            nomem();
    }
    for(;;) {
        l = newline(b);
        if(l == 0)
            break;
        if(args.nline >= args.mline)
            tempout();
        args.linep[args.nline] = l;
        args.nline++;
        args.lineno++;
    }
}

void
notifyf(void*, char *s)
{

    if(strcmp(s, "interrupt") == 0)
        done(0);
    if(strcmp(s, "hangup") == 0)
        done(0);
    if(strcmp(s, "kill") == 0)
        done(0);
    if(strncmp(s, "sys: write on closed pipe", 25) == 0)
        done(0);
    fprint(2, "sort: note: %s\n", s);
    abort();
}

Line*
newline(Biobuf *b)
{
    Line *l;
    char *p;
    int n, c;

    p = Brdline(b, '\n');
    n = Blinelen(b);
    if(p == 0) {
        if(n == 0)
            return 0;
        l = 0;
        for(n=0;;) {
            if((n & 31) == 0) {
                l = realloc(l, sizeof(Line) +
                    (n+31)*sizeof(l->line[0]));
                if(l == 0)
                    nomem();
            }
            c = Bgetc(b);
            if(c < 0) {
                fprint(2, "sort: newline added\n");
                c = '\n';
            }
            l->line[n++] = c;
            if(c == '\n')
                break;
        }
        l->llen = n;
        buildkey(l);
        return l;
    }
    l = malloc(sizeof(Line) +
        (n-1)*sizeof(l->line[0]));
    if(l == 0)
        nomem();
    l->llen = n;
    memmove(l->line, p, n);
    buildkey(l);
    return l;
}

void
lineout(Biobuf *b, Line *l)
{
    int n, m;

    n = l->llen;
    m = Bwrite(b, l->line, n);
    if(n != m)
        exits("write");
}

void
tempout(void)
{
    long n;
    Line **lp, *l;
    char *tf;
    int f;
    Biobuf tb;

    sort4(args.linep, args.nline);
    tf = tempfile(args.ntemp);
    args.ntemp++;
    f = create(tf, OWRITE, 0666);
    if(f < 0) {
        fprint(2, "sort: create %s: %r\n", tf);
        done("create");
    }

    Binit(&tb, f, OWRITE);
    lp = args.linep;
    for(n=args.nline; n>0; n--) {
        l = *lp++;
        lineout(&tb, l);
        free(l->key);
        free(l);
    }
    args.nline = 0;
    Bterm(&tb);
    close(f);
}

void
done(char *xs)
{
    int i;

    for(i=0; i<args.ntemp; i++)
        remove(tempfile(i));
    exits(xs);
}

void
nomem(void)
{
    fprint(2, "sort: out of memory\n");
    done("mem");
}

char*
tempfile(int n)
{
    static char file[100];
    static uint pid;
    char *dir;

    dir = "/tmp";
    if(args.tname)
        dir = args.tname;
    if(strlen(dir) >= nelem(file)-20) {
        fprint(2, "temp file directory name is too long: %s\n", dir);
        done("tdir");
    }

    if(pid == 0) {
        pid = getpid();
        if(pid == 0) {
            pid = time(0);
            if(pid == 0)
                pid = 1;
        }
    }

    sprint(file, "%s/sort.%.4d.%.4d", dir, pid%10000, n);
    return file;
}

void
mergeout(Biobuf *b)
{
    int n, i, f;
    char *tf;
    Biobuf tb;

    for(i=0; i<args.ntemp; i+=n) {
        n = args.ntemp - i;
        if(n > Nmerge) {
            tf = tempfile(args.ntemp);
            args.ntemp++;
            f = create(tf, OWRITE, 0666);
            if(f < 0) {
                fprint(2, "sort: create %s: %r\n", tf);
                done("create");
            }
            Binit(&tb, f, OWRITE);

            n = Nmerge;
            mergefiles(i, n, &tb);

            Bterm(&tb);
            close(f);
        } else
            mergefiles(i, n, b);
    }
}

void
mergefiles(int t, int n, Biobuf *b)
{
    Merge *m, *mp, **mmp;
    Key *ok;
    Line *l;
    char *tf;
    int i, f, nn;

    mmp = malloc(n*sizeof(*mmp));
    mp = malloc(n*sizeof(*mp));
    if(mmp == 0 || mp == 0)
        nomem();

    nn = 0;
    m = mp;
    for(i=0; i<n; i++,m++) {
        tf = tempfile(t+i);
        f = open(tf, OREAD);
        if(f < 0) {
            fprint(2, "sort: reopen %s: %r\n", tf);
            done("open");
        }
        m->fd = f;
        Binit(&m->b, f, OREAD);
        mmp[nn] = m;

        l = newline(&m->b);
        if(l == 0)
            continue;
        nn++;
        m->line = l;
        m->key = l->key;
    }

    ok = 0;
    for(;;) {
        sort4(mmp, nn);
        m = *mmp;
        if(nn == 0)
            break;
        for(;;) {
            l = m->line;
            if(args.uflag && ok && kcmp(ok, l->key) == 0) {
                free(l->key);
                free(l);
            } else {
                lineout(b, l);
                if(ok)
                    free(ok);
                ok = l->key;
                free(l);
            }

            l = newline(&m->b);
            if(l == 0) {
                nn--;
                mmp[0] = mmp[nn];
                break;
            }
            m->line = l;
            m->key = l->key;
            if(nn > 1 && kcmp(mmp[0]->key, mmp[1]->key) > 0)
                break;
        }
    }
    if(ok)
        free(ok);

    m = mp;
    for(i=0; i<n; i++,m++) {
        Bterm(&m->b);
        close(m->fd);
    }

    free(mp);
    free(mmp);
}

int
kcmp(Key *ka, Key *kb)
{
    int n, m;

    /*
     * set n to length of smaller key
     */
    n = ka->klen;
    m = kb->klen;
    if(n > m)
        n = m;
    return memcmp(ka->key, kb->key, n);
}

void
printout(Biobuf *b)
{
    long n;
    Line **lp, *l;
    Key *ok;

    sort4(args.linep, args.nline);
    lp = args.linep;
    ok = 0;
    for(n=args.nline; n>0; n--) {
        l = *lp++;
        if(args.uflag && ok && kcmp(ok, l->key) == 0)
            continue;
        lineout(b, l);
        ok = l->key;
    }
}

void
setfield(int n, int c)
{
    Field *f;

    f = &args.field[n];
    switch(c) {
    default:
        fprint(2, "sort: unknown option: field.%C\n", c);
        done("option");
    case 'b':   /* skip blanks */
        f->flags |= Bflag;
        break;
    case 'd':   /* directory order */
        f->flags |= Dflag;
        break;
    case 'f':   /* fold case */
        f->flags |= Fflag;
        break;
    case 'g':   /* floating point -n case */
        f->flags |= Gflag;
        break;
    case 'i':   /* ignore non-ascii */
        f->flags |= Iflag;
        break;
    case 'M':   /* month */
        f->flags |= Mflag;
        break;
    case 'n':   /* numbers */
        f->flags |= Nflag;
        break;
    case 'r':   /* reverse */
        f->flags |= Rflag;
        break;
    case 'w':   /* ignore white */
        f->flags |= Wflag;
        break;
    }
}

void
dofield(char *s, int *n1, int *n2, int off1, int off2)
{
    int c, n;

    c = *s++;
    if(c >= '0' && c <= '9') {
        n = 0;
        while(c >= '0' && c <= '9') {
            n = n*10 + (c-'0');
            c = *s++;
        }
        n -= off1;  /* posix committee: rot in hell */
        if(n < 0) {
            fprint(2, "sort: field offset must be positive\n");
            done("option");
        }
        *n1 = n;
    }
    if(c == '.') {
        c = *s++;
        if(c >= '0' && c <= '9') {
            n = 0;
            while(c >= '0' && c <= '9') {
                n = n*10 + (c-'0');
                c = *s++;
            }
            n -= off2;
            if(n < 0) {
                fprint(2, "sort: character offset must be positive\n");
                done("option");
            }
            *n2 = n;
        }
    }
    while(c != 0) {
        setfield(args.nfield, c);
        c = *s++;
    }
}

void
printargs(void)
{
    int i, n;
    Field *f;
    char *prefix;

    fprint(2, "sort");
    for(i=0; i<=args.nfield; i++) {
        f = &args.field[i];
        prefix = " -";
        if(i) {
            n = f->beg1;
            if(n >= 0)
                fprint(2, " +%d", n);
            else
                fprint(2, " +*");
            n = f->beg2;
            if(n >= 0)
                fprint(2, ".%d", n);
            else
                fprint(2, ".*");

            if(f->flags & B1flag)
                fprint(2, "b");

            n = f->end1;
            if(n >= 0)
                fprint(2, " -%d", n);
            else
                fprint(2, " -*");
            n = f->end2;
            if(n >= 0)
                fprint(2, ".%d", n);
            else
                fprint(2, ".*");
            prefix = "";
        }
        if(f->flags & Bflag)
            fprint(2, "%sb", prefix);
        if(f->flags & Dflag)
            fprint(2, "%sd", prefix);
        if(f->flags & Fflag)
            fprint(2, "%sf", prefix);
        if(f->flags & Gflag)
            fprint(2, "%sg", prefix);
        if(f->flags & Iflag)
            fprint(2, "%si", prefix);
        if(f->flags & Mflag)
            fprint(2, "%sM", prefix);
        if(f->flags & Nflag)
            fprint(2, "%sn", prefix);
        if(f->flags & Rflag)
            fprint(2, "%sr", prefix);
        if(f->flags & Wflag)
            fprint(2, "%sw", prefix);
    }
    if(args.cflag)
        fprint(2, " -c");
    if(args.uflag)
        fprint(2, " -u");
    if(args.ofile)
        fprint(2, " -o %s", args.ofile);
    if(args.mline != Nline)
        fprint(2, " -l %ld", args.mline);
    fprint(2, "\n");
}

void
newfield(void)
{
    int n;
    Field *f;

    n = args.nfield + 1;
    if(n >= Nfield) {
        fprint(2, "sort: too many fields specified\n");
        done("option");
    }
    args.nfield = n;
    f = &args.field[n];
    f->beg1 = -1;
    f->beg2 = -1;
    f->end1 = -1;
    f->end2 = -1;
}

void
doargs(int argc, char *argv[])
{
    int i, c, hadplus;
    char *s, *p, *q;
    Field *f;

    hadplus = 0;
    args.mline = Nline;
    for(i=1; i<argc; i++) {
        s = argv[i];
        c = *s++;
        if(c == '-') {
            c = *s;
            if(c == 0)      /* forced end of arg marker */
                break;
            argv[i] = 0;        /* clobber args processed */
            if(c == '.' || (c >= '0' && c <= '9')) {
                if(!hadplus)
                    newfield();
                f = &args.field[args.nfield];
                dofield(s, &f->end1, &f->end2, 0, 0);
                hadplus = 0;
                continue;
            }

            while(c = *s++)
            switch(c) {
            case '-':   /* end of options */
                i = argc;
                continue;
            case 'T':   /* temp directory */
                if(*s == 0) {
                    i++;
                    if(i < argc) {
                        args.tname = argv[i];
                        argv[i] = 0;
                    }
                } else
                    args.tname = s;
                s = strchr(s, 0);
                break;
            case 'o':   /* output file */
                if(*s == 0) {
                    i++;
                    if(i < argc) {
                        args.ofile = argv[i];
                        argv[i] = 0;
                    }
                } else
                    args.ofile = s;
                s = strchr(s, 0);
                break;
            case 'k':   /* posix key (what were they thinking?) */
                p = 0;
                if(*s == 0) {
                    i++;
                    if(i < argc) {
                        p = argv[i];
                        argv[i] = 0;
                    }
                } else
                    p = s;
                s = strchr(s, 0);
                if(p == 0)
                    break;

                newfield();
                q = strchr(p, ',');
                if(q)
                    *q++ = 0;
                f = &args.field[args.nfield];
                dofield(p, &f->beg1, &f->beg2, 1, 1);
                if(f->flags & Bflag) {
                    f->flags |= B1flag;
                    f->flags &= ~Bflag;
                }
                if(q) {
                    dofield(q, &f->end1, &f->end2, 1, 0);
                    if(f->end2 <= 0)
                        f->end1++;
                }
                hadplus = 0;
                break;
            case 't':   /* tab character */
                if(*s == 0) {
                    i++;
                    if(i < argc) {
                        chartorune(&args.tabchar, argv[i]);
                        argv[i] = 0;
                    }
                } else
                    s += chartorune(&args.tabchar, s);
                if(args.tabchar == '\n') {
                    fprint(2, "aw come on, rob\n");
                    done("rob");
                }
                break;
            case 'c':   /* check order */
                args.cflag = 1;
                break;
            case 'u':   /* unique */
                args.uflag = 1;
                break;
            case 'v':   /* debugging noise */
                args.vflag = 1;
                break;
            case 'l':
                if(*s == 0) {
                    i++;
                    if(i < argc) {
                        args.mline = atol(argv[i]);
                        argv[i] = 0;
                    }
                } else
                    args.mline = atol(s);
                s = strchr(s, 0);
                break;

            case 'M':   /* month */
            case 'b':   /* skip blanks */
            case 'd':   /* directory order */
            case 'f':   /* fold case */
            case 'g':   /* floating numbers */
            case 'i':   /* ignore non-ascii */
            case 'n':   /* numbers */
            case 'r':   /* reverse */
            case 'w':   /* ignore white */
                if(args.nfield > 0)
                    fprint(2, "sort: global field set after -k\n");
                setfield(0, c);
                break;
            case 'm':
                /* option m silently ignored but required by posix */
                break;
            default:
                fprint(2, "sort: unknown option: -%C\n", c);
                done("option");
            }
            continue;
        }
        if(c == '+') {
            argv[i] = 0;        /* clobber args processed */
            c = *s;
            if(c == '.' || (c >= '0' && c <= '9')) {
                newfield();
                f = &args.field[args.nfield];
                dofield(s, &f->beg1, &f->beg2, 0, 0);
                if(f->flags & Bflag) {
                    f->flags |= B1flag;
                    f->flags &= ~Bflag;
                }
                hadplus = 1;
                continue;
            }
            fprint(2, "sort: unknown option: +%C\n", c);
            done("option");
        }
        args.nfile++;
    }

    for(i=0; i<=args.nfield; i++) {
        f = &args.field[i];

        /*
         * global options apply to fields that
         * specify no options
         */
        if(f->flags == 0) {
            f->flags = args.field[0].flags;
            if(args.field[0].flags & Bflag)
                f->flags |= B1flag;
        }


        /*
         * build buildkey specification
         */
        switch(f->flags & ~(Bflag|B1flag)) {
        default:
            fprint(2, "sort: illegal combination of flags: %lx\n", f->flags);
            done("option");
        case 0:
            f->dokey = dokey_;
            break;
        case Rflag:
            f->dokey = dokey_r;
            break;
        case Gflag:
        case Nflag:
        case Gflag|Nflag:
        case Gflag|Rflag:
        case Nflag|Rflag:
        case Gflag|Nflag|Rflag:
            f->dokey = dokey_gn;
            break;
        case Mflag:
        case Mflag|Rflag:
            f->dokey = dokey_m;
            makemapm(f);
            break;
        case Dflag:
        case Dflag|Fflag:
        case Dflag|Fflag|Iflag:
        case Dflag|Fflag|Iflag|Rflag:
        case Dflag|Fflag|Iflag|Rflag|Wflag:
        case Dflag|Fflag|Iflag|Wflag:
        case Dflag|Fflag|Rflag:
        case Dflag|Fflag|Rflag|Wflag:
        case Dflag|Fflag|Wflag:
        case Dflag|Iflag:
        case Dflag|Iflag|Rflag:
        case Dflag|Iflag|Rflag|Wflag:
        case Dflag|Iflag|Wflag:
        case Dflag|Rflag:
        case Dflag|Rflag|Wflag:
        case Dflag|Wflag:
        case Fflag:
        case Fflag|Iflag:
        case Fflag|Iflag|Rflag:
        case Fflag|Iflag|Rflag|Wflag:
        case Fflag|Iflag|Wflag:
        case Fflag|Rflag:
        case Fflag|Rflag|Wflag:
        case Fflag|Wflag:
        case Iflag:
        case Iflag|Rflag:
        case Iflag|Rflag|Wflag:
        case Iflag|Wflag:
        case Wflag:
            f->dokey = dokey_dfi;
            makemapd(f);
            break;
        }
    }

    /*
     * random spot checks
     */
    if(args.nfile > 1 && args.cflag) {
        fprint(2, "sort: -c can have at most one input file\n");
        done("option");
    }
    return;
}

uchar*
skip(uchar *l, int n1, int n2, int bflag, int endfield)
{
    int i, c, tc;
    Rune r;

    if(endfield && n1 < 0)
        return 0;

    c = *l++;
    tc = args.tabchar;
    if(tc) {
        if(tc < Runeself) {
            for(i=n1; i>0; i--) {
                while(c != tc) {
                    if(c == '\n')
                        return 0;
                    c = *l++;
                }
                if(!(endfield && i == 1))
                    c = *l++;
            }
        } else {
            l--;
            l += chartorune(&r, (char*)l);
            for(i=n1; i>0; i--) {
                while(r != tc) {
                    if(r == '\n')
                        return 0;
                    l += chartorune(&r, (char*)l);
                }
                if(!(endfield && i == 1))
                    l += chartorune(&r, (char*)l);
            }
            c = r;
        }
    } else {
        for(i=n1; i>0; i--) {
            while(c == ' ' || c == '\t')
                c = *l++;
            while(c != ' ' && c != '\t') {
                if(c == '\n')
                    return 0;
                c = *l++;
            }
        }
    }

    if(bflag)
        while(c == ' ' || c == '\t')
            c = *l++;

    l--;
    for(i=n2; i>0; i--) {
        c = *l;
        if(c < Runeself) {
            if(c == '\n')
                return 0;
            l++;
            continue;
        }
        l += chartorune(&r, (char*)l);
    }
    return l;
}

void
dokey_gn(Key *k, uchar *lp, uchar *lpe, Field *f)
{
    uchar *kp;
    int c, cl, dp;
    int state, nzero, exp, expsign, rflag;

    cl = k->klen + 3;
    kp = k->key + cl;   /* skip place for sign, exponent[2] */

    nzero = 0;      /* number of trailing zeros */
    exp = 0;        /* value of the exponent */
    expsign = 0;        /* sign of the exponent */
    dp = 0x4040;        /* location of decimal point */
    rflag = f->flags&Rflag; /* xor of rflag and - sign */
    state = NSstart;

    for(;; lp++) {
        if(lp >= lpe)
            break;
        c = *lp;

        if(c == ' ' || c == '\t') {
            switch(state) {
            case NSstart:
            case NSsign:
                continue;
            }
            break;
        }
        if(c == '+' || c == '-') {
            switch(state) {
            case NSstart:
                state = NSsign;
                if(c == '-')
                    rflag = !rflag;
                continue;
            case NSexp:
                state = NSexpsign;
                if(c == '-')
                    expsign = 1;
                continue;
            }
            break;
        }
        if(c == '0') {
            switch(state) {
            case NSdigit:
                if(rflag)
                    c = ~c;
                *kp++ = c;
                cl++;
                nzero++;
                dp++;
                state = NSdigit;
                continue;
            case NSfract:
                if(rflag)
                    c = ~c;
                *kp++ = c;
                cl++;
                nzero++;
                state = NSfract;
                continue;
            case NSstart:
            case NSsign:
            case NSzero:
                state = NSzero;
                continue;
            case NSzerofract:
            case NSpoint:
                dp--;
                state = NSzerofract;
                continue;
            case NSexpsign:
            case NSexp:
            case NSexpdigit:
                exp = exp*10 + (c - '0');
                state = NSexpdigit;
                continue;
            }
            break;
        }
        if(c >= '1' && c <= '9') {
            switch(state) {
            case NSzero:
            case NSstart:
            case NSsign:
            case NSdigit:
                if(rflag)
                    c = ~c;
                *kp++ = c;
                cl++;
                nzero = 0;
                dp++;
                state = NSdigit;
                continue;
            case NSzerofract:
            case NSpoint:
            case NSfract:
                if(rflag)
                    c = ~c;
                *kp++ = c;
                cl++;
                nzero = 0;
                state = NSfract;
                continue;
            case NSexpsign:
            case NSexp:
            case NSexpdigit:
                exp = exp*10 + (c - '0');
                state = NSexpdigit;
                continue;
            }
            break;
        }
        if(c == '.') {
            switch(state) {
            case NSstart:
            case NSsign:
                state = NSpoint;
                continue;
            case NSzero:
                state = NSzerofract;
                continue;
            case NSdigit:
                state = NSfract;
                continue;
            }
            break;
        }
        if((f->flags & Gflag) && (c == 'e' || c == 'E')) {
            switch(state) {
            case NSdigit:
            case NSfract:
                state = NSexp;
                continue;
            }
            break;
        }
        break;
    }

    switch(state) {
    /*
     * result is zero
     */
    case NSstart:
    case NSsign:
    case NSzero:
    case NSzerofract:
    case NSpoint:
        kp = k->key + k->klen;
        k->klen += 2;
        kp[0] = 0x20;   /* between + and - */
        kp[1] = 0;
        return;
    /*
     * result has exponent
     */
    case NSexpsign:
    case NSexp:
    case NSexpdigit:
        if(expsign)
            exp = -exp;
        dp += exp;

    /*
     * result is fixed point number
     */
    case NSdigit:
    case NSfract:
        kp -= nzero;
        cl -= nzero;
        break;
    }

    /*
     * end of number
     */
    c = 0;
    if(rflag)
        c = ~c;
    *kp = c;

    /*
     * sign and exponent
     */
    c = 0x30;
    if(rflag) {
        c = 0x10;
        dp = ~dp;
    }
    kp = k->key + k->klen;
    kp[0] = c;
    kp[1] = (dp >> 8);
    kp[2] = dp;
    k->klen = cl+1;
}

void
dokey_m(Key *k, uchar *lp, uchar *lpe, Field *f)
{
    uchar *kp;
    Rune r, place[3];
    int c, cl, pc;
    int rflag;

    rflag = f->flags&Rflag;
    pc = 0;

    cl = k->klen;
    kp = k->key + cl;

    for(;;) {
        /*
         * get the character
         */
        if(lp >= lpe)
            break;
        c = *lp;
        if(c >= Runeself) {
            lp += chartorune(&r, (char*)lp);
            c = r;
        } else
            lp++;

        if(c < nelem(f->mapto)) {
            c = f->mapto[c];
            if(c == 0)
                continue;
        }
        place[pc++] = c;
        if(pc < 3)
            continue;
        for(c=11; c>=0; c--)
            if(memcmp(month[c], place, sizeof(place)) == 0)
                break;
        c += 10;
        if(rflag)
            c = ~c;
        *kp++ = c;
        cl++;
        break;
    }

    c = 0;
    if(rflag)
        c = ~c;
    *kp = c;
    k->klen = cl+1;
}

void
dokey_dfi(Key *k, uchar *lp, uchar *lpe, Field *f)
{
    uchar *kp;
    Rune r;
    int c, cl, n, rflag;

    cl = k->klen;
    kp = k->key + cl;
    rflag = f->flags & Rflag;

    for(;;) {
        /*
         * get the character
         */
        if(lp >= lpe)
            break;
        c = *lp;
        if(c >= Runeself) {
            lp += chartorune(&r, (char*)lp);
            c = r;
        } else
            lp++;

        /*
         * do the various mappings.
         * the common case is handled
         * completely by the table.
         */
        if(c != 0 && c < Runeself) {
            c = f->mapto[c];
            if(c) {
                *kp++ = c;
                cl++;
            }
            continue;
        }

        /*
         * for characters out of range,
         * the table does not do Rflag.
         * ignore is based on mapto[nelem(f->mapto)-1]
         */
        if(c != 0 && c < nelem(f->mapto)) {
            c = f->mapto[c];
            if(c == 0)
                continue;
        } else {
            if(f->mapto[nelem(f->mapto)-1] == 0)
                continue;
            /*
             * consider building maps as necessary
             */
            if(f->flags & Fflag)
                c = tolowerrune(tobaserune(c));
            if(f->flags & Dflag && !isalpharune(c) &&
                !isdigitrune(c) && !isspacerune(c))
                continue;
            if((f->flags & Wflag) && isspacerune(c))
                continue;
        }

        /*
         * put it in the key
         */
        r = c;
        n = runetochar((char*)kp, &r);
        kp += n;
        cl += n;
        if(rflag)
            while(n > 0) {
                kp[-n] = ~kp[-n];
                n--;
            }
    }

    /*
     * end of key
     */
    k->klen = cl+1;
    if(rflag) {
        *kp = ~0;
        return;
    }
    *kp = 0;
}

void
dokey_r(Key *k, uchar *lp, uchar *lpe, Field*)
{
    int cl, n;
    uchar *kp;

    n = lpe - lp;
    if(n < 0)
        n = 0;
    cl = k->klen;
    kp = k->key + cl;
    k->klen = cl+n+1;

    lpe -= 3;
    while(lp < lpe) {
        kp[0] = ~lp[0];
        kp[1] = ~lp[1];
        kp[2] = ~lp[2];
        kp[3] = ~lp[3];
        kp += 4;
        lp += 4;
    }

    lpe += 3;
    while(lp < lpe)
        *kp++ = ~*lp++;
    *kp = ~0;
}

void
dokey_(Key *k, uchar *lp, uchar *lpe, Field*)
{
    int n, cl;
    uchar *kp;

    n = lpe - lp;
    if(n < 0)
        n = 0;
    cl = k->klen;
    kp = k->key + cl;
    k->klen = cl+n+1;
    memmove(kp, lp, n);
    kp[n] = 0;
}

void
buildkey(Line *l)
{
    Key *k;
    uchar *lp, *lpe;
    int ll, kl, cl, i, n;
    Field *f;

    ll = l->llen - 1;
    kl = 0;         /* allocated length */
    cl = 0;         /* current length */
    k = 0;

    for(i=1; i<=args.nfield; i++) {
        f = &args.field[i];
        lp = skip(l->line, f->beg1, f->beg2, f->flags&B1flag, 0);
        if(lp == 0)
            lp = l->line + ll;
        lpe = skip(l->line, f->end1, f->end2, f->flags&Bflag, 1);
        if(lpe == 0)
            lpe = l->line + ll;
        n = (lpe - lp) + 1;
        if(n <= 0)
            n = 1;
        if(cl+(n+4) > kl) {
            kl = cl+(n+4);
            k = realloc(k, sizeof(Key) +
                (kl-1)*sizeof(k->key[0]));
            if(k == 0)
                nomem();
        }
        k->klen = cl;
        (*f->dokey)(k, lp, lpe, f);
        cl = k->klen;
    }

    /*
     * global comparisons
     */
    if(!(args.uflag && cl > 0)) {
        f = &args.field[0];
        if(cl+(ll+4) > kl) {
            kl = cl+(ll+4);
            k = realloc(k, sizeof(Key) +
                (kl-1)*sizeof(k->key[0]));
            if(k == 0)
                nomem();
        }
        k->klen = cl;
        (*f->dokey)(k, l->line, l->line+ll, f);
        cl = k->klen;
    }

    l->key = k;
    k->klen = cl;

    if(args.vflag) {
        if(write(2, l->line, l->llen) != l->llen)
            exits("write");
        for(i=0; i<k->klen; i++) {
            fprint(2, " %.2x", k->key[i]);
            if(k->key[i] == 0x00 || k->key[i] == 0xff)
                fprint(2, "\n");
        }
    }
}

void
makemapm(Field *f)
{
    int i, c;

    for(i=0; i<nelem(f->mapto); i++) {
        c = 1;
        if(i == ' ' || i == '\t')
            c = 0;
        if(i >= 'a' && i <= 'z')
            c = i + ('A' - 'a');
        if(i >= 'A' && i <= 'Z')
            c = i;
        f->mapto[i] = c;
        if(args.vflag) {
            if((i & 15) == 0)
                fprint(2, " ");
            fprint(2, " %.2x", c);
            if((i & 15) == 15)
                fprint(2, "\n");
        }
    }
}

void
makemapd(Field *f)
{
    int i, c;

    for(i=0; i<nelem(f->mapto); i++) {
        c = i;
        if(f->flags & Iflag)
            if(c < 040 || c > 0176)
                c = -1;
        if((f->flags & Wflag) && c >= 0)
            if(c == ' ' || c == '\t')
                c = -1;
        if((f->flags & Dflag) && c >= 0)
            if(!(c == ' ' || c == '\t' ||
                (c >= 'a' && c <= 'z') ||
                (c >= 'A' && c <= 'Z') ||
                (c >= '0' && c <= '9'))){
                if(!isupperrune(c = toupperrune(c)))
                    c = -1;
            }
        if((f->flags & Fflag) && c >= 0)
            c = toupperrune(tobaserune(c));
        if((f->flags & Rflag) && c >= 0 && i > 0 && i < Runeself)
            c = ~c & 0xff;
        if(c < 0)
            c = 0;
        f->mapto[i] = c;
        if(args.vflag) {
            if((i & 15) == 0)
                fprint(2, " ");
            fprint(2, " %.2x", c);
            if((i & 15) == 15)
                fprint(2, "\n");
        }
    }
}

Rune*   month[12] =
{
    L"JAN",
    L"FEB",
    L"MAR",
    L"APR",
    L"MAY",
    L"JUN",
    L"JUL",
    L"AUG",
    L"SEP",
    L"OCT",
    L"NOV",
    L"DEC",
};

/************** radix sort ***********/

enum
{
    Threshold   = 14,
};

void    rsort4(Key***, ulong, int);
void    bsort4(Key***, ulong, int);

void
sort4(void *a, ulong n)
{
    if(n > Threshold)
        rsort4((Key***)a, n, 0);
    else
        bsort4((Key***)a, n, 0);
}

void
rsort4(Key ***a, ulong n, int b)
{
    Key ***ea, ***t, ***u, **t1, **u1, *k;
    Key ***part[257];
    static long count[257];
    long clist[257+257], *cp, *cp1;
    int c, lowc, higc;

    /*
     * pass 1 over all keys,
     * count the number of each key[b].
     * find low count and high count.
     */
    lowc = 256;
    higc = 0;
    ea = a+n;
    for(t=a; t<ea; t++) {
        k = **t;
        n = k->klen;
        if(b >= n) {
            count[256]++;
            continue;
        }
        c = k->key[b];
        n = count[c]++;
        if(n == 0) {
            if(c < lowc)
                lowc = c;
            if(c > higc)
                higc = c;
        }
    }

    /*
     * pass 2 over all counts,
     * put partition pointers in part[c].
     * save compacted indexes and counts
     * in clist[].
     */
    t = a;
    n = count[256];
    clist[0] = n;
    part[256] = t;
    t += n;

    cp1 = clist+1;
    cp = count+lowc;
    for(c=lowc; c<=higc; c++,cp++) {
        n = *cp;
        if(n) {
            cp1[0] = n;
            cp1[1] = c;
            cp1 += 2;
            part[c] = t;
            t += n;
        }
    }
    *cp1 = 0;

    /*
     * pass 3 over all counts.
     * chase lowest pointer in each partition
     * around a permutation until it comes
     * back and is stored where it started.
     * static array, count[], should be
     * reduced to zero entries except maybe
     * count[256].
     */
    for(cp1=clist+1; cp1[0]; cp1+=2) {
        c = cp1[1];
        cp = count+c;
        while(*cp) {
            t1 = *part[c];
            for(;;) {
                k = *t1;
                n = 256;
                if(b < k->klen)
                    n = k->key[b];
                u = part[n]++;
                count[n]--;
                u1 = *u;
                *u = t1;
                if(n == c)
                    break;
                t1 = u1;
            }
        }
    }

    /*
     * pass 4 over all partitions.
     * call recursively.
     */
    b++;
    t = a + clist[0];
    count[256] = 0;
    for(cp1=clist+1; n=cp1[0]; cp1+=2) {
        if(n > Threshold)
            rsort4(t, n, b);
        else
        if(n > 1)
            bsort4(t, n, b);
        t += n;
    }
}

/*
 * bubble sort to pick up
 * the pieces.
 */
void
bsort4(Key ***a, ulong n, int b)
{
    Key ***i, ***j, ***k, ***l, **t;
    Key *ka, *kb;
    int n1, n2;

    l = a+n;
    j = a;

loop:
    i = j;
    j++;
    if(j >= l)
        return;

    ka = **i;
    kb = **j;
    n1 = ka->klen - b;
    n2 = kb->klen - b;
    if(n1 > n2)
        n1 = n2;
    if(n1 <= 0)
        goto loop;
    n2 = ka->key[b] - kb->key[b];
    if(n2 == 0)
        n2 = memcmp(ka->key+b, kb->key+b, n1);
    if(n2 <= 0)
        goto loop;

    for(;;) {
        k = i+1;

        t = *k;
        *k = *i;
        *i = t;

        if(i <= a)
            goto loop;

        i--;
        ka = **i;
        kb = *t;
        n1 = ka->klen - b;
        n2 = kb->klen - b;
        if(n1 > n2)
            n1 = n2;
        if(n1 <= 0)
            goto loop;
        n2 = ka->key[b] - kb->key[b];
        if(n2 == 0)
            n2 = memcmp(ka->key+b, kb->key+b, n1);
        if(n2 <= 0)
            goto loop;
    }
}
@

\subsection{[[pipe/tail.c]]}

%-------------------------------------------------------------

<<pipe/tail.c>>=
<<plan9 includes>>
#include    <ctype.h>
#include    <bio.h>

/*
 * tail command, posix plus v10 option -r.
 * the simple command tail -c, legal in v10, is illegal
 */

long    count;
int anycount;
static int  follow;
int file    = 0;

char*   umsg    = "usage: tail [-n N] [-c N] [-f] [-r] [+-N[bc][fr]] [file]";

Biobuf  bout;
enum
{
    BEG,
    END
} origin = END;
enum
{
    CHARS,
    LINES
} units = LINES;
enum
{
    FWD,
    REV
} dir = FWD;

extern  void    copy(void);
extern  void    fatal(char*);
extern  int getnumber(char*);
extern  void    keep(void);
extern  void    reverse(void);
extern  void    skip(void);
extern  void    suffix(char*);
extern  long    tread(char*, long);
extern  void    trunc_(Dir*, Dir**);
extern  vlong   tseek(vlong, int);
extern  void    twrite(char*, long);
extern  void    usage(void);
static  int isseekable(int fd);

#define JUMP(o,p) tseek(o,p), copy()

void
main(int argc, char **argv)
{
    int seekable, c;

    Binit(&bout, 1, OWRITE);
    for(; argc > 1 && ((c=*argv[1])=='-'||c=='+'); argc--,argv++ ) {
        if(getnumber(argv[1])) {
            suffix(argv[1]);
            continue;
        } else
        if(c == '-')
            switch(argv[1][1]) {
            case 'c':
                units = CHARS;
            case 'n':
                if(getnumber(argv[1]+2))
                    continue;
                else
                if(argc > 2 && getnumber(argv[2])) {
                    argc--, argv++;
                    continue;
                } else
                    usage();
            case 'r':
                dir = REV;
                continue;
            case 'f':
                follow++;
                continue;
            case '-':
                argc--, argv++;
            }
        break;
    }
    if(dir==REV && (units==CHARS || follow || origin==BEG))
        fatal("incompatible options");
    if(!anycount)
        count = dir==REV? ~0UL>>1: 10;
    if(origin==BEG && units==LINES && count>0)
        count--;
    if(argc > 2)
        usage();
    if(argc > 1 && (file=open(argv[1],0)) < 0)
        fatal(argv[1]);
    seekable = isseekable(file);

    if(!seekable && origin==END)
        keep();
    else
    if(!seekable && origin==BEG)
        skip();
    else
    if(units==CHARS && origin==END)
        JUMP(-count, 2);
    else
    if(units==CHARS && origin==BEG)
        JUMP(count, 0);
    else
    if(units==LINES && origin==END)
        reverse();
    else
    if(units==LINES && origin==BEG)
        skip();
    if(follow && seekable)
        for(;;) {
            static Dir *sb0, *sb1;
            trunc_(sb1, &sb0);
            copy();
            trunc_(sb0, &sb1);
            sleep(5000);
        }
    exits(0);
}

void
trunc_(Dir *old, Dir **new)
{
    Dir *d;
    vlong olength;

    d = dirfstat(file);
    if(d == nil)
        return;
    olength = 0;
    if(old)
        olength = old->length;
    if(d->length < olength)
        d->length = tseek(0LL, 0);
    free(*new);
    *new = d;
}

void
suffix(char *s)
{
    while(*s && strchr("0123456789+-", *s))
        s++;
    switch(*s) {
    case 'b':
        if((count *= 1024) < 0)
            fatal("too big");
    case 'c':
        units = CHARS;
    case 'l':
        s++;
    }
    switch(*s) {
    case 'r':
        dir = REV;
        return;
    case 'f':
        follow++;
        return;
    case 0:
        return;
    }
    usage();
}

/*
 * read past head of the file to find tail
 */
void
skip(void)
{
    int i;
    long n;
    char buf[Bsize];
    if(units == CHARS) {
        for( ; count>0; count -=n) {
            n = count<Bsize? count: Bsize;
            if(!(n = tread(buf, n)))
                return;
        }
    } else /*units == LINES*/ {
        n = i = 0;
        while(count > 0) {
            if(!(n = tread(buf, Bsize)))
                return;
            for(i=0; i<n && count>0; i++)
                if(buf[i]=='\n')
                    count--;
        }
        twrite(buf+i, n-i);
    }
    copy();
}

void
copy(void)
{
    long n;
    char buf[Bsize];
    while((n=tread(buf, Bsize)) > 0) {
        twrite(buf, n);
        Bflush(&bout);  /* for FWD on pipe; else harmless */
    }
}

/*
 * read whole file, keeping the tail
 *  complexity is length(file)*length(tail).
 *  could be linear.
 */
void
keep(void)
{
    int len = 0;
    long bufsiz = 0;
    char *buf = 0;
    int j, k, n;

    for(n=1; n;) {
        if(len+Bsize > bufsiz) {
            bufsiz += 2*Bsize;
            if(!(buf = realloc(buf, bufsiz+1)))
                fatal("out of space");
        }
        for(; n && len<bufsiz; len+=n)
            n = tread(buf+len, bufsiz-len);
        if(count >= len)
            continue;
        if(units == CHARS)
            j = len - count;
        else {
            /* units == LINES */
            j = buf[len-1]=='\n'? len-1: len;
            for(k=0; j>0; j--)
                if(buf[j-1] == '\n')
                    if(++k >= count)
                        break;
        }
        memmove(buf, buf+j, len-=j);
    }
    if(dir == REV) {
        if(len>0 && buf[len-1]!='\n')
            buf[len++] = '\n';
        for(j=len-1 ; j>0; j--)
            if(buf[j-1] == '\n') {
                twrite(buf+j, len-j);
                if(--count <= 0)
                    return;
                len = j;
            }
    }
    if(count > 0)
        twrite(buf, len);
}

/*
 * count backward and print tail of file
 */
void
reverse(void)
{
    int first;
    long len = 0;
    long n = 0;
    long bufsiz = 0;
    char *buf = 0;
    vlong pos = tseek(0LL, 2);

    for(first=1; pos>0 && count>0; first=0) {
        n = pos>Bsize? Bsize: (long)pos;
        pos -= n;
        if(len+n > bufsiz) {
            bufsiz += 2*Bsize;
            if(!(buf = realloc(buf, bufsiz+1)))
                fatal("out of space");
        }
        memmove(buf+n, buf, len);
        len += n;
        tseek(pos, 0);
        if(tread(buf, n) != n)
            fatal("length error");
        if(first && buf[len-1]!='\n')
            buf[len++] = '\n';
        for(n=len-1 ; n>0 && count>0; n--)
            if(buf[n-1] == '\n') {
                count--;
                if(dir == REV)
                    twrite(buf+n, len-n);
                len = n;
            }
    }
    if(dir == FWD) {
        if(n)
            tseek(pos+n+1, 0);
        else
            tseek(0, 0);
        copy();
    } else
    if(count > 0)
        twrite(buf, len);
}

vlong
tseek(vlong o, int p)
{
    o = seek(file, o, p);
    if(o == -1)
        fatal("");
    return o;
}

long
tread(char *buf, long n)
{
    int r = read(file, buf, n);
    if(r == -1)
        fatal("");
    return r;
}

void
twrite(char *s, long n)
{
    if(Bwrite(&bout, s, n) != n)
        fatal("");
}

int
getnumber(char *s)
{
    if(*s=='-' || *s=='+')
        s++;
    if(!isdigit(*s))
        return 0;
    if(s[-1] == '+')
        origin = BEG;
    if(anycount++)
        fatal("excess option");
    count = atol(s);

    /* check range of count */
    if(count < 0 || (int)count != count)
        fatal("too big");
    return 1;
}   

void        
fatal(char *s)
{
    char buf[ERRMAX];

    errstr(buf, sizeof buf);
    fprint(2, "tail: %s: %s\n", s, buf);
    exits(s);
}

void
usage(void)
{
    fprint(2, "%s\n", umsg);
    exits("usage");
}

/* return true if seeks work and if the file is > 0 length.
 * this will eventually bite me in the ass if seeking a file
 * is not conservative. - presotto
 */
static int
isseekable(int fd)
{   
    vlong m;

    m = seek(fd, 0, 1);
    if(m < 0)
        return 0;
    return 1;
}
@

\subsection{[[pipe/tee.c]]}

%-------------------------------------------------------------

<<pipe/tee.c>>=
/*
 * tee-- pipe fitting
 */
<<plan9 includes>>

<<global flags(tee.c)>>
<<global [[openf]](tee.c)>>
<<global [[in]](tee.c)>>

// forward decls
bool intignore(void*, char*);

<<function [[main]](tee.c)>>

<<function [[intignore]](tee.c)>>
@

\subsection{[[pipe/uniq.c]]}

%-------------------------------------------------------------

<<pipe/uniq.c>>=
/*
 * Deal with duplicated lines in a file
 */
<<plan9 includes>>
#include <bio.h>
#include <ctype.h>

<<constant [[SIZE]](uniq.c)>>

<<globals uniq.c>>

// forward decls
bool   gline(char *buf);
void  pline(char *buf);
bool   equal(char *b1, char *b2);
char* skip(char *s);

<<function [[main]](uniq.c)>>

<<function [[gline]](uniq.c)>>
<<function [[pline]](uniq.c)>>
<<function [[equal]](uniq.c)>>
<<function [[skip]](uniq.c)>>
@

\subsection{[[pipe/xargs.c]]}

%-------------------------------------------------------------

<<pipe/xargs.c>>=
<<plan9 includes>>
#include <bio.h>

<<function [[usage]](xargs.c)>>
<<function [[dowait]](xargs.c)>>

<<function [[main]](xargs.c)>>
@


\section{[[time/]]}

\subsection{[[time/date.c]]}

%-------------------------------------------------------------

<<time/date.c>>=
<<plan9 includes>>

<<global flags(date.c)>>

<<function [[main]](date.c)>>
@

\subsection{[[time/cal.c]]}

%-------------------------------------------------------------

<<time/cal.c>>=
<<plan9 includes>>
#include <bio.h>

<<constants cal.c>>
<<globals cal.c>>

// forward decls
int number(char *str);
void pstr(char *str, int n);
void cal(int m, int y, char *p, int w);
int jan1(int yr);
int curmo(void);
int curyr(void);

<<function [[main]](cal.c)>>

<<struct [[dict]](cal.c)>>
<<function [[number]](cal.c)>>
<<function [[pstr]](cal.c)>>

<<function [[cal]]>>

<<function [[jan1]](cal.c)>>

<<function [[curmo]](cal.c)>>
<<function [[curyr]](cal.c)>>
@

\section{[[misc/]]}

\subsection{[[misc/basename.c]]}

%-------------------------------------------------------------

<<misc/basename.c>>=
<<plan9 includes>>

<<function [[main]](basename.c)>>
@


\subsection{[[misc/file.c]]}

%-------------------------------------------------------------

<<misc/file.c>>=
<<plan9 includes>>
#include <bio.h>
#include <ctype.h>
#include <mach.h>

/*
 * file - determine type of file
 */
#define LENDIAN(p)  ((p)[0] | ((p)[1]<<8) | ((p)[2]<<16) | ((p)[3]<<24))

uchar   buf[6001];
short   cfreq[140];
short   wfreq[50];
int nbuf;
Dir*    mbuf;
int fd;
char    *fname;
char    *slash;

enum
{
    Cword,
    Fword,
    Aword,
    Alword,
    Lword,
    I1,
    I2,
    I3,
    Clatin  = 128,
    Cbinary,
    Cnull,
    Ceascii,
    Cutf,
};
struct
{
    char*   word;
    int class;
} dict[] =
{
    "PATH",     Lword,
    "TEXT",     Aword,
    "adt",      Alword,
    "aggr",     Alword,
    "alef",     Alword,
    "array",    Lword,
    "block",    Fword,
    "char",     Cword,
    "common",   Fword,
    "con",      Lword,
    "data",     Fword,
    "dimension",    Fword,
    "double",   Cword,
    "extern",   Cword,
    "bio",      I2,
    "float",    Cword,
    "fn",       Lword,
    "function", Fword,
    "h",        I3,
    "implement",    Lword,
    "import",   Lword,
    "include",  I1,
    "int",      Cword,
    "integer",  Fword,
    "iota",     Lword,
    "libc",     I2,
    "long",     Cword,
    "module",   Lword,
    "real",     Fword,
    "ref",      Lword,
    "register", Cword,
    "self",     Lword,
    "short",    Cword,
    "static",   Cword,
    "stdio",    I2,
    "struct",   Cword,
    "subroutine",   Fword,
    "u",        I2,
    "void",     Cword,
};

/* codes for 'mode' field in language structure */
enum    {
        Normal  = 0,
        First,      /* first entry for language spanning several ranges */
        Multi,      /* later entries "   "       "  ... */
        Shared,     /* codes used in several languages */
    };

struct
{
    int mode;       /* see enum above */
    int     count;
    int low;
    int high;
    char    *name;

} language[] =
{
    Normal, 0,  0x0100, 0x01FF, "Extended Latin",
    Normal, 0,  0x0370, 0x03FF, "Greek",
    Normal, 0,  0x0400, 0x04FF, "Cyrillic",
    Normal, 0,  0x0530, 0x058F, "Armenian",
    Normal, 0,  0x0590, 0x05FF, "Hebrew",
    Normal, 0,  0x0600, 0x06FF, "Arabic",
    Normal, 0,  0x0900, 0x097F, "Devanagari",
    Normal, 0,  0x0980, 0x09FF, "Bengali",
    Normal, 0,  0x0A00, 0x0A7F, "Gurmukhi",
    Normal, 0,  0x0A80, 0x0AFF, "Gujarati",
    Normal, 0,  0x0B00, 0x0B7F, "Oriya",
    Normal, 0,  0x0B80, 0x0BFF, "Tamil",
    Normal, 0,  0x0C00, 0x0C7F, "Telugu",
    Normal, 0,  0x0C80, 0x0CFF, "Kannada",
    Normal, 0,  0x0D00, 0x0D7F, "Malayalam",
    Normal, 0,  0x0E00, 0x0E7F, "Thai",
    Normal, 0,  0x0E80, 0x0EFF, "Lao",
    Normal, 0,  0x1000, 0x105F, "Tibetan",
    Normal, 0,  0x10A0, 0x10FF, "Georgian",
    Normal, 0,  0x3040, 0x30FF, "Japanese",
    Normal, 0,  0x3100, 0x312F, "Chinese",
    First,  0,  0x3130, 0x318F, "Korean",
    Multi,  0,  0x3400, 0x3D2F, "Korean",
    Shared, 0,  0x4e00, 0x9fff, "CJK",
    Normal, 0,  0,  0,  0,      /* terminal entry */
};


enum
{
    Fascii,     /* printable ascii */
    Flatin,     /* latin 1*/
    Futf,       /* UTF character set */
    Fbinary,    /* binary */
    Feascii,    /* ASCII with control chars */
    Fnull,      /* NULL in file */
} guess;

void    bump_utf_count(Rune);
int cistrncmp(char*, char*, int);
void    filetype(int);
int getfontnum(uchar*, uchar**);
int isas(void);
int isc(void);
int iscint(void);
int isenglish(void);
int ishp(void);
int ishtml(void);
int isrfc822(void);
int ismbox(void);
int islimbo(void);
int ismung(void);
int isp9bit(void);
int isp9font(void);
int isrtf(void);
int ismsdos(void);
int iself(void);
int istring(void);
int isoffstr(void);
int iff(void);
int long0(void);
int longoff(void);
int istar(void);
int isface(void);
int isexec(void);
int p9bitnum(uchar*);
int p9subfont(uchar*);
void    print_utf(void);
void    type(char*, int);
int utf_count(void);
void    wordfreq(void);

int (*call[])(void) =
{
    long0,      /* recognizable by first 4 bytes */
    istring,    /* recognizable by first string */
    iself,      /* ELF (foreign) executable */
    isexec,     /* native executables */
    iff,        /* interchange file format (strings) */
    longoff,    /* recognizable by 4 bytes at some offset */
    isoffstr,   /* recognizable by string at some offset */
    isrfc822,   /* email file */
    ismbox,     /* mail box */
    istar,      /* recognizable by tar checksum */
    ishtml,     /* html keywords */
    iscint,     /* compiler/assembler intermediate */
    islimbo,    /* limbo source */
    isc,        /* c & alef compiler key words */
    isas,       /* assembler key words */
    isp9font,   /* plan 9 font */
    isp9bit,    /* plan 9 image (as from /dev/window) */
    isrtf,      /* rich text format */
    ismsdos,    /* msdos exe (virus file attachement) */
    isface,     /* ascii face file */

    /* last resorts */
    ismung,     /* entropy compressed/encrypted */
    isenglish,  /* char frequency English */
    0
};

int mime;

char OCTET[] =  "application/octet-stream\n";
char PLAIN[] =  "text/plain\n";

void
main(int argc, char *argv[])
{
    int i, j, maxlen;
    char *cp;
    Rune r;

    ARGBEGIN{
    case 'm':
        mime = 1;
        break;
    default:
        fprint(2, "usage: file [-m] [file...]\n");
        exits("usage");
    }ARGEND;

    maxlen = 0;
    if(mime == 0 || argc > 1){
        for(i = 0; i < argc; i++) {
            for (j = 0, cp = argv[i]; *cp; j++, cp += chartorune(&r, cp))
                    ;
            if(j > maxlen)
                maxlen = j;
        }
    }
    if (argc <= 0) {
        if(!mime)
            print ("stdin: ");
        filetype(0);
    }
    else {
        for(i = 0; i < argc; i++)
            type(argv[i], maxlen);
    }
    exits(0);
}

void
type(char *file, int nlen)
{
    Rune r;
    int i;
    char *p;

    if(nlen > 0){
        slash = 0;
        for (i = 0, p = file; *p; i++) {
            if (*p == '/')          /* find rightmost slash */
                slash = p;
            p += chartorune(&r, p);     /* count runes */
        }
        print("%s:%*s",file, nlen-i+1, "");
    }
    fname = file;
    if ((fd = open(file, OREAD)) < 0) {
        print("cannot open: %r\n");
        return;
    }
    filetype(fd);
    close(fd);
}

void
filetype(int fd)
{
    Rune r;
    int i, f, n;
    char *p, *eob;

    free(mbuf);
    mbuf = dirfstat(fd);
    if(mbuf == nil){
        print("cannot stat: %r\n");
        return;
    }
    if(mbuf->mode & DMDIR) {
        print(mime ? OCTET : "directory\n");
        return;
    }
    if(mbuf->type != 'M' && mbuf->type != '|') {
        print(mime ? OCTET : "special file #%C/%s\n",
            mbuf->type, mbuf->name);
        return;
    }
    /* may be reading a pipe on standard input */
    nbuf = readn(fd, buf, sizeof(buf)-1);
    if(nbuf < 0) {
        print("cannot read: %r\n");
        return;
    }
    if(nbuf == 0) {
        print(mime ? PLAIN : "empty file\n");
        return;
    }
    buf[nbuf] = 0;

    /*
     * build histogram table
     */
    memset(cfreq, 0, sizeof(cfreq));
    for (i = 0; language[i].name; i++)
        language[i].count = 0;
    eob = (char *)buf+nbuf;
    for(n = 0, p = (char *)buf; p < eob; n++) {
        if (!fullrune(p, eob-p) && eob-p < UTFmax)
            break;
        p += chartorune(&r, p);
        if (r == 0)
            f = Cnull;
        else if (r <= 0x7f) {
            if (!isprint(r) && !isspace(r))
                f = Ceascii;    /* ASCII control char */
            else f = r;
        } else if (r == 0x80) {
            bump_utf_count(r);
            f = Cutf;
        } else if (r < 0xA0)
            f = Cbinary;    /* Invalid Runes */
        else if (r <= 0xff)
            f = Clatin; /* Latin 1 */
        else {
            bump_utf_count(r);
            f = Cutf;       /* UTF extension */
        }
        cfreq[f]++;         /* ASCII chars peg directly */
    }
    /*
     * gross classify
     */
    if (cfreq[Cbinary])
        guess = Fbinary;
    else if (cfreq[Cutf])
        guess = Futf;
    else if (cfreq[Clatin])
        guess = Flatin;
    else if (cfreq[Ceascii])
        guess = Feascii;
    else if (cfreq[Cnull])
        guess = Fbinary;
    else
        guess = Fascii;
    /*
     * lookup dictionary words
     */
    memset(wfreq, 0, sizeof(wfreq));
    if(guess == Fascii || guess == Flatin || guess == Futf)
        wordfreq();
    /*
     * call individual classify routines
     */
    for(i=0; call[i]; i++)
        if((*call[i])())
            return;

    /*
     * if all else fails,
     * print out gross classification
     */
    if (nbuf < 100 && !mime)
        print(mime ? PLAIN : "short ");
    if (guess == Fascii)
        print(mime ? PLAIN : "Ascii\n");
    else if (guess == Feascii)
        print(mime ? PLAIN : "extended ascii\n");
    else if (guess == Flatin)
        print(mime ? PLAIN : "latin ascii\n");
    else if (guess == Futf && utf_count() < 4)
        print_utf();
    else print(mime ? OCTET : "binary\n");
}

void
bump_utf_count(Rune r)
{
    int low, high, mid;

    high = sizeof(language)/sizeof(language[0])-1;
    for (low = 0; low < high;) {
        mid = (low+high)/2;
        if (r >= language[mid].low) {
            if (r <= language[mid].high) {
                language[mid].count++;
                break;
            } else low = mid+1;
        } else high = mid;
    }
}

int
utf_count(void)
{
    int i, count;

    count = 0;
    for (i = 0; language[i].name; i++)
        if (language[i].count > 0)
            switch (language[i].mode) {
            case Normal:
            case First:
                count++;
                break;
            default:
                break;
            }
    return count;
}

int
chkascii(void)
{
    int i;

    for (i = 'a'; i < 'z'; i++)
        if (cfreq[i])
            return 1;
    for (i = 'A'; i < 'Z'; i++)
        if (cfreq[i])
            return 1;
    return 0;
}

int
find_first(char *name)
{
    int i;

    for (i = 0; language[i].name != 0; i++)
        if (language[i].mode == First
            && strcmp(language[i].name, name) == 0)
            return i;
    return -1;
}

void
print_utf(void)
{
    int i, printed, j;

    if(mime){
        print(PLAIN);
        return;
    }
    if (chkascii()) {
        printed = 1;
        print("Ascii");
    } else
        printed = 0;
    for (i = 0; language[i].name; i++)
        if (language[i].count) {
            switch(language[i].mode) {
            case Multi:
                j = find_first(language[i].name);
                if (j < 0)
                    break;
                if (language[j].count > 0)
                    break;
                /* Fall through */
            case Normal:
            case First:
                if (printed)
                    print(" & ");
                else printed = 1;
                print("%s", language[i].name);
                break;
            case Shared:
            default:
                break;
            }
        }
    if(!printed)
        print("UTF");
    print(" text\n");
}

void
wordfreq(void)
{
    int low, high, mid, r;
    uchar *p, *p2, c;

    p = buf;
    for(;;) {
        while (p < buf+nbuf && !isalpha(*p))
            p++;
        if (p >= buf+nbuf)
            return;
        p2 = p;
        while(p < buf+nbuf && isalpha(*p))
            p++;
        c = *p;
        *p = 0;
        high = sizeof(dict)/sizeof(dict[0]);
        for(low = 0;low < high;) {
            mid = (low+high)/2;
            r = strcmp(dict[mid].word, (char*)p2);
            if(r == 0) {
                wfreq[dict[mid].class]++;
                break;
            }
            if(r < 0)
                low = mid+1;
            else
                high = mid;
        }
        *p++ = c;
    }
}

typedef struct Filemagic Filemagic;
struct Filemagic {
    ulong x;
    ulong mask;
    char *desc;
    char *mime;
};

/*
 * integers in this table must be as seen on a little-endian machine
 * when read from a file.
 */
Filemagic long0tab[] = {
    0xF16DF16D, 0xFFFFFFFF, "pac1 audio file\n",    OCTET,
    /* "pac1" */
    0x31636170, 0xFFFFFFFF, "pac3 audio file\n",    OCTET,
    /* "pXc2 */
    0x32630070, 0xFFFF00FF, "pac4 audio file\n",    OCTET,
    0xBA010000, 0xFFFFFFFF, "mpeg system stream\n", OCTET,
    0x43614c66, 0xFFFFFFFF, "FLAC audio file\n",    OCTET,
    0x30800CC0, 0xFFFFFFFF, "inferno .dis executable\n", OCTET,
    0x04034B50, 0xFFFFFFFF, "zip archive\n", "application/zip",
    070707,     0xFFFF,     "cpio archive\n", OCTET,
    0x2F7,      0xFFFF,     "tex dvi\n", "application/dvi",
    0xfaff,     0xfeff,     "mp3 audio\n",  "audio/mpeg",
    0xf0ff,     0xf6ff,     "aac audio\n",  "audio/mpeg",
    0xfeff0000, 0xffffffff, "utf-32be\n",   "text/plain charset=utf-32be",
    0xfffe,     0xffffffff, "utf-32le\n",   "text/plain charset=utf-32le",
    0xfeff,     0xffff,     "utf-16be\n",   "text/plain charset=utf-16be",
    0xfffe,     0xffff,     "utf-16le\n",   "text/plain charset=utf-16le",
    /* 0xfeedface: this could alternately be a Next Plan 9 boot image */
    0xcefaedfe, 0xFFFFFFFF, "32-bit power Mach-O executable\n", OCTET,
    /* 0xfeedfacf */
    0xcffaedfe, 0xFFFFFFFF, "64-bit power Mach-O executable\n", OCTET,
    /* 0xcefaedfe */
    0xfeedface, 0xFFFFFFFF, "386 Mach-O executable\n", OCTET,
    /* 0xcffaedfe */
    0xfeedfacf, 0xFFFFFFFF, "amd64 Mach-O executable\n", OCTET,
    /* 0xcafebabe */
    0xbebafeca, 0xFFFFFFFF, "Mach-O universal executable\n", OCTET,
    /*
     * these magic numbers are stored big-endian on disk,
     * thus the numbers appear reversed in this table.
     */
    0xad4e5cd1, 0xFFFFFFFF, "venti arena\n", OCTET,
    0x2bb19a52, 0xFFFFFFFF, "paq archive\n", OCTET,
};

int
filemagic(Filemagic *tab, int ntab, ulong x)
{
    int i;

    for(i=0; i<ntab; i++)
        if((x&tab[i].mask) == tab[i].x){
            print(mime ? tab[i].mime : tab[i].desc);
            return 1;
        }
    return 0;
}

int
long0(void)
{
    return filemagic(long0tab, nelem(long0tab), LENDIAN(buf));
}

typedef struct Fileoffmag Fileoffmag;
struct Fileoffmag {
    ulong   off;
    Filemagic;
};

/*
 * integers in this table must be as seen on a little-endian machine
 * when read from a file.
 */
Fileoffmag longofftab[] = {
    /*
     * these magic numbers are stored big-endian on disk,
     * thus the numbers appear reversed in this table.
     */
    256*1024, 0xe7a5e4a9, 0xFFFFFFFF, "venti arenas partition\n", OCTET,
    256*1024, 0xc75e5cd1, 0xFFFFFFFF, "venti index section\n", OCTET,
    128*1024, 0x89ae7637, 0xFFFFFFFF, "fossil write buffer\n", OCTET,
    4,    0x31647542, 0xFFFFFFFF, "OS X finder properties\n", OCTET,
};

int
fileoffmagic(Fileoffmag *tab, int ntab)
{
    int i;
    ulong x;
    Fileoffmag *tp;
    uchar buf[sizeof(long)];

    for(i=0; i<ntab; i++) {
        tp = tab + i;
        seek(fd, tp->off, 0);
        if (readn(fd, buf, sizeof buf) != sizeof buf)
            continue;
        x = LENDIAN(buf);
        if((x&tp->mask) == tp->x){
            print(mime? tp->mime: tp->desc);
            return 1;
        }
    }
    return 0;
}

int
longoff(void)
{
    return fileoffmagic(longofftab, nelem(longofftab));
}

int
isexec(void)
{
    Fhdr f;

    seek(fd, 0, 0);     /* reposition to start of file */
    if(crackhdr(fd, &f)) {
        print(mime ? OCTET : "%s\n", f.name);
        return 1;
    }
    return 0;
}


/* from tar.c */
enum { NAMSIZ = 100, TBLOCK = 512 };

union   hblock
{
    char    dummy[TBLOCK];
    struct  header
    {
        char    name[NAMSIZ];
        char    mode[8];
        char    uid[8];
        char    gid[8];
        char    size[12];
        char    mtime[12];
        char    chksum[8];
        char    linkflag;
        char    linkname[NAMSIZ];
        /* rest are defined by POSIX's ustar format; see p1003.2b */
        char    magic[6];   /* "ustar" */
        char    version[2];
        char    uname[32];
        char    gname[32];
        char    devmajor[8];
        char    devminor[8];
        char    prefix[155];  /* if non-null, path = prefix "/" name */
    } dbuf;
};

int
checksum(union hblock *hp)
{
    int i;
    char *cp;
    struct header *hdr = &hp->dbuf;

    for (cp = hdr->chksum; cp < &hdr->chksum[sizeof hdr->chksum]; cp++)
        *cp = ' ';
    i = 0;
    for (cp = hp->dummy; cp < &hp->dummy[TBLOCK]; cp++)
        i += *cp & 0xff;
    return i;
}

int
istar(void)
{
    int chksum;
    char tblock[TBLOCK];
    union hblock *hp = (union hblock *)tblock;
    struct header *hdr = &hp->dbuf;

    seek(fd, 0, 0);     /* reposition to start of file */
    if (readn(fd, tblock, sizeof tblock) != sizeof tblock)
        return 0;
    chksum = strtol(hdr->chksum, nil, 8);
    if (hdr->name[0] != '\0' && checksum(hp) == chksum) {
        if (strcmp(hdr->magic, "ustar") == 0)
            print(mime? "application/x-ustar\n":
                "posix tar archive\n");
        else
            print(mime? "application/x-tar\n": "tar archive\n");
        return 1;
    }
    return 0;
}

/*
 * initial words to classify file
 */
struct  FILE_STRING
{
    char    *key;
    char    *filetype;
    int length;
    char    *mime;
} file_string[] =
{
    "!<arch>\n__.SYMDEF",   "archive random library",   16, "application/octet-stream",
    "!<arch>\n",        "archive",          8,  "application/octet-stream",
    "070707",       "cpio archive - ascii header",  6,  "application/octet-stream",
    "#!/bin/rc",        "rc executable file",       9,  "text/plain",
    "#!/bin/sh",        "sh executable file",       9,  "text/plain",
    "%!",           "postscript",           2,  "application/postscript",
    "\004%!",       "postscript",           3,  "application/postscript",
    "x T post",     "troff output for post",    8,  "application/troff",
    "x T Latin1",       "troff output for Latin1",  10, "application/troff",
    "x T utf",      "troff output for UTF",     7,  "application/troff",
    "x T 202",      "troff output for 202",     7,  "application/troff",
    "x T aps",      "troff output for aps",     7,  "application/troff",
    "x T ",         "troff output",         4,  "application/troff",
    "GIF",          "GIF image",            3,  "image/gif",
    "\0PC Research, Inc\0", "ghostscript fax file",     18, "application/ghostscript",
    "%PDF",         "PDF",              4,  "application/pdf",
    "<html>\n",     "HTML file",            7,  "text/html",
    "<HTML>\n",     "HTML file",            7,  "text/html",
    "\111\111\052\000", "tiff",             4,  "image/tiff",
    "\115\115\000\052", "tiff",             4,  "image/tiff",
    "\377\330\377\340", "jpeg",             4,  "image/jpeg",
    "\377\330\377\341", "jpeg",             4,  "image/jpeg",
    "\377\330\377\333", "jpeg",             4,  "image/jpeg",
    "BM",           "bmp",              2,  "image/bmp",
    "\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1", "microsoft office document",    8,  "application/octet-stream",
    "<MakerFile ",      "FrameMaker file",      11, "application/framemaker",
    "\033E\033",    "HP PCL printer data",      3,  OCTET,
    "\033&",    "HP PCL printer data",      2,  OCTET,
    "\033%-12345X", "HPJCL file",       9,  "application/hpjcl",
    "\033Lua",      "Lua bytecode",     4,  OCTET,
    "ID3",          "mp3 audio with id3",   3,  "audio/mpeg",
    "\211PNG",      "PNG image",        4,  "image/png",
    "P3\n",         "ppm",              3,  "image/ppm",
    "P6\n",         "ppm",              3,  "image/ppm",
    "/* XPM */\n",  "xbm",              10, "image/xbm",
    ".HTML ",       "troff -ms input",  6,  "text/troff",
    ".LP",          "troff -ms input",  3,  "text/troff",
    ".ND",          "troff -ms input",  3,  "text/troff",
    ".PP",          "troff -ms input",  3,  "text/troff",
    ".TL",          "troff -ms input",  3,  "text/troff",
    ".TR",          "troff -ms input",  3,  "text/troff",
    ".TH",          "manual page",      3,  "text/troff",
    ".\\\"",        "troff input",      3,  "text/troff",
    ".de",          "troff input",      3,  "text/troff",
    ".if",          "troff input",      3,  "text/troff",
    ".nr",          "troff input",      3,  "text/troff",
    ".tr",          "troff input",      3,  "text/troff",
    "vac:",         "venti score",      4,  "text/plain",
    "-----BEGIN CERTIFICATE-----\n",
                "pem certificate",  -1, "text/plain",
    "-----BEGIN TRUSTED CERTIFICATE-----\n",
                "pem trusted certificate", -1,  "text/plain",
    "-----BEGIN X509 CERTIFICATE-----\n",
                "pem x.509 certificate", -1,    "text/plain",
    "subject=/C=",      "pem certificate with header", -1, "text/plain",
    "process snapshot ",    "process snapshot", -1, "application/snapfs",
    "BEGIN:VCARD\r\n",  "vCard",        13, "text/directory;profile=vcard",
    "BEGIN:VCARD\n",    "vCard",        12, "text/directory;profile=vcard",
    0,0,0,0
};

int
istring(void)
{
    int i, l;
    struct FILE_STRING *p;

    for(p = file_string; p->key; p++) {
        l = p->length;
        if(l == -1)
            l = strlen(p->key);
        if(nbuf >= l && memcmp(buf, p->key, l) == 0) {
            if(mime)
                print("%s\n", p->mime);
            else
                print("%s\n", p->filetype);
            return 1;
        }
    }
    if(strncmp((char*)buf, "TYPE=", 5) == 0) {  /* td */
        for(i = 5; i < nbuf; i++)
            if(buf[i] == '\n')
                break;
        if(mime)
            print(OCTET);
        else
            print("%.*s picture\n", utfnlen((char*)buf+5, i-5), (char*)buf+5);
        return 1;
    }
    return 0;
}

struct offstr
{
    ulong   off;
    struct FILE_STRING;
} offstrs[] = {
    32*1024, "\001CD001\001",   "ISO9660 CD image", 7,  OCTET,
    0, 0, 0, 0, 0
};

int
isoffstr(void)
{
    int n;
    char buf[256];
    struct offstr *p;

    for(p = offstrs; p->key; p++) {
        seek(fd, p->off, 0);
        n = p->length;
        if (n > sizeof buf)
            n = sizeof buf;
        if (readn(fd, buf, n) != n)
            continue;
        if(memcmp(buf, p->key, n) == 0) {
            if(mime)
                print("%s\n", p->mime);
            else
                print("%s\n", p->filetype);
            return 1;
        }
    }
    return 0;
}

int
iff(void)
{
    if (strncmp((char*)buf, "FORM", 4) == 0 &&
        strncmp((char*)buf+8, "AIFF", 4) == 0) {
        print("%s\n", mime? "audio/x-aiff": "aiff audio");
        return 1;
    }
    if (strncmp((char*)buf, "RIFF", 4) == 0) {
        if (strncmp((char*)buf+8, "WAVE", 4) == 0)
            print("%s\n", mime? "audio/wave": "wave audio");
        else if (strncmp((char*)buf+8, "AVI ", 4) == 0)
            print("%s\n", mime? "video/avi": "avi video");
        else
            print("%s\n", mime? "application/octet-stream":
                "riff file");
        return 1;
    }
    return 0;
}

char*   html_string[] =
{
    "title",
    "body",
    "head",
    "strong",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "ul",
    "li",
    "dl",
    "br",
    "em",
    0,
};

int
ishtml(void)
{
    uchar *p, *q;
    int i, count;

        /* compare strings between '<' and '>' to html table */
    count = 0;
    p = buf;
    for(;;) {
        while (p < buf+nbuf && *p != '<')
            p++;
        p++;
        if (p >= buf+nbuf)
            break;
        if(*p == '/')
            p++;
        q = p;
        while(p < buf+nbuf && *p != '>')
            p++;
        if (p >= buf+nbuf)
            break;
        for(i = 0; html_string[i]; i++) {
            if(cistrncmp(html_string[i], (char*)q, p-q) == 0) {
                if(count++ > 4) {
                    print(mime ? "text/html\n" : "HTML file\n");
                    return 1;
                }
                break;
            }
        }
        p++;
    }
    return 0;
}

char*   rfc822_string[] =
{
    "from:",
    "date:",
    "to:",
    "subject:",
    "received:",
    "reply to:",
    "sender:",
    0,
};

int
isrfc822(void)
{

    char *p, *q, *r;
    int i, count;

    count = 0;
    p = (char*)buf;
    for(;;) {
        q = strchr(p, '\n');
        if(q == nil)
            break;
        *q = 0;
        if(p == (char*)buf && strncmp(p, "From ", 5) == 0 && strstr(p, " remote from ")){
            count++;
            *q = '\n';
            p = q+1;
            continue;
        }
        *q = '\n';
        if(*p != '\t' && *p != ' '){
            r = strchr(p, ':');
            if(r == 0 || r > q)
                break;
            for(i = 0; rfc822_string[i]; i++) {
                if(cistrncmp(p, rfc822_string[i], strlen(rfc822_string[i])) == 0){
                    count++;
                    break;
                }
            }
        }
        p = q+1;
    }
    if(count >= 3){
        print(mime ? "message/rfc822\n" : "email file\n");
        return 1;
    }
    return 0;
}

int
ismbox(void)
{
    char *p, *q;

    p = (char*)buf;
    q = strchr(p, '\n');
    if(q == nil)
        return 0;
    *q = 0;
    if(strncmp(p, "From ", 5) == 0 && strstr(p, " remote from ") == nil){
        print(mime ? "text/plain\n" : "mail box\n");
        return 1;
    }
    *q = '\n';
    return 0;
}

int
iscint(void)
{
    int type;
    char *name;
    Biobuf b;

    if(Binit(&b, fd, OREAD) == Beof)
        return 0;
    seek(fd, 0, 0);
    type = objtype(&b, &name);
    if(type < 0)
        return 0;
    if(mime)
        print(OCTET);
    else
        print("%s intermediate\n", name);
    return 1;
}

int
isc(void)
{
    int n;

    n = wfreq[I1];
    /*
     * includes
     */
    if(n >= 2 && wfreq[I2] >= n && wfreq[I3] >= n && cfreq['.'] >= n)
        goto yes;
    if(n >= 1 && wfreq[Alword] >= n && wfreq[I3] >= n && cfreq['.'] >= n)
        goto yes;
    /*
     * declarations
     */
    if(wfreq[Cword] >= 5 && cfreq[';'] >= 5)
        goto yes;
    /*
     * assignments
     */
    if(cfreq[';'] >= 10 && cfreq['='] >= 10 && wfreq[Cword] >= 1)
        goto yes;
    return 0;

yes:
    if(mime){
        print(PLAIN);
        return 1;
    }
    if(wfreq[Alword] > 0)
        print("alef program\n");
    else
        print("c program\n");
    return 1;
}

int
islimbo(void)
{

    /*
     * includes
     */
    if(wfreq[Lword] < 4)
        return 0;
    print(mime ? PLAIN : "limbo program\n");
    return 1;
}

int
isas(void)
{

    /*
     * includes
     */
    if(wfreq[Aword] < 2)
        return 0;
    print(mime ? PLAIN : "as program\n");
    return 1;
}

/*
 * low entropy means encrypted
 */
int
ismung(void)
{
    int i, bucket[8];
    float cs;

    if(nbuf < 64)
        return 0;
    memset(bucket, 0, sizeof(bucket));
    for(i=nbuf-64; i<nbuf; i++)
        bucket[(buf[i]>>5)&07] += 1;

    cs = 0.;
    for(i=0; i<8; i++)
        cs += (bucket[i]-8)*(bucket[i]-8);
    cs /= 8.;
    if(cs <= 24.322) {
        if(buf[0]==0x1f && buf[1]==0x9d)
            print(mime ? OCTET : "compressed\n");
        else
        if(buf[0]==0x1f && buf[1]==0x8b)
            print(mime ? OCTET : "gzip compressed\n");
        else
        if(buf[0]=='B' && buf[1]=='Z' && buf[2]=='h')
            print(mime ? OCTET : "bzip2 compressed\n");
        else
            print(mime ? OCTET : "encrypted\n");
        return 1;
    }
    return 0;
}

/*
 * english by punctuation and frequencies
 */
int
isenglish(void)
{
    int vow, comm, rare, badpun, punct;
    char *p;

    if(guess != Fascii && guess != Feascii)
        return 0;
    badpun = 0;
    punct = 0;
    for(p = (char *)buf; p < (char *)buf+nbuf-1; p++)
        switch(*p) {
        case '.':
        case ',':
        case ')':
        case '%':
        case ';':
        case ':':
        case '?':
            punct++;
            if(p[1] != ' ' && p[1] != '\n')
                badpun++;
        }
    if(badpun*5 > punct)
        return 0;
    if(cfreq['>']+cfreq['<']+cfreq['/'] > cfreq['e'])   /* shell file test */
        return 0;
    if(2*cfreq[';'] > cfreq['e'])
        return 0;

    vow = 0;
    for(p="AEIOU"; *p; p++) {
        vow += cfreq[*p];
        vow += cfreq[tolower(*p)];
    }
    comm = 0;
    for(p="ETAION"; *p; p++) {
        comm += cfreq[*p];
        comm += cfreq[tolower(*p)];
    }
    rare = 0;
    for(p="VJKQXZ"; *p; p++) {
        rare += cfreq[*p];
        rare += cfreq[tolower(*p)];
    }
    if(vow*5 >= nbuf-cfreq[' '] && comm >= 10*rare) {
        print(mime ? PLAIN : "English text\n");
        return 1;
    }
    return 0;
}

/*
 * pick up a number with
 * syntax _*[0-9]+_
 */
#define P9BITLEN    12
int
p9bitnum(uchar *bp)
{
    int n, c, len;

    len = P9BITLEN;
    while(*bp == ' ') {
        bp++;
        len--;
        if(len <= 0)
            return -1;
    }
    n = 0;
    while(len > 1) {
        c = *bp++;
        if(!isdigit(c))
            return -1;
        n = n*10 + c-'0';
        len--;
    }
    if(*bp != ' ')
        return -1;
    return n;
}

int
depthof(char *s, int *newp)
{
    char *es;
    int d;

    *newp = 0;
    es = s+12;
    while(s<es && *s==' ')
        s++;
    if(s == es)
        return -1;
    if('0'<=*s && *s<='9')
        return 1<<strtol(s, nil, 0);

    *newp = 1;
    d = 0;
    while(s<es && *s!=' '){
        s++;            /* skip letter */
        d += strtoul(s, &s, 10);
    }

    if(d % 8 == 0 || 8 % d == 0)
        return d;
    else
        return -1;
}

int
isp9bit(void)
{
    int dep, lox, loy, hix, hiy, px, new, cmpr;
    ulong t;
    long len;
    char *newlabel;
    uchar *cp;

    cp = buf;
    cmpr = 0;
    newlabel = "old ";

    if(memcmp(cp, "compressed\n", 11) == 0) {
        cmpr = 1;
        cp = buf + 11;
    }

    dep = depthof((char*)cp + 0*P9BITLEN, &new);
    if(new)
        newlabel = "";
    lox = p9bitnum(cp + 1*P9BITLEN);
    loy = p9bitnum(cp + 2*P9BITLEN);
    hix = p9bitnum(cp + 3*P9BITLEN);
    hiy = p9bitnum(cp + 4*P9BITLEN);
    if(dep < 0 || lox < 0 || loy < 0 || hix < 0 || hiy < 0)
        return 0;

    if(dep < 8){
        px = 8/dep;     /* pixels per byte */
        /* set l to number of bytes of data per scan line */
        if(lox >= 0)
            len = (hix+px-1)/px - lox/px;
        else{           /* make positive before divide */
            t = (-lox)+px-1;
            t = (t/px)*px;
            len = (t+hix+px-1)/px;
        }
    }else
        len = (hix-lox)*dep/8;
    len *= hiy - loy;       /* col length */
    len += 5 * P9BITLEN;        /* size of initial ascii */

    /*
     * for compressed images, don't look any further. otherwise:
     * for image file, length is non-zero and must match calculation above.
     * for /dev/window and /dev/screen the length is always zero.
     * for subfont, the subfont header should follow immediately.
     */
    if (cmpr) {
        print(mime ? OCTET : "Compressed %splan 9 image or subfont, depth %d\n",
            newlabel, dep);
        return 1;
    }
    /*
     * mbuf->length == 0 probably indicates reading a pipe.
     * Ghostscript sometimes produces a little extra on the end.
     */
    if (len != 0 && (mbuf->length == 0 || mbuf->length == len ||
        mbuf->length > len && mbuf->length < len+P9BITLEN)) {
        print(mime ? OCTET : "%splan 9 image, depth %d\n", newlabel, dep);
        return 1;
    }
    if (p9subfont(buf+len)) {
        print(mime ? OCTET : "%ssubfont file, depth %d\n", newlabel, dep);
        return 1;
    }
    return 0;
}

int
p9subfont(uchar *p)
{
    int n, h, a;

    /* if image too big, assume it's a subfont */
    if (p+3*P9BITLEN > buf+sizeof(buf))
        return 1;

    n = p9bitnum(p + 0*P9BITLEN);   /* char count */
    if (n < 0)
        return 0;
    h = p9bitnum(p + 1*P9BITLEN);   /* height */
    if (h < 0)
        return 0;
    a = p9bitnum(p + 2*P9BITLEN);   /* ascent */
    if (a < 0)
        return 0;
    return 1;
}

#define WHITESPACE(c)       ((c) == ' ' || (c) == '\t' || (c) == '\n')

int
isp9font(void)
{
    uchar *cp, *p;
    int i, n;
    char pathname[1024];

    cp = buf;
    if (!getfontnum(cp, &cp))   /* height */
        return 0;
    if (!getfontnum(cp, &cp))   /* ascent */
        return 0;
    for (i = 0; cp=(uchar*)strchr((char*)cp, '\n'); i++) {
        if (!getfontnum(cp, &cp))   /* min */
            break;
        if (!getfontnum(cp, &cp))   /* max */
            return 0;
        getfontnum(cp, &cp);    /* optional offset */
        while (WHITESPACE(*cp))
            cp++;
        for (p = cp; *cp && !WHITESPACE(*cp); cp++)
                ;
            /* construct a path name, if needed */
        n = 0;
        if (*p != '/' && slash) {
            n = slash-fname+1;
            if (n < sizeof(pathname))
                memcpy(pathname, fname, n);
            else n = 0;
        }
        if (n+cp-p+4 < sizeof(pathname)) {
            memcpy(pathname+n, p, cp-p);
            n += cp-p;
            pathname[n] = 0;
            if (access(pathname, AEXIST) < 0) {
                strcpy(pathname+n, ".0");
                if (access(pathname, AEXIST) < 0)
                    return 0;
            }
        }
    }
    if (i) {
        print(mime ? "text/plain\n" : "font file\n");
        return 1;
    }
    return 0;
}

int
getfontnum(uchar *cp, uchar **rp)
{
    while (WHITESPACE(*cp))     /* extract ulong delimited by whitespace */
        cp++;
    if (*cp < '0' || *cp > '9')
        return 0;
    strtoul((char *)cp, (char **)rp, 0);
    if (!WHITESPACE(**rp)) {
        *rp = cp;
        return 0;
    }
    return 1;
}

int
isrtf(void)
{
    if(strstr((char *)buf, "\\rtf1")){
        print(mime ? "application/rtf\n" : "rich text format\n");
        return 1;
    }
    return 0;
}

int
ismsdos(void)
{
    if (buf[0] == 0x4d && buf[1] == 0x5a){
        print(mime ? "application/x-msdownload\n" : "MSDOS executable\n");
        return 1;
    }
    return 0;
}

int
iself(void)
{
    static char *cpu[] = {      /* NB: incomplete and arbitary list */
    [1] "WE32100",
    [2] "SPARC",
    [3] "i386",
    [4] "M68000",
    [5] "M88000",
    [6] "i486",
    [7] "i860",
    [8] "R3000",
    [9] "S370",
    [10]    "R4000",
    [15]    "HP-PA",
    [18]    "sparc v8+",
    [19]    "i960",
    [20]    "PPC-32",
    [21]    "PPC-64",
    [40]    "ARM",
    [41]    "Alpha",
    [43]    "sparc v9",
    [50]    "IA-64",
    [62]    "AMD64",
    [75]    "VAX",
    };
    static char *type[] = {
    [1] "relocatable object",
    [2] "executable",
    [3] "shared library",
    [4] "core dump",
    };

    if (memcmp(buf, "\x7fELF", 4) == 0){
        if (!mime){
            int isdifend = 0;
            int n = (buf[19] << 8) | buf[18];
            char *p = "unknown";
            char *t = "unknown";

            if (n > 0 && n < nelem(cpu) && cpu[n])
                p = cpu[n];
            else {
                /* try the other byte order */
                isdifend = 1;
                n = (buf[18] << 8) | buf[19];
                if (n > 0 && n < nelem(cpu) && cpu[n])
                    p = cpu[n];
            }
            if(isdifend)
                n = (buf[16]<< 8) | buf[17];
            else
                n = (buf[17]<< 8) | buf[16];

            if(n>0 && n < nelem(type) && type[n])
                t = type[n];
            print("%s ELF%s %s\n", p, (buf[4] == 2? "64": "32"), t);
        }
        else
            print("application/x-elf-executable");
        return 1;
    }

    return 0;
}

int
isface(void)
{
    int i, j, ldepth, l;
    char *p;

    ldepth = -1;
    for(j = 0; j < 3; j++){
        for(p = (char*)buf, i=0; i<3; i++){
            if(p[0] != '0' || p[1] != 'x')
                return 0;
            if(buf[2+8] == ',')
                l = 2;
            else if(buf[2+4] == ',')
                l = 1;
            else
                return 0;
            if(ldepth == -1)
                ldepth = l;
            if(l != ldepth)
                return 0;
            strtoul(p, &p, 16);
            if(*p++ != ',')
                return 0;
            while(*p == ' ' || *p == '\t')
                p++;
        }
        if (*p++ != '\n')
            return 0;
    }

    if(mime)
        print("application/x-face\n");
    else
        print("face image depth %d\n", ldepth);
    return 1;
}

@

\subsection{[[misc/iconv.c]]}

%-------------------------------------------------------------

<<misc/iconv.c>>=
<<plan9 includes>>
#include <draw.h>
#include <memdraw.h>

void
usage(void)
{
    fprint(2, "usage: iconv [-u] [-c chanstr] [file]\n");
    exits("usage");
}

void
writeuncompressed(int fd, Memimage *m)
{
    char chanstr[32];
    int bpl, y, j;
    uchar *buf;

    if(chantostr(chanstr, m->chan) == nil)
        sysfatal("can't convert channel descriptor: %r");
    fprint(fd, "%11s %11d %11d %11d %11d ",
        chanstr, m->r.min.x, m->r.min.y, m->r.max.x, m->r.max.y);

    bpl = bytesperline(m->r, m->depth);
    buf = malloc(bpl);
    if(buf == nil)
        sysfatal("malloc failed: %r");
    for(y=m->r.min.y; y<m->r.max.y; y++){
        j = unloadmemimage(m, Rect(m->r.min.x, y, m->r.max.x, y+1), buf, bpl);
        if(j != bpl)
            sysfatal("image unload failed: %r");
        if(write(fd, buf, bpl) != bpl)
            sysfatal("write failed: %r");
    }
    free(buf);
}

void
main(int argc, char *argv[])
{
    char *tostr, *file;
    int fd, uncompressed;
    ulong tochan;
    Memimage *m, *n;

    tostr = nil;
    uncompressed = 0;
    ARGBEGIN{
    case 'c':
        tostr = EARGF(usage());
        break;
    case 'u':
        uncompressed = 1;
        break;
    default:
        usage();
    }ARGEND

    memimageinit();

    file = "<stdin>";
    m = nil;

    switch(argc){
    case 0:
        m = readmemimage(0);
        break;
    case 1:
        file = argv[0];
        fd = open(file, OREAD);
        if(fd < 0)
            sysfatal("can't open %s: %r", file);
        m = readmemimage(fd);
        close(fd);
        break;
    default:
        usage();
    }

    if(m == nil)
        sysfatal("can't read %s: %r", file);

    if(tostr == nil)
        tochan = m->chan;
    else{
        tochan = strtochan(tostr);
        if(tochan == 0)
            sysfatal("bad channel descriptor '%s'", tostr);
    }

    n = allocmemimage(m->r, tochan);
    if(n == nil)
        sysfatal("can't allocate new image: %r");

    memimagedraw(n, n->r, m, m->r.min, nil, ZP, S);
    if(uncompressed)
        writeuncompressed(1, n);
    else
        writememimage(1, n);
    exits(nil);
}
@

\subsection{[[misc/strings.c]]}

%-------------------------------------------------------------

<<misc/strings.c>>=
<<plan9 includes>>
#include    <bio.h>

Biobuf  *fin;
Biobuf  fout;

#define MINSPAN     6       /* Min characters in string (default) */
#define BUFSIZE     70

void stringit(char *);
int isprint(Rune);

static int minspan = MINSPAN;

static void
usage(void)
{
    fprint(2, "usage: %s [-m min] [file...]\n", argv0);
    exits("usage");
}

void
main(int argc, char **argv)
{
    int i;

    ARGBEGIN{
    case 'm':
        minspan = atoi(EARGF(usage()));
        break;
    default:
        usage();
        break;
    }ARGEND
    Binit(&fout, 1, OWRITE);
    if(argc < 1) {
        stringit("/fd/0");
        exits(0);
    }

    for(i = 0; i < argc; i++) {
        if(argc > 2)
            print("%s:\n", argv[i]);

        stringit(argv[i]);
    }

    exits(0);
}

void
stringit(char *str)
{
    long posn, start;
    int cnt = 0;
    long c;

    Rune buf[BUFSIZE];

    if ((fin = Bopen(str, OREAD)) == 0) {
        perror("open");
        return;
    }

    start = 0;
    posn = Boffset(fin);
    while((c = Bgetrune(fin)) >= 0) {
        if(isprint(c)) {
            if(start == 0)
                start = posn;
            buf[cnt++] = c;
            if(cnt == BUFSIZE-1) {
                buf[cnt] = 0;
                Bprint(&fout, "%8ld: %S ...\n", start, buf);
                start = 0;
                cnt = 0;
            }
        } else {
             if(cnt >= minspan) {
                buf[cnt] = 0;
                Bprint(&fout, "%8ld: %S\n", start, buf);
            }
            start = 0;
            cnt = 0;
        }   
        posn = Boffset(fin);
    }

    if(cnt >= minspan){
        buf[cnt] = 0;
        Bprint(&fout, "%8ld: %S\n", start, buf);
    }
    Bterm(fin);
}

int
isprint(Rune r)
{
    if (r != Runeerror)
    if ((r >= ' ' && r < 0x7F) || r > 0xA0)
        return 1;
    return 0;
}
@

\subsection{[[misc/unicode.c]]}

%-------------------------------------------------------------

<<misc/unicode.c>>=
<<plan9 includes>>
#include <bio.h>

char    usage[] = "unicode { [-t] hex hex ... | hexmin-hexmax ... | [-n] char ... }";
char    hex[] = "0123456789abcdefABCDEF";
int numout = 0;
int text = 0;
char    *err;
Biobuf  bout;

char    *range(char*[]);
char    *nums(char*[]);
char    *chars(char*[]);

void
main(int argc, char *argv[])
{
    ARGBEGIN{
    case 'n':
        numout = 1;
        break;
    case 't':
        text = 1;
        break;
    }ARGEND
    Binit(&bout, 1, OWRITE);
    if(argc == 0){
        fprint(2, "usage: %s\n", usage);
        exits("usage");
    }
    if(!numout && utfrune(argv[0], '-'))
        exits(range(argv));
    if(numout || strchr(hex, argv[0][0])==0)
        exits(nums(argv));
    exits(chars(argv));
}

char*
range(char *argv[])
{
    char *q;
    int min, max;
    int i;

    while(*argv){
        q = *argv;
        if(strchr(hex, q[0]) == 0){
    err:
            fprint(2, "unicode: bad range %s\n", *argv);
            return "bad range";
        }
        min = strtoul(q, &q, 16);
        if(min<0 || min>Runemax || *q!='-')
            goto err;
        q++;
        if(strchr(hex, *q) == 0)
            goto err;
        max = strtoul(q, &q, 16);
        if(max<0 || max>Runemax || max<min || *q!=0)
            goto err;
        i = 0;
        do{
            Bprint(&bout, "%.6x %C", min, min);
            i++;
            if(min==max || (i&7)==0)
                Bprint(&bout, "\n");
            else
                Bprint(&bout, "\t");
            min++;
        }while(min<=max);
        argv++;
    }
    return 0;
}

char*
nums(char *argv[])
{
    char *q;
    Rune r;
    int w, rsz;
    char utferr[UTFmax];

    r = Runeerror;
    rsz = runetochar(utferr, &r);
    while(*argv){
        q = *argv;
        while(*q){
            w = chartorune(&r, q);
            if(r==Runeerror){
                if(strlen(q) != rsz || memcmp(q, utferr, rsz) != 0){
                    fprint(2, "unicode: invalid utf string %s\n", *argv);
                    return "bad utf";
                }
            }
            Bprint(&bout, "%.6x\n", r);
            q += w;
        }
        argv++;
    }
    return 0;
}

char*
chars(char *argv[])
{
    char *q;
    int m;

    while(*argv){
        q = *argv;
        if(strchr(hex, q[0]) == 0){
    err:
            fprint(2, "unicode: bad unicode value %s\n", *argv);
            return "bad char";
        }
        m = strtoul(q, &q, 16);
        if(m<0 || m>Runemax || *q!=0)
            goto err;
        Bprint(&bout, "%C", m);
        if(!text)
            Bprint(&bout, "\n");
        argv++;
    }
    return 0;
}
@

\section{[[editors/]]}


\subsection{[[editors/ed/ed.c]]}

<<constants ed.c>>=
BLKSIZE = 4096,     /* block size in temp file */
NBLK    = 8191,     /* max size of temp file */
MAXSUB  = 9,        /* max number of sub reg exp */
ESCFLG  = Runemax,  /* escape Rune - user defined code */
@

<<globals ed.c>>=
Rune    genbuf[LBSIZE];
Rune*   linebp;
Rune*   loc1;
Rune*   loc2;
int nleft;
Rune    rhsbuf[LBSIZE/sizeof(Rune)];
int subolda;
Resub   subexp[MAXSUB];


char    T[] = "TMP";
char    WRERR[] = "WRITE ERROR";
int bpagesize = 20;
char    hex[]   = "0123456789abcdef";
// in Linux pid can be very long, so better to have at least 7 X (was 5 before)
char template[] = "/tmp/eXXXXXXX";
@


%-------------------------------------------------------------
<<editors/misc/ed.c>>=
/*
 * Editor
 */
<<plan9 includes>>
#include <bio.h>
#include <regexp.h>

enum
{
    <<constants ed.c>>
};

// ??? seems dead
void    (*oldhup)(int);
void    (*oldquit)(int);

<<globals ed.c>>

// forward declarations
void    add(int);
int*    address(void);
int     append(int(*)(void), int*);
void    browse(void);
void    callunix(void);
void    commands(void);
void    compile(int);
int     compsub(void);
void    dosub(void);
void    error(char*);
int     match(int*);
void    exfile(int);
void    filename(int);
Rune*   getblock(int, int);
int     getchr(void);
int     getcopy(void);
int     getfile(void);
Rune*   getline(int);
int     getnum(void);
int     getsub(void);
int     gettty(void);
void    global(int);
void    init(void);
void    join(void);
void    move(int);
void    newline(void);
void    nonzero(void);
void    notifyf(void*, char*);
Rune*   place(Rune*, Rune*, Rune*);
void    printcom(void);
void    putchr(int);
void    putd(void);
void    putfile(void);
int     putline(void);
void    putshst(Rune*);
void    putst(char*);
void    quit(void);
void    rdelete(int*, int*);
void    regerror(char *);
void    reverse(int*, int*);
void    setnoaddr(void);
void    setwide(void);
void    squeeze(int);
void    substitute(int);

<<function [[main]](ed.c)>>

<<function [[commands]](ed.c)>>

// Command helpers
<<function [[printcom]](ed.c)>>

<<function [[address]](ed.c)>>
<<function [[getnum]](ed.c)>>

// ???
<<function [[setwide]](ed.c)>>
<<function [[setnoaddr]](ed.c)>>
<<function [[nonzero]](ed.c)>>
<<function [[squeeze]](ed.c)>>
<<function [[newline]](ed.c)>>
<<function [[filename]](ed.c)>>

// Writing files
<<function [[exfile]](ed.c)>>

// Error management
<<function [[error_1]](ed.c)>>
<<function [[error]](ed.c)>>
<<function [[rescue]](ed.c)>>

// Note management
<<function [[notifyf]](ed.c)>>

// Reading characters
<<function [[getchr]](ed.c)>>
<<function [[gety]](ed.c)>>
<<function [[gettty]](ed.c)>>

// Reading and writing files
<<function [[getfile]](ed.c)>>
<<function [[putfile]](ex.c)>>

<<function [[append]](ed.c)>>
<<function [[add]](ed.c)>>

<<function [[browse]](ed.c)>>

<<function [[callunix]](ed.c)>>

<<function [[quit]](ed.c)>>
<<function [[onquit]](ed.c)>>

// Delete
<<function [[rdelete]](ed.c)>>
<<function [[gdelete]](ed.c)>>

// Get/Put lines
<<function [[getline]](ed.c)>>
<<function [[putline]](ed.c)>>
<<function [[blkio]](ed.c)>>
<<function [[getblock]](ed.c)>>

<<function [[init]](ed.c)>>

<<function [[global]](ed.c)>>

<<function [[join]](ed.c)>>

// Search and replace
<<function [[substitute]](ed.c)>>
<<function [[compsub]](ed.c)>>
<<function [[getsub]](ed.c)>>
<<function [[dosub]](ed.c)>>
<<function [[place]](ed.c)>>

<<function [[move]](ed.c)>>
<<function [[reverse]](ed.c)>>
<<function [[getcopy]](ed.c)>>

<<function [[compile]](ed.c)>>
<<function [[match]](ed.c)>>

// Printing text
<<function [[putd]](ex.c)>>
<<function [[putstr]](ed.c)>>
<<function [[putshst]](ed.c)>>
<<function [[putchr]](ed.c)>>

<<function [[mktemp]](ed.c)>>

<<function [[regerror]](ed.c)>>
@

\section{[[text/grep/]]}


\subsection{[[grep/main.c]]}

%-------------------------------------------------------------

<<grep/main.c>>=
#include    "grep.h"

<<constant [[validflags]](grep)>>
<<function [[usage]](grep)>>

<<function [[main]](grep)>>

<<function [[search]](grep)>>
<<function [[initstate]](grep)>>
@

\subsection{[[grep/grep.h]]}

%-------------------------------------------------------------

<<grep/grep.h>>=
<<plan9 includes>>
#include    <bio.h>

typedef struct  Re  Re;
typedef struct  Re2 Re2;
typedef struct  State   State;

<<struct [[State]](grep)>>
<<struct [[Re2]](grep)>>
<<struct [[Re]](grep)>>

<<enum [[Re_type]]>>

enum
{
    Caselim     = 7,
    Nhunk       = 1<<16,
    Cbegin      = Runemax+1,
    Flshcnt     = (1<<9)-1,
};
<<enum [[grep_flags]]>>

<<union [[U]](grep)>>
extern union U u;

// defined in globals.c
extern  char    *filename;
extern  char    *pattern;
extern  Biobuf  bout;
extern  char    flags[256];
extern  Re**    follow;
extern  ushort  gen;
extern  char*   input;
extern  long    lineno;
extern  int literal;
extern  int matched;
extern  long    maxfollow;
extern  long    nfollow;
extern  int peekc;
extern  Biobuf* rein;
extern  State*  state0;
extern  Re2 topre;

// forward decls
extern  Re* addcase(Re*);
extern  void    appendnext(Re*, Re*);
extern  void    error(char*);
extern  int fcmp(void*, void*);     /* (Re**, Re**) */
extern  void    fol1(Re*, int);
extern  int getrec(void);
extern  void    increment(State*, int);
extern  State*  initstate_(Re*);
extern  void*   mal(int);
extern  void    patchnext(Re*, Re*);
extern  Re* ral(int);
extern  Re2 re2cat(Re2, Re2);
extern  Re2 re2class(char*);
extern  Re2 re2or(Re2, Re2);
extern  Re2 re2char(int, int);
extern  Re2 re2star(Re2);
extern  State*  sal(int);
extern  int search(char*, int);
extern  void    str2top(char*);
extern  int yyparse(void);
extern  void    reprint(char*, Re*);
extern  void    yyerror(char*, ...);
@

\subsection{[[grep/grep.y]]}

%-------------------------------------------------------------


\subsection{[[grep/globals.c]]}

%XXX
<<globals grep>>=
Re**    follow;
int matched;
long    maxfollow;
long    nfollow;
@

%-------------------------------------------------------------

% I created this file
<<grep/globals.c>>=
#include "grep.h"

<<globals grep>>
@

\subsection{[[grep/sub.c]]}

%-------------------------------------------------------------

<<grep/sub.c>>=
#include    "grep.h"

<<function [[mal]](grep)>>
<<function [[sal]](grep)>>
<<function [[ral]](grep)>>

<<function [[error]](grep)>>

// addcase() helpers
<<function [[countor]](grep)>>
<<function [[oralloc]](grep)>>
<<function [[case1]](grep)>>

<<function [[addcase]](grep)>>

<<function [[str2top]](grep)>>

<<function [[appendnext]](grep)>>
<<function [[patchnext]](grep)>>

<<function [[getrec]](grep)>>

<<function [[re2cat]](grep)>>
<<function [[re2star]](grep)>>
<<function [[re2or]](grep)>>
<<function [[re2char]](grep)>>

<<function [[reprint1]](grep)>>
<<function [[reprint]](grep)>>
@

\subsection{[[grep/comp.c]]}

%-------------------------------------------------------------

<<grep/comp.c>>=
#include    "grep.h"

/*
 * incremental compiler.
 * add the branch c to the
 * state s.
 */
void
increment(State *s, int c)
{
    int i;
    State *t, **tt;
    Re *re1, *re2;

    nfollow = 0;
    gen++;
    matched = 0;
    for(i=0; i<s->count; i++)
        fol1(s->re[i], c);
    qsort(follow, nfollow, sizeof(*follow), fcmp);
    for(tt=&state0; t = *tt;) {
        if(t->count > nfollow) {
            tt = &t->linkleft;
            goto cont;
        }
        if(t->count < nfollow) {
            tt = &t->linkright;
            goto cont;
        }
        for(i=0; i<nfollow; i++) {
            re1 = t->re[i];
            re2 = follow[i];
            if(re1 > re2) {
                tt = &t->linkleft;
                goto cont;
            }
            if(re1 < re2) {
                tt = &t->linkright;
                goto cont;
            }
        }
        if(!!matched && !t->match) {
            tt = &t->linkleft;
            goto cont;
        }
        if(!matched && !!t->match) {
            tt = &t->linkright;
            goto cont;
        }
        s->next[c] = t;
        return;
    cont:;
    }

    t = sal(nfollow);
    *tt = t;
    for(i=0; i<nfollow; i++) {
        re1 = follow[i];
        t->re[i] = re1;
    }
    s->next[c] = t;
    t->match = matched;
}

int
fcmp(void *va, void *vb)
{
    Re **aa, **bb;
    Re *a, *b;

    aa = va;
    bb = vb;
    a = *aa;
    b = *bb;
    if(a > b)
        return 1;
    if(a < b)
        return -1;
    return 0;
}

void
fol1(Re *r, int c)
{
    Re *r1;

loop:
    if(r->gen == gen)
        return;
    if(nfollow >= maxfollow)
        error("nfollow");
    r->gen = gen;
    switch(r->type) {
    default:
        error("fol1");

    case Tcase:
        if(c >= 0 && c < 256)
        if(r1 = r->cases[c])
            follow[nfollow++] = r1;
        if(r = r->next)
            goto loop;
        break;

    case Talt:
    case Tor:
        fol1(r->alt, c);
        r = r->next;
        goto loop;

    case Tbegin:
        if(c == '\n' || c == Cbegin)
            follow[nfollow++] = r->next;
        break;

    case Tend:
        if(c == '\n') {
            if(r->next == 0) {
                matched = 1;
                break;
            }
            r = r->next;
            goto loop;
        }
        break;

    case Tclass:
        if(c >= r->lo && c <= r->hi)
            follow[nfollow++] = r->next;
        break;
    }
}

Rune    tab1[] =
{
    0x007f,
    0x07ff,
};
Rune    tab2[] =
{
    0x003f,
    0x0fff,
};

Re2
rclass(Rune p0, Rune p1)
{
    char xc0[6], xc1[6];
    int i, n, m;
    Re2 x;

    if(p0 > p1)
        return re2char(0xff, 0xff); // no match

    /*
     * bust range into same length
     * character sequences
     */
    for(i=0; i<nelem(tab1); i++) {
        m = tab1[i];
        if(p0 <= m && p1 > m)
            return re2or(rclass(p0, m), rclass(m+1, p1));
    }

    /*
     * bust range into part of a single page
     * or into full pages
     */
    for(i=0; i<nelem(tab2); i++) {
        m = tab2[i];
        if((p0 & ~m) != (p1 & ~m)) {
            if((p0 & m) != 0)
                return re2or(rclass(p0, p0|m), rclass((p0|m)+1, p1));
            if((p1 & m) != m)
                return re2or(rclass(p0, (p1&~m)-1), rclass(p1&~m, p1));
        }
    }

    n = runetochar(xc0, &p0);
    i = runetochar(xc1, &p1);
    if(i != n)
        error("length");

    x = re2char(xc0[0], xc1[0]);
    for(i=1; i<n; i++)
        x = re2cat(x, re2char(xc0[i], xc1[i]));
    return x;
}

int
pcmp(void *va, void *vb)
{
    int n;
    Rune *a, *b;

    a = va;
    b = vb;

    n = a[0] - b[0];
    if(n)
        return n;
    return a[1] - b[1];
}

/*
 * convert character chass into
 * run-pair ranges of matches.
 * this is 10646/utf specific and
 * needs to be changed for some
 * other input character set.
 * this is the key to a fast
 * regular search of characters
 * by looking at sequential bytes.
 */
Re2
re2class(char *s)
{
    Rune pairs[200+2], *p, *q, ov;
    int nc;
    Re2 x;

    nc = 0;
    if(*s == '^') {
        nc = 1;
        s++;
    }

    p = pairs;
    s += chartorune(p, s);
    for(;;) {
        if(*p == '\\')
            s += chartorune(p, s);
        if(*p == 0)
            break;
        p[1] = *p;
        p += 2;
        if(p >= pairs + nelem(pairs) - 2)
            error("class too big");
        s += chartorune(p, s);
        if(*p != '-')
            continue;
        s += chartorune(p, s);
        if(*p == '\\')
            s += chartorune(p, s);
        if(*p == 0)
            break;
        p[-1] = *p;
        s += chartorune(p, s);
    }
    *p = 0;
    qsort(pairs, (p-pairs)/2, 2*sizeof(*pairs), pcmp);

    q = pairs;
    for(p=pairs+2; *p; p+=2) {
        if(p[0] > p[1])
            continue;
        if(p[0] > q[1] || p[1] < q[0]) {
            q[2] = p[0];
            q[3] = p[1];
            q += 2;
            continue;
        }
        if(p[0] < q[0])
            q[0] = p[0];
        if(p[1] > q[1])
            q[1] = p[1];
    }
    q[2] = 0;

    p = pairs;
    if(nc) {
        x = rclass(0, p[0]-1);
        ov = p[1]+1;
        for(p+=2; *p; p+=2) {
            x = re2or(x, rclass(ov, p[0]-1));
            ov = p[1]+1;
        }
        x = re2or(x, rclass(ov, Runemask));
    } else {
        x = rclass(p[0], p[1]);
        for(p+=2; *p; p+=2)
            x = re2or(x, rclass(p[0], p[1]));
    }
    return x;
}
@

\section{[[text/awk/]]}

\subsection{[[awk/awk.h]]}

<<awk/awk.h>>=
/*
Copyright (c) Lucent Technologies 1997
    All Rights Reserved

*/

typedef double  Awkfloat;

/* unsigned char is more trouble than it's worth */

typedef unsigned char uschar;

#define xfree(a)    { if ((a) != NULL) { free((char *) a); a = NULL; } }

#define DEBUG
#ifdef  DEBUG
            /* uses have to be doubly parenthesized */
#   define  dprintf(x)  if (dbg) printf x
#else
#   define  dprintf(x)
#endif

extern  char    errbuf[];

extern int  compile_time;   /* 1 if compiling, 0 if running */
extern int  safe;       /* 0 => unsafe, 1 => safe */

#define RECSIZE (8 * 1024)  /* sets limit on records, fields, etc., etc. */
extern int  recsize;    /* size of current record, orig RECSIZE */

extern char **FS;
extern char **RS;
extern char **ORS;
extern char **OFS;
extern char **OFMT;
extern Awkfloat *NR;
extern Awkfloat *FNR;
extern Awkfloat *NF;
extern char **FILENAME;
extern char **SUBSEP;
extern Awkfloat *RSTART;
extern Awkfloat *RLENGTH;

extern char *record;    /* points to $0 */
extern int  lineno;     /* line number in awk program */
extern int  errorflag;  /* 1 if error has occurred */
extern int  donefld;    /* 1 if record broken into fields */
extern int  donerec;    /* 1 if record is valid (no fld has changed */
extern char inputFS[];  /* FS at time of input, for field splitting */

extern int  dbg;

extern  char    *patbeg;    /* beginning of pattern matched */
extern  int patlen;     /* length of pattern matched.  set in b.c */

/* Cell:  all information about a variable or constant */

typedef struct Cell {
    uschar  ctype;      /* OCELL, OBOOL, OJUMP, etc. */
    uschar  csub;       /* CCON, CTEMP, CFLD, etc. */
    char    *nval;      /* name, for variables only */
    char    *sval;      /* string value */
    Awkfloat fval;      /* value as number */
    int  tval;      /* type info: STR|NUM|ARR|FCN|FLD|CON|DONTFREE */
    struct Cell *cnext; /* ptr to next if chained */
} Cell;

typedef struct Array {      /* symbol table array */
    int nelem;      /* elements in table right now */
    int size;       /* size of tab */
    Cell    **tab;      /* hash table pointers */
} Array;

#define NSYMTAB 50  /* initial size of a symbol table */
extern Array    *symtab;

extern Cell *nrloc;     /* NR */
extern Cell *fnrloc;    /* FNR */
extern Cell *nfloc;     /* NF */
extern Cell *rstartloc; /* RSTART */
extern Cell *rlengthloc;    /* RLENGTH */

/* Cell.tval values: */
#define NUM 01  /* number value is valid */
#define STR 02  /* string value is valid */
#define DONTFREE 04 /* string space is not freeable */
#define CON 010 /* this is a constant */
#define ARR 020 /* this is an array */
#define FCN 040 /* this is a function name */
#define FLD 0100    /* this is a field $1, $2, ... */
#define REC 0200    /* this is $0 */


/* function types */
#define FLENGTH 1
#define FSQRT   2
#define FEXP    3
#define FLOG    4
#define FINT    5
#define FSYSTEM 6
#define FRAND   7
#define FSRAND  8
#define FSIN    9
#define FCOS    10
#define FATAN   11
#define FTOUPPER 12
#define FTOLOWER 13
#define FFLUSH  14
#define FUTF    15

/* Node:  parse tree is made of nodes, with Cell's at bottom */

typedef struct Node {
    int ntype;
    struct  Node *nnext;
    int lineno;
    int nobj;
    struct  Node *narg[1];  /* variable: actual size set by calling malloc */
} Node;

#define NIL ((Node *) 0)

extern Node *winner;
extern Node *nullstat;
extern Node *nullnode;

/* ctypes */
#define OCELL   1
#define OBOOL   2
#define OJUMP   3

/* Cell subtypes: csub */
#define CFREE   7
#define CCOPY   6
#define CCON    5
#define CTEMP   4
#define CNAME   3 
#define CVAR    2
#define CFLD    1
#define CUNK    0

/* bool subtypes */
#define BTRUE   11
#define BFALSE  12

/* jump subtypes */
#define JEXIT   21
#define JNEXT   22
#define JBREAK  23
#define JCONT   24
#define JRET    25
#define JNEXTFILE   26

/* node types */
#define NVALUE  1
#define NSTAT   2
#define NEXPR   3


extern  int pairstack[], paircnt;

#define notlegal(n) (n <= FIRSTTOKEN || n >= LASTTOKEN || proctab[n-FIRSTTOKEN] == nullproc)
#define isvalue(n)  ((n)->ntype == NVALUE)
#define isexpr(n)   ((n)->ntype == NEXPR)
#define isjump(n)   ((n)->ctype == OJUMP)
#define isexit(n)   ((n)->csub == JEXIT)
#define isbreak(n)  ((n)->csub == JBREAK)
#define iscont(n)   ((n)->csub == JCONT)
#define isnext(n)   ((n)->csub == JNEXT)
#define isnextfile(n)   ((n)->csub == JNEXTFILE)
#define isret(n)    ((n)->csub == JRET)
#define isrec(n)    ((n)->tval & REC)
#define isfld(n)    ((n)->tval & FLD)
#define isstr(n)    ((n)->tval & STR)
#define isnum(n)    ((n)->tval & NUM)
#define isarr(n)    ((n)->tval & ARR)
#define isfcn(n)    ((n)->tval & FCN)
#define istrue(n)   ((n)->csub == BTRUE)
#define istemp(n)   ((n)->csub == CTEMP)
#define isargument(n)   ((n)->nobj == ARG)
/* #define freeable(p)  (!((p)->tval & DONTFREE)) */
#define freeable(p) ( ((p)->tval & (STR|DONTFREE)) == STR )

#include "proto.h"
@

\subsection{[[awk/awkgram.y]]}

<<awk/awkgram.y>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

%{
#include <stdio.h>
#include <string.h>
#include "awk.h"

#define makedfa(a,b)    compre(a)

void checkdup(Node *list, Cell *item);
int yywrap(void) { return(1); }

Node    *beginloc = 0;
Node    *endloc = 0;
int infunc  = 0;    /* = 1 if in arglist or body of func */
int inloop  = 0;    /* = 1 if in while, for, do */
char    *curfname = 0;  /* current function name */
Node    *arglist = 0;   /* list of args for current function */
%}

%union {
    Node    *p;
    Cell    *cp;
    int i;
    char    *s;
}

%token  <i> FIRSTTOKEN  /* must be first */
%token  <p> PROGRAM PASTAT PASTAT2 XBEGIN XEND
%token  <i> NL ',' '{' '(' '|' ';' '/' ')' '}' '[' ']'
%token  <i> ARRAY
%token  <i> MATCH NOTMATCH MATCHOP
%token  <i> FINAL DOT ALL CCL NCCL CHAR OR STAR QUEST PLUS
%token  <i> AND BOR APPEND EQ GE GT LE LT NE IN
%token  <i> ARG BLTIN BREAK CLOSE CONTINUE DELETE DO EXIT FOR FUNC 
%token  <i> SUB GSUB IF INDEX LSUBSTR MATCHFCN NEXT NEXTFILE
%token  <i> ADD MINUS MULT DIVIDE MOD
%token  <i> ASSIGN ASGNOP ADDEQ SUBEQ MULTEQ DIVEQ MODEQ POWEQ
%token  <i> PRINT PRINTF SPRINTF
%token  <p> ELSE INTEST CONDEXPR
%token  <i> POSTINCR PREINCR POSTDECR PREDECR
%token  <cp>    VAR IVAR VARNF CALL NUMBER STRING
%token  <s> REGEXPR

%type   <p> pas pattern ppattern plist pplist patlist prarg term re
%type   <p> pa_pat pa_stat pa_stats
%type   <s> reg_expr
%type   <p> simple_stmt opt_simple_stmt stmt stmtlist
%type   <p> var varname funcname varlist
%type   <p> for if else while
%type   <i> do st
%type   <i> pst opt_pst lbrace rbrace rparen comma nl opt_nl and bor
%type   <i> subop print

%right  ASGNOP
%right  '?'
%right  ':'
%left   BOR
%left   AND
%left   GETLINE
%nonassoc APPEND EQ GE GT LE LT NE MATCHOP IN '|'
%left   ARG BLTIN BREAK CALL CLOSE CONTINUE DELETE DO EXIT FOR FUNC 
%left   GSUB IF INDEX LSUBSTR MATCHFCN NEXT NUMBER
%left   PRINT PRINTF RETURN SPLIT SPRINTF STRING SUB SUBSTR
%left   REGEXPR VAR VARNF IVAR WHILE '('
%left   CAT
%left   '+' '-'
%left   '*' '/' '%'
%left   NOT UMINUS
%right  POWER
%right  DECR INCR
%left   INDIRECT
%token  LASTTOKEN   /* must be last */

%%

program:
      pas   { if (errorflag==0)
            winner = (Node *)stat3(PROGRAM, beginloc, $1, endloc); }
    | error { yyclearin; bracecheck(); SYNTAX("bailing out"); }
    ;

and:
      AND | and NL
    ;

bor:
      BOR | bor NL
    ;

comma:
      ',' | comma NL
    ;

do:
      DO | do NL
    ;

else:
      ELSE | else NL
    ;

for:
      FOR '(' opt_simple_stmt ';' opt_nl pattern ';' opt_nl opt_simple_stmt rparen {inloop++;} stmt
        { --inloop; $$ = stat4(FOR, $3, notnull($6), $9, $12); }
    | FOR '(' opt_simple_stmt ';'  ';' opt_nl opt_simple_stmt rparen {inloop++;} stmt
        { --inloop; $$ = stat4(FOR, $3, NIL, $7, $10); }
    | FOR '(' varname IN varname rparen {inloop++;} stmt
        { --inloop; $$ = stat3(IN, $3, makearr($5), $8); }
    ;

funcname:
      VAR   { setfname($1); }
    | CALL  { setfname($1); }
    ;

if:
      IF '(' pattern rparen     { $$ = notnull($3); }
    ;

lbrace:
      '{' | lbrace NL
    ;

nl:
      NL | nl NL
    ;

opt_nl:
      /* empty */   { $$ = 0; }
    | nl
    ;

opt_pst:
      /* empty */   { $$ = 0; }
    | pst
    ;


opt_simple_stmt:
      /* empty */           { $$ = 0; }
    | simple_stmt
    ;

pas:
      opt_pst           { $$ = 0; }
    | opt_pst pa_stats opt_pst  { $$ = $2; }
    ;

pa_pat:
      pattern   { $$ = notnull($1); }
    ;

pa_stat:
      pa_pat            { $$ = stat2(PASTAT, $1, stat2(PRINT, rectonode(), NIL)); }
    | pa_pat lbrace stmtlist '}'    { $$ = stat2(PASTAT, $1, $3); }
    | pa_pat ',' pa_pat     { $$ = pa2stat($1, $3, stat2(PRINT, rectonode(), NIL)); }
    | pa_pat ',' pa_pat lbrace stmtlist '}' { $$ = pa2stat($1, $3, $5); }
    | lbrace stmtlist '}'       { $$ = stat2(PASTAT, NIL, $2); }
    | XBEGIN lbrace stmtlist '}'
        { beginloc = linkum(beginloc, $3); $$ = 0; }
    | XEND lbrace stmtlist '}'
        { endloc = linkum(endloc, $3); $$ = 0; }
    | FUNC funcname '(' varlist rparen {infunc++;} lbrace stmtlist '}'
        { infunc--; curfname=0; defn((Cell *)$2, $4, $8); $$ = 0; }
    ;

pa_stats:
      pa_stat
    | pa_stats opt_pst pa_stat  { $$ = linkum($1, $3); }
    ;

patlist:
      pattern
    | patlist comma pattern     { $$ = linkum($1, $3); }
    ;

ppattern:
      var ASGNOP ppattern       { $$ = op2($2, $1, $3); }
    | ppattern '?' ppattern ':' ppattern %prec '?'
        { $$ = op3(CONDEXPR, notnull($1), $3, $5); }
    | ppattern bor ppattern %prec BOR
        { $$ = op2(BOR, notnull($1), notnull($3)); }
    | ppattern and ppattern %prec AND
        { $$ = op2(AND, notnull($1), notnull($3)); }
    | ppattern MATCHOP reg_expr { $$ = op3($2, NIL, $1, (Node*)makedfa($3, 0)); }
    | ppattern MATCHOP ppattern
        { if (constnode($3))
            $$ = op3($2, NIL, $1, (Node*)makedfa(strnode($3), 0));
          else
            $$ = op3($2, (Node *)1, $1, $3); }
    | ppattern IN varname       { $$ = op2(INTEST, $1, makearr($3)); }
    | '(' plist ')' IN varname  { $$ = op2(INTEST, $2, makearr($5)); }
    | ppattern term %prec CAT   { $$ = op2(CAT, $1, $2); }
    | re
    | term
    ;

pattern:
      var ASGNOP pattern        { $$ = op2($2, $1, $3); }
    | pattern '?' pattern ':' pattern %prec '?'
        { $$ = op3(CONDEXPR, notnull($1), $3, $5); }
    | pattern bor pattern %prec BOR
        { $$ = op2(BOR, notnull($1), notnull($3)); }
    | pattern and pattern %prec AND
        { $$ = op2(AND, notnull($1), notnull($3)); }
    | pattern EQ pattern        { $$ = op2($2, $1, $3); }
    | pattern GE pattern        { $$ = op2($2, $1, $3); }
    | pattern GT pattern        { $$ = op2($2, $1, $3); }
    | pattern LE pattern        { $$ = op2($2, $1, $3); }
    | pattern LT pattern        { $$ = op2($2, $1, $3); }
    | pattern NE pattern        { $$ = op2($2, $1, $3); }
    | pattern MATCHOP reg_expr  { $$ = op3($2, NIL, $1, (Node*)makedfa($3, 0)); }
    | pattern MATCHOP pattern
        { if (constnode($3))
            $$ = op3($2, NIL, $1, (Node*)makedfa(strnode($3), 0));
          else
            $$ = op3($2, (Node *)1, $1, $3); }
    | pattern IN varname        { $$ = op2(INTEST, $1, makearr($3)); }
    | '(' plist ')' IN varname  { $$ = op2(INTEST, $2, makearr($5)); }
    | pattern '|' GETLINE var   { 
            if (safe) SYNTAX("cmd | getline is unsafe");
            else $$ = op3(GETLINE, $4, itonp($2), $1); }
    | pattern '|' GETLINE       { 
            if (safe) SYNTAX("cmd | getline is unsafe");
            else $$ = op3(GETLINE, (Node*)0, itonp($2), $1); }
    | pattern term %prec CAT    { $$ = op2(CAT, $1, $2); }
    | re
    | term
    ;

plist:
      pattern comma pattern     { $$ = linkum($1, $3); }
    | plist comma pattern       { $$ = linkum($1, $3); }
    ;

pplist:
      ppattern
    | pplist comma ppattern     { $$ = linkum($1, $3); }
    ;

prarg:
      /* empty */           { $$ = rectonode(); }
    | pplist
    | '(' plist ')'         { $$ = $2; }
    ;

print:
      PRINT | PRINTF
    ;

pst:
      NL | ';' | pst NL | pst ';'
    ;

rbrace:
      '}' | rbrace NL
    ;

re:
       reg_expr
        { $$ = op3(MATCH, NIL, rectonode(), (Node*)makedfa($1, 0)); }
    | NOT re    { $$ = op1(NOT, notnull($2)); }
    ;

reg_expr:
      '/' {startreg();} REGEXPR '/'     { $$ = $3; }
    ;

rparen:
      ')' | rparen NL
    ;

simple_stmt:
      print prarg '|' term      { 
            if (safe) SYNTAX("print | is unsafe");
            else $$ = stat3($1, $2, itonp($3), $4); }
    | print prarg APPEND term   {
            if (safe) SYNTAX("print >> is unsafe");
            else $$ = stat3($1, $2, itonp($3), $4); }
    | print prarg GT term       {
            if (safe) SYNTAX("print > is unsafe");
            else $$ = stat3($1, $2, itonp($3), $4); }
    | print prarg           { $$ = stat3($1, $2, NIL, NIL); }
    | DELETE varname '[' patlist ']' { $$ = stat2(DELETE, makearr($2), $4); }
    | DELETE varname         { $$ = stat2(DELETE, makearr($2), 0); }
    | pattern           { $$ = exptostat($1); }
    | error             { yyclearin; SYNTAX("illegal statement"); }
    ;

st:
      nl
    | ';' opt_nl
    ;

stmt:
      BREAK st      { if (!inloop) SYNTAX("break illegal outside of loops");
                  $$ = stat1(BREAK, NIL); }
    | CLOSE pattern st  { $$ = stat1(CLOSE, $2); }
    | CONTINUE st       {  if (!inloop) SYNTAX("continue illegal outside of loops");
                  $$ = stat1(CONTINUE, NIL); }
    | do {inloop++;} stmt {--inloop;} WHILE '(' pattern ')' st
        { $$ = stat2(DO, $3, notnull($7)); }
    | EXIT pattern st   { $$ = stat1(EXIT, $2); }
    | EXIT st       { $$ = stat1(EXIT, NIL); }
    | for
    | if stmt else stmt { $$ = stat3(IF, $1, $2, $4); }
    | if stmt       { $$ = stat3(IF, $1, $2, NIL); }
    | lbrace stmtlist rbrace { $$ = $2; }
    | NEXT st   { if (infunc)
                SYNTAX("next is illegal inside a function");
              $$ = stat1(NEXT, NIL); }
    | NEXTFILE st   { if (infunc)
                SYNTAX("nextfile is illegal inside a function");
              $$ = stat1(NEXTFILE, NIL); }
    | RETURN pattern st { $$ = stat1(RETURN, $2); }
    | RETURN st     { $$ = stat1(RETURN, NIL); }
    | simple_stmt st
    | while {inloop++;} stmt    { --inloop; $$ = stat2(WHILE, $1, $3); }
    | ';' opt_nl        { $$ = 0; }
    ;

stmtlist:
      stmt
    | stmtlist stmt     { $$ = linkum($1, $2); }
    ;

subop:
      SUB | GSUB
    ;

term:
      term '/' ASGNOP term      { $$ = op2(DIVEQ, $1, $4); }
    | term '+' term         { $$ = op2(ADD, $1, $3); }
    | term '-' term         { $$ = op2(MINUS, $1, $3); }
    | term '*' term         { $$ = op2(MULT, $1, $3); }
    | term '/' term         { $$ = op2(DIVIDE, $1, $3); }
    | term '%' term         { $$ = op2(MOD, $1, $3); }
    | term POWER term       { $$ = op2(POWER, $1, $3); }
    | '-' term %prec UMINUS     { $$ = op1(UMINUS, $2); }
    | '+' term %prec UMINUS     { $$ = $2; }
    | NOT term %prec UMINUS     { $$ = op1(NOT, notnull($2)); }
    | BLTIN '(' ')'         { $$ = op2(BLTIN, itonp($1), rectonode()); }
    | BLTIN '(' patlist ')'     { $$ = op2(BLTIN, itonp($1), $3); }
    | BLTIN             { $$ = op2(BLTIN, itonp($1), rectonode()); }
    | CALL '(' ')'          { $$ = op2(CALL, celltonode($1,CVAR), NIL); }
    | CALL '(' patlist ')'      { $$ = op2(CALL, celltonode($1,CVAR), $3); }
    | DECR var          { $$ = op1(PREDECR, $2); }
    | INCR var          { $$ = op1(PREINCR, $2); }
    | var DECR          { $$ = op1(POSTDECR, $1); }
    | var INCR          { $$ = op1(POSTINCR, $1); }
    | GETLINE var LT term       { $$ = op3(GETLINE, $2, itonp($3), $4); }
    | GETLINE LT term       { $$ = op3(GETLINE, NIL, itonp($2), $3); }
    | GETLINE var           { $$ = op3(GETLINE, $2, NIL, NIL); }
    | GETLINE           { $$ = op3(GETLINE, NIL, NIL, NIL); }
    | INDEX '(' pattern comma pattern ')'
        { $$ = op2(INDEX, $3, $5); }
    | INDEX '(' pattern comma reg_expr ')'
        { SYNTAX("index() doesn't permit regular expressions");
          $$ = op2(INDEX, $3, (Node*)$5); }
    | '(' pattern ')'       { $$ = $2; }
    | MATCHFCN '(' pattern comma reg_expr ')'
        { $$ = op3(MATCHFCN, NIL, $3, (Node*)makedfa($5, 1)); }
    | MATCHFCN '(' pattern comma pattern ')'
        { if (constnode($5))
            $$ = op3(MATCHFCN, NIL, $3, (Node*)makedfa(strnode($5), 1));
          else
            $$ = op3(MATCHFCN, (Node *)1, $3, $5); }
    | NUMBER            { $$ = celltonode($1, CCON); }
    | SPLIT '(' pattern comma varname comma pattern ')'     /* string */
        { $$ = op4(SPLIT, $3, makearr($5), $7, (Node*)STRING); }
    | SPLIT '(' pattern comma varname comma reg_expr ')'    /* const /regexp/ */
        { $$ = op4(SPLIT, $3, makearr($5), (Node*)makedfa($7, 1), (Node *)REGEXPR); }
    | SPLIT '(' pattern comma varname ')'
        { $$ = op4(SPLIT, $3, makearr($5), NIL, (Node*)STRING); }  /* default */
    | SPRINTF '(' patlist ')'   { $$ = op1($1, $3); }
    | STRING            { $$ = celltonode($1, CCON); }
    | subop '(' reg_expr comma pattern ')'
        { $$ = op4($1, NIL, (Node*)makedfa($3, 1), $5, rectonode()); }
    | subop '(' pattern comma pattern ')'
        { if (constnode($3))
            $$ = op4($1, NIL, (Node*)makedfa(strnode($3), 1), $5, rectonode());
          else
            $$ = op4($1, (Node *)1, $3, $5, rectonode()); }
    | subop '(' reg_expr comma pattern comma var ')'
        { $$ = op4($1, NIL, (Node*)makedfa($3, 1), $5, $7); }
    | subop '(' pattern comma pattern comma var ')'
        { if (constnode($3))
            $$ = op4($1, NIL, (Node*)makedfa(strnode($3), 1), $5, $7);
          else
            $$ = op4($1, (Node *)1, $3, $5, $7); }
    | SUBSTR '(' pattern comma pattern comma pattern ')'
        { $$ = op3(SUBSTR, $3, $5, $7); }
    | SUBSTR '(' pattern comma pattern ')'
        { $$ = op3(SUBSTR, $3, $5, NIL); }
    | var
    ;

var:
      varname
    | varname '[' patlist ']'   { $$ = op2(ARRAY, makearr($1), $3); }
    | IVAR              { $$ = op1(INDIRECT, celltonode($1, CVAR)); }
    | INDIRECT term         { $$ = op1(INDIRECT, $2); }
    ;   

varlist:
      /* nothing */     { arglist = $$ = 0; }
    | VAR           { arglist = $$ = celltonode($1,CVAR); }
    | varlist comma VAR {
            checkdup($1, $3);
            arglist = $$ = linkum($1,celltonode($3,CVAR)); }
    ;

varname:
      VAR           { $$ = celltonode($1, CVAR); }
    | ARG           { $$ = op1(ARG, itonp($1)); }
    | VARNF         { $$ = op1(VARNF, (Node *) $1); }
    ;


while:
      WHILE '(' pattern rparen  { $$ = notnull($3); }
    ;

%%

void setfname(Cell *p)
{
    if (isarr(p))
        SYNTAX("%s is an array, not a function", p->nval);
    else if (isfcn(p))
        SYNTAX("you can't define function %s more than once", p->nval);
    curfname = p->nval;
}

int constnode(Node *p)
{
    return isvalue(p) && ((Cell *) (p->narg[0]))->csub == CCON;
}

char *strnode(Node *p)
{
    return ((Cell *)(p->narg[0]))->sval;
}

Node *notnull(Node *n)
{
    switch (n->nobj) {
    case LE: case LT: case EQ: case NE: case GT: case GE:
    case BOR: case AND: case NOT:
        return n;
    default:
        return op2(NE, n, nullnode);
    }
}

void checkdup(Node *vl, Cell *cp)   /* check if name already in list */
{
    char *s = cp->nval;
    for ( ; vl; vl = vl->nnext) {
        if (strcmp(s, ((Cell *)(vl->narg[0]))->nval) == 0) {
            SYNTAX("duplicate argument %s", s);
            break;
        }
    }
}
@

\subsection{[[awk/lex.c]]}

<<awk/lex.c>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "awk.h"
#include "y.tab.h"

extern YYSTYPE  yylval;
extern int  infunc;

int lineno  = 1;
int bracecnt = 0;
int brackcnt  = 0;
int parencnt = 0;

typedef struct Keyword {
    char    *word;
    int sub;
    int type;
} Keyword;

Keyword keywords[] ={   /* keep sorted: binary searched */
    { "BEGIN",  XBEGIN,     XBEGIN },
    { "END",    XEND,       XEND },
    { "NF",     VARNF,      VARNF },
    { "atan2",  FATAN,      BLTIN },
    { "break",  BREAK,      BREAK },
    { "close",  CLOSE,      CLOSE },
    { "continue",   CONTINUE,   CONTINUE },
    { "cos",    FCOS,       BLTIN },
    { "delete", DELETE,     DELETE },
    { "do",     DO,     DO },
    { "else",   ELSE,       ELSE },
    { "exit",   EXIT,       EXIT },
    { "exp",    FEXP,       BLTIN },
    { "fflush", FFLUSH,     BLTIN },
    { "for",    FOR,        FOR },
    { "func",   FUNC,       FUNC },
    { "function",   FUNC,       FUNC },
    { "getline",    GETLINE,    GETLINE },
    { "gsub",   GSUB,       GSUB },
    { "if",     IF,     IF },
    { "in",     IN,     IN },
    { "index",  INDEX,      INDEX },
    { "int",    FINT,       BLTIN },
    { "length", FLENGTH,    BLTIN },
    { "log",    FLOG,       BLTIN },
    { "match",  MATCHFCN,   MATCHFCN },
    { "next",   NEXT,       NEXT },
    { "nextfile",   NEXTFILE,   NEXTFILE },
    { "print",  PRINT,      PRINT },
    { "printf", PRINTF,     PRINTF },
    { "rand",   FRAND,      BLTIN },
    { "return", RETURN,     RETURN },
    { "sin",    FSIN,       BLTIN },
    { "split",  SPLIT,      SPLIT },
    { "sprintf",    SPRINTF,    SPRINTF },
    { "sqrt",   FSQRT,      BLTIN },
    { "srand",  FSRAND,     BLTIN },
    { "sub",    SUB,        SUB },
    { "substr", SUBSTR,     SUBSTR },
    { "system", FSYSTEM,    BLTIN },
    { "tolower",    FTOLOWER,   BLTIN },
    { "toupper",    FTOUPPER,   BLTIN },
    { "utf",    FUTF,       BLTIN },
    { "while",  WHILE,      WHILE },
};

#define DEBUG
#ifdef  DEBUG
#define RET(x)  { if(dbg)printf("lex %s\n", tokname(x)); return(x); }
#else
#define RET(x)  return(x)
#endif

int peek(void)
{
    int c = input();
    unput(c);
    return c;
}

int gettok(char **pbuf, int *psz)   /* get next input token */
{
    int c;
    char *buf = *pbuf;
    int sz = *psz;
    char *bp = buf;

    c = input();
    if (c == 0)
        return 0;
    buf[0] = c;
    buf[1] = 0;
    if (!isalnum(c) && c != '.' && c != '_')
        return c;

    *bp++ = c;
    if (isalpha(c) || c == '_') {   /* it's a varname */
        for ( ; (c = input()) != 0; ) {
            if (bp-buf >= sz)
                if (!adjbuf(&buf, &sz, bp-buf+2, 100, &bp, 0))
                    FATAL( "out of space for name %.10s...", buf );
            if (isalnum(c) || c == '_')
                *bp++ = c;
            else {
                *bp = 0;
                unput(c);
                break;
            }
        }
    } else {    /* it's a number */
        char *rem;
        /* read input until can't be a number */
        for ( ; (c = input()) != 0; ) {
            if (bp-buf >= sz)
                if (!adjbuf(&buf, &sz, bp-buf+2, 100, &bp, 0))
                    FATAL( "out of space for number %.10s...", buf );
            if (isdigit(c) || c == 'e' || c == 'E' 
              || c == '.' || c == '+' || c == '-')
                *bp++ = c;
            else {
                unput(c);
                break;
            }
        }
        *bp = 0;
        strtod(buf, &rem);  /* parse the number */
        unputstr(rem);      /* put rest back for later */
        rem[0] = 0;
    }
    *pbuf = buf;
    *psz = sz;
    return buf[0];
}

int word(char *);
int string(void);
int regexpr(void);
int sc  = 0;    /* 1 => return a } right now */
int reg = 0;    /* 1 => return a REGEXPR now */

int yylex(void)
{
    int c;
    static char *buf = 0;
    static int bufsize = 500;

    if (buf == 0 && (buf = (char *) malloc(bufsize)) == NULL)
        FATAL( "out of space in yylex" );
    if (sc) {
        sc = 0;
        RET('}');
    }
    if (reg) {
        reg = 0;
        return regexpr();
    }
    for (;;) {
        c = gettok(&buf, &bufsize);
        if (c == 0)
            return 0;
        if (isalpha(c) || c == '_')
            return word(buf);
        if (isdigit(c) || c == '.') {
            yylval.cp = setsymtab(buf, tostring(buf), atof(buf), CON|NUM, symtab);
            /* should this also have STR set? */
            RET(NUMBER);
        }
    
        yylval.i = c;
        switch (c) {
        case '\n':  /* {EOL} */
            RET(NL);
        case '\r':  /* assume \n is coming */
        case ' ':   /* {WS}+ */
        case '\t':
            break;
        case '#':   /* #.* strip comments */
            while ((c = input()) != '\n' && c != 0)
                ;
            unput(c);
            break;
        case ';':
            RET(';');
        case '\\':
            if (peek() == '\n') {
                input();
            } else if (peek() == '\r') {
                input(); input();   /* \n */
                lineno++;
            } else {
                RET(c);
            }
            break;
        case '&':
            if (peek() == '&') {
                input(); RET(AND);
            } else 
                RET('&');
        case '|':
            if (peek() == '|') {
                input(); RET(BOR);
            } else
                RET('|');
        case '!':
            if (peek() == '=') {
                input(); yylval.i = NE; RET(NE);
            } else if (peek() == '~') {
                input(); yylval.i = NOTMATCH; RET(MATCHOP);
            } else
                RET(NOT);
        case '~':
            yylval.i = MATCH;
            RET(MATCHOP);
        case '<':
            if (peek() == '=') {
                input(); yylval.i = LE; RET(LE);
            } else {
                yylval.i = LT; RET(LT);
            }
        case '=':
            if (peek() == '=') {
                input(); yylval.i = EQ; RET(EQ);
            } else {
                yylval.i = ASSIGN; RET(ASGNOP);
            }
        case '>':
            if (peek() == '=') {
                input(); yylval.i = GE; RET(GE);
            } else if (peek() == '>') {
                input(); yylval.i = APPEND; RET(APPEND);
            } else {
                yylval.i = GT; RET(GT);
            }
        case '+':
            if (peek() == '+') {
                input(); yylval.i = INCR; RET(INCR);
            } else if (peek() == '=') {
                input(); yylval.i = ADDEQ; RET(ASGNOP);
            } else
                RET('+');
        case '-':
            if (peek() == '-') {
                input(); yylval.i = DECR; RET(DECR);
            } else if (peek() == '=') {
                input(); yylval.i = SUBEQ; RET(ASGNOP);
            } else
                RET('-');
        case '*':
            if (peek() == '=') {    /* *= */
                input(); yylval.i = MULTEQ; RET(ASGNOP);
            } else if (peek() == '*') { /* ** or **= */
                input();    /* eat 2nd * */
                if (peek() == '=') {
                    input(); yylval.i = POWEQ; RET(ASGNOP);
                } else {
                    RET(POWER);
                }
            } else
                RET('*');
        case '/':
            RET('/');
        case '%':
            if (peek() == '=') {
                input(); yylval.i = MODEQ; RET(ASGNOP);
            } else
                RET('%');
        case '^':
            if (peek() == '=') {
                input(); yylval.i = POWEQ; RET(ASGNOP);
            } else
                RET(POWER);
    
        case '$':
            /* BUG: awkward, if not wrong */
            c = gettok(&buf, &bufsize);
            if (c == '(' || c == '[' || (infunc && isarg(buf) >= 0)) {
                unputstr(buf);
                RET(INDIRECT);
            } else if (isalpha(c)) {
                if (strcmp(buf, "NF") == 0) {   /* very special */
                    unputstr("(NF)");
                    RET(INDIRECT);
                }
                yylval.cp = setsymtab(buf, "", 0.0, STR|NUM, symtab);
                RET(IVAR);
            } else {
                unputstr(buf);
                RET(INDIRECT);
            }
    
        case '}':
            if (--bracecnt < 0)
                SYNTAX( "extra }" );
            sc = 1;
            RET(';');
        case ']':
            if (--brackcnt < 0)
                SYNTAX( "extra ]" );
            RET(']');
        case ')':
            if (--parencnt < 0)
                SYNTAX( "extra )" );
            RET(')');
        case '{':
            bracecnt++;
            RET('{');
        case '[':
            brackcnt++;
            RET('[');
        case '(':
            parencnt++;
            RET('(');
    
        case '"':
            return string();    /* BUG: should be like tran.c ? */
    
        default:
            RET(c);
        }
    }
}

int string(void)
{
    int c, n;
    char *s, *bp;
    static char *buf = 0;
    static int bufsz = 500;

    if (buf == 0 && (buf = (char *) malloc(bufsz)) == NULL)
        FATAL("out of space for strings");
    for (bp = buf; (c = input()) != '"'; ) {
        if (!adjbuf(&buf, &bufsz, bp-buf+2, 500, &bp, 0))
            FATAL("out of space for string %.10s...", buf);
        switch (c) {
        case '\n':
        case '\r':
        case 0:
            SYNTAX( "non-terminated string %.10s...", buf );
            lineno++;
            break;
        case '\\':
            c = input();
            switch (c) {
            case '"': *bp++ = '"'; break;
            case 'n': *bp++ = '\n'; break;  
            case 't': *bp++ = '\t'; break;
            case 'f': *bp++ = '\f'; break;
            case 'r': *bp++ = '\r'; break;
            case 'b': *bp++ = '\b'; break;
            case 'v': *bp++ = '\v'; break;
            case 'a': *bp++ = '\007'; break;
            case '\\': *bp++ = '\\'; break;

            case '0': case '1': case '2': /* octal: \d \dd \ddd */
            case '3': case '4': case '5': case '6': case '7':
                n = c - '0';
                if ((c = peek()) >= '0' && c < '8') {
                    n = 8 * n + input() - '0';
                    if ((c = peek()) >= '0' && c < '8')
                        n = 8 * n + input() - '0';
                }
                *bp++ = n;
                break;

            case 'x':   /* hex  \x0-9a-fA-F + */
                {   char xbuf[100], *px;
                for (px = xbuf; (c = input()) != 0 && px-xbuf < 100-2; ) {
                    if (isdigit(c)
                     || (c >= 'a' && c <= 'f')
                     || (c >= 'A' && c <= 'F'))
                        *px++ = c;
                    else
                        break;
                }
                *px = 0;
                unput(c);
                sscanf(xbuf, "%x", &n);
                *bp++ = n;
                break;
                }

            default: 
                *bp++ = c;
                break;
            }
            break;
        default:
            *bp++ = c;
            break;
        }
    }
    *bp = 0; 
    s = tostring(buf);
    *bp++ = ' '; *bp++ = 0;
    yylval.cp = setsymtab(buf, s, 0.0, CON|STR|DONTFREE, symtab);
    RET(STRING);
}


int binsearch(char *w, Keyword *kp, int n)
{
    int cond, low, mid, high;

    low = 0;
    high = n - 1;
    while (low <= high) {
        mid = (low + high) / 2;
        if ((cond = strcmp(w, kp[mid].word)) < 0)
            high = mid - 1;
        else if (cond > 0)
            low = mid + 1;
        else
            return mid;
    }
    return -1;
}

int word(char *w) 
{
    Keyword *kp;
    int c, n;

    n = binsearch(w, keywords, sizeof(keywords)/sizeof(keywords[0]));
    kp = keywords + n;
    if (n != -1) {  /* found in table */
        yylval.i = kp->sub;
        switch (kp->type) { /* special handling */
        case FSYSTEM:
            if (safe)
                SYNTAX( "system is unsafe" );
            RET(kp->type);
        case FUNC:
            if (infunc)
                SYNTAX( "illegal nested function" );
            RET(kp->type);
        case RETURN:
            if (!infunc)
                SYNTAX( "return not in function" );
            RET(kp->type);
        case VARNF:
            yylval.cp = setsymtab("NF", "", 0.0, NUM, symtab);
            RET(VARNF);
        default:
            RET(kp->type);
        }
    }
    c = peek(); /* look for '(' */
    if (c != '(' && infunc && (n=isarg(w)) >= 0) {
        yylval.i = n;
        RET(ARG);
    } else {
        yylval.cp = setsymtab(w, "", 0.0, STR|NUM|DONTFREE, symtab);
        if (c == '(') {
            RET(CALL);
        } else {
            RET(VAR);
        }
    }
}

void startreg(void) /* next call to yyles will return a regular expression */
{
    reg = 1;
}

int regexpr(void)
{
    int c;
    static char *buf = 0;
    static int bufsz = 500;
    char *bp;

    if (buf == 0 && (buf = (char *) malloc(bufsz)) == NULL)
        FATAL("out of space for rex expr");
    bp = buf;
    for ( ; (c = input()) != '/' && c != 0; ) {
        if (!adjbuf(&buf, &bufsz, bp-buf+3, 500, &bp, 0))
            FATAL("out of space for reg expr %.10s...", buf);
        if (c == '\n') {
            SYNTAX( "newline in regular expression %.10s...", buf ); 
            unput('\n');
            break;
        } else if (c == '\\') {
            *bp++ = '\\'; 
            *bp++ = input();
        } else {
            *bp++ = c;
        }
    }
    *bp = 0;
    yylval.s = tostring(buf);
    unput('/');
    RET(REGEXPR);
}

/* low-level lexical stuff, sort of inherited from lex */

char    ebuf[300];
char    *ep = ebuf;
char    yysbuf[100];    /* pushback buffer */
char    *yysptr = yysbuf;
FILE    *yyin = 0;

int input(void) /* get next lexical input character */
{
    int c;
    extern char *lexprog;

    if (yysptr > yysbuf)
        c = *--yysptr;
    else if (lexprog != NULL) { /* awk '...' */
        if ((c = *lexprog) != 0)
            lexprog++;
    } else              /* awk -f ... */
        c = pgetc();
    if (c == '\n')
        lineno++;
    else if (c == EOF)
        c = 0;
    if (ep >= ebuf + sizeof ebuf)
        ep = ebuf;
    return *ep++ = c;
}

void unput(int c)   /* put lexical character back on input */
{
    if (c == '\n')
        lineno--;
    if (yysptr >= yysbuf + sizeof(yysbuf))
        FATAL("pushed back too much: %.20s...", yysbuf);
    *yysptr++ = c;
    if (--ep < ebuf)
        ep = ebuf + sizeof(ebuf) - 1;
}

void unputstr(char *s)  /* put a string back on input */
{
    int i;

    for (i = strlen(s)-1; i >= 0; i--)
        unput(s[i]);
}
@

\subsection{[[awk/lib.c]]}

<<awk/lib.c>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#define DEBUG
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <stdarg.h>
#include "awk.h"
#include "y.tab.h"

FILE    *infile = NULL;
char    *file   = "";
char    *record;
int recsize = RECSIZE;
char    *fields;
int fieldssize = RECSIZE;

Cell    **fldtab;   /* pointers to Cells */
char    inputFS[100] = " ";

#define MAXFLD  200
int nfields = MAXFLD;   /* last allocated slot for $i */

int donefld;    /* 1 = implies rec broken into fields */
int donerec;    /* 1 = record is valid (no flds have changed) */

int lastfld = 0;    /* last used field */
int argno   = 1;    /* current input argument number */
extern  Awkfloat *ARGC;

static Cell dollar0 = { OCELL, CFLD, NULL, "", 0.0, REC|STR|DONTFREE };
static Cell dollar1 = { OCELL, CFLD, NULL, "", 0.0, FLD|STR|DONTFREE };

void recinit(unsigned int n)
{
    record = (char *) malloc(n);
    fields = (char *) malloc(n);
    fldtab = (Cell **) malloc((nfields+1) * sizeof(Cell *));
    if (record == NULL || fields == NULL || fldtab == NULL)
        FATAL("out of space for $0 and fields");
    fldtab[0] = (Cell *) malloc(sizeof (Cell));
    *fldtab[0] = dollar0;
    fldtab[0]->sval = record;
    fldtab[0]->nval = tostring("0");
    makefields(1, nfields);
}

void makefields(int n1, int n2)     /* create $n1..$n2 inclusive */
{
    char temp[50];
    int i;

    for (i = n1; i <= n2; i++) {
        fldtab[i] = (Cell *) malloc(sizeof (struct Cell));
        if (fldtab[i] == NULL)
            FATAL("out of space in makefields %d", i);
        *fldtab[i] = dollar1;
        sprintf(temp, "%d", i);
        fldtab[i]->nval = tostring(temp);
    }
}

void initgetrec(void)
{
    int i;
    char *p;

    for (i = 1; i < *ARGC; i++) {
        if (!isclvar(p = getargv(i))) { /* find 1st real filename */
            setsval(lookup("FILENAME", symtab), getargv(i));
            return;
        }
        setclvar(p);    /* a commandline assignment before filename */
        argno++;
    }
    infile = stdin;     /* no filenames, so use stdin */
}

int getrec(char **pbuf, int *pbufsize, int isrecord)    /* get next input record */
{           /* note: cares whether buf == record */
    int c;
    static int firsttime = 1;
    char *buf = *pbuf;
    int bufsize = *pbufsize;

    if (firsttime) {
        firsttime = 0;
        initgetrec();
    }
       dprintf( ("RS=<%s>, FS=<%s>, ARGC=%g, FILENAME=%s\n",
        *RS, *FS, *ARGC, *FILENAME) );
    if (isrecord) {
        donefld = 0;
        donerec = 1;
    }
    buf[0] = 0;
    while (argno < *ARGC || infile == stdin) {
           dprintf( ("argno=%d, file=|%s|\n", argno, file) );
        if (infile == NULL) {   /* have to open a new file */
            file = getargv(argno);
            if (*file == '\0') {    /* it's been zapped */
                argno++;
                continue;
            }
            if (isclvar(file)) {    /* a var=value arg */
                setclvar(file);
                argno++;
                continue;
            }
            *FILENAME = file;
               dprintf( ("opening file %s\n", file) );
            if (*file == '-' && *(file+1) == '\0')
                infile = stdin;
            else if ((infile = fopen(file, "r")) == NULL)
                FATAL("can't open file %s", file);
            setfval(fnrloc, 0.0);
        }
        c = readrec(&buf, &bufsize, infile);
        if (c != 0 || buf[0] != '\0') { /* normal record */
            if (isrecord) {
                if (freeable(fldtab[0]))
                    xfree(fldtab[0]->sval);
                fldtab[0]->sval = buf;  /* buf == record */
                fldtab[0]->tval = REC | STR | DONTFREE;
                if (is_number(fldtab[0]->sval)) {
                    fldtab[0]->fval = atof(fldtab[0]->sval);
                    fldtab[0]->tval |= NUM;
                }
            }
            setfval(nrloc, nrloc->fval+1);
            setfval(fnrloc, fnrloc->fval+1);
            *pbuf = buf;
            *pbufsize = bufsize;
            return 1;
        }
        /* EOF arrived on this file; set up next */
        if (infile != stdin)
            fclose(infile);
        infile = NULL;
        argno++;
    }
    *pbuf = buf;
    *pbufsize = bufsize;
    return 0;   /* true end of file */
}

void nextfile(void)
{
    if (infile != stdin)
        fclose(infile);
    infile = NULL;
    argno++;
}

int readrec(char **pbuf, int *pbufsize, FILE *inf)  /* read one record into buf */
{
    int sep, c;
    char *rr, *buf = *pbuf;
    int bufsize = *pbufsize;

    if (strlen(*FS) >= sizeof(inputFS))
        FATAL("field separator %.10s... is too long", *FS);
    strcpy(inputFS, *FS);   /* for subsequent field splitting */
    if ((sep = **RS) == 0) {
        sep = '\n';
        while ((c=getc(inf)) == '\n' && c != EOF)   /* skip leading \n's */
            ;
        if (c != EOF)
            ungetc(c, inf);
    }
    for (rr = buf; ; ) {
        for (; (c=getc(inf)) != sep && c != EOF; ) {
            if (rr-buf+1 > bufsize)
                if (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, "readrec 1"))
                    FATAL("input record `%.30s...' too long", buf);
            *rr++ = c;
        }
        if (**RS == sep || c == EOF)
            break;
        if ((c = getc(inf)) == '\n' || c == EOF) /* 2 in a row */
            break;
        if (!adjbuf(&buf, &bufsize, 2+rr-buf, recsize, &rr, "readrec 2"))
            FATAL("input record `%.30s...' too long", buf);
        *rr++ = '\n';
        *rr++ = c;
    }
    if (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, "readrec 3"))
        FATAL("input record `%.30s...' too long", buf);
    *rr = 0;
       dprintf( ("readrec saw <%s>, returns %d\n", buf, c == EOF && rr == buf ? 0 : 1) );
    *pbuf = buf;
    *pbufsize = bufsize;
    return c == EOF && rr == buf ? 0 : 1;
}

char *getargv(int n)    /* get ARGV[n] */
{
    Cell *x;
    char *s, temp[50];
    extern Array *ARGVtab;

    sprintf(temp, "%d", n);
    x = setsymtab(temp, "", 0.0, STR, ARGVtab);
    s = getsval(x);
       dprintf( ("getargv(%d) returns |%s|\n", n, s) );
    return s;
}

void setclvar(char *s)  /* set var=value from s */
{
    char *p;
    Cell *q;

    for (p=s; *p != '='; p++)
        ;
    *p++ = 0;
    p = qstring(p, '\0');
    q = setsymtab(s, p, 0.0, STR, symtab);
    setsval(q, p);
    if (is_number(q->sval)) {
        q->fval = atof(q->sval);
        q->tval |= NUM;
    }
       dprintf( ("command line set %s to |%s|\n", s, p) );
}


void fldbld(void)   /* create fields from current record */
{
    /* this relies on having fields[] the same length as $0 */
    /* the fields are all stored in this one array with \0's */
    char *r, *fr, sep;
    Cell *p;
    int i, j, n;

    if (donefld)
        return;
    if (!isstr(fldtab[0]))
        getsval(fldtab[0]);
    r = fldtab[0]->sval;
    n = strlen(r);
    if (n > fieldssize) {
        xfree(fields);
        if ((fields = (char *) malloc(n+1)) == NULL)
            FATAL("out of space for fields in fldbld %d", n);
        fieldssize = n;
    }
    fr = fields;
    i = 0;  /* number of fields accumulated here */
    if (strlen(inputFS) > 1) {  /* it's a regular expression */
        i = refldbld(r, inputFS);
    } else if ((sep = *inputFS) == ' ') {   /* default whitespace */
        for (i = 0; ; ) {
            while (*r == ' ' || *r == '\t' || *r == '\n')
                r++;
            if (*r == 0)
                break;
            i++;
            if (i > nfields)
                growfldtab(i);
            if (freeable(fldtab[i]))
                xfree(fldtab[i]->sval);
            fldtab[i]->sval = fr;
            fldtab[i]->tval = FLD | STR | DONTFREE;
            do
                *fr++ = *r++;
            while (*r != ' ' && *r != '\t' && *r != '\n' && *r != '\0');
            *fr++ = 0;
        }
        *fr = 0;
    } else if ((sep = *inputFS) == 0) {     /* new: FS="" => 1 char/field */
        for (i = 0; *r != 0; r++) {
            char buf[2];
            i++;
            if (i > nfields)
                growfldtab(i);
            if (freeable(fldtab[i]))
                xfree(fldtab[i]->sval);
            buf[0] = *r;
            buf[1] = 0;
            fldtab[i]->sval = tostring(buf);
            fldtab[i]->tval = FLD | STR;
        }
        *fr = 0;
    } else if (*r != 0) {   /* if 0, it's a null field */
        for (;;) {
            i++;
            if (i > nfields)
                growfldtab(i);
            if (freeable(fldtab[i]))
                xfree(fldtab[i]->sval);
            fldtab[i]->sval = fr;
            fldtab[i]->tval = FLD | STR | DONTFREE;
            while (*r != sep && *r != '\n' && *r != '\0')   /* \n is always a separator */
                *fr++ = *r++;
            *fr++ = 0;
            if (*r++ == 0)
                break;
        }
        *fr = 0;
    }
    if (i > nfields)
        FATAL("record `%.30s...' has too many fields; can't happen", r);
    cleanfld(i+1, lastfld); /* clean out junk from previous record */
    lastfld = i;
    donefld = 1;
    for (j = 1; j <= lastfld; j++) {
        p = fldtab[j];
        if(is_number(p->sval)) {
            p->fval = atof(p->sval);
            p->tval |= NUM;
        }
    }
    setfval(nfloc, (Awkfloat) lastfld);
    if (dbg) {
        for (j = 0; j <= lastfld; j++) {
            p = fldtab[j];
            printf("field %d (%s): |%s|\n", j, p->nval, p->sval);
        }
    }
}

void cleanfld(int n1, int n2)   /* clean out fields n1 .. n2 inclusive */
{               /* nvals remain intact */
    Cell *p;
    int i;

    for (i = n1; i <= n2; i++) {
        p = fldtab[i];
        if (freeable(p))
            xfree(p->sval);
        p->sval = "";
        p->tval = FLD | STR | DONTFREE;
    }
}

void newfld(int n)  /* add field n after end of existing lastfld */
{
    if (n > nfields)
        growfldtab(n);
    cleanfld(lastfld+1, n);
    lastfld = n;
    setfval(nfloc, (Awkfloat) n);
}

Cell *fieldadr(int n)   /* get nth field */
{
    if (n < 0)
        FATAL("trying to access field %d", n);
    if (n > nfields)    /* fields after NF are empty */
        growfldtab(n);  /* but does not increase NF */
    return(fldtab[n]);
}

void growfldtab(int n)  /* make new fields up to at least $n */
{
    int nf = 2 * nfields;

    if (n > nf)
        nf = n;
    fldtab = (Cell **) realloc(fldtab, (nf+1) * (sizeof (struct Cell *)));
    if (fldtab == NULL)
        FATAL("out of space creating %d fields", nf);
    makefields(nfields+1, nf);
    nfields = nf;
}

int refldbld(char *rec, char *fs)   /* build fields from reg expr in FS */
{
    /* this relies on having fields[] the same length as $0 */
    /* the fields are all stored in this one array with \0's */
    char *fr;
    void *p;
    int i, tempstat, n;

    n = strlen(rec);
    if (n > fieldssize) {
        xfree(fields);
        if ((fields = (char *) malloc(n+1)) == NULL)
            FATAL("out of space for fields in refldbld %d", n);
        fieldssize = n;
    }
    fr = fields;
    *fr = '\0';
    if (*rec == '\0')
        return 0;
    p = compre(fs);
       dprintf( ("into refldbld, rec = <%s>, pat = <%s>\n", rec, fs) );
    for (i = 1; ; i++) {
        if (i > nfields)
            growfldtab(i);
        if (freeable(fldtab[i]))
            xfree(fldtab[i]->sval);
        fldtab[i]->tval = FLD | STR | DONTFREE;
        fldtab[i]->sval = fr;
           dprintf( ("refldbld: i=%d\n", i) );
        if (nematch(p, rec, rec)) {
               dprintf( ("match %s (%d chars)\n", patbeg, patlen) );
            strncpy(fr, rec, patbeg-rec);
            fr += patbeg - rec + 1;
            *(fr-1) = '\0';
            rec = patbeg + patlen;
        } else {
               dprintf( ("no match %s\n", rec) );
            strcpy(fr, rec);
            break;
        }
    }
    return i;       
}

void recbld(void)   /* create $0 from $1..$NF if necessary */
{
    int i;
    char *r, *p;

    if (donerec == 1)
        return;
    r = record;
    for (i = 1; i <= *NF; i++) {
        p = getsval(fldtab[i]);
        if (!adjbuf(&record, &recsize, 1+strlen(p)+r-record, recsize, &r, "recbld 1"))
            FATAL("created $0 `%.30s...' too long", record);
        while ((*r = *p++) != 0)
            r++;
        if (i < *NF) {
            if (!adjbuf(&record, &recsize, 2+strlen(*OFS)+r-record, recsize, &r, "recbld 2"))
                FATAL("created $0 `%.30s...' too long", record);
            for (p = *OFS; (*r = *p++) != 0; )
                r++;
        }
    }
    if (!adjbuf(&record, &recsize, 2+r-record, recsize, &r, "recbld 3"))
        FATAL("built giant record `%.30s...'", record);
    *r = '\0';
       dprintf( ("in recbld inputFS=%s, fldtab[0]=%p\n", inputFS, fldtab[0]) );

    if (freeable(fldtab[0]))
        xfree(fldtab[0]->sval);
    fldtab[0]->tval = REC | STR | DONTFREE;
    fldtab[0]->sval = record;

       dprintf( ("in recbld inputFS=%s, fldtab[0]=%p\n", inputFS, fldtab[0]) );
       dprintf( ("recbld = |%s|\n", record) );
    donerec = 1;
}

int errorflag   = 0;

void yyerror(char *s)
{
    SYNTAX(s);
}

void SYNTAX(char *fmt, ...)
{
    extern char *cmdname, *curfname;
    static int been_here = 0;
    va_list varg;

    if (been_here++ > 2)
        return;
    fprintf(stderr, "%s: ", cmdname);
    va_start(varg, fmt);
    vfprintf(stderr, fmt, varg);
    va_end(varg);
    if(compile_time == 1 && cursource() != NULL)
        fprintf(stderr, " at %s:%d", cursource(), lineno);
    else
        fprintf(stderr, " at line %d", lineno);
    if (curfname != NULL)
        fprintf(stderr, " in function %s", curfname);
    fprintf(stderr, "\n");
    errorflag = 2;
    eprint();
}

void fpecatch(int n)
{
    FATAL("floating point exception %d", n);
}

extern int bracecnt, brackcnt, parencnt;

void bracecheck(void)
{
    int c;
    static int beenhere = 0;

    if (beenhere++)
        return;
    while ((c = input()) != EOF && c != '\0')
        bclass(c);
    bcheck2(bracecnt, '{', '}');
    bcheck2(brackcnt, '[', ']');
    bcheck2(parencnt, '(', ')');
}

void bcheck2(int n, int c1, int c2)
{
    if (n == 1)
        fprintf(stderr, "\tmissing %c\n", c2);
    else if (n > 1)
        fprintf(stderr, "\t%d missing %c's\n", n, c2);
    else if (n == -1)
        fprintf(stderr, "\textra %c\n", c2);
    else if (n < -1)
        fprintf(stderr, "\t%d extra %c's\n", -n, c2);
}

void FATAL(char *fmt, ...)
{
    extern char *cmdname;
    va_list varg;

    fflush(stdout);
    fprintf(stderr, "%s: ", cmdname);
    va_start(varg, fmt);
    vfprintf(stderr, fmt, varg);
    va_end(varg);
    error();
    if (dbg > 1)        /* core dump if serious debugging on */
        abort();
    exit(2);
}

void WARNING(char *fmt, ...)
{
    extern char *cmdname;
    va_list varg;

    fflush(stdout);
    fprintf(stderr, "%s: ", cmdname);
    va_start(varg, fmt);
    vfprintf(stderr, fmt, varg);
    va_end(varg);
    error();
}

void error()
{
    extern Node *curnode;
    int line;

    fprintf(stderr, "\n");
    if (compile_time != 2 && NR && *NR > 0) {
        if (strcmp(*FILENAME, "-") != 0)
            fprintf(stderr, " input record %s:%d", *FILENAME, (int) (*FNR));
        else
            fprintf(stderr, " input record number %d", (int) (*FNR));
        fprintf(stderr, "\n");
    }
    if (compile_time != 2 && curnode)
        line = curnode->lineno;
    else if (compile_time != 2 && lineno)
        line = lineno;
    else
        line = -1;
    if (compile_time == 1 && cursource() != NULL){
        if(line >= 0)
            fprintf(stderr, " source %s:%d", cursource(), line);
        else
            fprintf(stderr, " source file %s", cursource());
    }else if(line >= 0)
        fprintf(stderr, " source line %d", line);
    fprintf(stderr, "\n");
    eprint();
}

void eprint(void)   /* try to print context around error */
{
    char *p, *q;
    int c;
    static int been_here = 0;
    extern char ebuf[], *ep;

    if (compile_time == 2 || compile_time == 0 || been_here++ > 0)
        return;
    p = ep - 1;
    if (p > ebuf && *p == '\n')
        p--;
    for ( ; p > ebuf && *p != '\n' && *p != '\0'; p--)
        ;
    while (*p == '\n')
        p++;
    fprintf(stderr, " context is\n\t");
    for (q=ep-1; q>=p && *q!=' ' && *q!='\t' && *q!='\n'; q--)
        ;
    for ( ; p < q; p++)
        if (*p)
            putc(*p, stderr);
    fprintf(stderr, " >>> ");
    for ( ; p < ep; p++)
        if (*p)
            putc(*p, stderr);
    fprintf(stderr, " <<< ");
    if (*ep)
        while ((c = input()) != '\n' && c != '\0' && c != EOF) {
            putc(c, stderr);
            bclass(c);
        }
    putc('\n', stderr);
    ep = ebuf;
}

void bclass(int c)
{
    switch (c) {
    case '{': bracecnt++; break;
    case '}': bracecnt--; break;
    case '[': brackcnt++; break;
    case ']': brackcnt--; break;
    case '(': parencnt++; break;
    case ')': parencnt--; break;
    }
}

double errcheck(double x, char *s)
{

    if (errno == EDOM) {
        errno = 0;
        WARNING("%s argument out of domain", s);
        x = 1;
    } else if (errno == ERANGE) {
        errno = 0;
        WARNING("%s result out of range", s);
        x = 1;
    }
    return x;
}

int isclvar(char *s)    /* is s of form var=something ? */
{
    char *os = s;

    if (!isalpha(*s) && *s != '_')
        return 0;
    for ( ; *s; s++)
        if (!(isalnum(*s) || *s == '_'))
            break;
    return *s == '=' && s > os && *(s+1) != '=';
}

/* strtod is supposed to be a proper test of what's a valid number */

#include <math.h>
int is_number(char *s)
{
    double r;
    char *ep;

    /*
     * fast could-it-be-a-number check before calling strtod,
     * which takes a surprisingly long time to reject non-numbers.
     */
    switch (*s) {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
    case '\t':
    case '\n':
    case '\v':
    case '\f':
    case '\r':
    case ' ':
    case '-':
    case '+':
    case '.':
    case 'n':       /* nans */
    case 'N':
    case 'i':       /* infs */
    case 'I':
        break;
    default:
        return 0;   /* can't be a number */
    }

    errno = 0;
    r = strtod(s, &ep);
    if (ep == s || r == HUGE_VAL || errno == ERANGE)
        return 0;
    while (*ep == ' ' || *ep == '\t' || *ep == '\n')
        ep++;
    if (*ep == '\0')
        return 1;
    else
        return 0;
}
@

\subsection{[[awk/maketab.c]]}

<<awk/maketab.c>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

/*
 * this program makes the table to link function names
 * and type indices that is used by execute() in run.c.
 * it finds the indices in y.tab.h, produced by yacc.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "awk.h"
#include "y.tab.h"

struct xx
{   int token;
    char *name;
    char *pname;
} proc[] = {
    { PROGRAM, "program", NULL },
    { BOR, "boolop", " || " },
    { AND, "boolop", " && " },
    { NOT, "boolop", " !" },
    { NE, "relop", " != " },
    { EQ, "relop", " == " },
    { LE, "relop", " <= " },
    { LT, "relop", " < " },
    { GE, "relop", " >= " },
    { GT, "relop", " > " },
    { ARRAY, "array", NULL },
    { INDIRECT, "indirect", "$(" },
    { SUBSTR, "substr", "substr" },
    { SUB, "sub", "sub" },
    { GSUB, "gsub", "gsub" },
    { INDEX, "sindex", "sindex" },
    { SPRINTF, "awksprintf", "sprintf " },
    { ADD, "arith", " + " },
    { MINUS, "arith", " - " },
    { MULT, "arith", " * " },
    { DIVIDE, "arith", " / " },
    { MOD, "arith", " % " },
    { UMINUS, "arith", " -" },
    { POWER, "arith", " **" },
    { PREINCR, "incrdecr", "++" },
    { POSTINCR, "incrdecr", "++" },
    { PREDECR, "incrdecr", "--" },
    { POSTDECR, "incrdecr", "--" },
    { CAT, "cat", " " },
    { PASTAT, "pastat", NULL },
    { PASTAT2, "dopa2", NULL },
    { MATCH, "matchop", " ~ " },
    { NOTMATCH, "matchop", " !~ " },
    { MATCHFCN, "matchop", "matchop" },
    { INTEST, "intest", "intest" },
    { PRINTF, "awkprintf", "printf" },
    { PRINT, "printstat", "print" },
    { CLOSE, "closefile", "closefile" },
    { DELETE, "awkdelete", "awkdelete" },
    { SPLIT, "split", "split" },
    { ASSIGN, "assign", " = " },
    { ADDEQ, "assign", " += " },
    { SUBEQ, "assign", " -= " },
    { MULTEQ, "assign", " *= " },
    { DIVEQ, "assign", " /= " },
    { MODEQ, "assign", " %= " },
    { POWEQ, "assign", " ^= " },
    { CONDEXPR, "condexpr", " ?: " },
    { IF, "ifstat", "if(" },
    { WHILE, "whilestat", "while(" },
    { FOR, "forstat", "for(" },
    { DO, "dostat", "do" },
    { IN, "instat", "instat" },
    { NEXT, "jump", "next" },
    { NEXTFILE, "jump", "nextfile" },
    { EXIT, "jump", "exit" },
    { BREAK, "jump", "break" },
    { CONTINUE, "jump", "continue" },
    { RETURN, "jump", "ret" },
    { BLTIN, "bltin", "bltin" },
    { CALL, "call", "call" },
    { ARG, "arg", "arg" },
    { VARNF, "getnf", "NF" },
    { GETLINE, "getline", "getline" },
    { 0, "", "" },
};

#define SIZE    (LASTTOKEN - FIRSTTOKEN + 1)
char *table[SIZE];
char *names[SIZE];

int main(int argc, char *argv[])
{
    struct xx *p;
    int i, n, tok;
    char c;
    FILE *fp;
    char buf[200], name[200], def[200];

    printf("#include <stdio.h>\n");
    printf("#include \"awk.h\"\n");
    printf("#include \"y.tab.h\"\n\n");
    for (i = SIZE; --i >= 0; )
        names[i] = "";

    if ((fp = fopen("y.tab.h", "r")) == NULL) {
        fprintf(stderr, "maketab can't open y.tab.h!\n");
        exit(1);
    }
    printf("static char *printname[%d] = {\n", SIZE);
    i = 0;
    while (fgets(buf, sizeof buf, fp) != NULL) {
        n = sscanf(buf, "%1c %s %s %d", &c, def, name, &tok);
        if (c != '#' || (n != 4 && strcmp(def,"define") != 0))  /* not a valid #define */
            continue;
        if (tok < FIRSTTOKEN || tok > LASTTOKEN) {
            fprintf(stderr, "maketab funny token %d %s\n", tok, buf);
            exit(1);
        }
        names[tok-FIRSTTOKEN] = (char *) malloc(strlen(name)+1);
        strcpy(names[tok-FIRSTTOKEN], name);
        printf("\t(char *) \"%s\",\t/* %d */\n", name, tok);
        i++;
    }
    printf("};\n\n");

    for (p=proc; p->token!=0; p++)
        table[p->token-FIRSTTOKEN] = p->name;
    printf("\nCell *(*proctab[%d])(Node **, int) = {\n", SIZE);
    for (i=0; i<SIZE; i++)
        if (table[i]==0)
            printf("\tnullproc,\t/* %s */\n", names[i]);
        else
            printf("\t%s,\t/* %s */\n", table[i], names[i]);
    printf("};\n\n");

    printf("char *tokname(int n)\n");   /* print a tokname() function */
    printf("{\n");
    printf("    static char buf[100];\n\n");
    printf("    if (n < FIRSTTOKEN || n > LASTTOKEN) {\n");
    printf("        sprintf(buf, \"token %%d\", n);\n");
    printf("        return buf;\n");
    printf("    }\n");
    printf("    return printname[n-FIRSTTOKEN];\n");
    printf("}\n");
    return 0;
}
@

\subsection{[[awk/parse.c]]}

<<awk/parse.c>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#define DEBUG
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "awk.h"
#include "y.tab.h"

Node *nodealloc(int n)
{
    Node *x;

    x = (Node *) malloc(sizeof(Node) + (n-1)*sizeof(Node *));
    if (x == NULL)
        FATAL("out of space in nodealloc");
    x->nnext = NULL;
    x->lineno = lineno;
    return(x);
}

Node *exptostat(Node *a)
{
    a->ntype = NSTAT;
    return(a);
}

Node *node1(int a, Node *b)
{
    Node *x;

    x = nodealloc(1);
    x->nobj = a;
    x->narg[0]=b;
    return(x);
}

Node *node2(int a, Node *b, Node *c)
{
    Node *x;

    x = nodealloc(2);
    x->nobj = a;
    x->narg[0] = b;
    x->narg[1] = c;
    return(x);
}

Node *node3(int a, Node *b, Node *c, Node *d)
{
    Node *x;

    x = nodealloc(3);
    x->nobj = a;
    x->narg[0] = b;
    x->narg[1] = c;
    x->narg[2] = d;
    return(x);
}

Node *node4(int a, Node *b, Node *c, Node *d, Node *e)
{
    Node *x;

    x = nodealloc(4);
    x->nobj = a;
    x->narg[0] = b;
    x->narg[1] = c;
    x->narg[2] = d;
    x->narg[3] = e;
    return(x);
}

Node *stat1(int a, Node *b)
{
    Node *x;

    x = node1(a,b);
    x->ntype = NSTAT;
    return(x);
}

Node *stat2(int a, Node *b, Node *c)
{
    Node *x;

    x = node2(a,b,c);
    x->ntype = NSTAT;
    return(x);
}

Node *stat3(int a, Node *b, Node *c, Node *d)
{
    Node *x;

    x = node3(a,b,c,d);
    x->ntype = NSTAT;
    return(x);
}

Node *stat4(int a, Node *b, Node *c, Node *d, Node *e)
{
    Node *x;

    x = node4(a,b,c,d,e);
    x->ntype = NSTAT;
    return(x);
}

Node *op1(int a, Node *b)
{
    Node *x;

    x = node1(a,b);
    x->ntype = NEXPR;
    return(x);
}

Node *op2(int a, Node *b, Node *c)
{
    Node *x;

    x = node2(a,b,c);
    x->ntype = NEXPR;
    return(x);
}

Node *op3(int a, Node *b, Node *c, Node *d)
{
    Node *x;

    x = node3(a,b,c,d);
    x->ntype = NEXPR;
    return(x);
}

Node *op4(int a, Node *b, Node *c, Node *d, Node *e)
{
    Node *x;

    x = node4(a,b,c,d,e);
    x->ntype = NEXPR;
    return(x);
}

Node *celltonode(Cell *a, int b)
{
    Node *x;

    a->ctype = OCELL;
    a->csub = b;
    x = node1(0, (Node *) a);
    x->ntype = NVALUE;
    return(x);
}

Node *rectonode(void)   /* make $0 into a Node */
{
    extern Cell *literal0;
    return op1(INDIRECT, celltonode(literal0, CUNK));
}

Node *makearr(Node *p)
{
    Cell *cp;

    if (isvalue(p)) {
        cp = (Cell *) (p->narg[0]);
        if (isfcn(cp))
            SYNTAX( "%s is a function, not an array", cp->nval );
        else if (!isarr(cp)) {
            xfree(cp->sval);
            cp->sval = (char *) makesymtab(NSYMTAB);
            cp->tval = ARR;
        }
    }
    return p;
}

#define PA2NUM  50  /* max number of pat,pat patterns allowed */
int paircnt;        /* number of them in use */
int pairstack[PA2NUM];  /* state of each pat,pat */

Node *pa2stat(Node *a, Node *b, Node *c)    /* pat, pat {...} */
{
    Node *x;

    x = node4(PASTAT2, a, b, c, itonp(paircnt));
    if (paircnt++ >= PA2NUM)
        SYNTAX( "limited to %d pat,pat statements", PA2NUM );
    x->ntype = NSTAT;
    return(x);
}

Node *linkum(Node *a, Node *b)
{
    Node *c;

    if (errorflag)  /* don't link things that are wrong */
        return a;
    if (a == NULL)
        return(b);
    else if (b == NULL)
        return(a);
    for (c = a; c->nnext != NULL; c = c->nnext)
        ;
    c->nnext = b;
    return(a);
}

void defn(Cell *v, Node *vl, Node *st)  /* turn on FCN bit in definition, */
{                   /*   body of function, arglist */
    Node *p;
    int n;

    if (isarr(v)) {
        SYNTAX( "`%s' is an array name and a function name", v->nval );
        return;
    }
    v->tval = FCN;
    v->sval = (char *) st;
    n = 0;  /* count arguments */
    for (p = vl; p; p = p->nnext)
        n++;
    v->fval = n;
    dprintf( ("defining func %s (%d args)\n", v->nval, n) );
}

int isarg(char *s)      /* is s in argument list for current function? */
{           /* return -1 if not, otherwise arg # */
    extern Node *arglist;
    Node *p = arglist;
    int n;

    for (n = 0; p != 0; p = p->nnext, n++)
        if (strcmp(((Cell *)(p->narg[0]))->nval, s) == 0)
            return n;
    return -1;
}

int ptoi(void *p)   /* convert pointer to integer */
{
    return (int) (long) p;  /* swearing that p fits, of course */
}

Node *itonp(int i)  /* and vice versa */
{
    return (Node *) (long) i;
}
@

\subsection{[[awk/proto.h]]}

<<awk/proto.h>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

extern  int yywrap(void);
extern  void    setfname(Cell *);
extern  int constnode(Node *);
extern  char    *strnode(Node *);
extern  Node    *notnull(Node *);
extern  int yyparse(void);

extern  int yylex(void);
extern  void    startreg(void);
extern  int input(void);
extern  void    unput(int);
extern  void    unputstr(char *);
extern  int yylook(void);
extern  int yyback(int *, int);
extern  int yyinput(void);

extern  void    *compre(char *);
extern  int hexstr(char **);
extern  void    quoted(char **, char **, char *);
extern  int match(void *, char *, char *);
extern  int pmatch(void *, char *, char *);
extern  int nematch(void *, char *, char *);
extern  int countposn(char *, int);
extern  void    overflow(void);

extern  int pgetc(void);
extern  char    *cursource(void);

extern  Node    *nodealloc(int);
extern  Node    *exptostat(Node *);
extern  Node    *node1(int, Node *);
extern  Node    *node2(int, Node *, Node *);
extern  Node    *node3(int, Node *, Node *, Node *);
extern  Node    *node4(int, Node *, Node *, Node *, Node *);
extern  Node    *stat3(int, Node *, Node *, Node *);
extern  Node    *op2(int, Node *, Node *);
extern  Node    *op1(int, Node *);
extern  Node    *stat1(int, Node *);
extern  Node    *op3(int, Node *, Node *, Node *);
extern  Node    *op4(int, Node *, Node *, Node *, Node *);
extern  Node    *stat2(int, Node *, Node *);
extern  Node    *stat4(int, Node *, Node *, Node *, Node *);
extern  Node    *celltonode(Cell *, int);
extern  Node    *rectonode(void);
extern  Node    *makearr(Node *);
extern  Node    *pa2stat(Node *, Node *, Node *);
extern  Node    *linkum(Node *, Node *);
extern  void    defn(Cell *, Node *, Node *);
extern  int isarg(char *);
extern  char    *tokname(int);
extern  Cell    *(*proctab[])(Node **, int);
extern  int ptoi(void *);
extern  Node    *itonp(int);

extern  void    syminit(void);
extern  void    arginit(int, char **);
extern  void    envinit(char **);
extern  Array   *makesymtab(int);
extern  void    freesymtab(Cell *);
extern  void    freeelem(Cell *, char *);
extern  Cell    *setsymtab(char *, char *, double, unsigned int, Array *);
extern  int hash(char *, int);
extern  void    rehash(Array *);
extern  Cell    *lookup(char *, Array *);
extern  double  setfval(Cell *, double);
extern  void    funnyvar(Cell *, char *);
extern  char    *setsval(Cell *, char *);
extern  double  getfval(Cell *);
extern  char    *getsval(Cell *);
extern  char    *tostring(char *);
extern  char    *qstring(char *, int);

extern  void    recinit(unsigned int);
extern  void    initgetrec(void);
extern  void    makefields(int, int);
extern  void    growfldtab(int n);
extern  int getrec(char **, int *, int);
extern  void    nextfile(void);
extern  int readrec(char **buf, int *bufsize, FILE *inf);
extern  char    *getargv(int);
extern  void    setclvar(char *);
extern  void    fldbld(void);
extern  void    cleanfld(int, int);
extern  void    newfld(int);
extern  int refldbld(char *, char *);
extern  void    recbld(void);
extern  Cell    *fieldadr(int);
extern  void    yyerror(char *);
extern  void    fpecatch(int);
extern  void    bracecheck(void);
extern  void    bcheck2(int, int, int);
extern  void    SYNTAX(char *, ...);
extern  void    FATAL(char *, ...);
extern  void    WARNING(char *, ...);
extern  void    error(void);
extern  void    eprint(void);
extern  void    bclass(int);
extern  double  errcheck(double, char *);
extern  int isclvar(char *);
extern  int is_number(char *);

extern  int adjbuf(char **pb, int *sz, int min, int q, char **pbp, char *what);
extern  void    run(Node *);
extern  Cell    *execute(Node *);
extern  Cell    *program(Node **, int);
extern  Cell    *call(Node **, int);
extern  Cell    *copycell(Cell *);
extern  Cell    *arg(Node **, int);
extern  Cell    *jump(Node **, int);
extern  Cell    *getline(Node **, int);
extern  Cell    *getnf(Node **, int);
extern  Cell    *array(Node **, int);
extern  Cell    *awkdelete(Node **, int);
extern  Cell    *intest(Node **, int);
extern  Cell    *matchop(Node **, int);
extern  Cell    *boolop(Node **, int);
extern  Cell    *relop(Node **, int);
extern  void    tfree(Cell *);
extern  Cell    *gettemp(void);
extern  Cell    *field(Node **, int);
extern  Cell    *indirect(Node **, int);
extern  Cell    *substr(Node **, int);
extern  Cell    *sindex(Node **, int);
extern  int format(char **, int *, char *, Node *);
extern  Cell    *awksprintf(Node **, int);
extern  Cell    *awkprintf(Node **, int);
extern  Cell    *arith(Node **, int);
extern  double  ipow(double, int);
extern  Cell    *incrdecr(Node **, int);
extern  Cell    *assign(Node **, int);
extern  Cell    *cat(Node **, int);
extern  Cell    *pastat(Node **, int);
extern  Cell    *dopa2(Node **, int);
extern  Cell    *split(Node **, int);
extern  Cell    *condexpr(Node **, int);
extern  Cell    *ifstat(Node **, int);
extern  Cell    *whilestat(Node **, int);
extern  Cell    *dostat(Node **, int);
extern  Cell    *forstat(Node **, int);
extern  Cell    *instat(Node **, int);
extern  Cell    *bltin(Node **, int);
extern  Cell    *printstat(Node **, int);
extern  Cell    *nullproc(Node **, int);
extern  FILE    *redirect(int, Node *);
extern  FILE    *openfile(int, char *);
extern  char    *filename(FILE *);
extern  Cell    *closefile(Node **, int);
extern  void    closeall(void);
extern  Cell    *sub(Node **, int);
extern  Cell    *gsub(Node **, int);

extern  FILE    *popen(const char *, const char *);
extern  int pclose(FILE *);
@

\subsection{[[awk/re.c]]}

<<awk/re.c>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/


#define DEBUG
#include <stdio.h>
#include <ctype.h>
#include <setjmp.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "awk.h"
#include "y.tab.h"
#include "regexp.h"

    /* This file provides the interface between the main body of
     * awk and the pattern matching package.  It preprocesses
     * patterns prior to compilation to provide awk-like semantics
     * to character sequences not supported by the pattern package.
     * The following conversions are performed:
     *
     *  "()"        ->  "[]"
     *  "[-"        ->  "[\-"
     *  "[^-"       ->  "[^\-"
     *  "-]"        ->  "\-]"
     *  "[]"        ->  "[]*"
     *  "\xdddd"    ->  "\z" where 'z' is the UTF sequence
     *                  for the hex value
     *  "\ddd"      ->  "\o" where 'o' is a char octal value
     *  "\b"        ->  "\B"    where 'B' is backspace
     *  "\t"        ->  "\T"    where 'T' is tab
     *  "\f"        ->  "\F"    where 'F' is form feed
     *  "\n"        ->  "\N"    where 'N' is newline
     *  "\r"        ->  "\r"    where 'C' is cr
     */

#define MAXRE   512

static char re[MAXRE];  /* copy buffer */

char    *patbeg;
int patlen;         /* number of chars in pattern */

#define NPATS   20      /* number of slots in pattern cache */

static struct pat_list      /* dynamic pattern cache */
{
    char    *re;
    int use;
    Reprog  *program;
} pattern[NPATS];

static int npats;       /* cache fill level */

    /* Compile a pattern */
void
*compre(char *pat)
{
    int i, j, inclass;
    char c, *p, *s;
    Reprog *program;

    if (!compile_time) {    /* search cache for dynamic pattern */
        for (i = 0; i < npats; i++)
            if (!strcmp(pat, pattern[i].re)) {
                pattern[i].use++;
                return((void *) pattern[i].program);
            }
    }
        /* Preprocess Pattern for compilation */
    p = re;
    s = pat;
    inclass = 0;
    while (c = *s++) {
        if (c == '\\') {
            quoted(&s, &p, re+MAXRE);
            continue;
        }
        else if (!inclass && c == '(' && *s == ')') {
            if (p < re+MAXRE-2) {   /* '()' -> '[]*' */
                *p++ = '[';
                *p++ = ']';
                c = '*';
                s++;
            }
            else overflow();
        }
        else if (c == '['){         /* '[-' -> '[\-' */
            inclass = 1;
            if (*s == '-') {
                if (p < re+MAXRE-2) {
                    *p++ = '[';
                    *p++ = '\\';
                    c = *s++;
                }
                else overflow();
            }               /* '[^-' -> '[^\-'*/
            else if (*s == '^' && s[1] == '-'){
                if (p < re+MAXRE-3) {
                    *p++ = '[';
                    *p++ = *s++;
                    *p++ = '\\';
                    c = *s++;
                }
                else overflow();
            }
            else if (*s == '['){        /* skip '[[' */
                if (p < re+MAXRE-1)
                    *p++ = c;
                else overflow();
                c = *s++;
            }
            else if (*s == '^' && s[1] == '[') {    /* skip '[^['*/
                if (p < re+MAXRE-2) {
                    *p++ = c;
                    *p++ = *s++;
                    c = *s++;
                }
                else overflow();
            }
            else if (*s == ']') {       /* '[]' -> '[]*' */
                if (p < re+MAXRE-2) {
                    *p++ = c;
                    *p++ = *s++;
                    c = '*';
                    inclass = 0;
                }
                else overflow();
            }
        }
        else if (c == '-' && *s == ']') {   /* '-]' -> '\-]' */
            if (p < re+MAXRE-1)
                *p++ = '\\';
            else overflow();
        }
        else if (c == ']')
            inclass = 0;
        if (p < re+MAXRE-1)
            *p++ = c;
        else overflow();
    }
    *p = 0;
    program = regcomp(re);      /* compile pattern */
    if (!compile_time) {
        if (npats < NPATS)  /* Room in cache */
            i = npats++;
        else {          /* Throw out least used */
            int use = pattern[0].use;
            i = 0;
            for (j = 1; j < NPATS; j++) {
                if (pattern[j].use < use) {
                    use = pattern[j].use;
                    i = j;
                }
            }
            xfree(pattern[i].program);
            xfree(pattern[i].re);
        }
        pattern[i].re = tostring(pat);
        pattern[i].program = program;
        pattern[i].use = 1;
    }
    return((void *) program);
}

    /* T/F match indication - matched string not exported */
int
match(void *p, char *s, char *)
{
    return regexec((Reprog *) p, (char *) s, 0, 0);
}

    /* match and delimit the matched string */
int
pmatch(void *p, char *s, char *start)
{
    Resub m;

    m.s.sp = start;
    m.e.ep = 0;
    if (regexec((Reprog *) p, (char *) s, &m, 1)) {
        patbeg = m.s.sp;
        patlen = m.e.ep-m.s.sp;
        return 1;
    }
    patlen = -1;
    patbeg = start;
    return 0;
}

    /* perform a non-empty match */
int
nematch(void *p, char *s, char *start)
{
    if (pmatch(p, s, start) == 1 && patlen > 0)
        return 1;
    patlen = -1;
    patbeg = start; 
    return 0;
}
/* in the parsing of regular expressions, metacharacters like . have */
/* to be seen literally;  \056 is not a metacharacter. */

hexstr(char **pp)   /* find and eval hex string at pp, return new p */
{
    char c;
    int n = 0;
    int i;

    for (i = 0, c = (*pp)[i]; i < 4 && isxdigit(c); i++, c = (*pp)[i]) {
        if (isdigit(c))
            n = 16 * n + c - '0';
        else if ('a' <= c && c <= 'f')
            n = 16 * n + c - 'a' + 10;
        else if ('A' <= c && c <= 'F')
            n = 16 * n + c - 'A' + 10;
    }
    *pp += i;
    return n;
}

    /* look for awk-specific escape sequences */

#define isoctdigit(c) ((c) >= '0' && (c) <= '7') /* multiple use of arg */

void
quoted(char **s, char **to, char *end)  /* handle escaped sequence */
{
    char *p = *s;
    char *t = *to;
    wchar_t c;

    switch(c = *p++) {
    case 't':
        c = '\t';
        break;
    case 'n':
        c = '\n';
        break;
    case 'f':
        c = '\f';
        break;
    case 'r':
        c = '\r';
        break;
    case 'b':
        c = '\b';
        break;
    default:
        if (t < end-1)      /* all else must be escaped */
            *t++ = '\\';
        if (c == 'x') {     /* hexadecimal goo follows */
            c = hexstr(&p);
            if (t < end-MB_CUR_MAX)
                t += wctomb(t, c);
            else overflow();
            *to = t;
            *s = p;
            return;
        } else if (isoctdigit(c)) { /* \d \dd \ddd */
            c -= '0';
            if (isoctdigit(*p)) {
                c = 8 * c + *p++ - '0';
                if (isoctdigit(*p))
                    c = 8 * c + *p++ - '0';
            }
        }
        break;
    }
    if (t < end-1)
        *t++ = c;
    *s = p;
    *to = t;
}
    /* count rune positions */
int
countposn(char *s, int n)
{
    int i, j;
    char *end;

    for (i = 0, end = s+n; *s && s < end; i++){
        j = mblen(s, n);
        if(j <= 0)
            j = 1;
        s += j;
    }
    return(i);
}

    /* pattern package error handler */

void
regerror(char *s)
{
    FATAL("%s", s);
}

void
overflow(void)
{
    FATAL("%s", "regular expression too big");
}
@

\subsection{[[awk/run.c]]}

<<awk/run.c>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#define DEBUG
#include <stdio.h>
#include <ctype.h>
#include <setjmp.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <utf.h>
#include "awk.h"
#include "y.tab.h"

#define tempfree(x) if (istemp(x)) tfree(x); else

/*
#undef tempfree

void tempfree(Cell *p) {
    if (p->ctype == OCELL && (p->csub < CUNK || p->csub > CFREE)) {
        WARNING("bad csub %d in Cell %d %s",
            p->csub, p->ctype, p->sval);
    }
    if (istemp(p))
        tfree(p);
}
*/

#ifdef _NFILE
#ifndef FOPEN_MAX
#define FOPEN_MAX _NFILE
#endif
#endif

#ifndef FOPEN_MAX
#define FOPEN_MAX   40  /* max number of open files */
#endif

#ifndef RAND_MAX
#define RAND_MAX    32767   /* all that ansi guarantees */
#endif

jmp_buf env;
extern  int pairstack[];

Node    *winner = NULL; /* root of parse tree */
Cell    *tmps;      /* free temporary cells for execution */

static Cell truecell    ={ OBOOL, BTRUE, 0, 0, 1.0, NUM };
Cell    *True   = &truecell;
static Cell falsecell   ={ OBOOL, BFALSE, 0, 0, 0.0, NUM };
Cell    *False  = &falsecell;
static Cell breakcell   ={ OJUMP, JBREAK, 0, 0, 0.0, NUM };
Cell    *jbreak = &breakcell;
static Cell contcell    ={ OJUMP, JCONT, 0, 0, 0.0, NUM };
Cell    *jcont  = &contcell;
static Cell nextcell    ={ OJUMP, JNEXT, 0, 0, 0.0, NUM };
Cell    *jnext  = &nextcell;
static Cell nextfilecell    ={ OJUMP, JNEXTFILE, 0, 0, 0.0, NUM };
Cell    *jnextfile  = &nextfilecell;
static Cell exitcell    ={ OJUMP, JEXIT, 0, 0, 0.0, NUM };
Cell    *jexit  = &exitcell;
static Cell retcell     ={ OJUMP, JRET, 0, 0, 0.0, NUM };
Cell    *jret   = &retcell;
static Cell tempcell    ={ OCELL, CTEMP, 0, "", 0.0, NUM|STR|DONTFREE };

Node    *curnode = NULL;    /* the node being executed, for debugging */

/* buffer memory management */
int adjbuf(char **pbuf, int *psiz, int minlen, int quantum, char **pbptr,
    char *whatrtn)
/* pbuf:    address of pointer to buffer being managed
 * psiz:    address of buffer size variable
 * minlen:  minimum length of buffer needed
 * quantum: buffer size quantum
 * pbptr:   address of movable pointer into buffer, or 0 if none
 * whatrtn: name of the calling routine if failure should cause fatal error
 *
 * return   0 for realloc failure, !=0 for success
 */
{
    if (minlen > *psiz) {
        char *tbuf;
        int rminlen = quantum ? minlen % quantum : 0;
        int boff = pbptr ? *pbptr - *pbuf : 0;
        /* round up to next multiple of quantum */
        if (rminlen)
            minlen += quantum - rminlen;
        tbuf = (char *) realloc(*pbuf, minlen);
        if (tbuf == NULL) {
            if (whatrtn)
                FATAL("out of memory in %s", whatrtn);
            return 0;
        }
        *pbuf = tbuf;
        *psiz = minlen;
        if (pbptr)
            *pbptr = tbuf + boff;
    }
    return 1;
}

void run(Node *a)   /* execution of parse tree starts here */
{
    extern void stdinit(void);

    stdinit();
    execute(a);
    closeall();
}

Cell *execute(Node *u)  /* execute a node of the parse tree */
{
    int nobj;
    Cell *(*proc)(Node **, int);
    Cell *x;
    Node *a;

    if (u == NULL)
        return(True);
    for (a = u; ; a = a->nnext) {
        curnode = a;
        if (isvalue(a)) {
            x = (Cell *) (a->narg[0]);
            if (isfld(x) && !donefld)
                fldbld();
            else if (isrec(x) && !donerec)
                recbld();
            return(x);
        }
        nobj = a->nobj;
        if (notlegal(nobj)) /* probably a Cell* but too risky to print */
            FATAL("illegal statement");
        proc = proctab[nobj-FIRSTTOKEN];
        x = (*proc)(a->narg, nobj);
        if (isfld(x) && !donefld)
            fldbld();
        else if (isrec(x) && !donerec)
            recbld();
        if (isexpr(a))
            return(x);
        if (isjump(x))
            return(x);
        if (a->nnext == NULL)
            return(x);
        tempfree(x);
    }
}


Cell *program(Node **a, int n)  /* execute an awk program */
{               /* a[0] = BEGIN, a[1] = body, a[2] = END */
    Cell *x;

    if (setjmp(env) != 0)
        goto ex;
    if (a[0]) {     /* BEGIN */
        x = execute(a[0]);
        if (isexit(x))
            return(True);
        if (isjump(x))
            FATAL("illegal break, continue, next or nextfile from BEGIN");
        tempfree(x);
    }
    if (a[1] || a[2])
        while (getrec(&record, &recsize, 1) > 0) {
            x = execute(a[1]);
            if (isexit(x))
                break;
            tempfree(x);
        }
  ex:
    if (setjmp(env) != 0)   /* handles exit within END */
        goto ex1;
    if (a[2]) {     /* END */
        x = execute(a[2]);
        if (isbreak(x) || isnext(x) || iscont(x))
            FATAL("illegal break, continue, next or nextfile from END");
        tempfree(x);
    }
  ex1:
    return(True);
}

struct Frame {  /* stack frame for awk function calls */
    int nargs;  /* number of arguments in this call */
    Cell *fcncell;  /* pointer to Cell for function */
    Cell **args;    /* pointer to array of arguments after execute */
    Cell *retval;   /* return value */
};

#define NARGS   50  /* max args in a call */

struct Frame *frame = NULL; /* base of stack frames; dynamically allocated */
int nframe = 0;     /* number of frames allocated */
struct Frame *fp = NULL;    /* frame pointer. bottom level unused */

Cell *call(Node **a, int n) /* function call.  very kludgy and fragile */
{
    static Cell newcopycell = { OCELL, CCOPY, 0, "", 0.0, NUM|STR|DONTFREE };
    int i, ncall, ndef;
    Node *x;
    Cell *args[NARGS], *oargs[NARGS];   /* BUG: fixed size arrays */
    Cell *y, *z, *fcn;
    char *s;

    fcn = execute(a[0]);    /* the function itself */
    s = fcn->nval;
    if (!isfcn(fcn))
        FATAL("calling undefined function %s", s);
    if (frame == NULL) {
        fp = frame = (struct Frame *) calloc(nframe += 100, sizeof(struct Frame));
        if (frame == NULL)
            FATAL("out of space for stack frames calling %s", s);
    }
    for (ncall = 0, x = a[1]; x != NULL; x = x->nnext)  /* args in call */
        ncall++;
    ndef = (int) fcn->fval;         /* args in defn */
       dprintf( ("calling %s, %d args (%d in defn), fp=%d\n", s, ncall, ndef, (int) (fp-frame)) );
    if (ncall > ndef)
        WARNING("function %s called with %d args, uses only %d",
            s, ncall, ndef);
    if (ncall + ndef > NARGS)
        FATAL("function %s has %d arguments, limit %d", s, ncall+ndef, NARGS);
    for (i = 0, x = a[1]; x != NULL; i++, x = x->nnext) {   /* get call args */
           dprintf( ("evaluate args[%d], fp=%d:\n", i, (int) (fp-frame)) );
        y = execute(x);
        oargs[i] = y;
           dprintf( ("args[%d]: %s %f <%s>, t=%o\n",
               i, y->nval, y->fval, isarr(y) ? "(array)" : y->sval, y->tval) );
        if (isfcn(y))
            FATAL("can't use function %s as argument in %s", y->nval, s);
        if (isarr(y))
            args[i] = y;    /* arrays by ref */
        else
            args[i] = copycell(y);
        tempfree(y);
    }
    for ( ; i < ndef; i++) {    /* add null args for ones not provided */
        args[i] = gettemp();
        *args[i] = newcopycell;
    }
    fp++;   /* now ok to up frame */
    if (fp >= frame + nframe) {
        int dfp = fp - frame;   /* old index */
        frame = (struct Frame *)
            realloc((char *) frame, (nframe += 100) * sizeof(struct Frame));
        if (frame == NULL)
            FATAL("out of space for stack frames in %s", s);
        fp = frame + dfp;
    }
    fp->fcncell = fcn;
    fp->args = args;
    fp->nargs = ndef;   /* number defined with (excess are locals) */
    fp->retval = gettemp();

       dprintf( ("start exec of %s, fp=%d\n", s, (int) (fp-frame)) );
    y = execute((Node *)(fcn->sval));   /* execute body */
       dprintf( ("finished exec of %s, fp=%d\n", s, (int) (fp-frame)) );

    for (i = 0; i < ndef; i++) {
        Cell *t = fp->args[i];
        if (isarr(t)) {
            if (t->csub == CCOPY) {
                if (i >= ncall) {
                    freesymtab(t);
                    t->csub = CTEMP;
                    tempfree(t);
                } else {
                    oargs[i]->tval = t->tval;
                    oargs[i]->tval &= ~(STR|NUM|DONTFREE);
                    oargs[i]->sval = t->sval;
                    tempfree(t);
                }
            }
        } else if (t != y) {    /* kludge to prevent freeing twice */
            t->csub = CTEMP;
            tempfree(t);
        }
    }
    tempfree(fcn);
    if (isexit(y) || isnext(y) || isnextfile(y))
        return y;
    tempfree(y);        /* this can free twice! */
    z = fp->retval;         /* return value */
       dprintf( ("%s returns %g |%s| %o\n", s, getfval(z), getsval(z), z->tval) );
    fp--;
    return(z);
}

Cell *copycell(Cell *x) /* make a copy of a cell in a temp */
{
    Cell *y;

    y = gettemp();
    y->csub = CCOPY;    /* prevents freeing until call is over */
    y->nval = x->nval;  /* BUG? */
    y->sval = x->sval ? tostring(x->sval) : NULL;
    y->fval = x->fval;
    y->tval = x->tval & ~(CON|FLD|REC|DONTFREE);    /* copy is not constant or field */
                            /* is DONTFREE right? */
    return y;
}

Cell *arg(Node **a, int n)  /* nth argument of a function */
{

    n = ptoi(a[0]); /* argument number, counting from 0 */
       dprintf( ("arg(%d), fp->nargs=%d\n", n, fp->nargs) );
    if (n+1 > fp->nargs)
        FATAL("argument #%d of function %s was not supplied",
            n+1, fp->fcncell->nval);
    return fp->args[n];
}

Cell *jump(Node **a, int n) /* break, continue, next, nextfile, return */
{
    Cell *y;

    switch (n) {
    case EXIT:
        if (a[0] != NULL) {
            y = execute(a[0]);
            errorflag = (int) getfval(y);
            tempfree(y);
        }
        longjmp(env, 1);
    case RETURN:
        if (a[0] != NULL) {
            y = execute(a[0]);
            if ((y->tval & (STR|NUM)) == (STR|NUM)) {
                setsval(fp->retval, getsval(y));
                fp->retval->fval = getfval(y);
                fp->retval->tval |= NUM;
            }
            else if (y->tval & STR)
                setsval(fp->retval, getsval(y));
            else if (y->tval & NUM)
                setfval(fp->retval, getfval(y));
            else        /* can't happen */
                FATAL("bad type variable %d", y->tval);
            tempfree(y);
        }
        return(jret);
    case NEXT:
        return(jnext);
    case NEXTFILE:
        nextfile();
        return(jnextfile);
    case BREAK:
        return(jbreak);
    case CONTINUE:
        return(jcont);
    default:    /* can't happen */
        FATAL("illegal jump type %d", n);
    }
    return 0;   /* not reached */
}

Cell *getline(Node **a, int n)  /* get next line from specific input */
{       /* a[0] is variable, a[1] is operator, a[2] is filename */
    Cell *r, *x;
    extern Cell **fldtab;
    FILE *fp;
    char *buf;
    int bufsize = recsize;
    int mode;

    if ((buf = (char *) malloc(bufsize)) == NULL)
        FATAL("out of memory in getline");

    fflush(stdout); /* in case someone is waiting for a prompt */
    r = gettemp();
    if (a[1] != NULL) {     /* getline < file */
        x = execute(a[2]);      /* filename */
        mode = ptoi(a[1]);
        if (mode == '|')        /* input pipe */
            mode = LE;  /* arbitrary flag */
        fp = openfile(mode, getsval(x));
        tempfree(x);
        if (fp == NULL)
            n = -1;
        else
            n = readrec(&buf, &bufsize, fp);
        if (n <= 0) {
            ;
        } else if (a[0] != NULL) {  /* getline var <file */
            x = execute(a[0]);
            setsval(x, buf);
            tempfree(x);
        } else {            /* getline <file */
            setsval(fldtab[0], buf);
            if (is_number(fldtab[0]->sval)) {
                fldtab[0]->fval = atof(fldtab[0]->sval);
                fldtab[0]->tval |= NUM;
            }
        }
    } else {            /* bare getline; use current input */
        if (a[0] == NULL)   /* getline */
            n = getrec(&record, &recsize, 1);
        else {          /* getline var */
            n = getrec(&buf, &bufsize, 0);
            x = execute(a[0]);
            setsval(x, buf);
            tempfree(x);
        }
    }
    setfval(r, (Awkfloat) n);
    free(buf);
    return r;
}

Cell *getnf(Node **a, int n)    /* get NF */
{
    if (donefld == 0)
        fldbld();
    return (Cell *) a[0];
}

Cell *array(Node **a, int n)    /* a[0] is symtab, a[1] is list of subscripts */
{
    Cell *x, *y, *z;
    char *s;
    Node *np;
    char *buf;
    int bufsz = recsize;
    int nsub = strlen(*SUBSEP);

    if ((buf = (char *) malloc(bufsz)) == NULL)
        FATAL("out of memory in array");

    x = execute(a[0]);  /* Cell* for symbol table */
    buf[0] = 0;
    for (np = a[1]; np; np = np->nnext) {
        y = execute(np);    /* subscript */
        s = getsval(y);
        if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, 0))
            FATAL("out of memory for %s[%s...]", x->nval, buf);
        strcat(buf, s);
        if (np->nnext)
            strcat(buf, *SUBSEP);
        tempfree(y);
    }
    if (!isarr(x)) {
           dprintf( ("making %s into an array\n", x->nval) );
        if (freeable(x))
            xfree(x->sval);
        x->tval &= ~(STR|NUM|DONTFREE);
        x->tval |= ARR;
        x->sval = (char *) makesymtab(NSYMTAB);
    }
    z = setsymtab(buf, "", 0.0, STR|NUM, (Array *) x->sval);
    z->ctype = OCELL;
    z->csub = CVAR;
    tempfree(x);
    free(buf);
    return(z);
}

Cell *awkdelete(Node **a, int n)    /* a[0] is symtab, a[1] is list of subscripts */
{
    Cell *x, *y;
    Node *np;
    char *s;
    int nsub = strlen(*SUBSEP);

    x = execute(a[0]);  /* Cell* for symbol table */
    if (!isarr(x))
        return True;
    if (a[1] == 0) {    /* delete the elements, not the table */
        freesymtab(x);
        x->tval &= ~STR;
        x->tval |= ARR;
        x->sval = (char *) makesymtab(NSYMTAB);
    } else {
        int bufsz = recsize;
        char *buf;
        if ((buf = (char *) malloc(bufsz)) == NULL)
            FATAL("out of memory in adelete");
        buf[0] = 0;
        for (np = a[1]; np; np = np->nnext) {
            y = execute(np);    /* subscript */
            s = getsval(y);
            if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, 0))
                FATAL("out of memory deleting %s[%s...]", x->nval, buf);
            strcat(buf, s); 
            if (np->nnext)
                strcat(buf, *SUBSEP);
            tempfree(y);
        }
        freeelem(x, buf);
        free(buf);
    }
    tempfree(x);
    return True;
}

Cell *intest(Node **a, int n)   /* a[0] is index (list), a[1] is symtab */
{
    Cell *x, *ap, *k;
    Node *p;
    char *buf;
    char *s;
    int bufsz = recsize;
    int nsub = strlen(*SUBSEP);

    ap = execute(a[1]); /* array name */
    if (!isarr(ap)) {
           dprintf( ("making %s into an array\n", ap->nval) );
        if (freeable(ap))
            xfree(ap->sval);
        ap->tval &= ~(STR|NUM|DONTFREE);
        ap->tval |= ARR;
        ap->sval = (char *) makesymtab(NSYMTAB);
    }
    if ((buf = (char *) malloc(bufsz)) == NULL) {
        FATAL("out of memory in intest");
    }
    buf[0] = 0;
    for (p = a[0]; p; p = p->nnext) {
        x = execute(p); /* expr */
        s = getsval(x);
        if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, 0))
            FATAL("out of memory deleting %s[%s...]", x->nval, buf);
        strcat(buf, s);
        tempfree(x);
        if (p->nnext)
            strcat(buf, *SUBSEP);
    }
    k = lookup(buf, (Array *) ap->sval);
    tempfree(ap);
    free(buf);
    if (k == NULL)
        return(False);
    else
        return(True);
}


Cell *matchop(Node **a, int n)  /* ~ and match() */
{
    Cell *x, *y;
    char *s, *t;
    int i;
    void *p;

    x = execute(a[1]);  /* a[1] = target text */
    s = getsval(x);
    if (a[0] == 0)      /* a[1] == 0: already-compiled reg expr */
        p = (void *) a[2];
    else {
        y = execute(a[2]);  /* a[2] = regular expr */
        t = getsval(y);
        p = compre(t);
        tempfree(y);
    }
    if (n == MATCHFCN)
        i = pmatch(p, s, s);
    else
        i = match(p, s, s);
    tempfree(x);
    if (n == MATCHFCN) {
        int start = countposn(s, patbeg-s)+1;
        if (patlen < 0)
            start = 0;
        setfval(rstartloc, (Awkfloat) start);
        setfval(rlengthloc, (Awkfloat) countposn(patbeg, patlen));
        x = gettemp();
        x->tval = NUM;
        x->fval = start;
        return x;
    } else if ((n == MATCH && i == 1) || (n == NOTMATCH && i == 0))
        return(True);
    else
        return(False);
}


Cell *boolop(Node **a, int n)   /* a[0] || a[1], a[0] && a[1], !a[0] */
{
    Cell *x, *y;
    int i;

    x = execute(a[0]);
    i = istrue(x);
    tempfree(x);
    switch (n) {
    case BOR:
        if (i) return(True);
        y = execute(a[1]);
        i = istrue(y);
        tempfree(y);
        if (i) return(True);
        else return(False);
    case AND:
        if ( !i ) return(False);
        y = execute(a[1]);
        i = istrue(y);
        tempfree(y);
        if (i) return(True);
        else return(False);
    case NOT:
        if (i) return(False);
        else return(True);
    default:    /* can't happen */
        FATAL("unknown boolean operator %d", n);
    }
    return 0;   /*NOTREACHED*/
}

Cell *relop(Node **a, int n)    /* a[0 < a[1], etc. */
{
    int i;
    Cell *x, *y;
    Awkfloat j;

    x = execute(a[0]);
    y = execute(a[1]);
    if (x->tval&NUM && y->tval&NUM) {
        j = x->fval - y->fval;
        i = j<0? -1: (j>0? 1: 0);
    } else {
        i = strcmp(getsval(x), getsval(y));
    }
    tempfree(x);
    tempfree(y);
    switch (n) {
    case LT:    if (i<0) return(True);
            else return(False);
    case LE:    if (i<=0) return(True);
            else return(False);
    case NE:    if (i!=0) return(True);
            else return(False);
    case EQ:    if (i == 0) return(True);
            else return(False);
    case GE:    if (i>=0) return(True);
            else return(False);
    case GT:    if (i>0) return(True);
            else return(False);
    default:    /* can't happen */
        FATAL("unknown relational operator %d", n);
    }
    return 0;   /*NOTREACHED*/
}

void tfree(Cell *a) /* free a tempcell */
{
    if (freeable(a)) {
           dprintf( ("freeing %s %s %o\n", a->nval, a->sval, a->tval) );
        xfree(a->sval);
    }
    if (a == tmps)
        FATAL("tempcell list is curdled");
    a->cnext = tmps;
    tmps = a;
}

Cell *gettemp(void) /* get a tempcell */
{   int i;
    Cell *x;

    if (!tmps) {
        tmps = (Cell *) calloc(100, sizeof(Cell));
        if (!tmps)
            FATAL("out of space for temporaries");
        for(i = 1; i < 100; i++)
            tmps[i-1].cnext = &tmps[i];
        tmps[i-1].cnext = 0;
    }
    x = tmps;
    tmps = x->cnext;
    *x = tempcell;
    return(x);
}

Cell *indirect(Node **a, int n) /* $( a[0] ) */
{
    Cell *x;
    int m;
    char *s;

    x = execute(a[0]);
    m = (int) getfval(x);
    if (m == 0 && !is_number(s = getsval(x)))   /* suspicion! */
        FATAL("illegal field $(%s), name \"%s\"", s, x->nval);
        /* BUG: can x->nval ever be null??? */
    tempfree(x);
    x = fieldadr(m);
    x->ctype = OCELL;   /* BUG?  why are these needed? */
    x->csub = CFLD;
    return(x);
}

Cell *substr(Node **a, int nnn)     /* substr(a[0], a[1], a[2]) */
{
    int k, m, n;
    char *s, *p;
    int temp;
    Cell *x, *y, *z = 0;

    x = execute(a[0]);
    y = execute(a[1]);
    if (a[2] != 0)
        z = execute(a[2]);
    s = getsval(x);
    k = countposn(s, strlen(s)) + 1;
    if (k <= 1) {
        tempfree(x);
        tempfree(y);
        if (a[2] != 0)
            tempfree(z);
        x = gettemp();
        setsval(x, "");
        return(x);
    }
    m = (int) getfval(y);
    if (m <= 0)
        m = 1;
    else if (m > k)
        m = k;
    tempfree(y);
    if (a[2] != 0) {
        n = (int) getfval(z);
        tempfree(z);
    } else
        n = k - 1;
    if (n < 0)
        n = 0;
    else if (n > k - m)
        n = k - m;
       dprintf( ("substr: m=%d, n=%d, s=%s\n", m, n, s) );
    y = gettemp();
    while (*s && --m)
         s += mblen(s, k);
    for (p = s; *p && n--; p += mblen(p, k))
            ;
    temp = *p;  /* with thanks to John Linderman */
    *p = '\0';
    setsval(y, s);
    *p = temp;
    tempfree(x);
    return(y);
}

Cell *sindex(Node **a, int nnn)     /* index(a[0], a[1]) */
{
    Cell *x, *y, *z;
    char *s1, *s2, *p1, *p2, *q;
    Awkfloat v = 0.0;

    x = execute(a[0]);
    s1 = getsval(x);
    y = execute(a[1]);
    s2 = getsval(y);

    z = gettemp();
    for (p1 = s1; *p1 != '\0'; p1++) {
        for (q=p1, p2=s2; *p2 != '\0' && *q == *p2; q++, p2++)
            ;
        if (*p2 == '\0') {
            v = (Awkfloat) countposn(s1, p1-s1) + 1;    /* origin 1 */
            break;
        }
    }
    tempfree(x);
    tempfree(y);
    setfval(z, v);
    return(z);
}

#define MAXNUMSIZE  50

int format(char **pbuf, int *pbufsize, char *s, Node *a)    /* printf-like conversions */
{
    char *fmt;
    char *p, *t, *os;
    Cell *x;
    int flag = 0, n;
    int fmtwd; /* format width */
    int fmtsz = recsize;
    char *buf = *pbuf;
    int bufsize = *pbufsize;

    os = s;
    p = buf;
    if ((fmt = (char *) malloc(fmtsz)) == NULL)
        FATAL("out of memory in format()");
    while (*s) {
        adjbuf(&buf, &bufsize, MAXNUMSIZE+1+p-buf, recsize, &p, "format");
        if (*s != '%') {
            *p++ = *s++;
            continue;
        }
        if (*(s+1) == '%') {
            *p++ = '%';
            s += 2;
            continue;
        }
        /* have to be real careful in case this is a huge number, eg, %100000d */
        fmtwd = atoi(s+1);
        if (fmtwd < 0)
            fmtwd = -fmtwd;
        adjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, "format");
        for (t = fmt; (*t++ = *s) != '\0'; s++) {
            if (!adjbuf(&fmt, &fmtsz, MAXNUMSIZE+1+t-fmt, recsize, &t, 0))
                FATAL("format item %.30s... ran format() out of memory", os);
            if (isalpha(*s) && *s != 'l' && *s != 'h' && *s != 'L')
                break;  /* the ansi panoply */
            if (*s == '*') {
                x = execute(a);
                a = a->nnext;
                sprintf(t-1, "%d", fmtwd=(int) getfval(x));
                if (fmtwd < 0)
                    fmtwd = -fmtwd;
                adjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, "format");
                t = fmt + strlen(fmt);
                tempfree(x);
            }
        }
        *t = '\0';
        if (fmtwd < 0)
            fmtwd = -fmtwd;
        adjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, "format");

        switch (*s) {
        case 'f': case 'e': case 'g': case 'E': case 'G':
            flag = 1;
            break;
        case 'd': case 'i':
            flag = 2;
            if(*(s-1) == 'l') break;
            *(t-1) = 'l';
            *t = 'd';
            *++t = '\0';
            break;
        case 'o': case 'x': case 'X': case 'u':
            flag = *(s-1) == 'l' ? 2 : 3;
            break;
        case 's':
            flag = 4;
            break;
        case 'c':
            flag = 5;
            break;
        default:
            WARNING("weird printf conversion %s", fmt);
            flag = 0;
            break;
        }
        if (a == NULL)
            FATAL("not enough args in printf(%s)", os);
        x = execute(a);
        a = a->nnext;
        n = MAXNUMSIZE;
        if (fmtwd > n)
            n = fmtwd;
        adjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, "format");
        switch (flag) {
        case 0: sprintf(p, "%s", fmt);  /* unknown, so dump it too */
            t = getsval(x);
            n = strlen(t);
            if (fmtwd > n)
                n = fmtwd;
            adjbuf(&buf, &bufsize, 1+strlen(p)+n+p-buf, recsize, &p, "format");
            p += strlen(p);
            sprintf(p, "%s", t);
            break;
        case 1: sprintf(p, fmt, getfval(x)); break;
        case 2: sprintf(p, fmt, (long) getfval(x)); break;
        case 3: sprintf(p, fmt, (int) getfval(x)); break;
        case 4:
            t = getsval(x);
            n = strlen(t);
            if (fmtwd > n)
                n = fmtwd;
            if (!adjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, 0))
                FATAL("huge string/format (%d chars) in printf %.30s... ran format() out of memory", n, t);
            sprintf(p, fmt, t);
            break;
        case 5:
            if (isnum(x)) {
                if (getfval(x))
                    sprintf(p, fmt, (int) getfval(x));
                else{
                    *p++ = '\0';
                    *p = '\0';
                }
            } else
                sprintf(p, fmt, getsval(x)[0]);
            break;
        }
        tempfree(x);
        p += strlen(p);
        s++;
    }
    *p = '\0';
    free(fmt);
    for ( ; a; a = a->nnext)        /* evaluate any remaining args */
        execute(a);
    *pbuf = buf;
    *pbufsize = bufsize;
    return p - buf;
}

Cell *awksprintf(Node **a, int n)       /* sprintf(a[0]) */
{
    Cell *x;
    Node *y;
    char *buf;
    int bufsz=3*recsize;

    if ((buf = (char *) malloc(bufsz)) == NULL)
        FATAL("out of memory in awksprintf");
    y = a[0]->nnext;
    x = execute(a[0]);
    if (format(&buf, &bufsz, getsval(x), y) == -1)
        FATAL("sprintf string %.30s... too long.  can't happen.", buf);
    tempfree(x);
    x = gettemp();
    x->sval = buf;
    x->tval = STR;
    return(x);
}

Cell *awkprintf(Node **a, int n)        /* printf */
{   /* a[0] is list of args, starting with format string */
    /* a[1] is redirection operator, a[2] is redirection file */
    FILE *fp;
    Cell *x;
    Node *y;
    char *buf;
    int len;
    int bufsz=3*recsize;

    if ((buf = (char *) malloc(bufsz)) == NULL)
        FATAL("out of memory in awkprintf");
    y = a[0]->nnext;
    x = execute(a[0]);
    if ((len = format(&buf, &bufsz, getsval(x), y)) == -1)
        FATAL("printf string %.30s... too long.  can't happen.", buf);
    tempfree(x);
    if (a[1] == NULL) {
        /* fputs(buf, stdout); */
        fwrite(buf, len, 1, stdout);
        if (ferror(stdout))
            FATAL("write error on stdout");
    } else {
        fp = redirect(ptoi(a[1]), a[2]);
        /* fputs(buf, fp); */
        fwrite(buf, len, 1, fp);
        fflush(fp);
        if (ferror(fp))
            FATAL("write error on %s", filename(fp));
    }
    free(buf);
    return(True);
}

Cell *arith(Node **a, int n)    /* a[0] + a[1], etc.  also -a[0] */
{
    Awkfloat i, j = 0;
    double v;
    Cell *x, *y, *z;

    x = execute(a[0]);
    i = getfval(x);
    tempfree(x);
    if (n != UMINUS) {
        y = execute(a[1]);
        j = getfval(y);
        tempfree(y);
    }
    z = gettemp();
    switch (n) {
    case ADD:
        i += j;
        break;
    case MINUS:
        i -= j;
        break;
    case MULT:
        i *= j;
        break;
    case DIVIDE:
        if (j == 0)
            FATAL("division by zero");
        i /= j;
        break;
    case MOD:
        if (j == 0)
            FATAL("division by zero in mod");
        modf(i/j, &v);
        i = i - j * v;
        break;
    case UMINUS:
        i = -i;
        break;
    case POWER:
        if (j >= 0 && modf(j, &v) == 0.0)   /* pos integer exponent */
            i = ipow(i, (int) j);
        else
            i = errcheck(pow(i, j), "pow");
        break;
    default:    /* can't happen */
        FATAL("illegal arithmetic operator %d", n);
    }
    setfval(z, i);
    return(z);
}

double ipow(double x, int n)    /* x**n.  ought to be done by pow, but isn't always */
{
    double v;

    if (n <= 0)
        return 1;
    v = ipow(x, n/2);
    if (n % 2 == 0)
        return v * v;
    else
        return x * v * v;
}

Cell *incrdecr(Node **a, int n)     /* a[0]++, etc. */
{
    Cell *x, *z;
    int k;
    Awkfloat xf;

    x = execute(a[0]);
    xf = getfval(x);
    k = (n == PREINCR || n == POSTINCR) ? 1 : -1;
    if (n == PREINCR || n == PREDECR) {
        setfval(x, xf + k);
        return(x);
    }
    z = gettemp();
    setfval(z, xf);
    setfval(x, xf + k);
    tempfree(x);
    return(z);
}

Cell *assign(Node **a, int n)   /* a[0] = a[1], a[0] += a[1], etc. */
{       /* this is subtle; don't muck with it. */
    Cell *x, *y;
    Awkfloat xf, yf;
    double v;

    y = execute(a[1]);
    x = execute(a[0]);
    if (n == ASSIGN) {  /* ordinary assignment */
        if (x == y && !(x->tval & (FLD|REC)))   /* self-assignment: */
            ;       /* leave alone unless it's a field */
        else if ((y->tval & (STR|NUM)) == (STR|NUM)) {
            setsval(x, getsval(y));
            x->fval = getfval(y);
            x->tval |= NUM;
        }
        else if (isstr(y))
            setsval(x, getsval(y));
        else if (isnum(y))
            setfval(x, getfval(y));
        else
            funnyvar(y, "read value of");
        tempfree(y);
        return(x);
    }
    xf = getfval(x);
    yf = getfval(y);
    switch (n) {
    case ADDEQ:
        xf += yf;
        break;
    case SUBEQ:
        xf -= yf;
        break;
    case MULTEQ:
        xf *= yf;
        break;
    case DIVEQ:
        if (yf == 0)
            FATAL("division by zero in /=");
        xf /= yf;
        break;
    case MODEQ:
        if (yf == 0)
            FATAL("division by zero in %%=");
        modf(xf/yf, &v);
        xf = xf - yf * v;
        break;
    case POWEQ:
        if (yf >= 0 && modf(yf, &v) == 0.0) /* pos integer exponent */
            xf = ipow(xf, (int) yf);
        else
            xf = errcheck(pow(xf, yf), "pow");
        break;
    default:
        FATAL("illegal assignment operator %d", n);
        break;
    }
    tempfree(y);
    setfval(x, xf);
    return(x);
}

Cell *cat(Node **a, int q)  /* a[0] cat a[1] */
{
    Cell *x, *y, *z;
    int n1, n2;
    char *s;

    x = execute(a[0]);
    y = execute(a[1]);
    getsval(x);
    getsval(y);
    n1 = strlen(x->sval);
    n2 = strlen(y->sval);
    s = (char *) malloc(n1 + n2 + 1);
    if (s == NULL)
        FATAL("out of space concatenating %.15s... and %.15s...",
            x->sval, y->sval);
    strcpy(s, x->sval);
    strcpy(s+n1, y->sval);
    tempfree(y);
    z = gettemp();
    z->sval = s;
    z->tval = STR;
    tempfree(x);
    return(z);
}

Cell *pastat(Node **a, int n)   /* a[0] { a[1] } */
{
    Cell *x;

    if (a[0] == 0)
        x = execute(a[1]);
    else {
        x = execute(a[0]);
        if (istrue(x)) {
            tempfree(x);
            x = execute(a[1]);
        }
    }
    return x;
}

Cell *dopa2(Node **a, int n)    /* a[0], a[1] { a[2] } */
{
    Cell *x;
    int pair;

    pair = ptoi(a[3]);
    if (pairstack[pair] == 0) {
        x = execute(a[0]);
        if (istrue(x))
            pairstack[pair] = 1;
        tempfree(x);
    }
    if (pairstack[pair] == 1) {
        x = execute(a[1]);
        if (istrue(x))
            pairstack[pair] = 0;
        tempfree(x);
        x = execute(a[2]);
        return(x);
    }
    return(False);
}

Cell *split(Node **a, int nnn)  /* split(a[0], a[1], a[2]); a[3] is type */
{
    Cell *x = 0, *y, *ap;
    char *s, *t, *fs = 0;
    char temp, num[50];
    int n, nb, sep, tempstat, arg3type;

    y = execute(a[0]);  /* source string */
    s = getsval(y);
    arg3type = ptoi(a[3]);
    if (a[2] == 0)      /* fs string */
        fs = *FS;
    else if (arg3type == STRING) {  /* split(str,arr,"string") */
        x = execute(a[2]);
        fs = getsval(x);
    } else if (arg3type == REGEXPR)
        fs = "(regexpr)";   /* split(str,arr,/regexpr/) */
    else
        FATAL("illegal type of split");
    sep = *fs;
    ap = execute(a[1]); /* array name */
    freesymtab(ap);
       dprintf( ("split: s=|%s|, a=%s, sep=|%s|\n", s, ap->nval, fs) );
    ap->tval &= ~STR;
    ap->tval |= ARR;
    ap->sval = (char *) makesymtab(NSYMTAB);

    n = 0;
    if ((*s != '\0' && strlen(fs) > 1) || arg3type == REGEXPR) {    /* reg expr */
        void *p;
        if (arg3type == REGEXPR) {  /* it's ready already */
            p = (void *) a[2];
        } else {
            p = compre(fs);
        }
        t = s;
        if (nematch(p,s,t)) {
            do {
                n++;
                sprintf(num, "%d", n);
                temp = *patbeg;
                *patbeg = '\0';
                if (is_number(t))
                    setsymtab(num, t, atof(t), STR|NUM, (Array *) ap->sval);
                else
                    setsymtab(num, t, 0.0, STR, (Array *) ap->sval);
                *patbeg = temp;
                t = patbeg + patlen;
                if (t[-1] == 0 || *t == 0) {
                    n++;
                    sprintf(num, "%d", n);
                    setsymtab(num, "", 0.0, STR, (Array *) ap->sval);
                    goto spdone;
                }
            } while (nematch(p,s,t));
        }
        n++;
        sprintf(num, "%d", n);
        if (is_number(t))
            setsymtab(num, t, atof(t), STR|NUM, (Array *) ap->sval);
        else
            setsymtab(num, t, 0.0, STR, (Array *) ap->sval);
  spdone:
        p = NULL;
    } else if (sep == ' ') {
        for (n = 0; ; ) {
            while (*s == ' ' || *s == '\t' || *s == '\n')
                s++;
            if (*s == 0)
                break;
            n++;
            t = s;
            do
                s++;
            while (*s!=' ' && *s!='\t' && *s!='\n' && *s!='\0');
            temp = *s;
            *s = '\0';
            sprintf(num, "%d", n);
            if (is_number(t))
                setsymtab(num, t, atof(t), STR|NUM, (Array *) ap->sval);
            else
                setsymtab(num, t, 0.0, STR, (Array *) ap->sval);
            *s = temp;
            if (*s != 0)
                s++;
        }
    } else if (sep == 0) {  /* new: split(s, a, "") => 1 char/elem */
        for (n = 0; *s != 0; s += nb) {
            Rune r;
            char buf[UTFmax+1];

            n++;
            snprintf(num, sizeof num, "%d", n);
            nb = chartorune(&r, s);
            memmove(buf, s, nb);
            buf[nb] = '\0';
            if (isdigit(buf[0]))
                setsymtab(num, buf, atof(buf), STR|NUM, (Array *) ap->sval);
            else
                setsymtab(num, buf, 0.0, STR, (Array *) ap->sval);
        }
    } else if (*s != 0) {
        for (;;) {
            n++;
            t = s;
            while (*s != sep && *s != '\n' && *s != '\0')
                s++;
            temp = *s;
            *s = '\0';
            sprintf(num, "%d", n);
            if (is_number(t))
                setsymtab(num, t, atof(t), STR|NUM, (Array *) ap->sval);
            else
                setsymtab(num, t, 0.0, STR, (Array *) ap->sval);
            *s = temp;
            if (*s++ == 0)
                break;
        }
    }
    tempfree(ap);
    tempfree(y);
    if (a[2] != 0 && arg3type == STRING)
        tempfree(x);
    x = gettemp();
    x->tval = NUM;
    x->fval = n;
    return(x);
}

Cell *condexpr(Node **a, int n) /* a[0] ? a[1] : a[2] */
{
    Cell *x;

    x = execute(a[0]);
    if (istrue(x)) {
        tempfree(x);
        x = execute(a[1]);
    } else {
        tempfree(x);
        x = execute(a[2]);
    }
    return(x);
}

Cell *ifstat(Node **a, int n)   /* if (a[0]) a[1]; else a[2] */
{
    Cell *x;

    x = execute(a[0]);
    if (istrue(x)) {
        tempfree(x);
        x = execute(a[1]);
    } else if (a[2] != 0) {
        tempfree(x);
        x = execute(a[2]);
    }
    return(x);
}

Cell *whilestat(Node **a, int n)    /* while (a[0]) a[1] */
{
    Cell *x;

    for (;;) {
        x = execute(a[0]);
        if (!istrue(x))
            return(x);
        tempfree(x);
        x = execute(a[1]);
        if (isbreak(x)) {
            x = True;
            return(x);
        }
        if (isnext(x) || isexit(x) || isret(x))
            return(x);
        tempfree(x);
    }
}

Cell *dostat(Node **a, int n)   /* do a[0]; while(a[1]) */
{
    Cell *x;

    for (;;) {
        x = execute(a[0]);
        if (isbreak(x))
            return True;
        if (isnext(x) || isnextfile(x) || isexit(x) || isret(x))
            return(x);
        tempfree(x);
        x = execute(a[1]);
        if (!istrue(x))
            return(x);
        tempfree(x);
    }
}

Cell *forstat(Node **a, int n)  /* for (a[0]; a[1]; a[2]) a[3] */
{
    Cell *x;

    x = execute(a[0]);
    tempfree(x);
    for (;;) {
        if (a[1]!=0) {
            x = execute(a[1]);
            if (!istrue(x)) return(x);
            else tempfree(x);
        }
        x = execute(a[3]);
        if (isbreak(x))     /* turn off break */
            return True;
        if (isnext(x) || isexit(x) || isret(x))
            return(x);
        tempfree(x);
        x = execute(a[2]);
        tempfree(x);
    }
}

Cell *instat(Node **a, int n)   /* for (a[0] in a[1]) a[2] */
{
    Cell *x, *vp, *arrayp, *cp, *ncp;
    Array *tp;
    int i;

    vp = execute(a[0]);
    arrayp = execute(a[1]);
    if (!isarr(arrayp)) {
        return True;
    }
    tp = (Array *) arrayp->sval;
    tempfree(arrayp);
    for (i = 0; i < tp->size; i++) {    /* this routine knows too much */
        for (cp = tp->tab[i]; cp != NULL; cp = ncp) {
            setsval(vp, cp->nval);
            ncp = cp->cnext;
            x = execute(a[2]);
            if (isbreak(x)) {
                tempfree(vp);
                return True;
            }
            if (isnext(x) || isexit(x) || isret(x)) {
                tempfree(vp);
                return(x);
            }
            tempfree(x);
        }
    }
    return True;
}

Cell *bltin(Node **a, int n)    /* builtin functions. a[0] is type, a[1] is arg list */
{
    Cell *x, *y;
    Awkfloat u;
    int t;
    wchar_t wc;
    char *p, *buf;
    char mbc[50];
    Node *nextarg;
    FILE *fp;
    void flush_all(void);

    t = ptoi(a[0]);
    x = execute(a[1]);
    nextarg = a[1]->nnext;
    switch (t) {
    case FLENGTH:
        if (isarr(x))
            u = ((Array *) x->sval)->nelem; /* GROT. should be function*/
        else {
            p = getsval(x);
            u = (Awkfloat) countposn(p, strlen(p));
        }
        break;
    case FLOG:
        u = errcheck(log(getfval(x)), "log"); break;
    case FINT:
        modf(getfval(x), &u); break;
    case FEXP:
        u = errcheck(exp(getfval(x)), "exp"); break;
    case FSQRT:
        u = errcheck(sqrt(getfval(x)), "sqrt"); break;
    case FSIN:
        u = sin(getfval(x)); break;
    case FCOS:
        u = cos(getfval(x)); break;
    case FATAN:
        if (nextarg == 0) {
            WARNING("atan2 requires two arguments; returning 1.0");
            u = 1.0;
        } else {
            y = execute(a[1]->nnext);
            u = atan2(getfval(x), getfval(y));
            tempfree(y);
            nextarg = nextarg->nnext;
        }
        break;
    case FSYSTEM:
        fflush(stdout);     /* in case something is buffered already */
        u = (Awkfloat) system(getsval(x)) / 256;   /* 256 is unix-dep */
        break;
    case FRAND:
        /* in principle, rand() returns something in 0..RAND_MAX */
        u = (Awkfloat) (rand() % RAND_MAX) / RAND_MAX;
        break;
    case FSRAND:
        if (isrec(x))   /* no argument provided */
            u = time((time_t *)0);
        else
            u = getfval(x);
        srand((unsigned int) u);
        break;
    case FTOUPPER:
    case FTOLOWER:
        buf = tostring(getsval(x));
        if (t == FTOUPPER) {
            for (p = buf; *p; p++)
                if (islower(*p))
                    *p = toupper(*p);
        } else {
            for (p = buf; *p; p++)
                if (isupper(*p))
                    *p = tolower(*p);
        }
        tempfree(x);
        x = gettemp();
        setsval(x, buf);
        free(buf);
        return x;
    case FFLUSH:
        if (isrec(x) || strlen(getsval(x)) == 0) {
            flush_all();    /* fflush() or fflush("") -> all */
            u = 0;
        } else if ((fp = openfile(FFLUSH, getsval(x))) == NULL)
            u = EOF;
        else
            u = fflush(fp);
        break;
    case FUTF:
        wc = (int)getfval(x);
        mbc[wctomb(mbc, wc)] = 0;
        tempfree(x);
        x = gettemp();
        setsval(x, mbc);
        return x;
    default:    /* can't happen */
        FATAL("illegal function type %d", t);
        break;
    }
    tempfree(x);
    x = gettemp();
    setfval(x, u);
    if (nextarg != 0) {
        WARNING("warning: function has too many arguments");
        for ( ; nextarg; nextarg = nextarg->nnext)
            execute(nextarg);
    }
    return(x);
}

Cell *printstat(Node **a, int n)    /* print a[0] */
{
    int r;
    Node *x;
    Cell *y;
    FILE *fp;

    if (a[1] == 0)  /* a[1] is redirection operator, a[2] is file */
        fp = stdout;
    else
        fp = redirect(ptoi(a[1]), a[2]);
    for (x = a[0]; x != NULL; x = x->nnext) {
        y = execute(x);
        fputs(getsval(y), fp);
        tempfree(y);
        if (x->nnext == NULL)
            r = fputs(*ORS, fp);
        else
            r = fputs(*OFS, fp);
        if (r == EOF)
            FATAL("write error on %s", filename(fp));
    }
    if (a[1] != 0)
        if (fflush(fp) == EOF)
            FATAL("write error on %s", filename(fp));
    return(True);
}

Cell *nullproc(Node **a, int n)
{
    n = n;
    a = a;
    return 0;
}


FILE *redirect(int a, Node *b)  /* set up all i/o redirections */
{
    FILE *fp;
    Cell *x;
    char *fname;

    x = execute(b);
    fname = getsval(x);
    fp = openfile(a, fname);
    if (fp == NULL)
        FATAL("can't open file %s", fname);
    tempfree(x);
    return fp;
}

struct files {
    FILE    *fp;
    char    *fname;
    int mode;   /* '|', 'a', 'w' => LE/LT, GT */
} files[FOPEN_MAX] ={
    { NULL,  "/dev/stdin",  LT },   /* watch out: don't free this! */
    { NULL, "/dev/stdout", GT },
    { NULL, "/dev/stderr", GT }
};

void stdinit(void)  /* in case stdin, etc., are not constants */
{
    files[0].fp = stdin;
    files[1].fp = stdout;
    files[2].fp = stderr;
}

FILE *openfile(int a, char *us)
{
    char *s = us;
    int i, m;
    FILE *fp = 0;

    if (*s == '\0')
        FATAL("null file name in print or getline");
    for (i=0; i < FOPEN_MAX; i++)
        if (files[i].fname && strcmp(s, files[i].fname) == 0) {
            if (a == files[i].mode || (a==APPEND && files[i].mode==GT))
                return files[i].fp;
            if (a == FFLUSH)
                return files[i].fp;
        }
    if (a == FFLUSH)    /* didn't find it, so don't create it! */
        return NULL;

    for (i=0; i < FOPEN_MAX; i++)
        if (files[i].fp == 0)
            break;
    if (i >= FOPEN_MAX)
        FATAL("%s makes too many open files", s);
    fflush(stdout); /* force a semblance of order */
    m = a;
    if (a == GT) {
        fp = fopen(s, "w");
    } else if (a == APPEND) {
        fp = fopen(s, "a");
        m = GT; /* so can mix > and >> */
    } else if (a == '|') {  /* output pipe */
        fp = popen(s, "w");
    } else if (a == LE) {   /* input pipe */
        fp = popen(s, "r");
    } else if (a == LT) {   /* getline <file */
        fp = strcmp(s, "-") == 0 ? stdin : fopen(s, "r");   /* "-" is stdin */
    } else  /* can't happen */
        FATAL("illegal redirection %d", a);
    if (fp != NULL) {
        files[i].fname = tostring(s);
        files[i].fp = fp;
        files[i].mode = m;
    }
    return fp;
}

char *filename(FILE *fp)
{
    int i;

    for (i = 0; i < FOPEN_MAX; i++)
        if (fp == files[i].fp)
            return files[i].fname;
    return "???";
}

Cell *closefile(Node **a, int n)
{
    Cell *x;
    int i, stat;

    n = n;
    x = execute(a[0]);
    getsval(x);
    for (i = 0; i < FOPEN_MAX; i++)
        if (files[i].fname && strcmp(x->sval, files[i].fname) == 0) {
            if (ferror(files[i].fp))
                WARNING( "i/o error occurred on %s", files[i].fname );
            if (files[i].mode == '|' || files[i].mode == LE)
                stat = pclose(files[i].fp);
            else
                stat = fclose(files[i].fp);
            if (stat == EOF)
                WARNING( "i/o error occurred closing %s", files[i].fname );
            if (i > 2)  /* don't do /dev/std... */
                xfree(files[i].fname);
            files[i].fname = NULL;  /* watch out for ref thru this */
            files[i].fp = NULL;
        }
    tempfree(x);
    return(True);
}

void closeall(void)
{
    int i, stat;

    for (i = 0; i < FOPEN_MAX; i++)
        if (files[i].fp) {
            if (ferror(files[i].fp))
                WARNING( "i/o error occurred on %s", files[i].fname );
            if (files[i].mode == '|' || files[i].mode == LE)
                stat = pclose(files[i].fp);
            else
                stat = fclose(files[i].fp);
            if (stat == EOF)
                WARNING( "i/o error occurred while closing %s", files[i].fname );
        }
}

void flush_all(void)
{
    int i;

    for (i = 0; i < FOPEN_MAX; i++)
        if (files[i].fp)
            fflush(files[i].fp);
}

void backsub(char **pb_ptr, char **sptr_ptr);

Cell *sub(Node **a, int nnn)    /* substitute command */
{
    char *sptr, *pb, *q;
    Cell *x, *y, *result;
    char *t, *buf;
    void *p;
    int bufsz = recsize;

    if ((buf = (char *) malloc(bufsz)) == NULL)
        FATAL("out of memory in sub");
    x = execute(a[3]);  /* target string */
    t = getsval(x);
    if (a[0] == 0)      /* 0 => a[1] is already-compiled regexpr */
        p = (void *) a[1];  /* regular expression */
    else {
        y = execute(a[1]);
        p = compre(getsval(y));
        tempfree(y);
    }
    y = execute(a[2]);  /* replacement string */
    result = False;
    if (pmatch(p, t, t)) {
        sptr = t;
        adjbuf(&buf, &bufsz, 1+patbeg-sptr, recsize, 0, "sub");
        pb = buf;
        while (sptr < patbeg)
            *pb++ = *sptr++;
        sptr = getsval(y);
        while (*sptr != 0) {
            adjbuf(&buf, &bufsz, 5+pb-buf, recsize, &pb, "sub");
            if (*sptr == '\\') {
                backsub(&pb, &sptr);
            } else if (*sptr == '&') {
                sptr++;
                adjbuf(&buf, &bufsz, 1+patlen+pb-buf, recsize, &pb, "sub");
                for (q = patbeg; q < patbeg+patlen; )
                    *pb++ = *q++;
            } else
                *pb++ = *sptr++;
        }
        *pb = '\0';
        if (pb > buf + bufsz)
            FATAL("sub result1 %.30s too big; can't happen", buf);
        sptr = patbeg + patlen;
        if ((patlen == 0 && *patbeg) || (patlen && *(sptr-1))) {
            adjbuf(&buf, &bufsz, 1+strlen(sptr)+pb-buf, 0, &pb, "sub");
            while ((*pb++ = *sptr++) != 0)
                ;
        }
        if (pb > buf + bufsz)
            FATAL("sub result2 %.30s too big; can't happen", buf);
        setsval(x, buf);    /* BUG: should be able to avoid copy */
        result = True;;
    }
    tempfree(x);
    tempfree(y);
    free(buf);
    return result;
}

Cell *gsub(Node **a, int nnn)   /* global substitute */
{
    Cell *x, *y;
    char *rptr, *sptr, *t, *pb, *c;
    char *buf;
    void *p;
    int mflag, num;
    int bufsz = recsize;

    if ((buf = (char *)malloc(bufsz)) == NULL)
        FATAL("out of memory in gsub");
    mflag = 0;  /* if mflag == 0, can replace empty string */
    num = 0;
    x = execute(a[3]);  /* target string */
    c = t = getsval(x);
    if (a[0] == 0)      /* 0 => a[1] is already-compiled regexpr */
        p = (void *) a[1];  /* regular expression */
    else {
        y = execute(a[1]);
        p = compre(getsval(y));
        tempfree(y);
    }
    y = execute(a[2]);  /* replacement string */
    if (pmatch(p, t, c)) {
        pb = buf;
        rptr = getsval(y);
        do {
            if (patlen == 0 && *patbeg != 0) {  /* matched empty string */
                if (mflag == 0) {   /* can replace empty */
                    num++;
                    sptr = rptr;
                    while (*sptr != 0) {
                        adjbuf(&buf, &bufsz, 5+pb-buf, recsize, &pb, "gsub");
                        if (*sptr == '\\') {
                            backsub(&pb, &sptr);
                        } else if (*sptr == '&') {
                            char *q;
                            sptr++;
                            adjbuf(&buf, &bufsz, 1+patlen+pb-buf, recsize, &pb, "gsub");
                            for (q = patbeg; q < patbeg+patlen; )
                                *pb++ = *q++;
                        } else
                            *pb++ = *sptr++;
                    }
                }
                if (*c == 0)    /* at end */
                    goto done;
                adjbuf(&buf, &bufsz, 2+pb-buf, recsize, &pb, "gsub");
                *pb++ = *c++;
                if (pb > buf + bufsz)   /* BUG: not sure of this test */
                    FATAL("gsub result0 %.30s too big; can't happen", buf);
                mflag = 0;
            }
            else {  /* matched nonempty string */
                num++;
                sptr = c;
                adjbuf(&buf, &bufsz, 1+(patbeg-sptr)+pb-buf, recsize, &pb, "gsub");
                while (sptr < patbeg)
                    *pb++ = *sptr++;
                sptr = rptr;
                while (*sptr != 0) {
                    adjbuf(&buf, &bufsz, 5+pb-buf, recsize, &pb, "gsub");
                    if (*sptr == '\\') {
                        backsub(&pb, &sptr);
                    } else if (*sptr == '&') {
                        char *q;
                        sptr++;
                        adjbuf(&buf, &bufsz, 1+patlen+pb-buf, recsize, &pb, "gsub");
                        for (q = patbeg; q < patbeg+patlen; )
                            *pb++ = *q++;
                    } else
                        *pb++ = *sptr++;
                }
                c = patbeg + patlen;
                if ((c[-1] == 0) || (*c == 0))
                    goto done;
                if (pb > buf + bufsz)
                    FATAL("gsub result1 %.30s too big; can't happen", buf);
                mflag = 1;
            }
        } while (pmatch(p, t, c));
        sptr = c;
        adjbuf(&buf, &bufsz, 1+strlen(sptr)+pb-buf, 0, &pb, "gsub");
        while ((*pb++ = *sptr++) != 0)
            ;
    done:   if (pb > buf + bufsz)
            FATAL("gsub result2 %.30s too big; can't happen", buf);
        *pb = '\0';
        setsval(x, buf);    /* BUG: should be able to avoid copy + free */
    }
    tempfree(x);
    tempfree(y);
    x = gettemp();
    x->tval = NUM;
    x->fval = num;
    free(buf);
    return(x);
}

void backsub(char **pb_ptr, char **sptr_ptr)    /* handle \\& variations */
{                       /* sptr[0] == '\\' */
    char *pb = *pb_ptr, *sptr = *sptr_ptr;

    if (sptr[1] == '\\') {
        if (sptr[2] == '\\' && sptr[3] == '&') { /* \\\& -> \& */
            *pb++ = '\\';
            *pb++ = '&';
            sptr += 4;
        } else if (sptr[2] == '&') {    /* \\& -> \ + matched */
            *pb++ = '\\';
            sptr += 2;
        } else {            /* \\x -> \\x */
            *pb++ = *sptr++;
            *pb++ = *sptr++;
        }
    } else if (sptr[1] == '&') {    /* literal & */
        sptr++;
        *pb++ = *sptr++;
    } else              /* literal \ */
        *pb++ = *sptr++;

    *pb_ptr = pb;
    *sptr_ptr = sptr;
}
@

\subsection{[[awk/tran.c]]}

<<awk/tran.c>>=
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#define DEBUG
#include <stdio.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "awk.h"
#include "y.tab.h"

#define FULLTAB 2   /* rehash when table gets this x full */
#define GROWTAB 4   /* grow table by this factor */

Array   *symtab;    /* main symbol table */

char    **FS;       /* initial field sep */
char    **RS;       /* initial record sep */
char    **OFS;      /* output field sep */
char    **ORS;      /* output record sep */
char    **OFMT;     /* output format for numbers */
char    **CONVFMT;  /* format for conversions in getsval */
Awkfloat *NF;       /* number of fields in current record */
Awkfloat *NR;       /* number of current record */
Awkfloat *FNR;      /* number of current record in current file */
char    **FILENAME; /* current filename argument */
Awkfloat *ARGC;     /* number of arguments from command line */
char    **SUBSEP;   /* subscript separator for a[i,j,k]; default \034 */
Awkfloat *RSTART;   /* start of re matched with ~; origin 1 (!) */
Awkfloat *RLENGTH;  /* length of same */

Cell    *nrloc;     /* NR */
Cell    *nfloc;     /* NF */
Cell    *fnrloc;    /* FNR */
Array   *ARGVtab;   /* symbol table containing ARGV[...] */
Array   *ENVtab;    /* symbol table containing ENVIRON[...] */
Cell    *rstartloc; /* RSTART */
Cell    *rlengthloc;    /* RLENGTH */
Cell    *symtabloc; /* SYMTAB */

Cell    *nullloc;   /* a guaranteed empty cell */
Node    *nullnode;  /* zero&null, converted into a node for comparisons */
Cell    *literal0;

extern Cell **fldtab;

void syminit(void)  /* initialize symbol table with builtin vars */
{
    literal0 = setsymtab("0", "0", 0.0, NUM|STR|CON|DONTFREE, symtab);
    /* this is used for if(x)... tests: */
    nullloc = setsymtab("$zero&null", "", 0.0, NUM|STR|CON|DONTFREE, symtab);
    nullnode = celltonode(nullloc, CCON);

    FS = &setsymtab("FS", " ", 0.0, STR|DONTFREE, symtab)->sval;
    RS = &setsymtab("RS", "\n", 0.0, STR|DONTFREE, symtab)->sval;
    OFS = &setsymtab("OFS", " ", 0.0, STR|DONTFREE, symtab)->sval;
    ORS = &setsymtab("ORS", "\n", 0.0, STR|DONTFREE, symtab)->sval;
    OFMT = &setsymtab("OFMT", "%.6g", 0.0, STR|DONTFREE, symtab)->sval;
    CONVFMT = &setsymtab("CONVFMT", "%.6g", 0.0, STR|DONTFREE, symtab)->sval;
    FILENAME = &setsymtab("FILENAME", "", 0.0, STR|DONTFREE, symtab)->sval;
    nfloc = setsymtab("NF", "", 0.0, NUM, symtab);
    NF = &nfloc->fval;
    nrloc = setsymtab("NR", "", 0.0, NUM, symtab);
    NR = &nrloc->fval;
    fnrloc = setsymtab("FNR", "", 0.0, NUM, symtab);
    FNR = &fnrloc->fval;
    SUBSEP = &setsymtab("SUBSEP", "\034", 0.0, STR|DONTFREE, symtab)->sval;
    rstartloc = setsymtab("RSTART", "", 0.0, NUM, symtab);
    RSTART = &rstartloc->fval;
    rlengthloc = setsymtab("RLENGTH", "", 0.0, NUM, symtab);
    RLENGTH = &rlengthloc->fval;
    symtabloc = setsymtab("SYMTAB", "", 0.0, ARR, symtab);
    symtabloc->sval = (char *) symtab;
}

void arginit(int ac, char **av) /* set up ARGV and ARGC */
{
    Cell *cp;
    int i;
    char temp[50];

    ARGC = &setsymtab("ARGC", "", (Awkfloat) ac, NUM, symtab)->fval;
    cp = setsymtab("ARGV", "", 0.0, ARR, symtab);
    ARGVtab = makesymtab(NSYMTAB);  /* could be (int) ARGC as well */
    cp->sval = (char *) ARGVtab;
    for (i = 0; i < ac; i++) {
        sprintf(temp, "%d", i);
        if (is_number(*av))
            setsymtab(temp, *av, atof(*av), STR|NUM, ARGVtab);
        else
            setsymtab(temp, *av, 0.0, STR, ARGVtab);
        av++;
    }
}

void envinit(char **envp)   /* set up ENVIRON variable */
{
    Cell *cp;
    char *p;

    cp = setsymtab("ENVIRON", "", 0.0, ARR, symtab);
    ENVtab = makesymtab(NSYMTAB);
    cp->sval = (char *) ENVtab;
    for ( ; *envp; envp++) {
        if ((p = strchr(*envp, '=')) == NULL)
            continue;
        *p++ = 0;   /* split into two strings at = */
        if (is_number(p))
            setsymtab(*envp, p, atof(p), STR|NUM, ENVtab);
        else
            setsymtab(*envp, p, 0.0, STR, ENVtab);
        p[-1] = '=';    /* restore in case env is passed down to a shell */
    }
}

Array *makesymtab(int n)    /* make a new symbol table */
{
    Array *ap;
    Cell **tp;

    ap = (Array *) malloc(sizeof(Array));
    tp = (Cell **) calloc(n, sizeof(Cell *));
    if (ap == NULL || tp == NULL)
        FATAL("out of space in makesymtab");
    ap->nelem = 0;
    ap->size = n;
    ap->tab = tp;
    return(ap);
}

void freesymtab(Cell *ap)   /* free a symbol table */
{
    Cell *cp, *temp;
    Array *tp;
    int i;

    if (!isarr(ap))
        return;
    tp = (Array *) ap->sval;
    if (tp == NULL)
        return;
    for (i = 0; i < tp->size; i++) {
        for (cp = tp->tab[i]; cp != NULL; cp = temp) {
            xfree(cp->nval);
            if (freeable(cp))
                xfree(cp->sval);
            temp = cp->cnext;   /* avoids freeing then using */
            free(cp); 
        }
        tp->tab[i] = 0;
    }
    free(tp->tab);
    free(tp);
}

void freeelem(Cell *ap, char *s)    /* free elem s from ap (i.e., ap["s"] */
{
    Array *tp;
    Cell *p, *prev = NULL;
    int h;
    
    tp = (Array *) ap->sval;
    h = hash(s, tp->size);
    for (p = tp->tab[h]; p != NULL; prev = p, p = p->cnext)
        if (strcmp(s, p->nval) == 0) {
            if (prev == NULL)   /* 1st one */
                tp->tab[h] = p->cnext;
            else            /* middle somewhere */
                prev->cnext = p->cnext;
            if (freeable(p))
                xfree(p->sval);
            free(p->nval);
            free(p);
            tp->nelem--;
            return;
        }
}

Cell *setsymtab(char *n, char *s, Awkfloat f, unsigned t, Array *tp)
{
    int h;
    Cell *p;

    if (n != NULL && (p = lookup(n, tp)) != NULL) {
           dprintf( ("setsymtab found %p: n=%s s=\"%s\" f=%g t=%o\n",
            p, p->nval, p->sval, p->fval, p->tval) );
        return(p);
    }
    p = (Cell *) malloc(sizeof(Cell));
    if (p == NULL)
        FATAL("out of space for symbol table at %s", n);
    p->nval = tostring(n);
    p->sval = s ? tostring(s) : tostring("");
    p->fval = f;
    p->tval = t;
    p->csub = CUNK;
    p->ctype = OCELL;
    tp->nelem++;
    if (tp->nelem > FULLTAB * tp->size)
        rehash(tp);
    h = hash(n, tp->size);
    p->cnext = tp->tab[h];
    tp->tab[h] = p;
       dprintf( ("setsymtab set %p: n=%s s=\"%s\" f=%g t=%o\n",
        p, p->nval, p->sval, p->fval, p->tval) );
    return(p);
}

int hash(char *s, int n)    /* form hash value for string s */
{
    unsigned hashval;

    for (hashval = 0; *s != '\0'; s++)
        hashval = (*s + 31 * hashval);
    return hashval % n;
}

void rehash(Array *tp)  /* rehash items in small table into big one */
{
    int i, nh, nsz;
    Cell *cp, *op, **np;

    nsz = GROWTAB * tp->size;
    np = (Cell **) calloc(nsz, sizeof(Cell *));
    if (np == NULL)     /* can't do it, but can keep running. */
        return;     /* someone else will run out later. */
    for (i = 0; i < tp->size; i++) {
        for (cp = tp->tab[i]; cp; cp = op) {
            op = cp->cnext;
            nh = hash(cp->nval, nsz);
            cp->cnext = np[nh];
            np[nh] = cp;
        }
    }
    free(tp->tab);
    tp->tab = np;
    tp->size = nsz;
}

Cell *lookup(char *s, Array *tp)    /* look for s in tp */
{
    Cell *p;
    int h;

    h = hash(s, tp->size);
    for (p = tp->tab[h]; p != NULL; p = p->cnext)
        if (strcmp(s, p->nval) == 0)
            return(p);  /* found it */
    return(NULL);           /* not found */
}

Awkfloat setfval(Cell *vp, Awkfloat f)  /* set float val of a Cell */
{
    int fldno;

    if ((vp->tval & (NUM | STR)) == 0) 
        funnyvar(vp, "assign to");
    if (isfld(vp)) {
        donerec = 0;    /* mark $0 invalid */
        fldno = atoi(vp->nval);
        if (fldno > *NF)
            newfld(fldno);
           dprintf( ("setting field %d to %g\n", fldno, f) );
    } else if (isrec(vp)) {
        donefld = 0;    /* mark $1... invalid */
        donerec = 1;
    }
    if (freeable(vp))
        xfree(vp->sval); /* free any previous string */
    vp->tval &= ~STR;   /* mark string invalid */
    vp->tval |= NUM;    /* mark number ok */
       dprintf( ("setfval %p: %s = %g, t=%o\n", vp, vp->nval, f, vp->tval) );
    return vp->fval = f;
}

void funnyvar(Cell *vp, char *rw)
{
    if (isarr(vp))
        FATAL("can't %s %s; it's an array name.", rw, vp->nval);
    if (vp->tval & FCN)
        FATAL("can't %s %s; it's a function.", rw, vp->nval);
    WARNING("funny variable %p: n=%s s=\"%s\" f=%g t=%o",
        vp, vp->nval, vp->sval, vp->fval, vp->tval);
}

char *setsval(Cell *vp, char *s)    /* set string val of a Cell */
{
    char *t;
    int fldno;

       dprintf( ("starting setsval %p: %s = \"%s\", t=%o\n", vp, vp->nval, s, vp->tval) );
    if ((vp->tval & (NUM | STR)) == 0)
        funnyvar(vp, "assign to");
    if (isfld(vp)) {
        donerec = 0;    /* mark $0 invalid */
        fldno = atoi(vp->nval);
        if (fldno > *NF)
            newfld(fldno);
           dprintf( ("setting field %d to %s (%p)\n", fldno, s, s) );
    } else if (isrec(vp)) {
        donefld = 0;    /* mark $1... invalid */
        donerec = 1;
    }
    t = tostring(s);    /* in case it's self-assign */
    vp->tval &= ~NUM;
    vp->tval |= STR;
    if (freeable(vp))
        xfree(vp->sval);
    vp->tval &= ~DONTFREE;
       dprintf( ("setsval %p: %s = \"%s (%p)\", t=%o\n", vp, vp->nval, t,t, vp->tval) );
    return(vp->sval = t);
}

Awkfloat getfval(Cell *vp)  /* get float val of a Cell */
{
    if ((vp->tval & (NUM | STR)) == 0)
        funnyvar(vp, "read value of");
    if (isfld(vp) && donefld == 0)
        fldbld();
    else if (isrec(vp) && donerec == 0)
        recbld();
    if (!isnum(vp)) {   /* not a number */
        vp->fval = atof(vp->sval);  /* best guess */
        if (is_number(vp->sval) && !(vp->tval&CON))
            vp->tval |= NUM;    /* make NUM only sparingly */
    }
       dprintf( ("getfval %p: %s = %g, t=%o\n", vp, vp->nval, vp->fval, vp->tval) );
    return(vp->fval);
}

char *getsval(Cell *vp) /* get string val of a Cell */
{
    char s[100];    /* BUG: unchecked */
    double dtemp;

    if ((vp->tval & (NUM | STR)) == 0)
        funnyvar(vp, "read value of");
    if (isfld(vp) && donefld == 0)
        fldbld();
    else if (isrec(vp) && donerec == 0)
        recbld();
    if (isstr(vp) == 0) {
        if (freeable(vp))
            xfree(vp->sval);
        if (modf(vp->fval, &dtemp) == 0)    /* it's integral */
            sprintf(s, "%.30g", vp->fval);
        else
            sprintf(s, *CONVFMT, vp->fval);
        vp->sval = tostring(s);
        vp->tval &= ~DONTFREE;
        vp->tval |= STR;
    }
       dprintf( ("getsval %p: %s = \"%s (%p)\", t=%o\n", vp, vp->nval, vp->sval, vp->sval, vp->tval) );
    return(vp->sval);
}

char *tostring(char *s) /* make a copy of string s */
{
    char *p;

    p = (char *) malloc(strlen(s)+1);
    if (p == NULL)
        FATAL("out of space in tostring on %s", s);
    strcpy(p, s);
    return(p);
}

char *qstring(char *s, int delim)   /* collect string up to next delim */
{
    char *os = s;
    int c, n;
    char *buf, *bp;

    if ((buf = (char *) malloc(strlen(s)+3)) == NULL)
        FATAL( "out of space in qstring(%s)", s);
    for (bp = buf; (c = *s) != delim; s++) {
        if (c == '\n')
            SYNTAX( "newline in string %.20s...", os );
        else if (c != '\\')
            *bp++ = c;
        else {  /* \something */
            c = *++s;
            if (c == 0) {   /* \ at end */
                *bp++ = '\\';
                break;  /* for loop */
            }   
            switch (c) {
            case '\\':  *bp++ = '\\'; break;
            case 'n':   *bp++ = '\n'; break;
            case 't':   *bp++ = '\t'; break;
            case 'b':   *bp++ = '\b'; break;
            case 'f':   *bp++ = '\f'; break;
            case 'r':   *bp++ = '\r'; break;
            default:
                if (!isdigit(c)) {
                    *bp++ = c;
                    break;
                }
                n = c - '0';
                if (isdigit(s[1])) {
                    n = 8 * n + *++s - '0';
                    if (isdigit(s[1]))
                        n = 8 * n + *++s - '0';
                }
                *bp++ = n;
                break;
            }
        }
    }
    *bp++ = 0;
    return buf;
}
@



\section{[[archive/]]}

\subsection{[[archive/tar.c]]}

<<globals tar.c>>=
<<global [[verb]](tar.c)>>
@

%-----------------------------------------------------------------
<<archive/tar.c>>=
/*
 * tar - `tape archiver', actually usable on any medium.
 *  POSIX "ustar" compliant when extracting, and by default when creating.
 *  this tar attempts to read and write multiple Tblock-byte blocks
 *  at once to and from the filesystem, and does not copy blocks
 *  around internally.
 */
<<plan9 includes>>
#include <ctype.h>
//#include <fcall.h>      /* for %M */
#include <str.h>

<<macros [[TARGxxx]](tar.c)>>

#define HOWMANY(a, size)    (((a) + (size) - 1) / (size))
#define BYTES2TBLKS(bytes)  HOWMANY(bytes, Tblock)

/* read big-endian binary integers; args must be (uchar *) */
#define G2BEBYTE(x) (((x)[0]<<8)  |  (x)[1])
#define G3BEBYTE(x) (((x)[0]<<16) | ((x)[1]<<8)  |  (x)[2])
#define G4BEBYTE(x) (((x)[0]<<24) | ((x)[1]<<16) | ((x)[2]<<8) | (x)[3])
#define G8BEBYTE(x) (((vlong)G4BEBYTE(x)<<32) | (u32int)G4BEBYTE((x)+4))

typedef vlong Off;
typedef char *(*Refill)(int ar, char *bufs, int justhdr);

// nice enums! tar is modern! types!
enum { Rd, Wr };            /* pipe fd-array indices */
enum { Output, Input };
<<enum [[Verb]]>>
enum { Alldata, Justnxthdr };
enum {
    <<constants tar.c>>
};

/* POSIX link flags */
<<enum [[LinkFlag]](tar.c)>>
<<macros [[islinkxxx]](tar.c)>>

<<union [[Hdr]](tar.c)>>

<<struct [[Compress]](tar.c)>>
<<constant [[comps]](tar.c)>>

<<struct [[Pushstate]](tar.c)>>

#define OTHER(rdwr) ((rdwr) == Rd? Wr: Rd)

<<globals tar.c>>
<<global flags tar.c>>
static int debug;
static int fixednblock;
static int keepexisting;
static Off blkoff;      /* offset of the current archive block (not Tblock) */
static Off nexthdr;

static char *arname = "archive";
static char origdir[Maxname*2];
static Hdr *curblk;

<<function [[usage]](tar.c)>>

/* I/O, with error retry or exit */

static int
cope(char *name, int fd, void *buf, long len, Off off)
{
    fprint(2, "%s: %serror reading %s: %r\n", argv0,
        (ignerrs? "ignoring ": ""), name);
    if (!ignerrs)
        exits("read error");

    /* pretend we read len bytes of zeroes */
    memset(buf, 0, len);
    if (off >= 0)           /* seekable? */
        seek(fd, off + len, 0);
    return len;
}

static int
eread(char *name, int fd, void *buf, long len)
{
    int rd;
    Off off;

    off = seek(fd, 0, 1);       /* for coping with errors */
    rd = read(fd, buf, len);
    if (rd < 0)
        rd = cope(name, fd, buf, len, off);
    return rd;
}

static int
ereadn(char *name, int fd, void *buf, long len)
{
    int rd;
    Off off;

    off = seek(fd, 0, 1);
    rd = readn(fd, buf, len);
    if (rd < 0)
        rd = cope(name, fd, buf, len, off);
    return rd;
}

static int
ewrite(char *name, int fd, void *buf, long len)
{
    int rd;

    werrstr("");
    rd = write(fd, buf, len);
    if (rd != len)
        sysfatal("error writing %s: %r", name);
    return rd;
}

/* compression */

<<function [[compmethod]](tar.c)>>

/*
 * push a filter, cmd, onto fd.  if input, it's an input descriptor.
 * returns a descriptor to replace fd, or -1 on error.
 */
static int
push(int fd, char *cmd, int input, Pushstate *ps)
{
    int nfd, pifds[2];
    String *s;

    ps->open = 0;
    ps->fd = fd;
    ps->input = input;
    if (fd < 0 || pipe(pifds) < 0)
        return -1;
    ps->kid = fork();
    switch (ps->kid) {
    case -1:
        return -1;
    case 0:
        if (input)
            dup(pifds[Wr], STDOUT);
        else
            dup(pifds[Rd], STDIN);
        close(pifds[input? Rd: Wr]);
        dup(fd, (input? STDIN: STDOUT));
        s = s_new();
        if (cmd[0] != '/')
            s_append(s, "/bin/");
        s_append(s, cmd);
        execl(s_to_c(s), cmd, nil);
        sysfatal("can't exec %s: %r", cmd);
    default:
        nfd = pifds[input? Rd: Wr];
        close(pifds[input? Wr: Rd]);
        break;
    }
    ps->rfd = nfd;
    ps->open = 1;
    return nfd;
}

static char *
pushclose(Pushstate *ps)
{
    Waitmsg *wm;

    if (ps->fd < 0 || ps->rfd < 0 || !ps->open)
        return "not open";
    close(ps->rfd);
    ps->rfd = -1;
    ps->open = 0;
    while ((wm = wait()) != nil && wm->pid != ps->kid)
        continue;
    return wm? wm->msg: nil;
}

/*
 * block-buffer management
 */

<<function [[initblks]](tar.c)>>

/*
 * (re)fill block buffers from archive.  `justhdr' means we don't care
 * about the data before the next header block.
 */
static char *
refill(int ar, char *bufs, int justhdr)
{
    int i, n;
    unsigned bytes = Tblock * nblock;
    static int done, first = 1, seekable;

    if (done)
        return nil;

    blkoff = seek(ar, 0, 1);        /* note position for `tar r' */
    if (first)
        seekable = blkoff >= 0;
    /* try to size non-pipe input at first read */
    if (first && usefile && !fixednblock) {
        n = eread(arname, ar, bufs, bytes);
        if (n == 0)
            sysfatal("EOF reading archive %s: %r", arname);
        i = n;
        if (i % Tblock != 0)
            sysfatal("%s: archive block size (%d) error", arname, i);
        i /= Tblock;
        if (i != nblock) {
            nblock = i;
            fprint(2, "%s: blocking = %d\n", argv0, nblock);
            endblk = (Hdr *)bufs + nblock;
            bytes = n;
        }
    } else if (justhdr && seekable && nexthdr - blkoff >= bytes) {
        /* optimisation for huge archive members on seekable media */
        if (seek(ar, bytes, 1) < 0)
            sysfatal("can't seek on archive %s: %r", arname);
        n = bytes;
    } else
        n = ereadn(arname, ar, bufs, bytes);
    first = 0;

    if (n == 0)
        sysfatal("unexpected EOF reading archive %s", arname);
    if (n % Tblock != 0)
        sysfatal("partial block read from archive %s", arname);
    if (n != bytes) {
        done = 1;
        memset(bufs + n, 0, bytes - n);
    }
    return bufs;
}

static Hdr *
getblk(int ar, Refill rfp, int justhdr)
{
    if (curblk == nil || curblk >= endblk) {  /* input block exhausted? */
        if (rfp != nil && (*rfp)(ar, (char *)tpblk, justhdr) == nil)
            return nil;
        curblk = tpblk;
    }
    return curblk++;
}

static Hdr *
getblkrd(int ar, int justhdr)
{
    return getblk(ar, refill, justhdr);
}

static Hdr *
getblke(int ar)
{
    return getblk(ar, nil, Alldata);
}

static Hdr *
getblkz(int ar)
{
    Hdr *hp = getblke(ar);

    if (hp != nil)
        memset(hp->data, 0, Tblock);
    return hp;
}

/*
 * how many block buffers are available, starting at the address
 * just returned by getblk*?
 */
static int
gothowmany(int max)
{
    int n = endblk - (curblk - 1);

    return n > max? max: n;
}

/*
 * indicate that one is done with the last block obtained from getblke
 * and it is now available to be written into the archive.
 */
static void
putlastblk(int ar)
{
    unsigned bytes = Tblock * nblock;

    /* if writing end-of-archive, aid compression (good hygiene too) */
    if (curblk < endblk)
        memset(curblk, 0, (char *)endblk - (char *)curblk);
    ewrite(arname, ar, tpblk, bytes);
}

static void
putblk(int ar)
{
    if (curblk >= endblk)
        putlastblk(ar);
}

static void
putbackblk(int ar)
{
    curblk--;
    USED(ar);
}

static void
putreadblks(int ar, int blks)
{
    curblk += blks - 1;
    USED(ar);
}

static void
putblkmany(int ar, int blks)
{
    assert(blks > 0);
    curblk += blks - 1;
    putblk(ar);
}

/*
 * common routines
 */

/*
 * modifies hp->chksum but restores it; important for the last block of the
 * old archive when updating with `tar rf archive'
 */
static long
chksum(Hdr *hp)
{
    int n = Tblock;
    long i = 0;
    uchar *cp = hp->data;
    char oldsum[sizeof hp->chksum];

    memmove(oldsum, hp->chksum, sizeof oldsum);
    memset(hp->chksum, ' ', sizeof hp->chksum);
    while (n-- > 0)
        i += *cp++;
    memmove(hp->chksum, oldsum, sizeof oldsum);
    return i;
}

<<function [[isustar]](tar.c)>>

/*
 * s is at most n bytes long, but need not be NUL-terminated.
 * if shorter than n bytes, all bytes after the first NUL must also
 * be NUL.
 */
static int
strnlen_(char *s, int n)
{
    return s[n - 1] != '\0'? n: strlen(s);
}

/* set fullname from header */
static char *
name(Hdr *hp)
{
    int pfxlen, namlen;
    char *fullname;
    static char fullnamebuf[2+Maxname+1];  /* 2+ for ./ on relative names */

    fullname = fullnamebuf+2;
    namlen = strnlen_(hp->name, sizeof hp->name);
    if (hp->prefix[0] == '\0' || !isustar(hp)) {    /* old-style name? */
        memmove(fullname, hp->name, namlen);
        fullname[namlen] = '\0';
        return fullname;
    }

    /* name is in two pieces */
    pfxlen = strnlen_(hp->prefix, sizeof hp->prefix);
    memmove(fullname, hp->prefix, pfxlen);
    fullname[pfxlen] = '/';
    memmove(fullname + pfxlen + 1, hp->name, namlen);
    fullname[pfxlen + 1 + namlen] = '\0';
    return fullname;
}

static int
isdir(Hdr *hp)
{
    /* the mode test is ugly but sometimes necessary */
    return hp->linkflag == LF_DIR ||
        strrchr(name(hp), '\0')[-1] == '/' ||
        (strtoul(hp->mode, nil, 8)&0170000) == 040000;
}

static int
eotar(Hdr *hp)
{
    return name(hp)[0] == '\0';
}

/*
static uvlong
getbe(uchar *src, int size)
{
    uvlong vl = 0;

    while (size-- > 0) {
        vl <<= 8;
        vl |= *src++;
    }
    return vl;
}
 */

static void
putbe(uchar *dest, uvlong vl, int size)
{
    for (dest += size; size-- > 0; vl >>= 8)
        *--dest = vl;
}

/*
 * cautious parsing of octal numbers as ascii strings in
 * a tar header block.  this is particularly important for
 * trusting the checksum when trying to resync.
 */
static uvlong
hdrotoull(char *st, char *end, uvlong errval, char *name, char *field)
{
    char *numb;

    for (numb = st; (*numb == ' ' || *numb == '\0') && numb < end; numb++)
        ;
    if (numb < end && isascii(*numb) && isdigit(*numb))
        return strtoull(numb, nil, 8);
    else if (numb >= end)
        fprint(2, "%s: %s: empty %s in header\n", argv0, name, field);
    else
        fprint(2, "%s: %s: %s: non-numeric %s in header\n",
            argv0, name, numb, field);
    return errval;
}

/*
 * return the nominal size from the header block, which is not always the
 * size in the archive (the archive size may be zero for some file types
 * regardless of the nominal size).
 *
 * gnu and freebsd tars are now recording vlongs as big-endian binary
 * with a flag in byte 0 to indicate this, which permits file sizes up to
 * 2^64-1 (actually 2^80-1 but our file sizes are vlongs) rather than 2^33-1.
 */
static Off
hdrsize(Hdr *hp)
{
    uchar *p;

    if((uchar)hp->size[0] == Binnegsz) {
        fprint(2, "%s: %s: negative length, which is insane\n",
            argv0, name(hp));
        return 0;
    } else if((uchar)hp->size[0] == Binsize) {
        p = (uchar *)hp->size + sizeof hp->size - 1 -
            sizeof(vlong);      /* -1 for terminating space */
        return G8BEBYTE(p);
    }

    return hdrotoull(hp->size, hp->size + sizeof hp->size, 0,
        name(hp), "size");
}

/*
 * return the number of bytes recorded in the archive.
 */
static Off
arsize(Hdr *hp)
{
    if(isdir(hp) || islink(hp->linkflag))
        return 0;
    return hdrsize(hp);
}

static long
parsecksum(char *cksum, char *name)
{
    Hdr *hp;

    return hdrotoull(cksum, cksum + sizeof hp->chksum, (uvlong)-1LL,
        name, "checksum");
}

<<function [[readhdr]](tar.c)>>

/*
 * tar r[c]
 */

/*
 * if name is longer than Namsiz bytes, try to split it at a slash and fit the
 * pieces into hp->prefix and hp->name.
 */
static int
putfullname(Hdr *hp, char *name)
{
    int namlen, pfxlen;
    char *sl, *osl;
    String *slname = nil;

    if (isdir(hp)) {
        slname = s_new();
        s_append(slname, name);
        s_append(slname, "/");      /* posix requires this */
        name = s_to_c(slname);
    }

    namlen = strlen(name);
    if (namlen <= Namsiz) {
        strncpy(hp->name, name, Namsiz);
        hp->prefix[0] = '\0';       /* ustar paranoia */
        return 0;
    }

    if (!posix || namlen > Maxname) {
        fprint(2, "%s: name too long for tar header: %s\n",
            argv0, name);
        return -1;
    }
    /*
     * try various splits until one results in pieces that fit into the
     * appropriate fields of the header.  look for slashes from right
     * to left, in the hopes of putting the largest part of the name into
     * hp->prefix, which is larger than hp->name.
     */
    sl = strrchr(name, '/');
    while (sl != nil) {
        pfxlen = sl - name;
        if (pfxlen <= sizeof hp->prefix && namlen-1 - pfxlen <= Namsiz)
            break;
        osl = sl;
        *osl = '\0';
        sl = strrchr(name, '/');
        *osl = '/';
    }
    if (sl == nil) {
        fprint(2, "%s: name can't be split to fit tar header: %s\n",
            argv0, name);
        return -1;
    }
    *sl = '\0';
    strncpy(hp->prefix, name, sizeof hp->prefix);
    *sl++ = '/';
    strncpy(hp->name, sl, sizeof hp->name);
    if (slname)
        s_free(slname);
    return 0;
}

<<function [[mkhdr]](tar.c)>>

static void addtoar(int ar, char *file, char *shortf);

static void
addtreetoar(int ar, char *file, char *shortf, int fd)
{
    int n;
    Dir *dent, *dirents;
    String *name = s_new();

    n = dirreadall(fd, &dirents);
    if (n < 0)
        fprint(2, "%s: dirreadall %s: %r\n", argv0, file);
    close(fd);
    if (n <= 0)
        return;

    if (chdir(shortf) < 0)
        sysfatal("chdir %s: %r", file);
    if (Debug)
        fprint(2, "chdir %s\t# %s\n", shortf, file);

    for (dent = dirents; dent < dirents + n; dent++) {
        s_reset(name);
        s_append(name, file);
        s_append(name, "/");
        s_append(name, dent->name);
        addtoar(ar, s_to_c(name), dent->name);
    }
    s_free(name);
    free(dirents);

    /*
     * this assumes that shortf is just one component, which is true
     * during directory descent, but not necessarily true of command-line
     * arguments.  Our caller (or addtoar's) must reset the working
     * directory if necessary.
     */
    if (chdir("..") < 0)
        sysfatal("chdir %s/..: %r", file);
    if (Debug)
        fprint(2, "chdir ..\n");
}

static void
addtoar(int ar, char *file, char *shortf)
{
    int n, fd, isdir;
    long bytes, blksread;
    ulong blksleft;
    Hdr *hbp;
    Dir *dir;
    String *name = nil;

    if (shortf[0] == '#') {
        name = s_new();
        s_append(name, "./");
        s_append(name, shortf);
        shortf = s_to_c(name);
    }

    if (Debug)
        fprint(2, "opening %s   # %s\n", shortf, file);
    fd = open(shortf, OREAD);
    if (fd < 0) {
        fprint(2, "%s: can't open %s: %r\n", argv0, file);
        if (name)
            s_free(name);
        return;
    }
    dir = dirfstat(fd);
    if (dir == nil)
        sysfatal("can't fstat %s: %r", file);

    hbp = getblkz(ar);
    isdir = (dir->qid.type & QTDIR) != 0;
    if (mkhdr(hbp, dir, file) < 0) {
        putbackblk(ar);
        free(dir);
        close(fd);
        if (name)
            s_free(name);
        return;
    }
    putblk(ar);

    blksleft = BYTES2TBLKS(dir->length);
    free(dir);

    if (isdir)
        addtreetoar(ar, file, shortf, fd);
    else {
        for (; blksleft > 0; blksleft -= blksread) {
            hbp = getblke(ar);
            blksread = gothowmany(blksleft);
            assert(blksread >= 0);
            bytes = blksread * Tblock;
            n = ereadn(file, fd, hbp->data, bytes);
            assert(n >= 0);
            /*
             * ignore EOF.  zero any partial block to aid
             * compression and emergency recovery of data.
             */
            if (n < Tblock)
                memset(hbp->data + n, 0, bytes - n);
            putblkmany(ar, blksread);
        }
        close(fd);
        if (verbose)
            fprint(2, "%s\n", file);
    }
    if (name)
        s_free(name);
}

static void
skip(int ar, Hdr *hp, char *msg)
{
    ulong blksleft, blksread;
    Off bytes;

    bytes = arsize(hp);
    for (blksleft = BYTES2TBLKS(bytes); blksleft > 0; blksleft -= blksread) {
        if (getblkrd(ar, Justnxthdr) == nil)
            sysfatal("unexpected EOF on archive %s %s", arname, msg);
        blksread = gothowmany(blksleft);
        putreadblks(ar, blksread);
    }
}

static void
skiptoend(int ar)
{ 
    Hdr *hp;

    while ((hp = readhdr(ar)) != nil)
        skip(ar, hp, "skipping to end");

    /*
     * we have just read the end-of-archive Tblock.
     * now seek back over the (big) archive block containing it,
     * and back up curblk ptr over end-of-archive Tblock in memory.
     */
    if (seek(ar, blkoff, 0) < 0)
        sysfatal("can't seek back over end-of-archive in %s: %r", arname);
    curblk--;
}

<<function [[replace]](tar.c)>>

/*
 * tar [xt]
 */

/* is pfx a file-name prefix of name? */
static int
prefix(char *name, char *pfx)
{
    int pfxlen = strlen(pfx);
    char clpfx[Maxname+1];

    if (pfxlen > Maxname)
        return 0;
    strcpy(clpfx, pfx);
    cleanname(clpfx);
    return strncmp(clpfx, name, pfxlen) == 0 &&
        (name[pfxlen] == '\0' || name[pfxlen] == '/');
}

static int
match(char *name, char **argv)
{
    int i;
    char clname[Maxname+1];

    if (argv[0] == nil)
        return 1;
    strcpy(clname, name);
    cleanname(clname);
    for (i = 0; argv[i] != nil; i++)
        if (prefix(clname, argv[i]))
            return 1;
    return 0;
}

static void
cantcreate(char *s, int mode)
{
    int len;
    static char *last;

    /*
     * Always print about files.  Only print about directories
     * we haven't printed about.  (Assumes archive is ordered
     * nicely.)
     */
    if(mode&DMDIR){
        if(last){
            /* already printed this directory */
            if(strcmp(s, last) == 0)
                return;
            /* printed a higher directory, so printed this one */
            len = strlen(s);
            if(memcmp(s, last, len) == 0 && last[len] == '/')
                return;
        }
        /* save */
        free(last);
        last = strdup(s);
    }
    fprint(2, "%s: can't create %s: %r\n", argv0, s);
}

static int
makedir(char *s)
{
    int f;

    if (access(s, AEXIST) == 0)
        return -1;
    f = create(s, OREAD, DMDIR | 0777);
    if (f >= 0)
        close(f);
    else
        cantcreate(s, DMDIR);
    return f;
}

static int
mkpdirs(char *s)
{
    int err;
    char *p;

    p = s;
    err = 0;
    while (!err && (p = strchr(p+1, '/')) != nil) {
        *p = '\0';
        err = (access(s, AEXIST) < 0 && makedir(s) < 0);
        *p = '/';
    }
    return -err;
}

/* Call access but preserve the error string. */
static int
xaccess(char *name, int mode)
{
    char err[ERRMAX];
    int rv;

    err[0] = 0;
    errstr(err, sizeof err);
    rv = access(name, mode);
    errstr(err, sizeof err);
    return rv;
}

static int
openfname(Hdr *hp, char *fname, int dir, int mode)
{
    int fd;

    fd = -1;
    cleanname(fname);
    switch (hp->linkflag) {
    case LF_LINK:
    case LF_SYMLINK1:
    case LF_SYMLINK2:
        fprint(2, "%s: can't make (sym)link %s\n",
            argv0, fname);
        break;
    case LF_FIFO:
        fprint(2, "%s: can't make fifo %s\n", argv0, fname);
        break;
    default:
        if (!keepexisting || access(fname, AEXIST) < 0) {
            int rw = (dir? OREAD: OWRITE);

            fd = create(fname, rw, mode);
            if (fd < 0) {
                mkpdirs(fname);
                fd = create(fname, rw, mode);
            }
            if (fd < 0 && (!dir || xaccess(fname, AEXIST) < 0))
                    cantcreate(fname, mode);
        }
        if (fd >= 0 && verbose)
            fprint(2, "%s\n", fname);
        break;
    }
    return fd;
}

/* copy from archive to file system (or nowhere for table-of-contents) */
static void
copyfromar(int ar, int fd, char *fname, ulong blksleft, Off bytes)
{
    int wrbytes;
    ulong blksread;
    Hdr *hbp;

    if (blksleft == 0 || bytes < 0)
        bytes = 0;
    for (; blksleft > 0; blksleft -= blksread) {
        hbp = getblkrd(ar, (fd >= 0? Alldata: Justnxthdr));
        if (hbp == nil)
            sysfatal("unexpected EOF on archive extracting %s from %s",
                fname, arname);
        blksread = gothowmany(blksleft);
        if (blksread <= 0) {
            fprint(2, "%s: got %ld blocks reading %s!\n",
                argv0, blksread, fname);
            blksread = 0;
        }
        wrbytes = Tblock*blksread;
        assert(bytes >= 0);
        if(wrbytes > bytes)
            wrbytes = bytes;
        assert(wrbytes >= 0);
        if (fd >= 0)
            ewrite(fname, fd, hbp->data, wrbytes);
        putreadblks(ar, blksread);
        bytes -= wrbytes;
        assert(bytes >= 0);
    }
    if (bytes > 0)
        fprint(2, "%s: %lld bytes uncopied at EOF on archive %s; "
            "%s not fully extracted\n", argv0, bytes, arname, fname);
}

static void
wrmeta(int fd, Hdr *hp, long mtime, int mode)       /* update metadata */
{
    Dir nd;

    nulldir(&nd);
    nd.mtime = mtime;
    nd.mode = mode;
    dirfwstat(fd, &nd);
    if (isustar(hp)) {
        nulldir(&nd);
        nd.gid = hp->gname;
        dirfwstat(fd, &nd);
        nulldir(&nd);
        nd.uid = hp->uname;
        dirfwstat(fd, &nd);
    }
}

/*
 * copy a file from the archive into the filesystem.
 * fname is result of name(), so has two extra bytes at beginning.
 */
static void
extract1(int ar, Hdr *hp, char *fname)
{
    int fd = -1, dir = 0;
    long mtime = strtol(hp->mtime, nil, 8);
    ulong mode = strtoul(hp->mode, nil, 8) & 0777;
    Off bytes = hdrsize(hp);        /* for printing */
    ulong blksleft = BYTES2TBLKS(arsize(hp));

    /* fiddle name, figure out mode and blocks */
    if (isdir(hp)) {
        mode |= DMDIR|0700;
        dir = 1;
    }
    switch (hp->linkflag) {
    case LF_LINK:
    case LF_SYMLINK1:
    case LF_SYMLINK2:
    case LF_FIFO:
        blksleft = 0;
        break;
    }
    if (relative)
        if(fname[0] == '/')
            *--fname = '.';
        else if(fname[0] == '#'){
            *--fname = '/';
            *--fname = '.';
        }

    if (verb == Xtract)
        fd = openfname(hp, fname, dir, mode);
    else if (verbose) {
        char *cp = ctime(mtime);

        print("%M %8lld %-12.12s %-4.4s %s\n",
            mode, bytes, cp+4, cp+24, fname);
    } else
        print("%s\n", fname);

    copyfromar(ar, fd, fname, blksleft, bytes);

    /* touch up meta data and close */
    if (fd >= 0) {
        /*
         * directories should be wstated *after* we're done
         * creating files in them, but we don't do that.
         */
        if (settime)
            wrmeta(fd, hp, mtime, mode);
        close(fd);
    }
}

<<function [[extract]](tar.c)>>

<<function [[main]](tar.c)>>
@

\subsection{[[archive/gzip/gzip.h]]}

<<archive/gzip/gzip.h>>=
/*
 * gzip header fields
 */
enum
{
    <<gzip constants>>
    <<gzip flags>>
    GZXFAST     = 2,            /* used fast algorithm, little compression */
    GZXBEST     = 4,            /* used maximum compression algorithm */
    <<gzip fs type>>
};
@

\subsection{[[archive/gzip/gunzip.c]]}

<<archive/gzip/gunzip.c>>=
<<plan9 includes>>
#include <bio.h>
#include <flate.h>
#include "gzip.h"

typedef struct  GZHead  GZHead;
<<struct [[GZHead]]>>

// forward decls
static  int crcwrite(void *bout, void *buf, int n);
static  int     get1(Biobuf *b);
static  ulong   get4(Biobuf *b);
static  int gunzipf(char *file, bool stdout);
static  int gunzip(fdt ofd, char *ofile, Biobuf *bin);
static  void    header(Biobuf *bin, GZHead *h);
static  void    trailer(Biobuf *bin, long wlen);
static  void    error(char*, ...);

#pragma varargck    argpos  error   1

<<globals flags gunzip.c>>
<<globals gunzip.c>>

<<function [[usage]](gunzip.c)>>
<<function [[main]](gunzip.c)>>

<<function [[gunzipf]]>>
<<function [[gunzip]]>>

<<function [[header]](gunzip.c)>>
<<function [[trailer]](gunzip.c)>>

<<function [[get4]](gunzip.c)>>
<<function [[get1]](gunzip.c)>>
<<function [[crcwrite]](gunzip.c)>>

<<function [[error]](gunzip.c)>>
@

\subsection{[[archive/gzip.c]]}

<<archive/gzip/gzip.c>>=
<<plan9 includes>>
#include <bio.h>
#include <flate.h>
#include "gzip.h"

// forward decls
static  error0 gzipf(char*, bool);
static  int gzip(char*, long, int, Biobuf*);
static  int crcread(void *fd, void *buf, int n);
static  int gzwrite(void *bout, void *buf, int n);

<<global flags gzip.c>>
<<globals gzip.c>>

<<function [[usage]](gzip.c)>>
<<function [[main]](gzip.c)>>

<<function [[gzipf]]>>
<<function [[gzip]]>>

<<function [[crcread]](gzip.c)>>
<<function [[gzwrite]](gzip.c)>>
@

\subsection{[[archive/zip/zip.h]]}

<<zip/zip.h>>=
typedef struct ZipHead  ZipHead;

enum
{
    /*
     * magic numbers
     */
    ZHeader     = 0x04034b50,
    ZCHeader    = 0x02014b50,
    ZECHeader   = 0x06054b50,

    /*
     * "general purpose flag" bits
     */
    ZEncrypted  = 1 << 0,
    ZTrailInfo  = 1 << 3,   /* uncsize, csize, and crc are in trailer */
    ZCompPatch  = 1 << 5,   /* compression patched data */

    ZCrcPoly    = 0xedb88320,

    /*
     * compression method
     */
    ZDeflate    = 8,

    /*
     * internal file attributes
     */
    ZIsText     = 1 << 0,

    /*
     * file attribute interpretation, from high byte of version
     */
    ZDos        = 0,
    ZAmiga      = 1,
    ZVMS        = 2,
    ZUnix       = 3,
    ZVMCMS      = 4,
    ZAtariST    = 5,
    ZOS2HPFS    = 6,
    ZMac        = 7,
    ZZsys       = 8,
    ZCPM        = 9,
    ZNtfs       = 10,

    /*
     * external attribute flags for ZDos
     */
    ZDROnly     = 0x01,
    ZDHidden    = 0x02,
    ZDSystem    = 0x04,
    ZDVLable    = 0x08,
    ZDDir       = 0x10,
    ZDArch      = 0x20,

    ZHeadSize   = 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 2,
    ZHeadCrc    = 4 + 2 + 2 + 2 + 2 + 2,
    ZTrailSize  = 4 + 4 + 4,
    ZCHeadSize  = 4 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 4 + 4,
    ZECHeadSize = 4 + 2 + 2 + 2 + 2 + 4 + 4 + 2,
};

/*
 * interesting info from a zip header
 */
struct ZipHead
{
    int madeos;         /* version made by */
    int madevers;
    int extos;          /* version needed to extract */
    int extvers;
    int flags;          /* general purpose bit flag */
    int meth;
    int modtime;
    int moddate;
    ulong   crc;
    ulong   csize;
    ulong   uncsize;
    int iattr;
    ulong   eattr;
    ulong   off;
    char    *file;
};
@

\subsection{[[archive/zip/zip.c]]}

<<zip/zip.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <flate.h>
#include "zip.h"

enum
{
    HeadAlloc   = 64,
};

static  void    zip(Biobuf *bout, char *file, int stdout);
static  void    zipDir(Biobuf *bout, int fd, ZipHead *zh, int stdout);
static  int crcread(void *fd, void *buf, int n);
static  int zwrite(void *bout, void *buf, int n);
static  void    put4(Biobuf *b, ulong v);
static  void    put2(Biobuf *b, int v);
static  void    put1(Biobuf *b, int v);
static  void    header(Biobuf *bout, ZipHead *zh);
static  void    trailer(Biobuf *bout, ZipHead *zh, vlong off);
static  void    putCDir(Biobuf *bout);

static  void    error(char*, ...);
#pragma varargck    argpos  error   1

static  Biobuf  bout;
static  ulong   crc;
static  ulong   *crctab;
static  int debug;
static  int eof;
static  int level;
static  int nzheads;
static  ulong   totr;
static  ulong   totw;
static  int verbose;
static  int zhalloc;
static  ZipHead *zheads;
static  jmp_buf zjmp;

void
usage(void)
{
    fprint(2, "usage: zip [-vD] [-1-9] [-f zipfile] file ...\n");
    exits("usage");
}

void
main(int argc, char *argv[])
{
    char *zfile;
    int i, fd, err;

    zfile = nil;
    level = 6;
    ARGBEGIN{
    case 'D':
        debug++;
        break;
    case 'f':
        zfile = ARGF();
        if(zfile == nil)
            usage();
        break;
    case 'v':
        verbose++;
        break;
    case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
        level = ARGC() - '0';
        break;
    default:
        usage();
        break;
    }ARGEND

    if(argc == 0)
        usage();

    crctab = mkcrctab(ZCrcPoly);
    err = deflateinit();
    if(err != FlateOk)
        sysfatal("deflateinit failed: %s", flateerr(err));

    if(zfile == nil)
        fd = 1;
    else{
        fd = create(zfile, OWRITE, 0664);
        if(fd < 0)
            sysfatal("can't create %s: %r", zfile);
    }
    Binit(&bout, fd, OWRITE);

    if(setjmp(zjmp)){
        if(zfile != nil){
            fprint(2, "zip: removing output file %s\n", zfile);
            remove(zfile);
        }
        exits("errors");
    }

    for(i = 0; i < argc; i++)
        zip(&bout, argv[i], zfile == nil);

    putCDir(&bout);

    exits(nil);
}

static void
zip(Biobuf *bout, char *file, int stdout)
{
    Tm *t;
    ZipHead *zh;
    Dir *dir;
    vlong off;
    int fd, err;

    fd = open(file, OREAD);
    if(fd < 0)
        error("can't open %s: %r", file);
    dir = dirfstat(fd);
    if(dir == nil)
        error("can't stat %s: %r", file);

    /*
     * create the header
     */
    if(nzheads >= zhalloc){
        zhalloc += HeadAlloc;
        zheads = realloc(zheads, zhalloc * sizeof(ZipHead));
        if(zheads == nil)
            error("out of memory");
    }
    zh = &zheads[nzheads++];
    zh->madeos = ZDos;
    zh->madevers = (2 * 10) + 0;
    zh->extos = ZDos;
    zh->extvers = (2 * 10) + 0;
    
    t = localtime(dir->mtime);
    zh->modtime = (t->hour<<11) | (t->min<<5) | (t->sec>>1);
    zh->moddate = ((t->year-80)<<9) | ((t->mon+1)<<5) | t->mday;

    zh->flags = 0;
    zh->crc = 0;
    zh->csize = 0;
    zh->uncsize = 0;
    zh->file = strdup(file);
    if(zh->file == nil)
        error("out of memory");
    zh->iattr = 0;
    zh->eattr = ZDArch;
    if((dir->mode & 0700) == 0)
        zh->eattr |= ZDROnly;
    zh->off = Boffset(bout);

    if(dir->mode & DMDIR){
        zh->eattr |= ZDDir;
        zh->meth = 0;
        zipDir(bout, fd, zh, stdout);
    }else{
        zh->meth = 8;
        if(stdout)
            zh->flags |= ZTrailInfo;
        off = Boffset(bout);
        header(bout, zh);

        crc = 0;
        eof = 0;
        totr = 0;
        totw = 0;
        err = deflate(bout, zwrite, (void*)fd, crcread, level, debug);
        if(err != FlateOk)
            error("deflate failed: %s: %r", flateerr(err));

        zh->csize = totw;
        zh->uncsize = totr;
        zh->crc = crc;
        trailer(bout, zh, off);
    }
    close(fd);
    free(dir);
}

static void
zipDir(Biobuf *bout, int fd, ZipHead *zh, int stdout)
{
    Dir *dirs;
    char *file, *pfile;
    int i, nf, nd;

    nf = strlen(zh->file) + 1;
    if(strcmp(zh->file, ".") == 0){
        nzheads--;
        free(zh->file);
        pfile = "";
        nf = 1;
    }else{
        nf++;
        pfile = malloc(nf);
        if(pfile == nil)
            error("out of memory");
        snprint(pfile, nf, "%s/", zh->file);
        free(zh->file);
        zh->file = pfile;
        header(bout, zh);
    }

    nf += 256;  /* plenty of room */
    file = malloc(nf);
    if(file == nil)
        error("out of memory");
    while((nd = dirread(fd, &dirs)) > 0){
        for(i = 0; i < nd; i++){
            snprint(file, nf, "%s%s", pfile, dirs[i].name);
            zip(bout, file, stdout);
        }
        free(dirs);
    }
}

static void
header(Biobuf *bout, ZipHead *zh)
{
    int flen;

    if(verbose)
        fprint(2, "adding %s\n", zh->file);
    put4(bout, ZHeader);
    put1(bout, zh->extvers);
    put1(bout, zh->extos);
    put2(bout, zh->flags);
    put2(bout, zh->meth);
    put2(bout, zh->modtime);
    put2(bout, zh->moddate);
    put4(bout, zh->crc);
    put4(bout, zh->csize);
    put4(bout, zh->uncsize);
    flen = strlen(zh->file);
    put2(bout, flen);
    put2(bout, 0);
    if(Bwrite(bout, zh->file, flen) != flen)
        error("write error");
}

static void
trailer(Biobuf *bout, ZipHead *zh, vlong off)
{
    vlong coff;

    coff = -1;
    if(!(zh->flags & ZTrailInfo)){
        coff = Boffset(bout);
        if(Bseek(bout, off + ZHeadCrc, 0) < 0)
            error("can't seek in archive");
    }
    put4(bout, zh->crc);
    put4(bout, zh->csize);
    put4(bout, zh->uncsize);
    if(!(zh->flags & ZTrailInfo)){
        if(Bseek(bout, coff, 0) < 0)
            error("can't seek in archive");
    }
}

static void
cheader(Biobuf *bout, ZipHead *zh)
{
    int flen;

    put4(bout, ZCHeader);
    put1(bout, zh->madevers);
    put1(bout, zh->madeos);
    put1(bout, zh->extvers);
    put1(bout, zh->extos);
    put2(bout, zh->flags & ~ZTrailInfo);
    put2(bout, zh->meth);
    put2(bout, zh->modtime);
    put2(bout, zh->moddate);
    put4(bout, zh->crc);
    put4(bout, zh->csize);
    put4(bout, zh->uncsize);
    flen = strlen(zh->file);
    put2(bout, flen);
    put2(bout, 0);
    put2(bout, 0);
    put2(bout, 0);
    put2(bout, zh->iattr);
    put4(bout, zh->eattr);
    put4(bout, zh->off);
    if(Bwrite(bout, zh->file, flen) != flen)
        error("write error");
}

static void
putCDir(Biobuf *bout)
{
    vlong hoff, ecoff;
    int i;

    hoff = Boffset(bout);

    for(i = 0; i < nzheads; i++)
        cheader(bout, &zheads[i]);

    ecoff = Boffset(bout);

    if(nzheads >= (1 << 16))
        error("too many entries in zip file: max %d", (1 << 16) - 1);
    put4(bout, ZECHeader);
    put2(bout, 0);
    put2(bout, 0);
    put2(bout, nzheads);
    put2(bout, nzheads);
    put4(bout, ecoff - hoff);
    put4(bout, hoff);
    put2(bout, 0);
}

static int
crcread(void *fd, void *buf, int n)
{
    int nr, m;

    nr = 0;
    for(; !eof && n > 0; n -= m){
        m = read((int)(uintptr)fd, (char*)buf+nr, n);
        if(m <= 0){
            eof = 1;
            if(m < 0)
{
fprint(2, "input error %r\n");
                return -1;
}
            break;
        }
        nr += m;
    }
    crc = blockcrc(crctab, crc, buf, nr);
    totr += nr;
    return nr;
}

static int
zwrite(void *bout, void *buf, int n)
{
    if(n != Bwrite(bout, buf, n)){
        eof = 1;
        return -1;
    }
    totw += n;
    return n;
}

static void
put4(Biobuf *b, ulong v)
{
    int i;

    for(i = 0; i < 4; i++){
        if(Bputc(b, v) < 0)
            error("write error");
        v >>= 8;
    }
}

static void
put2(Biobuf *b, int v)
{
    int i;

    for(i = 0; i < 2; i++){
        if(Bputc(b, v) < 0)
            error("write error");
        v >>= 8;
    }
}

static void
put1(Biobuf *b, int v)
{
    if(Bputc(b, v)< 0)
        error("unexpected eof reading file information");
}

static void
error(char *fmt, ...)
{
    va_list arg;

    fprint(2, "zip: ");
    va_start(arg, fmt);
    vfprint(2, fmt, arg);
    va_end(arg);
    fprint(2, "\n");

    longjmp(zjmp, 1);
}
@

\subsection{[[archive/zip/unzip.c]]}

<<zip/unzip.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <flate.h>
#include "zip.h"

enum
{
    BufSize = 4096
};

static  int cheader(Biobuf *bin, ZipHead *zh);
static  int copyout(int ofd, Biobuf *bin, long len);
static  int crcwrite(void *ofd, void *buf, int n);
static  int findCDir(Biobuf *bin, char *file);
static  int get1(Biobuf *b);
static  int get2(Biobuf *b);
static  ulong   get4(Biobuf *b);
static  char    *getname(Biobuf *b, int len);
static  int header(Biobuf *bin, ZipHead *zh);
static  long    msdos2time(int time, int date);
static  int sunzip(Biobuf *bin);
static  int sunztable(Biobuf *bin);
static  void    trailer(Biobuf *bin, ZipHead *zh);
static  int unzip(Biobuf *bin, char *file);
static  int unzipEntry(Biobuf *bin, ZipHead *czh);
static  int unztable(Biobuf *bin, char *file);
static  int wantFile(char *file);

static  void    *emalloc(ulong);
static  void    error(char*, ...);
#pragma varargck    argpos  error   1

static  Biobuf  bin;
static  ulong   crc;
static  ulong   *crctab;
static  int debug;
static  char    *delfile;
static  int lower;
static  int nwant;
static  ulong   rlen;
static  int settimes;
static  int stdout;
static  int verbose;
static  char    **want;
static  int wbad;
static  ulong   wlen;
static  jmp_buf zjmp;
static  jmp_buf seekjmp;
static  int autodir;

static void
usage(void)
{
    fprint(2, "usage: unzip [-tsv] [-f zipfile] [file ...]\n");
    exits("usage");
}

void
main(int argc, char *argv[])
{
    char *zfile;
    int fd, ok, table, stream;

    table = 0;
    stream = 0;
    zfile = nil;
    ARGBEGIN{
    case 'a':
        autodir++;
        break;
    case 'D':
        debug++;
        break;
    case 'c':
        stdout++;
        break;
    case 'i':
        lower++;
        break;
    case 'f':
        zfile = ARGF();
        if(zfile == nil)
            usage();
        break;
    case 's':
        stream++;
        break;
    case 't':
        table++;
        break;
    case 'T':
        settimes++;
        break;
    case 'v':
        verbose++;
        break;
    default:
        usage();
        break;
    }ARGEND

    nwant = argc;
    want = argv;

    crctab = mkcrctab(ZCrcPoly);
    ok = inflateinit();
    if(ok != FlateOk)
        sysfatal("inflateinit failed: %s", flateerr(ok));

    if(zfile == nil){
        Binit(&bin, 0, OREAD);
        zfile = "<stdin>";
    }else{
        fd = open(zfile, OREAD);
        if(fd < 0)
            sysfatal("can't open %s: %r", zfile);
        Binit(&bin, fd, OREAD);
    }

    if(setjmp(seekjmp)){
        fprint(2, "trying to re-run assuming -s\n");
        stream = 1;
        Bseek(&bin, 0, 0);
    }

    if(table){
        if(stream)
            ok = sunztable(&bin);
        else
            ok = unztable(&bin, zfile);
    }else{
        if(stream)
            ok = sunzip(&bin);
        else
            ok = unzip(&bin, zfile);
    }

    exits(ok ? nil: "errors");
}

/*
 * print the table of contents from the "central directory structure"
 */
static int
unztable(Biobuf *bin, char *file)
{
    ZipHead zh;
    int entries;

    entries = findCDir(bin, file);
    if(entries < 0)
        return 0;

    if(verbose > 1)
        print("%d items in the archive\n", entries);
    while(entries-- > 0){
        if(setjmp(zjmp)){
            free(zh.file);
            return 0;
        }

        memset(&zh, 0, sizeof(zh));
        if(!cheader(bin, &zh))
            return 1;

        if(wantFile(zh.file)){
            if(verbose)
                print("%-32s %10lud %s", zh.file, zh.uncsize, ctime(msdos2time(zh.modtime, zh.moddate)));
            else
                print("%s\n", zh.file);

            if(verbose > 1){
                print("\tmade by os %d vers %d.%d\n", zh.madeos, zh.madevers/10, zh.madevers % 10);
                print("\textract by os %d vers %d.%d\n", zh.extos, zh.extvers/10, zh.extvers % 10);
                print("\tflags %x\n", zh.flags);
                print("\tmethod %d\n", zh.meth);
                print("\tmod time %d\n", zh.modtime);
                print("\tmod date %d\n", zh.moddate);
                print("\tcrc %lux\n", zh.crc);
                print("\tcompressed size %lud\n", zh.csize);
                print("\tuncompressed size %lud\n", zh.uncsize);
                print("\tinternal attributes %ux\n", zh.iattr);
                print("\texternal attributes %lux\n", zh.eattr);
                print("\tstarts at %ld\n", zh.off);
            }
        }

        free(zh.file);
        zh.file = nil;
    }

    return 1;
}

/*
 * print the "local file header" table of contents
 */
static int
sunztable(Biobuf *bin)
{
    ZipHead zh;
    vlong off;
    ulong hcrc, hcsize, huncsize;
    int ok, err;

    ok = 1;
    for(;;){
        if(setjmp(zjmp)){
            free(zh.file);
            return 0;
        }

        memset(&zh, 0, sizeof(zh));
        if(!header(bin, &zh))
            return ok;

        hcrc = zh.crc;
        hcsize = zh.csize;
        huncsize = zh.uncsize;

        wlen = 0;
        rlen = 0;
        crc = 0;
        wbad = 0;

        if(zh.meth == 0){
            if(!copyout(-1, bin, zh.csize))
                error("reading data for %s failed: %r", zh.file);
        }else if(zh.meth == 8){
            off = Boffset(bin);
            err = inflate((void*)-1, crcwrite, bin, (int(*)(void*))Bgetc);
            if(err != FlateOk)
                error("inflate %s failed: %s", zh.file, flateerr(err));
            rlen = Boffset(bin) - off;
        }else
            error("can't handle compression method %d for %s", zh.meth, zh.file);

        trailer(bin, &zh);

        if(wantFile(zh.file)){
            if(verbose)
                print("%-32s %10lud %s", zh.file, zh.uncsize, ctime(msdos2time(zh.modtime, zh.moddate)));
            else
                print("%s\n", zh.file);

            if(verbose > 1){
                print("\textract by os %d vers %d.%d\n", zh.extos, zh.extvers / 10, zh.extvers % 10);
                print("\tflags %x\n", zh.flags);
                print("\tmethod %d\n", zh.meth);
                print("\tmod time %d\n", zh.modtime);
                print("\tmod date %d\n", zh.moddate);
                print("\tcrc %lux\n", zh.crc);
                print("\tcompressed size %lud\n", zh.csize);
                print("\tuncompressed size %lud\n", zh.uncsize);
                if((zh.flags & ZTrailInfo) && (hcrc || hcsize || huncsize)){
                    print("\theader crc %lux\n", zh.crc);
                    print("\theader compressed size %lud\n", zh.csize);
                    print("\theader uncompressed size %lud\n", zh.uncsize);
                }
            }
        }

        if(zh.crc != crc)
            error("crc mismatch for %s", zh.file);
        if(zh.uncsize != wlen)
            error("output size mismatch for %s", zh.file);
        if(zh.csize != rlen)
            error("input size mismatch for %s", zh.file);


        free(zh.file);
        zh.file = nil;
    }
}

/*
 * extract files using the info in the central directory structure
 */
static int
unzip(Biobuf *bin, char *file)
{
    ZipHead zh;
    vlong off;
    int ok, eok, entries;

    entries = findCDir(bin, file);
    if(entries < 0)
        return 0;

    ok = 1;
    while(entries-- > 0){
        if(setjmp(zjmp)){
            free(zh.file);
            return 0;
        }
        memset(&zh, 0, sizeof(zh));
        if(!cheader(bin, &zh))
            return ok;


        off = Boffset(bin);
        if(wantFile(zh.file)){
            if(Bseek(bin, zh.off, 0) < 0){
                fprint(2, "unzip: can't seek to start of %s, skipping\n", zh.file);
                ok = 0;
            }else{
                eok = unzipEntry(bin, &zh);
                if(eok <= 0){
                    fprint(2, "unzip: skipping %s\n", zh.file);
                    ok = 0;
                }
            }
        }

        free(zh.file);
        zh.file = nil;

        if(Bseek(bin, off, 0) < 0){
            fprint(2, "unzip: can't seek to start of next entry, terminating extraction\n");
            return 0;
        }
    }

    return ok;
}

/*
 * extract files using the info the "local file headers"
 */
static int
sunzip(Biobuf *bin)
{
    int eok;

    for(;;){
        eok = unzipEntry(bin, nil);
        if(eok == 0)
            return 1;
        if(eok < 0)
            return 0;
    }
}

static int mkdirs(char *);

/*
 * if any directories leading up to path don't exist, create them.
 * modifies but restores path.
 */
static int
mkpdirs(char *path)
{
    int rv = 0;
    char *sl = strrchr(path, '/');
print("%s\n", path);
    if (sl != nil) {
        *sl = '\0';
        rv = mkdirs(path);
        *sl = '/';
    }
    return rv;
}

/*
 * if path or any directories leading up to it don't exist, create them.
 * modifies but restores path.
 */
static int
mkdirs(char *path)
{
    int fd;

    if (access(path, AEXIST) >= 0)
        return 0;

    /* make presumed-missing intermediate directories */
    if (mkpdirs(path) < 0)
        return -1;

    /* make final directory */
    fd = create(path, OREAD, 0755|DMDIR);
    if (fd < 0)
        /*
         * we may have lost a race; if the directory now exists,
         * it's okay.
         */
        return access(path, AEXIST) < 0? -1: 0;
    close(fd);
    return 0;
}


/*
 * extracts a single entry from a zip file
 * czh is the optional corresponding central directory entry
 */
static int
unzipEntry(Biobuf *bin, ZipHead *czh)
{
    Dir *d;
    ZipHead zh;
    char *p;
    vlong off;
    int fd, isdir, ok, err;

    zh.file = nil;
    if(setjmp(zjmp)){
        delfile = nil;
        free(zh.file);
        return -1;
    }

    memset(&zh, 0, sizeof(zh));
    if(!header(bin, &zh))
        return 0;

    ok = 1;
    isdir = 0;

    fd = -1;
    if(wantFile(zh.file)){
        if(verbose)
            fprint(2, "extracting %s\n", zh.file);

        if(czh != nil && czh->extos == ZDos){
            isdir = czh->eattr & ZDDir;
            if(isdir && zh.uncsize != 0)
                fprint(2, "unzip: ignoring directory data for %s\n", zh.file);
        }
        if(zh.meth == 0 && zh.uncsize == 0){
            p = strchr(zh.file, '\0');
            if(p > zh.file && p[-1] == '/')
                isdir = 1;
        }

        if(stdout){
            if(ok && !isdir)
                fd = 1;
        }else if(isdir){
            fd = create(zh.file, OREAD, DMDIR | 0775);
            if(fd < 0){
                d = dirstat(zh.file);
                if(d == nil || (d->mode & DMDIR) != DMDIR){
                    fprint(2, "unzip: can't create directory %s: %r\n", zh.file);
                    ok = 0;
                }
                free(d);
            }
        }else if(ok){
            if(autodir)
                mkpdirs(zh.file);
            fd = create(zh.file, OWRITE, 0664);
            if(fd < 0){
                fprint(2, "unzip: can't create %s: %r\n", zh.file);
                ok = 0;
            }else
                delfile = zh.file;
        }
    }

    wlen = 0;
    rlen = 0;
    crc = 0;
    wbad = 0;

    if(zh.meth == 0){
        if(!copyout(fd, bin, zh.csize))
            error("copying data for %s failed: %r", zh.file);
    }else if(zh.meth == 8){
        off = Boffset(bin);
        err = inflate((void*)fd, crcwrite, bin, (int(*)(void*))Bgetc);
        if(err != FlateOk)
            error("inflate failed: %s", flateerr(err));
        rlen = Boffset(bin) - off;
    }else
        error("can't handle compression method %d for %s", zh.meth, zh.file);

    trailer(bin, &zh);

    if(zh.crc != crc)
        error("crc mismatch for %s", zh.file);
    if(zh.uncsize != wlen)
        error("output size mismatch for %s", zh.file);
    if(zh.csize != rlen)
        error("input size mismatch for %s", zh.file);

    delfile = nil;
    free(zh.file);

    if(fd >= 0 && !stdout){
        if(settimes){
            d = dirfstat(fd);
            if(d != nil){
                d->mtime = msdos2time(zh.modtime, zh.moddate);
                if(d->mtime)
                    dirfwstat(fd, d);
            }
        }
        close(fd);
    }

    return ok;
}

static int
wantFile(char *file)
{
    int i, n;

    if(nwant == 0)
        return 1;
    for(i = 0; i < nwant; i++){
        if(strcmp(want[i], file) == 0)
            return 1;
        n = strlen(want[i]);
        if(strncmp(want[i], file, n) == 0 && file[n] == '/')
            return 1;
    }
    return 0;
}

/*
 * find the start of the central directory
 * returns the number of entries in the directory,
 * or -1 if there was an error
 */
static int
findCDir(Biobuf *bin, char *file)
{
    vlong ecoff;
    long off, size, m;
    int entries, zclen, dn, ds, de;

    ecoff = Bseek(bin, -ZECHeadSize, 2);
    if(ecoff < 0){
        fprint(2, "unzip: can't seek to contents of %s\n", file);
        longjmp(seekjmp, 1);
        return -1;
    }
    if(setjmp(zjmp))
        return -1;

    if((m=get4(bin)) != ZECHeader){
        fprint(2, "unzip: bad magic number for table of contents of %s: %#.8lx\n", file, m);
        longjmp(seekjmp, 1);
        return -1;
    }
    dn = get2(bin);
    ds = get2(bin);
    de = get2(bin);
    entries = get2(bin);
    size = get4(bin);
    off = get4(bin);
    zclen = get2(bin);
    while(zclen-- > 0)
        get1(bin);

    if(verbose > 1){
        print("table starts at %ld for %ld bytes\n", off, size);
        if(ecoff - size != off)
            print("\ttable should start at %lld-%ld=%lld\n", ecoff, size, ecoff-size);
        if(dn || ds || de != entries)
            print("\tcurrent disk=%d start disk=%d table entries on this disk=%d\n", dn, ds, de);
    }

    if(Bseek(bin, off, 0) != off){
        fprint(2, "unzip: can't seek to start of contents of %s\n", file);
        longjmp(seekjmp, 1);
        return -1;
    }

    return entries;
}

static int
cheader(Biobuf *bin, ZipHead *zh)
{
    ulong v;
    int flen, xlen, fclen;

    v = get4(bin);
    if(v != ZCHeader){
        if(v == ZECHeader)
            return 0;
        error("bad magic number %lux", v);
    }
    zh->madevers = get1(bin);
    zh->madeos = get1(bin);
    zh->extvers = get1(bin);
    zh->extos = get1(bin);
    zh->flags = get2(bin);
    zh->meth = get2(bin);
    zh->modtime = get2(bin);
    zh->moddate = get2(bin);
    zh->crc = get4(bin);
    zh->csize = get4(bin);
    zh->uncsize = get4(bin);
    flen = get2(bin);
    xlen = get2(bin);
    fclen = get2(bin);
    get2(bin);      /* disk number start */
    zh->iattr = get2(bin);
    zh->eattr = get4(bin);
    zh->off = get4(bin);

    zh->file = getname(bin, flen);

    while(xlen-- > 0)
        get1(bin);

    while(fclen-- > 0)
        get1(bin);

    return 1;
}

static int
header(Biobuf *bin, ZipHead *zh)
{
    ulong v;
    int flen, xlen;

    v = get4(bin);
    if(v != ZHeader){
        if(v == ZCHeader)
            return 0;
        error("bad magic number %lux at %lld", v, Boffset(bin)-4);
    }
    zh->extvers = get1(bin);
    zh->extos = get1(bin);
    zh->flags = get2(bin);
    zh->meth = get2(bin);
    zh->modtime = get2(bin);
    zh->moddate = get2(bin);
    zh->crc = get4(bin);
    zh->csize = get4(bin);
    zh->uncsize = get4(bin);
    flen = get2(bin);
    xlen = get2(bin);

    zh->file = getname(bin, flen);

    while(xlen-- > 0)
        get1(bin);

    return 1;
}

static void
trailer(Biobuf *bin, ZipHead *zh)
{
    if(zh->flags & ZTrailInfo){
        zh->crc = get4(bin);
        zh->csize = get4(bin);
        zh->uncsize = get4(bin);
    }
}

static char*
getname(Biobuf *bin, int len)
{
    char *s;
    int i, c;

    s = emalloc(len + 1);
    for(i = 0; i < len; i++){
        c = get1(bin);
        if(lower)
            c = tolower(c);
        s[i] = c;
    }
    s[i] = '\0';
    return s;
}

static int
crcwrite(void *out, void *buf, int n)
{
    int fd, nw;

    wlen += n;
    crc = blockcrc(crctab, crc, buf, n);
    fd = (int)(uintptr)out;
    if(fd < 0)
        return n;
    nw = write(fd, buf, n);
    if(nw != n)
        wbad = 1;
    return nw;
}

static int
copyout(int ofd, Biobuf *bin, long len)
{
    char buf[BufSize];
    int n;

    for(; len > 0; len -= n){
        n = len;
        if(n > BufSize)
            n = BufSize;
        n = Bread(bin, buf, n);
        if(n <= 0)
            return 0;
        rlen += n;
        if(crcwrite((void*)ofd, buf, n) != n)
            return 0;
    }
    return 1;
}

static ulong
get4(Biobuf *b)
{
    ulong v;
    int i, c;

    v = 0;
    for(i = 0; i < 4; i++){
        c = Bgetc(b);
        if(c < 0)
            error("unexpected eof reading file information");
        v |= c << (i * 8);
    }
    return v;
}

static int
get2(Biobuf *b)
{
    int i, c, v;

    v = 0;
    for(i = 0; i < 2; i++){
        c = Bgetc(b);
        if(c < 0)
            error("unexpected eof reading file information");
        v |= c << (i * 8);
    }
    return v;
}

static int
get1(Biobuf *b)
{
    int c;

    c = Bgetc(b);
    if(c < 0)
        error("unexpected eof reading file information");
    return c;
}

static long
msdos2time(int time, int date)
{
    Tm tm;

    tm.hour = time >> 11;
    tm.min = (time >> 5) & 63;
    tm.sec = (time & 31) << 1;
    tm.year = 80 + (date >> 9);
    tm.mon = ((date >> 5) & 15) - 1;
    tm.mday = date & 31;
    tm.zone[0] = '\0';
    tm.yday = 0;

    return tm2sec(&tm);
}

static void*
emalloc(ulong n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        sysfatal("out of memory");
    return p;
}

static void
error(char *fmt, ...)
{
    va_list arg;

    fprint(2, "unzip: ");
    va_start(arg, fmt);
    vfprint(2, fmt, arg);
    va_end(arg);
    fprint(2, "\n");

    if(delfile != nil){
        fprint(2, "unzip: removing output file %s\n", delfile);
        remove(delfile);
        delfile = nil;
    }

    longjmp(zjmp, 1);
}
@


\section{[[calc/]]}

\subsection{[[calc/dc.c]]}

%XXX
<<macros dc.c>>=
#define OUTC(x)     {Bputc(&bout,x); if(--count == 0){Bprint(&bout,"\\\n"); count=ll;} }
#define TEST2       {if((count -= 2) <=0){Bprint(&bout,"\\\n");count=ll;}}
#define EMPTY       if(stkerr != 0){Bprint(&bout,"stack empty\n"); continue; }
#define EMPTYR(x)   if(stkerr != 0){pushp(x);Bprint(&bout,"stack empty\n");continue;}
#define EMPTYS      if(stkerr != 0){Bprint(&bout,"stack empty\n"); return(1);}
#define EMPTYSR(x)  if(stkerr != 0){Bprint(&bout,"stack empty\n");pushp(x);return(1);}
#define error(p)    {Bprint(&bout,p); continue; }
#define errorrt(p)  {Bprint(&bout,p); return(1); }
@

%XXX
<<constants dc.c>>=
#define HEADSZ 1024
#define STKSZ 100
#define RDSKSZ 100
#define ARRAYST 221
#define MAXIND 2048
@

%XXX
<<globals dc.c>>=
Biobuf *fsave;
Blk *arg1, *arg2;
uchar   savk;
int ifile;
Blk *scalptr, *basptr, *tenptr, *inbas;
Blk *sqtemp, *chptr, *strptr, *divxyz;
Blk *stack[STKSZ];
Blk **stkptr,**stkbeg;
Blk **stkend;
Blk *hfree;
int stkerr;
int lastchar;
Blk *readstk[RDSKSZ];
Blk **readptr;
Blk *rem;
int k;
Blk *irem;
int skd,skr;
int neg;
Sym symlst[TBLSZ];
Sym *stable[TBLSZ];
Sym *sptr, *sfree;
long    rel;
long    nbytes;
long    all;
long    headmor;
long    obase;
int fw,fw1,ll;
void    (*outdit)(Blk *p, int flg);
int logo;
int logten;
int count;
char    *pp;
char    *dummy;
long    longest, maxsize, active;
int lall, lrel, lcopy, lmore, lbytes;
int inside;
@

<<calc/dc.c>>=
<<plan9 includes>>
#include <bio.h>

typedef void*   pointer;
#pragma varargck    type    "lx"    pointer

#define FATAL 0
#define NFATAL 1
#define BLK sizeof(Blk)
#define PTRSZ sizeof(int*)
#define TBLSZ 256           /* 1<<BI2BY */

<<constants dc.c>>

#define NL 1
#define NG 2
#define NE 3

<<macros on [[Blk]] dc.c>>
<<macros dc.c>>

#define LASTFUN 026

typedef struct  Blk Blk;
<<struct [[Blk]](dc.c)>>
typedef struct  Sym Sym;
<<struct [[Sym]](dc.c)>>
typedef struct  Wblk    Wblk;
<<struct [[Wblk]](dc.c)>>

<<global flags dc.c>>

<<globals dc.c>>

// forward decls
void    main(int argc, char *argv[]);
void    commnds(void);
Blk*    readin(void);
Blk*    div_(Blk *ddivd, Blk *ddivr);
int     dscale(void);
Blk*    removr(Blk *p, int n);
Blk*    dcsqrt(Blk *p);
void    init(int argc, char *argv[]);
void    onintr(void);
void    pushp(Blk *p);
Blk*    pop(void);
Blk*    readin(void);
Blk*    add0(Blk *p, int ct);
Blk*    mult(Blk *p, Blk *q);
void    chsign(Blk *p);
int     readc(void);
void    unreadc(char c);
void    binop(char c);
void    dcprint(Blk *hptr);
Blk*    dcexp(Blk *base, Blk *ex);
Blk*    getdec(Blk *p, int sc);
void    tenot(Blk *p, int sc);
void    oneot(Blk *p, int sc, char ch);
void    hexot(Blk *p, int flg);
void    bigot(Blk *p, int flg);
Blk*    add(Blk *a1, Blk *a2);
int     eqk(void);
Blk*    removc(Blk *p, int n);
Blk*    scalint(Blk *p);
Blk*    scale(Blk *p, int n);
int     subt(void);
int     command(void);
int     cond(char c);
void    load(void);
int     log2_(long n);
Blk*    salloc(int size);
Blk*    morehd(void);
Blk*    copy(Blk *hptr, int size);
void    sdump(char *s1, Blk *hptr);
void    seekc(Blk *hptr, int n);
void    salterwd(Blk *hptr, Blk *n);
void    more(Blk *hptr);
void    ospace(char *s);
void    garbage(char *s);
void    release(Blk *p);
Blk*    dcgetwd(Blk *p);
void    putwd(Blk *p, Blk *c);
Blk*    lookwd(Blk *p);
int     getstk(void);

/********debug only**/
void
tpr(char *cp, Blk *bp)
{
    print("%s-> ", cp);
    print("beg: %lx rd: %lx wt: %lx last: %lx\n", bp->beg, bp->rd,
        bp->wt, bp->last);
    for (cp = bp->beg; cp != bp->wt; cp++) {
        print("%d", *cp);
        if (cp != bp->wt-1)
            print("/");
    }
    print("\n");
}
/************/

<<function [[main]](dc.c)>>

<<function [[commnds]](dc.c)>>

Blk*
div_(Blk *ddivd, Blk *ddivr)
{
    int divsign, remsign, offset, divcarry,
        carry, dig, magic, d, dd, under, first;
    long c, td, cc;
    Blk *ps, *px, *p, *divd, *divr;

    dig = 0;
    under = 0;
    divcarry = 0;
    rem = 0;
    p = salloc(0);
    if(length(ddivr) == 0) {
        pushp(ddivr);
        Bprint(&bout,"divide by 0\n");
        return(p);
    }
    divsign = remsign = first = 0;
    divr = ddivr;
    fsfile(divr);
    if(sbackc(divr) == -1) {
        divr = copy(ddivr,length(ddivr));
        chsign(divr);
        divsign = ~divsign;
    }
    divd = copy(ddivd,length(ddivd));
    fsfile(divd);
    if(sfbeg(divd) == 0 && sbackc(divd) == -1) {
        chsign(divd);
        divsign = ~divsign;
        remsign = ~remsign;
    }
    offset = length(divd) - length(divr);
    if(offset < 0)
        goto ddone;
    seekc(p,offset+1);
    sputc(divd,0);
    magic = 0;
    fsfile(divr);
    c = sbackc(divr);
    if(c < 10)
        magic++;
    c = c * 100 + (sfbeg(divr)?0:sbackc(divr));
    if(magic>0){
        c = (c * 100 +(sfbeg(divr)?0:sbackc(divr)))*2;
        c /= 25;
    }
    while(offset >= 0) {
        first++;
        fsfile(divd);
        td = sbackc(divd) * 100;
        dd = sfbeg(divd)?0:sbackc(divd);
        td = (td + dd) * 100;
        dd = sfbeg(divd)?0:sbackc(divd);
        td = td + dd;
        cc = c;
        if(offset == 0)
            td++;
        else
            cc++;
        if(magic != 0)
            td = td<<3;
        dig = td/cc;
        under=0;
        if(td%cc < 8  && dig > 0 && magic) {
            dig--;
            under=1;
        }
        rewind(divr);
        rewind(divxyz);
        carry = 0;
        while(sfeof(divr) == 0) {
            d = sgetc(divr)*dig+carry;
            carry = d / 100;
            salterc(divxyz,d%100);
        }
        salterc(divxyz,carry);
        rewind(divxyz);
        seekc(divd,offset);
        carry = 0;
        while(sfeof(divd) == 0) {
            d = slookc(divd);
            d = d-(sfeof(divxyz)?0:sgetc(divxyz))-carry;
            carry = 0;
            if(d < 0) {
                d += 100;
                carry = 1;
            }
            salterc(divd,d);
        }
        divcarry = carry;
        backc(p);
        salterc(p,dig);
        backc(p);
        fsfile(divd);
        d=sbackc(divd);
        if((d != 0) && /*!divcarry*/ (offset != 0)) {
            d = sbackc(divd) + 100;
            salterc(divd,d);
        }
        if(--offset >= 0)
            divd->wt--;
    }
    if(under) { /* undershot last - adjust*/
        px = copy(divr,length(divr));   /*11/88 don't corrupt ddivr*/
        chsign(px);
        ps = add(px,divd);
        fsfile(ps);
        if(length(ps) > 0 && sbackc(ps) < 0) {
            release(ps);    /*only adjust in really undershot*/
        } else {
            release(divd);
            salterc(p, dig+1);
            divd=ps;
        }
    }
    if(divcarry != 0) {
        salterc(p,dig-1);
        salterc(divd,-1);
        ps = add(divr,divd);
        release(divd);
        divd = ps;
    }

    rewind(p);
    divcarry = 0;
    while(sfeof(p) == 0){
        d = slookc(p)+divcarry;
        divcarry = 0;
        if(d >= 100){
            d -= 100;
            divcarry = 1;
        }
        salterc(p,d);
    }
    if(divcarry != 0)salterc(p,divcarry);
    fsfile(p);
    while(sfbeg(p) == 0) {
        if(sbackc(p) != 0)
            break;
        truncate(p);
    }
    if(divsign < 0)
        chsign(p);
    fsfile(divd);
    while(sfbeg(divd) == 0) {
        if(sbackc(divd) != 0)
            break;
        truncate(divd);
    }
ddone:
    if(remsign<0)
        chsign(divd);
    if(divr != ddivr)
        release(divr);
    rem = divd;
    return(p);
}

int
dscale(void)
{
    Blk *dd, *dr, *r;
    int c;

    dr = pop();
    EMPTYS;
    dd = pop();
    EMPTYSR(dr);
    fsfile(dd);
    skd = sunputc(dd);
    fsfile(dr);
    skr = sunputc(dr);
    if(sfbeg(dr) == 1 || (sfbeg(dr) == 0 && sbackc(dr) == 0)) {
        sputc(dr,skr);
        pushp(dr);
        Bprint(&bout,"divide by 0\n");
        return(1);
    }
    if(sfbeg(dd) == 1 || (sfbeg(dd) == 0 && sbackc(dd) == 0)) {
        sputc(dd,skd);
        pushp(dd);
        return(1);
    }
    c = k-skd+skr;
    if(c < 0)
        r = removr(dd,-c);
    else {
        r = add0(dd,c);
        irem = 0;
    }
    arg1 = r;
    arg2 = dr;
    savk = k;
    return(0);
}

Blk*
removr(Blk *p, int n)
{
    int nn, neg;
    Blk *q, *s, *r;

    fsfile(p);
    neg = sbackc(p);
    if(neg < 0)
        chsign(p);
    rewind(p);
    nn = (n+1)/2;
    q = salloc(nn);
    while(n>1) {
        sputc(q,sgetc(p));
        n -= 2;
    }
    r = salloc(2);
    while(sfeof(p) == 0)
        sputc(r,sgetc(p));
    release(p);
    if(n == 1){
        s = div_(r,tenptr);
        release(r);
        rewind(rem);
        if(sfeof(rem) == 0)
            sputc(q,sgetc(rem));
        release(rem);
        if(neg < 0){
            chsign(s);
            chsign(q);
            irem = q;
            return(s);
        }
        irem = q;
        return(s);
    }
    if(neg < 0) {
        chsign(r);
        chsign(q);
        irem = q;
        return(r);
    }
    irem = q;
    return(r);
}

Blk*
dcsqrt(Blk *p)
{
    Blk *t, *r, *q, *s;
    int c, n, nn;

    n = length(p);
    fsfile(p);
    c = sbackc(p);
    if((n&1) != 1)
        c = c*100+(sfbeg(p)?0:sbackc(p));
    n = (n+1)>>1;
    r = salloc(n);
    zero(r);
    seekc(r,n);
    nn=1;
    while((c -= nn)>=0)
        nn+=2;
    c=(nn+1)>>1;
    fsfile(r);
    backc(r);
    if(c>=100) {
        c -= 100;
        salterc(r,c);
        sputc(r,1);
    } else
        salterc(r,c);
    for(;;){
        q = div_(p,r);
        s = add(q,r);
        release(q);
        release(rem);
        q = div_(s,sqtemp);
        release(s);
        release(rem);
        s = copy(r,length(r));
        chsign(s);
        t = add(s,q);
        release(s);
        fsfile(t);
        nn = sfbeg(t)?0:sbackc(t);
        if(nn>=0)
            break;
        release(r);
        release(t);
        r = q;
    }
    release(t);
    release(q);
    release(p);
    return(r);
}

Blk*
dcexp(Blk *base, Blk *ex)
{
    Blk *r, *e, *p, *e1, *t, *cp;
    int temp, c, n;

    r = salloc(1);
    sputc(r,1);
    p = copy(base,length(base));
    e = copy(ex,length(ex));
    fsfile(e);
    if(sfbeg(e) != 0)
        goto edone;
    temp=0;
    c = sbackc(e);
    if(c<0) {
        temp++;
        chsign(e);
    }
    while(length(e) != 0) {
        e1=div_(e,sqtemp);
        release(e);
        e = e1;
        n = length(rem);
        release(rem);
        if(n != 0) {
            e1=mult(p,r);
            release(r);
            r = e1;
        }
        t = copy(p,length(p));
        cp = mult(p,t);
        release(p);
        release(t);
        p = cp;
    }
    if(temp != 0) {
        if((c = length(base)) == 0) {
            goto edone;
        }
        if(c>1)
            create_(r);
        else {
            rewind(base);
            if((c = sgetc(base))<=1) {
                create_(r);
                sputc(r,c);
            } else
                create_(r);
        }
    }
edone:
    release(p);
    release(e);
    return(r);
}

<<function [[init]](dc.c)>>

<<function [[pushp]](dc.c)>>
<<function [[pop]](dc.c)>>

<<function [[readin]](dc.c)>>


/*
 * returns pointer to struct with ct 0's & p
 */
Blk*
add0(Blk *p, int ct)
{
    Blk *q, *t;

    q = salloc(length(p)+(ct+1)/2);
    while(ct>1) {
        sputc(q,0);
        ct -= 2;
    }
    rewind(p);
    while(sfeof(p) == 0) {
        sputc(q,sgetc(p));
    }
    release(p);
    if(ct == 1) {
        t = mult(tenptr,q);
        release(q);
        return(t);
    }
    return(q);
}

Blk*
mult(Blk *p, Blk *q)
{
    Blk *mp, *mq, *mr;
    int sign, offset, carry;
    int cq, cp, mt, mcr;

    offset = sign = 0;
    fsfile(p);
    mp = p;
    if(sfbeg(p) == 0) {
        if(sbackc(p)<0) {
            mp = copy(p,length(p));
            chsign(mp);
            sign = ~sign;
        }
    }
    fsfile(q);
    mq = q;
    if(sfbeg(q) == 0){
        if(sbackc(q)<0) {
            mq = copy(q,length(q));
            chsign(mq);
            sign = ~sign;
        }
    }
    mr = salloc(length(mp)+length(mq));
    zero(mr);
    rewind(mq);
    while(sfeof(mq) == 0) {
        cq = sgetc(mq);
        rewind(mp);
        rewind(mr);
        mr->rd += offset;
        carry=0;
        while(sfeof(mp) == 0) {
            cp = sgetc(mp);
            mcr = sfeof(mr)?0:slookc(mr);
            mt = cp*cq + carry + mcr;
            carry = mt/100;
            salterc(mr,mt%100);
        }
        offset++;
        if(carry != 0) {
            mcr = sfeof(mr)?0:slookc(mr);
            salterc(mr,mcr+carry);
        }
    }
    if(sign < 0) {
        chsign(mr);
    }
    if(mp != p)
        release(mp);
    if(mq != q)
        release(mq);
    return(mr);
}

void
chsign(Blk *p)
{
    int carry;
    char ct;

    carry=0;
    rewind(p);
    while(sfeof(p) == 0) {
        ct=100-slookc(p)-carry;
        carry=1;
        if(ct>=100) {
            ct -= 100;
            carry=0;
        }
        salterc(p,ct);
    }
    if(carry != 0) {
        sputc(p,-1);
        fsfile(p);
        backc(p);
        ct = sbackc(p);
        if(ct == 99 /*&& !sfbeg(p)*/) {
            truncate(p);
            sputc(p,-1);
        }
    } else{
        fsfile(p);
        ct = sbackc(p);
        if(ct == 0)
            truncate(p);
    }
    return;
}

<<function [[readc]](dc.c)>>
<<function [[unreadc]](dc.c)>>

<<function [[binop]](dc.c)>>

<<function [[dcprint]](dc.c)>>

Blk*
getdec(Blk *p, int sc)
{
    int cc;
    Blk *q, *t, *s;

    rewind(p);
    if(length(p)*2 < sc) {
        q = copy(p,length(p));
        return(q);
    }
    q = salloc(length(p));
    while(sc >= 1) {
        sputc(q,sgetc(p));
        sc -= 2;
    }
    if(sc != 0) {
        t = mult(q,tenptr);
        s = salloc(cc = length(q));
        release(q);
        rewind(t);
        while(cc-- > 0)
            sputc(s,sgetc(t));
        sputc(s,0);
        release(t);
        t = div_(s,tenptr);
        release(s);
        release(rem);
        return(t);
    }
    return(q);
}

void
tenot(Blk *p, int sc)
{
    int c, f;

    fsfile(p);
    f=0;
    while((sfbeg(p) == 0) && ((p->rd-p->beg-1)*2 >= sc)) {
        c = sbackc(p);
        if((c<10) && (f == 1))
            Bprint(&bout,"0%d",c);
        else
            Bprint(&bout,"%d",c);
        f=1;
        TEST2;
    }
    if(sc == 0) {
        Bprint(&bout,"\n");
        release(p);
        return;
    }
    if((p->rd-p->beg)*2 > sc) {
        c = sbackc(p);
        Bprint(&bout,"%d.",c/10);
        TEST2;
        OUTC(c%10 +'0');
        sc--;
    } else {
        OUTC('.');
    }
    while(sc>(p->rd-p->beg)*2) {
        OUTC('0');
        sc--;
    }
    while(sc > 1) {
        c = sbackc(p);
        if(c<10)
            Bprint(&bout,"0%d",c);
        else
            Bprint(&bout,"%d",c);
        sc -= 2;
        TEST2;
    }
    if(sc == 1) {
        OUTC(sbackc(p)/10 +'0');
    }
    Bprint(&bout,"\n");
    release(p);
}

void
oneot(Blk *p, int sc, char ch)
{
    Blk *q;

    q = removc(p,sc);
    create_(strptr);
    sputc(strptr,-1);
    while(length(q)>0) {
        p = add(strptr,q);
        release(q);
        q = p;
        OUTC(ch);
    }
    release(q);
    Bprint(&bout,"\n");
}

void
hexot(Blk *p, int flg)
{
    int c;

    USED(flg);
    rewind(p);
    if(sfeof(p) != 0) {
        sputc(strptr,'0');
        release(p);
        return;
    }
    c = sgetc(p);
    release(p);
    if(c >= 16) {
        Bprint(&bout,"hex digit > 16");
        return;
    }
    sputc(strptr,c<10?c+'0':c-10+'a');
}

void
bigot(Blk *p, int flg)
{
    Blk *t, *q;
    int neg, l;

    if(flg == 1) {
        t = salloc(0);
        l = 0;
    } else {
        t = strptr;
        l = length(strptr)+fw-1;
    }
    neg=0;
    if(length(p) != 0) {
        fsfile(p);
        if(sbackc(p)<0) {
            neg=1;
            chsign(p);
        }
        while(length(p) != 0) {
            q = div_(p,tenptr);
            release(p);
            p = q;
            rewind(rem);
            sputc(t,sfeof(rem)?'0':sgetc(rem)+'0');
            release(rem);
        }
    }
    release(p);
    if(flg == 1) {
        l = fw1-length(t);
        if(neg != 0) {
            l--;
            sputc(strptr,'-');
        }
        fsfile(t);
        while(l-- > 0)
            sputc(strptr,'0');
        while(sfbeg(t) == 0)
            sputc(strptr,sbackc(t));
        release(t);
    } else {
        l -= length(strptr);
        while(l-- > 0)
            sputc(strptr,'0');
        if(neg != 0) {
            sclobber(strptr);
            sputc(strptr,'-');
        }
    }
    sputc(strptr,' ');
}

Blk*
add(Blk *a1, Blk *a2)
{
    Blk *p;
    int carry, n, size, c, n1, n2;

    size = length(a1)>length(a2)?length(a1):length(a2);
    p = salloc(size);
    rewind(a1);
    rewind(a2);
    carry=0;
    while(--size >= 0) {
        n1 = sfeof(a1)?0:sgetc(a1);
        n2 = sfeof(a2)?0:sgetc(a2);
        n = n1 + n2 + carry;
        if(n>=100) {
            carry=1;
            n -= 100;
        } else
        if(n<0) {
            carry = -1;
            n += 100;
        } else
            carry = 0;
        sputc(p,n);
    }
    if(carry != 0)
        sputc(p,carry);
    fsfile(p);
    if(sfbeg(p) == 0) {
        c = 0;
        while(sfbeg(p) == 0 && (c = sbackc(p)) == 0)
            ;
        if(c != 0)
            salterc(p,c);
        truncate(p);
    }
    fsfile(p);
    if(sfbeg(p) == 0 && sbackc(p) == -1) {
        while((c = sbackc(p)) == 99) {
            if(c == -1)
                break;
        }
        skipc(p);
        salterc(p,-1);
        truncate(p);
    }
    return(p);
}

int
eqk(void)
{
    Blk *p, *q;
    int skp, skq;

    p = pop();
    EMPTYS;
    q = pop();
    EMPTYSR(p);
    skp = sunputc(p);
    skq = sunputc(q);
    if(skp == skq) {
        arg1=p;
        arg2=q;
        savk = skp;
        return(0);
    }
    if(skp < skq) {
        savk = skq;
        p = add0(p,skq-skp);
    } else {
        savk = skp;
        q = add0(q,skp-skq);
    }
    arg1=p;
    arg2=q;
    return(0);
}

Blk*
removc(Blk *p, int n)
{
    Blk *q, *r;

    rewind(p);
    while(n>1) {
        skipc(p);
        n -= 2;
    }
    q = salloc(2);
    while(sfeof(p) == 0)
        sputc(q,sgetc(p));
    if(n == 1) {
        r = div_(q,tenptr);
        release(q);
        release(rem);
        q = r;
    }
    release(p);
    return(q);
}

Blk*
scalint(Blk *p)
{
    int n;

    n = sunputc(p);
    p = removc(p,n);
    return(p);
}

Blk*
scale(Blk *p, int n)
{
    Blk *q, *s, *t;

    t = add0(p,n);
    q = salloc(1);
    sputc(q,n);
    s = dcexp(inbas,q);
    release(q);
    q = div_(t,s);
    release(t);
    release(s);
    release(rem);
    sputc(q,n);
    return(q);
}

<<function [[subt]](dc.c)>>

<<function [[command]](dc.c)>>

int
cond(char c)
{
    Blk *p;
    int cc;

    if(subt() != 0)
        return(1);
    p = pop();
    sclobber(p);
    if(length(p) == 0) {
        release(p);
        if(c == '<' || c == '>' || c == NE) {
            getstk();
            return(0);
        }
        load();
        return(1);
    }
    if(c == '='){
        release(p);
        getstk();
        return(0);
    }
    if(c == NE) {
        release(p);
        load();
        return(1);
    }
    fsfile(p);
    cc = sbackc(p);
    release(p);
    if((cc<0 && (c == '<' || c == NG)) ||
       (cc >0) && (c == '>' || c == NL)) {
        getstk();
        return(0);
    }
    load();
    return(1);
}

void
load(void)
{
    int c;
    Blk *p, *q, *t, *s;

    c = getstk() & 0377;
    sptr = stable[c];
    if(sptr != 0) {
        p = sptr->val;
        if(c >= ARRAYST) {
            q = salloc(length(p));
            rewind(p);
            while(sfeof(p) == 0) {
                s = dcgetwd(p);
                if(s == 0) {
                    putwd(q, (Blk*)0);
                } else {
                    t = copy(s,length(s));
                    putwd(q,t);
                }
            }
            pushp(q);
        } else {
            q = copy(p,length(p));
            pushp(q);
        }
    } else {
        q = salloc(1);
        if(c <= LASTFUN) {
            Bprint(&bout,"function %c undefined\n",c+'a'-1);
            sputc(q,'c');
            sputc(q,'0');
            sputc(q,' ');
            sputc(q,'1');
            sputc(q,'Q');
        }
        else
            sputc(q,0);
        pushp(q);
    }
}

int
log2_(long n)
{
    int i;

    if(n == 0)
        return(0);
    i=31;
    if(n<0)
        return(i);
    while((n <<= 1) > 0)
        i--;
    return i-1;
}

<<function [[salloc]](dc.c)>>
<<function [[morehd]](dc.c)>>
<<function [[copy]](dc.c)>>

<<function [[sdump]](dc.c)>>

void
seekc(Blk *hptr, int n)
{
    char *nn,*p;

    nn = hptr->beg+n;
    if(nn > hptr->last) {
        nbytes += nn - hptr->last;
        if(nbytes > maxsize)
            maxsize = nbytes;
        lbytes += nn - hptr->last;
        if(n > longest)
            longest = n;
/*      free(hptr->beg); /**/
        p = realloc(hptr->beg, n);
        if(p == 0) {
/*          hptr->beg = realloc(hptr->beg, hptr->last-hptr->beg);
**          garbage("seekc");
**          if((p = realloc(hptr->beg, n)) == 0)
*/              ospace("seekc");
        }
        hptr->beg = p;
        hptr->wt = hptr->last = hptr->rd = p+n;
        return;
    }
    hptr->rd = nn;
    if(nn>hptr->wt)
        hptr->wt = nn;
}

void
salterwd(Blk *ahptr, Blk *n)
{
    Wblk *hptr;

    hptr = (Wblk*)ahptr;
    if(hptr->rdw == hptr->lastw)
        more(ahptr);
    *hptr->rdw++ = n;
    if(hptr->rdw > hptr->wtw)
        hptr->wtw = hptr->rdw;
}

void
more(Blk *hptr)
{
    unsigned size;
    char *p;

    if((size=(hptr->last-hptr->beg)*2) == 0)
        size=2;
    nbytes += size/2;
    if(nbytes > maxsize)
        maxsize = nbytes;
    if(size > longest)
        longest = size;
    lbytes += size/2;
    lmore++;
/*  free(hptr->beg);/**/
    p = realloc(hptr->beg, size);

    if(p == 0) {
/*      hptr->beg = realloc(hptr->beg, (hptr->last-hptr->beg));
**      garbage("more");
**      if((p = realloc(hptr->beg,size)) == 0)
*/          ospace("more");
    }
    hptr->rd = p + (hptr->rd - hptr->beg);
    hptr->wt = p + (hptr->wt - hptr->beg);
    hptr->beg = p;
    hptr->last = p+size;
}

<<function [[ospace]](dc.c)>>
<<function [[garbage]](dc.c)>>
<<function [[release]](dc.c)>>

Blk*
dcgetwd(Blk *p)
{
    Wblk *wp;

    wp = (Wblk*)p;
    if(wp->rdw == wp->wtw)
        return(0);
    return(*wp->rdw++);
}

void
putwd(Blk *p, Blk *c)
{
    Wblk *wp;

    wp = (Wblk*)p;
    if(wp->wtw == wp->lastw)
        more(p);
    *wp->wtw++ = c;
}

Blk*
lookwd(Blk *p)
{
    Wblk *wp;

    wp = (Wblk*)p;
    if(wp->rdw == wp->wtw)
        return(0);
    return(*wp->rdw);
}

int
getstk(void)
{
    int n;
    uchar c;

    c = readc();
    if(c != '<')
        return c;
    n = 0;
    while(1) {
        c = readc();
        if(c == '>')
            break;
        n = n*10+c-'0';
    }
    return n;
}
@

\subsection{[[calc/bc.y]]}

<<prelude bc.y>>=
<<plan9 includes>>
#include        <bio.h>

#define bsp_max 5000

<<globals bc.y>>
<<global flags bc.y>>

// forward decls
char*   bundle(int, ...);
void    conout(char*, char*);
int     cpeek(int, int, int);
int     getch(void);
char*   geta(char*);
char*   getf(char*);
void    getout(void);
void    output(char*);
void    pp(char*);
void    routput(char*);
void    tp(char*);
void    yyerror(char*, ...);
int     yyparse(void);

typedef void*   pointer;
#pragma varargck        type    "lx"    pointer
@


<<calc/bc.y>>=
%{
        <<prelude bc.y>>
%}
<<union directive bc.y>>

<<type directives bc.y>>
<<token directives bc.y>>
<<priority directives bc.y>>
%%
<<grammar bc.y>>
%%

<<function [[yylex]](bc.y)>>

int
cpeek(int c, int yes, int no)
{

        peekc = getch();
        if(peekc == c) {
                peekc = -1;
                return yes;
        }
        return no;
}

int
getch(void)
{
        long ch;

loop:
        ch = peekc;
        if(ch < 0){
                if(in == 0)
                        ch = -1;
                else
                        ch = Bgetc(in);
        }
        peekc = -1;
        if(ch >= 0)
                return ch;
        ifile++;
        if(ifile > sargc) {
                if(ifile >= sargc+2)
                        getout();
                in = &bstdin;
                Binit(in, 0, OREAD);
                ln = 0;
                goto loop;
        }
        if(in)
                Bterm(in);
        if((in = Bopen(sargv[ifile], OREAD)) != 0){
                ln = 0;
                ss = sargv[ifile];
                goto loop;
        }
        yyerror("cannot open input file");
        return 0;               /* shut up ken */
}

char*
bundle(int a, ...)
{
        int i;
        char **q;
        va_list arg;
        
        i = a;
        va_start(arg, a);
        q = bsp_nxt;
        if(bdebug)
                fprint(2, "bundle %d elements at %lx\n", i, q);
        while(i-- > 0) {
                if(bsp_nxt >= &bspace[bsp_max])
                        yyerror("bundling space exceeded");
                *bsp_nxt++ = va_arg(arg, char*);
        }
        *bsp_nxt++ = 0;
        va_end(arg);
        //old: does not work with bison, need to use $$ in caller
        //yyval.cptr = (char*)q;
        return (char*)q;
}

void
routput(char *p)
{
        char **pp;
        
        if(bdebug)
                fprint(2, "routput(%lx)\n", p);
        if((char**)p >= &bspace[0] && (char**)p < &bspace[bsp_max]) {
                /* part of a bundle */
                pp = (char**)p;
                while(*pp != 0)
                        routput(*pp++);
        } else
                Bprint(&bstdout, p);    /* character string */
}

void
output(char *p)
{
        routput(p);
        bsp_nxt = &bspace[0];
        Bprint(&bstdout, "\n");
        Bflush(&bstdout);
        cp = cary;
        crs = rcrs;
}

void
conout(char *p, char *s)
{
        Bprint(&bstdout, "[");
        routput(p);
        Bprint(&bstdout, "]s%s\n", s);
        Bflush(&bstdout);
        lev--;
}

<<function [[yyerror]](bc.y)>>

void
pp(char *s)
{
        /* puts the relevant stuff on pre and post for the letter s */
        pre = bundle(3, "S", s, pre);
        post = bundle(4, post, "L", s, "s.");
}

void
tp(char *s)
{
        /* same as pp, but for temps */
        pre = bundle(3, "0S", s, pre);
        post = bundle(4, post, "L", s, "s.");
}

<<function [[yyinit]](bc.y)>>

void
getout(void)
{
        Bprint(&bstdout, "q");
        Bflush(&bstdout);
        exits(0);
}

char*
getf(char *p)
{
        return funtab[*p - 'a'];
}

char*
geta(char *p)
{
        return atab[*p - 'a'];
}

<<function [[main]](bc.y)>>
@
