\part{Was in Kernel.nw main text}

%title: x86 (32 bits) edition

\chapter{Introduction}

\section{Requirements}

%one of the item is about the x86 architecture

\chapter{Overview}

\section{The [[x86]] machine}
% actually will take 386, not 486, nor x86_64 or amd64, so simpler.

<<include/arch/386/ureg.h>>=
struct Ureg
{
 ulong	di;		/* general registers */
 ulong	si;		/* ... */
 ulong	bp;		/* ... */
 ulong	nsp;
 ulong	bx;		/* ... */
 ulong	dx;		/* ... */
 ulong	cx;		/* ... */
 ulong	ax;		/* ... */

 ulong	gs;		/* data segments */
 ulong	fs;		/* ... */
 ulong	es;		/* ... */
 ulong	ds;		/* ... */

 ulong	trap;		/* trap type */
 ulong	ecode;		/* error code (or zero) */
 ulong	pc;		/* pc */
 ulong	cs;		/* old context */
 ulong	flags;		/* old flags */
 union {
  ulong	usp;
  ulong	sp;
 };
 ulong	ss;		/* old stack segment */
};
@
% complicated ... ARM simpler.

% processor is not everything. There is also buses, devices, RAM, etc.
% There are tons of x86 machines ... we restrict to the one
% supported by qemu-system-386.

% intro segmentation and pagination? or ref to vm chapter?



\section{Code organization}

<<core/386/dat.h>>=

<<enum misc_constants(x86)>>
<<pad memory pointer types(x86)>>

#include "dat_forward.h"
#include "../port/portdat_forward.h"

// defines Lock (used inline in Cpu in portdat_core.h so must be before)
#include "../port/portdat_concurrency.h"

// defines Conf, Cpu, ... Label
#include "dat_core.h"
#include "../port/portdat_core.h"

// defines Page, Pagetable, Segment, KImage
#include "dat_memory.h"
#include "../port/portdat_memory.h"

// defines Chan
#include "../port/portdat_files.h"

// defines PCArch, a few arch-specific constants
#include "dat_arch.h"

// defines Timer
#include "dat_time.h"
#include "../port/portdat_time.h"

// defines Vctl
#include "dat_interrupts.h"

// defines Proc
#include "dat_processes.h"
#include "../port/portdat_processes.h"

// defines Cmd
#include "../port/portdat_misc.h"

// defines Uart
#include "../port/portdat_buses.h"

// defines keyboard queue, consdevtab
#include "../port/portdat_console.h"

// defines DevConf, DevPort (not that used)
#include "../port/portdat_devices.h"

// ref<Cpu>, the actual Cpu is where??
extern Cpu *cpu;

<<macro up(x86)>>

<<portdat.h pragmas(x86)>>
@

<<core/386/fns.h>>=
#include "../port/portfns_core.h"
#include "../port/portfns_concurrency.h"
#include "../port/portfns_memory.h"
#include "../port/portfns_files.h"
#include "../port/portfns_time.h"
#include "../port/portfns_interrupts.h"
#include "../port/portfns_processes.h"
#include "../port/portfns_misc.h"
#include "../port/portfns_console.h"
#include "../port/portfns_buses.h"
#include "../port/portfns_devices.h"
#include "../port/portfns_security.h"
#include "../port/portfns_network.h"
#include "../port/portfns_syscalls.h"
#include "../port/portfns_init.h"

<<fns.h declarations(x86)>>
@


<<main.c forward decl for backward deps(x86)>>=
int devcons_print(char*, ...);
int devcons_iprint(char*, ...);
int devcons_pprint(char*, ...);
void devcons_panic(char*, ...);
void devcons__assert(char*);
void trap_dumpstack(void);
void proc_dumpaproc(Proc *p);
void proc_error(char*);
void proc_nexterror(void);
void i8253_delay(int millisecs);
void i8253_microdelay(int microsecs);
void proc_sched(void);
void proc_ready(Proc*);
void proc_sleep(Rendez*, int(*)(void*), void*);
void proc_tsleep(Rendez *r, int (*fn)(void*), void *arg, ulong ms);
Proc* proc_wakeup(Rendez*);
void proc_pexit(char *exitstr, bool freemem);
Proc* proc_proctab(int i);
int proc_postnote(Proc *p, int dolock, char *n, int flag);
void chan_cclose(Chan *c);
void main_exit(int ispanic);
int  main_isaconfig(char *class, int ctlrno, ISAConf *isa);
void nop(void);
uvlong devarch_arch_fastticks(uvlong *hz);
void devarch_hook_ioalloc();
@


<<[[main()]] initial assignments for backward deps(x86)>>=
devtab = conf_devtab;

print = devcons_print;
iprint = devcons_iprint;
pprint = devcons_pprint;
panic = devcons_panic;
_assert = devcons__assert;
error = proc_error;
nexterror = proc_nexterror;
dumpaproc = proc_dumpaproc;
wakeup = proc_wakeup;
sched = proc_sched;
ready = proc_ready;
sleep = proc_sleep;
tsleep = proc_tsleep;
cclose = chan_cclose;
proctab = proc_proctab;
postnote = proc_postnote;
pexit = proc_pexit;
hook_ioalloc = devarch_hook_ioalloc;

arch_delay = i8253_delay;
arch_microdelay = i8253_microdelay;
/*
 * On a uniprocessor, you'd think that coherence could be nop,
 * but it can't.  We still need a barrier when using coherence() in
 * device drivers.
 *
 * On VMware, it's safe (and a huge win) to set this to nop.
 * Aux/vmware does this via the #P/archctl file.
 */
arch_coherence = nop;
arch_fastticks = devarch_arch_fastticks;
arch_exit = main_exit;
arch_dumpstack = trap_dumpstack;
arch_isaconfig = main_isaconfig;
@


%<<main.c forward decl for backward deps(x86)>>=
%@
%
%<<[[main()]] initial assignments for backward deps(x86)>>=
%iprint = devcons_iprint;
%hook_ioalloc = devarch_hook_ioalloc;
%devtab = conf_devtab;
%arch_coherence = nop;
%@

\section{Software architecture}

\subsection{Booting overview (x86)}

\subsection{Memory overview (x86)}

%binary image has been compiled with -TKZERO_AND_HEADER!! important
% and assume loading phase setup physical mapping from KZERO to 0 physical
% and so by having kernel at KTZERO beyond all special memory so no overlap
% with sensitive area.


<<pad memory pointer types(x86)>>=
// physical address
typedef uintptr phys_addr;
// virtual address (which should be a user address)
typedef uintptr virt_addr;
// kernel address (mostly physical + KZERO)
typedef uintptr kern_addr;
@

<<pad memory pointer types(x86)>>=
typedef ulong* kern_addr2;
typedef ulong* virt_addr2;
typedef void* virt_addr3;
typedef void* kern_addr3;
@

% idt, gdt, pd intel, pt intel, 


<<constant KZERO(x86)>>=
//coupling: with mkfile KZERO_AND_HEADER
#define KZERO   0xE0000000    /* base of kernel address space */
@
% last 512Mo of virtual memory space

% why not use different segments? because convenient to be in same
% virtual space, can read/write stuff on and from userspace

<<constant KTZERO(x86)>>=
#define KTZERO    (KZERO+0x100000)  /* first address in kernel text */
@
% why + 0x100000? because will map kzero to physical memory addr 0,
% and lots of address before 1Mo are reserved, used by device, e.g.
% screen cga is at 0xb8000

<<constant UZERO(x86)>>=
#define UZERO   0     /* base of user address space */
@

<<constant UTZERO(x86)>>=
#define UTZERO    (UZERO+BY2PG)   /* first address in user text */
@



<<function paddr(x86)>>=
phys_addr
arch_paddr(kern_addr3 v)
{
    kern_addr va;
    
    va = (kern_addr)v;
    if(va < KZERO)
        panic("arch_paddr: va=%#.8lux pc=%#p", va, getcallerpc(&v));
    return va-KZERO;
}
@
%less: not symetric, phys_addr vs kern_addr3, but hard to make
% symetric because then got lots of type errors

% pa must be <= MAXKPA, we use kaddr to access kernel data.
% if want to access different pa, then must use tmpmap or arch_kmap.
<<function kaddr(x86)>>=
/*
 * These could go back to being macros once the kernel is debugged,
 * but the extra checking is nice to have.
 */
kern_addr3
arch_kaddr(phys_addr pa)
{
    if(pa > MAXKPA)
        panic("arch_kaddr: pa=%#.8lux", pa);
    return (kern_addr3)(pa+KZERO);
}
@
%todo: should return a kern_addr

<<constant MAXKPA(x86)>>=
// -KZERO = 0xFFFFFFFF-KZERO in two's complement arithmetic
#define MAXKPA (phys_addr)(-KZERO)
@
% rename KEND? but it's not really kernel end. KADDREND? MAXKADDR? KADDREND?

<<function cankaddr(x86)>>=
/*
 * Return the number of bytes that can be accessed via KADDR(pa).
 * If pa is not a valid argument to KADDR, return 0.
 */
ulong
arch_cankaddr(phys_addr pa)
{
    if(pa >= MAXKPA)
        return 0;
    return MAXKPA - pa;
}
@
% used in xinit



% why trivial macro? because in other archi can be different
<<function KADDR(x86)>>=
#define KADDR(pa)  arch_kaddr(pa)
@

<<function PADDR(x86)>>=
#define PADDR(ka)  arch_paddr((kern_addr3)(ka))
@
%less: remove cast? more symetric with KADDR then
% actually all those intermediate types are very ugly, could simplify!
% but not easy

% in l.s:
%#define PADDR(ka)        ((ka)&~KZERO)
%#define KADDR(pa)        (KZERO|(pa))

% also IDT, GDT, PD0, PT0


\subsection{Syscall overview (x86)}

<<constant VectorSYSCALL(x86)>>=
//!!! int 64 (0x40), way to jump in plan9 OS !!!
#define VectorSYSCALL 64
@

\chapter{Core Data Structures}

\section{[[Cpu]] and [[cpu]]}

<<struct ArchCpu(x86)>>=
struct Arch_Cpu {
    <<[[Cpu]] [[Arch]] cpuid fields(x86)>>
    <<[[Cpu]] [[Arch]] other fields(x86)>>
};
@ 

% note that cpuinit just set cpus[0], not cpu, cpu is set in clearbss
<<global cpu(x86)>>=
// ref<Cpu>, assigned to CPUADDR in _clearbss
Cpu *cpu;
@ 

% note that cpus[0] will not be CPUADDR! it will be
% CPU0CPU (this will defeat the purpose otherwise)

<<constant MAXCPUS(x86)>>=
/*
 * In 32-bit mode, the MAXCPUS limit is 32 without
 * changing the way active.cpus is defined and used
 * (unfortunately, it is also used in the port code).
 */
#define MAXCPUS   32      /* max # cpus system can run */
@

\section{[[Proc]] and [[up]]}

<<struct ArchProc(x86)>>=
struct Arch_Proc
{
  <<[[Proc]] [[Arch]] memory fields(x86)>>
};
@

<<macro up(x86)>>=
// up = user process
#define up (cpu->proc)
@
%history: 
% Just like for 'cpu', we want 'up' to be something local to each processor.
% up used to be '#define up ((MACH*)MACHADDR)->externup' because:
% - doing just (m->externup) was conflicting with some functions using
%   a local variables called 'm'. Indeed up is a macro, not a closure so
%   any code introducing a local variable 'm' will not be able to use up
%   => rename m to cpu so less conflict (still some but rare) 
%   and can now do (cpu->externup)
% - why externup? because in other architectures such as bcm one can do
%     extern register Mach* m;			/* R10 */
%     extern register Proc* up;			/* R9 */
%   and so m and up are really extern registers (for sure local and different
%   in each processor). On the PC we don't have that many registers so
%   have to emulate per-processor data via the virtual memory and the CPUADDR
%   trick
% - => because in the end we don't use registers, there is no need
%   to have both a cpu->proc and cpu->externup field, one can just
%   use cpu->proc for up!

\section{[[PCArch]] and [[arch]] (x86)}

<<struct PCArch(x86)>>=
struct PCArch
{
  char* id;

  int (*ident)(void);   /* this should be in the model */
  void  (*reset)(void);   /* this should be in the model */
  void  (*resetothers)(void); /* put other cpus into reset */

  // interrupts
  <<[[PCArch]] interrupt methods fields(x86)>>
  // clock, timer
  <<[[PCArch]] time methods fields(x86)>>
  // power
  <<[[PCArch]] power methods fields(x86)>>
};
@ 

% could add cycles and cmpswap here? and also pcmspecial, fps?

<<global arch(x86)>>=
PCArch* arch;
@ 

<<global archgeneric(x86)>>=
PCArch archgeneric = {
    .id=        "generic",
    .ident=     nil,
    .reset=     archreset,

    // interrupt: Intel i8259 controller
    <<[[archgeneric]] interrupt methods(x86)>>
    // clock: Intel i8253 controller
    <<[[archgeneric]] time methods(x86)>>
    // power: none
    <<[[archgeneric]] power methods(x86)>>
};
@
% what ident is for?

% SMP is more complex arch: 'archmp'

\chapter{Concurrency}

\section{[[arch_splhi()]], [[arch_spllo()]] (x86)}

<<function splhi(x86)>>=
// bool   arch_splhi(void);
TEXT arch_splhi(SB), $0
shi:
        PUSHFL
        POPL    AX
        TESTL   $0x200, AX /* pad: interrupt bit */
        JZ      alreadyhi
        MOVL    $(CPUADDR+0x04), CX            /* save PC in cpu->splpc */
        MOVL    (SP), BX
        MOVL    BX, (CX)
alreadyhi:
        CLI
        RET
@ 
%$
% interrupt state is in x86 flags register, accessible via pushfl
% cli

<<function spllo(x86)>>=
// bool   arch_spllo(void);
TEXT arch_spllo(SB), $0
slo:
        PUSHFL
        POPL    AX
        TESTL   $0x200, AX
        JNZ     alreadylo
        MOVL    $(CPUADDR+0x04), CX            /* clear cpu->splpc */
        MOVL    $0, (CX)
alreadylo:
        STI
        RET
@ 
%sti

<<function splx(x86)>>=
// void    arch_splx(bool);
TEXT arch_splx(SB), $0
        MOVL    s+0(FP), AX
        TESTL   $0x200, AX
        JNZ     slo
        JMP     shi
@ 
% ref label in arch_splhi and spllot


<<function islo(x86)>>=
// bool arch_islo(void);
TEXT arch_islo(SB), $0
        PUSHFL
        POPL    AX
        ANDL    $0x200, AX                      /* interrupt enable flag */
        RET
@ 
%$

\section{[[arch_tas()]] (x86)}

<<function tas(x86)>>=
TEXT arch_tas(SB), $0
        MOVL    $0xDEADDEAD, AX
        MOVL    l+0(FP), BX
        XCHGL   AX, (BX)                        /* lock->key */
        RET
@ 
% XCHGL is atomic! can't have 2 cpu doing same thing at the same time
% only one will win!

%        // Exchange AX (0xDEADDEAD) to lock->key. So:
%        //  - if the lock was not held, lock->key was 0 and so AX will be 0
%        //     and lock->key will be 0xdeaddead
%        //  - if the lock was held, AX will be 0xdeaddead and lock->key will
%        //    still be 0xdeaddead.

% return in AX, so can read that as what was the value in the lock, and if
% nul then set it! So arch_tas() == 0 mean? arch_tas() == 0xDEADEAD mean?
% return in AX see C conventions.

% movl l+0(FP) is because we use 0(FP) and 8a forces the programmer
% to give a name to accessed parameters. Used in debugger?

\section{Atomic [[arch_xinc()]] and [[arch_xdec()]] (x86)}

<<function _xinc(x86)>>=
/* void arch_xinc(long*); */
TEXT arch_xinc(SB), $0
        MOVL    l+0(FP), AX
        LOCK;   INCL 0(AX)
        RET
@ 


<<function _xdec(x86)>>=
/* long arch_xdec(long*); */
TEXT arch_xdec(SB), $0
        MOVL    l+0(FP), BX
        XORL    AX, AX
        LOCK;   DECL 0(BX)
        JLT     _xdeclt
        JGT     _xdecgt
        RET
_xdecgt:
        INCL    AX
        RET
_xdeclt:
        DECL    AX
        RET
@ 


\section{[[arch_coherence()]] (x86)}

% originally set to nop, but then can be set to functions
% below via arch device

<<function mb386(x86)>>=
TEXT mb386(SB), $0
        POPL    AX                              /* return PC */
        PUSHFL
        PUSHL   CS
        PUSHL   AX
        IRETL
@
<<function mb586(x86)>>=
TEXT mb586(SB), $0
        XORL    AX, AX
        CPUID
        RET
@
<<function mfence(x86)>>=
TEXT mfence(SB), $0
        BYTE $0x0f
        BYTE $0xae
        BYTE $0xf0
        RET
@

\chapter{Memory}

\section{[[Segment]] and [[Pagetable]]}

<<constant PAGEDIRSIZE(x86)>>=
#define PAGEDIRSIZE  1984
@

<<constant SMALLPAGEDIRSIZE(x86)>>=
#define SMALLPAGEDIRSIZE 16
@

<<constant PAGETABMAPMEM(x86)>>=
#define PAGETABMAPMEM (1024*1024) // 1MB
@

<<constant PAGETABSIZE(x86)>>=
#define PAGETABSIZE 256 // (PAGETABMAPMEM/BY2PG)
@

\chapter{Processes}

\section{[[sysrfork()]]}

\subsection{[[arch_forkchild()]] (x86)}


<<function forkchild(x86)>>=
void
arch_forkchild(Proc *p, Ureg *ureg)
{
    Ureg *cureg;

    /*
     * Add 2*BY2WD to the stack to account for
     *  - the return PC
     *  - trap's argument (ur)
     */
    p->sched.sp = (ulong)p->kstack+KSTACK-(sizeof(Ureg)+2*BY2WD);
    p->sched.pc = (ulong)arch_forkret;

    cureg = (Ureg*)(p->sched.sp+2*BY2WD);
    memmove(cureg, ureg, sizeof(Ureg));
    /* return value of syscall in child */
    cureg->ax = 0;

    /* Things from bottom of syscall which were never executed */
    p->psstate = nil;
    p->insyscall = false;
}
@
% have to fake a return of syscall here, of sysrfork

<<function forkret(x86)>>=
TEXT arch_forkret(SB), $0
        POPL    AX
        POPAL
        POPL    GS
        POPL    FS
        POPL    ES
        POPL    DS
        ADDL    $8, SP                  /* pop error code and trap type */
        IRETL
@
%?? POPAL? need to look at core code for returning from syscall as this is
% what we emulate here

\section{[[sysexec()]]}

<<constant AOUT_MAGIC(x86)>>=
/*
 *  parameters for sysproc.c
 */
// I_MAGIC is defined in include/a.out.h, I for INTEL?
#define AOUT_MAGIC  (I_MAGIC)
@

<<function UTROUND(x86)>>=
#define UTROUND(t)  ROUNDUP((t), BY2PG)
@

<<constant TSTKTOP(x86)>>=
#define TSTKTOP   (USTKTOP-USTKSIZE)  /* end of new stack in sysexec */ // just below
@

<<constant TSTKSIZ(x86)>>=
#define TSTKSIZ   100     /* pages in new stack; limits exec args */
@

<<function procsetup(x86)>>=
void
arch_procsetup(Proc* p)
{
  <<[[procsetup()]] fp setup(x86)>>
}
@ 

<<function execregs(x86)>>=
long
arch_execregs(ulong entry, ulong ssize, ulong nargs)
{
    ulong *sp;
    Ureg *ureg;

    <<[[execregs()]] fp adjustments(x86)>>

    sp = (ulong*)(USTKTOP - ssize);
    *--sp = nargs;

    ureg = up->dbgreg;
    ureg->usp = (ulong)sp;
    ureg->pc = entry;
    return USTKTOP
     <<[[execregs()]] return adjustments(x86)>>
     ;     /* address of kernel/user shared data */
}
@ 

\section{Kernel processes}

<<function kprocchild(x86)>>=
void
arch_kprocchild(Proc* p, void (*func)(void*), void* arg)
{
    p->kpfun = func;
    p->kparg = arg;

    /*
     * arch_gotolabel() needs a word on the stack in
     * which to place the return PC used to jump
     * to linkproc().
     */
    p->sched.pc = (ulong)linkproc;
    p->sched.sp = (ulong)p->kstack+KSTACK-BY2WD;
}
@ 

<<function linkproc(x86)>>=
static void
linkproc(void)
{
    arch_spllo();
    up->kpfun(up->kparg);
    // should never reach this place?? kernel processes are supposed
    // to run forever??
    pexit("kproc dying", /*freemem*/false); 
}
@ 

\chapter{Interrupts}

% from wikipedia IRQ page:
%  - at beginning had one PIC, IRQ0 ot IRQ7
%  - then 2 PICs, IRQ0 to IRQ15 (and one IRQ used for the chaining I think)
%  - then APIC, up to 255 IRQ lines per APIC


\section{[[Vctl]] (x86)}

<<struct Vctl(x86)>>=
struct Vctl {

    bool isintr;     /* interrupt or fault/trap */
    int irq; // if interrupt
  
    void  (*f)(Ureg*, void*); /* handler to call */
    void* a;      /* argument to call it with */
  
    char  name[KNAMELEN];   /* of driver */
    int tbdf; // /* type+bus+device+function */ ??
  
    <<[[Vctl]] other fields(x86)>>
    // Extra
    <<[[Vctl]] extra fields(x86)>>
};
@

<<global vctl(x86)>>=
// array<list<ref_own<Vctl>>> (next = Vctl.next)
static Vctl *vctl[256];
@ 

<<[[Vctl]] extra fields(x86)>>=
// list<ref_own<Vctl> of vctl[vno], xalloc'ed (should not have that many so ok)
Vctl* next;     /* handlers on this vector */
@

<<global vctllock(x86)>>=
static Lock vctllock;
@ 

% for /dev/irqalloc via devarch.c addarchfile
<<function irqallocread(x86)>>=
static long
irqallocread(Chan*, void *vbuf, long n, vlong offset)
{
    char *buf, *p, str[2*(11+1)+KNAMELEN+1+1];
    int m, vno;
    long oldn;
    Vctl *v;

    if(n < 0 || offset < 0)
        error(Ebadarg);

    oldn = n;
    buf = vbuf;
    for(vno=0; vno<nelem(vctl); vno++){
        for(v=vctl[vno]; v; v=v->next){
            m = snprint(str, sizeof str, "%11d %11d %.*s\n", vno, v->irq, KNAMELEN, v->name);
            if(m <= offset) /* if do not want this, skip entry */
                offset -= m;
            else{
                /* skip offset bytes */
                m -= offset;
                p = str+offset;
                offset = 0;

                /* write at most max(n,m) bytes */
                if(m > n)
                    m = n;
                memmove(buf, p, m);
                n -= m;
                buf += m;

                if(n == 0)
                    return oldn;
            }
        }
    }
    return oldn - n;
}
@ 

\section{Faults (x86)}

<<enum vector(x86)>>=
enum {
    <<enum vector cases(x86)>>
};
@

<<enum vector cases(x86)>>=
    VectorNMI = 2,    /* non-maskable interrupt */
    VectorBPT = 3,    /* breakpoint */
    VectorUD  = 6,    /* invalid opcode exception */
    VectorCNA = 7,    /* coprocessor not available */
    Vector2F  = 8,    /* double fault */
    VectorCSO = 9,    /* coprocessor segment overrun */
    VectorPF  = 14,   /* page fault */ //!!! page fault interrupt
    Vector15  = 15,   /* reserved */
    VectorCERR  = 16,   /* coprocessor error */
@
% very important page fault, base of virtual memory

% called by trapinit() (trap vs intr?)
<<function trapenable(x86)>>=
void
trapenable(int vno, void (*f)(Ureg*, void*), void* a, char *name)
{
    Vctl *v;

    if(vno < 0 || vno >= VectorPIC)
        panic("trapenable: vno %d", vno);

    v = xalloc(sizeof(Vctl));
    v->tbdf = BUSUNKNOWN;
    v->f = f;
    v->a = a;
    v->isintr = false;
    strncpy(v->name, name, KNAMELEN);
    v->name[KNAMELEN-1] = 0;

    ilock(&vctllock);
    //add_list(vctl[vno], v)
    v->next = vctl[vno];
    vctl[vno] = v;
    iunlock(&vctllock);
}
@ 

\section{IRQs (x86)}

<<enum vector cases(x86)>>=
    VectorPIC = 32,   /* external i8259 interrupts */
@

<<enum irq(x86)>>=
enum {
    IrqCLOCK  = 0, // !!! clock interrupt
    IrqKBD    = 1,
    IrqUART1  = 3,
    IrqUART0  = 4,
    IrqPCMCIA = 5,
    IrqFLOPPY = 6,
    IrqLPT    = 7,
    IrqIRQ7   = 7,
    IrqAUX    = 12,   /* PS/2 port */
    IrqIRQ13  = 13,   /* coprocessor on 386 */
    IrqATA0   = 14,
    IrqATA1   = 15,

    MaxIrqPIC = 15,
  
    IrqLINT0  = 16,   /* LINT[01] must be offsets 0 and 1 */
    IrqLINT1  = 17,
    IrqTIMER  = 18, // for alarms
    IrqERROR  = 19,
    IrqPCINT  = 20,
    IrqSPURIOUS = 31,   /* must have bits [3-0] == 0x0F */

    MaxIrqLAPIC = 31,
};
@
% LINT? Low interrupt? PCINT?
% very important: clock interrupt, base of preemptive scheduling!


<<[[Vctl]] other fields(x86)>>=
// interrupt service routine
int (*isr)(int);    /* get isr bit for this irq */
int (*eoi)(int);    /* eoi */
@


<<function intrenable(x86)>>=
void
arch_intrenable(int irq, void (*f)(Ureg*, void*), void* a, int tbdf, char *name)
{
    int vno;
    Vctl *v;

    if(f == nil){
        print("intrenable: nil handler for %d, tbdf 0x%uX for %s\n",
            irq, tbdf, name);
        return;
    }

    v = xalloc(sizeof(Vctl));
    v->isintr = true;
    v->irq = irq;
    v->tbdf = tbdf;
    v->f = f;
    v->a = a;
    strncpy(v->name, name, KNAMELEN-1);
    v->name[KNAMELEN-1] = 0;

    ilock(&vctllock);
    vno = arch->intrenable(v); // this should also set v->isr or v->eoi
    if(vno == -1){
        iunlock(&vctllock);
        print("intrenable: couldn't enable irq %d, tbdf 0x%uX for %s\n",
            irq, tbdf, v->name);
        xfree(v);
        return;
    }
    // add_list(vctl[vno], v) and extra check
    if(vctl[vno]){
        if(vctl[vno]->isr != v->isr || vctl[vno]->eoi != v->eoi)
            panic("intrenable: handler: %s %s %#p %#p %#p %#p",
                vctl[vno]->name, v->name,
                vctl[vno]->isr, v->isr, vctl[vno]->eoi, v->eoi);
        v->next = vctl[vno];
    }
    vctl[vno] = v;
    iunlock(&vctllock);
}
@ 
% why use xalloc? because malloc forbidden in interrupt code?

<<function intrdisable(x86)>>=
int
intrdisable(int irq, void (*f)(Ureg *, void *), void *a, int tbdf, char *name)
{
    Vctl **pv, *v;
    int vno;

    /*
     * For now, none of this will work with the APIC code,
     * there is no mapping between irq and vector as the IRQ
     * is pretty meaningless.
     */
    if(arch->intrvecno == nil)
        return -1;
    vno = arch->intrvecno(irq);
    ilock(&vctllock);
    pv = &vctl[vno];
    while (*pv &&
          ((*pv)->irq != irq || (*pv)->tbdf != tbdf || (*pv)->f != f || (*pv)->a != a ||
           strcmp((*pv)->name, name)))
        pv = &((*pv)->next);
    assert(*pv);

    v = *pv;
    *pv = (*pv)->next;  /* Link out the entry */

    if(vctl[vno] == nil && arch->intrdisable != nil)
        arch->intrdisable(irq);
    iunlock(&vctllock);
    xfree(v);
    return 0;
}
@ 

%\section{Interrupt controller [[i8259]]}

<<[[PCArch]] interrupt methods fields(x86)>>=
void  (*intrinit)(void);
int (*intrenable)(Vctl*);
int (*intrvecno)(int);
int (*intrdisable)(int);
void  (*introff)(void);
void  (*intron)(void);
@

<<[[archgeneric]] interrupt methods(x86)>>=
.intrinit=  i8259init,
.intrenable=    i8259enable,
.intrvecno= i8259vecno,
.intrdisable=   i8259disable,
.intron=    i8259on,
.introff=   i8259off,
@

<<function i8259init(x86)>>=
void
i8259init(void)
{
    int x;

    ioalloc(Int0ctl, 2, 0, "i8259.0");
    ioalloc(Int1ctl, 2, 0, "i8259.1");
    ilock(&i8259lock);

    /*
     *  Set up the first 8259 interrupt processor.
     *  Make 8259 interrupts start at CPU vector VectorPIC.
     *  Set the 8259 as master with edge triggered
     *  input with fully nested interrupts.
     */
    outb(Int0ctl, (1<<4)|(0<<3)|(1<<0));    /* ICW1 - master, edge triggered,
                           ICW4 will be sent */
    outb(Int0aux, VectorPIC);       /* ICW2 - interrupt vector offset */
    outb(Int0aux, 0x04);            /* ICW3 - have slave on level 2 */
    outb(Int0aux, 0x01);            /* ICW4 - 8086 mode, not buffered */

    /*
     *  Set up the second 8259 interrupt processor.
     *  Make 8259 interrupts start at CPU vector VectorPIC+8.
     *  Set the 8259 as slave with edge triggered
     *  input with fully nested interrupts.
     */
    outb(Int1ctl, (1<<4)|(0<<3)|(1<<0));    /* ICW1 - master, edge triggered,
                           ICW4 will be sent */
    outb(Int1aux, VectorPIC+8);     /* ICW2 - interrupt vector offset */
    outb(Int1aux, 0x02);            /* ICW3 - I am a slave on level 2 */
    outb(Int1aux, 0x01);            /* ICW4 - 8086 mode, not buffered */
    outb(Int1aux, (i8259mask>>8) & 0xFF);

    /*
     *  pass #2 8259 interrupts to #1
     */
    i8259mask &= ~0x04;
    outb(Int0aux, i8259mask & 0xFF);

    /*
     * Set Ocw3 to return the ISR when ctl read.
     * After initialisation status read is set to IRR.
     * Read IRR first to possibly deassert an outstanding
     * interrupt.
     */
    inb(Int0ctl);
    outb(Int0ctl, Ocw3|0x03);
    inb(Int1ctl);
    outb(Int1ctl, Ocw3|0x03);

    /*
     * Check for Edge/Level register.
     * This check may not work for all chipsets.
     * First try a non-intrusive test - the bits for
     * IRQs 13, 8, 2, 1 and 0 must be edge (0). If
     * that's OK try a R/W test.
     */
    x = (inb(Elcr2)<<8)|inb(Elcr1);
    if(!(x & 0x2107)){
        outb(Elcr1, 0);
        if(inb(Elcr1) == 0){
            outb(Elcr1, 0x20);
            if(inb(Elcr1) == 0x20)
                i8259elcr = x;
            outb(Elcr1, x & 0xFF);
            print("ELCR: %4.4uX\n", i8259elcr);
        }
    }
    iunlock(&i8259lock);
}
@
% >> >> >> >> >> >>

<<global i8259lock(x86)>>=
static Lock i8259lock;
@

<<function i8259isr(x86)>>=
int
i8259isr(int vno)
{
    int irq, isr;

    if(vno < VectorPIC || vno > VectorPIC+MaxIrqPIC)
        return 0;
    irq = vno-VectorPIC;

    /*
     *  tell the 8259 that we're done with the
     *  highest level interrupt (interrupts are still
     *  off at this point)
     */
    ilock(&i8259lock);
    isr = inb(Int0ctl);
    outb(Int0ctl, EOI);
    if(irq >= 8){
        isr |= inb(Int1ctl)<<8;
        outb(Int1ctl, EOI);
    }
    iunlock(&i8259lock);

    return isr & (1<<irq);
}
@
% >> >>

<<function i8259enable(x86)>>=
int
i8259enable(Vctl* v)
{
    int irq, irqbit;

    /*
     * Given an IRQ, enable the corresponding interrupt in the i8259
     * and return the vector to be used. The i8259 is set to use a fixed
     * range of vectors starting at VectorPIC.
     */
    irq = v->irq;
    if(irq < 0 || irq > MaxIrqPIC){
        print("i8259enable: irq %d out of range\n", irq);
        return -1;
    }
    irqbit = 1<<irq;

    ilock(&i8259lock);
    if(!(i8259mask & irqbit) && !(i8259elcr & irqbit)){
        print("i8259enable: irq %d shared but not level\n", irq);
        iunlock(&i8259lock);
        return -1;
    }
    i8259mask &= ~irqbit;
    if(irq < 8)
        outb(Int0aux, i8259mask & 0xFF);
    else
        outb(Int1aux, (i8259mask>>8) & 0xFF);

    if(i8259elcr & irqbit)
        v->eoi = i8259isr;
    else
        v->isr = i8259isr;
    iunlock(&i8259lock);

    return VectorPIC+irq;
}
@

<<function i8259vecno(x86)>>=
int
i8259vecno(int irq)
{
    return VectorPIC+irq;
}
@

<<function i8259disable(x86)>>=
int
i8259disable(int irq)
{
    int irqbit;

    /*
     * Given an IRQ, disable the corresponding interrupt
     * in the 8259.
     */
    if(irq < 0 || irq > MaxIrqPIC){
        print("i8259disable: irq %d out of range\n", irq);
        return -1;
    }
    irqbit = 1<<irq;

    ilock(&i8259lock);
    if(!(i8259mask & irqbit)){
        i8259mask |= irqbit;
        if(irq < 8)
            outb(Int0aux, i8259mask & 0xFF);
        else
            outb(Int1aux, (i8259mask>>8) & 0xFF);
    }
    iunlock(&i8259lock);
    return 0;
}
@

<<function i8259on(x86)>>=
void
i8259on(void)
{
    outb(Int0aux, i8259mask&0xFF);
    outb(Int1aux, (i8259mask>>8)&0xFF);
}
@


<<function i8259off(x86)>>=
void
i8259off(void)
{
    outb(Int0aux, 0xFF);
    outb(Int1aux, 0xFF);
}
@


\section{Interrupt [[vectortable]] and [[idt]] (x86)}

<<constant IDTADDR(x86)>>=
#define IDTADDR   (KZERO+0x10800)   /* idt */
@
% why 800? why not 0x10000?

<<global vectortable(x86)>>=
TEXT vectortable(SB), $0
        CALL _strayintr(SB); BYTE $0x00         /* divide error */
        CALL _strayintr(SB); BYTE $0x01         /* debug exception */
        CALL _strayintr(SB); BYTE $0x02         /* NMI interrupt */
        CALL _strayintr(SB); BYTE $0x03         /* breakpoint */
        CALL _strayintr(SB); BYTE $0x04         /* overflow */
        CALL _strayintr(SB); BYTE $0x05         /* bound */
        CALL _strayintr(SB); BYTE $0x06         /* invalid opcode */
        CALL _strayintr(SB); BYTE $0x07         /* no coprocessor available */
        CALL _strayintrx(SB); BYTE $0x08        /* double fault */
        CALL _strayintr(SB); BYTE $0x09         /* coprocessor segment overflow */
        CALL _strayintrx(SB); BYTE $0x0A        /* invalid TSS */
        CALL _strayintrx(SB); BYTE $0x0B        /* segment not available */
        CALL _strayintrx(SB); BYTE $0x0C        /* stack exception */
        CALL _strayintrx(SB); BYTE $0x0D        /* general protection error */
        CALL _strayintrx(SB); BYTE $0x0E        /* page fault */
        CALL _strayintr(SB); BYTE $0x0F         /*  */
        CALL _strayintr(SB); BYTE $0x10         /* coprocessor error */
        CALL _strayintrx(SB); BYTE $0x11        /* alignment check */
        CALL _strayintr(SB); BYTE $0x12         /* machine check */
        CALL _strayintr(SB); BYTE $0x13
        CALL _strayintr(SB); BYTE $0x14
        CALL _strayintr(SB); BYTE $0x15
        CALL _strayintr(SB); BYTE $0x16
        CALL _strayintr(SB); BYTE $0x17
        CALL _strayintr(SB); BYTE $0x18
        CALL _strayintr(SB); BYTE $0x19
        CALL _strayintr(SB); BYTE $0x1A
        CALL _strayintr(SB); BYTE $0x1B
        CALL _strayintr(SB); BYTE $0x1C
        CALL _strayintr(SB); BYTE $0x1D
        CALL _strayintr(SB); BYTE $0x1E
        CALL _strayintr(SB); BYTE $0x1F
        CALL _strayintr(SB); BYTE $0x20         /* VectorLAPIC */
        CALL _strayintr(SB); BYTE $0x21
        CALL _strayintr(SB); BYTE $0x22
        CALL _strayintr(SB); BYTE $0x23
        CALL _strayintr(SB); BYTE $0x24
        CALL _strayintr(SB); BYTE $0x25
        CALL _strayintr(SB); BYTE $0x26
        CALL _strayintr(SB); BYTE $0x27
        CALL _strayintr(SB); BYTE $0x28
        CALL _strayintr(SB); BYTE $0x29
        CALL _strayintr(SB); BYTE $0x2A
        CALL _strayintr(SB); BYTE $0x2B
        CALL _strayintr(SB); BYTE $0x2C
        CALL _strayintr(SB); BYTE $0x2D
        CALL _strayintr(SB); BYTE $0x2E
        CALL _strayintr(SB); BYTE $0x2F
        CALL _strayintr(SB); BYTE $0x30
        CALL _strayintr(SB); BYTE $0x31
        CALL _strayintr(SB); BYTE $0x32
        CALL _strayintr(SB); BYTE $0x33
        CALL _strayintr(SB); BYTE $0x34
        CALL _strayintr(SB); BYTE $0x35
        CALL _strayintr(SB); BYTE $0x36
        CALL _strayintr(SB); BYTE $0x37
        CALL _strayintr(SB); BYTE $0x38
        CALL _strayintr(SB); BYTE $0x39
        CALL _strayintr(SB); BYTE $0x3A
        CALL _strayintr(SB); BYTE $0x3B
        CALL _strayintr(SB); BYTE $0x3C
        CALL _strayintr(SB); BYTE $0x3D
        CALL _strayintr(SB); BYTE $0x3E
        CALL _strayintr(SB); BYTE $0x3F
        CALL _syscallintr(SB); BYTE $0x40       /* VectorSYSCALL */
        CALL _strayintr(SB); BYTE $0x41
        CALL _strayintr(SB); BYTE $0x42
        CALL _strayintr(SB); BYTE $0x43
        CALL _strayintr(SB); BYTE $0x44
        CALL _strayintr(SB); BYTE $0x45
        CALL _strayintr(SB); BYTE $0x46
        CALL _strayintr(SB); BYTE $0x47
        CALL _strayintr(SB); BYTE $0x48
        CALL _strayintr(SB); BYTE $0x49
        CALL _strayintr(SB); BYTE $0x4A
        CALL _strayintr(SB); BYTE $0x4B
        CALL _strayintr(SB); BYTE $0x4C
        CALL _strayintr(SB); BYTE $0x4D
        CALL _strayintr(SB); BYTE $0x4E
        CALL _strayintr(SB); BYTE $0x4F
        CALL _strayintr(SB); BYTE $0x50
        CALL _strayintr(SB); BYTE $0x51
        CALL _strayintr(SB); BYTE $0x52
        CALL _strayintr(SB); BYTE $0x53
        CALL _strayintr(SB); BYTE $0x54
        CALL _strayintr(SB); BYTE $0x55
        CALL _strayintr(SB); BYTE $0x56
        CALL _strayintr(SB); BYTE $0x57
        CALL _strayintr(SB); BYTE $0x58
        CALL _strayintr(SB); BYTE $0x59
        CALL _strayintr(SB); BYTE $0x5A
        CALL _strayintr(SB); BYTE $0x5B
        CALL _strayintr(SB); BYTE $0x5C
        CALL _strayintr(SB); BYTE $0x5D
        CALL _strayintr(SB); BYTE $0x5E
        CALL _strayintr(SB); BYTE $0x5F
        CALL _strayintr(SB); BYTE $0x60
        CALL _strayintr(SB); BYTE $0x61
        CALL _strayintr(SB); BYTE $0x62
        CALL _strayintr(SB); BYTE $0x63
        CALL _strayintr(SB); BYTE $0x64
        CALL _strayintr(SB); BYTE $0x65
        CALL _strayintr(SB); BYTE $0x66
        CALL _strayintr(SB); BYTE $0x67
        CALL _strayintr(SB); BYTE $0x68
        CALL _strayintr(SB); BYTE $0x69
        CALL _strayintr(SB); BYTE $0x6A
        CALL _strayintr(SB); BYTE $0x6B
        CALL _strayintr(SB); BYTE $0x6C
        CALL _strayintr(SB); BYTE $0x6D
        CALL _strayintr(SB); BYTE $0x6E
        CALL _strayintr(SB); BYTE $0x6F
        CALL _strayintr(SB); BYTE $0x70
        CALL _strayintr(SB); BYTE $0x71
        CALL _strayintr(SB); BYTE $0x72
        CALL _strayintr(SB); BYTE $0x73
        CALL _strayintr(SB); BYTE $0x74
        CALL _strayintr(SB); BYTE $0x75
        CALL _strayintr(SB); BYTE $0x76
        CALL _strayintr(SB); BYTE $0x77
        CALL _strayintr(SB); BYTE $0x78
        CALL _strayintr(SB); BYTE $0x79
        CALL _strayintr(SB); BYTE $0x7A
        CALL _strayintr(SB); BYTE $0x7B
        CALL _strayintr(SB); BYTE $0x7C
        CALL _strayintr(SB); BYTE $0x7D
        CALL _strayintr(SB); BYTE $0x7E
        CALL _strayintr(SB); BYTE $0x7F
        CALL _strayintr(SB); BYTE $0x80         /* Vector[A]PIC */
        CALL _strayintr(SB); BYTE $0x81
        CALL _strayintr(SB); BYTE $0x82
        CALL _strayintr(SB); BYTE $0x83
        CALL _strayintr(SB); BYTE $0x84
        CALL _strayintr(SB); BYTE $0x85
        CALL _strayintr(SB); BYTE $0x86
        CALL _strayintr(SB); BYTE $0x87
        CALL _strayintr(SB); BYTE $0x88
        CALL _strayintr(SB); BYTE $0x89
        CALL _strayintr(SB); BYTE $0x8A
        CALL _strayintr(SB); BYTE $0x8B
        CALL _strayintr(SB); BYTE $0x8C
        CALL _strayintr(SB); BYTE $0x8D
        CALL _strayintr(SB); BYTE $0x8E
        CALL _strayintr(SB); BYTE $0x8F
        CALL _strayintr(SB); BYTE $0x90
        CALL _strayintr(SB); BYTE $0x91
        CALL _strayintr(SB); BYTE $0x92
        CALL _strayintr(SB); BYTE $0x93
        CALL _strayintr(SB); BYTE $0x94
        CALL _strayintr(SB); BYTE $0x95
        CALL _strayintr(SB); BYTE $0x96
        CALL _strayintr(SB); BYTE $0x97
        CALL _strayintr(SB); BYTE $0x98
        CALL _strayintr(SB); BYTE $0x99
        CALL _strayintr(SB); BYTE $0x9A
        CALL _strayintr(SB); BYTE $0x9B
        CALL _strayintr(SB); BYTE $0x9C
        CALL _strayintr(SB); BYTE $0x9D
        CALL _strayintr(SB); BYTE $0x9E
        CALL _strayintr(SB); BYTE $0x9F
        CALL _strayintr(SB); BYTE $0xA0
        CALL _strayintr(SB); BYTE $0xA1
        CALL _strayintr(SB); BYTE $0xA2
        CALL _strayintr(SB); BYTE $0xA3
        CALL _strayintr(SB); BYTE $0xA4
        CALL _strayintr(SB); BYTE $0xA5
        CALL _strayintr(SB); BYTE $0xA6
        CALL _strayintr(SB); BYTE $0xA7
        CALL _strayintr(SB); BYTE $0xA8
        CALL _strayintr(SB); BYTE $0xA9
        CALL _strayintr(SB); BYTE $0xAA
        CALL _strayintr(SB); BYTE $0xAB
        CALL _strayintr(SB); BYTE $0xAC
        CALL _strayintr(SB); BYTE $0xAD
        CALL _strayintr(SB); BYTE $0xAE
        CALL _strayintr(SB); BYTE $0xAF
        CALL _strayintr(SB); BYTE $0xB0
        CALL _strayintr(SB); BYTE $0xB1
        CALL _strayintr(SB); BYTE $0xB2
        CALL _strayintr(SB); BYTE $0xB3
        CALL _strayintr(SB); BYTE $0xB4
        CALL _strayintr(SB); BYTE $0xB5
        CALL _strayintr(SB); BYTE $0xB6
        CALL _strayintr(SB); BYTE $0xB7
        CALL _strayintr(SB); BYTE $0xB8
        CALL _strayintr(SB); BYTE $0xB9
        CALL _strayintr(SB); BYTE $0xBA
        CALL _strayintr(SB); BYTE $0xBB
        CALL _strayintr(SB); BYTE $0xBC
        CALL _strayintr(SB); BYTE $0xBD
        CALL _strayintr(SB); BYTE $0xBE
        CALL _strayintr(SB); BYTE $0xBF
        CALL _strayintr(SB); BYTE $0xC0
        CALL _strayintr(SB); BYTE $0xC1
        CALL _strayintr(SB); BYTE $0xC2
        CALL _strayintr(SB); BYTE $0xC3
        CALL _strayintr(SB); BYTE $0xC4
        CALL _strayintr(SB); BYTE $0xC5
        CALL _strayintr(SB); BYTE $0xC6
        CALL _strayintr(SB); BYTE $0xC7
        CALL _strayintr(SB); BYTE $0xC8
        CALL _strayintr(SB); BYTE $0xC9
        CALL _strayintr(SB); BYTE $0xCA
        CALL _strayintr(SB); BYTE $0xCB
        CALL _strayintr(SB); BYTE $0xCC
        CALL _strayintr(SB); BYTE $0xCD
        CALL _strayintr(SB); BYTE $0xCE
        CALL _strayintr(SB); BYTE $0xCF
        CALL _strayintr(SB); BYTE $0xD0
        CALL _strayintr(SB); BYTE $0xD1
        CALL _strayintr(SB); BYTE $0xD2
        CALL _strayintr(SB); BYTE $0xD3
        CALL _strayintr(SB); BYTE $0xD4
        CALL _strayintr(SB); BYTE $0xD5
        CALL _strayintr(SB); BYTE $0xD6
        CALL _strayintr(SB); BYTE $0xD7
        CALL _strayintr(SB); BYTE $0xD8
        CALL _strayintr(SB); BYTE $0xD9
        CALL _strayintr(SB); BYTE $0xDA
        CALL _strayintr(SB); BYTE $0xDB
        CALL _strayintr(SB); BYTE $0xDC
        CALL _strayintr(SB); BYTE $0xDD
        CALL _strayintr(SB); BYTE $0xDE
        CALL _strayintr(SB); BYTE $0xDF
        CALL _strayintr(SB); BYTE $0xE0
        CALL _strayintr(SB); BYTE $0xE1
        CALL _strayintr(SB); BYTE $0xE2
        CALL _strayintr(SB); BYTE $0xE3
        CALL _strayintr(SB); BYTE $0xE4
        CALL _strayintr(SB); BYTE $0xE5
        CALL _strayintr(SB); BYTE $0xE6
        CALL _strayintr(SB); BYTE $0xE7
        CALL _strayintr(SB); BYTE $0xE8
        CALL _strayintr(SB); BYTE $0xE9
        CALL _strayintr(SB); BYTE $0xEA
        CALL _strayintr(SB); BYTE $0xEB
        CALL _strayintr(SB); BYTE $0xEC
        CALL _strayintr(SB); BYTE $0xED
        CALL _strayintr(SB); BYTE $0xEE
        CALL _strayintr(SB); BYTE $0xEF
        CALL _strayintr(SB); BYTE $0xF0
        CALL _strayintr(SB); BYTE $0xF1
        CALL _strayintr(SB); BYTE $0xF2
        CALL _strayintr(SB); BYTE $0xF3
        CALL _strayintr(SB); BYTE $0xF4
        CALL _strayintr(SB); BYTE $0xF5
        CALL _strayintr(SB); BYTE $0xF6
        CALL _strayintr(SB); BYTE $0xF7
        CALL _strayintr(SB); BYTE $0xF8
        CALL _strayintr(SB); BYTE $0xF9
        CALL _strayintr(SB); BYTE $0xFA
        CALL _strayintr(SB); BYTE $0xFB
        CALL _strayintr(SB); BYTE $0xFC
        CALL _strayintr(SB); BYTE $0xFD
        CALL _strayintr(SB); BYTE $0xFE
        CALL _strayintr(SB); BYTE $0xFF
@ 
%$
% more a global than a function really. It's essentially an array 
% of function pointer

<<global excname(x86)>>=
static char* excname[32] = {
    "divide error",
    "debug exception",
    "nonmaskable interrupt",
    "breakpoint",
    "overflow",
    "bounds check",
    "invalid opcode",
    "coprocessor not available",
    "double fault",
    "coprocessor segment overrun",
    "invalid TSS",
    "segment not present",
    "stack exception",
    "general protection violation",
    "page fault",
    "15 (reserved)",
    "coprocessor error",
    "alignment check",
    "machine check",
    "19 (reserved)",
    "20 (reserved)",
    "21 (reserved)",
    "22 (reserved)",
    "23 (reserved)",
    "24 (reserved)",
    "25 (reserved)",
    "26 (reserved)",
    "27 (reserved)",
    "28 (reserved)",
    "29 (reserved)",
    "30 (reserved)",
    "31 (reserved)",
};
@ 

\section{[[trap()]] (x86)}

<<function _strayintr(x86)>>=
/*
 * Interrupt/exception handling.
 * Each entry in the vector table calls either _strayintr or _strayintrx depending
 * on whether an error code has been automatically pushed onto the stack
 * (_strayintrx) or not, in which case a dummy entry must be pushed before retrieving
 * the trap type from the vector table entry and placing it on the stack as part
 * of the Ureg structure.
 * The size of each entry in the vector table (6 bytes) is known in trapinit().
 */
TEXT _strayintr(SB), $0
        PUSHL   AX                      /* save AX */
        MOVL    4(SP), AX               /* return PC from vectortable(SB) */
        JMP     intrcommon
@


<<function _strayintrx(x86)>>=
TEXT _strayintrx(SB), $0
        XCHGL   AX, (SP)                /* swap AX with vectortable CALL PC */
intrcommon:
        PUSHL   DS                      /* save DS */
        PUSHL   $(KDSEL)
        POPL    DS                      /* fix up DS */
        MOVBLZX (AX), AX                /* trap type -> AX */
        XCHGL   AX, 4(SP)               /* exchange trap type with saved AX */

        PUSHL   ES                      /* save ES */
        PUSHL   $(KDSEL)
        POPL    ES                      /* fix up ES */

        PUSHL   FS                      /* save the rest of the Ureg struct */
        PUSHL   GS
        PUSHAL

        PUSHL   SP                      /* Ureg* argument to trap */
        CALL    trap(SB)
@ 

% todo: [[Cpu]] debugging fields?
<<[[Cpu]] other fields>>=
int lastintr; // debugging
@
\t actually unused in bcm/! so put in Arch_Cpu?

<<function trap(x86)>>=
/*
 *  All traps come here.  It is slower to have all traps call trap()
 *  rather than directly vectoring the handler. However, this avoids a
 *  lot of code duplication and possible bugs. The only exception is
 *  VectorSYSCALL.
 *  Trap is called with interrupts disabled via interrupt-gates.
 */
//@Scheck: not dead, called from assembly by _strayintr
void trap(Ureg* ureg)
{
    bool clockintr;
    bool user;
    int i, vno;
    char buf[ERRMAX];
    Vctl *ctl, *v;
    Cpu *mach;

    if(!trapinited){
        /* fault386 can give a better error message */
        if(ureg->trap == VectorPF)
            fault386(ureg, nil);
        panic("trap %lud: not ready", ureg->trap);
    }

    cpu->perf.intrts = arch_perfticks();

    user = (ureg->cs & 0xFFFF) == UESEL; // TODO: arch_userureg

    if(user){
        up->dbgreg = ureg;
        <<[[trap()]] adjust kentry when interrupt user>>
    }
    // else if !user, then that means we interrupted a syscall() which should
    // already have done those things, so no need for redundancy

    clockintr = false;

    vno = ureg->trap;
    if(ctl = vctl[vno]){
        if(ctl->isintr){
            cpu->intr++;
            if(vno >= VectorPIC && vno != VectorSYSCALL)
                cpu->lastintr = ctl->irq;
        }

        if(ctl->isr)
            ctl->isr(vno);
        for(v = ctl; v != nil; v = v->next){
            if(v->f) // this can be null?
                v->f(ureg, v->a);
        }
        if(ctl->eoi)
            ctl->eoi(vno);

        if(ctl->isintr){
            intrtime(cpu, vno);

            if(ctl->irq == IrqCLOCK || ctl->irq == IrqTIMER)
                clockintr = true;

            if(up && !clockintr)
                preempt();
        }
    } // no Vctl?
    else if(vno < nelem(excname) && user){
        arch_spllo();
        snprint(buf, sizeof buf, "sys: trap: %s", excname[vno]);
        postnote(up, 1, buf, NDebug);
    }
    else if(vno >= VectorPIC && vno != VectorSYSCALL){
        /*
         * An unknown interrupt.
         * Check for a default IRQ7. This can happen when
         * the IRQ input goes away before the acknowledge.
         * In this case, a 'default IRQ7' is generated, but
         * the corresponding bit in the ISR isn't set.
         * In fact, just ignore all such interrupts.
         */

        /* call all interrupt routines, just in case */
        for(i = VectorPIC; i <= MaxIrqLAPIC; i++){
            ctl = vctl[i];
            if(ctl == nil)
                continue;
            if(!ctl->isintr)
                continue;
            for(v = ctl; v != nil; v = v->next){
                if(v->f)
                    v->f(ureg, v->a);
            }
            /* should we do this? */
            if(ctl->eoi)
                ctl->eoi(i);
        } // remove? ugly?

        /* clear the interrupt */
        i8259isr(vno);
        <<[[trap()]] debugging(x86)>>
        cpu->spuriousintr++;
        if(user)
            kexit(ureg);
        return;
    }else{
        if(vno == VectorNMI){
            /*
             * Don't re-enable, it confuses the crash dumps.
            nmienable();
             */
            iprint("cpu%d: NMI PC %#8.8lux\n", cpu->cpuno, ureg->pc);
            while(cpu->cpuno != 0)
                ;
        }
        dumpregs(ureg);
        if(!user){
            ureg->sp = (ulong)&ureg->sp;
            _dumpstack(ureg);
        }
        if(vno < nelem(excname))
            panic("%s", excname[vno]);
        panic("unknown trap/intr: %d", vno);
    }
    arch_splhi(); // possible arch_spllo() done above

    <<[[trap()]] if delaysched and clockintr>>

    if(user){
        if(up->procctl || up->nnote)
            notify(ureg);
        kexit(ureg);
    }
}
@ 


<<function kexit(x86)>>=
/* go to user space */
void
kexit(Ureg*)
{
    <<[[kexit()]] tos adjustments>>
}
@ 

<<[[trap()]] debugging(x86)>>=
        if(0)print("cpu%d: spurious interrupt %d, last %d\n",
            cpu->cpuno, vno, cpu->lastintr);
        if(0)if(conf.ncpu > 1){
            for(i = 0; i < MAXCPUS; i++){
                if(!(active.cpus & (1<<i)))
                    continue;
                mach = CPUS(i);
                if(cpu->cpuno == mach->cpuno)
                    continue;
                print(" cpu%d: last %d",
                    mach->cpuno, mach->lastintr);
            }
            print("\n");
        }
@


\section{[[syscall()]] (x86)}

<<enum vector cases(x86)>>=
    //!!! int 64, or int 0x40 = way to jump in plan9 OS !!!
    // VectorSYSCALL = 64, in mem.h because used by Assembly too
@

<<function _syscallintr(x86)>>=
/*
 * This is merely _strayintr from l.s optimised to vector
 * to syscall() without going through trap().
 */
TEXT _syscallintr(SB), $0
        PUSHL   $VectorSYSCALL                  /* trap type */

        PUSHL   DS
        PUSHL   ES
        PUSHL   FS
        PUSHL   GS
        PUSHAL
        MOVL    $(KDSEL), AX
        MOVW    AX, DS
        MOVW    AX, ES
        PUSHL   SP
        CALL    syscall(SB)

        POPL    AX
        POPAL
        POPL    GS
        POPL    FS
        POPL    ES
        POPL    DS
        ADDL    $8, SP                          /* pop error code and trap type */
        IRETL
@ 

<<function syscall(x86)>>=
/*
 *  Syscall is called directly from assembler without going through trap().
 */
//@Scheck: not dead, called from assembly by _syscallintr
void syscall(Ureg* ureg)
{
    char *e;
    ulong   sp;
    long    ret;
    int i, s;
    ulong scallnr;
    vlong startns, stopns;

    if((ureg->cs & 0xFFFF) != UESEL) // TODO: use arch_userureg
        panic("syscall: cs 0x%4.4luX", ureg->cs);

    <<[[syscall()]] adjust kentry>>

    cpu->syscall++;
    up->insyscall = true;

    up->pc = ureg->pc;
    up->dbgreg = ureg;
    sp = ureg->usp;

    // syscall number!
    scallnr = ureg->ax;

    <<[[syscall()]] Proc_tracesyscall if, syscall entry(x86)>>

    <<[[syscall()]] fp adjustments if fork(x86)>>
    arch_spllo();

    up->nerrlab = 0;
    ret = -1;

    if(!waserror()){
        if(scallnr >= nsyscall || systab[scallnr] == nil){
            pprint("bad sys call number %lud pc %lux\n",
                scallnr, ureg->pc);
            postnote(up, 1, "sys: bad sys call", NDebug);
            error(Ebadarg);
        }

        if(sp<(USTKTOP-BY2PG) || sp>(USTKTOP-sizeof(Sargs)-BY2WD)) // adjust Tos ?
            validaddr(sp, sizeof(Sargs)+BY2WD, false);

        // copy syscall arguments from user stack to up->sargs
        up->sargs = *((Sargs*)(sp+BY2WD)); // 1 word for? return pc?
        up->psstate = sysctab[scallnr];

        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //IMPORTANT: The actual system call
        ret = systab[scallnr](up->sargs.args);
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        poperror();
    }else{
        /* failure: save the error buffer for errstr */
        e = up->syserrstr;
        up->syserrstr = up->errstr;
        up->errstr = e;
    }

    if(up->nerrlab){
        print("bad errstack [%lud]: %d extra\n", scallnr, up->nerrlab);
        for(i = 0; i < NERR; i++)
            print("sp=%lux pc=%lux\n",
                up->errlab[i].sp, up->errlab[i].pc);
        panic("error stack");
    }

    /*
     *  Put return value in frame.  On the x86 the syscall is
     *  just another trap and the return value from syscall is
     *  ignored.  On other machines the return value is put into
     *  the results register by caller of syscall.
     */
    ureg->ax = ret;

    <<[[syscall()]] Proc_tracesyscall if, syscall exit(x86)>>

    up->insyscall = false;
    up->psstate = nil;

    <<[[syscall()]] call noted()>>
    <<[[syscall()]] call notify()(x86)>>

    <<[[syscall()]] if delaysched(x86)>>
    kexit(ureg);
}
@ 
%        //if(0 && up->pid == 1)
%        //    print("syscall %lud error %s\n", scallnr, up->syserrstr);


<<function userpc(x86)>>=
/*
 *  return the userpc the last exception happened at
 */
ulong
arch_userpc(void)
{
    Ureg *ureg;

    ureg = (Ureg*)up->dbgreg;
    return ureg->pc;
}
@ 

\chapter{Virtual Memory}

% segmentation + pagination on intel, but like most OS, pagination
% offers most of the advantages so less need segmentation once use
% pagination. Will use segmentation only for security to differentiate
% kernel vs user.

% what a system with only segmentation? can do a lot too.

\section{Segmentation and [[gdt]] (x86)}

% see Basic segmentation intialization section too

% use segments mostly for security, for kernel vs user different
% level. CS will contain a selector in gdt (user can't change
% CS?) with gdt describe ring.

% could be an enum, but has to be used from assembly too
<<constant x86 segments>>=
/*
 *  known x86 segments (in GDT) and their selectors
 */
#define NULLSEG 0 /* null segment */
#define KDSEG 1 /* kernel data/stack */
#define KESEG 2 /* kernel executable */ 
#define UDSEG 3 /* user data/stack */
#define UESEG 4 /* user executable */
#define TSSSEG  5 /* task segment */
<<constant x86 other segments>>
#define NGDT    10  /* number of GDT entries required */
@

% will do MOVE XXSEG, AX; MOVE AX, ES
% can't do MOVE AX, CS, for that we do jmp XXSEG:ADDR
% actually will use XXSEL, not XXSEG, see below

% also used for IDT
<<struct Segdesc(x86)>>=
struct Segdesc
{
    ulong d0; // ??
    ulong d1; // ??
};
@ 
% rename, first is size and second is flag

% #define ring0, ring3? instead of 0 and 3 below?


<<constant segment field extractors(x86)>>=
/*
 *  fields in segment descriptors
 */
#define SEGDATA (0x10<<8) /* data/stack segment */
#define SEGEXEC (0x18<<8) /* executable segment */
#define SEGTSS  (0x9<<8)  /* TSS segment */
//#define SEGCG (0x0C<<8) /* call gate */
#define SEGIG (0x0E<<8) /* interrupt gate */
//#define SEGTG (0x0F<<8) /* trap gate */

//#define SEGTYPE (0x1F<<8)

#define SEGP  (1<<15)   /* segment present */

#define SEGPL(x) ((x)<<13)  /* priority level */

#define SEGB  (1<<22)   /* granularity 1==4k (for expand-down) */
#define SEGG  (1<<23)   /* granularity 1==4k (for other) */
//#define SEGE  (1<<10)   /* expand down */

#define SEGW  (1<<9)    /* writable (for data/stack) */
#define SEGR  (1<<9)    /* readable (for code) */

#define SEGD  (1<<22)   /* default 1==32bit (for code) */
@



<<global gdt(x86)>>=
Segdesc gdt[NGDT] =
{
[NULLSEG]   { 0, 0},        /* null descriptor */
[KDSEG]     DATASEGM(0),        /* kernel data/stack */
[KESEG]     EXECSEGM(0),        /* kernel code */
[UDSEG]     DATASEGM(3),        /* user data/stack */
[UESEG]     EXECSEGM(3),        /* user code */
[TSSSEG]    TSSSEGM(0,0),       /* tss segment */
<<[[gdt]] other elements(x86)>>
};
@
% copied in cpu->gdt (at CPU0GDT addresS) in mmuinit0
% speaks about user! as opposed to the more basic tgdt in _setup_segmentation

<<macros xxxSEGM(x86)>>=
/*
 * Simple segment descriptors with no translation.
 */
#define DATASEGM(p) { 0xFFFF, SEGG|SEGB|(0xF<<16)|SEGP|SEGPL(p)|SEGDATA|SEGW }
#define EXECSEGM(p) { 0xFFFF, SEGG|SEGD|(0xF<<16)|SEGP|SEGPL(p)|SEGEXEC|SEGR }
#define TSSSEGM(b,p) { ((b)<<16)|sizeof(Tss),\
                   ((b)&0xFF000000)|(((b)>>16)&0xFF)|SEGTSS|SEGPL(p)|SEGP }
<<macros other xxxSEGM(x86)>>
@
% maybe could define redundant C structure with bitfield to make
% this clearer. kencc supports bitfield? but has to be used from asm too no?





<<[[Cpu]] [[Arch]] other fields(x86)>>=
// array<Segdesc>
Segdesc *gdt;     /* gdt for this processor */
@

% CPU0GDT? and the other? mostly similar, just the 
% TSS change I think. Why use TSS?


<<constant x86 segment selectors>>=
//#define NULLSEL SELECTOR(NULLSEG, SELGDT, 0)
#define KDSEL SELECTOR(KDSEG, SELGDT, 0)
#define KESEL SELECTOR(KESEG, SELGDT, 0)
#define UESEL SELECTOR(UESEG, SELGDT, 3)
#define UDSEL SELECTOR(UDSEG, SELGDT, 3)
#define TSSSEL  SELECTOR(TSSSEG, SELGDT, 0)
<<constant x86 other segment selectors>>
@
% why need that?

<<function userureg(x86)>>=
//#define userureg(ur) (((ur)->cs & 0xFFFF) == UESEL)
int
arch_userureg(Ureg* ur)
{
  return (((ur)->cs & 0xFFFF) == UESEL);
}
@
% ->cs, see Ureg in x86 section in overview chapter
%todo: could be used at more places actually



<<constant SELGDT(x86)>>=
#define SELGDT  (0<<2)  /* selector is in gdt */
@

<<macro SELECTOR(x86)>>=
#define SELECTOR(idx, type, prio) (((idx)<<3) | (type) | (prio))
@

% could put code of tgdt of initialization here? but the real gdt
% is the one above, the tgdt is just used at the beginning


\section{Pagination and [[mmupd]], [[mmupt]] (x86)} 

<<constant PTExxx(x86)>>=
/*
 *  physical MMU
 */
#define PTEVALID  (1<<0)

#define PTEWRITE  (1<<1)
#define PTERONLY  (0<<1)

// x86 specific constants
//#define PTEKERNEL (0<<2)
#define PTEUSER   (1<<2)

#define PTEWT       (1<<3) // Write Through, e.g. VGA memory, mean??
#define PTEUNCACHED (1<<4) // ??
#define PTESIZE   (1<<7) // Big pages (x86 extension)
#define PTEGLOBAL (1<<8) // do not clear from TLB kernel pages (x86 extension)
@

% PTESIZE is used to say this entry actually maps a big page (4Mo, not 4Ko)
% but is used only for vmap mapping


% on tmpmap, tmpunmap. For now assume just alias to XXX
% on arch_kmap, arch_kunmap, VA. Assume alias to XXX.
% see Advanced memory chapter for the actual definitions when
% have machine with lots of memory where MAXKPA is not enough
% and so can't just do KADDR(page->pa) to get a virtual address
% when can access the content of a physical page.


%pd is always cpu->pdproto so a kern_addr.
% returns something created by xpanalloc so return a kern_addr too.
<<function mmuwalk(x86)>>=
/*
 * Walk the page-table pointed to by pd and return a pointer
 * to the entry for virtual address va at the requested level.
 * If the entry is invalid and create isn't requested then bail
 * out early. Otherwise, for the 2nd level walk, allocate a new
 * page-table page and register it in the 1st level.  This is used
 * only to edit kernel mappings, which use pages from kernel memory,
 * so it's okay to use KADDR to look at the tables.
 */
kern_addr2
mmuwalk(kern_addr2 pd, kern_addr va, int level, bool create)
{
    ulong *table;
    void *map;

    table = &pd[PDX(va)];
    if(!(*table & PTEVALID) && create == false)
        return nil;

    switch(level){
    default:
        return nil; //todo: panic? invalid value no?
    case 1:
        return table;
    case 2:
        if(*table & PTESIZE)
            panic("mmuwalk2: va %luX entry %luX", va, *table);
        if(!(*table & PTEVALID)){
            /*
             * Have to call low-level allocator from
             * memory.c if we haven't set up the xalloc
             * tables yet.
             */
            if(didmmuinit)
                map = xspanalloc(BY2PG, BY2PG, 0);
            else
                map = rampage();  //when called from meminit()
            if(map == nil)
                panic("mmuwalk xspanalloc failed");
            *table = PADDR(map)|PTEWRITE|PTEVALID;
        }
        table = KADDR(PPN(*table));
        return &table[PTX(va)];
    }
}
@
% s/table/pde_or_pte/?

<<[[Cpu]] [[Arch]] other fields(x86)>>=
kern_addr2   pdproto;      /* page directory base for this processor (va) */
@
% this pd is super important!! see arch_mmuswitch, he's the one
% that will map specially the CPUADDR for each CPU!
% it is actually a prototype that is copied in the mmupagedir of each
% new process

<<[[Cpu]] [[Arch]] other fields(x86)>>=
Page* mmupdpool;
int mmupdcnt;
@
%// TODO: have a Arch_CpuMMU like in bcm/
% mv later? when used? opti to not wait for newpage()

% pointers in kern_addr? no! but the page->pa there is real mem.
<<[[Proc]] [[Arch]] memory fields(x86)>>=
Page* mmupd;     /* page directory base */
@

<<[[Proc]] [[Arch]] memory fields(x86)>>=
// type? list<ref<?? > >
Page* mmufree;    /* unused page table pages */
Page* mmuused;    /* used page table pages */
@
% rename! mmupt_used, mmupt_free?
% so mmu release should release mmupd and those pages

<<function upallocmmupd(x86)>>=
/*
 * Allocate and install pd for the current process.
 */
static void
upallocmmupd(void)
{
    int s;
    kern_addr2 mmupd;
    Page *page;
    
    if(up->mmupd != nil)
        return;
    page = mmupdalloc();
    s = arch_splhi();
    if(up->mmupd != nil){
        /*
         * Perhaps we got an interrupt while
         * mmupdalloc was sleeping and that
         * interrupt allocated an mmupd?
         * Seems unlikely.
         */
        mmupdfree(up, page);
        arch_splx(s);
        return;
    }
    mmupd = tmpmap(page);
    mmupd[PDX(CPUADDR)] = cpu->pdproto[PDX(CPUADDR)]; // for up
    tmpunmap(mmupd);
    up->mmupd = page;
    putcr3(up->mmupd->pa); //!!!! bootstrap! putcr3 take a PA of course
    arch_splx(s);
}
@


%ctor
<<function mmupdalloc(x86)>>=
/*
 * Allocate a new page for a page directory.
 * We keep a small cache of pre-initialized
 * page directories in each cpu (see mmupdfree).
 */
static Page*
mmupdalloc(void)
{
    int s;
    Page *page;
    kern_addr2 mmupd;

    s = arch_splhi();
    cpu->mmupdalloc++;
    if(cpu->mmupdpool == nil){
        arch_spllo();
        page = newpage(false, nil, nilptr);
        arch_splhi();
        mmupd = tmpmap(page);
        memmove(mmupd, cpu->pdproto, BY2PG);
        <<[[mmupdalloc()]] vpt adjustments(x86)>>
        tmpunmap(mmupd);
    }else{
        page = cpu->mmupdpool;
        cpu->mmupdpool = page->next;
        cpu->mmupdcnt--;
    }
    arch_splx(s);
    return page;
}
@
% why not using kernel memory for that? after all use kernel memory
% for Segment and Pagetable
% how sure what is put back in the mmupdpool has virgin mapping?
% because of arch_mmurelease?


%dtor
<<function mmupdfree(x86)>>=
static void
mmupdfree(Proc *proc, Page *page)
{
    if(arch_islo())
        panic("mmupdfree: arch_islo");
    cpu->mmupdfree++;
    if(cpu->mmupdcnt >= 10){ // 10??? keep small cache of mmupd page, but not too big, don't want to eat too much memory for that.
        page->next = proc->mmufree;
        proc->mmufree = page;
    }else{
        page->next = cpu->mmupdpool;
        cpu->mmupdpool = page;
        cpu->mmupdcnt++;
    }
}
@
% but the Page is a pd that have all entries correct? who initialize it?
% it has the good entries for the mapping of the kernel, but before KZERO?
% assumes have called mmuptefree before I think in arch_mmurelease





%dtor
<<function mmuptefree(x86)>>=
/*
 * A user-space memory segment has been deleted, or the
 * process is exiting.  Clear all the pde entries for user-space
 * memory mappings and device mappings.  Any entries that
 * are needed will be paged back in as necessary.
 */
static void
mmuptefree(Proc* proc)
{
    int s;
    kern_addr2 mmupd;
    Page **last, *page;

    if(proc->mmupd == nil || proc->mmuused == nil)
        return; // panic? bug to be called with that?

    s = arch_splhi();
    mmupd = tmpmap(proc->mmupd);
    last = &proc->mmuused;
    for(page = *last; page; page = page->next){
        mmupd[page->daddr] = 0; //???? use daddr??
        last = &page->next;
    }
    tmpunmap(mmupd);
    arch_splx(s);
    *last = proc->mmufree;
    proc->mmufree = proc->mmuused;
    proc->mmuused = nil;
}
@


<<function mmurelease(x86)>>=
/*
 * Release any pages allocated for a page directory or page-tables
 * for this process:
 *   switch to the prototype pd for this processor (cpu->pdproto);
 *   call mmuptefree() to place all pages used for page-tables (proc->mmuused)
 *   onto the process' free list (proc->mmufree). This has the side-effect of
 *   cleaning any user entries in the pdb (proc->mmupd);
 *   if there's a pd put it in the cache of pre-initialised pd's
 *   for this processor (cpu->mmupdpool) or on the process' free list;
 *   finally, place any pages freed back into the free pool (palloc).
 * This routine is only called from schedinit() with palloc locked.
 */
void
arch_mmurelease(Proc* proc)
{
    Page *page, *next;

    if(arch_islo())
        panic("arch_mmurelease: arch_islo");
    taskswitch(PADDR(cpu->pdproto), (ulong)cpu + BY2PG);


    <<[[mmurelease()]] handle kmaptable(x86)>>

    if(proc->mmupd){
        mmuptefree(proc);
        mmupdfree(proc, proc->mmupd);
        proc->mmupd = nil;
    }
    for(page = proc->mmufree; page; page = next){
        next = page->next;
        if(--page->ref)
            panic("arch_mmurelease: page->ref %d", page->ref);
        pagechainhead(page);
    }
    if(proc->mmufree && palloc.freememr.p)
        wakeup(&palloc.freememr);
    proc->mmufree = nil;
}
@



% there are called to newpage, so use user memory for pagedir/pagetable
% of process, which kinda make sense, but is it dangerous? can those
% pages containing pagedir/pagetable data be swapped out? No because
% the swapping procedure iterate over the pages used by segments of
% processes, not on pages in Proc->mmupd or Proc->mmused. So it's safe.

<<function flushmmu(x86)>>=
/*
 * Flush all the user-space and device-mapping mmu info
 * for this process, because something has been deleted.
 * It will be paged back in on demand.
 */
void
arch_flushmmu(void)
{
    int s;

    s = arch_splhi();
    up->newtlb = true;
    arch_mmuswitch(up);
    arch_splx(s);
}
@


<<function flushpg(x86)>>=
/*
 * Flush a single page mapping from the tlb.
 */
void
flushpg(virt_addr va)
{
    if(X86FAMILY(cpu->cpuidax) >= 4)
        invlpg(va);
    else
        putcr3(getcr3());
}
@
% invalidate everything if does not have the feature

\section{Page fault (x86)}

% trap -> <>
<<function fault386>>=
static void
fault386(Ureg* ureg, void*)
{
    virt_addr addr; 
    bool read, insyscall, user;
    int n; // ret_code
    char buf[ERRMAX];

    addr = getcr2(); // faulting va
    read = !(ureg->ecode & 2);
    user = (ureg->cs & 0xFFFF) == UESEL;

    if(!user){
        if(vmapsync(addr))
            return;
        if(addr >= USTKTOP)
            panic("kernel fault: bad address pc=0x%.8lux addr=0x%.8lux", ureg->pc, addr);
        if(up == nil)
            panic("kernel fault: no user process pc=0x%.8lux addr=0x%.8lux", ureg->pc, addr);
    }
    if(up == nil)
        panic("user fault: up=0 pc=0x%.8lux addr=0x%.8lux", ureg->pc, addr);

    insyscall = up->insyscall;
    up->insyscall = true; // really?

    n = fault(addr, read); // portable code

    if(n < 0){
        if(!user){
            dumpregs(ureg);
            panic("fault: 0x%lux", addr);
        }
        checkpages();
        //checkfault(addr, ureg->pc);
        snprint(buf, sizeof buf, "sys: trap: fault %s addr=0x%lux",
            read ? "read" : "write", addr);
        postnote(up, 1, buf, NDebug);
    }
    up->insyscall = insyscall;
}
@ 

% this is the fundamental operation, put earlier?
% can some of the code here generate itself a fault?
<<function putmmu(x86)>>=
/*
 * Update the mmu in response to a user fault.  pa may have PTEWRITE set.
 */
void
arch_putmmu(virt_addr va, ulong mmupte, Page*)
{
    int old;
    Page *page;
    kern_addr2 mmupd;
    kern_addr2 mmupt;

    if(up->mmupd == nil)
        upallocmmupd();
    <<[[putmmu()]] adjustments(x86)>>
}
@

<<[[putmmu()]] adjustments(x86)>>=
// pad's code for simplified virtual memory, no VPT
mmupd = KADDR(up->mmupd->pa);
if(!(mmupd[PDX(va)]&PTEVALID)) {
    if(up->mmufree == nil){
        arch_spllo();
        page = newpage(false, nil, nilptr);
        arch_splhi();
    }
    else{
        page = up->mmufree;
        up->mmufree = page->next;
    }
    mmupd[PDX(va)] = PPN(page->pa)|PTEUSER|PTEWRITE|PTEVALID;
    mmupt = KADDR(page->pa);
    memset(mmupt, 0, BY2PG);
    page->daddr = PDX(va); // ???
    page->next = up->mmuused;
    up->mmuused = page;
}
mmupt = KADDR(PPN(mmupd[PDX(va)]));
old = mmupt[PTX(va)];
mmupt[PTX(va)] = mmupte|PTEUSER|PTEVALID;

if(old&PTEVALID)
    flushpg(va);
if(getcr3() != up->mmupd->pa)
     print("bad cr3 %#.8lux %#.8lux\n", getcr3(), up->mmupd->pa);
@


<<function checkmmu(x86)>>=
/*
 * Double-check the user MMU.
 * Error checking only.
 */
void
arch_checkmmu(virt_addr va, phys_addr pa)
{
    if(up->mmupd == nil)
        return;
   USED(va); USED(pa);
    <<[[checkmmu()]] pd at pt check(x86)>>
}
@

<<function checkpages>>=
void
checkpages(void)
{
    int checked;
    ulong addr, off;
    Pagetable *p;
    Page *pg;
    Segment **sp, **ep, *s;
    
    if(up == nil)
        return;

    checked = 0;
    // foreach(up->seg)
    for(sp=up->seg, ep=&up->seg[NSEG]; sp<ep; sp++){
        s = *sp;
        if(s == nil)
            continue;
        qlock(&s->lk);
        for(addr=s->base; addr<s->top; addr+=BY2PG){
            off = addr - s->base;
            p = s->pagedir[off/PAGETABMAPMEM];
            if(p == nil)
                continue;
            pg = p->pagetab[(off&(PAGETABMAPMEM-1))/BY2PG];
            if(pg == nil || pagedout(pg))
                continue;
            arch_checkmmu(addr, pg->pa);
            checked++;
        }
        qunlock(&s->lk);
    }
    print("%ld %s: checked %d page table entries\n", up->pid, up->text, checked);
}
@


\chapter{Advanced Topics}

\section{Floating point (x86)}

\section{Advanced virtual memory (x86)}

\part{Files}

\section{[[include/386/]]}

\subsection*{[[include/386/ureg.h]]}

\section{[[arch/386/]]}

\subsection*{[[arch/386/dat_arch.h]]}

<<enum arch_constants(x86)>>=
enum arch_constants
{
    /* cpuid instruction result register bits */
    // this is actually only used in 386/ code. 
    /* dx */
    Fpuonchip = 1<<0,
    Vmex  = 1<<1,   /* virtual-mode extensions */
    Pse = 1<<3,   /* page size extensions */
    Tsc = 1<<4,   /* time-stamp counter */
    Cpumsr  = 1<<5,   /* model-specific registers, rdmsr/wrmsr */
    Mce = 1<<7,   /* machine-check exception */
    Mtrr  = 1<<12,  /* memory-type range regs.  */
    Pge = 1<<13,  /* page global extension */
    Fxsr  = 1<<24,  /* have SSE FXSAVE/FXRSTOR */
    Sse2  = 1<<26,  /* thus mfence & lfence instr.s */
};
@

%  //  MAXCRYPT =  127,
%//  Pae = 1<<6,   /* physical-addr extensions */
%//  Cmpxchg8b = 1<<8,
%//  Cpuapic = 1<<9,
%//  Pse2  = 1<<17,  /* more page size extensions */
%//  Clflush = 1<<19,
%//  Mmx = 1<<23,
%//  Sse = 1<<25,  /* thus sfence instr. */




<<struct IOMap(x86)>>=
struct IOMap
{
    char    tag[13];
    ulong   start;
    ulong   end;

    // extra
    // list<ref<IOMap>> of Iomapalloc.free
    IOMap   *next;

    bool    reserved;
};
@ 
% next used to have to be at the first field of IOMap?! otherwise get fault??


<<struct Iomapalloc(x86)>>=
struct Iomapalloc
{
    // ??
    IOMap   *m;

    // list<ref<IOMap>> (next = IOMap.next)
    IOMap   *free;
    // array<IOMAP> pool
    IOMap   maps[32];   /* some initial free maps */

    // extra
    Lock;
    QLock   ql;     /* lock for reading map */
};
@ 


<<struct X86type(x86)>>=
struct X86type {
    int family;
    int model;
    int aalcycles;
    char*   name;
};
@ 




<<arch/386/dat_arch.h>>=

<<enum arch_constants(x86)>>

//*****************************************************************************
// IO Map
//*****************************************************************************

// All the ref<IOMap> here are references to IOMap in the array<IOMap> of 
// Iomapalloc.maps (pool allocator)

<<struct IOMap(x86)>>

<<struct Iomapalloc(x86)>>

// array<IMap> alloced statically in maps
extern struct Iomapalloc iomap;

//*****************************************************************************
// PC Architecture hooks (interrupts, clocks, power, reset)
//*****************************************************************************

/*
 *  routines for things outside the PC model, like power management
 */
<<struct PCArch(x86)>>
extern PCArch *arch;      /* PC architecture */
extern PCArch archgeneric;

//*****************************************************************************
// Co processor
//*****************************************************************************

<<struct FPstate(x86)>>

<<struct FPssestate(x86)>>

<<struct  SFPssestate(x86)>>

//*****************************************************************************
// Misc
//*****************************************************************************

struct BIOS32ci {   /* BIOS32 Calling Interface */
  u32int  eax;
  u32int  ebx;
  u32int  ecx;
  u32int  edx;
  u32int  esi;
  u32int  edi;
};


// used to be in devrtc.c, but to remove some backward deps had to be here
// it's really used only by nvram.c and devrtc.c
/*
 *  real time clock and non-volatile ram
 */

enum {
    Paddr=      0x70,   /* address port */
    PdataPort=      0x71,   /* data port */
};
extern Lock nvrtlock;

<<struct X86type(x86)>>

extern X86type *cputype;
@


\subsection*{[[arch/386/arch.c]]}
%pad: I created this file to remove some backward deps
% some stuff was in devarch.c

<<arch/386/arch.c>>=
<<kernel basic includes>>

<<global arch(x86)>>

<<hook fprestore and fpsave(x86)>>

int (*_pcmspecial)(char*, ISAConf*);
//void (*_pcmspecialclose)(int); // useful if use pccard device driver
/*
 *  call either the pcmcia or pccard device setup
 */
int
pcmspecial(char *idstr, ISAConf *isa)
{
    return (_pcmspecial != nil)? _pcmspecial(idstr, isa): -1;
}

<<function cpuidprint(x86)>>

@

%/*
% *  call either the pcmcia or pccard device teardown
% */
%//void
%//pcmspecialclose(int a)
%//{
%//  if (_pcmspecialclose != nil)
%//      _pcmspecialclose(a);
%//}

\section{[[concurrency/386/]]}

\subsection*{[[concurrency/386/concurrency.c]]}
%pad: I created this file

<<concurrency.c>>=
<<kernel basic includes>>

<<function cmpswap and default implementation(x86)>>

/*
 * On a uniprocessor, you'd think that coherence could be nop,
 * but it can't.  We still need a barrier when using coherence() in
 * device drivers.
 *
 * On VMware, it's safe (and a huge win) to set this to nop.
 * Aux/vmware does this via the #P/archctl file.
 */
//now in globals.c: void (*coherence)(void) = nop;
@

\subsection*{[[concurrency/386/l_concurrency.s]]}
%pad: I created this file, was in l.s before

<<l_concurrency.s>>=
#include "mem.h"

<<function splhi(x86)>>

<<function spllo(x86)>>

<<function splx(x86)>>

<<function islo(x86)>>

/*
 * Test-And-Set.
 */
<<function tas(x86)>>

<<function _xinc(x86)>>

<<function _xdec(x86)>>

// cmpswap

// cmpswap386 is in concurrenc.c
        
TEXT cmpswap486(SB), $0
        MOVL    addr+0(FP), BX
        MOVL    old+4(FP), AX
        MOVL    new+8(FP), CX
        LOCK
        BYTE $0x0F; BYTE $0xB1; BYTE $0x0B      /* CMPXCHGL CX, (BX) */
        JNZ didnt
        MOVL    $1, AX
        RET
didnt:
        XORL    AX,AX
        RET

// coherence

#define CPUID           BYTE $0x0F; BYTE $0xA2  /* CPUID, argument in AX */

<<function mb386(x86)>>

<<function mb586(x86)>>

<<function mfence(x86)>>

@
%$

%dead:
%  TEXT sfence(SB), $0
%          BYTE $0x0f
%          BYTE $0xae
%          BYTE $0xf8
%          RET
%  
%  TEXT lfence(SB), $0
%          BYTE $0x0f
%          BYTE $0xae
%          BYTE $0xe8
%          RET


\section{[[core/386/]]}

\subsection*{[[core/386/dat.h]]}

% in Kernel.nw

<<enum misc_constants(x86)>>=
enum misc_constants
{
    <<constant KMESGSIZE(x86)>>
    <<constant STAGESIZE(x86)>>
};
@
%old: some constants are now defined in dat.h not portdat.h because
% they were defined via some ifdef and each port could override them.


\subsection*{[[core/386/dat_core.h]]}

<<core/386/dat_core.h>>=

//*****************************************************************************
// Cpu extension
//*****************************************************************************

<<struct Tss(x86)>>

<<struct Segdesc(x86)>>

<<struct ArchCpu(x86)>>

//*****************************************************************************
// Conf extension?
//*****************************************************************************

@


\subsection*{[[core/386/dat_forward.h]]}


\ifallcode
<<dat_forward.h pragma(x86)>>=
#pragma incomplete BIOS32si
#pragma incomplete Pcidev
#pragma incomplete Ureg
@
\fi

\ifallcode
<<core/386/dat_forward.h>>=
typedef union Arch_FPsave  Arch_FPsave;
typedef struct Arch_Proc Arch_Proc;

typedef struct BIOS32si BIOS32si;
typedef struct BIOS32ci BIOS32ci;
typedef struct FPssestate FPssestate;
typedef struct SFPssestate SFPssestate;
typedef struct FPstate  FPstate;
typedef struct MMU  MMU;
typedef struct PCArch PCArch;
typedef struct Pcidev Pcidev;
typedef struct PCMmap PCMmap;
typedef struct PCMslot  PCMslot;
typedef struct Segdesc  Segdesc;

typedef struct Ureg Ureg;
typedef struct Vctl Vctl;

// was not there, but seems more consistent
typedef struct Tss Tss;
typedef struct IOMap IOMap;
typedef struct X86type X86type;
typedef struct I8253 I8253;

// needed in arch specific stuff
typedef struct Page Page;
typedef struct Proc Proc;
typedef struct Lock Lock;

// was in io.h
typedef struct Pcisiz Pcisiz;
typedef struct Pcidev Pcidev;
typedef struct PCMconftab PCMconftab;

// was in mp.h
typedef struct PCMP PCMP;
typedef struct _MP_ _MP_;
typedef struct PCMPprocessor PCMPprocessor;
typedef struct PCMPbus PCMPbus;
typedef struct PCMPioapic PCMPioapic;
typedef struct PCMPintr PCMPintr;
typedef struct Aintr Aintr;
typedef struct Bus Bus;
typedef struct Apic Apic;

// was in mpacpi.h
typedef struct Dsdt Dsdt;
typedef struct Facp Facp;
typedef struct Hpet Hpet;
typedef struct Madt Madt;
typedef struct Mcfg Mcfg;
typedef struct Mcfgd Mcfgd;
typedef struct Rsd Rsd;


<<dat_forward.h pragma(x86)>>
@
\fi

\subsection*{[[core/386/fns.h]]}

<<fns.h macros(x86)>>=
<<function KADDR(x86)>>
<<function PADDR(x86)>>

#define BIOSSEG(a)  KADDR(((uint)(a))<<4)

#define L16GET(p) (((p)[1]<<8)|(p)[0])
#define L32GET(p) (((u32int)L16GET((p)+2)<<16)|L16GET(p))
@
% #define dcflush(a, b) nil  is better for pfff, but then generate
% warnings with 8c when do  'dcflush(..);' because expands to 'nil;'

\ifallcode
<<fns.h declarations(x86)>>=

// <arch>/arch.c (called from main)
void   arch_cpuidprint(void);

// different signatures in different arch so cant factorize
void  arch_touser(void*);
int   (*arch_cmpswap)(long*, long, long);
void  (*arch_coherence)(void);
void  (*arch_cycles)(uvlong*);
<<function mmuflushtlb(x86)>>

// fns_memory.h

// mmu.c (called from main.c)
void   mmuinit0(void); 
void*  tmpmap(Page*);
void   tmpunmap(void*);
// mmu.c (called from main.c/mp.c)
ulong* mmuwalk(ulong*, ulong, int, bool); 
// mmu.c (called from many arch specific)
void*  vmap(ulong, int);
void   vunmap(void*, int);
int    vmapsync(ulong);
// memory.c (called from main.c)
void   meminit(void); 
// memory.c (called from mmu.c)
kern_addr3 rampage(void);
void*  sigsearch(char*);
// memory.c (called from screen.c, pci.c)
ulong  upaalloc(int, int);
void   upareserve(ulong, int);
// l_misc.s (called from mmu.c)
//@Scheck: Assembly
void   invlpg(ulong);
// l.s (called from mmu.c)
//@Scheck: Assembly
void   ltr(ulong);
//@Scheck: Assembly
void   lidt(ushort[3]);
//@Scheck: Assembly
void   lgdt(ushort[3]);

// fns_init.h

// main.c (called from main.c/mp.c)
void   cpuinit(void); 
// l_misc.s (called from main.c)
//@Scheck: Assembly
void   halt(void);

// fns_processes.h

// trap.c (called from main.c)
void  trapenable(int, void (*)(Ureg*, void*), void*, char*);
void  trapinit0(void);
// trap.c (called from sdata.c, uarti...)
int   intrdisable(int, void (*)(Ureg *, void *), void*, int, char*);
// l_misc.s (called from mp.c, x86.c, trap.c)
void  rdmsr(int, vlong*);
// l_trap.s (called from trap.c)
//@Scheck: Assembly
void  vectortable(void);

// fns_devices.h

// kbd.c (called from main)
void  kbdinit(void);
void  kbdenable(void);
// cga.c (called from main)
void  cgapost(int);

// fns_arch.h

// devarch.c (called from main)
void  archinit(void);
// archgeneric.c (called from mp)
void  archrevert(void);
// l_misc.s 
//@Scheck: Assembly
void  cpuid(int, ulong regs[]);
// x86.c (called from main.c/mp.c)
int   cpuidentify(void);
//l_misc.c (called from i8253.c)
//@Scheck: Assembly
void  aamloop(int);
// l_misc.s (called from mp.c/archgeneric.c)
//@Scheck: Assembly
void  idle(void);
// i8253.c (called from x86.c)
void  guesscpuhz(int);
// archmp.c (called from mp.c)
void  syncclock(void);
// l_misc.c (called from arch specific)
//@Scheck: Assembly
void  wrmsr(int, vlong);

// fns_concurrency.h

// coherence possible values
//@Scheck: Assembly
void  mfence(void);
//@Scheck: Assembly
void  mb386(void);
//@Scheck: Assembly
void  mb586(void);
// l_misc.s (called from devarch)
// cmpswap possible value
int   cmpswap386(long*, long, long);
//@Scheck: Assembly
int   cmpswap486(long*, long, long);




// iomap.c
void (*hook_ioalloc)(void);

void  iofree(int);
void  ioinit(void);
int   ioalloc(int, int, int, char*);

//@Scheck: Assembly
int   bios32call(BIOS32ci*, u16int[3]);
int   bios32ci(BIOS32si*, BIOS32ci*);
BIOS32si* bios32open(char*);

void  dmaend(int); // called from port/devaudio.c!
long  dmasetup(int, void*, long, int);

int   dmainit(int, int);


//@Scheck: Assembly
void  fpclear(void);
//@Scheck: Assembly
void  fpinit(void);
//@Scheck: Assembly
void  fpoff(void);
//@Scheck: Assembly
void  fpon(void);


//@Scheck: Assembly
void  fpenv(Arch_FPsave*);
void  (*fprestore)(Arch_FPsave*);
void  (*fpsave)(Arch_FPsave*);
void  fpsavealloc(void);
void  fpsserestore(Arch_FPsave*);
//@Scheck: Assembly
void  fpsserestore0(Arch_FPsave*);
void  fpssesave(Arch_FPsave*);
//@Scheck: Assembly
void  fpssesave0(Arch_FPsave*);
//ulong fpstatus(void);
//@Scheck: Assembly
void  fpx87restore(Arch_FPsave*);
//@Scheck: Assembly
void  fpx87save(Arch_FPsave*);

//@Scheck: Assembly
ulong getcr0(void);
//@Scheck: Assembly
ulong getcr2(void);
//@Scheck: Assembly
ulong getcr3(void);
//@Scheck: Assembly
ulong getcr4(void);

//@Scheck: Assembly
void  putcr0(ulong);
//@Scheck: Assembly
void  putcr3(ulong);
//@Scheck: Assembly
void  putcr4(ulong);


int   i8042auxcmd(int);
void  i8042auxenable(void (*)(int, int));
void  i8042reset(void);

void  i8250console(void);
void* i8250alloc(int, int, int);

void  i8253enable(void);
void  i8253init(void);
uvlong  i8253read(uvlong*);
void  i8253timerset(uvlong);

int   i8259disable(int);
int   i8259enable(Vctl*);
void  i8259init(void);
int   i8259isr(int);
void  i8259on(void);
void  i8259off(void);
int   i8259vecno(int);

//@Scheck: Assembly
int   inb(int);
void  insb(int, void*, int); // used only by ether8390 for now
//@Scheck: Assembly
ushort ins(int);
//@Scheck: Assembly
void  inss(int, void*, int);
//@Scheck: Assembly
ulong inl(int);

//@Scheck: Assembly
void  outb(int, int);
void  outsb(int, void*, int); // used only by ether8390 for now
//@Scheck: Assembly
void  outs(int, ushort);
//@Scheck: Assembly
void  outss(int, void*, int);
//@Scheck: Assembly
void  outl(int, ulong);

//int mtrr(uvlong, uvlong, char *);
//void mtrrclock(void);
//int mtrrprint(char *, long);

// nvram.c (called from devfloppy.c and memory.c)
uchar nvramread(int);
void  nvramwrite(int, uchar);

int   pcicfgr8(Pcidev*, int);
int   pcicfgr16(Pcidev*, int);
int   pcicfgr32(Pcidev*, int);
void  pcicfgw8(Pcidev*, int, int);
void  pcicfgw32(Pcidev*, int, int);
void  pciclrbme(Pcidev*);
Pcidev* pcimatch(Pcidev*, int, int);
Pcidev* pcimatchtbdf(int);
void  pcireset(void);
void  pcisetbme(Pcidev*);
//void  pcicfgw16(Pcidev*, int, int);
//void  pciclrioe(Pcidev*);
//void  pciclrmwi(Pcidev*);
//int   pcigetpms(Pcidev*);
//int   pciscan(int, Pcidev**);
//void  pcisetioe(Pcidev*);
//void  pcisetmwi(Pcidev*);
//int   pcisetpms(Pcidev*, int);

int pcmspecial(char*, ISAConf*);
//int (*_pcmspecial)(char *, ISAConf *);
//void  pcmcisread(PCMslot*);
//int   pcmcistuple(int, int, int, void*, int);
//void  pcmspecialclose(int);
//void  (*_pcmspecialclose)(int);
//PCMmap* pcmmap(int, ulong, int, int);
//void  pcmunmap(int, PCMmap*);


<<fns.h macros(x86)>>
@
\fi
%$

\subsection*{[[core/386/dat.c]]}
%pad: I created this file to remove some backward deps

<<core/386/dat.c>>=
<<kernel basic includes>>

<<global cpu(x86)>>
@

\subsection*{[[core/386/fns.c]]}

% used by isaconfig
<<function cistrncmp(x86)>>=
int
cistrncmp(char *a, char *b, int n)
{
    unsigned ac, bc;

    while(n > 0){
        ac = *a++;
        bc = *b++;
        n--;

        if(ac >= 'A' && ac <= 'Z')
            ac = 'a' + (ac - 'A');
        if(bc >= 'A' && bc <= 'Z')
            bc = 'a' + (bc - 'A');

        ac -= bc;
        if(ac)
            return ac;
        if(bc == 0)
            break;
    }

    return 0;
}
@

% used by getconf
<<function cistrcmp(x86)>>=
int
cistrcmp(char *a, char *b)
{
    int ac, bc;

    for(;;){
        ac = *a++;
        bc = *b++;
    
        if(ac >= 'A' && ac <= 'Z')
            ac = 'a' + (ac - 'A');
        if(bc >= 'A' && bc <= 'Z')
            bc = 'a' + (bc - 'A');
        ac -= bc;
        if(ac)
            return ac;
        if(bc == 0)
            break;
    }
    return 0;
}
@
% cant use strcmp from libc?


<<core/386/fns.c>>=
<<kernel basic includes>>

// was in main.c, could be in lib/386/libc.c (or even lib/libc.c)

<<function cistrncmp(x86)>>

<<function cistrcmp(x86)>>

@

\section{[[devices/386/]]}

\subsection*{[[devices/keyboard/386/kbd.c]]}

% main thing is the interrupt, set in kbdenable

%pad: most of the code is actually independent of x86 and similar for
% arm so I factorized the code in portkbd.c


<<devices/keyboard/386/kbd.c>>=
/*
 * keyboard input
 */
<<kernel basic includes>>

#include    "io.h"

enum {
    Data=       0x60,       /* data port */

    Status=     0x64,       /* status port */
     Inready=   0x01,       /*  input character ready */
     Outbusy=   0x02,       /*  output busy */
     Sysflag=   0x04,       /*  system flag */
     Cmddata=   0x08,       /*  cmd==0, data==1 */
     Inhibit=   0x10,       /*  keyboard/mouse inhibited */
     Minready=  0x20,       /*  mouse character ready */
     Rtimeout=  0x40,       /*  general timeout */
     Parity=    0x80,

    Cmd=        0x64,       /* command port (write only) */
};

enum
{
    /* controller command byte */
    Cscs1=      (1<<6),     /* scan code set 1 */
    Cauxdis=    (1<<5),     /* mouse disable */
    Ckbddis=    (1<<4),     /* kbd disable */
    Csf=        (1<<2),     /* system flag */
    Cauxint=    (1<<1),     /* mouse interrupt enable */
    Ckbdint=    (1<<0),     /* kbd interrupt enable */
};

<<global i8042lock(x86)>>
<<global nokbd(x86)>>

<<global ccc(x86)>>
<<hook auxputc(x86)>>

static char *initfailed = "i8042: kbdinit failed\n";

<<function outready(x86)>>

<<function inready(x86)>>

<<function i8042reset(x86)>>

<<function i8042auxcmd(x86)>>

<<function setleds(x86)>>

<<interrupt callback i8042intr(x86)>>

<<function i8042auxenable(x86)>>

<<function outbyte(x86)>>

<<function kbdinit(x86)>>

<<function kbdenable(x86)>>

@ 
% >> >> >> >> >> >> >> >>

%/*
% *  ask 8042 to enable the use of address bit 20
% */
%//void
%//i8042a20(void)
%//{
%//  outready();
%//  outb(Cmd, 0xD1);
%//  outready();
%//  outb(Data, 0xDF);
%//  outready();
%//}
%
%
%//int
%//i8042auxcmds(uchar *cmd, int ncmd)
%//{
%//  int i;
%//
%//  ilock(&i8042lock);
%//  for(i=0; i<ncmd; i++){
%//      if(outready() < 0)
%//          break;
%//      outb(Cmd, 0xD4);
%//      if(outready() < 0)
%//          break;
%//      outb(Data, cmd[i]);
%//  }
%//  iunlock(&i8042lock);
%//  return i;
%//}

% >> >> >> >>

\subsection*{[[devices/mouse/386/mouse.c]]}

<<386/mouse.c>>=
<<kernel basic includes>>

/*
 *  ps/2 mouse message is three bytes
 *
 *  byte 0 -    0 0 SDY SDX 1 M R L
 *  byte 1 -    DX
 *  byte 2 -    DY
 *
 *  shift & right button is the same as middle button
 *
 * Intellimouse and AccuPoint with extra buttons deliver
 *  byte 3 -    00 or 01 or FF according to extra button state.
 * extra buttons are mapped in this code to buttons 4 and 5.
 * AccuPoint generates repeated events for these buttons;
*  it and Intellimouse generate 'down' events only, so
 * user-level code is required to generate button 'up' events
 * if they are needed by the application.
 * Also on laptops with AccuPoint AND external mouse, the
 * controller may deliver 3 or 4 bytes according to the type
 * of the external mouse; code must adapt.
 *
 * On the NEC Versa series (and perhaps others?) we seem to
 * lose a byte from the packet every once in a while, which
 * means we lose where we are in the instruction stream.
 * To resynchronize, if we get a byte more than two seconds
 * after the previous byte, we assume it's the first in a packet.
 */
static void
ps2mouseputc(int c, int shift)
{
    static short msg[4];
    static int nb;
    static uchar b[] = {0, 1, 4, 5, 2, 3, 6, 7, 0, 1, 2, 3, 2, 3, 6, 7 };
    static ulong lasttick;
    ulong m;
    int buttons, dx, dy;

    /*
     * non-ps2 keyboards might not set shift
     * but still set mouseshifted.
     */
    shift |= mouseshifted;

    /*
     * Resynchronize in stream with timing; see comment above.
     */
    m = CPUS(0)->ticks;
    if(TK2SEC(m - lasttick) > 2)
        nb = 0;
    lasttick = m;

    /* 
     *  check byte 0 for consistency
     */
    if(nb==0 && (c&0xc8)!=0x08)
        if(intellimouse && (c==0x00 || c==0x01 || c==0xFF)){
            /* last byte of 4-byte packet */
            packetsize = 4;
            return;
        }

    msg[nb] = c;
    if(++nb == packetsize){
        nb = 0;
        if(msg[0] & 0x10)
            msg[1] |= 0xFF00;
        if(msg[0] & 0x20)
            msg[2] |= 0xFF00;

        buttons = b[(msg[0]&7) | (shift ? 8 : 0)];
        if(intellimouse && packetsize==4){
            if((msg[3]&0xc8) == 0x08){
                /* first byte of 3-byte packet */
                packetsize = 3;
                msg[0] = msg[3];
                nb = 1;
                /* fall through to emit previous packet */
            }else{
                /* The AccuPoint on the Toshiba 34[48]0CT
                 * encodes extra buttons as 4 and 5. They repeat
                 * and don't release, however, so user-level
                 * timing code is required. Furthermore,
                 * intellimice with 3buttons + scroll give a
                 * two's complement number in the lower 4 bits
                 * (bit 4 is sign extension) that describes
                 * the amount the scroll wheel has moved during
                 * the last sample. Here we use only the sign to
                 * decide whether the wheel is moving up or down
                 * and generate a single button 4 or 5 click
                 * accordingly.
                 */
                if((msg[3] >> 3) & 1)
                    buttons |= 1<<3;
                else if(msg[3] & 0x7)
                    buttons |= 1<<4;
            }
        }
        dx = msg[1];
        dy = -msg[2];

        // call in devmouse.c
        mousetrack(dx, dy, buttons, TK2MS(CPUS(0)->ticks));
    }
}


void arch_ps2mouse(void)
{
    i8042auxenable(ps2mouseputc);

    /* make mouse streaming, enabled */
    i8042auxcmd(0xEA);
    i8042auxcmd(0xF4);
}

void arch_setaccelerated(void)
{
    if(mousehwaccel){
        switch(mousetype){
        case MousePS2:
            i8042auxcmd(0xE7);
            return;
        }
    }
}

void arch_setlinear(void)
{
    if(mousehwaccel){
        switch(mousetype){
        case MousePS2:
            i8042auxcmd(0xE6);
            return;
        }
    }
}


void arch_setres(int n)
{
    switch(mousetype){
    case MousePS2:
        i8042auxcmd(0xE8);
        i8042auxcmd(n);
        break;
    }
}


void arch_setintellimouse()
{
    switch(mousetype){
    case MousePS2:
        i8042auxcmd(0xF3);  /* set sample */
        i8042auxcmd(0xC8);
        i8042auxcmd(0xF3);  /* set sample */
        i8042auxcmd(0x64);
        i8042auxcmd(0xF3);  /* set sample */
        i8042auxcmd(0x50);
        break;
    case Mouseserial:
        //i8250setmouseputc(mouseport, m5mouseputc);
        break;
    }
}

void arch_resetmouse(void)
{
    switch(mousetype){
    case MousePS2:
        i8042auxcmd(0xF6);
        i8042auxcmd(0xEA);  /* streaming */
        i8042auxcmd(0xE8);  /* set resolution */
        i8042auxcmd(3);
        i8042auxcmd(0xF4);  /* enabled */
        break;
    }
}

@

\subsection*{[[devices/screen/386/cga.c]]}

<<cga.c>>=
<<kernel basic includes>>

<<cga.c enum color(x86)>>

<<cga.c enum misc(x86)>>

<<constant CGASCREENBASE(x86)>>

<<global cgapos(x86)>>
<<global cgascreenlock(x86)>>

<<function cgaregr(x86)>>

<<function cgaregw(x86)>>

<<function movecursor(x86)>>

<<function cgascreenputc(x86)>>

<<function cgascreenputs(x86)>>

<<function cgapost(x86)>>

<<function screeninit(x86)>>
@


\subsection*{[[devices/storage/386/floppy.h]]}

\ifallcode
<<floppy.h forward decl(x86)>>=
typedef struct FController FController;
typedef struct FDrive FDrive;
typedef struct FType FType;
@
\fi

<<floppy.h>>=
<<floppy.h forward decl(x86)>>

// why not inlined in devfloppy.c? used by other programs?

/*
 *  a floppy drive
 */
struct FDrive
{
  FType *t;   /* floppy type */
  int dt;   /* drive type */
  int dev;

  ulong lasttouched;  /* time last touched */
  int cyl;    /* current arm position */
  int confused; /* needs to be recalibrated */
  int vers;
  int maxtries; /* max read attempts before Eio */

  int tcyl;   /* target cylinder */
  int thead;    /* target head */
  int tsec;   /* target sector */
  long  len;    /* size of xfer */

  uchar *cache;   /* track cache */
  int ccyl;
  int chead;
};

/*
 *  controller for 4 floppys
 */
struct FController
{
  QLock;      /* exclusive access to the contoller */

  int ndrive;
  FDrive  *d;   /* the floppy drives */
  FDrive  *selected;
  int rate;   /* current rate selected */
  uchar cmd[14];  /* command */
  int ncmd;   /* # command bytes */
  uchar stat[14]; /* command status */
  int nstat;    /* # status bytes */
  int confused; /* controler needs to be reset */
  Rendez  r;    /* wait here for command termination */
  int motor;    /* bit mask of spinning disks */
};

/*
 *  floppy types (all MFM encoding)
 */
struct FType
{
  char  *name;
  int dt;   /* compatible drive type */
  int bytes;    /* bytes/sector */
  int sectors;  /* sectors/track */
  int heads;    /* number of heads */
  int steps;    /* steps per cylinder */
  int tracks;   /* tracks/disk */
  int gpl;    /* intersector gap length for read/write */ 
  int fgpl;   /* intersector gap length for format */
  int rate;   /* rate code */

  /*
   *  these depend on previous entries and are set filled in
   *  by floppyinit
   */
  int bcode;    /* coded version of bytes for the controller */
  long  cap;    /* drive capacity in bytes */
  long  tsize;    /* track size in bytes */
};

/* bits in the registers */
enum
{
  /* status registers a & b */
  Psra=   0x3f0,
  Psrb=   0x3f1,

  /* digital output register */
  Pdor=   0x3f2,
  Fintena=  0x8,  /* enable floppy interrupt */
  Fena=   0x4,  /* 0 == reset controller */

  /* main status register */
  Pmsr=   0x3f4,
  Fready=   0x80, /* ready to be touched */
  Ffrom=    0x40, /* data from controller */
  Ffloppybusy=  0x10, /* operation not over */

  /* data register */
  Pfdata=   0x3f5,
  Frecal=   0x07, /* recalibrate cmd */
  Fseek=    0x0f, /* seek cmd */
  Fsense=   0x08, /* sense cmd */
  Fread=    0x66, /* read cmd */
  Freadid=  0x4a, /* read track id */
  Fspec=    0x03, /* set hold times */
  Fwrite=   0x45, /* write cmd */
  Fformat=  0x4d, /* format cmd */
  Fmulti=   0x80, /* or'd with Fread or Fwrite for multi-head */
  Fdumpreg= 0x0e, /* dump internal registers */

  /* digital input register */
  Pdir=   0x3F7,  /* disk changed port (read only) */
  Pdsr=   0x3F7,  /* data rate select port (write only) */
  Fchange=  0x80, /* disk has changed */

  /* status 0 byte */
  Drivemask=  3<<0,
  Seekend=  1<<5,
  Codemask= (3<<6)|(3<<3),
  Cmdexec=  1<<6,

  /* status 1 byte */
  Overrun=  0x10,
};

@
% >> >> >> >> >> >> 

\subsection*{[[devices/storage/386/devfloppy.c]]}

\ifallcode
<<devfloppy.c forward decl(x86)>>=
static void floppyintr(Ureg*);
static int floppyon(FDrive*);
static void floppyoff(FDrive*);
static void floppysetdef(FDrive*);

/*
 *  predeclared
 */
static int  cmddone(void*);
static void floppyformat(FDrive*, Cmdbuf*);
static void floppykproc(void*);
static void floppypos(FDrive*,long);
static int  floppyrecal(FDrive*);
static int  floppyresult(void);
static void floppyrevive(void);
static long floppyseek(FDrive*, long);
static int  floppysense(void);
static void floppywait(int);
static long floppyxfer(FDrive*, int, void*, long, long);
@

<<devfloppy.c debugging macro(x86)>>=
#define DPRINT if(floppydebug)print
int floppydebug = 0;
@ 
\fi



<<interrupt callback pcfloppyintr(x86)>>=
static void
pcfloppyintr(Ureg *ur, void *a)
{
    USED(a);

    floppyintr(ur);
}
@


<<global floppydevtab(x86)>>=
Dev floppydevtab = {
    .dc       =    'f',
    .name     =    "floppy",
               
    .reset    =    floppyreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    floppyattach,
    .walk     =    floppywalk,
    .stat     =    floppystat,
    .open     =    floppyopen,
    .create   =    devcreate,
    .close    =    floppyclose,
    .read     =    floppyread,
    .bread    =    devbread,
    .write    =    floppywrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@


<<devfloppy.c>>=
<<kernel basic includes>>
#include    "io.h"
#include    "floppy.h"

/* Intel 82077A (8272A compatible) floppy controller */

/* This module expects the following functions to be defined
 * elsewhere: 
 * 
 * inb()
 * outb()
 * floppyexec()
 * floppyeject() 
 * floppysetup0()
 * floppysetup1()
 * dmainit()
 * dmasetup()
 * dmaend()
 * 
 * On DMA systems, floppyexec() should be an empty function; 
 * on non-DMA systems, dmaend() should be an empty function; 
 * dmasetup() may enforce maximum transfer sizes. 
 */

<<devfloppy.c forward decl(x86)>>


<<interrupt callback pcfloppyintr(x86)>>

void
floppysetup0(FController *fl)
{
    fl->ndrive = 0;
    if(ioalloc(Psra, 6, 0, "floppy") < 0)
        return;
    if(ioalloc(Pdir, 1, 0, "floppy") < 0){
        iofree(Psra);
        return;
    }
    fl->ndrive = 2;
}

void
floppysetup1(FController *fl)
{
    uchar equip;

    /*
     *  read nvram for types of floppies 0 & 1
     */
    equip = nvramread(0x10);
    if(fl->ndrive > 0){
        fl->d[0].dt = (equip >> 4) & 0xf;
        floppysetdef(&fl->d[0]);
    }
    if(fl->ndrive > 1){
        fl->d[1].dt = equip & 0xf;
        floppysetdef(&fl->d[1]);
    }
    arch_intrenable(IrqFLOPPY, pcfloppyintr, fl, BUSUNKNOWN, "floppy");
}

/*
 *  eject disk ( unknown on safari )
 */
void
floppyeject(FDrive *dp)
{
    floppyon(dp);
    dp->vers++;
    floppyoff(dp);
}

int 
floppyexec(char *a, long b, int c)
{
    USED(a, b, c);
    return b;
}



enum {
    /* file types */
    Qdir=       0, 
    Qdata=      (1<<2),
    Qctl=       (2<<2),
    Qmask=      (3<<2),

    DMAchan=    2,  /* floppy dma channel */
};

<<devfloppy.c debugging macro(x86)>>

/*
 *  types of drive (from PC equipment byte)
 */
enum
{
    Tnone=      0,
    T360kb=     1,
    T1200kb=    2,
    T720kb=     3,
    T1440kb=    4,
};

FType floppytype[] =
{
 { "3½HD", T1440kb, 512, 18, 2, 1, 80, 0x1B, 0x54, 0, },
 { "3½DD", T1440kb, 512,  9, 2, 1, 80, 0x1B, 0x54, 2, },
 { "3½DD", T720kb,  512,  9, 2, 1, 80, 0x1B, 0x54, 2, },
 { "5¼HD", T1200kb, 512, 15, 2, 1, 80, 0x2A, 0x50, 0, },
 { "5¼DD", T1200kb, 512,  9, 2, 2, 40, 0x2A, 0x50, 1, },
 { "ATT3B1",    T1200kb, 512,  8, 2, 2, 48, 0x2A, 0x50, 1, },
 { "5¼DD", T360kb,  512,  9, 2, 1, 40, 0x2A, 0x50, 2, },
};

/*
 *  bytes per sector encoding for the controller.
 *  - index for b2c is is (bytes per sector/128).
 *  - index for c2b is code from b2c
 */
static int b2c[] =
{
[1] 0,
[2] 1,
[4] 2,
[8] 3,
};
static int c2b[] =
{
    128,
    256,
    512,
    1024,
};

FController fl;

#define MOTORBIT(i) (1<<((i)+4))


Dirtab floppydir[]={
    ".",        {Qdir, 0, QTDIR},   0,  0550,
    "fd0disk",      {Qdata + 0},    0,  0660,
    "fd0ctl",       {Qctl + 0}, 0,  0660,
    "fd1disk",      {Qdata + 1},    0,  0660,
    "fd1ctl",       {Qctl + 1}, 0,  0660,
    "fd2disk",      {Qdata + 2},    0,  0660,
    "fd2ctl",       {Qctl + 2}, 0,  0660,
    "fd3disk",      {Qdata + 3},    0,  0660,
    "fd3ctl",       {Qctl + 3}, 0,  0660,
};
#define NFDIR   2   /* directory entries/drive */

enum
{
    CMdebug,
    CMnodebug,
    CMeject,
    CMformat,
    CMreset,
};

static Cmdtab floppyctlmsg[] =
{
    CMdebug,    "debug",    1,
    CMnodebug,  "nodebug", 1,
    CMeject,    "eject",    1,
    CMformat,   "format",   0,
    CMreset,    "reset",    1,
};

static void
fldump(void)
{
    DPRINT("sra %ux srb %ux dor %ux msr %ux dir %ux\n", inb(Psra), inb(Psrb),
        inb(Pdor), inb(Pmsr), inb(Pdir));
}

/*
 *  set floppy drive to its default type
 */
static void
floppysetdef(FDrive *dp)
{
    FType *t;

    for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++)
        if(dp->dt == t->dt){
            dp->t = t;
            floppydir[1+NFDIR*dp->dev].length = dp->t->cap;
            break;
        }
}

static void
floppyreset(void)
{
    FDrive *dp;
    FType *t;
    ulong maxtsize;
    
    floppysetup0(&fl);
    if(fl.ndrive == 0)
        return;

    /*
     *  init dependent parameters
     */
    maxtsize = 0;
    for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++){
        t->cap = t->bytes * t->heads * t->sectors * t->tracks;
        t->bcode = b2c[t->bytes/128];
        t->tsize = t->bytes * t->sectors;
        if(maxtsize < t->tsize)
            maxtsize = t->tsize;
    }

    /*
     * Should check if this fails. Can do so
     * if there is no space <= 16MB for the DMA
     * bounce buffer.
     */
    dmainit(DMAchan, maxtsize);

    /*
     *  allocate the drive storage
     */
    fl.d = xalloc(fl.ndrive*sizeof(FDrive));
    fl.selected = fl.d;

    /*
     *  stop the motors
     */
    fl.motor = 0;
    arch_delay(10);
    outb(Pdor, fl.motor | Fintena | Fena);
    arch_delay(10);

    /*
     *  init drives
     */
    for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++){
        dp->dev = dp - fl.d;
        dp->dt = T1440kb;
        floppysetdef(dp);
        dp->cyl = -1;           /* because we don't know */
        dp->cache = (uchar*)xspanalloc(maxtsize, BY2PG, 64*1024);
        dp->ccyl = -1;
        dp->vers = 0;
    }

    /*
     *  first operation will recalibrate
     */
    fl.confused = 1;

    floppysetup1(&fl);
}

static Chan*
floppyattach(char *spec)
{
    static int kstarted;

    if(fl.ndrive == 0)
        error(Enodev);

    if(kstarted == 0){
        /*
         *  watchdog to turn off the motors
         */
        kstarted = 1;
        kproc("floppy", floppykproc, 0);
    }
    return devattach('f', spec);
}

static Walkqid*
floppywalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static int
floppystat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static Chan*
floppyopen(Chan *c, int omode)
{
    return devopen(c, omode, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static void
floppyclose(Chan *)
{
}

static void
islegal(ulong offset, long n, FDrive *dp)
{
    if(offset % dp->t->bytes)
        error(Ebadarg);
    if(n % dp->t->bytes)
        error(Ebadarg);
}

/*
 *  check if the floppy has been replaced under foot.  cause
 *  an error if it has.
 *
 *  a seek and a read clears the condition.  this was determined
 *  experimentally, there has to be a better way.
 *
 *  if the read fails, cycle through the possible floppy
 *  density till one works or we've cycled through all
 *  possibilities for this drive.
 */
static void
changed(Chan *c, FDrive *dp)
{
    ulong old;
    FType *start;

    /*
     *  if floppy has changed or first time through
     */
    if((inb(Pdir)&Fchange) || dp->vers == 0){
        DPRINT("changed\n");
        fldump();
        dp->vers++;
        start = dp->t;
        dp->maxtries = 3;   /* limit it when we're probing */

        /* floppyon will fail if there's a controller but no drive */
        dp->confused = 1;   /* make floppyon recal */
        if(floppyon(dp) < 0)
            error(Eio);

        /* seek to the first track */
        floppyseek(dp, dp->t->heads*dp->t->tsize);
        while(waserror()){
            /*
             *  if first attempt doesn't reset changed bit, there's
             *  no floppy there
             */
            if(inb(Pdir)&Fchange)
                nexterror();

            while(++dp->t){
                if(dp->t == &floppytype[nelem(floppytype)])
                    dp->t = floppytype;
                if(dp->dt == dp->t->dt)
                    break;
            }
            floppydir[1+NFDIR*dp->dev].length = dp->t->cap;

            /* floppyon will fail if there's a controller but no drive */
            if(floppyon(dp) < 0)
                error(Eio);

            DPRINT("changed: trying %s\n", dp->t->name);
            fldump();
            if(dp->t == start)
                nexterror();
        }

        /* if the read succeeds, we've got the density right */
        floppyxfer(dp, Fread, dp->cache, 0, dp->t->tsize);
        poperror();
        dp->maxtries = 20;
    }

    old = c->qid.vers;
    c->qid.vers = dp->vers;
    if(old && old != dp->vers)
        error(Eio);
}

static int
readtrack(FDrive *dp, int cyl, int head)
{
    int i, nn, sofar;
    ulong pos;

    nn = dp->t->tsize;
    if(dp->ccyl==cyl && dp->chead==head)
        return nn;
    pos = (cyl*dp->t->heads+head) * nn;
    for(sofar = 0; sofar < nn; sofar += i){
        dp->ccyl = -1;
        i = floppyxfer(dp, Fread, dp->cache + sofar, pos + sofar, nn - sofar);
        if(i <= 0)
            return -1;
    }
    dp->ccyl = cyl;
    dp->chead = head;
    return nn;
}

static long
floppyread(Chan *c, void *a, long n, vlong off)
{
    FDrive *dp;
    long rv;
    int sec, head, cyl;
    long len;
    uchar *aa;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, floppydir, 1+fl.ndrive*NFDIR, devgen);

    rv = 0;
    dp = &fl.d[c->qid.path & ~Qmask];
    switch ((int)(c->qid.path & Qmask)) {
    case Qdata:
        islegal(offset, n, dp);
        aa = a;

        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        floppyon(dp);
        changed(c, dp);
        for(rv = 0; rv < n; rv += len){
            /*
             *  all xfers come out of the track cache
             */
            dp->len = n - rv;
            floppypos(dp, offset+rv);
            cyl = dp->tcyl;
            head = dp->thead;
            len = dp->len;
            sec = dp->tsec;
            if(readtrack(dp, cyl, head) < 0)
                break;
            memmove(aa+rv, dp->cache + (sec-1)*dp->t->bytes, len);
        }
        qunlock(&fl);
        poperror();

        break;
    case Qctl:
        return readstr(offset, a, n, dp->t->name);
    default:
        panic("floppyread: bad qid");
    }

    return rv;
}

static long
floppywrite(Chan *c, void *a, long n, vlong off)
{
    FDrive *dp;
    long rv, i;
    char *aa = a;
    Cmdbuf *cb;
    Cmdtab *ct;
    ulong offset = off;

    rv = 0;
    dp = &fl.d[c->qid.path & ~Qmask];
    switch ((int)(c->qid.path & Qmask)) {
    case Qdata:
        islegal(offset, n, dp);
        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        floppyon(dp);
        changed(c, dp);
        for(rv = 0; rv < n; rv += i){
            floppypos(dp, offset+rv);
            if(dp->tcyl == dp->ccyl)
                dp->ccyl = -1;
            i = floppyxfer(dp, Fwrite, aa+rv, offset+rv, n-rv);
            if(i < 0)
                break;
            if(i == 0)
                error(Eio);
        }
        qunlock(&fl);
        poperror();
        break;
    case Qctl:
        rv = n;
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        ct = lookupcmd(cb, floppyctlmsg, nelem(floppyctlmsg));
        switch(ct->index){
        case CMeject:
            floppyeject(dp);
            break;
        case CMformat:
            floppyformat(dp, cb);
            break;
        case CMreset:
            fl.confused = 1;
            floppyon(dp);
            break;
        case CMdebug:
            floppydebug = 1;
            break;
        case CMnodebug:
            floppydebug = 0;
            break;
        }
        poperror();
        qunlock(&fl);
        poperror();
        free(cb);
        break;
    default:
        panic("floppywrite: bad qid");
    }

    return rv;
}

static void
floppykproc(void *)
{
    FDrive *dp;

    while(waserror())
        ;
    for(;;){
        for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++){
            if((fl.motor&MOTORBIT(dp->dev))
            && TK2SEC(cpu->ticks - dp->lasttouched) > 5
            && canqlock(&fl)){
                if(TK2SEC(cpu->ticks - dp->lasttouched) > 5)
                    floppyoff(dp);
                qunlock(&fl);
            }
        }
        tsleep(&up->sleepr, returnfalse, 0, 1000);
    }
}

/*
 *  start a floppy drive's motor.
 */
static int
floppyon(FDrive *dp)
{
    int alreadyon;
    int tries;

    if(fl.confused)
        floppyrevive();

    /* start motor and select drive */
    alreadyon = fl.motor & MOTORBIT(dp->dev);
    fl.motor |= MOTORBIT(dp->dev);
    outb(Pdor, fl.motor | Fintena | Fena | dp->dev);
    if(!alreadyon){
        /* wait for drive to spin up */
        tsleep(&up->sleepr, returnfalse, 0, 750);

        /* clear any pending interrupts */
        floppysense();
    }

    /* set transfer rate */
    if(fl.rate != dp->t->rate){
        fl.rate = dp->t->rate;
        outb(Pdsr, fl.rate);
    }

    /* get drive to a known cylinder */
    if(dp->confused)
        for(tries = 0; tries < 4; tries++)
            if(floppyrecal(dp) >= 0)
                break;
    dp->lasttouched = cpu->ticks;
    fl.selected = dp;

    /* return -1 if this didn't work */
    if(dp->confused)
        return -1;
    return 0;
}

/*
 *  stop the floppy if it hasn't been used in 5 seconds
 */
static void
floppyoff(FDrive *dp)
{
    fl.motor &= ~MOTORBIT(dp->dev);
    outb(Pdor, fl.motor | Fintena | Fena | dp->dev);
}

/*
 *  send a command to the floppy
 */
static int
floppycmd(void)
{
    int i;
    int tries;

    fl.nstat = 0;
    for(i = 0; i < fl.ncmd; i++){
        for(tries = 0; ; tries++){
            if((inb(Pmsr)&(Ffrom|Fready)) == Fready)
                break;
            if(tries > 1000){
                DPRINT("cmd %ux can't be sent (%d)\n", fl.cmd[0], i);
                fldump();

                /* empty fifo, might have been a bad command */
                floppyresult();
                return -1;
            }
            arch_microdelay(8);  /* for machine independence */
        }
        outb(Pfdata, fl.cmd[i]);
    }
    return 0;
}

/*
 *  get a command result from the floppy
 *
 *  when the controller goes ready waiting for a command
 *  (instead of sending results), we're done
 * 
 */
static int
floppyresult(void)
{
    int i, s;
    int tries;

    /* get the result of the operation */
    for(i = 0; i < sizeof(fl.stat); i++){
        /* wait for status byte */
        for(tries = 0; ; tries++){
            s = inb(Pmsr)&(Ffrom|Fready);
            if(s == Fready){
                fl.nstat = i;
                return fl.nstat;
            }
            if(s == (Ffrom|Fready))
                break;
            if(tries > 1000){
                DPRINT("floppyresult: %d stats\n", i);
                fldump();
                fl.confused = 1;
                return -1;
            }
            arch_microdelay(8);  /* for machine independence */
        }
        fl.stat[i] = inb(Pfdata);
    }
    fl.nstat = sizeof(fl.stat);
    return fl.nstat;
}

/*
 *  calculate physical address of a logical byte offset into the disk
 *
 *  truncate dp->length if it crosses a track boundary
 */
static void
floppypos(FDrive *dp, long off)
{
    int lsec;
    int ltrack;
    int end;

    lsec = off/dp->t->bytes;
    ltrack = lsec/dp->t->sectors;
    dp->tcyl = ltrack/dp->t->heads;
    dp->tsec = (lsec % dp->t->sectors) + 1;
    dp->thead = (lsec/dp->t->sectors) % dp->t->heads;

    /*
     *  can't read across track boundaries.
     *  if so, decrement the bytes to be read.
     */
    end = (ltrack+1)*dp->t->sectors*dp->t->bytes;
    if(off+dp->len > end)
        dp->len = end - off;
}

/*
 *  get the interrupt cause from the floppy.
 */
static int
floppysense(void)
{
    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Fsense;
    if(floppycmd() < 0)
        return -1;
    if(floppyresult() < 2){
        DPRINT("can't read sense response\n");
        fldump();
        fl.confused = 1;
        return -1;
    }
    return 0;
}

static int
cmddone(void *)
{
    return fl.ncmd == 0;
}

/*
 *  Wait for a floppy interrupt.  If none occurs in 5 seconds, we
 *  may have missed one.  This only happens on some portables which
 *  do power management behind our backs.  Call the interrupt
 *  routine to try to clear any conditions.
 */
static void
floppywait(int slow)
{
    tsleep(&fl.r, cmddone, 0, slow ? 5000 : 1000);
    if(!cmddone(0)){
        floppyintr(0);
        fl.confused = 1;
    }
}

/*
 *  we've lost the floppy position, go to cylinder 0.
 */
static int
floppyrecal(FDrive *dp)
{
    dp->ccyl = -1;
    dp->cyl = -1;

    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Frecal;
    fl.cmd[fl.ncmd++] = dp->dev;
    if(floppycmd() < 0)
        return -1;
    floppywait(1);
    if(fl.nstat < 2){
        DPRINT("recalibrate: confused %ux\n", inb(Pmsr));
        fl.confused = 1;
        return -1;
    }
    if((fl.stat[0] & (Codemask|Seekend)) != Seekend){
        DPRINT("recalibrate: failed\n");
        dp->confused = 1;
        return -1;
    }
    dp->cyl = fl.stat[1];
    if(dp->cyl != 0){
        DPRINT("recalibrate: wrong cylinder %d\n", dp->cyl);
        dp->cyl = -1;
        dp->confused = 1;
        return -1;
    }

    dp->confused = 0;
    return 0;
}

/*
 *  if the controller or a specific drive is in a confused state,
 *  reset it and get back to a known state
 */
static void
floppyrevive(void)
{
    FDrive *dp;

    /*
     *  reset the controller if it's confused
     */
    if(fl.confused){
        DPRINT("floppyrevive in\n");
        fldump();

        /* reset controller and turn all motors off */
        arch_splhi();
        fl.ncmd = 1;
        fl.cmd[0] = 0;
        outb(Pdor, 0);
        arch_delay(10);
        outb(Pdor, Fintena|Fena);
        arch_delay(10);
        arch_spllo();
        fl.motor = 0;
        fl.confused = 0;
        floppywait(0);

        /* mark all drives in an unknown state */
        for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++)
            dp->confused = 1;

        /* set rate to a known value */
        outb(Pdsr, 0);
        fl.rate = 0;

        DPRINT("floppyrevive out\n");
        fldump();
    }
}

/*
 *  seek to the target cylinder
 *
 *  interrupt, no results
 */
static long
floppyseek(FDrive *dp, long off)
{
    floppypos(dp, off);
    if(dp->cyl == dp->tcyl)
        return dp->tcyl;
    dp->cyl = -1;

    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Fseek;
    fl.cmd[fl.ncmd++] = (dp->thead<<2) | dp->dev;
    fl.cmd[fl.ncmd++] = dp->tcyl * dp->t->steps;
    if(floppycmd() < 0)
        return -1;
    floppywait(1);
    if(fl.nstat < 2){
        DPRINT("seek: confused\n");
        fl.confused = 1;
        return -1;
    }
    if((fl.stat[0] & (Codemask|Seekend)) != Seekend){
        DPRINT("seek: failed\n");
        dp->confused = 1;
        return -1;
    }

    dp->cyl = dp->tcyl;
    return dp->tcyl;
}

/*
 *  read or write to floppy.  try up to three times.
 */
static long
floppyxfer(FDrive *dp, int cmd, void *a, long off, long n)
{
    long offset;
    int tries;

    if(off >= dp->t->cap)
        return 0;
    if(off + n > dp->t->cap)
        n = dp->t->cap - off;

    /* retry on error (until it gets ridiculous) */
    tries = 0;
    while(waserror()){
        if(tries++ >= dp->maxtries)
            nexterror();
        DPRINT("floppyxfer: retrying\n");
    }

    dp->len = n;
    if(floppyseek(dp, off) < 0){
        DPRINT("xfer: seek failed\n");
        dp->confused = 1;
        error(Eio);
    }

    /*
     *  set up the dma (dp->len may be trimmed)
     */
    if(waserror()){
        dmaend(DMAchan);
        nexterror();
    }
    dp->len = dmasetup(DMAchan, a, dp->len, cmd==Fread);
    if(dp->len < 0)
        error(Eio);

    /*
     *  start operation
     */
    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = cmd | (dp->t->heads > 1 ? Fmulti : 0);
    fl.cmd[fl.ncmd++] = (dp->thead<<2) | dp->dev;
    fl.cmd[fl.ncmd++] = dp->tcyl;
    fl.cmd[fl.ncmd++] = dp->thead;
    fl.cmd[fl.ncmd++] = dp->tsec;
    fl.cmd[fl.ncmd++] = dp->t->bcode;
    fl.cmd[fl.ncmd++] = dp->t->sectors;
    fl.cmd[fl.ncmd++] = dp->t->gpl;
    fl.cmd[fl.ncmd++] = 0xFF;
    if(floppycmd() < 0)
        error(Eio);

    /* Poll ready bits and transfer data */
    floppyexec((char*)a, dp->len, cmd==Fread);

    /*
     *  give bus to DMA, floppyintr() will read result
     */
    floppywait(0);
    dmaend(DMAchan);
    poperror();

    /*
     *  check for errors
     */
    if(fl.nstat < 7){
        DPRINT("xfer: confused\n");
        fl.confused = 1;
        error(Eio);
    }
    if((fl.stat[0] & Codemask)!=0 || fl.stat[1] || fl.stat[2]){
        DPRINT("xfer: failed %ux %ux %ux\n", fl.stat[0],
            fl.stat[1], fl.stat[2]);
        DPRINT("offset %lud len %ld\n", off, dp->len);
        if((fl.stat[0]&Codemask)==Cmdexec && fl.stat[1]==Overrun){
            DPRINT("DMA overrun: retry\n");
        } else
            dp->confused = 1;
        error(Eio);
    }

    /*
     *  check for correct cylinder
     */
    offset = fl.stat[3] * dp->t->heads + fl.stat[4];
    offset = offset*dp->t->sectors + fl.stat[5] - 1;
    offset = offset * c2b[fl.stat[6]];
    if(offset != off+dp->len){
        DPRINT("xfer: ends on wrong cyl\n");
        dp->confused = 1;
        error(Eio);
    }
    poperror();

    dp->lasttouched = cpu->ticks;
    return dp->len;
}

/*
 *  format a track
 */
static void
floppyformat(FDrive *dp, Cmdbuf *cb)
{
    int cyl, h, sec;
    ulong track;
    uchar *buf, *bp;
    FType *t;

    /*
     *  set the type
     */
    if(cb->nf == 2){
        for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++){
            if(strcmp(cb->f[1], t->name)==0 && t->dt==dp->dt){
                dp->t = t;
                floppydir[1+NFDIR*dp->dev].length = dp->t->cap;
                break;
            }
        }
        if(t >= &floppytype[nelem(floppytype)])
            error(Ebadarg);
    } else if(cb->nf == 1){
        floppysetdef(dp);
        t = dp->t;
    } else {
        cmderror(cb, "invalid floppy format command");
        SET(t);
    }

    /*
     *  buffer for per track info
     */
    buf = smalloc(t->sectors*4);
    if(waserror()){
        free(buf);
        nexterror();
    }

    /* force a recalibrate to cylinder 0 */
    dp->confused = 1;
    if(!waserror()){
        floppyon(dp);
        poperror();
    }

    /*
     *  format a track at time
     */
    for(track = 0; track < t->tracks*t->heads; track++){
        cyl = track/t->heads;
        h = track % t->heads;

        /*
         *  seek to track, ignore errors
         */
        floppyseek(dp, track*t->tsize);
        dp->cyl = cyl;
        dp->confused = 0;

        /*
         *  set up the dma (dp->len may be trimmed)
         */
        bp = buf;
        for(sec = 1; sec <= t->sectors; sec++){
            *bp++ = cyl;
            *bp++ = h;
            *bp++ = sec;
            *bp++ = t->bcode;
        }
        if(waserror()){
            dmaend(DMAchan);
            nexterror();
        }
        if(dmasetup(DMAchan, buf, bp-buf, 0) < 0)
            error(Eio);

        /*
         *  start operation
         */
        fl.ncmd = 0;
        fl.cmd[fl.ncmd++] = Fformat;
        fl.cmd[fl.ncmd++] = (h<<2) | dp->dev;
        fl.cmd[fl.ncmd++] = t->bcode;
        fl.cmd[fl.ncmd++] = t->sectors;
        fl.cmd[fl.ncmd++] = t->fgpl;
        fl.cmd[fl.ncmd++] = 0x5a;
        if(floppycmd() < 0)
            error(Eio);

        /* Poll ready bits and transfer data */
        floppyexec((char *)buf, bp-buf, 0);

        /*
         *  give bus to DMA, floppyintr() will read result
         */
        floppywait(1);
        dmaend(DMAchan);
        poperror();

        /*
         *  check for errors
         */
        if(fl.nstat < 7){
            DPRINT("format: confused\n");
            fl.confused = 1;
            error(Eio);
        }
        if((fl.stat[0]&Codemask)!=0 || fl.stat[1]|| fl.stat[2]){
            DPRINT("format: failed %ux %ux %ux\n",
                fl.stat[0], fl.stat[1], fl.stat[2]);
            dp->confused = 1;
            error(Eio);
        }
    }
    free(buf);
    dp->confused = 1;
    poperror();
}

static void
floppyintr(Ureg *)
{
    switch(fl.cmd[0]&~Fmulti){
    case Fread:
    case Fwrite:
    case Fformat:
    case Fdumpreg: 
        floppyresult();
        break;
    case Fseek:
    case Frecal:
    default:
        floppysense();  /* to clear interrupt */
        break;
    }
    fl.ncmd = 0;
    wakeup(&fl.r);
}

<<global floppydevtab(x86)>>
@


\subsection*{[[devices/sys/386/devarch.c]]}
%pad: I moved stuff in newly created files arch.c, in time.c 
% to remove some backward deps

<<global archdevtab(x86)>>=
Dev archdevtab = {
    .dc       =    'P',
    .name     =    "arch",
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    archattach,
    .walk     =    archwalk,
    .stat     =    archstat,
    .open     =    archopen,
    .create   =    devcreate,
    .close    =    archclose,
    .read     =    archread,
    .bread    =    devbread,
    .write    =    archwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@



<<devices/sys/386/devarch.c>>=
<<kernel basic includes>>

#include "io.h"

#include <ureg.h>

enum {
    Qdir = 0,
    Qioalloc = 1,
    Qiob,
    Qiow,
    Qiol,
    Qbase,

    Qmax = 16,
};

typedef long Rdwrfn(Chan*, void*, long, vlong);

extern int doi8253set;
extern PCArch* knownarch[];


static Rdwrfn *readfn[Qmax];
static Rdwrfn *writefn[Qmax];

static Dirtab archdir[Qmax] = {
    ".",        { Qdir, 0, QTDIR }, 0,  0555,
    "ioalloc",  { Qioalloc, 0 },    0,  0444,
    "iob",      { Qiob, 0 },        0,  0660,
    "iow",      { Qiow, 0 },        0,  0660,
    "iol",      { Qiol, 0 },        0,  0660,
};
Lock archwlock; /* the lock is only for changing archdir */
int narchdir = Qbase;


/*
 * Add a file to the #P listing.  Once added, you can't delete it.
 * You can't add a file with the same name as one already there,
 * and you get a pointer to the Dirtab entry so you can do things
 * like change the Qid version.  Changing the Qid path is disallowed.
 */
Dirtab*
addarchfile(char *name, int perm, Rdwrfn *rdfn, Rdwrfn *wrfn)
{
    int i;
    Dirtab d;
    Dirtab *dp;

    memset(&d, 0, sizeof d);
    strcpy(d.name, name);
    d.perm = perm;

    lock(&archwlock);
    if(narchdir >= Qmax){
        unlock(&archwlock);
        return nil;
    }

    for(i=0; i<narchdir; i++)
        if(strcmp(archdir[i].name, name) == 0){
            unlock(&archwlock);
            return nil;
        }

    d.qid.path = narchdir;
    archdir[narchdir] = d;
    readfn[narchdir] = rdfn;
    writefn[narchdir] = wrfn;
    dp = &archdir[narchdir++];
    unlock(&archwlock);

    return dp;
}

void devarch_hook_ioalloc() {
  archdir[0].qid.vers++;
}


int
iounused(int start, int end)
{
    IOMap *m;

    for(m = iomap.m; m; m = m->next){
        if(start >= m->start && start < m->end
        || start <= m->start && end > m->start)
            return 0;
    }
    return 1;
}

static void
checkport(int start, int end)
{
    /* standard vga regs are OK */
    if(start >= 0x2b0 && end <= 0x2df+1)
        return;
    if(start >= 0x3c0 && end <= 0x3da+1)
        return;

    if(iounused(start, end))
        return;
    error(Eperm);
}




static Chan*
archattach(char* spec)
{
    return devattach('P', spec);
}

Walkqid*
archwalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, archdir, narchdir, devgen);
}

static int
archstat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, archdir, narchdir, devgen);
}

static Chan*
archopen(Chan* c, int omode)
{
    return devopen(c, omode, archdir, narchdir, devgen);
}

static void
archclose(Chan*)
{
}

enum
{
    Linelen= 31,
};

static long
archread(Chan *c, void *a, long n, vlong offset)
{
    char *buf, *p;
    int port;
    ushort *sp;
    ulong *lp;
    IOMap *m;
    Rdwrfn *fn;

    switch((ulong)c->qid.path){

    case Qdir:
        return devdirread(c, a, n, archdir, narchdir, devgen);

    case Qiob:
        port = offset;
        checkport(offset, offset+n);
        for(p = a; port < offset+n; port++)
            *p++ = inb(port);
        return n;

    case Qiow:
        if(n & 1)
            error(Ebadarg);
        checkport(offset, offset+n);
        sp = a;
        for(port = offset; port < offset+n; port += 2)
            *sp++ = ins(port);
        return n;

    case Qiol:
        if(n & 3)
            error(Ebadarg);
        checkport(offset, offset+n);
        lp = a;
        for(port = offset; port < offset+n; port += 4)
            *lp++ = inl(port);
        return n;

    case Qioalloc:
        break;

    default:
        if(c->qid.path < narchdir && (fn = readfn[c->qid.path]))
            return fn(c, a, n, offset);
        error(Eperm);
        break;
    }

    if((buf = malloc(n)) == nil)
        error(Enomem);
    p = buf;
    n = n/Linelen;
    offset = offset/Linelen;

    lock(&iomap);
    for(m = iomap.m; n > 0 && m != nil; m = m->next){
        if(offset-- > 0)
            continue;
        seprint(p, &buf[n], "%8lux %8lux %-12.12s\n", m->start,
            m->end-1, m->tag);
        p += Linelen;
        n--;
    }
    unlock(&iomap);

    n = p - buf;
    memmove(a, buf, n);
    free(buf);

    return n;
}

static long
archwrite(Chan *c, void *a, long n, vlong offset)
{
    char *p;
    int port;
    ushort *sp;
    ulong *lp;
    Rdwrfn *fn;

    switch((ulong)c->qid.path){

    case Qiob:
        p = a;
        checkport(offset, offset+n);
        for(port = offset; port < offset+n; port++)
            outb(port, *p++);
        return n;

    case Qiow:
        if(n & 1)
            error(Ebadarg);
        checkport(offset, offset+n);
        sp = a;
        for(port = offset; port < offset+n; port += 2)
            outs(port, *sp++);
        return n;

    case Qiol:
        if(n & 3)
            error(Ebadarg);
        checkport(offset, offset+n);
        lp = a;
        for(port = offset; port < offset+n; port += 4)
            outl(port, *lp++);
        return n;

    default:
        if(c->qid.path < narchdir && (fn = writefn[c->qid.path]))
            return fn(c, a, n, offset);
        error(Eperm);
        break;
    }
    return 0;
}

<<global archdevtab(x86)>>

void
nop(void)
{
}



static long
cputyperead(Chan*, void *a, long n, vlong offset)
{
    char str[32];
    ulong mhz;

    mhz = (cpu->cpuhz+999999)/1000000;

    snprint(str, sizeof(str), "%s %lud\n", cputype->name, mhz);
    return readstr(offset, a, n, str);
}

static long
archctlread(Chan*, void *a, long nn, vlong offset)
{
    int n;
    char *buf, *p, *ep;

    p = buf = malloc(READSTR);
    if(p == nil)
        error(Enomem);
    ep = p + READSTR;
    p = seprint(p, ep, "cpu %s %lud%s\n",
        cputype->name, (ulong)(cpu->cpuhz+999999)/1000000,
        cpu->havepge ? " pge" : "");
    p = seprint(p, ep, "pge %s\n", getcr4()&0x80 ? "on" : "off");
    p = seprint(p, ep, "coherence ");
    if(arch_coherence == mb386)
        p = seprint(p, ep, "mb386\n");
    else if(arch_coherence == mb586)
        p = seprint(p, ep, "mb586\n");
    else if(arch_coherence == mfence)
        p = seprint(p, ep, "mfence\n");
    else if(arch_coherence == nop)
        p = seprint(p, ep, "nop\n");
    else
        p = seprint(p, ep, "0x%p\n", arch_coherence);
    p = seprint(p, ep, "cmpswap ");
    if(arch_cmpswap == cmpswap386)
        p = seprint(p, ep, "cmpswap386\n");
    else if(arch_cmpswap == cmpswap486)
        p = seprint(p, ep, "cmpswap486\n");
    else
        p = seprint(p, ep, "0x%p\n", arch_cmpswap);
    p = seprint(p, ep, "i8253set %s\n", doi8253set ? "on" : "off");
    n = p - buf;
    //n += mtrrprint(p, ep - p);
    buf[n] = '\0';

    n = readstr(offset, a, nn, buf);
    free(buf);
    return n;
}

enum
{
    CMpge,
    CMcoherence,
    CMi8253set,
    CMcache,
};

static Cmdtab archctlmsg[] =
{
    CMpge,      "pge",      2,
    CMcoherence,    "coherence",    2,
    CMi8253set, "i8253set", 2,
    CMcache,        "cache",        4,
};

static long
archctlwrite(Chan*, void *a, long n, vlong)
{
    uvlong base, size;
    Cmdbuf *cb;
    Cmdtab *ct;
    char *ep;

    cb = parsecmd(a, n);
    if(waserror()){
        free(cb);
        nexterror();
    }
    ct = lookupcmd(cb, archctlmsg, nelem(archctlmsg));
    switch(ct->index){
    case CMpge:
        if(!cpu->havepge)
            error("processor does not support pge");
        if(strcmp(cb->f[1], "on") == 0)
            putcr4(getcr4() | 0x80);
        else if(strcmp(cb->f[1], "off") == 0)
            putcr4(getcr4() & ~0x80);
        else
            cmderror(cb, "invalid pge ctl");
        break;
    case CMcoherence:
        if(strcmp(cb->f[1], "mb386") == 0)
            arch_coherence = mb386;
        else if(strcmp(cb->f[1], "mb586") == 0){
            if(X86FAMILY(cpu->cpuidax) < 5)
                error("invalid coherence ctl on this cpu family");
            arch_coherence = mb586;
        }else if(strcmp(cb->f[1], "mfence") == 0){
            if((cpu->cpuiddx & Sse2) == 0)
                error("invalid coherence ctl on this cpu family");
            arch_coherence = mfence;
        }else if(strcmp(cb->f[1], "nop") == 0){
            /* only safe on vmware */
            if(conf.ncpu > 1)
                error("cannot disable coherence on a multiprocessor");
            arch_coherence = nop;
        }else
            cmderror(cb, "invalid coherence ctl");
        break;
    case CMi8253set:
        if(strcmp(cb->f[1], "on") == 0)
            doi8253set = 1;
        else if(strcmp(cb->f[1], "off") == 0){
            doi8253set = 0;
            (*arch->timerset)(0);
        }else
            cmderror(cb, "invalid i2853set ctl");
        break;
    case CMcache:
        base = strtoull(cb->f[1], &ep, 0);
        if(*ep)
            error("cache: parse error: base not a number?");
        size = strtoull(cb->f[2], &ep, 0);
        if(*ep)
            error("cache: parse error: size not a number?");
        //mtrr(base, size, cb->f[3]);
                error("mtrr: disabled");
        break;
    }
    free(cb);
    poperror();
    return n;
}

<<function archinit(x86)>>
@


\subsection*{[[devices/sys/386/devrtc.c]]}

\ifallcode
<<devrtc.c forward decl(x86)>>=
typedef struct Rtc  Rtc;

static ulong rtc2sec(Rtc*);
static void sec2rtc(ulong, Rtc*);
@
\fi



<<devices/sys/386/devrtc.c>>=
<<kernel basic includes>>

// see also the enum in dat_memory.h used by nvram.c and this file

enum {
    Seconds=    0x00,
    Minutes=    0x02,
    Hours=      0x04, 
    Mday=       0x07,
    Month=      0x08,
    Year=       0x09,
    Status=     0x0A,

    Nvoff=      128,    /* where usable nvram lives */
    Nvsize=     256,

    Nbcd=       6,
};

<<devrtc.c forward decl(x86)>>

<<struct Rtc(x86)>>


enum{
    Qdir = 0,
    Qrtc,
    Qnvram,
};

Dirtab rtcdir[]={
    ".",    {Qdir, 0, QTDIR},   0,  0555,
    "nvram",    {Qnvram, 0},    Nvsize, 0664,
    "rtc",      {Qrtc, 0},  0,  0664,
};

void
rtcinit(void)
{
    if(ioalloc(Paddr, 2, 0, "rtc/nvr") < 0)
        panic("rtcinit: ioalloc failed");
}

static Chan*
rtcattach(char* spec)
{
    return devattach('r', spec);
}

static Walkqid*  
rtcwalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, rtcdir, nelem(rtcdir), devgen);
}

static int   
rtcstat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, rtcdir, nelem(rtcdir), devgen);
}

static Chan*
rtcopen(Chan* c, int omode)
{
    omode = openmode(omode);
    switch((ulong)c->qid.path){
    case Qrtc:
        if(strcmp(up->user, eve)!=0 && omode!=OREAD)
            error(Eperm);
        break;
    case Qnvram:
        if(strcmp(up->user, eve)!=0)
            error(Eperm);
    }
    return devopen(c, omode, rtcdir, nelem(rtcdir), devgen);
}

static void  
rtcclose(Chan*)
{
}

#define GETBCD(o) ((bcdclock[o]&0xf) + 10*(bcdclock[o]>>4))

static long  
_rtctime(void)
{
    uchar bcdclock[Nbcd];
    Rtc rtc;
    int i;

    /* don't do the read until the clock is no longer busy */
    for(i = 0; i < 10000; i++){
        outb(Paddr, Status);
        if(inb(PdataPort) & 0x80)
            continue;

        /* read clock values */
        outb(Paddr, Seconds);   bcdclock[0] = inb(PdataPort);
        outb(Paddr, Minutes);   bcdclock[1] = inb(PdataPort);
        outb(Paddr, Hours); bcdclock[2] = inb(PdataPort);
        outb(Paddr, Mday);  bcdclock[3] = inb(PdataPort);
        outb(Paddr, Month); bcdclock[4] = inb(PdataPort);
        outb(Paddr, Year);  bcdclock[5] = inb(PdataPort);

        outb(Paddr, Status);
        if((inb(PdataPort) & 0x80) == 0)
            break;
    }

    /*
     *  convert from BCD
     */
    rtc.sec = GETBCD(0);
    rtc.min = GETBCD(1);
    rtc.hour = GETBCD(2);
    rtc.mday = GETBCD(3);
    rtc.mon = GETBCD(4);
    rtc.year = GETBCD(5);

    /*
     *  the world starts jan 1 1970
     */
    if(rtc.year < 70)
        rtc.year += 2000;
    else
        rtc.year += 1900;
    return rtc2sec(&rtc);
}

// now in dat_memory.h and not static ...
//static Lock nvrtlock;

long
rtctime(void)
{
    int i;
    long t, ot;

    ilock(&nvrtlock);

    /* loop till we get two reads in a row the same */
    t = _rtctime();
    for(i = 0; i < 100; i++){
        ot = t;
        t = _rtctime();
        if(ot == t)
            break;
    }
    if(i == 100) print("we are boofheads\n");

    iunlock(&nvrtlock);

    return t;
}

static long  
rtcread(Chan* c, void* buf, long n, vlong off)
{
    ulong t;
    char *a, *start;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, buf, n, rtcdir, nelem(rtcdir), devgen);

    switch((ulong)c->qid.path){
    case Qrtc:
        t = rtctime();
        n = readnum(offset, buf, n, t, 12);
        return n;
    case Qnvram:
        if(n == 0)
            return 0;
        if(n > Nvsize)
            n = Nvsize;
        a = start = smalloc(n);

        ilock(&nvrtlock);
        for(t = offset; t < offset + n; t++){
            if(t >= Nvsize)
                break;
            outb(Paddr, Nvoff+t);
            *a++ = inb(PdataPort);
        }
        iunlock(&nvrtlock);

        if(waserror()){
            free(start);
            nexterror();
        }
        memmove(buf, start, t - offset);
        poperror();

        free(start);
        return t - offset;
    }
    error(Ebadarg);
    return 0;
}

#define PUTBCD(n,o) bcdclock[o] = (n % 10) | (((n / 10) % 10)<<4)

static long  
rtcwrite(Chan* c, void* buf, long n, vlong off)
{
    int t;
    char *a, *start;
    Rtc rtc;
    ulong secs;
    uchar bcdclock[Nbcd];
    char *cp, *ep;
    ulong offset = off;

    if(offset!=0)
        error(Ebadarg);


    switch((ulong)c->qid.path){
    case Qrtc:
        /*
         *  read the time
         */
        cp = ep = buf;
        ep += n;
        while(cp < ep){
            if(*cp>='0' && *cp<='9')
                break;
            cp++;
        }
        secs = strtoul(cp, 0, 0);
    
        /*
         *  convert to bcd
         */
        sec2rtc(secs, &rtc);
        PUTBCD(rtc.sec, 0);
        PUTBCD(rtc.min, 1);
        PUTBCD(rtc.hour, 2);
        PUTBCD(rtc.mday, 3);
        PUTBCD(rtc.mon, 4);
        PUTBCD(rtc.year, 5);

        /*
         *  write the clock
         */
        ilock(&nvrtlock);
        outb(Paddr, Seconds);   outb(PdataPort, bcdclock[0]);
        outb(Paddr, Minutes);   outb(PdataPort, bcdclock[1]);
        outb(Paddr, Hours); outb(PdataPort, bcdclock[2]);
        outb(Paddr, Mday);  outb(PdataPort, bcdclock[3]);
        outb(Paddr, Month); outb(PdataPort, bcdclock[4]);
        outb(Paddr, Year);  outb(PdataPort, bcdclock[5]);
        iunlock(&nvrtlock);
        return n;
    case Qnvram:
        if(n == 0)
            return 0;
        if(n > Nvsize)
            n = Nvsize;
    
        start = a = smalloc(n);
        if(waserror()){
            free(start);
            nexterror();
        }
        memmove(a, buf, n);
        poperror();

        ilock(&nvrtlock);
        for(t = offset; t < offset + n; t++){
            if(t >= Nvsize)
                break;
            outb(Paddr, Nvoff+t);
            outb(PdataPort, *a++);
        }
        iunlock(&nvrtlock);

        free(start);
        return t - offset;
    }
    error(Ebadarg);
    return 0;
}

<<global rtcdevtab(x86)>>

<<constants SEC2XXX(x86)>>

<<globals dmsize ldmsize(x86)>>

<<function yrsize(x86)>>

<<function rtc2sec(x86)>>

<<function sec2rtc(x86)>>

@

\section{[[init/386/]]}

\subsection*{[[init/user/preboot/386/init9.c]]}

\subsection*{[[init/386/l.s]]}

<<l.s>>=
#include "mem.h"
#undef DELAY

//*****************************************************************************
// Constants/Macros
//*****************************************************************************

#define PADDR(ka)        ((ka) & ~KZERO)
#define KADDR(pa)        (KZERO|(pa))

/*
 * Some machine instructions not handled by 8[al].
 */
#define DELAY           BYTE $0xEB; BYTE $0x00  /* JMP .+2 */

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. Note that these are assembler-specific hence
 * the '<<2'.
 */
#define PDO(a)          (((((a))>>22) & 0x03FF)<<2)
#define PTO(a)          (((((a))>>12) & 0x03FF)<<2)
// <<2 because each PDE or PTE is 4 bytes.

//*****************************************************************************
// Entry point!! (after jump from l_multiboot.s)
//*****************************************************************************

<<function _setup_segmentation(x86)>>

//*****************************************************************************
// Gdts Data
//*****************************************************************************

<<global tgdt(x86)>>

<<global tgdtptr(x86)>>

// realmode stuff
TEXT m0rgdtptr(SB), $0
        WORD    $(NGDT*8-1)
        LONG    $(CPU0GDT-KZERO)

TEXT m0gdtptr(SB), $0
        WORD    $(NGDT*8-1)
        LONG    $CPU0GDT

TEXT m0idtptr(SB), $0
        WORD $(256*8-1)
        LONG $IDTADDR

//*****************************************************************************
// Assume protected 32 bit and GTD done
//*****************************************************************************

<<function _setup_pagination(x86)>>

<<function _setup_bss_stack(x86)>>

        
//*****************************************************************************
// CPU registers accessor
//*****************************************************************************
               
/*
 * Read/write various system registers.
 * CR4 and the 'model specific registers' should only be read/written
 * after it has been determined the processor supports them
 */
TEXT lgdt(SB), $0                               /* GDTR - global descriptor table */
        MOVL    gdtptr+0(FP), AX
        MOVL    (AX), GDTR
        RET

TEXT lidt(SB), $0                               /* IDTR - interrupt descriptor table */
        MOVL    idtptr+0(FP), AX
        MOVL    (AX), IDTR
        RET

TEXT ltr(SB), $0                                /* TR - task register */
        MOVL    tptr+0(FP), AX
        MOVW    AX, TASK
        RET



TEXT getcr0(SB), $0                             /* CR0 - processor control */
        MOVL    CR0, AX
        RET

TEXT getcr2(SB), $0                             /* CR2 - page fault linear address */
        MOVL    CR2, AX
        RET

TEXT getcr3(SB), $0                             /* CR3 - page directory base */
        MOVL    CR3, AX
        RET

TEXT getcr4(SB), $0                             /* CR4 - extensions */
        MOVL    CR4, AX
        RET


TEXT putcr0(SB), $0
        MOVL    cr0+0(FP), AX
        MOVL    AX, CR0
        RET

TEXT putcr3(SB), $0
        MOVL    cr3+0(FP), AX
        MOVL    AX, CR3
        RET

TEXT putcr4(SB), $0
        MOVL    cr4+0(FP), AX
        MOVL    AX, CR4
        RET

@
%$
% >> >>

\subsection*{[[init/386/l_misc.s]]}


<<l_misc.s>>=

/*
 * Some machine instructions not handled by 8[al].
 */
#define HLT             BYTE $0xF4

<<function idle(x86)>>

<<function halt(x86)>>

/*
 * Basic timing loop to determine CPU frequency.
 */
TEXT aamloop(SB), $0
        MOVL    count+0(FP), CX
_aamloop:
        AAM
        LOOP    _aamloop
        RET


//*****************************************************************************
// Misc
//*****************************************************************************

#define INVLPG  BYTE $0x0F; BYTE $0x01; BYTE $0x39      /* INVLPG (%ecx) */
TEXT invlpg(SB), $0
        /* 486+ only */
        MOVL    va+0(FP), CX
        INVLPG
        RET


#define RDTSC           BYTE $0x0F; BYTE $0x31  /* RDTSC, result in AX/DX (lo/hi) */
TEXT _cycles(SB), $0                            /* time stamp counter */
        RDTSC
        MOVL    vlong+0(FP), CX                 /* &vlong */
        MOVL    AX, 0(CX)                       /* lo */
        MOVL    DX, 4(CX)                       /* hi */
        RET

/*
 * stub for:
 * time stamp counter; low-order 32 bits of 64-bit cycle counter
 * Runs at fasthz/4 cycles per second (m->clkin>>3)
 */
TEXT lcycles(SB),1,$0
        RDTSC
        RET

#define RDMSR           BYTE $0x0F; BYTE $0x32  /* RDMSR, result in AX/DX (lo/hi) */
TEXT rdmsr(SB), $0                              /* model-specific register */
        MOVL    index+0(FP), CX
        RDMSR
        MOVL    vlong+4(FP), CX                 /* &vlong */
        MOVL    AX, 0(CX)                       /* lo */
        MOVL    DX, 4(CX)                       /* hi */
        RET

#define WRMSR           BYTE $0x0F; BYTE $0x30  /* WRMSR, argument in AX/DX (lo/hi) */
                
TEXT wrmsr(SB), $0
        MOVL    index+0(FP), CX
        MOVL    lo+4(FP), AX
        MOVL    hi+8(FP), DX
        WRMSR
        RET


#define CPUID           BYTE $0x0F; BYTE $0xA2  /* CPUID, argument in AX */
        
/*
 * Try to determine the CPU type which requires fiddling with EFLAGS.
 * If the Id bit can be toggled then the CPUID instruction can be used
 * to determine CPU identity and features. First have to check if it's
 * a 386 (Ac bit can't be set). If it's not a 386 and the Id bit can't be
 * toggled then it's an older 486 of some kind.
 *
 *      cpuid(fun, regs[4]);
 */
TEXT cpuid(SB), $0
        MOVL    $0x240000, AX
        PUSHL   AX
        POPFL                                   /* set Id|Ac */
        PUSHFL
        POPL    BX                              /* retrieve value */
        MOVL    $0, AX
        PUSHL   AX
        POPFL                                   /* clear Id|Ac, EFLAGS initialised */
        PUSHFL
        POPL    AX                              /* retrieve value */
        XORL    BX, AX
        TESTL   $0x040000, AX                   /* Ac */
        JZ      _cpu386                         /* can't set this bit on 386 */
        TESTL   $0x200000, AX                   /* Id */
        JZ      _cpu486                         /* can't toggle this bit on some 486 */
        /* load registers */
        MOVL    regs+4(FP), BP
        MOVL    fn+0(FP), AX                    /* cpuid function */
        MOVL    4(BP), BX
        MOVL    8(BP), CX                       /* typically an index */
        MOVL    12(BP), DX
        CPUID
        JMP     _cpuid
_cpu486:
        MOVL    $0x400, AX
        JMP     _maybezapax
_cpu386:
        MOVL    $0x300, AX
_maybezapax:
        CMPL    fn+0(FP), $1
        JE      _zaprest
        XORL    AX, AX
_zaprest:
        XORL    BX, BX
        XORL    CX, CX
        XORL    DX, DX
_cpuid:
        MOVL    regs+4(FP), BP
        MOVL    AX, 0(BP)
        MOVL    BX, 4(BP)
        MOVL    CX, 8(BP)
        MOVL    DX, 12(BP)
        RET






TEXT arch_mul64fract(SB), $0
/*
 * Multiply two 64-bit number s and keep the middle 64 bits from the 128-bit result
 * See ../port/tod.c for motivation.
 */
        MOVL    r+0(FP), CX
        XORL    BX, BX                          /* BX = 0 */

        MOVL    a+8(FP), AX
        MULL    b+16(FP)                        /* a1*b1 */
        MOVL    AX, 4(CX)                       /* r2 = lo(a1*b1) */

        MOVL    a+8(FP), AX
        MULL    b+12(FP)                        /* a1*b0 */
        MOVL    AX, 0(CX)                       /* r1 = lo(a1*b0) */
        ADDL    DX, 4(CX)                       /* r2 += hi(a1*b0) */

        MOVL    a+4(FP), AX
        MULL    b+16(FP)                        /* a0*b1 */
        ADDL    AX, 0(CX)                       /* r1 += lo(a0*b1) */
        ADCL    DX, 4(CX)                       /* r2 += hi(a0*b1) + carry */

        MOVL    a+4(FP), AX
        MULL    b+12(FP)                        /* a0*b0 */
        ADDL    DX, 0(CX)                       /* r1 += hi(a0*b0) */
        ADCL    BX, 4(CX)                       /* r2 += carry */
        RET
@

%//TEXT xchgw(SB), $0
%//      MOVL    v+4(FP), AX
%//      MOVL    p+0(FP), BX
%//      XCHGW   AX, (BX)
%//      RET


\subsection*{[[init/386/l_multiboot.s]]}


\subsection*{[[init/386/main.c]]}



<<function options(x86)>>=
static void
options(void)
{
        long i, n;
        char *cp, *line[MAXCONF], *p, *q;
        ulong l;
        kern_addr2 m;

        if(multiboot != nil){
                cp = BOOTARGS;
                *cp = 0;
                if((*multiboot & 8) != 0 && multiboot[5] > 0){
                        m = KADDR(multiboot[6]);
                        l = m[1] - m[0];
                        m = KADDR(m[0]);
                        if(l >= BOOTARGSLEN)
                                l = BOOTARGSLEN - 1;
                        memmove(cp, m, l);
                        cp[l] = 0;
                }
        }

        /*
         *  parse configuration args from dos file plan9.ini
         */
        cp = BOOTARGS;  /* where b.com leaves its config */
        cp[BOOTARGSLEN-1] = 0;

        /*
         * Strip out '\r', change '\t' -> ' '.
         */
        p = cp;
        for(q = cp; *q; q++){
                if(*q == '\r')
                        continue;
                if(*q == '\t')
                        *q = ' ';
                *p++ = *q;
        }
        *p = 0;

        n = getfields(cp, line, MAXCONF, 1, "\n");
        for(i = 0; i < n; i++){
                if(*line[i] == '#')
                        continue;
                cp = strchr(line[i], '=');
                if(cp == nil)
                        continue;
                *cp++ = '\0';
                confname[nconf] = line[i];
                confval[nconf] = cp;
                nconf++;
        }
}
@


<<function writeconf(x86)>>=
static void
writeconf(void)
{
        char *p, *q;
        int n;

        p = getconfenv();

        if(waserror()) {
                free(p);
                nexterror();
        }

        /* convert to name=value\n format */
        for(q=p; *q; q++) {
                q += strlen(q);
                *q = '=';
                q += strlen(q);
                *q = '\n';
        }
        n = q - p + 1;
        if(n >= BOOTARGSLEN)
                error("kernel configuration too large");
        memset(BOOTLINE, 0, BOOTLINELEN);
        memmove(BOOTARGS, p, n);
        poperror();
        free(p);
}
@


<<function pusharg(x86)>>=
uchar *
pusharg(char *p)
{
        int n;

        n = strlen(p)+1;
        sp -= n;
        memmove(sp, p, n);
        return sp;
}
@


<<function bootargs(x86)>>=
void
bootargs(void *base)
{
        int i, ac;
        uchar *av[32];
        uchar **lsp;
        char *cp = BOOTLINE;
        char buf[64];

        sp = (uchar*)base + BY2PG - Ustkheadroom;

        ac = 0;
        av[ac++] = pusharg("/386/9dos");

        /* when boot is changed to only use rc, this code can go away */
        cp[BOOTLINELEN-1] = 0;
        buf[0] = 0;
        if(strncmp(cp, "fd", 2) == 0){
                snprint(buf, sizeof buf, "local!#f/fd%lddisk",
                        strtol(cp+2, 0, 0));
                av[ac++] = pusharg(buf);
        } else if(strncmp(cp, "sd", 2) == 0){
                snprint(buf, sizeof buf, "local!#S/sd%c%c/fs", *(cp+2), *(cp+3));
                av[ac++] = pusharg(buf);
        } else if(strncmp(cp, "ether", 5) == 0)
                av[ac++] = pusharg("-n");

        /* 4 byte word align stack */
        sp = (uchar*)((ulong)sp & ~3);

        /* build argc, argv on stack */
        sp -= (ac+1)*sizeof(sp);
        lsp = (uchar**)sp;
        for(i = 0; i < ac; i++)
                *lsp++ = av[i] + ((USTKTOP - BY2PG) - (ulong)base);
        *lsp = 0;
        sp += (USTKTOP - BY2PG) - (ulong)base - sizeof(ulong);
}
@




<<global mathmsg(x86)>>=
static char* mathmsg[] =
{
        nil,    /* handled below */
        "denormalized operand",
        "division by zero",
        "numeric overflow",
        "numeric underflow",
        "precision loss",
};
@



<<function isaconfig(x86)>>=
int
main_isaconfig(char *class, int ctlrno, ISAConf *isa)
{
        char cc[32], *p;
        int i;

        snprint(cc, sizeof cc, "%s%d", class, ctlrno);
        p = getconf(cc);
        if(p == nil)
                return 0;

        isa->type = "";
        isa->nopt = tokenize(p, isa->opt, NISAOPT);
        for(i = 0; i < isa->nopt; i++){
                p = isa->opt[i];
                if(cistrncmp(p, "type=", 5) == 0)
                        isa->type = p + 5;
                else if(cistrncmp(p, "port=", 5) == 0)
                        isa->port = strtoul(p+5, &p, 0);
                else if(cistrncmp(p, "irq=", 4) == 0)
                        isa->irq = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "dma=", 4) == 0)
                        isa->dma = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "mem=", 4) == 0)
                        isa->mem = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "size=", 5) == 0)
                        isa->size = strtoul(p+5, &p, 0);
                else if(cistrncmp(p, "freq=", 5) == 0)
                        isa->freq = strtoul(p+5, &p, 0);
        }
        return 1;
}
@



<<init/386/main.c>>=
<<kernel basic includes>>

#include        "io.h"
#include        "mp.h"

// initcode binary
#include        "init.h"
// rebootcode binary
#include        "reboot.h"

#include        <ureg.h>
#include        <pool.h>
#include        <tos.h>

void bootargs(void*);

// part of a trick to remove some backward dependencies
<<main.c forward decl for backward deps(x86)>>

// conf.c
extern  Dev*  conf_devtab[];
// ??
extern  char* conffile;
//extern  uchar initcode[]; in init.h

extern void (*i8237alloc)(void);

//*****************************************************************************
// Configuration
//*****************************************************************************
// See globals in portdat_globals.h

//*****************************************************************************
// Boot parameters (not used by pad)
//*****************************************************************************

/*
 * Where configuration info is left for the loaded program.
 * This will turn into a structure as more is done by the boot loader
 * (e.g. why parse the .ini file twice?).
 * There are 3584 bytes available at CONFADDR.
 */
#define BOOTLINE        ((char*)CONFADDR)
#define BOOTLINELEN     64
#define BOOTARGS        ((char*)(CONFADDR+BOOTLINELEN))
#define BOOTARGSLEN     (4096-0x200-BOOTLINELEN)


enum {
        /* space for syscall args, return PC, top-of-stack struct */
        Ustkheadroom    = sizeof(Sargs) + sizeof(uintptr) + sizeof(Tos),
};

//char bootdisk[KNAMELEN];

// Global! set by bootargs()
uchar *sp;      /* user stack of init proc */

//@Scheck: Assembly
extern phys_addr *multiboot;

<<function options(x86)>>

<<function writeconf(x86)>>

//*****************************************************************************
// Cpu init
//*****************************************************************************

<<function cpuinit(x86)>>

<<function cpu0init(x86)>>

//*****************************************************************************
// Conf init
//*****************************************************************************

<<function confinit(x86)>>

//*****************************************************************************
// First process init
//*****************************************************************************

<<function init0(x86)>>

<<function pusharg(x86)>>

//TODO: get rid of as have simplified boot process, no plan9.ini
<<function bootargs(x86)>>

<<function userinit(x86)>>

//*****************************************************************************
// Math coprocessor
//*****************************************************************************

<<global mathmsg(x86)>>

<<function mathstate(x86)>>

<<function mathnote(x86)>>

<<function matherror(x86)>>

<<function mathemu(x86)>>

<<function mathover(x86)>>

<<function mathinit(x86)>>

//*****************************************************************************
// Shutdown/reboot
//*****************************************************************************

<<function shutdown(x86)>>

<<function exit(x86)>>

<<function reboot(x86)>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<function isaconfig(x86)>>

//*****************************************************************************
// Main entry point!
//*****************************************************************************

<<function main(x86)>>
@


\section{[[memory/386/]]}

\subsection*{[[memory/386/mem.h]]}

<<memory/386/mem.h>>=
/*
 * Memory and machine-specific definitions.  Used in C and assembler.
 */

/*
 * Sizes
 */
//defined in dat.h misc_constants
//#define KB      1024
//#define MB      (KB*KB)

#define BI2BY   8     /* bits per byte */
#define BI2WD   32      /* bits per word */

#define BY2WD   4     /* bytes per word */
#define BY2V    8     /* bytes per double word */

#define BY2PG   4096      /* bytes per page */
#define WD2PG   (BY2PG/BY2WD)   /* words per page */
#define PGSHIFT   12      /* log(BY2PG) */

<<constant BLOCKALIGN(x86)>>

// Intel specific
//#define BY2XPG    (4096*1024)   /* bytes per big page */

<<constant FPalign(x86)>>

<<constant MAXCPUS(x86)>>
<<constant KSTACK(x86)>>

/*
 * Time
 */
<<constant HZ(x86)>>

/*
 *  Address spaces
 */

// 0x10 = 16
// 0x100 = 256
// 0x1000 = 4Ko (1 page)
// 0x10000 = 64Ko
// 0x100000 = 1Mo
// 0x1000000 = 256Mo
// note: graphic card memory is at 0xb8000 so safer to go to 1Mo for kernel

<<constant KZERO(x86)>>
<<constant KTZERO(x86)>>

<<constant UZERO(x86)>>
<<constant UTZERO(x86)>>

<<function UTROUND(x86)>>
#define USTKTOP   (VMAP-BY2PG)    /* byte just beyond user stack */
#define USTKSIZE  (16*1024*1024)    /* size of user stack */
<<constant TSTKTOP(x86)>>
<<constant TSTKSIZ(x86)>>

<<constant MAXKPA(x86)>>

<<constant VPTSIZE(x86)>>
<<constant VPT(x86)>>

<<constant KMAPSIZE(x86)>>
<<constant KMAP(x86)>>

<<constant VMAPSIZE(x86)>>
<<constant VMAP(x86)>>
/*
 * Fundamental addresses - bottom 64kB saved for return to real mode
 */
#define CONFADDR  (KZERO+0x1200)    /* info passed from boot loader */

<<constant TMPADDR(x86)>>

#define APBOOTSTRAP (KZERO+0x3000)    /* AP bootstrap code */

#define RMUADDR   (KZERO+0x7C00)    /* real mode Ureg */
#define RMCODE    (KZERO+0x8000)    /* copy of first page of KTEXT */
#define RMBUF   (KZERO+0x9000)    /* buffer for user space - known to vga */

<<constant IDTADDR(x86)>>
#define REBOOTADDR  (0x11000)   /* reboot code - physical address */

#define CPU0PD   (KZERO+0x12000)   /* bootstrap processor PD */
//@Scheck: not dead, use in l.s
#define CPU0PT   (KZERO+0x13000)   /* bootstrap processor PT for 0-4MB */
#define CPU0GDT   (KZERO+0x14000)   /* bootstrap processor GDT */

#define CPUADDR  (KZERO+0x15000)   /* as seen by current processor */
#define CPU0CPU  (KZERO+0x16000)   /* Cpu for bootstrap processor */
#define CPUSIZE  BY2PG

#define CPU0END   (CPU0CPU+BY2PG)

/*
 * N.B.  ramscan() knows that CPU0END is the end of reserved data
 * N.B.  _setup_pagination knows that CPU0PD is the first reserved page
 * and that there are 5 of them.
 */
// MemMin in memory.c must start at the end of what CPU0PT covers (so 4MB)


// could be an enum but this also used from assembly
<<constant x86 segments>>

<<constant SELGDT(x86)>>
//#define SELLDT  (1<<2)  /* selector is in ldt */

<<macro SELECTOR(x86)>>

<<constant x86 segment selectors>>

<<constant segment field extractors(x86)>>

/*
 *  virtual MMU
 */
<<constant PAGETABMAPMEM(x86)>>
<<constant PAGETABSIZE(x86)>>
<<constant PAGEDIRSIZE(x86)>>
<<constant SMALLPAGEDIRSIZE(x86)>>

#define PPN(x)    ((x)&~(BY2PG-1))

<<constant PTExxx(x86)>>

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. 
 */
#define PDX(va)   ((((virt_addr)(va))>>22) & 0x03FF)
#define PTX(va)   ((((virt_addr)(va))>>12) & 0x03FF)
// 0x03FF = 1023, so 10 bits, put 1024-1 no?

#define getpgcolor(a) 0

<<constant VectorSYSCALL(x86)>>
@


\subsection*{[[memory/386/dat_memory.h]]}


<<memory/386/dat_memory.h>>=

#define NCOLOR 1

// define things used in Proc, for mmu.c to work on
/*
 *  MMU stuff in proc
 */
<<struct ArchProc(x86)>>

<<struct KMap(x86)>>
<<macro VA(x86)>>

@


\subsection*{[[memory/386/memory.c]]}

\ifallcode
<<memory.c forward decl(x86)>>=
typedef struct Map Map;
typedef struct RMap RMap;
@
\fi

<<memory.c debugging macro(x86)>>=
#define MEMDEBUG    0
@



<<memory/386/memory.c>>=
/*
 * Size memory and create the kernel page-tables on the fly while doing so.
 * Called from main(), this code should only be run by the bootstrap processor.
 *
 * MemMin is what the bootstrap code in l.s has already mapped;
 * MemMax is the limit of physical memory to scan.
 */
<<kernel basic includes>>
#include "io.h"
#include <ureg.h>

<<memory.c debugging macro(x86)>>

<<enum memkind(x86)>>

enum {
    MemMin      = 4*MB,
    MemMax      = (3*1024+768)*MB,
};
// coupling: with l.s for MemMin. 
// Why MemMax is not 4Go? because iterate by 256MB each time?

<<memory.c forward decl(x86)>>
<<struct Map(x86)>>

<<struct RMap(x86)>>

/* 
 * Memory allocation tracking.
 */
static Map mapupa[16];
static RMap rmapupa = {
    "unallocated unbacked physical memory",
    mapupa,
    &mapupa[nelem(mapupa)-1],
};

<<global mapram(x86)>>

static Map mapumb[64];
static RMap rmapumb = {
    "upper memory block",
    mapumb,
    &mapumb[nelem(mapumb)-1],
};

static Map mapumbrw[16];
static RMap rmapumbrw = {
    "UMB device memory",
    mapumbrw,
    &mapumbrw[nelem(mapumbrw)-1],
};

<<function mapprint(x86)>>

<<function memdebug(x86)>>

<<function mapfree(x86)>>

<<function mapalloc(x86)>>

<<function rampage(x86)>>

<<function umbscan(x86)>>

<<function sigscan(x86)>>

<<function sigsearch(x86)>>

<<function lowraminit(x86)>>

<<function ramscan(x86)>>

<<function meminit(x86)>>

<<function upaalloc(x86)>>

<<function upareserve(x86)>>

<<function memorysummary(x86)>>

@


%static char *etypes[] =
%{
%    "type=0",
%    "memory",
%    "reserved",
%    "acpi reclaim",
%    "acpi nvs",
%};

%
%
%//void
%//upafree(ulong pa, int size)
%//{
%//  mapfree(&rmapupa, pa, size);
%//}
%
%
%//ulong
%//umbrwmalloc(ulong addr, int size, int align)
%//{
%//  ulong a;
%//  uchar o[2], *p;
%//
%//  if(a = mapalloc(&rmapumbrw, addr, size, align))
%//      return(ulong)KADDR(a);
%//
%//  /*
%//   * Perhaps the memory wasn't visible before
%//   * the interface is initialised, so try again.
%//   */
%//  if((a = umbmalloc(addr, size, align)) == 0)
%//      return 0;
%//  p = (uchar*)a;
%//  o[0] = p[0];
%//  p[0] = 0xCC;
%//  o[1] = p[size-1];
%//  p[size-1] = 0xCC;
%//  if(p[0] == 0xCC && p[size-1] == 0xCC){
%//      p[0] = o[0];
%//      p[size-1] = o[1];
%//      return a;
%//  }
%//  umbfree(a, size);
%//
%//  return 0;
%//}
%
%//void
%//umbrwfree(ulong addr, int size)
%//{
%//  mapfree(&rmapumbrw, PADDR(addr), size);
%//}


%/*
% * Allocate memory from the upper memory blocks.
% */
%kern_addr
%umbmalloc(ulong addr, int size, int align)
%{
%    ulong a;
%
%    if(a = mapalloc(&rmapumb, addr, size, align))
%        return (ulong)KADDR(a);
%
%    return nilptr;
%}

%void
%umbfree(ulong addr, int size)
%{
%    mapfree(&rmapumb, PADDR(addr), size);
%}


% used by screen.c, devpccard.c
<<function upaalloc(x86)>>=
/*
 * Give out otherwise-unused physical address space
 * for use in configuring devices.  Note that unlike upamalloc
 * before it, upaalloc does not map the physical address
 * into virtual memory.  Call vmap to do that.
 */
ulong
upaalloc(int size, int align)
{
    ulong a;

    a = mapalloc(&rmapupa, 0, size, align);
    if(a == 0){
        print("out of physical address space allocating %d\n", size);
        mapprint(&rmapupa);
    }
    return a;
}
@



\subsection*{[[memory/386/mmu.c]]}

\ifallcode
<<mmu.c forward decl(x86)>>=
static void taskswitch(ulong, ulong);
static void memglobal(void);
static int findhole(ulong *a, int n, int count);
static ulong vmapalloc(ulong size);
static void pdunmap(ulong*, ulong, int);
@
\fi



%// called? mv in debugging section? with C-t C-t stuff?
<<function checkpagerefs>>=
void
checkpagerefs(void)
{
    int s;
    ulong i, np, nwrong;
    ulong *ref;
    
    np = palloc.user;
    ref = malloc(np*sizeof ref[0]);
    if(ref == nil){
        print("checkpagerefs: out of memory\n");
        return;
    }
    
    /*
     * This may not be exact if there are other processes
     * holding refs to pages on their stacks.  The hope is
     * that if you run it on a quiescent system it will still
     * be useful.
     */
    s = arch_splhi();
    lock(&palloc);
    arch_countpagerefs(ref, 0);
    portcountpagerefs(ref, 0);
    nwrong = 0;
    for(i=0; i<np; i++){
        if(palloc.pages[i].ref != ref[i]){
            iprint("page %#.8lux ref %d actual %lud\n", 
                palloc.pages[i].pa, palloc.pages[i].ref, ref[i]);
            ref[i] = 1;
            nwrong++;
        }else
            ref[i] = 0;
    }
    arch_countpagerefs(ref, 1);
    portcountpagerefs(ref, 1);
    iprint("%lud mistakes found\n", nwrong);
    unlock(&palloc);
    arch_splx(s);
}
@

<<[[Segment]] other fields>>=
    ulong mark;   /* portcountrefs */
@

<<function portcountpagerefs>>=
void
portcountpagerefs(ulong *ref, int print)
{
    ulong i, j, k, ns, n;
    Page **pg, *entry;
    Proc *p;
    Pagetable *pt;
    Segment *s;

    /*
     * Pages in segments.  s->mark avoids double-counting.
     */
    n = 0;
    ns = 0;
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        for(j=0; j<NSEG; j++){
            s = p->seg[j];
            if(s)
                s->mark = 0;
        }
    }
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        for(j=0; j<NSEG; j++){
            s = p->seg[j];
            if(s == nil || s->mark++)
                continue;
            ns++;
            for(k=0; k<s->pagedirsize; k++){
                pt = s->pagedir[k];
                if(pt == nil)
                    continue;
                for(pg = pt->first; pg <= pt->last; pg++){
                    entry = *pg;
                    if(pagedout(entry))
                        continue;
                    if(print){
                        if(ref[pagenumber(entry)])
                            iprint("page %#.8lux in segment %#p\n", entry->pa, s);
                        continue;
                    }
                    if(ref[pagenumber(entry)]++ == 0)
                        n++;
                }
            }
        }
    }
    if(!print){
        iprint("%lud pages in %lud segments\n", n, ns);
        for(i=0; i<conf.nproc; i++){
            p = proctab(i);
            for(j=0; j<NSEG; j++){
                s = p->seg[j];
                if(s == nil)
                    continue;
                if(s->ref != s->mark){
                    iprint("segment %#p (used by proc %lud pid %lud) has bad ref count %lud actual %lud\n",
                        s, i, p->pid, s->ref, s->mark);
                }
            }
        }
    }
}
@




<<function countpagerefs(x86)>>=
/*
 * More debugging.
 */
void
arch_countpagerefs(ulong *ref, int print)
{
    int i, n;
    Cpu *mm;
    Page *pg;
    Proc *p;
    
    n = 0;
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        if(p->mmupd){
            if(print){
                if(ref[pagenumber(p->mmupd)])
                    iprint("page %#.8lux is proc %d (pid %lud) pd\n",
                        p->mmupd->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(p->mmupd)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is proc %d (pid %lud) pd but has other refs!\n",
                    p->mmupd->pa, i, p->pid);
        }
        <<[[countpagerefs()]] handle kmaptable(x86)>>
        for(pg=p->mmuused; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is on proc %d (pid %lud) mmuused\n",
                        pg->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is on proc %d (pid %lud) mmuused but has other refs!\n",
                    pg->pa, i, p->pid);
        }
        for(pg=p->mmufree; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is on proc %d (pid %lud) mmufree\n",
                        pg->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is on proc %d (pid %lud) mmufree but has other refs!\n",
                    pg->pa, i, p->pid);
        }
    }
    if(!print)
        iprint("%d pages in proc mmu\n", n);
    n = 0;
    for(i=0; i<conf.ncpu; i++){
        mm = CPUS(i);
        for(pg=mm->mmupdpool; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is in cpu%d mmupdpool\n",
                        pg->pa, i);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is in cpu%d mmupdpool but has other refs!\n",
                    pg->pa, i);
        }
    }
    if(!print){
        iprint("%d pages in cpu mmupdpools\n", n);
        for(i=0; i<conf.ncpu; i++)
            iprint("cpu%d: %d mmupdalloc, %d mmupdfree\n",
                i, CPUS(i)->mmupdalloc, CPUS(i)->mmupdfree);
    }
}
@

<<[[Cpu]] [[Arch]] other fields(x86)>>=
int mmupdalloc;
int mmupdfree;
@



<<memory/386/mmu.c>>=
/*
 * Memory mappings.  Life was easier when 2G of memory was enough.
 *
 * The kernel memory starts at KZERO, with the text loaded at KZERO+1M
 * (9load sits under 1M during the load).  The memory from KZERO to the
 * top of memory is mapped 1-1 with physical memory, starting at physical
 * address 0.  All kernel memory and data structures (i.e., the entries stored
 * into conf.mem) must sit in this physical range: if KZERO is at 0xF0000000,
 * then the kernel can only have 256MB of memory for itself.
 * 
 * The 256M below KZERO comprises three parts.  The lowest 4M is the
 * virtual page table, a virtual address representation of the current 
 * page table tree.  The second 4M is used for temporary per-process
 * mappings managed by kmap and kunmap.  The remaining 248M is used
 * for global (shared by all procs and all processors) device memory
 * mappings and managed by vmap and vunmap.  The total amount (256M)
 * could probably be reduced somewhat if desired.  The largest device
 * mapping is that of the video card, and even though modern video cards
 * have embarrassing amounts of memory, the video drivers only use one
 * frame buffer worth (at most 16M).  Each is described in more detail below.
 *
 * The VPT is a 4M frame constructed by inserting the pd into itself.
 * This short-circuits one level of the page tables, with the result that 
 * the contents of second-level page tables can be accessed at VPT.  
 * We use the VPT to edit the page tables (see mmu) after inserting them
 * into the page directory.  It is a convenient mechanism for mapping what
 * might be otherwise-inaccessible pages.  The idea was borrowed from
 * the Exokernel.
 *
 * The VPT doesn't solve all our problems, because we still need to 
 * prepare page directories before we can install them.  For that, we
 * use tmpmap/tmpunmap, which map a single page at TMPADDR.
 */

<<kernel basic includes>>
#include    "io.h"

<<macros xxxSEGM(x86)>>

<<global gdt(x86)>>

<<mmu.c forward decl(x86)>>

<<global vpt and vpd(x86)>>

<<function mmuinit0(x86)>>

<<global didmmuinit(x86)>>

<<function mmuinit(x86)>>

<<function memglobal(x86)>>

<<function flushmmu(x86)>>

<<function flushpg(x86)>>

<<function mmupdalloc(x86)>>

<<function mmupdfree(x86)>>

<<function mmuptefree(x86)>>

<<function taskswitch(x86)>>

<<function mmuswitch(x86)>>

<<function mmurelease(x86)>>

<<function upallocmmupd(x86)>>

<<function putmmu(x86)>>

<<function checkmmu(x86)>>

<<function mmuwalk(x86)>>

/*
 * Device mappings are shared by all procs and processors and
 * live in the virtual range VMAP to VMAP+VMAPSIZE.  The master
 * copy of the mappings is stored in cpu0->pdproto, and they are
 * paged in from there as necessary by vmapsync during faults.
 */

<<global vmaplock(x86)>>

int pdmap(kern_addr2 mmupd, ulong pa, virt_addr va, int size);

<<function vmap(x86)>>

<<function findhole(x86)>>

<<function vmapalloc(x86)>>

<<function vunmap(x86)>>

<<function pdmap(x86)>>

<<function pdunmap(x86)>>

<<function vmapsync(x86)>>

/*
 * KMap is used to map individual pages into virtual memory.
 * It is rare to have more than a few KMaps at a time (in the 
 * absence of interrupts, only two at a time are ever used,
 * but interrupts can stack).  The mappings are local to a process,
 * so we can use the same range of virtual address space for
 * all processes without any coordination.
 */

<<global kpt(x86)>>
<<constant NKPT(x86)>>

<<function kmap(x86)>>

<<function kunmap(x86)>>

/*
 * Temporary one-page mapping used to edit page directories.
 *
 */

<<function tmpmap(x86)>>

<<function tmpunmap(x86)>>

<<function kaddr(x86)>>

<<function paddr(x86)>>

<<function countpagerefs(x86)>>

<<function cankaddr(x86)>>

@

\section{[[interrupts/386/]]}

\subsection*{[[interrupts/386/dat_interrupts.h]]}

<<dat_interrupts.h>>=

// Used only in 386/, so could be put in arch/, but used by the .c here.
// Used to be in io.h but more important than just a set of enums for IO
// so put here.

<<enum vector(x86)>>

<<enum irq(x86)>>
  
<<struct Vctl(x86)>>

// array<list<Vctl>>, xalloc'ed
//IMPORTANT: static Vctl *vctl[256]; (in trap.c)

@

\subsection*{[[interrupts/386/l_trap.s]]}

<<l_trap.s>>=
#include "mem.h"

<<function _strayintr(x86)>>

<<function _strayintrx(x86)>>

<<function forkret(x86)>>

<<global vectortable(x86)>>
@

\subsection*{[[interrupts/386/i8259.c]]}


<<i8259.c>>=
<<kernel basic includes>>
#include "io.h"

/*
 *  8259 interrupt controllers
 */
enum
{
    Int0ctl=    0x20,       /* control port (ICW1, OCW2, OCW3) */
    Int0aux=    0x21,       /* everything else (ICW2, ICW3, ICW4, OCW1) */
    Int1ctl=    0xA0,       /* control port */
    Int1aux=    0xA1,       /* everything else (ICW2, ICW3, ICW4, OCW1) */

    Icw1=       0x10,       /* select bit in ctl register */
    Ocw2=       0x00,
    Ocw3=       0x08,

    EOI=        0x20,       /* non-specific end of interrupt */

    Elcr1=      0x4D0,      /* Edge/Level Triggered Register */
    Elcr2=      0x4D1,
};

<<global i8259lock(x86)>>
static int i8259mask = 0xFFFF;      /* disabled interrupts */
int i8259elcr;              /* mask of level-triggered interrupts */

<<function i8259init(x86)>>

<<function i8259isr(x86)>>

<<function i8259enable(x86)>>

<<function i8259vecno(x86)>>

<<function i8259disable(x86)>>

<<function i8259on(x86)>>

<<function i8259off(x86)>>

@



\subsection*{[[interrupts/386/trap.c]]}

\ifallcode
<<trap.c forward decl(x86)>>=
void    noted(Ureg*, ulong);
int     notify(Ureg*);
void        dumpregs(Ureg*);

static void debugbpt(Ureg*, void*);
static void fault386(Ureg*, void*);
static void doublefault(Ureg*, void*);
static void unexpected(Ureg*, void*);
static void _dumpstack(Ureg*);

extern void checkpages(void);
@ 
//extern void checkfault(ulong, ulong);
\fi


<<function nmienable(x86)>>=
static void
nmienable(void)
{
    int x;

    /*
     * Hack: should be locked with NVRAM access.
     */
    outb(0x70, 0x80);       /* NMI latch clear */
    outb(0x70, 0);

    x = inb(0x61) & 0x07;       /* Enable NMI */
    outb(0x61, 0x08|x);
    outb(0x61, x);
}
@ 


<<interrupts/386/trap.c>>=
<<kernel basic includes>>

#include    "io.h"

#include    <tos.h>
#include    <ureg.h>
#include    <trace.h>

//*****************************************************************************
// Globals
//*****************************************************************************

<<global trapinited(x86)>>

<<global vctllock(x86)>>
<<global vctl(x86)>>

enum
{
   <<constant Ntimevec(x86)>>
};
<<global intrtimes(x86)>>

//*****************************************************************************
// Forward decl
//*****************************************************************************
<<trap.c forward decl(x86)>>

//*****************************************************************************
// Interrupts enable/disable
//*****************************************************************************

<<function intrenable(x86)>>

<<function intrdisable(x86)>>

//*****************************************************************************
// Init
//*****************************************************************************

<<function irqallocread(x86)>>

<<function trapenable(x86)>>

<<function nmienable(x86)>>

<<function trapinit0(x86)>>

<<function trapinit(x86)>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<global excname(x86)>>

<<function intrtime(x86)>>

<<function kexit(x86)>>

<<function trap(x86)>>

<<function dumpregs2(x86)>>

<<function dumpregs(x86)>>

<<function callwithureg(x86)>>

// was in fns.h before as a macro
// #define userureg(ur) (((ur)->cs & 0xFFFF) == UESEL)
<<function userureg(x86)>>

<<function _dumpstack(x86)>>

<<function dumpstack(x86)>>

<<function debugbpt(x86)>>

<<function doublefault(x86)>>

<<function unexpected(x86)>>

<<function fault386>>

//*****************************************************************************
// Syscall
//*****************************************************************************

/*
 *  system calls
 */
#include "../port/systab.h"

<<function syscall(x86)>>

<<function notify(x86)>>

<<function noted(x86)>>
//old: #define evenaddr(x)       /* x86 doesn't care */
void
arch_validalign(uintptr addr, unsigned align)
{
 /*
  * Plan 9 is a 32-bit O/S, and the hardware it runs on
  * does not usually have instructions which move 64-bit
  * quantities directly, synthesizing the operations
  * with 32-bit move instructions. Therefore, the compiler
  * (and hardware) usually only enforce 32-bit alignment,
  * if at all.
  *
  * Take this out if the architecture warrants it.
  */
 if(align == sizeof(vlong))
  align = sizeof(long);

 /*
  * Check align is a power of 2, then addr alignment.
  */
 if((align != 0 && !(align & (align-1))) && !(addr & (align-1)))
  return;
 postnote(up, 1, "sys: odd address", NDebug);
 error(Ebadarg);
 /*NOTREACHED*/
}


<<function execregs(x86)>>

<<function userpc(x86)>>

<<function setregisters(x86)>>

<<function linkproc(x86)>>

<<function kprocchild(x86)>>

<<function forkchild(x86)>>

<<function setkernur(x86)>>

<<function dbgpc(x86)>>
@


\section{[[time/386/]]}

\subsection*{[[time/386/dat_time.h]]}

<<time/386/dat_time.h>>=

// Used only in 386/, so could be put in arch/ but used by the .c here.
// Actually used only in i8253.c but important so put here.

<<struct I8253(x86)>>

//IMPORTANT: I8253 i8253; (in i8253.c)
//IMPORTANT: also is interrupt i8253clock() calling clock.c:timerintr()
@

\subsection*{[[time/386/time.c]]}
%pad: I created this file. content was in arch.c before and
% in devarch.c before
%TODO: rename to clock.c? matches more bcm/

<<time/386/time.c>>=
<<kernel basic includes>>

<<function cycles and default implementation(x86)>>

<<function timerset(x86)>>

<<function us(x86)>>

<<function fastticks(x86)>>
@

\subsection*{[[time/386/i8253.c]]}

<<struct Watchdog(x86)>>=
struct Watchdog
{
    void    (*enable)(void);    /* watchdog enable */
    void    (*disable)(void);   /* watchdog disable */
    void    (*restart)(void);   /* watchdog restart */
    void    (*stat)(char*, char*);  /* watchdog statistics */
};
@

<<global watchdog(x86)>>=
Watchdog* watchdog;
int watchdogon;
@

<<function wdogpause(x86)>>=
/*
 * if the watchdog is running and we're on cpu 0 and ignoring (clock)
 * interrupts, disable the watchdog temporarily so that the (presumed)
 * long-running loop to follow will not trigger an NMI.
 * wdogresume restarts the watchdog if wdogpause stopped it.
 */
static int
wdogpause(void)
{
    int turndogoff;

    turndogoff = watchdogon && cpu->cpuno == 0 && !arch_islo();
    if (turndogoff) {
        watchdog->disable();
        watchdogon = 0;
    }
    return turndogoff;
}
@


<<function wdogresume(x86)>>=
static void
wdogresume(int resume)
{
    if (resume) {
        watchdog->enable();
        watchdogon = 1;
    }
}
@

<<function guesscpuhz(x86)>>=
void
guesscpuhz(int aalcycles)
{
    int loops, incr, x, y, dogwason;
    uvlong a, b, cpufreq;

    dogwason = wdogpause();     /* don't get NMI while busy looping */

    /* find biggest loop that doesn't wrap */
    incr = 16000000/(aalcycles*Arch_HZ*2);
    x = 2000;
    for(loops = incr; loops < 64*1024; loops += incr) {
    
        /*
         *  measure time for the loop
         *
         *          MOVL    loops,CX
         *  aaml1:      AAM
         *          LOOP    aaml1
         *
         *  the time for the loop should be independent of external
         *  cache and memory system since it fits in the execution
         *  prefetch buffer.
         *
         */
        outb(Tmode, Latch0);
        arch_cycles(&a);
        x = inb(T0cntr);
        x |= inb(T0cntr)<<8;
        aamloop(loops);
        outb(Tmode, Latch0);
        arch_cycles(&b);
        y = inb(T0cntr);
        y |= inb(T0cntr)<<8;
        x -= y;
    
        if(x < 0)
            x += Freq/Arch_HZ;

        if(x > Freq/(3*Arch_HZ))
            break;
    }
    wdogresume(dogwason);

    /*
     *  figure out clock frequency and a loop multiplier for delay().
     *  n.b. counter goes up by 2*Freq
     */
    if(x == 0)
        x = 1;          /* avoid division by zero on vmware 7 */
    cpufreq = (vlong)loops*((aalcycles*2*Freq)/x);
    cpu->loopconst = (cpufreq/1000)/aalcycles;    /* AAM+LOOP's for 1 ms */

    if(cpu->havetsc && a != b){  /* a == b means virtualbox has confused us */
        /* counter goes up by 2*Freq */
        b = (b-a)<<1;
        b *= Freq;
        b /= x;

        /*
         *  round to the nearest megahz
         */
        cpu->cpumhz = (b+500000)/1000000L;
        cpu->cpuhz = b;
        cpu->cyclefreq = b;
    } else {
        /*
         *  add in possible 0.5% error and convert to MHz
         */
        cpu->cpumhz = (cpufreq + cpufreq/200)/1000000;
        cpu->cpuhz = cpufreq;
    }

    /* don't divide by zero in trap.c */
    if (cpu->cpumhz == 0)
        panic("guesscpuhz: zero cpu->cpumhz");
    i8253.hz = Freq<<Tickshift;
}
@




<<function i8253read(x86)>>=
/*
 *  return the total ticks of counter 2.  We shift by
 *  8 to give timesync more wriggle room for interpretation
 *  of the frequency
 */
uvlong
i8253read(uvlong *hz)
{
    ushort y, x;
    uvlong ticks;

    if(hz)
        *hz = i8253.hz;

    ilock(&i8253);
    outb(Tmode, Latch2);
    y = inb(T2cntr);
    y |= inb(T2cntr)<<8;

    if(y < i8253.last)
        x = i8253.last - y;
    else {
        x = i8253.last + (0x10000 - y);
        if (x > 3*MaxPeriod) {
            outb(Tmode, Load2|Square);
            outb(T2cntr, 0);        /* low byte */
            outb(T2cntr, 0);        /* high byte */
            y = 0xFFFF;
            x = i8253.period;
        }
    }
    i8253.last = y;
    i8253.ticks += x>>1;
    ticks = i8253.ticks;
    iunlock(&i8253);

    return ticks<<Tickshift;
}
@

<<[[Cpu]] [[Arch]] other fields(x86)>>=
int loopconst;
@

<<function delay(x86)>>=
void
i8253_delay(int millisecs)
{
    if (millisecs > 10*1000)
        iprint("delay(%d) from %#p\n", millisecs,
            getcallerpc(&millisecs));
    if (watchdogon && cpu->cpuno == 0 && !arch_islo())
        for (; millisecs > Wdogms; millisecs -= Wdogms) {
            arch_delay(Wdogms);
            watchdog->restart();
        }
    millisecs *= cpu->loopconst;
    if(millisecs <= 0)
        millisecs = 1;
    aamloop(millisecs);
}
@


<<function microdelay(x86)>>=
void
i8253_microdelay(int microsecs)
{
    if (watchdogon && cpu->cpuno == 0 && !arch_islo())
        for (; microsecs > Wdogms*1000; microsecs -= Wdogms*1000) {
            arch_delay(Wdogms);
            watchdog->restart();
        }
    microsecs *= cpu->loopconst;
    microsecs /= 1000;
    if(microsecs <= 0)
        microsecs = 1;
    aamloop(microsecs);
}
@




<<i8253.c>>=
<<kernel basic includes>>
#include "io.h"

//*****************************************************************************
// Data
//*****************************************************************************

/*
 *  8253 timer
 */
enum
{
    T0cntr= 0x40,       /* counter ports */
    T1cntr= 0x41,       /* ... */
    T2cntr= 0x42,       /* ... */
    Tmode=  0x43,       /* mode port (control word register) */
    T2ctl=  0x61,       /* counter 2 control port */

    /* commands */
    Latch0= 0x00,       /* latch counter 0's value */
    Load0l= 0x10,       /* load counter 0's lsb */
    Load0m= 0x20,       /* load counter 0's msb */
    Load0=  0x30,       /* load counter 0 with 2 bytes */

    Latch1= 0x40,       /* latch counter 1's value */
    Load1l= 0x50,       /* load counter 1's lsb */
    Load1m= 0x60,       /* load counter 1's msb */
    Load1=  0x70,       /* load counter 1 with 2 bytes */

    Latch2= 0x80,       /* latch counter 2's value */
    Load2l= 0x90,       /* load counter 2's lsb */
    Load2m= 0xa0,       /* load counter 2's msb */
    Load2=  0xb0,       /* load counter 2 with 2 bytes */

    /* 8254 read-back command: everything > pc-at has an 8254 */
    Rdback= 0xc0,       /* readback counters & status */
    Rdnstat=0x10,       /* don't read status */
    Rdncnt= 0x20,       /* don't read counter value */
    Rd0cntr=0x02,       /* read back for which counter */
    Rd1cntr=0x04,
    Rd2cntr=0x08,

    /* modes */
    ModeMsk=0xe,
    Square= 0x6,        /* periodic square wave */
    Trigger=0x0,        /* interrupt on terminal count */
    Sstrobe=0x8,        /* software triggered strobe */

    /* T2ctl bits */
    T2gate= (1<<0),     /* enable T2 counting */
    T2spkr= (1<<1),     /* connect T2 out to speaker */
    T2out=  (1<<5),     /* output of T2 */
};

enum {
    <<constant Freq(x86)>>
    Tickshift=8,        /* extra accuracy */
    MaxPeriod=Freq/Arch_HZ,
    MinPeriod=Freq/(100*Arch_HZ),

    Wdogms  = 200,      /* ms between strokes */
};

<<global i8253(x86)>>

<<struct Watchdog(x86)>>

<<global watchdog(x86)>>


//*****************************************************************************
// Init
//*****************************************************************************

<<function i8253init(x86)>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<function wdogpause(x86)>>

<<function wdogresume(x86)>>

<<function guesscpuhz(x86)>>

<<function i8253timerset(x86)>>

<<interrupt callback i8253clock(x86)>>

<<function i8253enable(x86)>>

<<function i8253read(x86)>>

<<function delay(x86)>>

<<function microdelay(x86)>>

<<function perfticks(x86)>>
@

\section{[[processes/386/]]}

\subsection*{[[processes/386/dat_processes.h]]}

%/*
% *  things saved in the Proc structure during a notify
% */
%struct Arch_ProcNotsave
%{
%    ulong svflags;
%    ulong svcs;
%    ulong svss;
%};


<<processes/386/dat_processes.h>>=

<<constant AOUT_MAGIC(x86)>>

//*****************************************************************************
// Proc extensions
//*****************************************************************************

<<union ArchFPSave(x86)>>

@


\subsection*{[[processes/386/archgeneric.c]]}

<<archgeneric.c>>=
<<kernel basic includes>>

//todo: weird, if don't include this file, then can't declare arch in this file
// or I get some type signature mismatch
#include "io.h"

/*
 *  the following is a generic version of the
 *  architecture specific stuff
 */

<<function unimplemented(x86)>>

<<function archreset(x86)>>

<<global archgeneric(x86)>>

<<function archrevert(x86)>>

@

\subsection*{[[processes/386/l_switch.s]]}

<<l_switch.s>>=

// This file is used for process switching but also to emulate
// exceptions in C (via the waserror(), nexterror(), poperror() functions)

<<function gotolabel(x86)>>

<<function setlabel(x86)>>
@


\subsection*{[[processes/386/main_processes.c]]}


<<processes/386/main_processes.c>>=
<<kernel basic includes>>

<<function procsetup(x86)>>

<<function procsave(x86)>>

<<function procrestore(x86)>>

<<function fpsavealloc(x86)>>

<<function fpssesave(x86)>>

<<function fpsserestore(x86)>>

<<function idlehands(x86)>>
@


\subsection*{[[processes/386/mp.c]]}

<<enum vector cases(x86)>>=
    VectorLAPIC = VectorPIC+16, /* local APIC interrupts */
    VectorAPIC  = 65,   /* external APIC interrupts */
    MaxVectorAPIC = 255,
@

<<function archrevert(x86)>>=
void
archrevert(void)
{
    arch = &archgeneric;
}
@


<<[[Cpu]] [[Arch]] other fields(x86)>>=
vlong mtrrcap;
vlong mtrrdef;
vlong mtrrfix[11];
vlong mtrrvar[32];    /* 256 max. */
@ 

<<mp.c debugging macro(x86)>>=
//#define dprint(...)   if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
#define dprint if(mpdebug) print
int mpdebug;
@ 


<<[[Active]] other fields>>=
bool main_reached_sched;/* lets the added processors continue to schedinit*/
@
% main_reached_sched was called thunderbirdsareago

<<[[main()]] before schedinit()(x86)>>=
active.main_reached_sched = true;
@


<<mp.c>>=
<<kernel basic includes>>

#include "io.h"
#include "mp.h"

#include "apbootstrap.h"

#include <ureg.h>

<<mp.c debugging macro(x86)>>

/* from mpacpi.c */
extern Apic *bootapic;

extern void (*mpacpifunc)(void);

static PCMP* mppcmp;
static Bus* mpbus;
static Bus* mpbuslast;
static int mpisabus = -1;
static int mpeisabus = -1;
extern int i8259elcr;           /* mask of level-triggered interrupts */
/* static */ Apic mpapic[MaxAPICNO+1];
/* static */ int cpuno2apicno[MaxAPICNO+1];    /* inverse map: cpuno -> APIC ID */
/* static */ Apic ioapic[MaxAPICNO+1];
static Ref mpvnoref;            /* unique vector assignment */
static int mpcpuno = 1;
static Lock mpphysidlock;
static int mpphysid;

static char* buses[] = {
    "CBUSI ",
    "CBUSII",
    "EISA  ",
    "FUTURE",
    "INTERN",
    "ISA   ",
    "MBI   ",
    "MBII  ",
    "MCA   ",
    "MPI   ",
    "MPSA  ",
    "NUBUS ",
    "PCI   ",
    "PCMCIA",
    "TC    ",
    "VL    ",
    "VME   ",
    "XPRESS",
    0,
};

static Apic*
mkprocessor(PCMPprocessor* p)
{
    int apicno;
    Apic *apic;

    apicno = p->apicno;
    if(!(p->flags & PcmpEN) || apicno > MaxAPICNO)
        return 0;

    apic = &mpapic[apicno];
    apic->type = PcmpPROCESSOR;
    apic->apicno = apicno;
    apic->flags = p->flags;
    apic->lintr[0] = ApicIMASK;
    apic->lintr[1] = ApicIMASK;

    if(p->flags & PcmpBP){
        cpuno2apicno[0] = apicno;
        apic->cpuno = 0;
    }
    else{
        cpuno2apicno[mpcpuno] = apicno;
        apic->cpuno = mpcpuno;
        mpcpuno++;
    }

    return apic;
}

static Bus*
mkbus(PCMPbus* p)
{
    Bus *bus;
    int i;

    for(i = 0; buses[i]; i++){
        if(strncmp(buses[i], p->string, sizeof(p->string)) == 0)
            break;
    }
    if(buses[i] == 0)
        return 0;

    bus = xalloc(sizeof(Bus));
    if(mpbus)
        mpbuslast->next = bus;
    else
        mpbus = bus;
    mpbuslast = bus;

    bus->type = i;
    bus->busno = p->busno;
    if(bus->type == BusEISA){
        bus->po = PcmpLOW;
        bus->el = PcmpLEVEL;
        if(mpeisabus != -1)
            print("mkbus: more than one EISA bus\n");
        mpeisabus = bus->busno;
    }
    else if(bus->type == BusPCI){
        bus->po = PcmpLOW;
        bus->el = PcmpLEVEL;
    }
    else if(bus->type == BusISA){
        bus->po = PcmpHIGH;
        bus->el = PcmpEDGE;
        if(mpisabus != -1)
            print("mkbus: more than one ISA bus\n");
        mpisabus = bus->busno;
    }
    else{
        bus->po = PcmpHIGH;
        bus->el = PcmpEDGE;
    }

    return bus;
}

static Bus*
mpgetbus(int busno)
{
    Bus *bus;

    for(bus = mpbus; bus; bus = bus->next){
        if(bus->busno == busno)
            return bus;
    }
    print("mpgetbus: can't find bus %d\n", busno);

    return 0;
}

static Apic*
mkioapic(PCMPioapic* p)
{
    void *va;
    int apicno;
    Apic *apic;

    apicno = p->apicno;
    if(!(p->flags & PcmpEN) || apicno > MaxAPICNO)
        return 0;

    /*
     * Map the I/O APIC.
     */
    if((va = vmap(p->addr, 1024)) == nil)
        return 0;

    apic = &ioapic[apicno];
    apic->type = PcmpIOAPIC;
    apic->apicno = apicno;
    apic->addr = va;
    apic->paddr = p->addr;
    apic->flags = p->flags;

    return apic;
}

static Aintr*
mkiointr(PCMPintr* p)
{
    Bus *bus;
    Aintr *aintr;
    PCMPintr* pcmpintr;

    /*
     * According to the MultiProcessor Specification, a destination
     * I/O APIC of 0xFF means the signal is routed to all I/O APICs.
     * It's unclear how that can possibly be correct so treat it as
     * an error for now.
     */
    if(p->apicno == 0xFF)
        return 0;
    if((bus = mpgetbus(p->busno)) == 0)
        return 0;

    aintr = xalloc(sizeof(Aintr));
    aintr->intr = p;

    if(0)
        dprint("mkiointr: type %d intr type %d flags %#o "
            "bus %d irq %d apicno %d intin %d\n",
            p->type, p->intr, p->flags,
            p->busno, p->irq, p->apicno, p->intin);
    /*
     * Hack for Intel SR1520ML motherboard, which BIOS describes
     * the i82575 dual ethernet controllers incorrectly.
     */
    if(mppcmp && memcmp(mppcmp->product, "INTEL   X38MLST     ", 20) == 0){
        if(p->busno == 1 && p->intin == 16 && p->irq == 1){
            pcmpintr = malloc(sizeof(PCMPintr));
            if(pcmpintr == nil)
                panic("mkiointr: no memory");
            memmove(pcmpintr, p, sizeof(PCMPintr));
            print("mkiointr: %20.20s bus %d intin %d irq %d\n",
                (char*)mppcmp->product,
                pcmpintr->busno, pcmpintr->intin,
                pcmpintr->irq);
            pcmpintr->intin = 17;
            aintr->intr = pcmpintr;
        }
    }
    if ((unsigned)p->apicno >= nelem(mpapic))
        panic("mkiointr: apic %d out of range", p->apicno);
    aintr->apic = &ioapic[p->apicno];
    aintr->next = bus->aintr;
    bus->aintr = aintr;

    return aintr;
}

static int
mpintrinit(Bus* bus, PCMPintr* intr, int vno, int /*irq*/)
{
    int el, po, v;

    /*
     * Parse an I/O or Local APIC interrupt table entry and
     * return the encoded vector.
     */
    v = vno;

    po = intr->flags & PcmpPOMASK;
    el = intr->flags & PcmpELMASK;

    switch(intr->intr){

    default:                /* PcmpINT */
        v |= ApicFIXED;         /* no-op */
        break;

    case PcmpNMI:
        v |= ApicNMI;
        po = PcmpHIGH;
        el = PcmpEDGE;
        break;

    case PcmpSMI:
        v |= ApicSMI;
        break;

    case PcmpExtINT:
        v |= ApicExtINT;
        /*
         * The AMI Goliath doesn't boot successfully with it's LINTR0
         * entry which decodes to low+level. The PPro manual says ExtINT
         * should be level, whereas the Pentium is edge. Setting the
         * Goliath to edge+high seems to cure the problem. Other PPro
         * MP tables (e.g. ASUS P/I-P65UP5 have a entry which decodes
         * to edge+high, so who knows.
         * Perhaps it would be best just to not set an ExtINT entry at
         * all, it shouldn't be needed for SMP mode.
         */
        po = PcmpHIGH;
        el = PcmpEDGE;
        break;
    }

    /*
     */
    if(bus->type == BusEISA && !po && !el /*&& !(i8259elcr & (1<<irq))*/){
        po = PcmpHIGH;
        el = PcmpEDGE;
    }
    if(!po)
        po = bus->po;
    if(po == PcmpLOW)
        v |= ApicLOW;
    else if(po != PcmpHIGH){
        print("mpintrinit: bad polarity 0x%uX\n", po);
        return ApicIMASK;
    }

    if(!el)
        el = bus->el;
    if(el == PcmpLEVEL)
        v |= ApicLEVEL;
    else if(el != PcmpEDGE){
        print("mpintrinit: bad trigger 0x%uX\n", el);
        return ApicIMASK;
    }

    return v;
}

static int
mklintr(PCMPintr* p)
{
    Apic *apic;
    Bus *bus;
    int intin, v;

    /*
     * The offsets of vectors for LINT[01] are known to be
     * 0 and 1 from the local APIC vector space at VectorLAPIC.
     */
    if((bus = mpgetbus(p->busno)) == 0)
        return 0;
    intin = p->intin;

    /*
     * Pentium Pros have problems if LINT[01] are set to ExtINT
     * so just bag it, SMP mode shouldn't need ExtINT anyway.
     */
    if(p->intr == PcmpExtINT || p->intr == PcmpNMI)
        v = ApicIMASK;
    else
        v = mpintrinit(bus, p, VectorLAPIC+intin, p->irq);

    if(p->apicno == 0xFF){
        for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++){
            if((apic->flags & PcmpEN)
            && apic->type == PcmpPROCESSOR)
                apic->lintr[intin] = v;
        }
    }
    else{
        if ((unsigned)p->apicno >= nelem(mpapic))
            panic("mklintr: ioapic %d out of range", p->apicno);
        apic = &mpapic[p->apicno];
        if((apic->flags & PcmpEN) && apic->type == PcmpPROCESSOR)
            apic->lintr[intin] = v;
    }

    return v;
}

static void
checkmtrr(void)
{
    int i, vcnt;
    Cpu *cpu0;

    /*
     * If there are MTRR registers, snarf them for validation.
     */
    if(!(cpu->cpuiddx & Mtrr))
        return;

    rdmsr(0x0FE, &cpu->mtrrcap);
    rdmsr(0x2FF, &cpu->mtrrdef);
    if(cpu->mtrrcap & 0x0100){
        rdmsr(0x250, &cpu->mtrrfix[0]);
        rdmsr(0x258, &cpu->mtrrfix[1]);
        rdmsr(0x259, &cpu->mtrrfix[2]);
        for(i = 0; i < 8; i++)
            rdmsr(0x268+i, &cpu->mtrrfix[(i+3)]);
    }
    vcnt = cpu->mtrrcap & 0x00FF;
    if(vcnt > nelem(cpu->mtrrvar))
        vcnt = nelem(cpu->mtrrvar);
    for(i = 0; i < vcnt; i++)
        rdmsr(0x200+i, &cpu->mtrrvar[i]);

    /*
     * If not the bootstrap processor, compare.
     */
    if(cpu->cpuno == 0)
        return;

    cpu0 = CPUS(0);
    if(cpu0->mtrrcap != cpu->mtrrcap)
        print("mtrrcap%d: %lluX %lluX\n",
            cpu->cpuno, cpu0->mtrrcap, cpu->mtrrcap);
    if(cpu0->mtrrdef != cpu->mtrrdef)
        print("mtrrdef%d: %lluX %lluX\n",
            cpu->cpuno, cpu0->mtrrdef, cpu->mtrrdef);
    for(i = 0; i < 11; i++){
        if(cpu0->mtrrfix[i] != cpu->mtrrfix[i])
            print("mtrrfix%d: i%d: %lluX %lluX\n",
                cpu->cpuno, i, cpu0->mtrrfix[i], cpu->mtrrfix[i]);
    }
    for(i = 0; i < vcnt; i++){
        if(cpu0->mtrrvar[i] != cpu->mtrrvar[i])
            print("mtrrvar%d: i%d: %lluX %lluX\n",
                cpu->cpuno, i, cpu0->mtrrvar[i], cpu->mtrrvar[i]);
    }
}

static void
squidboy(Apic* apic)
{
//  iprint("Hello Squidboy\n");

    cpuinit();
    fpsavealloc();
    arch_mmuinit();

    cpuidentify();
    arch_cpuidprint();
    checkmtrr();

    apic->online = 1;
    arch_coherence();

    lapicinit(apic);
    lapiconline();
    syncclock();
    timersinit();

    fpoff();

    lock(&active);
    active.cpus |= 1<<cpu->cpuno;
    unlock(&active);

    while(!active.main_reached_sched)
        arch_microdelay(100);

    schedinit();
}

static void
mpstartap(Apic* apic)
{
    ulong *apbootp, *pd, *pte;
    Cpu *cpu, *cpu0;
    int i, cpuno;
    uchar *p;

    cpu0 = CPUS(0);

    /*
     * Initialise the AP page-tables and Cpu structure. The page-tables
     * are the same as for the bootstrap processor with the exception of
     * the PTE for the Cpu structure.
     * Xspanalloc will panic if an allocation can't be made.
     */
    p = xspanalloc(4*BY2PG, BY2PG, 0);
    pd = (ulong*)p;
    memmove(pd, cpu0->pdproto, BY2PG);
    p += BY2PG;

    if((pte = mmuwalk(pd, CPUADDR, 1, false)) == nil)
        return;
    memmove(p, KADDR(PPN(*pte)), BY2PG);
    *pte = PADDR(p)|PTEWRITE|PTEVALID;
    if(cpu0->havepge)
        *pte |= PTEGLOBAL;
    p += BY2PG;

    cpu = (Cpu*)p;
    if((pte = mmuwalk(pd, CPUADDR, 2, false)) == nil)
        return;
    *pte = PADDR(cpu)|PTEWRITE|PTEVALID;
    if(cpu0->havepge)
        *pte |= PTEGLOBAL;
    p += BY2PG;

    cpuno = apic->cpuno;
    CPUS(cpuno) = cpu; // !!!!
    cpu->cpuno = cpuno;
    cpu->pdproto = pd;
    cpu->gdt = (Segdesc*)p;    /* filled by mmuinit */

    /*
     * Tell the AP where its kernel vector and pd are.
     * The offsets are known in the AP bootstrap code.
     */
    apbootp = (ulong*)(APBOOTSTRAP+0x08);
    *apbootp++ = (ulong)squidboy;   /* assembler jumps here eventually */
    *apbootp++ = PADDR(pd);
    *apbootp = (ulong)apic;

    /*
     * Universal Startup Algorithm.
     */
    p = KADDR(0x467);       /* warm-reset vector */
    *p++ = PADDR(APBOOTSTRAP);
    *p++ = PADDR(APBOOTSTRAP)>>8;
    i = (PADDR(APBOOTSTRAP) & ~0xFFFF)/16;
    /* code assumes i==0 */
    if(i != 0)
        print("mp: bad APBOOTSTRAP\n");
    *p++ = i;
    *p = i>>8;

    arch_coherence();

    nvramwrite(0x0F, 0x0A); /* shutdown code: warm reset upon init ipi */
    lapicstartap(apic, PADDR(APBOOTSTRAP));
    for(i = 0; i < 1000; i++){
        if(apic->online)
            break;
        arch_delay(10);
    }
    nvramwrite(0x0F, 0x00);
}

static void
trympacpi(void)
{
    if (mpacpifunc != nil) {
        print("mpinit: scanning acpi madt for extra cpus\n");
        (*mpacpifunc)();
    }
}

void
mpinit(void)
{
    int ncpu, cpuson;
    char *cp;
    PCMP *pcmp;
    uchar *e, *p;
    Apic *apic, *bpapic;
    void *va;

    mpdebug = getconf("*debugmp") != nil;
    i8259init();
    syncclock();

    bpapic = nil;
    cpuson = 0;

    if(_mp_ == 0) {
        /*
         * We can easily get processor info from ACPI, but
         * interrupt routing, etc. would require interpreting AML.
         */
        print("mpinit: no mp table found, assuming uniprocessor\n");
        archrevert();
        return;
    }
    pcmp = KADDR(_mp_->physaddr);

    /*
     * Map the local APIC.
     */
    if((va = vmap(pcmp->lapicbase, 1024)) == nil)
        return;
    mppcmp = pcmp;
    print("LAPIC: %#lux %#lux\n", pcmp->lapicbase, (ulong)va);

    /*
     * Run through the table saving information needed for starting
     * application processors and initialising any I/O APICs. The table
     * is guaranteed to be in order such that only one pass is necessary.
     */
    p = ((uchar*)pcmp)+sizeof(PCMP);
    e = ((uchar*)pcmp)+pcmp->length;
    while(p < e) switch(*p){

    default:
        print("mpinit: unknown PCMP type 0x%uX (e-p 0x%luX)\n",
            *p, e-p);
        while(p < e){
            print("%uX ", *p);
            p++;
        }
        break;

    case PcmpPROCESSOR:
        if(apic = mkprocessor((PCMPprocessor*)p)){
            /*
             * Must take a note of bootstrap processor APIC
             * now as it will be needed in order to start the
             * application processors later and there's no
             * guarantee that the bootstrap processor appears
             * first in the table before the others.
             */
            apic->addr = va;
            apic->paddr = pcmp->lapicbase;
            if(apic->flags & PcmpBP)
                bpapic = apic;
            cpuson++;
        }
        p += sizeof(PCMPprocessor);
        continue;

    case PcmpBUS:
        mkbus((PCMPbus*)p);
        p += sizeof(PCMPbus);
        continue;

    case PcmpIOAPIC:
        if(apic = mkioapic((PCMPioapic*)p))
            ioapicinit(apic, ((PCMPioapic*)p)->apicno);
        p += sizeof(PCMPioapic);
        continue;

    case PcmpIOINTR:
        mkiointr((PCMPintr*)p);
        p += sizeof(PCMPintr);
        continue;

    case PcmpLINTR:
        mklintr((PCMPintr*)p);
        p += sizeof(PCMPintr);
        continue;
    }

    dprint("mpinit: mp table describes %d cpus\n", cpuson);

    /* For now, always scan ACPI's MADT for processors that MP missed. */
    trympacpi();

    if (bpapic == nil)
        bpapic = bootapic;

    /*
     * No bootstrap processor, no need to go further.
     */
    if(bpapic == 0)
        return;
    bpapic->online = 1;

    lapicinit(bpapic);

    /*
     * These interrupts are local to the processor
     * and do not appear in the I/O APIC so it is OK
     * to set them now.
     */
    arch_intrenable(IrqTIMER, lapicclock, 0, BUSUNKNOWN, "clock");
    arch_intrenable(IrqERROR, lapicerror, 0, BUSUNKNOWN, "lapicerror");
    arch_intrenable(IrqSPURIOUS, lapicspurious, 0, BUSUNKNOWN, "lapicspurious");
    lapiconline();

    checkmtrr();

    /*
     * Initialise the application processors.
     */
    if(cp = getconf("*ncpu")){
        ncpu = strtol(cp, 0, 0);
        if(ncpu < 1)
            ncpu = 1;
        else if(ncpu > MAXCPUS)
            ncpu = MAXCPUS;
    }
    else
        ncpu = MAXCPUS;
    memmove((void*)APBOOTSTRAP, apbootstrap, sizeof(apbootstrap));
    for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++){
        if(ncpu <= 1)
            break;
        if((apic->flags & (PcmpBP|PcmpEN)) == PcmpEN
        && apic->type == PcmpPROCESSOR){
            mpstartap(apic);
            conf.ncpu++;
            ncpu--;
        }
    }

    /*
     *  we don't really know the number of processors till
     *  here.
     *
     *  set conf.copymode here if ncpu > 1.
     *  Should look for an ExtINT line and enable it.
     */
    if(X86FAMILY(cpu->cpuidax) == 3 || conf.ncpu > 1)
        conf.copymode = 1;
}

static int
mpintrcpu(void)
{
    int i;

    /*
     * The bulk of this code was written ~1995, when there was
     * one architecture and one generation of hardware, the number
     * of CPUs was up to 4(8) and the choices for interrupt routing
     * were physical, or flat logical (optionally with lowest
     * priority interrupt). Logical mode hasn't scaled well with
     * the increasing number of packages/cores/threads, so the
     * fall-back is to physical mode, which works across all processor
     * generations, both AMD and Intel, using the APIC and xAPIC.
     *
     * Interrupt routing policy can be set here.
     * Currently, just assign each interrupt to a different CPU on
     * a round-robin basis. Some idea of the packages/cores/thread
     * topology would be useful here, e.g. to not assign interrupts
     * to more than one thread in a core, or to use a "noise" core.
     * But, as usual, Intel make that an onerous task. 
     */

    /*
     * temporary workaround for many-core intel (non-amd) systems:
     * always use cpu 0.  (TODO)
     */
    if(strncmp(cpu->cpuidid, "AuthenticAMD", 12) != 0 && conf.ncpu > 8)
        return 0;

    lock(&mpphysidlock);
    for(;;){
        i = mpphysid++;
        if(mpphysid >= MaxAPICNO+1)
            mpphysid = 0;
        if(mpapic[i].online)
            break;
    }
    unlock(&mpphysidlock);

    return mpapic[i].apicno;
}

static int
mpintrenablex(Vctl* v, int tbdf)
{
    Bus *bus;
    Aintr *aintr;
    Apic *apic;
    Pcidev *pcidev;
    int bno, dno, hi, irq, lo, n, type, vno;
    char *typenm;

    /*
     * Find the bus.
     */
    type = BUSTYPE(tbdf);
    bno = BUSBNO(tbdf);
    dno = BUSDNO(tbdf);
    if(type == BusISA)
        bno = mpisabus;
    vno = -1;
    for(bus = mpbus; bus != nil; bus = bus->next){
        if(bus->type != type)
            continue;
        if(bus->busno == bno)
            break;
    }
    if(bus == nil){
        typenm = type < 0 || type >= nelem(buses)? "": buses[type];
        print("mpintrenablex: can't find bus type %d (%s) for irq %d "
            "%s busno %d\n", type, typenm, v->irq, v->name, bno);
        return -1;
    }

    /*
     * For PCI devices the interrupt pin (INT[ABCD]) and device
     * number are encoded into the entry irq field, so create something
     * to match on. The interrupt pin used by the device has to be
     * obtained from the PCI config space.
     */
    if(bus->type == BusPCI){
        pcidev = pcimatchtbdf(tbdf);
        if(pcidev != nil && (n = pcicfgr8(pcidev, PciINTP)) != 0)
            irq = (dno<<2)|(n-1);
        else
            irq = -1;
        //print("pcidev %#uX: irq %#uX v->irq %#uX\n", tbdf, irq, v->irq);
    }
    else
        irq = v->irq;

    /*
     * Find a matching interrupt entry from the list of interrupts
     * attached to this bus.
     */
    for(aintr = bus->aintr; aintr; aintr = aintr->next){
        if(aintr->intr->irq != irq)
            continue;
        if (0) {
            PCMPintr* p = aintr->intr;

            print("mpintrenablex: bus %d intin %d irq %d\n",
                p->busno, p->intin, p->irq);
        }
        /*
         * Check if already enabled. Multifunction devices may share
         * INT[A-D]# so, if already enabled, check the polarity matches
         * and the trigger is level.
         *
         * Should check the devices differ only in the function number,
         * but that can wait for the planned enable/disable rewrite.
         * The RDT read here is safe for now as currently interrupts
         * are never disabled once enabled.
         */
        apic = aintr->apic;
        ioapicrdtr(apic, aintr->intr->intin, 0, &lo);
        if(!(lo & ApicIMASK)){
            vno = lo & 0xFF;
//print("%s vector %d (!imask)\n", v->name, vno);
            n = mpintrinit(bus, aintr->intr, vno, v->irq);
            n |= ApicPHYSICAL;      /* no-op */
            lo &= ~(ApicRemoteIRR|ApicDELIVS);
            if(n != lo || !(n & ApicLEVEL)){
                print("mpintrenable: multiple botch irq%d, tbdf %uX, lo %8.8uX, n %8.8uX\n",
                    v->irq, tbdf, lo, n);
                return -1;
            }
            break;
        }

        /*
         * With the APIC a unique vector can be assigned to each
         * request to enable an interrupt. There are two reasons this
         * is a good idea:
         * 1) to prevent lost interrupts, no more than 2 interrupts
         *    should be assigned per block of 16 vectors (there is an
         *    in-service entry and a holding entry for each priority
         *    level and there is one priority level per block of 16
         *    interrupts).
         * 2) each input pin on the IOAPIC will receive a different
         *    vector regardless of whether the devices on that pin use
         *    the same IRQ as devices on another pin.
         */
        vno = VectorAPIC + (incref(&mpvnoref)-1)*8;
//print("%s vector %d (imask)\n", v->name, vno);
        if(vno > MaxVectorAPIC){
            print("mpintrenable: vno %d, irq %d, tbdf %uX\n",
                vno, v->irq, tbdf);
            return -1;
        }

        hi = mpintrcpu()<<24;
        lo = mpintrinit(bus, aintr->intr, vno, v->irq);
        //print("lo 0x%uX: busno %d intr %d vno %d irq %d elcr 0x%uX\n",
        //  lo, bus->busno, aintr->intr->irq, vno,
        //  v->irq, i8259elcr);
        if(lo & ApicIMASK)
            return -1;
        lo |= ApicPHYSICAL;         /* no-op */

        if((apic->flags & PcmpEN) && apic->type == PcmpIOAPIC)
            ioapicrdtw(apic, aintr->intr->intin, hi, lo);
        //else
        //  print("lo not enabled 0x%uX %d\n",
        //      apic->flags, apic->type);
        break;
    }
    if (aintr) {
        v->isr = lapicisr;
        v->eoi = lapiceoi;
    }
    return vno;
}

int
mpintrenable(Vctl* v)
{
    int irq, tbdf, vno;

    /*
     * If the bus is known, try it.
     * BUSUNKNOWN is given both by [E]ISA devices and by
     * interrupts local to the processor (local APIC, coprocessor
     * breakpoint and page-fault).
     */
    tbdf = v->tbdf;
    if(tbdf != BUSUNKNOWN && (vno = mpintrenablex(v, tbdf)) != -1)
        return vno;

    irq = v->irq;
    if(irq >= IrqLINT0 && irq <= MaxIrqLAPIC){
        if(irq != IrqSPURIOUS)
            v->isr = lapiceoi;
        return VectorPIC+irq;
    }
    if(irq < 0 || irq > MaxIrqPIC){
        print("mpintrenable: irq %d out of range\n", irq);
        return -1;
    }

    /*
     * Either didn't find it or have to try the default buses
     * (ISA and EISA). This hack is due to either over-zealousness 
     * or laziness on the part of some manufacturers.
     *
     * The MP configuration table on some older systems
     * (e.g. ASUS PCI/E-P54NP4) has an entry for the EISA bus
     * but none for ISA. It also has the interrupt type and
     * polarity set to 'default for this bus' which wouldn't
     * be compatible with ISA.
     */
    if(mpeisabus != -1){
        vno = mpintrenablex(v, MKBUS(BusEISA, 0, 0, 0));
        if(vno != -1)
            return vno;
    }
    if(mpisabus != -1){
        vno = mpintrenablex(v, MKBUS(BusISA, 0, 0, 0));
        if(vno != -1)
            return vno;
    }
    print("mpintrenable: out of choices eisa %d isa %d tbdf %#ux irq %d\n",
        mpeisabus, mpisabus, v->tbdf, v->irq);
    return -1;
}

static Lock mpshutdownlock;

void
mpshutdown(void)
{
    /*
     * To be done...
     */
    if(!canlock(&mpshutdownlock)){
        /*
         * If this processor received the CTRL-ALT-DEL from
         * the keyboard, acknowledge it. Send an INIT to self.
         */
#ifdef FIXTHIS
        if(lapicisr(VectorKBD))
            lapiceoi(VectorKBD);
#endif /* FIX THIS */
        arch->introff();
        idle();
    }

    if(active.rebooting)
        return;
    print("apshutdown: active = %#8.8ux\n", active.cpus);
    arch_delay(1000);
    arch_splhi();
    arch->resetothers();

    pcireset();
    i8042reset();

    /*
     * Often the BIOS hangs during restart if a conventional 8042
     * warm-boot sequence is tried. The following is Intel specific and
     * seems to perform a cold-boot, but at least it comes back.
     * And sometimes there is no keyboard...
     *
     * The reset register (0xcf9) is usually in one of the bridge
     * chips. The actual location and sequence could be extracted from
     * ACPI but why bother, this is the end of the line anyway.
     */
    print("no kbd; trying bios warm boot...");
    *(ushort*)KADDR(0x472) = 0x1234;    /* BIOS warm-boot flag */
    outb(0xCF9, 0x02);
    outb(0xCF9, 0x06);

    print("can't reset\n");
    for(;;)
        idle();
}
@
% >> >> >> >> >> >>

\section{[[syscalls/386/]]}

\subsection*{[[syscalls/386/plan9l.s]]}

<<plan9l.s>>=
#include "mem.h"

<<function touser(x86)>>

<<function _syscallintr(x86)>>
@


\part{Extra Extra}

\subsection*{[[arch/386/io.h]]}

<<arch/386/io.h>>=

#define X86FAMILY(x)  ((((x)>>8) & 0x0F) | (((x)>>20) & 0xFF)<<4)

enum {
  BusCBUS   = 0,    /* Corollary CBUS */
  BusCBUSII,      /* Corollary CBUS II */
  BusEISA,      /* Extended ISA */
  BusFUTURE,      /* IEEE Futurebus */
  BusINTERN,      /* Internal bus */
  BusISA,       /* Industry Standard Architecture */
  BusMBI,       /* Multibus I */
  BusMBII,      /* Multibus II */
  BusMCA,       /* Micro Channel Architecture */
  BusMPI,       /* MPI */
  BusMPSA,      /* MPSA */
  BusNUBUS,     /* Apple Macintosh NuBus */
  BusPCI,       /* Peripheral Component Interconnect */
  BusPCMCIA,      /* PC Memory Card International Association */
  BusTC,        /* DEC TurboChannel */
  BusVL,        /* VESA Local bus */
  BusVME,       /* VMEbus */
  BusXPRESS,      /* Express System Bus */
};

#define MKBUS(t,b,d,f)  (((t)<<24)|(((b)&0xFF)<<16)|(((d)&0x1F)<<11)|(((f)&0x07)<<8))
#define BUSFNO(tbdf)  (((tbdf)>>8)&0x07)
#define BUSDNO(tbdf)  (((tbdf)>>11)&0x1F)
#define BUSBNO(tbdf)  (((tbdf)>>16)&0xFF)
#define BUSTYPE(tbdf) ((tbdf)>>24)
#define BUSBDF(tbdf)  ((tbdf)&0x00FFFF00)
#define BUSUNKNOWN  (-1)

enum {
  MaxEISA   = 16,
  CfgEISA   = 0xC80,
};

/*
 * PCI support code.
 */
enum {          /* type 0 & type 1 pre-defined header */
  PciVID    = 0x00,   /* vendor ID */
  PciDID    = 0x02,   /* device ID */
  PciPCR    = 0x04,   /* command */
  PciPSR    = 0x06,   /* status */
  PciRID    = 0x08,   /* revision ID */
  PciCCRp   = 0x09,   /* programming interface class code */
  PciCCRu   = 0x0A,   /* sub-class code */
  PciCCRb   = 0x0B,   /* base class code */
  PciCLS    = 0x0C,   /* cache line size */
  PciLTR    = 0x0D,   /* latency timer */
  PciHDT    = 0x0E,   /* header type */
  PciBST    = 0x0F,   /* BIST */

  PciBAR0   = 0x10,   /* base address */
  PciBAR1   = 0x14,

  PciINTL   = 0x3C,   /* interrupt line */
  PciINTP   = 0x3D,   /* interrupt pin */
};

/* ccrb (base class code) values; controller types */
enum {
  Pcibcpci1 = 0,    /* pci 1.0; no class codes defined */
  Pcibcstore  = 1,    /* mass storage */
  Pcibcnet  = 2,    /* network */
  Pcibcdisp = 3,    /* display */
  Pcibcmmedia = 4,    /* multimedia */
  Pcibcmem  = 5,    /* memory */
  Pcibcbridge = 6,    /* bridge */
  Pcibccomm = 7,    /* simple comms (e.g., serial) */
  Pcibcbasesys  = 8,    /* base system */
  Pcibcinput  = 9,    /* input */
  Pcibcdock = 0xa,    /* docking stations */
  Pcibcproc = 0xb,    /* processors */
  Pcibcserial = 0xc,    /* serial bus (e.g., USB) */
  Pcibcwireless = 0xd,    /* wireless */
  Pcibcintell = 0xe,    /* intelligent i/o */
  Pcibcsatcom = 0xf,    /* satellite comms */
  Pcibccrypto = 0x10,   /* encryption/decryption */
  Pcibcdacq = 0x11,   /* data acquisition & signal proc. */
};

/* ccru (sub-class code) values; common cases only */
enum {
  /* mass storage */
  Pciscscsi = 0,    /* SCSI */
  Pciscide  = 1,    /* IDE (ATA) */
  Pciscsata = 6,    /* SATA */

  /* network */
  Pciscether  = 0,    /* Ethernet */

  /* display */
  Pciscvga  = 0,    /* VGA */
  Pciscxga  = 1,    /* XGA */
  Pcisc3d   = 2,    /* 3D */

  /* bridges */
  Pcischostpci  = 0,    /* host/pci */
  Pciscpcicpci  = 1,    /* pci/pci */

  /* simple comms */
  Pciscserial = 0,    /* 16450, etc. */
  Pciscmultiser = 1,    /* multiport serial */

  /* serial bus */
  Pciscusb  = 3,    /* USB */
};

enum {          /* type 0 pre-defined header */
  PciCIS    = 0x28,   /* cardbus CIS pointer */
  PciSVID   = 0x2C,   /* subsystem vendor ID */
  PciSID    = 0x2E,   /* cardbus CIS pointer */
  PciEBAR0  = 0x30,   /* expansion ROM base address */
  PciMGNT   = 0x3E,   /* burst period length */
  PciMLT    = 0x3F,   /* maximum latency between bursts */
};

enum {          /* type 1 pre-defined header */
  PciPBN    = 0x18,   /* primary bus number */
  PciSBN    = 0x19,   /* secondary bus number */
  PciUBN    = 0x1A,   /* subordinate bus number */
  PciSLTR   = 0x1B,   /* secondary latency timer */
  PciIBR    = 0x1C,   /* I/O base */
  PciILR    = 0x1D,   /* I/O limit */
  PciSPSR   = 0x1E,   /* secondary status */
  PciMBR    = 0x20,   /* memory base */
  PciMLR    = 0x22,   /* memory limit */
  PciPMBR   = 0x24,   /* prefetchable memory base */
  PciPMLR   = 0x26,   /* prefetchable memory limit */
  PciPUBR   = 0x28,   /* prefetchable base upper 32 bits */
  PciPULR   = 0x2C,   /* prefetchable limit upper 32 bits */
  PciIUBR   = 0x30,   /* I/O base upper 16 bits */
  PciIULR   = 0x32,   /* I/O limit upper 16 bits */
  PciEBAR1  = 0x28,   /* expansion ROM base address */
  PciBCR    = 0x3E,   /* bridge control register */
};

enum {          /* type 2 pre-defined header */
  PciCBExCA = 0x10,
  PciCBSPSR = 0x16,
  PciCBPBN  = 0x18,   /* primary bus number */
  PciCBSBN  = 0x19,   /* secondary bus number */
  PciCBUBN  = 0x1A,   /* subordinate bus number */
  PciCBSLTR = 0x1B,   /* secondary latency timer */
  PciCBMBR0 = 0x1C,
  PciCBMLR0 = 0x20,
  PciCBMBR1 = 0x24,
  PciCBMLR1 = 0x28,
  PciCBIBR0 = 0x2C,   /* I/O base */
  PciCBILR0 = 0x30,   /* I/O limit */
  PciCBIBR1 = 0x34,   /* I/O base */
  PciCBILR1 = 0x38,   /* I/O limit */
  PciCBSVID = 0x40,   /* subsystem vendor ID */
  PciCBSID  = 0x42,   /* subsystem ID */
  PciCBLMBAR  = 0x44,   /* legacy mode base address */
};

struct Pcisiz
{
  Pcidev* dev;
  int siz;
  int bar;
};

struct Pcidev
{
  int tbdf;     /* type+bus+device+function */
  ushort  vid;      /* vendor ID */
  ushort  did;      /* device ID */

  ushort  pcr;

  uchar rid;
  uchar ccrp;
  uchar ccru;
  uchar ccrb;
  uchar cls;
  uchar ltr;

  struct {
    ulong bar;    /* base address */
    int size;
  } mem[6];

  struct {
    ulong bar;  
    int size;
  } rom;
  uchar intl;     /* interrupt line */

  Pcidev* list;
  Pcidev* link;     /* next device on this bno */

  Pcidev* bridge;     /* down a bus */
  struct {
    ulong bar;
    int size;
  } ioa, mema;

  int pmrb;     /* power management register block */
};

enum {
  /* vendor ids */
  Vatiamd = 0x1002,
  Vintel  = 0x8086,
  Vjmicron= 0x197b,
  Vmarvell= 0x1b4b,
  Vmyricom= 0x14c1,
};

#define PCIWINDOW 0
#define PCIWADDR(va)  (PADDR(va)+PCIWINDOW)
//#define ISAWINDOW 0
//#define ISAWADDR(va)  (PADDR(va)+ISAWINDOW)

/* SMBus transactions */
enum
{
  SMBquick,   /* sends address only */

  /* write */
  SMBsend,    /* sends address and cmd */
  SMBbytewrite,   /* sends address and cmd and 1 byte */
  SMBwordwrite,   /* sends address and cmd and 2 bytes */

  /* read */
  SMBrecv,    /* sends address, recvs 1 byte */
  SMBbyteread,    /* sends address and cmd, recv's byte */
  SMBwordread,    /* sends address and cmd, recv's 2 bytes */
};


<<io.h pragmas(x86)>>
@


\ifallcode
<<io.h pragmas(x86)>>=
#pragma varargck  type  "T" int
#pragma varargck  type  "T" uint
@
\fi


%//typedef struct SMBus SMBus;
%//struct SMBus {
%//  QLock;    /* mutex */
%//  Rendez  r;  /* rendezvous point for completion interrupts */
%//  void  *arg; /* implementation dependent */
%//  ulong base; /* port or memory base of smbus */
%//  int busy;
%//  void  (*transact)(SMBus*, int, int, int, uchar*);
%//};



\subsection*{[[arch/386/iomap.c]]}

<<global iomap(x86)>>=
struct Iomapalloc iomap;
@ 


<<function ioinit(x86)>>=
void
ioinit(void)
{
    char *excluded;
    int i;

    for(i = 0; i < nelem(iomap.maps)-1; i++)
        iomap.maps[i].next = &iomap.maps[i+1];
    iomap.maps[i].next = nil;
    iomap.free = iomap.maps;

    /*
     * This is necessary to make the IBM X20 boot.
     * Have not tracked down the reason.
     * i82557 is at 0x1000, the dummy entry is needed for swappable devs.
     */
    ioalloc(0x0fff, 1, 0, "dummy");

    if ((excluded = getconf("ioexclude")) != nil) {
        char *s;

        s = excluded;
        while (s && *s != '\0' && *s != '\n') {
            char *ends;
            int io_s, io_e;

            io_s = (int)strtol(s, &ends, 0);
            if (ends == nil || ends == s || *ends != '-') {
                print("ioinit: cannot parse option string\n");
                break;
            }
            s = ++ends;

            io_e = (int)strtol(s, &ends, 0);
            if (ends && *ends == ',')
                *ends++ = '\0';
            s = ends;

            ioalloc(io_s, io_e - io_s + 1, 0, "pre-allocated");
        }
    }

}
@ 


<<function ioalloc(x86)>>=
/*
 *  alloc some io port space and remember who it was
 *  alloced to.  if port < 0, find a free region.
 */
int
ioalloc(int port, int size, int align, char *tag)
{
    IOMap *m, **l;
    int i;

    lock(&iomap);
    if(port < 0){
        /* find a free port above 0x400 and below 0x1000 */
        port = 0x400;
        for(l = &iomap.m; *l; l = &(*l)->next){
            m = *l;
            if (m->start < 0x400) continue;
            i = m->start - port;
            if(i > size)
                break;
            if(align > 0)
                port = ((port+align-1)/align)*align;
            else
                port = m->end;
        }
        if(*l == nil){
            unlock(&iomap);
            return -1;
        }
    } else {
        /* Only 64KB I/O space on the x86. */
        if((port+size) > 0x10000){
            unlock(&iomap);
            return -1;
        }
        /* see if the space clashes with previously allocated ports */
        for(l = &iomap.m; *l; l = &(*l)->next){
            m = *l;
            if(m->end <= port)
                continue;
            if(m->reserved && m->start == port && m->end == port + size) {
                m->reserved = 0;
                unlock(&iomap);
                return m->start;
            }
            if(m->start >= port+size)
                break;
            unlock(&iomap);
            return -1;
        }
    }
    m = iomap.free;
    if(m == nil){
        print("ioalloc: out of maps");
        unlock(&iomap);
        return port;
    }
    iomap.free = m->next;
    m->next = *l;
    m->start = port;
    m->end = port + size;
    strncpy(m->tag, tag, sizeof(m->tag));
    m->tag[sizeof(m->tag)-1] = 0;
    *l = m;

    //archdir[0].qid.vers++;
        if(hook_ioalloc) 
            hook_ioalloc();

    unlock(&iomap);
    return m->start;
}
@ 


<<function iofree(x86)>>=
void
iofree(int port)
{
    IOMap *m, **l;

    lock(&iomap);
    for(l = &iomap.m; *l; l = &(*l)->next){
        if((*l)->start == port){
            m = *l;
            *l = m->next;
            m->next = iomap.free;
            iomap.free = m;
            break;
        }
        if((*l)->start > port)
            break;
    }
    //archdir[0].qid.vers++;
        if(hook_ioalloc) 
            hook_ioalloc();

    unlock(&iomap);
}
@ 


<<iomap.c>>=
<<kernel basic includes>>
#include "io.h"

<<global iomap(x86)>>

// to remove some backward dependencies, so that ioalloc()
// can be here instead of in devarch.c
void (*hook_ioalloc)(void) = nil;

<<function ioinit(x86)>>

<<function ioalloc(x86)>>

<<function iofree(x86)>>

@

%///*
%// * Reserve a range to be ioalloced later.
%// * This is in particular useful for exchangable cards, such
%// * as pcmcia and cardbus cards.
%// */
%//int
%//ioreserve(int, int size, int align, char *tag)
%//{
%//  IOMap *m, **l;
%//  int i, port;
%//
%//  lock(&iomap);
%//  /* find a free port above 0x400 and below 0x1000 */
%//  port = 0x400;
%//  for(l = &iomap.m; *l; l = &(*l)->next){
%//      m = *l;
%//      if (m->start < 0x400) continue;
%//      i = m->start - port;
%//      if(i > size)
%//          break;
%//      if(align > 0)
%//          port = ((port+align-1)/align)*align;
%//      else
%//          port = m->end;
%//  }
%//  if(*l == nil){
%//      unlock(&iomap);
%//      return -1;
%//  }
%//  m = iomap.free;
%//  if(m == nil){
%//      print("ioalloc: out of maps");
%//      unlock(&iomap);
%//      return port;
%//  }
%//  iomap.free = m->next;
%//  m->next = *l;
%//  m->start = port;
%//  m->end = port + size;
%//  m->reserved = 1;
%//  strncpy(m->tag, tag, sizeof(m->tag));
%//  m->tag[sizeof(m->tag)-1] = 0;
%//  *l = m;
%//
%//  archdir[0].qid.vers++;
%//
%//  unlock(&iomap);
%//  return m->start;
%//}


\subsection*{[[arch/386/l_io.s]]}

<<l_io.s>>=
/*
 * Some machine instructions not handled by 8[al].
 */
#define OP16            BYTE $0x66
        
/*
 * Port I/O.
 *      in[bsl]         input a byte|short|long
 *      ins[bsl]        input a string of bytes|shorts|longs
 *      out[bsl]        output a byte|short|long
 *      outs[bsl]       output a string of bytes|shorts|longs
 */
TEXT inb(SB), $0
        MOVL    port+0(FP), DX
        XORL    AX, AX
        INB
        RET

TEXT ins(SB), $0
        MOVL    port+0(FP), DX
        XORL    AX, AX
        OP16;   INL
        RET

TEXT inss(SB), $0
        MOVL    port+0(FP), DX
        MOVL    address+4(FP), DI
        MOVL    count+8(FP), CX
        CLD
        REP;    OP16; INSL
        RET

TEXT inl(SB), $0
        MOVL    port+0(FP), DX
        INL
        RET

TEXT outb(SB), $0
        MOVL    port+0(FP), DX
        MOVL    byte+4(FP), AX
        OUTB
        RET

TEXT outs(SB), $0
        MOVL    port+0(FP), DX
        MOVL    short+4(FP), AX
        OP16;   OUTL
        RET

TEXT outss(SB), $0
        MOVL    port+0(FP), DX
        MOVL    address+4(FP), SI
        MOVL    count+8(FP), CX
        CLD
        REP;    OP16; OUTSL
        RET

TEXT outl(SB), $0
        MOVL    port+0(FP), DX
        MOVL    long+4(FP), AX
        OUTL
        RET

TEXT insb(SB), $0
      MOVL    port+0(FP), DX
      MOVL    address+4(FP), DI
      MOVL    count+8(FP), CX
      CLD
      REP;    INSB
      RET

// not called anywhere right now
TEXT insl(SB), $0
      MOVL    port+0(FP), DX
      MOVL    address+4(FP), DI
      MOVL    count+8(FP), CX
      CLD
      REP;    INSL
      RET

TEXT outsb(SB), $0
      MOVL    port+0(FP), DX
      MOVL    address+4(FP), SI
      MOVL    count+8(FP), CX
      CLD
      REP;    OUTSB
      RET

// not called anywhere right now
TEXT outsl(SB), $0
      MOVL    port+0(FP), DX
      MOVL    address+4(FP), SI
      MOVL    count+8(FP), CX
      CLD
      REP;    OUTSL
      RET

@
%$


\subsection*{[[arch/386/x86.c]]}

<<global cputype(x86)>>=
X86type *cputype;
@ 


<<global x86intel>>=
/* cpuid ax is 0x0ffMTFmS, where 0xffF is family, 0xMm is model */
static X86type x86intel[] =
{
    { 4,    0,  22, "486DX", }, /* known chips */
    { 4,    1,  22, "486DX50", },
    { 4,    2,  22, "486SX", },
    { 4,    3,  22, "486DX2", },
    { 4,    4,  22, "486SL", },
    { 4,    5,  22, "486SX2", },
    { 4,    7,  22, "DX2WB", }, /* P24D */
    { 4,    8,  22, "DX4", },   /* P24C */
    { 4,    9,  22, "DX4WB", }, /* P24CT */
    { 5,    0,  23, "P5", },
    { 5,    1,  23, "P5", },
    { 5,    2,  23, "P54C", },
    { 5,    3,  23, "P24T", },
    { 5,    4,  23, "P55C MMX", },
    { 5,    7,  23, "P54C VRT", },
    { 6,    1,  16, "PentiumPro", },/* trial and error */
    { 6,    3,  16, "PentiumII", },
    { 6,    5,  16, "PentiumII/Xeon", },
    { 6,    6,  16, "Celeron", },
    { 6,    7,  16, "PentiumIII/Xeon", },
    { 6,    8,  16, "PentiumIII/Xeon", },
    { 6,    0xB,    16, "PentiumIII/Xeon", },
    { 6,    0xF,    16, "Core 2/Xeon", },
    { 6,    0x16,   16, "Celeron", },
    { 6,    0x17,   16, "Core 2/Xeon", },
    { 6,    0x1A,   16, "Core i7/Xeon", },
    { 6,    0x1C,   16, "Atom", },
    { 6,    0x1D,   16, "Xeon MP", },
    { 6,    0x1E,   16, "Core i5/i7/Xeon", },
    { 6,    0x1F,   16, "Core i7/Xeon", },
    { 6,    0x22,   16, "Core i7", },
    { 6,    0x25,   16, "Core i3/i5/i7", },
    { 6,    0x2A,   16, "Core i7", },
    { 6,    0x2C,   16, "Core i7/Xeon", },
    { 6,    0x2D,   16, "Core i7", },
    { 6,    0x2E,   16, "Xeon MP", },
    { 6,    0x2F,   16, "Xeon MP", },
    { 6,    0x3A,   16, "Core i7", },
    { 0xF,  1,  16, "P4", },    /* P4 */
    { 0xF,  2,  16, "PentiumIV/Xeon", },
    { 0xF,  6,  16, "PentiumIV/Xeon", },

    { 3,    -1, 32, "386", },   /* family defaults */
    { 4,    -1, 22, "486", },
    { 5,    -1, 23, "P5", },
    { 6,    -1, 16, "P6", },
    { 0xF,  -1, 16, "P4", },    /* P4 */

    { -1,   -1, 16, "unknown", },   /* total default */
};
@ 


<<global x86amd>>=
/*
 * The AMD processors all implement the CPUID instruction.
 * The later ones also return the processor name via functions
 * 0x80000002, 0x80000003 and 0x80000004 in registers AX, BX, CX
 * and DX:
 *  K5  "AMD-K5(tm) Processor"
 *  K6  "AMD-K6tm w/ multimedia extensions"
 *  K6 3D   "AMD-K6(tm) 3D processor"
 *  K6 3D+  ?
 */
static X86type x86amd[] =
{
    { 5,    0,  23, "AMD-K5", },    /* guesswork */
    { 5,    1,  23, "AMD-K5", },    /* guesswork */
    { 5,    2,  23, "AMD-K5", },    /* guesswork */
    { 5,    3,  23, "AMD-K5", },    /* guesswork */
    { 5,    4,  23, "AMD Geode GX1", }, /* guesswork */
    { 5,    5,  23, "AMD Geode GX2", }, /* guesswork */
    { 5,    6,  11, "AMD-K6", },    /* trial and error */
    { 5,    7,  11, "AMD-K6", },    /* trial and error */
    { 5,    8,  11, "AMD-K6-2", },  /* trial and error */
    { 5,    9,  11, "AMD-K6-III", },/* trial and error */
    { 5,    0xa,    23, "AMD Geode LX", },  /* guesswork */

    { 6,    1,  11, "AMD-Athlon", },/* trial and error */
    { 6,    2,  11, "AMD-Athlon", },/* trial and error */

    { 0x1F, 9,  11, "AMD-K10 Opteron G34", },/* guesswork */

    { 4,    -1, 22, "Am486", }, /* guesswork */
    { 5,    -1, 23, "AMD-K5/K6", }, /* guesswork */
    { 6,    -1, 11, "AMD-Athlon", },/* guesswork */
    { 0xF,  -1, 11, "AMD-K8", },    /* guesswork */
    { 0x1F, -1, 11, "AMD-K10", },   /* guesswork */

    { -1,   -1, 11, "unknown", },   /* total default */
};
@ 


<<global x86winchip>>=
/*
 * WinChip 240MHz
 */
static X86type x86winchip[] =
{
    {5, 4,  23, "Winchip",},    /* guesswork */
    {6, 7,  23, "Via C3 Samuel 2 or Ezra",},
    {6, 8,  23, "Via C3 Ezra-T",},
    {6, 9,  23, "Via C3 Eden-N",},
    { -1,   -1, 23, "unknown", },   /* total default */
};
@ 


<<global x86sis>>=
/*
 * SiS 55x
 */
static X86type x86sis[] =
{
    {5, 0,  23, "SiS 55x",},    /* guesswork */
    { -1,   -1, 23, "unknown", },   /* total default */
};
@ 


<<function cpuidentify(x86)>>=
/*
 *  figure out:
 *  - cpu type
 *  - whether or not we have a TSC (cycle counter)
 *  - whether or not it supports page size extensions
 *      (if so turn it on)
 *  - whether or not it supports machine check exceptions
 *      (if so turn it on)
 *  - whether or not it supports the page global flag
 *      (if so turn it on)
 */
int
cpuidentify(void)
{
    char *p;
    int family, model, nomce;
    X86type *t, *tab;
    ulong cr4;
    ulong regs[4];
    vlong mca, mct;

    cpuid(Highstdfunc, regs);
    memmove(cpu->cpuidid,   &regs[1], BY2WD); /* bx */
    memmove(cpu->cpuidid+4, &regs[3], BY2WD); /* dx */
    memmove(cpu->cpuidid+8, &regs[2], BY2WD); /* cx */
    cpu->cpuidid[12] = '\0';

    cpuid(Procsig, regs);
    cpu->cpuidax = regs[0];
    cpu->cpuiddx = regs[3];

    if(strncmp(cpu->cpuidid, "AuthenticAMD", 12) == 0 ||
       strncmp(cpu->cpuidid, "Geode by NSC", 12) == 0)
        tab = x86amd;
    else if(strncmp(cpu->cpuidid, "CentaurHauls", 12) == 0)
        tab = x86winchip;
    else if(strncmp(cpu->cpuidid, "SiS SiS SiS ", 12) == 0)
        tab = x86sis;
    else
        tab = x86intel;

    family = X86FAMILY(cpu->cpuidax);
    model = X86MODEL(cpu->cpuidax);
    for(t=tab; t->name; t++)
        if((t->family == family && t->model == model)
        || (t->family == family && t->model == -1)
        || (t->family == -1))
            break;

    cpu->cpuidtype = t->name;

    /*
     *  if there is one, set tsc to a known value
     */
    if(cpu->cpuiddx & Tsc){
        cpu->havetsc = true;
        arch_cycles = _cycles;
        if(cpu->cpuiddx & Cpumsr)
            wrmsr(0x10, 0);
    }

    /*
     *  use i8253 to guess our cpu speed
     */
    guesscpuhz(t->aalcycles);

    /*
     * If machine check exception, page size extensions or page global bit
     * are supported enable them in CR4 and clear any other set extensions.
     * If machine check was enabled clear out any lingering status.
     */
    if(cpu->cpuiddx & (Pge|Mce|Pse)){
        cr4 = 0;
        if(cpu->cpuiddx & Pse)
            cr4 |= 0x10;        /* page size extensions */
        if(p = getconf("*nomce"))
            nomce = strtoul(p, 0, 0);
        else
            nomce = 0;
        if((cpu->cpuiddx & Mce) && !nomce){
            cr4 |= 0x40;        /* machine check enable */
            if(family == 5){
                rdmsr(0x00, &mca);
                rdmsr(0x01, &mct);
            }
        }

        /*
         * Detect whether the chip supports the global bit
         * in page directory and page table entries.  When set
         * in a particular entry, it means ``don't bother removing
         * this from the TLB when CR3 changes.''
         *
         * We flag all kernel pages with this bit.  Doing so lessens the
         * overhead of switching processes on bare hardware,
         * even more so on VMware.  See mmu.c:/^memglobal.
         *
         * For future reference, should we ever need to do a
         * full TLB flush, it can be accomplished by clearing
         * the PGE bit in CR4, writing to CR3, and then
         * restoring the PGE bit.
         */
        if(cpu->cpuiddx & Pge){
            cr4 |= 0x80;        /* page global enable bit */
            cpu->havepge = true;
        }

        putcr4(cr4);
        if(cpu->cpuiddx & Mce)
            rdmsr(0x01, &mct);
    }

    if(cpu->cpuiddx & Fxsr){          /* have sse fp? */
        fpsave = fpssesave;
        fprestore = fpsserestore;
        putcr4(getcr4() | CR4Osfxsr);
    } else {
        fpsave = fpx87save;
        fprestore = fpx87restore;
    }

    cputype = t;
    return t->family;
}
@ 


<<x86.c>>=
<<kernel basic includes>>
#include "io.h"

<<global cputype(x86)>>

//#define X86STEPPING(x)  ((x) & 0x0F)
/* incorporates extended-model and -family bits */
#define X86MODEL(x) ((((x)>>4) & 0x0F) | (((x)>>16) & 0x0F)<<4)

//@Scheck: Assembly l.s
void    _cycles(uvlong*);   

enum {
    CR4Osfxsr = 1 << 9,
};

enum {              /* cpuid standard function codes */
    Highstdfunc = 0,    /* also returns vendor string */
    Procsig,
    Proctlbcache,
    Procserial,
};


<<global x86intel>>

<<global x86amd>>

<<global x86winchip>>

<<global x86sis>>


<<function cpuidentify(x86)>>

@
% >> >> 

\subsection*{[[arch/386/bios32.c]]}

\ifallcode
<<bios32.c debugging macro(x86)>>=
static int vflag = 0;
//#define VFLAG(...)    if(vflag) print(__VA_ARGS__)
#define VFLAG if(vflag) print
@ 
\fi

<<bios32.c forward decl(x86)>>=
typedef struct BIOS32sdh BIOS32sdh;
typedef struct BIOS32si BIOS32si;
@ 


<<bios32.c>>=
<<kernel basic includes>>
#include "io.h"

<<bios32.c debugging macro(x86)>>

<<bios32.c forward decl(x86)>>

struct BIOS32sdh {      /* BIOS32 Service Directory Header */
    u8int   signature[4];       /* "_32_" */
    u8int   physaddr[4];        /* physical address of entry point */
    u8int   revision;
    u8int   length;         /* of header in paragraphs */
    u8int   checksum;       /* */
    u8int   reserved[5];
};

struct BIOS32si {       /* BIOS32 Service Interface */
    u8int*  base;           /* base address of service */
    int length;         /* length of service */
    u32int  offset;         /* service entry-point from base */

    u16int  ptr[3];         /* far pointer m16:32 */
};

static Lock bios32lock;
static u16int bios32ptr[3];
static void* bios32entry;

int
bios32ci(BIOS32si* si, BIOS32ci* ci)
{
    int r;

    lock(&bios32lock);
    r = bios32call(ci, si->ptr);
    unlock(&bios32lock);

    return r;
}

static void*
rsdchecksum(void* addr, int length)
{
    u8int *p, sum;

    sum = 0;
    for(p = addr; length-- > 0; p++)
        sum += *p;
    if(sum == 0)
        return addr;

    return nil;
}

static void*
rsdscan(u8int* addr, int len, char* signature)
{
    int sl;
    u8int *e, *p;

    e = addr+len;
    sl = strlen(signature);
    for(p = addr; p+sl < e; p += 16){
        if(memcmp(p, signature, sl))
            continue;
        return p;
    }

    return nil;
}

static int
bios32locate(void)
{
    uintptr ptr;
    BIOS32sdh *sdh;

    VFLAG("bios32link\n");
    if((sdh = rsdscan(BIOSSEG(0xE000), 0x20000, "_32_")) == nil)
        return -1;
    if(rsdchecksum(sdh, sizeof(BIOS32sdh)) == nil)
        return -1;
    VFLAG("sdh @ %#p, entry %#ux\n", sdh, L32GET(sdh->physaddr));

    bios32entry = vmap(L32GET(sdh->physaddr), 4096+1);
    VFLAG("entry @ %#p\n", bios32entry);
    ptr = (uintptr)(bios32entry);
    bios32ptr[0] = ptr & 0xffff;
    bios32ptr[1] = (ptr>>16) & 0xffff;
    bios32ptr[2] = KESEL;
    VFLAG("bios32link: ptr %ux %ux %ux\n",
        bios32ptr[0], bios32ptr[1], bios32ptr[2]);

    return 0;
}

BIOS32si*
bios32open(char* id)
{
    uint ptr;
    BIOS32ci ci;
    BIOS32si *si;

    lock(&bios32lock);
    if(bios32ptr[2] == 0 && bios32locate() < 0){
        unlock(&bios32lock);
        return nil;
    }

    VFLAG("bios32si: %s\n", id);
    memset(&ci, 0, sizeof(BIOS32ci));
    ci.eax = (id[3]<<24|(id[2]<<16)|(id[1]<<8)|id[0]);

    bios32call(&ci, bios32ptr);
    unlock(&bios32lock);

    VFLAG("bios32si: eax %ux\n", ci.eax);
    if(ci.eax & 0xff)
        return nil;
    VFLAG("bios32si: base %#ux length %#ux offset %#ux\n",
        ci.ebx, ci.ecx, ci.edx);

    if((si = malloc(sizeof(BIOS32si))) == nil)
        return nil;
    if((si->base = vmap(ci.ebx, ci.ecx)) == nil){
        free(si);
        return nil;
    }
    si->length = ci.ecx;

    ptr = (uintptr)(si->base)+ci.edx;
    si->ptr[0] = ptr & 0xffff;
    si->ptr[1] = (ptr>>16) & 0xffff;
    si->ptr[2] = KESEL;
    VFLAG("bios32si: eax entry %ux\n", ptr);

    return si;
}
@

%//void
%//BIOS32close(BIOS32si* si)
%//{
%//  vunmap(si->base, si->length);
%//  free(si);
%//}



\subsection*{[[arch/386/l_realmode.s]]}

<<constant x86 other segments>>=
#define KESEG16   9 /* kernel executable 16-bit */
@

<<macros other xxxSEGM(x86)>>=
#define EXEC16SEGM(p)   { 0xFFFF, SEGG|(0xF<<16)|SEGP|SEGPL(p)|SEGEXEC|SEGR }
@

<<[[gdt]] other elements(x86)>>=
[KESEG16]       EXEC16SEGM(0),  /* kernel code 16-bit */
@



<<l_realmode.s>>=
#include "mem.h"
#include "x16.ha"

//*****************************************************************************
// Helpers
//*****************************************************************************

/*
 * Save registers.
 */
TEXT saveregs(SB), $0
        /* appease 8l */
        SUBL $32, SP
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        
        PUSHL   AX
        PUSHL   BX
        PUSHL   CX
        PUSHL   DX
        PUSHL   BP
        PUSHL   DI
        PUSHL   SI
        PUSHFL

        XCHGL   32(SP), AX      /* swap return PC and saved flags */
        XCHGL   0(SP), AX
        XCHGL   32(SP), AX
        RET

TEXT restoreregs(SB), $0
        /* appease 8l */
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        ADDL    $32, SP
        
        XCHGL   32(SP), AX      /* swap return PC and saved flags */
        XCHGL   0(SP), AX
        XCHGL   32(SP), AX

        POPFL
        POPL    SI
        POPL    DI
        POPL    BP
        POPL    DX
        POPL    CX
        POPL    BX
        POPL    AX
        RET


//*****************************************************************************
// Functions
//*****************************************************************************
                
/*
 * Assumed to be in protected mode at time of call.
 * Switch to real mode, execute an interrupt, and
 * then switch back to protected mode.  
 *
 * Assumes:
 *
 *      - no device interrupts are going to come in
 *      - 0-16MB is identity mapped in page tables
 *      - realmode() has copied us down from 0x100000 to 0x8000
 *      - can use code segment 0x0800 in real mode
 *              to get at l.s code
 *      - l.s code is less than 1 page
 */
#define RELOC   (RMCODE-KTZERO)

TEXT realmodeidtptr(SB), $0
        WORD    $(4*256-1)
        LONG    $0

TEXT realmode0(SB), $0
        CALL    saveregs(SB)

        /* switch to low code address */
        LEAL    physcode-KZERO(SB), AX
        JMP *AX

TEXT physcode(SB), $0

        /* switch to low stack */
        MOVL    SP, AX
        MOVL    $0x7C00, SP
        PUSHL   AX

        /* change gdt to physical pointer */
        MOVL    m0rgdtptr-KZERO(SB), GDTR

        /* load IDT with real-mode version*/
        MOVL    realmodeidtptr-KZERO(SB), IDTR

        /* edit INT $0x00 instruction below */
        MOVL    $(RMUADDR-KZERO+48), AX /* &rmu.trap */
        MOVL    (AX), AX
        MOVB    AX, realmodeintrinst+(-KZERO+1+RELOC)(SB)

        /* disable paging */
        MOVL    CR0, AX
        ANDL    $0x7FFFFFFF, AX
        MOVL    AX, CR0
        /* JMP .+2 to clear prefetch queue*/
        BYTE $0xEB; BYTE $0x00

        /* jump to 16-bit code segment */
/*      JMPFAR  SELECTOR(KESEG16, SELGDT, 0):$again16bit(SB) /**/
         BYTE   $0xEA
         LONG   $again16bit-KZERO(SB)
         WORD   $SELECTOR(KESEG16, SELGDT, 0)

TEXT again16bit(SB), $0
        /*
         * Now in 16-bit compatibility mode.
         * These are 32-bit instructions being interpreted
         * as 16-bit instructions.  I'm being lazy and
         * not using the macros because I know when
         * the 16- and 32-bit instructions look the same
         * or close enough.
         */

        /* disable protected mode and jump to real mode cs */
        OPSIZE; MOVL CR0, AX
        OPSIZE; XORL BX, BX
        OPSIZE; INCL BX
        OPSIZE; XORL BX, AX
        OPSIZE; MOVL AX, CR0

        /* JMPFAR 0x0800:now16real */
         BYTE $0xEA
         WORD   $now16real-KZERO(SB)
         WORD   $0x0800

TEXT now16real(SB), $0
        /* copy the registers for the bios call */
        LWI(0x0000, rAX)
        MOVW    AX,SS
        LWI(RMUADDR, rBP)
        
        /* offsets are in Ureg */
        LXW(44, xBP, rAX)
        MOVW    AX, DS
        LXW(40, xBP, rAX)
        MOVW    AX, ES

        OPSIZE; LXW(0, xBP, rDI)
        OPSIZE; LXW(4, xBP, rSI)
        OPSIZE; LXW(16, xBP, rBX)
        OPSIZE; LXW(20, xBP, rDX)
        OPSIZE; LXW(24, xBP, rCX)
        OPSIZE; LXW(28, xBP, rAX)

        CLC

TEXT realmodeintrinst(SB), $0
        INT $0x00
        CLI                     /* who knows what evil the bios got up to */

        /* save the registers after the call */

        LWI(0x7bfc, rSP)
        OPSIZE; PUSHFL
        OPSIZE; PUSHL AX

        LWI(0, rAX)
        MOVW    AX,SS
        LWI(RMUADDR, rBP)
        
        OPSIZE; SXW(rDI, 0, xBP)
        OPSIZE; SXW(rSI, 4, xBP)
        OPSIZE; SXW(rBX, 16, xBP)
        OPSIZE; SXW(rDX, 20, xBP)
        OPSIZE; SXW(rCX, 24, xBP)
        OPSIZE; POPL AX
        OPSIZE; SXW(rAX, 28, xBP)

        MOVW    DS, AX
        OPSIZE; SXW(rAX, 44, xBP)
        MOVW    ES, AX
        OPSIZE; SXW(rAX, 40, xBP)

        OPSIZE; POPL AX
        OPSIZE; SXW(rAX, 64, xBP)       /* flags */

        /* re-enter protected mode and jump to 32-bit code */
        OPSIZE; MOVL $1, AX
        OPSIZE; MOVL AX, CR0
        
/*      JMPFAR  SELECTOR(KESEG, SELGDT, 0):$again32bit(SB) /**/
         OPSIZE
         BYTE $0xEA
         LONG   $again32bit-KZERO(SB)
         WORD   $SELECTOR(KESEG, SELGDT, 0)

TEXT again32bit(SB), $0
        MOVW    $SELECTOR(KDSEG, SELGDT, 0),AX
        MOVW    AX,DS
        MOVW    AX,SS
        MOVW    AX,ES
        MOVW    AX,FS
        MOVW    AX,GS

        /* enable paging and jump to kzero-address code */
        MOVL    CR0, AX
        ORL     $0x80010000, AX /* PG|WP */
        MOVL    AX, CR0
        LEAL    again32kzero(SB), AX
        JMP*    AX

TEXT again32kzero(SB), $0
        /* breathe a sigh of relief - back in 32-bit protected mode */

        /* switch to old stack */       
        PUSHL   AX      /* match popl below for 8l */
        MOVL    $0x7BFC, SP
        POPL    SP

        /* restore idt */
        MOVL    m0idtptr(SB),IDTR

        /* restore gdt */
        MOVL    m0gdtptr(SB), GDTR

        CALL    restoreregs(SB)
        RET

/*
 * BIOS32.
 */
TEXT bios32call(SB), $0
        MOVL    ci+0(FP), BP
        MOVL    0(BP), AX
        MOVL    4(BP), BX
        MOVL    8(BP), CX
        MOVL    12(BP), DX
        MOVL    16(BP), SI
        MOVL    20(BP), DI
        PUSHL   BP

        MOVL    12(SP), BP                      /* ptr */
        BYTE $0xFF; BYTE $0x5D; BYTE $0x00      /* CALL FAR 0(BP) */

        POPL    BP
        MOVL    DI, 20(BP)
        MOVL    SI, 16(BP)
        MOVL    DX, 12(BP)
        MOVL    CX, 8(BP)
        MOVL    BX, 4(BP)
        MOVL    AX, 0(BP)

        XORL    AX, AX
        JCC     _bios32xxret
        INCL    AX

_bios32xxret:
        RET
@



\subsection*{[[arch/386/mp.h]]}

<<mp.h>>=
/*
 * MultiProcessor Specification Version 1.[14].
 */
struct _MP_ {     /* floating pointer */
  uchar signature[4];   /* "_MP_" */
  long  physaddr;   /* physical address of MP configuration table */
  uchar length;     /* 1 */
  uchar specrev;    /* [14] */
  uchar checksum;   /* all bytes must add up to 0 */
  uchar type;     /* MP system configuration type */
  uchar imcrp;
  uchar reserved[3];
};

struct PCMP {     /* configuration table header */
  uchar signature[4];   /* "PCMP" */
  ushort  length;     /* total table length */
  uchar version;    /* [14] */
  uchar checksum;   /* all bytes must add up to 0 */
  uchar product[20];    /* product id */
  ulong oemtable;   /* OEM table pointer */
  ushort  oemlength;    /* OEM table length */
  ushort  entry;      /* entry count */
  ulong lapicbase;    /* address of local APIC */
  ushort  xlength;    /* extended table length */
  uchar xchecksum;    /* extended table checksum */
  uchar reserved;
};

struct PCMPprocessor {      /* processor table entry */
  uchar type;     /* entry type (0) */
  uchar apicno;     /* local APIC id */
  uchar version;    /* local APIC verison */
  uchar flags;      /* CPU flags */
  uchar signature[4];   /* CPU signature */
  ulong feature;    /* feature flags from CPUID instruction */
  uchar reserved[8];
};

struct PCMPbus {      /* bus table entry */
  uchar type;     /* entry type (1) */
  uchar busno;      /* bus id */
  char  string[6];    /* bus type string */
};

struct PCMPioapic {     /* I/O APIC table entry */
  uchar type;     /* entry type (2) */
  uchar apicno;     /* I/O APIC id */
  uchar version;    /* I/O APIC version */
  uchar flags;      /* I/O APIC flags */
  ulong addr;     /* I/O APIC address */
};

struct PCMPintr {     /* interrupt table entry */
  uchar type;     /* entry type ([34]) */
  uchar intr;     /* interrupt type */
  ushort  flags;      /* interrupt flag */
  uchar busno;      /* source bus id */
  uchar irq;      /* source bus irq */
  uchar apicno;     /* destination APIC id */
  uchar intin;      /* destination APIC [L]INTIN# */
};

enum {          /* table entry types */
  PcmpPROCESSOR = 0x00,   /* one entry per processor */
  PcmpBUS   = 0x01,   /* one entry per bus */
  PcmpIOAPIC  = 0x02,   /* one entry per I/O APIC */
  PcmpIOINTR  = 0x03,   /* one entry per bus interrupt source */
  PcmpLINTR = 0x04,   /* one entry per system interrupt source */

  PcmpSASM  = 0x80,
  PcmpHIERARCHY = 0x81,
  PcmpCBASM = 0x82,

          /* PCMPprocessor and PCMPioapic flags */
  PcmpEN    = 0x01,   /* enabled */
  PcmpBP    = 0x02,   /* bootstrap processor */

          /* PCMPiointr and PCMPlintr flags */
  PcmpPOMASK  = 0x03,   /* polarity conforms to specifications of bus */
  PcmpHIGH  = 0x01,   /* active high */
  PcmpLOW   = 0x03,   /* active low */
  PcmpELMASK  = 0x0C,   /* trigger mode of APIC input signals */
  PcmpEDGE  = 0x04,   /* edge-triggered */
  PcmpLEVEL = 0x0C,   /* level-triggered */

          /* PCMPiointr and PCMPlintr interrupt type */
  PcmpINT   = 0x00,   /* vectored interrupt from APIC Rdt */
  PcmpNMI   = 0x01,   /* non-maskable interrupt */
  PcmpSMI   = 0x02,   /* system management interrupt */
  PcmpExtINT  = 0x03,   /* vectored interrupt from external PIC */

          /* PCMPsasm addrtype */
  PcmpIOADDR  = 0x00,   /* I/O address */
  PcmpMADDR = 0x01,   /* memory address */
  PcmpPADDR = 0x02,   /* prefetch address */

          /* PCMPhierarchy info */
  PcmpSD    = 0x01,   /* subtractive decode bus */

          /* PCMPcbasm modifier */
  PcmpPR    = 0x01,   /* predefined range list */
};

/*
 * Condensed form of the MP Configuration Table.
 * This is created during a single pass through the MP Configuration
 * table.
 */
typedef struct Bus {
  uchar type;
  uchar busno;
  uchar po;
  uchar el;

  Aintr*  aintr;      /* interrupts tied to this bus */
  Bus*  next;
} Bus;

struct Aintr {
  PCMPintr* intr;
  Apic* apic;
  Aintr*  next;
};

struct Apic {
  int type;
  int apicno;
  ulong*  addr;     /* register base address */
  ulong paddr;
  int flags;      /* PcmpBP|PcmpEN */

  Lock;       /* I/O APIC: register access */
  int mre;      /* I/O APIC: maximum redirection entry */

  int lintr[2];   /* Local APIC */
  int cpuno;

  int online;
};

enum {
  MaxAPICNO = 254,    /* 255 is physical broadcast */
};

enum {          /* I/O APIC registers */
  IoapicID  = 0x00,   /* ID */
  IoapicVER = 0x01,   /* version */
  IoapicARB = 0x02,   /* arbitration ID */
  IoapicRDT = 0x10,   /* redirection table */
};

/*
 * Common bits for
 *  I/O APIC Redirection Table Entry;
 *  Local APIC Local Interrupt Vector Table;
 *  Local APIC Inter-Processor Interrupt;
 *  Local APIC Timer Vector Table.
 */
enum {
  ApicFIXED = 0x00000000, /* [10:8] Delivery Mode */
  ApicLOWEST  = 0x00000100, /* Lowest priority */
  ApicSMI   = 0x00000200, /* System Management Interrupt */
  ApicRR    = 0x00000300, /* Remote Read */
  ApicNMI   = 0x00000400,
  ApicINIT  = 0x00000500, /* INIT/RESET */
  ApicSTARTUP = 0x00000600, /* Startup IPI */
  ApicExtINT  = 0x00000700,

  ApicPHYSICAL  = 0x00000000, /* [11] Destination Mode (RW) */
  ApicLOGICAL = 0x00000800,

  ApicDELIVS  = 0x00001000, /* [12] Delivery Status (RO) */
  ApicHIGH  = 0x00000000, /* [13] Interrupt Input Pin Polarity (RW) */
  ApicLOW   = 0x00002000,
  ApicRemoteIRR = 0x00004000, /* [14] Remote IRR (RO) */
  ApicEDGE  = 0x00000000, /* [15] Trigger Mode (RW) */
  ApicLEVEL = 0x00008000,
  ApicIMASK = 0x00010000, /* [16] Interrupt Mask */
};

extern void ioapicinit(Apic*, int);
extern void ioapicrdtr(Apic*, int, int*, int*);
extern void ioapicrdtw(Apic*, int, int, int);

extern void lapicclock(Ureg*, void*);
extern int lapiceoi(int);
extern void lapicerror(Ureg*, void*);
extern void lapicicrw(ulong, ulong);
extern void lapicinit(Apic*);
extern void lapicintroff(void);
extern void lapicintron(void);
extern int lapicisr(int);
//extern void lapicnmidisable(void);
//extern void lapicnmienable(void);
extern void lapiconline(void);
extern void lapicspurious(Ureg*, void*);
extern void lapicstartap(Apic*, int);
extern void lapictimerset(uvlong);

extern void mpinit(void);
extern int mpintrenable(Vctl*);
extern void mpshutdown(void);

extern _MP_ *_mp_;
@

%//typedef struct PCMPsasm PCMPsasm;
%//typedef struct PCMPhierarchy PCMPhierarchy;
%//typedef struct PCMPcbasm PCMPcbasm;
%
%//struct PCMPsasm {     /* system address space mapping entry */
%//  uchar type;     /* entry type (128) */
%//  uchar length;     /* of this entry (20) */
%//  uchar busno;      /* bus id */
%//  uchar addrtype;
%//  ulong addrbase[2];
%//  ulong addrlength[2];
%//};
%
%//struct PCMPhierarchy {      /* bus hierarchy descriptor entry */
%//  uchar type;     /* entry type (129) */
%//  uchar length;     /* of this entry (8) */
%//  uchar busno;      /* bus id */
%//  uchar info;     /* bus info */
%//  uchar parent;     /* parent bus */
%//  uchar reserved[3];
%//};
%
%//struct PCMPcbasm {      /* compatibility bus address space modifier entry */
%//  uchar type;     /* entry type (130) */
%//  uchar length;     /* of this entry (8) */
%//  uchar busno;      /* bus id */
%//  uchar modifier;   /* address modifier */
%//  ulong range;      /* predefined range list */
%//};


\subsection*{[[arch/386/mpacpi.h]]}

<<mpacpi.h>>=
/*
 * ACPI definitions
 *
 * A System Descriptor Table starts with a header of 4 bytes of signature
 * followed by 4 bytes of total table length then 28 bytes of ID information
 * (including the table checksum).
 */

struct Madt {       /* Multiple APIC DT */
  uchar sdthdr[36];   /* "MADT" + length[4] + [28] */
  uchar addr[4];    /* Local APIC Address */
  uchar flags[4];
  uchar structures[];
};
struct Rsd {        /* Root System Description * */
  uchar signature[8];   /* "RSD PTR " */
  uchar rchecksum;
  uchar oemid[6];
  uchar revision;
  uchar raddr[4];   /* RSDT */
  uchar length[4];
  uchar xaddr[8];   /* XSDT */
  uchar xchecksum;    /* XSDT */
  uchar pad[3];     /* reserved */
};
@

%//struct Dsdt {       /* Differentiated System DT */
%//  uchar sdthdr[36];   /* "DSDT" + length[4] + [28] */
%//  uchar db[];     /* Definition Block */
%//};
%//struct Facp {       /* Fixed ACPI DT */
%//  uchar sdthdr[36];   /* "FACP" + length[4] + [28] */
%//  uchar faddr[4];   /* Firmware Control Address */
%//  uchar dsdt[4];    /* DSDT Address */
%//  uchar pad[200];   /* total table is 244 */
%//};
%//struct Hpet {       /* High-Precision Event Timer DT */
%//  uchar sdthdr[36];   /* "HPET" + length[4] + [28] */
%//  uchar id[4];      /* Event Timer Block ID */
%//  uchar addr[12];   /* ACPI Format Address */
%//  uchar seqno;      /* Sequence Number */
%//  uchar minticks[2];    /* Minimum Clock Tick */
%//  uchar attr;     /* Page Protection */
%//};
%//typedef struct Mcfg {     /* PCI Memory Mapped Config */
%//  uchar sdthdr[36];   /* "MCFG" + length[4] + [28] */
%//  uchar pad[8];     /* reserved */
%//  Mcfgd mcfgd[];    /* descriptors */
%//} Mcfg;
%//struct Mcfgd {        /* MCFG Descriptor */
%//  uchar addr[8];    /* base address */
%//  uchar segno[2];   /* segment group number */
%//  uchar sbno;     /* start bus number */
%//  uchar ebno;     /* end bus number */
%//  uchar pad[4];     /* reserved */
%//};

\subsection*{[[arch/386/nvram.c]]}

<<nvram.c>>=
<<kernel basic includes>>

// used to be static
Lock nvrtlock;

uchar
nvramread(int addr)
{
    uchar data;

    ilock(&nvrtlock);
    outb(Paddr, addr);
    data = inb(PdataPort);
    iunlock(&nvrtlock);

    return data;
}

void
nvramwrite(int addr, uchar data)
{
    ilock(&nvrtlock);
    outb(Paddr, addr);
    outb(PdataPort, data);
    iunlock(&nvrtlock);
}
@


\subsection*{[[arch/386/realmode.c]]}

<<function realmodelink(x86)>>=
void
realmodelink(void)
{
    addarchfile("realmode", 0660, rtrapread, rtrapwrite);
    addarchfile("realmodemem", 0660, rmemread, rmemwrite);
}
@ 


<<realmode.c>>=
<<kernel basic includes>>

#include    "io.h"

#include    <tos.h>
#include    <ureg.h>

/*
 * Back the processor into real mode to run a BIOS call,
 * then return.  This must be used carefully, since it 
 * completely disables hardware interrupts (e.g., the i8259)
 * while running.  It is *not* using VM86 mode. 
 * Maybe that's really the right answer, but real mode
 * is fine for now.  We don't expect to use this very much --
 * just for VGA and APM.
 */
#define realmoderegs (*(Ureg*)RMUADDR)

#define LORMBUF (RMBUF-KZERO)

static Ureg rmu;
static Lock rmlock;

//@Scheck: Assembly
extern void realmode0(void);    /* in l.s */

void
realmode(Ureg *ureg)
{
    int s;
    ulong cr3;

    if(getconf("*norealmode"))
        return;

    lock(&rmlock);
    realmoderegs = *ureg;

    /* copy l.s so that it can be run from 16-bit mode */
    memmove((void*)RMCODE, (void*)KTZERO, 0x1000);

    s = arch_splhi();
    cpu->pdproto[PDX(0)] = cpu->pdproto[PDX(KZERO)];    /* identity map low */
    cr3 = getcr3();
    putcr3(PADDR(cpu->pdproto));
    if (arch)
        arch->introff();
    else
        i8259off();
    realmode0();
    if(cpu->tss){
        /*
         * Called from memory.c before initialization of mmu.
         * Don't turn interrupts on before the kernel is ready!
         */
        if (arch)
            arch->intron();
        else
            i8259on();
    }
    cpu->pdproto[PDX(0)] = 0; /* remove low mapping */
    putcr3(cr3);
    arch_splx(s);
    *ureg = realmoderegs;
    unlock(&rmlock);
}

static long
rtrapread(Chan*, void *a, long n, vlong off)
{
    if(off < 0)
        error("badarg");
    if(n+off > sizeof rmu)
        n = sizeof rmu - off;
    if(n <= 0)
        return 0;
    memmove(a, (char*)&rmu+off, n);
    return n;
}

static long
rtrapwrite(Chan*, void *a, long n, vlong off)
{
    if(off || n != sizeof rmu)
        error("write a Ureg");
    memmove(&rmu, a, sizeof rmu);
    /*
     * Sanity check
     */
    if(rmu.trap == 0x10){   /* VBE */
        rmu.es = (LORMBUF>>4)&0xF000;
        rmu.di = LORMBUF&0xFFFF;
    }else
        error("invalid trap arguments");
    realmode(&rmu);
    return n;
}

static long
rmemrw(int isr, void *a, long n, vlong off)
{
    if(off < 0 || n < 0)
        error("bad offset/count");
    if(isr){
        if(off >= MB)
            return 0;
        if(off+n >= MB)
            n = MB - off;
        memmove(a, KADDR((ulong)off), n);
    }else{
        /* realmode buf page ok, allow vga framebuf's access */
        if(off >= MB || off+n > MB ||
            (off < LORMBUF || off+n > LORMBUF+BY2PG) &&
            (off < 0xA0000 || off+n > 0xB0000+0x10000))
            error("bad offset/count in write");
        memmove(KADDR((ulong)off), a, n);
    }
    return n;
}

static long
rmemread(Chan*, void *a, long n, vlong off)
{
    return rmemrw(1, a, n, off);
}

static long
rmemwrite(Chan*, void *a, long n, vlong off)
{
    return rmemrw(0, a, n, off);
}

<<function realmodelink(x86)>>

@


\subsection*{[[arch/386/x16.ha]]}

<<x16.ha>>=
/*
 * Can't write 16-bit code for 8a without getting into
 * lots of bother, so define some simple commands and
 * output the code directly.
 * 
 * N.B. CALL16(x) kills DI, so don't expect it to be
 * saved across calls.
 */
#define rAX		0		/* rX  */
#define rCX		1
#define rDX		2
#define rBX		3
#define rSP		4		/* SP */
#define rBP		5		/* BP */
#define rSI		6		/* SI */
#define rDI		7		/* DI */

#define rAL		0		/* rL  */
#define rCL		1
#define rDL		2
#define rBL		3
#define rAH		4		/* rH */
#define rCH		5
#define rDH		6
#define rBH		7

#define rES		0		/* rS */
#define rCS		1
#define rSS		2
#define rDS		3
#define rFS		4
#define rGS		5

#define xSI		4		/* rI (index) */
#define xDI		5
#define xBP		6
#define xBX		7

#define rCR0		0		/* rC */
#define rCR2		2
#define rCR3		3
#define rCR4		4

#define OP(o, m, ro, rm)	BYTE $o;	/* op + modr/m byte */	\
   BYTE $(((m)<<6)|((ro)<<3)|(rm))
#define OPrm(o, r, m)	OP(o, 0x00, r, 0x06);	/* general r <-> m */	\
   WORD $m;
#define OPrr(o, r0, r1)	OP(o, 0x03, r0, r1);	/* general r -> r */

#define LW(m, rX)	OPrm(0x8B, rX, m)	/* m -> rX */
#define LXW(x, rI, r)	OP(0x8B, 0x02, r, rI);	/* x(rI) -> r */	\
   WORD $x
#define LBPW(x, r)	OP(0x8B, 0x02, r, xBP);	/* x(rBP) -> r */	\
   WORD $x
#define LB(m, rB)	OPrm(0x8A, rB, m)	/* m -> r[HL] */
#define LXB(x, rI, r)	OP(0x8A, 0x01, r, rI);	/* x(rI) -> r */	\
   BYTE $x
#define LBPB(x, r)	OP(0x8A, 0x01, r, xBP);	/* x(rBP) -> r */	\
   BYTE $x
#define SW(rX, m)	OPrm(0x89, rX, m)	/* rX -> m */
#define SXW(r, x, rI)	OP(0x89, 0x02, r, rI);	/* r -> x(rI) */	\
   WORD $x
#define SBPW(r, x)	OP(0x89, 0x02, r, xBP);	/* r -> x(rBP) */	\
   WORD $(x)
#define SBPWI(i, x)	OP(0xC7, 0x01, 0, xBP);	/* i -> x(rBP) */	\
   BYTE $(x); WORD $(i)
#define STB(rB, m)	OPrm(0x88, rB, m)	/* rB -> m */
#define SXB(r, x, rI)	OP(0x88, 0x01, r, rI);	/* rB -> x(rI) */	\
   BYTE $x
#define SBPB(r, x)	OP(0x88, 0x01, r, xBP);	/* r -> x(rBP) */	\
   BYTE $x
#define SBPBI(i, x)	OP(0xC6, 0x01, 0, xBP);	/* i -> x(rBP) */	\
   BYTE $(x); BYTE $(i)
#define LWI(i, rX)	BYTE $(0xB8+rX);	/* i -> rX */		\
   WORD $i;
#define LBI(i, rB)	BYTE $(0xB0+rB);	/* i -> r[HL] */	\
   BYTE $i

#define MW(r0, r1)	OPrr(0x89, r0, r1)	/* r0 -> r1 */
#define MFSR(rS, rX)	OPrr(0x8C, rS, rX)	/* rS -> rX */
#define MTSR(rX, rS)	OPrr(0x8E, rS, rX)	/* rX -> rS */
#define MFCR(rC, rX)	BYTE $0x0F;		/* rC -> rX */		\
   OP(0x20, 0x03, rC, rX)
#define MTCR(rX, rC)	BYTE $0x0F;		/* rX -> rC */		\
   OP(0x22, 0x03, rC, rX)

#define ADC(r0, r1)	OPrr(0x11, r0, r1)	/* r0 + r1 -> r1 */
#define ADD(r0, r1)	OPrr(0x01, r0, r1)	/* r0 + r1 -> r1 */
#define ADDI(i, r)	OP(0x81, 0x03, 0x00, r);/* i+r -> r */		\
   WORD $i;
#define AND(r0, r1)	OPrr(0x21, r0, r1)	/* r0&r1 -> r1 */
#define ANDI(i, r)	OP(0x81, 0x03, 0x04, r);/* i&r -> r */		\
   WORD $i;
#define CLR(r)		OPrr(0x31, r, r)	/* r^r -> r */
#define CLRB(r)		OPrr(0x30, r, r)	/* r^r -> r */
#define CMP(r0, r1)	OPrr(0x39, r0, r1)	/* r1-r0 -> flags */
#define CMPI(i, r)	OP(0x81, 0x03, 0x07, r);/* r-i -> flags */	\
   WORD $i;
#define CMPBR(r0, r1)	OPrr(0x38, r0, r1)	/* r1-r0 -> flags */
#define DEC(r)		BYTE $(0x48|r)		/* r-1 -> r */
#define DIV(r)		OPrr(0xF7, 0x06, r)	/* rDX:rAX/r -> rAX, rDX:rAX%r -> rDX */
#define INC(r)		BYTE $(0x40|r)		/* r+1 -> r */
#define MUL(r)		OPrr(0xF7, 0x04, r)	/* r*rAX -> rDX:rAX */
#define IMUL(r0, r1)	BYTE $0x0F;		/* r0*r1 -> r1 */	\
   OPrr(0xAF, r1, r0)	/* (signed) */
#define OR(r0, r1)	OPrr(0x09, r0, r1)	/* r0|r1 -> r1 */
#define ORB(r0, r1)	OPrr(0x08, r0, r1)	/* r0|r1 -> r1 */
#define ORI(i, r)	OP(0x81, 0x03, 0x01, r);/* i|r -> r */		\
   WORD $i;
#define ROLI(i, r)	OPrr(0xC1, 0x00, r);	/* r<<>>i -> r */	\
   BYTE $i;
#define SHLI(i, r)	OPrr(0xC1, 0x04, r);	/* r<<i -> r */		\
   BYTE $i;
#define SHLBI(i, r)	OPrr(0xC0, 0x04, r);	/* r<<i -> r */		\
   BYTE $i;
#define SHRI(i, r)	OPrr(0xC1, 0x05, r);	/* r>>i -> r */		\
   BYTE $i;
#define SHRBI(i, r)	OPrr(0xC0, 0x05, r);	/* r>>i -> r */		\
   BYTE $i;
#define SUB(r0, r1)	OPrr(0x29, r0, r1)	/* r1-r0 -> r1 */
#define SUBI(i, r)	OP(0x81, 0x03, 0x05, r);/* r-i -> r */		\
   WORD $i;

#define STOSW		STOSL

#define CALL16(f)	LWI(f, rDI);		/* &f -> rDI */		\
   BYTE $0xFF;		/* (*rDI) */		\
   BYTE $0xD7;
#define FARJUMP16(s, o)	BYTE $0xEA;		/* jump to ptr16:16 */	\
   WORD $o; WORD $s
#define FARJUMP32(s, o)	BYTE $0x66;		/* jump to ptr32:16 */	\
   BYTE $0xEA; LONG $o; WORD $s
#define	DELAY		BYTE $0xEB;		/* jmp .+2 */		\
   BYTE $0x00
#define BIOSCALL(b)	INT $b			/* INT $b */

#define PEEKW		BYTE $0x26;		/* MOVW	rES:[rBX], rAX  */	\
   BYTE $0x8B; BYTE $0x07
#define POKEW		BYTE $0x26;		/* MOVW	rAX, rES:[rBX] */	\
   BYTE $0x89; BYTE $0x07
#define OUTPORTB(p, d)	LBI(d, rAL);		/* d -> I/O port p */	\
   BYTE $0xE6;					\
   BYTE $p; DELAY
#define PUSHA		BYTE $0x60
#define PUSHR(r)	BYTE $(0x50|r)		/* r  -> (--rSP) */
#define PUSHS(rS)	BYTE $(0x06|((rS)<<3))	/* rS  -> (--rSP) */
#define PUSHI(i)	BYTE $0x68; WORD $i;	/* i -> --(rSP) */
#define POPA		BYTE $0x61
#define POPR(r)		BYTE $(0x58|r)		/* (rSP++) -> r */
#define POPS(rS)	BYTE $(0x07|((rS)<<3))	/* (rSP++) -> r */
#define NOP		BYTE $0x90		/* nop */

#define LGDT(gdtptr)	BYTE $0x0F;		/* LGDT */			\
   BYTE $0x01; BYTE $0x16;					\
   WORD $gdtptr

/* operand size switch. */
#define OPSIZE		BYTE $0x66

@
%$
% >> >>


\subsection*{[[buses/386/dma.c]]}

\ifallcode
<<dma.c forward decl(x86)>>=
typedef struct DMAport  DMAport;
typedef struct DMA  DMA;
typedef struct DMAxfer  DMAxfer;
@
\fi

<<buses/386/dma.c>>=
<<kernel basic includes>>

<<dma.c forward decl(x86)>>

/*
 *  state of a dma transfer
 */
struct DMAxfer
{
    ulong   bpa;        /* bounce buffer physical address */
    void*   bva;        /* bounce buffer virtual address */
    int blen;       /* bounce buffer length */
    void*   va;     /* virtual address destination/src */
    long    len;        /* bytes to be transferred */
    int isread;
};

/*
 *  the dma controllers.  the first half of this structure specifies
 *  the I/O ports used by the DMA controllers.
 */
struct DMAport
{
    uchar   addr[4];    /* current address (4 channels) */
    uchar   count[4];   /* current count (4 channels) */
    uchar   page[4];    /* page registers (4 channels) */
    uchar   cmd;        /* command status register */
    uchar   req;        /* request registers */
    uchar   sbm;        /* single bit mask register */
    uchar   mode;       /* mode register */
    uchar   cbp;        /* clear byte pointer */
    uchar   mc;     /* master clear */
    uchar   cmask;      /* clear mask register */
    uchar   wam;        /* write all mask register bit */
};

struct DMA
{
    DMAport;
    int shift;
    Lock;
    DMAxfer x[4];
};

DMA dma[2] = {
    { 0x00, 0x02, 0x04, 0x06,
      0x01, 0x03, 0x05, 0x07,
      0x87, 0x83, 0x81, 0x82,
      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
     0 },

    { 0xc0, 0xc4, 0xc8, 0xcc,
      0xc2, 0xc6, 0xca, 0xce,
      0x8f, 0x8b, 0x89, 0x8a,
      0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
     1 },
};

extern int i8237dma;
static void* i8237bva[2];
static int i8237used;

/*
 *  DMA must be in the first 16MB.  This gets called early by the
 *  initialisation routines of any devices which require DMA to ensure
 *  the allocated bounce buffers are below the 16MB limit.
 */
void
_i8237alloc(void)
{
    void* bva;

    if(i8237dma <= 0)
        return;
    if(i8237dma > 2)
        i8237dma = 2;

    bva = xspanalloc(64*1024*i8237dma, BY2PG, 64*1024);
    if(bva == nil || PADDR(bva)+64*1024*i8237dma > 16*MB){
        /*
         * This will panic with the current
         * implementation of xspanalloc().
        if(bva != nil)
            xfree(bva);
         */
        return;
    }

    i8237bva[0] = bva;
    if(i8237dma == 2)
        i8237bva[1] = ((uchar*)i8237bva[0])+64*1024;
}

/*
 *  DMA must be in the first 16MB.  This gets called early by the
 *  initialisation routines of any devices which require DMA to ensure
 *  the allocated bounce buffers are below the 16MB limit.
 */
int
dmainit(int chan, int maxtransfer)
{
    DMA *dp;
    DMAxfer *xp;
    static int once;

    if(once == 0){
        if(ioalloc(0x00, 0x10, 0, "dma") < 0
        || ioalloc(0x80, 0x10, 0, "dma") < 0
        || ioalloc(0xd0, 0x10, 0, "dma") < 0)
            panic("dmainit");
        once = 1;
    }

    if(maxtransfer > 64*1024)
        maxtransfer = 64*1024;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;
    xp = &dp->x[chan];
    if(xp->bva != nil){
        if(xp->blen < maxtransfer)
            return 1;
        return 0;
    }

    if(i8237used >= i8237dma || i8237bva[i8237used] == nil){
        print("no i8237 DMA bounce buffer < 16MB\n");
        return 1;
    }
    xp->bva = i8237bva[i8237used++];
    xp->bpa = PADDR(xp->bva);
    xp->blen = maxtransfer;
    xp->len = 0;
    xp->isread = 0;

    return 0;
}

/*
 *  setup a dma transfer.  if the destination is not in kernel
 *  memory, allocate a page for the transfer.
 *
 *  we assume BIOS has set up the command register before we
 *  are booted.
 *
 *  return the updated transfer length (we can't transfer across 64k
 *  boundaries)
 */
long
dmasetup(int chan, void *va, long len, int isread)
{
    DMA *dp;
    ulong pa;
    uchar mode;
    DMAxfer *xp;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;
    xp = &dp->x[chan];

    /*
     *  if this isn't kernel memory or crossing 64k boundary or above 16 meg
     *  use the bounce buffer.
     */
    if((ulong)va < KZERO 
    || ((pa=PADDR(va))&0xFFFF0000) != ((pa+len)&0xFFFF0000)
    || pa >= 16*MB){
        if(xp->bva == nil)
            return -1;
        if(len > xp->blen)
            len = xp->blen;
        if(!isread)
            memmove(xp->bva, va, len);
        xp->va = va;
        xp->len = len;
        xp->isread = isread;
        pa = xp->bpa;
    }
    else
        xp->len = 0;

    /*
     * this setup must be atomic
     */
    ilock(dp);
    mode = (isread ? 0x44 : 0x48) | chan;
    outb(dp->mode, mode);   /* single mode dma (give CPU a chance at mem) */
    outb(dp->page[chan], pa>>16);
    outb(dp->cbp, 0);       /* set count & address to their first byte */
    outb(dp->addr[chan], pa>>dp->shift);        /* set address */
    outb(dp->addr[chan], pa>>(8+dp->shift));
    outb(dp->count[chan], (len>>dp->shift)-1);      /* set count */
    outb(dp->count[chan], ((len>>dp->shift)-1)>>8);
    outb(dp->sbm, chan);        /* enable the channel */
    iunlock(dp);

    return len;
}

/*
 *  this must be called after a dma has been completed.
 *
 *  if a page has been allocated for the dma,
 *  copy the data into the actual destination
 *  and free the page.
 */
void
dmaend(int chan)
{
    DMA *dp;
    DMAxfer *xp;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;

    /*
     *  disable the channel
     */
    ilock(dp);
    outb(dp->sbm, 4|chan);
    iunlock(dp);

    xp = &dp->x[chan];
    if(xp->len == 0 || !xp->isread)
        return;

    /*
     *  copy out of temporary page
     */
    memmove(xp->va, xp->bva, xp->len);
    xp->len = 0;
}

@

%//int
%//dmacount(int chan)
%//{
%//  int     retval;
%//  DMA     *dp;
%// 
%//  dp = &dma[(chan>>2)&1];
%//  outb(dp->cbp, 0);
%//  retval = inb(dp->count[chan]);
%//  retval |= inb(dp->count[chan]) << 8;
%//  return((retval<<dp->shift)+1);
%//}
%
%//int
%//dmadone(int chan)
%//{
%//  DMA *dp;
%//
%//  dp = &dma[(chan>>2)&1];
%//  chan = chan & 3;
%//
%//  return inb(dp->cmd) & (1<<chan);
%//}



\subsection*{[[buses/386/pci.c]]}

\ifallcode
<<pci.c forward decl(x86)>>=
void    pcicfgw16(Pcidev*, int, int);
ulong   pcibarsize(Pcidev*, int);
void    pcibussize(Pcidev*, ulong*, ulong*);
void    pcihinv(Pcidev*);
uchar   pciipin(Pcidev*, uchar);

typedef struct Slot Slot;
typedef struct Bridge Bridge;
typedef struct Router Router;
@

<<pci.c debugging macro(x86)>>=
#define DBG if(0) pcilog

int
pcilog(char *fmt, ...)
{
    int n;
    va_list arg;
    char buf[PRINTSIZE];

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    memmove(PCICONS.output+PCICONS.ptr, buf, n);
    PCICONS.ptr += n;
    return n;
}

@ 
\fi

<<global southbridges(x86)>>=
static Bridge southbridges[] = {
    { 0x8086, 0x122e, pIIxget, pIIxset },   /* Intel 82371FB */
    { 0x8086, 0x1234, pIIxget, pIIxset },   /* Intel 82371MX */
    { 0x8086, 0x7000, pIIxget, pIIxset },   /* Intel 82371SB */
    { 0x8086, 0x7110, pIIxget, pIIxset },   /* Intel 82371AB */
    { 0x8086, 0x7198, pIIxget, pIIxset },   /* Intel 82443MX (fn 1) */
    { 0x8086, 0x2410, pIIxget, pIIxset },   /* Intel 82801AA */
    { 0x8086, 0x2420, pIIxget, pIIxset },   /* Intel 82801AB */
    { 0x8086, 0x2440, pIIxget, pIIxset },   /* Intel 82801BA */
    { 0x8086, 0x2448, pIIxget, pIIxset },   /* Intel 82801BAM/CAM/DBM */
    { 0x8086, 0x244c, pIIxget, pIIxset },   /* Intel 82801BAM */
    { 0x8086, 0x244e, pIIxget, pIIxset },   /* Intel 82801 */
    { 0x8086, 0x2480, pIIxget, pIIxset },   /* Intel 82801CA */
    { 0x8086, 0x248c, pIIxget, pIIxset },   /* Intel 82801CAM */
    { 0x8086, 0x24c0, pIIxget, pIIxset },   /* Intel 82801DBL */
    { 0x8086, 0x24cc, pIIxget, pIIxset },   /* Intel 82801DBM */
    { 0x8086, 0x24d0, pIIxget, pIIxset },   /* Intel 82801EB */
    { 0x8086, 0x25a1, pIIxget, pIIxset },   /* Intel 6300ESB */
    { 0x8086, 0x2640, pIIxget, pIIxset },   /* Intel 82801FB */
    { 0x8086, 0x2641, pIIxget, pIIxset },   /* Intel 82801FBM */
    { 0x8086, 0x27b8, pIIxget, pIIxset },   /* Intel 82801GB */
    { 0x8086, 0x27b9, pIIxget, pIIxset },   /* Intel 82801GBM */
    { 0x8086, 0x27bd, pIIxget, pIIxset },   /* Intel 82801GB/GR */
    { 0x8086, 0x3a16, pIIxget, pIIxset },   /* Intel 82801JIR */
    { 0x8086, 0x3a40, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x3a42, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x3a48, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x2916, pIIxget, pIIxset },   /* Intel 82801? */
    { 0x8086, 0x1c02, pIIxget, pIIxset },   /* Intel 6 Series/C200 */
    { 0x8086, 0x1c44, pIIxget, pIIxset },   /* Intel 6 Series/Z68 Express */
    { 0x8086, 0x1e53, pIIxget, pIIxset },   /* Intel 7 Series/C216 */
    { 0x1106, 0x0586, viaget, viaset }, /* Viatech 82C586 */
    { 0x1106, 0x0596, viaget, viaset }, /* Viatech 82C596 */
    { 0x1106, 0x0686, viaget, viaset }, /* Viatech 82C686 */
    { 0x1106, 0x3227, viaget, viaset }, /* Viatech VT8237 */
    { 0x1045, 0xc700, optiget, optiset },   /* Opti 82C700 */
    { 0x10b9, 0x1533, aliget, aliset }, /* Al M1533 */
    { 0x1039, 0x0008, pIIxget, pIIxset },   /* SI 503 */
    { 0x1039, 0x0496, pIIxget, pIIxset },   /* SI 496 */
    { 0x1078, 0x0100, cyrixget, cyrixset }, /* Cyrix 5530 Legacy */

    { 0x1022, 0x746B, nil, nil },       /* AMD 8111 */
    { 0x10DE, 0x00D1, nil, nil },       /* NVIDIA nForce 3 */
    { 0x10DE, 0x00E0, nil, nil },       /* NVIDIA nForce 3 250 Series */
    { 0x10DE, 0x00E1, nil, nil },       /* NVIDIA nForce 3 250 Series */
    { 0x1166, 0x0200, nil, nil },       /* ServerWorks ServerSet III LE */
    { 0x1002, 0x4377, nil, nil },       /* ATI Radeon Xpress 200M */
    { 0x1002, 0x4372, nil, nil },       /* ATI SB400 */
};
@ 


<<function upareserve(x86)>>=
void
upareserve(ulong pa, int size)
{
    ulong a;
    
    a = mapalloc(&rmapupa, pa, size, 0);
    if(a != pa){
        /*
         * This can happen when we're using the E820
         * map, which might have already reserved some
         * of the regions claimed by the pci devices.
         */
    //  print("upareserve: cannot reserve pa=%#.8lux size=%d\n", pa, size);
        if(a != 0)
            mapfree(&rmapupa, a, size);
    }
}
@


<<pci.c>>=
/*
 * PCI support code.
 * Needs a massive rewrite.
 */
<<kernel basic includes>>
#include "io.h"

/* let each port override any of these */
#ifndef PCICONSSIZE
#define PCICONSSIZE (16*1024)
#endif

struct PCICons
{
    char    output[PCICONSSIZE];
    int ptr;
};
struct PCICons PCICONS;

int pcivga;

<<pci.c forward decl(x86)>>

<<pci.c debugging macro(x86)>>


enum
{                   /* configuration mechanism #1 */
    PciADDR     = 0xCF8,    /* CONFIG_ADDRESS */
    PciDATA     = 0xCFC,    /* CONFIG_DATA */

                    /* configuration mechanism #2 */
    PciCSE      = 0xCF8,    /* configuration space enable */
    PciFORWARD  = 0xCFA,    /* which bus */

    MaxFNO      = 7,
    MaxUBN      = 255,
};

enum
{                   /* command register */
    IOen        = (1<<0),
    MEMen       = (1<<1),
    MASen       = (1<<2),
    MemWrInv    = (1<<4),
    PErrEn      = (1<<6),
    SErrEn      = (1<<8),
};

static Lock pcicfglock;
static Lock pcicfginitlock;
static int pcicfgmode = -1;
static int pcimaxbno = 7;
static int pcimaxdno;
static Pcidev* pciroot;
static Pcidev* pcilist;
static Pcidev* pcitail;
static int nobios, nopcirouting;
static BIOS32si* pcibiossi;

static int pcicfgrw8raw(int, int, int, int);
static int pcicfgrw16raw(int, int, int, int);
static int pcicfgrw32raw(int, int, int, int);

static int (*pcicfgrw8)(int, int, int, int) = pcicfgrw8raw;
static int (*pcicfgrw16)(int, int, int, int) = pcicfgrw16raw;
static int (*pcicfgrw32)(int, int, int, int) = pcicfgrw32raw;

static char* bustypes[] = {
    "CBUSI",
    "CBUSII",
    "EISA",
    "FUTURE",
    "INTERN",
    "ISA",
    "MBI",
    "MBII",
    "MCA",
    "MPI",
    "MPSA",
    "NUBUS",
    "PCI",
    "PCMCIA",
    "TC",
    "VL",
    "VME",
    "XPRESS",
};

static int
tbdffmt(Fmt* fmt)
{
    char *p;
    int l, r;
    uint type, tbdf;

    if((p = malloc(READSTR)) == nil)
        return fmtstrcpy(fmt, "(tbdfconv)");

    switch(fmt->r){
    case 'T':
        tbdf = va_arg(fmt->args, int);
        if(tbdf == BUSUNKNOWN)
            snprint(p, READSTR, "unknown");
        else{
            type = BUSTYPE(tbdf);
            if(type < nelem(bustypes))
                l = snprint(p, READSTR, bustypes[type]);
            else
                l = snprint(p, READSTR, "%d", type);
            snprint(p+l, READSTR-l, ".%d.%d.%d",
                BUSBNO(tbdf), BUSDNO(tbdf), BUSFNO(tbdf));
        }
        break;

    default:
        snprint(p, READSTR, "(tbdfconv)");
        break;
    }
    r = fmtstrcpy(fmt, p);
    free(p);

    return r;
}

ulong
pcibarsize(Pcidev *p, int rno)
{
    ulong v, size;

    v = pcicfgrw32(p->tbdf, rno, 0, 1);
    pcicfgrw32(p->tbdf, rno, 0xFFFFFFF0, 0);
    size = pcicfgrw32(p->tbdf, rno, 0, 1);
    if(v & 1)
        size |= 0xFFFF0000;
    pcicfgrw32(p->tbdf, rno, v, 0);

    return -(size & ~0x0F);
}

static int
pcisizcmp(void *a, void *b)
{
    Pcisiz *aa, *bb;

    aa = a;
    bb = b;
    return aa->siz - bb->siz;
}

static ulong
pcimask(ulong v)
{
    ulong m;

    m = BI2BY*sizeof(v);
    for(m = 1<<(m-1); m != 0; m >>= 1) {
        if(m & v)
            break;
    }

    m--;
    if((v & m) == 0)
        return v;

    v |= m;
    return v+1;
}

static void
pcibusmap(Pcidev *root, ulong *pmema, ulong *pioa, int wrreg)
{
    Pcidev *p;
    int ntb, i, size, rno, hole;
    ulong v, mema, ioa, sioa, smema, base, limit;
    Pcisiz *table, *tptr, *mtb, *itb;

    if(!nobios)
        return;

    ioa = *pioa;
    mema = *pmema;

    DBG("pcibusmap wr=%d %T mem=%luX io=%luX\n",
        wrreg, root->tbdf, mema, ioa);

    ntb = 0;
    for(p = root; p != nil; p = p->link)
        ntb++;

    ntb *= (PciCIS-PciBAR0)/4;
    table = malloc(2*ntb*sizeof(Pcisiz));
    if(table == nil)
        panic("pcibusmap: no memory");
    itb = table;
    mtb = table+ntb;

    /*
     * Build a table of sizes
     */
    for(p = root; p != nil; p = p->link) {
        if(p->ccrb == 0x06) {
            if(p->ccru != 0x04 || p->bridge == nil) {
//              DBG("pci: ignored bridge %T\n", p->tbdf);
                continue;
            }

            sioa = ioa;
            smema = mema;
            pcibusmap(p->bridge, &smema, &sioa, 0);

            hole = pcimask(smema-mema);
            if(hole < (1<<20))
                hole = 1<<20;
            p->mema.size = hole;

            hole = pcimask(sioa-ioa);
            if(hole < (1<<12))
                hole = 1<<12;

            p->ioa.size = hole;

            itb->dev = p;
            itb->bar = -1;
            itb->siz = p->ioa.size;
            itb++;

            mtb->dev = p;
            mtb->bar = -1;
            mtb->siz = p->mema.size;
            mtb++;
            continue;
        }

        for(i = 0; i <= 5; i++) {
            rno = PciBAR0 + i*4;
            v = pcicfgrw32(p->tbdf, rno, 0, 1);
            size = pcibarsize(p, rno);
            if(size == 0)
                continue;

            if(v & 1) {
                itb->dev = p;
                itb->bar = i;
                itb->siz = size;
                itb++;
            }
            else {
                mtb->dev = p;
                mtb->bar = i;
                mtb->siz = size;
                mtb++;
            }

            p->mem[i].size = size;
        }
    }

    /*
     * Sort both tables IO smallest first, Memory largest
     */
    qsort(table, itb-table, sizeof(Pcisiz), pcisizcmp);
    tptr = table+ntb;
    qsort(tptr, mtb-tptr, sizeof(Pcisiz), pcisizcmp);

    /*
     * Allocate IO address space on this bus
     */
    for(tptr = table; tptr < itb; tptr++) {
        hole = tptr->siz;
        if(tptr->bar == -1)
            hole = 1<<12;
        ioa = ROUND(ioa, hole);

        p = tptr->dev;
        if(tptr->bar == -1)
            p->ioa.bar = ioa;
        else {
            p->pcr |= IOen;
            p->mem[tptr->bar].bar = ioa|1;
            if(wrreg)
                pcicfgrw32(p->tbdf, PciBAR0+(tptr->bar*4), ioa|1, 0);
        }

        ioa += tptr->siz;
    }

    /*
     * Allocate Memory address space on this bus
     */
    for(tptr = table+ntb; tptr < mtb; tptr++) {
        hole = tptr->siz;
        if(tptr->bar == -1)
            hole = 1<<20;
        mema = ROUND(mema,hole);

        p = tptr->dev;
        if(tptr->bar == -1)
            p->mema.bar = mema;
        else {
            p->pcr |= MEMen;
            p->mem[tptr->bar].bar = mema;
            if(wrreg)
                pcicfgrw32(p->tbdf, PciBAR0+(tptr->bar*4), mema, 0);
        }
        mema += tptr->siz;
    }

    *pmema = mema;
    *pioa = ioa;
    free(table);

    if(wrreg == 0)
        return;

    /*
     * Finally set all the bridge addresses & registers
     */
    for(p = root; p != nil; p = p->link) {
        if(p->bridge == nil) {
            pcicfgrw8(p->tbdf, PciLTR, 64, 0);

            p->pcr |= MASen;
            pcicfgrw16(p->tbdf, PciPCR, p->pcr, 0);
            continue;
        }

        base = p->ioa.bar;
        limit = base+p->ioa.size-1;
        v = pcicfgrw32(p->tbdf, PciIBR, 0, 1);
        v = (v&0xFFFF0000)|(limit & 0xF000)|((base & 0xF000)>>8);
        pcicfgrw32(p->tbdf, PciIBR, v, 0);
        v = (limit & 0xFFFF0000)|(base>>16);
        pcicfgrw32(p->tbdf, PciIUBR, v, 0);

        base = p->mema.bar;
        limit = base+p->mema.size-1;
        v = (limit & 0xFFF00000)|((base & 0xFFF00000)>>16);
        pcicfgrw32(p->tbdf, PciMBR, v, 0);

        /*
         * Disable memory prefetch
         */
        pcicfgrw32(p->tbdf, PciPMBR, 0x0000FFFF, 0);
        pcicfgrw8(p->tbdf, PciLTR, 64, 0);

        /*
         * Enable the bridge
         */
        p->pcr |= IOen|MEMen|MASen;
        pcicfgrw32(p->tbdf, PciPCR, 0xFFFF0000|p->pcr , 0);

        sioa = p->ioa.bar;
        smema = p->mema.bar;
        pcibusmap(p->bridge, &smema, &sioa, 1);
    }
}

/* side effect: if a video controller is seen, set pcivga non-zero */
static int
pcilscan(int bno, Pcidev** list)
{
    Pcidev *p, *head, *tail;
    int dno, fno, i, hdt, l, maxfno, maxubn, rno, sbn, tbdf, ubn;

    maxubn = bno;
    head = nil;
    tail = nil;
    for(dno = 0; dno <= pcimaxdno; dno++){
        maxfno = 0;
        for(fno = 0; fno <= maxfno; fno++){
            /*
             * For this possible device, form the
             * bus+device+function triplet needed to address it
             * and try to read the vendor and device ID.
             * If successful, allocate a device struct and
             * start to fill it in with some useful information
             * from the device's configuration space.
             */
            tbdf = MKBUS(BusPCI, bno, dno, fno);
            l = pcicfgrw32(tbdf, PciVID, 0, 1);
            if(l == 0xFFFFFFFF || l == 0)
                continue;
            p = malloc(sizeof(*p));
            if(p == nil)
                panic("pcilscan: no memory");
            p->tbdf = tbdf;
            p->vid = l;
            p->did = l>>16;

            if(pcilist != nil)
                pcitail->list = p;
            else
                pcilist = p;
            pcitail = p;

            p->pcr = pcicfgr16(p, PciPCR);
            p->rid = pcicfgr8(p, PciRID);
            p->ccrp = pcicfgr8(p, PciCCRp);
            p->ccru = pcicfgr8(p, PciCCRu);
            p->ccrb = pcicfgr8(p, PciCCRb);
            p->cls = pcicfgr8(p, PciCLS);
            p->ltr = pcicfgr8(p, PciLTR);

            p->intl = pcicfgr8(p, PciINTL);

            /*
             * If the device is a multi-function device adjust the
             * loop count so all possible functions are checked.
             */
            hdt = pcicfgr8(p, PciHDT);
            if(hdt & 0x80)
                maxfno = MaxFNO;

            /*
             * If appropriate, read the base address registers
             * and work out the sizes.
             */
            switch(p->ccrb) {
            case 0x03:      /* display controller */
                pcivga = 1;
                /* fall through */
            case 0x01:      /* mass storage controller */
            case 0x02:      /* network controller */
            case 0x04:      /* multimedia device */
            case 0x07:      /* simple comm. controllers */
            case 0x08:      /* base system peripherals */
            case 0x09:      /* input devices */
            case 0x0A:      /* docking stations */
            case 0x0B:      /* processors */
            case 0x0C:      /* serial bus controllers */
                if((hdt & 0x7F) != 0)
                    break;
                rno = PciBAR0 - 4;
                for(i = 0; i < nelem(p->mem); i++) {
                    rno += 4;
                    p->mem[i].bar = pcicfgr32(p, rno);
                    p->mem[i].size = pcibarsize(p, rno);
                }
                break;

            case 0x00:
            case 0x05:      /* memory controller */
            case 0x06:      /* bridge device */
            default:
                break;
            }

            if(head != nil)
                tail->link = p;
            else
                head = p;
            tail = p;
        }
    }

    *list = head;
    for(p = head; p != nil; p = p->link){
        /*
         * Find PCI-PCI bridges and recursively descend the tree.
         */
        if(p->ccrb != 0x06 || p->ccru != 0x04)
            continue;

        /*
         * If the secondary or subordinate bus number is not
         * initialised try to do what the PCI BIOS should have
         * done and fill in the numbers as the tree is descended.
         * On the way down the subordinate bus number is set to
         * the maximum as it's not known how many buses are behind
         * this one; the final value is set on the way back up.
         */
        sbn = pcicfgr8(p, PciSBN);
        ubn = pcicfgr8(p, PciUBN);

        if(sbn == 0 || ubn == 0 || nobios) {
            sbn = maxubn+1;
            /*
             * Make sure memory, I/O and master enables are
             * off, set the primary, secondary and subordinate
             * bus numbers and clear the secondary status before
             * attempting to scan the secondary bus.
             *
             * Initialisation of the bridge should be done here.
             */
            pcicfgw32(p, PciPCR, 0xFFFF0000);
            l = (MaxUBN<<16)|(sbn<<8)|bno;
            pcicfgw32(p, PciPBN, l);
            pcicfgw16(p, PciSPSR, 0xFFFF);
            maxubn = pcilscan(sbn, &p->bridge);
            l = (maxubn<<16)|(sbn<<8)|bno;

            pcicfgw32(p, PciPBN, l);
        }
        else {
            if(ubn > maxubn)
                maxubn = ubn;
            pcilscan(sbn, &p->bridge);
        }
    }

    return maxubn;
}

static uchar
pIIxget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 0x60, 0x61, 0x62, 0x63 */
    pirq = pcicfgr8(router, link);
    return (pirq < 16)? pirq: 0;
}

static void
pIIxset(Pcidev *router, uchar link, uchar irq)
{
    pcicfgw8(router, link, irq);
}

static uchar
viaget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 1, 2, 3, 5 */
    pirq = (link < 6)? pcicfgr8(router, 0x55 + (link>>1)): 0;

    return (link & 1)? (pirq >> 4): (pirq & 15);
}

static void
viaset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0x55 + (link >> 1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0x55 + (link>>1), pirq);
}

static uchar
optiget(Pcidev *router, uchar link)
{
    uchar pirq = 0;

    /* link should be 0x02, 0x12, 0x22, 0x32 */
    if ((link & 0xcf) == 0x02)
        pirq = pcicfgr8(router, 0xb8 + (link >> 5));
    return (link & 0x10)? (pirq >> 4): (pirq & 15);
}

static void
optiset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0xb8 + (link >> 5));
        pirq &= (link & 0x10)? 0x0f : 0xf0;
        pirq |= (link & 0x10)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0xb8 + (link >> 5), pirq);
}

static uchar
aliget(Pcidev *router, uchar link)
{
    /* No, you're not dreaming */
    static const uchar map[] = { 0, 9, 3, 10, 4, 5, 7, 6, 1, 11, 0, 12, 0, 14, 0, 15 };
    uchar pirq;

    /* link should be 0x01..0x08 */
    pirq = pcicfgr8(router, 0x48 + ((link-1)>>1));
    return (link & 1)? map[pirq&15]: map[pirq>>4];
}

static void
aliset(Pcidev *router, uchar link, uchar irq)
{
    /* Inverse of map in aliget */
    static const uchar map[] = { 0, 8, 0, 2, 4, 5, 7, 6, 0, 1, 3, 9, 11, 0, 13, 15 };
    uchar pirq;

    pirq = pcicfgr8(router, 0x48 + ((link-1)>>1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (map[irq] << 4): (map[irq] & 15);
    pcicfgw8(router, 0x48 + ((link-1)>>1), pirq);
}

static uchar
cyrixget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 1, 2, 3, 4 */
    pirq = pcicfgr8(router, 0x5c + ((link-1)>>1));
    return ((link & 1)? pirq >> 4: pirq & 15);
}

static void
cyrixset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0x5c + (link>>1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0x5c + (link>>1), pirq);
}

struct Bridge
{
    ushort  vid;
    ushort  did;
    uchar   (*get)(Pcidev *, uchar);
    void    (*set)(Pcidev *, uchar, uchar);
};

<<global southbridges(x86)>>

struct Slot {
    uchar   bus;        /* Pci bus number */
    uchar   dev;        /* Pci device number */
    uchar   maps[12];   /* Avoid structs!  Link and mask. */
    uchar   slot;       /* Add-in/built-in slot */
    uchar   reserved;
};

struct Router {
    uchar   signature[4];   /* Routing table signature */
    uchar   version[2]; /* Version number */
    uchar   size[2];    /* Total table size */
    uchar   bus;        /* Interrupt router bus number */
    uchar   devfn;      /* Router's devfunc */
    uchar   pciirqs[2]; /* Exclusive PCI irqs */
    uchar   compat[4];  /* Compatible PCI interrupt router */
    uchar   miniport[4];    /* Miniport data */
    uchar   reserved[11];
    uchar   checksum;
};

static ushort pciirqs;      /* Exclusive PCI irqs */
static Bridge *southbridge; /* Which southbridge to use. */

static void
pcirouting(void)
{
    Slot *e;
    Router *r;
    int size, i, fn, tbdf;
    Pcidev *sbpci, *pci;
    uchar *p, pin, irq, link, *map;

    /* Search for PCI interrupt routing table in BIOS */
    for(p = (uchar *)KADDR(0xf0000); p < (uchar *)KADDR(0xfffff); p += 16)
        if(p[0] == '$' && p[1] == 'P' && p[2] == 'I' && p[3] == 'R')
            break;

    if(p >= (uchar *)KADDR(0xfffff)) {
        // print("no PCI intr routing table found\n");
        return;
    }

    r = (Router *)p;

    if (0)
        print("PCI interrupt routing table version %d.%d at %#.6luX\n",
            r->version[0], r->version[1], (ulong)r & 0xfffff);

    tbdf = (BusPCI << 24)|(r->bus << 16)|(r->devfn << 8);
    sbpci = pcimatchtbdf(tbdf);
    if(sbpci == nil) {
        print("pcirouting: Cannot find south bridge %T\n", tbdf);
        return;
    }

    for(i = 0; i != nelem(southbridges); i++)
        if(sbpci->vid == southbridges[i].vid && sbpci->did == southbridges[i].did)
            break;

    if(i == nelem(southbridges)) {
        print("pcirouting: ignoring south bridge %T %.4uX/%.4uX\n", tbdf, sbpci->vid, sbpci->did);
        return;
    }
    southbridge = &southbridges[i];
    if(southbridge->get == nil || southbridge->set == nil)
        return;

    pciirqs = (r->pciirqs[1] << 8)|r->pciirqs[0];

    size = (r->size[1] << 8)|r->size[0];
    for(e = (Slot *)&r[1]; (uchar *)e < p + size; e++) {
        if (0) {
            print("%.2uX/%.2uX %.2uX: ", e->bus, e->dev, e->slot);
            for (i = 0; i != 4; i++) {
                uchar *m = &e->maps[i * 3];
                print("[%d] %.2uX %.4uX ",
                    i, m[0], (m[2] << 8)|m[1]);
            }
            print("\n");
        }
        for(fn = 0; fn != 8; fn++) {
            tbdf = (BusPCI << 24)|(e->bus << 16)|((e->dev | fn) << 8);
            pci = pcimatchtbdf(tbdf);
            if(pci == nil)
                continue;
            pin = pcicfgr8(pci, PciINTP);
            if(pin == 0 || pin == 0xff)
                continue;

            map = &e->maps[(pin - 1) * 3];
            link = map[0];
            irq = southbridge->get(sbpci, link);
            if(irq == 0 || irq == pci->intl)
                continue;
            if(pci->intl != 0 && pci->intl != 0xFF) {
                print("pcirouting: BIOS workaround: %T at pin %d link %d irq %d -> %d\n",
                      tbdf, pin, link, irq, pci->intl);
                southbridge->set(sbpci, link, pci->intl);
                continue;
            }
            print("pcirouting: %T at pin %d link %d irq %d\n", tbdf, pin, link, irq);
            pcicfgw8(pci, PciINTL, irq);
            pci->intl = irq;
        }
    }
}

static void pcireservemem(void);

static int
pcicfgrw8bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB108;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx & 0xFF;
    }
    else{
        ci.eax = 0xB10B;
        ci.ecx = data & 0xFF;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static int
pcicfgrw16bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB109;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx & 0xFFFF;
    }
    else{
        ci.eax = 0xB10C;
        ci.ecx = data & 0xFFFF;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static int
pcicfgrw32bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB10A;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx;
    }
    else{
        ci.eax = 0xB10D;
        ci.ecx = data;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static BIOS32si*
pcibiosinit(void)
{
    BIOS32ci ci;
    BIOS32si *si;

    if((si = bios32open("$PCI")) == nil)
        return nil;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.eax = 0xB101;
    if(bios32ci(si, &ci) || ci.edx != ((' '<<24)|('I'<<16)|('C'<<8)|'P')){
        free(si);
        return nil;
    }
    if(ci.eax & 0x01)
        pcimaxdno = 31;
    else
        pcimaxdno = 15;
    pcimaxbno = ci.ecx & 0xff;

    return si;
}

void
pcibussize(Pcidev *root, ulong *msize, ulong *iosize)
{
    *msize = 0;
    *iosize = 0;
    pcibusmap(root, msize, iosize, 0);
}

static void
pcicfginit(void)
{
    char *p;
    Pcidev **list;
    ulong mema, ioa;
    int bno, n, pcibios;

    lock(&pcicfginitlock);
    if(pcicfgmode != -1)
        goto out;

    pcibios = 0;
    if(getconf("*nobios"))
        nobios = 1;
    else if(getconf("*pcibios"))
        pcibios = 1;
    if(getconf("*nopcirouting"))
        nopcirouting = 1;

    /*
     * Try to determine which PCI configuration mode is implemented.
     * Mode2 uses a byte at 0xCF8 and another at 0xCFA; Mode1 uses
     * a DWORD at 0xCF8 and another at 0xCFC and will pass through
     * any non-DWORD accesses as normal I/O cycles. There shouldn't be
     * a device behind these addresses so if Mode1 accesses fail try
     * for Mode2 (Mode2 is deprecated).
     */
    if(!pcibios){
        /*
         * Bits [30:24] of PciADDR must be 0,
         * according to the spec.
         */
        n = inl(PciADDR);
        if(!(n & 0x7F000000)){
            outl(PciADDR, 0x80000000);
            outb(PciADDR+3, 0);
            if(inl(PciADDR) & 0x80000000){
                pcicfgmode = 1;
                pcimaxdno = 31;
            }
        }
        outl(PciADDR, n);

        if(pcicfgmode < 0){
            /*
             * The 'key' part of PciCSE should be 0.
             */
            n = inb(PciCSE);
            if(!(n & 0xF0)){
                outb(PciCSE, 0x0E);
                if(inb(PciCSE) == 0x0E){
                    pcicfgmode = 2;
                    pcimaxdno = 15;
                }
            }
            outb(PciCSE, n);
        }
    }

    if(pcicfgmode < 0 || pcibios) {
        if((pcibiossi = pcibiosinit()) == nil)
            goto out;
        pcicfgrw8 = pcicfgrw8bios;
        pcicfgrw16 = pcicfgrw16bios;
        pcicfgrw32 = pcicfgrw32bios;
        pcicfgmode = 3;
    }

    fmtinstall('T', tbdffmt);

    if(p = getconf("*pcimaxbno")){
        n = strtoul(p, 0, 0);
        if(n < pcimaxbno)
            pcimaxbno = n;
    }
    if(p = getconf("*pcimaxdno")){
        n = strtoul(p, 0, 0);
        if(n < pcimaxdno)
            pcimaxdno = n;
    }

    list = &pciroot;
    for(bno = 0; bno <= pcimaxbno; bno++) {
        int sbno = bno;
        bno = pcilscan(bno, list);

        while(*list)
            list = &(*list)->link;

        if (sbno == 0) {
            Pcidev *pci;

            /*
              * If we have found a PCI-to-Cardbus bridge, make sure
              * it has no valid mappings anymore.
              */
            for(pci = pciroot; pci != nil; pci = pci->link){
                if (pci->ccrb == 6 && pci->ccru == 7) {
                    ushort bcr;

                    /* reset the cardbus */
                    bcr = pcicfgr16(pci, PciBCR);
                    pcicfgw16(pci, PciBCR, 0x40 | bcr);
                    arch_delay(50);
                }
            }
        }
    }

    if(pciroot == nil)
        goto out;

    if(nobios) {
        /*
         * Work out how big the top bus is
         */
        pcibussize(pciroot, &mema, &ioa);

        /*
         * Align the windows and map it
         */
        ioa = 0x1000;
        mema = 0x90000000;

        pcilog("Mask sizes: mem=%lux io=%lux\n", mema, ioa);

        pcibusmap(pciroot, &mema, &ioa, 1);
        DBG("Sizes2: mem=%lux io=%lux\n", mema, ioa);

        unlock(&pcicfginitlock);
        return;
    }

    if (!nopcirouting)
        pcirouting();

out:
    pcireservemem();
    unlock(&pcicfginitlock);

    if(getconf("*pcihinv"))
        pcihinv(nil);
}

static void
pcireservemem(void)
{
    int i;
    Pcidev *p;

    /*
     * mark all the physical address space claimed by pci devices
     * as in use, so that upaalloc doesn't give it out.
     */
    for(p=pciroot; p; p=p->list)
        for(i=0; i<nelem(p->mem); i++)
            if(p->mem[i].bar && (p->mem[i].bar&1) == 0)
                upareserve(p->mem[i].bar&~0x0F, p->mem[i].size);
}

static int
pcicfgrw8raw(int tbdf, int rno, int data, int read)
{
    int o, type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        o = rno & 0x03;
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = inb(PciDATA+o);
        else
            outb(PciDATA+o, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = inb((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outb((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr8(Pcidev* pcidev, int rno)
{
    return pcicfgrw8(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw8(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw8(pcidev->tbdf, rno, data, 0);
}

static int
pcicfgrw16raw(int tbdf, int rno, int data, int read)
{
    int o, type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        o = rno & 0x02;
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = ins(PciDATA+o);
        else
            outs(PciDATA+o, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = ins((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outs((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr16(Pcidev* pcidev, int rno)
{
    return pcicfgrw16(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw16(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw16(pcidev->tbdf, rno, data, 0);
}

static int
pcicfgrw32raw(int tbdf, int rno, int data, int read)
{
    int type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = inl(PciDATA);
        else
            outl(PciDATA, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = inl((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outl((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr32(Pcidev* pcidev, int rno)
{
    return pcicfgrw32(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw32(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw32(pcidev->tbdf, rno, data, 0);
}

Pcidev*
pcimatch(Pcidev* prev, int vid, int did)
{
    if(pcicfgmode == -1)
        pcicfginit();

    if(prev == nil)
        prev = pcilist;
    else
        prev = prev->list;

    while(prev != nil){
        if((vid == 0 || prev->vid == vid)
        && (did == 0 || prev->did == did))
            break;
        prev = prev->list;
    }
    return prev;
}

Pcidev*
pcimatchtbdf(int tbdf)
{
    Pcidev *pcidev;

    if(pcicfgmode == -1)
        pcicfginit();

    for(pcidev = pcilist; pcidev != nil; pcidev = pcidev->list) {
        if(pcidev->tbdf == tbdf)
            break;
    }
    return pcidev;
}

uchar
pciipin(Pcidev *pci, uchar pin)
{
    if (pci == nil)
        pci = pcilist;

    while (pci) {
        uchar intl;

        if (pcicfgr8(pci, PciINTP) == pin && pci->intl != 0 && pci->intl != 0xff)
            return pci->intl;

        if (pci->bridge && (intl = pciipin(pci->bridge, pin)) != 0)
            return intl;

        pci = pci->list;
    }
    return 0;
}

static void
pcilhinv(Pcidev* p)
{
    int i;
    Pcidev *t;

    if(p == nil) {
        putstrn(PCICONS.output, PCICONS.ptr);
        p = pciroot;
        print("bus dev type vid  did intl memory\n");
    }
    for(t = p; t != nil; t = t->link) {
        print("%d  %2d/%d %.2ux %.2ux %.2ux %.4ux %.4ux %3d  ",
            BUSBNO(t->tbdf), BUSDNO(t->tbdf), BUSFNO(t->tbdf),
            t->ccrb, t->ccru, t->ccrp, t->vid, t->did, t->intl);

        for(i = 0; i < nelem(p->mem); i++) {
            if(t->mem[i].size == 0)
                continue;
            print("%d:%.8lux %d ", i,
                t->mem[i].bar, t->mem[i].size);
        }
        if(t->ioa.bar || t->ioa.size)
            print("ioa:%.8lux %d ", t->ioa.bar, t->ioa.size);
        if(t->mema.bar || t->mema.size)
            print("mema:%.8lux %d ", t->mema.bar, t->mema.size);
        if(t->bridge)
            print("->%d", BUSBNO(t->bridge->tbdf));
        print("\n");
    }
    while(p != nil) {
        if(p->bridge != nil)
            pcilhinv(p->bridge);
        p = p->link;
    }
}

void
pcihinv(Pcidev* p)
{
    if(pcicfgmode == -1)
        pcicfginit();
    lock(&pcicfginitlock);
    pcilhinv(p);
    unlock(&pcicfginitlock);
}

void
pcireset(void)
{
    Pcidev *p;

    if(pcicfgmode == -1)
        pcicfginit();

    for(p = pcilist; p != nil; p = p->list) {
        /* don't mess with the bridges */
        if(p->ccrb == 0x06)
            continue;
        pciclrbme(p);
    }
}



void
pcisetbme(Pcidev* p)
{
    p->pcr |= MASen;
    pcicfgw16(p, PciPCR, p->pcr);
}

void
pciclrbme(Pcidev* p)
{
    p->pcr &= ~MASen;
    pcicfgw16(p, PciPCR, p->pcr);
}

@

%//int
%//pciscan(int bno, Pcidev **list)
%//{
%//  int ubn;
%//
%//  lock(&pcicfginitlock);
%//  ubn = pcilscan(bno, list);
%//  unlock(&pcicfginitlock);
%//  return ubn;
%//}
%
%//void
%//pcisetioe(Pcidev* p)
%//{
%//  p->pcr |= IOen;
%//  pcicfgw16(p, PciPCR, p->pcr);
%//}
%
%//void
%//pciclrioe(Pcidev* p)
%//{
%//  p->pcr &= ~IOen;
%//  pcicfgw16(p, PciPCR, p->pcr);
%//}
%
%//void
%//pcisetmwi(Pcidev* p)
%//{
%//  p->pcr |= MemWrInv;
%//  pcicfgw16(p, PciPCR, p->pcr);
%//}
%
%//void
%//pciclrmwi(Pcidev* p)
%//{
%//  p->pcr &= ~MemWrInv;
%//  pcicfgw16(p, PciPCR, p->pcr);
%//}
%
%//static int
%//pcigetpmrb(Pcidev* p)
%//{
%//  int ptr;
%//
%//  if(p->pmrb != 0)
%//      return p->pmrb;
%//  p->pmrb = -1;
%//
%//  /*
%//   * If there are no extended capabilities implemented,
%//   * (bit 4 in the status register) assume there's no standard
%//   * power management method.
%//   * Find the capabilities pointer based on PCI header type.
%//   */
%//  if(!(pcicfgr16(p, PciPSR) & 0x0010))
%//      return -1;
%//  switch(pcicfgr8(p, PciHDT)){
%//  default:
%//      return -1;
%//  case 0:                 /* all other */
%//  case 1:                 /* PCI to PCI bridge */
%//      ptr = 0x34;
%//      break;
%//  case 2:                 /* CardBus bridge */
%//      ptr = 0x14;
%//      break;
%//  }
%//  ptr = pcicfgr32(p, ptr);
%//
%//  while(ptr != 0){
%//      /*
%//       * Check for validity.
%//       * Can't be in standard header and must be double
%//       * word aligned.
%//       */
%//      if(ptr < 0x40 || (ptr & ~0xFC))
%//          return -1;
%//      if(pcicfgr8(p, ptr) == 0x01){
%//          p->pmrb = ptr;
%//          return ptr;
%//      }
%//
%//      ptr = pcicfgr8(p, ptr+1);
%//  }
%//
%//  return -1;
%//}
%
%//int
%//pcigetpms(Pcidev* p)
%//{
%//  int pmcsr, ptr;
%//
%//  if((ptr = pcigetpmrb(p)) == -1)
%//      return -1;
%//
%//  /*
%//   * Power Management Register Block:
%//   *  offset 0:   Capability ID
%//   *     1:   next item pointer
%//   *     2:   capabilities
%//   *     4:   control/status
%//   *     6:   bridge support extensions
%//   *     7:   data
%//   */
%//  pmcsr = pcicfgr16(p, ptr+4);
%//
%//  return pmcsr & 0x0003;
%//}
%
%//int
%//pcisetpms(Pcidev* p, int state)
%//{
%//  int ostate, pmc, pmcsr, ptr;
%//
%//  if((ptr = pcigetpmrb(p)) == -1)
%//      return -1;
%//
%//  pmc = pcicfgr16(p, ptr+2);
%//  pmcsr = pcicfgr16(p, ptr+4);
%//  ostate = pmcsr & 0x0003;
%//  pmcsr &= ~0x0003;
%//
%//  switch(state){
%//  default:
%//      return -1;
%//  case 0:
%//      break;
%//  case 1:
%//      if(!(pmc & 0x0200))
%//          return -1;
%//      break;
%//  case 2:
%//      if(!(pmc & 0x0400))
%//          return -1;
%//      break;
%//  case 3:
%//      break;
%//  }
%//  pmcsr |= state;
%//  pcicfgw16(p, ptr+4, pmcsr);
%//
%//  return ostate;
%//}


\subsection*{[[buses/386/uarti8250.c]]}

\ifallcode
<<uarti8250.c forward decl(x86)>>=
typedef struct CtlrUart CtlrUart;
@
\fi


<<uarti8250.c>>=
<<kernel basic includes>>
#include "io.h"

/*
 * 8250 UART and compatibles.
 */
enum {
    Uart0       = 0x3F8,    /* COM1 */
    Uart0IRQ    = 4,
    Uart1       = 0x2F8,    /* COM2 */
    Uart1IRQ    = 3,

    UartFREQ    = 1843200,
};

enum {                  /* I/O ports */
    Rbr     = 0,        /* Receiver Buffer (RO) */
    Thr     = 0,        /* Transmitter Holding (WO) */
    Ier     = 1,        /* Interrupt Enable */
    Iir     = 2,        /* Interrupt Identification (RO) */
    Fcr     = 2,        /* FIFO Control (WO) */
    Lcr     = 3,        /* Line Control */
    Mcr     = 4,        /* Modem Control */
    Lsr     = 5,        /* Line Status */
    Msr     = 6,        /* Modem Status */
    Scr     = 7,        /* Scratch Pad */
    Dll     = 0,        /* Divisor Latch LSB */
    Dlm     = 1,        /* Divisor Latch MSB */
};

enum {                  /* Ier */
    Erda        = 0x01,     /* Enable Received Data Available */
    Ethre       = 0x02,     /* Enable Thr Empty */
    Erls        = 0x04,     /* Enable Receiver Line Status */
    Ems     = 0x08,     /* Enable Modem Status */
};

enum {                  /* Iir */
    Ims     = 0x00,     /* Ms interrupt */
    Ip      = 0x01,     /* Interrupt Pending (not) */
    Ithre       = 0x02,     /* Thr Empty */
    Irda        = 0x04,     /* Received Data Available */
    Irls        = 0x06,     /* Receiver Line Status */
    Ictoi       = 0x0C,     /* Character Time-out Indication */
    IirMASK     = 0x3F,
    Ifena       = 0xC0,     /* FIFOs enabled */
};

enum {                  /* Fcr */
    FIFOena     = 0x01,     /* FIFO enable */
    FIFOrclr    = 0x02,     /* clear Rx FIFO */
    FIFOtclr    = 0x04,     /* clear Tx FIFO */
    FIFO1       = 0x00,     /* Rx FIFO trigger level 1 byte */
    FIFO4       = 0x40,     /*  4 bytes */
    FIFO8       = 0x80,     /*  8 bytes */
    FIFO14      = 0xC0,     /*  14 bytes */
};

enum {                  /* Lcr */
    Wls5        = 0x00,     /* Word Length Select 5 bits/byte */
    Wls6        = 0x01,     /*  6 bits/byte */
    Wls7        = 0x02,     /*  7 bits/byte */
    Wls8        = 0x03,     /*  8 bits/byte */
    WlsMASK     = 0x03,
    Stb     = 0x04,     /* 2 stop bits */
    Pen     = 0x08,     /* Parity Enable */
    Eps     = 0x10,     /* Even Parity Select */
    Stp     = 0x20,     /* Stick Parity */
    Brk     = 0x40,     /* Break */
    Dlab        = 0x80,     /* Divisor Latch Access Bit */
};

enum {                  /* Mcr */
    Dtr     = 0x01,     /* Data Terminal Ready */
    Rts     = 0x02,     /* Ready To Send */
    Out1        = 0x04,     /* no longer in use */
    Ie      = 0x08,     /* IRQ Enable */
    Dm      = 0x10,     /* Diagnostic Mode loopback */
};

enum {                  /* Lsr */
    Dr      = 0x01,     /* Data Ready */
    Oe      = 0x02,     /* Overrun Error */
    Pe      = 0x04,     /* Parity Error */
    Fe      = 0x08,     /* Framing Error */
    Bi      = 0x10,     /* Break Interrupt */
    Thre        = 0x20,     /* Thr Empty */
    Temt        = 0x40,     /* Tramsmitter Empty */
    FIFOerr     = 0x80,     /* error in receiver FIFO */
};

enum {                  /* Msr */
    Dcts        = 0x01,     /* Delta Cts */
    Ddsr        = 0x02,     /* Delta Dsr */
    Teri        = 0x04,     /* Trailing Edge of Ri */
    Ddcd        = 0x08,     /* Delta Dcd */
    Cts     = 0x10,     /* Clear To Send */
    Dsr     = 0x20,     /* Data Set Ready */
    Ri      = 0x40,     /* Ring Indicator */
    Dcd     = 0x80,     /* Data Set Ready */
};

struct CtlrUart {
    int io;
    int irq;
    int tbdf;
    int iena;

    uchar   sticky[8];

    Lock;
    int hasfifo;
    int checkfifo;
    int fena;
};

<<uarti8250.c forward decl(x86)>>

extern PhysUart i8250physuart;

static CtlrUart i8250ctlr[2] = {
{   .io = Uart0,
    .irq    = Uart0IRQ,
    .tbdf   = BUSUNKNOWN, },

{   .io = Uart1,
    .irq    = Uart1IRQ,
    .tbdf   = BUSUNKNOWN, },
};

static Uart i8250uart[2] = {
{   .regs   = &i8250ctlr[0],
    .name   = "COM1",
    .freq   = UartFREQ,
    .phys   = &i8250physuart,
    .special= 0,
    .next   = &i8250uart[1], },

{   .regs   = &i8250ctlr[1],
    .name   = "COM2",
    .freq   = UartFREQ,
    .phys   = &i8250physuart,
    .special= 0,
    .next   = nil, },
};

#define csr8r(c, r) inb((c)->io+(r))
#define csr8w(c, r, v)  outb((c)->io+(r), (c)->sticky[(r)]|(v))

static long
i8250status(Uart* uart, void* buf, long n, long offset)
{
    char *p;
    CtlrUart *ctlr;
    uchar ier, lcr, mcr, msr;

    p = malloc(READSTR);
    if(p == nil)
        error(Enomem);
    ctlr = uart->regs;
    mcr = ctlr->sticky[Mcr];
    msr = csr8r(ctlr, Msr);
    ier = ctlr->sticky[Ier];
    lcr = ctlr->sticky[Lcr];
    snprint(p, READSTR,
        "b%d c%d d%d e%d l%d m%d p%c r%d s%d i%d\n"
        "dev(%d) type(%d) framing(%d) overruns(%d) "
        "berr(%d) serr(%d)%s%s%s%s\n",

        uart->baud,
        uart->hup_dcd, 
        (msr & Dsr) != 0,
        uart->hup_dsr,
        (lcr & WlsMASK) + 5,
        (ier & Ems) != 0, 
        (lcr & Pen) ? ((lcr & Eps) ? 'e': 'o'): 'n',
        (mcr & Rts) != 0,
        (lcr & Stb) ? 2: 1,
        ctlr->fena,

        uart->dev,
        uart->type,
        uart->ferr,
        uart->oerr,
        uart->berr,
        uart->serr,
        (msr & Cts) ? " cts": "",
        (msr & Dsr) ? " dsr": "",
        (msr & Dcd) ? " dcd": "",
        (msr & Ri) ? " ring": ""
    );
    n = readstr(offset, buf, n, p);
    free(p);

    return n;
}

static void
i8250fifo(Uart* uart, int level)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    if(ctlr->hasfifo == 0)
        return;

    /*
     * Changing the FIFOena bit in Fcr flushes data
     * from both receive and transmit FIFOs; there's
     * no easy way to guarantee not losing data on
     * the receive side, but it's possible to wait until
     * the transmitter is really empty.
     */
    ilock(ctlr);
    while(!(csr8r(ctlr, Lsr) & Temt))
        ;

    /*
     * Set the trigger level, default is the max.
     * value.
     * Some UARTs require FIFOena to be set before
     * other bits can take effect, so set it twice.
     */
    ctlr->fena = level;
    switch(level){
    case 0:
        break;
    case 1:
        level = FIFO1|FIFOena;
        break;
    case 4:
        level = FIFO4|FIFOena;
        break;
    case 8:
        level = FIFO8|FIFOena;
        break;
    default:
        level = FIFO14|FIFOena;
        break;
    }
    csr8w(ctlr, Fcr, level);
    csr8w(ctlr, Fcr, level);
    iunlock(ctlr);
}

static void
i8250dtr(Uart* uart, int on)
{
    CtlrUart *ctlr;

    /*
     * Toggle DTR.
     */
    ctlr = uart->regs;
    if(on)
        ctlr->sticky[Mcr] |= Dtr;
    else
        ctlr->sticky[Mcr] &= ~Dtr;
    csr8w(ctlr, Mcr, 0);
}

static void
i8250rts(Uart* uart, int on)
{
    CtlrUart *ctlr;

    /*
     * Toggle RTS.
     */
    ctlr = uart->regs;
    if(on)
        ctlr->sticky[Mcr] |= Rts;
    else
        ctlr->sticky[Mcr] &= ~Rts;
    csr8w(ctlr, Mcr, 0);
}

static void
i8250modemctl(Uart* uart, int on)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    ilock(&uart->tlock);
    if(on){
        ctlr->sticky[Ier] |= Ems;
        csr8w(ctlr, Ier, ctlr->sticky[Ier]);
        uart->modem = 1;
        uart->cts = csr8r(ctlr, Msr) & Cts;
    }
    else{
        ctlr->sticky[Ier] &= ~Ems;
        csr8w(ctlr, Ier, ctlr->sticky[Ier]);
        uart->modem = 0;
        uart->cts = 1;
    }
    iunlock(&uart->tlock);

    /* modem needs fifo */
    (*uart->phys->fifo)(uart, on);
}

static int
i8250parity(Uart* uart, int parity)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~(Eps|Pen);

    switch(parity){
    case 'e':
        lcr |= Eps|Pen;
        break;
    case 'o':
        lcr |= Pen;
        break;
    case 'n':
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->parity = parity;

    return 0;
}

static int
i8250stop(Uart* uart, int stop)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~Stb;

    switch(stop){
    case 1:
        break;
    case 2:
        lcr |= Stb;
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->stop = stop;

    return 0;
}

static int
i8250bits(Uart* uart, int bits)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~WlsMASK;

    switch(bits){
    case 5:
        lcr |= Wls5;
        break;
    case 6:
        lcr |= Wls6;
        break;
    case 7:
        lcr |= Wls7;
        break;
    case 8:
        lcr |= Wls8;
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->bits = bits;

    return 0;
}

static int
i8250baud(Uart* uart, int baud)
{
    ulong bgc;
    CtlrUart *ctlr;

    /*
     * Set the Baud rate by calculating and setting the Baud rate
     * Generator Constant. This will work with fairly non-standard
     * Baud rates.
     */
    if(uart->freq == 0 || baud <= 0)
        return -1;
    bgc = (uart->freq+8*baud-1)/(16*baud);

    ctlr = uart->regs;
    csr8w(ctlr, Lcr, Dlab);
    outb(ctlr->io+Dlm, bgc>>8);
    outb(ctlr->io+Dll, bgc);
    csr8w(ctlr, Lcr, 0);

    uart->baud = baud;

    return 0;
}

static void
i8250break(Uart* uart, int ms)
{
    CtlrUart *ctlr;

    /*
     * Send a break.
     */
    if(ms <= 0)
        ms = 200;

    ctlr = uart->regs;
    csr8w(ctlr, Lcr, Brk);
    tsleep(&up->sleepr, returnfalse, 0, ms);
    csr8w(ctlr, Lcr, 0);
}

static void
i8250kick(Uart* uart)
{
    int i;
    CtlrUart *ctlr;

    if(uart->cts == 0 || uart->blocked)
        return;

    /*
     *  128 here is an arbitrary limit to make sure
     *  we don't stay in this loop too long.  If the
     *  chip's output queue is longer than 128, too
     *  bad -- presotto
     */
    ctlr = uart->regs;
    for(i = 0; i < 128; i++){
        if(!(csr8r(ctlr, Lsr) & Thre))
            break;
        if(uart->op >= uart->oe && uartstageoutput(uart) == 0)
            break;
        outb(ctlr->io+Thr, *(uart->op++));
    }
}

static void
i8250interrupt(Ureg*, void* arg)
{
    CtlrUart *ctlr;
    Uart *uart;
    int iir, lsr, old, r;

    uart = arg;

    ctlr = uart->regs;
    for(iir = csr8r(ctlr, Iir); !(iir & Ip); iir = csr8r(ctlr, Iir)){
        switch(iir & IirMASK){
        case Ims:       /* Ms interrupt */
            r = csr8r(ctlr, Msr);
            if(r & Dcts){
                ilock(&uart->tlock);
                old = uart->cts;
                uart->cts = r & Cts;
                if(old == 0 && uart->cts)
                    uart->ctsbackoff = 2;
                iunlock(&uart->tlock);
            }
            if(r & Ddsr){
                old = r & Dsr;
                if(uart->hup_dsr && uart->dsr && !old)
                    uart->dohup = 1;
                uart->dsr = old;
            }
            if(r & Ddcd){
                old = r & Dcd;
                if(uart->hup_dcd && uart->dcd && !old)
                    uart->dohup = 1;
                uart->dcd = old;
            }
            break;
        case Ithre:     /* Thr Empty */
            uartkick(uart);
            break;
        case Irda:      /* Received Data Available */
        case Irls:      /* Receiver Line Status */
        case Ictoi:     /* Character Time-out Indication */
            /*
             * Consume any received data.
             * If the received byte came in with a break,
             * parity or framing error, throw it away;
             * overrun is an indication that something has
             * already been tossed.
             */
            while((lsr = csr8r(ctlr, Lsr)) & Dr){
                if(lsr & (FIFOerr|Oe))
                    uart->oerr++;
                if(lsr & Pe)
                    uart->perr++;
                if(lsr & Fe)
                    uart->ferr++;
                r = csr8r(ctlr, Rbr);
                if(!(lsr & (Bi|Fe|Pe)))
                    uartrecv(uart, r);
            }
            break;

        default:
            iprint("weird uart interrupt 0x%2.2uX\n", iir);
            break;
        }
    }
}

static void
i8250disable(Uart* uart)
{
    CtlrUart *ctlr;

    /*
     * Turn off DTR and RTS, disable interrupts and fifos.
     */
    (*uart->phys->dtr)(uart, 0);
    (*uart->phys->rts)(uart, 0);
    (*uart->phys->fifo)(uart, 0);

    ctlr = uart->regs;
    ctlr->sticky[Ier] = 0;
    csr8w(ctlr, Ier, ctlr->sticky[Ier]);

    if(ctlr->iena != 0){
        if(intrdisable(ctlr->irq, i8250interrupt, uart, ctlr->tbdf, uart->name) == 0)
            ctlr->iena = 0;
    }
}

static void
i8250enable(Uart* uart, int ie)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;

    /*
     * Check if there is a FIFO.
     * Changing the FIFOena bit in Fcr flushes data
     * from both receive and transmit FIFOs; there's
     * no easy way to guarantee not losing data on
     * the receive side, but it's possible to wait until
     * the transmitter is really empty.
     * Also, reading the Iir outwith i8250interrupt()
     * can be dangerous, but this should only happen
     * once before interrupts are enabled.
     */
    ilock(ctlr);
    if(!ctlr->checkfifo){
        /*
         * Wait until the transmitter is really empty.
         */
        while(!(csr8r(ctlr, Lsr) & Temt))
            ;
        csr8w(ctlr, Fcr, FIFOena);
        if(csr8r(ctlr, Iir) & Ifena)
            ctlr->hasfifo = 1;
        csr8w(ctlr, Fcr, 0);
        ctlr->checkfifo = 1;
    }
    iunlock(ctlr);

    /*
     * Enable interrupts and turn on DTR and RTS.
     * Be careful if this is called to set up a polled serial line
     * early on not to try to enable interrupts as interrupt-
     * -enabling mechanisms might not be set up yet.
     */
    if(ie){
        if(ctlr->iena == 0){
            arch_intrenable(ctlr->irq, i8250interrupt, uart, ctlr->tbdf, uart->name);
            ctlr->iena = 1;
        }
        ctlr->sticky[Ier] = Ethre|Erda;
        ctlr->sticky[Mcr] |= Ie;
    }
    else{
        ctlr->sticky[Ier] = 0;
        ctlr->sticky[Mcr] = 0;
    }
    csr8w(ctlr, Ier, ctlr->sticky[Ier]);
    csr8w(ctlr, Mcr, ctlr->sticky[Mcr]);

    (*uart->phys->dtr)(uart, 1);
    (*uart->phys->rts)(uart, 1);

    /*
     * During startup, the i8259 interrupt controller is reset.
     * This may result in a lost interrupt from the i8250 uart.
     * The i8250 thinks the interrupt is still outstanding and does not
     * generate any further interrupts. The workaround is to call the
     * interrupt handler to clear any pending interrupt events.
     * Note: this must be done after setting Ier.
     */
    if(ie)
        i8250interrupt(nil, uart);
}

void*
i8250alloc(int io, int irq, int tbdf)
{
    CtlrUart *ctlr;

    if((ctlr = malloc(sizeof(CtlrUart))) != nil){
        ctlr->io = io;
        ctlr->irq = irq;
        ctlr->tbdf = tbdf;
    }

    return ctlr;
}

static Uart*
i8250pnp(void)
{
    return i8250uart;
}

static int
i8250getc(Uart *uart)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    while(!(csr8r(ctlr, Lsr)&Dr))
        arch_delay(1);
    return csr8r(ctlr, Rbr);
}

static void
i8250putc(Uart *uart, int c)
{
    int i;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    for(i = 0; !(csr8r(ctlr, Lsr)&Thre) && i < 128; i++)
        arch_delay(1);
    outb(ctlr->io+Thr, c);
    for(i = 0; !(csr8r(ctlr, Lsr)&Thre) && i < 128; i++)
        arch_delay(1);
}

PhysUart i8250physuart = {
    .name       = "i8250",
    .pnp        = i8250pnp,
    .enable     = i8250enable,
    .disable    = i8250disable,
    .kick       = i8250kick,
    .dobreak    = i8250break,
    .baud       = i8250baud,
    .bits       = i8250bits,
    .stop       = i8250stop,
    .parity     = i8250parity,
    .modemctl   = i8250modemctl,
    .rts        = i8250rts,
    .dtr        = i8250dtr,
    .status     = i8250status,
    .fifo       = i8250fifo,
    .getc       = i8250getc,
    .putc       = i8250putc,
};

void
i8250config(char *p)
{
    Uart *uart;
    int n;
    char *cmd;

    if(p == nil)
        return;
    n = strtoul(p, &cmd, 0);
    if(p == cmd)
        return;
    switch(n){
    default:
        return;
    case 0:
        uart = &i8250uart[0];
        break;
    case 1:
        uart = &i8250uart[1];
        break;  
    }

    if(!uart->enabled)
        (*uart->phys->enable)(uart, 0);
    uartctl(uart, "b9600 l8 pn s1");
    if(*cmd != '\0')
        uartctl(uart, cmd);

    consuart = uart;
    uart->console = true;
}

void
i8250console(void)
{
    i8250config(getconf("console"));
}


@


\subsection*{[[buses/386/uartisa.c]]}

<<uartisa.c>>=
<<kernel basic includes>>
#include "io.h"

extern PhysUart i8250physuart;
extern PhysUart isaphysuart;
extern void* i8250alloc(int, int, int);

static Uart*
uartisa(int ctlrno, ISAConf* isa)
{
    int io;
    void *ctlr;
    Uart *uart;
    char buf[64];

    io = isa->port;
    snprint(buf, sizeof(buf), "%s%d", isaphysuart.name, ctlrno);
    if(ioalloc(io, 8, 0, buf) < 0){
        print("uartisa: I/O 0x%uX in use\n", io);
        return nil;
    }

    uart = malloc(sizeof(Uart));
    ctlr = i8250alloc(io, isa->irq, BUSUNKNOWN);
    if(uart == nil || ctlr == nil){
        iofree(io);
        free(uart);
        free(ctlr);
        return nil;
    }

    uart->regs = ctlr;
    snprint(buf, sizeof(buf), "COM%d", ctlrno+1);
    kstrdup(&uart->name, buf);
    uart->freq = isa->freq;
    uart->phys = &i8250physuart;

    return uart;
}

static Uart*
uartisapnp(void)
{
    int ctlrno;
    ISAConf isa;
    Uart *head, *tail, *uart;

    /*
     * Look for up to 4 discrete UARTs on the ISA bus.
     * All suitable devices are configured to simply point
     * to the generic i8250 driver.
     */
    head = tail = nil;
    for(ctlrno = 2; ctlrno < 6; ctlrno++){
        memset(&isa, 0, sizeof(isa));
        if(!arch_isaconfig("uart", ctlrno, &isa))
            continue;
        if(strcmp(isa.type, "isa") != 0)
            continue;
        if(isa.port == 0 || isa.irq == 0)
            continue;
        if(isa.freq == 0)
            isa.freq = 1843200;
        uart = uartisa(ctlrno, &isa);
        if(uart == nil)
            continue;
        if(head != nil)
            tail->next = uart;
        else
            head = uart;
        tail = uart;
    }

    return head;
}

PhysUart isaphysuart = {
    .name       = "UartISA",
    .pnp        = uartisapnp,
    .enable     = nil,
    .disable    = nil,
    .kick       = nil,
    .dobreak    = nil,
    .baud       = nil,
    .bits       = nil,
    .stop       = nil,
    .parity     = nil,
    .modemctl   = nil,
    .rts        = nil,
    .dtr        = nil,
    .status     = nil,
    .fifo       = nil,
};
@

\subsection*{[[devices/storage/386/sdata.c]]}

\ifallcode
<<sdata.c forward decl(x86)>>=
typedef struct Ctlr Ctlr;
typedef struct Drive Drive;
typedef struct Prd Prd;
@
\fi

% very very big, skipped for now
\ifallcode
<<sdata.c>>=
<<kernel basic includes>>

#include "io.h"
#include "../port/sd.h"

#include <ureg.h>

extern SDifc sdataifc;

enum {
    DbgCONFIG   = 0x0001,   /* detected drive config info */
    DbgIDENTIFY = 0x0002,   /* detected drive identify info */
    DbgSTATE    = 0x0004,   /* dump state on panic */
    DbgPROBE    = 0x0008,   /* trace device probing */
    DbgDEBUG    = 0x0080,   /* the current problem... */
    DbgINL      = 0x0100,   /* That Inil20+ message we hate */
    Dbg48BIT    = 0x0200,   /* 48-bit LBA */
    DbgBsy      = 0x0400,   /* interrupt but Bsy (shared IRQ) */
};
#define DEBUG       (DbgDEBUG|DbgSTATE)

enum {                  /* I/O ports */
    Data        = 0,
    Error       = 1,        /* (read) */
    Features    = 1,        /* (write) */
    Count       = 2,        /* sector count<7-0>, sector count<15-8> */
    Ir      = 2,        /* interrupt reason (PACKET) */
    Sector      = 3,        /* sector number */
    Lbalo       = 3,        /* LBA<7-0>, LBA<31-24> */
    Cyllo       = 4,        /* cylinder low */
    Bytelo      = 4,        /* byte count low (PACKET) */
    Lbamid      = 4,        /* LBA<15-8>, LBA<39-32> */
    Cylhi       = 5,        /* cylinder high */
    Bytehi      = 5,        /* byte count hi (PACKET) */
    Lbahi       = 5,        /* LBA<23-16>, LBA<47-40> */
    Dh      = 6,        /* Device/Head, LBA<27-24> */
    Status      = 7,        /* (read) */
    Command     = 7,        /* (write) */

    As      = 2,        /* Alternate Status (read) */
    Dc      = 2,        /* Device Control (write) */
};

enum {                  /* Error */
    Med     = 0x01,     /* Media error */
    Ili     = 0x01,     /* command set specific (PACKET) */
    Nm      = 0x02,     /* No Media */
    Eom     = 0x02,     /* command set specific (PACKET) */
    Abrt        = 0x04,     /* Aborted command */
    Mcr     = 0x08,     /* Media Change Request */
    Idnf        = 0x10,     /* no user-accessible address */
    Mc      = 0x20,     /* Media Change */
    Unc     = 0x40,     /* Uncorrectable data error */
    Wp      = 0x40,     /* Write Protect */
    Icrc        = 0x80,     /* Interface CRC error */
};

enum {                  /* Features */
    Dma     = 0x01,     /* data transfer via DMA (PACKET) */
    Ovl     = 0x02,     /* command overlapped (PACKET) */
};

enum {                  /* Interrupt Reason */
    Cd      = 0x01,     /* Command/Data */
    Io      = 0x02,     /* I/O direction: read */
    Rel     = 0x04,     /* Bus Release */
};

enum {                  /* Device/Head */
    Dev0        = 0xA0,     /* Master */
    Dev1        = 0xB0,     /* Slave */
    Lba     = 0x40,     /* LBA mode */
};

enum {                  /* Status, Alternate Status */
    Err     = 0x01,     /* Error */
    Chk     = 0x01,     /* Check error (PACKET) */
    Drq     = 0x08,     /* Data Request */
    Dsc     = 0x10,     /* Device Seek Complete */
    Serv        = 0x10,     /* Service */
    Df      = 0x20,     /* Device Fault */
    Dmrd        = 0x20,     /* DMA ready (PACKET) */
    Drdy        = 0x40,     /* Device Ready */
    Bsy     = 0x80,     /* Busy */
};

enum {                  /* Command */
    Cnop        = 0x00,     /* NOP */
    Cdr     = 0x08,     /* Device Reset */
    Crs     = 0x20,     /* Read Sectors */
    Crs48       = 0x24,     /* Read Sectors Ext */
    Crd48       = 0x25,     /* Read w/ DMA Ext */
    Crdq48      = 0x26,     /* Read w/ DMA Queued Ext */
    Crsm48      = 0x29,     /* Read Multiple Ext */
    Cws     = 0x30,     /* Write Sectors */
    Cws48       = 0x34,     /* Write Sectors Ext */
    Cwd48       = 0x35,     /* Write w/ DMA Ext */
    Cwdq48      = 0x36,     /* Write w/ DMA Queued Ext */
    Cwsm48      = 0x39,     /* Write Multiple Ext */
    Cedd        = 0x90,     /* Execute Device Diagnostics */
    Cpkt        = 0xA0,     /* Packet */
    Cidpkt      = 0xA1,     /* Identify Packet Device */
    Crsm        = 0xC4,     /* Read Multiple */
    Cwsm        = 0xC5,     /* Write Multiple */
    Csm     = 0xC6,     /* Set Multiple */
    Crdq        = 0xC7,     /* Read DMA queued */
    Crd     = 0xC8,     /* Read DMA */
    Cwd     = 0xCA,     /* Write DMA */
    Cwdq        = 0xCC,     /* Write DMA queued */
    Cstandby    = 0xE2,     /* Standby */
    Cid     = 0xEC,     /* Identify Device */
    Csf     = 0xEF,     /* Set Features */
};

enum {                  /* Device Control */
    Nien        = 0x02,     /* (not) Interrupt Enable */
    Srst        = 0x04,     /* Software Reset */
    Hob     = 0x80,     /* High Order Bit [sic] */
};

enum {                  /* PCI Configuration Registers */
    Bmiba       = 0x20,     /* Bus Master Interface Base Address */
    Idetim      = 0x40,     /* IE Timing */
    Sidetim     = 0x44,     /* Slave IE Timing */
    Udmactl     = 0x48,     /* Ultra DMA/33 Control */
    Udmatim     = 0x4A,     /* Ultra DMA/33 Timing */
};

enum {                  /* Bus Master IDE I/O Ports */
    Bmicx       = 0,        /* Command */
    Bmisx       = 2,        /* Status */
    Bmidtpx     = 4,        /* Descriptor Table Pointer */
};

enum {                  /* Bmicx */
    Ssbm        = 0x01,     /* Start/Stop Bus Master */
    Rwcon       = 0x08,     /* Read/Write Control */
};

enum {                  /* Bmisx */
    Bmidea      = 0x01,     /* Bus Master IDE Active */
    Idedmae     = 0x02,     /* IDE DMA Error  (R/WC) */
    Ideints     = 0x04,     /* IDE Interrupt Status (R/WC) */
    Dma0cap     = 0x20,     /* Drive 0 DMA Capable */
    Dma1cap     = 0x40,     /* Drive 0 DMA Capable */
};
enum {                  /* Physical Region Descriptor */
    PrdEOT      = 0x80000000,   /* End of Transfer */
};

enum {                  /* offsets into the identify info. */
    Iconfig     = 0,        /* general configuration */
    Ilcyl       = 1,        /* logical cylinders */
    Ilhead      = 3,        /* logical heads */
    Ilsec       = 6,        /* logical sectors per logical track */
    Iserial     = 10,       /* serial number */
    Ifirmware   = 23,       /* firmware revision */
    Imodel      = 27,       /* model number */
    Imaxrwm     = 47,       /* max. read/write multiple sectors */
    Icapabilities   = 49,       /* capabilities */
    Istandby    = 50,       /* device specific standby timer */
    Ipiomode    = 51,       /* PIO data transfer mode number */
    Ivalid      = 53,
    Iccyl       = 54,       /* cylinders if (valid&0x01) */
    Ichead      = 55,       /* heads if (valid&0x01) */
    Icsec       = 56,       /* sectors if (valid&0x01) */
    Iccap       = 57,       /* capacity if (valid&0x01) */
    Irwm        = 59,       /* read/write multiple */
    Ilba        = 60,       /* LBA size */
    Imwdma      = 63,       /* multiword DMA mode */
    Iapiomode   = 64,       /* advanced PIO modes supported */
    Iminmwdma   = 65,       /* min. multiword DMA cycle time */
    Irecmwdma   = 66,       /* rec. multiword DMA cycle time */
    Iminpio     = 67,       /* min. PIO cycle w/o flow control */
    Iminiordy   = 68,       /* min. PIO cycle with IORDY */
    Ipcktbr     = 71,       /* time from PACKET to bus release */
    Iserbsy     = 72,       /* time from SERVICE to !Bsy */
    Iqdepth     = 75,       /* max. queue depth */
    Imajor      = 80,       /* major version number */
    Iminor      = 81,       /* minor version number */
    Icsfs       = 82,       /* command set/feature supported */
    Icsfe       = 85,       /* command set/feature enabled */
    Iudma       = 88,       /* ultra DMA mode */
    Ierase      = 89,       /* time for security erase */
    Ieerase     = 90,       /* time for enhanced security erase */
    Ipower      = 91,       /* current advanced power management */
    Ilba48      = 100,      /* 48-bit LBA size (64 bits in 100-103) */
    Irmsn       = 127,      /* removable status notification */
    Isecstat    = 128,      /* security status */
    Icfapwr     = 160,      /* CFA power mode */
    Imediaserial    = 176,      /* current media serial number */
    Icksum      = 255,      /* checksum */
};

enum {                  /* bit masks for config identify info */
    Mpktsz      = 0x0003,   /* packet command size */
    Mincomplete = 0x0004,   /* incomplete information */
    Mdrq        = 0x0060,   /* DRQ type */
    Mrmdev      = 0x0080,   /* device is removable */
    Mtype       = 0x1F00,   /* device type */
    Mproto      = 0x8000,   /* command protocol */
};

enum {                  /* bit masks for capabilities identify info */
    Mdma        = 0x0100,   /* DMA supported */
    Mlba        = 0x0200,   /* LBA supported */
    Mnoiordy    = 0x0400,   /* IORDY may be disabled */
    Miordy      = 0x0800,   /* IORDY supported */
    Msoftrst    = 0x1000,   /* needs soft reset when Bsy */
    Mstdby      = 0x2000,   /* standby supported */
    Mqueueing   = 0x4000,   /* queueing overlap supported */
    Midma       = 0x8000,   /* interleaved DMA supported */
};

enum {                  /* bit masks for supported/enabled features */
    Msmart      = 0x0001,
    Msecurity   = 0x0002,
    Mrmmedia    = 0x0004,
    Mpwrmgmt    = 0x0008,
    Mpkt        = 0x0010,
    Mwcache     = 0x0020,
    Mlookahead  = 0x0040,
    Mrelirq     = 0x0080,
    Msvcirq     = 0x0100,
    Mreset      = 0x0200,
    Mprotected  = 0x0400,
    Mwbuf       = 0x1000,
    Mrbuf       = 0x2000,
    Mnop        = 0x4000,
    Mmicrocode  = 0x0001,
    Mqueued     = 0x0002,
    Mcfa        = 0x0004,
    Mapm        = 0x0008,
    Mnotify     = 0x0010,
    Mstandby    = 0x0020,
    Mspinup     = 0x0040,
    Mmaxsec     = 0x0100,
    Mautoacoustic   = 0x0200,
    Maddr48     = 0x0400,
    Mdevconfov  = 0x0800,
    Mflush      = 0x1000,
    Mflush48    = 0x2000,
    Msmarterror = 0x0001,
    Msmartselftest  = 0x0002,
    Mmserial    = 0x0004,
    Mmpassthru  = 0x0008,
    Mlogging    = 0x0020,
};

<<sdata.c forward decl(x86)>>

struct Prd {            /* Physical Region Descriptor */
    ulong   pa;         /* Physical Base Address */
    int count;
};

enum {
    BMspan      = 64*1024,  /* must be power of 2 <= 64*1024 */

    Nprd        = SDmaxio/BMspan+2,
};

struct Ctlr {
    int cmdport;
    int ctlport;
    int irq;
    int tbdf;
    int bmiba;          /* bus master interface base address */
    int maxio;          /* sector count transfer maximum */
    int span;           /* don't span this boundary with dma */

    Pcidev* pcidev;
    void    (*ienable)(Ctlr*);
    void    (*idisable)(Ctlr*);
    SDev*   sdev;

    Drive*  drive[2];

    Prd*    prdt;           /* physical region descriptor table */
    void    (*irqack)(Ctlr*);   /* call to extinguish ICH intrs */

    QLock;              /* current command */
    Drive*  curdrive;
    int command;        /* last command issued (debugging) */
    Rendez;
    int done;

    /* interrupt counts */
    ulong   intnil;         /* no drive */
    ulong   intbusy;        /* controller still busy */
    ulong   intok;          /* normal */

    Lock;               /* register access */
};

struct Drive {
    Ctlr*   ctlr;

    int dev;
    ushort  info[256];
    int c;          /* cylinder */
    int h;          /* head */
    int s;          /* sector */
    vlong   sectors;        /* total */
    int secsize;        /* sector size */

    int dma;            /* DMA R/W possible */
    int dmactl;
    int rwm;            /* read/write multiple possible */
    int rwmctl;

    int pkt;            /* PACKET device, length of pktcmd */
    uchar   pktcmd[16];
    int pktdma;         /* this PACKET command using dma */

    uchar   sense[18];
    uchar   inquiry[48];

    QLock;              /* drive access */
    int command;        /* current command */
    int write;
    uchar*  data;
    int dlen;
    uchar*  limit;
    int count;          /* sectors */
    int block;          /* R/W bytes per block */
    int status;
    int error;
    int flags;          /* internal flags */

    /* interrupt counts */
    ulong   intcmd;         /* commands */
    ulong   intrd;          /* reads */
    ulong   intwr;          /* writes */
};

enum {                  /* internal flags */
    Lba48       = 0x1,      /* LBA48 mode */
    Lba48always = 0x2,      /* ... */
};
enum {
    Last28      = (1<<28) - 1 - 1, /* all-ones mask is not addressible */
};

static void
pc87415ienable(Ctlr* ctlr)
{
    Pcidev *p;
    int x;

    p = ctlr->pcidev;
    if(p == nil)
        return;

    x = pcicfgr32(p, 0x40);
    if(ctlr->cmdport == p->mem[0].bar)
        x &= ~0x00000100;
    else
        x &= ~0x00000200;
    pcicfgw32(p, 0x40, x);
}

static void
atadumpstate(Drive* drive, uchar* cmd, vlong lba, int count)
{
    Prd *prd;
    Pcidev *p;
    Ctlr *ctlr;
    int i, bmiba;

    if(!(DEBUG & DbgSTATE)){
        USED(drive, cmd, lba, count);
        return;
    }

    ctlr = drive->ctlr;
    print("sdata: command %2.2uX\n", ctlr->command);
    print("data %8.8p limit %8.8p dlen %d status %uX error %uX\n",
        drive->data, drive->limit, drive->dlen,
        drive->status, drive->error);
    if(cmd != nil){
        print("lba %d -> %lld, count %d -> %d (%d)\n",
            (cmd[2]<<24)|(cmd[3]<<16)|(cmd[4]<<8)|cmd[5], lba,
            (cmd[7]<<8)|cmd[8], count, drive->count);
    }
    if(!(inb(ctlr->ctlport+As) & Bsy)){
        for(i = 1; i < 7; i++)
            print(" 0x%2.2uX", inb(ctlr->cmdport+i));
        print(" 0x%2.2uX\n", inb(ctlr->ctlport+As));
    }
    if(drive->command == Cwd || drive->command == Crd){
        bmiba = ctlr->bmiba;
        prd = ctlr->prdt;
        print("bmicx %2.2uX bmisx %2.2uX prdt %8.8p\n",
            inb(bmiba+Bmicx), inb(bmiba+Bmisx), prd);
        for(;;){
            print("pa 0x%8.8luX count %8.8uX\n",
                prd->pa, prd->count);
            if(prd->count & PrdEOT)
                break;
            prd++;
        }
    }
    if(ctlr->pcidev && ctlr->pcidev->vid == 0x8086){
        p = ctlr->pcidev;
        print("0x40: %4.4uX 0x42: %4.4uX",
            pcicfgr16(p, 0x40), pcicfgr16(p, 0x42));
        print("0x48: %2.2uX\n", pcicfgr8(p, 0x48));
        print("0x4A: %4.4uX\n", pcicfgr16(p, 0x4A));
    }
}

static int
atadebug(int cmdport, int ctlport, char* fmt, ...)
{
    int i, n;
    va_list arg;
    char buf[PRINTSIZE];

    if(!(DEBUG & DbgPROBE)){
        USED(cmdport, ctlport, fmt);
        return 0;
    }

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    if(cmdport){
        if(buf[n-1] == '\n')
            n--;
        n += snprint(buf+n, PRINTSIZE-n, " ataregs 0x%uX:",
            cmdport);
        for(i = Features; i < Command; i++)
            n += snprint(buf+n, PRINTSIZE-n, " 0x%2.2uX",
                inb(cmdport+i));
        if(ctlport)
            n += snprint(buf+n, PRINTSIZE-n, " 0x%2.2uX",
                inb(ctlport+As));
        n += snprint(buf+n, PRINTSIZE-n, "\n");
    }
    putstrn(buf, n);

    return n;
}

static int
ataready(int cmdport, int ctlport, int dev, int reset, int ready, int micro)
{
    int as;

    atadebug(cmdport, ctlport, "ataready: dev %uX reset %uX ready %uX",
        dev, reset, ready);

    for(;;){
        /*
         * Wait for the controller to become not busy and
         * possibly for a status bit to become true (usually
         * Drdy). Must change to the appropriate device
         * register set if necessary before testing for ready.
         * Always run through the loop at least once so it
         * can be used as a test for !Bsy.
         */
        as = inb(ctlport+As);
        if(as & reset){
            /* nothing to do */
        }
        else if(dev){
            outb(cmdport+Dh, dev);
            dev = 0;
        }
        else if(ready == 0 || (as & ready)){
            atadebug(0, 0, "ataready: %d 0x%2.2uX\n", micro, as);
            return as;
        }

        if(micro-- <= 0){
            atadebug(0, 0, "ataready: %d 0x%2.2uX\n", micro, as);
            break;
        }
        arch_microdelay(1);
    }
    atadebug(cmdport, ctlport, "ataready: timeout");

    return -1;
}

/*
static int
atacsf(Drive* drive, vlong csf, int supported)
{
    ushort *info;
    int cmdset, i, x;

    if(supported)
        info = &drive->info[Icsfs];
    else
        info = &drive->info[Icsfe];

    for(i = 0; i < 3; i++){
        x = (csf>>(16*i)) & 0xFFFF;
        if(x == 0)
            continue;
        cmdset = info[i];
        if(cmdset == 0 || cmdset == 0xFFFF)
            return 0;
        return cmdset & x;
    }

    return 0;
}
*/

static int
atadone(void* arg)
{
    return ((Ctlr*)arg)->done;
}

static int
atarwmmode(Drive* drive, int cmdport, int ctlport, int dev)
{
    int as, maxrwm, rwm;

    maxrwm = (drive->info[Imaxrwm] & 0xFF);
    if(maxrwm == 0)
        return 0;

    /*
     * Sometimes drives come up with the current count set
     * to 0; if so, set a suitable value, otherwise believe
     * the value in Irwm if the 0x100 bit is set.
     */
    if(drive->info[Irwm] & 0x100)
        rwm = (drive->info[Irwm] & 0xFF);
    else
        rwm = 0;
    if(rwm == 0)
        rwm = maxrwm;
    if(rwm > 16)
        rwm = 16;
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, Drdy, 102*1000) < 0)
        return 0;
    outb(cmdport+Count, rwm);
    outb(cmdport+Command, Csm);
    arch_microdelay(1);
    as = ataready(cmdport, ctlport, 0, Bsy, Drdy|Df|Err, 1000);
    inb(cmdport+Status);
    if(as < 0 || (as & (Df|Err)))
        return 0;

    drive->rwm = rwm;

    return rwm;
}

static int
atadmamode(Drive* drive)
{
    int dma;

    /*
     * Check if any DMA mode enabled.
     * Assumes the BIOS has picked and enabled the best.
     * This is completely passive at the moment, no attempt is
     * made to ensure the hardware is correctly set up.
     */
    dma = drive->info[Imwdma] & 0x0707;
    drive->dma = (dma>>8) & dma;
    if(drive->dma == 0 && (drive->info[Ivalid] & 0x04)){
        dma = drive->info[Iudma] & 0x7F7F;
        drive->dma = (dma>>8) & dma;
        if(drive->dma)
            drive->dma |= 'U'<<16;
    }

    return dma;
}

static int
ataidentify(int cmdport, int ctlport, int dev, int pkt, void* info)
{
    int as, command, drdy;

    if(pkt){
        command = Cidpkt;
        drdy = 0;
    }
    else{
        command = Cid;
        drdy = Drdy;
    }
    as = ataready(cmdport, ctlport, dev, Bsy|Drq, drdy, 103*1000);
    if(as < 0)
        return as;
    outb(cmdport+Command, command);
    arch_microdelay(1);

    as = ataready(cmdport, ctlport, 0, Bsy, Drq|Err, 400*1000);
    if(as < 0)
        return -1;
    if(as & Err)
        return as;

    memset(info, 0, 512);
    inss(cmdport+Data, info, 256);
    inb(cmdport+Status);

    if(DEBUG & DbgIDENTIFY){
        int i;
        ushort *sp;

        sp = (ushort*)info;
        for(i = 0; i < 256; i++){
            if(i && (i%16) == 0)
                print("\n");
            print(" %4.4uX", *sp);
            sp++;
        }
        print("\n");
    }

    return 0;
}

static Drive*
atadrive(int cmdport, int ctlport, int dev)
{
    Drive *drive;
    int as, i, pkt;
    uchar buf[512], *p;
    ushort iconfig, *sp;

    atadebug(0, 0, "identify: port 0x%uX dev 0x%2.2uX\n", cmdport, dev);
    pkt = 1;
retry:
    as = ataidentify(cmdport, ctlport, dev, pkt, buf);
    if(as < 0)
        return nil;
    if(as & Err){
        if(pkt == 0)
            return nil;
        pkt = 0;
        goto retry;
    }

    if((drive = malloc(sizeof(Drive))) == nil)
        return nil;
    drive->dev = dev;
    memmove(drive->info, buf, sizeof(drive->info));
    drive->sense[0] = 0x70;
    drive->sense[7] = sizeof(drive->sense)-7;

    drive->inquiry[2] = 2;
    drive->inquiry[3] = 2;
    drive->inquiry[4] = sizeof(drive->inquiry)-4;
    p = &drive->inquiry[8];
    sp = &drive->info[Imodel];
    for(i = 0; i < 20; i++){
        *p++ = *sp>>8;
        *p++ = *sp++;
    }

    drive->secsize = 512;

    /*
     * Beware the CompactFlash Association feature set.
     * Now, why this value in Iconfig just walks all over the bit
     * definitions used in the other parts of the ATA/ATAPI standards
     * is a mystery and a sign of true stupidity on someone's part.
     * Anyway, the standard says if this value is 0x848A then it's
     * CompactFlash and it's NOT a packet device.
     */
    iconfig = drive->info[Iconfig];
    if(iconfig != 0x848A && (iconfig & 0xC000) == 0x8000){
        if(iconfig & 0x01)
            drive->pkt = 16;
        else
            drive->pkt = 12;
    }
    else{
        if(drive->info[Ivalid] & 0x0001){
            drive->c = drive->info[Iccyl];
            drive->h = drive->info[Ichead];
            drive->s = drive->info[Icsec];
        }
        else{
            drive->c = drive->info[Ilcyl];
            drive->h = drive->info[Ilhead];
            drive->s = drive->info[Ilsec];
        }
        if(drive->info[Icapabilities] & Mlba){
            if(drive->info[Icsfs+1] & Maddr48){
                drive->sectors = drive->info[Ilba48]
                    | (drive->info[Ilba48+1]<<16)
                    | ((vlong)drive->info[Ilba48+2]<<32);
                drive->flags |= Lba48;
            }
            else{
                drive->sectors = (drive->info[Ilba+1]<<16)
                     |drive->info[Ilba];
            }
            drive->dev |= Lba;
        }
        else
            drive->sectors = drive->c*drive->h*drive->s;
        atarwmmode(drive, cmdport, ctlport, dev);
    }
    atadmamode(drive);  

    if(DEBUG & DbgCONFIG){
        print("dev %2.2uX port %uX config %4.4uX capabilities %4.4uX",
            dev, cmdport, iconfig, drive->info[Icapabilities]);
        print(" mwdma %4.4uX", drive->info[Imwdma]);
        if(drive->info[Ivalid] & 0x04)
            print(" udma %4.4uX", drive->info[Iudma]);
        print(" dma %8.8uX rwm %ud", drive->dma, drive->rwm);
        if(drive->flags&Lba48)
            print("\tLLBA sectors %lld", drive->sectors);
        print("\n");
    }

    return drive;
}

static void
atasrst(int ctlport)
{
    /*
     * Srst is a big stick and may cause problems if further
     * commands are tried before the drives become ready again.
     * Also, there will be problems here if overlapped commands
     * are ever supported.
     */
    arch_microdelay(5);
    outb(ctlport+Dc, Srst);
    arch_microdelay(5);
    outb(ctlport+Dc, 0);
    arch_microdelay(2*1000);
}

static SDev*
ataprobe(int cmdport, int ctlport, int irq)
{
    Ctlr* ctlr;
    SDev *sdev;
    Drive *drive;
    int dev, error, rhi, rlo;
    static int nonlegacy = 'C';
    
    if(cmdport == 0) {
        print("ataprobe: cmdport is 0\n");
        return nil;
    }
    if(ioalloc(cmdport, 8, 0, "atacmd") < 0) {
        print("ataprobe: Cannot allocate %X\n", cmdport);
        return nil;
    }
    if(ioalloc(ctlport+As, 1, 0, "atactl") < 0){
        print("ataprobe: Cannot allocate %X\n", ctlport + As);
        iofree(cmdport);
        return nil;
    }

    /*
     * Try to detect a floating bus.
     * Bsy should be cleared. If not, see if the cylinder registers
     * are read/write capable.
     * If the master fails, try the slave to catch slave-only
     * configurations.
     * There's no need to restore the tested registers as they will
     * be reset on any detected drives by the Cedd command.
     * All this indicates is that there is at least one drive on the
     * controller; when the non-existent drive is selected in a
     * single-drive configuration the registers of the existing drive
     * are often seen, only command execution fails.
     */
    dev = Dev0;
    if(inb(ctlport+As) & Bsy){
        outb(cmdport+Dh, dev);
        arch_microdelay(1);
trydev1:
        atadebug(cmdport, ctlport, "ataprobe bsy");
        outb(cmdport+Cyllo, 0xAA);
        outb(cmdport+Cylhi, 0x55);
        outb(cmdport+Sector, 0xFF);
        rlo = inb(cmdport+Cyllo);
        rhi = inb(cmdport+Cylhi);
        if(rlo != 0xAA && (rlo == 0xFF || rhi != 0x55)){
            if(dev == Dev1){
release:
                iofree(cmdport);
                iofree(ctlport+As);
                return nil;
            }
            dev = Dev1;
            if(ataready(cmdport, ctlport, dev, Bsy, 0, 20*1000) < 0)
                goto trydev1;
        }
    }

    /*
     * Disable interrupts on any detected controllers.
     */
    outb(ctlport+Dc, Nien);
tryedd1:
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 105*1000) < 0){
        /*
         * There's something there, but it didn't come up clean,
         * so try hitting it with a big stick. The timing here is
         * wrong but this is a last-ditch effort and it sometimes
         * gets some marginal hardware back online.
         */
        atasrst(ctlport);
        if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 106*1000) < 0)
            goto release;
    }

    /*
     * Can only get here if controller is not busy.
     * If there are drives Bsy will be set within 400nS,
     * must wait 2mS before testing Status.
     * Wait for the command to complete (6 seconds max).
     */
    outb(cmdport+Command, Cedd);
    arch_delay(2);
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 6*1000*1000) < 0)
        goto release;

    /*
     * If bit 0 of the error register is set then the selected drive
     * exists. This is enough to detect single-drive configurations.
     * However, if the master exists there is no way short of executing
     * a command to determine if a slave is present.
     * It appears possible to get here testing Dev0 although it doesn't
     * exist and the EDD won't take, so try again with Dev1.
     */
    error = inb(cmdport+Error);
    atadebug(cmdport, ctlport, "ataprobe: dev %uX", dev);
    if((error & ~0x80) != 0x01){
        if(dev == Dev1)
            goto release;
        dev = Dev1;
        goto tryedd1;
    }

    /*
     * At least one drive is known to exist, try to
     * identify it. If that fails, don't bother checking
     * any further.
     * If the one drive found is Dev0 and the EDD command
     * didn't indicate Dev1 doesn't exist, check for it.
     */
    if((drive = atadrive(cmdport, ctlport, dev)) == nil)
        goto release;
    if((ctlr = malloc(sizeof(Ctlr))) == nil){
        free(drive);
        goto release;
    }
    memset(ctlr, 0, sizeof(Ctlr));
    if((sdev = malloc(sizeof(SDev))) == nil){
        free(ctlr);
        free(drive);
        goto release;
    }
    memset(sdev, 0, sizeof(SDev));
    drive->ctlr = ctlr;
    if(dev == Dev0){
        ctlr->drive[0] = drive;
        if(!(error & 0x80)){
            /*
             * Always leave Dh pointing to a valid drive,
             * otherwise a subsequent call to ataready on
             * this controller may try to test a bogus Status.
             * Ataprobe is the only place possibly invalid
             * drives should be selected.
             */
            drive = atadrive(cmdport, ctlport, Dev1);
            if(drive != nil){
                drive->ctlr = ctlr;
                ctlr->drive[1] = drive;
            }
            else{
                outb(cmdport+Dh, Dev0);
                arch_microdelay(1);
            }
        }
    }
    else
        ctlr->drive[1] = drive;

    ctlr->cmdport = cmdport;
    ctlr->ctlport = ctlport;
    ctlr->irq = irq;
    ctlr->tbdf = BUSUNKNOWN;
    ctlr->command = Cedd;       /* debugging */
    
    switch(cmdport){
    default:
        sdev->idno = nonlegacy;
        break;
    case 0x1F0:
        sdev->idno = 'C';
        nonlegacy = 'E';
        break;
    case 0x170:
        sdev->idno = 'D';
        nonlegacy = 'E';
        break;
    }
    sdev->ifc = &sdataifc;
    sdev->ctlr = ctlr;
    sdev->nunit = 2;
    ctlr->sdev = sdev;

    return sdev;
}

static void
ataclear(SDev *sdev)
{
    Ctlr* ctlr;

    ctlr = sdev->ctlr;
    iofree(ctlr->cmdport);
    iofree(ctlr->ctlport + As);

    if (ctlr->drive[0])
        free(ctlr->drive[0]);
    if (ctlr->drive[1])
        free(ctlr->drive[1]);
    if (sdev->name)
        free(sdev->name);
    if (sdev->unitflg)
        free(sdev->unitflg);
    if (sdev->unit)
        free(sdev->unit);
    free(ctlr);
    free(sdev);
}

static char *
atastat(SDev *sdev, char *p, char *e)
{
    Ctlr *ctlr = sdev->ctlr;

    return seprint(p, e, "%s ata port %X ctl %X irq %d "
        "intr-ok %lud intr-busy %lud intr-nil-drive %lud\n",
        sdev->name, ctlr->cmdport, ctlr->ctlport, ctlr->irq,
        ctlr->intok, ctlr->intbusy, ctlr->intnil);
}

static SDev*
ataprobew(DevConf *cf)
{
    char *p;
    ISAConf isa;
    
    if (cf->nports != 2)
        error(Ebadarg);

    memset(&isa, 0, sizeof isa);
    isa.port = cf->ports[0].port;
    isa.irq = cf->intnum;
    if((p=strchr(cf->type, '/')) == nil || pcmspecial(p+1, &isa) < 0)
        error("cannot find controller");

    return ataprobe(cf->ports[0].port, cf->ports[1].port, cf->intnum);
}

/*
 * These are duplicated with sdsetsense, etc., in devsd.c, but
 * those assume that the disk is not SCSI while in fact here
 * ata drives are not SCSI but ATAPI ones kind of are.
 */
static int
atasetsense(Drive* drive, int status, int key, int asc, int ascq)
{
    drive->sense[2] = key;
    drive->sense[12] = asc;
    drive->sense[13] = ascq;

    return status;
}

static int
atamodesense(Drive* drive, uchar* cmd)
{
    int len;

    /*
     * Fake a vendor-specific request with page code 0,
     * return the drive info.
     */
    if((cmd[2] & 0x3F) != 0 && (cmd[2] & 0x3F) != 0x3F)
        return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
    len = (cmd[7]<<8)|cmd[8];
    if(len == 0)
        return SDok;
    if(len < 8+sizeof(drive->info))
        return atasetsense(drive, SDcheck, 0x05, 0x1A, 0);
    if(drive->data == nil || drive->dlen < len)
        return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
    memset(drive->data, 0, 8);
    drive->data[0] = sizeof(drive->info)>>8;
    drive->data[1] = sizeof(drive->info);
    memmove(drive->data+8, drive->info, sizeof(drive->info));
    drive->data += 8+sizeof(drive->info);

    return SDok;
}

static int
atastandby(Drive* drive, int period)
{
    Ctlr* ctlr;
    int cmdport, done;

    ctlr = drive->ctlr;
    drive->command = Cstandby;
    qlock(ctlr);

    cmdport = ctlr->cmdport;
    ilock(ctlr);
    outb(cmdport+Count, period);
    outb(cmdport+Dh, drive->dev);
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = Cstandby;   /* debugging */
    outb(cmdport+Command, Cstandby);
    iunlock(ctlr);

    while(waserror())
        ;
    tsleep(ctlr, atadone, ctlr, 60*1000);
    poperror();

    done = ctlr->done;
    qunlock(ctlr);

    if(!done || (drive->status & Err))
        return atasetsense(drive, SDcheck, 4, 8, drive->error);
    return SDok;
}

static void
atanop(Drive* drive, int subcommand)
{
    Ctlr* ctlr;
    int as, cmdport, ctlport, timeo;

    /*
     * Attempt to abort a command by using NOP.
     * In response, the drive is supposed to set Abrt
     * in the Error register, set (Drdy|Err) in Status
     * and clear Bsy when done. However, some drives
     * (e.g. ATAPI Zip) just go Bsy then clear Status
     * when done, hence the timeout loop only on Bsy
     * and the forced setting of drive->error.
     */
    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    outb(cmdport+Features, subcommand);
    outb(cmdport+Dh, drive->dev);
    ctlr->command = Cnop;       /* debugging */
    outb(cmdport+Command, Cnop);

    arch_microdelay(1);
    ctlport = ctlr->ctlport;
    for(timeo = 0; timeo < 1000; timeo++){
        as = inb(ctlport+As);
        if(!(as & Bsy))
            break;
        arch_microdelay(1);
    }
    drive->error |= Abrt;
}

static void
ataabort(Drive* drive, int dolock)
{
    /*
     * If NOP is available (packet commands) use it otherwise
     * must try a software reset.
     */
    if(dolock)
        ilock(drive->ctlr);
    if(drive->info[Icsfs] & Mnop)
        atanop(drive, 0);
    else{
        atasrst(drive->ctlr->ctlport);
        drive->error |= Abrt;
    }
    if(dolock)
        iunlock(drive->ctlr);
}

static int
atadmasetup(Drive* drive, int len)
{
    Prd *prd;
    ulong pa;
    Ctlr *ctlr;
    int bmiba, bmisx, count, i, span;

    ctlr = drive->ctlr;
    pa = PCIWADDR(drive->data);
    if(pa & 0x03)
        return -1;

    /*
     * Sometimes drives identify themselves as being DMA capable
     * although they are not on a busmastering controller.
     */
    prd = ctlr->prdt;
    if(prd == nil){
        drive->dmactl = 0;
        print("disabling dma: not on a busmastering controller\n");
        return -1;
    }

    for(i = 0; len && i < Nprd; i++){
        prd->pa = pa;
        span = ROUNDUP(pa, ctlr->span);
        if(span == pa)
            span += ctlr->span;
        count = span - pa;
        if(count >= len){
            prd->count = PrdEOT|len;
            break;
        }
        prd->count = count;
        len -= count;
        pa += count;
        prd++;
    }
    if(i == Nprd)
        (prd-1)->count |= PrdEOT;

    bmiba = ctlr->bmiba;
    outl(bmiba+Bmidtpx, PCIWADDR(ctlr->prdt));
    if(drive->write)
        outb(ctlr->bmiba+Bmicx, 0);
    else
        outb(ctlr->bmiba+Bmicx, Rwcon);
    bmisx = inb(bmiba+Bmisx);
    outb(bmiba+Bmisx, bmisx|Ideints|Idedmae);

    return 0;
}

static void
atadmastart(Ctlr* ctlr, int write)
{
    if(write)
        outb(ctlr->bmiba+Bmicx, Ssbm);
    else
        outb(ctlr->bmiba+Bmicx, Rwcon|Ssbm);
}

static int
atadmastop(Ctlr* ctlr)
{
    int bmiba;

    bmiba = ctlr->bmiba;
    outb(bmiba+Bmicx, inb(bmiba+Bmicx) & ~Ssbm);

    return inb(bmiba+Bmisx);
}

static void
atadmainterrupt(Drive* drive, int count)
{
    Ctlr* ctlr;
    int bmiba, bmisx;

    ctlr = drive->ctlr;
    bmiba = ctlr->bmiba;
    bmisx = inb(bmiba+Bmisx);
    switch(bmisx & (Ideints|Idedmae|Bmidea)){
    case Bmidea:
        /*
         * Data transfer still in progress, nothing to do
         * (this should never happen).
         */
        return;

    case Ideints:
    case Ideints|Bmidea:
        /*
         * Normal termination, tidy up.
         */
        drive->data += count;
        break;

    default:
        /*
         * What's left are error conditions (memory transfer
         * problem) and the device is not done but the PRD is
         * exhausted. For both cases must somehow tell the
         * drive to abort.
         */
        ataabort(drive, 0);
        break;
    }
    atadmastop(ctlr);
    ctlr->done = 1;
}

static void
atapktinterrupt(Drive* drive)
{
    Ctlr* ctlr;
    int cmdport, len, sts;

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    sts = inb(cmdport+Ir) & (/*Rel|*/ Io|Cd);
    /* a default case is impossible since all cases are enumerated */
    switch(sts){
    case Cd:            /* write cmd */
        outss(cmdport+Data, drive->pktcmd, drive->pkt/2);
        break;

    case 0:             /* write data */
        len = (inb(cmdport+Bytehi)<<8)|inb(cmdport+Bytelo);
        if(drive->data+len > drive->limit){
            atanop(drive, 0);
            break;
        }
        outss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        break;

    case Io:            /* read data */
        len = (inb(cmdport+Bytehi)<<8)|inb(cmdport+Bytelo);
        if(drive->data+len > drive->limit){
            atanop(drive, 0);
            break;
        }
        inss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        break;

    case Io|Cd:         /* read cmd */
        if(drive->pktdma)
            atadmainterrupt(drive, drive->dlen);
        else
            ctlr->done = 1;
        break;
    }
    if(sts & Cd)
        drive->intcmd++;
    if(sts & Io)
        drive->intrd++;
    else
        drive->intwr++;
}

static int
atapktio(Drive* drive, uchar* cmd, int clen)
{
    Ctlr *ctlr;
    int as, cmdport, ctlport, len, r, timeo;

    if(cmd[0] == 0x5A && (cmd[2] & 0x3F) == 0)
        return atamodesense(drive, cmd);

    r = SDok;

    drive->command = Cpkt;
    memmove(drive->pktcmd, cmd, clen);
    memset(drive->pktcmd+clen, 0, drive->pkt-clen);
    drive->limit = drive->data+drive->dlen;

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    ctlport = ctlr->ctlport;

    qlock(ctlr);

    as = ataready(cmdport, ctlport, drive->dev, Bsy|Drq, Drdy, 107*1000);
    /* used to test as&Chk as failure too, but some CD readers use that for media change */
    if(as < 0){
        qunlock(ctlr);
        return -1;
    }

    ilock(ctlr);
    if(drive->dlen && drive->dmactl && !atadmasetup(drive, drive->dlen))
        drive->pktdma = Dma;
    else
        drive->pktdma = 0;

    outb(cmdport+Features, drive->pktdma);
    outb(cmdport+Count, 0);
    outb(cmdport+Sector, 0);
    len = 16*drive->secsize;
    outb(cmdport+Bytelo, len);
    outb(cmdport+Bytehi, len>>8);
    outb(cmdport+Dh, drive->dev);
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = Cpkt;       /* debugging */
    if(drive->pktdma)
        atadmastart(ctlr, drive->write);
    outb(cmdport+Command, Cpkt);

    if((drive->info[Iconfig] & Mdrq) != 0x0020){
        arch_microdelay(1);
        as = ataready(cmdport, ctlport, 0, Bsy, Drq|Chk, 4*1000);
        if(as < 0 || (as & (Bsy|Chk))){
            drive->status = as<0 ? 0 : as;
            ctlr->curdrive = nil;
            ctlr->done = 1;
            r = SDtimeout;
        }else
            atapktinterrupt(drive);
    }
    iunlock(ctlr);

    while(waserror())
        ;
    if(!drive->pktdma)
        sleep(ctlr, atadone, ctlr);
    else for(timeo = 0; !ctlr->done; timeo++){
        tsleep(ctlr, atadone, ctlr, 1000);
        if(ctlr->done)
            break;
        ilock(ctlr);
        atadmainterrupt(drive, 0);
        if(!drive->error && timeo > 20){
            ataabort(drive, 0);
            atadmastop(ctlr);
            drive->dmactl = 0;
            drive->error |= Abrt;
        }
        if(drive->error){
            drive->status |= Chk;
            ctlr->curdrive = nil;
        }
        iunlock(ctlr);
    }
    poperror();

    qunlock(ctlr);

    if(drive->status & Chk)
        r = SDcheck;

    return r;
}

static uchar cmd48[256] = {
    [Crs]   Crs48,
    [Crd]   Crd48,
    [Crdq]  Crdq48,
    [Crsm]  Crsm48,
    [Cws]   Cws48,
    [Cwd]   Cwd48,
    [Cwdq]  Cwdq48,
    [Cwsm]  Cwsm48,
};

static int
atageniostart(Drive* drive, uvlong lba)
{
    Ctlr *ctlr;
    uchar cmd;
    int as, c, cmdport, ctlport, h, len, s, use48;

    use48 = 0;
    if((drive->flags&Lba48always) || lba > Last28 || drive->count > 256){
        if(!(drive->flags & Lba48))
            return -1;
        use48 = 1;
        c = h = s = 0;
    }
    else if(drive->dev & Lba){
        c = (lba>>8) & 0xFFFF;
        h = (lba>>24) & 0x0F;
        s = lba & 0xFF;
    }
    else{
        c = lba/(drive->s*drive->h);
        h = ((lba/drive->s) % drive->h);
        s = (lba % drive->s) + 1;
    }

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    ctlport = ctlr->ctlport;
    if(ataready(cmdport, ctlport, drive->dev, Bsy|Drq, Drdy, 101*1000) < 0)
        return -1;

    ilock(ctlr);
    if(drive->dmactl && !atadmasetup(drive, drive->count*drive->secsize)){
        if(drive->write)
            drive->command = Cwd;
        else
            drive->command = Crd;
    }
    else if(drive->rwmctl){
        drive->block = drive->rwm*drive->secsize;
        if(drive->write)
            drive->command = Cwsm;
        else
            drive->command = Crsm;
    }
    else{
        drive->block = drive->secsize;
        if(drive->write)
            drive->command = Cws;
        else
            drive->command = Crs;
    }
    drive->limit = drive->data + drive->count*drive->secsize;
    cmd = drive->command;
    if(use48){
        outb(cmdport+Count, drive->count>>8);
        outb(cmdport+Count, drive->count);
        outb(cmdport+Lbalo, lba>>24);
        outb(cmdport+Lbalo, lba);
        outb(cmdport+Lbamid, lba>>32);
        outb(cmdport+Lbamid, lba>>8);
        outb(cmdport+Lbahi, lba>>40);
        outb(cmdport+Lbahi, lba>>16);
        outb(cmdport+Dh, drive->dev|Lba);
        cmd = cmd48[cmd];

        if(DEBUG & Dbg48BIT)
            print("using 48-bit commands\n");
    }
    else{
        outb(cmdport+Count, drive->count);
        outb(cmdport+Sector, s);
        outb(cmdport+Cyllo, c);
        outb(cmdport+Cylhi, c>>8);
        outb(cmdport+Dh, drive->dev|h);
    }
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = drive->command; /* debugging */
    outb(cmdport+Command, cmd);

    switch(drive->command){
    case Cws:
    case Cwsm:
        arch_microdelay(1);
        /* 10*1000 for flash ide drives - maybe detect them? */
        as = ataready(cmdport, ctlport, 0, Bsy, Drq|Err, 10*1000);
        if(as < 0 || (as & Err)){
            iunlock(ctlr);
            return -1;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        outss(cmdport+Data, drive->data, len/2);
        break;

    case Crd:
    case Cwd:
        atadmastart(ctlr, drive->write);
        break;
    }
    iunlock(ctlr);

    return 0;
}

static int
atagenioretry(Drive* drive)
{
    if(drive->dmactl){
        drive->dmactl = 0;
        print("atagenioretry: disabling dma\n");
    }
    else if(drive->rwmctl)
        drive->rwmctl = 0;
    else
        return atasetsense(drive, SDcheck, 4, 8, drive->error);

    return SDretry;
}

static int
atagenio(Drive* drive, uchar* cmd, int clen)
{
    uchar *p;
    Ctlr *ctlr;
    vlong lba, len;
    int count, maxio;

    /*
     * Map SCSI commands into ATA commands for discs.
     * Fail any command with a LUN except INQUIRY which
     * will return 'logical unit not supported'.
     */
    if((cmd[1]>>5) && cmd[0] != 0x12)
        return atasetsense(drive, SDcheck, 0x05, 0x25, 0);

    switch(cmd[0]){
    default:
        return atasetsense(drive, SDcheck, 0x05, 0x20, 0);

    case 0x00:          /* test unit ready */
        return SDok;

    case 0x03:          /* request sense */
        if(cmd[4] < sizeof(drive->sense))
            len = cmd[4];
        else
            len = sizeof(drive->sense);
        if(drive->data && drive->dlen >= len){
            memmove(drive->data, drive->sense, len);
            drive->data += len;
        }
        return SDok;

    case 0x12:          /* inquiry */
        if(cmd[4] < sizeof(drive->inquiry))
            len = cmd[4];
        else
            len = sizeof(drive->inquiry);
        if(drive->data && drive->dlen >= len){
            memmove(drive->data, drive->inquiry, len);
            drive->data += len;
        }
        return SDok;

    case 0x1B:          /* start/stop unit */
        /*
         * NOP for now, can use the power management feature
         * set later.
         */
        return SDok;

    case 0x25:          /* read capacity */
        if((cmd[1] & 0x01) || cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
        if(drive->data == nil || drive->dlen < 8)
            return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
        /*
         * Read capacity returns the LBA of the last sector.
         */
        len = drive->sectors-1;
        p = drive->data;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p++ = len;
        len = drive->secsize;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p = len;
        drive->data += 8;
        return SDok;

    case 0x9E:          /* long read capacity */
        if((cmd[1] & 0x01) || cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
        if(drive->data == nil || drive->dlen < 8)
            return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
        /*
         * Read capacity returns the LBA of the last sector.
         */
        len = drive->sectors-1;
        p = drive->data;
        *p++ = len>>56;
        *p++ = len>>48;
        *p++ = len>>40;
        *p++ = len>>32;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p++ = len;
        len = drive->secsize;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p = len;
        drive->data += 12;
        return SDok;

    case 0x28:          /* read (10) */
    case 0x88:          /* long read (16) */
    case 0x2a:          /* write (10) */
    case 0x8a:          /* long write (16) */
    case 0x2e:          /* write and verify (10) */
        break;

    case 0x5A:
        return atamodesense(drive, cmd);
    }

    ctlr = drive->ctlr;
    if(clen == 16){
        /* ata commands only go to 48-bit lba */
        if(cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 3, 0xc, 2);
        lba = (uvlong)cmd[4]<<40 | (uvlong)cmd[5]<<32;
        lba |= cmd[6]<<24 | cmd[7]<<16 | cmd[8]<<8 | cmd[9];
        count = cmd[10]<<24 | cmd[11]<<16 | cmd[12]<<8 | cmd[13];
    }else{
        lba = cmd[2]<<24 | cmd[3]<<16 | cmd[4]<<8 | cmd[5];
        count = cmd[7]<<8 | cmd[8];
    }
    if(drive->data == nil)
        return SDok;
    if(drive->dlen < count*drive->secsize)
        count = drive->dlen/drive->secsize;
    qlock(ctlr);
    if(ctlr->maxio)
        maxio = ctlr->maxio;
    else if(drive->flags & Lba48)
        maxio = 65536;
    else
        maxio = 256;
    while(count){
        if(count > maxio)
            drive->count = maxio;
        else
            drive->count = count;
        if(atageniostart(drive, lba)){
            ilock(ctlr);
            atanop(drive, 0);
            iunlock(ctlr);
            qunlock(ctlr);
            return atagenioretry(drive);
        }

        while(waserror())
            ;
        tsleep(ctlr, atadone, ctlr, 60*1000);
        poperror();
        if(!ctlr->done){
            /*
             * What should the above timeout be? In
             * standby and sleep modes it could take as
             * long as 30 seconds for a drive to respond.
             * Very hard to get out of this cleanly.
             */
            atadumpstate(drive, cmd, lba, count);
            ataabort(drive, 1);
            qunlock(ctlr);
            return atagenioretry(drive);
        }

        if(drive->status & Err){
            qunlock(ctlr);
            return atasetsense(drive, SDcheck, 4, 8, drive->error);
        }
        count -= drive->count;
        lba += drive->count;
    }
    qunlock(ctlr);

    return SDok;
}

static int
atario(SDreq* r)
{
    Ctlr *ctlr;
    Drive *drive;
    SDunit *unit;
    uchar cmd10[10], *cmdp, *p;
    int clen, reqstatus, status;

    unit = r->unit;
    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil){
        r->status = SDtimeout;
        return SDtimeout;
    }
    drive = ctlr->drive[unit->subno];

    /*
     * Most SCSI commands can be passed unchanged except for
     * the padding on the end. The few which require munging
     * are not used internally. Mode select/sense(6) could be
     * converted to the 10-byte form but it's not worth the
     * effort. Read/write(6) are easy.
     */
    switch(r->cmd[0]){
    case 0x08:          /* read */
    case 0x0A:          /* write */
        cmdp = cmd10;
        memset(cmdp, 0, sizeof(cmd10));
        cmdp[0] = r->cmd[0]|0x20;
        cmdp[1] = r->cmd[1] & 0xE0;
        cmdp[5] = r->cmd[3];
        cmdp[4] = r->cmd[2];
        cmdp[3] = r->cmd[1] & 0x0F;
        cmdp[8] = r->cmd[4];
        clen = sizeof(cmd10);
        break;

    default:
        cmdp = r->cmd;
        clen = r->clen;
        break;
    }

    qlock(drive);
retry:
    drive->write = r->write;
    drive->data = r->data;
    drive->dlen = r->dlen;

    drive->status = 0;
    drive->error = 0;
    if(drive->pkt)
        status = atapktio(drive, cmdp, clen);
    else
        status = atagenio(drive, cmdp, clen);
    if(status == SDretry){
        if(DbgDEBUG)
            print("%s: retry: dma %8.8uX rwm %4.4uX\n",
                unit->name, drive->dmactl, drive->rwmctl);
        goto retry;
    }
    if(status == SDok){
        atasetsense(drive, SDok, 0, 0, 0);
        if(drive->data){
            p = r->data;
            r->rlen = drive->data - p;
        }
        else
            r->rlen = 0;
    }
    else if(status == SDcheck && !(r->flags & SDnosense)){
        drive->write = 0;
        memset(cmd10, 0, sizeof(cmd10));
        cmd10[0] = 0x03;
        cmd10[1] = r->lun<<5;
        cmd10[4] = sizeof(r->sense)-1;
        drive->data = r->sense;
        drive->dlen = sizeof(r->sense)-1;
        drive->status = 0;
        drive->error = 0;
        if(drive->pkt)
            reqstatus = atapktio(drive, cmd10, 6);
        else
            reqstatus = atagenio(drive, cmd10, 6);
        if(reqstatus == SDok){
            r->flags |= SDvalidsense;
            atasetsense(drive, SDok, 0, 0, 0);
        }
    }
    qunlock(drive);
    r->status = status;
    if(status != SDok)
        return status;

    /*
     * Fix up any results.
     * Many ATAPI CD-ROMs ignore the LUN field completely and
     * return valid INQUIRY data. Patch the response to indicate
     * 'logical unit not supported' if the LUN is non-zero.
     */
    switch(cmdp[0]){
    case 0x12:          /* inquiry */
        if((p = r->data) == nil)
            break;
        if((cmdp[1]>>5) && (!drive->pkt || (p[0] & 0x1F) == 0x05))
            p[0] = 0x7F;
        /*FALLTHROUGH*/
    default:
        break;
    }

    return SDok;
}

/* interrupt ack hack for intel ich controllers */
static void
ichirqack(Ctlr *ctlr)
{
    int bmiba;

    bmiba = ctlr->bmiba;
    if(bmiba)
        outb(bmiba+Bmisx, inb(bmiba+Bmisx));
}

static void
atainterrupt(Ureg*, void* arg)
{
    Ctlr *ctlr;
    Drive *drive;
    int cmdport, len, status;

    ctlr = arg;

    ilock(ctlr);
    if(inb(ctlr->ctlport+As) & Bsy){
        ctlr->intbusy++;
        iunlock(ctlr);
        if(DEBUG & DbgBsy)
            print("IBsy+");
        return;
    }
    cmdport = ctlr->cmdport;
    status = inb(cmdport+Status);
    if((drive = ctlr->curdrive) == nil){
        ctlr->intnil++;
        if(ctlr->irqack != nil)
            ctlr->irqack(ctlr);
        iunlock(ctlr);
        if((DEBUG & DbgINL) && ctlr->command != Cedd)
            print("Inil%2.2uX+", ctlr->command);
        return;
    }

    ctlr->intok++;

    if(status & Err)
        drive->error = inb(cmdport+Error);
    else switch(drive->command){
    default:
        drive->error = Abrt;
        break;

    case Crs:
    case Crsm:
        drive->intrd++;
        if(!(status & Drq)){
            drive->error = Abrt;
            break;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        inss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        if(drive->data >= drive->limit)
            ctlr->done = 1;
        break;

    case Cws:
    case Cwsm:
        drive->intwr++;
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        drive->data += len;
        if(drive->data >= drive->limit){
            ctlr->done = 1;
            break;
        }
        if(!(status & Drq)){
            drive->error = Abrt;
            break;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        outss(cmdport+Data, drive->data, len/2);
        break;

    case Cpkt:
        atapktinterrupt(drive);
        break;

    case Crd:
        drive->intrd++;
        /* fall through */
    case Cwd:
        if (drive->command == Cwd)
            drive->intwr++;
        atadmainterrupt(drive, drive->count*drive->secsize);
        break;

    case Cstandby:
        ctlr->done = 1;
        break;
    }
    if(ctlr->irqack != nil)
        ctlr->irqack(ctlr);
    iunlock(ctlr);

    if(drive->error){
        status |= Err;
        ctlr->done = 1;
    }

    if(ctlr->done){
        ctlr->curdrive = nil;
        drive->status = status;
        wakeup(ctlr);
    }
}

static SDev*
atapnp(void)
{
    Ctlr *ctlr;
    Pcidev *p;
    SDev *legacy[2], *sdev, *head, *tail;
    int channel, ispc87415, maxio, pi, r, span;
    void (*irqack)(Ctlr*);

    irqack = nil;
    legacy[0] = legacy[1] = head = tail = nil;
    if(sdev = ataprobe(0x1F0, 0x3F4, IrqATA0)){
        head = tail = sdev;
        legacy[0] = sdev;
    }
    if(sdev = ataprobe(0x170, 0x374, IrqATA1)){
        if(head != nil)
            tail->next = sdev;
        else
            head = sdev;
        tail = sdev;
        legacy[1] = sdev;
    }

    p = nil;
    while(p = pcimatch(p, 0, 0)){
        /*
         * Look for devices with the correct class and sub-class
         * code and known device and vendor ID; add native-mode
         * channels to the list to be probed, save info for the
         * compatibility mode channels.
         * Note that the legacy devices should not be considered
         * PCI devices by the interrupt controller.
         * For both native and legacy, save info for busmastering
         * if capable.
         * Promise Ultra ATA/66 (PDC20262) appears to
         * 1) give a sub-class of 'other mass storage controller'
         *    instead of 'IDE controller', regardless of whether it's
         *    the only controller or not;
         * 2) put 0 in the programming interface byte (probably
         *    as a consequence of 1) above).
         * Sub-class code 0x04 is 'RAID controller', e.g. VIA VT8237.
         */
        if(p->ccrb != 0x01)
            continue;
        if(p->ccru != 0x01 && p->ccru != 0x04 && p->ccru != 0x80)
            continue;
        pi = p->ccrp;
        ispc87415 = 0;
        maxio = 0;
        span = BMspan;

        switch((p->did<<16)|p->vid){
        default:
            continue;

        case (0x0002<<16)|0x100B:   /* NS PC87415 */
            /*
             * Disable interrupts on both channels until
             * after they are probed for drives.
             * This must be called before interrupts are
             * enabled because the IRQ may be shared.
             */
            ispc87415 = 1;
            pcicfgw32(p, 0x40, 0x00000300);
            break;
        case (0x1000<<16)|0x1042:   /* PC-Tech RZ1000 */
            /*
             * Turn off prefetch. Overkill, but cheap.
             */
            r = pcicfgr32(p, 0x40);
            r &= ~0x2000;
            pcicfgw32(p, 0x40, r);
            break;
        case (0x4379<<16)|0x1002:   /* ATI SB400 SATA*/
        case (0x437a<<16)|0x1002:   /* ATI SB400 SATA */
        case (0x439c<<16)|0x1002:   /* ATI 439c SATA*/
        case (0x3373<<16)|0x105A:   /* Promise 20378 RAID */
        case (0x4D30<<16)|0x105A:   /* Promise PDC202xx */
        case (0x4D38<<16)|0x105A:   /* Promise PDC20262 */
        case (0x4D68<<16)|0x105A:   /* Promise PDC20268 */
        case (0x4D69<<16)|0x105A:   /* Promise Ultra/133 TX2 */
        case (0x3112<<16)|0x1095:   /* SiI 3112 SATA/RAID */
        case (0x3149<<16)|0x1106:   /* VIA VT8237 SATA/RAID */
            maxio = 15;
            span = 8*1024;
            /*FALLTHROUGH*/
        case (0x0680<<16)|0x1095:   /* SiI 0680/680A PATA133 ATAPI/RAID */
        case (0x3114<<16)|0x1095:   /* SiI 3114 SATA/RAID */
            pi = 0x85;
            break;
        case (0x0004<<16)|0x1103:   /* HighPoint HPT366 */
            pi = 0x85;
            /*
             * Turn off fast interrupt prediction.
             */
            if((r = pcicfgr8(p, 0x51)) & 0x80)
                pcicfgw8(p, 0x51, r & ~0x80);
            if((r = pcicfgr8(p, 0x55)) & 0x80)
                pcicfgw8(p, 0x55, r & ~0x80);
            break;
        case (0x0640<<16)|0x1095:   /* CMD 640B */
            /*
             * Bugfix code here...
             */
            break;
        case (0x7441<<16)|0x1022:   /* AMD 768 */
            /*
             * Set:
             *  0x41    prefetch, postwrite;
             *  0x43    FIFO configuration 1/2 and 1/2;
             *  0x44    status register read retry;
             *  0x46    DMA read and end of sector flush.
             */
            r = pcicfgr8(p, 0x41);
            pcicfgw8(p, 0x41, r|0xF0);
            r = pcicfgr8(p, 0x43);
            pcicfgw8(p, 0x43, (r & 0x90)|0x2A);
            r = pcicfgr8(p, 0x44);
            pcicfgw8(p, 0x44, r|0x08);
            r = pcicfgr8(p, 0x46);
            pcicfgw8(p, 0x46, (r & 0x0C)|0xF0);
            /*FALLTHROUGH*/
        case (0x7401<<16)|0x1022:   /* AMD 755 Cobra */
        case (0x7409<<16)|0x1022:   /* AMD 756 Viper */
        case (0x7410<<16)|0x1022:   /* AMD 766 Viper Plus */
        case (0x7469<<16)|0x1022:   /* AMD 3111 */
            /*
             * This can probably be lumped in with the 768 above.
             */
            /*FALLTHROUGH*/
        case (0x209A<<16)|0x1022:   /* AMD CS5536 */
        case (0x01BC<<16)|0x10DE:   /* nVidia nForce1 */
        case (0x0065<<16)|0x10DE:   /* nVidia nForce2 */
        case (0x0085<<16)|0x10DE:   /* nVidia nForce2 MCP */
        case (0x00E3<<16)|0x10DE:   /* nVidia nForce2 250 SATA */
        case (0x00D5<<16)|0x10DE:   /* nVidia nForce3 */
        case (0x00E5<<16)|0x10DE:   /* nVidia nForce3 Pro */
        case (0x00EE<<16)|0x10DE:   /* nVidia nForce3 250 SATA */
        case (0x0035<<16)|0x10DE:   /* nVidia nForce3 MCP */
        case (0x0053<<16)|0x10DE:   /* nVidia nForce4 */
        case (0x0054<<16)|0x10DE:   /* nVidia nForce4 SATA */
        case (0x0055<<16)|0x10DE:   /* nVidia nForce4 SATA */
        case (0x0266<<16)|0x10DE:   /* nVidia nForce4 430 SATA */
        case (0x0267<<16)|0x10DE:   /* nVidia nForce 55 MCP SATA */
        case (0x03EC<<16)|0x10DE:   /* nVidia nForce 61 MCP SATA */
        case (0x0448<<16)|0x10DE:   /* nVidia nForce 65 MCP SATA */
        case (0x0560<<16)|0x10DE:   /* nVidia nForce 69 MCP SATA */
            /*
             * Ditto, although it may have a different base
             * address for the registers (0x50?).
             */
            /*FALLTHROUGH*/
        case (0x4376<<16)|0x1002:   /* ATI SB400 PATA */
        case (0x438c<<16)|0x1002:   /* ATI SB600 PATA */
            break;
        case (0x0211<<16)|0x1166:   /* ServerWorks IB6566 */
            {
                Pcidev *sb;

                sb = pcimatch(nil, 0x1166, 0x0200);
                if(sb == nil)
                    break;
                r = pcicfgr32(sb, 0x64);
                r &= ~0x2000;
                pcicfgw32(sb, 0x64, r);
            }
            span = 32*1024;
            break;
        case (0x0502<<17)|0x100B:   /* NS SC1100/SCx200 */
        case (0x5229<<16)|0x10B9:   /* ALi M1543 */
        case (0x5288<<16)|0x10B9:   /* ALi M5288 SATA */
        case (0x5513<<16)|0x1039:   /* SiS 962 */
        case (0x0646<<16)|0x1095:   /* CMD 646 */
        case (0x0571<<16)|0x1106:   /* VIA 82C686 */
        case (0x2363<<16)|0x197b:   /* JMicron SATA */
            break;  /* TODO: verify that this should be here; wasn't in original patch */
        case (0x1230<<16)|0x8086:   /* 82371FB (PIIX) */
        case (0x7010<<16)|0x8086:   /* 82371SB (PIIX3) */
        case (0x7111<<16)|0x8086:   /* 82371[AE]B (PIIX4[E]) */
        case (0x2411<<16)|0x8086:   /* 82801AA (ICH) */
        case (0x2421<<16)|0x8086:   /* 82801AB (ICH0) */
        case (0x244A<<16)|0x8086:   /* 82801BA (ICH2, Mobile) */
        case (0x244B<<16)|0x8086:   /* 82801BA (ICH2, High-End) */
        case (0x248A<<16)|0x8086:   /* 82801CA (ICH3, Mobile) */
        case (0x248B<<16)|0x8086:   /* 82801CA (ICH3, High-End) */
        case (0x24CA<<16)|0x8086:   /* 82801DBM (ICH4, Mobile) */
        case (0x24CB<<16)|0x8086:   /* 82801DB (ICH4, High-End) */
        case (0x24D1<<16)|0x8086:   /* 82801EB/ER (ICH5 High-End) */
        case (0x24DB<<16)|0x8086:   /* 82801EB (ICH5) */
        case (0x25A3<<16)|0x8086:   /* 6300ESB (E7210) */
        case (0x2653<<16)|0x8086:   /* 82801FBM (ICH6M) */
        case (0x266F<<16)|0x8086:   /* 82801FB (ICH6) */
        case (0x27DF<<16)|0x8086:   /* 82801G SATA (ICH7) */
        case (0x27C0<<16)|0x8086:   /* 82801GB SATA AHCI (ICH7) */
//      case (0x27C4<<16)|0x8086:   /* 82801GBM SATA (ICH7) */
        case (0x27C5<<16)|0x8086:   /* 82801GBM SATA AHCI (ICH7) */
        case (0x2920<<16)|0x8086:   /* 82801(IB)/IR/IH/IO SATA IDE (ICH9) */
        case (0x3a20<<16)|0x8086:   /* 82801JI (ICH10) */
        case (0x3a26<<16)|0x8086:   /* 82801JI (ICH10) */
            irqack = ichirqack;
            break;
        }

        for(channel = 0; channel < 2; channel++){
            if(pi & (1<<(2*channel))){
                sdev = ataprobe(p->mem[0+2*channel].bar & ~0x01,
                        p->mem[1+2*channel].bar & ~0x01,
                        p->intl);
                if(sdev == nil)
                    continue;

                ctlr = sdev->ctlr;
                if(ispc87415) {
                    ctlr->ienable = pc87415ienable;
                    print("pc87415disable: not yet implemented\n");
                }

                if(head != nil)
                    tail->next = sdev;
                else
                    head = sdev;
                tail = sdev;
                ctlr->tbdf = p->tbdf;
            }
            else if((sdev = legacy[channel]) == nil)
                continue;
            else
                ctlr = sdev->ctlr;

            ctlr->pcidev = p;
            ctlr->maxio = maxio;
            ctlr->span = span;
            ctlr->irqack = irqack;
            if(!(pi & 0x80))
                continue;
            ctlr->bmiba = (p->mem[4].bar & ~0x01) + channel*8;
        }
    }

//if(0){
//    int port;
//    ISAConf isa;
//
//    /*
//     * Hack for PCMCIA drives.
//     * This will be tidied once we figure out how the whole
//     * removeable device thing is going to work.
//     */
//    memset(&isa, 0, sizeof(isa));
//    isa.port = 0x180;       /* change this for your machine */
//    isa.irq = 11;           /* change this for your machine */
//
//    port = isa.port+0x0C;
//    channel = pcmspecial("MK2001MPL", &isa);
//    if(channel == -1)
//        channel = pcmspecial("SunDisk", &isa);
//    if(channel == -1){
//        isa.irq = 10;
//        channel = pcmspecial("CF", &isa);
//    }
//    if(channel == -1){
//        isa.irq = 10;
//        channel = pcmspecial("OLYMPUS", &isa);
//    }
//    if(channel == -1){
//        port = isa.port+0x204;
//        channel = pcmspecial("ATA/ATAPI", &isa);
//    }
//    if(channel >= 0 && (sdev = ataprobe(isa.port, port, isa.irq)) != nil){
//        if(head != nil)
//            tail->next = sdev;
//        else
//            head = sdev;
//    }
//}
    return head;
}

static SDev*
atalegacy(int port, int irq)
{
    return ataprobe(port, port+0x204, irq);
}

static int
ataenable(SDev* sdev)
{
    Ctlr *ctlr;
    char name[32];

    ctlr = sdev->ctlr;

    if(ctlr->bmiba){
        if(ctlr->pcidev != nil)
            pcisetbme(ctlr->pcidev);
          //#define ALIGN   (4 * 1024)
        ctlr->prdt = mallocalign(Nprd*sizeof(Prd), 4, 0, 4*1024);
        if(ctlr->prdt == nil)
            error(Enomem);
    }
    snprint(name, sizeof(name), "%s (%s)", sdev->name, sdev->ifc->name);
    arch_intrenable(ctlr->irq, atainterrupt, ctlr, ctlr->tbdf, name);
    outb(ctlr->ctlport+Dc, 0);
    if(ctlr->ienable)
        ctlr->ienable(ctlr);

    return 1;
}

static int
atadisable(SDev *sdev)
{
    Ctlr *ctlr;
    char name[32];

    ctlr = sdev->ctlr;
    outb(ctlr->ctlport+Dc, Nien);       /* disable interrupts */
    if (ctlr->idisable)
        ctlr->idisable(ctlr);
    snprint(name, sizeof(name), "%s (%s)", sdev->name, sdev->ifc->name);
    intrdisable(ctlr->irq, atainterrupt, ctlr, ctlr->tbdf, name);
    if (ctlr->bmiba) {
        if (ctlr->pcidev)
            pciclrbme(ctlr->pcidev);
        free(ctlr->prdt);
    }
    return 0;
}

static int
atarctl(SDunit* unit, char* p, int l)
{
    int n;
    Ctlr *ctlr;
    Drive *drive;

    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil)
        return 0;
    drive = ctlr->drive[unit->subno];

    qlock(drive);
    n = snprint(p, l, "config %4.4uX capabilities %4.4uX",
        drive->info[Iconfig], drive->info[Icapabilities]);
    if(drive->dma)
        n += snprint(p+n, l-n, " dma %8.8uX dmactl %8.8uX",
            drive->dma, drive->dmactl);
    if(drive->rwm)
        n += snprint(p+n, l-n, " rwm %ud rwmctl %ud",
            drive->rwm, drive->rwmctl);
    if(drive->flags&Lba48)
        n += snprint(p+n, l-n, " lba48always %s",
            (drive->flags&Lba48always) ? "on" : "off");
    n += snprint(p+n, l-n, "\n");
    n += snprint(p+n, l-n, "interrupts read %lud write %lud cmds %lud\n",
        drive->intrd, drive->intwr, drive->intcmd);
    if(drive->sectors){
        n += snprint(p+n, l-n, "geometry %lld %d",
            drive->sectors, drive->secsize);
        if(drive->pkt == 0)
            n += snprint(p+n, l-n, " %d %d %d",
                drive->c, drive->h, drive->s);
        n += snprint(p+n, l-n, "\n");
    }
    qunlock(drive);

    return n;
}

static int
atawctl(SDunit* unit, Cmdbuf* cb)
{
    int period;
    Ctlr *ctlr;
    Drive *drive;

    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil)
        return 0;
    drive = ctlr->drive[unit->subno];

    qlock(drive);
    if(waserror()){
        qunlock(drive);
        nexterror();
    }

    /*
     * Dma and rwm control is passive at the moment,
     * i.e. it is assumed that the hardware is set up
     * correctly already either by the BIOS or when
     * the drive was initially identified.
     */
    if(strcmp(cb->f[0], "dma") == 0){
        if(cb->nf != 2 || drive->dma == 0)
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->dmactl = drive->dma;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->dmactl = 0;
        else
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "rwm") == 0){
        if(cb->nf != 2 || drive->rwm == 0)
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->rwmctl = drive->rwm;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->rwmctl = 0;
        else
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "standby") == 0){
        switch(cb->nf){
        default:
            error(Ebadctl);
        case 2:
            period = strtol(cb->f[1], 0, 0);
            if(period && (period < 30 || period > 240*5))
                error(Ebadctl);
            period /= 5;
            break;
        }
        if(atastandby(drive, period) != SDok)
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "lba48always") == 0){
        if(cb->nf != 2 || !(drive->flags&Lba48))
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->flags |= Lba48always;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->flags &= ~Lba48always;
        else
            error(Ebadctl);
    }
    else
        error(Ebadctl);
    qunlock(drive);
    poperror();

    return 0;
}

SDifc sdataifc = {
    "ata",              /* name */

    atapnp,             /* pnp */
    atalegacy,          /* legacy */
    ataenable,          /* enable */
    atadisable,         /* disable */

    scsiverify,         /* verify */
    scsionline,         /* online */
    atario,             /* rio */
    atarctl,            /* rctl */
    atawctl,            /* wctl */

    scsibio,            /* bio */
    ataprobew,          /* probe */
    ataclear,           /* clear */
    atastat,            /* rtopctl */
    nil,                /* wtopctl */
};
@
\fi


\subsection*{[[init/386/l_fp.s]]}


\subsection*{[[processes/386/apic.c]]}


<<[[Cpu]] [[Arch]] other fields(x86)>>=
Lock  apictimerlock;
@


<<apic.c>>=
<<kernel basic includes>>

#include "io.h"
#include "mp.h"

enum {                  /* Local APIC registers */
    LapicID     = 0x0020,   /* ID */
    LapicVER    = 0x0030,   /* Version */
    LapicTPR    = 0x0080,   /* Task Priority */
    LapicAPR    = 0x0090,   /* Arbitration Priority */
    LapicPPR    = 0x00A0,   /* Processor Priority */
    LapicEOI    = 0x00B0,   /* EOI */
    LapicLDR    = 0x00D0,   /* Logical Destination */
    LapicDFR    = 0x00E0,   /* Destination Format */
    LapicSVR    = 0x00F0,   /* Spurious Interrupt Vector */
    LapicISR    = 0x0100,   /* Interrupt Status (8 registers) */
    LapicTMR    = 0x0180,   /* Trigger Mode (8 registers) */
    LapicIRR    = 0x0200,   /* Interrupt Request (8 registers) */
    LapicESR    = 0x0280,   /* Error Status */
    LapicICRLO  = 0x0300,   /* Interrupt Command */
    LapicICRHI  = 0x0310,   /* Interrupt Command [63:32] */
    LapicTIMER  = 0x0320,   /* Local Vector Table 0 (TIMER) */
    LapicPCINT  = 0x0340,   /* Performance Counter LVT */
    LapicLINT0  = 0x0350,   /* Local Vector Table 1 (LINT0) */
    LapicLINT1  = 0x0360,   /* Local Vector Table 2 (LINT1) */
    LapicERROR  = 0x0370,   /* Local Vector Table 3 (ERROR) */
    LapicTICR   = 0x0380,   /* Timer Initial Count */
    LapicTCCR   = 0x0390,   /* Timer Current Count */
    LapicTDCR   = 0x03E0,   /* Timer Divide Configuration */
};

enum {                  /* LapicSVR */
    LapicENABLE = 0x00000100,   /* Unit Enable */
    LapicFOCUS  = 0x00000200,   /* Focus Processor Checking Disable */
};

enum {                  /* LapicICRLO */
                    /* [14] IPI Trigger Mode Level (RW) */
    LapicDEASSERT   = 0x00000000,   /* Deassert level-sensitive interrupt */
    LapicASSERT = 0x00004000,   /* Assert level-sensitive interrupt */

                    /* [17:16] Remote Read Status */
    LapicINVALID    = 0x00000000,   /* Invalid */
    LapicWAIT   = 0x00010000,   /* In-Progress */
    LapicVALID  = 0x00020000,   /* Valid */

                    /* [19:18] Destination Shorthand */
    LapicFIELD  = 0x00000000,   /* No shorthand */
    LapicSELF   = 0x00040000,   /* Self is single destination */
    LapicALLINC = 0x00080000,   /* All including self */
    LapicALLEXC = 0x000C0000,   /* All Excluding self */
};

enum {                  /* LapicESR */
    LapicSENDCS = 0x00000001,   /* Send CS Error */
    LapicRCVCS  = 0x00000002,   /* Receive CS Error */
    LapicSENDACCEPT = 0x00000004,   /* Send Accept Error */
    LapicRCVACCEPT  = 0x00000008,   /* Receive Accept Error */
    LapicSENDVECTOR = 0x00000020,   /* Send Illegal Vector */
    LapicRCVVECTOR  = 0x00000040,   /* Receive Illegal Vector */
    LapicREGISTER   = 0x00000080,   /* Illegal Register Address */
};

enum {                  /* LapicTIMER */
                    /* [17] Timer Mode (RW) */
    LapicONESHOT    = 0x00000000,   /* One-shot */
    LapicPERIODIC   = 0x00020000,   /* Periodic */

                    /* [19:18] Timer Base (RW) */
    LapicCLKIN  = 0x00000000,   /* use CLKIN as input */
    LapicTMBASE = 0x00040000,   /* use TMBASE */
    LapicDIVIDER    = 0x00080000,   /* use output of the divider */
};

enum {                  /* LapicTDCR */
    LapicX2     = 0x00000000,   /* divide by 2 */
    LapicX4     = 0x00000001,   /* divide by 4 */
    LapicX8     = 0x00000002,   /* divide by 8 */
    LapicX16    = 0x00000003,   /* divide by 16 */
    LapicX32    = 0x00000008,   /* divide by 32 */
    LapicX64    = 0x00000009,   /* divide by 64 */
    LapicX128   = 0x0000000A,   /* divide by 128 */
    LapicX1     = 0x0000000B,   /* divide by 1 */
};

static ulong* lapicbase;

struct Lapictimer
{
    uvlong  hz;
    ulong   max;
    ulong   min;
    ulong   div;
};

struct Lapictimer lapictimer;

static ulong
lapicr(int r)
{
    if(lapicbase == 0)
        panic("lapicr: no lapic");
    return *(lapicbase+(r/sizeof(*lapicbase)));
}

static void
lapicw(int r, ulong data)
{
    if(lapicbase == 0)
        panic("lapicw: no lapic");
    *(lapicbase+(r/sizeof(*lapicbase))) = data;
    data = *(lapicbase+(LapicID/sizeof(*lapicbase)));
    USED(data);
}

void
lapiconline(void)
{
    /*
     * Reload the timer to de-synchronise the processors,
     * then lower the task priority to allow interrupts to be
     * accepted by the APIC.
     */
    arch_microdelay((TK2MS(1)*1000/conf.ncpu) * cpu->cpuno);
    lapicw(LapicTICR, lapictimer.max);
    lapicw(LapicTIMER, LapicCLKIN|LapicPERIODIC|(VectorPIC+IrqTIMER));

    lapicw(LapicTPR, 0);
}

/*
 *  use the i8253 clock to figure out our lapic timer rate.
 */
static void
lapictimerinit(void)
{
    uvlong x, v, hz;

    v = cpu->cpuhz/1000;
    lapicw(LapicTDCR, LapicX1);
    lapicw(LapicTIMER, ApicIMASK|LapicCLKIN|LapicONESHOT|(VectorPIC+IrqTIMER));

    if(lapictimer.hz == 0ULL){
        x = arch_fastticks(&hz);
        x += hz/10;
        lapicw(LapicTICR, 0xffffffff);
        do{
            v = arch_fastticks(nil);
        }while(v < x);

        lapictimer.hz = (0xffffffffUL-lapicr(LapicTCCR))*10;
        lapictimer.max = lapictimer.hz/Arch_HZ;
        lapictimer.min = lapictimer.hz/(100*Arch_HZ);

        if(lapictimer.hz > hz-(hz/10)){
            if(lapictimer.hz > hz+(hz/10))
                panic("lapic clock %lld > cpu clock > %lld\n",
                    lapictimer.hz, hz);
            lapictimer.hz = hz;
        }
        assert(lapictimer.hz != 0);
        lapictimer.div = hz/lapictimer.hz;
    }
}

void
lapicinit(Apic* apic)
{
    ulong dfr, ldr, lvt;

    if(lapicbase == 0)
        lapicbase = apic->addr;
    if(lapicbase == 0) {
        print("lapicinit: no lapic\n");
        return;
    }

    /*
     * These don't really matter in Physical mode;
     * set the defaults anyway.
     */
    if(strncmp(cpu->cpuidid, "AuthenticAMD", 12) == 0)
        dfr = 0xf0000000;
    else
        dfr = 0xffffffff;
    ldr = 0x00000000;

    lapicw(LapicDFR, dfr);
    lapicw(LapicLDR, ldr);
    lapicw(LapicTPR, 0xff);
    lapicw(LapicSVR, LapicENABLE|(VectorPIC+IrqSPURIOUS));

    lapictimerinit();

    /*
     * Some Pentium revisions have a bug whereby spurious
     * interrupts are generated in the through-local mode.
     */
    switch(cpu->cpuidax & 0xFFF){
    case 0x526:             /* stepping cB1 */
    case 0x52B:             /* stepping E0 */
    case 0x52C:             /* stepping cC0 */
        wrmsr(0x0E, 1<<14);     /* TR12 */
        break;
    }

    /*
     * Set the local interrupts. It's likely these should just be
     * masked off for SMP mode as some Pentium Pros have problems if
     * LINT[01] are set to ExtINT.
     * Acknowledge any outstanding interrupts.
    lapicw(LapicLINT0, apic->lintr[0]);
    lapicw(LapicLINT1, apic->lintr[1]);
     */
    lapiceoi(0);

    lvt = (lapicr(LapicVER)>>16) & 0xFF;
    if(lvt >= 4)
        lapicw(LapicPCINT, ApicIMASK|(VectorPIC+IrqPCINT));
    lapicw(LapicERROR, VectorPIC+IrqERROR);
    lapicw(LapicESR, 0);
    lapicr(LapicESR);

    /*
     * Issue an INIT Level De-Assert to synchronise arbitration ID's.
     */
    lapicw(LapicICRHI, 0);
    lapicw(LapicICRLO, LapicALLINC|ApicLEVEL|LapicDEASSERT|ApicINIT);
    while(lapicr(LapicICRLO) & ApicDELIVS)
        ;

    /*
     * Do not allow acceptance of interrupts until all initialisation
     * for this processor is done. For the bootstrap processor this can be
     * early during initialisation. For the application processors this should
     * be after the bootstrap processor has lowered priority and is accepting
     * interrupts.
    lapicw(LapicTPR, 0);
     */
}

void
lapicstartap(Apic* apic, int v)
{
    int i;
    ulong crhi;

    /* make apic's processor do a warm reset */
    crhi = apic->apicno<<24;
    lapicw(LapicICRHI, crhi);
    lapicw(LapicICRLO, LapicFIELD|ApicLEVEL|LapicASSERT|ApicINIT);
    arch_microdelay(200);
    lapicw(LapicICRLO, LapicFIELD|ApicLEVEL|LapicDEASSERT|ApicINIT);
    arch_delay(10);

    /* assumes apic is not an 82489dx */
    for(i = 0; i < 2; i++){
        lapicw(LapicICRHI, crhi);
        /* make apic's processor start at v in real mode */
        lapicw(LapicICRLO, LapicFIELD|ApicEDGE|ApicSTARTUP|(v/BY2PG));
        arch_microdelay(200);
    }
}

void
lapicerror(Ureg*, void*)
{
    ulong esr;

    lapicw(LapicESR, 0);
    esr = lapicr(LapicESR);
    switch(cpu->cpuidax & 0xFFF){
    case 0x526:             /* stepping cB1 */
    case 0x52B:             /* stepping E0 */
    case 0x52C:             /* stepping cC0 */
        return;
    }
    print("cpu%d: lapicerror: 0x%8.8luX\n", cpu->cpuno, esr);
}

void
lapicspurious(Ureg*, void*)
{
    print("cpu%d: lapicspurious\n", cpu->cpuno);
}

int
lapicisr(int v)
{
    ulong isr;

    isr = lapicr(LapicISR + (v/32));

    return isr & (1<<(v%32));
}

int
lapiceoi(int v)
{
    lapicw(LapicEOI, 0);

    return v;
}

void
lapicicrw(ulong hi, ulong lo)
{
    lapicw(LapicICRHI, hi);
    lapicw(LapicICRLO, lo);
}

void
ioapicrdtr(Apic* apic, int sel, int* hi, int* lo)
{
    ulong *iowin;

    iowin = apic->addr+(0x10/sizeof(ulong));
    sel = IoapicRDT + 2*sel;

    lock(apic);
    *apic->addr = sel+1;
    if(hi)
        *hi = *iowin;
    *apic->addr = sel;
    if(lo)
        *lo = *iowin;
    unlock(apic);
}

void
ioapicrdtw(Apic* apic, int sel, int hi, int lo)
{
    ulong *iowin;

    iowin = apic->addr+(0x10/sizeof(ulong));
    sel = IoapicRDT + 2*sel;

    lock(apic);
    *apic->addr = sel+1;
    *iowin = hi;
    *apic->addr = sel;
    *iowin = lo;
    unlock(apic);
}

void
ioapicinit(Apic* apic, int apicno)
{
    int hi, lo, v;
    ulong *iowin;

    /*
     * Initialise the I/O APIC.
     * The MultiProcessor Specification says it is the responsibility
     * of the O/S to set the APIC id.
     * Make sure interrupts are all masked off for now.
     */
    iowin = apic->addr+(0x10/sizeof(ulong));
    lock(apic);
    *apic->addr = IoapicVER;
    apic->mre = (*iowin>>16) & 0xFF;

    *apic->addr = IoapicID;
    *iowin = apicno<<24;
    unlock(apic);

    hi = 0;
    lo = ApicIMASK;
    for(v = 0; v <= apic->mre; v++)
        ioapicrdtw(apic, v, hi, lo);
}

void
lapictimerset(uvlong next)
{
    vlong period;
    int x;

    x = arch_splhi();
    lock(&cpu->apictimerlock);

    period = lapictimer.max;
    if(next != 0){
        period = next - arch_fastticks(nil);
        if (lapictimer.div == 0)
            panic("lapictimerset: zero lapictimer.div");
        period /= lapictimer.div;

        if(period < lapictimer.min)
            period = lapictimer.min;
        else if(period > lapictimer.max - lapictimer.min)
            period = lapictimer.max;
    }
    lapicw(LapicTICR, period);

    unlock(&cpu->apictimerlock);
    arch_splx(x);
}

void
lapicclock(Ureg *u, void*)
{
    /*
     * since the MTRR updates need to be synchronized across processors,
     * we want to do this within the clock tick.
     */
    //mtrrclock(); disabled

    timerintr(u, 0);
}

void
lapicintron(void)
{
    lapicw(LapicTPR, 0);
}

void
lapicintroff(void)
{
    lapicw(LapicTPR, 0xFF);
}

@

%//void
%//lapicnmienable(void)
%//{
%//  /*
%//   * On the one hand the manual says the vector information
%//   * is ignored if the delivery mode is NMI, and on the other
%//   * a "Receive Illegal Vector" should be generated for a
%//   * vector in the range 0 through 15.
%//   * Some implementations generate the error interrupt if the
%//   * NMI vector is invalid, so always give a valid value.
%//   */
%//  if (lapicbase)
%//      lapicw(LapicPCINT, ApicNMI|(VectorPIC+IrqPCINT));
%//  else
%//      print("lapicnmienable: no lapic\n");
%//}
%
%//void
%//lapicnmidisable(void)
%//{
%//  if (lapicbase)
%//      lapicw(LapicPCINT, ApicIMASK|(VectorPIC+IrqPCINT));
%//  else
%//      print("lapicnmidisable: no lapic\n");
%//}


\subsection*{[[processes/386/archmp.c]]}

<<archmp.c forward decl(x86)>>=
// forward decl, mutual recursivity between archmp and identity
extern PCArch archmp;
@


<<global archmp(x86)>>=
PCArch archmp = {
    .id=        "_MP_", 
    .ident=     identify,
    .reset=     mpshutdown,
    .intrinit=  mpinit,
    .intrenable=    mpintrenable,
    .intron=    lapicintron,
    .introff=   lapicintroff,
    .fastclock= i8253read,
    .timerset=  lapictimerset,
    .resetothers=   mpresetothers,
};
@

<<[[Cpu]] [[Arch]] other fields(x86)>>=
uvlong tscticks;
@


<<function syncclock(x86)>>=
// actually not a clock callback even though finish in clock
void
syncclock(void)
{
    uvlong x;

    if(arch->fastclock != tscticks)
        return;

    if(cpu->cpuno == 0){
        wrmsr(0x10, 0);
        cpu->tscticks = 0;
    } else {
        x = CPUS(0)->tscticks;
        while(x == CPUS(0)->tscticks)
            ;
        wrmsr(0x10, CPUS(0)->tscticks);
        arch_cycles(&cpu->tscticks);
    }
}
@



<<function sigsearch(x86)>>=
void*
sigsearch(char* signature)
{
    uintptr p;
    uchar *bda;
    void *r;

    /*
     * Search for the data structure:
     * 1) within the first KiB of the Extended BIOS Data Area (EBDA), or
     * 2) within the last KiB of system base memory if the EBDA segment
     *    is undefined, or
     * 3) within the BIOS ROM address space between 0xf0000 and 0xfffff
     *    (but will actually check 0xe0000 to 0xfffff).
     */
    bda = BIOSSEG(0x40);
    if(memcmp(KADDR(0xfffd9), "EISA", 4) == 0){
        if((p = (bda[0x0f]<<8)|bda[0x0e]) != 0){
            if((r = sigscan(BIOSSEG(p), 1024, signature)) != nil)
                return r;
        }
    }

    if((p = ((bda[0x14]<<8)|bda[0x13])*1024) != 0){
        if((r = sigscan(KADDR(p-1024), 1024, signature)) != nil)
            return r;
    }
    /* hack for virtualbox: look in KiB below 0xa0000 */
    if((r = sigscan(KADDR(0xa0000-1024), 1024, signature)) != nil)
        return r;

    return sigscan(BIOSSEG(0xe000), 0x20000, signature);
}
@

<<function sigscan(x86)>>=
static void*
sigscan(uchar* addr, int len, char* signature)
{
    int sl;
    uchar *e, *p;

    e = addr+len;
    sl = strlen(signature);
    for(p = addr; p+sl < e; p += 16)
        if(memcmp(p, signature, sl) == 0)
            return p;
    return nil;
}
@


<<archmp.c>>=
<<kernel basic includes>>
#include "io.h"
#include "mp.h"

_MP_ *_mp_;

<<archmp.c forward decl(x86)>>


uvlong
tscticks(uvlong *hz)
{
    if(hz != nil)
        *hz = cpu->cpuhz;

    arch_cycles(&cpu->tscticks);   /* Uses the rdtsc instruction */
    return cpu->tscticks;
}

static void
mpresetothers(void)
{
    /*
     * INIT all excluding self.
     */
    lapicicrw(0, 0x000C0000|ApicINIT);
}

int
identify(void)
{
    char *cp;
    PCMP *pcmp;
    uchar *p, sum;
    ulong length;

    if((cp = getconf("*nomp")) != nil && strtol(cp, 0, 0) != 0)
        return 1;

    /*
     * Search for an MP configuration table. For now,
     * don't accept the default configurations (physaddr == 0).
     * Check for correct signature, calculate the checksum and,
     * if correct, check the version.
     * To do: check extended table checksum.
     */
    if((_mp_ = sigsearch("_MP_")) == 0 || _mp_->physaddr == 0) {
        /*
         * we can easily get processor info from acpi, but
         * interrupt routing, etc. would require interpreting aml.
         */
        print("archmp: no mp table found, assuming uniprocessor\n");
        return 1;
    }

    if (0)
        iprint("mp physaddr %#lux\n", _mp_->physaddr);
    pcmp = KADDR(_mp_->physaddr);
    if(memcmp(pcmp, "PCMP", 4) != 0) {
        print("archmp: mp table has bad magic");
        return 1;
    }

    length = pcmp->length;
    sum = 0;
    for(p = (uchar*)pcmp; length; length--)
        sum += *p++;

    if(sum || (pcmp->version != 1 && pcmp->version != 4))
        return 1;

    if(cpuserver && cpu->havetsc)
        archmp.fastclock = tscticks;
    return 0;
}

<<global archmp(x86)>>


//Lock mpsynclock;

<<function syncclock(x86)>>
@


\subsection*{[[processes/386/mpacpi.c]]}

<<mpacpi.c debugging macro(x86)>>=
//#define dprint(...)   if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
#define dprint if(mpdebug) print
/* from mp.c */
extern int  mpdebug;
@ 


<<mpacpi.c>>=
/*
 * minimal acpi support for multiprocessors.
 *
 * avoids AML but that's only enough to discover
 * the processors, not the interrupt routing details.
 */
<<kernel basic includes>>

#include "io.h"
#include "mp.h"
#include "mpacpi.h"

/* 8c says: out of fixed registers */
#define L64GET(p)   ((uvlong)L32GET((p)+4) << 32 | L32GET(p))

enum {
    /* apic types */
    Apiclproc,
    Apicio,
    Apicintrsrcoverride,
    Apicnmisrc,
    Apiclnmi,
    Apicladdroverride,
    Apicios,
    Apicls,
    Apicintrsrc,
    Apiclx2,
    Apiclx2nmi,

    PcmpUsed = 1ul<<31,     /* Apic->flags addition */

    Lapicbase = 0x1b,       /* msr */

    Lapicae = 1<<11,        /* apic enable in Lapicbase */
};

<<mpacpi.c debugging macro(x86)>>

int mpcpuno; //PAD: bug? also declared in mp.c
extern Apic mpapic[MaxAPICNO+1];
extern int  cpuno2apicno[MaxAPICNO+1]; /* inverse map: cpuno -> APIC ID */

Apic    *bootapic;

static int nprocid;

static uvlong
l64get(uchar *p)
{
    return L64GET(p);
}

int
apicset(Apic *apic, int type, int apicno, int f)
{
    if(apicno > MaxAPICNO)
        return -1;
    apic->type = type;
    apic->apicno = apicno;
    apic->flags = f | PcmpEN | PcmpUsed;
    return 0;
}

int
mpnewproc(Apic *apic, int apicno, int f)
{
    if(apic->flags & PcmpUsed) {
        print("mpnewproc: apic already enabled\n");
        return -1;
    }
    if (apicset(apic, PcmpPROCESSOR, apicno, f) < 0)
        return -1;
    apic->lintr[1] = apic->lintr[0] = ApicIMASK;
    /* botch! just enumerate */
    if(apic->flags & PcmpBP)
        apic->cpuno = 0;
    else
        apic->cpuno = ++mpcpuno;
    cpuno2apicno[apic->cpuno] = apicno;
    return 0;
}

static int
mpacpiproc(uchar *p, ulong laddr)
{
    int id, f;
    ulong *vladdr;
    vlong base;
    char *already;
    Apic *apic;

    /* p bytes: type (0), len (8), cpuid, cpu_lapic id, flags[4] */
    id = p[3];
    /* cpu unusable flag or id out of range? */
    if((L32GET(p+4) & 1) == 0 || id > MaxAPICNO)
        return -1;

    vladdr = nil;
    already = "";
    f = 0;
    apic = &mpapic[id];
    dprint("\tmpacpiproc: apic %#p\n", apic);
    apic->paddr = laddr;
    if (nprocid++ == 0) {
        f = PcmpBP;
        vladdr = vmap(apic->paddr, 1024);
        if(apic->addr == nil){
            print("proc apic %d: failed to map %#p\n", id,
                apic->paddr);
            already = "(fail)";
        }
        bootapic = apic;
    }
    apic->addr = vladdr;

    if(apic->flags & PcmpUsed)
        already = "(on)";
    else
        mpnewproc(apic, id, f);

    if (0)
        dprint("\tapic proc %d/%d apicid %d flags%s%s %s\n", nprocid-1,
            apic->cpuno, id, f & PcmpBP? " boot": "",
            f & PcmpEN? " enabled": "", already);
    USED(already);

    rdmsr(Lapicbase, &base);
    if (!(base & Lapicae)) {
        dprint("mpacpiproc: enabling lapic\n");
        wrmsr(Lapicbase, base | Lapicae);
    }
    return 0;
}

static void
mpacpicpus(Madt *madt)
{
    int i, n;
    ulong laddr;
    uchar *p;

    laddr = L32GET(madt->addr);
    dprint("APIC mpacpicpus(%#p) lapic addr %#lux, flags %#ux\n",
        madt, laddr, L32GET(madt->flags));

    n = L32GET(&madt->sdthdr[4]);
    p = madt->structures;
    dprint("\t%d structures at %#p\n",n, p);
    /* byte 0 is assumed to be type, 1 is assumed to be length */
    for(i = offsetof(Madt, structures[0]); i < n; i += p[1], p += p[1])
        switch(p[0]){
        case Apiclproc:
            mpacpiproc(p, laddr);
            break;
        }
}

/* returns nil iff checksum is bad */
static void *
mpacpirsdchecksum(void* addr, int length)
{
    uchar *p, sum;

    sum = 0;
    for(p = addr; length-- > 0; p++)
        sum += *p;
    return sum == 0? addr: nil;
}

/* call func for each acpi table found */
static void
mpacpiscan(void (*func)(uchar *))
{
    int asize, i, tbllen, sdtlen;
    uintptr dhpa, sdtpa;
    uchar *tbl, *sdt;
    Rsd *rsd;

    dprint("ACPI...");
    if((rsd = sigsearch("RSD PTR ")) == nil) {
        dprint("none\n");
        return;
    }

    dprint("rsd %#p physaddr %#ux length %ud %#llux rev %d oem %.6s\n",
        rsd, L32GET(rsd->raddr), L32GET(rsd->length),
        l64get(rsd->xaddr), rsd->revision, (char*)rsd->oemid);

    if(rsd->revision == 2){
        if(mpacpirsdchecksum(rsd, 36) == nil)
            return;
        asize = 8;
        sdtpa = l64get(rsd->xaddr);
    } else {
        if(mpacpirsdchecksum(rsd, 20) == nil)
            return;
        asize = 4;
        sdtpa = L32GET(rsd->raddr);
    }

    if((sdt = vmap(sdtpa, 8)) == nil)
        return;
    if((sdt[0] != 'R' && sdt[0] != 'X') || memcmp(sdt+1, "SDT", 3) != 0){
        vunmap(sdt, 8);
        return;
    }
    sdtlen = L32GET(sdt + 4);
    vunmap(sdt, 8);

    if((sdt = vmap(sdtpa, sdtlen)) == nil)
        return;
    if(mpacpirsdchecksum(sdt, sdtlen) != nil)
        for(i = 36; i < sdtlen; i += asize){
            if(asize == 8)
                dhpa = l64get(sdt+i);
            else
                dhpa = L32GET(sdt+i);
    
            if((tbl = vmap(dhpa, 8)) == nil)
                continue;
            tbllen = L32GET(tbl + 4);
            vunmap(tbl, 8);
    
            if((tbl = vmap(dhpa, tbllen)) == nil)
                continue;
            if(mpacpirsdchecksum(tbl, tbllen) != nil)
                (*func)(tbl);
            vunmap(tbl, tbllen);
        }
    vunmap(sdt, sdtlen);
}

static void
mpacpitbl(uchar *p)
{
    /* for now, just activate any idle cpus */
    if (memcmp(p, "APIC", 4) == 0)
        mpacpicpus((Madt *)p);
}

static void
mpacpi(void)
{
    mpdebug = getconf("*debugmp") != nil;
    mpacpiscan(mpacpitbl);
}

void    (*mpacpifunc)(void) = mpacpi;
@



\subsection*{[[init/386/rebootcode.s]]}

<<init/386/rebootcode.s>>=
#include "mem.h"

/*
 * Turn off MMU, then memmove the new kernel to its correct location
 * in physical memory.  Then jump to the start of the kernel.
 */

TEXT    main(SB),$0
        MOVL    p1+0(FP), DI            /* destination */
        MOVL    DI, AX                  /* entry point */
        MOVL    p2+4(FP), SI            /* source */
        MOVL    n+8(FP), CX             /* byte count */

/*
 * disable paging
 */
        MOVL    CR0, DX
        ANDL    $~0x80000000, DX                /* ~(PG) */
        MOVL    DX, CR0
        MOVL    $0, DX
        MOVL    DX, CR3

/*
 * the source and destination may overlap.
 * determine whether to copy forward or backwards
 */
        CMPL    SI, DI
        JGT     _forward
        MOVL    SI, DX
        ADDL    CX, DX
        CMPL    DX, DI
        JGT     _back

_forward:
        CLD
        REP;    MOVSB
        JMP     _startkernel

_back:
        ADDL    CX, DI
        ADDL    CX, SI
        SUBL    $1, DI
        SUBL    $1, SI
        STD
        REP;    MOVSB
        JMP     _startkernel
/*
 * JMP to kernel entry point.  Note the true kernel entry point is
 * the virtual address KZERO|AX, but this must wait until
 * the MMU is enabled by the kernel in l.s
 */
_startkernel:
        ORL     AX, AX          /* NOP: avoid link bug */
        JMP*    AX
@
%$



\subsection*{[[init/386/apbootstrap.s]]}

<<apbootstrap.s>>=
/*
 * Start an Application Processor. This must be placed on a 4KB boundary
 * somewhere in the 1st MB of conventional memory (APBOOTSTRAP). However,
 * due to some shortcuts below it's restricted further to within the 1st
 * 64KB. The AP starts in real-mode, with
 *   CS selector set to the startup memory address/16;
 *   CS base set to startup memory address;
 *   CS limit set to 64KB;
 *   CPL and IP set to 0.
 */
#include "mem.h"

//TODO: mv in x16.ha? or just case of instructions not handled by 8[al]?
#define NOP             BYTE $0x90              /* NOP */
#define LGDT(gdtptr)    BYTE $0x0F;             /* LGDT */                      \
                        BYTE $0x01; BYTE $0x16;                                 \
                        WORD $gdtptr
#define FARJUMP16(s, o) BYTE $0xEA;             /* far jump to ptr16:16 */      \
                        WORD $o; WORD $s;                                       \
                        NOP; NOP; NOP
#define FARJUMP32(s, o) BYTE $0x66;             /* far jump to ptr32:16 */      \
                        BYTE $0xEA; LONG $o; WORD $s

#define DELAY           BYTE $0xEB;             /* JMP .+2 */                   \
                        BYTE $0x00
#define INVD            BYTE $0x0F; BYTE $0x08
#define WBINVD          BYTE $0x0F; BYTE $0x09

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. Note that these are assembler-specific hence
 * the '<<2'.
 */
#define PDO(a)          (((((a))>>22) & 0x03FF)<<2)
#define PTO(a)          (((((a))>>12) & 0x03FF)<<2)

TEXT apbootstrap(SB), $0
        FARJUMP16(0, _apbootstrap(SB))
TEXT _apvector(SB), $0                          /* address APBOOTSTRAP+0x08 */
        LONG $0
TEXT _appdb(SB), $0                             /* address APBOOTSTRAP+0x0C */
        LONG $0
TEXT _apapic(SB), $0                            /* address APBOOTSTRAP+0x10 */
        LONG $0
TEXT _apbootstrap(SB), $0                       /* address APBOOTSTRAP+0x14 */
        MOVW    CS, AX
        MOVW    AX, DS                          /* initialise DS */

        LGDT(gdtptr(SB))                        /* load a basic gdt */

        MOVL    CR0, AX
        ORL     $1, AX
        MOVL    AX, CR0                         /* turn on protected mode */
        DELAY                                   /* JMP .+2 */

        BYTE $0xB8; WORD $SELECTOR(1, SELGDT, 0)/* MOVW $SELECTOR(1, SELGDT, 0), AX */
        MOVW    AX, DS
        MOVW    AX, ES
        MOVW    AX, FS
        MOVW    AX, GS
        MOVW    AX, SS

        FARJUMP32(SELECTOR(2, SELGDT, 0), _ap32-KZERO(SB))

/*
 * For Pentiums and higher, the code that enables paging must come from
 * pages that are identity mapped. 
 * To this end double map KZERO at virtual 0 and undo the mapping once virtual
 * nirvana has been obtained.
 */
TEXT _ap32(SB), $0
        MOVL    _appdb-KZERO(SB), CX            /* physical address of PD */
        MOVL    (PDO(KZERO))(CX), DX            /* double-map KZERO at 0 */
        MOVL    DX, (PDO(0))(CX)
        MOVL    CX, CR3                         /* load and flush the mmu */

        MOVL    CR0, DX
        ORL     $0x80010000, DX                 /* PG|WP */
        ANDL    $~0x6000000A, DX                /* ~(CD|NW|TS|MP) */

        MOVL    $_appg(SB), AX
        MOVL    DX, CR0                         /* turn on paging */
        JMP*    AX

TEXT _appg(SB), $0
        MOVL    CX, AX                          /* physical address of PD */
        ORL     $KZERO, AX
        MOVL    $0, (PDO(0))(AX)                /* undo double-map of KZERO at 0 */
        MOVL    CX, CR3                         /* load and flush the mmu */

        MOVL    $(CPUADDR+CPUSIZE-4), SP

        MOVL    $0, AX
        PUSHL   AX
        POPFL

        MOVL    _apapic(SB), AX
        MOVL    AX, (SP)
        MOVL    _apvector(SB), AX
        CALL*   AX
_aphalt:
        HLT
        JMP     _aphalt

TEXT gdt(SB), $0
        LONG $0x0000; LONG $0
        LONG $0xFFFF; LONG $(SEGG|SEGB|(0xF<<16)|SEGP|SEGPL(0)|SEGDATA|SEGW)
        LONG $0xFFFF; LONG $(SEGG|SEGD|(0xF<<16)|SEGP|SEGPL(0)|SEGEXEC|SEGR)
TEXT gdtptr(SB), $0
        WORD    $(3*8-1)
        LONG    $gdt-KZERO(SB)
@



