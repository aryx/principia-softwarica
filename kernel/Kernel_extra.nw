\section{[[arch/]]}

\section{[[buses/]]}

\section{[[concurrency/]]}

\subsection*{[[concurrency/portdat_concurrency.h]]}

\ifallcode
<<lock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
        l->lockcycles = -arch_lcycles();
#endif
@ 
\fi

\ifallcode
<<[[Lock]] debugging fields>>=
//#ifdef LOCKCYCLES
long  lockcycles;
//#endif
@ 
\fi


\ifallcode
<<unlock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumlockcycles += l->lockcycles;
    if(l->lockcycles > maxlockcycles){
        maxlockcycles = l->lockcycles;
        maxlockpc = l->pc;
    }
#endif
@ 
\fi

\ifallcode
<<iunlock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumilockcycles += l->lockcycles;
    if(l->lockcycles > maxilockcycles){
        maxilockcycles = l->lockcycles;
        maxilockpc = l->pc;
    }
    if(l->lockcycles > 2400)
        ilockpcs[n++ & 0xff]  = l->pc;
#endif
@ 
\fi


<<portdat_concurrency.h>>=

//*****************************************************************************
// Mutual exclusion
//*****************************************************************************

// arch_tas < Lock < QLock|RWLock

// used to be in <arch> but the fields were used from port/ so must be portable!
<<struct Lock>>

<<struct ILock>>

<<struct QLock>>

<<struct RWlock>>

//*****************************************************************************
// Atomicity
//*****************************************************************************

<<struct Ref>>

<<struct Counter>>

//*****************************************************************************
// Synchronization
//*****************************************************************************

// defined in this directory but no functions are operating on it in this dir
<<struct Rendez>>

<<struct Sema>>

// see also Waitq in portdat_processes.h?
@


\subsection*{[[concurrency/portfns_concurrency.h]]}

\ifallcode
<<portfns_concurrency.h>>=

// taslock.c
int  lock(Lock*);
void unlock(Lock*);
void ilock(Lock*);
void iunlock(Lock*);
int  canlock(Lock*);

// ref.c
long incref(Ref*);
long decref(Ref*);

// qlock.c
void qlock(QLock*);
void qunlock(QLock*);
int  canqlock(QLock*);

void rlock(RWlock*);
void runlock(RWlock*);
int  canrlock(RWlock*);
void wlock(RWlock*);
void wunlock(RWlock*);

// in <arch>/l.s (but used in port)
//@Scheck: Assembly
bool arch_islo(void);
//@Scheck: Assembly
int  arch_splhi(void);
//@Scheck: Assembly
int  arch_spllo(void);
//@Scheck: Assembly
void arch_splx(int);
//test-and-set
//@Scheck: Assembly
int  arch_tas(void*);
//@Scheck: Assembly
void arch_xinc(long*);
//@Scheck: Assembly
long arch_xdec(long*);

// <arch>/??? (called from port but signature not portable across <arch>)
//void  arch_coherence(void);
//int   arch_cmpswap(long*, long, long); 

@
\fi
%//void    splxpc(int);
%//long    lcycles(void);

\subsection*{[[concurrency/taslock.c]]}

\ifallcode
<<struct TaslockStats>>=
struct TaslockStats
{
    ulong   locks;
    ulong   glare;
    ulong   inglare;
};
@

<<global lockstats>>=
struct TaslockStats lockstats;
@

<<globals lockcycles>>=
#ifdef LOCKCYCLES
long maxlockcycles;
long maxilockcycles;
long cumlockcycles;
long cumilockcycles;
ulong maxlockpc;
ulong maxilockpc;

ulong ilockpcs[0x100] = { [0xff] = 1 };
static int n;
#endif
@

\fi


<<taslock.c>>=
// TAS: Test And Set
<<kernel basic includes>>

<<struct TaslockStats>>
<<global lockstats>>
<<globals lockcycles>>

<<function inccnt>>

<<function deccnt>>

<<function lockloop>>

<<function lock>>

<<function ilock>>

<<function canlock>>

<<function unlock>>

<<function iunlock>>

@



\subsection*{[[concurrency/qlock.c]]}

\ifallcode
<<struct QlockStats>>=
struct QlockStats {
    ulong rlock;
    ulong rlockq;
    ulong wlock;
    ulong wlockq;
    ulong qlock;
    ulong qlockq;
};
@

<<global rwstats>>=
struct QlockStats rwstats;
@
\fi


<<qlock.c>>=
<<kernel basic includes>>

<<struct QlockStats>>
<<global rwstats>>

<<function qlock>>

<<function canqlock>>

<<function qunlock>>

<<function rlock>>

<<function runlock>>

<<function wlock>>

<<function wunlock>>

<<function canrlock>>
@


\subsection*{[[concurrency/ref.c]]}
%pad: I created this file, was in chan.c 
% (see also _incnt and _deccnt in tasklock.c)


<<ref.c>>=
<<kernel basic includes>>

<<function incref>>

<<function decref>>
@


\section{[[console/]]}

\subsection*{[[console/portdat_console.h]]}

\ifallcode
<<portdat_console.h>>=
extern  Queue*  kbdq;
extern  Queue*  kprintoq;
extern  Queue*  serialoq;

// consdevtab
@
\fi

\subsection*{[[console/portfns_console.h]]}

\ifallcode
<<portfns_console.h>>=

// devcons.c
// in portfns_core.h, to remove some backward dependencies
//int  (*pprint)(char*, ...);
//void (*_assert)(char*);
void kbdqinit(void);
void lineqinit(void);
void kbdputc(Rune);
int  consactive(void);
int  kbdcr2nl(Queue*, int);
int  nrand(int);
void putstrn(char*, int);
//     (*print) is declared lib.h
//int  (*iprint)(char*, ...);
//void (*panic)(char*, ...);
// as a pointer in the original too
void  (*screenputs)(char*, int);
// overrides also sysfatal from libc/9sys/sysfatal.c, that are called
// from a few libc functions

// rdb.c
void    rdb(void);

// print.c
// overrides _fmtlock, from lib_core/libc/fmt/fmtlock.c that are used
// in fmt related functions
@
\fi

\subsection*{[[console/devcons.c]]}

\ifallcode
<<devcons.c forward decl>>=
static void seedrand(void);
static int  readtime(ulong, char*, int);
static int  readbintime(char*, int);
static int  writetime(char*, int);
static int  writebintime(char*, int);
@
\fi


<<devcons.c>>=
<<kernel basic includes>>

#include    <pool.h>

// used also by edf.c
<<global panicking>>

<<hook screenputs>>
<<hook consdebug>>

<<global kbdq>>
<<global lineq>>
<<global serialoq>>
<<global kprintoq>>

<<global kprintinuse>>
<<global iprintscreenputs>>

<<struct ConsKbd>>

<<global kbd>>

<<global fasthz>>

<<devcons.c forward decl>>

<<function kbdqinit>>

<<function lineqinit>>

<<function consactive>>

<<function prflush>>

<<struct KMesg>>

<<global kmesg>>

<<function kmesgputs>>

<<function putstrn0>>

<<function putstrn>>

<<function print>>

<<global iprintlock>>

<<function iprintcanlock>>

<<function iprint>>

<<function panic>>

<<function sysfatal>>

<<function _assert>>

<<function pprint>>

<<function echoscreen>>

<<function echoserialoq>>

<<function echo>>

<<function kbdcr2nl>>

<<function kbdputc>>

<<clock callback kbdputcclock>>

<<devcons.c enum Qxxx>>

enum
{
    <<constant VLNUMSIZE>>
};

<<global consdir>>

<<method consinit>>

static Chan*
consattach(char *spec)
{
    return devattach('c', spec);
}

static Walkqid*
conswalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name,nname, consdir, nelem(consdir), devgen);
}

static int
consstat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, consdir, nelem(consdir), devgen);
}

<<method consopen>>

<<method consclose>>

<<method consread>>

<<method conswrite>>

<<global consdevtab>>

<<global randn>>

<<function seedrand>>

<<function nrand>>

<<global uvorder>>

<<function le2vlong>>

<<function vlong2le>>

<<global order>>

<<function le2long>>

<<devcons.c Exxx errors>>

<<function readtime>>

<<function writetime>>

<<function readbintime>>

<<function writebintime>>
@

%
%
%//static uchar*
%//long2le(uchar *t, long from)
%//{
%//  uchar *f, *o;
%//  int i;
%//
%//  f = (uchar*)&from;
%//  o = (uchar*)&order;
%//  for(i = 0; i < sizeof(long); i++)
%//      t[i] = f[o[i]];
%//  return t+sizeof(long);
%//}

\section{[[core/]]}

\subsection*{[[core/portdat_forward.h]]}

\ifallcode
<<portdat_forward.h pragmas>>=
#pragma incomplete Edf
#pragma incomplete Mntcache
#pragma incomplete Mntrpc
#pragma incomplete Queue
#pragma incomplete Timers
@
\fi
%old:
% #pragma incomplete DevConf

\ifallcode
<<portdat_forward.h>>=
typedef struct Alarms Alarms;
typedef struct Block  Block;
typedef struct Chan Chan;
typedef struct Cmdbuf Cmdbuf;
typedef struct Cmdtab Cmdtab;
typedef struct Dev  Dev;
typedef struct Dirtab Dirtab;
typedef struct Edf  Edf;
typedef struct Egrp Egrp;
typedef struct Evalue Evalue;
typedef struct Execvals Execvals;
typedef struct Fgrp Fgrp;
typedef struct KImage KImage;
typedef struct Log  Log;
typedef struct Logflag  Logflag;
typedef struct Mntcache Mntcache;
typedef struct Mount  Mount;
typedef struct Mntrpc Mntrpc;
typedef struct Mntwalk  Mntwalk;
typedef struct Mnt  Mnt;
typedef struct Mhead  Mhead;
typedef struct Note Note;
typedef struct Page Page;
typedef struct Path Path;
typedef struct Palloc Palloc;
typedef struct Pallocmem  Pallocmem;
typedef struct Perf Perf;
typedef struct PhysUart PhysUart;
typedef struct Pgrp Pgrp;
typedef struct Physseg  Physseg;
typedef struct Proc Proc;
typedef struct Pagetable  Pagetable;
typedef struct KQLock QLock;
typedef struct Queue  Queue;
typedef struct Ref  Ref;
typedef struct Rendez Rendez;
typedef struct Rgrp Rgrp;
typedef struct RWlock RWlock;
typedef struct Sargs  Sargs;
typedef struct Schedq Schedq;
typedef struct Segment  Segment;
typedef struct Sema Sema;
typedef struct Timer  Timer;
typedef struct Timers Timers;
typedef struct Uart Uart;
typedef struct Waitq  Waitq;
typedef struct Walkqid  Walkqid;
typedef struct Watchdog Watchdog;

typedef int    Devgen(Chan*, char*, Dirtab*, int, int, DirEntry*);

// was in dat_forward.h
typedef struct Conf Conf;
typedef struct Confmem  Confmem;
typedef struct Lock Lock;
typedef struct Cpu Cpu;
typedef struct Label  Label;
typedef struct DevConf  DevConf;
typedef struct Devport  Devport;
typedef struct ISAConf  ISAConf;

// was in cache.c
typedef struct Extent Extent;
// was in xallo.c
typedef struct Hole Hole;
typedef struct Xalloc Xalloc;
typedef struct Xhdr Xhdr;

// was in sd.h
typedef struct SDev SDev;
typedef struct SDifc SDifc;
typedef struct SDio SDio;
typedef struct SDpart SDpart;
typedef struct SDperm SDperm;
typedef struct SDreq SDreq;
typedef struct SDunit SDunit;

// was in kbd.c
typedef struct Kbscan Kbscan;

<<portdat_forward.h pragmas>>
@
\fi
\subsection*{[[core/portdat_core.h]]}

<<portdat_core.h>>=

// All those structs used to be in <arch>/dat.h, but many of their fields
// were used from port/ so I've moved them here (and put the arch
// specific fields in dat_core.h)

//*****************************************************************************
// Conf
//*****************************************************************************

<<struct Confmem>>

<<struct Conf>>

extern Conf conf;

<<constant MAXCONF>>
// hash<string, string>
extern char *confname[];
extern char *confval[];
// Hashtbl.length(confname)
extern int nconf;

extern bool cpuserver; // defined in $CONF.c

char* getconf(char *name);

//*****************************************************************************
// Cpu
//*****************************************************************************

<<struct Label>>

<<struct Perf>>

<<struct Cpu>>


// array<ref<Cpu>>, MAXCPUS is defined in <arch>/mem.h
extern Cpu* cpus[MAXCPUS];
<<macro CPUS>>

// 'up' and 'cpu' can have different implement in different archi
// so they are not defined here.

//*****************************************************************************
// Other
//*****************************************************************************

extern char* eve;
int iseve(void);
// accessed by /dev/hostdomain, defined in auth.c
extern  char  hostdomain[];

// defined in ???
extern ulong    kerndate; 

@
%$

\subsection*{[[core/portfns_core.h]]}

\ifallcode
<<portfns_core.h pragmas>>=
#pragma varargck argpos iprint  1
#pragma varargck argpos pprint  1
#pragma varargck argpos panic 1
@
\fi

\ifallcode
<<portfns_core.h>>=

// exported in lib.h, defined in portfns.c
// (*print)

// exported in lib.h, defined in 386/fns.c (but used in port)
// int  cistrcmp(char*, char*);
// int  cistrncmp(char*, char*, int);

// could be in lib.h
<<portdat.h macros>>

// portfns.c (mostly here just to remove some backward dependencies)
<<portfns_core.h backward deps breaker>>

// portfns.c
bool returnfalse(void*);
int   readnum(ulong, char*, ulong, ulong, int);
int   readstr(ulong, char*, ulong, char*);

<<portfns_core.h pragmas>>
@
\fi


%//unused and undefined:
%//void    addwatchdog(Watchdog*);
%//long    clrfpintr(void);
%//int   decrypt(void*, void*, int);
%//int   encrypt(void*, void*, int);
%//int   eqchan(Chan*, Chan*, bool);
%//void    logopen(Log*);
%//void    logclose(Log*);
%//char*   logctl(Log*, int, char**, Logflag*);
%//void    logn(Log*, int, void*, int);
%//long    logread(Log*, void*, ulong, long);
%//void    log(Log*, int, char*, ...);
%//void    resched(char*);
%//void    savefpregs(FPsave*);

\subsection*{[[core/portdat.h]]}

\ifallcode
<<portdat.h pragmas(x86)>>=
#pragma varargck  type  "I" uchar*
#pragma varargck  type  "V" uchar*
#pragma varargck  type  "E" uchar*
#pragma varargck  type  "M" uchar*
@
\fi



<<portdat.h macros>>=
#define MIN(a, b) ((a) < (b)? (a): (b))
#define HOWMANY(x, y) (((x)+((y)-1))/(y))
#define ROUNDUP(x, y) (HOWMANY((x), (y))*(y)) /* ceiling */

// BY2PG is defined in mem.h, which should always be included before "dat.h"!
#define PGROUND(s)  ROUNDUP(s, BY2PG)

#define FEXT(d, o, w) (((d)>>(o)) & ((1<<(w))-1)) // used in bcm/mmu.c
@


%/*
% * For multi-bit fields use FIELD(v, o, w) where 'v' is the value
% * of the bit-field of width 'w' with LSb at bit offset 'o'.
% */
%//#define MAX(a, b) ((a) > (b)? (a): (b))
%//#define ROUNDDN(x, y) (((x)/(y))*(y))   /* floor */
%//#define FIELD(v, o, w)  (((v) & ((1<<(w))-1))<<(o))
%//#define FCLR(d, o, w) ((d) & ~(((1<<(w))-1)<<(o)))
%//#define FINS(d, o, w, v) (FCLR((d), (o), (w))|FIELD((v), (o), (w)))
%//#define FSET(d, o, w) ((d)|(((1<<(w))-1)<<(o)))
%//#define FMASK(o, w) (((1<<(w))-1)<<(o))
%
%//#define MAXBY2PG BY2PG    /* rounding for UTZERO in executables */
%
%//enum
%//{
%//  NSMAX = 1000,
%//  NSLOG = 7,
%//  NSCACHE = (1<<NSLOG),
%//};
%//enum
%//{
%//  NCMDFIELD = 128
%//};
%/*
% *  action log
% */
%//struct Log {
%//  Lock;
%//  int opens;
%//  char* buf;
%//  char  *end;
%//  char  *rptr;
%//  int len;
%//  int nlog;
%//  int minread;
%//
%//  int logmask;  /* mask of things to debug */
%//
%//  QLock readq;
%//  Rendez  readr;
%//};
%//
%//struct Logflag {
%//  char* name;
%//  int mask;
%//};
%//



\subsection*{[[core/error.h]]}

\ifallcode
<<error.h>>=
extern char Emount[];   /* inconsistent mount */
extern char Eunmount[];   /* not mounted */
extern char Eismtpt[];    /* is a mount point */
extern char Eunion[];   /* not in union */
extern char Emountrpc[];  /* mount rpc error */
extern char Eshutdown[];  /* device shut down */
extern char Enocreate[];  /* mounted directory forbids creation */
extern char Enonexist[];  /* file does not exist */
extern char Eexist[];   /* file already exists */
extern char Ebadsharp[];  /* unknown device in # filename */
extern char Enotdir[];    /* not a directory */
extern char Eisdir[];   /* file is a directory */
extern char Ebadchar[];   /* bad character in file name */
extern char Efilename[];  /* file name syntax */
extern char Eperm[];    /* permission denied */
extern char Ebadusefd[];  /* inappropriate use of fd */
extern char Ebadarg[];    /* bad arg in system call */
extern char Einuse[];   /* device or object already in use */
extern char Eio[];    /* i/o error */
extern char Etoobig[];    /* read or write too large */
extern char Etoosmall[];  /* read or write too small */
extern char Ehungup[];    /* i/o on hungup channel */
extern char Ebadctl[];    /* bad process or channel control request */
extern char Enodev[];   /* no free devices */
extern char Eprocdied[];  /* process exited */
extern char Enochild[];   /* no living children */
extern char Eioload[];    /* i/o error in demand load */
extern char Enovmem[];    /* virtual memory allocation failed */
extern char Ebadfd[];   /* fd out of range or not open */
extern char Enofd[];    /* no free file descriptors */
extern char Eisstream[];  /* seek on a stream */
extern char Ebadexec[];   /* exec header invalid */
extern char Etimedout[];  /* connection timed out */
extern char Econrefused[];  /* connection refused */
extern char Econinuse[];  /* connection in use */
extern char Eintr[];    /* interrupted */
extern char Enomem[];   /* kernel allocate failed */
extern char Esoverlap[];  /* segments overlap */
extern char Eshort[];   /* i/o count too small */
extern char Egreg[];    /* jmk added reentrancy for threads */
extern char Ebadspec[];   /* bad attach specifier */
extern char Enoreg[];   /* process has no saved registers */
extern char Enoattach[];  /* mount/attach disallowed */
extern char Eshortstat[]; /* stat buffer too small */
extern char Ebadstat[];   /* malformed stat buffer */
extern char Enegoff[];    /* negative i/o offset */
extern char Ecmdargs[];   /* wrong #args in control message */
extern char Ebadip[];   /* bad ip address syntax */
extern char Edirseek[];   /* seek in directory */
extern char Echange[];    /* media or partition has changed */
extern char Edetach[];    /* device is detached */
extern char Enotconf[];   /* endpoint not configured */
extern char Estalled[];   /* endpoint stalled */
extern char Esbadstat[];  /* invalid directory entry received from server */
extern char Enoversion[]; /* version not established for mount channel */
@
\fi

%//extern char Enoerror[];   /* no error */
%//extern char Enoport[];    /* network port not available */
%//extern char Enoswap[];    /* swap space full */
%//extern char Eaoedown[];   /* aoe device is down */

\subsection*{[[core/error.c]]}

<<error.c>>=
<<global Exxx errors>>
@

\subsection*{[[core/portdat.c]]}


<<portdat.c>>=
<<kernel basic includes>>

// was in init/main.c
<<global conf>>
// bool cpuserver; // defined in $CONF.c

<<globals confname and confvar>>

<<function getconf>>

// was in dat.h
<<global cpus>>
// cpu is in init/main.c because it can differ in different archi

// was in security/auth.c
<<global eve>>
// should be in portfns.c, but then backward deps
/*
 *  return true if current user is eve
 */
<<function iseve>>

@
%$

\subsection*{[[core/portfns.c]]}

<<portfns.c>>=
<<kernel basic includes>>

// backward dependencies breaker for non functional properties functions
// (logging, security, error, profiling/timing)
<<portfns.c backward deps breaker>>

<<function returnfalse>>

// was in devcons.c, could be in lib/misc.c
<<function readnum>>

<<function readstr>>
@

\section{[[devices/]]}

\subsection*{[[devices/portdat_devices.h]]}

<<struct Devport>>=
struct Devport {
    ulong port; 
    int size;
};
@ 

<<struct DevConf>>=
struct DevConf
{
    ulong intnum;     /* interrupt number */
    char  *type;      /* card type, malloced */
    int nports;     /* Number of ports */
    Devport *ports;     /* The ports themselves */
};
@
% this used to be in dat.h but it's the same in bcm/ and it's actually
% referenced in portable code (e.g., devsd.c)

<<portdat_devices.h>>=
/*
 *  hardware info about a device
 */
<<struct Devport>>

<<struct DevConf>>

// keyboard

<<enum kbscan>>

<<struct Kbscan>>

// keyboard/portkbd.c
extern Kbscan kbscans[KbNscans];

// mouse

/*
 *  mouse types
 */
enum MouseType
{
    Mouseother= 0,
    Mouseserial=    1,
    MousePS2=   2,
};

// mouse/devmouse.c (used in portmouse.c, portkbd.c, ...)
extern int mouseshifted;

// mouse/portmouse.c (used in <arch>/mouse.c)
extern int mousetype;
extern int packetsize;
extern bool mousehwaccel;
extern bool intellimouse;

/* devdraw.c */ // used in some <arch>/screen.c
extern QLock	drawlock;
// for gscreen, gscreendata, see portscreen.h

@



%\subsection*{[[devices/keyboard/portkbd.h]]}
%pad: I originally added this file and factorize stuff from <arch>*/kbd.c
% but now simpler to put it in portdat_devices.h

<<portkbd.h>>=
ERROR
@

\subsection*{[[devices/portfns_devices.h]]}

\ifallcode
<<portfns_devices.h>>=

// sys/devroot.c
extern void  addbootfile(char*, uchar*, ulong);

// sys/devmnt.c
extern Chan* mntauth(Chan*, char*);
extern long  mntversion(Chan*, char*, int, int);

// sys/devsrv.c
extern char* srvname(Chan*);

// sys/devproc.c
extern int   procfdprint(Chan*, int, int, char*, int);

// sys/devenv.c
extern void  envcpy(Egrp*, Egrp*);
extern void  ksetenv(char*, char*, int);
extern char* getconfenv(void);



// screen/devdraw.c
extern void  drawactive(bool);
extern void  drawcmap(void);

// mouse/devmouse.c (called from portmouse.c or <arch>/mouse.c)
extern void  mouseresize(void);
extern void  mouseaccelerate(int x);
extern void  mousetrack(int dx, int dy, int b, int msec);
// to call to let know devmouse.c about some mouse related keyboard events
extern void  (*kbdmouse)(int);

// sys/devrtc.c
//long    rtctime(void);


// mouse/portmouse.c (called by devmouse.c for arch-specific mouse settings)
extern void  kmousectl(Cmdbuf*);

// keyboard/latin1.c (used by portkbd.c)
//@Scheck: def currently skipped, see skip_list.txt, because of unicode
extern long  latin1(Rune*, int);

// keyboard/portkbd.c
extern void  kbdputsc(byte, int);
extern int   kbdgetmap(uint, int*, int*, Rune*);
extern void  kbdputmap(ushort, ushort, Rune);


// mouse/<arch>/mouse.c (called from portmouse.c)
extern void  arch_ps2mouse(void);
extern void  arch_setaccelerated(void);
extern void  arch_setlinear(void);
extern void  arch_setres(int n);
extern void  arch_setintellimouse(void);
extern void  arch_resetmouse(void);

// keyboard/<arch>/kbd.c (called from portkbd.c)
extern void  arch_setleds(Kbscan *kbscan);

// screen/<arch>/screen.c (called from main)
extern void  arch_screeninit(void);

// sys/<arch>/devarch.c (called from arch specific)
extern Dirtab* addarchfile(char*, int, long(*)(Chan*,void*,long,vlong), long(*)(Chan*,void*,long,vlong));

@
\fi


\subsection*{[[devices/keyboard/portkbd.c]]}
%pad: I added this file and factorize stuff from <arch>/kbd.c

%old: (old or diff with bcm/kbd.c that I removed)
% - Latin -> Alt
% - I removed some high code for some exotic keyboard
% /*
%  * The codes at 0x79 and 0x7b are produced by the PFU Happy Hacking keyboard.
%  * A 'standard' keyboard doesn't produce anything above 0x58.
%  */
% - removed the shiftesc stuff
%  Rune kbtabshiftesc1[Nscan] =
%  {
%  [0x00]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x08]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x10]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x18]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x20]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x28]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x30]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x38]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x40]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x48]	Up,	No,	No,	No,	No,	No,	No,	No,
%  [0x50]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x58]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x60]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x68]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x70]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x78]	No,	Up,	No,	No,	No,	No,	No,	No,
%  };
%  
%  Rune kbtabctrlesc1[Nscan] =
%  {
%  [0x00]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x08]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x10]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x18]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x20]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x28]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x30]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x38]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x40]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x48]	Up,	No,	No,	No,	No,	No,	No,	No,
%  [0x50]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x58]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x60]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x68]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x70]	No,	No,	No,	No,	No,	No,	No,	No,
%  [0x78]	No,	Up,	No,	No,	No,	No,	No,	No,
%  };
% ...
%	if(kbscan->esc1 && kbscan->shift){
%		c = kbtabshiftesc1[c];
%		kbscan->esc1 = 0;
%	} else if(kbscan->esc1){
% ...
%	case 5:
%		kbtabctrlesc1[scanc] = r;
%		break;
%	case 6:
%		kbtabshiftesc1[scanc] = r;
%		break;
%	}
% ...
%	case 5:
%		*r = kbtabctrlesc1[*sc];
%		return 1;
%	case 6:
%		*r = kbtabshiftesc1[*sc];
%		return 1;



<<portkbd.c>>=
/*
 * keyboard input // the portable part
 */
<<kernel basic includes>>

// The main entry point in this file is kbdputsc() called
// from devkbin.c when a process (e.g., usbd) writes into /dev/kbin.

// The functions kbdputmap/kbdgetmap are also portable functions called
// from devkbmap.c

<<global kdebug>>

<<enum specialkey>>

<<global kbtab>>

<<global kbtabshift>>

<<global kbtabesc1>>

<<global kbtabaltgr>>

// see kbtab.c for the ctrl one, put in another file because
// of issues with TeX with the special characters it contain
// can't LPize it.
<<global kbtabctrl decl>>

<<global kbscans>>


// called when write in /dev/kbin (see devkbin.c)
<<function kbdputsc>>

// called when interact with /dev/kbmap (see devkbmap.c)
<<function kbdputmap>>

<<function kbdgetmap>>
@

\subsection*{[[devices/keyboard/latin1.c]]}


<<latin1.c>>=
<<kernel basic includes>>

/*
 * The code makes two assumptions: strlen(ld) is 1 or 2; latintab[i].ld can be a
 * prefix of latintab[j].ld only when j<i.
 */
struct cvlist
{
    char    *ld;        /* must be seen before using this conversion */
    char    *si;        /* options for last input characters */

    Rune    *so;        /* the corresponding Rune for each si entry */
};

struct cvlist latintab[] = {
#include "../port/latin1.h"
    0,  0,      0
};

/*
 * Given n characters k[0]..k[n-1], find the rune or return -1 for failure.
 */
long
unicode(Rune *k, int n)
{
    long c;
    Rune *r;

    c = 0;
    for(r = &k[1]; r<&k[n]; r++){       /* +1 to skip [Xx] */
        c <<= 4;
        if('0'<=*r && *r<='9')
            c += *r-'0';
        else if('a'<=*r && *r<='f')
            c += 10 + *r-'a';
        else if('A'<=*r && *r<='F')
            c += 10 + *r-'A';
        else
            return -1;
    }
    return c;
}

/*
 * Given n characters k[0]..k[n-1], find the corresponding rune or return -1 for
 * failure, or something < -1 if n is too small.  In the latter case, the result
 * is minus the required n.
 */
long
latin1(Rune* k, int n)
{
    struct cvlist *l;
    char c;
    char* p;

//    print("latin1: %d, %d\n", n, k[n-1]);

    if(k[0] == 'X')
        if(n>=5)
            return unicode(k, 5);
        else
            return -5;
    if(k[0] == 'x')
        if(n>=UTFmax*2+1)
            return unicode(k, UTFmax*2+1);
        else
            return -(UTFmax+1);

    for(l=latintab; l->ld!=0; l++)
        if(k[0] == l->ld[0]){
//          print("found: %s, %s\n", l->ld, l->si);
            if(n == 1)
                return -2;
            if(l->ld[1] == 0)
                c = k[1];
            else if(l->ld[1] != k[1])
                continue;
            else if(n == 2)
                return -3;
            else
                c = k[2];
            for(p=l->si; *p!=0; p++)
                if(*p == c) {
                    print("found: 0x%x\n", l->so[p - l->si]);
                    return l->so[p - l->si];
                }
            return -1;
        }
    return -1;
}
@


\subsection*{[[devices/keyboard/latin1.h]]}


\subsection*{[[devices/keyboard/devkbin.c]]}

<<devkbin.c>>=
/*
 *  keyboard scan code input from outside the kernel.
 *  to avoid duplication of keyboard map processing for usb.
 */

#include	"u.h"
#include	"../port/lib.h"
#include	"../port/error.h"
#include	"mem.h"
#include	"dat.h"
#include	"fns.h"

enum {
 Qdir,
 Qkbd,
};

Dirtab kbintab[] = {
 ".",	{Qdir, 0, QTDIR},	0,	0555,
 "kbin",	{Qkbd, 0},		0,	0200,
};

Lock	kbinlck;
int	kbinbusy;

static Chan *
kbinattach(char *spec)
{
 return devattach(L'Ι', spec);
}

static Walkqid*
kbinwalk(Chan *c, Chan *nc, char **name, int nname)
{
 return devwalk(c, nc, name, nname, kbintab, nelem(kbintab), devgen);
}

static int
kbinstat(Chan *c, uchar *dp, int n)
{
 return devstat(c, dp, n, kbintab, nelem(kbintab), devgen);
}

static Chan*
kbinopen(Chan *c, int omode)
{
 if(!iseve())
  error(Eperm);
 if(c->qid.path == Qkbd){
  lock(&kbinlck);
  if(kbinbusy){
   unlock(&kbinlck);
   error(Einuse);
  }
  kbinbusy++;
  unlock(&kbinlck);
 }
 return devopen(c, omode, kbintab, nelem(kbintab), devgen);
}

static void
kbinclose(Chan *c)
{
 if(c->aux){
  free(c->aux);
  c->aux = nil;
 }
 if(c->qid.path == Qkbd)
  kbinbusy = 0;
}

static long
kbinread(Chan *c, void *a, long n, vlong )
{
 if(c->qid.type == QTDIR)
  return devdirread(c, a, n, kbintab, nelem(kbintab), devgen);
 return 0;
}

static long
kbinwrite(Chan *c, void *a, long n, vlong)
{
 int i;
 uchar *p = a;

 if(c->qid.type == QTDIR)
  error(Eisdir);
 switch((int)c->qid.path){
 case Qkbd:
  for(i = 0; i < n; i++)
            // !! important call !!
   kbdputsc(*p++, 1);	/* external source */
  break;
 default:
  error(Egreg);
 }
 return n;
}

Dev kbindevtab = {
 .dc = L'Ι',
 .name = "kbin",

 .reset = devreset,
 .init = devinit,
 .shutdown = devshutdown,
 .attach = kbinattach,
 .walk = kbinwalk,
 .stat = kbinstat,
 .open = kbinopen,
 .create = devcreate,
 .close = kbinclose,
 .read = kbinread,
 .bread = devbread,
 .write = kbinwrite,
 .bwrite = devbwrite,
 .remove = devremove,
 .wstat = devwstat,
};
@

\subsection*{[[devices/keyboard/devkbmap.c]]}


<<devkbmap.c>>=
/*
 *  keyboard map
 */

#include	"u.h"
#include	"../port/lib.h"
#include	"../port/error.h"
#include	"mem.h"
#include	"dat.h"
#include	"fns.h"

enum{
 Qdir,
 Qdata,
};
Dirtab kbmaptab[]={
 ".",		{Qdir, 0, QTDIR},	0,	0555,
 "kbmap",	{Qdata, 0},		0,	0600,
};
#define	NKBFILE	sizeof(kbmaptab)/sizeof(kbmaptab[0])

#define	KBLINELEN	(3*NUMSIZE+1)	/* t code val\n */

static Chan *
kbmapattach(char *spec)
{
 return devattach(L'κ', spec);
}

static Walkqid*
kbmapwalk(Chan *c, Chan *nc, char **name, int nname)
{
 return devwalk(c, nc, name, nname, kbmaptab, NKBFILE, devgen);
}

static int
kbmapstat(Chan *c, uchar *dp, int n)
{
 return devstat(c, dp, n, kbmaptab, NKBFILE, devgen);
}

static Chan*
kbmapopen(Chan *c, int omode)
{
 if(!iseve())
  error(Eperm);
 return devopen(c, omode, kbmaptab, NKBFILE, devgen);
}

static void
kbmapclose(Chan *c)
{
 if(c->aux){
  free(c->aux);
  c->aux = nil;
 }
}

static long
kbmapread(Chan *c, void *a, long n, vlong offset)
{
 char *bp;
 char tmp[KBLINELEN+1];
 int t, sc;
 Rune r;

 if(c->qid.type == QTDIR)
  return devdirread(c, a, n, kbmaptab, NKBFILE, devgen);

 switch((int)(c->qid.path)){
 case Qdata:
  if(kbdgetmap(offset/KBLINELEN, &t, &sc, &r)) {
   bp = tmp;
   bp += readnum(0, bp, NUMSIZE, t, NUMSIZE);
   bp += readnum(0, bp, NUMSIZE, sc, NUMSIZE);
   bp += readnum(0, bp, NUMSIZE, r, NUMSIZE);
   *bp++ = '\n';
   *bp = 0;
   n = readstr(offset%KBLINELEN, a, n, tmp);
  } else
   n = 0;
  break;
 default:
  n=0;
  break;
 }
 return n;
}

static long
kbmapwrite(Chan *c, void *a, long n, vlong)
{
 char line[100], *lp, *b;
 int key, m, l;
 Rune r;

 if(c->qid.type == QTDIR)
  error(Eperm);

 switch((int)(c->qid.path)){
 case Qdata:
  b = a;
  l = n;
  lp = line;
  if(c->aux){
   strcpy(line, c->aux);
   lp = line+strlen(line);
   free(c->aux);
   c->aux = nil;
  }
  while(--l >= 0) {
   *lp++  = *b++;
   if(lp[-1] == '\n' || lp == &line[sizeof(line)-1]) {
    *lp = 0;
    if(*line == 0)
     error(Ebadarg);
    if(*line == '\n' || *line == '#'){
     lp = line;
     continue;
    }
    lp = line;
    while(*lp == ' ' || *lp == '\t')
     lp++;
    m = strtoul(line, &lp, 0);
    key = strtoul(lp, &lp, 0);
    while(*lp == ' ' || *lp == '\t')
     lp++;
    r = 0;
    if(*lp == '\'' && lp[1])
     chartorune(&r, lp+1);
    else if(*lp == '^' && lp[1]){
     chartorune(&r, lp+1);
     if(0x40 <= r && r < 0x60)
      r -= 0x40;
     else
      error(Ebadarg);
    }else if(*lp == 'M' && ('1' <= lp[1] && lp[1] <= '5'))
     r = 0xF900+lp[1]-'0';
    else if(*lp>='0' && *lp<='9') /* includes 0x... */
     r = strtoul(lp, &lp, 0);
    else
     error(Ebadarg);
    kbdputmap(m, key, r);
    lp = line;
   }
  }
  if(lp != line){
   l = lp-line;
   c->aux = lp = smalloc(l+1);
   memmove(lp, line, l);
   lp[l] = 0;
  }
  break;
 default:
  error(Ebadusefd);
 }
 return n;
}

Dev kbmapdevtab = {
 .dc = L'κ',
 .name = "kbmap",

 .reset = devreset,
 .init = devinit,
 .shutdown = devshutdown,
 .attach = kbmapattach,
 .walk = kbmapwalk,
 .stat = kbmapstat,
 .open = kbmapopen,
 .create = devcreate,
 .close = kbmapclose,
 .read = kbmapread,
 .bread = devbread,
 .write = kbmapwrite,
 .bwrite = devbwrite,
 .remove = devremove,
 .wstat = devwstat,
};
@

\subsection*{[[devices/mouse/portmouse.c]]}
%pad: I added this file and factorize stuff from <arch>/mouse.c

<<portmouse.c>>=
<<kernel basic includes>>

// enum<MouseType>
int mousetype;

int packetsize;
static int resolution;
static int accelerated;

bool mousehwaccel;
bool intellimouse;

static QLock mousectlqlock;

// for serial mouse
//static char mouseport[5];

enum
{
    CMaccelerated,
    CMhwaccel,
    CMintellimouse,
    CMlinear,
    CMps2,
    CMps2intellimouse,
    CMres,
    CMreset,
    CMserial,
};

static Cmdtab mousectlmsg[] =
{
    CMaccelerated     , "accelerated"     , 0 ,
    CMhwaccel         , "hwaccel"         , 2 ,
    CMintellimouse    , "intellimouse"    , 1 ,
    CMlinear          , "linear"          , 1 ,
    CMps2             , "ps2"             , 1 ,
    CMps2intellimouse , "ps2intellimouse" , 1 ,
    CMres             , "res"             , 0 ,
    CMreset           , "reset"           , 1 ,
    CMserial          , "serial"          , 0 ,
};


/*
 *  set up a ps2 mouse
 */
static void
ps2mouse(void)
{
    if(mousetype == MousePS2)
        return;
    arch_ps2mouse();

    mousetype = MousePS2;
    packetsize = 3;
    mousehwaccel = 1;
}

/*
 * The PS/2 Trackpoint multiplexor on the IBM Thinkpad T23 ignores
 * acceleration commands.  It is supposed to pass them on
 * to the attached device, but my Logitech mouse is simply
 * not behaving any differently.  For such devices, we allow
 * the user to use "hwaccel off" to tell us to back off to
 * software acceleration even if we're using the PS/2 port.
 * (Serial mice are always software accelerated.)
 * For more information on the Thinkpad multiplexor, see
 * http://wwwcssrv.almaden.ibm.com/trackpoint/
 */
static void
setaccelerated(int x)
{
    accelerated = x;
    arch_setaccelerated();
    // call in devmouse.c
    mouseaccelerate(x);
}

static void
setlinear(void)
{
    accelerated = 0;
    arch_setlinear();
    mouseaccelerate(0);
}

static void
setres(int n)
{
    resolution = n;
    arch_setres(n);
}

static void
setintellimouse(void)
{
    intellimouse = 1;
    packetsize = 4;
    arch_setintellimouse();
}

static void
resetmouse(void)
{
    packetsize = 3;
    arch_resetmouse();
}

void
kmousectl(Cmdbuf *cb)
{
    Cmdtab *ct;

    qlock(&mousectlqlock);
    if(waserror()){
        qunlock(&mousectlqlock);
        nexterror();
    }

    ct = lookupcmd(cb, mousectlmsg, nelem(mousectlmsg));
    switch(ct->index){
    case CMaccelerated:
        setaccelerated(cb->nf == 1 ? 1: atoi(cb->f[1]));
        break;
    case CMlinear:
        setlinear();
        break;
    case CMps2:
        intellimouse = 0;
        ps2mouse();
        break;
    case CMres:
        if(cb->nf >= 2)
            setres(atoi(cb->f[1]));
        else
            setres(1);
        break;
    case CMreset:
        resetmouse();
        if(accelerated)
            setaccelerated(accelerated);
        if(resolution)
            setres(resolution);
        if(intellimouse)
            setintellimouse();
        break;
    case CMhwaccel:
        if(strcmp(cb->f[1], "on")==0)
            mousehwaccel = 1;
        else if(strcmp(cb->f[1], "off")==0)
            mousehwaccel = 0;
        else
            cmderror(cb, "bad mouse control message");
        break;
    case CMintellimouse:
        setintellimouse();
        break;
    case CMps2intellimouse:
        ps2mouse();
        setintellimouse();
        break;
    case CMserial:
        //if(mousetype == Mouseserial)
        //  error(Emouseset);
        //
        //if(cb->nf > 2){
        //  if(strcmp(cb->f[2], "M") == 0)
        //      i8250mouse(cb->f[1], m3mouseputc, 0);
        //  else if(strcmp(cb->f[2], "MI") == 0)
        //      i8250mouse(cb->f[1], m5mouseputc, 0);
        //  else
        //      i8250mouse(cb->f[1], mouseputc, cb->nf == 1);
        //} else
        //  i8250mouse(cb->f[1], mouseputc, cb->nf == 1);
        //
        //mousetype = Mouseserial;
        //strncpy(mouseport, cb->f[1], sizeof(mouseport)-1);
        //packetsize = 3;
        error("serial mice not supported anymore");
        break;
    }
    qunlock(&mousectlqlock);
    poperror();
}

@
%old: MouseSerial but unused
%old: mousectl -> kmousectl

\subsection*{[[devices/mouse/devmouse.c]]}

<<devmouse.c>>=
<<kernel basic includes>>

#include    <draw.h>
#include    <draw_private.h> // for BPLONG
#include    <memdraw.h>
#include    <cursor.h>

#include    "../port/portscreen.h"

enum {
    ScrollUp = 0x08,
    ScrollDown = 0x10,
    ScrollLeft = 0x20,
    ScrollRight = 0x40,
};

typedef struct Mouseinfo    Mouseinfo;
typedef struct Mousestate   Mousestate;

struct Mousestate
{
    Point   xy;     /* mouse.xy */
    int buttons;    /* mouse.buttons */
    ulong   counter;    /* increments every update */
    ulong   msec;       /* time of last event */
};

struct Mouseinfo
{
    Lock;
    Mousestate;
    int dx;
    int dy;
    bool track;      /* dx & dy updated */
    bool redraw;     /* update cursor on screen */
    ulong   lastcounter;    /* value when /dev/mouse read */
    ulong   lastresize;
    ulong   resize;
    Rendez  r;
    Ref;
    QLock;
    bool open;
    int acceleration;
    int maxacc;
    Mousestate  queue[16];  /* circular buffer of click events */
    int ri;     /* read index into queue */
    int wi;     /* write index into queue */
    uchar   qfull;      /* queue is full */
};

Mouseinfo   mouse;


Cursorinfo  cursor;
Cursor      curs;


// set to mousefromkbd here in mouseinit(), but used outside devmouse.c
// to let know devmouse.c about some keyboard events related to the mouse
void    (*kbdmouse)(int);
int     kbdbuttons;

// not used in this file
bool     mouseshifted;


enum{
    Qdir,
    Qcursor,
    Qmouse,
    Qmousein,
    Qmousectl,
};

static Dirtab mousedir[]={
    ".",    {Qdir, 0, QTDIR},   0,          DMDIR|0555,
    "cursor",   {Qcursor},  0,          0666,
    "mouse",    {Qmouse},   0,          0666,
    "mousein",  {Qmousein}, 0,          0220,
    "mousectl", {Qmousectl},    0,          0220,
};

enum
{
    CMbuttonmap,
    CMscrollswap,
    CMswap,
    CMwildcard,
};

static Cmdtab mousectlmsg[] =
{
    CMbuttonmap,    "buttonmap",    0,
    CMscrollswap,   "scrollswap",   0,
    CMswap,     "swap",     1,
    CMwildcard, "*",        0,
};
// for CMwildcard, devmouse.c relies on arch defined kmousectl()



static uchar buttonmap[8] = {
    0, 1, 2, 3, 4, 5, 6, 7,
};
static bool mouseswap;
static bool scrollswap;
static ulong mousetime;



void Cursortocursor(Cursor*);
int mousechanged(void*);
static void mouseclock(void);




static void
mousereset(void)
{
    curs = arch_arrow;
    Cursortocursor(&arch_arrow);
    /* redraw cursor about 30 times per second */
    addclock0link(mouseclock, 33);
}

static void
mousefromkbd(int buttons)
{
    kbdbuttons = buttons;
    mousetrack(0, 0, 0, TK2MS(CPUS(0)->ticks));
}

static int
mousedevgen(Chan *c, char *name, Dirtab *tab, int ntab, int i, DirEntry *dp)
{
    int rc;

    rc = devgen(c, name, tab, ntab, i, dp);
    if(rc != -1)
        dp->atime = mousetime;
    return rc;
}

static void
mouseinit(void)
{
    curs = arch_arrow;
    Cursortocursor(&arch_arrow);
    arch_cursoron(true);
    kbdmouse = mousefromkbd;
    mousetime = seconds();
}

static Chan*
mouseattach(char *spec)
{
    return devattach('m', spec);
}

static Walkqid*
mousewalk(Chan *c, Chan *nc, char **name, int nname)
{
    Walkqid *wq;

    /*
     * We use devgen() and not mousedevgen() here
     * see "Ugly problem" in dev.c/devwalk()
     */
    wq = devwalk(c, nc, name, nname, mousedir, nelem(mousedir), devgen);
    if(wq != nil && wq->clone != c && wq->clone != nil && (wq->clone->qid.type&QTDIR)==0)
        incref(&mouse);
    return wq;
}

static int
mousestat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, mousedir, nelem(mousedir), mousedevgen);
}

static Chan*
mouseopen(Chan *c, int omode)
{
    switch((ulong)c->qid.path){
    case Qdir:
        if(omode != OREAD)
            error(Eperm);
        break;
    case Qmouse:
        lock(&mouse);
        if(mouse.open){
            unlock(&mouse);
            error(Einuse);
        }
        mouse.open = true;
        mouse.ref++;
        mouse.lastresize = mouse.resize;
        unlock(&mouse);
        break;
    case Qmousein:
        if(!iseve())
            error(Eperm);
        break;
    default:
        incref(&mouse);
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    return c;
}

static void
mousecreate(Chan*, char*, int, ulong)
{
    error(Eperm);
}

static void
mouseclose(Chan *c)
{
    if((c->qid.type&QTDIR)==0 && (c->flag&COPEN)){
        if(c->qid.path == Qmousein)
            return;
        lock(&mouse);
        if(c->qid.path == Qmouse)
            mouse.open = false;
        if(--mouse.ref == 0){
            arch_cursoroff(true);
            curs = arch_arrow;
            Cursortocursor(&arch_arrow);
            arch_cursoron(true);
        }
        unlock(&mouse);
    }
}


static long
mouseread(Chan *c, void *va, long n, vlong off)
{
    char buf[1+4*12+1];
    uchar *p;
    static int map[8] = {0, 4, 2, 6, 1, 5, 3, 7 };
    ulong offset = off;
    Mousestate m;
    int b;

    p = va;
    switch((ulong)c->qid.path){
    case Qdir:
        return devdirread(c, va, n, mousedir, nelem(mousedir), mousedevgen);

    case Qcursor:
        if(offset != 0)
            return 0;
        if(n < 2*4+2*2*16)
            error(Eshort);
        n = 2*4+2*2*16;
        lock(&cursor);
        BPLONG(p+0, curs.offset.x);
        BPLONG(p+4, curs.offset.y);
        memmove(p+8, curs.clr, 2*16);
        memmove(p+40, curs.set, 2*16);
        unlock(&cursor);
        return n;

    case Qmouse:
        while(mousechanged(nil) == 0)
            sleep(&mouse.r, mousechanged, nil);

        mouse.qfull = 0;
        mousetime = seconds();

        /*
         * No lock of the indices is necessary here, because ri is only
         * updated by us, and there is only one mouse reader
         * at a time.  I suppose that more than one process
         * could try to read the fd at one time, but such behavior
         * is degenerate and already violates the calling
         * conventions for sleep above.
         */
        if(mouse.ri != mouse.wi) {
            m = mouse.queue[mouse.ri];
            if(++mouse.ri == nelem(mouse.queue))
                mouse.ri = 0;
        } else {
            while(!canlock(&cursor))
                tsleep(&up->sleepr, returnfalse, 0, TK2MS(1));

            m = mouse.Mousestate;
            unlock(&cursor);
        }

        b = buttonmap[m.buttons&7];
        /* put buttons 4 and 5 back in */
        b |= m.buttons & (3<<3);
        if (scrollswap)
            if (b == 8)
                b = 16;
            else if (b == 16)
                b = 8;
        snprint(buf, sizeof buf, "m%11d %11d %11d %11lud ",
            m.xy.x, m.xy.y,
            b,
            m.msec);
        mouse.lastcounter = m.counter;
        if(n > 1+4*12)
            n = 1+4*12;
        if(mouse.lastresize != mouse.resize){
            mouse.lastresize = mouse.resize;
            buf[0] = 'r';
        }
        memmove(va, buf, n);
        return n;
    }
    return 0;
}

static void
setbuttonmap(char* map)
{
    int i, x, one, two, three;

    one = two = three = 0;
    for(i = 0; i < 3; i++){
        if(map[i] == 0)
            error(Ebadarg);
        if(map[i] == '1'){
            if(one)
                error(Ebadarg);
            one = 1<<i;
        }
        else if(map[i] == '2'){
            if(two)
                error(Ebadarg);
            two = 1<<i;
        }
        else if(map[i] == '3'){
            if(three)
                error(Ebadarg);
            three = 1<<i;
        }
        else
            error(Ebadarg);
    }
    if(map[i])
        error(Ebadarg);

    memset(buttonmap, 0, 8);
    for(i = 0; i < 8; i++){
        x = 0;
        if(i & 1)
            x |= one;
        if(i & 2)
            x |= two;
        if(i & 4)
            x |= three;
        buttonmap[x] = i;
    }
}

static long
mousewrite(Chan *c, void *va, long n, vlong)
{
    char *p;
    Point pt;
    Cmdbuf *cb;
    Cmdtab *ct;
    char buf[64];
    int b, msec;

    p = va;
    switch((ulong)c->qid.path){
    case Qdir:
        error(Eisdir);

    case Qcursor:
        arch_cursoroff(true);
        if(n < 2*4+2*2*16){
            curs = arch_arrow;
            Cursortocursor(&arch_arrow);
        }else{
            n = 2*4+2*2*16;
            curs.offset.x = BGLONG(p+0);
            curs.offset.y = BGLONG(p+4);
            memmove(curs.clr, p+8, 2*16);
            memmove(curs.set, p+40, 2*16);
            Cursortocursor(&curs);
        }
        qlock(&mouse);
        mouse.redraw = true;
        mouseclock();
        qunlock(&mouse);
        arch_cursoron(true);
        return n;

    case Qmousectl:
        cb = parsecmd(va, n);
        if(waserror()){
            free(cb);
            nexterror();
        }

        ct = lookupcmd(cb, mousectlmsg, nelem(mousectlmsg));

        switch(ct->index){
        case CMswap:
            if(mouseswap)
                setbuttonmap("123");
            else
                setbuttonmap("321");
            mouseswap ^= true;
            break;

        case CMscrollswap:
            scrollswap ^= true;
            break;

        case CMbuttonmap:
            if(cb->nf == 1)
                setbuttonmap("123");
            else
                setbuttonmap(cb->f[1]);
            break;

        case CMwildcard:
            kmousectl(cb); // device specific hook
            break;
        }

        free(cb);
        poperror();
        return n;

    case Qmousein:
        if(n > sizeof buf-1)
            n = sizeof buf -1;
        memmove(buf, va, n);
        buf[n] = 0;
        p = 0;
        pt.x = strtol(buf+1, &p, 0);
        if(p == 0)
            error(Eshort);
        pt.y = strtol(p, &p, 0);
        if(p == 0)
            error(Eshort);
        b = strtol(p, &p, 0);
        msec = strtol(p, &p, 0);
        if(msec == 0)
            msec = TK2MS(CPUS(0)->ticks);
        mousetrack(pt.x, pt.y, b, msec);
        return n;

    case Qmouse:
        if(n > sizeof buf-1)
            n = sizeof buf -1;
        memmove(buf, va, n);
        buf[n] = 0;
        p = 0;
        pt.x = strtoul(buf+1, &p, 0);
        if(p == 0)
            error(Eshort);
        pt.y = strtoul(p, 0, 0);
        qlock(&mouse);
        if(ptinrect(pt, gscreen->r)){
            mouse.xy = pt;
            mouse.redraw = true;
            mouse.track = true;
            mouseclock();
        }
        qunlock(&mouse);
        return n;
    }

    error(Egreg);
    return -1;
}

Dev mousedevtab = {
    .dc       =    'm',
    .name     =    "mouse",
               
    .reset    =    mousereset,
    .init     =    mouseinit,
    .shutdown =    devshutdown,
    .attach   =    mouseattach,
    .walk     =    mousewalk,
    .stat     =    mousestat,
    .open     =    mouseopen,
    .create   =    mousecreate,
    .close    =    mouseclose,
    .read     =    mouseread,
    .bread    =    devbread,
    .write    =    mousewrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};

void
Cursortocursor(Cursor *c)
{
    lock(&cursor);
    memmove(&cursor.Cursor, c, sizeof(Cursor));
    arch_ksetcursor(c);
    unlock(&cursor);
}


/*
 *  called by the clock routine to redraw the cursor
 */
static void
mouseclock(void)
{
    if(mouse.track){
        mousetrack(mouse.dx, mouse.dy, mouse.buttons, TK2MS(CPUS(0)->ticks));
        mouse.track = false;
        mouse.dx = 0;
        mouse.dy = 0;
    }
    if(mouse.redraw && canlock(&cursor)){
        mouse.redraw = false;
        arch_cursoroff(false);
        mouse.redraw = arch_cursoron(false);
        unlock(&cursor);
    }
    drawactive(false);
}

static int
scale(int x)
{
    int sign = 1;

    if(x < 0){
        sign = -1;
        x = -x;
    }
    switch(x){
    case 0:
    case 1:
    case 2:
    case 3:
        break;
    case 4:
        x = 6 + (mouse.acceleration>>2);
        break;
    case 5:
        x = 9 + (mouse.acceleration>>1);
        break;
    default:
        x *= mouse.maxacc;
        break;
    }
    return sign*x;
}

/*
 *  called at interrupt level to update the structure and
 *  awaken any waiting procs.
 */
void
mousetrack(int dx, int dy, int b, int msec)
{
    int x, y, lastb;

    if(gscreen==nil)
        return;

    if(mouse.acceleration){
        dx = scale(dx);
        dy = scale(dy);
    }
    x = mouse.xy.x + dx;
    if(x < gscreen->clipr.min.x)
        x = gscreen->clipr.min.x;
    if(x >= gscreen->clipr.max.x)
        x = gscreen->clipr.max.x;
    y = mouse.xy.y + dy;
    if(y < gscreen->clipr.min.y)
        y = gscreen->clipr.min.y;
    if(y >= gscreen->clipr.max.y)
        y = gscreen->clipr.max.y;

    lastb = mouse.buttons;
    mouse.xy = Pt(x, y);
    mouse.buttons = b|kbdbuttons;
    mouse.redraw = true;
    mouse.counter++;
    mouse.msec = msec;

    /*
     * if the queue fills, we discard the entire queue and don't
     * queue any more events until a reader polls the mouse.
     */
    if(!mouse.qfull && lastb != b) {    /* add to ring */
        mouse.queue[mouse.wi] = mouse.Mousestate;
        if(++mouse.wi == nelem(mouse.queue))
            mouse.wi = 0;
        if(mouse.wi == mouse.ri)
            mouse.qfull = 1;
    }
    wakeup(&mouse.r);
    drawactive(true);
}

int
mousechanged(void*)
{
    return mouse.lastcounter != mouse.counter ||
        mouse.lastresize != mouse.resize;
}

// called from outside devmouse.c
Point
mousexy(void)
{
    return mouse.xy;
}

// called from outside devmouse.c to let know devmouse.c of changes
void
mouseaccelerate(int x)
{
    mouse.acceleration = x;
    if(mouse.acceleration < 3)
        mouse.maxacc = 2;
    else
        mouse.maxacc = mouse.acceleration;
}

// called from outside devmouse.c to let know devmouse.c of changes
/*
 * notify reader that screen has been resized
 */
void
mouseresize(void)
{
    mouse.resize++;
    wakeup(&mouse.r);
}

@

\subsection*{[[devices/sys/devroot.c]]}

\ifallcode
<<devroot.c forward decl>>=
typedef struct Dirlist Dirlist;
@
\fi

<<method rootclose>>=
/*
 * sysremove() knows this is a nop
 */
static void
rootclose(Chan*)
{
}
@



<<devroot.c>>=
<<kernel basic includes>>

//*****************************************************************************
// Constants and types
//*****************************************************************************

<<devroot enum Qxxx>>

<<devroot.c forward decl>>
<<struct Dirlist>>

//*****************************************************************************
// Root
//*****************************************************************************

// note: directories have by convention 0 length

<<globals rootdir, rootdata, rootlist>>

//*****************************************************************************
// Boot
//*****************************************************************************

<<globals bootdir, bootdata, bootlist>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<function addlist>>

<<function addbootfile>>

<<function addrootdir>>

<<method rootreset>>

static Chan*
rootattach(char *spec)
{
    return devattach('/', spec);
}

<<function rootgen>>

static Walkqid*
rootwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c,  nc, name, nname, nil, 0, rootgen);
}

static int
rootstat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, nil, 0, rootgen);
}

static Chan*
rootopen(Chan *c, int omode)
{
    return devopen(c, omode, nil, 0, devgen);
}

<<method rootclose>>

<<method rootread>>

static long
rootwrite(Chan*, void*, long, vlong)
{
    error(Egreg);
    return 0;
}

<<global rootdevtab>>

@


\subsection*{[[devices/sys/devsys.c]]}

<<method syswalk>>=
static Walkqid*
syswalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, sysdir, nelem(sysdir), devgen);
}
@


<<method sysstat>>=
static int
sysstat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, sysdir, nelem(sysdir), devgen);
}
@


<<method sysopen>>=
static Chan*
sysopen(Chan *c, int omode)
{
    c->aux = nil;
    c = devopen(c, omode, sysdir, nelem(sysdir), devgen);
    switch((ulong)c->qid.path){
    }
    return c;
}
@


<<method sysclose>>=
static void
sysclose(Chan *c)
{
    switch((ulong)c->qid.path){
    }
}
@



<<devsys.c>>=
<<kernel basic includes>>

#include    <authsrv.h>

<<devsys.c enum Qxxx>>

<<global sysdir>>

<<devsys.c decls and globals>>
<<global sysname>>

<<method sysinit>>

<<method sysattach>>

<<method syswalk>>

<<method sysstat>>

<<method sysopen>>

<<method sysclose>>

<<method sysread>>

<<method syswrite>>

<<global sysdevtab>>

@


\subsection*{[[devices/sys/devenv.c]]}

\ifallcode
<<devenv.c forward decl>>=
static Egrp *envgrp(Chan *c);
static bool envwriteable(Chan *c);
@
\fi




<<function envgrp>>=
static Egrp*
envgrp(Chan *c)
{
    if(c->aux == nil)
        return up->egrp;
    return c->aux;
}
@
%todo: use union instead of aux pointer

<<function envwriteable>>=
static bool
envwriteable(Chan *c)
{
    return iseve() || c->aux == nil;
}
@


<<function getconfenv>>=
/*
 * Return a copy of configuration environment as a sequence of strings.
 * The strings alternate between name and value.  A zero length name string
 * indicates the end of the list
 */
char *
getconfenv(void)
{
    Egrp *eg = &confegrp;
    Evalue *e;
    char *p, *q;
    int i, n;

    rlock(eg);
    if(waserror()) {
        runlock(eg);
        nexterror();
    }
    
    /* determine size */
    n = 0;
    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        n += strlen(e->name) + e->len + 2;
    }
    p = malloc(n + 1);
    if(p == nil)
        error(Enomem);
    q = p;
    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        strcpy(q, e->name);
        q += strlen(q) + 1;
        memmove(q, e->value, e->len);
        q[e->len] = 0;
        /* move up to the first null */
        q += strlen(q) + 1;
    }
    *q = 0;
    
    poperror();
    runlock(eg);
    return p;
}
@

%TODO: lp split

<<devenv.c>>=
<<kernel basic includes>>

enum
{
    Maxenvsize = 16300,
};

<<devenv.c forward decl>>

static Egrp confegrp;   /* global environment group containing the kernel configuration */

static Evalue*
envlookup(Egrp *eg, char *name, ulong qidpath)
{
    Evalue *e;
    int i;

    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        if(e->qid.path == qidpath || (name && e->name[0]==name[0] && strcmp(e->name, name) == 0))
            return e;
    }
    return nil;
}

static int
envgen(Chan *c, char *name, Dirtab*, int, int s, DirEntry *dp)
{
    Egrp *eg;
    Evalue *e;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, "#e", 0, eve, DMDIR|0775, dp);
        return 1;
    }

    eg = envgrp(c);
    rlock(eg);
    e = nil;
    if(name)
        e = envlookup(eg, name, -1);
    else if(s < eg->nent)
        e = eg->ent[s];

    if(e == nil) {
        runlock(eg);
        return -1;
    }

    /* make sure name string continues to exist after we release lock */
    kstrcpy(up->genbuf, e->name, sizeof up->genbuf);
    devdir(c, e->qid, up->genbuf, e->len, eve, 0666, dp);
    runlock(eg);
    return 1;
}

static Chan*
envattach(char *spec)
{
    Chan *c;
    Egrp *egrp = nil;

    if(spec && *spec) {
        if(strcmp(spec, "c") == 0)
            egrp = &confegrp;
        if(egrp == nil)
            error(Ebadarg);
    }

    c = devattach('e', spec);
    c->aux = egrp;
    return c;
}

static Walkqid*
envwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, envgen);
}

static int
envstat(Chan *c, uchar *db, int n)
{
    if(c->qid.type & QTDIR)
        c->qid.vers = envgrp(c)->vers;
    return devstat(c, db, n, 0, 0, envgen);
}

static Chan*
envopen(Chan *c, int omode)
{
    Egrp *eg;
    Evalue *e;
    bool trunc;

    eg = envgrp(c);
    if(c->qid.type & QTDIR) {
        if(omode != OREAD)
            error(Eperm);
    }
    else {
        trunc = omode & OTRUNC;
        if(omode != OREAD && !envwriteable(c))
            error(Eperm);
        if(trunc)
            wlock(eg);
        else
            rlock(eg);
        e = envlookup(eg, nil, c->qid.path);
        if(e == nil) {
            if(trunc)
                wunlock(eg);
            else
                runlock(eg);
            error(Enonexist);
        }
        if(trunc && e->value) {
            e->qid.vers++;
            free(e->value);
            e->value = nil;
            e->len = 0;
        }
        if(trunc)
            wunlock(eg);
        else
            runlock(eg);
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    return c;
}

static void
envcreate(Chan *c, char *name, int omode, ulong)
{
    Egrp *eg;
    Evalue *e;
    Evalue **ent;

    if(c->qid.type != QTDIR)
        error(Eperm);
    if(strlen(name) >= sizeof up->genbuf)
        error("name too long");         /* protect envgen */

    omode = openmode(omode);
    eg = envgrp(c);

    wlock(eg);
    if(waserror()) {
        wunlock(eg);
        nexterror();
    }

    if(envlookup(eg, name, -1))
        error(Eexist);

    e = smalloc(sizeof(Evalue));
    e->name = smalloc(strlen(name)+1);
    strcpy(e->name, name);

    // realloc
    if(eg->nent == eg->ment){
        eg->ment += 32;
        ent = smalloc(sizeof(eg->ent[0])*eg->ment);
        if(eg->nent)
            memmove(ent, eg->ent, sizeof(eg->ent[0])*eg->nent);
        free(eg->ent);
        eg->ent = ent;
    }
    e->qid.path = ++eg->path;
    e->qid.vers = 0;
    eg->vers++;
    eg->ent[eg->nent++] = e;
    c->qid = e->qid;

    wunlock(eg);
    poperror();

    c->offset = 0;
    c->mode = omode;
    c->flag |= COPEN;
}

static void
envremove(Chan *c)
{
    int i;
    Egrp *eg;
    Evalue *e;

    if(c->qid.type & QTDIR)
        error(Eperm);

    eg = envgrp(c);
    wlock(eg);
    e = nil;
    for(i=0; i<eg->nent; i++){
        if(eg->ent[i]->qid.path == c->qid.path){
            e = eg->ent[i];
            eg->nent--;
            eg->ent[i] = eg->ent[eg->nent];
            eg->vers++;
            break;
        }
    }
    wunlock(eg);
    if(e == nil)
        error(Enonexist);
    free(e->name);
    if(e->value)
        free(e->value);
    free(e);
}

static void
envclose(Chan *c)
{
    /*
     * cclose can't fail, so errors from remove will be ignored.
     * since permissions aren't checked,
     * envremove can't not remove it if its there.
     */
    if(c->flag & CRCLOSE)
        envremove(c);
}

static long
envread(Chan *c, void *a, long n, vlong off)
{
    Egrp *eg;
    Evalue *e;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, 0, 0, envgen);

    eg = envgrp(c);
    rlock(eg);
    e = envlookup(eg, nil, c->qid.path);
    if(e == nil) {
        runlock(eg);
        error(Enonexist);
    }

    if(offset > e->len) /* protects against overflow converting vlong to ulong */
        n = 0;
    else if(offset + n > e->len)
        n = e->len - offset;
    if(n <= 0)
        n = 0;
    else
        memmove(a, e->value+offset, n);
    runlock(eg);
    return n;
}

static long
envwrite(Chan *c, void *a, long n, vlong off)
{
    byte *s;
    ulong len;
    Egrp *eg;
    Evalue *e;
    ulong offset = off;

    if(n <= 0)
        return 0;
    if(offset > Maxenvsize || n > (Maxenvsize - offset))
        error(Etoobig);

    eg = envgrp(c);
    wlock(eg);
    e = envlookup(eg, nil, c->qid.path);
    if(e == nil) {
        wunlock(eg);
        error(Enonexist);
    }

    len = offset+n;
    if(len > e->len) {
        s = smalloc(len);
        if(e->value){
            memmove(s, e->value, e->len);
            free(e->value);
        }
        e->value = s;
        e->len = len;
    }
    memmove(e->value+offset, a, n);
    e->qid.vers++;
    eg->vers++;
    wunlock(eg);
    return n;
}

<<global envdevtab>>



<<function envcpy>>

<<function envgrp>>

<<function envwriteable>>

<<function ksetenv>>

<<function getconfenv>>
@

\subsection*{[[devices/sys/devpipe.c]]}

\ifallcode
<<devpipe.c forward decl>>=
typedef struct Pipe Pipe;
@
\fi


<<devpipe.c>>=
<<kernel basic includes>>

// need that??
#include    "netif.h"

<<devpipe.c forward decl>>

<<struct Pipe>>

<<struct Pipealloc>>

<<global pipealloc>>

<<devpipe.c enum Qxxx>>

<<global pipedir>>

#define NPIPEDIR 3

<<method pipeinit>>

<<method pipeattach>>

<<function pipegen>>

<<method pipewalk>>

<<method pipestat>>

<<method pipewstat>>

<<method pipeopen>>

<<method pipeclose>>

<<method piperead>>

<<method pipebread>>

<<method pipewrite>>

<<method pipebwrite>>

<<global pipedevtab>>
@


\subsection*{[[devices/sys/devproc.c]]}

\ifallcode
<<devproc.c forward decl>>=
void    procctlreq(Proc*, char*, int);
int procctlmemio(Proc*, ulong, int, void*, int);
Chan*   proctext(Chan*, Proc*);
Segment* text2data(Proc*, Segment*);
int procstopped(void*);
void    mntscan(Mntwalk*, Proc*);
@
\fi














<<devproc.c>>=
<<kernel basic includes>>

#include    <trace.h>
#include    <tos.h>
#include    <ureg.h>

<<struct Mntwalk>>

<<devproc.c enum Qxxx>>

<<devproc enum CMxxx>>

enum{
<<constant Nevents>>
<<constant Emask>>
};

#define STATSIZE    (2*KNAMELEN+12+9*12)
<<global procdir>>

<<global proccmd>>

/* Segment type from portdat.h */
<<global sname>>

<<devproc QXXX macros>>

<<devproc.c forward decl>>

<<global trace txxx>>

<<clock callback profclock>>

<<function procgen>>

<<function _proctrace>>

<<method procinit>>

static Chan*
procattach(char *spec)
{
    return devattach('p', spec);
}

static Walkqid*
procwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, procgen);
}

static int
procstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, procgen);
}

<<function nonone>>

<<method procopen>>

<<method procwstat>>

<<function procoffset>>

<<function procqidwidth>>

<<function procfdprint>>

<<function procfds>>

<<method procclose>>

<<function int2flag>>

<<function procargs>>

<<function eventsavailable>>

<<method procread>>

<<function mntscan>>

<<method procwrite>>

<<global procdevtab>>



<<function proctext>>

<<function procstopwait>>

<<function procctlcloseone>>

<<function procctlclosefiles>>

<<function parsetime>>

<<function procctlreq>>

<<function procstopped>>

<<function procctlmemio>>

<<function text2data>>
@


\section{[[files/]]}

\subsection*{[[files/portdat_files.h]]}

<<struct Extent>>=
struct Extent
{
  int bid;
  ulong start;
  int len;
  Page  *cache;
  Extent  *next;
};
@

<<struct Mntcache>>=
struct Mntcache
{
  Qid qid;
  int dev;
  int type;
  QLock;
  Extent   *list;
  Mntcache *hash;
  Mntcache *prev;
  Mntcache *next;
};
@




<<portdat_files.h>>=

<<enum blockflag>>

<<struct Block>>

<<function BLEN>>
<<function BALLOC>>


<<enum queuestate>>

// defined in qio.c
extern  uint  qiomaxatomic;

/*
 *  IO queues
 */
// was in qio.c
<<struct Queue>>


// was in cache.c
<<struct Extent>>

// was in cache.c
<<struct Mntcache>>


<<struct Mount>>

<<struct Mhead>>



#include <fcall.h>

// was in devmnt.c
<<struct Mntrpc>>

<<struct Mnt>>



<<struct Path>>

<<enum accessnamec>>

<<enum channelflag>>

<<struct Chan>>


<<struct Evalue>>

<<struct Egrp>>


// internals

<<struct Walkqid>>

<<struct Dev>>


// array<Dev>, it looks like an allocated array<ref<dev>> but
// it is really a static array put here to avoid backward deps on conf_devtab,
// and it is not really a <ref<dev>> because it's pointers to static
// structures (e.g. mousedevtab, vgadevtab, etc).
extern Dev** devtab;

<<struct Dirtab>>

// used by with devmnt.c and sysfile.c
struct Bogus {
    Chan    *chan;
    Chan    *authchan;
    char    *spec;
    int flags;
};


//*****************************************************************************
// Internal to files/
//*****************************************************************************

<<constants tags>>

// actually internal to devmnt.c and mnt.c
<<struct Mntalloc>>
extern struct Mntalloc mntalloc;
@


\subsection*{[[files/portfns_files.h]]}

\ifallcode
<<portfns_files.h>>=

// allocb.c
Block* allocb(int);
void   freeb(Block*);
Block* iallocb(int);
void   iallocsummary(void);
void   checkb(Block*, char*);

// cache.c
void   cinit(void);
void   copen(Chan*);
int    cread(Chan*, uchar*, int, vlong);
void   cwrite(Chan*, uchar*, int, vlong);
void   cupdate(Chan*, uchar*, int, vlong);

// qio.c
void   freeblist(Block*);
int    blocklen(Block*);
Queue* qopen(int, int, void (*)(void*), void*);
void   qhangup(Queue*, char*);
Block* qget(Queue*);
int    qdiscard(Queue*, int);
void   qreopen(Queue*);
Block* qremove(Queue*);
void   qputback(Queue*, Block*);
Block* packblock(Block*);
Queue* qbypass(void (*)(void*, Block*), void*);
int    pullblock(Block**, int);
Block* bl2mem(uchar*, Block*, int);
void   qnoblock(Queue*, bool);
int    qisclosed(Queue*);
int    qfull(Queue*);
int    qwindow(Queue*);
void   qsetlimit(Queue*, int);
int    qpass(Queue*, Block*);
void   qclose(Queue*);
int    qiwrite(Queue*, void*, int);
int    qproduce(Queue*, void*, int);
Block* padblock(Block*, int);
Block* pullupblock(Block*, int);
int    qpassnolim(Queue*, Block*);
Block* copyblock(Block*, int);
Block* qcopy(Queue*, int, ulong);
void   qflush(Queue*);
long   qbwrite(Queue*, Block*);
int    qconsume(Queue*, void*, int);
//Block*    mem2bl(uchar*, int);
Block* trimblock(Block*, int, int);
void   qaddlist(Queue*, Block*);
Block* concatblock(Block*);
void   ixsummary(void);
Block* pullupqueue(Queue*, int);
void   qfree(Queue*);
int    qwrite(Queue*, void*, int);
Block* adjustblock(Block*, int);
Block* qbread(Queue*, int);
long   qread(Queue*, void*, int);
int    qcanread(Queue*);
int    qlen(Queue*);

// chan.c
Chan*  cclone(Chan*);
void   putmhead(Mhead*);
int    eqchantdqid(Chan*, int, int, Qid, bool);
Mhead* newmhead(Chan*);
void   error_if_not_dir(Chan*);
char*  chanpath(Chan*);
int    emptystr(char*);
void   chandevinit(void);
void   chandevshutdown(void);
void   chandevreset(void);
int    eqqid(Qid, Qid);
int    cmount(Chan*, Chan*, int, char*);
void   cunmount(Chan*, Chan*);
bool   findmount(Chan**, Mhead**, int, int, Qid);
void   pathclose(Path*);
Path*  newpath(char*);
Chan*  newchan(void);
void   chanfree(Chan*);
//cchan_close => cclose
char*  validnamedup(char*, bool);
void   validname(char*, bool);
void   nameerror(char*, char*);
int    walk(Chan**, char**, int, int, int*);
void   ccloseq(Chan*);
Chan*  namec(char*, int, int, ulong);
//long    unionread(Chan*, void*, long);

// file.c
Chan*  fdtochan(int, int, bool, bool);
int    openmode(ulong);
void   fdclose(int, int);
void   validstat(uchar*, int);

// dev.c
void   mkqid(Qid*, vlong, ulong, int);
int    devno(Rune, bool);
void   devdir(Chan*, Qid, char*, vlong, char*, long, DirEntry*);
void   devinit(void);
void   devreset(void);
void   devshutdown(void);
Chan*  devclone(Chan*);
long   devdirread(Chan*, char*, long, Dirtab*, int, Devgen*);
void   devpermcheck(char*, ulong, int);
void   devcreate(Chan*, char*, int, ulong);
Block* devbread(Chan*, long, ulong);
long   devbwrite(Chan*, Block*, ulong);
void   devremove(Chan*);
int    devwstat(Chan*, uchar*, int);
#define DEVDOTDOT -1
Devgen    devgen;//TODO?
//void    devpower(int);
//int   devconfig(int, char *, DevConf *);//TODO? why fp no-deps?
int    devstat(Chan*, uchar*, int, Dirtab*, int, Devgen*);
Chan*  devopen(Chan*, int, Dirtab*, int, Devgen*);
Chan*  devattach(Rune, char*);
Walkqid* devwalk(Chan*, Chan*, char**, int, Dirtab*, int, Devgen*);

// env.c
void   closeegrp(Egrp*);

// mnt.c
void   muxclose(Mnt*);
void   mntfree(Mntrpc*);
//void    mntpntfree(Mnt*);

// sysfile.c
int    newfd(Chan*);
// many sysxxx functions (used in syscalls/ without requiring extern decl)
@
\fi

\subsection*{[[files/chan.c]]}

\ifallcode
<<chan.c forward decl>>=
char*       skipslash(char*);
void closeproc(void*);
typedef struct Elemlist Elemlist;
@
\fi

%PAD: still toggled by sysr1? not true
\ifallcode
<<chan.c debugging macro>>=
bool chandebug=false;        /* toggle it in sysnop if you want */
#define DBG if(chandebug)iprint
@ 
\fi


<<chan.c>>=
<<kernel basic includes>>

<<chan.c forward decl>>

<<chan.c debugging macro>>

enum
{
<<constant PATHSLOP>>
<<constant PATHMSLOP>>
};

<<struct Chanalloc>>
<<global chanalloc>>

<<struct Elemlist>>

<<function chanpath>>

<<function isdotdot>>

<<function emptystr>>

<<function chandevreset>>

<<function chandevinit>>

<<function chandevshutdown>>

<<constructor newchan>>

<<global npath>>

<<constructor newpath>>

<<function copypath>>

<<destructor pathclose>>

<<function fixdotdotname>>

<<function uniquepath>>

<<function addelem>>

<<destructor chanfree>>

<<function cclose>>

<<struct Clunkq>>
<<global clunkq>>

<<function ccloseq>>

<<function clunkwork>>

<<function closeproc>>

<<function uniquechan>>

<<function eqqid>>

<<function eqchan>>

<<function eqchantdqid>>

<<constructor newmhead>>

<<function cmount>>

<<function cunmount>>

<<function cclone>>

<<function findmount>>

<<function domount>>

<<function undomount>>

<<function ewalk>>

<<global Edoesnotexist>>

<<function walk>>

<<function createdir>>

<<function growparse>>

<<function parsename>>

<<function memrchr>>

<<function namelenerror>>

<<function nameerror>>

<<function namec>>

<<function skipslash>>

<<global isfrog>>

<<function validname0>>

<<function validname>>

<<function validnamedup>>

<<function error_if_not_dir>>

<<destructor putmhead>>

@


\subsection*{[[files/dev.c]]}

%<<[[Dev]] methods>>=
%int (*config)(int, char*, DevConf*);  /* returns nil on error */
%@
% dead?

<<dev.c>>=
<<kernel basic includes>>

// was in $CONF.c
<<global devtab>>

<<function mkqid>>

<<function devno>>

<<function devdir>>

<<function devgen>>

void
devreset(void)
{
}

void
devinit(void)
{
}

void
devshutdown(void)
{
}

<<function devattach>>

<<function devclone>>

<<function devwalk>>

<<function devstat>>

<<function devdirread>>

<<function devpermcheck>>

<<function devopen>>

void
devcreate(Chan*, char*, int, ulong)
{
    error(Eperm);
}

<<function devbread>>

<<function devbrwrite>>

void
devremove(Chan*)
{
    error(Eperm);
}

int
devwstat(Chan*, uchar*, int)
{
    error(Eperm);
    return 0;
}

//void
//devpower(int)
//{
//    error(Eperm);
//}
//
//int
//devconfig(int, char *, DevConf *)
//{
//    error(Eperm);
//    return 0;
//}
@
%$

\subsection*{[[files/allocb.c]]}

%todo: got some panic in _allocb when I set BLOCKALIGN to 64
% in bcm/pi


<<allocb.c>>=
<<kernel basic includes>>

enum
{
    Hdrspc      = 64,       /* leave room for high-level headers */
    Bdead       = 0x51494F42,   /* "QIOB" */
};

<<struct Ialloc>>
<<global ialloc>>

<<function _allocb>>

<<function allocb>>

<<function iallocb>>

<<function freeb>>

<<function checkb>>

<<function iallocsummary>>
@


\subsection*{[[files/env.c]]}

<<env.c>>=
<<kernel basic includes>>

// this used to be in devenv.c, but to avoid backward deps I've splitted
// this file in 2
<<function closeegrp>>
@


\subsection*{[[files/file.c]]}
%pad: I created this file

<<file.c>>=
<<kernel basic includes>>

<<function fdtochan>>

<<function openmode>>

<<function fdclose>>

<<function validstat>>

@


\subsection*{[[files/mnt.c]]}

<<enum channelflag cases>>=
CMSG  = 0x0002,   /* the message channel for a mount */
@

<<function mntversion>>=
/*
 * Version is not multiplexed: message sent only once per connection.
 */
long
mntversion(Chan *c, char *version, int msize, int returnlen)
{
    Fcall f;
    uchar *msg;
    Mnt *m;
    char *v;
    long k, l;
    uvlong oo;
    char buf[128];

    qlock(&c->umqlock); /* make sure no one else does this until we've established ourselves */
    if(waserror()){
        qunlock(&c->umqlock);
        nexterror();
    }

    /* defaults */
    if(msize == 0)
        msize = MAXRPC;
    if(msize > c->iounit && c->iounit != 0)
        msize = c->iounit;
    v = version;
    if(v == nil || v[0] == '\0')
        v = VERSION9P;

    /* validity */
    if(msize < 0)
        error("bad iounit in version call");
    if(strncmp(v, VERSION9P, strlen(VERSION9P)) != 0)
        error("bad 9P version specification");

    m = c->mux;

    if(m != nil){
        qunlock(&c->umqlock);
        poperror();

        strecpy(buf, buf+sizeof buf, m->version);
        k = strlen(buf);
        if(strncmp(buf, v, k) != 0){
            snprint(buf, sizeof buf, "incompatible 9P versions %s %s", m->version, v);
            error(buf);
        }
        if(returnlen > 0){
            if(returnlen < k)
                error(Eshort);
            memmove(version, buf, k);
        }
        return k;
    }

    f.type = Tversion;
    f.tag = NOTAG;
    f.msize = msize;
    f.version = v;
    msg = malloc(8192+IOHDRSZ);
    if(msg == nil)
        exhausted("version memory");
    if(waserror()){
        free(msg);
        nexterror();
    }
    k = convS2M(&f, msg, 8192+IOHDRSZ);
    if(k == 0)
        error("bad fversion conversion on send");

    lock(c);
    oo = c->offset;
    c->offset += k;
    unlock(c);

    l = devtab[c->type]->write(c, msg, k, oo);

    if(l < k){
        lock(c);
        c->offset -= k - l;
        unlock(c);
        error("short write in fversion");
    }

    /* message sent; receive and decode reply */
    k = devtab[c->type]->read(c, msg, 8192+IOHDRSZ, c->offset);
    if(k <= 0)
        error("EOF receiving fversion reply");

    lock(c);
    c->offset += k;
    unlock(c);

    l = convM2S(msg, k, &f);
    if(l != k)
        error("bad fversion conversion on reply");
    if(f.type != Rversion){
        if(f.type == Rerror)
            error(f.ename);
        error("unexpected reply type in fversion");
    }
    if(f.msize > msize)
        error("server tries to increase msize in fversion");
    if(f.msize<256 || f.msize>1024*1024)
        error("nonsense value of msize in fversion");
    k = strlen(f.version);
    if(strncmp(f.version, v, k) != 0)
        error("bad 9P version returned from server");

    /* now build Mnt associated with this connection */
    lock(&mntalloc);
    m = mntalloc.mntfree;
    if(m != 0)
        mntalloc.mntfree = m->list;
    else {
        m = malloc(sizeof(Mnt));
        if(m == 0) {
            unlock(&mntalloc);
            exhausted("mount devices");
        }
    }
    m->list = mntalloc.list;
    mntalloc.list = m;
    m->version = nil;
    kstrdup(&m->version, f.version);
    m->id = mntalloc.id++;
    m->q = qopen(10*MAXRPC, 0, nil, nil);
    m->msize = f.msize;
    unlock(&mntalloc);

    if(returnlen > 0){
        if(returnlen < k)
            error(Eshort);
        memmove(version, f.version, k);
    }

    poperror(); /* msg */
    free(msg);

    lock(m);
    m->queue = 0;
    m->rip = 0;

    c->flag |= CMSG;
    c->mux = m;
    m->c = c;
    unlock(m);

    poperror(); /* c */
    qunlock(&c->umqlock);

    return k;
}
@


<<mnt.c>>=
<<kernel basic includes>>

// this used to be in devmnt.c, but to avoid backward deps I've splitted
// this file in 2 (which forced to put more stuff in portdat_files.h though).

<<global mntalloc>>

#define MAXRPC (IOHDRSZ+8192)

<<function freetag>>

<<function mntfree>>

<<function mntpntfree>>

<<function muxclose>>

<<function mntversion>>

@


\subsection*{[[files/qio.c]]}

\ifallcode
<<qio.c globals cnt>>=
static ulong padblockcnt;
static ulong concatblockcnt;
static ulong pullupblockcnt;
static ulong copyblockcnt;
static ulong consumecnt;
static ulong producecnt;
static ulong qcopycnt;
static ulong noblockcnt;
@ 

<<qio.c global debugging>>=
static int debugging;

//#define QDEBUG  if(0)
@ 
\fi


<<global qiomaxatomic>>=
enum
{
    Maxatomic   = 64*1024,
};

uint    qiomaxatomic = Maxatomic;
@

<<qio.c>>=
<<kernel basic includes>>

<<qio.c globals cnt>>

<<qio.c global debugging>>

<<global qiomaxatomic>>

<<function ixsummary>>

<<function freeblist>>

<<function padblock>>

<<function blocklen>>

<<function blockalloclen>>

<<function concatblock>>

<<function pullupblock>>

<<function pullupqueue>>

<<function trimblock>>

<<function copyblock>>

<<function adjustblock>>

<<function pullblock>>

<<function qget>>

<<function qdiscard>>

<<function qconsume>>

<<function qpass>>

<<function qpassnolim>>

<<function packblock>>

<<function qproduce>>

<<function qcopy>>

<<function qopen>>

<<function qbypass>>

<<function notempty>>

<<function qwait>>

<<function qaddlist>>

<<function qremove>>

<<function bl2mem>>

<<function qputback>>

<<function qwakeup_iunlock>>

<<function qbread>>

<<function qread>>

<<function qnotfull>>

<<function qbwrite>>

<<function qwrite>>

<<function qiwrite>>

<<function qfree>>

<<function qclose>>

<<function qhangup>>

<<function qiclosed>>

<<function qreopen>>

<<function qlen>>

<<function qwindow>>

<<function qcanread>>

<<function qsetlimit>>

<<function qnoblock>>

<<function qflush>>

<<function qfull>>

@

%/*
% *  copy the contents of memory into a string of blocks.
% *  return nil on error.
% */
%//Block*
%//mem2bl(uchar *p, int len)
%//{
%//  int n;
%//  Block *b, *first, **l;
%//
%//  first = nil;
%//  l = &first;
%//  if(waserror()){
%//      freeblist(first);
%//      nexterror();
%//  }
%//  do {
%//      n = len;
%//      if(n > Maxatomic)
%//          n = Maxatomic;
%//
%//      *l = b = allocb(n);
%//      setmalloctag(b, (up->text[0]<<24)|(up->text[1]<<16)|(up->text[2]<<8)|up->text[3]);
%//      memmove(b->wp, p, n);
%//      b->wp += n;
%//      p += n;
%//      len -= n;
%//      l = &b->next;
%//  } while(len > 0);
%//  poperror();
%//
%//  return first;
%//}
%
%//int
%//qstate(Queue *q)
%//{
%//  return q->state;
%//}


\subsection*{[[files/sysfile.c]]}


<<sysfile.c>>=
<<kernel basic includes>>

/*
 * The sys*() routines needn't poperror() as they return directly to syscall().
 */

<<function unlockfgrp>>

<<function growfd>>

<<function findfreefd>>

<<function newfd>>

<<function newfd2>>


<<syscall fd2path>>

<<syscall pipe>>

<<syscall dup>>

<<syscall open>>

<<syscall close>>

<<function unionread>>

<<function unionrewind>>

<<function dirfixed>>

<<function offsetof_name_direntry>>

<<function direntry_setname>>

<<function mountrock>>

<<function mountrockread>>

<<function mountrewind>>

<<function mountfix>>

<<function read>>

<<syscall pread>>

<<function write>>

<<syscall pwrite>>

<<function sseek>>

<<syscall seek>>

<<function pathlast>>

<<syscall fstat>>

<<syscall stat>>

<<syscall chdir>>

<<function bindmount>>

<<syscall bind>>

<<syscall mount>>

<<syscall unmount>>

<<syscall create>>

<<syscall remove>>

<<function wstat>>

<<syscall wstat>>

<<syscall fwstat>>

@

\section{[[filesystems/]]}

% see dossrv/ fossil/ ...

\section{[[init/]]}

\subsection*{[[init/portfns_init.h]]}

\ifallcode
<<portfns_init.h>>=

// rebootcmd.c
void    rebootcmd(int, char**);

//in <arch>/main.c (but called from syswrite)
void    arch_reboot(kern_addr3, kern_addr3, ulong);

//TODO: should add prefix arch_ (or conf_ ?)
// in <arch>/<conf>.c (called from main)
void  links(void);
// in <arch>/<conf>.root.c (called from main)
void    bootlinks(void);

// in <arch>/?? (called from main) but different prototypes
//void  arch_touser(void*);

@
\fi

\subsection*{[[init/user/preboot/initcode.c]]}


\subsection*{[[init/user/boot/aux.c]]}

% only run and runv are maybe slightly interesting


\ifallcode
<<aux.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

// Note that most of this code is now superseded by $objtype/boot.rc

void
warning(char *s)
{
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    fprint(2, "boot: %s: %s\n", s, buf);
}

void
fatal(char *s)
{
    char *msg;
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    msg = smprint("%s: %s", s, buf);
    fprint(2, "boot: %s\n", msg);
    exits(msg);         /* this will trigger a panic */
}

<<function runv>>

<<function run>>


void bind_safe(char* old, char* new, int flag) {
  if(bind(old, new, flag) < 0)
    fatal("bind");
  return;
}

//less: could get path in fatal message
int open_safe(char* path, int flag) {
  int fd;
  if((fd = open(path, flag)) < 0) {
    fatal("open");
  }
  return fd;
}

void print_safe(int fd, char* str) {
  if(write(fd, str, strlen(str)) < 0) {
    fatal("print");
  };
  return;
}

void close_safe(int fd) {
  if(close(fd) < 0) {
    fatal("close");
  }
}
@
%$
\fi

\subsection*{[[init/user/boot/boot.c]]}

\subsection*{[[init/user/boot/boot.h]]}

\ifallcode
<<boot.h>>=
/* libc equivalent */
// aux.c: 
extern void fatal(char*);
extern void warning(char*);
extern void run(char *file, ...);
extern void runv(char **argv);
/* pad style */
void bind_safe(char* old, char* new, int flag);
int open_safe(char* path, int flag);
void print_safe(int fd, char* str);
void close_safe(int fd);

/* methods */
// local.c:
extern void  connectlocal(void);
//extern void configlocal(Method*);
// other possible method connections: network.c, ...

// <arch>/boot$CONF.c
//extern Method method[];   /* defined in ../$arch/boot$CONF.c */
//extern char*  bootdisk;   /* defined in ../$arch/boot$CONF.c */
//void main(int argc, char **argv)

/* main entry point */
// boot.c:
extern void boot(int, char **);

@
\fi
%$

%// what boot$CONF.c used to expect
%//typedef struct Method Method;
%//struct Method
%//{
%//  char  *name;
%//  void  (*config)(Method*);
%//  int (*connect)(void);
%//  char  *arg;
%//};


\subsection*{[[init/user/boot/local.c]]}

%//void
%//configlocal(Method *mp)
%//{
%//  USED(mp);
%//}



\section{[[lib/]]}

\subsection*{[[lib/lib.h]]}

\ifallcode
<<lib.h forward decl>>=
typedef struct Qid  Qid;
typedef struct DirEntry  DirEntry;
typedef struct DirEntry  Dir; // for fcall.h
typedef struct Waitmsg  Waitmsg;
typedef struct Fmt  Fmt;
@
\fi





<<constant ERRMAX>>=
ERRMAX = 128, /* max length of error string */
@


<<constant KNAMELEN>>=
KNAMELEN = 28,  /* max length of name held in kernel */
@

\ifallcode
<<enum miscsize>>=
enum miscsize {  
    <<constant ERRMAX>>
    <<constant KNAMELEN>>
};
@ 
\fi


<<function nelem>>=
#define nelem(x)  (sizeof(x)/sizeof((x)[0]))
@


<<function offsetof>>=
//@Scheck: not dead, actually exanded in macros.h
#define offsetof(s, m)  (ulong)(&(((s*)0)->m))
@

<<function assert>>=
#define assert(x) do { if(x) {}else _assert("x");}while(0)
@




<<lib.h print decl>>=
// This used to be regular function, but to avoid backward deps in the kernel
// I made it into a pointer function (a bit ugly, and maybe unsafe)
extern  int (*print)(char*, ...);
@


<<lib.h>>=
// coupling: libc.h
// This file mostly exports code from lib_core/libc/ (linked with the kernel).
// Those functions are also exported in include/libc.h but they prefered to
// not include it and instead to reexport here a subset specific to the kernel.
// There are also the poolxxx() functions exported in include/pool.h
// (also part of libc) that are used in memory/alloc.c.
// Some functions in libc are also "overriden" (via linker abuse):
//  - print.c overrides _fmtlock(), _fmtunlock() that were in libc/fmt/
//  - devcons.s overrides the sysfatal() that was in libc/9sys/

// pad specific, could be in u.h
<<pad basic types>>

//#define nil (void*)0 in u.h
#define nilptr 0

<<lib.h forward decl>>

/*
 * functions (mostly) linked in from libc.
 */
<<function nelem>>
<<function offsetof>>
<<function assert>>

/*
 * mem routines
 */
<<lib.h mem functions decl>>

/*
 * string routines
 */
<<lib.h string functions decl>>

//redefined in the kernel
extern  int cistrcmp(char*, char*);
extern  int cistrncmp(char*, char*, int);

<<enum utf>>

/*
 * rune routines
 */
<<lib.h rune functions decl>>

extern  int abs(int);

/*
 * print routines
 */
typedef int (*Fmts)(Fmt*);
<<struct Fmt>>

<<lib.h print decl>>

<<lib.h printf functions decl>>

<<lib.h pragmas>>

<<lib.h fmt functions decl>>

/*
 * one-of-a-kind
 */
<<lib.h strto functions decl>>

//todo: should return a (void*)
extern  ulong getcallerpc(void*);
extern  char* cleanname(char*);
extern  int getfields(char*, char**, int, int, char*);
extern  int tokenize(char*, char**, int);
extern  void  qsort(void*, long, long, int (*)(void*, void*));

<<lib.h exxx decl>>


/*
 * Syscall data structures
 */
<<enum mount>>

<<enum open>>

<<enum note>>

<<enum miscsize>>



<<enum qidtype>>

<<enum dirmode>>

<<struct Qid>>

<<struct DirEntry>>


<<struct Waitmsg>>

@
%//unused: extern  int dec64(uchar*, int, char*, int);
%//unused: extern  int encodefmt(Fmt*);

%// for byteorder agnostic marshalling?
%// dead?
%struct OWaitmsg
%{
%  char  pid[12];  /* of loved one */
%  char  time[3*12]; /* of loved one and descendants */
%  char  msg[64];  /* compatibility BUG */
%};
%@ 



\section{[[memory/]]}

\subsection*{[[memory/portdat_memory.h]]}

<<portdat_memory.h>>=

// see also Arch_KMap in <arch>/ (but used in port)

//*****************************************************************************
// Page < Pagetable (can be filled by KImage) < Segment
//*****************************************************************************

// All the ref<Page> here are references to Pages in the array<Page> of 
// Palloc.pages (pool allocator)
// All the ref<Kimage> here are references to KImage in the ?? of 
// Imagealloc.free?

<<enum modref>>

enum Cachectl {
 PG_NOFLUSH	= 0,
 PG_TXTFLUSH	= 1,		/* flush dcache and invalidate icache */
 PG_NEWCOL	= 3,		/* page has been recolored */
};


<<struct Page>>

<<type PageOrSwap>>

<<struct Pagetable>>

<<struct KImage>>

<<enum segtype>>

<<constant PG_ONSWAP>>

<<function onswap>>
<<function pagedout>>
<<function swapaddr>>

#define SEGMAXSIZE  (PAGEDIRSIZE*PAGETABMAPMEM)

<<struct Physseg>>

enum
{
    <<constant LRESPROF>>
};

<<struct Segment>>

//*****************************************************************************
// Internal to memory/
//*****************************************************************************

// See also RMap in 386/

// actually internal to xalloc.c, but important so here
<<constants holes>>

<<struct Hole>>

<<struct Xhdr>>

<<struct Xalloc>>
//IMPORTANT: static Xalloc xlists; // private to xalloc.c


// from pool.h
//struct Pool {
//  char* name;
//  ulong maxsize;
//
//  ulong cursize;
//  ulong curfree;
//  ulong curalloc;
//
//  ulong minarena; /* smallest size of new arena */
//  ulong quantum;  /* allocated blocks should be multiple of */
//  ulong minblock; /* smallest newly allocated block */
//
//  void* freeroot; /* actually Free* */
//  void* arenalist;  /* actually Arena* */
//
//  void* (*alloc)(ulong);
//  int (*merge)(void*, void*);
//  void  (*move)(void* from, void* to);
//
//  int flags;
//  int nfree;
//  int lastcompact;
//
//  void  (*lock)(Pool*);
//  void  (*unlock)(Pool*);
//  void  (*print)(Pool*, char*, ...);
//  void  (*panic)(Pool*, char*, ...);
//  void  (*logstack)(Pool*);
//
//  void* private;
//};

// exported by libc include/pool.h, used by malloc, defined in pool.c in this dir
// memory pools for malloc()/free() (using xalloc pools)
//IMPORTANT: extern Pool*  mainmem;
// memory pools for ??
//IMPORTANT: extern Pool*  imagmem;

<<struct Pallocmem>>

<<function pghash>>

<<struct Palloc>>
extern  Palloc  palloc;

<<constant NFREECHAN>>

<<function ihash>>

<<struct Imagealloc>>

//IMPORTANT: static struct Imagealloc imagealloc; (segment.c)
// so have conf.nimage + 1 Kimages
extern  KImage  swapimage;

<<struct Swapalloc>>
extern struct Swapalloc swapalloc;
@


\subsection*{[[memory/portfns_memory.h]]}

\ifallcode
<<portfns_memory.h>>=

// xalloc.c
void* xalloc(ulong);
void  xfree(void*);
void  xsummary(void);
int   xmerge(void*, void*);
void  xinit(void);
void* xspanalloc(ulong, int, ulong);

// pool.c
// see include/pool.h: poollock(), ...
void  mallocsummary(void);

// alloc.c
void* malloc(ulong);
void  free(void*);
void* smalloc(ulong);
void* mallocz(ulong, int);
void* mallocalign(ulong, ulong, long, ulong);
void* realloc(void *v, ulong size);
ulong msize(void*);
void  setmalloctag(void*, ulong);
void  kstrcpy(char*, char*, int);
void  kstrdup(char**, char*);

// page.c
void  pageinit(void);
void  pagechainhead(Page*);
void  copypage(Page*, Page*); //TODO: why fp no-deps in codegraph?
void  cachepage(Page *p, KImage *i);
void  uncachepage(Page*);
void  cachedel(KImage*, ulong);
Pagetable*    ptalloc(void);
Pagetable*    ptcpy(Pagetable*);
void  freept(Segment*, Pagetable*);
ulong pagenumber(Page*);
Page* lookpage(KImage*, ulong);
void  putpage(Page*);
Page* auxpage(void);
Page* newpage(int, Segment **, ulong);
int   duppage(Page*);
void  checkpagerefs(void);

// swap.c
void  swapinit(void);
void  putswap(Page*);
void  dupswap(Page*);
int   swapcount(ulong);
void  pagersummary(void);
void  setswapchan(Chan*);
void  kickpager(void);

// fault.c
Segment*  seg(Proc*, ulong, int);
void  checkpages(void);
void  validaddr(ulong, ulong, bool);
int   okaddr(ulong, ulong, int);
int   fixfault(Segment*, ulong, int, int);
void* vmemchr(virt_addr3, int, int);
int   fault(ulong, int);

// segment.c
Segment*  newseg(int, ulong, ulong);
void  relocateseg(Segment*, ulong);
void  segpage(Segment*, Page*);
void  putimage(KImage*);
void  mfreeseg(Segment*, ulong, int);
void  segclock(ulong);
void  putseg(Segment*);
Segment*  dupseg(Segment**, int, int);
long  ibrk(ulong, int);
int   addphysseg(Physseg*);
ulong segattach(Proc*, ulong, char *, ulong, ulong);
void  imageinit(void);
KImage*   attachimage(int, Chan*, ulong, ulong);

// sysfile.c
// syssetflush (used in syscalls/ without requiring extern decl)

// defined in <arch>/mmu.c (used in port)
Arch_KMap* arch_kmap(Page*);
void  arch_kunmap(Arch_KMap*);
void  arch_flushmmu(void);
void  arch_checkmmu(ulong va, ulong pa);
void  arch_putmmu(ulong, ulong, Page*);
void  arch_mmurelease(Proc*);
void  arch_mmuswitch(Proc*);
ulong arch_cankaddr(ulong);
// actually KADDR is used in port, but it's expanding to kaddr
kern_addr3 arch_kaddr(phys_addr);
// actually PADDR is used in port, but it's expanding to paddr
phys_addr arch_paddr(kern_addr3);
void  arch_countpagerefs(ulong*, int);

// defined in <arch>/ (used in port)
void  arch_memorysummary(void);

// in <arch>/mmu.c (called from main and other other cpu init function)
void  arch_mmuinit(void);

@
\fi

\subsection*{[[memory/portdat_memory.c]]}


<<portdat_memory.c>>=
<<kernel basic includes>>

<<global palloc>>

<<global swapalloc>>
<<global swapimage>>

@


\subsection*{[[memory/xalloc.c]]}

\ifallcode
<<xalloc.c forward decl>>=
void        xhole(ulong, ulong);
@
\fi



<<xalloc.c>>=
<<kernel basic includes>>

<<xalloc.c forward decl>>

//*****************************************************************************
// The global
//*****************************************************************************

<<global xlists>>

//*****************************************************************************
// Initialization
//*****************************************************************************

<<function xinit>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<function xspanalloc>>

<<function xallocz>>

<<function xalloc>>

<<function xfree>>

<<function xmerge>>

<<function xhole>>

//*****************************************************************************
// Debugging
//*****************************************************************************

<<function xsummary>>
@


\subsection*{[[memory/pool.c]]}
%pad: I created this file, it was in alloc.c before.
% important to include it!! otherwise imagmem and mainmem will not
% be defined anywhere and when linking libmemdraw, the linker
% will load mainmem from libc and you will get 'redefinition' linking
% errors.

<<pool.c forward decl>>=
typedef struct Private  Private;
@



<<pool.c>>=
<<kernel basic includes>>

#include    <pool.h>

<<pool.c forward decl>>

//*****************************************************************************
// Concurrency
//*****************************************************************************

// See Pool.private, for mutual exclusion on memory pools
<<pool.c struct Private>>

//*****************************************************************************
// Pool methods
//*****************************************************************************

<<function poolprint>>

<<function ppanic>>

<<function plock>>

<<function punlock>>

<<function poolsummary>>

//*****************************************************************************
// The globals
//*****************************************************************************

<<global pmainmem>>

<<global pimagmem>>

<<global mainmem and imagmem>>

<<function mallosummary>>

@


\subsection*{[[memory/alloc.c]]}

\ifallcode
<<alloc.c debugging macro>>=
/* non tracing
 *
enum {
    Npadlong    = 0,
    MallocOffset = 0,
    ReallocOffset = 0,
};
 *
 */
@
\fi

<<alloc.c>>=
<<kernel basic includes>>

#include    <pool.h>

/* everything from here down should be the same in libc, libdebugmalloc, and the kernel */
/* - except the code for malloc(), which alternately doesn't clear or does. */
/* - except the code for smalloc(), which lives only in the kernel. */

//*****************************************************************************
// Debugging support
//*****************************************************************************

/*
 * Npadlong is the number of 32-bit longs to leave at the beginning of 
 * each allocated buffer for our own bookkeeping.  We return to the callers
 * a pointer that points immediately after our bookkeeping area.  Incoming pointers
 * must be decremented by that much, and outgoing pointers incremented.
 * The malloc tag is stored at MallocOffset from the beginning of the block,
 * and the realloc tag at ReallocOffset.  The offsets are from the true beginning
 * of the block, not the beginning the caller sees.
 *
 * The extra if(Npadlong != 0) in various places is a hint for the compiler to
 * compile out function calls that would otherwise be no-ops.
 */

/* tracing */
enum {
    Npadlong    = 2,
    MallocOffset = 0,
    ReallocOffset = 1
};

<<alloc.c debugging macro>>

<<function setmalloctag>>

<<function setrealloctag>>

//*****************************************************************************
// Pool wrappers
//*****************************************************************************

<<function smalloc>>

<<function malloc>>

<<function mallocz>>

<<function mallocalign>>

<<function free>>

<<function realloc>>

<<function msize>>


//*****************************************************************************
// kstr functions
//*****************************************************************************

//pad: was in chan.c

<<function kstrcpy>>

<<function kstrdup>>
@


%//ulong
%//getmalloctag(void *v)
%//{
%//  USED(v);
%//  if(Npadlong <= MallocOffset)
%//      return ~0;
%//  return ((ulong*)v)[-Npadlong+MallocOffset];
%//}
%//
%//ulong
%//getrealloctag(void *v)
%//{
%//  USED(v);
%//  if(Npadlong <= ReallocOffset)
%//      return ((ulong*)v)[-Npadlong+ReallocOffset];
%//  return ~0;
%//}
%//void*
%//calloc(ulong n, ulong szelem)
%//{
%//  void *v;
%//  if(v = mallocz(n*szelem, 1))
%//      setmalloctag(v, getcallerpc(&n));
%//  return v;
%//}

\subsection*{[[memory/fault.c]]}

\ifallcode
<<fault.c forward decl>>=
void        pio(Segment *, ulong, ulong, Page **);
@
\fi



<<fault.c>>=
<<kernel basic includes>>

<<fault.c forward decl>>

<<function fault>>

<<function faulterror>>

// for debugging SG_PHYSICAL
void    (*checkaddr)(ulong, Segment *, Page *);
ulong   addr2check;

<<function fixfault>>

<<function pio>>

<<function okaddr>>

<<function validaddr>>

<<function vmemchr>>

<<function seg>>

<<function checkpages>>
@


\subsection*{[[memory/page.c]]}

\ifallcode
<<page.c forward decl>>=
int hasfreepages(void*);
void portcountpagerefs(ulong*, int);
@
\fi



<<page.c>>=
<<kernel basic includes>>

<<page.c forward decl>>

//*****************************************************************************
// Initialization
//*****************************************************************************

<<function pageinit>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<function pageunchain>>

<<function pagechaintail>>

<<function pagechainhead>>

<<constructor newpage>>

<<function hasfreepages>>

<<destructor putpage>>

<<function auxpage>>

<<global dupretries>>

<<function duppage>>

<<function copypage>>

<<function uncachepage>>

<<function cachepage>>

<<function cachedel>>

<<function lookpage>>

<<function ptcpy>>

<<constructor ptalloc>>

<<destructor freept>>

<<function pagenumber>>

<<function checkpagerefs>>

<<function portcountpagerefs>>

@


\subsection*{[[memory/segment.c]]}

\ifallcode
<<segment.c forward decl>>=
static void imagereclaim(void);
static void imagechanreclaim(void);
Segment* data2txt(Segment *s);
@
\fi

\ifallcode
<<struct Irstats>>=
struct Irstats {
    int calls;          /* times imagereclaim was called */
    int loops;          /* times the main loop was run */
    uvlong  ticks;          /* total time in the main loop */
    uvlong  maxt;           /* longest time in main loop */
};
@ 

<<segment.c global irstats>>=
static struct Irstats  irstats;
@ 
\fi


<<segment.c>>=
<<kernel basic includes>>
#include "io.h"

//*****************************************************************************
// Global
//*****************************************************************************

<<global imagealloc>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<global physseg>>
<<global physseglock>>

<<hook _globalsegattach>>

<<segment.c forward decl>>

//*****************************************************************************
// Initialization
//*****************************************************************************

<<function imageinit>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<constructor newseg>>

<<destructor putseg>>

<<function relocateseg>>

<<function dupseg>>

<<function segpage>>

<<constructor attachimage>>

<<struct Irstats>>
<<segment.c global irstats>>

<<function imagereclaim>>

<<function imagechanreclaim>>

<<destructor putimage>>

<<function ibrk>>

<<function mfreeseg>>

<<function isoverlap>>

<<function addphysseg>>

<<function segattach>>

<<clock callback segclock>>

// was in another file before
<<function data2txt>>
@

%//int
%//isphysseg(char *name)
%//{
%//  Physseg *ps;
%//  int rv = 0;
%//
%//  lock(&physseglock);
%//  for(ps = physseg; ps->name; ps++){
%//      if(strcmp(ps->name, name) == 0){
%//          rv = 1;
%//          break;
%//      }
%//  }
%//  unlock(&physseglock);
%//  return rv;
%//}


\subsection*{[[memory/swap.c]]}

\ifallcode
<<swap.c forward decl>>=
static int  canflush(Proc*, Segment*);
static void executeio(void);
static int  needpages(void*);
static void pageout(Proc*, Segment*);
static void pagepte(int, Page**);
static void pager(void*);
@
\fi


<<swap.c>>=
<<kernel basic includes>>

<<swap.c forward decl>>

<<global iolist>>
<<global ioptr>>

<<global genxxx>>

<<function gentick>>

<<function swapinit>>

<<function newswap>>

<<function putswap>>

<<function dupswap>>

<<function swapcount>>

<<function kickpager>>

<<function pager>>

<<function pageout>>

<<function canflush>>

<<function pagepte>>

<<function pagersummary>>

<<function pageiocomp>>

<<function executeio>>

<<function needpages>>

<<function setswapchan>>

@

%//int
%//swapfull(void)
%//{
%//  return swapalloc.free < conf.nswap/10;
%//}


\subsection*{[[memory/sysmemory.c]]}


<<sysmemory.c>>=
<<kernel basic includes>>

// see also sysbrk in sysproc.c

// those functions used to be in segment.c

void
ptflush(Pagetable *pt, int s, int e)
{
 int i;
 Page *p;

 for(i = s; i < e; i++) {
  p = pt->pagetab[i];
  if(pagedout(p) == 0)
   memset(p->cachectl, PG_TXTFLUSH, sizeof(p->cachectl));
 }
}


<<syscall segflush>>
@

\section{[[misc/]]}

\subsection*{[[misc/portdat_misc.h]]}


<<portdat_misc.h>>=

enum misc_constants_portable {
    /* READSTR was 1000, which is way too small for usb's ctl file */
    READSTR = 4000,   /* temporary buffer size for device reads */

    KB = 1024,
    MB = (1024*1024),

    NUMSIZE = 12,   /* size of formatted number */

    <<constant PRINTSIZE>>
};


<<struct Cmdbuf>>

<<struct Cmdtab>>
@


\subsection*{[[misc/portfns_misc.h]]}

\ifallcode
<<portfns_misc.h>>=

// parse.c
Cmdbuf*  parsecmd(char *a, int n);
Cmdtab*  lookupcmd(Cmdbuf*, Cmdtab*, int);
void     cmderror(Cmdbuf*, char*);

// random.c
void     randominit(void);
ulong    randomread(void*, ulong);

@
\fi

\subsection*{[[misc/parse.c]]}


<<parse.c>>=
<<kernel basic includes>>

<<ncmdfield>>

<<function parsecmd>>

<<function cmderror>>

<<function lookupcmd>>
@


\subsection*{[[misc/random.c]]}


<<random.c>>=
<<kernel basic includes>>

<<struct Rb>>

<<global rb>>

<<struct rbnotfull>>

<<struct rbnotempty>>

<<function genrandom>>

<<clock callback randomclock>>

<<function randominit>>

<<function randomread>>
@


\section{[[processes/]]}

\subsection*{[[processes/portdat_processes.h]]}

\ifallcode
<<portdat_processes.h pragmas>>=
#pragma varargck  type  "t"   long
#pragma varargck  type  "U"   uvlong
@
\fi



<<portdat_processes.h>>=

// in lib.h: Waitmsg, ERRMAX

//*****************************************************************************
// Proc components
//*****************************************************************************
// All the ref<Proc> here are references to Proc in the array<Proc> of
// Procalloc.arena (pool allocator)

//--------------------------------------------------------------------
// State
//--------------------------------------------------------------------

// TODO: state transition diagram
<<enum procstate>>

// hash<enum<procstate>, string>, to debug
extern  char* statename[];

//--------------------------------------------------------------------
// Memory
//--------------------------------------------------------------------
<<enum procseg>>

//--------------------------------------------------------------------
// Files
//--------------------------------------------------------------------

enum
{
   <<constant DELTAFD>>
};

<<struct Fgrp>>


<<function MOUNTH>>

<<struct Pgrp>>

//--------------------------------------------------------------------
// System call
//--------------------------------------------------------------------

<<constant MAXSYSARG>>

<<struct Sargs>>

//--------------------------------------------------------------------
// Notes
//--------------------------------------------------------------------

enum {
    <<constant NNOTE>>
};

<<enum notekind>>

<<struct Note>>
extern Counter  noteidalloc;

//--------------------------------------------------------------------
// Process children waiting
//--------------------------------------------------------------------

<<struct Waitq>>

//--------------------------------------------------------------------
// Synchronization (Rendez vous)
//--------------------------------------------------------------------

<<function REND>>

<<struct Rgrp>>

//--------------------------------------------------------------------
// Alarms, timers
//--------------------------------------------------------------------

<<enum timermode>>

<<type Txxx>>

<<struct Timer>>

// was in clock.c
<<struct Timers>>

//--------------------------------------------------------------------
// Scheduling
//--------------------------------------------------------------------

enum {
    <<constant Npriq>>
    <<constant Nrq>>
};

<<enum priority>>

<<enum edfflags>>

<<struct Edf>>

//--------------------------------------------------------------------
// Error management
//--------------------------------------------------------------------
enum {
    <<constant NERR>>
};

//--------------------------------------------------------------------
// Stats, profiling
//--------------------------------------------------------------------
<<enum proctimer>>

//--------------------------------------------------------------------
// Debugger
//--------------------------------------------------------------------

<<enum procctl>>

//--------------------------------------------------------------------
// Misc
//--------------------------------------------------------------------

<<enum fpsavestatus>>

//*****************************************************************************
// Proc, the big one
//*****************************************************************************

<<struct Proc>>

<<macro waserror poperror>>


//*****************************************************************************
// Internal to process/
//*****************************************************************************

// Proc allocator (singleton), was actually in proc.c, but important so here
<<struct Procalloc>>
//IMPORTANT: static struct Procalloc procalloc; (in proc.c)

<<struct Schedq>>
// hash<enum<priority>, Schedq>, Nrq is the number of priority level (20+2)
//IMPORTANT: Schedq  runq[Nrq];  (in proc.c)

// was in alarm.c, but important so here
<<struct Alarms>>
//IMPORTANT: static Alarms alarms; (in alarm.c)
//IMPORTANT: static Rendez alarmr; (in alarm.c)

<<struct Active>>
extern struct Active active;

<<portdat_processes.h pragmas>>

@


\subsection*{[[processes/portfns_processes.h]]}

\ifallcode
<<portfns_processes.h>>=

// tod.c
// initialize the hidden global tod.c#tod
void    todinit(void);
void    todsetfreq(vlong);
void    todset(vlong, vlong, int);
vlong   todget(vlong*);
//is in <arch>/devarch.c (but used in port)
//uvlong    (*arch_fastticks)(uvlong*); 
uvlong  fastticks2us(uvlong);
uvlong  ns2fastticks(uvlong);
long    seconds(void);

// pgrp.c
Rgrp*   newrgrp(void);
Pgrp*   newpgrp(void);
void    closergrp(Rgrp*);
void    closefgrp(Fgrp*);
Fgrp*   dupfgrp(Fgrp*);
void    closepgrp(Pgrp*);
void    pgrpcpy(Pgrp*, Pgrp*);
void    forceclosefgrp(void);
void    pgrpnote(ulong, char*, long, int);
void    mountfree(Mount*);
Mount*  newmount(Chan*, int, char*);
void    resrcwait(char*);

// portclock.c
ulong   tk2ms(ulong);
#define   TK2MS(x) ((x)*(1000/HZ))
#define   MS2NS(n) (((vlong)(n))*1000000LL)
ulong   ms2tk(ulong);
void    timerdel(Timer*);
void    timeradd(Timer*);
Timer*  addclock0link(void (*)(void), int);
void    timerintr(Ureg*, Tval);
void    timersinit(void);
//void    arch_timerset(Tval); is in <arch>/devarch.c (but used in port)

// proc.c
void exhausted(char*);
// in portfns_core.h, to remove some backward dependencies
//void  (*sleep)(Rendez*, int(*)(void*), void*);
//int   (*postnote)(Proc*, int, char*, int);
void    procctl(Proc*);
void    procwired(Proc*, int);
//Proc* (*wakeup)(Rendez*);
//void  (*error)(char*);
void    procpriority(Proc*, int, int);
//TODO: fp non-deps twakeup, passed as pointer func
//void  (*nexterror)(void);
//void  (*dumpaproc)(Proc*);
void    accounttime(void);
int     canpage(Proc*);
int     anyhigher(void);
void    scheddump(void);
Proc*   dequeueproc(Schedq*, Proc*);
void    preempt(void);
void    killbig(char*);
void    procflushseg(Segment*); 
void    procdump(void);
void    renameuser(char*, char*);
void    procinit(void);
int     procindex(ulong);
ulong   pwait(Waitmsg*);
//void  (*tsleep)(Rendez*, int (*)(void*), void*, ulong);
void    unbreak(Proc*);
int     freebroken(void);
void    yield(void);
//void  (*pexit)(char*, bool);
//void  (*sched)(void);
void    schedinit(void);
//void  (*ready)(Proc*);
Proc*   newproc(void);
void    kproc(char*, void(*)(void*), void*);
void    hzsched(void);
//not used outside: int   anyready(void);
//TODO cg didn't find ref outside in devproc.c?
int   haswaitq(void*);

// alarm.c
ulong   procalarm(ulong);
void    alarmkproc(void*);
void    checkalarms(void);

// edf.c (used to be declared in edf.h)
Edf*    edflock(Proc*);
void    edfunlock(void);
//TODO fp deadlineintr, static func passed via pointer again
void    edfrun(Proc*, int);
void    edfinit(Proc*);
void    edfrecord(Proc*);
void    edfstop(Proc*);
void    edfyield(void);
int     edfready(Proc*);
char*   edfadmit(Proc*);

// sysproc.c
// not useless, used by misc/rebootcmd.c, weird not recognized by cg
ulong   l2be(long);
// many sysxxx functions (used in syscalls/ without requiring extern decl)




// <arch>/trap.c (but used in port)
int     arch_userureg(Ureg *);
void    arch_callwithureg(void(*)(Ureg*));
ulong   arch_dbgpc(Proc*);
ulong   arch_userpc(void);
long    arch_execregs(ulong, ulong, ulong);
void    arch_forkchild(Proc*, Ureg*);
void    arch_kprocchild(Proc*, void (*)(void*), void*);
void    arch_setregisters(Ureg*, char*, char*, int);
void    arch_setkernur(Ureg*, Proc*);
void    arch_validalign(uintptr, unsigned); // TODO: should be in memory/?

// <arch>/trap.c (used in arch specific)
void  arch_intrenable(int, void (*)(Ureg*, void*), void*, int, char*);


// <arch>/trap.c (called from main)
void  arch_trapinit(void);
// in <arch>/forkret.s, called from arch_forkchild
//@Scheck: Assembly
void  arch_forkret(void); 



// <arch>/main_processes.c (but used in port)
void  arch_procsetup(Proc*);
void  arch_procsave(Proc*);
void  arch_procrestore(Proc *);
void  arch_idlehands(void);

// <arch>/i8253.c (but used in port)
ulong arch_perfticks(void);

// <arch>/arch.c (but used in port)
void  arch_timerset(Tval);
ulong arch_us(void);

// in <arch>/l.s (but used in port)
//@Scheck: Assembly
void  arch_gotolabel(Label*);
//@Scheck: Assembly
int   arch_setlabel(Label*);
//@Scheck: Assembly
void  arch_mul64fract(uvlong*, uvlong, uvlong);

// portdat_processes.c
void (*proctrace)(Proc*, int, vlong); // was in devproc.c
void (*kproftimer)(ulong); // was in portfns.h
@
\fi

\subsection*{[[processes/portdat_processes.c]]}


<<portdat_processes.c>>=
<<kernel basic includes>>

<<hook proctrace>>
<<hook kproftimer>>

<<global active>>
@


\subsection*{[[processes/alarm.c]]}

<<alarm.c>>=
<<kernel basic includes>>

<<global alarms>>
<<global alarmr>>

<<kernel process alarmkproc>>

<<function checkalarms>>

<<function procalarm>>
@

\subsection*{[[processes/portclock.c]]}
% At some point I renamed this file clock.c, but
% then many arch defines their own clock.c and
% then the mkfile does not like that because there is an
% ambiguity between port/ and the arch, so I kept original portclock.c
% filename.


<<portclock.c>>=
<<kernel basic includes>>

#include "io.h"

#include <ureg.h>

enum {
   <<constant Maxtimerloops>>
};

<<global timers>>
<<global timersinited>>

<<clock.c statistics>>

<<function tadd>>

<<function tdel>>

<<function timeradd>>

<<function timerdel>>

<<clock callback hzclock>>

<<interrupt callback timerintr>>

<<function timersinit>>

<<function addclock0link>>

<<function tk2ms>>

<<function ms2tk>>
@


\subsection*{[[processes/pgrp.c]]}

<<pgrp.c>>=
// Process group, and Namespace.

<<kernel basic includes>>

enum {
   <<constant Whinesecs>>
};

<<global pgrpid>>
<<global mountid>>

<<function pgrpnote>>

<<constructor newpgrp>>

<<constructor newrgrp>>

<<destructor closergrp>>

<<destructor closepgrp>>

<<function pgrpinsert>>

<<function pgrpcpy>>

<<function dupfgrp>>

<<function closefgrp>>

<<function forceclosefgrp>>

<<constructor newmount>>

<<destructor mountfree>>

<<function resrcwait>>
@


\subsection*{[[processes/proc.c]]}

\ifallcode
<<proc.c forward decl>>=
Proc* runproc(void);
void updatecpu(Proc*);
int reprioritize(Proc*);

static void pidhash(Proc*);
static void pidunhash(Proc*);
static void rebalance(void);
@

<<proc.c statistics>>=
ulong delayedscheds;    /* statistics */
long skipscheds;
long preempts;
//ulong load;
@ 

\fi





<<enum procctl cases>>=
    Proc_exitbig,
@

<<[[procctl()]] Proc_exitbig case>>=
    case Proc_exitbig:
        arch_spllo();
        pexit("Killed: Insufficient physical memory", true);
@

<<function killbig>>=
void
killbig(char *why)
{
    int i;
    Segment *s;
    ulong l, max;
    Proc *p, *ep, *kp;

    max = 0;
    kp = 0;
    ep = procalloc.arena+conf.nproc;
    for(p = procalloc.arena; p < ep; p++) {
        if(p->state == Dead || p->kp)
            continue;
        l = 0;
        for(i=1; i<NSEG; i++) {
            s = p->seg[i];
            if(s != 0)
                l += s->top - s->base;
        }
        if(l > max && ((p->procmode&0222) || strcmp(eve, p->user)!=0)) {
            kp = p;
            max = l;
        }
    }

    print("%lud: %s killed: %s\n", kp->pid, kp->text, why);
    for(p = procalloc.arena; p < ep; p++) {
        if(p->state == Dead || p->kp)
            continue;
        if(p != kp && p->seg[BSEG] && p->seg[BSEG] == kp->seg[BSEG])
            p->procctl = Proc_exitbig;
    }
    kp->procctl = Proc_exitbig;
    for(i = 0; i < NSEG; i++) {
        s = kp->seg[i];
        if(s != 0 && canqlock(&s->lk)) {
            mfreeseg(s, s->base, (s->top - s->base)/BY2PG);
            qunlock(&s->lk);
        }
    }
}
@ 



<<proc.c>>=
<<kernel basic includes>>
#include    <trace.h>

//*****************************************************************************
// Globals
//*****************************************************************************

<<global runq>>
<<global runveq>>

<<global procalloc>>

<<global nrdy>>
<<global noteidalloc>>

<<proc.c statistics>>

<<global pidalloc>>

enum
{
    <<constant Schedagain>>
    <<constant Scaling>>
};

<<global statename>>

<<proc.c forward decl>>

//*****************************************************************************
// Error managment
//*****************************************************************************

// see also waserror() and poperror() macro in portdat_processes.h

<<function error>>

<<function nexterror>>

<<function exhausted>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<function schedinit>>

<<function sched>>

<<function anyready>>

<<function anyhigher>>

<<function hzsched>>

<<function preempt>>

<<function updatecpu>>

<<function reprioritize>>

<<function queueproc>>

<<function dequeueproc>>

<<function ready>>

<<function yield>>

<<global balancetime>>

<<function rebalance>>
    
<<function runproc>>

<<function canpage>>

<<function noprocpanic>>

<<constructor newproc>>

<<function procwired>>

<<function procpriority>>

<<function procinit>>

<<function sleep>>

<<function tfn>>

<<function twakeup>>

<<function tsleep>>

<<function wakeup>>

<<function postnote>>

<<struct Broken>>
<<global broken>>

<<function addbroken>>

<<function unbreak>>

<<function freebroken>>

<<function pexit>>

<<function haswaitq>>

<<function pwait>>

<<function proctab>>

<<function dumpaproc>>

<<function procdump>>

<<function procflushseg>>

<<function scheddump>>

<<function kproc>>

<<function procctl>>

<<function killbig>>

<<function renameuser>>

<<function accounttime>>

<<function pidhash>>

<<function pidunhash>>

<<function procindex>>
@

\subsection*{[[processes/tod.c]]}

\ifallcode
<<tod.c forward decl>>=
uvlong      mk64fract(uvlong, uvlong);
static void todfix(void);
@
\fi




%/*
%    int shift;
%
%    if(to == 0ULL)
%        return 0ULL;
%
%    shift = 0;
%    while(shift < 32 && to < (1ULL<<(32+24))){
%        to <<= 8;
%        shift += 8;
%    }
%    while(shift < 32 && to < (1ULL<<(32+31))){
%        to <<= 1;
%        shift += 1;
%    }
%
%    return (to/from)<<(32-shift);
% */


<<tod.c>>=
// TOD: Time Of Day.

<<kernel basic includes>>

<<tod.c forward decl>>

/*
 * Compute nanosecond epoch time from the fastest ticking clock
 * on the system.  Converting the time to nanoseconds requires
 * the following formula
 *
 *  t = (((1000000000<<31)/f)*ticks)>>31
 *
 *  where
 *
 *  'f'     is the clock frequency
 *  'ticks'     are clock ticks
 *
 *  to avoid too much calculation in todget(), we calculate
 *
 *  mult = (1000000000<<32)/f
 *
 *  each time f is set.  f is normally set by a user level
 *  program writing to /dev/fastclock.  arch_mul64fract will then
 *  take that fractional multiplier and a 64 bit integer and
 *  return the resulting integer product.
 *
 *  We assume that the cpu's of a multiprocessor are synchronized.
 *  This assumption needs to be questioned with each new architecture.
 */

/* frequency of the tod clock */
#define TODFREQ     1000000000ULL
#define MicroFREQ   1000000ULL

<<struct TOD>>
<<global tod>>

<<function todinit>>

<<function todsetfreq>>

<<function todset>>

<<function todget>>

<<function todfix>>

<<function seconds>>

<<function fastticks2us>>

<<function ns2fastticks>>

<<function mk64fract>>
@

%/*
% *  convert time of day to ticks
% */
%//uvlong
%//tod2fastticks(vlong ns)
%//{
%//  uvlong x;
%//
%//  ilock(&tod);
%//  arch_mul64fract(&x, ns-tod.off, tod.divider);
%//  x += tod.last;
%//  iunlock(&tod);
%//  return x;
%//}
%
%
%//uvlong
%//us2fastticks(uvlong us)
%//{
%//  uvlong res;
%//
%//  if(!tod.init)
%//      todinit();
%//  arch_mul64fract(&res, us, tod.udivider);
%//  return res;
%//}
%
%///*
%// *  convert milliseconds to fast ticks
%// */
%//uvlong
%//ms2fastticks(ulong ms)
%//{
%//  if(!tod.init)
%//      todinit();
%//  return (tod.hz*ms)/1000ULL;
%//}
%
%
%///*
%// *  convert fast ticks to ns
%// */
%//uvlong
%//fastticks2ns(uvlong ticks)
%//{
%//  uvlong res;
%//
%//  if(!tod.init)
%//      todinit();
%//  arch_mul64fract(&res, ticks, tod.multiplier);
%//  return res;
%//}

\subsection*{[[processes/sysproc.c]]}

\ifallcode
<<sysproc.c forward decl>>=
int shargs(char*, int, char**);
@
\fi


<<sysproc.c>>=
<<kernel basic includes>>

#include    <tos.h>
#include    <a.out.h>

<<enum rfork>>

<<sysproc.c forward decl>>

<<syscall nop>>

<<syscall rfork>>

<<function l2be>>

<<syscall exec>>

<<function shargs>>

<<syscall sleep>>

<<syscall alarm>>

<<syscall exits>>

<<syscall await>>

<<function werrstr>>

<<function generrstr>>

<<syscall errstr>>

<<syscall notify>>

<<syscall noted>>

<<syscall segbrk>>

<<syscall segattach>>

<<syscall segdetach>>

<<syscall segfree>>

<<syscall brk>>

<<syscall rendezvous>>

@


\subsection*{[[processes/syssema.c]]}


<<syssema.c>>=
<<kernel basic includes>>

/*
 * The implementation of semaphores is complicated by needing
 * to avoid rescheduling in syssemrelease, so that it is safe
 * to call from real-time processes.  This means syssemrelease
 * cannot acquire any qlocks, only spin locks.
 * 
 * Semacquire and semrelease must both manipulate the semaphore
 * wait list.  Lock-free linked lists only exist in theory, not
 * in practice, so the wait list is protected by a spin lock.
 * 
 * The semaphore value *addr is stored in user memory, so it
 * cannot be read or written while holding spin locks.
 * 
 * Thus, we can access the list only when holding the lock, and
 * we can access the semaphore only when not holding the lock.
 * This makes things interesting.  Note that sleep's condition function
 * is called while holding two locks - r and up->rlock - so it cannot
 * access the semaphore value either.
 * 
 * An acquirer announces its intention to try for the semaphore
 * by putting a Sema structure onto the wait list and then
 * setting Sema.waiting.  After one last check of semaphore,
 * the acquirer sleeps until Sema.waiting==0.  A releaser of n
 * must wake up n acquirers who have Sema.waiting set.  It does
 * this by clearing Sema.waiting and then calling wakeup.
 * 
 * There are three interesting races here.  
 
 * The first is that in this particular sleep/wakeup usage, a single
 * wakeup can rouse a process from two consecutive sleeps!  
 * The ordering is:
 * 
 *  (a) set Sema.waiting = 1
 *  (a) call sleep
 *  (b) set Sema.waiting = 0
 *  (a) check Sema.waiting inside sleep, return w/o sleeping
 *  (a) try for semaphore, fail
 *  (a) set Sema.waiting = 1
 *  (a) call sleep
 *  (b) call wakeup(a)
 *  (a) wake up again
 * 
 * This is okay - semacquire will just go around the loop
 * again.  It does mean that at the top of the for(;;) loop in
 * semacquire, phore.waiting might already be set to 1.
 * 
 * The second is that a releaser might wake an acquirer who is
 * interrupted before he can acquire the lock.  Since
 * release(n) issues only n wakeup calls -- only n can be used
 * anyway -- if the interrupted process is not going to use his
 * wakeup call he must pass it on to another acquirer.
 * 
 * The third race is similar to the second but more subtle.  An
 * acquirer sets waiting=1 and then does a final canacquire()
 * before going to sleep.  The opposite order would result in
 * missing wakeups that happen between canacquire and
 * waiting=1.  (In fact, the whole point of Sema.waiting is to
 * avoid missing wakeups between canacquire() and sleep().) But
 * there can be spurious wakeups between a successful
 * canacquire() and the following semdequeue().  This wakeup is
 * not useful to the acquirer, since he has already acquired
 * the semaphore.  Like in the previous case, though, the
 * acquirer must pass the wakeup call along.
 * 
 * This is all rather subtle.  The code below has been verified
 * with the spin model /sys/src/9/port/semaphore.p.  The
 * original code anticipated the second race but not the first
 * or third, which were caught only with spin.  The first race
 * is mentioned in /sys/doc/sleep.ps, but I'd forgotten about it.
 * It was lucky that my abstract model of sleep/wakeup still managed
 * to preserve that behavior.
 *
 * I remain slightly concerned about memory coherence
 * outside of locks.  The spin model does not take 
 * queued processor writes into account so we have to
 * think hard.  The only variables accessed outside locks
 * are the semaphore value itself and the boolean flag
 * Sema.waiting.  The value is only accessed with cmpswap,
 * whose job description includes doing the right thing as
 * far as memory coherence across processors.  That leaves
 * Sema.waiting.  To handle it, we call coherence() before each
 * read and after each write.       - rsc
 */

<<function semqueue>>

<<function semdequeue>>

<<function semwakeup>>

<<function semrelease>>

<<function canacquire>>

<<function semawoke>>

<<function semacquire>>

<<function tsemacquire>>

<<syscall semacquire>>

<<syscall tsemacquire>>

<<syscall semrelease>>

@

\section{[[security/]]}

\subsection*{[[security/portfns_security.h]]}


\ifallcode
<<portfns_security.h>>=

// auth.c
long  userwrite(char*, int);
long  hostdomainwrite(char*, int);
long  hostownerwrite(char*, int);

// and some sysxxx functions
@
\fi

\subsection*{[[security/auth.c]]}

<<auth.c>>=
<<kernel basic includes>>

#include    <authsrv.h>

//char  *eve; now in core/
//int iseve(void) { } now in core/

<<global hostdomain>>

<<syscall fversion>>

<<syscall fauth>>

<<function userwrite>>

<<function hostownerwrite>>

<<function hostdomainwrite>>
@

\section{[[syscalls/]]}

\subsection*{[[syscalls/systab.h]]}





\subsection*{[[syscalls/syscallfmt.c]]}

<<syscallfmt.c>>=
/*
 * Print functions for system call tracing.
 */
<<kernel basic includes>>

#include "../port/systab.h"

<<function fmtrwdata>>

<<function fmtuserstring>>

<<function syscallfmt>>

<<function sysretfmt>>
@


\subsection*{[[syscalls/systab.c]]}

\ifallcode
<<systab.c forward decl>>=
extern Syscall sysnop;
extern Syscall sysbind;
extern Syscall syschdir;
extern Syscall sysclose;
extern Syscall sysdup;
extern Syscall sysalarm;
extern Syscall sysexec;
extern Syscall sysexits;
extern Syscall sysfauth;
extern Syscall syssegbrk;
extern Syscall sysopen;
extern Syscall syssleep;
extern Syscall sysrfork;
extern Syscall syspipe;
extern Syscall syscreate;
extern Syscall sysfd2path;
extern Syscall sysbrk;
extern Syscall sysremove;
extern Syscall sysnotify;
extern Syscall sysnoted;
extern Syscall syssegattach;
extern Syscall syssegdetach;
extern Syscall syssegfree;
extern Syscall syssegflush;
extern Syscall sysrendezvous;
extern Syscall sysunmount;
extern Syscall syssemacquire;
extern Syscall syssemrelease;
extern Syscall sysseek;
extern Syscall sysfversion;
extern Syscall syserrstr;
extern Syscall sysstat;
extern Syscall sysfstat;
extern Syscall syswstat;
extern Syscall sysfwstat;
extern Syscall sysmount;
extern Syscall sysawait;
extern Syscall syspread;
extern Syscall syspwrite;
extern Syscall systsemacquire;
@
\fi

\ifallcode
<<global sysstab>>=
char *sysctab[] = {
    [NOP]     "Nop",
    [BIND]      "Bind",
    [CHDIR]     "Chdir",
    [CLOSE]     "Close",
    [DUP]       "Dup",
    [ALARM]     "Alarm",
    [EXEC]      "Exec",
    [EXITS]     "Exits",
    [FAUTH]     "Fauth",
    [SEGBRK]    "Segbrk",
    [OPEN]      "Open",
    [SLEEP]     "Sleep",
    [RFORK]     "Rfork",
    [PIPE]      "Pipe",
    [CREATE]    "Create",
    [FD2PATH]   "Fd2path",
    [BRK]      "Brk",
    [REMOVE]    "Remove",
    [NOTIFY]    "Notify",
    [NOTED]     "Noted",
    [SEGATTACH] "Segattach",
    [SEGDETACH] "Segdetach",
    [SEGFREE]   "Segfree",
    [SEGFLUSH]  "Segflush",
    [RENDEZVOUS]    "Rendez",
    [UNMOUNT]   "Unmount",
    [SEMACQUIRE]    "Semacquire",
    [SEMRELEASE]    "Semrelease",
    [SEEK]      "Seek",
    [FVERSION]  "Fversion",
    [ERRSTR]    "Errstr",
    [STAT]      "Stat",
    [FSTAT]     "Fstat",
    [WSTAT]     "Wstat",
    [FWSTAT]    "Fwstat",
    [MOUNT]     "Mount",
    [AWAIT]     "Await",
    [PREAD]     "Pread",
    [PWRITE]    "Pwrite",
    [TSEMACQUIRE]   "Tsemacquire",
};
@
\fi

<<systab.c>>=
<<kernel basic includes>>

#include "../port/systab.h"

<<systab.c forward decl>>

//coupling: debuggers/acid/conf/syscall
//coupling: debuggers/acid/conf/truss
<<global systab>>

<<global sysstab>>
@

\ifallcode

\chapter{Extra Extra}

\subsection*{[[buses/portdat_buses.h]]}

<<struct ISAConf>>=
struct ISAConf {
  char  *type;
  ulong port;
  int irq;
  ulong dma;
  ulong mem;
  ulong size;
  ulong freq;

  int nopt;
  char  *opt[NISAOPT];
};
@ 
%this used to be in dat.h, but every arch was defining the same.
% used in port/ (e.g. devaudio.c, usb.h)

<<constant NISAOPT>>=
/*
 *  a parsed plan9.ini line
 */
#define NISAOPT   8
@ 


<<portdat_buses.h>>=

<<constant NISAOPT>>

<<struct ISAConf>>

/*
 *  routines to access UART hardware
 */
struct PhysUart
{
  char* name;
  Uart* (*pnp)(void);
  void  (*enable)(Uart*, int);
  void  (*disable)(Uart*);
  void  (*kick)(Uart*);
  void  (*dobreak)(Uart*, int);
  int (*baud)(Uart*, int);
  int (*bits)(Uart*, int);
  int (*stop)(Uart*, int);
  int (*parity)(Uart*, int);
  void  (*modemctl)(Uart*, int);
  void  (*rts)(Uart*, int);
  void  (*dtr)(Uart*, int);
  long  (*status)(Uart*, void*, long, long);
  void  (*fifo)(Uart*, int);
  void  (*power)(Uart*, int);
  int (*getc)(Uart*); /* polling versions, for iprint, rdb */
  void  (*putc)(Uart*, int);
};

/*
 *  software UART
 */
struct Uart
{
  void* regs;     /* hardware stuff */
  void* saveregs;   /* place to put registers on power down */
  char* name;     /* internal name */
  ulong freq;     /* clock frequency */
  int bits;     /* bits per character */
  int stop;     /* stop bits */
  int parity;     /* even, odd or no parity */
  int baud;     /* baud rate */
  PhysUart*phys;
  bool console;    /* used as a serial console */
  int special;    /* internal kernel device */
  Uart* next;     /* list of allocated uarts */

  QLock;
  int type;     /* ?? */
  int dev;
  int opens;

  int enabled;
  Uart  *elist;     /* next enabled interface */

  int perr;     /* parity errors */
  int ferr;     /* framing errors */
  int oerr;     /* rcvr overruns */
  int berr;     /* no input buffers */
  int serr;     /* input queue overflow */

  /* buffers */
  int (*putc)(Queue*, int);
  Queue *iq;
  Queue *oq;

  Lock  rlock;
  uchar istage[STAGESIZE];
  uchar *iw;
  uchar *ir;
  uchar *ie;

  Lock  tlock;      /* transmit */
  uchar ostage[STAGESIZE];
  uchar *op;
  uchar *oe;
  int drain;

  int modem;      /* hardware flow control on */
  int xonoff;     /* software flow control on */
  int blocked;
  int cts, dsr, dcd;  /* keep track of modem status */ 
  int ctsbackoff;
  int hup_dsr, hup_dcd; /* send hangup upstream? */
  int dohup;

  Rendez  r;
};

extern  Uart* consuart;

extern Dev uartdevtab;
extern PhysUart* physuart[];

//void (*lprint)(char *, int);
@


\subsection*{[[buses/portfns_buses.h]]}

\ifallcode
<<portfns_buses.h>>=

// devuart.c
int   uartgetc(void);
void  uartputs(char*, int);
void  uartrecv(Uart*, char);
int   uartctl(Uart*, char*);
int   uartstageoutput(Uart*);
void  uartkick(void*);

// TODO: move outside main.c?
// <arch>/main.c for now (called from port)
int arch_isaconfig(char*, int, ISAConf*);

@
\fi

\subsection*{[[buses/devuart.c]]}

<<function kbdcr2nl>>=
/*
 *  Called by a uart interrupt for console input.
 *
 *  turn '\r' into '\n' before putting it into the queue.
 */
int
kbdcr2nl(Queue*, int ch)
{
    char *next;

    ilock(&kbd.lockputc);       /* just a mutex */
    if(ch == '\r' && !kbd.raw)
        ch = '\n';
    next = kbd.iw+1;
    if(next >= kbd.ie)
        next = kbd.istage;
    if(next != kbd.ir){
        *kbd.iw = ch;
        kbd.iw = next;
    }
    iunlock(&kbd.lockputc);
    return 0;
}
@ 

\ifallcode
<<devuart.c forward decl>>=
static void uartclock(void);
static void uartflow(void*);
@
\fi

<<constant STAGESIZE(x86)>>=
// used by devuart.c
STAGESIZE = 2048, // default is 64
@

<<devuart.c>>=
<<kernel basic includes>>

#include    "io.h"
#include    "../port/netif.h"

enum
{
    /* soft flow control chars */
    CTLS= 023,
    CTLQ= 021,
};

static Uart* uartlist;
static Uart** uart;
static int uartnuart;
static Dirtab *uartdir;
static int uartndir;
static Timer *uarttimer;

struct Uartalloc {
    Lock;
    Uart *elist;    /* list of enabled interfaces */
} uartalloc;

<<devuart.c forward decl>>

/*
 *  enable/disable uart and add/remove to list of enabled uarts
 */
Uart*
uartenable(Uart *p)
{
    Uart **l;

    if(p->enabled)
        return p;
    if(p->iq == nil){
        if((p->iq = qopen(8*1024, 0, uartflow, p)) == nil)
            return nil;
    }
    else
        qreopen(p->iq);
    if(p->oq == nil){
        if((p->oq = qopen(8*1024, 0, uartkick, p)) == nil){
            qfree(p->iq);
            p->iq = nil;
            return nil;
        }
    }
    else
        qreopen(p->oq);

    p->ir = p->istage;
    p->iw = p->istage;
    p->ie = &p->istage[STAGESIZE];
    p->op = p->ostage;
    p->oe = p->ostage;

    p->hup_dsr = p->hup_dcd = 0;
    p->dsr = p->dcd = 0;

    /* assume we can send */
    p->cts = 1;
    p->ctsbackoff = 0;

    if(p->bits == 0)
        uartctl(p, "l8");
    if(p->stop == 0)
        uartctl(p, "s1");
    if(p->parity == 0)
        uartctl(p, "pn");
    if(p->baud == 0)
        uartctl(p, "b9600");
    (*p->phys->enable)(p, 1);

    /*
     * use ilock because uartclock can otherwise interrupt here
     * and would hang on an attempt to lock uartalloc.
     */
    ilock(&uartalloc);
    for(l = &uartalloc.elist; *l; l = &(*l)->elist){
        if(*l == p)
            break;
    }
    if(*l == 0){
        p->elist = uartalloc.elist;
        uartalloc.elist = p;
    }
    p->enabled = 1;
    iunlock(&uartalloc);

    return p;
}

static void
uartdisable(Uart *p)
{
    Uart **l;

    if(!p->enabled)
        return;
    (*p->phys->disable)(p);

    ilock(&uartalloc);
    for(l = &uartalloc.elist; *l; l = &(*l)->elist){
        if(*l == p){
            *l = p->elist;
            break;
        }
    }
    p->enabled = 0;
    iunlock(&uartalloc);
}


static void
setlength(int i)
{
    Uart *p;

    if(i > 0){
        p = uart[i];
        if(p && p->opens && p->iq)
            uartdir[1+3*i].length = qlen(p->iq);
    } else for(i = 0; i < uartnuart; i++){
        p = uart[i];
        if(p && p->opens && p->iq)
            uartdir[1+3*i].length = qlen(p->iq);
    }
}

/*
 *  set up the '#t' directory
 */
static void
uartreset(void)
{
    int i;
    Dirtab *dp;
    Uart *p, *tail;

    tail = nil;
    for(i = 0; physuart[i] != nil; i++){
        if(physuart[i]->pnp == nil)
            continue;
        if((p = physuart[i]->pnp()) == nil)
            continue;
        if(uartlist != nil)
            tail->next = p;
        else
            uartlist = p;
        for(tail = p; tail->next != nil; tail = tail->next)
            uartnuart++;
        uartnuart++;
    }

    if(uartnuart) {
        uart = xalloc(uartnuart*sizeof(Uart*));
        if (uart == nil)
            panic("uartreset: no memory");
    }

    uartndir = 1 + 3*uartnuart;
    uartdir = xalloc(uartndir * sizeof(Dirtab));
    if (uartdir == nil)
        panic("uartreset: no memory");
    dp = uartdir;
    strcpy(dp->name, ".");
    mkqid(&dp->qid, 0, 0, QTDIR);
    dp->length = 0;
    dp->perm = DMDIR|0555;
    dp++;
    p = uartlist;
    for(i = 0; i < uartnuart; i++){
        /* 3 directory entries per port */
        snprint(dp->name, sizeof dp->name, "eia%d", i);
        dp->qid.path = NETQID(i, Ndataqid);
        dp->perm = 0660;
        dp++;
        snprint(dp->name, sizeof dp->name, "eia%dctl", i);
        dp->qid.path = NETQID(i, Nctlqid);
        dp->perm = 0660;
        dp++;
        snprint(dp->name, sizeof dp->name, "eia%dstatus", i);
        dp->qid.path = NETQID(i, Nstatqid);
        dp->perm = 0444;
        dp++;

        uart[i] = p;
        p->dev = i;
        if(p->console || p->special){
            if(uartenable(p) != nil){
                if(p->console){
                    kbdq = p->iq;
                    serialoq = p->oq;
                    p->putc = kbdcr2nl;
                }
                p->opens++;
            }
        }
        p = p->next;
    }

    if(uartnuart){
        /*
         * at 115200 baud, the 1024 char buffer takes 56 ms to process,
         * processing it every 22 ms should be fine.
         */
        uarttimer = addclock0link(uartclock, 22);
    }
}


static Chan*
uartattach(char *spec)
{
    return devattach('t', spec);
}

static Walkqid*
uartwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, uartdir, uartndir, devgen);
}

static int
uartstat(Chan *c, uchar *dp, int n)
{
    if(NETTYPE(c->qid.path) == Ndataqid)
        setlength(NETID(c->qid.path));
    return devstat(c, dp, n, uartdir, uartndir, devgen);
}

static Chan*
uartopen(Chan *c, int omode)
{
    Uart *p;

    c = devopen(c, omode, uartdir, uartndir, devgen);

    switch(NETTYPE(c->qid.path)){
    case Nctlqid:
    case Ndataqid:
        p = uart[NETID(c->qid.path)];
        qlock(p);
        if(p->opens++ == 0 && uartenable(p) == nil){
            qunlock(p);
            c->flag &= ~COPEN;
            error(Enodev);
        }
        qunlock(p);
        break;
    }

    c->iounit = qiomaxatomic;
    return c;
}

static int
uartdrained(void* arg)
{
    Uart *p;

    p = arg;
    return qlen(p->oq) == 0 && p->op == p->oe;
}

static void
uartdrainoutput(Uart *p)
{
    if(!p->enabled)
        return;

    p->drain = 1;
    if(waserror()){
        p->drain = 0;
        nexterror();
    }
    sleep(&p->r, uartdrained, p);
    poperror();
}

static void
uartclose(Chan *c)
{
    Uart *p;

    if(c->qid.type & QTDIR)
        return;
    if((c->flag & COPEN) == 0)
        return;
    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
    case Nctlqid:
        p = uart[NETID(c->qid.path)];
        qlock(p);
        if(--(p->opens) == 0){
            qclose(p->iq);
            ilock(&p->rlock);
            p->ir = p->iw = p->istage;
            iunlock(&p->rlock);

            /*
             */
            qhangup(p->oq, nil);
            if(!waserror()){
                uartdrainoutput(p);
                poperror();
            }
            qclose(p->oq);
            uartdisable(p);
            p->dcd = p->dsr = p->dohup = 0;
        }
        qunlock(p);
        break;
    }
}

static long
uartread(Chan *c, void *buf, long n, vlong off)
{
    Uart *p;
    ulong offset = off;

    if(c->qid.type & QTDIR){
        setlength(-1);
        return devdirread(c, buf, n, uartdir, uartndir, devgen);
    }

    p = uart[NETID(c->qid.path)];
    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
        return qread(p->iq, buf, n);
    case Nctlqid:
        return readnum(offset, buf, n, NETID(c->qid.path), NUMSIZE);
    case Nstatqid:
        return (*p->phys->status)(p, buf, n, offset);
    }

    return 0;
}

int
uartctl(Uart *p, char *cmd)
{
    char *f[16];
    int i, n, nf;

    nf = tokenize(cmd, f, nelem(f));
    for(i = 0; i < nf; i++){
        if(strncmp(f[i], "break", 5) == 0){
            (*p->phys->dobreak)(p, 0);
            continue;
        }

        n = atoi(f[i]+1);
        switch(*f[i]){
        case 'B':
        case 'b':
            uartdrainoutput(p);
            if((*p->phys->baud)(p, n) < 0)
                return -1;
            break;
        case 'C':
        case 'c':
            p->hup_dcd = n;
            break;
        case 'D':
        case 'd':
            uartdrainoutput(p);
            (*p->phys->dtr)(p, n);
            break;
        case 'E':
        case 'e':
            p->hup_dsr = n;
            break;
        case 'f':
        case 'F':
            if(p->oq != nil)
                qflush(p->oq);
            break;
        case 'H':
        case 'h':
            if(p->iq != nil)
                qhangup(p->iq, 0);
            if(p->oq != nil)
                qhangup(p->oq, 0);
            break;
        case 'i':
        case 'I':
            uartdrainoutput(p);
            (*p->phys->fifo)(p, n);
            break;
        case 'K':
        case 'k':
            uartdrainoutput(p);
            (*p->phys->dobreak)(p, n);
            break;
        case 'L':
        case 'l':
            uartdrainoutput(p);
            if((*p->phys->bits)(p, n) < 0)
                return -1;
            break;
        case 'm':
        case 'M':
            uartdrainoutput(p);
            (*p->phys->modemctl)(p, n);
            break;
        case 'n':
        case 'N':
            if(p->oq != nil)
                qnoblock(p->oq, n);
            break;
        case 'P':
        case 'p':
            uartdrainoutput(p);
            if((*p->phys->parity)(p, *(f[i]+1)) < 0)
                return -1;
            break;
        case 'Q':
        case 'q':
            if(p->iq != nil)
                qsetlimit(p->iq, n);
            if(p->oq != nil)
                qsetlimit(p->oq, n);
            break;
        case 'R':
        case 'r':
            uartdrainoutput(p);
            (*p->phys->rts)(p, n);
            break;
        case 'S':
        case 's':
            uartdrainoutput(p);
            if((*p->phys->stop)(p, n) < 0)
                return -1;
            break;
        case 'W':
        case 'w':
            if(uarttimer == nil || n < 1)
                return -1;
            uarttimer->tns = (vlong)n * 100000LL;
            break;
        case 'X':
        case 'x':
            if(p->enabled){
                ilock(&p->tlock);
                p->xonoff = n;
                iunlock(&p->tlock);
            }
            break;
        }
    }
    return 0;
}

static long
uartwrite(Chan *c, void *buf, long n, vlong)
{
    Uart *p;
    char *cmd;

    if(c->qid.type & QTDIR)
        error(Eperm);

    p = uart[NETID(c->qid.path)];

    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
        qlock(p);
        if(waserror()){
            qunlock(p);
            nexterror();
        }

        n = qwrite(p->oq, buf, n);

        qunlock(p);
        poperror();
        break;
    case Nctlqid:
        cmd = malloc(n+1);
        if(cmd == nil)
            error(Enomem);
        memmove(cmd, buf, n);
        cmd[n] = 0;
        qlock(p);
        if(waserror()){
            qunlock(p);
            free(cmd);
            nexterror();
        }

        /* let output drain */
        if(uartctl(p, cmd) < 0)
            error(Ebadarg);

        qunlock(p);
        poperror();
        free(cmd);
        break;
    }

    return n;
}

static int
uartwstat(Chan *c, uchar *dp, int n)
{
    DirEntry d;
    Dirtab *dt;

    if(!iseve())
        error(Eperm);
    if(QTDIR & c->qid.type)
        error(Eperm);
    if(NETTYPE(c->qid.path) == Nstatqid)
        error(Eperm);

    dt = &uartdir[1 + 3 * NETID(c->qid.path)];
    n = convM2D(dp, n, &d, nil);
    if(n == 0)
        error(Eshortstat);
    if(d.mode != ~0UL)
        dt[0].perm = dt[1].perm = d.mode;
    return n;
}

//void
//uartpower(int on)
//{
//    Uart *p;
//
//    for(p = uartlist; p != nil; p = p->next) {
//        if(p->phys->power)
//            (*p->phys->power)(p, on);
//    }
//}

Dev uartdevtab = {
    .dc       =    't',
    .name     =    "uart",
               
    .reset    =    uartreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    uartattach,
    .walk     =    uartwalk,
    .stat     =    uartstat,
    .open     =    uartopen,
    .create   =    devcreate,
    .close    =    uartclose,
    .read     =    uartread,
    .bread    =    devbread,
    .write    =    uartwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    uartwstat,

//    .power    =    uartpower,
};

/*
 *  restart input if it's off
 */
static void
uartflow(void *v)
{
    Uart *p;

    p = v;
    if(p->modem)
        (*p->phys->rts)(p, 1);
}

/*
 *  put some bytes into the local queue to avoid calling
 *  qconsume for every character
 */
int
uartstageoutput(Uart *p)
{
    int n;

    n = qconsume(p->oq, p->ostage, STAGESIZE);
    if(n <= 0)
        return 0;
    p->op = p->ostage;
    p->oe = p->ostage + n;
    return n;
}

/*
 *  restart output
 */
void
uartkick(void *v)
{
    Uart *p = v;

    if(p->blocked)
        return;

    ilock(&p->tlock);
    (*p->phys->kick)(p);
    iunlock(&p->tlock);

    if(p->drain && uartdrained(p)){
        p->drain = 0;
        wakeup(&p->r);
    }
}

/*
 * Move data from the interrupt staging area to
 * the input Queue.
 */
static void
uartstageinput(Uart *p)
{
    int n;
    uchar *ir, *iw;

    while(p->ir != p->iw){
        ir = p->ir;
        if(p->ir > p->iw){
            iw = p->ie;
            p->ir = p->istage;
        }
        else{
            iw = p->iw;
            p->ir = p->iw;
        }
        if((n = qproduce(p->iq, ir, iw - ir)) < 0){
            p->serr++;
            (*p->phys->rts)(p, 0);
        }
        else if(n == 0)
            p->berr++;
    }
}

/*
 *  receive a character at interrupt time
 */
void
uartrecv(Uart *p,  char ch)
{
    uchar *next;

    /* software flow control */
    if(p->xonoff){
        if(ch == CTLS){
            p->blocked = 1;
        }else if(ch == CTLQ){
            p->blocked = 0;
            p->ctsbackoff = 2; /* clock gets output going again */
        }
    }

    /* receive the character */
    if(p->putc)
        p->putc(p->iq, ch);
    else if (p->iw) {       /* maybe the line isn't enabled yet */
        ilock(&p->rlock);
        next = p->iw + 1;
        if(next == p->ie)
            next = p->istage;
        if(next == p->ir)
            uartstageinput(p);
        if(next != p->ir){
            *p->iw = ch;
            p->iw = next;
        }
        iunlock(&p->rlock);
    }
}

/*
 *  we save up input characters till clock time to reduce
 *  per character interrupt overhead.
 */
static void
uartclock(void)
{
    Uart *p;

    ilock(&uartalloc);
    for(p = uartalloc.elist; p; p = p->elist){

        /* this hopefully amortizes cost of qproduce to many chars */
        if(p->iw != p->ir){
            ilock(&p->rlock);
            uartstageinput(p);
            iunlock(&p->rlock);
        }

        /* hang up if requested */
        if(p->dohup){
            qhangup(p->iq, 0);
            qhangup(p->oq, 0);
            p->dohup = 0;
        }

        /* this adds hysteresis to hardware/software flow control */
        if(p->ctsbackoff){
            ilock(&p->tlock);
            if(p->ctsbackoff){
                if(--(p->ctsbackoff) == 0)
                    (*p->phys->kick)(p);
            }
            iunlock(&p->tlock);
        }
    }
    iunlock(&uartalloc);
}

/*
 * polling console input, output
 */

Uart* consuart;
void (*lprint)(char *, int);

int
uartgetc(void)
{
    if(consuart == nil || consuart->phys->getc == nil)
        return -1;
    return consuart->phys->getc(consuart);
}

void
uartputs(char *s, int n)
{
    char *e;

    if(consuart == nil || consuart->phys->putc == nil) {
        if (lprint)
            (*lprint)(s, n);
        return;
    }
    e = s+n;
    for(; s<e; s++){
        if(*s == '\n')
            consuart->phys->putc(consuart, '\r');
        consuart->phys->putc(consuart, *s);
    }
}
@

%//void
%//uartputc(int c)
%//{
%//  char c2;
%//
%//  if(consuart == nil || consuart->phys->putc == nil) {
%//      c2 = c;
%//      if (lprint)
%//          (*lprint)(&c2, 1);
%//      return;
%//  }
%//  consuart->phys->putc(consuart, c);
%//}


\subsection*{[[console/rdb.c]]}

<<rdb.c debugging macro>>=
#define DBG if(0)scrprint
#pragma varargck argpos scrprint 1
//static Ureg ureg;

static void
scrprint(char *fmt, ...)
{
    char buf[128];
    va_list va;
    int n;

    va_start(va, fmt);
    n = vseprint(buf, buf+sizeof buf, fmt, va)-buf;
    va_end(va);
    putstrn(buf, n);
}
@


<<rdb.c>>=
<<kernel basic includes>>
#include "io.h"
#include <ureg.h>

<<rdb.c debugging macro>>

static char*
getline(void)
{
    static char buf[128];
    int i, c;

    for(;;){
        for(i=0; i<nelem(buf) && (c=uartgetc()) != '\n'; i++){
            DBG("%c...", c);
            buf[i] = c;
        }

        if(i < nelem(buf)){
            buf[i] = 0;
            return buf;
        }
    }
}

static void*
addr(char *s, Ureg *ureg, char **p)
{
    ulong a;

    a = strtoul(s, p, 16);
    if(a < sizeof(Ureg))
        return ((uchar*)ureg)+a;
    return (void*)a;
}

static void
talkrdb(Ureg *ureg)
{
    uchar *a;
    char *p, *req;

    serialoq = nil;     /* turn off serial console */
    kprintoq = nil;     /* turn off /dev/kprint if active */
    DBG("Plan 9 debugger\n");
    iprint("Edebugger reset\n");
    for(;;){
        req = getline();
        switch(*req){
        case 'r':
            a = addr(req+1, ureg, nil);
            DBG("read %p\n", a);
            iprint("R%.8lux %.2ux %.2ux %.2ux %.2ux\n",
                strtoul(req+1, 0, 16), a[0], a[1], a[2], a[3]);
            break;

        case 'w':
            a = addr(req+1, ureg, &p);
            *(ulong*)a = strtoul(p, nil, 16);
            iprint("W\n");
            break;
/*
 *      case Tmput:
            n = min[4];
            if(n > 4){
                mesg(Rerr, Ecount);
                break;
            }
            a = addr(min+0);
            scrprint("mput %.8lux\n", a);
            memmove(a, min+5, n);
            mesg(Rmput, mout);
            break;
 *
 */
        default:
            DBG("unknown %c\n", *req);
            iprint("Eunknown message\n");
            break;
        }
    }
}

void
rdb(void)
{
    arch_splhi();
    iprint("rdb...");
    arch_callwithureg(talkrdb);
}
@


\subsection*{[[console/print.c]]}

<<print.c>>=
<<kernel basic includes>>
// overrides functions defined in lib_core/libc/fmt/fmtlock.c 
// to behave in a special way when libc functions related to fmt
// are called in the kernel.

static Lock fmtl;

//@Scheck: no dead, called from libc
void _fmtlock(void)
{
    lock(&fmtl);
}

//@Scheck: no dead, called from libc
void _fmtunlock(void)
{
    unlock(&fmtl);
}

//@Scheck: no dead, called from libc
int _efgfmt(Fmt*)
{
    return -1;
}
@


\subsection*{[[devices/storage/sd.h]]}

<<sd.h>>=
/*
 * Storage Device.
 */

struct SDperm {
  char* name;
  char* user;
  ulong perm;
};

struct SDpart {
  uvlong  start;
  uvlong  end;
  SDperm;
  int valid;
  ulong vers;
};

struct SDunit {
  SDev* dev;
  int subno;
  uchar inquiry[255];   /* format follows SCSI spec */
  uchar sense[18];    /* format follows SCSI spec */
  SDperm;

  QLock ctl;
  uvlong  sectors;
  ulong secsize;
  SDpart* part;     /* nil or array of size npart */
  int npart;
  ulong vers;
  SDperm  ctlperm;

  QLock raw;      /* raw read or write in progress */
  ulong rawinuse;   /* really just a test-and-set */
  int state;
  SDreq*  req;
  SDperm  rawperm;
};

/*
 * Each controller is represented by a SDev.
 */
struct SDev {
  Ref r;      /* Number of callers using device */
  SDifc*  ifc;      /* pnp/legacy */
  void* ctlr;
  int idno;
  char  name[8];
  SDev* next;

  QLock;        /* enable/disable */
  int enabled;
  int nunit;      /* Number of units */
  QLock unitlock;   /* `Loading' of units */
  int*  unitflg;    /* Unit flags */
  SDunit**unit;
};

struct SDifc {
  char* name;

  SDev* (*pnp)(void);
  SDev* (*legacy)(int, int);
  int (*enable)(SDev*);
  int (*disable)(SDev*);

  int (*verify)(SDunit*);
  int (*online)(SDunit*);
  int (*rio)(SDreq*);
  int (*rctl)(SDunit*, char*, int);
  int (*wctl)(SDunit*, Cmdbuf*);

  long  (*bio)(SDunit*, int, int, void*, long, uvlong);
  SDev* (*probe)(DevConf*);
  void  (*clear)(SDev*);
  char* (*rtopctl)(SDev*, char*, char*);
  int (*wtopctl)(SDev*, Cmdbuf*);
};

struct SDreq {
  SDunit* unit;
  int lun;
  int write;
  uchar cmd[16];
  int clen;
  void* data;
  int dlen;

  int flags;

  int status;
  long  rlen;
  uchar sense[256];
};

enum {
  SDnosense = 0x00000001,
  SDvalidsense  = 0x00010000,

  SDinq0periphqual= 0xe0,
  SDinq0periphtype= 0x1f,
  SDinq1removable = 0x80,

  /* periphtype values */
  SDperdisk = 0,  /* Direct access (disk) */
  SDpertape = 1,  /* Sequential eg, tape */
  SDperpr   = 2,  /* Printer */
  SDperworm = 4,  /* Worm */
  SDpercd   = 5,  /* CD-ROM */
  SDpermo   = 7,  /* rewriteable MO */
  SDperjuke = 8,  /* medium-changer */
};

enum {
  SDretry   = -5,   /* internal to controllers */
  SDmalloc  = -4,
  SDeio   = -3,
  SDtimeout = -2,
  SDnostatus  = -1,

  SDok    = 0,

  SDcheck   = 0x02,   /* check condition */
  SDbusy    = 0x08,   /* busy */

  SDmaxio   = 2048*1024,
  SDnpart   = 16,
};

/*
 * Allow the default #defines for sdmalloc & sdfree to be overridden by
 * system-specific versions.  This can be used to avoid extra copying
 * by making sure sd buffers are cache-aligned (some ARM systems) or
 * page-aligned (xen) for DMA.
 */
#ifdef sdmalloc
#else
#define sdmalloc(n) malloc(n)
#define sdfree(p) free(p)
#endif

/*
 * mmc/sd/sdio host controller interface
 */
struct SDio {
 char	*name;
 int	(*init)(void);
 void	(*enable)(void);
 int	(*inquiry)(char*, int);
 int	(*cmd)(u32int, u32int, u32int*);
 void	(*iosetup)(int, void*, int, int);
 void	(*io)(int, uchar*, int);
};

extern SDio sdio;

/* sdscsi.c */
extern int scsiverify(SDunit*);
extern int scsionline(SDunit*);
extern long scsibio(SDunit*, int, int, void*, long, uvlong);
//extern SDev* scsiid(SDev*, SDifc*);
@

%//struct SDio {
%//  char  *name;
%//  int (*init)(void);
%//  void  (*enable)(void);
%//  int (*inquiry)(char*, int);
%//  int (*cmd)(u32int, u32int, u32int*);
%//  void  (*iosetup)(int, void*, int, int);
%//  void  (*io)(int, uchar*, int);
%//};
%//
%//extern SDio sdio;
%
%/* devsd.c */
%//extern void sdadddevs(SDev*);
%//extern void sdaddconf(SDunit*);
%//extern void sdaddallconfs(void (*f)(SDunit*));
%//extern void sdaddpart(SDunit*, char*, uvlong, uvlong);
%//extern int sdsetsense(SDreq*, int, int, int, int);
%//extern int sdmodesense(SDreq*, uchar*, void*, int);
%//extern int sdfakescsi(SDreq*, void*, int);



\subsection*{[[devices/storage/devsd.c]]}

% sd for storage device. 
% Then get some specific devices such as sdata or sdmmc

\ifallcode
<<devsd.c forward decl>>=
extern void sdaddpart(SDunit*, char*, uvlong, uvlong);
extern void sdadddevs(SDev*);
@
\fi

%//extern int sdsetsense(SDreq*, int, int, int, int);
%//extern int sdmodesense(SDreq*, uchar*, void*, int);

% very big for now so skip

<<global sddevtab>>=
Dev sddevtab = {
    .dc       =    'S',
    .name     =    "sd",
               
    .reset    =    sdreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    sdattach,
    .walk     =    sdwalk,
    .stat     =    sdstat,
    .open     =    sdopen,
    .create   =    devcreate,
    .close    =    sdclose,
    .read     =    sdread,
    .bread    =    devbread,
    .write    =    sdwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    sdwstat,

//    .power    = devpower,
//    .config   = sdconfig,   /* probe; only called for pcmcia-like devices */
};
@

\ifallcode
<<devsd.c>>=
/*
 * Storage Device.
 */
<<kernel basic includes>>

#include "io.h"
#include "../port/sd.h"

#include <ureg.h>

extern Dev sddevtab;
extern SDifc* sdifc[];

static char devletters[] = "0123456789"
    "abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

static SDev *devs[sizeof devletters-1];
static QLock devslock;

<<devsd.c forward decl>>

enum {
    Rawcmd,
    Rawdata,
    Rawstatus,
};

enum {
    Qtopdir     = 1,        /* top level directory */
    Qtopbase,
    Qtopctl      = Qtopbase,

    Qunitdir,           /* directory per unit */
    Qunitbase,
    Qctl        = Qunitbase,
    Qraw,
    Qpart,

    TypeLOG     = 4,
    NType       = (1<<TypeLOG),
    TypeMASK    = (NType-1),
    TypeSHIFT   = 0,

    PartLOG     = 8,
    NPart       = (1<<PartLOG),
    PartMASK    = (NPart-1),
    PartSHIFT   = TypeLOG,

    UnitLOG     = 8,
    NUnit       = (1<<UnitLOG),
    UnitMASK    = (NUnit-1),
    UnitSHIFT   = (PartLOG+TypeLOG),

    DevLOG      = 8,
    NDev        = (1 << DevLOG),
    DevMASK     = (NDev-1),
    DevSHIFT     = (UnitLOG+PartLOG+TypeLOG),

    Ncmd = 20,
};

#define TYPE(q)     ((((ulong)(q).path)>>TypeSHIFT) & TypeMASK)
#define PART(q)     ((((ulong)(q).path)>>PartSHIFT) & PartMASK)
#define UNIT(q)     ((((ulong)(q).path)>>UnitSHIFT) & UnitMASK)
#define DEV(q)      ((((ulong)(q).path)>>DevSHIFT) & DevMASK)
#define QID(d,u, p, t)  (((d)<<DevSHIFT)|((u)<<UnitSHIFT)|\
                     ((p)<<PartSHIFT)|((t)<<TypeSHIFT))


void
sdaddpart(SDunit* unit, char* name, uvlong start, uvlong end)
{
    SDpart *pp;
    int i, partno;

    /*
     * Check name not already used
     * and look for a free slot.
     */
    if(unit->part != nil){
        partno = -1;
        for(i = 0; i < unit->npart; i++){
            pp = &unit->part[i];
            if(!pp->valid){
                if(partno == -1)
                    partno = i;
                break;
            }
            if(strcmp(name, pp->name) == 0){
                if(pp->start == start && pp->end == end)
                    return;
                error(Ebadctl);
            }
        }
    }
    else{
        if((unit->part = malloc(sizeof(SDpart)*SDnpart)) == nil)
            error(Enomem);
        unit->npart = SDnpart;
        partno = 0;
    }

    /*
     * If no free slot found then increase the
     * array size (can't get here with unit->part == nil).
     */
    if(partno == -1){
        if(unit->npart >= NPart)
            error(Enomem);
        if((pp = malloc(sizeof(SDpart)*(unit->npart+SDnpart))) == nil)
            error(Enomem);
        memmove(pp, unit->part, sizeof(SDpart)*unit->npart);
        free(unit->part);
        unit->part = pp;
        partno = unit->npart;
        unit->npart += SDnpart;
    }

    /*
     * Check size and extent are valid.
     */
    if(start > end || end > unit->sectors)
        error(Eio);
    pp = &unit->part[partno];
    pp->start = start;
    pp->end = end;
    kstrdup(&pp->name, name);
    kstrdup(&pp->user, eve);
    pp->perm = 0640;
    pp->valid = 1;
}

static void
sddelpart(SDunit* unit, char* name)
{
    int i;
    SDpart *pp;

    /*
     * Look for the partition to delete.
     * Can't delete if someone still has it open.
     */
    pp = unit->part;
    for(i = 0; i < unit->npart; i++){
        if(strcmp(name, pp->name) == 0)
            break;
        pp++;
    }
    if(i >= unit->npart)
        error(Ebadctl);
    if(strcmp(up->user, pp->user) && !iseve())
        error(Eperm);
    pp->valid = 0;
    pp->vers++;
}

static void
sdincvers(SDunit *unit)
{
    int i;

    unit->vers++;
    if(unit->part){
        for(i = 0; i < unit->npart; i++){
            unit->part[i].valid = 0;
            unit->part[i].vers++;
        }
    }
}

static int
sdinitpart(SDunit* unit)
{
    int nf;
    uvlong start, end;
    char *f[4], *p, *q, buf[10];

    if(unit->sectors > 0){
        unit->sectors = unit->secsize = 0;
        sdincvers(unit);
    }

    /* device must be connected or not; other values are trouble */
    if(unit->inquiry[0] & 0xC0) /* see SDinq0periphqual */
        return 0;
    switch(unit->inquiry[0] & SDinq0periphtype){
    case SDperdisk:
    case SDperworm:
    case SDpercd:
    case SDpermo:
        break;
    default:
        return 0;
    }

    if(unit->dev->ifc->online)
        unit->dev->ifc->online(unit);
    if(unit->sectors){
        sdincvers(unit);
        sdaddpart(unit, "data", 0, unit->sectors);

        /*
         * Use partitions passed from boot program,
         * e.g.
         *  sdC0part=dos 63 123123/plan9 123123 456456
         * This happens before /boot sets hostname so the
         * partitions will have the null-string for user.
         * The gen functions patch it up.
         */
        snprint(buf, sizeof buf, "%spart", unit->name);
        for(p = getconf(buf); p != nil; p = q){
            if(q = strchr(p, '/'))
                *q++ = '\0';
            nf = tokenize(p, f, nelem(f));
            if(nf < 3)
                continue;

            start = strtoull(f[1], 0, 0);
            end = strtoull(f[2], 0, 0);
            if(!waserror()){
                sdaddpart(unit, f[0], start, end);
                poperror();
            }
        }
    }

    return 1;
}

static int
sdindex(int idno)
{
    char *p;

    p = strchr(devletters, idno);
    if(p == nil)
        return -1;
    return p-devletters;
}

static SDev*
sdgetdev(int idno)
{
    SDev *sdev;
    int i;

    if((i = sdindex(idno)) < 0)
        return nil;

    qlock(&devslock);
    if(sdev = devs[i])
        incref(&sdev->r);
    qunlock(&devslock);
    return sdev;
}

static SDunit*
sdgetunit(SDev* sdev, int subno)
{
    SDunit *unit;
    char buf[32];

    /*
     * Associate a unit with a given device and sub-unit
     * number on that device.
     * The device will be probed if it has not already been
     * successfully accessed.
     */
    qlock(&sdev->unitlock);
    if(subno > sdev->nunit){
        qunlock(&sdev->unitlock);
        return nil;
    }

    unit = sdev->unit[subno];
    if(unit == nil){
        /*
         * Probe the unit only once. This decision
         * may be a little severe and reviewed later.
         */
        if(sdev->unitflg[subno]){
            qunlock(&sdev->unitlock);
            return nil;
        }
        if((unit = malloc(sizeof(SDunit))) == nil){
            qunlock(&sdev->unitlock);
            return nil;
        }
        sdev->unitflg[subno] = 1;

        snprint(buf, sizeof(buf), "%s%d", sdev->name, subno);
        kstrdup(&unit->name, buf);
        kstrdup(&unit->user, eve);
        unit->perm = 0555;
        unit->subno = subno;
        unit->dev = sdev;

        if(sdev->enabled == 0 && sdev->ifc->enable)
            sdev->ifc->enable(sdev);
        sdev->enabled = 1;

        /*
         * No need to lock anything here as this is only
         * called before the unit is made available in the
         * sdunit[] array.
         */
        if(unit->dev->ifc->verify(unit) == 0){
            qunlock(&sdev->unitlock);
            free(unit);
            return nil;
        }
        sdev->unit[subno] = unit;
    }
    qunlock(&sdev->unitlock);
    return unit;
}

static void
sdreset(void)
{
    int i;
    SDev *sdev;

    /*
     * Probe all known controller types and register any devices found.
     */
    for(i = 0; sdifc[i] != nil; i++){
        if(sdifc[i]->pnp == nil || (sdev = sdifc[i]->pnp()) == nil)
            continue;
        sdadddevs(sdev);
    }
}

void
sdadddevs(SDev *sdev)
{
    int i, j, id;
    SDev *next;

    for(; sdev; sdev=next){
        next = sdev->next;

        sdev->unit = (SDunit**)malloc(sdev->nunit * sizeof(SDunit*));
        sdev->unitflg = (int*)malloc(sdev->nunit * sizeof(int));
        if(sdev->unit == nil || sdev->unitflg == nil){
            print("sdadddevs: out of memory\n");
        giveup:
            free(sdev->unit);
            free(sdev->unitflg);
            if(sdev->ifc->clear)
                sdev->ifc->clear(sdev);
            free(sdev);
            continue;
        }
        id = sdindex(sdev->idno);
        if(id == -1){
            print("sdadddevs: bad id number %d (%C)\n", id, id);
            goto giveup;
        }
        qlock(&devslock);
        for(i=0; i<nelem(devs); i++){
            if(devs[j = (id+i)%nelem(devs)] == nil){
                sdev->idno = devletters[j];
                devs[j] = sdev;
                snprint(sdev->name, sizeof sdev->name, "sd%c", devletters[j]);
                break;
            }
        }
        qunlock(&devslock);
        if(i == nelem(devs)){
            print("sdadddevs: out of device letters\n");
            goto giveup;
        }
    }
}

static int
sd2gen(Chan* c, int i, DirEntry* dp)
{
    Qid q;
    uvlong l;
    SDpart *pp;
    SDperm *perm;
    SDunit *unit;
    SDev *sdev;
    int rv;

    sdev = sdgetdev(DEV(c->qid));
    assert(sdev);
    unit = sdev->unit[UNIT(c->qid)];

    rv = -1;
    switch(i){
    case Qctl:
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qctl),
            unit->vers, QTFILE);
        perm = &unit->ctlperm;
        if(emptystr(perm->user)){
            kstrdup(&perm->user, eve);
            perm->perm = 0644;  /* nothing secret in ctl */
        }
        devdir(c, q, "ctl", 0, perm->user, perm->perm, dp);
        rv = 1;
        break;

    case Qraw:
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qraw),
            unit->vers, QTFILE);
        perm = &unit->rawperm;
        if(emptystr(perm->user)){
            kstrdup(&perm->user, eve);
            perm->perm = DMEXCL|0600;
        }
        devdir(c, q, "raw", 0, perm->user, perm->perm, dp);
        rv = 1;
        break;

    case Qpart:
        pp = &unit->part[PART(c->qid)];
        l = (pp->end - pp->start) * unit->secsize;
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qpart),
            unit->vers+pp->vers, QTFILE);
        if(emptystr(pp->user))
            kstrdup(&pp->user, eve);
        devdir(c, q, pp->name, l, pp->user, pp->perm, dp);
        rv = 1;
        break;
    }

    decref(&sdev->r);
    return rv;
}

static int
sd1gen(Chan* c, int i, DirEntry* dp)
{
    Qid q;

    switch(i){
    case Qtopctl:
        mkqid(&q, QID(0, 0, 0, Qtopctl), 0, QTFILE);
        devdir(c, q, "sdctl", 0, eve, 0644, dp);    /* no secrets */
        return 1;
    }
    return -1;
}

static int
sdgen(Chan* c, char*, Dirtab*, int, int s, DirEntry* dp)
{
    Qid q;
    uvlong l;
    int i, r;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;

    switch(TYPE(c->qid)){
    case Qtopdir:
        if(s == DEVDOTDOT){
            mkqid(&q, QID(0, 0, 0, Qtopdir), 0, QTDIR);
            snprint(up->genbuf, sizeof up->genbuf, "#%C",
                sddevtab.dc);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            return 1;
        }

        if(s+Qtopbase < Qunitdir)
            return sd1gen(c, s+Qtopbase, dp);
        s -= (Qunitdir-Qtopbase);

        qlock(&devslock);
        for(i=0; i<nelem(devs); i++){
            if(devs[i]){
                if(s < devs[i]->nunit)
                    break;
                s -= devs[i]->nunit;
            }
        }

        if(i == nelem(devs)){
            /* Run off the end of the list */
            qunlock(&devslock);
            return -1;
        }

        if((sdev = devs[i]) == nil){
            qunlock(&devslock);
            return 0;
        }

        incref(&sdev->r);
        qunlock(&devslock);

        if((unit = sdev->unit[s]) == nil)
            if((unit = sdgetunit(sdev, s)) == nil){
                decref(&sdev->r);
                return 0;
            }

        mkqid(&q, QID(sdev->idno, s, 0, Qunitdir), 0, QTDIR);
        if(emptystr(unit->user))
            kstrdup(&unit->user, eve);
        devdir(c, q, unit->name, 0, unit->user, unit->perm, dp);
        decref(&sdev->r);
        return 1;

    case Qunitdir:
        if(s == DEVDOTDOT){
            mkqid(&q, QID(0, 0, 0, Qtopdir), 0, QTDIR);
            snprint(up->genbuf, sizeof up->genbuf, "#%C",
                sddevtab.dc);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            return 1;
        }

        if((sdev = sdgetdev(DEV(c->qid))) == nil){
            devdir(c, c->qid, "unavailable", 0, eve, 0, dp);
            return 1;
        }

        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->ctl);

        /*
         * Check for media change.
         * If one has already been detected, sectors will be zero.
         * If there is one waiting to be detected, online
         * will return > 1.
         * Online is a bit of a large hammer but does the job.
         */
        if(unit->sectors == 0
        || (unit->dev->ifc->online && unit->dev->ifc->online(unit) > 1))
            sdinitpart(unit);

        i = s+Qunitbase;
        if(i < Qpart){
            r = sd2gen(c, i, dp);
            qunlock(&unit->ctl);
            decref(&sdev->r);
            return r;
        }
        i -= Qpart;
        if(unit->part == nil || i >= unit->npart){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            break;
        }
        pp = &unit->part[i];
        if(!pp->valid){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            return 0;
        }
        l = (pp->end - pp->start) * unit->secsize;
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), i, Qpart),
            unit->vers+pp->vers, QTFILE);
        if(emptystr(pp->user))
            kstrdup(&pp->user, eve);
        devdir(c, q, pp->name, l, pp->user, pp->perm, dp);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        return 1;
    case Qraw:
    case Qctl:
    case Qpart:
        if((sdev = sdgetdev(DEV(c->qid))) == nil){
            devdir(c, q, "unavailable", 0, eve, 0, dp);
            return 1;
        }
        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->ctl);
        r = sd2gen(c, TYPE(c->qid), dp);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        return r;
    case Qtopctl:
        return sd1gen(c, TYPE(c->qid), dp);
    default:
        break;
    }

    return -1;
}

static Chan*
sdattach(char* spec)
{
    Chan *c;
    char *p;
    SDev *sdev;
    int idno, subno;

    if(*spec == '\0'){
        c = devattach(sddevtab.dc, spec);
        mkqid(&c->qid, QID(0, 0, 0, Qtopdir), 0, QTDIR);
        return c;
    }

    if(spec[0] != 's' || spec[1] != 'd')
        error(Ebadspec);
    idno = spec[2];
    subno = strtol(&spec[3], &p, 0);
    if(p == &spec[3])
        error(Ebadspec);

    if((sdev=sdgetdev(idno)) == nil)
        error(Enonexist);
    if(sdgetunit(sdev, subno) == nil){
        decref(&sdev->r);
        error(Enonexist);
    }

    c = devattach(sddevtab.dc, spec);
    mkqid(&c->qid, QID(sdev->idno, subno, 0, Qunitdir), 0, QTDIR);
    c->dev = (sdev->idno << UnitLOG) + subno;
    decref(&sdev->r);
    return c;
}

static Walkqid*
sdwalk(Chan* c, Chan* nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, nil, 0, sdgen);
}

static int
sdstat(Chan* c, uchar* db, int n)
{
    return devstat(c, db, n, nil, 0, sdgen);
}

static Chan*
sdopen(Chan* c, int omode)
{
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    uchar tp;

    c = devopen(c, omode, 0, 0, sdgen);
    if((tp = TYPE(c->qid)) != Qctl && tp != Qraw && tp != Qpart)
        return c;

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil)
        error(Enonexist);

    unit = sdev->unit[UNIT(c->qid)];

    switch(TYPE(c->qid)){
    case Qctl:
        c->qid.vers = unit->vers;
        break;
    case Qraw:
        c->qid.vers = unit->vers;
        if(arch_tas(&unit->rawinuse) != 0){
            c->flag &= ~COPEN;
            decref(&sdev->r);
            error(Einuse);
        }
        unit->state = Rawcmd;
        break;
    case Qpart:
        qlock(&unit->ctl);
        if(waserror()){
            qunlock(&unit->ctl);
            c->flag &= ~COPEN;
            decref(&sdev->r);
            nexterror();
        }
        pp = &unit->part[PART(c->qid)];
        c->qid.vers = unit->vers+pp->vers;
        qunlock(&unit->ctl);
        poperror();
        break;
    }
    decref(&sdev->r);
    return c;
}

static void
sdclose(Chan* c)
{
    SDunit *unit;
    SDev *sdev;

    if(c->qid.type & QTDIR)
        return;
    if(!(c->flag & COPEN))
        return;

    switch(TYPE(c->qid)){
    default:
        break;
    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev){
            unit = sdev->unit[UNIT(c->qid)];
            unit->rawinuse = 0;
            decref(&sdev->r);
        }
        break;
    }
}

static long
sdbio(Chan* c, int write, char* a, long len, uvlong off)
{
    int nchange;
    long l;
    uchar *b;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    ulong max, nb, offset;
    uvlong bno;

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil){
        decref(&sdev->r);
        error(Enonexist);
    }
    unit = sdev->unit[UNIT(c->qid)];
    if(unit == nil)
        error(Enonexist);

    nchange = 0;
    qlock(&unit->ctl);
    while(waserror()){
        /* notification of media change; go around again */
        if(strcmp(up->errstr, Eio) == 0 && unit->sectors == 0 && nchange++ == 0){
            sdinitpart(unit);
            continue;
        }

        /* other errors; give up */
        qunlock(&unit->ctl);
        decref(&sdev->r);
        nexterror();
    }
    pp = &unit->part[PART(c->qid)];
    if(unit->vers+pp->vers != c->qid.vers)
        error(Echange);

    /*
     * Check the request is within bounds.
     * Removeable drives are locked throughout the I/O
     * in case the media changes unexpectedly.
     * Non-removeable drives are not locked during the I/O
     * to allow the hardware to optimise if it can; this is
     * a little fast and loose.
     * It's assumed that non-removeable media parameters
     * (sectors, secsize) can't change once the drive has
     * been brought online.
     */
    bno = (off/unit->secsize) + pp->start;
    nb = ((off+len+unit->secsize-1)/unit->secsize) + pp->start - bno;
    max = SDmaxio/unit->secsize;
    if(nb > max)
        nb = max;
    if(bno+nb > pp->end)
        nb = pp->end - bno;
    if(bno >= pp->end || nb == 0){
        if(write)
            error(Eio);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        poperror();
        return 0;
    }
    if(!(unit->inquiry[1] & SDinq1removable)){
        qunlock(&unit->ctl);
        poperror();
    }

    b = sdmalloc(nb*unit->secsize);
    if(b == nil)
        error(Enomem);
    if(waserror()){
        sdfree(b);
        if(!(unit->inquiry[1] & SDinq1removable))
            decref(&sdev->r);       /* gadverdamme! */
        nexterror();
    }

    offset = off%unit->secsize;
    if(offset+len > nb*unit->secsize)
        len = nb*unit->secsize - offset;
    if(write){
        if(offset || (len%unit->secsize)){
            l = unit->dev->ifc->bio(unit, 0, 0, b, nb, bno);
            if(l < 0)
                error(Eio);
            if(l < (nb*unit->secsize)){
                nb = l/unit->secsize;
                l = nb*unit->secsize - offset;
                if(len > l)
                    len = l;
            }
        }
        memmove(b+offset, a, len);
        l = unit->dev->ifc->bio(unit, 0, 1, b, nb, bno);
        if(l < 0)
            error(Eio);
        if(l < offset)
            len = 0;
        else if(len > l - offset)
            len = l - offset;
    }
    else{
        l = unit->dev->ifc->bio(unit, 0, 0, b, nb, bno);
        if(l < 0)
            error(Eio);
        if(l < offset)
            len = 0;
        else if(len > l - offset)
            len = l - offset;
        memmove(a, b+offset, len);
    }
    sdfree(b);
    poperror();

    if(unit->inquiry[1] & SDinq1removable){
        qunlock(&unit->ctl);
        poperror();
    }

    decref(&sdev->r);
    return len;
}

static long
sdrio(SDreq* r, void* a, long n)
{
    void *data;

    if(n >= SDmaxio || n < 0)
        error(Etoobig);

    data = nil;
    if(n){
        if((data = sdmalloc(n)) == nil)
            error(Enomem);
        if(r->write)
            memmove(data, a, n);
    }
    r->data = data;
    r->dlen = n;

    if(waserror()){
        sdfree(data);
        r->data = nil;
        nexterror();
    }

    if(r->unit->dev->ifc->rio(r) != SDok)
        error(Eio);

    if(!r->write && r->rlen > 0)
        memmove(a, data, r->rlen);
    sdfree(data);
    r->data = nil;
    poperror();

    return r->rlen;
}

static long
sdread(Chan *c, void *a, long n, vlong off)
{
    char *p, *e, *buf;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    ulong offset;
    int i, l, m, status;

    offset = off;
    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qtopctl:
        m = 64*1024;    /* room for register dumps */
        p = buf = malloc(m);
        if(p == nil)
            error(Enomem);
        e = p + m;
        qlock(&devslock);
        for(i = 0; i < nelem(devs); i++){
            sdev = devs[i];
            if(sdev && sdev->ifc->rtopctl)
                p = sdev->ifc->rtopctl(sdev, p, e);
        }
        qunlock(&devslock);
        n = readstr(off, a, n, buf);
        free(buf);
        return n;

    case Qtopdir:
    case Qunitdir:
        return devdirread(c, a, n, 0, 0, sdgen);

    case Qctl:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);

        unit = sdev->unit[UNIT(c->qid)];
        m = 16*1024;    /* room for register dumps */
        p = malloc(m);
        if(p == nil)
            error(Enomem);
        l = snprint(p, m, "inquiry %.48s\n",
            (char*)unit->inquiry+8);
        qlock(&unit->ctl);
        /*
         * If there's a device specific routine it must
         * provide all information pertaining to night geometry
         * and the garscadden trains.
         */
        if(unit->dev->ifc->rctl)
            l += unit->dev->ifc->rctl(unit, p+l, m-l);
        if(unit->sectors == 0)
            sdinitpart(unit);
        if(unit->sectors){
            if(unit->dev->ifc->rctl == nil)
                l += snprint(p+l, m-l,
                    "geometry %llud %lud\n",
                    unit->sectors, unit->secsize);
            pp = unit->part;
            for(i = 0; i < unit->npart; i++){
                if(pp->valid)
                    l += snprint(p+l, m-l,
                        "part %s %llud %llud\n",
                        pp->name, pp->start, pp->end);
                pp++;
            }
        }
        qunlock(&unit->ctl);
        decref(&sdev->r);
        l = readstr(offset, a, n, p);
        free(p);
        return l;

    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);

        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->raw);
        if(waserror()){
            qunlock(&unit->raw);
            decref(&sdev->r);
            nexterror();
        }
        if(unit->state == Rawdata){
            unit->state = Rawstatus;
            i = sdrio(unit->req, a, n);
        }
        else if(unit->state == Rawstatus){
            status = unit->req->status;
            unit->state = Rawcmd;
            free(unit->req);
            unit->req = nil;
            i = readnum(0, a, n, status, NUMSIZE);
        } else
            i = 0;
        qunlock(&unit->raw);
        decref(&sdev->r);
        poperror();
        return i;

    case Qpart:
        return sdbio(c, 0, a, n, off);
    }
}

static void legacytopctl(Cmdbuf*);

static long
sdwrite(Chan* c, void* a, long n, vlong off)
{
    char *f0;
    int i;
    uvlong end, start;
    Cmdbuf *cb;
    SDifc *ifc;
    SDreq *req;
    SDunit *unit;
    SDev *sdev;

    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qtopctl:
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        if(cb->nf == 0)
            error("empty control message");
        f0 = cb->f[0];
        cb->f++;
        cb->nf--;
        if(strcmp(f0, "config") == 0){
            /* wormhole into ugly legacy interface */
            legacytopctl(cb);
            poperror();
            free(cb);
            break;
        }
        /*
         * "ata arg..." invokes sdifc[i]->wtopctl(nil, cb),
         * where sdifc[i]->name=="ata" and cb contains the args.
         */
        ifc = nil;
        sdev = nil;
        for(i=0; sdifc[i]; i++){
            if(strcmp(sdifc[i]->name, f0) == 0){
                ifc = sdifc[i];
                sdev = nil;
                goto subtopctl;
            }
        }
        /*
         * "sd1 arg..." invokes sdifc[i]->wtopctl(sdev, cb),
         * where sdifc[i] and sdev match controller letter "1",
         * and cb contains the args.
         */
        if(f0[0]=='s' && f0[1]=='d' && f0[2] && f0[3] == 0){
            if((sdev = sdgetdev(f0[2])) != nil){
                ifc = sdev->ifc;
                goto subtopctl;
            }
        }
        error("unknown interface");

    subtopctl:
        if(waserror()){
            if(sdev)
                decref(&sdev->r);
            nexterror();
        }
        if(ifc->wtopctl)
            ifc->wtopctl(sdev, cb);
        else
            error(Ebadctl);
        poperror();
        poperror();
        if (sdev)
            decref(&sdev->r);
        free(cb);
        break;

    case Qctl:
        cb = parsecmd(a, n);
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);
        unit = sdev->unit[UNIT(c->qid)];

        qlock(&unit->ctl);
        if(waserror()){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            free(cb);
            nexterror();
        }
        if(unit->vers != c->qid.vers)
            error(Echange);

        if(cb->nf < 1)
            error(Ebadctl);
        if(strcmp(cb->f[0], "part") == 0){
            if(cb->nf != 4)
                error(Ebadctl);
            if(unit->sectors == 0 && !sdinitpart(unit))
                error(Eio);
            start = strtoull(cb->f[2], 0, 0);
            end = strtoull(cb->f[3], 0, 0);
            sdaddpart(unit, cb->f[1], start, end);
        }
        else if(strcmp(cb->f[0], "delpart") == 0){
            if(cb->nf != 2 || unit->part == nil)
                error(Ebadctl);
            sddelpart(unit, cb->f[1]);
        }
        else if(unit->dev->ifc->wctl)
            unit->dev->ifc->wctl(unit, cb);
        else
            error(Ebadctl);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        poperror();
        free(cb);
        break;

    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);
        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->raw);
        if(waserror()){
            qunlock(&unit->raw);
            decref(&sdev->r);
            nexterror();
        }
        switch(unit->state){
        case Rawcmd:
            if(n < 6 || n > sizeof(req->cmd))
                error(Ebadarg);
            if((req = malloc(sizeof(SDreq))) == nil)
                error(Enomem);
            req->unit = unit;
            memmove(req->cmd, a, n);
            req->clen = n;
            req->flags = SDnosense;
            req->status = ~0;

            unit->req = req;
            unit->state = Rawdata;
            break;

        case Rawstatus:
            unit->state = Rawcmd;
            free(unit->req);
            unit->req = nil;
            error(Ebadusefd);

        case Rawdata:
            unit->state = Rawstatus;
            unit->req->write = 1;
            n = sdrio(unit->req, a, n);
        }
        qunlock(&unit->raw);
        decref(&sdev->r);
        poperror();
        break;
    case Qpart:
        return sdbio(c, 1, a, n, off);
    }

    return n;
}

static int
sdwstat(Chan* c, uchar* dp, int n)
{
    DirEntry *d;
    SDpart *pp;
    SDperm *perm;
    SDunit *unit;
    SDev *sdev;

    if(c->qid.type & QTDIR)
        error(Eperm);

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil)
        error(Enonexist);
    unit = sdev->unit[UNIT(c->qid)];
    qlock(&unit->ctl);
    d = nil;
    if(waserror()){
        free(d);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        nexterror();
    }

    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qctl:
        perm = &unit->ctlperm;
        break;
    case Qraw:
        perm = &unit->rawperm;
        break;
    case Qpart:
        pp = &unit->part[PART(c->qid)];
        if(unit->vers+pp->vers != c->qid.vers)
            error(Enonexist);
        perm = &pp->SDperm;
        break;
    }

    if(strcmp(up->user, perm->user) && !iseve())
        error(Eperm);

    d = smalloc(sizeof(DirEntry)+n);
    n = convM2D(dp, n, &d[0], (char*)&d[1]);
    if(n == 0)
        error(Eshortstat);
    if(!emptystr(d[0].uid))
        kstrdup(&perm->user, d[0].uid);
    if(d[0].mode != ~0UL)
        perm->perm = (perm->perm & ~0777) | (d[0].mode & 0777);

    free(d);
    qunlock(&unit->ctl);
    decref(&sdev->r);
    poperror();
    return n;
}

static int
configure(char* spec, DevConf* cf)
{
    SDev *s, *sdev;
    char *p;
    int i;

    if(sdindex(*spec) < 0)
        error("bad sd spec");

    if((p = strchr(cf->type, '/')) != nil)
        *p++ = '\0';

    for(i = 0; sdifc[i] != nil; i++)
        if(strcmp(sdifc[i]->name, cf->type) == 0)
            break;
    if(sdifc[i] == nil)
        error("sd type not found");
    if(p)
        *(p-1) = '/';

    if(sdifc[i]->probe == nil)
        error("sd type cannot probe");

    sdev = sdifc[i]->probe(cf);
    for(s=sdev; s; s=s->next)
        s->idno = *spec;
    sdadddevs(sdev);
    return 0;
}

static int
unconfigure(char* spec)
{
    int i;
    SDev *sdev;
    SDunit *unit;

    if((i = sdindex(*spec)) < 0)
        error(Enonexist);

    qlock(&devslock);
    if((sdev = devs[i]) == nil){
        qunlock(&devslock);
        error(Enonexist);
    }
    if(sdev->r.ref){
        qunlock(&devslock);
        error(Einuse);
    }
    devs[i] = nil;
    qunlock(&devslock);

    /* make sure no interrupts arrive anymore before removing resources */
    if(sdev->enabled && sdev->ifc->disable)
        sdev->ifc->disable(sdev);

    for(i = 0; i != sdev->nunit; i++){
        if(unit = sdev->unit[i]){
            free(unit->name);
            free(unit->user);
            free(unit);
        }
    }

    if(sdev->ifc->clear)
        sdev->ifc->clear(sdev);
    free(sdev);
    return 0;
}

static int
sdconfig(int on, char* spec, DevConf* cf)
{
    if(on)
        return configure(spec, cf);
    return unconfigure(spec);
}

<<global sddevtab>>

/*
 * This is wrong for so many reasons.  This code must go.
 */
typedef struct Confdata Confdata;
struct Confdata {
    int on;
    char*   spec;
    DevConf cf;
};

static void
parseswitch(Confdata* cd, char* option)
{
    if(!strcmp("on", option))
        cd->on = 1;
    else if(!strcmp("off", option))
        cd->on = 0;
    else
        error(Ebadarg);
}

static void
parsespec(Confdata* cd, char* option)
{
    if(strlen(option) > 1)
        error(Ebadarg);
    cd->spec = option;
}

static Devport*
getnewport(DevConf* dc)
{
    Devport *p;

    p = (Devport *)malloc((dc->nports + 1) * sizeof(Devport));
    if(p == nil)
        error(Enomem);
    if(dc->nports > 0){
        memmove(p, dc->ports, dc->nports * sizeof(Devport));
        free(dc->ports);
    }
    dc->ports = p;
    p = &dc->ports[dc->nports++];
    p->size = -1;
    p->port = (ulong)-1;
    return p;
}

static void
parseport(Confdata* cd, char* option)
{
    char *e;
    Devport *p;

    if(cd->cf.nports == 0 || cd->cf.ports[cd->cf.nports-1].port != (ulong)-1)
        p = getnewport(&cd->cf);
    else
        p = &cd->cf.ports[cd->cf.nports-1];
    p->port = strtol(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parsesize(Confdata* cd, char* option)
{
    char *e;
    Devport *p;

    if(cd->cf.nports == 0 || cd->cf.ports[cd->cf.nports-1].size != -1)
        p = getnewport(&cd->cf);
    else
        p = &cd->cf.ports[cd->cf.nports-1];
    p->size = (int)strtol(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parseirq(Confdata* cd, char* option)
{
    char *e;

    cd->cf.intnum = strtoul(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parsetype(Confdata* cd, char* option)
{
    cd->cf.type = option;
}

static struct {
    char    *name;
    void    (*parse)(Confdata*, char*);
} options[] = {
    "switch",   parseswitch,
    "spec",     parsespec,
    "port",     parseport,
    "size",     parsesize,
    "irq",      parseirq,
    "type",     parsetype,
};

static void
legacytopctl(Cmdbuf *cb)
{
    char *opt;
    int i, j;
    Confdata cd;

    memset(&cd, 0, sizeof cd);
    cd.on = -1;
    for(i=0; i<cb->nf; i+=2){
        if(i+2 > cb->nf)
            error(Ebadarg);
        opt = cb->f[i];
        for(j=0; j<nelem(options); j++)
            if(strcmp(opt, options[j].name) == 0){
                options[j].parse(&cd, cb->f[i+1]);
                break;
            }
        if(j == nelem(options))
            error(Ebadarg);
    }
    /* this has been rewritten to accomodate sdaoe */
    if(cd.on < 0 || cd.spec == 0)
        error(Ebadarg);
    if(cd.on && cd.cf.type == nil)
        error(Ebadarg);
    sdconfig(cd.on, cd.spec, &cd.cf);
}
@
\fi

%// void
%// sdrmdevs(SDev *sdev)
%// {
%//  char buf[2];
%//
%//  snprint(buf, sizeof buf, "%c", sdev->idno);
%//  unconfigure(buf);
%// }
%
%//void
%//sdaddallconfs(void (*addconf)(SDunit *))
%//{
%//  int i, u;
%//  SDev *sdev;
%//
%//  for(i = 0; i < nelem(devs); i++)        /* each controller */
%//      for(sdev = devs[i]; sdev; sdev = sdev->next)
%//          for(u = 0; u < sdev->nunit; u++)    /* each drive */
%//              (*addconf)(sdev->unit[u]);
%//}
%
%
%/*
% * SCSI simulation for non-SCSI devices
% */
%//int
%//sdsetsense(SDreq *r, int status, int key, int asc, int ascq)
%//{
%//  int len;
%//  SDunit *unit;
%//
%//  unit = r->unit;
%//  unit->sense[2] = key;
%//  unit->sense[12] = asc;
%//  unit->sense[13] = ascq;
%//
%//  r->status = status;
%//  if(status == SDcheck && !(r->flags & SDnosense)){
%//      /* request sense case from sdfakescsi */
%//      len = sizeof unit->sense;
%//      if(len > sizeof r->sense-1)
%//          len = sizeof r->sense-1;
%//      memmove(r->sense, unit->sense, len);
%//      unit->sense[2] = 0;
%//      unit->sense[12] = 0;
%//      unit->sense[13] = 0;
%//      r->flags |= SDvalidsense;
%//      return SDok;
%//  }
%//  return status;
%//}
%
%//int
%//sdmodesense(SDreq *r, uchar *cmd, void *info, int ilen)
%//{
%//  int len;
%//  uchar *data;
%//
%//  /*
%//   * Fake a vendor-specific request with page code 0,
%//   * return the drive info.
%//   */
%//  if((cmd[2] & 0x3F) != 0 && (cmd[2] & 0x3F) != 0x3F)
%//      return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
%//  len = (cmd[7]<<8)|cmd[8];
%//  if(len == 0)
%//      return SDok;
%//  if(len < 8+ilen)
%//      return sdsetsense(r, SDcheck, 0x05, 0x1A, 0);
%//  if(r->data == nil || r->dlen < len)
%//      return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
%//  data = r->data;
%//  memset(data, 0, 8);
%//  data[0] = ilen>>8;
%//  data[1] = ilen;
%//  if(ilen)
%//      memmove(data+8, info, ilen);
%//  r->rlen = 8+ilen;
%//  return sdsetsense(r, SDok, 0, 0, 0);
%//}
%
%//int
%//sdfakescsi(SDreq *r, void *info, int ilen)
%//{
%//  uchar *cmd, *p;
%//  uvlong len;
%//  SDunit *unit;
%//
%//  cmd = r->cmd;
%//  r->rlen = 0;
%//  unit = r->unit;
%//
%//  /*
%//   * Rewrite read(6)/write(6) into read(10)/write(10).
%//   */
%//  switch(cmd[0]){
%//  case 0x08:  /* read */
%//  case 0x0A:  /* write */
%//      cmd[9] = 0;
%//      cmd[8] = cmd[4];
%//      cmd[7] = 0;
%//      cmd[6] = 0;
%//      cmd[5] = cmd[3];
%//      cmd[4] = cmd[2];
%//      cmd[3] = cmd[1] & 0x0F;
%//      cmd[2] = 0;
%//      cmd[1] &= 0xE0;
%//      cmd[0] |= 0x20;
%//      break;
%//  }
%//
%//  /*
%//   * Map SCSI commands into ATA commands for discs.
%//   * Fail any command with a LUN except INQUIRY which
%//   * will return 'logical unit not supported'.
%//   */
%//  if((cmd[1]>>5) && cmd[0] != 0x12)
%//      return sdsetsense(r, SDcheck, 0x05, 0x25, 0);
%//
%//  switch(cmd[0]){
%//  default:
%//      return sdsetsense(r, SDcheck, 0x05, 0x20, 0);
%//
%//  case 0x00:  /* test unit ready */
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x03:  /* request sense */
%//      if(cmd[4] < sizeof unit->sense)
%//          len = cmd[4];
%//      else
%//          len = sizeof unit->sense;
%//      if(r->data && r->dlen >= len){
%//          memmove(r->data, unit->sense, len);
%//          r->rlen = len;
%//      }
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x12:  /* inquiry */
%//      if(cmd[4] < sizeof unit->inquiry)
%//          len = cmd[4];
%//      else
%//          len = sizeof unit->inquiry;
%//      if(r->data && r->dlen >= len){
%//          memmove(r->data, unit->inquiry, len);
%//          r->rlen = len;
%//      }
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x1B:  /* start/stop unit */
%//      /*
%//       * nop for now, can use power management later.
%//       */
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x25:  /* read capacity */
%//      if((cmd[1] & 0x01) || cmd[2] || cmd[3])
%//          return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
%//      if(r->data == nil || r->dlen < 8)
%//          return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
%//
%//      /*
%//       * Read capacity returns the LBA of the last sector.
%//       */
%//      len = unit->sectors - 1;
%//      p = r->data;
%//      *p++ = len>>24;
%//      *p++ = len>>16;
%//      *p++ = len>>8;
%//      *p++ = len;
%//      len = 512;
%//      *p++ = len>>24;
%//      *p++ = len>>16;
%//      *p++ = len>>8;
%//      *p++ = len;
%//      r->rlen = p - (uchar*)r->data;
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x9E:  /* long read capacity */
%//      if((cmd[1] & 0x01) || cmd[2] || cmd[3])
%//          return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
%//      if(r->data == nil || r->dlen < 8)
%//          return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
%//      /*
%//       * Read capcity returns the LBA of the last sector.
%//       */
%//      len = unit->sectors - 1;
%//      p = r->data;
%//      *p++ = len>>56;
%//      *p++ = len>>48;
%//      *p++ = len>>40;
%//      *p++ = len>>32;
%//      *p++ = len>>24;
%//      *p++ = len>>16;
%//      *p++ = len>>8;
%//      *p++ = len;
%//      len = 512;
%//      *p++ = len>>24;
%//      *p++ = len>>16;
%//      *p++ = len>>8;
%//      *p++ = len;
%//      r->rlen = p - (uchar*)r->data;
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x5A:  /* mode sense */
%//      return sdmodesense(r, cmd, info, ilen);
%//
%//  case 0x28:  /* read */
%//  case 0x2A:  /* write */
%//  case 0x88:  /* read16 */
%//  case 0x8a:  /* write16 */
%//      return SDnostatus;
%//  }
%//}


\subsection*{[[devices/storage/sdscsi.c]]}


\ifallcode
<<sdscsi.c>>=
<<kernel basic includes>>

#include "io.h"
#include "../port/sd.h"

#include <ureg.h>

static int
scsitest(SDreq* r)
{
    r->write = 0;
    memset(r->cmd, 0, sizeof(r->cmd));
    r->cmd[1] = r->lun<<5;
    r->clen = 6;
    r->data = nil;
    r->dlen = 0;
    r->flags = 0;

    r->status = ~0;

    return r->unit->dev->ifc->rio(r);
}

int
scsiverify(SDunit* unit)
{
    SDreq *r;
    int i, status;
    uchar *inquiry;

    if((r = malloc(sizeof(SDreq))) == nil)
        return 0;
    if((inquiry = sdmalloc(sizeof(unit->inquiry))) == nil){
        free(r);
        return 0;
    }
    r->unit = unit;
    r->lun = 0;     /* ??? */

    memset(unit->inquiry, 0, sizeof(unit->inquiry));
    r->write = 0;
    r->cmd[0] = 0x12;
    r->cmd[1] = r->lun<<5;
    r->cmd[4] = sizeof(unit->inquiry)-1;
    r->clen = 6;
    r->data = inquiry;
    r->dlen = sizeof(unit->inquiry)-1;
    r->flags = 0;

    r->status = ~0;
    if(unit->dev->ifc->rio(r) != SDok){
        free(r);
        return 0;
    }
    memmove(unit->inquiry, inquiry, r->dlen);
    free(inquiry);

    SET(status);
    for(i = 0; i < 3; i++){
        while((status = scsitest(r)) == SDbusy)
            ;
        if(status == SDok || status != SDcheck)
            break;
        if(!(r->flags & SDvalidsense))
            break;
        if((r->sense[2] & 0x0F) != 0x02)
            continue;

        /*
         * Unit is 'not ready'.
         * If it is in the process of becoming ready or needs
         * an initialising command, set status so it will be spun-up
         * below.
         * If there's no medium, that's OK too, but don't
         * try to spin it up.
         */
        if(r->sense[12] == 0x04){
            if(r->sense[13] == 0x02 || r->sense[13] == 0x01){
                status = SDok;
                break;
            }
        }
        if(r->sense[12] == 0x3A)
            break;
    }

    if(status == SDok){
        /*
         * Try to ensure a direct-access device is spinning.
         * Don't wait for completion, ignore the result.
         */
        if((unit->inquiry[0] & SDinq0periphtype) == SDperdisk){
            memset(r->cmd, 0, sizeof(r->cmd));
            r->write = 0;
            r->cmd[0] = 0x1B;
            r->cmd[1] = (r->lun<<5)|0x01;
            r->cmd[4] = 1;
            r->clen = 6;
            r->data = nil;
            r->dlen = 0;
            r->flags = 0;

            r->status = ~0;
            unit->dev->ifc->rio(r);
        }
    }
    free(r);

    if(status == SDok || status == SDcheck)
        return 1;
    return 0;
}

static int
scsirio(SDreq* r)
{
    /*
     * Perform an I/O request, returning
     *  -1  failure
     *   0  ok
     *   1  no medium present
     *   2  retry
     * The contents of r may be altered so the
     * caller should re-initialise if necesary.
     */
    r->status = ~0;
    switch(r->unit->dev->ifc->rio(r)){
    default:
        break;
    case SDcheck:
        if(!(r->flags & SDvalidsense))
            break;
        switch(r->sense[2] & 0x0F){
        case 0x00:      /* no sense */
        case 0x01:      /* recovered error */
            return 2;
        case 0x06:      /* check condition */
            /*
             * 0x28 - not ready to ready transition,
             *    medium may have changed.
             * 0x29 - power on or some type of reset.
             */
            if(r->sense[12] == 0x28 && r->sense[13] == 0)
                return 2;
            if(r->sense[12] == 0x29)
                return 2;
            break;
        case 0x02:      /* not ready */
            /*
             * If no medium present, bail out.
             * If unit is becoming ready, rather than not
             * not ready, wait a little then poke it again.                  */
            if(r->sense[12] == 0x3A)
                break;
            if(r->sense[12] != 0x04 || r->sense[13] != 0x01)
                break;

            while(waserror())
                ;
            tsleep(&up->sleepr, returnfalse, 0, 500);
            poperror();
            scsitest(r);
            return 2;
        default:
            break;
        }
        break;
    case SDok:
        return 0;
    }
    return -1;
}

int
scsionline(SDunit* unit)
{
    SDreq *r;
    uchar *p;
    int ok, retries;

    if((r = malloc(sizeof(SDreq))) == nil)
        return 0;
    if((p = sdmalloc(8)) == nil){
        free(r);
        return 0;
    }

    ok = 0;

    r->unit = unit;
    r->lun = 0;             /* ??? */
    for(retries = 0; retries < 10; retries++){
        /*
         * Read-capacity is mandatory for DA, WORM, CD-ROM and
         * MO. It may return 'not ready' if type DA is not
         * spun up, type MO or type CD-ROM are not loaded or just
         * plain slow getting their act together after a reset.
         */
        r->write = 0;
        memset(r->cmd, 0, sizeof(r->cmd));
        r->cmd[0] = 0x25;
        r->cmd[1] = r->lun<<5;
        r->clen = 10;
        r->data = p;
        r->dlen = 8;
        r->flags = 0;

        r->status = ~0;
        switch(scsirio(r)){
        default:
            break;
        case 0:
            unit->sectors = (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
            unit->secsize = (p[4]<<24)|(p[5]<<16)|(p[6]<<8)|p[7];

            /*
             * Some ATAPI CD readers lie about the block size.
             * Since we don't read audio via this interface
             * it's okay to always fudge this.
             */
            if(unit->secsize == 2352)
                unit->secsize = 2048;
            /*
             * Devices with removable media may return 0 sectors
             * when they have empty media (e.g. sata dvd writers);
             * if so, keep the count zero.
             *
             * Read-capacity returns the LBA of the last sector,
             * therefore the number of sectors must be incremented.
             */
            if(unit->sectors != 0)
                unit->sectors++;
            ok = 1;
            break;
        case 1:
            ok = 1;
            break;
        case 2:
            continue;
        }
        break;
    }
    free(p);
    free(r);

    if(ok)
        return ok+retries;
    else
        return 0;
}

static void
scsifmt10(SDreq *r, int write, int lun, ulong nb, uvlong bno)
{
    uchar *c;

    c = r->cmd;
    if(write == 0)
        c[0] = 0x28;
    else
        c[0] = 0x2A;
    c[1] = lun<<5;
    c[2] = bno>>24;
    c[3] = bno>>16;
    c[4] = bno>>8;
    c[5] = bno;
    c[6] = 0;
    c[7] = nb>>8;
    c[8] = nb;
    c[9] = 0;

    r->clen = 10;
}

static void
scsifmt16(SDreq *r, int write, int lun, ulong nb, uvlong bno)
{
    uchar *c;

    c = r->cmd;
    if(write == 0)
        c[0] = 0x88;
    else
        c[0] = 0x8A;
    c[1] = lun<<5;      /* so wrong */
    c[2] = bno>>56;
    c[3] = bno>>48;
    c[4] = bno>>40;
    c[5] = bno>>32;
    c[6] = bno>>24;
    c[7] = bno>>16;
    c[8] = bno>>8;
    c[9] = bno;
    c[10] = nb>>24;
    c[11] = nb>>16;
    c[12] = nb>>8;
    c[13] = nb;
    c[14] = 0;
    c[15] = 0;

    r->clen = 16;
}

long
scsibio(SDunit* unit, int lun, int write, void* data, long nb, uvlong bno)
{
    SDreq *r;
    long rlen;

    if((r = malloc(sizeof(SDreq))) == nil)
        error(Enomem);
    r->unit = unit;
    r->lun = lun;
again:
    r->write = write;
    if(bno >= (1ULL<<32))
        scsifmt16(r, write, lun, nb, bno);
    else
        scsifmt10(r, write, lun, nb, bno);
    r->data = data;
    r->dlen = nb*unit->secsize;
    r->flags = 0;

    r->status = ~0;
    switch(scsirio(r)){
    default:
        rlen = -1;
        break;
    case 0:
        rlen = r->rlen;
        break;
    case 2:
        rlen = -1;
        if(!(r->flags & SDvalidsense))
            break;
        switch(r->sense[2] & 0x0F){
        default:
            break;
        case 0x01:      /* recovered error */
            print("%s: recovered error at sector %llud\n",
                unit->name, bno);
            rlen = r->rlen;
            break;
        case 0x06:      /* check condition */
            /*
             * Check for a removeable media change.
             * If so, mark it by zapping the geometry info
             * to force an online request.
             */
            if(r->sense[12] != 0x28 || r->sense[13] != 0)
                break;
            if(unit->inquiry[1] & SDinq1removable)
                unit->sectors = 0;
            break;
        case 0x02:      /* not ready */
            /*
             * If unit is becoming ready,
             * rather than not not ready, try again.
             */
            if(r->sense[12] == 0x04 && r->sense[13] == 0x01)
                goto again;
            break;
        }
        break;
    }
    free(r);

    return rlen;
}

@
\fi

%//int
%//scsiexec(SDunit* unit, int write, uchar* cmd, int clen, void* data, int* dlen)
%//{
%//  SDreq *r;
%//  int status;
%//
%//  if((r = malloc(sizeof(SDreq))) == nil)
%//      return SDmalloc;
%//  r->unit = unit;
%//  r->lun = cmd[1]>>5;     /* ??? */
%//  r->write = write;
%//  memmove(r->cmd, cmd, clen);
%//  r->clen = clen;
%//  r->data = data;
%//  if(dlen)
%//      r->dlen = *dlen;
%//  r->flags = 0;
%//
%//  r->status = ~0;
%//
%//  /*
%//   * Call the device-specific I/O routine.
%//   * There should be no calls to 'error()' below this
%//   * which percolate back up.
%//   */
%//  switch(status = unit->dev->ifc->rio(r)){
%//  case SDok:
%//      if(dlen)
%//          *dlen = r->rlen;
%//      /*FALLTHROUGH*/
%//  case SDcheck:
%//      /*FALLTHROUGH*/
%//  default:
%//      /*
%//       * It's more complicated than this. There are conditions
%//       * which are 'ok' but for which the returned status code
%//       * is not 'SDok'.
%//       * Also, not all conditions require a reqsense, might
%//       * need to do a reqsense here and make it available to the
%//       * caller somehow.
%//       *
%//       * Mañana.
%//       */
%//      break;
%//  }
%//  sdfree(r);
%//
%//  return status;
%//}


\subsection*{[[devices/sys/devdup.c]]}

<<global dupdevtab>>=
Dev dupdevtab = {
    .dc       =    'd',
    .name     =    "dup",
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    dupattach,
    .walk     =    dupwalk,
    .stat     =    dupstat,
    .open     =    dupopen,
    .create   =    devcreate,
    .close    =    dupclose,
    .read     =    dupread,
    .bread    =    devbread,
    .write    =    dupwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@


<<devdup.c>>=
<<kernel basic includes>>

/* Qid is (2*fd + (file is ctl))+1 */

static int
dupgen(Chan *c, char *, Dirtab*, int, int s, DirEntry *dp)
{
    Fgrp *fgrp = up->fgrp;
    Chan *f;
    static int perm[] = { 0400, 0200, 0600, 0 };
    int p;
    Qid q;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, ".", 0, eve, DMDIR|0555, dp);
        return 1;
    }
    if(s == 0)
        return 0;
    s--;
    if(s/2 > fgrp->maxfd)
        return -1;
    if((f=fgrp->fd[s/2]) == nil)
        return 0;
    if(s & 1){
        p = 0400;
        snprint(up->genbuf, sizeof up->genbuf, "%dctl", s/2);
    }else{
        p = perm[f->mode&3];
        snprint(up->genbuf, sizeof up->genbuf, "%d", s/2);
    }
    mkqid(&q, s+1, 0, QTFILE);
    devdir(c, q, up->genbuf, 0, eve, p, dp);
    return 1;
}

static Chan*
dupattach(char *spec)
{
    return devattach('d', spec);
}

static Walkqid*
dupwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, (Dirtab *)0, 0, dupgen);
}

static int
dupstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, (Dirtab *)0, 0L, dupgen);
}

static Chan*
dupopen(Chan *c, int omode)
{
    Chan *f;
    int fd, twicefd;

    if(c->qid.type & QTDIR){
        if(omode != 0)
            error(Eisdir);
        c->mode = 0;
        c->flag |= COPEN;
        c->offset = 0;
        return c;
    }
    if(c->qid.type & QTAUTH)
        error(Eperm);
    twicefd = c->qid.path - 1;
    fd = twicefd/2;
    if((twicefd & 1)){
        /* ctl file */
        f = c;
        f->mode = openmode(omode);
        f->flag |= COPEN;
        f->offset = 0;
    }else{
        /* fd file */
        f = fdtochan(fd, openmode(omode), false, true);
        cclose(c);
    }
    if(omode & OCEXEC)
        f->flag |= CCEXEC;
    return f;
}

static void
dupclose(Chan*)
{
}

static long
dupread(Chan *c, void *va, long n, vlong offset)
{
    char *a = va;
    char buf[256];
    int fd, twicefd;

    if(c->qid.type == QTDIR)
        return devdirread(c, a, n, (Dirtab *)0, 0L, dupgen);
    twicefd = c->qid.path - 1;
    fd = twicefd/2;
    if(twicefd & 1){
        c = fdtochan(fd, -1, false, true);
        procfdprint(c, fd, 0, buf, sizeof buf);
        cclose(c);
        return readstr((ulong)offset, va, n, buf);
    }
    panic("dupread");
    return 0;
}

static long
dupwrite(Chan*, void*, long, vlong)
{
    error(Eperm);
    return 0;       /* not reached */
}

<<global dupdevtab>>
@


\subsection*{[[devices/sys/devmnt.c]]}

\ifallcode
<<devmnt.c forward decl>>=
Mnt*    mntchk(Chan*);
void    mntdirfix(uchar*, Chan*);
Mntrpc* mntflushalloc(Mntrpc*, ulong);
void    mntflushfree(Mnt*, Mntrpc*);
void    mntgate(Mnt*);
void    mntqrm(Mnt*, Mntrpc*);
Mntrpc* mntralloc(Chan*, ulong);
long    mntrdwr(int, Chan*, void*, long, vlong);
int mntrpcread(Mnt*, Mntrpc*);
void    mountio(Mnt*, Mntrpc*);
void    mountmux(Mnt*, Mntrpc*);
void    mountrpc(Mnt*, Mntrpc*);
int rpcattn(void*);
Chan*   mntchan(void);
@
\fi


<<[[Chan]] other fields>>=
int fid;      /* for devmnt */
ulong iounit;     /* chunk size for i/o; 0==default */

Mnt*  mux;      /* Mnt for clients using me for messages */

Qid mqid;     /* qid of root of mount point */
@

<<global mntdevtab>>=
Dev mntdevtab = {
    .dc       =    'M',
    .name     =    "mnt",
               
    .reset    =    mntreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    mntattach,
    .walk     =    mntwalk,
    .stat     =    mntstat,
    .open     =    mntopen,
    .create   =    mntcreate,
    .close    =    mntclose,
    .read     =    mntread,
    .bread    =    devbread,
    .write    =    mntwrite,
    .bwrite   =    devbwrite,
    .remove   =    mntremove,
    .wstat    =    mntwstat,
};
@

<<enum channelflag cases>>=
CCACHE  = 0x0080,   /* client cache */
@

<<[[namec()]] set channel flag before open>>=
        if(omode == OEXEC)
            c->flag &= ~CCACHE;
@


<<devmnt.c>>=
<<kernel basic includes>>

#define MAXRPC (IOHDRSZ+8192)

<<devmnt.c forward decl>>


void (*mntstats)(int, Chan*, uvlong, ulong);

static void
mntreset(void)
{
    mntalloc.id = 1;
    mntalloc.tagmask[0] = 1;            /* don't allow 0 as a tag */
    mntalloc.tagmask[NMASK-1] = 0x80000000UL;   /* don't allow NOTAG */
    fmtinstall('F', fcallfmt);
    fmtinstall('D', dirfmt);
/* We can't install %M since eipfmt does and is used in the kernel [sape] */

    cinit();
}


Chan*
mntauth(Chan *c, char *spec)
{
    Mnt *m;
    Mntrpc *r;

    m = c->mux;

    if(m == nil){
        mntversion(c, VERSION9P, MAXRPC, 0);
        m = c->mux;
        if(m == nil)
            error(Enoversion);
    }

    c = mntchan();
    if(waserror()) {
        /* Close must not be called since it will
         * call mnt recursively
         */
        chanfree(c);
        nexterror();
    }

    r = mntralloc(0, m->msize);

    if(waserror()) {
        mntfree(r);
        nexterror();
    }

    r->request.type = Tauth;
    r->request.afid = c->fid;
    r->request.uname = up->user;
    r->request.aname = spec;
    mountrpc(m, r);

    c->qid = r->reply.aqid;
    c->mchan = m->c;
    incref(m->c);
    c->mqid = c->qid;
    c->mode = ORDWR;

    poperror(); /* r */
    mntfree(r);

    poperror(); /* c */

    return c;

}

static Chan*
mntattach(char *muxattach)
{
    Mnt *m;
    Chan *c;
    Mntrpc *r;
    struct Bogus bogus;

    bogus = *((struct Bogus *)muxattach);
    c = bogus.chan;

    m = c->mux;

    if(m == nil){
        mntversion(c, nil, 0, 0);
        m = c->mux;
        if(m == nil)
            error(Enoversion);
    }

    c = mntchan();
    if(waserror()) {
        /* Close must not be called since it will
         * call mnt recursively
         */
        chanfree(c);
        nexterror();
    }

    r = mntralloc(0, m->msize);

    if(waserror()) {
        mntfree(r);
        nexterror();
    }

    r->request.type = Tattach;
    r->request.fid = c->fid;
    if(bogus.authchan == nil)
        r->request.afid = NOFID;
    else
        r->request.afid = bogus.authchan->fid;
    r->request.uname = up->user;
    r->request.aname = bogus.spec;
    mountrpc(m, r);

    c->qid = r->reply.qid;
    c->mchan = m->c;
    incref(m->c);
    c->mqid = c->qid;

    poperror(); /* r */
    mntfree(r);

    poperror(); /* c */

    if(bogus.flags&MCACHE)
        c->flag |= CCACHE;
    return c;
}

Chan*
mntchan(void)
{
    Chan *c;

    c = devattach('M', 0);
    lock(&mntalloc);
    c->dev = mntalloc.id++;
    unlock(&mntalloc);

    if(c->mchan)
        panic("mntchan non-zero %p", c->mchan);
    return c;
}

static Walkqid*
mntwalk(Chan *c, Chan *nc, char **name, int nname)
{
    int i, alloc;
    Mnt *m;
    Mntrpc *r;
    Walkqid *wq;

    if(nc != nil)
        print("mntwalk: nc != nil\n");
    if(nname > MAXWELEM)
        error("devmnt: too many name elements");
    alloc = 0;
    wq = smalloc(sizeof(Walkqid)+(nname-1)*sizeof(Qid));
    if(waserror()){
        if(alloc && wq->clone!=nil)
            cclose(wq->clone);
        free(wq);
        return nil;
    }

    alloc = 0;
    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(nc == nil){
        nc = devclone(c);
        /*
         * Until the other side accepts this fid, we can't mntclose it.
         * Therefore set type to 0 for now; rootclose is known to be safe.
         */
        nc->type = 0;
        alloc = 1;
    }
    wq->clone = nc;
    nc->flag |= c->flag&CCACHE;

    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Twalk;
    r->request.fid = c->fid;
    r->request.newfid = nc->fid;
    r->request.nwname = nname;
    memmove(r->request.wname, name, nname*sizeof(char*));

    mountrpc(m, r);

    if(r->reply.nwqid > nname)
        error("too many QIDs returned by walk");
    if(r->reply.nwqid < nname){
        if(alloc)
            cclose(nc);
        wq->clone = nil;
        if(r->reply.nwqid == 0){
            free(wq);
            wq = nil;
            goto Return;
        }
    }

    /* move new fid onto mnt device and update its qid */
    if(wq->clone != nil){
        if(wq->clone != c){
            wq->clone->type = c->type;
            wq->clone->mchan = c->mchan;
            incref(c->mchan);
        }
        if(r->reply.nwqid > 0)
            wq->clone->qid = r->reply.wqid[r->reply.nwqid-1];
    }
    wq->nqid = r->reply.nwqid;
    for(i=0; i<wq->nqid; i++)
        wq->qid[i] = r->reply.wqid[i];

    Return:
    poperror();
    mntfree(r);
    poperror();
    return wq;
}

static int
mntstat(Chan *c, uchar *dp, int n)
{
    Mnt *m;
    Mntrpc *r;

    if(n < BIT16SZ)
        error(Eshortstat);
    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Tstat;
    r->request.fid = c->fid;
    mountrpc(m, r);

    if(r->reply.nstat > n){
        n = BIT16SZ;
        PBIT16((uchar*)dp, r->reply.nstat-2);
    }else{
        n = r->reply.nstat;
        memmove(dp, r->reply.stat, n);
        validstat(dp, n);
        mntdirfix(dp, c);
    }
    poperror();
    mntfree(r);
    return n;
}

static Chan*
mntopencreate(int type, Chan *c, char *name, int omode, ulong perm)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = type;
    r->request.fid = c->fid;
    r->request.mode = omode;
    if(type == Tcreate){
        r->request.perm = perm;
        r->request.name = name;
    }
    mountrpc(m, r);

    c->qid = r->reply.qid;
    c->offset = 0;
    c->mode = openmode(omode);
    c->iounit = r->reply.iounit;
    if(c->iounit == 0 || c->iounit > m->msize-IOHDRSZ)
        c->iounit = m->msize-IOHDRSZ;
    c->flag |= COPEN;
    poperror();
    mntfree(r);

    if(c->flag & CCACHE)
        copen(c);

    return c;
}

static Chan*
mntopen(Chan *c, int omode)
{
    return mntopencreate(Topen, c, nil, omode, 0);
}

static void
mntcreate(Chan *c, char *name, int omode, ulong perm)
{
    mntopencreate(Tcreate, c, name, omode, perm);
}

static void
mntclunk(Chan *c, int t)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()){
        mntfree(r);
        nexterror();
    }

    r->request.type = t;
    r->request.fid = c->fid;
    mountrpc(m, r);
    mntfree(r);
    poperror();
}



static void
mntclose(Chan *c)
{
    mntclunk(c, Tclunk);
}

static void
mntremove(Chan *c)
{
    mntclunk(c, Tremove);
}

static int
mntwstat(Chan *c, uchar *dp, int n)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Twstat;
    r->request.fid = c->fid;
    r->request.nstat = n;
    r->request.stat = dp;
    mountrpc(m, r);
    poperror();
    mntfree(r);
    return n;
}

static long
mntread(Chan *c, void *buf, long n, vlong off)
{
    uchar *p, *e;
    int nc, cache, isdir, dirlen;

    isdir = 0;
    cache = c->flag & CCACHE;
    if(c->qid.type & QTDIR) {
        cache = 0;
        isdir = 1;
    }

    p = buf;
    if(cache) {
        nc = cread(c, buf, n, off);
        if(nc > 0) {
            n -= nc;
            if(n == 0)
                return nc;
            p += nc;
            off += nc;
        }
        n = mntrdwr(Tread, c, p, n, off);
        cupdate(c, p, n, off);
        return n + nc;
    }

    n = mntrdwr(Tread, c, buf, n, off);
    if(isdir) {
        for(e = &p[n]; p+BIT16SZ < e; p += dirlen){
            dirlen = BIT16SZ+GBIT16(p);
            if(p+dirlen > e)
                break;
            validstat(p, dirlen);
            mntdirfix(p, c);
        }
        if(p != e)
            error(Esbadstat);
    }
    return n;
}

static long
mntwrite(Chan *c, void *buf, long n, vlong off)
{
    return mntrdwr(Twrite, c, buf, n, off);
}

long
mntrdwr(int type, Chan *c, void *buf, long n, vlong off)
{
    Mnt *m;
    Mntrpc *r;
    char *uba;
    int cache;
    ulong cnt, nr, nreq;

    m = mntchk(c);
    uba = buf;
    cnt = 0;
    cache = c->flag & CCACHE;
    if(c->qid.type & QTDIR)
        cache = 0;
    for(;;) {
        r = mntralloc(c, m->msize);
        if(waserror()) {
            mntfree(r);
            nexterror();
        }
        r->request.type = type;
        r->request.fid = c->fid;
        r->request.offset = off;
        r->request.data = uba;
        nr = n;
        if(nr > m->msize-IOHDRSZ)
            nr = m->msize-IOHDRSZ;
        r->request.count = nr;
        mountrpc(m, r);
        nreq = r->request.count;
        nr = r->reply.count;
        if(nr > nreq)
            nr = nreq;

        if(type == Tread)
            r->b = bl2mem((uchar*)uba, r->b, nr);
        else if(cache)
            cwrite(c, (uchar*)uba, nr, off);

        poperror();
        mntfree(r);
        off += nr;
        uba += nr;
        cnt += nr;
        n -= nr;
        if(nr != nreq || n == 0 || up->nnote)
            break;
    }
    return cnt;
}

void
mountrpc(Mnt *m, Mntrpc *r)
{
    char *sn, *cn;
    int t;

    r->reply.tag = 0;
    r->reply.type = Tmax;   /* can't ever be a valid message type */

    mountio(m, r);

    t = r->reply.type;
    switch(t) {
    case Rerror:
        error(r->reply.ename);
    case Rflush:
        error(Eintr);
    default:
        if(t == r->request.type+1)
            break;
        sn = "?";
        if(m->c->path != nil)
            sn = m->c->path->s;
        cn = "?";
        if(r->c != nil && r->c->path != nil)
            cn = r->c->path->s;
        print("mnt: proc %s %lud: mismatch from %s %s rep %#p tag %d fid %d T%d R%d rp %d\n",
            up->text, up->pid, sn, cn,
            r, r->request.tag, r->request.fid, r->request.type,
            r->reply.type, r->reply.tag);
        error(Emountrpc);
    }
}

void
mountio(Mnt *m, Mntrpc *r)
{
    int n;

    while(waserror()) {
        if(m->rip == up)
            mntgate(m);
        if(strcmp(up->errstr, Eintr) != 0){
            mntflushfree(m, r);
            nexterror();
        }
        r = mntflushalloc(r, m->msize);
    }

    lock(m);
    r->m = m;
    r->list = m->queue;
    m->queue = r;
    unlock(m);

    /* Transmit a file system rpc */
    if(m->msize == 0)
        panic("msize");
    n = convS2M(&r->request, r->rpc, m->msize);
    if(n < 0)
        panic("bad message type in mountio");
    if(devtab[m->c->type]->write(m->c, r->rpc, n, 0) != n)
        error(Emountrpc);
    r->stime = arch_fastticks(nil);
    r->reqlen = n;

    /* Gate readers onto the mount point one at a time */
    for(;;) {
        lock(m);
        if(m->rip == 0)
            break;
        unlock(m);
        sleep(&r->r, rpcattn, r);
        if(r->done){
            poperror();
            mntflushfree(m, r);
            return;
        }
    }
    m->rip = up;
    unlock(m);
    while(r->done == 0) {
        if(mntrpcread(m, r) < 0)
            error(Emountrpc);
        mountmux(m, r);
    }
    mntgate(m);
    poperror();
    mntflushfree(m, r);
}

static int
doread(Mnt *m, int len)
{
    Block *b;

    while(qlen(m->q) < len){
        b = devtab[m->c->type]->bread(m->c, m->msize, 0);
        if(b == nil)
            return -1;
        if(blocklen(b) == 0){
            freeblist(b);
            return -1;
        }
        qaddlist(m->q, b);
    }
    return 0;
}

int
mntrpcread(Mnt *m, Mntrpc *r)
{
    int i, t, len, hlen;
    Block *b, **l, *nb;

    r->reply.type = 0;
    r->reply.tag = 0;

    /* read at least length, type, and tag and pullup to a single block */
    if(doread(m, BIT32SZ+BIT8SZ+BIT16SZ) < 0)
        return -1;
    nb = pullupqueue(m->q, BIT32SZ+BIT8SZ+BIT16SZ);

    /* read in the rest of the message, avoid ridiculous (for now) message sizes */
    len = GBIT32(nb->rp);
    if(len > m->msize){
        qdiscard(m->q, qlen(m->q));
        return -1;
    }
    if(doread(m, len) < 0)
        return -1;

    /* pullup the header (i.e. everything except data) */
    t = nb->rp[BIT32SZ];
    switch(t){
    case Rread:
        hlen = BIT32SZ+BIT8SZ+BIT16SZ+BIT32SZ;
        break;
    default:
        hlen = len;
        break;
    }
    nb = pullupqueue(m->q, hlen);

    if(convM2S(nb->rp, len, &r->reply) <= 0){
        /* bad message, dump it */
        print("mntrpcread: convM2S failed\n");
        qdiscard(m->q, len);
        return -1;
    }

    /* hang the data off of the fcall struct */
    l = &r->b;
    *l = nil;
    do {
        b = qremove(m->q);
        if(hlen > 0){
            b->rp += hlen;
            len -= hlen;
            hlen = 0;
        }
        i = BLEN(b);
        if(i <= len){
            len -= i;
            *l = b;
            l = &(b->next);
        } else {
            /* split block and put unused bit back */
            nb = allocb(i-len);
            memmove(nb->wp, b->rp+len, i-len);
            b->wp = b->rp+len;
            nb->wp += i-len;
            qputback(m->q, nb);
            *l = b;
            return 0;
        }
    }while(len > 0);

    return 0;
}

void
mntgate(Mnt *m)
{
    Mntrpc *q;

    lock(m);
    m->rip = 0;
    for(q = m->queue; q; q = q->list) {
        if(q->done == 0)
        if(wakeup(&q->r))
            break;
    }
    unlock(m);
}

void
mountmux(Mnt *m, Mntrpc *r)
{
    Mntrpc **l, *q;

    lock(m);
    l = &m->queue;
    for(q = *l; q; q = q->list) {
        /* look for a reply to a message */
        if(q->request.tag == r->reply.tag) {
            *l = q->list;
            if(q != r) {
                /*
                 * Completed someone else.
                 * Trade pointers to receive buffer.
                 */
                q->reply = r->reply;
                q->b = r->b;
                r->b = nil;
            }
            q->done = 1;
            unlock(m);
            if(mntstats != nil)
                (*mntstats)(q->request.type,
                    m->c, q->stime,
                    q->reqlen + r->replen);
            if(q != r)
                wakeup(&q->r);
            return;
        }
        l = &q->list;
    }
    unlock(m);
    print("unexpected reply tag %ud; type %d\n", r->reply.tag, r->reply.type);
}

/*
 * Create a new flush request and chain the previous
 * requests from it
 */
Mntrpc*
mntflushalloc(Mntrpc *r, ulong iounit)
{
    Mntrpc *fr;

    fr = mntralloc(0, iounit);

    fr->request.type = Tflush;
    if(r->request.type == Tflush)
        fr->request.oldtag = r->request.oldtag;
    else
        fr->request.oldtag = r->request.tag;
    fr->flushed = r;

    return fr;
}

/*
 *  Free a chain of flushes.  Remove each unanswered
 *  flush and the original message from the unanswered
 *  request queue.  Mark the original message as done
 *  and if it hasn't been answered set the reply to to
 *  Rflush.
 */
void
mntflushfree(Mnt *m, Mntrpc *r)
{
    Mntrpc *fr;

    while(r){
        fr = r->flushed;
        if(!r->done){
            r->reply.type = Rflush;
            mntqrm(m, r);
        }
        if(fr)
            mntfree(r);
        r = fr;
    }
}

int
alloctag(void)
{
    int i, j;
    ulong v;

    for(i = 0; i < NMASK; i++){
        v = mntalloc.tagmask[i];
        if(v == ~0UL)
            continue;
        for(j = 0; j < 1<<TAGSHIFT; j++)
            if((v & (1<<j)) == 0){
                mntalloc.tagmask[i] |= 1<<j;
                return (i<<TAGSHIFT) + j;
            }
    }
    panic("no friggin tags left");
    return NOTAG;
}


Mntrpc*
mntralloc(Chan *c, ulong msize)
{
    Mntrpc *new;

    lock(&mntalloc);
    new = mntalloc.rpcfree;
    if(new == nil){
        new = malloc(sizeof(Mntrpc));
        if(new == nil) {
            unlock(&mntalloc);
            exhausted("mount rpc header");
        }
        /*
         * The header is split from the data buffer as
         * mountmux may swap the buffer with another header.
         */
        new->rpc = mallocz(msize, 0);
        if(new->rpc == nil){
            free(new);
            unlock(&mntalloc);
            exhausted("mount rpc buffer");
        }
        new->rpclen = msize;
        new->request.tag = alloctag();
    }
    else {
        mntalloc.rpcfree = new->list;
        mntalloc.nrpcfree--;
        if(new->rpclen < msize){
            free(new->rpc);
            new->rpc = mallocz(msize, 0);
            if(new->rpc == nil){
                free(new);
                mntalloc.nrpcused--;
                unlock(&mntalloc);
                exhausted("mount rpc buffer");
            }
            new->rpclen = msize;
        }
    }
    mntalloc.nrpcused++;
    unlock(&mntalloc);
    new->c = c;
    new->done = 0;
    new->flushed = nil;
    new->b = nil;
    return new;
}


void
mntqrm(Mnt *m, Mntrpc *r)
{
    Mntrpc **l, *f;

    lock(m);
    r->done = 1;

    l = &m->queue;
    for(f = *l; f; f = f->list) {
        if(f == r) {
            *l = r->list;
            break;
        }
        l = &f->list;
    }
    unlock(m);
}

Mnt*
mntchk(Chan *c)
{
    Mnt *m;

    /* This routine is mostly vestiges of prior lives; now it's just sanity checking */

    if(c->mchan == nil)
        panic("mntchk 1: nil mchan c %s\n", chanpath(c));

    m = c->mchan->mux;

    if(m == nil)
        print("mntchk 2: nil mux c %s c->mchan %s \n", chanpath(c), chanpath(c->mchan));

    /*
     * Was it closed and reused (was error(Eshutdown); now, it cannot happen)
     */
    if(m->id == 0 || m->id >= c->dev)
        panic("mntchk 3: can't happen");

    return m;
}

/*
 * Rewrite channel type and dev for in-flight data to
 * reflect local values.  These entries are known to be
 * the first two in the Dir encoding after the count.
 */
void
mntdirfix(uchar *dirbuf, Chan *c)
{
    uint r;

    r = devtab[c->type]->dc;
    dirbuf += BIT16SZ;  /* skip count */
    PBIT16(dirbuf, r);
    dirbuf += BIT16SZ;
    PBIT32(dirbuf, c->dev);
}

int
rpcattn(void *v)
{
    Mntrpc *r;

    r = v;
    return r->done || r->m->rip == 0;
}

<<global mntdevtab>>
@


\subsection*{[[devices/sys/devsrv.c]]}

\ifallcode
<<devsrv.c forward decl>>=
typedef struct Srv Srv;
@
\fi

<<struct Srv>>=
struct Srv
{
    char    *name;
    char    *owner;
    ulong   perm;
    Chan    *chan;
    Srv *link;
    ulong   path;
};
@


<<global srv>>=
static Srv  *srv;
@


<<global srvlk>>=
static QLock    srvlk;
@


<<global qidpath>>=
static int  qidpath;
@


<<method srvgen>>=
static int
srvgen(Chan *c, char*, Dirtab*, int, int s, DirEntry *dp)
{
    Srv *sp;
    Qid q;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, "#s", 0, eve, 0555, dp);
        return 1;
    }

    qlock(&srvlk);
    for(sp = srv; sp && s; sp = sp->link)
        s--;

    if(sp == 0) {
        qunlock(&srvlk);
        return -1;
    }

    mkqid(&q, sp->path, 0, QTFILE);
    /* make sure name string continues to exist after we release lock */
    kstrcpy(up->genbuf, sp->name, sizeof up->genbuf);
    devdir(c, q, up->genbuf, 0, sp->owner, sp->perm, dp);
    qunlock(&srvlk);
    return 1;
}
@


<<method srvinit>>=
static void
srvinit(void)
{
    qidpath = 1;
}
@


<<function srvlookup>>=
static Srv*
srvlookup(char *name, ulong qidpath)
{
    Srv *sp;
    for(sp = srv; sp; sp = sp->link)
        if(sp->path == qidpath || (name && strcmp(sp->name, name) == 0))
            return sp;
    return nil;
}
@


<<function srvname>>=
char*
srvname(Chan *c)
{
    int size;
    Srv *sp;
    char *s;

    for(sp = srv; sp; sp = sp->link)
        if(sp->chan == c){
            size = 3+strlen(sp->name)+1;
            s = smalloc(size);
            snprint(s, size, "#s/%s", sp->name);
            return s;
        }
    return nil;
}
@


<<method srvopen>>=
static Chan*
srvopen(Chan *c, int omode)
{
    Srv *sp;

    if(c->qid.type == QTDIR){
        if(omode & ORCLOSE)
            error(Eperm);
        if(omode != OREAD)
            error(Eisdir);
        c->mode = omode;
        c->flag |= COPEN;
        c->offset = 0;
        return c;
    }
    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        nexterror();
    }

    sp = srvlookup(nil, c->qid.path);
    if(sp == 0 || sp->chan == 0)
        error(Eshutdown);

    if(omode&OTRUNC)
        error("srv file already exists");
    if(openmode(omode)!=sp->chan->mode && sp->chan->mode!=ORDWR)
        error(Eperm);
    devpermcheck(sp->owner, sp->perm, omode);

    cclose(c);
    incref(sp->chan);
    qunlock(&srvlk);
    poperror();
    return sp->chan;
}
@


<<method srvcreate>>=
static void
srvcreate(Chan *c, char *name, int omode, ulong perm)
{
    char *sname;
    Srv *sp;

    if(openmode(omode) != OWRITE)
        error(Eperm);

    if(omode & OCEXEC)  /* can't happen */
        panic("someone broke namec");

    sp = smalloc(sizeof *sp);
    sname = smalloc(strlen(name)+1);

    qlock(&srvlk);
    if(waserror()){
        free(sp);
        free(sname);
        qunlock(&srvlk);
        nexterror();
    }
    if(sp == nil || sname == nil)
        error(Enomem);
    if(srvlookup(name, -1))
        error(Eexist);

    sp->path = qidpath++;
    sp->link = srv;
    strcpy(sname, name);
    sp->name = sname;
    c->qid.type = QTFILE;
    c->qid.path = sp->path;
    srv = sp;
    qunlock(&srvlk);
    poperror();

    kstrdup(&sp->owner, up->user);
    sp->perm = perm&0777;

    c->flag |= COPEN;
    c->mode = OWRITE;
}
@


<<method srvremove>>=
static void
srvremove(Chan *c)
{
    Srv *sp, **l;

    if(c->qid.type == QTDIR)
        error(Eperm);

    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        nexterror();
    }
    l = &srv;
    for(sp = *l; sp; sp = sp->link) {
        if(sp->path == c->qid.path)
            break;

        l = &sp->link;
    }
    if(sp == 0)
        error(Enonexist);

    /*
     * Only eve can remove system services.
     * No one can remove #s/boot.
     */
    if(strcmp(sp->owner, eve) == 0 && !iseve())
        error(Eperm);
    if(strcmp(sp->name, "boot") == 0)
        error(Eperm);

    /*
     * No removing personal services.
     */
    if((sp->perm&7) != 7 && strcmp(sp->owner, up->user) && !iseve())
        error(Eperm);

    *l = sp->link;
    qunlock(&srvlk);
    poperror();

    if(sp->chan)
        cclose(sp->chan);
    free(sp->owner);
    free(sp->name);
    free(sp);
}
@


<<method srvwstat>>=
static int
srvwstat(Chan *c, uchar *dp, int n)
{
    char *strs;
    DirEntry d;
    Srv *sp;

    if(c->qid.type & QTDIR)
        error(Eperm);

    strs = nil;
    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        free(strs);
        nexterror();
    }

    sp = srvlookup(nil, c->qid.path);
    if(sp == 0)
        error(Enonexist);

    if(strcmp(sp->owner, up->user) != 0 && !iseve())
        error(Eperm);

    strs = smalloc(n);
    n = convM2D(dp, n, &d, strs);
    if(n == 0)
        error(Eshortstat);
    if(d.mode != ~0UL)
        sp->perm = d.mode & 0777;
    if(d.uid && *d.uid)
        kstrdup(&sp->owner, d.uid);
    if(d.name && *d.name && strcmp(sp->name, d.name) != 0) {
        if(strchr(d.name, '/') != nil)
            error(Ebadchar);
        kstrdup(&sp->name, d.name);
    }
    qunlock(&srvlk);
    free(strs);
    poperror();
    return n;
}
@


<<method srvclose>>=
static void
srvclose(Chan *c)
{
    /*
     * in theory we need to override any changes in removability
     * since open, but since all that's checked is the owner,
     * which is immutable, all is well.
     */
    if(c->flag & CRCLOSE){
        if(waserror())
            return;
        srvremove(c);
        poperror();
    }
}
@


<<method srvread>>=
static long
srvread(Chan *c, void *va, long n, vlong)
{
    error_if_not_dir(c);
    return devdirread(c, va, n, 0, 0, srvgen);
}
@


<<method srvwrite>>=
static long
srvwrite(Chan *c, void *va, long n, vlong)
{
    Srv *sp;
    Chan *c1;
    int fd;
    char buf[32];

    if(n >= sizeof buf)
        error(Egreg);
    memmove(buf, va, n);    /* so we can NUL-terminate */
    buf[n] = 0;
    fd = strtoul(buf, 0, 0);

    c1 = fdtochan(fd, -1, false, true);    /* error check and inc ref */

    qlock(&srvlk);
    if(waserror()) {
        qunlock(&srvlk);
        cclose(c1);
        nexterror();
    }
    if(c1->flag & (CCEXEC|CRCLOSE))
        error("posted fd has remove-on-close or close-on-exec");
    if(c1->qid.type & QTAUTH)
        error("cannot post auth file in srv");
    sp = srvlookup(nil, c->qid.path);
    if(sp == 0)
        error(Enonexist);

    if(sp->chan)
        error(Ebadusefd);

    sp->chan = c1;
    qunlock(&srvlk);
    poperror();
    return n;
}
@


<<global srvdevtab>>=
Dev srvdevtab = {
    .dc       =    's',
    .name     =    "srv",
               
    .reset    =    devreset,
    .init     =    srvinit,    
    .shutdown =    devshutdown,
    .attach   =    srvattach,
    .walk     =    srvwalk,
    .stat     =    srvstat,
    .open     =    srvopen,
    .create   =    srvcreate,
    .close    =    srvclose,
    .read     =    srvread,
    .bread    =    devbread,
    .write    =    srvwrite,
    .bwrite   =    devbwrite,
    .remove   =    srvremove,
    .wstat    =    srvwstat,
};
@


<<devsrv.c>>=
<<kernel basic includes>>

<<devsrv.c forward decl>>

<<struct Srv>>

<<global srvlk>>
<<global srv>>
<<global qidpath>>

<<method srvgen>>

<<method srvinit>>

static Chan*
srvattach(char *spec)
{
    return devattach('s', spec);
}

static Walkqid*
srvwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, srvgen);
}

<<function srvlookup>>

static int
srvstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, srvgen);
}

<<function srvname>>

<<method srvopen>>

<<method srvcreate>>

<<method srvremove>>

<<method srvwstat>>

<<method srvclose>>

<<method srvread>>

<<method srvwrite>>

<<global srvdevtab>>
@

\subsection*{[[filesystems/devfs.c]]}

\ifallcode
<<devfs.c forward decl>>=
typedef struct Inner Inner;
typedef struct Fsdev Fsdev;
typedef struct Tree Tree;

extern Dev fsdevtab;        /* forward */
@
\fi

<<devfs.c debugging macro>>=
static int debug;
#define dprint if(debug)print
@


<<global fsdevtab>>=
Dev fsdevtab = {
    .dc       =    'k',
    .name     =    "fs",
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    mattach,
    .walk     =    mwalk,
    .stat     =    mstat,
    .open     =    mopen,
    .create   =    devcreate,
    .close    =    mclose,
    .read     =    mread,
    .bread    =    devbread,
    .write    =    mwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,

//    .power    =    devpower,
//    .config   =    devconfig,
};
@


<<devfs.c>>=
/*
 * File system devices.
 * Follows device config in Ken's file server.
 * Builds mirrors, concatenations, interleavings, and partitions
 * of devices out of other (inner) devices.
 * It is ok if inner devices are provided by this driver.
 *
 * Built files are grouped on different directories
 * (called trees, and used to represent disks).
 * The "#k/fs" tree is always available and never goes away.
 * Configuration changes happen only while no I/O is in progress.
 *
 * Default sector size is one byte unless changed by the "disk" ctl.
 */

<<kernel basic includes>>
#include "io.h"
#include <ureg.h>

enum
{
    Fnone,
    Fmirror,        /* mirror of others */
    Fcat,           /* catenation of others */
    Finter,         /* interleaving of others */
    Fpart,          /* part of other */
    Fclear,         /* start over */
    Fdel,           /* delete a configure device */
    Fdisk,          /* set default tree and sector sz*/

    Sectorsz = 1,
    Blksize = 8*1024,   /* for Finter only */

    Incr = 5,       /* Increments for the dev array */

    /*
     * All qids are decorated with the tree number.
     * #k/fs is tree number 0, is automatically added and
     * its first qid is for the ctl file. It never goes away.
     */
    Qtop    = 0,        /* #k */
    Qdir,           /* directory (#k/fs) */
    Qctl,           /* ctl, only for #k/fs/ctl */
    Qfirst,         /* first qid assigned for device */

    Iswrite = 0,
    Isread,

    Optional = 0,
    Mustexist,

    /* tunable parameters */
    Maxconf = 4*1024,   /* max length for config */
    Ndevs   = 32,       /* max. inner devs per command */
    Ntrees  = 128,      /* max. number of trees */
    Maxretries = 3,     /* max. retries of i/o errors */
    Retrypause = 5000,  /* ms. to pause between retries */
};

<<devfs.c forward decl>>

<<devfs.c debugging macro>>


struct Inner
{
    char    *iname;     /* inner device name */
    vlong   isize;      /* size of inner device */
    Chan    *idev;      /* inner device */
};

struct Fsdev
{
    Ref;            /* one per Chan doing I/O */
    int gone;       /* true if removed */
    int vers;       /* qid version for this device */
    int type;       /* Fnone, Fmirror, ... */
    char    *name;      /* name for this fsdev */
    Tree*   tree;       /* where the device is kept */
    vlong   size;       /* min(inner[X].isize) */
    vlong   start;      /* start address (for Fpart) */
    uint    ndevs;      /* number of inner devices */
    int perm;       /* minimum of inner device perms */
    Inner   *inner[Ndevs];  /* inner devices */
};

struct Tree
{
    char    *name;      /* name for #k/<name> */
    Fsdev   **devs;     /* devices in dir. */
    uint    ndevs;      /* number of devices */
    uint    nadevs;     /* number of allocated devices in devs */
};



static RWlock lck;      /* r: use devices; w: change config  */
static Tree fstree;     /* The main "fs" tree. Never goes away */
static Tree *trees[Ntrees]; /* internal representation of config */
static int ntrees;      /* max number of trees */
static int qidvers;

static char *disk;      /* default tree name used */
static char *source;        /* default inner device used */
static int sectorsz = Sectorsz; /* default sector size */

static char confstr[Maxconf];   /* textual configuration */


static char cfgstr[] = "fsdev:\n";

static Qid tqid = {Qtop, 0, QTDIR};
static Qid cqid = {Qctl, 0, 0};

static char* tnames[] = {
    [Fmirror]   "mirror",
    [Fcat]      "cat",
    [Finter]    "inter",
    [Fpart]     "part",
};

static Cmdtab configs[] = {
    Fmirror,"mirror",   0,
    Fcat,   "cat",      0,
    Finter, "inter",    0,
    Fpart,  "part",     0,
    Fclear, "clear",    1,
    Fdel,   "del",      2,
    Fdisk,  "disk",     0,
};

static char Egone[] = "device is gone";     /* file has been removed */

static char*
seprintdev(char *s, char *e, Fsdev *mp)
{
    int i;

    if(mp == nil)
        return seprint(s, e, "<null Fsdev>");
    if(mp->type < 0 || mp->type >= nelem(tnames) || tnames[mp->type] == nil)
        return seprint(s, e, "bad device type %d\n", mp->type);

    s = strecpy(s, e, tnames[mp->type]);
    if(mp->tree != &fstree)
        s = seprint(s, e, " %s/%s", mp->tree->name, mp->name);
    else
        s = seprint(s, e, " %s", mp->name);
    for(i = 0; i < mp->ndevs; i++)
        s = seprint(s, e, " %s", mp->inner[i]->iname);
    switch(mp->type){
    case Fmirror:
    case Fcat:
    case Finter:
        s = strecpy(s, e, "\n");
        break;
    case Fpart:
        s = seprint(s, e, " %ulld %ulld\n", mp->start, mp->size);
        break;
    default:
        panic("#k: seprintdev bug");
    }
    return s;
}

static vlong
mkpath(int tree, int devno)
{
    return (tree&0xFFFF)<<16 | devno&0xFFFF;
}

static int
path2treeno(int q)
{
    return q>>16 & 0xFFFF;
}

static int
path2devno(int q)
{
    return q & 0xFFFF;
}

static Tree*
gettree(int i, int mustexist)
{
    dprint("gettree %d\n", i);
    if(i < 0)
        panic("#k: bug: bad tree index %d in gettree", i);
    if(i >= ntrees || trees[i] == nil)
        if(mustexist)
            error(Enonexist);
        else
            return nil;
    return trees[i];
}

static Fsdev*
getdev(Tree *t, int i, int mustexist)
{
    dprint("getdev %d\n", i);
    if(i < 0)
        panic("#k: bug: bad dev index %d in getdev", i);
    if(i >= t->nadevs || t->devs[i] == nil)
        if(mustexist)
            error(Enonexist);
        else
            return nil;
    return t->devs[i];
}

static Fsdev*
path2dev(int q)
{
    Tree    *t;

    dprint("path2dev %ux\n", q);
    t = gettree(path2treeno(q), Mustexist);
    return getdev(t, path2devno(q) - Qfirst, Mustexist);
}

static Tree*
treealloc(char *name)
{
    int i;
    Tree    *t;

    dprint("treealloc %s\n", name);
    for(i = 0; i < nelem(trees); i++)
        if(trees[i] == nil)
            break;
    if(i == nelem(trees))
        return nil;
    t = trees[i] = mallocz(sizeof(Tree), 1);
    if(t == nil)
        return nil;
    if(i == ntrees)
        ntrees++;
    kstrdup(&t->name, name);
    return t;
}

static Tree*
lookuptree(char *name)
{
    int i;

    dprint("lookuptree %s\n", name);
    for(i = 0; i < ntrees; i++)
        if(trees[i] != nil && strcmp(trees[i]->name, name) == 0)
            return trees[i];
    return nil;
}

static Fsdev*
devalloc(Tree *t, char *name)
{
    int i, ndevs;
    Fsdev   *mp, **devs;

    dprint("devalloc %s %s\n", t->name, name);
    mp = mallocz(sizeof(Fsdev), 1);
    if(mp == nil)
        return nil;
    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] == nil)
            break;
    if(i >= t->nadevs){
        if(t->nadevs % Incr == 0){
            ndevs = t->nadevs + Incr;
            devs = realloc(t->devs, ndevs * sizeof(Fsdev*));
            if(devs == nil){
                free(mp);
                return nil;
            }
            t->devs = devs;
        }
        t->devs[t->nadevs] = nil;
        t->nadevs++;
    }
    kstrdup(&mp->name, name);
    mp->vers = ++qidvers;
    mp->tree = t;
    t->devs[i] = mp;
    t->ndevs++;
    return mp;
}

static void
deltree(Tree *t)
{
    int i;

    dprint("deltree %s\n", t->name);
    for(i = 0; i < ntrees; i++)
        if(trees[i] == t){
            if(i > 0){      /* "fs" never goes away */
                free(t->name);
                free(t->devs);
                free(t);
                trees[i] = nil;
            }
            return;
        }
    panic("#k: deltree: bug: tree not found");
}

/*
 * A device is gone and we know that all its users are gone.
 * A tree is gone when all its devices are gone ("fs" is never gone).
 * Must close devices outside locks, so we could nest our own devices.
 */
static void
mdeldev(Fsdev *mp)
{
    int i;
    Inner   *in;
    Tree    *t;

    dprint("deldev %s gone %d ref %uld\n", mp->name, mp->gone, mp->ref);

    mp->gone = 1;
    mp->vers = ++qidvers;

    wlock(&lck);
    t = mp->tree;
    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] == mp){
            t->devs[i] = nil;
            t->ndevs--;
            if(t->ndevs == 0)
                deltree(t);
            break;
        }
    wunlock(&lck);

    free(mp->name);
    for(i = 0; i < mp->ndevs; i++){
        in = mp->inner[i];
        if(in->idev != nil)
            cclose(in->idev);
        free(in->iname);
        free(in);
    }
    if(debug)
        memset(mp, 9, sizeof *mp);  /* poison */
    free(mp);
}

/*
 * Delete one or all devices in one or all trees.
 */
static void
mdelctl(char *tname, char *dname)
{
    int i, alldevs, alltrees, some;
    Fsdev *mp;
    Tree *t;

    dprint("delctl %s\n", dname);
    alldevs = strcmp(dname, "*") == 0;
    alltrees = strcmp(tname, "*") == 0;
    some = 0;
Again:
    wlock(&lck);
    for(i = 0; i < ntrees; i++){
        t = trees[i];
        if(t == nil)
            continue;
        if(alltrees == 0 && strcmp(t->name, tname) != 0)
            continue;
        for(i = 0; i < t->nadevs; i++){
            mp = t->devs[i];
            if(t->devs[i] == nil)
                continue;
            if(alldevs == 0 && strcmp(mp->name, dname) != 0)
                continue;
            /*
             * Careful: must close outside locks and that
             * may change the file tree we are looking at.
             */
            some++;
            mp->gone = 1;
            if(mp->ref == 0){
                incref(mp); /* keep it there */
                wunlock(&lck);
                mdeldev(mp);
                goto Again; /* tree can change */
            }
        }
    }
    wunlock(&lck);
    if(some == 0 && alltrees == 0)
        error(Enonexist);
}

static void
setdsize(Fsdev* mp, vlong *ilen)
{
    int i;
    vlong   inlen;
    Inner   *in;

    dprint("setdsize %s\n", mp->name);
    for (i = 0; i < mp->ndevs; i++){
        in = mp->inner[i];
        in->isize = ilen[i];
        inlen = in->isize;
        switch(mp->type){
        case Finter:
            /* truncate to multiple of Blksize */
            inlen &= ~(Blksize-1);
            in->isize = inlen;
            /* fall through */
        case Fmirror:
            /* use size of smallest inner device */
            if (mp->size == 0 || mp->size > inlen)
                mp->size = inlen;
            break;
        case Fcat:
            mp->size += inlen;
            break;
        case Fpart:
            if(mp->start > inlen)
                error("partition starts after device end");
            if(inlen < mp->start + mp->size){
                print("#k: %s: partition truncated from "
                    "%lld to %lld bytes\n", mp->name,
                    mp->size, inlen - mp->start);
                mp->size = inlen - mp->start;
            }
            break;
        }
    }
    if(mp->type == Finter)
        mp->size *= mp->ndevs;
}

static void
validdevname(Tree *t, char *dname)
{
    int i;

    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] != nil && strcmp(t->devs[i]->name, dname) == 0)
            error(Eexist);
}

static void
parseconfig(char *a, long n, Cmdbuf **cbp, Cmdtab **ctp)
{
    Cmdbuf  *cb;
    Cmdtab  *ct;

    *cbp = cb = parsecmd(a, n);
    *ctp = ct = lookupcmd(cb, configs, nelem(configs));

    cb->f++;            /* skip command */
    cb->nf--;
    switch(ct->index){
    case Fmirror:
    case Fcat:
    case Finter:
        if(cb->nf < 2)
            error("too few arguments for ctl");
        if(cb->nf - 1 > Ndevs)
            error("too many devices in ctl");
        break;
    case Fdisk:
        if(cb->nf < 1 || cb->nf > 3)
            error("ctl usage: disk name [sz dev]");
        break;
    case Fpart:
        if(cb->nf != 4 && (cb->nf != 3 || source == nil))
            error("ctl usage: part new [file] off len");
        break;
    }
}

static void
parsename(char *name, char *disk, char **tree, char **dev)
{
    char *slash;

    slash = strchr(name, '/');
    if(slash == nil){
        if(disk != nil)
            *tree = disk;
        else
            *tree = "fs";
        *dev = name;
    }else{
        *tree = name;
        *slash++ = 0;
        *dev = slash;
    }
    validname(*tree, false);
    validname(*dev, false);
}

static int
getattrs(Chan *c, vlong *lenp, int *permp)
{
    uchar   buf[128];   /* old DIRLEN plus a little should be plenty */
    DirEntry d;
    long    l;

    *lenp = 0;
    *permp = 0;
    l = devtab[c->type]->stat(c, buf, sizeof buf);
    if (l >= 0 && convM2D(buf, l, &d, nil) > 0) {
        *lenp = d.length;
        *permp = d.mode & 0777;
    }
    return l;
}

/*
 * Process a single line of configuration,
 * often of the form "cmd newname idev0 idev1".
 * locking is tricky, because we need a write lock to
 * add/remove devices yet adding/removing them may lead
 * to calls to this driver that require a read lock (when
 * inner devices are also provided by us).
 */
static void
mconfig(char* a, long n)
{
    int i;
    int *iperm;
    vlong   size, start;
    vlong   *ilen;
    char    *tname, *dname, *fakef[4];
    Chan    **idev;
    Cmdbuf  *cb;
    Cmdtab  *ct;
    Fsdev   *mp;
    Inner   *inprv;
    Tree    *t;

    /* ignore comments & empty lines */
    if (*a == '\0' || *a == '#' || *a == '\n')
        return;

    dprint("mconfig\n");
    size = 0;
    start = 0;
    mp = nil;
    cb = nil;
    idev = nil;
    ilen = nil;
    iperm = nil;

    if(waserror()){
        free(cb);
        nexterror();
    }

    parseconfig(a, n, &cb, &ct);
    switch (ct->index) {
    case Fdisk:
        kstrdup(&disk, cb->f[0]);
        if(cb->nf >= 2)
            sectorsz = strtoul(cb->f[1], 0, 0);
        else
            sectorsz = Sectorsz;
        if(cb->nf == 3)
            kstrdup(&source, cb->f[2]);
        else{
            free(source);
            source = nil;
        }
        poperror();
        free(cb);
        return;
    case Fclear:
        poperror();
        free(cb);
        mdelctl("*", "*");      /* del everything */
        return;
    case Fpart:
        if(cb->nf == 3){
            /*
             * got a request in the format of sd(3),
             * pretend we got one in our format.
             * later we change end to be len.
             */
            fakef[0] = cb->f[0];
            fakef[1] = source;
            fakef[2] = cb->f[1];
            fakef[3] = cb->f[2];
            cb->f = fakef;
            cb->nf = 4;
        }
        start = strtoll(cb->f[2], nil, 10);
        size =  strtoll(cb->f[3], nil, 10);
        if(cb->f == fakef)
            size -= start;      /* it was end */
        cb->nf -= 2;
        break;
    }
    parsename(cb->f[0], disk, &tname, &dname);
    for(i = 1; i < cb->nf; i++)
        validname(cb->f[i], true);

    if(ct->index == Fdel){
        mdelctl(tname, dname);
        poperror();
        free(cb);
        return;
    }

    /*
     * Open all inner devices while we have only a read lock.
     */
    poperror();
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
Fail:
        for(i = 1; i < cb->nf; i++)
            if(idev != nil && idev[i-1] != nil)
                cclose(idev[i]);
        if(mp != nil)
            mdeldev(mp);
        free(idev);
        free(ilen);
        free(iperm);
        free(cb);
        nexterror();
    }
    /* record names, lengths and perms of all named files */
    idev = smalloc(sizeof(Chan*) * Ndevs);
    ilen = smalloc(sizeof(vlong) * Ndevs);
    iperm = smalloc(sizeof(int) * Ndevs);
    for(i = 1; i < cb->nf; i++){
        idev[i-1] = namec(cb->f[i], Aopen, ORDWR, 0);
        getattrs(idev[i-1], &ilen[i-1], &iperm[i-1]);
    }
    poperror();
    runlock(&lck);

    /*
     * Get a write lock and add the device if we can.
     */
    wlock(&lck);
    if(waserror()){
        wunlock(&lck);
        goto Fail;
    }

    t = lookuptree(tname);
    if(t != nil)
        validdevname(t, dname);
    else
        t = treealloc(tname);
    if(t == nil)
        error("no more trees");
    mp = devalloc(t, dname);
    if(mp == nil){
        if(t->ndevs == 0)   /* it was created for us */
            deltree(t); /* but we will not mdeldev() */
        error(Enomem);
    }

    /* construct mp from iname, idev and iperm arrays */
    mp->type = ct->index;
    if(mp->type == Fpart){
        mp->start = start * sectorsz;
        mp->size = size * sectorsz;
    }
    mp->perm = 0666;
    for(i = 1; i < cb->nf; i++){
        inprv = mp->inner[i-1] = mallocz(sizeof(Inner), 1);
        if(inprv == nil)
            error(Enomem);
        mp->ndevs++;
        kstrdup(&inprv->iname, cb->f[i]);
        inprv->idev = idev[i-1];
        idev[i-1] = nil;
        /* use the most restrictive of the inner permissions */
        mp->perm &= iperm[i-1];
    }
    setdsize(mp, ilen);

    poperror();
    wunlock(&lck);
    free(idev);
    free(ilen);
    free(iperm);
    free(cb);
}

static void
rdconf(void)
{
    int mustrd;
    char *c, *e, *p, *s;
    Chan *cc;
    static int configed;

    /* only read config file once */
    if (configed)
        return;
    configed = 1;

    dprint("rdconf\n");
    /* add the std "fs" tree */
    trees[0] = &fstree;
    ntrees++;
    fstree.name = "fs";

    /* identify the config file */
    s = getconf("fsconfig");
    if (s == nil){
        mustrd = 0;
        s = "/dev/sdC0/fscfg";
    } else
        mustrd = 1;

    /* read it */
    cc = nil;
    c = nil;
    if (waserror()){
        if (cc != nil)
            cclose(cc);
        if (c)
            free(c);
        if (!mustrd)
            return;
        nexterror();
    }
    cc = namec(s, Aopen, OREAD, 0);
    devtab[cc->type]->read(cc, confstr, sizeof confstr, 0);
    cclose(cc);
    cc = nil;

    /* validate, copy and erase config; mconfig will repopulate confstr */
    if (strncmp(confstr, cfgstr, sizeof cfgstr - 1) != 0)
        error("bad #k config, first line must be: 'fsdev:\\n'");
    kstrdup(&c, confstr + sizeof cfgstr - 1);
    memset(confstr, 0, sizeof confstr);

    /* process config copy one line at a time */
    for (p = c; p != nil && *p != '\0'; p = e){
        e = strchr(p, '\n');
        if (e == nil)
            e = p + strlen(p);
        else
            e++;
        mconfig(p, e - p);
    }
    USED(cc);       /* until now, can be used in waserror clause */
    poperror();
}

static int
mgen(Chan *c, char*, Dirtab*, int, int i, DirEntry *dp)
{
    int treeno;
    Fsdev   *mp;
    Qid qid;
    Tree    *t;

    dprint("mgen %#ullx %d\n", c->qid.path, i);
    qid.type = QTDIR;
    qid.vers = 0;
    if(c->qid.path == Qtop){
        if(i == DEVDOTDOT){
            devdir(c, tqid, "#k", 0, eve, DMDIR|0775, dp);
            return 1;
        }
        t = gettree(i, Optional);
        if(t == nil){
            dprint("no\n");
            return -1;
        }
        qid.path = mkpath(i, Qdir);
        devdir(c, qid, t->name, 0, eve, DMDIR|0775, dp);
        return 1;
    }

    treeno = path2treeno(c->qid.path);
    t = gettree(treeno, Optional);
    if(t == nil){
        dprint("no\n");
        return -1;
    }
    if((c->qid.type & QTDIR) != 0){
        if(i == DEVDOTDOT){
            devdir(c, tqid, "#k", 0, eve, DMDIR|0775, dp);
            return 1;
        }
        if(treeno == 0){
            /* take care of #k/fs/ctl */
            if(i == 0){
                devdir(c, cqid, "ctl", 0, eve, 0664, dp);
                return 1;
            }
            i--;
        }
        mp = getdev(t, i, Optional);
        if(mp == nil){
            dprint("no\n");
            return -1;
        }
        qid.type = QTFILE;
        qid.vers = mp->vers;
        qid.path = mkpath(treeno, Qfirst+i);
        devdir(c, qid, mp->name, mp->size, eve, mp->perm, dp);
        return 1;
    }

    if(i == DEVDOTDOT){
        qid.path = mkpath(treeno, Qdir);
        devdir(c, qid, t->name, 0, eve, DMDIR|0775, dp);
        return 1;
    }
    dprint("no\n");
    return -1;
}

static Chan*
mattach(char *spec)
{
    dprint("mattach\n");
    return devattach(fsdevtab.dc, spec);
}

static Walkqid*
mwalk(Chan *c, Chan *nc, char **name, int nname)
{
    Walkqid *wq;

    rdconf();

    dprint("mwalk %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    wq = devwalk(c, nc, name, nname, 0, 0, mgen);
    poperror();
    runlock(&lck);
    return wq;
}

static int
mstat(Chan *c, uchar *db, int n)
{
    int p;
    DirEntry d;
    Fsdev   *mp;
    Qid q;
    Tree    *t;

    dprint("mstat %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    p = c->qid.path;
    memset(&d, 0, sizeof d);
    switch(p){
    case Qtop:
        devdir(c, tqid, "#k", 0, eve, DMDIR|0775, &d);
        break;
    case Qctl:
        devdir(c, cqid, "ctl", 0, eve, 0664, &d);
        break;
    default:
        t = gettree(path2treeno(p), Mustexist);
        if(c->qid.type & QTDIR)
            devdir(c, c->qid, t->name, 0, eve, DMDIR|0775, &d);
        else{
            mp = getdev(t, path2devno(p) - Qfirst, Mustexist);
            q = c->qid;
            q.vers = mp->vers;
            devdir(c, q, mp->name, mp->size, eve, mp->perm, &d);
        }
    }
    n = convD2M(&d, db, n);
    if (n == 0)
        error(Ebadarg);
    poperror();
    runlock(&lck);
    return n;
}

static Chan*
mopen(Chan *c, int omode)
{
    int q;
    Fsdev   *mp;

    dprint("mopen %llux\n", c->qid.path);
    if((c->qid.type & QTDIR) && omode != OREAD)
        error(Eperm);
    if(c->qid.path != Qctl && (c->qid.type&QTDIR) == 0){
        rlock(&lck);
        if(waserror()){
            runlock(&lck);
            nexterror();
        }
        q = c->qid.path;
        mp = path2dev(q);
        if(mp->gone)
            error(Egone);
        devpermcheck(eve, mp->perm, omode);
        incref(mp);
        poperror();
        runlock(&lck);
    }
    /*
     * Our mgen does not return the info for the qid
     * but only for its children. Don't use devopen here.
     */
    c->offset = 0;
    c->mode = openmode(omode & ~OTRUNC);
    c->flag |= COPEN;
    return c;
}

static void
mclose(Chan *c)
{
    int mustdel, q;
    Fsdev   *mp;

    dprint("mclose %llux\n", c->qid.path);
    if(c->qid.type & QTDIR || !(c->flag & COPEN))
        return;
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    mustdel = 0;
    mp = nil;
    q = c->qid.path;
    if(q == Qctl){
        free(disk);
        disk = nil; /* restore defaults */
        free(source);
        source = nil;
        sectorsz = Sectorsz;
    }else{
        mp = path2dev(q);
        if(mp->gone != 0 && mp->ref == 1)
            mustdel = 1;
        else
            decref(mp);
    }
    poperror();
    runlock(&lck);
    if(mustdel)
        mdeldev(mp);
}

static long
io(Fsdev *mp, Inner *in, int isread, void *a, long l, vlong off)
{
    long wl;
    Chan    *mc;

    mc = in->idev;
    if(mc == nil)
        error(Egone);
    if (waserror()) {
        print("#k: %s: byte %,lld count %ld (of #k/%s): %s error: %s\n",
            in->iname, off, l, mp->name, (isread? "read": "write"),
            (up && up->errstr? up->errstr: ""));
        nexterror();
    }
    if (isread)
        wl = devtab[mc->type]->read(mc, a, l, off);
    else
        wl = devtab[mc->type]->write(mc, a, l, off);
    poperror();
    return wl;
}

/* NB: a transfer could span multiple inner devices */
static long
catio(Fsdev *mp, int isread, void *a, long n, vlong off)
{
    int i;
    long    l, res;
    Inner   *in;

    if(debug)
        print("catio %d %p %ld %lld\n", isread, a, n, off);
    res = n;
    for (i = 0; n > 0 && i < mp->ndevs; i++){
        in = mp->inner[i];
        if (off >= in->isize){
            off -= in->isize;
            continue;       /* not there yet */
        }
        if (off + n > in->isize)
            l = in->isize - off;
        else
            l = n;
        if(debug)
            print("\tdev %d %p %ld %lld\n", i, a, l, off);

        if (io(mp, in, isread, a, l, off) != l)
            error(Eio);

        a = (char*)a + l;
        off = 0;
        n -= l;
    }
    if(debug)
        print("\tres %ld\n", res - n);
    return res - n;
}

static long
interio(Fsdev *mp, int isread, void *a, long n, vlong off)
{
    int i;
    long    boff, res, l, wl, wsz;
    vlong   woff, blk, mblk;

    blk  = off / Blksize;
    boff = off % Blksize;
    wsz  = Blksize - boff;
    res = n;
    while(n > 0){
        mblk = blk / mp->ndevs;
        i    = blk % mp->ndevs;
        woff = mblk*Blksize + boff;
        if (n > wsz)
            l = wsz;
        else
            l = n;

        wl = io(mp, mp->inner[i], isread, a, l, woff);
        if (wl != l)
            error(Eio);

        blk++;
        boff = 0;
        wsz = Blksize;
        a = (char*)a + l;
        n -= l;
    }
    return res;
}

static char*
seprintconf(char *s, char *e)
{
    int i, j;
    Tree    *t;

    *s = 0;
    for(i = 0; i < ntrees; i++){
        t = trees[i];
        if(t != nil)
            for(j = 0; j < t->nadevs; j++)
                if(t->devs[j] != nil)
                    s = seprintdev(s, e, t->devs[j]);
    }
    return s;
}

static long
mread(Chan *c, void *a, long n, vlong off)
{
    int i, retry;
    long    l, res;
    Fsdev   *mp;
    Tree    *t;

    dprint("mread %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    res = -1;
    if(c->qid.type & QTDIR){
        res = devdirread(c, a, n, 0, 0, mgen);
        goto Done;
    }
    if(c->qid.path == Qctl){
        seprintconf(confstr, confstr + sizeof(confstr));
        res = readstr((long)off, a, n, confstr);
        goto Done;
    }

    t = gettree(path2treeno(c->qid.path), Mustexist);
    mp = getdev(t, path2devno(c->qid.path) - Qfirst, Mustexist);

    if(off >= mp->size){
        res = 0;
        goto Done;
    }
    if(off + n > mp->size)
        n = mp->size - off;
    if(n == 0){
        res = 0;
        goto Done;
    }

    switch(mp->type){
    case Fcat:
        res = catio(mp, Isread, a, n, off);
        break;
    case Finter:
        res = interio(mp, Isread, a, n, off);
        break;
    case Fpart:
        res = io(mp, mp->inner[0], Isread, a, n, mp->start + off);
        break;
    case Fmirror:
        retry = 0;
        do {
            if (retry > 0) {
                print("#k/%s: retry %d read for byte %,lld "
                    "count %ld: %s\n", mp->name, retry, off,
                    n, (up && up->errstr? up->errstr: ""));
                /*
                 * pause before retrying in case it's due to
                 * a transient bus or controller problem.
                 */
                tsleep(&up->sleepr, returnfalse, 0, Retrypause);
            }
            for (i = 0; i < mp->ndevs; i++){
                if (waserror())
                    continue;
                l = io(mp, mp->inner[i], Isread, a, n, off);
                poperror();
                if (l >= 0){
                    res = l;
                    break;      /* read a good copy */
                }
            }
        } while (i == mp->ndevs && ++retry <= Maxretries);
        if (retry > Maxretries) {
            /* no mirror had a good copy of the block */
            print("#k/%s: byte %,lld count %ld: CAN'T READ "
                "from mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
            error(Eio);
        } else if (retry > 0)
            print("#k/%s: byte %,lld count %ld: retry read OK "
                "from mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
        break;
    }
Done:
    poperror();
    runlock(&lck);
    return res;
}

static long
mwrite(Chan *c, void *a, long n, vlong off)
{
    int i, allbad, anybad, retry;
    long    l, res;
    Fsdev   *mp;
    Tree    *t;

    dprint("mwrite %llux\n", c->qid.path);
    if (c->qid.type & QTDIR)
        error(Eisdir);
    if (c->qid.path == Qctl){
        mconfig(a, n);
        return n;
    }

    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }

    t = gettree(path2treeno(c->qid.path), Mustexist);
    mp = getdev(t, path2devno(c->qid.path) - Qfirst, Mustexist);

    if(off >= mp->size){
        res = 0;
        goto Done;
    }
    if(off + n > mp->size)
        n = mp->size - off;
    if(n == 0){
        res = 0;
        goto Done;
    }
    res = n;
    switch(mp->type){
    case Fcat:
        res = catio(mp, Iswrite, a, n, off);
        break;
    case Finter:
        res = interio(mp, Iswrite, a, n, off);
        break;
    case Fpart:
        res = io(mp, mp->inner[0], Iswrite, a, n, mp->start + off);
        if (res != n)
            error(Eio);
        break;
    case Fmirror:
        retry = 0;
        do {
            if (retry > 0) {
                print("#k/%s: retry %d write for byte %,lld "
                    "count %ld: %s\n", mp->name, retry, off,
                    n, (up && up->errstr? up->errstr: ""));
                /*
                 * pause before retrying in case it's due to
                 * a transient bus or controller problem.
                 */
                tsleep(&up->sleepr, returnfalse, 0, Retrypause);
            }
            allbad = 1;
            anybad = 0;
            for (i = mp->ndevs - 1; i >= 0; i--){
                if (waserror()) {
                    anybad = 1;
                    continue;
                }
                l = io(mp, mp->inner[i], Iswrite, a, n, off);
                poperror();
                if (l == n)
                    allbad = 0; /* wrote a good copy */
                else
                    anybad = 1;
            }
        } while (anybad && ++retry <= Maxretries);
        if (allbad) {
            /* no mirror took a good copy of the block */
            print("#k/%s: byte %,lld count %ld: CAN'T WRITE "
                "to mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
            error(Eio);
        } else if (retry > 0)
            print("#k/%s: byte %,lld count %ld: retry wrote OK "
                "to mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));

        break;
    }
Done:
    poperror();
    runlock(&lck);
    return res;
}

<<global fsdevtab>>
@


\subsection*{[[../include/trace.h]]}

<<[[enum Tevent]] real-time scheduling events>>=
SAdmit,	/* Edf admit */
SRelease,	/* Edf release, waiting to be scheduled */
SYield,		/* blocked waiting for release */
SSlice,		/* slice exhausted */
SDeadline,	/* proc's deadline */
SExpel,		/* Edf expel */
SInts,		/* Interrupt start */
SInte,		/* Interrupt end */
@

<<trace.h>>=
<<enum Tevent>>

<<struct Traceevent>>

typedef enum Tevent Tevent;
typedef struct Traceevent	Traceevent;
@

\subsection*{[[../include/tos.h]]}
<<tos.h>>=
typedef struct Plink Plink;
#pragma incomplete Plink

<<struct Tos>>
typedef struct Tos Tos;

extern Tos *_tos;
@

\subsection*{[[files/cache.c]]}

\ifallcode
<<cache.c forward decl>>=
typedef struct Cache Cache;
typedef struct Ecache Ecache;
@
\fi

<<[[Chan]] other fields>>=
Mntcache* mcp;      /* Mount cache pointer */
@

% used only by cache.c
<<function auxpage>>=
Page*
auxpage(void)
{
    Page *p;

    lock(&palloc);
    p = palloc.head;
    if(palloc.freecount < swapalloc.highwater) {
        unlock(&palloc);
        return nil;
    }
    pageunchain(p);

    lock(p);
    if(p->ref != 0)
        panic("auxpage");
    p->ref++;
    uncachepage(p);
    unlock(p);
    unlock(&palloc);

    return p;
}
@



<<cache.c>>=
<<kernel basic includes>>

enum
{
    NHASH       = 128,
    MAXCACHE    = 1024*1024,
    NFILE       = 4096,
    NEXTENT     = 200,      /* extent allocation size */
};

<<cache.c forward decl>>

struct Cache
{
    QLock;
    int     pgno;
    Mntcache    *head;
    Mntcache    *tail;
    Mntcache    *hash[NHASH];
};

struct Ecache
{
    Lock;
    int total;
    int free;
    Extent* head;
};

static KImage fscache;
static Cache cache;
static Ecache ecache;
static int maxcache = MAXCACHE;

static void
extentfree(Extent* e)
{
    lock(&ecache);
    e->next = ecache.head;
    ecache.head = e;
    ecache.free++;
    unlock(&ecache);
}

static Extent*
extentalloc(void)
{
    Extent *e;
    int i;

    lock(&ecache);
    if(ecache.head == nil){
        e = xalloc(NEXTENT*sizeof(Extent));
        if(e == nil){
            unlock(&ecache);
            return nil;
        }
        for(i = 0; i < NEXTENT; i++){
            e->next = ecache.head;
            ecache.head = e;
            e++;
        }
        ecache.free += NEXTENT;
        ecache.total += NEXTENT;
    }

    e = ecache.head;
    ecache.head = e->next;
    memset(e, 0, sizeof(Extent));
    ecache.free--;
    unlock(&ecache);

    return e;
}

void
cinit(void)
{
    int i;
    Mntcache *m;

    cache.head = xalloc(sizeof(Mntcache)*NFILE);
    m = cache.head;
    if (m == nil)
        panic("cinit: no memory");

    /* a better algorithm would be nice */
    if(conf.npage*BY2PG > 400*MB)
        maxcache = 20*MAXCACHE;
    else if(conf.npage*BY2PG > 200*MB)
        maxcache = 10*MAXCACHE;

    for(i = 0; i < NFILE-1; i++) {
        m->next = m+1;
        m->prev = m-1;
        m++;
    }

    cache.tail = m;
    cache.tail->next = 0;
    cache.head->prev = 0;

    fscache.notext = true;
}

Page*
cpage(Extent *e)
{
    /* Easy consistency check */
    if(e->cache->daddr != e->bid)
        return 0;

    return lookpage(&fscache, e->bid);
}

void
cnodata(Mntcache *m)
{
    Extent *e, *n;

    /*
     * Invalidate all extent data
     * Image lru will waste the pages
     */
    for(e = m->list; e; e = n) {
        n = e->next;
        extentfree(e);
    }
    m->list = 0;
}

void
ctail(Mntcache *m)
{
    /* Unlink and send to the tail */
    if(m->prev)
        m->prev->next = m->next;
    else
        cache.head = m->next;
    if(m->next)
        m->next->prev = m->prev;
    else
        cache.tail = m->prev;

    if(cache.tail) {
        m->prev = cache.tail;
        cache.tail->next = m;
        m->next = 0;
        cache.tail = m;
    }
    else {
        cache.head = m;
        cache.tail = m;
        m->prev = 0;
        m->next = 0;
    }
}

void
copen(Chan *c)
{
    int h;
    Extent *e, *next;
    Mntcache *m, *f, **l;

    /* directories aren't cacheable and append-only files confuse us */
    if(c->qid.type&(QTDIR|QTAPPEND))
        return;

    h = c->qid.path%NHASH;
    qlock(&cache);
    for(m = cache.hash[h]; m; m = m->hash) {
        if(m->qid.path == c->qid.path)
        if(m->qid.type == c->qid.type)
        if(m->dev == c->dev && m->type == c->type) {
            c->mcp = m;
            ctail(m);
            qunlock(&cache);

            /* File was updated, invalidate cache */
            if(m->qid.vers != c->qid.vers) {
                m->qid.vers = c->qid.vers;
                qlock(m);
                cnodata(m);
                qunlock(m);
            }
            return;
        }
    }

    /* LRU the cache headers */
    m = cache.head;
    l = &cache.hash[m->qid.path%NHASH];
    for(f = *l; f; f = f->hash) {
        if(f == m) {
            *l = m->hash;
            break;
        }
        l = &f->hash;
    }

    m->qid = c->qid;
    m->dev = c->dev;
    m->type = c->type;

    l = &cache.hash[h];
    m->hash = *l;
    *l = m;
    ctail(m);

    qlock(m);
    c->mcp = m;
    e = m->list;
    m->list = 0;
    qunlock(&cache);

    while(e) {
        next = e->next;
        extentfree(e);
        e = next;
    }
    qunlock(m);
}

static int
cdev(Mntcache *m, Chan *c)
{
    if(m->qid.path != c->qid.path)
        return 0;
    if(m->qid.type != c->qid.type)
        return 0;
    if(m->dev != c->dev)
        return 0;
    if(m->type != c->type)
        return 0;
    if(m->qid.vers != c->qid.vers)
        return 0;
    return 1;
}

int
cread(Chan *c, uchar *buf, int len, vlong off)
{
    Arch_KMap *k;
    Page *p;
    Mntcache *m;
    Extent *e, **t;
    int o, l, total;
    ulong offset;

    if(off+len > maxcache)
        return 0;

    m = c->mcp;
    if(m == 0)
        return 0;

    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return 0;
    }

    offset = off;
    t = &m->list;
    for(e = *t; e; e = e->next) {
        if(offset >= e->start && offset < e->start+e->len)
            break;
        t = &e->next;
    }

    if(e == 0) {
        qunlock(m);
        return 0;
    }

    total = 0;
    while(len) {
        p = cpage(e);
        if(p == 0) {
            *t = e->next;
            extentfree(e);
            qunlock(m);
            return total;
        }

        o = offset - e->start;
        l = len;
        if(l > e->len-o)
            l = e->len-o;

        k = arch_kmap(p);
        if(waserror()) {
            arch_kunmap(k);
            putpage(p);
            qunlock(m);
            nexterror();
        }

        memmove(buf, (uchar*)VA(k) + o, l);

        poperror();
        arch_kunmap(k);

        putpage(p);

        buf += l;
        len -= l;
        offset += l;
        total += l;
        t = &e->next;
        e = e->next;
        if(e == 0 || e->start != offset)
            break;
    }

    qunlock(m);
    return total;
}

Extent*
cchain(uchar *buf, ulong offset, int len, Extent **tail)
{
    int l;
    Page *p;
    Arch_KMap *k;
    Extent *e, *start, **t;

    start = 0;
    *tail = 0;
    t = &start;
    while(len) {
        e = extentalloc();
        if(e == 0)
            break;

        p = auxpage();
        if(p == 0) {
            extentfree(e);
            break;
        }
        l = len;
        if(l > BY2PG)
            l = BY2PG;

        e->cache = p;
        e->start = offset;
        e->len = l;

        qlock(&cache);
        e->bid = cache.pgno;
        cache.pgno += BY2PG;
        /* wrap the counter; low bits are unused by pghash but checked by lookpage */
        if((cache.pgno & ~(BY2PG-1)) == 0){
            if(cache.pgno == BY2PG-1){
                print("cache wrapped\n");
                cache.pgno = 0;
            }else
                cache.pgno++;
        }
        qunlock(&cache);

        p->daddr = e->bid;
        k = arch_kmap(p);
        if(waserror()) {        /* buf may be virtual */
            arch_kunmap(k);
            nexterror();
        }
        memmove((void*)VA(k), buf, l);
        poperror();
        arch_kunmap(k);

        cachepage(p, &fscache);
        putpage(p);

        buf += l;
        offset += l;
        len -= l;

        *t = e;
        *tail = e;
        t = &e->next;
    }

    return start;
}

int
cpgmove(Extent *e, uchar *buf, int boff, int len)
{
    Page *p;
    Arch_KMap *k;

    p = cpage(e);
    if(p == 0)
        return 0;

    k = arch_kmap(p);
    if(waserror()) {        /* Since buf may be virtual */
        arch_kunmap(k);
        nexterror();
    }

    memmove((uchar*)VA(k)+boff, buf, len);

    poperror();
    arch_kunmap(k);
    putpage(p);

    return 1;
}

void
cupdate(Chan *c, uchar *buf, int len, vlong off)
{
    Mntcache *m;
    Extent *tail;
    Extent *e, *f, *p;
    int o, ee, eblock;
    ulong offset;

    if(off > maxcache || len == 0)
        return;

    m = c->mcp;
    if(m == 0)
        return;
    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return;
    }

    /*
     * Find the insertion point
     */
    offset = off;
    p = 0;
    for(f = m->list; f; f = f->next) {
        if(f->start > offset)
            break;
        p = f;
    }

    /* trim if there is a successor */
    eblock = offset+len;
    if(f != 0 && eblock > f->start) {
        len -= (eblock - f->start);
        if(len <= 0) {
            qunlock(m);
            return;
        }
    }

    if(p == 0) {        /* at the head */
        e = cchain(buf, offset, len, &tail);
        if(e != 0) {
            m->list = e;
            tail->next = f;
        }
        qunlock(m);
        return;
    }

    /* trim to the predecessor */
    ee = p->start+p->len;
    if(offset < ee) {
        o = ee - offset;
        len -= o;
        if(len <= 0) {
            qunlock(m);
            return;
        }
        buf += o;
        offset += o;
    }

    /* try and pack data into the predecessor */
    if(offset == ee && p->len < BY2PG) {
        o = len;
        if(o > BY2PG - p->len)
            o = BY2PG - p->len;
        if(cpgmove(p, buf, p->len, o)) {
            p->len += o;
            buf += o;
            len -= o;
            offset += o;
            if(len <= 0) {
if(f && p->start + p->len > f->start) print("CACHE: p->start=%uld p->len=%d f->start=%uld\n", p->start, p->len, f->start);
                qunlock(m);
                return;
            }
        }
    }

    e = cchain(buf, offset, len, &tail);
    if(e != 0) {
        p->next = e;
        tail->next = f;
    }
    qunlock(m);
}

void
cwrite(Chan* c, uchar *buf, int len, vlong off)
{
    int o, eo;
    Mntcache *m;
    ulong eblock, ee;
    Extent *p, *f, *e, *tail;
    ulong offset;

    if(off > maxcache || len == 0)
        return;

    m = c->mcp;
    if(m == 0)
        return;

    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return;
    }

    offset = off;
    m->qid.vers++;
    c->qid.vers++;

    p = 0;
    for(f = m->list; f; f = f->next) {
        if(f->start >= offset)
            break;
        p = f;
    }

    if(p != 0) {
        ee = p->start+p->len;
        eo = offset - p->start;
        /* pack in predecessor if there is space */
        if(offset <= ee && eo < BY2PG) {
            o = len;
            if(o > BY2PG - eo)
                o = BY2PG - eo;
            if(cpgmove(p, buf, eo, o)) {
                if(eo+o > p->len)
                    p->len = eo+o;
                buf += o;
                len -= o;
                offset += o;
            }
        }
    }

    /* free the overlap -- it's a rare case */
    eblock = offset+len;
    while(f && f->start < eblock) {
        e = f->next;
        extentfree(f);
        f = e;
    }

    /* link the block (if any) into the middle */
    e = cchain(buf, offset, len, &tail);
    if(e != 0) {
        tail->next = f;
        f = e;
    }

    if(p == 0)
        m->list = f;
    else
        p->next = f;
    qunlock(m);
}
@

%//void
%//cprint(Chan *c, Mntcache *m, char *s)
%//{
%//  ulong o;
%//  int nb, ct;
%//  Extent *e;
%//
%//  nb = 0;
%//  ct = 1;
%//  o = 0;
%//  if(m->list)
%//      o = m->list->start;
%//  for(e = m->list; e; e = e->next) {
%//      nb += e->len;
%//      if(o != e->start)
%//          ct = 0;
%//      o = e->start+e->len;
%//  }
%//  pprint("%s: %#llux.%#lux %d %d %s (%d %c)\n",
%//  s, m->qid.path, m->qid.vers, m->type, m->dev, c->path->s, nb, ct ? 'C' : 'N');
%//
%//  for(e = m->list; e; e = e->next) {
%//      pprint("\t%4d %5lud %4d %#p\n",
%//          e->bid, e->start, e->len, e->cache);
%//  }
%//}

\subsection*{[[init/rebootcmd.c]]}

<<rebootcmd.c>>=
<<kernel basic includes>>

#include    <a.out.h>
#include    <elf.h>

struct Execvals {
  uvlong  entry;
  ulong textsize;
  ulong datasize;
};
//TODO: who sets this? it's used by rebootcmd but who sets it? qemu?
int (*parseboothdr)(Chan *, ulong, Execvals *);


enum {
    Ehdr32sz    = 52,
    Phdr32sz    = 32,
    Shdr32sz    = 40,

    Ehdr64sz    = 64,
    Phdr64sz    = 56,
    Shdr64sz    = 64,
};

static uchar elfident[] = {
    '\177', 'E', 'L', 'F',
};

static void
readn(Chan *c, void *vp, long n)
{
    char *p = vp;
    long nn;

    while(n > 0) {
        nn = devtab[c->type]->read(c, p, n, c->offset);
        if(nn == 0)
            error(Eshort);
        c->offset += nn;
        p += nn;
        n -= nn;
    }
}

/* assume the elf header is in the byte order of this machine */
int
readelfhdr(Chan *c, ulong, Execvals *evp)
{
    Ehdr ehdr;
    Phdr phdrs[3];

    c->offset = 0;          /* back up */
    readn(c, &ehdr, sizeof ehdr);
    if(memcmp(&ehdr.ident[MAG0], elfident, sizeof elfident) != 0 ||
        ehdr.ident[CLASS] != ELFCLASS32)
        return -1;

    /* get textsize and datasize from Phdrs */
    readn(c, phdrs, sizeof phdrs);
    evp->entry = ehdr.elfentry;
    evp->textsize = phdrs[0].filesz;
    evp->datasize = phdrs[1].filesz;
    c->offset = ROUNDUP(Ehdr32sz + 3*Phdr32sz, 16); /* position for text */
    return 0;
}

//static int
//readelf64hdr(Chan *c, ulong, Execvals *evp)
//{
//    E64hdr ehdr;
//    P64hdr phdrs[3];
//
//    c->offset = 0;          /* back up */
//    readn(c, &ehdr, sizeof ehdr);
//    if(memcmp(&ehdr.ident[MAG0], elfident, sizeof elfident) != 0 ||
//        ehdr.ident[CLASS] != ELFCLASS64)
//        return -1;
//
//    /* get textsize and datasize from Phdrs */
//    readn(c, phdrs, sizeof phdrs);
//    evp->entry = ehdr.elfentry;
//    evp->textsize = phdrs[0].filesz;
//    evp->datasize = phdrs[1].filesz;
//    c->offset = ROUNDUP(Ehdr64sz + 3*Phdr64sz, 16); /* position for text */
//    return 0;
//}

static void
setbootcmd(int argc, char *argv[])
{
    char *buf, *p, *ep;
    int i;

    buf = malloc(1024);
    if(buf == nil)
        error(Enomem);
    p = buf;
    ep = buf + 1024;
    for(i=0; i<argc; i++)
        p = seprint(p, ep, "%q ", argv[i]);
    *p = 0;
    ksetenv("bootcmd", buf, 1);
    free(buf);
}

void
rebootcmd(int argc, char *argv[])
{
    Chan *c;
    Exec exec;
    Execvals ev;
    ulong magic, text, rtext, entry, data, size;
    uchar *p;

    if(argc == 0)
        exit(0);

    c = namec(argv[0], Aopen, OEXEC, 0);
    if(waserror()){
        cclose(c);
        nexterror();
    }

    readn(c, &exec, sizeof(Exec));
    magic = l2be(exec.magic);
    /*
     * AOUT_MAGIC is sometimes defined like this:
     * #define AOUT_MAGIC   V_MAGIC || magic==M_MAGIC
     * so we can only use it in a fairly stylized manner.
     */
    if(magic == AOUT_MAGIC) {
        entry = l2be(exec.entry);
        text = l2be(exec.text);
        data = l2be(exec.data);
    } else if(parseboothdr && (*parseboothdr)(c, magic, &ev) >= 0 ||
        readelfhdr(c, magic, &ev) >= 0 
        //|| readelf64hdr(c, magic, &ev) >= 0
        ){
        entry = ev.entry;
        text = ev.textsize;
        data = ev.datasize;
    } else {
        error(Ebadexec);
        return;             /* for the compiler */
    }

    /* round text out to page boundary */
    rtext = ROUNDUP(entry+text, BY2PG) - entry;
    size = rtext + data;
    p = malloc(size);
    if(p == nil)
        error(Enomem);

    if(waserror()){
        free(p);
        nexterror();
    }

    memset(p, 0, size);
    readn(c, p, text);
    readn(c, p + rtext, data);

    ksetenv("bootfile", argv[0], 1);
    setbootcmd(argc-1, argv+1);

    arch_reboot((void*)entry, p, size);

    panic("return from reboot!");
}
@

\chapter{Outside Kernel}

%Network.nw: netif.c, netif.h
%Graphics.nw: portscreen.c, portscreen.h

\chapter{User programs outside Kernel}

\chapter{Not LPized yet}

% Many files in plan9/BIG/kernel-port/

\subsection{[[devaudio.c]]}

\subsection{[[fhashif.h]]}

\subsection{[[fpi.h]]}

\subsection{[[fpi.c]]}

\subsection{[[fpimem.c]]}

\subsection{[[mul64fract.c.c]]}

\subsection{[[sdmmc.c]]}

\subsection{[[usb.h]]}


\fi
