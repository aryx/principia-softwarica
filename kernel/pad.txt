# -*- org -*-

* Glossary

up = user process

pc = program counter

spl = set priority level

ilock = interrupt safe version of lock (disable interruptions)

umb = upper memory block

RMAP = RAM map

PDB = page directory base

PTE = page table entry

tod = time of day

ap = application processor

EDF = Earliest Deadline First
http://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling

RPC = remote procedure call

EGRP = Environment group

FGRP = File descriptor Group (chans)

PGRP = Process Group (namespace)

cistrcmp= ??


* (Re)Organization

split in subdirectories instead of having the very flat port/ and pc/
Generalize what they have done for ip/ and boot/ and add concurrency/,
memory/, files/, processes/, etc.

split portdat.h in subfiles, help understand things more
gradually. Make dependencies more clear.
Try to put the data ([port]dat) and prototype ([port]fns) closer to their
relevant directory (even though it can introduce backward dependencies).
It used to be a giant portdat_core.h but this was not good.

split portfns.h in subfiles, again help understand components.

Declare also in portfns_xxx.h the functions defined in 386/ which are
used in port/ code. So put in the fns_xxx.h files, functions used only
inside 386/.

Same for portdat_xxx.h, or at least declare in comments the
structures that are defined in 386/ but used outside in port.

Qualify better pointers. In C pointers can be many things: 
list head, list tail, member of a list, hash, reference, option, array, etc.
Same for enum, they can be sometimes variant, bitset, etc.

TODO: use literate programming to better introduce big data structure,
especially put the list related, queue related, hash related closer
together. This is because C does not handle very well lists, does not
provide reusable abstraction and so list are embedded inside
the element itself. Use LP to alleviate this (or at least
put such fields at the end of the structure).

* Misc

** notes

I use // to comment, so it's easy to see if the code comes from me
(and no need verbose //pad:)

** ref vs non ref
if the structure "own" the substructure, then don't use ref
but if structure use as reference in an array of another structure,
then use ref.

** types

implicit: 
char* = string

* Principles

** abstractions

** optimizations

caching
 (buffer cache)
 (swap is a form of caching because limited ram is used first, and when no
  more then put on disk)

sharing
 (text segment for binaries)

lazy 
 (demand loading for text segment)


gc, reference counting

hash

sparse tree (double index table) (Segment, Pte, Page)
 and even inline ssegmap (like in ext2 inode, indirect, double indirect,
 inline)

** testing
no way to unit test this big software?

* Explanations

** up

"it can not be a global, because each processor have different user processes
so up is defined as a macro to be the extern up of the Mach per processor
structure

concurrency issue when accessing up? 

What can "interrupt" or execute in parallel with current kernel code?

Another processor can be also in kernel code, but it will be a different up!

The current kernel code can be interrupted, but interrupt code are supposed
to do very little so there should be no race on global important data structures.


** externup
why extern?

** spl
(lo, hi), lo = enable interrupt, hi = disable interrupt

** ilock vs lock

lock is good for mutual exclusion between different processors in kernel code,
but we also need mutual exclusion on same processor because kernel code
could have been interrupted (by interrupt) on the same processor.
so ilock allow to not lock yourself ...


** qid

why int? why not string?
because of distributed nature of plan9? that was designed with
distribution in mind?

** memory

xalloc (128?), pool, ...

page

malloc


segment vs page

list, hash, reference counting
arena, pool, page, ...


there are lots of data structures initialized in memory
when load kernel (text+data) in memory! so xlists, mainmem,
devtab, etc are all allocated memory and initialized with
the right value. no need malloc for that! no chicken and egg.
So one have xlists and confmem that describe the memory,
can use xalloc to get chunk of this memory.
xalloc for procs, for all Pages, etc.

