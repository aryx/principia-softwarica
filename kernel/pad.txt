# -*- org -*-

* Glossary

up = user process

pc = program counter

spl = set priority level

ilock = interrupt safe version of lock (disable interruptions)

umb = upper memory block

RMAP = RAM map

PDB = page directory base

PTE = page table entry

tod = time of day

ap = application processor

EDF = Earliest Deadline First
http://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling

RPC = remote procedure call

EGRP = Environment group

FGRP = File descriptor Group (chans)

PGRP = Process Group (namespace)

VNO = Vector number (interrupt)

ISR = Interrupt Service Routine

TSC = Time Stamp Counter
http://en.wikipedia.org/wiki/Time_Stamp_Counter

intr = Interrupt (not INT, probably to avoid ambiguity with integer)

cistrcmp= ??

* (Re)Organization

split in subdirectories instead of having the very flat port/ and pc/
Generalize what they have done for ip/ and boot/ and add concurrency/,
memory/, files/, processes/, etc.

split portdat.h in subfiles, help understand things more
gradually. Make dependencies more clear.
Try to put the data ([port]dat) and prototype ([port]fns) closer to their
relevant directory (even though it can introduce backward dependencies).
It used to be a giant portdat_core.h but this was not good.

split portfns.h in subfiles, again help understand components.

Declare also in portfns_xxx.h the functions defined in 386/ which are
used in port/ code. So put in the fns_xxx.h files, functions used only
inside 386/.

Same for portdat_xxx.h, or at least declare in comments the
structures that are defined in 386/ but used outside in port.
Or better mv in portdat_xxx.h the arch-independent part of
the big structure (e.g. Conf, Arch), and put in arch specific hooks
(e.g. ArchMMU).

Qualify better pointers. In C pointers can be many things: 
list head, list tail, member of a list, hash, reference, option, array, etc.
Same for enum, they can be sometimes variant, bitset, etc.

Use portdat_xxx.h to define important structures and globals.
Put sometimes there also private structure to a file (e.g. Procalloc)
but that are important for understand things.

Have a arch/ where put really arch specific code not used from
port/ at all but containing helpers used by arch specific code
(e.g. nvram.c, bios3d.c, etc).

TODO: use literate programming to better introduce big data structure,
especially put the list related, queue related, hash related closer
together. This is because C does not handle very well lists, does not
provide reusable abstraction and so list are embedded inside
the element itself. Use LP to alleviate this (or at least
put such fields at the end of the structure).

* Misc

** notes

I use // to comment, so it's easy to see if the code comes from me
(and no need verbose //pad:)

** ref vs non ref
if the structure "own" the substructure, then don't use ref
but if structure use as reference in an array of another structure,
then use ref.

** types

implicit: 
char* = string

** call convention
Assume function returns is in AX.
Assume parameters passed by stack 0(FP), etc.

* Principles

** abstractions

** optimizations

caching
 (buffer cache, cache.c)
 (swap is a form of caching because limited ram is used first, and when no
  more then put on disk)

parallelizing
 use different processors, and so use locks

sharing
 (text segment for binaries, namespaces, heap segment copy-on-write)

lazy 
 (demand loading for text segment)


gc, reference counting

hash

sparse tree (double index table) (Segment, Pte, Page)
 and even inline ssegmap (like in ext2 inode, indirect, double indirect,
 inline)

** testing
no way to unit test this big software?

* Non features

** non goal?

*** uid, gid? 

*** shared libraries?

** would be nice to have

* Explanations

** up

"it can not be a global, because each processor have different user processes
so up is defined as a macro to be the extern up of the Mach per processor
structure

concurrency issue when accessing up? 

What can "interrupt" or execute in parallel with current kernel code?

Another processor can be also in kernel code, but it will be a different up!

The current kernel code can be interrupted, but interrupt code are supposed
to do very little so there should be no race on global important data structures.


** externup
why extern?

** spl
(lo, hi), lo = enable interrupt, hi = disable interrupt

** ilock vs lock

lock is good for mutual exclusion between different processors in kernel code,
but we also need mutual exclusion on same processor because kernel code
could have been interrupted (by interrupt) on the same processor.
so ilock allow to not lock yourself ...


** qid

why int? why not string?
because of distributed nature of plan9? that was designed with
distribution in mind?

** memory

xalloc (128?), pool, ...

page

malloc


segment vs page

list, hash, reference counting
arena, pool, page, ...


there are lots of data structures initialized in memory
when load kernel (text+data) in memory! so xlists, mainmem,
devtab, etc are all allocated memory and initialized with
the right value. no need malloc for that! no chicken and egg.
So one have xlists and confmem that describe the memory,
can use xalloc to get chunk of this memory.
xalloc for procs, for all Pages, etc.

** first process 
not that this first process is important because everything will be forked
from it and so all namespace set in the first process will be inherited.

TODO: could simplify things probably

*** userinit()

first newproc()
then set:
 - kernel pc stack = init0(), that do then touser() (defined in syscall/386/plan9l.s)
  => switch to user text binary
 - user text binary = initcode (via data2txt in initcode.h from init9.c and initcode.c

*** initcode
who calls _main()??

init/386/init9.c:_main() -> init/initcode.c:startboot() -> exec("/boot/boot")

*** boot
boot/386/bootpcf.c:main() -> boot/boot.c:boot() -> execinit() -> exec("/bin/rc")

