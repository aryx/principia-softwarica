\section{[[arch/]]}

\subsection*{[[arch/386/arch.c]]}

<<arch.c>>=
<<kernel basic includes>>
//todo: weird, if don't include this file, then can't declare arch in this file
// or I get some type signature mismatch
#include "io.h"

<<global arch>>

<<hook fprestore and fpsave>>

int (*_pcmspecial)(char*, ISAConf*);
void (*_pcmspecialclose)(int);

/*
 *  call either the pcmcia or pccard device setup
 */
int
pcmspecial(char *idstr, ISAConf *isa)
{
    return (_pcmspecial != nil)? _pcmspecial(idstr, isa): -1;
}

<<function cpuidprint>>

<<function cycles and default implementation>>

<<function cmpswap and default implementation>>

/*
 * On a uniprocessor, you'd think that coherence could be nop,
 * but it can't.  We still need a barrier when using coherence() in
 * device drivers.
 *
 * On VMware, it's safe (and a huge win) to set this to nop.
 * Aux/vmware does this via the #P/archctl file.
 */
//now in globals.c: void (*coherence)(void) = nop;


<<function timerset>>

<<function us>>

<<function fastticks>>
@

%/*
% *  call either the pcmcia or pccard device teardown
% */
%//void
%//pcmspecialclose(int a)
%//{
%//  if (_pcmspecialclose != nil)
%//      _pcmspecialclose(a);
%//}


\subsection*{[[arch/386/dat_arch.h]]}


<<struct IOMap>>=
struct IOMap
{
    char    tag[13];
    ulong   start;
    ulong   end;

    // extra
    // list<ref<IOMap>> of Iomapalloc.free
    IOMap   *next;

    bool    reserved;
};
@ 
% next used to have to be at the first field of IOMap?! otherwise get fault??


<<struct Iomapalloc>>=
struct Iomapalloc
{
    // ??
    IOMap   *m;

    // list<ref<IOMap>> (next = IOMap.next)
    IOMap   *free;
    // array<IOMAP> pool
    IOMap   maps[32];   /* some initial free maps */

    // extra
    Lock;
    QLock   ql;     /* lock for reading map */
};
@ 


<<struct X86type>>=
struct X86type {
    int family;
    int model;
    int aalcycles;
    char*   name;
};
@ 


<<struct Devport>>=
struct Devport {
    ulong port; 
    int size;
};
@ 


<<struct DevConf>>=
struct DevConf
{
    ulong intnum;     /* interrupt number */
    char  *type;      /* card type, malloced */
    int nports;     /* Number of ports */
    Devport *ports;     /* The ports themselves */
};
@ 


<<dat_arch.h>>=

//*****************************************************************************
// IO Map
//*****************************************************************************

// All the ref<IOMap> here are references to IOMap in the array<IOMap> of 
// Iomapalloc.maps (pool allocator)

<<struct IOMap>>

<<struct Iomapalloc>>

// array<IMap> alloced statically in maps
extern struct Iomapalloc iomap;

//*****************************************************************************
// PC Architecture hooks (interrupts, clocks, power, reset)
//*****************************************************************************

/*
 *  routines for things outside the PC model, like power management
 */
<<struct PCArch>>
extern PCArch *arch;      /* PC architecture */
extern PCArch archgeneric;

//*****************************************************************************
// Co processor
//*****************************************************************************

<<struct FPstate>>

<<struct FPssestate>>

<<struct  SFPssestate>>

//*****************************************************************************
// Misc
//*****************************************************************************

struct BIOS32ci {   /* BIOS32 Calling Interface */
  u32int  eax;
  u32int  ebx;
  u32int  ecx;
  u32int  edx;
  u32int  esi;
  u32int  edi;
};


// used to be in devrtc.c, but to remove some backward deps had to be here
// it's really used only by nvram.c and devrtc.c
/*
 *  real time clock and non-volatile ram
 */

enum {
    Paddr=      0x70,   /* address port */
    PdataPort=      0x71,   /* data port */
};
extern Lock nvrtlock;

<<struct X86type>>

extern X86type *cputype;


/*
 *  hardware info about a device
 */
<<struct Devport>>

<<struct DevConf>>
@


\section{[[buses/]]}

\section{[[concurrency/]]}

\subsection*{[[concurrency/386/l_concurrency.s]]}

<<l_concurrency.s>>=
#include "mem.h"

<<function splhi>>

<<function spllo>>

<<function splx>>

<<function islo>>

/*
 * Test-And-Set.
 */
<<function tas>>

<<function _xinc>>

<<function _xdec>>
@


\subsection*{[[concurrency/portdat_concurrency.h]]}

\ifallcode
<<lock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
        l->lockcycles = -lcycles();
#endif
@ 
\fi

\ifallcode
<<[[Lock]] debugging fields>>=
//#ifdef LOCKCYCLES
long  lockcycles;
//#endif
@ 
\fi


\ifallcode
<<unlock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumlockcycles += l->lockcycles;
    if(l->lockcycles > maxlockcycles){
        maxlockcycles = l->lockcycles;
        maxlockpc = l->pc;
    }
#endif
@ 
\fi

\ifallcode
<<iunlock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumilockcycles += l->lockcycles;
    if(l->lockcycles > maxilockcycles){
        maxilockcycles = l->lockcycles;
        maxilockpc = l->pc;
    }
    if(l->lockcycles > 2400)
        ilockpcs[n++ & 0xff]  = l->pc;
#endif
@ 
\fi


<<portdat_concurrency.h>>=

//*****************************************************************************
// Mutual exclusion
//*****************************************************************************

// tas < Lock < QLock|RWLock

// used to be in 386/ but the fields were used from port/ so must be portable!
<<struct Lock>>

<<struct QLock>>

// Read/Write lock
<<struct RWlock>>

//*****************************************************************************
// Atomicity
//*****************************************************************************

<<struct Ref>>
<<struct Counter>>

//*****************************************************************************
// Synchronization
//*****************************************************************************

// defined in this directory but no functions are operating on it in this dir
<<struct Rendez>>

<<struct Sema>>

// see also Waitq in portdat_processes.h?
@


\subsection*{[[concurrency/portfns_concurrency.h]]}

\ifallcode
<<portfns_concurrency.h>>=

// taslock.c
int lock(Lock*);
void unlock(Lock*);
void ilock(Lock*);
void iunlock(Lock*);
int canlock(Lock*);

// ref.c
long    incref(Ref*);
long    decref(Ref*);

// qlock.c
void    qlock(QLock*);
void    qunlock(QLock*);
int   canqlock(QLock*);

void    rlock(RWlock*);
void    runlock(RWlock*);
int   canrlock(RWlock*);
void    wlock(RWlock*);
void    wunlock(RWlock*);

// in 386/l.s (but used in port)
//@Scheck: Assembly
bool   islo(void);
//@Scheck: Assembly
int   splhi(void);
//@Scheck: Assembly
int   spllo(void);
//@Scheck: Assembly
void    splx(int);
//void    splxpc(int);
//long    lcycles(void);
//test-and-set
//@Scheck: Assembly
int tas(void*);
//@Scheck: Assembly
void    _xinc(long*);
//@Scheck: Assembly
long    _xdec(long*);
@
\fi

\subsection*{[[concurrency/qlock.c]]}

\ifallcode
<<struct QlockStats>>=
struct QlockStats {
    ulong rlock;
    ulong rlockq;
    ulong wlock;
    ulong wlockq;
    ulong qlock;
    ulong qlockq;
};
@

<<global rwstats>>=
struct QlockStats rwstats;
@
\fi


<<qlock.c>>=
<<kernel basic includes>>

<<struct QlockStats>>
<<global rwstats>>

<<function qlock>>

<<function canqlock>>

<<function qunlock>>

<<function rlock>>

<<function runlock>>

<<function wlock>>

<<function wunlock>>

<<function canrlock>>
@


\subsection*{[[concurrency/ref.c]]}


<<ref.c>>=
<<kernel basic includes>>

// was in chan.c (see also _incnt and _deccnt in tasklock.c)
<<function incref>>

<<function decref>>
@


\subsection*{[[concurrency/taslock.c]]}

\ifallcode
<<struct TaslockStats>>=
struct TaslockStats
{
    ulong   locks;
    ulong   glare;
    ulong   inglare;
};
@

<<global lockstats>>=
struct TaslockStats lockstats;
@

<<globals lockcycles>>=
#ifdef LOCKCYCLES
long maxlockcycles;
long maxilockcycles;
long cumlockcycles;
long cumilockcycles;
ulong maxlockpc;
ulong maxilockpc;

ulong ilockpcs[0x100] = { [0xff] = 1 };
static int n;
#endif
@

\fi


<<taslock.c>>=
// TAS: Test And Set
<<kernel basic includes>>

<<struct TaslockStats>>
<<global lockstats>>
<<globals lockcycles>>

<<function inccnt>>

<<function deccnt>>

<<function lockloop>>

<<function lock>>

<<function ilock>>

<<function canlock>>

<<function unlock>>

<<function iunlock>>

@



\section{[[console/]]}

\subsection*{[[console/devcons.c]]}

\ifallcode
<<devcons.c forward decl>>=
static void seedrand(void);
static int  readtime(ulong, char*, int);
static int  readbintime(char*, int);
static int  writetime(char*, int);
static int  writebintime(char*, int);
@
\fi


<<devcons.c>>=
<<kernel basic includes>>

#include    <pool.h>

// used also by edf.c
<<global panicking>>

<<hook screenputs>>
<<hook consdebug>>

<<global kbdq>>
<<global lineq>>
<<global serialoq>>
<<global kprintoq>>

<<global kprintinuse>>
<<global iprintscreenputs>>

<<struct ConsKbd>>

<<global kbd>>

<<global fasthz>>

<<devcons.c forward decl>>

<<function lineqinit>>

<<function consactive>>

<<function prflush>>

<<struct KMesg>>

<<global kmesg>>

<<function kmesgputs>>

<<function putstrn0>>

<<function putstrn>>

<<function print>>

<<global iprintlock>>

<<function iprintcanlock>>

<<function iprint>>

<<function panic>>

<<function sysfatal>>

<<function _assert>>

<<function pprint>>

<<function echoscreen>>

<<function echoserialoq>>

<<function echo>>

<<function kbdcr2nl>>

<<function kbdputc>>

<<clock callback kbdputcclock>>

<<devcons.c enum Qxxx>>

enum
{
    <<constant VLNUMSIZE>>
};

<<global consdir>>

<<method consinit>>

static Chan*
consattach(char *spec)
{
    return devattach('c', spec);
}

static Walkqid*
conswalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name,nname, consdir, nelem(consdir), devgen);
}

static int
consstat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, consdir, nelem(consdir), devgen);
}

<<method consopen>>

<<method consclose>>

<<method consread>>

<<method conswrite>>

<<global consdevtab>>

<<global randn>>

<<function seedrand>>

<<function nrand>>

<<global uvorder>>

<<function le2vlong>>

<<function vlong2le>>

<<global order>>

<<function le2long>>

<<devcons.c Exxx errors>>

<<function readtime>>

<<function writetime>>

<<function readbintime>>

<<function writebintime>>
@

%
%
%//static uchar*
%//long2le(uchar *t, long from)
%//{
%//  uchar *f, *o;
%//  int i;
%//
%//  f = (uchar*)&from;
%//  o = (uchar*)&order;
%//  for(i = 0; i < sizeof(long); i++)
%//      t[i] = f[o[i]];
%//  return t+sizeof(long);
%//}

\subsection*{[[console/portdat_console.h]]}

\ifallcode
<<portdat_console.h>>=
extern  Queue*  kbdq;
extern  Queue*  kprintoq;
extern  Queue*  serialoq;

// consdevtab
@
\fi

\subsection*{[[console/portfns_console.h]]}

\ifallcode
<<portfns_console.h>>=

// devcons.c
// in portfns_core.h, to remove some backward dependencies
//int   (*pprint)(char*, ...);
//void    (*_assert)(char*);
void    lineqinit(void);
int   kbdputc(Queue*, int);
int   consactive(void);
int   kbdcr2nl(Queue*, int);
int   nrand(int);
void    putstrn(char*, int);
// (*print) is declared lib.h
//int   (*iprint)(char*, ...);
//void    (*panic)(char*, ...);
// as a pointer in the original too
void    (*screenputs)(char*, int);
//void    prflush(void);
//int   rand(void);
// overrides also sysfatal from libc/9sys/sysfatal.c, that are called
// from a few libc functions

// rdb.c
void    rdb(void);

// print.c
// overrides _fmtlock, from lib_core/libc/fmt/fmtlock.c that are used
// in fmt related functions
@
\fi

\section{[[core/]]}

\subsection*{[[core/386/dat.h]]}

\subsection*{[[core/386/dat_core.h]]}

<<dat_core.h>>=

//*****************************************************************************
// Cpu extension
//*****************************************************************************

<<struct Tss>>

<<struct Segdesc>>

<<struct ArchCpu>>

//*****************************************************************************
// Conf extension?
//*****************************************************************************

@


\subsection*{[[core/386/dat_forward.h]]}


\ifallcode
<<dat_forward.h pragma>>=
#pragma incomplete BIOS32si
#pragma incomplete Pcidev
#pragma incomplete Ureg
@
\fi

\ifallcode
<<dat_forward.h>>=
typedef union ArchFPsave  ArchFPsave;
typedef struct ArchProcMMU ArchProcMMU;

typedef struct BIOS32si BIOS32si;
typedef struct BIOS32ci BIOS32ci;
typedef struct FPssestate FPssestate;
typedef struct SFPssestate SFPssestate;
typedef struct FPstate  FPstate;
typedef struct ISAConf  ISAConf;
typedef struct MMU  MMU;
typedef struct PCArch PCArch;
typedef struct Pcidev Pcidev;
typedef struct PCMmap PCMmap;
typedef struct PCMslot  PCMslot;
typedef struct Segdesc  Segdesc;

typedef struct Ureg Ureg;
typedef struct Vctl Vctl;

// was not there, but seems more consistent
typedef struct Tss Tss;
typedef struct Devport Devport;
typedef struct IOMap IOMap;
typedef struct X86type X86type;
typedef struct I8253 I8253;

// needed in arch specific stuff
typedef struct Page Page;
typedef struct Proc Proc;
typedef struct Lock Lock;

// was in io.h
typedef struct Pcisiz Pcisiz;
typedef struct Pcidev Pcidev;
typedef struct PCMslot    PCMslot;
typedef struct PCMconftab PCMconftab;

// was in mp.h
typedef struct PCMP PCMP;
typedef struct _MP_ _MP_;
typedef struct PCMPprocessor PCMPprocessor;
typedef struct PCMPbus PCMPbus;
typedef struct PCMPioapic PCMPioapic;
typedef struct PCMPintr PCMPintr;
typedef struct Aintr Aintr;
typedef struct Bus Bus;
typedef struct Apic Apic;

// was in mpacpi.h
typedef struct Dsdt Dsdt;
typedef struct Facp Facp;
typedef struct Hpet Hpet;
typedef struct Madt Madt;
typedef struct Mcfg Mcfg;
typedef struct Mcfgd Mcfgd;
typedef struct Rsd Rsd;

// was in sd.h
typedef struct SDev SDev;
typedef struct SDifc SDifc;
typedef struct SDio SDio;
typedef struct SDpart SDpart;
typedef struct SDperm SDperm;
typedef struct SDreq SDreq;
typedef struct SDunit SDunit;

<<dat_forward.h pragma>>
@
\fi

\subsection*{[[core/386/fns.c]]}

% used by isaconfig
<<function cistrncmp>>=
int
cistrncmp(char *a, char *b, int n)
{
    unsigned ac, bc;

    while(n > 0){
        ac = *a++;
        bc = *b++;
        n--;

        if(ac >= 'A' && ac <= 'Z')
            ac = 'a' + (ac - 'A');
        if(bc >= 'A' && bc <= 'Z')
            bc = 'a' + (bc - 'A');

        ac -= bc;
        if(ac)
            return ac;
        if(bc == 0)
            break;
    }

    return 0;
}
@

% used by getconf
<<function cistrcmp>>=
int
cistrcmp(char *a, char *b)
{
    int ac, bc;

    for(;;){
        ac = *a++;
        bc = *b++;
    
        if(ac >= 'A' && ac <= 'Z')
            ac = 'a' + (ac - 'A');
        if(bc >= 'A' && bc <= 'Z')
            bc = 'a' + (bc - 'A');
        ac -= bc;
        if(ac)
            return ac;
        if(bc == 0)
            break;
    }
    return 0;
}
@


<<fns.c>>=
<<kernel basic includes>>

// backward deps trick too
int (*isaconfig)(char*, int, ISAConf*) = 0;

// was in main.c, could be in lib/386/libc.c (or even lib/libc.c)

<<function cistrncmp>>

<<function cistrcmp>>

@


\subsection*{[[core/386/fns.h]]}

<<fns.h macros>>=
<<function KADDR>>
<<function PADDR>>

// used in devaudio, maybe could remove it
#define dcflush(a, b)

#define BIOSSEG(a)  KADDR(((uint)(a))<<4)

#define L16GET(p) (((p)[1]<<8)|(p)[0])
#define L32GET(p) (((u32int)L16GET((p)+2)<<16)|L16GET(p))
@


\ifallcode
<<fns.h declarations>>=

// used by $CONF.c and main.c
void    bootlinks(void);

// defined in lib/latin1.c, used only in 386
long    latin1(Rune*, int);

// used by main.c
void    cpuinit(void);

// used by main.c
void mmuinit0(void);

// iomap.c
void (*hook_ioalloc)();

//@Scheck: Assembly
void    forkret(void);
//@Scheck: Assembly
void  aamloop(int);
//void  acpiscan(void (*func)(uchar *));
Dirtab* addarchfile(char*, int, long(*)(Chan*,void*,long,vlong), long(*)(Chan*,void*,long,vlong));
void  archinit(void);
void  archrevert(void);
//@Scheck: Assembly
int bios32call(BIOS32ci*, u16int[3]);
int bios32ci(BIOS32si*, BIOS32ci*);
//void  bios32close(BIOS32si*);
BIOS32si* bios32open(char*);
void  cgapost(int);
//void  clockintr(Ureg*, void*);
int (*cmpswap)(long*, long, long);
//@Scheck: Assembly
int cmpswap486(long*, long, long);
//@Scheck: Assembly
void  cpuid(int, ulong regs[]);
int cpuidentify(void);
void  cpuidprint(void);
void  (*cycles)(uvlong*);
//int dmacount(int);
//int dmadone(int);
void  dmaend(int);
int dmainit(int, int);
long  dmasetup(int, void*, long, int);
#define evenaddr(x)       /* x86 doesn't care */
//@Scheck: Assembly
void  fpclear(void);
//@Scheck: Assembly
void  fpenv(ArchFPsave*);
//@Scheck: Assembly
void  fpinit(void);
//@Scheck: Assembly
void  fpoff(void);
//@Scheck: Assembly
void  fpon(void);
void  (*fprestore)(ArchFPsave*);
void  (*fpsave)(ArchFPsave*);
void  fpsavealloc(void);
void  fpsserestore(ArchFPsave*);
//@Scheck: Assembly
void  fpsserestore0(ArchFPsave*);
void  fpssesave(ArchFPsave*);
//@Scheck: Assembly
void  fpssesave0(ArchFPsave*);
//ulong fpstatus(void);
//@Scheck: Assembly
void  fpx87restore(ArchFPsave*);
//@Scheck: Assembly
void  fpx87save(ArchFPsave*);
//@Scheck: Assembly
ulong getcr0(void);
//@Scheck: Assembly
ulong getcr2(void);
//@Scheck: Assembly
ulong getcr3(void);
//@Scheck: Assembly
ulong getcr4(void);
void  guesscpuhz(int);
//@Scheck: Assembly
void  halt(void);
int i8042auxcmd(int);
//int i8042auxcmds(uchar*, int);
void  i8042auxenable(void (*)(int, int));
void  i8042reset(void);
void  i8250console(void);
void* i8250alloc(int, int, int);
void  i8250mouse(char*, int (*)(Queue*, int), int);
void  i8250setmouseputc(char*, int (*)(Queue*, int));
void  i8253enable(void);
void  i8253init(void);
uvlong  i8253read(uvlong*);
void  i8253timerset(uvlong);
int i8259disable(int);
int i8259enable(Vctl*);
void  i8259init(void);
int i8259isr(int);
void  i8259on(void);
void  i8259off(void);
int i8259vecno(int);
//@Scheck: Assembly
void  idle(void);
void  idlehands(void);
//@Scheck: Assembly
int inb(int);
//void  insb(int, void*, int);
//@Scheck: Assembly
ushort  ins(int);
//@Scheck: Assembly
void  inss(int, void*, int);
//@Scheck: Assembly
ulong inl(int);
//void  insl(int, void*, int);
int intrdisable(int, void (*)(Ureg *, void *), void*, int, char*);
void  intrenable(int, void (*)(Ureg*, void*), void*, int, char*);
//void  introff(void);
//void  intron(void);
//@Scheck: Assembly
void  invlpg(ulong);
void  iofree(int);
void  ioinit(void);
int ioalloc(int, int, int, char*);
//int ioreserve(int, int, int, char*);
int (*isaconfig)(char*, int, ISAConf*);
void  kbdenable(void);
void  kbdinit(void);
<<function kmapinval>>
//@Scheck: Assembly
void  lgdt(ushort[3]);
//@Scheck: Assembly
void  lidt(ushort[3]);
void  links(void);
//@Scheck: Assembly
void  ltr(ulong);
//@Scheck: Assembly
void  mb386(void);
//@Scheck: Assembly
void  mb586(void);
void  meminit(void);
void  memorysummary(void);
//@Scheck: Assembly
void  mfence(void);
<<function mmuflushtlb>>
void  mmuinit(void);
ulong*  mmuwalk(ulong*, ulong, int, bool);
int mtrr(uvlong, uvlong, char *);
void  mtrrclock(void);
int mtrrprint(char *, long);
uchar nvramread(int);
void  nvramwrite(int, uchar);
//@Scheck: Assembly
void  outb(int, int);
//void  outsb(int, void*, int);
//@Scheck: Assembly
void  outs(int, ushort);
//@Scheck: Assembly
void  outss(int, void*, int);
//@Scheck: Assembly
void  outl(int, ulong);
//void  outsl(int, void*, int);
int pcicfgr8(Pcidev*, int);
int pcicfgr16(Pcidev*, int);
int pcicfgr32(Pcidev*, int);
void  pcicfgw8(Pcidev*, int, int);
//void  pcicfgw16(Pcidev*, int, int);
void  pcicfgw32(Pcidev*, int, int);
void  pciclrbme(Pcidev*);
//void  pciclrioe(Pcidev*);
//void  pciclrmwi(Pcidev*);
//int pcigetpms(Pcidev*);
Pcidev* pcimatch(Pcidev*, int, int);
Pcidev* pcimatchtbdf(int);
void  pcireset(void);
//int pciscan(int, Pcidev**);
void  pcisetbme(Pcidev*);
//void  pcisetioe(Pcidev*);
//void  pcisetmwi(Pcidev*);
//int pcisetpms(Pcidev*, int);
void  pcmcisread(PCMslot*);
//int pcmcistuple(int, int, int, void*, int);
PCMmap* pcmmap(int, ulong, int, int);
int pcmspecial(char*, ISAConf*);
int (*_pcmspecial)(char *, ISAConf *);
//void  pcmspecialclose(int);
void  (*_pcmspecialclose)(int);
void  pcmunmap(int, PCMmap*);
int pdmap(ulong*, ulong, ulong, int);
void  procrestore(Proc*);
void  procsave(Proc*);
void  procsetup(Proc*);
//@Scheck: Assembly
void  putcr0(ulong);
//@Scheck: Assembly
void  putcr3(ulong);
//@Scheck: Assembly
void  putcr4(ulong);
kern_addr3 rampage(void);
//@Scheck: Assembly
void  rdmsr(int, vlong*);
void  realmode(Ureg*);
void  screeninit(void);
void  (*screenputs)(char*, int);
void* sigsearch(char*);
void  syncclock(void);
void  syscallfmt(int syscallno, ulong pc, va_list list);
void  sysretfmt(int syscallno, va_list list, long ret, uvlong start, uvlong stop);
void* tmpmap(Page*);
void  tmpunmap(void*);
//@Scheck: Assembly
void  touser(void*);
void  trapenable(int, void (*)(Ureg*, void*), void*, char*);
void  trapinit(void);
void  trapinit0(void);
ulong upaalloc(int, int);
//void  upafree(ulong, int);
void  upareserve(ulong, int);
<<function userureg>>
//@Scheck: Assembly
void  vectortable(void);
void* vmap(ulong, int);
int vmapsync(ulong);
void  vunmap(void*, int);
//@Scheck: Assembly
void  wbinvd(void);
//@Scheck: Assembly
void  wrmsr(int, vlong);
//int xchgw(ushort*, int);

//int iounused(int start, int end); not used anymore in vga.c

<<fns.h macros>>
@
\fi
%$

\subsection*{[[core/error.h]]}

\ifallcode
<<error.h>>=
extern char Emount[];   /* inconsistent mount */
extern char Eunmount[];   /* not mounted */
extern char Eismtpt[];    /* is a mount point */
extern char Eunion[];   /* not in union */
extern char Emountrpc[];  /* mount rpc error */
extern char Eshutdown[];  /* device shut down */
extern char Enocreate[];  /* mounted directory forbids creation */
extern char Enonexist[];  /* file does not exist */
extern char Eexist[];   /* file already exists */
extern char Ebadsharp[];  /* unknown device in # filename */
extern char Enotdir[];    /* not a directory */
extern char Eisdir[];   /* file is a directory */
extern char Ebadchar[];   /* bad character in file name */
extern char Efilename[];  /* file name syntax */
extern char Eperm[];    /* permission denied */
extern char Ebadusefd[];  /* inappropriate use of fd */
extern char Ebadarg[];    /* bad arg in system call */
extern char Einuse[];   /* device or object already in use */
extern char Eio[];    /* i/o error */
extern char Etoobig[];    /* read or write too large */
extern char Etoosmall[];  /* read or write too small */
extern char Ehungup[];    /* i/o on hungup channel */
extern char Ebadctl[];    /* bad process or channel control request */
extern char Enodev[];   /* no free devices */
extern char Eprocdied[];  /* process exited */
extern char Enochild[];   /* no living children */
extern char Eioload[];    /* i/o error in demand load */
extern char Enovmem[];    /* virtual memory allocation failed */
extern char Ebadfd[];   /* fd out of range or not open */
extern char Enofd[];    /* no free file descriptors */
extern char Eisstream[];  /* seek on a stream */
extern char Ebadexec[];   /* exec header invalid */
extern char Etimedout[];  /* connection timed out */
extern char Econrefused[];  /* connection refused */
extern char Econinuse[];  /* connection in use */
extern char Eintr[];    /* interrupted */
extern char Enomem[];   /* kernel allocate failed */
extern char Esoverlap[];  /* segments overlap */
extern char Emouseset[];  /* mouse type already set */
extern char Eshort[];   /* i/o count too small */
extern char Egreg[];    /* jmk added reentrancy for threads */
extern char Ebadspec[];   /* bad attach specifier */
extern char Enoreg[];   /* process has no saved registers */
extern char Enoattach[];  /* mount/attach disallowed */
extern char Eshortstat[]; /* stat buffer too small */
extern char Ebadstat[];   /* malformed stat buffer */
extern char Enegoff[];    /* negative i/o offset */
extern char Ecmdargs[];   /* wrong #args in control message */
extern char Ebadip[];   /* bad ip address syntax */
extern char Edirseek[];   /* seek in directory */
extern char Echange[];    /* media or partition has changed */
@
\fi

%//extern char Enoerror[];   /* no error */
%//extern char Enoport[];    /* network port not available */
%//extern char Enoswap[];    /* swap space full */
%//extern char Estalled[];   /* endpoint stalled */
%//extern char Edetach[];    /* device is detached */
%//extern char Enotconf[];   /* endpoint not configured */
%//extern char Eaoedown[];   /* aoe device is down */

\subsection*{[[core/error.c]]}

<<error.c>>=
<<global Exxx errors>>
@

\subsection*{[[core/portdat.c]]}


<<portdat.c>>=
<<kernel basic includes>>

// was in init/main.c
<<global conf>>
// bool cpuserver; // defined in $CONF.c

<<globals confname and confvar>>

<<function getconf>>

// was in init/main.c
<<global cpu>>
// was in dat.h
<<global cpus>>

// was in security/auth.c
<<global eve>>
// should be in portfns.c, but then backward deps
/*
 *  return true if current user is eve
 */
<<function iseve>>

@
%$

\subsection*{[[core/portdat.h]]}

\ifallcode
<<portdat.h pragmas>>=
#pragma varargck  type  "I" uchar*
#pragma varargck  type  "V" uchar*
#pragma varargck  type  "E" uchar*
#pragma varargck  type  "M" uchar*
@
\fi


<<enum misc_constants>>=
enum misc_constants
{
    <<constant MAXSYSARG>>

    <<constant PRINTSIZE>>
    <<constant KMESGSIZE>>
    <<constant STAGESIZE>>

    NUMSIZE = 12,   /* size of formatted number */
    /* READSTR was 1000, which is way too small for usb's ctl file */
    READSTR = 4000,   /* temporary buffer size for device reads */

    KB      = 1024,
    MB =    (1024*1024),

    /* cpuid instruction result register bits */
    // this is actually only used in 386/ code. 
    /* dx */
    Fpuonchip = 1<<0,
    Vmex  = 1<<1,   /* virtual-mode extensions */
    Pse = 1<<3,   /* page size extensions */
    Tsc = 1<<4,   /* time-stamp counter */
    Cpumsr  = 1<<5,   /* model-specific registers, rdmsr/wrmsr */
    Mce = 1<<7,   /* machine-check exception */
    Mtrr  = 1<<12,  /* memory-type range regs.  */
    Pge = 1<<13,  /* page global extension */
    Fxsr  = 1<<24,  /* have SSE FXSAVE/FXRSTOR */
    Sse2  = 1<<26,  /* thus mfence & lfence instr.s */
};
@
%  //  MAXCRYPT =  127,

%//  Pae = 1<<6,   /* physical-addr extensions */

%//  Cmpxchg8b = 1<<8,
%//  Cpuapic = 1<<9,
%//  Pse2  = 1<<17,  /* more page size extensions */
%//  Clflush = 1<<19,
%//  Mmx = 1<<23,
%//  Sse = 1<<25,  /* thus sfence instr. */



<<portdat.h macros>>=
#define MIN(a, b) ((a) < (b)? (a): (b))
#define HOWMANY(x, y) (((x)+((y)-1))/(y))
#define ROUNDUP(x, y) (HOWMANY((x), (y))*(y)) /* ceiling */

// BY2PG is defined in mem.h, which should always be included before "dat.h"!
#define PGROUND(s)  ROUNDUP(s, BY2PG)
@


%/*
% * For multi-bit fields use FIELD(v, o, w) where 'v' is the value
% * of the bit-field of width 'w' with LSb at bit offset 'o'.
% */
%//#define MAX(a, b) ((a) > (b)? (a): (b))
%//#define ROUNDDN(x, y) (((x)/(y))*(y))   /* floor */
%//#define FIELD(v, o, w)  (((v) & ((1<<(w))-1))<<(o))
%//#define FCLR(d, o, w) ((d) & ~(((1<<(w))-1)<<(o)))
%//#define FEXT(d, o, w) (((d)>>(o)) & ((1<<(w))-1))
%//#define FINS(d, o, w, v) (FCLR((d), (o), (w))|FIELD((v), (o), (w)))
%//#define FSET(d, o, w) ((d)|(((1<<(w))-1)<<(o)))
%//#define FMASK(o, w) (((1<<(w))-1)<<(o))
%
%//#define MAXBY2PG BY2PG    /* rounding for UTZERO in executables */
%
%//enum
%//{
%//  NSMAX = 1000,
%//  NSLOG = 7,
%//  NSCACHE = (1<<NSLOG),
%//};
%//enum
%//{
%//  NCMDFIELD = 128
%//};
%/*
% *  action log
% */
%//struct Log {
%//  Lock;
%//  int opens;
%//  char* buf;
%//  char  *end;
%//  char  *rptr;
%//  int len;
%//  int nlog;
%//  int minread;
%//
%//  int logmask;  /* mask of things to debug */
%//
%//  QLock readq;
%//  Rendez  readr;
%//};
%//
%//struct Logflag {
%//  char* name;
%//  int mask;
%//};
%//


\subsection*{[[core/portdat_core.h]]}

<<portdat_core.h>>=

// All those structs used to be in dat.h, in 386/, but many of their fields
// were used from port/ so I've moved them here (and put the arch
// specific fields in dat_core.h)

//*****************************************************************************
// Conf
//*****************************************************************************

<<struct Confmem>>

<<struct Conf>>

extern Conf conf;

<<constant MAXCONF>>
// hash<string, string>
extern char *confname[];
extern char *confval[];
// Hashtbl.length(confname)
extern int nconf;

extern bool cpuserver; // defined in $CONF.c

char* getconf(char *name);

//*****************************************************************************
// Cpu
//*****************************************************************************

<<struct Label>>

<<struct Perf>>

<<struct Cpu>>

// ref<Cpu>, the actual Cpu is where??
extern Cpu *cpu;
// array<ref<Cpu>>, MAXCPUS is defined in 386/mem.h
extern Cpu* cpus[MAXCPUS];
<<macro CPUS>>

<<macro up>>

//*****************************************************************************
// Other
//*****************************************************************************

extern char* eve;
int iseve(void);
// accessed by /dev/hostdomain, defined in auth.c
extern  char  hostdomain[];

// defined in ???
extern ulong    kerndate; 

@
%$

\subsection*{[[core/portdat_forward.h]]}

\ifallcode
<<portdat_forward.h pragmas>>=
#pragma incomplete DevConf
#pragma incomplete Edf
#pragma incomplete Mntcache
#pragma incomplete Mntrpc
#pragma incomplete Queue
#pragma incomplete Timers
@
\fi

\ifallcode
<<portdat_forward.h>>=
typedef struct Alarms Alarms;
typedef struct Block  Block;
typedef struct Chan Chan;
typedef struct Cmdbuf Cmdbuf;
typedef struct Cmdtab Cmdtab;
typedef struct Dev  Dev;
typedef struct Dirtab Dirtab;
typedef struct Edf  Edf;
typedef struct Egrp Egrp;
typedef struct Evalue Evalue;
typedef struct Execvals Execvals;
typedef struct Fgrp Fgrp;
typedef struct DevConf  DevConf;
typedef struct KImage KImage;
typedef struct Log  Log;
typedef struct Logflag  Logflag;
typedef struct Mntcache Mntcache;
typedef struct Mount  Mount;
typedef struct Mntrpc Mntrpc;
typedef struct Mntwalk  Mntwalk;
typedef struct Mnt  Mnt;
typedef struct Mhead  Mhead;
typedef struct Note Note;
typedef struct Page Page;
typedef struct Path Path;
typedef struct Palloc Palloc;
typedef struct Pallocmem  Pallocmem;
typedef struct Perf Perf;
typedef struct PhysUart PhysUart;
typedef struct Pgrp Pgrp;
typedef struct Physseg  Physseg;
typedef struct Proc Proc;
typedef struct Pagetable  Pagetable;
typedef struct KQLock QLock;
typedef struct Queue  Queue;
typedef struct Ref  Ref;
typedef struct Rendez Rendez;
typedef struct Rgrp Rgrp;
typedef struct RWlock RWlock;
typedef struct Sargs  Sargs;
typedef struct Schedq Schedq;
typedef struct Segment  Segment;
typedef struct Sema Sema;
typedef struct Timer  Timer;
typedef struct Timers Timers;
typedef struct Uart Uart;
typedef struct Waitq  Waitq;
typedef struct Walkqid  Walkqid;
typedef struct Watchdog Watchdog;

typedef int    Devgen(Chan*, char*, Dirtab*, int, int, Dir*);

// was in dat_forward.h
typedef struct Conf Conf;
typedef struct Confmem  Confmem;
typedef struct Lock Lock;
typedef struct Cpu Cpu;
typedef struct Label  Label;

// was in cache.c
typedef struct Extent Extent;
// was in xallo.c
typedef struct Hole Hole;
typedef struct Xalloc Xalloc;
typedef struct Xhdr Xhdr;

<<portdat_forward.h pragmas>>
@
\fi

\subsection*{[[core/portfns.c]]}

<<portfns.c>>=
<<kernel basic includes>>

// backward dependencies breaker for non functional properties functions
// (logging, security, error, profiling/timing)

// console/devcons.c
int (*print)(char*, ...) = 0;
int (*iprint)(char*, ...) = 0;
int (*pprint)(char *fmt, ...) = 0;

void (*panic)(char*, ...) = 0;
void (*_assert)(char *fmt) = 0;

// process/386/trap.c
void (*dumpstack)(void) = 0;
// process/proc.c
void (*dumpaproc)(Proc*) = 0;


// process/proc.c
void (*error)(char*) = 0;
void (*nexterror)(void) = 0;

void (*sched)(void) = 0;
void (*ready)(Proc*) = 0;
Proc* (*wakeup)(Rendez*) = 0;
void (*sleep)(Rendez*, int(*)(void*), void*) = 0;
void (*tsleep)(Rendez*, int (*)(void*), void*, ulong) = 0;

Proc* (*proctab)(int) = 0;
int (*postnote)(Proc*, int, char*, int) = 0;
void (*pexit)(char*, bool) = 0;

// files/chan.c
void (*cclose)(Chan*);

// init/main.c
void (*exit)(int ispanic) = 0;

// misc/386/devarch.c
void (*coherence)(void) = 0;

// misc/386/devarch.c
uvlong (*fastticks)(uvlong*) = 0;

// processes/386/i8253.c
void (*delay)(int) = 0;
void (*microdelay)(int) = 0;

<<function returnfalse>>

// was in devcons.c, could be in lib/misc.c
<<function readnum>>

<<function readstr>>
@

\subsection*{[[core/portfns.h]]}

%//unused and undefined:
%//void    addwatchdog(Watchdog*);
%//long    clrfpintr(void);
%//int   decrypt(void*, void*, int);
%//int   encrypt(void*, void*, int);
%//int   eqchan(Chan*, Chan*, int);
%//void    logopen(Log*);
%//void    logclose(Log*);
%//char*   logctl(Log*, int, char**, Logflag*);
%//void    logn(Log*, int, void*, int);
%//long    logread(Log*, void*, ulong, long);
%//void    log(Log*, int, char*, ...);
%//void    resched(char*);
%//void    savefpregs(FPsave*);


\subsection*{[[core/portfns_core.h]]}

\ifallcode
<<portfns_core.h pragmas>>=
#pragma varargck argpos iprint  1
#pragma varargck argpos pprint  1
#pragma varargck argpos panic 1
@
\fi

\ifallcode
<<portfns_core.h>>=

// exported in lib.h, defined in portfns.c
// (*print)

// exported in lib.h, defined in 386/fns.c (but used in port)
// int  cistrcmp(char*, char*);
// int  cistrncmp(char*, char*, int);

// portfns.c (mostly here just to remove some backward dependencies)
// console/devcons.c
int   (*iprint)(char*, ...);
int   (*pprint)(char*, ...);
void    (*panic)(char*, ...);
void    (*_assert)(char*);
// process/386/trap.c
void    (*dumpstack)(void);
// process/proc.c
void    (*dumpaproc)(Proc*);
// process/proc.c
void    (*error)(char*);
void    (*nexterror)(void);
// process/proc.c
void    (*sleep)(Rendez*, int(*)(void*), void*);
void    (*tsleep)(Rendez*, int (*)(void*), void*, ulong);
Proc*   (*wakeup)(Rendez*);
void    (*sched)(void);
void    (*ready)(Proc*);
// process/proc.c
Proc*   (*proctab)(int);
int     (*postnote)(Proc*, int, char*, int);
void    (*pexit)(char*, bool);
// files/chan.c
void    (*cclose)(Chan*);
// init/main.c
void    (*exit)(int);
//misc/386/devarch.c
void  (*coherence)(void);
uvlong    (*fastticks)(uvlong*);
// processes/386/i8253.c
void    (*microdelay)(int);
void    (*delay)(int);

// portfns.c
bool returnfalse(void*);
int   readnum(ulong, char*, ulong, ulong, int);
int   readstr(ulong, char*, ulong, char*);

<<portfns_core.h pragmas>>
@
\fi

\section{[[devices/]]}

\subsection*{[[devices/keyboard/386/kbd.c]]}

% main thing is the interrupt, set in kbdenable

\ifallcode
<<kbd.c forward decl>>=
typedef struct Kbscan Kbscan;
@
\fi

\ifallcode
<<kbd.c debugging macro>>=
static bool kdebug;
@
\fi


<<function setleds>>=
/*
 * set keyboard's leds for lock states (scroll, numeric, caps).
 *
 * at least one keyboard (from Qtronics) also sets its numeric-lock
 * behaviour to match the led state, though it has no numeric keypad,
 * and some BIOSes bring the system up with numeric-lock set and no
 * setting to change that.  this combination steals the keys for these
 * characters and makes it impossible to generate them: uiolkjm&*().
 * thus we'd like to be able to force the numeric-lock led (and behaviour) off.
 */
static void
setleds(Kbscan *kbscan)
{
    int leds;

    if(nokbd || kbscan != &kbscans[Int])
        return;
    leds = 0;
    if(kbscan->num)
        leds |= 1<<1;
    if(0 && kbscan->caps)       /* we don't implement caps lock */
        leds |= 1<<2;

    ilock(&i8042lock);
    outready();
    outb(Data, 0xed);       /* `reset keyboard lock states' */
    if(inready() == 0)
        inb(Data);

    outready();
    outb(Data, leds);
    if(inready() == 0)
        inb(Data);

    outready();
    iunlock(&i8042lock);
}
@

<<function kbdgetmap>>=
int
kbdgetmap(uint offset, int *t, int *sc, Rune *r)
{
    if ((int)offset < 0)
        error(Ebadarg);
    *t = offset/Nscan;
    *sc = offset%Nscan;
    switch(*t) {
    default:
        return 0;
    case 0:
        *r = kbtab[*sc];
        return 1;
    case 1:
        *r = kbtabshift[*sc];
        return 1;
    case 2:
        *r = kbtabesc1[*sc];
        return 1;
    case 3:
        *r = kbtabaltgr[*sc];
        return 1;
    case 4:
        *r = kbtabctrl[*sc];
        return 1;
    }
}
@


<<function kbdputmap>>=
void
kbdputmap(ushort m, ushort scanc, Rune r)
{
    if(scanc >= Nscan)
        error(Ebadarg);
    switch(m) {
    default:
        error(Ebadarg);
    case 0:
        kbtab[scanc] = r;
        break;
    case 1:
        kbtabshift[scanc] = r;
        break;
    case 2:
        kbtabesc1[scanc] = r;
        break;
    case 3:
        kbtabaltgr[scanc] = r;
        break;
    case 4: 
        kbtabctrl[scanc] = r;
        break;
    }
}
@

% used by mouse.c
<<function i8042auxenable>>=
void
i8042auxenable(void (*putc)(int, int))
{
    char *err = "i8042: aux init failed\n";

    /* enable kbd/aux xfers and interrupts */
    ccc &= ~Cauxdis;
    ccc |= Cauxint;

    ilock(&i8042lock);
    if(outready() < 0)
        print(err);
    outb(Cmd, 0x60);            /* write control register */
    if(outready() < 0)
        print(err);
    outb(Data, ccc);
    if(outready() < 0)
        print(err);
    outb(Cmd, 0xA8);            /* auxiliary device enable */
    if(outready() < 0){
        iunlock(&i8042lock);
        return;
    }
    auxputc = putc;
    intrenable(IrqAUX, i8042intr, 0, BUSUNKNOWN, "kbdaux");
    iunlock(&i8042lock);
}
@

<<hook auxputc>>=
static void (*auxputc)(int, int);
@

<<[[i8042intr()]] aux port handling>>=
    /*
     *  if it's the aux port...
     */
    if(s & Minready){
        if(auxputc != nil)
            auxputc(c, kbscans[Int].shift);
        return;
    }
@


<<kbd.c>>=
/*
 * keyboard input
 */
<<kernel basic includes>>

#include    "io.h"

<<kbd.c forward decl>>

enum {
    Data=       0x60,       /* data port */

    Status=     0x64,       /* status port */
     Inready=   0x01,       /*  input character ready */
     Outbusy=   0x02,       /*  output busy */
     Sysflag=   0x04,       /*  system flag */
     Cmddata=   0x08,       /*  cmd==0, data==1 */
     Inhibit=   0x10,       /*  keyboard/mouse inhibited */
     Minready=  0x20,       /*  mouse character ready */
     Rtimeout=  0x40,       /*  general timeout */
     Parity=    0x80,

    Cmd=        0x64,       /* command port (write only) */
};

<<enum specialkey>>

<<enum kbscan>>

static char *initfailed = "i8042: kbdinit failed\n";

<<global kbtab>>

<<global kbtabshift>>

<<global kbtabesc1>>

<<global kbtabaltgr>>

// see kbtab.c for the ctrl one, put in another file because
// of issues with TeX with the special characters it contain
// can't LPize it.
<<global kbtabctrl decl>>

enum
{
    /* controller command byte */
    Cscs1=      (1<<6),     /* scan code set 1 */
    Cauxdis=    (1<<5),     /* mouse disable */
    Ckbddis=    (1<<4),     /* kbd disable */
    Csf=        (1<<2),     /* system flag */
    Cauxint=    (1<<1),     /* mouse interrupt enable */
    Ckbdint=    (1<<0),     /* kbd interrupt enable */
};

<<global i8042lock>>
<<global nokbd>>

extern int mouseshifted;
extern void (*kbdmouse)(int);

<<global ccc>>
<<hook auxputc>>

<<function outready>>

<<function inready>>

<<function i8042reset>>

<<function i8042auxcmd>>

<<struct Kbscan>>

<<global kbscans>>

<<kbd.c debugging macro>>

<<function setleds>>

<<function kbdputsc>>

<<interrupt callback i8042intr>>

<<function i8042auxenable>>

<<function outbyte>>

<<function kbdinit>>

<<function kbdenable>>

<<function kbdputmap>>

<<function kbdgetmap>>
@ 

%/*
% *  ask 8042 to enable the use of address bit 20
% */
%//void
%//i8042a20(void)
%//{
%//  outready();
%//  outb(Cmd, 0xD1);
%//  outready();
%//  outb(Data, 0xDF);
%//  outready();
%//}
%
%
%//int
%//i8042auxcmds(uchar *cmd, int ncmd)
%//{
%//  int i;
%//
%//  ilock(&i8042lock);
%//  for(i=0; i<ncmd; i++){
%//      if(outready() < 0)
%//          break;
%//      outb(Cmd, 0xD4);
%//      if(outready() < 0)
%//          break;
%//      outb(Data, cmd[i]);
%//  }
%//  iunlock(&i8042lock);
%//  return i;
%//}

\subsection*{[[devices/portfns_devices.h]]}

\ifallcode
<<portfns_devices.h>>=

// sys/devroot.c
void    addbootfile(char*, uchar*, ulong);
// sys/devmnt.c
Chan*   mntauth(Chan*, char*);
long    mntversion(Chan*, char*, int, int);
// sys/devsrv.c
char*   srvname(Chan*);
// sys/devproc.c
int   procfdprint(Chan*, int, int, char*, int);
// sys/devrtc.c
//long    rtctime(void);
// sys/devenv.c
void    envcpy(Egrp*, Egrp*);
void    ksetenv(char*, char*, int);
char*   getconfenv(void);


// screen/devdraw.c
void    drawactive(int);
void    drawcmap(void);
// mouse/devmouse.c
void    mouseresize(void);

// in screen/386/screen.c (but used in port)
void    getcolor(ulong, ulong*, ulong*, ulong*);
int   setcolor(ulong, ulong, ulong, ulong);
// in keyboard/386/kbd.c (but used in port)
int   kbdgetmap(uint, int*, int*, Rune*);
void    kbdputmap(ushort, ushort, Rune);

@
\fi

\subsection*{[[devices/screen/386/cga.c]]}

<<cga.c>>=
<<kernel basic includes>>

<<cga.c enum color>>

<<cga.c enum misc>>

<<constant CGASCREENBASE>>

<<global cgapos>>
<<global cgascreenlock>>

<<function cgaregr>>

<<function cgaregw>>

<<function movecursor>>

<<function cgascreenputc>>

<<function cgascreenputs>>

<<function cgapost>>

<<function screeninit>>
@


\subsection*{[[devices/sys/386/devarch.c]]}

<<global archdevtab>>=
Dev archdevtab = {
    .dc       =    'P',
    .name     =    "arch",
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    archattach,
    .walk     =    archwalk,
    .stat     =    archstat,
    .open     =    archopen,
    .create   =    devcreate,
    .close    =    archclose,
    .read     =    archread,
    .bread    =    devbread,
    .write    =    archwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@



<<devarch.c>>=
<<kernel basic includes>>

#include "io.h"

#include <ureg.h>

enum {
    Qdir = 0,
    Qioalloc = 1,
    Qiob,
    Qiow,
    Qiol,
    Qbase,

    Qmax = 16,
};

typedef long Rdwrfn(Chan*, void*, long, vlong);

extern int doi8253set;
extern int cmpswap386(long *addr, long old, long new);
extern PCArch* knownarch[];


static Rdwrfn *readfn[Qmax];
static Rdwrfn *writefn[Qmax];

static Dirtab archdir[Qmax] = {
    ".",        { Qdir, 0, QTDIR }, 0,  0555,
    "ioalloc",  { Qioalloc, 0 },    0,  0444,
    "iob",      { Qiob, 0 },        0,  0660,
    "iow",      { Qiow, 0 },        0,  0660,
    "iol",      { Qiol, 0 },        0,  0660,
};
Lock archwlock; /* the lock is only for changing archdir */
int narchdir = Qbase;


/*
 * Add a file to the #P listing.  Once added, you can't delete it.
 * You can't add a file with the same name as one already there,
 * and you get a pointer to the Dirtab entry so you can do things
 * like change the Qid version.  Changing the Qid path is disallowed.
 */
Dirtab*
addarchfile(char *name, int perm, Rdwrfn *rdfn, Rdwrfn *wrfn)
{
    int i;
    Dirtab d;
    Dirtab *dp;

    memset(&d, 0, sizeof d);
    strcpy(d.name, name);
    d.perm = perm;

    lock(&archwlock);
    if(narchdir >= Qmax){
        unlock(&archwlock);
        return nil;
    }

    for(i=0; i<narchdir; i++)
        if(strcmp(archdir[i].name, name) == 0){
            unlock(&archwlock);
            return nil;
        }

    d.qid.path = narchdir;
    archdir[narchdir] = d;
    readfn[narchdir] = rdfn;
    writefn[narchdir] = wrfn;
    dp = &archdir[narchdir++];
    unlock(&archwlock);

    return dp;
}

void devarch_hook_ioalloc() {
  archdir[0].qid.vers++;
}


int
iounused(int start, int end)
{
    IOMap *m;

    for(m = iomap.m; m; m = m->next){
        if(start >= m->start && start < m->end
        || start <= m->start && end > m->start)
            return 0;
    }
    return 1;
}

static void
checkport(int start, int end)
{
    /* standard vga regs are OK */
    if(start >= 0x2b0 && end <= 0x2df+1)
        return;
    if(start >= 0x3c0 && end <= 0x3da+1)
        return;

    if(iounused(start, end))
        return;
    error(Eperm);
}




static Chan*
archattach(char* spec)
{
    return devattach('P', spec);
}

Walkqid*
archwalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, archdir, narchdir, devgen);
}

static int
archstat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, archdir, narchdir, devgen);
}

static Chan*
archopen(Chan* c, int omode)
{
    return devopen(c, omode, archdir, narchdir, devgen);
}

static void
archclose(Chan*)
{
}

enum
{
    Linelen= 31,
};

static long
archread(Chan *c, void *a, long n, vlong offset)
{
    char *buf, *p;
    int port;
    ushort *sp;
    ulong *lp;
    IOMap *m;
    Rdwrfn *fn;

    switch((ulong)c->qid.path){

    case Qdir:
        return devdirread(c, a, n, archdir, narchdir, devgen);

    case Qiob:
        port = offset;
        checkport(offset, offset+n);
        for(p = a; port < offset+n; port++)
            *p++ = inb(port);
        return n;

    case Qiow:
        if(n & 1)
            error(Ebadarg);
        checkport(offset, offset+n);
        sp = a;
        for(port = offset; port < offset+n; port += 2)
            *sp++ = ins(port);
        return n;

    case Qiol:
        if(n & 3)
            error(Ebadarg);
        checkport(offset, offset+n);
        lp = a;
        for(port = offset; port < offset+n; port += 4)
            *lp++ = inl(port);
        return n;

    case Qioalloc:
        break;

    default:
        if(c->qid.path < narchdir && (fn = readfn[c->qid.path]))
            return fn(c, a, n, offset);
        error(Eperm);
        break;
    }

    if((buf = malloc(n)) == nil)
        error(Enomem);
    p = buf;
    n = n/Linelen;
    offset = offset/Linelen;

    lock(&iomap);
    for(m = iomap.m; n > 0 && m != nil; m = m->next){
        if(offset-- > 0)
            continue;
        seprint(p, &buf[n], "%8lux %8lux %-12.12s\n", m->start,
            m->end-1, m->tag);
        p += Linelen;
        n--;
    }
    unlock(&iomap);

    n = p - buf;
    memmove(a, buf, n);
    free(buf);

    return n;
}

static long
archwrite(Chan *c, void *a, long n, vlong offset)
{
    char *p;
    int port;
    ushort *sp;
    ulong *lp;
    Rdwrfn *fn;

    switch((ulong)c->qid.path){

    case Qiob:
        p = a;
        checkport(offset, offset+n);
        for(port = offset; port < offset+n; port++)
            outb(port, *p++);
        return n;

    case Qiow:
        if(n & 1)
            error(Ebadarg);
        checkport(offset, offset+n);
        sp = a;
        for(port = offset; port < offset+n; port += 2)
            outs(port, *sp++);
        return n;

    case Qiol:
        if(n & 3)
            error(Ebadarg);
        checkport(offset, offset+n);
        lp = a;
        for(port = offset; port < offset+n; port += 4)
            outl(port, *lp++);
        return n;

    default:
        if(c->qid.path < narchdir && (fn = writefn[c->qid.path]))
            return fn(c, a, n, offset);
        error(Eperm);
        break;
    }
    return 0;
}

<<global archdevtab>>

void
nop(void)
{
}



static long
cputyperead(Chan*, void *a, long n, vlong offset)
{
    char str[32];
    ulong mhz;

    mhz = (cpu->cpuhz+999999)/1000000;

    snprint(str, sizeof(str), "%s %lud\n", cputype->name, mhz);
    return readstr(offset, a, n, str);
}

static long
archctlread(Chan*, void *a, long nn, vlong offset)
{
    int n;
    char *buf, *p, *ep;

    p = buf = malloc(READSTR);
    if(p == nil)
        error(Enomem);
    ep = p + READSTR;
    p = seprint(p, ep, "cpu %s %lud%s\n",
        cputype->name, (ulong)(cpu->cpuhz+999999)/1000000,
        cpu->havepge ? " pge" : "");
    p = seprint(p, ep, "pge %s\n", getcr4()&0x80 ? "on" : "off");
    p = seprint(p, ep, "coherence ");
    if(coherence == mb386)
        p = seprint(p, ep, "mb386\n");
    else if(coherence == mb586)
        p = seprint(p, ep, "mb586\n");
    else if(coherence == mfence)
        p = seprint(p, ep, "mfence\n");
    else if(coherence == nop)
        p = seprint(p, ep, "nop\n");
    else
        p = seprint(p, ep, "0x%p\n", coherence);
    p = seprint(p, ep, "cmpswap ");
    if(cmpswap == cmpswap386)
        p = seprint(p, ep, "cmpswap386\n");
    else if(cmpswap == cmpswap486)
        p = seprint(p, ep, "cmpswap486\n");
    else
        p = seprint(p, ep, "0x%p\n", cmpswap);
    p = seprint(p, ep, "i8253set %s\n", doi8253set ? "on" : "off");
    n = p - buf;
    //n += mtrrprint(p, ep - p);
    buf[n] = '\0';

    n = readstr(offset, a, nn, buf);
    free(buf);
    return n;
}

enum
{
    CMpge,
    CMcoherence,
    CMi8253set,
    CMcache,
};

static Cmdtab archctlmsg[] =
{
    CMpge,      "pge",      2,
    CMcoherence,    "coherence",    2,
    CMi8253set, "i8253set", 2,
    CMcache,        "cache",        4,
};

static long
archctlwrite(Chan*, void *a, long n, vlong)
{
    uvlong base, size;
    Cmdbuf *cb;
    Cmdtab *ct;
    char *ep;

    cb = parsecmd(a, n);
    if(waserror()){
        free(cb);
        nexterror();
    }
    ct = lookupcmd(cb, archctlmsg, nelem(archctlmsg));
    switch(ct->index){
    case CMpge:
        if(!cpu->havepge)
            error("processor does not support pge");
        if(strcmp(cb->f[1], "on") == 0)
            putcr4(getcr4() | 0x80);
        else if(strcmp(cb->f[1], "off") == 0)
            putcr4(getcr4() & ~0x80);
        else
            cmderror(cb, "invalid pge ctl");
        break;
    case CMcoherence:
        if(strcmp(cb->f[1], "mb386") == 0)
            coherence = mb386;
        else if(strcmp(cb->f[1], "mb586") == 0){
            if(X86FAMILY(cpu->cpuidax) < 5)
                error("invalid coherence ctl on this cpu family");
            coherence = mb586;
        }else if(strcmp(cb->f[1], "mfence") == 0){
            if((cpu->cpuiddx & Sse2) == 0)
                error("invalid coherence ctl on this cpu family");
            coherence = mfence;
        }else if(strcmp(cb->f[1], "nop") == 0){
            /* only safe on vmware */
            if(conf.ncpu > 1)
                error("cannot disable coherence on a multiprocessor");
            coherence = nop;
        }else
            cmderror(cb, "invalid coherence ctl");
        break;
    case CMi8253set:
        if(strcmp(cb->f[1], "on") == 0)
            doi8253set = 1;
        else if(strcmp(cb->f[1], "off") == 0){
            doi8253set = 0;
            (*arch->timerset)(0);
        }else
            cmderror(cb, "invalid i2853set ctl");
        break;
    case CMcache:
        base = strtoull(cb->f[1], &ep, 0);
        if(*ep)
            error("cache: parse error: base not a number?");
        size = strtoull(cb->f[2], &ep, 0);
        if(*ep)
            error("cache: parse error: size not a number?");
        //mtrr(base, size, cb->f[3]);
                error("mtrr: disabled");
        break;
    }
    free(cb);
    poperror();
    return n;
}

<<function archinit>>
@


\subsection*{[[devices/sys/386/devrtc.c]]}

\ifallcode
<<devrtc.c forward decl>>=
typedef struct Rtc  Rtc;

static ulong rtc2sec(Rtc*);
static void sec2rtc(ulong, Rtc*);
@
\fi



<<devrtc.c>>=
<<kernel basic includes>>

// see also the enum in dat_memory.h used by nvram.c and this file

enum {
    Seconds=    0x00,
    Minutes=    0x02,
    Hours=      0x04, 
    Mday=       0x07,
    Month=      0x08,
    Year=       0x09,
    Status=     0x0A,

    Nvoff=      128,    /* where usable nvram lives */
    Nvsize=     256,

    Nbcd=       6,
};

<<devrtc.c forward decl>>

<<struct Rtc>>


enum{
    Qdir = 0,
    Qrtc,
    Qnvram,
};

Dirtab rtcdir[]={
    ".",    {Qdir, 0, QTDIR},   0,  0555,
    "nvram",    {Qnvram, 0},    Nvsize, 0664,
    "rtc",      {Qrtc, 0},  0,  0664,
};

void
rtcinit(void)
{
    if(ioalloc(Paddr, 2, 0, "rtc/nvr") < 0)
        panic("rtcinit: ioalloc failed");
}

static Chan*
rtcattach(char* spec)
{
    return devattach('r', spec);
}

static Walkqid*  
rtcwalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, rtcdir, nelem(rtcdir), devgen);
}

static int   
rtcstat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, rtcdir, nelem(rtcdir), devgen);
}

static Chan*
rtcopen(Chan* c, int omode)
{
    omode = openmode(omode);
    switch((ulong)c->qid.path){
    case Qrtc:
        if(strcmp(up->user, eve)!=0 && omode!=OREAD)
            error(Eperm);
        break;
    case Qnvram:
        if(strcmp(up->user, eve)!=0)
            error(Eperm);
    }
    return devopen(c, omode, rtcdir, nelem(rtcdir), devgen);
}

static void  
rtcclose(Chan*)
{
}

#define GETBCD(o) ((bcdclock[o]&0xf) + 10*(bcdclock[o]>>4))

static long  
_rtctime(void)
{
    uchar bcdclock[Nbcd];
    Rtc rtc;
    int i;

    /* don't do the read until the clock is no longer busy */
    for(i = 0; i < 10000; i++){
        outb(Paddr, Status);
        if(inb(PdataPort) & 0x80)
            continue;

        /* read clock values */
        outb(Paddr, Seconds);   bcdclock[0] = inb(PdataPort);
        outb(Paddr, Minutes);   bcdclock[1] = inb(PdataPort);
        outb(Paddr, Hours); bcdclock[2] = inb(PdataPort);
        outb(Paddr, Mday);  bcdclock[3] = inb(PdataPort);
        outb(Paddr, Month); bcdclock[4] = inb(PdataPort);
        outb(Paddr, Year);  bcdclock[5] = inb(PdataPort);

        outb(Paddr, Status);
        if((inb(PdataPort) & 0x80) == 0)
            break;
    }

    /*
     *  convert from BCD
     */
    rtc.sec = GETBCD(0);
    rtc.min = GETBCD(1);
    rtc.hour = GETBCD(2);
    rtc.mday = GETBCD(3);
    rtc.mon = GETBCD(4);
    rtc.year = GETBCD(5);

    /*
     *  the world starts jan 1 1970
     */
    if(rtc.year < 70)
        rtc.year += 2000;
    else
        rtc.year += 1900;
    return rtc2sec(&rtc);
}

// now in dat_memory.h and not static ...
//static Lock nvrtlock;

long
rtctime(void)
{
    int i;
    long t, ot;

    ilock(&nvrtlock);

    /* loop till we get two reads in a row the same */
    t = _rtctime();
    for(i = 0; i < 100; i++){
        ot = t;
        t = _rtctime();
        if(ot == t)
            break;
    }
    if(i == 100) print("we are boofheads\n");

    iunlock(&nvrtlock);

    return t;
}

static long  
rtcread(Chan* c, void* buf, long n, vlong off)
{
    ulong t;
    char *a, *start;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, buf, n, rtcdir, nelem(rtcdir), devgen);

    switch((ulong)c->qid.path){
    case Qrtc:
        t = rtctime();
        n = readnum(offset, buf, n, t, 12);
        return n;
    case Qnvram:
        if(n == 0)
            return 0;
        if(n > Nvsize)
            n = Nvsize;
        a = start = smalloc(n);

        ilock(&nvrtlock);
        for(t = offset; t < offset + n; t++){
            if(t >= Nvsize)
                break;
            outb(Paddr, Nvoff+t);
            *a++ = inb(PdataPort);
        }
        iunlock(&nvrtlock);

        if(waserror()){
            free(start);
            nexterror();
        }
        memmove(buf, start, t - offset);
        poperror();

        free(start);
        return t - offset;
    }
    error(Ebadarg);
    return 0;
}

#define PUTBCD(n,o) bcdclock[o] = (n % 10) | (((n / 10) % 10)<<4)

static long  
rtcwrite(Chan* c, void* buf, long n, vlong off)
{
    int t;
    char *a, *start;
    Rtc rtc;
    ulong secs;
    uchar bcdclock[Nbcd];
    char *cp, *ep;
    ulong offset = off;

    if(offset!=0)
        error(Ebadarg);


    switch((ulong)c->qid.path){
    case Qrtc:
        /*
         *  read the time
         */
        cp = ep = buf;
        ep += n;
        while(cp < ep){
            if(*cp>='0' && *cp<='9')
                break;
            cp++;
        }
        secs = strtoul(cp, 0, 0);
    
        /*
         *  convert to bcd
         */
        sec2rtc(secs, &rtc);
        PUTBCD(rtc.sec, 0);
        PUTBCD(rtc.min, 1);
        PUTBCD(rtc.hour, 2);
        PUTBCD(rtc.mday, 3);
        PUTBCD(rtc.mon, 4);
        PUTBCD(rtc.year, 5);

        /*
         *  write the clock
         */
        ilock(&nvrtlock);
        outb(Paddr, Seconds);   outb(PdataPort, bcdclock[0]);
        outb(Paddr, Minutes);   outb(PdataPort, bcdclock[1]);
        outb(Paddr, Hours); outb(PdataPort, bcdclock[2]);
        outb(Paddr, Mday);  outb(PdataPort, bcdclock[3]);
        outb(Paddr, Month); outb(PdataPort, bcdclock[4]);
        outb(Paddr, Year);  outb(PdataPort, bcdclock[5]);
        iunlock(&nvrtlock);
        return n;
    case Qnvram:
        if(n == 0)
            return 0;
        if(n > Nvsize)
            n = Nvsize;
    
        start = a = smalloc(n);
        if(waserror()){
            free(start);
            nexterror();
        }
        memmove(a, buf, n);
        poperror();

        ilock(&nvrtlock);
        for(t = offset; t < offset + n; t++){
            if(t >= Nvsize)
                break;
            outb(Paddr, Nvoff+t);
            outb(PdataPort, *a++);
        }
        iunlock(&nvrtlock);

        free(start);
        return t - offset;
    }
    error(Ebadarg);
    return 0;
}

<<global rtcdevtab>>

<<constants SEC2XXX>>

<<globals dmsize ldmsize>>

<<function yrsize>>

<<function rtc2sec>>

<<function sec2rtc>>

@

\subsection*{[[devices/sys/devsys.c]]}

<<method syswalk>>=
static Walkqid*
syswalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, sysdir, nelem(sysdir), devgen);
}
@


<<method sysstat>>=
static int
sysstat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, sysdir, nelem(sysdir), devgen);
}
@


<<method sysopen>>=
static Chan*
sysopen(Chan *c, int omode)
{
    c->aux = nil;
    c = devopen(c, omode, sysdir, nelem(sysdir), devgen);
    switch((ulong)c->qid.path){
    }
    return c;
}
@


<<method sysclose>>=
static void
sysclose(Chan *c)
{
    switch((ulong)c->qid.path){
    }
}
@



<<devsys.c>>=
<<kernel basic includes>>

#include    <authsrv.h>

<<devsys.c enum Qxxx>>

<<global sysdir>>

<<devsys.c decls and globals>>
<<global sysname>>

<<method sysinit>>

<<method sysattach>>

<<method syswalk>>

<<method sysstat>>

<<method sysopen>>

<<method sysclose>>

<<method sysread>>

<<method syswrite>>

<<global sysdevtab>>

@


\subsection*{[[devices/sys/devroot.c]]}

\ifallcode
<<devroot.c forward decl>>=
typedef struct Dirlist Dirlist;
@
\fi

<<method rootclose>>=
/*
 * sysremove() knows this is a nop
 */
static void
rootclose(Chan*)
{
}
@



<<devroot.c>>=
<<kernel basic includes>>

//*****************************************************************************
// Constants and types
//*****************************************************************************

<<devroot enum Qxxx>>

<<devroot.c forward decl>>
<<struct Dirlist>>

//*****************************************************************************
// Root
//*****************************************************************************

// note: directories have by convention 0 length

<<globals rootdir, rootdata, rootlist>>

//*****************************************************************************
// Boot
//*****************************************************************************

<<globals bootdir, bootdata, bootlist>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<function addlist>>

<<function addbootfile>>

<<function addrootdir>>

<<method rootreset>>

static Chan*
rootattach(char *spec)
{
    return devattach('/', spec);
}

<<function rootgen>>

static Walkqid*
rootwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c,  nc, name, nname, nil, 0, rootgen);
}

static int
rootstat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, nil, 0, rootgen);
}

static Chan*
rootopen(Chan *c, int omode)
{
    return devopen(c, omode, nil, 0, devgen);
}

<<method rootclose>>

<<method rootread>>

static long
rootwrite(Chan*, void*, long, vlong)
{
    error(Egreg);
    return 0;
}

<<global rootdevtab>>

@


\section{[[files/]]}

\subsection*{[[files/allocb.c]]}


<<allocb.c>>=
<<kernel basic includes>>

enum
{
    Hdrspc      = 64,       /* leave room for high-level headers */
    Bdead       = 0x51494F42,   /* "QIOB" */
};

<<struct Ialloc>>
<<global ialloc>>

<<function _allocb>>

<<function allocb>>

<<function iallocb>>

<<function freeb>>

<<function checkb>>

<<function iallocsummary>>
@


\subsection*{[[files/chan.c]]}

\ifallcode
<<chan.c forward decl>>=
char*       skipslash(char*);
void closeproc(void*);
typedef struct Elemlist Elemlist;
@
\fi

%PAD: still toggled by sysr1? not true
\ifallcode
<<chan.c debugging macro>>=
int chandebug=0;        /* toggle it in sysnop if you want */
#define DBG if(chandebug)iprint
static bool debugstart = false;
@ 
\fi


<<chan.c>>=
<<kernel basic includes>>

<<chan.c forward decl>>

<<chan.c debugging macro>>

enum
{
<<constant PATHSLOP>>
<<constant PATHMSLOP>>
};

<<struct Chanalloc>>
<<global chanalloc>>

<<struct Elemlist>>

<<macro SEP>>

<<function chanpath>>

<<function isdotdot>>

<<function emptystr>>

<<function chandevreset>>

<<function chandevinit>>

<<function chandevshutdown>>

<<constructor newchan>>

<<global npath>>

<<constructor newpath>>

<<function copypath>>

<<destructor pathclose>>

<<function fixdotdotname>>

<<function uniquepath>>

<<function addelem>>

<<destructor chanfree>>

<<function cclose>>

<<struct Clunkq>>
<<global clunkq>>

<<function ccloseq>>

<<function clunkwork>>

<<function closeproc>>

<<function cunique>>

<<function eqqid>>

<<function eqchan>>

<<function eqchantdqid>>

<<constructor newmhead>>

<<function cmount>>

<<function cunmount>>

<<function cclone>>

<<function findmount>>

<<function domount>>

<<function undomount>>

<<function ewalk>>

<<global Edoesnotexist>>

<<function walk>>

<<function createdir>>

<<function growparse>>

<<function parsename>>

<<function memrchr>>

<<function namelenerror>>

<<function nameerror>>

<<function namec>>

<<function skipslash>>

<<global isfrog>>

<<function validname0>>

<<function validname>>

<<function validnamedup>>

<<function isdir>>

<<destructor putmhead>>

@


\subsection*{[[files/dev.c]]}


<<dev.c>>=
<<kernel basic includes>>

// was in $CONF.c
<<global devtab>>

<<function mkqid>>

<<function devno>>

<<function devdir>>

<<function devgen>>

void
devreset(void)
{
}

void
devinit(void)
{
}

void
devshutdown(void)
{
}

<<function devattach>>

<<function devclone>>

<<function devwalk>>

<<function devstat>>

<<function devdirread>>

<<function devpermcheck>>

<<function devopen>>

void
devcreate(Chan*, char*, int, ulong)
{
    error(Eperm);
}

<<function devbread>>

<<function devbrwrite>>

void
devremove(Chan*)
{
    error(Eperm);
}

int
devwstat(Chan*, uchar*, int)
{
    error(Eperm);
    return 0;
}

void
devpower(int)
{
    error(Eperm);
}

int
devconfig(int, char *, DevConf *)
{
    error(Eperm);
    return 0;
}
@
%$

\subsection*{[[files/env.c]]}

<<env.c>>=
<<kernel basic includes>>

// this used to be in devenv.c, but to avoid backward deps I've splitted
// this file in 2
<<function closeegrp>>
@


\subsection*{[[files/file.c]]}

<<file.c>>=
<<kernel basic includes>>

<<function fdtochan>>

<<function openmode>>

<<function fdclose>>

<<function validstat>>

@


\subsection*{[[files/mnt.c]]}

<<mnt.c Exxx errors>>=
char   Esbadstat[] = "invalid directory entry received from server";
char   Enoversion[] = "version not established for mount channel";
@


<<function mntversion>>=
/*
 * Version is not multiplexed: message sent only once per connection.
 */
long
mntversion(Chan *c, char *version, int msize, int returnlen)
{
    Fcall f;
    uchar *msg;
    Mnt *m;
    char *v;
    long k, l;
    uvlong oo;
    char buf[128];

    qlock(&c->umqlock); /* make sure no one else does this until we've established ourselves */
    if(waserror()){
        qunlock(&c->umqlock);
        nexterror();
    }

    /* defaults */
    if(msize == 0)
        msize = MAXRPC;
    if(msize > c->iounit && c->iounit != 0)
        msize = c->iounit;
    v = version;
    if(v == nil || v[0] == '\0')
        v = VERSION9P;

    /* validity */
    if(msize < 0)
        error("bad iounit in version call");
    if(strncmp(v, VERSION9P, strlen(VERSION9P)) != 0)
        error("bad 9P version specification");

    m = c->mux;

    if(m != nil){
        qunlock(&c->umqlock);
        poperror();

        strecpy(buf, buf+sizeof buf, m->version);
        k = strlen(buf);
        if(strncmp(buf, v, k) != 0){
            snprint(buf, sizeof buf, "incompatible 9P versions %s %s", m->version, v);
            error(buf);
        }
        if(returnlen > 0){
            if(returnlen < k)
                error(Eshort);
            memmove(version, buf, k);
        }
        return k;
    }

    f.type = Tversion;
    f.tag = NOTAG;
    f.msize = msize;
    f.version = v;
    msg = malloc(8192+IOHDRSZ);
    if(msg == nil)
        exhausted("version memory");
    if(waserror()){
        free(msg);
        nexterror();
    }
    k = convS2M(&f, msg, 8192+IOHDRSZ);
    if(k == 0)
        error("bad fversion conversion on send");

    lock(c);
    oo = c->offset;
    c->offset += k;
    unlock(c);

    l = devtab[c->type]->write(c, msg, k, oo);

    if(l < k){
        lock(c);
        c->offset -= k - l;
        unlock(c);
        error("short write in fversion");
    }

    /* message sent; receive and decode reply */
    k = devtab[c->type]->read(c, msg, 8192+IOHDRSZ, c->offset);
    if(k <= 0)
        error("EOF receiving fversion reply");

    lock(c);
    c->offset += k;
    unlock(c);

    l = convM2S(msg, k, &f);
    if(l != k)
        error("bad fversion conversion on reply");
    if(f.type != Rversion){
        if(f.type == Rerror)
            error(f.ename);
        error("unexpected reply type in fversion");
    }
    if(f.msize > msize)
        error("server tries to increase msize in fversion");
    if(f.msize<256 || f.msize>1024*1024)
        error("nonsense value of msize in fversion");
    k = strlen(f.version);
    if(strncmp(f.version, v, k) != 0)
        error("bad 9P version returned from server");

    /* now build Mnt associated with this connection */
    lock(&mntalloc);
    m = mntalloc.mntfree;
    if(m != 0)
        mntalloc.mntfree = m->list;
    else {
        m = malloc(sizeof(Mnt));
        if(m == 0) {
            unlock(&mntalloc);
            exhausted("mount devices");
        }
    }
    m->list = mntalloc.list;
    mntalloc.list = m;
    m->version = nil;
    kstrdup(&m->version, f.version);
    m->id = mntalloc.id++;
    m->q = qopen(10*MAXRPC, 0, nil, nil);
    m->msize = f.msize;
    unlock(&mntalloc);

    if(returnlen > 0){
        if(returnlen < k)
            error(Eshort);
        memmove(version, f.version, k);
    }

    poperror(); /* msg */
    free(msg);

    lock(m);
    m->queue = 0;
    m->rip = 0;

    c->flag |= CMSG;
    c->mux = m;
    m->c = c;
    unlock(m);

    poperror(); /* c */
    qunlock(&c->umqlock);

    return k;
}
@


<<mnt.c>>=
<<kernel basic includes>>

// this used to be in devmnt.c, but to avoid backward deps I've splitted
// this file in 2 (which forced to put more stuff in portdat_files.h though).

<<global mntalloc>>

#define MAXRPC (IOHDRSZ+8192)

<<mnt.c Exxx errors>>

<<function freetag>>

<<function mntfree>>

<<function mntpntfree>>

<<function muxclose>>

<<function mntversion>>

@


\subsection*{[[files/portdat_files.h]]}

<<struct Extent>>=
struct Extent
{
  int bid;
  ulong start;
  int len;
  Page  *cache;
  Extent  *next;
};
@

<<struct Mntcache>>=
struct Mntcache
{
  Qid qid;
  int dev;
  int type;
  QLock;
  Extent   *list;
  Mntcache *hash;
  Mntcache *prev;
  Mntcache *next;
};
@




<<portdat_files.h>>=

<<enum blockflag>>

<<struct Block>>

<<function BLEN>>
<<function BALLOC>>


<<enum queuestate>>

// defined in qio.c
extern  uint  qiomaxatomic;

/*
 *  IO queues
 */
// was in qio.c
<<struct Queue>>


// was in cache.c
<<struct Extent>>

// was in cache.c
<<struct Mntcache>>


<<struct Mount>>

<<struct Mhead>>



#include <fcall.h>

// was in devmnt.c
<<struct Mntrpc>>

<<struct Mnt>>



<<struct Path>>

<<enum accessnamec>>

<<enum channelflag>>

<<struct Chan>>


<<struct Evalue>>

<<struct Egrp>>


// internals

<<struct Walkqid>>

<<struct Dev>>


// array<Dev>, it looks like an allocated array<ref<dev>> but
// it is really a static array put here to avoid backward deps on conf_devtab,
// and it is not really a <ref<dev>> because it's pointers to static
// structures (e.g. mousedevtab, vgadevtab, etc).
extern Dev** devtab;

<<struct Dirtab>>



//*****************************************************************************
// Internal to memory/
//*****************************************************************************

<<constants tags>>

// actually internal to devmnt.c and mnt.c
<<struct Mntalloc>>
extern struct Mntalloc mntalloc;

// TODO: mv in errstr.c?
extern char Esbadstat[];
extern char Enoversion[];
@


\subsection*{[[files/portfns_files.h]]}

\ifallcode
<<portfns_files.h>>=

// allocb.c
Block*    allocb(int);
void    freeb(Block*);
Block*    iallocb(int);
void    iallocsummary(void);
void    checkb(Block*, char*);

// cache.c
void    cinit(void);
void    copen(Chan*);
int   cread(Chan*, uchar*, int, vlong);
void    cwrite(Chan*, uchar*, int, vlong);
void    cupdate(Chan*, uchar*, int, vlong);

// qio.c
void    freeblist(Block*);
int   blocklen(Block*);
Queue*    qopen(int, int, void (*)(void*), void*);
void    qhangup(Queue*, char*);
Block*    qget(Queue*);
int   qdiscard(Queue*, int);
void    qreopen(Queue*);
Block*    qremove(Queue*);
void    qputback(Queue*, Block*);
Block*    packblock(Block*);
Queue*    qbypass(void (*)(void*, Block*), void*);
int   pullblock(Block**, int);
Block*    bl2mem(uchar*, Block*, int);
void    qnoblock(Queue*, bool);
int   qisclosed(Queue*);
int   qfull(Queue*);
int   qwindow(Queue*);
void    qsetlimit(Queue*, int);
int   qpass(Queue*, Block*);
void    qclose(Queue*);
int   qiwrite(Queue*, void*, int);
int   qproduce(Queue*, void*, int);
Block*    padblock(Block*, int);
Block*    pullupblock(Block*, int);
int   qpassnolim(Queue*, Block*);
Block*    copyblock(Block*, int);
Block*    qcopy(Queue*, int, ulong);
void    qflush(Queue*);
long    qbwrite(Queue*, Block*);
int   qconsume(Queue*, void*, int);
//Block*    mem2bl(uchar*, int);
Block*    trimblock(Block*, int, int);
void    qaddlist(Queue*, Block*);
Block*    concatblock(Block*);
void    ixsummary(void);
Block*    pullupqueue(Queue*, int);
void    qfree(Queue*);
int   qwrite(Queue*, void*, int);
Block*    adjustblock(Block*, int);
Block*    qbread(Queue*, int);
long    qread(Queue*, void*, int);
int   qcanread(Queue*);
int   qlen(Queue*);

// chan.c
Chan*   cclone(Chan*);
void    putmhead(Mhead*);
int   eqchantdqid(Chan*, int, int, Qid, int);
Mhead*    newmhead(Chan*);
void    isdir(Chan*);
char*   chanpath(Chan*);
int   emptystr(char*);
void    chandevinit(void);
void    chandevshutdown(void);
void    chandevreset(void);
int   eqqid(Qid, Qid);
int   cmount(Chan**, Chan*, int, char*);
void    cunmount(Chan*, Chan*);
int   findmount(Chan**, Mhead**, int, int, Qid);
void    pathclose(Path*);
Path*   newpath(char*);
Chan*   newchan(void);
void    chanfree(Chan*);
//cchan_close => cclose
char*   validnamedup(char*, int);
void    validname(char*, int);
void    nameerror(char*, char*);
int   walk(Chan**, char**, int, int, int*);
void    ccloseq(Chan*);
Chan*   namec(char*, int, int, ulong);
//long    unionread(Chan*, void*, long);

// file.c
Chan*   fdtochan(int, int, int, int);
int   openmode(ulong);
void    fdclose(int, int);
void    validstat(uchar*, int);

// dev.c
void    mkqid(Qid*, vlong, ulong, int);
int   devno(int, int);
void    devdir(Chan*, Qid, char*, vlong, char*, long, Dir*);
void    devinit(void);
void    devreset(void);
void    devshutdown(void);
Chan*   devclone(Chan*);
long    devdirread(Chan*, char*, long, Dirtab*, int, Devgen*);
void    devpermcheck(char*, ulong, int);
void    devcreate(Chan*, char*, int, ulong);
Block*    devbread(Chan*, long, ulong);
long    devbwrite(Chan*, Block*, ulong);
void    devremove(Chan*);
int   devwstat(Chan*, uchar*, int);
#define DEVDOTDOT -1
Devgen    devgen;//TODO?
void    devpower(int);
int   devconfig(int, char *, DevConf *);//TODO? why fp no-deps?
int   devstat(Chan*, uchar*, int, Dirtab*, int, Devgen*);
Chan*   devopen(Chan*, int, Dirtab*, int, Devgen*);
Chan*   devattach(int, char*);
Walkqid*  devwalk(Chan*, Chan*, char**, int, Dirtab*, int, Devgen*);

// env.c
void    closeegrp(Egrp*);

// mnt.c
void    muxclose(Mnt*);
void    mntfree(Mntrpc*);
void    mntpntfree(Mnt*);

// sysfile.c
int   newfd(Chan*);
// many sysxxx functions (used in syscalls/ without requiring extern decl)
@
\fi

\subsection*{[[files/qio.c]]}

\ifallcode
<<qio.c globals cnt>>=
static ulong padblockcnt;
static ulong concatblockcnt;
static ulong pullupblockcnt;
static ulong copyblockcnt;
static ulong consumecnt;
static ulong producecnt;
static ulong qcopycnt;
static ulong noblockcnt;
@ 

<<qio.c global debugging>>=
static int debugging;

#define QDEBUG  if(0)
@ 
\fi


<<global qiomaxatomic>>=
enum
{
    Maxatomic   = 64*1024,
};

uint    qiomaxatomic = Maxatomic;
@

<<qio.c>>=
<<kernel basic includes>>

<<qio.c globals cnt>>

<<qio.c global debugging>>

<<global qiomaxatomic>>

<<function ixsummary>>

<<function freeblist>>

<<function padblock>>

<<function blocklen>>

<<function blockalloclen>>

<<function concatblock>>

<<function pullupblock>>

<<function pullupqueue>>

<<function trimblock>>

<<function copyblock>>

<<function adjustblock>>

<<function pullblock>>

<<function qget>>

<<function qdiscard>>

<<function qconsume>>

<<function qpass>>

<<function qpassnolim>>

<<function packblock>>

<<function qproduce>>

<<function qcopy>>

<<function qopen>>

<<function qbypass>>

<<function notempty>>

<<function qwait>>

<<function qaddlist>>

<<function qremove>>

<<function bl2mem>>

<<function qputback>>

<<function qwakeup_iunlock>>

<<function qbread>>

<<function qread>>

<<function qnotfull>>

<<function qbwrite>>

<<function qwrite>>

<<function qiwrite>>

<<function qfree>>

<<function qclose>>

<<function qhangup>>

<<function qiclosed>>

<<function qreopen>>

<<function qlen>>

<<function qwindow>>

<<function qcanread>>

<<function qsetlimit>>

<<function qnoblock>>

<<function qflush>>

<<function qfull>>

@

%/*
% *  copy the contents of memory into a string of blocks.
% *  return nil on error.
% */
%//Block*
%//mem2bl(uchar *p, int len)
%//{
%//  int n;
%//  Block *b, *first, **l;
%//
%//  first = nil;
%//  l = &first;
%//  if(waserror()){
%//      freeblist(first);
%//      nexterror();
%//  }
%//  do {
%//      n = len;
%//      if(n > Maxatomic)
%//          n = Maxatomic;
%//
%//      *l = b = allocb(n);
%//      setmalloctag(b, (up->text[0]<<24)|(up->text[1]<<16)|(up->text[2]<<8)|up->text[3]);
%//      memmove(b->wp, p, n);
%//      b->wp += n;
%//      p += n;
%//      len -= n;
%//      l = &b->next;
%//  } while(len > 0);
%//  poperror();
%//
%//  return first;
%//}
%
%//int
%//qstate(Queue *q)
%//{
%//  return q->state;
%//}


\subsection*{[[files/sysfile.c]]}


<<sysfile.c>>=
<<kernel basic includes>>

/*
 * The sys*() routines needn't poperror() as they return directly to syscall().
 */

<<function unlockfgrp>>

<<function growfd>>

<<function findfreefd>>

<<function newfd>>

<<function newfd2>>


<<syscall fd2path>>

<<syscall pipe>>

<<syscall dup>>

<<syscall open>>

<<syscall close>>

<<function unionread>>

<<function unionrewind>>

<<function dirfixed>>

<<function dirname>>

<<function dirsetname>>

<<function mountrock>>

<<function mountrockread>>

<<function mountrewind>>

<<function mountfix>>

<<function read>>

<<syscall pread>>

<<function write>>

<<syscall pwrite>>

<<function sseek>>

<<syscall seek>>

<<function pathlast>>

<<syscall fstat>>

<<syscall stat>>

<<syscall chdir>>

<<function bindmount>>

<<syscall bind>>

<<syscall mount>>

<<syscall unmount>>

<<syscall create>>

<<syscall remove>>

<<function wstat>>

<<syscall wstat>>

<<syscall fwstat>>

@

\section{[[filesystems/]]}

\section{[[init/]]}

\subsection*{[[init/user/preboot/386/init9.c]]}

\subsection*{[[init/user/preboot/initcode.c]]}


\subsection*{[[init/user/boot/aux.c]]}

% only run and runv are maybe slightly interesting


\ifallcode
<<aux.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

void
warning(char *s)
{
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    fprint(2, "boot: %s: %s\n", s, buf);
}

void
fatal(char *s)
{
    char *msg;
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    msg = smprint("%s: %s", s, buf);
    fprint(2, "boot: %s\n", msg);
    exits(msg);         /* this will trigger a panic */
}

<<function runv>>

<<function run>>


void bind_safe(char* old, char* new, int flag) {
  if(bind(old, new, flag) < 0)
    fatal("bind");
  return;
}

int open_safe(char* path, int flag) {
  int fd;
  if((fd = open(path, flag)) < 0) {
    fatal("open");
  }
  return fd;
}

void print_safe(int fd, char* str) {
  if(write(fd, str, strlen(str)) < 0) {
    fatal("print");
  };
  return;
}

void close_safe(int fd) {
  if(close(fd) < 0) {
    fatal("close");
  }
}
@
\fi

\subsection*{[[init/user/boot/boot.c]]}

\subsection*{[[init/user/boot/boot.h]]}

\ifallcode
<<boot.h>>=
/* libc equivalent */
// aux.c: 
extern void fatal(char*);
extern void warning(char*);
extern void run(char *file, ...);
extern void runv(char **argv);
/* pad style */
void bind_safe(char* old, char* new, int flag);
int open_safe(char* path, int flag);
void print_safe(int fd, char* str);
void close_safe(int fd);

/* methods */
// local.c:
extern void  connectlocal(void);
//extern void configlocal(Method*);
// other possible method connections: network.c, ...

// 386/boot$CONF.c
//extern Method method[];   /* defined in ../$arch/boot$CONF.c */
//extern char*  bootdisk;   /* defined in ../$arch/boot$CONF.c */
//void main(int argc, char **argv)

/* main entry point */
// boot.c:
extern void boot(int, char **);

@
\fi
%$

%// what boot$CONF.c used to expect
%//typedef struct Method Method;
%//struct Method
%//{
%//  char  *name;
%//  void  (*config)(Method*);
%//  int (*connect)(void);
%//  char  *arg;
%//};


\subsection*{[[init/user/boot/local.c]]}

%//void
%//configlocal(Method *mp)
%//{
%//  USED(mp);
%//}



\subsection*{[[init/386/l.s]]}

<<l.s>>=
#include "mem.h"
#undef DELAY

//*****************************************************************************
// Constants/Macros
//*****************************************************************************

#define PADDR(ka)        ((ka) & ~KZERO)
#define KADDR(pa)        (KZERO|(pa))

/*
 * Some machine instructions not handled by 8[al].
 */
#define DELAY           BYTE $0xEB; BYTE $0x00  /* JMP .+2 */

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. Note that these are assembler-specific hence
 * the '<<2'.
 */
#define PDO(a)          (((((a))>>22) & 0x03FF)<<2)
#define PTO(a)          (((((a))>>12) & 0x03FF)<<2)
// <<2 because each PDE or PTE is 4 bytes.

//*****************************************************************************
// Entry point!! (after jump from l_multiboot.s)
//*****************************************************************************

<<function _setup_segmentation>>

//*****************************************************************************
// Gdts Data
//*****************************************************************************

<<global tgdt>>

<<global tgdtptr>>

// realmode stuff
TEXT m0rgdtptr(SB), $0
        WORD    $(NGDT*8-1)
        LONG    $(CPU0GDT-KZERO)

TEXT m0gdtptr(SB), $0
        WORD    $(NGDT*8-1)
        LONG    $CPU0GDT

TEXT m0idtptr(SB), $0
        WORD $(256*8-1)
        LONG $IDTADDR

//*****************************************************************************
// Assume protected 32 bit and GTD done
//*****************************************************************************

<<function _setup_pagination>>

<<function _setup_bss_stack>>

        
//*****************************************************************************
// CPU registers accessor
//*****************************************************************************
               
/*
 * Read/write various system registers.
 * CR4 and the 'model specific registers' should only be read/written
 * after it has been determined the processor supports them
 */
TEXT lgdt(SB), $0                               /* GDTR - global descriptor table */
        MOVL    gdtptr+0(FP), AX
        MOVL    (AX), GDTR
        RET

TEXT lidt(SB), $0                               /* IDTR - interrupt descriptor table */
        MOVL    idtptr+0(FP), AX
        MOVL    (AX), IDTR
        RET

TEXT ltr(SB), $0                                /* TR - task register */
        MOVL    tptr+0(FP), AX
        MOVW    AX, TASK
        RET



TEXT getcr0(SB), $0                             /* CR0 - processor control */
        MOVL    CR0, AX
        RET

TEXT getcr2(SB), $0                             /* CR2 - page fault linear address */
        MOVL    CR2, AX
        RET

TEXT getcr3(SB), $0                             /* CR3 - page directory base */
        MOVL    CR3, AX
        RET

TEXT getcr4(SB), $0                             /* CR4 - extensions */
        MOVL    CR4, AX
        RET


TEXT putcr0(SB), $0
        MOVL    cr0+0(FP), AX
        MOVL    AX, CR0
        RET

TEXT putcr3(SB), $0
        MOVL    cr3+0(FP), AX
        MOVL    AX, CR3
        RET

TEXT putcr4(SB), $0
        MOVL    cr4+0(FP), AX
        MOVL    AX, CR4
        RET

@
%$
% >> >>

\subsection*{[[init/386/l_misc.s]]}


<<l_misc.s>>=

/*
 * Some machine instructions not handled by 8[al].
 */
#define HLT             BYTE $0xF4

<<function idle>>

<<function halt>>

/*
 * Basic timing loop to determine CPU frequency.
 */
TEXT aamloop(SB), $0
        MOVL    count+0(FP), CX
_aamloop:
        AAM
        LOOP    _aamloop
        RET


//*****************************************************************************
// Misc
//*****************************************************************************

#define INVLPG  BYTE $0x0F; BYTE $0x01; BYTE $0x39      /* INVLPG (%ecx) */
TEXT invlpg(SB), $0
        /* 486+ only */
        MOVL    va+0(FP), CX
        INVLPG
        RET

#define WBINVD  BYTE $0x0F; BYTE $0x09
TEXT wbinvd(SB), $0
        WBINVD
        RET

#define RDTSC           BYTE $0x0F; BYTE $0x31  /* RDTSC, result in AX/DX (lo/hi) */
TEXT _cycles(SB), $0                            /* time stamp counter */
        RDTSC
        MOVL    vlong+0(FP), CX                 /* &vlong */
        MOVL    AX, 0(CX)                       /* lo */
        MOVL    DX, 4(CX)                       /* hi */
        RET

/*
 * stub for:
 * time stamp counter; low-order 32 bits of 64-bit cycle counter
 * Runs at fasthz/4 cycles per second (m->clkin>>3)
 */
TEXT lcycles(SB),1,$0
        RDTSC
        RET

#define RDMSR           BYTE $0x0F; BYTE $0x32  /* RDMSR, result in AX/DX (lo/hi) */
TEXT rdmsr(SB), $0                              /* model-specific register */
        MOVL    index+0(FP), CX
        RDMSR
        MOVL    vlong+4(FP), CX                 /* &vlong */
        MOVL    AX, 0(CX)                       /* lo */
        MOVL    DX, 4(CX)                       /* hi */
        RET

#define WRMSR           BYTE $0x0F; BYTE $0x30  /* WRMSR, argument in AX/DX (lo/hi) */
                
TEXT wrmsr(SB), $0
        MOVL    index+0(FP), CX
        MOVL    lo+4(FP), AX
        MOVL    hi+8(FP), DX
        WRMSR
        RET


#define CPUID           BYTE $0x0F; BYTE $0xA2  /* CPUID, argument in AX */
        
/*
 * Try to determine the CPU type which requires fiddling with EFLAGS.
 * If the Id bit can be toggled then the CPUID instruction can be used
 * to determine CPU identity and features. First have to check if it's
 * a 386 (Ac bit can't be set). If it's not a 386 and the Id bit can't be
 * toggled then it's an older 486 of some kind.
 *
 *      cpuid(fun, regs[4]);
 */
TEXT cpuid(SB), $0
        MOVL    $0x240000, AX
        PUSHL   AX
        POPFL                                   /* set Id|Ac */
        PUSHFL
        POPL    BX                              /* retrieve value */
        MOVL    $0, AX
        PUSHL   AX
        POPFL                                   /* clear Id|Ac, EFLAGS initialised */
        PUSHFL
        POPL    AX                              /* retrieve value */
        XORL    BX, AX
        TESTL   $0x040000, AX                   /* Ac */
        JZ      _cpu386                         /* can't set this bit on 386 */
        TESTL   $0x200000, AX                   /* Id */
        JZ      _cpu486                         /* can't toggle this bit on some 486 */
        /* load registers */
        MOVL    regs+4(FP), BP
        MOVL    fn+0(FP), AX                    /* cpuid function */
        MOVL    4(BP), BX
        MOVL    8(BP), CX                       /* typically an index */
        MOVL    12(BP), DX
        CPUID
        JMP     _cpuid
_cpu486:
        MOVL    $0x400, AX
        JMP     _maybezapax
_cpu386:
        MOVL    $0x300, AX
_maybezapax:
        CMPL    fn+0(FP), $1
        JE      _zaprest
        XORL    AX, AX
_zaprest:
        XORL    BX, BX
        XORL    CX, CX
        XORL    DX, DX
_cpuid:
        MOVL    regs+4(FP), BP
        MOVL    AX, 0(BP)
        MOVL    BX, 4(BP)
        MOVL    CX, 8(BP)
        MOVL    DX, 12(BP)
        RET




TEXT mb386(SB), $0
        POPL    AX                              /* return PC */
        PUSHFL
        PUSHL   CS
        PUSHL   AX
        IRETL

TEXT mb586(SB), $0
        XORL    AX, AX
        CPUID
        RET

TEXT sfence(SB), $0
        BYTE $0x0f
        BYTE $0xae
        BYTE $0xf8
        RET

TEXT lfence(SB), $0
        BYTE $0x0f
        BYTE $0xae
        BYTE $0xe8
        RET

TEXT mfence(SB), $0
        BYTE $0x0f
        BYTE $0xae
        BYTE $0xf0
        RET

TEXT cmpswap486(SB), $0
        MOVL    addr+0(FP), BX
        MOVL    old+4(FP), AX
        MOVL    new+8(FP), CX
        LOCK
        BYTE $0x0F; BYTE $0xB1; BYTE $0x0B      /* CMPXCHGL CX, (BX) */
        JNZ didnt
        MOVL    $1, AX
        RET
didnt:
        XORL    AX,AX
        RET

TEXT mul64fract(SB), $0
/*
 * Multiply two 64-bit number s and keep the middle 64 bits from the 128-bit result
 * See ../port/tod.c for motivation.
 */
        MOVL    r+0(FP), CX
        XORL    BX, BX                          /* BX = 0 */

        MOVL    a+8(FP), AX
        MULL    b+16(FP)                        /* a1*b1 */
        MOVL    AX, 4(CX)                       /* r2 = lo(a1*b1) */

        MOVL    a+8(FP), AX
        MULL    b+12(FP)                        /* a1*b0 */
        MOVL    AX, 0(CX)                       /* r1 = lo(a1*b0) */
        ADDL    DX, 4(CX)                       /* r2 += hi(a1*b0) */

        MOVL    a+4(FP), AX
        MULL    b+16(FP)                        /* a0*b1 */
        ADDL    AX, 0(CX)                       /* r1 += lo(a0*b1) */
        ADCL    DX, 4(CX)                       /* r2 += hi(a0*b1) + carry */

        MOVL    a+4(FP), AX
        MULL    b+12(FP)                        /* a0*b0 */
        ADDL    DX, 0(CX)                       /* r1 += hi(a0*b0) */
        ADCL    BX, 4(CX)                       /* r2 += carry */
        RET
@

%//TEXT xchgw(SB), $0
%//      MOVL    v+4(FP), AX
%//      MOVL    p+0(FP), BX
%//      XCHGW   AX, (BX)
%//      RET


\subsection*{[[init/386/l_multiboot.s]]}


\subsection*{[[init/386/main.c]]}

\ifallcode
<<main.c forward decl for backward dependencies>>=
// part of a trick to remove some backward dependencies
int devcons_print(char*, ...);
int devcons_iprint(char*, ...);
int devcons_pprint(char*, ...);
void devcons_panic(char*, ...);
void devcons__assert(char*);
void trap_dumpstack(void);
void proc_dumpaproc(Proc *p);
void proc_error(char*);
void proc_nexterror(void);
void i8253_delay(int millisecs);
void i8253_microdelay(int microsecs);
void proc_sched(void);
void proc_ready(Proc*);
void proc_sleep(Rendez*, int(*)(void*), void*);
void proc_tsleep(Rendez *r, int (*fn)(void*), void *arg, ulong ms);
Proc* proc_wakeup(Rendez*);
void proc_pexit(char *exitstr, bool freemem);
Proc* proc_proctab(int i);
void main_exit(int ispanic);
int  main_isaconfig(char *class, int ctlrno, ISAConf *isa);
void nop(void);
uvlong devarch_fastticks(uvlong *hz);
void devarch_hook_ioalloc();
void chan_cclose(Chan *c);
int proc_postnote(Proc *p, int dolock, char *n, int flag);
@ 
\fi

<<function options>>=
static void
options(void)
{
        long i, n;
        char *cp, *line[MAXCONF], *p, *q;
        ulong l;
        kern_addr2 m;

        if(multiboot != nil){
                cp = BOOTARGS;
                *cp = 0;
                if((*multiboot & 8) != 0 && multiboot[5] > 0){
                        m = KADDR(multiboot[6]);
                        l = m[1] - m[0];
                        m = KADDR(m[0]);
                        if(l >= BOOTARGSLEN)
                                l = BOOTARGSLEN - 1;
                        memmove(cp, m, l);
                        cp[l] = 0;
                }
        }

        /*
         *  parse configuration args from dos file plan9.ini
         */
        cp = BOOTARGS;  /* where b.com leaves its config */
        cp[BOOTARGSLEN-1] = 0;

        /*
         * Strip out '\r', change '\t' -> ' '.
         */
        p = cp;
        for(q = cp; *q; q++){
                if(*q == '\r')
                        continue;
                if(*q == '\t')
                        *q = ' ';
                *p++ = *q;
        }
        *p = 0;

        n = getfields(cp, line, MAXCONF, 1, "\n");
        for(i = 0; i < n; i++){
                if(*line[i] == '#')
                        continue;
                cp = strchr(line[i], '=');
                if(cp == nil)
                        continue;
                *cp++ = '\0';
                confname[nconf] = line[i];
                confval[nconf] = cp;
                nconf++;
        }
}
@


<<function writeconf>>=
static void
writeconf(void)
{
        char *p, *q;
        int n;

        p = getconfenv();

        if(waserror()) {
                free(p);
                nexterror();
        }

        /* convert to name=value\n format */
        for(q=p; *q; q++) {
                q += strlen(q);
                *q = '=';
                q += strlen(q);
                *q = '\n';
        }
        n = q - p + 1;
        if(n >= BOOTARGSLEN)
                error("kernel configuration too large");
        memset(BOOTLINE, 0, BOOTLINELEN);
        memmove(BOOTARGS, p, n);
        poperror();
        free(p);
}
@


<<function pusharg>>=
uchar *
pusharg(char *p)
{
        int n;

        n = strlen(p)+1;
        sp -= n;
        memmove(sp, p, n);
        return sp;
}
@


<<function bootargs>>=
void
bootargs(void *base)
{
        int i, ac;
        uchar *av[32];
        uchar **lsp;
        char *cp = BOOTLINE;
        char buf[64];

        sp = (uchar*)base + BY2PG - Ustkheadroom;

        ac = 0;
        av[ac++] = pusharg("/386/9dos");

        /* when boot is changed to only use rc, this code can go away */
        cp[BOOTLINELEN-1] = 0;
        buf[0] = 0;
        if(strncmp(cp, "fd", 2) == 0){
                snprint(buf, sizeof buf, "local!#f/fd%lddisk",
                        strtol(cp+2, 0, 0));
                av[ac++] = pusharg(buf);
        } else if(strncmp(cp, "sd", 2) == 0){
                snprint(buf, sizeof buf, "local!#S/sd%c%c/fs", *(cp+2), *(cp+3));
                av[ac++] = pusharg(buf);
        } else if(strncmp(cp, "ether", 5) == 0)
                av[ac++] = pusharg("-n");

        /* 4 byte word align stack */
        sp = (uchar*)((ulong)sp & ~3);

        /* build argc, argv on stack */
        sp -= (ac+1)*sizeof(sp);
        lsp = (uchar**)sp;
        for(i = 0; i < ac; i++)
                *lsp++ = av[i] + ((USTKTOP - BY2PG) - (ulong)base);
        *lsp = 0;
        sp += (USTKTOP - BY2PG) - (ulong)base - sizeof(ulong);
}
@




<<global mathmsg>>=
static char* mathmsg[] =
{
        nil,    /* handled below */
        "denormalized operand",
        "division by zero",
        "numeric overflow",
        "numeric underflow",
        "precision loss",
};
@



<<function isaconfig>>=
int
main_isaconfig(char *class, int ctlrno, ISAConf *isa)
{
        char cc[32], *p;
        int i;

        snprint(cc, sizeof cc, "%s%d", class, ctlrno);
        p = getconf(cc);
        if(p == nil)
                return 0;

        isa->type = "";
        isa->nopt = tokenize(p, isa->opt, NISAOPT);
        for(i = 0; i < isa->nopt; i++){
                p = isa->opt[i];
                if(cistrncmp(p, "type=", 5) == 0)
                        isa->type = p + 5;
                else if(cistrncmp(p, "port=", 5) == 0)
                        isa->port = strtoul(p+5, &p, 0);
                else if(cistrncmp(p, "irq=", 4) == 0)
                        isa->irq = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "dma=", 4) == 0)
                        isa->dma = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "mem=", 4) == 0)
                        isa->mem = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "size=", 5) == 0)
                        isa->size = strtoul(p+5, &p, 0);
                else if(cistrncmp(p, "freq=", 5) == 0)
                        isa->freq = strtoul(p+5, &p, 0);
        }
        return 1;
}
@


<<[[main()]] initial assgnments for backward dependencies>>=
// initial assignment made to avoid circular dependencies in codegraph
print = devcons_print;
iprint = devcons_iprint;
pprint = devcons_pprint;

panic = devcons_panic;
_assert = devcons__assert;

error = proc_error;
nexterror = proc_nexterror;

dumpstack = trap_dumpstack;
dumpaproc = proc_dumpaproc;

devtab = conf_devtab;

delay = i8253_delay;
microdelay = i8253_microdelay;

wakeup = proc_wakeup;
sched = proc_sched;
ready = proc_ready;
sleep = proc_sleep;
tsleep = proc_tsleep;

exit = main_exit;
isaconfig = main_isaconfig;

/*
 * On a uniprocessor, you'd think that coherence could be nop,
 * but it can't.  We still need a barrier when using coherence() in
 * device drivers.
 *
 * On VMware, it's safe (and a huge win) to set this to nop.
 * Aux/vmware does this via the #P/archctl file.
 */
coherence = nop;

fastticks = devarch_fastticks;

cclose = chan_cclose;

proctab = proc_proctab;
postnote = proc_postnote;
pexit = proc_pexit;

hook_ioalloc = devarch_hook_ioalloc;
@




<<main.c>>=
<<kernel basic includes>>

#include        "io.h"
#include        "mp.h"

// initcode binary
#include        "init.h"
// rebootcode binary
#include        "reboot.h"

#include        <ureg.h>
#include        <pool.h>
#include        <tos.h>

void bootargs(void*);

<<main.c forward decl for backward dependencies>>

// conf.c
extern  Dev*  conf_devtab[];
// ??
extern  char* conffile;
//extern  uchar initcode[]; in init.h

extern void (*i8237alloc)(void);

//*****************************************************************************
// Configuration
//*****************************************************************************
// See globals in portdat_globals.h

//*****************************************************************************
// Boot parameters (not used by pad)
//*****************************************************************************

/*
 * Where configuration info is left for the loaded program.
 * This will turn into a structure as more is done by the boot loader
 * (e.g. why parse the .ini file twice?).
 * There are 3584 bytes available at CONFADDR.
 */
#define BOOTLINE        ((char*)CONFADDR)
#define BOOTLINELEN     64
#define BOOTARGS        ((char*)(CONFADDR+BOOTLINELEN))
#define BOOTARGSLEN     (4096-0x200-BOOTLINELEN)


enum {
        /* space for syscall args, return PC, top-of-stack struct */
        Ustkheadroom    = sizeof(Sargs) + sizeof(uintptr) + sizeof(Tos),
};

//char bootdisk[KNAMELEN];

// Global! set by bootargs()
uchar *sp;      /* user stack of init proc */

// could delete, nobody set it to true anyway
int delaylink = 0;

//@Scheck: Assembly
extern phys_addr *multiboot;

<<function options>>

<<function writeconf>>

//*****************************************************************************
// Cpu init
//*****************************************************************************

<<function cpuinit>>

<<function cpu0init>>

//*****************************************************************************
// Conf init
//*****************************************************************************

<<function confinit>>

//*****************************************************************************
// First process init
//*****************************************************************************

<<function init0>>

<<function pusharg>>

//TODO: get rid of as have simplified boot process, no plan9.ini
<<function bootargs>>

<<function userinit>>

//*****************************************************************************
// Math coprocessor
//*****************************************************************************

<<global mathmsg>>

<<function mathstate>>

<<function mathnote>>

<<function matherror>>

<<function mathemu>>

<<function mathover>>

<<function mathinit>>

//*****************************************************************************
// Shutdown/reboot
//*****************************************************************************

<<function shutdown>>

<<function exit>>

<<function reboot>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<function isaconfig>>

//*****************************************************************************
// Main entry point!
//*****************************************************************************

<<function main>>
@


\subsection*{[[init/portfns_init.h]]}

\ifallcode
<<portfns_init.h>>=

//in init/386/main.c (but used in port)
void    reboot(kern_addr3, kern_addr3, ulong);

// rebootcmd.c
//void    readn(Chan *, void *, long);
void    rebootcmd(int, char**);

@
\fi

\section{[[lib/]]}

\subsection*{[[lib/lib.h]]}

\ifallcode
<<lib.h forward decl>>=
typedef struct Qid  Qid;
typedef struct Dir  Dir;
typedef struct Waitmsg  Waitmsg;
typedef struct Fmt  Fmt;
@
\fi





<<enum node>>=
enum note {
  NCONT = 0, /* continue after note */
  NDFLT = 1, /* terminate after note */
  NSAVE = 2, /* clear note but hold state */
  NRSTR = 3, /* restore saved state */
};
@ 


<<enum open>>=
enum open {
  OREAD = 0, /* open for read */
  OWRITE = 1, /* write */
  ORDWR = 2, /* read and write */
  OEXEC = 3, /* execute, == read but check execute permission */
  OTRUNC = 16,  /* or'ed in (except for exec), truncate file first */
  OCEXEC = 32,  /* or'ed in, close on exec */
  ORCLOSE = 64,  /* or'ed in, remove on close */
  OEXCL = 0x1000,  /* or'ed in, exclusive create */
};
@ 


<<enum mount>>=
enum mount {
  MREPL = 0x0000,  /* mount replaces object */
  MBEFORE = 0x0001,  /* mount goes before others in union directory */
  MAFTER = 0x0002,  /* mount goes after others in union directory */
  MCREATE = 0x0004,  /* permit creation in mounted directory */
  MCACHE = 0x0010,  /* cache some data */

  MORDER =  0x0003,  /* mask for bits defining order of mounting */
  MMASK = 0x0017,  /* all bits on */
};
@ 


<<constant ERRMAX>>=
ERRMAX = 128, /* max length of error string */
@


<<constant KNAMELEN>>=
KNAMELEN = 28,  /* max length of name held in kernel */
@

\ifallcode
<<enum miscsize>>=
enum miscsize {  
    <<constant ERRMAX>>
    <<constant KNAMELEN>>
};
@ 
\fi


<<function nelem>>=
#define nelem(x)  (sizeof(x)/sizeof((x)[0]))
@


<<function offsetof>>=
#define offsetof(s, m)  (ulong)(&(((s*)0)->m))
@

<<function assert>>=
#define assert(x) if(x){}else _assert("x")
@




<<lib.h print decl>>=
// This used to be regular function, but to avoid backward deps in the kernel
// I made it into a pointer function (a bit ugly, and maybe unsafe)
extern  int (*print)(char*, ...);
@


<<lib.h>>=
// coupling: libc.h
// This file mostly exports code from lib_core/libc/ (linked with the kernel).
// Those functions are also exported in include/libc.h but they prefered to
// not include it and instead to reexport here a subset specific to the kernel.
// There are also the poolxxx() functions exported in include/pool.h
// (also part of libc) that are used in memory/alloc.c.
// Some functions in libc are also "overriden" (via linker abuse):
//  - print.c overrides _fmtlock(), _fmtunlock() that were in libc/fmt/
//  - devcons.s overrides the sysfatal() that was in libc/9sys/

// pad specific, could be in u.h
<<pad basic types>>

<<lib.h forward decl>>

/*
 * functions (mostly) linked in from libc.
 */
<<function nelem>>
<<function offsetof>>
<<function assert>>

/*
 * mem routines
 */
<<lib.h mem functions decl>>

/*
 * string routines
 */
<<lib.h string functions decl>>

//redefined in the kernel
extern  int cistrcmp(char*, char*);
extern  int cistrncmp(char*, char*, int);

<<enum utf>>

/*
 * rune routines
 */
<<lib.h rune functions decl>>

extern  int abs(int);

/*
 * print routines
 */
typedef int (*Fmts)(Fmt*);
<<struct Fmt>>

<<lib.h print decl>>

<<lib.h printf functions decl>>

<<lib.h pragmas>>

<<lib.h fmt functions decl>>

/*
 * one-of-a-kind
 */
<<lib.h strto functions decl>>

//todo: should return a (void*)
extern  ulong getcallerpc(void*);
extern  char* cleanname(char*);
extern  int getfields(char*, char**, int, int, char*);
extern  int tokenize(char*, char**, int);
extern  void  qsort(void*, long, long, int (*)(void*, void*));

<<lib.h exxx decl>>


/*
 * Syscall data structures
 */
<<enum mount>>

<<enum open>>

<<enum node>>

<<enum miscsize>>



<<enum qidtype>>

<<enum dirmode>>

<<struct Qid>>

<<struct Dir>>


<<struct Waitmsg>>

@
%//unused: extern  int dec64(uchar*, int, char*, int);
%//unused: extern  int encodefmt(Fmt*);

%// for byteorder agnostic marshalling?
%// dead?
%struct OWaitmsg
%{
%  char  pid[12];  /* of loved one */
%  char  time[3*12]; /* of loved one and descendants */
%  char  msg[64];  /* compatibility BUG */
%};
%@ 



\section{[[memory/]]}

\subsection*{[[memory/386/dat_memory.h]]}


<<dat_memory.h>>=

// define things used in Proc, for mmu.c to work on
/*
 *  MMU stuff in proc
 */
<<struct ArchProcMMU>>

<<struct KMap>>
<<macro VA>>
@


\subsection*{[[memory/386/mem.h]]}

<<mem.h>>=
/*
 * Memory and machine-specific definitions.  Used in C and assembler.
 */

/*
 * Sizes
 */
//defined in dat.h misc_constants
//#define KB      1024
//#define MB      (KB*KB)

#define BI2BY   8     /* bits per byte */
#define BI2WD   32      /* bits per word */

#define BY2WD   4     /* bytes per word */
#define BY2V    8     /* bytes per double word */

#define BY2PG   4096      /* bytes per page */
#define WD2PG   (BY2PG/BY2WD)   /* words per page */
#define PGSHIFT   12      /* log(BY2PG) */

<<constant BLOCKALIGN>>

// Intel specific
#define BY2XPG    (4096*1024)   /* bytes per big page */

<<constant FPalign>>

<<constant MAXCPUS>>
<<constant KSTACK>>

/*
 * Time
 */
<<constant HZ>>
#define MS2HZ   (1000/HZ)   /* millisec per clock tick */
#define TK2SEC(t) ((t)/HZ)    /* ticks to seconds */

/*
 *  Address spaces
 */

// 0x10 = 16
// 0x100 = 256
// 0x1000 = 4Ko (1 page)
// 0x10000 = 64Ko
// 0x100000 = 1Mo
// 0x1000000 = 256Mo
// note: graphic card memory is at 0xb8000 so safer to go to 1Mo for kernel

<<constant KZERO>>
<<constant KTZERO>>

<<constant UZERO>>
<<constant UTZERO>>

<<function UTROUND>>
#define USTKTOP   (VMAP-BY2PG)    /* byte just beyond user stack */
#define USTKSIZE  (16*1024*1024)    /* size of user stack */
<<constant TSTKTOP>>
<<constant TSTKSIZ>>

<<constant MAXKPA>>

<<constant VPTSIZE>>
<<constant VPT>>

<<constant KMAPSIZE>>
<<constant KMAP>>

<<constant VMAPSIZE>>
<<constant VMAP>>
/*
 * Fundamental addresses - bottom 64kB saved for return to real mode
 */
#define CONFADDR  (KZERO+0x1200)    /* info passed from boot loader */

<<constant TMPADDR>>

#define APBOOTSTRAP (KZERO+0x3000)    /* AP bootstrap code */

#define RMUADDR   (KZERO+0x7C00)    /* real mode Ureg */
#define RMCODE    (KZERO+0x8000)    /* copy of first page of KTEXT */
#define RMBUF   (KZERO+0x9000)    /* buffer for user space - known to vga */

<<constant IDTADDR>>
#define REBOOTADDR  (0x11000)   /* reboot code - physical address */

#define CPU0PD   (KZERO+0x12000)   /* bootstrap processor PD */
#define CPU0PT   (KZERO+0x13000)   /* bootstrap processor PT for 0-4MB */
#define CPU0GDT   (KZERO+0x14000)   /* bootstrap processor GDT */

#define CPUADDR  (KZERO+0x15000)   /* as seen by current processor */
#define CPU0CPU  (KZERO+0x16000)   /* Cpu for bootstrap processor */
#define CPUSIZE  BY2PG

#define CPU0END   (CPU0CPU+BY2PG)

/*
 * N.B.  ramscan() knows that CPU0END is the end of reserved data
 * N.B.  _setup_pagination knows that CPU0PD is the first reserved page
 * and that there are 5 of them.
 */
// MemMin in memory.c must start at the end of what CPU0PT covers (so 4MB)


// could be an enum but this also used from assembly
<<constant x86 segments>>

<<constant SELGDT>>
#define SELLDT  (1<<2)  /* selector is in ldt */

<<macro SELECTOR>>

<<constant x86 segment selectors>>

<<constant segment field extractors>>

/*
 *  virtual MMU
 */
<<constant PAGETABMAPMEM>>
<<constant PAGETABSIZE>>
<<constant PAGEDIRSIZE>>
<<constant SMALLPAGEDIRSIZE>>

#define PPN(x)    ((x)&~(BY2PG-1))

<<constant PTExxx>>

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. 
 */
#define PDX(va)   ((((virt_addr)(va))>>22) & 0x03FF)
#define PTX(va)   ((((virt_addr)(va))>>12) & 0x03FF)
// 0x03FF = 1023, so 10 bits, put 1024-1 no?

<<constant VectorSYSCALL>>
@


\subsection*{[[memory/386/memory.c]]}

\ifallcode
<<memory.c forward decl>>=
typedef struct Map Map;
typedef struct RMap RMap;
@
\fi

<<memory.c debugging macro>>=
#define MEMDEBUG    0
@



<<memory.c>>=
/*
 * Size memory and create the kernel page-tables on the fly while doing so.
 * Called from main(), this code should only be run by the bootstrap processor.
 *
 * MemMin is what the bootstrap code in l.s has already mapped;
 * MemMax is the limit of physical memory to scan.
 */
<<kernel basic includes>>
#include "io.h"
#include <ureg.h>

<<memory.c debugging macro>>

<<enum memkind>>

enum {
    MemMin      = 4*MB,
    MemMax      = (3*1024+768)*MB,
};
// coupling: with l.s for MemMin. 
// Why MemMax is not 4Go? because iterate by 256MB each time?

<<memory.c forward decl>>
<<struct Map>>

<<struct RMap>>

/* 
 * Memory allocation tracking.
 */
static Map mapupa[16];
static RMap rmapupa = {
    "unallocated unbacked physical memory",
    mapupa,
    &mapupa[nelem(mapupa)-1],
};

<<global mapram>>

static Map mapumb[64];
static RMap rmapumb = {
    "upper memory block",
    mapumb,
    &mapumb[nelem(mapumb)-1],
};

static Map mapumbrw[16];
static RMap rmapumbrw = {
    "UMB device memory",
    mapumbrw,
    &mapumbrw[nelem(mapumbrw)-1],
};

<<function mapprint>>

<<function memdebug>>

<<function mapfree>>

<<function mapalloc>>

<<function rampage>>

<<function umbscan>>

<<function sigscan>>

<<function sigsearch>>

<<function lowraminit>>

<<function ramscan>>

<<function meminit>>

<<function upaalloc>>

<<function upareserve>>

<<function memorysummary>>

@


%static char *etypes[] =
%{
%    "type=0",
%    "memory",
%    "reserved",
%    "acpi reclaim",
%    "acpi nvs",
%};

%
%
%//void
%//upafree(ulong pa, int size)
%//{
%//  mapfree(&rmapupa, pa, size);
%//}
%
%
%//ulong
%//umbrwmalloc(ulong addr, int size, int align)
%//{
%//  ulong a;
%//  uchar o[2], *p;
%//
%//  if(a = mapalloc(&rmapumbrw, addr, size, align))
%//      return(ulong)KADDR(a);
%//
%//  /*
%//   * Perhaps the memory wasn't visible before
%//   * the interface is initialised, so try again.
%//   */
%//  if((a = umbmalloc(addr, size, align)) == 0)
%//      return 0;
%//  p = (uchar*)a;
%//  o[0] = p[0];
%//  p[0] = 0xCC;
%//  o[1] = p[size-1];
%//  p[size-1] = 0xCC;
%//  if(p[0] == 0xCC && p[size-1] == 0xCC){
%//      p[0] = o[0];
%//      p[size-1] = o[1];
%//      return a;
%//  }
%//  umbfree(a, size);
%//
%//  return 0;
%//}
%
%//void
%//umbrwfree(ulong addr, int size)
%//{
%//  mapfree(&rmapumbrw, PADDR(addr), size);
%//}


%/*
% * Allocate memory from the upper memory blocks.
% */
%kern_addr
%umbmalloc(ulong addr, int size, int align)
%{
%    ulong a;
%
%    if(a = mapalloc(&rmapumb, addr, size, align))
%        return (ulong)KADDR(a);
%
%    return nilptr;
%}

%void
%umbfree(ulong addr, int size)
%{
%    mapfree(&rmapumb, PADDR(addr), size);
%}


% used by screen.c, devpccard.c
<<function upaalloc>>=
/*
 * Give out otherwise-unused physical address space
 * for use in configuring devices.  Note that unlike upamalloc
 * before it, upaalloc does not map the physical address
 * into virtual memory.  Call vmap to do that.
 */
ulong
upaalloc(int size, int align)
{
    ulong a;

    a = mapalloc(&rmapupa, 0, size, align);
    if(a == 0){
        print("out of physical address space allocating %d\n", size);
        mapprint(&rmapupa);
    }
    return a;
}
@



\subsection*{[[memory/386/mmu.c]]}

\ifallcode
<<mmu.c forward decl>>=
static void taskswitch(ulong, ulong);
static void memglobal(void);
static int findhole(ulong *a, int n, int count);
static ulong vmapalloc(ulong size);
static void pdunmap(ulong*, ulong, int);
@
\fi



%// called? mv in debugging section? with C-t C-t stuff?
<<function checkpagerefs>>=
void
checkpagerefs(void)
{
    int s;
    ulong i, np, nwrong;
    ulong *ref;
    
    np = palloc.user;
    ref = malloc(np*sizeof ref[0]);
    if(ref == nil){
        print("checkpagerefs: out of memory\n");
        return;
    }
    
    /*
     * This may not be exact if there are other processes
     * holding refs to pages on their stacks.  The hope is
     * that if you run it on a quiescent system it will still
     * be useful.
     */
    s = splhi();
    lock(&palloc);
    countpagerefs(ref, 0);
    portcountpagerefs(ref, 0);
    nwrong = 0;
    for(i=0; i<np; i++){
        if(palloc.pages[i].ref != ref[i]){
            iprint("page %#.8lux ref %d actual %lud\n", 
                palloc.pages[i].pa, palloc.pages[i].ref, ref[i]);
            ref[i] = 1;
            nwrong++;
        }else
            ref[i] = 0;
    }
    countpagerefs(ref, 1);
    portcountpagerefs(ref, 1);
    iprint("%lud mistakes found\n", nwrong);
    unlock(&palloc);
    splx(s);
}
@

<<[[Segment]] other fields>>=
    ulong mark;   /* portcountrefs */
@

<<function portcountpagerefs>>=
void
portcountpagerefs(ulong *ref, int print)
{
    ulong i, j, k, ns, n;
    Page **pg, *entry;
    Proc *p;
    Pagetable *pt;
    Segment *s;

    /*
     * Pages in segments.  s->mark avoids double-counting.
     */
    n = 0;
    ns = 0;
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        for(j=0; j<NSEG; j++){
            s = p->seg[j];
            if(s)
                s->mark = 0;
        }
    }
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        for(j=0; j<NSEG; j++){
            s = p->seg[j];
            if(s == nil || s->mark++)
                continue;
            ns++;
            for(k=0; k<s->pagedirsize; k++){
                pt = s->pagedir[k];
                if(pt == nil)
                    continue;
                for(pg = pt->first; pg <= pt->last; pg++){
                    entry = *pg;
                    if(pagedout(entry))
                        continue;
                    if(print){
                        if(ref[pagenumber(entry)])
                            iprint("page %#.8lux in segment %#p\n", entry->pa, s);
                        continue;
                    }
                    if(ref[pagenumber(entry)]++ == 0)
                        n++;
                }
            }
        }
    }
    if(!print){
        iprint("%lud pages in %lud segments\n", n, ns);
        for(i=0; i<conf.nproc; i++){
            p = proctab(i);
            for(j=0; j<NSEG; j++){
                s = p->seg[j];
                if(s == nil)
                    continue;
                if(s->ref != s->mark){
                    iprint("segment %#p (used by proc %lud pid %lud) has bad ref count %lud actual %lud\n",
                        s, i, p->pid, s->ref, s->mark);
                }
            }
        }
    }
}
@




<<function countpagerefs>>=
/*
 * More debugging.
 */
void
countpagerefs(ulong *ref, int print)
{
    int i, n;
    Cpu *mm;
    Page *pg;
    Proc *p;
    
    n = 0;
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        if(p->mmupd){
            if(print){
                if(ref[pagenumber(p->mmupd)])
                    iprint("page %#.8lux is proc %d (pid %lud) pd\n",
                        p->mmupd->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(p->mmupd)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is proc %d (pid %lud) pd but has other refs!\n",
                    p->mmupd->pa, i, p->pid);
        }
        <<[[countpagerefs()]] handle kmaptable>>
        for(pg=p->mmuused; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is on proc %d (pid %lud) mmuused\n",
                        pg->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is on proc %d (pid %lud) mmuused but has other refs!\n",
                    pg->pa, i, p->pid);
        }
        for(pg=p->mmufree; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is on proc %d (pid %lud) mmufree\n",
                        pg->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is on proc %d (pid %lud) mmufree but has other refs!\n",
                    pg->pa, i, p->pid);
        }
    }
    if(!print)
        iprint("%d pages in proc mmu\n", n);
    n = 0;
    for(i=0; i<conf.ncpu; i++){
        mm = CPUS(i);
        for(pg=mm->mmupdpool; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is in cpu%d mmupdpool\n",
                        pg->pa, i);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is in cpu%d mmupdpool but has other refs!\n",
                    pg->pa, i);
        }
    }
    if(!print){
        iprint("%d pages in cpu mmupdpools\n", n);
        for(i=0; i<conf.ncpu; i++)
            iprint("cpu%d: %d mmupdalloc, %d mmupdfree\n",
                i, CPUS(i)->mmupdalloc, CPUS(i)->mmupdfree);
    }
}
@

<<[[Cpu]] [[Arch]] other fields>>=
int mmupdalloc;
int mmupdfree;
@



<<mmu.c>>=
/*
 * Memory mappings.  Life was easier when 2G of memory was enough.
 *
 * The kernel memory starts at KZERO, with the text loaded at KZERO+1M
 * (9load sits under 1M during the load).  The memory from KZERO to the
 * top of memory is mapped 1-1 with physical memory, starting at physical
 * address 0.  All kernel memory and data structures (i.e., the entries stored
 * into conf.mem) must sit in this physical range: if KZERO is at 0xF0000000,
 * then the kernel can only have 256MB of memory for itself.
 * 
 * The 256M below KZERO comprises three parts.  The lowest 4M is the
 * virtual page table, a virtual address representation of the current 
 * page table tree.  The second 4M is used for temporary per-process
 * mappings managed by kmap and kunmap.  The remaining 248M is used
 * for global (shared by all procs and all processors) device memory
 * mappings and managed by vmap and vunmap.  The total amount (256M)
 * could probably be reduced somewhat if desired.  The largest device
 * mapping is that of the video card, and even though modern video cards
 * have embarrassing amounts of memory, the video drivers only use one
 * frame buffer worth (at most 16M).  Each is described in more detail below.
 *
 * The VPT is a 4M frame constructed by inserting the pd into itself.
 * This short-circuits one level of the page tables, with the result that 
 * the contents of second-level page tables can be accessed at VPT.  
 * We use the VPT to edit the page tables (see mmu) after inserting them
 * into the page directory.  It is a convenient mechanism for mapping what
 * might be otherwise-inaccessible pages.  The idea was borrowed from
 * the Exokernel.
 *
 * The VPT doesn't solve all our problems, because we still need to 
 * prepare page directories before we can install them.  For that, we
 * use tmpmap/tmpunmap, which map a single page at TMPADDR.
 */

<<kernel basic includes>>
#include    "io.h"

<<macros xxxSEGM>>

<<global gdt>>

<<mmu.c forward decl>>

<<global vpt and vpd>>

<<function mmuinit0>>

<<global didmmuinit>>

<<function mmuinit>>

<<function memglobal>>

<<function flushmmu>>

<<function flushpg>>

<<function mmupdalloc>>

<<function mmupdfree>>

<<function mmuptefree>>

<<function taskswitch>>

<<function mmuswitch>>

<<function mmurelease>>

<<function upallocmmupd>>

<<function putmmu>>

<<function checkmmu>>

<<function mmuwalk>>

/*
 * Device mappings are shared by all procs and processors and
 * live in the virtual range VMAP to VMAP+VMAPSIZE.  The master
 * copy of the mappings is stored in cpu0->pdproto, and they are
 * paged in from there as necessary by vmapsync during faults.
 */

<<global vmaplock>>

<<function vmap>>

<<function findhole>>

<<function vmapalloc>>

<<function vunmap>>

<<function pdmap>>

<<function pdunmap>>

<<function vmapsync>>

/*
 * KMap is used to map individual pages into virtual memory.
 * It is rare to have more than a few KMaps at a time (in the 
 * absence of interrupts, only two at a time are ever used,
 * but interrupts can stack).  The mappings are local to a process,
 * so we can use the same range of virtual address space for
 * all processes without any coordination.
 */

<<global kpt>>
<<constant NKPT>>

<<function kmap>>

<<function kunmap>>

/*
 * Temporary one-page mapping used to edit page directories.
 *
 */

<<function tmpmap>>

<<function tmpunmap>>

<<function kaddr>>

<<function paddr>>

<<function countpagerefs>>

<<function cankaddr>>

@


\subsection*{[[memory/alloc.c]]}

\ifallcode
<<alloc.c debugging macro>>=
/* non tracing
 *
enum {
    Npadlong    = 0,
    MallocOffset = 0,
    ReallocOffset = 0,
};
 *
 */
@
\fi

<<alloc.c>>=
<<kernel basic includes>>

#include    <pool.h>

/* everything from here down should be the same in libc, libdebugmalloc, and the kernel */
/* - except the code for malloc(), which alternately doesn't clear or does. */
/* - except the code for smalloc(), which lives only in the kernel. */

//*****************************************************************************
// Debugging support
//*****************************************************************************

/*
 * Npadlong is the number of 32-bit longs to leave at the beginning of 
 * each allocated buffer for our own bookkeeping.  We return to the callers
 * a pointer that points immediately after our bookkeeping area.  Incoming pointers
 * must be decremented by that much, and outgoing pointers incremented.
 * The malloc tag is stored at MallocOffset from the beginning of the block,
 * and the realloc tag at ReallocOffset.  The offsets are from the true beginning
 * of the block, not the beginning the caller sees.
 *
 * The extra if(Npadlong != 0) in various places is a hint for the compiler to
 * compile out function calls that would otherwise be no-ops.
 */

/* tracing */
enum {
    Npadlong    = 2,
    MallocOffset = 0,
    ReallocOffset = 1
};

<<alloc.c debugging macro>>

<<function setmalloctag>>

<<function setrealloctag>>

//*****************************************************************************
// Pool wrappers
//*****************************************************************************

<<function smalloc>>

<<function malloc>>

<<function mallocz>>

<<function mallocalign>>

<<function free>>

<<function realloc>>

<<function msize>>


//*****************************************************************************
// kstr functions
//*****************************************************************************

//pad: was in chan.c

<<function kstrcpy>>

<<function kstrdup>>
@


%//ulong
%//getmalloctag(void *v)
%//{
%//  USED(v);
%//  if(Npadlong <= MallocOffset)
%//      return ~0;
%//  return ((ulong*)v)[-Npadlong+MallocOffset];
%//}
%//
%//ulong
%//getrealloctag(void *v)
%//{
%//  USED(v);
%//  if(Npadlong <= ReallocOffset)
%//      return ((ulong*)v)[-Npadlong+ReallocOffset];
%//  return ~0;
%//}
%//void*
%//calloc(ulong n, ulong szelem)
%//{
%//  void *v;
%//  if(v = mallocz(n*szelem, 1))
%//      setmalloctag(v, getcallerpc(&n));
%//  return v;
%//}

\subsection*{[[memory/fault.c]]}

\ifallcode
<<fault.c forward decl>>=
void        pio(Segment *, ulong, ulong, Page **);
@
\fi



<<fault.c>>=
<<kernel basic includes>>

<<fault.c forward decl>>

<<function fault>>

<<function faulterror>>

// for debugging SG_PHYSICAL
void    (*checkaddr)(ulong, Segment *, Page *);
ulong   addr2check;

<<function fixfault>>

<<function pio>>

<<function okaddr>>

<<function validaddr>>

<<function vmemchr>>

<<function seg>>

<<function checkpages>>
@


\subsection*{[[memory/page.c]]}

\ifallcode
<<page.c forward decl>>=
int hasfreepages(void*);
void portcountpagerefs(ulong*, int);
@
\fi



<<page.c>>=
<<kernel basic includes>>

<<page.c forward decl>>

//*****************************************************************************
// Initialization
//*****************************************************************************

<<function pageinit>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<function pageunchain>>

<<function pagechaintail>>

<<function pagechainhead>>

<<constructor newpage>>

<<function hasfreepages>>

<<destructor putpage>>

<<function auxpage>>

<<global dupretries>>

<<function duppage>>

<<function copypage>>

<<function uncachepage>>

<<function cachepage>>

<<function cachedel>>

<<function lookpage>>

<<function ptcpy>>

<<constructor ptalloc>>

<<destructor freept>>

<<function pagenumber>>

<<function checkpagerefs>>

<<function portcountpagerefs>>

@


\subsection*{[[memory/pool.c]]}

<<pool.c forward decl>>=
typedef struct Private  Private;
@



<<pool.c>>=
<<kernel basic includes>>

#include    <pool.h>

<<pool.c forward decl>>

//*****************************************************************************
// Concurrency
//*****************************************************************************

// See Pool.private, for mutual exclusion on memory pools
<<pool.c struct Private>>

//*****************************************************************************
// Pool methods
//*****************************************************************************

<<function poolprint>>

<<function ppanic>>

<<function plock>>

<<function punlock>>

<<function poolsummary>>

//*****************************************************************************
// The globals
//*****************************************************************************

<<global pmainmem>>

<<global pimagmem>>

<<global mainmem and imagmem>>

<<function mallosummary>>

@


\subsection*{[[memory/portdat_memory.c]]}


<<portdat_memory.c>>=
<<kernel basic includes>>

<<global palloc>>

<<global swapalloc>>
<<global swapimage>>

@


\subsection*{[[memory/portdat_memory.h]]}

<<portdat_memory.h>>=

// see also KMap in 386/ (but used in port)

//*****************************************************************************
// Page < Pagetable (can be filled by KImage) < Segment
//*****************************************************************************

// All the ref<Page> here are references to Pages in the array<Page> of 
// Palloc.pages (pool allocator)
// All the ref<Kimage> here are references to KImage in the ?? of 
// Imagealloc.free?

<<enum modref>>

<<struct Page>>

<<type PageOrSwap>>

<<struct Pagetable>>

<<struct KImage>>

<<enum segtype>>

<<constant PG_ONSWAP>>

<<function onswap>>
<<function pagedout>>
<<function swapaddr>>

#define SEGMAXSIZE  (PAGEDIRSIZE*PAGETABMAPMEM)

<<struct Physseg>>

enum
{
    <<constant LRESPROF>>
};

<<struct Segment>>

//*****************************************************************************
// Internal to memory/
//*****************************************************************************

// See also RMap in 386/

// actually internal to xalloc.c, but important so here
<<constants holes>>

<<struct Hole>>

<<struct Xhdr>>

<<struct Xalloc>>
//IMPORTANT: static Xalloc xlists; // private to xalloc.c


// from pool.h
//struct Pool {
//  char* name;
//  ulong maxsize;
//
//  ulong cursize;
//  ulong curfree;
//  ulong curalloc;
//
//  ulong minarena; /* smallest size of new arena */
//  ulong quantum;  /* allocated blocks should be multiple of */
//  ulong minblock; /* smallest newly allocated block */
//
//  void* freeroot; /* actually Free* */
//  void* arenalist;  /* actually Arena* */
//
//  void* (*alloc)(ulong);
//  int (*merge)(void*, void*);
//  void  (*move)(void* from, void* to);
//
//  int flags;
//  int nfree;
//  int lastcompact;
//
//  void  (*lock)(Pool*);
//  void  (*unlock)(Pool*);
//  void  (*print)(Pool*, char*, ...);
//  void  (*panic)(Pool*, char*, ...);
//  void  (*logstack)(Pool*);
//
//  void* private;
//};

// exported by libc include/pool.h, used by malloc, defined in pool.c in this dir
// memory pools for malloc()/free() (using xalloc pools)
//IMPORTANT: extern Pool*  mainmem;
// memory pools for ??
//IMPORTANT: extern Pool*  imagmem;

<<struct Pallocmem>>

<<function pghash>>

<<struct Palloc>>
extern  Palloc  palloc;

<<constant NFREECHAN>>

<<function ihash>>

<<struct Imagealloc>>

//IMPORTANT: static struct Imagealloc imagealloc; (segment.c)
// so have conf.nimage + 1 Kimages
extern  KImage  swapimage;

<<struct Swapalloc>>
extern struct Swapalloc swapalloc;
@


\subsection*{[[memory/portfns_memory.h]]}

\ifallcode
<<portfns_memory.h>>=

// xalloc.c
void*   xalloc(ulong);
void    xfree(void*);
void    xsummary(void);
int   xmerge(void*, void*);
void    xinit(void);
void*   xspanalloc(ulong, int, ulong);

// pool.c
// see include/pool.h: poollock(), ...
void    mallocsummary(void);

// alloc.c
void*   malloc(ulong);
void    free(void*);
void*   smalloc(ulong);
void*   mallocz(ulong, int);
void*   mallocalign(ulong, ulong, long, ulong);
void*   realloc(void *v, ulong size);
ulong   msize(void*);
void    setmalloctag(void*, ulong);
void    kstrcpy(char*, char*, int);
void    kstrdup(char**, char*);
//void    setrealloctag(void*, ulong);
//ulong   getmalloctag(void*);
//ulong   getrealloctag(void*);

// page.c
void    pageinit(void);
void    pagechainhead(Page*);
void    copypage(Page*, Page*); //TODO: why fp no-deps in codegraph?
void cachepage(Page *p, KImage *i);
void    uncachepage(Page*);
void    cachedel(KImage*, ulong);
Pagetable*    ptalloc(void);
Pagetable*    ptcpy(Pagetable*);
void    freept(Segment*, Pagetable*);
ulong pagenumber(Page*);
Page*   lookpage(KImage*, ulong);
void    putpage(Page*);
Page*   auxpage(void);
Page*   newpage(int, Segment **, ulong);
int   duppage(Page*);
void checkpagerefs(void);
//void    portcountpagerefs(ulong*, int);
//int   hasfreepages(void*);

// swap.c
void    swapinit(void);
void    putswap(Page*);
void    dupswap(Page*);
int   swapcount(ulong);
//int   swapfull(void);
void    pagersummary(void);
void    setswapchan(Chan*);
void    kickpager(void);

// fault.c
Segment*  seg(Proc*, ulong, int);
void checkpages(void);
void    validaddr(ulong, ulong, bool);
int   okaddr(ulong, ulong, int);
int   fixfault(Segment*, ulong, int, int);
void*   vmemchr(virt_addr3, int, int);
int   fault(ulong, int);

// segment.c
Segment*  newseg(int, ulong, ulong);
void    relocateseg(Segment*, ulong);
void    segpage(Segment*, Page*);
void    putimage(KImage*);
void    mfreeseg(Segment*, ulong, int);
void    segclock(ulong);
void    putseg(Segment*);
Segment*  dupseg(Segment**, int, int);
long    ibrk(ulong, int);
int   addphysseg(Physseg*);
//int   isphysseg(char*);
ulong   segattach(Proc*, ulong, char *, ulong, ulong);
void    initimage(void);
KImage*   attachimage(int, Chan*, ulong, ulong);
//Segment*  isoverlap(Proc*, ulong, int);
Segment*  data2txt(Segment*);


// sysfile.c
// syssetflush (used in syscalls/ without requiring extern decl)

// in 386/mmu.c (but used in port)
KMap* kmap(Page*);
void  kunmap(KMap*);
void    countpagerefs(ulong*, int);
void    flushmmu(void);
void checkmmu(ulong va, ulong pa);
ulong cankaddr(ulong);
// actually KADDR is used in port, but it's expanding to kaddr
kern_addr3 kaddr(phys_addr);
// actually PADDR is used in port, but it's expanding to paddr
phys_addr paddr(kern_addr3);
void    putmmu(ulong, ulong, Page*);
void    mmurelease(Proc*);
void    mmuswitch(Proc*);
@
\fi

\subsection*{[[memory/segment.c]]}

\ifallcode
<<segment.c forward decl>>=
static void imagereclaim(void);
static void imagechanreclaim(void);
@
\fi

\ifallcode
<<struct Irstats>>=
struct Irstats {
    int calls;          /* times imagereclaim was called */
    int loops;          /* times the main loop was run */
    uvlong  ticks;          /* total time in the main loop */
    uvlong  maxt;           /* longest time in main loop */
};
@ 

<<segment.c global irstats>>=
static struct Irstats  irstats;
@ 
\fi


<<segment.c>>=
<<kernel basic includes>>
#include "io.h"

//*****************************************************************************
// Global
//*****************************************************************************

<<global imagealloc>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<global physseg>>
<<global physseglock>>

<<hook _globalsegattach>>

<<segment.c forward decl>>

//*****************************************************************************
// Initialization
//*****************************************************************************

<<function initimage>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<constructor newseg>>

<<destructor putseg>>

<<function relocateseg>>

<<function dupseg>>

<<function segpage>>

<<constructor attachimage>>

<<struct Irstats>>
<<segment.c global irstats>>

<<function imagereclaim>>

<<function imagechanreclaim>>

<<destructor putimage>>

<<function ibrk>>

<<function mfreeseg>>

<<function isoverlap>>

<<function addphysseg>>

<<function segattach>>

<<clock callback segclock>>

// was in another file before
<<function data2txt>>
@

%//int
%//isphysseg(char *name)
%//{
%//  Physseg *ps;
%//  int rv = 0;
%//
%//  lock(&physseglock);
%//  for(ps = physseg; ps->name; ps++){
%//      if(strcmp(ps->name, name) == 0){
%//          rv = 1;
%//          break;
%//      }
%//  }
%//  unlock(&physseglock);
%//  return rv;
%//}


\subsection*{[[memory/swap.c]]}

\ifallcode
<<swap.c forward decl>>=
static int  canflush(Proc*, Segment*);
static void executeio(void);
static int  needpages(void*);
static void pageout(Proc*, Segment*);
static void pagepte(int, Page**);
static void pager(void*);
@
\fi


<<swap.c>>=
<<kernel basic includes>>

<<swap.c forward decl>>

<<global iolist>>
<<global ioptr>>

<<global genxxx>>

<<function gentick>>

<<function swapinit>>

<<function newswap>>

<<function putswap>>

<<function dupswap>>

<<function swapcount>>

<<function kickpager>>

<<function pager>>

<<function pageout>>

<<function canflush>>

<<function pagepte>>

<<function pagersummary>>

<<function pageiocomp>>

<<function executeio>>

<<function needpages>>

<<function setswapchan>>

@

%//int
%//swapfull(void)
%//{
%//  return swapalloc.free < conf.nswap/10;
%//}


\subsection*{[[memory/sysmemory.c]]}


<<sysmemory.c>>=
<<kernel basic includes>>

// see also sysbrk in sysproc.c

// those functions used to be in segment.c

<<syscall segflush>>
@

\subsection*{[[memory/xalloc.c]]}

\ifallcode
<<xalloc.c forward decl>>=
void        xhole(ulong, ulong);
@
\fi



<<xalloc.c>>=
<<kernel basic includes>>

<<xalloc.c forward decl>>

//*****************************************************************************
// The global
//*****************************************************************************

<<global xlists>>

//*****************************************************************************
// Initialization
//*****************************************************************************

<<function xinit>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<function xspanalloc>>

<<function xallocz>>

<<function xalloc>>

<<function xfree>>

<<function xmerge>>

<<function xhole>>

//*****************************************************************************
// Debugging
//*****************************************************************************

<<function xsummary>>
@


\section{[[misc/]]}

\subsection*{[[misc/parse.c]]}


<<parse.c>>=
<<kernel basic includes>>

<<ncmdfield>>

<<function parsecmd>>

<<function cmderror>>

<<function lookupcmd>>
@


\subsection*{[[misc/portdat_misc.h]]}


<<portdat_misc.h>>=

<<struct Cmdbuf>>

<<struct Cmdtab>>
@


\subsection*{[[misc/portfns_misc.h]]}

\ifallcode
<<portfns_misc.h>>=

// parse.c
Cmdbuf*   parsecmd(char *a, int n);
Cmdtab*   lookupcmd(Cmdbuf*, Cmdtab*, int);
void    cmderror(Cmdbuf*, char*);

// random.c
void    randominit(void);
ulong   randomread(void*, ulong);

@
\fi

\subsection*{[[misc/random.c]]}


<<random.c>>=
<<kernel basic includes>>

<<struct Rb>>

<<global rb>>

<<struct rbnotfull>>

<<struct rbnotempty>>

<<function genrandom>>

<<clock callback randomclock>>

<<function randominit>>

<<function randomread>>
@


\section{[[processes/]]}

\subsection*{[[processes/386/archgeneric.c]]}

<<archgeneric.c>>=
<<kernel basic includes>>

//todo: weird, if don't include this file, then can't declare arch in this file
// or I get some type signature mismatch
#include "io.h"

/*
 *  the following is a generic version of the
 *  architecture specific stuff
 */

<<function unimplemented>>

<<function archreset>>

<<global archgeneric>>

<<function archrevert>>

@


\subsection*{[[processes/386/dat_processes.h]]}

%/*
% *  things saved in the Proc structure during a notify
% */
%struct ArchProcNotsave
%{
%    ulong svflags;
%    ulong svcs;
%    ulong svss;
%};


<<dat_processes.h>>=

<<constant AOUT_MAGIC>>

//*****************************************************************************
// Proc extensions
//*****************************************************************************

<<union ArchFPSave>>

//*****************************************************************************
// Interrupts
//*****************************************************************************
// Used only in 386/, so could be put in arch/, but used by the .c here.
// Used to be in io.h but more important than just a set of enums for IO
// so put here.

<<enum vector>>

<<enum irq>>
  

<<struct Vctl>>

// array<list<Vctl>>, xalloc'ed
//IMPORTANT: static Vctl *vctl[256]; (in trap.c)

//*****************************************************************************
// Timer
//*****************************************************************************

// Used only in 386/, so could be put in arch/ but used by the .c here.
// Actually used only in i8253.c but important so put here.

<<struct I8253>>

//IMPORTANT: I8253 i8253; (in i8253.c)
//IMPORTANT: also is interrupt i8253clock() calling clock.c:timerintr()
@


\subsection*{[[processes/386/i8253.c]]}

<<struct Watchdog>>=
struct Watchdog
{
    void    (*enable)(void);    /* watchdog enable */
    void    (*disable)(void);   /* watchdog disable */
    void    (*restart)(void);   /* watchdog restart */
    void    (*stat)(char*, char*);  /* watchdog statistics */
};
@

<<global watchdog>>=
Watchdog* watchdog;
int watchdogon;
@

<<function wdogpause>>=
/*
 * if the watchdog is running and we're on cpu 0 and ignoring (clock)
 * interrupts, disable the watchdog temporarily so that the (presumed)
 * long-running loop to follow will not trigger an NMI.
 * wdogresume restarts the watchdog if wdogpause stopped it.
 */
static int
wdogpause(void)
{
    int turndogoff;

    turndogoff = watchdogon && cpu->cpuno == 0 && !islo();
    if (turndogoff) {
        watchdog->disable();
        watchdogon = 0;
    }
    return turndogoff;
}
@


<<function wdogresume>>=
static void
wdogresume(int resume)
{
    if (resume) {
        watchdog->enable();
        watchdogon = 1;
    }
}
@

<<function guesscpuhz>>=
void
guesscpuhz(int aalcycles)
{
    int loops, incr, x, y, dogwason;
    uvlong a, b, cpufreq;

    dogwason = wdogpause();     /* don't get NMI while busy looping */

    /* find biggest loop that doesn't wrap */
    incr = 16000000/(aalcycles*HZ*2);
    x = 2000;
    for(loops = incr; loops < 64*1024; loops += incr) {
    
        /*
         *  measure time for the loop
         *
         *          MOVL    loops,CX
         *  aaml1:      AAM
         *          LOOP    aaml1
         *
         *  the time for the loop should be independent of external
         *  cache and memory system since it fits in the execution
         *  prefetch buffer.
         *
         */
        outb(Tmode, Latch0);
        cycles(&a);
        x = inb(T0cntr);
        x |= inb(T0cntr)<<8;
        aamloop(loops);
        outb(Tmode, Latch0);
        cycles(&b);
        y = inb(T0cntr);
        y |= inb(T0cntr)<<8;
        x -= y;
    
        if(x < 0)
            x += Freq/HZ;

        if(x > Freq/(3*HZ))
            break;
    }
    wdogresume(dogwason);

    /*
     *  figure out clock frequency and a loop multiplier for delay().
     *  n.b. counter goes up by 2*Freq
     */
    if(x == 0)
        x = 1;          /* avoid division by zero on vmware 7 */
    cpufreq = (vlong)loops*((aalcycles*2*Freq)/x);
    cpu->loopconst = (cpufreq/1000)/aalcycles;    /* AAM+LOOP's for 1 ms */

    if(cpu->havetsc && a != b){  /* a == b means virtualbox has confused us */
        /* counter goes up by 2*Freq */
        b = (b-a)<<1;
        b *= Freq;
        b /= x;

        /*
         *  round to the nearest megahz
         */
        cpu->cpumhz = (b+500000)/1000000L;
        cpu->cpuhz = b;
        cpu->cyclefreq = b;
    } else {
        /*
         *  add in possible 0.5% error and convert to MHz
         */
        cpu->cpumhz = (cpufreq + cpufreq/200)/1000000;
        cpu->cpuhz = cpufreq;
    }

    /* don't divide by zero in trap.c */
    if (cpu->cpumhz == 0)
        panic("guesscpuhz: zero cpu->cpumhz");
    i8253.hz = Freq<<Tickshift;
}
@




<<function i8253read>>=
/*
 *  return the total ticks of counter 2.  We shift by
 *  8 to give timesync more wriggle room for interpretation
 *  of the frequency
 */
uvlong
i8253read(uvlong *hz)
{
    ushort y, x;
    uvlong ticks;

    if(hz)
        *hz = i8253.hz;

    ilock(&i8253);
    outb(Tmode, Latch2);
    y = inb(T2cntr);
    y |= inb(T2cntr)<<8;

    if(y < i8253.last)
        x = i8253.last - y;
    else {
        x = i8253.last + (0x10000 - y);
        if (x > 3*MaxPeriod) {
            outb(Tmode, Load2|Square);
            outb(T2cntr, 0);        /* low byte */
            outb(T2cntr, 0);        /* high byte */
            y = 0xFFFF;
            x = i8253.period;
        }
    }
    i8253.last = y;
    i8253.ticks += x>>1;
    ticks = i8253.ticks;
    iunlock(&i8253);

    return ticks<<Tickshift;
}
@

<<[[Cpu]] [[Arch]] other fields>>=
int loopconst;
@

<<function delay>>=
void
i8253_delay(int millisecs)
{
    if (millisecs > 10*1000)
        iprint("delay(%d) from %#p\n", millisecs,
            getcallerpc(&millisecs));
    if (watchdogon && cpu->cpuno == 0 && !islo())
        for (; millisecs > Wdogms; millisecs -= Wdogms) {
            delay(Wdogms);
            watchdog->restart();
        }
    millisecs *= cpu->loopconst;
    if(millisecs <= 0)
        millisecs = 1;
    aamloop(millisecs);
}
@


<<function microdelay>>=
void
i8253_microdelay(int microsecs)
{
    if (watchdogon && cpu->cpuno == 0 && !islo())
        for (; microsecs > Wdogms*1000; microsecs -= Wdogms*1000) {
            delay(Wdogms);
            watchdog->restart();
        }
    microsecs *= cpu->loopconst;
    microsecs /= 1000;
    if(microsecs <= 0)
        microsecs = 1;
    aamloop(microsecs);
}
@




<<i8253.c>>=
<<kernel basic includes>>
#include "io.h"

//*****************************************************************************
// Data
//*****************************************************************************


/*
 *  8253 timer
 */
enum
{
    T0cntr= 0x40,       /* counter ports */
    T1cntr= 0x41,       /* ... */
    T2cntr= 0x42,       /* ... */
    Tmode=  0x43,       /* mode port (control word register) */
    T2ctl=  0x61,       /* counter 2 control port */

    /* commands */
    Latch0= 0x00,       /* latch counter 0's value */
    Load0l= 0x10,       /* load counter 0's lsb */
    Load0m= 0x20,       /* load counter 0's msb */
    Load0=  0x30,       /* load counter 0 with 2 bytes */

    Latch1= 0x40,       /* latch counter 1's value */
    Load1l= 0x50,       /* load counter 1's lsb */
    Load1m= 0x60,       /* load counter 1's msb */
    Load1=  0x70,       /* load counter 1 with 2 bytes */

    Latch2= 0x80,       /* latch counter 2's value */
    Load2l= 0x90,       /* load counter 2's lsb */
    Load2m= 0xa0,       /* load counter 2's msb */
    Load2=  0xb0,       /* load counter 2 with 2 bytes */

    /* 8254 read-back command: everything > pc-at has an 8254 */
    Rdback= 0xc0,       /* readback counters & status */
    Rdnstat=0x10,       /* don't read status */
    Rdncnt= 0x20,       /* don't read counter value */
    Rd0cntr=0x02,       /* read back for which counter */
    Rd1cntr=0x04,
    Rd2cntr=0x08,

    /* modes */
    ModeMsk=0xe,
    Square= 0x6,        /* periodic square wave */
    Trigger=0x0,        /* interrupt on terminal count */
    Sstrobe=0x8,        /* software triggered strobe */

    /* T2ctl bits */
    T2gate= (1<<0),     /* enable T2 counting */
    T2spkr= (1<<1),     /* connect T2 out to speaker */
    T2out=  (1<<5),     /* output of T2 */
};

enum {
    <<constant Freq>>
    Tickshift=8,        /* extra accuracy */
    MaxPeriod=Freq/HZ,
    MinPeriod=Freq/(100*HZ),

    Wdogms  = 200,      /* ms between strokes */
};

<<global i8253>>

<<struct Watchdog>>

<<global watchdog>>


//*****************************************************************************
// Init
//*****************************************************************************

<<function i8253init>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<function wdogpause>>

<<function wdogresume>>

<<function guesscpuhz>>

<<function i8253timerset>>

<<interrupt callback i8253clock>>

<<function i8253enable>>

<<function i8253read>>

<<function delay>>

<<function microdelay>>

<<function perfticks>>
@


\subsection*{[[processes/386/i8259.c]]}


<<i8259.c>>=
<<kernel basic includes>>
#include "io.h"

/*
 *  8259 interrupt controllers
 */
enum
{
    Int0ctl=    0x20,       /* control port (ICW1, OCW2, OCW3) */
    Int0aux=    0x21,       /* everything else (ICW2, ICW3, ICW4, OCW1) */
    Int1ctl=    0xA0,       /* control port */
    Int1aux=    0xA1,       /* everything else (ICW2, ICW3, ICW4, OCW1) */

    Icw1=       0x10,       /* select bit in ctl register */
    Ocw2=       0x00,
    Ocw3=       0x08,

    EOI=        0x20,       /* non-specific end of interrupt */

    Elcr1=      0x4D0,      /* Edge/Level Triggered Register */
    Elcr2=      0x4D1,
};

<<global i8259lock>>
static int i8259mask = 0xFFFF;      /* disabled interrupts */
int i8259elcr;              /* mask of level-triggered interrupts */

<<function i8259init>>

<<function i8259isr>>

<<function i8259enable>>

<<function i8259vecno>>

<<function i8259disable>>

<<function i8259on>>

<<function i8259off>>

@


\subsection*{[[processes/386/l_switch.s]]}

<<l_switch.s>>=

// This file is used for process switching but also to emulate
// exceptions in C (via the waserror(), nexterror(), poperror() functions)

<<function gotolabel>>

<<function setlabel>>
@


\subsection*{[[processes/386/l_trap.s]]}

<<l_trap.s>>=
#include "mem.h"

<<function _strayintr>>

<<function _strayintrx>>

<<function forkret>>

<<global vectortable>>
@


\subsection*{[[processes/386/main_processes.c]]}


<<main_processes.c>>=
<<kernel basic includes>>

<<function procsetup>>

<<function procsave>>

<<function procrestore>>

<<function fpsavealloc>>

<<function fpssesave>>

<<function fpsserestore>>

<<function idlehands>>
@


\subsection*{[[processes/386/trap.c]]}

\ifallcode
<<trap.c forward decl>>=
void    noted(Ureg*, ulong);
int     notify(Ureg*);
void        dumpregs(Ureg*);

static void debugbpt(Ureg*, void*);
static void fault386(Ureg*, void*);
static void doublefault(Ureg*, void*);
static void unexpected(Ureg*, void*);
static void _dumpstack(Ureg*);

extern void checkpages(void);
@ 
//extern void checkfault(ulong, ulong);
\fi


<<function nmienable>>=
static void
nmienable(void)
{
    int x;

    /*
     * Hack: should be locked with NVRAM access.
     */
    outb(0x70, 0x80);       /* NMI latch clear */
    outb(0x70, 0);

    x = inb(0x61) & 0x07;       /* Enable NMI */
    outb(0x61, 0x08|x);
    outb(0x61, x);
}
@ 


<<trap.c>>=
<<kernel basic includes>>

#include    "io.h"

#include    <tos.h>
#include    <ureg.h>
#include    <trace.h>

//*****************************************************************************
// Globals
//*****************************************************************************

<<global trapinited>>

<<global vctllock>>
<<global vctl>>

enum
{
   <<constant Ntimevec>>
};
<<global intrtimes>>

//*****************************************************************************
// Forward decl
//*****************************************************************************
<<trap.c forward decl>>

//*****************************************************************************
// Interrupts enable/disable
//*****************************************************************************

<<function intrenable>>

<<function intrdisable>>

//*****************************************************************************
// Init
//*****************************************************************************

<<function irqallocread>>

<<function trapenable>>

<<function nmienable>>

<<function trapinit0>>

<<function trapinit>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<global excname>>

<<function intrtime>>

<<function kexit>>

<<function trap>>

<<function dumpregs2>>

<<function dumpregs>>

<<function callwithureg>>

<<function _dumpstack>>

<<function dumpstack>>

<<function debugbpt>>

<<function doublefault>>

<<function unexpected>>

<<function fault386>>

//*****************************************************************************
// Syscall
//*****************************************************************************

/*
 *  system calls
 */
#include "../port/systab.h"

<<function syscall>>

<<function notify>>

<<function noted>>

<<function execregs>>

<<function userpc>>

<<function setregisters>>

<<function linkproc>>

<<function kprocchild>>

<<function forkchild>>

<<function setkernur>>

<<function dbgpc>>
@


\subsection*{[[processes/alarm.c]]}

<<alarm.c>>=
<<kernel basic includes>>

<<global alarms>>
<<global alarmr>>

<<kernel process alarmkproc>>

<<function checkalarms>>

<<function procalarm>>
@

\subsection*{[[processes/clock.c]]}


<<clock.c>>=
<<kernel basic includes>>

#include "io.h"

#include <ureg.h>

enum {
   <<constant Maxtimerloops>>
};

<<global timers>>
<<global timersinited>>

<<clock.c statistics>>

<<function tadd>>

<<function tdel>>

<<function timeradd>>

<<function timerdel>>

<<clock callback hzclock>>

<<interrupt callback timerintr>>

<<function timersinit>>

<<function addclock0link>>

<<function tk2ms>>

<<function ms2tk>>
@


\subsection*{[[processes/pgrp.c]]}

<<pgrp.c>>=
// Process group, and Namespace.

<<kernel basic includes>>

enum {
   <<constant Whinesecs>>
};

<<global pgrpid>>
<<global mountid>>

<<function pgrpnote>>

<<constructor newpgrp>>

<<constructor newrgrp>>

<<destructor closergrp>>

<<destructor closepgrp>>

<<function pgrpinsert>>

<<function pgrpcpy>>

<<function dupfgrp>>

<<function closefgrp>>

<<function forceclosefgrp>>

<<constructor newmount>>

<<destructor mountfree>>

<<function resrcwait>>
@


\subsection*{[[processes/portdat_processes.c]]}


<<portdat_processes.c>>=
<<kernel basic includes>>

<<hook proctrace>>
<<hook kproftimer>>

<<global active>>
@


\subsection*{[[processes/portdat_processes.h]]}

\ifallcode
<<portdat_processes.h pragmas>>=
#pragma varargck  type  "t"   long
#pragma varargck  type  "U"   uvlong
@
\fi



<<portdat_processes.h>>=

// in lib.h: Waitmsg, ERRMAX
// see also ArchProcMMU, MAXSYSARG in 386/

//*****************************************************************************
// Proc components
//*****************************************************************************
// All the ref<Proc> here are references to Proc in the array<Proc> of
// Procalloc.arena (pool allocator)

//--------------------------------------------------------------------
// State
//--------------------------------------------------------------------

// TODO: state transition diagram
<<enum procstate>>

// hash<enum<procstate>, string>, to debug
extern  char* statename[];

//--------------------------------------------------------------------
// Memory
//--------------------------------------------------------------------
<<enum procseg>>

//--------------------------------------------------------------------
// Files
//--------------------------------------------------------------------

enum
{
   <<constant DELTAFD>>
};

<<struct Fgrp>>


<<function MOUNTH>>

<<struct Pgrp>>

//--------------------------------------------------------------------
// System call
//--------------------------------------------------------------------

<<struct Sargs>>

//--------------------------------------------------------------------
// Notes
//--------------------------------------------------------------------

enum {
    <<constant NNOTE>>
};

<<enum notekind>>

<<struct Note>>
extern Counter  noteidalloc;

//--------------------------------------------------------------------
// Process children waiting
//--------------------------------------------------------------------

<<struct Waitq>>

//--------------------------------------------------------------------
// Synchronization (Rendez vous)
//--------------------------------------------------------------------

<<function REND>>

<<struct Rgrp>>

//--------------------------------------------------------------------
// Alarms, timers
//--------------------------------------------------------------------

<<enum timermode>>

<<type Txxx>>

<<struct Timer>>

// was in clock.c
<<struct Timers>>

//--------------------------------------------------------------------
// Scheduling
//--------------------------------------------------------------------

enum {
    <<constant Npriq>>
    <<constant Nrq>>
};

<<enum priority>>

<<enum edfflags>>

<<struct Edf>>

//--------------------------------------------------------------------
// Error managment
//--------------------------------------------------------------------
enum {
    <<constant NERR>>
};

//--------------------------------------------------------------------
// Stats, profiling
//--------------------------------------------------------------------
<<enum proctimer>>

//--------------------------------------------------------------------
// Debugger
//--------------------------------------------------------------------

<<enum procctl>>

//--------------------------------------------------------------------
// Misc
//--------------------------------------------------------------------

<<enum fpsavestatus>>

//*****************************************************************************
// Proc, the big one
//*****************************************************************************

<<struct Proc>>

<<macro waserror poperror>>


//*****************************************************************************
// Internal to process/
//*****************************************************************************

// Proc allocator (singleton), was actually in proc.c, but important so here
<<struct Procalloc>>
//IMPORTANT: static struct Procalloc procalloc; (in proc.c)

<<struct Schedq>>
// hash<enum<priority>, Schedq>, Nrq is the number of priority level (20+2)
//IMPORTANT: Schedq  runq[Nrq];  (in proc.c)

// was in alarm.c, but important so here
<<struct Alarms>>
//IMPORTANT: static Alarms alarms; (in alarm.c)
//IMPORTANT: static Rendez alarmr; (in alarm.c)

<<struct Active>>
extern struct Active active;

<<portdat_processes.h pragmas>>

@


\subsection*{[[processes/portfns_processes.h]]}

\ifallcode
<<portfns_processes.h>>=

// tod.c
// initialize the hidden global tod.c#tod
void    todinit(void);
void    todsetfreq(vlong);
void    todset(vlong, vlong, int);
vlong   todget(vlong*);
//uvlong    (*fastticks)(uvlong*); is in 386/devarch.c (but used in port)
uvlong    fastticks2us(uvlong);
uvlong    ns2fastticks(uvlong);
long    seconds(void);
//uvlong    tod2fastticks(vlong);
//uvlong    us2fastticks(uvlong);
//uvlong    ms2fastticks(ulong);
//uvlong    fastticks2ns(uvlong);
//todfix(): TODO false positive, static forward decl

// pgrp.c
Rgrp*   newrgrp(void);
Pgrp*   newpgrp(void);
void    closergrp(Rgrp*);
void    closefgrp(Fgrp*);
Fgrp*   dupfgrp(Fgrp*);
void    closepgrp(Pgrp*);
void    pgrpcpy(Pgrp*, Pgrp*);
void    forceclosefgrp(void);
void    pgrpnote(ulong, char*, long, int);
void    mountfree(Mount*);
Mount*    newmount(Mhead*, Chan*, int, char*);
void    resrcwait(char*);

// portclock.c
ulong   tk2ms(ulong);
#define   TK2MS(x) ((x)*(1000/HZ))
#define   MS2NS(n) (((vlong)(n))*1000000LL)
ulong   ms2tk(ulong);
void    timerdel(Timer*);
void    timeradd(Timer*);
Timer*    addclock0link(void (*)(void), int);
void    timerintr(Ureg*, Tval);
void    timersinit(void);
//void    timerset(Tval); is in 386/devarch.c (but used in port)

// proc.c
void exhausted(char*);
// in portfns_core.h, to remove some backward dependencies
//void    (*sleep)(Rendez*, int(*)(void*), void*);
//int (*postnote)(Proc*, int, char*, int);
void    procctl(Proc*);
void    procwired(Proc*, int);
//Proc*   (*wakeup)(Rendez*);
//void    (*error)(char*);
void    procpriority(Proc*, int, int);
//TODO: fp non-deps twakeup, passed as pointer func
//void    (*nexterror)(void);
//void    (*dumpaproc)(Proc*);
void    accounttime(void);
int   canpage(Proc*);
int   anyhigher(void);
void    scheddump(void);
Proc*   dequeueproc(Schedq*, Proc*);
void   preempt(void);
void    killbig(char*);
//@Scheck: not dead, used in segment.c, weird TODO
void    procflushseg(Segment*); 
void    procdump(void);
void    renameuser(char*, char*);
void    procinit(void);
int   procindex(ulong);
ulong   pwait(Waitmsg*);
//void    (*tsleep)(Rendez*, int (*)(void*), void*, ulong);
void    unbreak(Proc*);
int   freebroken(void);
void    yield(void);
//void    (*pexit)(char*, bool);
//void    (*sched)(void);
void    schedinit(void);
//void    (*ready)(Proc*);
Proc*   newproc(void);
void    kproc(char*, void(*)(void*), void*);
void    hzsched(void);
//not used outside: int   anyready(void);
//TODO cg didn't find ref outside in devproc.c?
int   haswaitq(void*);

// alarm.c
ulong   procalarm(ulong);
void    alarmkproc(void*);
void    checkalarms(void);

// edf.c (used to be declared in edf.h)
Edf*    edflock(Proc*);
void    edfunlock(void);
//TODO fp deadlineintr, static func passed via pointer again
void    edfrun(Proc*, int);
void    edfinit(Proc*);
void    edfrecord(Proc*);
void    edfstop(Proc*);
void    edfyield(void);
int   edfready(Proc*);
char*   edfadmit(Proc*);

// sysproc.c
//@Scheck: not useless, used by misc/rebootcmd.c, weird not recognized by cg
ulong   l2be(long);
// many sysxxx functions (used in syscalls/ without requiring extern decl)




// 386/trap.c (but used in port)
void    callwithureg(void(*)(Ureg*));
ulong   dbgpc(Proc*);
long    execregs(ulong, ulong, ulong);
void    forkchild(Proc*, Ureg*);
ulong   userpc(void);
void    setregisters(Ureg*, char*, char*, int);
void    setkernur(Ureg*, Proc*);
void    kprocchild(Proc*, void (*)(void*), void*);
// intrenable(), but mostly used in 386, just in port/devaudio.c

// 386/main_processes.c (but used in port)
void procsetup(Proc*);
void procsave(Proc*);
void procrestore(Proc *);
void idlehands(void);

// 386/i8253.c (but used in port)
ulong   perfticks(void);

// 386/devarch.c (but used in port)
void    timerset(Tval);
ulong   us(void);

// in 386/l.s (but used in port)
//@Scheck: Assembly
void    gotolabel(Label*);
//@Scheck: Assembly
int   setlabel(Label*);
//@Scheck: Assembly
void    mul64fract(uvlong*, uvlong, uvlong);

// portdat_processes.c
void (*proctrace)(Proc*, int, vlong); // was in devproc.c
void (*kproftimer)(ulong); // was in portfns.h
@
\fi

\subsection*{[[processes/proc.c]]}

\ifallcode
<<proc.c forward decl>>=
Proc* runproc(void);
void updatecpu(Proc*);
int reprioritize(Proc*);

static void pidhash(Proc*);
static void pidunhash(Proc*);
static void rebalance(void);
@

<<proc.c statistics>>=
ulong delayedscheds;    /* statistics */
long skipscheds;
long preempts;
//ulong load;
@ 

\fi



% dead?
<<function tfn>>=
static int
tfn(void *arg)
{
    return up->trend == nil || up->tfn(arg);
}
@ 


<<enum procctl cases>>=
    Proc_exitbig,
@

<<[[procctl()]] Proc_exitbig case>>=
    case Proc_exitbig:
        spllo();
        pexit("Killed: Insufficient physical memory", true);
@

<<function killbig>>=
void
killbig(char *why)
{
    int i;
    Segment *s;
    ulong l, max;
    Proc *p, *ep, *kp;

    max = 0;
    kp = 0;
    ep = procalloc.arena+conf.nproc;
    for(p = procalloc.arena; p < ep; p++) {
        if(p->state == Dead || p->kp)
            continue;
        l = 0;
        for(i=1; i<NSEG; i++) {
            s = p->seg[i];
            if(s != 0)
                l += s->top - s->base;
        }
        if(l > max && ((p->procmode&0222) || strcmp(eve, p->user)!=0)) {
            kp = p;
            max = l;
        }
    }

    print("%lud: %s killed: %s\n", kp->pid, kp->text, why);
    for(p = procalloc.arena; p < ep; p++) {
        if(p->state == Dead || p->kp)
            continue;
        if(p != kp && p->seg[BSEG] && p->seg[BSEG] == kp->seg[BSEG])
            p->procctl = Proc_exitbig;
    }
    kp->procctl = Proc_exitbig;
    for(i = 0; i < NSEG; i++) {
        s = kp->seg[i];
        if(s != 0 && canqlock(&s->lk)) {
            mfreeseg(s, s->base, (s->top - s->base)/BY2PG);
            qunlock(&s->lk);
        }
    }
}
@ 



<<proc.c>>=
<<kernel basic includes>>
#include    <trace.h>

//*****************************************************************************
// Globals
//*****************************************************************************

<<global runq>>
<<global runveq>>

<<global procalloc>>

<<global nrdy>>
<<global noteidalloc>>

<<proc.c statistics>>

<<global pidalloc>>

enum
{
    <<constant Schedagain>>
    <<constant Scaling>>
};

<<global statename>>

<<proc.c forward decl>>

//*****************************************************************************
// Error managment
//*****************************************************************************

// see also waserror() and poperror() macro in portdat_processes.h

<<function error>>

<<function nexterror>>

<<function exhausted>>

//*****************************************************************************
// Functions
//*****************************************************************************

<<function schedinit>>

<<function sched>>

<<function anyready>>

<<function anyhigher>>

<<function hzsched>>

<<function preempt>>

<<function updatecpu>>

<<function reprioritize>>

<<function queueproc>>

<<function dequeueproc>>

<<function ready>>

<<function yield>>

<<global balancetime>>

<<function rebalance>>
    
<<function runproc>>

<<function canpage>>

<<function noprocpanic>>

<<constructor newproc>>

<<function procwired>>

<<function procpriority>>

<<function procinit>>

<<function sleep>>

<<function tfn>>

<<function twakeup>>

<<function tsleep>>

<<function wakeup>>

<<function postnote>>

<<struct Broken>>
<<global broken>>

<<function addbroken>>

<<function unbreak>>

<<function freebroken>>

<<function pexit>>

<<function haswaitq>>

<<function pwait>>

<<function proctab>>

<<function dumpaproc>>

<<function procdump>>

<<function procflushseg>>

<<function scheddump>>

<<function kproc>>

<<function procctl>>

<<function killbig>>

<<function renameuser>>

<<function accounttime>>

<<function pidhash>>

<<function pidunhash>>

<<function procindex>>
@

\subsection*{[[processes/syssema.c]]}


<<syssema.c>>=
<<kernel basic includes>>

/*
 * The implementation of semaphores is complicated by needing
 * to avoid rescheduling in syssemrelease, so that it is safe
 * to call from real-time processes.  This means syssemrelease
 * cannot acquire any qlocks, only spin locks.
 * 
 * Semacquire and semrelease must both manipulate the semaphore
 * wait list.  Lock-free linked lists only exist in theory, not
 * in practice, so the wait list is protected by a spin lock.
 * 
 * The semaphore value *addr is stored in user memory, so it
 * cannot be read or written while holding spin locks.
 * 
 * Thus, we can access the list only when holding the lock, and
 * we can access the semaphore only when not holding the lock.
 * This makes things interesting.  Note that sleep's condition function
 * is called while holding two locks - r and up->rlock - so it cannot
 * access the semaphore value either.
 * 
 * An acquirer announces its intention to try for the semaphore
 * by putting a Sema structure onto the wait list and then
 * setting Sema.waiting.  After one last check of semaphore,
 * the acquirer sleeps until Sema.waiting==0.  A releaser of n
 * must wake up n acquirers who have Sema.waiting set.  It does
 * this by clearing Sema.waiting and then calling wakeup.
 * 
 * There are three interesting races here.  
 
 * The first is that in this particular sleep/wakeup usage, a single
 * wakeup can rouse a process from two consecutive sleeps!  
 * The ordering is:
 * 
 *  (a) set Sema.waiting = 1
 *  (a) call sleep
 *  (b) set Sema.waiting = 0
 *  (a) check Sema.waiting inside sleep, return w/o sleeping
 *  (a) try for semaphore, fail
 *  (a) set Sema.waiting = 1
 *  (a) call sleep
 *  (b) call wakeup(a)
 *  (a) wake up again
 * 
 * This is okay - semacquire will just go around the loop
 * again.  It does mean that at the top of the for(;;) loop in
 * semacquire, phore.waiting might already be set to 1.
 * 
 * The second is that a releaser might wake an acquirer who is
 * interrupted before he can acquire the lock.  Since
 * release(n) issues only n wakeup calls -- only n can be used
 * anyway -- if the interrupted process is not going to use his
 * wakeup call he must pass it on to another acquirer.
 * 
 * The third race is similar to the second but more subtle.  An
 * acquirer sets waiting=1 and then does a final canacquire()
 * before going to sleep.  The opposite order would result in
 * missing wakeups that happen between canacquire and
 * waiting=1.  (In fact, the whole point of Sema.waiting is to
 * avoid missing wakeups between canacquire() and sleep().) But
 * there can be spurious wakeups between a successful
 * canacquire() and the following semdequeue().  This wakeup is
 * not useful to the acquirer, since he has already acquired
 * the semaphore.  Like in the previous case, though, the
 * acquirer must pass the wakeup call along.
 * 
 * This is all rather subtle.  The code below has been verified
 * with the spin model /sys/src/9/port/semaphore.p.  The
 * original code anticipated the second race but not the first
 * or third, which were caught only with spin.  The first race
 * is mentioned in /sys/doc/sleep.ps, but I'd forgotten about it.
 * It was lucky that my abstract model of sleep/wakeup still managed
 * to preserve that behavior.
 *
 * I remain slightly concerned about memory coherence
 * outside of locks.  The spin model does not take 
 * queued processor writes into account so we have to
 * think hard.  The only variables accessed outside locks
 * are the semaphore value itself and the boolean flag
 * Sema.waiting.  The value is only accessed with cmpswap,
 * whose job description includes doing the right thing as
 * far as memory coherence across processors.  That leaves
 * Sema.waiting.  To handle it, we call coherence() before each
 * read and after each write.       - rsc
 */

<<function semqueue>>

<<function semdequeue>>

<<function semwakeup>>

<<function semrelease>>

<<function canacquire>>

<<function semawoke>>

<<function semacquire>>

<<function tsemacquire>>

<<syscall semacquire>>

<<syscall tsemacquire>>

<<syscall semrelease>>

@

\subsection*{[[processes/sysproc.c]]}

\ifallcode
<<sysproc.c forward decl>>=
int shargs(char*, int, char**);
@
\fi


<<sysproc.c>>=
<<kernel basic includes>>

#include    <tos.h>
#include    <a.out.h>

<<enum rfork>>

<<sysproc.c forward decl>>

<<syscall nop>>

<<syscall rfork>>

<<function l2be>>

<<syscall exec>>

<<function shargs>>

<<syscall sleep>>

<<syscall alarm>>

<<syscall exits>>

<<syscall await>>

<<function werrstr>>

<<function generrstr>>

<<syscall errstr>>

<<syscall notify>>

<<syscall noted>>

<<syscall segbrk>>

<<syscall segattach>>

<<syscall segdetach>>

<<syscall segfree>>

<<syscall brk>>

<<syscall rendezvous>>

@


\subsection*{[[processes/tod.c]]}

\ifallcode
<<tod.c forward decl>>=
uvlong      mk64fract(uvlong, uvlong);
static void todfix(void);
@
\fi




%/*
%    int shift;
%
%    if(to == 0ULL)
%        return 0ULL;
%
%    shift = 0;
%    while(shift < 32 && to < (1ULL<<(32+24))){
%        to <<= 8;
%        shift += 8;
%    }
%    while(shift < 32 && to < (1ULL<<(32+31))){
%        to <<= 1;
%        shift += 1;
%    }
%
%    return (to/from)<<(32-shift);
% */


<<tod.c>>=
// TOD: Time Of Day.

<<kernel basic includes>>

<<tod.c forward decl>>

/*
 * Compute nanosecond epoch time from the fastest ticking clock
 * on the system.  Converting the time to nanoseconds requires
 * the following formula
 *
 *  t = (((1000000000<<31)/f)*ticks)>>31
 *
 *  where
 *
 *  'f'     is the clock frequency
 *  'ticks'     are clock ticks
 *
 *  to avoid too much calculation in todget(), we calculate
 *
 *  mult = (1000000000<<32)/f
 *
 *  each time f is set.  f is normally set by a user level
 *  program writing to /dev/fastclock.  mul64fract will then
 *  take that fractional multiplier and a 64 bit integer and
 *  return the resulting integer product.
 *
 *  We assume that the cpu's of a multiprocessor are synchronized.
 *  This assumption needs to be questioned with each new architecture.
 */

/* frequency of the tod clock */
#define TODFREQ     1000000000ULL
#define MicroFREQ   1000000ULL

<<struct TOD>>
<<global tod>>

<<function todinit>>

<<function todsetfreq>>

<<function todset>>

<<function todget>>

<<function todfix>>

<<function seconds>>

<<function fastticks2us>>

<<function ns2fastticks>>

<<function mk64fract>>
@

%/*
% *  convert time of day to ticks
% */
%//uvlong
%//tod2fastticks(vlong ns)
%//{
%//  uvlong x;
%//
%//  ilock(&tod);
%//  mul64fract(&x, ns-tod.off, tod.divider);
%//  x += tod.last;
%//  iunlock(&tod);
%//  return x;
%//}
%
%
%//uvlong
%//us2fastticks(uvlong us)
%//{
%//  uvlong res;
%//
%//  if(!tod.init)
%//      todinit();
%//  mul64fract(&res, us, tod.udivider);
%//  return res;
%//}
%
%///*
%// *  convert milliseconds to fast ticks
%// */
%//uvlong
%//ms2fastticks(ulong ms)
%//{
%//  if(!tod.init)
%//      todinit();
%//  return (tod.hz*ms)/1000ULL;
%//}
%
%
%///*
%// *  convert fast ticks to ns
%// */
%//uvlong
%//fastticks2ns(uvlong ticks)
%//{
%//  uvlong res;
%//
%//  if(!tod.init)
%//      todinit();
%//  mul64fract(&res, ticks, tod.multiplier);
%//  return res;
%//}

\section{[[security/]]}

\subsection*{[[security/auth.c]]}

<<auth.c>>=
<<kernel basic includes>>

#include    <authsrv.h>

//char  *eve; now in core/
//int iseve(void) { } now in core/

<<global hostdomain>>

<<syscall fversion>>

<<syscall fauth>>

<<function userwrite>>

<<function hostownerwrite>>

<<function hostdomainwrite>>
@

\subsection*{[[security/portfns_security.h]]}


\ifallcode
<<portfns_security.h>>=

// auth.c
long    userwrite(char*, int);
long    hostdomainwrite(char*, int);
long    hostownerwrite(char*, int);

// and some sysxxx functions
@
\fi

\section{[[syscalls/]]}

\subsection*{[[syscalls/386/plan9l.s]]}

<<plan9l.s>>=
#include "mem.h"

<<function touser>>

<<function _syscallintr>>
@


\subsection*{[[syscalls/syscallfmt.c]]}

<<syscallfmt.c>>=
/*
 * Print functions for system call tracing.
 */
<<kernel basic includes>>

#include "../port/systab.h"

<<function fmtrwdata>>

<<function fmtuserstring>>

<<function syscallfmt>>

<<function sysretfmt>>
@


\subsection*{[[syscalls/systab.c]]}

\ifallcode
<<systab.c forward decl>>=
extern Syscall sysnop;
extern Syscall sysbind;
extern Syscall syschdir;
extern Syscall sysclose;
extern Syscall sysdup;
extern Syscall sysalarm;
extern Syscall sysexec;
extern Syscall sysexits;
extern Syscall sysfauth;
extern Syscall syssegbrk;
extern Syscall sysopen;
extern Syscall syssleep;
extern Syscall sysrfork;
extern Syscall syspipe;
extern Syscall syscreate;
extern Syscall sysfd2path;
extern Syscall sysbrk;
extern Syscall sysremove;
extern Syscall sysnotify;
extern Syscall sysnoted;
extern Syscall syssegattach;
extern Syscall syssegdetach;
extern Syscall syssegfree;
extern Syscall syssegflush;
extern Syscall sysrendezvous;
extern Syscall sysunmount;
extern Syscall syssemacquire;
extern Syscall syssemrelease;
extern Syscall sysseek;
extern Syscall sysfversion;
extern Syscall syserrstr;
extern Syscall sysstat;
extern Syscall sysfstat;
extern Syscall syswstat;
extern Syscall sysfwstat;
extern Syscall sysmount;
extern Syscall sysawait;
extern Syscall syspread;
extern Syscall syspwrite;
extern Syscall systsemacquire;
//@Scheck: TODO? dead?
extern Syscall sysdeath;
@
\fi

\ifallcode
<<global sysstab>>=
char *sysctab[] = {
    [NOP]     "Nop",
    [BIND]      "Bind",
    [CHDIR]     "Chdir",
    [CLOSE]     "Close",
    [DUP]       "Dup",
    [ALARM]     "Alarm",
    [EXEC]      "Exec",
    [EXITS]     "Exits",
    [FAUTH]     "Fauth",
    [SEGBRK]    "Segbrk",
    [OPEN]      "Open",
    [SLEEP]     "Sleep",
    [RFORK]     "Rfork",
    [PIPE]      "Pipe",
    [CREATE]    "Create",
    [FD2PATH]   "Fd2path",
    [BRK]      "Brk",
    [REMOVE]    "Remove",
    [NOTIFY]    "Notify",
    [NOTED]     "Noted",
    [SEGATTACH] "Segattach",
    [SEGDETACH] "Segdetach",
    [SEGFREE]   "Segfree",
    [SEGFLUSH]  "Segflush",
    [RENDEZVOUS]    "Rendez",
    [UNMOUNT]   "Unmount",
    [SEMACQUIRE]    "Semacquire",
    [SEMRELEASE]    "Semrelease",
    [SEEK]      "Seek",
    [FVERSION]  "Fversion",
    [ERRSTR]    "Errstr",
    [STAT]      "Stat",
    [FSTAT]     "Fstat",
    [WSTAT]     "Wstat",
    [FWSTAT]    "Fwstat",
    [MOUNT]     "Mount",
    [AWAIT]     "Await",
    [PREAD]     "Pread",
    [PWRITE]    "Pwrite",
    [TSEMACQUIRE]   "Tsemacquire",
};
@
\fi

<<systab.c>>=
<<kernel basic includes>>

#include "../port/systab.h"

<<systab.c forward decl>>

//coupling: debuggers/acid/conf/syscall
//coupling: debuggers/acid/conf/truss
<<global systab>>

<<global sysstab>>
@

\subsection*{[[syscalls/systab.h]]}


%------------------------------------------------------------------------
%------------------------------------------------------------------------
%------------------------------------------------------------------------
%------------------------------------------------------------------------

\ifallcode
\chapter{Extra Extra}

\section{SMP}


\section{Advanced virtual memory}

% large memory system: vpt/vpd, tmpmap, kmap
% other: vmap? for devices? framebuffer related?
% 9atom also provides patches for PAE support and amd64 support

\subsection{Page coloring}
% page coloring, getpgcolor, cachectl, etc
% but I've removed the code actually

\subsection{Cache line}

%#define CACHELINESZ 32      /* pentium & later */

\subsection{Extra segment types}

<<enum segtype other cases>>=
    SG_SHARED = 04,
@


<<enum segtype other cases>>=
    SG_PHYSICAL = 05,
@
% SG_PHYSICAL used only for vga/vesa apparently


<<struct Physseg>>=
struct Physseg
{
    ulong attr;     /* Segment attributes */
    char  *name;      /* Attach name */
    phys_addr pa;     /* Physical address */
    ulong size;     /* Maximum segment size in pages */
};
@
%    // seems dead, not even used by vga.c
%    Page  *(*pgalloc)(Segment*, ulong); /* Allocation if we need it */
%    void  (*pgfree)(Page*);


<<[[Segment]] other fields>>=
Physseg *pseg;
@


<<global physseg>>=
/*
 * Attachable segment types
 */
static Physseg physseg[10] = {
    { .attr= SG_SHARED, 
      .name= "shared", 
      .pa= 0,
      .size= SEGMAXSIZE, 
    },
    { .attr= SG_BSS, 
      .name= "memory", 
      .pa = 0,
      .size = SEGMAXSIZE, 
    },
    { 0, 0, 0, 0},
};
@

<<global physseglock>>=
static Lock physseglock;
@

% used by vga.c
<<function addphysseg>>=
int
addphysseg(Physseg* new)
{
    Physseg *ps;

    /*
     * Check not already entered and there is room
     * for a new entry and the terminating null entry.
     */
    lock(&physseglock);
    for(ps = physseg; ps->name; ps++){
        if(strcmp(ps->name, new->name) == 0){
            unlock(&physseglock);
            return -1;
        }
    }
    if(ps-physseg >= nelem(physseg)-2){
        unlock(&physseglock);
        return -1;
    }

    *ps = *new;
    unlock(&physseglock);

    return 0;
}
@



<<[[freept()]] SG_PHYSICAL case>>=
    case SG_PHYSICAL:
        ptop = &p->pagetab[PAGETABSIZE];
        for(pte = p->pagetab; pte < ptop; pte++) {
            pt = *pte;
            if(pt == nil)
                continue;
            lock(pt);
            ref = --pt->ref;
            unlock(pt);
            if(ref == 0)
                free(pt); // because was smalloc'ed in fixfault
        }
        break;
@

<<[[fixfault()]] SG_PHYSICAL case>>=
    case SG_PHYSICAL:
        if(*pte == nil) {
            new = smalloc(sizeof(Page));
            new->va = addr;
            new->pa = s->pseg->pa+(addr-s->base);
            new->ref = 1;
            *pte = new;
        }

        if (checkaddr && addr == addr2check)
            (*checkaddr)(addr, s, *pte);
        mmupte = PPN((*pte)->pa) |PTEWRITE|PTEUNCACHED|PTEVALID;
        (*pte)->modref = PG_MOD|PG_REF;
        break;
@

\subsection{[[vpt]], [[vpd]]}

% tricks apparently borrowed from exokernel code.
% see the toplevel comment in mmu.c
% essentially just tricks abusing the long page feature of x86 to make
% it easy to map and then edit physical content of page tables or
% page directory per process.

<<constant VPTSIZE>>=
#define VPTSIZE 0
@

<<constant VPT>>=
@

<<global vpt and vpd>>=
@

<<[[mmuinit()]] vpt adjusments>>=
@


<<[[mmupdalloc()]] vpt adjustments>>=
@
% the page->va used to be just after newpage() in mmupdalloc, not sure it matters




<<[[checkmmu()]] pd at pt check>>=
//    if(!(vpd[PDX(va)]&PTEVALID) || !(vpt[VPTX(va)]&PTEVALID))
//        return;
//    if(PPN(vpt[VPTX(va)]) != pa)
//        print("%ld %s: va=%#08lux pa=%#08lux pte=%#08lux\n",
//            up->pid, up->text,
//            va, pa, vpt[VPTX(va)]);
@

<<[[vmapsync()]] va set to entry>>=
// pad's code for simplified virtual memory, no VPT
if(up == nil) {
    return 0;
} else {
   if(up->mmupd == nil)
       upallocmmupd();
    mmupd = KADDR(up->mmupd->pa);
    mmupd[PDX(va)] = pde;
}
@

%-------------------------------------------------------------------------

<<constant VPTSIZETODO>>=
#define VPTSIZE   BY2XPG
@
% 4Mo because potentially a full page dir + page tables for 4Go
% can take 4Mo (1pagedir + 1024 page table = 1025 * 4Ko = 4Mo


<<constant VPTTODO>>=
#define VPT   (KZERO-VPTSIZE)
@


<<global vpt and vpdTODO>>=
#define vpt ((ulong*)VPT)
#define VPTX(va)        (((ulong)(va))>>12)
#define vpd (vpt+VPTX(VPT))
@

<<[[mmuinit()]] vpt adjusmentsTODO>>=
    cpu->pdproto[PDX(VPT)] = PADDR(cpu->pdproto)|PTEWRITE|PTEVALID; // setup VPT
@


<<[[mmupdalloc()]] vpt adjustmentsTODO>>=
        page->va = (ulong)vpd; // needed? not part of a segment anyway no?
        mmupd[PDX(VPT)] = page->pa|PTEWRITE|PTEVALID; /* set up VPT */
@
% the page->va used to be just after newpage() in mmupdalloc, not sure it matters


<<[[putmmu()]] adjustmentsTODO>>=
    /*
     * We should be able to get through this with interrupts
     * turned on (if we get interrupted we'll just pick up 
     * where we left off) but we get many faults accessing
     * vpt[] near the end of this function, and they always happen
     * after the process has been switched out and then 
     * switched back, usually many times in a row (perhaps
     * it cannot switch back successfully for some reason).
     * 
     * In any event, I'm tired of searching for this bug.  
     * Turn off interrupts during putmmu even though
     * we shouldn't need to.        - rsc
     */
    
    s = splhi();
    if(!(vpd[PDX(va)]&PTEVALID)){
        if(up->mmufree == nil){
            spllo();
            page = newpage(false, nil, nilptr);
            splhi();
        }
        else{
            page = up->mmufree;
            up->mmufree = page->next;
        }
        vpd[PDX(va)] = PPN(page->pa)|PTEUSER|PTEWRITE|PTEVALID;
        /* page is now mapped into the VPT - clear it */
        memset((void*)(VPT+PDX(va)*BY2PG), 0, BY2PG);
        page->daddr = PDX(va); // ???
        page->next = up->mmuused;
        up->mmuused = page;
    }

    old = vpt[VPTX(va)];
    vpt[VPTX(va)] = pa|PTEUSER|PTEVALID;

    if(old&PTEVALID)
        flushpg(va);
    if(getcr3() != up->mmupd->pa)
        print("bad cr3 %#.8lux %#.8lux\n", getcr3(), up->mmupd->pa);
    splx(s);
@


<<[[checkmmu()]] pd at pt checkTODO>>=
    if(!(vpd[PDX(va)]&PTEVALID) || !(vpt[VPTX(va)]&PTEVALID))
        return;
    if(PPN(vpt[VPTX(va)]) != pa)
        print("%ld %s: va=%#08lux pa=%#08lux pte=%#08lux\n",
            up->pid, up->text,
            va, pa, vpt[VPTX(va)]);
@


<<[[vmapsync()]] va set to entryTODO>>=
    vpd[PDX(va)] = entry;
@

% in mmuinit
%    //if(0) print("vpt=%#.8ux vpd=%#p kmap=%#.8ux\n", VPT, vpd, KMAP);




\subsection{[[tmpmap()]]}

<<constant TMPADDR>>=
@

<<function tmpmap>>=
virt_addr3
tmpmap(Page *p)
{
    if(islo())
        panic("tmpmap: islo");
    if(p->pa < MAXKPA)
        return KADDR(p->pa);
    else
      panic("tmpmap: physical address too high");
}
@

<<function tmpunmap>>=
void
tmpunmap(virt_addr3 v)
{
    if(islo())
        panic("tmpmap: islo");
    if((ulong)v >= KZERO)
        return;
    panic("tmpmap: physical address too high");
}
@


%-------------------------------------------------------------

<<constant TMPADDRTODO>>=
#define TMPADDR   (KZERO+0x2000)    /* used for temporary mappings */
@

<<function tmpmapTODO>>=
virt_addr3
tmpmap(Page *p)
{
    ulong i;
    ulong *entry;
    
    if(islo())
        panic("tmpaddr: islo");

    if(p->pa < MAXKPA)
        return KADDR(p->pa);



    /*
     * PDX(TMPADDR) == PDX(CPUADDR), so this
     * entry is private to the processor and shared 
     * between up->mmupd (if any) and cpu->pd.
     */
    entry = &vpt[VPTX(TMPADDR)];
    if(!(*entry&PTEVALID)){
        for(i=KZERO; i<=CPU0CPU; i+=BY2PG)
            print("%#p: *%#p=%#p (vpt=%#p index=%#p)\n", i, &vpt[VPTX(i)], vpt[VPTX(i)], vpt, VPTX(i));
        panic("tmpmap: no entry");
    }
    if(PPN(*entry) != PPN(TMPADDR-KZERO))
        panic("tmpmap: already mapped entry=%#.8lux", *entry);
    *entry = p->pa|PTEWRITE|PTEVALID;
    flushpg(TMPADDR);
    return (virt_addr3)TMPADDR;
}
@
%PPN = pure page number

<<function tmpunmapTODO>>=
void
tmpunmap(virt_addr3 v)
{
    ulong *entry;
    
    if(islo())
        panic("tmpaddr: islo");
    if((ulong)v >= KZERO && v != (void*)TMPADDR)
        return;

    if(v != (void*)TMPADDR)
        panic("tmpunmap: bad address");

    entry = &vpt[VPTX(TMPADDR)];
    if(!(*entry&PTEVALID) || PPN(*entry) == PPN(PADDR(TMPADDR)))
        panic("tmpmap: not mapped entry=%#.8lux", *entry);
    *entry = PPN(TMPADDR-KZERO)|PTEWRITE|PTEVALID;
    flushpg(TMPADDR);
}
@



\subsection{[[kmap()]]}

<<struct KMap>>=
/*
 * KMap the structure doesn't exist, but the functions do.
 */
typedef struct KMap   KMap;
@
% why not void like in bcm?

<<function kmapinval>>=
#define kmapinval()
@

<<macro VA>>=
#define VA(k)   ((virt_addr3)(k))
@



<<constant KMAPSIZE>>=
#define KMAPSIZE 0
@
<<constant KMAP>>=
#define KMAP KZERO
@

<<global kpt>>=
@

<<constant NKPT>>=
@


% start of differences and simplificiations
<<function kmap>>=
KMap*
kmap(Page *p)
{
    if(up == nil)
        panic("kmap: up=0 pc=%#.8lux", getcallerpc(&p));
    if(p->pa < MAXKPA)
        return KADDR(p->pa);
    else
      panic("kmap: physical address too high");
}
@

<<function kunmap>>=
void
kunmap(KMap *k)
{
    ulong va;
    va = (ulong)k;
    flushpg(va); // not sure we need that

    if((ulong)va >= KZERO)
        return;
    panic("kunmap: physical address too high");
}
@


<<[[mmurelease()]] handle kmaptable>>=
@

<<[[countpagerefs()]] handle kmaptable>>=
@


% -----------------------------------------------------------------------

<<constant KMAPSIZETODO>>=
#define KMAPSIZE  BY2XPG
@

<<constant KMAPTODO>>=
#define KMAP    (VPT-KMAPSIZE)
@

<<global kptTODO>>=
#define kpt (vpt+VPTX(KMAP))
@
<<constant NKPTTODO>>=
#define NKPT (KMAPSIZE/BY2PG)
@


<<[[Proc]] [[Arch]] memory fieldsTODO>>=
Page* kmaptable;    /* page table used by kmap */
uint  lastkmap;   /* last entry used by kmap */
int nkmap;      /* number of current kmaps */
@

<<[[countpagerefs()]] handle kmaptableTODO>>=
        if(p->kmaptable){
            if(print){
                if(ref[pagenumber(p->kmaptable)])
                    iprint("page %#.8lux is proc %d (pid %lud) kmaptable\n",
                        p->kmaptable->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(p->kmaptable)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is proc %d (pid %lud) kmaptable but has other refs!\n",
                    p->kmaptable->pa, i, p->pid);
        }

@

<<[[mmurelease()]] handle kmaptableTODO>>=
    if(proc->kmaptable){
        if(proc->mmupd == nil)
            panic("mmurelease: no mmupd");
        if(--proc->kmaptable->ref)
            panic("mmurelease: kmap ref %d", proc->kmaptable->ref);
        if(proc->nkmap)
            panic("mmurelease: nkmap %d", proc->nkmap);
        /*
         * remove kmaptable from pd before putting pd up for reuse.
         */
        mmupd = tmpmap(proc->mmupd);
        if(PPN(mmupd[PDX(KMAP)]) != proc->kmaptable->pa)
            panic("mmurelease: bad kmap pde %#.8lux kmap %#.8lux",
                mmupd[PDX(KMAP)], proc->kmaptable->pa);
        mmupd[PDX(KMAP)] = 0;
        tmpunmap(mmupd);
        /*
         * move kmaptable to free list.
         */
        pagechainhead(proc->kmaptable);
        proc->kmaptable = nil;
    }
@


<<function kmapTODO>>=
KMap*
kmap(Page *page)
{
    int i, o, s;

    if(up == nil)
        panic("kmap: up=0 pc=%#.8lux", getcallerpc(&page));
    if(up->mmupd == nil)
        upallocmmupd();
    if(up->nkmap < 0)
        panic("kmap %lud %s: nkmap=%d", up->pid, up->text, up->nkmap);
    
    /*
     * Splhi shouldn't be necessary here, but paranoia reigns.
     * See comment in putmmu above.
     */
    s = splhi();
    up->nkmap++;
    if(!(vpd[PDX(KMAP)]&PTEVALID)){
        /* allocate page directory */
        if(KMAPSIZE > BY2XPG)
            panic("bad kmapsize");
        if(up->kmaptable != nil)
            panic("kmaptable");
        spllo();
        up->kmaptable = newpage(0, 0, 0);
        splhi();
        vpd[PDX(KMAP)] = up->kmaptable->pa|PTEWRITE|PTEVALID;
        flushpg((ulong)kpt);
        memset(kpt, 0, BY2PG);
        kpt[0] = page->pa|PTEWRITE|PTEVALID;
        up->lastkmap = 0;
        splx(s);
        return (KMap*)KMAP;
    }
    if(up->kmaptable == nil)
        panic("no kmaptable");
    o = up->lastkmap+1;
    for(i=0; i<NKPT; i++){
        if(kpt[(i+o)%NKPT] == 0){
            o = (i+o)%NKPT;
            kpt[o] = page->pa|PTEWRITE|PTEVALID;
            up->lastkmap = o;
            splx(s);
            return (KMap*)(KMAP+o*BY2PG);
        }
    }
    panic("out of kmap");
    return nil;
}
@


<<function kunmapTODO>>=
void
kunmap(KMap *k)
{
    ulong va;

    va = (ulong)k;
    if(up->mmupd == nil || !(vpd[PDX(KMAP)]&PTEVALID))
        panic("kunmap: no kmaps");
    if(va < KMAP || va >= KMAP+KMAPSIZE)
        panic("kunmap: bad address %#.8lux pc=%#p", va, getcallerpc(&k));
    if(!(vpt[VPTX(va)]&PTEVALID))
        panic("kunmap: not mapped %#.8lux pc=%#p", va, getcallerpc(&k));
    up->nkmap--;
    if(up->nkmap < 0)
        panic("kunmap %lud %s: nkmap=%d", up->pid, up->text, up->nkmap);
    vpt[VPTX(va)] = 0;
    flushpg(va);
}
@


\subsection{[[vmap()]]}

% used to map framebuffer for instance. the vga driver uses it!

<<constant VMAP>>=
#define VMAP    (KMAP-VMAPSIZE)
@

<<constant VMAPSIZE>>=
#define VMAPSIZE  (0x10000000-VPTSIZE-KMAPSIZE)
@
% 256Mo, enough for big framebuffers!

% actually this is independent of vpt, tmpmap, kmap

<<global vmaplock>>=
static Lock vmaplock;
@


<<function vmap>>=
/*
 * Add a device mapping to the vmap range.
 */
virt_addr3
vmap(phys_addr pa, int size)
{
    int osize;
    virt_addr va;
    ulong o;
    
    /*
     * might be asking for less than a page.
     */
    osize = size;
    o = pa & (BY2PG-1);
    pa -= o;
    size += o;

    size = ROUND(size, BY2PG);
    if(pa == 0){
        print("vmap pa=0 pc=%#p\n", getcallerpc(&pa));
        return nil;
    }
    ilock(&vmaplock);
    if((va = vmapalloc(size)) == 0 
    || pdmap(CPUS(0)->pdproto, pa|PTEUNCACHED|PTEWRITE, va, size) < 0){
        iunlock(&vmaplock);
        return nil;
    }
    iunlock(&vmaplock);
    /* avoid trap on local processor
    for(i=0; i<size; i+=4*MB)
        vmapsync(va+i);
    */
    USED(osize);
//  print("  vmap %#.8lux %d => %#.8lux\n", pa+o, osize, va+o);
    return (void*)(va + o);
}
@

<<function pdmap>>=
/*
 * Add kernel mappings for pa -> va for a section of size bytes.
 */
int
pdmap(kern_addr2 mmupd, ulong pa, virt_addr va, int size)
{
    bool pse;
    ulong pgsz;
    kern_addr2 pte, pde;
    ulong flag, off;
    
    flag = pa&0xFFF;
    pa &= ~0xFFF;

    if((CPUS(0)->cpuiddx & Pse) && (getcr4() & 0x10))
        pse = true;
    else
        pse = false;

    for(off=0; off<size; off+=pgsz){
        pde = &mmupd[PDX(va+off)];
        if((*pde&PTEVALID) && (*pde&PTESIZE))
            panic("vmap: va=%#.8lux pa=%#.8lux pde=%#.8lux",
                va+off, pa+off, *pde);

        /*
         * Check if it can be mapped using a 4MB page:
         * va, pa aligned and size >= 4MB and processor can do it.
         */
        if(pse && (pa+off)%(4*MB) == 0 && (va+off)%(4*MB) == 0 && (size-off) >= 4*MB){
            *pde = (pa+off)|flag|PTESIZE|PTEVALID;
            pgsz = 4*MB;
        }else{
            pte = mmuwalk(mmupd, va+off, 2, true);
            if(*pte&PTEVALID)
                panic("vmap: va=%#.8lux pa=%#.8lux pte=%#.8lux",
                    va+off, pa+off, *pte);
            *pte = (pa+off)|flag|PTEVALID;
            pgsz = BY2PG;
        }
    }
    return 0;
}
@



<<function findhole>>=
static int
findhole(ulong *a, int n, int count)
{
    int have, i;
    
    have = 0;
    for(i=0; i<n; i++){
        if(a[i] == 0)
            have++;
        else
            have = 0;
        if(have >= count)
            return i+1 - have;
    }
    return -1;
}
@



<<function vmapalloc>>=
/*
 * Look for free space in the vmap.
 */
static virt_addr
vmapalloc(ulong size)
{
    int i, n, o;
    // this is really a page directory base, that spans a range of pdes
    // starting to map from VMAP to VMAP+VMAPSIZE
    kern_addr2 vpdb;
    int vpdsize;
    
    vpdb = &CPUS(0)->pdproto[PDX(VMAP)];
    vpdsize = VMAPSIZE/(4*MB);

    if(size >= 4*MB){
        n = (size+4*MB-1) / (4*MB);
        if((o = findhole(vpdb, vpdsize, n)) != -1)
            return VMAP + o*4*MB;
        return nilptr;
    }

    // size <= 4MB
    n = (size+BY2PG-1) / BY2PG;
    for(i=0; i<vpdsize; i++)
        if((vpdb[i]&PTEVALID) && !(vpdb[i]&PTESIZE))
            if((o = findhole(KADDR(PPN(vpdb[i])), WD2PG, n)) != -1)
                return VMAP + i*4*MB + o*BY2PG;

    if((o = findhole(vpdb, vpdsize, 1)) != -1)
        return VMAP + o*4*MB;
        
    /*
     * could span page directory entries, but not worth the trouble.
     * not going to be very much contention.
     */
    return nilptr;
}
@

<<function vunmap>>=
/*
 * Remove a device mapping from the vmap range.
 * Since pdunmap does not remove page tables, just entries,
 * the call need not be interlocked with vmap.
 */
void
vunmap(virt_addr3 v, int size)
{
    int i;
    virt_addr va;
    ulong o;
    Cpu *nm;
    Proc *p;
    
    /*
     * might not be aligned
     */
    va = (virt_addr)v;
    o = va&(BY2PG-1);
    va -= o;
    size += o;
    size = ROUND(size, BY2PG);
    
    if(size < 0 || va < VMAP || va+size > VMAP+VMAPSIZE)
        panic("vunmap va=%#.8lux size=%#x pc=%#.8lux",
            va, size, getcallerpc(&v));

    pdunmap(CPUS(0)->pdproto, va, size);
    
    /*
     * Flush mapping from all the tlbs and copied pds.
     * This can be (and is) slow, since it is called only rarely.
     * It is possible for vunmap to be called with up == nil,
     * e.g. from the reset/init driver routines during system
     * boot. In that case it suffices to flush the CPUS(0) TLB
     * and return.
     */
    if(!active.main_reached_sched){
        putcr3(PADDR(CPUS(0)->pdproto));
        return;
    }
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        if(p->state == Dead)
            continue;
        if(p != up)
            p->newtlb = true;
    }
    for(i=0; i<conf.ncpu; i++){
        nm = CPUS(i);
        if(nm != cpu)
            nm->flushmmu = true;
    }
    flushmmu();
    for(i=0; i<conf.ncpu; i++){
        nm = CPUS(i);
        if(nm != cpu)
            while((active.cpus&(1<<nm->cpuno)) && nm->flushmmu)
                ;
    }
}
@
% >>

<<function pdunmap>>=
/*
 * Remove mappings.  Must already exist, for sanity.
 * Only used for kernel mappings, so okay to use KADDR.
 */
static void
pdunmap(kern_addr2 mmupd, virt_addr va, int size)
{
    virt_addr vae;
    kern_addr2 pde, pte;
    
    vae = va+size;
    while(va < vae){
        pde = &mmupd[PDX(va)];
        if(!(*pde & PTEVALID)){
            panic("vunmap: not mapped");
            /* 
            va = (va+4*MB-1) & ~(4*MB-1);
            continue;
            */
        }
        if(*pde & PTESIZE){
            *pde = 0;
            va = (va+4*MB-1) & ~(4*MB-1);
            continue;
        }
        pte = KADDR(PPN(*pde));
        if(!(pte[PTX(va)] & PTEVALID))
            panic("vunmap: not mapped");
        pte[PTX(va)] = 0;
        va += BY2PG;
    }
}
@

<<function vmapsync>>=
/*
 * Handle a fault by bringing vmap up to date.
 * Only copy pd entries and they never go away,
 * so no locking needed.
 */
int
vmapsync(virt_addr va)
{
    ulong pde;
    kern_addr2 mmupt;
    kern_addr2 mmupd;

    if(va < VMAP || va >= VMAP+VMAPSIZE)
        return 0;

    pde = CPUS(0)->pdproto[PDX(va)];
    if(!(pde&PTEVALID))
        return 0;
    if(!(pde&PTESIZE)){
        /* make sure entry will help the fault */
        mmupt = KADDR(PPN(pde));
        if(!(mmupt[PTX(va)]&PTEVALID))
            return 0;
    }
    <<[[vmapsync()]] va set to entry>>
    /*
     * TLB doesn't cache negative results, so no flush needed.
     */
    return 1;
}
@

\subsection{Big pages }

% pse? see code in vmap, could aspectize things
% also does vpt/vpd uses this feature? I don't think so.


\section{EDF}
% real time scheduling

<<constants for real-time priority>>=
    PriRelease  = Npriq,  /* released edf processes */
    PriEdf    = Npriq+1,  /* active edf processes */
    PriExtra  = Npriq-1,  /* edf processes at high best-effort pri */
@

<<[[runproc()]] test for empty real-time scheduling queue>>=
runq[Nrq-1].head == nil && runq[Nrq-2].head == nil
@

<<[[runproc()]] test if p is a real-time process>>=
    if(edflock(p)){
        edfrun(p, rq == &runq[PriEdf]); /* start deadline timer and do admin */
        edfunlock();
    }
@

<<[[schedinit()]] optional real-time [[edfrecord()]]>>=
        if((e = up->edf) && (e->flags & Admitted))
            edfrecord(up);
@

<<[[schedinit()]] optional real-time [[edfstop()]]>>=
            edfstop(up);
            if (up->edf)
                free(up->edf);
            up->edf = nil;
@

<<[[ready()]] optional [[edfready()]] for real-time scheduling>>=
    if(edfready(p)){
        splx(s);
        return;
    }
@


<<[[syssleep()]] optional [[edfyield()]] for real-time scheduling>>=
        if (up->edf && (up->edf->flags & Admitted))
            edfyield();
        else
@

<<[[procctlreq()]] optional real-time commands>>=
    /* real time */
    case CMperiod:
        if(p->edf == nil)
            edfinit(p);
        if(e=parsetime(&time, cb->f[1]))    /* time in ns */
            error(e);
        edfstop(p);
        p->edf->T = time/1000;  /* Edf times are in microseconds */
        break;
    case CMdeadline:
        if(p->edf == nil)
            edfinit(p);
        if(e=parsetime(&time, cb->f[1]))
            error(e);
        edfstop(p);
        p->edf->D = time/1000;
        break;
    case CMcost:
        if(p->edf == nil)
            edfinit(p);
        if(e=parsetime(&time, cb->f[1]))
            error(e);
        edfstop(p);
        p->edf->C = time/1000;
        break;
    case CMsporadic:
        if(p->edf == nil)
            edfinit(p);
        p->edf->flags |= Sporadic;
        break;
    case CMdeadlinenotes:
        if(p->edf == nil)
            edfinit(p);
        p->edf->flags |= Sendnotes;
        break;
    case CMadmit:
        if(p->edf == 0)
            error("edf params");
        if(e = edfadmit(p))
            error(e);
        break;
    case CMextra:
        if(p->edf == nil)
            edfinit(p);
        p->edf->flags |= Extratime;
        break;
    case CMexpel:
        if(p->edf)
            edfstop(p);
        break;

@

<<[[sched()]] optional guard for real-time process>>=
    if(!p->edf)
@

<<[[pexit()]] optional [[edfstop()]] for real-time scheduling>>=
    edfstop(up);
@


<<[[Proc]] scheduling fields>>=
<<[[Proc]] optional [[edf]] field for real-time scheduling>>
@ 

% seems dead field
<<[[Proc]] scheduling fields>>=
ulong readytime;  /* time process came ready */
@
%dead? uchar yield;    /* non-zero if the process just did a sleep(0) */
%dead? ulong movetime; /* last time process switched processors */



<<[[Proc]] optional [[edf]] field for real-time scheduling>>=
// option<ref_own?<edf>>
Edf *edf; /* if non-null, real-time proc, edf contains scheduling params */
@

<<[[lock()]] optional priority-inversion for real-time process>>=
            if(conf.ncpu < 2 && up && up->edf && (up->edf->flags & Admitted)){
                /*
                 * Priority inversion, yield on a uniprocessor; on a
                 * multiprocessor, the other processor will unlock
                 */
                print("inversion %#p pc %#lux proc %lud held by pc %#lux proc %lud\n",
                    l, pc, up ? up->pid : 0, l->pc, l->p ? l->p->pid : 0);
                up->edf->d = todget(nil);   /* yield to process with lock */
            }
@




<<enum edfflags>>=
enum edfflags 
{
    /* Edf.flags field */
    Admitted    = 0x01,
    Sporadic    = 0x02,
    Yieldonblock    = 0x04,
    Sendnotes   = 0x08,
    Deadline    = 0x10,
    Yield     = 0x20,
    Extratime   = 0x40,
};
@ 


<<struct Edf>>=
struct Edf {
    /* All times in µs */
    /* time intervals */
    long    D;    /* Deadline */
    long    Delta;    /* Inherited deadline */
    long    T;    /* period */
    long    C;    /* Cost */
    long    S;    /* Slice: time remaining in this period */
    /* times (only low-order bits of absolute time) */
    long    r;    /* (this) release time */
    long    d;    /* (this) deadline */
    long    t;    /* Start of next period, t += T at release */
    long    s;    /* Time at which this proc was last scheduled */
  
    /* for schedulability testing */
    long    testDelta;
    int   testtype; /* Release or Deadline */
    long    testtime;
    Proc    *testnext;
  
    /* other */
    // set<enum<edfflags>>
    ushort    flags;
  
    Timer;
  
    /* Stats */
    long    edfused;
    long    extraused;
    long    aged;
    ulong   periods;
    ulong   missed;
};
@ 


\subsection*{[[processes/edf.c]]}

\ifallcode
<<edf.c debugging macro>>=
enum {
    Dontprint = 1,
};
#define DPRINT  if(Dontprint){}else print
@ 
\fi



<<edf.c statistics>>=
/* Statistics stuff */
ulong       edfnrun;
//ulong     nilcount;
//ulong     scheds;
//int       misseddeadlines;
@ 

<<enum procstate cases>>=
Waitrelease, // for real-time scheduling
@ 

<<edf.c>>=
/* EDF scheduling */
<<kernel basic includes>>

#include    <trace.h>

// in proc.c
extern Schedq   runq[Nrq];
extern ulong    delayedscheds;
extern int  nrdy;
extern ulong    runvec;
// in devcons.c
extern int panicking; 
// used to be in edf.h
//unused: extern Lock edftestlock;  /* for atomic admitting/expelling */

<<edf.c debugging macro>>

enum 
{
    Maxsteps = 200 * 100 * 2, /* 100 periods of 200 procs */
};


static long now;    /* Low order 32 bits of time in µs */


<<edf.c statistics>>

int     edfinited;

/* Edfschedlock protects modification of admission params */
QLock       edfschedlock;
static Lock thelock;

enum{
    Dl, /* Invariant for schedulability test: Dl < Rl */
    Rl,
};

static char *testschedulability(Proc*);
static Proc *qschedulability;

enum {
    Onemicrosecond =    1,
    Onemillisecond =    1000,
    Onesecond =     1000000,
    OneRound =      Onemillisecond/2,
};

static int
timeconv(Fmt *f)
{
    char buf[128], *sign;
    vlong t;

    buf[0] = 0;
    switch(f->r) {
    case 'U':
        t = va_arg(f->args, uvlong);
        break;
    case 't':           /* vlong in nanoseconds */
        t = va_arg(f->args, long);
        break;
    default:
        return fmtstrcpy(f, "(timeconv)");
    }
    if (t < 0) {
        sign = "-";
        t = -t;
    }
    else
        sign = "";
    if (t > Onesecond){
        t += OneRound;
        snprint(buf, sizeof buf, "%s%d.%.3ds", sign,
            (int)(t / Onesecond),
            (int)(t % Onesecond)/Onemillisecond);
    }else if (t > Onemillisecond)
        snprint(buf, sizeof buf, "%s%d.%.3dms", sign,
            (int)(t / Onemillisecond), (int)(t % Onemillisecond));
    else
        snprint(buf, sizeof buf, "%s%dµs", sign, (int)t);
    return fmtstrcpy(f, buf);
}

#ifdef EDFCYCLES
long edfcycles;
#endif

Edf*
edflock(Proc *p)
{
    Edf *e;

    if (p->edf == nil)
        return nil;
    ilock(&thelock);
    if((e = p->edf) && (e->flags & Admitted)){
        thelock.pc = getcallerpc(&p);
#ifdef EDFCYCLES
        edfcycles -= lcycles();
#endif
        now = us();
        return e;
    }
    iunlock(&thelock);
    return nil;
}

void
edfunlock(void)
{

#ifdef EDFCYCLES
    edfcycles += lcycles();
#endif
    edfnrun++;
    iunlock(&thelock);
}

void
edfinit(Proc*p)
{
    if(!edfinited){
        fmtinstall('t', timeconv);
        edfinited++;
    }
    now = us();
    DPRINT("%lud edfinit %lud[%s]\n", now, p->pid, statename[p->state]);
    p->edf = malloc(sizeof(Edf));
    if(p->edf == nil)
        error(Enomem);
    return;
}

//@Scheck: not dead, called below, but not in edf.clang, weird
static void
deadlineintr(Ureg*, Timer *t)
{
    /* Proc reached deadline */
    Proc *p;
    void (*pt)(Proc*, int, vlong);

    if(panicking || active.exiting)
        return;

    p = t->ta;
    now = us();
    DPRINT("%lud deadlineintr %lud[%s]\n", now, p->pid, statename[p->state]);
    /* If we're interrupting something other than the proc pointed to by t->a,
     * we've already achieved recheduling, so we need not do anything
     * Otherwise, we must cause a reschedule, but if we call sched()
     * here directly, the timer interrupt routine will not finish its business
     * Instead, we cause the resched to happen when the interrupted proc
     * returns to user space
     */
    if(p == up){
        if(up->trace && (pt = proctrace))
            pt(up, SInts, 0);
        up->delaysched++;
        delayedscheds++;
    }
}

static void
release(Proc *p)
{
    /* Called with edflock held */
    Edf *e;
    void (*pt)(Proc*, int, vlong);
    long n;
    vlong nowns;

    e = p->edf;
    e->flags &= ~Yield;
    if(e->d - now < 0){
        e->periods++;
        e->r = now;
        if((e->flags & Sporadic) == 0){
            /*
             * Non sporadic processes stay true to their period;
             * calculate next release time.
             * Second test limits duration of while loop.
             */
            if((n = now - e->t) > 0){
                if(n < e->T)
                    e->t += e->T;
                else
                    e->t = now + e->T - (n % e->T);
            }
        }else{
            /* Sporadic processes may not be released earlier than
             * one period after this release
             */
            e->t = e->r + e->T;
        }
        e->d = e->r + e->D;
        e->S = e->C;
        DPRINT("%lud release %lud[%s], r=%lud, d=%lud, t=%lud, S=%lud\n",
            now, p->pid, statename[p->state], e->r, e->d, e->t, e->S);
        if(pt = proctrace){
            nowns = todget(nil);
            pt(p, SRelease, nowns);
            pt(p, SDeadline, nowns + 1000LL*e->D);
        }
    }else{
        DPRINT("%lud release %lud[%s], too late t=%lud, called from %#p\n",
            now, p->pid, statename[p->state], e->t, getcallerpc(&p));
    }
}

static void
releaseintr(Ureg*, Timer *t)
{
    Proc *p;
    Schedq *rq;

    if(panicking || active.exiting)
        return;

    p = t->ta;
    if((edflock(p)) == nil)
        return;
    DPRINT("%lud releaseintr %lud[%s]\n", now, p->pid, statename[p->state]);
    switch(p->state){
    default:
        edfunlock();
        return;
    case Ready:
        /* remove proc from current runq */
        rq = &runq[p->priority];
        if(dequeueproc(rq, p) != p){
            DPRINT("releaseintr: can't find proc or lock race\n");
            release(p); /* It'll start best effort */
            edfunlock();
            return;
        }
        p->state = Waitrelease;
        /* fall through */
    case Waitrelease:
        release(p);
        edfunlock();
        if(p->state == Wakeme){
            iprint("releaseintr: wakeme\n");
        }
        ready(p);
        if(up){
            up->delaysched++;
            delayedscheds++;
        }
        return;
    case Running:
        release(p);
        edfrun(p, 1);
        break;
    case Wakeme:
        release(p);
        edfunlock();
        if(p->trend)
            wakeup(p->trend);
        p->trend = nil;
        if(up){
            up->delaysched++;
            delayedscheds++;
        }
        return;
    }
    edfunlock();
}

void
edfrecord(Proc *p)
{
    long used;
    Edf *e;
    void (*pt)(Proc*, int, vlong);

    if((e = edflock(p)) == nil)
        return;
    used = now - e->s;
    if(e->d - now <= 0)
        e->edfused += used;
    else
        e->extraused += used;
    if(e->S > 0){
        if(e->S <= used){
            if(pt = proctrace)
                pt(p, SSlice, 0);
            DPRINT("%lud edfrecord slice used up\n", now);
            e->d = now;
            e->S = 0;
        }else
            e->S -= used;
    }
    e->s = now;
    edfunlock();
}

void
edfrun(Proc *p, int edfpri)
{
    Edf *e;
    void (*pt)(Proc*, int, vlong);
    long tns;

    e = p->edf;
    /* Called with edflock held */
    if(edfpri){
        tns = e->d - now;
        if(tns <= 0 || e->S == 0){
            /* Deadline reached or resources exhausted,
             * deschedule forthwith
             */
            p->delaysched++;
            delayedscheds++;
            e->s = now;
            return;
        }
        if(e->S < tns)
            tns = e->S;
        if(tns < 20)
            tns = 20;
        e->tns = 1000LL * tns;  /* µs to ns */
        if(e->tt == nil || e->tf != deadlineintr){
            DPRINT("%lud edfrun, deadline=%lud\n", now, tns);
        }else{
            DPRINT("v");
        }
        if(p->trace && (pt = proctrace))
            pt(p, SInte, todget(nil) + e->tns);
        e->tmode = Trelative;
        e->tf = deadlineintr;
        e->ta = p;
        timeradd(e);
    }else{
        DPRINT("<");
    }
    e->s = now;
}

char *
edfadmit(Proc *p)
{
    char *err;
    Edf *e;
    int i;
    Proc *r;
    void (*pt)(Proc*, int, vlong);
    long tns;

    e = p->edf;
    if (e->flags & Admitted)
        return "task state";    /* should never happen */

    /* simple sanity checks */
    if (e->T == 0)
        return "T not set";
    if (e->C == 0)
        return "C not set";
    if (e->D > e->T)
        return "D > T";
    if (e->D == 0)  /* if D is not set, set it to T */
        e->D = e->T;
    if (e->C > e->D)
        return "C > D";

    qlock(&edfschedlock);
    if (err = testschedulability(p)){
        qunlock(&edfschedlock);
        return err;
    }
    e->flags |= Admitted;

    edflock(p);

    if(p->trace && (pt = proctrace))
        pt(p, SAdmit, 0);

    /* Look for another proc with the same period to synchronize to */
    SET(r);
    for(i=0; i<conf.nproc; i++) {
        r = proctab(i);
        if(r->state == Dead || r == p)
            continue;
        if (r->edf == nil || (r->edf->flags & Admitted) == 0)
            continue;
        if (r->edf->T == e->T)
                break;
    }
    if (i == conf.nproc){
        /* Can't synchronize to another proc, release now */
        e->t = now;
        e->d = 0;
        release(p);
        if (p == up){
            DPRINT("%lud edfadmit self %lud[%s], release now: r=%lud d=%lud t=%lud\n",
                now, p->pid, statename[p->state], e->r, e->d, e->t);
            /* We're already running */
            edfrun(p, 1);
        }else{
            /* We're releasing another proc */
            DPRINT("%lud edfadmit other %lud[%s], release now: r=%lud d=%lud t=%lud\n",
                now, p->pid, statename[p->state], e->r, e->d, e->t);
            p->ta = p;
            edfunlock();
            qunlock(&edfschedlock);
            releaseintr(nil, p);
            return nil;
        }
    }else{
        /* Release in synch to something else */
        e->t = r->edf->t;
        if (p == up){
            DPRINT("%lud edfadmit self %lud[%s], release at %lud\n",
                now, p->pid, statename[p->state], e->t);
            edfunlock();
            qunlock(&edfschedlock);
            return nil;
        }else{
            DPRINT("%lud edfadmit other %lud[%s], release at %lud\n",
                now, p->pid, statename[p->state], e->t);
            if(e->tt == nil){
                e->tf = releaseintr;
                e->ta = p;
                tns = e->t - now;
                if(tns < 20)
                    tns = 20;
                e->tns = 1000LL * tns;
                e->tmode = Trelative;
                timeradd(e);
            }
        }
    }
    edfunlock();
    qunlock(&edfschedlock);
    return nil;
}

void
edfstop(Proc *p)
{
    Edf *e;
    void (*pt)(Proc*, int, vlong);

    if(e = edflock(p)){
        DPRINT("%lud edfstop %lud[%s]\n", now, p->pid, statename[p->state]);
        if(p->trace && (pt = proctrace))
            pt(p, SExpel, 0);
        e->flags &= ~Admitted;
        if(e->tt)
            timerdel(e);
        edfunlock();
    }
}

static int
yfn(void *)
{
    now = us();
    return up->trend == nil || now - up->edf->r >= 0;
}

void
edfyield(void)
{
    /* sleep until next release */
    Edf *e;
    void (*pt)(Proc*, int, vlong);
    long n;

    if((e = edflock(up)) == nil)
        return;
    if(up->trace && (pt = proctrace))
        pt(up, SYield, 0);
    if((n = now - e->t) > 0){
        if(n < e->T)
            e->t += e->T;
        else
            e->t = now + e->T - (n % e->T);
    }
    e->r = e->t;
    e->flags |= Yield;
    e->d = now;
    if (up->tt == nil){
        n = e->t - now;
        if(n < 20)
            n = 20;
        up->tns = 1000LL * n;
        up->tf = releaseintr;
        up->tmode = Trelative;
        up->ta = up;
        up->trend = &up->sleepr;
        timeradd(up);
    }else if(up->tf != releaseintr)
        print("edfyield: surprise! %#p\n", up->tf);
    edfunlock();
    sleep(&up->sleepr, yfn, nil);
}

int
edfready(Proc *p)
{
    Edf *e;
    Schedq *rq;
    Proc *l, *pp;
    void (*pt)(Proc*, int, vlong);
    long n;

    if((e = edflock(p)) == nil)
        return 0;

    if(p->state == Wakeme && p->r){
        iprint("edfready: wakeme\n");
    }
    if(e->d - now <= 0){
        /* past deadline, arrange for next release */
        if((e->flags & Sporadic) == 0){
            /*
             * Non sporadic processes stay true to their period;
             * calculate next release time.
             */
            if((n = now - e->t) > 0){
                if(n < e->T)
                    e->t += e->T;
                else
                    e->t = now + e->T - (n % e->T);
            }
        }
        if(now - e->t < 0){
            /* Next release is in the future, schedule it */
            if(e->tt == nil || e->tf != releaseintr){
                n = e->t - now;
                if(n < 20)
                    n = 20;
                e->tns = 1000LL * n;
                e->tmode = Trelative;
                e->tf = releaseintr;
                e->ta = p;
                timeradd(e);
                DPRINT("%lud edfready %lud[%s], release=%lud\n",
                    now, p->pid, statename[p->state], e->t);
            }
            if(p->state == Running && (e->flags & (Yield|Yieldonblock)) == 0 && (e->flags & Extratime)){
                /* If we were running, we've overrun our CPU allocation
                 * or missed the deadline, continue running best-effort at low priority
                 * Otherwise we were blocked.  If we don't yield on block, we continue
                 * best effort
                 */
                DPRINT(">");
                p->basepri = PriExtra;
                p->fixedpri = 1;
                edfunlock();
                return 0;   /* Stick on runq[PriExtra] */
            }
            DPRINT("%lud edfready %lud[%s] wait release at %lud\n",
                now, p->pid, statename[p->state], e->t);
            p->state = Waitrelease;
            edfunlock();
            return 1;   /* Make runnable later */
        }
        DPRINT("%lud edfready %lud %s release now\n", now, p->pid, statename[p->state]);
        /* release now */
        release(p);
    }
    edfunlock();
    DPRINT("^");
    rq = &runq[PriEdf];
    /* insert in queue in earliest deadline order */
    lock(runq);
    l = nil;
    for(pp = rq->head; pp; pp = pp->rnext){
        if(pp->edf->d > e->d)
            break;
        l = pp;
    }
    p->rnext = pp;
    if (l == nil)
        rq->head = p;
    else
        l->rnext = p;
    if(pp == nil)
        rq->tail = p;
    rq->n++;
    nrdy++;
    runvec |= 1 << PriEdf;
    p->priority = PriEdf;
    p->readytime = cpu->ticks;
    p->state = Ready;
    unlock(runq);
    if(p->trace && (pt = proctrace))
        pt(p, SReady, 0);
    return 1;
}


static void
testenq(Proc *p)
{
    Proc *xp, **xpp;
    Edf *e;

    e = p->edf;
    e->testnext = nil;
    if (qschedulability == nil) {
        qschedulability = p;
        return;
    }
    SET(xp);
    for (xpp = &qschedulability; *xpp; xpp = &xp->edf->testnext) {
        xp = *xpp;
        if (e->testtime - xp->edf->testtime < 0
        || (e->testtime == xp->edf->testtime && e->testtype < xp->edf->testtype)){
            e->testnext = xp;
            *xpp = p;
            return;
        }
    }
    assert(xp->edf->testnext == nil);
    xp->edf->testnext = p;
}

static char *
testschedulability(Proc *theproc)
{
    Proc *p;
    long H, G, Cb, ticks;
    int steps, i;

    /* initialize */
    DPRINT("schedulability test %lud\n", theproc->pid);
    qschedulability = nil;
    for(i=0; i<conf.nproc; i++) {
        p = proctab(i);
        if(p->state == Dead)
            continue;
        if ((p->edf == nil || (p->edf->flags & Admitted) == 0) && p != theproc)
            continue;
        p->edf->testtype = Rl;
        p->edf->testtime = 0;
        DPRINT("\tInit: edfenqueue %lud\n", p->pid);
        testenq(p);
    }
    H=0;
    G=0;
    for(steps = 0; steps < Maxsteps; steps++){
        p = qschedulability;
        qschedulability = p->edf->testnext;
        ticks = p->edf->testtime;
        switch (p->edf->testtype){
        case Dl:
            H += p->edf->C;
            Cb = 0;
            DPRINT("\tStep %3d, Ticks %lud, pid %lud, deadline, H += %lud → %lud, Cb = %lud\n",
                steps, ticks, p->pid, p->edf->C, H, Cb);
            if (H+Cb>ticks){
                DPRINT("not schedulable\n");
                return "not schedulable";
            }
            p->edf->testtime += p->edf->T - p->edf->D;
            p->edf->testtype = Rl;
            testenq(p);
            break;
        case Rl:
            DPRINT("\tStep %3d, Ticks %lud, pid %lud, release, G  %lud, C%lud\n",
                steps, ticks, p->pid, p->edf->C, G);
            if(ticks && G <= ticks){
                DPRINT("schedulable\n");
                return nil;
            }
            G += p->edf->C;
            p->edf->testtime += p->edf->D;
            p->edf->testtype = Dl;
            testenq(p);
            break;
        default:
            assert(0);
        }
    }
    DPRINT("probably not schedulable\n");
    return "probably not schedulable";
}
@

% >>

\section{Floating Point}
%{FP}

% apparently on 386 we have IrqIRQ13 for coprocessor, meaning the copro
% is really outside and need to communicate with him?
% simpler with 486?

<<enum fpsavestatus>>=
/*
 * FPsave.status
 */
enum fpsavestatus
{
    /* this is a state */
    FPinit=   0,
    FPactive= 1,
    FPinactive= 2,
  
    /* the following is a bit that can be or'd into the state */
    FPillegal=  0x100,
};
@ 

<<[[Proc]] other fields>>=
// enum<fpsavestatus>
int fpstate;
ArchFPsave  fpsave;   /* address of this is known by db */
@

<<union ArchFPSave>>=
/*
 * the FP regs must be stored here, not somewhere pointed to from here.
 * port code assumes this.
 */
// could be renamed ArchProcFPSave (used both in Proc and Cpu though)
union ArchFPsave {
    FPstate;
    SFPssestate;
};
@


<<struct FPstate>>=
//@Scheck: unnamed substructure
struct  FPstate     /* x87 fpu state */
{
  ushort  control;
  ushort  r1;
  // enum<fpsavestatus>
  ushort  status;
  ushort  r2;
  ushort  tag;
  ushort  r3;
  ulong pc;
  ushort  selector;
  ushort  r4;
  ulong operand;
  ushort  oselector;
  ushort  r5;
  uchar regs[80]; /* floating point registers */
};
@

<<struct  SFPssestate>>=
//@Scheck: unnamed substructure
struct  SFPssestate   /* SSE fp state with alignment slop */
{
  FPssestate;
  uchar alignpad[FPalign]; /* slop to allow copying to aligned addr */
  ulong magic;    /* debugging: check for overrun */
};
@

<<constant FPalign>>=
#define FPalign   16      /* required for FXSAVE */
@


<<struct FPssestate>>=
//@Scheck: unnamed substructure
struct  FPssestate    /* SSE fp state */
{
  ushort  fcw;    /* control */
  ushort  fsw;    /* status */
  ushort  ftw;    /* tag */
  ushort  fop;    /* opcode */
  ulong fpuip;    /* pc */
  ushort  cs;   /* pc segment */
  ushort  r1;   /* reserved */
  ulong fpudp;    /* data pointer */
  ushort  ds;   /* data pointer segment */
  ushort  r2;
  ulong mxcsr;    /* MXCSR register state */
  ulong mxcsr_mask; /* MXCSR mask register */
  uchar xregs[480]; /* extended registers */
};
@


<<[[Cpu]] [[Arch]] other fields>>=
ArchFPsave *fpsavalign;
@


<<[[newproc()]] fb init>>=
    p->fpstate = FPinit;
@

<<[[sysrfork()]] propagate fpsave>>=
    p->fpsave = up->fpsave;
@

<<[[sysrfork()]] propagate fpstate>>=
    /* don't penalize the child, it hasn't done FP in a note handler. */
    p->fpstate = up->fpstate & ~FPillegal;
@

<<function fpsavealloc>>=
void
fpsavealloc(void)
{
    cpu->fpsavalign = mallocalign(sizeof(FPssestate), FPalign, 0, 0);
    if (cpu->fpsavalign == nil)
        panic("cpu%d: can't allocate fpsavalign", cpu->cpuno);
}
@ 


<<hook fprestore and fpsave>>=
void    (*fprestore)(ArchFPsave*);
void    (*fpsave)(ArchFPsave*);
@

<<function fpssesave>>=
/*
 * sse fp save and restore buffers have to be 16-byte (FPalign) aligned,
 * so we shuffle the data down as needed or make copies.
 */

void
fpssesave(ArchFPsave *fps)
{
    ArchFPsave *afps;

    fps->magic = 0x1234;
    afps = (ArchFPsave *)ROUND(((uintptr)fps), FPalign);
    fpssesave0(afps);
    if (fps != afps)  /* not aligned? shuffle down from aligned buffer */
        memmove(fps, afps, sizeof(FPssestate));
    if (fps->magic != 0x1234)
        print("fpssesave: magic corrupted\n");
}
@ 


<<function fpsserestore>>=
void
fpsserestore(ArchFPsave *fps)
{
    ArchFPsave *afps;

    fps->magic = 0x4321;
    afps = (ArchFPsave *)ROUND(((uintptr)fps), FPalign);
    if (fps != afps) {
        afps = cpu->fpsavalign;
        memmove(afps, fps, sizeof(FPssestate)); /* make aligned copy */
    }
    fpsserestore0(afps);
    if (fps->magic != 0x4321)
        print("fpsserestore: magic corrupted\n");
}
@ 





<<[[procsetup()]] fp setup>>=
/*
 *  set up floating point for a new process
 */
    p->fpstate = FPinit;
    fpoff();
@

<<[[userinit()]] fp setup>>=
    p->fpstate = FPinit;
    fpoff();
@

<<[[execregs()]] fp adjustments>>=
    //procsetup(up), redundant?
    up->fpstate = FPinit;
    fpoff();
@

<<[[syscall()]] fp adjustments if fork>>=
    if(scallnr == RFORK && up->fpstate == FPactive){
        fpsave(&up->fpsave);
        up->fpstate = FPinactive;
    }
@

<<[[notify()]] fp adjustments>>=
    if(up->fpstate == FPactive){
        fpsave(&up->fpsave);
        up->fpstate = FPinactive;
    }
    up->fpstate |= FPillegal;
@

<<[[noted()]] fp adjustments>>=
    up->fpstate &= ~FPillegal;
@

<<[[procsave()]] fp adjustments>>=
    if(p->fpstate == FPactive){
        if(p->state == Moribund)
            fpclear();
        else{
            /*
             * Fpsave() stores without handling pending
             * unmasked exeptions. Postnote() can't be called
             * here as sleep() already has up->rlock, so
             * the handling of pending exceptions is delayed
             * until the process runs again and generates an
             * emulation fault to activate the FPU.
             */
            fpsave(&p->fpsave);
        }
        p->fpstate = FPinactive;
    }
@



<<[[procread()]] Qfpregs case>>=
    case Qfpregs:
        rptr = (uchar*)&p->fpsave;
        rsize = sizeof(ArchFPsave);
        goto regread;
@

<<[[procwrite]] Qfpregs case>>=
    case Qfpregs:
        if(offset >= sizeof(ArchFPsave))
            n = 0;
        else if(offset+n > sizeof(ArchFPsave))
            n = sizeof(ArchFPsave) - offset;
        memmove((uchar*)&p->fpsave+offset, va, n);
        break;
@




<<function mathstate>>=
static void
mathstate(ulong *stsp, ulong *pcp, ulong *ctlp)
{
        ulong sts, fpc, ctl;
        ArchFPsave *f = &up->fpsave;

        if(fpsave == fpx87save){
                sts = f->status;
                fpc = f->pc;
                ctl = f->control;
        } else {
                sts = f->fsw;
                fpc = f->fpuip;
                ctl = f->fcw;
        }
        if(stsp)
                *stsp = sts;
        if(pcp)
                *pcp = fpc;
        if(ctlp)
                *ctlp = ctl;
}
@

<<function mathnote>>=
static void
mathnote(void)
{
        int i;
        ulong status, pc;
        char *msg, note[ERRMAX];

        mathstate(&status, &pc, nil);

        /*
         * Some attention should probably be paid here to the
         * exception masks and error summary.
         */
        msg = "unknown exception";
        for(i = 1; i <= 5; i++){
                if(!((1<<i) & status))
                        continue;
                msg = mathmsg[i];
                break;
        }
        if(status & 0x01){
                if(status & 0x40){
                        if(status & 0x200)
                                msg = "stack overflow";
                        else
                                msg = "stack underflow";
                }else
                        msg = "invalid operation";
        }
        snprint(note, sizeof note, "sys: fp: %s fppc=%#lux status=%#lux",
                msg, pc, status);
        postnote(up, 1, note, NDebug);
}
@
% >>

<<function matherror>>=
/*
 *  math coprocessor error
 */
static void
matherror(Ureg *ur, void*)
{
        ulong status, pc;

        /*
         *  a write cycle to port 0xF0 clears the interrupt latch attached
         *  to the error# line from the 387
         */
        if(!(cpu->cpuiddx & Fpuonchip))
                outb(0xF0, 0xFF);

        /*
         *  save floating point state to check out error
         */
        fpenv(&up->fpsave);     /* result ignored, but masks fp exceptions */
        fpsave(&up->fpsave);            /* also turns fpu off */
        fpon();
        mathnote();

        if((ur->pc & 0xf0000000) == KZERO){
                mathstate(&status, &pc, nil);
                panic("fp: status %#lux fppc=%#lux pc=%#lux", status, pc, ur->pc);
        }
}
@


<<function mathemu>>=
/*
 *  math coprocessor emulation fault
 */
static void
mathemu(Ureg *ureg, void*)
{
        ulong status, control;

        if(up->fpstate & FPillegal){
                /* someone did floating point in a note handler */
                postnote(up, 1, "sys: floating point in note handler", NDebug);
                return;
        }
        switch(up->fpstate){
        case FPinit:
                fpinit();
                up->fpstate = FPactive;
                break;
        case FPinactive:
                /*
                 * Before restoring the state, check for any pending
                 * exceptions, there's no way to restore the state without
                 * generating an unmasked exception.
                 * More attention should probably be paid here to the
                 * exception masks and error summary.
                 */
                mathstate(&status, nil, &control);
                if((status & ~control) & 0x07F){
                        mathnote();
                        break;
                }
                fprestore(&up->fpsave);
                up->fpstate = FPactive;
                break;
        case FPactive:
                panic("math emu pid %ld %s pc %#lux",
                        up->pid, up->text, ureg->pc);
                break;
        }
}
@


<<function mathover>>=
/*
 *  math coprocessor segment overrun
 */
static void
mathover(Ureg*, void*)
{
        pexit("math overrun", false);
}
@


<<function mathinit>>=
void
mathinit(void)
{
        trapenable(VectorCERR, matherror, 0, "matherror");
        if(X86FAMILY(cpu->cpuidax) == 3)
                intrenable(IrqIRQ13, matherror, 0, BUSUNKNOWN, "matherror");
        trapenable(VectorCNA, mathemu, 0, "mathemu");
        trapenable(VectorCSO, mathover, 0, "mathover");
}
@



<<l_fp.s>>=
/*
 * Some machine instructions not handled by 8[al].
 */
#define FXSAVE          BYTE $0x0f; BYTE $0xae; BYTE $0x00  /* SSE FP save */
#define FXRSTOR         BYTE $0x0f; BYTE $0xae; BYTE $0x08  /* SSE FP restore */

        
/*
 * Floating point.
 * Note: the encodings for the FCLEX, FINIT, FSAVE, FSTCW, FSENV and FSTSW
 * instructions do NOT have the WAIT prefix byte (i.e. they act like their
 * FNxxx variations) so WAIT instructions must be explicitly placed in the
 * code as necessary.
 */
#define FPOFF(l)                                                 ;\
        MOVL    CR0, AX                                          ;\
        ANDL    $0xC, AX                        /* EM, TS */     ;\
        CMPL    AX, $0x8                                         ;\
        JEQ     l                                                ;\
        WAIT                                                     ;\
l:                                                               ;\
        MOVL    CR0, AX                                          ;\
        ANDL    $~0x4, AX                       /* EM=0 */       ;\
        ORL     $0x28, AX                       /* NE=1, TS=1 */ ;\
        MOVL    AX, CR0

#define FPON                                                     ;\
        MOVL    CR0, AX                                          ;\
        ANDL    $~0xC, AX                       /* EM=0, TS=0 */ ;\
        MOVL    AX, CR0

TEXT fpon(SB), $0                               /* enable */
        FPON
        RET

TEXT fpoff(SB), $0                              /* disable */
        FPOFF(l1)
        RET

TEXT fpinit(SB), $0                             /* enable and init */
        FPON
        FINIT
        WAIT
        /* setfcr(FPPDBL|FPRNR|FPINVAL|FPZDIV|FPOVFL) */
        /* note that low 6 bits are masks, not enables, on this chip */
        PUSHW   $0x0232
        FLDCW   0(SP)
        POPW    AX
        WAIT
        RET

TEXT fpx87save(SB), $0                          /* save state and disable */
        MOVL    p+0(FP), AX
        FSAVE   0(AX)                           /* no WAIT */
        FPOFF(l2)
        RET

TEXT fpx87restore(SB), $0                       /* enable and restore state */
        FPON
        MOVL    p+0(FP), AX
        FRSTOR  0(AX)
        WAIT
        RET

//TEXT fpstatus(SB), $0                         /* get floating point status */
//      FSTSW   AX
//      RET

TEXT fpenv(SB), $0                              /* save state without waiting */
        MOVL    p+0(FP), AX
        FSTENV  0(AX)                           /* also masks FP exceptions */
        RET

TEXT fpclear(SB), $0                            /* clear pending exceptions */
        FPON
        FCLEX                                   /* no WAIT */
        FPOFF(l3)
        RET

TEXT fpssesave0(SB), $0                         /* save state and disable */
        MOVL    p+0(FP), AX
        FXSAVE                                  /* no WAIT */
        FPOFF(l4)
        RET

TEXT fpsserestore0(SB), $0                      /* enable and restore state */
        FPON
        MOVL    p+0(FP), AX
        FXRSTOR
        WAIT
        RET
        
@


\section{Power}

% used by apm.c
<<constant x86 other segments>>=
#define APMCSEG   6 /* APM code segment */
#define APMCSEG16 7 /* APM 16-bit code segment */
#define APMDSEG   8 /* APM data segment */
/* #define  APM40SEG  8 /* APM segment 0x40 */
@


<<constant x86 other segment selectors>>=
#define APMCSEL   SELECTOR(APMCSEG, SELGDT, 0)
#define APMCSEL16 SELECTOR(APMCSEG16, SELGDT, 0)
#define APMDSEL   SELECTOR(APMDSEG, SELGDT, 0)
/* #define  APM40SEL  SELECTOR(APM40SEG, SELGDT, 0) */
@


<<[[PCArch]] power methods fields>>=
int (*serialpower)(int);  /* 1 == on, 0 == off */
int (*modempower)(int); /* 1 == on, 0 == off */
@

<<[[archgeneric]] power methods>>=
    .serialpower=   unimplemented,
    .modempower=    unimplemented,
@

<<function unimplemented>>=
static int
unimplemented(int)
{
    return 0;
}
@


\section{Serial line}
% or put in debugging section? with rdb? but then need do demo
% with qemu?

<<global serialoq>>=
Queue*  serialoq;       /* serial console output */
@ 

<<function consactive>>=
int
consactive(void)
{
    if(serialoq)
        return qlen(serialoq) > 0;
    return 0;
}
@ 

% dead?
<<function prflush>>=
void
prflush(void)
{
    ulong now;

    now = cpu->ticks;
    while(consactive())
        if(cpu->ticks - now >= HZ)
            break;
}
@ 

<<function echoserialoq>>=
static void
echoserialoq(char *buf, int n)
{
    char *e, *p;
    char ebuf[128];
    int x;

    p = ebuf;
    e = ebuf + sizeof(ebuf) - 4;
    while(n-- > 0){
        if(p >= e){
            qiwrite(serialoq, ebuf, p - ebuf);
            p = ebuf;
        }
        x = *buf++;
        if(x == '\n'){
            *p++ = '\r';
            *p++ = '\n';
        } else if(x == 0x15){
            *p++ = '^';
            *p++ = 'U';
            *p++ = '\n';
        } else
            *p++ = x;
    }
    if(p != ebuf)
        qiwrite(serialoq, ebuf, p - ebuf);
}
@ 


\section{SCSI}




\chapter{Extra Extra Extra}

\subsection*{[[arch/386/io.h]]}

<<io.h>>=

#define X86FAMILY(x)  ((((x)>>8) & 0x0F) | (((x)>>20) & 0xFF)<<4)

enum {
  BusCBUS   = 0,    /* Corollary CBUS */
  BusCBUSII,      /* Corollary CBUS II */
  BusEISA,      /* Extended ISA */
  BusFUTURE,      /* IEEE Futurebus */
  BusINTERN,      /* Internal bus */
  BusISA,       /* Industry Standard Architecture */
  BusMBI,       /* Multibus I */
  BusMBII,      /* Multibus II */
  BusMCA,       /* Micro Channel Architecture */
  BusMPI,       /* MPI */
  BusMPSA,      /* MPSA */
  BusNUBUS,     /* Apple Macintosh NuBus */
  BusPCI,       /* Peripheral Component Interconnect */
  BusPCMCIA,      /* PC Memory Card International Association */
  BusTC,        /* DEC TurboChannel */
  BusVL,        /* VESA Local bus */
  BusVME,       /* VMEbus */
  BusXPRESS,      /* Express System Bus */
};

#define MKBUS(t,b,d,f)  (((t)<<24)|(((b)&0xFF)<<16)|(((d)&0x1F)<<11)|(((f)&0x07)<<8))
#define BUSFNO(tbdf)  (((tbdf)>>8)&0x07)
#define BUSDNO(tbdf)  (((tbdf)>>11)&0x1F)
#define BUSBNO(tbdf)  (((tbdf)>>16)&0xFF)
#define BUSTYPE(tbdf) ((tbdf)>>24)
#define BUSBDF(tbdf)  ((tbdf)&0x00FFFF00)
#define BUSUNKNOWN  (-1)

enum {
  MaxEISA   = 16,
  CfgEISA   = 0xC80,
};

/*
 * PCI support code.
 */
enum {          /* type 0 & type 1 pre-defined header */
  PciVID    = 0x00,   /* vendor ID */
  PciDID    = 0x02,   /* device ID */
  PciPCR    = 0x04,   /* command */
  PciPSR    = 0x06,   /* status */
  PciRID    = 0x08,   /* revision ID */
  PciCCRp   = 0x09,   /* programming interface class code */
  PciCCRu   = 0x0A,   /* sub-class code */
  PciCCRb   = 0x0B,   /* base class code */
  PciCLS    = 0x0C,   /* cache line size */
  PciLTR    = 0x0D,   /* latency timer */
  PciHDT    = 0x0E,   /* header type */
  PciBST    = 0x0F,   /* BIST */

  PciBAR0   = 0x10,   /* base address */
  PciBAR1   = 0x14,

  PciINTL   = 0x3C,   /* interrupt line */
  PciINTP   = 0x3D,   /* interrupt pin */
};

/* ccrb (base class code) values; controller types */
enum {
  Pcibcpci1 = 0,    /* pci 1.0; no class codes defined */
  Pcibcstore  = 1,    /* mass storage */
  Pcibcnet  = 2,    /* network */
  Pcibcdisp = 3,    /* display */
  Pcibcmmedia = 4,    /* multimedia */
  Pcibcmem  = 5,    /* memory */
  Pcibcbridge = 6,    /* bridge */
  Pcibccomm = 7,    /* simple comms (e.g., serial) */
  Pcibcbasesys  = 8,    /* base system */
  Pcibcinput  = 9,    /* input */
  Pcibcdock = 0xa,    /* docking stations */
  Pcibcproc = 0xb,    /* processors */
  Pcibcserial = 0xc,    /* serial bus (e.g., USB) */
  Pcibcwireless = 0xd,    /* wireless */
  Pcibcintell = 0xe,    /* intelligent i/o */
  Pcibcsatcom = 0xf,    /* satellite comms */
  Pcibccrypto = 0x10,   /* encryption/decryption */
  Pcibcdacq = 0x11,   /* data acquisition & signal proc. */
};

/* ccru (sub-class code) values; common cases only */
enum {
  /* mass storage */
  Pciscscsi = 0,    /* SCSI */
  Pciscide  = 1,    /* IDE (ATA) */
  Pciscsata = 6,    /* SATA */

  /* network */
  Pciscether  = 0,    /* Ethernet */

  /* display */
  Pciscvga  = 0,    /* VGA */
  Pciscxga  = 1,    /* XGA */
  Pcisc3d   = 2,    /* 3D */

  /* bridges */
  Pcischostpci  = 0,    /* host/pci */
  Pciscpcicpci  = 1,    /* pci/pci */

  /* simple comms */
  Pciscserial = 0,    /* 16450, etc. */
  Pciscmultiser = 1,    /* multiport serial */

  /* serial bus */
  Pciscusb  = 3,    /* USB */
};

enum {          /* type 0 pre-defined header */
  PciCIS    = 0x28,   /* cardbus CIS pointer */
  PciSVID   = 0x2C,   /* subsystem vendor ID */
  PciSID    = 0x2E,   /* cardbus CIS pointer */
  PciEBAR0  = 0x30,   /* expansion ROM base address */
  PciMGNT   = 0x3E,   /* burst period length */
  PciMLT    = 0x3F,   /* maximum latency between bursts */
};

enum {          /* type 1 pre-defined header */
  PciPBN    = 0x18,   /* primary bus number */
  PciSBN    = 0x19,   /* secondary bus number */
  PciUBN    = 0x1A,   /* subordinate bus number */
  PciSLTR   = 0x1B,   /* secondary latency timer */
  PciIBR    = 0x1C,   /* I/O base */
  PciILR    = 0x1D,   /* I/O limit */
  PciSPSR   = 0x1E,   /* secondary status */
  PciMBR    = 0x20,   /* memory base */
  PciMLR    = 0x22,   /* memory limit */
  PciPMBR   = 0x24,   /* prefetchable memory base */
  PciPMLR   = 0x26,   /* prefetchable memory limit */
  PciPUBR   = 0x28,   /* prefetchable base upper 32 bits */
  PciPULR   = 0x2C,   /* prefetchable limit upper 32 bits */
  PciIUBR   = 0x30,   /* I/O base upper 16 bits */
  PciIULR   = 0x32,   /* I/O limit upper 16 bits */
  PciEBAR1  = 0x28,   /* expansion ROM base address */
  PciBCR    = 0x3E,   /* bridge control register */
};

enum {          /* type 2 pre-defined header */
  PciCBExCA = 0x10,
  PciCBSPSR = 0x16,
  PciCBPBN  = 0x18,   /* primary bus number */
  PciCBSBN  = 0x19,   /* secondary bus number */
  PciCBUBN  = 0x1A,   /* subordinate bus number */
  PciCBSLTR = 0x1B,   /* secondary latency timer */
  PciCBMBR0 = 0x1C,
  PciCBMLR0 = 0x20,
  PciCBMBR1 = 0x24,
  PciCBMLR1 = 0x28,
  PciCBIBR0 = 0x2C,   /* I/O base */
  PciCBILR0 = 0x30,   /* I/O limit */
  PciCBIBR1 = 0x34,   /* I/O base */
  PciCBILR1 = 0x38,   /* I/O limit */
  PciCBSVID = 0x40,   /* subsystem vendor ID */
  PciCBSID  = 0x42,   /* subsystem ID */
  PciCBLMBAR  = 0x44,   /* legacy mode base address */
};

struct Pcisiz
{
  Pcidev* dev;
  int siz;
  int bar;
};

struct Pcidev
{
  int tbdf;     /* type+bus+device+function */
  ushort  vid;      /* vendor ID */
  ushort  did;      /* device ID */

  ushort  pcr;

  uchar rid;
  uchar ccrp;
  uchar ccru;
  uchar ccrb;
  uchar cls;
  uchar ltr;

  struct {
    ulong bar;    /* base address */
    int size;
  } mem[6];

  struct {
    ulong bar;  
    int size;
  } rom;
  uchar intl;     /* interrupt line */

  Pcidev* list;
  Pcidev* link;     /* next device on this bno */

  Pcidev* bridge;     /* down a bus */
  struct {
    ulong bar;
    int size;
  } ioa, mema;

  int pmrb;     /* power management register block */
};

enum {
  /* vendor ids */
  Vatiamd = 0x1002,
  Vintel  = 0x8086,
  Vjmicron= 0x197b,
  Vmarvell= 0x1b4b,
  Vmyricom= 0x14c1,
};

#define PCIWINDOW 0
#define PCIWADDR(va)  (PADDR(va)+PCIWINDOW)
#define ISAWINDOW 0
#define ISAWADDR(va)  (PADDR(va)+ISAWINDOW)

/* SMBus transactions */
enum
{
  SMBquick,   /* sends address only */

  /* write */
  SMBsend,    /* sends address and cmd */
  SMBbytewrite,   /* sends address and cmd and 1 byte */
  SMBwordwrite,   /* sends address and cmd and 2 bytes */

  /* read */
  SMBrecv,    /* sends address, recvs 1 byte */
  SMBbyteread,    /* sends address and cmd, recv's byte */
  SMBwordread,    /* sends address and cmd, recv's 2 bytes */
};

/*
 * PCMCIA support code.
 */

/*
 * Map between ISA memory space and PCMCIA card memory space.
 */
struct PCMmap {
  ulong ca;     /* card address */
  ulong cea;      /* card end address */
  ulong isa;      /* ISA address */
  int len;      /* length of the ISA area */
  int attr;     /* attribute memory */
  int ref;
};

/* configuration table entry */
struct PCMconftab
{
  int index;
  ushort  irqs;   /* legal irqs */
  uchar irqtype;
  uchar bit16;    /* true for 16 bit access */
  struct {
    ulong start;
    ulong len;
  } io[16];
  int nio;
  uchar vpp1;
  uchar vpp2;
  uchar memwait;
  ulong maxwait;
  ulong readywait;
  ulong otherwait;
};

/* a card slot */
struct PCMslot
{
  Lock;
  int ref;

  void  *cp;    /* controller for this slot */
  long  memlen;   /* memory length */
  uchar base;   /* index register base */
  uchar slotno;   /* slot number */

  /* status */
  uchar special;  /* in use for a special device */
  uchar already;  /* already inited */
  uchar occupied;
  uchar battery;
  uchar wrprot;
  uchar powered;
  uchar configed;
  uchar enabled;
  uchar busy;

  /* cis info */
  ulong msec;   /* time of last slotinfo call */
  char  verstr[512];  /* version string */
  int ncfg;   /* number of configurations */
  struct {
    ushort  cpresent; /* config registers present */
    ulong caddr;    /* relative address of config registers */
  } cfg[8];
  int nctab;    /* number of config table entries */
  PCMconftab  ctab[8];
  PCMconftab  *def; /* default conftab */

  /* memory maps */
  Lock  mlock;    /* lock down the maps */
  int time;
  PCMmap  mmap[4];  /* maps, last is always for the kernel */
};

<<io.h pragmas>>
@


\ifallcode
<<io.h pragmas>>=
#pragma varargck  type  "T" int
#pragma varargck  type  "T" uint
@
\fi


%//typedef struct SMBus SMBus;
%//struct SMBus {
%//  QLock;    /* mutex */
%//  Rendez  r;  /* rendezvous point for completion interrupts */
%//  void  *arg; /* implementation dependent */
%//  ulong base; /* port or memory base of smbus */
%//  int busy;
%//  void  (*transact)(SMBus*, int, int, int, uchar*);
%//};



\subsection*{[[arch/386/iomap.c]]}

<<global iomap>>=
struct Iomapalloc iomap;
@ 


<<function ioinit>>=
void
ioinit(void)
{
    char *excluded;
    int i;

    for(i = 0; i < nelem(iomap.maps)-1; i++)
        iomap.maps[i].next = &iomap.maps[i+1];
    iomap.maps[i].next = nil;
    iomap.free = iomap.maps;

    /*
     * This is necessary to make the IBM X20 boot.
     * Have not tracked down the reason.
     * i82557 is at 0x1000, the dummy entry is needed for swappable devs.
     */
    ioalloc(0x0fff, 1, 0, "dummy");

    if ((excluded = getconf("ioexclude")) != nil) {
        char *s;

        s = excluded;
        while (s && *s != '\0' && *s != '\n') {
            char *ends;
            int io_s, io_e;

            io_s = (int)strtol(s, &ends, 0);
            if (ends == nil || ends == s || *ends != '-') {
                print("ioinit: cannot parse option string\n");
                break;
            }
            s = ++ends;

            io_e = (int)strtol(s, &ends, 0);
            if (ends && *ends == ',')
                *ends++ = '\0';
            s = ends;

            ioalloc(io_s, io_e - io_s + 1, 0, "pre-allocated");
        }
    }

}
@ 


<<function ioalloc>>=
/*
 *  alloc some io port space and remember who it was
 *  alloced to.  if port < 0, find a free region.
 */
int
ioalloc(int port, int size, int align, char *tag)
{
    IOMap *m, **l;
    int i;

    lock(&iomap);
    if(port < 0){
        /* find a free port above 0x400 and below 0x1000 */
        port = 0x400;
        for(l = &iomap.m; *l; l = &(*l)->next){
            m = *l;
            if (m->start < 0x400) continue;
            i = m->start - port;
            if(i > size)
                break;
            if(align > 0)
                port = ((port+align-1)/align)*align;
            else
                port = m->end;
        }
        if(*l == nil){
            unlock(&iomap);
            return -1;
        }
    } else {
        /* Only 64KB I/O space on the x86. */
        if((port+size) > 0x10000){
            unlock(&iomap);
            return -1;
        }
        /* see if the space clashes with previously allocated ports */
        for(l = &iomap.m; *l; l = &(*l)->next){
            m = *l;
            if(m->end <= port)
                continue;
            if(m->reserved && m->start == port && m->end == port + size) {
                m->reserved = 0;
                unlock(&iomap);
                return m->start;
            }
            if(m->start >= port+size)
                break;
            unlock(&iomap);
            return -1;
        }
    }
    m = iomap.free;
    if(m == nil){
        print("ioalloc: out of maps");
        unlock(&iomap);
        return port;
    }
    iomap.free = m->next;
    m->next = *l;
    m->start = port;
    m->end = port + size;
    strncpy(m->tag, tag, sizeof(m->tag));
    m->tag[sizeof(m->tag)-1] = 0;
    *l = m;

    //archdir[0].qid.vers++;
        if(hook_ioalloc) 
            hook_ioalloc();

    unlock(&iomap);
    return m->start;
}
@ 


<<function iofree>>=
void
iofree(int port)
{
    IOMap *m, **l;

    lock(&iomap);
    for(l = &iomap.m; *l; l = &(*l)->next){
        if((*l)->start == port){
            m = *l;
            *l = m->next;
            m->next = iomap.free;
            iomap.free = m;
            break;
        }
        if((*l)->start > port)
            break;
    }
    //archdir[0].qid.vers++;
        if(hook_ioalloc) 
            hook_ioalloc();

    unlock(&iomap);
}
@ 


<<iomap.c>>=
<<kernel basic includes>>
#include "io.h"

<<global iomap>>

// to remove some backward dependencies, so that ioalloc()
// can be here instead of in devarch.c
void (*hook_ioalloc)() = nil;

<<function ioinit>>

<<function ioalloc>>

<<function iofree>>

@

%///*
%// * Reserve a range to be ioalloced later.
%// * This is in particular useful for exchangable cards, such
%// * as pcmcia and cardbus cards.
%// */
%//int
%//ioreserve(int, int size, int align, char *tag)
%//{
%//  IOMap *m, **l;
%//  int i, port;
%//
%//  lock(&iomap);
%//  /* find a free port above 0x400 and below 0x1000 */
%//  port = 0x400;
%//  for(l = &iomap.m; *l; l = &(*l)->next){
%//      m = *l;
%//      if (m->start < 0x400) continue;
%//      i = m->start - port;
%//      if(i > size)
%//          break;
%//      if(align > 0)
%//          port = ((port+align-1)/align)*align;
%//      else
%//          port = m->end;
%//  }
%//  if(*l == nil){
%//      unlock(&iomap);
%//      return -1;
%//  }
%//  m = iomap.free;
%//  if(m == nil){
%//      print("ioalloc: out of maps");
%//      unlock(&iomap);
%//      return port;
%//  }
%//  iomap.free = m->next;
%//  m->next = *l;
%//  m->start = port;
%//  m->end = port + size;
%//  m->reserved = 1;
%//  strncpy(m->tag, tag, sizeof(m->tag));
%//  m->tag[sizeof(m->tag)-1] = 0;
%//  *l = m;
%//
%//  archdir[0].qid.vers++;
%//
%//  unlock(&iomap);
%//  return m->start;
%//}


\subsection*{[[arch/386/l_io.s]]}

<<l_io.s>>=
/*
 * Some machine instructions not handled by 8[al].
 */
#define OP16            BYTE $0x66
        
/*
 * Port I/O.
 *      in[bsl]         input a byte|short|long
 *      ins[bsl]        input a string of bytes|shorts|longs
 *      out[bsl]        output a byte|short|long
 *      outs[bsl]       output a string of bytes|shorts|longs
 */
TEXT inb(SB), $0
        MOVL    port+0(FP), DX
        XORL    AX, AX
        INB
        RET

TEXT ins(SB), $0
        MOVL    port+0(FP), DX
        XORL    AX, AX
        OP16;   INL
        RET

TEXT inss(SB), $0
        MOVL    port+0(FP), DX
        MOVL    address+4(FP), DI
        MOVL    count+8(FP), CX
        CLD
        REP;    OP16; INSL
        RET

TEXT inl(SB), $0
        MOVL    port+0(FP), DX
        INL
        RET

TEXT outb(SB), $0
        MOVL    port+0(FP), DX
        MOVL    byte+4(FP), AX
        OUTB
        RET

TEXT outs(SB), $0
        MOVL    port+0(FP), DX
        MOVL    short+4(FP), AX
        OP16;   OUTL
        RET

TEXT outss(SB), $0
        MOVL    port+0(FP), DX
        MOVL    address+4(FP), SI
        MOVL    count+8(FP), CX
        CLD
        REP;    OP16; OUTSL
        RET

TEXT outl(SB), $0
        MOVL    port+0(FP), DX
        MOVL    long+4(FP), AX
        OUTL
        RET
@

%//TEXT insb(SB), $0
%//      MOVL    port+0(FP), DX
%//      MOVL    address+4(FP), DI
%//      MOVL    count+8(FP), CX
%//      CLD
%//      REP;    INSB
%//      RET
%//TEXT insl(SB), $0
%//      MOVL    port+0(FP), DX
%//      MOVL    address+4(FP), DI
%//      MOVL    count+8(FP), CX
%//      CLD
%//      REP;    INSL
%//      RET
%//TEXT outsb(SB), $0
%//      MOVL    port+0(FP), DX
%//      MOVL    address+4(FP), SI
%//      MOVL    count+8(FP), CX
%//      CLD
%//      REP;    OUTSB
%//      RET
%
%//TEXT outsl(SB), $0
%//      MOVL    port+0(FP), DX
%//      MOVL    address+4(FP), SI
%//      MOVL    count+8(FP), CX
%//      CLD
%//      REP;    OUTSL
%//      RET


\subsection*{[[arch/386/x86.c]]}

<<global cputype>>=
X86type *cputype;
@ 


<<global x86intel>>=
/* cpuid ax is 0x0ffMTFmS, where 0xffF is family, 0xMm is model */
static X86type x86intel[] =
{
    { 4,    0,  22, "486DX", }, /* known chips */
    { 4,    1,  22, "486DX50", },
    { 4,    2,  22, "486SX", },
    { 4,    3,  22, "486DX2", },
    { 4,    4,  22, "486SL", },
    { 4,    5,  22, "486SX2", },
    { 4,    7,  22, "DX2WB", }, /* P24D */
    { 4,    8,  22, "DX4", },   /* P24C */
    { 4,    9,  22, "DX4WB", }, /* P24CT */
    { 5,    0,  23, "P5", },
    { 5,    1,  23, "P5", },
    { 5,    2,  23, "P54C", },
    { 5,    3,  23, "P24T", },
    { 5,    4,  23, "P55C MMX", },
    { 5,    7,  23, "P54C VRT", },
    { 6,    1,  16, "PentiumPro", },/* trial and error */
    { 6,    3,  16, "PentiumII", },
    { 6,    5,  16, "PentiumII/Xeon", },
    { 6,    6,  16, "Celeron", },
    { 6,    7,  16, "PentiumIII/Xeon", },
    { 6,    8,  16, "PentiumIII/Xeon", },
    { 6,    0xB,    16, "PentiumIII/Xeon", },
    { 6,    0xF,    16, "Core 2/Xeon", },
    { 6,    0x16,   16, "Celeron", },
    { 6,    0x17,   16, "Core 2/Xeon", },
    { 6,    0x1A,   16, "Core i7/Xeon", },
    { 6,    0x1C,   16, "Atom", },
    { 6,    0x1D,   16, "Xeon MP", },
    { 6,    0x1E,   16, "Core i5/i7/Xeon", },
    { 6,    0x1F,   16, "Core i7/Xeon", },
    { 6,    0x22,   16, "Core i7", },
    { 6,    0x25,   16, "Core i3/i5/i7", },
    { 6,    0x2A,   16, "Core i7", },
    { 6,    0x2C,   16, "Core i7/Xeon", },
    { 6,    0x2D,   16, "Core i7", },
    { 6,    0x2E,   16, "Xeon MP", },
    { 6,    0x2F,   16, "Xeon MP", },
    { 6,    0x3A,   16, "Core i7", },
    { 0xF,  1,  16, "P4", },    /* P4 */
    { 0xF,  2,  16, "PentiumIV/Xeon", },
    { 0xF,  6,  16, "PentiumIV/Xeon", },

    { 3,    -1, 32, "386", },   /* family defaults */
    { 4,    -1, 22, "486", },
    { 5,    -1, 23, "P5", },
    { 6,    -1, 16, "P6", },
    { 0xF,  -1, 16, "P4", },    /* P4 */

    { -1,   -1, 16, "unknown", },   /* total default */
};
@ 


<<global x86amd>>=
/*
 * The AMD processors all implement the CPUID instruction.
 * The later ones also return the processor name via functions
 * 0x80000002, 0x80000003 and 0x80000004 in registers AX, BX, CX
 * and DX:
 *  K5  "AMD-K5(tm) Processor"
 *  K6  "AMD-K6tm w/ multimedia extensions"
 *  K6 3D   "AMD-K6(tm) 3D processor"
 *  K6 3D+  ?
 */
static X86type x86amd[] =
{
    { 5,    0,  23, "AMD-K5", },    /* guesswork */
    { 5,    1,  23, "AMD-K5", },    /* guesswork */
    { 5,    2,  23, "AMD-K5", },    /* guesswork */
    { 5,    3,  23, "AMD-K5", },    /* guesswork */
    { 5,    4,  23, "AMD Geode GX1", }, /* guesswork */
    { 5,    5,  23, "AMD Geode GX2", }, /* guesswork */
    { 5,    6,  11, "AMD-K6", },    /* trial and error */
    { 5,    7,  11, "AMD-K6", },    /* trial and error */
    { 5,    8,  11, "AMD-K6-2", },  /* trial and error */
    { 5,    9,  11, "AMD-K6-III", },/* trial and error */
    { 5,    0xa,    23, "AMD Geode LX", },  /* guesswork */

    { 6,    1,  11, "AMD-Athlon", },/* trial and error */
    { 6,    2,  11, "AMD-Athlon", },/* trial and error */

    { 0x1F, 9,  11, "AMD-K10 Opteron G34", },/* guesswork */

    { 4,    -1, 22, "Am486", }, /* guesswork */
    { 5,    -1, 23, "AMD-K5/K6", }, /* guesswork */
    { 6,    -1, 11, "AMD-Athlon", },/* guesswork */
    { 0xF,  -1, 11, "AMD-K8", },    /* guesswork */
    { 0x1F, -1, 11, "AMD-K10", },   /* guesswork */

    { -1,   -1, 11, "unknown", },   /* total default */
};
@ 


<<global x86winchip>>=
/*
 * WinChip 240MHz
 */
static X86type x86winchip[] =
{
    {5, 4,  23, "Winchip",},    /* guesswork */
    {6, 7,  23, "Via C3 Samuel 2 or Ezra",},
    {6, 8,  23, "Via C3 Ezra-T",},
    {6, 9,  23, "Via C3 Eden-N",},
    { -1,   -1, 23, "unknown", },   /* total default */
};
@ 


<<global x86sis>>=
/*
 * SiS 55x
 */
static X86type x86sis[] =
{
    {5, 0,  23, "SiS 55x",},    /* guesswork */
    { -1,   -1, 23, "unknown", },   /* total default */
};
@ 


<<function cpuidentify>>=
/*
 *  figure out:
 *  - cpu type
 *  - whether or not we have a TSC (cycle counter)
 *  - whether or not it supports page size extensions
 *      (if so turn it on)
 *  - whether or not it supports machine check exceptions
 *      (if so turn it on)
 *  - whether or not it supports the page global flag
 *      (if so turn it on)
 */
int
cpuidentify(void)
{
    char *p;
    int family, model, nomce;
    X86type *t, *tab;
    ulong cr4;
    ulong regs[4];
    vlong mca, mct;

    cpuid(Highstdfunc, regs);
    memmove(cpu->cpuidid,   &regs[1], BY2WD); /* bx */
    memmove(cpu->cpuidid+4, &regs[3], BY2WD); /* dx */
    memmove(cpu->cpuidid+8, &regs[2], BY2WD); /* cx */
    cpu->cpuidid[12] = '\0';

    cpuid(Procsig, regs);
    cpu->cpuidax = regs[0];
    cpu->cpuiddx = regs[3];

    if(strncmp(cpu->cpuidid, "AuthenticAMD", 12) == 0 ||
       strncmp(cpu->cpuidid, "Geode by NSC", 12) == 0)
        tab = x86amd;
    else if(strncmp(cpu->cpuidid, "CentaurHauls", 12) == 0)
        tab = x86winchip;
    else if(strncmp(cpu->cpuidid, "SiS SiS SiS ", 12) == 0)
        tab = x86sis;
    else
        tab = x86intel;

    family = X86FAMILY(cpu->cpuidax);
    model = X86MODEL(cpu->cpuidax);
    for(t=tab; t->name; t++)
        if((t->family == family && t->model == model)
        || (t->family == family && t->model == -1)
        || (t->family == -1))
            break;

    cpu->cpuidtype = t->name;

    /*
     *  if there is one, set tsc to a known value
     */
    if(cpu->cpuiddx & Tsc){
        cpu->havetsc = true;
        cycles = _cycles;
        if(cpu->cpuiddx & Cpumsr)
            wrmsr(0x10, 0);
    }

    /*
     *  use i8253 to guess our cpu speed
     */
    guesscpuhz(t->aalcycles);

    /*
     * If machine check exception, page size extensions or page global bit
     * are supported enable them in CR4 and clear any other set extensions.
     * If machine check was enabled clear out any lingering status.
     */
    if(cpu->cpuiddx & (Pge|Mce|Pse)){
        cr4 = 0;
        if(cpu->cpuiddx & Pse)
            cr4 |= 0x10;        /* page size extensions */
        if(p = getconf("*nomce"))
            nomce = strtoul(p, 0, 0);
        else
            nomce = 0;
        if((cpu->cpuiddx & Mce) && !nomce){
            cr4 |= 0x40;        /* machine check enable */
            if(family == 5){
                rdmsr(0x00, &mca);
                rdmsr(0x01, &mct);
            }
        }

        /*
         * Detect whether the chip supports the global bit
         * in page directory and page table entries.  When set
         * in a particular entry, it means ``don't bother removing
         * this from the TLB when CR3 changes.''
         *
         * We flag all kernel pages with this bit.  Doing so lessens the
         * overhead of switching processes on bare hardware,
         * even more so on VMware.  See mmu.c:/^memglobal.
         *
         * For future reference, should we ever need to do a
         * full TLB flush, it can be accomplished by clearing
         * the PGE bit in CR4, writing to CR3, and then
         * restoring the PGE bit.
         */
        if(cpu->cpuiddx & Pge){
            cr4 |= 0x80;        /* page global enable bit */
            cpu->havepge = true;
        }

        putcr4(cr4);
        if(cpu->cpuiddx & Mce)
            rdmsr(0x01, &mct);
    }

    if(cpu->cpuiddx & Fxsr){          /* have sse fp? */
        fpsave = fpssesave;
        fprestore = fpsserestore;
        putcr4(getcr4() | CR4Osfxsr);
    } else {
        fpsave = fpx87save;
        fprestore = fpx87restore;
    }

    cputype = t;
    return t->family;
}
@ 


<<x86.c>>=
<<kernel basic includes>>
#include "io.h"

<<global cputype>>

//#define X86STEPPING(x)  ((x) & 0x0F)
/* incorporates extended-model and -family bits */
#define X86MODEL(x) ((((x)>>4) & 0x0F) | (((x)>>16) & 0x0F)<<4)

//@Scheck: Assembly l.s
void    _cycles(uvlong*);   

enum {
    CR4Osfxsr = 1 << 9,
};

enum {              /* cpuid standard function codes */
    Highstdfunc = 0,    /* also returns vendor string */
    Procsig,
    Proctlbcache,
    Procserial,
};


<<global x86intel>>

<<global x86amd>>

<<global x86winchip>>

<<global x86sis>>


<<function cpuidentify>>

@

\subsection*{[[arch/386/bios32.c]]}

\ifallcode
<<bios32.c debugging macro>>=
static int vflag = 0;
//#define VFLAG(...)    if(vflag) print(__VA_ARGS__)
#define VFLAG if(vflag) print
@ 
\fi

<<bios32.c forward decl>>=
typedef struct BIOS32sdh BIOS32sdh;
typedef struct BIOS32si BIOS32si;
@ 


<<bios32.c>>=
<<kernel basic includes>>
#include "io.h"

<<bios32.c debugging macro>>

<<bios32.c forward decl>>

struct BIOS32sdh {      /* BIOS32 Service Directory Header */
    u8int   signature[4];       /* "_32_" */
    u8int   physaddr[4];        /* physical address of entry point */
    u8int   revision;
    u8int   length;         /* of header in paragraphs */
    u8int   checksum;       /* */
    u8int   reserved[5];
};

struct BIOS32si {       /* BIOS32 Service Interface */
    u8int*  base;           /* base address of service */
    int length;         /* length of service */
    u32int  offset;         /* service entry-point from base */

    u16int  ptr[3];         /* far pointer m16:32 */
};

static Lock bios32lock;
static u16int bios32ptr[3];
static void* bios32entry;

int
bios32ci(BIOS32si* si, BIOS32ci* ci)
{
    int r;

    lock(&bios32lock);
    r = bios32call(ci, si->ptr);
    unlock(&bios32lock);

    return r;
}

static void*
rsdchecksum(void* addr, int length)
{
    u8int *p, sum;

    sum = 0;
    for(p = addr; length-- > 0; p++)
        sum += *p;
    if(sum == 0)
        return addr;

    return nil;
}

static void*
rsdscan(u8int* addr, int len, char* signature)
{
    int sl;
    u8int *e, *p;

    e = addr+len;
    sl = strlen(signature);
    for(p = addr; p+sl < e; p += 16){
        if(memcmp(p, signature, sl))
            continue;
        return p;
    }

    return nil;
}

static int
bios32locate(void)
{
    uintptr ptr;
    BIOS32sdh *sdh;

    VFLAG("bios32link\n");
    if((sdh = rsdscan(BIOSSEG(0xE000), 0x20000, "_32_")) == nil)
        return -1;
    if(rsdchecksum(sdh, sizeof(BIOS32sdh)) == nil)
        return -1;
    VFLAG("sdh @ %#p, entry %#ux\n", sdh, L32GET(sdh->physaddr));

    bios32entry = vmap(L32GET(sdh->physaddr), 4096+1);
    VFLAG("entry @ %#p\n", bios32entry);
    ptr = (uintptr)(bios32entry);
    bios32ptr[0] = ptr & 0xffff;
    bios32ptr[1] = (ptr>>16) & 0xffff;
    bios32ptr[2] = KESEL;
    VFLAG("bios32link: ptr %ux %ux %ux\n",
        bios32ptr[0], bios32ptr[1], bios32ptr[2]);

    return 0;
}

BIOS32si*
bios32open(char* id)
{
    uint ptr;
    BIOS32ci ci;
    BIOS32si *si;

    lock(&bios32lock);
    if(bios32ptr[2] == 0 && bios32locate() < 0){
        unlock(&bios32lock);
        return nil;
    }

    VFLAG("bios32si: %s\n", id);
    memset(&ci, 0, sizeof(BIOS32ci));
    ci.eax = (id[3]<<24|(id[2]<<16)|(id[1]<<8)|id[0]);

    bios32call(&ci, bios32ptr);
    unlock(&bios32lock);

    VFLAG("bios32si: eax %ux\n", ci.eax);
    if(ci.eax & 0xff)
        return nil;
    VFLAG("bios32si: base %#ux length %#ux offset %#ux\n",
        ci.ebx, ci.ecx, ci.edx);

    if((si = malloc(sizeof(BIOS32si))) == nil)
        return nil;
    if((si->base = vmap(ci.ebx, ci.ecx)) == nil){
        free(si);
        return nil;
    }
    si->length = ci.ecx;

    ptr = (uintptr)(si->base)+ci.edx;
    si->ptr[0] = ptr & 0xffff;
    si->ptr[1] = (ptr>>16) & 0xffff;
    si->ptr[2] = KESEL;
    VFLAG("bios32si: eax entry %ux\n", ptr);

    return si;
}
@

%//void
%//BIOS32close(BIOS32si* si)
%//{
%//  vunmap(si->base, si->length);
%//  free(si);
%//}



\subsection*{[[arch/386/l_realmode.s]]}

<<constant x86 other segments>>=
#define KESEG16   9 /* kernel executable 16-bit */
@

<<macros other xxxSEGM>>=
#define EXEC16SEGM(p)   { 0xFFFF, SEGG|(0xF<<16)|SEGP|SEGPL(p)|SEGEXEC|SEGR }
@

<<[[gdt]] other elements>>=
[KESEG16]       EXEC16SEGM(0),  /* kernel code 16-bit */
@



<<l_realmode.s>>=
#include "mem.h"
#include "x16.h"

//*****************************************************************************
// Helpers
//*****************************************************************************

/*
 * Save registers.
 */
TEXT saveregs(SB), $0
        /* appease 8l */
        SUBL $32, SP
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        
        PUSHL   AX
        PUSHL   BX
        PUSHL   CX
        PUSHL   DX
        PUSHL   BP
        PUSHL   DI
        PUSHL   SI
        PUSHFL

        XCHGL   32(SP), AX      /* swap return PC and saved flags */
        XCHGL   0(SP), AX
        XCHGL   32(SP), AX
        RET

TEXT restoreregs(SB), $0
        /* appease 8l */
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        ADDL    $32, SP
        
        XCHGL   32(SP), AX      /* swap return PC and saved flags */
        XCHGL   0(SP), AX
        XCHGL   32(SP), AX

        POPFL
        POPL    SI
        POPL    DI
        POPL    BP
        POPL    DX
        POPL    CX
        POPL    BX
        POPL    AX
        RET


//*****************************************************************************
// Functions
//*****************************************************************************
                
/*
 * Assumed to be in protected mode at time of call.
 * Switch to real mode, execute an interrupt, and
 * then switch back to protected mode.  
 *
 * Assumes:
 *
 *      - no device interrupts are going to come in
 *      - 0-16MB is identity mapped in page tables
 *      - realmode() has copied us down from 0x100000 to 0x8000
 *      - can use code segment 0x0800 in real mode
 *              to get at l.s code
 *      - l.s code is less than 1 page
 */
#define RELOC   (RMCODE-KTZERO)

TEXT realmodeidtptr(SB), $0
        WORD    $(4*256-1)
        LONG    $0

TEXT realmode0(SB), $0
        CALL    saveregs(SB)

        /* switch to low code address */
        LEAL    physcode-KZERO(SB), AX
        JMP *AX

TEXT physcode(SB), $0

        /* switch to low stack */
        MOVL    SP, AX
        MOVL    $0x7C00, SP
        PUSHL   AX

        /* change gdt to physical pointer */
        MOVL    m0rgdtptr-KZERO(SB), GDTR

        /* load IDT with real-mode version*/
        MOVL    realmodeidtptr-KZERO(SB), IDTR

        /* edit INT $0x00 instruction below */
        MOVL    $(RMUADDR-KZERO+48), AX /* &rmu.trap */
        MOVL    (AX), AX
        MOVB    AX, realmodeintrinst+(-KZERO+1+RELOC)(SB)

        /* disable paging */
        MOVL    CR0, AX
        ANDL    $0x7FFFFFFF, AX
        MOVL    AX, CR0
        /* JMP .+2 to clear prefetch queue*/
        BYTE $0xEB; BYTE $0x00

        /* jump to 16-bit code segment */
/*      JMPFAR  SELECTOR(KESEG16, SELGDT, 0):$again16bit(SB) /**/
         BYTE   $0xEA
         LONG   $again16bit-KZERO(SB)
         WORD   $SELECTOR(KESEG16, SELGDT, 0)

TEXT again16bit(SB), $0
        /*
         * Now in 16-bit compatibility mode.
         * These are 32-bit instructions being interpreted
         * as 16-bit instructions.  I'm being lazy and
         * not using the macros because I know when
         * the 16- and 32-bit instructions look the same
         * or close enough.
         */

        /* disable protected mode and jump to real mode cs */
        OPSIZE; MOVL CR0, AX
        OPSIZE; XORL BX, BX
        OPSIZE; INCL BX
        OPSIZE; XORL BX, AX
        OPSIZE; MOVL AX, CR0

        /* JMPFAR 0x0800:now16real */
         BYTE $0xEA
         WORD   $now16real-KZERO(SB)
         WORD   $0x0800

TEXT now16real(SB), $0
        /* copy the registers for the bios call */
        LWI(0x0000, rAX)
        MOVW    AX,SS
        LWI(RMUADDR, rBP)
        
        /* offsets are in Ureg */
        LXW(44, xBP, rAX)
        MOVW    AX, DS
        LXW(40, xBP, rAX)
        MOVW    AX, ES

        OPSIZE; LXW(0, xBP, rDI)
        OPSIZE; LXW(4, xBP, rSI)
        OPSIZE; LXW(16, xBP, rBX)
        OPSIZE; LXW(20, xBP, rDX)
        OPSIZE; LXW(24, xBP, rCX)
        OPSIZE; LXW(28, xBP, rAX)

        CLC

TEXT realmodeintrinst(SB), $0
        INT $0x00
        CLI                     /* who knows what evil the bios got up to */

        /* save the registers after the call */

        LWI(0x7bfc, rSP)
        OPSIZE; PUSHFL
        OPSIZE; PUSHL AX

        LWI(0, rAX)
        MOVW    AX,SS
        LWI(RMUADDR, rBP)
        
        OPSIZE; SXW(rDI, 0, xBP)
        OPSIZE; SXW(rSI, 4, xBP)
        OPSIZE; SXW(rBX, 16, xBP)
        OPSIZE; SXW(rDX, 20, xBP)
        OPSIZE; SXW(rCX, 24, xBP)
        OPSIZE; POPL AX
        OPSIZE; SXW(rAX, 28, xBP)

        MOVW    DS, AX
        OPSIZE; SXW(rAX, 44, xBP)
        MOVW    ES, AX
        OPSIZE; SXW(rAX, 40, xBP)

        OPSIZE; POPL AX
        OPSIZE; SXW(rAX, 64, xBP)       /* flags */

        /* re-enter protected mode and jump to 32-bit code */
        OPSIZE; MOVL $1, AX
        OPSIZE; MOVL AX, CR0
        
/*      JMPFAR  SELECTOR(KESEG, SELGDT, 0):$again32bit(SB) /**/
         OPSIZE
         BYTE $0xEA
         LONG   $again32bit-KZERO(SB)
         WORD   $SELECTOR(KESEG, SELGDT, 0)

TEXT again32bit(SB), $0
        MOVW    $SELECTOR(KDSEG, SELGDT, 0),AX
        MOVW    AX,DS
        MOVW    AX,SS
        MOVW    AX,ES
        MOVW    AX,FS
        MOVW    AX,GS

        /* enable paging and jump to kzero-address code */
        MOVL    CR0, AX
        ORL     $0x80010000, AX /* PG|WP */
        MOVL    AX, CR0
        LEAL    again32kzero(SB), AX
        JMP*    AX

TEXT again32kzero(SB), $0
        /* breathe a sigh of relief - back in 32-bit protected mode */

        /* switch to old stack */       
        PUSHL   AX      /* match popl below for 8l */
        MOVL    $0x7BFC, SP
        POPL    SP

        /* restore idt */
        MOVL    m0idtptr(SB),IDTR

        /* restore gdt */
        MOVL    m0gdtptr(SB), GDTR

        CALL    restoreregs(SB)
        RET

/*
 * BIOS32.
 */
TEXT bios32call(SB), $0
        MOVL    ci+0(FP), BP
        MOVL    0(BP), AX
        MOVL    4(BP), BX
        MOVL    8(BP), CX
        MOVL    12(BP), DX
        MOVL    16(BP), SI
        MOVL    20(BP), DI
        PUSHL   BP

        MOVL    12(SP), BP                      /* ptr */
        BYTE $0xFF; BYTE $0x5D; BYTE $0x00      /* CALL FAR 0(BP) */

        POPL    BP
        MOVL    DI, 20(BP)
        MOVL    SI, 16(BP)
        MOVL    DX, 12(BP)
        MOVL    CX, 8(BP)
        MOVL    BX, 4(BP)
        MOVL    AX, 0(BP)

        XORL    AX, AX
        JCC     _bios32xxret
        INCL    AX

_bios32xxret:
        RET
@



\subsection*{[[arch/386/mp.h]]}

<<mp.h>>=
/*
 * MultiProcessor Specification Version 1.[14].
 */
struct _MP_ {     /* floating pointer */
  uchar signature[4];   /* "_MP_" */
  long  physaddr;   /* physical address of MP configuration table */
  uchar length;     /* 1 */
  uchar specrev;    /* [14] */
  uchar checksum;   /* all bytes must add up to 0 */
  uchar type;     /* MP system configuration type */
  uchar imcrp;
  uchar reserved[3];
};

struct PCMP {     /* configuration table header */
  uchar signature[4];   /* "PCMP" */
  ushort  length;     /* total table length */
  uchar version;    /* [14] */
  uchar checksum;   /* all bytes must add up to 0 */
  uchar product[20];    /* product id */
  ulong oemtable;   /* OEM table pointer */
  ushort  oemlength;    /* OEM table length */
  ushort  entry;      /* entry count */
  ulong lapicbase;    /* address of local APIC */
  ushort  xlength;    /* extended table length */
  uchar xchecksum;    /* extended table checksum */
  uchar reserved;
};

struct PCMPprocessor {      /* processor table entry */
  uchar type;     /* entry type (0) */
  uchar apicno;     /* local APIC id */
  uchar version;    /* local APIC verison */
  uchar flags;      /* CPU flags */
  uchar signature[4];   /* CPU signature */
  ulong feature;    /* feature flags from CPUID instruction */
  uchar reserved[8];
};

struct PCMPbus {      /* bus table entry */
  uchar type;     /* entry type (1) */
  uchar busno;      /* bus id */
  char  string[6];    /* bus type string */
};

struct PCMPioapic {     /* I/O APIC table entry */
  uchar type;     /* entry type (2) */
  uchar apicno;     /* I/O APIC id */
  uchar version;    /* I/O APIC version */
  uchar flags;      /* I/O APIC flags */
  ulong addr;     /* I/O APIC address */
};

struct PCMPintr {     /* interrupt table entry */
  uchar type;     /* entry type ([34]) */
  uchar intr;     /* interrupt type */
  ushort  flags;      /* interrupt flag */
  uchar busno;      /* source bus id */
  uchar irq;      /* source bus irq */
  uchar apicno;     /* destination APIC id */
  uchar intin;      /* destination APIC [L]INTIN# */
};

enum {          /* table entry types */
  PcmpPROCESSOR = 0x00,   /* one entry per processor */
  PcmpBUS   = 0x01,   /* one entry per bus */
  PcmpIOAPIC  = 0x02,   /* one entry per I/O APIC */
  PcmpIOINTR  = 0x03,   /* one entry per bus interrupt source */
  PcmpLINTR = 0x04,   /* one entry per system interrupt source */

  PcmpSASM  = 0x80,
  PcmpHIERARCHY = 0x81,
  PcmpCBASM = 0x82,

          /* PCMPprocessor and PCMPioapic flags */
  PcmpEN    = 0x01,   /* enabled */
  PcmpBP    = 0x02,   /* bootstrap processor */

          /* PCMPiointr and PCMPlintr flags */
  PcmpPOMASK  = 0x03,   /* polarity conforms to specifications of bus */
  PcmpHIGH  = 0x01,   /* active high */
  PcmpLOW   = 0x03,   /* active low */
  PcmpELMASK  = 0x0C,   /* trigger mode of APIC input signals */
  PcmpEDGE  = 0x04,   /* edge-triggered */
  PcmpLEVEL = 0x0C,   /* level-triggered */

          /* PCMPiointr and PCMPlintr interrupt type */
  PcmpINT   = 0x00,   /* vectored interrupt from APIC Rdt */
  PcmpNMI   = 0x01,   /* non-maskable interrupt */
  PcmpSMI   = 0x02,   /* system management interrupt */
  PcmpExtINT  = 0x03,   /* vectored interrupt from external PIC */

          /* PCMPsasm addrtype */
  PcmpIOADDR  = 0x00,   /* I/O address */
  PcmpMADDR = 0x01,   /* memory address */
  PcmpPADDR = 0x02,   /* prefetch address */

          /* PCMPhierarchy info */
  PcmpSD    = 0x01,   /* subtractive decode bus */

          /* PCMPcbasm modifier */
  PcmpPR    = 0x01,   /* predefined range list */
};

/*
 * Condensed form of the MP Configuration Table.
 * This is created during a single pass through the MP Configuration
 * table.
 */
typedef struct Bus {
  uchar type;
  uchar busno;
  uchar po;
  uchar el;

  Aintr*  aintr;      /* interrupts tied to this bus */
  Bus*  next;
} Bus;

struct Aintr {
  PCMPintr* intr;
  Apic* apic;
  Aintr*  next;
};

struct Apic {
  int type;
  int apicno;
  ulong*  addr;     /* register base address */
  ulong paddr;
  int flags;      /* PcmpBP|PcmpEN */

  Lock;       /* I/O APIC: register access */
  int mre;      /* I/O APIC: maximum redirection entry */

  int lintr[2];   /* Local APIC */
  int cpuno;

  int online;
};

enum {
  MaxAPICNO = 254,    /* 255 is physical broadcast */
};

enum {          /* I/O APIC registers */
  IoapicID  = 0x00,   /* ID */
  IoapicVER = 0x01,   /* version */
  IoapicARB = 0x02,   /* arbitration ID */
  IoapicRDT = 0x10,   /* redirection table */
};

/*
 * Common bits for
 *  I/O APIC Redirection Table Entry;
 *  Local APIC Local Interrupt Vector Table;
 *  Local APIC Inter-Processor Interrupt;
 *  Local APIC Timer Vector Table.
 */
enum {
  ApicFIXED = 0x00000000, /* [10:8] Delivery Mode */
  ApicLOWEST  = 0x00000100, /* Lowest priority */
  ApicSMI   = 0x00000200, /* System Management Interrupt */
  ApicRR    = 0x00000300, /* Remote Read */
  ApicNMI   = 0x00000400,
  ApicINIT  = 0x00000500, /* INIT/RESET */
  ApicSTARTUP = 0x00000600, /* Startup IPI */
  ApicExtINT  = 0x00000700,

  ApicPHYSICAL  = 0x00000000, /* [11] Destination Mode (RW) */
  ApicLOGICAL = 0x00000800,

  ApicDELIVS  = 0x00001000, /* [12] Delivery Status (RO) */
  ApicHIGH  = 0x00000000, /* [13] Interrupt Input Pin Polarity (RW) */
  ApicLOW   = 0x00002000,
  ApicRemoteIRR = 0x00004000, /* [14] Remote IRR (RO) */
  ApicEDGE  = 0x00000000, /* [15] Trigger Mode (RW) */
  ApicLEVEL = 0x00008000,
  ApicIMASK = 0x00010000, /* [16] Interrupt Mask */
};

extern void ioapicinit(Apic*, int);
extern void ioapicrdtr(Apic*, int, int*, int*);
extern void ioapicrdtw(Apic*, int, int, int);

extern void lapicclock(Ureg*, void*);
extern int lapiceoi(int);
extern void lapicerror(Ureg*, void*);
extern void lapicicrw(ulong, ulong);
extern void lapicinit(Apic*);
extern void lapicintroff(void);
extern void lapicintron(void);
extern int lapicisr(int);
//extern void lapicnmidisable(void);
//extern void lapicnmienable(void);
extern void lapiconline(void);
extern void lapicspurious(Ureg*, void*);
extern void lapicstartap(Apic*, int);
extern void lapictimerset(uvlong);

extern void mpinit(void);
extern int mpintrenable(Vctl*);
extern void mpshutdown(void);

extern _MP_ *_mp_;
@

%//typedef struct PCMPsasm PCMPsasm;
%//typedef struct PCMPhierarchy PCMPhierarchy;
%//typedef struct PCMPcbasm PCMPcbasm;
%
%//struct PCMPsasm {     /* system address space mapping entry */
%//  uchar type;     /* entry type (128) */
%//  uchar length;     /* of this entry (20) */
%//  uchar busno;      /* bus id */
%//  uchar addrtype;
%//  ulong addrbase[2];
%//  ulong addrlength[2];
%//};
%
%//struct PCMPhierarchy {      /* bus hierarchy descriptor entry */
%//  uchar type;     /* entry type (129) */
%//  uchar length;     /* of this entry (8) */
%//  uchar busno;      /* bus id */
%//  uchar info;     /* bus info */
%//  uchar parent;     /* parent bus */
%//  uchar reserved[3];
%//};
%
%//struct PCMPcbasm {      /* compatibility bus address space modifier entry */
%//  uchar type;     /* entry type (130) */
%//  uchar length;     /* of this entry (8) */
%//  uchar busno;      /* bus id */
%//  uchar modifier;   /* address modifier */
%//  ulong range;      /* predefined range list */
%//};


\subsection*{[[arch/386/mpacpi.h]]}

<<mpacpi.h>>=
/*
 * ACPI definitions
 *
 * A System Descriptor Table starts with a header of 4 bytes of signature
 * followed by 4 bytes of total table length then 28 bytes of ID information
 * (including the table checksum).
 */

//@Scheck: type deps on params
struct Madt {       /* Multiple APIC DT */
  uchar sdthdr[36];   /* "MADT" + length[4] + [28] */
  uchar addr[4];    /* Local APIC Address */
  uchar flags[4];
  uchar structures[];
};
struct Rsd {        /* Root System Description * */
  uchar signature[8];   /* "RSD PTR " */
  uchar rchecksum;
  uchar oemid[6];
  uchar revision;
  uchar raddr[4];   /* RSDT */
  uchar length[4];
  uchar xaddr[8];   /* XSDT */
  uchar xchecksum;    /* XSDT */
  uchar pad[3];     /* reserved */
};
@

%//struct Dsdt {       /* Differentiated System DT */
%//  uchar sdthdr[36];   /* "DSDT" + length[4] + [28] */
%//  uchar db[];     /* Definition Block */
%//};
%//struct Facp {       /* Fixed ACPI DT */
%//  uchar sdthdr[36];   /* "FACP" + length[4] + [28] */
%//  uchar faddr[4];   /* Firmware Control Address */
%//  uchar dsdt[4];    /* DSDT Address */
%//  uchar pad[200];   /* total table is 244 */
%//};
%//struct Hpet {       /* High-Precision Event Timer DT */
%//  uchar sdthdr[36];   /* "HPET" + length[4] + [28] */
%//  uchar id[4];      /* Event Timer Block ID */
%//  uchar addr[12];   /* ACPI Format Address */
%//  uchar seqno;      /* Sequence Number */
%//  uchar minticks[2];    /* Minimum Clock Tick */
%//  uchar attr;     /* Page Protection */
%//};
%//typedef struct Mcfg {     /* PCI Memory Mapped Config */
%//  uchar sdthdr[36];   /* "MCFG" + length[4] + [28] */
%//  uchar pad[8];     /* reserved */
%//  Mcfgd mcfgd[];    /* descriptors */
%//} Mcfg;
%//struct Mcfgd {        /* MCFG Descriptor */
%//  uchar addr[8];    /* base address */
%//  uchar segno[2];   /* segment group number */
%//  uchar sbno;     /* start bus number */
%//  uchar ebno;     /* end bus number */
%//  uchar pad[4];     /* reserved */
%//};

\subsection*{[[arch/386/nvram.c]]}

<<nvram.c>>=
<<kernel basic includes>>

// used to be static
Lock nvrtlock;

uchar
nvramread(int addr)
{
    uchar data;

    ilock(&nvrtlock);
    outb(Paddr, addr);
    data = inb(PdataPort);
    iunlock(&nvrtlock);

    return data;
}

void
nvramwrite(int addr, uchar data)
{
    ilock(&nvrtlock);
    outb(Paddr, addr);
    outb(PdataPort, data);
    iunlock(&nvrtlock);
}
@


\subsection*{[[arch/386/realmode.c]]}

<<function realmodelink>>=
void
realmodelink(void)
{
    addarchfile("realmode", 0660, rtrapread, rtrapwrite);
    addarchfile("realmodemem", 0660, rmemread, rmemwrite);
}
@ 


<<realmode.c>>=
<<kernel basic includes>>

#include    "io.h"

#include    <tos.h>
#include    <ureg.h>

/*
 * Back the processor into real mode to run a BIOS call,
 * then return.  This must be used carefully, since it 
 * completely disables hardware interrupts (e.g., the i8259)
 * while running.  It is *not* using VM86 mode. 
 * Maybe that's really the right answer, but real mode
 * is fine for now.  We don't expect to use this very much --
 * just for VGA and APM.
 */
#define realmoderegs (*(Ureg*)RMUADDR)

#define LORMBUF (RMBUF-KZERO)

static Ureg rmu;
static Lock rmlock;

//@Scheck: Assembly
extern void realmode0(void);    /* in l.s */

void
realmode(Ureg *ureg)
{
    int s;
    ulong cr3;

    if(getconf("*norealmode"))
        return;

    lock(&rmlock);
    realmoderegs = *ureg;

    /* copy l.s so that it can be run from 16-bit mode */
    memmove((void*)RMCODE, (void*)KTZERO, 0x1000);

    s = splhi();
    cpu->pdproto[PDX(0)] = cpu->pdproto[PDX(KZERO)];    /* identity map low */
    cr3 = getcr3();
    putcr3(PADDR(cpu->pdproto));
    if (arch)
        arch->introff();
    else
        i8259off();
    realmode0();
    if(cpu->tss){
        /*
         * Called from memory.c before initialization of mmu.
         * Don't turn interrupts on before the kernel is ready!
         */
        if (arch)
            arch->intron();
        else
            i8259on();
    }
    cpu->pdproto[PDX(0)] = 0; /* remove low mapping */
    putcr3(cr3);
    splx(s);
    *ureg = realmoderegs;
    unlock(&rmlock);
}

static long
rtrapread(Chan*, void *a, long n, vlong off)
{
    if(off < 0)
        error("badarg");
    if(n+off > sizeof rmu)
        n = sizeof rmu - off;
    if(n <= 0)
        return 0;
    memmove(a, (char*)&rmu+off, n);
    return n;
}

static long
rtrapwrite(Chan*, void *a, long n, vlong off)
{
    if(off || n != sizeof rmu)
        error("write a Ureg");
    memmove(&rmu, a, sizeof rmu);
    /*
     * Sanity check
     */
    if(rmu.trap == 0x10){   /* VBE */
        rmu.es = (LORMBUF>>4)&0xF000;
        rmu.di = LORMBUF&0xFFFF;
    }else
        error("invalid trap arguments");
    realmode(&rmu);
    return n;
}

static long
rmemrw(int isr, void *a, long n, vlong off)
{
    if(off < 0 || n < 0)
        error("bad offset/count");
    if(isr){
        if(off >= MB)
            return 0;
        if(off+n >= MB)
            n = MB - off;
        memmove(a, KADDR((ulong)off), n);
    }else{
        /* realmode buf page ok, allow vga framebuf's access */
        if(off >= MB || off+n > MB ||
            (off < LORMBUF || off+n > LORMBUF+BY2PG) &&
            (off < 0xA0000 || off+n > 0xB0000+0x10000))
            error("bad offset/count in write");
        memmove(KADDR((ulong)off), a, n);
    }
    return n;
}

static long
rmemread(Chan*, void *a, long n, vlong off)
{
    return rmemrw(1, a, n, off);
}

static long
rmemwrite(Chan*, void *a, long n, vlong off)
{
    return rmemrw(0, a, n, off);
}

<<function realmodelink>>

@


\subsection*{[[arch/386/x16.h]]}

<<x16.h>>=
/*
 * Can't write 16-bit code for 8a without getting into
 * lots of bother, so define some simple commands and
 * output the code directly.
 * 
 * N.B. CALL16(x) kills DI, so don't expect it to be
 * saved across calls.
 */
#define rAX		0		/* rX  */
#define rCX		1
#define rDX		2
#define rBX		3
#define rSP		4		/* SP */
#define rBP		5		/* BP */
#define rSI		6		/* SI */
#define rDI		7		/* DI */

#define rAL		0		/* rL  */
#define rCL		1
#define rDL		2
#define rBL		3
#define rAH		4		/* rH */
#define rCH		5
#define rDH		6
#define rBH		7

#define rES		0		/* rS */
#define rCS		1
#define rSS		2
#define rDS		3
#define rFS		4
#define rGS		5

#define xSI		4		/* rI (index) */
#define xDI		5
#define xBP		6
#define xBX		7

#define rCR0		0		/* rC */
#define rCR2		2
#define rCR3		3
#define rCR4		4

#define OP(o, m, ro, rm)	BYTE $o;	/* op + modr/m byte */	\
   BYTE $(((m)<<6)|((ro)<<3)|(rm))
#define OPrm(o, r, m)	OP(o, 0x00, r, 0x06);	/* general r <-> m */	\
   WORD $m;
#define OPrr(o, r0, r1)	OP(o, 0x03, r0, r1);	/* general r -> r */

#define LW(m, rX)	OPrm(0x8B, rX, m)	/* m -> rX */
#define LXW(x, rI, r)	OP(0x8B, 0x02, r, rI);	/* x(rI) -> r */	\
   WORD $x
#define LBPW(x, r)	OP(0x8B, 0x02, r, xBP);	/* x(rBP) -> r */	\
   WORD $x
#define LB(m, rB)	OPrm(0x8A, rB, m)	/* m -> r[HL] */
#define LXB(x, rI, r)	OP(0x8A, 0x01, r, rI);	/* x(rI) -> r */	\
   BYTE $x
#define LBPB(x, r)	OP(0x8A, 0x01, r, xBP);	/* x(rBP) -> r */	\
   BYTE $x
#define SW(rX, m)	OPrm(0x89, rX, m)	/* rX -> m */
#define SXW(r, x, rI)	OP(0x89, 0x02, r, rI);	/* r -> x(rI) */	\
   WORD $x
#define SBPW(r, x)	OP(0x89, 0x02, r, xBP);	/* r -> x(rBP) */	\
   WORD $(x)
#define SBPWI(i, x)	OP(0xC7, 0x01, 0, xBP);	/* i -> x(rBP) */	\
   BYTE $(x); WORD $(i)
#define STB(rB, m)	OPrm(0x88, rB, m)	/* rB -> m */
#define SXB(r, x, rI)	OP(0x88, 0x01, r, rI);	/* rB -> x(rI) */	\
   BYTE $x
#define SBPB(r, x)	OP(0x88, 0x01, r, xBP);	/* r -> x(rBP) */	\
   BYTE $x
#define SBPBI(i, x)	OP(0xC6, 0x01, 0, xBP);	/* i -> x(rBP) */	\
   BYTE $(x); BYTE $(i)
#define LWI(i, rX)	BYTE $(0xB8+rX);	/* i -> rX */		\
   WORD $i;
#define LBI(i, rB)	BYTE $(0xB0+rB);	/* i -> r[HL] */	\
   BYTE $i

#define MW(r0, r1)	OPrr(0x89, r0, r1)	/* r0 -> r1 */
#define MFSR(rS, rX)	OPrr(0x8C, rS, rX)	/* rS -> rX */
#define MTSR(rX, rS)	OPrr(0x8E, rS, rX)	/* rX -> rS */
#define MFCR(rC, rX)	BYTE $0x0F;		/* rC -> rX */		\
   OP(0x20, 0x03, rC, rX)
#define MTCR(rX, rC)	BYTE $0x0F;		/* rX -> rC */		\
   OP(0x22, 0x03, rC, rX)

#define ADC(r0, r1)	OPrr(0x11, r0, r1)	/* r0 + r1 -> r1 */
#define ADD(r0, r1)	OPrr(0x01, r0, r1)	/* r0 + r1 -> r1 */
#define ADDI(i, r)	OP(0x81, 0x03, 0x00, r);/* i+r -> r */		\
   WORD $i;
#define AND(r0, r1)	OPrr(0x21, r0, r1)	/* r0&r1 -> r1 */
#define ANDI(i, r)	OP(0x81, 0x03, 0x04, r);/* i&r -> r */		\
   WORD $i;
#define CLR(r)		OPrr(0x31, r, r)	/* r^r -> r */
#define CLRB(r)		OPrr(0x30, r, r)	/* r^r -> r */
#define CMP(r0, r1)	OPrr(0x39, r0, r1)	/* r1-r0 -> flags */
#define CMPI(i, r)	OP(0x81, 0x03, 0x07, r);/* r-i -> flags */	\
   WORD $i;
#define CMPBR(r0, r1)	OPrr(0x38, r0, r1)	/* r1-r0 -> flags */
#define DEC(r)		BYTE $(0x48|r)		/* r-1 -> r */
#define DIV(r)		OPrr(0xF7, 0x06, r)	/* rDX:rAX/r -> rAX, rDX:rAX%r -> rDX */
#define INC(r)		BYTE $(0x40|r)		/* r+1 -> r */
#define MUL(r)		OPrr(0xF7, 0x04, r)	/* r*rAX -> rDX:rAX */
#define IMUL(r0, r1)	BYTE $0x0F;		/* r0*r1 -> r1 */	\
   OPrr(0xAF, r1, r0)	/* (signed) */
#define OR(r0, r1)	OPrr(0x09, r0, r1)	/* r0|r1 -> r1 */
#define ORB(r0, r1)	OPrr(0x08, r0, r1)	/* r0|r1 -> r1 */
#define ORI(i, r)	OP(0x81, 0x03, 0x01, r);/* i|r -> r */		\
   WORD $i;
#define ROLI(i, r)	OPrr(0xC1, 0x00, r);	/* r<<>>i -> r */	\
   BYTE $i;
#define SHLI(i, r)	OPrr(0xC1, 0x04, r);	/* r<<i -> r */		\
   BYTE $i;
#define SHLBI(i, r)	OPrr(0xC0, 0x04, r);	/* r<<i -> r */		\
   BYTE $i;
#define SHRI(i, r)	OPrr(0xC1, 0x05, r);	/* r>>i -> r */		\
   BYTE $i;
#define SHRBI(i, r)	OPrr(0xC0, 0x05, r);	/* r>>i -> r */		\
   BYTE $i;
#define SUB(r0, r1)	OPrr(0x29, r0, r1)	/* r1-r0 -> r1 */
#define SUBI(i, r)	OP(0x81, 0x03, 0x05, r);/* r-i -> r */		\
   WORD $i;

#define STOSW		STOSL

#define CALL16(f)	LWI(f, rDI);		/* &f -> rDI */		\
   BYTE $0xFF;		/* (*rDI) */		\
   BYTE $0xD7;
#define FARJUMP16(s, o)	BYTE $0xEA;		/* jump to ptr16:16 */	\
   WORD $o; WORD $s
#define FARJUMP32(s, o)	BYTE $0x66;		/* jump to ptr32:16 */	\
   BYTE $0xEA; LONG $o; WORD $s
#define	DELAY		BYTE $0xEB;		/* jmp .+2 */		\
   BYTE $0x00
#define BIOSCALL(b)	INT $b			/* INT $b */

#define PEEKW		BYTE $0x26;		/* MOVW	rES:[rBX], rAX  */	\
   BYTE $0x8B; BYTE $0x07
#define POKEW		BYTE $0x26;		/* MOVW	rAX, rES:[rBX] */	\
   BYTE $0x89; BYTE $0x07
#define OUTPORTB(p, d)	LBI(d, rAL);		/* d -> I/O port p */	\
   BYTE $0xE6;					\
   BYTE $p; DELAY
#define PUSHA		BYTE $0x60
#define PUSHR(r)	BYTE $(0x50|r)		/* r  -> (--rSP) */
#define PUSHS(rS)	BYTE $(0x06|((rS)<<3))	/* rS  -> (--rSP) */
#define PUSHI(i)	BYTE $0x68; WORD $i;	/* i -> --(rSP) */
#define POPA		BYTE $0x61
#define POPR(r)		BYTE $(0x58|r)		/* (rSP++) -> r */
#define POPS(rS)	BYTE $(0x07|((rS)<<3))	/* (rSP++) -> r */
#define NOP		BYTE $0x90		/* nop */

#define LGDT(gdtptr)	BYTE $0x0F;		/* LGDT */			\
   BYTE $0x01; BYTE $0x16;					\
   WORD $gdtptr

/* operand size switch. */
#define OPSIZE		BYTE $0x66

@
%$
% >> >>

\subsection*{[[buses/386/dat_buses.h]]}

<<struct ISAConf>>=
struct ISAConf {
  char  *type;
  ulong port;
  int irq;
  ulong dma;
  ulong mem;
  ulong size;
  ulong freq;

  int nopt;
  char  *opt[NISAOPT];
};
@ 


<<constant NISAOPT>>=
#define NISAOPT   8
@ 


<<dat_buses.h>>=

/*
 *  a parsed plan9.ini line
 */
<<constant NISAOPT>>

<<struct ISAConf>>
@


\subsection*{[[buses/386/dma.c]]}

\ifallcode
<<dma.c forward decl>>=
typedef struct DMAport  DMAport;
typedef struct DMA  DMA;
typedef struct DMAxfer  DMAxfer;
@
\fi

<<dma.c>>=
<<kernel basic includes>>

<<dma.c forward decl>>

/*
 *  state of a dma transfer
 */
struct DMAxfer
{
    ulong   bpa;        /* bounce buffer physical address */
    void*   bva;        /* bounce buffer virtual address */
    int blen;       /* bounce buffer length */
    void*   va;     /* virtual address destination/src */
    long    len;        /* bytes to be transferred */
    int isread;
};

/*
 *  the dma controllers.  the first half of this structure specifies
 *  the I/O ports used by the DMA controllers.
 */
//@Scheck: unnamed substructure
struct DMAport
{
    uchar   addr[4];    /* current address (4 channels) */
    uchar   count[4];   /* current count (4 channels) */
    uchar   page[4];    /* page registers (4 channels) */
    uchar   cmd;        /* command status register */
    uchar   req;        /* request registers */
    uchar   sbm;        /* single bit mask register */
    uchar   mode;       /* mode register */
    uchar   cbp;        /* clear byte pointer */
    uchar   mc;     /* master clear */
    uchar   cmask;      /* clear mask register */
    uchar   wam;        /* write all mask register bit */
};

struct DMA
{
    DMAport;
    int shift;
    Lock;
    DMAxfer x[4];
};

DMA dma[2] = {
    { 0x00, 0x02, 0x04, 0x06,
      0x01, 0x03, 0x05, 0x07,
      0x87, 0x83, 0x81, 0x82,
      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
     0 },

    { 0xc0, 0xc4, 0xc8, 0xcc,
      0xc2, 0xc6, 0xca, 0xce,
      0x8f, 0x8b, 0x89, 0x8a,
      0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
     1 },
};

extern int i8237dma;
static void* i8237bva[2];
static int i8237used;

/*
 *  DMA must be in the first 16MB.  This gets called early by the
 *  initialisation routines of any devices which require DMA to ensure
 *  the allocated bounce buffers are below the 16MB limit.
 */
void
_i8237alloc(void)
{
    void* bva;

    if(i8237dma <= 0)
        return;
    if(i8237dma > 2)
        i8237dma = 2;

    bva = xspanalloc(64*1024*i8237dma, BY2PG, 64*1024);
    if(bva == nil || PADDR(bva)+64*1024*i8237dma > 16*MB){
        /*
         * This will panic with the current
         * implementation of xspanalloc().
        if(bva != nil)
            xfree(bva);
         */
        return;
    }

    i8237bva[0] = bva;
    if(i8237dma == 2)
        i8237bva[1] = ((uchar*)i8237bva[0])+64*1024;
}

/*
 *  DMA must be in the first 16MB.  This gets called early by the
 *  initialisation routines of any devices which require DMA to ensure
 *  the allocated bounce buffers are below the 16MB limit.
 */
int
dmainit(int chan, int maxtransfer)
{
    DMA *dp;
    DMAxfer *xp;
    static int once;

    if(once == 0){
        if(ioalloc(0x00, 0x10, 0, "dma") < 0
        || ioalloc(0x80, 0x10, 0, "dma") < 0
        || ioalloc(0xd0, 0x10, 0, "dma") < 0)
            panic("dmainit");
        once = 1;
    }

    if(maxtransfer > 64*1024)
        maxtransfer = 64*1024;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;
    xp = &dp->x[chan];
    if(xp->bva != nil){
        if(xp->blen < maxtransfer)
            return 1;
        return 0;
    }

    if(i8237used >= i8237dma || i8237bva[i8237used] == nil){
        print("no i8237 DMA bounce buffer < 16MB\n");
        return 1;
    }
    xp->bva = i8237bva[i8237used++];
    xp->bpa = PADDR(xp->bva);
    xp->blen = maxtransfer;
    xp->len = 0;
    xp->isread = 0;

    return 0;
}

/*
 *  setup a dma transfer.  if the destination is not in kernel
 *  memory, allocate a page for the transfer.
 *
 *  we assume BIOS has set up the command register before we
 *  are booted.
 *
 *  return the updated transfer length (we can't transfer across 64k
 *  boundaries)
 */
long
dmasetup(int chan, void *va, long len, int isread)
{
    DMA *dp;
    ulong pa;
    uchar mode;
    DMAxfer *xp;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;
    xp = &dp->x[chan];

    /*
     *  if this isn't kernel memory or crossing 64k boundary or above 16 meg
     *  use the bounce buffer.
     */
    if((ulong)va < KZERO 
    || ((pa=PADDR(va))&0xFFFF0000) != ((pa+len)&0xFFFF0000)
    || pa >= 16*MB){
        if(xp->bva == nil)
            return -1;
        if(len > xp->blen)
            len = xp->blen;
        if(!isread)
            memmove(xp->bva, va, len);
        xp->va = va;
        xp->len = len;
        xp->isread = isread;
        pa = xp->bpa;
    }
    else
        xp->len = 0;

    /*
     * this setup must be atomic
     */
    ilock(dp);
    mode = (isread ? 0x44 : 0x48) | chan;
    outb(dp->mode, mode);   /* single mode dma (give CPU a chance at mem) */
    outb(dp->page[chan], pa>>16);
    outb(dp->cbp, 0);       /* set count & address to their first byte */
    outb(dp->addr[chan], pa>>dp->shift);        /* set address */
    outb(dp->addr[chan], pa>>(8+dp->shift));
    outb(dp->count[chan], (len>>dp->shift)-1);      /* set count */
    outb(dp->count[chan], ((len>>dp->shift)-1)>>8);
    outb(dp->sbm, chan);        /* enable the channel */
    iunlock(dp);

    return len;
}

/*
 *  this must be called after a dma has been completed.
 *
 *  if a page has been allocated for the dma,
 *  copy the data into the actual destination
 *  and free the page.
 */
void
dmaend(int chan)
{
    DMA *dp;
    DMAxfer *xp;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;

    /*
     *  disable the channel
     */
    ilock(dp);
    outb(dp->sbm, 4|chan);
    iunlock(dp);

    xp = &dp->x[chan];
    if(xp->len == 0 || !xp->isread)
        return;

    /*
     *  copy out of temporary page
     */
    memmove(xp->va, xp->bva, xp->len);
    xp->len = 0;
}

@

%//int
%//dmacount(int chan)
%//{
%//  int     retval;
%//  DMA     *dp;
%// 
%//  dp = &dma[(chan>>2)&1];
%//  outb(dp->cbp, 0);
%//  retval = inb(dp->count[chan]);
%//  retval |= inb(dp->count[chan]) << 8;
%//  return((retval<<dp->shift)+1);
%//}
%
%//int
%//dmadone(int chan)
%//{
%//  DMA *dp;
%//
%//  dp = &dma[(chan>>2)&1];
%//  chan = chan & 3;
%//
%//  return inb(dp->cmd) & (1<<chan);
%//}



\subsection*{[[buses/386/pci.c]]}

\ifallcode
<<pci.c forward decl>>=
void    pcicfgw16(Pcidev*, int, int);
ulong   pcibarsize(Pcidev*, int);
void    pcibussize(Pcidev*, ulong*, ulong*);
void    pcihinv(Pcidev*);
uchar   pciipin(Pcidev*, uchar);

typedef struct Slot Slot;
typedef struct Bridge Bridge;
typedef struct Router Router;
@

<<pci.c debugging macro>>=
#define DBG if(0) pcilog

int
pcilog(char *fmt, ...)
{
    int n;
    va_list arg;
    char buf[PRINTSIZE];

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    memmove(PCICONS.output+PCICONS.ptr, buf, n);
    PCICONS.ptr += n;
    return n;
}

@ 
\fi

<<global southbridges>>=
static Bridge southbridges[] = {
    { 0x8086, 0x122e, pIIxget, pIIxset },   /* Intel 82371FB */
    { 0x8086, 0x1234, pIIxget, pIIxset },   /* Intel 82371MX */
    { 0x8086, 0x7000, pIIxget, pIIxset },   /* Intel 82371SB */
    { 0x8086, 0x7110, pIIxget, pIIxset },   /* Intel 82371AB */
    { 0x8086, 0x7198, pIIxget, pIIxset },   /* Intel 82443MX (fn 1) */
    { 0x8086, 0x2410, pIIxget, pIIxset },   /* Intel 82801AA */
    { 0x8086, 0x2420, pIIxget, pIIxset },   /* Intel 82801AB */
    { 0x8086, 0x2440, pIIxget, pIIxset },   /* Intel 82801BA */
    { 0x8086, 0x2448, pIIxget, pIIxset },   /* Intel 82801BAM/CAM/DBM */
    { 0x8086, 0x244c, pIIxget, pIIxset },   /* Intel 82801BAM */
    { 0x8086, 0x244e, pIIxget, pIIxset },   /* Intel 82801 */
    { 0x8086, 0x2480, pIIxget, pIIxset },   /* Intel 82801CA */
    { 0x8086, 0x248c, pIIxget, pIIxset },   /* Intel 82801CAM */
    { 0x8086, 0x24c0, pIIxget, pIIxset },   /* Intel 82801DBL */
    { 0x8086, 0x24cc, pIIxget, pIIxset },   /* Intel 82801DBM */
    { 0x8086, 0x24d0, pIIxget, pIIxset },   /* Intel 82801EB */
    { 0x8086, 0x25a1, pIIxget, pIIxset },   /* Intel 6300ESB */
    { 0x8086, 0x2640, pIIxget, pIIxset },   /* Intel 82801FB */
    { 0x8086, 0x2641, pIIxget, pIIxset },   /* Intel 82801FBM */
    { 0x8086, 0x27b8, pIIxget, pIIxset },   /* Intel 82801GB */
    { 0x8086, 0x27b9, pIIxget, pIIxset },   /* Intel 82801GBM */
    { 0x8086, 0x27bd, pIIxget, pIIxset },   /* Intel 82801GB/GR */
    { 0x8086, 0x3a16, pIIxget, pIIxset },   /* Intel 82801JIR */
    { 0x8086, 0x3a40, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x3a42, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x3a48, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x2916, pIIxget, pIIxset },   /* Intel 82801? */
    { 0x8086, 0x1c02, pIIxget, pIIxset },   /* Intel 6 Series/C200 */
    { 0x8086, 0x1c44, pIIxget, pIIxset },   /* Intel 6 Series/Z68 Express */
    { 0x8086, 0x1e53, pIIxget, pIIxset },   /* Intel 7 Series/C216 */
    { 0x1106, 0x0586, viaget, viaset }, /* Viatech 82C586 */
    { 0x1106, 0x0596, viaget, viaset }, /* Viatech 82C596 */
    { 0x1106, 0x0686, viaget, viaset }, /* Viatech 82C686 */
    { 0x1106, 0x3227, viaget, viaset }, /* Viatech VT8237 */
    { 0x1045, 0xc700, optiget, optiset },   /* Opti 82C700 */
    { 0x10b9, 0x1533, aliget, aliset }, /* Al M1533 */
    { 0x1039, 0x0008, pIIxget, pIIxset },   /* SI 503 */
    { 0x1039, 0x0496, pIIxget, pIIxset },   /* SI 496 */
    { 0x1078, 0x0100, cyrixget, cyrixset }, /* Cyrix 5530 Legacy */

    { 0x1022, 0x746B, nil, nil },       /* AMD 8111 */
    { 0x10DE, 0x00D1, nil, nil },       /* NVIDIA nForce 3 */
    { 0x10DE, 0x00E0, nil, nil },       /* NVIDIA nForce 3 250 Series */
    { 0x10DE, 0x00E1, nil, nil },       /* NVIDIA nForce 3 250 Series */
    { 0x1166, 0x0200, nil, nil },       /* ServerWorks ServerSet III LE */
    { 0x1002, 0x4377, nil, nil },       /* ATI Radeon Xpress 200M */
    { 0x1002, 0x4372, nil, nil },       /* ATI SB400 */
};
@ 


<<function upareserve>>=
void
upareserve(ulong pa, int size)
{
    ulong a;
    
    a = mapalloc(&rmapupa, pa, size, 0);
    if(a != pa){
        /*
         * This can happen when we're using the E820
         * map, which might have already reserved some
         * of the regions claimed by the pci devices.
         */
    //  print("upareserve: cannot reserve pa=%#.8lux size=%d\n", pa, size);
        if(a != 0)
            mapfree(&rmapupa, a, size);
    }
}
@


<<pci.c>>=
/*
 * PCI support code.
 * Needs a massive rewrite.
 */
<<kernel basic includes>>
#include "io.h"

/* let each port override any of these */
#ifndef PCICONSSIZE
#define PCICONSSIZE (16*1024)
#endif

struct PCICons
{
    char    output[PCICONSSIZE];
    int ptr;
};
struct PCICons PCICONS;

int pcivga;

<<pci.c forward decl>>

<<pci.c debugging macro>>


enum
{                   /* configuration mechanism #1 */
    PciADDR     = 0xCF8,    /* CONFIG_ADDRESS */
    PciDATA     = 0xCFC,    /* CONFIG_DATA */

                    /* configuration mechanism #2 */
    PciCSE      = 0xCF8,    /* configuration space enable */
    PciFORWARD  = 0xCFA,    /* which bus */

    MaxFNO      = 7,
    MaxUBN      = 255,
};

enum
{                   /* command register */
    IOen        = (1<<0),
    MEMen       = (1<<1),
    MASen       = (1<<2),
    MemWrInv    = (1<<4),
    PErrEn      = (1<<6),
    SErrEn      = (1<<8),
};

static Lock pcicfglock;
static Lock pcicfginitlock;
static int pcicfgmode = -1;
static int pcimaxbno = 7;
static int pcimaxdno;
static Pcidev* pciroot;
static Pcidev* pcilist;
static Pcidev* pcitail;
static int nobios, nopcirouting;
static BIOS32si* pcibiossi;

static int pcicfgrw8raw(int, int, int, int);
static int pcicfgrw16raw(int, int, int, int);
static int pcicfgrw32raw(int, int, int, int);

static int (*pcicfgrw8)(int, int, int, int) = pcicfgrw8raw;
static int (*pcicfgrw16)(int, int, int, int) = pcicfgrw16raw;
static int (*pcicfgrw32)(int, int, int, int) = pcicfgrw32raw;

static char* bustypes[] = {
    "CBUSI",
    "CBUSII",
    "EISA",
    "FUTURE",
    "INTERN",
    "ISA",
    "MBI",
    "MBII",
    "MCA",
    "MPI",
    "MPSA",
    "NUBUS",
    "PCI",
    "PCMCIA",
    "TC",
    "VL",
    "VME",
    "XPRESS",
};

static int
tbdffmt(Fmt* fmt)
{
    char *p;
    int l, r;
    uint type, tbdf;

    if((p = malloc(READSTR)) == nil)
        return fmtstrcpy(fmt, "(tbdfconv)");

    switch(fmt->r){
    case 'T':
        tbdf = va_arg(fmt->args, int);
        if(tbdf == BUSUNKNOWN)
            snprint(p, READSTR, "unknown");
        else{
            type = BUSTYPE(tbdf);
            if(type < nelem(bustypes))
                l = snprint(p, READSTR, bustypes[type]);
            else
                l = snprint(p, READSTR, "%d", type);
            snprint(p+l, READSTR-l, ".%d.%d.%d",
                BUSBNO(tbdf), BUSDNO(tbdf), BUSFNO(tbdf));
        }
        break;

    default:
        snprint(p, READSTR, "(tbdfconv)");
        break;
    }
    r = fmtstrcpy(fmt, p);
    free(p);

    return r;
}

ulong
pcibarsize(Pcidev *p, int rno)
{
    ulong v, size;

    v = pcicfgrw32(p->tbdf, rno, 0, 1);
    pcicfgrw32(p->tbdf, rno, 0xFFFFFFF0, 0);
    size = pcicfgrw32(p->tbdf, rno, 0, 1);
    if(v & 1)
        size |= 0xFFFF0000;
    pcicfgrw32(p->tbdf, rno, v, 0);

    return -(size & ~0x0F);
}

static int
pcisizcmp(void *a, void *b)
{
    Pcisiz *aa, *bb;

    aa = a;
    bb = b;
    return aa->siz - bb->siz;
}

static ulong
pcimask(ulong v)
{
    ulong m;

    m = BI2BY*sizeof(v);
    for(m = 1<<(m-1); m != 0; m >>= 1) {
        if(m & v)
            break;
    }

    m--;
    if((v & m) == 0)
        return v;

    v |= m;
    return v+1;
}

static void
pcibusmap(Pcidev *root, ulong *pmema, ulong *pioa, int wrreg)
{
    Pcidev *p;
    int ntb, i, size, rno, hole;
    ulong v, mema, ioa, sioa, smema, base, limit;
    Pcisiz *table, *tptr, *mtb, *itb;

    if(!nobios)
        return;

    ioa = *pioa;
    mema = *pmema;

    DBG("pcibusmap wr=%d %T mem=%luX io=%luX\n",
        wrreg, root->tbdf, mema, ioa);

    ntb = 0;
    for(p = root; p != nil; p = p->link)
        ntb++;

    ntb *= (PciCIS-PciBAR0)/4;
    table = malloc(2*ntb*sizeof(Pcisiz));
    if(table == nil)
        panic("pcibusmap: no memory");
    itb = table;
    mtb = table+ntb;

    /*
     * Build a table of sizes
     */
    for(p = root; p != nil; p = p->link) {
        if(p->ccrb == 0x06) {
            if(p->ccru != 0x04 || p->bridge == nil) {
//              DBG("pci: ignored bridge %T\n", p->tbdf);
                continue;
            }

            sioa = ioa;
            smema = mema;
            pcibusmap(p->bridge, &smema, &sioa, 0);

            hole = pcimask(smema-mema);
            if(hole < (1<<20))
                hole = 1<<20;
            p->mema.size = hole;

            hole = pcimask(sioa-ioa);
            if(hole < (1<<12))
                hole = 1<<12;

            p->ioa.size = hole;

            itb->dev = p;
            itb->bar = -1;
            itb->siz = p->ioa.size;
            itb++;

            mtb->dev = p;
            mtb->bar = -1;
            mtb->siz = p->mema.size;
            mtb++;
            continue;
        }

        for(i = 0; i <= 5; i++) {
            rno = PciBAR0 + i*4;
            v = pcicfgrw32(p->tbdf, rno, 0, 1);
            size = pcibarsize(p, rno);
            if(size == 0)
                continue;

            if(v & 1) {
                itb->dev = p;
                itb->bar = i;
                itb->siz = size;
                itb++;
            }
            else {
                mtb->dev = p;
                mtb->bar = i;
                mtb->siz = size;
                mtb++;
            }

            p->mem[i].size = size;
        }
    }

    /*
     * Sort both tables IO smallest first, Memory largest
     */
    qsort(table, itb-table, sizeof(Pcisiz), pcisizcmp);
    tptr = table+ntb;
    qsort(tptr, mtb-tptr, sizeof(Pcisiz), pcisizcmp);

    /*
     * Allocate IO address space on this bus
     */
    for(tptr = table; tptr < itb; tptr++) {
        hole = tptr->siz;
        if(tptr->bar == -1)
            hole = 1<<12;
        ioa = ROUND(ioa, hole);

        p = tptr->dev;
        if(tptr->bar == -1)
            p->ioa.bar = ioa;
        else {
            p->pcr |= IOen;
            p->mem[tptr->bar].bar = ioa|1;
            if(wrreg)
                pcicfgrw32(p->tbdf, PciBAR0+(tptr->bar*4), ioa|1, 0);
        }

        ioa += tptr->siz;
    }

    /*
     * Allocate Memory address space on this bus
     */
    for(tptr = table+ntb; tptr < mtb; tptr++) {
        hole = tptr->siz;
        if(tptr->bar == -1)
            hole = 1<<20;
        mema = ROUND(mema,hole);

        p = tptr->dev;
        if(tptr->bar == -1)
            p->mema.bar = mema;
        else {
            p->pcr |= MEMen;
            p->mem[tptr->bar].bar = mema;
            if(wrreg)
                pcicfgrw32(p->tbdf, PciBAR0+(tptr->bar*4), mema, 0);
        }
        mema += tptr->siz;
    }

    *pmema = mema;
    *pioa = ioa;
    free(table);

    if(wrreg == 0)
        return;

    /*
     * Finally set all the bridge addresses & registers
     */
    for(p = root; p != nil; p = p->link) {
        if(p->bridge == nil) {
            pcicfgrw8(p->tbdf, PciLTR, 64, 0);

            p->pcr |= MASen;
            pcicfgrw16(p->tbdf, PciPCR, p->pcr, 0);
            continue;
        }

        base = p->ioa.bar;
        limit = base+p->ioa.size-1;
        v = pcicfgrw32(p->tbdf, PciIBR, 0, 1);
        v = (v&0xFFFF0000)|(limit & 0xF000)|((base & 0xF000)>>8);
        pcicfgrw32(p->tbdf, PciIBR, v, 0);
        v = (limit & 0xFFFF0000)|(base>>16);
        pcicfgrw32(p->tbdf, PciIUBR, v, 0);

        base = p->mema.bar;
        limit = base+p->mema.size-1;
        v = (limit & 0xFFF00000)|((base & 0xFFF00000)>>16);
        pcicfgrw32(p->tbdf, PciMBR, v, 0);

        /*
         * Disable memory prefetch
         */
        pcicfgrw32(p->tbdf, PciPMBR, 0x0000FFFF, 0);
        pcicfgrw8(p->tbdf, PciLTR, 64, 0);

        /*
         * Enable the bridge
         */
        p->pcr |= IOen|MEMen|MASen;
        pcicfgrw32(p->tbdf, PciPCR, 0xFFFF0000|p->pcr , 0);

        sioa = p->ioa.bar;
        smema = p->mema.bar;
        pcibusmap(p->bridge, &smema, &sioa, 1);
    }
}

/* side effect: if a video controller is seen, set pcivga non-zero */
static int
pcilscan(int bno, Pcidev** list)
{
    Pcidev *p, *head, *tail;
    int dno, fno, i, hdt, l, maxfno, maxubn, rno, sbn, tbdf, ubn;

    maxubn = bno;
    head = nil;
    tail = nil;
    for(dno = 0; dno <= pcimaxdno; dno++){
        maxfno = 0;
        for(fno = 0; fno <= maxfno; fno++){
            /*
             * For this possible device, form the
             * bus+device+function triplet needed to address it
             * and try to read the vendor and device ID.
             * If successful, allocate a device struct and
             * start to fill it in with some useful information
             * from the device's configuration space.
             */
            tbdf = MKBUS(BusPCI, bno, dno, fno);
            l = pcicfgrw32(tbdf, PciVID, 0, 1);
            if(l == 0xFFFFFFFF || l == 0)
                continue;
            p = malloc(sizeof(*p));
            if(p == nil)
                panic("pcilscan: no memory");
            p->tbdf = tbdf;
            p->vid = l;
            p->did = l>>16;

            if(pcilist != nil)
                pcitail->list = p;
            else
                pcilist = p;
            pcitail = p;

            p->pcr = pcicfgr16(p, PciPCR);
            p->rid = pcicfgr8(p, PciRID);
            p->ccrp = pcicfgr8(p, PciCCRp);
            p->ccru = pcicfgr8(p, PciCCRu);
            p->ccrb = pcicfgr8(p, PciCCRb);
            p->cls = pcicfgr8(p, PciCLS);
            p->ltr = pcicfgr8(p, PciLTR);

            p->intl = pcicfgr8(p, PciINTL);

            /*
             * If the device is a multi-function device adjust the
             * loop count so all possible functions are checked.
             */
            hdt = pcicfgr8(p, PciHDT);
            if(hdt & 0x80)
                maxfno = MaxFNO;

            /*
             * If appropriate, read the base address registers
             * and work out the sizes.
             */
            switch(p->ccrb) {
            case 0x03:      /* display controller */
                pcivga = 1;
                /* fall through */
            case 0x01:      /* mass storage controller */
            case 0x02:      /* network controller */
            case 0x04:      /* multimedia device */
            case 0x07:      /* simple comm. controllers */
            case 0x08:      /* base system peripherals */
            case 0x09:      /* input devices */
            case 0x0A:      /* docking stations */
            case 0x0B:      /* processors */
            case 0x0C:      /* serial bus controllers */
                if((hdt & 0x7F) != 0)
                    break;
                rno = PciBAR0 - 4;
                for(i = 0; i < nelem(p->mem); i++) {
                    rno += 4;
                    p->mem[i].bar = pcicfgr32(p, rno);
                    p->mem[i].size = pcibarsize(p, rno);
                }
                break;

            case 0x00:
            case 0x05:      /* memory controller */
            case 0x06:      /* bridge device */
            default:
                break;
            }

            if(head != nil)
                tail->link = p;
            else
                head = p;
            tail = p;
        }
    }

    *list = head;
    for(p = head; p != nil; p = p->link){
        /*
         * Find PCI-PCI bridges and recursively descend the tree.
         */
        if(p->ccrb != 0x06 || p->ccru != 0x04)
            continue;

        /*
         * If the secondary or subordinate bus number is not
         * initialised try to do what the PCI BIOS should have
         * done and fill in the numbers as the tree is descended.
         * On the way down the subordinate bus number is set to
         * the maximum as it's not known how many buses are behind
         * this one; the final value is set on the way back up.
         */
        sbn = pcicfgr8(p, PciSBN);
        ubn = pcicfgr8(p, PciUBN);

        if(sbn == 0 || ubn == 0 || nobios) {
            sbn = maxubn+1;
            /*
             * Make sure memory, I/O and master enables are
             * off, set the primary, secondary and subordinate
             * bus numbers and clear the secondary status before
             * attempting to scan the secondary bus.
             *
             * Initialisation of the bridge should be done here.
             */
            pcicfgw32(p, PciPCR, 0xFFFF0000);
            l = (MaxUBN<<16)|(sbn<<8)|bno;
            pcicfgw32(p, PciPBN, l);
            pcicfgw16(p, PciSPSR, 0xFFFF);
            maxubn = pcilscan(sbn, &p->bridge);
            l = (maxubn<<16)|(sbn<<8)|bno;

            pcicfgw32(p, PciPBN, l);
        }
        else {
            if(ubn > maxubn)
                maxubn = ubn;
            pcilscan(sbn, &p->bridge);
        }
    }

    return maxubn;
}

static uchar
pIIxget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 0x60, 0x61, 0x62, 0x63 */
    pirq = pcicfgr8(router, link);
    return (pirq < 16)? pirq: 0;
}

static void
pIIxset(Pcidev *router, uchar link, uchar irq)
{
    pcicfgw8(router, link, irq);
}

static uchar
viaget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 1, 2, 3, 5 */
    pirq = (link < 6)? pcicfgr8(router, 0x55 + (link>>1)): 0;

    return (link & 1)? (pirq >> 4): (pirq & 15);
}

static void
viaset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0x55 + (link >> 1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0x55 + (link>>1), pirq);
}

static uchar
optiget(Pcidev *router, uchar link)
{
    uchar pirq = 0;

    /* link should be 0x02, 0x12, 0x22, 0x32 */
    if ((link & 0xcf) == 0x02)
        pirq = pcicfgr8(router, 0xb8 + (link >> 5));
    return (link & 0x10)? (pirq >> 4): (pirq & 15);
}

static void
optiset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0xb8 + (link >> 5));
        pirq &= (link & 0x10)? 0x0f : 0xf0;
        pirq |= (link & 0x10)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0xb8 + (link >> 5), pirq);
}

static uchar
aliget(Pcidev *router, uchar link)
{
    /* No, you're not dreaming */
    static const uchar map[] = { 0, 9, 3, 10, 4, 5, 7, 6, 1, 11, 0, 12, 0, 14, 0, 15 };
    uchar pirq;

    /* link should be 0x01..0x08 */
    pirq = pcicfgr8(router, 0x48 + ((link-1)>>1));
    return (link & 1)? map[pirq&15]: map[pirq>>4];
}

static void
aliset(Pcidev *router, uchar link, uchar irq)
{
    /* Inverse of map in aliget */
    static const uchar map[] = { 0, 8, 0, 2, 4, 5, 7, 6, 0, 1, 3, 9, 11, 0, 13, 15 };
    uchar pirq;

    pirq = pcicfgr8(router, 0x48 + ((link-1)>>1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (map[irq] << 4): (map[irq] & 15);
    pcicfgw8(router, 0x48 + ((link-1)>>1), pirq);
}

static uchar
cyrixget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 1, 2, 3, 4 */
    pirq = pcicfgr8(router, 0x5c + ((link-1)>>1));
    return ((link & 1)? pirq >> 4: pirq & 15);
}

static void
cyrixset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0x5c + (link>>1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0x5c + (link>>1), pirq);
}

struct Bridge
{
    ushort  vid;
    ushort  did;
    uchar   (*get)(Pcidev *, uchar);
    void    (*set)(Pcidev *, uchar, uchar);
};

<<global southbridges>>

struct Slot {
    uchar   bus;        /* Pci bus number */
    uchar   dev;        /* Pci device number */
    uchar   maps[12];   /* Avoid structs!  Link and mask. */
    uchar   slot;       /* Add-in/built-in slot */
    uchar   reserved;
};

struct Router {
    uchar   signature[4];   /* Routing table signature */
    uchar   version[2]; /* Version number */
    uchar   size[2];    /* Total table size */
    uchar   bus;        /* Interrupt router bus number */
    uchar   devfn;      /* Router's devfunc */
    uchar   pciirqs[2]; /* Exclusive PCI irqs */
    uchar   compat[4];  /* Compatible PCI interrupt router */
    uchar   miniport[4];    /* Miniport data */
    uchar   reserved[11];
    uchar   checksum;
};

static ushort pciirqs;      /* Exclusive PCI irqs */
static Bridge *southbridge; /* Which southbridge to use. */

static void
pcirouting(void)
{
    Slot *e;
    Router *r;
    int size, i, fn, tbdf;
    Pcidev *sbpci, *pci;
    uchar *p, pin, irq, link, *map;

    /* Search for PCI interrupt routing table in BIOS */
    for(p = (uchar *)KADDR(0xf0000); p < (uchar *)KADDR(0xfffff); p += 16)
        if(p[0] == '$' && p[1] == 'P' && p[2] == 'I' && p[3] == 'R')
            break;

    if(p >= (uchar *)KADDR(0xfffff)) {
        // print("no PCI intr routing table found\n");
        return;
    }

    r = (Router *)p;

    if (0)
        print("PCI interrupt routing table version %d.%d at %#.6luX\n",
            r->version[0], r->version[1], (ulong)r & 0xfffff);

    tbdf = (BusPCI << 24)|(r->bus << 16)|(r->devfn << 8);
    sbpci = pcimatchtbdf(tbdf);
    if(sbpci == nil) {
        print("pcirouting: Cannot find south bridge %T\n", tbdf);
        return;
    }

    for(i = 0; i != nelem(southbridges); i++)
        if(sbpci->vid == southbridges[i].vid && sbpci->did == southbridges[i].did)
            break;

    if(i == nelem(southbridges)) {
        print("pcirouting: ignoring south bridge %T %.4uX/%.4uX\n", tbdf, sbpci->vid, sbpci->did);
        return;
    }
    southbridge = &southbridges[i];
    if(southbridge->get == nil || southbridge->set == nil)
        return;

    pciirqs = (r->pciirqs[1] << 8)|r->pciirqs[0];

    size = (r->size[1] << 8)|r->size[0];
    for(e = (Slot *)&r[1]; (uchar *)e < p + size; e++) {
        if (0) {
            print("%.2uX/%.2uX %.2uX: ", e->bus, e->dev, e->slot);
            for (i = 0; i != 4; i++) {
                uchar *m = &e->maps[i * 3];
                print("[%d] %.2uX %.4uX ",
                    i, m[0], (m[2] << 8)|m[1]);
            }
            print("\n");
        }
        for(fn = 0; fn != 8; fn++) {
            tbdf = (BusPCI << 24)|(e->bus << 16)|((e->dev | fn) << 8);
            pci = pcimatchtbdf(tbdf);
            if(pci == nil)
                continue;
            pin = pcicfgr8(pci, PciINTP);
            if(pin == 0 || pin == 0xff)
                continue;

            map = &e->maps[(pin - 1) * 3];
            link = map[0];
            irq = southbridge->get(sbpci, link);
            if(irq == 0 || irq == pci->intl)
                continue;
            if(pci->intl != 0 && pci->intl != 0xFF) {
                print("pcirouting: BIOS workaround: %T at pin %d link %d irq %d -> %d\n",
                      tbdf, pin, link, irq, pci->intl);
                southbridge->set(sbpci, link, pci->intl);
                continue;
            }
            print("pcirouting: %T at pin %d link %d irq %d\n", tbdf, pin, link, irq);
            pcicfgw8(pci, PciINTL, irq);
            pci->intl = irq;
        }
    }
}

static void pcireservemem(void);

static int
pcicfgrw8bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB108;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx & 0xFF;
    }
    else{
        ci.eax = 0xB10B;
        ci.ecx = data & 0xFF;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static int
pcicfgrw16bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB109;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx & 0xFFFF;
    }
    else{
        ci.eax = 0xB10C;
        ci.ecx = data & 0xFFFF;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static int
pcicfgrw32bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB10A;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx;
    }
    else{
        ci.eax = 0xB10D;
        ci.ecx = data;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static BIOS32si*
pcibiosinit(void)
{
    BIOS32ci ci;
    BIOS32si *si;

    if((si = bios32open("$PCI")) == nil)
        return nil;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.eax = 0xB101;
    if(bios32ci(si, &ci) || ci.edx != ((' '<<24)|('I'<<16)|('C'<<8)|'P')){
        free(si);
        return nil;
    }
    if(ci.eax & 0x01)
        pcimaxdno = 31;
    else
        pcimaxdno = 15;
    pcimaxbno = ci.ecx & 0xff;

    return si;
}

void
pcibussize(Pcidev *root, ulong *msize, ulong *iosize)
{
    *msize = 0;
    *iosize = 0;
    pcibusmap(root, msize, iosize, 0);
}

static void
pcicfginit(void)
{
    char *p;
    Pcidev **list;
    ulong mema, ioa;
    int bno, n, pcibios;

    lock(&pcicfginitlock);
    if(pcicfgmode != -1)
        goto out;

    pcibios = 0;
    if(getconf("*nobios"))
        nobios = 1;
    else if(getconf("*pcibios"))
        pcibios = 1;
    if(getconf("*nopcirouting"))
        nopcirouting = 1;

    /*
     * Try to determine which PCI configuration mode is implemented.
     * Mode2 uses a byte at 0xCF8 and another at 0xCFA; Mode1 uses
     * a DWORD at 0xCF8 and another at 0xCFC and will pass through
     * any non-DWORD accesses as normal I/O cycles. There shouldn't be
     * a device behind these addresses so if Mode1 accesses fail try
     * for Mode2 (Mode2 is deprecated).
     */
    if(!pcibios){
        /*
         * Bits [30:24] of PciADDR must be 0,
         * according to the spec.
         */
        n = inl(PciADDR);
        if(!(n & 0x7F000000)){
            outl(PciADDR, 0x80000000);
            outb(PciADDR+3, 0);
            if(inl(PciADDR) & 0x80000000){
                pcicfgmode = 1;
                pcimaxdno = 31;
            }
        }
        outl(PciADDR, n);

        if(pcicfgmode < 0){
            /*
             * The 'key' part of PciCSE should be 0.
             */
            n = inb(PciCSE);
            if(!(n & 0xF0)){
                outb(PciCSE, 0x0E);
                if(inb(PciCSE) == 0x0E){
                    pcicfgmode = 2;
                    pcimaxdno = 15;
                }
            }
            outb(PciCSE, n);
        }
    }

    if(pcicfgmode < 0 || pcibios) {
        if((pcibiossi = pcibiosinit()) == nil)
            goto out;
        pcicfgrw8 = pcicfgrw8bios;
        pcicfgrw16 = pcicfgrw16bios;
        pcicfgrw32 = pcicfgrw32bios;
        pcicfgmode = 3;
    }

    fmtinstall('T', tbdffmt);

    if(p = getconf("*pcimaxbno")){
        n = strtoul(p, 0, 0);
        if(n < pcimaxbno)
            pcimaxbno = n;
    }
    if(p = getconf("*pcimaxdno")){
        n = strtoul(p, 0, 0);
        if(n < pcimaxdno)
            pcimaxdno = n;
    }

    list = &pciroot;
    for(bno = 0; bno <= pcimaxbno; bno++) {
        int sbno = bno;
        bno = pcilscan(bno, list);

        while(*list)
            list = &(*list)->link;

        if (sbno == 0) {
            Pcidev *pci;

            /*
              * If we have found a PCI-to-Cardbus bridge, make sure
              * it has no valid mappings anymore.
              */
            for(pci = pciroot; pci != nil; pci = pci->link){
                if (pci->ccrb == 6 && pci->ccru == 7) {
                    ushort bcr;

                    /* reset the cardbus */
                    bcr = pcicfgr16(pci, PciBCR);
                    pcicfgw16(pci, PciBCR, 0x40 | bcr);
                    delay(50);
                }
            }
        }
    }

    if(pciroot == nil)
        goto out;

    if(nobios) {
        /*
         * Work out how big the top bus is
         */
        pcibussize(pciroot, &mema, &ioa);

        /*
         * Align the windows and map it
         */
        ioa = 0x1000;
        mema = 0x90000000;

        pcilog("Mask sizes: mem=%lux io=%lux\n", mema, ioa);

        pcibusmap(pciroot, &mema, &ioa, 1);
        DBG("Sizes2: mem=%lux io=%lux\n", mema, ioa);

        unlock(&pcicfginitlock);
        return;
    }

    if (!nopcirouting)
        pcirouting();

out:
    pcireservemem();
    unlock(&pcicfginitlock);

    if(getconf("*pcihinv"))
        pcihinv(nil);
}

static void
pcireservemem(void)
{
    int i;
    Pcidev *p;

    /*
     * mark all the physical address space claimed by pci devices
     * as in use, so that upaalloc doesn't give it out.
     */
    for(p=pciroot; p; p=p->list)
        for(i=0; i<nelem(p->mem); i++)
            if(p->mem[i].bar && (p->mem[i].bar&1) == 0)
                upareserve(p->mem[i].bar&~0x0F, p->mem[i].size);
}

static int
pcicfgrw8raw(int tbdf, int rno, int data, int read)
{
    int o, type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        o = rno & 0x03;
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = inb(PciDATA+o);
        else
            outb(PciDATA+o, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = inb((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outb((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr8(Pcidev* pcidev, int rno)
{
    return pcicfgrw8(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw8(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw8(pcidev->tbdf, rno, data, 0);
}

static int
pcicfgrw16raw(int tbdf, int rno, int data, int read)
{
    int o, type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        o = rno & 0x02;
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = ins(PciDATA+o);
        else
            outs(PciDATA+o, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = ins((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outs((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr16(Pcidev* pcidev, int rno)
{
    return pcicfgrw16(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw16(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw16(pcidev->tbdf, rno, data, 0);
}

static int
pcicfgrw32raw(int tbdf, int rno, int data, int read)
{
    int type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = inl(PciDATA);
        else
            outl(PciDATA, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = inl((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outl((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr32(Pcidev* pcidev, int rno)
{
    return pcicfgrw32(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw32(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw32(pcidev->tbdf, rno, data, 0);
}

Pcidev*
pcimatch(Pcidev* prev, int vid, int did)
{
    if(pcicfgmode == -1)
        pcicfginit();

    if(prev == nil)
        prev = pcilist;
    else
        prev = prev->list;

    while(prev != nil){
        if((vid == 0 || prev->vid == vid)
        && (did == 0 || prev->did == did))
            break;
        prev = prev->list;
    }
    return prev;
}

Pcidev*
pcimatchtbdf(int tbdf)
{
    Pcidev *pcidev;

    if(pcicfgmode == -1)
        pcicfginit();

    for(pcidev = pcilist; pcidev != nil; pcidev = pcidev->list) {
        if(pcidev->tbdf == tbdf)
            break;
    }
    return pcidev;
}

uchar
pciipin(Pcidev *pci, uchar pin)
{
    if (pci == nil)
        pci = pcilist;

    while (pci) {
        uchar intl;

        if (pcicfgr8(pci, PciINTP) == pin && pci->intl != 0 && pci->intl != 0xff)
            return pci->intl;

        if (pci->bridge && (intl = pciipin(pci->bridge, pin)) != 0)
            return intl;

        pci = pci->list;
    }
    return 0;
}

static void
pcilhinv(Pcidev* p)
{
    int i;
    Pcidev *t;

    if(p == nil) {
        putstrn(PCICONS.output, PCICONS.ptr);
        p = pciroot;
        print("bus dev type vid  did intl memory\n");
    }
    for(t = p; t != nil; t = t->link) {
        print("%d  %2d/%d %.2ux %.2ux %.2ux %.4ux %.4ux %3d  ",
            BUSBNO(t->tbdf), BUSDNO(t->tbdf), BUSFNO(t->tbdf),
            t->ccrb, t->ccru, t->ccrp, t->vid, t->did, t->intl);

        for(i = 0; i < nelem(p->mem); i++) {
            if(t->mem[i].size == 0)
                continue;
            print("%d:%.8lux %d ", i,
                t->mem[i].bar, t->mem[i].size);
        }
        if(t->ioa.bar || t->ioa.size)
            print("ioa:%.8lux %d ", t->ioa.bar, t->ioa.size);
        if(t->mema.bar || t->mema.size)
            print("mema:%.8lux %d ", t->mema.bar, t->mema.size);
        if(t->bridge)
            print("->%d", BUSBNO(t->bridge->tbdf));
        print("\n");
    }
    while(p != nil) {
        if(p->bridge != nil)
            pcilhinv(p->bridge);
        p = p->link;
    }
}

void
pcihinv(Pcidev* p)
{
    if(pcicfgmode == -1)
        pcicfginit();
    lock(&pcicfginitlock);
    pcilhinv(p);
    unlock(&pcicfginitlock);
}

void
pcireset(void)
{
    Pcidev *p;

    if(pcicfgmode == -1)
        pcicfginit();

    for(p = pcilist; p != nil; p = p->list) {
        /* don't mess with the bridges */
        if(p->ccrb == 0x06)
            continue;
        pciclrbme(p);
    }
}



void
pcisetbme(Pcidev* p)
{
    p->pcr |= MASen;
    pcicfgw16(p, PciPCR, p->pcr);
}

void
pciclrbme(Pcidev* p)
{
    p->pcr &= ~MASen;
    pcicfgw16(p, PciPCR, p->pcr);
}

@

%//int
%//pciscan(int bno, Pcidev **list)
%//{
%//  int ubn;
%//
%//  lock(&pcicfginitlock);
%//  ubn = pcilscan(bno, list);
%//  unlock(&pcicfginitlock);
%//  return ubn;
%//}
%
%//void
%//pcisetioe(Pcidev* p)
%//{
%//  p->pcr |= IOen;
%//  pcicfgw16(p, PciPCR, p->pcr);
%//}
%
%//void
%//pciclrioe(Pcidev* p)
%//{
%//  p->pcr &= ~IOen;
%//  pcicfgw16(p, PciPCR, p->pcr);
%//}
%
%//void
%//pcisetmwi(Pcidev* p)
%//{
%//  p->pcr |= MemWrInv;
%//  pcicfgw16(p, PciPCR, p->pcr);
%//}
%
%//void
%//pciclrmwi(Pcidev* p)
%//{
%//  p->pcr &= ~MemWrInv;
%//  pcicfgw16(p, PciPCR, p->pcr);
%//}
%
%//static int
%//pcigetpmrb(Pcidev* p)
%//{
%//  int ptr;
%//
%//  if(p->pmrb != 0)
%//      return p->pmrb;
%//  p->pmrb = -1;
%//
%//  /*
%//   * If there are no extended capabilities implemented,
%//   * (bit 4 in the status register) assume there's no standard
%//   * power management method.
%//   * Find the capabilities pointer based on PCI header type.
%//   */
%//  if(!(pcicfgr16(p, PciPSR) & 0x0010))
%//      return -1;
%//  switch(pcicfgr8(p, PciHDT)){
%//  default:
%//      return -1;
%//  case 0:                 /* all other */
%//  case 1:                 /* PCI to PCI bridge */
%//      ptr = 0x34;
%//      break;
%//  case 2:                 /* CardBus bridge */
%//      ptr = 0x14;
%//      break;
%//  }
%//  ptr = pcicfgr32(p, ptr);
%//
%//  while(ptr != 0){
%//      /*
%//       * Check for validity.
%//       * Can't be in standard header and must be double
%//       * word aligned.
%//       */
%//      if(ptr < 0x40 || (ptr & ~0xFC))
%//          return -1;
%//      if(pcicfgr8(p, ptr) == 0x01){
%//          p->pmrb = ptr;
%//          return ptr;
%//      }
%//
%//      ptr = pcicfgr8(p, ptr+1);
%//  }
%//
%//  return -1;
%//}
%
%//int
%//pcigetpms(Pcidev* p)
%//{
%//  int pmcsr, ptr;
%//
%//  if((ptr = pcigetpmrb(p)) == -1)
%//      return -1;
%//
%//  /*
%//   * Power Management Register Block:
%//   *  offset 0:   Capability ID
%//   *     1:   next item pointer
%//   *     2:   capabilities
%//   *     4:   control/status
%//   *     6:   bridge support extensions
%//   *     7:   data
%//   */
%//  pmcsr = pcicfgr16(p, ptr+4);
%//
%//  return pmcsr & 0x0003;
%//}
%
%//int
%//pcisetpms(Pcidev* p, int state)
%//{
%//  int ostate, pmc, pmcsr, ptr;
%//
%//  if((ptr = pcigetpmrb(p)) == -1)
%//      return -1;
%//
%//  pmc = pcicfgr16(p, ptr+2);
%//  pmcsr = pcicfgr16(p, ptr+4);
%//  ostate = pmcsr & 0x0003;
%//  pmcsr &= ~0x0003;
%//
%//  switch(state){
%//  default:
%//      return -1;
%//  case 0:
%//      break;
%//  case 1:
%//      if(!(pmc & 0x0200))
%//          return -1;
%//      break;
%//  case 2:
%//      if(!(pmc & 0x0400))
%//          return -1;
%//      break;
%//  case 3:
%//      break;
%//  }
%//  pmcsr |= state;
%//  pcicfgw16(p, ptr+4, pmcsr);
%//
%//  return ostate;
%//}


\subsection*{[[buses/386/uarti8250.c]]}

\ifallcode
<<uarti8250.c forward decl>>=
typedef struct CtlrUart CtlrUart;
@
\fi


<<uarti8250.c>>=
<<kernel basic includes>>
#include "io.h"

/*
 * 8250 UART and compatibles.
 */
enum {
    Uart0       = 0x3F8,    /* COM1 */
    Uart0IRQ    = 4,
    Uart1       = 0x2F8,    /* COM2 */
    Uart1IRQ    = 3,

    UartFREQ    = 1843200,
};

enum {                  /* I/O ports */
    Rbr     = 0,        /* Receiver Buffer (RO) */
    Thr     = 0,        /* Transmitter Holding (WO) */
    Ier     = 1,        /* Interrupt Enable */
    Iir     = 2,        /* Interrupt Identification (RO) */
    Fcr     = 2,        /* FIFO Control (WO) */
    Lcr     = 3,        /* Line Control */
    Mcr     = 4,        /* Modem Control */
    Lsr     = 5,        /* Line Status */
    Msr     = 6,        /* Modem Status */
    Scr     = 7,        /* Scratch Pad */
    Dll     = 0,        /* Divisor Latch LSB */
    Dlm     = 1,        /* Divisor Latch MSB */
};

enum {                  /* Ier */
    Erda        = 0x01,     /* Enable Received Data Available */
    Ethre       = 0x02,     /* Enable Thr Empty */
    Erls        = 0x04,     /* Enable Receiver Line Status */
    Ems     = 0x08,     /* Enable Modem Status */
};

enum {                  /* Iir */
    Ims     = 0x00,     /* Ms interrupt */
    Ip      = 0x01,     /* Interrupt Pending (not) */
    Ithre       = 0x02,     /* Thr Empty */
    Irda        = 0x04,     /* Received Data Available */
    Irls        = 0x06,     /* Receiver Line Status */
    Ictoi       = 0x0C,     /* Character Time-out Indication */
    IirMASK     = 0x3F,
    Ifena       = 0xC0,     /* FIFOs enabled */
};

enum {                  /* Fcr */
    FIFOena     = 0x01,     /* FIFO enable */
    FIFOrclr    = 0x02,     /* clear Rx FIFO */
    FIFOtclr    = 0x04,     /* clear Tx FIFO */
    FIFO1       = 0x00,     /* Rx FIFO trigger level 1 byte */
    FIFO4       = 0x40,     /*  4 bytes */
    FIFO8       = 0x80,     /*  8 bytes */
    FIFO14      = 0xC0,     /*  14 bytes */
};

enum {                  /* Lcr */
    Wls5        = 0x00,     /* Word Length Select 5 bits/byte */
    Wls6        = 0x01,     /*  6 bits/byte */
    Wls7        = 0x02,     /*  7 bits/byte */
    Wls8        = 0x03,     /*  8 bits/byte */
    WlsMASK     = 0x03,
    Stb     = 0x04,     /* 2 stop bits */
    Pen     = 0x08,     /* Parity Enable */
    Eps     = 0x10,     /* Even Parity Select */
    Stp     = 0x20,     /* Stick Parity */
    Brk     = 0x40,     /* Break */
    Dlab        = 0x80,     /* Divisor Latch Access Bit */
};

enum {                  /* Mcr */
    Dtr     = 0x01,     /* Data Terminal Ready */
    Rts     = 0x02,     /* Ready To Send */
    Out1        = 0x04,     /* no longer in use */
    Ie      = 0x08,     /* IRQ Enable */
    Dm      = 0x10,     /* Diagnostic Mode loopback */
};

enum {                  /* Lsr */
    Dr      = 0x01,     /* Data Ready */
    Oe      = 0x02,     /* Overrun Error */
    Pe      = 0x04,     /* Parity Error */
    Fe      = 0x08,     /* Framing Error */
    Bi      = 0x10,     /* Break Interrupt */
    Thre        = 0x20,     /* Thr Empty */
    Temt        = 0x40,     /* Tramsmitter Empty */
    FIFOerr     = 0x80,     /* error in receiver FIFO */
};

enum {                  /* Msr */
    Dcts        = 0x01,     /* Delta Cts */
    Ddsr        = 0x02,     /* Delta Dsr */
    Teri        = 0x04,     /* Trailing Edge of Ri */
    Ddcd        = 0x08,     /* Delta Dcd */
    Cts     = 0x10,     /* Clear To Send */
    Dsr     = 0x20,     /* Data Set Ready */
    Ri      = 0x40,     /* Ring Indicator */
    Dcd     = 0x80,     /* Data Set Ready */
};

struct CtlrUart {
    int io;
    int irq;
    int tbdf;
    int iena;

    uchar   sticky[8];

    Lock;
    int hasfifo;
    int checkfifo;
    int fena;
};

<<uarti8250.c forward decl>>

extern PhysUart i8250physuart;

static CtlrUart i8250ctlr[2] = {
{   .io = Uart0,
    .irq    = Uart0IRQ,
    .tbdf   = BUSUNKNOWN, },

{   .io = Uart1,
    .irq    = Uart1IRQ,
    .tbdf   = BUSUNKNOWN, },
};

static Uart i8250uart[2] = {
{   .regs   = &i8250ctlr[0],
    .name   = "COM1",
    .freq   = UartFREQ,
    .phys   = &i8250physuart,
    .special= 0,
    .next   = &i8250uart[1], },

{   .regs   = &i8250ctlr[1],
    .name   = "COM2",
    .freq   = UartFREQ,
    .phys   = &i8250physuart,
    .special= 0,
    .next   = nil, },
};

#define csr8r(c, r) inb((c)->io+(r))
#define csr8w(c, r, v)  outb((c)->io+(r), (c)->sticky[(r)]|(v))

static long
i8250status(Uart* uart, void* buf, long n, long offset)
{
    char *p;
    CtlrUart *ctlr;
    uchar ier, lcr, mcr, msr;

    p = malloc(READSTR);
    if(p == nil)
        error(Enomem);
    ctlr = uart->regs;
    mcr = ctlr->sticky[Mcr];
    msr = csr8r(ctlr, Msr);
    ier = ctlr->sticky[Ier];
    lcr = ctlr->sticky[Lcr];
    snprint(p, READSTR,
        "b%d c%d d%d e%d l%d m%d p%c r%d s%d i%d\n"
        "dev(%d) type(%d) framing(%d) overruns(%d) "
        "berr(%d) serr(%d)%s%s%s%s\n",

        uart->baud,
        uart->hup_dcd, 
        (msr & Dsr) != 0,
        uart->hup_dsr,
        (lcr & WlsMASK) + 5,
        (ier & Ems) != 0, 
        (lcr & Pen) ? ((lcr & Eps) ? 'e': 'o'): 'n',
        (mcr & Rts) != 0,
        (lcr & Stb) ? 2: 1,
        ctlr->fena,

        uart->dev,
        uart->type,
        uart->ferr,
        uart->oerr,
        uart->berr,
        uart->serr,
        (msr & Cts) ? " cts": "",
        (msr & Dsr) ? " dsr": "",
        (msr & Dcd) ? " dcd": "",
        (msr & Ri) ? " ring": ""
    );
    n = readstr(offset, buf, n, p);
    free(p);

    return n;
}

static void
i8250fifo(Uart* uart, int level)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    if(ctlr->hasfifo == 0)
        return;

    /*
     * Changing the FIFOena bit in Fcr flushes data
     * from both receive and transmit FIFOs; there's
     * no easy way to guarantee not losing data on
     * the receive side, but it's possible to wait until
     * the transmitter is really empty.
     */
    ilock(ctlr);
    while(!(csr8r(ctlr, Lsr) & Temt))
        ;

    /*
     * Set the trigger level, default is the max.
     * value.
     * Some UARTs require FIFOena to be set before
     * other bits can take effect, so set it twice.
     */
    ctlr->fena = level;
    switch(level){
    case 0:
        break;
    case 1:
        level = FIFO1|FIFOena;
        break;
    case 4:
        level = FIFO4|FIFOena;
        break;
    case 8:
        level = FIFO8|FIFOena;
        break;
    default:
        level = FIFO14|FIFOena;
        break;
    }
    csr8w(ctlr, Fcr, level);
    csr8w(ctlr, Fcr, level);
    iunlock(ctlr);
}

static void
i8250dtr(Uart* uart, int on)
{
    CtlrUart *ctlr;

    /*
     * Toggle DTR.
     */
    ctlr = uart->regs;
    if(on)
        ctlr->sticky[Mcr] |= Dtr;
    else
        ctlr->sticky[Mcr] &= ~Dtr;
    csr8w(ctlr, Mcr, 0);
}

static void
i8250rts(Uart* uart, int on)
{
    CtlrUart *ctlr;

    /*
     * Toggle RTS.
     */
    ctlr = uart->regs;
    if(on)
        ctlr->sticky[Mcr] |= Rts;
    else
        ctlr->sticky[Mcr] &= ~Rts;
    csr8w(ctlr, Mcr, 0);
}

static void
i8250modemctl(Uart* uart, int on)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    ilock(&uart->tlock);
    if(on){
        ctlr->sticky[Ier] |= Ems;
        csr8w(ctlr, Ier, ctlr->sticky[Ier]);
        uart->modem = 1;
        uart->cts = csr8r(ctlr, Msr) & Cts;
    }
    else{
        ctlr->sticky[Ier] &= ~Ems;
        csr8w(ctlr, Ier, ctlr->sticky[Ier]);
        uart->modem = 0;
        uart->cts = 1;
    }
    iunlock(&uart->tlock);

    /* modem needs fifo */
    (*uart->phys->fifo)(uart, on);
}

static int
i8250parity(Uart* uart, int parity)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~(Eps|Pen);

    switch(parity){
    case 'e':
        lcr |= Eps|Pen;
        break;
    case 'o':
        lcr |= Pen;
        break;
    case 'n':
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->parity = parity;

    return 0;
}

static int
i8250stop(Uart* uart, int stop)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~Stb;

    switch(stop){
    case 1:
        break;
    case 2:
        lcr |= Stb;
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->stop = stop;

    return 0;
}

static int
i8250bits(Uart* uart, int bits)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~WlsMASK;

    switch(bits){
    case 5:
        lcr |= Wls5;
        break;
    case 6:
        lcr |= Wls6;
        break;
    case 7:
        lcr |= Wls7;
        break;
    case 8:
        lcr |= Wls8;
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->bits = bits;

    return 0;
}

static int
i8250baud(Uart* uart, int baud)
{
    ulong bgc;
    CtlrUart *ctlr;

    /*
     * Set the Baud rate by calculating and setting the Baud rate
     * Generator Constant. This will work with fairly non-standard
     * Baud rates.
     */
    if(uart->freq == 0 || baud <= 0)
        return -1;
    bgc = (uart->freq+8*baud-1)/(16*baud);

    ctlr = uart->regs;
    csr8w(ctlr, Lcr, Dlab);
    outb(ctlr->io+Dlm, bgc>>8);
    outb(ctlr->io+Dll, bgc);
    csr8w(ctlr, Lcr, 0);

    uart->baud = baud;

    return 0;
}

static void
i8250break(Uart* uart, int ms)
{
    CtlrUart *ctlr;

    /*
     * Send a break.
     */
    if(ms <= 0)
        ms = 200;

    ctlr = uart->regs;
    csr8w(ctlr, Lcr, Brk);
    tsleep(&up->sleepr, returnfalse, 0, ms);
    csr8w(ctlr, Lcr, 0);
}

static void
i8250kick(Uart* uart)
{
    int i;
    CtlrUart *ctlr;

    if(uart->cts == 0 || uart->blocked)
        return;

    /*
     *  128 here is an arbitrary limit to make sure
     *  we don't stay in this loop too long.  If the
     *  chip's output queue is longer than 128, too
     *  bad -- presotto
     */
    ctlr = uart->regs;
    for(i = 0; i < 128; i++){
        if(!(csr8r(ctlr, Lsr) & Thre))
            break;
        if(uart->op >= uart->oe && uartstageoutput(uart) == 0)
            break;
        outb(ctlr->io+Thr, *(uart->op++));
    }
}

static void
i8250interrupt(Ureg*, void* arg)
{
    CtlrUart *ctlr;
    Uart *uart;
    int iir, lsr, old, r;

    uart = arg;

    ctlr = uart->regs;
    for(iir = csr8r(ctlr, Iir); !(iir & Ip); iir = csr8r(ctlr, Iir)){
        switch(iir & IirMASK){
        case Ims:       /* Ms interrupt */
            r = csr8r(ctlr, Msr);
            if(r & Dcts){
                ilock(&uart->tlock);
                old = uart->cts;
                uart->cts = r & Cts;
                if(old == 0 && uart->cts)
                    uart->ctsbackoff = 2;
                iunlock(&uart->tlock);
            }
            if(r & Ddsr){
                old = r & Dsr;
                if(uart->hup_dsr && uart->dsr && !old)
                    uart->dohup = 1;
                uart->dsr = old;
            }
            if(r & Ddcd){
                old = r & Dcd;
                if(uart->hup_dcd && uart->dcd && !old)
                    uart->dohup = 1;
                uart->dcd = old;
            }
            break;
        case Ithre:     /* Thr Empty */
            uartkick(uart);
            break;
        case Irda:      /* Received Data Available */
        case Irls:      /* Receiver Line Status */
        case Ictoi:     /* Character Time-out Indication */
            /*
             * Consume any received data.
             * If the received byte came in with a break,
             * parity or framing error, throw it away;
             * overrun is an indication that something has
             * already been tossed.
             */
            while((lsr = csr8r(ctlr, Lsr)) & Dr){
                if(lsr & (FIFOerr|Oe))
                    uart->oerr++;
                if(lsr & Pe)
                    uart->perr++;
                if(lsr & Fe)
                    uart->ferr++;
                r = csr8r(ctlr, Rbr);
                if(!(lsr & (Bi|Fe|Pe)))
                    uartrecv(uart, r);
            }
            break;

        default:
            iprint("weird uart interrupt 0x%2.2uX\n", iir);
            break;
        }
    }
}

static void
i8250disable(Uart* uart)
{
    CtlrUart *ctlr;

    /*
     * Turn off DTR and RTS, disable interrupts and fifos.
     */
    (*uart->phys->dtr)(uart, 0);
    (*uart->phys->rts)(uart, 0);
    (*uart->phys->fifo)(uart, 0);

    ctlr = uart->regs;
    ctlr->sticky[Ier] = 0;
    csr8w(ctlr, Ier, ctlr->sticky[Ier]);

    if(ctlr->iena != 0){
        if(intrdisable(ctlr->irq, i8250interrupt, uart, ctlr->tbdf, uart->name) == 0)
            ctlr->iena = 0;
    }
}

static void
i8250enable(Uart* uart, int ie)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;

    /*
     * Check if there is a FIFO.
     * Changing the FIFOena bit in Fcr flushes data
     * from both receive and transmit FIFOs; there's
     * no easy way to guarantee not losing data on
     * the receive side, but it's possible to wait until
     * the transmitter is really empty.
     * Also, reading the Iir outwith i8250interrupt()
     * can be dangerous, but this should only happen
     * once before interrupts are enabled.
     */
    ilock(ctlr);
    if(!ctlr->checkfifo){
        /*
         * Wait until the transmitter is really empty.
         */
        while(!(csr8r(ctlr, Lsr) & Temt))
            ;
        csr8w(ctlr, Fcr, FIFOena);
        if(csr8r(ctlr, Iir) & Ifena)
            ctlr->hasfifo = 1;
        csr8w(ctlr, Fcr, 0);
        ctlr->checkfifo = 1;
    }
    iunlock(ctlr);

    /*
     * Enable interrupts and turn on DTR and RTS.
     * Be careful if this is called to set up a polled serial line
     * early on not to try to enable interrupts as interrupt-
     * -enabling mechanisms might not be set up yet.
     */
    if(ie){
        if(ctlr->iena == 0){
            intrenable(ctlr->irq, i8250interrupt, uart, ctlr->tbdf, uart->name);
            ctlr->iena = 1;
        }
        ctlr->sticky[Ier] = Ethre|Erda;
        ctlr->sticky[Mcr] |= Ie;
    }
    else{
        ctlr->sticky[Ier] = 0;
        ctlr->sticky[Mcr] = 0;
    }
    csr8w(ctlr, Ier, ctlr->sticky[Ier]);
    csr8w(ctlr, Mcr, ctlr->sticky[Mcr]);

    (*uart->phys->dtr)(uart, 1);
    (*uart->phys->rts)(uart, 1);

    /*
     * During startup, the i8259 interrupt controller is reset.
     * This may result in a lost interrupt from the i8250 uart.
     * The i8250 thinks the interrupt is still outstanding and does not
     * generate any further interrupts. The workaround is to call the
     * interrupt handler to clear any pending interrupt events.
     * Note: this must be done after setting Ier.
     */
    if(ie)
        i8250interrupt(nil, uart);
}

void*
i8250alloc(int io, int irq, int tbdf)
{
    CtlrUart *ctlr;

    if((ctlr = malloc(sizeof(CtlrUart))) != nil){
        ctlr->io = io;
        ctlr->irq = irq;
        ctlr->tbdf = tbdf;
    }

    return ctlr;
}

static Uart*
i8250pnp(void)
{
    return i8250uart;
}

static int
i8250getc(Uart *uart)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    while(!(csr8r(ctlr, Lsr)&Dr))
        delay(1);
    return csr8r(ctlr, Rbr);
}

static void
i8250putc(Uart *uart, int c)
{
    int i;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    for(i = 0; !(csr8r(ctlr, Lsr)&Thre) && i < 128; i++)
        delay(1);
    outb(ctlr->io+Thr, c);
    for(i = 0; !(csr8r(ctlr, Lsr)&Thre) && i < 128; i++)
        delay(1);
}

PhysUart i8250physuart = {
    .name       = "i8250",
    .pnp        = i8250pnp,
    .enable     = i8250enable,
    .disable    = i8250disable,
    .kick       = i8250kick,
    .dobreak    = i8250break,
    .baud       = i8250baud,
    .bits       = i8250bits,
    .stop       = i8250stop,
    .parity     = i8250parity,
    .modemctl   = i8250modemctl,
    .rts        = i8250rts,
    .dtr        = i8250dtr,
    .status     = i8250status,
    .fifo       = i8250fifo,
    .getc       = i8250getc,
    .putc       = i8250putc,
};

void
i8250config(char *p)
{
    Uart *uart;
    int n;
    char *cmd;

    if(p == nil)
        return;
    n = strtoul(p, &cmd, 0);
    if(p == cmd)
        return;
    switch(n){
    default:
        return;
    case 0:
        uart = &i8250uart[0];
        break;
    case 1:
        uart = &i8250uart[1];
        break;  
    }

    if(!uart->enabled)
        (*uart->phys->enable)(uart, 0);
    uartctl(uart, "b9600 l8 pn s1");
    if(*cmd != '\0')
        uartctl(uart, cmd);

    consuart = uart;
    uart->console = true;
}

void
i8250console(void)
{
    i8250config(getconf("console"));
}

void
i8250mouse(char* which, int (*putc)(Queue*, int), int setb1200)
{
    char *p;
    int port;

    port = strtol(which, &p, 0);
    if(p == which || port < 0 || port > 1)
        error(Ebadarg);
    uartmouse(&i8250uart[port], putc, setb1200);
}

void
i8250setmouseputc(char* which, int (*putc)(Queue*, int))
{
    char *p;
    int port;

    port = strtol(which, &p, 0);
    if(p == which || port < 0 || port > 1)
        error(Ebadarg);
    uartsetmouseputc(&i8250uart[port], putc);

}
@


\subsection*{[[buses/386/uartisa.c]]}

<<uartisa.c>>=
<<kernel basic includes>>
#include "io.h"

extern PhysUart i8250physuart;
extern PhysUart isaphysuart;
extern void* i8250alloc(int, int, int);

static Uart*
uartisa(int ctlrno, ISAConf* isa)
{
    int io;
    void *ctlr;
    Uart *uart;
    char buf[64];

    io = isa->port;
    snprint(buf, sizeof(buf), "%s%d", isaphysuart.name, ctlrno);
    if(ioalloc(io, 8, 0, buf) < 0){
        print("uartisa: I/O 0x%uX in use\n", io);
        return nil;
    }

    uart = malloc(sizeof(Uart));
    ctlr = i8250alloc(io, isa->irq, BUSUNKNOWN);
    if(uart == nil || ctlr == nil){
        iofree(io);
        free(uart);
        free(ctlr);
        return nil;
    }

    uart->regs = ctlr;
    snprint(buf, sizeof(buf), "COM%d", ctlrno+1);
    kstrdup(&uart->name, buf);
    uart->freq = isa->freq;
    uart->phys = &i8250physuart;

    return uart;
}

static Uart*
uartisapnp(void)
{
    int ctlrno;
    ISAConf isa;
    Uart *head, *tail, *uart;

    /*
     * Look for up to 4 discrete UARTs on the ISA bus.
     * All suitable devices are configured to simply point
     * to the generic i8250 driver.
     */
    head = tail = nil;
    for(ctlrno = 2; ctlrno < 6; ctlrno++){
        memset(&isa, 0, sizeof(isa));
        if(!isaconfig("uart", ctlrno, &isa))
            continue;
        if(strcmp(isa.type, "isa") != 0)
            continue;
        if(isa.port == 0 || isa.irq == 0)
            continue;
        if(isa.freq == 0)
            isa.freq = 1843200;
        uart = uartisa(ctlrno, &isa);
        if(uart == nil)
            continue;
        if(head != nil)
            tail->next = uart;
        else
            head = uart;
        tail = uart;
    }

    return head;
}

PhysUart isaphysuart = {
    .name       = "UartISA",
    .pnp        = uartisapnp,
    .enable     = nil,
    .disable    = nil,
    .kick       = nil,
    .dobreak    = nil,
    .baud       = nil,
    .bits       = nil,
    .stop       = nil,
    .parity     = nil,
    .modemctl   = nil,
    .rts        = nil,
    .dtr        = nil,
    .status     = nil,
    .fifo       = nil,
};
@

\subsection*{[[buses/devuart.c]]}

<<function kbdcr2nl>>=
/*
 *  Called by a uart interrupt for console input.
 *
 *  turn '\r' into '\n' before putting it into the queue.
 */
int
kbdcr2nl(Queue*, int ch)
{
    char *next;

    ilock(&kbd.lockputc);       /* just a mutex */
    if(ch == '\r' && !kbd.raw)
        ch = '\n';
    next = kbd.iw+1;
    if(next >= kbd.ie)
        next = kbd.istage;
    if(next != kbd.ir){
        *kbd.iw = ch;
        kbd.iw = next;
    }
    iunlock(&kbd.lockputc);
    return 0;
}
@ 

\ifallcode
<<devuart.c forward decl>>=
static void uartclock(void);
static void uartflow(void*);
@
\fi

<<constant STAGESIZE>>=
// used by devuart.c
STAGESIZE = 2048, // default is 64
@

<<devuart.c>>=
<<kernel basic includes>>
#include    "io.h"
#include    "../port/netif.h"

enum
{
    /* soft flow control chars */
    CTLS= 023,
    CTLQ= 021,
};

extern Dev uartdevtab;
extern PhysUart* physuart[];

static Uart* uartlist;
static Uart** uart;
static int uartnuart;
static Dirtab *uartdir;
static int uartndir;
static Timer *uarttimer;

struct Uartalloc {
    Lock;
    Uart *elist;    /* list of enabled interfaces */
} uartalloc;

<<devuart.c forward decl>>

/*
 *  enable/disable uart and add/remove to list of enabled uarts
 */
Uart*
uartenable(Uart *p)
{
    Uart **l;

    if(p->enabled)
        return p;
    if(p->iq == nil){
        if((p->iq = qopen(8*1024, 0, uartflow, p)) == nil)
            return nil;
    }
    else
        qreopen(p->iq);
    if(p->oq == nil){
        if((p->oq = qopen(8*1024, 0, uartkick, p)) == nil){
            qfree(p->iq);
            p->iq = nil;
            return nil;
        }
    }
    else
        qreopen(p->oq);

    p->ir = p->istage;
    p->iw = p->istage;
    p->ie = &p->istage[STAGESIZE];
    p->op = p->ostage;
    p->oe = p->ostage;

    p->hup_dsr = p->hup_dcd = 0;
    p->dsr = p->dcd = 0;

    /* assume we can send */
    p->cts = 1;
    p->ctsbackoff = 0;

    if(p->bits == 0)
        uartctl(p, "l8");
    if(p->stop == 0)
        uartctl(p, "s1");
    if(p->parity == 0)
        uartctl(p, "pn");
    if(p->baud == 0)
        uartctl(p, "b9600");
    (*p->phys->enable)(p, 1);

    /*
     * use ilock because uartclock can otherwise interrupt here
     * and would hang on an attempt to lock uartalloc.
     */
    ilock(&uartalloc);
    for(l = &uartalloc.elist; *l; l = &(*l)->elist){
        if(*l == p)
            break;
    }
    if(*l == 0){
        p->elist = uartalloc.elist;
        uartalloc.elist = p;
    }
    p->enabled = 1;
    iunlock(&uartalloc);

    return p;
}

static void
uartdisable(Uart *p)
{
    Uart **l;

    if(!p->enabled)
        return;
    (*p->phys->disable)(p);

    ilock(&uartalloc);
    for(l = &uartalloc.elist; *l; l = &(*l)->elist){
        if(*l == p){
            *l = p->elist;
            break;
        }
    }
    p->enabled = 0;
    iunlock(&uartalloc);
}

void
uartmouse(Uart* p, int (*putc)(Queue*, int), int setb1200)
{
    qlock(p);
    if(p->opens++ == 0 && uartenable(p) == nil){
        qunlock(p);
        error(Enodev);
    }
    if(setb1200)
        uartctl(p, "b1200");
    p->putc = putc;
    p->special = 1;
    qunlock(p);
}

void
uartsetmouseputc(Uart* p, int (*putc)(Queue*, int))
{
    qlock(p);
    if(p->opens == 0 || p->special == 0){
        qunlock(p);
        error(Enodev);
    }
    p->putc = putc;
    qunlock(p);
}

static void
setlength(int i)
{
    Uart *p;

    if(i > 0){
        p = uart[i];
        if(p && p->opens && p->iq)
            uartdir[1+3*i].length = qlen(p->iq);
    } else for(i = 0; i < uartnuart; i++){
        p = uart[i];
        if(p && p->opens && p->iq)
            uartdir[1+3*i].length = qlen(p->iq);
    }
}

/*
 *  set up the '#t' directory
 */
static void
uartreset(void)
{
    int i;
    Dirtab *dp;
    Uart *p, *tail;

    tail = nil;
    for(i = 0; physuart[i] != nil; i++){
        if(physuart[i]->pnp == nil)
            continue;
        if((p = physuart[i]->pnp()) == nil)
            continue;
        if(uartlist != nil)
            tail->next = p;
        else
            uartlist = p;
        for(tail = p; tail->next != nil; tail = tail->next)
            uartnuart++;
        uartnuart++;
    }

    if(uartnuart) {
        uart = xalloc(uartnuart*sizeof(Uart*));
        if (uart == nil)
            panic("uartreset: no memory");
    }

    uartndir = 1 + 3*uartnuart;
    uartdir = xalloc(uartndir * sizeof(Dirtab));
    if (uartdir == nil)
        panic("uartreset: no memory");
    dp = uartdir;
    strcpy(dp->name, ".");
    mkqid(&dp->qid, 0, 0, QTDIR);
    dp->length = 0;
    dp->perm = DMDIR|0555;
    dp++;
    p = uartlist;
    for(i = 0; i < uartnuart; i++){
        /* 3 directory entries per port */
        snprint(dp->name, sizeof dp->name, "eia%d", i);
        dp->qid.path = NETQID(i, Ndataqid);
        dp->perm = 0660;
        dp++;
        snprint(dp->name, sizeof dp->name, "eia%dctl", i);
        dp->qid.path = NETQID(i, Nctlqid);
        dp->perm = 0660;
        dp++;
        snprint(dp->name, sizeof dp->name, "eia%dstatus", i);
        dp->qid.path = NETQID(i, Nstatqid);
        dp->perm = 0444;
        dp++;

        uart[i] = p;
        p->dev = i;
        if(p->console || p->special){
            if(uartenable(p) != nil){
                if(p->console){
                    kbdq = p->iq;
                    serialoq = p->oq;
                    p->putc = kbdcr2nl;
                }
                p->opens++;
            }
        }
        p = p->next;
    }

    if(uartnuart){
        /*
         * at 115200 baud, the 1024 char buffer takes 56 ms to process,
         * processing it every 22 ms should be fine.
         */
        uarttimer = addclock0link(uartclock, 22);
    }
}


static Chan*
uartattach(char *spec)
{
    return devattach('t', spec);
}

static Walkqid*
uartwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, uartdir, uartndir, devgen);
}

static int
uartstat(Chan *c, uchar *dp, int n)
{
    if(NETTYPE(c->qid.path) == Ndataqid)
        setlength(NETID(c->qid.path));
    return devstat(c, dp, n, uartdir, uartndir, devgen);
}

static Chan*
uartopen(Chan *c, int omode)
{
    Uart *p;

    c = devopen(c, omode, uartdir, uartndir, devgen);

    switch(NETTYPE(c->qid.path)){
    case Nctlqid:
    case Ndataqid:
        p = uart[NETID(c->qid.path)];
        qlock(p);
        if(p->opens++ == 0 && uartenable(p) == nil){
            qunlock(p);
            c->flag &= ~COPEN;
            error(Enodev);
        }
        qunlock(p);
        break;
    }

    c->iounit = qiomaxatomic;
    return c;
}

static int
uartdrained(void* arg)
{
    Uart *p;

    p = arg;
    return qlen(p->oq) == 0 && p->op == p->oe;
}

static void
uartdrainoutput(Uart *p)
{
    if(!p->enabled)
        return;

    p->drain = 1;
    if(waserror()){
        p->drain = 0;
        nexterror();
    }
    sleep(&p->r, uartdrained, p);
    poperror();
}

static void
uartclose(Chan *c)
{
    Uart *p;

    if(c->qid.type & QTDIR)
        return;
    if((c->flag & COPEN) == 0)
        return;
    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
    case Nctlqid:
        p = uart[NETID(c->qid.path)];
        qlock(p);
        if(--(p->opens) == 0){
            qclose(p->iq);
            ilock(&p->rlock);
            p->ir = p->iw = p->istage;
            iunlock(&p->rlock);

            /*
             */
            qhangup(p->oq, nil);
            if(!waserror()){
                uartdrainoutput(p);
                poperror();
            }
            qclose(p->oq);
            uartdisable(p);
            p->dcd = p->dsr = p->dohup = 0;
        }
        qunlock(p);
        break;
    }
}

static long
uartread(Chan *c, void *buf, long n, vlong off)
{
    Uart *p;
    ulong offset = off;

    if(c->qid.type & QTDIR){
        setlength(-1);
        return devdirread(c, buf, n, uartdir, uartndir, devgen);
    }

    p = uart[NETID(c->qid.path)];
    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
        return qread(p->iq, buf, n);
    case Nctlqid:
        return readnum(offset, buf, n, NETID(c->qid.path), NUMSIZE);
    case Nstatqid:
        return (*p->phys->status)(p, buf, n, offset);
    }

    return 0;
}

int
uartctl(Uart *p, char *cmd)
{
    char *f[16];
    int i, n, nf;

    nf = tokenize(cmd, f, nelem(f));
    for(i = 0; i < nf; i++){
        if(strncmp(f[i], "break", 5) == 0){
            (*p->phys->dobreak)(p, 0);
            continue;
        }

        n = atoi(f[i]+1);
        switch(*f[i]){
        case 'B':
        case 'b':
            uartdrainoutput(p);
            if((*p->phys->baud)(p, n) < 0)
                return -1;
            break;
        case 'C':
        case 'c':
            p->hup_dcd = n;
            break;
        case 'D':
        case 'd':
            uartdrainoutput(p);
            (*p->phys->dtr)(p, n);
            break;
        case 'E':
        case 'e':
            p->hup_dsr = n;
            break;
        case 'f':
        case 'F':
            if(p->oq != nil)
                qflush(p->oq);
            break;
        case 'H':
        case 'h':
            if(p->iq != nil)
                qhangup(p->iq, 0);
            if(p->oq != nil)
                qhangup(p->oq, 0);
            break;
        case 'i':
        case 'I':
            uartdrainoutput(p);
            (*p->phys->fifo)(p, n);
            break;
        case 'K':
        case 'k':
            uartdrainoutput(p);
            (*p->phys->dobreak)(p, n);
            break;
        case 'L':
        case 'l':
            uartdrainoutput(p);
            if((*p->phys->bits)(p, n) < 0)
                return -1;
            break;
        case 'm':
        case 'M':
            uartdrainoutput(p);
            (*p->phys->modemctl)(p, n);
            break;
        case 'n':
        case 'N':
            if(p->oq != nil)
                qnoblock(p->oq, n);
            break;
        case 'P':
        case 'p':
            uartdrainoutput(p);
            if((*p->phys->parity)(p, *(f[i]+1)) < 0)
                return -1;
            break;
        case 'Q':
        case 'q':
            if(p->iq != nil)
                qsetlimit(p->iq, n);
            if(p->oq != nil)
                qsetlimit(p->oq, n);
            break;
        case 'R':
        case 'r':
            uartdrainoutput(p);
            (*p->phys->rts)(p, n);
            break;
        case 'S':
        case 's':
            uartdrainoutput(p);
            if((*p->phys->stop)(p, n) < 0)
                return -1;
            break;
        case 'W':
        case 'w':
            if(uarttimer == nil || n < 1)
                return -1;
            uarttimer->tns = (vlong)n * 100000LL;
            break;
        case 'X':
        case 'x':
            if(p->enabled){
                ilock(&p->tlock);
                p->xonoff = n;
                iunlock(&p->tlock);
            }
            break;
        }
    }
    return 0;
}

static long
uartwrite(Chan *c, void *buf, long n, vlong)
{
    Uart *p;
    char *cmd;

    if(c->qid.type & QTDIR)
        error(Eperm);

    p = uart[NETID(c->qid.path)];

    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
        qlock(p);
        if(waserror()){
            qunlock(p);
            nexterror();
        }

        n = qwrite(p->oq, buf, n);

        qunlock(p);
        poperror();
        break;
    case Nctlqid:
        cmd = malloc(n+1);
        if(cmd == nil)
            error(Enomem);
        memmove(cmd, buf, n);
        cmd[n] = 0;
        qlock(p);
        if(waserror()){
            qunlock(p);
            free(cmd);
            nexterror();
        }

        /* let output drain */
        if(uartctl(p, cmd) < 0)
            error(Ebadarg);

        qunlock(p);
        poperror();
        free(cmd);
        break;
    }

    return n;
}

static int
uartwstat(Chan *c, uchar *dp, int n)
{
    Dir d;
    Dirtab *dt;

    if(!iseve())
        error(Eperm);
    if(QTDIR & c->qid.type)
        error(Eperm);
    if(NETTYPE(c->qid.path) == Nstatqid)
        error(Eperm);

    dt = &uartdir[1 + 3 * NETID(c->qid.path)];
    n = convM2D(dp, n, &d, nil);
    if(n == 0)
        error(Eshortstat);
    if(d.mode != ~0UL)
        dt[0].perm = dt[1].perm = d.mode;
    return n;
}

void
uartpower(int on)
{
    Uart *p;

    for(p = uartlist; p != nil; p = p->next) {
        if(p->phys->power)
            (*p->phys->power)(p, on);
    }
}

Dev uartdevtab = {
    .dc       =    't',
    .name     =    "uart",
               
    .reset    =    uartreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    uartattach,
    .walk     =    uartwalk,
    .stat     =    uartstat,
    .open     =    uartopen,
    .create   =    devcreate,
    .close    =    uartclose,
    .read     =    uartread,
    .bread    =    devbread,
    .write    =    uartwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    uartwstat,
    .power    =    uartpower,
};

/*
 *  restart input if it's off
 */
static void
uartflow(void *v)
{
    Uart *p;

    p = v;
    if(p->modem)
        (*p->phys->rts)(p, 1);
}

/*
 *  put some bytes into the local queue to avoid calling
 *  qconsume for every character
 */
int
uartstageoutput(Uart *p)
{
    int n;

    n = qconsume(p->oq, p->ostage, STAGESIZE);
    if(n <= 0)
        return 0;
    p->op = p->ostage;
    p->oe = p->ostage + n;
    return n;
}

/*
 *  restart output
 */
void
uartkick(void *v)
{
    Uart *p = v;

    if(p->blocked)
        return;

    ilock(&p->tlock);
    (*p->phys->kick)(p);
    iunlock(&p->tlock);

    if(p->drain && uartdrained(p)){
        p->drain = 0;
        wakeup(&p->r);
    }
}

/*
 * Move data from the interrupt staging area to
 * the input Queue.
 */
static void
uartstageinput(Uart *p)
{
    int n;
    uchar *ir, *iw;

    while(p->ir != p->iw){
        ir = p->ir;
        if(p->ir > p->iw){
            iw = p->ie;
            p->ir = p->istage;
        }
        else{
            iw = p->iw;
            p->ir = p->iw;
        }
        if((n = qproduce(p->iq, ir, iw - ir)) < 0){
            p->serr++;
            (*p->phys->rts)(p, 0);
        }
        else if(n == 0)
            p->berr++;
    }
}

/*
 *  receive a character at interrupt time
 */
void
uartrecv(Uart *p,  char ch)
{
    uchar *next;

    /* software flow control */
    if(p->xonoff){
        if(ch == CTLS){
            p->blocked = 1;
        }else if(ch == CTLQ){
            p->blocked = 0;
            p->ctsbackoff = 2; /* clock gets output going again */
        }
    }

    /* receive the character */
    if(p->putc)
        p->putc(p->iq, ch);
    else if (p->iw) {       /* maybe the line isn't enabled yet */
        ilock(&p->rlock);
        next = p->iw + 1;
        if(next == p->ie)
            next = p->istage;
        if(next == p->ir)
            uartstageinput(p);
        if(next != p->ir){
            *p->iw = ch;
            p->iw = next;
        }
        iunlock(&p->rlock);
    }
}

/*
 *  we save up input characters till clock time to reduce
 *  per character interrupt overhead.
 */
static void
uartclock(void)
{
    Uart *p;

    ilock(&uartalloc);
    for(p = uartalloc.elist; p; p = p->elist){

        /* this hopefully amortizes cost of qproduce to many chars */
        if(p->iw != p->ir){
            ilock(&p->rlock);
            uartstageinput(p);
            iunlock(&p->rlock);
        }

        /* hang up if requested */
        if(p->dohup){
            qhangup(p->iq, 0);
            qhangup(p->oq, 0);
            p->dohup = 0;
        }

        /* this adds hysteresis to hardware/software flow control */
        if(p->ctsbackoff){
            ilock(&p->tlock);
            if(p->ctsbackoff){
                if(--(p->ctsbackoff) == 0)
                    (*p->phys->kick)(p);
            }
            iunlock(&p->tlock);
        }
    }
    iunlock(&uartalloc);
}

/*
 * polling console input, output
 */

Uart* consuart;
void (*lprint)(char *, int);

int
uartgetc(void)
{
    if(consuart == nil || consuart->phys->getc == nil)
        return -1;
    return consuart->phys->getc(consuart);
}

void
uartputs(char *s, int n)
{
    char *e;

    if(consuart == nil || consuart->phys->putc == nil) {
        if (lprint)
            (*lprint)(s, n);
        return;
    }
    e = s+n;
    for(; s<e; s++){
        if(*s == '\n')
            consuart->phys->putc(consuart, '\r');
        consuart->phys->putc(consuart, *s);
    }
}
@

%//void
%//uartputc(int c)
%//{
%//  char c2;
%//
%//  if(consuart == nil || consuart->phys->putc == nil) {
%//      c2 = c;
%//      if (lprint)
%//          (*lprint)(&c2, 1);
%//      return;
%//  }
%//  consuart->phys->putc(consuart, c);
%//}


\subsection*{[[buses/portdat_buses.h]]}

<<portdat_buses.h>>=

/*
 *  routines to access UART hardware
 */
struct PhysUart
{
  char* name;
  Uart* (*pnp)(void);
  void  (*enable)(Uart*, int);
  void  (*disable)(Uart*);
  void  (*kick)(Uart*);
  void  (*dobreak)(Uart*, int);
  int (*baud)(Uart*, int);
  int (*bits)(Uart*, int);
  int (*stop)(Uart*, int);
  int (*parity)(Uart*, int);
  void  (*modemctl)(Uart*, int);
  void  (*rts)(Uart*, int);
  void  (*dtr)(Uart*, int);
  long  (*status)(Uart*, void*, long, long);
  void  (*fifo)(Uart*, int);
  void  (*power)(Uart*, int);
  int (*getc)(Uart*); /* polling versions, for iprint, rdb */
  void  (*putc)(Uart*, int);
};

/*
 *  software UART
 */
struct Uart
{
  void* regs;     /* hardware stuff */
  void* saveregs;   /* place to put registers on power down */
  char* name;     /* internal name */
  ulong freq;     /* clock frequency */
  int bits;     /* bits per character */
  int stop;     /* stop bits */
  int parity;     /* even, odd or no parity */
  int baud;     /* baud rate */
  PhysUart*phys;
  bool console;    /* used as a serial console */
  int special;    /* internal kernel device */
  Uart* next;     /* list of allocated uarts */

  QLock;
  int type;     /* ?? */
  int dev;
  int opens;

  int enabled;
  Uart  *elist;     /* next enabled interface */

  int perr;     /* parity errors */
  int ferr;     /* framing errors */
  int oerr;     /* rcvr overruns */
  int berr;     /* no input buffers */
  int serr;     /* input queue overflow */

  /* buffers */
  int (*putc)(Queue*, int);
  Queue *iq;
  Queue *oq;

  Lock  rlock;
  uchar istage[STAGESIZE];
  uchar *iw;
  uchar *ir;
  uchar *ie;

  Lock  tlock;      /* transmit */
  uchar ostage[STAGESIZE];
  uchar *op;
  uchar *oe;
  int drain;

  int modem;      /* hardware flow control on */
  int xonoff;     /* software flow control on */
  int blocked;
  int cts, dsr, dcd;  /* keep track of modem status */ 
  int ctsbackoff;
  int hup_dsr, hup_dcd; /* send hangup upstream? */
  int dohup;

  Rendez  r;
};

extern  Uart* consuart;

//void (*lprint)(char *, int);
@


\subsection*{[[buses/portfns_buses.h]]}

\ifallcode
<<portfns_buses.h>>=

// devuart.c
void    uartsetmouseputc(Uart*, int (*)(Queue*, int));
int   uartstageoutput(Uart*);
void    uartkick(void*);
int   uartgetc(void);
//void    uartputc(int);
void    uartputs(char*, int);
void    uartrecv(Uart*, char);
int   uartctl(Uart*, char*);
void    uartmouse(Uart*, int (*)(Queue*, int), int);

@
\fi

\subsection*{[[console/rdb.c]]}

<<rdb.c debugging macro>>=
#define DBG if(0)scrprint
#pragma varargck argpos scrprint 1
//static Ureg ureg;

static void
scrprint(char *fmt, ...)
{
    char buf[128];
    va_list va;
    int n;

    va_start(va, fmt);
    n = vseprint(buf, buf+sizeof buf, fmt, va)-buf;
    va_end(va);
    putstrn(buf, n);
}
@


<<rdb.c>>=
<<kernel basic includes>>
#include "io.h"
#include <ureg.h>

<<rdb.c debugging macro>>

static char*
getline(void)
{
    static char buf[128];
    int i, c;

    for(;;){
        for(i=0; i<nelem(buf) && (c=uartgetc()) != '\n'; i++){
            DBG("%c...", c);
            buf[i] = c;
        }

        if(i < nelem(buf)){
            buf[i] = 0;
            return buf;
        }
    }
}

static void*
addr(char *s, Ureg *ureg, char **p)
{
    ulong a;

    a = strtoul(s, p, 16);
    if(a < sizeof(Ureg))
        return ((uchar*)ureg)+a;
    return (void*)a;
}

static void
talkrdb(Ureg *ureg)
{
    uchar *a;
    char *p, *req;

    serialoq = nil;     /* turn off serial console */
    kprintoq = nil;     /* turn off /dev/kprint if active */
    DBG("Plan 9 debugger\n");
    iprint("Edebugger reset\n");
    for(;;){
        req = getline();
        switch(*req){
        case 'r':
            a = addr(req+1, ureg, nil);
            DBG("read %p\n", a);
            iprint("R%.8lux %.2ux %.2ux %.2ux %.2ux\n",
                strtoul(req+1, 0, 16), a[0], a[1], a[2], a[3]);
            break;

        case 'w':
            a = addr(req+1, ureg, &p);
            *(ulong*)a = strtoul(p, nil, 16);
            iprint("W\n");
            break;
/*
 *      case Tmput:
            n = min[4];
            if(n > 4){
                mesg(Rerr, Ecount);
                break;
            }
            a = addr(min+0);
            scrprint("mput %.8lux\n", a);
            memmove(a, min+5, n);
            mesg(Rmput, mout);
            break;
 *
 */
        default:
            DBG("unknown %c\n", *req);
            iprint("Eunknown message\n");
            break;
        }
    }
}

void
rdb(void)
{
    splhi();
    iprint("rdb...");
    callwithureg(talkrdb);
}
@


\subsection*{[[console/print.c]]}

<<print.c>>=
<<kernel basic includes>>
// overrides functions defined in lib_core/libc/fmt/fmtlock.c 
// to behave in a special way when libc functions related to fmt
// are called in the kernel.

static Lock fmtl;

//@Scheck: no dead, called from libc
void
_fmtlock(void)
{
    lock(&fmtl);
}

//@Scheck: no dead, called from libc
void
_fmtunlock(void)
{
    unlock(&fmtl);
}

//@Scheck: no dead, called from libc
int
_efgfmt(Fmt*)
{
    return -1;
}
@


\subsection*{[[devices/keyboard/386/latin1.c]]}


<<latin1.c>>=
#include    "u.h"
#include    "../port/lib.h"

/*
 * The code makes two assumptions: strlen(ld) is 1 or 2; latintab[i].ld can be a
 * prefix of latintab[j].ld only when j<i.
 */
struct cvlist
{
    char    *ld;        /* must be seen before using this conversion */
    char    *si;        /* options for last input characters */
    Rune    *so;        /* the corresponding Rune for each si entry */
};

struct cvlist latintab[] = {
#include "../port/latin1.h"
    0,  0,      0
};

/*
 * Given n characters k[0]..k[n-1], find the rune or return -1 for failure.
 */
long
unicode(Rune *k, int n)
{
    long c;
    Rune *r;

    c = 0;
    for(r = &k[1]; r<&k[n]; r++){       /* +1 to skip [Xx] */
        c <<= 4;
        if('0'<=*r && *r<='9')
            c += *r-'0';
        else if('a'<=*r && *r<='f')
            c += 10 + *r-'a';
        else if('A'<=*r && *r<='F')
            c += 10 + *r-'A';
        else
            return -1;
    }
    return c;
}

/*
 * Given n characters k[0]..k[n-1], find the corresponding rune or return -1 for
 * failure, or something < -1 if n is too small.  In the latter case, the result
 * is minus the required n.
 */
long
latin1(Rune *k, int n)
{
    struct cvlist *l;
    int c;
    char* p;

    if(k[0] == 'X')
        if(n>=5)
            return unicode(k, 5);
        else
            return -5;
    if(k[0] == 'x')
        if(n>=UTFmax*2+1)
            return unicode(k, UTFmax*2+1);
        else
            return -(UTFmax+1);

    for(l=latintab; l->ld!=0; l++)
        if(k[0] == l->ld[0]){
            if(n == 1)
                return -2;
            if(l->ld[1] == 0)
                c = k[1];
            else if(l->ld[1] != k[1])
                continue;
            else if(n == 2)
                return -3;
            else
                c = k[2];
            for(p=l->si; *p!=0; p++)
                if(*p == c)
                    return l->so[p - l->si];
            return -1;
        }
    return -1;
}
@


\subsection*{[[devices/keyboard/386/latin1.h]]}



\subsection*{[[devices/storage/386/devfloppy.c]]}

\ifallcode
<<devfloppy.c forward decl>>=
static void floppyintr(Ureg*);
static int floppyon(FDrive*);
static void floppyoff(FDrive*);
static void floppysetdef(FDrive*);

/*
 *  predeclared
 */
static int  cmddone(void*);
static void floppyformat(FDrive*, Cmdbuf*);
static void floppykproc(void*);
static void floppypos(FDrive*,long);
static int  floppyrecal(FDrive*);
static int  floppyresult(void);
static void floppyrevive(void);
static long floppyseek(FDrive*, long);
static int  floppysense(void);
static void floppywait(int);
static long floppyxfer(FDrive*, int, void*, long, long);
@

<<devfloppy.c debugging macro>>=
#define DPRINT if(floppydebug)print
int floppydebug = 0;
@ 
\fi



<<interrupt callback pcfloppyintr>>=
static void
pcfloppyintr(Ureg *ur, void *a)
{
    USED(a);

    floppyintr(ur);
}
@


<<global floppydevtab>>=
Dev floppydevtab = {
    .dc       =    'f',
    .name     =    "floppy",
               
    .reset    =    floppyreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    floppyattach,
    .walk     =    floppywalk,
    .stat     =    floppystat,
    .open     =    floppyopen,
    .create   =    devcreate,
    .close    =    floppyclose,
    .read     =    floppyread,
    .bread    =    devbread,
    .write    =    floppywrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@


<<devfloppy.c>>=
<<kernel basic includes>>
#include    "io.h"
#include    "floppy.h"

/* Intel 82077A (8272A compatible) floppy controller */

/* This module expects the following functions to be defined
 * elsewhere: 
 * 
 * inb()
 * outb()
 * floppyexec()
 * floppyeject() 
 * floppysetup0()
 * floppysetup1()
 * dmainit()
 * dmasetup()
 * dmaend()
 * 
 * On DMA systems, floppyexec() should be an empty function; 
 * on non-DMA systems, dmaend() should be an empty function; 
 * dmasetup() may enforce maximum transfer sizes. 
 */

<<devfloppy.c forward decl>>


<<interrupt callback pcfloppyintr>>

void
floppysetup0(FController *fl)
{
    fl->ndrive = 0;
    if(ioalloc(Psra, 6, 0, "floppy") < 0)
        return;
    if(ioalloc(Pdir, 1, 0, "floppy") < 0){
        iofree(Psra);
        return;
    }
    fl->ndrive = 2;
}

void
floppysetup1(FController *fl)
{
    uchar equip;

    /*
     *  read nvram for types of floppies 0 & 1
     */
    equip = nvramread(0x10);
    if(fl->ndrive > 0){
        fl->d[0].dt = (equip >> 4) & 0xf;
        floppysetdef(&fl->d[0]);
    }
    if(fl->ndrive > 1){
        fl->d[1].dt = equip & 0xf;
        floppysetdef(&fl->d[1]);
    }
    intrenable(IrqFLOPPY, pcfloppyintr, fl, BUSUNKNOWN, "floppy");
}

/*
 *  eject disk ( unknown on safari )
 */
void
floppyeject(FDrive *dp)
{
    floppyon(dp);
    dp->vers++;
    floppyoff(dp);
}

int 
floppyexec(char *a, long b, int c)
{
    USED(a, b, c);
    return b;
}



enum {
    /* file types */
    Qdir=       0, 
    Qdata=      (1<<2),
    Qctl=       (2<<2),
    Qmask=      (3<<2),

    DMAchan=    2,  /* floppy dma channel */
};

<<devfloppy.c debugging macro>>

/*
 *  types of drive (from PC equipment byte)
 */
enum
{
    Tnone=      0,
    T360kb=     1,
    T1200kb=    2,
    T720kb=     3,
    T1440kb=    4,
};

FType floppytype[] =
{
 { "3½HD", T1440kb, 512, 18, 2, 1, 80, 0x1B, 0x54, 0, },
 { "3½DD", T1440kb, 512,  9, 2, 1, 80, 0x1B, 0x54, 2, },
 { "3½DD", T720kb,  512,  9, 2, 1, 80, 0x1B, 0x54, 2, },
 { "5¼HD", T1200kb, 512, 15, 2, 1, 80, 0x2A, 0x50, 0, },
 { "5¼DD", T1200kb, 512,  9, 2, 2, 40, 0x2A, 0x50, 1, },
 { "ATT3B1",    T1200kb, 512,  8, 2, 2, 48, 0x2A, 0x50, 1, },
 { "5¼DD", T360kb,  512,  9, 2, 1, 40, 0x2A, 0x50, 2, },
};

/*
 *  bytes per sector encoding for the controller.
 *  - index for b2c is is (bytes per sector/128).
 *  - index for c2b is code from b2c
 */
static int b2c[] =
{
[1] 0,
[2] 1,
[4] 2,
[8] 3,
};
static int c2b[] =
{
    128,
    256,
    512,
    1024,
};

FController fl;

#define MOTORBIT(i) (1<<((i)+4))


Dirtab floppydir[]={
    ".",        {Qdir, 0, QTDIR},   0,  0550,
    "fd0disk",      {Qdata + 0},    0,  0660,
    "fd0ctl",       {Qctl + 0}, 0,  0660,
    "fd1disk",      {Qdata + 1},    0,  0660,
    "fd1ctl",       {Qctl + 1}, 0,  0660,
    "fd2disk",      {Qdata + 2},    0,  0660,
    "fd2ctl",       {Qctl + 2}, 0,  0660,
    "fd3disk",      {Qdata + 3},    0,  0660,
    "fd3ctl",       {Qctl + 3}, 0,  0660,
};
#define NFDIR   2   /* directory entries/drive */

enum
{
    CMdebug,
    CMnodebug,
    CMeject,
    CMformat,
    CMreset,
};

static Cmdtab floppyctlmsg[] =
{
    CMdebug,    "debug",    1,
    CMnodebug,  "nodebug", 1,
    CMeject,    "eject",    1,
    CMformat,   "format",   0,
    CMreset,    "reset",    1,
};

static void
fldump(void)
{
    DPRINT("sra %ux srb %ux dor %ux msr %ux dir %ux\n", inb(Psra), inb(Psrb),
        inb(Pdor), inb(Pmsr), inb(Pdir));
}

/*
 *  set floppy drive to its default type
 */
static void
floppysetdef(FDrive *dp)
{
    FType *t;

    for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++)
        if(dp->dt == t->dt){
            dp->t = t;
            floppydir[1+NFDIR*dp->dev].length = dp->t->cap;
            break;
        }
}

static void
floppyreset(void)
{
    FDrive *dp;
    FType *t;
    ulong maxtsize;
    
    floppysetup0(&fl);
    if(fl.ndrive == 0)
        return;

    /*
     *  init dependent parameters
     */
    maxtsize = 0;
    for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++){
        t->cap = t->bytes * t->heads * t->sectors * t->tracks;
        t->bcode = b2c[t->bytes/128];
        t->tsize = t->bytes * t->sectors;
        if(maxtsize < t->tsize)
            maxtsize = t->tsize;
    }

    /*
     * Should check if this fails. Can do so
     * if there is no space <= 16MB for the DMA
     * bounce buffer.
     */
    dmainit(DMAchan, maxtsize);

    /*
     *  allocate the drive storage
     */
    fl.d = xalloc(fl.ndrive*sizeof(FDrive));
    fl.selected = fl.d;

    /*
     *  stop the motors
     */
    fl.motor = 0;
    delay(10);
    outb(Pdor, fl.motor | Fintena | Fena);
    delay(10);

    /*
     *  init drives
     */
    for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++){
        dp->dev = dp - fl.d;
        dp->dt = T1440kb;
        floppysetdef(dp);
        dp->cyl = -1;           /* because we don't know */
        dp->cache = (uchar*)xspanalloc(maxtsize, BY2PG, 64*1024);
        dp->ccyl = -1;
        dp->vers = 0;
    }

    /*
     *  first operation will recalibrate
     */
    fl.confused = 1;

    floppysetup1(&fl);
}

static Chan*
floppyattach(char *spec)
{
    static int kstarted;

    if(fl.ndrive == 0)
        error(Enodev);

    if(kstarted == 0){
        /*
         *  watchdog to turn off the motors
         */
        kstarted = 1;
        kproc("floppy", floppykproc, 0);
    }
    return devattach('f', spec);
}

static Walkqid*
floppywalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static int
floppystat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static Chan*
floppyopen(Chan *c, int omode)
{
    return devopen(c, omode, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static void
floppyclose(Chan *)
{
}

static void
islegal(ulong offset, long n, FDrive *dp)
{
    if(offset % dp->t->bytes)
        error(Ebadarg);
    if(n % dp->t->bytes)
        error(Ebadarg);
}

/*
 *  check if the floppy has been replaced under foot.  cause
 *  an error if it has.
 *
 *  a seek and a read clears the condition.  this was determined
 *  experimentally, there has to be a better way.
 *
 *  if the read fails, cycle through the possible floppy
 *  density till one works or we've cycled through all
 *  possibilities for this drive.
 */
static void
changed(Chan *c, FDrive *dp)
{
    ulong old;
    FType *start;

    /*
     *  if floppy has changed or first time through
     */
    if((inb(Pdir)&Fchange) || dp->vers == 0){
        DPRINT("changed\n");
        fldump();
        dp->vers++;
        start = dp->t;
        dp->maxtries = 3;   /* limit it when we're probing */

        /* floppyon will fail if there's a controller but no drive */
        dp->confused = 1;   /* make floppyon recal */
        if(floppyon(dp) < 0)
            error(Eio);

        /* seek to the first track */
        floppyseek(dp, dp->t->heads*dp->t->tsize);
        while(waserror()){
            /*
             *  if first attempt doesn't reset changed bit, there's
             *  no floppy there
             */
            if(inb(Pdir)&Fchange)
                nexterror();

            while(++dp->t){
                if(dp->t == &floppytype[nelem(floppytype)])
                    dp->t = floppytype;
                if(dp->dt == dp->t->dt)
                    break;
            }
            floppydir[1+NFDIR*dp->dev].length = dp->t->cap;

            /* floppyon will fail if there's a controller but no drive */
            if(floppyon(dp) < 0)
                error(Eio);

            DPRINT("changed: trying %s\n", dp->t->name);
            fldump();
            if(dp->t == start)
                nexterror();
        }

        /* if the read succeeds, we've got the density right */
        floppyxfer(dp, Fread, dp->cache, 0, dp->t->tsize);
        poperror();
        dp->maxtries = 20;
    }

    old = c->qid.vers;
    c->qid.vers = dp->vers;
    if(old && old != dp->vers)
        error(Eio);
}

static int
readtrack(FDrive *dp, int cyl, int head)
{
    int i, nn, sofar;
    ulong pos;

    nn = dp->t->tsize;
    if(dp->ccyl==cyl && dp->chead==head)
        return nn;
    pos = (cyl*dp->t->heads+head) * nn;
    for(sofar = 0; sofar < nn; sofar += i){
        dp->ccyl = -1;
        i = floppyxfer(dp, Fread, dp->cache + sofar, pos + sofar, nn - sofar);
        if(i <= 0)
            return -1;
    }
    dp->ccyl = cyl;
    dp->chead = head;
    return nn;
}

static long
floppyread(Chan *c, void *a, long n, vlong off)
{
    FDrive *dp;
    long rv;
    int sec, head, cyl;
    long len;
    uchar *aa;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, floppydir, 1+fl.ndrive*NFDIR, devgen);

    rv = 0;
    dp = &fl.d[c->qid.path & ~Qmask];
    switch ((int)(c->qid.path & Qmask)) {
    case Qdata:
        islegal(offset, n, dp);
        aa = a;

        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        floppyon(dp);
        changed(c, dp);
        for(rv = 0; rv < n; rv += len){
            /*
             *  all xfers come out of the track cache
             */
            dp->len = n - rv;
            floppypos(dp, offset+rv);
            cyl = dp->tcyl;
            head = dp->thead;
            len = dp->len;
            sec = dp->tsec;
            if(readtrack(dp, cyl, head) < 0)
                break;
            memmove(aa+rv, dp->cache + (sec-1)*dp->t->bytes, len);
        }
        qunlock(&fl);
        poperror();

        break;
    case Qctl:
        return readstr(offset, a, n, dp->t->name);
    default:
        panic("floppyread: bad qid");
    }

    return rv;
}

static long
floppywrite(Chan *c, void *a, long n, vlong off)
{
    FDrive *dp;
    long rv, i;
    char *aa = a;
    Cmdbuf *cb;
    Cmdtab *ct;
    ulong offset = off;

    rv = 0;
    dp = &fl.d[c->qid.path & ~Qmask];
    switch ((int)(c->qid.path & Qmask)) {
    case Qdata:
        islegal(offset, n, dp);
        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        floppyon(dp);
        changed(c, dp);
        for(rv = 0; rv < n; rv += i){
            floppypos(dp, offset+rv);
            if(dp->tcyl == dp->ccyl)
                dp->ccyl = -1;
            i = floppyxfer(dp, Fwrite, aa+rv, offset+rv, n-rv);
            if(i < 0)
                break;
            if(i == 0)
                error(Eio);
        }
        qunlock(&fl);
        poperror();
        break;
    case Qctl:
        rv = n;
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        ct = lookupcmd(cb, floppyctlmsg, nelem(floppyctlmsg));
        switch(ct->index){
        case CMeject:
            floppyeject(dp);
            break;
        case CMformat:
            floppyformat(dp, cb);
            break;
        case CMreset:
            fl.confused = 1;
            floppyon(dp);
            break;
        case CMdebug:
            floppydebug = 1;
            break;
        case CMnodebug:
            floppydebug = 0;
            break;
        }
        poperror();
        qunlock(&fl);
        poperror();
        free(cb);
        break;
    default:
        panic("floppywrite: bad qid");
    }

    return rv;
}

static void
floppykproc(void *)
{
    FDrive *dp;

    while(waserror())
        ;
    for(;;){
        for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++){
            if((fl.motor&MOTORBIT(dp->dev))
            && TK2SEC(cpu->ticks - dp->lasttouched) > 5
            && canqlock(&fl)){
                if(TK2SEC(cpu->ticks - dp->lasttouched) > 5)
                    floppyoff(dp);
                qunlock(&fl);
            }
        }
        tsleep(&up->sleepr, returnfalse, 0, 1000);
    }
}

/*
 *  start a floppy drive's motor.
 */
static int
floppyon(FDrive *dp)
{
    int alreadyon;
    int tries;

    if(fl.confused)
        floppyrevive();

    /* start motor and select drive */
    alreadyon = fl.motor & MOTORBIT(dp->dev);
    fl.motor |= MOTORBIT(dp->dev);
    outb(Pdor, fl.motor | Fintena | Fena | dp->dev);
    if(!alreadyon){
        /* wait for drive to spin up */
        tsleep(&up->sleepr, returnfalse, 0, 750);

        /* clear any pending interrupts */
        floppysense();
    }

    /* set transfer rate */
    if(fl.rate != dp->t->rate){
        fl.rate = dp->t->rate;
        outb(Pdsr, fl.rate);
    }

    /* get drive to a known cylinder */
    if(dp->confused)
        for(tries = 0; tries < 4; tries++)
            if(floppyrecal(dp) >= 0)
                break;
    dp->lasttouched = cpu->ticks;
    fl.selected = dp;

    /* return -1 if this didn't work */
    if(dp->confused)
        return -1;
    return 0;
}

/*
 *  stop the floppy if it hasn't been used in 5 seconds
 */
static void
floppyoff(FDrive *dp)
{
    fl.motor &= ~MOTORBIT(dp->dev);
    outb(Pdor, fl.motor | Fintena | Fena | dp->dev);
}

/*
 *  send a command to the floppy
 */
static int
floppycmd(void)
{
    int i;
    int tries;

    fl.nstat = 0;
    for(i = 0; i < fl.ncmd; i++){
        for(tries = 0; ; tries++){
            if((inb(Pmsr)&(Ffrom|Fready)) == Fready)
                break;
            if(tries > 1000){
                DPRINT("cmd %ux can't be sent (%d)\n", fl.cmd[0], i);
                fldump();

                /* empty fifo, might have been a bad command */
                floppyresult();
                return -1;
            }
            microdelay(8);  /* for machine independence */
        }
        outb(Pfdata, fl.cmd[i]);
    }
    return 0;
}

/*
 *  get a command result from the floppy
 *
 *  when the controller goes ready waiting for a command
 *  (instead of sending results), we're done
 * 
 */
static int
floppyresult(void)
{
    int i, s;
    int tries;

    /* get the result of the operation */
    for(i = 0; i < sizeof(fl.stat); i++){
        /* wait for status byte */
        for(tries = 0; ; tries++){
            s = inb(Pmsr)&(Ffrom|Fready);
            if(s == Fready){
                fl.nstat = i;
                return fl.nstat;
            }
            if(s == (Ffrom|Fready))
                break;
            if(tries > 1000){
                DPRINT("floppyresult: %d stats\n", i);
                fldump();
                fl.confused = 1;
                return -1;
            }
            microdelay(8);  /* for machine independence */
        }
        fl.stat[i] = inb(Pfdata);
    }
    fl.nstat = sizeof(fl.stat);
    return fl.nstat;
}

/*
 *  calculate physical address of a logical byte offset into the disk
 *
 *  truncate dp->length if it crosses a track boundary
 */
static void
floppypos(FDrive *dp, long off)
{
    int lsec;
    int ltrack;
    int end;

    lsec = off/dp->t->bytes;
    ltrack = lsec/dp->t->sectors;
    dp->tcyl = ltrack/dp->t->heads;
    dp->tsec = (lsec % dp->t->sectors) + 1;
    dp->thead = (lsec/dp->t->sectors) % dp->t->heads;

    /*
     *  can't read across track boundaries.
     *  if so, decrement the bytes to be read.
     */
    end = (ltrack+1)*dp->t->sectors*dp->t->bytes;
    if(off+dp->len > end)
        dp->len = end - off;
}

/*
 *  get the interrupt cause from the floppy.
 */
static int
floppysense(void)
{
    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Fsense;
    if(floppycmd() < 0)
        return -1;
    if(floppyresult() < 2){
        DPRINT("can't read sense response\n");
        fldump();
        fl.confused = 1;
        return -1;
    }
    return 0;
}

static int
cmddone(void *)
{
    return fl.ncmd == 0;
}

/*
 *  Wait for a floppy interrupt.  If none occurs in 5 seconds, we
 *  may have missed one.  This only happens on some portables which
 *  do power management behind our backs.  Call the interrupt
 *  routine to try to clear any conditions.
 */
static void
floppywait(int slow)
{
    tsleep(&fl.r, cmddone, 0, slow ? 5000 : 1000);
    if(!cmddone(0)){
        floppyintr(0);
        fl.confused = 1;
    }
}

/*
 *  we've lost the floppy position, go to cylinder 0.
 */
static int
floppyrecal(FDrive *dp)
{
    dp->ccyl = -1;
    dp->cyl = -1;

    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Frecal;
    fl.cmd[fl.ncmd++] = dp->dev;
    if(floppycmd() < 0)
        return -1;
    floppywait(1);
    if(fl.nstat < 2){
        DPRINT("recalibrate: confused %ux\n", inb(Pmsr));
        fl.confused = 1;
        return -1;
    }
    if((fl.stat[0] & (Codemask|Seekend)) != Seekend){
        DPRINT("recalibrate: failed\n");
        dp->confused = 1;
        return -1;
    }
    dp->cyl = fl.stat[1];
    if(dp->cyl != 0){
        DPRINT("recalibrate: wrong cylinder %d\n", dp->cyl);
        dp->cyl = -1;
        dp->confused = 1;
        return -1;
    }

    dp->confused = 0;
    return 0;
}

/*
 *  if the controller or a specific drive is in a confused state,
 *  reset it and get back to a known state
 */
static void
floppyrevive(void)
{
    FDrive *dp;

    /*
     *  reset the controller if it's confused
     */
    if(fl.confused){
        DPRINT("floppyrevive in\n");
        fldump();

        /* reset controller and turn all motors off */
        splhi();
        fl.ncmd = 1;
        fl.cmd[0] = 0;
        outb(Pdor, 0);
        delay(10);
        outb(Pdor, Fintena|Fena);
        delay(10);
        spllo();
        fl.motor = 0;
        fl.confused = 0;
        floppywait(0);

        /* mark all drives in an unknown state */
        for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++)
            dp->confused = 1;

        /* set rate to a known value */
        outb(Pdsr, 0);
        fl.rate = 0;

        DPRINT("floppyrevive out\n");
        fldump();
    }
}

/*
 *  seek to the target cylinder
 *
 *  interrupt, no results
 */
static long
floppyseek(FDrive *dp, long off)
{
    floppypos(dp, off);
    if(dp->cyl == dp->tcyl)
        return dp->tcyl;
    dp->cyl = -1;

    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Fseek;
    fl.cmd[fl.ncmd++] = (dp->thead<<2) | dp->dev;
    fl.cmd[fl.ncmd++] = dp->tcyl * dp->t->steps;
    if(floppycmd() < 0)
        return -1;
    floppywait(1);
    if(fl.nstat < 2){
        DPRINT("seek: confused\n");
        fl.confused = 1;
        return -1;
    }
    if((fl.stat[0] & (Codemask|Seekend)) != Seekend){
        DPRINT("seek: failed\n");
        dp->confused = 1;
        return -1;
    }

    dp->cyl = dp->tcyl;
    return dp->tcyl;
}

/*
 *  read or write to floppy.  try up to three times.
 */
static long
floppyxfer(FDrive *dp, int cmd, void *a, long off, long n)
{
    long offset;
    int tries;

    if(off >= dp->t->cap)
        return 0;
    if(off + n > dp->t->cap)
        n = dp->t->cap - off;

    /* retry on error (until it gets ridiculous) */
    tries = 0;
    while(waserror()){
        if(tries++ >= dp->maxtries)
            nexterror();
        DPRINT("floppyxfer: retrying\n");
    }

    dp->len = n;
    if(floppyseek(dp, off) < 0){
        DPRINT("xfer: seek failed\n");
        dp->confused = 1;
        error(Eio);
    }

    /*
     *  set up the dma (dp->len may be trimmed)
     */
    if(waserror()){
        dmaend(DMAchan);
        nexterror();
    }
    dp->len = dmasetup(DMAchan, a, dp->len, cmd==Fread);
    if(dp->len < 0)
        error(Eio);

    /*
     *  start operation
     */
    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = cmd | (dp->t->heads > 1 ? Fmulti : 0);
    fl.cmd[fl.ncmd++] = (dp->thead<<2) | dp->dev;
    fl.cmd[fl.ncmd++] = dp->tcyl;
    fl.cmd[fl.ncmd++] = dp->thead;
    fl.cmd[fl.ncmd++] = dp->tsec;
    fl.cmd[fl.ncmd++] = dp->t->bcode;
    fl.cmd[fl.ncmd++] = dp->t->sectors;
    fl.cmd[fl.ncmd++] = dp->t->gpl;
    fl.cmd[fl.ncmd++] = 0xFF;
    if(floppycmd() < 0)
        error(Eio);

    /* Poll ready bits and transfer data */
    floppyexec((char*)a, dp->len, cmd==Fread);

    /*
     *  give bus to DMA, floppyintr() will read result
     */
    floppywait(0);
    dmaend(DMAchan);
    poperror();

    /*
     *  check for errors
     */
    if(fl.nstat < 7){
        DPRINT("xfer: confused\n");
        fl.confused = 1;
        error(Eio);
    }
    if((fl.stat[0] & Codemask)!=0 || fl.stat[1] || fl.stat[2]){
        DPRINT("xfer: failed %ux %ux %ux\n", fl.stat[0],
            fl.stat[1], fl.stat[2]);
        DPRINT("offset %lud len %ld\n", off, dp->len);
        if((fl.stat[0]&Codemask)==Cmdexec && fl.stat[1]==Overrun){
            DPRINT("DMA overrun: retry\n");
        } else
            dp->confused = 1;
        error(Eio);
    }

    /*
     *  check for correct cylinder
     */
    offset = fl.stat[3] * dp->t->heads + fl.stat[4];
    offset = offset*dp->t->sectors + fl.stat[5] - 1;
    offset = offset * c2b[fl.stat[6]];
    if(offset != off+dp->len){
        DPRINT("xfer: ends on wrong cyl\n");
        dp->confused = 1;
        error(Eio);
    }
    poperror();

    dp->lasttouched = cpu->ticks;
    return dp->len;
}

/*
 *  format a track
 */
static void
floppyformat(FDrive *dp, Cmdbuf *cb)
{
    int cyl, h, sec;
    ulong track;
    uchar *buf, *bp;
    FType *t;

    /*
     *  set the type
     */
    if(cb->nf == 2){
        for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++){
            if(strcmp(cb->f[1], t->name)==0 && t->dt==dp->dt){
                dp->t = t;
                floppydir[1+NFDIR*dp->dev].length = dp->t->cap;
                break;
            }
        }
        if(t >= &floppytype[nelem(floppytype)])
            error(Ebadarg);
    } else if(cb->nf == 1){
        floppysetdef(dp);
        t = dp->t;
    } else {
        cmderror(cb, "invalid floppy format command");
        SET(t);
    }

    /*
     *  buffer for per track info
     */
    buf = smalloc(t->sectors*4);
    if(waserror()){
        free(buf);
        nexterror();
    }

    /* force a recalibrate to cylinder 0 */
    dp->confused = 1;
    if(!waserror()){
        floppyon(dp);
        poperror();
    }

    /*
     *  format a track at time
     */
    for(track = 0; track < t->tracks*t->heads; track++){
        cyl = track/t->heads;
        h = track % t->heads;

        /*
         *  seek to track, ignore errors
         */
        floppyseek(dp, track*t->tsize);
        dp->cyl = cyl;
        dp->confused = 0;

        /*
         *  set up the dma (dp->len may be trimmed)
         */
        bp = buf;
        for(sec = 1; sec <= t->sectors; sec++){
            *bp++ = cyl;
            *bp++ = h;
            *bp++ = sec;
            *bp++ = t->bcode;
        }
        if(waserror()){
            dmaend(DMAchan);
            nexterror();
        }
        if(dmasetup(DMAchan, buf, bp-buf, 0) < 0)
            error(Eio);

        /*
         *  start operation
         */
        fl.ncmd = 0;
        fl.cmd[fl.ncmd++] = Fformat;
        fl.cmd[fl.ncmd++] = (h<<2) | dp->dev;
        fl.cmd[fl.ncmd++] = t->bcode;
        fl.cmd[fl.ncmd++] = t->sectors;
        fl.cmd[fl.ncmd++] = t->fgpl;
        fl.cmd[fl.ncmd++] = 0x5a;
        if(floppycmd() < 0)
            error(Eio);

        /* Poll ready bits and transfer data */
        floppyexec((char *)buf, bp-buf, 0);

        /*
         *  give bus to DMA, floppyintr() will read result
         */
        floppywait(1);
        dmaend(DMAchan);
        poperror();

        /*
         *  check for errors
         */
        if(fl.nstat < 7){
            DPRINT("format: confused\n");
            fl.confused = 1;
            error(Eio);
        }
        if((fl.stat[0]&Codemask)!=0 || fl.stat[1]|| fl.stat[2]){
            DPRINT("format: failed %ux %ux %ux\n",
                fl.stat[0], fl.stat[1], fl.stat[2]);
            dp->confused = 1;
            error(Eio);
        }
    }
    free(buf);
    dp->confused = 1;
    poperror();
}

static void
floppyintr(Ureg *)
{
    switch(fl.cmd[0]&~Fmulti){
    case Fread:
    case Fwrite:
    case Fformat:
    case Fdumpreg: 
        floppyresult();
        break;
    case Fseek:
    case Frecal:
    default:
        floppysense();  /* to clear interrupt */
        break;
    }
    fl.ncmd = 0;
    wakeup(&fl.r);
}

<<global floppydevtab>>
@


\subsection*{[[devices/storage/386/floppy.h]]}

\ifallcode
<<floppy.h forward decl>>=
typedef struct FController FController;
typedef struct FDrive FDrive;
typedef struct FType FType;
@
\fi

<<floppy.h>>=
<<floppy.h forward decl>>

// why not inlined in devfloppy.c? used by other programs?

/*
 *  a floppy drive
 */
struct FDrive
{
  FType *t;   /* floppy type */
  int dt;   /* drive type */
  int dev;

  ulong lasttouched;  /* time last touched */
  int cyl;    /* current arm position */
  int confused; /* needs to be recalibrated */
  int vers;
  int maxtries; /* max read attempts before Eio */

  int tcyl;   /* target cylinder */
  int thead;    /* target head */
  int tsec;   /* target sector */
  long  len;    /* size of xfer */

  uchar *cache;   /* track cache */
  int ccyl;
  int chead;
};

/*
 *  controller for 4 floppys
 */
struct FController
{
  QLock;      /* exclusive access to the contoller */

  int ndrive;
  FDrive  *d;   /* the floppy drives */
  FDrive  *selected;
  int rate;   /* current rate selected */
  uchar cmd[14];  /* command */
  int ncmd;   /* # command bytes */
  uchar stat[14]; /* command status */
  int nstat;    /* # status bytes */
  int confused; /* controler needs to be reset */
  Rendez  r;    /* wait here for command termination */
  int motor;    /* bit mask of spinning disks */
};

/*
 *  floppy types (all MFM encoding)
 */
struct FType
{
  char  *name;
  int dt;   /* compatible drive type */
  int bytes;    /* bytes/sector */
  int sectors;  /* sectors/track */
  int heads;    /* number of heads */
  int steps;    /* steps per cylinder */
  int tracks;   /* tracks/disk */
  int gpl;    /* intersector gap length for read/write */ 
  int fgpl;   /* intersector gap length for format */
  int rate;   /* rate code */

  /*
   *  these depend on previous entries and are set filled in
   *  by floppyinit
   */
  int bcode;    /* coded version of bytes for the controller */
  long  cap;    /* drive capacity in bytes */
  long  tsize;    /* track size in bytes */
};

/* bits in the registers */
enum
{
  /* status registers a & b */
  Psra=   0x3f0,
  Psrb=   0x3f1,

  /* digital output register */
  Pdor=   0x3f2,
  Fintena=  0x8,  /* enable floppy interrupt */
  Fena=   0x4,  /* 0 == reset controller */

  /* main status register */
  Pmsr=   0x3f4,
  Fready=   0x80, /* ready to be touched */
  Ffrom=    0x40, /* data from controller */
  Ffloppybusy=  0x10, /* operation not over */

  /* data register */
  Pfdata=   0x3f5,
  Frecal=   0x07, /* recalibrate cmd */
  Fseek=    0x0f, /* seek cmd */
  Fsense=   0x08, /* sense cmd */
  Fread=    0x66, /* read cmd */
  Freadid=  0x4a, /* read track id */
  Fspec=    0x03, /* set hold times */
  Fwrite=   0x45, /* write cmd */
  Fformat=  0x4d, /* format cmd */
  Fmulti=   0x80, /* or'd with Fread or Fwrite for multi-head */
  Fdumpreg= 0x0e, /* dump internal registers */

  /* digital input register */
  Pdir=   0x3F7,  /* disk changed port (read only) */
  Pdsr=   0x3F7,  /* data rate select port (write only) */
  Fchange=  0x80, /* disk has changed */

  /* status 0 byte */
  Drivemask=  3<<0,
  Seekend=  1<<5,
  Codemask= (3<<6)|(3<<3),
  Cmdexec=  1<<6,

  /* status 1 byte */
  Overrun=  0x10,
};

@


\subsection*{[[devices/storage/386/sdata.c]]}

\ifallcode
<<sdata.c forward decl>>=
typedef struct Ctlr Ctlr;
typedef struct Drive Drive;
typedef struct Prd Prd;
@
\fi

% very very big, skipped for now
\ifallcode
<<sdata.c>>=
<<kernel basic includes>>

#include "io.h"
#include "../port/sd.h"

#include <ureg.h>

extern SDifc sdataifc;

enum {
    DbgCONFIG   = 0x0001,   /* detected drive config info */
    DbgIDENTIFY = 0x0002,   /* detected drive identify info */
    DbgSTATE    = 0x0004,   /* dump state on panic */
    DbgPROBE    = 0x0008,   /* trace device probing */
    DbgDEBUG    = 0x0080,   /* the current problem... */
    DbgINL      = 0x0100,   /* That Inil20+ message we hate */
    Dbg48BIT    = 0x0200,   /* 48-bit LBA */
    DbgBsy      = 0x0400,   /* interrupt but Bsy (shared IRQ) */
};
#define DEBUG       (DbgDEBUG|DbgSTATE)

enum {                  /* I/O ports */
    Data        = 0,
    Error       = 1,        /* (read) */
    Features    = 1,        /* (write) */
    Count       = 2,        /* sector count<7-0>, sector count<15-8> */
    Ir      = 2,        /* interrupt reason (PACKET) */
    Sector      = 3,        /* sector number */
    Lbalo       = 3,        /* LBA<7-0>, LBA<31-24> */
    Cyllo       = 4,        /* cylinder low */
    Bytelo      = 4,        /* byte count low (PACKET) */
    Lbamid      = 4,        /* LBA<15-8>, LBA<39-32> */
    Cylhi       = 5,        /* cylinder high */
    Bytehi      = 5,        /* byte count hi (PACKET) */
    Lbahi       = 5,        /* LBA<23-16>, LBA<47-40> */
    Dh      = 6,        /* Device/Head, LBA<27-24> */
    Status      = 7,        /* (read) */
    Command     = 7,        /* (write) */

    As      = 2,        /* Alternate Status (read) */
    Dc      = 2,        /* Device Control (write) */
};

enum {                  /* Error */
    Med     = 0x01,     /* Media error */
    Ili     = 0x01,     /* command set specific (PACKET) */
    Nm      = 0x02,     /* No Media */
    Eom     = 0x02,     /* command set specific (PACKET) */
    Abrt        = 0x04,     /* Aborted command */
    Mcr     = 0x08,     /* Media Change Request */
    Idnf        = 0x10,     /* no user-accessible address */
    Mc      = 0x20,     /* Media Change */
    Unc     = 0x40,     /* Uncorrectable data error */
    Wp      = 0x40,     /* Write Protect */
    Icrc        = 0x80,     /* Interface CRC error */
};

enum {                  /* Features */
    Dma     = 0x01,     /* data transfer via DMA (PACKET) */
    Ovl     = 0x02,     /* command overlapped (PACKET) */
};

enum {                  /* Interrupt Reason */
    Cd      = 0x01,     /* Command/Data */
    Io      = 0x02,     /* I/O direction: read */
    Rel     = 0x04,     /* Bus Release */
};

enum {                  /* Device/Head */
    Dev0        = 0xA0,     /* Master */
    Dev1        = 0xB0,     /* Slave */
    Lba     = 0x40,     /* LBA mode */
};

enum {                  /* Status, Alternate Status */
    Err     = 0x01,     /* Error */
    Chk     = 0x01,     /* Check error (PACKET) */
    Drq     = 0x08,     /* Data Request */
    Dsc     = 0x10,     /* Device Seek Complete */
    Serv        = 0x10,     /* Service */
    Df      = 0x20,     /* Device Fault */
    Dmrd        = 0x20,     /* DMA ready (PACKET) */
    Drdy        = 0x40,     /* Device Ready */
    Bsy     = 0x80,     /* Busy */
};

enum {                  /* Command */
    Cnop        = 0x00,     /* NOP */
    Cdr     = 0x08,     /* Device Reset */
    Crs     = 0x20,     /* Read Sectors */
    Crs48       = 0x24,     /* Read Sectors Ext */
    Crd48       = 0x25,     /* Read w/ DMA Ext */
    Crdq48      = 0x26,     /* Read w/ DMA Queued Ext */
    Crsm48      = 0x29,     /* Read Multiple Ext */
    Cws     = 0x30,     /* Write Sectors */
    Cws48       = 0x34,     /* Write Sectors Ext */
    Cwd48       = 0x35,     /* Write w/ DMA Ext */
    Cwdq48      = 0x36,     /* Write w/ DMA Queued Ext */
    Cwsm48      = 0x39,     /* Write Multiple Ext */
    Cedd        = 0x90,     /* Execute Device Diagnostics */
    Cpkt        = 0xA0,     /* Packet */
    Cidpkt      = 0xA1,     /* Identify Packet Device */
    Crsm        = 0xC4,     /* Read Multiple */
    Cwsm        = 0xC5,     /* Write Multiple */
    Csm     = 0xC6,     /* Set Multiple */
    Crdq        = 0xC7,     /* Read DMA queued */
    Crd     = 0xC8,     /* Read DMA */
    Cwd     = 0xCA,     /* Write DMA */
    Cwdq        = 0xCC,     /* Write DMA queued */
    Cstandby    = 0xE2,     /* Standby */
    Cid     = 0xEC,     /* Identify Device */
    Csf     = 0xEF,     /* Set Features */
};

enum {                  /* Device Control */
    Nien        = 0x02,     /* (not) Interrupt Enable */
    Srst        = 0x04,     /* Software Reset */
    Hob     = 0x80,     /* High Order Bit [sic] */
};

enum {                  /* PCI Configuration Registers */
    Bmiba       = 0x20,     /* Bus Master Interface Base Address */
    Idetim      = 0x40,     /* IE Timing */
    Sidetim     = 0x44,     /* Slave IE Timing */
    Udmactl     = 0x48,     /* Ultra DMA/33 Control */
    Udmatim     = 0x4A,     /* Ultra DMA/33 Timing */
};

enum {                  /* Bus Master IDE I/O Ports */
    Bmicx       = 0,        /* Command */
    Bmisx       = 2,        /* Status */
    Bmidtpx     = 4,        /* Descriptor Table Pointer */
};

enum {                  /* Bmicx */
    Ssbm        = 0x01,     /* Start/Stop Bus Master */
    Rwcon       = 0x08,     /* Read/Write Control */
};

enum {                  /* Bmisx */
    Bmidea      = 0x01,     /* Bus Master IDE Active */
    Idedmae     = 0x02,     /* IDE DMA Error  (R/WC) */
    Ideints     = 0x04,     /* IDE Interrupt Status (R/WC) */
    Dma0cap     = 0x20,     /* Drive 0 DMA Capable */
    Dma1cap     = 0x40,     /* Drive 0 DMA Capable */
};
enum {                  /* Physical Region Descriptor */
    PrdEOT      = 0x80000000,   /* End of Transfer */
};

enum {                  /* offsets into the identify info. */
    Iconfig     = 0,        /* general configuration */
    Ilcyl       = 1,        /* logical cylinders */
    Ilhead      = 3,        /* logical heads */
    Ilsec       = 6,        /* logical sectors per logical track */
    Iserial     = 10,       /* serial number */
    Ifirmware   = 23,       /* firmware revision */
    Imodel      = 27,       /* model number */
    Imaxrwm     = 47,       /* max. read/write multiple sectors */
    Icapabilities   = 49,       /* capabilities */
    Istandby    = 50,       /* device specific standby timer */
    Ipiomode    = 51,       /* PIO data transfer mode number */
    Ivalid      = 53,
    Iccyl       = 54,       /* cylinders if (valid&0x01) */
    Ichead      = 55,       /* heads if (valid&0x01) */
    Icsec       = 56,       /* sectors if (valid&0x01) */
    Iccap       = 57,       /* capacity if (valid&0x01) */
    Irwm        = 59,       /* read/write multiple */
    Ilba        = 60,       /* LBA size */
    Imwdma      = 63,       /* multiword DMA mode */
    Iapiomode   = 64,       /* advanced PIO modes supported */
    Iminmwdma   = 65,       /* min. multiword DMA cycle time */
    Irecmwdma   = 66,       /* rec. multiword DMA cycle time */
    Iminpio     = 67,       /* min. PIO cycle w/o flow control */
    Iminiordy   = 68,       /* min. PIO cycle with IORDY */
    Ipcktbr     = 71,       /* time from PACKET to bus release */
    Iserbsy     = 72,       /* time from SERVICE to !Bsy */
    Iqdepth     = 75,       /* max. queue depth */
    Imajor      = 80,       /* major version number */
    Iminor      = 81,       /* minor version number */
    Icsfs       = 82,       /* command set/feature supported */
    Icsfe       = 85,       /* command set/feature enabled */
    Iudma       = 88,       /* ultra DMA mode */
    Ierase      = 89,       /* time for security erase */
    Ieerase     = 90,       /* time for enhanced security erase */
    Ipower      = 91,       /* current advanced power management */
    Ilba48      = 100,      /* 48-bit LBA size (64 bits in 100-103) */
    Irmsn       = 127,      /* removable status notification */
    Isecstat    = 128,      /* security status */
    Icfapwr     = 160,      /* CFA power mode */
    Imediaserial    = 176,      /* current media serial number */
    Icksum      = 255,      /* checksum */
};

enum {                  /* bit masks for config identify info */
    Mpktsz      = 0x0003,   /* packet command size */
    Mincomplete = 0x0004,   /* incomplete information */
    Mdrq        = 0x0060,   /* DRQ type */
    Mrmdev      = 0x0080,   /* device is removable */
    Mtype       = 0x1F00,   /* device type */
    Mproto      = 0x8000,   /* command protocol */
};

enum {                  /* bit masks for capabilities identify info */
    Mdma        = 0x0100,   /* DMA supported */
    Mlba        = 0x0200,   /* LBA supported */
    Mnoiordy    = 0x0400,   /* IORDY may be disabled */
    Miordy      = 0x0800,   /* IORDY supported */
    Msoftrst    = 0x1000,   /* needs soft reset when Bsy */
    Mstdby      = 0x2000,   /* standby supported */
    Mqueueing   = 0x4000,   /* queueing overlap supported */
    Midma       = 0x8000,   /* interleaved DMA supported */
};

enum {                  /* bit masks for supported/enabled features */
    Msmart      = 0x0001,
    Msecurity   = 0x0002,
    Mrmmedia    = 0x0004,
    Mpwrmgmt    = 0x0008,
    Mpkt        = 0x0010,
    Mwcache     = 0x0020,
    Mlookahead  = 0x0040,
    Mrelirq     = 0x0080,
    Msvcirq     = 0x0100,
    Mreset      = 0x0200,
    Mprotected  = 0x0400,
    Mwbuf       = 0x1000,
    Mrbuf       = 0x2000,
    Mnop        = 0x4000,
    Mmicrocode  = 0x0001,
    Mqueued     = 0x0002,
    Mcfa        = 0x0004,
    Mapm        = 0x0008,
    Mnotify     = 0x0010,
    Mstandby    = 0x0020,
    Mspinup     = 0x0040,
    Mmaxsec     = 0x0100,
    Mautoacoustic   = 0x0200,
    Maddr48     = 0x0400,
    Mdevconfov  = 0x0800,
    Mflush      = 0x1000,
    Mflush48    = 0x2000,
    Msmarterror = 0x0001,
    Msmartselftest  = 0x0002,
    Mmserial    = 0x0004,
    Mmpassthru  = 0x0008,
    Mlogging    = 0x0020,
};

<<sdata.c forward decl>>

struct Prd {            /* Physical Region Descriptor */
    ulong   pa;         /* Physical Base Address */
    int count;
};

enum {
    BMspan      = 64*1024,  /* must be power of 2 <= 64*1024 */

    Nprd        = SDmaxio/BMspan+2,
};

struct Ctlr {
    int cmdport;
    int ctlport;
    int irq;
    int tbdf;
    int bmiba;          /* bus master interface base address */
    int maxio;          /* sector count transfer maximum */
    int span;           /* don't span this boundary with dma */

    Pcidev* pcidev;
    void    (*ienable)(Ctlr*);
    void    (*idisable)(Ctlr*);
    SDev*   sdev;

    Drive*  drive[2];

    Prd*    prdt;           /* physical region descriptor table */
    void    (*irqack)(Ctlr*);   /* call to extinguish ICH intrs */

    QLock;              /* current command */
    Drive*  curdrive;
    int command;        /* last command issued (debugging) */
    Rendez;
    int done;

    /* interrupt counts */
    ulong   intnil;         /* no drive */
    ulong   intbusy;        /* controller still busy */
    ulong   intok;          /* normal */

    Lock;               /* register access */
};

struct Drive {
    Ctlr*   ctlr;

    int dev;
    ushort  info[256];
    int c;          /* cylinder */
    int h;          /* head */
    int s;          /* sector */
    vlong   sectors;        /* total */
    int secsize;        /* sector size */

    int dma;            /* DMA R/W possible */
    int dmactl;
    int rwm;            /* read/write multiple possible */
    int rwmctl;

    int pkt;            /* PACKET device, length of pktcmd */
    uchar   pktcmd[16];
    int pktdma;         /* this PACKET command using dma */

    uchar   sense[18];
    uchar   inquiry[48];

    QLock;              /* drive access */
    int command;        /* current command */
    int write;
    uchar*  data;
    int dlen;
    uchar*  limit;
    int count;          /* sectors */
    int block;          /* R/W bytes per block */
    int status;
    int error;
    int flags;          /* internal flags */

    /* interrupt counts */
    ulong   intcmd;         /* commands */
    ulong   intrd;          /* reads */
    ulong   intwr;          /* writes */
};

enum {                  /* internal flags */
    Lba48       = 0x1,      /* LBA48 mode */
    Lba48always = 0x2,      /* ... */
};
enum {
    Last28      = (1<<28) - 1 - 1, /* all-ones mask is not addressible */
};

static void
pc87415ienable(Ctlr* ctlr)
{
    Pcidev *p;
    int x;

    p = ctlr->pcidev;
    if(p == nil)
        return;

    x = pcicfgr32(p, 0x40);
    if(ctlr->cmdport == p->mem[0].bar)
        x &= ~0x00000100;
    else
        x &= ~0x00000200;
    pcicfgw32(p, 0x40, x);
}

static void
atadumpstate(Drive* drive, uchar* cmd, vlong lba, int count)
{
    Prd *prd;
    Pcidev *p;
    Ctlr *ctlr;
    int i, bmiba;

    if(!(DEBUG & DbgSTATE)){
        USED(drive, cmd, lba, count);
        return;
    }

    ctlr = drive->ctlr;
    print("sdata: command %2.2uX\n", ctlr->command);
    print("data %8.8p limit %8.8p dlen %d status %uX error %uX\n",
        drive->data, drive->limit, drive->dlen,
        drive->status, drive->error);
    if(cmd != nil){
        print("lba %d -> %lld, count %d -> %d (%d)\n",
            (cmd[2]<<24)|(cmd[3]<<16)|(cmd[4]<<8)|cmd[5], lba,
            (cmd[7]<<8)|cmd[8], count, drive->count);
    }
    if(!(inb(ctlr->ctlport+As) & Bsy)){
        for(i = 1; i < 7; i++)
            print(" 0x%2.2uX", inb(ctlr->cmdport+i));
        print(" 0x%2.2uX\n", inb(ctlr->ctlport+As));
    }
    if(drive->command == Cwd || drive->command == Crd){
        bmiba = ctlr->bmiba;
        prd = ctlr->prdt;
        print("bmicx %2.2uX bmisx %2.2uX prdt %8.8p\n",
            inb(bmiba+Bmicx), inb(bmiba+Bmisx), prd);
        for(;;){
            print("pa 0x%8.8luX count %8.8uX\n",
                prd->pa, prd->count);
            if(prd->count & PrdEOT)
                break;
            prd++;
        }
    }
    if(ctlr->pcidev && ctlr->pcidev->vid == 0x8086){
        p = ctlr->pcidev;
        print("0x40: %4.4uX 0x42: %4.4uX",
            pcicfgr16(p, 0x40), pcicfgr16(p, 0x42));
        print("0x48: %2.2uX\n", pcicfgr8(p, 0x48));
        print("0x4A: %4.4uX\n", pcicfgr16(p, 0x4A));
    }
}

static int
atadebug(int cmdport, int ctlport, char* fmt, ...)
{
    int i, n;
    va_list arg;
    char buf[PRINTSIZE];

    if(!(DEBUG & DbgPROBE)){
        USED(cmdport, ctlport, fmt);
        return 0;
    }

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    if(cmdport){
        if(buf[n-1] == '\n')
            n--;
        n += snprint(buf+n, PRINTSIZE-n, " ataregs 0x%uX:",
            cmdport);
        for(i = Features; i < Command; i++)
            n += snprint(buf+n, PRINTSIZE-n, " 0x%2.2uX",
                inb(cmdport+i));
        if(ctlport)
            n += snprint(buf+n, PRINTSIZE-n, " 0x%2.2uX",
                inb(ctlport+As));
        n += snprint(buf+n, PRINTSIZE-n, "\n");
    }
    putstrn(buf, n);

    return n;
}

static int
ataready(int cmdport, int ctlport, int dev, int reset, int ready, int micro)
{
    int as;

    atadebug(cmdport, ctlport, "ataready: dev %uX reset %uX ready %uX",
        dev, reset, ready);

    for(;;){
        /*
         * Wait for the controller to become not busy and
         * possibly for a status bit to become true (usually
         * Drdy). Must change to the appropriate device
         * register set if necessary before testing for ready.
         * Always run through the loop at least once so it
         * can be used as a test for !Bsy.
         */
        as = inb(ctlport+As);
        if(as & reset){
            /* nothing to do */
        }
        else if(dev){
            outb(cmdport+Dh, dev);
            dev = 0;
        }
        else if(ready == 0 || (as & ready)){
            atadebug(0, 0, "ataready: %d 0x%2.2uX\n", micro, as);
            return as;
        }

        if(micro-- <= 0){
            atadebug(0, 0, "ataready: %d 0x%2.2uX\n", micro, as);
            break;
        }
        microdelay(1);
    }
    atadebug(cmdport, ctlport, "ataready: timeout");

    return -1;
}

/*
static int
atacsf(Drive* drive, vlong csf, int supported)
{
    ushort *info;
    int cmdset, i, x;

    if(supported)
        info = &drive->info[Icsfs];
    else
        info = &drive->info[Icsfe];

    for(i = 0; i < 3; i++){
        x = (csf>>(16*i)) & 0xFFFF;
        if(x == 0)
            continue;
        cmdset = info[i];
        if(cmdset == 0 || cmdset == 0xFFFF)
            return 0;
        return cmdset & x;
    }

    return 0;
}
*/

static int
atadone(void* arg)
{
    return ((Ctlr*)arg)->done;
}

static int
atarwmmode(Drive* drive, int cmdport, int ctlport, int dev)
{
    int as, maxrwm, rwm;

    maxrwm = (drive->info[Imaxrwm] & 0xFF);
    if(maxrwm == 0)
        return 0;

    /*
     * Sometimes drives come up with the current count set
     * to 0; if so, set a suitable value, otherwise believe
     * the value in Irwm if the 0x100 bit is set.
     */
    if(drive->info[Irwm] & 0x100)
        rwm = (drive->info[Irwm] & 0xFF);
    else
        rwm = 0;
    if(rwm == 0)
        rwm = maxrwm;
    if(rwm > 16)
        rwm = 16;
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, Drdy, 102*1000) < 0)
        return 0;
    outb(cmdport+Count, rwm);
    outb(cmdport+Command, Csm);
    microdelay(1);
    as = ataready(cmdport, ctlport, 0, Bsy, Drdy|Df|Err, 1000);
    inb(cmdport+Status);
    if(as < 0 || (as & (Df|Err)))
        return 0;

    drive->rwm = rwm;

    return rwm;
}

static int
atadmamode(Drive* drive)
{
    int dma;

    /*
     * Check if any DMA mode enabled.
     * Assumes the BIOS has picked and enabled the best.
     * This is completely passive at the moment, no attempt is
     * made to ensure the hardware is correctly set up.
     */
    dma = drive->info[Imwdma] & 0x0707;
    drive->dma = (dma>>8) & dma;
    if(drive->dma == 0 && (drive->info[Ivalid] & 0x04)){
        dma = drive->info[Iudma] & 0x7F7F;
        drive->dma = (dma>>8) & dma;
        if(drive->dma)
            drive->dma |= 'U'<<16;
    }

    return dma;
}

static int
ataidentify(int cmdport, int ctlport, int dev, int pkt, void* info)
{
    int as, command, drdy;

    if(pkt){
        command = Cidpkt;
        drdy = 0;
    }
    else{
        command = Cid;
        drdy = Drdy;
    }
    as = ataready(cmdport, ctlport, dev, Bsy|Drq, drdy, 103*1000);
    if(as < 0)
        return as;
    outb(cmdport+Command, command);
    microdelay(1);

    as = ataready(cmdport, ctlport, 0, Bsy, Drq|Err, 400*1000);
    if(as < 0)
        return -1;
    if(as & Err)
        return as;

    memset(info, 0, 512);
    inss(cmdport+Data, info, 256);
    inb(cmdport+Status);

    if(DEBUG & DbgIDENTIFY){
        int i;
        ushort *sp;

        sp = (ushort*)info;
        for(i = 0; i < 256; i++){
            if(i && (i%16) == 0)
                print("\n");
            print(" %4.4uX", *sp);
            sp++;
        }
        print("\n");
    }

    return 0;
}

static Drive*
atadrive(int cmdport, int ctlport, int dev)
{
    Drive *drive;
    int as, i, pkt;
    uchar buf[512], *p;
    ushort iconfig, *sp;

    atadebug(0, 0, "identify: port 0x%uX dev 0x%2.2uX\n", cmdport, dev);
    pkt = 1;
retry:
    as = ataidentify(cmdport, ctlport, dev, pkt, buf);
    if(as < 0)
        return nil;
    if(as & Err){
        if(pkt == 0)
            return nil;
        pkt = 0;
        goto retry;
    }

    if((drive = malloc(sizeof(Drive))) == nil)
        return nil;
    drive->dev = dev;
    memmove(drive->info, buf, sizeof(drive->info));
    drive->sense[0] = 0x70;
    drive->sense[7] = sizeof(drive->sense)-7;

    drive->inquiry[2] = 2;
    drive->inquiry[3] = 2;
    drive->inquiry[4] = sizeof(drive->inquiry)-4;
    p = &drive->inquiry[8];
    sp = &drive->info[Imodel];
    for(i = 0; i < 20; i++){
        *p++ = *sp>>8;
        *p++ = *sp++;
    }

    drive->secsize = 512;

    /*
     * Beware the CompactFlash Association feature set.
     * Now, why this value in Iconfig just walks all over the bit
     * definitions used in the other parts of the ATA/ATAPI standards
     * is a mystery and a sign of true stupidity on someone's part.
     * Anyway, the standard says if this value is 0x848A then it's
     * CompactFlash and it's NOT a packet device.
     */
    iconfig = drive->info[Iconfig];
    if(iconfig != 0x848A && (iconfig & 0xC000) == 0x8000){
        if(iconfig & 0x01)
            drive->pkt = 16;
        else
            drive->pkt = 12;
    }
    else{
        if(drive->info[Ivalid] & 0x0001){
            drive->c = drive->info[Iccyl];
            drive->h = drive->info[Ichead];
            drive->s = drive->info[Icsec];
        }
        else{
            drive->c = drive->info[Ilcyl];
            drive->h = drive->info[Ilhead];
            drive->s = drive->info[Ilsec];
        }
        if(drive->info[Icapabilities] & Mlba){
            if(drive->info[Icsfs+1] & Maddr48){
                drive->sectors = drive->info[Ilba48]
                    | (drive->info[Ilba48+1]<<16)
                    | ((vlong)drive->info[Ilba48+2]<<32);
                drive->flags |= Lba48;
            }
            else{
                drive->sectors = (drive->info[Ilba+1]<<16)
                     |drive->info[Ilba];
            }
            drive->dev |= Lba;
        }
        else
            drive->sectors = drive->c*drive->h*drive->s;
        atarwmmode(drive, cmdport, ctlport, dev);
    }
    atadmamode(drive);  

    if(DEBUG & DbgCONFIG){
        print("dev %2.2uX port %uX config %4.4uX capabilities %4.4uX",
            dev, cmdport, iconfig, drive->info[Icapabilities]);
        print(" mwdma %4.4uX", drive->info[Imwdma]);
        if(drive->info[Ivalid] & 0x04)
            print(" udma %4.4uX", drive->info[Iudma]);
        print(" dma %8.8uX rwm %ud", drive->dma, drive->rwm);
        if(drive->flags&Lba48)
            print("\tLLBA sectors %lld", drive->sectors);
        print("\n");
    }

    return drive;
}

static void
atasrst(int ctlport)
{
    /*
     * Srst is a big stick and may cause problems if further
     * commands are tried before the drives become ready again.
     * Also, there will be problems here if overlapped commands
     * are ever supported.
     */
    microdelay(5);
    outb(ctlport+Dc, Srst);
    microdelay(5);
    outb(ctlport+Dc, 0);
    microdelay(2*1000);
}

static SDev*
ataprobe(int cmdport, int ctlport, int irq)
{
    Ctlr* ctlr;
    SDev *sdev;
    Drive *drive;
    int dev, error, rhi, rlo;
    static int nonlegacy = 'C';
    
    if(cmdport == 0) {
        print("ataprobe: cmdport is 0\n");
        return nil;
    }
    if(ioalloc(cmdport, 8, 0, "atacmd") < 0) {
        print("ataprobe: Cannot allocate %X\n", cmdport);
        return nil;
    }
    if(ioalloc(ctlport+As, 1, 0, "atactl") < 0){
        print("ataprobe: Cannot allocate %X\n", ctlport + As);
        iofree(cmdport);
        return nil;
    }

    /*
     * Try to detect a floating bus.
     * Bsy should be cleared. If not, see if the cylinder registers
     * are read/write capable.
     * If the master fails, try the slave to catch slave-only
     * configurations.
     * There's no need to restore the tested registers as they will
     * be reset on any detected drives by the Cedd command.
     * All this indicates is that there is at least one drive on the
     * controller; when the non-existent drive is selected in a
     * single-drive configuration the registers of the existing drive
     * are often seen, only command execution fails.
     */
    dev = Dev0;
    if(inb(ctlport+As) & Bsy){
        outb(cmdport+Dh, dev);
        microdelay(1);
trydev1:
        atadebug(cmdport, ctlport, "ataprobe bsy");
        outb(cmdport+Cyllo, 0xAA);
        outb(cmdport+Cylhi, 0x55);
        outb(cmdport+Sector, 0xFF);
        rlo = inb(cmdport+Cyllo);
        rhi = inb(cmdport+Cylhi);
        if(rlo != 0xAA && (rlo == 0xFF || rhi != 0x55)){
            if(dev == Dev1){
release:
                iofree(cmdport);
                iofree(ctlport+As);
                return nil;
            }
            dev = Dev1;
            if(ataready(cmdport, ctlport, dev, Bsy, 0, 20*1000) < 0)
                goto trydev1;
        }
    }

    /*
     * Disable interrupts on any detected controllers.
     */
    outb(ctlport+Dc, Nien);
tryedd1:
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 105*1000) < 0){
        /*
         * There's something there, but it didn't come up clean,
         * so try hitting it with a big stick. The timing here is
         * wrong but this is a last-ditch effort and it sometimes
         * gets some marginal hardware back online.
         */
        atasrst(ctlport);
        if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 106*1000) < 0)
            goto release;
    }

    /*
     * Can only get here if controller is not busy.
     * If there are drives Bsy will be set within 400nS,
     * must wait 2mS before testing Status.
     * Wait for the command to complete (6 seconds max).
     */
    outb(cmdport+Command, Cedd);
    delay(2);
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 6*1000*1000) < 0)
        goto release;

    /*
     * If bit 0 of the error register is set then the selected drive
     * exists. This is enough to detect single-drive configurations.
     * However, if the master exists there is no way short of executing
     * a command to determine if a slave is present.
     * It appears possible to get here testing Dev0 although it doesn't
     * exist and the EDD won't take, so try again with Dev1.
     */
    error = inb(cmdport+Error);
    atadebug(cmdport, ctlport, "ataprobe: dev %uX", dev);
    if((error & ~0x80) != 0x01){
        if(dev == Dev1)
            goto release;
        dev = Dev1;
        goto tryedd1;
    }

    /*
     * At least one drive is known to exist, try to
     * identify it. If that fails, don't bother checking
     * any further.
     * If the one drive found is Dev0 and the EDD command
     * didn't indicate Dev1 doesn't exist, check for it.
     */
    if((drive = atadrive(cmdport, ctlport, dev)) == nil)
        goto release;
    if((ctlr = malloc(sizeof(Ctlr))) == nil){
        free(drive);
        goto release;
    }
    memset(ctlr, 0, sizeof(Ctlr));
    if((sdev = malloc(sizeof(SDev))) == nil){
        free(ctlr);
        free(drive);
        goto release;
    }
    memset(sdev, 0, sizeof(SDev));
    drive->ctlr = ctlr;
    if(dev == Dev0){
        ctlr->drive[0] = drive;
        if(!(error & 0x80)){
            /*
             * Always leave Dh pointing to a valid drive,
             * otherwise a subsequent call to ataready on
             * this controller may try to test a bogus Status.
             * Ataprobe is the only place possibly invalid
             * drives should be selected.
             */
            drive = atadrive(cmdport, ctlport, Dev1);
            if(drive != nil){
                drive->ctlr = ctlr;
                ctlr->drive[1] = drive;
            }
            else{
                outb(cmdport+Dh, Dev0);
                microdelay(1);
            }
        }
    }
    else
        ctlr->drive[1] = drive;

    ctlr->cmdport = cmdport;
    ctlr->ctlport = ctlport;
    ctlr->irq = irq;
    ctlr->tbdf = BUSUNKNOWN;
    ctlr->command = Cedd;       /* debugging */
    
    switch(cmdport){
    default:
        sdev->idno = nonlegacy;
        break;
    case 0x1F0:
        sdev->idno = 'C';
        nonlegacy = 'E';
        break;
    case 0x170:
        sdev->idno = 'D';
        nonlegacy = 'E';
        break;
    }
    sdev->ifc = &sdataifc;
    sdev->ctlr = ctlr;
    sdev->nunit = 2;
    ctlr->sdev = sdev;

    return sdev;
}

static void
ataclear(SDev *sdev)
{
    Ctlr* ctlr;

    ctlr = sdev->ctlr;
    iofree(ctlr->cmdport);
    iofree(ctlr->ctlport + As);

    if (ctlr->drive[0])
        free(ctlr->drive[0]);
    if (ctlr->drive[1])
        free(ctlr->drive[1]);
    if (sdev->name)
        free(sdev->name);
    if (sdev->unitflg)
        free(sdev->unitflg);
    if (sdev->unit)
        free(sdev->unit);
    free(ctlr);
    free(sdev);
}

static char *
atastat(SDev *sdev, char *p, char *e)
{
    Ctlr *ctlr = sdev->ctlr;

    return seprint(p, e, "%s ata port %X ctl %X irq %d "
        "intr-ok %lud intr-busy %lud intr-nil-drive %lud\n",
        sdev->name, ctlr->cmdport, ctlr->ctlport, ctlr->irq,
        ctlr->intok, ctlr->intbusy, ctlr->intnil);
}

static SDev*
ataprobew(DevConf *cf)
{
    char *p;
    ISAConf isa;
    
    if (cf->nports != 2)
        error(Ebadarg);

    memset(&isa, 0, sizeof isa);
    isa.port = cf->ports[0].port;
    isa.irq = cf->intnum;
    if((p=strchr(cf->type, '/')) == nil || pcmspecial(p+1, &isa) < 0)
        error("cannot find controller");

    return ataprobe(cf->ports[0].port, cf->ports[1].port, cf->intnum);
}

/*
 * These are duplicated with sdsetsense, etc., in devsd.c, but
 * those assume that the disk is not SCSI while in fact here
 * ata drives are not SCSI but ATAPI ones kind of are.
 */
static int
atasetsense(Drive* drive, int status, int key, int asc, int ascq)
{
    drive->sense[2] = key;
    drive->sense[12] = asc;
    drive->sense[13] = ascq;

    return status;
}

static int
atamodesense(Drive* drive, uchar* cmd)
{
    int len;

    /*
     * Fake a vendor-specific request with page code 0,
     * return the drive info.
     */
    if((cmd[2] & 0x3F) != 0 && (cmd[2] & 0x3F) != 0x3F)
        return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
    len = (cmd[7]<<8)|cmd[8];
    if(len == 0)
        return SDok;
    if(len < 8+sizeof(drive->info))
        return atasetsense(drive, SDcheck, 0x05, 0x1A, 0);
    if(drive->data == nil || drive->dlen < len)
        return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
    memset(drive->data, 0, 8);
    drive->data[0] = sizeof(drive->info)>>8;
    drive->data[1] = sizeof(drive->info);
    memmove(drive->data+8, drive->info, sizeof(drive->info));
    drive->data += 8+sizeof(drive->info);

    return SDok;
}

static int
atastandby(Drive* drive, int period)
{
    Ctlr* ctlr;
    int cmdport, done;

    ctlr = drive->ctlr;
    drive->command = Cstandby;
    qlock(ctlr);

    cmdport = ctlr->cmdport;
    ilock(ctlr);
    outb(cmdport+Count, period);
    outb(cmdport+Dh, drive->dev);
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = Cstandby;   /* debugging */
    outb(cmdport+Command, Cstandby);
    iunlock(ctlr);

    while(waserror())
        ;
    tsleep(ctlr, atadone, ctlr, 60*1000);
    poperror();

    done = ctlr->done;
    qunlock(ctlr);

    if(!done || (drive->status & Err))
        return atasetsense(drive, SDcheck, 4, 8, drive->error);
    return SDok;
}

static void
atanop(Drive* drive, int subcommand)
{
    Ctlr* ctlr;
    int as, cmdport, ctlport, timeo;

    /*
     * Attempt to abort a command by using NOP.
     * In response, the drive is supposed to set Abrt
     * in the Error register, set (Drdy|Err) in Status
     * and clear Bsy when done. However, some drives
     * (e.g. ATAPI Zip) just go Bsy then clear Status
     * when done, hence the timeout loop only on Bsy
     * and the forced setting of drive->error.
     */
    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    outb(cmdport+Features, subcommand);
    outb(cmdport+Dh, drive->dev);
    ctlr->command = Cnop;       /* debugging */
    outb(cmdport+Command, Cnop);

    microdelay(1);
    ctlport = ctlr->ctlport;
    for(timeo = 0; timeo < 1000; timeo++){
        as = inb(ctlport+As);
        if(!(as & Bsy))
            break;
        microdelay(1);
    }
    drive->error |= Abrt;
}

static void
ataabort(Drive* drive, int dolock)
{
    /*
     * If NOP is available (packet commands) use it otherwise
     * must try a software reset.
     */
    if(dolock)
        ilock(drive->ctlr);
    if(drive->info[Icsfs] & Mnop)
        atanop(drive, 0);
    else{
        atasrst(drive->ctlr->ctlport);
        drive->error |= Abrt;
    }
    if(dolock)
        iunlock(drive->ctlr);
}

static int
atadmasetup(Drive* drive, int len)
{
    Prd *prd;
    ulong pa;
    Ctlr *ctlr;
    int bmiba, bmisx, count, i, span;

    ctlr = drive->ctlr;
    pa = PCIWADDR(drive->data);
    if(pa & 0x03)
        return -1;

    /*
     * Sometimes drives identify themselves as being DMA capable
     * although they are not on a busmastering controller.
     */
    prd = ctlr->prdt;
    if(prd == nil){
        drive->dmactl = 0;
        print("disabling dma: not on a busmastering controller\n");
        return -1;
    }

    for(i = 0; len && i < Nprd; i++){
        prd->pa = pa;
        span = ROUNDUP(pa, ctlr->span);
        if(span == pa)
            span += ctlr->span;
        count = span - pa;
        if(count >= len){
            prd->count = PrdEOT|len;
            break;
        }
        prd->count = count;
        len -= count;
        pa += count;
        prd++;
    }
    if(i == Nprd)
        (prd-1)->count |= PrdEOT;

    bmiba = ctlr->bmiba;
    outl(bmiba+Bmidtpx, PCIWADDR(ctlr->prdt));
    if(drive->write)
        outb(ctlr->bmiba+Bmicx, 0);
    else
        outb(ctlr->bmiba+Bmicx, Rwcon);
    bmisx = inb(bmiba+Bmisx);
    outb(bmiba+Bmisx, bmisx|Ideints|Idedmae);

    return 0;
}

static void
atadmastart(Ctlr* ctlr, int write)
{
    if(write)
        outb(ctlr->bmiba+Bmicx, Ssbm);
    else
        outb(ctlr->bmiba+Bmicx, Rwcon|Ssbm);
}

static int
atadmastop(Ctlr* ctlr)
{
    int bmiba;

    bmiba = ctlr->bmiba;
    outb(bmiba+Bmicx, inb(bmiba+Bmicx) & ~Ssbm);

    return inb(bmiba+Bmisx);
}

static void
atadmainterrupt(Drive* drive, int count)
{
    Ctlr* ctlr;
    int bmiba, bmisx;

    ctlr = drive->ctlr;
    bmiba = ctlr->bmiba;
    bmisx = inb(bmiba+Bmisx);
    switch(bmisx & (Ideints|Idedmae|Bmidea)){
    case Bmidea:
        /*
         * Data transfer still in progress, nothing to do
         * (this should never happen).
         */
        return;

    case Ideints:
    case Ideints|Bmidea:
        /*
         * Normal termination, tidy up.
         */
        drive->data += count;
        break;

    default:
        /*
         * What's left are error conditions (memory transfer
         * problem) and the device is not done but the PRD is
         * exhausted. For both cases must somehow tell the
         * drive to abort.
         */
        ataabort(drive, 0);
        break;
    }
    atadmastop(ctlr);
    ctlr->done = 1;
}

static void
atapktinterrupt(Drive* drive)
{
    Ctlr* ctlr;
    int cmdport, len, sts;

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    sts = inb(cmdport+Ir) & (/*Rel|*/ Io|Cd);
    /* a default case is impossible since all cases are enumerated */
    switch(sts){
    case Cd:            /* write cmd */
        outss(cmdport+Data, drive->pktcmd, drive->pkt/2);
        break;

    case 0:             /* write data */
        len = (inb(cmdport+Bytehi)<<8)|inb(cmdport+Bytelo);
        if(drive->data+len > drive->limit){
            atanop(drive, 0);
            break;
        }
        outss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        break;

    case Io:            /* read data */
        len = (inb(cmdport+Bytehi)<<8)|inb(cmdport+Bytelo);
        if(drive->data+len > drive->limit){
            atanop(drive, 0);
            break;
        }
        inss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        break;

    case Io|Cd:         /* read cmd */
        if(drive->pktdma)
            atadmainterrupt(drive, drive->dlen);
        else
            ctlr->done = 1;
        break;
    }
    if(sts & Cd)
        drive->intcmd++;
    if(sts & Io)
        drive->intrd++;
    else
        drive->intwr++;
}

static int
atapktio(Drive* drive, uchar* cmd, int clen)
{
    Ctlr *ctlr;
    int as, cmdport, ctlport, len, r, timeo;

    if(cmd[0] == 0x5A && (cmd[2] & 0x3F) == 0)
        return atamodesense(drive, cmd);

    r = SDok;

    drive->command = Cpkt;
    memmove(drive->pktcmd, cmd, clen);
    memset(drive->pktcmd+clen, 0, drive->pkt-clen);
    drive->limit = drive->data+drive->dlen;

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    ctlport = ctlr->ctlport;

    qlock(ctlr);

    as = ataready(cmdport, ctlport, drive->dev, Bsy|Drq, Drdy, 107*1000);
    /* used to test as&Chk as failure too, but some CD readers use that for media change */
    if(as < 0){
        qunlock(ctlr);
        return -1;
    }

    ilock(ctlr);
    if(drive->dlen && drive->dmactl && !atadmasetup(drive, drive->dlen))
        drive->pktdma = Dma;
    else
        drive->pktdma = 0;

    outb(cmdport+Features, drive->pktdma);
    outb(cmdport+Count, 0);
    outb(cmdport+Sector, 0);
    len = 16*drive->secsize;
    outb(cmdport+Bytelo, len);
    outb(cmdport+Bytehi, len>>8);
    outb(cmdport+Dh, drive->dev);
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = Cpkt;       /* debugging */
    if(drive->pktdma)
        atadmastart(ctlr, drive->write);
    outb(cmdport+Command, Cpkt);

    if((drive->info[Iconfig] & Mdrq) != 0x0020){
        microdelay(1);
        as = ataready(cmdport, ctlport, 0, Bsy, Drq|Chk, 4*1000);
        if(as < 0 || (as & (Bsy|Chk))){
            drive->status = as<0 ? 0 : as;
            ctlr->curdrive = nil;
            ctlr->done = 1;
            r = SDtimeout;
        }else
            atapktinterrupt(drive);
    }
    iunlock(ctlr);

    while(waserror())
        ;
    if(!drive->pktdma)
        sleep(ctlr, atadone, ctlr);
    else for(timeo = 0; !ctlr->done; timeo++){
        tsleep(ctlr, atadone, ctlr, 1000);
        if(ctlr->done)
            break;
        ilock(ctlr);
        atadmainterrupt(drive, 0);
        if(!drive->error && timeo > 20){
            ataabort(drive, 0);
            atadmastop(ctlr);
            drive->dmactl = 0;
            drive->error |= Abrt;
        }
        if(drive->error){
            drive->status |= Chk;
            ctlr->curdrive = nil;
        }
        iunlock(ctlr);
    }
    poperror();

    qunlock(ctlr);

    if(drive->status & Chk)
        r = SDcheck;

    return r;
}

static uchar cmd48[256] = {
    [Crs]   Crs48,
    [Crd]   Crd48,
    [Crdq]  Crdq48,
    [Crsm]  Crsm48,
    [Cws]   Cws48,
    [Cwd]   Cwd48,
    [Cwdq]  Cwdq48,
    [Cwsm]  Cwsm48,
};

static int
atageniostart(Drive* drive, uvlong lba)
{
    Ctlr *ctlr;
    uchar cmd;
    int as, c, cmdport, ctlport, h, len, s, use48;

    use48 = 0;
    if((drive->flags&Lba48always) || lba > Last28 || drive->count > 256){
        if(!(drive->flags & Lba48))
            return -1;
        use48 = 1;
        c = h = s = 0;
    }
    else if(drive->dev & Lba){
        c = (lba>>8) & 0xFFFF;
        h = (lba>>24) & 0x0F;
        s = lba & 0xFF;
    }
    else{
        c = lba/(drive->s*drive->h);
        h = ((lba/drive->s) % drive->h);
        s = (lba % drive->s) + 1;
    }

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    ctlport = ctlr->ctlport;
    if(ataready(cmdport, ctlport, drive->dev, Bsy|Drq, Drdy, 101*1000) < 0)
        return -1;

    ilock(ctlr);
    if(drive->dmactl && !atadmasetup(drive, drive->count*drive->secsize)){
        if(drive->write)
            drive->command = Cwd;
        else
            drive->command = Crd;
    }
    else if(drive->rwmctl){
        drive->block = drive->rwm*drive->secsize;
        if(drive->write)
            drive->command = Cwsm;
        else
            drive->command = Crsm;
    }
    else{
        drive->block = drive->secsize;
        if(drive->write)
            drive->command = Cws;
        else
            drive->command = Crs;
    }
    drive->limit = drive->data + drive->count*drive->secsize;
    cmd = drive->command;
    if(use48){
        outb(cmdport+Count, drive->count>>8);
        outb(cmdport+Count, drive->count);
        outb(cmdport+Lbalo, lba>>24);
        outb(cmdport+Lbalo, lba);
        outb(cmdport+Lbamid, lba>>32);
        outb(cmdport+Lbamid, lba>>8);
        outb(cmdport+Lbahi, lba>>40);
        outb(cmdport+Lbahi, lba>>16);
        outb(cmdport+Dh, drive->dev|Lba);
        cmd = cmd48[cmd];

        if(DEBUG & Dbg48BIT)
            print("using 48-bit commands\n");
    }
    else{
        outb(cmdport+Count, drive->count);
        outb(cmdport+Sector, s);
        outb(cmdport+Cyllo, c);
        outb(cmdport+Cylhi, c>>8);
        outb(cmdport+Dh, drive->dev|h);
    }
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = drive->command; /* debugging */
    outb(cmdport+Command, cmd);

    switch(drive->command){
    case Cws:
    case Cwsm:
        microdelay(1);
        /* 10*1000 for flash ide drives - maybe detect them? */
        as = ataready(cmdport, ctlport, 0, Bsy, Drq|Err, 10*1000);
        if(as < 0 || (as & Err)){
            iunlock(ctlr);
            return -1;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        outss(cmdport+Data, drive->data, len/2);
        break;

    case Crd:
    case Cwd:
        atadmastart(ctlr, drive->write);
        break;
    }
    iunlock(ctlr);

    return 0;
}

static int
atagenioretry(Drive* drive)
{
    if(drive->dmactl){
        drive->dmactl = 0;
        print("atagenioretry: disabling dma\n");
    }
    else if(drive->rwmctl)
        drive->rwmctl = 0;
    else
        return atasetsense(drive, SDcheck, 4, 8, drive->error);

    return SDretry;
}

static int
atagenio(Drive* drive, uchar* cmd, int clen)
{
    uchar *p;
    Ctlr *ctlr;
    vlong lba, len;
    int count, maxio;

    /*
     * Map SCSI commands into ATA commands for discs.
     * Fail any command with a LUN except INQUIRY which
     * will return 'logical unit not supported'.
     */
    if((cmd[1]>>5) && cmd[0] != 0x12)
        return atasetsense(drive, SDcheck, 0x05, 0x25, 0);

    switch(cmd[0]){
    default:
        return atasetsense(drive, SDcheck, 0x05, 0x20, 0);

    case 0x00:          /* test unit ready */
        return SDok;

    case 0x03:          /* request sense */
        if(cmd[4] < sizeof(drive->sense))
            len = cmd[4];
        else
            len = sizeof(drive->sense);
        if(drive->data && drive->dlen >= len){
            memmove(drive->data, drive->sense, len);
            drive->data += len;
        }
        return SDok;

    case 0x12:          /* inquiry */
        if(cmd[4] < sizeof(drive->inquiry))
            len = cmd[4];
        else
            len = sizeof(drive->inquiry);
        if(drive->data && drive->dlen >= len){
            memmove(drive->data, drive->inquiry, len);
            drive->data += len;
        }
        return SDok;

    case 0x1B:          /* start/stop unit */
        /*
         * NOP for now, can use the power management feature
         * set later.
         */
        return SDok;

    case 0x25:          /* read capacity */
        if((cmd[1] & 0x01) || cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
        if(drive->data == nil || drive->dlen < 8)
            return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
        /*
         * Read capacity returns the LBA of the last sector.
         */
        len = drive->sectors-1;
        p = drive->data;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p++ = len;
        len = drive->secsize;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p = len;
        drive->data += 8;
        return SDok;

    case 0x9E:          /* long read capacity */
        if((cmd[1] & 0x01) || cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
        if(drive->data == nil || drive->dlen < 8)
            return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
        /*
         * Read capacity returns the LBA of the last sector.
         */
        len = drive->sectors-1;
        p = drive->data;
        *p++ = len>>56;
        *p++ = len>>48;
        *p++ = len>>40;
        *p++ = len>>32;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p++ = len;
        len = drive->secsize;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p = len;
        drive->data += 12;
        return SDok;

    case 0x28:          /* read (10) */
    case 0x88:          /* long read (16) */
    case 0x2a:          /* write (10) */
    case 0x8a:          /* long write (16) */
    case 0x2e:          /* write and verify (10) */
        break;

    case 0x5A:
        return atamodesense(drive, cmd);
    }

    ctlr = drive->ctlr;
    if(clen == 16){
        /* ata commands only go to 48-bit lba */
        if(cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 3, 0xc, 2);
        lba = (uvlong)cmd[4]<<40 | (uvlong)cmd[5]<<32;
        lba |= cmd[6]<<24 | cmd[7]<<16 | cmd[8]<<8 | cmd[9];
        count = cmd[10]<<24 | cmd[11]<<16 | cmd[12]<<8 | cmd[13];
    }else{
        lba = cmd[2]<<24 | cmd[3]<<16 | cmd[4]<<8 | cmd[5];
        count = cmd[7]<<8 | cmd[8];
    }
    if(drive->data == nil)
        return SDok;
    if(drive->dlen < count*drive->secsize)
        count = drive->dlen/drive->secsize;
    qlock(ctlr);
    if(ctlr->maxio)
        maxio = ctlr->maxio;
    else if(drive->flags & Lba48)
        maxio = 65536;
    else
        maxio = 256;
    while(count){
        if(count > maxio)
            drive->count = maxio;
        else
            drive->count = count;
        if(atageniostart(drive, lba)){
            ilock(ctlr);
            atanop(drive, 0);
            iunlock(ctlr);
            qunlock(ctlr);
            return atagenioretry(drive);
        }

        while(waserror())
            ;
        tsleep(ctlr, atadone, ctlr, 60*1000);
        poperror();
        if(!ctlr->done){
            /*
             * What should the above timeout be? In
             * standby and sleep modes it could take as
             * long as 30 seconds for a drive to respond.
             * Very hard to get out of this cleanly.
             */
            atadumpstate(drive, cmd, lba, count);
            ataabort(drive, 1);
            qunlock(ctlr);
            return atagenioretry(drive);
        }

        if(drive->status & Err){
            qunlock(ctlr);
            return atasetsense(drive, SDcheck, 4, 8, drive->error);
        }
        count -= drive->count;
        lba += drive->count;
    }
    qunlock(ctlr);

    return SDok;
}

static int
atario(SDreq* r)
{
    Ctlr *ctlr;
    Drive *drive;
    SDunit *unit;
    uchar cmd10[10], *cmdp, *p;
    int clen, reqstatus, status;

    unit = r->unit;
    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil){
        r->status = SDtimeout;
        return SDtimeout;
    }
    drive = ctlr->drive[unit->subno];

    /*
     * Most SCSI commands can be passed unchanged except for
     * the padding on the end. The few which require munging
     * are not used internally. Mode select/sense(6) could be
     * converted to the 10-byte form but it's not worth the
     * effort. Read/write(6) are easy.
     */
    switch(r->cmd[0]){
    case 0x08:          /* read */
    case 0x0A:          /* write */
        cmdp = cmd10;
        memset(cmdp, 0, sizeof(cmd10));
        cmdp[0] = r->cmd[0]|0x20;
        cmdp[1] = r->cmd[1] & 0xE0;
        cmdp[5] = r->cmd[3];
        cmdp[4] = r->cmd[2];
        cmdp[3] = r->cmd[1] & 0x0F;
        cmdp[8] = r->cmd[4];
        clen = sizeof(cmd10);
        break;

    default:
        cmdp = r->cmd;
        clen = r->clen;
        break;
    }

    qlock(drive);
retry:
    drive->write = r->write;
    drive->data = r->data;
    drive->dlen = r->dlen;

    drive->status = 0;
    drive->error = 0;
    if(drive->pkt)
        status = atapktio(drive, cmdp, clen);
    else
        status = atagenio(drive, cmdp, clen);
    if(status == SDretry){
        if(DbgDEBUG)
            print("%s: retry: dma %8.8uX rwm %4.4uX\n",
                unit->name, drive->dmactl, drive->rwmctl);
        goto retry;
    }
    if(status == SDok){
        atasetsense(drive, SDok, 0, 0, 0);
        if(drive->data){
            p = r->data;
            r->rlen = drive->data - p;
        }
        else
            r->rlen = 0;
    }
    else if(status == SDcheck && !(r->flags & SDnosense)){
        drive->write = 0;
        memset(cmd10, 0, sizeof(cmd10));
        cmd10[0] = 0x03;
        cmd10[1] = r->lun<<5;
        cmd10[4] = sizeof(r->sense)-1;
        drive->data = r->sense;
        drive->dlen = sizeof(r->sense)-1;
        drive->status = 0;
        drive->error = 0;
        if(drive->pkt)
            reqstatus = atapktio(drive, cmd10, 6);
        else
            reqstatus = atagenio(drive, cmd10, 6);
        if(reqstatus == SDok){
            r->flags |= SDvalidsense;
            atasetsense(drive, SDok, 0, 0, 0);
        }
    }
    qunlock(drive);
    r->status = status;
    if(status != SDok)
        return status;

    /*
     * Fix up any results.
     * Many ATAPI CD-ROMs ignore the LUN field completely and
     * return valid INQUIRY data. Patch the response to indicate
     * 'logical unit not supported' if the LUN is non-zero.
     */
    switch(cmdp[0]){
    case 0x12:          /* inquiry */
        if((p = r->data) == nil)
            break;
        if((cmdp[1]>>5) && (!drive->pkt || (p[0] & 0x1F) == 0x05))
            p[0] = 0x7F;
        /*FALLTHROUGH*/
    default:
        break;
    }

    return SDok;
}

/* interrupt ack hack for intel ich controllers */
static void
ichirqack(Ctlr *ctlr)
{
    int bmiba;

    bmiba = ctlr->bmiba;
    if(bmiba)
        outb(bmiba+Bmisx, inb(bmiba+Bmisx));
}

static void
atainterrupt(Ureg*, void* arg)
{
    Ctlr *ctlr;
    Drive *drive;
    int cmdport, len, status;

    ctlr = arg;

    ilock(ctlr);
    if(inb(ctlr->ctlport+As) & Bsy){
        ctlr->intbusy++;
        iunlock(ctlr);
        if(DEBUG & DbgBsy)
            print("IBsy+");
        return;
    }
    cmdport = ctlr->cmdport;
    status = inb(cmdport+Status);
    if((drive = ctlr->curdrive) == nil){
        ctlr->intnil++;
        if(ctlr->irqack != nil)
            ctlr->irqack(ctlr);
        iunlock(ctlr);
        if((DEBUG & DbgINL) && ctlr->command != Cedd)
            print("Inil%2.2uX+", ctlr->command);
        return;
    }

    ctlr->intok++;

    if(status & Err)
        drive->error = inb(cmdport+Error);
    else switch(drive->command){
    default:
        drive->error = Abrt;
        break;

    case Crs:
    case Crsm:
        drive->intrd++;
        if(!(status & Drq)){
            drive->error = Abrt;
            break;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        inss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        if(drive->data >= drive->limit)
            ctlr->done = 1;
        break;

    case Cws:
    case Cwsm:
        drive->intwr++;
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        drive->data += len;
        if(drive->data >= drive->limit){
            ctlr->done = 1;
            break;
        }
        if(!(status & Drq)){
            drive->error = Abrt;
            break;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        outss(cmdport+Data, drive->data, len/2);
        break;

    case Cpkt:
        atapktinterrupt(drive);
        break;

    case Crd:
        drive->intrd++;
        /* fall through */
    case Cwd:
        if (drive->command == Cwd)
            drive->intwr++;
        atadmainterrupt(drive, drive->count*drive->secsize);
        break;

    case Cstandby:
        ctlr->done = 1;
        break;
    }
    if(ctlr->irqack != nil)
        ctlr->irqack(ctlr);
    iunlock(ctlr);

    if(drive->error){
        status |= Err;
        ctlr->done = 1;
    }

    if(ctlr->done){
        ctlr->curdrive = nil;
        drive->status = status;
        wakeup(ctlr);
    }
}

static SDev*
atapnp(void)
{
    Ctlr *ctlr;
    Pcidev *p;
    SDev *legacy[2], *sdev, *head, *tail;
    int channel, ispc87415, maxio, pi, r, span;
    void (*irqack)(Ctlr*);

    irqack = nil;
    legacy[0] = legacy[1] = head = tail = nil;
    if(sdev = ataprobe(0x1F0, 0x3F4, IrqATA0)){
        head = tail = sdev;
        legacy[0] = sdev;
    }
    if(sdev = ataprobe(0x170, 0x374, IrqATA1)){
        if(head != nil)
            tail->next = sdev;
        else
            head = sdev;
        tail = sdev;
        legacy[1] = sdev;
    }

    p = nil;
    while(p = pcimatch(p, 0, 0)){
        /*
         * Look for devices with the correct class and sub-class
         * code and known device and vendor ID; add native-mode
         * channels to the list to be probed, save info for the
         * compatibility mode channels.
         * Note that the legacy devices should not be considered
         * PCI devices by the interrupt controller.
         * For both native and legacy, save info for busmastering
         * if capable.
         * Promise Ultra ATA/66 (PDC20262) appears to
         * 1) give a sub-class of 'other mass storage controller'
         *    instead of 'IDE controller', regardless of whether it's
         *    the only controller or not;
         * 2) put 0 in the programming interface byte (probably
         *    as a consequence of 1) above).
         * Sub-class code 0x04 is 'RAID controller', e.g. VIA VT8237.
         */
        if(p->ccrb != 0x01)
            continue;
        if(p->ccru != 0x01 && p->ccru != 0x04 && p->ccru != 0x80)
            continue;
        pi = p->ccrp;
        ispc87415 = 0;
        maxio = 0;
        span = BMspan;

        switch((p->did<<16)|p->vid){
        default:
            continue;

        case (0x0002<<16)|0x100B:   /* NS PC87415 */
            /*
             * Disable interrupts on both channels until
             * after they are probed for drives.
             * This must be called before interrupts are
             * enabled because the IRQ may be shared.
             */
            ispc87415 = 1;
            pcicfgw32(p, 0x40, 0x00000300);
            break;
        case (0x1000<<16)|0x1042:   /* PC-Tech RZ1000 */
            /*
             * Turn off prefetch. Overkill, but cheap.
             */
            r = pcicfgr32(p, 0x40);
            r &= ~0x2000;
            pcicfgw32(p, 0x40, r);
            break;
        case (0x4379<<16)|0x1002:   /* ATI SB400 SATA*/
        case (0x437a<<16)|0x1002:   /* ATI SB400 SATA */
        case (0x439c<<16)|0x1002:   /* ATI 439c SATA*/
        case (0x3373<<16)|0x105A:   /* Promise 20378 RAID */
        case (0x4D30<<16)|0x105A:   /* Promise PDC202xx */
        case (0x4D38<<16)|0x105A:   /* Promise PDC20262 */
        case (0x4D68<<16)|0x105A:   /* Promise PDC20268 */
        case (0x4D69<<16)|0x105A:   /* Promise Ultra/133 TX2 */
        case (0x3112<<16)|0x1095:   /* SiI 3112 SATA/RAID */
        case (0x3149<<16)|0x1106:   /* VIA VT8237 SATA/RAID */
            maxio = 15;
            span = 8*1024;
            /*FALLTHROUGH*/
        case (0x0680<<16)|0x1095:   /* SiI 0680/680A PATA133 ATAPI/RAID */
        case (0x3114<<16)|0x1095:   /* SiI 3114 SATA/RAID */
            pi = 0x85;
            break;
        case (0x0004<<16)|0x1103:   /* HighPoint HPT366 */
            pi = 0x85;
            /*
             * Turn off fast interrupt prediction.
             */
            if((r = pcicfgr8(p, 0x51)) & 0x80)
                pcicfgw8(p, 0x51, r & ~0x80);
            if((r = pcicfgr8(p, 0x55)) & 0x80)
                pcicfgw8(p, 0x55, r & ~0x80);
            break;
        case (0x0640<<16)|0x1095:   /* CMD 640B */
            /*
             * Bugfix code here...
             */
            break;
        case (0x7441<<16)|0x1022:   /* AMD 768 */
            /*
             * Set:
             *  0x41    prefetch, postwrite;
             *  0x43    FIFO configuration 1/2 and 1/2;
             *  0x44    status register read retry;
             *  0x46    DMA read and end of sector flush.
             */
            r = pcicfgr8(p, 0x41);
            pcicfgw8(p, 0x41, r|0xF0);
            r = pcicfgr8(p, 0x43);
            pcicfgw8(p, 0x43, (r & 0x90)|0x2A);
            r = pcicfgr8(p, 0x44);
            pcicfgw8(p, 0x44, r|0x08);
            r = pcicfgr8(p, 0x46);
            pcicfgw8(p, 0x46, (r & 0x0C)|0xF0);
            /*FALLTHROUGH*/
        case (0x7401<<16)|0x1022:   /* AMD 755 Cobra */
        case (0x7409<<16)|0x1022:   /* AMD 756 Viper */
        case (0x7410<<16)|0x1022:   /* AMD 766 Viper Plus */
        case (0x7469<<16)|0x1022:   /* AMD 3111 */
            /*
             * This can probably be lumped in with the 768 above.
             */
            /*FALLTHROUGH*/
        case (0x209A<<16)|0x1022:   /* AMD CS5536 */
        case (0x01BC<<16)|0x10DE:   /* nVidia nForce1 */
        case (0x0065<<16)|0x10DE:   /* nVidia nForce2 */
        case (0x0085<<16)|0x10DE:   /* nVidia nForce2 MCP */
        case (0x00E3<<16)|0x10DE:   /* nVidia nForce2 250 SATA */
        case (0x00D5<<16)|0x10DE:   /* nVidia nForce3 */
        case (0x00E5<<16)|0x10DE:   /* nVidia nForce3 Pro */
        case (0x00EE<<16)|0x10DE:   /* nVidia nForce3 250 SATA */
        case (0x0035<<16)|0x10DE:   /* nVidia nForce3 MCP */
        case (0x0053<<16)|0x10DE:   /* nVidia nForce4 */
        case (0x0054<<16)|0x10DE:   /* nVidia nForce4 SATA */
        case (0x0055<<16)|0x10DE:   /* nVidia nForce4 SATA */
        case (0x0266<<16)|0x10DE:   /* nVidia nForce4 430 SATA */
        case (0x0267<<16)|0x10DE:   /* nVidia nForce 55 MCP SATA */
        case (0x03EC<<16)|0x10DE:   /* nVidia nForce 61 MCP SATA */
        case (0x0448<<16)|0x10DE:   /* nVidia nForce 65 MCP SATA */
        case (0x0560<<16)|0x10DE:   /* nVidia nForce 69 MCP SATA */
            /*
             * Ditto, although it may have a different base
             * address for the registers (0x50?).
             */
            /*FALLTHROUGH*/
        case (0x4376<<16)|0x1002:   /* ATI SB400 PATA */
        case (0x438c<<16)|0x1002:   /* ATI SB600 PATA */
            break;
        case (0x0211<<16)|0x1166:   /* ServerWorks IB6566 */
            {
                Pcidev *sb;

                sb = pcimatch(nil, 0x1166, 0x0200);
                if(sb == nil)
                    break;
                r = pcicfgr32(sb, 0x64);
                r &= ~0x2000;
                pcicfgw32(sb, 0x64, r);
            }
            span = 32*1024;
            break;
        case (0x0502<<17)|0x100B:   /* NS SC1100/SCx200 */
        case (0x5229<<16)|0x10B9:   /* ALi M1543 */
        case (0x5288<<16)|0x10B9:   /* ALi M5288 SATA */
        case (0x5513<<16)|0x1039:   /* SiS 962 */
        case (0x0646<<16)|0x1095:   /* CMD 646 */
        case (0x0571<<16)|0x1106:   /* VIA 82C686 */
        case (0x2363<<16)|0x197b:   /* JMicron SATA */
            break;  /* TODO: verify that this should be here; wasn't in original patch */
        case (0x1230<<16)|0x8086:   /* 82371FB (PIIX) */
        case (0x7010<<16)|0x8086:   /* 82371SB (PIIX3) */
        case (0x7111<<16)|0x8086:   /* 82371[AE]B (PIIX4[E]) */
        case (0x2411<<16)|0x8086:   /* 82801AA (ICH) */
        case (0x2421<<16)|0x8086:   /* 82801AB (ICH0) */
        case (0x244A<<16)|0x8086:   /* 82801BA (ICH2, Mobile) */
        case (0x244B<<16)|0x8086:   /* 82801BA (ICH2, High-End) */
        case (0x248A<<16)|0x8086:   /* 82801CA (ICH3, Mobile) */
        case (0x248B<<16)|0x8086:   /* 82801CA (ICH3, High-End) */
        case (0x24CA<<16)|0x8086:   /* 82801DBM (ICH4, Mobile) */
        case (0x24CB<<16)|0x8086:   /* 82801DB (ICH4, High-End) */
        case (0x24D1<<16)|0x8086:   /* 82801EB/ER (ICH5 High-End) */
        case (0x24DB<<16)|0x8086:   /* 82801EB (ICH5) */
        case (0x25A3<<16)|0x8086:   /* 6300ESB (E7210) */
        case (0x2653<<16)|0x8086:   /* 82801FBM (ICH6M) */
        case (0x266F<<16)|0x8086:   /* 82801FB (ICH6) */
        case (0x27DF<<16)|0x8086:   /* 82801G SATA (ICH7) */
        case (0x27C0<<16)|0x8086:   /* 82801GB SATA AHCI (ICH7) */
//      case (0x27C4<<16)|0x8086:   /* 82801GBM SATA (ICH7) */
        case (0x27C5<<16)|0x8086:   /* 82801GBM SATA AHCI (ICH7) */
        case (0x2920<<16)|0x8086:   /* 82801(IB)/IR/IH/IO SATA IDE (ICH9) */
        case (0x3a20<<16)|0x8086:   /* 82801JI (ICH10) */
        case (0x3a26<<16)|0x8086:   /* 82801JI (ICH10) */
            irqack = ichirqack;
            break;
        }

        for(channel = 0; channel < 2; channel++){
            if(pi & (1<<(2*channel))){
                sdev = ataprobe(p->mem[0+2*channel].bar & ~0x01,
                        p->mem[1+2*channel].bar & ~0x01,
                        p->intl);
                if(sdev == nil)
                    continue;

                ctlr = sdev->ctlr;
                if(ispc87415) {
                    ctlr->ienable = pc87415ienable;
                    print("pc87415disable: not yet implemented\n");
                }

                if(head != nil)
                    tail->next = sdev;
                else
                    head = sdev;
                tail = sdev;
                ctlr->tbdf = p->tbdf;
            }
            else if((sdev = legacy[channel]) == nil)
                continue;
            else
                ctlr = sdev->ctlr;

            ctlr->pcidev = p;
            ctlr->maxio = maxio;
            ctlr->span = span;
            ctlr->irqack = irqack;
            if(!(pi & 0x80))
                continue;
            ctlr->bmiba = (p->mem[4].bar & ~0x01) + channel*8;
        }
    }

if(0){
    int port;
    ISAConf isa;

    /*
     * Hack for PCMCIA drives.
     * This will be tidied once we figure out how the whole
     * removeable device thing is going to work.
     */
    memset(&isa, 0, sizeof(isa));
    isa.port = 0x180;       /* change this for your machine */
    isa.irq = 11;           /* change this for your machine */

    port = isa.port+0x0C;
    channel = pcmspecial("MK2001MPL", &isa);
    if(channel == -1)
        channel = pcmspecial("SunDisk", &isa);
    if(channel == -1){
        isa.irq = 10;
        channel = pcmspecial("CF", &isa);
    }
    if(channel == -1){
        isa.irq = 10;
        channel = pcmspecial("OLYMPUS", &isa);
    }
    if(channel == -1){
        port = isa.port+0x204;
        channel = pcmspecial("ATA/ATAPI", &isa);
    }
    if(channel >= 0 && (sdev = ataprobe(isa.port, port, isa.irq)) != nil){
        if(head != nil)
            tail->next = sdev;
        else
            head = sdev;
    }
}
    return head;
}

static SDev*
atalegacy(int port, int irq)
{
    return ataprobe(port, port+0x204, irq);
}

static int
ataenable(SDev* sdev)
{
    Ctlr *ctlr;
    char name[32];

    ctlr = sdev->ctlr;

    if(ctlr->bmiba){
        if(ctlr->pcidev != nil)
            pcisetbme(ctlr->pcidev);
          //#define ALIGN   (4 * 1024)
        ctlr->prdt = mallocalign(Nprd*sizeof(Prd), 4, 0, 4*1024);
        if(ctlr->prdt == nil)
            error(Enomem);
    }
    snprint(name, sizeof(name), "%s (%s)", sdev->name, sdev->ifc->name);
    intrenable(ctlr->irq, atainterrupt, ctlr, ctlr->tbdf, name);
    outb(ctlr->ctlport+Dc, 0);
    if(ctlr->ienable)
        ctlr->ienable(ctlr);

    return 1;
}

static int
atadisable(SDev *sdev)
{
    Ctlr *ctlr;
    char name[32];

    ctlr = sdev->ctlr;
    outb(ctlr->ctlport+Dc, Nien);       /* disable interrupts */
    if (ctlr->idisable)
        ctlr->idisable(ctlr);
    snprint(name, sizeof(name), "%s (%s)", sdev->name, sdev->ifc->name);
    intrdisable(ctlr->irq, atainterrupt, ctlr, ctlr->tbdf, name);
    if (ctlr->bmiba) {
        if (ctlr->pcidev)
            pciclrbme(ctlr->pcidev);
        free(ctlr->prdt);
    }
    return 0;
}

static int
atarctl(SDunit* unit, char* p, int l)
{
    int n;
    Ctlr *ctlr;
    Drive *drive;

    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil)
        return 0;
    drive = ctlr->drive[unit->subno];

    qlock(drive);
    n = snprint(p, l, "config %4.4uX capabilities %4.4uX",
        drive->info[Iconfig], drive->info[Icapabilities]);
    if(drive->dma)
        n += snprint(p+n, l-n, " dma %8.8uX dmactl %8.8uX",
            drive->dma, drive->dmactl);
    if(drive->rwm)
        n += snprint(p+n, l-n, " rwm %ud rwmctl %ud",
            drive->rwm, drive->rwmctl);
    if(drive->flags&Lba48)
        n += snprint(p+n, l-n, " lba48always %s",
            (drive->flags&Lba48always) ? "on" : "off");
    n += snprint(p+n, l-n, "\n");
    n += snprint(p+n, l-n, "interrupts read %lud write %lud cmds %lud\n",
        drive->intrd, drive->intwr, drive->intcmd);
    if(drive->sectors){
        n += snprint(p+n, l-n, "geometry %lld %d",
            drive->sectors, drive->secsize);
        if(drive->pkt == 0)
            n += snprint(p+n, l-n, " %d %d %d",
                drive->c, drive->h, drive->s);
        n += snprint(p+n, l-n, "\n");
    }
    qunlock(drive);

    return n;
}

static int
atawctl(SDunit* unit, Cmdbuf* cb)
{
    int period;
    Ctlr *ctlr;
    Drive *drive;

    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil)
        return 0;
    drive = ctlr->drive[unit->subno];

    qlock(drive);
    if(waserror()){
        qunlock(drive);
        nexterror();
    }

    /*
     * Dma and rwm control is passive at the moment,
     * i.e. it is assumed that the hardware is set up
     * correctly already either by the BIOS or when
     * the drive was initially identified.
     */
    if(strcmp(cb->f[0], "dma") == 0){
        if(cb->nf != 2 || drive->dma == 0)
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->dmactl = drive->dma;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->dmactl = 0;
        else
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "rwm") == 0){
        if(cb->nf != 2 || drive->rwm == 0)
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->rwmctl = drive->rwm;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->rwmctl = 0;
        else
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "standby") == 0){
        switch(cb->nf){
        default:
            error(Ebadctl);
        case 2:
            period = strtol(cb->f[1], 0, 0);
            if(period && (period < 30 || period > 240*5))
                error(Ebadctl);
            period /= 5;
            break;
        }
        if(atastandby(drive, period) != SDok)
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "lba48always") == 0){
        if(cb->nf != 2 || !(drive->flags&Lba48))
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->flags |= Lba48always;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->flags &= ~Lba48always;
        else
            error(Ebadctl);
    }
    else
        error(Ebadctl);
    qunlock(drive);
    poperror();

    return 0;
}

SDifc sdataifc = {
    "ata",              /* name */

    atapnp,             /* pnp */
    atalegacy,          /* legacy */
    ataenable,          /* enable */
    atadisable,         /* disable */

    scsiverify,         /* verify */
    scsionline,         /* online */
    atario,             /* rio */
    atarctl,            /* rctl */
    atawctl,            /* wctl */

    scsibio,            /* bio */
    ataprobew,          /* probe */
    ataclear,           /* clear */
    atastat,            /* rtopctl */
    nil,                /* wtopctl */
};
@
\fi


\subsection*{[[devices/storage/devsd.c]]}

\ifallcode
<<devsd.c forward decl>>=
extern void sdaddpart(SDunit*, char*, uvlong, uvlong);
extern void sdadddevs(SDev*);
@
\fi

%//extern int sdsetsense(SDreq*, int, int, int, int);
%//extern int sdmodesense(SDreq*, uchar*, void*, int);

% very big for now so skip

<<global sddevtab>>=
Dev sddevtab = {
    .dc       =    'S',
    .name     =    "sd",
               
    .reset    =    sdreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    sdattach,
    .walk     =    sdwalk,
    .stat     =    sdstat,
    .open     =    sdopen,
    .create   =    devcreate,
    .close    =    sdclose,
    .read     =    sdread,
    .bread    =    devbread,
    .write    =    sdwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    sdwstat,

    .power    = devpower,
    .config   = sdconfig,   /* probe; only called for pcmcia-like devices */
};
@

\ifallcode
<<devsd.c>>=
/*
 * Storage Device.
 */
<<kernel basic includes>>

#include "io.h"
#include "../port/sd.h"

#include <ureg.h>

extern Dev sddevtab;
extern SDifc* sdifc[];

static char devletters[] = "0123456789"
    "abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

static SDev *devs[sizeof devletters-1];
static QLock devslock;

<<devsd.c forward decl>>

enum {
    Rawcmd,
    Rawdata,
    Rawstatus,
};

enum {
    Qtopdir     = 1,        /* top level directory */
    Qtopbase,
    Qtopctl      = Qtopbase,

    Qunitdir,           /* directory per unit */
    Qunitbase,
    Qctl        = Qunitbase,
    Qraw,
    Qpart,

    TypeLOG     = 4,
    NType       = (1<<TypeLOG),
    TypeMASK    = (NType-1),
    TypeSHIFT   = 0,

    PartLOG     = 8,
    NPart       = (1<<PartLOG),
    PartMASK    = (NPart-1),
    PartSHIFT   = TypeLOG,

    UnitLOG     = 8,
    NUnit       = (1<<UnitLOG),
    UnitMASK    = (NUnit-1),
    UnitSHIFT   = (PartLOG+TypeLOG),

    DevLOG      = 8,
    NDev        = (1 << DevLOG),
    DevMASK     = (NDev-1),
    DevSHIFT     = (UnitLOG+PartLOG+TypeLOG),

    Ncmd = 20,
};

#define TYPE(q)     ((((ulong)(q).path)>>TypeSHIFT) & TypeMASK)
#define PART(q)     ((((ulong)(q).path)>>PartSHIFT) & PartMASK)
#define UNIT(q)     ((((ulong)(q).path)>>UnitSHIFT) & UnitMASK)
#define DEV(q)      ((((ulong)(q).path)>>DevSHIFT) & DevMASK)
#define QID(d,u, p, t)  (((d)<<DevSHIFT)|((u)<<UnitSHIFT)|\
                     ((p)<<PartSHIFT)|((t)<<TypeSHIFT))


void
sdaddpart(SDunit* unit, char* name, uvlong start, uvlong end)
{
    SDpart *pp;
    int i, partno;

    /*
     * Check name not already used
     * and look for a free slot.
     */
    if(unit->part != nil){
        partno = -1;
        for(i = 0; i < unit->npart; i++){
            pp = &unit->part[i];
            if(!pp->valid){
                if(partno == -1)
                    partno = i;
                break;
            }
            if(strcmp(name, pp->name) == 0){
                if(pp->start == start && pp->end == end)
                    return;
                error(Ebadctl);
            }
        }
    }
    else{
        if((unit->part = malloc(sizeof(SDpart)*SDnpart)) == nil)
            error(Enomem);
        unit->npart = SDnpart;
        partno = 0;
    }

    /*
     * If no free slot found then increase the
     * array size (can't get here with unit->part == nil).
     */
    if(partno == -1){
        if(unit->npart >= NPart)
            error(Enomem);
        if((pp = malloc(sizeof(SDpart)*(unit->npart+SDnpart))) == nil)
            error(Enomem);
        memmove(pp, unit->part, sizeof(SDpart)*unit->npart);
        free(unit->part);
        unit->part = pp;
        partno = unit->npart;
        unit->npart += SDnpart;
    }

    /*
     * Check size and extent are valid.
     */
    if(start > end || end > unit->sectors)
        error(Eio);
    pp = &unit->part[partno];
    pp->start = start;
    pp->end = end;
    kstrdup(&pp->name, name);
    kstrdup(&pp->user, eve);
    pp->perm = 0640;
    pp->valid = 1;
}

static void
sddelpart(SDunit* unit, char* name)
{
    int i;
    SDpart *pp;

    /*
     * Look for the partition to delete.
     * Can't delete if someone still has it open.
     */
    pp = unit->part;
    for(i = 0; i < unit->npart; i++){
        if(strcmp(name, pp->name) == 0)
            break;
        pp++;
    }
    if(i >= unit->npart)
        error(Ebadctl);
    if(strcmp(up->user, pp->user) && !iseve())
        error(Eperm);
    pp->valid = 0;
    pp->vers++;
}

static void
sdincvers(SDunit *unit)
{
    int i;

    unit->vers++;
    if(unit->part){
        for(i = 0; i < unit->npart; i++){
            unit->part[i].valid = 0;
            unit->part[i].vers++;
        }
    }
}

static int
sdinitpart(SDunit* unit)
{
    int nf;
    uvlong start, end;
    char *f[4], *p, *q, buf[10];

    if(unit->sectors > 0){
        unit->sectors = unit->secsize = 0;
        sdincvers(unit);
    }

    /* device must be connected or not; other values are trouble */
    if(unit->inquiry[0] & 0xC0) /* see SDinq0periphqual */
        return 0;
    switch(unit->inquiry[0] & SDinq0periphtype){
    case SDperdisk:
    case SDperworm:
    case SDpercd:
    case SDpermo:
        break;
    default:
        return 0;
    }

    if(unit->dev->ifc->online)
        unit->dev->ifc->online(unit);
    if(unit->sectors){
        sdincvers(unit);
        sdaddpart(unit, "data", 0, unit->sectors);

        /*
         * Use partitions passed from boot program,
         * e.g.
         *  sdC0part=dos 63 123123/plan9 123123 456456
         * This happens before /boot sets hostname so the
         * partitions will have the null-string for user.
         * The gen functions patch it up.
         */
        snprint(buf, sizeof buf, "%spart", unit->name);
        for(p = getconf(buf); p != nil; p = q){
            if(q = strchr(p, '/'))
                *q++ = '\0';
            nf = tokenize(p, f, nelem(f));
            if(nf < 3)
                continue;

            start = strtoull(f[1], 0, 0);
            end = strtoull(f[2], 0, 0);
            if(!waserror()){
                sdaddpart(unit, f[0], start, end);
                poperror();
            }
        }
    }

    return 1;
}

static int
sdindex(int idno)
{
    char *p;

    p = strchr(devletters, idno);
    if(p == nil)
        return -1;
    return p-devletters;
}

static SDev*
sdgetdev(int idno)
{
    SDev *sdev;
    int i;

    if((i = sdindex(idno)) < 0)
        return nil;

    qlock(&devslock);
    if(sdev = devs[i])
        incref(&sdev->r);
    qunlock(&devslock);
    return sdev;
}

static SDunit*
sdgetunit(SDev* sdev, int subno)
{
    SDunit *unit;
    char buf[32];

    /*
     * Associate a unit with a given device and sub-unit
     * number on that device.
     * The device will be probed if it has not already been
     * successfully accessed.
     */
    qlock(&sdev->unitlock);
    if(subno > sdev->nunit){
        qunlock(&sdev->unitlock);
        return nil;
    }

    unit = sdev->unit[subno];
    if(unit == nil){
        /*
         * Probe the unit only once. This decision
         * may be a little severe and reviewed later.
         */
        if(sdev->unitflg[subno]){
            qunlock(&sdev->unitlock);
            return nil;
        }
        if((unit = malloc(sizeof(SDunit))) == nil){
            qunlock(&sdev->unitlock);
            return nil;
        }
        sdev->unitflg[subno] = 1;

        snprint(buf, sizeof(buf), "%s%d", sdev->name, subno);
        kstrdup(&unit->name, buf);
        kstrdup(&unit->user, eve);
        unit->perm = 0555;
        unit->subno = subno;
        unit->dev = sdev;

        if(sdev->enabled == 0 && sdev->ifc->enable)
            sdev->ifc->enable(sdev);
        sdev->enabled = 1;

        /*
         * No need to lock anything here as this is only
         * called before the unit is made available in the
         * sdunit[] array.
         */
        if(unit->dev->ifc->verify(unit) == 0){
            qunlock(&sdev->unitlock);
            free(unit);
            return nil;
        }
        sdev->unit[subno] = unit;
    }
    qunlock(&sdev->unitlock);
    return unit;
}

static void
sdreset(void)
{
    int i;
    SDev *sdev;

    /*
     * Probe all known controller types and register any devices found.
     */
    for(i = 0; sdifc[i] != nil; i++){
        if(sdifc[i]->pnp == nil || (sdev = sdifc[i]->pnp()) == nil)
            continue;
        sdadddevs(sdev);
    }
}

void
sdadddevs(SDev *sdev)
{
    int i, j, id;
    SDev *next;

    for(; sdev; sdev=next){
        next = sdev->next;

        sdev->unit = (SDunit**)malloc(sdev->nunit * sizeof(SDunit*));
        sdev->unitflg = (int*)malloc(sdev->nunit * sizeof(int));
        if(sdev->unit == nil || sdev->unitflg == nil){
            print("sdadddevs: out of memory\n");
        giveup:
            free(sdev->unit);
            free(sdev->unitflg);
            if(sdev->ifc->clear)
                sdev->ifc->clear(sdev);
            free(sdev);
            continue;
        }
        id = sdindex(sdev->idno);
        if(id == -1){
            print("sdadddevs: bad id number %d (%C)\n", id, id);
            goto giveup;
        }
        qlock(&devslock);
        for(i=0; i<nelem(devs); i++){
            if(devs[j = (id+i)%nelem(devs)] == nil){
                sdev->idno = devletters[j];
                devs[j] = sdev;
                snprint(sdev->name, sizeof sdev->name, "sd%c", devletters[j]);
                break;
            }
        }
        qunlock(&devslock);
        if(i == nelem(devs)){
            print("sdadddevs: out of device letters\n");
            goto giveup;
        }
    }
}

static int
sd2gen(Chan* c, int i, Dir* dp)
{
    Qid q;
    uvlong l;
    SDpart *pp;
    SDperm *perm;
    SDunit *unit;
    SDev *sdev;
    int rv;

    sdev = sdgetdev(DEV(c->qid));
    assert(sdev);
    unit = sdev->unit[UNIT(c->qid)];

    rv = -1;
    switch(i){
    case Qctl:
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qctl),
            unit->vers, QTFILE);
        perm = &unit->ctlperm;
        if(emptystr(perm->user)){
            kstrdup(&perm->user, eve);
            perm->perm = 0644;  /* nothing secret in ctl */
        }
        devdir(c, q, "ctl", 0, perm->user, perm->perm, dp);
        rv = 1;
        break;

    case Qraw:
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qraw),
            unit->vers, QTFILE);
        perm = &unit->rawperm;
        if(emptystr(perm->user)){
            kstrdup(&perm->user, eve);
            perm->perm = DMEXCL|0600;
        }
        devdir(c, q, "raw", 0, perm->user, perm->perm, dp);
        rv = 1;
        break;

    case Qpart:
        pp = &unit->part[PART(c->qid)];
        l = (pp->end - pp->start) * unit->secsize;
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qpart),
            unit->vers+pp->vers, QTFILE);
        if(emptystr(pp->user))
            kstrdup(&pp->user, eve);
        devdir(c, q, pp->name, l, pp->user, pp->perm, dp);
        rv = 1;
        break;
    }

    decref(&sdev->r);
    return rv;
}

static int
sd1gen(Chan* c, int i, Dir* dp)
{
    Qid q;

    switch(i){
    case Qtopctl:
        mkqid(&q, QID(0, 0, 0, Qtopctl), 0, QTFILE);
        devdir(c, q, "sdctl", 0, eve, 0644, dp);    /* no secrets */
        return 1;
    }
    return -1;
}

static int
sdgen(Chan* c, char*, Dirtab*, int, int s, Dir* dp)
{
    Qid q;
    uvlong l;
    int i, r;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;

    switch(TYPE(c->qid)){
    case Qtopdir:
        if(s == DEVDOTDOT){
            mkqid(&q, QID(0, 0, 0, Qtopdir), 0, QTDIR);
            snprint(up->genbuf, sizeof up->genbuf, "#%C",
                sddevtab.dc);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            return 1;
        }

        if(s+Qtopbase < Qunitdir)
            return sd1gen(c, s+Qtopbase, dp);
        s -= (Qunitdir-Qtopbase);

        qlock(&devslock);
        for(i=0; i<nelem(devs); i++){
            if(devs[i]){
                if(s < devs[i]->nunit)
                    break;
                s -= devs[i]->nunit;
            }
        }

        if(i == nelem(devs)){
            /* Run off the end of the list */
            qunlock(&devslock);
            return -1;
        }

        if((sdev = devs[i]) == nil){
            qunlock(&devslock);
            return 0;
        }

        incref(&sdev->r);
        qunlock(&devslock);

        if((unit = sdev->unit[s]) == nil)
            if((unit = sdgetunit(sdev, s)) == nil){
                decref(&sdev->r);
                return 0;
            }

        mkqid(&q, QID(sdev->idno, s, 0, Qunitdir), 0, QTDIR);
        if(emptystr(unit->user))
            kstrdup(&unit->user, eve);
        devdir(c, q, unit->name, 0, unit->user, unit->perm, dp);
        decref(&sdev->r);
        return 1;

    case Qunitdir:
        if(s == DEVDOTDOT){
            mkqid(&q, QID(0, 0, 0, Qtopdir), 0, QTDIR);
            snprint(up->genbuf, sizeof up->genbuf, "#%C",
                sddevtab.dc);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            return 1;
        }

        if((sdev = sdgetdev(DEV(c->qid))) == nil){
            devdir(c, c->qid, "unavailable", 0, eve, 0, dp);
            return 1;
        }

        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->ctl);

        /*
         * Check for media change.
         * If one has already been detected, sectors will be zero.
         * If there is one waiting to be detected, online
         * will return > 1.
         * Online is a bit of a large hammer but does the job.
         */
        if(unit->sectors == 0
        || (unit->dev->ifc->online && unit->dev->ifc->online(unit) > 1))
            sdinitpart(unit);

        i = s+Qunitbase;
        if(i < Qpart){
            r = sd2gen(c, i, dp);
            qunlock(&unit->ctl);
            decref(&sdev->r);
            return r;
        }
        i -= Qpart;
        if(unit->part == nil || i >= unit->npart){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            break;
        }
        pp = &unit->part[i];
        if(!pp->valid){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            return 0;
        }
        l = (pp->end - pp->start) * unit->secsize;
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), i, Qpart),
            unit->vers+pp->vers, QTFILE);
        if(emptystr(pp->user))
            kstrdup(&pp->user, eve);
        devdir(c, q, pp->name, l, pp->user, pp->perm, dp);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        return 1;
    case Qraw:
    case Qctl:
    case Qpart:
        if((sdev = sdgetdev(DEV(c->qid))) == nil){
            devdir(c, q, "unavailable", 0, eve, 0, dp);
            return 1;
        }
        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->ctl);
        r = sd2gen(c, TYPE(c->qid), dp);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        return r;
    case Qtopctl:
        return sd1gen(c, TYPE(c->qid), dp);
    default:
        break;
    }

    return -1;
}

static Chan*
sdattach(char* spec)
{
    Chan *c;
    char *p;
    SDev *sdev;
    int idno, subno;

    if(*spec == '\0'){
        c = devattach(sddevtab.dc, spec);
        mkqid(&c->qid, QID(0, 0, 0, Qtopdir), 0, QTDIR);
        return c;
    }

    if(spec[0] != 's' || spec[1] != 'd')
        error(Ebadspec);
    idno = spec[2];
    subno = strtol(&spec[3], &p, 0);
    if(p == &spec[3])
        error(Ebadspec);

    if((sdev=sdgetdev(idno)) == nil)
        error(Enonexist);
    if(sdgetunit(sdev, subno) == nil){
        decref(&sdev->r);
        error(Enonexist);
    }

    c = devattach(sddevtab.dc, spec);
    mkqid(&c->qid, QID(sdev->idno, subno, 0, Qunitdir), 0, QTDIR);
    c->dev = (sdev->idno << UnitLOG) + subno;
    decref(&sdev->r);
    return c;
}

static Walkqid*
sdwalk(Chan* c, Chan* nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, nil, 0, sdgen);
}

static int
sdstat(Chan* c, uchar* db, int n)
{
    return devstat(c, db, n, nil, 0, sdgen);
}

static Chan*
sdopen(Chan* c, int omode)
{
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    uchar tp;

    c = devopen(c, omode, 0, 0, sdgen);
    if((tp = TYPE(c->qid)) != Qctl && tp != Qraw && tp != Qpart)
        return c;

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil)
        error(Enonexist);

    unit = sdev->unit[UNIT(c->qid)];

    switch(TYPE(c->qid)){
    case Qctl:
        c->qid.vers = unit->vers;
        break;
    case Qraw:
        c->qid.vers = unit->vers;
        if(tas(&unit->rawinuse) != 0){
            c->flag &= ~COPEN;
            decref(&sdev->r);
            error(Einuse);
        }
        unit->state = Rawcmd;
        break;
    case Qpart:
        qlock(&unit->ctl);
        if(waserror()){
            qunlock(&unit->ctl);
            c->flag &= ~COPEN;
            decref(&sdev->r);
            nexterror();
        }
        pp = &unit->part[PART(c->qid)];
        c->qid.vers = unit->vers+pp->vers;
        qunlock(&unit->ctl);
        poperror();
        break;
    }
    decref(&sdev->r);
    return c;
}

static void
sdclose(Chan* c)
{
    SDunit *unit;
    SDev *sdev;

    if(c->qid.type & QTDIR)
        return;
    if(!(c->flag & COPEN))
        return;

    switch(TYPE(c->qid)){
    default:
        break;
    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev){
            unit = sdev->unit[UNIT(c->qid)];
            unit->rawinuse = 0;
            decref(&sdev->r);
        }
        break;
    }
}

static long
sdbio(Chan* c, int write, char* a, long len, uvlong off)
{
    int nchange;
    long l;
    uchar *b;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    ulong max, nb, offset;
    uvlong bno;

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil){
        decref(&sdev->r);
        error(Enonexist);
    }
    unit = sdev->unit[UNIT(c->qid)];
    if(unit == nil)
        error(Enonexist);

    nchange = 0;
    qlock(&unit->ctl);
    while(waserror()){
        /* notification of media change; go around again */
        if(strcmp(up->errstr, Eio) == 0 && unit->sectors == 0 && nchange++ == 0){
            sdinitpart(unit);
            continue;
        }

        /* other errors; give up */
        qunlock(&unit->ctl);
        decref(&sdev->r);
        nexterror();
    }
    pp = &unit->part[PART(c->qid)];
    if(unit->vers+pp->vers != c->qid.vers)
        error(Echange);

    /*
     * Check the request is within bounds.
     * Removeable drives are locked throughout the I/O
     * in case the media changes unexpectedly.
     * Non-removeable drives are not locked during the I/O
     * to allow the hardware to optimise if it can; this is
     * a little fast and loose.
     * It's assumed that non-removeable media parameters
     * (sectors, secsize) can't change once the drive has
     * been brought online.
     */
    bno = (off/unit->secsize) + pp->start;
    nb = ((off+len+unit->secsize-1)/unit->secsize) + pp->start - bno;
    max = SDmaxio/unit->secsize;
    if(nb > max)
        nb = max;
    if(bno+nb > pp->end)
        nb = pp->end - bno;
    if(bno >= pp->end || nb == 0){
        if(write)
            error(Eio);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        poperror();
        return 0;
    }
    if(!(unit->inquiry[1] & SDinq1removable)){
        qunlock(&unit->ctl);
        poperror();
    }

    b = sdmalloc(nb*unit->secsize);
    if(b == nil)
        error(Enomem);
    if(waserror()){
        sdfree(b);
        if(!(unit->inquiry[1] & SDinq1removable))
            decref(&sdev->r);       /* gadverdamme! */
        nexterror();
    }

    offset = off%unit->secsize;
    if(offset+len > nb*unit->secsize)
        len = nb*unit->secsize - offset;
    if(write){
        if(offset || (len%unit->secsize)){
            l = unit->dev->ifc->bio(unit, 0, 0, b, nb, bno);
            if(l < 0)
                error(Eio);
            if(l < (nb*unit->secsize)){
                nb = l/unit->secsize;
                l = nb*unit->secsize - offset;
                if(len > l)
                    len = l;
            }
        }
        memmove(b+offset, a, len);
        l = unit->dev->ifc->bio(unit, 0, 1, b, nb, bno);
        if(l < 0)
            error(Eio);
        if(l < offset)
            len = 0;
        else if(len > l - offset)
            len = l - offset;
    }
    else{
        l = unit->dev->ifc->bio(unit, 0, 0, b, nb, bno);
        if(l < 0)
            error(Eio);
        if(l < offset)
            len = 0;
        else if(len > l - offset)
            len = l - offset;
        memmove(a, b+offset, len);
    }
    sdfree(b);
    poperror();

    if(unit->inquiry[1] & SDinq1removable){
        qunlock(&unit->ctl);
        poperror();
    }

    decref(&sdev->r);
    return len;
}

static long
sdrio(SDreq* r, void* a, long n)
{
    void *data;

    if(n >= SDmaxio || n < 0)
        error(Etoobig);

    data = nil;
    if(n){
        if((data = sdmalloc(n)) == nil)
            error(Enomem);
        if(r->write)
            memmove(data, a, n);
    }
    r->data = data;
    r->dlen = n;

    if(waserror()){
        sdfree(data);
        r->data = nil;
        nexterror();
    }

    if(r->unit->dev->ifc->rio(r) != SDok)
        error(Eio);

    if(!r->write && r->rlen > 0)
        memmove(a, data, r->rlen);
    sdfree(data);
    r->data = nil;
    poperror();

    return r->rlen;
}

static long
sdread(Chan *c, void *a, long n, vlong off)
{
    char *p, *e, *buf;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    ulong offset;
    int i, l, m, status;

    offset = off;
    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qtopctl:
        m = 64*1024;    /* room for register dumps */
        p = buf = malloc(m);
        if(p == nil)
            error(Enomem);
        e = p + m;
        qlock(&devslock);
        for(i = 0; i < nelem(devs); i++){
            sdev = devs[i];
            if(sdev && sdev->ifc->rtopctl)
                p = sdev->ifc->rtopctl(sdev, p, e);
        }
        qunlock(&devslock);
        n = readstr(off, a, n, buf);
        free(buf);
        return n;

    case Qtopdir:
    case Qunitdir:
        return devdirread(c, a, n, 0, 0, sdgen);

    case Qctl:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);

        unit = sdev->unit[UNIT(c->qid)];
        m = 16*1024;    /* room for register dumps */
        p = malloc(m);
        if(p == nil)
            error(Enomem);
        l = snprint(p, m, "inquiry %.48s\n",
            (char*)unit->inquiry+8);
        qlock(&unit->ctl);
        /*
         * If there's a device specific routine it must
         * provide all information pertaining to night geometry
         * and the garscadden trains.
         */
        if(unit->dev->ifc->rctl)
            l += unit->dev->ifc->rctl(unit, p+l, m-l);
        if(unit->sectors == 0)
            sdinitpart(unit);
        if(unit->sectors){
            if(unit->dev->ifc->rctl == nil)
                l += snprint(p+l, m-l,
                    "geometry %llud %lud\n",
                    unit->sectors, unit->secsize);
            pp = unit->part;
            for(i = 0; i < unit->npart; i++){
                if(pp->valid)
                    l += snprint(p+l, m-l,
                        "part %s %llud %llud\n",
                        pp->name, pp->start, pp->end);
                pp++;
            }
        }
        qunlock(&unit->ctl);
        decref(&sdev->r);
        l = readstr(offset, a, n, p);
        free(p);
        return l;

    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);

        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->raw);
        if(waserror()){
            qunlock(&unit->raw);
            decref(&sdev->r);
            nexterror();
        }
        if(unit->state == Rawdata){
            unit->state = Rawstatus;
            i = sdrio(unit->req, a, n);
        }
        else if(unit->state == Rawstatus){
            status = unit->req->status;
            unit->state = Rawcmd;
            free(unit->req);
            unit->req = nil;
            i = readnum(0, a, n, status, NUMSIZE);
        } else
            i = 0;
        qunlock(&unit->raw);
        decref(&sdev->r);
        poperror();
        return i;

    case Qpart:
        return sdbio(c, 0, a, n, off);
    }
}

static void legacytopctl(Cmdbuf*);

static long
sdwrite(Chan* c, void* a, long n, vlong off)
{
    char *f0;
    int i;
    uvlong end, start;
    Cmdbuf *cb;
    SDifc *ifc;
    SDreq *req;
    SDunit *unit;
    SDev *sdev;

    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qtopctl:
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        if(cb->nf == 0)
            error("empty control message");
        f0 = cb->f[0];
        cb->f++;
        cb->nf--;
        if(strcmp(f0, "config") == 0){
            /* wormhole into ugly legacy interface */
            legacytopctl(cb);
            poperror();
            free(cb);
            break;
        }
        /*
         * "ata arg..." invokes sdifc[i]->wtopctl(nil, cb),
         * where sdifc[i]->name=="ata" and cb contains the args.
         */
        ifc = nil;
        sdev = nil;
        for(i=0; sdifc[i]; i++){
            if(strcmp(sdifc[i]->name, f0) == 0){
                ifc = sdifc[i];
                sdev = nil;
                goto subtopctl;
            }
        }
        /*
         * "sd1 arg..." invokes sdifc[i]->wtopctl(sdev, cb),
         * where sdifc[i] and sdev match controller letter "1",
         * and cb contains the args.
         */
        if(f0[0]=='s' && f0[1]=='d' && f0[2] && f0[3] == 0){
            if((sdev = sdgetdev(f0[2])) != nil){
                ifc = sdev->ifc;
                goto subtopctl;
            }
        }
        error("unknown interface");

    subtopctl:
        if(waserror()){
            if(sdev)
                decref(&sdev->r);
            nexterror();
        }
        if(ifc->wtopctl)
            ifc->wtopctl(sdev, cb);
        else
            error(Ebadctl);
        poperror();
        poperror();
        if (sdev)
            decref(&sdev->r);
        free(cb);
        break;

    case Qctl:
        cb = parsecmd(a, n);
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);
        unit = sdev->unit[UNIT(c->qid)];

        qlock(&unit->ctl);
        if(waserror()){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            free(cb);
            nexterror();
        }
        if(unit->vers != c->qid.vers)
            error(Echange);

        if(cb->nf < 1)
            error(Ebadctl);
        if(strcmp(cb->f[0], "part") == 0){
            if(cb->nf != 4)
                error(Ebadctl);
            if(unit->sectors == 0 && !sdinitpart(unit))
                error(Eio);
            start = strtoull(cb->f[2], 0, 0);
            end = strtoull(cb->f[3], 0, 0);
            sdaddpart(unit, cb->f[1], start, end);
        }
        else if(strcmp(cb->f[0], "delpart") == 0){
            if(cb->nf != 2 || unit->part == nil)
                error(Ebadctl);
            sddelpart(unit, cb->f[1]);
        }
        else if(unit->dev->ifc->wctl)
            unit->dev->ifc->wctl(unit, cb);
        else
            error(Ebadctl);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        poperror();
        free(cb);
        break;

    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);
        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->raw);
        if(waserror()){
            qunlock(&unit->raw);
            decref(&sdev->r);
            nexterror();
        }
        switch(unit->state){
        case Rawcmd:
            if(n < 6 || n > sizeof(req->cmd))
                error(Ebadarg);
            if((req = malloc(sizeof(SDreq))) == nil)
                error(Enomem);
            req->unit = unit;
            memmove(req->cmd, a, n);
            req->clen = n;
            req->flags = SDnosense;
            req->status = ~0;

            unit->req = req;
            unit->state = Rawdata;
            break;

        case Rawstatus:
            unit->state = Rawcmd;
            free(unit->req);
            unit->req = nil;
            error(Ebadusefd);

        case Rawdata:
            unit->state = Rawstatus;
            unit->req->write = 1;
            n = sdrio(unit->req, a, n);
        }
        qunlock(&unit->raw);
        decref(&sdev->r);
        poperror();
        break;
    case Qpart:
        return sdbio(c, 1, a, n, off);
    }

    return n;
}

static int
sdwstat(Chan* c, uchar* dp, int n)
{
    Dir *d;
    SDpart *pp;
    SDperm *perm;
    SDunit *unit;
    SDev *sdev;

    if(c->qid.type & QTDIR)
        error(Eperm);

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil)
        error(Enonexist);
    unit = sdev->unit[UNIT(c->qid)];
    qlock(&unit->ctl);
    d = nil;
    if(waserror()){
        free(d);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        nexterror();
    }

    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qctl:
        perm = &unit->ctlperm;
        break;
    case Qraw:
        perm = &unit->rawperm;
        break;
    case Qpart:
        pp = &unit->part[PART(c->qid)];
        if(unit->vers+pp->vers != c->qid.vers)
            error(Enonexist);
        perm = &pp->SDperm;
        break;
    }

    if(strcmp(up->user, perm->user) && !iseve())
        error(Eperm);

    d = smalloc(sizeof(Dir)+n);
    n = convM2D(dp, n, &d[0], (char*)&d[1]);
    if(n == 0)
        error(Eshortstat);
    if(!emptystr(d[0].uid))
        kstrdup(&perm->user, d[0].uid);
    if(d[0].mode != ~0UL)
        perm->perm = (perm->perm & ~0777) | (d[0].mode & 0777);

    free(d);
    qunlock(&unit->ctl);
    decref(&sdev->r);
    poperror();
    return n;
}

static int
configure(char* spec, DevConf* cf)
{
    SDev *s, *sdev;
    char *p;
    int i;

    if(sdindex(*spec) < 0)
        error("bad sd spec");

    if((p = strchr(cf->type, '/')) != nil)
        *p++ = '\0';

    for(i = 0; sdifc[i] != nil; i++)
        if(strcmp(sdifc[i]->name, cf->type) == 0)
            break;
    if(sdifc[i] == nil)
        error("sd type not found");
    if(p)
        *(p-1) = '/';

    if(sdifc[i]->probe == nil)
        error("sd type cannot probe");

    sdev = sdifc[i]->probe(cf);
    for(s=sdev; s; s=s->next)
        s->idno = *spec;
    sdadddevs(sdev);
    return 0;
}

static int
unconfigure(char* spec)
{
    int i;
    SDev *sdev;
    SDunit *unit;

    if((i = sdindex(*spec)) < 0)
        error(Enonexist);

    qlock(&devslock);
    if((sdev = devs[i]) == nil){
        qunlock(&devslock);
        error(Enonexist);
    }
    if(sdev->r.ref){
        qunlock(&devslock);
        error(Einuse);
    }
    devs[i] = nil;
    qunlock(&devslock);

    /* make sure no interrupts arrive anymore before removing resources */
    if(sdev->enabled && sdev->ifc->disable)
        sdev->ifc->disable(sdev);

    for(i = 0; i != sdev->nunit; i++){
        if(unit = sdev->unit[i]){
            free(unit->name);
            free(unit->user);
            free(unit);
        }
    }

    if(sdev->ifc->clear)
        sdev->ifc->clear(sdev);
    free(sdev);
    return 0;
}

static int
sdconfig(int on, char* spec, DevConf* cf)
{
    if(on)
        return configure(spec, cf);
    return unconfigure(spec);
}

<<global sddevtab>>

/*
 * This is wrong for so many reasons.  This code must go.
 */
typedef struct Confdata Confdata;
struct Confdata {
    int on;
    char*   spec;
    DevConf cf;
};

static void
parseswitch(Confdata* cd, char* option)
{
    if(!strcmp("on", option))
        cd->on = 1;
    else if(!strcmp("off", option))
        cd->on = 0;
    else
        error(Ebadarg);
}

static void
parsespec(Confdata* cd, char* option)
{
    if(strlen(option) > 1)
        error(Ebadarg);
    cd->spec = option;
}

static Devport*
getnewport(DevConf* dc)
{
    Devport *p;

    p = (Devport *)malloc((dc->nports + 1) * sizeof(Devport));
    if(p == nil)
        error(Enomem);
    if(dc->nports > 0){
        memmove(p, dc->ports, dc->nports * sizeof(Devport));
        free(dc->ports);
    }
    dc->ports = p;
    p = &dc->ports[dc->nports++];
    p->size = -1;
    p->port = (ulong)-1;
    return p;
}

static void
parseport(Confdata* cd, char* option)
{
    char *e;
    Devport *p;

    if(cd->cf.nports == 0 || cd->cf.ports[cd->cf.nports-1].port != (ulong)-1)
        p = getnewport(&cd->cf);
    else
        p = &cd->cf.ports[cd->cf.nports-1];
    p->port = strtol(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parsesize(Confdata* cd, char* option)
{
    char *e;
    Devport *p;

    if(cd->cf.nports == 0 || cd->cf.ports[cd->cf.nports-1].size != -1)
        p = getnewport(&cd->cf);
    else
        p = &cd->cf.ports[cd->cf.nports-1];
    p->size = (int)strtol(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parseirq(Confdata* cd, char* option)
{
    char *e;

    cd->cf.intnum = strtoul(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parsetype(Confdata* cd, char* option)
{
    cd->cf.type = option;
}

static struct {
    char    *name;
    void    (*parse)(Confdata*, char*);
} options[] = {
    "switch",   parseswitch,
    "spec",     parsespec,
    "port",     parseport,
    "size",     parsesize,
    "irq",      parseirq,
    "type",     parsetype,
};

static void
legacytopctl(Cmdbuf *cb)
{
    char *opt;
    int i, j;
    Confdata cd;

    memset(&cd, 0, sizeof cd);
    cd.on = -1;
    for(i=0; i<cb->nf; i+=2){
        if(i+2 > cb->nf)
            error(Ebadarg);
        opt = cb->f[i];
        for(j=0; j<nelem(options); j++)
            if(strcmp(opt, options[j].name) == 0){
                options[j].parse(&cd, cb->f[i+1]);
                break;
            }
        if(j == nelem(options))
            error(Ebadarg);
    }
    /* this has been rewritten to accomodate sdaoe */
    if(cd.on < 0 || cd.spec == 0)
        error(Ebadarg);
    if(cd.on && cd.cf.type == nil)
        error(Ebadarg);
    sdconfig(cd.on, cd.spec, &cd.cf);
}
@
\fi

%// void
%// sdrmdevs(SDev *sdev)
%// {
%//  char buf[2];
%//
%//  snprint(buf, sizeof buf, "%c", sdev->idno);
%//  unconfigure(buf);
%// }
%
%//void
%//sdaddallconfs(void (*addconf)(SDunit *))
%//{
%//  int i, u;
%//  SDev *sdev;
%//
%//  for(i = 0; i < nelem(devs); i++)        /* each controller */
%//      for(sdev = devs[i]; sdev; sdev = sdev->next)
%//          for(u = 0; u < sdev->nunit; u++)    /* each drive */
%//              (*addconf)(sdev->unit[u]);
%//}
%
%
%/*
% * SCSI simulation for non-SCSI devices
% */
%//int
%//sdsetsense(SDreq *r, int status, int key, int asc, int ascq)
%//{
%//  int len;
%//  SDunit *unit;
%//
%//  unit = r->unit;
%//  unit->sense[2] = key;
%//  unit->sense[12] = asc;
%//  unit->sense[13] = ascq;
%//
%//  r->status = status;
%//  if(status == SDcheck && !(r->flags & SDnosense)){
%//      /* request sense case from sdfakescsi */
%//      len = sizeof unit->sense;
%//      if(len > sizeof r->sense-1)
%//          len = sizeof r->sense-1;
%//      memmove(r->sense, unit->sense, len);
%//      unit->sense[2] = 0;
%//      unit->sense[12] = 0;
%//      unit->sense[13] = 0;
%//      r->flags |= SDvalidsense;
%//      return SDok;
%//  }
%//  return status;
%//}
%
%//int
%//sdmodesense(SDreq *r, uchar *cmd, void *info, int ilen)
%//{
%//  int len;
%//  uchar *data;
%//
%//  /*
%//   * Fake a vendor-specific request with page code 0,
%//   * return the drive info.
%//   */
%//  if((cmd[2] & 0x3F) != 0 && (cmd[2] & 0x3F) != 0x3F)
%//      return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
%//  len = (cmd[7]<<8)|cmd[8];
%//  if(len == 0)
%//      return SDok;
%//  if(len < 8+ilen)
%//      return sdsetsense(r, SDcheck, 0x05, 0x1A, 0);
%//  if(r->data == nil || r->dlen < len)
%//      return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
%//  data = r->data;
%//  memset(data, 0, 8);
%//  data[0] = ilen>>8;
%//  data[1] = ilen;
%//  if(ilen)
%//      memmove(data+8, info, ilen);
%//  r->rlen = 8+ilen;
%//  return sdsetsense(r, SDok, 0, 0, 0);
%//}
%
%//int
%//sdfakescsi(SDreq *r, void *info, int ilen)
%//{
%//  uchar *cmd, *p;
%//  uvlong len;
%//  SDunit *unit;
%//
%//  cmd = r->cmd;
%//  r->rlen = 0;
%//  unit = r->unit;
%//
%//  /*
%//   * Rewrite read(6)/write(6) into read(10)/write(10).
%//   */
%//  switch(cmd[0]){
%//  case 0x08:  /* read */
%//  case 0x0A:  /* write */
%//      cmd[9] = 0;
%//      cmd[8] = cmd[4];
%//      cmd[7] = 0;
%//      cmd[6] = 0;
%//      cmd[5] = cmd[3];
%//      cmd[4] = cmd[2];
%//      cmd[3] = cmd[1] & 0x0F;
%//      cmd[2] = 0;
%//      cmd[1] &= 0xE0;
%//      cmd[0] |= 0x20;
%//      break;
%//  }
%//
%//  /*
%//   * Map SCSI commands into ATA commands for discs.
%//   * Fail any command with a LUN except INQUIRY which
%//   * will return 'logical unit not supported'.
%//   */
%//  if((cmd[1]>>5) && cmd[0] != 0x12)
%//      return sdsetsense(r, SDcheck, 0x05, 0x25, 0);
%//
%//  switch(cmd[0]){
%//  default:
%//      return sdsetsense(r, SDcheck, 0x05, 0x20, 0);
%//
%//  case 0x00:  /* test unit ready */
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x03:  /* request sense */
%//      if(cmd[4] < sizeof unit->sense)
%//          len = cmd[4];
%//      else
%//          len = sizeof unit->sense;
%//      if(r->data && r->dlen >= len){
%//          memmove(r->data, unit->sense, len);
%//          r->rlen = len;
%//      }
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x12:  /* inquiry */
%//      if(cmd[4] < sizeof unit->inquiry)
%//          len = cmd[4];
%//      else
%//          len = sizeof unit->inquiry;
%//      if(r->data && r->dlen >= len){
%//          memmove(r->data, unit->inquiry, len);
%//          r->rlen = len;
%//      }
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x1B:  /* start/stop unit */
%//      /*
%//       * nop for now, can use power management later.
%//       */
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x25:  /* read capacity */
%//      if((cmd[1] & 0x01) || cmd[2] || cmd[3])
%//          return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
%//      if(r->data == nil || r->dlen < 8)
%//          return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
%//
%//      /*
%//       * Read capacity returns the LBA of the last sector.
%//       */
%//      len = unit->sectors - 1;
%//      p = r->data;
%//      *p++ = len>>24;
%//      *p++ = len>>16;
%//      *p++ = len>>8;
%//      *p++ = len;
%//      len = 512;
%//      *p++ = len>>24;
%//      *p++ = len>>16;
%//      *p++ = len>>8;
%//      *p++ = len;
%//      r->rlen = p - (uchar*)r->data;
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x9E:  /* long read capacity */
%//      if((cmd[1] & 0x01) || cmd[2] || cmd[3])
%//          return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
%//      if(r->data == nil || r->dlen < 8)
%//          return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
%//      /*
%//       * Read capcity returns the LBA of the last sector.
%//       */
%//      len = unit->sectors - 1;
%//      p = r->data;
%//      *p++ = len>>56;
%//      *p++ = len>>48;
%//      *p++ = len>>40;
%//      *p++ = len>>32;
%//      *p++ = len>>24;
%//      *p++ = len>>16;
%//      *p++ = len>>8;
%//      *p++ = len;
%//      len = 512;
%//      *p++ = len>>24;
%//      *p++ = len>>16;
%//      *p++ = len>>8;
%//      *p++ = len;
%//      r->rlen = p - (uchar*)r->data;
%//      return sdsetsense(r, SDok, 0, 0, 0);
%//
%//  case 0x5A:  /* mode sense */
%//      return sdmodesense(r, cmd, info, ilen);
%//
%//  case 0x28:  /* read */
%//  case 0x2A:  /* write */
%//  case 0x88:  /* read16 */
%//  case 0x8a:  /* write16 */
%//      return SDnostatus;
%//  }
%//}


\subsection*{[[devices/storage/sd.h]]}

<<sd.h>>=
/*
 * Storage Device.
 */

struct SDperm {
  char* name;
  char* user;
  ulong perm;
};

struct SDpart {
  uvlong  start;
  uvlong  end;
  SDperm;
  int valid;
  ulong vers;
};

struct SDunit {
  SDev* dev;
  int subno;
  uchar inquiry[255];   /* format follows SCSI spec */
  uchar sense[18];    /* format follows SCSI spec */
  SDperm;

  QLock ctl;
  uvlong  sectors;
  ulong secsize;
  SDpart* part;     /* nil or array of size npart */
  int npart;
  ulong vers;
  SDperm  ctlperm;

  QLock raw;      /* raw read or write in progress */
  ulong rawinuse;   /* really just a test-and-set */
  int state;
  SDreq*  req;
  SDperm  rawperm;
};

/*
 * Each controller is represented by a SDev.
 */
struct SDev {
  Ref r;      /* Number of callers using device */
  SDifc*  ifc;      /* pnp/legacy */
  void* ctlr;
  int idno;
  char  name[8];
  SDev* next;

  QLock;        /* enable/disable */
  int enabled;
  int nunit;      /* Number of units */
  QLock unitlock;   /* `Loading' of units */
  int*  unitflg;    /* Unit flags */
  SDunit**unit;
};

struct SDifc {
  char* name;

  SDev* (*pnp)(void);
  SDev* (*legacy)(int, int);
  int (*enable)(SDev*);
  int (*disable)(SDev*);

  int (*verify)(SDunit*);
  int (*online)(SDunit*);
  int (*rio)(SDreq*);
  int (*rctl)(SDunit*, char*, int);
  int (*wctl)(SDunit*, Cmdbuf*);

  long  (*bio)(SDunit*, int, int, void*, long, uvlong);
  SDev* (*probe)(DevConf*);
  void  (*clear)(SDev*);
  char* (*rtopctl)(SDev*, char*, char*);
  int (*wtopctl)(SDev*, Cmdbuf*);
};

struct SDreq {
  SDunit* unit;
  int lun;
  int write;
  uchar cmd[16];
  int clen;
  void* data;
  int dlen;

  int flags;

  int status;
  long  rlen;
  uchar sense[256];
};

enum {
  SDnosense = 0x00000001,
  SDvalidsense  = 0x00010000,

  SDinq0periphqual= 0xe0,
  SDinq0periphtype= 0x1f,
  SDinq1removable = 0x80,

  /* periphtype values */
  SDperdisk = 0,  /* Direct access (disk) */
  SDpertape = 1,  /* Sequential eg, tape */
  SDperpr   = 2,  /* Printer */
  SDperworm = 4,  /* Worm */
  SDpercd   = 5,  /* CD-ROM */
  SDpermo   = 7,  /* rewriteable MO */
  SDperjuke = 8,  /* medium-changer */
};

enum {
  SDretry   = -5,   /* internal to controllers */
  SDmalloc  = -4,
  SDeio   = -3,
  SDtimeout = -2,
  SDnostatus  = -1,

  SDok    = 0,

  SDcheck   = 0x02,   /* check condition */
  SDbusy    = 0x08,   /* busy */

  SDmaxio   = 2048*1024,
  SDnpart   = 16,
};

/*
 * Allow the default #defines for sdmalloc & sdfree to be overridden by
 * system-specific versions.  This can be used to avoid extra copying
 * by making sure sd buffers are cache-aligned (some ARM systems) or
 * page-aligned (xen) for DMA.
 */
#ifndef sdmalloc
#define sdmalloc(n) malloc(n)
#define sdfree(p) free(p)
#endif

/*
 * mmc/sd/sdio host controller interface
 */

/* sdscsi.c */
extern int scsiverify(SDunit*);
extern int scsionline(SDunit*);
extern long scsibio(SDunit*, int, int, void*, long, uvlong);
//extern SDev* scsiid(SDev*, SDifc*);
@

%//struct SDio {
%//  char  *name;
%//  int (*init)(void);
%//  void  (*enable)(void);
%//  int (*inquiry)(char*, int);
%//  int (*cmd)(u32int, u32int, u32int*);
%//  void  (*iosetup)(int, void*, int, int);
%//  void  (*io)(int, uchar*, int);
%//};
%//
%//extern SDio sdio;
%
%/* devsd.c */
%//extern void sdadddevs(SDev*);
%//extern void sdaddconf(SDunit*);
%//extern void sdaddallconfs(void (*f)(SDunit*));
%//extern void sdaddpart(SDunit*, char*, uvlong, uvlong);
%//extern int sdsetsense(SDreq*, int, int, int, int);
%//extern int sdmodesense(SDreq*, uchar*, void*, int);
%//extern int sdfakescsi(SDreq*, void*, int);



\subsection*{[[devices/storage/sdscsi.c]]}


\ifallcode
<<sdscsi.c>>=
<<kernel basic includes>>

#include "io.h"
#include "../port/sd.h"

#include <ureg.h>

static int
scsitest(SDreq* r)
{
    r->write = 0;
    memset(r->cmd, 0, sizeof(r->cmd));
    r->cmd[1] = r->lun<<5;
    r->clen = 6;
    r->data = nil;
    r->dlen = 0;
    r->flags = 0;

    r->status = ~0;

    return r->unit->dev->ifc->rio(r);
}

int
scsiverify(SDunit* unit)
{
    SDreq *r;
    int i, status;
    uchar *inquiry;

    if((r = malloc(sizeof(SDreq))) == nil)
        return 0;
    if((inquiry = sdmalloc(sizeof(unit->inquiry))) == nil){
        free(r);
        return 0;
    }
    r->unit = unit;
    r->lun = 0;     /* ??? */

    memset(unit->inquiry, 0, sizeof(unit->inquiry));
    r->write = 0;
    r->cmd[0] = 0x12;
    r->cmd[1] = r->lun<<5;
    r->cmd[4] = sizeof(unit->inquiry)-1;
    r->clen = 6;
    r->data = inquiry;
    r->dlen = sizeof(unit->inquiry)-1;
    r->flags = 0;

    r->status = ~0;
    if(unit->dev->ifc->rio(r) != SDok){
        free(r);
        return 0;
    }
    memmove(unit->inquiry, inquiry, r->dlen);
    free(inquiry);

    SET(status);
    for(i = 0; i < 3; i++){
        while((status = scsitest(r)) == SDbusy)
            ;
        if(status == SDok || status != SDcheck)
            break;
        if(!(r->flags & SDvalidsense))
            break;
        if((r->sense[2] & 0x0F) != 0x02)
            continue;

        /*
         * Unit is 'not ready'.
         * If it is in the process of becoming ready or needs
         * an initialising command, set status so it will be spun-up
         * below.
         * If there's no medium, that's OK too, but don't
         * try to spin it up.
         */
        if(r->sense[12] == 0x04){
            if(r->sense[13] == 0x02 || r->sense[13] == 0x01){
                status = SDok;
                break;
            }
        }
        if(r->sense[12] == 0x3A)
            break;
    }

    if(status == SDok){
        /*
         * Try to ensure a direct-access device is spinning.
         * Don't wait for completion, ignore the result.
         */
        if((unit->inquiry[0] & SDinq0periphtype) == SDperdisk){
            memset(r->cmd, 0, sizeof(r->cmd));
            r->write = 0;
            r->cmd[0] = 0x1B;
            r->cmd[1] = (r->lun<<5)|0x01;
            r->cmd[4] = 1;
            r->clen = 6;
            r->data = nil;
            r->dlen = 0;
            r->flags = 0;

            r->status = ~0;
            unit->dev->ifc->rio(r);
        }
    }
    free(r);

    if(status == SDok || status == SDcheck)
        return 1;
    return 0;
}

static int
scsirio(SDreq* r)
{
    /*
     * Perform an I/O request, returning
     *  -1  failure
     *   0  ok
     *   1  no medium present
     *   2  retry
     * The contents of r may be altered so the
     * caller should re-initialise if necesary.
     */
    r->status = ~0;
    switch(r->unit->dev->ifc->rio(r)){
    default:
        break;
    case SDcheck:
        if(!(r->flags & SDvalidsense))
            break;
        switch(r->sense[2] & 0x0F){
        case 0x00:      /* no sense */
        case 0x01:      /* recovered error */
            return 2;
        case 0x06:      /* check condition */
            /*
             * 0x28 - not ready to ready transition,
             *    medium may have changed.
             * 0x29 - power on or some type of reset.
             */
            if(r->sense[12] == 0x28 && r->sense[13] == 0)
                return 2;
            if(r->sense[12] == 0x29)
                return 2;
            break;
        case 0x02:      /* not ready */
            /*
             * If no medium present, bail out.
             * If unit is becoming ready, rather than not
             * not ready, wait a little then poke it again.                  */
            if(r->sense[12] == 0x3A)
                break;
            if(r->sense[12] != 0x04 || r->sense[13] != 0x01)
                break;

            while(waserror())
                ;
            tsleep(&up->sleepr, returnfalse, 0, 500);
            poperror();
            scsitest(r);
            return 2;
        default:
            break;
        }
        break;
    case SDok:
        return 0;
    }
    return -1;
}

int
scsionline(SDunit* unit)
{
    SDreq *r;
    uchar *p;
    int ok, retries;

    if((r = malloc(sizeof(SDreq))) == nil)
        return 0;
    if((p = sdmalloc(8)) == nil){
        free(r);
        return 0;
    }

    ok = 0;

    r->unit = unit;
    r->lun = 0;             /* ??? */
    for(retries = 0; retries < 10; retries++){
        /*
         * Read-capacity is mandatory for DA, WORM, CD-ROM and
         * MO. It may return 'not ready' if type DA is not
         * spun up, type MO or type CD-ROM are not loaded or just
         * plain slow getting their act together after a reset.
         */
        r->write = 0;
        memset(r->cmd, 0, sizeof(r->cmd));
        r->cmd[0] = 0x25;
        r->cmd[1] = r->lun<<5;
        r->clen = 10;
        r->data = p;
        r->dlen = 8;
        r->flags = 0;

        r->status = ~0;
        switch(scsirio(r)){
        default:
            break;
        case 0:
            unit->sectors = (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
            unit->secsize = (p[4]<<24)|(p[5]<<16)|(p[6]<<8)|p[7];

            /*
             * Some ATAPI CD readers lie about the block size.
             * Since we don't read audio via this interface
             * it's okay to always fudge this.
             */
            if(unit->secsize == 2352)
                unit->secsize = 2048;
            /*
             * Devices with removable media may return 0 sectors
             * when they have empty media (e.g. sata dvd writers);
             * if so, keep the count zero.
             *
             * Read-capacity returns the LBA of the last sector,
             * therefore the number of sectors must be incremented.
             */
            if(unit->sectors != 0)
                unit->sectors++;
            ok = 1;
            break;
        case 1:
            ok = 1;
            break;
        case 2:
            continue;
        }
        break;
    }
    free(p);
    free(r);

    if(ok)
        return ok+retries;
    else
        return 0;
}

static void
scsifmt10(SDreq *r, int write, int lun, ulong nb, uvlong bno)
{
    uchar *c;

    c = r->cmd;
    if(write == 0)
        c[0] = 0x28;
    else
        c[0] = 0x2A;
    c[1] = lun<<5;
    c[2] = bno>>24;
    c[3] = bno>>16;
    c[4] = bno>>8;
    c[5] = bno;
    c[6] = 0;
    c[7] = nb>>8;
    c[8] = nb;
    c[9] = 0;

    r->clen = 10;
}

static void
scsifmt16(SDreq *r, int write, int lun, ulong nb, uvlong bno)
{
    uchar *c;

    c = r->cmd;
    if(write == 0)
        c[0] = 0x88;
    else
        c[0] = 0x8A;
    c[1] = lun<<5;      /* so wrong */
    c[2] = bno>>56;
    c[3] = bno>>48;
    c[4] = bno>>40;
    c[5] = bno>>32;
    c[6] = bno>>24;
    c[7] = bno>>16;
    c[8] = bno>>8;
    c[9] = bno;
    c[10] = nb>>24;
    c[11] = nb>>16;
    c[12] = nb>>8;
    c[13] = nb;
    c[14] = 0;
    c[15] = 0;

    r->clen = 16;
}

long
scsibio(SDunit* unit, int lun, int write, void* data, long nb, uvlong bno)
{
    SDreq *r;
    long rlen;

    if((r = malloc(sizeof(SDreq))) == nil)
        error(Enomem);
    r->unit = unit;
    r->lun = lun;
again:
    r->write = write;
    if(bno >= (1ULL<<32))
        scsifmt16(r, write, lun, nb, bno);
    else
        scsifmt10(r, write, lun, nb, bno);
    r->data = data;
    r->dlen = nb*unit->secsize;
    r->flags = 0;

    r->status = ~0;
    switch(scsirio(r)){
    default:
        rlen = -1;
        break;
    case 0:
        rlen = r->rlen;
        break;
    case 2:
        rlen = -1;
        if(!(r->flags & SDvalidsense))
            break;
        switch(r->sense[2] & 0x0F){
        default:
            break;
        case 0x01:      /* recovered error */
            print("%s: recovered error at sector %llud\n",
                unit->name, bno);
            rlen = r->rlen;
            break;
        case 0x06:      /* check condition */
            /*
             * Check for a removeable media change.
             * If so, mark it by zapping the geometry info
             * to force an online request.
             */
            if(r->sense[12] != 0x28 || r->sense[13] != 0)
                break;
            if(unit->inquiry[1] & SDinq1removable)
                unit->sectors = 0;
            break;
        case 0x02:      /* not ready */
            /*
             * If unit is becoming ready,
             * rather than not not ready, try again.
             */
            if(r->sense[12] == 0x04 && r->sense[13] == 0x01)
                goto again;
            break;
        }
        break;
    }
    free(r);

    return rlen;
}

@
\fi

%//int
%//scsiexec(SDunit* unit, int write, uchar* cmd, int clen, void* data, int* dlen)
%//{
%//  SDreq *r;
%//  int status;
%//
%//  if((r = malloc(sizeof(SDreq))) == nil)
%//      return SDmalloc;
%//  r->unit = unit;
%//  r->lun = cmd[1]>>5;     /* ??? */
%//  r->write = write;
%//  memmove(r->cmd, cmd, clen);
%//  r->clen = clen;
%//  r->data = data;
%//  if(dlen)
%//      r->dlen = *dlen;
%//  r->flags = 0;
%//
%//  r->status = ~0;
%//
%//  /*
%//   * Call the device-specific I/O routine.
%//   * There should be no calls to 'error()' below this
%//   * which percolate back up.
%//   */
%//  switch(status = unit->dev->ifc->rio(r)){
%//  case SDok:
%//      if(dlen)
%//          *dlen = r->rlen;
%//      /*FALLTHROUGH*/
%//  case SDcheck:
%//      /*FALLTHROUGH*/
%//  default:
%//      /*
%//       * It's more complicated than this. There are conditions
%//       * which are 'ok' but for which the returned status code
%//       * is not 'SDok'.
%//       * Also, not all conditions require a reqsense, might
%//       * need to do a reqsense here and make it available to the
%//       * caller somehow.
%//       *
%//       * Mañana.
%//       */
%//      break;
%//  }
%//  sdfree(r);
%//
%//  return status;
%//}


\subsection*{[[devices/sys/devdup.c]]}

<<global dupdevtab>>=
Dev dupdevtab = {
    .dc       =    'd',
    .name     =    "dup",
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    dupattach,
    .walk     =    dupwalk,
    .stat     =    dupstat,
    .open     =    dupopen,
    .create   =    devcreate,
    .close    =    dupclose,
    .read     =    dupread,
    .bread    =    devbread,
    .write    =    dupwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@


<<devdup.c>>=
<<kernel basic includes>>

/* Qid is (2*fd + (file is ctl))+1 */

static int
dupgen(Chan *c, char *, Dirtab*, int, int s, Dir *dp)
{
    Fgrp *fgrp = up->fgrp;
    Chan *f;
    static int perm[] = { 0400, 0200, 0600, 0 };
    int p;
    Qid q;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, ".", 0, eve, DMDIR|0555, dp);
        return 1;
    }
    if(s == 0)
        return 0;
    s--;
    if(s/2 > fgrp->maxfd)
        return -1;
    if((f=fgrp->fd[s/2]) == nil)
        return 0;
    if(s & 1){
        p = 0400;
        snprint(up->genbuf, sizeof up->genbuf, "%dctl", s/2);
    }else{
        p = perm[f->mode&3];
        snprint(up->genbuf, sizeof up->genbuf, "%d", s/2);
    }
    mkqid(&q, s+1, 0, QTFILE);
    devdir(c, q, up->genbuf, 0, eve, p, dp);
    return 1;
}

static Chan*
dupattach(char *spec)
{
    return devattach('d', spec);
}

static Walkqid*
dupwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, (Dirtab *)0, 0, dupgen);
}

static int
dupstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, (Dirtab *)0, 0L, dupgen);
}

static Chan*
dupopen(Chan *c, int omode)
{
    Chan *f;
    int fd, twicefd;

    if(c->qid.type & QTDIR){
        if(omode != 0)
            error(Eisdir);
        c->mode = 0;
        c->flag |= COPEN;
        c->offset = 0;
        return c;
    }
    if(c->qid.type & QTAUTH)
        error(Eperm);
    twicefd = c->qid.path - 1;
    fd = twicefd/2;
    if((twicefd & 1)){
        /* ctl file */
        f = c;
        f->mode = openmode(omode);
        f->flag |= COPEN;
        f->offset = 0;
    }else{
        /* fd file */
        f = fdtochan(fd, openmode(omode), 0, 1);
        cclose(c);
    }
    if(omode & OCEXEC)
        f->flag |= CCEXEC;
    return f;
}

static void
dupclose(Chan*)
{
}

static long
dupread(Chan *c, void *va, long n, vlong offset)
{
    char *a = va;
    char buf[256];
    int fd, twicefd;

    if(c->qid.type == QTDIR)
        return devdirread(c, a, n, (Dirtab *)0, 0L, dupgen);
    twicefd = c->qid.path - 1;
    fd = twicefd/2;
    if(twicefd & 1){
        c = fdtochan(fd, -1, 0, 1);
        procfdprint(c, fd, 0, buf, sizeof buf);
        cclose(c);
        return readstr((ulong)offset, va, n, buf);
    }
    panic("dupread");
    return 0;
}

static long
dupwrite(Chan*, void*, long, vlong)
{
    error(Eperm);
    return 0;       /* not reached */
}

<<global dupdevtab>>
@


\subsection*{[[devices/sys/devmnt.c]]}

\ifallcode
<<devmnt.c forward decl>>=
Mnt*    mntchk(Chan*);
void    mntdirfix(uchar*, Chan*);
Mntrpc* mntflushalloc(Mntrpc*, ulong);
void    mntflushfree(Mnt*, Mntrpc*);
void    mntgate(Mnt*);
void    mntqrm(Mnt*, Mntrpc*);
Mntrpc* mntralloc(Chan*, ulong);
long    mntrdwr(int, Chan*, void*, long, vlong);
int mntrpcread(Mnt*, Mntrpc*);
void    mountio(Mnt*, Mntrpc*);
void    mountmux(Mnt*, Mntrpc*);
void    mountrpc(Mnt*, Mntrpc*);
int rpcattn(void*);
Chan*   mntchan(void);
@
\fi


<<[[Chan]] other fields>>=
int fid;      /* for devmnt */
ulong iounit;     /* chunk size for i/o; 0==default */

Mnt*  mux;      /* Mnt for clients using me for messages */

Qid mqid;     /* qid of root of mount point */
@

<<global mntdevtab>>=
Dev mntdevtab = {
    .dc       =    'M',
    .name     =    "mnt",
               
    .reset    =    mntreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    mntattach,
    .walk     =    mntwalk,
    .stat     =    mntstat,
    .open     =    mntopen,
    .create   =    mntcreate,
    .close    =    mntclose,
    .read     =    mntread,
    .bread    =    devbread,
    .write    =    mntwrite,
    .bwrite   =    devbwrite,
    .remove   =    mntremove,
    .wstat    =    mntwstat,
};
@


<<devmnt.c>>=
<<kernel basic includes>>

#define MAXRPC (IOHDRSZ+8192)

<<devmnt.c forward decl>>


void (*mntstats)(int, Chan*, uvlong, ulong);

static void
mntreset(void)
{
    mntalloc.id = 1;
    mntalloc.tagmask[0] = 1;            /* don't allow 0 as a tag */
    mntalloc.tagmask[NMASK-1] = 0x80000000UL;   /* don't allow NOTAG */
    fmtinstall('F', fcallfmt);
    fmtinstall('D', dirfmt);
/* We can't install %M since eipfmt does and is used in the kernel [sape] */

    cinit();
}


Chan*
mntauth(Chan *c, char *spec)
{
    Mnt *m;
    Mntrpc *r;

    m = c->mux;

    if(m == nil){
        mntversion(c, VERSION9P, MAXRPC, 0);
        m = c->mux;
        if(m == nil)
            error(Enoversion);
    }

    c = mntchan();
    if(waserror()) {
        /* Close must not be called since it will
         * call mnt recursively
         */
        chanfree(c);
        nexterror();
    }

    r = mntralloc(0, m->msize);

    if(waserror()) {
        mntfree(r);
        nexterror();
    }

    r->request.type = Tauth;
    r->request.afid = c->fid;
    r->request.uname = up->user;
    r->request.aname = spec;
    mountrpc(m, r);

    c->qid = r->reply.aqid;
    c->mchan = m->c;
    incref(m->c);
    c->mqid = c->qid;
    c->mode = ORDWR;

    poperror(); /* r */
    mntfree(r);

    poperror(); /* c */

    return c;

}

static Chan*
mntattach(char *muxattach)
{
    Mnt *m;
    Chan *c;
    Mntrpc *r;
    struct bogus{
        Chan    *chan;
        Chan    *authchan;
        char    *spec;
        int flags;
    }bogus;

    bogus = *((struct bogus *)muxattach);
    c = bogus.chan;

    m = c->mux;

    if(m == nil){
        mntversion(c, nil, 0, 0);
        m = c->mux;
        if(m == nil)
            error(Enoversion);
    }

    c = mntchan();
    if(waserror()) {
        /* Close must not be called since it will
         * call mnt recursively
         */
        chanfree(c);
        nexterror();
    }

    r = mntralloc(0, m->msize);

    if(waserror()) {
        mntfree(r);
        nexterror();
    }

    r->request.type = Tattach;
    r->request.fid = c->fid;
    if(bogus.authchan == nil)
        r->request.afid = NOFID;
    else
        r->request.afid = bogus.authchan->fid;
    r->request.uname = up->user;
    r->request.aname = bogus.spec;
    mountrpc(m, r);

    c->qid = r->reply.qid;
    c->mchan = m->c;
    incref(m->c);
    c->mqid = c->qid;

    poperror(); /* r */
    mntfree(r);

    poperror(); /* c */

    if(bogus.flags&MCACHE)
        c->flag |= CCACHE;
    return c;
}

Chan*
mntchan(void)
{
    Chan *c;

    c = devattach('M', 0);
    lock(&mntalloc);
    c->dev = mntalloc.id++;
    unlock(&mntalloc);

    if(c->mchan)
        panic("mntchan non-zero %p", c->mchan);
    return c;
}

static Walkqid*
mntwalk(Chan *c, Chan *nc, char **name, int nname)
{
    int i, alloc;
    Mnt *m;
    Mntrpc *r;
    Walkqid *wq;

    if(nc != nil)
        print("mntwalk: nc != nil\n");
    if(nname > MAXWELEM)
        error("devmnt: too many name elements");
    alloc = 0;
    wq = smalloc(sizeof(Walkqid)+(nname-1)*sizeof(Qid));
    if(waserror()){
        if(alloc && wq->clone!=nil)
            cclose(wq->clone);
        free(wq);
        return nil;
    }

    alloc = 0;
    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(nc == nil){
        nc = devclone(c);
        /*
         * Until the other side accepts this fid, we can't mntclose it.
         * Therefore set type to 0 for now; rootclose is known to be safe.
         */
        nc->type = 0;
        alloc = 1;
    }
    wq->clone = nc;
    nc->flag |= c->flag&CCACHE;

    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Twalk;
    r->request.fid = c->fid;
    r->request.newfid = nc->fid;
    r->request.nwname = nname;
    memmove(r->request.wname, name, nname*sizeof(char*));

    mountrpc(m, r);

    if(r->reply.nwqid > nname)
        error("too many QIDs returned by walk");
    if(r->reply.nwqid < nname){
        if(alloc)
            cclose(nc);
        wq->clone = nil;
        if(r->reply.nwqid == 0){
            free(wq);
            wq = nil;
            goto Return;
        }
    }

    /* move new fid onto mnt device and update its qid */
    if(wq->clone != nil){
        if(wq->clone != c){
            wq->clone->type = c->type;
            wq->clone->mchan = c->mchan;
            incref(c->mchan);
        }
        if(r->reply.nwqid > 0)
            wq->clone->qid = r->reply.wqid[r->reply.nwqid-1];
    }
    wq->nqid = r->reply.nwqid;
    for(i=0; i<wq->nqid; i++)
        wq->qid[i] = r->reply.wqid[i];

    Return:
    poperror();
    mntfree(r);
    poperror();
    return wq;
}

static int
mntstat(Chan *c, uchar *dp, int n)
{
    Mnt *m;
    Mntrpc *r;

    if(n < BIT16SZ)
        error(Eshortstat);
    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Tstat;
    r->request.fid = c->fid;
    mountrpc(m, r);

    if(r->reply.nstat > n){
        n = BIT16SZ;
        PBIT16((uchar*)dp, r->reply.nstat-2);
    }else{
        n = r->reply.nstat;
        memmove(dp, r->reply.stat, n);
        validstat(dp, n);
        mntdirfix(dp, c);
    }
    poperror();
    mntfree(r);
    return n;
}

static Chan*
mntopencreate(int type, Chan *c, char *name, int omode, ulong perm)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = type;
    r->request.fid = c->fid;
    r->request.mode = omode;
    if(type == Tcreate){
        r->request.perm = perm;
        r->request.name = name;
    }
    mountrpc(m, r);

    c->qid = r->reply.qid;
    c->offset = 0;
    c->mode = openmode(omode);
    c->iounit = r->reply.iounit;
    if(c->iounit == 0 || c->iounit > m->msize-IOHDRSZ)
        c->iounit = m->msize-IOHDRSZ;
    c->flag |= COPEN;
    poperror();
    mntfree(r);

    if(c->flag & CCACHE)
        copen(c);

    return c;
}

static Chan*
mntopen(Chan *c, int omode)
{
    return mntopencreate(Topen, c, nil, omode, 0);
}

static void
mntcreate(Chan *c, char *name, int omode, ulong perm)
{
    mntopencreate(Tcreate, c, name, omode, perm);
}

static void
mntclunk(Chan *c, int t)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()){
        mntfree(r);
        nexterror();
    }

    r->request.type = t;
    r->request.fid = c->fid;
    mountrpc(m, r);
    mntfree(r);
    poperror();
}



static void
mntclose(Chan *c)
{
    mntclunk(c, Tclunk);
}

static void
mntremove(Chan *c)
{
    mntclunk(c, Tremove);
}

static int
mntwstat(Chan *c, uchar *dp, int n)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Twstat;
    r->request.fid = c->fid;
    r->request.nstat = n;
    r->request.stat = dp;
    mountrpc(m, r);
    poperror();
    mntfree(r);
    return n;
}

static long
mntread(Chan *c, void *buf, long n, vlong off)
{
    uchar *p, *e;
    int nc, cache, isdir, dirlen;

    isdir = 0;
    cache = c->flag & CCACHE;
    if(c->qid.type & QTDIR) {
        cache = 0;
        isdir = 1;
    }

    p = buf;
    if(cache) {
        nc = cread(c, buf, n, off);
        if(nc > 0) {
            n -= nc;
            if(n == 0)
                return nc;
            p += nc;
            off += nc;
        }
        n = mntrdwr(Tread, c, p, n, off);
        cupdate(c, p, n, off);
        return n + nc;
    }

    n = mntrdwr(Tread, c, buf, n, off);
    if(isdir) {
        for(e = &p[n]; p+BIT16SZ < e; p += dirlen){
            dirlen = BIT16SZ+GBIT16(p);
            if(p+dirlen > e)
                break;
            validstat(p, dirlen);
            mntdirfix(p, c);
        }
        if(p != e)
            error(Esbadstat);
    }
    return n;
}

static long
mntwrite(Chan *c, void *buf, long n, vlong off)
{
    return mntrdwr(Twrite, c, buf, n, off);
}

long
mntrdwr(int type, Chan *c, void *buf, long n, vlong off)
{
    Mnt *m;
    Mntrpc *r;
    char *uba;
    int cache;
    ulong cnt, nr, nreq;

    m = mntchk(c);
    uba = buf;
    cnt = 0;
    cache = c->flag & CCACHE;
    if(c->qid.type & QTDIR)
        cache = 0;
    for(;;) {
        r = mntralloc(c, m->msize);
        if(waserror()) {
            mntfree(r);
            nexterror();
        }
        r->request.type = type;
        r->request.fid = c->fid;
        r->request.offset = off;
        r->request.data = uba;
        nr = n;
        if(nr > m->msize-IOHDRSZ)
            nr = m->msize-IOHDRSZ;
        r->request.count = nr;
        mountrpc(m, r);
        nreq = r->request.count;
        nr = r->reply.count;
        if(nr > nreq)
            nr = nreq;

        if(type == Tread)
            r->b = bl2mem((uchar*)uba, r->b, nr);
        else if(cache)
            cwrite(c, (uchar*)uba, nr, off);

        poperror();
        mntfree(r);
        off += nr;
        uba += nr;
        cnt += nr;
        n -= nr;
        if(nr != nreq || n == 0 || up->nnote)
            break;
    }
    return cnt;
}

void
mountrpc(Mnt *m, Mntrpc *r)
{
    char *sn, *cn;
    int t;

    r->reply.tag = 0;
    r->reply.type = Tmax;   /* can't ever be a valid message type */

    mountio(m, r);

    t = r->reply.type;
    switch(t) {
    case Rerror:
        error(r->reply.ename);
    case Rflush:
        error(Eintr);
    default:
        if(t == r->request.type+1)
            break;
        sn = "?";
        if(m->c->path != nil)
            sn = m->c->path->s;
        cn = "?";
        if(r->c != nil && r->c->path != nil)
            cn = r->c->path->s;
        print("mnt: proc %s %lud: mismatch from %s %s rep %#p tag %d fid %d T%d R%d rp %d\n",
            up->text, up->pid, sn, cn,
            r, r->request.tag, r->request.fid, r->request.type,
            r->reply.type, r->reply.tag);
        error(Emountrpc);
    }
}

void
mountio(Mnt *m, Mntrpc *r)
{
    int n;

    while(waserror()) {
        if(m->rip == up)
            mntgate(m);
        if(strcmp(up->errstr, Eintr) != 0){
            mntflushfree(m, r);
            nexterror();
        }
        r = mntflushalloc(r, m->msize);
    }

    lock(m);
    r->m = m;
    r->list = m->queue;
    m->queue = r;
    unlock(m);

    /* Transmit a file system rpc */
    if(m->msize == 0)
        panic("msize");
    n = convS2M(&r->request, r->rpc, m->msize);
    if(n < 0)
        panic("bad message type in mountio");
    if(devtab[m->c->type]->write(m->c, r->rpc, n, 0) != n)
        error(Emountrpc);
    r->stime = fastticks(nil);
    r->reqlen = n;

    /* Gate readers onto the mount point one at a time */
    for(;;) {
        lock(m);
        if(m->rip == 0)
            break;
        unlock(m);
        sleep(&r->r, rpcattn, r);
        if(r->done){
            poperror();
            mntflushfree(m, r);
            return;
        }
    }
    m->rip = up;
    unlock(m);
    while(r->done == 0) {
        if(mntrpcread(m, r) < 0)
            error(Emountrpc);
        mountmux(m, r);
    }
    mntgate(m);
    poperror();
    mntflushfree(m, r);
}

static int
doread(Mnt *m, int len)
{
    Block *b;

    while(qlen(m->q) < len){
        b = devtab[m->c->type]->bread(m->c, m->msize, 0);
        if(b == nil)
            return -1;
        if(blocklen(b) == 0){
            freeblist(b);
            return -1;
        }
        qaddlist(m->q, b);
    }
    return 0;
}

int
mntrpcread(Mnt *m, Mntrpc *r)
{
    int i, t, len, hlen;
    Block *b, **l, *nb;

    r->reply.type = 0;
    r->reply.tag = 0;

    /* read at least length, type, and tag and pullup to a single block */
    if(doread(m, BIT32SZ+BIT8SZ+BIT16SZ) < 0)
        return -1;
    nb = pullupqueue(m->q, BIT32SZ+BIT8SZ+BIT16SZ);

    /* read in the rest of the message, avoid ridiculous (for now) message sizes */
    len = GBIT32(nb->rp);
    if(len > m->msize){
        qdiscard(m->q, qlen(m->q));
        return -1;
    }
    if(doread(m, len) < 0)
        return -1;

    /* pullup the header (i.e. everything except data) */
    t = nb->rp[BIT32SZ];
    switch(t){
    case Rread:
        hlen = BIT32SZ+BIT8SZ+BIT16SZ+BIT32SZ;
        break;
    default:
        hlen = len;
        break;
    }
    nb = pullupqueue(m->q, hlen);

    if(convM2S(nb->rp, len, &r->reply) <= 0){
        /* bad message, dump it */
        print("mntrpcread: convM2S failed\n");
        qdiscard(m->q, len);
        return -1;
    }

    /* hang the data off of the fcall struct */
    l = &r->b;
    *l = nil;
    do {
        b = qremove(m->q);
        if(hlen > 0){
            b->rp += hlen;
            len -= hlen;
            hlen = 0;
        }
        i = BLEN(b);
        if(i <= len){
            len -= i;
            *l = b;
            l = &(b->next);
        } else {
            /* split block and put unused bit back */
            nb = allocb(i-len);
            memmove(nb->wp, b->rp+len, i-len);
            b->wp = b->rp+len;
            nb->wp += i-len;
            qputback(m->q, nb);
            *l = b;
            return 0;
        }
    }while(len > 0);

    return 0;
}

void
mntgate(Mnt *m)
{
    Mntrpc *q;

    lock(m);
    m->rip = 0;
    for(q = m->queue; q; q = q->list) {
        if(q->done == 0)
        if(wakeup(&q->r))
            break;
    }
    unlock(m);
}

void
mountmux(Mnt *m, Mntrpc *r)
{
    Mntrpc **l, *q;

    lock(m);
    l = &m->queue;
    for(q = *l; q; q = q->list) {
        /* look for a reply to a message */
        if(q->request.tag == r->reply.tag) {
            *l = q->list;
            if(q != r) {
                /*
                 * Completed someone else.
                 * Trade pointers to receive buffer.
                 */
                q->reply = r->reply;
                q->b = r->b;
                r->b = nil;
            }
            q->done = 1;
            unlock(m);
            if(mntstats != nil)
                (*mntstats)(q->request.type,
                    m->c, q->stime,
                    q->reqlen + r->replen);
            if(q != r)
                wakeup(&q->r);
            return;
        }
        l = &q->list;
    }
    unlock(m);
    print("unexpected reply tag %ud; type %d\n", r->reply.tag, r->reply.type);
}

/*
 * Create a new flush request and chain the previous
 * requests from it
 */
Mntrpc*
mntflushalloc(Mntrpc *r, ulong iounit)
{
    Mntrpc *fr;

    fr = mntralloc(0, iounit);

    fr->request.type = Tflush;
    if(r->request.type == Tflush)
        fr->request.oldtag = r->request.oldtag;
    else
        fr->request.oldtag = r->request.tag;
    fr->flushed = r;

    return fr;
}

/*
 *  Free a chain of flushes.  Remove each unanswered
 *  flush and the original message from the unanswered
 *  request queue.  Mark the original message as done
 *  and if it hasn't been answered set the reply to to
 *  Rflush.
 */
void
mntflushfree(Mnt *m, Mntrpc *r)
{
    Mntrpc *fr;

    while(r){
        fr = r->flushed;
        if(!r->done){
            r->reply.type = Rflush;
            mntqrm(m, r);
        }
        if(fr)
            mntfree(r);
        r = fr;
    }
}

int
alloctag(void)
{
    int i, j;
    ulong v;

    for(i = 0; i < NMASK; i++){
        v = mntalloc.tagmask[i];
        if(v == ~0UL)
            continue;
        for(j = 0; j < 1<<TAGSHIFT; j++)
            if((v & (1<<j)) == 0){
                mntalloc.tagmask[i] |= 1<<j;
                return (i<<TAGSHIFT) + j;
            }
    }
    panic("no friggin tags left");
    return NOTAG;
}


Mntrpc*
mntralloc(Chan *c, ulong msize)
{
    Mntrpc *new;

    lock(&mntalloc);
    new = mntalloc.rpcfree;
    if(new == nil){
        new = malloc(sizeof(Mntrpc));
        if(new == nil) {
            unlock(&mntalloc);
            exhausted("mount rpc header");
        }
        /*
         * The header is split from the data buffer as
         * mountmux may swap the buffer with another header.
         */
        new->rpc = mallocz(msize, 0);
        if(new->rpc == nil){
            free(new);
            unlock(&mntalloc);
            exhausted("mount rpc buffer");
        }
        new->rpclen = msize;
        new->request.tag = alloctag();
    }
    else {
        mntalloc.rpcfree = new->list;
        mntalloc.nrpcfree--;
        if(new->rpclen < msize){
            free(new->rpc);
            new->rpc = mallocz(msize, 0);
            if(new->rpc == nil){
                free(new);
                mntalloc.nrpcused--;
                unlock(&mntalloc);
                exhausted("mount rpc buffer");
            }
            new->rpclen = msize;
        }
    }
    mntalloc.nrpcused++;
    unlock(&mntalloc);
    new->c = c;
    new->done = 0;
    new->flushed = nil;
    new->b = nil;
    return new;
}


void
mntqrm(Mnt *m, Mntrpc *r)
{
    Mntrpc **l, *f;

    lock(m);
    r->done = 1;

    l = &m->queue;
    for(f = *l; f; f = f->list) {
        if(f == r) {
            *l = r->list;
            break;
        }
        l = &f->list;
    }
    unlock(m);
}

Mnt*
mntchk(Chan *c)
{
    Mnt *m;

    /* This routine is mostly vestiges of prior lives; now it's just sanity checking */

    if(c->mchan == nil)
        panic("mntchk 1: nil mchan c %s\n", chanpath(c));

    m = c->mchan->mux;

    if(m == nil)
        print("mntchk 2: nil mux c %s c->mchan %s \n", chanpath(c), chanpath(c->mchan));

    /*
     * Was it closed and reused (was error(Eshutdown); now, it cannot happen)
     */
    if(m->id == 0 || m->id >= c->dev)
        panic("mntchk 3: can't happen");

    return m;
}

/*
 * Rewrite channel type and dev for in-flight data to
 * reflect local values.  These entries are known to be
 * the first two in the Dir encoding after the count.
 */
void
mntdirfix(uchar *dirbuf, Chan *c)
{
    uint r;

    r = devtab[c->type]->dc;
    dirbuf += BIT16SZ;  /* skip count */
    PBIT16(dirbuf, r);
    dirbuf += BIT16SZ;
    PBIT32(dirbuf, c->dev);
}

int
rpcattn(void *v)
{
    Mntrpc *r;

    r = v;
    return r->done || r->m->rip == 0;
}

<<global mntdevtab>>
@


\subsection*{[[devices/sys/devpipe.c]]}

\ifallcode
<<devpipe.c forward decl>>=
typedef struct Pipe Pipe;
@
\fi


<<devpipe.c>>=
<<kernel basic includes>>

// need that??
#include    "netif.h"

<<devpipe.c forward decl>>

<<struct Pipe>>

<<struct Pipealloc>>

<<global pipealloc>>

<<devpipe.c enum Qxxx>>

<<global pipedir>>

#define NPIPEDIR 3

<<method pipeinit>>

<<method pipeattach>>

<<function pipegen>>

<<method pipewalk>>

<<method pipestat>>

<<method pipewstat>>

<<method pipeopen>>

<<method pipeclose>>

<<method piperead>>

<<method pipebread>>

<<method pipewrite>>

<<method pipebwrite>>

<<global pipedevtab>>
@


\subsection*{[[devices/sys/devsrv.c]]}

\ifallcode
<<devsrv.c forward decl>>=
typedef struct Srv Srv;
@
\fi

<<struct Srv>>=
struct Srv
{
    char    *name;
    char    *owner;
    ulong   perm;
    Chan    *chan;
    Srv *link;
    ulong   path;
};
@


<<global srv>>=
static Srv  *srv;
@


<<global srvlk>>=
static QLock    srvlk;
@


<<global qidpath>>=
static int  qidpath;
@


<<method srvgen>>=
static int
srvgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    Srv *sp;
    Qid q;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, "#s", 0, eve, 0555, dp);
        return 1;
    }

    qlock(&srvlk);
    for(sp = srv; sp && s; sp = sp->link)
        s--;

    if(sp == 0) {
        qunlock(&srvlk);
        return -1;
    }

    mkqid(&q, sp->path, 0, QTFILE);
    /* make sure name string continues to exist after we release lock */
    kstrcpy(up->genbuf, sp->name, sizeof up->genbuf);
    devdir(c, q, up->genbuf, 0, sp->owner, sp->perm, dp);
    qunlock(&srvlk);
    return 1;
}
@


<<method srvinit>>=
static void
srvinit(void)
{
    qidpath = 1;
}
@


<<function srvlookup>>=
static Srv*
srvlookup(char *name, ulong qidpath)
{
    Srv *sp;
    for(sp = srv; sp; sp = sp->link)
        if(sp->path == qidpath || (name && strcmp(sp->name, name) == 0))
            return sp;
    return nil;
}
@


<<function srvname>>=
char*
srvname(Chan *c)
{
    int size;
    Srv *sp;
    char *s;

    for(sp = srv; sp; sp = sp->link)
        if(sp->chan == c){
            size = 3+strlen(sp->name)+1;
            s = smalloc(size);
            snprint(s, size, "#s/%s", sp->name);
            return s;
        }
    return nil;
}
@


<<method srvopen>>=
static Chan*
srvopen(Chan *c, int omode)
{
    Srv *sp;

    if(c->qid.type == QTDIR){
        if(omode & ORCLOSE)
            error(Eperm);
        if(omode != OREAD)
            error(Eisdir);
        c->mode = omode;
        c->flag |= COPEN;
        c->offset = 0;
        return c;
    }
    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        nexterror();
    }

    sp = srvlookup(nil, c->qid.path);
    if(sp == 0 || sp->chan == 0)
        error(Eshutdown);

    if(omode&OTRUNC)
        error("srv file already exists");
    if(openmode(omode)!=sp->chan->mode && sp->chan->mode!=ORDWR)
        error(Eperm);
    devpermcheck(sp->owner, sp->perm, omode);

    cclose(c);
    incref(sp->chan);
    qunlock(&srvlk);
    poperror();
    return sp->chan;
}
@


<<method srvcreate>>=
static void
srvcreate(Chan *c, char *name, int omode, ulong perm)
{
    char *sname;
    Srv *sp;

    if(openmode(omode) != OWRITE)
        error(Eperm);

    if(omode & OCEXEC)  /* can't happen */
        panic("someone broke namec");

    sp = smalloc(sizeof *sp);
    sname = smalloc(strlen(name)+1);

    qlock(&srvlk);
    if(waserror()){
        free(sp);
        free(sname);
        qunlock(&srvlk);
        nexterror();
    }
    if(sp == nil || sname == nil)
        error(Enomem);
    if(srvlookup(name, -1))
        error(Eexist);

    sp->path = qidpath++;
    sp->link = srv;
    strcpy(sname, name);
    sp->name = sname;
    c->qid.type = QTFILE;
    c->qid.path = sp->path;
    srv = sp;
    qunlock(&srvlk);
    poperror();

    kstrdup(&sp->owner, up->user);
    sp->perm = perm&0777;

    c->flag |= COPEN;
    c->mode = OWRITE;
}
@


<<method srvremove>>=
static void
srvremove(Chan *c)
{
    Srv *sp, **l;

    if(c->qid.type == QTDIR)
        error(Eperm);

    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        nexterror();
    }
    l = &srv;
    for(sp = *l; sp; sp = sp->link) {
        if(sp->path == c->qid.path)
            break;

        l = &sp->link;
    }
    if(sp == 0)
        error(Enonexist);

    /*
     * Only eve can remove system services.
     * No one can remove #s/boot.
     */
    if(strcmp(sp->owner, eve) == 0 && !iseve())
        error(Eperm);
    if(strcmp(sp->name, "boot") == 0)
        error(Eperm);

    /*
     * No removing personal services.
     */
    if((sp->perm&7) != 7 && strcmp(sp->owner, up->user) && !iseve())
        error(Eperm);

    *l = sp->link;
    qunlock(&srvlk);
    poperror();

    if(sp->chan)
        cclose(sp->chan);
    free(sp->owner);
    free(sp->name);
    free(sp);
}
@


<<method srvwstat>>=
static int
srvwstat(Chan *c, uchar *dp, int n)
{
    char *strs;
    Dir d;
    Srv *sp;

    if(c->qid.type & QTDIR)
        error(Eperm);

    strs = nil;
    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        free(strs);
        nexterror();
    }

    sp = srvlookup(nil, c->qid.path);
    if(sp == 0)
        error(Enonexist);

    if(strcmp(sp->owner, up->user) != 0 && !iseve())
        error(Eperm);

    strs = smalloc(n);
    n = convM2D(dp, n, &d, strs);
    if(n == 0)
        error(Eshortstat);
    if(d.mode != ~0UL)
        sp->perm = d.mode & 0777;
    if(d.uid && *d.uid)
        kstrdup(&sp->owner, d.uid);
    if(d.name && *d.name && strcmp(sp->name, d.name) != 0) {
        if(strchr(d.name, '/') != nil)
            error(Ebadchar);
        kstrdup(&sp->name, d.name);
    }
    qunlock(&srvlk);
    free(strs);
    poperror();
    return n;
}
@


<<method srvclose>>=
static void
srvclose(Chan *c)
{
    /*
     * in theory we need to override any changes in removability
     * since open, but since all that's checked is the owner,
     * which is immutable, all is well.
     */
    if(c->flag & CRCLOSE){
        if(waserror())
            return;
        srvremove(c);
        poperror();
    }
}
@


<<method srvread>>=
static long
srvread(Chan *c, void *va, long n, vlong)
{
    isdir(c);
    return devdirread(c, va, n, 0, 0, srvgen);
}
@


<<method srvwrite>>=
static long
srvwrite(Chan *c, void *va, long n, vlong)
{
    Srv *sp;
    Chan *c1;
    int fd;
    char buf[32];

    if(n >= sizeof buf)
        error(Egreg);
    memmove(buf, va, n);    /* so we can NUL-terminate */
    buf[n] = 0;
    fd = strtoul(buf, 0, 0);

    c1 = fdtochan(fd, -1, 0, 1);    /* error check and inc ref */

    qlock(&srvlk);
    if(waserror()) {
        qunlock(&srvlk);
        cclose(c1);
        nexterror();
    }
    if(c1->flag & (CCEXEC|CRCLOSE))
        error("posted fd has remove-on-close or close-on-exec");
    if(c1->qid.type & QTAUTH)
        error("cannot post auth file in srv");
    sp = srvlookup(nil, c->qid.path);
    if(sp == 0)
        error(Enonexist);

    if(sp->chan)
        error(Ebadusefd);

    sp->chan = c1;
    qunlock(&srvlk);
    poperror();
    return n;
}
@


<<global srvdevtab>>=
Dev srvdevtab = {
    .dc       =    's',
    .name     =    "srv",
               
    .reset    =    devreset,
    .init     =    srvinit,    
    .shutdown =    devshutdown,
    .attach   =    srvattach,
    .walk     =    srvwalk,
    .stat     =    srvstat,
    .open     =    srvopen,
    .create   =    srvcreate,
    .close    =    srvclose,
    .read     =    srvread,
    .bread    =    devbread,
    .write    =    srvwrite,
    .bwrite   =    devbwrite,
    .remove   =    srvremove,
    .wstat    =    srvwstat,
};
@


<<devsrv.c>>=
<<kernel basic includes>>

<<devsrv.c forward decl>>

<<struct Srv>>

<<global srvlk>>
<<global srv>>
<<global qidpath>>

<<method srvgen>>

<<method srvinit>>

static Chan*
srvattach(char *spec)
{
    return devattach('s', spec);
}

static Walkqid*
srvwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, srvgen);
}

<<function srvlookup>>

static int
srvstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, srvgen);
}

<<function srvname>>

<<method srvopen>>

<<method srvcreate>>

<<method srvremove>>

<<method srvwstat>>

<<method srvclose>>

<<method srvread>>

<<method srvwrite>>

<<global srvdevtab>>
@

\subsection*{[[devices/sys/devenv.c]]}

\ifallcode
<<devenv.c forward decl>>=
static Egrp *envgrp(Chan *c);
static int  envwriteable(Chan *c);
@
\fi

<<global envdevtab>>=
Dev envdevtab = {
    .dc       =    'e',
    .name     =    "env",
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    envattach,
    .walk     =    envwalk,
    .stat     =    envstat,
    .open     =    envopen,
    .create   =    envcreate,
    .close    =    envclose,
    .read     =    envread,
    .bread    =    devbread,
    .write    =    envwrite,
    .bwrite   =    devbwrite,
    .remove   =    envremove,
    .wstat    =    devwstat,
};
@



<<function envcpy>>=
void
envcpy(Egrp *to, Egrp *from)
{
    int i;
    Evalue *ne, *e;

    rlock(from);
    to->ment = (from->nent+31)&~31;
    to->ent = smalloc(to->ment*sizeof(to->ent[0]));
    for(i=0; i<from->nent; i++){
        e = from->ent[i];
        ne = smalloc(sizeof(Evalue));
        ne->name = smalloc(strlen(e->name)+1);
        strcpy(ne->name, e->name);
        if(e->value){
            ne->value = smalloc(e->len);
            memmove(ne->value, e->value, e->len);
            ne->len = e->len;
        }
        ne->qid.path = ++to->path;
        to->ent[i] = ne;
    }
    to->nent = from->nent;
    runlock(from);
}
@


<<function envgrp>>=
static Egrp*
envgrp(Chan *c)
{
    if(c->aux == nil)
        return up->egrp;
    return c->aux;
}
@


<<function envwriteable>>=
static int
envwriteable(Chan *c)
{
    return iseve() || c->aux == nil;
}
@


<<function getconfenv>>=
/*
 * Return a copy of configuration environment as a sequence of strings.
 * The strings alternate between name and value.  A zero length name string
 * indicates the end of the list
 */
char *
getconfenv(void)
{
    Egrp *eg = &confegrp;
    Evalue *e;
    char *p, *q;
    int i, n;

    rlock(eg);
    if(waserror()) {
        runlock(eg);
        nexterror();
    }
    
    /* determine size */
    n = 0;
    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        n += strlen(e->name) + e->len + 2;
    }
    p = malloc(n + 1);
    if(p == nil)
        error(Enomem);
    q = p;
    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        strcpy(q, e->name);
        q += strlen(q) + 1;
        memmove(q, e->value, e->len);
        q[e->len] = 0;
        /* move up to the first null */
        q += strlen(q) + 1;
    }
    *q = 0;
    
    poperror();
    runlock(eg);
    return p;
}
@


<<devenv.c>>=
<<kernel basic includes>>

enum
{
    Maxenvsize = 16300,
};

<<devenv.c forward decl>>

static Egrp confegrp;   /* global environment group containing the kernel configuration */

static Evalue*
envlookup(Egrp *eg, char *name, ulong qidpath)
{
    Evalue *e;
    int i;

    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        if(e->qid.path == qidpath || (name && e->name[0]==name[0] && strcmp(e->name, name) == 0))
            return e;
    }
    return nil;
}

static int
envgen(Chan *c, char *name, Dirtab*, int, int s, Dir *dp)
{
    Egrp *eg;
    Evalue *e;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, "#e", 0, eve, DMDIR|0775, dp);
        return 1;
    }

    eg = envgrp(c);
    rlock(eg);
    e = 0;
    if(name)
        e = envlookup(eg, name, -1);
    else if(s < eg->nent)
        e = eg->ent[s];

    if(e == 0) {
        runlock(eg);
        return -1;
    }

    /* make sure name string continues to exist after we release lock */
    kstrcpy(up->genbuf, e->name, sizeof up->genbuf);
    devdir(c, e->qid, up->genbuf, e->len, eve, 0666, dp);
    runlock(eg);
    return 1;
}

static Chan*
envattach(char *spec)
{
    Chan *c;
    Egrp *egrp = nil;

    if(spec && *spec) {
        if(strcmp(spec, "c") == 0)
            egrp = &confegrp;
        if(egrp == nil)
            error(Ebadarg);
    }

    c = devattach('e', spec);
    c->aux = egrp;
    return c;
}

static Walkqid*
envwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, envgen);
}

static int
envstat(Chan *c, uchar *db, int n)
{
    if(c->qid.type & QTDIR)
        c->qid.vers = envgrp(c)->vers;
    return devstat(c, db, n, 0, 0, envgen);
}

static Chan*
envopen(Chan *c, int omode)
{
    Egrp *eg;
    Evalue *e;
    int trunc;

    eg = envgrp(c);
    if(c->qid.type & QTDIR) {
        if(omode != OREAD)
            error(Eperm);
    }
    else {
        trunc = omode & OTRUNC;
        if(omode != OREAD && !envwriteable(c))
            error(Eperm);
        if(trunc)
            wlock(eg);
        else
            rlock(eg);
        e = envlookup(eg, nil, c->qid.path);
        if(e == 0) {
            if(trunc)
                wunlock(eg);
            else
                runlock(eg);
            error(Enonexist);
        }
        if(trunc && e->value) {
            e->qid.vers++;
            free(e->value);
            e->value = 0;
            e->len = 0;
        }
        if(trunc)
            wunlock(eg);
        else
            runlock(eg);
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    return c;
}

static void
envcreate(Chan *c, char *name, int omode, ulong)
{
    Egrp *eg;
    Evalue *e;
    Evalue **ent;

    if(c->qid.type != QTDIR)
        error(Eperm);
    if(strlen(name) >= sizeof up->genbuf)
        error("name too long");         /* protect envgen */

    omode = openmode(omode);
    eg = envgrp(c);

    wlock(eg);
    if(waserror()) {
        wunlock(eg);
        nexterror();
    }

    if(envlookup(eg, name, -1))
        error(Eexist);

    e = smalloc(sizeof(Evalue));
    e->name = smalloc(strlen(name)+1);
    strcpy(e->name, name);

    if(eg->nent == eg->ment){
        eg->ment += 32;
        ent = smalloc(sizeof(eg->ent[0])*eg->ment);
        if(eg->nent)
            memmove(ent, eg->ent, sizeof(eg->ent[0])*eg->nent);
        free(eg->ent);
        eg->ent = ent;
    }
    e->qid.path = ++eg->path;
    e->qid.vers = 0;
    eg->vers++;
    eg->ent[eg->nent++] = e;
    c->qid = e->qid;

    wunlock(eg);
    poperror();

    c->offset = 0;
    c->mode = omode;
    c->flag |= COPEN;
}

static void
envremove(Chan *c)
{
    int i;
    Egrp *eg;
    Evalue *e;

    if(c->qid.type & QTDIR)
        error(Eperm);

    eg = envgrp(c);
    wlock(eg);
    e = 0;
    for(i=0; i<eg->nent; i++){
        if(eg->ent[i]->qid.path == c->qid.path){
            e = eg->ent[i];
            eg->nent--;
            eg->ent[i] = eg->ent[eg->nent];
            eg->vers++;
            break;
        }
    }
    wunlock(eg);
    if(e == 0)
        error(Enonexist);
    free(e->name);
    if(e->value)
        free(e->value);
    free(e);
}

static void
envclose(Chan *c)
{
    /*
     * cclose can't fail, so errors from remove will be ignored.
     * since permissions aren't checked,
     * envremove can't not remove it if its there.
     */
    if(c->flag & CRCLOSE)
        envremove(c);
}

static long
envread(Chan *c, void *a, long n, vlong off)
{
    Egrp *eg;
    Evalue *e;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, 0, 0, envgen);

    eg = envgrp(c);
    rlock(eg);
    e = envlookup(eg, nil, c->qid.path);
    if(e == 0) {
        runlock(eg);
        error(Enonexist);
    }

    if(offset > e->len) /* protects against overflow converting vlong to ulong */
        n = 0;
    else if(offset + n > e->len)
        n = e->len - offset;
    if(n <= 0)
        n = 0;
    else
        memmove(a, e->value+offset, n);
    runlock(eg);
    return n;
}

static long
envwrite(Chan *c, void *a, long n, vlong off)
{
    char *s;
    ulong len;
    Egrp *eg;
    Evalue *e;
    ulong offset = off;

    if(n <= 0)
        return 0;
    if(offset > Maxenvsize || n > (Maxenvsize - offset))
        error(Etoobig);

    eg = envgrp(c);
    wlock(eg);
    e = envlookup(eg, nil, c->qid.path);
    if(e == 0) {
        wunlock(eg);
        error(Enonexist);
    }

    len = offset+n;
    if(len > e->len) {
        s = smalloc(len);
        if(e->value){
            memmove(s, e->value, e->len);
            free(e->value);
        }
        e->value = s;
        e->len = len;
    }
    memmove(e->value+offset, a, n);
    e->qid.vers++;
    eg->vers++;
    wunlock(eg);
    return n;
}

<<global envdevtab>>



<<function envcpy>>

<<function envgrp>>

<<function envwriteable>>

<<function ksetenv>>

<<function getconfenv>>
@

\subsection*{[[../include/trace.h]]}

<<[[enum Tevent]] real-time scheduling events>>=
SAdmit,	/* Edf admit */
SRelease,	/* Edf release, waiting to be scheduled */
SYield,		/* blocked waiting for release */
SSlice,		/* slice exhausted */
SDeadline,	/* proc's deadline */
SExpel,		/* Edf expel */
SInts,		/* Interrupt start */
SInte,		/* Interrupt end */
@

<<trace.h>>=
<<enum Tevent>>

<<struct Traceevent>>

typedef enum Tevent Tevent;
typedef struct Traceevent	Traceevent;
@

\subsection*{[[../include/tos.h]]}
<<tos.h>>=
typedef struct Plink Plink;
#pragma incomplete Plink

<<struct Tos>>
typedef struct Tos Tos;

extern Tos *_tos;
@

\subsection*{[[devices/sys/devproc.c]]}

\ifallcode
<<devproc.c forward decl>>=
void    procctlreq(Proc*, char*, int);
int procctlmemio(Proc*, ulong, int, void*, int);
Chan*   proctext(Chan*, Proc*);
Segment* text2data(Proc*, Segment*);
int procstopped(void*);
void    mntscan(Mntwalk*, Proc*);
@
\fi

<<struct Mntwalk>>=
struct Mntwalk              /* state for /proc/#/ns */
{
    int cddone;
    Mhead*  mh;
    Mount*  cm;
};
@













<<devproc.c>>=
<<kernel basic includes>>

#include    <trace.h>
#include    <tos.h>
#include    <ureg.h>

<<struct Mntwalk>>

<<devproc.c enum Qxxx>>

<<devproc enum CMxxx>>

enum{
<<constant Nevents>>
<<constant Emask>>
};

#define STATSIZE    (2*KNAMELEN+12+9*12)
<<global procdir>>

<<global proccmd>>

/* Segment type from portdat.h */
<<global sname>>

<<devproc QXXX macros>>

<<devproc.c forward decl>>

<<global trace txxx>>

<<clock callback profclock>>

<<function procgen>>

<<function _proctrace>>

<<method procinit>>

static Chan*
procattach(char *spec)
{
    return devattach('p', spec);
}

static Walkqid*
procwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, procgen);
}

static int
procstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, procgen);
}

<<function nonone>>

<<method procopen>>

<<method procwstat>>

<<function procoffset>>

<<function procqidwidth>>

<<function procfdprint>>

<<function procfds>>

<<method procclose>>

<<function int2flag>>

<<function procargs>>

<<function eventsavailable>>

<<method procread>>

<<function mntscan>>

<<method procwrite>>

<<global procdevtab>>



<<function proctext>>

<<function procstopwait>>

<<function procctlcloseone>>

<<function procctlclosefiles>>

<<function parsetime>>

<<function procctlreq>>

<<function procstopped>>

<<function procctlmemio>>

<<function text2data>>
@


\subsection*{[[files/cache.c]]}

\ifallcode
<<cache.c forward decl>>=
typedef struct Cache Cache;
typedef struct Ecache Ecache;
@
\fi

<<[[Chan]] other fields>>=
Mntcache* mcp;      /* Mount cache pointer */
@

% used only by cache.c
<<function auxpage>>=
Page*
auxpage(void)
{
    Page *p;

    lock(&palloc);
    p = palloc.head;
    if(palloc.freecount < swapalloc.highwater) {
        unlock(&palloc);
        return nil;
    }
    pageunchain(p);

    lock(p);
    if(p->ref != 0)
        panic("auxpage");
    p->ref++;
    uncachepage(p);
    unlock(p);
    unlock(&palloc);

    return p;
}
@



<<cache.c>>=
<<kernel basic includes>>

enum
{
    NHASH       = 128,
    MAXCACHE    = 1024*1024,
    NFILE       = 4096,
    NEXTENT     = 200,      /* extent allocation size */
};

<<cache.c forward decl>>

struct Cache
{
    QLock;
    int     pgno;
    Mntcache    *head;
    Mntcache    *tail;
    Mntcache    *hash[NHASH];
};

struct Ecache
{
    Lock;
    int total;
    int free;
    Extent* head;
};

static KImage fscache;
static Cache cache;
static Ecache ecache;
static int maxcache = MAXCACHE;

static void
extentfree(Extent* e)
{
    lock(&ecache);
    e->next = ecache.head;
    ecache.head = e;
    ecache.free++;
    unlock(&ecache);
}

static Extent*
extentalloc(void)
{
    Extent *e;
    int i;

    lock(&ecache);
    if(ecache.head == nil){
        e = xalloc(NEXTENT*sizeof(Extent));
        if(e == nil){
            unlock(&ecache);
            return nil;
        }
        for(i = 0; i < NEXTENT; i++){
            e->next = ecache.head;
            ecache.head = e;
            e++;
        }
        ecache.free += NEXTENT;
        ecache.total += NEXTENT;
    }

    e = ecache.head;
    ecache.head = e->next;
    memset(e, 0, sizeof(Extent));
    ecache.free--;
    unlock(&ecache);

    return e;
}

void
cinit(void)
{
    int i;
    Mntcache *m;

    cache.head = xalloc(sizeof(Mntcache)*NFILE);
    m = cache.head;
    if (m == nil)
        panic("cinit: no memory");

    /* a better algorithm would be nice */
    if(conf.npage*BY2PG > 400*MB)
        maxcache = 20*MAXCACHE;
    else if(conf.npage*BY2PG > 200*MB)
        maxcache = 10*MAXCACHE;

    for(i = 0; i < NFILE-1; i++) {
        m->next = m+1;
        m->prev = m-1;
        m++;
    }

    cache.tail = m;
    cache.tail->next = 0;
    cache.head->prev = 0;

    fscache.notext = true;
}

Page*
cpage(Extent *e)
{
    /* Easy consistency check */
    if(e->cache->daddr != e->bid)
        return 0;

    return lookpage(&fscache, e->bid);
}

void
cnodata(Mntcache *m)
{
    Extent *e, *n;

    /*
     * Invalidate all extent data
     * Image lru will waste the pages
     */
    for(e = m->list; e; e = n) {
        n = e->next;
        extentfree(e);
    }
    m->list = 0;
}

void
ctail(Mntcache *m)
{
    /* Unlink and send to the tail */
    if(m->prev)
        m->prev->next = m->next;
    else
        cache.head = m->next;
    if(m->next)
        m->next->prev = m->prev;
    else
        cache.tail = m->prev;

    if(cache.tail) {
        m->prev = cache.tail;
        cache.tail->next = m;
        m->next = 0;
        cache.tail = m;
    }
    else {
        cache.head = m;
        cache.tail = m;
        m->prev = 0;
        m->next = 0;
    }
}

void
copen(Chan *c)
{
    int h;
    Extent *e, *next;
    Mntcache *m, *f, **l;

    /* directories aren't cacheable and append-only files confuse us */
    if(c->qid.type&(QTDIR|QTAPPEND))
        return;

    h = c->qid.path%NHASH;
    qlock(&cache);
    for(m = cache.hash[h]; m; m = m->hash) {
        if(m->qid.path == c->qid.path)
        if(m->qid.type == c->qid.type)
        if(m->dev == c->dev && m->type == c->type) {
            c->mcp = m;
            ctail(m);
            qunlock(&cache);

            /* File was updated, invalidate cache */
            if(m->qid.vers != c->qid.vers) {
                m->qid.vers = c->qid.vers;
                qlock(m);
                cnodata(m);
                qunlock(m);
            }
            return;
        }
    }

    /* LRU the cache headers */
    m = cache.head;
    l = &cache.hash[m->qid.path%NHASH];
    for(f = *l; f; f = f->hash) {
        if(f == m) {
            *l = m->hash;
            break;
        }
        l = &f->hash;
    }

    m->qid = c->qid;
    m->dev = c->dev;
    m->type = c->type;

    l = &cache.hash[h];
    m->hash = *l;
    *l = m;
    ctail(m);

    qlock(m);
    c->mcp = m;
    e = m->list;
    m->list = 0;
    qunlock(&cache);

    while(e) {
        next = e->next;
        extentfree(e);
        e = next;
    }
    qunlock(m);
}

static int
cdev(Mntcache *m, Chan *c)
{
    if(m->qid.path != c->qid.path)
        return 0;
    if(m->qid.type != c->qid.type)
        return 0;
    if(m->dev != c->dev)
        return 0;
    if(m->type != c->type)
        return 0;
    if(m->qid.vers != c->qid.vers)
        return 0;
    return 1;
}

int
cread(Chan *c, uchar *buf, int len, vlong off)
{
    KMap *k;
    Page *p;
    Mntcache *m;
    Extent *e, **t;
    int o, l, total;
    ulong offset;

    if(off+len > maxcache)
        return 0;

    m = c->mcp;
    if(m == 0)
        return 0;

    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return 0;
    }

    offset = off;
    t = &m->list;
    for(e = *t; e; e = e->next) {
        if(offset >= e->start && offset < e->start+e->len)
            break;
        t = &e->next;
    }

    if(e == 0) {
        qunlock(m);
        return 0;
    }

    total = 0;
    while(len) {
        p = cpage(e);
        if(p == 0) {
            *t = e->next;
            extentfree(e);
            qunlock(m);
            return total;
        }

        o = offset - e->start;
        l = len;
        if(l > e->len-o)
            l = e->len-o;

        k = kmap(p);
        if(waserror()) {
            kunmap(k);
            putpage(p);
            qunlock(m);
            nexterror();
        }

        memmove(buf, (uchar*)VA(k) + o, l);

        poperror();
        kunmap(k);

        putpage(p);

        buf += l;
        len -= l;
        offset += l;
        total += l;
        t = &e->next;
        e = e->next;
        if(e == 0 || e->start != offset)
            break;
    }

    qunlock(m);
    return total;
}

Extent*
cchain(uchar *buf, ulong offset, int len, Extent **tail)
{
    int l;
    Page *p;
    KMap *k;
    Extent *e, *start, **t;

    start = 0;
    *tail = 0;
    t = &start;
    while(len) {
        e = extentalloc();
        if(e == 0)
            break;

        p = auxpage();
        if(p == 0) {
            extentfree(e);
            break;
        }
        l = len;
        if(l > BY2PG)
            l = BY2PG;

        e->cache = p;
        e->start = offset;
        e->len = l;

        qlock(&cache);
        e->bid = cache.pgno;
        cache.pgno += BY2PG;
        /* wrap the counter; low bits are unused by pghash but checked by lookpage */
        if((cache.pgno & ~(BY2PG-1)) == 0){
            if(cache.pgno == BY2PG-1){
                print("cache wrapped\n");
                cache.pgno = 0;
            }else
                cache.pgno++;
        }
        qunlock(&cache);

        p->daddr = e->bid;
        k = kmap(p);
        if(waserror()) {        /* buf may be virtual */
            kunmap(k);
            nexterror();
        }
        memmove((void*)VA(k), buf, l);
        poperror();
        kunmap(k);

        cachepage(p, &fscache);
        putpage(p);

        buf += l;
        offset += l;
        len -= l;

        *t = e;
        *tail = e;
        t = &e->next;
    }

    return start;
}

int
cpgmove(Extent *e, uchar *buf, int boff, int len)
{
    Page *p;
    KMap *k;

    p = cpage(e);
    if(p == 0)
        return 0;

    k = kmap(p);
    if(waserror()) {        /* Since buf may be virtual */
        kunmap(k);
        nexterror();
    }

    memmove((uchar*)VA(k)+boff, buf, len);

    poperror();
    kunmap(k);
    putpage(p);

    return 1;
}

void
cupdate(Chan *c, uchar *buf, int len, vlong off)
{
    Mntcache *m;
    Extent *tail;
    Extent *e, *f, *p;
    int o, ee, eblock;
    ulong offset;

    if(off > maxcache || len == 0)
        return;

    m = c->mcp;
    if(m == 0)
        return;
    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return;
    }

    /*
     * Find the insertion point
     */
    offset = off;
    p = 0;
    for(f = m->list; f; f = f->next) {
        if(f->start > offset)
            break;
        p = f;
    }

    /* trim if there is a successor */
    eblock = offset+len;
    if(f != 0 && eblock > f->start) {
        len -= (eblock - f->start);
        if(len <= 0) {
            qunlock(m);
            return;
        }
    }

    if(p == 0) {        /* at the head */
        e = cchain(buf, offset, len, &tail);
        if(e != 0) {
            m->list = e;
            tail->next = f;
        }
        qunlock(m);
        return;
    }

    /* trim to the predecessor */
    ee = p->start+p->len;
    if(offset < ee) {
        o = ee - offset;
        len -= o;
        if(len <= 0) {
            qunlock(m);
            return;
        }
        buf += o;
        offset += o;
    }

    /* try and pack data into the predecessor */
    if(offset == ee && p->len < BY2PG) {
        o = len;
        if(o > BY2PG - p->len)
            o = BY2PG - p->len;
        if(cpgmove(p, buf, p->len, o)) {
            p->len += o;
            buf += o;
            len -= o;
            offset += o;
            if(len <= 0) {
if(f && p->start + p->len > f->start) print("CACHE: p->start=%uld p->len=%d f->start=%uld\n", p->start, p->len, f->start);
                qunlock(m);
                return;
            }
        }
    }

    e = cchain(buf, offset, len, &tail);
    if(e != 0) {
        p->next = e;
        tail->next = f;
    }
    qunlock(m);
}

void
cwrite(Chan* c, uchar *buf, int len, vlong off)
{
    int o, eo;
    Mntcache *m;
    ulong eblock, ee;
    Extent *p, *f, *e, *tail;
    ulong offset;

    if(off > maxcache || len == 0)
        return;

    m = c->mcp;
    if(m == 0)
        return;

    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return;
    }

    offset = off;
    m->qid.vers++;
    c->qid.vers++;

    p = 0;
    for(f = m->list; f; f = f->next) {
        if(f->start >= offset)
            break;
        p = f;
    }

    if(p != 0) {
        ee = p->start+p->len;
        eo = offset - p->start;
        /* pack in predecessor if there is space */
        if(offset <= ee && eo < BY2PG) {
            o = len;
            if(o > BY2PG - eo)
                o = BY2PG - eo;
            if(cpgmove(p, buf, eo, o)) {
                if(eo+o > p->len)
                    p->len = eo+o;
                buf += o;
                len -= o;
                offset += o;
            }
        }
    }

    /* free the overlap -- it's a rare case */
    eblock = offset+len;
    while(f && f->start < eblock) {
        e = f->next;
        extentfree(f);
        f = e;
    }

    /* link the block (if any) into the middle */
    e = cchain(buf, offset, len, &tail);
    if(e != 0) {
        tail->next = f;
        f = e;
    }

    if(p == 0)
        m->list = f;
    else
        p->next = f;
    qunlock(m);
}
@

%//void
%//cprint(Chan *c, Mntcache *m, char *s)
%//{
%//  ulong o;
%//  int nb, ct;
%//  Extent *e;
%//
%//  nb = 0;
%//  ct = 1;
%//  o = 0;
%//  if(m->list)
%//      o = m->list->start;
%//  for(e = m->list; e; e = e->next) {
%//      nb += e->len;
%//      if(o != e->start)
%//          ct = 0;
%//      o = e->start+e->len;
%//  }
%//  pprint("%s: %#llux.%#lux %d %d %s (%d %c)\n",
%//  s, m->qid.path, m->qid.vers, m->type, m->dev, c->path->s, nb, ct ? 'C' : 'N');
%//
%//  for(e = m->list; e; e = e->next) {
%//      pprint("\t%4d %5lud %4d %#p\n",
%//          e->bid, e->start, e->len, e->cache);
%//  }
%//}

\subsection*{[[filesystems/devfs.c]]}

\ifallcode
<<devfs.c forward decl>>=
typedef struct Inner Inner;
typedef struct Fsdev Fsdev;
typedef struct Tree Tree;

extern Dev fsdevtab;        /* forward */
@
\fi

<<devfs.c debugging macro>>=
static int debug;
#define dprint if(debug)print
@


<<global fsdevtab>>=
Dev fsdevtab = {
    .dc       =    'k',
    .name     =    "fs",
               
    .reset    =    devreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .attach   =    mattach,
    .walk     =    mwalk,
    .stat     =    mstat,
    .open     =    mopen,
    .create   =    devcreate,
    .close    =    mclose,
    .read     =    mread,
    .bread    =    devbread,
    .write    =    mwrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,

    .power    =    devpower,
    .config   =    devconfig,
};
@


<<devfs.c>>=
/*
 * File system devices.
 * Follows device config in Ken's file server.
 * Builds mirrors, concatenations, interleavings, and partitions
 * of devices out of other (inner) devices.
 * It is ok if inner devices are provided by this driver.
 *
 * Built files are grouped on different directories
 * (called trees, and used to represent disks).
 * The "#k/fs" tree is always available and never goes away.
 * Configuration changes happen only while no I/O is in progress.
 *
 * Default sector size is one byte unless changed by the "disk" ctl.
 */

<<kernel basic includes>>
#include "io.h"
#include <ureg.h>

enum
{
    Fnone,
    Fmirror,        /* mirror of others */
    Fcat,           /* catenation of others */
    Finter,         /* interleaving of others */
    Fpart,          /* part of other */
    Fclear,         /* start over */
    Fdel,           /* delete a configure device */
    Fdisk,          /* set default tree and sector sz*/

    Sectorsz = 1,
    Blksize = 8*1024,   /* for Finter only */

    Incr = 5,       /* Increments for the dev array */

    /*
     * All qids are decorated with the tree number.
     * #k/fs is tree number 0, is automatically added and
     * its first qid is for the ctl file. It never goes away.
     */
    Qtop    = 0,        /* #k */
    Qdir,           /* directory (#k/fs) */
    Qctl,           /* ctl, only for #k/fs/ctl */
    Qfirst,         /* first qid assigned for device */

    Iswrite = 0,
    Isread,

    Optional = 0,
    Mustexist,

    /* tunable parameters */
    Maxconf = 4*1024,   /* max length for config */
    Ndevs   = 32,       /* max. inner devs per command */
    Ntrees  = 128,      /* max. number of trees */
    Maxretries = 3,     /* max. retries of i/o errors */
    Retrypause = 5000,  /* ms. to pause between retries */
};

<<devfs.c forward decl>>

<<devfs.c debugging macro>>


struct Inner
{
    char    *iname;     /* inner device name */
    vlong   isize;      /* size of inner device */
    Chan    *idev;      /* inner device */
};

struct Fsdev
{
    Ref;            /* one per Chan doing I/O */
    int gone;       /* true if removed */
    int vers;       /* qid version for this device */
    int type;       /* Fnone, Fmirror, ... */
    char    *name;      /* name for this fsdev */
    Tree*   tree;       /* where the device is kept */
    vlong   size;       /* min(inner[X].isize) */
    vlong   start;      /* start address (for Fpart) */
    uint    ndevs;      /* number of inner devices */
    int perm;       /* minimum of inner device perms */
    Inner   *inner[Ndevs];  /* inner devices */
};

struct Tree
{
    char    *name;      /* name for #k/<name> */
    Fsdev   **devs;     /* devices in dir. */
    uint    ndevs;      /* number of devices */
    uint    nadevs;     /* number of allocated devices in devs */
};



static RWlock lck;      /* r: use devices; w: change config  */
static Tree fstree;     /* The main "fs" tree. Never goes away */
static Tree *trees[Ntrees]; /* internal representation of config */
static int ntrees;      /* max number of trees */
static int qidvers;

static char *disk;      /* default tree name used */
static char *source;        /* default inner device used */
static int sectorsz = Sectorsz; /* default sector size */

static char confstr[Maxconf];   /* textual configuration */


static char cfgstr[] = "fsdev:\n";

static Qid tqid = {Qtop, 0, QTDIR};
static Qid cqid = {Qctl, 0, 0};

static char* tnames[] = {
    [Fmirror]   "mirror",
    [Fcat]      "cat",
    [Finter]    "inter",
    [Fpart]     "part",
};

static Cmdtab configs[] = {
    Fmirror,"mirror",   0,
    Fcat,   "cat",      0,
    Finter, "inter",    0,
    Fpart,  "part",     0,
    Fclear, "clear",    1,
    Fdel,   "del",      2,
    Fdisk,  "disk",     0,
};

static char Egone[] = "device is gone";     /* file has been removed */

static char*
seprintdev(char *s, char *e, Fsdev *mp)
{
    int i;

    if(mp == nil)
        return seprint(s, e, "<null Fsdev>");
    if(mp->type < 0 || mp->type >= nelem(tnames) || tnames[mp->type] == nil)
        return seprint(s, e, "bad device type %d\n", mp->type);

    s = strecpy(s, e, tnames[mp->type]);
    if(mp->tree != &fstree)
        s = seprint(s, e, " %s/%s", mp->tree->name, mp->name);
    else
        s = seprint(s, e, " %s", mp->name);
    for(i = 0; i < mp->ndevs; i++)
        s = seprint(s, e, " %s", mp->inner[i]->iname);
    switch(mp->type){
    case Fmirror:
    case Fcat:
    case Finter:
        s = strecpy(s, e, "\n");
        break;
    case Fpart:
        s = seprint(s, e, " %ulld %ulld\n", mp->start, mp->size);
        break;
    default:
        panic("#k: seprintdev bug");
    }
    return s;
}

static vlong
mkpath(int tree, int devno)
{
    return (tree&0xFFFF)<<16 | devno&0xFFFF;
}

static int
path2treeno(int q)
{
    return q>>16 & 0xFFFF;
}

static int
path2devno(int q)
{
    return q & 0xFFFF;
}

static Tree*
gettree(int i, int mustexist)
{
    dprint("gettree %d\n", i);
    if(i < 0)
        panic("#k: bug: bad tree index %d in gettree", i);
    if(i >= ntrees || trees[i] == nil)
        if(mustexist)
            error(Enonexist);
        else
            return nil;
    return trees[i];
}

static Fsdev*
getdev(Tree *t, int i, int mustexist)
{
    dprint("getdev %d\n", i);
    if(i < 0)
        panic("#k: bug: bad dev index %d in getdev", i);
    if(i >= t->nadevs || t->devs[i] == nil)
        if(mustexist)
            error(Enonexist);
        else
            return nil;
    return t->devs[i];
}

static Fsdev*
path2dev(int q)
{
    Tree    *t;

    dprint("path2dev %ux\n", q);
    t = gettree(path2treeno(q), Mustexist);
    return getdev(t, path2devno(q) - Qfirst, Mustexist);
}

static Tree*
treealloc(char *name)
{
    int i;
    Tree    *t;

    dprint("treealloc %s\n", name);
    for(i = 0; i < nelem(trees); i++)
        if(trees[i] == nil)
            break;
    if(i == nelem(trees))
        return nil;
    t = trees[i] = mallocz(sizeof(Tree), 1);
    if(t == nil)
        return nil;
    if(i == ntrees)
        ntrees++;
    kstrdup(&t->name, name);
    return t;
}

static Tree*
lookuptree(char *name)
{
    int i;

    dprint("lookuptree %s\n", name);
    for(i = 0; i < ntrees; i++)
        if(trees[i] != nil && strcmp(trees[i]->name, name) == 0)
            return trees[i];
    return nil;
}

static Fsdev*
devalloc(Tree *t, char *name)
{
    int i, ndevs;
    Fsdev   *mp, **devs;

    dprint("devalloc %s %s\n", t->name, name);
    mp = mallocz(sizeof(Fsdev), 1);
    if(mp == nil)
        return nil;
    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] == nil)
            break;
    if(i >= t->nadevs){
        if(t->nadevs % Incr == 0){
            ndevs = t->nadevs + Incr;
            devs = realloc(t->devs, ndevs * sizeof(Fsdev*));
            if(devs == nil){
                free(mp);
                return nil;
            }
            t->devs = devs;
        }
        t->devs[t->nadevs] = nil;
        t->nadevs++;
    }
    kstrdup(&mp->name, name);
    mp->vers = ++qidvers;
    mp->tree = t;
    t->devs[i] = mp;
    t->ndevs++;
    return mp;
}

static void
deltree(Tree *t)
{
    int i;

    dprint("deltree %s\n", t->name);
    for(i = 0; i < ntrees; i++)
        if(trees[i] == t){
            if(i > 0){      /* "fs" never goes away */
                free(t->name);
                free(t->devs);
                free(t);
                trees[i] = nil;
            }
            return;
        }
    panic("#k: deltree: bug: tree not found");
}

/*
 * A device is gone and we know that all its users are gone.
 * A tree is gone when all its devices are gone ("fs" is never gone).
 * Must close devices outside locks, so we could nest our own devices.
 */
static void
mdeldev(Fsdev *mp)
{
    int i;
    Inner   *in;
    Tree    *t;

    dprint("deldev %s gone %d ref %uld\n", mp->name, mp->gone, mp->ref);

    mp->gone = 1;
    mp->vers = ++qidvers;

    wlock(&lck);
    t = mp->tree;
    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] == mp){
            t->devs[i] = nil;
            t->ndevs--;
            if(t->ndevs == 0)
                deltree(t);
            break;
        }
    wunlock(&lck);

    free(mp->name);
    for(i = 0; i < mp->ndevs; i++){
        in = mp->inner[i];
        if(in->idev != nil)
            cclose(in->idev);
        free(in->iname);
        free(in);
    }
    if(debug)
        memset(mp, 9, sizeof *mp);  /* poison */
    free(mp);
}

/*
 * Delete one or all devices in one or all trees.
 */
static void
mdelctl(char *tname, char *dname)
{
    int i, alldevs, alltrees, some;
    Fsdev *mp;
    Tree *t;

    dprint("delctl %s\n", dname);
    alldevs = strcmp(dname, "*") == 0;
    alltrees = strcmp(tname, "*") == 0;
    some = 0;
Again:
    wlock(&lck);
    for(i = 0; i < ntrees; i++){
        t = trees[i];
        if(t == nil)
            continue;
        if(alltrees == 0 && strcmp(t->name, tname) != 0)
            continue;
        for(i = 0; i < t->nadevs; i++){
            mp = t->devs[i];
            if(t->devs[i] == nil)
                continue;
            if(alldevs == 0 && strcmp(mp->name, dname) != 0)
                continue;
            /*
             * Careful: must close outside locks and that
             * may change the file tree we are looking at.
             */
            some++;
            mp->gone = 1;
            if(mp->ref == 0){
                incref(mp); /* keep it there */
                wunlock(&lck);
                mdeldev(mp);
                goto Again; /* tree can change */
            }
        }
    }
    wunlock(&lck);
    if(some == 0 && alltrees == 0)
        error(Enonexist);
}

static void
setdsize(Fsdev* mp, vlong *ilen)
{
    int i;
    vlong   inlen;
    Inner   *in;

    dprint("setdsize %s\n", mp->name);
    for (i = 0; i < mp->ndevs; i++){
        in = mp->inner[i];
        in->isize = ilen[i];
        inlen = in->isize;
        switch(mp->type){
        case Finter:
            /* truncate to multiple of Blksize */
            inlen &= ~(Blksize-1);
            in->isize = inlen;
            /* fall through */
        case Fmirror:
            /* use size of smallest inner device */
            if (mp->size == 0 || mp->size > inlen)
                mp->size = inlen;
            break;
        case Fcat:
            mp->size += inlen;
            break;
        case Fpart:
            if(mp->start > inlen)
                error("partition starts after device end");
            if(inlen < mp->start + mp->size){
                print("#k: %s: partition truncated from "
                    "%lld to %lld bytes\n", mp->name,
                    mp->size, inlen - mp->start);
                mp->size = inlen - mp->start;
            }
            break;
        }
    }
    if(mp->type == Finter)
        mp->size *= mp->ndevs;
}

static void
validdevname(Tree *t, char *dname)
{
    int i;

    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] != nil && strcmp(t->devs[i]->name, dname) == 0)
            error(Eexist);
}

static void
parseconfig(char *a, long n, Cmdbuf **cbp, Cmdtab **ctp)
{
    Cmdbuf  *cb;
    Cmdtab  *ct;

    *cbp = cb = parsecmd(a, n);
    *ctp = ct = lookupcmd(cb, configs, nelem(configs));

    cb->f++;            /* skip command */
    cb->nf--;
    switch(ct->index){
    case Fmirror:
    case Fcat:
    case Finter:
        if(cb->nf < 2)
            error("too few arguments for ctl");
        if(cb->nf - 1 > Ndevs)
            error("too many devices in ctl");
        break;
    case Fdisk:
        if(cb->nf < 1 || cb->nf > 3)
            error("ctl usage: disk name [sz dev]");
        break;
    case Fpart:
        if(cb->nf != 4 && (cb->nf != 3 || source == nil))
            error("ctl usage: part new [file] off len");
        break;
    }
}

static void
parsename(char *name, char *disk, char **tree, char **dev)
{
    char *slash;

    slash = strchr(name, '/');
    if(slash == nil){
        if(disk != nil)
            *tree = disk;
        else
            *tree = "fs";
        *dev = name;
    }else{
        *tree = name;
        *slash++ = 0;
        *dev = slash;
    }
    validname(*tree, 0);
    validname(*dev, 0);
}

static int
getattrs(Chan *c, vlong *lenp, int *permp)
{
    uchar   buf[128];   /* old DIRLEN plus a little should be plenty */
    Dir d;
    long    l;

    *lenp = 0;
    *permp = 0;
    l = devtab[c->type]->stat(c, buf, sizeof buf);
    if (l >= 0 && convM2D(buf, l, &d, nil) > 0) {
        *lenp = d.length;
        *permp = d.mode & 0777;
    }
    return l;
}

/*
 * Process a single line of configuration,
 * often of the form "cmd newname idev0 idev1".
 * locking is tricky, because we need a write lock to
 * add/remove devices yet adding/removing them may lead
 * to calls to this driver that require a read lock (when
 * inner devices are also provided by us).
 */
static void
mconfig(char* a, long n)
{
    int i;
    int *iperm;
    vlong   size, start;
    vlong   *ilen;
    char    *tname, *dname, *fakef[4];
    Chan    **idev;
    Cmdbuf  *cb;
    Cmdtab  *ct;
    Fsdev   *mp;
    Inner   *inprv;
    Tree    *t;

    /* ignore comments & empty lines */
    if (*a == '\0' || *a == '#' || *a == '\n')
        return;

    dprint("mconfig\n");
    size = 0;
    start = 0;
    mp = nil;
    cb = nil;
    idev = nil;
    ilen = nil;
    iperm = nil;

    if(waserror()){
        free(cb);
        nexterror();
    }

    parseconfig(a, n, &cb, &ct);
    switch (ct->index) {
    case Fdisk:
        kstrdup(&disk, cb->f[0]);
        if(cb->nf >= 2)
            sectorsz = strtoul(cb->f[1], 0, 0);
        else
            sectorsz = Sectorsz;
        if(cb->nf == 3)
            kstrdup(&source, cb->f[2]);
        else{
            free(source);
            source = nil;
        }
        poperror();
        free(cb);
        return;
    case Fclear:
        poperror();
        free(cb);
        mdelctl("*", "*");      /* del everything */
        return;
    case Fpart:
        if(cb->nf == 3){
            /*
             * got a request in the format of sd(3),
             * pretend we got one in our format.
             * later we change end to be len.
             */
            fakef[0] = cb->f[0];
            fakef[1] = source;
            fakef[2] = cb->f[1];
            fakef[3] = cb->f[2];
            cb->f = fakef;
            cb->nf = 4;
        }
        start = strtoll(cb->f[2], nil, 10);
        size =  strtoll(cb->f[3], nil, 10);
        if(cb->f == fakef)
            size -= start;      /* it was end */
        cb->nf -= 2;
        break;
    }
    parsename(cb->f[0], disk, &tname, &dname);
    for(i = 1; i < cb->nf; i++)
        validname(cb->f[i], 1);

    if(ct->index == Fdel){
        mdelctl(tname, dname);
        poperror();
        free(cb);
        return;
    }

    /*
     * Open all inner devices while we have only a read lock.
     */
    poperror();
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
Fail:
        for(i = 1; i < cb->nf; i++)
            if(idev != nil && idev[i-1] != nil)
                cclose(idev[i]);
        if(mp != nil)
            mdeldev(mp);
        free(idev);
        free(ilen);
        free(iperm);
        free(cb);
        nexterror();
    }
    /* record names, lengths and perms of all named files */
    idev = smalloc(sizeof(Chan*) * Ndevs);
    ilen = smalloc(sizeof(vlong) * Ndevs);
    iperm = smalloc(sizeof(int) * Ndevs);
    for(i = 1; i < cb->nf; i++){
        idev[i-1] = namec(cb->f[i], Aopen, ORDWR, 0);
        getattrs(idev[i-1], &ilen[i-1], &iperm[i-1]);
    }
    poperror();
    runlock(&lck);

    /*
     * Get a write lock and add the device if we can.
     */
    wlock(&lck);
    if(waserror()){
        wunlock(&lck);
        goto Fail;
    }

    t = lookuptree(tname);
    if(t != nil)
        validdevname(t, dname);
    else
        t = treealloc(tname);
    if(t == nil)
        error("no more trees");
    mp = devalloc(t, dname);
    if(mp == nil){
        if(t->ndevs == 0)   /* it was created for us */
            deltree(t); /* but we will not mdeldev() */
        error(Enomem);
    }

    /* construct mp from iname, idev and iperm arrays */
    mp->type = ct->index;
    if(mp->type == Fpart){
        mp->start = start * sectorsz;
        mp->size = size * sectorsz;
    }
    mp->perm = 0666;
    for(i = 1; i < cb->nf; i++){
        inprv = mp->inner[i-1] = mallocz(sizeof(Inner), 1);
        if(inprv == nil)
            error(Enomem);
        mp->ndevs++;
        kstrdup(&inprv->iname, cb->f[i]);
        inprv->idev = idev[i-1];
        idev[i-1] = nil;
        /* use the most restrictive of the inner permissions */
        mp->perm &= iperm[i-1];
    }
    setdsize(mp, ilen);

    poperror();
    wunlock(&lck);
    free(idev);
    free(ilen);
    free(iperm);
    free(cb);
}

static void
rdconf(void)
{
    int mustrd;
    char *c, *e, *p, *s;
    Chan *cc;
    static int configed;

    /* only read config file once */
    if (configed)
        return;
    configed = 1;

    dprint("rdconf\n");
    /* add the std "fs" tree */
    trees[0] = &fstree;
    ntrees++;
    fstree.name = "fs";

    /* identify the config file */
    s = getconf("fsconfig");
    if (s == nil){
        mustrd = 0;
        s = "/dev/sdC0/fscfg";
    } else
        mustrd = 1;

    /* read it */
    cc = nil;
    c = nil;
    if (waserror()){
        if (cc != nil)
            cclose(cc);
        if (c)
            free(c);
        if (!mustrd)
            return;
        nexterror();
    }
    cc = namec(s, Aopen, OREAD, 0);
    devtab[cc->type]->read(cc, confstr, sizeof confstr, 0);
    cclose(cc);
    cc = nil;

    /* validate, copy and erase config; mconfig will repopulate confstr */
    if (strncmp(confstr, cfgstr, sizeof cfgstr - 1) != 0)
        error("bad #k config, first line must be: 'fsdev:\\n'");
    kstrdup(&c, confstr + sizeof cfgstr - 1);
    memset(confstr, 0, sizeof confstr);

    /* process config copy one line at a time */
    for (p = c; p != nil && *p != '\0'; p = e){
        e = strchr(p, '\n');
        if (e == nil)
            e = p + strlen(p);
        else
            e++;
        mconfig(p, e - p);
    }
    USED(cc);       /* until now, can be used in waserror clause */
    poperror();
}

static int
mgen(Chan *c, char*, Dirtab*, int, int i, Dir *dp)
{
    int treeno;
    Fsdev   *mp;
    Qid qid;
    Tree    *t;

    dprint("mgen %#ullx %d\n", c->qid.path, i);
    qid.type = QTDIR;
    qid.vers = 0;
    if(c->qid.path == Qtop){
        if(i == DEVDOTDOT){
            devdir(c, tqid, "#k", 0, eve, DMDIR|0775, dp);
            return 1;
        }
        t = gettree(i, Optional);
        if(t == nil){
            dprint("no\n");
            return -1;
        }
        qid.path = mkpath(i, Qdir);
        devdir(c, qid, t->name, 0, eve, DMDIR|0775, dp);
        return 1;
    }

    treeno = path2treeno(c->qid.path);
    t = gettree(treeno, Optional);
    if(t == nil){
        dprint("no\n");
        return -1;
    }
    if((c->qid.type & QTDIR) != 0){
        if(i == DEVDOTDOT){
            devdir(c, tqid, "#k", 0, eve, DMDIR|0775, dp);
            return 1;
        }
        if(treeno == 0){
            /* take care of #k/fs/ctl */
            if(i == 0){
                devdir(c, cqid, "ctl", 0, eve, 0664, dp);
                return 1;
            }
            i--;
        }
        mp = getdev(t, i, Optional);
        if(mp == nil){
            dprint("no\n");
            return -1;
        }
        qid.type = QTFILE;
        qid.vers = mp->vers;
        qid.path = mkpath(treeno, Qfirst+i);
        devdir(c, qid, mp->name, mp->size, eve, mp->perm, dp);
        return 1;
    }

    if(i == DEVDOTDOT){
        qid.path = mkpath(treeno, Qdir);
        devdir(c, qid, t->name, 0, eve, DMDIR|0775, dp);
        return 1;
    }
    dprint("no\n");
    return -1;
}

static Chan*
mattach(char *spec)
{
    dprint("mattach\n");
    return devattach(fsdevtab.dc, spec);
}

static Walkqid*
mwalk(Chan *c, Chan *nc, char **name, int nname)
{
    Walkqid *wq;

    rdconf();

    dprint("mwalk %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    wq = devwalk(c, nc, name, nname, 0, 0, mgen);
    poperror();
    runlock(&lck);
    return wq;
}

static int
mstat(Chan *c, uchar *db, int n)
{
    int p;
    Dir d;
    Fsdev   *mp;
    Qid q;
    Tree    *t;

    dprint("mstat %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    p = c->qid.path;
    memset(&d, 0, sizeof d);
    switch(p){
    case Qtop:
        devdir(c, tqid, "#k", 0, eve, DMDIR|0775, &d);
        break;
    case Qctl:
        devdir(c, cqid, "ctl", 0, eve, 0664, &d);
        break;
    default:
        t = gettree(path2treeno(p), Mustexist);
        if(c->qid.type & QTDIR)
            devdir(c, c->qid, t->name, 0, eve, DMDIR|0775, &d);
        else{
            mp = getdev(t, path2devno(p) - Qfirst, Mustexist);
            q = c->qid;
            q.vers = mp->vers;
            devdir(c, q, mp->name, mp->size, eve, mp->perm, &d);
        }
    }
    n = convD2M(&d, db, n);
    if (n == 0)
        error(Ebadarg);
    poperror();
    runlock(&lck);
    return n;
}

static Chan*
mopen(Chan *c, int omode)
{
    int q;
    Fsdev   *mp;

    dprint("mopen %llux\n", c->qid.path);
    if((c->qid.type & QTDIR) && omode != OREAD)
        error(Eperm);
    if(c->qid.path != Qctl && (c->qid.type&QTDIR) == 0){
        rlock(&lck);
        if(waserror()){
            runlock(&lck);
            nexterror();
        }
        q = c->qid.path;
        mp = path2dev(q);
        if(mp->gone)
            error(Egone);
        devpermcheck(eve, mp->perm, omode);
        incref(mp);
        poperror();
        runlock(&lck);
    }
    /*
     * Our mgen does not return the info for the qid
     * but only for its children. Don't use devopen here.
     */
    c->offset = 0;
    c->mode = openmode(omode & ~OTRUNC);
    c->flag |= COPEN;
    return c;
}

static void
mclose(Chan *c)
{
    int mustdel, q;
    Fsdev   *mp;

    dprint("mclose %llux\n", c->qid.path);
    if(c->qid.type & QTDIR || !(c->flag & COPEN))
        return;
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    mustdel = 0;
    mp = nil;
    q = c->qid.path;
    if(q == Qctl){
        free(disk);
        disk = nil; /* restore defaults */
        free(source);
        source = nil;
        sectorsz = Sectorsz;
    }else{
        mp = path2dev(q);
        if(mp->gone != 0 && mp->ref == 1)
            mustdel = 1;
        else
            decref(mp);
    }
    poperror();
    runlock(&lck);
    if(mustdel)
        mdeldev(mp);
}

static long
io(Fsdev *mp, Inner *in, int isread, void *a, long l, vlong off)
{
    long wl;
    Chan    *mc;

    mc = in->idev;
    if(mc == nil)
        error(Egone);
    if (waserror()) {
        print("#k: %s: byte %,lld count %ld (of #k/%s): %s error: %s\n",
            in->iname, off, l, mp->name, (isread? "read": "write"),
            (up && up->errstr? up->errstr: ""));
        nexterror();
    }
    if (isread)
        wl = devtab[mc->type]->read(mc, a, l, off);
    else
        wl = devtab[mc->type]->write(mc, a, l, off);
    poperror();
    return wl;
}

/* NB: a transfer could span multiple inner devices */
static long
catio(Fsdev *mp, int isread, void *a, long n, vlong off)
{
    int i;
    long    l, res;
    Inner   *in;

    if(debug)
        print("catio %d %p %ld %lld\n", isread, a, n, off);
    res = n;
    for (i = 0; n > 0 && i < mp->ndevs; i++){
        in = mp->inner[i];
        if (off >= in->isize){
            off -= in->isize;
            continue;       /* not there yet */
        }
        if (off + n > in->isize)
            l = in->isize - off;
        else
            l = n;
        if(debug)
            print("\tdev %d %p %ld %lld\n", i, a, l, off);

        if (io(mp, in, isread, a, l, off) != l)
            error(Eio);

        a = (char*)a + l;
        off = 0;
        n -= l;
    }
    if(debug)
        print("\tres %ld\n", res - n);
    return res - n;
}

static long
interio(Fsdev *mp, int isread, void *a, long n, vlong off)
{
    int i;
    long    boff, res, l, wl, wsz;
    vlong   woff, blk, mblk;

    blk  = off / Blksize;
    boff = off % Blksize;
    wsz  = Blksize - boff;
    res = n;
    while(n > 0){
        mblk = blk / mp->ndevs;
        i    = blk % mp->ndevs;
        woff = mblk*Blksize + boff;
        if (n > wsz)
            l = wsz;
        else
            l = n;

        wl = io(mp, mp->inner[i], isread, a, l, woff);
        if (wl != l)
            error(Eio);

        blk++;
        boff = 0;
        wsz = Blksize;
        a = (char*)a + l;
        n -= l;
    }
    return res;
}

static char*
seprintconf(char *s, char *e)
{
    int i, j;
    Tree    *t;

    *s = 0;
    for(i = 0; i < ntrees; i++){
        t = trees[i];
        if(t != nil)
            for(j = 0; j < t->nadevs; j++)
                if(t->devs[j] != nil)
                    s = seprintdev(s, e, t->devs[j]);
    }
    return s;
}

static long
mread(Chan *c, void *a, long n, vlong off)
{
    int i, retry;
    long    l, res;
    Fsdev   *mp;
    Tree    *t;

    dprint("mread %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    res = -1;
    if(c->qid.type & QTDIR){
        res = devdirread(c, a, n, 0, 0, mgen);
        goto Done;
    }
    if(c->qid.path == Qctl){
        seprintconf(confstr, confstr + sizeof(confstr));
        res = readstr((long)off, a, n, confstr);
        goto Done;
    }

    t = gettree(path2treeno(c->qid.path), Mustexist);
    mp = getdev(t, path2devno(c->qid.path) - Qfirst, Mustexist);

    if(off >= mp->size){
        res = 0;
        goto Done;
    }
    if(off + n > mp->size)
        n = mp->size - off;
    if(n == 0){
        res = 0;
        goto Done;
    }

    switch(mp->type){
    case Fcat:
        res = catio(mp, Isread, a, n, off);
        break;
    case Finter:
        res = interio(mp, Isread, a, n, off);
        break;
    case Fpart:
        res = io(mp, mp->inner[0], Isread, a, n, mp->start + off);
        break;
    case Fmirror:
        retry = 0;
        do {
            if (retry > 0) {
                print("#k/%s: retry %d read for byte %,lld "
                    "count %ld: %s\n", mp->name, retry, off,
                    n, (up && up->errstr? up->errstr: ""));
                /*
                 * pause before retrying in case it's due to
                 * a transient bus or controller problem.
                 */
                tsleep(&up->sleepr, returnfalse, 0, Retrypause);
            }
            for (i = 0; i < mp->ndevs; i++){
                if (waserror())
                    continue;
                l = io(mp, mp->inner[i], Isread, a, n, off);
                poperror();
                if (l >= 0){
                    res = l;
                    break;      /* read a good copy */
                }
            }
        } while (i == mp->ndevs && ++retry <= Maxretries);
        if (retry > Maxretries) {
            /* no mirror had a good copy of the block */
            print("#k/%s: byte %,lld count %ld: CAN'T READ "
                "from mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
            error(Eio);
        } else if (retry > 0)
            print("#k/%s: byte %,lld count %ld: retry read OK "
                "from mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
        break;
    }
Done:
    poperror();
    runlock(&lck);
    return res;
}

static long
mwrite(Chan *c, void *a, long n, vlong off)
{
    int i, allbad, anybad, retry;
    long    l, res;
    Fsdev   *mp;
    Tree    *t;

    dprint("mwrite %llux\n", c->qid.path);
    if (c->qid.type & QTDIR)
        error(Eisdir);
    if (c->qid.path == Qctl){
        mconfig(a, n);
        return n;
    }

    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }

    t = gettree(path2treeno(c->qid.path), Mustexist);
    mp = getdev(t, path2devno(c->qid.path) - Qfirst, Mustexist);

    if(off >= mp->size){
        res = 0;
        goto Done;
    }
    if(off + n > mp->size)
        n = mp->size - off;
    if(n == 0){
        res = 0;
        goto Done;
    }
    res = n;
    switch(mp->type){
    case Fcat:
        res = catio(mp, Iswrite, a, n, off);
        break;
    case Finter:
        res = interio(mp, Iswrite, a, n, off);
        break;
    case Fpart:
        res = io(mp, mp->inner[0], Iswrite, a, n, mp->start + off);
        if (res != n)
            error(Eio);
        break;
    case Fmirror:
        retry = 0;
        do {
            if (retry > 0) {
                print("#k/%s: retry %d write for byte %,lld "
                    "count %ld: %s\n", mp->name, retry, off,
                    n, (up && up->errstr? up->errstr: ""));
                /*
                 * pause before retrying in case it's due to
                 * a transient bus or controller problem.
                 */
                tsleep(&up->sleepr, returnfalse, 0, Retrypause);
            }
            allbad = 1;
            anybad = 0;
            for (i = mp->ndevs - 1; i >= 0; i--){
                if (waserror()) {
                    anybad = 1;
                    continue;
                }
                l = io(mp, mp->inner[i], Iswrite, a, n, off);
                poperror();
                if (l == n)
                    allbad = 0; /* wrote a good copy */
                else
                    anybad = 1;
            }
        } while (anybad && ++retry <= Maxretries);
        if (allbad) {
            /* no mirror took a good copy of the block */
            print("#k/%s: byte %,lld count %ld: CAN'T WRITE "
                "to mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
            error(Eio);
        } else if (retry > 0)
            print("#k/%s: byte %,lld count %ld: retry wrote OK "
                "to mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));

        break;
    }
Done:
    poperror();
    runlock(&lck);
    return res;
}

<<global fsdevtab>>
@


\subsection*{[[init/386/apbootstrap.s]]}

<<apbootstrap.s>>=
/*
 * Start an Application Processor. This must be placed on a 4KB boundary
 * somewhere in the 1st MB of conventional memory (APBOOTSTRAP). However,
 * due to some shortcuts below it's restricted further to within the 1st
 * 64KB. The AP starts in real-mode, with
 *   CS selector set to the startup memory address/16;
 *   CS base set to startup memory address;
 *   CS limit set to 64KB;
 *   CPL and IP set to 0.
 */
#include "mem.h"

//TODO: mv in x16.h? or just case of instructions not handled by 8[al]?
#define NOP             BYTE $0x90              /* NOP */
#define LGDT(gdtptr)    BYTE $0x0F;             /* LGDT */                      \
                        BYTE $0x01; BYTE $0x16;                                 \
                        WORD $gdtptr
#define FARJUMP16(s, o) BYTE $0xEA;             /* far jump to ptr16:16 */      \
                        WORD $o; WORD $s;                                       \
                        NOP; NOP; NOP
#define FARJUMP32(s, o) BYTE $0x66;             /* far jump to ptr32:16 */      \
                        BYTE $0xEA; LONG $o; WORD $s

#define DELAY           BYTE $0xEB;             /* JMP .+2 */                   \
                        BYTE $0x00
#define INVD            BYTE $0x0F; BYTE $0x08
#define WBINVD          BYTE $0x0F; BYTE $0x09

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. Note that these are assembler-specific hence
 * the '<<2'.
 */
#define PDO(a)          (((((a))>>22) & 0x03FF)<<2)
#define PTO(a)          (((((a))>>12) & 0x03FF)<<2)

TEXT apbootstrap(SB), $0
        FARJUMP16(0, _apbootstrap(SB))
TEXT _apvector(SB), $0                          /* address APBOOTSTRAP+0x08 */
        LONG $0
TEXT _appdb(SB), $0                             /* address APBOOTSTRAP+0x0C */
        LONG $0
TEXT _apapic(SB), $0                            /* address APBOOTSTRAP+0x10 */
        LONG $0
TEXT _apbootstrap(SB), $0                       /* address APBOOTSTRAP+0x14 */
        MOVW    CS, AX
        MOVW    AX, DS                          /* initialise DS */

        LGDT(gdtptr(SB))                        /* load a basic gdt */

        MOVL    CR0, AX
        ORL     $1, AX
        MOVL    AX, CR0                         /* turn on protected mode */
        DELAY                                   /* JMP .+2 */

        BYTE $0xB8; WORD $SELECTOR(1, SELGDT, 0)/* MOVW $SELECTOR(1, SELGDT, 0), AX */
        MOVW    AX, DS
        MOVW    AX, ES
        MOVW    AX, FS
        MOVW    AX, GS
        MOVW    AX, SS

        FARJUMP32(SELECTOR(2, SELGDT, 0), _ap32-KZERO(SB))

/*
 * For Pentiums and higher, the code that enables paging must come from
 * pages that are identity mapped. 
 * To this end double map KZERO at virtual 0 and undo the mapping once virtual
 * nirvana has been obtained.
 */
TEXT _ap32(SB), $0
        MOVL    _appdb-KZERO(SB), CX            /* physical address of PD */
        MOVL    (PDO(KZERO))(CX), DX            /* double-map KZERO at 0 */
        MOVL    DX, (PDO(0))(CX)
        MOVL    CX, CR3                         /* load and flush the mmu */

        MOVL    CR0, DX
        ORL     $0x80010000, DX                 /* PG|WP */
        ANDL    $~0x6000000A, DX                /* ~(CD|NW|TS|MP) */

        MOVL    $_appg(SB), AX
        MOVL    DX, CR0                         /* turn on paging */
        JMP*    AX

TEXT _appg(SB), $0
        MOVL    CX, AX                          /* physical address of PD */
        ORL     $KZERO, AX
        MOVL    $0, (PDO(0))(AX)                /* undo double-map of KZERO at 0 */
        MOVL    CX, CR3                         /* load and flush the mmu */

        MOVL    $(CPUADDR+CPUSIZE-4), SP

        MOVL    $0, AX
        PUSHL   AX
        POPFL

        MOVL    _apapic(SB), AX
        MOVL    AX, (SP)
        MOVL    _apvector(SB), AX
        CALL*   AX
_aphalt:
        HLT
        JMP     _aphalt

TEXT gdt(SB), $0
        LONG $0x0000; LONG $0
        LONG $0xFFFF; LONG $(SEGG|SEGB|(0xF<<16)|SEGP|SEGPL(0)|SEGDATA|SEGW)
        LONG $0xFFFF; LONG $(SEGG|SEGD|(0xF<<16)|SEGP|SEGPL(0)|SEGEXEC|SEGR)
TEXT gdtptr(SB), $0
        WORD    $(3*8-1)
        LONG    $gdt-KZERO(SB)
@



\subsection*{[[init/386/l_fp.s]]}


\subsection*{[[processes/386/apic.c]]}


<<[[Cpu]] [[Arch]] other fields>>=
Lock  apictimerlock;
@


<<apic.c>>=
<<kernel basic includes>>

#include "io.h"
#include "mp.h"

enum {                  /* Local APIC registers */
    LapicID     = 0x0020,   /* ID */
    LapicVER    = 0x0030,   /* Version */
    LapicTPR    = 0x0080,   /* Task Priority */
    LapicAPR    = 0x0090,   /* Arbitration Priority */
    LapicPPR    = 0x00A0,   /* Processor Priority */
    LapicEOI    = 0x00B0,   /* EOI */
    LapicLDR    = 0x00D0,   /* Logical Destination */
    LapicDFR    = 0x00E0,   /* Destination Format */
    LapicSVR    = 0x00F0,   /* Spurious Interrupt Vector */
    LapicISR    = 0x0100,   /* Interrupt Status (8 registers) */
    LapicTMR    = 0x0180,   /* Trigger Mode (8 registers) */
    LapicIRR    = 0x0200,   /* Interrupt Request (8 registers) */
    LapicESR    = 0x0280,   /* Error Status */
    LapicICRLO  = 0x0300,   /* Interrupt Command */
    LapicICRHI  = 0x0310,   /* Interrupt Command [63:32] */
    LapicTIMER  = 0x0320,   /* Local Vector Table 0 (TIMER) */
    LapicPCINT  = 0x0340,   /* Performance Counter LVT */
    LapicLINT0  = 0x0350,   /* Local Vector Table 1 (LINT0) */
    LapicLINT1  = 0x0360,   /* Local Vector Table 2 (LINT1) */
    LapicERROR  = 0x0370,   /* Local Vector Table 3 (ERROR) */
    LapicTICR   = 0x0380,   /* Timer Initial Count */
    LapicTCCR   = 0x0390,   /* Timer Current Count */
    LapicTDCR   = 0x03E0,   /* Timer Divide Configuration */
};

enum {                  /* LapicSVR */
    LapicENABLE = 0x00000100,   /* Unit Enable */
    LapicFOCUS  = 0x00000200,   /* Focus Processor Checking Disable */
};

enum {                  /* LapicICRLO */
                    /* [14] IPI Trigger Mode Level (RW) */
    LapicDEASSERT   = 0x00000000,   /* Deassert level-sensitive interrupt */
    LapicASSERT = 0x00004000,   /* Assert level-sensitive interrupt */

                    /* [17:16] Remote Read Status */
    LapicINVALID    = 0x00000000,   /* Invalid */
    LapicWAIT   = 0x00010000,   /* In-Progress */
    LapicVALID  = 0x00020000,   /* Valid */

                    /* [19:18] Destination Shorthand */
    LapicFIELD  = 0x00000000,   /* No shorthand */
    LapicSELF   = 0x00040000,   /* Self is single destination */
    LapicALLINC = 0x00080000,   /* All including self */
    LapicALLEXC = 0x000C0000,   /* All Excluding self */
};

enum {                  /* LapicESR */
    LapicSENDCS = 0x00000001,   /* Send CS Error */
    LapicRCVCS  = 0x00000002,   /* Receive CS Error */
    LapicSENDACCEPT = 0x00000004,   /* Send Accept Error */
    LapicRCVACCEPT  = 0x00000008,   /* Receive Accept Error */
    LapicSENDVECTOR = 0x00000020,   /* Send Illegal Vector */
    LapicRCVVECTOR  = 0x00000040,   /* Receive Illegal Vector */
    LapicREGISTER   = 0x00000080,   /* Illegal Register Address */
};

enum {                  /* LapicTIMER */
                    /* [17] Timer Mode (RW) */
    LapicONESHOT    = 0x00000000,   /* One-shot */
    LapicPERIODIC   = 0x00020000,   /* Periodic */

                    /* [19:18] Timer Base (RW) */
    LapicCLKIN  = 0x00000000,   /* use CLKIN as input */
    LapicTMBASE = 0x00040000,   /* use TMBASE */
    LapicDIVIDER    = 0x00080000,   /* use output of the divider */
};

enum {                  /* LapicTDCR */
    LapicX2     = 0x00000000,   /* divide by 2 */
    LapicX4     = 0x00000001,   /* divide by 4 */
    LapicX8     = 0x00000002,   /* divide by 8 */
    LapicX16    = 0x00000003,   /* divide by 16 */
    LapicX32    = 0x00000008,   /* divide by 32 */
    LapicX64    = 0x00000009,   /* divide by 64 */
    LapicX128   = 0x0000000A,   /* divide by 128 */
    LapicX1     = 0x0000000B,   /* divide by 1 */
};

static ulong* lapicbase;

struct Lapictimer
{
    uvlong  hz;
    ulong   max;
    ulong   min;
    ulong   div;
};

struct Lapictimer lapictimer;

static ulong
lapicr(int r)
{
    if(lapicbase == 0)
        panic("lapicr: no lapic");
    return *(lapicbase+(r/sizeof(*lapicbase)));
}

static void
lapicw(int r, ulong data)
{
    if(lapicbase == 0)
        panic("lapicw: no lapic");
    *(lapicbase+(r/sizeof(*lapicbase))) = data;
    data = *(lapicbase+(LapicID/sizeof(*lapicbase)));
    USED(data);
}

void
lapiconline(void)
{
    /*
     * Reload the timer to de-synchronise the processors,
     * then lower the task priority to allow interrupts to be
     * accepted by the APIC.
     */
    microdelay((TK2MS(1)*1000/conf.ncpu) * cpu->cpuno);
    lapicw(LapicTICR, lapictimer.max);
    lapicw(LapicTIMER, LapicCLKIN|LapicPERIODIC|(VectorPIC+IrqTIMER));

    lapicw(LapicTPR, 0);
}

/*
 *  use the i8253 clock to figure out our lapic timer rate.
 */
static void
lapictimerinit(void)
{
    uvlong x, v, hz;

    v = cpu->cpuhz/1000;
    lapicw(LapicTDCR, LapicX1);
    lapicw(LapicTIMER, ApicIMASK|LapicCLKIN|LapicONESHOT|(VectorPIC+IrqTIMER));

    if(lapictimer.hz == 0ULL){
        x = fastticks(&hz);
        x += hz/10;
        lapicw(LapicTICR, 0xffffffff);
        do{
            v = fastticks(nil);
        }while(v < x);

        lapictimer.hz = (0xffffffffUL-lapicr(LapicTCCR))*10;
        lapictimer.max = lapictimer.hz/HZ;
        lapictimer.min = lapictimer.hz/(100*HZ);

        if(lapictimer.hz > hz-(hz/10)){
            if(lapictimer.hz > hz+(hz/10))
                panic("lapic clock %lld > cpu clock > %lld\n",
                    lapictimer.hz, hz);
            lapictimer.hz = hz;
        }
        assert(lapictimer.hz != 0);
        lapictimer.div = hz/lapictimer.hz;
    }
}

void
lapicinit(Apic* apic)
{
    ulong dfr, ldr, lvt;

    if(lapicbase == 0)
        lapicbase = apic->addr;
    if(lapicbase == 0) {
        print("lapicinit: no lapic\n");
        return;
    }

    /*
     * These don't really matter in Physical mode;
     * set the defaults anyway.
     */
    if(strncmp(cpu->cpuidid, "AuthenticAMD", 12) == 0)
        dfr = 0xf0000000;
    else
        dfr = 0xffffffff;
    ldr = 0x00000000;

    lapicw(LapicDFR, dfr);
    lapicw(LapicLDR, ldr);
    lapicw(LapicTPR, 0xff);
    lapicw(LapicSVR, LapicENABLE|(VectorPIC+IrqSPURIOUS));

    lapictimerinit();

    /*
     * Some Pentium revisions have a bug whereby spurious
     * interrupts are generated in the through-local mode.
     */
    switch(cpu->cpuidax & 0xFFF){
    case 0x526:             /* stepping cB1 */
    case 0x52B:             /* stepping E0 */
    case 0x52C:             /* stepping cC0 */
        wrmsr(0x0E, 1<<14);     /* TR12 */
        break;
    }

    /*
     * Set the local interrupts. It's likely these should just be
     * masked off for SMP mode as some Pentium Pros have problems if
     * LINT[01] are set to ExtINT.
     * Acknowledge any outstanding interrupts.
    lapicw(LapicLINT0, apic->lintr[0]);
    lapicw(LapicLINT1, apic->lintr[1]);
     */
    lapiceoi(0);

    lvt = (lapicr(LapicVER)>>16) & 0xFF;
    if(lvt >= 4)
        lapicw(LapicPCINT, ApicIMASK|(VectorPIC+IrqPCINT));
    lapicw(LapicERROR, VectorPIC+IrqERROR);
    lapicw(LapicESR, 0);
    lapicr(LapicESR);

    /*
     * Issue an INIT Level De-Assert to synchronise arbitration ID's.
     */
    lapicw(LapicICRHI, 0);
    lapicw(LapicICRLO, LapicALLINC|ApicLEVEL|LapicDEASSERT|ApicINIT);
    while(lapicr(LapicICRLO) & ApicDELIVS)
        ;

    /*
     * Do not allow acceptance of interrupts until all initialisation
     * for this processor is done. For the bootstrap processor this can be
     * early during initialisation. For the application processors this should
     * be after the bootstrap processor has lowered priority and is accepting
     * interrupts.
    lapicw(LapicTPR, 0);
     */
}

void
lapicstartap(Apic* apic, int v)
{
    int i;
    ulong crhi;

    /* make apic's processor do a warm reset */
    crhi = apic->apicno<<24;
    lapicw(LapicICRHI, crhi);
    lapicw(LapicICRLO, LapicFIELD|ApicLEVEL|LapicASSERT|ApicINIT);
    microdelay(200);
    lapicw(LapicICRLO, LapicFIELD|ApicLEVEL|LapicDEASSERT|ApicINIT);
    delay(10);

    /* assumes apic is not an 82489dx */
    for(i = 0; i < 2; i++){
        lapicw(LapicICRHI, crhi);
        /* make apic's processor start at v in real mode */
        lapicw(LapicICRLO, LapicFIELD|ApicEDGE|ApicSTARTUP|(v/BY2PG));
        microdelay(200);
    }
}

void
lapicerror(Ureg*, void*)
{
    ulong esr;

    lapicw(LapicESR, 0);
    esr = lapicr(LapicESR);
    switch(cpu->cpuidax & 0xFFF){
    case 0x526:             /* stepping cB1 */
    case 0x52B:             /* stepping E0 */
    case 0x52C:             /* stepping cC0 */
        return;
    }
    print("cpu%d: lapicerror: 0x%8.8luX\n", cpu->cpuno, esr);
}

void
lapicspurious(Ureg*, void*)
{
    print("cpu%d: lapicspurious\n", cpu->cpuno);
}

int
lapicisr(int v)
{
    ulong isr;

    isr = lapicr(LapicISR + (v/32));

    return isr & (1<<(v%32));
}

int
lapiceoi(int v)
{
    lapicw(LapicEOI, 0);

    return v;
}

void
lapicicrw(ulong hi, ulong lo)
{
    lapicw(LapicICRHI, hi);
    lapicw(LapicICRLO, lo);
}

void
ioapicrdtr(Apic* apic, int sel, int* hi, int* lo)
{
    ulong *iowin;

    iowin = apic->addr+(0x10/sizeof(ulong));
    sel = IoapicRDT + 2*sel;

    lock(apic);
    *apic->addr = sel+1;
    if(hi)
        *hi = *iowin;
    *apic->addr = sel;
    if(lo)
        *lo = *iowin;
    unlock(apic);
}

void
ioapicrdtw(Apic* apic, int sel, int hi, int lo)
{
    ulong *iowin;

    iowin = apic->addr+(0x10/sizeof(ulong));
    sel = IoapicRDT + 2*sel;

    lock(apic);
    *apic->addr = sel+1;
    *iowin = hi;
    *apic->addr = sel;
    *iowin = lo;
    unlock(apic);
}

void
ioapicinit(Apic* apic, int apicno)
{
    int hi, lo, v;
    ulong *iowin;

    /*
     * Initialise the I/O APIC.
     * The MultiProcessor Specification says it is the responsibility
     * of the O/S to set the APIC id.
     * Make sure interrupts are all masked off for now.
     */
    iowin = apic->addr+(0x10/sizeof(ulong));
    lock(apic);
    *apic->addr = IoapicVER;
    apic->mre = (*iowin>>16) & 0xFF;

    *apic->addr = IoapicID;
    *iowin = apicno<<24;
    unlock(apic);

    hi = 0;
    lo = ApicIMASK;
    for(v = 0; v <= apic->mre; v++)
        ioapicrdtw(apic, v, hi, lo);
}

void
lapictimerset(uvlong next)
{
    vlong period;
    int x;

    x = splhi();
    lock(&cpu->apictimerlock);

    period = lapictimer.max;
    if(next != 0){
        period = next - fastticks(nil);
        if (lapictimer.div == 0)
            panic("lapictimerset: zero lapictimer.div");
        period /= lapictimer.div;

        if(period < lapictimer.min)
            period = lapictimer.min;
        else if(period > lapictimer.max - lapictimer.min)
            period = lapictimer.max;
    }
    lapicw(LapicTICR, period);

    unlock(&cpu->apictimerlock);
    splx(x);
}

void
lapicclock(Ureg *u, void*)
{
    /*
     * since the MTRR updates need to be synchronized across processors,
     * we want to do this within the clock tick.
     */
    //mtrrclock(); disabled

    timerintr(u, 0);
}

void
lapicintron(void)
{
    lapicw(LapicTPR, 0);
}

void
lapicintroff(void)
{
    lapicw(LapicTPR, 0xFF);
}

@

%//void
%//lapicnmienable(void)
%//{
%//  /*
%//   * On the one hand the manual says the vector information
%//   * is ignored if the delivery mode is NMI, and on the other
%//   * a "Receive Illegal Vector" should be generated for a
%//   * vector in the range 0 through 15.
%//   * Some implementations generate the error interrupt if the
%//   * NMI vector is invalid, so always give a valid value.
%//   */
%//  if (lapicbase)
%//      lapicw(LapicPCINT, ApicNMI|(VectorPIC+IrqPCINT));
%//  else
%//      print("lapicnmienable: no lapic\n");
%//}
%
%//void
%//lapicnmidisable(void)
%//{
%//  if (lapicbase)
%//      lapicw(LapicPCINT, ApicIMASK|(VectorPIC+IrqPCINT));
%//  else
%//      print("lapicnmidisable: no lapic\n");
%//}


\subsection*{[[processes/386/archmp.c]]}

<<archmp.c forward decl>>=
// forward decl, mutual recursivity between archmp and identity
PCArch archmp;
@


<<global archmp>>=
PCArch archmp = {
    .id=        "_MP_", 
    .ident=     identify,
    .reset=     mpshutdown,
    .intrinit=  mpinit,
    .intrenable=    mpintrenable,
    .intron=    lapicintron,
    .introff=   lapicintroff,
    .fastclock= i8253read,
    .timerset=  lapictimerset,
    .resetothers=   mpresetothers,
};
@

<<[[Cpu]] [[Arch]] other fields>>=
uvlong tscticks;
@


<<function syncclock>>=
// actually not a clock callback even though finish in clock
void
syncclock(void)
{
    uvlong x;

    if(arch->fastclock != tscticks)
        return;

    if(cpu->cpuno == 0){
        wrmsr(0x10, 0);
        cpu->tscticks = 0;
    } else {
        x = CPUS(0)->tscticks;
        while(x == CPUS(0)->tscticks)
            ;
        wrmsr(0x10, CPUS(0)->tscticks);
        cycles(&cpu->tscticks);
    }
}
@



<<function sigsearch>>=
void*
sigsearch(char* signature)
{
    uintptr p;
    uchar *bda;
    void *r;

    /*
     * Search for the data structure:
     * 1) within the first KiB of the Extended BIOS Data Area (EBDA), or
     * 2) within the last KiB of system base memory if the EBDA segment
     *    is undefined, or
     * 3) within the BIOS ROM address space between 0xf0000 and 0xfffff
     *    (but will actually check 0xe0000 to 0xfffff).
     */
    bda = BIOSSEG(0x40);
    if(memcmp(KADDR(0xfffd9), "EISA", 4) == 0){
        if((p = (bda[0x0f]<<8)|bda[0x0e]) != 0){
            if((r = sigscan(BIOSSEG(p), 1024, signature)) != nil)
                return r;
        }
    }

    if((p = ((bda[0x14]<<8)|bda[0x13])*1024) != 0){
        if((r = sigscan(KADDR(p-1024), 1024, signature)) != nil)
            return r;
    }
    /* hack for virtualbox: look in KiB below 0xa0000 */
    if((r = sigscan(KADDR(0xa0000-1024), 1024, signature)) != nil)
        return r;

    return sigscan(BIOSSEG(0xe000), 0x20000, signature);
}
@

<<function sigscan>>=
static void*
sigscan(uchar* addr, int len, char* signature)
{
    int sl;
    uchar *e, *p;

    e = addr+len;
    sl = strlen(signature);
    for(p = addr; p+sl < e; p += 16)
        if(memcmp(p, signature, sl) == 0)
            return p;
    return nil;
}
@


<<archmp.c>>=
<<kernel basic includes>>
#include "io.h"
#include "mp.h"

_MP_ *_mp_;

<<archmp.c forward decl>>


uvlong
tscticks(uvlong *hz)
{
    if(hz != nil)
        *hz = cpu->cpuhz;

    cycles(&cpu->tscticks);   /* Uses the rdtsc instruction */
    return cpu->tscticks;
}

static void
mpresetothers(void)
{
    /*
     * INIT all excluding self.
     */
    lapicicrw(0, 0x000C0000|ApicINIT);
}

int
identify(void)
{
    char *cp;
    PCMP *pcmp;
    uchar *p, sum;
    ulong length;

    if((cp = getconf("*nomp")) != nil && strtol(cp, 0, 0) != 0)
        return 1;

    /*
     * Search for an MP configuration table. For now,
     * don't accept the default configurations (physaddr == 0).
     * Check for correct signature, calculate the checksum and,
     * if correct, check the version.
     * To do: check extended table checksum.
     */
    if((_mp_ = sigsearch("_MP_")) == 0 || _mp_->physaddr == 0) {
        /*
         * we can easily get processor info from acpi, but
         * interrupt routing, etc. would require interpreting aml.
         */
        print("archmp: no mp table found, assuming uniprocessor\n");
        return 1;
    }

    if (0)
        iprint("mp physaddr %#lux\n", _mp_->physaddr);
    pcmp = KADDR(_mp_->physaddr);
    if(memcmp(pcmp, "PCMP", 4) != 0) {
        print("archmp: mp table has bad magic");
        return 1;
    }

    length = pcmp->length;
    sum = 0;
    for(p = (uchar*)pcmp; length; length--)
        sum += *p++;

    if(sum || (pcmp->version != 1 && pcmp->version != 4))
        return 1;

    if(cpuserver && cpu->havetsc)
        archmp.fastclock = tscticks;
    return 0;
}

<<global archmp>>


//Lock mpsynclock;

<<function syncclock>>
@


\subsection*{[[processes/386/mp.c]]}

<<enum vector cases>>=
    VectorLAPIC = VectorPIC+16, /* local APIC interrupts */
    VectorAPIC  = 65,   /* external APIC interrupts */
    MaxVectorAPIC = 255,
@

<<function archrevert>>=
void
archrevert(void)
{
    arch = &archgeneric;
}
@


<<[[Cpu]] [[Arch]] other fields>>=
vlong mtrrcap;
vlong mtrrdef;
vlong mtrrfix[11];
vlong mtrrvar[32];    /* 256 max. */
@ 

<<mp.c debugging macro>>=
//#define dprint(...)   if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
#define dprint if(mpdebug) print
int mpdebug;
@ 


<<[[Active]] other fields>>=
bool main_reached_sched;/* lets the added processors continue to schedinit*/
@
% main_reached_sched was called thunderbirdsareago

<<[[main()]] before schedinit()>>=
active.main_reached_sched = true;
@


<<mp.c>>=
<<kernel basic includes>>

#include "io.h"
#include "mp.h"

#include "apbootstrap.h"

#include <ureg.h>

<<mp.c debugging macro>>

/* from mpacpi.c */
extern Apic *bootapic;

extern void (*mpacpifunc)(void);

static PCMP* mppcmp;
static Bus* mpbus;
static Bus* mpbuslast;
static int mpisabus = -1;
static int mpeisabus = -1;
extern int i8259elcr;           /* mask of level-triggered interrupts */
/* static */ Apic mpapic[MaxAPICNO+1];
/* static */ int cpuno2apicno[MaxAPICNO+1];    /* inverse map: cpuno -> APIC ID */
/* static */ Apic ioapic[MaxAPICNO+1];
static Ref mpvnoref;            /* unique vector assignment */
static int mpcpuno = 1;
static Lock mpphysidlock;
static int mpphysid;

static char* buses[] = {
    "CBUSI ",
    "CBUSII",
    "EISA  ",
    "FUTURE",
    "INTERN",
    "ISA   ",
    "MBI   ",
    "MBII  ",
    "MCA   ",
    "MPI   ",
    "MPSA  ",
    "NUBUS ",
    "PCI   ",
    "PCMCIA",
    "TC    ",
    "VL    ",
    "VME   ",
    "XPRESS",
    0,
};

static Apic*
mkprocessor(PCMPprocessor* p)
{
    int apicno;
    Apic *apic;

    apicno = p->apicno;
    if(!(p->flags & PcmpEN) || apicno > MaxAPICNO)
        return 0;

    apic = &mpapic[apicno];
    apic->type = PcmpPROCESSOR;
    apic->apicno = apicno;
    apic->flags = p->flags;
    apic->lintr[0] = ApicIMASK;
    apic->lintr[1] = ApicIMASK;

    if(p->flags & PcmpBP){
        cpuno2apicno[0] = apicno;
        apic->cpuno = 0;
    }
    else{
        cpuno2apicno[mpcpuno] = apicno;
        apic->cpuno = mpcpuno;
        mpcpuno++;
    }

    return apic;
}

static Bus*
mkbus(PCMPbus* p)
{
    Bus *bus;
    int i;

    for(i = 0; buses[i]; i++){
        if(strncmp(buses[i], p->string, sizeof(p->string)) == 0)
            break;
    }
    if(buses[i] == 0)
        return 0;

    bus = xalloc(sizeof(Bus));
    if(mpbus)
        mpbuslast->next = bus;
    else
        mpbus = bus;
    mpbuslast = bus;

    bus->type = i;
    bus->busno = p->busno;
    if(bus->type == BusEISA){
        bus->po = PcmpLOW;
        bus->el = PcmpLEVEL;
        if(mpeisabus != -1)
            print("mkbus: more than one EISA bus\n");
        mpeisabus = bus->busno;
    }
    else if(bus->type == BusPCI){
        bus->po = PcmpLOW;
        bus->el = PcmpLEVEL;
    }
    else if(bus->type == BusISA){
        bus->po = PcmpHIGH;
        bus->el = PcmpEDGE;
        if(mpisabus != -1)
            print("mkbus: more than one ISA bus\n");
        mpisabus = bus->busno;
    }
    else{
        bus->po = PcmpHIGH;
        bus->el = PcmpEDGE;
    }

    return bus;
}

static Bus*
mpgetbus(int busno)
{
    Bus *bus;

    for(bus = mpbus; bus; bus = bus->next){
        if(bus->busno == busno)
            return bus;
    }
    print("mpgetbus: can't find bus %d\n", busno);

    return 0;
}

static Apic*
mkioapic(PCMPioapic* p)
{
    void *va;
    int apicno;
    Apic *apic;

    apicno = p->apicno;
    if(!(p->flags & PcmpEN) || apicno > MaxAPICNO)
        return 0;

    /*
     * Map the I/O APIC.
     */
    if((va = vmap(p->addr, 1024)) == nil)
        return 0;

    apic = &ioapic[apicno];
    apic->type = PcmpIOAPIC;
    apic->apicno = apicno;
    apic->addr = va;
    apic->paddr = p->addr;
    apic->flags = p->flags;

    return apic;
}

static Aintr*
mkiointr(PCMPintr* p)
{
    Bus *bus;
    Aintr *aintr;
    PCMPintr* pcmpintr;

    /*
     * According to the MultiProcessor Specification, a destination
     * I/O APIC of 0xFF means the signal is routed to all I/O APICs.
     * It's unclear how that can possibly be correct so treat it as
     * an error for now.
     */
    if(p->apicno == 0xFF)
        return 0;
    if((bus = mpgetbus(p->busno)) == 0)
        return 0;

    aintr = xalloc(sizeof(Aintr));
    aintr->intr = p;

    if(0)
        dprint("mkiointr: type %d intr type %d flags %#o "
            "bus %d irq %d apicno %d intin %d\n",
            p->type, p->intr, p->flags,
            p->busno, p->irq, p->apicno, p->intin);
    /*
     * Hack for Intel SR1520ML motherboard, which BIOS describes
     * the i82575 dual ethernet controllers incorrectly.
     */
    if(mppcmp && memcmp(mppcmp->product, "INTEL   X38MLST     ", 20) == 0){
        if(p->busno == 1 && p->intin == 16 && p->irq == 1){
            pcmpintr = malloc(sizeof(PCMPintr));
            if(pcmpintr == nil)
                panic("mkiointr: no memory");
            memmove(pcmpintr, p, sizeof(PCMPintr));
            print("mkiointr: %20.20s bus %d intin %d irq %d\n",
                (char*)mppcmp->product,
                pcmpintr->busno, pcmpintr->intin,
                pcmpintr->irq);
            pcmpintr->intin = 17;
            aintr->intr = pcmpintr;
        }
    }
    if ((unsigned)p->apicno >= nelem(mpapic))
        panic("mkiointr: apic %d out of range", p->apicno);
    aintr->apic = &ioapic[p->apicno];
    aintr->next = bus->aintr;
    bus->aintr = aintr;

    return aintr;
}

static int
mpintrinit(Bus* bus, PCMPintr* intr, int vno, int /*irq*/)
{
    int el, po, v;

    /*
     * Parse an I/O or Local APIC interrupt table entry and
     * return the encoded vector.
     */
    v = vno;

    po = intr->flags & PcmpPOMASK;
    el = intr->flags & PcmpELMASK;

    switch(intr->intr){

    default:                /* PcmpINT */
        v |= ApicFIXED;         /* no-op */
        break;

    case PcmpNMI:
        v |= ApicNMI;
        po = PcmpHIGH;
        el = PcmpEDGE;
        break;

    case PcmpSMI:
        v |= ApicSMI;
        break;

    case PcmpExtINT:
        v |= ApicExtINT;
        /*
         * The AMI Goliath doesn't boot successfully with it's LINTR0
         * entry which decodes to low+level. The PPro manual says ExtINT
         * should be level, whereas the Pentium is edge. Setting the
         * Goliath to edge+high seems to cure the problem. Other PPro
         * MP tables (e.g. ASUS P/I-P65UP5 have a entry which decodes
         * to edge+high, so who knows.
         * Perhaps it would be best just to not set an ExtINT entry at
         * all, it shouldn't be needed for SMP mode.
         */
        po = PcmpHIGH;
        el = PcmpEDGE;
        break;
    }

    /*
     */
    if(bus->type == BusEISA && !po && !el /*&& !(i8259elcr & (1<<irq))*/){
        po = PcmpHIGH;
        el = PcmpEDGE;
    }
    if(!po)
        po = bus->po;
    if(po == PcmpLOW)
        v |= ApicLOW;
    else if(po != PcmpHIGH){
        print("mpintrinit: bad polarity 0x%uX\n", po);
        return ApicIMASK;
    }

    if(!el)
        el = bus->el;
    if(el == PcmpLEVEL)
        v |= ApicLEVEL;
    else if(el != PcmpEDGE){
        print("mpintrinit: bad trigger 0x%uX\n", el);
        return ApicIMASK;
    }

    return v;
}

static int
mklintr(PCMPintr* p)
{
    Apic *apic;
    Bus *bus;
    int intin, v;

    /*
     * The offsets of vectors for LINT[01] are known to be
     * 0 and 1 from the local APIC vector space at VectorLAPIC.
     */
    if((bus = mpgetbus(p->busno)) == 0)
        return 0;
    intin = p->intin;

    /*
     * Pentium Pros have problems if LINT[01] are set to ExtINT
     * so just bag it, SMP mode shouldn't need ExtINT anyway.
     */
    if(p->intr == PcmpExtINT || p->intr == PcmpNMI)
        v = ApicIMASK;
    else
        v = mpintrinit(bus, p, VectorLAPIC+intin, p->irq);

    if(p->apicno == 0xFF){
        for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++){
            if((apic->flags & PcmpEN)
            && apic->type == PcmpPROCESSOR)
                apic->lintr[intin] = v;
        }
    }
    else{
        if ((unsigned)p->apicno >= nelem(mpapic))
            panic("mklintr: ioapic %d out of range", p->apicno);
        apic = &mpapic[p->apicno];
        if((apic->flags & PcmpEN) && apic->type == PcmpPROCESSOR)
            apic->lintr[intin] = v;
    }

    return v;
}

static void
checkmtrr(void)
{
    int i, vcnt;
    Cpu *cpu0;

    /*
     * If there are MTRR registers, snarf them for validation.
     */
    if(!(cpu->cpuiddx & Mtrr))
        return;

    rdmsr(0x0FE, &cpu->mtrrcap);
    rdmsr(0x2FF, &cpu->mtrrdef);
    if(cpu->mtrrcap & 0x0100){
        rdmsr(0x250, &cpu->mtrrfix[0]);
        rdmsr(0x258, &cpu->mtrrfix[1]);
        rdmsr(0x259, &cpu->mtrrfix[2]);
        for(i = 0; i < 8; i++)
            rdmsr(0x268+i, &cpu->mtrrfix[(i+3)]);
    }
    vcnt = cpu->mtrrcap & 0x00FF;
    if(vcnt > nelem(cpu->mtrrvar))
        vcnt = nelem(cpu->mtrrvar);
    for(i = 0; i < vcnt; i++)
        rdmsr(0x200+i, &cpu->mtrrvar[i]);

    /*
     * If not the bootstrap processor, compare.
     */
    if(cpu->cpuno == 0)
        return;

    cpu0 = CPUS(0);
    if(cpu0->mtrrcap != cpu->mtrrcap)
        print("mtrrcap%d: %lluX %lluX\n",
            cpu->cpuno, cpu0->mtrrcap, cpu->mtrrcap);
    if(cpu0->mtrrdef != cpu->mtrrdef)
        print("mtrrdef%d: %lluX %lluX\n",
            cpu->cpuno, cpu0->mtrrdef, cpu->mtrrdef);
    for(i = 0; i < 11; i++){
        if(cpu0->mtrrfix[i] != cpu->mtrrfix[i])
            print("mtrrfix%d: i%d: %lluX %lluX\n",
                cpu->cpuno, i, cpu0->mtrrfix[i], cpu->mtrrfix[i]);
    }
    for(i = 0; i < vcnt; i++){
        if(cpu0->mtrrvar[i] != cpu->mtrrvar[i])
            print("mtrrvar%d: i%d: %lluX %lluX\n",
                cpu->cpuno, i, cpu0->mtrrvar[i], cpu->mtrrvar[i]);
    }
}

static void
squidboy(Apic* apic)
{
//  iprint("Hello Squidboy\n");

    cpuinit();
    fpsavealloc();
    mmuinit();

    cpuidentify();
    cpuidprint();
    checkmtrr();

    apic->online = 1;
    coherence();

    lapicinit(apic);
    lapiconline();
    syncclock();
    timersinit();

    fpoff();

    lock(&active);
    active.cpus |= 1<<cpu->cpuno;
    unlock(&active);

    while(!active.main_reached_sched)
        microdelay(100);

    schedinit();
}

static void
mpstartap(Apic* apic)
{
    ulong *apbootp, *pd, *pte;
    Cpu *cpu, *cpu0;
    int i, cpuno;
    uchar *p;

    cpu0 = CPUS(0);

    /*
     * Initialise the AP page-tables and Cpu structure. The page-tables
     * are the same as for the bootstrap processor with the exception of
     * the PTE for the Cpu structure.
     * Xspanalloc will panic if an allocation can't be made.
     */
    p = xspanalloc(4*BY2PG, BY2PG, 0);
    pd = (ulong*)p;
    memmove(pd, cpu0->pdproto, BY2PG);
    p += BY2PG;

    if((pte = mmuwalk(pd, CPUADDR, 1, false)) == nil)
        return;
    memmove(p, KADDR(PPN(*pte)), BY2PG);
    *pte = PADDR(p)|PTEWRITE|PTEVALID;
    if(cpu0->havepge)
        *pte |= PTEGLOBAL;
    p += BY2PG;

    cpu = (Cpu*)p;
    if((pte = mmuwalk(pd, CPUADDR, 2, false)) == nil)
        return;
    *pte = PADDR(cpu)|PTEWRITE|PTEVALID;
    if(cpu0->havepge)
        *pte |= PTEGLOBAL;
    p += BY2PG;

    cpuno = apic->cpuno;
    CPUS(cpuno) = cpu; // !!!!
    cpu->cpuno = cpuno;
    cpu->pdproto = pd;
    cpu->gdt = (Segdesc*)p;    /* filled by mmuinit */

    /*
     * Tell the AP where its kernel vector and pd are.
     * The offsets are known in the AP bootstrap code.
     */
    apbootp = (ulong*)(APBOOTSTRAP+0x08);
    *apbootp++ = (ulong)squidboy;   /* assembler jumps here eventually */
    *apbootp++ = PADDR(pd);
    *apbootp = (ulong)apic;

    /*
     * Universal Startup Algorithm.
     */
    p = KADDR(0x467);       /* warm-reset vector */
    *p++ = PADDR(APBOOTSTRAP);
    *p++ = PADDR(APBOOTSTRAP)>>8;
    i = (PADDR(APBOOTSTRAP) & ~0xFFFF)/16;
    /* code assumes i==0 */
    if(i != 0)
        print("mp: bad APBOOTSTRAP\n");
    *p++ = i;
    *p = i>>8;

    coherence();

    nvramwrite(0x0F, 0x0A); /* shutdown code: warm reset upon init ipi */
    lapicstartap(apic, PADDR(APBOOTSTRAP));
    for(i = 0; i < 1000; i++){
        if(apic->online)
            break;
        delay(10);
    }
    nvramwrite(0x0F, 0x00);
}

static void
trympacpi(void)
{
    if (mpacpifunc != nil) {
        print("mpinit: scanning acpi madt for extra cpus\n");
        (*mpacpifunc)();
    }
}

void
mpinit(void)
{
    int ncpu, cpuson;
    char *cp;
    PCMP *pcmp;
    uchar *e, *p;
    Apic *apic, *bpapic;
    void *va;

    mpdebug = getconf("*debugmp") != nil;
    i8259init();
    syncclock();

    bpapic = nil;
    cpuson = 0;

    if(_mp_ == 0) {
        /*
         * We can easily get processor info from ACPI, but
         * interrupt routing, etc. would require interpreting AML.
         */
        print("mpinit: no mp table found, assuming uniprocessor\n");
        archrevert();
        return;
    }
    pcmp = KADDR(_mp_->physaddr);

    /*
     * Map the local APIC.
     */
    if((va = vmap(pcmp->lapicbase, 1024)) == nil)
        return;
    mppcmp = pcmp;
    print("LAPIC: %#lux %#lux\n", pcmp->lapicbase, (ulong)va);

    /*
     * Run through the table saving information needed for starting
     * application processors and initialising any I/O APICs. The table
     * is guaranteed to be in order such that only one pass is necessary.
     */
    p = ((uchar*)pcmp)+sizeof(PCMP);
    e = ((uchar*)pcmp)+pcmp->length;
    while(p < e) switch(*p){

    default:
        print("mpinit: unknown PCMP type 0x%uX (e-p 0x%luX)\n",
            *p, e-p);
        while(p < e){
            print("%uX ", *p);
            p++;
        }
        break;

    case PcmpPROCESSOR:
        if(apic = mkprocessor((PCMPprocessor*)p)){
            /*
             * Must take a note of bootstrap processor APIC
             * now as it will be needed in order to start the
             * application processors later and there's no
             * guarantee that the bootstrap processor appears
             * first in the table before the others.
             */
            apic->addr = va;
            apic->paddr = pcmp->lapicbase;
            if(apic->flags & PcmpBP)
                bpapic = apic;
            cpuson++;
        }
        p += sizeof(PCMPprocessor);
        continue;

    case PcmpBUS:
        mkbus((PCMPbus*)p);
        p += sizeof(PCMPbus);
        continue;

    case PcmpIOAPIC:
        if(apic = mkioapic((PCMPioapic*)p))
            ioapicinit(apic, ((PCMPioapic*)p)->apicno);
        p += sizeof(PCMPioapic);
        continue;

    case PcmpIOINTR:
        mkiointr((PCMPintr*)p);
        p += sizeof(PCMPintr);
        continue;

    case PcmpLINTR:
        mklintr((PCMPintr*)p);
        p += sizeof(PCMPintr);
        continue;
    }

    dprint("mpinit: mp table describes %d cpus\n", cpuson);

    /* For now, always scan ACPI's MADT for processors that MP missed. */
    trympacpi();

    if (bpapic == nil)
        bpapic = bootapic;

    /*
     * No bootstrap processor, no need to go further.
     */
    if(bpapic == 0)
        return;
    bpapic->online = 1;

    lapicinit(bpapic);

    /*
     * These interrupts are local to the processor
     * and do not appear in the I/O APIC so it is OK
     * to set them now.
     */
    intrenable(IrqTIMER, lapicclock, 0, BUSUNKNOWN, "clock");
    intrenable(IrqERROR, lapicerror, 0, BUSUNKNOWN, "lapicerror");
    intrenable(IrqSPURIOUS, lapicspurious, 0, BUSUNKNOWN, "lapicspurious");
    lapiconline();

    checkmtrr();

    /*
     * Initialise the application processors.
     */
    if(cp = getconf("*ncpu")){
        ncpu = strtol(cp, 0, 0);
        if(ncpu < 1)
            ncpu = 1;
        else if(ncpu > MAXCPUS)
            ncpu = MAXCPUS;
    }
    else
        ncpu = MAXCPUS;
    memmove((void*)APBOOTSTRAP, apbootstrap, sizeof(apbootstrap));
    for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++){
        if(ncpu <= 1)
            break;
        if((apic->flags & (PcmpBP|PcmpEN)) == PcmpEN
        && apic->type == PcmpPROCESSOR){
            mpstartap(apic);
            conf.ncpu++;
            ncpu--;
        }
    }

    /*
     *  we don't really know the number of processors till
     *  here.
     *
     *  set conf.copymode here if ncpu > 1.
     *  Should look for an ExtINT line and enable it.
     */
    if(X86FAMILY(cpu->cpuidax) == 3 || conf.ncpu > 1)
        conf.copymode = 1;
}

static int
mpintrcpu(void)
{
    int i;

    /*
     * The bulk of this code was written ~1995, when there was
     * one architecture and one generation of hardware, the number
     * of CPUs was up to 4(8) and the choices for interrupt routing
     * were physical, or flat logical (optionally with lowest
     * priority interrupt). Logical mode hasn't scaled well with
     * the increasing number of packages/cores/threads, so the
     * fall-back is to physical mode, which works across all processor
     * generations, both AMD and Intel, using the APIC and xAPIC.
     *
     * Interrupt routing policy can be set here.
     * Currently, just assign each interrupt to a different CPU on
     * a round-robin basis. Some idea of the packages/cores/thread
     * topology would be useful here, e.g. to not assign interrupts
     * to more than one thread in a core, or to use a "noise" core.
     * But, as usual, Intel make that an onerous task. 
     */

    /*
     * temporary workaround for many-core intel (non-amd) systems:
     * always use cpu 0.  (TODO)
     */
    if(strncmp(cpu->cpuidid, "AuthenticAMD", 12) != 0 && conf.ncpu > 8)
        return 0;

    lock(&mpphysidlock);
    for(;;){
        i = mpphysid++;
        if(mpphysid >= MaxAPICNO+1)
            mpphysid = 0;
        if(mpapic[i].online)
            break;
    }
    unlock(&mpphysidlock);

    return mpapic[i].apicno;
}

static int
mpintrenablex(Vctl* v, int tbdf)
{
    Bus *bus;
    Aintr *aintr;
    Apic *apic;
    Pcidev *pcidev;
    int bno, dno, hi, irq, lo, n, type, vno;
    char *typenm;

    /*
     * Find the bus.
     */
    type = BUSTYPE(tbdf);
    bno = BUSBNO(tbdf);
    dno = BUSDNO(tbdf);
    if(type == BusISA)
        bno = mpisabus;
    vno = -1;
    for(bus = mpbus; bus != nil; bus = bus->next){
        if(bus->type != type)
            continue;
        if(bus->busno == bno)
            break;
    }
    if(bus == nil){
        typenm = type < 0 || type >= nelem(buses)? "": buses[type];
        print("mpintrenablex: can't find bus type %d (%s) for irq %d "
            "%s busno %d\n", type, typenm, v->irq, v->name, bno);
        return -1;
    }

    /*
     * For PCI devices the interrupt pin (INT[ABCD]) and device
     * number are encoded into the entry irq field, so create something
     * to match on. The interrupt pin used by the device has to be
     * obtained from the PCI config space.
     */
    if(bus->type == BusPCI){
        pcidev = pcimatchtbdf(tbdf);
        if(pcidev != nil && (n = pcicfgr8(pcidev, PciINTP)) != 0)
            irq = (dno<<2)|(n-1);
        else
            irq = -1;
        //print("pcidev %#uX: irq %#uX v->irq %#uX\n", tbdf, irq, v->irq);
    }
    else
        irq = v->irq;

    /*
     * Find a matching interrupt entry from the list of interrupts
     * attached to this bus.
     */
    for(aintr = bus->aintr; aintr; aintr = aintr->next){
        if(aintr->intr->irq != irq)
            continue;
        if (0) {
            PCMPintr* p = aintr->intr;

            print("mpintrenablex: bus %d intin %d irq %d\n",
                p->busno, p->intin, p->irq);
        }
        /*
         * Check if already enabled. Multifunction devices may share
         * INT[A-D]# so, if already enabled, check the polarity matches
         * and the trigger is level.
         *
         * Should check the devices differ only in the function number,
         * but that can wait for the planned enable/disable rewrite.
         * The RDT read here is safe for now as currently interrupts
         * are never disabled once enabled.
         */
        apic = aintr->apic;
        ioapicrdtr(apic, aintr->intr->intin, 0, &lo);
        if(!(lo & ApicIMASK)){
            vno = lo & 0xFF;
//print("%s vector %d (!imask)\n", v->name, vno);
            n = mpintrinit(bus, aintr->intr, vno, v->irq);
            n |= ApicPHYSICAL;      /* no-op */
            lo &= ~(ApicRemoteIRR|ApicDELIVS);
            if(n != lo || !(n & ApicLEVEL)){
                print("mpintrenable: multiple botch irq%d, tbdf %uX, lo %8.8uX, n %8.8uX\n",
                    v->irq, tbdf, lo, n);
                return -1;
            }
            break;
        }

        /*
         * With the APIC a unique vector can be assigned to each
         * request to enable an interrupt. There are two reasons this
         * is a good idea:
         * 1) to prevent lost interrupts, no more than 2 interrupts
         *    should be assigned per block of 16 vectors (there is an
         *    in-service entry and a holding entry for each priority
         *    level and there is one priority level per block of 16
         *    interrupts).
         * 2) each input pin on the IOAPIC will receive a different
         *    vector regardless of whether the devices on that pin use
         *    the same IRQ as devices on another pin.
         */
        vno = VectorAPIC + (incref(&mpvnoref)-1)*8;
//print("%s vector %d (imask)\n", v->name, vno);
        if(vno > MaxVectorAPIC){
            print("mpintrenable: vno %d, irq %d, tbdf %uX\n",
                vno, v->irq, tbdf);
            return -1;
        }

        hi = mpintrcpu()<<24;
        lo = mpintrinit(bus, aintr->intr, vno, v->irq);
        //print("lo 0x%uX: busno %d intr %d vno %d irq %d elcr 0x%uX\n",
        //  lo, bus->busno, aintr->intr->irq, vno,
        //  v->irq, i8259elcr);
        if(lo & ApicIMASK)
            return -1;
        lo |= ApicPHYSICAL;         /* no-op */

        if((apic->flags & PcmpEN) && apic->type == PcmpIOAPIC)
            ioapicrdtw(apic, aintr->intr->intin, hi, lo);
        //else
        //  print("lo not enabled 0x%uX %d\n",
        //      apic->flags, apic->type);
        break;
    }
    if (aintr) {
        v->isr = lapicisr;
        v->eoi = lapiceoi;
    }
    return vno;
}

int
mpintrenable(Vctl* v)
{
    int irq, tbdf, vno;

    /*
     * If the bus is known, try it.
     * BUSUNKNOWN is given both by [E]ISA devices and by
     * interrupts local to the processor (local APIC, coprocessor
     * breakpoint and page-fault).
     */
    tbdf = v->tbdf;
    if(tbdf != BUSUNKNOWN && (vno = mpintrenablex(v, tbdf)) != -1)
        return vno;

    irq = v->irq;
    if(irq >= IrqLINT0 && irq <= MaxIrqLAPIC){
        if(irq != IrqSPURIOUS)
            v->isr = lapiceoi;
        return VectorPIC+irq;
    }
    if(irq < 0 || irq > MaxIrqPIC){
        print("mpintrenable: irq %d out of range\n", irq);
        return -1;
    }

    /*
     * Either didn't find it or have to try the default buses
     * (ISA and EISA). This hack is due to either over-zealousness 
     * or laziness on the part of some manufacturers.
     *
     * The MP configuration table on some older systems
     * (e.g. ASUS PCI/E-P54NP4) has an entry for the EISA bus
     * but none for ISA. It also has the interrupt type and
     * polarity set to 'default for this bus' which wouldn't
     * be compatible with ISA.
     */
    if(mpeisabus != -1){
        vno = mpintrenablex(v, MKBUS(BusEISA, 0, 0, 0));
        if(vno != -1)
            return vno;
    }
    if(mpisabus != -1){
        vno = mpintrenablex(v, MKBUS(BusISA, 0, 0, 0));
        if(vno != -1)
            return vno;
    }
    print("mpintrenable: out of choices eisa %d isa %d tbdf %#ux irq %d\n",
        mpeisabus, mpisabus, v->tbdf, v->irq);
    return -1;
}

static Lock mpshutdownlock;

void
mpshutdown(void)
{
    /*
     * To be done...
     */
    if(!canlock(&mpshutdownlock)){
        /*
         * If this processor received the CTRL-ALT-DEL from
         * the keyboard, acknowledge it. Send an INIT to self.
         */
#ifdef FIXTHIS
        if(lapicisr(VectorKBD))
            lapiceoi(VectorKBD);
#endif /* FIX THIS */
        arch->introff();
        idle();
    }

    if(active.rebooting)
        return;
    print("apshutdown: active = %#8.8ux\n", active.cpus);
    delay(1000);
    splhi();
    arch->resetothers();

    pcireset();
    i8042reset();

    /*
     * Often the BIOS hangs during restart if a conventional 8042
     * warm-boot sequence is tried. The following is Intel specific and
     * seems to perform a cold-boot, but at least it comes back.
     * And sometimes there is no keyboard...
     *
     * The reset register (0xcf9) is usually in one of the bridge
     * chips. The actual location and sequence could be extracted from
     * ACPI but why bother, this is the end of the line anyway.
     */
    print("no kbd; trying bios warm boot...");
    *(ushort*)KADDR(0x472) = 0x1234;    /* BIOS warm-boot flag */
    outb(0xCF9, 0x02);
    outb(0xCF9, 0x06);

    print("can't reset\n");
    for(;;)
        idle();
}
@


\subsection*{[[processes/386/mpacpi.c]]}

<<mpacpi.c debugging macro>>=
//#define dprint(...)   if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
#define dprint if(mpdebug) print
/* from mp.c */
extern int  mpdebug;
@ 


<<mpacpi.c>>=
/*
 * minimal acpi support for multiprocessors.
 *
 * avoids AML but that's only enough to discover
 * the processors, not the interrupt routing details.
 */
<<kernel basic includes>>

#include "io.h"
#include "mp.h"
#include "mpacpi.h"

/* 8c says: out of fixed registers */
#define L64GET(p)   ((uvlong)L32GET((p)+4) << 32 | L32GET(p))

enum {
    /* apic types */
    Apiclproc,
    Apicio,
    Apicintrsrcoverride,
    Apicnmisrc,
    Apiclnmi,
    Apicladdroverride,
    Apicios,
    Apicls,
    Apicintrsrc,
    Apiclx2,
    Apiclx2nmi,

    PcmpUsed = 1ul<<31,     /* Apic->flags addition */

    Lapicbase = 0x1b,       /* msr */

    Lapicae = 1<<11,        /* apic enable in Lapicbase */
};

<<mpacpi.c debugging macro>>

int mpcpuno; //PAD: bug? also declared in mp.c
extern Apic mpapic[MaxAPICNO+1];
extern int  cpuno2apicno[MaxAPICNO+1]; /* inverse map: cpuno -> APIC ID */

Apic    *bootapic;

static int nprocid;

static uvlong
l64get(uchar *p)
{
    return L64GET(p);
}

int
apicset(Apic *apic, int type, int apicno, int f)
{
    if(apicno > MaxAPICNO)
        return -1;
    apic->type = type;
    apic->apicno = apicno;
    apic->flags = f | PcmpEN | PcmpUsed;
    return 0;
}

int
mpnewproc(Apic *apic, int apicno, int f)
{
    if(apic->flags & PcmpUsed) {
        print("mpnewproc: apic already enabled\n");
        return -1;
    }
    if (apicset(apic, PcmpPROCESSOR, apicno, f) < 0)
        return -1;
    apic->lintr[1] = apic->lintr[0] = ApicIMASK;
    /* botch! just enumerate */
    if(apic->flags & PcmpBP)
        apic->cpuno = 0;
    else
        apic->cpuno = ++mpcpuno;
    cpuno2apicno[apic->cpuno] = apicno;
    return 0;
}

static int
mpacpiproc(uchar *p, ulong laddr)
{
    int id, f;
    ulong *vladdr;
    vlong base;
    char *already;
    Apic *apic;

    /* p bytes: type (0), len (8), cpuid, cpu_lapic id, flags[4] */
    id = p[3];
    /* cpu unusable flag or id out of range? */
    if((L32GET(p+4) & 1) == 0 || id > MaxAPICNO)
        return -1;

    vladdr = nil;
    already = "";
    f = 0;
    apic = &mpapic[id];
    dprint("\tmpacpiproc: apic %#p\n", apic);
    apic->paddr = laddr;
    if (nprocid++ == 0) {
        f = PcmpBP;
        vladdr = vmap(apic->paddr, 1024);
        if(apic->addr == nil){
            print("proc apic %d: failed to map %#p\n", id,
                apic->paddr);
            already = "(fail)";
        }
        bootapic = apic;
    }
    apic->addr = vladdr;

    if(apic->flags & PcmpUsed)
        already = "(on)";
    else
        mpnewproc(apic, id, f);

    if (0)
        dprint("\tapic proc %d/%d apicid %d flags%s%s %s\n", nprocid-1,
            apic->cpuno, id, f & PcmpBP? " boot": "",
            f & PcmpEN? " enabled": "", already);
    USED(already);

    rdmsr(Lapicbase, &base);
    if (!(base & Lapicae)) {
        dprint("mpacpiproc: enabling lapic\n");
        wrmsr(Lapicbase, base | Lapicae);
    }
    return 0;
}

static void
mpacpicpus(Madt *madt)
{
    int i, n;
    ulong laddr;
    uchar *p;

    laddr = L32GET(madt->addr);
    dprint("APIC mpacpicpus(%#p) lapic addr %#lux, flags %#ux\n",
        madt, laddr, L32GET(madt->flags));

    n = L32GET(&madt->sdthdr[4]);
    p = madt->structures;
    dprint("\t%d structures at %#p\n",n, p);
    /* byte 0 is assumed to be type, 1 is assumed to be length */
    for(i = offsetof(Madt, structures[0]); i < n; i += p[1], p += p[1])
        switch(p[0]){
        case Apiclproc:
            mpacpiproc(p, laddr);
            break;
        }
}

/* returns nil iff checksum is bad */
static void *
mpacpirsdchecksum(void* addr, int length)
{
    uchar *p, sum;

    sum = 0;
    for(p = addr; length-- > 0; p++)
        sum += *p;
    return sum == 0? addr: nil;
}

/* call func for each acpi table found */
static void
mpacpiscan(void (*func)(uchar *))
{
    int asize, i, tbllen, sdtlen;
    uintptr dhpa, sdtpa;
    uchar *tbl, *sdt;
    Rsd *rsd;

    dprint("ACPI...");
    if((rsd = sigsearch("RSD PTR ")) == nil) {
        dprint("none\n");
        return;
    }

    dprint("rsd %#p physaddr %#ux length %ud %#llux rev %d oem %.6s\n",
        rsd, L32GET(rsd->raddr), L32GET(rsd->length),
        l64get(rsd->xaddr), rsd->revision, (char*)rsd->oemid);

    if(rsd->revision == 2){
        if(mpacpirsdchecksum(rsd, 36) == nil)
            return;
        asize = 8;
        sdtpa = l64get(rsd->xaddr);
    } else {
        if(mpacpirsdchecksum(rsd, 20) == nil)
            return;
        asize = 4;
        sdtpa = L32GET(rsd->raddr);
    }

    if((sdt = vmap(sdtpa, 8)) == nil)
        return;
    if((sdt[0] != 'R' && sdt[0] != 'X') || memcmp(sdt+1, "SDT", 3) != 0){
        vunmap(sdt, 8);
        return;
    }
    sdtlen = L32GET(sdt + 4);
    vunmap(sdt, 8);

    if((sdt = vmap(sdtpa, sdtlen)) == nil)
        return;
    if(mpacpirsdchecksum(sdt, sdtlen) != nil)
        for(i = 36; i < sdtlen; i += asize){
            if(asize == 8)
                dhpa = l64get(sdt+i);
            else
                dhpa = L32GET(sdt+i);
    
            if((tbl = vmap(dhpa, 8)) == nil)
                continue;
            tbllen = L32GET(tbl + 4);
            vunmap(tbl, 8);
    
            if((tbl = vmap(dhpa, tbllen)) == nil)
                continue;
            if(mpacpirsdchecksum(tbl, tbllen) != nil)
                (*func)(tbl);
            vunmap(tbl, tbllen);
        }
    vunmap(sdt, sdtlen);
}

static void
mpacpitbl(uchar *p)
{
    /* for now, just activate any idle cpus */
    if (memcmp(p, "APIC", 4) == 0)
        mpacpicpus((Madt *)p);
}

static void
mpacpi(void)
{
    mpdebug = getconf("*debugmp") != nil;
    mpacpiscan(mpacpitbl);
}

void    (*mpacpifunc)(void) = mpacpi;
@



\subsection*{[[init/386/rebootcode.s]]}

<<rebootcode.s>>=
#include "mem.h"

/*
 * Turn off MMU, then memmove the new kernel to its correct location
 * in physical memory.  Then jump to the start of the kernel.
 */

TEXT    main(SB),$0
        MOVL    p1+0(FP), DI            /* destination */
        MOVL    DI, AX                  /* entry point */
        MOVL    p2+4(FP), SI            /* source */
        MOVL    n+8(FP), CX             /* byte count */

/*
 * disable paging
 */
        MOVL    CR0, DX
        ANDL    $~0x80000000, DX                /* ~(PG) */
        MOVL    DX, CR0
        MOVL    $0, DX
        MOVL    DX, CR3

/*
 * the source and destination may overlap.
 * determine whether to copy forward or backwards
 */
        CMPL    SI, DI
        JGT     _forward
        MOVL    SI, DX
        ADDL    CX, DX
        CMPL    DX, DI
        JGT     _back

_forward:
        CLD
        REP;    MOVSB
        JMP     _startkernel

_back:
        ADDL    CX, DI
        ADDL    CX, SI
        SUBL    $1, DI
        SUBL    $1, SI
        STD
        REP;    MOVSB
        JMP     _startkernel
/*
 * JMP to kernel entry point.  Note the true kernel entry point is
 * the virtual address KZERO|AX, but this must wait until
 * the MMU is enabled by the kernel in l.s
 */
_startkernel:
        ORL     AX, AX          /* NOP: avoid link bug */
        JMP*    AX
@




\subsection*{[[init/rebootcmd.c]]}

<<rebootcmd.c>>=
<<kernel basic includes>>

#include    <a.out.h>
#include    <elf.h>

//@Scheck: used in params below, FP cg
struct Execvals {
  uvlong  entry;
  ulong textsize;
  ulong datasize;
};
//@Scheck: TODO: who sets this? it's used by rebootcmd but who sets it? qemu?
int (*parseboothdr)(Chan *, ulong, Execvals *);


enum {
    Ehdr32sz    = 52,
    Phdr32sz    = 32,
    Shdr32sz    = 40,

    Ehdr64sz    = 64,
    Phdr64sz    = 56,
    Shdr64sz    = 64,
};

static uchar elfident[] = {
    '\177', 'E', 'L', 'F',
};

void
readn(Chan *c, void *vp, long n)
{
    char *p = vp;
    long nn;

    while(n > 0) {
        nn = devtab[c->type]->read(c, p, n, c->offset);
        if(nn == 0)
            error(Eshort);
        c->offset += nn;
        p += nn;
        n -= nn;
    }
}

/* assume the elf header is in the byte order of this machine */
int
readelfhdr(Chan *c, ulong, Execvals *evp)
{
    Ehdr ehdr;
    Phdr phdrs[3];

    c->offset = 0;          /* back up */
    readn(c, &ehdr, sizeof ehdr);
    if(memcmp(&ehdr.ident[MAG0], elfident, sizeof elfident) != 0 ||
        ehdr.ident[CLASS] != ELFCLASS32)
        return -1;

    /* get textsize and datasize from Phdrs */
    readn(c, phdrs, sizeof phdrs);
    evp->entry = ehdr.elfentry;
    evp->textsize = phdrs[0].filesz;
    evp->datasize = phdrs[1].filesz;
    c->offset = ROUNDUP(Ehdr32sz + 3*Phdr32sz, 16); /* position for text */
    return 0;
}

static int
readelf64hdr(Chan *c, ulong, Execvals *evp)
{
    E64hdr ehdr;
    P64hdr phdrs[3];

    c->offset = 0;          /* back up */
    readn(c, &ehdr, sizeof ehdr);
    if(memcmp(&ehdr.ident[MAG0], elfident, sizeof elfident) != 0 ||
        ehdr.ident[CLASS] != ELFCLASS64)
        return -1;

    /* get textsize and datasize from Phdrs */
    readn(c, phdrs, sizeof phdrs);
    evp->entry = ehdr.elfentry;
    evp->textsize = phdrs[0].filesz;
    evp->datasize = phdrs[1].filesz;
    c->offset = ROUNDUP(Ehdr64sz + 3*Phdr64sz, 16); /* position for text */
    return 0;
}

static void
setbootcmd(int argc, char *argv[])
{
    char *buf, *p, *ep;
    int i;

    buf = malloc(1024);
    if(buf == nil)
        error(Enomem);
    p = buf;
    ep = buf + 1024;
    for(i=0; i<argc; i++)
        p = seprint(p, ep, "%q ", argv[i]);
    *p = 0;
    ksetenv("bootcmd", buf, 1);
    free(buf);
}

void
rebootcmd(int argc, char *argv[])
{
    Chan *c;
    Exec exec;
    Execvals ev;
    ulong magic, text, rtext, entry, data, size;
    uchar *p;

    if(argc == 0)
        exit(0);

    c = namec(argv[0], Aopen, OEXEC, 0);
    if(waserror()){
        cclose(c);
        nexterror();
    }

    readn(c, &exec, sizeof(Exec));
    magic = l2be(exec.magic);
    /*
     * AOUT_MAGIC is sometimes defined like this:
     * #define AOUT_MAGIC   V_MAGIC || magic==M_MAGIC
     * so we can only use it in a fairly stylized manner.
     */
    if(magic == AOUT_MAGIC) {
        entry = l2be(exec.entry);
        text = l2be(exec.text);
        data = l2be(exec.data);
    } else if(parseboothdr && (*parseboothdr)(c, magic, &ev) >= 0 ||
        readelfhdr(c, magic, &ev) >= 0 ||
        readelf64hdr(c, magic, &ev) >= 0){
        entry = ev.entry;
        text = ev.textsize;
        data = ev.datasize;
    } else {
        error(Ebadexec);
        return;             /* for the compiler */
    }

    /* round text out to page boundary */
    rtext = ROUNDUP(entry+text, BY2PG) - entry;
    size = rtext + data;
    p = malloc(size);
    if(p == nil)
        error(Enomem);

    if(waserror()){
        free(p);
        nexterror();
    }

    memset(p, 0, size);
    readn(c, p, text);
    readn(c, p + rtext, data);

    ksetenv("bootfile", argv[0], 1);
    setbootcmd(argc-1, argv+1);

    reboot((void*)entry, p, size);

    panic("return from reboot!");
}
@


\fi
