\section{[[arch/]]}

\subsection*{[[arch/386/arch.c]]}

<<arch.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

//todo: weird, if don't include this file, then can't declare arch in this file
// or I get some type signature mismatch
#include "io.h"

PCArch* arch;

void    (*fprestore)(ArchFPsave*);
void    (*fpsave)(ArchFPsave*);

int (*_pcmspecial)(char*, ISAConf*);
void (*_pcmspecialclose)(int);




void
cpuidprint(void)
{
    int i;
    char buf[128];

    i = snprint(buf, sizeof buf, "cpu%d: %s%dMHz ", m->machno,
        m->machno < 10? " ": "", m->cpumhz);
    if(m->cpuidid[0])
        i += sprint(buf+i, "%12.12s ", m->cpuidid);
    seprint(buf+i, buf + sizeof buf - 1,
        "%s (cpuid: AX 0x%4.4uX DX 0x%4.4uX)\n",
        m->cpuidtype, m->cpuidax, m->cpuiddx);
    print(buf);
}


ulong
Âµs(void)
{
    return fastticks2us((*arch->fastclock)(nil));
}



static void
simplecycles(uvlong*x)
{
    *x = m->ticks;
}

void    (*cycles)(uvlong*) = simplecycles;

/*
 * 386 has no compare-and-swap instruction.
 * Run it with interrupts turned off instead.
 */
// used to be static, but now shared between arch.c and devarch.c
int
cmpswap386(long *addr, long old, long new)
{
    int r, s;

    s = splhi();
    if(r = (*addr == old))
        *addr = new;
    splx(s);
    return r;
}

/*
 * On a uniprocessor, you'd think that coherence could be nop,
 * but it can't.  We still need a barrier when using coherence() in
 * device drivers.
 *
 * On VMware, it's safe (and a huge win) to set this to nop.
 * Aux/vmware does this via the #P/archctl file.
 */
//now in globals.c: void (*coherence)(void) = nop;

int (*cmpswap)(long*, long, long) = cmpswap386;


// used to be static, but now shared between arch.c and devarch.c
int doi8253set = 1;

/*
 *  set next timer interrupt
 */
void
timerset(Tval x)
{
    if(doi8253set)
        (*arch->timerset)(x);
}





/*
 *  call either the pcmcia or pccard device setup
 */
int
pcmspecial(char *idstr, ISAConf *isa)
{
    return (_pcmspecial != nil)? _pcmspecial(idstr, isa): -1;
}

/*
 *  call either the pcmcia or pccard device teardown
 */
//void
//pcmspecialclose(int a)
//{
//  if (_pcmspecialclose != nil)
//      _pcmspecialclose(a);
//}


/*
 *  return value and speed of timer set in arch->clockenable
 */
uvlong
devarch_fastticks(uvlong *hz)
{
    return (*arch->fastclock)(hz);
}


@


\subsection*{[[arch/386/bios32.c]]}

<<bios32.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"

//#define VFLAG(...)    if(vflag) print(__VA_ARGS__)
#define VFLAG if(vflag) print

#define UPTR2INT(p) ((uintptr)(p))

static int vflag = 0;

typedef struct BIOS32sdh {      /* BIOS32 Service Directory Header */
    u8int   signature[4];       /* "_32_" */
    u8int   physaddr[4];        /* physical address of entry point */
    u8int   revision;
    u8int   length;         /* of header in paragraphs */
    u8int   checksum;       /* */
    u8int   reserved[5];
} BIOS32sdh;

typedef struct BIOS32si {       /* BIOS32 Service Interface */
    u8int*  base;           /* base address of service */
    int length;         /* length of service */
    u32int  offset;         /* service entry-point from base */

    u16int  ptr[3];         /* far pointer m16:32 */
} BIOS32si;

static Lock bios32lock;
static u16int bios32ptr[3];
static void* bios32entry;

int
bios32ci(BIOS32si* si, BIOS32ci* ci)
{
    int r;

    lock(&bios32lock);
    r = bios32call(ci, si->ptr);
    unlock(&bios32lock);

    return r;
}

static void*
rsdchecksum(void* addr, int length)
{
    u8int *p, sum;

    sum = 0;
    for(p = addr; length-- > 0; p++)
        sum += *p;
    if(sum == 0)
        return addr;

    return nil;
}

static void*
rsdscan(u8int* addr, int len, char* signature)
{
    int sl;
    u8int *e, *p;

    e = addr+len;
    sl = strlen(signature);
    for(p = addr; p+sl < e; p += 16){
        if(memcmp(p, signature, sl))
            continue;
        return p;
    }

    return nil;
}

static int
bios32locate(void)
{
    uintptr ptr;
    BIOS32sdh *sdh;

    VFLAG("bios32link\n");
    if((sdh = rsdscan(BIOSSEG(0xE000), 0x20000, "_32_")) == nil)
        return -1;
    if(rsdchecksum(sdh, sizeof(BIOS32sdh)) == nil)
        return -1;
    VFLAG("sdh @ %#p, entry %#ux\n", sdh, L32GET(sdh->physaddr));

    bios32entry = vmap(L32GET(sdh->physaddr), 4096+1);
    VFLAG("entry @ %#p\n", bios32entry);
    ptr = UPTR2INT(bios32entry);
    bios32ptr[0] = ptr & 0xffff;
    bios32ptr[1] = (ptr>>16) & 0xffff;
    bios32ptr[2] = KESEL;
    VFLAG("bios32link: ptr %ux %ux %ux\n",
        bios32ptr[0], bios32ptr[1], bios32ptr[2]);

    return 0;
}

//void
//BIOS32close(BIOS32si* si)
//{
//  vunmap(si->base, si->length);
//  free(si);
//}

BIOS32si*
bios32open(char* id)
{
    uint ptr;
    BIOS32ci ci;
    BIOS32si *si;

    lock(&bios32lock);
    if(bios32ptr[2] == 0 && bios32locate() < 0){
        unlock(&bios32lock);
        return nil;
    }

    VFLAG("bios32si: %s\n", id);
    memset(&ci, 0, sizeof(BIOS32ci));
    ci.eax = (id[3]<<24|(id[2]<<16)|(id[1]<<8)|id[0]);

    bios32call(&ci, bios32ptr);
    unlock(&bios32lock);

    VFLAG("bios32si: eax %ux\n", ci.eax);
    if(ci.eax & 0xff)
        return nil;
    VFLAG("bios32si: base %#ux length %#ux offset %#ux\n",
        ci.ebx, ci.ecx, ci.edx);

    if((si = malloc(sizeof(BIOS32si))) == nil)
        return nil;
    if((si->base = vmap(ci.ebx, ci.ecx)) == nil){
        free(si);
        return nil;
    }
    si->length = ci.ecx;

    ptr = UPTR2INT(si->base)+ci.edx;
    si->ptr[0] = ptr & 0xffff;
    si->ptr[1] = (ptr>>16) & 0xffff;
    si->ptr[2] = KESEL;
    VFLAG("bios32si: eax entry %ux\n", ptr);

    return si;
}
@


\subsection*{[[arch/386/dat_arch.h]]}

<<dat_arch.h>>=

//*****************************************************************************
// IO Map
//*****************************************************************************

// All the ref<IOMap> here are references to IOMap in the array<IOMap> of 
// Iomapalloc.maps (pool allocator)

struct IOMap
{
  // TODO: why this has to be the first field of IOMap?! otherwise get fault??

  // list<ref<IOMap>> of Iomapalloc.free
    IOMap   *next;

    char    tag[13];
    ulong   start;
    ulong   end;

  // extra
    bool    reserved;

};

struct Iomapalloc
{
  // ??
    IOMap   *m;

  // list<ref<IOMap>> (next = IOMap.next)
    IOMap   *free;
  // array<IOMAP> pool
    IOMap   maps[32];   /* some initial free maps */

  // extra
    Lock;
    QLock   ql;     /* lock for reading map */
};

// array<IMap> alloced statically in maps
extern struct Iomapalloc iomap;

//*****************************************************************************
// PC Architecture hooks (interrupts, clocks, power, reset)
//*****************************************************************************

/*
 *  routines for things outside the PC model, like power management
 */
struct PCArch
{
  char* id;
  int (*ident)(void);   /* this should be in the model */
  void  (*reset)(void);   /* this should be in the model */
  int (*serialpower)(int);  /* 1 == on, 0 == off */
  int (*modempower)(int); /* 1 == on, 0 == off */

  // interrupts
  void  (*intrinit)(void);
  int (*intrenable)(Vctl*);
  int (*intrvecno)(int);
  int (*intrdisable)(int);
  void  (*introff)(void);
  void  (*intron)(void);

  // clock, timer
  void  (*clockenable)(void);
  uvlong  (*fastclock)(uvlong*);
  void  (*timerset)(uvlong);

  void  (*resetothers)(void); /* put other cpus into reset */
};
extern PCArch *arch;      /* PC architecture */
extern PCArch archgeneric;

//*****************************************************************************
// Co processor
//*****************************************************************************

//@Scheck: unnamed substructure
struct  FPstate     /* x87 fpu state */
{
  ushort  control;
  ushort  r1;
  // enum<fpsavestatus>
  ushort  status;
  ushort  r2;
  ushort  tag;
  ushort  r3;
  ulong pc;
  ushort  selector;
  ushort  r4;
  ulong operand;
  ushort  oselector;
  ushort  r5;
  uchar regs[80]; /* floating point registers */
};

//@Scheck: unnamed substructure
struct  FPssestate    /* SSE fp state */
{
  ushort  fcw;    /* control */
  ushort  fsw;    /* status */
  ushort  ftw;    /* tag */
  ushort  fop;    /* opcode */
  ulong fpuip;    /* pc */
  ushort  cs;   /* pc segment */
  ushort  r1;   /* reserved */
  ulong fpudp;    /* data pointer */
  ushort  ds;   /* data pointer segment */
  ushort  r2;
  ulong mxcsr;    /* MXCSR register state */
  ulong mxcsr_mask; /* MXCSR mask register */
  uchar xregs[480]; /* extended registers */
};

//@Scheck: unnamed substructure
struct  SFPssestate   /* SSE fp state with alignment slop */
{
  FPssestate;
  uchar alignpad[FPalign]; /* slop to allow copying to aligned addr */
  ulong magic;    /* debugging: check for overrun */
};

//*****************************************************************************
// Misc
//*****************************************************************************

struct BIOS32ci {   /* BIOS32 Calling Interface */
  u32int  eax;
  u32int  ebx;
  u32int  ecx;
  u32int  edx;
  u32int  esi;
  u32int  edi;
};


// used to be in devrtc.c, but to remove some backward deps had to be here
// it's really used only by nvram.c and devrtc.c
/*
 *  real time clock and non-volatile ram
 */

enum {
    Paddr=      0x70,   /* address port */
    PdataPort=      0x71,   /* data port */
};
extern Lock nvrtlock;


struct X86type {
    int family;
    int model;
    int aalcycles;
    char*   name;
};

extern X86type *cputype;



/*
 *  hardware info about a device
 */
struct Devport {
  ulong port; 
  int size;
};

struct DevConf
{
  ulong intnum;     /* interrupt number */
  char  *type;      /* card type, malloced */
  int nports;     /* Number of ports */
  Devport *ports;     /* The ports themselves */
};
@


\subsection*{[[arch/386/io.h]]}

<<io.h>>=


#define X86FAMILY(x)  ((((x)>>8) & 0x0F) | (((x)>>20) & 0xFF)<<4)

enum {
  BusCBUS   = 0,    /* Corollary CBUS */
  BusCBUSII,      /* Corollary CBUS II */
  BusEISA,      /* Extended ISA */
  BusFUTURE,      /* IEEE Futurebus */
  BusINTERN,      /* Internal bus */
  BusISA,       /* Industry Standard Architecture */
  BusMBI,       /* Multibus I */
  BusMBII,      /* Multibus II */
  BusMCA,       /* Micro Channel Architecture */
  BusMPI,       /* MPI */
  BusMPSA,      /* MPSA */
  BusNUBUS,     /* Apple Macintosh NuBus */
  BusPCI,       /* Peripheral Component Interconnect */
  BusPCMCIA,      /* PC Memory Card International Association */
  BusTC,        /* DEC TurboChannel */
  BusVL,        /* VESA Local bus */
  BusVME,       /* VMEbus */
  BusXPRESS,      /* Express System Bus */
};

#define MKBUS(t,b,d,f)  (((t)<<24)|(((b)&0xFF)<<16)|(((d)&0x1F)<<11)|(((f)&0x07)<<8))
#define BUSFNO(tbdf)  (((tbdf)>>8)&0x07)
#define BUSDNO(tbdf)  (((tbdf)>>11)&0x1F)
#define BUSBNO(tbdf)  (((tbdf)>>16)&0xFF)
#define BUSTYPE(tbdf) ((tbdf)>>24)
#define BUSBDF(tbdf)  ((tbdf)&0x00FFFF00)
#define BUSUNKNOWN  (-1)

enum {
  MaxEISA   = 16,
  CfgEISA   = 0xC80,
};

/*
 * PCI support code.
 */
enum {          /* type 0 & type 1 pre-defined header */
  PciVID    = 0x00,   /* vendor ID */
  PciDID    = 0x02,   /* device ID */
  PciPCR    = 0x04,   /* command */
  PciPSR    = 0x06,   /* status */
  PciRID    = 0x08,   /* revision ID */
  PciCCRp   = 0x09,   /* programming interface class code */
  PciCCRu   = 0x0A,   /* sub-class code */
  PciCCRb   = 0x0B,   /* base class code */
  PciCLS    = 0x0C,   /* cache line size */
  PciLTR    = 0x0D,   /* latency timer */
  PciHDT    = 0x0E,   /* header type */
  PciBST    = 0x0F,   /* BIST */

  PciBAR0   = 0x10,   /* base address */
  PciBAR1   = 0x14,

  PciINTL   = 0x3C,   /* interrupt line */
  PciINTP   = 0x3D,   /* interrupt pin */
};

/* ccrb (base class code) values; controller types */
enum {
  Pcibcpci1 = 0,    /* pci 1.0; no class codes defined */
  Pcibcstore  = 1,    /* mass storage */
  Pcibcnet  = 2,    /* network */
  Pcibcdisp = 3,    /* display */
  Pcibcmmedia = 4,    /* multimedia */
  Pcibcmem  = 5,    /* memory */
  Pcibcbridge = 6,    /* bridge */
  Pcibccomm = 7,    /* simple comms (e.g., serial) */
  Pcibcbasesys  = 8,    /* base system */
  Pcibcinput  = 9,    /* input */
  Pcibcdock = 0xa,    /* docking stations */
  Pcibcproc = 0xb,    /* processors */
  Pcibcserial = 0xc,    /* serial bus (e.g., USB) */
  Pcibcwireless = 0xd,    /* wireless */
  Pcibcintell = 0xe,    /* intelligent i/o */
  Pcibcsatcom = 0xf,    /* satellite comms */
  Pcibccrypto = 0x10,   /* encryption/decryption */
  Pcibcdacq = 0x11,   /* data acquisition & signal proc. */
};

/* ccru (sub-class code) values; common cases only */
enum {
  /* mass storage */
  Pciscscsi = 0,    /* SCSI */
  Pciscide  = 1,    /* IDE (ATA) */
  Pciscsata = 6,    /* SATA */

  /* network */
  Pciscether  = 0,    /* Ethernet */

  /* display */
  Pciscvga  = 0,    /* VGA */
  Pciscxga  = 1,    /* XGA */
  Pcisc3d   = 2,    /* 3D */

  /* bridges */
  Pcischostpci  = 0,    /* host/pci */
  Pciscpcicpci  = 1,    /* pci/pci */

  /* simple comms */
  Pciscserial = 0,    /* 16450, etc. */
  Pciscmultiser = 1,    /* multiport serial */

  /* serial bus */
  Pciscusb  = 3,    /* USB */
};

enum {          /* type 0 pre-defined header */
  PciCIS    = 0x28,   /* cardbus CIS pointer */
  PciSVID   = 0x2C,   /* subsystem vendor ID */
  PciSID    = 0x2E,   /* cardbus CIS pointer */
  PciEBAR0  = 0x30,   /* expansion ROM base address */
  PciMGNT   = 0x3E,   /* burst period length */
  PciMLT    = 0x3F,   /* maximum latency between bursts */
};

enum {          /* type 1 pre-defined header */
  PciPBN    = 0x18,   /* primary bus number */
  PciSBN    = 0x19,   /* secondary bus number */
  PciUBN    = 0x1A,   /* subordinate bus number */
  PciSLTR   = 0x1B,   /* secondary latency timer */
  PciIBR    = 0x1C,   /* I/O base */
  PciILR    = 0x1D,   /* I/O limit */
  PciSPSR   = 0x1E,   /* secondary status */
  PciMBR    = 0x20,   /* memory base */
  PciMLR    = 0x22,   /* memory limit */
  PciPMBR   = 0x24,   /* prefetchable memory base */
  PciPMLR   = 0x26,   /* prefetchable memory limit */
  PciPUBR   = 0x28,   /* prefetchable base upper 32 bits */
  PciPULR   = 0x2C,   /* prefetchable limit upper 32 bits */
  PciIUBR   = 0x30,   /* I/O base upper 16 bits */
  PciIULR   = 0x32,   /* I/O limit upper 16 bits */
  PciEBAR1  = 0x28,   /* expansion ROM base address */
  PciBCR    = 0x3E,   /* bridge control register */
};

enum {          /* type 2 pre-defined header */
  PciCBExCA = 0x10,
  PciCBSPSR = 0x16,
  PciCBPBN  = 0x18,   /* primary bus number */
  PciCBSBN  = 0x19,   /* secondary bus number */
  PciCBUBN  = 0x1A,   /* subordinate bus number */
  PciCBSLTR = 0x1B,   /* secondary latency timer */
  PciCBMBR0 = 0x1C,
  PciCBMLR0 = 0x20,
  PciCBMBR1 = 0x24,
  PciCBMLR1 = 0x28,
  PciCBIBR0 = 0x2C,   /* I/O base */
  PciCBILR0 = 0x30,   /* I/O limit */
  PciCBIBR1 = 0x34,   /* I/O base */
  PciCBILR1 = 0x38,   /* I/O limit */
  PciCBSVID = 0x40,   /* subsystem vendor ID */
  PciCBSID  = 0x42,   /* subsystem ID */
  PciCBLMBAR  = 0x44,   /* legacy mode base address */
};

typedef struct Pcisiz Pcisiz;
struct Pcisiz
{
  Pcidev* dev;
  int siz;
  int bar;
};

typedef struct Pcidev Pcidev;
struct Pcidev
{
  int tbdf;     /* type+bus+device+function */
  ushort  vid;      /* vendor ID */
  ushort  did;      /* device ID */

  ushort  pcr;

  uchar rid;
  uchar ccrp;
  uchar ccru;
  uchar ccrb;
  uchar cls;
  uchar ltr;

  struct {
    ulong bar;    /* base address */
    int size;
  } mem[6];

  struct {
    ulong bar;  
    int size;
  } rom;
  uchar intl;     /* interrupt line */

  Pcidev* list;
  Pcidev* link;     /* next device on this bno */

  Pcidev* bridge;     /* down a bus */
  struct {
    ulong bar;
    int size;
  } ioa, mema;

  int pmrb;     /* power management register block */
};

enum {
  /* vendor ids */
  Vatiamd = 0x1002,
  Vintel  = 0x8086,
  Vjmicron= 0x197b,
  Vmarvell= 0x1b4b,
  Vmyricom= 0x14c1,
};

#define PCIWINDOW 0
#define PCIWADDR(va)  (PADDR(va)+PCIWINDOW)
#define ISAWINDOW 0
#define ISAWADDR(va)  (PADDR(va)+ISAWINDOW)

/* SMBus transactions */
enum
{
  SMBquick,   /* sends address only */

  /* write */
  SMBsend,    /* sends address and cmd */
  SMBbytewrite,   /* sends address and cmd and 1 byte */
  SMBwordwrite,   /* sends address and cmd and 2 bytes */

  /* read */
  SMBrecv,    /* sends address, recvs 1 byte */
  SMBbyteread,    /* sends address and cmd, recv's byte */
  SMBwordread,    /* sends address and cmd, recv's 2 bytes */
};

//typedef struct SMBus SMBus;
//struct SMBus {
//  QLock;    /* mutex */
//  Rendez  r;  /* rendezvous point for completion interrupts */
//  void  *arg; /* implementation dependent */
//  ulong base; /* port or memory base of smbus */
//  int busy;
//  void  (*transact)(SMBus*, int, int, int, uchar*);
//};

/*
 * PCMCIA support code.
 */

typedef struct PCMslot    PCMslot;
typedef struct PCMconftab PCMconftab;

/*
 * Map between ISA memory space and PCMCIA card memory space.
 */
struct PCMmap {
  ulong ca;     /* card address */
  ulong cea;      /* card end address */
  ulong isa;      /* ISA address */
  int len;      /* length of the ISA area */
  int attr;     /* attribute memory */
  int ref;
};

/* configuration table entry */
struct PCMconftab
{
  int index;
  ushort  irqs;   /* legal irqs */
  uchar irqtype;
  uchar bit16;    /* true for 16 bit access */
  struct {
    ulong start;
    ulong len;
  } io[16];
  int nio;
  uchar vpp1;
  uchar vpp2;
  uchar memwait;
  ulong maxwait;
  ulong readywait;
  ulong otherwait;
};

/* a card slot */
struct PCMslot
{
  Lock;
  int ref;

  void  *cp;    /* controller for this slot */
  long  memlen;   /* memory length */
  uchar base;   /* index register base */
  uchar slotno;   /* slot number */

  /* status */
  uchar special;  /* in use for a special device */
  uchar already;  /* already inited */
  uchar occupied;
  uchar battery;
  uchar wrprot;
  uchar powered;
  uchar configed;
  uchar enabled;
  uchar busy;

  /* cis info */
  ulong msec;   /* time of last slotinfo call */
  char  verstr[512];  /* version string */
  int ncfg;   /* number of configurations */
  struct {
    ushort  cpresent; /* config registers present */
    ulong caddr;    /* relative address of config registers */
  } cfg[8];
  int nctab;    /* number of config table entries */
  PCMconftab  ctab[8];
  PCMconftab  *def; /* default conftab */

  /* memory maps */
  Lock  mlock;    /* lock down the maps */
  int time;
  PCMmap  mmap[4];  /* maps, last is always for the kernel */
};

#pragma varargck  type  "T" int
#pragma varargck  type  "T" uint
@


\subsection*{[[arch/386/iomap.c]]}

<<iomap.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"

struct Iomapalloc iomap;

// to remove some backward dependencies, so that ioalloc()
// can be here instead of in devarch.c
void (*hook_ioalloc)() = nil;

void
ioinit(void)
{
    char *excluded;
    int i;

    for(i = 0; i < nelem(iomap.maps)-1; i++)
        iomap.maps[i].next = &iomap.maps[i+1];
    iomap.maps[i].next = nil;
    iomap.free = iomap.maps;

    /*
     * This is necessary to make the IBM X20 boot.
     * Have not tracked down the reason.
     * i82557 is at 0x1000, the dummy entry is needed for swappable devs.
     */
    ioalloc(0x0fff, 1, 0, "dummy");

    if ((excluded = getconf("ioexclude")) != nil) {
        char *s;

        s = excluded;
        while (s && *s != '\0' && *s != '\n') {
            char *ends;
            int io_s, io_e;

            io_s = (int)strtol(s, &ends, 0);
            if (ends == nil || ends == s || *ends != '-') {
                print("ioinit: cannot parse option string\n");
                break;
            }
            s = ++ends;

            io_e = (int)strtol(s, &ends, 0);
            if (ends && *ends == ',')
                *ends++ = '\0';
            s = ends;

            ioalloc(io_s, io_e - io_s + 1, 0, "pre-allocated");
        }
    }

}


/*
 *  alloc some io port space and remember who it was
 *  alloced to.  if port < 0, find a free region.
 */
int
ioalloc(int port, int size, int align, char *tag)
{
    IOMap *m, **l;
    int i;

    lock(&iomap);
    if(port < 0){
        /* find a free port above 0x400 and below 0x1000 */
        port = 0x400;
        for(l = &iomap.m; *l; l = &(*l)->next){
            m = *l;
            if (m->start < 0x400) continue;
            i = m->start - port;
            if(i > size)
                break;
            if(align > 0)
                port = ((port+align-1)/align)*align;
            else
                port = m->end;
        }
        if(*l == nil){
            unlock(&iomap);
            return -1;
        }
    } else {
        /* Only 64KB I/O space on the x86. */
        if((port+size) > 0x10000){
            unlock(&iomap);
            return -1;
        }
        /* see if the space clashes with previously allocated ports */
        for(l = &iomap.m; *l; l = &(*l)->next){
            m = *l;
            if(m->end <= port)
                continue;
            if(m->reserved && m->start == port && m->end == port + size) {
                m->reserved = 0;
                unlock(&iomap);
                return m->start;
            }
            if(m->start >= port+size)
                break;
            unlock(&iomap);
            return -1;
        }
    }
    m = iomap.free;
    if(m == nil){
        print("ioalloc: out of maps");
        unlock(&iomap);
        return port;
    }
    iomap.free = m->next;
    m->next = *l;
    m->start = port;
    m->end = port + size;
    strncpy(m->tag, tag, sizeof(m->tag));
    m->tag[sizeof(m->tag)-1] = 0;
    *l = m;

    //archdir[0].qid.vers++;
        if(hook_ioalloc) 
            hook_ioalloc();

    unlock(&iomap);
    return m->start;
}

void
iofree(int port)
{
    IOMap *m, **l;

    lock(&iomap);
    for(l = &iomap.m; *l; l = &(*l)->next){
        if((*l)->start == port){
            m = *l;
            *l = m->next;
            m->next = iomap.free;
            iomap.free = m;
            break;
        }
        if((*l)->start > port)
            break;
    }
    //archdir[0].qid.vers++;
        if(hook_ioalloc) 
            hook_ioalloc();

    unlock(&iomap);
}

///*
// * Reserve a range to be ioalloced later.
// * This is in particular useful for exchangable cards, such
// * as pcmcia and cardbus cards.
// */
//int
//ioreserve(int, int size, int align, char *tag)
//{
//  IOMap *m, **l;
//  int i, port;
//
//  lock(&iomap);
//  /* find a free port above 0x400 and below 0x1000 */
//  port = 0x400;
//  for(l = &iomap.m; *l; l = &(*l)->next){
//      m = *l;
//      if (m->start < 0x400) continue;
//      i = m->start - port;
//      if(i > size)
//          break;
//      if(align > 0)
//          port = ((port+align-1)/align)*align;
//      else
//          port = m->end;
//  }
//  if(*l == nil){
//      unlock(&iomap);
//      return -1;
//  }
//  m = iomap.free;
//  if(m == nil){
//      print("ioalloc: out of maps");
//      unlock(&iomap);
//      return port;
//  }
//  iomap.free = m->next;
//  m->next = *l;
//  m->start = port;
//  m->end = port + size;
//  m->reserved = 1;
//  strncpy(m->tag, tag, sizeof(m->tag));
//  m->tag[sizeof(m->tag)-1] = 0;
//  *l = m;
//
//  archdir[0].qid.vers++;
//
//  unlock(&iomap);
//  return m->start;
//}

@


\subsection*{[[arch/386/l_io.s]]}

<<l_io.s>>=
/*
 * Some machine instructions not handled by 8[al].
 */
#define OP16            BYTE $0x66

        
        
/*
 * Port I/O.
 *      in[bsl]         input a byte|short|long
 *      ins[bsl]        input a string of bytes|shorts|longs
 *      out[bsl]        output a byte|short|long
 *      outs[bsl]       output a string of bytes|shorts|longs
 */
TEXT inb(SB), $0
        MOVL    port+0(FP), DX
        XORL    AX, AX
        INB
        RET

//TEXT insb(SB), $0
//      MOVL    port+0(FP), DX
//      MOVL    address+4(FP), DI
//      MOVL    count+8(FP), CX
//      CLD
//      REP;    INSB
//      RET

TEXT ins(SB), $0
        MOVL    port+0(FP), DX
        XORL    AX, AX
        OP16;   INL
        RET

TEXT inss(SB), $0
        MOVL    port+0(FP), DX
        MOVL    address+4(FP), DI
        MOVL    count+8(FP), CX
        CLD
        REP;    OP16; INSL
        RET

TEXT inl(SB), $0
        MOVL    port+0(FP), DX
        INL
        RET

//TEXT insl(SB), $0
//      MOVL    port+0(FP), DX
//      MOVL    address+4(FP), DI
//      MOVL    count+8(FP), CX
//      CLD
//      REP;    INSL
//      RET

TEXT outb(SB), $0
        MOVL    port+0(FP), DX
        MOVL    byte+4(FP), AX
        OUTB
        RET

//TEXT outsb(SB), $0
//      MOVL    port+0(FP), DX
//      MOVL    address+4(FP), SI
//      MOVL    count+8(FP), CX
//      CLD
//      REP;    OUTSB
//      RET

TEXT outs(SB), $0
        MOVL    port+0(FP), DX
        MOVL    short+4(FP), AX
        OP16;   OUTL
        RET

TEXT outss(SB), $0
        MOVL    port+0(FP), DX
        MOVL    address+4(FP), SI
        MOVL    count+8(FP), CX
        CLD
        REP;    OP16; OUTSL
        RET

TEXT outl(SB), $0
        MOVL    port+0(FP), DX
        MOVL    long+4(FP), AX
        OUTL
        RET

//TEXT outsl(SB), $0
//      MOVL    port+0(FP), DX
//      MOVL    address+4(FP), SI
//      MOVL    count+8(FP), CX
//      CLD
//      REP;    OUTSL
//      RET


@


\subsection*{[[arch/386/l_realmode.s]]}

<<l_realmode.s>>=
#include "mem.h"
#include "x16.h"

//*****************************************************************************
// Helpers
//*****************************************************************************

/*
 * Save registers.
 */
TEXT saveregs(SB), $0
        /* appease 8l */
        SUBL $32, SP
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        POPL AX
        
        PUSHL   AX
        PUSHL   BX
        PUSHL   CX
        PUSHL   DX
        PUSHL   BP
        PUSHL   DI
        PUSHL   SI
        PUSHFL

        XCHGL   32(SP), AX      /* swap return PC and saved flags */
        XCHGL   0(SP), AX
        XCHGL   32(SP), AX
        RET

TEXT restoreregs(SB), $0
        /* appease 8l */
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        PUSHL   AX
        ADDL    $32, SP
        
        XCHGL   32(SP), AX      /* swap return PC and saved flags */
        XCHGL   0(SP), AX
        XCHGL   32(SP), AX

        POPFL
        POPL    SI
        POPL    DI
        POPL    BP
        POPL    DX
        POPL    CX
        POPL    BX
        POPL    AX
        RET


//*****************************************************************************
// Functions
//*****************************************************************************
                
/*
 * Assumed to be in protected mode at time of call.
 * Switch to real mode, execute an interrupt, and
 * then switch back to protected mode.  
 *
 * Assumes:
 *
 *      - no device interrupts are going to come in
 *      - 0-16MB is identity mapped in page tables
 *      - realmode() has copied us down from 0x100000 to 0x8000
 *      - can use code segment 0x0800 in real mode
 *              to get at l.s code
 *      - l.s code is less than 1 page
 */
#define RELOC   (RMCODE-KTZERO)

TEXT realmodeidtptr(SB), $0
        WORD    $(4*256-1)
        LONG    $0

TEXT realmode0(SB), $0
        CALL    saveregs(SB)

        /* switch to low code address */
        LEAL    physcode-KZERO(SB), AX
        JMP *AX

TEXT physcode(SB), $0

        /* switch to low stack */
        MOVL    SP, AX
        MOVL    $0x7C00, SP
        PUSHL   AX

        /* change gdt to physical pointer */
        MOVL    m0rgdtptr-KZERO(SB), GDTR

        /* load IDT with real-mode version*/
        MOVL    realmodeidtptr-KZERO(SB), IDTR

        /* edit INT $0x00 instruction below */
        MOVL    $(RMUADDR-KZERO+48), AX /* &rmu.trap */
        MOVL    (AX), AX
        MOVB    AX, realmodeintrinst+(-KZERO+1+RELOC)(SB)

        /* disable paging */
        MOVL    CR0, AX
        ANDL    $0x7FFFFFFF, AX
        MOVL    AX, CR0
        /* JMP .+2 to clear prefetch queue*/
        BYTE $0xEB; BYTE $0x00

        /* jump to 16-bit code segment */
/*      JMPFAR  SELECTOR(KESEG16, SELGDT, 0):$again16bit(SB) /**/
         BYTE   $0xEA
         LONG   $again16bit-KZERO(SB)
         WORD   $SELECTOR(KESEG16, SELGDT, 0)

TEXT again16bit(SB), $0
        /*
         * Now in 16-bit compatibility mode.
         * These are 32-bit instructions being interpreted
         * as 16-bit instructions.  I'm being lazy and
         * not using the macros because I know when
         * the 16- and 32-bit instructions look the same
         * or close enough.
         */

        /* disable protected mode and jump to real mode cs */
        OPSIZE; MOVL CR0, AX
        OPSIZE; XORL BX, BX
        OPSIZE; INCL BX
        OPSIZE; XORL BX, AX
        OPSIZE; MOVL AX, CR0

        /* JMPFAR 0x0800:now16real */
         BYTE $0xEA
         WORD   $now16real-KZERO(SB)
         WORD   $0x0800

TEXT now16real(SB), $0
        /* copy the registers for the bios call */
        LWI(0x0000, rAX)
        MOVW    AX,SS
        LWI(RMUADDR, rBP)
        
        /* offsets are in Ureg */
        LXW(44, xBP, rAX)
        MOVW    AX, DS
        LXW(40, xBP, rAX)
        MOVW    AX, ES

        OPSIZE; LXW(0, xBP, rDI)
        OPSIZE; LXW(4, xBP, rSI)
        OPSIZE; LXW(16, xBP, rBX)
        OPSIZE; LXW(20, xBP, rDX)
        OPSIZE; LXW(24, xBP, rCX)
        OPSIZE; LXW(28, xBP, rAX)

        CLC

TEXT realmodeintrinst(SB), $0
        INT $0x00
        CLI                     /* who knows what evil the bios got up to */

        /* save the registers after the call */

        LWI(0x7bfc, rSP)
        OPSIZE; PUSHFL
        OPSIZE; PUSHL AX

        LWI(0, rAX)
        MOVW    AX,SS
        LWI(RMUADDR, rBP)
        
        OPSIZE; SXW(rDI, 0, xBP)
        OPSIZE; SXW(rSI, 4, xBP)
        OPSIZE; SXW(rBX, 16, xBP)
        OPSIZE; SXW(rDX, 20, xBP)
        OPSIZE; SXW(rCX, 24, xBP)
        OPSIZE; POPL AX
        OPSIZE; SXW(rAX, 28, xBP)

        MOVW    DS, AX
        OPSIZE; SXW(rAX, 44, xBP)
        MOVW    ES, AX
        OPSIZE; SXW(rAX, 40, xBP)

        OPSIZE; POPL AX
        OPSIZE; SXW(rAX, 64, xBP)       /* flags */

        /* re-enter protected mode and jump to 32-bit code */
        OPSIZE; MOVL $1, AX
        OPSIZE; MOVL AX, CR0
        
/*      JMPFAR  SELECTOR(KESEG, SELGDT, 0):$again32bit(SB) /**/
         OPSIZE
         BYTE $0xEA
         LONG   $again32bit-KZERO(SB)
         WORD   $SELECTOR(KESEG, SELGDT, 0)

TEXT again32bit(SB), $0
        MOVW    $SELECTOR(KDSEG, SELGDT, 0),AX
        MOVW    AX,DS
        MOVW    AX,SS
        MOVW    AX,ES
        MOVW    AX,FS
        MOVW    AX,GS

        /* enable paging and jump to kzero-address code */
        MOVL    CR0, AX
        ORL     $0x80010000, AX /* PG|WP */
        MOVL    AX, CR0
        LEAL    again32kzero(SB), AX
        JMP*    AX

TEXT again32kzero(SB), $0
        /* breathe a sigh of relief - back in 32-bit protected mode */

        /* switch to old stack */       
        PUSHL   AX      /* match popl below for 8l */
        MOVL    $0x7BFC, SP
        POPL    SP

        /* restore idt */
        MOVL    m0idtptr(SB),IDTR

        /* restore gdt */
        MOVL    m0gdtptr(SB), GDTR

        CALL    restoreregs(SB)
        RET

/*
 * BIOS32.
 */
TEXT bios32call(SB), $0
        MOVL    ci+0(FP), BP
        MOVL    0(BP), AX
        MOVL    4(BP), BX
        MOVL    8(BP), CX
        MOVL    12(BP), DX
        MOVL    16(BP), SI
        MOVL    20(BP), DI
        PUSHL   BP

        MOVL    12(SP), BP                      /* ptr */
        BYTE $0xFF; BYTE $0x5D; BYTE $0x00      /* CALL FAR 0(BP) */

        POPL    BP
        MOVL    DI, 20(BP)
        MOVL    SI, 16(BP)
        MOVL    DX, 12(BP)
        MOVL    CX, 8(BP)
        MOVL    BX, 4(BP)
        MOVL    AX, 0(BP)

        XORL    AX, AX
        JCC     _bios32xxret
        INCL    AX

_bios32xxret:
        RET

@


\subsection*{[[arch/386/mp.h]]}

<<mp.h>>=
/*
 * MultiProcessor Specification Version 1.[14].
 */
struct _MP_ {     /* floating pointer */
  uchar signature[4];   /* "_MP_" */
  long  physaddr;   /* physical address of MP configuration table */
  uchar length;     /* 1 */
  uchar specrev;    /* [14] */
  uchar checksum;   /* all bytes must add up to 0 */
  uchar type;     /* MP system configuration type */
  uchar imcrp;
  uchar reserved[3];
};

struct PCMP {     /* configuration table header */
  uchar signature[4];   /* "PCMP" */
  ushort  length;     /* total table length */
  uchar version;    /* [14] */
  uchar checksum;   /* all bytes must add up to 0 */
  uchar product[20];    /* product id */
  ulong oemtable;   /* OEM table pointer */
  ushort  oemlength;    /* OEM table length */
  ushort  entry;      /* entry count */
  ulong lapicbase;    /* address of local APIC */
  ushort  xlength;    /* extended table length */
  uchar xchecksum;    /* extended table checksum */
  uchar reserved;
};

struct PCMPprocessor {      /* processor table entry */
  uchar type;     /* entry type (0) */
  uchar apicno;     /* local APIC id */
  uchar version;    /* local APIC verison */
  uchar flags;      /* CPU flags */
  uchar signature[4];   /* CPU signature */
  ulong feature;    /* feature flags from CPUID instruction */
  uchar reserved[8];
};

struct PCMPbus {      /* bus table entry */
  uchar type;     /* entry type (1) */
  uchar busno;      /* bus id */
  char  string[6];    /* bus type string */
};

struct PCMPioapic {     /* I/O APIC table entry */
  uchar type;     /* entry type (2) */
  uchar apicno;     /* I/O APIC id */
  uchar version;    /* I/O APIC version */
  uchar flags;      /* I/O APIC flags */
  ulong addr;     /* I/O APIC address */
};

struct PCMPintr {     /* interrupt table entry */
  uchar type;     /* entry type ([34]) */
  uchar intr;     /* interrupt type */
  ushort  flags;      /* interrupt flag */
  uchar busno;      /* source bus id */
  uchar irq;      /* source bus irq */
  uchar apicno;     /* destination APIC id */
  uchar intin;      /* destination APIC [L]INTIN# */
};

//struct PCMPsasm {     /* system address space mapping entry */
//  uchar type;     /* entry type (128) */
//  uchar length;     /* of this entry (20) */
//  uchar busno;      /* bus id */
//  uchar addrtype;
//  ulong addrbase[2];
//  ulong addrlength[2];
//};

//struct PCMPhierarchy {      /* bus hierarchy descriptor entry */
//  uchar type;     /* entry type (129) */
//  uchar length;     /* of this entry (8) */
//  uchar busno;      /* bus id */
//  uchar info;     /* bus info */
//  uchar parent;     /* parent bus */
//  uchar reserved[3];
//};

//struct PCMPcbasm {      /* compatibility bus address space modifier entry */
//  uchar type;     /* entry type (130) */
//  uchar length;     /* of this entry (8) */
//  uchar busno;      /* bus id */
//  uchar modifier;   /* address modifier */
//  ulong range;      /* predefined range list */
//};

typedef struct PCMP PCMP;
typedef struct _MP_ _MP_;
typedef struct PCMPprocessor PCMPprocessor;
typedef struct PCMPbus PCMPbus;
typedef struct PCMPioapic PCMPioapic;
typedef struct PCMPintr PCMPintr;
//typedef struct PCMPsasm PCMPsasm;
//typedef struct PCMPhierarchy PCMPhierarchy;
//typedef struct PCMPcbasm PCMPcbasm;

enum {          /* table entry types */
  PcmpPROCESSOR = 0x00,   /* one entry per processor */
  PcmpBUS   = 0x01,   /* one entry per bus */
  PcmpIOAPIC  = 0x02,   /* one entry per I/O APIC */
  PcmpIOINTR  = 0x03,   /* one entry per bus interrupt source */
  PcmpLINTR = 0x04,   /* one entry per system interrupt source */

  PcmpSASM  = 0x80,
  PcmpHIERARCHY = 0x81,
  PcmpCBASM = 0x82,

          /* PCMPprocessor and PCMPioapic flags */
  PcmpEN    = 0x01,   /* enabled */
  PcmpBP    = 0x02,   /* bootstrap processor */

          /* PCMPiointr and PCMPlintr flags */
  PcmpPOMASK  = 0x03,   /* polarity conforms to specifications of bus */
  PcmpHIGH  = 0x01,   /* active high */
  PcmpLOW   = 0x03,   /* active low */
  PcmpELMASK  = 0x0C,   /* trigger mode of APIC input signals */
  PcmpEDGE  = 0x04,   /* edge-triggered */
  PcmpLEVEL = 0x0C,   /* level-triggered */

          /* PCMPiointr and PCMPlintr interrupt type */
  PcmpINT   = 0x00,   /* vectored interrupt from APIC Rdt */
  PcmpNMI   = 0x01,   /* non-maskable interrupt */
  PcmpSMI   = 0x02,   /* system management interrupt */
  PcmpExtINT  = 0x03,   /* vectored interrupt from external PIC */

          /* PCMPsasm addrtype */
  PcmpIOADDR  = 0x00,   /* I/O address */
  PcmpMADDR = 0x01,   /* memory address */
  PcmpPADDR = 0x02,   /* prefetch address */

          /* PCMPhierarchy info */
  PcmpSD    = 0x01,   /* subtractive decode bus */

          /* PCMPcbasm modifier */
  PcmpPR    = 0x01,   /* predefined range list */
};

/*
 * Condensed form of the MP Configuration Table.
 * This is created during a single pass through the MP Configuration
 * table.
 */
typedef struct Aintr Aintr;
typedef struct Bus Bus;
typedef struct Apic Apic;

typedef struct Bus {
  uchar type;
  uchar busno;
  uchar po;
  uchar el;

  Aintr*  aintr;      /* interrupts tied to this bus */
  Bus*  next;
} Bus;

struct Aintr {
  PCMPintr* intr;
  Apic* apic;
  Aintr*  next;
};

struct Apic {
  int type;
  int apicno;
  ulong*  addr;     /* register base address */
  ulong paddr;
  int flags;      /* PcmpBP|PcmpEN */

  Lock;       /* I/O APIC: register access */
  int mre;      /* I/O APIC: maximum redirection entry */

  int lintr[2];   /* Local APIC */
  int machno;

  int online;
};

enum {
  MaxAPICNO = 254,    /* 255 is physical broadcast */
};

enum {          /* I/O APIC registers */
  IoapicID  = 0x00,   /* ID */
  IoapicVER = 0x01,   /* version */
  IoapicARB = 0x02,   /* arbitration ID */
  IoapicRDT = 0x10,   /* redirection table */
};

/*
 * Common bits for
 *  I/O APIC Redirection Table Entry;
 *  Local APIC Local Interrupt Vector Table;
 *  Local APIC Inter-Processor Interrupt;
 *  Local APIC Timer Vector Table.
 */
enum {
  ApicFIXED = 0x00000000, /* [10:8] Delivery Mode */
  ApicLOWEST  = 0x00000100, /* Lowest priority */
  ApicSMI   = 0x00000200, /* System Management Interrupt */
  ApicRR    = 0x00000300, /* Remote Read */
  ApicNMI   = 0x00000400,
  ApicINIT  = 0x00000500, /* INIT/RESET */
  ApicSTARTUP = 0x00000600, /* Startup IPI */
  ApicExtINT  = 0x00000700,

  ApicPHYSICAL  = 0x00000000, /* [11] Destination Mode (RW) */
  ApicLOGICAL = 0x00000800,

  ApicDELIVS  = 0x00001000, /* [12] Delivery Status (RO) */
  ApicHIGH  = 0x00000000, /* [13] Interrupt Input Pin Polarity (RW) */
  ApicLOW   = 0x00002000,
  ApicRemoteIRR = 0x00004000, /* [14] Remote IRR (RO) */
  ApicEDGE  = 0x00000000, /* [15] Trigger Mode (RW) */
  ApicLEVEL = 0x00008000,
  ApicIMASK = 0x00010000, /* [16] Interrupt Mask */
};

extern void ioapicinit(Apic*, int);
extern void ioapicrdtr(Apic*, int, int*, int*);
extern void ioapicrdtw(Apic*, int, int, int);

extern void lapicclock(Ureg*, void*);
extern int lapiceoi(int);
extern void lapicerror(Ureg*, void*);
extern void lapicicrw(ulong, ulong);
extern void lapicinit(Apic*);
extern void lapicintroff(void);
extern void lapicintron(void);
extern int lapicisr(int);
//extern void lapicnmidisable(void);
//extern void lapicnmienable(void);
extern void lapiconline(void);
extern void lapicspurious(Ureg*, void*);
extern void lapicstartap(Apic*, int);
extern void lapictimerset(uvlong);

extern void mpinit(void);
extern int mpintrenable(Vctl*);
extern void mpshutdown(void);

extern _MP_ *_mp_;
@


\subsection*{[[arch/386/mpacpi.h]]}

<<mpacpi.h>>=
/*
 * ACPI definitions
 *
 * A System Descriptor Table starts with a header of 4 bytes of signature
 * followed by 4 bytes of total table length then 28 bytes of ID information
 * (including the table checksum).
 */
typedef struct Dsdt Dsdt;
typedef struct Facp Facp;
typedef struct Hpet Hpet;
typedef struct Madt Madt;
typedef struct Mcfg Mcfg;
typedef struct Mcfgd Mcfgd;
typedef struct Rsd Rsd;

//struct Dsdt {       /* Differentiated System DT */
//  uchar sdthdr[36];   /* "DSDT" + length[4] + [28] */
//  uchar db[];     /* Definition Block */
//};
//struct Facp {       /* Fixed ACPI DT */
//  uchar sdthdr[36];   /* "FACP" + length[4] + [28] */
//  uchar faddr[4];   /* Firmware Control Address */
//  uchar dsdt[4];    /* DSDT Address */
//  uchar pad[200];   /* total table is 244 */
//};
//struct Hpet {       /* High-Precision Event Timer DT */
//  uchar sdthdr[36];   /* "HPET" + length[4] + [28] */
//  uchar id[4];      /* Event Timer Block ID */
//  uchar addr[12];   /* ACPI Format Address */
//  uchar seqno;      /* Sequence Number */
//  uchar minticks[2];    /* Minimum Clock Tick */
//  uchar attr;     /* Page Protection */
//};
//@Scheck: type deps on params
struct Madt {       /* Multiple APIC DT */
  uchar sdthdr[36];   /* "MADT" + length[4] + [28] */
  uchar addr[4];    /* Local APIC Address */
  uchar flags[4];
  uchar structures[];
};
//typedef struct Mcfg {     /* PCI Memory Mapped Config */
//  uchar sdthdr[36];   /* "MCFG" + length[4] + [28] */
//  uchar pad[8];     /* reserved */
//  Mcfgd mcfgd[];    /* descriptors */
//} Mcfg;
//struct Mcfgd {        /* MCFG Descriptor */
//  uchar addr[8];    /* base address */
//  uchar segno[2];   /* segment group number */
//  uchar sbno;     /* start bus number */
//  uchar ebno;     /* end bus number */
//  uchar pad[4];     /* reserved */
//};
struct Rsd {        /* Root System Description * */
  uchar signature[8];   /* "RSD PTR " */
  uchar rchecksum;
  uchar oemid[6];
  uchar revision;
  uchar raddr[4];   /* RSDT */
  uchar length[4];
  uchar xaddr[8];   /* XSDT */
  uchar xchecksum;    /* XSDT */
  uchar pad[3];     /* reserved */
};
@


\subsection*{[[arch/386/nvram.c]]}

<<nvram.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// used to be static
Lock nvrtlock;


uchar
nvramread(int addr)
{
    uchar data;

    ilock(&nvrtlock);
    outb(Paddr, addr);
    data = inb(PdataPort);
    iunlock(&nvrtlock);

    return data;
}

void
nvramwrite(int addr, uchar data)
{
    ilock(&nvrtlock);
    outb(Paddr, addr);
    outb(PdataPort, data);
    iunlock(&nvrtlock);
}
@


\subsection*{[[arch/386/realmode.c]]}

<<realmode.c>>=
#include    "u.h"
#include    "tos.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "io.h"
#include    "ureg.h"
#include    "../port/error.h"

/*
 * Back the processor into real mode to run a BIOS call,
 * then return.  This must be used carefully, since it 
 * completely disables hardware interrupts (e.g., the i8259)
 * while running.  It is *not* using VM86 mode. 
 * Maybe that's really the right answer, but real mode
 * is fine for now.  We don't expect to use this very much --
 * just for VGA and APM.
 */
#define realmoderegs (*(Ureg*)RMUADDR)

#define LORMBUF (RMBUF-KZERO)

static Ureg rmu;
static Lock rmlock;

//@Scheck: Assembly
extern void realmode0(void);    /* in l.s */

void
realmode(Ureg *ureg)
{
    int s;
    ulong cr3;

    if(getconf("*norealmode"))
        return;

    lock(&rmlock);
    realmoderegs = *ureg;

    /* copy l.s so that it can be run from 16-bit mode */
    memmove((void*)RMCODE, (void*)KTZERO, 0x1000);

    s = splhi();
    m->pdb[PDX(0)] = m->pdb[PDX(KZERO)];    /* identity map low */
    cr3 = getcr3();
    putcr3(PADDR(m->pdb));
    if (arch)
        arch->introff();
    else
        i8259off();
    realmode0();
    if(m->tss){
        /*
         * Called from memory.c before initialization of mmu.
         * Don't turn interrupts on before the kernel is ready!
         */
        if (arch)
            arch->intron();
        else
            i8259on();
    }
    m->pdb[PDX(0)] = 0; /* remove low mapping */
    putcr3(cr3);
    splx(s);
    *ureg = realmoderegs;
    unlock(&rmlock);
}

static long
rtrapread(Chan*, void *a, long n, vlong off)
{
    if(off < 0)
        error("badarg");
    if(n+off > sizeof rmu)
        n = sizeof rmu - off;
    if(n <= 0)
        return 0;
    memmove(a, (char*)&rmu+off, n);
    return n;
}

static long
rtrapwrite(Chan*, void *a, long n, vlong off)
{
    if(off || n != sizeof rmu)
        error("write a Ureg");
    memmove(&rmu, a, sizeof rmu);
    /*
     * Sanity check
     */
    if(rmu.trap == 0x10){   /* VBE */
        rmu.es = (LORMBUF>>4)&0xF000;
        rmu.di = LORMBUF&0xFFFF;
    }else
        error("invalid trap arguments");
    realmode(&rmu);
    return n;
}

static long
rmemrw(int isr, void *a, long n, vlong off)
{
    if(off < 0 || n < 0)
        error("bad offset/count");
    if(isr){
        if(off >= MB)
            return 0;
        if(off+n >= MB)
            n = MB - off;
        memmove(a, KADDR((ulong)off), n);
    }else{
        /* realmode buf page ok, allow vga framebuf's access */
        if(off >= MB || off+n > MB ||
            (off < LORMBUF || off+n > LORMBUF+BY2PG) &&
            (off < 0xA0000 || off+n > 0xB0000+0x10000))
            error("bad offset/count in write");
        memmove(KADDR((ulong)off), a, n);
    }
    return n;
}

static long
rmemread(Chan*, void *a, long n, vlong off)
{
    return rmemrw(1, a, n, off);
}

static long
rmemwrite(Chan*, void *a, long n, vlong off)
{
    return rmemrw(0, a, n, off);
}

void
realmodelink(void)
{
    addarchfile("realmode", 0660, rtrapread, rtrapwrite);
    addarchfile("realmodemem", 0660, rmemread, rmemwrite);
}

@


\subsection*{[[arch/386/x16.h]]}

<<x16.h>>=
/*
 * Can't write 16-bit code for 8a without getting into
 * lots of bother, so define some simple commands and
 * output the code directly.
 * 
 * N.B. CALL16(x) kills DI, so don't expect it to be
 * saved across calls.
 */
#define rAX		0		/* rX  */
#define rCX		1
#define rDX		2
#define rBX		3
#define rSP		4		/* SP */
#define rBP		5		/* BP */
#define rSI		6		/* SI */
#define rDI		7		/* DI */

#define rAL		0		/* rL  */
#define rCL		1
#define rDL		2
#define rBL		3
#define rAH		4		/* rH */
#define rCH		5
#define rDH		6
#define rBH		7

#define rES		0		/* rS */
#define rCS		1
#define rSS		2
#define rDS		3
#define rFS		4
#define rGS		5

#define xSI		4		/* rI (index) */
#define xDI		5
#define xBP		6
#define xBX		7

#define rCR0		0		/* rC */
#define rCR2		2
#define rCR3		3
#define rCR4		4

#define OP(o, m, ro, rm)	BYTE $o;	/* op + modr/m byte */	\
   BYTE $(((m)<<6)|((ro)<<3)|(rm))
#define OPrm(o, r, m)	OP(o, 0x00, r, 0x06);	/* general r <-> m */	\
   WORD $m;
#define OPrr(o, r0, r1)	OP(o, 0x03, r0, r1);	/* general r -> r */

#define LW(m, rX)	OPrm(0x8B, rX, m)	/* m -> rX */
#define LXW(x, rI, r)	OP(0x8B, 0x02, r, rI);	/* x(rI) -> r */	\
   WORD $x
#define LBPW(x, r)	OP(0x8B, 0x02, r, xBP);	/* x(rBP) -> r */	\
   WORD $x
#define LB(m, rB)	OPrm(0x8A, rB, m)	/* m -> r[HL] */
#define LXB(x, rI, r)	OP(0x8A, 0x01, r, rI);	/* x(rI) -> r */	\
   BYTE $x
#define LBPB(x, r)	OP(0x8A, 0x01, r, xBP);	/* x(rBP) -> r */	\
   BYTE $x
#define SW(rX, m)	OPrm(0x89, rX, m)	/* rX -> m */
#define SXW(r, x, rI)	OP(0x89, 0x02, r, rI);	/* r -> x(rI) */	\
   WORD $x
#define SBPW(r, x)	OP(0x89, 0x02, r, xBP);	/* r -> x(rBP) */	\
   WORD $(x)
#define SBPWI(i, x)	OP(0xC7, 0x01, 0, xBP);	/* i -> x(rBP) */	\
   BYTE $(x); WORD $(i)
#define STB(rB, m)	OPrm(0x88, rB, m)	/* rB -> m */
#define SXB(r, x, rI)	OP(0x88, 0x01, r, rI);	/* rB -> x(rI) */	\
   BYTE $x
#define SBPB(r, x)	OP(0x88, 0x01, r, xBP);	/* r -> x(rBP) */	\
   BYTE $x
#define SBPBI(i, x)	OP(0xC6, 0x01, 0, xBP);	/* i -> x(rBP) */	\
   BYTE $(x); BYTE $(i)
#define LWI(i, rX)	BYTE $(0xB8+rX);	/* i -> rX */		\
   WORD $i;
#define LBI(i, rB)	BYTE $(0xB0+rB);	/* i -> r[HL] */	\
   BYTE $i

#define MW(r0, r1)	OPrr(0x89, r0, r1)	/* r0 -> r1 */
#define MFSR(rS, rX)	OPrr(0x8C, rS, rX)	/* rS -> rX */
#define MTSR(rX, rS)	OPrr(0x8E, rS, rX)	/* rX -> rS */
#define MFCR(rC, rX)	BYTE $0x0F;		/* rC -> rX */		\
   OP(0x20, 0x03, rC, rX)
#define MTCR(rX, rC)	BYTE $0x0F;		/* rX -> rC */		\
   OP(0x22, 0x03, rC, rX)

#define ADC(r0, r1)	OPrr(0x11, r0, r1)	/* r0 + r1 -> r1 */
#define ADD(r0, r1)	OPrr(0x01, r0, r1)	/* r0 + r1 -> r1 */
#define ADDI(i, r)	OP(0x81, 0x03, 0x00, r);/* i+r -> r */		\
   WORD $i;
#define AND(r0, r1)	OPrr(0x21, r0, r1)	/* r0&r1 -> r1 */
#define ANDI(i, r)	OP(0x81, 0x03, 0x04, r);/* i&r -> r */		\
   WORD $i;
#define CLR(r)		OPrr(0x31, r, r)	/* r^r -> r */
#define CLRB(r)		OPrr(0x30, r, r)	/* r^r -> r */
#define CMP(r0, r1)	OPrr(0x39, r0, r1)	/* r1-r0 -> flags */
#define CMPI(i, r)	OP(0x81, 0x03, 0x07, r);/* r-i -> flags */	\
   WORD $i;
#define CMPBR(r0, r1)	OPrr(0x38, r0, r1)	/* r1-r0 -> flags */
#define DEC(r)		BYTE $(0x48|r)		/* r-1 -> r */
#define DIV(r)		OPrr(0xF7, 0x06, r)	/* rDX:rAX/r -> rAX, rDX:rAX%r -> rDX */
#define INC(r)		BYTE $(0x40|r)		/* r+1 -> r */
#define MUL(r)		OPrr(0xF7, 0x04, r)	/* r*rAX -> rDX:rAX */
#define IMUL(r0, r1)	BYTE $0x0F;		/* r0*r1 -> r1 */	\
   OPrr(0xAF, r1, r0)	/* (signed) */
#define OR(r0, r1)	OPrr(0x09, r0, r1)	/* r0|r1 -> r1 */
#define ORB(r0, r1)	OPrr(0x08, r0, r1)	/* r0|r1 -> r1 */
#define ORI(i, r)	OP(0x81, 0x03, 0x01, r);/* i|r -> r */		\
   WORD $i;
#define ROLI(i, r)	OPrr(0xC1, 0x00, r);	/* r<<>>i -> r */	\
   BYTE $i;
#define SHLI(i, r)	OPrr(0xC1, 0x04, r);	/* r<<i -> r */		\
   BYTE $i;
#define SHLBI(i, r)	OPrr(0xC0, 0x04, r);	/* r<<i -> r */		\
   BYTE $i;
#define SHRI(i, r)	OPrr(0xC1, 0x05, r);	/* r>>i -> r */		\
   BYTE $i;
#define SHRBI(i, r)	OPrr(0xC0, 0x05, r);	/* r>>i -> r */		\
   BYTE $i;
#define SUB(r0, r1)	OPrr(0x29, r0, r1)	/* r1-r0 -> r1 */
#define SUBI(i, r)	OP(0x81, 0x03, 0x05, r);/* r-i -> r */		\
   WORD $i;

#define STOSW		STOSL

#define CALL16(f)	LWI(f, rDI);		/* &f -> rDI */		\
   BYTE $0xFF;		/* (*rDI) */		\
   BYTE $0xD7;
#define FARJUMP16(s, o)	BYTE $0xEA;		/* jump to ptr16:16 */	\
   WORD $o; WORD $s
#define FARJUMP32(s, o)	BYTE $0x66;		/* jump to ptr32:16 */	\
   BYTE $0xEA; LONG $o; WORD $s
#define	DELAY		BYTE $0xEB;		/* jmp .+2 */		\
   BYTE $0x00
#define BIOSCALL(b)	INT $b			/* INT $b */

#define PEEKW		BYTE $0x26;		/* MOVW	rES:[rBX], rAX  */	\
   BYTE $0x8B; BYTE $0x07
#define POKEW		BYTE $0x26;		/* MOVW	rAX, rES:[rBX] */	\
   BYTE $0x89; BYTE $0x07
#define OUTPORTB(p, d)	LBI(d, rAL);		/* d -> I/O port p */	\
   BYTE $0xE6;					\
   BYTE $p; DELAY
#define PUSHA		BYTE $0x60
#define PUSHR(r)	BYTE $(0x50|r)		/* r  -> (--rSP) */
#define PUSHS(rS)	BYTE $(0x06|((rS)<<3))	/* rS  -> (--rSP) */
#define PUSHI(i)	BYTE $0x68; WORD $i;	/* i -> --(rSP) */
#define POPA		BYTE $0x61
#define POPR(r)		BYTE $(0x58|r)		/* (rSP++) -> r */
#define POPS(rS)	BYTE $(0x07|((rS)<<3))	/* (rSP++) -> r */
#define NOP		BYTE $0x90		/* nop */

#define LGDT(gdtptr)	BYTE $0x0F;		/* LGDT */			\
   BYTE $0x01; BYTE $0x16;					\
   WORD $gdtptr

/* operand size switch. */
#define OPSIZE		BYTE $0x66

@


\subsection*{[[arch/386/x86.c]]}

<<x86.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"

//#define X86STEPPING(x)  ((x) & 0x0F)
/* incorporates extended-model and -family bits */
#define X86MODEL(x) ((((x)>>4) & 0x0F) | (((x)>>16) & 0x0F)<<4)


//@Scheck: Assembly l.s
void    _cycles(uvlong*);   

enum {
    CR4Osfxsr = 1 << 9,
};

enum {              /* cpuid standard function codes */
    Highstdfunc = 0,    /* also returns vendor string */
    Procsig,
    Proctlbcache,
    Procserial,
};



/* cpuid ax is 0x0ffMTFmS, where 0xffF is family, 0xMm is model */
static X86type x86intel[] =
{
    { 4,    0,  22, "486DX", }, /* known chips */
    { 4,    1,  22, "486DX50", },
    { 4,    2,  22, "486SX", },
    { 4,    3,  22, "486DX2", },
    { 4,    4,  22, "486SL", },
    { 4,    5,  22, "486SX2", },
    { 4,    7,  22, "DX2WB", }, /* P24D */
    { 4,    8,  22, "DX4", },   /* P24C */
    { 4,    9,  22, "DX4WB", }, /* P24CT */
    { 5,    0,  23, "P5", },
    { 5,    1,  23, "P5", },
    { 5,    2,  23, "P54C", },
    { 5,    3,  23, "P24T", },
    { 5,    4,  23, "P55C MMX", },
    { 5,    7,  23, "P54C VRT", },
    { 6,    1,  16, "PentiumPro", },/* trial and error */
    { 6,    3,  16, "PentiumII", },
    { 6,    5,  16, "PentiumII/Xeon", },
    { 6,    6,  16, "Celeron", },
    { 6,    7,  16, "PentiumIII/Xeon", },
    { 6,    8,  16, "PentiumIII/Xeon", },
    { 6,    0xB,    16, "PentiumIII/Xeon", },
    { 6,    0xF,    16, "Core 2/Xeon", },
    { 6,    0x16,   16, "Celeron", },
    { 6,    0x17,   16, "Core 2/Xeon", },
    { 6,    0x1A,   16, "Core i7/Xeon", },
    { 6,    0x1C,   16, "Atom", },
    { 6,    0x1D,   16, "Xeon MP", },
    { 6,    0x1E,   16, "Core i5/i7/Xeon", },
    { 6,    0x1F,   16, "Core i7/Xeon", },
    { 6,    0x22,   16, "Core i7", },
    { 6,    0x25,   16, "Core i3/i5/i7", },
    { 6,    0x2A,   16, "Core i7", },
    { 6,    0x2C,   16, "Core i7/Xeon", },
    { 6,    0x2D,   16, "Core i7", },
    { 6,    0x2E,   16, "Xeon MP", },
    { 6,    0x2F,   16, "Xeon MP", },
    { 6,    0x3A,   16, "Core i7", },
    { 0xF,  1,  16, "P4", },    /* P4 */
    { 0xF,  2,  16, "PentiumIV/Xeon", },
    { 0xF,  6,  16, "PentiumIV/Xeon", },

    { 3,    -1, 32, "386", },   /* family defaults */
    { 4,    -1, 22, "486", },
    { 5,    -1, 23, "P5", },
    { 6,    -1, 16, "P6", },
    { 0xF,  -1, 16, "P4", },    /* P4 */

    { -1,   -1, 16, "unknown", },   /* total default */
};

/*
 * The AMD processors all implement the CPUID instruction.
 * The later ones also return the processor name via functions
 * 0x80000002, 0x80000003 and 0x80000004 in registers AX, BX, CX
 * and DX:
 *  K5  "AMD-K5(tm) Processor"
 *  K6  "AMD-K6tm w/ multimedia extensions"
 *  K6 3D   "AMD-K6(tm) 3D processor"
 *  K6 3D+  ?
 */
static X86type x86amd[] =
{
    { 5,    0,  23, "AMD-K5", },    /* guesswork */
    { 5,    1,  23, "AMD-K5", },    /* guesswork */
    { 5,    2,  23, "AMD-K5", },    /* guesswork */
    { 5,    3,  23, "AMD-K5", },    /* guesswork */
    { 5,    4,  23, "AMD Geode GX1", }, /* guesswork */
    { 5,    5,  23, "AMD Geode GX2", }, /* guesswork */
    { 5,    6,  11, "AMD-K6", },    /* trial and error */
    { 5,    7,  11, "AMD-K6", },    /* trial and error */
    { 5,    8,  11, "AMD-K6-2", },  /* trial and error */
    { 5,    9,  11, "AMD-K6-III", },/* trial and error */
    { 5,    0xa,    23, "AMD Geode LX", },  /* guesswork */

    { 6,    1,  11, "AMD-Athlon", },/* trial and error */
    { 6,    2,  11, "AMD-Athlon", },/* trial and error */

    { 0x1F, 9,  11, "AMD-K10 Opteron G34", },/* guesswork */

    { 4,    -1, 22, "Am486", }, /* guesswork */
    { 5,    -1, 23, "AMD-K5/K6", }, /* guesswork */
    { 6,    -1, 11, "AMD-Athlon", },/* guesswork */
    { 0xF,  -1, 11, "AMD-K8", },    /* guesswork */
    { 0x1F, -1, 11, "AMD-K10", },   /* guesswork */

    { -1,   -1, 11, "unknown", },   /* total default */
};

/*
 * WinChip 240MHz
 */
static X86type x86winchip[] =
{
    {5, 4,  23, "Winchip",},    /* guesswork */
    {6, 7,  23, "Via C3 Samuel 2 or Ezra",},
    {6, 8,  23, "Via C3 Ezra-T",},
    {6, 9,  23, "Via C3 Eden-N",},
    { -1,   -1, 23, "unknown", },   /* total default */
};

/*
 * SiS 55x
 */
static X86type x86sis[] =
{
    {5, 0,  23, "SiS 55x",},    /* guesswork */
    { -1,   -1, 23, "unknown", },   /* total default */
};

X86type *cputype;


/*
 *  figure out:
 *  - cpu type
 *  - whether or not we have a TSC (cycle counter)
 *  - whether or not it supports page size extensions
 *      (if so turn it on)
 *  - whether or not it supports machine check exceptions
 *      (if so turn it on)
 *  - whether or not it supports the page global flag
 *      (if so turn it on)
 */
int
cpuidentify(void)
{
    char *p;
    int family, model, nomce;
    X86type *t, *tab;
    ulong cr4;
    ulong regs[4];
    vlong mca, mct;

    cpuid(Highstdfunc, regs);
    memmove(m->cpuidid,   &regs[1], BY2WD); /* bx */
    memmove(m->cpuidid+4, &regs[3], BY2WD); /* dx */
    memmove(m->cpuidid+8, &regs[2], BY2WD); /* cx */
    m->cpuidid[12] = '\0';

    cpuid(Procsig, regs);
    m->cpuidax = regs[0];
    m->cpuiddx = regs[3];

    if(strncmp(m->cpuidid, "AuthenticAMD", 12) == 0 ||
       strncmp(m->cpuidid, "Geode by NSC", 12) == 0)
        tab = x86amd;
    else if(strncmp(m->cpuidid, "CentaurHauls", 12) == 0)
        tab = x86winchip;
    else if(strncmp(m->cpuidid, "SiS SiS SiS ", 12) == 0)
        tab = x86sis;
    else
        tab = x86intel;

    family = X86FAMILY(m->cpuidax);
    model = X86MODEL(m->cpuidax);
    for(t=tab; t->name; t++)
        if((t->family == family && t->model == model)
        || (t->family == family && t->model == -1)
        || (t->family == -1))
            break;

    m->cpuidtype = t->name;

    /*
     *  if there is one, set tsc to a known value
     */
    if(m->cpuiddx & Tsc){
        m->havetsc = 1;
        cycles = _cycles;
        if(m->cpuiddx & Cpumsr)
            wrmsr(0x10, 0);
    }

    /*
     *  use i8253 to guess our cpu speed
     */
    guesscpuhz(t->aalcycles);

    /*
     * If machine check exception, page size extensions or page global bit
     * are supported enable them in CR4 and clear any other set extensions.
     * If machine check was enabled clear out any lingering status.
     */
    if(m->cpuiddx & (Pge|Mce|Pse)){
        cr4 = 0;
        if(m->cpuiddx & Pse)
            cr4 |= 0x10;        /* page size extensions */
        if(p = getconf("*nomce"))
            nomce = strtoul(p, 0, 0);
        else
            nomce = 0;
        if((m->cpuiddx & Mce) && !nomce){
            cr4 |= 0x40;        /* machine check enable */
            if(family == 5){
                rdmsr(0x00, &mca);
                rdmsr(0x01, &mct);
            }
        }

        /*
         * Detect whether the chip supports the global bit
         * in page directory and page table entries.  When set
         * in a particular entry, it means ``don't bother removing
         * this from the TLB when CR3 changes.''
         *
         * We flag all kernel pages with this bit.  Doing so lessens the
         * overhead of switching processes on bare hardware,
         * even more so on VMware.  See mmu.c:/^memglobal.
         *
         * For future reference, should we ever need to do a
         * full TLB flush, it can be accomplished by clearing
         * the PGE bit in CR4, writing to CR3, and then
         * restoring the PGE bit.
         */
        if(m->cpuiddx & Pge){
            cr4 |= 0x80;        /* page global enable bit */
            m->havepge = 1;
        }

        putcr4(cr4);
        if(m->cpuiddx & Mce)
            rdmsr(0x01, &mct);
    }

    if(m->cpuiddx & Fxsr){          /* have sse fp? */
        fpsave = fpssesave;
        fprestore = fpsserestore;
        putcr4(getcr4() | CR4Osfxsr);
    } else {
        fpsave = fpx87save;
        fprestore = fpx87restore;
    }

    cputype = t;
    return t->family;
}




@


\section{[[boot/]]}

\subsection*{[[boot/aux.c]]}

<<aux.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

void
warning(char *s)
{
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    fprint(2, "boot: %s: %s\n", s, buf);
}

void
fatal(char *s)
{
    char *msg;
    char buf[ERRMAX];

    buf[0] = '\0';
    errstr(buf, sizeof buf);
    msg = smprint("%s: %s", s, buf);
    fprint(2, "boot: %s\n", msg);
    exits(msg);         /* this will trigger a panic */
}

void
runv(char **argv)
{
  int i, pid;
  
  switch(pid = fork()){
  case -1:
    fatal("fork");
  case 0:
    exec(argv[0], argv);
    fatal(smprint("can't exec %s: %r", argv[0]));
  default:
    while ((i = waitpid()) != pid && i != -1)
      ;
    if(i == -1)
      fatal(smprint("wait failed running %s", argv[0]));
  }
}

void
run(char *file, ...)
{
  runv(&file);
}


void bind_safe(char* old, char* new, int flag) {
  if(bind(old, new, flag) < 0)
    fatal("bind");
  return;
}

int open_safe(char* path, int flag) {
  int fd;
  if((fd = open(path, flag)) < 0) {
    fatal("open");
  }
  return fd;
}

void print_safe(int fd, char* str) {
  if(write(fd, str, strlen(str)) < 0) {
    fatal("print");
  };
  return;
}

void close_safe(int fd) {
  if(close(fd) < 0) {
    fatal("close");
  }
}
@


\subsection*{[[boot/boot.c]]}

<<boot.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

/*
 * we should inherit the standard fds all referring to /dev/cons,
 * but we're being paranoid.
 */
static void
opencons(void)
{
  close(0);
  close(1);
  close(2);
  open("/dev/cons", OREAD);
  open("/dev/cons", OWRITE);
  open("/dev/cons", OWRITE);
}

/*
 * init will reinitialize its namespace.
 * #ec gets us plan9.ini settings (*var variables).
 */
static void
bindenvsrv(void)
{
  bind("#ec", "/env", MREPL);
  bind("#e", "/env", MBEFORE|MCREATE);
  bind("#s", "/srv/", MREPL|MCREATE);
}

static void
swapproc(void)
{
    int fd;

    fd = open("#c/swap", OWRITE);
    if(fd < 0){
        warning("opening #c/swap");
        return;
    }
    if(write(fd, "start", 5) <= 0)
        warning("starting swap kproc");
    close(fd);
}

static void
execinit(void)
{
  int fd;

  bind_safe("#p", "/proc", MREPL); //devproc
  // used by rc and many programs, e.g. via open("#d/0")
  bind_safe("#d", "/fd", MREPL); //devdup

  bind_safe("/root", "/", MAFTER|MCREATE);
  bind_safe("/386/bin", "/bin", MREPL);
  bind_safe("/rc/bin", "/bin", MAFTER);

  bind_safe("#v", "/dev", MAFTER); //devvga
  bind_safe("#m", "/dev", MAFTER); //devmouse
  bind_safe("#P", "/dev", MAFTER);

  run("/bin/aux/mouse", "ps2", nil);
  //this just need a regular vga driver
  //run("/bin/aux/vga", "-l", "640x480x8", nil);
  //this need special drivers, such as the clgd424x.c in the kernel
  run("/bin/aux/vga", "-l", "1024x768x8", nil);
  bind_safe("#i", "/dev", MAFTER);

  // for rio
  run("/bin/ramfs", "-m", "/mnt", nil);
  run("/bin/mkdir", "/mnt/temp", nil); // see thread(2), used to create pipes
  run("/bin/mkdir", "/mnt/wsys", nil);
  fd = open_safe("#c/hostowner", OWRITE);
  print_safe(fd, "pad");
  close(fd);

  // network
  bind_safe("#I", "/net", MREPL);
  bind_safe("#l0", "/net", MAFTER);

  run("/bin/rc", nil);
}


// called from bootpcf.c:main()
void
boot(int argc, char *argv[])
{
  USED(argc);
  USED(argv);

  fmtinstall('r', errfmt);

  //At this point we should have #/ and #c setup by the kernel init0

  opencons();
  bindenvsrv();

  print("booooooooting...\n");

  rfork(RFNAMEG);

  connectlocal();

  swapproc();
  execinit();

  exits("failed to exec init");
}
@


\subsection*{[[boot/boot.h]]}

<<boot.h>>=
/* libc equivalent */
// aux.c: 
extern void fatal(char*);
extern void warning(char*);
extern void run(char *file, ...);
extern void runv(char **argv);
/* pad style */
void bind_safe(char* old, char* new, int flag);
int open_safe(char* path, int flag);
void print_safe(int fd, char* str);
void close_safe(int fd);

// what bootpcf.c used to expect
//typedef struct Method Method;
//struct Method
//{
//  char  *name;
//  void  (*config)(Method*);
//  int (*connect)(void);
//  char  *arg;
//};

/* methods */
// local.c:
extern int  connectlocal(void);
//extern void configlocal(Method*);
// other possible method connections: network.c, ...

// 386/bootpcf.c
//extern Method method[];   /* defined in ../$arch/boot$CONF.c */
//extern char*  bootdisk;   /* defined in ../$arch/boot$CONF.c */
//void main(int argc, char **argv)

/* main entry point */
// boot.c:
extern void boot(int, char **);


@


\subsection*{[[boot/local.c]]}

<<local.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

//void
//configlocal(Method *mp)
//{
//  USED(mp);
//}


int
connectlocal(void)
{
  int fd;
  
  bind_safe("#S", "/dev", MAFTER);

  fd = open_safe("/dev/sdC0/ctl", ORDWR);
  //TODO: use fdisk -p /dev/sdC1/data > /dev/sdC1/ctl
  //for sdC0: #prep -p /dev/sdC1/plan9 > /dev/sdC1/ctl
  print_safe(fd, "part dos 1 1000063");
  close_safe(fd);

  run("/boot/dossrv", nil);
  run("/boot/mount", "-c", "/srv/dos", "/root", "/dev/sdC0/dos", nil);
  
  return 0;
}
@


\section{[[buses/]]}

\subsection*{[[buses/386/dat_buses.h]]}

<<dat_buses.h>>=

/*
 *  a parsed plan9.ini line
 */
#define NISAOPT   8

struct ISAConf {
  char  *type;
  ulong port;
  int irq;
  ulong dma;
  ulong mem;
  ulong size;
  ulong freq;

  int nopt;
  char  *opt[NISAOPT];
};
@


\subsection*{[[buses/386/dma.c]]}

<<dma.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

typedef struct DMAport  DMAport;
typedef struct DMA  DMA;
typedef struct DMAxfer  DMAxfer;

/*
 *  state of a dma transfer
 */
struct DMAxfer
{
    ulong   bpa;        /* bounce buffer physical address */
    void*   bva;        /* bounce buffer virtual address */
    int blen;       /* bounce buffer length */
    void*   va;     /* virtual address destination/src */
    long    len;        /* bytes to be transferred */
    int isread;
};

/*
 *  the dma controllers.  the first half of this structure specifies
 *  the I/O ports used by the DMA controllers.
 */
//@Scheck: unnamed substructure
struct DMAport
{
    uchar   addr[4];    /* current address (4 channels) */
    uchar   count[4];   /* current count (4 channels) */
    uchar   page[4];    /* page registers (4 channels) */
    uchar   cmd;        /* command status register */
    uchar   req;        /* request registers */
    uchar   sbm;        /* single bit mask register */
    uchar   mode;       /* mode register */
    uchar   cbp;        /* clear byte pointer */
    uchar   mc;     /* master clear */
    uchar   cmask;      /* clear mask register */
    uchar   wam;        /* write all mask register bit */
};

struct DMA
{
    DMAport;
    int shift;
    Lock;
    DMAxfer x[4];
};

DMA dma[2] = {
    { 0x00, 0x02, 0x04, 0x06,
      0x01, 0x03, 0x05, 0x07,
      0x87, 0x83, 0x81, 0x82,
      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
     0 },

    { 0xc0, 0xc4, 0xc8, 0xcc,
      0xc2, 0xc6, 0xca, 0xce,
      0x8f, 0x8b, 0x89, 0x8a,
      0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
     1 },
};

extern int i8237dma;
static void* i8237bva[2];
static int i8237used;

/*
 *  DMA must be in the first 16MB.  This gets called early by the
 *  initialisation routines of any devices which require DMA to ensure
 *  the allocated bounce buffers are below the 16MB limit.
 */
void
_i8237alloc(void)
{
    void* bva;

    if(i8237dma <= 0)
        return;
    if(i8237dma > 2)
        i8237dma = 2;

    bva = xspanalloc(64*1024*i8237dma, BY2PG, 64*1024);
    if(bva == nil || PADDR(bva)+64*1024*i8237dma > 16*MB){
        /*
         * This will panic with the current
         * implementation of xspanalloc().
        if(bva != nil)
            xfree(bva);
         */
        return;
    }

    i8237bva[0] = bva;
    if(i8237dma == 2)
        i8237bva[1] = ((uchar*)i8237bva[0])+64*1024;
}

/*
 *  DMA must be in the first 16MB.  This gets called early by the
 *  initialisation routines of any devices which require DMA to ensure
 *  the allocated bounce buffers are below the 16MB limit.
 */
int
dmainit(int chan, int maxtransfer)
{
    DMA *dp;
    DMAxfer *xp;
    static int once;

    if(once == 0){
        if(ioalloc(0x00, 0x10, 0, "dma") < 0
        || ioalloc(0x80, 0x10, 0, "dma") < 0
        || ioalloc(0xd0, 0x10, 0, "dma") < 0)
            panic("dmainit");
        once = 1;
    }

    if(maxtransfer > 64*1024)
        maxtransfer = 64*1024;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;
    xp = &dp->x[chan];
    if(xp->bva != nil){
        if(xp->blen < maxtransfer)
            return 1;
        return 0;
    }

    if(i8237used >= i8237dma || i8237bva[i8237used] == nil){
        print("no i8237 DMA bounce buffer < 16MB\n");
        return 1;
    }
    xp->bva = i8237bva[i8237used++];
    xp->bpa = PADDR(xp->bva);
    xp->blen = maxtransfer;
    xp->len = 0;
    xp->isread = 0;

    return 0;
}

/*
 *  setup a dma transfer.  if the destination is not in kernel
 *  memory, allocate a page for the transfer.
 *
 *  we assume BIOS has set up the command register before we
 *  are booted.
 *
 *  return the updated transfer length (we can't transfer across 64k
 *  boundaries)
 */
long
dmasetup(int chan, void *va, long len, int isread)
{
    DMA *dp;
    ulong pa;
    uchar mode;
    DMAxfer *xp;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;
    xp = &dp->x[chan];

    /*
     *  if this isn't kernel memory or crossing 64k boundary or above 16 meg
     *  use the bounce buffer.
     */
    if((ulong)va < KZERO 
    || ((pa=PADDR(va))&0xFFFF0000) != ((pa+len)&0xFFFF0000)
    || pa >= 16*MB){
        if(xp->bva == nil)
            return -1;
        if(len > xp->blen)
            len = xp->blen;
        if(!isread)
            memmove(xp->bva, va, len);
        xp->va = va;
        xp->len = len;
        xp->isread = isread;
        pa = xp->bpa;
    }
    else
        xp->len = 0;

    /*
     * this setup must be atomic
     */
    ilock(dp);
    mode = (isread ? 0x44 : 0x48) | chan;
    outb(dp->mode, mode);   /* single mode dma (give CPU a chance at mem) */
    outb(dp->page[chan], pa>>16);
    outb(dp->cbp, 0);       /* set count & address to their first byte */
    outb(dp->addr[chan], pa>>dp->shift);        /* set address */
    outb(dp->addr[chan], pa>>(8+dp->shift));
    outb(dp->count[chan], (len>>dp->shift)-1);      /* set count */
    outb(dp->count[chan], ((len>>dp->shift)-1)>>8);
    outb(dp->sbm, chan);        /* enable the channel */
    iunlock(dp);

    return len;
}

//int
//dmadone(int chan)
//{
//  DMA *dp;
//
//  dp = &dma[(chan>>2)&1];
//  chan = chan & 3;
//
//  return inb(dp->cmd) & (1<<chan);
//}

/*
 *  this must be called after a dma has been completed.
 *
 *  if a page has been allocated for the dma,
 *  copy the data into the actual destination
 *  and free the page.
 */
void
dmaend(int chan)
{
    DMA *dp;
    DMAxfer *xp;

    dp = &dma[(chan>>2)&1];
    chan = chan & 3;

    /*
     *  disable the channel
     */
    ilock(dp);
    outb(dp->sbm, 4|chan);
    iunlock(dp);

    xp = &dp->x[chan];
    if(xp->len == 0 || !xp->isread)
        return;

    /*
     *  copy out of temporary page
     */
    memmove(xp->va, xp->bva, xp->len);
    xp->len = 0;
}

/*
//int
//dmacount(int chan)
//{
//  int     retval;
//  DMA     *dp;
// 
//  dp = &dma[(chan>>2)&1];
//  outb(dp->cbp, 0);
//  retval = inb(dp->count[chan]);
//  retval |= inb(dp->count[chan]) << 8;
//  return((retval<<dp->shift)+1);
//}
 */
@


\subsection*{[[buses/386/pci.c]]}

<<pci.c>>=
/*
 * PCI support code.
 * Needs a massive rewrite.
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"

#define DBG if(0) pcilog

/* let each port override any of these */
#ifndef PCICONSSIZE
#define PCICONSSIZE (16*1024)
#endif

void    pcicfgw16(Pcidev*, int, int);

struct
{
    char    output[PCICONSSIZE];
    int ptr;
} PCICONS;

int pcivga;

ulong   pcibarsize(Pcidev*, int);
void    pcibussize(Pcidev*, ulong*, ulong*);
void    pcihinv(Pcidev*);
uchar   pciipin(Pcidev*, uchar);

int
pcilog(char *fmt, ...)
{
    int n;
    va_list arg;
    char buf[PRINTSIZE];

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    memmove(PCICONS.output+PCICONS.ptr, buf, n);
    PCICONS.ptr += n;
    return n;
}

enum
{                   /* configuration mechanism #1 */
    PciADDR     = 0xCF8,    /* CONFIG_ADDRESS */
    PciDATA     = 0xCFC,    /* CONFIG_DATA */

                    /* configuration mechanism #2 */
    PciCSE      = 0xCF8,    /* configuration space enable */
    PciFORWARD  = 0xCFA,    /* which bus */

    MaxFNO      = 7,
    MaxUBN      = 255,
};

enum
{                   /* command register */
    IOen        = (1<<0),
    MEMen       = (1<<1),
    MASen       = (1<<2),
    MemWrInv    = (1<<4),
    PErrEn      = (1<<6),
    SErrEn      = (1<<8),
};

static Lock pcicfglock;
static Lock pcicfginitlock;
static int pcicfgmode = -1;
static int pcimaxbno = 7;
static int pcimaxdno;
static Pcidev* pciroot;
static Pcidev* pcilist;
static Pcidev* pcitail;
static int nobios, nopcirouting;
static BIOS32si* pcibiossi;

static int pcicfgrw8raw(int, int, int, int);
static int pcicfgrw16raw(int, int, int, int);
static int pcicfgrw32raw(int, int, int, int);

static int (*pcicfgrw8)(int, int, int, int) = pcicfgrw8raw;
static int (*pcicfgrw16)(int, int, int, int) = pcicfgrw16raw;
static int (*pcicfgrw32)(int, int, int, int) = pcicfgrw32raw;

static char* bustypes[] = {
    "CBUSI",
    "CBUSII",
    "EISA",
    "FUTURE",
    "INTERN",
    "ISA",
    "MBI",
    "MBII",
    "MCA",
    "MPI",
    "MPSA",
    "NUBUS",
    "PCI",
    "PCMCIA",
    "TC",
    "VL",
    "VME",
    "XPRESS",
};

static int
tbdffmt(Fmt* fmt)
{
    char *p;
    int l, r;
    uint type, tbdf;

    if((p = malloc(READSTR)) == nil)
        return fmtstrcpy(fmt, "(tbdfconv)");

    switch(fmt->r){
    case 'T':
        tbdf = va_arg(fmt->args, int);
        if(tbdf == BUSUNKNOWN)
            snprint(p, READSTR, "unknown");
        else{
            type = BUSTYPE(tbdf);
            if(type < nelem(bustypes))
                l = snprint(p, READSTR, bustypes[type]);
            else
                l = snprint(p, READSTR, "%d", type);
            snprint(p+l, READSTR-l, ".%d.%d.%d",
                BUSBNO(tbdf), BUSDNO(tbdf), BUSFNO(tbdf));
        }
        break;

    default:
        snprint(p, READSTR, "(tbdfconv)");
        break;
    }
    r = fmtstrcpy(fmt, p);
    free(p);

    return r;
}

ulong
pcibarsize(Pcidev *p, int rno)
{
    ulong v, size;

    v = pcicfgrw32(p->tbdf, rno, 0, 1);
    pcicfgrw32(p->tbdf, rno, 0xFFFFFFF0, 0);
    size = pcicfgrw32(p->tbdf, rno, 0, 1);
    if(v & 1)
        size |= 0xFFFF0000;
    pcicfgrw32(p->tbdf, rno, v, 0);

    return -(size & ~0x0F);
}

static int
pcisizcmp(void *a, void *b)
{
    Pcisiz *aa, *bb;

    aa = a;
    bb = b;
    return aa->siz - bb->siz;
}

static ulong
pcimask(ulong v)
{
    ulong m;

    m = BI2BY*sizeof(v);
    for(m = 1<<(m-1); m != 0; m >>= 1) {
        if(m & v)
            break;
    }

    m--;
    if((v & m) == 0)
        return v;

    v |= m;
    return v+1;
}

static void
pcibusmap(Pcidev *root, ulong *pmema, ulong *pioa, int wrreg)
{
    Pcidev *p;
    int ntb, i, size, rno, hole;
    ulong v, mema, ioa, sioa, smema, base, limit;
    Pcisiz *table, *tptr, *mtb, *itb;

    if(!nobios)
        return;

    ioa = *pioa;
    mema = *pmema;

    DBG("pcibusmap wr=%d %T mem=%luX io=%luX\n",
        wrreg, root->tbdf, mema, ioa);

    ntb = 0;
    for(p = root; p != nil; p = p->link)
        ntb++;

    ntb *= (PciCIS-PciBAR0)/4;
    table = malloc(2*ntb*sizeof(Pcisiz));
    if(table == nil)
        panic("pcibusmap: no memory");
    itb = table;
    mtb = table+ntb;

    /*
     * Build a table of sizes
     */
    for(p = root; p != nil; p = p->link) {
        if(p->ccrb == 0x06) {
            if(p->ccru != 0x04 || p->bridge == nil) {
//              DBG("pci: ignored bridge %T\n", p->tbdf);
                continue;
            }

            sioa = ioa;
            smema = mema;
            pcibusmap(p->bridge, &smema, &sioa, 0);

            hole = pcimask(smema-mema);
            if(hole < (1<<20))
                hole = 1<<20;
            p->mema.size = hole;

            hole = pcimask(sioa-ioa);
            if(hole < (1<<12))
                hole = 1<<12;

            p->ioa.size = hole;

            itb->dev = p;
            itb->bar = -1;
            itb->siz = p->ioa.size;
            itb++;

            mtb->dev = p;
            mtb->bar = -1;
            mtb->siz = p->mema.size;
            mtb++;
            continue;
        }

        for(i = 0; i <= 5; i++) {
            rno = PciBAR0 + i*4;
            v = pcicfgrw32(p->tbdf, rno, 0, 1);
            size = pcibarsize(p, rno);
            if(size == 0)
                continue;

            if(v & 1) {
                itb->dev = p;
                itb->bar = i;
                itb->siz = size;
                itb++;
            }
            else {
                mtb->dev = p;
                mtb->bar = i;
                mtb->siz = size;
                mtb++;
            }

            p->mem[i].size = size;
        }
    }

    /*
     * Sort both tables IO smallest first, Memory largest
     */
    qsort(table, itb-table, sizeof(Pcisiz), pcisizcmp);
    tptr = table+ntb;
    qsort(tptr, mtb-tptr, sizeof(Pcisiz), pcisizcmp);

    /*
     * Allocate IO address space on this bus
     */
    for(tptr = table; tptr < itb; tptr++) {
        hole = tptr->siz;
        if(tptr->bar == -1)
            hole = 1<<12;
        ioa = (ioa+hole-1) & ~(hole-1);

        p = tptr->dev;
        if(tptr->bar == -1)
            p->ioa.bar = ioa;
        else {
            p->pcr |= IOen;
            p->mem[tptr->bar].bar = ioa|1;
            if(wrreg)
                pcicfgrw32(p->tbdf, PciBAR0+(tptr->bar*4), ioa|1, 0);
        }

        ioa += tptr->siz;
    }

    /*
     * Allocate Memory address space on this bus
     */
    for(tptr = table+ntb; tptr < mtb; tptr++) {
        hole = tptr->siz;
        if(tptr->bar == -1)
            hole = 1<<20;
        mema = (mema+hole-1) & ~(hole-1);

        p = tptr->dev;
        if(tptr->bar == -1)
            p->mema.bar = mema;
        else {
            p->pcr |= MEMen;
            p->mem[tptr->bar].bar = mema;
            if(wrreg)
                pcicfgrw32(p->tbdf, PciBAR0+(tptr->bar*4), mema, 0);
        }
        mema += tptr->siz;
    }

    *pmema = mema;
    *pioa = ioa;
    free(table);

    if(wrreg == 0)
        return;

    /*
     * Finally set all the bridge addresses & registers
     */
    for(p = root; p != nil; p = p->link) {
        if(p->bridge == nil) {
            pcicfgrw8(p->tbdf, PciLTR, 64, 0);

            p->pcr |= MASen;
            pcicfgrw16(p->tbdf, PciPCR, p->pcr, 0);
            continue;
        }

        base = p->ioa.bar;
        limit = base+p->ioa.size-1;
        v = pcicfgrw32(p->tbdf, PciIBR, 0, 1);
        v = (v&0xFFFF0000)|(limit & 0xF000)|((base & 0xF000)>>8);
        pcicfgrw32(p->tbdf, PciIBR, v, 0);
        v = (limit & 0xFFFF0000)|(base>>16);
        pcicfgrw32(p->tbdf, PciIUBR, v, 0);

        base = p->mema.bar;
        limit = base+p->mema.size-1;
        v = (limit & 0xFFF00000)|((base & 0xFFF00000)>>16);
        pcicfgrw32(p->tbdf, PciMBR, v, 0);

        /*
         * Disable memory prefetch
         */
        pcicfgrw32(p->tbdf, PciPMBR, 0x0000FFFF, 0);
        pcicfgrw8(p->tbdf, PciLTR, 64, 0);

        /*
         * Enable the bridge
         */
        p->pcr |= IOen|MEMen|MASen;
        pcicfgrw32(p->tbdf, PciPCR, 0xFFFF0000|p->pcr , 0);

        sioa = p->ioa.bar;
        smema = p->mema.bar;
        pcibusmap(p->bridge, &smema, &sioa, 1);
    }
}

/* side effect: if a video controller is seen, set pcivga non-zero */
static int
pcilscan(int bno, Pcidev** list)
{
    Pcidev *p, *head, *tail;
    int dno, fno, i, hdt, l, maxfno, maxubn, rno, sbn, tbdf, ubn;

    maxubn = bno;
    head = nil;
    tail = nil;
    for(dno = 0; dno <= pcimaxdno; dno++){
        maxfno = 0;
        for(fno = 0; fno <= maxfno; fno++){
            /*
             * For this possible device, form the
             * bus+device+function triplet needed to address it
             * and try to read the vendor and device ID.
             * If successful, allocate a device struct and
             * start to fill it in with some useful information
             * from the device's configuration space.
             */
            tbdf = MKBUS(BusPCI, bno, dno, fno);
            l = pcicfgrw32(tbdf, PciVID, 0, 1);
            if(l == 0xFFFFFFFF || l == 0)
                continue;
            p = malloc(sizeof(*p));
            if(p == nil)
                panic("pcilscan: no memory");
            p->tbdf = tbdf;
            p->vid = l;
            p->did = l>>16;

            if(pcilist != nil)
                pcitail->list = p;
            else
                pcilist = p;
            pcitail = p;

            p->pcr = pcicfgr16(p, PciPCR);
            p->rid = pcicfgr8(p, PciRID);
            p->ccrp = pcicfgr8(p, PciCCRp);
            p->ccru = pcicfgr8(p, PciCCRu);
            p->ccrb = pcicfgr8(p, PciCCRb);
            p->cls = pcicfgr8(p, PciCLS);
            p->ltr = pcicfgr8(p, PciLTR);

            p->intl = pcicfgr8(p, PciINTL);

            /*
             * If the device is a multi-function device adjust the
             * loop count so all possible functions are checked.
             */
            hdt = pcicfgr8(p, PciHDT);
            if(hdt & 0x80)
                maxfno = MaxFNO;

            /*
             * If appropriate, read the base address registers
             * and work out the sizes.
             */
            switch(p->ccrb) {
            case 0x03:      /* display controller */
                pcivga = 1;
                /* fall through */
            case 0x01:      /* mass storage controller */
            case 0x02:      /* network controller */
            case 0x04:      /* multimedia device */
            case 0x07:      /* simple comm. controllers */
            case 0x08:      /* base system peripherals */
            case 0x09:      /* input devices */
            case 0x0A:      /* docking stations */
            case 0x0B:      /* processors */
            case 0x0C:      /* serial bus controllers */
                if((hdt & 0x7F) != 0)
                    break;
                rno = PciBAR0 - 4;
                for(i = 0; i < nelem(p->mem); i++) {
                    rno += 4;
                    p->mem[i].bar = pcicfgr32(p, rno);
                    p->mem[i].size = pcibarsize(p, rno);
                }
                break;

            case 0x00:
            case 0x05:      /* memory controller */
            case 0x06:      /* bridge device */
            default:
                break;
            }

            if(head != nil)
                tail->link = p;
            else
                head = p;
            tail = p;
        }
    }

    *list = head;
    for(p = head; p != nil; p = p->link){
        /*
         * Find PCI-PCI bridges and recursively descend the tree.
         */
        if(p->ccrb != 0x06 || p->ccru != 0x04)
            continue;

        /*
         * If the secondary or subordinate bus number is not
         * initialised try to do what the PCI BIOS should have
         * done and fill in the numbers as the tree is descended.
         * On the way down the subordinate bus number is set to
         * the maximum as it's not known how many buses are behind
         * this one; the final value is set on the way back up.
         */
        sbn = pcicfgr8(p, PciSBN);
        ubn = pcicfgr8(p, PciUBN);

        if(sbn == 0 || ubn == 0 || nobios) {
            sbn = maxubn+1;
            /*
             * Make sure memory, I/O and master enables are
             * off, set the primary, secondary and subordinate
             * bus numbers and clear the secondary status before
             * attempting to scan the secondary bus.
             *
             * Initialisation of the bridge should be done here.
             */
            pcicfgw32(p, PciPCR, 0xFFFF0000);
            l = (MaxUBN<<16)|(sbn<<8)|bno;
            pcicfgw32(p, PciPBN, l);
            pcicfgw16(p, PciSPSR, 0xFFFF);
            maxubn = pcilscan(sbn, &p->bridge);
            l = (maxubn<<16)|(sbn<<8)|bno;

            pcicfgw32(p, PciPBN, l);
        }
        else {
            if(ubn > maxubn)
                maxubn = ubn;
            pcilscan(sbn, &p->bridge);
        }
    }

    return maxubn;
}

//int
//pciscan(int bno, Pcidev **list)
//{
//  int ubn;
//
//  lock(&pcicfginitlock);
//  ubn = pcilscan(bno, list);
//  unlock(&pcicfginitlock);
//  return ubn;
//}

static uchar
pIIxget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 0x60, 0x61, 0x62, 0x63 */
    pirq = pcicfgr8(router, link);
    return (pirq < 16)? pirq: 0;
}

static void
pIIxset(Pcidev *router, uchar link, uchar irq)
{
    pcicfgw8(router, link, irq);
}

static uchar
viaget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 1, 2, 3, 5 */
    pirq = (link < 6)? pcicfgr8(router, 0x55 + (link>>1)): 0;

    return (link & 1)? (pirq >> 4): (pirq & 15);
}

static void
viaset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0x55 + (link >> 1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0x55 + (link>>1), pirq);
}

static uchar
optiget(Pcidev *router, uchar link)
{
    uchar pirq = 0;

    /* link should be 0x02, 0x12, 0x22, 0x32 */
    if ((link & 0xcf) == 0x02)
        pirq = pcicfgr8(router, 0xb8 + (link >> 5));
    return (link & 0x10)? (pirq >> 4): (pirq & 15);
}

static void
optiset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0xb8 + (link >> 5));
        pirq &= (link & 0x10)? 0x0f : 0xf0;
        pirq |= (link & 0x10)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0xb8 + (link >> 5), pirq);
}

static uchar
aliget(Pcidev *router, uchar link)
{
    /* No, you're not dreaming */
    static const uchar map[] = { 0, 9, 3, 10, 4, 5, 7, 6, 1, 11, 0, 12, 0, 14, 0, 15 };
    uchar pirq;

    /* link should be 0x01..0x08 */
    pirq = pcicfgr8(router, 0x48 + ((link-1)>>1));
    return (link & 1)? map[pirq&15]: map[pirq>>4];
}

static void
aliset(Pcidev *router, uchar link, uchar irq)
{
    /* Inverse of map in aliget */
    static const uchar map[] = { 0, 8, 0, 2, 4, 5, 7, 6, 0, 1, 3, 9, 11, 0, 13, 15 };
    uchar pirq;

    pirq = pcicfgr8(router, 0x48 + ((link-1)>>1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (map[irq] << 4): (map[irq] & 15);
    pcicfgw8(router, 0x48 + ((link-1)>>1), pirq);
}

static uchar
cyrixget(Pcidev *router, uchar link)
{
    uchar pirq;

    /* link should be 1, 2, 3, 4 */
    pirq = pcicfgr8(router, 0x5c + ((link-1)>>1));
    return ((link & 1)? pirq >> 4: pirq & 15);
}

static void
cyrixset(Pcidev *router, uchar link, uchar irq)
{
    uchar pirq;

    pirq = pcicfgr8(router, 0x5c + (link>>1));
    pirq &= (link & 1)? 0x0f: 0xf0;
    pirq |= (link & 1)? (irq << 4): (irq & 15);
    pcicfgw8(router, 0x5c + (link>>1), pirq);
}

typedef struct Bridge Bridge;
struct Bridge
{
    ushort  vid;
    ushort  did;
    uchar   (*get)(Pcidev *, uchar);
    void    (*set)(Pcidev *, uchar, uchar);
};

static Bridge southbridges[] = {
    { 0x8086, 0x122e, pIIxget, pIIxset },   /* Intel 82371FB */
    { 0x8086, 0x1234, pIIxget, pIIxset },   /* Intel 82371MX */
    { 0x8086, 0x7000, pIIxget, pIIxset },   /* Intel 82371SB */
    { 0x8086, 0x7110, pIIxget, pIIxset },   /* Intel 82371AB */
    { 0x8086, 0x7198, pIIxget, pIIxset },   /* Intel 82443MX (fn 1) */
    { 0x8086, 0x2410, pIIxget, pIIxset },   /* Intel 82801AA */
    { 0x8086, 0x2420, pIIxget, pIIxset },   /* Intel 82801AB */
    { 0x8086, 0x2440, pIIxget, pIIxset },   /* Intel 82801BA */
    { 0x8086, 0x2448, pIIxget, pIIxset },   /* Intel 82801BAM/CAM/DBM */
    { 0x8086, 0x244c, pIIxget, pIIxset },   /* Intel 82801BAM */
    { 0x8086, 0x244e, pIIxget, pIIxset },   /* Intel 82801 */
    { 0x8086, 0x2480, pIIxget, pIIxset },   /* Intel 82801CA */
    { 0x8086, 0x248c, pIIxget, pIIxset },   /* Intel 82801CAM */
    { 0x8086, 0x24c0, pIIxget, pIIxset },   /* Intel 82801DBL */
    { 0x8086, 0x24cc, pIIxget, pIIxset },   /* Intel 82801DBM */
    { 0x8086, 0x24d0, pIIxget, pIIxset },   /* Intel 82801EB */
    { 0x8086, 0x25a1, pIIxget, pIIxset },   /* Intel 6300ESB */
    { 0x8086, 0x2640, pIIxget, pIIxset },   /* Intel 82801FB */
    { 0x8086, 0x2641, pIIxget, pIIxset },   /* Intel 82801FBM */
    { 0x8086, 0x27b8, pIIxget, pIIxset },   /* Intel 82801GB */
    { 0x8086, 0x27b9, pIIxget, pIIxset },   /* Intel 82801GBM */
    { 0x8086, 0x27bd, pIIxget, pIIxset },   /* Intel 82801GB/GR */
    { 0x8086, 0x3a16, pIIxget, pIIxset },   /* Intel 82801JIR */
    { 0x8086, 0x3a40, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x3a42, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x3a48, pIIxget, pIIxset },   /* Intel 82801JI */
    { 0x8086, 0x2916, pIIxget, pIIxset },   /* Intel 82801? */
    { 0x8086, 0x1c02, pIIxget, pIIxset },   /* Intel 6 Series/C200 */
    { 0x8086, 0x1c44, pIIxget, pIIxset },   /* Intel 6 Series/Z68 Express */
    { 0x8086, 0x1e53, pIIxget, pIIxset },   /* Intel 7 Series/C216 */
    { 0x1106, 0x0586, viaget, viaset }, /* Viatech 82C586 */
    { 0x1106, 0x0596, viaget, viaset }, /* Viatech 82C596 */
    { 0x1106, 0x0686, viaget, viaset }, /* Viatech 82C686 */
    { 0x1106, 0x3227, viaget, viaset }, /* Viatech VT8237 */
    { 0x1045, 0xc700, optiget, optiset },   /* Opti 82C700 */
    { 0x10b9, 0x1533, aliget, aliset }, /* Al M1533 */
    { 0x1039, 0x0008, pIIxget, pIIxset },   /* SI 503 */
    { 0x1039, 0x0496, pIIxget, pIIxset },   /* SI 496 */
    { 0x1078, 0x0100, cyrixget, cyrixset }, /* Cyrix 5530 Legacy */

    { 0x1022, 0x746B, nil, nil },       /* AMD 8111 */
    { 0x10DE, 0x00D1, nil, nil },       /* NVIDIA nForce 3 */
    { 0x10DE, 0x00E0, nil, nil },       /* NVIDIA nForce 3 250 Series */
    { 0x10DE, 0x00E1, nil, nil },       /* NVIDIA nForce 3 250 Series */
    { 0x1166, 0x0200, nil, nil },       /* ServerWorks ServerSet III LE */
    { 0x1002, 0x4377, nil, nil },       /* ATI Radeon Xpress 200M */
    { 0x1002, 0x4372, nil, nil },       /* ATI SB400 */
};

typedef struct Slot Slot;
struct Slot {
    uchar   bus;        /* Pci bus number */
    uchar   dev;        /* Pci device number */
    uchar   maps[12];   /* Avoid structs!  Link and mask. */
    uchar   slot;       /* Add-in/built-in slot */
    uchar   reserved;
};

typedef struct Router Router;
struct Router {
    uchar   signature[4];   /* Routing table signature */
    uchar   version[2]; /* Version number */
    uchar   size[2];    /* Total table size */
    uchar   bus;        /* Interrupt router bus number */
    uchar   devfn;      /* Router's devfunc */
    uchar   pciirqs[2]; /* Exclusive PCI irqs */
    uchar   compat[4];  /* Compatible PCI interrupt router */
    uchar   miniport[4];    /* Miniport data */
    uchar   reserved[11];
    uchar   checksum;
};

static ushort pciirqs;      /* Exclusive PCI irqs */
static Bridge *southbridge; /* Which southbridge to use. */

static void
pcirouting(void)
{
    Slot *e;
    Router *r;
    int size, i, fn, tbdf;
    Pcidev *sbpci, *pci;
    uchar *p, pin, irq, link, *map;

    /* Search for PCI interrupt routing table in BIOS */
    for(p = (uchar *)KADDR(0xf0000); p < (uchar *)KADDR(0xfffff); p += 16)
        if(p[0] == '$' && p[1] == 'P' && p[2] == 'I' && p[3] == 'R')
            break;

    if(p >= (uchar *)KADDR(0xfffff)) {
        // print("no PCI intr routing table found\n");
        return;
    }

    r = (Router *)p;

    if (0)
        print("PCI interrupt routing table version %d.%d at %#.6luX\n",
            r->version[0], r->version[1], (ulong)r & 0xfffff);

    tbdf = (BusPCI << 24)|(r->bus << 16)|(r->devfn << 8);
    sbpci = pcimatchtbdf(tbdf);
    if(sbpci == nil) {
        print("pcirouting: Cannot find south bridge %T\n", tbdf);
        return;
    }

    for(i = 0; i != nelem(southbridges); i++)
        if(sbpci->vid == southbridges[i].vid && sbpci->did == southbridges[i].did)
            break;

    if(i == nelem(southbridges)) {
        print("pcirouting: ignoring south bridge %T %.4uX/%.4uX\n", tbdf, sbpci->vid, sbpci->did);
        return;
    }
    southbridge = &southbridges[i];
    if(southbridge->get == nil || southbridge->set == nil)
        return;

    pciirqs = (r->pciirqs[1] << 8)|r->pciirqs[0];

    size = (r->size[1] << 8)|r->size[0];
    for(e = (Slot *)&r[1]; (uchar *)e < p + size; e++) {
        if (0) {
            print("%.2uX/%.2uX %.2uX: ", e->bus, e->dev, e->slot);
            for (i = 0; i != 4; i++) {
                uchar *m = &e->maps[i * 3];
                print("[%d] %.2uX %.4uX ",
                    i, m[0], (m[2] << 8)|m[1]);
            }
            print("\n");
        }
        for(fn = 0; fn != 8; fn++) {
            tbdf = (BusPCI << 24)|(e->bus << 16)|((e->dev | fn) << 8);
            pci = pcimatchtbdf(tbdf);
            if(pci == nil)
                continue;
            pin = pcicfgr8(pci, PciINTP);
            if(pin == 0 || pin == 0xff)
                continue;

            map = &e->maps[(pin - 1) * 3];
            link = map[0];
            irq = southbridge->get(sbpci, link);
            if(irq == 0 || irq == pci->intl)
                continue;
            if(pci->intl != 0 && pci->intl != 0xFF) {
                print("pcirouting: BIOS workaround: %T at pin %d link %d irq %d -> %d\n",
                      tbdf, pin, link, irq, pci->intl);
                southbridge->set(sbpci, link, pci->intl);
                continue;
            }
            print("pcirouting: %T at pin %d link %d irq %d\n", tbdf, pin, link, irq);
            pcicfgw8(pci, PciINTL, irq);
            pci->intl = irq;
        }
    }
}

static void pcireservemem(void);

static int
pcicfgrw8bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB108;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx & 0xFF;
    }
    else{
        ci.eax = 0xB10B;
        ci.ecx = data & 0xFF;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static int
pcicfgrw16bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB109;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx & 0xFFFF;
    }
    else{
        ci.eax = 0xB10C;
        ci.ecx = data & 0xFFFF;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static int
pcicfgrw32bios(int tbdf, int rno, int data, int read)
{
    BIOS32ci ci;

    if(pcibiossi == nil)
        return -1;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.ebx = (BUSBNO(tbdf)<<8)|(BUSDNO(tbdf)<<3)|BUSFNO(tbdf);
    ci.edi = rno;
    if(read){
        ci.eax = 0xB10A;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return ci.ecx;
    }
    else{
        ci.eax = 0xB10D;
        ci.ecx = data;
        if(!bios32ci(pcibiossi, &ci)/* && !(ci.eax & 0xFF)*/)
            return 0;
    }

    return -1;
}

static BIOS32si*
pcibiosinit(void)
{
    BIOS32ci ci;
    BIOS32si *si;

    if((si = bios32open("$PCI")) == nil)
        return nil;

    memset(&ci, 0, sizeof(BIOS32ci));
    ci.eax = 0xB101;
    if(bios32ci(si, &ci) || ci.edx != ((' '<<24)|('I'<<16)|('C'<<8)|'P')){
        free(si);
        return nil;
    }
    if(ci.eax & 0x01)
        pcimaxdno = 31;
    else
        pcimaxdno = 15;
    pcimaxbno = ci.ecx & 0xff;

    return si;
}

void
pcibussize(Pcidev *root, ulong *msize, ulong *iosize)
{
    *msize = 0;
    *iosize = 0;
    pcibusmap(root, msize, iosize, 0);
}

static void
pcicfginit(void)
{
    char *p;
    Pcidev **list;
    ulong mema, ioa;
    int bno, n, pcibios;

    lock(&pcicfginitlock);
    if(pcicfgmode != -1)
        goto out;

    pcibios = 0;
    if(getconf("*nobios"))
        nobios = 1;
    else if(getconf("*pcibios"))
        pcibios = 1;
    if(getconf("*nopcirouting"))
        nopcirouting = 1;

    /*
     * Try to determine which PCI configuration mode is implemented.
     * Mode2 uses a byte at 0xCF8 and another at 0xCFA; Mode1 uses
     * a DWORD at 0xCF8 and another at 0xCFC and will pass through
     * any non-DWORD accesses as normal I/O cycles. There shouldn't be
     * a device behind these addresses so if Mode1 accesses fail try
     * for Mode2 (Mode2 is deprecated).
     */
    if(!pcibios){
        /*
         * Bits [30:24] of PciADDR must be 0,
         * according to the spec.
         */
        n = inl(PciADDR);
        if(!(n & 0x7F000000)){
            outl(PciADDR, 0x80000000);
            outb(PciADDR+3, 0);
            if(inl(PciADDR) & 0x80000000){
                pcicfgmode = 1;
                pcimaxdno = 31;
            }
        }
        outl(PciADDR, n);

        if(pcicfgmode < 0){
            /*
             * The 'key' part of PciCSE should be 0.
             */
            n = inb(PciCSE);
            if(!(n & 0xF0)){
                outb(PciCSE, 0x0E);
                if(inb(PciCSE) == 0x0E){
                    pcicfgmode = 2;
                    pcimaxdno = 15;
                }
            }
            outb(PciCSE, n);
        }
    }

    if(pcicfgmode < 0 || pcibios) {
        if((pcibiossi = pcibiosinit()) == nil)
            goto out;
        pcicfgrw8 = pcicfgrw8bios;
        pcicfgrw16 = pcicfgrw16bios;
        pcicfgrw32 = pcicfgrw32bios;
        pcicfgmode = 3;
    }

    fmtinstall('T', tbdffmt);

    if(p = getconf("*pcimaxbno")){
        n = strtoul(p, 0, 0);
        if(n < pcimaxbno)
            pcimaxbno = n;
    }
    if(p = getconf("*pcimaxdno")){
        n = strtoul(p, 0, 0);
        if(n < pcimaxdno)
            pcimaxdno = n;
    }

    list = &pciroot;
    for(bno = 0; bno <= pcimaxbno; bno++) {
        int sbno = bno;
        bno = pcilscan(bno, list);

        while(*list)
            list = &(*list)->link;

        if (sbno == 0) {
            Pcidev *pci;

            /*
              * If we have found a PCI-to-Cardbus bridge, make sure
              * it has no valid mappings anymore.
              */
            for(pci = pciroot; pci != nil; pci = pci->link){
                if (pci->ccrb == 6 && pci->ccru == 7) {
                    ushort bcr;

                    /* reset the cardbus */
                    bcr = pcicfgr16(pci, PciBCR);
                    pcicfgw16(pci, PciBCR, 0x40 | bcr);
                    delay(50);
                }
            }
        }
    }

    if(pciroot == nil)
        goto out;

    if(nobios) {
        /*
         * Work out how big the top bus is
         */
        pcibussize(pciroot, &mema, &ioa);

        /*
         * Align the windows and map it
         */
        ioa = 0x1000;
        mema = 0x90000000;

        pcilog("Mask sizes: mem=%lux io=%lux\n", mema, ioa);

        pcibusmap(pciroot, &mema, &ioa, 1);
        DBG("Sizes2: mem=%lux io=%lux\n", mema, ioa);

        unlock(&pcicfginitlock);
        return;
    }

    if (!nopcirouting)
        pcirouting();

out:
    pcireservemem();
    unlock(&pcicfginitlock);

    if(getconf("*pcihinv"))
        pcihinv(nil);
}

static void
pcireservemem(void)
{
    int i;
    Pcidev *p;

    /*
     * mark all the physical address space claimed by pci devices
     * as in use, so that upaalloc doesn't give it out.
     */
    for(p=pciroot; p; p=p->list)
        for(i=0; i<nelem(p->mem); i++)
            if(p->mem[i].bar && (p->mem[i].bar&1) == 0)
                upareserve(p->mem[i].bar&~0x0F, p->mem[i].size);
}

static int
pcicfgrw8raw(int tbdf, int rno, int data, int read)
{
    int o, type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        o = rno & 0x03;
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = inb(PciDATA+o);
        else
            outb(PciDATA+o, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = inb((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outb((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr8(Pcidev* pcidev, int rno)
{
    return pcicfgrw8(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw8(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw8(pcidev->tbdf, rno, data, 0);
}

static int
pcicfgrw16raw(int tbdf, int rno, int data, int read)
{
    int o, type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        o = rno & 0x02;
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = ins(PciDATA+o);
        else
            outs(PciDATA+o, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = ins((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outs((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr16(Pcidev* pcidev, int rno)
{
    return pcicfgrw16(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw16(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw16(pcidev->tbdf, rno, data, 0);
}

static int
pcicfgrw32raw(int tbdf, int rno, int data, int read)
{
    int type, x;

    if(pcicfgmode == -1)
        pcicfginit();

    if(BUSBNO(tbdf))
        type = 0x01;
    else
        type = 0x00;
    x = -1;
    if(BUSDNO(tbdf) > pcimaxdno)
        return x;

    lock(&pcicfglock);
    switch(pcicfgmode){

    case 1:
        rno &= ~0x03;
        outl(PciADDR, 0x80000000|BUSBDF(tbdf)|rno|type);
        if(read)
            x = inl(PciDATA);
        else
            outl(PciDATA, data);
        outl(PciADDR, 0);
        break;

    case 2:
        outb(PciCSE, 0x80|(BUSFNO(tbdf)<<1));
        outb(PciFORWARD, BUSBNO(tbdf));
        if(read)
            x = inl((0xC000|(BUSDNO(tbdf)<<8)) + rno);
        else
            outl((0xC000|(BUSDNO(tbdf)<<8)) + rno, data);
        outb(PciCSE, 0);
        break;
    }
    unlock(&pcicfglock);

    return x;
}

int
pcicfgr32(Pcidev* pcidev, int rno)
{
    return pcicfgrw32(pcidev->tbdf, rno, 0, 1);
}

void
pcicfgw32(Pcidev* pcidev, int rno, int data)
{
    pcicfgrw32(pcidev->tbdf, rno, data, 0);
}

Pcidev*
pcimatch(Pcidev* prev, int vid, int did)
{
    if(pcicfgmode == -1)
        pcicfginit();

    if(prev == nil)
        prev = pcilist;
    else
        prev = prev->list;

    while(prev != nil){
        if((vid == 0 || prev->vid == vid)
        && (did == 0 || prev->did == did))
            break;
        prev = prev->list;
    }
    return prev;
}

Pcidev*
pcimatchtbdf(int tbdf)
{
    Pcidev *pcidev;

    if(pcicfgmode == -1)
        pcicfginit();

    for(pcidev = pcilist; pcidev != nil; pcidev = pcidev->list) {
        if(pcidev->tbdf == tbdf)
            break;
    }
    return pcidev;
}

uchar
pciipin(Pcidev *pci, uchar pin)
{
    if (pci == nil)
        pci = pcilist;

    while (pci) {
        uchar intl;

        if (pcicfgr8(pci, PciINTP) == pin && pci->intl != 0 && pci->intl != 0xff)
            return pci->intl;

        if (pci->bridge && (intl = pciipin(pci->bridge, pin)) != 0)
            return intl;

        pci = pci->list;
    }
    return 0;
}

static void
pcilhinv(Pcidev* p)
{
    int i;
    Pcidev *t;

    if(p == nil) {
        putstrn(PCICONS.output, PCICONS.ptr);
        p = pciroot;
        print("bus dev type vid  did intl memory\n");
    }
    for(t = p; t != nil; t = t->link) {
        print("%d  %2d/%d %.2ux %.2ux %.2ux %.4ux %.4ux %3d  ",
            BUSBNO(t->tbdf), BUSDNO(t->tbdf), BUSFNO(t->tbdf),
            t->ccrb, t->ccru, t->ccrp, t->vid, t->did, t->intl);

        for(i = 0; i < nelem(p->mem); i++) {
            if(t->mem[i].size == 0)
                continue;
            print("%d:%.8lux %d ", i,
                t->mem[i].bar, t->mem[i].size);
        }
        if(t->ioa.bar || t->ioa.size)
            print("ioa:%.8lux %d ", t->ioa.bar, t->ioa.size);
        if(t->mema.bar || t->mema.size)
            print("mema:%.8lux %d ", t->mema.bar, t->mema.size);
        if(t->bridge)
            print("->%d", BUSBNO(t->bridge->tbdf));
        print("\n");
    }
    while(p != nil) {
        if(p->bridge != nil)
            pcilhinv(p->bridge);
        p = p->link;
    }
}

void
pcihinv(Pcidev* p)
{
    if(pcicfgmode == -1)
        pcicfginit();
    lock(&pcicfginitlock);
    pcilhinv(p);
    unlock(&pcicfginitlock);
}

void
pcireset(void)
{
    Pcidev *p;

    if(pcicfgmode == -1)
        pcicfginit();

    for(p = pcilist; p != nil; p = p->list) {
        /* don't mess with the bridges */
        if(p->ccrb == 0x06)
            continue;
        pciclrbme(p);
    }
}

//void
//pcisetioe(Pcidev* p)
//{
//  p->pcr |= IOen;
//  pcicfgw16(p, PciPCR, p->pcr);
//}

//void
//pciclrioe(Pcidev* p)
//{
//  p->pcr &= ~IOen;
//  pcicfgw16(p, PciPCR, p->pcr);
//}

void
pcisetbme(Pcidev* p)
{
    p->pcr |= MASen;
    pcicfgw16(p, PciPCR, p->pcr);
}

void
pciclrbme(Pcidev* p)
{
    p->pcr &= ~MASen;
    pcicfgw16(p, PciPCR, p->pcr);
}

//void
//pcisetmwi(Pcidev* p)
//{
//  p->pcr |= MemWrInv;
//  pcicfgw16(p, PciPCR, p->pcr);
//}

//void
//pciclrmwi(Pcidev* p)
//{
//  p->pcr &= ~MemWrInv;
//  pcicfgw16(p, PciPCR, p->pcr);
//}

//static int
//pcigetpmrb(Pcidev* p)
//{
//  int ptr;
//
//  if(p->pmrb != 0)
//      return p->pmrb;
//  p->pmrb = -1;
//
//  /*
//   * If there are no extended capabilities implemented,
//   * (bit 4 in the status register) assume there's no standard
//   * power management method.
//   * Find the capabilities pointer based on PCI header type.
//   */
//  if(!(pcicfgr16(p, PciPSR) & 0x0010))
//      return -1;
//  switch(pcicfgr8(p, PciHDT)){
//  default:
//      return -1;
//  case 0:                 /* all other */
//  case 1:                 /* PCI to PCI bridge */
//      ptr = 0x34;
//      break;
//  case 2:                 /* CardBus bridge */
//      ptr = 0x14;
//      break;
//  }
//  ptr = pcicfgr32(p, ptr);
//
//  while(ptr != 0){
//      /*
//       * Check for validity.
//       * Can't be in standard header and must be double
//       * word aligned.
//       */
//      if(ptr < 0x40 || (ptr & ~0xFC))
//          return -1;
//      if(pcicfgr8(p, ptr) == 0x01){
//          p->pmrb = ptr;
//          return ptr;
//      }
//
//      ptr = pcicfgr8(p, ptr+1);
//  }
//
//  return -1;
//}

//int
//pcigetpms(Pcidev* p)
//{
//  int pmcsr, ptr;
//
//  if((ptr = pcigetpmrb(p)) == -1)
//      return -1;
//
//  /*
//   * Power Management Register Block:
//   *  offset 0:   Capability ID
//   *     1:   next item pointer
//   *     2:   capabilities
//   *     4:   control/status
//   *     6:   bridge support extensions
//   *     7:   data
//   */
//  pmcsr = pcicfgr16(p, ptr+4);
//
//  return pmcsr & 0x0003;
//}

//int
//pcisetpms(Pcidev* p, int state)
//{
//  int ostate, pmc, pmcsr, ptr;
//
//  if((ptr = pcigetpmrb(p)) == -1)
//      return -1;
//
//  pmc = pcicfgr16(p, ptr+2);
//  pmcsr = pcicfgr16(p, ptr+4);
//  ostate = pmcsr & 0x0003;
//  pmcsr &= ~0x0003;
//
//  switch(state){
//  default:
//      return -1;
//  case 0:
//      break;
//  case 1:
//      if(!(pmc & 0x0200))
//          return -1;
//      break;
//  case 2:
//      if(!(pmc & 0x0400))
//          return -1;
//      break;
//  case 3:
//      break;
//  }
//  pmcsr |= state;
//  pcicfgw16(p, ptr+4, pmcsr);
//
//  return ostate;
//}
@


\subsection*{[[buses/386/uarti8250.c]]}

<<uarti8250.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"

/*
 * 8250 UART and compatibles.
 */
enum {
    Uart0       = 0x3F8,    /* COM1 */
    Uart0IRQ    = 4,
    Uart1       = 0x2F8,    /* COM2 */
    Uart1IRQ    = 3,

    UartFREQ    = 1843200,
};

enum {                  /* I/O ports */
    Rbr     = 0,        /* Receiver Buffer (RO) */
    Thr     = 0,        /* Transmitter Holding (WO) */
    Ier     = 1,        /* Interrupt Enable */
    Iir     = 2,        /* Interrupt Identification (RO) */
    Fcr     = 2,        /* FIFO Control (WO) */
    Lcr     = 3,        /* Line Control */
    Mcr     = 4,        /* Modem Control */
    Lsr     = 5,        /* Line Status */
    Msr     = 6,        /* Modem Status */
    Scr     = 7,        /* Scratch Pad */
    Dll     = 0,        /* Divisor Latch LSB */
    Dlm     = 1,        /* Divisor Latch MSB */
};

enum {                  /* Ier */
    Erda        = 0x01,     /* Enable Received Data Available */
    Ethre       = 0x02,     /* Enable Thr Empty */
    Erls        = 0x04,     /* Enable Receiver Line Status */
    Ems     = 0x08,     /* Enable Modem Status */
};

enum {                  /* Iir */
    Ims     = 0x00,     /* Ms interrupt */
    Ip      = 0x01,     /* Interrupt Pending (not) */
    Ithre       = 0x02,     /* Thr Empty */
    Irda        = 0x04,     /* Received Data Available */
    Irls        = 0x06,     /* Receiver Line Status */
    Ictoi       = 0x0C,     /* Character Time-out Indication */
    IirMASK     = 0x3F,
    Ifena       = 0xC0,     /* FIFOs enabled */
};

enum {                  /* Fcr */
    FIFOena     = 0x01,     /* FIFO enable */
    FIFOrclr    = 0x02,     /* clear Rx FIFO */
    FIFOtclr    = 0x04,     /* clear Tx FIFO */
    FIFO1       = 0x00,     /* Rx FIFO trigger level 1 byte */
    FIFO4       = 0x40,     /*  4 bytes */
    FIFO8       = 0x80,     /*  8 bytes */
    FIFO14      = 0xC0,     /*  14 bytes */
};

enum {                  /* Lcr */
    Wls5        = 0x00,     /* Word Length Select 5 bits/byte */
    Wls6        = 0x01,     /*  6 bits/byte */
    Wls7        = 0x02,     /*  7 bits/byte */
    Wls8        = 0x03,     /*  8 bits/byte */
    WlsMASK     = 0x03,
    Stb     = 0x04,     /* 2 stop bits */
    Pen     = 0x08,     /* Parity Enable */
    Eps     = 0x10,     /* Even Parity Select */
    Stp     = 0x20,     /* Stick Parity */
    Brk     = 0x40,     /* Break */
    Dlab        = 0x80,     /* Divisor Latch Access Bit */
};

enum {                  /* Mcr */
    Dtr     = 0x01,     /* Data Terminal Ready */
    Rts     = 0x02,     /* Ready To Send */
    Out1        = 0x04,     /* no longer in use */
    Ie      = 0x08,     /* IRQ Enable */
    Dm      = 0x10,     /* Diagnostic Mode loopback */
};

enum {                  /* Lsr */
    Dr      = 0x01,     /* Data Ready */
    Oe      = 0x02,     /* Overrun Error */
    Pe      = 0x04,     /* Parity Error */
    Fe      = 0x08,     /* Framing Error */
    Bi      = 0x10,     /* Break Interrupt */
    Thre        = 0x20,     /* Thr Empty */
    Temt        = 0x40,     /* Tramsmitter Empty */
    FIFOerr     = 0x80,     /* error in receiver FIFO */
};

enum {                  /* Msr */
    Dcts        = 0x01,     /* Delta Cts */
    Ddsr        = 0x02,     /* Delta Dsr */
    Teri        = 0x04,     /* Trailing Edge of Ri */
    Ddcd        = 0x08,     /* Delta Dcd */
    Cts     = 0x10,     /* Clear To Send */
    Dsr     = 0x20,     /* Data Set Ready */
    Ri      = 0x40,     /* Ring Indicator */
    Dcd     = 0x80,     /* Data Set Ready */
};

struct CtlrUart {
    int io;
    int irq;
    int tbdf;
    int iena;

    uchar   sticky[8];

    Lock;
    int hasfifo;
    int checkfifo;
    int fena;
};

typedef struct CtlrUart CtlrUart;

extern PhysUart i8250physuart;

static CtlrUart i8250ctlr[2] = {
{   .io = Uart0,
    .irq    = Uart0IRQ,
    .tbdf   = BUSUNKNOWN, },

{   .io = Uart1,
    .irq    = Uart1IRQ,
    .tbdf   = BUSUNKNOWN, },
};

static Uart i8250uart[2] = {
{   .regs   = &i8250ctlr[0],
    .name   = "COM1",
    .freq   = UartFREQ,
    .phys   = &i8250physuart,
    .special= 0,
    .next   = &i8250uart[1], },

{   .regs   = &i8250ctlr[1],
    .name   = "COM2",
    .freq   = UartFREQ,
    .phys   = &i8250physuart,
    .special= 0,
    .next   = nil, },
};

#define csr8r(c, r) inb((c)->io+(r))
#define csr8w(c, r, v)  outb((c)->io+(r), (c)->sticky[(r)]|(v))

static long
i8250status(Uart* uart, void* buf, long n, long offset)
{
    char *p;
    CtlrUart *ctlr;
    uchar ier, lcr, mcr, msr;

    p = malloc(READSTR);
    if(p == nil)
        error(Enomem);
    ctlr = uart->regs;
    mcr = ctlr->sticky[Mcr];
    msr = csr8r(ctlr, Msr);
    ier = ctlr->sticky[Ier];
    lcr = ctlr->sticky[Lcr];
    snprint(p, READSTR,
        "b%d c%d d%d e%d l%d m%d p%c r%d s%d i%d\n"
        "dev(%d) type(%d) framing(%d) overruns(%d) "
        "berr(%d) serr(%d)%s%s%s%s\n",

        uart->baud,
        uart->hup_dcd, 
        (msr & Dsr) != 0,
        uart->hup_dsr,
        (lcr & WlsMASK) + 5,
        (ier & Ems) != 0, 
        (lcr & Pen) ? ((lcr & Eps) ? 'e': 'o'): 'n',
        (mcr & Rts) != 0,
        (lcr & Stb) ? 2: 1,
        ctlr->fena,

        uart->dev,
        uart->type,
        uart->ferr,
        uart->oerr,
        uart->berr,
        uart->serr,
        (msr & Cts) ? " cts": "",
        (msr & Dsr) ? " dsr": "",
        (msr & Dcd) ? " dcd": "",
        (msr & Ri) ? " ring": ""
    );
    n = readstr(offset, buf, n, p);
    free(p);

    return n;
}

static void
i8250fifo(Uart* uart, int level)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    if(ctlr->hasfifo == 0)
        return;

    /*
     * Changing the FIFOena bit in Fcr flushes data
     * from both receive and transmit FIFOs; there's
     * no easy way to guarantee not losing data on
     * the receive side, but it's possible to wait until
     * the transmitter is really empty.
     */
    ilock(ctlr);
    while(!(csr8r(ctlr, Lsr) & Temt))
        ;

    /*
     * Set the trigger level, default is the max.
     * value.
     * Some UARTs require FIFOena to be set before
     * other bits can take effect, so set it twice.
     */
    ctlr->fena = level;
    switch(level){
    case 0:
        break;
    case 1:
        level = FIFO1|FIFOena;
        break;
    case 4:
        level = FIFO4|FIFOena;
        break;
    case 8:
        level = FIFO8|FIFOena;
        break;
    default:
        level = FIFO14|FIFOena;
        break;
    }
    csr8w(ctlr, Fcr, level);
    csr8w(ctlr, Fcr, level);
    iunlock(ctlr);
}

static void
i8250dtr(Uart* uart, int on)
{
    CtlrUart *ctlr;

    /*
     * Toggle DTR.
     */
    ctlr = uart->regs;
    if(on)
        ctlr->sticky[Mcr] |= Dtr;
    else
        ctlr->sticky[Mcr] &= ~Dtr;
    csr8w(ctlr, Mcr, 0);
}

static void
i8250rts(Uart* uart, int on)
{
    CtlrUart *ctlr;

    /*
     * Toggle RTS.
     */
    ctlr = uart->regs;
    if(on)
        ctlr->sticky[Mcr] |= Rts;
    else
        ctlr->sticky[Mcr] &= ~Rts;
    csr8w(ctlr, Mcr, 0);
}

static void
i8250modemctl(Uart* uart, int on)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    ilock(&uart->tlock);
    if(on){
        ctlr->sticky[Ier] |= Ems;
        csr8w(ctlr, Ier, ctlr->sticky[Ier]);
        uart->modem = 1;
        uart->cts = csr8r(ctlr, Msr) & Cts;
    }
    else{
        ctlr->sticky[Ier] &= ~Ems;
        csr8w(ctlr, Ier, ctlr->sticky[Ier]);
        uart->modem = 0;
        uart->cts = 1;
    }
    iunlock(&uart->tlock);

    /* modem needs fifo */
    (*uart->phys->fifo)(uart, on);
}

static int
i8250parity(Uart* uart, int parity)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~(Eps|Pen);

    switch(parity){
    case 'e':
        lcr |= Eps|Pen;
        break;
    case 'o':
        lcr |= Pen;
        break;
    case 'n':
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->parity = parity;

    return 0;
}

static int
i8250stop(Uart* uart, int stop)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~Stb;

    switch(stop){
    case 1:
        break;
    case 2:
        lcr |= Stb;
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->stop = stop;

    return 0;
}

static int
i8250bits(Uart* uart, int bits)
{
    int lcr;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    lcr = ctlr->sticky[Lcr] & ~WlsMASK;

    switch(bits){
    case 5:
        lcr |= Wls5;
        break;
    case 6:
        lcr |= Wls6;
        break;
    case 7:
        lcr |= Wls7;
        break;
    case 8:
        lcr |= Wls8;
        break;
    default:
        return -1;
    }
    ctlr->sticky[Lcr] = lcr;
    csr8w(ctlr, Lcr, 0);

    uart->bits = bits;

    return 0;
}

static int
i8250baud(Uart* uart, int baud)
{
    ulong bgc;
    CtlrUart *ctlr;

    /*
     * Set the Baud rate by calculating and setting the Baud rate
     * Generator Constant. This will work with fairly non-standard
     * Baud rates.
     */
    if(uart->freq == 0 || baud <= 0)
        return -1;
    bgc = (uart->freq+8*baud-1)/(16*baud);

    ctlr = uart->regs;
    csr8w(ctlr, Lcr, Dlab);
    outb(ctlr->io+Dlm, bgc>>8);
    outb(ctlr->io+Dll, bgc);
    csr8w(ctlr, Lcr, 0);

    uart->baud = baud;

    return 0;
}

static void
i8250break(Uart* uart, int ms)
{
    CtlrUart *ctlr;

    /*
     * Send a break.
     */
    if(ms <= 0)
        ms = 200;

    ctlr = uart->regs;
    csr8w(ctlr, Lcr, Brk);
    tsleep(&up->sleep, return0, 0, ms);
    csr8w(ctlr, Lcr, 0);
}

static void
i8250kick(Uart* uart)
{
    int i;
    CtlrUart *ctlr;

    if(uart->cts == 0 || uart->blocked)
        return;

    /*
     *  128 here is an arbitrary limit to make sure
     *  we don't stay in this loop too long.  If the
     *  chip's output queue is longer than 128, too
     *  bad -- presotto
     */
    ctlr = uart->regs;
    for(i = 0; i < 128; i++){
        if(!(csr8r(ctlr, Lsr) & Thre))
            break;
        if(uart->op >= uart->oe && uartstageoutput(uart) == 0)
            break;
        outb(ctlr->io+Thr, *(uart->op++));
    }
}

static void
i8250interrupt(Ureg*, void* arg)
{
    CtlrUart *ctlr;
    Uart *uart;
    int iir, lsr, old, r;

    uart = arg;

    ctlr = uart->regs;
    for(iir = csr8r(ctlr, Iir); !(iir & Ip); iir = csr8r(ctlr, Iir)){
        switch(iir & IirMASK){
        case Ims:       /* Ms interrupt */
            r = csr8r(ctlr, Msr);
            if(r & Dcts){
                ilock(&uart->tlock);
                old = uart->cts;
                uart->cts = r & Cts;
                if(old == 0 && uart->cts)
                    uart->ctsbackoff = 2;
                iunlock(&uart->tlock);
            }
            if(r & Ddsr){
                old = r & Dsr;
                if(uart->hup_dsr && uart->dsr && !old)
                    uart->dohup = 1;
                uart->dsr = old;
            }
            if(r & Ddcd){
                old = r & Dcd;
                if(uart->hup_dcd && uart->dcd && !old)
                    uart->dohup = 1;
                uart->dcd = old;
            }
            break;
        case Ithre:     /* Thr Empty */
            uartkick(uart);
            break;
        case Irda:      /* Received Data Available */
        case Irls:      /* Receiver Line Status */
        case Ictoi:     /* Character Time-out Indication */
            /*
             * Consume any received data.
             * If the received byte came in with a break,
             * parity or framing error, throw it away;
             * overrun is an indication that something has
             * already been tossed.
             */
            while((lsr = csr8r(ctlr, Lsr)) & Dr){
                if(lsr & (FIFOerr|Oe))
                    uart->oerr++;
                if(lsr & Pe)
                    uart->perr++;
                if(lsr & Fe)
                    uart->ferr++;
                r = csr8r(ctlr, Rbr);
                if(!(lsr & (Bi|Fe|Pe)))
                    uartrecv(uart, r);
            }
            break;

        default:
            iprint("weird uart interrupt 0x%2.2uX\n", iir);
            break;
        }
    }
}

static void
i8250disable(Uart* uart)
{
    CtlrUart *ctlr;

    /*
     * Turn off DTR and RTS, disable interrupts and fifos.
     */
    (*uart->phys->dtr)(uart, 0);
    (*uart->phys->rts)(uart, 0);
    (*uart->phys->fifo)(uart, 0);

    ctlr = uart->regs;
    ctlr->sticky[Ier] = 0;
    csr8w(ctlr, Ier, ctlr->sticky[Ier]);

    if(ctlr->iena != 0){
        if(intrdisable(ctlr->irq, i8250interrupt, uart, ctlr->tbdf, uart->name) == 0)
            ctlr->iena = 0;
    }
}

static void
i8250enable(Uart* uart, int ie)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;

    /*
     * Check if there is a FIFO.
     * Changing the FIFOena bit in Fcr flushes data
     * from both receive and transmit FIFOs; there's
     * no easy way to guarantee not losing data on
     * the receive side, but it's possible to wait until
     * the transmitter is really empty.
     * Also, reading the Iir outwith i8250interrupt()
     * can be dangerous, but this should only happen
     * once before interrupts are enabled.
     */
    ilock(ctlr);
    if(!ctlr->checkfifo){
        /*
         * Wait until the transmitter is really empty.
         */
        while(!(csr8r(ctlr, Lsr) & Temt))
            ;
        csr8w(ctlr, Fcr, FIFOena);
        if(csr8r(ctlr, Iir) & Ifena)
            ctlr->hasfifo = 1;
        csr8w(ctlr, Fcr, 0);
        ctlr->checkfifo = 1;
    }
    iunlock(ctlr);

    /*
     * Enable interrupts and turn on DTR and RTS.
     * Be careful if this is called to set up a polled serial line
     * early on not to try to enable interrupts as interrupt-
     * -enabling mechanisms might not be set up yet.
     */
    if(ie){
        if(ctlr->iena == 0){
            intrenable(ctlr->irq, i8250interrupt, uart, ctlr->tbdf, uart->name);
            ctlr->iena = 1;
        }
        ctlr->sticky[Ier] = Ethre|Erda;
        ctlr->sticky[Mcr] |= Ie;
    }
    else{
        ctlr->sticky[Ier] = 0;
        ctlr->sticky[Mcr] = 0;
    }
    csr8w(ctlr, Ier, ctlr->sticky[Ier]);
    csr8w(ctlr, Mcr, ctlr->sticky[Mcr]);

    (*uart->phys->dtr)(uart, 1);
    (*uart->phys->rts)(uart, 1);

    /*
     * During startup, the i8259 interrupt controller is reset.
     * This may result in a lost interrupt from the i8250 uart.
     * The i8250 thinks the interrupt is still outstanding and does not
     * generate any further interrupts. The workaround is to call the
     * interrupt handler to clear any pending interrupt events.
     * Note: this must be done after setting Ier.
     */
    if(ie)
        i8250interrupt(nil, uart);
}

void*
i8250alloc(int io, int irq, int tbdf)
{
    CtlrUart *ctlr;

    if((ctlr = malloc(sizeof(CtlrUart))) != nil){
        ctlr->io = io;
        ctlr->irq = irq;
        ctlr->tbdf = tbdf;
    }

    return ctlr;
}

static Uart*
i8250pnp(void)
{
    return i8250uart;
}

static int
i8250getc(Uart *uart)
{
    CtlrUart *ctlr;

    ctlr = uart->regs;
    while(!(csr8r(ctlr, Lsr)&Dr))
        delay(1);
    return csr8r(ctlr, Rbr);
}

static void
i8250putc(Uart *uart, int c)
{
    int i;
    CtlrUart *ctlr;

    ctlr = uart->regs;
    for(i = 0; !(csr8r(ctlr, Lsr)&Thre) && i < 128; i++)
        delay(1);
    outb(ctlr->io+Thr, c);
    for(i = 0; !(csr8r(ctlr, Lsr)&Thre) && i < 128; i++)
        delay(1);
}

PhysUart i8250physuart = {
    .name       = "i8250",
    .pnp        = i8250pnp,
    .enable     = i8250enable,
    .disable    = i8250disable,
    .kick       = i8250kick,
    .dobreak    = i8250break,
    .baud       = i8250baud,
    .bits       = i8250bits,
    .stop       = i8250stop,
    .parity     = i8250parity,
    .modemctl   = i8250modemctl,
    .rts        = i8250rts,
    .dtr        = i8250dtr,
    .status     = i8250status,
    .fifo       = i8250fifo,
    .getc       = i8250getc,
    .putc       = i8250putc,
};

void
i8250config(char *p)
{
    Uart *uart;
    int n;
    char *cmd;

    if(p == nil)
        return;
    n = strtoul(p, &cmd, 0);
    if(p == cmd)
        return;
    switch(n){
    default:
        return;
    case 0:
        uart = &i8250uart[0];
        break;
    case 1:
        uart = &i8250uart[1];
        break;  
    }

    if(!uart->enabled)
        (*uart->phys->enable)(uart, 0);
    uartctl(uart, "b9600 l8 pn s1");
    if(*cmd != '\0')
        uartctl(uart, cmd);

    consuart = uart;
    uart->console = 1;
}

void
i8250console(void)
{
    i8250config(getconf("console"));
}

void
i8250mouse(char* which, int (*putc)(Queue*, int), int setb1200)
{
    char *p;
    int port;

    port = strtol(which, &p, 0);
    if(p == which || port < 0 || port > 1)
        error(Ebadarg);
    uartmouse(&i8250uart[port], putc, setb1200);
}

void
i8250setmouseputc(char* which, int (*putc)(Queue*, int))
{
    char *p;
    int port;

    port = strtol(which, &p, 0);
    if(p == which || port < 0 || port > 1)
        error(Ebadarg);
    uartsetmouseputc(&i8250uart[port], putc);

}
@


\subsection*{[[buses/386/uartisa.c]]}

<<uartisa.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"

extern PhysUart i8250physuart;
extern PhysUart isaphysuart;
extern void* i8250alloc(int, int, int);

static Uart*
uartisa(int ctlrno, ISAConf* isa)
{
    int io;
    void *ctlr;
    Uart *uart;
    char buf[64];

    io = isa->port;
    snprint(buf, sizeof(buf), "%s%d", isaphysuart.name, ctlrno);
    if(ioalloc(io, 8, 0, buf) < 0){
        print("uartisa: I/O 0x%uX in use\n", io);
        return nil;
    }

    uart = malloc(sizeof(Uart));
    ctlr = i8250alloc(io, isa->irq, BUSUNKNOWN);
    if(uart == nil || ctlr == nil){
        iofree(io);
        free(uart);
        free(ctlr);
        return nil;
    }

    uart->regs = ctlr;
    snprint(buf, sizeof(buf), "COM%d", ctlrno+1);
    kstrdup(&uart->name, buf);
    uart->freq = isa->freq;
    uart->phys = &i8250physuart;

    return uart;
}

static Uart*
uartisapnp(void)
{
    int ctlrno;
    ISAConf isa;
    Uart *head, *tail, *uart;

    /*
     * Look for up to 4 discrete UARTs on the ISA bus.
     * All suitable devices are configured to simply point
     * to the generic i8250 driver.
     */
    head = tail = nil;
    for(ctlrno = 2; ctlrno < 6; ctlrno++){
        memset(&isa, 0, sizeof(isa));
        if(!isaconfig("uart", ctlrno, &isa))
            continue;
        if(strcmp(isa.type, "isa") != 0)
            continue;
        if(isa.port == 0 || isa.irq == 0)
            continue;
        if(isa.freq == 0)
            isa.freq = 1843200;
        uart = uartisa(ctlrno, &isa);
        if(uart == nil)
            continue;
        if(head != nil)
            tail->next = uart;
        else
            head = uart;
        tail = uart;
    }

    return head;
}

PhysUart isaphysuart = {
    .name       = "UartISA",
    .pnp        = uartisapnp,
    .enable     = nil,
    .disable    = nil,
    .kick       = nil,
    .dobreak    = nil,
    .baud       = nil,
    .bits       = nil,
    .stop       = nil,
    .parity     = nil,
    .modemctl   = nil,
    .rts        = nil,
    .dtr        = nil,
    .status     = nil,
    .fifo       = nil,
};
@


\subsection*{[[buses/devuart.c]]}

<<devuart.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "io.h"
#include    "../port/error.h"

#include    "../port/netif.h"

enum
{
    /* soft flow control chars */
    CTLS= 023,
    CTLQ= 021,
};

extern Dev uartdevtab;
extern PhysUart* physuart[];

static Uart* uartlist;
static Uart** uart;
static int uartnuart;
static Dirtab *uartdir;
static int uartndir;
static Timer *uarttimer;

struct Uartalloc {
    Lock;
    Uart *elist;    /* list of enabled interfaces */
} uartalloc;

static void uartclock(void);
static void uartflow(void*);

/*
 *  enable/disable uart and add/remove to list of enabled uarts
 */
Uart*
uartenable(Uart *p)
{
    Uart **l;

    if(p->enabled)
        return p;
    if(p->iq == nil){
        if((p->iq = qopen(8*1024, 0, uartflow, p)) == nil)
            return nil;
    }
    else
        qreopen(p->iq);
    if(p->oq == nil){
        if((p->oq = qopen(8*1024, 0, uartkick, p)) == nil){
            qfree(p->iq);
            p->iq = nil;
            return nil;
        }
    }
    else
        qreopen(p->oq);

    p->ir = p->istage;
    p->iw = p->istage;
    p->ie = &p->istage[STAGESIZE];
    p->op = p->ostage;
    p->oe = p->ostage;

    p->hup_dsr = p->hup_dcd = 0;
    p->dsr = p->dcd = 0;

    /* assume we can send */
    p->cts = 1;
    p->ctsbackoff = 0;

    if(p->bits == 0)
        uartctl(p, "l8");
    if(p->stop == 0)
        uartctl(p, "s1");
    if(p->parity == 0)
        uartctl(p, "pn");
    if(p->baud == 0)
        uartctl(p, "b9600");
    (*p->phys->enable)(p, 1);

    /*
     * use ilock because uartclock can otherwise interrupt here
     * and would hang on an attempt to lock uartalloc.
     */
    ilock(&uartalloc);
    for(l = &uartalloc.elist; *l; l = &(*l)->elist){
        if(*l == p)
            break;
    }
    if(*l == 0){
        p->elist = uartalloc.elist;
        uartalloc.elist = p;
    }
    p->enabled = 1;
    iunlock(&uartalloc);

    return p;
}

static void
uartdisable(Uart *p)
{
    Uart **l;

    if(!p->enabled)
        return;
    (*p->phys->disable)(p);

    ilock(&uartalloc);
    for(l = &uartalloc.elist; *l; l = &(*l)->elist){
        if(*l == p){
            *l = p->elist;
            break;
        }
    }
    p->enabled = 0;
    iunlock(&uartalloc);
}

void
uartmouse(Uart* p, int (*putc)(Queue*, int), int setb1200)
{
    qlock(p);
    if(p->opens++ == 0 && uartenable(p) == nil){
        qunlock(p);
        error(Enodev);
    }
    if(setb1200)
        uartctl(p, "b1200");
    p->putc = putc;
    p->special = 1;
    qunlock(p);
}

void
uartsetmouseputc(Uart* p, int (*putc)(Queue*, int))
{
    qlock(p);
    if(p->opens == 0 || p->special == 0){
        qunlock(p);
        error(Enodev);
    }
    p->putc = putc;
    qunlock(p);
}

static void
setlength(int i)
{
    Uart *p;

    if(i > 0){
        p = uart[i];
        if(p && p->opens && p->iq)
            uartdir[1+3*i].length = qlen(p->iq);
    } else for(i = 0; i < uartnuart; i++){
        p = uart[i];
        if(p && p->opens && p->iq)
            uartdir[1+3*i].length = qlen(p->iq);
    }
}

/*
 *  set up the '#t' directory
 */
static void
uartreset(void)
{
    int i;
    Dirtab *dp;
    Uart *p, *tail;

    tail = nil;
    for(i = 0; physuart[i] != nil; i++){
        if(physuart[i]->pnp == nil)
            continue;
        if((p = physuart[i]->pnp()) == nil)
            continue;
        if(uartlist != nil)
            tail->next = p;
        else
            uartlist = p;
        for(tail = p; tail->next != nil; tail = tail->next)
            uartnuart++;
        uartnuart++;
    }

    if(uartnuart) {
        uart = xalloc(uartnuart*sizeof(Uart*));
        if (uart == nil)
            panic("uartreset: no memory");
    }

    uartndir = 1 + 3*uartnuart;
    uartdir = xalloc(uartndir * sizeof(Dirtab));
    if (uartdir == nil)
        panic("uartreset: no memory");
    dp = uartdir;
    strcpy(dp->name, ".");
    mkqid(&dp->qid, 0, 0, QTDIR);
    dp->length = 0;
    dp->perm = DMDIR|0555;
    dp++;
    p = uartlist;
    for(i = 0; i < uartnuart; i++){
        /* 3 directory entries per port */
        snprint(dp->name, sizeof dp->name, "eia%d", i);
        dp->qid.path = NETQID(i, Ndataqid);
        dp->perm = 0660;
        dp++;
        snprint(dp->name, sizeof dp->name, "eia%dctl", i);
        dp->qid.path = NETQID(i, Nctlqid);
        dp->perm = 0660;
        dp++;
        snprint(dp->name, sizeof dp->name, "eia%dstatus", i);
        dp->qid.path = NETQID(i, Nstatqid);
        dp->perm = 0444;
        dp++;

        uart[i] = p;
        p->dev = i;
        if(p->console || p->special){
            if(uartenable(p) != nil){
                if(p->console){
                    kbdq = p->iq;
                    serialoq = p->oq;
                    p->putc = kbdcr2nl;
                }
                p->opens++;
            }
        }
        p = p->next;
    }

    if(uartnuart){
        /*
         * at 115200 baud, the 1024 char buffer takes 56 ms to process,
         * processing it every 22 ms should be fine.
         */
        uarttimer = addclock0link(uartclock, 22);
    }
}


static Chan*
uartattach(char *spec)
{
    return devattach('t', spec);
}

static Walkqid*
uartwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, uartdir, uartndir, devgen);
}

static int
uartstat(Chan *c, uchar *dp, int n)
{
    if(NETTYPE(c->qid.path) == Ndataqid)
        setlength(NETID(c->qid.path));
    return devstat(c, dp, n, uartdir, uartndir, devgen);
}

static Chan*
uartopen(Chan *c, int omode)
{
    Uart *p;

    c = devopen(c, omode, uartdir, uartndir, devgen);

    switch(NETTYPE(c->qid.path)){
    case Nctlqid:
    case Ndataqid:
        p = uart[NETID(c->qid.path)];
        qlock(p);
        if(p->opens++ == 0 && uartenable(p) == nil){
            qunlock(p);
            c->flag &= ~COPEN;
            error(Enodev);
        }
        qunlock(p);
        break;
    }

    c->iounit = qiomaxatomic;
    return c;
}

static int
uartdrained(void* arg)
{
    Uart *p;

    p = arg;
    return qlen(p->oq) == 0 && p->op == p->oe;
}

static void
uartdrainoutput(Uart *p)
{
    if(!p->enabled)
        return;

    p->drain = 1;
    if(waserror()){
        p->drain = 0;
        nexterror();
    }
    sleep(&p->r, uartdrained, p);
    poperror();
}

static void
uartclose(Chan *c)
{
    Uart *p;

    if(c->qid.type & QTDIR)
        return;
    if((c->flag & COPEN) == 0)
        return;
    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
    case Nctlqid:
        p = uart[NETID(c->qid.path)];
        qlock(p);
        if(--(p->opens) == 0){
            qclose(p->iq);
            ilock(&p->rlock);
            p->ir = p->iw = p->istage;
            iunlock(&p->rlock);

            /*
             */
            qhangup(p->oq, nil);
            if(!waserror()){
                uartdrainoutput(p);
                poperror();
            }
            qclose(p->oq);
            uartdisable(p);
            p->dcd = p->dsr = p->dohup = 0;
        }
        qunlock(p);
        break;
    }
}

static long
uartread(Chan *c, void *buf, long n, vlong off)
{
    Uart *p;
    ulong offset = off;

    if(c->qid.type & QTDIR){
        setlength(-1);
        return devdirread(c, buf, n, uartdir, uartndir, devgen);
    }

    p = uart[NETID(c->qid.path)];
    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
        return qread(p->iq, buf, n);
    case Nctlqid:
        return readnum(offset, buf, n, NETID(c->qid.path), NUMSIZE);
    case Nstatqid:
        return (*p->phys->status)(p, buf, n, offset);
    }

    return 0;
}

int
uartctl(Uart *p, char *cmd)
{
    char *f[16];
    int i, n, nf;

    nf = tokenize(cmd, f, nelem(f));
    for(i = 0; i < nf; i++){
        if(strncmp(f[i], "break", 5) == 0){
            (*p->phys->dobreak)(p, 0);
            continue;
        }

        n = atoi(f[i]+1);
        switch(*f[i]){
        case 'B':
        case 'b':
            uartdrainoutput(p);
            if((*p->phys->baud)(p, n) < 0)
                return -1;
            break;
        case 'C':
        case 'c':
            p->hup_dcd = n;
            break;
        case 'D':
        case 'd':
            uartdrainoutput(p);
            (*p->phys->dtr)(p, n);
            break;
        case 'E':
        case 'e':
            p->hup_dsr = n;
            break;
        case 'f':
        case 'F':
            if(p->oq != nil)
                qflush(p->oq);
            break;
        case 'H':
        case 'h':
            if(p->iq != nil)
                qhangup(p->iq, 0);
            if(p->oq != nil)
                qhangup(p->oq, 0);
            break;
        case 'i':
        case 'I':
            uartdrainoutput(p);
            (*p->phys->fifo)(p, n);
            break;
        case 'K':
        case 'k':
            uartdrainoutput(p);
            (*p->phys->dobreak)(p, n);
            break;
        case 'L':
        case 'l':
            uartdrainoutput(p);
            if((*p->phys->bits)(p, n) < 0)
                return -1;
            break;
        case 'm':
        case 'M':
            uartdrainoutput(p);
            (*p->phys->modemctl)(p, n);
            break;
        case 'n':
        case 'N':
            if(p->oq != nil)
                qnoblock(p->oq, n);
            break;
        case 'P':
        case 'p':
            uartdrainoutput(p);
            if((*p->phys->parity)(p, *(f[i]+1)) < 0)
                return -1;
            break;
        case 'Q':
        case 'q':
            if(p->iq != nil)
                qsetlimit(p->iq, n);
            if(p->oq != nil)
                qsetlimit(p->oq, n);
            break;
        case 'R':
        case 'r':
            uartdrainoutput(p);
            (*p->phys->rts)(p, n);
            break;
        case 'S':
        case 's':
            uartdrainoutput(p);
            if((*p->phys->stop)(p, n) < 0)
                return -1;
            break;
        case 'W':
        case 'w':
            if(uarttimer == nil || n < 1)
                return -1;
            uarttimer->tns = (vlong)n * 100000LL;
            break;
        case 'X':
        case 'x':
            if(p->enabled){
                ilock(&p->tlock);
                p->xonoff = n;
                iunlock(&p->tlock);
            }
            break;
        }
    }
    return 0;
}

static long
uartwrite(Chan *c, void *buf, long n, vlong)
{
    Uart *p;
    char *cmd;

    if(c->qid.type & QTDIR)
        error(Eperm);

    p = uart[NETID(c->qid.path)];

    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
        qlock(p);
        if(waserror()){
            qunlock(p);
            nexterror();
        }

        n = qwrite(p->oq, buf, n);

        qunlock(p);
        poperror();
        break;
    case Nctlqid:
        cmd = malloc(n+1);
        if(cmd == nil)
            error(Enomem);
        memmove(cmd, buf, n);
        cmd[n] = 0;
        qlock(p);
        if(waserror()){
            qunlock(p);
            free(cmd);
            nexterror();
        }

        /* let output drain */
        if(uartctl(p, cmd) < 0)
            error(Ebadarg);

        qunlock(p);
        poperror();
        free(cmd);
        break;
    }

    return n;
}

static int
uartwstat(Chan *c, uchar *dp, int n)
{
    Dir d;
    Dirtab *dt;

    if(!iseve())
        error(Eperm);
    if(QTDIR & c->qid.type)
        error(Eperm);
    if(NETTYPE(c->qid.path) == Nstatqid)
        error(Eperm);

    dt = &uartdir[1 + 3 * NETID(c->qid.path)];
    n = convM2D(dp, n, &d, nil);
    if(n == 0)
        error(Eshortstat);
    if(d.mode != ~0UL)
        dt[0].perm = dt[1].perm = d.mode;
    return n;
}

void
uartpower(int on)
{
    Uart *p;

    for(p = uartlist; p != nil; p = p->next) {
        if(p->phys->power)
            (*p->phys->power)(p, on);
    }
}

Dev uartdevtab = {
    't',
    "uart",

    uartreset,
    devinit,
    devshutdown,
    uartattach,
    uartwalk,
    uartstat,
    uartopen,
    devcreate,
    uartclose,
    uartread,
    devbread,
    uartwrite,
    devbwrite,
    devremove,
    uartwstat,
    uartpower,
};

/*
 *  restart input if it's off
 */
static void
uartflow(void *v)
{
    Uart *p;

    p = v;
    if(p->modem)
        (*p->phys->rts)(p, 1);
}

/*
 *  put some bytes into the local queue to avoid calling
 *  qconsume for every character
 */
int
uartstageoutput(Uart *p)
{
    int n;

    n = qconsume(p->oq, p->ostage, STAGESIZE);
    if(n <= 0)
        return 0;
    p->op = p->ostage;
    p->oe = p->ostage + n;
    return n;
}

/*
 *  restart output
 */
void
uartkick(void *v)
{
    Uart *p = v;

    if(p->blocked)
        return;

    ilock(&p->tlock);
    (*p->phys->kick)(p);
    iunlock(&p->tlock);

    if(p->drain && uartdrained(p)){
        p->drain = 0;
        wakeup(&p->r);
    }
}

/*
 * Move data from the interrupt staging area to
 * the input Queue.
 */
static void
uartstageinput(Uart *p)
{
    int n;
    uchar *ir, *iw;

    while(p->ir != p->iw){
        ir = p->ir;
        if(p->ir > p->iw){
            iw = p->ie;
            p->ir = p->istage;
        }
        else{
            iw = p->iw;
            p->ir = p->iw;
        }
        if((n = qproduce(p->iq, ir, iw - ir)) < 0){
            p->serr++;
            (*p->phys->rts)(p, 0);
        }
        else if(n == 0)
            p->berr++;
    }
}

/*
 *  receive a character at interrupt time
 */
void
uartrecv(Uart *p,  char ch)
{
    uchar *next;

    /* software flow control */
    if(p->xonoff){
        if(ch == CTLS){
            p->blocked = 1;
        }else if(ch == CTLQ){
            p->blocked = 0;
            p->ctsbackoff = 2; /* clock gets output going again */
        }
    }

    /* receive the character */
    if(p->putc)
        p->putc(p->iq, ch);
    else if (p->iw) {       /* maybe the line isn't enabled yet */
        ilock(&p->rlock);
        next = p->iw + 1;
        if(next == p->ie)
            next = p->istage;
        if(next == p->ir)
            uartstageinput(p);
        if(next != p->ir){
            *p->iw = ch;
            p->iw = next;
        }
        iunlock(&p->rlock);
    }
}

/*
 *  we save up input characters till clock time to reduce
 *  per character interrupt overhead.
 */
static void
uartclock(void)
{
    Uart *p;

    ilock(&uartalloc);
    for(p = uartalloc.elist; p; p = p->elist){

        /* this hopefully amortizes cost of qproduce to many chars */
        if(p->iw != p->ir){
            ilock(&p->rlock);
            uartstageinput(p);
            iunlock(&p->rlock);
        }

        /* hang up if requested */
        if(p->dohup){
            qhangup(p->iq, 0);
            qhangup(p->oq, 0);
            p->dohup = 0;
        }

        /* this adds hysteresis to hardware/software flow control */
        if(p->ctsbackoff){
            ilock(&p->tlock);
            if(p->ctsbackoff){
                if(--(p->ctsbackoff) == 0)
                    (*p->phys->kick)(p);
            }
            iunlock(&p->tlock);
        }
    }
    iunlock(&uartalloc);
}

/*
 * polling console input, output
 */

Uart* consuart;
void (*lprint)(char *, int);

int
uartgetc(void)
{
    if(consuart == nil || consuart->phys->getc == nil)
        return -1;
    return consuart->phys->getc(consuart);
}

//void
//uartputc(int c)
//{
//  char c2;
//
//  if(consuart == nil || consuart->phys->putc == nil) {
//      c2 = c;
//      if (lprint)
//          (*lprint)(&c2, 1);
//      return;
//  }
//  consuart->phys->putc(consuart, c);
//}

void
uartputs(char *s, int n)
{
    char *e;

    if(consuart == nil || consuart->phys->putc == nil) {
        if (lprint)
            (*lprint)(s, n);
        return;
    }
    e = s+n;
    for(; s<e; s++){
        if(*s == '\n')
            consuart->phys->putc(consuart, '\r');
        consuart->phys->putc(consuart, *s);
    }
}
@


\subsection*{[[buses/portdat_buses.h]]}

<<portdat_buses.h>>=

/*
 *  routines to access UART hardware
 */
struct PhysUart
{
  char* name;
  Uart* (*pnp)(void);
  void  (*enable)(Uart*, int);
  void  (*disable)(Uart*);
  void  (*kick)(Uart*);
  void  (*dobreak)(Uart*, int);
  int (*baud)(Uart*, int);
  int (*bits)(Uart*, int);
  int (*stop)(Uart*, int);
  int (*parity)(Uart*, int);
  void  (*modemctl)(Uart*, int);
  void  (*rts)(Uart*, int);
  void  (*dtr)(Uart*, int);
  long  (*status)(Uart*, void*, long, long);
  void  (*fifo)(Uart*, int);
  void  (*power)(Uart*, int);
  int (*getc)(Uart*); /* polling versions, for iprint, rdb */
  void  (*putc)(Uart*, int);
};

/*
 *  software UART
 */
struct Uart
{
  void* regs;     /* hardware stuff */
  void* saveregs;   /* place to put registers on power down */
  char* name;     /* internal name */
  ulong freq;     /* clock frequency */
  int bits;     /* bits per character */
  int stop;     /* stop bits */
  int parity;     /* even, odd or no parity */
  int baud;     /* baud rate */
  PhysUart*phys;
  int console;    /* used as a serial console */
  int special;    /* internal kernel device */
  Uart* next;     /* list of allocated uarts */

  QLock;
  int type;     /* ?? */
  int dev;
  int opens;

  int enabled;
  Uart  *elist;     /* next enabled interface */

  int perr;     /* parity errors */
  int ferr;     /* framing errors */
  int oerr;     /* rcvr overruns */
  int berr;     /* no input buffers */
  int serr;     /* input queue overflow */

  /* buffers */
  int (*putc)(Queue*, int);
  Queue *iq;
  Queue *oq;

  Lock  rlock;
  uchar istage[STAGESIZE];
  uchar *iw;
  uchar *ir;
  uchar *ie;

  Lock  tlock;      /* transmit */
  uchar ostage[STAGESIZE];
  uchar *op;
  uchar *oe;
  int drain;

  int modem;      /* hardware flow control on */
  int xonoff;     /* software flow control on */
  int blocked;
  int cts, dsr, dcd;  /* keep track of modem status */ 
  int ctsbackoff;
  int hup_dsr, hup_dcd; /* send hangup upstream? */
  int dohup;

  Rendez  r;
};

extern  Uart* consuart;

//void (*lprint)(char *, int);
@


\subsection*{[[buses/portfns_buses.h]]}

<<portfns_buses.h>>=

// devuart.c
void    uartsetmouseputc(Uart*, int (*)(Queue*, int));
int   uartstageoutput(Uart*);
void    uartkick(void*);
int   uartgetc(void);
//void    uartputc(int);
void    uartputs(char*, int);
void    uartrecv(Uart*, char);
int   uartctl(Uart*, char*);
void    uartmouse(Uart*, int (*)(Queue*, int), int);

// devpnp.c
// dead?
@


\section{[[concurrency/]]}

\subsection*{[[concurrency/386/l_concurrency.s]]}

<<l_concurrency.s>>=
#include "mem.h"

/*
 */
TEXT splhi(SB), $0
shi:
        PUSHFL
        POPL    AX
        TESTL   $0x200, AX
        JZ      alreadyhi
        MOVL    $(MACHADDR+0x04), CX            /* save PC in m->splpc */
        MOVL    (SP), BX
        MOVL    BX, (CX)
alreadyhi:
        CLI
        RET

TEXT spllo(SB), $0
slo:
        PUSHFL
        POPL    AX
        TESTL   $0x200, AX
        JNZ     alreadylo
        MOVL    $(MACHADDR+0x04), CX            /* clear m->splpc */
        MOVL    $0, (CX)
alreadylo:
        STI
        RET

TEXT splx(SB), $0
        MOVL    s+0(FP), AX
        TESTL   $0x200, AX
        JNZ     slo
        JMP     shi

TEXT spldone(SB), $0
        RET

TEXT islo(SB), $0
        PUSHFL
        POPL    AX
        ANDL    $0x200, AX                      /* interrupt enable flag */
        RET

/*
 * Test-And-Set.
 */
TEXT tas(SB), $0
        MOVL    $0xDEADDEAD, AX
        MOVL    lock+0(FP), BX
        // Exchange AX to lock->key. So:
        //  - if the lock was not held, lock->key was 0 and so AX will be 0
        //     and lock->key will be 0xdeaddead
        //  - if the lock was held, AX will be 0xdeaddead and lock->key will
        //    still be 0xdeaddead.
        XCHGL   AX, (BX)                        /* lock->key */
        RET

TEXT _xinc(SB), $0                              /* void _xinc(long*); */
        MOVL    l+0(FP), AX
        LOCK;   INCL 0(AX)
        RET

TEXT _xdec(SB), $0                              /* long _xdec(long*); */
        MOVL    l+0(FP), BX
        XORL    AX, AX
        LOCK;   DECL 0(BX)
        JLT     _xdeclt
        JGT     _xdecgt
        RET
_xdecgt:
        INCL    AX
        RET
_xdeclt:
        DECL    AX
        RET
@


\subsection*{[[concurrency/portdat_concurrency.h]]}

<<portdat_concurrency.h>>=

// There are different code "regions": 
// - user code, 
// - kernel init code
// - kernel code of kernel processes (e.g. the alarm kernel process)
// - kernel code of syscalls (soft interrupt), 
// - kernel code of interrupt handlers (hard interrupt).
//
// There is no mutual exclusion need between user and kernel code. 
// Same for init code as only one processor is used during the
// uninterrupted sequential initialization.
//
// For the kernel code one wants mutual exclusion because of possible race 
// on shared data structures between the syscalls themselves when run
// on different processors (or even when run on one processor as one syscall
// can be interrupted causing a scheduling that will then lead later to
// another syscall), but also between the syscalls and interrupts.
// The flow of control on one processor can be 
//  - User -> Syscall, 
//  - User -> Interrupt,
//  - or even User -> Syscall -> Interrupt. 
//  - one can even have User -> Syscall -> Interrupt -> Interrupt!!
// This is on one processor. Multiple processors lead to more combinations
// where 2 processors can run at the same time 2 interrupt handlers for instance.
// 
// One must take care when using locks inside interrupts as one can deadlock
// if the same lock was used in the enclosing syscall (hence ilock/iunlock)

//*****************************************************************************
// Mutual exclusion
//*****************************************************************************

// tas < Lock < QLock|RWLock|Ref

// used to be in 386/ but the fields were used from port/ so must be portable!
struct Lock
{
  ulong key; // 0 when unset, 0xDEADDEAD when acquired, could be a bool
  bool_ushort isilock; // false when from lock(), true when from ilock()

  ulong sr; // saved priority level when using ilock() to restore in iunlock()
  // virt_addr?
  ulong pc; // for debugging

  // option<ref<Proc>>, None when key = 0?
  Proc  *p; // the process locking should be the same unlocking
  // option<ref<Mach>>, None when key = 0?
  Mach  *m; // not that used, only in iprintcanlock apparently

  // debugging
//#ifdef LOCKCYCLES
  long  lockcycles;
//#endif
};


// Kernel basic lock with Queue (renamed to avoid ambiguity with libc.h Qlock)
struct KQLock
{
  bool  locked;   /* flag */

  // list<ref<Proc>> (next = Proc.qnext)
  Proc  *head;    /* next process waiting for object */
  // list<ref<Proc>> (direct access to tail, queue)
  Proc  *tail;    /* last process waiting for object */

  uintptr qpc;    /* pc of the holder */ // for debugging?

  Lock  use;    /* to access Qlock structure */
};

// Read/Write lock
struct RWlock
{
  int readers;  /* number of readers */
  int writer;   /* number of writers */

  // list<ref<Proc>> (next = Proc.qnext)
  Proc  *head;    /* list of waiting processes */
  // list<ref<Proc>>
  Proc  *tail;
  // option<ref<Proc>> (direct access to tail, queue)
  Proc  *wproc;   /* writing proc */

  ulong wpc;    /* pc of writer */

  Lock  use;
};

// For reference counting shared things (e.g. a Page)
struct Ref
{
  long  ref;

  Lock;
};

//*****************************************************************************
// Synchronization
//*****************************************************************************

// defined in this directory but no functions are operating on in this dir
struct Rendez
{
  // ??
  Proc  *p;

  Lock;
};

struct Sema
{
  long  *addr;
  int waiting;

  //list<Sema> of ??
  Sema  *next;
  Sema  *prev;
  Rendez;
};

// see also Waitq in portdat_processes.h?
@


\subsection*{[[concurrency/portfns_concurrency.h]]}

<<portfns_concurrency.h>>=
// For protecting kernel syscall code from interrupt kernel code: splhi(), splo()
// For very small critical region: taslock
// For bigger region, or when have lots of contention on a lock: qlock

// taslock.c
int lock(Lock*);
void unlock(Lock*);
void ilock(Lock*);
void iunlock(Lock*);
int canlock(Lock*);

// ref.c
long    incref(Ref*);
long    decref(Ref*);

// qlock.c
void    qlock(QLock*);
void    qunlock(QLock*);
int   canqlock(QLock*);

void    rlock(RWlock*);
void    runlock(RWlock*);
int   canrlock(RWlock*);
void    wlock(RWlock*);
void    wunlock(RWlock*);

// in 386/l.s (but used in port)
//@Scheck: Assembly
int   islo(void);
//@Scheck: Assembly
int   splhi(void);
//@Scheck: Assembly
int   spllo(void);
//@Scheck: Assembly
void    splx(int);
//void    splxpc(int);
//long    lcycles(void);
//test-and-set
//@Scheck: Assembly
int tas(void*);
//@Scheck: Assembly
void    _xinc(long*);
//@Scheck: Assembly
long    _xdec(long*);
@


\subsection*{[[concurrency/qlock.c]]}

<<qlock.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

struct QlockStats {
    ulong rlock;
    ulong rlockq;
    ulong wlock;
    ulong wlockq;
    ulong qlock;
    ulong qlockq;
};

struct QlockStats rwstats;

void
qlock(QLock *q)
{
    Proc *p;

    if(m->ilockdepth != 0)
        print("qlock: %#p: ilockdepth %d\n", getcallerpc(&q), m->ilockdepth);
    if(up != nil && up->nlocks.ref)
        print("qlock: %#p: nlocks %lud\n", getcallerpc(&q), up->nlocks.ref);

    if(q->use.key == 0x55555555)
        panic("qlock: q %#p, key 5*\n", q);
    lock(&q->use);
    rwstats.qlock++;
    if(!q->locked) {
        q->locked = true;
        q->qpc = getcallerpc(&q);
        unlock(&q->use);
        return;
    }
    if(up == 0)
        panic("qlock");
    rwstats.qlockq++;
    p = q->tail;
    if(p == 0)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = 0;
    up->state = Queueing;
    up->qpc = getcallerpc(&q);
    unlock(&q->use);
    sched();
    q->qpc = getcallerpc(&q);
}

int
canqlock(QLock *q)
{
    if(!canlock(&q->use))
        return 0;
    if(q->locked){
        unlock(&q->use);
        return 0;
    }
    q->locked = true;
    q->qpc = getcallerpc(&q);
    unlock(&q->use);
    return 1;
}

void
qunlock(QLock *q)
{
    Proc *p;

    lock(&q->use);
    if (q->locked == false)
        print("qunlock called with qlock not held, from %#p\n",
            getcallerpc(&q));
    p = q->head;
    if(p){
        q->head = p->qnext;
        if(q->head == 0)
            q->tail = 0;
        unlock(&q->use);
        ready(p);
        return;
    }
    q->locked = false;
    q->qpc = 0;
    unlock(&q->use);
}

void
rlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    rwstats.rlock++;
    if(q->writer == 0 && q->head == nil){
        /* no writer, go for it */
        q->readers++;
        unlock(&q->use);
        return;
    }

    rwstats.rlockq++;
    p = q->tail;
    if(up == nil)
        panic("rlock");
    if(p == 0)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = 0;
    up->state = QueueingR;
    unlock(&q->use);
    sched();
}

void
runlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    p = q->head;
    if(--(q->readers) > 0 || p == nil){
        unlock(&q->use);
        return;
    }

    /* start waiting writer */
    if(p->state != QueueingW)
        panic("runlock");
    q->head = p->qnext;
    if(q->head == 0)
        q->tail = 0;
    q->writer = 1;
    unlock(&q->use);
    ready(p);
}

void
wlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    rwstats.wlock++;
    if(q->readers == 0 && q->writer == 0){
        /* noone waiting, go for it */
        q->wpc = getcallerpc(&q);
        q->wproc = up;
        q->writer = 1;
        unlock(&q->use);
        return;
    }

    /* wait */
    rwstats.wlockq++;
    p = q->tail;
    if(up == nil)
        panic("wlock");
    if(p == nil)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = 0;
    up->state = QueueingW;
    unlock(&q->use);
    sched();
}

void
wunlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    p = q->head;
    if(p == nil){
        q->writer = 0;
        unlock(&q->use);
        return;
    }
    if(p->state == QueueingW){
        /* start waiting writer */
        q->head = p->qnext;
        if(q->head == nil)
            q->tail = nil;
        unlock(&q->use);
        ready(p);
        return;
    }

    if(p->state != QueueingR)
        panic("wunlock");

    /* waken waiting readers */
    while(q->head != nil && q->head->state == QueueingR){
        p = q->head;
        q->head = p->qnext;
        q->readers++;
        ready(p);
    }
    if(q->head == nil)
        q->tail = nil;
    q->writer = 0;
    unlock(&q->use);
}

/* same as rlock but punts if there are any writers waiting */
int
canrlock(RWlock *q)
{
    lock(&q->use);
    rwstats.rlock++;
    if(q->writer == 0 && q->head == nil){
        /* no writer, go for it */
        q->readers++;
        unlock(&q->use);
        return 1;
    }
    unlock(&q->use);
    return 0;
}
@


\subsection*{[[concurrency/ref.c]]}

<<ref.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

// was in chan.c
// see also _incnt and _deccnt in tasklock.c
long
incref(Ref *r)
{
    long x;

    lock(r);
    x = ++r->ref;
    unlock(r);
    return x;
}

long
decref(Ref *r)
{
    long x;

    lock(r);
    x = --r->ref;
    unlock(r);
    if(x < 0)
        panic("decref pc=%#p", getcallerpc(&r));

    return x;
}
@


\subsection*{[[concurrency/taslock.c]]}

<<taslock.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

// TAS: Test And Set

struct TaslockStats
{
    ulong   locks;
    ulong   glare;
    ulong   inglare;
};

struct TaslockStats lockstats;

#ifdef LOCKCYCLES
long maxlockcycles;
long maxilockcycles;
long cumlockcycles;
long cumilockcycles;
ulong maxlockpc;
ulong maxilockpc;

ulong ilockpcs[0x100] = { [0xff] = 1 };
static int n;
#endif

// See also ref.c incref() and decref(), but we can't use them here as they
// themselves rely on lock() and unlock(). 
static void
inccnt(Ref *r)
{
    _xinc(&r->ref);
}

static int
deccnt(Ref *r)
{
    int x;

    x = _xdec(&r->ref);
    if(x < 0)
        panic("deccnt pc=%#p", getcallerpc(&r));
    return x;
}

//unused:
//static void
//dumplockmem(char *tag, Lock *l)
//{
//  uchar *cp;
//  int i;
//
//  iprint("%s: ", tag);
//  cp = (uchar*)l;
//  for(i = 0; i < 64; i++)
//      iprint("%2.2ux ", cp[i]);
//  iprint("\n");
//}

void
lockloop(Lock *l, ulong pc)
{
    Proc *p;

    p = l->p;
    print("lock %#p loop key %#lux pc %#lux held by pc %#lux proc %lud\n",
        l, l->key, pc, l->pc, p ? p->pid : 0);
    dumpaproc(up);
    if(p != nil)
        dumpaproc(p);
}

int
lock(Lock *l)
{
    int i;
    ulong pc;

    pc = getcallerpc(&l);

    lockstats.locks++;
    if(up)
        inccnt(&up->nlocks);    /* prevent being scheded */
    if(tas(&l->key) == 0){
        if(up)
            up->lastlock = l;
        l->pc = pc;
        l->p = up;
        l->isilock = 0;
                //TODO: not setting l->m = ??
#ifdef LOCKCYCLES
        l->lockcycles = -lcycles();
#endif
        return 0;
    }
    if(up)
        deccnt(&up->nlocks);

    lockstats.glare++;
    for(;;){
        lockstats.inglare++;
        i = 0;
        while(l->key){
            if(conf.nmach < 2 && up && up->edf && (up->edf->flags & Admitted)){
                /*
                 * Priority inversion, yield on a uniprocessor; on a
                 * multiprocessor, the other processor will unlock
                 */
                print("inversion %#p pc %#lux proc %lud held by pc %#lux proc %lud\n",
                    l, pc, up ? up->pid : 0, l->pc, l->p ? l->p->pid : 0);
                up->edf->d = todget(nil);   /* yield to process with lock */
            }
            if(i++ > 100000000){
                i = 0;
                lockloop(l, pc);
            }
        }
        if(up)
            inccnt(&up->nlocks);
        if(tas(&l->key) == 0){
            if(up)
                up->lastlock = l;
            l->pc = pc;
            l->p = up;
            l->isilock = 0;
#ifdef LOCKCYCLES
            l->lockcycles = -lcycles();
#endif
            return 1;
        }
        if(up)
            deccnt(&up->nlocks);
    }
}

// To provide mutual exclusion with interrupt code and avoiding deadlock.
// By using splhi() we disable interrupts while running the critical region
// code.
void
ilock(Lock *l)
{
    ulong x;
    ulong pc;

    pc = getcallerpc(&l);
    lockstats.locks++;

    x = splhi();
    if(tas(&l->key) != 0){
        lockstats.glare++;
        /*
         * Cannot also check l->pc, l->m, or l->isilock here
         * because they might just not be set yet, or
         * (for pc and m) the lock might have just been unlocked.
         */
        for(;;){
            lockstats.inglare++;
            splx(x);
            while(l->key)
                ;
            x = splhi();
            if(tas(&l->key) == 0)
                goto acquire;
        }
    }
acquire:
    m->ilockdepth++;
    if(up)
        up->lastilock = l;
    l->sr = x;
    l->pc = pc;
    l->p = up;
    l->isilock = 1;
        //TODO: why not just l->m = m? 
    l->m = MACHP(m->machno);
#ifdef LOCKCYCLES
    l->lockcycles = -lcycles();
#endif
}

int
canlock(Lock *l)
{
    if(up)
        inccnt(&up->nlocks);
    if(tas(&l->key)){
        if(up)
            deccnt(&up->nlocks);
        return 0;
    }

    if(up)
        up->lastlock = l;
    l->pc = getcallerpc(&l);
    l->p = up;
    l->m = MACHP(m->machno);
    l->isilock = 0;
#ifdef LOCKCYCLES
    l->lockcycles = -lcycles();
#endif
    return 1;
}

void
unlock(Lock *l)
{
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumlockcycles += l->lockcycles;
    if(l->lockcycles > maxlockcycles){
        maxlockcycles = l->lockcycles;
        maxlockpc = l->pc;
    }
#endif
    if(l->key == 0)
        print("unlock: not locked: pc %#p\n", getcallerpc(&l));
    if(l->isilock)
        print("unlock of ilock: pc %lux, held by %lux\n", getcallerpc(&l), l->pc);
    if(l->p != up)
        print("unlock: up changed: pc %#p, acquired at pc %lux, lock p %#p, unlock up %#p\n", getcallerpc(&l), l->pc, l->p, up);
    l->m = nil;
    l->key = 0;
        // for processor caches, to ensure the lock value is seen by other
        // processors so that if they were doing while(l->key) { ... } they
        // can finally exit the while loop.
    coherence();

    if(up && deccnt(&up->nlocks) == 0 && up->delaysched && islo()){
        /*
         * Call sched if the need arose while locks were held
         * But, don't do it from interrupt routines, hence the islo() test
         */
        sched();
    }
}


void
iunlock(Lock *l)
{
    ulong sr;

#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumilockcycles += l->lockcycles;
    if(l->lockcycles > maxilockcycles){
        maxilockcycles = l->lockcycles;
        maxilockpc = l->pc;
    }
    if(l->lockcycles > 2400)
        ilockpcs[n++ & 0xff]  = l->pc;
#endif
    if(l->key == 0)
        print("iunlock: not locked: pc %#p\n", getcallerpc(&l));
    if(!l->isilock)
        print("iunlock of lock: pc %#p, held by %#lux\n", getcallerpc(&l), l->pc);
    if(islo())
        print("iunlock while lo: pc %#p, held by %#lux\n", getcallerpc(&l), l->pc);

    sr = l->sr;
    l->m = nil;
    l->key = 0;
    coherence();
    m->ilockdepth--;
    if(up)
        up->lastilock = nil;
    splx(sr);
}


@


\section{[[console/]]}

\subsection*{[[console/devcons.c]]}

<<devcons.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    "pool.h"

#include    <authsrv.h>

void    (*consdebug)(void) = nil;
void    (*screenputs)(char*, int) = nil;

Queue*  kbdq;           /* unprocessed console input */
Queue*  lineq;          /* processed console input */
Queue*  serialoq;       /* serial console output */
Queue*  kprintoq;       /* console output, for /dev/kprint */
ulong   kprintinuse;        /* test and set whether /dev/kprint is open */
int iprintscreenputs = 1;

static struct
{
    QLock;

    int raw;        /* true if we shouldn't process input */
    Ref ctl;        /* number of opens to the control file */
    int x;      /* index into line */
    char    line[1024]; /* current input line */

    int count;
    int ctlpoff;

    /* a place to save up characters at interrupt time before dumping them in the queue */
    Lock    lockputc;
    char    istage[1024];
    char    *iw;
    char    *ir;
    char    *ie;
} kbd = {
    .iw = kbd.istage,
    .ir = kbd.istage,
    .ie = kbd.istage + sizeof(kbd.istage),
};

char    *sysname;
vlong   fasthz;

static void seedrand(void);
static int  readtime(ulong, char*, int);
static int  readbintime(char*, int);
static int  writetime(char*, int);
static int  writebintime(char*, int);

enum
{
    CMhalt,
    CMreboot,
    CMpanic,
};

Cmdtab rebootmsg[] =
{
    CMhalt,     "halt",     1,
    CMreboot,   "reboot",   0,
    CMpanic,    "panic",    0,
};

void
printinit(void)
{
    lineq = qopen(2*1024, 0, nil, nil);
    if(lineq == nil)
        panic("printinit");
    qnoblock(lineq, 1);
}

int
consactive(void)
{
    if(serialoq)
        return qlen(serialoq) > 0;
    return 0;
}

void
prflush(void)
{
    ulong now;

    now = m->ticks;
    while(consactive())
        if(m->ticks - now >= HZ)
            break;
}

/*
 * Log console output so it can be retrieved via /dev/kmesg.
 * This is good for catching boot-time messages after the fact.
 */
struct {
    Lock lk;
    char buf[KMESGSIZE];
    uint n;
} kmesg;

static void
kmesgputs(char *str, int n)
{
    uint nn, d;

    ilock(&kmesg.lk);
    /* take the tail of huge writes */
    if(n > sizeof kmesg.buf){
        d = n - sizeof kmesg.buf;
        str += d;
        n -= d;
    }

    /* slide the buffer down to make room */
    nn = kmesg.n;
    if(nn + n >= sizeof kmesg.buf){
        d = nn + n - sizeof kmesg.buf;
        if(d)
            memmove(kmesg.buf, kmesg.buf+d, sizeof kmesg.buf-d);
        nn -= d;
    }

    /* copy the data in */
    memmove(kmesg.buf+nn, str, n);
    nn += n;
    kmesg.n = nn;
    iunlock(&kmesg.lk);
}

/*
 *   Print a string on the console.  Convert \n to \r\n for serial
 *   line consoles.  Locking of the queues is left up to the screen
 *   or uart code.  Multi-line messages to serial consoles may get
 *   interspersed with other messages.
 */
static void
putstrn0(char *str, int n, int usewrite)
{
    int m;
    char *t;

    if(!islo())
        usewrite = 0;

    /*
     *  how many different output devices do we need?
     */
    kmesgputs(str, n);

    /*
     *  if someone is reading /dev/kprint,
     *  put the message there.
     *  if not and there's an attached bit mapped display,
     *  put the message there.
     *
     *  if there's a serial line being used as a console,
     *  put the message there.
     */
    if(kprintoq != nil && !qisclosed(kprintoq)){
        if(usewrite)
            qwrite(kprintoq, str, n);
        else
            qiwrite(kprintoq, str, n);
    }else if(screenputs != nil)
        screenputs(str, n);

    if(serialoq == nil){
        uartputs(str, n);
        return;
    }

    while(n > 0) {
        t = memchr(str, '\n', n);
        if(t && !kbd.raw) {
            m = t-str;
            if(usewrite){
                qwrite(serialoq, str, m);
                qwrite(serialoq, "\r\n", 2);
            } else {
                qiwrite(serialoq, str, m);
                qiwrite(serialoq, "\r\n", 2);
            }
            n -= m+1;
            str = t+1;
        } else {
            if(usewrite)
                qwrite(serialoq, str, n);
            else
                qiwrite(serialoq, str, n);
            break;
        }
    }
}

void
putstrn(char *str, int n)
{
    putstrn0(str, n, 0);
}

int noprint;

int
devcons_print(char *fmt, ...)
{
    int n;
    va_list arg;
    char buf[PRINTSIZE];

    if(noprint)
        return -1;

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);
    putstrn(buf, n);

    return n;
}

/*
 * Want to interlock iprints to avoid interlaced output on 
 * multiprocessor, but don't want to deadlock if one processor
 * dies during print and another has something important to say.
 * Make a good faith effort.
 */
static Lock iprintlock;
static int
iprintcanlock(Lock *l)
{
    int i;
    
    for(i=0; i<1000; i++){
        if(canlock(l))
            return 1;
        if(l->m == MACHP(m->machno))
            return 0;
        microdelay(100);
    }
    return 0;
}

int
devcons_iprint(char *fmt, ...)
{
    int n, s, locked;
    va_list arg;
    char buf[PRINTSIZE];

    s = splhi();
    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);
    locked = iprintcanlock(&iprintlock);
    if(screenputs != nil && iprintscreenputs)
        screenputs(buf, n);
    uartputs(buf, n);
    if(locked)
        unlock(&iprintlock);
    splx(s);

    return n;
}

void
devcons_panic(char *fmt, ...)
{
    int n, s;
    va_list arg;
    char buf[PRINTSIZE];

    kprintoq = nil; /* don't try to write to /dev/kprint */

    if(panicking)
        for(;;);
    panicking = 1;

    s = splhi();
    strcpy(buf, "panic: ");
    va_start(arg, fmt);
    n = vseprint(buf+strlen(buf), buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);
    iprint("%s\n", buf);
    if(consdebug)
        (*consdebug)();
    splx(s);
    prflush();
    buf[n] = '\n';
    putstrn(buf, n+1);
    //dumpstack();

        //  exit(1);
}

/* libmp at least contains a few calls to sysfatal; simulate with panic */
//@Scheck: no dead, override also sysfatal from libc/9sys/sysfatal.c
void
sysfatal(char *fmt, ...)
{
    char err[256];
    va_list arg;

    va_start(arg, fmt);
    vseprint(err, err + sizeof err, fmt, arg);
    va_end(arg);
    panic("sysfatal: %s", err);
}

void
devcons__assert(char *fmt)
{
    panic("assert failed at %#p: %s", getcallerpc(&fmt), fmt);
}

int
devcons_pprint(char *fmt, ...)
{
    int n;
    Chan *c;
    va_list arg;
    char buf[2*PRINTSIZE];

    if(up == nil || up->fgrp == nil)
        return 0;

    c = up->fgrp->fd[2];
    if(c==0 || (c->mode!=OWRITE && c->mode!=ORDWR))
        return 0;
    n = snprint(buf, sizeof buf, "%s %lud: ", up->text, up->pid);
    va_start(arg, fmt);
    n = vseprint(buf+n, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    if(waserror())
        return 0;
    devtab[c->type]->write(c, buf, n, c->offset);
    poperror();

    lock(c);
    c->offset += n;
    unlock(c);

    return n;
}

static void
echoscreen(char *buf, int n)
{
    char *e, *p;
    char ebuf[128];
    int x;

    p = ebuf;
    e = ebuf + sizeof(ebuf) - 4;
    while(n-- > 0){
        if(p >= e){
            screenputs(ebuf, p - ebuf);
            p = ebuf;
        }
        x = *buf++;
        if(x == 0x15){
            *p++ = '^';
            *p++ = 'U';
            *p++ = '\n';
        } else
            *p++ = x;
    }
    if(p != ebuf)
        screenputs(ebuf, p - ebuf);
}

static void
echoserialoq(char *buf, int n)
{
    char *e, *p;
    char ebuf[128];
    int x;

    p = ebuf;
    e = ebuf + sizeof(ebuf) - 4;
    while(n-- > 0){
        if(p >= e){
            qiwrite(serialoq, ebuf, p - ebuf);
            p = ebuf;
        }
        x = *buf++;
        if(x == '\n'){
            *p++ = '\r';
            *p++ = '\n';
        } else if(x == 0x15){
            *p++ = '^';
            *p++ = 'U';
            *p++ = '\n';
        } else
            *p++ = x;
    }
    if(p != ebuf)
        qiwrite(serialoq, ebuf, p - ebuf);
}

static void
echo(char *buf, int n)
{
    static int ctrlt, pid;
    int x;
    char *e, *p;

    if(n == 0)
        return;

    e = buf+n;
    for(p = buf; p < e; p++){
        switch(*p){
        case 0x10:  /* ^P */
            if(cpuserver && !kbd.ctlpoff){
                active.exiting = 1;
                return;
            }
            break;
        case 0x14:  /* ^T */
            ctrlt++;
            if(ctrlt > 2)
                ctrlt = 2;
            continue;
        }

        if(ctrlt != 2)
            continue;

        /* ^T escapes */
        ctrlt = 0;
        switch(*p){
        case 'S':
            x = splhi();
            dumpstack();
            procdump();
            splx(x);
            return;
        case 's':
            dumpstack();
            return;
        case 'x':
            xsummary();
            ixsummary();
            mallocsummary();
        //  memorysummary();
            pagersummary();
            return;
        case 'd':
            if(consdebug == nil)
                consdebug = rdb;
            else
                consdebug = nil;
            print("consdebug now %#p\n", consdebug);
            return;
        case 'D':
            if(consdebug == nil)
                consdebug = rdb;
            consdebug();
            return;
        case 'p':
            x = spllo();
            procdump();
            splx(x);
            return;
        case 'q':
            scheddump();
            return;
        case 'k':
            killbig("^t ^t k");
            return;
        case 'r':
            exit(0);
            return;
        }
    }

    qproduce(kbdq, buf, n);
    if(kbd.raw)
        return;
    kmesgputs(buf, n);
    if(screenputs != nil)
        echoscreen(buf, n);
    if(serialoq)
        echoserialoq(buf, n);
}

/*
 *  Called by a uart interrupt for console input.
 *
 *  turn '\r' into '\n' before putting it into the queue.
 */
int
kbdcr2nl(Queue*, int ch)
{
    char *next;

    ilock(&kbd.lockputc);       /* just a mutex */
    if(ch == '\r' && !kbd.raw)
        ch = '\n';
    next = kbd.iw+1;
    if(next >= kbd.ie)
        next = kbd.istage;
    if(next != kbd.ir){
        *kbd.iw = ch;
        kbd.iw = next;
    }
    iunlock(&kbd.lockputc);
    return 0;
}

/*
 *  Put character, possibly a rune, into read queue at interrupt time.
 *  Called at interrupt time to process a character.
 */
int
kbdputc(Queue*, int ch)
{
    int i, n;
    char buf[3];
    Rune r;
    char *next;

    if(kbd.ir == nil)
        return 0;       /* in case we're not inited yet */
    
    ilock(&kbd.lockputc);       /* just a mutex */
    r = ch;
    n = runetochar(buf, &r);
    for(i = 0; i < n; i++){
        next = kbd.iw+1;
        if(next >= kbd.ie)
            next = kbd.istage;
        if(next == kbd.ir)
            break;
        *kbd.iw = buf[i];
        kbd.iw = next;
    }
    iunlock(&kbd.lockputc);
    return 0;
}

/*
 *  we save up input characters till clock time to reduce
 *  per character interrupt overhead.
 */
static void
kbdputcclock(void)
{
    char *iw;

    /* this amortizes cost of qproduce */
    if(kbd.iw != kbd.ir){
        iw = kbd.iw;
        if(iw < kbd.ir){
            echo(kbd.ir, kbd.ie-kbd.ir);
            kbd.ir = kbd.istage;
        }
        if(kbd.ir != iw){
            echo(kbd.ir, iw-kbd.ir);
            kbd.ir = iw;
        }
    }
}

enum{
    Qdir,
    Qbintime,
    Qcons,
    Qconsctl,
    Qcputime,
    Qdrivers,
    Qkmesg,
    Qkprint,
    Qhostdomain,
    Qhostowner,
    Qnull,
    Qosversion,
    Qpgrpid,
    Qpid,
    Qppid,
    Qrandom,
    Qreboot,
    Qswap,
    Qsysname,
    Qsysstat,
    Qtime,
    Quser,
    Qzero,
    Qconfig,
};

enum
{
    VLNUMSIZE=  22,
};

static Dirtab consdir[]={
    ".",    {Qdir, 0, QTDIR},   0,      DMDIR|0555,
    "bintime",  {Qbintime}, 24,     0664,
    "cons",     {Qcons},    0,      0660,
    "consctl",  {Qconsctl}, 0,      0220,
    "cputime",  {Qcputime}, 6*NUMSIZE,  0444,
    "drivers",  {Qdrivers}, 0,      0444,
    "hostdomain",   {Qhostdomain},  DOMLEN,     0664,
    "hostowner",    {Qhostowner},   0,      0664,
    "kmesg",    {Qkmesg},   0,      0440,
    "kprint",   {Qkprint, 0, QTEXCL},   0,  DMEXCL|0440,
    "null",     {Qnull},    0,      0666,
    "osversion",    {Qosversion},   0,      0444,
    "pgrpid",   {Qpgrpid},  NUMSIZE,    0444,
    "pid",      {Qpid},     NUMSIZE,    0444,
    "ppid",     {Qppid},    NUMSIZE,    0444,
    "random",   {Qrandom},  0,      0444,
    "reboot",   {Qreboot},  0,      0660,
    "swap",     {Qswap},    0,      0664,
    "sysname",  {Qsysname}, 0,      0664,
    "sysstat",  {Qsysstat}, 0,      0666,
    "time",     {Qtime},    NUMSIZE+3*VLNUMSIZE,    0664,
    "user",     {Quser},    0,      0666,
    "zero",     {Qzero},    0,      0444,
    "config",   {Qconfig},  0,      0444,
};


static void
consinit(void)
{
    todinit();
    randominit();
    /*
     * at 115200 baud, the 1024 char buffer takes 56 ms to process,
     * processing it every 22 ms should be fine
     */
    addclock0link(kbdputcclock, 22);
}

static Chan*
consattach(char *spec)
{
    return devattach('c', spec);
}

static Walkqid*
conswalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name,nname, consdir, nelem(consdir), devgen);
}

static int
consstat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, consdir, nelem(consdir), devgen);
}

static Chan*
consopen(Chan *c, int omode)
{
    c->aux = nil;
    c = devopen(c, omode, consdir, nelem(consdir), devgen);
    switch((ulong)c->qid.path){
    case Qconsctl:
        incref(&kbd.ctl);
        break;

    case Qkprint:
        if(tas(&kprintinuse) != 0){
            c->flag &= ~COPEN;
            error(Einuse);
        }
        if(kprintoq == nil){
            kprintoq = qopen(8*1024, Qcoalesce, 0, 0);
            if(kprintoq == nil){
                c->flag &= ~COPEN;
                error(Enomem);
            }
            qnoblock(kprintoq, 1);
        }else
            qreopen(kprintoq);
        c->iounit = qiomaxatomic;
        break;
    }
    return c;
}

static void
consclose(Chan *c)
{
    switch((ulong)c->qid.path){
    /* last close of control file turns off raw */
    case Qconsctl:
        if(c->flag&COPEN){
            if(decref(&kbd.ctl) == 0)
                kbd.raw = 0;
        }
        break;

    /* close of kprint allows other opens */
    case Qkprint:
        if(c->flag & COPEN){
            kprintinuse = 0;
            qhangup(kprintoq, nil);
        }
        break;
    }
}

static long
consread(Chan *c, void *buf, long n, vlong off)
{
    ulong l;
    Mach *mp;
    char *b, *bp, ch;
    char tmp[256];      /* must be >= 18*NUMSIZE (Qswap) */
    int i, k, id, send;
    vlong offset = off;
    extern char configfile[];

    if(n <= 0)
        return n;

    switch((ulong)c->qid.path){
    case Qdir:
        return devdirread(c, buf, n, consdir, nelem(consdir), devgen);

    case Qcons:
        qlock(&kbd);
        if(waserror()) {
            qunlock(&kbd);
            nexterror();
        }
        while(!qcanread(lineq)){
            if(qread(kbdq, &ch, 1) == 0)
                continue;
            send = 0;
            if(ch == 0){
                /* flush output on rawoff -> rawon */
                if(kbd.x > 0)
                    send = !qcanread(kbdq);
            }else if(kbd.raw){
                kbd.line[kbd.x++] = ch;
                send = !qcanread(kbdq);
            }else{
                switch(ch){
                case '\b':
                    if(kbd.x > 0)
                        kbd.x--;
                    break;
                case 0x15:  /* ^U */
                    kbd.x = 0;
                    break;
                case '\n':
                case 0x04:  /* ^D */
                    send = 1;
                default:
                    if(ch != 0x04)
                        kbd.line[kbd.x++] = ch;
                    break;
                }
            }
            if(send || kbd.x == sizeof kbd.line){
                qwrite(lineq, kbd.line, kbd.x);
                kbd.x = 0;
            }
        }
        n = qread(lineq, buf, n);
        qunlock(&kbd);
        poperror();
        return n;

    case Qcputime:
        k = offset;
        if(k >= 6*NUMSIZE)
            return 0;
        if(k+n > 6*NUMSIZE)
            n = 6*NUMSIZE - k;
        /* easiest to format in a separate buffer and copy out */
        for(i=0; i<6 && NUMSIZE*i<k+n; i++){
            l = up->time[i];
            if(i == TReal)
                l = MACHP(0)->ticks - l;
            l = TK2MS(l);
            readnum(0, tmp+NUMSIZE*i, NUMSIZE, l, NUMSIZE);
        }
        memmove(buf, tmp+k, n);
        return n;

    case Qkmesg:
        /*
         * This is unlocked to avoid tying up a process
         * that's writing to the buffer.  kmesg.n never 
         * gets smaller, so worst case the reader will
         * see a slurred buffer.
         */
        if(off >= kmesg.n)
            n = 0;
        else{
            if(off+n > kmesg.n)
                n = kmesg.n - off;
            memmove(buf, kmesg.buf+off, n);
        }
        return n;
        
    case Qkprint:
        return qread(kprintoq, buf, n);

    case Qpgrpid:
        return readnum((ulong)offset, buf, n, up->pgrp->pgrpid, NUMSIZE);

    case Qpid:
        return readnum((ulong)offset, buf, n, up->pid, NUMSIZE);

    case Qppid:
        return readnum((ulong)offset, buf, n, up->parentpid, NUMSIZE);

    case Qtime:
        return readtime((ulong)offset, buf, n);

    case Qbintime:
        return readbintime(buf, n);

    case Qhostowner:
        return readstr((ulong)offset, buf, n, eve);

    case Qhostdomain:
        return readstr((ulong)offset, buf, n, hostdomain);

    case Quser:
        return readstr((ulong)offset, buf, n, up->user);

    case Qnull:
        return 0;

    case Qconfig:
        return readstr((ulong)offset, buf, n, configfile);

    case Qsysstat:
        b = smalloc(conf.nmach*(NUMSIZE*11+1) + 1); /* +1 for NUL */
        bp = b;
        for(id = 0; id < 32; id++) {
            if(active.machs & (1<<id)) {
                mp = MACHP(id);
                readnum(0, bp, NUMSIZE, id, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->cs, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->intr, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->syscall, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->pfault, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->tlbfault, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->tlbpurge, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->load, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE,
                    (mp->perf.avg_inidle*100)/mp->perf.period,
                    NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE,
                    (mp->perf.avg_inintr*100)/mp->perf.period,
                    NUMSIZE);
                bp += NUMSIZE;
                *bp++ = '\n';
            }
        }
        if(waserror()){
            free(b);
            nexterror();
        }
        n = readstr((ulong)offset, buf, n, b);
        free(b);
        poperror();
        return n;

    case Qswap:
        snprint(tmp, sizeof tmp,
            "%lud memory\n"
            "%d pagesize\n"
            "%lud kernel\n"
            "%lud/%lud user\n"
            "%lud/%lud swap\n"
            "%lud/%lud kernel malloc\n"
            "%lud/%lud kernel draw\n",
            conf.npage*BY2PG,
            BY2PG,
            conf.npage-conf.upages,
            palloc.user-palloc.freecount, palloc.user,
            conf.nswap-swapalloc.free, conf.nswap,
            mainmem->cursize, mainmem->maxsize,
            imagmem->cursize, imagmem->maxsize);

        return readstr((ulong)offset, buf, n, tmp);

    case Qsysname:
        if(sysname == nil)
            return 0;
        return readstr((ulong)offset, buf, n, sysname);

    case Qrandom:
        return randomread(buf, n);

    case Qdrivers:
        b = malloc(READSTR);
        if(b == nil)
            error(Enomem);
        k = 0;
        for(i = 0; devtab[i] != nil; i++)
            k += snprint(b+k, READSTR-k, "#%C %s\n",
                devtab[i]->dc, devtab[i]->name);
        if(waserror()){
            free(b);
            nexterror();
        }
        n = readstr((ulong)offset, buf, n, b);
        free(b);
        poperror();
        return n;

    case Qzero:
        memset(buf, 0, n);
        return n;

    case Qosversion:
        snprint(tmp, sizeof tmp, "2000");
        n = readstr((ulong)offset, buf, n, tmp);
        return n;

    default:
        print("consread %#llux\n", c->qid.path);
        error(Egreg);
    }
    return -1;      /* never reached */
}

static long
conswrite(Chan *c, void *va, long n, vlong off)
{
    char buf[256], ch;
    long l, bp;
    char *a;
    Mach *mp;
    int id, fd;
    Chan *swc;
    ulong offset;
    Cmdbuf *cb;
    Cmdtab *ct;

    a = va;
    offset = off;

    switch((ulong)c->qid.path){
    case Qcons:
        /*
         * Can't page fault in putstrn, so copy the data locally.
         */
        l = n;
        while(l > 0){
            bp = l;
            if(bp > sizeof buf)
                bp = sizeof buf;
            memmove(buf, a, bp);
            putstrn0(buf, bp, 1);
            a += bp;
            l -= bp;
        }
        break;

    case Qconsctl:
        if(n >= sizeof(buf))
            n = sizeof(buf)-1;
        strncpy(buf, a, n);
        buf[n] = 0;
        for(a = buf; a;){
            if(strncmp(a, "rawon", 5) == 0){
                kbd.raw = 1;
                /* clumsy hack - wake up reader */
                ch = 0;
                qwrite(kbdq, &ch, 1);           
            } else if(strncmp(a, "rawoff", 6) == 0){
                kbd.raw = 0;
            } else if(strncmp(a, "ctlpon", 6) == 0){
                kbd.ctlpoff = 0;
            } else if(strncmp(a, "ctlpoff", 7) == 0){
                kbd.ctlpoff = 1;
            }
            if(a = strchr(a, ' '))
                a++;
        }
        break;

    case Qtime:
        if(!iseve())
            error(Eperm);
        return writetime(a, n);

    case Qbintime:
        if(!iseve())
            error(Eperm);
        return writebintime(a, n);

    case Qhostowner:
        return hostownerwrite(a, n);

    case Qhostdomain:
        return hostdomainwrite(a, n);

    case Quser:
        return userwrite(a, n);

    case Qnull:
        break;

    case Qconfig:
        error(Eperm);
        break;

    case Qreboot:
        if(!iseve())
            error(Eperm);
        cb = parsecmd(a, n);

        if(waserror()) {
            free(cb);
            nexterror();
        }
        ct = lookupcmd(cb, rebootmsg, nelem(rebootmsg));
        switch(ct->index) {
        case CMhalt:
            reboot(nil, 0, 0);
            break;
        case CMreboot:
            rebootcmd(cb->nf-1, cb->f+1);
            break;
        case CMpanic:
            *(ulong*)0=0;
            panic("/dev/reboot");
        }
        poperror();
        free(cb);
        break;

    case Qsysstat:
        for(id = 0; id < 32; id++) {
            if(active.machs & (1<<id)) {
                mp = MACHP(id);
                mp->cs = 0;
                mp->intr = 0;
                mp->syscall = 0;
                mp->pfault = 0;
                mp->tlbfault = 0;
                mp->tlbpurge = 0;
            }
        }
        break;

    case Qswap:
        if(n >= sizeof buf)
            error(Egreg);
        memmove(buf, va, n);    /* so we can NUL-terminate */
        buf[n] = 0;
        /* start a pager if not already started */
        if(strncmp(buf, "start", 5) == 0){
            kickpager();
            break;
        }
        if(!iseve())
            error(Eperm);
        if(buf[0]<'0' || '9'<buf[0])
            error(Ebadarg);
        fd = strtoul(buf, 0, 0);
        swc = fdtochan(fd, -1, 1, 1);
        setswapchan(swc);
        break;

    case Qsysname:
        if(offset != 0)
            error(Ebadarg);
        if(n <= 0 || n >= sizeof buf)
            error(Ebadarg);
        strncpy(buf, a, n);
        buf[n] = 0;
        if(buf[n-1] == '\n')
            buf[n-1] = 0;
        kstrdup(&sysname, buf);
        break;

    default:
        print("conswrite: %#llux\n", c->qid.path);
        error(Egreg);
    }
    return n;
}

Dev consdevtab = {
    'c',
    "cons",

    devreset,
    consinit,
    devshutdown,
    consattach,
    conswalk,
    consstat,
    consopen,
    devcreate,
    consclose,
    consread,
    devbread,
    conswrite,
    devbwrite,
    devremove,
    devwstat,
};

static  ulong   randn;

static void
seedrand(void)
{
    if(!waserror()){
        randomread((void*)&randn, sizeof(randn));
        poperror();
    }
}

int
nrand(int n)
{
    if(randn == 0)
        seedrand();
    randn = randn*1103515245 + 12345 + MACHP(0)->ticks;
    return (randn>>16) % n;
}

//int
//rand(void)
//{
//  nrand(1);
//  return randn;
//}

static uvlong uvorder = 0x0001020304050607ULL;

static uchar*
le2vlong(vlong *to, uchar *f)
{
    uchar *t, *o;
    int i;

    t = (uchar*)to;
    o = (uchar*)&uvorder;
    for(i = 0; i < sizeof(vlong); i++)
        t[o[i]] = f[i];
    return f+sizeof(vlong);
}

static uchar*
vlong2le(uchar *t, vlong from)
{
    uchar *f, *o;
    int i;

    f = (uchar*)&from;
    o = (uchar*)&uvorder;
    for(i = 0; i < sizeof(vlong); i++)
        t[i] = f[o[i]];
    return t+sizeof(vlong);
}

static long order = 0x00010203;

static uchar*
le2long(long *to, uchar *f)
{
    uchar *t, *o;
    int i;

    t = (uchar*)to;
    o = (uchar*)&order;
    for(i = 0; i < sizeof(long); i++)
        t[o[i]] = f[i];
    return f+sizeof(long);
}

//static uchar*
//long2le(uchar *t, long from)
//{
//  uchar *f, *o;
//  int i;
//
//  f = (uchar*)&from;
//  o = (uchar*)&order;
//  for(i = 0; i < sizeof(long); i++)
//      t[i] = f[o[i]];
//  return t+sizeof(long);
//}

char *Ebadtimectl = "bad time control";

/*
 *  like the old #c/time but with added info.  Return
 *
 *  secs    nanosecs    fastticks   fasthz
 */
static int
readtime(ulong off, char *buf, int n)
{
    vlong   nsec, ticks;
    long sec;
    char str[7*NUMSIZE];

    nsec = todget(&ticks);
    if(fasthz == 0LL)
        fastticks((uvlong*)&fasthz);
    sec = nsec/1000000000ULL;
    snprint(str, sizeof(str), "%*lud %*llud %*llud %*llud ",
        NUMSIZE-1, sec,
        VLNUMSIZE-1, nsec,
        VLNUMSIZE-1, ticks,
        VLNUMSIZE-1, fasthz);
    return readstr(off, buf, n, str);
}

/*
 *  set the time in seconds
 */
static int
writetime(char *buf, int n)
{
    char b[13];
    long i;
    vlong now;

    if(n >= sizeof(b))
        error(Ebadtimectl);
    strncpy(b, buf, n);
    b[n] = 0;
    i = strtol(b, 0, 0);
    if(i <= 0)
        error(Ebadtimectl);
    now = i*1000000000LL;
    todset(now, 0, 0);
    return n;
}

/*
 *  read binary time info.  all numbers are little endian.
 *  ticks and nsec are syncronized.
 */
static int
readbintime(char *buf, int n)
{
    int i;
    vlong nsec, ticks;
    uchar *b = (uchar*)buf;

    i = 0;
    if(fasthz == 0LL)
        fastticks((uvlong*)&fasthz);
    nsec = todget(&ticks);
    if(n >= 3*sizeof(uvlong)){
        vlong2le(b+2*sizeof(uvlong), fasthz);
        i += sizeof(uvlong);
    }
    if(n >= 2*sizeof(uvlong)){
        vlong2le(b+sizeof(uvlong), ticks);
        i += sizeof(uvlong);
    }
    if(n >= 8){
        vlong2le(b, nsec);
        i += sizeof(vlong);
    }
    return i;
}

/*
 *  set any of the following
 *  - time in nsec
 *  - nsec trim applied over some seconds
 *  - clock frequency
 */
static int
writebintime(char *buf, int n)
{
    uchar *p;
    vlong delta;
    long period;

    n--;
    p = (uchar*)buf + 1;
    switch(*buf){
    case 'n':
        if(n < sizeof(vlong))
            error(Ebadtimectl);
        le2vlong(&delta, p);
        todset(delta, 0, 0);
        break;
    case 'd':
        if(n < sizeof(vlong)+sizeof(long))
            error(Ebadtimectl);
        p = le2vlong(&delta, p);
        le2long(&period, p);
        todset(-1, delta, period);
        break;
    case 'f':
        if(n < sizeof(uvlong))
            error(Ebadtimectl);
        le2vlong(&fasthz, p);
        if(fasthz <= 0)
            error(Ebadtimectl);
        todsetfreq(fasthz);
        break;
    }
    return n;
}
@


\subsection*{[[console/portdat_console.h]]}

<<portdat_console.h>>=

extern  Queue*  serialoq;
extern  Queue*  kbdq;
extern  Queue*  kprintoq;

// consdevtab
@


\subsection*{[[console/portfns_console.h]]}

<<portfns_console.h>>=

// devcons.c
// in portfns_core.h, to remove some backward dependencies
//int   (*pprint)(char*, ...);
//void    (*_assert)(char*);
void    printinit(void);
int   kbdputc(Queue*, int);
int   consactive(void);
int   kbdcr2nl(Queue*, int);
int   nrand(int);
void    putstrn(char*, int);
// (*print) is declared lib.h
//int   (*iprint)(char*, ...);
//void    (*panic)(char*, ...);
// as a pointer in the original too
void    (*screenputs)(char*, int);
//void    prflush(void);
//int   rand(void);
// overrides also sysfatal from libc/9sys/sysfatal.c, that are called
// from a few libc functions

// rdb.c
void    rdb(void);

// print.c
// overrides _fmtlock, from lib_core/libc/fmt/fmtlock.c that are used
// in fmt related functions

@


\subsection*{[[console/print.c]]}

<<print.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

// overrides functions defined in lib_core/libc/fmt/fmtlock.c 
// to behave in a special way when libc functions related to fmt
// are called in the kernel.

static Lock fmtl;

//@Scheck: no dead, called from libc
void
_fmtlock(void)
{
    lock(&fmtl);
}

//@Scheck: no dead, called from libc
void
_fmtunlock(void)
{
    unlock(&fmtl);
}

//@Scheck: no dead, called from libc
int
_efgfmt(Fmt*)
{
    return -1;
}
@


\subsection*{[[console/rdb.c]]}

<<rdb.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"

#define DBG if(0)scrprint
#pragma varargck argpos scrprint 1
//static Ureg ureg;

static void
scrprint(char *fmt, ...)
{
    char buf[128];
    va_list va;
    int n;

    va_start(va, fmt);
    n = vseprint(buf, buf+sizeof buf, fmt, va)-buf;
    va_end(va);
    putstrn(buf, n);
}

static char*
getline(void)
{
    static char buf[128];
    int i, c;

    for(;;){
        for(i=0; i<nelem(buf) && (c=uartgetc()) != '\n'; i++){
            DBG("%c...", c);
            buf[i] = c;
        }

        if(i < nelem(buf)){
            buf[i] = 0;
            return buf;
        }
    }
}

static void*
addr(char *s, Ureg *ureg, char **p)
{
    ulong a;

    a = strtoul(s, p, 16);
    if(a < sizeof(Ureg))
        return ((uchar*)ureg)+a;
    return (void*)a;
}

static void
talkrdb(Ureg *ureg)
{
    uchar *a;
    char *p, *req;

    serialoq = nil;     /* turn off serial console */
    kprintoq = nil;     /* turn off /dev/kprint if active */
//  scrprint("Plan 9 debugger\n");
    iprint("Edebugger reset\n");
    for(;;){
        req = getline();
        switch(*req){
        case 'r':
            a = addr(req+1, ureg, nil);
            DBG("read %p\n", a);
            iprint("R%.8lux %.2ux %.2ux %.2ux %.2ux\n",
                strtoul(req+1, 0, 16), a[0], a[1], a[2], a[3]);
            break;

        case 'w':
            a = addr(req+1, ureg, &p);
            *(ulong*)a = strtoul(p, nil, 16);
            iprint("W\n");
            break;
/*
 *      case Tmput:
            n = min[4];
            if(n > 4){
                mesg(Rerr, Ecount);
                break;
            }
            a = addr(min+0);
            scrprint("mput %.8lux\n", a);
            memmove(a, min+5, n);
            mesg(Rmput, mout);
            break;
 *
 */
        default:
            DBG("unknown %c\n", *req);
            iprint("Eunknown message\n");
            break;
        }
    }
}

void
rdb(void)
{
    splhi();
    iprint("rdb...");
    callwithureg(talkrdb);
}
@


\section{[[core/]]}

\subsection*{[[core/386/dat.h]]}

<<dat.h>>=
#include "dat_forward.h"
#include "../port/portdat_forward.h"

enum miscsize_dat {
  // used in devcons.c
  KMESGSIZE = (256*1024),  /* lots, for acpi debugging */ // default is 16*1024
  // used by devuart.c
  STAGESIZE = 2048, // default is 64
  // used in Proc
  MAXSYSARG = 5, /* for mount(fd, afd, mpt, flag, arg) */
};

// defines Lock (used inline in Mach in portdat_core.h so must be before)
#include "../port/portdat_concurrency.h"

// defines Conf, Mach
#include "dat_core.h"
#include "../port/portdat_core.h"

// defines Page
#include "dat_memory.h"
#include "../port/portdat_memory.h"

// defines Chan
#include "../port/portdat_files.h"

#include "dat_arch.h"

// defines Proc
#include "dat_processes.h"
#include "../port/portdat_processes.h"

// defines Cmd (use ??)
#include "../port/portdat_misc.h"

// defines Uart
#include "dat_buses.h"
#include "../port/portdat_buses.h"

#include "../port/portdat_console.h"

#include "../port/portdat.h"

/*
 *  parameters for sysproc.c
 */
// I_MAGIC is defined in include/a.out.h
#define AOUT_MAGIC  (I_MAGIC)

/* cpuid instruction result register bits */
// this is actually only used in 386/ code. 
enum misc_dat {
  /* dx */
  Fpuonchip = 1<<0,
  Vmex  = 1<<1,   /* virtual-mode extensions */
  Pse = 1<<3,   /* page size extensions */
  Tsc = 1<<4,   /* time-stamp counter */
  Cpumsr  = 1<<5,   /* model-specific registers, rdmsr/wrmsr */
  Mce = 1<<7,   /* machine-check exception */
  Mtrr  = 1<<12,  /* memory-type range regs.  */
  Pge = 1<<13,  /* page global extension */
  Fxsr  = 1<<24,  /* have SSE FXSAVE/FXRSTOR */
  Sse2  = 1<<26,  /* thus mfence & lfence instr.s */
//  Pae = 1<<6,   /* physical-addr extensions */
//  Cmpxchg8b = 1<<8,
//  Cpuapic = 1<<9,
//  Pse2  = 1<<17,  /* more page size extensions */
//  Clflush = 1<<19,
//  Mmx = 1<<23,
//  Sse = 1<<25,  /* thus sfence instr. */
};
@


\subsection*{[[core/386/dat_core.h]]}

<<dat_core.h>>=

//*****************************************************************************
// Conf extension
//*****************************************************************************

struct ArchConf {
  ulong base0;    /* base of bank 0 */
  ulong base1;    /* base of bank 1 */
};


//*****************************************************************************
// Mach extension
//*****************************************************************************

struct Tss {
  ulong link;     /* link (old TSS selector) */
  ulong esp0;     /* privilege level 0 stack pointer */
  ulong ss0;      /* privilege level 0 stack selector */
  ulong esp1;     /* privilege level 1 stack pointer */
  ulong ss1;      /* privilege level 1 stack selector */
  ulong esp2;     /* privilege level 2 stack pointer */
  ulong ss2;      /* privilege level 2 stack selector */
  ulong xcr3;     /* page directory base register - not used because we don't use trap gates */
  ulong eip;      /* instruction pointer */
  ulong eflags;     /* flags register */
  ulong eax;      /* general registers */
  ulong   ecx;
  ulong edx;
  ulong ebx;
  ulong esp;
  ulong ebp;
  ulong esi;
  ulong edi;
  ulong es;     /* segment selectors */
  ulong cs;
  ulong ss;
  ulong ds;
  ulong fs;
  ulong gs;
  ulong ldt;      /* selector for task's LDT */
  ulong iomap;      /* I/O map base address + T-bit */
};

struct Segdesc
{
  ulong d0;
  ulong d1;
};

struct ArchMach {
  // TODO: have a ArchMachMMU like in bcm/
  ulong*  pdb;      /* page directory base for this processor (va) */
  Tss*  tss;      /* tss for this processor */
  Segdesc *gdt;     /* gdt for this processor */
  Proc* externup;   /* extern register Proc *up */
  Page* pdbpool;
  int pdbcnt;
//  int inclockintr;

  Lock  apictimerlock;
  ArchFPsave *fpsavalign;

  // for perfticks, tsc = time stamp counter
  bool havetsc;

  int loopconst;
  int cpuidax;
  int cpuiddx;
  char  cpuidid[16];
  char* cpuidtype;
  int havepge;
  uvlong tscticks;
  int pdballoc;
  int pdbfree;
  vlong mtrrcap;
  vlong mtrrdef;
  vlong mtrrfix[11];
  vlong mtrrvar[32];    /* 256 max. */

};
@


\subsection*{[[core/386/dat_forward.h]]}

<<dat_forward.h>>=

typedef union ArchFPsave  ArchFPsave;
typedef struct ArchProcNotsave  ArchProcNotsave;
typedef struct ArchProcMMU ArchProcMMU;

typedef struct BIOS32si BIOS32si;
typedef struct BIOS32ci BIOS32ci;
typedef struct FPssestate FPssestate;
typedef struct SFPssestate SFPssestate;
typedef struct FPstate  FPstate;
typedef struct ISAConf  ISAConf;
typedef struct MMU  MMU;
typedef struct PCArch PCArch;
typedef struct Pcidev Pcidev;
typedef struct PCMmap PCMmap;
typedef struct PCMslot  PCMslot;

typedef struct Segdesc  Segdesc;
typedef vlong   Tval;
typedef struct Ureg Ureg;
typedef struct Vctl Vctl;

// was not there, but seems more consistent
typedef struct Tss Tss;
typedef struct Devport Devport;
typedef struct Vctl Vctl;
typedef struct IOMap IOMap;
typedef struct X86type X86type;
typedef struct I8253 I8253;

// needed in arch specific stuff
typedef struct Page Page;
typedef struct Proc Proc;
typedef struct Lock Lock;


#pragma incomplete BIOS32si
#pragma incomplete Pcidev
#pragma incomplete Ureg
@


\subsection*{[[core/386/fns.c]]}

<<fns.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

int (*isaconfig)(char*, int, ISAConf*) = 0;

// was in main.c, could be in lib/386/libc.c (or even lib/libc.c)

int
cistrncmp(char *a, char *b, int n)
{
    unsigned ac, bc;

    while(n > 0){
        ac = *a++;
        bc = *b++;
        n--;

        if(ac >= 'A' && ac <= 'Z')
            ac = 'a' + (ac - 'A');
        if(bc >= 'A' && bc <= 'Z')
            bc = 'a' + (bc - 'A');

        ac -= bc;
        if(ac)
            return ac;
        if(bc == 0)
            break;
    }

    return 0;
}

int
cistrcmp(char *a, char *b)
{
    int ac, bc;

    for(;;){
        ac = *a++;
        bc = *b++;
    
        if(ac >= 'A' && ac <= 'Z')
            ac = 'a' + (ac - 'A');
        if(bc >= 'A' && bc <= 'Z')
            bc = 'a' + (bc - 'A');
        ac -= bc;
        if(ac)
            return ac;
        if(bc == 0)
            break;
    }
    return 0;
}

@


\subsection*{[[core/386/fns.h]]}

<<fns.h>>=
#include "../port/portfns.h"

// used by pcf.c and main.c
void    bootlinks(void);

// defined in lib/latin1.c, used only in 386
long    latin1(Rune*, int);

// used by main.c
void    machinit(void);

// used by main.c
void mmuinit0(void);

// iomap.c
void (*hook_ioalloc)();

//@Scheck: Assembly
void    forkret(void);
//@Scheck: Assembly
void  aamloop(int);
//void  acpiscan(void (*func)(uchar *));
Dirtab* addarchfile(char*, int, long(*)(Chan*,void*,long,vlong), long(*)(Chan*,void*,long,vlong));
void  archinit(void);
void  archrevert(void);
//@Scheck: Assembly
int bios32call(BIOS32ci*, u16int[3]);
int bios32ci(BIOS32si*, BIOS32ci*);
//void  bios32close(BIOS32si*);
BIOS32si* bios32open(char*);
void  cgapost(int);
//void  clockintr(Ureg*, void*);
int (*cmpswap)(long*, long, long);
//@Scheck: Assembly
int cmpswap486(long*, long, long);
//@Scheck: Assembly
void  cpuid(int, ulong regs[]);
int cpuidentify(void);
void  cpuidprint(void);
void  (*cycles)(uvlong*);
//int dmacount(int);
//int dmadone(int);
void  dmaend(int);
int dmainit(int, int);
long  dmasetup(int, void*, long, int);
#define evenaddr(x)       /* x86 doesn't care */
//@Scheck: Assembly
void  fpclear(void);
//@Scheck: Assembly
void  fpenv(ArchFPsave*);
//@Scheck: Assembly
void  fpinit(void);
//@Scheck: Assembly
void  fpoff(void);
//@Scheck: Assembly
void  fpon(void);
void  (*fprestore)(ArchFPsave*);
void  (*fpsave)(ArchFPsave*);
void  fpsavealloc(void);
void  fpsserestore(ArchFPsave*);
//@Scheck: Assembly
void  fpsserestore0(ArchFPsave*);
void  fpssesave(ArchFPsave*);
//@Scheck: Assembly
void  fpssesave0(ArchFPsave*);
//ulong fpstatus(void);
//@Scheck: Assembly
void  fpx87restore(ArchFPsave*);
//@Scheck: Assembly
void  fpx87save(ArchFPsave*);
//@Scheck: Assembly
ulong getcr0(void);
//@Scheck: Assembly
ulong getcr2(void);
//@Scheck: Assembly
ulong getcr3(void);
//@Scheck: Assembly
ulong getcr4(void);
void  guesscpuhz(int);
//@Scheck: Assembly
void  halt(void);
int i8042auxcmd(int);
//int i8042auxcmds(uchar*, int);
void  i8042auxenable(void (*)(int, int));
void  i8042reset(void);
void  i8250console(void);
void* i8250alloc(int, int, int);
void  i8250mouse(char*, int (*)(Queue*, int), int);
void  i8250setmouseputc(char*, int (*)(Queue*, int));
void  i8253enable(void);
void  i8253init(void);
void  i8253link(void);
uvlong  i8253read(uvlong*);
void  i8253timerset(uvlong);
int i8259disable(int);
int i8259enable(Vctl*);
void  i8259init(void);
int i8259isr(int);
void  i8259on(void);
void  i8259off(void);
int i8259vecno(int);
//@Scheck: Assembly
void  idle(void);
void  idlehands(void);
//@Scheck: Assembly
int inb(int);
//void  insb(int, void*, int);
//@Scheck: Assembly
ushort  ins(int);
//@Scheck: Assembly
void  inss(int, void*, int);
//@Scheck: Assembly
ulong inl(int);
//void  insl(int, void*, int);
int intrdisable(int, void (*)(Ureg *, void *), void*, int, char*);
void  intrenable(int, void (*)(Ureg*, void*), void*, int, char*);
//void  introff(void);
//void  intron(void);
//@Scheck: Assembly
void  invlpg(ulong);
void  iofree(int);
void  ioinit(void);
int ioalloc(int, int, int, char*);
//int ioreserve(int, int, int, char*);
int (*isaconfig)(char*, int, ISAConf*);
void  kbdenable(void);
void  kbdinit(void);
#define kmapinval()
//@Scheck: Assembly
void  lgdt(ushort[3]);
//@Scheck: Assembly
void  lidt(ushort[3]);
void  links(void);
//@Scheck: Assembly
void  ltr(ulong);
//@Scheck: Assembly
void  mb386(void);
//@Scheck: Assembly
void  mb586(void);
void  meminit(void);
//void  memorysummary(void);
//@Scheck: Assembly
void  mfence(void);
#define mmuflushtlb(pdb) putcr3(pdb)
void  mmuinit(void);
ulong*  mmuwalk(ulong*, ulong, int, int);
int mtrr(uvlong, uvlong, char *);
void  mtrrclock(void);
int mtrrprint(char *, long);
uchar nvramread(int);
void  nvramwrite(int, uchar);
//@Scheck: Assembly
void  outb(int, int);
//void  outsb(int, void*, int);
//@Scheck: Assembly
void  outs(int, ushort);
//@Scheck: Assembly
void  outss(int, void*, int);
//@Scheck: Assembly
void  outl(int, ulong);
//void  outsl(int, void*, int);
int pcicfgr8(Pcidev*, int);
int pcicfgr16(Pcidev*, int);
int pcicfgr32(Pcidev*, int);
void  pcicfgw8(Pcidev*, int, int);
//void  pcicfgw16(Pcidev*, int, int);
void  pcicfgw32(Pcidev*, int, int);
void  pciclrbme(Pcidev*);
//void  pciclrioe(Pcidev*);
//void  pciclrmwi(Pcidev*);
//int pcigetpms(Pcidev*);
Pcidev* pcimatch(Pcidev*, int, int);
Pcidev* pcimatchtbdf(int);
void  pcireset(void);
//int pciscan(int, Pcidev**);
void  pcisetbme(Pcidev*);
//void  pcisetioe(Pcidev*);
//void  pcisetmwi(Pcidev*);
//int pcisetpms(Pcidev*, int);
void  pcmcisread(PCMslot*);
//int pcmcistuple(int, int, int, void*, int);
PCMmap* pcmmap(int, ulong, int, int);
int pcmspecial(char*, ISAConf*);
int (*_pcmspecial)(char *, ISAConf *);
//void  pcmspecialclose(int);
void  (*_pcmspecialclose)(int);
void  pcmunmap(int, PCMmap*);
int pdbmap(ulong*, ulong, ulong, int);
void  procrestore(Proc*);
void  procsave(Proc*);
void  procsetup(Proc*);
//@Scheck: Assembly
void  putcr0(ulong);
//@Scheck: Assembly
void  putcr3(ulong);
//@Scheck: Assembly
void  putcr4(ulong);
void* rampage(void);
//@Scheck: Assembly
void  rdmsr(int, vlong*);
void  realmode(Ureg*);
void  screeninit(void);
void  (*screenputs)(char*, int);
void* sigsearch(char*);
void  syncclock(void);
void  syscallfmt(int syscallno, ulong pc, va_list list);
void  sysretfmt(int syscallno, va_list list, long ret, uvlong start, uvlong stop);
void* tmpmap(Page*);
void  tmpunmap(void*);
//@Scheck: Assembly
void  touser(void*);
void  trapenable(int, void (*)(Ureg*, void*), void*, char*);
void  trapinit(void);
void  trapinit0(void);
ulong umbmalloc(ulong, int, int);
void  umbfree(ulong, int);
//ulong umbrwmalloc(ulong, int, int);
//void  umbrwfree(ulong, int);
ulong upaalloc(int, int);
//void  upafree(ulong, int);
void  upareserve(ulong, int);
#define userureg(ur) (((ur)->cs & 0xFFFF) == UESEL)
//@Scheck: Assembly
void  vectortable(void);
void* vmap(ulong, int);
int vmapsync(ulong);
void  vunmap(void*, int);
//@Scheck: Assembly
void  wbinvd(void);
//@Scheck: Assembly
void  wrmsr(int, vlong);
//int xchgw(ushort*, int);

//int iounused(int start, int end); not used anymore in vga.c

#define KADDR(a)  kaddr(a)
#define PADDR(a)  paddr((void*)(a))


#define dcflush(a, b)

#define BIOSSEG(a)  KADDR(((uint)(a))<<4)

#define L16GET(p) (((p)[1]<<8)|(p)[0])
#define L32GET(p) (((u32int)L16GET((p)+2)<<16)|L16GET(p))
@


\subsection*{[[core/error.h]]}

<<error.h>>=
//extern char Enoerror[];   /* no error */
extern char Emount[];   /* inconsistent mount */
extern char Eunmount[];   /* not mounted */
extern char Eismtpt[];    /* is a mount point */
extern char Eunion[];   /* not in union */
extern char Emountrpc[];  /* mount rpc error */
extern char Eshutdown[];  /* device shut down */
extern char Enocreate[];  /* mounted directory forbids creation */
extern char Enonexist[];  /* file does not exist */
extern char Eexist[];   /* file already exists */
extern char Ebadsharp[];  /* unknown device in # filename */
extern char Enotdir[];    /* not a directory */
extern char Eisdir[];   /* file is a directory */
extern char Ebadchar[];   /* bad character in file name */
extern char Efilename[];  /* file name syntax */
extern char Eperm[];    /* permission denied */
extern char Ebadusefd[];  /* inappropriate use of fd */
extern char Ebadarg[];    /* bad arg in system call */
extern char Einuse[];   /* device or object already in use */
extern char Eio[];    /* i/o error */
extern char Etoobig[];    /* read or write too large */
extern char Etoosmall[];  /* read or write too small */
//extern char Enoport[];    /* network port not available */
extern char Ehungup[];    /* i/o on hungup channel */
extern char Ebadctl[];    /* bad process or channel control request */
extern char Enodev[];   /* no free devices */
extern char Eprocdied[];  /* process exited */
extern char Enochild[];   /* no living children */
extern char Eioload[];    /* i/o error in demand load */
extern char Enovmem[];    /* virtual memory allocation failed */
extern char Ebadfd[];   /* fd out of range or not open */
extern char Enofd[];    /* no free file descriptors */
extern char Eisstream[];  /* seek on a stream */
extern char Ebadexec[];   /* exec header invalid */
extern char Etimedout[];  /* connection timed out */
extern char Econrefused[];  /* connection refused */
extern char Econinuse[];  /* connection in use */
extern char Eintr[];    /* interrupted */
extern char Enomem[];   /* kernel allocate failed */
//extern char Enoswap[];    /* swap space full */
extern char Esoverlap[];  /* segments overlap */
extern char Emouseset[];  /* mouse type already set */
extern char Eshort[];   /* i/o count too small */
extern char Egreg[];    /* jmk added reentrancy for threads */
extern char Ebadspec[];   /* bad attach specifier */
extern char Enoreg[];   /* process has no saved registers */
extern char Enoattach[];  /* mount/attach disallowed */
extern char Eshortstat[]; /* stat buffer too small */
extern char Ebadstat[];   /* malformed stat buffer */
extern char Enegoff[];    /* negative i/o offset */
extern char Ecmdargs[];   /* wrong #args in control message */
extern char Ebadip[];   /* bad ip address syntax */
extern char Edirseek[];   /* seek in directory */
extern char Echange[];    /* media or partition has changed */
//extern char Estalled[];   /* endpoint stalled */
//extern char Edetach[];    /* device is detached */
//extern char Enotconf[];   /* endpoint not configured */
//extern char Eaoedown[];   /* aoe device is down */

@


\subsection*{[[core/errstr.c]]}

<<errstr.c>>=
char Emount[] = "inconsistent mount";
char Eunmount[] = "not mounted";
char Eismtpt[] = "is a mount point";
char Eunion[] = "not in union";
char Emountrpc[] = "mount rpc error";
char Eshutdown[] = "device shut down";
char Enocreate[] = "mounted directory forbids creation";
char Enonexist[] = "file does not exist";
char Eexist[] = "file already exists";
char Ebadsharp[] = "unknown device in # filename";
char Enotdir[] = "not a directory";
char Eisdir[] = "file is a directory";
char Ebadchar[] = "bad character in file name";
char Efilename[] = "file name syntax";
char Eperm[] = "permission denied";
char Ebadusefd[] = "inappropriate use of fd";
char Ebadarg[] = "bad arg in system call";
char Einuse[] = "device or object already in use";
char Eio[] = "i/o error";
char Etoobig[] = "read or write too large";
char Etoosmall[] = "read or write too small";
char Ehungup[] = "i/o on hungup channel";
char Ebadctl[] = "bad process or channel control request";
char Enodev[] = "no free devices";
char Eprocdied[] = "process exited";
char Enochild[] = "no living children";
char Eioload[] = "i/o error in demand load";
char Enovmem[] = "virtual memory allocation failed";
char Ebadfd[] = "fd out of range or not open";
char Enofd[] = "no free file descriptors";
char Eisstream[] = "seek on a stream";
char Ebadexec[] = "exec header invalid";
char Etimedout[] = "connection timed out";
char Econrefused[] = "connection refused";
char Econinuse[] = "connection in use";
char Eintr[] = "interrupted";
char Enomem[] = "kernel allocate failed";
char Esoverlap[] = "segments overlap";
char Emouseset[] = "mouse type already set";
char Eshort[] = "i/o count too small";
char Egreg[] = "jmk added reentrancy for threads";
char Ebadspec[] = "bad attach specifier";
char Enoreg[] = "process has no saved registers";
char Enoattach[] = "mount/attach disallowed";
char Eshortstat[] = "stat buffer too small";
char Ebadstat[] = "malformed stat buffer";
char Enegoff[] = "negative i/o offset";
char Ecmdargs[] = "wrong #args in control message";
char Ebadip[] = "bad ip address syntax";
char Edirseek[] = "seek in directory";
char Echange[] = "media or partition has changed";

@


\subsection*{[[core/portdat.c]]}

<<portdat.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// was in init/main.c
Conf conf;
// bool cpuserver; // defined in conf/pcf.c

// conf (boot) parameters *e.g. { "*kernelpercent*" => "60" }
// hash<string, string>
char *confname[MAXCONF];
char *confval[MAXCONF];
// Hashtbl.length(confname)
int nconf;

char* getconf(char *name)
{
        int i;
        for(i = 0; i < nconf; i++)
                if(cistrcmp(confname[i], name) == 0)
                        return confval[i];
        return nil;
}

// was in init/main.c
Mach *m;
// was in dat.h
Mach* machp[MAXMACH];

// was in security/auth.c
char    *eve;
// should be in portfns.c, but then backward deps
/*
 *  return true if current user is eve
 */
bool iseve(void) { 
  return strcmp(eve, up->user) == 0; 
}

// was in console/devcons.c, but used also by edf.c
int panicking;
@


\subsection*{[[core/portdat.h]]}

<<portdat.h>>=

// could be put in lib.h
#define MIN(a, b) ((a) < (b)? (a): (b))
//#define MAX(a, b) ((a) > (b)? (a): (b))
#define HOWMANY(x, y) (((x)+((y)-1))/(y))
#define ROUNDUP(x, y) (HOWMANY((x), (y))*(y)) /* ceiling */
//#define ROUNDDN(x, y) (((x)/(y))*(y))   /* floor */
#define ROUND(s, sz)  (((s)+(sz-1))&~(sz-1))
// BY2PG is defined in mem.h, which should always be included before "dat.h"!
#define PGROUND(s)  ROUNDUP(s, BY2PG)

// convenient constants
enum miscsize_portdat
{
  PRINTSIZE = 256,
  NUMSIZE = 12,   /* size of formatted number */
  MB =    (1024*1024),
  /* READSTR was 1000, which is way too small for usb's ctl file */
  READSTR = 4000,   /* temporary buffer size for device reads */
  //  MAXCRYPT =  127,
};

/*
 * For multi-bit fields use FIELD(v, o, w) where 'v' is the value
 * of the bit-field of width 'w' with LSb at bit offset 'o'.
 */
//#define FIELD(v, o, w)  (((v) & ((1<<(w))-1))<<(o))
//#define FCLR(d, o, w) ((d) & ~(((1<<(w))-1)<<(o)))
//#define FEXT(d, o, w) (((d)>>(o)) & ((1<<(w))-1))
//#define FINS(d, o, w, v) (FCLR((d), (o), (w))|FIELD((v), (o), (w)))
//#define FSET(d, o, w) ((d)|(((1<<(w))-1)<<(o)))
//#define FMASK(o, w) (((1<<(w))-1)<<(o))

//#define MAXBY2PG BY2PG    /* rounding for UTZERO in executables */

//enum
//{
//  NSMAX = 1000,
//  NSLOG = 7,
//  NSCACHE = (1<<NSLOG),
//};
//enum
//{
//  NCMDFIELD = 128
//};
/*
 *  action log
 */
//struct Log {
//  Lock;
//  int opens;
//  char* buf;
//  char  *end;
//  char  *rptr;
//  int len;
//  int nlog;
//  int minread;
//
//  int logmask;  /* mask of things to debug */
//
//  QLock readq;
//  Rendez  readr;
//};
//
//struct Logflag {
//  char* name;
//  int mask;
//};
//

#pragma varargck  type  "I" uchar*
#pragma varargck  type  "V" uchar*
#pragma varargck  type  "E" uchar*
#pragma varargck  type  "M" uchar*
@


\subsection*{[[core/portdat_core.h]]}

<<portdat_core.h>>=

// All those structs used to be in dat.h, in 386/, but many of their fields
// were used from port/ so I've moved them here (and put the arch
// specific fields in dat_core.h)

// less: have a conf.c, mach.c?

//*****************************************************************************
// Conf
//*****************************************************************************

// memory "bank"
struct Confmem
{
  ulong base; // phys?
  ulong npage;

  ulong kbase; // phys?
  ulong klimit; // phys?
};

struct Conf
{
  ulong nmach;    /* processors */
  ulong nproc;    /* processes */
  // in bcm/ it's [1], important? 
  Confmem mem[4];   /* physical memory */

  bool_ulong monitor;  /* has monitor? */

  ulong npage;    /* total physical pages of memory */
  ulong upages;   /* user page pool */
  ulong nimage;   /* number of page cache image headers */
  ulong nswap;    /* number of swap pages */

  int nswppo;   /* max # of pageouts per segment pass */

  bool_ulong copymode; /* 0 is copy on write, 1 is copy on reference */
  ulong ialloc;   /* max interrupt time allocation in bytes */
  ulong pipeqsize;  /* size in bytes of pipe queues */
  int nuart;    /* number of uart devices */

  struct ArchConf;
};


extern Conf conf;

// hash<string, string>
#define MAXCONF         64
extern char *confname[];
extern char *confval[];
// Hashtbl.length(confname)
extern int nconf;
extern bool cpuserver; // defined in conf/pcf.c

char* getconf(char *name);

//*****************************************************************************
// Mach
//*****************************************************************************

// =~ a jumpbuf in C, for coroutines
struct Label
{
  ulong sp; // virt_addr?
  ulong pc; // virt_addr?
};

/*
 *  performance timers, all units in perfticks
 */
struct Perf
{
  // intr-ts? interrupt time stamp?
  ulong intrts;   /* time of last interrupt */
  ulong inintr;   /* time since last clock tick in interrupt handlers */
  ulong avg_inintr; /* avg time per clock tick in interrupt handlers */
  ulong inidle;   /* time since last clock tick in idle loop */
  ulong avg_inidle; /* avg time per clock tick in idle loop */
  ulong last;   /* value of perfticks() at last clock tick */
  ulong period;   /* perfticks() per clock tick */
};



struct Mach
{
  int machno;     /* physical id of processor (KNOWN TO ASSEMBLY) */
  // must be second field at 0x04, used by splhi()
  ulong splpc;      /* pc of last caller to splhi */

  // ref<Proc>
  Proc* proc;     /* current process on this processor */

  ulong ticks;      /* of the clock since boot time */
  Label sched;      /* scheduler wakeup */
  Lock  alarmlock;    /* access to alarm list */
  void* alarm;      /* alarms bound to this clock */

  Proc* readied;    /* for runproc */
  ulong schedticks;   /* next forced context switch */

  int flushmmu;   /* make current proc flush it's mmu state */

  struct ArchMach;

    /* stats */
  int tlbfault;
  int tlbpurge;
  int pfault;
  int cs;
  int syscall;
  int load;
  int intr;

  ulong spuriousintr;
  int lastintr;
  int ilockdepth;
  Perf  perf;     /* performance counters */

  int cpumhz;
  uvlong  cpuhz;
  uvlong  cyclefreq;    /* Frequency of user readable cycle counter */

  int stack[1];
};

// ref<Mach>, the actual Mach is where??
extern Mach *m;
/*
 * Each processor sees its own Mach structure at address MACHADDR.
 * However, the Mach structures must also be available via the per-processor
 * MMU information array machp, mainly for disambiguation and access to
 * the clock which is only maintained by the bootstrap processor (0).
 */
// array<ref<Mach>>, MAXMACH is defined in 386/mem.h
extern Mach* machp[MAXMACH];
#define MACHP(n)  (machp[n])

// up = user process, MACHADDR is defined in 386/mem.h
//TODO: mv in 386/ TODO: why not m->externup? m is not valid?
#define up  (((Mach*)MACHADDR)->externup)

//*****************************************************************************
// Other
//*****************************************************************************

extern char* eve;
int iseve(void);
// accessed by /dev/hostdomain, defined in auth.c
extern  char  hostdomain[];

// defined in ???
extern ulong    kerndate; 

// used to be in devcons.c, but used also by edf.c
extern int panicking;
@


\subsection*{[[core/portdat_forward.h]]}

<<portdat_forward.h>>=

typedef struct Alarms Alarms;
typedef struct Block  Block;
typedef struct Chan Chan;
typedef struct Cmdbuf Cmdbuf;
typedef struct Cmdtab Cmdtab;
typedef struct Dev  Dev;
typedef struct Dirtab Dirtab;
typedef struct Edf  Edf;
typedef struct Egrp Egrp;
typedef struct Evalue Evalue;
typedef struct Execvals Execvals;
typedef struct Fgrp Fgrp;
typedef struct DevConf  DevConf;
typedef struct KImage KImage;
typedef struct Log  Log;
typedef struct Logflag  Logflag;
typedef struct Mntcache Mntcache;
typedef struct Mount  Mount;
typedef struct Mntrpc Mntrpc;
typedef struct Mntwalk  Mntwalk;
typedef struct Mnt  Mnt;
typedef struct Mhead  Mhead;
typedef struct Note Note;
typedef struct Page Page;
typedef struct Path Path;
typedef struct Palloc Palloc;
typedef struct Pallocmem  Pallocmem;
typedef struct Perf Perf;
typedef struct PhysUart PhysUart;
typedef struct Pgrp Pgrp;
typedef struct Physseg  Physseg;
typedef struct Proc Proc;
typedef struct Pte  Pte;
typedef struct KQLock QLock;
typedef struct Queue  Queue;
typedef struct Ref  Ref;
typedef struct Rendez Rendez;
typedef struct Rgrp Rgrp;
typedef struct RWlock RWlock;
typedef struct Sargs  Sargs;
typedef struct Schedq Schedq;
typedef struct Segment  Segment;
typedef struct Sema Sema;
typedef struct Timer  Timer;
typedef struct Timers Timers;
typedef struct Uart Uart;
typedef struct Waitq  Waitq;
typedef struct Walkqid  Walkqid;
typedef struct Watchdog Watchdog;

typedef int    Devgen(Chan*, char*, Dirtab*, int, int, Dir*);

// was in dat_forward.h
typedef struct Conf Conf;
typedef struct Confmem  Confmem;
typedef struct Lock Lock;
typedef struct Mach Mach;
typedef struct Label  Label;

// was in cache.c
typedef struct Extent Extent;
typedef struct Mntcache Mntcache;
// was in edf.h
typedef struct Edf    Edf;
// was in qio.c
typedef struct Queue  Queue;
// was in xallo.c
typedef struct Hole Hole;
typedef struct Xalloc Xalloc;
typedef struct Xhdr Xhdr;

#pragma incomplete DevConf
#pragma incomplete Edf
#pragma incomplete Mntcache
#pragma incomplete Mntrpc
#pragma incomplete Queue
#pragma incomplete Timers
@


\subsection*{[[core/portfns.c]]}

<<portfns.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// backward dependencies breaker for non functional properties functions
// (logging, security, error, profiling/timing)

// console/devcons.c
int (*print)(char*, ...) = 0;
int (*iprint)(char*, ...) = 0;
int (*pprint)(char *fmt, ...) = 0;

void (*panic)(char*, ...) = 0;
void (*_assert)(char *fmt) = 0;

// process/386/trap.c
void (*dumpstack)(void) = 0;
// process/proc.c
void (*dumpaproc)(Proc*) = 0;


// process/proc.c
void (*error)(char*) = 0;
void (*nexterror)(void) = 0;

void (*sched)(void) = 0;
void (*ready)(Proc*) = 0;
Proc* (*wakeup)(Rendez*) = 0;
void (*sleep)(Rendez*, int(*)(void*), void*) = 0;
void (*tsleep)(Rendez*, int (*)(void*), void*, ulong) = 0;

Proc* (*proctab)(int) = 0;
int (*postnote)(Proc*, int, char*, int) = 0;
void (*pexit)(char*, int) = 0;

//process/sysproc.c
int (*return0)(void*) = 0;

// files/chan.c
void (*cclose)(Chan*);

// init/main.c
void (*exit)(int ispanic) = 0;

// misc/386/devarch.c
void (*coherence)(void) = 0;

// misc/386/devarch.c
uvlong (*fastticks)(uvlong*) = 0;

// processes/386/i8253.c
void (*microdelay)(int) = 0;
void (*delay)(int) = 0;


// was in devcons.c, could be in lib/misc.c
int
readnum(ulong off, char *buf, ulong n, ulong val, int size)
{
    char tmp[64];

    snprint(tmp, sizeof(tmp), "%*lud", size-1, val);
    tmp[size-1] = ' ';
    if(off >= size)
        return 0;
    if(off+n > size)
        n = size-off;
    memmove(buf, tmp+off, n);
    return n;
}

int
readstr(ulong off, char *buf, ulong n, char *str)
{
    int size;

    size = strlen(str);
    if(off >= size)
        return 0;
    if(off+n > size)
        n = size-off;
    memmove(buf, str+off, n);
    return n;
}
@


\subsection*{[[core/portfns.h]]}

<<portfns.h>>=

#include "../port/portfns_core.h"
#include "../port/portfns_concurrency.h"
#include "../port/portfns_memory.h"
#include "../port/portfns_files.h"
#include "../port/portfns_processes.h"
#include "../port/portfns_misc.h"
#include "../port/portfns_console.h"
#include "../port/portfns_buses.h"
#include "../port/portfns_devices.h"
#include "../port/portfns_security.h"
#include "../port/portfns_network.h"
#include "../port/portfns_init.h"

//unused and undefined:
//void    addwatchdog(Watchdog*);
//long    clrfpintr(void);
//int   decrypt(void*, void*, int);
//int   encrypt(void*, void*, int);
//int   eqchan(Chan*, Chan*, int);
//void    logopen(Log*);
//void    logclose(Log*);
//char*   logctl(Log*, int, char**, Logflag*);
//void    logn(Log*, int, void*, int);
//long    logread(Log*, void*, ulong, long);
//void    log(Log*, int, char*, ...);
//void    resched(char*);
//void    savefpregs(FPsave*);
@


\subsection*{[[core/portfns_core.h]]}

<<portfns_core.h>>=

// exported in lib.h, defined in portfns.c
// (*print)

// exported in lib.h, defined in 386/fns.c (but used in port)
// int  cistrcmp(char*, char*);
// int  cistrncmp(char*, char*, int);

// portfns.c (mostly here just to remove some backward dependencies)
// console/devcons.c
int   (*iprint)(char*, ...);
int   (*pprint)(char*, ...);
void    (*panic)(char*, ...);
void    (*_assert)(char*);
// process/386/trap.c
void    (*dumpstack)(void);
// process/proc.c
void    (*dumpaproc)(Proc*);
// process/proc.c
void    (*error)(char*);
void    (*nexterror)(void);
// process/proc.c
void    (*sleep)(Rendez*, int(*)(void*), void*);
void    (*tsleep)(Rendez*, int (*)(void*), void*, ulong);
Proc*   (*wakeup)(Rendez*);
void    (*sched)(void);
void    (*ready)(Proc*);
// process/proc.c
Proc*   (*proctab)(int);
int     (*postnote)(Proc*, int, char*, int);
void    (*pexit)(char*, int);
//process/sysproc.c
int   (*return0)(void*);
// files/chan.c
void    (*cclose)(Chan*);
// init/main.c
void    (*exit)(int);
//TODO?char* (*getconf)(char *name) = 0;
//misc/386/devarch.c
void  (*coherence)(void);
//misc/386/devarch.c
uvlong    (*fastticks)(uvlong*);
// processes/386/i8253.c
void    (*microdelay)(int);
void    (*delay)(int);

// portfns.c
int   readnum(ulong, char*, ulong, ulong, int);
int   readstr(ulong, char*, ulong, char*);

#pragma varargck argpos iprint  1
#pragma varargck argpos pprint  1
#pragma varargck argpos panic 1
@


\section{[[devices/]]}

\subsection*{[[devices/keyboard/386/latin1.c]]}

<<latin1.c>>=
#include    "u.h"
#include    "../port/lib.h"
/*
 * The code makes two assumptions: strlen(ld) is 1 or 2; latintab[i].ld can be a
 * prefix of latintab[j].ld only when j<i.
 */
struct cvlist
{
    char    *ld;        /* must be seen before using this conversion */
    char    *si;        /* options for last input characters */
    Rune    *so;        /* the corresponding Rune for each si entry */
} latintab[] = {
#include "../port/latin1.h"
    0,  0,      0
};

/*
 * Given n characters k[0]..k[n-1], find the rune or return -1 for failure.
 */
long
unicode(Rune *k, int n)
{
    long c;
    Rune *r;

    c = 0;
    for(r = &k[1]; r<&k[n]; r++){       /* +1 to skip [Xx] */
        c <<= 4;
        if('0'<=*r && *r<='9')
            c += *r-'0';
        else if('a'<=*r && *r<='f')
            c += 10 + *r-'a';
        else if('A'<=*r && *r<='F')
            c += 10 + *r-'A';
        else
            return -1;
    }
    return c;
}

/*
 * Given n characters k[0]..k[n-1], find the corresponding rune or return -1 for
 * failure, or something < -1 if n is too small.  In the latter case, the result
 * is minus the required n.
 */
long
latin1(Rune *k, int n)
{
    struct cvlist *l;
    int c;
    char* p;

    if(k[0] == 'X')
        if(n>=5)
            return unicode(k, 5);
        else
            return -5;
    if(k[0] == 'x')
        if(n>=UTFmax*2+1)
            return unicode(k, UTFmax*2+1);
        else
            return -(UTFmax+1);
    for(l=latintab; l->ld!=0; l++)
        if(k[0] == l->ld[0]){
            if(n == 1)
                return -2;
            if(l->ld[1] == 0)
                c = k[1];
            else if(l->ld[1] != k[1])
                continue;
            else if(n == 2)
                return -3;
            else
                c = k[2];
            for(p=l->si; *p!=0; p++)
                if(*p == c)
                    return l->so[p - l->si];
            return -1;
        }
    return -1;
}
@


\subsection*{[[devices/keyboard/386/latin1.h]]}

<<latin1.h>>=
@


\subsection*{[[devices/portfns_devices.h]]}

<<portfns_devices.h>>=

// sys/devroot.c
void    addbootfile(char*, uchar*, ulong);
// sys/devmnt.c
Chan*   mntauth(Chan*, char*);
long    mntversion(Chan*, char*, int, int);
// sys/devsrv.c
char*   srvname(Chan*);
// sys/devproc.c
int   procfdprint(Chan*, int, int, char*, int);
// sys/devrtc.c
//long    rtctime(void);
// sys/devenv.c
void    envcpy(Egrp*, Egrp*);
void    ksetenv(char*, char*, int);
char*   getconfenv(void);


// screen/devdraw.c
void    drawactive(int);
void    drawcmap(void);
// mouse/devmouse.c
void    mouseresize(void);

// in screen/386/screen.c (but used in port)
void    getcolor(ulong, ulong*, ulong*, ulong*);
int   setcolor(ulong, ulong, ulong, ulong);
// in keyboard/386/kbd.c (but used in port)
int   kbdgetmap(uint, int*, int*, Rune*);
void    kbdputmap(ushort, ushort, Rune);

@


\subsection*{[[devices/screen/386/cga.c]]}

<<cga.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

enum {
    Black,
    Blue,
    Green,
    Cyan,
    Red,
    Magenta,
    Brown,
    Grey,

    Bright = 0x08,
    Blinking = 0x80,

    Yellow = Bright|Brown,
    White = Bright|Grey,
};
    
enum {
    Width       = 80*2,
    Height      = 25,

    Attr        = (Black<<4)|Grey,  /* high nibble background
                         * low foreground
                         */

    Poststrlen  = 0,
    Postcodelen = 2,
    Postlen     = Poststrlen+Postcodelen,
};

#define CGASCREENBASE   ((uchar*)KADDR(0xB8000))
#define CGA     CGASCREENBASE

static int cgapos;
static Lock cgascreenlock;

static uchar
cgaregr(int index)
{
    outb(0x3D4, index);
    return inb(0x3D4+1) & 0xFF;
}

static void
cgaregw(int index, int data)
{
    outb(0x3D4, index);
    outb(0x3D4+1, data);
}

static void
movecursor(void)
{
    cgaregw(0x0E, (cgapos/2>>8) & 0xFF);
    cgaregw(0x0F, cgapos/2 & 0xFF);
    CGASCREENBASE[cgapos+1] = Attr;
}

static void
cgascreenputc(int c)
{
    int i;
    uchar *p;

    if(c == '\n'){
        cgapos = cgapos/Width;
        cgapos = (cgapos+1)*Width;
    }
    else if(c == '\t'){
        i = 8 - ((cgapos/2)&7);
        while(i-->0)
            cgascreenputc(' ');
    }
    else if(c == '\b'){
        if(cgapos >= 2)
            cgapos -= 2;
        cgascreenputc(' ');
        cgapos -= 2;
    }
    else{
        CGASCREENBASE[cgapos++] = c;
        CGASCREENBASE[cgapos++] = Attr;
    }
    if(cgapos >= Width*Height){
        memmove(CGASCREENBASE, &CGASCREENBASE[Width], Width*(Height-1));
        p = &CGASCREENBASE[Width*(Height-1)];
        for(i=0; i<Width/2; i++){
            *p++ = ' ';
            *p++ = Attr;
        }
        cgapos = Width*(Height-1);
    }
    movecursor();
}

static void
cgascreenputs(char* s, int n)
{
    if(!islo()){
        /*
         * Don't deadlock trying to
         * print in an interrupt.
         */
        if(!canlock(&cgascreenlock))
            return;
    }
    else
        lock(&cgascreenlock);

    while(n-- > 0)
        cgascreenputc(*s++);

    unlock(&cgascreenlock);
}

char hex[] = "0123456789ABCDEF";

void
cgapost(int code)
{
    uchar *cga;

    cga = CGA;
    cga[Width*Height-Postcodelen*2] = hex[(code>>4) & 0x0F];
    cga[Width*Height-Postcodelen*2+1] = Attr;
    cga[Width*Height-Postcodelen*2+2] = hex[code & 0x0F];
    cga[Width*Height-Postcodelen*2+3] = Attr;
}

void
screeninit(void)
{

    cgapos = cgaregr(0x0E)<<8;
    cgapos |= cgaregr(0x0F);
    cgapos *= 2;

    screenputs = cgascreenputs;
}
@


\subsection*{[[devices/storage/386/devfloppy.c]]}

<<devfloppy.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "io.h"
#include    "../port/error.h"

#include    "floppy.h"

/* Intel 82077A (8272A compatible) floppy controller */

/* This module expects the following functions to be defined
 * elsewhere: 
 * 
 * inb()
 * outb()
 * floppyexec()
 * floppyeject() 
 * floppysetup0()
 * floppysetup1()
 * dmainit()
 * dmasetup()
 * dmaend()
 * 
 * On DMA systems, floppyexec() should be an empty function; 
 * on non-DMA systems, dmaend() should be an empty function; 
 * dmasetup() may enforce maximum transfer sizes. 
 */

static void floppyintr(Ureg*);
static int floppyon(FDrive*);
static void floppyoff(FDrive*);
static void floppysetdef(FDrive*);



static void
pcfloppyintr(Ureg *ur, void *a)
{
    USED(a);

    floppyintr(ur);
}

void
floppysetup0(FController *fl)
{
    fl->ndrive = 0;
    if(ioalloc(Psra, 6, 0, "floppy") < 0)
        return;
    if(ioalloc(Pdir, 1, 0, "floppy") < 0){
        iofree(Psra);
        return;
    }
    fl->ndrive = 2;
}

void
floppysetup1(FController *fl)
{
    uchar equip;

    /*
     *  read nvram for types of floppies 0 & 1
     */
    equip = nvramread(0x10);
    if(fl->ndrive > 0){
        fl->d[0].dt = (equip >> 4) & 0xf;
        floppysetdef(&fl->d[0]);
    }
    if(fl->ndrive > 1){
        fl->d[1].dt = equip & 0xf;
        floppysetdef(&fl->d[1]);
    }
    intrenable(IrqFLOPPY, pcfloppyintr, fl, BUSUNKNOWN, "floppy");
}

/*
 *  eject disk ( unknown on safari )
 */
void
floppyeject(FDrive *dp)
{
    floppyon(dp);
    dp->vers++;
    floppyoff(dp);
}

int 
floppyexec(char *a, long b, int c)
{
    USED(a, b, c);
    return b;
}



enum {
    /* file types */
    Qdir=       0, 
    Qdata=      (1<<2),
    Qctl=       (2<<2),
    Qmask=      (3<<2),

    DMAchan=    2,  /* floppy dma channel */
};

#define DPRINT if(floppydebug)print
int floppydebug = 0;

/*
 *  types of drive (from PC equipment byte)
 */
enum
{
    Tnone=      0,
    T360kb=     1,
    T1200kb=    2,
    T720kb=     3,
    T1440kb=    4,
};

FType floppytype[] =
{
 { "3Â½HD", T1440kb, 512, 18, 2, 1, 80, 0x1B, 0x54, 0, },
 { "3Â½DD", T1440kb, 512,  9, 2, 1, 80, 0x1B, 0x54, 2, },
 { "3Â½DD", T720kb,  512,  9, 2, 1, 80, 0x1B, 0x54, 2, },
 { "5Â¼HD", T1200kb, 512, 15, 2, 1, 80, 0x2A, 0x50, 0, },
 { "5Â¼DD", T1200kb, 512,  9, 2, 2, 40, 0x2A, 0x50, 1, },
 { "ATT3B1",    T1200kb, 512,  8, 2, 2, 48, 0x2A, 0x50, 1, },
 { "5Â¼DD", T360kb,  512,  9, 2, 1, 40, 0x2A, 0x50, 2, },
};

/*
 *  bytes per sector encoding for the controller.
 *  - index for b2c is is (bytes per sector/128).
 *  - index for c2b is code from b2c
 */
static int b2c[] =
{
[1] 0,
[2] 1,
[4] 2,
[8] 3,
};
static int c2b[] =
{
    128,
    256,
    512,
    1024,
};

FController fl;

#define MOTORBIT(i) (1<<((i)+4))

/*
 *  predeclared
 */
static int  cmddone(void*);
static void floppyformat(FDrive*, Cmdbuf*);
static void floppykproc(void*);
static void floppypos(FDrive*,long);
static int  floppyrecal(FDrive*);
static int  floppyresult(void);
static void floppyrevive(void);
static long floppyseek(FDrive*, long);
static int  floppysense(void);
static void floppywait(int);
static long floppyxfer(FDrive*, int, void*, long, long);

Dirtab floppydir[]={
    ".",        {Qdir, 0, QTDIR},   0,  0550,
    "fd0disk",      {Qdata + 0},    0,  0660,
    "fd0ctl",       {Qctl + 0}, 0,  0660,
    "fd1disk",      {Qdata + 1},    0,  0660,
    "fd1ctl",       {Qctl + 1}, 0,  0660,
    "fd2disk",      {Qdata + 2},    0,  0660,
    "fd2ctl",       {Qctl + 2}, 0,  0660,
    "fd3disk",      {Qdata + 3},    0,  0660,
    "fd3ctl",       {Qctl + 3}, 0,  0660,
};
#define NFDIR   2   /* directory entries/drive */

enum
{
    CMdebug,
    CMnodebug,
    CMeject,
    CMformat,
    CMreset,
};

static Cmdtab floppyctlmsg[] =
{
    CMdebug,    "debug",    1,
    CMnodebug,  "nodebug", 1,
    CMeject,    "eject",    1,
    CMformat,   "format",   0,
    CMreset,    "reset",    1,
};

static void
fldump(void)
{
    DPRINT("sra %ux srb %ux dor %ux msr %ux dir %ux\n", inb(Psra), inb(Psrb),
        inb(Pdor), inb(Pmsr), inb(Pdir));
}

/*
 *  set floppy drive to its default type
 */
static void
floppysetdef(FDrive *dp)
{
    FType *t;

    for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++)
        if(dp->dt == t->dt){
            dp->t = t;
            floppydir[1+NFDIR*dp->dev].length = dp->t->cap;
            break;
        }
}

static void
floppyreset(void)
{
    FDrive *dp;
    FType *t;
    ulong maxtsize;
    
    floppysetup0(&fl);
    if(fl.ndrive == 0)
        return;

    /*
     *  init dependent parameters
     */
    maxtsize = 0;
    for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++){
        t->cap = t->bytes * t->heads * t->sectors * t->tracks;
        t->bcode = b2c[t->bytes/128];
        t->tsize = t->bytes * t->sectors;
        if(maxtsize < t->tsize)
            maxtsize = t->tsize;
    }

    /*
     * Should check if this fails. Can do so
     * if there is no space <= 16MB for the DMA
     * bounce buffer.
     */
    dmainit(DMAchan, maxtsize);

    /*
     *  allocate the drive storage
     */
    fl.d = xalloc(fl.ndrive*sizeof(FDrive));
    fl.selected = fl.d;

    /*
     *  stop the motors
     */
    fl.motor = 0;
    delay(10);
    outb(Pdor, fl.motor | Fintena | Fena);
    delay(10);

    /*
     *  init drives
     */
    for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++){
        dp->dev = dp - fl.d;
        dp->dt = T1440kb;
        floppysetdef(dp);
        dp->cyl = -1;           /* because we don't know */
        dp->cache = (uchar*)xspanalloc(maxtsize, BY2PG, 64*1024);
        dp->ccyl = -1;
        dp->vers = 0;
    }

    /*
     *  first operation will recalibrate
     */
    fl.confused = 1;

    floppysetup1(&fl);
}

static Chan*
floppyattach(char *spec)
{
    static int kstarted;

    if(fl.ndrive == 0)
        error(Enodev);

    if(kstarted == 0){
        /*
         *  watchdog to turn off the motors
         */
        kstarted = 1;
        kproc("floppy", floppykproc, 0);
    }
    return devattach('f', spec);
}

static Walkqid*
floppywalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static int
floppystat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static Chan*
floppyopen(Chan *c, int omode)
{
    return devopen(c, omode, floppydir, 1+fl.ndrive*NFDIR, devgen);
}

static void
floppyclose(Chan *)
{
}

static void
islegal(ulong offset, long n, FDrive *dp)
{
    if(offset % dp->t->bytes)
        error(Ebadarg);
    if(n % dp->t->bytes)
        error(Ebadarg);
}

/*
 *  check if the floppy has been replaced under foot.  cause
 *  an error if it has.
 *
 *  a seek and a read clears the condition.  this was determined
 *  experimentally, there has to be a better way.
 *
 *  if the read fails, cycle through the possible floppy
 *  density till one works or we've cycled through all
 *  possibilities for this drive.
 */
static void
changed(Chan *c, FDrive *dp)
{
    ulong old;
    FType *start;

    /*
     *  if floppy has changed or first time through
     */
    if((inb(Pdir)&Fchange) || dp->vers == 0){
        DPRINT("changed\n");
        fldump();
        dp->vers++;
        start = dp->t;
        dp->maxtries = 3;   /* limit it when we're probing */

        /* floppyon will fail if there's a controller but no drive */
        dp->confused = 1;   /* make floppyon recal */
        if(floppyon(dp) < 0)
            error(Eio);

        /* seek to the first track */
        floppyseek(dp, dp->t->heads*dp->t->tsize);
        while(waserror()){
            /*
             *  if first attempt doesn't reset changed bit, there's
             *  no floppy there
             */
            if(inb(Pdir)&Fchange)
                nexterror();

            while(++dp->t){
                if(dp->t == &floppytype[nelem(floppytype)])
                    dp->t = floppytype;
                if(dp->dt == dp->t->dt)
                    break;
            }
            floppydir[1+NFDIR*dp->dev].length = dp->t->cap;

            /* floppyon will fail if there's a controller but no drive */
            if(floppyon(dp) < 0)
                error(Eio);

            DPRINT("changed: trying %s\n", dp->t->name);
            fldump();
            if(dp->t == start)
                nexterror();
        }

        /* if the read succeeds, we've got the density right */
        floppyxfer(dp, Fread, dp->cache, 0, dp->t->tsize);
        poperror();
        dp->maxtries = 20;
    }

    old = c->qid.vers;
    c->qid.vers = dp->vers;
    if(old && old != dp->vers)
        error(Eio);
}

static int
readtrack(FDrive *dp, int cyl, int head)
{
    int i, nn, sofar;
    ulong pos;

    nn = dp->t->tsize;
    if(dp->ccyl==cyl && dp->chead==head)
        return nn;
    pos = (cyl*dp->t->heads+head) * nn;
    for(sofar = 0; sofar < nn; sofar += i){
        dp->ccyl = -1;
        i = floppyxfer(dp, Fread, dp->cache + sofar, pos + sofar, nn - sofar);
        if(i <= 0)
            return -1;
    }
    dp->ccyl = cyl;
    dp->chead = head;
    return nn;
}

static long
floppyread(Chan *c, void *a, long n, vlong off)
{
    FDrive *dp;
    long rv;
    int sec, head, cyl;
    long len;
    uchar *aa;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, floppydir, 1+fl.ndrive*NFDIR, devgen);

    rv = 0;
    dp = &fl.d[c->qid.path & ~Qmask];
    switch ((int)(c->qid.path & Qmask)) {
    case Qdata:
        islegal(offset, n, dp);
        aa = a;

        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        floppyon(dp);
        changed(c, dp);
        for(rv = 0; rv < n; rv += len){
            /*
             *  all xfers come out of the track cache
             */
            dp->len = n - rv;
            floppypos(dp, offset+rv);
            cyl = dp->tcyl;
            head = dp->thead;
            len = dp->len;
            sec = dp->tsec;
            if(readtrack(dp, cyl, head) < 0)
                break;
            memmove(aa+rv, dp->cache + (sec-1)*dp->t->bytes, len);
        }
        qunlock(&fl);
        poperror();

        break;
    case Qctl:
        return readstr(offset, a, n, dp->t->name);
    default:
        panic("floppyread: bad qid");
    }

    return rv;
}

static long
floppywrite(Chan *c, void *a, long n, vlong off)
{
    FDrive *dp;
    long rv, i;
    char *aa = a;
    Cmdbuf *cb;
    Cmdtab *ct;
    ulong offset = off;

    rv = 0;
    dp = &fl.d[c->qid.path & ~Qmask];
    switch ((int)(c->qid.path & Qmask)) {
    case Qdata:
        islegal(offset, n, dp);
        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        floppyon(dp);
        changed(c, dp);
        for(rv = 0; rv < n; rv += i){
            floppypos(dp, offset+rv);
            if(dp->tcyl == dp->ccyl)
                dp->ccyl = -1;
            i = floppyxfer(dp, Fwrite, aa+rv, offset+rv, n-rv);
            if(i < 0)
                break;
            if(i == 0)
                error(Eio);
        }
        qunlock(&fl);
        poperror();
        break;
    case Qctl:
        rv = n;
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        qlock(&fl);
        if(waserror()){
            qunlock(&fl);
            nexterror();
        }
        ct = lookupcmd(cb, floppyctlmsg, nelem(floppyctlmsg));
        switch(ct->index){
        case CMeject:
            floppyeject(dp);
            break;
        case CMformat:
            floppyformat(dp, cb);
            break;
        case CMreset:
            fl.confused = 1;
            floppyon(dp);
            break;
        case CMdebug:
            floppydebug = 1;
            break;
        case CMnodebug:
            floppydebug = 0;
            break;
        }
        poperror();
        qunlock(&fl);
        poperror();
        free(cb);
        break;
    default:
        panic("floppywrite: bad qid");
    }

    return rv;
}

static void
floppykproc(void *)
{
    FDrive *dp;

    while(waserror())
        ;
    for(;;){
        for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++){
            if((fl.motor&MOTORBIT(dp->dev))
            && TK2SEC(m->ticks - dp->lasttouched) > 5
            && canqlock(&fl)){
                if(TK2SEC(m->ticks - dp->lasttouched) > 5)
                    floppyoff(dp);
                qunlock(&fl);
            }
        }
        tsleep(&up->sleep, return0, 0, 1000);
    }
}

/*
 *  start a floppy drive's motor.
 */
static int
floppyon(FDrive *dp)
{
    int alreadyon;
    int tries;

    if(fl.confused)
        floppyrevive();

    /* start motor and select drive */
    alreadyon = fl.motor & MOTORBIT(dp->dev);
    fl.motor |= MOTORBIT(dp->dev);
    outb(Pdor, fl.motor | Fintena | Fena | dp->dev);
    if(!alreadyon){
        /* wait for drive to spin up */
        tsleep(&up->sleep, return0, 0, 750);

        /* clear any pending interrupts */
        floppysense();
    }

    /* set transfer rate */
    if(fl.rate != dp->t->rate){
        fl.rate = dp->t->rate;
        outb(Pdsr, fl.rate);
    }

    /* get drive to a known cylinder */
    if(dp->confused)
        for(tries = 0; tries < 4; tries++)
            if(floppyrecal(dp) >= 0)
                break;
    dp->lasttouched = m->ticks;
    fl.selected = dp;

    /* return -1 if this didn't work */
    if(dp->confused)
        return -1;
    return 0;
}

/*
 *  stop the floppy if it hasn't been used in 5 seconds
 */
static void
floppyoff(FDrive *dp)
{
    fl.motor &= ~MOTORBIT(dp->dev);
    outb(Pdor, fl.motor | Fintena | Fena | dp->dev);
}

/*
 *  send a command to the floppy
 */
static int
floppycmd(void)
{
    int i;
    int tries;

    fl.nstat = 0;
    for(i = 0; i < fl.ncmd; i++){
        for(tries = 0; ; tries++){
            if((inb(Pmsr)&(Ffrom|Fready)) == Fready)
                break;
            if(tries > 1000){
                DPRINT("cmd %ux can't be sent (%d)\n", fl.cmd[0], i);
                fldump();

                /* empty fifo, might have been a bad command */
                floppyresult();
                return -1;
            }
            microdelay(8);  /* for machine independence */
        }
        outb(Pfdata, fl.cmd[i]);
    }
    return 0;
}

/*
 *  get a command result from the floppy
 *
 *  when the controller goes ready waiting for a command
 *  (instead of sending results), we're done
 * 
 */
static int
floppyresult(void)
{
    int i, s;
    int tries;

    /* get the result of the operation */
    for(i = 0; i < sizeof(fl.stat); i++){
        /* wait for status byte */
        for(tries = 0; ; tries++){
            s = inb(Pmsr)&(Ffrom|Fready);
            if(s == Fready){
                fl.nstat = i;
                return fl.nstat;
            }
            if(s == (Ffrom|Fready))
                break;
            if(tries > 1000){
                DPRINT("floppyresult: %d stats\n", i);
                fldump();
                fl.confused = 1;
                return -1;
            }
            microdelay(8);  /* for machine independence */
        }
        fl.stat[i] = inb(Pfdata);
    }
    fl.nstat = sizeof(fl.stat);
    return fl.nstat;
}

/*
 *  calculate physical address of a logical byte offset into the disk
 *
 *  truncate dp->length if it crosses a track boundary
 */
static void
floppypos(FDrive *dp, long off)
{
    int lsec;
    int ltrack;
    int end;

    lsec = off/dp->t->bytes;
    ltrack = lsec/dp->t->sectors;
    dp->tcyl = ltrack/dp->t->heads;
    dp->tsec = (lsec % dp->t->sectors) + 1;
    dp->thead = (lsec/dp->t->sectors) % dp->t->heads;

    /*
     *  can't read across track boundaries.
     *  if so, decrement the bytes to be read.
     */
    end = (ltrack+1)*dp->t->sectors*dp->t->bytes;
    if(off+dp->len > end)
        dp->len = end - off;
}

/*
 *  get the interrupt cause from the floppy.
 */
static int
floppysense(void)
{
    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Fsense;
    if(floppycmd() < 0)
        return -1;
    if(floppyresult() < 2){
        DPRINT("can't read sense response\n");
        fldump();
        fl.confused = 1;
        return -1;
    }
    return 0;
}

static int
cmddone(void *)
{
    return fl.ncmd == 0;
}

/*
 *  Wait for a floppy interrupt.  If none occurs in 5 seconds, we
 *  may have missed one.  This only happens on some portables which
 *  do power management behind our backs.  Call the interrupt
 *  routine to try to clear any conditions.
 */
static void
floppywait(int slow)
{
    tsleep(&fl.r, cmddone, 0, slow ? 5000 : 1000);
    if(!cmddone(0)){
        floppyintr(0);
        fl.confused = 1;
    }
}

/*
 *  we've lost the floppy position, go to cylinder 0.
 */
static int
floppyrecal(FDrive *dp)
{
    dp->ccyl = -1;
    dp->cyl = -1;

    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Frecal;
    fl.cmd[fl.ncmd++] = dp->dev;
    if(floppycmd() < 0)
        return -1;
    floppywait(1);
    if(fl.nstat < 2){
        DPRINT("recalibrate: confused %ux\n", inb(Pmsr));
        fl.confused = 1;
        return -1;
    }
    if((fl.stat[0] & (Codemask|Seekend)) != Seekend){
        DPRINT("recalibrate: failed\n");
        dp->confused = 1;
        return -1;
    }
    dp->cyl = fl.stat[1];
    if(dp->cyl != 0){
        DPRINT("recalibrate: wrong cylinder %d\n", dp->cyl);
        dp->cyl = -1;
        dp->confused = 1;
        return -1;
    }

    dp->confused = 0;
    return 0;
}

/*
 *  if the controller or a specific drive is in a confused state,
 *  reset it and get back to a known state
 */
static void
floppyrevive(void)
{
    FDrive *dp;

    /*
     *  reset the controller if it's confused
     */
    if(fl.confused){
        DPRINT("floppyrevive in\n");
        fldump();

        /* reset controller and turn all motors off */
        splhi();
        fl.ncmd = 1;
        fl.cmd[0] = 0;
        outb(Pdor, 0);
        delay(10);
        outb(Pdor, Fintena|Fena);
        delay(10);
        spllo();
        fl.motor = 0;
        fl.confused = 0;
        floppywait(0);

        /* mark all drives in an unknown state */
        for(dp = fl.d; dp < &fl.d[fl.ndrive]; dp++)
            dp->confused = 1;

        /* set rate to a known value */
        outb(Pdsr, 0);
        fl.rate = 0;

        DPRINT("floppyrevive out\n");
        fldump();
    }
}

/*
 *  seek to the target cylinder
 *
 *  interrupt, no results
 */
static long
floppyseek(FDrive *dp, long off)
{
    floppypos(dp, off);
    if(dp->cyl == dp->tcyl)
        return dp->tcyl;
    dp->cyl = -1;

    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = Fseek;
    fl.cmd[fl.ncmd++] = (dp->thead<<2) | dp->dev;
    fl.cmd[fl.ncmd++] = dp->tcyl * dp->t->steps;
    if(floppycmd() < 0)
        return -1;
    floppywait(1);
    if(fl.nstat < 2){
        DPRINT("seek: confused\n");
        fl.confused = 1;
        return -1;
    }
    if((fl.stat[0] & (Codemask|Seekend)) != Seekend){
        DPRINT("seek: failed\n");
        dp->confused = 1;
        return -1;
    }

    dp->cyl = dp->tcyl;
    return dp->tcyl;
}

/*
 *  read or write to floppy.  try up to three times.
 */
static long
floppyxfer(FDrive *dp, int cmd, void *a, long off, long n)
{
    long offset;
    int tries;

    if(off >= dp->t->cap)
        return 0;
    if(off + n > dp->t->cap)
        n = dp->t->cap - off;

    /* retry on error (until it gets ridiculous) */
    tries = 0;
    while(waserror()){
        if(tries++ >= dp->maxtries)
            nexterror();
        DPRINT("floppyxfer: retrying\n");
    }

    dp->len = n;
    if(floppyseek(dp, off) < 0){
        DPRINT("xfer: seek failed\n");
        dp->confused = 1;
        error(Eio);
    }

    /*
     *  set up the dma (dp->len may be trimmed)
     */
    if(waserror()){
        dmaend(DMAchan);
        nexterror();
    }
    dp->len = dmasetup(DMAchan, a, dp->len, cmd==Fread);
    if(dp->len < 0)
        error(Eio);

    /*
     *  start operation
     */
    fl.ncmd = 0;
    fl.cmd[fl.ncmd++] = cmd | (dp->t->heads > 1 ? Fmulti : 0);
    fl.cmd[fl.ncmd++] = (dp->thead<<2) | dp->dev;
    fl.cmd[fl.ncmd++] = dp->tcyl;
    fl.cmd[fl.ncmd++] = dp->thead;
    fl.cmd[fl.ncmd++] = dp->tsec;
    fl.cmd[fl.ncmd++] = dp->t->bcode;
    fl.cmd[fl.ncmd++] = dp->t->sectors;
    fl.cmd[fl.ncmd++] = dp->t->gpl;
    fl.cmd[fl.ncmd++] = 0xFF;
    if(floppycmd() < 0)
        error(Eio);

    /* Poll ready bits and transfer data */
    floppyexec((char*)a, dp->len, cmd==Fread);

    /*
     *  give bus to DMA, floppyintr() will read result
     */
    floppywait(0);
    dmaend(DMAchan);
    poperror();

    /*
     *  check for errors
     */
    if(fl.nstat < 7){
        DPRINT("xfer: confused\n");
        fl.confused = 1;
        error(Eio);
    }
    if((fl.stat[0] & Codemask)!=0 || fl.stat[1] || fl.stat[2]){
        DPRINT("xfer: failed %ux %ux %ux\n", fl.stat[0],
            fl.stat[1], fl.stat[2]);
        DPRINT("offset %lud len %ld\n", off, dp->len);
        if((fl.stat[0]&Codemask)==Cmdexec && fl.stat[1]==Overrun){
            DPRINT("DMA overrun: retry\n");
        } else
            dp->confused = 1;
        error(Eio);
    }

    /*
     *  check for correct cylinder
     */
    offset = fl.stat[3] * dp->t->heads + fl.stat[4];
    offset = offset*dp->t->sectors + fl.stat[5] - 1;
    offset = offset * c2b[fl.stat[6]];
    if(offset != off+dp->len){
        DPRINT("xfer: ends on wrong cyl\n");
        dp->confused = 1;
        error(Eio);
    }
    poperror();

    dp->lasttouched = m->ticks;
    return dp->len;
}

/*
 *  format a track
 */
static void
floppyformat(FDrive *dp, Cmdbuf *cb)
{
    int cyl, h, sec;
    ulong track;
    uchar *buf, *bp;
    FType *t;

    /*
     *  set the type
     */
    if(cb->nf == 2){
        for(t = floppytype; t < &floppytype[nelem(floppytype)]; t++){
            if(strcmp(cb->f[1], t->name)==0 && t->dt==dp->dt){
                dp->t = t;
                floppydir[1+NFDIR*dp->dev].length = dp->t->cap;
                break;
            }
        }
        if(t >= &floppytype[nelem(floppytype)])
            error(Ebadarg);
    } else if(cb->nf == 1){
        floppysetdef(dp);
        t = dp->t;
    } else {
        cmderror(cb, "invalid floppy format command");
        SET(t);
    }

    /*
     *  buffer for per track info
     */
    buf = smalloc(t->sectors*4);
    if(waserror()){
        free(buf);
        nexterror();
    }

    /* force a recalibrate to cylinder 0 */
    dp->confused = 1;
    if(!waserror()){
        floppyon(dp);
        poperror();
    }

    /*
     *  format a track at time
     */
    for(track = 0; track < t->tracks*t->heads; track++){
        cyl = track/t->heads;
        h = track % t->heads;

        /*
         *  seek to track, ignore errors
         */
        floppyseek(dp, track*t->tsize);
        dp->cyl = cyl;
        dp->confused = 0;

        /*
         *  set up the dma (dp->len may be trimmed)
         */
        bp = buf;
        for(sec = 1; sec <= t->sectors; sec++){
            *bp++ = cyl;
            *bp++ = h;
            *bp++ = sec;
            *bp++ = t->bcode;
        }
        if(waserror()){
            dmaend(DMAchan);
            nexterror();
        }
        if(dmasetup(DMAchan, buf, bp-buf, 0) < 0)
            error(Eio);

        /*
         *  start operation
         */
        fl.ncmd = 0;
        fl.cmd[fl.ncmd++] = Fformat;
        fl.cmd[fl.ncmd++] = (h<<2) | dp->dev;
        fl.cmd[fl.ncmd++] = t->bcode;
        fl.cmd[fl.ncmd++] = t->sectors;
        fl.cmd[fl.ncmd++] = t->fgpl;
        fl.cmd[fl.ncmd++] = 0x5a;
        if(floppycmd() < 0)
            error(Eio);

        /* Poll ready bits and transfer data */
        floppyexec((char *)buf, bp-buf, 0);

        /*
         *  give bus to DMA, floppyintr() will read result
         */
        floppywait(1);
        dmaend(DMAchan);
        poperror();

        /*
         *  check for errors
         */
        if(fl.nstat < 7){
            DPRINT("format: confused\n");
            fl.confused = 1;
            error(Eio);
        }
        if((fl.stat[0]&Codemask)!=0 || fl.stat[1]|| fl.stat[2]){
            DPRINT("format: failed %ux %ux %ux\n",
                fl.stat[0], fl.stat[1], fl.stat[2]);
            dp->confused = 1;
            error(Eio);
        }
    }
    free(buf);
    dp->confused = 1;
    poperror();
}

static void
floppyintr(Ureg *)
{
    switch(fl.cmd[0]&~Fmulti){
    case Fread:
    case Fwrite:
    case Fformat:
    case Fdumpreg: 
        floppyresult();
        break;
    case Fseek:
    case Frecal:
    default:
        floppysense();  /* to clear interrupt */
        break;
    }
    fl.ncmd = 0;
    wakeup(&fl.r);
}

Dev floppydevtab = {
    'f',
    "floppy",

    floppyreset,
    devinit,
    devshutdown,
    floppyattach,
    floppywalk,
    floppystat,
    floppyopen,
    devcreate,
    floppyclose,
    floppyread,
    devbread,
    floppywrite,
    devbwrite,
    devremove,
    devwstat,
};
@


\subsection*{[[devices/storage/386/floppy.h]]}

<<floppy.h>>=
typedef struct FController FController;
typedef struct FDrive FDrive;
typedef struct FType FType;

/*
 *  a floppy drive
 */
struct FDrive
{
  FType *t;   /* floppy type */
  int dt;   /* drive type */
  int dev;

  ulong lasttouched;  /* time last touched */
  int cyl;    /* current arm position */
  int confused; /* needs to be recalibrated */
  int vers;
  int maxtries; /* max read attempts before Eio */

  int tcyl;   /* target cylinder */
  int thead;    /* target head */
  int tsec;   /* target sector */
  long  len;    /* size of xfer */

  uchar *cache;   /* track cache */
  int ccyl;
  int chead;
};

/*
 *  controller for 4 floppys
 */
struct FController
{
  QLock;      /* exclusive access to the contoller */

  int ndrive;
  FDrive  *d;   /* the floppy drives */
  FDrive  *selected;
  int rate;   /* current rate selected */
  uchar cmd[14];  /* command */
  int ncmd;   /* # command bytes */
  uchar stat[14]; /* command status */
  int nstat;    /* # status bytes */
  int confused; /* controler needs to be reset */
  Rendez  r;    /* wait here for command termination */
  int motor;    /* bit mask of spinning disks */
};

/*
 *  floppy types (all MFM encoding)
 */
struct FType
{
  char  *name;
  int dt;   /* compatible drive type */
  int bytes;    /* bytes/sector */
  int sectors;  /* sectors/track */
  int heads;    /* number of heads */
  int steps;    /* steps per cylinder */
  int tracks;   /* tracks/disk */
  int gpl;    /* intersector gap length for read/write */ 
  int fgpl;   /* intersector gap length for format */
  int rate;   /* rate code */

  /*
   *  these depend on previous entries and are set filled in
   *  by floppyinit
   */
  int bcode;    /* coded version of bytes for the controller */
  long  cap;    /* drive capacity in bytes */
  long  tsize;    /* track size in bytes */
};
/* bits in the registers */
enum
{
  /* status registers a & b */
  Psra=   0x3f0,
  Psrb=   0x3f1,

  /* digital output register */
  Pdor=   0x3f2,
  Fintena=  0x8,  /* enable floppy interrupt */
  Fena=   0x4,  /* 0 == reset controller */

  /* main status register */
  Pmsr=   0x3f4,
  Fready=   0x80, /* ready to be touched */
  Ffrom=    0x40, /* data from controller */
  Ffloppybusy=  0x10, /* operation not over */

  /* data register */
  Pfdata=   0x3f5,
  Frecal=   0x07, /* recalibrate cmd */
  Fseek=    0x0f, /* seek cmd */
  Fsense=   0x08, /* sense cmd */
  Fread=    0x66, /* read cmd */
  Freadid=  0x4a, /* read track id */
  Fspec=    0x03, /* set hold times */
  Fwrite=   0x45, /* write cmd */
  Fformat=  0x4d, /* format cmd */
  Fmulti=   0x80, /* or'd with Fread or Fwrite for multi-head */
  Fdumpreg= 0x0e, /* dump internal registers */

  /* digital input register */
  Pdir=   0x3F7,  /* disk changed port (read only) */
  Pdsr=   0x3F7,  /* data rate select port (write only) */
  Fchange=  0x80, /* disk has changed */

  /* status 0 byte */
  Drivemask=  3<<0,
  Seekend=  1<<5,
  Codemask= (3<<6)|(3<<3),
  Cmdexec=  1<<6,

  /* status 1 byte */
  Overrun=  0x10,
};


@


\subsection*{[[devices/storage/386/sdata.c]]}

<<sdata.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "io.h"
#include "ureg.h"

#include "../port/sd.h"

extern SDifc sdataifc;

enum {
    DbgCONFIG   = 0x0001,   /* detected drive config info */
    DbgIDENTIFY = 0x0002,   /* detected drive identify info */
    DbgSTATE    = 0x0004,   /* dump state on panic */
    DbgPROBE    = 0x0008,   /* trace device probing */
    DbgDEBUG    = 0x0080,   /* the current problem... */
    DbgINL      = 0x0100,   /* That Inil20+ message we hate */
    Dbg48BIT    = 0x0200,   /* 48-bit LBA */
    DbgBsy      = 0x0400,   /* interrupt but Bsy (shared IRQ) */
};
#define DEBUG       (DbgDEBUG|DbgSTATE)

enum {                  /* I/O ports */
    Data        = 0,
    Error       = 1,        /* (read) */
    Features    = 1,        /* (write) */
    Count       = 2,        /* sector count<7-0>, sector count<15-8> */
    Ir      = 2,        /* interrupt reason (PACKET) */
    Sector      = 3,        /* sector number */
    Lbalo       = 3,        /* LBA<7-0>, LBA<31-24> */
    Cyllo       = 4,        /* cylinder low */
    Bytelo      = 4,        /* byte count low (PACKET) */
    Lbamid      = 4,        /* LBA<15-8>, LBA<39-32> */
    Cylhi       = 5,        /* cylinder high */
    Bytehi      = 5,        /* byte count hi (PACKET) */
    Lbahi       = 5,        /* LBA<23-16>, LBA<47-40> */
    Dh      = 6,        /* Device/Head, LBA<27-24> */
    Status      = 7,        /* (read) */
    Command     = 7,        /* (write) */

    As      = 2,        /* Alternate Status (read) */
    Dc      = 2,        /* Device Control (write) */
};

enum {                  /* Error */
    Med     = 0x01,     /* Media error */
    Ili     = 0x01,     /* command set specific (PACKET) */
    Nm      = 0x02,     /* No Media */
    Eom     = 0x02,     /* command set specific (PACKET) */
    Abrt        = 0x04,     /* Aborted command */
    Mcr     = 0x08,     /* Media Change Request */
    Idnf        = 0x10,     /* no user-accessible address */
    Mc      = 0x20,     /* Media Change */
    Unc     = 0x40,     /* Uncorrectable data error */
    Wp      = 0x40,     /* Write Protect */
    Icrc        = 0x80,     /* Interface CRC error */
};

enum {                  /* Features */
    Dma     = 0x01,     /* data transfer via DMA (PACKET) */
    Ovl     = 0x02,     /* command overlapped (PACKET) */
};

enum {                  /* Interrupt Reason */
    Cd      = 0x01,     /* Command/Data */
    Io      = 0x02,     /* I/O direction: read */
    Rel     = 0x04,     /* Bus Release */
};

enum {                  /* Device/Head */
    Dev0        = 0xA0,     /* Master */
    Dev1        = 0xB0,     /* Slave */
    Lba     = 0x40,     /* LBA mode */
};

enum {                  /* Status, Alternate Status */
    Err     = 0x01,     /* Error */
    Chk     = 0x01,     /* Check error (PACKET) */
    Drq     = 0x08,     /* Data Request */
    Dsc     = 0x10,     /* Device Seek Complete */
    Serv        = 0x10,     /* Service */
    Df      = 0x20,     /* Device Fault */
    Dmrd        = 0x20,     /* DMA ready (PACKET) */
    Drdy        = 0x40,     /* Device Ready */
    Bsy     = 0x80,     /* Busy */
};

enum {                  /* Command */
    Cnop        = 0x00,     /* NOP */
    Cdr     = 0x08,     /* Device Reset */
    Crs     = 0x20,     /* Read Sectors */
    Crs48       = 0x24,     /* Read Sectors Ext */
    Crd48       = 0x25,     /* Read w/ DMA Ext */
    Crdq48      = 0x26,     /* Read w/ DMA Queued Ext */
    Crsm48      = 0x29,     /* Read Multiple Ext */
    Cws     = 0x30,     /* Write Sectors */
    Cws48       = 0x34,     /* Write Sectors Ext */
    Cwd48       = 0x35,     /* Write w/ DMA Ext */
    Cwdq48      = 0x36,     /* Write w/ DMA Queued Ext */
    Cwsm48      = 0x39,     /* Write Multiple Ext */
    Cedd        = 0x90,     /* Execute Device Diagnostics */
    Cpkt        = 0xA0,     /* Packet */
    Cidpkt      = 0xA1,     /* Identify Packet Device */
    Crsm        = 0xC4,     /* Read Multiple */
    Cwsm        = 0xC5,     /* Write Multiple */
    Csm     = 0xC6,     /* Set Multiple */
    Crdq        = 0xC7,     /* Read DMA queued */
    Crd     = 0xC8,     /* Read DMA */
    Cwd     = 0xCA,     /* Write DMA */
    Cwdq        = 0xCC,     /* Write DMA queued */
    Cstandby    = 0xE2,     /* Standby */
    Cid     = 0xEC,     /* Identify Device */
    Csf     = 0xEF,     /* Set Features */
};

enum {                  /* Device Control */
    Nien        = 0x02,     /* (not) Interrupt Enable */
    Srst        = 0x04,     /* Software Reset */
    Hob     = 0x80,     /* High Order Bit [sic] */
};

enum {                  /* PCI Configuration Registers */
    Bmiba       = 0x20,     /* Bus Master Interface Base Address */
    Idetim      = 0x40,     /* IE Timing */
    Sidetim     = 0x44,     /* Slave IE Timing */
    Udmactl     = 0x48,     /* Ultra DMA/33 Control */
    Udmatim     = 0x4A,     /* Ultra DMA/33 Timing */
};

enum {                  /* Bus Master IDE I/O Ports */
    Bmicx       = 0,        /* Command */
    Bmisx       = 2,        /* Status */
    Bmidtpx     = 4,        /* Descriptor Table Pointer */
};

enum {                  /* Bmicx */
    Ssbm        = 0x01,     /* Start/Stop Bus Master */
    Rwcon       = 0x08,     /* Read/Write Control */
};

enum {                  /* Bmisx */
    Bmidea      = 0x01,     /* Bus Master IDE Active */
    Idedmae     = 0x02,     /* IDE DMA Error  (R/WC) */
    Ideints     = 0x04,     /* IDE Interrupt Status (R/WC) */
    Dma0cap     = 0x20,     /* Drive 0 DMA Capable */
    Dma1cap     = 0x40,     /* Drive 0 DMA Capable */
};
enum {                  /* Physical Region Descriptor */
    PrdEOT      = 0x80000000,   /* End of Transfer */
};

enum {                  /* offsets into the identify info. */
    Iconfig     = 0,        /* general configuration */
    Ilcyl       = 1,        /* logical cylinders */
    Ilhead      = 3,        /* logical heads */
    Ilsec       = 6,        /* logical sectors per logical track */
    Iserial     = 10,       /* serial number */
    Ifirmware   = 23,       /* firmware revision */
    Imodel      = 27,       /* model number */
    Imaxrwm     = 47,       /* max. read/write multiple sectors */
    Icapabilities   = 49,       /* capabilities */
    Istandby    = 50,       /* device specific standby timer */
    Ipiomode    = 51,       /* PIO data transfer mode number */
    Ivalid      = 53,
    Iccyl       = 54,       /* cylinders if (valid&0x01) */
    Ichead      = 55,       /* heads if (valid&0x01) */
    Icsec       = 56,       /* sectors if (valid&0x01) */
    Iccap       = 57,       /* capacity if (valid&0x01) */
    Irwm        = 59,       /* read/write multiple */
    Ilba        = 60,       /* LBA size */
    Imwdma      = 63,       /* multiword DMA mode */
    Iapiomode   = 64,       /* advanced PIO modes supported */
    Iminmwdma   = 65,       /* min. multiword DMA cycle time */
    Irecmwdma   = 66,       /* rec. multiword DMA cycle time */
    Iminpio     = 67,       /* min. PIO cycle w/o flow control */
    Iminiordy   = 68,       /* min. PIO cycle with IORDY */
    Ipcktbr     = 71,       /* time from PACKET to bus release */
    Iserbsy     = 72,       /* time from SERVICE to !Bsy */
    Iqdepth     = 75,       /* max. queue depth */
    Imajor      = 80,       /* major version number */
    Iminor      = 81,       /* minor version number */
    Icsfs       = 82,       /* command set/feature supported */
    Icsfe       = 85,       /* command set/feature enabled */
    Iudma       = 88,       /* ultra DMA mode */
    Ierase      = 89,       /* time for security erase */
    Ieerase     = 90,       /* time for enhanced security erase */
    Ipower      = 91,       /* current advanced power management */
    Ilba48      = 100,      /* 48-bit LBA size (64 bits in 100-103) */
    Irmsn       = 127,      /* removable status notification */
    Isecstat    = 128,      /* security status */
    Icfapwr     = 160,      /* CFA power mode */
    Imediaserial    = 176,      /* current media serial number */
    Icksum      = 255,      /* checksum */
};

enum {                  /* bit masks for config identify info */
    Mpktsz      = 0x0003,   /* packet command size */
    Mincomplete = 0x0004,   /* incomplete information */
    Mdrq        = 0x0060,   /* DRQ type */
    Mrmdev      = 0x0080,   /* device is removable */
    Mtype       = 0x1F00,   /* device type */
    Mproto      = 0x8000,   /* command protocol */
};

enum {                  /* bit masks for capabilities identify info */
    Mdma        = 0x0100,   /* DMA supported */
    Mlba        = 0x0200,   /* LBA supported */
    Mnoiordy    = 0x0400,   /* IORDY may be disabled */
    Miordy      = 0x0800,   /* IORDY supported */
    Msoftrst    = 0x1000,   /* needs soft reset when Bsy */
    Mstdby      = 0x2000,   /* standby supported */
    Mqueueing   = 0x4000,   /* queueing overlap supported */
    Midma       = 0x8000,   /* interleaved DMA supported */
};

enum {                  /* bit masks for supported/enabled features */
    Msmart      = 0x0001,
    Msecurity   = 0x0002,
    Mrmmedia    = 0x0004,
    Mpwrmgmt    = 0x0008,
    Mpkt        = 0x0010,
    Mwcache     = 0x0020,
    Mlookahead  = 0x0040,
    Mrelirq     = 0x0080,
    Msvcirq     = 0x0100,
    Mreset      = 0x0200,
    Mprotected  = 0x0400,
    Mwbuf       = 0x1000,
    Mrbuf       = 0x2000,
    Mnop        = 0x4000,
    Mmicrocode  = 0x0001,
    Mqueued     = 0x0002,
    Mcfa        = 0x0004,
    Mapm        = 0x0008,
    Mnotify     = 0x0010,
    Mstandby    = 0x0020,
    Mspinup     = 0x0040,
    Mmaxsec     = 0x0100,
    Mautoacoustic   = 0x0200,
    Maddr48     = 0x0400,
    Mdevconfov  = 0x0800,
    Mflush      = 0x1000,
    Mflush48    = 0x2000,
    Msmarterror = 0x0001,
    Msmartselftest  = 0x0002,
    Mmserial    = 0x0004,
    Mmpassthru  = 0x0008,
    Mlogging    = 0x0020,
};

typedef struct Ctlr Ctlr;
typedef struct Drive Drive;

typedef struct Prd {            /* Physical Region Descriptor */
    ulong   pa;         /* Physical Base Address */
    int count;
} Prd;

enum {
    BMspan      = 64*1024,  /* must be power of 2 <= 64*1024 */

    Nprd        = SDmaxio/BMspan+2,
};

typedef struct Ctlr {
    int cmdport;
    int ctlport;
    int irq;
    int tbdf;
    int bmiba;          /* bus master interface base address */
    int maxio;          /* sector count transfer maximum */
    int span;           /* don't span this boundary with dma */

    Pcidev* pcidev;
    void    (*ienable)(Ctlr*);
    void    (*idisable)(Ctlr*);
    SDev*   sdev;

    Drive*  drive[2];

    Prd*    prdt;           /* physical region descriptor table */
    void    (*irqack)(Ctlr*);   /* call to extinguish ICH intrs */

    QLock;              /* current command */
    Drive*  curdrive;
    int command;        /* last command issued (debugging) */
    Rendez;
    int done;

    /* interrupt counts */
    ulong   intnil;         /* no drive */
    ulong   intbusy;        /* controller still busy */
    ulong   intok;          /* normal */

    Lock;               /* register access */
} Ctlr;

typedef struct Drive {
    Ctlr*   ctlr;

    int dev;
    ushort  info[256];
    int c;          /* cylinder */
    int h;          /* head */
    int s;          /* sector */
    vlong   sectors;        /* total */
    int secsize;        /* sector size */

    int dma;            /* DMA R/W possible */
    int dmactl;
    int rwm;            /* read/write multiple possible */
    int rwmctl;

    int pkt;            /* PACKET device, length of pktcmd */
    uchar   pktcmd[16];
    int pktdma;         /* this PACKET command using dma */

    uchar   sense[18];
    uchar   inquiry[48];

    QLock;              /* drive access */
    int command;        /* current command */
    int write;
    uchar*  data;
    int dlen;
    uchar*  limit;
    int count;          /* sectors */
    int block;          /* R/W bytes per block */
    int status;
    int error;
    int flags;          /* internal flags */

    /* interrupt counts */
    ulong   intcmd;         /* commands */
    ulong   intrd;          /* reads */
    ulong   intwr;          /* writes */
} Drive;

enum {                  /* internal flags */
    Lba48       = 0x1,      /* LBA48 mode */
    Lba48always = 0x2,      /* ... */
};
enum {
    Last28      = (1<<28) - 1 - 1, /* all-ones mask is not addressible */
};

static void
pc87415ienable(Ctlr* ctlr)
{
    Pcidev *p;
    int x;

    p = ctlr->pcidev;
    if(p == nil)
        return;

    x = pcicfgr32(p, 0x40);
    if(ctlr->cmdport == p->mem[0].bar)
        x &= ~0x00000100;
    else
        x &= ~0x00000200;
    pcicfgw32(p, 0x40, x);
}

static void
atadumpstate(Drive* drive, uchar* cmd, vlong lba, int count)
{
    Prd *prd;
    Pcidev *p;
    Ctlr *ctlr;
    int i, bmiba;

    if(!(DEBUG & DbgSTATE)){
        USED(drive, cmd, lba, count);
        return;
    }

    ctlr = drive->ctlr;
    print("sdata: command %2.2uX\n", ctlr->command);
    print("data %8.8p limit %8.8p dlen %d status %uX error %uX\n",
        drive->data, drive->limit, drive->dlen,
        drive->status, drive->error);
    if(cmd != nil){
        print("lba %d -> %lld, count %d -> %d (%d)\n",
            (cmd[2]<<24)|(cmd[3]<<16)|(cmd[4]<<8)|cmd[5], lba,
            (cmd[7]<<8)|cmd[8], count, drive->count);
    }
    if(!(inb(ctlr->ctlport+As) & Bsy)){
        for(i = 1; i < 7; i++)
            print(" 0x%2.2uX", inb(ctlr->cmdport+i));
        print(" 0x%2.2uX\n", inb(ctlr->ctlport+As));
    }
    if(drive->command == Cwd || drive->command == Crd){
        bmiba = ctlr->bmiba;
        prd = ctlr->prdt;
        print("bmicx %2.2uX bmisx %2.2uX prdt %8.8p\n",
            inb(bmiba+Bmicx), inb(bmiba+Bmisx), prd);
        for(;;){
            print("pa 0x%8.8luX count %8.8uX\n",
                prd->pa, prd->count);
            if(prd->count & PrdEOT)
                break;
            prd++;
        }
    }
    if(ctlr->pcidev && ctlr->pcidev->vid == 0x8086){
        p = ctlr->pcidev;
        print("0x40: %4.4uX 0x42: %4.4uX",
            pcicfgr16(p, 0x40), pcicfgr16(p, 0x42));
        print("0x48: %2.2uX\n", pcicfgr8(p, 0x48));
        print("0x4A: %4.4uX\n", pcicfgr16(p, 0x4A));
    }
}

static int
atadebug(int cmdport, int ctlport, char* fmt, ...)
{
    int i, n;
    va_list arg;
    char buf[PRINTSIZE];

    if(!(DEBUG & DbgPROBE)){
        USED(cmdport, ctlport, fmt);
        return 0;
    }

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    if(cmdport){
        if(buf[n-1] == '\n')
            n--;
        n += snprint(buf+n, PRINTSIZE-n, " ataregs 0x%uX:",
            cmdport);
        for(i = Features; i < Command; i++)
            n += snprint(buf+n, PRINTSIZE-n, " 0x%2.2uX",
                inb(cmdport+i));
        if(ctlport)
            n += snprint(buf+n, PRINTSIZE-n, " 0x%2.2uX",
                inb(ctlport+As));
        n += snprint(buf+n, PRINTSIZE-n, "\n");
    }
    putstrn(buf, n);

    return n;
}

static int
ataready(int cmdport, int ctlport, int dev, int reset, int ready, int micro)
{
    int as;

    atadebug(cmdport, ctlport, "ataready: dev %uX reset %uX ready %uX",
        dev, reset, ready);

    for(;;){
        /*
         * Wait for the controller to become not busy and
         * possibly for a status bit to become true (usually
         * Drdy). Must change to the appropriate device
         * register set if necessary before testing for ready.
         * Always run through the loop at least once so it
         * can be used as a test for !Bsy.
         */
        as = inb(ctlport+As);
        if(as & reset){
            /* nothing to do */
        }
        else if(dev){
            outb(cmdport+Dh, dev);
            dev = 0;
        }
        else if(ready == 0 || (as & ready)){
            atadebug(0, 0, "ataready: %d 0x%2.2uX\n", micro, as);
            return as;
        }

        if(micro-- <= 0){
            atadebug(0, 0, "ataready: %d 0x%2.2uX\n", micro, as);
            break;
        }
        microdelay(1);
    }
    atadebug(cmdport, ctlport, "ataready: timeout");

    return -1;
}

/*
static int
atacsf(Drive* drive, vlong csf, int supported)
{
    ushort *info;
    int cmdset, i, x;

    if(supported)
        info = &drive->info[Icsfs];
    else
        info = &drive->info[Icsfe];

    for(i = 0; i < 3; i++){
        x = (csf>>(16*i)) & 0xFFFF;
        if(x == 0)
            continue;
        cmdset = info[i];
        if(cmdset == 0 || cmdset == 0xFFFF)
            return 0;
        return cmdset & x;
    }

    return 0;
}
*/

static int
atadone(void* arg)
{
    return ((Ctlr*)arg)->done;
}

static int
atarwmmode(Drive* drive, int cmdport, int ctlport, int dev)
{
    int as, maxrwm, rwm;

    maxrwm = (drive->info[Imaxrwm] & 0xFF);
    if(maxrwm == 0)
        return 0;

    /*
     * Sometimes drives come up with the current count set
     * to 0; if so, set a suitable value, otherwise believe
     * the value in Irwm if the 0x100 bit is set.
     */
    if(drive->info[Irwm] & 0x100)
        rwm = (drive->info[Irwm] & 0xFF);
    else
        rwm = 0;
    if(rwm == 0)
        rwm = maxrwm;
    if(rwm > 16)
        rwm = 16;
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, Drdy, 102*1000) < 0)
        return 0;
    outb(cmdport+Count, rwm);
    outb(cmdport+Command, Csm);
    microdelay(1);
    as = ataready(cmdport, ctlport, 0, Bsy, Drdy|Df|Err, 1000);
    inb(cmdport+Status);
    if(as < 0 || (as & (Df|Err)))
        return 0;

    drive->rwm = rwm;

    return rwm;
}

static int
atadmamode(Drive* drive)
{
    int dma;

    /*
     * Check if any DMA mode enabled.
     * Assumes the BIOS has picked and enabled the best.
     * This is completely passive at the moment, no attempt is
     * made to ensure the hardware is correctly set up.
     */
    dma = drive->info[Imwdma] & 0x0707;
    drive->dma = (dma>>8) & dma;
    if(drive->dma == 0 && (drive->info[Ivalid] & 0x04)){
        dma = drive->info[Iudma] & 0x7F7F;
        drive->dma = (dma>>8) & dma;
        if(drive->dma)
            drive->dma |= 'U'<<16;
    }

    return dma;
}

static int
ataidentify(int cmdport, int ctlport, int dev, int pkt, void* info)
{
    int as, command, drdy;

    if(pkt){
        command = Cidpkt;
        drdy = 0;
    }
    else{
        command = Cid;
        drdy = Drdy;
    }
    as = ataready(cmdport, ctlport, dev, Bsy|Drq, drdy, 103*1000);
    if(as < 0)
        return as;
    outb(cmdport+Command, command);
    microdelay(1);

    as = ataready(cmdport, ctlport, 0, Bsy, Drq|Err, 400*1000);
    if(as < 0)
        return -1;
    if(as & Err)
        return as;

    memset(info, 0, 512);
    inss(cmdport+Data, info, 256);
    inb(cmdport+Status);

    if(DEBUG & DbgIDENTIFY){
        int i;
        ushort *sp;

        sp = (ushort*)info;
        for(i = 0; i < 256; i++){
            if(i && (i%16) == 0)
                print("\n");
            print(" %4.4uX", *sp);
            sp++;
        }
        print("\n");
    }

    return 0;
}

static Drive*
atadrive(int cmdport, int ctlport, int dev)
{
    Drive *drive;
    int as, i, pkt;
    uchar buf[512], *p;
    ushort iconfig, *sp;

    atadebug(0, 0, "identify: port 0x%uX dev 0x%2.2uX\n", cmdport, dev);
    pkt = 1;
retry:
    as = ataidentify(cmdport, ctlport, dev, pkt, buf);
    if(as < 0)
        return nil;
    if(as & Err){
        if(pkt == 0)
            return nil;
        pkt = 0;
        goto retry;
    }

    if((drive = malloc(sizeof(Drive))) == nil)
        return nil;
    drive->dev = dev;
    memmove(drive->info, buf, sizeof(drive->info));
    drive->sense[0] = 0x70;
    drive->sense[7] = sizeof(drive->sense)-7;

    drive->inquiry[2] = 2;
    drive->inquiry[3] = 2;
    drive->inquiry[4] = sizeof(drive->inquiry)-4;
    p = &drive->inquiry[8];
    sp = &drive->info[Imodel];
    for(i = 0; i < 20; i++){
        *p++ = *sp>>8;
        *p++ = *sp++;
    }

    drive->secsize = 512;

    /*
     * Beware the CompactFlash Association feature set.
     * Now, why this value in Iconfig just walks all over the bit
     * definitions used in the other parts of the ATA/ATAPI standards
     * is a mystery and a sign of true stupidity on someone's part.
     * Anyway, the standard says if this value is 0x848A then it's
     * CompactFlash and it's NOT a packet device.
     */
    iconfig = drive->info[Iconfig];
    if(iconfig != 0x848A && (iconfig & 0xC000) == 0x8000){
        if(iconfig & 0x01)
            drive->pkt = 16;
        else
            drive->pkt = 12;
    }
    else{
        if(drive->info[Ivalid] & 0x0001){
            drive->c = drive->info[Iccyl];
            drive->h = drive->info[Ichead];
            drive->s = drive->info[Icsec];
        }
        else{
            drive->c = drive->info[Ilcyl];
            drive->h = drive->info[Ilhead];
            drive->s = drive->info[Ilsec];
        }
        if(drive->info[Icapabilities] & Mlba){
            if(drive->info[Icsfs+1] & Maddr48){
                drive->sectors = drive->info[Ilba48]
                    | (drive->info[Ilba48+1]<<16)
                    | ((vlong)drive->info[Ilba48+2]<<32);
                drive->flags |= Lba48;
            }
            else{
                drive->sectors = (drive->info[Ilba+1]<<16)
                     |drive->info[Ilba];
            }
            drive->dev |= Lba;
        }
        else
            drive->sectors = drive->c*drive->h*drive->s;
        atarwmmode(drive, cmdport, ctlport, dev);
    }
    atadmamode(drive);  

    if(DEBUG & DbgCONFIG){
        print("dev %2.2uX port %uX config %4.4uX capabilities %4.4uX",
            dev, cmdport, iconfig, drive->info[Icapabilities]);
        print(" mwdma %4.4uX", drive->info[Imwdma]);
        if(drive->info[Ivalid] & 0x04)
            print(" udma %4.4uX", drive->info[Iudma]);
        print(" dma %8.8uX rwm %ud", drive->dma, drive->rwm);
        if(drive->flags&Lba48)
            print("\tLLBA sectors %lld", drive->sectors);
        print("\n");
    }

    return drive;
}

static void
atasrst(int ctlport)
{
    /*
     * Srst is a big stick and may cause problems if further
     * commands are tried before the drives become ready again.
     * Also, there will be problems here if overlapped commands
     * are ever supported.
     */
    microdelay(5);
    outb(ctlport+Dc, Srst);
    microdelay(5);
    outb(ctlport+Dc, 0);
    microdelay(2*1000);
}

static SDev*
ataprobe(int cmdport, int ctlport, int irq)
{
    Ctlr* ctlr;
    SDev *sdev;
    Drive *drive;
    int dev, error, rhi, rlo;
    static int nonlegacy = 'C';
    
    if(cmdport == 0) {
        print("ataprobe: cmdport is 0\n");
        return nil;
    }
    if(ioalloc(cmdport, 8, 0, "atacmd") < 0) {
        print("ataprobe: Cannot allocate %X\n", cmdport);
        return nil;
    }
    if(ioalloc(ctlport+As, 1, 0, "atactl") < 0){
        print("ataprobe: Cannot allocate %X\n", ctlport + As);
        iofree(cmdport);
        return nil;
    }

    /*
     * Try to detect a floating bus.
     * Bsy should be cleared. If not, see if the cylinder registers
     * are read/write capable.
     * If the master fails, try the slave to catch slave-only
     * configurations.
     * There's no need to restore the tested registers as they will
     * be reset on any detected drives by the Cedd command.
     * All this indicates is that there is at least one drive on the
     * controller; when the non-existent drive is selected in a
     * single-drive configuration the registers of the existing drive
     * are often seen, only command execution fails.
     */
    dev = Dev0;
    if(inb(ctlport+As) & Bsy){
        outb(cmdport+Dh, dev);
        microdelay(1);
trydev1:
        atadebug(cmdport, ctlport, "ataprobe bsy");
        outb(cmdport+Cyllo, 0xAA);
        outb(cmdport+Cylhi, 0x55);
        outb(cmdport+Sector, 0xFF);
        rlo = inb(cmdport+Cyllo);
        rhi = inb(cmdport+Cylhi);
        if(rlo != 0xAA && (rlo == 0xFF || rhi != 0x55)){
            if(dev == Dev1){
release:
                iofree(cmdport);
                iofree(ctlport+As);
                return nil;
            }
            dev = Dev1;
            if(ataready(cmdport, ctlport, dev, Bsy, 0, 20*1000) < 0)
                goto trydev1;
        }
    }

    /*
     * Disable interrupts on any detected controllers.
     */
    outb(ctlport+Dc, Nien);
tryedd1:
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 105*1000) < 0){
        /*
         * There's something there, but it didn't come up clean,
         * so try hitting it with a big stick. The timing here is
         * wrong but this is a last-ditch effort and it sometimes
         * gets some marginal hardware back online.
         */
        atasrst(ctlport);
        if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 106*1000) < 0)
            goto release;
    }

    /*
     * Can only get here if controller is not busy.
     * If there are drives Bsy will be set within 400nS,
     * must wait 2mS before testing Status.
     * Wait for the command to complete (6 seconds max).
     */
    outb(cmdport+Command, Cedd);
    delay(2);
    if(ataready(cmdport, ctlport, dev, Bsy|Drq, 0, 6*1000*1000) < 0)
        goto release;

    /*
     * If bit 0 of the error register is set then the selected drive
     * exists. This is enough to detect single-drive configurations.
     * However, if the master exists there is no way short of executing
     * a command to determine if a slave is present.
     * It appears possible to get here testing Dev0 although it doesn't
     * exist and the EDD won't take, so try again with Dev1.
     */
    error = inb(cmdport+Error);
    atadebug(cmdport, ctlport, "ataprobe: dev %uX", dev);
    if((error & ~0x80) != 0x01){
        if(dev == Dev1)
            goto release;
        dev = Dev1;
        goto tryedd1;
    }

    /*
     * At least one drive is known to exist, try to
     * identify it. If that fails, don't bother checking
     * any further.
     * If the one drive found is Dev0 and the EDD command
     * didn't indicate Dev1 doesn't exist, check for it.
     */
    if((drive = atadrive(cmdport, ctlport, dev)) == nil)
        goto release;
    if((ctlr = malloc(sizeof(Ctlr))) == nil){
        free(drive);
        goto release;
    }
    memset(ctlr, 0, sizeof(Ctlr));
    if((sdev = malloc(sizeof(SDev))) == nil){
        free(ctlr);
        free(drive);
        goto release;
    }
    memset(sdev, 0, sizeof(SDev));
    drive->ctlr = ctlr;
    if(dev == Dev0){
        ctlr->drive[0] = drive;
        if(!(error & 0x80)){
            /*
             * Always leave Dh pointing to a valid drive,
             * otherwise a subsequent call to ataready on
             * this controller may try to test a bogus Status.
             * Ataprobe is the only place possibly invalid
             * drives should be selected.
             */
            drive = atadrive(cmdport, ctlport, Dev1);
            if(drive != nil){
                drive->ctlr = ctlr;
                ctlr->drive[1] = drive;
            }
            else{
                outb(cmdport+Dh, Dev0);
                microdelay(1);
            }
        }
    }
    else
        ctlr->drive[1] = drive;

    ctlr->cmdport = cmdport;
    ctlr->ctlport = ctlport;
    ctlr->irq = irq;
    ctlr->tbdf = BUSUNKNOWN;
    ctlr->command = Cedd;       /* debugging */
    
    switch(cmdport){
    default:
        sdev->idno = nonlegacy;
        break;
    case 0x1F0:
        sdev->idno = 'C';
        nonlegacy = 'E';
        break;
    case 0x170:
        sdev->idno = 'D';
        nonlegacy = 'E';
        break;
    }
    sdev->ifc = &sdataifc;
    sdev->ctlr = ctlr;
    sdev->nunit = 2;
    ctlr->sdev = sdev;

    return sdev;
}

static void
ataclear(SDev *sdev)
{
    Ctlr* ctlr;

    ctlr = sdev->ctlr;
    iofree(ctlr->cmdport);
    iofree(ctlr->ctlport + As);

    if (ctlr->drive[0])
        free(ctlr->drive[0]);
    if (ctlr->drive[1])
        free(ctlr->drive[1]);
    if (sdev->name)
        free(sdev->name);
    if (sdev->unitflg)
        free(sdev->unitflg);
    if (sdev->unit)
        free(sdev->unit);
    free(ctlr);
    free(sdev);
}

static char *
atastat(SDev *sdev, char *p, char *e)
{
    Ctlr *ctlr = sdev->ctlr;

    return seprint(p, e, "%s ata port %X ctl %X irq %d "
        "intr-ok %lud intr-busy %lud intr-nil-drive %lud\n",
        sdev->name, ctlr->cmdport, ctlr->ctlport, ctlr->irq,
        ctlr->intok, ctlr->intbusy, ctlr->intnil);
}

static SDev*
ataprobew(DevConf *cf)
{
    char *p;
    ISAConf isa;
    
    if (cf->nports != 2)
        error(Ebadarg);

    memset(&isa, 0, sizeof isa);
    isa.port = cf->ports[0].port;
    isa.irq = cf->intnum;
    if((p=strchr(cf->type, '/')) == nil || pcmspecial(p+1, &isa) < 0)
        error("cannot find controller");

    return ataprobe(cf->ports[0].port, cf->ports[1].port, cf->intnum);
}

/*
 * These are duplicated with sdsetsense, etc., in devsd.c, but
 * those assume that the disk is not SCSI while in fact here
 * ata drives are not SCSI but ATAPI ones kind of are.
 */
static int
atasetsense(Drive* drive, int status, int key, int asc, int ascq)
{
    drive->sense[2] = key;
    drive->sense[12] = asc;
    drive->sense[13] = ascq;

    return status;
}

static int
atamodesense(Drive* drive, uchar* cmd)
{
    int len;

    /*
     * Fake a vendor-specific request with page code 0,
     * return the drive info.
     */
    if((cmd[2] & 0x3F) != 0 && (cmd[2] & 0x3F) != 0x3F)
        return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
    len = (cmd[7]<<8)|cmd[8];
    if(len == 0)
        return SDok;
    if(len < 8+sizeof(drive->info))
        return atasetsense(drive, SDcheck, 0x05, 0x1A, 0);
    if(drive->data == nil || drive->dlen < len)
        return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
    memset(drive->data, 0, 8);
    drive->data[0] = sizeof(drive->info)>>8;
    drive->data[1] = sizeof(drive->info);
    memmove(drive->data+8, drive->info, sizeof(drive->info));
    drive->data += 8+sizeof(drive->info);

    return SDok;
}

static int
atastandby(Drive* drive, int period)
{
    Ctlr* ctlr;
    int cmdport, done;

    ctlr = drive->ctlr;
    drive->command = Cstandby;
    qlock(ctlr);

    cmdport = ctlr->cmdport;
    ilock(ctlr);
    outb(cmdport+Count, period);
    outb(cmdport+Dh, drive->dev);
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = Cstandby;   /* debugging */
    outb(cmdport+Command, Cstandby);
    iunlock(ctlr);

    while(waserror())
        ;
    tsleep(ctlr, atadone, ctlr, 60*1000);
    poperror();

    done = ctlr->done;
    qunlock(ctlr);

    if(!done || (drive->status & Err))
        return atasetsense(drive, SDcheck, 4, 8, drive->error);
    return SDok;
}

static void
atanop(Drive* drive, int subcommand)
{
    Ctlr* ctlr;
    int as, cmdport, ctlport, timeo;

    /*
     * Attempt to abort a command by using NOP.
     * In response, the drive is supposed to set Abrt
     * in the Error register, set (Drdy|Err) in Status
     * and clear Bsy when done. However, some drives
     * (e.g. ATAPI Zip) just go Bsy then clear Status
     * when done, hence the timeout loop only on Bsy
     * and the forced setting of drive->error.
     */
    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    outb(cmdport+Features, subcommand);
    outb(cmdport+Dh, drive->dev);
    ctlr->command = Cnop;       /* debugging */
    outb(cmdport+Command, Cnop);

    microdelay(1);
    ctlport = ctlr->ctlport;
    for(timeo = 0; timeo < 1000; timeo++){
        as = inb(ctlport+As);
        if(!(as & Bsy))
            break;
        microdelay(1);
    }
    drive->error |= Abrt;
}

static void
ataabort(Drive* drive, int dolock)
{
    /*
     * If NOP is available (packet commands) use it otherwise
     * must try a software reset.
     */
    if(dolock)
        ilock(drive->ctlr);
    if(drive->info[Icsfs] & Mnop)
        atanop(drive, 0);
    else{
        atasrst(drive->ctlr->ctlport);
        drive->error |= Abrt;
    }
    if(dolock)
        iunlock(drive->ctlr);
}

static int
atadmasetup(Drive* drive, int len)
{
    Prd *prd;
    ulong pa;
    Ctlr *ctlr;
    int bmiba, bmisx, count, i, span;

    ctlr = drive->ctlr;
    pa = PCIWADDR(drive->data);
    if(pa & 0x03)
        return -1;

    /*
     * Sometimes drives identify themselves as being DMA capable
     * although they are not on a busmastering controller.
     */
    prd = ctlr->prdt;
    if(prd == nil){
        drive->dmactl = 0;
        print("disabling dma: not on a busmastering controller\n");
        return -1;
    }

    for(i = 0; len && i < Nprd; i++){
        prd->pa = pa;
        span = ROUNDUP(pa, ctlr->span);
        if(span == pa)
            span += ctlr->span;
        count = span - pa;
        if(count >= len){
            prd->count = PrdEOT|len;
            break;
        }
        prd->count = count;
        len -= count;
        pa += count;
        prd++;
    }
    if(i == Nprd)
        (prd-1)->count |= PrdEOT;

    bmiba = ctlr->bmiba;
    outl(bmiba+Bmidtpx, PCIWADDR(ctlr->prdt));
    if(drive->write)
        outb(ctlr->bmiba+Bmicx, 0);
    else
        outb(ctlr->bmiba+Bmicx, Rwcon);
    bmisx = inb(bmiba+Bmisx);
    outb(bmiba+Bmisx, bmisx|Ideints|Idedmae);

    return 0;
}

static void
atadmastart(Ctlr* ctlr, int write)
{
    if(write)
        outb(ctlr->bmiba+Bmicx, Ssbm);
    else
        outb(ctlr->bmiba+Bmicx, Rwcon|Ssbm);
}

static int
atadmastop(Ctlr* ctlr)
{
    int bmiba;

    bmiba = ctlr->bmiba;
    outb(bmiba+Bmicx, inb(bmiba+Bmicx) & ~Ssbm);

    return inb(bmiba+Bmisx);
}

static void
atadmainterrupt(Drive* drive, int count)
{
    Ctlr* ctlr;
    int bmiba, bmisx;

    ctlr = drive->ctlr;
    bmiba = ctlr->bmiba;
    bmisx = inb(bmiba+Bmisx);
    switch(bmisx & (Ideints|Idedmae|Bmidea)){
    case Bmidea:
        /*
         * Data transfer still in progress, nothing to do
         * (this should never happen).
         */
        return;

    case Ideints:
    case Ideints|Bmidea:
        /*
         * Normal termination, tidy up.
         */
        drive->data += count;
        break;

    default:
        /*
         * What's left are error conditions (memory transfer
         * problem) and the device is not done but the PRD is
         * exhausted. For both cases must somehow tell the
         * drive to abort.
         */
        ataabort(drive, 0);
        break;
    }
    atadmastop(ctlr);
    ctlr->done = 1;
}

static void
atapktinterrupt(Drive* drive)
{
    Ctlr* ctlr;
    int cmdport, len, sts;

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    sts = inb(cmdport+Ir) & (/*Rel|*/ Io|Cd);
    /* a default case is impossible since all cases are enumerated */
    switch(sts){
    case Cd:            /* write cmd */
        outss(cmdport+Data, drive->pktcmd, drive->pkt/2);
        break;

    case 0:             /* write data */
        len = (inb(cmdport+Bytehi)<<8)|inb(cmdport+Bytelo);
        if(drive->data+len > drive->limit){
            atanop(drive, 0);
            break;
        }
        outss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        break;

    case Io:            /* read data */
        len = (inb(cmdport+Bytehi)<<8)|inb(cmdport+Bytelo);
        if(drive->data+len > drive->limit){
            atanop(drive, 0);
            break;
        }
        inss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        break;

    case Io|Cd:         /* read cmd */
        if(drive->pktdma)
            atadmainterrupt(drive, drive->dlen);
        else
            ctlr->done = 1;
        break;
    }
    if(sts & Cd)
        drive->intcmd++;
    if(sts & Io)
        drive->intrd++;
    else
        drive->intwr++;
}

static int
atapktio(Drive* drive, uchar* cmd, int clen)
{
    Ctlr *ctlr;
    int as, cmdport, ctlport, len, r, timeo;

    if(cmd[0] == 0x5A && (cmd[2] & 0x3F) == 0)
        return atamodesense(drive, cmd);

    r = SDok;

    drive->command = Cpkt;
    memmove(drive->pktcmd, cmd, clen);
    memset(drive->pktcmd+clen, 0, drive->pkt-clen);
    drive->limit = drive->data+drive->dlen;

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    ctlport = ctlr->ctlport;

    qlock(ctlr);

    as = ataready(cmdport, ctlport, drive->dev, Bsy|Drq, Drdy, 107*1000);
    /* used to test as&Chk as failure too, but some CD readers use that for media change */
    if(as < 0){
        qunlock(ctlr);
        return -1;
    }

    ilock(ctlr);
    if(drive->dlen && drive->dmactl && !atadmasetup(drive, drive->dlen))
        drive->pktdma = Dma;
    else
        drive->pktdma = 0;

    outb(cmdport+Features, drive->pktdma);
    outb(cmdport+Count, 0);
    outb(cmdport+Sector, 0);
    len = 16*drive->secsize;
    outb(cmdport+Bytelo, len);
    outb(cmdport+Bytehi, len>>8);
    outb(cmdport+Dh, drive->dev);
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = Cpkt;       /* debugging */
    if(drive->pktdma)
        atadmastart(ctlr, drive->write);
    outb(cmdport+Command, Cpkt);

    if((drive->info[Iconfig] & Mdrq) != 0x0020){
        microdelay(1);
        as = ataready(cmdport, ctlport, 0, Bsy, Drq|Chk, 4*1000);
        if(as < 0 || (as & (Bsy|Chk))){
            drive->status = as<0 ? 0 : as;
            ctlr->curdrive = nil;
            ctlr->done = 1;
            r = SDtimeout;
        }else
            atapktinterrupt(drive);
    }
    iunlock(ctlr);

    while(waserror())
        ;
    if(!drive->pktdma)
        sleep(ctlr, atadone, ctlr);
    else for(timeo = 0; !ctlr->done; timeo++){
        tsleep(ctlr, atadone, ctlr, 1000);
        if(ctlr->done)
            break;
        ilock(ctlr);
        atadmainterrupt(drive, 0);
        if(!drive->error && timeo > 20){
            ataabort(drive, 0);
            atadmastop(ctlr);
            drive->dmactl = 0;
            drive->error |= Abrt;
        }
        if(drive->error){
            drive->status |= Chk;
            ctlr->curdrive = nil;
        }
        iunlock(ctlr);
    }
    poperror();

    qunlock(ctlr);

    if(drive->status & Chk)
        r = SDcheck;

    return r;
}

static uchar cmd48[256] = {
    [Crs]   Crs48,
    [Crd]   Crd48,
    [Crdq]  Crdq48,
    [Crsm]  Crsm48,
    [Cws]   Cws48,
    [Cwd]   Cwd48,
    [Cwdq]  Cwdq48,
    [Cwsm]  Cwsm48,
};

static int
atageniostart(Drive* drive, uvlong lba)
{
    Ctlr *ctlr;
    uchar cmd;
    int as, c, cmdport, ctlport, h, len, s, use48;

    use48 = 0;
    if((drive->flags&Lba48always) || lba > Last28 || drive->count > 256){
        if(!(drive->flags & Lba48))
            return -1;
        use48 = 1;
        c = h = s = 0;
    }
    else if(drive->dev & Lba){
        c = (lba>>8) & 0xFFFF;
        h = (lba>>24) & 0x0F;
        s = lba & 0xFF;
    }
    else{
        c = lba/(drive->s*drive->h);
        h = ((lba/drive->s) % drive->h);
        s = (lba % drive->s) + 1;
    }

    ctlr = drive->ctlr;
    cmdport = ctlr->cmdport;
    ctlport = ctlr->ctlport;
    if(ataready(cmdport, ctlport, drive->dev, Bsy|Drq, Drdy, 101*1000) < 0)
        return -1;

    ilock(ctlr);
    if(drive->dmactl && !atadmasetup(drive, drive->count*drive->secsize)){
        if(drive->write)
            drive->command = Cwd;
        else
            drive->command = Crd;
    }
    else if(drive->rwmctl){
        drive->block = drive->rwm*drive->secsize;
        if(drive->write)
            drive->command = Cwsm;
        else
            drive->command = Crsm;
    }
    else{
        drive->block = drive->secsize;
        if(drive->write)
            drive->command = Cws;
        else
            drive->command = Crs;
    }
    drive->limit = drive->data + drive->count*drive->secsize;
    cmd = drive->command;
    if(use48){
        outb(cmdport+Count, drive->count>>8);
        outb(cmdport+Count, drive->count);
        outb(cmdport+Lbalo, lba>>24);
        outb(cmdport+Lbalo, lba);
        outb(cmdport+Lbamid, lba>>32);
        outb(cmdport+Lbamid, lba>>8);
        outb(cmdport+Lbahi, lba>>40);
        outb(cmdport+Lbahi, lba>>16);
        outb(cmdport+Dh, drive->dev|Lba);
        cmd = cmd48[cmd];

        if(DEBUG & Dbg48BIT)
            print("using 48-bit commands\n");
    }
    else{
        outb(cmdport+Count, drive->count);
        outb(cmdport+Sector, s);
        outb(cmdport+Cyllo, c);
        outb(cmdport+Cylhi, c>>8);
        outb(cmdport+Dh, drive->dev|h);
    }
    ctlr->done = 0;
    ctlr->curdrive = drive;
    ctlr->command = drive->command; /* debugging */
    outb(cmdport+Command, cmd);

    switch(drive->command){
    case Cws:
    case Cwsm:
        microdelay(1);
        /* 10*1000 for flash ide drives - maybe detect them? */
        as = ataready(cmdport, ctlport, 0, Bsy, Drq|Err, 10*1000);
        if(as < 0 || (as & Err)){
            iunlock(ctlr);
            return -1;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        outss(cmdport+Data, drive->data, len/2);
        break;

    case Crd:
    case Cwd:
        atadmastart(ctlr, drive->write);
        break;
    }
    iunlock(ctlr);

    return 0;
}

static int
atagenioretry(Drive* drive)
{
    if(drive->dmactl){
        drive->dmactl = 0;
        print("atagenioretry: disabling dma\n");
    }
    else if(drive->rwmctl)
        drive->rwmctl = 0;
    else
        return atasetsense(drive, SDcheck, 4, 8, drive->error);

    return SDretry;
}

static int
atagenio(Drive* drive, uchar* cmd, int clen)
{
    uchar *p;
    Ctlr *ctlr;
    vlong lba, len;
    int count, maxio;

    /*
     * Map SCSI commands into ATA commands for discs.
     * Fail any command with a LUN except INQUIRY which
     * will return 'logical unit not supported'.
     */
    if((cmd[1]>>5) && cmd[0] != 0x12)
        return atasetsense(drive, SDcheck, 0x05, 0x25, 0);

    switch(cmd[0]){
    default:
        return atasetsense(drive, SDcheck, 0x05, 0x20, 0);

    case 0x00:          /* test unit ready */
        return SDok;

    case 0x03:          /* request sense */
        if(cmd[4] < sizeof(drive->sense))
            len = cmd[4];
        else
            len = sizeof(drive->sense);
        if(drive->data && drive->dlen >= len){
            memmove(drive->data, drive->sense, len);
            drive->data += len;
        }
        return SDok;

    case 0x12:          /* inquiry */
        if(cmd[4] < sizeof(drive->inquiry))
            len = cmd[4];
        else
            len = sizeof(drive->inquiry);
        if(drive->data && drive->dlen >= len){
            memmove(drive->data, drive->inquiry, len);
            drive->data += len;
        }
        return SDok;

    case 0x1B:          /* start/stop unit */
        /*
         * NOP for now, can use the power management feature
         * set later.
         */
        return SDok;

    case 0x25:          /* read capacity */
        if((cmd[1] & 0x01) || cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
        if(drive->data == nil || drive->dlen < 8)
            return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
        /*
         * Read capacity returns the LBA of the last sector.
         */
        len = drive->sectors-1;
        p = drive->data;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p++ = len;
        len = drive->secsize;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p = len;
        drive->data += 8;
        return SDok;

    case 0x9E:          /* long read capacity */
        if((cmd[1] & 0x01) || cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 0x05, 0x24, 0);
        if(drive->data == nil || drive->dlen < 8)
            return atasetsense(drive, SDcheck, 0x05, 0x20, 1);
        /*
         * Read capacity returns the LBA of the last sector.
         */
        len = drive->sectors-1;
        p = drive->data;
        *p++ = len>>56;
        *p++ = len>>48;
        *p++ = len>>40;
        *p++ = len>>32;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p++ = len;
        len = drive->secsize;
        *p++ = len>>24;
        *p++ = len>>16;
        *p++ = len>>8;
        *p = len;
        drive->data += 12;
        return SDok;

    case 0x28:          /* read (10) */
    case 0x88:          /* long read (16) */
    case 0x2a:          /* write (10) */
    case 0x8a:          /* long write (16) */
    case 0x2e:          /* write and verify (10) */
        break;

    case 0x5A:
        return atamodesense(drive, cmd);
    }

    ctlr = drive->ctlr;
    if(clen == 16){
        /* ata commands only go to 48-bit lba */
        if(cmd[2] || cmd[3])
            return atasetsense(drive, SDcheck, 3, 0xc, 2);
        lba = (uvlong)cmd[4]<<40 | (uvlong)cmd[5]<<32;
        lba |= cmd[6]<<24 | cmd[7]<<16 | cmd[8]<<8 | cmd[9];
        count = cmd[10]<<24 | cmd[11]<<16 | cmd[12]<<8 | cmd[13];
    }else{
        lba = cmd[2]<<24 | cmd[3]<<16 | cmd[4]<<8 | cmd[5];
        count = cmd[7]<<8 | cmd[8];
    }
    if(drive->data == nil)
        return SDok;
    if(drive->dlen < count*drive->secsize)
        count = drive->dlen/drive->secsize;
    qlock(ctlr);
    if(ctlr->maxio)
        maxio = ctlr->maxio;
    else if(drive->flags & Lba48)
        maxio = 65536;
    else
        maxio = 256;
    while(count){
        if(count > maxio)
            drive->count = maxio;
        else
            drive->count = count;
        if(atageniostart(drive, lba)){
            ilock(ctlr);
            atanop(drive, 0);
            iunlock(ctlr);
            qunlock(ctlr);
            return atagenioretry(drive);
        }

        while(waserror())
            ;
        tsleep(ctlr, atadone, ctlr, 60*1000);
        poperror();
        if(!ctlr->done){
            /*
             * What should the above timeout be? In
             * standby and sleep modes it could take as
             * long as 30 seconds for a drive to respond.
             * Very hard to get out of this cleanly.
             */
            atadumpstate(drive, cmd, lba, count);
            ataabort(drive, 1);
            qunlock(ctlr);
            return atagenioretry(drive);
        }

        if(drive->status & Err){
            qunlock(ctlr);
            return atasetsense(drive, SDcheck, 4, 8, drive->error);
        }
        count -= drive->count;
        lba += drive->count;
    }
    qunlock(ctlr);

    return SDok;
}

static int
atario(SDreq* r)
{
    Ctlr *ctlr;
    Drive *drive;
    SDunit *unit;
    uchar cmd10[10], *cmdp, *p;
    int clen, reqstatus, status;

    unit = r->unit;
    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil){
        r->status = SDtimeout;
        return SDtimeout;
    }
    drive = ctlr->drive[unit->subno];

    /*
     * Most SCSI commands can be passed unchanged except for
     * the padding on the end. The few which require munging
     * are not used internally. Mode select/sense(6) could be
     * converted to the 10-byte form but it's not worth the
     * effort. Read/write(6) are easy.
     */
    switch(r->cmd[0]){
    case 0x08:          /* read */
    case 0x0A:          /* write */
        cmdp = cmd10;
        memset(cmdp, 0, sizeof(cmd10));
        cmdp[0] = r->cmd[0]|0x20;
        cmdp[1] = r->cmd[1] & 0xE0;
        cmdp[5] = r->cmd[3];
        cmdp[4] = r->cmd[2];
        cmdp[3] = r->cmd[1] & 0x0F;
        cmdp[8] = r->cmd[4];
        clen = sizeof(cmd10);
        break;

    default:
        cmdp = r->cmd;
        clen = r->clen;
        break;
    }

    qlock(drive);
retry:
    drive->write = r->write;
    drive->data = r->data;
    drive->dlen = r->dlen;

    drive->status = 0;
    drive->error = 0;
    if(drive->pkt)
        status = atapktio(drive, cmdp, clen);
    else
        status = atagenio(drive, cmdp, clen);
    if(status == SDretry){
        if(DbgDEBUG)
            print("%s: retry: dma %8.8uX rwm %4.4uX\n",
                unit->name, drive->dmactl, drive->rwmctl);
        goto retry;
    }
    if(status == SDok){
        atasetsense(drive, SDok, 0, 0, 0);
        if(drive->data){
            p = r->data;
            r->rlen = drive->data - p;
        }
        else
            r->rlen = 0;
    }
    else if(status == SDcheck && !(r->flags & SDnosense)){
        drive->write = 0;
        memset(cmd10, 0, sizeof(cmd10));
        cmd10[0] = 0x03;
        cmd10[1] = r->lun<<5;
        cmd10[4] = sizeof(r->sense)-1;
        drive->data = r->sense;
        drive->dlen = sizeof(r->sense)-1;
        drive->status = 0;
        drive->error = 0;
        if(drive->pkt)
            reqstatus = atapktio(drive, cmd10, 6);
        else
            reqstatus = atagenio(drive, cmd10, 6);
        if(reqstatus == SDok){
            r->flags |= SDvalidsense;
            atasetsense(drive, SDok, 0, 0, 0);
        }
    }
    qunlock(drive);
    r->status = status;
    if(status != SDok)
        return status;

    /*
     * Fix up any results.
     * Many ATAPI CD-ROMs ignore the LUN field completely and
     * return valid INQUIRY data. Patch the response to indicate
     * 'logical unit not supported' if the LUN is non-zero.
     */
    switch(cmdp[0]){
    case 0x12:          /* inquiry */
        if((p = r->data) == nil)
            break;
        if((cmdp[1]>>5) && (!drive->pkt || (p[0] & 0x1F) == 0x05))
            p[0] = 0x7F;
        /*FALLTHROUGH*/
    default:
        break;
    }

    return SDok;
}

/* interrupt ack hack for intel ich controllers */
static void
ichirqack(Ctlr *ctlr)
{
    int bmiba;

    bmiba = ctlr->bmiba;
    if(bmiba)
        outb(bmiba+Bmisx, inb(bmiba+Bmisx));
}

static void
atainterrupt(Ureg*, void* arg)
{
    Ctlr *ctlr;
    Drive *drive;
    int cmdport, len, status;

    ctlr = arg;

    ilock(ctlr);
    if(inb(ctlr->ctlport+As) & Bsy){
        ctlr->intbusy++;
        iunlock(ctlr);
        if(DEBUG & DbgBsy)
            print("IBsy+");
        return;
    }
    cmdport = ctlr->cmdport;
    status = inb(cmdport+Status);
    if((drive = ctlr->curdrive) == nil){
        ctlr->intnil++;
        if(ctlr->irqack != nil)
            ctlr->irqack(ctlr);
        iunlock(ctlr);
        if((DEBUG & DbgINL) && ctlr->command != Cedd)
            print("Inil%2.2uX+", ctlr->command);
        return;
    }

    ctlr->intok++;

    if(status & Err)
        drive->error = inb(cmdport+Error);
    else switch(drive->command){
    default:
        drive->error = Abrt;
        break;

    case Crs:
    case Crsm:
        drive->intrd++;
        if(!(status & Drq)){
            drive->error = Abrt;
            break;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        inss(cmdport+Data, drive->data, len/2);
        drive->data += len;
        if(drive->data >= drive->limit)
            ctlr->done = 1;
        break;

    case Cws:
    case Cwsm:
        drive->intwr++;
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        drive->data += len;
        if(drive->data >= drive->limit){
            ctlr->done = 1;
            break;
        }
        if(!(status & Drq)){
            drive->error = Abrt;
            break;
        }
        len = drive->block;
        if(drive->data+len > drive->limit)
            len = drive->limit-drive->data;
        outss(cmdport+Data, drive->data, len/2);
        break;

    case Cpkt:
        atapktinterrupt(drive);
        break;

    case Crd:
        drive->intrd++;
        /* fall through */
    case Cwd:
        if (drive->command == Cwd)
            drive->intwr++;
        atadmainterrupt(drive, drive->count*drive->secsize);
        break;

    case Cstandby:
        ctlr->done = 1;
        break;
    }
    if(ctlr->irqack != nil)
        ctlr->irqack(ctlr);
    iunlock(ctlr);

    if(drive->error){
        status |= Err;
        ctlr->done = 1;
    }

    if(ctlr->done){
        ctlr->curdrive = nil;
        drive->status = status;
        wakeup(ctlr);
    }
}

static SDev*
atapnp(void)
{
    Ctlr *ctlr;
    Pcidev *p;
    SDev *legacy[2], *sdev, *head, *tail;
    int channel, ispc87415, maxio, pi, r, span;
    void (*irqack)(Ctlr*);

    irqack = nil;
    legacy[0] = legacy[1] = head = tail = nil;
    if(sdev = ataprobe(0x1F0, 0x3F4, IrqATA0)){
        head = tail = sdev;
        legacy[0] = sdev;
    }
    if(sdev = ataprobe(0x170, 0x374, IrqATA1)){
        if(head != nil)
            tail->next = sdev;
        else
            head = sdev;
        tail = sdev;
        legacy[1] = sdev;
    }

    p = nil;
    while(p = pcimatch(p, 0, 0)){
        /*
         * Look for devices with the correct class and sub-class
         * code and known device and vendor ID; add native-mode
         * channels to the list to be probed, save info for the
         * compatibility mode channels.
         * Note that the legacy devices should not be considered
         * PCI devices by the interrupt controller.
         * For both native and legacy, save info for busmastering
         * if capable.
         * Promise Ultra ATA/66 (PDC20262) appears to
         * 1) give a sub-class of 'other mass storage controller'
         *    instead of 'IDE controller', regardless of whether it's
         *    the only controller or not;
         * 2) put 0 in the programming interface byte (probably
         *    as a consequence of 1) above).
         * Sub-class code 0x04 is 'RAID controller', e.g. VIA VT8237.
         */
        if(p->ccrb != 0x01)
            continue;
        if(p->ccru != 0x01 && p->ccru != 0x04 && p->ccru != 0x80)
            continue;
        pi = p->ccrp;
        ispc87415 = 0;
        maxio = 0;
        span = BMspan;

        switch((p->did<<16)|p->vid){
        default:
            continue;

        case (0x0002<<16)|0x100B:   /* NS PC87415 */
            /*
             * Disable interrupts on both channels until
             * after they are probed for drives.
             * This must be called before interrupts are
             * enabled because the IRQ may be shared.
             */
            ispc87415 = 1;
            pcicfgw32(p, 0x40, 0x00000300);
            break;
        case (0x1000<<16)|0x1042:   /* PC-Tech RZ1000 */
            /*
             * Turn off prefetch. Overkill, but cheap.
             */
            r = pcicfgr32(p, 0x40);
            r &= ~0x2000;
            pcicfgw32(p, 0x40, r);
            break;
        case (0x4379<<16)|0x1002:   /* ATI SB400 SATA*/
        case (0x437a<<16)|0x1002:   /* ATI SB400 SATA */
        case (0x439c<<16)|0x1002:   /* ATI 439c SATA*/
        case (0x3373<<16)|0x105A:   /* Promise 20378 RAID */
        case (0x4D30<<16)|0x105A:   /* Promise PDC202xx */
        case (0x4D38<<16)|0x105A:   /* Promise PDC20262 */
        case (0x4D68<<16)|0x105A:   /* Promise PDC20268 */
        case (0x4D69<<16)|0x105A:   /* Promise Ultra/133 TX2 */
        case (0x3112<<16)|0x1095:   /* SiI 3112 SATA/RAID */
        case (0x3149<<16)|0x1106:   /* VIA VT8237 SATA/RAID */
            maxio = 15;
            span = 8*1024;
            /*FALLTHROUGH*/
        case (0x0680<<16)|0x1095:   /* SiI 0680/680A PATA133 ATAPI/RAID */
        case (0x3114<<16)|0x1095:   /* SiI 3114 SATA/RAID */
            pi = 0x85;
            break;
        case (0x0004<<16)|0x1103:   /* HighPoint HPT366 */
            pi = 0x85;
            /*
             * Turn off fast interrupt prediction.
             */
            if((r = pcicfgr8(p, 0x51)) & 0x80)
                pcicfgw8(p, 0x51, r & ~0x80);
            if((r = pcicfgr8(p, 0x55)) & 0x80)
                pcicfgw8(p, 0x55, r & ~0x80);
            break;
        case (0x0640<<16)|0x1095:   /* CMD 640B */
            /*
             * Bugfix code here...
             */
            break;
        case (0x7441<<16)|0x1022:   /* AMD 768 */
            /*
             * Set:
             *  0x41    prefetch, postwrite;
             *  0x43    FIFO configuration 1/2 and 1/2;
             *  0x44    status register read retry;
             *  0x46    DMA read and end of sector flush.
             */
            r = pcicfgr8(p, 0x41);
            pcicfgw8(p, 0x41, r|0xF0);
            r = pcicfgr8(p, 0x43);
            pcicfgw8(p, 0x43, (r & 0x90)|0x2A);
            r = pcicfgr8(p, 0x44);
            pcicfgw8(p, 0x44, r|0x08);
            r = pcicfgr8(p, 0x46);
            pcicfgw8(p, 0x46, (r & 0x0C)|0xF0);
            /*FALLTHROUGH*/
        case (0x7401<<16)|0x1022:   /* AMD 755 Cobra */
        case (0x7409<<16)|0x1022:   /* AMD 756 Viper */
        case (0x7410<<16)|0x1022:   /* AMD 766 Viper Plus */
        case (0x7469<<16)|0x1022:   /* AMD 3111 */
            /*
             * This can probably be lumped in with the 768 above.
             */
            /*FALLTHROUGH*/
        case (0x209A<<16)|0x1022:   /* AMD CS5536 */
        case (0x01BC<<16)|0x10DE:   /* nVidia nForce1 */
        case (0x0065<<16)|0x10DE:   /* nVidia nForce2 */
        case (0x0085<<16)|0x10DE:   /* nVidia nForce2 MCP */
        case (0x00E3<<16)|0x10DE:   /* nVidia nForce2 250 SATA */
        case (0x00D5<<16)|0x10DE:   /* nVidia nForce3 */
        case (0x00E5<<16)|0x10DE:   /* nVidia nForce3 Pro */
        case (0x00EE<<16)|0x10DE:   /* nVidia nForce3 250 SATA */
        case (0x0035<<16)|0x10DE:   /* nVidia nForce3 MCP */
        case (0x0053<<16)|0x10DE:   /* nVidia nForce4 */
        case (0x0054<<16)|0x10DE:   /* nVidia nForce4 SATA */
        case (0x0055<<16)|0x10DE:   /* nVidia nForce4 SATA */
        case (0x0266<<16)|0x10DE:   /* nVidia nForce4 430 SATA */
        case (0x0267<<16)|0x10DE:   /* nVidia nForce 55 MCP SATA */
        case (0x03EC<<16)|0x10DE:   /* nVidia nForce 61 MCP SATA */
        case (0x0448<<16)|0x10DE:   /* nVidia nForce 65 MCP SATA */
        case (0x0560<<16)|0x10DE:   /* nVidia nForce 69 MCP SATA */
            /*
             * Ditto, although it may have a different base
             * address for the registers (0x50?).
             */
            /*FALLTHROUGH*/
        case (0x4376<<16)|0x1002:   /* ATI SB400 PATA */
        case (0x438c<<16)|0x1002:   /* ATI SB600 PATA */
            break;
        case (0x0211<<16)|0x1166:   /* ServerWorks IB6566 */
            {
                Pcidev *sb;

                sb = pcimatch(nil, 0x1166, 0x0200);
                if(sb == nil)
                    break;
                r = pcicfgr32(sb, 0x64);
                r &= ~0x2000;
                pcicfgw32(sb, 0x64, r);
            }
            span = 32*1024;
            break;
        case (0x0502<<17)|0x100B:   /* NS SC1100/SCx200 */
        case (0x5229<<16)|0x10B9:   /* ALi M1543 */
        case (0x5288<<16)|0x10B9:   /* ALi M5288 SATA */
        case (0x5513<<16)|0x1039:   /* SiS 962 */
        case (0x0646<<16)|0x1095:   /* CMD 646 */
        case (0x0571<<16)|0x1106:   /* VIA 82C686 */
        case (0x2363<<16)|0x197b:   /* JMicron SATA */
            break;  /* TODO: verify that this should be here; wasn't in original patch */
        case (0x1230<<16)|0x8086:   /* 82371FB (PIIX) */
        case (0x7010<<16)|0x8086:   /* 82371SB (PIIX3) */
        case (0x7111<<16)|0x8086:   /* 82371[AE]B (PIIX4[E]) */
        case (0x2411<<16)|0x8086:   /* 82801AA (ICH) */
        case (0x2421<<16)|0x8086:   /* 82801AB (ICH0) */
        case (0x244A<<16)|0x8086:   /* 82801BA (ICH2, Mobile) */
        case (0x244B<<16)|0x8086:   /* 82801BA (ICH2, High-End) */
        case (0x248A<<16)|0x8086:   /* 82801CA (ICH3, Mobile) */
        case (0x248B<<16)|0x8086:   /* 82801CA (ICH3, High-End) */
        case (0x24CA<<16)|0x8086:   /* 82801DBM (ICH4, Mobile) */
        case (0x24CB<<16)|0x8086:   /* 82801DB (ICH4, High-End) */
        case (0x24D1<<16)|0x8086:   /* 82801EB/ER (ICH5 High-End) */
        case (0x24DB<<16)|0x8086:   /* 82801EB (ICH5) */
        case (0x25A3<<16)|0x8086:   /* 6300ESB (E7210) */
        case (0x2653<<16)|0x8086:   /* 82801FBM (ICH6M) */
        case (0x266F<<16)|0x8086:   /* 82801FB (ICH6) */
        case (0x27DF<<16)|0x8086:   /* 82801G SATA (ICH7) */
        case (0x27C0<<16)|0x8086:   /* 82801GB SATA AHCI (ICH7) */
//      case (0x27C4<<16)|0x8086:   /* 82801GBM SATA (ICH7) */
        case (0x27C5<<16)|0x8086:   /* 82801GBM SATA AHCI (ICH7) */
        case (0x2920<<16)|0x8086:   /* 82801(IB)/IR/IH/IO SATA IDE (ICH9) */
        case (0x3a20<<16)|0x8086:   /* 82801JI (ICH10) */
        case (0x3a26<<16)|0x8086:   /* 82801JI (ICH10) */
            irqack = ichirqack;
            break;
        }

        for(channel = 0; channel < 2; channel++){
            if(pi & (1<<(2*channel))){
                sdev = ataprobe(p->mem[0+2*channel].bar & ~0x01,
                        p->mem[1+2*channel].bar & ~0x01,
                        p->intl);
                if(sdev == nil)
                    continue;

                ctlr = sdev->ctlr;
                if(ispc87415) {
                    ctlr->ienable = pc87415ienable;
                    print("pc87415disable: not yet implemented\n");
                }

                if(head != nil)
                    tail->next = sdev;
                else
                    head = sdev;
                tail = sdev;
                ctlr->tbdf = p->tbdf;
            }
            else if((sdev = legacy[channel]) == nil)
                continue;
            else
                ctlr = sdev->ctlr;

            ctlr->pcidev = p;
            ctlr->maxio = maxio;
            ctlr->span = span;
            ctlr->irqack = irqack;
            if(!(pi & 0x80))
                continue;
            ctlr->bmiba = (p->mem[4].bar & ~0x01) + channel*8;
        }
    }

if(0){
    int port;
    ISAConf isa;

    /*
     * Hack for PCMCIA drives.
     * This will be tidied once we figure out how the whole
     * removeable device thing is going to work.
     */
    memset(&isa, 0, sizeof(isa));
    isa.port = 0x180;       /* change this for your machine */
    isa.irq = 11;           /* change this for your machine */

    port = isa.port+0x0C;
    channel = pcmspecial("MK2001MPL", &isa);
    if(channel == -1)
        channel = pcmspecial("SunDisk", &isa);
    if(channel == -1){
        isa.irq = 10;
        channel = pcmspecial("CF", &isa);
    }
    if(channel == -1){
        isa.irq = 10;
        channel = pcmspecial("OLYMPUS", &isa);
    }
    if(channel == -1){
        port = isa.port+0x204;
        channel = pcmspecial("ATA/ATAPI", &isa);
    }
    if(channel >= 0 && (sdev = ataprobe(isa.port, port, isa.irq)) != nil){
        if(head != nil)
            tail->next = sdev;
        else
            head = sdev;
    }
}
    return head;
}

static SDev*
atalegacy(int port, int irq)
{
    return ataprobe(port, port+0x204, irq);
}

static int
ataenable(SDev* sdev)
{
    Ctlr *ctlr;
    char name[32];

    ctlr = sdev->ctlr;

    if(ctlr->bmiba){
        if(ctlr->pcidev != nil)
            pcisetbme(ctlr->pcidev);
          //#define ALIGN   (4 * 1024)
        ctlr->prdt = mallocalign(Nprd*sizeof(Prd), 4, 0, 4*1024);
        if(ctlr->prdt == nil)
            error(Enomem);
    }
    snprint(name, sizeof(name), "%s (%s)", sdev->name, sdev->ifc->name);
    intrenable(ctlr->irq, atainterrupt, ctlr, ctlr->tbdf, name);
    outb(ctlr->ctlport+Dc, 0);
    if(ctlr->ienable)
        ctlr->ienable(ctlr);

    return 1;
}

static int
atadisable(SDev *sdev)
{
    Ctlr *ctlr;
    char name[32];

    ctlr = sdev->ctlr;
    outb(ctlr->ctlport+Dc, Nien);       /* disable interrupts */
    if (ctlr->idisable)
        ctlr->idisable(ctlr);
    snprint(name, sizeof(name), "%s (%s)", sdev->name, sdev->ifc->name);
    intrdisable(ctlr->irq, atainterrupt, ctlr, ctlr->tbdf, name);
    if (ctlr->bmiba) {
        if (ctlr->pcidev)
            pciclrbme(ctlr->pcidev);
        free(ctlr->prdt);
    }
    return 0;
}

static int
atarctl(SDunit* unit, char* p, int l)
{
    int n;
    Ctlr *ctlr;
    Drive *drive;

    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil)
        return 0;
    drive = ctlr->drive[unit->subno];

    qlock(drive);
    n = snprint(p, l, "config %4.4uX capabilities %4.4uX",
        drive->info[Iconfig], drive->info[Icapabilities]);
    if(drive->dma)
        n += snprint(p+n, l-n, " dma %8.8uX dmactl %8.8uX",
            drive->dma, drive->dmactl);
    if(drive->rwm)
        n += snprint(p+n, l-n, " rwm %ud rwmctl %ud",
            drive->rwm, drive->rwmctl);
    if(drive->flags&Lba48)
        n += snprint(p+n, l-n, " lba48always %s",
            (drive->flags&Lba48always) ? "on" : "off");
    n += snprint(p+n, l-n, "\n");
    n += snprint(p+n, l-n, "interrupts read %lud write %lud cmds %lud\n",
        drive->intrd, drive->intwr, drive->intcmd);
    if(drive->sectors){
        n += snprint(p+n, l-n, "geometry %lld %d",
            drive->sectors, drive->secsize);
        if(drive->pkt == 0)
            n += snprint(p+n, l-n, " %d %d %d",
                drive->c, drive->h, drive->s);
        n += snprint(p+n, l-n, "\n");
    }
    qunlock(drive);

    return n;
}

static int
atawctl(SDunit* unit, Cmdbuf* cb)
{
    int period;
    Ctlr *ctlr;
    Drive *drive;

    if((ctlr = unit->dev->ctlr) == nil || ctlr->drive[unit->subno] == nil)
        return 0;
    drive = ctlr->drive[unit->subno];

    qlock(drive);
    if(waserror()){
        qunlock(drive);
        nexterror();
    }

    /*
     * Dma and rwm control is passive at the moment,
     * i.e. it is assumed that the hardware is set up
     * correctly already either by the BIOS or when
     * the drive was initially identified.
     */
    if(strcmp(cb->f[0], "dma") == 0){
        if(cb->nf != 2 || drive->dma == 0)
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->dmactl = drive->dma;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->dmactl = 0;
        else
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "rwm") == 0){
        if(cb->nf != 2 || drive->rwm == 0)
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->rwmctl = drive->rwm;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->rwmctl = 0;
        else
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "standby") == 0){
        switch(cb->nf){
        default:
            error(Ebadctl);
        case 2:
            period = strtol(cb->f[1], 0, 0);
            if(period && (period < 30 || period > 240*5))
                error(Ebadctl);
            period /= 5;
            break;
        }
        if(atastandby(drive, period) != SDok)
            error(Ebadctl);
    }
    else if(strcmp(cb->f[0], "lba48always") == 0){
        if(cb->nf != 2 || !(drive->flags&Lba48))
            error(Ebadctl);
        if(strcmp(cb->f[1], "on") == 0)
            drive->flags |= Lba48always;
        else if(strcmp(cb->f[1], "off") == 0)
            drive->flags &= ~Lba48always;
        else
            error(Ebadctl);
    }
    else
        error(Ebadctl);
    qunlock(drive);
    poperror();

    return 0;
}

SDifc sdataifc = {
    "ata",              /* name */

    atapnp,             /* pnp */
    atalegacy,          /* legacy */
    ataenable,          /* enable */
    atadisable,         /* disable */

    scsiverify,         /* verify */
    scsionline,         /* online */
    atario,             /* rio */
    atarctl,            /* rctl */
    atawctl,            /* wctl */

    scsibio,            /* bio */
    ataprobew,          /* probe */
    ataclear,           /* clear */
    atastat,            /* rtopctl */
    nil,                /* wtopctl */
};
@


\subsection*{[[devices/storage/devsd.c]]}

<<devsd.c>>=
/*
 * Storage Device.
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"
#include "../port/error.h"

#include "../port/sd.h"

extern Dev sddevtab;
extern SDifc* sdifc[];

static char devletters[] = "0123456789"
    "abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

static SDev *devs[sizeof devletters-1];
static QLock devslock;

extern void sdaddpart(SDunit*, char*, uvlong, uvlong);
//extern int sdsetsense(SDreq*, int, int, int, int);
//extern int sdmodesense(SDreq*, uchar*, void*, int);
extern void sdadddevs(SDev*);

enum {
    Rawcmd,
    Rawdata,
    Rawstatus,
};

enum {
    Qtopdir     = 1,        /* top level directory */
    Qtopbase,
    Qtopctl      = Qtopbase,

    Qunitdir,           /* directory per unit */
    Qunitbase,
    Qctl        = Qunitbase,
    Qraw,
    Qpart,

    TypeLOG     = 4,
    NType       = (1<<TypeLOG),
    TypeMASK    = (NType-1),
    TypeSHIFT   = 0,

    PartLOG     = 8,
    NPart       = (1<<PartLOG),
    PartMASK    = (NPart-1),
    PartSHIFT   = TypeLOG,

    UnitLOG     = 8,
    NUnit       = (1<<UnitLOG),
    UnitMASK    = (NUnit-1),
    UnitSHIFT   = (PartLOG+TypeLOG),

    DevLOG      = 8,
    NDev        = (1 << DevLOG),
    DevMASK     = (NDev-1),
    DevSHIFT     = (UnitLOG+PartLOG+TypeLOG),

    Ncmd = 20,
};

#define TYPE(q)     ((((ulong)(q).path)>>TypeSHIFT) & TypeMASK)
#define PART(q)     ((((ulong)(q).path)>>PartSHIFT) & PartMASK)
#define UNIT(q)     ((((ulong)(q).path)>>UnitSHIFT) & UnitMASK)
#define DEV(q)      ((((ulong)(q).path)>>DevSHIFT) & DevMASK)
#define QID(d,u, p, t)  (((d)<<DevSHIFT)|((u)<<UnitSHIFT)|\
                     ((p)<<PartSHIFT)|((t)<<TypeSHIFT))


void
sdaddpart(SDunit* unit, char* name, uvlong start, uvlong end)
{
    SDpart *pp;
    int i, partno;

    /*
     * Check name not already used
     * and look for a free slot.
     */
    if(unit->part != nil){
        partno = -1;
        for(i = 0; i < unit->npart; i++){
            pp = &unit->part[i];
            if(!pp->valid){
                if(partno == -1)
                    partno = i;
                break;
            }
            if(strcmp(name, pp->name) == 0){
                if(pp->start == start && pp->end == end)
                    return;
                error(Ebadctl);
            }
        }
    }
    else{
        if((unit->part = malloc(sizeof(SDpart)*SDnpart)) == nil)
            error(Enomem);
        unit->npart = SDnpart;
        partno = 0;
    }

    /*
     * If no free slot found then increase the
     * array size (can't get here with unit->part == nil).
     */
    if(partno == -1){
        if(unit->npart >= NPart)
            error(Enomem);
        if((pp = malloc(sizeof(SDpart)*(unit->npart+SDnpart))) == nil)
            error(Enomem);
        memmove(pp, unit->part, sizeof(SDpart)*unit->npart);
        free(unit->part);
        unit->part = pp;
        partno = unit->npart;
        unit->npart += SDnpart;
    }

    /*
     * Check size and extent are valid.
     */
    if(start > end || end > unit->sectors)
        error(Eio);
    pp = &unit->part[partno];
    pp->start = start;
    pp->end = end;
    kstrdup(&pp->name, name);
    kstrdup(&pp->user, eve);
    pp->perm = 0640;
    pp->valid = 1;
}

static void
sddelpart(SDunit* unit, char* name)
{
    int i;
    SDpart *pp;

    /*
     * Look for the partition to delete.
     * Can't delete if someone still has it open.
     */
    pp = unit->part;
    for(i = 0; i < unit->npart; i++){
        if(strcmp(name, pp->name) == 0)
            break;
        pp++;
    }
    if(i >= unit->npart)
        error(Ebadctl);
    if(strcmp(up->user, pp->user) && !iseve())
        error(Eperm);
    pp->valid = 0;
    pp->vers++;
}

static void
sdincvers(SDunit *unit)
{
    int i;

    unit->vers++;
    if(unit->part){
        for(i = 0; i < unit->npart; i++){
            unit->part[i].valid = 0;
            unit->part[i].vers++;
        }
    }
}

static int
sdinitpart(SDunit* unit)
{
    int nf;
    uvlong start, end;
    char *f[4], *p, *q, buf[10];

    if(unit->sectors > 0){
        unit->sectors = unit->secsize = 0;
        sdincvers(unit);
    }

    /* device must be connected or not; other values are trouble */
    if(unit->inquiry[0] & 0xC0) /* see SDinq0periphqual */
        return 0;
    switch(unit->inquiry[0] & SDinq0periphtype){
    case SDperdisk:
    case SDperworm:
    case SDpercd:
    case SDpermo:
        break;
    default:
        return 0;
    }

    if(unit->dev->ifc->online)
        unit->dev->ifc->online(unit);
    if(unit->sectors){
        sdincvers(unit);
        sdaddpart(unit, "data", 0, unit->sectors);

        /*
         * Use partitions passed from boot program,
         * e.g.
         *  sdC0part=dos 63 123123/plan9 123123 456456
         * This happens before /boot sets hostname so the
         * partitions will have the null-string for user.
         * The gen functions patch it up.
         */
        snprint(buf, sizeof buf, "%spart", unit->name);
        for(p = getconf(buf); p != nil; p = q){
            if(q = strchr(p, '/'))
                *q++ = '\0';
            nf = tokenize(p, f, nelem(f));
            if(nf < 3)
                continue;

            start = strtoull(f[1], 0, 0);
            end = strtoull(f[2], 0, 0);
            if(!waserror()){
                sdaddpart(unit, f[0], start, end);
                poperror();
            }
        }
    }

    return 1;
}

static int
sdindex(int idno)
{
    char *p;

    p = strchr(devletters, idno);
    if(p == nil)
        return -1;
    return p-devletters;
}

static SDev*
sdgetdev(int idno)
{
    SDev *sdev;
    int i;

    if((i = sdindex(idno)) < 0)
        return nil;

    qlock(&devslock);
    if(sdev = devs[i])
        incref(&sdev->r);
    qunlock(&devslock);
    return sdev;
}

static SDunit*
sdgetunit(SDev* sdev, int subno)
{
    SDunit *unit;
    char buf[32];

    /*
     * Associate a unit with a given device and sub-unit
     * number on that device.
     * The device will be probed if it has not already been
     * successfully accessed.
     */
    qlock(&sdev->unitlock);
    if(subno > sdev->nunit){
        qunlock(&sdev->unitlock);
        return nil;
    }

    unit = sdev->unit[subno];
    if(unit == nil){
        /*
         * Probe the unit only once. This decision
         * may be a little severe and reviewed later.
         */
        if(sdev->unitflg[subno]){
            qunlock(&sdev->unitlock);
            return nil;
        }
        if((unit = malloc(sizeof(SDunit))) == nil){
            qunlock(&sdev->unitlock);
            return nil;
        }
        sdev->unitflg[subno] = 1;

        snprint(buf, sizeof(buf), "%s%d", sdev->name, subno);
        kstrdup(&unit->name, buf);
        kstrdup(&unit->user, eve);
        unit->perm = 0555;
        unit->subno = subno;
        unit->dev = sdev;

        if(sdev->enabled == 0 && sdev->ifc->enable)
            sdev->ifc->enable(sdev);
        sdev->enabled = 1;

        /*
         * No need to lock anything here as this is only
         * called before the unit is made available in the
         * sdunit[] array.
         */
        if(unit->dev->ifc->verify(unit) == 0){
            qunlock(&sdev->unitlock);
            free(unit);
            return nil;
        }
        sdev->unit[subno] = unit;
    }
    qunlock(&sdev->unitlock);
    return unit;
}

static void
sdreset(void)
{
    int i;
    SDev *sdev;

    /*
     * Probe all known controller types and register any devices found.
     */
    for(i = 0; sdifc[i] != nil; i++){
        if(sdifc[i]->pnp == nil || (sdev = sdifc[i]->pnp()) == nil)
            continue;
        sdadddevs(sdev);
    }
}

void
sdadddevs(SDev *sdev)
{
    int i, j, id;
    SDev *next;

    for(; sdev; sdev=next){
        next = sdev->next;

        sdev->unit = (SDunit**)malloc(sdev->nunit * sizeof(SDunit*));
        sdev->unitflg = (int*)malloc(sdev->nunit * sizeof(int));
        if(sdev->unit == nil || sdev->unitflg == nil){
            print("sdadddevs: out of memory\n");
        giveup:
            free(sdev->unit);
            free(sdev->unitflg);
            if(sdev->ifc->clear)
                sdev->ifc->clear(sdev);
            free(sdev);
            continue;
        }
        id = sdindex(sdev->idno);
        if(id == -1){
            print("sdadddevs: bad id number %d (%C)\n", id, id);
            goto giveup;
        }
        qlock(&devslock);
        for(i=0; i<nelem(devs); i++){
            if(devs[j = (id+i)%nelem(devs)] == nil){
                sdev->idno = devletters[j];
                devs[j] = sdev;
                snprint(sdev->name, sizeof sdev->name, "sd%c", devletters[j]);
                break;
            }
        }
        qunlock(&devslock);
        if(i == nelem(devs)){
            print("sdadddevs: out of device letters\n");
            goto giveup;
        }
    }
}

// void
// sdrmdevs(SDev *sdev)
// {
//  char buf[2];
//
//  snprint(buf, sizeof buf, "%c", sdev->idno);
//  unconfigure(buf);
// }

//void
//sdaddallconfs(void (*addconf)(SDunit *))
//{
//  int i, u;
//  SDev *sdev;
//
//  for(i = 0; i < nelem(devs); i++)        /* each controller */
//      for(sdev = devs[i]; sdev; sdev = sdev->next)
//          for(u = 0; u < sdev->nunit; u++)    /* each drive */
//              (*addconf)(sdev->unit[u]);
//}

static int
sd2gen(Chan* c, int i, Dir* dp)
{
    Qid q;
    uvlong l;
    SDpart *pp;
    SDperm *perm;
    SDunit *unit;
    SDev *sdev;
    int rv;

    sdev = sdgetdev(DEV(c->qid));
    assert(sdev);
    unit = sdev->unit[UNIT(c->qid)];

    rv = -1;
    switch(i){
    case Qctl:
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qctl),
            unit->vers, QTFILE);
        perm = &unit->ctlperm;
        if(emptystr(perm->user)){
            kstrdup(&perm->user, eve);
            perm->perm = 0644;  /* nothing secret in ctl */
        }
        devdir(c, q, "ctl", 0, perm->user, perm->perm, dp);
        rv = 1;
        break;

    case Qraw:
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qraw),
            unit->vers, QTFILE);
        perm = &unit->rawperm;
        if(emptystr(perm->user)){
            kstrdup(&perm->user, eve);
            perm->perm = DMEXCL|0600;
        }
        devdir(c, q, "raw", 0, perm->user, perm->perm, dp);
        rv = 1;
        break;

    case Qpart:
        pp = &unit->part[PART(c->qid)];
        l = (pp->end - pp->start) * unit->secsize;
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), PART(c->qid), Qpart),
            unit->vers+pp->vers, QTFILE);
        if(emptystr(pp->user))
            kstrdup(&pp->user, eve);
        devdir(c, q, pp->name, l, pp->user, pp->perm, dp);
        rv = 1;
        break;
    }

    decref(&sdev->r);
    return rv;
}

static int
sd1gen(Chan* c, int i, Dir* dp)
{
    Qid q;

    switch(i){
    case Qtopctl:
        mkqid(&q, QID(0, 0, 0, Qtopctl), 0, QTFILE);
        devdir(c, q, "sdctl", 0, eve, 0644, dp);    /* no secrets */
        return 1;
    }
    return -1;
}

static int
sdgen(Chan* c, char*, Dirtab*, int, int s, Dir* dp)
{
    Qid q;
    uvlong l;
    int i, r;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;

    switch(TYPE(c->qid)){
    case Qtopdir:
        if(s == DEVDOTDOT){
            mkqid(&q, QID(0, 0, 0, Qtopdir), 0, QTDIR);
            snprint(up->genbuf, sizeof up->genbuf, "#%C",
                sddevtab.dc);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            return 1;
        }

        if(s+Qtopbase < Qunitdir)
            return sd1gen(c, s+Qtopbase, dp);
        s -= (Qunitdir-Qtopbase);

        qlock(&devslock);
        for(i=0; i<nelem(devs); i++){
            if(devs[i]){
                if(s < devs[i]->nunit)
                    break;
                s -= devs[i]->nunit;
            }
        }

        if(i == nelem(devs)){
            /* Run off the end of the list */
            qunlock(&devslock);
            return -1;
        }

        if((sdev = devs[i]) == nil){
            qunlock(&devslock);
            return 0;
        }

        incref(&sdev->r);
        qunlock(&devslock);

        if((unit = sdev->unit[s]) == nil)
            if((unit = sdgetunit(sdev, s)) == nil){
                decref(&sdev->r);
                return 0;
            }

        mkqid(&q, QID(sdev->idno, s, 0, Qunitdir), 0, QTDIR);
        if(emptystr(unit->user))
            kstrdup(&unit->user, eve);
        devdir(c, q, unit->name, 0, unit->user, unit->perm, dp);
        decref(&sdev->r);
        return 1;

    case Qunitdir:
        if(s == DEVDOTDOT){
            mkqid(&q, QID(0, 0, 0, Qtopdir), 0, QTDIR);
            snprint(up->genbuf, sizeof up->genbuf, "#%C",
                sddevtab.dc);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            return 1;
        }

        if((sdev = sdgetdev(DEV(c->qid))) == nil){
            devdir(c, c->qid, "unavailable", 0, eve, 0, dp);
            return 1;
        }

        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->ctl);

        /*
         * Check for media change.
         * If one has already been detected, sectors will be zero.
         * If there is one waiting to be detected, online
         * will return > 1.
         * Online is a bit of a large hammer but does the job.
         */
        if(unit->sectors == 0
        || (unit->dev->ifc->online && unit->dev->ifc->online(unit) > 1))
            sdinitpart(unit);

        i = s+Qunitbase;
        if(i < Qpart){
            r = sd2gen(c, i, dp);
            qunlock(&unit->ctl);
            decref(&sdev->r);
            return r;
        }
        i -= Qpart;
        if(unit->part == nil || i >= unit->npart){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            break;
        }
        pp = &unit->part[i];
        if(!pp->valid){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            return 0;
        }
        l = (pp->end - pp->start) * unit->secsize;
        mkqid(&q, QID(DEV(c->qid), UNIT(c->qid), i, Qpart),
            unit->vers+pp->vers, QTFILE);
        if(emptystr(pp->user))
            kstrdup(&pp->user, eve);
        devdir(c, q, pp->name, l, pp->user, pp->perm, dp);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        return 1;
    case Qraw:
    case Qctl:
    case Qpart:
        if((sdev = sdgetdev(DEV(c->qid))) == nil){
            devdir(c, q, "unavailable", 0, eve, 0, dp);
            return 1;
        }
        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->ctl);
        r = sd2gen(c, TYPE(c->qid), dp);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        return r;
    case Qtopctl:
        return sd1gen(c, TYPE(c->qid), dp);
    default:
        break;
    }

    return -1;
}

static Chan*
sdattach(char* spec)
{
    Chan *c;
    char *p;
    SDev *sdev;
    int idno, subno;

    if(*spec == '\0'){
        c = devattach(sddevtab.dc, spec);
        mkqid(&c->qid, QID(0, 0, 0, Qtopdir), 0, QTDIR);
        return c;
    }

    if(spec[0] != 's' || spec[1] != 'd')
        error(Ebadspec);
    idno = spec[2];
    subno = strtol(&spec[3], &p, 0);
    if(p == &spec[3])
        error(Ebadspec);

    if((sdev=sdgetdev(idno)) == nil)
        error(Enonexist);
    if(sdgetunit(sdev, subno) == nil){
        decref(&sdev->r);
        error(Enonexist);
    }

    c = devattach(sddevtab.dc, spec);
    mkqid(&c->qid, QID(sdev->idno, subno, 0, Qunitdir), 0, QTDIR);
    c->dev = (sdev->idno << UnitLOG) + subno;
    decref(&sdev->r);
    return c;
}

static Walkqid*
sdwalk(Chan* c, Chan* nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, nil, 0, sdgen);
}

static int
sdstat(Chan* c, uchar* db, int n)
{
    return devstat(c, db, n, nil, 0, sdgen);
}

static Chan*
sdopen(Chan* c, int omode)
{
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    uchar tp;

    c = devopen(c, omode, 0, 0, sdgen);
    if((tp = TYPE(c->qid)) != Qctl && tp != Qraw && tp != Qpart)
        return c;

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil)
        error(Enonexist);

    unit = sdev->unit[UNIT(c->qid)];

    switch(TYPE(c->qid)){
    case Qctl:
        c->qid.vers = unit->vers;
        break;
    case Qraw:
        c->qid.vers = unit->vers;
        if(tas(&unit->rawinuse) != 0){
            c->flag &= ~COPEN;
            decref(&sdev->r);
            error(Einuse);
        }
        unit->state = Rawcmd;
        break;
    case Qpart:
        qlock(&unit->ctl);
        if(waserror()){
            qunlock(&unit->ctl);
            c->flag &= ~COPEN;
            decref(&sdev->r);
            nexterror();
        }
        pp = &unit->part[PART(c->qid)];
        c->qid.vers = unit->vers+pp->vers;
        qunlock(&unit->ctl);
        poperror();
        break;
    }
    decref(&sdev->r);
    return c;
}

static void
sdclose(Chan* c)
{
    SDunit *unit;
    SDev *sdev;

    if(c->qid.type & QTDIR)
        return;
    if(!(c->flag & COPEN))
        return;

    switch(TYPE(c->qid)){
    default:
        break;
    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev){
            unit = sdev->unit[UNIT(c->qid)];
            unit->rawinuse = 0;
            decref(&sdev->r);
        }
        break;
    }
}

static long
sdbio(Chan* c, int write, char* a, long len, uvlong off)
{
    int nchange;
    long l;
    uchar *b;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    ulong max, nb, offset;
    uvlong bno;

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil){
        decref(&sdev->r);
        error(Enonexist);
    }
    unit = sdev->unit[UNIT(c->qid)];
    if(unit == nil)
        error(Enonexist);

    nchange = 0;
    qlock(&unit->ctl);
    while(waserror()){
        /* notification of media change; go around again */
        if(strcmp(up->errstr, Eio) == 0 && unit->sectors == 0 && nchange++ == 0){
            sdinitpart(unit);
            continue;
        }

        /* other errors; give up */
        qunlock(&unit->ctl);
        decref(&sdev->r);
        nexterror();
    }
    pp = &unit->part[PART(c->qid)];
    if(unit->vers+pp->vers != c->qid.vers)
        error(Echange);

    /*
     * Check the request is within bounds.
     * Removeable drives are locked throughout the I/O
     * in case the media changes unexpectedly.
     * Non-removeable drives are not locked during the I/O
     * to allow the hardware to optimise if it can; this is
     * a little fast and loose.
     * It's assumed that non-removeable media parameters
     * (sectors, secsize) can't change once the drive has
     * been brought online.
     */
    bno = (off/unit->secsize) + pp->start;
    nb = ((off+len+unit->secsize-1)/unit->secsize) + pp->start - bno;
    max = SDmaxio/unit->secsize;
    if(nb > max)
        nb = max;
    if(bno+nb > pp->end)
        nb = pp->end - bno;
    if(bno >= pp->end || nb == 0){
        if(write)
            error(Eio);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        poperror();
        return 0;
    }
    if(!(unit->inquiry[1] & SDinq1removable)){
        qunlock(&unit->ctl);
        poperror();
    }

    b = sdmalloc(nb*unit->secsize);
    if(b == nil)
        error(Enomem);
    if(waserror()){
        sdfree(b);
        if(!(unit->inquiry[1] & SDinq1removable))
            decref(&sdev->r);       /* gadverdamme! */
        nexterror();
    }

    offset = off%unit->secsize;
    if(offset+len > nb*unit->secsize)
        len = nb*unit->secsize - offset;
    if(write){
        if(offset || (len%unit->secsize)){
            l = unit->dev->ifc->bio(unit, 0, 0, b, nb, bno);
            if(l < 0)
                error(Eio);
            if(l < (nb*unit->secsize)){
                nb = l/unit->secsize;
                l = nb*unit->secsize - offset;
                if(len > l)
                    len = l;
            }
        }
        memmove(b+offset, a, len);
        l = unit->dev->ifc->bio(unit, 0, 1, b, nb, bno);
        if(l < 0)
            error(Eio);
        if(l < offset)
            len = 0;
        else if(len > l - offset)
            len = l - offset;
    }
    else{
        l = unit->dev->ifc->bio(unit, 0, 0, b, nb, bno);
        if(l < 0)
            error(Eio);
        if(l < offset)
            len = 0;
        else if(len > l - offset)
            len = l - offset;
        memmove(a, b+offset, len);
    }
    sdfree(b);
    poperror();

    if(unit->inquiry[1] & SDinq1removable){
        qunlock(&unit->ctl);
        poperror();
    }

    decref(&sdev->r);
    return len;
}

static long
sdrio(SDreq* r, void* a, long n)
{
    void *data;

    if(n >= SDmaxio || n < 0)
        error(Etoobig);

    data = nil;
    if(n){
        if((data = sdmalloc(n)) == nil)
            error(Enomem);
        if(r->write)
            memmove(data, a, n);
    }
    r->data = data;
    r->dlen = n;

    if(waserror()){
        sdfree(data);
        r->data = nil;
        nexterror();
    }

    if(r->unit->dev->ifc->rio(r) != SDok)
        error(Eio);

    if(!r->write && r->rlen > 0)
        memmove(a, data, r->rlen);
    sdfree(data);
    r->data = nil;
    poperror();

    return r->rlen;
}

/*
 * SCSI simulation for non-SCSI devices
 */
//int
//sdsetsense(SDreq *r, int status, int key, int asc, int ascq)
//{
//  int len;
//  SDunit *unit;
//
//  unit = r->unit;
//  unit->sense[2] = key;
//  unit->sense[12] = asc;
//  unit->sense[13] = ascq;
//
//  r->status = status;
//  if(status == SDcheck && !(r->flags & SDnosense)){
//      /* request sense case from sdfakescsi */
//      len = sizeof unit->sense;
//      if(len > sizeof r->sense-1)
//          len = sizeof r->sense-1;
//      memmove(r->sense, unit->sense, len);
//      unit->sense[2] = 0;
//      unit->sense[12] = 0;
//      unit->sense[13] = 0;
//      r->flags |= SDvalidsense;
//      return SDok;
//  }
//  return status;
//}

//int
//sdmodesense(SDreq *r, uchar *cmd, void *info, int ilen)
//{
//  int len;
//  uchar *data;
//
//  /*
//   * Fake a vendor-specific request with page code 0,
//   * return the drive info.
//   */
//  if((cmd[2] & 0x3F) != 0 && (cmd[2] & 0x3F) != 0x3F)
//      return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
//  len = (cmd[7]<<8)|cmd[8];
//  if(len == 0)
//      return SDok;
//  if(len < 8+ilen)
//      return sdsetsense(r, SDcheck, 0x05, 0x1A, 0);
//  if(r->data == nil || r->dlen < len)
//      return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
//  data = r->data;
//  memset(data, 0, 8);
//  data[0] = ilen>>8;
//  data[1] = ilen;
//  if(ilen)
//      memmove(data+8, info, ilen);
//  r->rlen = 8+ilen;
//  return sdsetsense(r, SDok, 0, 0, 0);
//}

//int
//sdfakescsi(SDreq *r, void *info, int ilen)
//{
//  uchar *cmd, *p;
//  uvlong len;
//  SDunit *unit;
//
//  cmd = r->cmd;
//  r->rlen = 0;
//  unit = r->unit;
//
//  /*
//   * Rewrite read(6)/write(6) into read(10)/write(10).
//   */
//  switch(cmd[0]){
//  case 0x08:  /* read */
//  case 0x0A:  /* write */
//      cmd[9] = 0;
//      cmd[8] = cmd[4];
//      cmd[7] = 0;
//      cmd[6] = 0;
//      cmd[5] = cmd[3];
//      cmd[4] = cmd[2];
//      cmd[3] = cmd[1] & 0x0F;
//      cmd[2] = 0;
//      cmd[1] &= 0xE0;
//      cmd[0] |= 0x20;
//      break;
//  }
//
//  /*
//   * Map SCSI commands into ATA commands for discs.
//   * Fail any command with a LUN except INQUIRY which
//   * will return 'logical unit not supported'.
//   */
//  if((cmd[1]>>5) && cmd[0] != 0x12)
//      return sdsetsense(r, SDcheck, 0x05, 0x25, 0);
//
//  switch(cmd[0]){
//  default:
//      return sdsetsense(r, SDcheck, 0x05, 0x20, 0);
//
//  case 0x00:  /* test unit ready */
//      return sdsetsense(r, SDok, 0, 0, 0);
//
//  case 0x03:  /* request sense */
//      if(cmd[4] < sizeof unit->sense)
//          len = cmd[4];
//      else
//          len = sizeof unit->sense;
//      if(r->data && r->dlen >= len){
//          memmove(r->data, unit->sense, len);
//          r->rlen = len;
//      }
//      return sdsetsense(r, SDok, 0, 0, 0);
//
//  case 0x12:  /* inquiry */
//      if(cmd[4] < sizeof unit->inquiry)
//          len = cmd[4];
//      else
//          len = sizeof unit->inquiry;
//      if(r->data && r->dlen >= len){
//          memmove(r->data, unit->inquiry, len);
//          r->rlen = len;
//      }
//      return sdsetsense(r, SDok, 0, 0, 0);
//
//  case 0x1B:  /* start/stop unit */
//      /*
//       * nop for now, can use power management later.
//       */
//      return sdsetsense(r, SDok, 0, 0, 0);
//
//  case 0x25:  /* read capacity */
//      if((cmd[1] & 0x01) || cmd[2] || cmd[3])
//          return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
//      if(r->data == nil || r->dlen < 8)
//          return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
//
//      /*
//       * Read capacity returns the LBA of the last sector.
//       */
//      len = unit->sectors - 1;
//      p = r->data;
//      *p++ = len>>24;
//      *p++ = len>>16;
//      *p++ = len>>8;
//      *p++ = len;
//      len = 512;
//      *p++ = len>>24;
//      *p++ = len>>16;
//      *p++ = len>>8;
//      *p++ = len;
//      r->rlen = p - (uchar*)r->data;
//      return sdsetsense(r, SDok, 0, 0, 0);
//
//  case 0x9E:  /* long read capacity */
//      if((cmd[1] & 0x01) || cmd[2] || cmd[3])
//          return sdsetsense(r, SDcheck, 0x05, 0x24, 0);
//      if(r->data == nil || r->dlen < 8)
//          return sdsetsense(r, SDcheck, 0x05, 0x20, 1);
//      /*
//       * Read capcity returns the LBA of the last sector.
//       */
//      len = unit->sectors - 1;
//      p = r->data;
//      *p++ = len>>56;
//      *p++ = len>>48;
//      *p++ = len>>40;
//      *p++ = len>>32;
//      *p++ = len>>24;
//      *p++ = len>>16;
//      *p++ = len>>8;
//      *p++ = len;
//      len = 512;
//      *p++ = len>>24;
//      *p++ = len>>16;
//      *p++ = len>>8;
//      *p++ = len;
//      r->rlen = p - (uchar*)r->data;
//      return sdsetsense(r, SDok, 0, 0, 0);
//
//  case 0x5A:  /* mode sense */
//      return sdmodesense(r, cmd, info, ilen);
//
//  case 0x28:  /* read */
//  case 0x2A:  /* write */
//  case 0x88:  /* read16 */
//  case 0x8a:  /* write16 */
//      return SDnostatus;
//  }
//}

static long
sdread(Chan *c, void *a, long n, vlong off)
{
    char *p, *e, *buf;
    SDpart *pp;
    SDunit *unit;
    SDev *sdev;
    ulong offset;
    int i, l, m, status;

    offset = off;
    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qtopctl:
        m = 64*1024;    /* room for register dumps */
        p = buf = malloc(m);
        if(p == nil)
            error(Enomem);
        e = p + m;
        qlock(&devslock);
        for(i = 0; i < nelem(devs); i++){
            sdev = devs[i];
            if(sdev && sdev->ifc->rtopctl)
                p = sdev->ifc->rtopctl(sdev, p, e);
        }
        qunlock(&devslock);
        n = readstr(off, a, n, buf);
        free(buf);
        return n;

    case Qtopdir:
    case Qunitdir:
        return devdirread(c, a, n, 0, 0, sdgen);

    case Qctl:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);

        unit = sdev->unit[UNIT(c->qid)];
        m = 16*1024;    /* room for register dumps */
        p = malloc(m);
        if(p == nil)
            error(Enomem);
        l = snprint(p, m, "inquiry %.48s\n",
            (char*)unit->inquiry+8);
        qlock(&unit->ctl);
        /*
         * If there's a device specific routine it must
         * provide all information pertaining to night geometry
         * and the garscadden trains.
         */
        if(unit->dev->ifc->rctl)
            l += unit->dev->ifc->rctl(unit, p+l, m-l);
        if(unit->sectors == 0)
            sdinitpart(unit);
        if(unit->sectors){
            if(unit->dev->ifc->rctl == nil)
                l += snprint(p+l, m-l,
                    "geometry %llud %lud\n",
                    unit->sectors, unit->secsize);
            pp = unit->part;
            for(i = 0; i < unit->npart; i++){
                if(pp->valid)
                    l += snprint(p+l, m-l,
                        "part %s %llud %llud\n",
                        pp->name, pp->start, pp->end);
                pp++;
            }
        }
        qunlock(&unit->ctl);
        decref(&sdev->r);
        l = readstr(offset, a, n, p);
        free(p);
        return l;

    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);

        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->raw);
        if(waserror()){
            qunlock(&unit->raw);
            decref(&sdev->r);
            nexterror();
        }
        if(unit->state == Rawdata){
            unit->state = Rawstatus;
            i = sdrio(unit->req, a, n);
        }
        else if(unit->state == Rawstatus){
            status = unit->req->status;
            unit->state = Rawcmd;
            free(unit->req);
            unit->req = nil;
            i = readnum(0, a, n, status, NUMSIZE);
        } else
            i = 0;
        qunlock(&unit->raw);
        decref(&sdev->r);
        poperror();
        return i;

    case Qpart:
        return sdbio(c, 0, a, n, off);
    }
}

static void legacytopctl(Cmdbuf*);

static long
sdwrite(Chan* c, void* a, long n, vlong off)
{
    char *f0;
    int i;
    uvlong end, start;
    Cmdbuf *cb;
    SDifc *ifc;
    SDreq *req;
    SDunit *unit;
    SDev *sdev;

    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qtopctl:
        cb = parsecmd(a, n);
        if(waserror()){
            free(cb);
            nexterror();
        }
        if(cb->nf == 0)
            error("empty control message");
        f0 = cb->f[0];
        cb->f++;
        cb->nf--;
        if(strcmp(f0, "config") == 0){
            /* wormhole into ugly legacy interface */
            legacytopctl(cb);
            poperror();
            free(cb);
            break;
        }
        /*
         * "ata arg..." invokes sdifc[i]->wtopctl(nil, cb),
         * where sdifc[i]->name=="ata" and cb contains the args.
         */
        ifc = nil;
        sdev = nil;
        for(i=0; sdifc[i]; i++){
            if(strcmp(sdifc[i]->name, f0) == 0){
                ifc = sdifc[i];
                sdev = nil;
                goto subtopctl;
            }
        }
        /*
         * "sd1 arg..." invokes sdifc[i]->wtopctl(sdev, cb),
         * where sdifc[i] and sdev match controller letter "1",
         * and cb contains the args.
         */
        if(f0[0]=='s' && f0[1]=='d' && f0[2] && f0[3] == 0){
            if((sdev = sdgetdev(f0[2])) != nil){
                ifc = sdev->ifc;
                goto subtopctl;
            }
        }
        error("unknown interface");

    subtopctl:
        if(waserror()){
            if(sdev)
                decref(&sdev->r);
            nexterror();
        }
        if(ifc->wtopctl)
            ifc->wtopctl(sdev, cb);
        else
            error(Ebadctl);
        poperror();
        poperror();
        if (sdev)
            decref(&sdev->r);
        free(cb);
        break;

    case Qctl:
        cb = parsecmd(a, n);
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);
        unit = sdev->unit[UNIT(c->qid)];

        qlock(&unit->ctl);
        if(waserror()){
            qunlock(&unit->ctl);
            decref(&sdev->r);
            free(cb);
            nexterror();
        }
        if(unit->vers != c->qid.vers)
            error(Echange);

        if(cb->nf < 1)
            error(Ebadctl);
        if(strcmp(cb->f[0], "part") == 0){
            if(cb->nf != 4)
                error(Ebadctl);
            if(unit->sectors == 0 && !sdinitpart(unit))
                error(Eio);
            start = strtoull(cb->f[2], 0, 0);
            end = strtoull(cb->f[3], 0, 0);
            sdaddpart(unit, cb->f[1], start, end);
        }
        else if(strcmp(cb->f[0], "delpart") == 0){
            if(cb->nf != 2 || unit->part == nil)
                error(Ebadctl);
            sddelpart(unit, cb->f[1]);
        }
        else if(unit->dev->ifc->wctl)
            unit->dev->ifc->wctl(unit, cb);
        else
            error(Ebadctl);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        poperror();
        free(cb);
        break;

    case Qraw:
        sdev = sdgetdev(DEV(c->qid));
        if(sdev == nil)
            error(Enonexist);
        unit = sdev->unit[UNIT(c->qid)];
        qlock(&unit->raw);
        if(waserror()){
            qunlock(&unit->raw);
            decref(&sdev->r);
            nexterror();
        }
        switch(unit->state){
        case Rawcmd:
            if(n < 6 || n > sizeof(req->cmd))
                error(Ebadarg);
            if((req = malloc(sizeof(SDreq))) == nil)
                error(Enomem);
            req->unit = unit;
            memmove(req->cmd, a, n);
            req->clen = n;
            req->flags = SDnosense;
            req->status = ~0;

            unit->req = req;
            unit->state = Rawdata;
            break;

        case Rawstatus:
            unit->state = Rawcmd;
            free(unit->req);
            unit->req = nil;
            error(Ebadusefd);

        case Rawdata:
            unit->state = Rawstatus;
            unit->req->write = 1;
            n = sdrio(unit->req, a, n);
        }
        qunlock(&unit->raw);
        decref(&sdev->r);
        poperror();
        break;
    case Qpart:
        return sdbio(c, 1, a, n, off);
    }

    return n;
}

static int
sdwstat(Chan* c, uchar* dp, int n)
{
    Dir *d;
    SDpart *pp;
    SDperm *perm;
    SDunit *unit;
    SDev *sdev;

    if(c->qid.type & QTDIR)
        error(Eperm);

    sdev = sdgetdev(DEV(c->qid));
    if(sdev == nil)
        error(Enonexist);
    unit = sdev->unit[UNIT(c->qid)];
    qlock(&unit->ctl);
    d = nil;
    if(waserror()){
        free(d);
        qunlock(&unit->ctl);
        decref(&sdev->r);
        nexterror();
    }

    switch(TYPE(c->qid)){
    default:
        error(Eperm);
    case Qctl:
        perm = &unit->ctlperm;
        break;
    case Qraw:
        perm = &unit->rawperm;
        break;
    case Qpart:
        pp = &unit->part[PART(c->qid)];
        if(unit->vers+pp->vers != c->qid.vers)
            error(Enonexist);
        perm = &pp->SDperm;
        break;
    }

    if(strcmp(up->user, perm->user) && !iseve())
        error(Eperm);

    d = smalloc(sizeof(Dir)+n);
    n = convM2D(dp, n, &d[0], (char*)&d[1]);
    if(n == 0)
        error(Eshortstat);
    if(!emptystr(d[0].uid))
        kstrdup(&perm->user, d[0].uid);
    if(d[0].mode != ~0UL)
        perm->perm = (perm->perm & ~0777) | (d[0].mode & 0777);

    free(d);
    qunlock(&unit->ctl);
    decref(&sdev->r);
    poperror();
    return n;
}

static int
configure(char* spec, DevConf* cf)
{
    SDev *s, *sdev;
    char *p;
    int i;

    if(sdindex(*spec) < 0)
        error("bad sd spec");

    if((p = strchr(cf->type, '/')) != nil)
        *p++ = '\0';

    for(i = 0; sdifc[i] != nil; i++)
        if(strcmp(sdifc[i]->name, cf->type) == 0)
            break;
    if(sdifc[i] == nil)
        error("sd type not found");
    if(p)
        *(p-1) = '/';

    if(sdifc[i]->probe == nil)
        error("sd type cannot probe");

    sdev = sdifc[i]->probe(cf);
    for(s=sdev; s; s=s->next)
        s->idno = *spec;
    sdadddevs(sdev);
    return 0;
}

static int
unconfigure(char* spec)
{
    int i;
    SDev *sdev;
    SDunit *unit;

    if((i = sdindex(*spec)) < 0)
        error(Enonexist);

    qlock(&devslock);
    if((sdev = devs[i]) == nil){
        qunlock(&devslock);
        error(Enonexist);
    }
    if(sdev->r.ref){
        qunlock(&devslock);
        error(Einuse);
    }
    devs[i] = nil;
    qunlock(&devslock);

    /* make sure no interrupts arrive anymore before removing resources */
    if(sdev->enabled && sdev->ifc->disable)
        sdev->ifc->disable(sdev);

    for(i = 0; i != sdev->nunit; i++){
        if(unit = sdev->unit[i]){
            free(unit->name);
            free(unit->user);
            free(unit);
        }
    }

    if(sdev->ifc->clear)
        sdev->ifc->clear(sdev);
    free(sdev);
    return 0;
}

static int
sdconfig(int on, char* spec, DevConf* cf)
{
    if(on)
        return configure(spec, cf);
    return unconfigure(spec);
}

Dev sddevtab = {
    'S',
    "sd",

    sdreset,
    devinit,
    devshutdown,
    sdattach,
    sdwalk,
    sdstat,
    sdopen,
    devcreate,
    sdclose,
    sdread,
    devbread,
    sdwrite,
    devbwrite,
    devremove,
    sdwstat,
    devpower,
    sdconfig,   /* probe; only called for pcmcia-like devices */
};

/*
 * This is wrong for so many reasons.  This code must go.
 */
typedef struct Confdata Confdata;
struct Confdata {
    int on;
    char*   spec;
    DevConf cf;
};

static void
parseswitch(Confdata* cd, char* option)
{
    if(!strcmp("on", option))
        cd->on = 1;
    else if(!strcmp("off", option))
        cd->on = 0;
    else
        error(Ebadarg);
}

static void
parsespec(Confdata* cd, char* option)
{
    if(strlen(option) > 1)
        error(Ebadarg);
    cd->spec = option;
}

static Devport*
getnewport(DevConf* dc)
{
    Devport *p;

    p = (Devport *)malloc((dc->nports + 1) * sizeof(Devport));
    if(p == nil)
        error(Enomem);
    if(dc->nports > 0){
        memmove(p, dc->ports, dc->nports * sizeof(Devport));
        free(dc->ports);
    }
    dc->ports = p;
    p = &dc->ports[dc->nports++];
    p->size = -1;
    p->port = (ulong)-1;
    return p;
}

static void
parseport(Confdata* cd, char* option)
{
    char *e;
    Devport *p;

    if(cd->cf.nports == 0 || cd->cf.ports[cd->cf.nports-1].port != (ulong)-1)
        p = getnewport(&cd->cf);
    else
        p = &cd->cf.ports[cd->cf.nports-1];
    p->port = strtol(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parsesize(Confdata* cd, char* option)
{
    char *e;
    Devport *p;

    if(cd->cf.nports == 0 || cd->cf.ports[cd->cf.nports-1].size != -1)
        p = getnewport(&cd->cf);
    else
        p = &cd->cf.ports[cd->cf.nports-1];
    p->size = (int)strtol(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parseirq(Confdata* cd, char* option)
{
    char *e;

    cd->cf.intnum = strtoul(option, &e, 0);
    if(e == nil || *e != '\0')
        error(Ebadarg);
}

static void
parsetype(Confdata* cd, char* option)
{
    cd->cf.type = option;
}

static struct {
    char    *name;
    void    (*parse)(Confdata*, char*);
} options[] = {
    "switch",   parseswitch,
    "spec",     parsespec,
    "port",     parseport,
    "size",     parsesize,
    "irq",      parseirq,
    "type",     parsetype,
};

static void
legacytopctl(Cmdbuf *cb)
{
    char *opt;
    int i, j;
    Confdata cd;

    memset(&cd, 0, sizeof cd);
    cd.on = -1;
    for(i=0; i<cb->nf; i+=2){
        if(i+2 > cb->nf)
            error(Ebadarg);
        opt = cb->f[i];
        for(j=0; j<nelem(options); j++)
            if(strcmp(opt, options[j].name) == 0){
                options[j].parse(&cd, cb->f[i+1]);
                break;
            }
        if(j == nelem(options))
            error(Ebadarg);
    }
    /* this has been rewritten to accomodate sdaoe */
    if(cd.on < 0 || cd.spec == 0)
        error(Ebadarg);
    if(cd.on && cd.cf.type == nil)
        error(Ebadarg);
    sdconfig(cd.on, cd.spec, &cd.cf);
}
@


\subsection*{[[devices/storage/sd.h]]}

<<sd.h>>=
/*
 * Storage Device.
 */
typedef struct SDev SDev;
typedef struct SDifc SDifc;
typedef struct SDio SDio;
typedef struct SDpart SDpart;
typedef struct SDperm SDperm;
typedef struct SDreq SDreq;
typedef struct SDunit SDunit;

struct SDperm {
  char* name;
  char* user;
  ulong perm;
};

struct SDpart {
  uvlong  start;
  uvlong  end;
  SDperm;
  int valid;
  ulong vers;
};

struct SDunit {
  SDev* dev;
  int subno;
  uchar inquiry[255];   /* format follows SCSI spec */
  uchar sense[18];    /* format follows SCSI spec */
  SDperm;

  QLock ctl;
  uvlong  sectors;
  ulong secsize;
  SDpart* part;     /* nil or array of size npart */
  int npart;
  ulong vers;
  SDperm  ctlperm;

  QLock raw;      /* raw read or write in progress */
  ulong rawinuse;   /* really just a test-and-set */
  int state;
  SDreq*  req;
  SDperm  rawperm;
};

/*
 * Each controller is represented by a SDev.
 */
struct SDev {
  Ref r;      /* Number of callers using device */
  SDifc*  ifc;      /* pnp/legacy */
  void* ctlr;
  int idno;
  char  name[8];
  SDev* next;

  QLock;        /* enable/disable */
  int enabled;
  int nunit;      /* Number of units */
  QLock unitlock;   /* `Loading' of units */
  int*  unitflg;    /* Unit flags */
  SDunit**unit;
};

struct SDifc {
  char* name;

  SDev* (*pnp)(void);
  SDev* (*legacy)(int, int);
  int (*enable)(SDev*);
  int (*disable)(SDev*);

  int (*verify)(SDunit*);
  int (*online)(SDunit*);
  int (*rio)(SDreq*);
  int (*rctl)(SDunit*, char*, int);
  int (*wctl)(SDunit*, Cmdbuf*);

  long  (*bio)(SDunit*, int, int, void*, long, uvlong);
  SDev* (*probe)(DevConf*);
  void  (*clear)(SDev*);
  char* (*rtopctl)(SDev*, char*, char*);
  int (*wtopctl)(SDev*, Cmdbuf*);
};

struct SDreq {
  SDunit* unit;
  int lun;
  int write;
  uchar cmd[16];
  int clen;
  void* data;
  int dlen;

  int flags;

  int status;
  long  rlen;
  uchar sense[256];
};

enum {
  SDnosense = 0x00000001,
  SDvalidsense  = 0x00010000,

  SDinq0periphqual= 0xe0,
  SDinq0periphtype= 0x1f,
  SDinq1removable = 0x80,

  /* periphtype values */
  SDperdisk = 0,  /* Direct access (disk) */
  SDpertape = 1,  /* Sequential eg, tape */
  SDperpr   = 2,  /* Printer */
  SDperworm = 4,  /* Worm */
  SDpercd   = 5,  /* CD-ROM */
  SDpermo   = 7,  /* rewriteable MO */
  SDperjuke = 8,  /* medium-changer */
};

enum {
  SDretry   = -5,   /* internal to controllers */
  SDmalloc  = -4,
  SDeio   = -3,
  SDtimeout = -2,
  SDnostatus  = -1,

  SDok    = 0,

  SDcheck   = 0x02,   /* check condition */
  SDbusy    = 0x08,   /* busy */

  SDmaxio   = 2048*1024,
  SDnpart   = 16,
};

/*
 * Allow the default #defines for sdmalloc & sdfree to be overridden by
 * system-specific versions.  This can be used to avoid extra copying
 * by making sure sd buffers are cache-aligned (some ARM systems) or
 * page-aligned (xen) for DMA.
 */
#ifndef sdmalloc
#define sdmalloc(n) malloc(n)
#define sdfree(p) free(p)
#endif

/*
 * mmc/sd/sdio host controller interface
 */

//struct SDio {
//  char  *name;
//  int (*init)(void);
//  void  (*enable)(void);
//  int (*inquiry)(char*, int);
//  int (*cmd)(u32int, u32int, u32int*);
//  void  (*iosetup)(int, void*, int, int);
//  void  (*io)(int, uchar*, int);
//};
//
//extern SDio sdio;

/* devsd.c */
//extern void sdadddevs(SDev*);
//extern void sdaddconf(SDunit*);
//extern void sdaddallconfs(void (*f)(SDunit*));
//extern void sdaddpart(SDunit*, char*, uvlong, uvlong);
//extern int sdsetsense(SDreq*, int, int, int, int);
//extern int sdmodesense(SDreq*, uchar*, void*, int);
//extern int sdfakescsi(SDreq*, void*, int);

/* sdscsi.c */
extern int scsiverify(SDunit*);
extern int scsionline(SDunit*);
extern long scsibio(SDunit*, int, int, void*, long, uvlong);
//extern SDev* scsiid(SDev*, SDifc*);
@


\subsection*{[[devices/storage/sdscsi.c]]}

<<sdscsi.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"
#include "../port/error.h"

#include "../port/sd.h"

static int
scsitest(SDreq* r)
{
    r->write = 0;
    memset(r->cmd, 0, sizeof(r->cmd));
    r->cmd[1] = r->lun<<5;
    r->clen = 6;
    r->data = nil;
    r->dlen = 0;
    r->flags = 0;

    r->status = ~0;

    return r->unit->dev->ifc->rio(r);
}

int
scsiverify(SDunit* unit)
{
    SDreq *r;
    int i, status;
    uchar *inquiry;

    if((r = malloc(sizeof(SDreq))) == nil)
        return 0;
    if((inquiry = sdmalloc(sizeof(unit->inquiry))) == nil){
        free(r);
        return 0;
    }
    r->unit = unit;
    r->lun = 0;     /* ??? */

    memset(unit->inquiry, 0, sizeof(unit->inquiry));
    r->write = 0;
    r->cmd[0] = 0x12;
    r->cmd[1] = r->lun<<5;
    r->cmd[4] = sizeof(unit->inquiry)-1;
    r->clen = 6;
    r->data = inquiry;
    r->dlen = sizeof(unit->inquiry)-1;
    r->flags = 0;

    r->status = ~0;
    if(unit->dev->ifc->rio(r) != SDok){
        free(r);
        return 0;
    }
    memmove(unit->inquiry, inquiry, r->dlen);
    free(inquiry);

    SET(status);
    for(i = 0; i < 3; i++){
        while((status = scsitest(r)) == SDbusy)
            ;
        if(status == SDok || status != SDcheck)
            break;
        if(!(r->flags & SDvalidsense))
            break;
        if((r->sense[2] & 0x0F) != 0x02)
            continue;

        /*
         * Unit is 'not ready'.
         * If it is in the process of becoming ready or needs
         * an initialising command, set status so it will be spun-up
         * below.
         * If there's no medium, that's OK too, but don't
         * try to spin it up.
         */
        if(r->sense[12] == 0x04){
            if(r->sense[13] == 0x02 || r->sense[13] == 0x01){
                status = SDok;
                break;
            }
        }
        if(r->sense[12] == 0x3A)
            break;
    }

    if(status == SDok){
        /*
         * Try to ensure a direct-access device is spinning.
         * Don't wait for completion, ignore the result.
         */
        if((unit->inquiry[0] & SDinq0periphtype) == SDperdisk){
            memset(r->cmd, 0, sizeof(r->cmd));
            r->write = 0;
            r->cmd[0] = 0x1B;
            r->cmd[1] = (r->lun<<5)|0x01;
            r->cmd[4] = 1;
            r->clen = 6;
            r->data = nil;
            r->dlen = 0;
            r->flags = 0;

            r->status = ~0;
            unit->dev->ifc->rio(r);
        }
    }
    free(r);

    if(status == SDok || status == SDcheck)
        return 1;
    return 0;
}

static int
scsirio(SDreq* r)
{
    /*
     * Perform an I/O request, returning
     *  -1  failure
     *   0  ok
     *   1  no medium present
     *   2  retry
     * The contents of r may be altered so the
     * caller should re-initialise if necesary.
     */
    r->status = ~0;
    switch(r->unit->dev->ifc->rio(r)){
    default:
        break;
    case SDcheck:
        if(!(r->flags & SDvalidsense))
            break;
        switch(r->sense[2] & 0x0F){
        case 0x00:      /* no sense */
        case 0x01:      /* recovered error */
            return 2;
        case 0x06:      /* check condition */
            /*
             * 0x28 - not ready to ready transition,
             *    medium may have changed.
             * 0x29 - power on or some type of reset.
             */
            if(r->sense[12] == 0x28 && r->sense[13] == 0)
                return 2;
            if(r->sense[12] == 0x29)
                return 2;
            break;
        case 0x02:      /* not ready */
            /*
             * If no medium present, bail out.
             * If unit is becoming ready, rather than not
             * not ready, wait a little then poke it again.                  */
            if(r->sense[12] == 0x3A)
                break;
            if(r->sense[12] != 0x04 || r->sense[13] != 0x01)
                break;

            while(waserror())
                ;
            tsleep(&up->sleep, return0, 0, 500);
            poperror();
            scsitest(r);
            return 2;
        default:
            break;
        }
        break;
    case SDok:
        return 0;
    }
    return -1;
}

int
scsionline(SDunit* unit)
{
    SDreq *r;
    uchar *p;
    int ok, retries;

    if((r = malloc(sizeof(SDreq))) == nil)
        return 0;
    if((p = sdmalloc(8)) == nil){
        free(r);
        return 0;
    }

    ok = 0;

    r->unit = unit;
    r->lun = 0;             /* ??? */
    for(retries = 0; retries < 10; retries++){
        /*
         * Read-capacity is mandatory for DA, WORM, CD-ROM and
         * MO. It may return 'not ready' if type DA is not
         * spun up, type MO or type CD-ROM are not loaded or just
         * plain slow getting their act together after a reset.
         */
        r->write = 0;
        memset(r->cmd, 0, sizeof(r->cmd));
        r->cmd[0] = 0x25;
        r->cmd[1] = r->lun<<5;
        r->clen = 10;
        r->data = p;
        r->dlen = 8;
        r->flags = 0;

        r->status = ~0;
        switch(scsirio(r)){
        default:
            break;
        case 0:
            unit->sectors = (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
            unit->secsize = (p[4]<<24)|(p[5]<<16)|(p[6]<<8)|p[7];

            /*
             * Some ATAPI CD readers lie about the block size.
             * Since we don't read audio via this interface
             * it's okay to always fudge this.
             */
            if(unit->secsize == 2352)
                unit->secsize = 2048;
            /*
             * Devices with removable media may return 0 sectors
             * when they have empty media (e.g. sata dvd writers);
             * if so, keep the count zero.
             *
             * Read-capacity returns the LBA of the last sector,
             * therefore the number of sectors must be incremented.
             */
            if(unit->sectors != 0)
                unit->sectors++;
            ok = 1;
            break;
        case 1:
            ok = 1;
            break;
        case 2:
            continue;
        }
        break;
    }
    free(p);
    free(r);

    if(ok)
        return ok+retries;
    else
        return 0;
}

//int
//scsiexec(SDunit* unit, int write, uchar* cmd, int clen, void* data, int* dlen)
//{
//  SDreq *r;
//  int status;
//
//  if((r = malloc(sizeof(SDreq))) == nil)
//      return SDmalloc;
//  r->unit = unit;
//  r->lun = cmd[1]>>5;     /* ??? */
//  r->write = write;
//  memmove(r->cmd, cmd, clen);
//  r->clen = clen;
//  r->data = data;
//  if(dlen)
//      r->dlen = *dlen;
//  r->flags = 0;
//
//  r->status = ~0;
//
//  /*
//   * Call the device-specific I/O routine.
//   * There should be no calls to 'error()' below this
//   * which percolate back up.
//   */
//  switch(status = unit->dev->ifc->rio(r)){
//  case SDok:
//      if(dlen)
//          *dlen = r->rlen;
//      /*FALLTHROUGH*/
//  case SDcheck:
//      /*FALLTHROUGH*/
//  default:
//      /*
//       * It's more complicated than this. There are conditions
//       * which are 'ok' but for which the returned status code
//       * is not 'SDok'.
//       * Also, not all conditions require a reqsense, might
//       * need to do a reqsense here and make it available to the
//       * caller somehow.
//       *
//       * MaÃ±ana.
//       */
//      break;
//  }
//  sdfree(r);
//
//  return status;
//}

static void
scsifmt10(SDreq *r, int write, int lun, ulong nb, uvlong bno)
{
    uchar *c;

    c = r->cmd;
    if(write == 0)
        c[0] = 0x28;
    else
        c[0] = 0x2A;
    c[1] = lun<<5;
    c[2] = bno>>24;
    c[3] = bno>>16;
    c[4] = bno>>8;
    c[5] = bno;
    c[6] = 0;
    c[7] = nb>>8;
    c[8] = nb;
    c[9] = 0;

    r->clen = 10;
}

static void
scsifmt16(SDreq *r, int write, int lun, ulong nb, uvlong bno)
{
    uchar *c;

    c = r->cmd;
    if(write == 0)
        c[0] = 0x88;
    else
        c[0] = 0x8A;
    c[1] = lun<<5;      /* so wrong */
    c[2] = bno>>56;
    c[3] = bno>>48;
    c[4] = bno>>40;
    c[5] = bno>>32;
    c[6] = bno>>24;
    c[7] = bno>>16;
    c[8] = bno>>8;
    c[9] = bno;
    c[10] = nb>>24;
    c[11] = nb>>16;
    c[12] = nb>>8;
    c[13] = nb;
    c[14] = 0;
    c[15] = 0;

    r->clen = 16;
}

long
scsibio(SDunit* unit, int lun, int write, void* data, long nb, uvlong bno)
{
    SDreq *r;
    long rlen;

    if((r = malloc(sizeof(SDreq))) == nil)
        error(Enomem);
    r->unit = unit;
    r->lun = lun;
again:
    r->write = write;
    if(bno >= (1ULL<<32))
        scsifmt16(r, write, lun, nb, bno);
    else
        scsifmt10(r, write, lun, nb, bno);
    r->data = data;
    r->dlen = nb*unit->secsize;
    r->flags = 0;

    r->status = ~0;
    switch(scsirio(r)){
    default:
        rlen = -1;
        break;
    case 0:
        rlen = r->rlen;
        break;
    case 2:
        rlen = -1;
        if(!(r->flags & SDvalidsense))
            break;
        switch(r->sense[2] & 0x0F){
        default:
            break;
        case 0x01:      /* recovered error */
            print("%s: recovered error at sector %llud\n",
                unit->name, bno);
            rlen = r->rlen;
            break;
        case 0x06:      /* check condition */
            /*
             * Check for a removeable media change.
             * If so, mark it by zapping the geometry info
             * to force an online request.
             */
            if(r->sense[12] != 0x28 || r->sense[13] != 0)
                break;
            if(unit->inquiry[1] & SDinq1removable)
                unit->sectors = 0;
            break;
        case 0x02:      /* not ready */
            /*
             * If unit is becoming ready,
             * rather than not not ready, try again.
             */
            if(r->sense[12] == 0x04 && r->sense[13] == 0x01)
                goto again;
            break;
        }
        break;
    }
    free(r);

    return rlen;
}

@


\subsection*{[[devices/sys/386/devarch.c]]}

<<devarch.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"
#include "../port/error.h"

enum {
    Qdir = 0,
    Qioalloc = 1,
    Qiob,
    Qiow,
    Qiol,
    Qbase,

    Qmax = 16,
};

typedef long Rdwrfn(Chan*, void*, long, vlong);

static Rdwrfn *readfn[Qmax];
static Rdwrfn *writefn[Qmax];

static Dirtab archdir[Qmax] = {
    ".",        { Qdir, 0, QTDIR }, 0,  0555,
    "ioalloc",  { Qioalloc, 0 },    0,  0444,
    "iob",      { Qiob, 0 },        0,  0660,
    "iow",      { Qiow, 0 },        0,  0660,
    "iol",      { Qiol, 0 },        0,  0660,
};
Lock archwlock; /* the lock is only for changing archdir */
int narchdir = Qbase;

extern int doi8253set;

/*
 * Add a file to the #P listing.  Once added, you can't delete it.
 * You can't add a file with the same name as one already there,
 * and you get a pointer to the Dirtab entry so you can do things
 * like change the Qid version.  Changing the Qid path is disallowed.
 */
Dirtab*
addarchfile(char *name, int perm, Rdwrfn *rdfn, Rdwrfn *wrfn)
{
    int i;
    Dirtab d;
    Dirtab *dp;

    memset(&d, 0, sizeof d);
    strcpy(d.name, name);
    d.perm = perm;

    lock(&archwlock);
    if(narchdir >= Qmax){
        unlock(&archwlock);
        return nil;
    }

    for(i=0; i<narchdir; i++)
        if(strcmp(archdir[i].name, name) == 0){
            unlock(&archwlock);
            return nil;
        }

    d.qid.path = narchdir;
    archdir[narchdir] = d;
    readfn[narchdir] = rdfn;
    writefn[narchdir] = wrfn;
    dp = &archdir[narchdir++];
    unlock(&archwlock);

    return dp;
}

void devarch_hook_ioalloc() {
  archdir[0].qid.vers++;
}


int
iounused(int start, int end)
{
    IOMap *m;

    for(m = iomap.m; m; m = m->next){
        if(start >= m->start && start < m->end
        || start <= m->start && end > m->start)
            return 0;
    }
    return 1;
}

static void
checkport(int start, int end)
{
    /* standard vga regs are OK */
    if(start >= 0x2b0 && end <= 0x2df+1)
        return;
    if(start >= 0x3c0 && end <= 0x3da+1)
        return;

    if(iounused(start, end))
        return;
    error(Eperm);
}













static Chan*
archattach(char* spec)
{
    return devattach('P', spec);
}

Walkqid*
archwalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, archdir, narchdir, devgen);
}

static int
archstat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, archdir, narchdir, devgen);
}

static Chan*
archopen(Chan* c, int omode)
{
    return devopen(c, omode, archdir, narchdir, devgen);
}

static void
archclose(Chan*)
{
}

enum
{
    Linelen= 31,
};

static long
archread(Chan *c, void *a, long n, vlong offset)
{
    char *buf, *p;
    int port;
    ushort *sp;
    ulong *lp;
    IOMap *m;
    Rdwrfn *fn;

    switch((ulong)c->qid.path){

    case Qdir:
        return devdirread(c, a, n, archdir, narchdir, devgen);

    case Qiob:
        port = offset;
        checkport(offset, offset+n);
        for(p = a; port < offset+n; port++)
            *p++ = inb(port);
        return n;

    case Qiow:
        if(n & 1)
            error(Ebadarg);
        checkport(offset, offset+n);
        sp = a;
        for(port = offset; port < offset+n; port += 2)
            *sp++ = ins(port);
        return n;

    case Qiol:
        if(n & 3)
            error(Ebadarg);
        checkport(offset, offset+n);
        lp = a;
        for(port = offset; port < offset+n; port += 4)
            *lp++ = inl(port);
        return n;

    case Qioalloc:
        break;

    default:
        if(c->qid.path < narchdir && (fn = readfn[c->qid.path]))
            return fn(c, a, n, offset);
        error(Eperm);
        break;
    }

    if((buf = malloc(n)) == nil)
        error(Enomem);
    p = buf;
    n = n/Linelen;
    offset = offset/Linelen;

    lock(&iomap);
    for(m = iomap.m; n > 0 && m != nil; m = m->next){
        if(offset-- > 0)
            continue;
        seprint(p, &buf[n], "%8lux %8lux %-12.12s\n", m->start,
            m->end-1, m->tag);
        p += Linelen;
        n--;
    }
    unlock(&iomap);

    n = p - buf;
    memmove(a, buf, n);
    free(buf);

    return n;
}

static long
archwrite(Chan *c, void *a, long n, vlong offset)
{
    char *p;
    int port;
    ushort *sp;
    ulong *lp;
    Rdwrfn *fn;

    switch((ulong)c->qid.path){

    case Qiob:
        p = a;
        checkport(offset, offset+n);
        for(port = offset; port < offset+n; port++)
            outb(port, *p++);
        return n;

    case Qiow:
        if(n & 1)
            error(Ebadarg);
        checkport(offset, offset+n);
        sp = a;
        for(port = offset; port < offset+n; port += 2)
            outs(port, *sp++);
        return n;

    case Qiol:
        if(n & 3)
            error(Ebadarg);
        checkport(offset, offset+n);
        lp = a;
        for(port = offset; port < offset+n; port += 4)
            outl(port, *lp++);
        return n;

    default:
        if(c->qid.path < narchdir && (fn = writefn[c->qid.path]))
            return fn(c, a, n, offset);
        error(Eperm);
        break;
    }
    return 0;
}

Dev archdevtab = {
    'P',
    "arch",

    devreset,
    devinit,
    devshutdown,
    archattach,
    archwalk,
    archstat,
    archopen,
    devcreate,
    archclose,
    archread,
    devbread,
    archwrite,
    devbwrite,
    devremove,
    devwstat,
};

void
nop(void)
{
}

extern int cmpswap386(long *addr, long old, long new);

extern PCArch* knownarch[];





static long
cputyperead(Chan*, void *a, long n, vlong offset)
{
    char str[32];
    ulong mhz;

    mhz = (m->cpuhz+999999)/1000000;

    snprint(str, sizeof(str), "%s %lud\n", cputype->name, mhz);
    return readstr(offset, a, n, str);
}

static long
archctlread(Chan*, void *a, long nn, vlong offset)
{
    int n;
    char *buf, *p, *ep;

    p = buf = malloc(READSTR);
    if(p == nil)
        error(Enomem);
    ep = p + READSTR;
    p = seprint(p, ep, "cpu %s %lud%s\n",
        cputype->name, (ulong)(m->cpuhz+999999)/1000000,
        m->havepge ? " pge" : "");
    p = seprint(p, ep, "pge %s\n", getcr4()&0x80 ? "on" : "off");
    p = seprint(p, ep, "coherence ");
    if(coherence == mb386)
        p = seprint(p, ep, "mb386\n");
    else if(coherence == mb586)
        p = seprint(p, ep, "mb586\n");
    else if(coherence == mfence)
        p = seprint(p, ep, "mfence\n");
    else if(coherence == nop)
        p = seprint(p, ep, "nop\n");
    else
        p = seprint(p, ep, "0x%p\n", coherence);
    p = seprint(p, ep, "cmpswap ");
    if(cmpswap == cmpswap386)
        p = seprint(p, ep, "cmpswap386\n");
    else if(cmpswap == cmpswap486)
        p = seprint(p, ep, "cmpswap486\n");
    else
        p = seprint(p, ep, "0x%p\n", cmpswap);
    p = seprint(p, ep, "i8253set %s\n", doi8253set ? "on" : "off");
    n = p - buf;
    //n += mtrrprint(p, ep - p);
    buf[n] = '\0';

    n = readstr(offset, a, nn, buf);
    free(buf);
    return n;
}

enum
{
    CMpge,
    CMcoherence,
    CMi8253set,
    CMcache,
};

static Cmdtab archctlmsg[] =
{
    CMpge,      "pge",      2,
    CMcoherence,    "coherence",    2,
    CMi8253set, "i8253set", 2,
    CMcache,        "cache",        4,
};

static long
archctlwrite(Chan*, void *a, long n, vlong)
{
    uvlong base, size;
    Cmdbuf *cb;
    Cmdtab *ct;
    char *ep;

    cb = parsecmd(a, n);
    if(waserror()){
        free(cb);
        nexterror();
    }
    ct = lookupcmd(cb, archctlmsg, nelem(archctlmsg));
    switch(ct->index){
    case CMpge:
        if(!m->havepge)
            error("processor does not support pge");
        if(strcmp(cb->f[1], "on") == 0)
            putcr4(getcr4() | 0x80);
        else if(strcmp(cb->f[1], "off") == 0)
            putcr4(getcr4() & ~0x80);
        else
            cmderror(cb, "invalid pge ctl");
        break;
    case CMcoherence:
        if(strcmp(cb->f[1], "mb386") == 0)
            coherence = mb386;
        else if(strcmp(cb->f[1], "mb586") == 0){
            if(X86FAMILY(m->cpuidax) < 5)
                error("invalid coherence ctl on this cpu family");
            coherence = mb586;
        }else if(strcmp(cb->f[1], "mfence") == 0){
            if((m->cpuiddx & Sse2) == 0)
                error("invalid coherence ctl on this cpu family");
            coherence = mfence;
        }else if(strcmp(cb->f[1], "nop") == 0){
            /* only safe on vmware */
            if(conf.nmach > 1)
                error("cannot disable coherence on a multiprocessor");
            coherence = nop;
        }else
            cmderror(cb, "invalid coherence ctl");
        break;
    case CMi8253set:
        if(strcmp(cb->f[1], "on") == 0)
            doi8253set = 1;
        else if(strcmp(cb->f[1], "off") == 0){
            doi8253set = 0;
            (*arch->timerset)(0);
        }else
            cmderror(cb, "invalid i2853set ctl");
        break;
    case CMcache:
        base = strtoull(cb->f[1], &ep, 0);
        if(*ep)
            error("cache: parse error: base not a number?");
        size = strtoull(cb->f[2], &ep, 0);
        if(*ep)
            error("cache: parse error: size not a number?");
        //mtrr(base, size, cb->f[3]);
                error("mtrr: disabled");
        break;
    }
    free(cb);
    poperror();
    return n;
}

void
archinit(void)
{
    PCArch **p;

    arch = 0;
    for(p = knownarch; *p; p++){
        if((*p)->ident && (*p)->ident() == 0){
            arch = *p;
            break;
        }
    }
    if(arch == 0)
        arch = &archgeneric;
    else{
        if(arch->id == 0)
            arch->id = archgeneric.id;
        if(arch->reset == 0)
            arch->reset = archgeneric.reset;
        if(arch->serialpower == 0)
            arch->serialpower = archgeneric.serialpower;
        if(arch->modempower == 0)
            arch->modempower = archgeneric.modempower;
        if(arch->intrinit == 0)
            arch->intrinit = archgeneric.intrinit;
        if(arch->intrenable == 0)
            arch->intrenable = archgeneric.intrenable;
    }

    /*
     *  Decide whether to use copy-on-reference (386 and mp).
     *  We get another chance to set it in mpinit() for a
     *  multiprocessor.
     */
    if(X86FAMILY(m->cpuidax) == 3)
        conf.copymode = 1;

    if(X86FAMILY(m->cpuidax) >= 4)
        cmpswap = cmpswap486;

    if(X86FAMILY(m->cpuidax) >= 5)
        coherence = mb586;

    if(m->cpuiddx & Sse2)
        coherence = mfence;

    addarchfile("cputype", 0444, cputyperead, nil);
    addarchfile("archctl", 0664, archctlread, archctlwrite);
}
@


\subsection*{[[devices/sys/386/devrtc.c]]}

<<devrtc.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// see also the enum in dat_memory.h used by nvram.c and this file

enum {
    Seconds=    0x00,
    Minutes=    0x02,
    Hours=      0x04, 
    Mday=       0x07,
    Month=      0x08,
    Year=       0x09,
    Status=     0x0A,

    Nvoff=      128,    /* where usable nvram lives */
    Nvsize=     256,

    Nbcd=       6,
};



typedef struct Rtc  Rtc;
struct Rtc
{
    int sec;
    int min;
    int hour;
    int mday;
    int mon;
    int year;
};


enum{
    Qdir = 0,
    Qrtc,
    Qnvram,
};

Dirtab rtcdir[]={
    ".",    {Qdir, 0, QTDIR},   0,  0555,
    "nvram",    {Qnvram, 0},    Nvsize, 0664,
    "rtc",      {Qrtc, 0},  0,  0664,
};

static ulong rtc2sec(Rtc*);
static void sec2rtc(ulong, Rtc*);

void
rtcinit(void)
{
    if(ioalloc(Paddr, 2, 0, "rtc/nvr") < 0)
        panic("rtcinit: ioalloc failed");
}

static Chan*
rtcattach(char* spec)
{
    return devattach('r', spec);
}

static Walkqid*  
rtcwalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, rtcdir, nelem(rtcdir), devgen);
}

static int   
rtcstat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, rtcdir, nelem(rtcdir), devgen);
}

static Chan*
rtcopen(Chan* c, int omode)
{
    omode = openmode(omode);
    switch((ulong)c->qid.path){
    case Qrtc:
        if(strcmp(up->user, eve)!=0 && omode!=OREAD)
            error(Eperm);
        break;
    case Qnvram:
        if(strcmp(up->user, eve)!=0)
            error(Eperm);
    }
    return devopen(c, omode, rtcdir, nelem(rtcdir), devgen);
}

static void  
rtcclose(Chan*)
{
}

#define GETBCD(o) ((bcdclock[o]&0xf) + 10*(bcdclock[o]>>4))

static long  
_rtctime(void)
{
    uchar bcdclock[Nbcd];
    Rtc rtc;
    int i;

    /* don't do the read until the clock is no longer busy */
    for(i = 0; i < 10000; i++){
        outb(Paddr, Status);
        if(inb(PdataPort) & 0x80)
            continue;

        /* read clock values */
        outb(Paddr, Seconds);   bcdclock[0] = inb(PdataPort);
        outb(Paddr, Minutes);   bcdclock[1] = inb(PdataPort);
        outb(Paddr, Hours); bcdclock[2] = inb(PdataPort);
        outb(Paddr, Mday);  bcdclock[3] = inb(PdataPort);
        outb(Paddr, Month); bcdclock[4] = inb(PdataPort);
        outb(Paddr, Year);  bcdclock[5] = inb(PdataPort);

        outb(Paddr, Status);
        if((inb(PdataPort) & 0x80) == 0)
            break;
    }

    /*
     *  convert from BCD
     */
    rtc.sec = GETBCD(0);
    rtc.min = GETBCD(1);
    rtc.hour = GETBCD(2);
    rtc.mday = GETBCD(3);
    rtc.mon = GETBCD(4);
    rtc.year = GETBCD(5);

    /*
     *  the world starts jan 1 1970
     */
    if(rtc.year < 70)
        rtc.year += 2000;
    else
        rtc.year += 1900;
    return rtc2sec(&rtc);
}

// now in dat_memory.h and not static ...
//static Lock nvrtlock;

long
rtctime(void)
{
    int i;
    long t, ot;

    ilock(&nvrtlock);

    /* loop till we get two reads in a row the same */
    t = _rtctime();
    for(i = 0; i < 100; i++){
        ot = t;
        t = _rtctime();
        if(ot == t)
            break;
    }
    if(i == 100) print("we are boofheads\n");

    iunlock(&nvrtlock);

    return t;
}

static long  
rtcread(Chan* c, void* buf, long n, vlong off)
{
    ulong t;
    char *a, *start;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, buf, n, rtcdir, nelem(rtcdir), devgen);

    switch((ulong)c->qid.path){
    case Qrtc:
        t = rtctime();
        n = readnum(offset, buf, n, t, 12);
        return n;
    case Qnvram:
        if(n == 0)
            return 0;
        if(n > Nvsize)
            n = Nvsize;
        a = start = smalloc(n);

        ilock(&nvrtlock);
        for(t = offset; t < offset + n; t++){
            if(t >= Nvsize)
                break;
            outb(Paddr, Nvoff+t);
            *a++ = inb(PdataPort);
        }
        iunlock(&nvrtlock);

        if(waserror()){
            free(start);
            nexterror();
        }
        memmove(buf, start, t - offset);
        poperror();

        free(start);
        return t - offset;
    }
    error(Ebadarg);
    return 0;
}

#define PUTBCD(n,o) bcdclock[o] = (n % 10) | (((n / 10) % 10)<<4)

static long  
rtcwrite(Chan* c, void* buf, long n, vlong off)
{
    int t;
    char *a, *start;
    Rtc rtc;
    ulong secs;
    uchar bcdclock[Nbcd];
    char *cp, *ep;
    ulong offset = off;

    if(offset!=0)
        error(Ebadarg);


    switch((ulong)c->qid.path){
    case Qrtc:
        /*
         *  read the time
         */
        cp = ep = buf;
        ep += n;
        while(cp < ep){
            if(*cp>='0' && *cp<='9')
                break;
            cp++;
        }
        secs = strtoul(cp, 0, 0);
    
        /*
         *  convert to bcd
         */
        sec2rtc(secs, &rtc);
        PUTBCD(rtc.sec, 0);
        PUTBCD(rtc.min, 1);
        PUTBCD(rtc.hour, 2);
        PUTBCD(rtc.mday, 3);
        PUTBCD(rtc.mon, 4);
        PUTBCD(rtc.year, 5);

        /*
         *  write the clock
         */
        ilock(&nvrtlock);
        outb(Paddr, Seconds);   outb(PdataPort, bcdclock[0]);
        outb(Paddr, Minutes);   outb(PdataPort, bcdclock[1]);
        outb(Paddr, Hours); outb(PdataPort, bcdclock[2]);
        outb(Paddr, Mday);  outb(PdataPort, bcdclock[3]);
        outb(Paddr, Month); outb(PdataPort, bcdclock[4]);
        outb(Paddr, Year);  outb(PdataPort, bcdclock[5]);
        iunlock(&nvrtlock);
        return n;
    case Qnvram:
        if(n == 0)
            return 0;
        if(n > Nvsize)
            n = Nvsize;
    
        start = a = smalloc(n);
        if(waserror()){
            free(start);
            nexterror();
        }
        memmove(a, buf, n);
        poperror();

        ilock(&nvrtlock);
        for(t = offset; t < offset + n; t++){
            if(t >= Nvsize)
                break;
            outb(Paddr, Nvoff+t);
            outb(PdataPort, *a++);
        }
        iunlock(&nvrtlock);

        free(start);
        return t - offset;
    }
    error(Ebadarg);
    return 0;
}

Dev rtcdevtab = {
    'r',
    "rtc",

    devreset,
    rtcinit,
    devshutdown,
    rtcattach,
    rtcwalk,
    rtcstat,
    rtcopen,
    devcreate,
    rtcclose,
    rtcread,
    devbread,
    rtcwrite,
    devbwrite,
    devremove,
    devwstat,
};

#define SEC2MIN 60L
#define SEC2HOUR (60L*SEC2MIN)
#define SEC2DAY (24L*SEC2HOUR)

/*
 *  days per month plus days/year
 */
static  int dmsize[] =
{
    365, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};
static  int ldmsize[] =
{
    366, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

/*
 *  return the days/month for the given year
 */
static int*
yrsize(int y)
{
    if((y%4) == 0 && ((y%100) != 0 || (y%400) == 0))
        return ldmsize;
    else
        return dmsize;
}

/*
 *  compute seconds since Jan 1 1970
 */
static ulong
rtc2sec(Rtc *rtc)
{
    ulong secs;
    int i;
    int *d2m;

    secs = 0;

    /*
     *  seconds per year
     */
    for(i = 1970; i < rtc->year; i++){
        d2m = yrsize(i);
        secs += d2m[0] * SEC2DAY;
    }

    /*
     *  seconds per month
     */
    d2m = yrsize(rtc->year);
    for(i = 1; i < rtc->mon; i++)
        secs += d2m[i] * SEC2DAY;

    secs += (rtc->mday-1) * SEC2DAY;
    secs += rtc->hour * SEC2HOUR;
    secs += rtc->min * SEC2MIN;
    secs += rtc->sec;

    return secs;
}

/*
 *  compute rtc from seconds since Jan 1 1970
 */
static void
sec2rtc(ulong secs, Rtc *rtc)
{
    int d;
    long hms, day;
    int *d2m;

    /*
     * break initial number into days
     */
    hms = secs % SEC2DAY;
    day = secs / SEC2DAY;
    if(hms < 0) {
        hms += SEC2DAY;
        day -= 1;
    }

    /*
     * generate hours:minutes:seconds
     */
    rtc->sec = hms % 60;
    d = hms / 60;
    rtc->min = d % 60;
    d /= 60;
    rtc->hour = d;

    /*
     * year number
     */
    if(day >= 0)
        for(d = 1970; day >= *yrsize(d); d++)
            day -= *yrsize(d);
    else
        for (d = 1970; day < 0; d--)
            day += *yrsize(d-1);
    rtc->year = d;

    /*
     * generate month
     */
    d2m = yrsize(rtc->year);
    for(d = 1; day >= d2m[d]; d++)
        day -= d2m[d];
    rtc->mday = day + 1;
    rtc->mon = d;

    return;
}

@


\subsection*{[[devices/sys/devdup.c]]}

<<devdup.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

/* Qid is (2*fd + (file is ctl))+1 */

static int
dupgen(Chan *c, char *, Dirtab*, int, int s, Dir *dp)
{
    Fgrp *fgrp = up->fgrp;
    Chan *f;
    static int perm[] = { 0400, 0200, 0600, 0 };
    int p;
    Qid q;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, ".", 0, eve, DMDIR|0555, dp);
        return 1;
    }
    if(s == 0)
        return 0;
    s--;
    if(s/2 > fgrp->maxfd)
        return -1;
    if((f=fgrp->fd[s/2]) == nil)
        return 0;
    if(s & 1){
        p = 0400;
        snprint(up->genbuf, sizeof up->genbuf, "%dctl", s/2);
    }else{
        p = perm[f->mode&3];
        snprint(up->genbuf, sizeof up->genbuf, "%d", s/2);
    }
    mkqid(&q, s+1, 0, QTFILE);
    devdir(c, q, up->genbuf, 0, eve, p, dp);
    return 1;
}

static Chan*
dupattach(char *spec)
{
    return devattach('d', spec);
}

static Walkqid*
dupwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, (Dirtab *)0, 0, dupgen);
}

static int
dupstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, (Dirtab *)0, 0L, dupgen);
}

static Chan*
dupopen(Chan *c, int omode)
{
    Chan *f;
    int fd, twicefd;

    if(c->qid.type & QTDIR){
        if(omode != 0)
            error(Eisdir);
        c->mode = 0;
        c->flag |= COPEN;
        c->offset = 0;
        return c;
    }
    if(c->qid.type & QTAUTH)
        error(Eperm);
    twicefd = c->qid.path - 1;
    fd = twicefd/2;
    if((twicefd & 1)){
        /* ctl file */
        f = c;
        f->mode = openmode(omode);
        f->flag |= COPEN;
        f->offset = 0;
    }else{
        /* fd file */
        f = fdtochan(fd, openmode(omode), 0, 1);
        cclose(c);
    }
    if(omode & OCEXEC)
        f->flag |= CCEXEC;
    return f;
}

static void
dupclose(Chan*)
{
}

static long
dupread(Chan *c, void *va, long n, vlong offset)
{
    char *a = va;
    char buf[256];
    int fd, twicefd;

    if(c->qid.type == QTDIR)
        return devdirread(c, a, n, (Dirtab *)0, 0L, dupgen);
    twicefd = c->qid.path - 1;
    fd = twicefd/2;
    if(twicefd & 1){
        c = fdtochan(fd, -1, 0, 1);
        procfdprint(c, fd, 0, buf, sizeof buf);
        cclose(c);
        return readstr((ulong)offset, va, n, buf);
    }
    panic("dupread");
    return 0;
}

static long
dupwrite(Chan*, void*, long, vlong)
{
    error(Eperm);
    return 0;       /* not reached */
}

Dev dupdevtab = {
    'd',
    "dup",

    devreset,
    devinit,
    devshutdown,
    dupattach,
    dupwalk,
    dupstat,
    dupopen,
    devcreate,
    dupclose,
    dupread,
    devbread,
    dupwrite,
    devbwrite,
    devremove,
    devwstat,
};
@


\subsection*{[[devices/sys/devenv.c]]}

<<devenv.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

enum
{
    Maxenvsize = 16300,
};

static Egrp *envgrp(Chan *c);
static int  envwriteable(Chan *c);

static Egrp confegrp;   /* global environment group containing the kernel configuration */

static Evalue*
envlookup(Egrp *eg, char *name, ulong qidpath)
{
    Evalue *e;
    int i;

    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        if(e->qid.path == qidpath || (name && e->name[0]==name[0] && strcmp(e->name, name) == 0))
            return e;
    }
    return nil;
}

static int
envgen(Chan *c, char *name, Dirtab*, int, int s, Dir *dp)
{
    Egrp *eg;
    Evalue *e;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, "#e", 0, eve, DMDIR|0775, dp);
        return 1;
    }

    eg = envgrp(c);
    rlock(eg);
    e = 0;
    if(name)
        e = envlookup(eg, name, -1);
    else if(s < eg->nent)
        e = eg->ent[s];

    if(e == 0) {
        runlock(eg);
        return -1;
    }

    /* make sure name string continues to exist after we release lock */
    kstrcpy(up->genbuf, e->name, sizeof up->genbuf);
    devdir(c, e->qid, up->genbuf, e->len, eve, 0666, dp);
    runlock(eg);
    return 1;
}

static Chan*
envattach(char *spec)
{
    Chan *c;
    Egrp *egrp = nil;

    if(spec && *spec) {
        if(strcmp(spec, "c") == 0)
            egrp = &confegrp;
        if(egrp == nil)
            error(Ebadarg);
    }

    c = devattach('e', spec);
    c->aux = egrp;
    return c;
}

static Walkqid*
envwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, envgen);
}

static int
envstat(Chan *c, uchar *db, int n)
{
    if(c->qid.type & QTDIR)
        c->qid.vers = envgrp(c)->vers;
    return devstat(c, db, n, 0, 0, envgen);
}

static Chan*
envopen(Chan *c, int omode)
{
    Egrp *eg;
    Evalue *e;
    int trunc;

    eg = envgrp(c);
    if(c->qid.type & QTDIR) {
        if(omode != OREAD)
            error(Eperm);
    }
    else {
        trunc = omode & OTRUNC;
        if(omode != OREAD && !envwriteable(c))
            error(Eperm);
        if(trunc)
            wlock(eg);
        else
            rlock(eg);
        e = envlookup(eg, nil, c->qid.path);
        if(e == 0) {
            if(trunc)
                wunlock(eg);
            else
                runlock(eg);
            error(Enonexist);
        }
        if(trunc && e->value) {
            e->qid.vers++;
            free(e->value);
            e->value = 0;
            e->len = 0;
        }
        if(trunc)
            wunlock(eg);
        else
            runlock(eg);
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    return c;
}

static void
envcreate(Chan *c, char *name, int omode, ulong)
{
    Egrp *eg;
    Evalue *e;
    Evalue **ent;

    if(c->qid.type != QTDIR)
        error(Eperm);
    if(strlen(name) >= sizeof up->genbuf)
        error("name too long");         /* protect envgen */

    omode = openmode(omode);
    eg = envgrp(c);

    wlock(eg);
    if(waserror()) {
        wunlock(eg);
        nexterror();
    }

    if(envlookup(eg, name, -1))
        error(Eexist);

    e = smalloc(sizeof(Evalue));
    e->name = smalloc(strlen(name)+1);
    strcpy(e->name, name);

    if(eg->nent == eg->ment){
        eg->ment += 32;
        ent = smalloc(sizeof(eg->ent[0])*eg->ment);
        if(eg->nent)
            memmove(ent, eg->ent, sizeof(eg->ent[0])*eg->nent);
        free(eg->ent);
        eg->ent = ent;
    }
    e->qid.path = ++eg->path;
    e->qid.vers = 0;
    eg->vers++;
    eg->ent[eg->nent++] = e;
    c->qid = e->qid;

    wunlock(eg);
    poperror();

    c->offset = 0;
    c->mode = omode;
    c->flag |= COPEN;
}

static void
envremove(Chan *c)
{
    int i;
    Egrp *eg;
    Evalue *e;

    if(c->qid.type & QTDIR)
        error(Eperm);

    eg = envgrp(c);
    wlock(eg);
    e = 0;
    for(i=0; i<eg->nent; i++){
        if(eg->ent[i]->qid.path == c->qid.path){
            e = eg->ent[i];
            eg->nent--;
            eg->ent[i] = eg->ent[eg->nent];
            eg->vers++;
            break;
        }
    }
    wunlock(eg);
    if(e == 0)
        error(Enonexist);
    free(e->name);
    if(e->value)
        free(e->value);
    free(e);
}

static void
envclose(Chan *c)
{
    /*
     * cclose can't fail, so errors from remove will be ignored.
     * since permissions aren't checked,
     * envremove can't not remove it if its there.
     */
    if(c->flag & CRCLOSE)
        envremove(c);
}

static long
envread(Chan *c, void *a, long n, vlong off)
{
    Egrp *eg;
    Evalue *e;
    ulong offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, 0, 0, envgen);

    eg = envgrp(c);
    rlock(eg);
    e = envlookup(eg, nil, c->qid.path);
    if(e == 0) {
        runlock(eg);
        error(Enonexist);
    }

    if(offset > e->len) /* protects against overflow converting vlong to ulong */
        n = 0;
    else if(offset + n > e->len)
        n = e->len - offset;
    if(n <= 0)
        n = 0;
    else
        memmove(a, e->value+offset, n);
    runlock(eg);
    return n;
}

static long
envwrite(Chan *c, void *a, long n, vlong off)
{
    char *s;
    ulong len;
    Egrp *eg;
    Evalue *e;
    ulong offset = off;

    if(n <= 0)
        return 0;
    if(offset > Maxenvsize || n > (Maxenvsize - offset))
        error(Etoobig);

    eg = envgrp(c);
    wlock(eg);
    e = envlookup(eg, nil, c->qid.path);
    if(e == 0) {
        wunlock(eg);
        error(Enonexist);
    }

    len = offset+n;
    if(len > e->len) {
        s = smalloc(len);
        if(e->value){
            memmove(s, e->value, e->len);
            free(e->value);
        }
        e->value = s;
        e->len = len;
    }
    memmove(e->value+offset, a, n);
    e->qid.vers++;
    eg->vers++;
    wunlock(eg);
    return n;
}

Dev envdevtab = {
    'e',
    "env",

    devreset,
    devinit,
    devshutdown,
    envattach,
    envwalk,
    envstat,
    envopen,
    envcreate,
    envclose,
    envread,
    devbread,
    envwrite,
    devbwrite,
    envremove,
    devwstat,
};

void
envcpy(Egrp *to, Egrp *from)
{
    int i;
    Evalue *ne, *e;

    rlock(from);
    to->ment = (from->nent+31)&~31;
    to->ent = smalloc(to->ment*sizeof(to->ent[0]));
    for(i=0; i<from->nent; i++){
        e = from->ent[i];
        ne = smalloc(sizeof(Evalue));
        ne->name = smalloc(strlen(e->name)+1);
        strcpy(ne->name, e->name);
        if(e->value){
            ne->value = smalloc(e->len);
            memmove(ne->value, e->value, e->len);
            ne->len = e->len;
        }
        ne->qid.path = ++to->path;
        to->ent[i] = ne;
    }
    to->nent = from->nent;
    runlock(from);
}


static Egrp*
envgrp(Chan *c)
{
    if(c->aux == nil)
        return up->egrp;
    return c->aux;
}

static int
envwriteable(Chan *c)
{
    return iseve() || c->aux == nil;
}

/*
 *  to let the kernel set environment variables
 */
void
ksetenv(char *ename, char *eval, int conf)
{
    Chan *c;
    char buf[2*KNAMELEN];
    
    snprint(buf, sizeof(buf), "#e%s/%s", conf?"c":"", ename);
    c = namec(buf, Acreate, OWRITE, 0600);
    devtab[c->type]->write(c, eval, strlen(eval), 0);
    cclose(c);
}

/*
 * Return a copy of configuration environment as a sequence of strings.
 * The strings alternate between name and value.  A zero length name string
 * indicates the end of the list
 */
char *
getconfenv(void)
{
    Egrp *eg = &confegrp;
    Evalue *e;
    char *p, *q;
    int i, n;

    rlock(eg);
    if(waserror()) {
        runlock(eg);
        nexterror();
    }
    
    /* determine size */
    n = 0;
    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        n += strlen(e->name) + e->len + 2;
    }
    p = malloc(n + 1);
    if(p == nil)
        error(Enomem);
    q = p;
    for(i=0; i<eg->nent; i++){
        e = eg->ent[i];
        strcpy(q, e->name);
        q += strlen(q) + 1;
        memmove(q, e->value, e->len);
        q[e->len] = 0;
        /* move up to the first null */
        q += strlen(q) + 1;
    }
    *q = 0;
    
    poperror();
    runlock(eg);
    return p;
}
@


\subsection*{[[devices/sys/devmnt.c]]}

<<devmnt.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#define MAXRPC (IOHDRSZ+8192)


Mnt*    mntchk(Chan*);
void    mntdirfix(uchar*, Chan*);
Mntrpc* mntflushalloc(Mntrpc*, ulong);
void    mntflushfree(Mnt*, Mntrpc*);
void    mntgate(Mnt*);
void    mntqrm(Mnt*, Mntrpc*);
Mntrpc* mntralloc(Chan*, ulong);
long    mntrdwr(int, Chan*, void*, long, vlong);
int mntrpcread(Mnt*, Mntrpc*);
void    mountio(Mnt*, Mntrpc*);
void    mountmux(Mnt*, Mntrpc*);
void    mountrpc(Mnt*, Mntrpc*);
int rpcattn(void*);
Chan*   mntchan(void);


void (*mntstats)(int, Chan*, uvlong, ulong);

static void
mntreset(void)
{
    mntalloc.id = 1;
    mntalloc.tagmask[0] = 1;            /* don't allow 0 as a tag */
    mntalloc.tagmask[NMASK-1] = 0x80000000UL;   /* don't allow NOTAG */
    fmtinstall('F', fcallfmt);
    fmtinstall('D', dirfmt);
/* We can't install %M since eipfmt does and is used in the kernel [sape] */

    cinit();
}


Chan*
mntauth(Chan *c, char *spec)
{
    Mnt *m;
    Mntrpc *r;

    m = c->mux;

    if(m == nil){
        mntversion(c, VERSION9P, MAXRPC, 0);
        m = c->mux;
        if(m == nil)
            error(Enoversion);
    }

    c = mntchan();
    if(waserror()) {
        /* Close must not be called since it will
         * call mnt recursively
         */
        chanfree(c);
        nexterror();
    }

    r = mntralloc(0, m->msize);

    if(waserror()) {
        mntfree(r);
        nexterror();
    }

    r->request.type = Tauth;
    r->request.afid = c->fid;
    r->request.uname = up->user;
    r->request.aname = spec;
    mountrpc(m, r);

    c->qid = r->reply.aqid;
    c->mchan = m->c;
    incref(m->c);
    c->mqid = c->qid;
    c->mode = ORDWR;

    poperror(); /* r */
    mntfree(r);

    poperror(); /* c */

    return c;

}

static Chan*
mntattach(char *muxattach)
{
    Mnt *m;
    Chan *c;
    Mntrpc *r;
    struct bogus{
        Chan    *chan;
        Chan    *authchan;
        char    *spec;
        int flags;
    }bogus;

    bogus = *((struct bogus *)muxattach);
    c = bogus.chan;

    m = c->mux;

    if(m == nil){
        mntversion(c, nil, 0, 0);
        m = c->mux;
        if(m == nil)
            error(Enoversion);
    }

    c = mntchan();
    if(waserror()) {
        /* Close must not be called since it will
         * call mnt recursively
         */
        chanfree(c);
        nexterror();
    }

    r = mntralloc(0, m->msize);

    if(waserror()) {
        mntfree(r);
        nexterror();
    }

    r->request.type = Tattach;
    r->request.fid = c->fid;
    if(bogus.authchan == nil)
        r->request.afid = NOFID;
    else
        r->request.afid = bogus.authchan->fid;
    r->request.uname = up->user;
    r->request.aname = bogus.spec;
    mountrpc(m, r);

    c->qid = r->reply.qid;
    c->mchan = m->c;
    incref(m->c);
    c->mqid = c->qid;

    poperror(); /* r */
    mntfree(r);

    poperror(); /* c */

    if(bogus.flags&MCACHE)
        c->flag |= CCACHE;
    return c;
}

Chan*
mntchan(void)
{
    Chan *c;

    c = devattach('M', 0);
    lock(&mntalloc);
    c->dev = mntalloc.id++;
    unlock(&mntalloc);

    if(c->mchan)
        panic("mntchan non-zero %p", c->mchan);
    return c;
}

static Walkqid*
mntwalk(Chan *c, Chan *nc, char **name, int nname)
{
    int i, alloc;
    Mnt *m;
    Mntrpc *r;
    Walkqid *wq;

    if(nc != nil)
        print("mntwalk: nc != nil\n");
    if(nname > MAXWELEM)
        error("devmnt: too many name elements");
    alloc = 0;
    wq = smalloc(sizeof(Walkqid)+(nname-1)*sizeof(Qid));
    if(waserror()){
        if(alloc && wq->clone!=nil)
            cclose(wq->clone);
        free(wq);
        return nil;
    }

    alloc = 0;
    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(nc == nil){
        nc = devclone(c);
        /*
         * Until the other side accepts this fid, we can't mntclose it.
         * Therefore set type to 0 for now; rootclose is known to be safe.
         */
        nc->type = 0;
        alloc = 1;
    }
    wq->clone = nc;
    nc->flag |= c->flag&CCACHE;

    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Twalk;
    r->request.fid = c->fid;
    r->request.newfid = nc->fid;
    r->request.nwname = nname;
    memmove(r->request.wname, name, nname*sizeof(char*));

    mountrpc(m, r);

    if(r->reply.nwqid > nname)
        error("too many QIDs returned by walk");
    if(r->reply.nwqid < nname){
        if(alloc)
            cclose(nc);
        wq->clone = nil;
        if(r->reply.nwqid == 0){
            free(wq);
            wq = nil;
            goto Return;
        }
    }

    /* move new fid onto mnt device and update its qid */
    if(wq->clone != nil){
        if(wq->clone != c){
            wq->clone->type = c->type;
            wq->clone->mchan = c->mchan;
            incref(c->mchan);
        }
        if(r->reply.nwqid > 0)
            wq->clone->qid = r->reply.wqid[r->reply.nwqid-1];
    }
    wq->nqid = r->reply.nwqid;
    for(i=0; i<wq->nqid; i++)
        wq->qid[i] = r->reply.wqid[i];

    Return:
    poperror();
    mntfree(r);
    poperror();
    return wq;
}

static int
mntstat(Chan *c, uchar *dp, int n)
{
    Mnt *m;
    Mntrpc *r;

    if(n < BIT16SZ)
        error(Eshortstat);
    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Tstat;
    r->request.fid = c->fid;
    mountrpc(m, r);

    if(r->reply.nstat > n){
        n = BIT16SZ;
        PBIT16((uchar*)dp, r->reply.nstat-2);
    }else{
        n = r->reply.nstat;
        memmove(dp, r->reply.stat, n);
        validstat(dp, n);
        mntdirfix(dp, c);
    }
    poperror();
    mntfree(r);
    return n;
}

static Chan*
mntopencreate(int type, Chan *c, char *name, int omode, ulong perm)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = type;
    r->request.fid = c->fid;
    r->request.mode = omode;
    if(type == Tcreate){
        r->request.perm = perm;
        r->request.name = name;
    }
    mountrpc(m, r);

    c->qid = r->reply.qid;
    c->offset = 0;
    c->mode = openmode(omode);
    c->iounit = r->reply.iounit;
    if(c->iounit == 0 || c->iounit > m->msize-IOHDRSZ)
        c->iounit = m->msize-IOHDRSZ;
    c->flag |= COPEN;
    poperror();
    mntfree(r);

    if(c->flag & CCACHE)
        copen(c);

    return c;
}

static Chan*
mntopen(Chan *c, int omode)
{
    return mntopencreate(Topen, c, nil, omode, 0);
}

static void
mntcreate(Chan *c, char *name, int omode, ulong perm)
{
    mntopencreate(Tcreate, c, name, omode, perm);
}

static void
mntclunk(Chan *c, int t)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()){
        mntfree(r);
        nexterror();
    }

    r->request.type = t;
    r->request.fid = c->fid;
    mountrpc(m, r);
    mntfree(r);
    poperror();
}



static void
mntclose(Chan *c)
{
    mntclunk(c, Tclunk);
}

static void
mntremove(Chan *c)
{
    mntclunk(c, Tremove);
}

static int
mntwstat(Chan *c, uchar *dp, int n)
{
    Mnt *m;
    Mntrpc *r;

    m = mntchk(c);
    r = mntralloc(c, m->msize);
    if(waserror()) {
        mntfree(r);
        nexterror();
    }
    r->request.type = Twstat;
    r->request.fid = c->fid;
    r->request.nstat = n;
    r->request.stat = dp;
    mountrpc(m, r);
    poperror();
    mntfree(r);
    return n;
}

static long
mntread(Chan *c, void *buf, long n, vlong off)
{
    uchar *p, *e;
    int nc, cache, isdir, dirlen;

    isdir = 0;
    cache = c->flag & CCACHE;
    if(c->qid.type & QTDIR) {
        cache = 0;
        isdir = 1;
    }

    p = buf;
    if(cache) {
        nc = cread(c, buf, n, off);
        if(nc > 0) {
            n -= nc;
            if(n == 0)
                return nc;
            p += nc;
            off += nc;
        }
        n = mntrdwr(Tread, c, p, n, off);
        cupdate(c, p, n, off);
        return n + nc;
    }

    n = mntrdwr(Tread, c, buf, n, off);
    if(isdir) {
        for(e = &p[n]; p+BIT16SZ < e; p += dirlen){
            dirlen = BIT16SZ+GBIT16(p);
            if(p+dirlen > e)
                break;
            validstat(p, dirlen);
            mntdirfix(p, c);
        }
        if(p != e)
            error(Esbadstat);
    }
    return n;
}

static long
mntwrite(Chan *c, void *buf, long n, vlong off)
{
    return mntrdwr(Twrite, c, buf, n, off);
}

long
mntrdwr(int type, Chan *c, void *buf, long n, vlong off)
{
    Mnt *m;
    Mntrpc *r;
    char *uba;
    int cache;
    ulong cnt, nr, nreq;

    m = mntchk(c);
    uba = buf;
    cnt = 0;
    cache = c->flag & CCACHE;
    if(c->qid.type & QTDIR)
        cache = 0;
    for(;;) {
        r = mntralloc(c, m->msize);
        if(waserror()) {
            mntfree(r);
            nexterror();
        }
        r->request.type = type;
        r->request.fid = c->fid;
        r->request.offset = off;
        r->request.data = uba;
        nr = n;
        if(nr > m->msize-IOHDRSZ)
            nr = m->msize-IOHDRSZ;
        r->request.count = nr;
        mountrpc(m, r);
        nreq = r->request.count;
        nr = r->reply.count;
        if(nr > nreq)
            nr = nreq;

        if(type == Tread)
            r->b = bl2mem((uchar*)uba, r->b, nr);
        else if(cache)
            cwrite(c, (uchar*)uba, nr, off);

        poperror();
        mntfree(r);
        off += nr;
        uba += nr;
        cnt += nr;
        n -= nr;
        if(nr != nreq || n == 0 || up->nnote)
            break;
    }
    return cnt;
}

void
mountrpc(Mnt *m, Mntrpc *r)
{
    char *sn, *cn;
    int t;

    r->reply.tag = 0;
    r->reply.type = Tmax;   /* can't ever be a valid message type */

    mountio(m, r);

    t = r->reply.type;
    switch(t) {
    case Rerror:
        error(r->reply.ename);
    case Rflush:
        error(Eintr);
    default:
        if(t == r->request.type+1)
            break;
        sn = "?";
        if(m->c->path != nil)
            sn = m->c->path->s;
        cn = "?";
        if(r->c != nil && r->c->path != nil)
            cn = r->c->path->s;
        print("mnt: proc %s %lud: mismatch from %s %s rep %#p tag %d fid %d T%d R%d rp %d\n",
            up->text, up->pid, sn, cn,
            r, r->request.tag, r->request.fid, r->request.type,
            r->reply.type, r->reply.tag);
        error(Emountrpc);
    }
}

void
mountio(Mnt *m, Mntrpc *r)
{
    int n;

    while(waserror()) {
        if(m->rip == up)
            mntgate(m);
        if(strcmp(up->errstr, Eintr) != 0){
            mntflushfree(m, r);
            nexterror();
        }
        r = mntflushalloc(r, m->msize);
    }

    lock(m);
    r->m = m;
    r->list = m->queue;
    m->queue = r;
    unlock(m);

    /* Transmit a file system rpc */
    if(m->msize == 0)
        panic("msize");
    n = convS2M(&r->request, r->rpc, m->msize);
    if(n < 0)
        panic("bad message type in mountio");
    if(devtab[m->c->type]->write(m->c, r->rpc, n, 0) != n)
        error(Emountrpc);
    r->stime = fastticks(nil);
    r->reqlen = n;

    /* Gate readers onto the mount point one at a time */
    for(;;) {
        lock(m);
        if(m->rip == 0)
            break;
        unlock(m);
        sleep(&r->r, rpcattn, r);
        if(r->done){
            poperror();
            mntflushfree(m, r);
            return;
        }
    }
    m->rip = up;
    unlock(m);
    while(r->done == 0) {
        if(mntrpcread(m, r) < 0)
            error(Emountrpc);
        mountmux(m, r);
    }
    mntgate(m);
    poperror();
    mntflushfree(m, r);
}

static int
doread(Mnt *m, int len)
{
    Block *b;

    while(qlen(m->q) < len){
        b = devtab[m->c->type]->bread(m->c, m->msize, 0);
        if(b == nil)
            return -1;
        if(blocklen(b) == 0){
            freeblist(b);
            return -1;
        }
        qaddlist(m->q, b);
    }
    return 0;
}

int
mntrpcread(Mnt *m, Mntrpc *r)
{
    int i, t, len, hlen;
    Block *b, **l, *nb;

    r->reply.type = 0;
    r->reply.tag = 0;

    /* read at least length, type, and tag and pullup to a single block */
    if(doread(m, BIT32SZ+BIT8SZ+BIT16SZ) < 0)
        return -1;
    nb = pullupqueue(m->q, BIT32SZ+BIT8SZ+BIT16SZ);

    /* read in the rest of the message, avoid ridiculous (for now) message sizes */
    len = GBIT32(nb->rp);
    if(len > m->msize){
        qdiscard(m->q, qlen(m->q));
        return -1;
    }
    if(doread(m, len) < 0)
        return -1;

    /* pullup the header (i.e. everything except data) */
    t = nb->rp[BIT32SZ];
    switch(t){
    case Rread:
        hlen = BIT32SZ+BIT8SZ+BIT16SZ+BIT32SZ;
        break;
    default:
        hlen = len;
        break;
    }
    nb = pullupqueue(m->q, hlen);

    if(convM2S(nb->rp, len, &r->reply) <= 0){
        /* bad message, dump it */
        print("mntrpcread: convM2S failed\n");
        qdiscard(m->q, len);
        return -1;
    }

    /* hang the data off of the fcall struct */
    l = &r->b;
    *l = nil;
    do {
        b = qremove(m->q);
        if(hlen > 0){
            b->rp += hlen;
            len -= hlen;
            hlen = 0;
        }
        i = BLEN(b);
        if(i <= len){
            len -= i;
            *l = b;
            l = &(b->next);
        } else {
            /* split block and put unused bit back */
            nb = allocb(i-len);
            memmove(nb->wp, b->rp+len, i-len);
            b->wp = b->rp+len;
            nb->wp += i-len;
            qputback(m->q, nb);
            *l = b;
            return 0;
        }
    }while(len > 0);

    return 0;
}

void
mntgate(Mnt *m)
{
    Mntrpc *q;

    lock(m);
    m->rip = 0;
    for(q = m->queue; q; q = q->list) {
        if(q->done == 0)
        if(wakeup(&q->r))
            break;
    }
    unlock(m);
}

void
mountmux(Mnt *m, Mntrpc *r)
{
    Mntrpc **l, *q;

    lock(m);
    l = &m->queue;
    for(q = *l; q; q = q->list) {
        /* look for a reply to a message */
        if(q->request.tag == r->reply.tag) {
            *l = q->list;
            if(q != r) {
                /*
                 * Completed someone else.
                 * Trade pointers to receive buffer.
                 */
                q->reply = r->reply;
                q->b = r->b;
                r->b = nil;
            }
            q->done = 1;
            unlock(m);
            if(mntstats != nil)
                (*mntstats)(q->request.type,
                    m->c, q->stime,
                    q->reqlen + r->replen);
            if(q != r)
                wakeup(&q->r);
            return;
        }
        l = &q->list;
    }
    unlock(m);
    print("unexpected reply tag %ud; type %d\n", r->reply.tag, r->reply.type);
}

/*
 * Create a new flush request and chain the previous
 * requests from it
 */
Mntrpc*
mntflushalloc(Mntrpc *r, ulong iounit)
{
    Mntrpc *fr;

    fr = mntralloc(0, iounit);

    fr->request.type = Tflush;
    if(r->request.type == Tflush)
        fr->request.oldtag = r->request.oldtag;
    else
        fr->request.oldtag = r->request.tag;
    fr->flushed = r;

    return fr;
}

/*
 *  Free a chain of flushes.  Remove each unanswered
 *  flush and the original message from the unanswered
 *  request queue.  Mark the original message as done
 *  and if it hasn't been answered set the reply to to
 *  Rflush.
 */
void
mntflushfree(Mnt *m, Mntrpc *r)
{
    Mntrpc *fr;

    while(r){
        fr = r->flushed;
        if(!r->done){
            r->reply.type = Rflush;
            mntqrm(m, r);
        }
        if(fr)
            mntfree(r);
        r = fr;
    }
}

int
alloctag(void)
{
    int i, j;
    ulong v;

    for(i = 0; i < NMASK; i++){
        v = mntalloc.tagmask[i];
        if(v == ~0UL)
            continue;
        for(j = 0; j < 1<<TAGSHIFT; j++)
            if((v & (1<<j)) == 0){
                mntalloc.tagmask[i] |= 1<<j;
                return (i<<TAGSHIFT) + j;
            }
    }
    panic("no friggin tags left");
    return NOTAG;
}


Mntrpc*
mntralloc(Chan *c, ulong msize)
{
    Mntrpc *new;

    lock(&mntalloc);
    new = mntalloc.rpcfree;
    if(new == nil){
        new = malloc(sizeof(Mntrpc));
        if(new == nil) {
            unlock(&mntalloc);
            exhausted("mount rpc header");
        }
        /*
         * The header is split from the data buffer as
         * mountmux may swap the buffer with another header.
         */
        new->rpc = mallocz(msize, 0);
        if(new->rpc == nil){
            free(new);
            unlock(&mntalloc);
            exhausted("mount rpc buffer");
        }
        new->rpclen = msize;
        new->request.tag = alloctag();
    }
    else {
        mntalloc.rpcfree = new->list;
        mntalloc.nrpcfree--;
        if(new->rpclen < msize){
            free(new->rpc);
            new->rpc = mallocz(msize, 0);
            if(new->rpc == nil){
                free(new);
                mntalloc.nrpcused--;
                unlock(&mntalloc);
                exhausted("mount rpc buffer");
            }
            new->rpclen = msize;
        }
    }
    mntalloc.nrpcused++;
    unlock(&mntalloc);
    new->c = c;
    new->done = 0;
    new->flushed = nil;
    new->b = nil;
    return new;
}


void
mntqrm(Mnt *m, Mntrpc *r)
{
    Mntrpc **l, *f;

    lock(m);
    r->done = 1;

    l = &m->queue;
    for(f = *l; f; f = f->list) {
        if(f == r) {
            *l = r->list;
            break;
        }
        l = &f->list;
    }
    unlock(m);
}

Mnt*
mntchk(Chan *c)
{
    Mnt *m;

    /* This routine is mostly vestiges of prior lives; now it's just sanity checking */

    if(c->mchan == nil)
        panic("mntchk 1: nil mchan c %s\n", chanpath(c));

    m = c->mchan->mux;

    if(m == nil)
        print("mntchk 2: nil mux c %s c->mchan %s \n", chanpath(c), chanpath(c->mchan));

    /*
     * Was it closed and reused (was error(Eshutdown); now, it cannot happen)
     */
    if(m->id == 0 || m->id >= c->dev)
        panic("mntchk 3: can't happen");

    return m;
}

/*
 * Rewrite channel type and dev for in-flight data to
 * reflect local values.  These entries are known to be
 * the first two in the Dir encoding after the count.
 */
void
mntdirfix(uchar *dirbuf, Chan *c)
{
    uint r;

    r = devtab[c->type]->dc;
    dirbuf += BIT16SZ;  /* skip count */
    PBIT16(dirbuf, r);
    dirbuf += BIT16SZ;
    PBIT32(dirbuf, c->dev);
}

int
rpcattn(void *v)
{
    Mntrpc *r;

    r = v;
    return r->done || r->m->rip == 0;
}

Dev mntdevtab = {
    'M',
    "mnt",

    mntreset,
    devinit,
    devshutdown,
    mntattach,
    mntwalk,
    mntstat,
    mntopen,
    mntcreate,
    mntclose,
    mntread,
    devbread,
    mntwrite,
    devbwrite,
    mntremove,
    mntwstat,
};
@


\subsection*{[[devices/sys/devpipe.c]]}

<<devpipe.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    "netif.h"

typedef struct Pipe Pipe;
struct Pipe
{
    QLock;
    Pipe    *next;
    int ref;
    ulong   path;
    long    perm;
    Queue   *q[2];
    int qref[2];
};

struct
{
    Lock;
    ulong   path;
} pipealloc;

enum
{
    Qdir,
    Qdata0,
    Qdata1,
};

Dirtab pipedir[] =
{
    ".",        {Qdir,0,QTDIR}, 0,      DMDIR|0500,
    "data",     {Qdata0},   0,      0600,
    "data1",    {Qdata1},   0,      0600,
};
#define NPIPEDIR 3

static void
pipeinit(void)
{
    if(conf.pipeqsize == 0){
        if(conf.nmach > 1)
            conf.pipeqsize = 256*1024;
        else
            conf.pipeqsize = 32*1024;
    }
}

/*
 *  create a pipe, no streams are created until an open
 */
static Chan*
pipeattach(char *spec)
{
    Pipe *p;
    Chan *c;

    c = devattach('|', spec);
    p = malloc(sizeof(Pipe));
    if(p == 0)
        exhausted("memory");
    p->ref = 1;

    p->q[0] = qopen(conf.pipeqsize, 0, 0, 0);
    if(p->q[0] == 0){
        free(p);
        exhausted("memory");
    }
    p->q[1] = qopen(conf.pipeqsize, 0, 0, 0);
    if(p->q[1] == 0){
        free(p->q[0]);
        free(p);
        exhausted("memory");
    }

    lock(&pipealloc);
    p->path = ++pipealloc.path;
    unlock(&pipealloc);
    p->perm = pipedir[Qdata0].perm;

    mkqid(&c->qid, NETQID(2*p->path, Qdir), 0, QTDIR);
    c->aux = p;
    c->dev = 0;
    return c;
}

static int
pipegen(Chan *c, char*, Dirtab *tab, int ntab, int i, Dir *dp)
{
    Qid q;
    int len;
    Pipe *p;

    if(i == DEVDOTDOT){
        devdir(c, c->qid, "#|", 0, eve, DMDIR|0555, dp);
        return 1;
    }
    i++;    /* skip . */
    if(tab==0 || i>=ntab)
        return -1;

    tab += i;
    p = c->aux;
    switch((ulong)tab->qid.path){
    case Qdata0:
        len = qlen(p->q[0]);
        break;
    case Qdata1:
        len = qlen(p->q[1]);
        break;
    default:
        len = tab->length;
        break;
    }
    mkqid(&q, NETQID(NETID(c->qid.path), tab->qid.path), 0, QTFILE);
    devdir(c, q, tab->name, len, eve, p->perm, dp);
    return 1;
}


static Walkqid*
pipewalk(Chan *c, Chan *nc, char **name, int nname)
{
    Walkqid *wq;
    Pipe *p;

    wq = devwalk(c, nc, name, nname, pipedir, NPIPEDIR, pipegen);
    if(wq != nil && wq->clone != nil && wq->clone != c){
        p = c->aux;
        qlock(p);
        p->ref++;
        if(c->flag & COPEN){
            print("channel open in pipewalk\n");
            switch(NETTYPE(c->qid.path)){
            case Qdata0:
                p->qref[0]++;
                break;
            case Qdata1:
                p->qref[1]++;
                break;
            }
        }
        qunlock(p);
    }
    return wq;
}

static int
pipestat(Chan *c, uchar *db, int n)
{
    Pipe *p;
    Dir dir;

    p = c->aux;

    switch(NETTYPE(c->qid.path)){
    case Qdir:
        devdir(c, c->qid, ".", 0, eve, DMDIR|0555, &dir);
        break;
    case Qdata0:
        devdir(c, c->qid, "data", qlen(p->q[0]), eve, p->perm, &dir);
        break;
    case Qdata1:
        devdir(c, c->qid, "data1", qlen(p->q[1]), eve, p->perm, &dir);
        break;
    default:
        panic("pipestat");
    }
    n = convD2M(&dir, db, n);
    if(n < BIT16SZ)
        error(Eshortstat);
    return n;
}

static int
pipewstat(Chan* c, uchar* db, int n)
{
    int m;
    Dir *dir;
    Pipe *p;

    p = c->aux;
    if(strcmp(up->user, eve) != 0)
        error(Eperm);
    if(NETTYPE(c->qid.path) == Qdir)
        error(Eisdir);

    dir = smalloc(sizeof(Dir)+n);
    if(waserror()){
        free(dir);
        nexterror();
    }
    m = convM2D(db, n, &dir[0], (char*)&dir[1]);
    if(m == 0)
        error(Eshortstat);
    if(!emptystr(dir[0].uid))
        error("can't change owner");
    if(dir[0].mode != ~0UL)
        p->perm = dir[0].mode;
    poperror();
    free(dir);
    return m;
}

/*
 *  if the stream doesn't exist, create it
 */
static Chan*
pipeopen(Chan *c, int omode)
{
    Pipe *p;

    if(c->qid.type & QTDIR){
        if(omode != OREAD)
            error(Ebadarg);
        c->mode = omode;
        c->flag |= COPEN;
        c->offset = 0;
        return c;
    }

    p = c->aux;
    qlock(p);
    switch(NETTYPE(c->qid.path)){
    case Qdata0:
        p->qref[0]++;
        break;
    case Qdata1:
        p->qref[1]++;
        break;
    }
    qunlock(p);

    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    c->iounit = qiomaxatomic;
    return c;
}

static void
pipeclose(Chan *c)
{
    Pipe *p;

    p = c->aux;
    qlock(p);

    if(c->flag & COPEN){
        /*
         *  closing either side hangs up the stream
         */
        switch(NETTYPE(c->qid.path)){
        case Qdata0:
            p->qref[0]--;
            if(p->qref[0] == 0){
                qhangup(p->q[1], 0);
                qclose(p->q[0]);
            }
            break;
        case Qdata1:
            p->qref[1]--;
            if(p->qref[1] == 0){
                qhangup(p->q[0], 0);
                qclose(p->q[1]);
            }
            break;
        }
    }


    /*
     *  if both sides are closed, they are reusable
     */
    if(p->qref[0] == 0 && p->qref[1] == 0){
        qreopen(p->q[0]);
        qreopen(p->q[1]);
    }

    /*
     *  free the structure on last close
     */
    p->ref--;
    if(p->ref == 0){
        qunlock(p);
        free(p->q[0]);
        free(p->q[1]);
        free(p);
    } else
        qunlock(p);
}

static long
piperead(Chan *c, void *va, long n, vlong)
{
    Pipe *p;

    p = c->aux;

    switch(NETTYPE(c->qid.path)){
    case Qdir:
        return devdirread(c, va, n, pipedir, NPIPEDIR, pipegen);
    case Qdata0:
        return qread(p->q[0], va, n);
    case Qdata1:
        return qread(p->q[1], va, n);
    default:
        panic("piperead");
    }
    return -1;  /* not reached */
}

static Block*
pipebread(Chan *c, long n, ulong offset)
{
    Pipe *p;

    p = c->aux;

    switch(NETTYPE(c->qid.path)){
    case Qdata0:
        return qbread(p->q[0], n);
    case Qdata1:
        return qbread(p->q[1], n);
    }

    return devbread(c, n, offset);
}

/*
 *  a write to a closed pipe causes a note to be sent to
 *  the process.
 */
static long
pipewrite(Chan *c, void *va, long n, vlong)
{
    Pipe *p;

    if(!islo())
        print("pipewrite hi %#p\n", getcallerpc(&c));
    if(waserror()) {
        /* avoid notes when pipe is a mounted queue */
        if((c->flag & CMSG) == 0)
            postnote(up, 1, "sys: write on closed pipe", NUser);
        nexterror();
    }

    p = c->aux;

    switch(NETTYPE(c->qid.path)){
    case Qdata0:
        n = qwrite(p->q[1], va, n);
        break;

    case Qdata1:
        n = qwrite(p->q[0], va, n);
        break;

    default:
        panic("pipewrite");
    }

    poperror();
    return n;
}

static long
pipebwrite(Chan *c, Block *bp, ulong)
{
    long n;
    Pipe *p;

    if(waserror()) {
        /* avoid notes when pipe is a mounted queue */
        if((c->flag & CMSG) == 0)
            postnote(up, 1, "sys: write on closed pipe", NUser);
        nexterror();
    }

    p = c->aux;
    switch(NETTYPE(c->qid.path)){
    case Qdata0:
        n = qbwrite(p->q[1], bp);
        break;

    case Qdata1:
        n = qbwrite(p->q[0], bp);
        break;

    default:
        n = 0;
        panic("pipebwrite");
    }

    poperror();
    return n;
}

Dev pipedevtab = {
    '|',
    "pipe",

    devreset,
    pipeinit,
    devshutdown,
    pipeattach,
    pipewalk,
    pipestat,
    pipeopen,
    devcreate,
    pipeclose,
    piperead,
    pipebread,
    pipewrite,
    pipebwrite,
    devremove,
    pipewstat,
};
@


\subsection*{[[devices/sys/devproc.c]]}

<<devproc.c>>=
#include    "u.h"
#include    <trace.h>
#include    "tos.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
#include    "ureg.h"
//#include  "../port/edf.h"

struct Mntwalk              /* state for /proc/#/ns */
{
    int cddone;
    Mhead*  mh;
    Mount*  cm;
};


enum
{
    Qdir,
    Qtrace,
    Qargs,
    Qctl,
    Qfd,
    Qfpregs,
    Qkregs,
    Qmem,
    Qnote,
    Qnoteid,
    Qnotepg,
    Qns,
    Qproc,
    Qregs,
    Qsegment,
    Qstatus,
    Qtext,
    Qwait,
    Qprofile,
    Qsyscall,
};

enum
{
    CMclose,
    CMclosefiles,
    CMfixedpri,
    CMhang,
    CMkill,
    CMnohang,
    CMnoswap,
    CMpri,
    CMprivate,
    CMprofile,
    CMstart,
    CMstartstop,
    CMstartsyscall,
    CMstop,
    CMwaitstop,
    CMwired,
    CMtrace,
    /* real time */
    CMperiod,
    CMdeadline,
    CMcost,
    CMsporadic,
    CMdeadlinenotes,
    CMadmit,
    CMextra,
    CMexpel,
    CMevent,
};

enum{
    Nevents = 0x4000,
    Emask = Nevents - 1,
};

#define STATSIZE    (2*KNAMELEN+12+9*12)
/*
 * Status, fd, and ns are left fully readable (0444) because of their use in debugging,
 * particularly on shared servers.
 * Arguably, ns and fd shouldn't be readable; if you'd prefer, change them to 0000
 */
Dirtab procdir[] =
{
    "args",     {Qargs},    0,          0660,
    "ctl",      {Qctl},     0,          0000,
    "fd",       {Qfd},      0,          0444,
    "fpregs",   {Qfpregs},  sizeof(ArchFPsave),     0000,
    "kregs",    {Qkregs},   sizeof(Ureg),       0400,
    "mem",      {Qmem},     0,          0000,
    "note",     {Qnote},    0,          0000,
    "noteid",   {Qnoteid},  0,          0664,
    "notepg",   {Qnotepg},  0,          0000,
    "ns",       {Qns},      0,          0444,
    "proc",     {Qproc},    0,          0400,
    "regs",     {Qregs},    sizeof(Ureg),       0000,
    "segment",  {Qsegment}, 0,          0444,
    "status",   {Qstatus},  STATSIZE,       0444,
    "text",     {Qtext},    0,          0000,
    "wait",     {Qwait},    0,          0400,
    "profile",  {Qprofile}, 0,          0400,
    "syscall",  {Qsyscall}, 0,          0400,   
};

static
Cmdtab proccmd[] = {
    CMclose,        "close",        2,
    CMclosefiles,       "closefiles",       1,
    CMfixedpri,     "fixedpri",     2,
    CMhang,         "hang",         1,
    CMnohang,       "nohang",       1,
    CMnoswap,       "noswap",       1,
    CMkill,         "kill",         1,
    CMpri,          "pri",          2,
    CMprivate,      "private",      1,
    CMprofile,      "profile",      1,
    CMstart,        "start",        1,
    CMstartstop,        "startstop",        1,
    CMstartsyscall,     "startsyscall",     1,
    CMstop,         "stop",         1,
    CMwaitstop,     "waitstop",     1,
    CMwired,        "wired",        2,
    CMtrace,        "trace",        0,
    CMperiod,       "period",       2,
    CMdeadline,     "deadline",     2,
    CMcost,         "cost",         2,
    CMsporadic,     "sporadic",     1,
    CMdeadlinenotes,    "deadlinenotes",    1,
    CMadmit,        "admit",        1,
    CMextra,        "extra",        1,
    CMexpel,        "expel",        1,
    CMevent,        "event",        1,
};

/* Segment type from portdat.h */
//@Scheck: not dead, used in devether.c but not in .clang, weird
static char *sname[]={ "Text", "Data", "Bss", "Stack", "Shared", "Phys", };

/*
 * Qids are, in path:
 *   5 bits of file type (qids above)
 *  26 bits of process slot number + 1
 *       in vers,
 *  32 bits of pid, for consistency checking
 * If notepg, c->pgrpid.path is pgrp slot, .vers is noteid.
 */
#define QSHIFT  5   /* location in qid of proc slot # */

#define QID(q)      ((((ulong)(q).path) & ((1<<QSHIFT)-1)) >> 0)
#define SLOT(q)     (((((ulong)(q).path) & ~(1UL<<31)) >> QSHIFT) - 1)
#define PID(q)      ((q).vers)
#define NOTEID(q)   ((q).vers)

void    procctlreq(Proc*, char*, int);
int procctlmemio(Proc*, ulong, int, void*, int);
Chan*   proctext(Chan*, Proc*);
Segment* txt2data(Proc*, Segment*);
int procstopped(void*);
void    mntscan(Mntwalk*, Proc*);

static Traceevent *tevents;
static Lock tlock;
static int topens;
static int tproduced, tconsumed;

//extern int unfair;

static void
profclock(Ureg *ur, Timer *)
{
    Tos *tos;

    if(up == 0 || up->state != Running)
        return;

    /* user profiling clock */
    if(userureg(ur)){
        tos = (Tos*)(USTKTOP-sizeof(Tos));
        tos->clock += TK2MS(1);
        segclock(ur->pc);
    }
}

static int
procgen(Chan *c, char *name, Dirtab *tab, int, int s, Dir *dp)
{
    Qid qid;
    Proc *p;
    char *ename;
    Segment *q;
    ulong pid, path, perm, len;

    if(s == DEVDOTDOT){
        mkqid(&qid, Qdir, 0, QTDIR);
        devdir(c, qid, "#p", 0, eve, 0555, dp);
        return 1;
    }

    if(c->qid.path == Qdir){
        if(s == 0){
            strcpy(up->genbuf, "trace");
            mkqid(&qid, Qtrace, -1, QTFILE);
            devdir(c, qid, up->genbuf, 0, eve, 0444, dp);
            return 1;
        }

        if(name != nil){
            /* ignore s and use name to find pid */
            pid = strtol(name, &ename, 10);
            if(pid==0 || ename[0]!='\0')
                return -1;
            s = procindex(pid);
            if(s < 0)
                return -1;
        }
        else if(--s >= conf.nproc)
            return -1;

        p = proctab(s);
        pid = p->pid;
        if(pid == 0)
            return 0;
        snprint(up->genbuf, sizeof up->genbuf, "%lud", pid);
        /*
         * String comparison is done in devwalk so name must match its formatted pid
        */
        if(name != nil && strcmp(name, up->genbuf) != 0)
            return -1;
        mkqid(&qid, (s+1)<<QSHIFT, pid, QTDIR);
        devdir(c, qid, up->genbuf, 0, p->user, DMDIR|0555, dp);
        return 1;
    }
    if(c->qid.path == Qtrace){
        strcpy(up->genbuf, "trace");
        mkqid(&qid, Qtrace, -1, QTFILE);
        devdir(c, qid, up->genbuf, 0, eve, 0444, dp);
        return 1;
    }
    if(s >= nelem(procdir))
        return -1;
    if(tab)
        panic("procgen");

    tab = &procdir[s];
    path = c->qid.path&~(((1<<QSHIFT)-1));  /* slot component */

    /* p->procmode determines default mode for files in /proc */
    p = proctab(SLOT(c->qid));
    perm = tab->perm;
    if(perm == 0)
        perm = p->procmode;
    else    /* just copy read bits */
        perm |= p->procmode & 0444;

    len = tab->length;
    switch(QID(c->qid)) {
    case Qwait:
        len = p->nwait; /* incorrect size, but >0 means there's something to read */
        break;
    case Qprofile:
        q = p->seg[TSEG];
        if(q && q->profile) {
            len = (q->top-q->base)>>LRESPROF;
            len *= sizeof(*q->profile);
        }
        break;
    }

    mkqid(&qid, path|tab->qid.path, c->qid.vers, QTFILE);
    devdir(c, qid, tab->name, len, p->user, perm, dp);
    return 1;
}

static void
_proctrace(Proc* p, Tevent etype, vlong ts)
{
    Traceevent *te;

    if (p->trace == 0 || topens == 0 ||
        tproduced - tconsumed >= Nevents)
        return;

    te = &tevents[tproduced&Emask];
    te->pid = p->pid;
    te->etype = etype;
    if (ts == 0)
        te->time = todget(nil);
    else
        te->time = ts;
    tproduced++;
}

static void
procinit(void)
{
    if(conf.nproc >= (1<<(31-QSHIFT))-1)
        print("warning: too many procs for devproc\n");
    addclock0link((void (*)(void))profclock, 113);  /* Relative prime to HZ */
}

static Chan*
procattach(char *spec)
{
    return devattach('p', spec);
}

static Walkqid*
procwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, procgen);
}

static int
procstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, procgen);
}

/*
 *  none can't read or write state on other
 *  processes.  This is to contain access of
 *  servers running as none should they be
 *  subverted by, for example, a stack attack.
 */
static void
nonone(Proc *p)
{
    if(p == up)
        return;
    if(strcmp(up->user, "none") != 0)
        return;
    if(iseve())
        return;
    error(Eperm);
}

static Chan*
procopen(Chan *c, int omode)
{
    Proc *p;
    Pgrp *pg;
    Chan *tc;
    int pid;

    if(c->qid.type & QTDIR)
        return devopen(c, omode, 0, 0, procgen);

    if(QID(c->qid) == Qtrace){
        if (omode != OREAD) 
            error(Eperm);
        lock(&tlock);
        if (waserror()){
            unlock(&tlock);
            nexterror();
        }
        if (topens > 0)
            error("already open");
        topens++;
        if (tevents == nil){
            tevents = (Traceevent*)malloc(sizeof(Traceevent) * Nevents);
            if(tevents == nil)
                error(Enomem);
            tproduced = tconsumed = 0;
        }
        proctrace = _proctrace;
        unlock(&tlock);
        poperror();

        c->mode = openmode(omode);
        c->flag |= COPEN;
        c->offset = 0;
        return c;
    }
        
    p = proctab(SLOT(c->qid));
    qlock(&p->debug);
    if(waserror()){
        qunlock(&p->debug);
        nexterror();
    }
    pid = PID(c->qid);
    if(p->pid != pid)
        error(Eprocdied);

    omode = openmode(omode);

    switch(QID(c->qid)){
    case Qtext:
        if(omode != OREAD)
            error(Eperm);
        tc = proctext(c, p);
        tc->offset = 0;
        qunlock(&p->debug);
        poperror();
        cclose(c);
        return tc;

    case Qproc:
    case Qkregs:
    case Qsegment:
    case Qprofile:
    case Qfd:
        if(omode != OREAD)
            error(Eperm);
        break;

    case Qnote:
        if(p->privatemem)
            error(Eperm);
        break;

    case Qmem:
    case Qctl:
        if(p->privatemem)
            error(Eperm);
        nonone(p);
        break;

    case Qargs:
    case Qnoteid:
    case Qstatus:
    case Qwait:
    case Qregs:
    case Qfpregs:
    case Qsyscall:  
        nonone(p);
        break;

    case Qns:
        if(omode != OREAD)
            error(Eperm);
        c->aux = malloc(sizeof(Mntwalk));
        break;

    case Qnotepg:
        nonone(p);
        pg = p->pgrp;
        if(pg == nil)
            error(Eprocdied);
        if(omode!=OWRITE || pg->pgrpid == 1)
            error(Eperm);
        c->pgrpid.path = pg->pgrpid+1;
        c->pgrpid.vers = p->noteid;
        break;

    default:
        pprint("procopen %#lux\n", QID(c->qid));
        error(Egreg);
    }

    /* Affix pid to qid */
    if(p->state != Dead)
        c->qid.vers = p->pid;

    /* make sure the process slot didn't get reallocated while we were playing */
    coherence();
    if(p->pid != pid)
        error(Eprocdied);

    tc = devopen(c, omode, 0, 0, procgen);
    qunlock(&p->debug);
    poperror();

    return tc;
}

static int
procwstat(Chan *c, uchar *db, int n)
{
    Proc *p;
    Dir *d;

    if(c->qid.type&QTDIR)
        error(Eperm);

    if(QID(c->qid) == Qtrace)
        return devwstat(c, db, n);
        
    p = proctab(SLOT(c->qid));
    nonone(p);
    d = nil;
    if(waserror()){
        free(d);
        qunlock(&p->debug);
        nexterror();
    }
    qlock(&p->debug);

    if(p->pid != PID(c->qid))
        error(Eprocdied);

    if(strcmp(up->user, p->user) != 0 && strcmp(up->user, eve) != 0)
        error(Eperm);

    d = smalloc(sizeof(Dir)+n);
    n = convM2D(db, n, &d[0], (char*)&d[1]);
    if(n == 0)
        error(Eshortstat);
    if(!emptystr(d->uid) && strcmp(d->uid, p->user) != 0){
        if(strcmp(up->user, eve) != 0)
            error(Eperm);
        else
            kstrdup(&p->user, d->uid);
    }
    /* p->procmode determines default mode for files in /proc */
    if(d->mode != ~0UL)
        p->procmode = d->mode&0777;

    poperror();
    free(d);
    qunlock(&p->debug);
    return n;
}


static long
procoffset(long offset, char *va, int *np)
{
    if(offset > 0) {
        offset -= *np;
        if(offset < 0) {
            memmove(va, va+*np+offset, -offset);
            *np = -offset;
        }
        else
            *np = 0;
    }
    return offset;
}

static int
procqidwidth(Chan *c)
{
    char buf[32];

    return snprint(buf, sizeof buf, "%lud", c->qid.vers);
}

int
procfdprint(Chan *c, int fd, int w, char *s, int ns)
{
    int n;

    if(w == 0)
        w = procqidwidth(c);
    n = snprint(s, ns, "%3d %.2s %C %4ld (%.16llux %*lud %.2ux) %5ld %8lld %s\n",
        fd,
        &"r w rw"[(c->mode&3)<<1],
        devtab[c->type]->dc, c->dev,
        c->qid.path, w, c->qid.vers, c->qid.type,
        c->iounit, c->offset, c->path->s);
    return n;
}

static int
procfds(Proc *p, char *va, int count, long offset)
{
    Fgrp *f;
    Chan *c;
    char buf[256];
    int n, i, w, ww;
    char *a;

    /* print to buf to avoid holding fgrp lock while writing to user space */
    if(count > sizeof buf)
        count = sizeof buf;
    a = buf;

    qlock(&p->debug);
    f = p->fgrp;
    if(f == nil){
        qunlock(&p->debug);
        return 0;
    }
    lock(f);
    if(waserror()){
        unlock(f);
        qunlock(&p->debug);
        nexterror();
    }

    n = readstr(0, a, count, p->dot->path->s);
    n += snprint(a+n, count-n, "\n");
    offset = procoffset(offset, a, &n);
    /* compute width of qid.path */
    w = 0;
    for(i = 0; i <= f->maxfd; i++) {
        c = f->fd[i];
        if(c == nil)
            continue;
        ww = procqidwidth(c);
        if(ww > w)
            w = ww;
    }
    for(i = 0; i <= f->maxfd; i++) {
        c = f->fd[i];
        if(c == nil)
            continue;
        n += procfdprint(c, i, w, a+n, count-n);
        offset = procoffset(offset, a, &n);
    }
    unlock(f);
    qunlock(&p->debug);
    poperror();

    /* copy result to user space, now that locks are released */
    memmove(va, buf, n);

    return n;
}

static void
procclose(Chan * c)
{
    if(QID(c->qid) == Qtrace){
        lock(&tlock);
        if(topens > 0)
            topens--;
        if(topens == 0)
            proctrace = nil;
        unlock(&tlock);
    }
    if(QID(c->qid) == Qns && c->aux != 0)
        free(c->aux);
}

static void
int2flag(int flag, char *s)
{
    if(flag == 0){
        *s = '\0';
        return;
    }
    *s++ = '-';
    if(flag & MAFTER)
        *s++ = 'a';
    if(flag & MBEFORE)
        *s++ = 'b';
    if(flag & MCREATE)
        *s++ = 'c';
    if(flag & MCACHE)
        *s++ = 'C';
    *s = '\0';
}

static int
procargs(Proc *p, char *buf, int nbuf)
{
    int j, k, m;
    char *a;
    int n;

    a = p->args;
    if(p->setargs){
        snprint(buf, nbuf, "%s [%s]", p->text, p->args);
        return strlen(buf);
    }
    n = p->nargs;
    for(j = 0; j < nbuf - 1; j += m){
        if(n <= 0)
            break;
        if(j != 0)
            buf[j++] = ' ';
        m = snprint(buf+j, nbuf-j, "%q",  a);
        k = strlen(a) + 1;
        a += k;
        n -= k;
    }
    return j;
}

static int
eventsavailable(void *)
{
    return tproduced > tconsumed;
}

static long
procread(Chan *c, void *va, long n, vlong off)
{
    /* NSEG*32 was too small for worst cases */
    char *a, flag[10], *sps, *srv, statbuf[NSEG*64];
    int i, j, m, navail, ne, pid, rsize;
    long l;
    uchar *rptr;
    ulong offset;
    Confmem *cm;
    Mntwalk *mw;
    Proc *p;
    Segment *sg, *s;
    Ureg kur;
    Waitq *wq;
    
    a = va;
    offset = off;

    if(c->qid.type & QTDIR)
        return devdirread(c, a, n, 0, 0, procgen);

    if(QID(c->qid) == Qtrace){
        if(!eventsavailable(nil))
            return 0;

        rptr = (uchar*)va;
        navail = tproduced - tconsumed;
        if(navail > n / sizeof(Traceevent))
            navail = n / sizeof(Traceevent);
        while(navail > 0) {
            ne = ((tconsumed & Emask) + navail > Nevents)? 
                    Nevents - (tconsumed & Emask): navail;
            memmove(rptr, &tevents[tconsumed & Emask], 
                    ne * sizeof(Traceevent));

            tconsumed += ne;
            rptr += ne * sizeof(Traceevent);
            navail -= ne;
        }
        return rptr - (uchar*)va;
    }

    p = proctab(SLOT(c->qid));
    if(p->pid != PID(c->qid))
        error(Eprocdied);

    switch(QID(c->qid)){
    case Qargs:
        qlock(&p->debug);
        j = procargs(p, up->genbuf, sizeof up->genbuf);
        qunlock(&p->debug);
        if(offset >= j)
            return 0;
        if(offset+n > j)
            n = j-offset;
        memmove(a, &up->genbuf[offset], n);
        return n;
    case Qsyscall:
        if(!p->syscalltrace)
            return 0;
        n = readstr(offset, a, n, p->syscalltrace);
        return n;

    case Qmem:
        if(offset < KZERO)
            return procctlmemio(p, offset, n, va, 1);

        if(!iseve())
            error(Eperm);

        /* validate kernel addresses */
        if(offset < (ulong)end) {
            if(offset+n > (ulong)end)
                n = (ulong)end - offset;
            memmove(a, (char*)offset, n);
            return n;
        }
        for(i=0; i<nelem(conf.mem); i++){
            cm = &conf.mem[i];
            /* klimit-1 because klimit might be zero! */
            if(cm->kbase <= offset && offset <= cm->klimit-1){
                if(offset+n >= cm->klimit-1)
                    n = cm->klimit - offset;
                memmove(a, (char*)offset, n);
                return n;
            }
        }
        error(Ebadarg);

    case Qprofile:
        s = p->seg[TSEG];
        if(s == 0 || s->profile == 0)
            error("profile is off");
        i = (s->top-s->base)>>LRESPROF;
        i *= sizeof(*s->profile);
        if(offset >= i)
            return 0;
        if(offset+n > i)
            n = i - offset;
        memmove(a, ((char*)s->profile)+offset, n);
        return n;

    case Qnote:
        qlock(&p->debug);
        if(waserror()){
            qunlock(&p->debug);
            nexterror();
        }
        if(p->pid != PID(c->qid))
            error(Eprocdied);
        if(n < 1)   /* must accept at least the '\0' */
            error(Etoosmall);
        if(p->nnote == 0)
            n = 0;
        else {
            m = strlen(p->note[0].msg) + 1;
            if(m > n)
                m = n;
            memmove(va, p->note[0].msg, m);
            ((char*)va)[m-1] = '\0';
            p->nnote--;
            memmove(p->note, p->note+1, p->nnote*sizeof(Note));
            n = m;
        }
        if(p->nnote == 0)
            p->notepending = 0;
        poperror();
        qunlock(&p->debug);
        return n;

    case Qproc:
        if(offset >= sizeof(Proc))
            return 0;
        if(offset+n > sizeof(Proc))
            n = sizeof(Proc) - offset;
        memmove(a, ((char*)p)+offset, n);
        return n;

    case Qregs:
        rptr = (uchar*)p->dbgreg;
        rsize = sizeof(Ureg);
        goto regread;

    case Qkregs:
        memset(&kur, 0, sizeof(Ureg));
        setkernur(&kur, p);
        rptr = (uchar*)&kur;
        rsize = sizeof(Ureg);
        goto regread;

    case Qfpregs:
        rptr = (uchar*)&p->fpsave;
        rsize = sizeof(ArchFPsave);
    regread:
        if(rptr == 0)
            error(Enoreg);
        if(offset >= rsize)
            return 0;
        if(offset+n > rsize)
            n = rsize - offset;
        memmove(a, rptr+offset, n);
        return n;

    case Qstatus:
        if(offset >= STATSIZE)
            return 0;
        if(offset+n > STATSIZE)
            n = STATSIZE - offset;

        sps = p->psstate;
        if(sps == 0)
            sps = statename[p->state];
        memset(statbuf, ' ', sizeof statbuf);
        readstr(0, statbuf+0*KNAMELEN, KNAMELEN-1, p->text);
        readstr(0, statbuf+1*KNAMELEN, KNAMELEN-1, p->user);
        readstr(0, statbuf+2*KNAMELEN, 11, sps);
        j = 2*KNAMELEN + 12;

        for(i = 0; i < 6; i++) {
            l = p->time[i];
            if(i == TReal)
                l = MACHP(0)->ticks - l;
            l = TK2MS(l);
            readnum(0, statbuf+j+NUMSIZE*i, NUMSIZE, l, NUMSIZE);
        }
        /* ignore stack, which is mostly non-existent */
        l = 0;
        for(i=1; i<NSEG; i++){
            s = p->seg[i];
            if(s)
                l += s->top - s->base;
        }
        readnum(0, statbuf+j+NUMSIZE*6, NUMSIZE, l>>10, NUMSIZE);
        readnum(0, statbuf+j+NUMSIZE*7, NUMSIZE, p->basepri, NUMSIZE);
        readnum(0, statbuf+j+NUMSIZE*8, NUMSIZE, p->priority, NUMSIZE);
        memmove(a, statbuf+offset, n);
        return n;

    case Qsegment:
        j = 0;
        for(i = 0; i < NSEG; i++) {
            sg = p->seg[i];
            if(sg == 0)
                continue;
            j += snprint(statbuf+j, sizeof statbuf - j,
                "%-6s %c%c %.8lux %.8lux %4ld\n",
                sname[sg->type&SG_TYPE],
                sg->type&SG_RONLY ? 'R' : ' ',
                sg->profile ? 'P' : ' ',
                sg->base, sg->top, sg->ref);
        }
        if(offset >= j)
            return 0;
        if(offset+n > j)
            n = j-offset;
        if(n == 0 && offset == 0)
            exhausted("segments");
        memmove(a, &statbuf[offset], n);
        return n;

    case Qwait:
        if(!canqlock(&p->qwaitr))
            error(Einuse);

        if(waserror()) {
            qunlock(&p->qwaitr);
            nexterror();
        }

        lock(&p->exl);
        if(up == p && p->nchild == 0 && p->waitq == 0) {
            unlock(&p->exl);
            error(Enochild);
        }
        pid = p->pid;
        while(p->waitq == 0) {
            unlock(&p->exl);
            sleep(&p->waitr, haswaitq, p);
            if(p->pid != pid)
                error(Eprocdied);
            lock(&p->exl);
        }
        wq = p->waitq;
        p->waitq = wq->next;
        p->nwait--;
        unlock(&p->exl);

        qunlock(&p->qwaitr);
        poperror();
        n = snprint(a, n, "%d %lud %lud %lud %q",
            wq->w.pid,
            wq->w.time[TUser], wq->w.time[TSys], wq->w.time[TReal],
            wq->w.msg);
        free(wq);
        return n;

    case Qns:
        qlock(&p->debug);
        if(waserror()){
            qunlock(&p->debug);
            nexterror();
        }
        if(p->pgrp == nil || p->pid != PID(c->qid))
            error(Eprocdied);
        mw = c->aux;
        if(mw == nil)
            error(Enomem);
        if(mw->cddone){
            qunlock(&p->debug);
            poperror();
            return 0;
        }
        mntscan(mw, p);
        if(mw->mh == 0){
            mw->cddone = 1;
            i = snprint(a, n, "cd %s\n", p->dot->path->s);
            qunlock(&p->debug);
            poperror();
            return i;
        }
        int2flag(mw->cm->mflag, flag);
        if(strcmp(mw->cm->to->path->s, "#M") == 0){
            srv = srvname(mw->cm->to->mchan);
            i = snprint(a, n, "mount %s %s %s %s\n", flag,
                srv==nil? mw->cm->to->mchan->path->s : srv,
                mw->mh->from->path->s, mw->cm->spec? mw->cm->spec : "");
            free(srv);
        }else
            i = snprint(a, n, "bind %s %s %s\n", flag,
                mw->cm->to->path->s, mw->mh->from->path->s);
        qunlock(&p->debug);
        poperror();
        return i;

    case Qnoteid:
        return readnum(offset, va, n, p->noteid, NUMSIZE);
    case Qfd:
        return procfds(p, va, n, offset);
    }
    error(Egreg);
    return 0;       /* not reached */
}

void
mntscan(Mntwalk *mw, Proc *p)
{
    Pgrp *pg;
    Mount *t;
    Mhead *f;
    int nxt, i;
    ulong last, bestmid;

    pg = p->pgrp;
    rlock(&pg->ns);

    nxt = 0;
    bestmid = ~0;

    last = 0;
    if(mw->mh)
        last = mw->cm->mountid;

    for(i = 0; i < MNTHASH; i++) {
        for(f = pg->mnthash[i]; f; f = f->hash) {
            for(t = f->mount; t; t = t->next) {
                if(mw->mh == 0 ||
                  (t->mountid > last && t->mountid < bestmid)) {
                    mw->cm = t;
                    mw->mh = f;
                    bestmid = mw->cm->mountid;
                    nxt = 1;
                }
            }
        }
    }
    if(nxt == 0)
        mw->mh = 0;

    runlock(&pg->ns);
}

static long
procwrite(Chan *c, void *va, long n, vlong off)
{
    int id, m;
    Proc *p, *t, *et;
    char *a, *arg, buf[ERRMAX];
    ulong offset = off;

    a = va;
    if(c->qid.type & QTDIR)
        error(Eisdir);

    p = proctab(SLOT(c->qid));

    /* Use the remembered noteid in the channel rather
     * than the process pgrpid
     */
    if(QID(c->qid) == Qnotepg) {
        pgrpnote(NOTEID(c->pgrpid), va, n, NUser);
        return n;
    }

    qlock(&p->debug);
    if(waserror()){
        qunlock(&p->debug);
        nexterror();
    }
    if(p->pid != PID(c->qid))
        error(Eprocdied);

    switch(QID(c->qid)){
    case Qargs:
        if(n == 0)
            error(Eshort);
        if(n >= ERRMAX)
            error(Etoobig);
        arg = malloc(n+1);
        if(arg == nil)
            error(Enomem);
        memmove(arg, va, n);
        m = n;
        if(arg[m-1] != 0)
            arg[m++] = 0;
        free(p->args);
        p->nargs = m;
        p->args = arg;
        p->setargs = 1;
        break;

    case Qmem:
        if(p->state != Stopped)
            error(Ebadctl);

        n = procctlmemio(p, offset, n, va, 0);
        break;

    case Qregs:
        if(offset >= sizeof(Ureg))
            n = 0;
        else if(offset+n > sizeof(Ureg))
            n = sizeof(Ureg) - offset;
        if(p->dbgreg == 0)
            error(Enoreg);
        setregisters(p->dbgreg, (char*)(p->dbgreg)+offset, va, n);
        break;

    case Qfpregs:
        if(offset >= sizeof(ArchFPsave))
            n = 0;
        else if(offset+n > sizeof(ArchFPsave))
            n = sizeof(ArchFPsave) - offset;
        memmove((uchar*)&p->fpsave+offset, va, n);
        break;

    case Qctl:
        procctlreq(p, va, n);
        break;

    case Qnote:
        if(p->kp)
            error(Eperm);
        if(n >= ERRMAX-1)
            error(Etoobig);
        memmove(buf, va, n);
        buf[n] = 0;
        if(!postnote(p, 0, buf, NUser))
            error("note not posted");
        break;
    case Qnoteid:
        id = atoi(a);
        if(id == p->pid) {
            p->noteid = id;
            break;
        }
        t = proctab(0);
        for(et = t+conf.nproc; t < et; t++) {
            if(t->state == Dead)
                continue;
            if(id == t->noteid) {
                if(strcmp(p->user, t->user) != 0)
                    error(Eperm);
                p->noteid = id;
                break;
            }
        }
        if(p->noteid != id)
            error(Ebadarg);
        break;
    default:
        pprint("unknown qid in procwrite\n");
        error(Egreg);
    }
    poperror();
    qunlock(&p->debug);
    return n;
}

Dev procdevtab = {
    'p',
    "proc",

    devreset,
    procinit,
    devshutdown,
    procattach,
    procwalk,
    procstat,
    procopen,
    devcreate,
    procclose,
    procread,
    devbread,
    procwrite,
    devbwrite,
    devremove,
    procwstat,
};

Chan*
proctext(Chan *c, Proc *p)
{
    Chan *tc;
    KImage *i;
    Segment *s;

    s = p->seg[TSEG];
    if(s == 0)
        error(Enonexist);
    if(p->state==Dead)
        error(Eprocdied);

    lock(s);
    i = s->image;
    if(i == 0) {
        unlock(s);
        error(Eprocdied);
    }
    unlock(s);

    lock(i);
    if(waserror()) {
        unlock(i);
        nexterror();
    }

    tc = i->c;
    if(tc == 0)
        error(Eprocdied);

    if(incref(tc) == 1 || (tc->flag&COPEN) == 0 || tc->mode!=OREAD) {
        cclose(tc);
        error(Eprocdied);
    }

    if(p->pid != PID(c->qid)){
        cclose(tc);
        error(Eprocdied);
    }

    unlock(i);
    poperror();

    return tc;
}

void
procstopwait(Proc *p, int ctl)
{
    int pid;

    if(p->pdbg)
        error(Einuse);
    if(procstopped(p) || p->state == Broken)
        return;

    if(ctl != 0)
        p->procctl = ctl;
    p->pdbg = up;
    pid = p->pid;
    qunlock(&p->debug);
    up->psstate = "Stopwait";
    if(waserror()) {
        p->pdbg = 0;
        qlock(&p->debug);
        nexterror();
    }
    sleep(&up->sleep, procstopped, p);
    poperror();
    qlock(&p->debug);
    if(p->pid != pid)
        error(Eprocdied);
}

static void
procctlcloseone(Proc *p, Fgrp *f, int fd)
{
    Chan *c;

    c = f->fd[fd];
    if(c == nil)
        return;
    f->fd[fd] = nil;
    unlock(f);
    qunlock(&p->debug);
    cclose(c);
    qlock(&p->debug);
    lock(f);
}

void
procctlclosefiles(Proc *p, int all, int fd)
{
    int i;
    Fgrp *f;

    f = p->fgrp;
    if(f == nil)
        error(Eprocdied);

    lock(f);
    f->ref++;
    if(all)
        for(i = 0; i < f->maxfd; i++)
            procctlcloseone(p, f, i);
    else
        procctlcloseone(p, f, fd);
    unlock(f);
    closefgrp(f);
}

static char *
parsetime(vlong *rt, char *s)
{
    uvlong ticks;
    ulong l;
    char *e, *p;
    static int p10[] = {100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10, 1};

    if (s == nil)
        return("missing value");
    ticks=strtoul(s, &e, 10);
    if (*e == '.'){
        p = e+1;
        l = strtoul(p, &e, 10);
        if(e-p > nelem(p10))
            return "too many digits after decimal point";
        if(e-p == 0)
            return "ill-formed number";
        l *= p10[e-p-1];
    }else
        l = 0;
    if (*e == '\0' || strcmp(e, "s") == 0){
        ticks = 1000000000 * ticks + l;
    }else if (strcmp(e, "ms") == 0){
        ticks = 1000000 * ticks + l/1000;
    }else if (strcmp(e, "Âµs") == 0 || strcmp(e, "us") == 0){
        ticks = 1000 * ticks + l/1000000;
    }else if (strcmp(e, "ns") != 0)
        return "unrecognized unit";
    *rt = ticks;
    return nil;
}

void
procctlreq(Proc *p, char *va, int n)
{
    Segment *s;
    int npc, pri;
    Cmdbuf *cb;
    Cmdtab *ct;
    vlong time;
    char *e;
    void (*pt)(Proc*, int, vlong);

    if(p->kp)   /* no ctl requests to kprocs */
        error(Eperm);

    cb = parsecmd(va, n);
    if(waserror()){
        free(cb);
        nexterror();
    }

    ct = lookupcmd(cb, proccmd, nelem(proccmd));

    switch(ct->index){
    case CMclose:
        procctlclosefiles(p, 0, atoi(cb->f[1]));
        break;
    case CMclosefiles:
        procctlclosefiles(p, 1, 0);
        break;
    case CMhang:
        p->hang = 1;
        break;
    case CMkill:
        switch(p->state) {
        case Broken:
            unbreak(p);
            break;
        case Stopped:
            p->procctl = Proc_exitme;
            postnote(p, 0, "sys: killed", NExit);
            ready(p);
            break;
        default:
            p->procctl = Proc_exitme;
            postnote(p, 0, "sys: killed", NExit);
        }
        break;
    case CMnohang:
        p->hang = 0;
        break;
    case CMnoswap:
        p->noswap = 1;
        break;
    case CMpri:
        pri = atoi(cb->f[1]);
        if(pri > PriNormal && !iseve())
            error(Eperm);
        procpriority(p, pri, 0);
        break;
    case CMfixedpri:
        pri = atoi(cb->f[1]);
        if(pri > PriNormal && !iseve())
            error(Eperm);
        procpriority(p, pri, 1);
        break;
    case CMprivate:
        p->privatemem = 1;
        break;
    case CMprofile:
        s = p->seg[TSEG];
        if(s == 0 || (s->type&SG_TYPE) != SG_TEXT)
            error(Ebadctl);
        if(s->profile != 0)
            free(s->profile);
        npc = (s->top-s->base)>>LRESPROF;
        s->profile = malloc(npc*sizeof(*s->profile));
        if(s->profile == 0)
            error(Enomem);
        break;
    case CMstart:
        if(p->state != Stopped)
            error(Ebadctl);
        ready(p);
        break;
    case CMstartstop:
        if(p->state != Stopped)
            error(Ebadctl);
        p->procctl = Proc_traceme;
        ready(p);
        procstopwait(p, Proc_traceme);
        break;
    case CMstartsyscall:
        if(p->state != Stopped)
            error(Ebadctl);
        p->procctl = Proc_tracesyscall;
        ready(p);
        procstopwait(p, Proc_tracesyscall);
        break;
    case CMstop:
        procstopwait(p, Proc_stopme);
        break;
    case CMwaitstop:
        procstopwait(p, 0);
        break;
    case CMwired:
        procwired(p, atoi(cb->f[1]));
        break;
    case CMtrace:
        switch(cb->nf){
        case 1:
            p->trace ^= 1;
            break;
        case 2:
            p->trace = (atoi(cb->f[1]) != 0);
            break;
        default:
            error("args");
        }
        break;
    /* real time */
    case CMperiod:
        if(p->edf == nil)
            edfinit(p);
        if(e=parsetime(&time, cb->f[1]))    /* time in ns */
            error(e);
        edfstop(p);
        p->edf->T = time/1000;  /* Edf times are in Âµs */
        break;
    case CMdeadline:
        if(p->edf == nil)
            edfinit(p);
        if(e=parsetime(&time, cb->f[1]))
            error(e);
        edfstop(p);
        p->edf->D = time/1000;
        break;
    case CMcost:
        if(p->edf == nil)
            edfinit(p);
        if(e=parsetime(&time, cb->f[1]))
            error(e);
        edfstop(p);
        p->edf->C = time/1000;
        break;
    case CMsporadic:
        if(p->edf == nil)
            edfinit(p);
        p->edf->flags |= Sporadic;
        break;
    case CMdeadlinenotes:
        if(p->edf == nil)
            edfinit(p);
        p->edf->flags |= Sendnotes;
        break;
    case CMadmit:
        if(p->edf == 0)
            error("edf params");
        if(e = edfadmit(p))
            error(e);
        break;
    case CMextra:
        if(p->edf == nil)
            edfinit(p);
        p->edf->flags |= Extratime;
        break;
    case CMexpel:
        if(p->edf)
            edfstop(p);
        break;
    case CMevent:
        pt = proctrace;
        if(up->trace && pt)
            pt(up, SUser, 0);
        break;
    }

    poperror();
    free(cb);
}

int
procstopped(void *a)
{
    Proc *p = a;
    return p->state == Stopped;
}

int
procctlmemio(Proc *p, ulong offset, int n, void *va, int read)
{
    KMap *k;
    Pte *pte;
    Page *pg;
    Segment *s;
    ulong soff, l;
    char *a = va, *b;

    for(;;) {
        s = seg(p, offset, 1);
        if(s == 0)
            error(Ebadarg);

        if(offset+n >= s->top)
            n = s->top-offset;

        if(!read && (s->type&SG_TYPE) == SG_TEXT)
            s = txt2data(p, s);

        s->steal++;
        soff = offset-s->base;
        if(waserror()) {
            s->steal--;
            nexterror();
        }
        if(fixfault(s, offset, read, 0) == 0)
            break;
        poperror();
        s->steal--;
    }
    poperror();
    pte = s->map[soff/PTEMAPMEM];
    if(pte == 0)
        panic("procctlmemio");
    pg = pte->pages[(soff&(PTEMAPMEM-1))/BY2PG];
    if(pagedout(pg))
        panic("procctlmemio1");

    l = BY2PG - (offset&(BY2PG-1));
    if(n > l)
        n = l;

    k = kmap(pg);
    if(waserror()) {
        s->steal--;
        kunmap(k);
        nexterror();
    }
    b = (char*)VA(k);
    b += offset&(BY2PG-1);
    if(read == 1)
        memmove(a, b, n);   /* This can fault */
    else
        memmove(b, a, n);
    kunmap(k);
    poperror();

    /* Ensure the process sees text page changes */
    if(s->flushme)
        memset(pg->cachectl, PG_TXTFLUSH, sizeof(pg->cachectl));

    s->steal--;

    if(read == 0)
        p->newtlb = 1;

    return n;
}

Segment*
txt2data(Proc *p, Segment *s)
{
    int i;
    Segment *ps;

    ps = newseg(SG_DATA, s->base, s->size);
    ps->image = s->image;
    incref(ps->image);
    ps->fstart = s->fstart;
    ps->flen = s->flen;
    ps->flushme = 1;

    qlock(&p->seglock);
    for(i = 0; i < NSEG; i++)
        if(p->seg[i] == s)
            break;
    if(i == NSEG)
        panic("segment gone");

    qunlock(&s->lk);
    putseg(s);
    qlock(&ps->lk);
    p->seg[i] = ps;
    qunlock(&p->seglock);

    return ps;
}
@


\subsection*{[[devices/sys/devroot.c]]}

<<devroot.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

//*****************************************************************************
// Constants and types
//*****************************************************************************

enum
{
    Qdir = 0,
    Qboot = 0x1000,

    Nrootfiles = 32,
    Nbootfiles = 32,
};

typedef struct Dirlist Dirlist;
struct Dirlist
{
    uint base; // for unique qids
    Dirtab *dir;
    uchar **data;
    int ndir; // number of dir used
    int mdir; // max dir entries
};

//*****************************************************************************
// Root
//*****************************************************************************

// note: directories have by convention 0 length
static Dirtab rootdir[Nrootfiles] = {
  {
    .name = "#/",
    .qid = {Qdir, 0, QTDIR},
    .length = 0,
    .perm = DMDIR|0555,
  },
  {    
    .name = "boot", 
    .qid = {Qboot, 0, QTDIR},
    .length = 0,
    .perm = DMDIR|0555,
  }
};
static uchar *rootdata[Nrootfiles];
static Dirlist rootlist = 
{
  .base = 0,
  .dir = rootdir,
  .data = rootdata,
  .ndir = 2,
  .mdir = Nrootfiles
};

//*****************************************************************************
// Boot
//*****************************************************************************

static Dirtab bootdir[Nbootfiles] = {
  {
    .name = "boot",
    .qid = {Qboot, 0, QTDIR},
    .length = 0,
    .perm = DMDIR|0555,
  }
};

static uchar *bootdata[Nbootfiles];
static Dirlist bootlist =
{
    .base = Qboot,
    .dir = bootdir,
    .data = bootdata,
    .ndir = 1,
    .mdir = Nbootfiles
};

//*****************************************************************************
// Functions
//*****************************************************************************

/*
 *  add a file to the list
 */
static void
addlist(Dirlist *l, char *name, uchar *contents, ulong len, int perm)
{
    Dirtab *d;

    if(l->ndir >= l->mdir)
        panic("too many root files");
    l->data[l->ndir] = contents;
    d = &l->dir[l->ndir];
    strcpy(d->name, name);
    d->length = len;
    d->perm = perm;
    d->qid.type = 0;
    d->qid.vers = 0;
    d->qid.path = ++l->ndir + l->base;
    if(perm & DMDIR)
        d->qid.type |= QTDIR;
}

/*
 *  add a root file
 */
void
addbootfile(char *name, uchar *contents, ulong len)
{
    addlist(&bootlist, name, contents, len, 0555);
}

/*
 *  add a root directory
 */
static void
addrootdir(char *name)
{
    addlist(&rootlist, name, nil, 0, DMDIR|0555);
}

static void
rootreset(void)
{
    addrootdir("bin");
    addrootdir("dev");
    addrootdir("env");
    addrootdir("fd");
    addrootdir("mnt");
    addrootdir("net");
    addrootdir("net.alt");
    addrootdir("proc");
    addrootdir("root");
    addrootdir("srv");
}

static Chan*
rootattach(char *spec)
{
    return devattach('/', spec);
}

static int
rootgen(Chan *c, char *name, Dirtab*, int, int s, Dir *dp)
{
    int t;
    Dirtab *d;
    Dirlist *l;

    switch((int)c->qid.path){
    case Qdir:
        if(s == DEVDOTDOT){
            devdir(c, (Qid){Qdir, 0, QTDIR}, "#/", 0, eve, 0555, dp);
            return 1;
        }
        return devgen(c, name, rootlist.dir, rootlist.ndir, s, dp);
    case Qboot:
        if(s == DEVDOTDOT){
            devdir(c, (Qid){Qdir, 0, QTDIR}, "#/", 0, eve, 0555, dp);
            return 1;
        }
        return devgen(c, name, bootlist.dir, bootlist.ndir, s, dp);
    default:
        if(s == DEVDOTDOT){
            if((int)c->qid.path < Qboot)
                devdir(c, (Qid){Qdir, 0, QTDIR}, "#/", 0, eve, 0555, dp);
            else
                devdir(c, (Qid){Qboot, 0, QTDIR}, "#/", 0, eve, 0555, dp);
            return 1;
        }
        if(s != 0)
            return -1;
        if((int)c->qid.path < Qboot){
            t = c->qid.path-1;
            l = &rootlist;
        }else{
            t = c->qid.path - Qboot - 1;
            l = &bootlist;
        }
        if(t >= l->ndir)
            return -1;
if(t < 0){
print("rootgen %llud %d %d\n", c->qid.path, s, t);
panic("whoops");
}
        d = &l->dir[t];
        devdir(c, d->qid, d->name, d->length, eve, d->perm, dp);
        return 1;
    }
}

static Walkqid*
rootwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c,  nc, name, nname, nil, 0, rootgen);
}

static int
rootstat(Chan *c, uchar *dp, int n)
{
    return devstat(c, dp, n, nil, 0, rootgen);
}

static Chan*
rootopen(Chan *c, int omode)
{
    return devopen(c, omode, nil, 0, devgen);
}

/*
 * sysremove() knows this is a nop
 */
static void
rootclose(Chan*)
{
}

static long
rootread(Chan *c, void *buf, long n, vlong off)
{
    ulong t;
    Dirtab *d;
    Dirlist *l;
    uchar *data;
    ulong offset = off;

    t = c->qid.path;
    switch(t){
    case Qdir:
    case Qboot:
        return devdirread(c, buf, n, nil, 0, rootgen);
    }

    if(t<Qboot)
        l = &rootlist;
    else{
        t -= Qboot;
        l = &bootlist;
    }

    t--;
    if(t >= l->ndir)
        error(Egreg);

    d = &l->dir[t];
    data = l->data[t];
    if(offset >= d->length)
        return 0;
    if(offset+n > d->length)
        n = d->length - offset;
#ifdef asdf
print("[%d] kaddr %.8ulx base %.8ulx offset %ld (%.8ulx), n %d %.8ulx %.8ulx %.8ulx\n", 
        t, buf, data, offset, offset, n,
        ((ulong*)(data+offset))[0],
        ((ulong*)(data+offset))[1],
        ((ulong*)(data+offset))[2]);
#endif asdf
    memmove(buf, data+offset, n);
    return n;
}

static long
rootwrite(Chan*, void*, long, vlong)
{
    error(Egreg);
    return 0;
}

Dev rootdevtab = {
  .dc = '/',
  .name = "root",

  .reset = rootreset,
  .init = devinit,
  .shutdown = devshutdown,
  .attach = rootattach,
  .walk = rootwalk,
  .stat = rootstat,
  .open = rootopen,
  .create = devcreate,
  .close = rootclose,
  .read = rootread,
  .bread = devbread,
  .write = rootwrite,
  .bwrite = devbwrite,
  .remove = devremove,
  .wstat = devwstat,
};

@


\subsection*{[[devices/sys/devsrv.c]]}

<<devsrv.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"


typedef struct Srv Srv;
struct Srv
{
    char    *name;
    char    *owner;
    ulong   perm;
    Chan    *chan;
    Srv *link;
    ulong   path;
};

static QLock    srvlk;
static Srv  *srv;
static int  qidpath;

static int
srvgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    Srv *sp;
    Qid q;

    if(s == DEVDOTDOT){
        devdir(c, c->qid, "#s", 0, eve, 0555, dp);
        return 1;
    }

    qlock(&srvlk);
    for(sp = srv; sp && s; sp = sp->link)
        s--;

    if(sp == 0) {
        qunlock(&srvlk);
        return -1;
    }

    mkqid(&q, sp->path, 0, QTFILE);
    /* make sure name string continues to exist after we release lock */
    kstrcpy(up->genbuf, sp->name, sizeof up->genbuf);
    devdir(c, q, up->genbuf, 0, sp->owner, sp->perm, dp);
    qunlock(&srvlk);
    return 1;
}

static void
srvinit(void)
{
    qidpath = 1;
}

static Chan*
srvattach(char *spec)
{
    return devattach('s', spec);
}

static Walkqid*
srvwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, 0, 0, srvgen);
}

static Srv*
srvlookup(char *name, ulong qidpath)
{
    Srv *sp;
    for(sp = srv; sp; sp = sp->link)
        if(sp->path == qidpath || (name && strcmp(sp->name, name) == 0))
            return sp;
    return nil;
}

static int
srvstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, 0, 0, srvgen);
}

char*
srvname(Chan *c)
{
    int size;
    Srv *sp;
    char *s;

    for(sp = srv; sp; sp = sp->link)
        if(sp->chan == c){
            size = 3+strlen(sp->name)+1;
            s = smalloc(size);
            snprint(s, size, "#s/%s", sp->name);
            return s;
        }
    return nil;
}

static Chan*
srvopen(Chan *c, int omode)
{
    Srv *sp;

    if(c->qid.type == QTDIR){
        if(omode & ORCLOSE)
            error(Eperm);
        if(omode != OREAD)
            error(Eisdir);
        c->mode = omode;
        c->flag |= COPEN;
        c->offset = 0;
        return c;
    }
    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        nexterror();
    }

    sp = srvlookup(nil, c->qid.path);
    if(sp == 0 || sp->chan == 0)
        error(Eshutdown);

    if(omode&OTRUNC)
        error("srv file already exists");
    if(openmode(omode)!=sp->chan->mode && sp->chan->mode!=ORDWR)
        error(Eperm);
    devpermcheck(sp->owner, sp->perm, omode);

    cclose(c);
    incref(sp->chan);
    qunlock(&srvlk);
    poperror();
    return sp->chan;
}

static void
srvcreate(Chan *c, char *name, int omode, ulong perm)
{
    char *sname;
    Srv *sp;

    if(openmode(omode) != OWRITE)
        error(Eperm);

    if(omode & OCEXEC)  /* can't happen */
        panic("someone broke namec");

    sp = smalloc(sizeof *sp);
    sname = smalloc(strlen(name)+1);

    qlock(&srvlk);
    if(waserror()){
        free(sp);
        free(sname);
        qunlock(&srvlk);
        nexterror();
    }
    if(sp == nil || sname == nil)
        error(Enomem);
    if(srvlookup(name, -1))
        error(Eexist);

    sp->path = qidpath++;
    sp->link = srv;
    strcpy(sname, name);
    sp->name = sname;
    c->qid.type = QTFILE;
    c->qid.path = sp->path;
    srv = sp;
    qunlock(&srvlk);
    poperror();

    kstrdup(&sp->owner, up->user);
    sp->perm = perm&0777;

    c->flag |= COPEN;
    c->mode = OWRITE;
}

static void
srvremove(Chan *c)
{
    Srv *sp, **l;

    if(c->qid.type == QTDIR)
        error(Eperm);

    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        nexterror();
    }
    l = &srv;
    for(sp = *l; sp; sp = sp->link) {
        if(sp->path == c->qid.path)
            break;

        l = &sp->link;
    }
    if(sp == 0)
        error(Enonexist);

    /*
     * Only eve can remove system services.
     * No one can remove #s/boot.
     */
    if(strcmp(sp->owner, eve) == 0 && !iseve())
        error(Eperm);
    if(strcmp(sp->name, "boot") == 0)
        error(Eperm);

    /*
     * No removing personal services.
     */
    if((sp->perm&7) != 7 && strcmp(sp->owner, up->user) && !iseve())
        error(Eperm);

    *l = sp->link;
    qunlock(&srvlk);
    poperror();

    if(sp->chan)
        cclose(sp->chan);
    free(sp->owner);
    free(sp->name);
    free(sp);
}

static int
srvwstat(Chan *c, uchar *dp, int n)
{
    char *strs;
    Dir d;
    Srv *sp;

    if(c->qid.type & QTDIR)
        error(Eperm);

    strs = nil;
    qlock(&srvlk);
    if(waserror()){
        qunlock(&srvlk);
        free(strs);
        nexterror();
    }

    sp = srvlookup(nil, c->qid.path);
    if(sp == 0)
        error(Enonexist);

    if(strcmp(sp->owner, up->user) != 0 && !iseve())
        error(Eperm);

    strs = smalloc(n);
    n = convM2D(dp, n, &d, strs);
    if(n == 0)
        error(Eshortstat);
    if(d.mode != ~0UL)
        sp->perm = d.mode & 0777;
    if(d.uid && *d.uid)
        kstrdup(&sp->owner, d.uid);
    if(d.name && *d.name && strcmp(sp->name, d.name) != 0) {
        if(strchr(d.name, '/') != nil)
            error(Ebadchar);
        kstrdup(&sp->name, d.name);
    }
    qunlock(&srvlk);
    free(strs);
    poperror();
    return n;
}

static void
srvclose(Chan *c)
{
    /*
     * in theory we need to override any changes in removability
     * since open, but since all that's checked is the owner,
     * which is immutable, all is well.
     */
    if(c->flag & CRCLOSE){
        if(waserror())
            return;
        srvremove(c);
        poperror();
    }
}

static long
srvread(Chan *c, void *va, long n, vlong)
{
    isdir(c);
    return devdirread(c, va, n, 0, 0, srvgen);
}

static long
srvwrite(Chan *c, void *va, long n, vlong)
{
    Srv *sp;
    Chan *c1;
    int fd;
    char buf[32];

    if(n >= sizeof buf)
        error(Egreg);
    memmove(buf, va, n);    /* so we can NUL-terminate */
    buf[n] = 0;
    fd = strtoul(buf, 0, 0);

    c1 = fdtochan(fd, -1, 0, 1);    /* error check and inc ref */

    qlock(&srvlk);
    if(waserror()) {
        qunlock(&srvlk);
        cclose(c1);
        nexterror();
    }
    if(c1->flag & (CCEXEC|CRCLOSE))
        error("posted fd has remove-on-close or close-on-exec");
    if(c1->qid.type & QTAUTH)
        error("cannot post auth file in srv");
    sp = srvlookup(nil, c->qid.path);
    if(sp == 0)
        error(Enonexist);

    if(sp->chan)
        error(Ebadusefd);

    sp->chan = c1;
    qunlock(&srvlk);
    poperror();
    return n;
}

Dev srvdevtab = {
    's',
    "srv",

    devreset,
    srvinit,    
    devshutdown,
    srvattach,
    srvwalk,
    srvstat,
    srvopen,
    srvcreate,
    srvclose,
    srvread,
    devbread,
    srvwrite,
    devbwrite,
    srvremove,
    srvwstat,
};
@


\section{[[files/]]}

\subsection*{[[files/allocb.c]]}

<<allocb.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "error.h"

enum
{
    Hdrspc      = 64,       /* leave room for high-level headers */
    Bdead       = 0x51494F42,   /* "QIOB" */
};

struct
{
    Lock;
    ulong   bytes;
} ialloc;

static Block*
_allocb(int size)
{
    Block *b;
    ulong addr;

    if((b = mallocz(sizeof(Block)+size+Hdrspc, 0)) == nil)
        return nil;

    b->next = nil;
    b->list = nil;
    b->free = 0;
    b->flag = 0;
    b->ref = 0;
    _xinc(&b->ref);

    /* align start of data portion by rounding up */
    addr = (ulong)b;
    addr = ROUND(addr + sizeof(Block), BLOCKALIGN);
    b->base = (uchar*)addr;

    /* align end of data portion by rounding down */
    b->lim = ((uchar*)b) + msize(b);
    addr = (ulong)(b->lim);
    addr = addr & ~(BLOCKALIGN-1);
    b->lim = (uchar*)addr;

    /* leave sluff at beginning for added headers */
    b->rp = b->lim - ROUND(size, BLOCKALIGN);
    if(b->rp < b->base)
        panic("_allocb");
    b->wp = b->rp;

    return b;
}

Block*
allocb(int size)
{
    Block *b;

    /*
     * Check in a process and wait until successful.
     * Can still error out of here, though.
     */
    if(up == nil)
        panic("allocb without up: %#p", getcallerpc(&size));
    if((b = _allocb(size)) == nil){
        splhi();
        xsummary();
        mallocsummary();
        delay(500);
        panic("allocb: no memory for %d bytes; caller %#p", size,
            getcallerpc(&size));
    }
    setmalloctag(b, getcallerpc(&size));

    return b;
}

Block*
iallocb(int size)
{
    Block *b;
    static int m1, m2, mp;

    if(ialloc.bytes > conf.ialloc){
        if((m1++%10000)==0){
            if(mp++ > 1000){
                active.exiting = 1;
                exit(0);
            }
            iprint("iallocb: limited %lud/%lud\n",
                ialloc.bytes, conf.ialloc);
        }
        return nil;
    }

    if((b = _allocb(size)) == nil){
        if((m2++%10000)==0){
            if(mp++ > 1000){
                active.exiting = 1;
                exit(0);
            }
            iprint("iallocb: no memory %lud/%lud\n",
                ialloc.bytes, conf.ialloc);
        }
        return nil;
    }
    setmalloctag(b, getcallerpc(&size));
    b->flag = BINTR;

    ilock(&ialloc);
    ialloc.bytes += b->lim - b->base;
    iunlock(&ialloc);

    return b;
}

void
freeb(Block *b)
{
    void *dead = (void*)Bdead;
    long ref;

    if(b == nil || (ref = _xdec(&b->ref)) > 0)
        return;

    if(ref < 0){
        dumpstack();
        panic("freeb: ref %ld; caller pc %#p", ref, getcallerpc(&b));
    }

    /*
     * drivers which perform non cache coherent DMA manage their own buffer
     * pool of uncached buffers and provide their own free routine.
     */
    if(b->free) {
        b->free(b);
        return;
    }
    if(b->flag & BINTR) {
        ilock(&ialloc);
        ialloc.bytes -= b->lim - b->base;
        iunlock(&ialloc);
    }

    /* poison the block in case someone is still holding onto it */
    b->next = dead;
    b->rp = dead;
    b->wp = dead;
    b->lim = dead;
    b->base = dead;

    free(b);
}

void
checkb(Block *b, char *msg)
{
    void *dead = (void*)Bdead;

    if(b == dead)
        panic("checkb b %s %#p", msg, b);
    if(b->base == dead || b->lim == dead || b->next == dead
      || b->rp == dead || b->wp == dead){
        print("checkb: base %#p lim %#p next %#p\n",
            b->base, b->lim, b->next);
        print("checkb: rp %#p wp %#p\n", b->rp, b->wp);
        panic("checkb dead: %s", msg);
    }

    if(b->base > b->lim)
        panic("checkb 0 %s %#p %#p", msg, b->base, b->lim);
    if(b->rp < b->base)
        panic("checkb 1 %s %#p %#p", msg, b->base, b->rp);
    if(b->wp < b->base)
        panic("checkb 2 %s %#p %#p", msg, b->base, b->wp);
    if(b->rp > b->lim)
        panic("checkb 3 %s %#p %#p", msg, b->rp, b->lim);
    if(b->wp > b->lim)
        panic("checkb 4 %s %#p %#p", msg, b->wp, b->lim);
}

void
iallocsummary(void)
{
    print("ialloc %lud/%lud\n", ialloc.bytes, conf.ialloc);
}
@


\subsection*{[[files/cache.c]]}

<<cache.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

enum
{
    NHASH       = 128,
    MAXCACHE    = 1024*1024,
    NFILE       = 4096,
    NEXTENT     = 200,      /* extent allocation size */
};


typedef struct Cache Cache;
struct Cache
{
    QLock;
    int     pgno;
    Mntcache    *head;
    Mntcache    *tail;
    Mntcache    *hash[NHASH];
};

typedef struct Ecache Ecache;
struct Ecache
{
    Lock;
    int total;
    int free;
    Extent* head;
};

static KImage fscache;
static Cache cache;
static Ecache ecache;
static int maxcache = MAXCACHE;

static void
extentfree(Extent* e)
{
    lock(&ecache);
    e->next = ecache.head;
    ecache.head = e;
    ecache.free++;
    unlock(&ecache);
}

static Extent*
extentalloc(void)
{
    Extent *e;
    int i;

    lock(&ecache);
    if(ecache.head == nil){
        e = xalloc(NEXTENT*sizeof(Extent));
        if(e == nil){
            unlock(&ecache);
            return nil;
        }
        for(i = 0; i < NEXTENT; i++){
            e->next = ecache.head;
            ecache.head = e;
            e++;
        }
        ecache.free += NEXTENT;
        ecache.total += NEXTENT;
    }

    e = ecache.head;
    ecache.head = e->next;
    memset(e, 0, sizeof(Extent));
    ecache.free--;
    unlock(&ecache);

    return e;
}

void
cinit(void)
{
    int i;
    Mntcache *m;

    cache.head = xalloc(sizeof(Mntcache)*NFILE);
    m = cache.head;
    if (m == nil)
        panic("cinit: no memory");

    /* a better algorithm would be nice */
    if(conf.npage*BY2PG > 400*MB)
        maxcache = 20*MAXCACHE;
    else if(conf.npage*BY2PG > 200*MB)
        maxcache = 10*MAXCACHE;

    for(i = 0; i < NFILE-1; i++) {
        m->next = m+1;
        m->prev = m-1;
        m++;
    }

    cache.tail = m;
    cache.tail->next = 0;
    cache.head->prev = 0;

    fscache.notext = true;
}

//void
//cprint(Chan *c, Mntcache *m, char *s)
//{
//  ulong o;
//  int nb, ct;
//  Extent *e;
//
//  nb = 0;
//  ct = 1;
//  o = 0;
//  if(m->list)
//      o = m->list->start;
//  for(e = m->list; e; e = e->next) {
//      nb += e->len;
//      if(o != e->start)
//          ct = 0;
//      o = e->start+e->len;
//  }
//  pprint("%s: %#llux.%#lux %d %d %s (%d %c)\n",
//  s, m->qid.path, m->qid.vers, m->type, m->dev, c->path->s, nb, ct ? 'C' : 'N');
//
//  for(e = m->list; e; e = e->next) {
//      pprint("\t%4d %5lud %4d %#p\n",
//          e->bid, e->start, e->len, e->cache);
//  }
//}

Page*
cpage(Extent *e)
{
    /* Easy consistency check */
    if(e->cache->daddr != e->bid)
        return 0;

    return lookpage(&fscache, e->bid);
}

void
cnodata(Mntcache *m)
{
    Extent *e, *n;

    /*
     * Invalidate all extent data
     * Image lru will waste the pages
     */
    for(e = m->list; e; e = n) {
        n = e->next;
        extentfree(e);
    }
    m->list = 0;
}

void
ctail(Mntcache *m)
{
    /* Unlink and send to the tail */
    if(m->prev)
        m->prev->next = m->next;
    else
        cache.head = m->next;
    if(m->next)
        m->next->prev = m->prev;
    else
        cache.tail = m->prev;

    if(cache.tail) {
        m->prev = cache.tail;
        cache.tail->next = m;
        m->next = 0;
        cache.tail = m;
    }
    else {
        cache.head = m;
        cache.tail = m;
        m->prev = 0;
        m->next = 0;
    }
}

void
copen(Chan *c)
{
    int h;
    Extent *e, *next;
    Mntcache *m, *f, **l;

    /* directories aren't cacheable and append-only files confuse us */
    if(c->qid.type&(QTDIR|QTAPPEND))
        return;

    h = c->qid.path%NHASH;
    qlock(&cache);
    for(m = cache.hash[h]; m; m = m->hash) {
        if(m->qid.path == c->qid.path)
        if(m->qid.type == c->qid.type)
        if(m->dev == c->dev && m->type == c->type) {
            c->mcp = m;
            ctail(m);
            qunlock(&cache);

            /* File was updated, invalidate cache */
            if(m->qid.vers != c->qid.vers) {
                m->qid.vers = c->qid.vers;
                qlock(m);
                cnodata(m);
                qunlock(m);
            }
            return;
        }
    }

    /* LRU the cache headers */
    m = cache.head;
    l = &cache.hash[m->qid.path%NHASH];
    for(f = *l; f; f = f->hash) {
        if(f == m) {
            *l = m->hash;
            break;
        }
        l = &f->hash;
    }

    m->qid = c->qid;
    m->dev = c->dev;
    m->type = c->type;

    l = &cache.hash[h];
    m->hash = *l;
    *l = m;
    ctail(m);

    qlock(m);
    c->mcp = m;
    e = m->list;
    m->list = 0;
    qunlock(&cache);

    while(e) {
        next = e->next;
        extentfree(e);
        e = next;
    }
    qunlock(m);
}

static int
cdev(Mntcache *m, Chan *c)
{
    if(m->qid.path != c->qid.path)
        return 0;
    if(m->qid.type != c->qid.type)
        return 0;
    if(m->dev != c->dev)
        return 0;
    if(m->type != c->type)
        return 0;
    if(m->qid.vers != c->qid.vers)
        return 0;
    return 1;
}

int
cread(Chan *c, uchar *buf, int len, vlong off)
{
    KMap *k;
    Page *p;
    Mntcache *m;
    Extent *e, **t;
    int o, l, total;
    ulong offset;

    if(off+len > maxcache)
        return 0;

    m = c->mcp;
    if(m == 0)
        return 0;

    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return 0;
    }

    offset = off;
    t = &m->list;
    for(e = *t; e; e = e->next) {
        if(offset >= e->start && offset < e->start+e->len)
            break;
        t = &e->next;
    }

    if(e == 0) {
        qunlock(m);
        return 0;
    }

    total = 0;
    while(len) {
        p = cpage(e);
        if(p == 0) {
            *t = e->next;
            extentfree(e);
            qunlock(m);
            return total;
        }

        o = offset - e->start;
        l = len;
        if(l > e->len-o)
            l = e->len-o;

        k = kmap(p);
        if(waserror()) {
            kunmap(k);
            putpage(p);
            qunlock(m);
            nexterror();
        }

        memmove(buf, (uchar*)VA(k) + o, l);

        poperror();
        kunmap(k);

        putpage(p);

        buf += l;
        len -= l;
        offset += l;
        total += l;
        t = &e->next;
        e = e->next;
        if(e == 0 || e->start != offset)
            break;
    }

    qunlock(m);
    return total;
}

Extent*
cchain(uchar *buf, ulong offset, int len, Extent **tail)
{
    int l;
    Page *p;
    KMap *k;
    Extent *e, *start, **t;

    start = 0;
    *tail = 0;
    t = &start;
    while(len) {
        e = extentalloc();
        if(e == 0)
            break;

        p = auxpage();
        if(p == 0) {
            extentfree(e);
            break;
        }
        l = len;
        if(l > BY2PG)
            l = BY2PG;

        e->cache = p;
        e->start = offset;
        e->len = l;

        qlock(&cache);
        e->bid = cache.pgno;
        cache.pgno += BY2PG;
        /* wrap the counter; low bits are unused by pghash but checked by lookpage */
        if((cache.pgno & ~(BY2PG-1)) == 0){
            if(cache.pgno == BY2PG-1){
                print("cache wrapped\n");
                cache.pgno = 0;
            }else
                cache.pgno++;
        }
        qunlock(&cache);

        p->daddr = e->bid;
        k = kmap(p);
        if(waserror()) {        /* buf may be virtual */
            kunmap(k);
            nexterror();
        }
        memmove((void*)VA(k), buf, l);
        poperror();
        kunmap(k);

        cachepage(p, &fscache);
        putpage(p);

        buf += l;
        offset += l;
        len -= l;

        *t = e;
        *tail = e;
        t = &e->next;
    }

    return start;
}

int
cpgmove(Extent *e, uchar *buf, int boff, int len)
{
    Page *p;
    KMap *k;

    p = cpage(e);
    if(p == 0)
        return 0;

    k = kmap(p);
    if(waserror()) {        /* Since buf may be virtual */
        kunmap(k);
        nexterror();
    }

    memmove((uchar*)VA(k)+boff, buf, len);

    poperror();
    kunmap(k);
    putpage(p);

    return 1;
}

void
cupdate(Chan *c, uchar *buf, int len, vlong off)
{
    Mntcache *m;
    Extent *tail;
    Extent *e, *f, *p;
    int o, ee, eblock;
    ulong offset;

    if(off > maxcache || len == 0)
        return;

    m = c->mcp;
    if(m == 0)
        return;
    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return;
    }

    /*
     * Find the insertion point
     */
    offset = off;
    p = 0;
    for(f = m->list; f; f = f->next) {
        if(f->start > offset)
            break;
        p = f;
    }

    /* trim if there is a successor */
    eblock = offset+len;
    if(f != 0 && eblock > f->start) {
        len -= (eblock - f->start);
        if(len <= 0) {
            qunlock(m);
            return;
        }
    }

    if(p == 0) {        /* at the head */
        e = cchain(buf, offset, len, &tail);
        if(e != 0) {
            m->list = e;
            tail->next = f;
        }
        qunlock(m);
        return;
    }

    /* trim to the predecessor */
    ee = p->start+p->len;
    if(offset < ee) {
        o = ee - offset;
        len -= o;
        if(len <= 0) {
            qunlock(m);
            return;
        }
        buf += o;
        offset += o;
    }

    /* try and pack data into the predecessor */
    if(offset == ee && p->len < BY2PG) {
        o = len;
        if(o > BY2PG - p->len)
            o = BY2PG - p->len;
        if(cpgmove(p, buf, p->len, o)) {
            p->len += o;
            buf += o;
            len -= o;
            offset += o;
            if(len <= 0) {
if(f && p->start + p->len > f->start) print("CACHE: p->start=%uld p->len=%d f->start=%uld\n", p->start, p->len, f->start);
                qunlock(m);
                return;
            }
        }
    }

    e = cchain(buf, offset, len, &tail);
    if(e != 0) {
        p->next = e;
        tail->next = f;
    }
    qunlock(m);
}

void
cwrite(Chan* c, uchar *buf, int len, vlong off)
{
    int o, eo;
    Mntcache *m;
    ulong eblock, ee;
    Extent *p, *f, *e, *tail;
    ulong offset;

    if(off > maxcache || len == 0)
        return;

    m = c->mcp;
    if(m == 0)
        return;

    qlock(m);
    if(cdev(m, c) == 0) {
        qunlock(m);
        return;
    }

    offset = off;
    m->qid.vers++;
    c->qid.vers++;

    p = 0;
    for(f = m->list; f; f = f->next) {
        if(f->start >= offset)
            break;
        p = f;
    }

    if(p != 0) {
        ee = p->start+p->len;
        eo = offset - p->start;
        /* pack in predecessor if there is space */
        if(offset <= ee && eo < BY2PG) {
            o = len;
            if(o > BY2PG - eo)
                o = BY2PG - eo;
            if(cpgmove(p, buf, eo, o)) {
                if(eo+o > p->len)
                    p->len = eo+o;
                buf += o;
                len -= o;
                offset += o;
            }
        }
    }

    /* free the overlap -- it's a rare case */
    eblock = offset+len;
    while(f && f->start < eblock) {
        e = f->next;
        extentfree(f);
        f = e;
    }

    /* link the block (if any) into the middle */
    e = cchain(buf, offset, len, &tail);
    if(e != 0) {
        tail->next = f;
        f = e;
    }

    if(p == 0)
        m->list = f;
    else
        p->next = f;
    qunlock(m);
}
@


\subsection*{[[files/chan.c]]}

<<chan.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

char*       skipslash(char*);

int chandebug=0;        /* toggled by sysr1 */
#define DBG if(chandebug)iprint

enum
{
    PATHSLOP    = 20,
    PATHMSLOP   = 20,
};

struct
{
    Lock;
    int fid;
    Chan    *free;
    Chan    *list;
}chanalloc;

typedef struct Elemlist Elemlist;

struct Elemlist
{
    char    *aname; /* original name */
    char    *name;  /* copy of name, so '/' can be overwritten */
    int nelems;
    char    **elems;
    int *off;
    int mustbedir;
    int nerror;
    int prefix;
};

#define SEP(c) ((c) == 0 || (c) == '/')

//unused
//static void
//dumpmount(void)       /* DEBUGGING */
//{
//  Pgrp *pg;
//  Mount *t;
//  Mhead **h, **he, *f;
//
//  if(up == nil){
//      print("no process for dumpmount\n");
//      return;
//  }
//  pg = up->pgrp;
//  if(pg == nil){
//      print("no pgrp for dumpmount\n");
//      return;
//  }
//  rlock(&pg->ns);
//  if(waserror()){
//      runlock(&pg->ns);
//      nexterror();
//  }
//
//  he = &pg->mnthash[MNTHASH];
//  for(h = pg->mnthash; h < he; h++){
//      for(f = *h; f; f = f->hash){
//          print("head: %#p: %s %#llux.%lud %C %lud -> \n", f,
//              f->from->path->s, f->from->qid.path,
//              f->from->qid.vers, devtab[f->from->type]->dc,
//              f->from->dev);
//          for(t = f->mount; t; t = t->next)
//              print("\t%#p: %s (umh %#p) (path %#.8llux dev %C %lud)\n", t, t->to->path->s, t->to->umh, t->to->qid.path, devtab[t->to->type]->dc, t->to->dev);
//      }
//  }
//  poperror();
//  runlock(&pg->ns);
//}

char*
chanpath(Chan *c)
{
    if(c == nil)
        return "<nil chan>";
    if(c->path == nil)
        return "<nil path>";
    if(c->path->s == nil)
        return "<nil path.s>";
    return c->path->s;
}

int
isdotdot(char *p)
{
    return p[0]=='.' && p[1]=='.' && p[2]=='\0';
}


int
emptystr(char *s)
{
    if(s == nil)
        return 1;
    if(s[0] == '\0')
        return 1;
    return 0;
}

static int debugstart = 1;

void
chandevreset(void)
{
    int i;

    todinit();  /* avoid later reentry causing infinite recursion */
    debugstart = getconf("*debugstart") != nil;
    if(debugstart)
        iprint("reset:");
    for(i=0; devtab[i] != nil; i++) {
        if(debugstart)
            iprint(" %s", devtab[i]->name);
        devtab[i]->reset();
    }
    if(debugstart)
        iprint("\n");
}

void
chandevinit(void)
{
    int i;

    if(debugstart)
        iprint("init:");
    for(i=0; devtab[i] != nil; i++) {
        if(debugstart)
            iprint(" %s", devtab[i]->name);
        devtab[i]->init();
    }
    if(debugstart)
        iprint("\n");
}

void
chandevshutdown(void)
{
    int i;
    
    /* shutdown in reverse order */
    for(i=0; devtab[i] != nil; i++)
        ;
    for(i--; i >= 0; i--)
        devtab[i]->shutdown();
}

Chan*
newchan(void)
{
    Chan *c;

    lock(&chanalloc);
    c = chanalloc.free;
    if(c != 0)
        chanalloc.free = c->next;
    unlock(&chanalloc);

    if(c == nil){
        c = smalloc(sizeof(Chan));
        lock(&chanalloc);
        c->fid = ++chanalloc.fid;
        c->link = chanalloc.list;
        chanalloc.list = c;
        unlock(&chanalloc);
    }

    /* if you get an error before associating with a dev,
       close calls rootclose, a nop */
    c->type = 0;
    c->flag = 0;
    c->ref = 1;
    c->dev = 0;
    c->offset = 0;
    c->devoffset = 0;
    c->iounit = 0;
    c->umh = 0;
    c->uri = 0;
    c->dri = 0;
    c->aux = 0;
    c->mchan = 0;
    c->mcp = 0;
    c->mux = 0;
    memset(&c->mqid, 0, sizeof(c->mqid));
    c->path = 0;
    c->ismtpt = 0;
    
    return c;
}

Ref npath;

Path*
newpath(char *s)
{
    int i;
    Path *p;

    p = smalloc(sizeof(Path));
    i = strlen(s);
    p->len = i;
    p->alen = i+PATHSLOP;
    p->s = smalloc(p->alen);
    memmove(p->s, s, i+1);
    p->ref = 1;
    incref(&npath);

    /*
     * Cannot use newpath for arbitrary names because the mtpt 
     * array will not be populated correctly.  The names #/ and / are
     * allowed, but other names with / in them draw warnings.
     */
    if(strchr(s, '/') && strcmp(s, "#/") != 0 && strcmp(s, "/") != 0)
        print("newpath: %s from %#p\n", s, getcallerpc(&s));

    p->mlen = 1;
    p->malen = PATHMSLOP;
    p->mtpt = smalloc(p->malen*sizeof p->mtpt[0]);
    return p;
}

//@Scheck: not dead, used below
static Path*
copypath(Path *p)
{
    int i;
    Path *pp;
    
    pp = smalloc(sizeof(Path));
    pp->ref = 1;
    incref(&npath);
    DBG("copypath %s %p => %p\n", p->s, p, pp);
    
    pp->len = p->len;
    pp->alen = p->alen;
    pp->s = smalloc(p->alen);
    memmove(pp->s, p->s, p->len+1);
    
    pp->mlen = p->mlen;
    pp->malen = p->malen;
    pp->mtpt = smalloc(p->malen*sizeof pp->mtpt[0]);
    for(i=0; i<pp->mlen; i++){
        pp->mtpt[i] = p->mtpt[i];
        if(pp->mtpt[i])
            incref(pp->mtpt[i]);
    }

    return pp;
}

void
pathclose(Path *p)
{
    int i;
    
    if(p == nil)
        return;
//XXX
    DBG("pathclose %p %s ref=%ld =>", p, p->s, p->ref);
    for(i=0; i<p->mlen; i++)
        DBG(" %p", p->mtpt[i]);
    DBG("\n");

    if(decref(p))
        return;
    decref(&npath);
    free(p->s);
    for(i=0; i<p->mlen; i++)
        if(p->mtpt[i])
            cclose(p->mtpt[i]);
    free(p->mtpt);
    free(p);
}

/*
 * In place, rewrite name to compress multiple /, eliminate ., and process ..
 * (Really only called to remove a trailing .. that has been added.
 * Otherwise would need to update n->mtpt as well.)
 */
static void
fixdotdotname(Path *p)
{
    char *r;

    if(p->s[0] == '#'){
        r = strchr(p->s, '/');
        if(r == nil)
            return;
        cleanname(r);

        /*
         * The correct name is #i rather than #i/,
         * but the correct name of #/ is #/.
         */
        if(strcmp(r, "/")==0 && p->s[1] != '/')
            *r = '\0';
    }else
        cleanname(p->s);
    p->len = strlen(p->s);
}

static Path*
uniquepath(Path *p)
{
    Path *new;
    
    if(p->ref > 1){
        /* copy on write */
        new = copypath(p);
        pathclose(p);
        p = new;
    }
    return p;
}

static Path*
addelem(Path *p, char *s, Chan *from)
{
    char *t;
    int a, i;
    Chan *c, **tt;

    if(s[0]=='.' && s[1]=='\0')
        return p;

    p = uniquepath(p);

    i = strlen(s);
    if(p->len+1+i+1 > p->alen){
        a = p->len+1+i+1 + PATHSLOP;
        t = smalloc(a);
        memmove(t, p->s, p->len+1);
        free(p->s);
        p->s = t;
        p->alen = a;
    }
    /* don't insert extra slash if one is present */
    if(p->len>0 && p->s[p->len-1]!='/' && s[0]!='/')
        p->s[p->len++] = '/';
    memmove(p->s+p->len, s, i+1);
    p->len += i;
    if(isdotdot(s)){
        fixdotdotname(p);
        DBG("addelem %s .. => rm %p\n", p->s, p->mtpt[p->mlen-1]);
        if(p->mlen>1 && (c = p->mtpt[--p->mlen])){
            p->mtpt[p->mlen] = nil;
            cclose(c);
        }
    }else{
        if(p->mlen >= p->malen){
            p->malen = p->mlen+1+PATHMSLOP;
            tt = smalloc(p->malen*sizeof tt[0]);
            memmove(tt, p->mtpt, p->mlen*sizeof tt[0]);
            free(p->mtpt);
            p->mtpt = tt;
        }
        DBG("addelem %s %s => add %p\n", p->s, s, from);
        p->mtpt[p->mlen++] = from;
        if(from)
            incref(from);
    }
    return p;
}

void
chanfree(Chan *c)
{
    c->flag = CFREE;

    if(c->dirrock != nil){
        free(c->dirrock);
        c->dirrock = 0;
        c->nrock = 0;
        c->mrock = 0;
    }
    if(c->umh != nil){
        putmhead(c->umh);
        c->umh = nil;
    }
    if(c->umc != nil){
        cclose(c->umc);
        c->umc = nil;
    }
    if(c->mux != nil){
        muxclose(c->mux);
        c->mux = nil;
    }
    if(c->mchan != nil){
        cclose(c->mchan);
        c->mchan = nil;
    }

    pathclose(c->path);
    c->path = nil;

    lock(&chanalloc);
    c->next = chanalloc.free;
    chanalloc.free = c;
    unlock(&chanalloc);
}

void
chan_cclose(Chan *c)
{
    if(c->flag&CFREE)
        panic("cclose %#p", getcallerpc(&c));

    DBG("cclose %p name=%s ref=%ld\n", c, c->path->s, c->ref);
    if(decref(c))
        return;

    if(!waserror()){
        devtab[c->type]->close(c);
        poperror();
    }
    chanfree(c);
}

/*
 * Queue a chan to be closed by one of the clunk procs.
 */
struct {
    Chan *head;
    Chan *tail;
    int nqueued;
    int nclosed;
    Lock l;
    QLock q;
    Rendez r;
} clunkq;
void closeproc(void*);

void
ccloseq(Chan *c)
{
    if(c->flag&CFREE)
        panic("cclose %#p", getcallerpc(&c));

    DBG("ccloseq %p name=%s ref=%ld\n", c, c->path->s, c->ref);

    if(decref(c))
        return;

    lock(&clunkq.l);
    clunkq.nqueued++;
    c->next = nil;
    if(clunkq.head)
        clunkq.tail->next = c;
    else
        clunkq.head = c;
    clunkq.tail = c;
    unlock(&clunkq.l);

    if(!wakeup(&clunkq.r))
        kproc("closeproc", closeproc, nil); 
}

static int
clunkwork(void*)
{
    return clunkq.head != nil;
}

void
closeproc(void*)
{
    Chan *c;

    for(;;){
        qlock(&clunkq.q);
        if(clunkq.head == nil){
            if(!waserror()){
                tsleep(&clunkq.r, clunkwork, nil, 5000);
                poperror();
            }
            if(clunkq.head == nil){
                qunlock(&clunkq.q);
                pexit("no work", 1);
            }
        }
        lock(&clunkq.l);
        c = clunkq.head;
        clunkq.head = c->next;
        clunkq.nclosed++;
        unlock(&clunkq.l);
        qunlock(&clunkq.q);
        if(!waserror()){
            devtab[c->type]->close(c);
            poperror();
        }
        chanfree(c);
    }
}

/*
 * Make sure we have the only copy of c.  (Copy on write.)
 */
Chan*
cunique(Chan *c)
{
    Chan *nc;

    if(c->ref != 1){
        nc = cclone(c);
        cclose(c);
        c = nc;
    }

    return c;
}

int
eqqid(Qid a, Qid b)
{
    return a.path==b.path && a.vers==b.vers;
}

int
eqchan(Chan *a, Chan *b, int skipvers)
{
    if(a->qid.path != b->qid.path)
        return 0;
    if(!skipvers && a->qid.vers!=b->qid.vers)
        return 0;
    if(a->type != b->type)
        return 0;
    if(a->dev != b->dev)
        return 0;
    return 1;
}

int
eqchantdqid(Chan *a, int type, int dev, Qid qid, int skipvers)
{
    if(a->qid.path != qid.path)
        return 0;
    if(!skipvers && a->qid.vers!=qid.vers)
        return 0;
    if(a->type != type)
        return 0;
    if(a->dev != dev)
        return 0;
    return 1;
}

Mhead*
newmhead(Chan *from)
{
    Mhead *mh;

    mh = smalloc(sizeof(Mhead));
    mh->ref = 1;
    mh->from = from;
    incref(from);
    return mh;
}

int
cmount(Chan **newp, Chan *old, int flag, char *spec)
{
    int order, flg;
    Chan *new;
    Mhead *m, **l, *mh;
    Mount *nm, *f, *um, **h;
    Pgrp *pg;

    if(QTDIR & (old->qid.type^(*newp)->qid.type))
        error(Emount);

    if(old->umh)
        print("cmount: unexpected umh, caller %#p\n", getcallerpc(&newp));

    order = flag&MORDER;

    if((old->qid.type&QTDIR)==0 && order != MREPL)
        error(Emount);

    new = *newp;
    mh = new->umh;

    /*
     * Not allowed to bind when the old directory is itself a union. 
     * (Maybe it should be allowed, but I don't see what the semantics
     * would be.)
     *
     * We need to check mh->mount->next to tell unions apart from
     * simple mount points, so that things like
     *  mount -c fd /root
     *  bind -c /root /
     * work.  
     * 
     * The check of mount->mflag allows things like
     *  mount fd /root
     *  bind -c /root /
     * 
     * This is far more complicated than it should be, but I don't
     * see an easier way at the moment.
     */
    if((flag&MCREATE) && mh && mh->mount
    && (mh->mount->next || !(mh->mount->mflag&MCREATE)))
        error(Emount);

    pg = up->pgrp;
    wlock(&pg->ns);

    l = &MOUNTH(pg, old->qid);
    for(m = *l; m; m = m->hash){
        if(eqchan(m->from, old, 1))
            break;
        l = &m->hash;
    }

    if(m == nil){
        /*
         *  nothing mounted here yet.  create a mount
         *  head and add to the hash table.
         */
        m = newmhead(old);
        *l = m;

        /*
         *  if this is a union mount, add the old
         *  node to the mount chain.
         */
        if(order != MREPL)
            m->mount = newmount(m, old, 0, 0);
    }
    wlock(&m->lock);
    if(waserror()){
        wunlock(&m->lock);
        nexterror();
    }
    wunlock(&pg->ns);

    nm = newmount(m, new, flag, spec);
    if(mh != nil && mh->mount != nil){
        /*
         *  copy a union when binding it onto a directory
         */
        flg = order;
        if(order == MREPL)
            flg = MAFTER;
        h = &nm->next;
        um = mh->mount;
        for(um = um->next; um; um = um->next){
            f = newmount(m, um->to, flg, um->spec);
            *h = f;
            h = &f->next;
        }
    }

    if(m->mount && order == MREPL){
        mountfree(m->mount);
        m->mount = 0;
    }

    if(flag & MCREATE)
        nm->mflag |= MCREATE;

    if(m->mount && order == MAFTER){
        for(f = m->mount; f->next; f = f->next)
            ;
        f->next = nm;
    }else{
        for(f = nm; f->next; f = f->next)
            ;
        f->next = m->mount;
        m->mount = nm;
    }

    wunlock(&m->lock);
    poperror();
    return nm->mountid;
}

void
cunmount(Chan *mnt, Chan *mounted)
{
    Pgrp *pg;
    Mhead *m, **l;
    Mount *f, **p;

    if(mnt->umh)    /* should not happen */
        print("cunmount newp extra umh %p has %p\n", mnt, mnt->umh);

    /*
     * It _can_ happen that mounted->umh is non-nil, 
     * because mounted is the result of namec(Aopen)
     * (see sysfile.c:/^sysunmount).
     * If we open a union directory, it will have a umh.
     * Although surprising, this is okay, since the
     * cclose will take care of freeing the umh.
     */

    pg = up->pgrp;
    wlock(&pg->ns);

    l = &MOUNTH(pg, mnt->qid);
    for(m = *l; m; m = m->hash){
        if(eqchan(m->from, mnt, 1))
            break;
        l = &m->hash;
    }

    if(m == 0){
        wunlock(&pg->ns);
        error(Eunmount);
    }

    wlock(&m->lock);
    if(mounted == 0){
        *l = m->hash;
        wunlock(&pg->ns);
        mountfree(m->mount);
        m->mount = nil;
        cclose(m->from);
        wunlock(&m->lock);
        putmhead(m);
        return;
    }

    p = &m->mount;
    for(f = *p; f; f = f->next){
        /* BUG: Needs to be 2 pass */
        if(eqchan(f->to, mounted, 1) ||
          (f->to->mchan && eqchan(f->to->mchan, mounted, 1))){
            *p = f->next;
            f->next = 0;
            mountfree(f);
            if(m->mount == nil){
                *l = m->hash;
                cclose(m->from);
                wunlock(&m->lock);
                wunlock(&pg->ns);
                putmhead(m);
                return;
            }
            wunlock(&m->lock);
            wunlock(&pg->ns);
            return;
        }
        p = &f->next;
    }
    wunlock(&m->lock);
    wunlock(&pg->ns);
    error(Eunion);
}

Chan*
cclone(Chan *c)
{
    Chan *nc;
    Walkqid *wq;

    wq = devtab[c->type]->walk(c, nil, nil, 0);
    if(wq == nil)
        error("clone failed");
    nc = wq->clone;
    free(wq);
    nc->path = c->path;
    if(c->path)
        incref(c->path);
    return nc;
}

/* also used by sysfile.c:/^mountfix */
int
findmount(Chan **cp, Mhead **mp, int type, int dev, Qid qid)
{
    Pgrp *pg;
    Mhead *m;

    pg = up->pgrp;
    rlock(&pg->ns);
    for(m = MOUNTH(pg, qid); m; m = m->hash){
        rlock(&m->lock);
        if(m->from == nil){
            print("m %p m->from 0\n", m);
            runlock(&m->lock);
            continue;
        }
        if(eqchantdqid(m->from, type, dev, qid, 1)){
            runlock(&pg->ns);
            if(mp != nil){
                incref(m);
                if(*mp != nil)
                    putmhead(*mp);
                *mp = m;
            }
            if(*cp != nil)
                cclose(*cp);
            incref(m->mount->to);
            *cp = m->mount->to;
            runlock(&m->lock);
            return 1;
        }
        runlock(&m->lock);
    }

    runlock(&pg->ns);
    return 0;
}

/*
 * Calls findmount but also updates path.
 */
static int
domount(Chan **cp, Mhead **mp, Path **path)
{
    Chan **lc;
    Path *p;

    if(findmount(cp, mp, (*cp)->type, (*cp)->dev, (*cp)->qid) == 0)
        return 0;

    if(path){
        p = *path;
        p = uniquepath(p);
        if(p->mlen <= 0)
            print("domount: path %s has mlen==%d\n", p->s, p->mlen);
        else{
            lc = &p->mtpt[p->mlen-1];
DBG("domount %p %s => add %p (was %p)\n", p, p->s, (*mp)->from, p->mtpt[p->mlen-1]);
            incref((*mp)->from);
            if(*lc)
                cclose(*lc);
            *lc = (*mp)->from;
        }
        *path = p;
    }
    return 1;
}

/*
 * If c is the right-hand-side of a mount point, returns the left hand side.
 * Changes name to reflect the fact that we've uncrossed the mountpoint,
 * so name had better be ours to change!
 */
static Chan*
undomount(Chan *c, Path *path)
{
    Chan *nc;

    if(path->ref != 1 || path->mlen == 0)
        print("undomount: path %s ref %ld mlen %d caller %#p\n",
            path->s, path->ref, path->mlen, getcallerpc(&c));

    if(path->mlen>0 && (nc=path->mtpt[path->mlen-1]) != nil){
DBG("undomount %p %s => remove %p\n", path, path->s, nc);
        cclose(c);
        path->mtpt[path->mlen-1] = nil;
        c = nc;
    }
    return c;
}

/*
 * Call dev walk but catch errors.
 */
static Walkqid*
ewalk(Chan *c, Chan *nc, char **name, int nname)
{
    Walkqid *wq;

    if(waserror())
        return nil;
    wq = devtab[c->type]->walk(c, nc, name, nname);
    poperror();
    return wq;
}

/*
 * Either walks all the way or not at all.  No partial results in *cp.
 * *nerror is the number of names to display in an error message.
 */
static char Edoesnotexist[] = "does not exist";
int
walk(Chan **cp, char **names, int nnames, int nomount, int *nerror)
{
    int dev, didmount, dotdot, i, n, nhave, ntry, type;
    Chan *c, *nc, *mtpt;
    Path *path;
    Mhead *mh, *nmh;
    Mount *f;
    Walkqid *wq;

    c = *cp;
    incref(c);
    path = c->path;
    incref(path);
    mh = nil;

    /*
     * While we haven't gotten all the way down the path:
     *    1. step through a mount point, if any
     *    2. send a walk request for initial dotdot or initial prefix without dotdot
     *    3. move to the first mountpoint along the way.
     *    4. repeat.
     *
     * Each time through the loop:
     *
     *  If didmount==0, c is on the undomount side of the mount point.
     *  If didmount==1, c is on the domount side of the mount point.
     *  Either way, c's full path is path.
     */
    didmount = 0;
    for(nhave=0; nhave<nnames; nhave+=n){
        if((c->qid.type&QTDIR)==0){
            if(nerror)
                *nerror = nhave;
            pathclose(path);
            cclose(c);
            strcpy(up->errstr, Enotdir);
            if(mh != nil)
                putmhead(mh);
            return -1;
        }
        ntry = nnames - nhave;
        if(ntry > MAXWELEM)
            ntry = MAXWELEM;
        dotdot = 0;
        for(i=0; i<ntry; i++){
            if(isdotdot(names[nhave+i])){
                if(i==0){
                    dotdot = 1;
                    ntry = 1;
                }else
                    ntry = i;
                break;
            }
        }

        if(!dotdot && !nomount && !didmount)
            domount(&c, &mh, &path);
        
        type = c->type;
        dev = c->dev;

        if((wq = ewalk(c, nil, names+nhave, ntry)) == nil){
            /* try a union mount, if any */
            if(mh && !nomount){
                /*
                 * mh->mount->to == c, so start at mh->mount->next
                 */
                rlock(&mh->lock);
                f = mh->mount;
                for(f = (f? f->next: f); f; f = f->next)
                    if((wq = ewalk(f->to, nil, names+nhave, ntry)) != nil)
                        break;
                runlock(&mh->lock);
                if(f != nil){
                    type = f->to->type;
                    dev = f->to->dev;
                }
            }
            if(wq == nil){
                cclose(c);
                pathclose(path);
                if(nerror)
                    *nerror = nhave+1;
                if(mh != nil)
                    putmhead(mh);
                return -1;
            }
        }

        didmount = 0;
        if(dotdot){
            assert(wq->nqid == 1);
            assert(wq->clone != nil);

            path = addelem(path, "..", nil);
            nc = undomount(wq->clone, path);
            nmh = nil;
            n = 1;
        }else{
            nc = nil;
            nmh = nil;
            if(!nomount){
                for(i=0; i<wq->nqid && i<ntry-1; i++){
                    if(findmount(&nc, &nmh, type, dev, wq->qid[i])){
                        didmount = 1;
                        break;
                    }
                }
            }
            if(nc == nil){  /* no mount points along path */
                if(wq->clone == nil){
                    cclose(c);
                    pathclose(path);
                    if(wq->nqid==0 || (wq->qid[wq->nqid-1].type&QTDIR)){
                        if(nerror)
                            *nerror = nhave+wq->nqid+1;
                        strcpy(up->errstr, Edoesnotexist);
                    }else{
                        if(nerror)
                            *nerror = nhave+wq->nqid;
                        strcpy(up->errstr, Enotdir);
                    }
                    free(wq);
                    if(mh != nil)
                        putmhead(mh);
                    return -1;
                }
                n = wq->nqid;
                nc = wq->clone;
            }else{      /* stopped early, at a mount point */
                didmount = 1;
                if(wq->clone != nil){
                    cclose(wq->clone);
                    wq->clone = nil;
                }
                n = i+1;
            }
            for(i=0; i<n; i++){
                mtpt = nil;
                if(i==n-1 && nmh)
                    mtpt = nmh->from;
                path = addelem(path, names[nhave+i], mtpt);
            }
        }
        cclose(c);
        c = nc;
        putmhead(mh);
        mh = nmh;
        free(wq);
    }

    putmhead(mh);

    c = cunique(c);

    if(c->umh != nil){  //BUG
        print("walk umh\n");
        putmhead(c->umh);
        c->umh = nil;
    }

    pathclose(c->path);
    c->path = path;

    cclose(*cp);
    *cp = c;
    if(nerror)
        *nerror = nhave;
    return 0;
}

/*
 * c is a mounted non-creatable directory.  find a creatable one.
 */
Chan*
createdir(Chan *c, Mhead *m)
{
    Chan *nc;
    Mount *f;

    rlock(&m->lock);
    if(waserror()){
        runlock(&m->lock);
        nexterror();
    }
    for(f = m->mount; f; f = f->next){
        if(f->mflag&MCREATE){
            nc = cclone(f->to);
            runlock(&m->lock);
            poperror();
            cclose(c);
            return nc;
        }
    }
    error(Enocreate);
    return 0;
}

void
saveregisters(void)
{
}

static void
growparse(Elemlist *e)
{
    char **new;
    int *inew;
    enum { Delta = 8 };

    if(e->nelems % Delta == 0){
        new = smalloc((e->nelems+Delta) * sizeof(char*));
        memmove(new, e->elems, e->nelems*sizeof(char*));
        free(e->elems);
        e->elems = new;
        inew = smalloc((e->nelems+Delta+1) * sizeof(int));
        memmove(inew, e->off, (e->nelems+1)*sizeof(int));
        free(e->off);
        e->off = inew;
    }
}

/*
 * The name is known to be valid.
 * Copy the name so slashes can be overwritten.
 * An empty string will set nelem=0.
 * A path ending in / or /. or /.//./ etc. will have
 * e.mustbedir = 1, so that we correctly
 * reject, e.g., "/adm/users/." when /adm/users is a file
 * rather than a directory.
 */
static void
parsename(char *aname, Elemlist *e)
{
    char *name, *slash;

    kstrdup(&e->name, aname);
    name = e->name;
    e->nelems = 0;
    e->elems = nil;
    e->off = smalloc(sizeof(int));
    e->off[0] = skipslash(name) - name;
    for(;;){
        name = skipslash(name);
        if(*name == '\0'){
            e->off[e->nelems] = name+strlen(name) - e->name;
            e->mustbedir = 1;
            break;
        }
        growparse(e);
        e->elems[e->nelems++] = name;
        slash = utfrune(name, '/');
        if(slash == nil){
            e->off[e->nelems] = name+strlen(name) - e->name;
            e->mustbedir = 0;
            break;
        }
        e->off[e->nelems] = slash - e->name;
        *slash++ = '\0';
        name = slash;
    }
    
    if(0 && chandebug){
        int i;
        
        print("parsename %s:", e->name);
        for(i=0; i<=e->nelems; i++)
            print(" %d", e->off[i]);
        print("\n");
    }
}

void*
memrchr(void *va, int c, long n)
{
    uchar *a, *e;

    a = va;
    for(e=a+n-1; e>a; e--)
        if(*e == c)
            return e;
    return nil;
}

void
namelenerror(char *aname, int len, char *err)
{
    char *ename, *name, *next;
    int i, errlen;

    /*
     * If the name is short enough, just use the whole thing.
     */
    errlen = strlen(err);
    if(len < ERRMAX/3 || len+errlen < 2*ERRMAX/3)
        snprint(up->genbuf, sizeof up->genbuf, "%.*s", 
            utfnlen(aname, len), aname);
    else{
        /*
         * Print a suffix of the name, but try to get a little info.
         */
        ename = aname+len;
        next = ename;
        do{
            name = next;
            next = memrchr(aname, '/', name-aname);
            if(next == nil)
                next = aname;
            len = ename-next;
        }while(len < ERRMAX/3 || len + errlen < 2*ERRMAX/3);

        /*
         * If the name is ridiculously long, chop it.
         */
        if(name == ename){
            name = ename-ERRMAX/4;
            if(name <= aname)
                panic("bad math in namelenerror");
            /* walk out of current UTF sequence */
            for(i=0; (*name&0xC0)==0x80 && i<UTFmax; i++)
                name++;
        }
        snprint(up->genbuf, sizeof up->genbuf, "...%.*s",
            utfnlen(name, ename-name), name);
    }               
    snprint(up->errstr, ERRMAX, "%#q %s", up->genbuf, err);
    nexterror();
}

void
nameerror(char *name, char *err)
{
    namelenerror(name, strlen(name), err);
}

/*
 * Turn a name into a channel.
 * &name[0] is known to be a valid address.  It may be a kernel address.
 *
 * Opening with amode Aopen, Acreate, Aremove, or Aaccess guarantees
 * that the result will be the only reference to that particular fid.
 * This is necessary since we might pass the result to
 * devtab[]->remove().
 *
 * Opening Atodir or Amount does not guarantee this.
 *
 * Under certain circumstances, opening Aaccess will cause
 * an unnecessary clone in order to get a cunique Chan so it
 * can attach the correct name.  Sysstat and sys_stat need the
 * correct name so they can rewrite the stat info.
 */
Chan*
namec(char *aname, int amode, int omode, ulong perm)
{
    int len, n, t, nomount;
    Chan *c, *cnew;
    Path *path;
    Elemlist e;
    Rune r;
    Mhead *m;
    char *createerr, tmperrbuf[ERRMAX];
    char *name;

    if(aname[0] == '\0')
        error("empty file name");
    aname = validnamedup(aname, 1);
    if(waserror()){
        free(aname);
        nexterror();
    }
    DBG("namec %s %d %d\n", aname, amode, omode);
    name = aname;

    /*
     * Find the starting off point (the current slash, the root of
     * a device tree, or the current dot) as well as the name to
     * evaluate starting there.
     */
    nomount = 0;
    switch(name[0]){
    case '/':
        c = up->slash;
        incref(c);
        break;
    
    case '#':
        nomount = 1;
        up->genbuf[0] = '\0';
        n = 0;
        while(*name != '\0' && (*name != '/' || n < 2)){
            if(n >= sizeof(up->genbuf)-1)
                error(Efilename);
            up->genbuf[n++] = *name++;
        }
        up->genbuf[n] = '\0';
        /*
         *  noattach is sandboxing.
         *
         *  the OK exceptions are:
         *  |  it only gives access to pipes you create
         *  d  this process's file descriptors
         *  e  this process's environment
         *  the iffy exceptions are:
         *  c  time and pid, but also cons and consctl
         *  p  control of your own processes (and unfortunately
         *     any others left unprotected)
         */
        n = chartorune(&r, up->genbuf+1)+1;
        /* actually / is caught by parsing earlier */
        if(utfrune("M", r))
            error(Enoattach);
        if(up->pgrp->noattach && utfrune("|decp", r)==nil)
            error(Enoattach);
        t = devno(r, 1);
        if(t == -1)
            error(Ebadsharp);
        if(debugstart && !devtab[t]->attached)
            print("#%C...", devtab[t]->dc);
        c = devtab[t]->attach(up->genbuf+n);
        if(debugstart && c != nil)
            devtab[t]->attached = 1;
        break;

    default:
        c = up->dot;
        incref(c);
        break;
    }

    e.aname = aname;
    e.prefix = name - aname;
    e.name = nil;
    e.elems = nil;
    e.off = nil;
    e.nelems = 0;
    e.nerror = 0;
    if(waserror()){
        cclose(c);
        free(e.name);
        free(e.elems);
        /*
         * Prepare nice error, showing first e.nerror elements of name.
         */
        if(e.nerror == 0)
            nexterror();
        strcpy(tmperrbuf, up->errstr);
        if(e.off[e.nerror]==0)
            print("nerror=%d but off=%d\n",
                e.nerror, e.off[e.nerror]);
        if(0 && chandebug)
            print("showing %d+%d/%d (of %d) of %s (%d %d)\n", e.prefix, e.off[e.nerror], e.nerror, e.nelems, aname, e.off[0], e.off[1]);
        len = e.prefix+e.off[e.nerror];
        free(e.off);
        namelenerror(aname, len, tmperrbuf);
    }

    /*
     * Build a list of elements in the name.
     */
    parsename(name, &e);

    /*
     * On create, ....
     */
    if(amode == Acreate){
        /* perm must have DMDIR if last element is / or /. */
        if(e.mustbedir && !(perm&DMDIR)){
            e.nerror = e.nelems;
            error("create without DMDIR");
        }

        /* don't try to walk the last path element just yet. */
        if(e.nelems == 0)
            error(Eexist);
        e.nelems--;
    }

    if(walk(&c, e.elems, e.nelems, nomount, &e.nerror) < 0){
        if(e.nerror < 0 || e.nerror > e.nelems){
            print("namec %s walk error nerror=%d\n", aname, e.nerror);
            e.nerror = 0;
        }
        nexterror();
    }

    if(e.mustbedir && !(c->qid.type&QTDIR))
        error("not a directory");

    if(amode == Aopen && (omode&3) == OEXEC && (c->qid.type&QTDIR))
        error("cannot exec directory");

    switch(amode){
    case Abind:
        /* no need to maintain path - cannot dotdot an Abind */
        m = nil;
        if(!nomount)
            domount(&c, &m, nil);
        if(c->umh != nil)
            putmhead(c->umh);
        c->umh = m;
        break;

    case Aaccess:
    case Aremove:
    case Aopen:
    Open:
        /* save&update the name; domount might change c */
        path = c->path;
        incref(path);
        m = nil;
        if(!nomount)
            domount(&c, &m, &path);

        /* our own copy to open or remove */
        c = cunique(c);

        /* now it's our copy anyway, we can put the name back */
        pathclose(c->path);
        c->path = path;

        /* record whether c is on a mount point */
        c->ismtpt = m!=nil;

        switch(amode){
        case Aaccess:
        case Aremove:
            putmhead(m);
            break;

        case Aopen:
        case Acreate:
if(c->umh != nil){
    print("cunique umh Open\n");
    putmhead(c->umh);
    c->umh = nil;
}
            /* only save the mount head if it's a multiple element union */
            if(m && m->mount && m->mount->next)
                c->umh = m;
            else
                putmhead(m);

            /* save registers else error() in open has wrong value of c saved */
            saveregisters();

            if(omode == OEXEC)
                c->flag &= ~CCACHE;

            c = devtab[c->type]->open(c, omode&~OCEXEC);

            if(omode & OCEXEC)
                c->flag |= CCEXEC;
            if(omode & ORCLOSE)
                c->flag |= CRCLOSE;
            break;
        }
        break;

    case Atodir:
        /*
         * Directories (e.g. for cd) are left before the mount point,
         * so one may mount on / or . and see the effect.
         */
        if(!(c->qid.type & QTDIR))
            error(Enotdir);
        break;

    case Amount:
        /*
         * When mounting on an already mounted upon directory,
         * one wants subsequent mounts to be attached to the
         * original directory, not the replacement.  Don't domount.
         */
        break;

    case Acreate:
        /*
         * We've already walked all but the last element.
         * If the last exists, try to open it OTRUNC.
         * If omode&OEXCL is set, just give up.
         */
        e.nelems++;
        e.nerror++;
        if(walk(&c, e.elems+e.nelems-1, 1, nomount, nil) == 0){
            if(omode&OEXCL)
                error(Eexist);
            omode |= OTRUNC;
            goto Open;
        }

        /*
         * The semantics of the create(2) system call are that if the
         * file exists and can be written, it is to be opened with truncation.
         * On the other hand, the create(5) message fails if the file exists.
         * If we get two create(2) calls happening simultaneously, 
         * they might both get here and send create(5) messages, but only 
         * one of the messages will succeed.  To provide the expected create(2)
         * semantics, the call with the failed message needs to try the above
         * walk again, opening for truncation.  This correctly solves the 
         * create/create race, in the sense that any observable outcome can
         * be explained as one happening before the other.
         * The create/create race is quite common.  For example, it happens
         * when two rc subshells simultaneously update the same
         * environment variable.
         *
         * The implementation still admits a create/create/remove race:
         * (A) walk to file, fails
         * (B) walk to file, fails
         * (A) create file, succeeds, returns 
         * (B) create file, fails
         * (A) remove file, succeeds, returns
         * (B) walk to file, return failure.
         *
         * This is hardly as common as the create/create race, and is really
         * not too much worse than what might happen if (B) got a hold of a
         * file descriptor and then the file was removed -- either way (B) can't do
         * anything with the result of the create call.  So we don't care about this race.
         *
         * Applications that care about more fine-grained decision of the races
         * can use the OEXCL flag to get at the underlying create(5) semantics;
         * by default we provide the common case.
         *
         * We need to stay behind the mount point in case we
         * need to do the first walk again (should the create fail).
         *
         * We also need to cross the mount point and find the directory
         * in the union in which we should be creating.
         *
         * The channel staying behind is c, the one moving forward is cnew.
         */
        m = nil;
        cnew = nil; /* is this assignment necessary? */
        if(!waserror()){    /* try create */
            if(!nomount && findmount(&cnew, &m, c->type, c->dev, c->qid))
                cnew = createdir(cnew, m);
            else{
                cnew = c;
                incref(cnew);
            }

            /*
             * We need our own copy of the Chan because we're
             * about to send a create, which will move it.  Once we have
             * our own copy, we can fix the name, which might be wrong
             * if findmount gave us a new Chan.
             */
            cnew = cunique(cnew);
            pathclose(cnew->path);
            cnew->path = c->path;
            incref(cnew->path);

            devtab[cnew->type]->create(cnew, e.elems[e.nelems-1], omode&~(OEXCL|OCEXEC), perm);
            poperror();
            if(omode & OCEXEC)
                cnew->flag |= CCEXEC;
            if(omode & ORCLOSE)
                cnew->flag |= CRCLOSE;
            if(m)
                putmhead(m);
            cclose(c);
            c = cnew;
            c->path = addelem(c->path, e.elems[e.nelems-1], nil);
            break;
        }

        /* create failed */
        cclose(cnew);
        if(m)
            putmhead(m);
        if(omode & OEXCL)
            nexterror();
        /* save error */
        createerr = up->errstr;
        up->errstr = tmperrbuf;
        /* note: we depend that walk does not error */
        if(walk(&c, e.elems+e.nelems-1, 1, nomount, nil) < 0){
            up->errstr = createerr;
            error(createerr);   /* report true error */
        }
        up->errstr = createerr;
        omode |= OTRUNC;
        goto Open;

    default:
        panic("unknown namec access %d\n", amode);
    }

    /* place final element in genbuf for e.g. exec */
    if(e.nelems > 0)
        kstrcpy(up->genbuf, e.elems[e.nelems-1], sizeof up->genbuf);
    else
        kstrcpy(up->genbuf, ".", sizeof up->genbuf);
    free(e.name);
    free(e.elems);
    free(e.off);
    poperror(); /* e c */
    free(aname);
    poperror(); /* aname */

    return c;
}

/*
 * name is valid. skip leading / and ./ as much as possible
 */
char*
skipslash(char *name)
{
    while(name[0]=='/' || (name[0]=='.' && (name[1]==0 || name[1]=='/')))
        name++;
    return name;
}

char isfrog[256]={
    /*NUL*/ 1, 1, 1, 1, 1, 1, 1, 1,
    /*BKS*/ 1, 1, 1, 1, 1, 1, 1, 1,
    /*DLE*/ 1, 1, 1, 1, 1, 1, 1, 1,
    /*CAN*/ 1, 1, 1, 1, 1, 1, 1, 1,
    ['/']   1,
    [0x7f]  1,
};

/*
 * Check that the name
 *  a) is in valid memory.
 *  b) is shorter than 2^16 bytes, so it can fit in a 9P string field.
 *  c) contains no frogs.
 * The first byte is known to be addressible by the requester, so the
 * routine works for kernel and user memory both.
 * The parameter slashok flags whether a slash character is an error
 * or a valid character.
 *
 * The parameter dup flags whether the string should be copied
 * out of user space before being scanned the second time.
 * (Otherwise a malicious thread could remove the NUL, causing us
 * to access unchecked addresses.) 
 */
static char*
validname0(char *aname, int slashok, int dup, ulong pc)
{
    char *ename, *name, *s;
    int c, n;
    Rune r;

    name = aname;
    if((ulong)name < KZERO){
        if(!dup)
            print("warning: validname called from %#p with user pointer", pc);
        ename = vmemchr(name, 0, (1<<16));
    }else
        ename = memchr(name, 0, (1<<16));

    if(ename==nil || ename-name>=(1<<16))
        error("name too long");

    s = nil;
    if(dup){
        n = ename-name;
        s = smalloc(n+1);
        memmove(s, name, n);
        s[n] = 0;
        aname = s;
        name = s;
        setmalloctag(s, pc);
    }
    
    while(*name){
        /* all characters above '~' are ok */
        c = *(uchar*)name;
        if(c >= Runeself)
            name += chartorune(&r, name);
        else{
            if(isfrog[c])
                if(!slashok || c!='/'){
                    snprint(up->genbuf, sizeof(up->genbuf), "%s: %q", Ebadchar, aname);
                    free(s);
                    error(up->genbuf);
            }
            name++;
        }
    }
    return s;
}

void
validname(char *aname, int slashok)
{
    validname0(aname, slashok, 0, getcallerpc(&aname));
}

char*
validnamedup(char *aname, int slashok)
{
    return validname0(aname, slashok, 1, getcallerpc(&aname));
}

void
isdir(Chan *c)
{
    if(c->qid.type & QTDIR)
        return;
    error(Enotdir);
}

/*
 * This is necessary because there are many
 * pointers to the top of a given mount list:
 *
 *  - the mhead in the namespace hash table
 *  - the mhead in chans returned from findmount:
 *    used in namec and then by unionread.
 *  - the mhead in chans returned from createdir:
 *    used in the open/create race protect, which is gone.
 *
 * The RWlock in the Mhead protects the mount list it contains.
 * The mount list is deleted when we cunmount.
 * The RWlock ensures that nothing is using the mount list at that time.
 *
 * It is okay to replace c->mh with whatever you want as 
 * long as you are sure you have a unique reference to it.
 *
 * This comment might belong somewhere else.
 */
void
putmhead(Mhead *m)
{
    if(m && decref(m) == 0){
        m->mount = (Mount*)0xCafeBeef;
        free(m);
    }
}

@


\subsection*{[[files/dev.c]]}

<<dev.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// was in conf/pcf.c
Dev** devtab = 0;



void
mkqid(Qid *q, vlong path, ulong vers, int type)
{
    q->type = type;
    q->vers = vers;
    q->path = path;
}

int
devno(int c, int user)
{
    int i;

    for(i = 0; devtab[i] != nil; i++) {
        if(devtab[i]->dc == c)
            return i;
    }
    if(user == 0)
        panic("devno %C %#ux", c, c);

    return -1;
}

void
devdir(Chan *c, Qid qid, char *n, vlong length, char *user, long perm, Dir *db)
{
    db->name = n;
    if(c->flag&CMSG)
        qid.type |= QTMOUNT;
    db->qid = qid;
    db->type = devtab[c->type]->dc;
    db->dev = c->dev;
    db->mode = perm;
    db->mode |= qid.type << 24;
    db->atime = seconds();
    db->mtime = kerndate;
    db->length = length;
    db->uid = user;
    db->gid = eve;
    db->muid = user;
}

/*
 * (here, Devgen is the prototype; devgen is the function in dev.c.)
 * 
 * a Devgen is expected to return the directory entry for ".."
 * if you pass it s==DEVDOTDOT (-1).  otherwise...
 * 
 * there are two contradictory rules.
 * 
 * (i) if c is a directory, a Devgen is expected to list its children
 * as you iterate s.
 * 
 * (ii) whether or not c is a directory, a Devgen is expected to list
 * its siblings as you iterate s.
 * 
 * devgen always returns the list of children in the root
 * directory.  thus it follows (i) when c is the root and (ii) otherwise.
 * many other Devgens follow (i) when c is a directory and (ii) otherwise.
 * 
 * devwalk assumes (i).  it knows that devgen breaks (i)
 * for children that are themselves directories, and explicitly catches them.
 * 
 * devstat assumes (ii).  if the Devgen in question follows (i)
 * for this particular c, devstat will not find the necessary info.
 * with our particular Devgen functions, this happens only for
 * directories, so devstat makes something up, assuming
 * c->name, c->qid, eve, DMDIR|0555.
 * 
 * devdirread assumes (i).  the callers have to make sure
 * that the Devgen satisfies (i) for the chan being read.
 */
/*
 * the zeroth element of the table MUST be the directory itself for ..
*/
int
devgen(Chan *c, char *name, Dirtab *tab, int ntab, int i, Dir *dp)
{
    if(tab == 0)
        return -1;
    if(i == DEVDOTDOT){
        /* nothing */
    }else if(name){
        for(i=1; i<ntab; i++)
            if(strcmp(tab[i].name, name) == 0)
                break;
        if(i==ntab)
            return -1;
        tab += i;
    }else{
        /* skip over the first element, that for . itself */
        i++;
        if(i >= ntab)
            return -1;
        tab += i;
    }
    devdir(c, tab->qid, tab->name, tab->length, eve, tab->perm, dp);
    return 1;
}

void
devreset(void)
{
}

void
devinit(void)
{
}

void
devshutdown(void)
{
}

Chan*
devattach(int tc, char *spec)
{
    int n;
    Chan *c;
    char *buf;

    c = newchan();
    mkqid(&c->qid, 0, 0, QTDIR);
    c->type = devno(tc, 0);
    if(spec == nil)
        spec = "";
    n = 1+UTFmax+strlen(spec)+1;
    buf = smalloc(n);
    snprint(buf, n, "#%C%s", tc, spec);
    c->path = newpath(buf);
    free(buf);
    return c;
}


Chan*
devclone(Chan *c)
{
    Chan *nc;

    if(c->flag & COPEN)
        panic("clone of open file type %C\n", devtab[c->type]->dc);

    nc = newchan();

    nc->type = c->type;
    nc->dev = c->dev;
    nc->mode = c->mode;
    nc->qid = c->qid;
    nc->offset = c->offset;
    nc->umh = nil;
    nc->aux = c->aux;
    nc->mqid = c->mqid;
    nc->mcp = c->mcp;
    return nc;
}

Walkqid*
devwalk(Chan *c, Chan *nc, char **name, int nname, Dirtab *tab, int ntab, Devgen *gen)
{
    int i, j, alloc;
    Walkqid *wq;
    char *n;
    Dir dir;

    if(nname > 0)
        isdir(c);

    alloc = 0;
    wq = smalloc(sizeof(Walkqid)+(nname-1)*sizeof(Qid));
    if(waserror()){
        if(alloc && wq->clone!=nil)
            cclose(wq->clone);
        free(wq);
        return nil;
    }
    if(nc == nil){
        nc = devclone(c);
        nc->type = 0;   /* device doesn't know about this channel yet */
        alloc = 1;
    }
    wq->clone = nc;

    for(j=0; j<nname; j++){
        if(!(nc->qid.type&QTDIR)){
            if(j==0)
                error(Enotdir);
            goto Done;
        }
        n = name[j];
        if(strcmp(n, ".") == 0){
    Accept:
            wq->qid[wq->nqid++] = nc->qid;
            continue;
        }
        if(strcmp(n, "..") == 0){
            if((*gen)(nc, nil, tab, ntab, DEVDOTDOT, &dir) != 1){
                print("devgen walk .. in dev%s %llux broken\n",
                    devtab[nc->type]->name, nc->qid.path);
                error("broken devgen");
            }
            nc->qid = dir.qid;
            goto Accept;
        }
        /*
         * Ugly problem: If we're using devgen, make sure we're
         * walking the directory itself, represented by the first
         * entry in the table, and not trying to step into a sub-
         * directory of the table, e.g. /net/net. Devgen itself
         * should take care of the problem, but it doesn't have
         * the necessary information (that we're doing a walk).
         */
        if(gen==devgen && nc->qid.path!=tab[0].qid.path)
            goto Notfound;
        for(i=0;; i++) {
            switch((*gen)(nc, n, tab, ntab, i, &dir)){
            case -1:
            Notfound:
                if(j == 0)
                    error(Enonexist);
                kstrcpy(up->errstr, Enonexist, ERRMAX);
                goto Done;
            case 0:
                continue;
            case 1:
                if(strcmp(n, dir.name) == 0){
                    nc->qid = dir.qid;
                    goto Accept;
                }
                continue;
            }
        }
    }
    /*
     * We processed at least one name, so will return some data.
     * If we didn't process all nname entries succesfully, we drop
     * the cloned channel and return just the Qids of the walks.
     */
Done:
    poperror();
    if(wq->nqid < nname){
        if(alloc)
            cclose(wq->clone);
        wq->clone = nil;
    }else if(wq->clone){
        /* attach cloned channel to same device */
        wq->clone->type = c->type;
    }
    return wq;
}

int
devstat(Chan *c, uchar *db, int n, Dirtab *tab, int ntab, Devgen *gen)
{
    int i;
    Dir dir;
    char *p, *elem;

    for(i=0;; i++){
        switch((*gen)(c, nil, tab, ntab, i, &dir)){
        case -1:
            if(c->qid.type & QTDIR){
                if(c->path == nil)
                    elem = "???";
                else if(strcmp(c->path->s, "/") == 0)
                    elem = "/";
                else
                    for(elem=p=c->path->s; *p; p++)
                        if(*p == '/')
                            elem = p+1;
                devdir(c, c->qid, elem, 0, eve, DMDIR|0555, &dir);
                n = convD2M(&dir, db, n);
                if(n == 0)
                    error(Ebadarg);
                return n;
            }

            error(Enonexist);
        case 0:
            break;
        case 1:
            if(c->qid.path == dir.qid.path) {
                if(c->flag&CMSG)
                    dir.mode |= DMMOUNT;
                n = convD2M(&dir, db, n);
                if(n == 0)
                    error(Ebadarg);
                return n;
            }
            break;
        }
    }
}

long
devdirread(Chan *c, char *d, long n, Dirtab *tab, int ntab, Devgen *gen)
{
    long m, dsz;
    Dir dir;

    for(m=0; m<n; c->dri++) {
        switch((*gen)(c, nil, tab, ntab, c->dri, &dir)){
        case -1:
            return m;

        case 0:
            break;

        case 1:
            dsz = convD2M(&dir, (uchar*)d, n-m);
            if(dsz <= BIT16SZ){ /* <= not < because this isn't stat; read is stuck */
                if(m == 0)
                    error(Eshort);
                return m;
            }
            m += dsz;
            d += dsz;
            break;
        }
    }

    return m;
}

/*
 * error(Eperm) if open permission not granted for up->user.
 */
void
devpermcheck(char *fileuid, ulong perm, int omode)
{
    ulong t;
    static int access[] = { 0400, 0200, 0600, 0100 };

    if(strcmp(up->user, fileuid) == 0)
        perm <<= 0;
    else
    if(strcmp(up->user, eve) == 0)
        perm <<= 3;
    else
        perm <<= 6;

    t = access[omode&3];
    if((t&perm) != t)
        error(Eperm);
}

Chan*
devopen(Chan *c, int omode, Dirtab *tab, int ntab, Devgen *gen)
{
    int i;
    Dir dir;

    for(i=0;; i++) {
        switch((*gen)(c, nil, tab, ntab, i, &dir)){
        case -1:
            goto Return;
        case 0:
            break;
        case 1:
            if(c->qid.path == dir.qid.path) {
                devpermcheck(dir.uid, dir.mode, omode);
                goto Return;
            }
            break;
        }
    }
Return:
    c->offset = 0;
    if((c->qid.type&QTDIR) && omode!=OREAD)
        error(Eperm);
    c->mode = openmode(omode);
    c->flag |= COPEN;
    return c;
}

void
devcreate(Chan*, char*, int, ulong)
{
    error(Eperm);
}

Block*
devbread(Chan *c, long n, ulong offset)
{
    Block *bp;

    bp = allocb(n);
    if(bp == 0)
        error(Enomem);
    if(waserror()) {
        freeb(bp);
        nexterror();
    }
    bp->wp += devtab[c->type]->read(c, bp->wp, n, offset);
    poperror();
    return bp;
}

long
devbwrite(Chan *c, Block *bp, ulong offset)
{
    long n;

    if(waserror()) {
        freeb(bp);
        nexterror();
    }
    n = devtab[c->type]->write(c, bp->rp, BLEN(bp), offset);
    poperror();
    freeb(bp);

    return n;
}

void
devremove(Chan*)
{
    error(Eperm);
}

int
devwstat(Chan*, uchar*, int)
{
    error(Eperm);
    return 0;
}

void
devpower(int)
{
    error(Eperm);
}

int
devconfig(int, char *, DevConf *)
{
    error(Eperm);
    return 0;
}
@


\subsection*{[[files/env.c]]}

<<env.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// this used to be in devenv.c, but to avoid backward deps I've splitted
// this file in 2

void
closeegrp(Egrp *eg)
{
    int i;
    Evalue *e;

    if(decref(eg) == 0){
        for(i=0; i<eg->nent; i++){
            e = eg->ent[i];
            free(e->name);
            if(e->value)
                free(e->value);
            free(e);
        }
        free(eg->ent);
        free(eg);
    }
}
@


\subsection*{[[files/file.c]]}

<<file.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

Chan*
fdtochan(int fd, int mode, int chkmnt, int iref)
{
    Chan *c;
    Fgrp *f;

    c = 0;
    f = up->fgrp;

    lock(f);
    if(fd<0 || f->nfd<=fd || (c = f->fd[fd])==0) {
        unlock(f);
        error(Ebadfd);
    }
    if(iref)
        incref(c);
    unlock(f);

    if(chkmnt && (c->flag&CMSG)) {
        if(iref)
            cclose(c);
        error(Ebadusefd);
    }

    if(mode<0 || c->mode==ORDWR)
        return c;

    if((mode&OTRUNC) && c->mode==OREAD) {
        if(iref)
            cclose(c);
        error(Ebadusefd);
    }

    if((mode&~OTRUNC) != c->mode) {
        if(iref)
            cclose(c);
        error(Ebadusefd);
    }

    return c;
}

int
openmode(ulong o)
{
    o &= ~(OTRUNC|OCEXEC|ORCLOSE);
    if(o > OEXEC)
        error(Ebadarg);
    if(o == OEXEC)
        return OREAD;
    return o;
}


void
fdclose(int fd, int flag)
{
    int i;
    Chan *c;
    Fgrp *f = up->fgrp;

    lock(f);
    c = f->fd[fd];
    if(c == 0){
        /* can happen for users with shared fd tables */
        unlock(f);
        return;
    }
    if(flag){
        if(c==0 || !(c->flag&flag)){
            unlock(f);
            return;
        }
    }
    f->fd[fd] = 0;
    if(fd == f->maxfd)
        for(i=fd; --i>=0 && f->fd[i]==0; )
            f->maxfd = i;

    unlock(f);
    cclose(c);
}


void
validstat(uchar *s, int n)
{
    int m;
    char buf[64];

    if(statcheck(s, n) < 0)
        error(Ebadstat);
    /* verify that name entry is acceptable */
    s += STATFIXLEN - 4*BIT16SZ;    /* location of first string */
    /*
     * s now points at count for first string.
     * if it's too long, let the server decide; this is
     * only for his protection anyway. otherwise
     * we'd have to allocate and waserror.
     */
    m = GBIT16(s);
    s += BIT16SZ;
    if(m+1 > sizeof buf)
        return;
    memmove(buf, s, m);
    buf[m] = '\0';
    /* name could be '/' */
    if(strcmp(buf, "/") != 0)
        validname(buf, 0);
}

@


\subsection*{[[files/mnt.c]]}

<<mnt.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// this used to be in devmnt.c, but to avoid backward deps I've splitted
// this file in 2 (which forced to put more stuff in portdat_files.h though).

struct Mntalloc mntalloc;

#define MAXRPC (IOHDRSZ+8192)

char   Esbadstat[] = "invalid directory entry received from server";
char   Enoversion[] = "version not established for mount channel";

void
freetag(int t)
{
    mntalloc.tagmask[t>>TAGSHIFT] &= ~(1<<(t&TAGMASK));
}

void
mntfree(Mntrpc *r)
{
    if(r->b != nil)
        freeblist(r->b);
    lock(&mntalloc);
    if(mntalloc.nrpcfree >= 10){
        free(r->rpc);
        freetag(r->request.tag);
        free(r);
    }
    else{
        r->list = mntalloc.rpcfree;
        mntalloc.rpcfree = r;
        mntalloc.nrpcfree++;
    }
    mntalloc.nrpcused--;
    unlock(&mntalloc);
}


void
mntpntfree(Mnt *m)
{
    Mnt *f, **l;
    Queue *q;

    lock(&mntalloc);
    l = &mntalloc.list;
    for(f = *l; f; f = f->list) {
        if(f == m) {
            *l = m->list;
            break;
        }
        l = &f->list;
    }
    m->list = mntalloc.mntfree;
    mntalloc.mntfree = m;
    q = m->q;
    unlock(&mntalloc);

    qfree(q);
}



void
muxclose(Mnt *m)
{
    Mntrpc *q, *r;

    for(q = m->queue; q; q = r) {
        r = q->list;
        mntfree(q);
    }
    m->id = 0;
    free(m->version);
    m->version = nil;
    mntpntfree(m);
}



/*
 * Version is not multiplexed: message sent only once per connection.
 */
long
mntversion(Chan *c, char *version, int msize, int returnlen)
{
    Fcall f;
    uchar *msg;
    Mnt *m;
    char *v;
    long k, l;
    uvlong oo;
    char buf[128];

    qlock(&c->umqlock); /* make sure no one else does this until we've established ourselves */
    if(waserror()){
        qunlock(&c->umqlock);
        nexterror();
    }

    /* defaults */
    if(msize == 0)
        msize = MAXRPC;
    if(msize > c->iounit && c->iounit != 0)
        msize = c->iounit;
    v = version;
    if(v == nil || v[0] == '\0')
        v = VERSION9P;

    /* validity */
    if(msize < 0)
        error("bad iounit in version call");
    if(strncmp(v, VERSION9P, strlen(VERSION9P)) != 0)
        error("bad 9P version specification");

    m = c->mux;

    if(m != nil){
        qunlock(&c->umqlock);
        poperror();

        strecpy(buf, buf+sizeof buf, m->version);
        k = strlen(buf);
        if(strncmp(buf, v, k) != 0){
            snprint(buf, sizeof buf, "incompatible 9P versions %s %s", m->version, v);
            error(buf);
        }
        if(returnlen > 0){
            if(returnlen < k)
                error(Eshort);
            memmove(version, buf, k);
        }
        return k;
    }

    f.type = Tversion;
    f.tag = NOTAG;
    f.msize = msize;
    f.version = v;
    msg = malloc(8192+IOHDRSZ);
    if(msg == nil)
        exhausted("version memory");
    if(waserror()){
        free(msg);
        nexterror();
    }
    k = convS2M(&f, msg, 8192+IOHDRSZ);
    if(k == 0)
        error("bad fversion conversion on send");

    lock(c);
    oo = c->offset;
    c->offset += k;
    unlock(c);

    l = devtab[c->type]->write(c, msg, k, oo);

    if(l < k){
        lock(c);
        c->offset -= k - l;
        unlock(c);
        error("short write in fversion");
    }

    /* message sent; receive and decode reply */
    k = devtab[c->type]->read(c, msg, 8192+IOHDRSZ, c->offset);
    if(k <= 0)
        error("EOF receiving fversion reply");

    lock(c);
    c->offset += k;
    unlock(c);

    l = convM2S(msg, k, &f);
    if(l != k)
        error("bad fversion conversion on reply");
    if(f.type != Rversion){
        if(f.type == Rerror)
            error(f.ename);
        error("unexpected reply type in fversion");
    }
    if(f.msize > msize)
        error("server tries to increase msize in fversion");
    if(f.msize<256 || f.msize>1024*1024)
        error("nonsense value of msize in fversion");
    k = strlen(f.version);
    if(strncmp(f.version, v, k) != 0)
        error("bad 9P version returned from server");

    /* now build Mnt associated with this connection */
    lock(&mntalloc);
    m = mntalloc.mntfree;
    if(m != 0)
        mntalloc.mntfree = m->list;
    else {
        m = malloc(sizeof(Mnt));
        if(m == 0) {
            unlock(&mntalloc);
            exhausted("mount devices");
        }
    }
    m->list = mntalloc.list;
    mntalloc.list = m;
    m->version = nil;
    kstrdup(&m->version, f.version);
    m->id = mntalloc.id++;
    m->q = qopen(10*MAXRPC, 0, nil, nil);
    m->msize = f.msize;
    unlock(&mntalloc);

    if(returnlen > 0){
        if(returnlen < k)
            error(Eshort);
        memmove(version, f.version, k);
    }

    poperror(); /* msg */
    free(msg);

    lock(m);
    m->queue = 0;
    m->rip = 0;

    c->flag |= CMSG;
    c->mux = m;
    m->c = c;
    unlock(m);

    poperror(); /* c */
    qunlock(&c->umqlock);

    return k;
}





@


\subsection*{[[files/portdat_files.h]]}

<<portdat_files.h>>=

/* flag values */
enum
{
  BINTR = (1<<0),
  BFREE = (1<<1),
  Bipck = (1<<2),   /* ip checksum */
  Budpck  = (1<<3),   /* udp checksum */
  Btcpck  = (1<<4),   /* tcp checksum */
  Bpktck  = (1<<5),   /* packet checksum */
};

struct Block
{
  long  ref;
  Block*  next;
  Block*  list;
  uchar*  rp;     /* first unconsumed byte */
  uchar*  wp;     /* first empty byte */
  uchar*  lim;      /* 1 past the end of the buffer */
  uchar*  base;     /* start of the buffer */
  void  (*free)(Block*);
  ushort  flag;
  ushort  checksum;   /* IP checksum of complete packet (minus media header) */
};

#define BLEN(s) ((s)->wp - (s)->rp)
#define BALLOC(s) ((s)->lim - (s)->base)



/* queue state bits,  Qmsg, Qcoalesce, and Qkick can be set in qopen */
enum
{
  /* Queue.state */
  Qstarve   = (1<<0), /* consumer starved */
  Qmsg    = (1<<1), /* message stream */
  Qclosed   = (1<<2), /* queue has been closed/hungup */
  Qflow   = (1<<3), /* producer flow controlled */
  Qcoalesce = (1<<4), /* coalesce packets on read */
  Qkick   = (1<<5), /* always call the kick routine after qwrite */
};

// defined in qio.c
extern  uint  qiomaxatomic;

/*
 *  IO queues
 */
// was in qio.c
struct Queue
{
  Lock;

  Block*  bfirst;   /* buffer */
  Block*  blast;

  int len;    /* bytes allocated to queue */
  int dlen;   /* data bytes in queue */
  int limit;    /* max bytes in queue */
  int inilim;   /* initial limit */
  int state;
  int noblock;  /* true if writes return immediately when q full */
  int eof;    /* number of eofs read by user */

  void  (*kick)(void*); /* restart output */
  void  (*bypass)(void*, Block*); /* bypass queue altogether */
  void* arg;    /* argument to kick */

  QLock rlock;    /* mutex for reading processes */
  Rendez  rr;   /* process waiting to read */
  QLock wlock;    /* mutex for writing processes */
  Rendez  wr;   /* process waiting to write */

  char  err[ERRMAX];
};



// was in cache.c
struct Extent
{
  int bid;
  ulong start;
  int len;
  Page  *cache;
  Extent  *next;
};

// was in cache.c
struct Mntcache
{
  Qid qid;
  int dev;
  int type;
  QLock;
  Extent   *list;
  Mntcache *hash;
  Mntcache *prev;
  Mntcache *next;
};





struct Mount
{
  ulong mountid;
  Mount*  next;
  Mhead*  head;
  Mount*  copy;
  Mount*  order;
  Chan* to;     /* channel replacing channel */
  int mflag;
  char  *spec;
};


struct Mhead
{
  Ref;
  RWlock  lock;
  Chan* from;     /* channel mounted upon */
  Mount*  mount;      /* what's mounted upon it */
  Mhead*  hash;     /* Hash chain */
};





#include <fcall.h>

// was in devmnt.c
struct Mntrpc
{
  Chan* c;    /* Channel for whom we are working */
  Mntrpc* list;   /* Free/pending list */
  Fcall request;  /* Outgoing file system protocol message */
  Fcall   reply;    /* Incoming reply */
  Mnt*  m;    /* Mount device during rpc */
  Rendez  r;    /* Place to hang out */
  uchar*  rpc;    /* I/O Data buffer */
  uint  rpclen;   /* len of buffer */
  Block *b;   /* reply blocks */
  char  done;   /* Rpc completed */
  uvlong  stime;    /* start time for mnt statistics */
  ulong reqlen;   /* request length for mnt statistics */
  ulong replen;   /* reply length for mnt statistics */
  Mntrpc* flushed;  /* message this one flushes */
};

struct Mnt
{
  Lock;
  /* references are counted using c->ref; channels on this mount point incref(c->mchan) == Mnt.c */
  Chan  *c;   /* Channel to file service */
  Proc  *rip;   /* Reader in progress */
  Mntrpc  *queue;   /* Queue of pending requests on this channel */
  ulong id;   /* Multiplexer id for channel check */
  Mnt *list;    /* Free list */
  int flags;    /* cache */
  int msize;    /* data + IOHDRSZ */
  char  *version; /* 9P version */
  Queue *q;   /* input queue */
};




struct Path
{
  Ref;
  char  *s;
  Chan  **mtpt;     /* mtpt history */
  int len;      /* strlen(s) */
  int alen;     /* allocated length of s */
  int mlen;     /* number of path elements */
  int malen;      /* allocated length of mtpt */
};



/*
 * Access types in namec & channel flags
 */
enum
{
  Aaccess,      /* as in stat, wstat */
  Abind,        /* for left-hand-side of bind */
  Atodir,       /* as in chdir */
  Aopen,        /* for i/o */
  Amount,       /* to be mounted or mounted upon */
  Acreate,      /* is to be created */
  Aremove,      /* will be removed by caller */

  COPEN = 0x0001,   /* for i/o */
  CMSG  = 0x0002,   /* the message channel for a mount */
/*rsc CCREATE = 0x0004,   /* permits creation if c->mnt */
  CCEXEC  = 0x0008,   /* close on exec */
  CFREE = 0x0010,   /* not in use */
  CRCLOSE = 0x0020,   /* remove on close */
  CCACHE  = 0x0080,   /* client cache */
};

struct Chan
{
  Ref;        /* the Lock in this Ref is also Chan's lock */
  Chan* next;     /* allocation */
  Chan* link;
  vlong offset;     /* in fd */
  vlong devoffset;    /* in underlying device; see read */

  ushort  type; // idx in devtab?
  ulong dev;

  ushort  mode;     /* read/write */
  ushort  flag;

  Qid qid;

  int fid;      /* for devmnt */
  ulong iounit;     /* chunk size for i/o; 0==default */
  Mhead*  umh;      /* mount point that derived Chan; used in unionread */
  Chan* umc;      /* channel in union; held for union read */
  QLock umqlock;    /* serialize unionreads */
  int uri;      /* union read index */
  int dri;      /* devdirread index */
  uchar*  dirrock;    /* directory entry rock for translations */
  int nrock;
  int mrock;
  QLock rockqlock;
  int ismtpt;
  Mntcache* mcp;      /* Mount cache pointer */
  Mnt*  mux;      /* Mnt for clients using me for messages */
  union {
    void* aux;
    Qid pgrpid;   /* for #p/notepg */
    ulong mid;    /* for ns in devproc */
  };
  Chan* mchan;      /* channel to mounted server */
  Qid mqid;     /* qid of root of mount point */
  Path* path;
};





struct Evalue
{
  char  *name;
  char  *value;
  int len;
  Evalue  *link;
  Qid qid;
};

struct Egrp
{
  Ref;
  RWlock;
  Evalue  **ent;
  int nent;
  int ment;
  ulong path; /* qid.path of next Evalue to be allocated */
  ulong vers; /* of Egrp */
};


// internals


struct Walkqid
{
  Chan  *clone;
  int nqid;
  Qid qid[1];
};

struct Dev
{
  int dc; // dev character code
  char* name;

  void  (*reset)(void);
  void  (*init)(void);
  void  (*shutdown)(void);
  Chan* (*attach)(char*);
  Walkqid*(*walk)(Chan*, Chan*, char**, int);
  int (*stat)(Chan*, uchar*, int);
  Chan* (*open)(Chan*, int);
  void  (*create)(Chan*, char*, int, ulong);
  void  (*close)(Chan*);
  long  (*read)(Chan*, void*, long, vlong);
  Block*  (*bread)(Chan*, long, ulong);
  long  (*write)(Chan*, void*, long, vlong);
  long  (*bwrite)(Chan*, Block*, ulong);
  void  (*remove)(Chan*);
  int (*wstat)(Chan*, uchar*, int);
  void  (*power)(int);  /* power mgt: power(1) => on, power (0) => off */
  int (*config)(int, char*, DevConf*);  /* returns nil on error */

  /* not initialised */
  int attached;       /* debugging */
};

// array<Dev>, it looks like an allocated array<ref<dev>> but
// it is really a static array put here to avoid backward deps on conf_devtab,
// and it is not really a <ref<dev>> because it's pointers to static
// structures (e.g. mousedevtab, vgadevtab, etc).
extern Dev** devtab;


struct Dirtab
{
  char  name[KNAMELEN];
  Qid qid;
  vlong length;
  long  perm;
};



//*****************************************************************************
// Internal to memory/
//*****************************************************************************

enum
{
    TAGSHIFT = 5,           /* ulong has to be 32 bits */
    TAGMASK = (1<<TAGSHIFT)-1,
    NMASK = (64*1024)>>TAGSHIFT,
};

/*
 * References are managed as follows:
 * The channel to the server - a network connection or pipe - has one
 * reference for every Chan open on the server.  The server channel has
 * c->mux set to the Mnt used for muxing control to that server.  Mnts
 * have no reference count; they go away when c goes away.
 * Each channel derived from the mount point has mchan set to c,
 * and increfs/decrefs mchan to manage references on the server
 * connection.
 */

// actually internal to devmnt.c and mnt.c
struct Mntalloc
{
    Mnt*    list;       /* Mount devices in use */
    Mnt*    mntfree;    /* Free list */
    Mntrpc* rpcfree;
    int nrpcfree;
    int nrpcused;
    ulong   id;
    ulong   tagmask[NMASK];

  // extra
    Lock;

};
extern struct Mntalloc mntalloc;

// TODO: mv in errstr.c
extern char Esbadstat[];
extern char Enoversion[];
@


\subsection*{[[files/portfns_files.h]]}

<<portfns_files.h>>=

// allocb.c
Block*    allocb(int);
void    freeb(Block*);
Block*    iallocb(int);
void    iallocsummary(void);
void    checkb(Block*, char*);

// cache.c
void    cinit(void);
void    copen(Chan*);
int   cread(Chan*, uchar*, int, vlong);
void    cwrite(Chan*, uchar*, int, vlong);
void    cupdate(Chan*, uchar*, int, vlong);

// qio.c
void    freeblist(Block*);
int   blocklen(Block*);
Queue*    qopen(int, int, void (*)(void*), void*);
void    qhangup(Queue*, char*);
Block*    qget(Queue*);
int   qdiscard(Queue*, int);
void    qreopen(Queue*);
Block*    qremove(Queue*);
void    qputback(Queue*, Block*);
Block*    packblock(Block*);
Queue*    qbypass(void (*)(void*, Block*), void*);
int   pullblock(Block**, int);
Block*    bl2mem(uchar*, Block*, int);
void    qnoblock(Queue*, int);
int   qisclosed(Queue*);
int   qfull(Queue*);
int   qwindow(Queue*);
void    qsetlimit(Queue*, int);
int   qpass(Queue*, Block*);
void    qclose(Queue*);
int   qiwrite(Queue*, void*, int);
int   qproduce(Queue*, void*, int);
Block*    padblock(Block*, int);
Block*    pullupblock(Block*, int);
int   qpassnolim(Queue*, Block*);
Block*    copyblock(Block*, int);
Block*    qcopy(Queue*, int, ulong);
void    qflush(Queue*);
long    qbwrite(Queue*, Block*);
int   qconsume(Queue*, void*, int);
//Block*    mem2bl(uchar*, int);
Block*    trimblock(Block*, int, int);
void    qaddlist(Queue*, Block*);
Block*    concatblock(Block*);
void    ixsummary(void);
Block*    pullupqueue(Queue*, int);
void    qfree(Queue*);
int   qwrite(Queue*, void*, int);
Block*    adjustblock(Block*, int);
Block*    qbread(Queue*, int);
long    qread(Queue*, void*, int);
int   qcanread(Queue*);
int   qlen(Queue*);

// chan.c
Chan*   cclone(Chan*);
void    putmhead(Mhead*);
int   eqchantdqid(Chan*, int, int, Qid, int);
Mhead*    newmhead(Chan*);
void    isdir(Chan*);
char*   chanpath(Chan*);
int   emptystr(char*);
void    chandevinit(void);
void    chandevshutdown(void);
void    chandevreset(void);
int   eqqid(Qid, Qid);
int   cmount(Chan**, Chan*, int, char*);
void    cunmount(Chan*, Chan*);
int   findmount(Chan**, Mhead**, int, int, Qid);
void    pathclose(Path*);
Path*   newpath(char*);
Chan*   newchan(void);
void    chanfree(Chan*);
//cchan_close => cclose
char*   validnamedup(char*, int);
void    validname(char*, int);
void    nameerror(char*, char*);
int   walk(Chan**, char**, int, int, int*);
void    ccloseq(Chan*);
Chan*   namec(char*, int, int, ulong);
//long    unionread(Chan*, void*, long);

// file.c
Chan*   fdtochan(int, int, int, int);
int   openmode(ulong);
void    fdclose(int, int);
void    validstat(uchar*, int);

// dev.c
void    mkqid(Qid*, vlong, ulong, int);
int   devno(int, int);
void    devdir(Chan*, Qid, char*, vlong, char*, long, Dir*);
void    devinit(void);
void    devreset(void);
void    devshutdown(void);
Chan*   devclone(Chan*);
long    devdirread(Chan*, char*, long, Dirtab*, int, Devgen*);
void    devpermcheck(char*, ulong, int);
void    devcreate(Chan*, char*, int, ulong);
Block*    devbread(Chan*, long, ulong);
long    devbwrite(Chan*, Block*, ulong);
void    devremove(Chan*);
int   devwstat(Chan*, uchar*, int);
#define DEVDOTDOT -1
Devgen    devgen;//TODO?
void    devpower(int);
int   devconfig(int, char *, DevConf *);//TODO? why fp no-deps?
int   devstat(Chan*, uchar*, int, Dirtab*, int, Devgen*);
Chan*   devopen(Chan*, int, Dirtab*, int, Devgen*);
Chan*   devattach(int, char*);
Walkqid*  devwalk(Chan*, Chan*, char**, int, Dirtab*, int, Devgen*);

// env.c
void    closeegrp(Egrp*);

// mnt.c
void    muxclose(Mnt*);
void    mntfree(Mntrpc*);
void    mntpntfree(Mnt*);

// sysfile.c
int   newfd(Chan*);
// many sysxxx functions (used in syscalls/ without requiring extern decl)
@


\subsection*{[[files/qio.c]]}

<<qio.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

static ulong padblockcnt;
static ulong concatblockcnt;
static ulong pullupblockcnt;
static ulong copyblockcnt;
static ulong consumecnt;
static ulong producecnt;
static ulong qcopycnt;

static int debugging;

#define QDEBUG  if(0)

enum
{
    Maxatomic   = 64*1024,
};

uint    qiomaxatomic = Maxatomic;

void
ixsummary(void)
{
    debugging ^= 1;
    iallocsummary();
    print("pad %lud, concat %lud, pullup %lud, copy %lud\n",
        padblockcnt, concatblockcnt, pullupblockcnt, copyblockcnt);
    print("consume %lud, produce %lud, qcopy %lud\n",
        consumecnt, producecnt, qcopycnt);
}

/*
 *  free a list of blocks
 */
void
freeblist(Block *b)
{
    Block *next;

    for(; b != 0; b = next){
        next = b->next;
        if(b->ref == 1)
            b->next = nil;
        freeb(b);
    }
}

/*
 *  pad a block to the front (or the back if size is negative)
 */
Block*
padblock(Block *bp, int size)
{
    int n;
    Block *nbp;

    QDEBUG checkb(bp, "padblock 1");
    if(size >= 0){
        if(bp->rp - bp->base >= size){
            bp->rp -= size;
            return bp;
        }

        if(bp->next)
            panic("padblock %#p", getcallerpc(&bp));
        n = BLEN(bp);
        padblockcnt++;
        nbp = allocb(size+n);
        nbp->rp += size;
        nbp->wp = nbp->rp;
        memmove(nbp->wp, bp->rp, n);
        nbp->wp += n;
        freeb(bp);
        nbp->rp -= size;
    } else {
        size = -size;

        if(bp->next)
            panic("padblock %#p", getcallerpc(&bp));

        if(bp->lim - bp->wp >= size)
            return bp;

        n = BLEN(bp);
        padblockcnt++;
        nbp = allocb(size+n);
        memmove(nbp->wp, bp->rp, n);
        nbp->wp += n;
        freeb(bp);
    }
    QDEBUG checkb(nbp, "padblock 1");
    return nbp;
}

/*
 *  return count of bytes in a string of blocks
 */
int
blocklen(Block *bp)
{
    int len;

    len = 0;
    while(bp) {
        len += BLEN(bp);
        bp = bp->next;
    }
    return len;
}

/*
 * return count of space in blocks
 */
int
blockalloclen(Block *bp)
{
    int len;

    len = 0;
    while(bp) {
        len += BALLOC(bp);
        bp = bp->next;
    }
    return len;
}

/*
 *  copy the  string of blocks into
 *  a single block and free the string
 */
Block*
concatblock(Block *bp)
{
    int len;
    Block *nb, *f;

    if(bp->next == 0)
        return bp;

    nb = allocb(blocklen(bp));
    for(f = bp; f; f = f->next) {
        len = BLEN(f);
        memmove(nb->wp, f->rp, len);
        nb->wp += len;
    }
    concatblockcnt += BLEN(nb);
    freeblist(bp);
    QDEBUG checkb(nb, "concatblock 1");
    return nb;
}

/*
 *  make sure the first block has at least n bytes
 */
Block*
pullupblock(Block *bp, int n)
{
    int i;
    Block *nbp;

    /*
     *  this should almost always be true, it's
     *  just to avoid every caller checking.
     */
    if(BLEN(bp) >= n)
        return bp;

    /*
     *  if not enough room in the first block,
     *  add another to the front of the list.
     */
    if(bp->lim - bp->rp < n){
        nbp = allocb(n);
        nbp->next = bp;
        bp = nbp;
    }

    /*
     *  copy bytes from the trailing blocks into the first
     */
    n -= BLEN(bp);
    while(nbp = bp->next){
        i = BLEN(nbp);
        if(i > n) {
            memmove(bp->wp, nbp->rp, n);
            pullupblockcnt++;
            bp->wp += n;
            nbp->rp += n;
            QDEBUG checkb(bp, "pullupblock 1");
            return bp;
        } else {
            /* shouldn't happen but why crash if it does */
            if(i < 0){
                print("pullup negative length packet, called from %#p\n",
                    getcallerpc(&bp));
                i = 0;
            }
            memmove(bp->wp, nbp->rp, i);
            pullupblockcnt++;
            bp->wp += i;
            bp->next = nbp->next;
            nbp->next = 0;
            freeb(nbp);
            n -= i;
            if(n == 0){
                QDEBUG checkb(bp, "pullupblock 2");
                return bp;
            }
        }
    }
    freeb(bp);
    return 0;
}

/*
 *  make sure the first block has at least n bytes
 */
Block*
pullupqueue(Queue *q, int n)
{
    Block *b;

    if(BLEN(q->bfirst) >= n)
        return q->bfirst;
    q->bfirst = pullupblock(q->bfirst, n);
    for(b = q->bfirst; b != nil && b->next != nil; b = b->next)
        ;
    q->blast = b;
    return q->bfirst;
}

/*
 *  trim to len bytes starting at offset
 */
Block *
trimblock(Block *bp, int offset, int len)
{
    ulong l;
    Block *nb, *startb;

    QDEBUG checkb(bp, "trimblock 1");
    if(blocklen(bp) < offset+len) {
        freeblist(bp);
        return nil;
    }

    while((l = BLEN(bp)) < offset) {
        offset -= l;
        nb = bp->next;
        bp->next = nil;
        freeb(bp);
        bp = nb;
    }

    startb = bp;
    bp->rp += offset;

    while((l = BLEN(bp)) < len) {
        len -= l;
        bp = bp->next;
    }

    bp->wp -= (BLEN(bp) - len);

    if(bp->next) {
        freeblist(bp->next);
        bp->next = nil;
    }

    return startb;
}

/*
 *  copy 'count' bytes into a new block
 */
Block*
copyblock(Block *bp, int count)
{
    int l;
    Block *nbp;

    QDEBUG checkb(bp, "copyblock 0");
    nbp = allocb(count);
    for(; count > 0 && bp != 0; bp = bp->next){
        l = BLEN(bp);
        if(l > count)
            l = count;
        memmove(nbp->wp, bp->rp, l);
        nbp->wp += l;
        count -= l;
    }
    if(count > 0){
        memset(nbp->wp, 0, count);
        nbp->wp += count;
    }
    copyblockcnt++;
    QDEBUG checkb(nbp, "copyblock 1");

    return nbp;
}

Block*
adjustblock(Block* bp, int len)
{
    int n;
    Block *nbp;

    if(len < 0){
        freeb(bp);
        return nil;
    }

    if(bp->rp+len > bp->lim){
        nbp = copyblock(bp, len);
        freeblist(bp);
        QDEBUG checkb(nbp, "adjustblock 1");

        return nbp;
    }

    n = BLEN(bp);
    if(len > n)
        memset(bp->wp, 0, len-n);
    bp->wp = bp->rp+len;
    QDEBUG checkb(bp, "adjustblock 2");

    return bp;
}


/*
 *  throw away up to count bytes from a
 *  list of blocks.  Return count of bytes
 *  thrown away.
 */
int
pullblock(Block **bph, int count)
{
    Block *bp;
    int n, bytes;

    bytes = 0;
    if(bph == nil)
        return 0;

    while(*bph != nil && count != 0) {
        bp = *bph;
        n = BLEN(bp);
        if(count < n)
            n = count;
        bytes += n;
        count -= n;
        bp->rp += n;
        QDEBUG checkb(bp, "pullblock ");
        if(BLEN(bp) == 0) {
            *bph = bp->next;
            bp->next = nil;
            freeb(bp);
        }
    }
    return bytes;
}

/*
 *  get next block from a queue, return null if nothing there
 */
Block*
qget(Queue *q)
{
    int dowakeup;
    Block *b;

    /* sync with qwrite */
    ilock(q);

    b = q->bfirst;
    if(b == nil){
        q->state |= Qstarve;
        iunlock(q);
        return nil;
    }
    q->bfirst = b->next;
    b->next = 0;
    q->len -= BALLOC(b);
    q->dlen -= BLEN(b);
    QDEBUG checkb(b, "qget");

    /* if writer flow controlled, restart */
    if((q->state & Qflow) && q->len < q->limit/2){
        q->state &= ~Qflow;
        dowakeup = 1;
    } else
        dowakeup = 0;

    iunlock(q);

    if(dowakeup)
        wakeup(&q->wr);

    return b;
}

/*
 *  throw away the next 'len' bytes in the queue
 */
int
qdiscard(Queue *q, int len)
{
    Block *b;
    int dowakeup, n, sofar;

    ilock(q);
    for(sofar = 0; sofar < len; sofar += n){
        b = q->bfirst;
        if(b == nil)
            break;
        QDEBUG checkb(b, "qdiscard");
        n = BLEN(b);
        if(n <= len - sofar){
            q->bfirst = b->next;
            b->next = 0;
            q->len -= BALLOC(b);
            q->dlen -= BLEN(b);
            freeb(b);
        } else {
            n = len - sofar;
            b->rp += n;
            q->dlen -= n;
        }
    }

    /*
     *  if writer flow controlled, restart
     *
     *  This used to be
     *  q->len < q->limit/2
     *  but it slows down tcp too much for certain write sizes.
     *  I really don't understand it completely.  It may be
     *  due to the queue draining so fast that the transmission
     *  stalls waiting for the app to produce more data.  - presotto
     */
    if((q->state & Qflow) && q->len < q->limit){
        q->state &= ~Qflow;
        dowakeup = 1;
    } else
        dowakeup = 0;

    iunlock(q);

    if(dowakeup)
        wakeup(&q->wr);

    return sofar;
}

/*
 *  Interrupt level copy out of a queue, return # bytes copied.
 */
int
qconsume(Queue *q, void *vp, int len)
{
    Block *b;
    int n, dowakeup;
    uchar *p = vp;
    Block *tofree = nil;

    /* sync with qwrite */
    ilock(q);

    for(;;) {
        b = q->bfirst;
        if(b == 0){
            q->state |= Qstarve;
            iunlock(q);
            return -1;
        }
        QDEBUG checkb(b, "qconsume 1");

        n = BLEN(b);
        if(n > 0)
            break;
        q->bfirst = b->next;
        q->len -= BALLOC(b);

        /* remember to free this */
        b->next = tofree;
        tofree = b;
    };

    if(n < len)
        len = n;
    memmove(p, b->rp, len);
    consumecnt += n;
    b->rp += len;
    q->dlen -= len;

    /* discard the block if we're done with it */
    if((q->state & Qmsg) || len == n){
        q->bfirst = b->next;
        b->next = 0;
        q->len -= BALLOC(b);
        q->dlen -= BLEN(b);

        /* remember to free this */
        b->next = tofree;
        tofree = b;
    }

    /* if writer flow controlled, restart */
    if((q->state & Qflow) && q->len < q->limit/2){
        q->state &= ~Qflow;
        dowakeup = 1;
    } else
        dowakeup = 0;

    iunlock(q);

    if(dowakeup)
        wakeup(&q->wr);

    if(tofree != nil)
        freeblist(tofree);

    return len;
}

int
qpass(Queue *q, Block *b)
{
    int dlen, len, dowakeup;

    /* sync with qread */
    dowakeup = 0;
    ilock(q);
    if(q->len >= q->limit){
        freeblist(b);
        iunlock(q);
        return -1;
    }
    if(q->state & Qclosed){
        len = BALLOC(b);
        freeblist(b);
        iunlock(q);
        return len;
    }

    /* add buffer to queue */
    if(q->bfirst)
        q->blast->next = b;
    else
        q->bfirst = b;
    len = BALLOC(b);
    dlen = BLEN(b);
    QDEBUG checkb(b, "qpass");
    while(b->next){
        b = b->next;
        QDEBUG checkb(b, "qpass");
        len += BALLOC(b);
        dlen += BLEN(b);
    }
    q->blast = b;
    q->len += len;
    q->dlen += dlen;

    if(q->len >= q->limit/2)
        q->state |= Qflow;

    if(q->state & Qstarve){
        q->state &= ~Qstarve;
        dowakeup = 1;
    }
    iunlock(q);

    if(dowakeup)
        wakeup(&q->rr);

    return len;
}

int
qpassnolim(Queue *q, Block *b)
{
    int dlen, len, dowakeup;

    /* sync with qread */
    dowakeup = 0;
    ilock(q);

    if(q->state & Qclosed){
        freeblist(b);
        iunlock(q);
        return BALLOC(b);
    }

    /* add buffer to queue */
    if(q->bfirst)
        q->blast->next = b;
    else
        q->bfirst = b;
    len = BALLOC(b);
    dlen = BLEN(b);
    QDEBUG checkb(b, "qpass");
    while(b->next){
        b = b->next;
        QDEBUG checkb(b, "qpass");
        len += BALLOC(b);
        dlen += BLEN(b);
    }
    q->blast = b;
    q->len += len;
    q->dlen += dlen;

    if(q->len >= q->limit/2)
        q->state |= Qflow;

    if(q->state & Qstarve){
        q->state &= ~Qstarve;
        dowakeup = 1;
    }
    iunlock(q);

    if(dowakeup)
        wakeup(&q->rr);

    return len;
}

/*
 *  if the allocated space is way out of line with the used
 *  space, reallocate to a smaller block
 */
Block*
packblock(Block *bp)
{
    Block **l, *nbp;
    int n;

    for(l = &bp; *l; l = &(*l)->next){
        nbp = *l;
        n = BLEN(nbp);
        if((n<<2) < BALLOC(nbp)){
            *l = allocb(n);
            memmove((*l)->wp, nbp->rp, n);
            (*l)->wp += n;
            (*l)->next = nbp->next;
            freeb(nbp);
        }
    }

    return bp;
}

int
qproduce(Queue *q, void *vp, int len)
{
    Block *b;
    int dowakeup;
    uchar *p = vp;

    /* sync with qread */
    dowakeup = 0;
    ilock(q);

    /* no waiting receivers, room in buffer? */
    if(q->len >= q->limit){
        q->state |= Qflow;
        iunlock(q);
        return -1;
    }

    /* save in buffer */
    b = iallocb(len);
    if(b == 0){
        iunlock(q);
        return 0;
    }
    memmove(b->wp, p, len);
    producecnt += len;
    b->wp += len;
    if(q->bfirst)
        q->blast->next = b;
    else
        q->bfirst = b;
    q->blast = b;
    /* b->next = 0; done by iallocb() */
    q->len += BALLOC(b);
    q->dlen += BLEN(b);
    QDEBUG checkb(b, "qproduce");

    if(q->state & Qstarve){
        q->state &= ~Qstarve;
        dowakeup = 1;
    }

    if(q->len >= q->limit)
        q->state |= Qflow;
    iunlock(q);

    if(dowakeup)
        wakeup(&q->rr);

    return len;
}

/*
 *  copy from offset in the queue
 */
Block*
qcopy(Queue *q, int len, ulong offset)
{
    int sofar;
    int n;
    Block *b, *nb;
    uchar *p;

    nb = allocb(len);

    ilock(q);

    /* go to offset */
    b = q->bfirst;
    for(sofar = 0; ; sofar += n){
        if(b == nil){
            iunlock(q);
            return nb;
        }
        n = BLEN(b);
        if(sofar + n > offset){
            p = b->rp + offset - sofar;
            n -= offset - sofar;
            break;
        }
        QDEBUG checkb(b, "qcopy");
        b = b->next;
    }

    /* copy bytes from there */
    for(sofar = 0; sofar < len;){
        if(n > len - sofar)
            n = len - sofar;
        memmove(nb->wp, p, n);
        qcopycnt += n;
        sofar += n;
        nb->wp += n;
        b = b->next;
        if(b == nil)
            break;
        n = BLEN(b);
        p = b->rp;
    }
    iunlock(q);

    return nb;
}

/*
 *  called by non-interrupt code
 */
Queue*
qopen(int limit, int msg, void (*kick)(void*), void *arg)
{
    Queue *q;

    q = malloc(sizeof(Queue));
    if(q == 0)
        return 0;

    q->limit = q->inilim = limit;
    q->kick = kick;
    q->arg = arg;
    q->state = msg;
    
    q->state |= Qstarve;
    q->eof = 0;
    q->noblock = 0;

    return q;
}

/* open a queue to be bypassed */
Queue*
qbypass(void (*bypass)(void*, Block*), void *arg)
{
    Queue *q;

    q = malloc(sizeof(Queue));
    if(q == 0)
        return 0;

    q->limit = 0;
    q->arg = arg;
    q->bypass = bypass;
    q->state = 0;

    return q;
}

static int
notempty(void *a)
{
    Queue *q = a;

    return (q->state & Qclosed) || q->bfirst != 0;
}

/*
 *  wait for the queue to be non-empty or closed.
 *  called with q ilocked.
 */
static int
qwait(Queue *q)
{
    /* wait for data */
    for(;;){
        if(q->bfirst != nil)
            break;

        if(q->state & Qclosed){
            if(++q->eof > 3)
                return -1;
            if(*q->err && strcmp(q->err, Ehungup) != 0)
                return -1;
            return 0;
        }

        q->state |= Qstarve;    /* flag requesting producer to wake me */
        iunlock(q);
        sleep(&q->rr, notempty, q);
        ilock(q);
    }
    return 1;
}

/*
 * add a block list to a queue
 */
void
qaddlist(Queue *q, Block *b)
{
    /* queue the block */
    if(q->bfirst)
        q->blast->next = b;
    else
        q->bfirst = b;
    q->len += blockalloclen(b);
    q->dlen += blocklen(b);
    while(b->next)
        b = b->next;
    q->blast = b;
}

/*
 *  called with q ilocked
 */
Block*
qremove(Queue *q)
{
    Block *b;

    b = q->bfirst;
    if(b == nil)
        return nil;
    q->bfirst = b->next;
    b->next = nil;
    q->dlen -= BLEN(b);
    q->len -= BALLOC(b);
    QDEBUG checkb(b, "qremove");
    return b;
}

/*
 *  copy the contents of a string of blocks into
 *  memory.  emptied blocks are freed.  return
 *  pointer to first unconsumed block.
 */
Block*
bl2mem(uchar *p, Block *b, int n)
{
    int i;
    Block *next;

    for(; b != nil; b = next){
        i = BLEN(b);
        if(i > n){
            memmove(p, b->rp, n);
            b->rp += n;
            return b;
        }
        memmove(p, b->rp, i);
        n -= i;
        p += i;
        b->rp += i;
        next = b->next;
        freeb(b);
    }
    return nil;
}

//unused
/*
 *  copy the contents of memory into a string of blocks.
 *  return nil on error.
 */
//Block*
//mem2bl(uchar *p, int len)
//{
//  int n;
//  Block *b, *first, **l;
//
//  first = nil;
//  l = &first;
//  if(waserror()){
//      freeblist(first);
//      nexterror();
//  }
//  do {
//      n = len;
//      if(n > Maxatomic)
//          n = Maxatomic;
//
//      *l = b = allocb(n);
//      setmalloctag(b, (up->text[0]<<24)|(up->text[1]<<16)|(up->text[2]<<8)|up->text[3]);
//      memmove(b->wp, p, n);
//      b->wp += n;
//      p += n;
//      len -= n;
//      l = &b->next;
//  } while(len > 0);
//  poperror();
//
//  return first;
//}

/*
 *  put a block back to the front of the queue
 *  called with q ilocked
 */
void
qputback(Queue *q, Block *b)
{
    b->next = q->bfirst;
    if(q->bfirst == nil)
        q->blast = b;
    q->bfirst = b;
    q->len += BALLOC(b);
    q->dlen += BLEN(b);
}

/*
 *  flow control, get producer going again
 *  called with q ilocked
 */
static void
qwakeup_iunlock(Queue *q)
{
    int dowakeup = 0;

    /* if writer flow controlled, restart */
    if((q->state & Qflow) && q->len < q->limit/2){
        q->state &= ~Qflow;
        dowakeup = 1;
    }

    iunlock(q);

    /* wakeup flow controlled writers */
    if(dowakeup){
        if(q->kick)
            q->kick(q->arg);
        wakeup(&q->wr);
    }
}

/*
 *  get next block from a queue (up to a limit)
 */
Block*
qbread(Queue *q, int len)
{
    Block *b, *nb;
    int n;

    qlock(&q->rlock);
    if(waserror()){
        qunlock(&q->rlock);
        nexterror();
    }

    ilock(q);
    switch(qwait(q)){
    case 0:
        /* queue closed */
        iunlock(q);
        qunlock(&q->rlock);
        poperror();
        return nil;
    case -1:
        /* multiple reads on a closed queue */
        iunlock(q);
        error(q->err);
    }

    /* if we get here, there's at least one block in the queue */
    b = qremove(q);
    n = BLEN(b);

    /* split block if it's too big and this is not a message queue */
    nb = b;
    if(n > len){
        if((q->state&Qmsg) == 0){
            n -= len;
            b = allocb(n);
            memmove(b->wp, nb->rp+len, n);
            b->wp += n;
            qputback(q, b);
        }
        nb->wp = nb->rp + len;
    }

    /* restart producer */
    qwakeup_iunlock(q);

    poperror();
    qunlock(&q->rlock);
    return nb;
}

/*
 *  read a queue.  if no data is queued, post a Block
 *  and wait on its Rendez.
 */
long
qread(Queue *q, void *vp, int len)
{
    Block *b, *first, **l;
    int m, n;

    qlock(&q->rlock);
    if(waserror()){
        qunlock(&q->rlock);
        nexterror();
    }

    ilock(q);
again:
    switch(qwait(q)){
    case 0:
        /* queue closed */
        iunlock(q);
        qunlock(&q->rlock);
        poperror();
        return 0;
    case -1:
        /* multiple reads on a closed queue */
        iunlock(q);
        error(q->err);
    }

    /* if we get here, there's at least one block in the queue */
    if(q->state & Qcoalesce){
        /* when coalescing, 0 length blocks just go away */
        b = q->bfirst;
        if(BLEN(b) <= 0){
            freeb(qremove(q));
            goto again;
        }

        /*  grab the first block plus as many
         *  following blocks as will completely
         *  fit in the read.
         */
        n = 0;
        l = &first;
        m = BLEN(b);
        for(;;) {
            *l = qremove(q);
            l = &b->next;
            n += m;

            b = q->bfirst;
            if(b == nil)
                break;
            m = BLEN(b);
            if(n+m > len)
                break;
        }
    } else {
        first = qremove(q);
        n = BLEN(first);
    }

    /* copy to user space outside of the ilock */
    iunlock(q);
    b = bl2mem(vp, first, len);
    ilock(q);

    /* take care of any left over partial block */
    if(b != nil){
        n -= BLEN(b);
        if(q->state & Qmsg)
            freeb(b);
        else
            qputback(q, b);
    }

    /* restart producer */
    qwakeup_iunlock(q);

    poperror();
    qunlock(&q->rlock);
    return n;
}

static int
qnotfull(void *a)
{
    Queue *q = a;

    return q->len < q->limit || (q->state & Qclosed);
}

ulong noblockcnt;

/*
 *  add a block to a queue obeying flow control
 */
long
qbwrite(Queue *q, Block *b)
{
    int n, dowakeup;
    Proc *p;

    n = BLEN(b);

    if(q->bypass){
        (*q->bypass)(q->arg, b);
        return n;
    }

    dowakeup = 0;
    qlock(&q->wlock);
    if(waserror()){
        if(b != nil)
            freeb(b);
        qunlock(&q->wlock);
        nexterror();
    }

    ilock(q);

    /* give up if the queue is closed */
    if(q->state & Qclosed){
        iunlock(q);
        error(q->err);
    }

    /* if nonblocking, don't queue over the limit */
    if(q->len >= q->limit){
        if(q->noblock){
            iunlock(q);
            freeb(b);
            noblockcnt += n;
            qunlock(&q->wlock);
            poperror();
            return n;
        }
    }

    /* queue the block */
    if(q->bfirst)
        q->blast->next = b;
    else
        q->bfirst = b;
    q->blast = b;
    b->next = 0;
    q->len += BALLOC(b);
    q->dlen += n;
    QDEBUG checkb(b, "qbwrite");
    b = nil;

    /* make sure other end gets awakened */
    if(q->state & Qstarve){
        q->state &= ~Qstarve;
        dowakeup = 1;
    }
    iunlock(q);

    /*  get output going again */
    if(q->kick && (dowakeup || (q->state&Qkick)))
        q->kick(q->arg);

    /* wakeup anyone consuming at the other end */
    if(dowakeup){
        p = wakeup(&q->rr);

        /* if we just wokeup a higher priority process, let it run */
        if(p != nil && p->priority > up->priority)
            sched();
    }

    /*
     *  flow control, wait for queue to get below the limit
     *  before allowing the process to continue and queue
     *  more.  We do this here so that postnote can only
     *  interrupt us after the data has been queued.  This
     *  means that things like 9p flushes and ssl messages
     *  will not be disrupted by software interrupts.
     *
     *  Note - this is moderately dangerous since a process
     *  that keeps getting interrupted and rewriting will
     *  queue infinite crud.
     */
    for(;;){
        if(q->noblock || qnotfull(q))
            break;

        ilock(q);
        q->state |= Qflow;
        iunlock(q);
        sleep(&q->wr, qnotfull, q);
    }
    USED(b);

    qunlock(&q->wlock);
    poperror();
    return n;
}

/*
 *  write to a queue.  only Maxatomic bytes at a time is atomic.
 */
int
qwrite(Queue *q, void *vp, int len)
{
    int n, sofar;
    Block *b;
    uchar *p = vp;

    QDEBUG if(!islo())
        print("qwrite hi %#p\n", getcallerpc(&q));

    sofar = 0;
    do {
        n = len-sofar;
        if(n > Maxatomic)
            n = Maxatomic;

        b = allocb(n);
        setmalloctag(b, (up->text[0]<<24)|(up->text[1]<<16)|(up->text[2]<<8)|up->text[3]);
        if(waserror()){
            freeb(b);
            nexterror();
        }
        memmove(b->wp, p+sofar, n);
        poperror();
        b->wp += n;

        qbwrite(q, b);

        sofar += n;
    } while(sofar < len && (q->state & Qmsg) == 0);

    return len;
}

/*
 *  used by print() to write to a queue.  Since we may be splhi or not in
 *  a process, don't qlock.
 *
 *  this routine merges adjacent blocks if block n+1 will fit into
 *  the free space of block n.
 */
int
qiwrite(Queue *q, void *vp, int len)
{
    int n, sofar, dowakeup;
    Block *b;
    uchar *p = vp;

    dowakeup = 0;

    sofar = 0;
    do {
        n = len-sofar;
        if(n > Maxatomic)
            n = Maxatomic;

        b = iallocb(n);
        if(b == nil)
            break;
        memmove(b->wp, p+sofar, n);
        b->wp += n;

        ilock(q);

        /* we use an artificially high limit for kernel prints since anything
         * over the limit gets dropped
         */
        if(q->dlen >= 16*1024){
            iunlock(q);
            freeb(b);
            break;
        }

        QDEBUG checkb(b, "qiwrite");
        if(q->bfirst)
            q->blast->next = b;
        else
            q->bfirst = b;
        q->blast = b;
        q->len += BALLOC(b);
        q->dlen += n;

        if(q->state & Qstarve){
            q->state &= ~Qstarve;
            dowakeup = 1;
        }

        iunlock(q);

        if(dowakeup){
            if(q->kick)
                q->kick(q->arg);
            wakeup(&q->rr);
        }

        sofar += n;
    } while(sofar < len && (q->state & Qmsg) == 0);

    return sofar;
}

/*
 *  be extremely careful when calling this,
 *  as there is no reference accounting
 */
void
qfree(Queue *q)
{
    qclose(q);
    free(q);
}

/*
 *  Mark a queue as closed.  No further IO is permitted.
 *  All blocks are released.
 */
void
qclose(Queue *q)
{
    Block *bfirst;

    if(q == nil)
        return;

    /* mark it */
    ilock(q);
    q->state |= Qclosed;
    q->state &= ~(Qflow|Qstarve);
    strcpy(q->err, Ehungup);
    bfirst = q->bfirst;
    q->bfirst = 0;
    q->len = 0;
    q->dlen = 0;
    q->noblock = 0;
    iunlock(q);

    /* free queued blocks */
    freeblist(bfirst);

    /* wake up readers/writers */
    wakeup(&q->rr);
    wakeup(&q->wr);
}

/*
 *  Mark a queue as closed.  Wakeup any readers.  Don't remove queued
 *  blocks.
 */
void
qhangup(Queue *q, char *msg)
{
    /* mark it */
    ilock(q);
    q->state |= Qclosed;
    if(msg == 0 || *msg == 0)
        strcpy(q->err, Ehungup);
    else
        strncpy(q->err, msg, ERRMAX-1);
    iunlock(q);

    /* wake up readers/writers */
    wakeup(&q->rr);
    wakeup(&q->wr);
}

/*
 *  return non-zero if the q is hungup
 */
int
qisclosed(Queue *q)
{
    return q->state & Qclosed;
}

/*
 *  mark a queue as no longer hung up
 */
void
qreopen(Queue *q)
{
    ilock(q);
    q->state &= ~Qclosed;
    q->state |= Qstarve;
    q->eof = 0;
    q->limit = q->inilim;
    iunlock(q);
}

/*
 *  return bytes queued
 */
int
qlen(Queue *q)
{
    return q->dlen;
}

/*
 * return space remaining before flow control
 */
int
qwindow(Queue *q)
{
    int l;

    l = q->limit - q->len;
    if(l < 0)
        l = 0;
    return l;
}

/*
 *  return true if we can read without blocking
 */
int
qcanread(Queue *q)
{
    return q->bfirst!=0;
}

/*
 *  change queue limit
 */
void
qsetlimit(Queue *q, int limit)
{
    q->limit = limit;
}

/*
 *  set blocking/nonblocking
 */
void
qnoblock(Queue *q, int onoff)
{
    q->noblock = onoff;
}

/*
 *  flush the output queue
 */
void
qflush(Queue *q)
{
    Block *bfirst;

    /* mark it */
    ilock(q);
    bfirst = q->bfirst;
    q->bfirst = 0;
    q->len = 0;
    q->dlen = 0;
    iunlock(q);

    /* free queued blocks */
    freeblist(bfirst);

    /* wake up readers/writers */
    wakeup(&q->wr);
}

int
qfull(Queue *q)
{
    return q->state & Qflow;
}

//unused
//int
//qstate(Queue *q)
//{
//  return q->state;
//}
@


\subsection*{[[files/sysfile.c]]}

<<sysfile.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

/*
 * The sys*() routines needn't poperror() as they return directly to syscall().
 */

static void
unlockfgrp(Fgrp *f)
{
    int ex;

    ex = f->exceed;
    f->exceed = 0;
    unlock(f);
    if(ex)
        pprint("warning: process exceeds %d file descriptors\n", ex);
}

int
growfd(Fgrp *f, int fd) /* fd is always >= 0 */
{
    Chan **newfd, **oldfd;

    if(fd < f->nfd)
        return 0;
    if(fd >= f->nfd+DELTAFD)
        return -1;  /* out of range */
    /*
     * Unbounded allocation is unwise
     */
    if(f->nfd >= 5000){
    Exhausted:
        print("no free file descriptors\n");
        return -1;
    }
    newfd = malloc((f->nfd+DELTAFD)*sizeof(Chan*));
    if(newfd == 0)
        goto Exhausted;
    oldfd = f->fd;
    memmove(newfd, oldfd, f->nfd*sizeof(Chan*));
    f->fd = newfd;
    free(oldfd);
    f->nfd += DELTAFD;
    if(fd > f->maxfd){
        if(fd/100 > f->maxfd/100)
            f->exceed = (fd/100)*100;
        f->maxfd = fd;
    }
    return 1;
}

/*
 *  this assumes that the fgrp is locked
 */
int
findfreefd(Fgrp *f, int start)
{
    int fd;

    for(fd=start; fd<f->nfd; fd++)
        if(f->fd[fd] == 0)
            break;
    if(fd >= f->nfd && growfd(f, fd) < 0)
        return -1;
    return fd;
}

int
newfd(Chan *c)
{
    int fd;
    Fgrp *f;

    f = up->fgrp;
    lock(f);
    fd = findfreefd(f, 0);
    if(fd < 0){
        unlockfgrp(f);
        return -1;
    }
    if(fd > f->maxfd)
        f->maxfd = fd;
    f->fd[fd] = c;
    unlockfgrp(f);
    return fd;
}

int
newfd2(int fd[2], Chan *c[2])
{
    Fgrp *f;

    f = up->fgrp;
    lock(f);
    fd[0] = findfreefd(f, 0);
    if(fd[0] < 0){
        unlockfgrp(f);
        return -1;
    }
    fd[1] = findfreefd(f, fd[0]+1);
    if(fd[1] < 0){
        unlockfgrp(f);
        return -1;
    }
    if(fd[1] > f->maxfd)
        f->maxfd = fd[1];
    f->fd[fd[0]] = c[0];
    f->fd[fd[1]] = c[1];
    unlockfgrp(f);

    return 0;
}



long
sysfd2path(ulong *arg)
{
    Chan *c;

    validaddr(arg[1], arg[2], 1);

    c = fdtochan(arg[0], -1, 0, 1);
    snprint((char*)arg[1], arg[2], "%s", chanpath(c));
    cclose(c);
    return 0;
}

long
syspipe(ulong *arg)
{
    int fd[2];
    Chan *c[2];
    Dev *d;
    static char *datastr[] = {"data", "data1"};

    validaddr(arg[0], 2*BY2WD, 1);
    evenaddr(arg[0]);
    d = devtab[devno('|', 0)];
    c[0] = namec("#|", Atodir, 0, 0);
    c[1] = 0;
    fd[0] = -1;
    fd[1] = -1;

    if(waserror()){
        cclose(c[0]);
        if(c[1])
            cclose(c[1]);
        nexterror();
    }
    c[1] = cclone(c[0]);
    if(walk(&c[0], datastr+0, 1, 1, nil) < 0)
        error(Egreg);
    if(walk(&c[1], datastr+1, 1, 1, nil) < 0)
        error(Egreg);
    c[0] = d->open(c[0], ORDWR);
    c[1] = d->open(c[1], ORDWR);
    if(newfd2(fd, c) < 0)
        error(Enofd);
    poperror();

    ((long*)arg[0])[0] = fd[0];
    ((long*)arg[0])[1] = fd[1];
    return 0;
}

long
sysdup(ulong *arg)
{
    int fd;
    Chan *c, *oc;
    Fgrp *f = up->fgrp;

    /*
     * Close after dup'ing, so date > #d/1 works
     */
    c = fdtochan(arg[0], -1, 0, 1);
    fd = arg[1];
    if(fd != -1){
        lock(f);
        if(fd<0 || growfd(f, fd)<0) {
            unlockfgrp(f);
            cclose(c);
            error(Ebadfd);
        }
        if(fd > f->maxfd)
            f->maxfd = fd;

        oc = f->fd[fd];
        f->fd[fd] = c;
        unlockfgrp(f);
        if(oc)
            cclose(oc);
    }else{
        if(waserror()) {
            cclose(c);
            nexterror();
        }
        fd = newfd(c);
        if(fd < 0)
            error(Enofd);
        poperror();
    }

    return fd;
}

long
sysopen(ulong *arg)
{
    int fd;
    Chan *c;

    openmode(arg[1]);   /* error check only */
    validaddr(arg[0], 1, 0);
    c = namec((char*)arg[0], Aopen, arg[1], 0);
    if(waserror()){
        cclose(c);
        nexterror();
    }
    fd = newfd(c);
    if(fd < 0)
        error(Enofd);
    poperror();
    return fd;
}


long
sysclose(ulong *arg)
{
    fdtochan(arg[0], -1, 0, 0);
    fdclose(arg[0], 0);

    return 0;
}

long
unionread(Chan *c, void *va, long n)
{
    int i;
    long nr;
    Mhead *m;
    Mount *mount;

    qlock(&c->umqlock);
    m = c->umh;
    rlock(&m->lock);
    mount = m->mount;
    /* bring mount in sync with c->uri and c->umc */
    for(i = 0; mount != nil && i < c->uri; i++)
        mount = mount->next;

    nr = 0;
    while(mount != nil){
        /* Error causes component of union to be skipped */
        if(mount->to && !waserror()){
            if(c->umc == nil){
                c->umc = cclone(mount->to);
                c->umc = devtab[c->umc->type]->open(c->umc, OREAD);
            }
    
            nr = devtab[c->umc->type]->read(c->umc, va, n, c->umc->offset);
            c->umc->offset += nr;
            poperror();
        }
        if(nr > 0)
            break;

        /* Advance to next element */
        c->uri++;
        if(c->umc){
            cclose(c->umc);
            c->umc = nil;
        }
        mount = mount->next;
    }
    runlock(&m->lock);
    qunlock(&c->umqlock);
    return nr;
}

static void
unionrewind(Chan *c)
{
    qlock(&c->umqlock);
    c->uri = 0;
    if(c->umc){
        cclose(c->umc);
        c->umc = nil;
    }
    qunlock(&c->umqlock);
}

static int
dirfixed(uchar *p, uchar *e, Dir *d)
{
    int len;

    len = GBIT16(p)+BIT16SZ;
    if(p + len > e)
        return -1;

    p += BIT16SZ;   /* ignore size */
    d->type = devno(GBIT16(p), 1);
    p += BIT16SZ;
    d->dev = GBIT32(p);
    p += BIT32SZ;
    d->qid.type = GBIT8(p);
    p += BIT8SZ;
    d->qid.vers = GBIT32(p);
    p += BIT32SZ;
    d->qid.path = GBIT64(p);
    p += BIT64SZ;
    d->mode = GBIT32(p);
    p += BIT32SZ;
    d->atime = GBIT32(p);
    p += BIT32SZ;
    d->mtime = GBIT32(p);
    p += BIT32SZ;
    d->length = GBIT64(p);

    return len;
}

static char*
dirname(uchar *p, int *n)
{
    p += BIT16SZ+BIT16SZ+BIT32SZ+BIT8SZ+BIT32SZ+BIT64SZ
        + BIT32SZ+BIT32SZ+BIT32SZ+BIT64SZ;
    *n = GBIT16(p);
    return (char*)p+BIT16SZ;
}

static long
dirsetname(char *name, int len, uchar *p, long n, long maxn)
{
    char *oname;
    int olen;
    long nn;

    if(n == BIT16SZ)
        return BIT16SZ;

    oname = dirname(p, &olen);

    nn = n+len-olen;
    PBIT16(p, nn-BIT16SZ);
    if(nn > maxn)
        return BIT16SZ;

    if(len != olen)
        memmove(oname+len, oname+olen, p+n-(uchar*)(oname+olen));
    PBIT16((uchar*)(oname-2), len);
    memmove(oname, name, len);
    return nn;
}

/*
 * Mountfix might have caused the fixed results of the directory read
 * to overflow the buffer.  Catch the overflow in c->dirrock.
 */
static void
mountrock(Chan *c, uchar *p, uchar **pe)
{
    uchar *e, *r;
    int len, n;

    e = *pe;

    /* find last directory entry */
    for(;;){
        len = BIT16SZ+GBIT16(p);
        if(p+len >= e)
            break;
        p += len;
    }

    /* save it away */
    qlock(&c->rockqlock);
    if(c->nrock+len > c->mrock){
        n = ROUND(c->nrock+len, 1024);
        r = smalloc(n);
        memmove(r, c->dirrock, c->nrock);
        free(c->dirrock);
        c->dirrock = r;
        c->mrock = n;
    }
    memmove(c->dirrock+c->nrock, p, len);
    c->nrock += len;
    qunlock(&c->rockqlock);

    /* drop it */
    *pe = p;
}

/*
 * Satisfy a directory read with the results saved in c->dirrock.
 */
static int
mountrockread(Chan *c, uchar *op, long n, long *nn)
{
    long dirlen;
    uchar *rp, *erp, *ep, *p;

    /* common case */
    if(c->nrock == 0)
        return 0;

    /* copy out what we can */
    qlock(&c->rockqlock);
    rp = c->dirrock;
    erp = rp+c->nrock;
    p = op;
    ep = p+n;
    while(rp+BIT16SZ <= erp){
        dirlen = BIT16SZ+GBIT16(rp);
        if(p+dirlen > ep)
            break;
        memmove(p, rp, dirlen);
        p += dirlen;
        rp += dirlen;
    }

    if(p == op){
        qunlock(&c->rockqlock);
        return 0;
    }

    /* shift the rest */
    if(rp != erp)
        memmove(c->dirrock, rp, erp-rp);
    c->nrock = erp - rp;

    *nn = p - op;
    qunlock(&c->rockqlock);
    return 1;
}

static void
mountrewind(Chan *c)
{
    c->nrock = 0;
}

/*
 * Rewrite the results of a directory read to reflect current 
 * name space bindings and mounts.  Specifically, replace
 * directory entries for bind and mount points with the results
 * of statting what is mounted there.  Except leave the old names.
 */
static long
mountfix(Chan *c, uchar *op, long n, long maxn)
{
    char *name;
    int nbuf, nname;
    Chan *nc;
    Mhead *mh;
    Mount *m;
    uchar *p;
    int dirlen, rest;
    long l;
    uchar *buf, *e;
    Dir d;

    p = op;
    buf = nil;
    nbuf = 0;
    for(e=&p[n]; p+BIT16SZ<e; p+=dirlen){
        dirlen = dirfixed(p, e, &d);
        if(dirlen < 0)
            break;
        nc = nil;
        mh = nil;
        if(findmount(&nc, &mh, d.type, d.dev, d.qid)){
            /*
             * If it's a union directory and the original is
             * in the union, don't rewrite anything.
             */
            for(m=mh->mount; m; m=m->next)
                if(eqchantdqid(m->to, d.type, d.dev, d.qid, 1))
                    goto Norewrite;

            name = dirname(p, &nname);
            /*
             * Do the stat but fix the name.  If it fails, leave old entry.
             * BUG: If it fails because there isn't room for the entry,
             * what can we do?  Nothing, really.  Might as well skip it.
             */
            if(buf == nil){
                buf = smalloc(4096);
                nbuf = 4096;
            }
            if(waserror())
                goto Norewrite;
            l = devtab[nc->type]->stat(nc, buf, nbuf);
            l = dirsetname(name, nname, buf, l, nbuf);
            if(l == BIT16SZ)
                error("dirsetname");
            poperror();

            /*
             * Shift data in buffer to accomodate new entry,
             * possibly overflowing into rock.
             */
            rest = e - (p+dirlen);
            if(l > dirlen){
                while(p+l+rest > op+maxn){
                    mountrock(c, p, &e);
                    if(e == p){
                        dirlen = 0;
                        goto Norewrite;
                    }
                    rest = e - (p+dirlen);
                }
            }
            if(l != dirlen){
                memmove(p+l, p+dirlen, rest);
                dirlen = l;
                e = p+dirlen+rest;
            }

            /*
             * Rewrite directory entry.
             */
            memmove(p, buf, l);

            Norewrite:
            cclose(nc);
            putmhead(mh);
        }
    }
    if(buf)
        free(buf);

    if(p != e)
        error("oops in rockfix");

    return e-op;
}

static long
read(ulong *arg, vlong *offp)
{
    long n, nn, nnn;
    uchar *p;
    Chan *c;
    vlong off;

    n = arg[2];
    validaddr(arg[1], n, 1);
    p = (void*)arg[1];
    c = fdtochan(arg[0], OREAD, 1, 1);

    if(waserror()){
        cclose(c);
        nexterror();
    }

    /*
     * The offset is passed through on directories, normally.
     * Sysseek complains, but pread is used by servers like exportfs,
     * that shouldn't need to worry about this issue.
     *
     * Notice that c->devoffset is the offset that c's dev is seeing.
     * The number of bytes read on this fd (c->offset) may be different
     * due to rewritings in rockfix.
     */
    if(offp == nil) /* use and maintain channel's offset */
        off = c->offset;
    else
        off = *offp;
    if(off < 0)
        error(Enegoff);

    if(off == 0){   /* rewind to the beginning of the directory */
        if(offp == nil){
            c->offset = 0;
            c->devoffset = 0;
        }
        mountrewind(c);
        unionrewind(c);
    }

    if(c->qid.type & QTDIR){
        if(mountrockread(c, p, n, &nn)){
            /* do nothing: mountrockread filled buffer */
        }else if(c->umh)
            nn = unionread(c, p, n);
        else{
            if(off != c->offset)
                error(Edirseek);
            nn = devtab[c->type]->read(c, p, n, c->devoffset);
        }
        nnn = mountfix(c, p, nn, n);
    }else
        nnn = nn = devtab[c->type]->read(c, p, n, off);

    lock(c);
    c->devoffset += nn;
    c->offset += nnn;
    unlock(c);

    poperror();
    cclose(c);

    return nnn;
}

long
sys_read(ulong *arg)
{
    return read(arg, nil);
}

long
syspread(ulong *arg)
{
    vlong v;
    va_list list;

    /* use varargs to guarantee alignment of vlong */
    va_start(list, arg[2]);
    v = va_arg(list, vlong);
    va_end(list);

    if(v == ~0ULL)
        return read(arg, nil);

    return read(arg, &v);
}

static long
write(ulong *arg, vlong *offp)
{
    Chan *c;
    long m, n;
    vlong off;

    validaddr(arg[1], arg[2], 0);
    n = 0;
    c = fdtochan(arg[0], OWRITE, 1, 1);
    if(waserror()) {
        if(offp == nil){
            lock(c);
            c->offset -= n;
            unlock(c);
        }
        cclose(c);
        nexterror();
    }

    if(c->qid.type & QTDIR)
        error(Eisdir);

    n = arg[2];

    if(offp == nil){    /* use and maintain channel's offset */
        lock(c);
        off = c->offset;
        c->offset += n;
        unlock(c);
    }else
        off = *offp;

    if(off < 0)
        error(Enegoff);

    m = devtab[c->type]->write(c, (void*)arg[1], n, off);

    if(offp == nil && m < n){
        lock(c);
        c->offset -= n - m;
        unlock(c);
    }

    poperror();
    cclose(c);

    return m;
}

long
sys_write(ulong *arg)
{
    return write(arg, nil);
}

long
syspwrite(ulong *arg)
{
    vlong v;
    va_list list;

    /* use varargs to guarantee alignment of vlong */
    va_start(list, arg[2]);
    v = va_arg(list, vlong);
    va_end(list);

    if(v == ~0ULL)
        return write(arg, nil);

    return write(arg, &v);
}

static void
sseek(ulong *arg)
{
    Chan *c;
    uchar buf[sizeof(Dir)+100];
    Dir dir;
    int n;
    vlong off;
    union {
        vlong v;
        ulong u[2];
    } o;

    c = fdtochan(arg[1], -1, 1, 1);
    if(waserror()){
        cclose(c);
        nexterror();
    }
    if(devtab[c->type]->dc == '|')
        error(Eisstream);

    off = 0;
    o.u[0] = arg[2];
    o.u[1] = arg[3];
    switch(arg[4]){
    case 0:
        off = o.v;
        if((c->qid.type & QTDIR) && off != 0)
            error(Eisdir);
        if(off < 0)
            error(Enegoff);
        c->offset = off;
        break;

    case 1:
        if(c->qid.type & QTDIR)
            error(Eisdir);
        lock(c);    /* lock for read/write update */
        off = o.v + c->offset;
        if(off < 0){
            unlock(c);
            error(Enegoff);
        }
        c->offset = off;
        unlock(c);
        break;

    case 2:
        if(c->qid.type & QTDIR)
            error(Eisdir);
        n = devtab[c->type]->stat(c, buf, sizeof buf);
        if(convM2D(buf, n, &dir, nil) == 0)
            error("internal error: stat error in seek");
        off = dir.length + o.v;
        if(off < 0)
            error(Enegoff);
        c->offset = off;
        break;

    default:
        error(Ebadarg);
    }
    *(vlong*)arg[0] = off;
    c->uri = 0;
    c->dri = 0;
    cclose(c);
    poperror();
}

long
sysseek(ulong *arg)
{
    validaddr(arg[0], BY2V, 1);
    sseek(arg);
    return 0;
}

long
sysoseek(ulong *arg)
{
    union {
        vlong v;
        ulong u[2];
    } o;
    ulong a[5];

    o.v = (long)arg[1];
    a[0] = (ulong)&o.v;
    a[1] = arg[0];
    a[2] = o.u[0];
    a[3] = o.u[1];
    a[4] = arg[2];
    sseek(a);
    return o.v;
}


static char*
pathlast(Path *p)
{
    char *s;

    if(p == nil)
        return nil;
    if(p->len == 0)
        return nil;
    s = strrchr(p->s, '/');
    if(s)
        return s+1;
    return p->s;
}

long
sysfstat(ulong *arg)
{
    Chan *c;
    uint l;

    l = arg[2];
    validaddr(arg[1], l, 1);
    c = fdtochan(arg[0], -1, 0, 1);
    if(waserror()) {
        cclose(c);
        nexterror();
    }
    l = devtab[c->type]->stat(c, (uchar*)arg[1], l);
    poperror();
    cclose(c);
    return l;
}

long
sysstat(ulong *arg)
{
    char *name;
    Chan *c;
    uint l;

    l = arg[2];
    validaddr(arg[1], l, 1);
    validaddr(arg[0], 1, 0);
    c = namec((char*)arg[0], Aaccess, 0, 0);
    if(waserror()){
        cclose(c);
        nexterror();
    }
    l = devtab[c->type]->stat(c, (uchar*)arg[1], l);
    name = pathlast(c->path);
    if(name)
        l = dirsetname(name, strlen(name), (uchar*)arg[1], l, arg[2]);

    poperror();
    cclose(c);
    return l;
}

long
syschdir(ulong *arg)
{
    Chan *c;

    validaddr(arg[0], 1, 0);

    c = namec((char*)arg[0], Atodir, 0, 0);
    cclose(up->dot);
    up->dot = c;
    return 0;
}

long
bindmount(int ismount, int fd, int afd, char* arg0, char* arg1, ulong flag, char* spec)
{
    int ret;
    Chan *c0, *c1, *ac, *bc;
    struct{
        Chan    *chan;
        Chan    *authchan;
        char    *spec;
        int flags;
    }bogus;

    if((flag&~MMASK) || (flag&MORDER)==(MBEFORE|MAFTER))
        error(Ebadarg);

    if(ismount){
        validaddr((ulong)spec, 1, 0);
        spec = validnamedup(spec, 1);
        if(waserror()){
            free(spec);
            nexterror();
        }

        if(up->pgrp->noattach)
            error(Enoattach);

        ac = nil;
        bc = fdtochan(fd, ORDWR, 0, 1);
        if(waserror()) {
            if(ac)
                cclose(ac);
            cclose(bc);
            nexterror();
        }

        if(afd >= 0)
            ac = fdtochan(afd, ORDWR, 0, 1);

        bogus.flags = flag & MCACHE;
        bogus.chan = bc;
        bogus.authchan = ac;
        bogus.spec = spec;
        ret = devno('M', 0);
        c0 = devtab[ret]->attach((char*)&bogus);
        poperror(); /* ac bc */
        if(ac)
            cclose(ac);
        cclose(bc);
    }else{
        spec = 0;
        validaddr((ulong)arg0, 1, 0);
        c0 = namec(arg0, Abind, 0, 0);
    }

    if(waserror()){
        cclose(c0);
        nexterror();
    }

    validaddr((ulong)arg1, 1, 0);
    c1 = namec(arg1, Amount, 0, 0);
    if(waserror()){
        cclose(c1);
        nexterror();
    }

    ret = cmount(&c0, c1, flag, spec);

    poperror();
    cclose(c1);
    poperror();
    cclose(c0);
    if(ismount){
        fdclose(fd, 0);
        poperror();
        free(spec);
    }
    return ret;
}

long
sysbind(ulong *arg)
{
    return bindmount(0, -1, -1, (char*)arg[0], (char*)arg[1], arg[2], nil);
}

long
sysmount(ulong *arg)
{
    return bindmount(1, arg[0], arg[1], nil, (char*)arg[2], arg[3], (char*)arg[4]);
}

long
sys_mount(ulong *arg)
{
    return bindmount(1, arg[0], -1, nil, (char*)arg[1], arg[2], (char*)arg[3]);
}

long
sysunmount(ulong *arg)
{
    Chan *cmount, *cmounted;

    cmounted = 0;

    validaddr(arg[1], 1, 0);
    cmount = namec((char *)arg[1], Amount, 0, 0);
    if(waserror()) {
        cclose(cmount);
        if(cmounted)
            cclose(cmounted);
        nexterror();
    }

    if(arg[0]) {
        /*
         * This has to be namec(..., Aopen, ...) because
         * if arg[0] is something like /srv/cs or /fd/0,
         * opening it is the only way to get at the real
         * Chan underneath.
         */
        validaddr(arg[0], 1, 0);
        cmounted = namec((char*)arg[0], Aopen, OREAD, 0);
    }
    cunmount(cmount, cmounted);
    poperror();
    cclose(cmount);
    if(cmounted)
        cclose(cmounted);
    return 0;
}

long
syscreate(ulong *arg)
{
    int fd;
    Chan *c;

    openmode(arg[1]&~OEXCL);    /* error check only; OEXCL okay here */
    validaddr(arg[0], 1, 0);
    c = namec((char*)arg[0], Acreate, arg[1], arg[2]);
    if(waserror()) {
        cclose(c);
        nexterror();
    }
    fd = newfd(c);
    if(fd < 0)
        error(Enofd);
    poperror();
    return fd;
}

long
sysremove(ulong *arg)
{
    Chan *c;

    validaddr(arg[0], 1, 0);
    c = namec((char*)arg[0], Aremove, 0, 0);
    /*
     * Removing mount points is disallowed to avoid surprises
     * (which should be removed: the mount point or the mounted Chan?).
     */
    if(c->ismtpt){
        cclose(c);
        error(Eismtpt);
    }
    if(waserror()){
        c->type = 0;    /* see below */
        cclose(c);
        nexterror();
    }
    devtab[c->type]->remove(c);
    /*
     * Remove clunks the fid, but we need to recover the Chan
     * so fake it up.  rootclose() is known to be a nop.
     */
    c->type = 0;
    poperror();
    cclose(c);
    return 0;
}

static long
wstat(Chan *c, uchar *d, int nd)
{
    long l;
    int namelen;

    if(waserror()){
        cclose(c);
        nexterror();
    }
    if(c->ismtpt){
        /*
         * Renaming mount points is disallowed to avoid surprises
         * (which should be renamed? the mount point or the mounted Chan?).
         */
        dirname(d, &namelen);
        if(namelen)
            nameerror(chanpath(c), Eismtpt);
    }
    l = devtab[c->type]->wstat(c, d, nd);
    poperror();
    cclose(c);
    return l;
}

long
syswstat(ulong *arg)
{
    Chan *c;
    uint l;

    l = arg[2];
    validaddr(arg[1], l, 0);
    validstat((uchar*)arg[1], l);
    validaddr(arg[0], 1, 0);
    c = namec((char*)arg[0], Aaccess, 0, 0);
    return wstat(c, (uchar*)arg[1], l);
}

long
sysfwstat(ulong *arg)
{
    Chan *c;
    uint l;

    l = arg[2];
    validaddr(arg[1], l, 0);
    validstat((uchar*)arg[1], l);
    c = fdtochan(arg[0], -1, 1, 1);
    return wstat(c, (uchar*)arg[1], l);
}

static void
packoldstat(uchar *buf, Dir *d)
{
    uchar *p;
    ulong q;

    /* lay down old stat buffer - grotty code but it's temporary */
    p = buf;
    strncpy((char*)p, d->name, 28);
    p += 28;
    strncpy((char*)p, d->uid, 28);
    p += 28;
    strncpy((char*)p, d->gid, 28);
    p += 28;
    q = d->qid.path & ~DMDIR;   /* make sure doesn't accidentally look like directory */
    if(d->qid.type & QTDIR) /* this is the real test of a new directory */
        q |= DMDIR;
    PBIT32(p, q);
    p += BIT32SZ;
    PBIT32(p, d->qid.vers);
    p += BIT32SZ;
    PBIT32(p, d->mode);
    p += BIT32SZ;
    PBIT32(p, d->atime);
    p += BIT32SZ;
    PBIT32(p, d->mtime);
    p += BIT32SZ;
    PBIT64(p, d->length);
    p += BIT64SZ;
    PBIT16(p, d->type);
    p += BIT16SZ;
    PBIT16(p, d->dev);
}

long
sys_stat(ulong *arg)
{
    Chan *c;
    uint l;
    uchar buf[128]; /* old DIRLEN plus a little should be plenty */
    char strs[128], *name;
    Dir d;
    char old[] = "old stat system call - recompile";

    validaddr(arg[1], 116, 1);
    validaddr(arg[0], 1, 0);
    c = namec((char*)arg[0], Aaccess, 0, 0);
    if(waserror()){
        cclose(c);
        nexterror();
    }
    l = devtab[c->type]->stat(c, buf, sizeof buf);
    /* buf contains a new stat buf; convert to old. yuck. */
    if(l <= BIT16SZ)    /* buffer too small; time to face reality */
        error(old);
    name = pathlast(c->path);
    if(name)
        l = dirsetname(name, strlen(name), buf, l, sizeof buf);
    l = convM2D(buf, l, &d, strs);
    if(l == 0)
        error(old);
    packoldstat((uchar*)arg[1], &d);
    
    poperror();
    cclose(c);
    return 0;
}

long
sys_fstat(ulong *arg)
{
    Chan *c;
    char *name;
    uint l;
    uchar buf[128]; /* old DIRLEN plus a little should be plenty */
    char strs[128];
    Dir d;
    char old[] = "old fstat system call - recompile";

    validaddr(arg[1], 116, 1);
    c = fdtochan(arg[0], -1, 0, 1);
    if(waserror()){
        cclose(c);
        nexterror();
    }
    l = devtab[c->type]->stat(c, buf, sizeof buf);
    /* buf contains a new stat buf; convert to old. yuck. */
    if(l <= BIT16SZ)    /* buffer too small; time to face reality */
        error(old);
    name = pathlast(c->path);
    if(name)
        l = dirsetname(name, strlen(name), buf, l, sizeof buf);
    l = convM2D(buf, l, &d, strs);
    if(l == 0)
        error(old);
    packoldstat((uchar*)arg[1], &d);
    
    poperror();
    cclose(c);
    return 0;
}

long
sys_wstat(ulong *)
{
    error("old wstat system call - recompile");
    return -1;
}

long
sys_fwstat(ulong *)
{
    error("old fwstat system call - recompile");
    return -1;
}
@


\section{[[filesystems/]]}

\subsection*{[[filesystems/devfs.c]]}

<<devfs.c>>=
/*
 * File system devices.
 * Follows device config in Ken's file server.
 * Builds mirrors, concatenations, interleavings, and partitions
 * of devices out of other (inner) devices.
 * It is ok if inner devices are provided by this driver.
 *
 * Built files are grouped on different directories
 * (called trees, and used to represent disks).
 * The "#k/fs" tree is always available and never goes away.
 * Configuration changes happen only while no I/O is in progress.
 *
 * Default sector size is one byte unless changed by the "disk" ctl.
 */

#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"
#include "../port/error.h"

enum
{
    Fnone,
    Fmirror,        /* mirror of others */
    Fcat,           /* catenation of others */
    Finter,         /* interleaving of others */
    Fpart,          /* part of other */
    Fclear,         /* start over */
    Fdel,           /* delete a configure device */
    Fdisk,          /* set default tree and sector sz*/

    Sectorsz = 1,
    Blksize = 8*1024,   /* for Finter only */

    Incr = 5,       /* Increments for the dev array */

    /*
     * All qids are decorated with the tree number.
     * #k/fs is tree number 0, is automatically added and
     * its first qid is for the ctl file. It never goes away.
     */
    Qtop    = 0,        /* #k */
    Qdir,           /* directory (#k/fs) */
    Qctl,           /* ctl, only for #k/fs/ctl */
    Qfirst,         /* first qid assigned for device */

    Iswrite = 0,
    Isread,

    Optional = 0,
    Mustexist,

    /* tunable parameters */
    Maxconf = 4*1024,   /* max length for config */
    Ndevs   = 32,       /* max. inner devs per command */
    Ntrees  = 128,      /* max. number of trees */
    Maxretries = 3,     /* max. retries of i/o errors */
    Retrypause = 5000,  /* ms. to pause between retries */
};

typedef struct Inner Inner;
typedef struct Fsdev Fsdev;
typedef struct Tree Tree;

struct Inner
{
    char    *iname;     /* inner device name */
    vlong   isize;      /* size of inner device */
    Chan    *idev;      /* inner device */
};

struct Fsdev
{
    Ref;            /* one per Chan doing I/O */
    int gone;       /* true if removed */
    int vers;       /* qid version for this device */
    int type;       /* Fnone, Fmirror, ... */
    char    *name;      /* name for this fsdev */
    Tree*   tree;       /* where the device is kept */
    vlong   size;       /* min(inner[X].isize) */
    vlong   start;      /* start address (for Fpart) */
    uint    ndevs;      /* number of inner devices */
    int perm;       /* minimum of inner device perms */
    Inner   *inner[Ndevs];  /* inner devices */
};

struct Tree
{
    char    *name;      /* name for #k/<name> */
    Fsdev   **devs;     /* devices in dir. */
    uint    ndevs;      /* number of devices */
    uint    nadevs;     /* number of allocated devices in devs */
};

#define dprint if(debug)print

extern Dev fsdevtab;        /* forward */

static RWlock lck;      /* r: use devices; w: change config  */
static Tree fstree;     /* The main "fs" tree. Never goes away */
static Tree *trees[Ntrees]; /* internal representation of config */
static int ntrees;      /* max number of trees */
static int qidvers;

static char *disk;      /* default tree name used */
static char *source;        /* default inner device used */
static int sectorsz = Sectorsz; /* default sector size */

static char confstr[Maxconf];   /* textual configuration */

static int debug;

static char cfgstr[] = "fsdev:\n";

static Qid tqid = {Qtop, 0, QTDIR};
static Qid cqid = {Qctl, 0, 0};

static char* tnames[] = {
    [Fmirror]   "mirror",
    [Fcat]      "cat",
    [Finter]    "inter",
    [Fpart]     "part",
};

static Cmdtab configs[] = {
    Fmirror,"mirror",   0,
    Fcat,   "cat",      0,
    Finter, "inter",    0,
    Fpart,  "part",     0,
    Fclear, "clear",    1,
    Fdel,   "del",      2,
    Fdisk,  "disk",     0,
};

static char Egone[] = "device is gone";     /* file has been removed */

static char*
seprintdev(char *s, char *e, Fsdev *mp)
{
    int i;

    if(mp == nil)
        return seprint(s, e, "<null Fsdev>");
    if(mp->type < 0 || mp->type >= nelem(tnames) || tnames[mp->type] == nil)
        return seprint(s, e, "bad device type %d\n", mp->type);

    s = strecpy(s, e, tnames[mp->type]);
    if(mp->tree != &fstree)
        s = seprint(s, e, " %s/%s", mp->tree->name, mp->name);
    else
        s = seprint(s, e, " %s", mp->name);
    for(i = 0; i < mp->ndevs; i++)
        s = seprint(s, e, " %s", mp->inner[i]->iname);
    switch(mp->type){
    case Fmirror:
    case Fcat:
    case Finter:
        s = strecpy(s, e, "\n");
        break;
    case Fpart:
        s = seprint(s, e, " %ulld %ulld\n", mp->start, mp->size);
        break;
    default:
        panic("#k: seprintdev bug");
    }
    return s;
}

static vlong
mkpath(int tree, int devno)
{
    return (tree&0xFFFF)<<16 | devno&0xFFFF;
}

static int
path2treeno(int q)
{
    return q>>16 & 0xFFFF;
}

static int
path2devno(int q)
{
    return q & 0xFFFF;
}

static Tree*
gettree(int i, int mustexist)
{
    dprint("gettree %d\n", i);
    if(i < 0)
        panic("#k: bug: bad tree index %d in gettree", i);
    if(i >= ntrees || trees[i] == nil)
        if(mustexist)
            error(Enonexist);
        else
            return nil;
    return trees[i];
}

static Fsdev*
getdev(Tree *t, int i, int mustexist)
{
    dprint("getdev %d\n", i);
    if(i < 0)
        panic("#k: bug: bad dev index %d in getdev", i);
    if(i >= t->nadevs || t->devs[i] == nil)
        if(mustexist)
            error(Enonexist);
        else
            return nil;
    return t->devs[i];
}

static Fsdev*
path2dev(int q)
{
    Tree    *t;

    dprint("path2dev %ux\n", q);
    t = gettree(path2treeno(q), Mustexist);
    return getdev(t, path2devno(q) - Qfirst, Mustexist);
}

static Tree*
treealloc(char *name)
{
    int i;
    Tree    *t;

    dprint("treealloc %s\n", name);
    for(i = 0; i < nelem(trees); i++)
        if(trees[i] == nil)
            break;
    if(i == nelem(trees))
        return nil;
    t = trees[i] = mallocz(sizeof(Tree), 1);
    if(t == nil)
        return nil;
    if(i == ntrees)
        ntrees++;
    kstrdup(&t->name, name);
    return t;
}

static Tree*
lookuptree(char *name)
{
    int i;

    dprint("lookuptree %s\n", name);
    for(i = 0; i < ntrees; i++)
        if(trees[i] != nil && strcmp(trees[i]->name, name) == 0)
            return trees[i];
    return nil;
}

static Fsdev*
devalloc(Tree *t, char *name)
{
    int i, ndevs;
    Fsdev   *mp, **devs;

    dprint("devalloc %s %s\n", t->name, name);
    mp = mallocz(sizeof(Fsdev), 1);
    if(mp == nil)
        return nil;
    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] == nil)
            break;
    if(i >= t->nadevs){
        if(t->nadevs % Incr == 0){
            ndevs = t->nadevs + Incr;
            devs = realloc(t->devs, ndevs * sizeof(Fsdev*));
            if(devs == nil){
                free(mp);
                return nil;
            }
            t->devs = devs;
        }
        t->devs[t->nadevs] = nil;
        t->nadevs++;
    }
    kstrdup(&mp->name, name);
    mp->vers = ++qidvers;
    mp->tree = t;
    t->devs[i] = mp;
    t->ndevs++;
    return mp;
}

static void
deltree(Tree *t)
{
    int i;

    dprint("deltree %s\n", t->name);
    for(i = 0; i < ntrees; i++)
        if(trees[i] == t){
            if(i > 0){      /* "fs" never goes away */
                free(t->name);
                free(t->devs);
                free(t);
                trees[i] = nil;
            }
            return;
        }
    panic("#k: deltree: bug: tree not found");
}

/*
 * A device is gone and we know that all its users are gone.
 * A tree is gone when all its devices are gone ("fs" is never gone).
 * Must close devices outside locks, so we could nest our own devices.
 */
static void
mdeldev(Fsdev *mp)
{
    int i;
    Inner   *in;
    Tree    *t;

    dprint("deldev %s gone %d ref %uld\n", mp->name, mp->gone, mp->ref);

    mp->gone = 1;
    mp->vers = ++qidvers;

    wlock(&lck);
    t = mp->tree;
    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] == mp){
            t->devs[i] = nil;
            t->ndevs--;
            if(t->ndevs == 0)
                deltree(t);
            break;
        }
    wunlock(&lck);

    free(mp->name);
    for(i = 0; i < mp->ndevs; i++){
        in = mp->inner[i];
        if(in->idev != nil)
            cclose(in->idev);
        free(in->iname);
        free(in);
    }
    if(debug)
        memset(mp, 9, sizeof *mp);  /* poison */
    free(mp);
}

/*
 * Delete one or all devices in one or all trees.
 */
static void
mdelctl(char *tname, char *dname)
{
    int i, alldevs, alltrees, some;
    Fsdev *mp;
    Tree *t;

    dprint("delctl %s\n", dname);
    alldevs = strcmp(dname, "*") == 0;
    alltrees = strcmp(tname, "*") == 0;
    some = 0;
Again:
    wlock(&lck);
    for(i = 0; i < ntrees; i++){
        t = trees[i];
        if(t == nil)
            continue;
        if(alltrees == 0 && strcmp(t->name, tname) != 0)
            continue;
        for(i = 0; i < t->nadevs; i++){
            mp = t->devs[i];
            if(t->devs[i] == nil)
                continue;
            if(alldevs == 0 && strcmp(mp->name, dname) != 0)
                continue;
            /*
             * Careful: must close outside locks and that
             * may change the file tree we are looking at.
             */
            some++;
            mp->gone = 1;
            if(mp->ref == 0){
                incref(mp); /* keep it there */
                wunlock(&lck);
                mdeldev(mp);
                goto Again; /* tree can change */
            }
        }
    }
    wunlock(&lck);
    if(some == 0 && alltrees == 0)
        error(Enonexist);
}

static void
setdsize(Fsdev* mp, vlong *ilen)
{
    int i;
    vlong   inlen;
    Inner   *in;

    dprint("setdsize %s\n", mp->name);
    for (i = 0; i < mp->ndevs; i++){
        in = mp->inner[i];
        in->isize = ilen[i];
        inlen = in->isize;
        switch(mp->type){
        case Finter:
            /* truncate to multiple of Blksize */
            inlen &= ~(Blksize-1);
            in->isize = inlen;
            /* fall through */
        case Fmirror:
            /* use size of smallest inner device */
            if (mp->size == 0 || mp->size > inlen)
                mp->size = inlen;
            break;
        case Fcat:
            mp->size += inlen;
            break;
        case Fpart:
            if(mp->start > inlen)
                error("partition starts after device end");
            if(inlen < mp->start + mp->size){
                print("#k: %s: partition truncated from "
                    "%lld to %lld bytes\n", mp->name,
                    mp->size, inlen - mp->start);
                mp->size = inlen - mp->start;
            }
            break;
        }
    }
    if(mp->type == Finter)
        mp->size *= mp->ndevs;
}

static void
validdevname(Tree *t, char *dname)
{
    int i;

    for(i = 0; i < t->nadevs; i++)
        if(t->devs[i] != nil && strcmp(t->devs[i]->name, dname) == 0)
            error(Eexist);
}

static void
parseconfig(char *a, long n, Cmdbuf **cbp, Cmdtab **ctp)
{
    Cmdbuf  *cb;
    Cmdtab  *ct;

    *cbp = cb = parsecmd(a, n);
    *ctp = ct = lookupcmd(cb, configs, nelem(configs));

    cb->f++;            /* skip command */
    cb->nf--;
    switch(ct->index){
    case Fmirror:
    case Fcat:
    case Finter:
        if(cb->nf < 2)
            error("too few arguments for ctl");
        if(cb->nf - 1 > Ndevs)
            error("too many devices in ctl");
        break;
    case Fdisk:
        if(cb->nf < 1 || cb->nf > 3)
            error("ctl usage: disk name [sz dev]");
        break;
    case Fpart:
        if(cb->nf != 4 && (cb->nf != 3 || source == nil))
            error("ctl usage: part new [file] off len");
        break;
    }
}

static void
parsename(char *name, char *disk, char **tree, char **dev)
{
    char *slash;

    slash = strchr(name, '/');
    if(slash == nil){
        if(disk != nil)
            *tree = disk;
        else
            *tree = "fs";
        *dev = name;
    }else{
        *tree = name;
        *slash++ = 0;
        *dev = slash;
    }
    validname(*tree, 0);
    validname(*dev, 0);
}

static int
getattrs(Chan *c, vlong *lenp, int *permp)
{
    uchar   buf[128];   /* old DIRLEN plus a little should be plenty */
    Dir d;
    long    l;

    *lenp = 0;
    *permp = 0;
    l = devtab[c->type]->stat(c, buf, sizeof buf);
    if (l >= 0 && convM2D(buf, l, &d, nil) > 0) {
        *lenp = d.length;
        *permp = d.mode & 0777;
    }
    return l;
}

/*
 * Process a single line of configuration,
 * often of the form "cmd newname idev0 idev1".
 * locking is tricky, because we need a write lock to
 * add/remove devices yet adding/removing them may lead
 * to calls to this driver that require a read lock (when
 * inner devices are also provided by us).
 */
static void
mconfig(char* a, long n)
{
    int i;
    int *iperm;
    vlong   size, start;
    vlong   *ilen;
    char    *tname, *dname, *fakef[4];
    Chan    **idev;
    Cmdbuf  *cb;
    Cmdtab  *ct;
    Fsdev   *mp;
    Inner   *inprv;
    Tree    *t;

    /* ignore comments & empty lines */
    if (*a == '\0' || *a == '#' || *a == '\n')
        return;

    dprint("mconfig\n");
    size = 0;
    start = 0;
    mp = nil;
    cb = nil;
    idev = nil;
    ilen = nil;
    iperm = nil;

    if(waserror()){
        free(cb);
        nexterror();
    }

    parseconfig(a, n, &cb, &ct);
    switch (ct->index) {
    case Fdisk:
        kstrdup(&disk, cb->f[0]);
        if(cb->nf >= 2)
            sectorsz = strtoul(cb->f[1], 0, 0);
        else
            sectorsz = Sectorsz;
        if(cb->nf == 3)
            kstrdup(&source, cb->f[2]);
        else{
            free(source);
            source = nil;
        }
        poperror();
        free(cb);
        return;
    case Fclear:
        poperror();
        free(cb);
        mdelctl("*", "*");      /* del everything */
        return;
    case Fpart:
        if(cb->nf == 3){
            /*
             * got a request in the format of sd(3),
             * pretend we got one in our format.
             * later we change end to be len.
             */
            fakef[0] = cb->f[0];
            fakef[1] = source;
            fakef[2] = cb->f[1];
            fakef[3] = cb->f[2];
            cb->f = fakef;
            cb->nf = 4;
        }
        start = strtoll(cb->f[2], nil, 10);
        size =  strtoll(cb->f[3], nil, 10);
        if(cb->f == fakef)
            size -= start;      /* it was end */
        cb->nf -= 2;
        break;
    }
    parsename(cb->f[0], disk, &tname, &dname);
    for(i = 1; i < cb->nf; i++)
        validname(cb->f[i], 1);

    if(ct->index == Fdel){
        mdelctl(tname, dname);
        poperror();
        free(cb);
        return;
    }

    /*
     * Open all inner devices while we have only a read lock.
     */
    poperror();
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
Fail:
        for(i = 1; i < cb->nf; i++)
            if(idev != nil && idev[i-1] != nil)
                cclose(idev[i]);
        if(mp != nil)
            mdeldev(mp);
        free(idev);
        free(ilen);
        free(iperm);
        free(cb);
        nexterror();
    }
    /* record names, lengths and perms of all named files */
    idev = smalloc(sizeof(Chan*) * Ndevs);
    ilen = smalloc(sizeof(vlong) * Ndevs);
    iperm = smalloc(sizeof(int) * Ndevs);
    for(i = 1; i < cb->nf; i++){
        idev[i-1] = namec(cb->f[i], Aopen, ORDWR, 0);
        getattrs(idev[i-1], &ilen[i-1], &iperm[i-1]);
    }
    poperror();
    runlock(&lck);

    /*
     * Get a write lock and add the device if we can.
     */
    wlock(&lck);
    if(waserror()){
        wunlock(&lck);
        goto Fail;
    }

    t = lookuptree(tname);
    if(t != nil)
        validdevname(t, dname);
    else
        t = treealloc(tname);
    if(t == nil)
        error("no more trees");
    mp = devalloc(t, dname);
    if(mp == nil){
        if(t->ndevs == 0)   /* it was created for us */
            deltree(t); /* but we will not mdeldev() */
        error(Enomem);
    }

    /* construct mp from iname, idev and iperm arrays */
    mp->type = ct->index;
    if(mp->type == Fpart){
        mp->start = start * sectorsz;
        mp->size = size * sectorsz;
    }
    mp->perm = 0666;
    for(i = 1; i < cb->nf; i++){
        inprv = mp->inner[i-1] = mallocz(sizeof(Inner), 1);
        if(inprv == nil)
            error(Enomem);
        mp->ndevs++;
        kstrdup(&inprv->iname, cb->f[i]);
        inprv->idev = idev[i-1];
        idev[i-1] = nil;
        /* use the most restrictive of the inner permissions */
        mp->perm &= iperm[i-1];
    }
    setdsize(mp, ilen);

    poperror();
    wunlock(&lck);
    free(idev);
    free(ilen);
    free(iperm);
    free(cb);
}

static void
rdconf(void)
{
    int mustrd;
    char *c, *e, *p, *s;
    Chan *cc;
    static int configed;

    /* only read config file once */
    if (configed)
        return;
    configed = 1;

    dprint("rdconf\n");
    /* add the std "fs" tree */
    trees[0] = &fstree;
    ntrees++;
    fstree.name = "fs";

    /* identify the config file */
    s = getconf("fsconfig");
    if (s == nil){
        mustrd = 0;
        s = "/dev/sdC0/fscfg";
    } else
        mustrd = 1;

    /* read it */
    cc = nil;
    c = nil;
    if (waserror()){
        if (cc != nil)
            cclose(cc);
        if (c)
            free(c);
        if (!mustrd)
            return;
        nexterror();
    }
    cc = namec(s, Aopen, OREAD, 0);
    devtab[cc->type]->read(cc, confstr, sizeof confstr, 0);
    cclose(cc);
    cc = nil;

    /* validate, copy and erase config; mconfig will repopulate confstr */
    if (strncmp(confstr, cfgstr, sizeof cfgstr - 1) != 0)
        error("bad #k config, first line must be: 'fsdev:\\n'");
    kstrdup(&c, confstr + sizeof cfgstr - 1);
    memset(confstr, 0, sizeof confstr);

    /* process config copy one line at a time */
    for (p = c; p != nil && *p != '\0'; p = e){
        e = strchr(p, '\n');
        if (e == nil)
            e = p + strlen(p);
        else
            e++;
        mconfig(p, e - p);
    }
    USED(cc);       /* until now, can be used in waserror clause */
    poperror();
}

static int
mgen(Chan *c, char*, Dirtab*, int, int i, Dir *dp)
{
    int treeno;
    Fsdev   *mp;
    Qid qid;
    Tree    *t;

    dprint("mgen %#ullx %d\n", c->qid.path, i);
    qid.type = QTDIR;
    qid.vers = 0;
    if(c->qid.path == Qtop){
        if(i == DEVDOTDOT){
            devdir(c, tqid, "#k", 0, eve, DMDIR|0775, dp);
            return 1;
        }
        t = gettree(i, Optional);
        if(t == nil){
            dprint("no\n");
            return -1;
        }
        qid.path = mkpath(i, Qdir);
        devdir(c, qid, t->name, 0, eve, DMDIR|0775, dp);
        return 1;
    }

    treeno = path2treeno(c->qid.path);
    t = gettree(treeno, Optional);
    if(t == nil){
        dprint("no\n");
        return -1;
    }
    if((c->qid.type & QTDIR) != 0){
        if(i == DEVDOTDOT){
            devdir(c, tqid, "#k", 0, eve, DMDIR|0775, dp);
            return 1;
        }
        if(treeno == 0){
            /* take care of #k/fs/ctl */
            if(i == 0){
                devdir(c, cqid, "ctl", 0, eve, 0664, dp);
                return 1;
            }
            i--;
        }
        mp = getdev(t, i, Optional);
        if(mp == nil){
            dprint("no\n");
            return -1;
        }
        qid.type = QTFILE;
        qid.vers = mp->vers;
        qid.path = mkpath(treeno, Qfirst+i);
        devdir(c, qid, mp->name, mp->size, eve, mp->perm, dp);
        return 1;
    }

    if(i == DEVDOTDOT){
        qid.path = mkpath(treeno, Qdir);
        devdir(c, qid, t->name, 0, eve, DMDIR|0775, dp);
        return 1;
    }
    dprint("no\n");
    return -1;
}

static Chan*
mattach(char *spec)
{
    dprint("mattach\n");
    return devattach(fsdevtab.dc, spec);
}

static Walkqid*
mwalk(Chan *c, Chan *nc, char **name, int nname)
{
    Walkqid *wq;

    rdconf();

    dprint("mwalk %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    wq = devwalk(c, nc, name, nname, 0, 0, mgen);
    poperror();
    runlock(&lck);
    return wq;
}

static int
mstat(Chan *c, uchar *db, int n)
{
    int p;
    Dir d;
    Fsdev   *mp;
    Qid q;
    Tree    *t;

    dprint("mstat %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    p = c->qid.path;
    memset(&d, 0, sizeof d);
    switch(p){
    case Qtop:
        devdir(c, tqid, "#k", 0, eve, DMDIR|0775, &d);
        break;
    case Qctl:
        devdir(c, cqid, "ctl", 0, eve, 0664, &d);
        break;
    default:
        t = gettree(path2treeno(p), Mustexist);
        if(c->qid.type & QTDIR)
            devdir(c, c->qid, t->name, 0, eve, DMDIR|0775, &d);
        else{
            mp = getdev(t, path2devno(p) - Qfirst, Mustexist);
            q = c->qid;
            q.vers = mp->vers;
            devdir(c, q, mp->name, mp->size, eve, mp->perm, &d);
        }
    }
    n = convD2M(&d, db, n);
    if (n == 0)
        error(Ebadarg);
    poperror();
    runlock(&lck);
    return n;
}

static Chan*
mopen(Chan *c, int omode)
{
    int q;
    Fsdev   *mp;

    dprint("mopen %llux\n", c->qid.path);
    if((c->qid.type & QTDIR) && omode != OREAD)
        error(Eperm);
    if(c->qid.path != Qctl && (c->qid.type&QTDIR) == 0){
        rlock(&lck);
        if(waserror()){
            runlock(&lck);
            nexterror();
        }
        q = c->qid.path;
        mp = path2dev(q);
        if(mp->gone)
            error(Egone);
        devpermcheck(eve, mp->perm, omode);
        incref(mp);
        poperror();
        runlock(&lck);
    }
    /*
     * Our mgen does not return the info for the qid
     * but only for its children. Don't use devopen here.
     */
    c->offset = 0;
    c->mode = openmode(omode & ~OTRUNC);
    c->flag |= COPEN;
    return c;
}

static void
mclose(Chan *c)
{
    int mustdel, q;
    Fsdev   *mp;

    dprint("mclose %llux\n", c->qid.path);
    if(c->qid.type & QTDIR || !(c->flag & COPEN))
        return;
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    mustdel = 0;
    mp = nil;
    q = c->qid.path;
    if(q == Qctl){
        free(disk);
        disk = nil; /* restore defaults */
        free(source);
        source = nil;
        sectorsz = Sectorsz;
    }else{
        mp = path2dev(q);
        if(mp->gone != 0 && mp->ref == 1)
            mustdel = 1;
        else
            decref(mp);
    }
    poperror();
    runlock(&lck);
    if(mustdel)
        mdeldev(mp);
}

static long
io(Fsdev *mp, Inner *in, int isread, void *a, long l, vlong off)
{
    long wl;
    Chan    *mc;

    mc = in->idev;
    if(mc == nil)
        error(Egone);
    if (waserror()) {
        print("#k: %s: byte %,lld count %ld (of #k/%s): %s error: %s\n",
            in->iname, off, l, mp->name, (isread? "read": "write"),
            (up && up->errstr? up->errstr: ""));
        nexterror();
    }
    if (isread)
        wl = devtab[mc->type]->read(mc, a, l, off);
    else
        wl = devtab[mc->type]->write(mc, a, l, off);
    poperror();
    return wl;
}

/* NB: a transfer could span multiple inner devices */
static long
catio(Fsdev *mp, int isread, void *a, long n, vlong off)
{
    int i;
    long    l, res;
    Inner   *in;

    if(debug)
        print("catio %d %p %ld %lld\n", isread, a, n, off);
    res = n;
    for (i = 0; n > 0 && i < mp->ndevs; i++){
        in = mp->inner[i];
        if (off >= in->isize){
            off -= in->isize;
            continue;       /* not there yet */
        }
        if (off + n > in->isize)
            l = in->isize - off;
        else
            l = n;
        if(debug)
            print("\tdev %d %p %ld %lld\n", i, a, l, off);

        if (io(mp, in, isread, a, l, off) != l)
            error(Eio);

        a = (char*)a + l;
        off = 0;
        n -= l;
    }
    if(debug)
        print("\tres %ld\n", res - n);
    return res - n;
}

static long
interio(Fsdev *mp, int isread, void *a, long n, vlong off)
{
    int i;
    long    boff, res, l, wl, wsz;
    vlong   woff, blk, mblk;

    blk  = off / Blksize;
    boff = off % Blksize;
    wsz  = Blksize - boff;
    res = n;
    while(n > 0){
        mblk = blk / mp->ndevs;
        i    = blk % mp->ndevs;
        woff = mblk*Blksize + boff;
        if (n > wsz)
            l = wsz;
        else
            l = n;

        wl = io(mp, mp->inner[i], isread, a, l, woff);
        if (wl != l)
            error(Eio);

        blk++;
        boff = 0;
        wsz = Blksize;
        a = (char*)a + l;
        n -= l;
    }
    return res;
}

static char*
seprintconf(char *s, char *e)
{
    int i, j;
    Tree    *t;

    *s = 0;
    for(i = 0; i < ntrees; i++){
        t = trees[i];
        if(t != nil)
            for(j = 0; j < t->nadevs; j++)
                if(t->devs[j] != nil)
                    s = seprintdev(s, e, t->devs[j]);
    }
    return s;
}

static long
mread(Chan *c, void *a, long n, vlong off)
{
    int i, retry;
    long    l, res;
    Fsdev   *mp;
    Tree    *t;

    dprint("mread %llux\n", c->qid.path);
    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }
    res = -1;
    if(c->qid.type & QTDIR){
        res = devdirread(c, a, n, 0, 0, mgen);
        goto Done;
    }
    if(c->qid.path == Qctl){
        seprintconf(confstr, confstr + sizeof(confstr));
        res = readstr((long)off, a, n, confstr);
        goto Done;
    }

    t = gettree(path2treeno(c->qid.path), Mustexist);
    mp = getdev(t, path2devno(c->qid.path) - Qfirst, Mustexist);

    if(off >= mp->size){
        res = 0;
        goto Done;
    }
    if(off + n > mp->size)
        n = mp->size - off;
    if(n == 0){
        res = 0;
        goto Done;
    }

    switch(mp->type){
    case Fcat:
        res = catio(mp, Isread, a, n, off);
        break;
    case Finter:
        res = interio(mp, Isread, a, n, off);
        break;
    case Fpart:
        res = io(mp, mp->inner[0], Isread, a, n, mp->start + off);
        break;
    case Fmirror:
        retry = 0;
        do {
            if (retry > 0) {
                print("#k/%s: retry %d read for byte %,lld "
                    "count %ld: %s\n", mp->name, retry, off,
                    n, (up && up->errstr? up->errstr: ""));
                /*
                 * pause before retrying in case it's due to
                 * a transient bus or controller problem.
                 */
                tsleep(&up->sleep, return0, 0, Retrypause);
            }
            for (i = 0; i < mp->ndevs; i++){
                if (waserror())
                    continue;
                l = io(mp, mp->inner[i], Isread, a, n, off);
                poperror();
                if (l >= 0){
                    res = l;
                    break;      /* read a good copy */
                }
            }
        } while (i == mp->ndevs && ++retry <= Maxretries);
        if (retry > Maxretries) {
            /* no mirror had a good copy of the block */
            print("#k/%s: byte %,lld count %ld: CAN'T READ "
                "from mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
            error(Eio);
        } else if (retry > 0)
            print("#k/%s: byte %,lld count %ld: retry read OK "
                "from mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
        break;
    }
Done:
    poperror();
    runlock(&lck);
    return res;
}

static long
mwrite(Chan *c, void *a, long n, vlong off)
{
    int i, allbad, anybad, retry;
    long    l, res;
    Fsdev   *mp;
    Tree    *t;

    dprint("mwrite %llux\n", c->qid.path);
    if (c->qid.type & QTDIR)
        error(Eisdir);
    if (c->qid.path == Qctl){
        mconfig(a, n);
        return n;
    }

    rlock(&lck);
    if(waserror()){
        runlock(&lck);
        nexterror();
    }

    t = gettree(path2treeno(c->qid.path), Mustexist);
    mp = getdev(t, path2devno(c->qid.path) - Qfirst, Mustexist);

    if(off >= mp->size){
        res = 0;
        goto Done;
    }
    if(off + n > mp->size)
        n = mp->size - off;
    if(n == 0){
        res = 0;
        goto Done;
    }
    res = n;
    switch(mp->type){
    case Fcat:
        res = catio(mp, Iswrite, a, n, off);
        break;
    case Finter:
        res = interio(mp, Iswrite, a, n, off);
        break;
    case Fpart:
        res = io(mp, mp->inner[0], Iswrite, a, n, mp->start + off);
        if (res != n)
            error(Eio);
        break;
    case Fmirror:
        retry = 0;
        do {
            if (retry > 0) {
                print("#k/%s: retry %d write for byte %,lld "
                    "count %ld: %s\n", mp->name, retry, off,
                    n, (up && up->errstr? up->errstr: ""));
                /*
                 * pause before retrying in case it's due to
                 * a transient bus or controller problem.
                 */
                tsleep(&up->sleep, return0, 0, Retrypause);
            }
            allbad = 1;
            anybad = 0;
            for (i = mp->ndevs - 1; i >= 0; i--){
                if (waserror()) {
                    anybad = 1;
                    continue;
                }
                l = io(mp, mp->inner[i], Iswrite, a, n, off);
                poperror();
                if (l == n)
                    allbad = 0; /* wrote a good copy */
                else
                    anybad = 1;
            }
        } while (anybad && ++retry <= Maxretries);
        if (allbad) {
            /* no mirror took a good copy of the block */
            print("#k/%s: byte %,lld count %ld: CAN'T WRITE "
                "to mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));
            error(Eio);
        } else if (retry > 0)
            print("#k/%s: byte %,lld count %ld: retry wrote OK "
                "to mirror: %s\n", mp->name, off, n,
                (up && up->errstr? up->errstr: ""));

        break;
    }
Done:
    poperror();
    runlock(&lck);
    return res;
}

Dev fsdevtab = {
    'k',
    "fs",

    devreset,
    devinit,
    devshutdown,
    mattach,
    mwalk,
    mstat,
    mopen,
    devcreate,
    mclose,
    mread,
    devbread,
    mwrite,
    devbwrite,
    devremove,
    devwstat,
    devpower,
    devconfig,
};
@


\section{[[init/]]}

\subsection*{[[init/386/apbootstrap.s]]}

<<apbootstrap.s>>=
/*
 * Start an Application Processor. This must be placed on a 4KB boundary
 * somewhere in the 1st MB of conventional memory (APBOOTSTRAP). However,
 * due to some shortcuts below it's restricted further to within the 1st
 * 64KB. The AP starts in real-mode, with
 *   CS selector set to the startup memory address/16;
 *   CS base set to startup memory address;
 *   CS limit set to 64KB;
 *   CPL and IP set to 0.
 */
#include "mem.h"

#define NOP             BYTE $0x90              /* NOP */
#define LGDT(gdtptr)    BYTE $0x0F;             /* LGDT */                      \
                        BYTE $0x01; BYTE $0x16;                                 \
                        WORD $gdtptr
#define FARJUMP16(s, o) BYTE $0xEA;             /* far jump to ptr16:16 */      \
                        WORD $o; WORD $s;                                       \
                        NOP; NOP; NOP
#define FARJUMP32(s, o) BYTE $0x66;             /* far jump to ptr32:16 */      \
                        BYTE $0xEA; LONG $o; WORD $s

#define DELAY           BYTE $0xEB;             /* JMP .+2 */                   \
                        BYTE $0x00
#define INVD            BYTE $0x0F; BYTE $0x08
#define WBINVD          BYTE $0x0F; BYTE $0x09

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. Note that these are assembler-specific hence
 * the '<<2'.
 */
#define PDO(a)          (((((a))>>22) & 0x03FF)<<2)
#define PTO(a)          (((((a))>>12) & 0x03FF)<<2)

TEXT apbootstrap(SB), $0
        FARJUMP16(0, _apbootstrap(SB))
TEXT _apvector(SB), $0                          /* address APBOOTSTRAP+0x08 */
        LONG $0
TEXT _appdb(SB), $0                             /* address APBOOTSTRAP+0x0C */
        LONG $0
TEXT _apapic(SB), $0                            /* address APBOOTSTRAP+0x10 */
        LONG $0
TEXT _apbootstrap(SB), $0                       /* address APBOOTSTRAP+0x14 */
        MOVW    CS, AX
        MOVW    AX, DS                          /* initialise DS */

        LGDT(gdtptr(SB))                        /* load a basic gdt */

        MOVL    CR0, AX
        ORL     $1, AX
        MOVL    AX, CR0                         /* turn on protected mode */
        DELAY                                   /* JMP .+2 */

        BYTE $0xB8; WORD $SELECTOR(1, SELGDT, 0)/* MOVW $SELECTOR(1, SELGDT, 0), AX */
        MOVW    AX, DS
        MOVW    AX, ES
        MOVW    AX, FS
        MOVW    AX, GS
        MOVW    AX, SS

        FARJUMP32(SELECTOR(2, SELGDT, 0), _ap32-KZERO(SB))

/*
 * For Pentiums and higher, the code that enables paging must come from
 * pages that are identity mapped. 
 * To this end double map KZERO at virtual 0 and undo the mapping once virtual
 * nirvana has been obtained.
 */
TEXT _ap32(SB), $0
        MOVL    _appdb-KZERO(SB), CX            /* physical address of PDB */
        MOVL    (PDO(KZERO))(CX), DX            /* double-map KZERO at 0 */
        MOVL    DX, (PDO(0))(CX)
        MOVL    CX, CR3                         /* load and flush the mmu */

        MOVL    CR0, DX
        ORL     $0x80010000, DX                 /* PG|WP */
        ANDL    $~0x6000000A, DX                /* ~(CD|NW|TS|MP) */

        MOVL    $_appg(SB), AX
        MOVL    DX, CR0                         /* turn on paging */
        JMP*    AX

TEXT _appg(SB), $0
        MOVL    CX, AX                          /* physical address of PDB */
        ORL     $KZERO, AX
        MOVL    $0, (PDO(0))(AX)                /* undo double-map of KZERO at 0 */
        MOVL    CX, CR3                         /* load and flush the mmu */

        MOVL    $(MACHADDR+MACHSIZE-4), SP

        MOVL    $0, AX
        PUSHL   AX
        POPFL

        MOVL    _apapic(SB), AX
        MOVL    AX, (SP)
        MOVL    _apvector(SB), AX
        CALL*   AX
_aphalt:
        HLT
        JMP     _aphalt

TEXT gdt(SB), $0
        LONG $0x0000; LONG $0
        LONG $0xFFFF; LONG $(SEGG|SEGB|(0xF<<16)|SEGP|SEGPL(0)|SEGDATA|SEGW)
        LONG $0xFFFF; LONG $(SEGG|SEGD|(0xF<<16)|SEGP|SEGPL(0)|SEGEXEC|SEGR)
TEXT gdtptr(SB), $0
        WORD    $(3*8-1)
        LONG    $gdt-KZERO(SB)
@


\subsection*{[[init/386/init9.c]]}

<<init9.c>>=
//@Scheck: def can actually be found initcode.c, but this file is in skip list
extern void startboot(char*, char**);

//@Scheck: TODO who calls that??
void
_main(char *argv0)
{
    startboot(argv0, &argv0);
}
@


\subsection*{[[init/386/initcode.s]]}

<<initcode.s>>=
#include "/sys/src/libc/9syscall/sys.h"

TEXT    main(SB),$0

        /*
         *  exec("/boot", bootv)
         */
        LEAL    4(SP),AX
        PUSHL   AX
        LEAL    boot(SB),AX
        PUSHL   AX
        PUSHL   $0
        MOVL    $EXEC,AX
        INT     $64

        /*
         *  should never get here
         */
here:
        JMP     here

GLOBL   boot+0(SB),$6
DATA    boot+0(SB)/5,$"/boot"
@


\subsection*{[[init/386/l.s]]}

<<l.s>>=
#include "mem.h"
#undef DELAY

//*****************************************************************************
// Constants/Macros
//*****************************************************************************

#define PADDR(a)        ((a) & ~KZERO)
#define KADDR(a)        (KZERO|(a))

/*
 * Some machine instructions not handled by 8[al].
 */
#define DELAY           BYTE $0xEB; BYTE $0x00  /* JMP .+2 */

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. Note that these are assembler-specific hence
 * the '<<2'.
 */
#define PDO(a)          (((((a))>>22) & 0x03FF)<<2)
#define PTO(a)          (((((a))>>12) & 0x03FF)<<2)

//*****************************************************************************
// Entry point!! (after jump from l_multiboot.s)
//*****************************************************************************

/*
 * In protected mode with paging turned off and segment registers setup
 * to linear map all memory. Entered via a jump to PADDR(entry),
 * the physical address of the virtual kernel entry point of KADDR(entry).
 * Make the basic page tables for processor 0. Six pages are needed for
 * the basic set:
 *      a page directory;
 *      page tables for mapping the first 8MB of physical memory to KZERO;
 *      a page for the GDT;
 *      virtual and physical pages for mapping the Mach structure.
 * The remaining PTEs will be allocated later when memory is sized.
 * An identity mmu map is also needed for the switch to virtual mode.
 * This identity mapping is removed once the MMU is going and the JMP has
 * been made to virtual memory.
 */
TEXT _startPADDR(SB), $0
        CLI                     /* make sure interrupts are off */

        /* set up the gdt so we have sane plan 9 style gdts. */
        MOVL    $tgdtptr(SB), AX
        ANDL    $~KZERO, AX
        MOVL    (AX), GDTR
        MOVW    $1, AX
        MOVW    AX, MSW

        /* clear prefetch queue (weird code to avoid optimizations) */
        DELAY

        /* set segs to something sane (avoid traps later) */
        MOVW    $(1<<3), AX
        MOVW    AX, DS
        MOVW    AX, SS
        MOVW    AX, ES
        MOVW    AX, FS
        MOVW    AX, GS

/*      JMP     $(2<<3):$mode32bit(SB) /**/
         BYTE   $0xEA
         LONG   $mode32bit-KZERO(SB)
         WORD   $(2<<3)


//*****************************************************************************
// Gdts Data
//*****************************************************************************
        
/*
 *  gdt to get us to 32-bit/segmented/unpaged mode
 */
TEXT tgdt(SB), $0

        /* null descriptor */
        LONG    $0
        LONG    $0

        /* data segment descriptor for 4 gigabytes (PL 0) */
        LONG    $(0xFFFF)
        LONG    $(SEGG|SEGB|(0xF<<16)|SEGP|SEGPL(0)|SEGDATA|SEGW)

        /* exec segment descriptor for 4 gigabytes (PL 0) */
        LONG    $(0xFFFF)
        LONG    $(SEGG|SEGD|(0xF<<16)|SEGP|SEGPL(0)|SEGEXEC|SEGR)

/*
 *  pointer to initial gdt
 *  Note the -KZERO which puts the physical address in the gdtptr. 
 *  that's needed as we start executing in physical addresses. 
 */
TEXT tgdtptr(SB), $0
        WORD    $(3*8)
        LONG    $tgdt-KZERO(SB)

TEXT m0rgdtptr(SB), $0
        WORD    $(NGDT*8-1)
        LONG    $(CPU0GDT-KZERO)

TEXT m0gdtptr(SB), $0
        WORD    $(NGDT*8-1)
        LONG    $CPU0GDT

TEXT m0idtptr(SB), $0
        WORD $(256*8-1)
        LONG $IDTADDR

//*****************************************************************************
// Assume protected 32 bit and GTD done
//*****************************************************************************

TEXT mode32bit(SB), $0
        /* At this point, the GDT setup is done. */

        MOVL    $PADDR(CPU0PDB), DI             /* clear 4 pages for the tables etc. */
        XORL    AX, AX
        MOVL    $(4*BY2PG), CX
        SHRL    $2, CX

        CLD
        REP;    STOSL

        MOVL    $PADDR(CPU0PDB), AX
        ADDL    $PDO(KZERO), AX                 /* page directory offset for KZERO */
        MOVL    $PADDR(CPU0PTE), (AX)           /* PTE's for KZERO */
        MOVL    $(PTEWRITE|PTEVALID), BX        /* page permissions */
        ORL     BX, (AX)

        ADDL    $4, AX
        MOVL    $PADDR(CPU0PTE1), (AX)          /* PTE's for KZERO+4MB */
        MOVL    $(PTEWRITE|PTEVALID), BX        /* page permissions */
        ORL     BX, (AX)

        MOVL    $PADDR(CPU0PTE), AX             /* first page of page table */
        MOVL    $1024, CX                       /* 1024 pages in 4MB */
_setpte:
        MOVL    BX, (AX)
        ADDL    $(1<<PGSHIFT), BX
        ADDL    $4, AX
        LOOP    _setpte

        MOVL    $PADDR(CPU0PTE1), AX            /* second page of page table */
        MOVL    $1024, CX                       /* 1024 pages in 4MB */
_setpte1:
        MOVL    BX, (AX)
        ADDL    $(1<<PGSHIFT), BX
        ADDL    $4, AX
        LOOP    _setpte1

        MOVL    $PADDR(CPU0PTE), AX
        ADDL    $PTO(MACHADDR), AX              /* page table entry offset for MACHADDR */
        MOVL    $PADDR(CPU0MACH), (AX)          /* PTE for Mach */
        MOVL    $(PTEWRITE|PTEVALID), BX        /* page permissions */
        ORL     BX, (AX)

/*
 * Now ready to use the new map. Make sure the processor options are what is wanted.
 * It is necessary on some processors to immediately follow mode switching with a JMP instruction
 * to clear the prefetch queues.
 */
        MOVL    $PADDR(CPU0PDB), CX             /* load address of page directory */
        MOVL    (PDO(KZERO))(CX), DX            /* double-map KZERO at 0 */
        MOVL    DX, (PDO(0))(CX)
        MOVL    CX, CR3
        DELAY                                   /* JMP .+2 */

        MOVL    CR0, DX
        ORL     $0x80010000, DX                 /* PG|WP */
        ANDL    $~0x6000000A, DX                /* ~(CD|NW|TS|MP) */

        MOVL    $_startpg(SB), AX               /* this is a virtual address */
        MOVL    DX, CR0                         /* turn on paging */
        JMP*    AX                              /* jump to the virtual nirvana */

/*
 * Basic machine environment set, can clear BSS and create a stack.
 * The stack starts at the top of the page containing the Mach structure.
 * The x86 architecture forces the use of the same virtual address for
 * each processor's Mach structure, so the global Mach pointer 'm' can
 * be initialised here.
 */
TEXT _startpg(SB), $0
        MOVL    $0, (PDO(0))(CX)                /* undo double-map of KZERO at 0 */
        MOVL    CX, CR3                         /* load and flush the mmu */

_clearbss:
        MOVL    $edata(SB), DI
        XORL    AX, AX
        MOVL    $end(SB), CX
        SUBL    DI, CX                          /* end-edata bytes */
        SHRL    $2, CX                          /* end-edata doublewords */

        CLD
        REP;    STOSL                           /* clear BSS */

        MOVL    $MACHADDR, SP
        MOVL    SP, m(SB)                       /* initialise global Mach pointer */
        MOVL    $0, 0(SP)                       /* initialise m->machno */


        ADDL    $(MACHSIZE-4), SP               /* initialise stack */

/*
 * Need to do one final thing to ensure a clean machine environment,
 * clear the EFLAGS register, which can only be done once there is a stack.
 */
        MOVL    $0, AX
        PUSHL   AX
        POPFL

        CALL    main(SB)


        
//*****************************************************************************
// CPU registers accessor
//*****************************************************************************
               
/*
 * Read/write various system registers.
 * CR4 and the 'model specific registers' should only be read/written
 * after it has been determined the processor supports them
 */
TEXT lgdt(SB), $0                               /* GDTR - global descriptor table */
        MOVL    gdtptr+0(FP), AX
        MOVL    (AX), GDTR
        RET

TEXT lidt(SB), $0                               /* IDTR - interrupt descriptor table */
        MOVL    idtptr+0(FP), AX
        MOVL    (AX), IDTR
        RET

TEXT ltr(SB), $0                                /* TR - task register */
        MOVL    tptr+0(FP), AX
        MOVW    AX, TASK
        RET

TEXT getcr0(SB), $0                             /* CR0 - processor control */
        MOVL    CR0, AX
        RET

TEXT getcr2(SB), $0                             /* CR2 - page fault linear address */
        MOVL    CR2, AX
        RET

TEXT getcr3(SB), $0                             /* CR3 - page directory base */
        MOVL    CR3, AX
        RET

TEXT putcr0(SB), $0
        MOVL    cr0+0(FP), AX
        MOVL    AX, CR0
        RET

TEXT putcr3(SB), $0
        MOVL    cr3+0(FP), AX
        MOVL    AX, CR3
        RET

TEXT getcr4(SB), $0                             /* CR4 - extensions */
        MOVL    CR4, AX
        RET

TEXT putcr4(SB), $0
        MOVL    cr4+0(FP), AX
        MOVL    AX, CR4
        RET

@


\subsection*{[[init/386/l_fp.s]]}

<<l_fp.s>>=
/*
 * Some machine instructions not handled by 8[al].
 */
#define FXSAVE          BYTE $0x0f; BYTE $0xae; BYTE $0x00  /* SSE FP save */
#define FXRSTOR         BYTE $0x0f; BYTE $0xae; BYTE $0x08  /* SSE FP restore */

        
/*
 * Floating point.
 * Note: the encodings for the FCLEX, FINIT, FSAVE, FSTCW, FSENV and FSTSW
 * instructions do NOT have the WAIT prefix byte (i.e. they act like their
 * FNxxx variations) so WAIT instructions must be explicitly placed in the
 * code as necessary.
 */
#define FPOFF(l)                                                 ;\
        MOVL    CR0, AX                                          ;\
        ANDL    $0xC, AX                        /* EM, TS */     ;\
        CMPL    AX, $0x8                                         ;\
        JEQ     l                                                ;\
        WAIT                                                     ;\
l:                                                               ;\
        MOVL    CR0, AX                                          ;\
        ANDL    $~0x4, AX                       /* EM=0 */       ;\
        ORL     $0x28, AX                       /* NE=1, TS=1 */ ;\
        MOVL    AX, CR0

#define FPON                                                     ;\
        MOVL    CR0, AX                                          ;\
        ANDL    $~0xC, AX                       /* EM=0, TS=0 */ ;\
        MOVL    AX, CR0

TEXT fpon(SB), $0                               /* enable */
        FPON
        RET

TEXT fpoff(SB), $0                              /* disable */
        FPOFF(l1)
        RET

TEXT fpinit(SB), $0                             /* enable and init */
        FPON
        FINIT
        WAIT
        /* setfcr(FPPDBL|FPRNR|FPINVAL|FPZDIV|FPOVFL) */
        /* note that low 6 bits are masks, not enables, on this chip */
        PUSHW   $0x0232
        FLDCW   0(SP)
        POPW    AX
        WAIT
        RET

TEXT fpx87save(SB), $0                          /* save state and disable */
        MOVL    p+0(FP), AX
        FSAVE   0(AX)                           /* no WAIT */
        FPOFF(l2)
        RET

TEXT fpx87restore(SB), $0                       /* enable and restore state */
        FPON
        MOVL    p+0(FP), AX
        FRSTOR  0(AX)
        WAIT
        RET

//TEXT fpstatus(SB), $0                         /* get floating point status */
//      FSTSW   AX
//      RET

TEXT fpenv(SB), $0                              /* save state without waiting */
        MOVL    p+0(FP), AX
        FSTENV  0(AX)                           /* also masks FP exceptions */
        RET

TEXT fpclear(SB), $0                            /* clear pending exceptions */
        FPON
        FCLEX                                   /* no WAIT */
        FPOFF(l3)
        RET

TEXT fpssesave0(SB), $0                         /* save state and disable */
        MOVL    p+0(FP), AX
        FXSAVE                                  /* no WAIT */
        FPOFF(l4)
        RET

TEXT fpsserestore0(SB), $0                      /* enable and restore state */
        FPON
        MOVL    p+0(FP), AX
        FXRSTOR
        WAIT
        RET

        
@


\subsection*{[[init/386/l_misc.s]]}

<<l_misc.s>>=

/*
 * Some machine instructions not handled by 8[al].
 */
#define HLT             BYTE $0xF4
        
/*
 * Park a processor. Should never fall through a return from main to here,
 * should only be called by application processors when shutting down.
 */
TEXT idle(SB), $0
_idle:
        STI
        HLT
        JMP     _idle


        
/*
 * Attempt at power saving. -rsc
 */
TEXT halt(SB), $0
        CLI
        CMPL    nrdy(SB), $0
        JEQ     _nothingready
        STI
        RET

_nothingready:
        STI
        HLT
        RET





/*
 * Basic timing loop to determine CPU frequency.
 */
TEXT aamloop(SB), $0
        MOVL    count+0(FP), CX
_aamloop:
        AAM
        LOOP    _aamloop
        RET



//*****************************************************************************
// Misc
//*****************************************************************************

#define INVLPG  BYTE $0x0F; BYTE $0x01; BYTE $0x39      /* INVLPG (%ecx) */
TEXT invlpg(SB), $0
        /* 486+ only */
        MOVL    va+0(FP), CX
        INVLPG
        RET

#define WBINVD  BYTE $0x0F; BYTE $0x09
TEXT wbinvd(SB), $0
        WBINVD
        RET

#define RDTSC           BYTE $0x0F; BYTE $0x31  /* RDTSC, result in AX/DX (lo/hi) */
TEXT _cycles(SB), $0                            /* time stamp counter */
        RDTSC
        MOVL    vlong+0(FP), CX                 /* &vlong */
        MOVL    AX, 0(CX)                       /* lo */
        MOVL    DX, 4(CX)                       /* hi */
        RET

/*
 * stub for:
 * time stamp counter; low-order 32 bits of 64-bit cycle counter
 * Runs at fasthz/4 cycles per second (m->clkin>>3)
 */
TEXT lcycles(SB),1,$0
        RDTSC
        RET

#define RDMSR           BYTE $0x0F; BYTE $0x32  /* RDMSR, result in AX/DX (lo/hi) */
TEXT rdmsr(SB), $0                              /* model-specific register */
        MOVL    index+0(FP), CX
        RDMSR
        MOVL    vlong+4(FP), CX                 /* &vlong */
        MOVL    AX, 0(CX)                       /* lo */
        MOVL    DX, 4(CX)                       /* hi */
        RET

#define WRMSR           BYTE $0x0F; BYTE $0x30  /* WRMSR, argument in AX/DX (lo/hi) */
                
TEXT wrmsr(SB), $0
        MOVL    index+0(FP), CX
        MOVL    lo+4(FP), AX
        MOVL    hi+8(FP), DX
        WRMSR
        RET


#define CPUID           BYTE $0x0F; BYTE $0xA2  /* CPUID, argument in AX */
        
/*
 * Try to determine the CPU type which requires fiddling with EFLAGS.
 * If the Id bit can be toggled then the CPUID instruction can be used
 * to determine CPU identity and features. First have to check if it's
 * a 386 (Ac bit can't be set). If it's not a 386 and the Id bit can't be
 * toggled then it's an older 486 of some kind.
 *
 *      cpuid(fun, regs[4]);
 */
TEXT cpuid(SB), $0
        MOVL    $0x240000, AX
        PUSHL   AX
        POPFL                                   /* set Id|Ac */
        PUSHFL
        POPL    BX                              /* retrieve value */
        MOVL    $0, AX
        PUSHL   AX
        POPFL                                   /* clear Id|Ac, EFLAGS initialised */
        PUSHFL
        POPL    AX                              /* retrieve value */
        XORL    BX, AX
        TESTL   $0x040000, AX                   /* Ac */
        JZ      _cpu386                         /* can't set this bit on 386 */
        TESTL   $0x200000, AX                   /* Id */
        JZ      _cpu486                         /* can't toggle this bit on some 486 */
        /* load registers */
        MOVL    regs+4(FP), BP
        MOVL    fn+0(FP), AX                    /* cpuid function */
        MOVL    4(BP), BX
        MOVL    8(BP), CX                       /* typically an index */
        MOVL    12(BP), DX
        CPUID
        JMP     _cpuid
_cpu486:
        MOVL    $0x400, AX
        JMP     _maybezapax
_cpu386:
        MOVL    $0x300, AX
_maybezapax:
        CMPL    fn+0(FP), $1
        JE      _zaprest
        XORL    AX, AX
_zaprest:
        XORL    BX, BX
        XORL    CX, CX
        XORL    DX, DX
_cpuid:
        MOVL    regs+4(FP), BP
        MOVL    AX, 0(BP)
        MOVL    BX, 4(BP)
        MOVL    CX, 8(BP)
        MOVL    DX, 12(BP)
        RET




TEXT mb386(SB), $0
        POPL    AX                              /* return PC */
        PUSHFL
        PUSHL   CS
        PUSHL   AX
        IRETL

TEXT mb586(SB), $0
        XORL    AX, AX
        CPUID
        RET

TEXT sfence(SB), $0
        BYTE $0x0f
        BYTE $0xae
        BYTE $0xf8
        RET

TEXT lfence(SB), $0
        BYTE $0x0f
        BYTE $0xae
        BYTE $0xe8
        RET

TEXT mfence(SB), $0
        BYTE $0x0f
        BYTE $0xae
        BYTE $0xf0
        RET

//TEXT xchgw(SB), $0
//      MOVL    v+4(FP), AX
//      MOVL    p+0(FP), BX
//      XCHGW   AX, (BX)
//      RET

TEXT cmpswap486(SB), $0
        MOVL    addr+0(FP), BX
        MOVL    old+4(FP), AX
        MOVL    new+8(FP), CX
        LOCK
        BYTE $0x0F; BYTE $0xB1; BYTE $0x0B      /* CMPXCHGL CX, (BX) */
        JNZ didnt
        MOVL    $1, AX
        RET
didnt:
        XORL    AX,AX
        RET

TEXT mul64fract(SB), $0
/*
 * Multiply two 64-bit number s and keep the middle 64 bits from the 128-bit result
 * See ../port/tod.c for motivation.
 */
        MOVL    r+0(FP), CX
        XORL    BX, BX                          /* BX = 0 */

        MOVL    a+8(FP), AX
        MULL    b+16(FP)                        /* a1*b1 */
        MOVL    AX, 4(CX)                       /* r2 = lo(a1*b1) */

        MOVL    a+8(FP), AX
        MULL    b+12(FP)                        /* a1*b0 */
        MOVL    AX, 0(CX)                       /* r1 = lo(a1*b0) */
        ADDL    DX, 4(CX)                       /* r2 += hi(a1*b0) */

        MOVL    a+4(FP), AX
        MULL    b+16(FP)                        /* a0*b1 */
        ADDL    AX, 0(CX)                       /* r1 += lo(a0*b1) */
        ADCL    DX, 4(CX)                       /* r2 += hi(a0*b1) + carry */

        MOVL    a+4(FP), AX
        MULL    b+12(FP)                        /* a0*b0 */
        ADDL    DX, 0(CX)                       /* r1 += hi(a0*b0) */
        ADCL    BX, 4(CX)                       /* r2 += carry */
        RET
@


\subsection*{[[init/386/l_multiboot.s]]}

<<l_multiboot.s>>=
#include "mem.h"
        
TEXT _startKADDR(SB), $0

/*
 * Must be 4-byte aligned.
 */
TEXT _multibootheader(SB), $0
        LONG    $0x1BADB002                     /* magic */
        LONG    $0x00010003                     /* flags */
        LONG    $-(0x1BADB002 + 0x00010003)     /* checksum */
        
        LONG    $_multibootheader-KZERO(SB)     /* header_addr */
        LONG    $_startKADDR-KZERO(SB)          /* load_addr */
        LONG    $edata-KZERO(SB)                /* load_end_addr */
        LONG    $end-KZERO(SB)                  /* bss_end_addr */
        
//      !!!entry point specification!!!
        LONG    $_multibootentry-KZERO(SB)              /* entry_addr */
        
        LONG    $0                              /* mode_type */
        LONG    $0                              /* width */
        LONG    $0                              /* height */
        LONG    $0                              /* depth */

/* 
 * the kernel expects the data segment to be page-aligned
 * multiboot bootloaders put the data segment right behind text
 */
TEXT _multibootentry(SB), $0
        MOVL    $etext-KZERO(SB), SI
        MOVL    SI, DI
        ADDL    $0xfff, DI
        ANDL    $~0xfff, DI
        MOVL    $edata-KZERO(SB), CX
        SUBL    DI, CX
        ADDL    CX, SI
        ADDL    CX, DI
        STD
        REP; MOVSB
        CLD
        ADDL    $KZERO, BX
        MOVL    BX, multiboot-KZERO(SB)
//      !!! Jump to _startPADDR (not _startKADDR)!!!
        MOVL    $_startPADDR(SB), AX
        ANDL    $~KZERO, AX
        JMP*    AX

/* multiboot structure pointer */
TEXT multiboot(SB), $0
        LONG    $0
@


\subsection*{[[init/386/main.c]]}

<<main.c>>=
#include        "u.h"
#include        "../port/lib.h"
#include        "mem.h"
#include        "dat.h"
#include        "fns.h"


#include        "io.h"
#include        "ureg.h"

#include        "pool.h"

#include        "init.h"
#include        "reboot.h"

#include        "mp.h"

#include        <tos.h>

void bootargs(void*);

// part of a trick to remove some backward dependencies
int devcons_print(char*, ...);
int devcons_iprint(char*, ...);
void devcons_panic(char*, ...);
void devcons__assert(char*);
void trap_dumpstack(void);
void proc_dumpaproc(Proc *p);
void proc_error(char*);
void proc_nexterror(void);
int devcons_pprint(char*, ...);
void i8253_delay(int millisecs);
void i8253_microdelay(int microsecs);
Proc* proc_wakeup(Rendez*);
void proc_sched(void);
void proc_ready(Proc*);
void proc_sleep(Rendez*, int(*)(void*), void*);
void main_exit(int ispanic);
int  main_isaconfig(char *class, int ctlrno, ISAConf *isa);
void nop(void);
uvlong devarch_fastticks(uvlong *hz);
void devarch_hook_ioalloc();
void chan_cclose(Chan *c);
Proc* proc_proctab(int i);
void proc_tsleep(Rendez *r, int (*fn)(void*), void *arg, ulong ms);
int proc_postnote(Proc *p, int dolock, char *n, int flag);
int sysproc_return0(void*);
void proc_pexit(char *exitstr, int freemem);

// conf.c
extern  Dev*  conf_devtab[];
// ??
extern  char* conffile;
//extern  uchar initcode[]; in init.h

extern void (*i8237alloc)(void);

//*****************************************************************************
// Configuration
//*****************************************************************************
// See globals in portdat_globals.h

//*****************************************************************************
// Boot parameters (not used by pad)
//*****************************************************************************

/*
 * Where configuration info is left for the loaded programme.
 * This will turn into a structure as more is done by the boot loader
 * (e.g. why parse the .ini file twice?).
 * There are 3584 bytes available at CONFADDR.
 */
#define BOOTLINE        ((char*)CONFADDR)
#define BOOTLINELEN     64
#define BOOTARGS        ((char*)(CONFADDR+BOOTLINELEN))
#define BOOTARGSLEN     (4096-0x200-BOOTLINELEN)


enum {
        /* space for syscall args, return PC, top-of-stack struct */
        Ustkheadroom    = sizeof(Sargs) + sizeof(uintptr) + sizeof(Tos),
};

//char bootdisk[KNAMELEN];

// Global! set by bootargs()
uchar *sp;      /* user stack of init proc */

// who set this??
int delaylink;

//@Scheck: Assembly
extern ulong *multiboot;

static void
options(void)
{
        long i, n;
        char *cp, *line[MAXCONF], *p, *q;
        ulong *m, l;

        if(multiboot != nil){
                cp = BOOTARGS;
                *cp = 0;
                if((*multiboot & 8) != 0 && multiboot[5] > 0){
                        m = KADDR(multiboot[6]);
                        l = m[1] - m[0];
                        m = KADDR(m[0]);
                        if(l >= BOOTARGSLEN)
                                l = BOOTARGSLEN - 1;
                        memmove(cp, m, l);
                        cp[l] = 0;
                }
        }

        /*
         *  parse configuration args from dos file plan9.ini
         */
        cp = BOOTARGS;  /* where b.com leaves its config */
        cp[BOOTARGSLEN-1] = 0;

        /*
         * Strip out '\r', change '\t' -> ' '.
         */
        p = cp;
        for(q = cp; *q; q++){
                if(*q == '\r')
                        continue;
                if(*q == '\t')
                        *q = ' ';
                *p++ = *q;
        }
        *p = 0;

        n = getfields(cp, line, MAXCONF, 1, "\n");
        for(i = 0; i < n; i++){
                if(*line[i] == '#')
                        continue;
                cp = strchr(line[i], '=');
                if(cp == nil)
                        continue;
                *cp++ = '\0';
                confname[nconf] = line[i];
                confval[nconf] = cp;
                nconf++;
        }
}

static void
writeconf(void)
{
        char *p, *q;
        int n;

        p = getconfenv();

        if(waserror()) {
                free(p);
                nexterror();
        }

        /* convert to name=value\n format */
        for(q=p; *q; q++) {
                q += strlen(q);
                *q = '=';
                q += strlen(q);
                *q = '\n';
        }
        n = q - p + 1;
        if(n >= BOOTARGSLEN)
                error("kernel configuration too large");
        memset(BOOTLINE, 0, BOOTLINELEN);
        memmove(BOOTARGS, p, n);
        poperror();
        free(p);
}

//*****************************************************************************
// Mach init
//*****************************************************************************

void
machinit(void)
{
    int machno;
    ulong *pdb;
    Segdesc *gdt;

    machno = m->machno;
    pdb = m->pdb;
    gdt = m->gdt;
    memset(m, 0, sizeof(Mach));
    m->machno = machno;
    m->pdb = pdb;
    m->gdt = gdt;
    m->perf.period = 1;

    /*
     * For polled uart output at boot, need
     * a default delay constant. 100000 should
     * be enough for a while. Cpuidentify will
     * calculate the real value later.
     */
    m->loopconst = 100000;
}


void
mach0init(void)
{
        conf.nmach = 1;
        MACHP(0) = (Mach*)CPU0MACH;
        m->pdb = (ulong*)CPU0PDB;
        m->gdt = (Segdesc*)CPU0GDT;

        machinit();

        active.machs = 1;
        active.exiting = 0;
}

//*****************************************************************************
// Conf init
//*****************************************************************************

// precondition: meminit() have initialized Conf.mem
void
confinit(void)
{
        char *p;
        int i, userpcnt;
        ulong kpages;

        if(p = getconf("*kernelpercent"))
                userpcnt = 100 - strtol(p, 0, 0);
        else
                userpcnt = 0;

        conf.npage = 0;
        for(i=0; i<nelem(conf.mem); i++)
                conf.npage += conf.mem[i].npage;

        conf.nproc = 100 + ((conf.npage*BY2PG)/MB)*5;
        if(cpuserver)
                conf.nproc *= 3;
        if(conf.nproc > 2000)
                conf.nproc = 2000;
        conf.nimage = 200;
        conf.nswap = conf.nproc*80;
        conf.nswppo = 4096;

        if(cpuserver) {
                if(userpcnt < 10)
                        userpcnt = 70;
                kpages = conf.npage - (conf.npage*userpcnt)/100;

                /*
                 * Hack for the big boys. Only good while physmem < 4GB.
                 * Give the kernel fixed max + enough to allocate the
                 * page pool.
                 * This is an overestimate as conf.upages < conf.npages.
                 * The patch of nimage is a band-aid, scanning the whole
                 * page list in imagereclaim just takes too long.
                 */
                if(kpages > (128*MB + conf.npage*sizeof(Page))/BY2PG){
                        kpages = (128*MB + conf.npage*sizeof(Page))/BY2PG;
                        conf.nimage = 2000;
                        kpages += (conf.nproc*KSTACK)/BY2PG;
                }
        } else {
                if(userpcnt < 10) {
                        if(conf.npage*BY2PG < 16*MB)
                                userpcnt = 40;
                        else
                                userpcnt = 60;
                }
                kpages = conf.npage - (conf.npage*userpcnt)/100;

                /*
                 * Make sure terminals with low memory get at least
                 * 4MB on the first Image chunk allocation.
                 */
                if(conf.npage*BY2PG < 16*MB)
                        imagmem->minarena = 4*1024*1024;
        }

        /*
         * can't go past the end of virtual memory
         * (ulong)-KZERO is 2^32 - KZERO
         */
        if(kpages > ((ulong)-KZERO)/BY2PG)
                kpages = ((ulong)-KZERO)/BY2PG;

        conf.upages = conf.npage - kpages;
        conf.ialloc = (kpages/2)*BY2PG;

        /*
         * Guess how much is taken by the large permanent
         * datastructures. Mntcache and Mntrpc are not accounted for
         * (probably ~300KB).
         */
        kpages *= BY2PG;
        kpages -= conf.upages*sizeof(Page)
                + conf.nproc*sizeof(Proc)
                + conf.nimage*sizeof(KImage)
                + conf.nswap
                + conf.nswppo*sizeof(Page);
        mainmem->maxsize = kpages;
        if(!cpuserver){
                /*
                 * give terminals lots of image memory, too; the dynamic
                 * allocation will balance the load properly, hopefully.
                 * be careful with 32-bit overflow.
                 */
                imagmem->maxsize = kpages;
        }
}

//*****************************************************************************
// First process init
//*****************************************************************************

// set by userinit to sched.pc
void
init0(void)
{
        int i;
        char buf[2*KNAMELEN];
        
        up->nerrlab = 0;

        spllo();

        /*
         * These are o.k. because rootinit is null.
         * Then early kproc's will have a root and dot.
         */
        up->slash = namec("#/", Atodir, 0, 0);
        pathclose(up->slash->path);
        up->slash->path = newpath("/");
        up->dot = cclone(up->slash);

        chandevinit();

        if(!waserror()){
                snprint(buf, sizeof(buf), "%s %s", arch->id, conffile);
                ksetenv("terminal", buf, 0);
                ksetenv("cputype", "386", 0);
                if(cpuserver)
                        ksetenv("service", "cpu", 0);
                else
                        ksetenv("service", "terminal", 0);
                for(i = 0; i < nconf; i++){
                        if(confname[i][0] != '*')
                                ksetenv(confname[i], confval[i], 0);
                        ksetenv(confname[i], confval[i], 1);
                }
                poperror();
        }
        kproc("alarm", alarmkproc, 0);
        cgapost(0x9);
        touser(sp);
}


uchar *
pusharg(char *p)
{
        int n;

        n = strlen(p)+1;
        sp -= n;
        memmove(sp, p, n);
        return sp;
}

//TODO: get rid of as have simplified boot process, no plan9.ini
void
bootargs(void *base)
{
        int i, ac;
        uchar *av[32];
        uchar **lsp;
        char *cp = BOOTLINE;
        char buf[64];

        sp = (uchar*)base + BY2PG - Ustkheadroom;

        ac = 0;
        av[ac++] = pusharg("/386/9dos");

        /* when boot is changed to only use rc, this code can go away */
        cp[BOOTLINELEN-1] = 0;
        buf[0] = 0;
        if(strncmp(cp, "fd", 2) == 0){
                snprint(buf, sizeof buf, "local!#f/fd%lddisk",
                        strtol(cp+2, 0, 0));
                av[ac++] = pusharg(buf);
        } else if(strncmp(cp, "sd", 2) == 0){
                snprint(buf, sizeof buf, "local!#S/sd%c%c/fs", *(cp+2), *(cp+3));
                av[ac++] = pusharg(buf);
        } else if(strncmp(cp, "ether", 5) == 0)
                av[ac++] = pusharg("-n");

        /* 4 byte word align stack */
        sp = (uchar*)((ulong)sp & ~3);

        /* build argc, argv on stack */
        sp -= (ac+1)*sizeof(sp);
        lsp = (uchar**)sp;
        for(i = 0; i < ac; i++)
                *lsp++ = av[i] + ((USTKTOP - BY2PG) - (ulong)base);
        *lsp = 0;
        sp += (USTKTOP - BY2PG) - (ulong)base - sizeof(ulong);
}


void
userinit(void)
{
        void *v;
        Proc *p;
        Segment *s;
        Page *pg;

        p = newproc();
        p->pgrp = newpgrp();
        p->egrp = smalloc(sizeof(Egrp)); //todo: newegrp()
        p->egrp->ref = 1;
        p->fgrp = dupfgrp(nil);
        p->rgrp = newrgrp();
        p->procmode = 0640;

        kstrdup(&eve, "");
        kstrdup(&p->text, "*init*");
        kstrdup(&p->user, eve);

        p->fpstate = FPinit;
        fpoff();

        /*
         * Kernel Stack
         *
         * N.B. make sure there's enough space for syscall to check
         *      for valid args and 
         *      4 bytes for gotolabel's return PC
         */
        p->sched.pc = (ulong)init0;
        p->sched.sp = (ulong)p->kstack+KSTACK-(sizeof(Sargs)+BY2WD);

        /*
         * User Stack
         *
         * N.B. cannot call newpage() with clear=1, because pc kmap
         * requires up != nil.  use tmpmap instead.
         */
        s = newseg(SG_STACK, USTKTOP-USTKSIZE, USTKSIZE/BY2PG);
        p->seg[SSEG] = s;
        pg = newpage(0, 0, USTKTOP-BY2PG);
        v = tmpmap(pg);
        memset(v, 0, BY2PG);
        segpage(s, pg);

        bootargs(v);
        tmpunmap(v);

        /*
         * Text
         */
        s = newseg(SG_TEXT, UTZERO, 1);
        s->flushme++;
        p->seg[TSEG] = s;
        pg = newpage(0, 0, UTZERO);
        memset(pg->cachectl, PG_TXTFLUSH, sizeof(pg->cachectl));
        segpage(s, pg);
        v = tmpmap(pg);
        memset(v, 0, BY2PG);
        memmove(v, initcode, sizeof initcode);
        tmpunmap(v);

        ready(p);
}

//*****************************************************************************
// Math coprocessor
//*****************************************************************************

static char* mathmsg[] =
{
        nil,    /* handled below */
        "denormalized operand",
        "division by zero",
        "numeric overflow",
        "numeric underflow",
        "precision loss",
};

static void
mathstate(ulong *stsp, ulong *pcp, ulong *ctlp)
{
        ulong sts, fpc, ctl;
        ArchFPsave *f = &up->fpsave;

        if(fpsave == fpx87save){
                sts = f->status;
                fpc = f->pc;
                ctl = f->control;
        } else {
                sts = f->fsw;
                fpc = f->fpuip;
                ctl = f->fcw;
        }
        if(stsp)
                *stsp = sts;
        if(pcp)
                *pcp = fpc;
        if(ctlp)
                *ctlp = ctl;
}

static void
mathnote(void)
{
        int i;
        ulong status, pc;
        char *msg, note[ERRMAX];

        mathstate(&status, &pc, nil);

        /*
         * Some attention should probably be paid here to the
         * exception masks and error summary.
         */
        msg = "unknown exception";
        for(i = 1; i <= 5; i++){
                if(!((1<<i) & status))
                        continue;
                msg = mathmsg[i];
                break;
        }
        if(status & 0x01){
                if(status & 0x40){
                        if(status & 0x200)
                                msg = "stack overflow";
                        else
                                msg = "stack underflow";
                }else
                        msg = "invalid operation";
        }
        snprint(note, sizeof note, "sys: fp: %s fppc=%#lux status=%#lux",
                msg, pc, status);
        postnote(up, 1, note, NDebug);
}

/*
 *  math coprocessor error
 */
static void
matherror(Ureg *ur, void*)
{
        ulong status, pc;

        /*
         *  a write cycle to port 0xF0 clears the interrupt latch attached
         *  to the error# line from the 387
         */
        if(!(m->cpuiddx & Fpuonchip))
                outb(0xF0, 0xFF);

        /*
         *  save floating point state to check out error
         */
        fpenv(&up->fpsave);     /* result ignored, but masks fp exceptions */
        fpsave(&up->fpsave);            /* also turns fpu off */
        fpon();
        mathnote();

        if((ur->pc & 0xf0000000) == KZERO){
                mathstate(&status, &pc, nil);
                panic("fp: status %#lux fppc=%#lux pc=%#lux", status, pc, ur->pc);
        }
}

/*
 *  math coprocessor emulation fault
 */
static void
mathemu(Ureg *ureg, void*)
{
        ulong status, control;

        if(up->fpstate & FPillegal){
                /* someone did floating point in a note handler */
                postnote(up, 1, "sys: floating point in note handler", NDebug);
                return;
        }
        switch(up->fpstate){
        case FPinit:
                fpinit();
                up->fpstate = FPactive;
                break;
        case FPinactive:
                /*
                 * Before restoring the state, check for any pending
                 * exceptions, there's no way to restore the state without
                 * generating an unmasked exception.
                 * More attention should probably be paid here to the
                 * exception masks and error summary.
                 */
                mathstate(&status, nil, &control);
                if((status & ~control) & 0x07F){
                        mathnote();
                        break;
                }
                fprestore(&up->fpsave);
                up->fpstate = FPactive;
                break;
        case FPactive:
                panic("math emu pid %ld %s pc %#lux",
                        up->pid, up->text, ureg->pc);
                break;
        }
}

/*
 *  math coprocessor segment overrun
 */
static void
mathover(Ureg*, void*)
{
        pexit("math overrun", 0);
}


void
mathinit(void)
{
        trapenable(VectorCERR, matherror, 0, "matherror");
        if(X86FAMILY(m->cpuidax) == 3)
                intrenable(IrqIRQ13, matherror, 0, BUSUNKNOWN, "matherror");
        trapenable(VectorCNA, mathemu, 0, "mathemu");
        trapenable(VectorCSO, mathover, 0, "mathover");
}

//*****************************************************************************
// Shutdown/reboot
//*****************************************************************************

static void
shutdown(bool ispanic)
{
        int ms, once;

        lock(&active);
        if(ispanic)
                active.ispanic = ispanic;
        else if(m->machno == 0 && (active.machs & (1<<m->machno)) == 0)
                active.ispanic = 0;
        once = active.machs & (1<<m->machno);
        /*
         * setting exiting will make hzclock() on each processor call exit(0),
         * which calls shutdown(0) and arch->reset(), which on mp systems is
         * mpshutdown, which idles non-bootstrap cpus and returns on bootstrap
         * processors (to permit a reboot).  clearing our bit in machs avoids
         * calling exit(0) from hzclock() on this processor.
         */
        active.machs &= ~(1<<m->machno);
        active.exiting = 1;
        unlock(&active);

        if(once)
                iprint("cpu%d: exiting\n", m->machno);

        /* wait for any other processors to shutdown */
        spllo();
        for(ms = 5*1000; ms > 0; ms -= TK2MS(2)){
                delay(TK2MS(2));
                if(active.machs == 0 && consactive() == 0)
                        break;
        }

        if(active.ispanic){
                if(!cpuserver)
                        for(;;)
                                halt();
                if(getconf("*debug"))
                        delay(5*60*1000);
                else
                        delay(10000);
        }else
                delay(1000);
}

// exit()
void
main_exit(bool ispanic)
{
        shutdown(ispanic);
        arch->reset();
}


void
reboot(void *entry, void *code, ulong size)
{
        void (*f)(ulong, ulong, ulong);
        ulong *pdb;

        writeconf();

        /*
         * the boot processor is cpu0.  execute this function on it
         * so that the new kernel has the same cpu0.  this only matters
         * because the hardware has a notion of which processor was the
         * boot processor and we look at it at start up.
         */
        if (m->machno != 0) {
                procwired(up, 0);
                sched();
        }

        if(conf.nmach > 1) {
                /*
                 * the other cpus could be holding locks that will never get
                 * released (e.g., in the print path) if we put them into
                 * reset now, so force them to shutdown gracefully first.
                 */
                lock(&active);
                active.rebooting = 1;
                unlock(&active);
                shutdown(0);
                if(arch->resetothers)
                        arch->resetothers();
                delay(20);
        }

        /*
         * should be the only processor running now
         */
        active.machs = 0;
        if (m->machno != 0)
                print("on cpu%d (not 0)!\n", m->machno);

        print("shutting down...\n");
        delay(200);

        splhi();

        /* turn off buffered serial console */
        serialoq = nil;

        /* shutdown devices */
        chandevshutdown();
        arch->introff();

        /*
         * Modify the machine page table to directly map the low 4MB of memory
         * This allows the reboot code to turn off the page mapping
         */
        pdb = m->pdb;
        pdb[PDX(0)] = pdb[PDX(KZERO)];
        mmuflushtlb(PADDR(pdb));

        /* setup reboot trampoline function */
        f = (void*)REBOOTADDR;
        memmove(f, rebootcode, sizeof(rebootcode));

        print("rebooting...\n");

        /* off we go - never to return */
        coherence();
        (*f)(PADDR(entry), PADDR(code), size);
}


//*****************************************************************************
// Misc
//*****************************************************************************

// isaconfig()
int
main_isaconfig(char *class, int ctlrno, ISAConf *isa)
{
        char cc[32], *p;
        int i;

        snprint(cc, sizeof cc, "%s%d", class, ctlrno);
        p = getconf(cc);
        if(p == nil)
                return 0;

        isa->type = "";
        isa->nopt = tokenize(p, isa->opt, NISAOPT);
        for(i = 0; i < isa->nopt; i++){
                p = isa->opt[i];
                if(cistrncmp(p, "type=", 5) == 0)
                        isa->type = p + 5;
                else if(cistrncmp(p, "port=", 5) == 0)
                        isa->port = strtoul(p+5, &p, 0);
                else if(cistrncmp(p, "irq=", 4) == 0)
                        isa->irq = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "dma=", 4) == 0)
                        isa->dma = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "mem=", 4) == 0)
                        isa->mem = strtoul(p+4, &p, 0);
                else if(cistrncmp(p, "size=", 5) == 0)
                        isa->size = strtoul(p+5, &p, 0);
                else if(cistrncmp(p, "freq=", 5) == 0)
                        isa->freq = strtoul(p+5, &p, 0);
        }
        return 1;
}

//*****************************************************************************
// Main entry point!
//*****************************************************************************

//@Scheck: not dead, entry point :) jumped to by qemu (via elf header)
void
main(void)
{

  // initial assignment made to avoid circular dependencies in codegraph
  print = devcons_print;
  iprint = devcons_iprint;
  pprint = devcons_pprint;
  
  panic = devcons_panic;
  _assert = devcons__assert;
  
  error = proc_error;
  nexterror = proc_nexterror;
  
  dumpstack = trap_dumpstack;
  dumpaproc = proc_dumpaproc;
  
  devtab = conf_devtab;
  
  delay = i8253_delay;
  microdelay = i8253_microdelay;

  wakeup = proc_wakeup;
  sched = proc_sched;
  ready = proc_ready;
  sleep = proc_sleep;
  tsleep = proc_tsleep;

  exit = main_exit;
  isaconfig = main_isaconfig;
  
  /*
   * On a uniprocessor, you'd think that coherence could be nop,
   * but it can't.  We still need a barrier when using coherence() in
   * device drivers.
   *
   * On VMware, it's safe (and a huge win) to set this to nop.
   * Aux/vmware does this via the #P/archctl file.
   */
  coherence = nop;
  
  fastticks = devarch_fastticks;
  
  cclose = chan_cclose;

  proctab = proc_proctab;
  postnote = proc_postnote;
  return0 = sysproc_return0;
  pexit = proc_pexit;

  hook_ioalloc = devarch_hook_ioalloc;

  // end patch, back to original code

        cgapost(0);

        mach0init(); // calls machinit()

        options();

        ioinit();
        i8250console();
        quotefmtinstall();
        screeninit();
        // screeninit() done, we can print stuff!
        print("\nPlan 99999999999999\n");

        // the init0 means this is really early on (malloc is not available?!)
        trapinit0();
        mmuinit0();

        kbdinit();
        i8253init();

        cpuidentify();

        meminit();
        confinit();

        archinit();

        xinit();

        if(i8237alloc != nil)
                i8237alloc();

        trapinit();
        printinit();
        cpuidprint();
        mmuinit();

        fpsavealloc();
        if(arch->intrinit)      /* launches other processors on an mp */
                arch->intrinit();

        timersinit();
        mathinit();
        kbdenable();
        if(arch->clockenable)
                arch->clockenable();


        procinit0();
        initseg();
        if(delaylink) {
                bootlinks();
                pcimatch(0, 0, 0);
        } else
                links();
        conf.monitor = true;
        // initialize all devices
        chandevreset();
        cgapost(0xcd);

        pageinit();
        i8253link();
        swapinit();

        // let's craft our first process (that will then exec("boot/boot"))
        userinit();
        active.thunderbirdsarego = 1;

        cgapost(0x99);
        schedinit();
}
@


\subsection*{[[init/386/rebootcode.s]]}

<<rebootcode.s>>=
#include "mem.h"

/*
 * Turn off MMU, then memmove the new kernel to its correct location
 * in physical memory.  Then jump to the start of the kernel.
 */

TEXT    main(SB),$0
        MOVL    p1+0(FP), DI            /* destination */
        MOVL    DI, AX                  /* entry point */
        MOVL    p2+4(FP), SI            /* source */
        MOVL    n+8(FP), CX             /* byte count */

/*
 * disable paging
 */
        MOVL    CR0, DX
        ANDL    $~0x80000000, DX                /* ~(PG) */
        MOVL    DX, CR0
        MOVL    $0, DX
        MOVL    DX, CR3

/*
 * the source and destination may overlap.
 * determine whether to copy forward or backwards
 */
        CMPL    SI, DI
        JGT     _forward
        MOVL    SI, DX
        ADDL    CX, DX
        CMPL    DX, DI
        JGT     _back

_forward:
        CLD
        REP;    MOVSB
        JMP     _startkernel

_back:
        ADDL    CX, DI
        ADDL    CX, SI
        SUBL    $1, DI
        SUBL    $1, SI
        STD
        REP;    MOVSB
        JMP     _startkernel
/*
 * JMP to kernel entry point.  Note the true kernel entry point is
 * the virtual address KZERO|AX, but this must wait until
 * the MMU is enabled by the kernel in l.s
 */
_startkernel:
        ORL     AX, AX          /* NOP: avoid link bug */
        JMP*    AX
@


\subsection*{[[init/initcode.c]]}

<<initcode.c>>=
/*
 * IMPORTANT!  DO NOT ADD LIBRARY CALLS TO THIS FILE.
 * The entire text image must fit on one page
 * (and there's no data segment, so any read/write data must be on the stack).
 */

#include <u.h>
#include <libc.h>

char cons[] = "#c/cons";
char boot[] = "/boot/boot";
char dev[] = "/dev";
char c[] = "#c";
char e[] = "#e";
char ec[] = "#ec";
char s[] = "#s";
char srv[] = "/srv";
char env[] = "/env";

void
startboot(char *argv0, char **argv)
{
    char buf[200];  /* keep this fairly large to capture error details */

    /* in case boot is a shell script */
    open(cons, OREAD);
    open(cons, OWRITE);
    open(cons, OWRITE);
    bind(c, dev, MAFTER);
    bind(ec, env, MAFTER);
    bind(e, env, MCREATE|MAFTER);
    bind(s, srv, MREPL|MCREATE);

    USED(argv0);
    exec(boot, argv);

    rerrstr(buf, sizeof buf);
    buf[sizeof buf - 1] = '\0';
    _exits(buf);
}
@


\subsection*{[[init/portfns_init.h]]}

<<portfns_init.h>>=

//in init/386/main.c (but used in port)
void    reboot(void*, void*, ulong);

// rebootcmd.c
//void    readn(Chan *, void *, long);
void    rebootcmd(int, char**);

@


\subsection*{[[init/rebootcmd.c]]}

<<rebootcmd.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    <a.out.h>
//#include  "/sys/src/libmach/elf.h"
#include    <elf.h>

//@Scheck: used in params below, FP cg
struct Execvals {
  uvlong  entry;
  ulong textsize;
  ulong datasize;
};
//@Scheck: TODO: who sets this? it's used by rebootcmd but who sets it? qemu?
int (*parseboothdr)(Chan *, ulong, Execvals *);


enum {
    Ehdr32sz    = 52,
    Phdr32sz    = 32,
    Shdr32sz    = 40,

    Ehdr64sz    = 64,
    Phdr64sz    = 56,
    Shdr64sz    = 64,
};

static uchar elfident[] = {
    '\177', 'E', 'L', 'F',
};

void
readn(Chan *c, void *vp, long n)
{
    char *p = vp;
    long nn;

    while(n > 0) {
        nn = devtab[c->type]->read(c, p, n, c->offset);
        if(nn == 0)
            error(Eshort);
        c->offset += nn;
        p += nn;
        n -= nn;
    }
}

/* assume the elf header is in the byte order of this machine */
int
readelfhdr(Chan *c, ulong, Execvals *evp)
{
    Ehdr ehdr;
    Phdr phdrs[3];

    c->offset = 0;          /* back up */
    readn(c, &ehdr, sizeof ehdr);
    if(memcmp(&ehdr.ident[MAG0], elfident, sizeof elfident) != 0 ||
        ehdr.ident[CLASS] != ELFCLASS32)
        return -1;

    /* get textsize and datasize from Phdrs */
    readn(c, phdrs, sizeof phdrs);
    evp->entry = ehdr.elfentry;
    evp->textsize = phdrs[0].filesz;
    evp->datasize = phdrs[1].filesz;
    c->offset = ROUNDUP(Ehdr32sz + 3*Phdr32sz, 16); /* position for text */
    return 0;
}

static int
readelf64hdr(Chan *c, ulong, Execvals *evp)
{
    E64hdr ehdr;
    P64hdr phdrs[3];

    c->offset = 0;          /* back up */
    readn(c, &ehdr, sizeof ehdr);
    if(memcmp(&ehdr.ident[MAG0], elfident, sizeof elfident) != 0 ||
        ehdr.ident[CLASS] != ELFCLASS64)
        return -1;

    /* get textsize and datasize from Phdrs */
    readn(c, phdrs, sizeof phdrs);
    evp->entry = ehdr.elfentry;
    evp->textsize = phdrs[0].filesz;
    evp->datasize = phdrs[1].filesz;
    c->offset = ROUNDUP(Ehdr64sz + 3*Phdr64sz, 16); /* position for text */
    return 0;
}

static void
setbootcmd(int argc, char *argv[])
{
    char *buf, *p, *ep;
    int i;

    buf = malloc(1024);
    if(buf == nil)
        error(Enomem);
    p = buf;
    ep = buf + 1024;
    for(i=0; i<argc; i++)
        p = seprint(p, ep, "%q ", argv[i]);
    *p = 0;
    ksetenv("bootcmd", buf, 1);
    free(buf);
}

void
rebootcmd(int argc, char *argv[])
{
    Chan *c;
    Exec exec;
    Execvals ev;
    ulong magic, text, rtext, entry, data, size;
    uchar *p;

    if(argc == 0)
        exit(0);

    c = namec(argv[0], Aopen, OEXEC, 0);
    if(waserror()){
        cclose(c);
        nexterror();
    }

    readn(c, &exec, sizeof(Exec));
    magic = l2be(exec.magic);
    /*
     * AOUT_MAGIC is sometimes defined like this:
     * #define AOUT_MAGIC   V_MAGIC || magic==M_MAGIC
     * so we can only use it in a fairly stylized manner.
     */
    if(magic == AOUT_MAGIC) {
        entry = l2be(exec.entry);
        text = l2be(exec.text);
        data = l2be(exec.data);
    } else if(parseboothdr && (*parseboothdr)(c, magic, &ev) >= 0 ||
        readelfhdr(c, magic, &ev) >= 0 ||
        readelf64hdr(c, magic, &ev) >= 0){
        entry = ev.entry;
        text = ev.textsize;
        data = ev.datasize;
    } else {
        error(Ebadexec);
        return;             /* for the compiler */
    }

    /* round text out to page boundary */
    rtext = ROUNDUP(entry+text, BY2PG) - entry;
    size = rtext + data;
    p = malloc(size);
    if(p == nil)
        error(Enomem);

    if(waserror()){
        free(p);
        nexterror();
    }

    memset(p, 0, size);
    readn(c, p, text);
    readn(c, p + rtext, data);

    ksetenv("bootfile", argv[0], 1);
    setbootcmd(argc-1, argv+1);

    reboot((void*)entry, p, size);

    panic("return from reboot!");
}
@


\section{[[lib/]]}

\subsection*{[[lib/lib.h]]}

<<lib.h>>=
// This file mostly exports code from lib_core/libc/ (linked with the kernel).
// Those functions are also exported in include/libc.h but they prefered to
// not include it and instead to reexport here a subset specific to the kernel.

// There are also the poolxxx() functions exported in include/pool.h
// (also part of libc) that are used in memory/alloc.c.

// Some functions in libc are also "overriden" (via linker abuse):
//  - print.c overrides _fmtlock(), _fmtunlock() that were in libc/fmt/
//  - devcons.s overrides the sysfatal() that was in libc/9sys/

// pad specific, should be in u.h
typedef int bool;
typedef ushort bool_ushort;
typedef ulong bool_ulong;
enum _bool {
  false = 0,
  true = 1
};

/*
 * functions (mostly) linked in from libc.
 */

#define nelem(x)  (sizeof(x)/sizeof((x)[0]))
#define offsetof(s, m)  (ulong)(&(((s*)0)->m))
#define assert(x) if(x){}else _assert("x")

/*
 * mem routines
 */
extern  void* memccpy(void*, void*, int, ulong);
extern  void* memset(void*, int, ulong);
extern  int memcmp(void*, void*, ulong);
extern  void* memmove(void*, void*, ulong);
extern  void* memchr(void*, int, ulong);

/*
 * string routines
 */
extern  char* strchr(char*, int);
extern  char* strrchr(char*, int);
extern  int strcmp(char*, char*);
extern  char* strcpy(char*, char*);
extern  char* strecpy(char*, char*, char*);
extern  char* strncpy(char*, char*, long);
extern  int strncmp(char*, char*, long);
extern  long  strlen(char*);
extern  char* strstr(char*, char*);
extern  int atoi(char*);
extern  int fullrune(char*, int);
//unused: extern  char* strcat(char*, char*);
//unused: extern  char* strncat(char*, char*, long);

//redefined in the kernel
extern  int cistrcmp(char*, char*);
extern  int cistrncmp(char*, char*, int);

enum
{
  UTFmax    = 4,    /* maximum bytes per rune */
  Runeself  = 0x80,   /* rune and UTF sequences are the same (<) */
//unused: Runesync  = 0x80,   /* cannot represent part of a UTF sequence (<) */
//unused: Runeerror = 0xFFFD, /* decoding error in UTF */
//unused: Runemax   = 0x10FFFF, /* 24 bit rune */
//unused: Runemask  = 0x1FFFFF, /* bits used by runes (see grep) */
};

/*
 * rune routines
 */
extern  int runetochar(char*, Rune*);
extern  int chartorune(Rune*, char*);
extern  char* utfrune(char*, long);
extern  int utfnlen(char*, long);
//unused: extern  int utflen(char*);
//unused: extern  int runelen(long);

extern  int abs(int);

/*
 * print routines
 */
typedef struct Fmt  Fmt;
typedef int (*Fmts)(Fmt*);
struct Fmt{
  uchar runes;      /* output buffer is runes or chars? */
  void  *start;     /* of buffer */
  void  *to;      /* current place in the buffer */
  void  *stop;      /* end of the buffer; overwritten if flush fails */
  int (*flush)(Fmt *);  /* called when to == stop */
  void  *farg;      /* to make flush a closure */
  int nfmt;     /* num chars formatted so far */
  va_list args;     /* args passed to dofmt */
  int r;      /* % format Rune */
  int width;
  int prec;
  ulong flags;
};

// This used to be regular function, but to avoid backward deps in the kernel
// I made it into a pointer function (a bit ugly, and maybe unsafe)
extern  int (*print)(char*, ...);

extern  char* seprint(char*, char*, char*, ...);
extern  char* vseprint(char*, char*, char*, va_list);
extern  int snprint(char*, int, char*, ...);
extern  int sprint(char*, char*, ...);
//unused: extern  int vsnprint(char*, int, char*, va_list);

#pragma varargck  argpos  fmtprint  2
#pragma varargck  argpos  print   1
#pragma varargck  argpos  seprint   3
#pragma varargck  argpos  snprint   3
#pragma varargck  argpos  sprint    2

#pragma varargck  type  "lld" vlong
#pragma varargck  type  "llx" vlong
#pragma varargck  type  "lld" uvlong
#pragma varargck  type  "llx" uvlong
#pragma varargck  type  "ld"  long
#pragma varargck  type  "lx"  long
#pragma varargck  type  "ld"  ulong
#pragma varargck  type  "lx"  ulong
#pragma varargck  type  "d" int
#pragma varargck  type  "x" int
#pragma varargck  type  "c" int
#pragma varargck  type  "C" int
#pragma varargck  type  "d" uint
#pragma varargck  type  "x" uint
#pragma varargck  type  "c" uint
#pragma varargck  type  "C" uint
#pragma varargck  type  "s" char*
#pragma varargck  type  "q" char*
#pragma varargck  type  "S" Rune*
#pragma varargck  type  "%" void
#pragma varargck  type  "p" uintptr
#pragma varargck  type  "p" void*
#pragma varargck  flag  ','

extern  int fmtstrinit(Fmt*);
extern  int fmtinstall(int, int (*)(Fmt*));
extern  void  quotefmtinstall(void);
extern  int fmtprint(Fmt*, char*, ...);
extern  int fmtstrcpy(Fmt*, char*);
extern  char* fmtstrflush(Fmt*);

/*
 * one-of-a-kind
 */
extern  char* cleanname(char*);
extern  ulong getcallerpc(void*);

extern  long  strtol(char*, char**, int);
extern  ulong strtoul(char*, char**, int);
extern  vlong strtoll(char*, char**, int);
extern  uvlong  strtoull(char*, char**, int);

extern  int getfields(char*, char**, int, int, char*);
extern  int tokenize(char*, char**, int);
extern  void  qsort(void*, long, long, int (*)(void*, void*));
//unused: extern  int dec64(uchar*, int, char*, int);
//unused: extern  int encodefmt(Fmt*);


extern  char  etext[];
//@Scheck: Assembly, not dead used by 386/l.s
extern  char  edata[];
extern  char  end[];


/*
 * Syscall data structures
 */
enum mount {
  MREPL = 0x0000,  /* mount replaces object */
  MBEFORE = 0x0001,  /* mount goes before others in union directory */
  MAFTER = 0x0002,  /* mount goes after others in union directory */
  MCREATE = 0x0004,  /* permit creation in mounted directory */
  MCACHE = 0x0010,  /* cache some data */

  MORDER =  0x0003,  /* mask for bits defining order of mounting */
  MMASK = 0x0017,  /* all bits on */
};

enum open {
  OREAD = 0, /* open for read */
  OWRITE = 1, /* write */
  ORDWR = 2, /* read and write */
  OEXEC = 3, /* execute, == read but check execute permission */
  OTRUNC = 16,  /* or'ed in (except for exec), truncate file first */
  OCEXEC = 32,  /* or'ed in, close on exec */
  ORCLOSE = 64,  /* or'ed in, remove on close */
  OEXCL = 0x1000,  /* or'ed in, exclusive create */
};

enum note {
  NCONT = 0, /* continue after note */
  NDFLT = 1, /* terminate after note */
  NSAVE = 2, /* clear note but hold state */
  NRSTR = 3, /* restore saved state */
};



enum miscsize {  
  ERRMAX = 128, /* max length of error string */
  KNAMELEN = 28,  /* max length of name held in kernel */
};




/* bits in Qid.type */
enum qidtype {
  QTFILE = 0x00,    /* plain file */
  QTDIR = 0x80,    /* type bit for directories */
  QTMOUNT = 0x10,    /* type bit for mounted channel */

  QTAUTH = 0x08,    /* type bit for authentication file */
  QTAPPEND = 0x40,    /* type bit for append only files */
  QTEXCL = 0x20,    /* type bit for exclusive use files */
};

/* bits in Dir.mode */
enum dirmode {
  DMDIR = 0x80000000,  /* mode bit for directories */
  DMAPPEND = 0x40000000,  /* mode bit for append only files */
  DMEXCL = 0x20000000,  /* mode bit for exclusive use files */
  DMMOUNT = 0x10000000,  /* mode bit for mounted channel */

  DMREAD = 0x4,   /* mode bit for read permission */
  DMWRITE = 0x2,   /* mode bit for write permission */
  DMEXEC = 0x1,   /* mode bit for execute permission */
};

typedef struct Qid  Qid;
typedef struct Dir  Dir;
typedef struct OWaitmsg OWaitmsg;
typedef struct Waitmsg  Waitmsg;

struct Qid
{
  // note that this is not a string, but an int! it's kind of an inode?
  uvlong  path;
  // for cache invalidation
  ulong vers;
  // enum<qidtype>
  uchar type;
};

struct Dir {
  /* system-modified data */
  ushort  type; /* server type */
  uint  dev;  /* server subtype */

  /* file data */
  Qid qid;  /* unique id from server */
  // bitset<enum<dirmode>>
  ulong mode; /* permissions */
  ulong atime;  /* last read time */
  ulong mtime;  /* last write time */
  vlong length; /* file length: see <u.h> */
  char  *name;  /* last element of path */
  char  *uid; /* owner name */
  char  *gid; /* group name */
  char  *muid;  /* last modifier name */
};



struct Waitmsg
{
  int pid;    /* of loved one */
  ulong time[3];  /* of loved one and descendants */
  char  msg[ERRMAX];  /* actually variable-size in user mode */
};

// for byteorder agnostic marshalling?
struct OWaitmsg
{
  char  pid[12];  /* of loved one */
  char  time[3*12]; /* of loved one and descendants */
  char  msg[64];  /* compatibility BUG */
};

@


\section{[[memory/]]}

\subsection*{[[memory/386/dat_memory.h]]}

<<dat_memory.h>>=

// define things used in Proc, for mmu.c to work on
/*
 *  MMU stuff in proc
 */
#define NCOLOR 1
//@Scheck: not dead, unnamed substructure
struct ArchProcMMU
{
  Page* mmupdb;     /* page directory base */
  Page* mmufree;    /* unused page table pages */
  Page* mmuused;    /* used page table pages */

  Page* kmaptable;    /* page table used by kmap */
  uint  lastkmap;   /* last entry used by kmap */
  int nkmap;      /* number of current kmaps */
};

/*
 * KMap the structure doesn't exist, but the functions do.
 */
typedef struct KMap   KMap;
#define VA(k)   ((void*)(k))
@


\subsection*{[[memory/386/mem.h]]}

<<mem.h>>=
/*
 * Memory and machine-specific definitions.  Used in C and assembler.
 */

/*
 * Sizes
 */
#define BI2BY   8     /* bits per byte */
#define BI2WD   32      /* bits per word */
#define BY2WD   4     /* bytes per word */
#define BY2V    8     /* bytes per double word */
#define BY2PG   4096      /* bytes per page */
#define WD2PG   (BY2PG/BY2WD)   /* words per page */
#define BY2XPG    (4096*1024)   /* bytes per big page */
#define PGSHIFT   12      /* log(BY2PG) */
#define CACHELINESZ 32      /* pentium & later */
#define BLOCKALIGN  8
#define FPalign   16      /* required for FXSAVE */

/*
 * In 32-bit mode, the MAXMACH limit is 32 without
 * changing the way active.machs is defined and used
 * (unfortunately, it is also used in the port code).
 */
#define MAXMACH   32      /* max # cpus system can run */
#define KSTACK    4096      /* Size of kernel stack */

/*
 * Time
 */
#define HZ    (100)     /* clock frequency */
#define MS2HZ   (1000/HZ)   /* millisec per clock tick */
#define TK2SEC(t) ((t)/HZ)    /* ticks to seconds */

/*
 *  Address spaces
 */
#define KZERO   0xF0000000    /* base of kernel address space */
#define KTZERO    (KZERO+0x100000)  /* first address in kernel text - 9load sits below */
#define VPT   (KZERO-VPTSIZE)
#define VPTSIZE   BY2XPG
#define NVPT    (VPTSIZE/BY2WD)
#define KMAP    (VPT-KMAPSIZE)
#define KMAPSIZE  BY2XPG
#define VMAP    (KMAP-VMAPSIZE)
#define VMAPSIZE  (0x10000000-VPTSIZE-KMAPSIZE)
#define UZERO   0     /* base of user address space */
#define UTZERO    (UZERO+BY2PG)   /* first address in user text */
#define UTROUND(t)  ROUNDUP((t), BY2PG)
#define USTKTOP   (VMAP-BY2PG)    /* byte just beyond user stack */
#define USTKSIZE  (16*1024*1024)    /* size of user stack */
#define TSTKTOP   (USTKTOP-USTKSIZE)  /* end of new stack in sysexec */
#define TSTKSIZ   100     /* pages in new stack; limits exec args */

/*
 * Fundamental addresses - bottom 64kB saved for return to real mode
 */
#define CONFADDR  (KZERO+0x1200)    /* info passed from boot loader */
#define TMPADDR   (KZERO+0x2000)    /* used for temporary mappings */
#define APBOOTSTRAP (KZERO+0x3000)    /* AP bootstrap code */
#define RMUADDR   (KZERO+0x7C00)    /* real mode Ureg */
#define RMCODE    (KZERO+0x8000)    /* copy of first page of KTEXT */
#define RMBUF   (KZERO+0x9000)    /* buffer for user space - known to vga */
#define IDTADDR   (KZERO+0x10800)   /* idt */
#define REBOOTADDR  (0x11000)   /* reboot code - physical address */
#define CPU0PDB   (KZERO+0x12000)   /* bootstrap processor PDB */
#define CPU0PTE   (KZERO+0x13000)   /* bootstrap processor PTE's for 0-4MB */
#define CPU0GDT   (KZERO+0x14000)   /* bootstrap processor GDT */
#define MACHADDR  (KZERO+0x15000)   /* as seen by current processor */
#define CPU0MACH  (KZERO+0x16000)   /* Mach for bootstrap processor */
#define MACHSIZE  BY2PG
#define CPU0PTE1  (KZERO+0x17000)   /* bootstrap processor PTE's for 4MB-8MB */
#define CPU0END   (CPU0PTE1+BY2PG)
/*
 * N.B.  ramscan knows that CPU0END is the end of reserved data
 * N.B.  _startPADDR knows that CPU0PDB is the first reserved page
 * and that there are 6 of them.
 */

/*
 *  known x86 segments (in GDT) and their selectors
 */
#define NULLSEG 0 /* null segment */
#define KDSEG 1 /* kernel data/stack */
#define KESEG 2 /* kernel executable */ 
#define UDSEG 3 /* user data/stack */
#define UESEG 4 /* user executable */
#define TSSSEG  5 /* task segment */
#define APMCSEG   6 /* APM code segment */
#define APMCSEG16 7 /* APM 16-bit code segment */
#define APMDSEG   8 /* APM data segment */
#define KESEG16   9 /* kernel executable 16-bit */
#define NGDT    10  /* number of GDT entries required */
/* #define  APM40SEG  8 /* APM segment 0x40 */

#define SELGDT  (0<<2)  /* selector is in gdt */
#define SELLDT  (1<<2)  /* selector is in ldt */

#define SELECTOR(i, t, p) (((i)<<3) | (t) | (p))

#define NULLSEL SELECTOR(NULLSEG, SELGDT, 0)
#define KDSEL SELECTOR(KDSEG, SELGDT, 0)
#define KESEL SELECTOR(KESEG, SELGDT, 0)
#define UESEL SELECTOR(UESEG, SELGDT, 3)
#define UDSEL SELECTOR(UDSEG, SELGDT, 3)
#define TSSSEL  SELECTOR(TSSSEG, SELGDT, 0)
#define APMCSEL   SELECTOR(APMCSEG, SELGDT, 0)
#define APMCSEL16 SELECTOR(APMCSEG16, SELGDT, 0)
#define APMDSEL   SELECTOR(APMDSEG, SELGDT, 0)
/* #define  APM40SEL  SELECTOR(APM40SEG, SELGDT, 0) */

/*
 *  fields in segment descriptors
 */
#define SEGDATA (0x10<<8) /* data/stack segment */
#define SEGEXEC (0x18<<8) /* executable segment */
#define SEGTSS  (0x9<<8)  /* TSS segment */
#define SEGCG (0x0C<<8) /* call gate */
#define SEGIG (0x0E<<8) /* interrupt gate */
#define SEGTG (0x0F<<8) /* trap gate */
#define SEGTYPE (0x1F<<8)

#define SEGP  (1<<15)   /* segment present */
#define SEGPL(x) ((x)<<13)  /* priority level */
#define SEGB  (1<<22)   /* granularity 1==4k (for expand-down) */
#define SEGG  (1<<23)   /* granularity 1==4k (for other) */
#define SEGE  (1<<10)   /* expand down */
#define SEGW  (1<<9)    /* writable (for data/stack) */
#define SEGR  (1<<9)    /* readable (for code) */
#define SEGD  (1<<22)   /* default 1==32bit (for code) */

/*
 *  virtual MMU
 */
#define PTEMAPMEM (1024*1024) // 1MB
#define PTEPERTAB (PTEMAPMEM/BY2PG)
#define SEGMAPSIZE  1984
#define SSEGMAPSIZE 16 // small segmap
#define PPN(x)    ((x)&~(BY2PG-1))

/*
 *  physical MMU
 */
#define PTEVALID  (1<<0)
#define PTEWT   (1<<3)
#define PTEUNCACHED (1<<4)
#define PTEWRITE  (1<<1)
#define PTERONLY  (0<<1)
#define PTEKERNEL (0<<2)
#define PTEUSER   (1<<2)
#define PTESIZE   (1<<7)
#define PTEGLOBAL (1<<8)

/*
 * Macros for calculating offsets within the page directory base
 * and page tables. 
 */
#define PDX(va)   ((((ulong)(va))>>22) & 0x03FF)
#define PTX(va)   ((((ulong)(va))>>12) & 0x03FF)

#define getpgcolor(a) 0

@


\subsection*{[[memory/386/memory.c]]}

<<memory.c>>=
/*
 * Size memory and create the kernel page-tables on the fly while doing so.
 * Called from main(), this code should only be run by the bootstrap processor.
 *
 * MemMin is what the bootstrap code in l.s has already mapped;
 * MemMax is the limit of physical memory to scan.
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"

#define MEMDEBUG    0

enum {
    MemUPA      = 0,        /* unbacked physical address */
    MemRAM      = 1,        /* physical memory */
    MemUMB      = 2,        /* upper memory block (<16MB) */
    MemReserved = 3,
    NMemType    = 4,

    KB      = 1024,

    MemMin      = 8*MB,
    MemMax      = (3*1024+768)*MB,
};

typedef struct Map Map;
struct Map {
    ulong   size;
    ulong   addr;
};

typedef struct RMap RMap;
struct RMap {
    char*   name;
    Map*    map;
    Map*    mapend;

    Lock;
};

/* 
 * Memory allocation tracking.
 */
static Map mapupa[16];
static RMap rmapupa = {
    "unallocated unbacked physical memory",
    mapupa,
    &mapupa[nelem(mapupa)-1],
};

static Map mapram[16];
static RMap rmapram = {
    "physical memory",
    mapram,
    &mapram[nelem(mapram)-1],
};

static Map mapumb[64];
static RMap rmapumb = {
    "upper memory block",
    mapumb,
    &mapumb[nelem(mapumb)-1],
};

static Map mapumbrw[16];
static RMap rmapumbrw = {
    "UMB device memory",
    mapumbrw,
    &mapumbrw[nelem(mapumbrw)-1],
};

void
mapprint(RMap *rmap)
{
    Map *mp;

    print("%s\n", rmap->name);  
    for(mp = rmap->map; mp->size; mp++)
        print("\t%8.8luX %8.8luX (%lud)\n", mp->addr, mp->addr+mp->size, mp->size);
}


void
memdebug(void)
{
    ulong maxpa, maxpa1, maxpa2;

    maxpa = (nvramread(0x18)<<8)|nvramread(0x17);
    maxpa1 = (nvramread(0x31)<<8)|nvramread(0x30);
    maxpa2 = (nvramread(0x16)<<8)|nvramread(0x15);
    print("maxpa = %luX -> %luX, maxpa1 = %luX maxpa2 = %luX\n",
        maxpa, MB+maxpa*KB, maxpa1, maxpa2);

    mapprint(&rmapram);
    mapprint(&rmapumb);
    mapprint(&rmapumbrw);
    mapprint(&rmapupa);
}

void
mapfree(RMap* rmap, ulong addr, ulong size)
{
    Map *mp;
    ulong t;

    if(size <= 0)
        return;

    lock(rmap);
    for(mp = rmap->map; mp->addr <= addr && mp->size; mp++)
        ;

    if(mp > rmap->map && (mp-1)->addr+(mp-1)->size == addr){
        (mp-1)->size += size;
        if(addr+size == mp->addr){
            (mp-1)->size += mp->size;
            while(mp->size){
                mp++;
                (mp-1)->addr = mp->addr;
                (mp-1)->size = mp->size;
            }
        }
    }
    else{
        if(addr+size == mp->addr && mp->size){
            mp->addr -= size;
            mp->size += size;
        }
        else do{
            if(mp >= rmap->mapend){
                print("mapfree: %s: losing 0x%luX, %ld\n",
                    rmap->name, addr, size);
                break;
            }
            t = mp->addr;
            mp->addr = addr;
            addr = t;
            t = mp->size;
            mp->size = size;
            mp++;
        }while(size = t);
    }
    unlock(rmap);
}

ulong
mapalloc(RMap* rmap, ulong addr, int size, int align)
{
    Map *mp;
    ulong maddr, oaddr;

    lock(rmap);
    for(mp = rmap->map; mp->size; mp++){
        maddr = mp->addr;

        if(addr){
            /*
             * A specific address range has been given:
             *   if the current map entry is greater then
             *   the address is not in the map;
             *   if the current map entry does not overlap
             *   the beginning of the requested range then
             *   continue on to the next map entry;
             *   if the current map entry does not entirely
             *   contain the requested range then the range
             *   is not in the map.
             */
            if(maddr > addr)
                break;
            if(mp->size < addr - maddr) /* maddr+mp->size < addr, but no overflow */
                continue;
            if(addr - maddr > mp->size - size)  /* addr+size > maddr+mp->size, but no overflow */
                break;
            maddr = addr;
        }

        if(align > 0)
            maddr = ((maddr+align-1)/align)*align;
        if(mp->addr+mp->size-maddr < size)
            continue;

        oaddr = mp->addr;
        mp->addr = maddr+size;
        mp->size -= maddr-oaddr+size;
        if(mp->size == 0){
            do{
                mp++;
                (mp-1)->addr = mp->addr;
            }while((mp-1)->size = mp->size);
        }

        unlock(rmap);
        if(oaddr != maddr)
            mapfree(rmap, oaddr, maddr-oaddr);

        return maddr;
    }
    unlock(rmap);

    return 0;
}

/*
 * Allocate from the ram map directly to make page tables.
 * Called by mmuwalk during e820scan.
 */
void*
rampage(void)
{
    ulong m;
    
    m = mapalloc(&rmapram, 0, BY2PG, BY2PG);
    if(m == 0)
        return nil;
    return KADDR(m);
}

static void
umbexclude(void)
{
    int size;
    ulong addr;
    char *op, *p, *rptr;

    if((p = getconf("umbexclude")) == nil)
        return;

    while(p && *p != '\0' && *p != '\n'){
        op = p;
        addr = strtoul(p, &rptr, 0);
        if(rptr == nil || rptr == p || *rptr != '-'){
            print("umbexclude: invalid argument <%s>\n", op);
            break;
        }
        p = rptr+1;

        size = strtoul(p, &rptr, 0) - addr + 1;
        if(size <= 0){
            print("umbexclude: bad range <%s>\n", op);
            break;
        }
        if(rptr != nil && *rptr == ',')
            *rptr++ = '\0';
        p = rptr;

        mapalloc(&rmapumb, addr, size, 0);
    }
}

static void
umbscan(void)
{
    uchar o[2], *p;

    /*
     * Scan the Upper Memory Blocks (0xA0000->0xF0000) for pieces
     * which aren't used; they can be used later for devices which
     * want to allocate some virtual address space.
     * Check for two things:
     * 1) device BIOS ROM. This should start with a two-byte header
     *    of 0x55 0xAA, followed by a byte giving the size of the ROM
     *    in 512-byte chunks. These ROM's must start on a 2KB boundary.
     * 2) device memory. This is read-write.
     * There are some assumptions: there's VGA memory at 0xA0000 and
     * the VGA BIOS ROM is at 0xC0000. Also, if there's no ROM signature
     * at 0xE0000 then the whole 64KB up to 0xF0000 is theoretically up
     * for grabs; check anyway.
     */
    p = KADDR(0xD0000);
    while(p < (uchar*)KADDR(0xE0000)){
        /*
         * Check for the ROM signature, skip if valid.
         */
        if(p[0] == 0x55 && p[1] == 0xAA){
            p += p[2]*512;
            continue;
        }

        /*
         * Is it writeable? If yes, then stick it in
         * the UMB device memory map. A floating bus will
         * return 0xff, so add that to the map of the
         * UMB space available for allocation.
         * If it is neither of those, ignore it.
         */
        o[0] = p[0];
        p[0] = 0xCC;
        o[1] = p[2*KB-1];
        p[2*KB-1] = 0xCC;
        if(p[0] == 0xCC && p[2*KB-1] == 0xCC){
            p[0] = o[0];
            p[2*KB-1] = o[1];
            mapfree(&rmapumbrw, PADDR(p), 2*KB);
        }
        else if(p[0] == 0xFF && p[1] == 0xFF)
            mapfree(&rmapumb, PADDR(p), 2*KB);
        p += 2*KB;
    }

    p = KADDR(0xE0000);
    if(p[0] != 0x55 || p[1] != 0xAA){
        p[0] = 0xCC;
        p[64*KB-1] = 0xCC;
        if(p[0] != 0xCC && p[64*KB-1] != 0xCC)
            mapfree(&rmapumb, PADDR(p), 64*KB);
    }

    umbexclude();
}

static void*
sigscan(uchar* addr, int len, char* signature)
{
    int sl;
    uchar *e, *p;

    e = addr+len;
    sl = strlen(signature);
    for(p = addr; p+sl < e; p += 16)
        if(memcmp(p, signature, sl) == 0)
            return p;
    return nil;
}

void*
sigsearch(char* signature)
{
    uintptr p;
    uchar *bda;
    void *r;

    /*
     * Search for the data structure:
     * 1) within the first KiB of the Extended BIOS Data Area (EBDA), or
     * 2) within the last KiB of system base memory if the EBDA segment
     *    is undefined, or
     * 3) within the BIOS ROM address space between 0xf0000 and 0xfffff
     *    (but will actually check 0xe0000 to 0xfffff).
     */
    bda = BIOSSEG(0x40);
    if(memcmp(KADDR(0xfffd9), "EISA", 4) == 0){
        if((p = (bda[0x0f]<<8)|bda[0x0e]) != 0){
            if((r = sigscan(BIOSSEG(p), 1024, signature)) != nil)
                return r;
        }
    }

    if((p = ((bda[0x14]<<8)|bda[0x13])*1024) != 0){
        if((r = sigscan(KADDR(p-1024), 1024, signature)) != nil)
            return r;
    }
    /* hack for virtualbox: look in KiB below 0xa0000 */
    if((r = sigscan(KADDR(0xa0000-1024), 1024, signature)) != nil)
        return r;

    return sigscan(BIOSSEG(0xe000), 0x20000, signature);
}

static void
lowraminit(void)
{
    ulong n, pa, x;
    uchar *bda;

    /*
     * Initialise the memory bank information for conventional memory
     * (i.e. less than 640KB). The base is the first location after the
     * bootstrap processor MMU information and the limit is obtained from
     * the BIOS data area.
     */
    x = PADDR(CPU0END);
    bda = (uchar*)KADDR(0x400);
    n = ((bda[0x14]<<8)|bda[0x13])*KB-x;
    mapfree(&rmapram, x, n);
    memset(KADDR(x), 0, n);         /* keep us honest */

    x = PADDR(PGROUND((ulong)end));
    pa = MemMin;
    if(x > pa)
        panic("kernel too big");
    mapfree(&rmapram, x, pa-x);
    memset(KADDR(x), 0, pa-x);      /* keep us honest */
}

static void
ramscan(ulong maxmem)
{
    ulong *k0, kzero, map, maxkpa, maxpa, pa, *pte, *table, *va, vbase, x;
    int nvalid[NMemType];

    /*
     * The bootstrap code has has created a prototype page
     * table which maps the first MemMin of physical memory to KZERO.
     * The page directory is at m->pdb and the first page of
     * free memory is after the per-processor MMU information.
     */
    pa = MemMin;

    /*
     * Check if the extended memory size can be obtained from the CMOS.
     * If it's 0 then it's either not known or >= 64MB. Always check
     * at least 24MB in case there's a memory gap (up to 8MB) below 16MB;
     * in this case the memory from the gap is remapped to the top of
     * memory.
     * The value in CMOS is supposed to be the number of KB above 1MB.
     */
    if(maxmem == 0){
        x = (nvramread(0x18)<<8)|nvramread(0x17);
        if(x == 0 || x >= (63*KB))
            maxpa = MemMax;
        else
            maxpa = MB+x*KB;
        if(maxpa < 24*MB)
            maxpa = 24*MB;
    }else
        maxpa = maxmem;
    maxkpa = (u32int)-KZERO;    /* 2^32 - KZERO */

    /*
     * March up memory from MemMin to maxpa 1MB at a time,
     * mapping the first page and checking the page can
     * be written and read correctly. The page tables are created here
     * on the fly, allocating from low memory as necessary.
     */
    k0 = (ulong*)KADDR(0);
    kzero = *k0;
    map = 0;
    x = 0x12345678;
    memset(nvalid, 0, sizeof(nvalid));
    
    /*
     * Can't map memory to KADDR(pa) when we're walking because
     * can only use KADDR for relatively low addresses.
     * Instead, map each 4MB we scan to the virtual address range
     * MemMin->MemMin+4MB while we are scanning.
     */
    vbase = MemMin;
    while(pa < maxpa){
        /*
         * Map the page. Use mapalloc(&rmapram, ...) to make
         * the page table if necessary, it will be returned to the
         * pool later if it isn't needed.  Map in a fixed range (the second 4M)
         * because high physical addresses cannot be passed to KADDR.
         */
        va = (void*)(vbase + pa%(4*MB));
        table = &m->pdb[PDX(va)];
        if(pa%(4*MB) == 0){
            if(map == 0 && (map = mapalloc(&rmapram, 0, BY2PG, BY2PG)) == 0)
                break;
            memset(KADDR(map), 0, BY2PG);
            *table = map|PTEWRITE|PTEVALID;
            memset(nvalid, 0, sizeof(nvalid));
        }
        table = KADDR(PPN(*table));
        pte = &table[PTX(va)];

        *pte = pa|PTEWRITE|PTEUNCACHED|PTEVALID;
        mmuflushtlb(PADDR(m->pdb));
        /*
         * Write a pattern to the page and write a different
         * pattern to a possible mirror at KZERO. If the data
         * reads back correctly the chunk is some type of RAM (possibly
         * a linearly-mapped VGA framebuffer, for instance...) and
         * can be cleared and added to the memory pool. If not, the
         * chunk is marked uncached and added to the UMB pool if <16MB
         * or is marked invalid and added to the UPA pool.
         */
        *va = x;
        *k0 = ~x;
        if(*va == x){
            nvalid[MemRAM] += MB/BY2PG;
            mapfree(&rmapram, pa, MB);

            do{
                *pte++ = pa|PTEWRITE|PTEVALID;
                pa += BY2PG;
            }while(pa % MB);
            mmuflushtlb(PADDR(m->pdb));
            /* memset(va, 0, MB); so damn slow to memset all of memory */
        }
        else if(pa < 16*MB){
            nvalid[MemUMB] += MB/BY2PG;
            mapfree(&rmapumb, pa, MB);

            do{
                *pte++ = pa|PTEWRITE|PTEUNCACHED|PTEVALID;
                pa += BY2PG;
            }while(pa % MB);
        }
        else{
            nvalid[MemUPA] += MB/BY2PG;
            mapfree(&rmapupa, pa, MB);

            *pte = 0;
            pa += MB;
        }
        /*
         * Done with this 4MB chunk, review the options:
         * 1) not physical memory and >=16MB - invalidate the PDB entry;
         * 2) physical memory - use the 4MB page extension if possible;
         * 3) not physical memory and <16MB - use the 4MB page extension
         *    if possible;
         * 4) mixed or no 4MB page extension - commit the already
         *    initialised space for the page table.
         */
        if(pa%(4*MB) == 0 && pa >= 32*MB && nvalid[MemUPA] == (4*MB)/BY2PG){
            /*
             * If we encounter a 4MB chunk of missing memory
             * at a sufficiently high offset, call it the end of
             * memory.  Otherwise we run the risk of thinking
             * that video memory is real RAM.
             */
            break;
        }
        if(pa <= maxkpa && pa%(4*MB) == 0){
            table = &m->pdb[PDX(KADDR(pa - 4*MB))];
            if(nvalid[MemUPA] == (4*MB)/BY2PG)
                *table = 0;
            else if(nvalid[MemRAM] == (4*MB)/BY2PG && (m->cpuiddx & 0x08))
                *table = (pa - 4*MB)|PTESIZE|PTEWRITE|PTEVALID;
            else if(nvalid[MemUMB] == (4*MB)/BY2PG && (m->cpuiddx & 0x08))
                *table = (pa - 4*MB)|PTESIZE|PTEWRITE|PTEUNCACHED|PTEVALID;
            else{
                *table = map|PTEWRITE|PTEVALID;
                map = 0;
            }
        }
        mmuflushtlb(PADDR(m->pdb));
        x += 0x3141526;
    }
    /*
     * If we didn't reach the end of the 4MB chunk, that part won't
     * be mapped.  Commit the already initialised space for the page table.
     */
    if(pa % (4*MB) && pa <= maxkpa){
        m->pdb[PDX(KADDR(pa))] = map|PTEWRITE|PTEVALID;
        map = 0;
    }
    if(map)
        mapfree(&rmapram, map, BY2PG);

    m->pdb[PDX(vbase)] = 0;
    mmuflushtlb(PADDR(m->pdb));

    mapfree(&rmapupa, pa, (u32int)-pa);
    *k0 = kzero;
}

/*
 * BIOS Int 0x15 E820 memory map.
 */
enum
{
    SMAP = ('S'<<24)|('M'<<16)|('A'<<8)|'P',
    Ememory = 1,
    Ereserved = 2,
    Carry = 1,
};

typedef struct Emap Emap;
struct Emap
{
    uvlong base;
    uvlong len;
    ulong type;
};
static Emap emap[16];
int nemap;

static char *etypes[] =
{
    "type=0",
    "memory",
    "reserved",
    "acpi reclaim",
    "acpi nvs",
};

static int
emapcmp(const void *va, const void *vb)
{
    Emap *a, *b;
    
    a = (Emap*)va;
    b = (Emap*)vb;
    if(a->base < b->base)
        return -1;
    if(a->base > b->base)
        return 1;
    if(a->len < b->len)
        return -1;
    if(a->len > b->len)
        return 1;
    return a->type - b->type;
}

static void
map(ulong base, ulong len, int type)
{
    ulong e, n;
    ulong *table, flags, maxkpa;
    
    /*
     * Split any call crossing MemMin to make below simpler.
     */
    if(base < MemMin && len > MemMin-base){
        n = MemMin - base;
        map(base, n, type);
        map(MemMin, len-n, type);
    }
    
    /*
     * Let lowraminit and umbscan hash out the low MemMin.
     */
    if(base < MemMin)
        return;

    /*
     * Any non-memory below 16*MB is used as upper mem blocks.
     */
    if(type == MemUPA && base < 16*MB && base+len > 16*MB){
        map(base, 16*MB-base, MemUMB);
        map(16*MB, len-(16*MB-base), MemUPA);
        return;
    }
    
    /*
     * Memory below CPU0END is reserved for the kernel
     * and already mapped.
     */
    if(base < PADDR(CPU0END)){
        n = PADDR(CPU0END) - base;
        if(len <= n)
            return;
        map(PADDR(CPU0END), len-n, type);
        return;
    }
    
    /*
     * Memory between KTZERO and end is the kernel itself
     * and is already mapped.
     */
    if(base < PADDR(KTZERO) && base+len > PADDR(KTZERO)){
        map(base, PADDR(KTZERO)-base, type);
        return;
    }
    if(PADDR(KTZERO) < base && base < PADDR(PGROUND((ulong)end))){
        n = PADDR(PGROUND((ulong)end));
        if(len <= n)
            return;
        map(PADDR(PGROUND((ulong)end)), len-n, type);
        return;
    }
    
    /*
     * Now we have a simple case.
     */
    // print("map %.8lux %.8lux %d\n", base, base+len, type);
    switch(type){
    case MemRAM:
        mapfree(&rmapram, base, len);
        flags = PTEWRITE|PTEVALID;
        break;
    case MemUMB:
        mapfree(&rmapumb, base, len);
        flags = PTEWRITE|PTEUNCACHED|PTEVALID;
        break;
    case MemUPA:
        mapfree(&rmapupa, base, len);
        flags = 0;
        break;
    default:
    case MemReserved:
        flags = 0;
        break;
    }
    
    /*
     * bottom MemMin is already mapped - just twiddle flags.
     * (not currently used - see above)
     */
    if(base < MemMin){
        table = KADDR(PPN(m->pdb[PDX(base)]));
        e = base+len;
        base = PPN(base);
        for(; base<e; base+=BY2PG)
            table[PTX(base)] |= flags;
        return;
    }
    
    /*
     * Only map from KZERO to 2^32.
     */
    if(flags){
        maxkpa = -KZERO;
        if(base >= maxkpa)
            return;
        if(len > maxkpa-base)
            len = maxkpa - base;
        pdbmap(m->pdb, base|flags, base+KZERO, len);
    }
}

static int
e820scan(void)
{
    int i;
    Ureg u;
    ulong cont, base, len;
    uvlong last;
    Emap *e;

    if(getconf("*norealmode") || getconf("*noe820scan"))
        return -1;

    cont = 0;
    for(i=0; i<nelem(emap); i++){
        memset(&u, 0, sizeof u);
        u.ax = 0xE820;
        u.bx = cont;
        u.cx = 20;
        u.dx = SMAP;
        u.es = (PADDR(RMBUF)>>4)&0xF000;
        u.di = PADDR(RMBUF)&0xFFFF;
        u.trap = 0x15;
        realmode(&u);
        cont = u.bx;
        if((u.flags&Carry) || u.ax != SMAP || u.cx != 20)
            break;
        e = &emap[nemap++];
        *e = *(Emap*)RMBUF;
        if(u.bx == 0)
            break;
    }
    if(nemap == 0)
        return -1;
    
    qsort(emap, nemap, sizeof emap[0], emapcmp);

    if(getconf("*noe820print") == nil){
        for(i=0; i<nemap; i++){
            e = &emap[i];
            print("E820: %.8llux %.8llux ", e->base, e->base+e->len);
            if(e->type < nelem(etypes))
                print("%s\n", etypes[e->type]);
            else
                print("type=%lud\n", e->type);
        }
    }

    last = 0;
    for(i=0; i<nemap; i++){ 
        e = &emap[i];
        /*
         * pull out the info but only about the low 32 bits...
         */
        if(e->base >= (1LL<<32))
            break;
        base = e->base;
        if(base+e->len > (1LL<<32))
            len = -base;
        else
            len = e->len;
        /*
         * If the map skips addresses, mark them available.
         */
        if(last < e->base)
            map(last, e->base-last, MemUPA);
        last = base+len;
        if(e->type == Ememory)
            map(base, len, MemRAM);
        else
            map(base, len, MemReserved);
    }
    if(last < (1LL<<32))
        map(last, (u32int)-last, MemUPA);
    return 0;
}

void
meminit(void)
{
    int i;
    Map *mp;
    Confmem *cm;
    ulong pa, *pte;
    ulong maxmem, lost;
    char *p;

    if(p = getconf("*maxmem"))
        maxmem = strtoul(p, 0, 0);
    else
        maxmem = 0;

    /*
     * Set special attributes for memory between 640KB and 1MB:
     *   VGA memory is writethrough;
     *   BIOS ROM's/UMB's are uncached;
     * then scan for useful memory.
     */
    for(pa = 0xA0000; pa < 0xC0000; pa += BY2PG){
        pte = mmuwalk(m->pdb, (ulong)KADDR(pa), 2, 0);
        *pte |= PTEWT;
    }
    for(pa = 0xC0000; pa < 0x100000; pa += BY2PG){
        pte = mmuwalk(m->pdb, (ulong)KADDR(pa), 2, 0);
        *pte |= PTEUNCACHED;
    }
    mmuflushtlb(PADDR(m->pdb));

    umbscan();
    lowraminit();
    if(e820scan() < 0)
        ramscan(maxmem);

    /*
     * Set the conf entries describing banks of allocatable memory.
     */
    for(i=0; i<nelem(mapram) && i<nelem(conf.mem); i++){
        mp = &rmapram.map[i];
        cm = &conf.mem[i];
        cm->base = mp->addr;
        cm->npage = mp->size/BY2PG;
    }
    
    lost = 0;
    for(; i<nelem(mapram); i++)
        lost += rmapram.map[i].size;
    if(lost)
        print("meminit - lost %lud bytes\n", lost);

    if(MEMDEBUG)
        memdebug();
}

/*
 * Allocate memory from the upper memory blocks.
 */
ulong
umbmalloc(ulong addr, int size, int align)
{
    ulong a;

    if(a = mapalloc(&rmapumb, addr, size, align))
        return (ulong)KADDR(a);

    return 0;
}

void
umbfree(ulong addr, int size)
{
    mapfree(&rmapumb, PADDR(addr), size);
}

//ulong
//umbrwmalloc(ulong addr, int size, int align)
//{
//  ulong a;
//  uchar o[2], *p;
//
//  if(a = mapalloc(&rmapumbrw, addr, size, align))
//      return(ulong)KADDR(a);
//
//  /*
//   * Perhaps the memory wasn't visible before
//   * the interface is initialised, so try again.
//   */
//  if((a = umbmalloc(addr, size, align)) == 0)
//      return 0;
//  p = (uchar*)a;
//  o[0] = p[0];
//  p[0] = 0xCC;
//  o[1] = p[size-1];
//  p[size-1] = 0xCC;
//  if(p[0] == 0xCC && p[size-1] == 0xCC){
//      p[0] = o[0];
//      p[size-1] = o[1];
//      return a;
//  }
//  umbfree(a, size);
//
//  return 0;
//}

//void
//umbrwfree(ulong addr, int size)
//{
//  mapfree(&rmapumbrw, PADDR(addr), size);
//}

/*
 * Give out otherwise-unused physical address space
 * for use in configuring devices.  Note that unlike upamalloc
 * before it, upaalloc does not map the physical address
 * into virtual memory.  Call vmap to do that.
 */
ulong
upaalloc(int size, int align)
{
    ulong a;

    a = mapalloc(&rmapupa, 0, size, align);
    if(a == 0){
        print("out of physical address space allocating %d\n", size);
        mapprint(&rmapupa);
    }
    return a;
}

//void
//upafree(ulong pa, int size)
//{
//  mapfree(&rmapupa, pa, size);
//}

void
upareserve(ulong pa, int size)
{
    ulong a;
    
    a = mapalloc(&rmapupa, pa, size, 0);
    if(a != pa){
        /*
         * This can happen when we're using the E820
         * map, which might have already reserved some
         * of the regions claimed by the pci devices.
         */
    //  print("upareserve: cannot reserve pa=%#.8lux size=%d\n", pa, size);
        if(a != 0)
            mapfree(&rmapupa, a, size);
    }
}

//void
//memorysummary(void)
//{
//  memdebug();
//}

@


\subsection*{[[memory/386/mmu.c]]}

<<mmu.c>>=
/*
 * Memory mappings.  Life was easier when 2G of memory was enough.
 *
 * The kernel memory starts at KZERO, with the text loaded at KZERO+1M
 * (9load sits under 1M during the load).  The memory from KZERO to the
 * top of memory is mapped 1-1 with physical memory, starting at physical
 * address 0.  All kernel memory and data structures (i.e., the entries stored
 * into conf.mem) must sit in this physical range: if KZERO is at 0xF0000000,
 * then the kernel can only have 256MB of memory for itself.
 * 
 * The 256M below KZERO comprises three parts.  The lowest 4M is the
 * virtual page table, a virtual address representation of the current 
 * page table tree.  The second 4M is used for temporary per-process
 * mappings managed by kmap and kunmap.  The remaining 248M is used
 * for global (shared by all procs and all processors) device memory
 * mappings and managed by vmap and vunmap.  The total amount (256M)
 * could probably be reduced somewhat if desired.  The largest device
 * mapping is that of the video card, and even though modern video cards
 * have embarrassing amounts of memory, the video drivers only use one
 * frame buffer worth (at most 16M).  Each is described in more detail below.
 *
 * The VPT is a 4M frame constructed by inserting the pdb into itself.
 * This short-circuits one level of the page tables, with the result that 
 * the contents of second-level page tables can be accessed at VPT.  
 * We use the VPT to edit the page tables (see mmu) after inserting them
 * into the page directory.  It is a convenient mechanism for mapping what
 * might be otherwise-inaccessible pages.  The idea was borrowed from
 * the Exokernel.
 *
 * The VPT doesn't solve all our problems, because we still need to 
 * prepare page directories before we can install them.  For that, we
 * use tmpmap/tmpunmap, which map a single page at TMPADDR.
 */

#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "io.h"

/*
 * Simple segment descriptors with no translation.
 */
#define DATASEGM(p)     { 0xFFFF, SEGG|SEGB|(0xF<<16)|SEGP|SEGPL(p)|SEGDATA|SEGW }
#define EXECSEGM(p)     { 0xFFFF, SEGG|SEGD|(0xF<<16)|SEGP|SEGPL(p)|SEGEXEC|SEGR }
#define EXEC16SEGM(p)   { 0xFFFF, SEGG|(0xF<<16)|SEGP|SEGPL(p)|SEGEXEC|SEGR }
#define TSSSEGM(b,p)    { ((b)<<16)|sizeof(Tss),\
              ((b)&0xFF000000)|(((b)>>16)&0xFF)|SEGTSS|SEGPL(p)|SEGP }

Segdesc gdt[NGDT] =
{
[NULLSEG]   { 0, 0},        /* null descriptor */
[KDSEG]     DATASEGM(0),        /* kernel data/stack */
[KESEG]     EXECSEGM(0),        /* kernel code */
[UDSEG]     DATASEGM(3),        /* user data/stack */
[UESEG]     EXECSEGM(3),        /* user code */
[TSSSEG]    TSSSEGM(0,0),       /* tss segment */
[KESEG16]       EXEC16SEGM(0),  /* kernel code 16-bit */
};

static int didmmuinit;
static void taskswitch(ulong, ulong);
static void memglobal(void);

#define vpt ((ulong*)VPT)
#define VPTX(va)        (((ulong)(va))>>12)
#define vpd (vpt+VPTX(VPT))

void
mmuinit0(void)
{
    memmove(m->gdt, gdt, sizeof gdt);
}

void
mmuinit(void)
{
    ulong x, *p;
    ushort ptr[3];

    didmmuinit = 1;

    if(0) print("vpt=%#.8ux vpd=%#p kmap=%#.8ux\n",
        VPT, vpd, KMAP);

    memglobal();
    m->pdb[PDX(VPT)] = PADDR(m->pdb)|PTEWRITE|PTEVALID;
    
    m->tss = malloc(sizeof(Tss));
    if(m->tss == nil)
        panic("mmuinit: no memory");
    memset(m->tss, 0, sizeof(Tss));
    m->tss->iomap = 0xDFFF<<16;

    /*
     * We used to keep the GDT in the Mach structure, but it
     * turns out that that slows down access to the rest of the
     * page.  Since the Mach structure is accessed quite often,
     * it pays off anywhere from a factor of 1.25 to 2 on real
     * hardware to separate them (the AMDs are more sensitive
     * than Intels in this regard).  Under VMware it pays off
     * a factor of about 10 to 100.
     */
    memmove(m->gdt, gdt, sizeof gdt);
    x = (ulong)m->tss;
    m->gdt[TSSSEG].d0 = (x<<16)|sizeof(Tss);
    m->gdt[TSSSEG].d1 = (x&0xFF000000)|((x>>16)&0xFF)|SEGTSS|SEGPL(0)|SEGP;

    ptr[0] = sizeof(gdt)-1;
    x = (ulong)m->gdt;
    ptr[1] = x & 0xFFFF;
    ptr[2] = (x>>16) & 0xFFFF;
    lgdt(ptr);

    ptr[0] = sizeof(Segdesc)*256-1;
    x = IDTADDR;
    ptr[1] = x & 0xFFFF;
    ptr[2] = (x>>16) & 0xFFFF;
    lidt(ptr);

    /* make kernel text unwritable */
    for(x = KTZERO; x < (ulong)etext; x += BY2PG){
        p = mmuwalk(m->pdb, x, 2, 0);
        if(p == nil)
            panic("mmuinit");
        *p &= ~PTEWRITE;
    }

    taskswitch(PADDR(m->pdb),  (ulong)m + BY2PG);
    ltr(TSSSEL);
}

/* 
 * On processors that support it, we set the PTEGLOBAL bit in
 * page table and page directory entries that map kernel memory.
 * Doing this tells the processor not to bother flushing them
 * from the TLB when doing the TLB flush associated with a 
 * context switch (write to CR3).  Since kernel memory mappings
 * are never removed, this is safe.  (If we ever remove kernel memory
 * mappings, we can do a full flush by turning off the PGE bit in CR4,
 * writing to CR3, and then turning the PGE bit back on.) 
 *
 * See also mmukmap below.
 * 
 * Processor support for the PTEGLOBAL bit is enabled in devarch.c.
 */
static void
memglobal(void)
{
    int i, j;
    ulong *pde, *pte;

    /* only need to do this once, on bootstrap processor */
    if(m->machno != 0)
        return;

    if(!m->havepge)
        return;

    pde = m->pdb;
    for(i=PDX(KZERO); i<1024; i++){
        if(pde[i] & PTEVALID){
            pde[i] |= PTEGLOBAL;
            if(!(pde[i] & PTESIZE)){
                pte = KADDR(pde[i]&~(BY2PG-1));
                for(j=0; j<1024; j++)
                    if(pte[j] & PTEVALID)
                        pte[j] |= PTEGLOBAL;
            }
        }
    }           
}

/*
 * Flush all the user-space and device-mapping mmu info
 * for this process, because something has been deleted.
 * It will be paged back in on demand.
 */
void
flushmmu(void)
{
    int s;

    s = splhi();
    up->newtlb = 1;
    mmuswitch(up);
    splx(s);
}

/*
 * Flush a single page mapping from the tlb.
 */
void
flushpg(ulong va)
{
    if(X86FAMILY(m->cpuidax) >= 4)
        invlpg(va);
    else
        putcr3(getcr3());
}
    
/*
 * Allocate a new page for a page directory. 
 * We keep a small cache of pre-initialized
 * page directories in each mach.
 */
static Page*
mmupdballoc(void)
{
    int s;
    Page *page;
    ulong *pdb;

    s = splhi();
    m->pdballoc++;
    if(m->pdbpool == 0){
        spllo();
        page = newpage(0, 0, 0);
        page->va = (ulong)vpd;
        splhi();
        pdb = tmpmap(page);
        memmove(pdb, m->pdb, BY2PG);
        pdb[PDX(VPT)] = page->pa|PTEWRITE|PTEVALID; /* set up VPT */
        tmpunmap(pdb);
    }else{
        page = m->pdbpool;
        m->pdbpool = page->next;
        m->pdbcnt--;
    }
    splx(s);
    return page;
}

//@Scheck: not deaded, called below
static void
mmupdbfree(Proc *proc, Page *p)
{
    if(islo())
        panic("mmupdbfree: islo");
    m->pdbfree++;
    if(m->pdbcnt >= 10){
        p->next = proc->mmufree;
        proc->mmufree = p;
    }else{
        p->next = m->pdbpool;
        m->pdbpool = p;
        m->pdbcnt++;
    }
}

/*
 * A user-space memory segment has been deleted, or the
 * process is exiting.  Clear all the pde entries for user-space
 * memory mappings and device mappings.  Any entries that
 * are needed will be paged back in as necessary.
 */
static void
mmuptefree(Proc* proc)
{
    int s;
    ulong *pdb;
    Page **last, *page;

    if(proc->mmupdb == nil || proc->mmuused == nil)
        return;
    s = splhi();
    pdb = tmpmap(proc->mmupdb);
    last = &proc->mmuused;
    for(page = *last; page; page = page->next){
        pdb[page->daddr] = 0;
        last = &page->next;
    }
    tmpunmap(pdb);
    splx(s);
    *last = proc->mmufree;
    proc->mmufree = proc->mmuused;
    proc->mmuused = 0;
}

static void
taskswitch(ulong pdb, ulong stack)
{
    Tss *tss;

    tss = m->tss;
    tss->ss0 = KDSEL;
    tss->esp0 = stack;
    tss->ss1 = KDSEL;
    tss->esp1 = stack;
    tss->ss2 = KDSEL;
    tss->esp2 = stack;
    putcr3(pdb);
}

void
mmuswitch(Proc* proc)
{
    ulong *pdb;

    if(proc->newtlb){
        mmuptefree(proc);
        proc->newtlb = 0;
    }

    if(proc->mmupdb){
        pdb = tmpmap(proc->mmupdb);
        pdb[PDX(MACHADDR)] = m->pdb[PDX(MACHADDR)];
        tmpunmap(pdb);
        taskswitch(proc->mmupdb->pa, (ulong)(proc->kstack+KSTACK));
    }else
        taskswitch(PADDR(m->pdb), (ulong)(proc->kstack+KSTACK));
}

/*
 * Release any pages allocated for a page directory base or page-tables
 * for this process:
 *   switch to the prototype pdb for this processor (m->pdb);
 *   call mmuptefree() to place all pages used for page-tables (proc->mmuused)
 *   onto the process' free list (proc->mmufree). This has the side-effect of
 *   cleaning any user entries in the pdb (proc->mmupdb);
 *   if there's a pdb put it in the cache of pre-initialised pdb's
 *   for this processor (m->pdbpool) or on the process' free list;
 *   finally, place any pages freed back into the free pool (palloc).
 * This routine is only called from schedinit() with palloc locked.
 */
void
mmurelease(Proc* proc)
{
    Page *page, *next;
    ulong *pdb;

    if(islo())
        panic("mmurelease: islo");
    taskswitch(PADDR(m->pdb), (ulong)m + BY2PG);
    if(proc->kmaptable){
        if(proc->mmupdb == nil)
            panic("mmurelease: no mmupdb");
        if(--proc->kmaptable->ref)
            panic("mmurelease: kmap ref %d", proc->kmaptable->ref);
        if(proc->nkmap)
            panic("mmurelease: nkmap %d", proc->nkmap);
        /*
         * remove kmaptable from pdb before putting pdb up for reuse.
         */
        pdb = tmpmap(proc->mmupdb);
        if(PPN(pdb[PDX(KMAP)]) != proc->kmaptable->pa)
            panic("mmurelease: bad kmap pde %#.8lux kmap %#.8lux",
                pdb[PDX(KMAP)], proc->kmaptable->pa);
        pdb[PDX(KMAP)] = 0;
        tmpunmap(pdb);
        /*
         * move kmaptable to free list.
         */
        pagechainhead(proc->kmaptable);
        proc->kmaptable = 0;
    }
    if(proc->mmupdb){
        mmuptefree(proc);
        mmupdbfree(proc, proc->mmupdb);
        proc->mmupdb = 0;
    }
    for(page = proc->mmufree; page; page = next){
        next = page->next;
        if(--page->ref)
            panic("mmurelease: page->ref %d", page->ref);
        pagechainhead(page);
    }
    if(proc->mmufree && palloc.r.p)
        wakeup(&palloc.r);
    proc->mmufree = 0;
}

/*
 * Allocate and install pdb for the current process.
 */
//@Scheck: no dead, called bellow
static void
upallocpdb(void)
{
    int s;
    ulong *pdb;
    Page *page;
    
    if(up->mmupdb != nil)
        return;
    page = mmupdballoc();
    s = splhi();
    if(up->mmupdb != nil){
        /*
         * Perhaps we got an interrupt while
         * mmupdballoc was sleeping and that
         * interrupt allocated an mmupdb?
         * Seems unlikely.
         */
        mmupdbfree(up, page);
        splx(s);
        return;
    }
    pdb = tmpmap(page);
    pdb[PDX(MACHADDR)] = m->pdb[PDX(MACHADDR)];
    tmpunmap(pdb);
    up->mmupdb = page;
    putcr3(up->mmupdb->pa);
    splx(s);
}

/*
 * Update the mmu in response to a user fault.  pa may have PTEWRITE set.
 */
void
putmmu(ulong va, ulong pa, Page*)
{
    int old, s;
    Page *page;

    if(up->mmupdb == nil)
        upallocpdb();

    /*
     * We should be able to get through this with interrupts
     * turned on (if we get interrupted we'll just pick up 
     * where we left off) but we get many faults accessing
     * vpt[] near the end of this function, and they always happen
     * after the process has been switched out and then 
     * switched back, usually many times in a row (perhaps
     * it cannot switch back successfully for some reason).
     * 
     * In any event, I'm tired of searching for this bug.  
     * Turn off interrupts during putmmu even though
     * we shouldn't need to.        - rsc
     */
    
    s = splhi();
    if(!(vpd[PDX(va)]&PTEVALID)){
        if(up->mmufree == 0){
            spllo();
            page = newpage(0, 0, 0);
            splhi();
        }
        else{
            page = up->mmufree;
            up->mmufree = page->next;
        }
        vpd[PDX(va)] = PPN(page->pa)|PTEUSER|PTEWRITE|PTEVALID;
        /* page is now mapped into the VPT - clear it */
        memset((void*)(VPT+PDX(va)*BY2PG), 0, BY2PG);
        page->daddr = PDX(va);
        page->next = up->mmuused;
        up->mmuused = page;
    }
    old = vpt[VPTX(va)];
    vpt[VPTX(va)] = pa|PTEUSER|PTEVALID;
    if(old&PTEVALID)
        flushpg(va);
    if(getcr3() != up->mmupdb->pa)
        print("bad cr3 %#.8lux %#.8lux\n", getcr3(), up->mmupdb->pa);
    splx(s);
}

/*
 * Double-check the user MMU.
 * Error checking only.
 */
void
checkmmu(ulong va, ulong pa)
{
    if(up->mmupdb == 0)
        return;
    if(!(vpd[PDX(va)]&PTEVALID) || !(vpt[VPTX(va)]&PTEVALID))
        return;
    if(PPN(vpt[VPTX(va)]) != pa)
        print("%ld %s: va=%#08lux pa=%#08lux pte=%#08lux\n",
            up->pid, up->text,
            va, pa, vpt[VPTX(va)]);
}

/*
 * Walk the page-table pointed to by pdb and return a pointer
 * to the entry for virtual address va at the requested level.
 * If the entry is invalid and create isn't requested then bail
 * out early. Otherwise, for the 2nd level walk, allocate a new
 * page-table page and register it in the 1st level.  This is used
 * only to edit kernel mappings, which use pages from kernel memory,
 * so it's okay to use KADDR to look at the tables.
 */
ulong*
mmuwalk(ulong* pdb, ulong va, int level, int create)
{
    ulong *table;
    void *map;

    table = &pdb[PDX(va)];
    if(!(*table & PTEVALID) && create == 0)
        return 0;

    switch(level){

    default:
        return 0;

    case 1:
        return table;

    case 2:
        if(*table & PTESIZE)
            panic("mmuwalk2: va %luX entry %luX", va, *table);
        if(!(*table & PTEVALID)){
            /*
             * Have to call low-level allocator from
             * memory.c if we haven't set up the xalloc
             * tables yet.
             */
            if(didmmuinit)
                map = xspanalloc(BY2PG, BY2PG, 0);
            else
                map = rampage();
            if(map == nil)
                panic("mmuwalk xspanalloc failed");
            *table = PADDR(map)|PTEWRITE|PTEVALID;
        }
        table = KADDR(PPN(*table));
        return &table[PTX(va)];
    }
}

/*
 * Device mappings are shared by all procs and processors and
 * live in the virtual range VMAP to VMAP+VMAPSIZE.  The master
 * copy of the mappings is stored in mach0->pdb, and they are
 * paged in from there as necessary by vmapsync during faults.
 */

static Lock vmaplock;

static int findhole(ulong *a, int n, int count);
static ulong vmapalloc(ulong size);
static void pdbunmap(ulong*, ulong, int);

/*
 * Add a device mapping to the vmap range.
 */
void*
vmap(ulong pa, int size)
{
    int osize;
    ulong o, va;
    
    /*
     * might be asking for less than a page.
     */
    osize = size;
    o = pa & (BY2PG-1);
    pa -= o;
    size += o;

    size = ROUND(size, BY2PG);
    if(pa == 0){
        print("vmap pa=0 pc=%#p\n", getcallerpc(&pa));
        return nil;
    }
    ilock(&vmaplock);
    if((va = vmapalloc(size)) == 0 
    || pdbmap(MACHP(0)->pdb, pa|PTEUNCACHED|PTEWRITE, va, size) < 0){
        iunlock(&vmaplock);
        return 0;
    }
    iunlock(&vmaplock);
    /* avoid trap on local processor
    for(i=0; i<size; i+=4*MB)
        vmapsync(va+i);
    */
    USED(osize);
//  print("  vmap %#.8lux %d => %#.8lux\n", pa+o, osize, va+o);
    return (void*)(va + o);
}

static int
findhole(ulong *a, int n, int count)
{
    int have, i;
    
    have = 0;
    for(i=0; i<n; i++){
        if(a[i] == 0)
            have++;
        else
            have = 0;
        if(have >= count)
            return i+1 - have;
    }
    return -1;
}

/*
 * Look for free space in the vmap.
 */
static ulong
vmapalloc(ulong size)
{
    int i, n, o;
    ulong *vpdb;
    int vpdbsize;
    
    vpdb = &MACHP(0)->pdb[PDX(VMAP)];
    vpdbsize = VMAPSIZE/(4*MB);

    if(size >= 4*MB){
        n = (size+4*MB-1) / (4*MB);
        if((o = findhole(vpdb, vpdbsize, n)) != -1)
            return VMAP + o*4*MB;
        return 0;
    }
    n = (size+BY2PG-1) / BY2PG;
    for(i=0; i<vpdbsize; i++)
        if((vpdb[i]&PTEVALID) && !(vpdb[i]&PTESIZE))
            if((o = findhole(KADDR(PPN(vpdb[i])), WD2PG, n)) != -1)
                return VMAP + i*4*MB + o*BY2PG;
    if((o = findhole(vpdb, vpdbsize, 1)) != -1)
        return VMAP + o*4*MB;
        
    /*
     * could span page directory entries, but not worth the trouble.
     * not going to be very much contention.
     */
    return 0;
}

/*
 * Remove a device mapping from the vmap range.
 * Since pdbunmap does not remove page tables, just entries,
 * the call need not be interlocked with vmap.
 */
void
vunmap(void *v, int size)
{
    int i;
    ulong va, o;
    Mach *nm;
    Proc *p;
    
    /*
     * might not be aligned
     */
    va = (ulong)v;
    o = va&(BY2PG-1);
    va -= o;
    size += o;
    size = ROUND(size, BY2PG);
    
    if(size < 0 || va < VMAP || va+size > VMAP+VMAPSIZE)
        panic("vunmap va=%#.8lux size=%#x pc=%#.8lux",
            va, size, getcallerpc(&v));

    pdbunmap(MACHP(0)->pdb, va, size);
    
    /*
     * Flush mapping from all the tlbs and copied pdbs.
     * This can be (and is) slow, since it is called only rarely.
     * It is possible for vunmap to be called with up == nil,
     * e.g. from the reset/init driver routines during system
     * boot. In that case it suffices to flush the MACH(0) TLB
     * and return.
     */
    if(!active.thunderbirdsarego){
        putcr3(PADDR(MACHP(0)->pdb));
        return;
    }
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        if(p->state == Dead)
            continue;
        if(p != up)
            p->newtlb = 1;
    }
    for(i=0; i<conf.nmach; i++){
        nm = MACHP(i);
        if(nm != m)
            nm->flushmmu = 1;
    }
    flushmmu();
    for(i=0; i<conf.nmach; i++){
        nm = MACHP(i);
        if(nm != m)
            while((active.machs&(1<<nm->machno)) && nm->flushmmu)
                ;
    }
}

/*
 * Add kernel mappings for pa -> va for a section of size bytes.
 */
int
pdbmap(ulong *pdb, ulong pa, ulong va, int size)
{
    int pse;
    ulong pgsz, *pte, *table;
    ulong flag, off;
    
    flag = pa&0xFFF;
    pa &= ~0xFFF;

    if((MACHP(0)->cpuiddx & Pse) && (getcr4() & 0x10))
        pse = 1;
    else
        pse = 0;

    for(off=0; off<size; off+=pgsz){
        table = &pdb[PDX(va+off)];
        if((*table&PTEVALID) && (*table&PTESIZE))
            panic("vmap: va=%#.8lux pa=%#.8lux pde=%#.8lux",
                va+off, pa+off, *table);

        /*
         * Check if it can be mapped using a 4MB page:
         * va, pa aligned and size >= 4MB and processor can do it.
         */
        if(pse && (pa+off)%(4*MB) == 0 && (va+off)%(4*MB) == 0 && (size-off) >= 4*MB){
            *table = (pa+off)|flag|PTESIZE|PTEVALID;
            pgsz = 4*MB;
        }else{
            pte = mmuwalk(pdb, va+off, 2, 1);
            if(*pte&PTEVALID)
                panic("vmap: va=%#.8lux pa=%#.8lux pte=%#.8lux",
                    va+off, pa+off, *pte);
            *pte = (pa+off)|flag|PTEVALID;
            pgsz = BY2PG;
        }
    }
    return 0;
}

/*
 * Remove mappings.  Must already exist, for sanity.
 * Only used for kernel mappings, so okay to use KADDR.
 */
static void
pdbunmap(ulong *pdb, ulong va, int size)
{
    ulong vae;
    ulong *table;
    
    vae = va+size;
    while(va < vae){
        table = &pdb[PDX(va)];
        if(!(*table & PTEVALID)){
            panic("vunmap: not mapped");
            /* 
            va = (va+4*MB-1) & ~(4*MB-1);
            continue;
            */
        }
        if(*table & PTESIZE){
            *table = 0;
            va = (va+4*MB-1) & ~(4*MB-1);
            continue;
        }
        table = KADDR(PPN(*table));
        if(!(table[PTX(va)] & PTEVALID))
            panic("vunmap: not mapped");
        table[PTX(va)] = 0;
        va += BY2PG;
    }
}

/*
 * Handle a fault by bringing vmap up to date.
 * Only copy pdb entries and they never go away,
 * so no locking needed.
 */
int
vmapsync(ulong va)
{
    ulong entry, *table;

    if(va < VMAP || va >= VMAP+VMAPSIZE)
        return 0;

    entry = MACHP(0)->pdb[PDX(va)];
    if(!(entry&PTEVALID))
        return 0;
    if(!(entry&PTESIZE)){
        /* make sure entry will help the fault */
        table = KADDR(PPN(entry));
        if(!(table[PTX(va)]&PTEVALID))
            return 0;
    }
    vpd[PDX(va)] = entry;
    /*
     * TLB doesn't cache negative results, so no flush needed.
     */
    return 1;
}


/*
 * KMap is used to map individual pages into virtual memory.
 * It is rare to have more than a few KMaps at a time (in the 
 * absence of interrupts, only two at a time are ever used,
 * but interrupts can stack).  The mappings are local to a process,
 * so we can use the same range of virtual address space for
 * all processes without any coordination.
 */
#define kpt (vpt+VPTX(KMAP))
#define NKPT (KMAPSIZE/BY2PG)

KMap*
kmap(Page *page)
{
    int i, o, s;

    if(up == nil)
        panic("kmap: up=0 pc=%#.8lux", getcallerpc(&page));
    if(up->mmupdb == nil)
        upallocpdb();
    if(up->nkmap < 0)
        panic("kmap %lud %s: nkmap=%d", up->pid, up->text, up->nkmap);
    
    /*
     * Splhi shouldn't be necessary here, but paranoia reigns.
     * See comment in putmmu above.
     */
    s = splhi();
    up->nkmap++;
    if(!(vpd[PDX(KMAP)]&PTEVALID)){
        /* allocate page directory */
        if(KMAPSIZE > BY2XPG)
            panic("bad kmapsize");
        if(up->kmaptable != nil)
            panic("kmaptable");
        spllo();
        up->kmaptable = newpage(0, 0, 0);
        splhi();
        vpd[PDX(KMAP)] = up->kmaptable->pa|PTEWRITE|PTEVALID;
        flushpg((ulong)kpt);
        memset(kpt, 0, BY2PG);
        kpt[0] = page->pa|PTEWRITE|PTEVALID;
        up->lastkmap = 0;
        splx(s);
        return (KMap*)KMAP;
    }
    if(up->kmaptable == nil)
        panic("no kmaptable");
    o = up->lastkmap+1;
    for(i=0; i<NKPT; i++){
        if(kpt[(i+o)%NKPT] == 0){
            o = (i+o)%NKPT;
            kpt[o] = page->pa|PTEWRITE|PTEVALID;
            up->lastkmap = o;
            splx(s);
            return (KMap*)(KMAP+o*BY2PG);
        }
    }
    panic("out of kmap");
    return nil;
}

void
kunmap(KMap *k)
{
    ulong va;

    va = (ulong)k;
    if(up->mmupdb == nil || !(vpd[PDX(KMAP)]&PTEVALID))
        panic("kunmap: no kmaps");
    if(va < KMAP || va >= KMAP+KMAPSIZE)
        panic("kunmap: bad address %#.8lux pc=%#p", va, getcallerpc(&k));
    if(!(vpt[VPTX(va)]&PTEVALID))
        panic("kunmap: not mapped %#.8lux pc=%#p", va, getcallerpc(&k));
    up->nkmap--;
    if(up->nkmap < 0)
        panic("kunmap %lud %s: nkmap=%d", up->pid, up->text, up->nkmap);
    vpt[VPTX(va)] = 0;
    flushpg(va);
}

/*
 * Temporary one-page mapping used to edit page directories.
 *
 * The fasttmp #define controls whether the code optimizes
 * the case where the page is already mapped in the physical
 * memory window.  
 */
#define fasttmp 1

void*
tmpmap(Page *p)
{
    ulong i;
    ulong *entry;
    
    if(islo())
        panic("tmpaddr: islo");

    if(fasttmp && p->pa < -KZERO)
        return KADDR(p->pa);

    /*
     * PDX(TMPADDR) == PDX(MACHADDR), so this
     * entry is private to the processor and shared 
     * between up->mmupdb (if any) and m->pdb.
     */
    entry = &vpt[VPTX(TMPADDR)];
    if(!(*entry&PTEVALID)){
        for(i=KZERO; i<=CPU0MACH; i+=BY2PG)
            print("%#p: *%#p=%#p (vpt=%#p index=%#p)\n", i, &vpt[VPTX(i)], vpt[VPTX(i)], vpt, VPTX(i));
        panic("tmpmap: no entry");
    }
    if(PPN(*entry) != PPN(TMPADDR-KZERO))
        panic("tmpmap: already mapped entry=%#.8lux", *entry);
    *entry = p->pa|PTEWRITE|PTEVALID;
    flushpg(TMPADDR);
    return (void*)TMPADDR;
}

void
tmpunmap(void *v)
{
    ulong *entry;
    
    if(islo())
        panic("tmpaddr: islo");
    if(fasttmp && (ulong)v >= KZERO && v != (void*)TMPADDR)
        return;
    if(v != (void*)TMPADDR)
        panic("tmpunmap: bad address");
    entry = &vpt[VPTX(TMPADDR)];
    if(!(*entry&PTEVALID) || PPN(*entry) == PPN(PADDR(TMPADDR)))
        panic("tmpmap: not mapped entry=%#.8lux", *entry);
    *entry = PPN(TMPADDR-KZERO)|PTEWRITE|PTEVALID;
    flushpg(TMPADDR);
}

/*
 * These could go back to being macros once the kernel is debugged,
 * but the extra checking is nice to have.
 */
void*
kaddr(ulong pa)
{
    if(pa > (ulong)-KZERO)
        panic("kaddr: pa=%#.8lux", pa);
    return (void*)(pa+KZERO);
}

ulong
paddr(void *v)
{
    ulong va;
    
    va = (ulong)v;
    if(va < KZERO)
        panic("paddr: va=%#.8lux pc=%#p", va, getcallerpc(&v));
    return va-KZERO;
}

/*
 * More debugging.
 */
void
countpagerefs(ulong *ref, int print)
{
    int i, n;
    Mach *mm;
    Page *pg;
    Proc *p;
    
    n = 0;
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        if(p->mmupdb){
            if(print){
                if(ref[pagenumber(p->mmupdb)])
                    iprint("page %#.8lux is proc %d (pid %lud) pdb\n",
                        p->mmupdb->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(p->mmupdb)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is proc %d (pid %lud) pdb but has other refs!\n",
                    p->mmupdb->pa, i, p->pid);
        }
        if(p->kmaptable){
            if(print){
                if(ref[pagenumber(p->kmaptable)])
                    iprint("page %#.8lux is proc %d (pid %lud) kmaptable\n",
                        p->kmaptable->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(p->kmaptable)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is proc %d (pid %lud) kmaptable but has other refs!\n",
                    p->kmaptable->pa, i, p->pid);
        }
        for(pg=p->mmuused; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is on proc %d (pid %lud) mmuused\n",
                        pg->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is on proc %d (pid %lud) mmuused but has other refs!\n",
                    pg->pa, i, p->pid);
        }
        for(pg=p->mmufree; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is on proc %d (pid %lud) mmufree\n",
                        pg->pa, i, p->pid);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is on proc %d (pid %lud) mmufree but has other refs!\n",
                    pg->pa, i, p->pid);
        }
    }
    if(!print)
        iprint("%d pages in proc mmu\n", n);
    n = 0;
    for(i=0; i<conf.nmach; i++){
        mm = MACHP(i);
        for(pg=mm->pdbpool; pg; pg=pg->next){
            if(print){
                if(ref[pagenumber(pg)])
                    iprint("page %#.8lux is in cpu%d pdbpool\n",
                        pg->pa, i);
                continue;
            }
            if(ref[pagenumber(pg)]++ == 0)
                n++;
            else
                iprint("page %#.8lux is in cpu%d pdbpool but has other refs!\n",
                    pg->pa, i);
        }
    }
    if(!print){
        iprint("%d pages in mach pdbpools\n", n);
        for(i=0; i<conf.nmach; i++)
            iprint("cpu%d: %d pdballoc, %d pdbfree\n",
                i, MACHP(i)->pdballoc, MACHP(i)->pdbfree);
    }
}

void
checkfault(ulong, ulong)
{
}

/*
 * Return the number of bytes that can be accessed via KADDR(pa).
 * If pa is not a valid argument to KADDR, return 0.
 */
ulong
cankaddr(ulong pa)
{
    if(pa >= -KZERO)
        return 0;
    return -KZERO - pa;
}

@


\subsection*{[[memory/alloc.c]]}

<<alloc.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "error.h"

#include    <pool.h>

/* everything from here down should be the same in libc, libdebugmalloc, and the kernel */
/* - except the code for malloc(), which alternately doesn't clear or does. */
/* - except the code for smalloc(), which lives only in the kernel. */

//*****************************************************************************
// Debugging support
//*****************************************************************************

/*
 * Npadlong is the number of 32-bit longs to leave at the beginning of 
 * each allocated buffer for our own bookkeeping.  We return to the callers
 * a pointer that points immediately after our bookkeeping area.  Incoming pointers
 * must be decremented by that much, and outgoing pointers incremented.
 * The malloc tag is stored at MallocOffset from the beginning of the block,
 * and the realloc tag at ReallocOffset.  The offsets are from the true beginning
 * of the block, not the beginning the caller sees.
 *
 * The extra if(Npadlong != 0) in various places is a hint for the compiler to
 * compile out function calls that would otherwise be no-ops.
 */

/* non tracing
 *
enum {
    Npadlong    = 0,
    MallocOffset = 0,
    ReallocOffset = 0,
};
 *
 */

/* tracing */
enum {
    Npadlong    = 2,
    MallocOffset = 0,
    ReallocOffset = 1
};

void
setmalloctag(void *v, ulong pc)
{
    ulong *u;
    USED(v, pc);
    if(Npadlong <= MallocOffset || v == nil)
        return;
    u = v;
    u[-Npadlong+MallocOffset] = pc;
}

void
setrealloctag(void *v, ulong pc)
{
    ulong *u;
    USED(v, pc);
    if(Npadlong <= ReallocOffset || v == nil)
        return;
    u = v;
    u[-Npadlong+ReallocOffset] = pc;
}

//unused:
//ulong
//getmalloctag(void *v)
//{
//  USED(v);
//  if(Npadlong <= MallocOffset)
//      return ~0;
//  return ((ulong*)v)[-Npadlong+MallocOffset];
//}
//
//ulong
//getrealloctag(void *v)
//{
//  USED(v);
//  if(Npadlong <= ReallocOffset)
//      return ((ulong*)v)[-Npadlong+ReallocOffset];
//  return ~0;
//}

//*****************************************************************************
// Pool wrappers
//*****************************************************************************

// non failing malloc! will repeat until it can
void*
smalloc(ulong size)
{
    void *v;

    for(;;) {
        v = poolalloc(mainmem, size + Npadlong*sizeof(ulong));
        if(v != nil)
            break;
        tsleep(&up->sleep, return0, 0, 100);
    }
    if(Npadlong){
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
    }
    memset(v, 0, size);
    return v;
}

void*
malloc(ulong size)
{
    void *v;

    v = poolalloc(mainmem, size+Npadlong*sizeof(ulong));
    if(v == nil)
        return nil;
    if(Npadlong){
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    memset(v, 0, size);
    return v;
}

void*
mallocz(ulong size, int clr)
{
    void *v;

    v = poolalloc(mainmem, size+Npadlong*sizeof(ulong));
    if(Npadlong && v != nil){
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    if(clr && v != nil)
        memset(v, 0, size);
    return v;
}

void*
mallocalign(ulong size, ulong align, long offset, ulong span)
{
    void *v;

    v = poolallocalign(mainmem, size+Npadlong*sizeof(ulong), align, 
                           offset-Npadlong*sizeof(ulong), span);
    if(Npadlong && v != nil){
        v = (ulong*)v+Npadlong;
        setmalloctag(v, getcallerpc(&size));
        setrealloctag(v, 0);
    }
    if(v)
        memset(v, 0, size);
    return v;
}

void
free(void *v)
{
    if(v != nil)
        poolfree(mainmem, (ulong*)v-Npadlong);
}

void*
realloc(void *v, ulong size)
{
    void *nv;

    if(v != nil)
        v = (ulong*)v-Npadlong;
    if(Npadlong !=0 && size != 0)
        size += Npadlong*sizeof(ulong);

    if(nv = poolrealloc(mainmem, v, size)){
        nv = (ulong*)nv+Npadlong;
        setrealloctag(nv, getcallerpc(&v));
        if(v == nil)
            setmalloctag(nv, getcallerpc(&v));
    }       
    return nv;
}

ulong
msize(void *v)
{
    return poolmsize(mainmem, (ulong*)v-Npadlong)-Npadlong*sizeof(ulong);
}

//unused:
//void*
//calloc(ulong n, ulong szelem)
//{
//  void *v;
//  if(v = mallocz(n*szelem, 1))
//      setmalloctag(v, getcallerpc(&n));
//  return v;
//}


//*****************************************************************************
// kstr functions
//*****************************************************************************

//pad: was in chan.c

/*
 * Rather than strncpy, which zeros the rest of the buffer, kstrcpy
 * truncates if necessary, always zero terminates, does not zero fill,
 * and puts ... at the end of the string if it's too long.  Usually used to
 * save a string in up->genbuf;
 */
void
kstrcpy(char *s, char *t, int ns)
{
    int nt;

    nt = strlen(t);
    if(nt+1 <= ns){
        memmove(s, t, nt+1);
        return;
    }
    /* too long */
    if(ns < 4){
        /* but very short! */
        strncpy(s, t, ns);
        return;
    }
    /* truncate with ... at character boundary (very rare case) */
    memmove(s, t, ns-4);
    ns -= 4;
    s[ns] = '\0';
    /* look for first byte of UTF-8 sequence by skipping continuation bytes */
    while(ns>0 && (s[--ns]&0xC0)==0x80)
        ;
    strcpy(s+ns, "...");
}

/*
 * Atomically replace *p with copy of s
 */
void
kstrdup(char **p, char *s)
{
    int n;
    char *t, *prev;

    n = strlen(s)+1;
    /* if it's a user, we can wait for memory; if not, something's very wrong */
    if(up){
        t = smalloc(n);
        setmalloctag(t, getcallerpc(&p));
    }else{
        t = malloc(n);
        if(t == nil)
            panic("kstrdup: no memory");
    }
    memmove(t, s, n);
    prev = *p;
    *p = t;
    free(prev);
}
@


\subsection*{[[memory/fault.c]]}

<<fault.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

void        pio(Segment *, ulong, ulong, Page **);


int
fault(ulong addr, bool read)
{
    Segment *s;
    char *sps;

    if(up == nil)
        panic("fault: nil up");
    if(up->nlocks.ref)
        print("fault: addr %#p: nlocks %ld\n", addr, up->nlocks.ref);

    sps = up->psstate;
    up->psstate = "Fault";
    spllo();

    m->pfault++;
    for(;;) {
        s = seg(up, addr, 1);       /* leaves s->lk qlocked if seg != nil */
        if(s == 0) {
            up->psstate = sps;
            return -1;
        }

        if(!read && (s->type&SG_RONLY)) {
            qunlock(&s->lk);
            up->psstate = sps;
            return -1;
        }

        if(fixfault(s, addr, read, 1) == 0) /* qunlocks s->lk */
            break;
    }

    up->psstate = sps;
    return 0;
}

static void
faulterror(char *s, Chan *c, int freemem)
{
    char buf[ERRMAX];

    if(c && c->path){
        snprint(buf, sizeof buf, "%s accessing %s: %s", s, c->path->s, up->errstr);
        s = buf;
    }
    if(up->nerrlab) {
        postnote(up, 1, s, NDebug);
        error(s);
    }
    pexit(s, freemem);
}

void    (*checkaddr)(ulong, Segment *, Page *);
ulong   addr2check;

int
fixfault(Segment *s, ulong addr, int read, int doputmmu)
{
    int type;
    int ref;
    Pte **p, *etp;
    ulong mmuphys=0, soff;
    Page **pg, *lkp, *new;
    Page *(*fn)(Segment*, ulong);

    addr &= ~(BY2PG-1);
    soff = addr-s->base;
    p = &s->map[soff/PTEMAPMEM];
    if(*p == 0)
        *p = ptealloc();

    etp = *p;
    pg = &etp->pages[(soff&(PTEMAPMEM-1))/BY2PG];
    type = s->type&SG_TYPE;

    if(pg < etp->first)
        etp->first = pg;
    if(pg > etp->last)
        etp->last = pg;

    switch(type) {
    default:
        panic("fault");
        break;

    case SG_TEXT:           /* Demand load */
        if(pagedout(*pg))
            pio(s, addr, soff, pg);

        mmuphys = PPN((*pg)->pa) | PTERONLY|PTEVALID;
        (*pg)->modref = PG_REF;
        break;

    case SG_BSS:
    case SG_SHARED:         /* Zero fill on demand */
    case SG_STACK:
        if(*pg == 0) {
            new = newpage(1, &s, addr);
            if(s == 0)
                return -1;

            *pg = new;
        }
        goto common;

    case SG_DATA:
    common:         /* Demand load/pagein/copy on write */
        if(pagedout(*pg))
            pio(s, addr, soff, pg);

        /*
         *  It's only possible to copy on write if
         *  we're the only user of the segment.
         */
        if(read && conf.copymode == 0 && s->ref == 1) {
            mmuphys = PPN((*pg)->pa)|PTERONLY|PTEVALID;
            (*pg)->modref |= PG_REF;
            break;
        }

        lkp = *pg;
        lock(lkp);

        if(lkp->image == &swapimage)
            ref = lkp->ref + swapcount(lkp->daddr);
        else
            ref = lkp->ref;
        if(ref == 1 && lkp->image){
            /* save a copy of the original for the image cache */
            duppage(lkp);
            ref = lkp->ref;
        }
        unlock(lkp);
        if(ref > 1){
            new = newpage(0, &s, addr);
            if(s == 0)
                return -1;
            *pg = new;
            copypage(lkp, *pg);
            putpage(lkp);
        }
        mmuphys = PPN((*pg)->pa) | PTEWRITE | PTEVALID;
        (*pg)->modref = PG_MOD|PG_REF;
        break;

    case SG_PHYSICAL:
        if(*pg == 0) {
            fn = s->pseg->pgalloc;
            if(fn)
                *pg = (*fn)(s, addr);
            else {
                new = smalloc(sizeof(Page));
                new->va = addr;
                new->pa = s->pseg->pa+(addr-s->base);
                new->ref = 1;
                *pg = new;
            }
        }

        if (checkaddr && addr == addr2check)
            (*checkaddr)(addr, s, *pg);
        mmuphys = PPN((*pg)->pa) |PTEWRITE|PTEUNCACHED|PTEVALID;
        (*pg)->modref = PG_MOD|PG_REF;
        break;
    }
    qunlock(&s->lk);

    if(doputmmu)
        putmmu(addr, mmuphys, *pg);

    return 0;
}

// page io on the text segment
void
pio(Segment *s, ulong addr, ulong soff, Page **p)
{
    Page *new;
    KMap *k;
    Chan *c;
    int n, ask;
    char *kaddr;
    ulong daddr; // disk address
    Page *loadrec;

retry:
    loadrec = *p;
    if(loadrec == 0) {  /* from a text/data image */
        daddr = s->fstart+soff;
        new = lookpage(s->image, daddr);
        if(new != nil) {
            *p = new;
            return;
        }

        c = s->image->c;
        ask = s->flen-soff;
        if(ask > BY2PG)
            ask = BY2PG;
    }
    else {          /* from a swap image */
        daddr = swapaddr(loadrec);
        new = lookpage(&swapimage, daddr);
        if(new != nil) {
            putswap(loadrec);
            *p = new;
            return;
        }

        c = swapimage.c;
        ask = BY2PG;
    }
    qunlock(&s->lk);

    new = newpage(0, 0, addr);
    k = kmap(new);
    kaddr = (char*)VA(k);

    while(waserror()) {
        if(strcmp(up->errstr, Eintr) == 0)
            continue;
        kunmap(k);
        putpage(new);
        faulterror(Eioload, c, 0);
    }

    n = devtab[c->type]->read(c, kaddr, ask, daddr);
    if(n != ask)
        faulterror(Eioload, c, 0);
    if(ask < BY2PG)
        memset(kaddr+ask, 0, BY2PG-ask);

    poperror();
    kunmap(k);
    qlock(&s->lk);
    if(loadrec == 0) {  /* This is demand load */
        /*
         *  race, another proc may have gotten here first while
         *  s->lk was unlocked
         */
        if(*p == 0) { 
            new->daddr = daddr;
            cachepage(new, s->image);
            *p = new;
        }
        else
            putpage(new);
    }
    else {          /* This is paged out */
        /*
         *  race, another proc may have gotten here first
         *  (and the pager may have run on that page) while
         *  s->lk was unlocked
         */
        if(*p != loadrec){
            if(!pagedout(*p)){
                /* another process did it for me */
                putpage(new);
                goto done;
            } else {
                /* another process and the pager got in */
                putpage(new);
                goto retry;
            }
        }

        new->daddr = daddr;
        cachepage(new, &swapimage);
        *p = new;
        putswap(loadrec);
    }

done:
    if(s->flushme)
        memset((*p)->cachectl, PG_TXTFLUSH, sizeof((*p)->cachectl));
}

/*
 * Called only in a system call
 */
int
okaddr(ulong addr, ulong len, int write)
{
    Segment *s;

    if((long)len >= 0) {
        for(;;) {
            s = seg(up, addr, 0);
            if(s == 0 || (write && (s->type&SG_RONLY)))
                break;

            if(addr+len > s->top) {
                len -= s->top - addr;
                addr = s->top;
                continue;
            }
            return 1;
        }
    }
    pprint("suicide: invalid address %#lux/%lud in sys call pc=%#lux\n", addr, len, userpc());
    return 0;
}

void
validaddr(ulong addr, ulong len, int write)
{
    if(!okaddr(addr, len, write)){
        postnote(up, 1, "sys: bad address in syscall", NDebug);
        error(Ebadarg);
    }
}

/*
 * &s[0] is known to be a valid address.
 */
void*
vmemchr(void *s, int c, int n)
{
    int m;
    ulong a;
    void *t;

    a = (ulong)s;
    while(PGROUND(a) != PGROUND(a+n-1)){
        /* spans pages; handle this page */
        m = BY2PG - (a & (BY2PG-1));
        t = memchr((void*)a, c, m);
        if(t)
            return t;
        a += m;
        n -= m;
        if(a < KZERO)
            validaddr(a, 1, 0);
    }

    /* fits in one page */
    return memchr((void*)a, c, n);
}

Segment*
seg(Proc *p, ulong addr, int dolock)
{
    Segment **s, **et, *n;

    et = &p->seg[NSEG];
    for(s = p->seg; s < et; s++) {
        n = *s;
        if(n == 0)
            continue;
        if(addr >= n->base && addr < n->top) {
            if(dolock == 0)
                return n;

            qlock(&n->lk);
            if(addr >= n->base && addr < n->top)
                return n;
            qunlock(&n->lk);
        }
    }

    return 0;
}

void
checkpages(void)
{
    int checked;
    ulong addr, off;
    Pte *p;
    Page *pg;
    Segment **sp, **ep, *s;
    
    if(up == nil)
        return;

    checked = 0;
    for(sp=up->seg, ep=&up->seg[NSEG]; sp<ep; sp++){
        s = *sp;
        if(s == nil)
            continue;
        qlock(&s->lk);
        for(addr=s->base; addr<s->top; addr+=BY2PG){
            off = addr - s->base;
            p = s->map[off/PTEMAPMEM];
            if(p == 0)
                continue;
            pg = p->pages[(off&(PTEMAPMEM-1))/BY2PG];
            if(pg == 0 || pagedout(pg))
                continue;
            checkmmu(addr, pg->pa);
            checked++;
        }
        qunlock(&s->lk);
    }
    print("%ld %s: checked %d page table entries\n", up->pid, up->text, checked);
}
@


\subsection*{[[memory/page.c]]}

<<page.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// forward decl
int     ispages(void*);
void        portcountpagerefs(ulong*, int);

//*****************************************************************************
// Initialization
//*****************************************************************************

void
pageinit(void)
{
    int color, i, j;
    Page *p;
    Pallocmem *pm;
    ulong m, np, k, vkb, pkb;

    np = 0;
    for(i=0; i<nelem(palloc.mem); i++){
        pm = &palloc.mem[i];
        np += pm->npage;
    }
    palloc.pages = xalloc(np*sizeof(Page));
    if(palloc.pages == 0)
        panic("pageinit");

    color = 0;
    palloc.head = palloc.pages;
    p = palloc.head;
    for(i=0; i<nelem(palloc.mem); i++){
        pm = &palloc.mem[i];
        for(j=0; j<pm->npage; j++){
            p->prev = p-1;
            p->next = p+1;
            p->pa = pm->base+j*BY2PG;
            p->color = color;
            palloc.freecount++;
            color = (color+1)%NCOLOR;
            p++;
        }
    }
    palloc.tail = p - 1;
    palloc.head->prev = 0;
    palloc.tail->next = 0;

    palloc.user = p - palloc.pages; // TODO? should be np too no?
    pkb = palloc.user*BY2PG/1024;
    vkb = pkb + (conf.nswap*BY2PG)/1024;

    /* Paging numbers */
    swapalloc.highwater = (palloc.user*5)/100;
    swapalloc.headroom = swapalloc.highwater + (swapalloc.highwater/4);

    m = 0;
    for(i=0; i<nelem(conf.mem); i++)
        if(conf.mem[i].npage)
            m += conf.mem[i].npage*BY2PG;
    k = PGROUND(end - (char*)KTZERO);
    print("%ldM memory: ", (m+k+1024*1024-1)/(1024*1024));
    print("%ldM kernel data, ", (m+k-pkb*1024+1024*1024-1)/(1024*1024));
    print("%ldM user, ", pkb/1024);
    print("%ldM swap\n", vkb/1024);
}

//*****************************************************************************
// Functions
//*****************************************************************************

static void
pageunchain(Page *p)
{
    if(canlock(&palloc))
        panic("pageunchain (palloc %p)", &palloc);
    if(p->prev)
        p->prev->next = p->next;
    else
        palloc.head = p->next;
    if(p->next)
        p->next->prev = p->prev;
    else
        palloc.tail = p->prev;
    p->prev = p->next = nil;
    palloc.freecount--;
}

void
pagechaintail(Page *p)
{
    if(canlock(&palloc))
        panic("pagechaintail");
    if(palloc.tail) {
        p->prev = palloc.tail;
        palloc.tail->next = p;
    }
    else {
        palloc.head = p;
        p->prev = 0;
    }
    palloc.tail = p;
    p->next = 0;
    palloc.freecount++;
}

void
pagechainhead(Page *p)
{
    if(canlock(&palloc))
        panic("pagechainhead");
    if(palloc.head) {
        p->next = palloc.head;
        palloc.head->prev = p;
    }
    else {
        palloc.tail = p;
        p->next = 0;
    }
    palloc.head = p;
    p->prev = 0;
    palloc.freecount++;
}

Page*
newpage(int clear, Segment **s, ulong va)
{
    Page *p;
    KMap *k;
    uchar ct;
    int i, hw, dontalloc, color;

    lock(&palloc);
    color = getpgcolor(va);
    hw = swapalloc.highwater;
    for(;;) {
        if(palloc.freecount > hw)
            break;
        if(up->kp && palloc.freecount > 0)
            break;

        unlock(&palloc);
        dontalloc = 0;
        if(s && *s) {
            qunlock(&((*s)->lk));
            *s = 0;
            dontalloc = 1;
        }
        qlock(&palloc.pwait);   /* Hold memory requesters here */

        while(waserror())   /* Ignore interrupts */
            ;

        kickpager();
        tsleep(&palloc.r, ispages, 0, 1000);

        poperror();

        qunlock(&palloc.pwait);

        /*
         * If called from fault and we lost the segment from
         * underneath don't waste time allocating and freeing
         * a page. Fault will call newpage again when it has
         * reacquired the segment locks
         */
        if(dontalloc)
            return 0;

        lock(&palloc);
    }

    /* First try for our colour */
    for(p = palloc.head; p; p = p->next)
        if(p->color == color)
            break;

    ct = PG_NOFLUSH;
    if(p == 0) {
        p = palloc.head;
        p->color = color;
        ct = PG_NEWCOL;
    }

    pageunchain(p);

    lock(p);
    if(p->ref != 0)
        panic("newpage: p->ref %d != 0", p->ref);

    uncachepage(p);
    p->ref++;
    p->va = va;
    p->modref = 0;
    for(i = 0; i < MAXMACH; i++)
        p->cachectl[i] = ct;
    unlock(p);
    unlock(&palloc);

    if(clear) {
        k = kmap(p);
        memset((void*)VA(k), 0, BY2PG);
        kunmap(k);
    }

    return p;
}

int
ispages(void*)
{
    return palloc.freecount >= swapalloc.highwater;
}

void
putpage(Page *p)
{
    if(onswap(p)) {
        putswap(p);
        return;
    }

    lock(&palloc);
    lock(p);

    if(p->ref == 0)
        panic("putpage");

    if(--p->ref > 0) {
        unlock(p);
        unlock(&palloc);
        return;
    }

    if(p->image && p->image != &swapimage)
        pagechaintail(p);
    else 
        pagechainhead(p);

    if(palloc.r.p != 0)
        wakeup(&palloc.r);

    unlock(p);
    unlock(&palloc);
}

Page*
auxpage(void)
{
    Page *p;

    lock(&palloc);
    p = palloc.head;
    if(palloc.freecount < swapalloc.highwater) {
        unlock(&palloc);
        return 0;
    }
    pageunchain(p);

    lock(p);
    if(p->ref != 0)
        panic("auxpage");
    p->ref++;
    uncachepage(p);
    unlock(p);
    unlock(&palloc);

    return p;
}

static int dupretries = 15000;

int
duppage(Page *p)                /* Always call with p locked */
{
    Page *np;
    int color;
    int retries;

    retries = 0;
retry:

    if(retries++ > dupretries){
        print("duppage %d, up %p\n", retries, up);
        dupretries += 100;
        if(dupretries > 100000)
            panic("duppage\n");
        uncachepage(p);
        return 1;
    }
        

    /* don't dup pages with no image */
    if(p->ref == 0 || p->image == nil || p->image->notext)
        return 0;

    /*
     *  normal lock ordering is to call
     *  lock(&palloc) before lock(p).
     *  To avoid deadlock, we have to drop
     *  our locks and try again.
     */
    if(!canlock(&palloc)){
        unlock(p);
        if(up)
            sched();
        lock(p);
        goto retry;
    }

    /* No freelist cache when memory is very low */
    if(palloc.freecount < swapalloc.highwater) {
        unlock(&palloc);
        uncachepage(p);
        return 1;
    }

    color = getpgcolor(p->va);
    for(np = palloc.head; np; np = np->next)
        if(np->color == color)
            break;

    /* No page of the correct color */
    if(np == 0) {
        unlock(&palloc);
        uncachepage(p);
        return 1;
    }

    pageunchain(np);
    pagechaintail(np);
/*
* XXX - here's a bug? - np is on the freelist but it's not really free.
* when we unlock palloc someone else can come in, decide to
* use np, and then try to lock it.  they succeed after we've 
* run copypage and cachepage and unlock(np).  then what?
* they call pageunchain before locking(np), so it's removed
* from the freelist, but still in the cache because of
* cachepage below.  if someone else looks in the cache
* before they remove it, the page will have a nonzero ref
* once they finally lock(np).
*/
    lock(np);
    unlock(&palloc);

    /* Cache the new version */
    uncachepage(np);
    np->va = p->va;
    np->daddr = p->daddr;
    copypage(p, np);
    cachepage(np, p->image);
    unlock(np);
    uncachepage(p);

    return 0;
}

void
copypage(Page *f, Page *t)
{
    KMap *ks, *kd;

    ks = kmap(f);
    kd = kmap(t);
    memmove((void*)VA(kd), (void*)VA(ks), BY2PG);
    kunmap(ks);
    kunmap(kd);
}

void
uncachepage(Page *p)            /* Always called with a locked page */
{
    Page **l, *f;

    if(p->image == 0)
        return;

    lock(&palloc.hashlock);
    l = &pghash(p->daddr);
    for(f = *l; f; f = f->hash) {
        if(f == p) {
            *l = p->hash;
            break;
        }
        l = &f->hash;
    }
    unlock(&palloc.hashlock);
    putimage(p->image);
    p->image = 0;
    p->daddr = 0;
}

void
cachepage(Page *p, KImage *i)
{
    Page **l;

    /* If this ever happens it should be fixed by calling
     * uncachepage instead of panic. I think there is a race
     * with pio in which this can happen. Calling uncachepage is
     * correct - I just wanted to see if we got here.
     */
    if(p->image)
        panic("cachepage");

    incref(i);
    lock(&palloc.hashlock);
    p->image = i;
    l = &pghash(p->daddr);
    p->hash = *l;
    *l = p;
    unlock(&palloc.hashlock);
}

void
cachedel(KImage *i, ulong daddr)
{
    Page *f, **l;

    lock(&palloc.hashlock);
    l = &pghash(daddr);
    for(f = *l; f; f = f->hash) {
        if(f->image == i && f->daddr == daddr) {
            lock(f);
            if(f->image == i && f->daddr == daddr){
                *l = f->hash;
                putimage(f->image);
                f->image = 0;
                f->daddr = 0;
            }
            unlock(f);
            break;
        }
        l = &f->hash;
    }
    unlock(&palloc.hashlock);
}

Page *
lookpage(KImage *i, ulong daddr)
{
    Page *f;

    lock(&palloc.hashlock);
    for(f = pghash(daddr); f; f = f->hash) {
        if(f->image == i && f->daddr == daddr) {
            unlock(&palloc.hashlock);

            lock(&palloc);
            lock(f);
            if(f->image != i || f->daddr != daddr) {
                unlock(f);
                unlock(&palloc);
                return 0;
            }
            if(++f->ref == 1)
                pageunchain(f);
            unlock(&palloc);
            unlock(f);

            return f;
        }
    }
    unlock(&palloc.hashlock);

    return 0;
}

Pte*
ptecpy(Pte *old)
{
    Pte *new;
    Page **src, **dst;

    new = ptealloc();
    dst = &new->pages[old->first-old->pages];
    new->first = dst;
    for(src = old->first; src <= old->last; src++, dst++)
        if(*src) {
            if(onswap(*src))
                dupswap(*src);
            else {
                lock(*src);
                (*src)->ref++;
                unlock(*src);
            }
            new->last = dst;
            *dst = *src;
        }

    return new;
}

Pte*
ptealloc(void)
{
    Pte *new;

    new = smalloc(sizeof(Pte));
    new->first = &new->pages[PTEPERTAB];
    new->last = new->pages;
    return new;
}

void
freepte(Segment *s, Pte *p)
{
    int ref;
    void (*fn)(Page*);
    Page *pt, **pg, **ptop;

    switch(s->type&SG_TYPE) {
    case SG_PHYSICAL:
        fn = s->pseg->pgfree;
        ptop = &p->pages[PTEPERTAB];
        if(fn) {
            for(pg = p->pages; pg < ptop; pg++) {
                if(*pg == 0)
                    continue;
                (*fn)(*pg);
                *pg = 0;
            }
            break;
        }
        for(pg = p->pages; pg < ptop; pg++) {
            pt = *pg;
            if(pt == 0)
                continue;
            lock(pt);
            ref = --pt->ref;
            unlock(pt);
            if(ref == 0)
                free(pt);
        }
        break;
    default:
        for(pg = p->first; pg <= p->last; pg++)
            if(*pg) {
                putpage(*pg);
                *pg = 0;
            }
    }
    free(p);
}

ulong
pagenumber(Page *p)
{
    return p-palloc.pages;
}

void
checkpagerefs(void)
{
    int s;
    ulong i, np, nwrong;
    ulong *ref;
    
    np = palloc.user;
    ref = malloc(np*sizeof ref[0]);
    if(ref == nil){
        print("checkpagerefs: out of memory\n");
        return;
    }
    
    /*
     * This may not be exact if there are other processes
     * holding refs to pages on their stacks.  The hope is
     * that if you run it on a quiescent system it will still
     * be useful.
     */
    s = splhi();
    lock(&palloc);
    countpagerefs(ref, 0);
    portcountpagerefs(ref, 0);
    nwrong = 0;
    for(i=0; i<np; i++){
        if(palloc.pages[i].ref != ref[i]){
            iprint("page %#.8lux ref %d actual %lud\n", 
                palloc.pages[i].pa, palloc.pages[i].ref, ref[i]);
            ref[i] = 1;
            nwrong++;
        }else
            ref[i] = 0;
    }
    countpagerefs(ref, 1);
    portcountpagerefs(ref, 1);
    iprint("%lud mistakes found\n", nwrong);
    unlock(&palloc);
    splx(s);
}

void
portcountpagerefs(ulong *ref, int print)
{
    ulong i, j, k, ns, n;
    Page **pg, *entry;
    Proc *p;
    Pte *pte;
    Segment *s;

    /*
     * Pages in segments.  s->mark avoids double-counting.
     */
    n = 0;
    ns = 0;
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        for(j=0; j<NSEG; j++){
            s = p->seg[j];
            if(s)
                s->mark = 0;
        }
    }
    for(i=0; i<conf.nproc; i++){
        p = proctab(i);
        for(j=0; j<NSEG; j++){
            s = p->seg[j];
            if(s == nil || s->mark++)
                continue;
            ns++;
            for(k=0; k<s->mapsize; k++){
                pte = s->map[k];
                if(pte == nil)
                    continue;
                for(pg = pte->first; pg <= pte->last; pg++){
                    entry = *pg;
                    if(pagedout(entry))
                        continue;
                    if(print){
                        if(ref[pagenumber(entry)])
                            iprint("page %#.8lux in segment %#p\n", entry->pa, s);
                        continue;
                    }
                    if(ref[pagenumber(entry)]++ == 0)
                        n++;
                }
            }
        }
    }
    if(!print){
        iprint("%lud pages in %lud segments\n", n, ns);
        for(i=0; i<conf.nproc; i++){
            p = proctab(i);
            for(j=0; j<NSEG; j++){
                s = p->seg[j];
                if(s == nil)
                    continue;
                if(s->ref != s->mark){
                    iprint("segment %#p (used by proc %lud pid %lud) has bad ref count %lud actual %lud\n",
                        s, i, p->pid, s->ref, s->mark);
                }
            }
        }
    }
}

@


\subsection*{[[memory/pool.c]]}

<<pool.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "error.h"

#include    <pool.h>

//*****************************************************************************
// Concurrency
//*****************************************************************************

// See Pool.private, for mutual exclusion on memory pools
struct Private {
    Lock        lk;
    char        msg[256]; /* a rock for messages to be printed at unlock */
};
typedef struct Private  Private;

//*****************************************************************************
// Pool methods
//*****************************************************************************

/*
 * because we can't print while we're holding the locks, 
 * we have the save the message and print it once we let go.
 */
static void
poolprint(Pool *p, char *fmt, ...)
{
    va_list v;
    Private *pv;

    pv = p->private;
    va_start(v, fmt);
    vseprint(pv->msg+strlen(pv->msg), pv->msg+sizeof pv->msg, fmt, v);
    va_end(v);
}

static void
ppanic(Pool *p, char *fmt, ...)
{
    va_list v;
    Private *pv;
    char msg[sizeof pv->msg];

    pv = p->private;
    va_start(v, fmt);
    vseprint(pv->msg+strlen(pv->msg), pv->msg+sizeof pv->msg, fmt, v);
    va_end(v);
    memmove(msg, pv->msg, sizeof msg);
    iunlock(&pv->lk);
    panic("%s", msg);
}

static void
plock(Pool *p)
{
    Private *pv;

    pv = p->private;
    ilock(&pv->lk);
    pv->lk.pc = getcallerpc(&p);
    pv->msg[0] = 0;
}

static void
punlock(Pool *p)
{
    Private *pv;
    char msg[sizeof pv->msg];

    pv = p->private;
    if(pv->msg[0] == 0){
        iunlock(&pv->lk);
        return;
    }

    memmove(msg, pv->msg, sizeof msg);
    iunlock(&pv->lk);
    iprint("%.*s", sizeof pv->msg, msg);
}

void
poolsummary(Pool *p)
{
    print("%s max %lud cur %lud free %lud alloc %lud\n", p->name,
        p->maxsize, p->cursize, p->curfree, p->curalloc);
}

//*****************************************************************************
// The globals
//*****************************************************************************

static Private pmainpriv;
static Pool pmainmem = {
    .name=  "Main",
    .maxsize=   4*1024*1024,
    .minarena=  128*1024,
    .quantum=   32,
    .alloc= xalloc,
    .merge= xmerge,
    .flags= POOL_TOLERANCE,

    .lock=plock,
    .unlock= punlock,
    .print= poolprint,
    .panic= ppanic,

    .private=   &pmainpriv,
};

static Private pimagpriv;
static Pool pimagmem = {
    .name=  "Image",
    .maxsize=   16*1024*1024,
    .minarena=  2*1024*1024,
    .quantum=   32,
    .alloc= xalloc,
    .merge= xmerge,
    .flags= 0,

    .lock= plock,
    .unlock= punlock,
    .print= poolprint,
    .panic= ppanic,

    .private=   &pimagpriv,
};

// exported in include/pool.h, defined here!
Pool*   mainmem = &pmainmem;
Pool*   imagmem = &pimagmem;

void
mallocsummary(void)
{
    poolsummary(mainmem);
    poolsummary(imagmem);
}

@


\subsection*{[[memory/portdat_memory.c]]}

<<portdat_memory.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

// Page allocator
struct Palloc palloc;

// Swap allocator
struct Swapalloc swapalloc;
KImage  swapimage;

@


\subsection*{[[memory/portdat_memory.h]]}

<<portdat_memory.h>>=

// see also KMap in 386/ (but used in port)

// physical address
typedef ulong phys_addr;
// virtual address
typedef ulong virt_addr;

//*****************************************************************************
// Page < Pte (can be filled by KImage) < Segment
//*****************************************************************************

// All the ref<Page> here are references to Pages in the array<Page> of 
// Palloc.pages (pool allocator)
// All the ref<Kimage> here are references to KImage in the ?? of 
// Imagealloc.free?

enum modref 
{
  PG_MOD    = 0x01,   /* software modified bit */
  PG_REF    = 0x02,   /* software referenced bit */
};

enum cachectl
{
  PG_NOFLUSH  = 0,
  PG_TXTFLUSH = 1,    /* flush dcache and invalidate icache */
  //  PG_DATFLUSH = 2,    /* flush both i & d caches (UNUSED) */
  PG_NEWCOL = 3,    /* page has been recolored */
};

// Page metadata. We will allocate as many Page as to cover all physical memory
// + swap "address space". Either pa or daddr should be valid at one time.
// Should have been xalloc'ed in Palloc.pages
struct Page
{
  phys_addr pa;     /* Physical address in memory */
  virt_addr va;     /* Virtual address for user */

  ulong daddr;      /* Disc address on swap */
  ulong gen;      /* Generation counter for swap */

  // Why not Ref? to save space?
  ushort  ref;      /* Reference count */
  // set<enum<modref>>
  char  modref;     /* Simulated modify/reference bits */
  // enum<cachectl>??
  char  color;      /* Cache coloring */
  // array<enum<cachectl>>
  char  cachectl[MAXMACH];  /* Cache flushing control for putmmu */

  // extra
  Lock;
  Page  *next; /* Lru free list */ // list<ref<Page>> Palloc.head?
  Page  *prev; // ??
  Page  *hash; /* Image hash chains */ // hash<?, list<ref<Page>>> Palloc.hash?
  // option<ref<Kimage>>
  KImage  *image;     /* Associated text or swap image */
};

// ptealloc'ed (malloc'ed)
struct Pte
{
  //array<option<ref<Page>> will map 1M of memory
  Page  *pages[PTEPERTAB];  /* Page map for this chunk of pte */

  //to avoid iterate over all pages
  // ref<ref<Page>> in Pte.pages
  Page  **first;    /* First used entry */
  // ref<ref<Page>> in Pte.pages
  Page  **last;     /* Last used entry */
};



// a KImage is essentially a channel to a text file (an image of a binary)
// the image in memory for a portion of a given file.
// (renamed KImage to avoid name conflict with memdraw Image (picture) and avoid
//  ugly #define Image IMAGE each time one wants to use draw.h from a device driver)
struct KImage
{
  Chan  *c;     /* channel to text file */
  Qid   qid;      /* Qid for page cache coherence */
  Qid mqid;
  Chan  *mchan;
  ushort  type;     /* Device type of owning channel */

  bool  notext;     /* no file associated */

  // extra
  Ref;
  // list<ref<Kimage>> of Imagealloc.free?
  KImage  *next; /* Free list */ 
  // hash<?, list<ref<Kimage>>> Imagealloc.hash?
  KImage  *hash; /* Qid hash chains */ 
  // option<ref<Segment>>?
  Segment *s;     /* TEXT segment for image if running */
};



/* Segment types */
enum segtype
{
  SG_TYPE   = 07,   /* Mask type of segment */
  SG_TEXT   = 00,
  SG_DATA   = 01,
  SG_BSS    = 02,
  SG_STACK  = 03,
  SG_SHARED = 04,
  SG_PHYSICAL = 05,

  SG_RONLY  = 0040,   /* Segment is read only */
  SG_CEXEC  = 0100,   /* Detach at exec */
};

#define PG_ONSWAP 1
#define onswap(s) (((ulong)s)&PG_ONSWAP)
#define pagedout(s) (((ulong)s)==0 || onswap(s))
#define swapaddr(s) (((ulong)s)&~PG_ONSWAP)

#define SEGMAXSIZE  (SEGMAPSIZE*PTEMAPMEM)

struct Physseg
{
  ulong attr;     /* Segment attributes */
  char  *name;      /* Attach name */
  ulong pa;     /* Physical address */
  ulong size;     /* Maximum segment size in pages */
  Page  *(*pgalloc)(Segment*, ulong); /* Allocation if we need it */
  void  (*pgfree)(Page*);
};


// often used as (q->top-q->base)>>LRESPROF
enum
{
  LRESPROF  = 3,
};

// smalloc'ed by newseg()
struct Segment
{
  // enum<segtype>
  ushort  type;   /* segment type */

  virt_addr base;   /* virtual base */
  virt_addr top;    /* virtual top */
  ulong size;   /* size in pages */ // top - base / BY2PG?

  // Kind of a page directory table (and pte = page table)
  // can be SEGMAPSIZE max so 1984 * 1M via PTE =~ 2Go virtual mem per segment!
  // array<option<ref<Pte>>>, smalloc'ed, point to ssegmap if small enough
  Pte **map; 
  // small seg map, used instead of map if segment small enough
  // array<ref<Pte>>
  Pte *ssegmap[SSEGMAPSIZE]; // 16
  int mapsize; // nelem(map)

  KImage  *image;   /* text in file attached to this segment */
  ulong fstart;   /* start address in file for demand load */
  ulong flen;   /* length of segment in file */

  bool flushme;  /* maintain icache for this segment */
  Physseg *pseg;
  ulong*  profile;  /* Tick profile area */
  ulong mark;   /* portcountrefs */
  ushort  steal;    /* Page stealer lock */

  // extra
  Ref;
  QLock lk;
  Lock  semalock;
  Sema  sema;
};


//*****************************************************************************
// Internal to memory/
//*****************************************************************************

// See also RMap in 386/

// actually internal to xalloc.c, but important so here
enum
{
  Nhole   = 128,
  Magichole = 0x484F4C45,     /* HOLE */
};

struct Hole
{
  ulong addr; // phys_addr? base?
  ulong top; // phys_addr?
  ulong size; // top - addr?
  
  // extra
  Hole* link; // list<ref<Hole>> of Xalloc.flist or Xalloc.table?
};

// What is the connection with Hole? a used Hole will describe
// a portion of memory, and at this memory there will be a header
// and then just after the actual memory xalloc'ed by someone
struct Xhdr
{
  // bookkeeping area
  ulong size;
  ulong magix;

  char  data[]; // memory pointer returned by xalloc
};

// Long lived data structure allocator (singleton)
// (can call xalloc() only Nhole time!)
struct Xalloc
{
  // array<Hole>
  Hole  hole[Nhole];

  // list<ref<Hole>> (next = Hole.link) free list?
  Hole* flist; 
  // list<ref<Hole>> (next = Hole.link) used list?
  Hole* table; 

  // extra
  Lock;
};
//IMPORTANT: static Xalloc xlists; // private to xalloc.c


// from pool.h
//struct Pool {
//  char* name;
//  ulong maxsize;
//
//  ulong cursize;
//  ulong curfree;
//  ulong curalloc;
//
//  ulong minarena; /* smallest size of new arena */
//  ulong quantum;  /* allocated blocks should be multiple of */
//  ulong minblock; /* smallest newly allocated block */
//
//  void* freeroot; /* actually Free* */
//  void* arenalist;  /* actually Arena* */
//
//  void* (*alloc)(ulong);
//  int (*merge)(void*, void*);
//  void  (*move)(void* from, void* to);
//
//  int flags;
//  int nfree;
//  int lastcompact;
//
//  void  (*lock)(Pool*);
//  void  (*unlock)(Pool*);
//  void  (*print)(Pool*, char*, ...);
//  void  (*panic)(Pool*, char*, ...);
//  void  (*logstack)(Pool*);
//
//  void* private;
//};

// exported by libc include/pool.h, used by malloc, defined in pool.c in this dir
// memory pools for malloc()/free() (using xalloc pools)
//IMPORTANT: extern Pool*  mainmem;
// memory pools for ??
//IMPORTANT: extern Pool*  imagmem;


// memory banks, similar to RMap, and Confmem, but page oriented, and portable
struct Pallocmem
{
  phys_addr base;
  ulong npage;
};

enum
{
  PGHLOG  = 9, // 2^9 = 512
  PGHSIZE = 1<<PGHLOG,  /* Page hash for image lookup */
};
#define pghash(daddr) palloc.hash[(daddr>>PGSHIFT)&(PGHSIZE-1)]

// Page Allocator (singleton)
struct Palloc
{
  Pallocmem mem[4]; // TODO: 4 ?? same as Conf.mem
  // sum of mem.npage (which should be conf.upages)
  ulong user;     /* how many user pages */

  // array<Page>, xalloc'ed in pageinit() (huge)
  Page  *pages; /* array of all pages */ 

  // list<ref<Page>> (next = Page.next)
  Page  *head;      /* most recently used */
  // list<ref<Page>> (next = prev?)
  Page  *tail;      /* least recently used */
  ulong freecount;    /* how many pages on free list now */

  // hash<?pghash(Page.daddr?), list<ref<Page>> (next = Page.hash)>
  Page  *hash[PGHSIZE];
  Lock  hashlock;

  // extra
  Lock;
  Rendez  r;      /* Sleep for free mem */
  QLock pwait;      /* Queue of procs waiting for memory */
};
extern  Palloc  palloc;


#define NFREECHAN 64
#define IHASHSIZE 64
// actually internal to page.c, but important so here
#define ihash(s)  imagealloc.hash[s%IHASHSIZE]

// Image allocator (internal to segment.c, but important so here, singleton)
struct Imagealloc
{
  // array<Kimage>?  xalloc'ed in initseg() (conf.nimage)
  KImage  *free; 
  // hash<?ihash(??), list<ref<Kimage>>
  KImage  *hash[IHASHSIZE];
  QLock ireclaim; /* mutex on reclaiming free images */

  Chan  **freechan; /* free image channels */
  int nfreechan;  /* number of free channels */
  int szfreechan; /* size of freechan array */
  QLock fcreclaim;  /* mutex on reclaiming free channels */

  // extra
  Lock;

};
//IMPORTANT: static struct Imagealloc imagealloc; (segment.c)
// so have conf.nimage + 1 Kimages
extern  KImage  swapimage;


// Swap allocator (singleton)
struct Swapalloc
{
  int free;     /* currently free swap pages */
  uchar*  swmap;      /* Base of swap map in memory */
  uchar*  alloc;      /* Round robin allocator */
  uchar*  last;     /* Speed swap allocation */
  uchar*  top;      /* Top of swap map */
  Rendez  r;      /* Pager kproc idle sleep */
  ulong highwater;    /* Pager start threshold */
  ulong headroom;   /* Space pager frees under highwater */

  //extra
  Lock;       /* Free map lock */
};
extern struct Swapalloc swapalloc;
@


\subsection*{[[memory/portfns_memory.h]]}

<<portfns_memory.h>>=

// xalloc.c
void*   xalloc(ulong);
void    xfree(void*);
void    xsummary(void);
int   xmerge(void*, void*);
void    xinit(void);
void*   xspanalloc(ulong, int, ulong);

// pool.c
// see include/pool.h: poollock(), ...
void    mallocsummary(void);

// alloc.c
void*   malloc(ulong);
void    free(void*);
void*   smalloc(ulong);
void*   mallocz(ulong, int);
void*   mallocalign(ulong, ulong, long, ulong);
void*   realloc(void *v, ulong size);
ulong   msize(void*);
void    setmalloctag(void*, ulong);
void    kstrcpy(char*, char*, int);
void    kstrdup(char**, char*);
//void    setrealloctag(void*, ulong);
//ulong   getmalloctag(void*);
//ulong   getrealloctag(void*);

// page.c
void    pageinit(void);
void    pagechainhead(Page*);
void    copypage(Page*, Page*); //TODO: why fp no-deps in codegraph?
void cachepage(Page *p, KImage *i);
void    uncachepage(Page*);
void    cachedel(KImage*, ulong);
Pte*    ptealloc(void);
Pte*    ptecpy(Pte*);
void    freepte(Segment*, Pte*);
ulong pagenumber(Page*);
Page*   lookpage(KImage*, ulong);
void    putpage(Page*);
Page*   auxpage(void);
Page*   newpage(int, Segment **, ulong);
int   duppage(Page*);
void checkpagerefs(void);
//void    portcountpagerefs(ulong*, int);
//int   ispages(void*);

// swap.c
void    swapinit(void);
void    putswap(Page*);
void    dupswap(Page*);
int   swapcount(ulong);
//int   swapfull(void);
void    pagersummary(void);
void    setswapchan(Chan*);
void    kickpager(void);

// fault.c
Segment*  seg(Proc*, ulong, int);
void checkpages(void);
void    validaddr(ulong, ulong, int);
int   okaddr(ulong, ulong, int);
int   fixfault(Segment*, ulong, int, int);
void*   vmemchr(void*, int, int);
int   fault(ulong, int);

// segment.c
Segment*  newseg(int, ulong, ulong);
void    relocateseg(Segment*, ulong);
void    segpage(Segment*, Page*);
void    putimage(KImage*);
void    mfreeseg(Segment*, ulong, int);
void    segclock(ulong);
void    putseg(Segment*);
Segment*  dupseg(Segment**, int, int);
long    ibrk(ulong, int);
int   addphysseg(Physseg*);
//int   isphysseg(char*);
ulong   segattach(Proc*, ulong, char *, ulong, ulong);
void    initseg(void);
KImage*   attachimage(int, Chan*, ulong, ulong);
//Segment*  isoverlap(Proc*, ulong, int);
Segment*  data2txt(Segment*);


// sysfile.c
// syssetflush (used in syscalls/ without requiring extern decl)

// in 386/mmu.c (but used in port)
KMap* kmap(Page*);
void  kunmap(KMap*);
void    countpagerefs(ulong*, int);
void    flushmmu(void);
void checkmmu(ulong va, ulong pa);
ulong cankaddr(ulong);
// actually KADDR is used in port, but it's expanding to kaddr
void* kaddr(ulong);
// actually PADDR is used in port, but it's expanding to paddr
ulong paddr(void*);
void    putmmu(ulong, ulong, Page*);
void    mmurelease(Proc*);
void    mmuswitch(Proc*);
@


\subsection*{[[memory/segment.c]]}

<<segment.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
#include "io.h"

//*****************************************************************************
// Global
//*****************************************************************************

static struct Imagealloc imagealloc;

//*****************************************************************************
// Misc
//*****************************************************************************

/*
 * Attachable segment types
 */
static Physseg physseg[10] = {
    { SG_SHARED,    "shared",   0,  SEGMAXSIZE, 0,  0 },
    { SG_BSS,   "memory",   0,  SEGMAXSIZE, 0,  0 },
    { 0,        0,      0,  0,      0,  0 },
};
static Lock physseglock;

Segment* (*_globalsegattach)(Proc*, char*);


static void imagereclaim(void);
static void imagechanreclaim(void);

//*****************************************************************************
// Initialization
//*****************************************************************************

void
initseg(void)
{
    KImage *i, *ie;

    imagealloc.free = xalloc(conf.nimage*sizeof(KImage));
    if (imagealloc.free == nil)
        panic("initseg: no memory");
    ie = &imagealloc.free[conf.nimage-1];
    for(i = imagealloc.free; i < ie; i++)
        i->next = i+1;
    i->next = 0;
    imagealloc.freechan = malloc(NFREECHAN * sizeof(Chan*));
    imagealloc.szfreechan = NFREECHAN;
}

//*****************************************************************************
// Functions
//*****************************************************************************

Segment *
newseg(int type, ulong base, ulong size)
{
    Segment *s;
    int mapsize;

    if(size > (SEGMAPSIZE*PTEPERTAB))
        error(Enovmem);

    s = smalloc(sizeof(Segment));
    s->ref = 1;
    s->type = type;
    s->base = base;
    s->top = base+(size*BY2PG);
    s->size = size;
    s->sema.prev = &s->sema;
    s->sema.next = &s->sema;

    mapsize = ROUND(size, PTEPERTAB)/PTEPERTAB;
    if(mapsize > nelem(s->ssegmap)){
        mapsize *= 2;
        if(mapsize > (SEGMAPSIZE*PTEPERTAB))
            mapsize = (SEGMAPSIZE*PTEPERTAB);
        s->map = smalloc(mapsize*sizeof(Pte*));
        s->mapsize = mapsize;
    }
    else{
        s->map = s->ssegmap;
        s->mapsize = nelem(s->ssegmap);
    }

    return s;
}

void
putseg(Segment *s)
{
    Pte **pp, **emap;
    KImage *i;

    if(s == 0)
        return;

    i = s->image;
    if(i != 0) {
        lock(i);
        lock(s);
        if(i->s == s && s->ref == 1)
            i->s = 0;
        unlock(i);
    }
    else
        lock(s);

    s->ref--;
    if(s->ref != 0) {
        unlock(s);
        return;
    }
    unlock(s);

    qlock(&s->lk);
    if(i)
        putimage(i);

    emap = &s->map[s->mapsize];
    for(pp = s->map; pp < emap; pp++)
        if(*pp)
            freepte(s, *pp);

    qunlock(&s->lk);
    if(s->map != s->ssegmap)
        free(s->map);
    if(s->profile != 0)
        free(s->profile);
    free(s);
}

void
relocateseg(Segment *s, ulong offset)
{
    Page **pg, *x;
    Pte *pte, **p, **endpte;

    endpte = &s->map[s->mapsize];
    for(p = s->map; p < endpte; p++) {
        if(*p == 0)
            continue;
        pte = *p;
        for(pg = pte->first; pg <= pte->last; pg++) {
            if(x = *pg)
                x->va += offset;
        }
    }
}

Segment*
dupseg(Segment **seg, int segno, int share)
{
    int i, size;
    Pte *pte;
    Segment *n, *s;

    SET(n);
    s = seg[segno];

    qlock(&s->lk);
    if(waserror()){
        qunlock(&s->lk);
        nexterror();
    }
    switch(s->type&SG_TYPE) {
    case SG_TEXT:       /* New segment shares pte set */
    case SG_SHARED:
    case SG_PHYSICAL:
        goto sameseg;

    case SG_STACK:
        n = newseg(s->type, s->base, s->size);
        break;

    case SG_BSS:        /* Just copy on write */
        if(share)
            goto sameseg;
        n = newseg(s->type, s->base, s->size);
        break;

    case SG_DATA:       /* Copy on write plus demand load info */
        if(segno == TSEG){
            poperror();
            qunlock(&s->lk);
            return data2txt(s);
        }

        if(share)
            goto sameseg;
        n = newseg(s->type, s->base, s->size);

        incref(s->image);
        n->image = s->image;
        n->fstart = s->fstart;
        n->flen = s->flen;
        break;
    }
    size = s->mapsize;
    for(i = 0; i < size; i++)
        if(pte = s->map[i])
            n->map[i] = ptecpy(pte);

    n->flushme = s->flushme;
    if(s->ref > 1)
        procflushseg(s);
    poperror();
    qunlock(&s->lk);
    return n;

sameseg:
    incref(s);
    poperror();
    qunlock(&s->lk);
    return s;
}

void
segpage(Segment *s, Page *p)
{
    Pte **pte;
    ulong off;
    Page **pg;

    if(p->va < s->base || p->va >= s->top)
        panic("segpage");

    off = p->va - s->base;
    pte = &s->map[off/PTEMAPMEM];
    if(*pte == 0)
        *pte = ptealloc();

    pg = &(*pte)->pages[(off&(PTEMAPMEM-1))/BY2PG];
    *pg = p;
    if(pg < (*pte)->first)
        (*pte)->first = pg;
    if(pg > (*pte)->last)
        (*pte)->last = pg;
}

KImage*
attachimage(int type, Chan *c, ulong base, ulong len)
{
    KImage *i, **l;

    /* reclaim any free channels from reclaimed segments */
    if(imagealloc.nfreechan)
        imagechanreclaim();

    lock(&imagealloc);

    /*
     * Search the image cache for remains of the text from a previous
     * or currently running incarnation
     */
    for(i = ihash(c->qid.path); i; i = i->hash) {
        if(c->qid.path == i->qid.path) {
            lock(i);
            if(eqqid(c->qid, i->qid) &&
               eqqid(c->mqid, i->mqid) &&
               c->mchan == i->mchan &&
               c->type == i->type) {
                goto found;
            }
            unlock(i);
        }
    }

    /*
     * imagereclaim dumps pages from the free list which are cached by image
     * structures. This should free some image structures.
     */
    while(!(i = imagealloc.free)) {
        unlock(&imagealloc);
        imagereclaim();
        sched();
        lock(&imagealloc);
    }

    imagealloc.free = i->next;

    lock(i);
    incref(c);
    i->c = c;
    i->type = c->type;
    i->qid = c->qid;
    i->mqid = c->mqid;
    i->mchan = c->mchan;
    l = &ihash(c->qid.path);
    i->hash = *l;
    *l = i;
found:
    unlock(&imagealloc);

    if(i->s == 0) {
        /* Disaster after commit in exec */
        if(waserror()) {
            unlock(i);
            pexit(Enovmem, 1);
        }
        i->s = newseg(type, base, len);
        i->s->image = i;
        i->ref++;
        poperror();
    }
    else
        incref(i->s);

    return i;
}

struct Irstats {
    int calls;          /* times imagereclaim was called */
    int loops;          /* times the main loop was run */
    uvlong  ticks;          /* total time in the main loop */
    uvlong  maxt;           /* longest time in main loop */
};
static struct Irstats  irstats;

static void
imagereclaim(void)
{
    int n;
    Page *p;
    uvlong ticks;

    irstats.calls++;
    /* Somebody is already cleaning the page cache */
    if(!canqlock(&imagealloc.ireclaim))
        return;

    lock(&palloc);
    ticks = fastticks(nil);
    n = 0;
    /*
     * All the pages with images backing them are at the
     * end of the list (see putpage) so start there and work
     * backward.
     */
    for(p = palloc.tail; p && p->image && n<1000; p = p->prev) {
        if(p->ref == 0 && canlock(p)) {
            if(p->ref == 0) {
                n++;
                uncachepage(p);
            }
            unlock(p);
        }
    }
    ticks = fastticks(nil) - ticks;
    unlock(&palloc);
    irstats.loops++;
    irstats.ticks += ticks;
    if(ticks > irstats.maxt)
        irstats.maxt = ticks;
    //print("T%llud+", ticks);
    qunlock(&imagealloc.ireclaim);
}

/*
 *  since close can block, this has to be called outside of
 *  spin locks.
 */
static void
imagechanreclaim(void)
{
    Chan *c;

    /* Somebody is already cleaning the image chans */
    if(!canqlock(&imagealloc.fcreclaim))
        return;

    /*
     * We don't have to recheck that nfreechan > 0 after we
     * acquire the lock, because we're the only ones who decrement 
     * it (the other lock contender increments it), and there's only
     * one of us thanks to the qlock above.
     */
    while(imagealloc.nfreechan > 0){
        lock(&imagealloc);
        imagealloc.nfreechan--;
        c = imagealloc.freechan[imagealloc.nfreechan];
        unlock(&imagealloc);
        cclose(c);
    }

    qunlock(&imagealloc.fcreclaim);
}

void
putimage(KImage *i)
{
    Chan *c, **cp;
    KImage *f, **l;

    if(i->notext)
        return;

    lock(i);
    if(--i->ref == 0) {
        l = &ihash(i->qid.path);
        mkqid(&i->qid, ~0, ~0, QTFILE);
        unlock(i);
        c = i->c;

        lock(&imagealloc);
        for(f = *l; f; f = f->hash) {
            if(f == i) {
                *l = i->hash;
                break;
            }
            l = &f->hash;
        }

        i->next = imagealloc.free;
        imagealloc.free = i;

        /* defer freeing channel till we're out of spin lock's */
        if(imagealloc.nfreechan == imagealloc.szfreechan){
            imagealloc.szfreechan += NFREECHAN;
            cp = malloc(imagealloc.szfreechan*sizeof(Chan*));
            if(cp == nil)
                panic("putimage");
            memmove(cp, imagealloc.freechan, imagealloc.nfreechan*sizeof(Chan*));
            free(imagealloc.freechan);
            imagealloc.freechan = cp;
        }
        imagealloc.freechan[imagealloc.nfreechan++] = c;
        unlock(&imagealloc);

        return;
    }
    unlock(i);
}

long
ibrk(ulong addr, int seg)
{
    Segment *s, *ns;
    ulong newtop, newsize;
    int i, mapsize;
    Pte **map;

    s = up->seg[seg];
    if(s == 0)
        error(Ebadarg);

    if(addr == 0)
        return s->base;

    qlock(&s->lk);

    /* We may start with the bss overlapping the data */
    if(addr < s->base) {
        if(seg != BSEG || up->seg[DSEG] == 0 || addr < up->seg[DSEG]->base) {
            qunlock(&s->lk);
            error(Enovmem);
        }
        addr = s->base;
    }

    newtop = PGROUND(addr);
    newsize = (newtop-s->base)/BY2PG;
    if(newtop < s->top) {
        /*
         * do not shrink a segment shared with other procs, as the
         * to-be-freed address space may have been passed to the kernel
         * already by another proc and is past the validaddr stage.
         */
        if(s->ref > 1){
            qunlock(&s->lk);
            error(Einuse);
        }
        mfreeseg(s, newtop, (s->top-newtop)/BY2PG);
        s->top = newtop;
        s->size = newsize;
        qunlock(&s->lk);
        flushmmu();
        return 0;
    }

    for(i = 0; i < NSEG; i++) {
        ns = up->seg[i];
        if(ns == 0 || ns == s)
            continue;
        if(newtop >= ns->base && newtop < ns->top) {
            qunlock(&s->lk);
            error(Esoverlap);
        }
    }

    if(newsize > (SEGMAPSIZE*PTEPERTAB)) {
        qunlock(&s->lk);
        error(Enovmem);
    }
    mapsize = ROUND(newsize, PTEPERTAB)/PTEPERTAB;
    if(mapsize > s->mapsize){
        map = smalloc(mapsize*sizeof(Pte*));
        memmove(map, s->map, s->mapsize*sizeof(Pte*));
        if(s->map != s->ssegmap)
            free(s->map);
        s->map = map;
        s->mapsize = mapsize;
    }

    s->top = newtop;
    s->size = newsize;
    qunlock(&s->lk);
    return 0;
}

/*
 *  called with s->lk locked
 */
void
mfreeseg(Segment *s, ulong start, int pages)
{
    int i, j, size;
    ulong soff;
    Page *pg;
    Page *list;

    soff = start-s->base;
    j = (soff&(PTEMAPMEM-1))/BY2PG;

    size = s->mapsize;
    list = nil;
    for(i = soff/PTEMAPMEM; i < size; i++) {
        if(pages <= 0)
            break;
        if(s->map[i] == 0) {
            pages -= PTEPERTAB-j;
            j = 0;
            continue;
        }
        while(j < PTEPERTAB) {
            pg = s->map[i]->pages[j];
            /*
             * We want to zero s->map[i]->page[j] and putpage(pg),
             * but we have to make sure other processors flush the
             * entry from their TLBs before the page is freed.
             * We construct a list of the pages to be freed, zero
             * the entries, then (below) call procflushseg, and call
             * putpage on the whole list.
             *
             * Swapped-out pages don't appear in TLBs, so it's okay
             * to putswap those pages before procflushseg.
             */
            if(pg){
                if(onswap(pg))
                    putswap(pg);
                else{
                    pg->next = list;
                    list = pg;
                }
                s->map[i]->pages[j] = 0;
            }
            if(--pages == 0)
                goto out;
            j++;
        }
        j = 0;
    }
out:
    /* flush this seg in all other processes */
    if(s->ref > 1)
        procflushseg(s);

    /* free the pages */
    for(pg = list; pg != nil; pg = list){
        list = list->next;
        putpage(pg);
    }
}

Segment*
isoverlap(Proc *p, ulong va, int len)
{
    int i;
    Segment *ns;
    ulong newtop;

    newtop = va+len;
    for(i = 0; i < NSEG; i++) {
        ns = p->seg[i];
        if(ns == 0)
            continue;
        if((newtop > ns->base && newtop <= ns->top) ||
           (va >= ns->base && va < ns->top))
            return ns;
    }
    return nil;
}

int
addphysseg(Physseg* new)
{
    Physseg *ps;

    /*
     * Check not already entered and there is room
     * for a new entry and the terminating null entry.
     */
    lock(&physseglock);
    for(ps = physseg; ps->name; ps++){
        if(strcmp(ps->name, new->name) == 0){
            unlock(&physseglock);
            return -1;
        }
    }
    if(ps-physseg >= nelem(physseg)-2){
        unlock(&physseglock);
        return -1;
    }

    *ps = *new;
    unlock(&physseglock);

    return 0;
}

//unused
//int
//isphysseg(char *name)
//{
//  Physseg *ps;
//  int rv = 0;
//
//  lock(&physseglock);
//  for(ps = physseg; ps->name; ps++){
//      if(strcmp(ps->name, name) == 0){
//          rv = 1;
//          break;
//      }
//  }
//  unlock(&physseglock);
//  return rv;
//}

ulong
segattach(Proc *p, ulong attr, char *name, ulong va, ulong len)
{
    int sno;
    Segment *s, *os;
    Physseg *ps;

    if(va != 0 && va >= USTKTOP)
        error(Ebadarg);

    validaddr((ulong)name, 1, 0);
    vmemchr(name, 0, ~0);

    for(sno = 0; sno < NSEG; sno++)
        if(p->seg[sno] == nil && sno != ESEG)
            break;

    if(sno == NSEG)
        error(Enovmem);

    /*
     *  first look for a global segment with the
     *  same name
     */
    if(_globalsegattach != nil){
        s = (*_globalsegattach)(p, name);
        if(s != nil){
            p->seg[sno] = s;
            return s->base;
        }
    }

    len = PGROUND(len);
    if(len == 0)
        error(Ebadarg);

    /*
     * Find a hole in the address space.
     * Starting at the lowest possible stack address - len,
     * check for an overlapping segment, and repeat at the
     * base of that segment - len until either a hole is found
     * or the address space is exhausted.  Ensure that we don't
     * map the zero page.
     */
    if(va == 0) {
        for (os = p->seg[SSEG]; os != nil; os = isoverlap(p, va, len)) {
            va = os->base;
            if(len >= va)
                error(Enovmem);
            va -= len;
        }
        va &= ~(BY2PG-1);
    } else {
        va &= ~(BY2PG-1);
        if(va == 0 || va >= USTKTOP)
            error(Ebadarg);
    }

    if(isoverlap(p, va, len) != nil)
        error(Esoverlap);

    for(ps = physseg; ps->name; ps++)
        if(strcmp(name, ps->name) == 0)
            goto found;

    error(Ebadarg);
found:
    if(len > ps->size)
        error(Enovmem);

    attr &= ~SG_TYPE;       /* Turn off what is not allowed */
    attr |= ps->attr;       /* Copy in defaults */

    s = newseg(attr, va, len/BY2PG);
    s->pseg = ps;
    p->seg[sno] = s;

    return va;
}


void
segclock(ulong pc)
{
    Segment *s;

    s = up->seg[TSEG];
    if(s == 0 || s->profile == 0)
        return;

    s->profile[0] += TK2MS(1);
    if(pc >= s->base && pc < s->top) {
        pc -= s->base;
        s->profile[pc>>LRESPROF] += TK2MS(1);
    }
}

// was in another file before
Segment*
data2txt(Segment *s)
{
    Segment *ps;

    ps = newseg(SG_TEXT, s->base, s->size);
    ps->image = s->image;
    incref(ps->image);
    ps->fstart = s->fstart;
    ps->flen = s->flen;
    ps->flushme = true;

    return ps;
}
@


\subsection*{[[memory/swap.c]]}

<<swap.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

static int  canflush(Proc*, Segment*);
static void executeio(void);
static int  needpages(void*);
static void pageout(Proc*, Segment*);
static void pagepte(int, Page**);
static void pager(void*);


//static    int swopen;
static  Page    **iolist;
static  int ioptr;

static  ulong   genage, genclock, gencount;
static  uvlong  gensum;

static void
gentick(void)
{
    genclock++;
    if(gencount)
        genage = gensum / gencount;
    else
        genage = 0;
    gensum = gencount = 0;
}

void
swapinit(void)
{
    swapalloc.swmap = xalloc(conf.nswap);
    swapalloc.top = &swapalloc.swmap[conf.nswap];
    swapalloc.alloc = swapalloc.swmap;
    swapalloc.last = swapalloc.swmap;
    swapalloc.free = conf.nswap;
    iolist = xalloc(conf.nswppo*sizeof(Page*));
    if(swapalloc.swmap == 0 || iolist == 0)
        panic("swapinit: not enough memory");

    swapimage.notext = 1;
}

ulong
newswap(void)
{
    uchar *look;

    lock(&swapalloc);

    if(swapalloc.free == 0){
        unlock(&swapalloc);
        return ~0;
    }

    look = memchr(swapalloc.last, 0, swapalloc.top-swapalloc.last);
    if(look == 0)
        panic("inconsistent swap");

    *look = 1;
    swapalloc.last = look;
    swapalloc.free--;
    unlock(&swapalloc);
    return (look-swapalloc.swmap) * BY2PG;
}

void
putswap(Page *p)
{
    uchar *idx;

    lock(&swapalloc);
    idx = &swapalloc.swmap[((ulong)p)/BY2PG];
    if(--(*idx) == 0) {
        swapalloc.free++;
        if(idx < swapalloc.last)
            swapalloc.last = idx;
    }
    if(*idx >= 254)
        panic("putswap %#p == %ud", p, *idx);
    unlock(&swapalloc);
}

void
dupswap(Page *p)
{
    lock(&swapalloc);
    if(++swapalloc.swmap[((ulong)p)/BY2PG] == 0)
        panic("dupswap");
    unlock(&swapalloc);
}

int
swapcount(ulong daddr)
{
    return swapalloc.swmap[daddr/BY2PG];
}

void
kickpager(void)
{
    static int started;

    if(started)
        wakeup(&swapalloc.r);
    else {
        kproc("pager", pager, 0);
        started = 1;
    }
}

static void
pager(void *junk)
{
    int i;
    Segment *s;
    Proc *p, *ep;

    if(waserror())
        panic("pager: os error");

    p = proctab(0);
    ep = &p[conf.nproc];

loop:
    up->psstate = "Idle";
    wakeup(&palloc.r);
    sleep(&swapalloc.r, needpages, 0);

    while(needpages(junk)) {
        if(swapimage.c) {
            p++;
            if(p >= ep){
                p = proctab(0);
                gentick();          
            }

            if(p->state == Dead || p->noswap)
                continue;

            if(!canqlock(&p->seglock))
                continue;       /* process changing its segments */

            for(i = 0; i < NSEG; i++) {
                if(!needpages(junk)){
                    qunlock(&p->seglock);
                    goto loop;
                }

                if(s = p->seg[i]) {
                    switch(s->type&SG_TYPE) {
                    default:
                        break;
                    case SG_TEXT:
                        pageout(p, s);
                        break;
                    case SG_DATA:
                    case SG_BSS:
                    case SG_STACK:
                    case SG_SHARED:
                        up->psstate = "Pageout";
                        pageout(p, s);
                        if(ioptr != 0) {
                            up->psstate = "I/O";
                            executeio();
                        }
                        break;
                    }
                }
            }
            qunlock(&p->seglock);
        } else {
            print("out of memory\n");
            killbig("out of memory");
            freebroken();       /* can use the memory */

            /* Emulate the old system if no swap channel */
            if(!swapimage.c)
                tsleep(&up->sleep, return0, 0, 5000);
        }
    }
    goto loop;
}

static void
pageout(Proc *p, Segment *s)
{
    int type, i, size;
    ulong age;
    Pte *l;
    Page **pg, *entry;

    if(!canqlock(&s->lk))   /* We cannot afford to wait, we will surely deadlock */
        return;

    if(s->steal) {      /* Protected by /dev/proc */
        qunlock(&s->lk);
        return;
    }

    if(!canflush(p, s)) {   /* Able to invalidate all tlbs with references */
        qunlock(&s->lk);
        putseg(s);
        return;
    }

    if(waserror()) {
        qunlock(&s->lk);
        putseg(s);
        return;
    }

    /* Pass through the pte tables looking for memory pages to swap out */
    type = s->type&SG_TYPE;
    size = s->mapsize;
    for(i = 0; i < size; i++) {
        l = s->map[i];
        if(l == 0)
            continue;
        for(pg = l->first; pg < l->last; pg++) {
            entry = *pg;
            if(pagedout(entry))
                continue;

            if(entry->modref & PG_REF) {
                entry->modref &= ~PG_REF;
                entry->gen = genclock;
            }

            if(genclock < entry->gen)
                age = ~(entry->gen - genclock);
            else
                age = genclock - entry->gen;
            gensum += age;
            gencount++;
            if(age <= genage)
                continue;

            pagepte(type, pg);

            if(ioptr >= conf.nswppo)
                goto out;
        }
    }
out:
    poperror();
    qunlock(&s->lk);
    putseg(s);
}

static int
canflush(Proc *p, Segment *s)
{
    int i;
    Proc *ep;

    lock(s);
    if(s->ref == 1) {       /* Easy if we are the only user */
        s->ref++;
        unlock(s);
        return canpage(p);
    }
    s->ref++;
    unlock(s);

    /* Now we must do hardwork to ensure all processes which have tlb
     * entries for this segment will be flushed if we succeed in paging it out
     */
    p = proctab(0);
    ep = &p[conf.nproc];
    while(p < ep) {
        if(p->state != Dead) {
            for(i = 0; i < NSEG; i++)
                if(p->seg[i] == s)
                    if(!canpage(p))
                        return 0;
        }
        p++;
    }
    return 1;
}

static void
pagepte(int type, Page **pg)
{
    ulong daddr;
    Page *outp;

    outp = *pg;
    switch(type) {
    case SG_TEXT:               /* Revert to demand load */
        putpage(outp);
        *pg = 0;
        break;

    case SG_DATA:
    case SG_BSS:
    case SG_STACK:
    case SG_SHARED:
        /*
         *  get a new swap address and clear any pages
         *  referring to it from the cache
         */
        daddr = newswap();
        if(daddr == ~0)
            break;
        cachedel(&swapimage, daddr);

        lock(outp);

        /* forget anything that it used to cache */
        uncachepage(outp);

        /*
         *  incr the reference count to make sure it sticks around while
         *  being written
         */
        outp->ref++;

        /*
         *  enter it into the cache so that a fault happening
         *  during the write will grab the page from the cache
         *  rather than one partially written to the disk
         */
        outp->daddr = daddr;
        cachepage(outp, &swapimage);
        *pg = (Page*)(daddr|PG_ONSWAP);
        unlock(outp);

        /* Add page to IO transaction list */
        iolist[ioptr++] = outp;
        break;
    }
}

void
pagersummary(void)
{
    print("%lud/%lud memory %lud/%lud swap %d iolist\n",
        palloc.user-palloc.freecount,
        palloc.user, conf.nswap-swapalloc.free, conf.nswap,
        ioptr);
}

static int
pageiocomp(void *a, void *b)
{
    Page *p1, *p2;

    p1 = *(Page **)a;
    p2 = *(Page **)b;
    if(p1->daddr > p2->daddr)
        return 1;
    else
        return -1;
}

static void
executeio(void)
{
    Page *out;
    int i, n;
    Chan *c;
    char *kaddr;
    KMap *k;

    c = swapimage.c;
    qsort(iolist, ioptr, sizeof iolist[0], pageiocomp);
    for(i = 0; i < ioptr; i++) {
        if(ioptr > conf.nswppo)
            panic("executeio: ioptr %d > %d", ioptr, conf.nswppo);
        out = iolist[i];
        k = kmap(out);
        kaddr = (char*)VA(k);

        if(waserror())
            panic("executeio: page out I/O error");

        n = devtab[c->type]->write(c, kaddr, BY2PG, out->daddr);
        if(n != BY2PG)
            nexterror();

        kunmap(k);
        poperror();

        /* Free up the page after I/O */
        lock(out);
        out->ref--;
        unlock(out);
        putpage(out);
    }
    ioptr = 0;
}

static int
needpages(void*)
{
    return palloc.freecount < swapalloc.headroom;
}

void
setswapchan(Chan *c)
{
    uchar dirbuf[sizeof(Dir)+100];
    Dir d;
    int n;

    if(swapimage.c) {
        if(swapalloc.free != conf.nswap){
            cclose(c);
            error(Einuse);
        }
        cclose(swapimage.c);
    }

    /*
     *  if this isn't a file, set the swap space
     *  to be at most the size of the partition
     */
    if(devtab[c->type]->dc != L'M'){
        n = devtab[c->type]->stat(c, dirbuf, sizeof dirbuf);
        if(n <= 0){
            cclose(c);
            error("stat failed in setswapchan");
        }
        convM2D(dirbuf, n, &d, nil);
        if(d.length < conf.nswap*BY2PG){
            conf.nswap = d.length/BY2PG;
            swapalloc.top = &swapalloc.swmap[conf.nswap];
            swapalloc.free = conf.nswap;
        }
    }

    swapimage.c = c;
}

//unused
//int
//swapfull(void)
//{
//  return swapalloc.free < conf.nswap/10;
//}
@


\subsection*{[[memory/sysmemory.c]]}

<<sysmemory.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// see also sysbrk_ in sysproc.c

// used to be in segment.c

void
pteflush(Pte *pte, int s, int e)
{
    int i;
    Page *p;

    for(i = s; i < e; i++) {
        p = pte->pages[i];
        if(pagedout(p) == 0)
            memset(p->cachectl, PG_TXTFLUSH, sizeof(p->cachectl));
    }
}

long
syssegflush(ulong *arg)
{
    Segment *s;
    ulong addr, l;
    Pte *pte;
    int chunk, ps, pe, len;

    addr = arg[0];
    len = arg[1];

    while(len > 0) {
        s = seg(up, addr, 1);
        if(s == 0)
            error(Ebadarg);

        s->flushme = 1;
    more:
        l = len;
        if(addr+l > s->top)
            l = s->top - addr;

        ps = addr-s->base;
        pte = s->map[ps/PTEMAPMEM];
        ps &= PTEMAPMEM-1;
        pe = PTEMAPMEM;
        if(pe-ps > l){
            pe = ps + l;
            pe = (pe+BY2PG-1)&~(BY2PG-1);
        }
        if(pe == ps) {
            qunlock(&s->lk);
            error(Ebadarg);
        }

        if(pte)
            pteflush(pte, ps/BY2PG, pe/BY2PG);

        chunk = pe-ps;
        len -= chunk;
        addr += chunk;

        if(len > 0 && addr < s->top)
            goto more;

        qunlock(&s->lk);
    }
    flushmmu();
    return 0;
}
@


\subsection*{[[memory/xalloc.c]]}

<<xalloc.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

// Memory allocator for long lived allocated structures
// e.g. array or Proc (procalloc), array of Pages (palloc.pages), etc

// forward decl
void        xhole(ulong, ulong);

//*****************************************************************************
// The global
//*****************************************************************************

static Xalloc   xlists;

//*****************************************************************************
// Initialization
//*****************************************************************************

void
xinit(void)
{
    int i, n, upages, kpages;
    ulong maxpages;
    Confmem *m;
    Pallocmem *pm;
    Hole *h, *eh;

    eh = &xlists.hole[Nhole-1];
    for(h = xlists.hole; h < eh; h++)
        h->link = h+1;

    xlists.flist = xlists.hole;

    upages = conf.upages;
    kpages = conf.npage - upages;
    pm = palloc.mem;
    for(i=0; i<nelem(conf.mem); i++){
        m = &conf.mem[i];
        n = m->npage;
        if(n > kpages)
            n = kpages;
        /* don't try to use non-KADDR-able memory for kernel */
        maxpages = cankaddr(m->base)/BY2PG;
        if(n > maxpages)
            n = maxpages;
        /* first give to kernel */
        if(n > 0){
            m->kbase = (ulong)KADDR(m->base);
            m->klimit = (ulong)KADDR(m->base+n*BY2PG);
            xhole(m->base, n*BY2PG);
            kpages -= n;
        }
        /* if anything left over, give to user */
        if(n < m->npage){
            if(pm >= palloc.mem+nelem(palloc.mem)){
                print("xinit: losing %lud pages\n", m->npage-n);
                continue;
            }
            pm->base = m->base+n*BY2PG;
            pm->npage = m->npage - n;
            pm++;
        }
    }
//  xsummary();         /* call it from main if desired */
}

//*****************************************************************************
// Functions
//*****************************************************************************

void*
xspanalloc(ulong size, int align, ulong span)
{
    ulong a, v, t;
    a = (ulong)xalloc(size+align+span);
    if(a == 0)
        panic("xspanalloc: %lud %d %lux", size, align, span);

    if(span > 2) {
        v = (a + span) & ~(span-1);
        t = v - a;
        if(t > 0)
            xhole(PADDR(a), t);
        t = a + span - v;
        if(t > 0)
            xhole(PADDR(v+size+align), t);
    }
    else
        v = a;

    if(align > 1)
        v = (v + align) & ~(align-1);

    return (void*)v;
}

void*
xallocz(ulong size, bool zero)
{
    Xhdr *p;
    Hole *h, **l;

    /* add room for magix & size overhead, round up to nearest vlong */
    size += BY2V + offsetof(Xhdr, data[0]);
    size &= ~(BY2V-1);

    ilock(&xlists);
    l = &xlists.table;
    for(h = *l; h; h = h->link) {
        if(h->size >= size) {
            p = (Xhdr*)KADDR(h->addr);
            h->addr += size;
            h->size -= size;
            if(h->size == 0) {
                *l = h->link;
                h->link = xlists.flist;
                xlists.flist = h;
            }
            iunlock(&xlists);
            if(zero)
                memset(p, 0, size);
            p->magix = Magichole;
            p->size = size;
            return p->data;
        }
        l = &h->link;
    }
    iunlock(&xlists);
    return nil;
}

void*
xalloc(ulong size)
{
    return xallocz(size, true);
}

void
xfree(void *p)
{
    Xhdr *x;

    x = (Xhdr*)((ulong)p - offsetof(Xhdr, data[0]));
    if(x->magix != Magichole) {
        xsummary();
        panic("xfree(%#p) %#ux != %#lux", p, Magichole, x->magix);
    }
    xhole(PADDR((uintptr)x), x->size);
}

int
xmerge(void *vp, void *vq)
{
    Xhdr *p, *q;

    p = (Xhdr*)(((ulong)vp - offsetof(Xhdr, data[0])));
    q = (Xhdr*)(((ulong)vq - offsetof(Xhdr, data[0])));
    if(p->magix != Magichole || q->magix != Magichole) {
        int i;
        ulong *wd;
        void *badp;

        xsummary();
        badp = (p->magix != Magichole? p: q);
        wd = (ulong *)badp - 12;
        for (i = 24; i-- > 0; ) {
            print("%#p: %lux", wd, *wd);
            if (wd == badp)
                print(" <-");
            print("\n");
            wd++;
        }
        panic("xmerge(%#p, %#p) bad magic %#lux, %#lux",
            vp, vq, p->magix, q->magix);
    }
    if((uchar*)p+p->size == (uchar*)q) {
        p->size += q->size;
        return 1;
    }
    return 0;
}

void
xhole(ulong addr, ulong size)
{
    ulong top;
    Hole *h, *c, **l;

    if(size == 0)
        return;

    top = addr + size;
    ilock(&xlists);
    l = &xlists.table;
    for(h = *l; h; h = h->link) {
        if(h->top == addr) {
            h->size += size;
            h->top = h->addr+h->size;
            c = h->link;
            if(c && h->top == c->addr) {
                h->top += c->size;
                h->size += c->size;
                h->link = c->link;
                c->link = xlists.flist;
                xlists.flist = c;
            }
            iunlock(&xlists);
            return;
        }
        if(h->addr > addr)
            break;
        l = &h->link;
    }
    if(h && top == h->addr) {
        h->addr -= size;
        h->size += size;
        iunlock(&xlists);
        return;
    }

    if(xlists.flist == nil) {
        iunlock(&xlists);
        print("xfree: no free holes, leaked %lud bytes\n", size);
        return;
    }

    h = xlists.flist;
    xlists.flist = h->link;
    h->addr = addr;
    h->top = top;
    h->size = size;
    h->link = *l;
    *l = h;
    iunlock(&xlists);
}

//*****************************************************************************
// Debugging
//*****************************************************************************

void
xsummary(void)
{
    int i;
    Hole *h;

    i = 0;
    for(h = xlists.flist; h; h = h->link)
        i++;

    print("%d holes free", i);
    i = 0;
    for(h = xlists.table; h; h = h->link) {
        if (0) {
            print("addr %#.8lux top %#.8lux size %lud\n",
                h->addr, h->top, h->size);
            delay(10);
        }
        i += h->size;
        if (h == h->link) {
            print("xsummary: infinite loop broken\n");
            break;
        }
    }
    print(" %d bytes free\n", i);
}
@


\section{[[misc/]]}

\subsection*{[[misc/parse.c]]}

<<parse.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

/*
 * Generous estimate of number of fields, including terminal nil pointer
 */
static int
ncmdfield(char *p, int n)
{
    int white, nwhite;
    char *ep;
    int nf;

    if(p == nil)
        return 1;

    nf = 0;
    ep = p+n;
    white = 1;  /* first text will start field */
    while(p < ep){
        nwhite = (strchr(" \t\r\n", *p++ & 0xFF) != 0); /* UTF is irrelevant */
        if(white && !nwhite)    /* beginning of field */
            nf++;
        white = nwhite;
    }
    return nf+1;    /* +1 for nil */
}

/*
 *  parse a command written to a device
 */
Cmdbuf*
parsecmd(char *p, int n)
{
    Cmdbuf *volatile cb;
    int nf;
    char *sp;

    nf = ncmdfield(p, n);

    /* allocate Cmdbuf plus string pointers plus copy of string including \0 */
    sp = smalloc(sizeof(*cb) + nf * sizeof(char*) + n + 1);
    cb = (Cmdbuf*)sp;
    cb->f = (char**)(&cb[1]);
    cb->buf = (char*)(&cb->f[nf]);

    if(up!=nil && waserror()){
        free(cb);
        nexterror();
    }
    memmove(cb->buf, p, n);
    if(up != nil)
        poperror();

    /* dump new line and null terminate */
    if(n > 0 && cb->buf[n-1] == '\n')
        n--;
    cb->buf[n] = '\0';

    cb->nf = tokenize(cb->buf, cb->f, nf-1);
    cb->f[cb->nf] = nil;

    return cb;
}

/*
 * Reconstruct original message, for error diagnostic
 */
void
cmderror(Cmdbuf *cb, char *s)
{
    int i;
    char *p, *e;

    p = up->genbuf;
    e = p+ERRMAX-10;
    p = seprint(p, e, "%s \"", s);
    for(i=0; i<cb->nf; i++){
        if(i > 0)
            p = seprint(p, e, " ");
        p = seprint(p, e, "%q", cb->f[i]);
    }
    strcpy(p, "\"");
    error(up->genbuf);
}

/*
 * Look up entry in table
 */
Cmdtab*
lookupcmd(Cmdbuf *cb, Cmdtab *ctab, int nctab)
{
    int i;
    Cmdtab *ct;

    if(cb->nf == 0)
        error("empty control message");

    for(ct = ctab, i=0; i<nctab; i++, ct++){
        if(strcmp(ct->cmd, "*") !=0)    /* wildcard always matches */
        if(strcmp(ct->cmd, cb->f[0]) != 0)
            continue;
        if(ct->narg != 0 && ct->narg != cb->nf)
            cmderror(cb, Ecmdargs);
        return ct;
    }

    cmderror(cb, "unknown control message");
    return nil;
}
@


\subsection*{[[misc/portdat_misc.h]]}

<<portdat_misc.h>>=

struct Cmdbuf
{
  char  *buf;
  char  **f;
  int nf;
};

struct Cmdtab
{
  int index;  /* used by client to switch on result */
  char  *cmd; /* command name */
  int narg; /* expected #args; 0 ==> variadic */
};
@


\subsection*{[[misc/portfns_misc.h]]}

<<portfns_misc.h>>=

// cis.c
// pcmcisread in fns.h

// parse.c
void    cmderror(Cmdbuf*, char*);
Cmdbuf*   parsecmd(char *a, int n);
Cmdtab*   lookupcmd(Cmdbuf*, Cmdtab*, int);

// random.c
ulong   randomread(void*, ulong);
void    randominit(void);
@


\subsection*{[[misc/random.c]]}

<<random.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"


struct Rb
{
    QLock;
    Rendez  producer;
    Rendez  consumer;
    ulong   randomcount;
    uchar   buf[1024];
    uchar   *ep;
    uchar   *rp;
    uchar   *wp;
    uchar   next;
    uchar   wakeme;
    ushort  bits;
    ulong   randn;
} rb;

static int
rbnotfull(void*)
{
    int i;

    i = rb.rp - rb.wp;
    return i != 1 && i != (1 - sizeof(rb.buf));
}

static int
rbnotempty(void*)
{
    return rb.wp != rb.rp;
}

static void
genrandom(void*)
{
    up->basepri = PriNormal;
    up->priority = up->basepri;

    for(;;){
        for(;;)
            if(++rb.randomcount > 100000)
                break;
        if(anyhigher())
            sched();
        if(!rbnotfull(0))
            sleep(&rb.producer, rbnotfull, 0);
    }
}

/*
 *  produce random bits in a circular buffer
 */
static void
randomclock(void)
{
    if(rb.randomcount == 0 || !rbnotfull(0))
        return;

    rb.bits = (rb.bits<<2) ^ rb.randomcount;
    rb.randomcount = 0;

    rb.next++;
    if(rb.next != 8/2)
        return;
    rb.next = 0;

    *rb.wp ^= rb.bits;
    if(rb.wp+1 == rb.ep)
        rb.wp = rb.buf;
    else
        rb.wp = rb.wp+1;

    if(rb.wakeme)
        wakeup(&rb.consumer);
}

void
randominit(void)
{
    /* Frequency close but not equal to HZ */
    addclock0link(randomclock, 13);
    rb.ep = rb.buf + sizeof(rb.buf);
    rb.rp = rb.wp = rb.buf;
    kproc("genrandom", genrandom, 0);
}

/*
 *  consume random bytes from a circular buffer
 */
ulong
randomread(void *xp, ulong n)
{
    uchar *e, *p;
    ulong x;

    p = xp;

    if(waserror()){
        qunlock(&rb);
        nexterror();
    }

    qlock(&rb);
    for(e = p + n; p < e; ){
        if(rb.wp == rb.rp){
            rb.wakeme = 1;
            wakeup(&rb.producer);
            sleep(&rb.consumer, rbnotempty, 0);
            rb.wakeme = 0;
            continue;
        }

        /*
         *  beating clocks will be predictable if
         *  they are synchronized.  Use a cheap pseudo-
         *  random number generator to obscure any cycles.
         */
        x = rb.randn*1103515245 ^ *rb.rp;
        *p++ = rb.randn = x;

        if(rb.rp+1 == rb.ep)
            rb.rp = rb.buf;
        else
            rb.rp = rb.rp+1;
    }
    qunlock(&rb);
    poperror();

    wakeup(&rb.producer);

    return n;
}
@


\section{[[processes/]]}

\subsection*{[[processes/386/apic.c]]}

<<apic.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"

#include "mp.h"

enum {                  /* Local APIC registers */
    LapicID     = 0x0020,   /* ID */
    LapicVER    = 0x0030,   /* Version */
    LapicTPR    = 0x0080,   /* Task Priority */
    LapicAPR    = 0x0090,   /* Arbitration Priority */
    LapicPPR    = 0x00A0,   /* Processor Priority */
    LapicEOI    = 0x00B0,   /* EOI */
    LapicLDR    = 0x00D0,   /* Logical Destination */
    LapicDFR    = 0x00E0,   /* Destination Format */
    LapicSVR    = 0x00F0,   /* Spurious Interrupt Vector */
    LapicISR    = 0x0100,   /* Interrupt Status (8 registers) */
    LapicTMR    = 0x0180,   /* Trigger Mode (8 registers) */
    LapicIRR    = 0x0200,   /* Interrupt Request (8 registers) */
    LapicESR    = 0x0280,   /* Error Status */
    LapicICRLO  = 0x0300,   /* Interrupt Command */
    LapicICRHI  = 0x0310,   /* Interrupt Command [63:32] */
    LapicTIMER  = 0x0320,   /* Local Vector Table 0 (TIMER) */
    LapicPCINT  = 0x0340,   /* Performance Counter LVT */
    LapicLINT0  = 0x0350,   /* Local Vector Table 1 (LINT0) */
    LapicLINT1  = 0x0360,   /* Local Vector Table 2 (LINT1) */
    LapicERROR  = 0x0370,   /* Local Vector Table 3 (ERROR) */
    LapicTICR   = 0x0380,   /* Timer Initial Count */
    LapicTCCR   = 0x0390,   /* Timer Current Count */
    LapicTDCR   = 0x03E0,   /* Timer Divide Configuration */
};

enum {                  /* LapicSVR */
    LapicENABLE = 0x00000100,   /* Unit Enable */
    LapicFOCUS  = 0x00000200,   /* Focus Processor Checking Disable */
};

enum {                  /* LapicICRLO */
                    /* [14] IPI Trigger Mode Level (RW) */
    LapicDEASSERT   = 0x00000000,   /* Deassert level-sensitive interrupt */
    LapicASSERT = 0x00004000,   /* Assert level-sensitive interrupt */

                    /* [17:16] Remote Read Status */
    LapicINVALID    = 0x00000000,   /* Invalid */
    LapicWAIT   = 0x00010000,   /* In-Progress */
    LapicVALID  = 0x00020000,   /* Valid */

                    /* [19:18] Destination Shorthand */
    LapicFIELD  = 0x00000000,   /* No shorthand */
    LapicSELF   = 0x00040000,   /* Self is single destination */
    LapicALLINC = 0x00080000,   /* All including self */
    LapicALLEXC = 0x000C0000,   /* All Excluding self */
};

enum {                  /* LapicESR */
    LapicSENDCS = 0x00000001,   /* Send CS Error */
    LapicRCVCS  = 0x00000002,   /* Receive CS Error */
    LapicSENDACCEPT = 0x00000004,   /* Send Accept Error */
    LapicRCVACCEPT  = 0x00000008,   /* Receive Accept Error */
    LapicSENDVECTOR = 0x00000020,   /* Send Illegal Vector */
    LapicRCVVECTOR  = 0x00000040,   /* Receive Illegal Vector */
    LapicREGISTER   = 0x00000080,   /* Illegal Register Address */
};

enum {                  /* LapicTIMER */
                    /* [17] Timer Mode (RW) */
    LapicONESHOT    = 0x00000000,   /* One-shot */
    LapicPERIODIC   = 0x00020000,   /* Periodic */

                    /* [19:18] Timer Base (RW) */
    LapicCLKIN  = 0x00000000,   /* use CLKIN as input */
    LapicTMBASE = 0x00040000,   /* use TMBASE */
    LapicDIVIDER    = 0x00080000,   /* use output of the divider */
};

enum {                  /* LapicTDCR */
    LapicX2     = 0x00000000,   /* divide by 2 */
    LapicX4     = 0x00000001,   /* divide by 4 */
    LapicX8     = 0x00000002,   /* divide by 8 */
    LapicX16    = 0x00000003,   /* divide by 16 */
    LapicX32    = 0x00000008,   /* divide by 32 */
    LapicX64    = 0x00000009,   /* divide by 64 */
    LapicX128   = 0x0000000A,   /* divide by 128 */
    LapicX1     = 0x0000000B,   /* divide by 1 */
};

static ulong* lapicbase;

struct
{
    uvlong  hz;
    ulong   max;
    ulong   min;
    ulong   div;
} lapictimer;

static ulong
lapicr(int r)
{
    if(lapicbase == 0)
        panic("lapicr: no lapic");
    return *(lapicbase+(r/sizeof(*lapicbase)));
}

static void
lapicw(int r, ulong data)
{
    if(lapicbase == 0)
        panic("lapicw: no lapic");
    *(lapicbase+(r/sizeof(*lapicbase))) = data;
    data = *(lapicbase+(LapicID/sizeof(*lapicbase)));
    USED(data);
}

void
lapiconline(void)
{
    /*
     * Reload the timer to de-synchronise the processors,
     * then lower the task priority to allow interrupts to be
     * accepted by the APIC.
     */
    microdelay((TK2MS(1)*1000/conf.nmach) * m->machno);
    lapicw(LapicTICR, lapictimer.max);
    lapicw(LapicTIMER, LapicCLKIN|LapicPERIODIC|(VectorPIC+IrqTIMER));

    lapicw(LapicTPR, 0);
}

/*
 *  use the i8253 clock to figure out our lapic timer rate.
 */
static void
lapictimerinit(void)
{
    uvlong x, v, hz;

    v = m->cpuhz/1000;
    lapicw(LapicTDCR, LapicX1);
    lapicw(LapicTIMER, ApicIMASK|LapicCLKIN|LapicONESHOT|(VectorPIC+IrqTIMER));

    if(lapictimer.hz == 0ULL){
        x = fastticks(&hz);
        x += hz/10;
        lapicw(LapicTICR, 0xffffffff);
        do{
            v = fastticks(nil);
        }while(v < x);

        lapictimer.hz = (0xffffffffUL-lapicr(LapicTCCR))*10;
        lapictimer.max = lapictimer.hz/HZ;
        lapictimer.min = lapictimer.hz/(100*HZ);

        if(lapictimer.hz > hz-(hz/10)){
            if(lapictimer.hz > hz+(hz/10))
                panic("lapic clock %lld > cpu clock > %lld\n",
                    lapictimer.hz, hz);
            lapictimer.hz = hz;
        }
        assert(lapictimer.hz != 0);
        lapictimer.div = hz/lapictimer.hz;
    }
}

void
lapicinit(Apic* apic)
{
    ulong dfr, ldr, lvt;

    if(lapicbase == 0)
        lapicbase = apic->addr;
    if(lapicbase == 0) {
        print("lapicinit: no lapic\n");
        return;
    }

    /*
     * These don't really matter in Physical mode;
     * set the defaults anyway.
     */
    if(strncmp(m->cpuidid, "AuthenticAMD", 12) == 0)
        dfr = 0xf0000000;
    else
        dfr = 0xffffffff;
    ldr = 0x00000000;

    lapicw(LapicDFR, dfr);
    lapicw(LapicLDR, ldr);
    lapicw(LapicTPR, 0xff);
    lapicw(LapicSVR, LapicENABLE|(VectorPIC+IrqSPURIOUS));

    lapictimerinit();

    /*
     * Some Pentium revisions have a bug whereby spurious
     * interrupts are generated in the through-local mode.
     */
    switch(m->cpuidax & 0xFFF){
    case 0x526:             /* stepping cB1 */
    case 0x52B:             /* stepping E0 */
    case 0x52C:             /* stepping cC0 */
        wrmsr(0x0E, 1<<14);     /* TR12 */
        break;
    }

    /*
     * Set the local interrupts. It's likely these should just be
     * masked off for SMP mode as some Pentium Pros have problems if
     * LINT[01] are set to ExtINT.
     * Acknowledge any outstanding interrupts.
    lapicw(LapicLINT0, apic->lintr[0]);
    lapicw(LapicLINT1, apic->lintr[1]);
     */
    lapiceoi(0);

    lvt = (lapicr(LapicVER)>>16) & 0xFF;
    if(lvt >= 4)
        lapicw(LapicPCINT, ApicIMASK|(VectorPIC+IrqPCINT));
    lapicw(LapicERROR, VectorPIC+IrqERROR);
    lapicw(LapicESR, 0);
    lapicr(LapicESR);

    /*
     * Issue an INIT Level De-Assert to synchronise arbitration ID's.
     */
    lapicw(LapicICRHI, 0);
    lapicw(LapicICRLO, LapicALLINC|ApicLEVEL|LapicDEASSERT|ApicINIT);
    while(lapicr(LapicICRLO) & ApicDELIVS)
        ;

    /*
     * Do not allow acceptance of interrupts until all initialisation
     * for this processor is done. For the bootstrap processor this can be
     * early during initialisation. For the application processors this should
     * be after the bootstrap processor has lowered priority and is accepting
     * interrupts.
    lapicw(LapicTPR, 0);
     */
}

void
lapicstartap(Apic* apic, int v)
{
    int i;
    ulong crhi;

    /* make apic's processor do a warm reset */
    crhi = apic->apicno<<24;
    lapicw(LapicICRHI, crhi);
    lapicw(LapicICRLO, LapicFIELD|ApicLEVEL|LapicASSERT|ApicINIT);
    microdelay(200);
    lapicw(LapicICRLO, LapicFIELD|ApicLEVEL|LapicDEASSERT|ApicINIT);
    delay(10);

    /* assumes apic is not an 82489dx */
    for(i = 0; i < 2; i++){
        lapicw(LapicICRHI, crhi);
        /* make apic's processor start at v in real mode */
        lapicw(LapicICRLO, LapicFIELD|ApicEDGE|ApicSTARTUP|(v/BY2PG));
        microdelay(200);
    }
}

void
lapicerror(Ureg*, void*)
{
    ulong esr;

    lapicw(LapicESR, 0);
    esr = lapicr(LapicESR);
    switch(m->cpuidax & 0xFFF){
    case 0x526:             /* stepping cB1 */
    case 0x52B:             /* stepping E0 */
    case 0x52C:             /* stepping cC0 */
        return;
    }
    print("cpu%d: lapicerror: 0x%8.8luX\n", m->machno, esr);
}

void
lapicspurious(Ureg*, void*)
{
    print("cpu%d: lapicspurious\n", m->machno);
}

int
lapicisr(int v)
{
    ulong isr;

    isr = lapicr(LapicISR + (v/32));

    return isr & (1<<(v%32));
}

int
lapiceoi(int v)
{
    lapicw(LapicEOI, 0);

    return v;
}

void
lapicicrw(ulong hi, ulong lo)
{
    lapicw(LapicICRHI, hi);
    lapicw(LapicICRLO, lo);
}

void
ioapicrdtr(Apic* apic, int sel, int* hi, int* lo)
{
    ulong *iowin;

    iowin = apic->addr+(0x10/sizeof(ulong));
    sel = IoapicRDT + 2*sel;

    lock(apic);
    *apic->addr = sel+1;
    if(hi)
        *hi = *iowin;
    *apic->addr = sel;
    if(lo)
        *lo = *iowin;
    unlock(apic);
}

void
ioapicrdtw(Apic* apic, int sel, int hi, int lo)
{
    ulong *iowin;

    iowin = apic->addr+(0x10/sizeof(ulong));
    sel = IoapicRDT + 2*sel;

    lock(apic);
    *apic->addr = sel+1;
    *iowin = hi;
    *apic->addr = sel;
    *iowin = lo;
    unlock(apic);
}

void
ioapicinit(Apic* apic, int apicno)
{
    int hi, lo, v;
    ulong *iowin;

    /*
     * Initialise the I/O APIC.
     * The MultiProcessor Specification says it is the responsibility
     * of the O/S to set the APIC id.
     * Make sure interrupts are all masked off for now.
     */
    iowin = apic->addr+(0x10/sizeof(ulong));
    lock(apic);
    *apic->addr = IoapicVER;
    apic->mre = (*iowin>>16) & 0xFF;

    *apic->addr = IoapicID;
    *iowin = apicno<<24;
    unlock(apic);

    hi = 0;
    lo = ApicIMASK;
    for(v = 0; v <= apic->mre; v++)
        ioapicrdtw(apic, v, hi, lo);
}

void
lapictimerset(uvlong next)
{
    vlong period;
    int x;

    x = splhi();
    lock(&m->apictimerlock);

    period = lapictimer.max;
    if(next != 0){
        period = next - fastticks(nil);
        if (lapictimer.div == 0)
            panic("lapictimerset: zero lapictimer.div");
        period /= lapictimer.div;

        if(period < lapictimer.min)
            period = lapictimer.min;
        else if(period > lapictimer.max - lapictimer.min)
            period = lapictimer.max;
    }
    lapicw(LapicTICR, period);

    unlock(&m->apictimerlock);
    splx(x);
}

void
lapicclock(Ureg *u, void*)
{
    /*
     * since the MTRR updates need to be synchronized across processors,
     * we want to do this within the clock tick.
     */
    //mtrrclock(); disabled

    timerintr(u, 0);
}

void
lapicintron(void)
{
    lapicw(LapicTPR, 0);
}

void
lapicintroff(void)
{
    lapicw(LapicTPR, 0xFF);
}

//void
//lapicnmienable(void)
//{
//  /*
//   * On the one hand the manual says the vector information
//   * is ignored if the delivery mode is NMI, and on the other
//   * a "Receive Illegal Vector" should be generated for a
//   * vector in the range 0 through 15.
//   * Some implementations generate the error interrupt if the
//   * NMI vector is invalid, so always give a valid value.
//   */
//  if (lapicbase)
//      lapicw(LapicPCINT, ApicNMI|(VectorPIC+IrqPCINT));
//  else
//      print("lapicnmienable: no lapic\n");
//}

//void
//lapicnmidisable(void)
//{
//  if (lapicbase)
//      lapicw(LapicPCINT, ApicIMASK|(VectorPIC+IrqPCINT));
//  else
//      print("lapicnmidisable: no lapic\n");
//}
@


\subsection*{[[processes/386/archgeneric.c]]}

<<archgeneric.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

//todo: weird, if don't include this file, then can't declare arch in this file
// or I get some type signature mismatch
#include "io.h"

/*
 *  the following is a generic version of the
 *  architecture specific stuff
 */

static int
unimplemented(int)
{
    return 0;
}

static void
archreset(void)
{
    i8042reset();

    /*
     * Often the BIOS hangs during restart if a conventional 8042
     * warm-boot sequence is tried. The following is Intel specific and
     * seems to perform a cold-boot, but at least it comes back.
     * And sometimes there is no keyboard...
     *
     * The reset register (0xcf9) is usually in one of the bridge
     * chips. The actual location and sequence could be extracted from
     * ACPI but why bother, this is the end of the line anyway.
     */
    print("Takes a licking and keeps on ticking...\n");
    *(ushort*)KADDR(0x472) = 0x1234;    /* BIOS warm-boot flag */
    outb(0xcf9, 0x02);
    outb(0xcf9, 0x06);

    for(;;)
        idle();
}


PCArch archgeneric = {
.id=        "generic",
.ident=     0,
.reset=     archreset,
.serialpower=   unimplemented,
.modempower=    unimplemented,

// i8259
.intrinit=  i8259init,
.intrenable=    i8259enable,
.intrvecno= i8259vecno,
.intrdisable=   i8259disable,
.intron=    i8259on,
.introff=   i8259off,

// i8253
.clockenable=   i8253enable,
.fastclock= i8253read,
.timerset=  i8253timerset,
};


void
archrevert(void)
{
    arch = &archgeneric;
}

@


\subsection*{[[processes/386/archmp.c]]}

<<archmp.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include "mp.h"

_MP_ *_mp_;

// forward decl, mutual recursivity between archmp and identity
PCArch archmp;


uvlong
tscticks(uvlong *hz)
{
    if(hz != nil)
        *hz = m->cpuhz;

    cycles(&m->tscticks);   /* Uses the rdtsc instruction */
    return m->tscticks;
}

static void
mpresetothers(void)
{
    /*
     * INIT all excluding self.
     */
    lapicicrw(0, 0x000C0000|ApicINIT);
}

int
identify(void)
{
    char *cp;
    PCMP *pcmp;
    uchar *p, sum;
    ulong length;

    if((cp = getconf("*nomp")) != nil && strtol(cp, 0, 0) != 0)
        return 1;

    /*
     * Search for an MP configuration table. For now,
     * don't accept the default configurations (physaddr == 0).
     * Check for correct signature, calculate the checksum and,
     * if correct, check the version.
     * To do: check extended table checksum.
     */
    if((_mp_ = sigsearch("_MP_")) == 0 || _mp_->physaddr == 0) {
        /*
         * we can easily get processor info from acpi, but
         * interrupt routing, etc. would require interpreting aml.
         */
        print("archmp: no mp table found, assuming uniprocessor\n");
        return 1;
    }

    if (0)
        iprint("mp physaddr %#lux\n", _mp_->physaddr);
    pcmp = KADDR(_mp_->physaddr);
    if(memcmp(pcmp, "PCMP", 4) != 0) {
        print("archmp: mp table has bad magic");
        return 1;
    }

    length = pcmp->length;
    sum = 0;
    for(p = (uchar*)pcmp; length; length--)
        sum += *p++;

    if(sum || (pcmp->version != 1 && pcmp->version != 4))
        return 1;

    if(cpuserver && m->havetsc)
        archmp.fastclock = tscticks;
    return 0;
}


PCArch archmp = {
.id=        "_MP_", 
.ident=     identify,
.reset=     mpshutdown,
.intrinit=  mpinit,
.intrenable=    mpintrenable,
.intron=    lapicintron,
.introff=   lapicintroff,
.fastclock= i8253read,
.timerset=  lapictimerset,
.resetothers=   mpresetothers,
};


//Lock mpsynclock;

void
syncclock(void)
{
    uvlong x;

    if(arch->fastclock != tscticks)
        return;

    if(m->machno == 0){
        wrmsr(0x10, 0);
        m->tscticks = 0;
    } else {
        x = MACHP(0)->tscticks;
        while(x == MACHP(0)->tscticks)
            ;
        wrmsr(0x10, MACHP(0)->tscticks);
        cycles(&m->tscticks);
    }
}
@


\subsection*{[[processes/386/dat_processes.h]]}

<<dat_processes.h>>=

//*****************************************************************************
// Proc extensions
//*****************************************************************************

/*
 * the FP regs must be stored here, not somewhere pointed to from here.
 * port code assumes this.
 */
// could be renamed ArchProcFPSave (used both in Proc and Mach though)
union ArchFPsave {
  FPstate;
  SFPssestate;
};

/*
 *  things saved in the Proc structure during a notify
 */
//@Scheck: not dead, FP because unnamed substructure
struct ArchProcNotsave
{
  ulong svflags;
  ulong svcs;
  ulong svss;
};

//*****************************************************************************
// Interrupts
//*****************************************************************************
// Used only in 386/, so could be put in arch/, but used by the .c here.
// Used to be in io.h but more important than just a set of enums for IO
// so put here.

enum {
  VectorNMI = 2,    /* non-maskable interrupt */
  VectorBPT = 3,    /* breakpoint */
  VectorUD  = 6,    /* invalid opcode exception */
  VectorCNA = 7,    /* coprocessor not available */
  Vector2F  = 8,    /* double fault */
  VectorCSO = 9,    /* coprocessor segment overrun */
  VectorPF  = 14,   /* page fault */
  Vector15  = 15,   /* reserved */
  VectorCERR  = 16,   /* coprocessor error */

  VectorPIC = 32,   /* external i8259 interrupts */

  IrqCLOCK  = 0,
  IrqKBD    = 1,
  IrqUART1  = 3,
  IrqUART0  = 4,
  IrqPCMCIA = 5,
  IrqFLOPPY = 6,
  IrqLPT    = 7,
  IrqIRQ7   = 7,
  IrqAUX    = 12,   /* PS/2 port */
  IrqIRQ13  = 13,   /* coprocessor on 386 */
  IrqATA0   = 14,
  IrqATA1   = 15,
  MaxIrqPIC = 15,

  VectorLAPIC = VectorPIC+16, /* local APIC interrupts */
  IrqLINT0  = 16,   /* LINT[01] must be offsets 0 and 1 */
  IrqLINT1  = 17,
  IrqTIMER  = 18,
  IrqERROR  = 19,
  IrqPCINT  = 20,
  IrqSPURIOUS = 31,   /* must have bits [3-0] == 0x0F */
  MaxIrqLAPIC = 31,

  //!!! int 64 = way to jump in plan9 OS !!!
  VectorSYSCALL = 64,

  VectorAPIC  = 65,   /* external APIC interrupts */
  MaxVectorAPIC = 255,
};

struct Vctl {

  bool isintr;     /* interrupt or fault/trap */
  int irq;

  void  (*f)(Ureg*, void*); /* handler to call */
  void* a;      /* argument to call it with */

  char  name[KNAMELEN];   /* of driver */
  int tbdf; //?

  // interrupt service routine
  int (*isr)(int);    /* get isr bit for this irq */
  int (*eoi)(int);    /* eoi */

  // extra

  // list<Vctl> of vctl[vno], xalloc'ed (should not have that many so ok)
  Vctl* next;     /* handlers on this vector */
};

// array<list<Vctl>>, xalloc'ed
//IMPORTANT: static Vctl *vctl[256]; (in trap.c)

//*****************************************************************************
// Timer
//*****************************************************************************

// Used only in 386/, so could be put in arch/ but used by the .c here.
// Actually used only in i8253.c but important so put here.

struct I8253
{
    ulong   period;     /* current clock period */
    bool    enabled;
    uvlong  hz;

    ushort  last;       /* last value of clock 1 */
    uvlong  ticks;      /* cumulative ticks of counter 1 */

    ulong   periodset;

  // extra
    Lock;
};
//IMPORTANT: I8253 i8253; (in i8253.c)

//IMPORTANT: also is interrupt i8253clock() calling clock.c:timerintr()
@


\subsection*{[[processes/386/i8253.c]]}

<<i8253.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"

//*****************************************************************************
// Data
//*****************************************************************************


// the 8253 timer will generate clock ticks which will be useful to preempt
// processes and so provide multitasking

/*
 *  8253 timer
 */
enum
{
    T0cntr= 0x40,       /* counter ports */
    T1cntr= 0x41,       /* ... */
    T2cntr= 0x42,       /* ... */
    Tmode=  0x43,       /* mode port (control word register) */
    T2ctl=  0x61,       /* counter 2 control port */

    /* commands */
    Latch0= 0x00,       /* latch counter 0's value */
    Load0l= 0x10,       /* load counter 0's lsb */
    Load0m= 0x20,       /* load counter 0's msb */
    Load0=  0x30,       /* load counter 0 with 2 bytes */

    Latch1= 0x40,       /* latch counter 1's value */
    Load1l= 0x50,       /* load counter 1's lsb */
    Load1m= 0x60,       /* load counter 1's msb */
    Load1=  0x70,       /* load counter 1 with 2 bytes */

    Latch2= 0x80,       /* latch counter 2's value */
    Load2l= 0x90,       /* load counter 2's lsb */
    Load2m= 0xa0,       /* load counter 2's msb */
    Load2=  0xb0,       /* load counter 2 with 2 bytes */

    /* 8254 read-back command: everything > pc-at has an 8254 */
    Rdback= 0xc0,       /* readback counters & status */
    Rdnstat=0x10,       /* don't read status */
    Rdncnt= 0x20,       /* don't read counter value */
    Rd0cntr=0x02,       /* read back for which counter */
    Rd1cntr=0x04,
    Rd2cntr=0x08,

    /* modes */
    ModeMsk=0xe,
    Square= 0x6,        /* periodic square wave */
    Trigger=0x0,        /* interrupt on terminal count */
    Sstrobe=0x8,        /* software triggered strobe */

    /* T2ctl bits */
    T2gate= (1<<0),     /* enable T2 counting */
    T2spkr= (1<<1),     /* connect T2 out to speaker */
    T2out=  (1<<5),     /* output of T2 */

    Freq=   1193182,    /* Real clock frequency */
    Tickshift=8,        /* extra accuracy */
    MaxPeriod=Freq/HZ,
    MinPeriod=Freq/(100*HZ),

    Wdogms  = 200,      /* ms between strokes */
};

I8253 i8253;



struct Watchdog
{
    void    (*enable)(void);    /* watchdog enable */
    void    (*disable)(void);   /* watchdog disable */
    void    (*restart)(void);   /* watchdog restart */
    void    (*stat)(char*, char*);  /* watchdog statistics */
};

Watchdog* watchdog;
int watchdogon;


//*****************************************************************************
// Init
//*****************************************************************************

void
i8253init(void)
{
    int loops, x;

    ioalloc(T0cntr, 4, 0, "i8253");
    ioalloc(T2ctl, 1, 0, "i8253.cntr2ctl");

    i8253.period = Freq/HZ;

    /*
     *  enable a 1/HZ interrupt for providing scheduling interrupts
     */
    outb(Tmode, Load0|Square);
    outb(T0cntr, (Freq/HZ));    /* low byte */
    outb(T0cntr, (Freq/HZ)>>8); /* high byte */

    /*
     *  enable a longer period counter to use as a clock
     */
    outb(Tmode, Load2|Square);
    outb(T2cntr, 0);        /* low byte */
    outb(T2cntr, 0);        /* high byte */
    x = inb(T2ctl);
    x |= T2gate;
    outb(T2ctl, x);
    
    /*
     * Introduce a little delay to make sure the count is
     * latched and the timer is counting down; with a fast
     * enough processor this may not be the case.
     * The i8254 (which this probably is) has a read-back
     * command which can be used to make sure the counting
     * register has been written into the counting element.
     */
    x = (Freq/HZ);
    for(loops = 0; loops < 100000 && x >= (Freq/HZ); loops++){
        outb(Tmode, Latch0);
        x = inb(T0cntr);
        x |= inb(T0cntr)<<8;
    }
}

//*****************************************************************************
// Misc
//*****************************************************************************

/*
 * if the watchdog is running and we're on cpu 0 and ignoring (clock)
 * interrupts, disable the watchdog temporarily so that the (presumed)
 * long-running loop to follow will not trigger an NMI.
 * wdogresume restarts the watchdog if wdogpause stopped it.
 */
static int
wdogpause(void)
{
    int turndogoff;

    turndogoff = watchdogon && m->machno == 0 && !islo();
    if (turndogoff) {
        watchdog->disable();
        watchdogon = 0;
    }
    return turndogoff;
}

static void
wdogresume(int resume)
{
    if (resume) {
        watchdog->enable();
        watchdogon = 1;
    }
}

void
guesscpuhz(int aalcycles)
{
    int loops, incr, x, y, dogwason;
    uvlong a, b, cpufreq;

    dogwason = wdogpause();     /* don't get NMI while busy looping */

    /* find biggest loop that doesn't wrap */
    incr = 16000000/(aalcycles*HZ*2);
    x = 2000;
    for(loops = incr; loops < 64*1024; loops += incr) {
    
        /*
         *  measure time for the loop
         *
         *          MOVL    loops,CX
         *  aaml1:      AAM
         *          LOOP    aaml1
         *
         *  the time for the loop should be independent of external
         *  cache and memory system since it fits in the execution
         *  prefetch buffer.
         *
         */
        outb(Tmode, Latch0);
        cycles(&a);
        x = inb(T0cntr);
        x |= inb(T0cntr)<<8;
        aamloop(loops);
        outb(Tmode, Latch0);
        cycles(&b);
        y = inb(T0cntr);
        y |= inb(T0cntr)<<8;
        x -= y;
    
        if(x < 0)
            x += Freq/HZ;

        if(x > Freq/(3*HZ))
            break;
    }
    wdogresume(dogwason);

    /*
     *  figure out clock frequency and a loop multiplier for delay().
     *  n.b. counter goes up by 2*Freq
     */
    if(x == 0)
        x = 1;          /* avoid division by zero on vmware 7 */
    cpufreq = (vlong)loops*((aalcycles*2*Freq)/x);
    m->loopconst = (cpufreq/1000)/aalcycles;    /* AAM+LOOP's for 1 ms */

    if(m->havetsc && a != b){  /* a == b means virtualbox has confused us */
        /* counter goes up by 2*Freq */
        b = (b-a)<<1;
        b *= Freq;
        b /= x;

        /*
         *  round to the nearest megahz
         */
        m->cpumhz = (b+500000)/1000000L;
        m->cpuhz = b;
        m->cyclefreq = b;
    } else {
        /*
         *  add in possible 0.5% error and convert to MHz
         */
        m->cpumhz = (cpufreq + cpufreq/200)/1000000;
        m->cpuhz = cpufreq;
    }

    /* don't divide by zero in trap.c */
    if (m->cpumhz == 0)
        panic("guesscpuhz: zero m->cpumhz");
    i8253.hz = Freq<<Tickshift;
}

void
i8253timerset(uvlong next)
{
    long period;
    ulong want;
    ulong now;

    period = MaxPeriod;
    if(next != 0){
        want = next>>Tickshift;
        now = i8253.ticks;  /* assuming whomever called us just did fastticks() */

        period = want - now;
        if(period < MinPeriod)
            period = MinPeriod;
        else if(period > MaxPeriod)
            period = MaxPeriod;
    }

    /* hysteresis */
    if(i8253.period != period){
        ilock(&i8253);
        /* load new value */
        outb(Tmode, Load0|Square);
        outb(T0cntr, period);       /* low byte */
        outb(T0cntr, period >> 8);      /* high byte */

        /* remember period */
        i8253.period = period;
        i8253.periodset++;
        iunlock(&i8253);
    }
}

static void
i8253clock(Ureg* ureg, void*)
{
    timerintr(ureg, 0);
}

void
i8253enable(void)
{
    i8253.enabled = 1;
    i8253.period = Freq/HZ;
    intrenable(IrqCLOCK, i8253clock, 0, BUSUNKNOWN, "clock");
}

void
i8253link(void)
{
}

/*
 *  return the total ticks of counter 2.  We shift by
 *  8 to give timesync more wriggle room for interpretation
 *  of the frequency
 */
uvlong
i8253read(uvlong *hz)
{
    ushort y, x;
    uvlong ticks;

    if(hz)
        *hz = i8253.hz;

    ilock(&i8253);
    outb(Tmode, Latch2);
    y = inb(T2cntr);
    y |= inb(T2cntr)<<8;

    if(y < i8253.last)
        x = i8253.last - y;
    else {
        x = i8253.last + (0x10000 - y);
        if (x > 3*MaxPeriod) {
            outb(Tmode, Load2|Square);
            outb(T2cntr, 0);        /* low byte */
            outb(T2cntr, 0);        /* high byte */
            y = 0xFFFF;
            x = i8253.period;
        }
    }
    i8253.last = y;
    i8253.ticks += x>>1;
    ticks = i8253.ticks;
    iunlock(&i8253);

    return ticks<<Tickshift;
}

void
i8253_delay(int millisecs)
{
    if (millisecs > 10*1000)
        iprint("delay(%d) from %#p\n", millisecs,
            getcallerpc(&millisecs));
    if (watchdogon && m->machno == 0 && !islo())
        for (; millisecs > Wdogms; millisecs -= Wdogms) {
            delay(Wdogms);
            watchdog->restart();
        }
    millisecs *= m->loopconst;
    if(millisecs <= 0)
        millisecs = 1;
    aamloop(millisecs);
}

void
i8253_microdelay(int microsecs)
{
    if (watchdogon && m->machno == 0 && !islo())
        for (; microsecs > Wdogms*1000; microsecs -= Wdogms*1000) {
            delay(Wdogms);
            watchdog->restart();
        }
    microsecs *= m->loopconst;
    microsecs /= 1000;
    if(microsecs <= 0)
        microsecs = 1;
    aamloop(microsecs);
}

/*  
 *  performance measurement ticks.  must be low overhead.
 *  doesn't have to count over a second.
 */
ulong
perfticks(void)
{
    uvlong x;

    if(m->havetsc)
        cycles(&x);
    else
        x = 0;
    return x;
}
@


\subsection*{[[processes/386/i8259.c]]}

<<i8259.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"

/*
 *  8259 interrupt controllers
 */
enum
{
    Int0ctl=    0x20,       /* control port (ICW1, OCW2, OCW3) */
    Int0aux=    0x21,       /* everything else (ICW2, ICW3, ICW4, OCW1) */
    Int1ctl=    0xA0,       /* control port */
    Int1aux=    0xA1,       /* everything else (ICW2, ICW3, ICW4, OCW1) */

    Icw1=       0x10,       /* select bit in ctl register */
    Ocw2=       0x00,
    Ocw3=       0x08,

    EOI=        0x20,       /* non-specific end of interrupt */

    Elcr1=      0x4D0,      /* Edge/Level Triggered Register */
    Elcr2=      0x4D1,
};

static Lock i8259lock;
static int i8259mask = 0xFFFF;      /* disabled interrupts */
int i8259elcr;              /* mask of level-triggered interrupts */

void
i8259init(void)
{
    int x;

    ioalloc(Int0ctl, 2, 0, "i8259.0");
    ioalloc(Int1ctl, 2, 0, "i8259.1");
    ilock(&i8259lock);

    /*
     *  Set up the first 8259 interrupt processor.
     *  Make 8259 interrupts start at CPU vector VectorPIC.
     *  Set the 8259 as master with edge triggered
     *  input with fully nested interrupts.
     */
    outb(Int0ctl, (1<<4)|(0<<3)|(1<<0));    /* ICW1 - master, edge triggered,
                           ICW4 will be sent */
    outb(Int0aux, VectorPIC);       /* ICW2 - interrupt vector offset */
    outb(Int0aux, 0x04);            /* ICW3 - have slave on level 2 */
    outb(Int0aux, 0x01);            /* ICW4 - 8086 mode, not buffered */

    /*
     *  Set up the second 8259 interrupt processor.
     *  Make 8259 interrupts start at CPU vector VectorPIC+8.
     *  Set the 8259 as slave with edge triggered
     *  input with fully nested interrupts.
     */
    outb(Int1ctl, (1<<4)|(0<<3)|(1<<0));    /* ICW1 - master, edge triggered,
                           ICW4 will be sent */
    outb(Int1aux, VectorPIC+8);     /* ICW2 - interrupt vector offset */
    outb(Int1aux, 0x02);            /* ICW3 - I am a slave on level 2 */
    outb(Int1aux, 0x01);            /* ICW4 - 8086 mode, not buffered */
    outb(Int1aux, (i8259mask>>8) & 0xFF);

    /*
     *  pass #2 8259 interrupts to #1
     */
    i8259mask &= ~0x04;
    outb(Int0aux, i8259mask & 0xFF);

    /*
     * Set Ocw3 to return the ISR when ctl read.
     * After initialisation status read is set to IRR.
     * Read IRR first to possibly deassert an outstanding
     * interrupt.
     */
    inb(Int0ctl);
    outb(Int0ctl, Ocw3|0x03);
    inb(Int1ctl);
    outb(Int1ctl, Ocw3|0x03);

    /*
     * Check for Edge/Level register.
     * This check may not work for all chipsets.
     * First try a non-intrusive test - the bits for
     * IRQs 13, 8, 2, 1 and 0 must be edge (0). If
     * that's OK try a R/W test.
     */
    x = (inb(Elcr2)<<8)|inb(Elcr1);
    if(!(x & 0x2107)){
        outb(Elcr1, 0);
        if(inb(Elcr1) == 0){
            outb(Elcr1, 0x20);
            if(inb(Elcr1) == 0x20)
                i8259elcr = x;
            outb(Elcr1, x & 0xFF);
            print("ELCR: %4.4uX\n", i8259elcr);
        }
    }
    iunlock(&i8259lock);
}

int
i8259isr(int vno)
{
    int irq, isr;

    if(vno < VectorPIC || vno > VectorPIC+MaxIrqPIC)
        return 0;
    irq = vno-VectorPIC;

    /*
     *  tell the 8259 that we're done with the
     *  highest level interrupt (interrupts are still
     *  off at this point)
     */
    ilock(&i8259lock);
    isr = inb(Int0ctl);
    outb(Int0ctl, EOI);
    if(irq >= 8){
        isr |= inb(Int1ctl)<<8;
        outb(Int1ctl, EOI);
    }
    iunlock(&i8259lock);

    return isr & (1<<irq);
}

int
i8259enable(Vctl* v)
{
    int irq, irqbit;

    /*
     * Given an IRQ, enable the corresponding interrupt in the i8259
     * and return the vector to be used. The i8259 is set to use a fixed
     * range of vectors starting at VectorPIC.
     */
    irq = v->irq;
    if(irq < 0 || irq > MaxIrqPIC){
        print("i8259enable: irq %d out of range\n", irq);
        return -1;
    }
    irqbit = 1<<irq;

    ilock(&i8259lock);
    if(!(i8259mask & irqbit) && !(i8259elcr & irqbit)){
        print("i8259enable: irq %d shared but not level\n", irq);
        iunlock(&i8259lock);
        return -1;
    }
    i8259mask &= ~irqbit;
    if(irq < 8)
        outb(Int0aux, i8259mask & 0xFF);
    else
        outb(Int1aux, (i8259mask>>8) & 0xFF);

    if(i8259elcr & irqbit)
        v->eoi = i8259isr;
    else
        v->isr = i8259isr;
    iunlock(&i8259lock);

    return VectorPIC+irq;
}

int
i8259vecno(int irq)
{
    return VectorPIC+irq;
}

int
i8259disable(int irq)
{
    int irqbit;

    /*
     * Given an IRQ, disable the corresponding interrupt
     * in the 8259.
     */
    if(irq < 0 || irq > MaxIrqPIC){
        print("i8259disable: irq %d out of range\n", irq);
        return -1;
    }
    irqbit = 1<<irq;

    ilock(&i8259lock);
    if(!(i8259mask & irqbit)){
        i8259mask |= irqbit;
        if(irq < 8)
            outb(Int0aux, i8259mask & 0xFF);
        else
            outb(Int1aux, (i8259mask>>8) & 0xFF);
    }
    iunlock(&i8259lock);
    return 0;
}

void
i8259on(void)
{
    outb(Int0aux, i8259mask&0xFF);
    outb(Int1aux, (i8259mask>>8)&0xFF);
}

void
i8259off(void)
{
    outb(Int0aux, 0xFF);
    outb(Int1aux, 0xFF);
}

@


\subsection*{[[processes/386/l_switch.s]]}

<<l_switch.s>>=

// This file is used for task switching but last to emulate
// exceptions in C (via the waserror(), nexterror(), poperror() functions)
        
/*
 *  label consists of a stack pointer and a PC
 */
TEXT gotolabel(SB), $0
        MOVL    label+0(FP), AX
        MOVL    0(AX), SP                       /* restore sp */
        MOVL    4(AX), AX                       /* put return pc on the stack */
        MOVL    AX, 0(SP)
        MOVL    $1, AX                          /* return 1 */
        RET

TEXT setlabel(SB), $0
        MOVL    label+0(FP), AX
        MOVL    SP, 0(AX)                       /* store sp */
        MOVL    0(SP), BX                       /* store return pc */
        MOVL    BX, 4(AX)
        MOVL    $0, AX                          /* return 0 */
        RET

@


\subsection*{[[processes/386/l_trap.s]]}

<<l_trap.s>>=
#include "mem.h"
        
        
/*
 * Interrupt/exception handling.
 * Each entry in the vector table calls either _strayintr or _strayintrx depending
 * on whether an error code has been automatically pushed onto the stack
 * (_strayintrx) or not, in which case a dummy entry must be pushed before retrieving
 * the trap type from the vector table entry and placing it on the stack as part
 * of the Ureg structure.
 * The size of each entry in the vector table (6 bytes) is known in trapinit().
 */
TEXT _strayintr(SB), $0
        PUSHL   AX                      /* save AX */
        MOVL    4(SP), AX               /* return PC from vectortable(SB) */
        JMP     intrcommon

TEXT _strayintrx(SB), $0
        XCHGL   AX, (SP)                /* swap AX with vectortable CALL PC */
intrcommon:
        PUSHL   DS                      /* save DS */
        PUSHL   $(KDSEL)
        POPL    DS                      /* fix up DS */
        MOVBLZX (AX), AX                /* trap type -> AX */
        XCHGL   AX, 4(SP)               /* exchange trap type with saved AX */

        PUSHL   ES                      /* save ES */
        PUSHL   $(KDSEL)
        POPL    ES                      /* fix up ES */

        PUSHL   FS                      /* save the rest of the Ureg struct */
        PUSHL   GS
        PUSHAL

        PUSHL   SP                      /* Ureg* argument to trap */
        CALL    trap(SB)

TEXT forkret(SB), $0
        POPL    AX
        POPAL
        POPL    GS
        POPL    FS
        POPL    ES
        POPL    DS
        ADDL    $8, SP                  /* pop error code and trap type */
        IRETL

TEXT vectortable(SB), $0
        CALL _strayintr(SB); BYTE $0x00         /* divide error */
        CALL _strayintr(SB); BYTE $0x01         /* debug exception */
        CALL _strayintr(SB); BYTE $0x02         /* NMI interrupt */
        CALL _strayintr(SB); BYTE $0x03         /* breakpoint */
        CALL _strayintr(SB); BYTE $0x04         /* overflow */
        CALL _strayintr(SB); BYTE $0x05         /* bound */
        CALL _strayintr(SB); BYTE $0x06         /* invalid opcode */
        CALL _strayintr(SB); BYTE $0x07         /* no coprocessor available */
        CALL _strayintrx(SB); BYTE $0x08        /* double fault */
        CALL _strayintr(SB); BYTE $0x09         /* coprocessor segment overflow */
        CALL _strayintrx(SB); BYTE $0x0A        /* invalid TSS */
        CALL _strayintrx(SB); BYTE $0x0B        /* segment not available */
        CALL _strayintrx(SB); BYTE $0x0C        /* stack exception */
        CALL _strayintrx(SB); BYTE $0x0D        /* general protection error */
        CALL _strayintrx(SB); BYTE $0x0E        /* page fault */
        CALL _strayintr(SB); BYTE $0x0F         /*  */
        CALL _strayintr(SB); BYTE $0x10         /* coprocessor error */
        CALL _strayintrx(SB); BYTE $0x11        /* alignment check */
        CALL _strayintr(SB); BYTE $0x12         /* machine check */
        CALL _strayintr(SB); BYTE $0x13
        CALL _strayintr(SB); BYTE $0x14
        CALL _strayintr(SB); BYTE $0x15
        CALL _strayintr(SB); BYTE $0x16
        CALL _strayintr(SB); BYTE $0x17
        CALL _strayintr(SB); BYTE $0x18
        CALL _strayintr(SB); BYTE $0x19
        CALL _strayintr(SB); BYTE $0x1A
        CALL _strayintr(SB); BYTE $0x1B
        CALL _strayintr(SB); BYTE $0x1C
        CALL _strayintr(SB); BYTE $0x1D
        CALL _strayintr(SB); BYTE $0x1E
        CALL _strayintr(SB); BYTE $0x1F
        CALL _strayintr(SB); BYTE $0x20         /* VectorLAPIC */
        CALL _strayintr(SB); BYTE $0x21
        CALL _strayintr(SB); BYTE $0x22
        CALL _strayintr(SB); BYTE $0x23
        CALL _strayintr(SB); BYTE $0x24
        CALL _strayintr(SB); BYTE $0x25
        CALL _strayintr(SB); BYTE $0x26
        CALL _strayintr(SB); BYTE $0x27
        CALL _strayintr(SB); BYTE $0x28
        CALL _strayintr(SB); BYTE $0x29
        CALL _strayintr(SB); BYTE $0x2A
        CALL _strayintr(SB); BYTE $0x2B
        CALL _strayintr(SB); BYTE $0x2C
        CALL _strayintr(SB); BYTE $0x2D
        CALL _strayintr(SB); BYTE $0x2E
        CALL _strayintr(SB); BYTE $0x2F
        CALL _strayintr(SB); BYTE $0x30
        CALL _strayintr(SB); BYTE $0x31
        CALL _strayintr(SB); BYTE $0x32
        CALL _strayintr(SB); BYTE $0x33
        CALL _strayintr(SB); BYTE $0x34
        CALL _strayintr(SB); BYTE $0x35
        CALL _strayintr(SB); BYTE $0x36
        CALL _strayintr(SB); BYTE $0x37
        CALL _strayintr(SB); BYTE $0x38
        CALL _strayintr(SB); BYTE $0x39
        CALL _strayintr(SB); BYTE $0x3A
        CALL _strayintr(SB); BYTE $0x3B
        CALL _strayintr(SB); BYTE $0x3C
        CALL _strayintr(SB); BYTE $0x3D
        CALL _strayintr(SB); BYTE $0x3E
        CALL _strayintr(SB); BYTE $0x3F
        CALL _syscallintr(SB); BYTE $0x40       /* VectorSYSCALL */
        CALL _strayintr(SB); BYTE $0x41
        CALL _strayintr(SB); BYTE $0x42
        CALL _strayintr(SB); BYTE $0x43
        CALL _strayintr(SB); BYTE $0x44
        CALL _strayintr(SB); BYTE $0x45
        CALL _strayintr(SB); BYTE $0x46
        CALL _strayintr(SB); BYTE $0x47
        CALL _strayintr(SB); BYTE $0x48
        CALL _strayintr(SB); BYTE $0x49
        CALL _strayintr(SB); BYTE $0x4A
        CALL _strayintr(SB); BYTE $0x4B
        CALL _strayintr(SB); BYTE $0x4C
        CALL _strayintr(SB); BYTE $0x4D
        CALL _strayintr(SB); BYTE $0x4E
        CALL _strayintr(SB); BYTE $0x4F
        CALL _strayintr(SB); BYTE $0x50
        CALL _strayintr(SB); BYTE $0x51
        CALL _strayintr(SB); BYTE $0x52
        CALL _strayintr(SB); BYTE $0x53
        CALL _strayintr(SB); BYTE $0x54
        CALL _strayintr(SB); BYTE $0x55
        CALL _strayintr(SB); BYTE $0x56
        CALL _strayintr(SB); BYTE $0x57
        CALL _strayintr(SB); BYTE $0x58
        CALL _strayintr(SB); BYTE $0x59
        CALL _strayintr(SB); BYTE $0x5A
        CALL _strayintr(SB); BYTE $0x5B
        CALL _strayintr(SB); BYTE $0x5C
        CALL _strayintr(SB); BYTE $0x5D
        CALL _strayintr(SB); BYTE $0x5E
        CALL _strayintr(SB); BYTE $0x5F
        CALL _strayintr(SB); BYTE $0x60
        CALL _strayintr(SB); BYTE $0x61
        CALL _strayintr(SB); BYTE $0x62
        CALL _strayintr(SB); BYTE $0x63
        CALL _strayintr(SB); BYTE $0x64
        CALL _strayintr(SB); BYTE $0x65
        CALL _strayintr(SB); BYTE $0x66
        CALL _strayintr(SB); BYTE $0x67
        CALL _strayintr(SB); BYTE $0x68
        CALL _strayintr(SB); BYTE $0x69
        CALL _strayintr(SB); BYTE $0x6A
        CALL _strayintr(SB); BYTE $0x6B
        CALL _strayintr(SB); BYTE $0x6C
        CALL _strayintr(SB); BYTE $0x6D
        CALL _strayintr(SB); BYTE $0x6E
        CALL _strayintr(SB); BYTE $0x6F
        CALL _strayintr(SB); BYTE $0x70
        CALL _strayintr(SB); BYTE $0x71
        CALL _strayintr(SB); BYTE $0x72
        CALL _strayintr(SB); BYTE $0x73
        CALL _strayintr(SB); BYTE $0x74
        CALL _strayintr(SB); BYTE $0x75
        CALL _strayintr(SB); BYTE $0x76
        CALL _strayintr(SB); BYTE $0x77
        CALL _strayintr(SB); BYTE $0x78
        CALL _strayintr(SB); BYTE $0x79
        CALL _strayintr(SB); BYTE $0x7A
        CALL _strayintr(SB); BYTE $0x7B
        CALL _strayintr(SB); BYTE $0x7C
        CALL _strayintr(SB); BYTE $0x7D
        CALL _strayintr(SB); BYTE $0x7E
        CALL _strayintr(SB); BYTE $0x7F
        CALL _strayintr(SB); BYTE $0x80         /* Vector[A]PIC */
        CALL _strayintr(SB); BYTE $0x81
        CALL _strayintr(SB); BYTE $0x82
        CALL _strayintr(SB); BYTE $0x83
        CALL _strayintr(SB); BYTE $0x84
        CALL _strayintr(SB); BYTE $0x85
        CALL _strayintr(SB); BYTE $0x86
        CALL _strayintr(SB); BYTE $0x87
        CALL _strayintr(SB); BYTE $0x88
        CALL _strayintr(SB); BYTE $0x89
        CALL _strayintr(SB); BYTE $0x8A
        CALL _strayintr(SB); BYTE $0x8B
        CALL _strayintr(SB); BYTE $0x8C
        CALL _strayintr(SB); BYTE $0x8D
        CALL _strayintr(SB); BYTE $0x8E
        CALL _strayintr(SB); BYTE $0x8F
        CALL _strayintr(SB); BYTE $0x90
        CALL _strayintr(SB); BYTE $0x91
        CALL _strayintr(SB); BYTE $0x92
        CALL _strayintr(SB); BYTE $0x93
        CALL _strayintr(SB); BYTE $0x94
        CALL _strayintr(SB); BYTE $0x95
        CALL _strayintr(SB); BYTE $0x96
        CALL _strayintr(SB); BYTE $0x97
        CALL _strayintr(SB); BYTE $0x98
        CALL _strayintr(SB); BYTE $0x99
        CALL _strayintr(SB); BYTE $0x9A
        CALL _strayintr(SB); BYTE $0x9B
        CALL _strayintr(SB); BYTE $0x9C
        CALL _strayintr(SB); BYTE $0x9D
        CALL _strayintr(SB); BYTE $0x9E
        CALL _strayintr(SB); BYTE $0x9F
        CALL _strayintr(SB); BYTE $0xA0
        CALL _strayintr(SB); BYTE $0xA1
        CALL _strayintr(SB); BYTE $0xA2
        CALL _strayintr(SB); BYTE $0xA3
        CALL _strayintr(SB); BYTE $0xA4
        CALL _strayintr(SB); BYTE $0xA5
        CALL _strayintr(SB); BYTE $0xA6
        CALL _strayintr(SB); BYTE $0xA7
        CALL _strayintr(SB); BYTE $0xA8
        CALL _strayintr(SB); BYTE $0xA9
        CALL _strayintr(SB); BYTE $0xAA
        CALL _strayintr(SB); BYTE $0xAB
        CALL _strayintr(SB); BYTE $0xAC
        CALL _strayintr(SB); BYTE $0xAD
        CALL _strayintr(SB); BYTE $0xAE
        CALL _strayintr(SB); BYTE $0xAF
        CALL _strayintr(SB); BYTE $0xB0
        CALL _strayintr(SB); BYTE $0xB1
        CALL _strayintr(SB); BYTE $0xB2
        CALL _strayintr(SB); BYTE $0xB3
        CALL _strayintr(SB); BYTE $0xB4
        CALL _strayintr(SB); BYTE $0xB5
        CALL _strayintr(SB); BYTE $0xB6
        CALL _strayintr(SB); BYTE $0xB7
        CALL _strayintr(SB); BYTE $0xB8
        CALL _strayintr(SB); BYTE $0xB9
        CALL _strayintr(SB); BYTE $0xBA
        CALL _strayintr(SB); BYTE $0xBB
        CALL _strayintr(SB); BYTE $0xBC
        CALL _strayintr(SB); BYTE $0xBD
        CALL _strayintr(SB); BYTE $0xBE
        CALL _strayintr(SB); BYTE $0xBF
        CALL _strayintr(SB); BYTE $0xC0
        CALL _strayintr(SB); BYTE $0xC1
        CALL _strayintr(SB); BYTE $0xC2
        CALL _strayintr(SB); BYTE $0xC3
        CALL _strayintr(SB); BYTE $0xC4
        CALL _strayintr(SB); BYTE $0xC5
        CALL _strayintr(SB); BYTE $0xC6
        CALL _strayintr(SB); BYTE $0xC7
        CALL _strayintr(SB); BYTE $0xC8
        CALL _strayintr(SB); BYTE $0xC9
        CALL _strayintr(SB); BYTE $0xCA
        CALL _strayintr(SB); BYTE $0xCB
        CALL _strayintr(SB); BYTE $0xCC
        CALL _strayintr(SB); BYTE $0xCD
        CALL _strayintr(SB); BYTE $0xCE
        CALL _strayintr(SB); BYTE $0xCF
        CALL _strayintr(SB); BYTE $0xD0
        CALL _strayintr(SB); BYTE $0xD1
        CALL _strayintr(SB); BYTE $0xD2
        CALL _strayintr(SB); BYTE $0xD3
        CALL _strayintr(SB); BYTE $0xD4
        CALL _strayintr(SB); BYTE $0xD5
        CALL _strayintr(SB); BYTE $0xD6
        CALL _strayintr(SB); BYTE $0xD7
        CALL _strayintr(SB); BYTE $0xD8
        CALL _strayintr(SB); BYTE $0xD9
        CALL _strayintr(SB); BYTE $0xDA
        CALL _strayintr(SB); BYTE $0xDB
        CALL _strayintr(SB); BYTE $0xDC
        CALL _strayintr(SB); BYTE $0xDD
        CALL _strayintr(SB); BYTE $0xDE
        CALL _strayintr(SB); BYTE $0xDF
        CALL _strayintr(SB); BYTE $0xE0
        CALL _strayintr(SB); BYTE $0xE1
        CALL _strayintr(SB); BYTE $0xE2
        CALL _strayintr(SB); BYTE $0xE3
        CALL _strayintr(SB); BYTE $0xE4
        CALL _strayintr(SB); BYTE $0xE5
        CALL _strayintr(SB); BYTE $0xE6
        CALL _strayintr(SB); BYTE $0xE7
        CALL _strayintr(SB); BYTE $0xE8
        CALL _strayintr(SB); BYTE $0xE9
        CALL _strayintr(SB); BYTE $0xEA
        CALL _strayintr(SB); BYTE $0xEB
        CALL _strayintr(SB); BYTE $0xEC
        CALL _strayintr(SB); BYTE $0xED
        CALL _strayintr(SB); BYTE $0xEE
        CALL _strayintr(SB); BYTE $0xEF
        CALL _strayintr(SB); BYTE $0xF0
        CALL _strayintr(SB); BYTE $0xF1
        CALL _strayintr(SB); BYTE $0xF2
        CALL _strayintr(SB); BYTE $0xF3
        CALL _strayintr(SB); BYTE $0xF4
        CALL _strayintr(SB); BYTE $0xF5
        CALL _strayintr(SB); BYTE $0xF6
        CALL _strayintr(SB); BYTE $0xF7
        CALL _strayintr(SB); BYTE $0xF8
        CALL _strayintr(SB); BYTE $0xF9
        CALL _strayintr(SB); BYTE $0xFA
        CALL _strayintr(SB); BYTE $0xFB
        CALL _strayintr(SB); BYTE $0xFC
        CALL _strayintr(SB); BYTE $0xFD
        CALL _strayintr(SB); BYTE $0xFE
        CALL _strayintr(SB); BYTE $0xFF
@


\subsection*{[[processes/386/main_processes.c]]}

<<main_processes.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

//TODO: where this is set??
int idle_spin, idle_if_nproc;

/*
 *  set up floating point for a new process
 */
void
procsetup(Proc*p)
{
    p->fpstate = FPinit;
    fpoff();
}

/*
 *  Save the mach dependent part of the process state.
 */
void
procsave(Proc *p)
{
    uvlong t;

    cycles(&t);
    p->pcycles += t;
    if(p->fpstate == FPactive){
        if(p->state == Moribund)
            fpclear();
        else{
            /*
             * Fpsave() stores without handling pending
             * unmasked exeptions. Postnote() can't be called
             * here as sleep() already has up->rlock, so
             * the handling of pending exceptions is delayed
             * until the process runs again and generates an
             * emulation fault to activate the FPU.
             */
            fpsave(&p->fpsave);
        }
        p->fpstate = FPinactive;
    }

    /*
     * While this processor is in the scheduler, the process could run
     * on another processor and exit, returning the page tables to
     * the free list where they could be reallocated and overwritten.
     * When this processor eventually has to get an entry from the
     * trashed page tables it will crash.
     *
     * If there's only one processor, this can't happen.
     * You might think it would be a win not to do this in that case,
     * especially on VMware, but it turns out not to matter.
     */
    mmuflushtlb(PADDR(m->pdb));
}



void
procrestore(Proc *p)
{
    uvlong t;

    if(p->kp)
        return;
    cycles(&t);
    p->pcycles -= t;
}


void
fpsavealloc(void)
{
    m->fpsavalign = mallocalign(sizeof(FPssestate), FPalign, 0, 0);
    if (m->fpsavalign == nil)
        panic("cpu%d: can't allocate fpsavalign", m->machno);
}

/*
 * sse fp save and restore buffers have to be 16-byte (FPalign) aligned,
 * so we shuffle the data down as needed or make copies.
 */

void
fpssesave(ArchFPsave *fps)
{
    ArchFPsave *afps;

    fps->magic = 0x1234;
    afps = (ArchFPsave *)ROUND(((uintptr)fps), FPalign);
    fpssesave0(afps);
    if (fps != afps)  /* not aligned? shuffle down from aligned buffer */
        memmove(fps, afps, sizeof(FPssestate));
    if (fps->magic != 0x1234)
        print("fpssesave: magic corrupted\n");
}

void
fpsserestore(ArchFPsave *fps)
{
    ArchFPsave *afps;

    fps->magic = 0x4321;
    afps = (ArchFPsave *)ROUND(((uintptr)fps), FPalign);
    if (fps != afps) {
        afps = m->fpsavalign;
        memmove(afps, fps, sizeof(FPssestate)); /* make aligned copy */
    }
    fpsserestore0(afps);
    if (fps->magic != 0x4321)
        print("fpsserestore: magic corrupted\n");
}

/*
 *  put the processor in the halt state if we've no processes to run.
 *  an interrupt will get us going again.
 */
void
idlehands(void)
{
    /*
     * we used to halt only on single-core setups. halting in an smp system 
     * can result in a startup latency for processes that become ready.
     * if idle_spin is zero, we care more about saving energy
     * than reducing this latency.
     *
     * the performance loss with idle_spin == 0 seems to be slight
     * and it reduces lock contention (thus system time and real time)
     * on many-core systems with large values of NPROC.
     */
    if(conf.nmach == 1 || idle_spin == 0 ||
        idle_if_nproc && conf.nmach >= idle_if_nproc)
        halt();
}
@


\subsection*{[[processes/386/mp.c]]}

<<mp.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"

#include "mp.h"
#include "apbootstrap.h"

//#define dprint(...)   if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
#define dprint if(mpdebug) print

/* from mpacpi.c */
extern Apic *bootapic;

int mpdebug;
extern void (*mpacpifunc)(void);

static PCMP* mppcmp;
static Bus* mpbus;
static Bus* mpbuslast;
static int mpisabus = -1;
static int mpeisabus = -1;
extern int i8259elcr;           /* mask of level-triggered interrupts */
/* static */ Apic mpapic[MaxAPICNO+1];
/* static */ int machno2apicno[MaxAPICNO+1];    /* inverse map: machno -> APIC ID */
/* static */ Apic ioapic[MaxAPICNO+1];
static Ref mpvnoref;            /* unique vector assignment */
static int mpmachno = 1;
static Lock mpphysidlock;
static int mpphysid;

static char* buses[] = {
    "CBUSI ",
    "CBUSII",
    "EISA  ",
    "FUTURE",
    "INTERN",
    "ISA   ",
    "MBI   ",
    "MBII  ",
    "MCA   ",
    "MPI   ",
    "MPSA  ",
    "NUBUS ",
    "PCI   ",
    "PCMCIA",
    "TC    ",
    "VL    ",
    "VME   ",
    "XPRESS",
    0,
};

static Apic*
mkprocessor(PCMPprocessor* p)
{
    int apicno;
    Apic *apic;

    apicno = p->apicno;
    if(!(p->flags & PcmpEN) || apicno > MaxAPICNO)
        return 0;

    apic = &mpapic[apicno];
    apic->type = PcmpPROCESSOR;
    apic->apicno = apicno;
    apic->flags = p->flags;
    apic->lintr[0] = ApicIMASK;
    apic->lintr[1] = ApicIMASK;

    if(p->flags & PcmpBP){
        machno2apicno[0] = apicno;
        apic->machno = 0;
    }
    else{
        machno2apicno[mpmachno] = apicno;
        apic->machno = mpmachno;
        mpmachno++;
    }

    return apic;
}

static Bus*
mkbus(PCMPbus* p)
{
    Bus *bus;
    int i;

    for(i = 0; buses[i]; i++){
        if(strncmp(buses[i], p->string, sizeof(p->string)) == 0)
            break;
    }
    if(buses[i] == 0)
        return 0;

    bus = xalloc(sizeof(Bus));
    if(mpbus)
        mpbuslast->next = bus;
    else
        mpbus = bus;
    mpbuslast = bus;

    bus->type = i;
    bus->busno = p->busno;
    if(bus->type == BusEISA){
        bus->po = PcmpLOW;
        bus->el = PcmpLEVEL;
        if(mpeisabus != -1)
            print("mkbus: more than one EISA bus\n");
        mpeisabus = bus->busno;
    }
    else if(bus->type == BusPCI){
        bus->po = PcmpLOW;
        bus->el = PcmpLEVEL;
    }
    else if(bus->type == BusISA){
        bus->po = PcmpHIGH;
        bus->el = PcmpEDGE;
        if(mpisabus != -1)
            print("mkbus: more than one ISA bus\n");
        mpisabus = bus->busno;
    }
    else{
        bus->po = PcmpHIGH;
        bus->el = PcmpEDGE;
    }

    return bus;
}

static Bus*
mpgetbus(int busno)
{
    Bus *bus;

    for(bus = mpbus; bus; bus = bus->next){
        if(bus->busno == busno)
            return bus;
    }
    print("mpgetbus: can't find bus %d\n", busno);

    return 0;
}

static Apic*
mkioapic(PCMPioapic* p)
{
    void *va;
    int apicno;
    Apic *apic;

    apicno = p->apicno;
    if(!(p->flags & PcmpEN) || apicno > MaxAPICNO)
        return 0;

    /*
     * Map the I/O APIC.
     */
    if((va = vmap(p->addr, 1024)) == nil)
        return 0;

    apic = &ioapic[apicno];
    apic->type = PcmpIOAPIC;
    apic->apicno = apicno;
    apic->addr = va;
    apic->paddr = p->addr;
    apic->flags = p->flags;

    return apic;
}

static Aintr*
mkiointr(PCMPintr* p)
{
    Bus *bus;
    Aintr *aintr;
    PCMPintr* pcmpintr;

    /*
     * According to the MultiProcessor Specification, a destination
     * I/O APIC of 0xFF means the signal is routed to all I/O APICs.
     * It's unclear how that can possibly be correct so treat it as
     * an error for now.
     */
    if(p->apicno == 0xFF)
        return 0;
    if((bus = mpgetbus(p->busno)) == 0)
        return 0;

    aintr = xalloc(sizeof(Aintr));
    aintr->intr = p;

    if(0)
        dprint("mkiointr: type %d intr type %d flags %#o "
            "bus %d irq %d apicno %d intin %d\n",
            p->type, p->intr, p->flags,
            p->busno, p->irq, p->apicno, p->intin);
    /*
     * Hack for Intel SR1520ML motherboard, which BIOS describes
     * the i82575 dual ethernet controllers incorrectly.
     */
    if(mppcmp && memcmp(mppcmp->product, "INTEL   X38MLST     ", 20) == 0){
        if(p->busno == 1 && p->intin == 16 && p->irq == 1){
            pcmpintr = malloc(sizeof(PCMPintr));
            if(pcmpintr == nil)
                panic("mkiointr: no memory");
            memmove(pcmpintr, p, sizeof(PCMPintr));
            print("mkiointr: %20.20s bus %d intin %d irq %d\n",
                (char*)mppcmp->product,
                pcmpintr->busno, pcmpintr->intin,
                pcmpintr->irq);
            pcmpintr->intin = 17;
            aintr->intr = pcmpintr;
        }
    }
    if ((unsigned)p->apicno >= nelem(mpapic))
        panic("mkiointr: apic %d out of range", p->apicno);
    aintr->apic = &ioapic[p->apicno];
    aintr->next = bus->aintr;
    bus->aintr = aintr;

    return aintr;
}

static int
mpintrinit(Bus* bus, PCMPintr* intr, int vno, int /*irq*/)
{
    int el, po, v;

    /*
     * Parse an I/O or Local APIC interrupt table entry and
     * return the encoded vector.
     */
    v = vno;

    po = intr->flags & PcmpPOMASK;
    el = intr->flags & PcmpELMASK;

    switch(intr->intr){

    default:                /* PcmpINT */
        v |= ApicFIXED;         /* no-op */
        break;

    case PcmpNMI:
        v |= ApicNMI;
        po = PcmpHIGH;
        el = PcmpEDGE;
        break;

    case PcmpSMI:
        v |= ApicSMI;
        break;

    case PcmpExtINT:
        v |= ApicExtINT;
        /*
         * The AMI Goliath doesn't boot successfully with it's LINTR0
         * entry which decodes to low+level. The PPro manual says ExtINT
         * should be level, whereas the Pentium is edge. Setting the
         * Goliath to edge+high seems to cure the problem. Other PPro
         * MP tables (e.g. ASUS P/I-P65UP5 have a entry which decodes
         * to edge+high, so who knows.
         * Perhaps it would be best just to not set an ExtINT entry at
         * all, it shouldn't be needed for SMP mode.
         */
        po = PcmpHIGH;
        el = PcmpEDGE;
        break;
    }

    /*
     */
    if(bus->type == BusEISA && !po && !el /*&& !(i8259elcr & (1<<irq))*/){
        po = PcmpHIGH;
        el = PcmpEDGE;
    }
    if(!po)
        po = bus->po;
    if(po == PcmpLOW)
        v |= ApicLOW;
    else if(po != PcmpHIGH){
        print("mpintrinit: bad polarity 0x%uX\n", po);
        return ApicIMASK;
    }

    if(!el)
        el = bus->el;
    if(el == PcmpLEVEL)
        v |= ApicLEVEL;
    else if(el != PcmpEDGE){
        print("mpintrinit: bad trigger 0x%uX\n", el);
        return ApicIMASK;
    }

    return v;
}

static int
mklintr(PCMPintr* p)
{
    Apic *apic;
    Bus *bus;
    int intin, v;

    /*
     * The offsets of vectors for LINT[01] are known to be
     * 0 and 1 from the local APIC vector space at VectorLAPIC.
     */
    if((bus = mpgetbus(p->busno)) == 0)
        return 0;
    intin = p->intin;

    /*
     * Pentium Pros have problems if LINT[01] are set to ExtINT
     * so just bag it, SMP mode shouldn't need ExtINT anyway.
     */
    if(p->intr == PcmpExtINT || p->intr == PcmpNMI)
        v = ApicIMASK;
    else
        v = mpintrinit(bus, p, VectorLAPIC+intin, p->irq);

    if(p->apicno == 0xFF){
        for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++){
            if((apic->flags & PcmpEN)
            && apic->type == PcmpPROCESSOR)
                apic->lintr[intin] = v;
        }
    }
    else{
        if ((unsigned)p->apicno >= nelem(mpapic))
            panic("mklintr: ioapic %d out of range", p->apicno);
        apic = &mpapic[p->apicno];
        if((apic->flags & PcmpEN) && apic->type == PcmpPROCESSOR)
            apic->lintr[intin] = v;
    }

    return v;
}

static void
checkmtrr(void)
{
    int i, vcnt;
    Mach *mach0;

    /*
     * If there are MTRR registers, snarf them for validation.
     */
    if(!(m->cpuiddx & Mtrr))
        return;

    rdmsr(0x0FE, &m->mtrrcap);
    rdmsr(0x2FF, &m->mtrrdef);
    if(m->mtrrcap & 0x0100){
        rdmsr(0x250, &m->mtrrfix[0]);
        rdmsr(0x258, &m->mtrrfix[1]);
        rdmsr(0x259, &m->mtrrfix[2]);
        for(i = 0; i < 8; i++)
            rdmsr(0x268+i, &m->mtrrfix[(i+3)]);
    }
    vcnt = m->mtrrcap & 0x00FF;
    if(vcnt > nelem(m->mtrrvar))
        vcnt = nelem(m->mtrrvar);
    for(i = 0; i < vcnt; i++)
        rdmsr(0x200+i, &m->mtrrvar[i]);

    /*
     * If not the bootstrap processor, compare.
     */
    if(m->machno == 0)
        return;

    mach0 = MACHP(0);
    if(mach0->mtrrcap != m->mtrrcap)
        print("mtrrcap%d: %lluX %lluX\n",
            m->machno, mach0->mtrrcap, m->mtrrcap);
    if(mach0->mtrrdef != m->mtrrdef)
        print("mtrrdef%d: %lluX %lluX\n",
            m->machno, mach0->mtrrdef, m->mtrrdef);
    for(i = 0; i < 11; i++){
        if(mach0->mtrrfix[i] != m->mtrrfix[i])
            print("mtrrfix%d: i%d: %lluX %lluX\n",
                m->machno, i, mach0->mtrrfix[i], m->mtrrfix[i]);
    }
    for(i = 0; i < vcnt; i++){
        if(mach0->mtrrvar[i] != m->mtrrvar[i])
            print("mtrrvar%d: i%d: %lluX %lluX\n",
                m->machno, i, mach0->mtrrvar[i], m->mtrrvar[i]);
    }
}

static void
squidboy(Apic* apic)
{
//  iprint("Hello Squidboy\n");

    machinit();
    fpsavealloc();
    mmuinit();

    cpuidentify();
    cpuidprint();
    checkmtrr();

    apic->online = 1;
    coherence();

    lapicinit(apic);
    lapiconline();
    syncclock();
    timersinit();

    fpoff();

    lock(&active);
    active.machs |= 1<<m->machno;
    unlock(&active);

    while(!active.thunderbirdsarego)
        microdelay(100);

    schedinit();
}

static void
mpstartap(Apic* apic)
{
    ulong *apbootp, *pdb, *pte;
    Mach *mach, *mach0;
    int i, machno;
    uchar *p;

    mach0 = MACHP(0);

    /*
     * Initialise the AP page-tables and Mach structure. The page-tables
     * are the same as for the bootstrap processor with the exception of
     * the PTE for the Mach structure.
     * Xspanalloc will panic if an allocation can't be made.
     */
    p = xspanalloc(4*BY2PG, BY2PG, 0);
    pdb = (ulong*)p;
    memmove(pdb, mach0->pdb, BY2PG);
    p += BY2PG;

    if((pte = mmuwalk(pdb, MACHADDR, 1, 0)) == nil)
        return;
    memmove(p, KADDR(PPN(*pte)), BY2PG);
    *pte = PADDR(p)|PTEWRITE|PTEVALID;
    if(mach0->havepge)
        *pte |= PTEGLOBAL;
    p += BY2PG;

    mach = (Mach*)p;
    if((pte = mmuwalk(pdb, MACHADDR, 2, 0)) == nil)
        return;
    *pte = PADDR(mach)|PTEWRITE|PTEVALID;
    if(mach0->havepge)
        *pte |= PTEGLOBAL;
    p += BY2PG;

    machno = apic->machno;
    MACHP(machno) = mach;
    mach->machno = machno;
    mach->pdb = pdb;
    mach->gdt = (Segdesc*)p;    /* filled by mmuinit */

    /*
     * Tell the AP where its kernel vector and pdb are.
     * The offsets are known in the AP bootstrap code.
     */
    apbootp = (ulong*)(APBOOTSTRAP+0x08);
    *apbootp++ = (ulong)squidboy;   /* assembler jumps here eventually */
    *apbootp++ = PADDR(pdb);
    *apbootp = (ulong)apic;

    /*
     * Universal Startup Algorithm.
     */
    p = KADDR(0x467);       /* warm-reset vector */
    *p++ = PADDR(APBOOTSTRAP);
    *p++ = PADDR(APBOOTSTRAP)>>8;
    i = (PADDR(APBOOTSTRAP) & ~0xFFFF)/16;
    /* code assumes i==0 */
    if(i != 0)
        print("mp: bad APBOOTSTRAP\n");
    *p++ = i;
    *p = i>>8;

    coherence();

    nvramwrite(0x0F, 0x0A); /* shutdown code: warm reset upon init ipi */
    lapicstartap(apic, PADDR(APBOOTSTRAP));
    for(i = 0; i < 1000; i++){
        if(apic->online)
            break;
        delay(10);
    }
    nvramwrite(0x0F, 0x00);
}

static void
trympacpi(void)
{
    if (mpacpifunc != nil) {
        print("mpinit: scanning acpi madt for extra cpus\n");
        (*mpacpifunc)();
    }
}

void
mpinit(void)
{
    int ncpu, cpuson;
    char *cp;
    PCMP *pcmp;
    uchar *e, *p;
    Apic *apic, *bpapic;
    void *va;

    mpdebug = getconf("*debugmp") != nil;
    i8259init();
    syncclock();

    bpapic = nil;
    cpuson = 0;

    if(_mp_ == 0) {
        /*
         * We can easily get processor info from ACPI, but
         * interrupt routing, etc. would require interpreting AML.
         */
        print("mpinit: no mp table found, assuming uniprocessor\n");
        archrevert();
        return;
    }
    pcmp = KADDR(_mp_->physaddr);

    /*
     * Map the local APIC.
     */
    if((va = vmap(pcmp->lapicbase, 1024)) == nil)
        return;
    mppcmp = pcmp;
    print("LAPIC: %#lux %#lux\n", pcmp->lapicbase, (ulong)va);

    /*
     * Run through the table saving information needed for starting
     * application processors and initialising any I/O APICs. The table
     * is guaranteed to be in order such that only one pass is necessary.
     */
    p = ((uchar*)pcmp)+sizeof(PCMP);
    e = ((uchar*)pcmp)+pcmp->length;
    while(p < e) switch(*p){

    default:
        print("mpinit: unknown PCMP type 0x%uX (e-p 0x%luX)\n",
            *p, e-p);
        while(p < e){
            print("%uX ", *p);
            p++;
        }
        break;

    case PcmpPROCESSOR:
        if(apic = mkprocessor((PCMPprocessor*)p)){
            /*
             * Must take a note of bootstrap processor APIC
             * now as it will be needed in order to start the
             * application processors later and there's no
             * guarantee that the bootstrap processor appears
             * first in the table before the others.
             */
            apic->addr = va;
            apic->paddr = pcmp->lapicbase;
            if(apic->flags & PcmpBP)
                bpapic = apic;
            cpuson++;
        }
        p += sizeof(PCMPprocessor);
        continue;

    case PcmpBUS:
        mkbus((PCMPbus*)p);
        p += sizeof(PCMPbus);
        continue;

    case PcmpIOAPIC:
        if(apic = mkioapic((PCMPioapic*)p))
            ioapicinit(apic, ((PCMPioapic*)p)->apicno);
        p += sizeof(PCMPioapic);
        continue;

    case PcmpIOINTR:
        mkiointr((PCMPintr*)p);
        p += sizeof(PCMPintr);
        continue;

    case PcmpLINTR:
        mklintr((PCMPintr*)p);
        p += sizeof(PCMPintr);
        continue;
    }

    dprint("mpinit: mp table describes %d cpus\n", cpuson);

    /* For now, always scan ACPI's MADT for processors that MP missed. */
    trympacpi();

    if (bpapic == nil)
        bpapic = bootapic;

    /*
     * No bootstrap processor, no need to go further.
     */
    if(bpapic == 0)
        return;
    bpapic->online = 1;

    lapicinit(bpapic);

    /*
     * These interrupts are local to the processor
     * and do not appear in the I/O APIC so it is OK
     * to set them now.
     */
    intrenable(IrqTIMER, lapicclock, 0, BUSUNKNOWN, "clock");
    intrenable(IrqERROR, lapicerror, 0, BUSUNKNOWN, "lapicerror");
    intrenable(IrqSPURIOUS, lapicspurious, 0, BUSUNKNOWN, "lapicspurious");
    lapiconline();

    checkmtrr();

    /*
     * Initialise the application processors.
     */
    if(cp = getconf("*ncpu")){
        ncpu = strtol(cp, 0, 0);
        if(ncpu < 1)
            ncpu = 1;
        else if(ncpu > MAXMACH)
            ncpu = MAXMACH;
    }
    else
        ncpu = MAXMACH;
    memmove((void*)APBOOTSTRAP, apbootstrap, sizeof(apbootstrap));
    for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++){
        if(ncpu <= 1)
            break;
        if((apic->flags & (PcmpBP|PcmpEN)) == PcmpEN
        && apic->type == PcmpPROCESSOR){
            mpstartap(apic);
            conf.nmach++;
            ncpu--;
        }
    }

    /*
     *  we don't really know the number of processors till
     *  here.
     *
     *  set conf.copymode here if nmach > 1.
     *  Should look for an ExtINT line and enable it.
     */
    if(X86FAMILY(m->cpuidax) == 3 || conf.nmach > 1)
        conf.copymode = 1;
}

static int
mpintrcpu(void)
{
    int i;

    /*
     * The bulk of this code was written ~1995, when there was
     * one architecture and one generation of hardware, the number
     * of CPUs was up to 4(8) and the choices for interrupt routing
     * were physical, or flat logical (optionally with lowest
     * priority interrupt). Logical mode hasn't scaled well with
     * the increasing number of packages/cores/threads, so the
     * fall-back is to physical mode, which works across all processor
     * generations, both AMD and Intel, using the APIC and xAPIC.
     *
     * Interrupt routing policy can be set here.
     * Currently, just assign each interrupt to a different CPU on
     * a round-robin basis. Some idea of the packages/cores/thread
     * topology would be useful here, e.g. to not assign interrupts
     * to more than one thread in a core, or to use a "noise" core.
     * But, as usual, Intel make that an onerous task. 
     */

    /*
     * temporary workaround for many-core intel (non-amd) systems:
     * always use cpu 0.  (TODO)
     */
    if(strncmp(m->cpuidid, "AuthenticAMD", 12) != 0 && conf.nmach > 8)
        return 0;

    lock(&mpphysidlock);
    for(;;){
        i = mpphysid++;
        if(mpphysid >= MaxAPICNO+1)
            mpphysid = 0;
        if(mpapic[i].online)
            break;
    }
    unlock(&mpphysidlock);

    return mpapic[i].apicno;
}

static int
mpintrenablex(Vctl* v, int tbdf)
{
    Bus *bus;
    Aintr *aintr;
    Apic *apic;
    Pcidev *pcidev;
    int bno, dno, hi, irq, lo, n, type, vno;
    char *typenm;

    /*
     * Find the bus.
     */
    type = BUSTYPE(tbdf);
    bno = BUSBNO(tbdf);
    dno = BUSDNO(tbdf);
    if(type == BusISA)
        bno = mpisabus;
    vno = -1;
    for(bus = mpbus; bus != nil; bus = bus->next){
        if(bus->type != type)
            continue;
        if(bus->busno == bno)
            break;
    }
    if(bus == nil){
        typenm = type < 0 || type >= nelem(buses)? "": buses[type];
        print("mpintrenablex: can't find bus type %d (%s) for irq %d "
            "%s busno %d\n", type, typenm, v->irq, v->name, bno);
        return -1;
    }

    /*
     * For PCI devices the interrupt pin (INT[ABCD]) and device
     * number are encoded into the entry irq field, so create something
     * to match on. The interrupt pin used by the device has to be
     * obtained from the PCI config space.
     */
    if(bus->type == BusPCI){
        pcidev = pcimatchtbdf(tbdf);
        if(pcidev != nil && (n = pcicfgr8(pcidev, PciINTP)) != 0)
            irq = (dno<<2)|(n-1);
        else
            irq = -1;
        //print("pcidev %#uX: irq %#uX v->irq %#uX\n", tbdf, irq, v->irq);
    }
    else
        irq = v->irq;

    /*
     * Find a matching interrupt entry from the list of interrupts
     * attached to this bus.
     */
    for(aintr = bus->aintr; aintr; aintr = aintr->next){
        if(aintr->intr->irq != irq)
            continue;
        if (0) {
            PCMPintr* p = aintr->intr;

            print("mpintrenablex: bus %d intin %d irq %d\n",
                p->busno, p->intin, p->irq);
        }
        /*
         * Check if already enabled. Multifunction devices may share
         * INT[A-D]# so, if already enabled, check the polarity matches
         * and the trigger is level.
         *
         * Should check the devices differ only in the function number,
         * but that can wait for the planned enable/disable rewrite.
         * The RDT read here is safe for now as currently interrupts
         * are never disabled once enabled.
         */
        apic = aintr->apic;
        ioapicrdtr(apic, aintr->intr->intin, 0, &lo);
        if(!(lo & ApicIMASK)){
            vno = lo & 0xFF;
//print("%s vector %d (!imask)\n", v->name, vno);
            n = mpintrinit(bus, aintr->intr, vno, v->irq);
            n |= ApicPHYSICAL;      /* no-op */
            lo &= ~(ApicRemoteIRR|ApicDELIVS);
            if(n != lo || !(n & ApicLEVEL)){
                print("mpintrenable: multiple botch irq%d, tbdf %uX, lo %8.8uX, n %8.8uX\n",
                    v->irq, tbdf, lo, n);
                return -1;
            }
            break;
        }

        /*
         * With the APIC a unique vector can be assigned to each
         * request to enable an interrupt. There are two reasons this
         * is a good idea:
         * 1) to prevent lost interrupts, no more than 2 interrupts
         *    should be assigned per block of 16 vectors (there is an
         *    in-service entry and a holding entry for each priority
         *    level and there is one priority level per block of 16
         *    interrupts).
         * 2) each input pin on the IOAPIC will receive a different
         *    vector regardless of whether the devices on that pin use
         *    the same IRQ as devices on another pin.
         */
        vno = VectorAPIC + (incref(&mpvnoref)-1)*8;
//print("%s vector %d (imask)\n", v->name, vno);
        if(vno > MaxVectorAPIC){
            print("mpintrenable: vno %d, irq %d, tbdf %uX\n",
                vno, v->irq, tbdf);
            return -1;
        }

        hi = mpintrcpu()<<24;
        lo = mpintrinit(bus, aintr->intr, vno, v->irq);
        //print("lo 0x%uX: busno %d intr %d vno %d irq %d elcr 0x%uX\n",
        //  lo, bus->busno, aintr->intr->irq, vno,
        //  v->irq, i8259elcr);
        if(lo & ApicIMASK)
            return -1;
        lo |= ApicPHYSICAL;         /* no-op */

        if((apic->flags & PcmpEN) && apic->type == PcmpIOAPIC)
            ioapicrdtw(apic, aintr->intr->intin, hi, lo);
        //else
        //  print("lo not enabled 0x%uX %d\n",
        //      apic->flags, apic->type);
        break;
    }
    if (aintr) {
        v->isr = lapicisr;
        v->eoi = lapiceoi;
    }
    return vno;
}

int
mpintrenable(Vctl* v)
{
    int irq, tbdf, vno;

    /*
     * If the bus is known, try it.
     * BUSUNKNOWN is given both by [E]ISA devices and by
     * interrupts local to the processor (local APIC, coprocessor
     * breakpoint and page-fault).
     */
    tbdf = v->tbdf;
    if(tbdf != BUSUNKNOWN && (vno = mpintrenablex(v, tbdf)) != -1)
        return vno;

    irq = v->irq;
    if(irq >= IrqLINT0 && irq <= MaxIrqLAPIC){
        if(irq != IrqSPURIOUS)
            v->isr = lapiceoi;
        return VectorPIC+irq;
    }
    if(irq < 0 || irq > MaxIrqPIC){
        print("mpintrenable: irq %d out of range\n", irq);
        return -1;
    }

    /*
     * Either didn't find it or have to try the default buses
     * (ISA and EISA). This hack is due to either over-zealousness 
     * or laziness on the part of some manufacturers.
     *
     * The MP configuration table on some older systems
     * (e.g. ASUS PCI/E-P54NP4) has an entry for the EISA bus
     * but none for ISA. It also has the interrupt type and
     * polarity set to 'default for this bus' which wouldn't
     * be compatible with ISA.
     */
    if(mpeisabus != -1){
        vno = mpintrenablex(v, MKBUS(BusEISA, 0, 0, 0));
        if(vno != -1)
            return vno;
    }
    if(mpisabus != -1){
        vno = mpintrenablex(v, MKBUS(BusISA, 0, 0, 0));
        if(vno != -1)
            return vno;
    }
    print("mpintrenable: out of choices eisa %d isa %d tbdf %#ux irq %d\n",
        mpeisabus, mpisabus, v->tbdf, v->irq);
    return -1;
}

static Lock mpshutdownlock;

void
mpshutdown(void)
{
    /*
     * To be done...
     */
    if(!canlock(&mpshutdownlock)){
        /*
         * If this processor received the CTRL-ALT-DEL from
         * the keyboard, acknowledge it. Send an INIT to self.
         */
#ifdef FIXTHIS
        if(lapicisr(VectorKBD))
            lapiceoi(VectorKBD);
#endif /* FIX THIS */
        arch->introff();
        idle();
    }

    if(active.rebooting)
        return;
    print("apshutdown: active = %#8.8ux\n", active.machs);
    delay(1000);
    splhi();
    arch->resetothers();

    pcireset();
    i8042reset();

    /*
     * Often the BIOS hangs during restart if a conventional 8042
     * warm-boot sequence is tried. The following is Intel specific and
     * seems to perform a cold-boot, but at least it comes back.
     * And sometimes there is no keyboard...
     *
     * The reset register (0xcf9) is usually in one of the bridge
     * chips. The actual location and sequence could be extracted from
     * ACPI but why bother, this is the end of the line anyway.
     */
    print("no kbd; trying bios warm boot...");
    *(ushort*)KADDR(0x472) = 0x1234;    /* BIOS warm-boot flag */
    outb(0xCF9, 0x02);
    outb(0xCF9, 0x06);

    print("can't reset\n");
    for(;;)
        idle();
}
@


\subsection*{[[processes/386/mpacpi.c]]}

<<mpacpi.c>>=
/*
 * minimal acpi support for multiprocessors.
 *
 * avoids AML but that's only enough to discover
 * the processors, not the interrupt routing details.
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "mp.h"
#include "mpacpi.h"

/* 8c says: out of fixed registers */
#define L64GET(p)   ((uvlong)L32GET((p)+4) << 32 | L32GET(p))

enum {
    /* apic types */
    Apiclproc,
    Apicio,
    Apicintrsrcoverride,
    Apicnmisrc,
    Apiclnmi,
    Apicladdroverride,
    Apicios,
    Apicls,
    Apicintrsrc,
    Apiclx2,
    Apiclx2nmi,

    PcmpUsed = 1ul<<31,     /* Apic->flags addition */

    Lapicbase = 0x1b,       /* msr */

    Lapicae = 1<<11,        /* apic enable in Lapicbase */
};

//#define dprint(...)   if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
#define dprint if(mpdebug) print

/* from mp.c */
extern int  mpdebug;
int mpmachno; //PAD: bug? also declared in mp.c
extern Apic mpapic[MaxAPICNO+1];
extern int  machno2apicno[MaxAPICNO+1]; /* inverse map: machno -> APIC ID */

Apic    *bootapic;

static int nprocid;

static uvlong
l64get(uchar *p)
{
    return L64GET(p);
}

int
apicset(Apic *apic, int type, int apicno, int f)
{
    if(apicno > MaxAPICNO)
        return -1;
    apic->type = type;
    apic->apicno = apicno;
    apic->flags = f | PcmpEN | PcmpUsed;
    return 0;
}

int
mpnewproc(Apic *apic, int apicno, int f)
{
    if(apic->flags & PcmpUsed) {
        print("mpnewproc: apic already enabled\n");
        return -1;
    }
    if (apicset(apic, PcmpPROCESSOR, apicno, f) < 0)
        return -1;
    apic->lintr[1] = apic->lintr[0] = ApicIMASK;
    /* botch! just enumerate */
    if(apic->flags & PcmpBP)
        apic->machno = 0;
    else
        apic->machno = ++mpmachno;
    machno2apicno[apic->machno] = apicno;
    return 0;
}

static int
mpacpiproc(uchar *p, ulong laddr)
{
    int id, f;
    ulong *vladdr;
    vlong base;
    char *already;
    Apic *apic;

    /* p bytes: type (0), len (8), cpuid, cpu_lapic id, flags[4] */
    id = p[3];
    /* cpu unusable flag or id out of range? */
    if((L32GET(p+4) & 1) == 0 || id > MaxAPICNO)
        return -1;

    vladdr = nil;
    already = "";
    f = 0;
    apic = &mpapic[id];
    dprint("\tmpacpiproc: apic %#p\n", apic);
    apic->paddr = laddr;
    if (nprocid++ == 0) {
        f = PcmpBP;
        vladdr = vmap(apic->paddr, 1024);
        if(apic->addr == nil){
            print("proc apic %d: failed to map %#p\n", id,
                apic->paddr);
            already = "(fail)";
        }
        bootapic = apic;
    }
    apic->addr = vladdr;

    if(apic->flags & PcmpUsed)
        already = "(on)";
    else
        mpnewproc(apic, id, f);

    if (0)
        dprint("\tapic proc %d/%d apicid %d flags%s%s %s\n", nprocid-1,
            apic->machno, id, f & PcmpBP? " boot": "",
            f & PcmpEN? " enabled": "", already);
    USED(already);

    rdmsr(Lapicbase, &base);
    if (!(base & Lapicae)) {
        dprint("mpacpiproc: enabling lapic\n");
        wrmsr(Lapicbase, base | Lapicae);
    }
    return 0;
}

static void
mpacpicpus(Madt *madt)
{
    int i, n;
    ulong laddr;
    uchar *p;

    laddr = L32GET(madt->addr);
    dprint("APIC mpacpicpus(%#p) lapic addr %#lux, flags %#ux\n",
        madt, laddr, L32GET(madt->flags));

    n = L32GET(&madt->sdthdr[4]);
    p = madt->structures;
    dprint("\t%d structures at %#p\n",n, p);
    /* byte 0 is assumed to be type, 1 is assumed to be length */
    for(i = offsetof(Madt, structures[0]); i < n; i += p[1], p += p[1])
        switch(p[0]){
        case Apiclproc:
            mpacpiproc(p, laddr);
            break;
        }
}

/* returns nil iff checksum is bad */
static void *
mpacpirsdchecksum(void* addr, int length)
{
    uchar *p, sum;

    sum = 0;
    for(p = addr; length-- > 0; p++)
        sum += *p;
    return sum == 0? addr: nil;
}

/* call func for each acpi table found */
static void
mpacpiscan(void (*func)(uchar *))
{
    int asize, i, tbllen, sdtlen;
    uintptr dhpa, sdtpa;
    uchar *tbl, *sdt;
    Rsd *rsd;

    dprint("ACPI...");
    if((rsd = sigsearch("RSD PTR ")) == nil) {
        dprint("none\n");
        return;
    }

    dprint("rsd %#p physaddr %#ux length %ud %#llux rev %d oem %.6s\n",
        rsd, L32GET(rsd->raddr), L32GET(rsd->length),
        l64get(rsd->xaddr), rsd->revision, (char*)rsd->oemid);

    if(rsd->revision == 2){
        if(mpacpirsdchecksum(rsd, 36) == nil)
            return;
        asize = 8;
        sdtpa = l64get(rsd->xaddr);
    } else {
        if(mpacpirsdchecksum(rsd, 20) == nil)
            return;
        asize = 4;
        sdtpa = L32GET(rsd->raddr);
    }

    if((sdt = vmap(sdtpa, 8)) == nil)
        return;
    if((sdt[0] != 'R' && sdt[0] != 'X') || memcmp(sdt+1, "SDT", 3) != 0){
        vunmap(sdt, 8);
        return;
    }
    sdtlen = L32GET(sdt + 4);
    vunmap(sdt, 8);

    if((sdt = vmap(sdtpa, sdtlen)) == nil)
        return;
    if(mpacpirsdchecksum(sdt, sdtlen) != nil)
        for(i = 36; i < sdtlen; i += asize){
            if(asize == 8)
                dhpa = l64get(sdt+i);
            else
                dhpa = L32GET(sdt+i);
    
            if((tbl = vmap(dhpa, 8)) == nil)
                continue;
            tbllen = L32GET(tbl + 4);
            vunmap(tbl, 8);
    
            if((tbl = vmap(dhpa, tbllen)) == nil)
                continue;
            if(mpacpirsdchecksum(tbl, tbllen) != nil)
                (*func)(tbl);
            vunmap(tbl, tbllen);
        }
    vunmap(sdt, sdtlen);
}

static void
mpacpitbl(uchar *p)
{
    /* for now, just activate any idle cpus */
    if (memcmp(p, "APIC", 4) == 0)
        mpacpicpus((Madt *)p);
}

static void
mpacpi(void)
{
    mpdebug = getconf("*debugmp") != nil;
    mpacpiscan(mpacpitbl);
}

void    (*mpacpifunc)(void) = mpacpi;
@


\subsection*{[[processes/386/trap.c]]}

<<trap.c>>=
#include    "u.h"
#include    "tos.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    "io.h"
#include    "ureg.h"
#include    "../port/error.h"
#include    <trace.h>

//*****************************************************************************
// Globals
//*****************************************************************************

static int trapinited;

static Lock vctllock;
static Vctl *vctl[256];

enum
{
    Ntimevec = 20       /* number of time buckets for each intr */
};
ulong intrtimes[256][Ntimevec];

//*****************************************************************************
// Forward decl
//*****************************************************************************

void    noted(Ureg*, ulong);
int     notify(Ureg*);
void        dumpregs(Ureg*);

static void debugbpt(Ureg*, void*);
static void fault386(Ureg*, void*);
static void doublefault(Ureg*, void*);
static void unexpected(Ureg*, void*);
static void _dumpstack(Ureg*);

//*****************************************************************************
// Interrupts enable/disable
//*****************************************************************************

void
intrenable(int irq, void (*f)(Ureg*, void*), void* a, int tbdf, char *name)
{
    int vno;
    Vctl *v;

    if(f == nil){
        print("intrenable: nil handler for %d, tbdf 0x%uX for %s\n",
            irq, tbdf, name);
        return;
    }

    v = xalloc(sizeof(Vctl));
    v->isintr = true;
    v->irq = irq;
    v->tbdf = tbdf;
    v->f = f;
    v->a = a;
    strncpy(v->name, name, KNAMELEN-1);
    v->name[KNAMELEN-1] = 0;

    ilock(&vctllock);
    vno = arch->intrenable(v);
    if(vno == -1){
        iunlock(&vctllock);
        print("intrenable: couldn't enable irq %d, tbdf 0x%uX for %s\n",
            irq, tbdf, v->name);
        xfree(v);
        return;
    }
    if(vctl[vno]){
        if(vctl[vno]->isr != v->isr || vctl[vno]->eoi != v->eoi)
            panic("intrenable: handler: %s %s %#p %#p %#p %#p",
                vctl[vno]->name, v->name,
                vctl[vno]->isr, v->isr, vctl[vno]->eoi, v->eoi);
        v->next = vctl[vno];
    }
    vctl[vno] = v;
    iunlock(&vctllock);
}

int
intrdisable(int irq, void (*f)(Ureg *, void *), void *a, int tbdf, char *name)
{
    Vctl **pv, *v;
    int vno;

    /*
     * For now, none of this will work with the APIC code,
     * there is no mapping between irq and vector as the IRQ
     * is pretty meaningless.
     */
    if(arch->intrvecno == nil)
        return -1;
    vno = arch->intrvecno(irq);
    ilock(&vctllock);
    pv = &vctl[vno];
    while (*pv &&
          ((*pv)->irq != irq || (*pv)->tbdf != tbdf || (*pv)->f != f || (*pv)->a != a ||
           strcmp((*pv)->name, name)))
        pv = &((*pv)->next);
    assert(*pv);

    v = *pv;
    *pv = (*pv)->next;  /* Link out the entry */

    if(vctl[vno] == nil && arch->intrdisable != nil)
        arch->intrdisable(irq);
    iunlock(&vctllock);
    xfree(v);
    return 0;
}

//*****************************************************************************
// Init
//*****************************************************************************

static long
irqallocread(Chan*, void *vbuf, long n, vlong offset)
{
    char *buf, *p, str[2*(11+1)+KNAMELEN+1+1];
    int m, vno;
    long oldn;
    Vctl *v;

    if(n < 0 || offset < 0)
        error(Ebadarg);

    oldn = n;
    buf = vbuf;
    for(vno=0; vno<nelem(vctl); vno++){
        for(v=vctl[vno]; v; v=v->next){
            m = snprint(str, sizeof str, "%11d %11d %.*s\n", vno, v->irq, KNAMELEN, v->name);
            if(m <= offset) /* if do not want this, skip entry */
                offset -= m;
            else{
                /* skip offset bytes */
                m -= offset;
                p = str+offset;
                offset = 0;

                /* write at most max(n,m) bytes */
                if(m > n)
                    m = n;
                memmove(buf, p, m);
                n -= m;
                buf += m;

                if(n == 0)
                    return oldn;
            }
        }
    }
    return oldn - n;
}

void
trapenable(int vno, void (*f)(Ureg*, void*), void* a, char *name)
{
    Vctl *v;

    if(vno < 0 || vno >= VectorPIC)
        panic("trapenable: vno %d", vno);
    v = xalloc(sizeof(Vctl));
    v->tbdf = BUSUNKNOWN;
    v->f = f;
    v->a = a;
    strncpy(v->name, name, KNAMELEN);
    v->name[KNAMELEN-1] = 0;

    ilock(&vctllock);
    v->next = vctl[vno];
    vctl[vno] = v;
    iunlock(&vctllock);
}

static void
nmienable(void)
{
    int x;

    /*
     * Hack: should be locked with NVRAM access.
     */
    outb(0x70, 0x80);       /* NMI latch clear */
    outb(0x70, 0);

    x = inb(0x61) & 0x07;       /* Enable NMI */
    outb(0x61, 0x08|x);
    outb(0x61, x);
}

/*
 * Minimal trap setup.  Just enough so that we can panic
 * on traps (bugs) during kernel initialization.
 * Called very early - malloc is not yet available.
 */
void
trapinit0(void)
{
    int d1, v;
    ulong vaddr;
    Segdesc *idt;

    idt = (Segdesc*)IDTADDR;
    vaddr = (ulong)vectortable;
    for(v = 0; v < 256; v++){
        d1 = (vaddr & 0xFFFF0000)|SEGP;
        switch(v){

        case VectorBPT:
            d1 |= SEGPL(3)|SEGIG;
            break;

        case VectorSYSCALL:
            d1 |= SEGPL(3)|SEGIG;
            break;

        default:
            d1 |= SEGPL(0)|SEGIG;
            break;
        }
        idt[v].d0 = (vaddr & 0xFFFF)|(KESEL<<16);
        idt[v].d1 = d1;
        vaddr += 6;
    }
}

void
trapinit(void)
{
    /*
     * Special traps.
     * Syscall() is called directly without going through trap().
     */
    trapenable(VectorBPT, debugbpt, 0, "debugpt");
    trapenable(VectorPF, fault386, 0, "fault386");
    trapenable(Vector2F, doublefault, 0, "doublefault");
    trapenable(Vector15, unexpected, 0, "unexpected");
    nmienable();

    addarchfile("irqalloc", 0444, irqallocread, nil);
    trapinited = 1;
}

//*****************************************************************************
// Misc
//*****************************************************************************

static char* excname[32] = {
    "divide error",
    "debug exception",
    "nonmaskable interrupt",
    "breakpoint",
    "overflow",
    "bounds check",
    "invalid opcode",
    "coprocessor not available",
    "double fault",
    "coprocessor segment overrun",
    "invalid TSS",
    "segment not present",
    "stack exception",
    "general protection violation",
    "page fault",
    "15 (reserved)",
    "coprocessor error",
    "alignment check",
    "machine check",
    "19 (reserved)",
    "20 (reserved)",
    "21 (reserved)",
    "22 (reserved)",
    "23 (reserved)",
    "24 (reserved)",
    "25 (reserved)",
    "26 (reserved)",
    "27 (reserved)",
    "28 (reserved)",
    "29 (reserved)",
    "30 (reserved)",
    "31 (reserved)",
};

/*
 *  keep histogram of interrupt service times
 */
void
intrtime(Mach*, int vno)
{
    ulong diff;
    ulong x;

    x = perfticks();
    diff = x - m->perf.intrts;
    m->perf.intrts = x;

    m->perf.inintr += diff;
    if(up == nil && m->perf.inidle > diff)
        m->perf.inidle -= diff;

    diff /= m->cpumhz*100;      /* quantum = 100Âµsec */
    if(diff >= Ntimevec)
        diff = Ntimevec-1;
    intrtimes[vno][diff]++;
}

/* go to user space */
void
kexit(Ureg*)
{
    uvlong t;
    Tos *tos;

    /* precise time accounting, kernel exit */
    tos = (Tos*)(USTKTOP-sizeof(Tos));
    cycles(&t);
    tos->kcycles += t - up->kentry;
    tos->pcycles = up->pcycles;
    tos->pid = up->pid;
}

/*
 *  All traps come here.  It is slower to have all traps call trap()
 *  rather than directly vectoring the handler. However, this avoids a
 *  lot of code duplication and possible bugs. The only exception is
 *  VectorSYSCALL.
 *  Trap is called with interrupts disabled via interrupt-gates.
 */
//@Scheck: Assembly, not dead, called from assembly
void
trap(Ureg* ureg)
{
    int clockintr, i, vno, user;
    char buf[ERRMAX];
    Vctl *ctl, *v;
    Mach *mach;

    if(!trapinited){
        /* fault386 can give a better error message */
        if(ureg->trap == VectorPF)
            fault386(ureg, nil);
        panic("trap %lud: not ready", ureg->trap);
    }

    m->perf.intrts = perfticks();
    user = (ureg->cs & 0xFFFF) == UESEL;
    if(user){
        up->dbgreg = ureg;
        cycles(&up->kentry);
    }

    clockintr = 0;

    vno = ureg->trap;
    if(ctl = vctl[vno]){
        if(ctl->isintr){
            m->intr++;
            if(vno >= VectorPIC && vno != VectorSYSCALL)
                m->lastintr = ctl->irq;
        }

        if(ctl->isr)
            ctl->isr(vno);
        for(v = ctl; v != nil; v = v->next){
            if(v->f)
                v->f(ureg, v->a);
        }
        if(ctl->eoi)
            ctl->eoi(vno);

        if(ctl->isintr){
            intrtime(m, vno);

            if(ctl->irq == IrqCLOCK || ctl->irq == IrqTIMER)
                clockintr = 1;

            if(up && !clockintr)
                preempted();
        }
    }
    else if(vno < nelem(excname) && user){
        spllo();
        snprint(buf, sizeof buf, "sys: trap: %s", excname[vno]);
        postnote(up, 1, buf, NDebug);
    }
    else if(vno >= VectorPIC && vno != VectorSYSCALL){
        /*
         * An unknown interrupt.
         * Check for a default IRQ7. This can happen when
         * the IRQ input goes away before the acknowledge.
         * In this case, a 'default IRQ7' is generated, but
         * the corresponding bit in the ISR isn't set.
         * In fact, just ignore all such interrupts.
         */

        /* call all interrupt routines, just in case */
        for(i = VectorPIC; i <= MaxIrqLAPIC; i++){
            ctl = vctl[i];
            if(ctl == nil)
                continue;
            if(!ctl->isintr)
                continue;
            for(v = ctl; v != nil; v = v->next){
                if(v->f)
                    v->f(ureg, v->a);
            }
            /* should we do this? */
            if(ctl->eoi)
                ctl->eoi(i);
        }

        /* clear the interrupt */
        i8259isr(vno);

        if(0)print("cpu%d: spurious interrupt %d, last %d\n",
            m->machno, vno, m->lastintr);
        if(0)if(conf.nmach > 1){
            for(i = 0; i < 32; i++){
                if(!(active.machs & (1<<i)))
                    continue;
                mach = MACHP(i);
                if(m->machno == mach->machno)
                    continue;
                print(" cpu%d: last %d",
                    mach->machno, mach->lastintr);
            }
            print("\n");
        }
        m->spuriousintr++;
        if(user)
            kexit(ureg);
        return;
    }
    else{
        if(vno == VectorNMI){
            /*
             * Don't re-enable, it confuses the crash dumps.
            nmienable();
             */
            iprint("cpu%d: NMI PC %#8.8lux\n", m->machno, ureg->pc);
            while(m->machno != 0)
                ;
        }
        dumpregs(ureg);
        if(!user){
            ureg->sp = (ulong)&ureg->sp;
            _dumpstack(ureg);
        }
        if(vno < nelem(excname))
            panic("%s", excname[vno]);
        panic("unknown trap/intr: %d", vno);
    }
    splhi();

    /* delaysched set because we held a lock or because our quantum ended */
    if(up && up->delaysched && clockintr){
        sched();
        splhi();
    }

    if(user){
        if(up->procctl || up->nnote)
            notify(ureg);
        kexit(ureg);
    }
}

/*
 *  dump registers
 */
void
dumpregs2(Ureg* ureg)
{
    if(up)
        iprint("cpu%d: registers for %s %lud\n",
            m->machno, up->text, up->pid);
    else
        iprint("cpu%d: registers for kernel\n", m->machno);
    iprint("FLAGS=%luX TRAP=%luX ECODE=%luX PC=%luX",
        ureg->flags, ureg->trap, ureg->ecode, ureg->pc);
    iprint(" SS=%4.4luX USP=%luX\n", ureg->ss & 0xFFFF, ureg->usp);
    iprint("  AX %8.8luX  BX %8.8luX  CX %8.8luX  DX %8.8luX\n",
        ureg->ax, ureg->bx, ureg->cx, ureg->dx);
    iprint("  SI %8.8luX  DI %8.8luX  BP %8.8luX\n",
        ureg->si, ureg->di, ureg->bp);
    iprint("  CS %4.4luX  DS %4.4luX  ES %4.4luX  FS %4.4luX  GS %4.4luX\n",
        ureg->cs & 0xFFFF, ureg->ds & 0xFFFF, ureg->es & 0xFFFF,
        ureg->fs & 0xFFFF, ureg->gs & 0xFFFF);
}

void
dumpregs(Ureg* ureg)
{
    vlong mca, mct;

    dumpregs2(ureg);

    /*
     * Processor control registers.
     * If machine check exception, time stamp counter, page size extensions
     * or enhanced virtual 8086 mode extensions are supported, there is a
     * CR4. If there is a CR4 and machine check extensions, read the machine
     * check address and machine check type registers if RDMSR supported.
     */
    iprint("  CR0 %8.8lux CR2 %8.8lux CR3 %8.8lux",
        getcr0(), getcr2(), getcr3());
    if(m->cpuiddx & (Mce|Tsc|Pse|Vmex)){
        iprint(" CR4 %8.8lux", getcr4());
        if((m->cpuiddx & (Mce|Cpumsr)) == (Mce|Cpumsr)){
            rdmsr(0x00, &mca);
            rdmsr(0x01, &mct);
            iprint("\n  MCA %8.8llux MCT %8.8llux", mca, mct);
        }
    }
    iprint("\n  ur %#p up %#p\n", ureg, up);
}


/*
 * Fill in enough of Ureg to get a stack trace, and call a function.
 * Used by debugging interface rdb.
 */
void
callwithureg(void (*fn)(Ureg*))
{
    Ureg ureg;
    ureg.pc = getcallerpc(&fn);
    ureg.sp = (ulong)&fn;
    fn(&ureg);
}

static void
_dumpstack(Ureg *ureg)
{
    uintptr l, v, i, estack;
    extern ulong etext;
    int x;
    char *s;

    if((s = getconf("*nodumpstack")) != nil && strcmp(s, "0") != 0){
        iprint("dumpstack disabled\n");
        return;
    }
    iprint("dumpstack\n");

    x = 0;
    x += iprint("ktrace /kernel/path %.8lux %.8lux <<EOF\n", ureg->pc, ureg->sp);
    i = 0;
    if(up
    && (uintptr)&l >= (uintptr)up->kstack
    && (uintptr)&l <= (uintptr)up->kstack+KSTACK)
        estack = (uintptr)up->kstack+KSTACK;
    else if((uintptr)&l >= (uintptr)m->stack
    && (uintptr)&l <= (uintptr)m+MACHSIZE)
        estack = (uintptr)m+MACHSIZE;
    else
        return;
    x += iprint("estackx %p\n", estack);

    for(l = (uintptr)&l; l < estack; l += sizeof(uintptr)){
        v = *(uintptr*)l;
        if((KTZERO < v && v < (uintptr)&etext) || estack-l < 32){
            /*
             * Could Pick off general CALL (((uchar*)v)[-5] == 0xE8)
             * and CALL indirect through AX
             * (((uchar*)v)[-2] == 0xFF && ((uchar*)v)[-2] == 0xD0),
             * but this is too clever and misses faulting address.
             */
            x += iprint("%.8p=%.8p ", l, v);
            i++;
        }
        if(i == 4){
            i = 0;
            x += iprint("\n");
        }
    }
    if(i)
        iprint("\n");
    iprint("EOF\n");

    if(ureg->trap != VectorNMI)
        return;

    i = 0;
    for(l = (uintptr)&l; l < estack; l += sizeof(uintptr)){
        iprint("%.8p ", *(uintptr*)l);
        if(++i == 8){
            i = 0;
            iprint("\n");
        }
    }
    if(i)
        iprint("\n");
}

void
trap_dumpstack(void)
{
    callwithureg(_dumpstack);
}

static void
debugbpt(Ureg* ureg, void*)
{
    char buf[ERRMAX];

    if(up == 0)
        panic("kernel bpt");
    /* restore pc to instruction that caused the trap */
    ureg->pc--;
    snprint(buf, sizeof buf, "sys: breakpoint");
    postnote(up, 1, buf, NDebug);
}

static void
doublefault(Ureg*, void*)
{
    panic("double fault");
}

static void
unexpected(Ureg* ureg, void*)
{
    print("unexpected trap %lud; ignoring\n", ureg->trap);
}

extern void checkpages(void);
extern void checkfault(ulong, ulong);

static void
fault386(Ureg* ureg, void*)
{
    ulong addr;
    int read, user, n, insyscall;
    char buf[ERRMAX];

    addr = getcr2();
    read = !(ureg->ecode & 2);

    user = (ureg->cs & 0xFFFF) == UESEL;
    if(!user){
        if(vmapsync(addr))
            return;
        if(addr >= USTKTOP)
            panic("kernel fault: bad address pc=0x%.8lux addr=0x%.8lux", ureg->pc, addr);
        if(up == nil)
            panic("kernel fault: no user process pc=0x%.8lux addr=0x%.8lux", ureg->pc, addr);
    }
    if(up == nil)
        panic("user fault: up=0 pc=0x%.8lux addr=0x%.8lux", ureg->pc, addr);

    insyscall = up->insyscall;
    up->insyscall = 1;
    n = fault(addr, read);
    if(n < 0){
        if(!user){
            dumpregs(ureg);
            panic("fault: 0x%lux", addr);
        }
        checkpages();
        checkfault(addr, ureg->pc);
        snprint(buf, sizeof buf, "sys: trap: fault %s addr=0x%lux",
            read ? "read" : "write", addr);
        postnote(up, 1, buf, NDebug);
    }
    up->insyscall = insyscall;
}

//*****************************************************************************
// Syscall
//*****************************************************************************

/*
 *  system calls
 */
#include "../port/systab.h"

/*
 *  Syscall is called directly from assembler without going through trap().
 */
//@Scheck: no dead, called from assembly by syscall/386/plan9l.s
void
syscall(Ureg* ureg)
{
    char *e;
    ulong   sp;
    long    ret;
    int i, s;
    ulong scallnr;
    vlong startns, stopns;

    if((ureg->cs & 0xFFFF) != UESEL)
        panic("syscall: cs 0x%4.4luX", ureg->cs);

    cycles(&up->kentry);

    m->syscall++;
    up->insyscall = true;
    up->pc = ureg->pc;
    up->dbgreg = ureg;

    sp = ureg->usp;
        // syscall number
    scallnr = ureg->ax;
    up->scallnr = scallnr;

    if(up->procctl == Proc_tracesyscall){
        /*
         * Redundant validaddr.  Do we care?
         * Tracing syscalls is not exactly a fast path...
         * Beware, validaddr currently does a pexit rather
         * than an error if there's a problem; that might
         * change in the future.
         */
        if(sp < (USTKTOP-BY2PG) || sp > (USTKTOP-sizeof(Sargs)-BY2WD))
            validaddr(sp, sizeof(Sargs)+BY2WD, 0);

        syscallfmt(scallnr, ureg->pc, (va_list)(sp+BY2WD));
        up->procctl = Proc_stopme;
        procctl(up);
        if(up->syscalltrace)
            free(up->syscalltrace);
        up->syscalltrace = nil;
        startns = todget(nil);
    }

    if(scallnr == RFORK && up->fpstate == FPactive){
        fpsave(&up->fpsave);
        up->fpstate = FPinactive;
    }
    spllo();

    up->nerrlab = 0;
    ret = -1;
    if(!waserror()){
        if(scallnr >= nsyscall || systab[scallnr] == 0){
            pprint("bad sys call number %lud pc %lux\n",
                scallnr, ureg->pc);
            postnote(up, 1, "sys: bad sys call", NDebug);
            error(Ebadarg);
        }

        if(sp<(USTKTOP-BY2PG) || sp>(USTKTOP-sizeof(Sargs)-BY2WD))
            validaddr(sp, sizeof(Sargs)+BY2WD, 0);

        up->s = *((Sargs*)(sp+BY2WD));
        up->psstate = sysctab[scallnr];

                //IMPORTANT: The actual system call
        ret = systab[scallnr](up->s.args);
        poperror();
    }else{
        /* failure: save the error buffer for errstr */
        e = up->syserrstr;
        up->syserrstr = up->errstr;
        up->errstr = e;
        if(0 && up->pid == 1)
            print("syscall %lud error %s\n", scallnr, up->syserrstr);
    }
    if(up->nerrlab){
        print("bad errstack [%lud]: %d extra\n", scallnr, up->nerrlab);
        for(i = 0; i < NERR; i++)
            print("sp=%lux pc=%lux\n",
                up->errlab[i].sp, up->errlab[i].pc);
        panic("error stack");
    }

    /*
     *  Put return value in frame.  On the x86 the syscall is
     *  just another trap and the return value from syscall is
     *  ignored.  On other machines the return value is put into
     *  the results register by caller of syscall.
     */
    ureg->ax = ret;

    if(up->procctl == Proc_tracesyscall){
        stopns = todget(nil);
        up->procctl = Proc_stopme;
        sysretfmt(scallnr, (va_list)(sp+BY2WD), ret, startns, stopns);
        s = splhi();
        procctl(up);
        splx(s);
        if(up->syscalltrace)
            free(up->syscalltrace);
        up->syscalltrace = nil;
    }

    up->insyscall = false;
    up->psstate = nil;

    if(scallnr == NOTED)
        noted(ureg, *(ulong*)(sp+BY2WD));

    if(scallnr!=RFORK && (up->procctl || up->nnote)){
        splhi();
        notify(ureg);
    }
    /* if we delayed sched because we held a lock, sched now */
    if(up->delaysched)
        sched();
    kexit(ureg);
}

/*
 *  Call user, if necessary, with note.
 *  Pass user the Ureg struct and the note on his stack.
 */
int
notify(Ureg* ureg)
{
    int l;
    ulong s, sp;
    Note *n;

    if(up->procctl)
        procctl(up);
    if(up->nnote == 0)
        return 0;

    if(up->fpstate == FPactive){
        fpsave(&up->fpsave);
        up->fpstate = FPinactive;
    }
    up->fpstate |= FPillegal;

    s = spllo();
    qlock(&up->debug);
    up->notepending = 0;
    n = &up->note[0];
    if(strncmp(n->msg, "sys:", 4) == 0){
        l = strlen(n->msg);
        if(l > ERRMAX-15)   /* " pc=0x12345678\0" */
            l = ERRMAX-15;
        seprint(n->msg+l, &n->msg[sizeof n->msg], " pc=0x%.8lux",
            ureg->pc);
    }

    if(n->flag!=NUser && (up->notified || up->notify==0)){
        if(n->flag == NDebug)
            pprint("suicide: %s\n", n->msg);
        qunlock(&up->debug);
        pexit(n->msg, n->flag!=NDebug);
    }

    if(up->notified){
        qunlock(&up->debug);
        splhi();
        return 0;
    }

    if(!up->notify){
        qunlock(&up->debug);
        pexit(n->msg, n->flag!=NDebug);
    }
    sp = ureg->usp;
    sp -= 256;  /* debugging: preserve context causing problem */
    sp -= sizeof(Ureg);
if(0) print("%s %lud: notify %.8lux %.8lux %.8lux %s\n",
    up->text, up->pid, ureg->pc, ureg->usp, sp, n->msg);

    if(!okaddr((ulong)up->notify, 1, 0)
    || !okaddr(sp-ERRMAX-4*BY2WD, sizeof(Ureg)+ERRMAX+4*BY2WD, 1)){
        qunlock(&up->debug);
        pprint("suicide: bad address in notify\n");
        pexit("Suicide", 0);
    }

    memmove((Ureg*)sp, ureg, sizeof(Ureg));
    *(Ureg**)(sp-BY2WD) = up->ureg; /* word under Ureg is old up->ureg */
    up->ureg = (void*)sp;
    sp -= BY2WD+ERRMAX;
    memmove((char*)sp, up->note[0].msg, ERRMAX);
    sp -= 3*BY2WD;
    *(ulong*)(sp+2*BY2WD) = sp+3*BY2WD;     /* arg 2 is string */
    *(ulong*)(sp+1*BY2WD) = (ulong)up->ureg;    /* arg 1 is ureg* */
    *(ulong*)(sp+0*BY2WD) = 0;          /* arg 0 is pc */
    ureg->usp = sp;
    ureg->pc = (ulong)up->notify;
    up->notified = 1;
    up->nnote--;
    memmove(&up->lastnote, &up->note[0], sizeof(Note));
    memmove(&up->note[0], &up->note[1], up->nnote*sizeof(Note));

    qunlock(&up->debug);
    splx(s);
    return 1;
}

/*
 *   Return user to state before notify()
 */
void
noted(Ureg* ureg, ulong arg0)
{
    Ureg *nureg;
    ulong oureg, sp;

    qlock(&up->debug);
    if(arg0!=NRSTR && !up->notified) {
        qunlock(&up->debug);
        pprint("call to noted() when not notified\n");
        pexit("Suicide", 0);
    }
    up->notified = 0;

    nureg = up->ureg;   /* pointer to user returned Ureg struct */

    up->fpstate &= ~FPillegal;

    /* sanity clause */
    oureg = (ulong)nureg;
    if(!okaddr((ulong)oureg-BY2WD, BY2WD+sizeof(Ureg), 0)){
        qunlock(&up->debug);
        pprint("bad ureg in noted or call to noted when not notified\n");
        pexit("Suicide", 0);
    }

    /*
     * Check the segment selectors are all valid, otherwise
     * a fault will be taken on attempting to return to the
     * user process.
     * Take care with the comparisons as different processor
     * generations push segment descriptors in different ways.
     */
    if((nureg->cs & 0xFFFF) != UESEL || (nureg->ss & 0xFFFF) != UDSEL
      || (nureg->ds & 0xFFFF) != UDSEL || (nureg->es & 0xFFFF) != UDSEL
      || (nureg->fs & 0xFFFF) != UDSEL || (nureg->gs & 0xFFFF) != UDSEL){
        qunlock(&up->debug);
        pprint("bad segment selector in noted\n");
        pexit("Suicide", 0);
    }

    /* don't let user change system flags */
    nureg->flags = (ureg->flags & ~0xCD5) | (nureg->flags & 0xCD5);

    memmove(ureg, nureg, sizeof(Ureg));

    switch(arg0){
    case NCONT:
    case NRSTR:
if(0) print("%s %lud: noted %.8lux %.8lux\n",
    up->text, up->pid, nureg->pc, nureg->usp);
        if(!okaddr(nureg->pc, 1, 0) || !okaddr(nureg->usp, BY2WD, 0)){
            qunlock(&up->debug);
            pprint("suicide: trap in noted\n");
            pexit("Suicide", 0);
        }
        up->ureg = (Ureg*)(*(ulong*)(oureg-BY2WD));
        qunlock(&up->debug);
        break;

    case NSAVE:
        if(!okaddr(nureg->pc, BY2WD, 0)
        || !okaddr(nureg->usp, BY2WD, 0)){
            qunlock(&up->debug);
            pprint("suicide: trap in noted\n");
            pexit("Suicide", 0);
        }
        qunlock(&up->debug);
        sp = oureg-4*BY2WD-ERRMAX;
        splhi();
        ureg->sp = sp;
        ((ulong*)sp)[1] = oureg;    /* arg 1 0(FP) is ureg* */
        ((ulong*)sp)[0] = 0;        /* arg 0 is pc */
        break;

    default:
        pprint("unknown noted arg 0x%lux\n", arg0);
        up->lastnote.flag = NDebug;
        /* fall through */

    case NDFLT:
        if(up->lastnote.flag == NDebug){
            qunlock(&up->debug);
            pprint("suicide: %s\n", up->lastnote.msg);
        } else
            qunlock(&up->debug);
        pexit(up->lastnote.msg, up->lastnote.flag!=NDebug);
    }
}

long
execregs(ulong entry, ulong ssize, ulong nargs)
{
    ulong *sp;
    Ureg *ureg;

    up->fpstate = FPinit;
    fpoff();

    sp = (ulong*)(USTKTOP - ssize);
    *--sp = nargs;

    ureg = up->dbgreg;
    ureg->usp = (ulong)sp;
    ureg->pc = entry;
    return USTKTOP-sizeof(Tos);     /* address of kernel/user shared data */
}

/*
 *  return the userpc the last exception happened at
 */
ulong
userpc(void)
{
    Ureg *ureg;

    ureg = (Ureg*)up->dbgreg;
    return ureg->pc;
}

/* This routine must save the values of registers the user is not permitted
 * to write from devproc and then restore the saved values before returning.
 */
void
setregisters(Ureg* ureg, char* pureg, char* uva, int n)
{
    ulong cs, ds, es, flags, fs, gs, ss;

    ss = ureg->ss;
    flags = ureg->flags;
    cs = ureg->cs;
    ds = ureg->ds;
    es = ureg->es;
    fs = ureg->fs;
    gs = ureg->gs;
    memmove(pureg, uva, n);
    ureg->gs = gs;
    ureg->fs = fs;
    ureg->es = es;
    ureg->ds = ds;
    ureg->cs = cs;
    ureg->flags = (ureg->flags & 0x00FF) | (flags & 0xFF00);
    ureg->ss = ss;
}

static void
linkproc(void)
{
    spllo();
    up->kpfun(up->kparg);
    pexit("kproc dying", 0);
}

void
kprocchild(Proc* p, void (*func)(void*), void* arg)
{
    /*
     * gotolabel() needs a word on the stack in
     * which to place the return PC used to jump
     * to linkproc().
     */
    p->sched.pc = (ulong)linkproc;
    p->sched.sp = (ulong)p->kstack+KSTACK-BY2WD;

    p->kpfun = func;
    p->kparg = arg;
}

void
forkchild(Proc *p, Ureg *ureg)
{
    Ureg *cureg;

    /*
     * Add 2*BY2WD to the stack to account for
     *  - the return PC
     *  - trap's argument (ur)
     */
    p->sched.sp = (ulong)p->kstack+KSTACK-(sizeof(Ureg)+2*BY2WD);
    p->sched.pc = (ulong)forkret;

    cureg = (Ureg*)(p->sched.sp+2*BY2WD);
    memmove(cureg, ureg, sizeof(Ureg));
    /* return value of syscall in child */
    cureg->ax = 0;

    /* Things from bottom of syscall which were never executed */
    p->psstate = 0;
    p->insyscall = 0;
}

/* Give enough context in the ureg to produce a kernel stack for
 * a sleeping process
 */
void
setkernur(Ureg* ureg, Proc* p)
{
    ureg->pc = p->sched.pc;
    ureg->sp = p->sched.sp+4;
}

ulong
dbgpc(Proc *p)
{
    Ureg *ureg;

    ureg = p->dbgreg;
    if(ureg == 0)
        return 0;

    return ureg->pc;
}
@


\subsection*{[[processes/alarm.c]]}

<<alarm.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

static Alarms   alarms;
static Rendez   alarmr;

// Kernel Process for alarm managment
void
alarmkproc(void*)
{
    Proc *rp;
    ulong now;

    for(;;){
        now = MACHP(0)->ticks;
        qlock(&alarms);
        /*
         * the odd test of now vs. rp->alarm is to cope with
         * now wrapping around.
         */
        while((rp = alarms.head) && (long)(now - rp->alarm) >= 0){
            if(rp->alarm != 0L){
                if(canqlock(&rp->debug)){
                    if(!waserror()){
                        postnote(rp, 0, "alarm", NUser);
                        poperror();
                    }
                    qunlock(&rp->debug);
                    rp->alarm = 0L;
                }else
                    break;
            }
            alarms.head = rp->palarm;
        }
        qunlock(&alarms);

        sleep(&alarmr, return0, 0);
    }
}

/*
 *  called every clock tick
 */
void
checkalarms(void)
{
    Proc *p;
    ulong now;

    p = alarms.head;
    now = MACHP(0)->ticks;

    if(p && (long)(now - p->alarm) >= 0)
        wakeup(&alarmr);
}

ulong
procalarm(ulong time)
{
    Proc **l, *f;
    ulong when, old;

    if(up->alarm)
        old = tk2ms(up->alarm - MACHP(0)->ticks);
    else
        old = 0;
    if(time == 0) {
        up->alarm = 0;
        return old;
    }
    when = ms2tk(time)+MACHP(0)->ticks;
    if(when == 0)       /* ticks have wrapped to 0? */
        when = 1;   /* distinguish a wrapped alarm from no alarm */

    qlock(&alarms);
    l = &alarms.head;
    for(f = *l; f; f = f->palarm) {
        if(up == f){
            *l = f->palarm;
            break;
        }
        l = &f->palarm;
    }

    up->palarm = 0;
    if(alarms.head) {
        l = &alarms.head;
        for(f = *l; f; f = f->palarm) {
            if((long)(f->alarm - when) >= 0) {
                up->palarm = f;
                *l = up;
                goto done;
            }
            l = &f->palarm;
        }
        *l = up;
    }
    else
        alarms.head = up;
done:
    up->alarm = when;
    qunlock(&alarms);

    return old;
}
@


\subsection*{[[processes/clock.c]]}

<<clock.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"
#include "../port/error.h"

enum {
    Maxtimerloops = 20*1000,
};


static Timers timers[MAXMACH];
static int timersinited;

ulong intrcount[MAXMACH];
ulong fcallcount[MAXMACH];

static vlong
tadd(Timers *tt, Timer *nt)
{
    Timer *t, **last;

    /* Called with tt locked */
    assert(nt->tt == nil);
    switch(nt->tmode){
    default:
        panic("timer");
        break;
    case Trelative:
        if(nt->tns <= 0)
            nt->tns = 1;
        nt->twhen = fastticks(nil) + ns2fastticks(nt->tns);
        break;
    case Tperiodic:
        assert(nt->tns >= 100000);  /* At least 100 Âµs period */
        if(nt->twhen == 0){
            /* look for another timer at same frequency for combining */
            for(t = tt->head; t; t = t->tnext){
                if(t->tmode == Tperiodic && t->tns == nt->tns)
                    break;
            }
            if (t)
                nt->twhen = t->twhen;
            else
                nt->twhen = fastticks(nil);
        }
        nt->twhen += ns2fastticks(nt->tns);
        break;
    }

    for(last = &tt->head; t = *last; last = &t->tnext){
        if(t->twhen > nt->twhen)
            break;
    }
    nt->tnext = *last;
    *last = nt;
    nt->tt = tt;
    if(last == &tt->head)
        return nt->twhen;
    return 0;
}

static uvlong
tdel(Timer *dt)
{

    Timer *t, **last;
    Timers *tt;

    tt = dt->tt;
    if (tt == nil)
        return 0;
    for(last = &tt->head; t = *last; last = &t->tnext){
        if(t == dt){
            assert(dt->tt);
            dt->tt = nil;
            *last = t->tnext;
            break;
        }
    }
    if(last == &tt->head && tt->head)
        return tt->head->twhen;
    return 0;
}

/* add or modify a timer */
void
timeradd(Timer *nt)
{
    Timers *tt;
    vlong when;

    /* Must lock Timer struct before Timers struct */
    ilock(nt);
    if(tt = nt->tt){
        ilock(tt);
        tdel(nt);
        iunlock(tt);
    }
    tt = &timers[m->machno];
    ilock(tt);
    when = tadd(tt, nt);
    if(when)
        timerset(when);
    iunlock(tt);
    iunlock(nt);
}


void
timerdel(Timer *dt)
{
    Timers *tt;
    uvlong when;

    ilock(dt);
    if(tt = dt->tt){
        ilock(tt);
        when = tdel(dt);
        if(when && tt == &timers[m->machno])
            timerset(tt->head->twhen);
        iunlock(tt);
    }
    iunlock(dt);
}

void
hzclock(Ureg *ur)
{
    m->ticks++;
    if(m->proc)
        m->proc->pc = ur->pc;

    if(m->flushmmu){
        if(up)
            flushmmu();
        m->flushmmu = 0;
    }

    accounttime();
    kmapinval();

    if(kproftimer != nil)
        kproftimer(ur->pc);

    if((active.machs&(1<<m->machno)) == 0)
        return;

    if(active.exiting) {
        print("someone's exiting\n");
        exit(0);
    }

    checkalarms();

    if(up && up->state == Running)
        hzsched();  /* in proc.c */
}

void
timerintr(Ureg *u, Tval)
{
    Timer *t;
    Timers *tt;
    uvlong when, now;
    int count, callhzclock;

    intrcount[m->machno]++;
    callhzclock = 0;
    tt = &timers[m->machno];
    now = fastticks(nil);
    if(now == 0)
        panic("timerintr: zero fastticks()");
    ilock(tt);
    count = Maxtimerloops;
    while((t = tt->head) != nil){
        /*
         * No need to ilock t here: any manipulation of t
         * requires tdel(t) and this must be done with a
         * lock to tt held.  We have tt, so the tdel will
         * wait until we're done
         */
        when = t->twhen;
        if(when > now){
            timerset(when);
            iunlock(tt);
            if(callhzclock)
                hzclock(u);
            return;
        }
        tt->head = t->tnext;
        assert(t->tt == tt);
        t->tt = nil;
        fcallcount[m->machno]++;
        iunlock(tt);
        if(t->tf)
            (*t->tf)(u, t);
        else
            callhzclock++;
        ilock(tt);
        if(t->tmode == Tperiodic)
            tadd(tt, t);
        if (--count <= 0) {
            count = Maxtimerloops;
            iprint("timerintr: probably stuck in while loop; "
                "scrutinise clock.c or use faster cycle "
                "counter\n");
        }
    }
    iunlock(tt);
}

void
timersinit(void)
{
    Timer *t;

    /*
     * T->tf == nil means the HZ clock for this processor.
     */
    timersinited = 1;
    todinit();
    t = malloc(sizeof(*t));
    if(t == nil)
        error(Enomem);
    t->tmode = Tperiodic;
    t->tt = nil;
    t->tns = 1000000000/HZ;
    t->tf = nil;
    timeradd(t);
}

Timer*
addclock0link(void (*f)(void), int ms)
{
    Timer *nt;
    uvlong when;

    if(!timersinited)
        panic("addclock0link: timersinit not called yet");
    /* Synchronize to hztimer if ms is 0 */
    nt = malloc(sizeof(Timer));
    if(nt == nil)
        error(Enomem);
    if(ms == 0)
        ms = 1000/HZ;
    nt->tns = (vlong)ms*1000000LL;
    nt->tmode = Tperiodic;
    nt->tt = nil;
    nt->tf = (void (*)(Ureg*, Timer*))f;

    ilock(&timers[0]);
    when = tadd(&timers[0], nt);
    if(when)
        timerset(when);
    iunlock(&timers[0]);
    return nt;
}

/*
 *  This tk2ms avoids overflows that the macro version is prone to.
 *  It is a LOT slower so shouldn't be used if you're just converting
 *  a delta.
 */
ulong
tk2ms(ulong ticks)
{
    uvlong t, hz;

    t = ticks;
    hz = HZ;
    t *= 1000L;
    t = t/hz;
    ticks = t;
    return ticks;
}

ulong
ms2tk(ulong ms)
{
    /* avoid overflows at the cost of precision */
    if(ms >= 1000000000/HZ)
        return (ms/1000)*HZ;
    return (ms*HZ+500)/1000;
}
@


\subsection*{[[processes/edf.c]]}

<<edf.c>>=
/* EDF scheduling */
#include    <u.h>
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
//#include  "../port/edf.h"
#include    <trace.h>

// hash<enum<priority>, Schedq>, Nrq is the number of priority level (20+2)
extern Schedq   runq[Nrq];

// used to be in edf.h
//unused: extern Lock edftestlock;  /* for atomic admitting/expelling */

/* debugging */
enum {
    Dontprint = 1,
};
#define DPRINT  if(Dontprint){}else print


static long now;    /* Low order 32 bits of time in Âµs */

extern ulong    delayedscheds;
extern int  nrdy;
extern ulong    runvec;

/* Statistics stuff */
//ulong     nilcount;
//ulong     scheds;
ulong       edfnrun;
//int       misseddeadlines;

/* Edfschedlock protects modification of admission params */
int     edfinited;
QLock       edfschedlock;
static Lock thelock;

enum{
    Dl, /* Invariant for schedulability test: Dl < Rl */
    Rl,
};

static char *testschedulability(Proc*);
static Proc *qschedulability;

enum {
    Onemicrosecond =    1,
    Onemillisecond =    1000,
    Onesecond =     1000000,
    OneRound =      Onemillisecond/2,
};

static int
timeconv(Fmt *f)
{
    char buf[128], *sign;
    vlong t;

    buf[0] = 0;
    switch(f->r) {
    case 'U':
        t = va_arg(f->args, uvlong);
        break;
    case 't':           /* vlong in nanoseconds */
        t = va_arg(f->args, long);
        break;
    default:
        return fmtstrcpy(f, "(timeconv)");
    }
    if (t < 0) {
        sign = "-";
        t = -t;
    }
    else
        sign = "";
    if (t > Onesecond){
        t += OneRound;
        snprint(buf, sizeof buf, "%s%d.%.3ds", sign,
            (int)(t / Onesecond),
            (int)(t % Onesecond)/Onemillisecond);
    }else if (t > Onemillisecond)
        snprint(buf, sizeof buf, "%s%d.%.3dms", sign,
            (int)(t / Onemillisecond), (int)(t % Onemillisecond));
    else
        snprint(buf, sizeof buf, "%s%dÂµs", sign, (int)t);
    return fmtstrcpy(f, buf);
}

#ifdef EDFCYCLES
long edfcycles;
#endif

Edf*
edflock(Proc *p)
{
    Edf *e;

    if (p->edf == nil)
        return nil;
    ilock(&thelock);
    if((e = p->edf) && (e->flags & Admitted)){
        thelock.pc = getcallerpc(&p);
#ifdef EDFCYCLES
        edfcycles -= lcycles();
#endif
        now = Âµs();
        return e;
    }
    iunlock(&thelock);
    return nil;
}

void
edfunlock(void)
{

#ifdef EDFCYCLES
    edfcycles += lcycles();
#endif
    edfnrun++;
    iunlock(&thelock);
}

void
edfinit(Proc*p)
{
    if(!edfinited){
        fmtinstall('t', timeconv);
        edfinited++;
    }
    now = Âµs();
    DPRINT("%lud edfinit %lud[%s]\n", now, p->pid, statename[p->state]);
    p->edf = malloc(sizeof(Edf));
    if(p->edf == nil)
        error(Enomem);
    return;
}

//@Scheck: not dead, called below, but not in edf.clang, weird
static void
deadlineintr(Ureg*, Timer *t)
{
    /* Proc reached deadline */
    Proc *p;
    void (*pt)(Proc*, int, vlong);

    if(panicking || active.exiting)
        return;

    p = t->ta;
    now = Âµs();
    DPRINT("%lud deadlineintr %lud[%s]\n", now, p->pid, statename[p->state]);
    /* If we're interrupting something other than the proc pointed to by t->a,
     * we've already achieved recheduling, so we need not do anything
     * Otherwise, we must cause a reschedule, but if we call sched()
     * here directly, the timer interrupt routine will not finish its business
     * Instead, we cause the resched to happen when the interrupted proc
     * returns to user space
     */
    if(p == up){
        if(up->trace && (pt = proctrace))
            pt(up, SInts, 0);
        up->delaysched++;
        delayedscheds++;
    }
}

static void
release(Proc *p)
{
    /* Called with edflock held */
    Edf *e;
    void (*pt)(Proc*, int, vlong);
    long n;
    vlong nowns;

    e = p->edf;
    e->flags &= ~Yield;
    if(e->d - now < 0){
        e->periods++;
        e->r = now;
        if((e->flags & Sporadic) == 0){
            /*
             * Non sporadic processes stay true to their period;
             * calculate next release time.
             * Second test limits duration of while loop.
             */
            if((n = now - e->t) > 0){
                if(n < e->T)
                    e->t += e->T;
                else
                    e->t = now + e->T - (n % e->T);
            }
        }else{
            /* Sporadic processes may not be released earlier than
             * one period after this release
             */
            e->t = e->r + e->T;
        }
        e->d = e->r + e->D;
        e->S = e->C;
        DPRINT("%lud release %lud[%s], r=%lud, d=%lud, t=%lud, S=%lud\n",
            now, p->pid, statename[p->state], e->r, e->d, e->t, e->S);
        if(pt = proctrace){
            nowns = todget(nil);
            pt(p, SRelease, nowns);
            pt(p, SDeadline, nowns + 1000LL*e->D);
        }
    }else{
        DPRINT("%lud release %lud[%s], too late t=%lud, called from %#p\n",
            now, p->pid, statename[p->state], e->t, getcallerpc(&p));
    }
}

static void
releaseintr(Ureg*, Timer *t)
{
    Proc *p;
    Schedq *rq;

    if(panicking || active.exiting)
        return;

    p = t->ta;
    if((edflock(p)) == nil)
        return;
    DPRINT("%lud releaseintr %lud[%s]\n", now, p->pid, statename[p->state]);
    switch(p->state){
    default:
        edfunlock();
        return;
    case Ready:
        /* remove proc from current runq */
        rq = &runq[p->priority];
        if(dequeueproc(rq, p) != p){
            DPRINT("releaseintr: can't find proc or lock race\n");
            release(p); /* It'll start best effort */
            edfunlock();
            return;
        }
        p->state = Waitrelease;
        /* fall through */
    case Waitrelease:
        release(p);
        edfunlock();
        if(p->state == Wakeme){
            iprint("releaseintr: wakeme\n");
        }
        ready(p);
        if(up){
            up->delaysched++;
            delayedscheds++;
        }
        return;
    case Running:
        release(p);
        edfrun(p, 1);
        break;
    case Wakeme:
        release(p);
        edfunlock();
        if(p->trend)
            wakeup(p->trend);
        p->trend = nil;
        if(up){
            up->delaysched++;
            delayedscheds++;
        }
        return;
    }
    edfunlock();
}

void
edfrecord(Proc *p)
{
    long used;
    Edf *e;
    void (*pt)(Proc*, int, vlong);

    if((e = edflock(p)) == nil)
        return;
    used = now - e->s;
    if(e->d - now <= 0)
        e->edfused += used;
    else
        e->extraused += used;
    if(e->S > 0){
        if(e->S <= used){
            if(pt = proctrace)
                pt(p, SSlice, 0);
            DPRINT("%lud edfrecord slice used up\n", now);
            e->d = now;
            e->S = 0;
        }else
            e->S -= used;
    }
    e->s = now;
    edfunlock();
}

void
edfrun(Proc *p, int edfpri)
{
    Edf *e;
    void (*pt)(Proc*, int, vlong);
    long tns;

    e = p->edf;
    /* Called with edflock held */
    if(edfpri){
        tns = e->d - now;
        if(tns <= 0 || e->S == 0){
            /* Deadline reached or resources exhausted,
             * deschedule forthwith
             */
            p->delaysched++;
            delayedscheds++;
            e->s = now;
            return;
        }
        if(e->S < tns)
            tns = e->S;
        if(tns < 20)
            tns = 20;
        e->tns = 1000LL * tns;  /* Âµs to ns */
        if(e->tt == nil || e->tf != deadlineintr){
            DPRINT("%lud edfrun, deadline=%lud\n", now, tns);
        }else{
            DPRINT("v");
        }
        if(p->trace && (pt = proctrace))
            pt(p, SInte, todget(nil) + e->tns);
        e->tmode = Trelative;
        e->tf = deadlineintr;
        e->ta = p;
        timeradd(e);
    }else{
        DPRINT("<");
    }
    e->s = now;
}

char *
edfadmit(Proc *p)
{
    char *err;
    Edf *e;
    int i;
    Proc *r;
    void (*pt)(Proc*, int, vlong);
    long tns;

    e = p->edf;
    if (e->flags & Admitted)
        return "task state";    /* should never happen */

    /* simple sanity checks */
    if (e->T == 0)
        return "T not set";
    if (e->C == 0)
        return "C not set";
    if (e->D > e->T)
        return "D > T";
    if (e->D == 0)  /* if D is not set, set it to T */
        e->D = e->T;
    if (e->C > e->D)
        return "C > D";

    qlock(&edfschedlock);
    if (err = testschedulability(p)){
        qunlock(&edfschedlock);
        return err;
    }
    e->flags |= Admitted;

    edflock(p);

    if(p->trace && (pt = proctrace))
        pt(p, SAdmit, 0);

    /* Look for another proc with the same period to synchronize to */
    SET(r);
    for(i=0; i<conf.nproc; i++) {
        r = proctab(i);
        if(r->state == Dead || r == p)
            continue;
        if (r->edf == nil || (r->edf->flags & Admitted) == 0)
            continue;
        if (r->edf->T == e->T)
                break;
    }
    if (i == conf.nproc){
        /* Can't synchronize to another proc, release now */
        e->t = now;
        e->d = 0;
        release(p);
        if (p == up){
            DPRINT("%lud edfadmit self %lud[%s], release now: r=%lud d=%lud t=%lud\n",
                now, p->pid, statename[p->state], e->r, e->d, e->t);
            /* We're already running */
            edfrun(p, 1);
        }else{
            /* We're releasing another proc */
            DPRINT("%lud edfadmit other %lud[%s], release now: r=%lud d=%lud t=%lud\n",
                now, p->pid, statename[p->state], e->r, e->d, e->t);
            p->ta = p;
            edfunlock();
            qunlock(&edfschedlock);
            releaseintr(nil, p);
            return nil;
        }
    }else{
        /* Release in synch to something else */
        e->t = r->edf->t;
        if (p == up){
            DPRINT("%lud edfadmit self %lud[%s], release at %lud\n",
                now, p->pid, statename[p->state], e->t);
            edfunlock();
            qunlock(&edfschedlock);
            return nil;
        }else{
            DPRINT("%lud edfadmit other %lud[%s], release at %lud\n",
                now, p->pid, statename[p->state], e->t);
            if(e->tt == nil){
                e->tf = releaseintr;
                e->ta = p;
                tns = e->t - now;
                if(tns < 20)
                    tns = 20;
                e->tns = 1000LL * tns;
                e->tmode = Trelative;
                timeradd(e);
            }
        }
    }
    edfunlock();
    qunlock(&edfschedlock);
    return nil;
}

void
edfstop(Proc *p)
{
    Edf *e;
    void (*pt)(Proc*, int, vlong);

    if(e = edflock(p)){
        DPRINT("%lud edfstop %lud[%s]\n", now, p->pid, statename[p->state]);
        if(p->trace && (pt = proctrace))
            pt(p, SExpel, 0);
        e->flags &= ~Admitted;
        if(e->tt)
            timerdel(e);
        edfunlock();
    }
}

static int
yfn(void *)
{
    now = Âµs();
    return up->trend == nil || now - up->edf->r >= 0;
}

void
edfyield(void)
{
    /* sleep until next release */
    Edf *e;
    void (*pt)(Proc*, int, vlong);
    long n;

    if((e = edflock(up)) == nil)
        return;
    if(up->trace && (pt = proctrace))
        pt(up, SYield, 0);
    if((n = now - e->t) > 0){
        if(n < e->T)
            e->t += e->T;
        else
            e->t = now + e->T - (n % e->T);
    }
    e->r = e->t;
    e->flags |= Yield;
    e->d = now;
    if (up->tt == nil){
        n = e->t - now;
        if(n < 20)
            n = 20;
        up->tns = 1000LL * n;
        up->tf = releaseintr;
        up->tmode = Trelative;
        up->ta = up;
        up->trend = &up->sleep;
        timeradd(up);
    }else if(up->tf != releaseintr)
        print("edfyield: surprise! %#p\n", up->tf);
    edfunlock();
    sleep(&up->sleep, yfn, nil);
}

int
edfready(Proc *p)
{
    Edf *e;
    Schedq *rq;
    Proc *l, *pp;
    void (*pt)(Proc*, int, vlong);
    long n;

    if((e = edflock(p)) == nil)
        return 0;

    if(p->state == Wakeme && p->r){
        iprint("edfready: wakeme\n");
    }
    if(e->d - now <= 0){
        /* past deadline, arrange for next release */
        if((e->flags & Sporadic) == 0){
            /*
             * Non sporadic processes stay true to their period;
             * calculate next release time.
             */
            if((n = now - e->t) > 0){
                if(n < e->T)
                    e->t += e->T;
                else
                    e->t = now + e->T - (n % e->T);
            }
        }
        if(now - e->t < 0){
            /* Next release is in the future, schedule it */
            if(e->tt == nil || e->tf != releaseintr){
                n = e->t - now;
                if(n < 20)
                    n = 20;
                e->tns = 1000LL * n;
                e->tmode = Trelative;
                e->tf = releaseintr;
                e->ta = p;
                timeradd(e);
                DPRINT("%lud edfready %lud[%s], release=%lud\n",
                    now, p->pid, statename[p->state], e->t);
            }
            if(p->state == Running && (e->flags & (Yield|Yieldonblock)) == 0 && (e->flags & Extratime)){
                /* If we were running, we've overrun our CPU allocation
                 * or missed the deadline, continue running best-effort at low priority
                 * Otherwise we were blocked.  If we don't yield on block, we continue
                 * best effort
                 */
                DPRINT(">");
                p->basepri = PriExtra;
                p->fixedpri = 1;
                edfunlock();
                return 0;   /* Stick on runq[PriExtra] */
            }
            DPRINT("%lud edfready %lud[%s] wait release at %lud\n",
                now, p->pid, statename[p->state], e->t);
            p->state = Waitrelease;
            edfunlock();
            return 1;   /* Make runnable later */
        }
        DPRINT("%lud edfready %lud %s release now\n", now, p->pid, statename[p->state]);
        /* release now */
        release(p);
    }
    edfunlock();
    DPRINT("^");
    rq = &runq[PriEdf];
    /* insert in queue in earliest deadline order */
    lock(runq);
    l = nil;
    for(pp = rq->head; pp; pp = pp->rnext){
        if(pp->edf->d > e->d)
            break;
        l = pp;
    }
    p->rnext = pp;
    if (l == nil)
        rq->head = p;
    else
        l->rnext = p;
    if(pp == nil)
        rq->tail = p;
    rq->n++;
    nrdy++;
    runvec |= 1 << PriEdf;
    p->priority = PriEdf;
    p->readytime = m->ticks;
    p->state = Ready;
    unlock(runq);
    if(p->trace && (pt = proctrace))
        pt(p, SReady, 0);
    return 1;
}


static void
testenq(Proc *p)
{
    Proc *xp, **xpp;
    Edf *e;

    e = p->edf;
    e->testnext = nil;
    if (qschedulability == nil) {
        qschedulability = p;
        return;
    }
    SET(xp);
    for (xpp = &qschedulability; *xpp; xpp = &xp->edf->testnext) {
        xp = *xpp;
        if (e->testtime - xp->edf->testtime < 0
        || (e->testtime == xp->edf->testtime && e->testtype < xp->edf->testtype)){
            e->testnext = xp;
            *xpp = p;
            return;
        }
    }
    assert(xp->edf->testnext == nil);
    xp->edf->testnext = p;
}

static char *
testschedulability(Proc *theproc)
{
    Proc *p;
    long H, G, Cb, ticks;
    int steps, i;

    /* initialize */
    DPRINT("schedulability test %lud\n", theproc->pid);
    qschedulability = nil;
    for(i=0; i<conf.nproc; i++) {
        p = proctab(i);
        if(p->state == Dead)
            continue;
        if ((p->edf == nil || (p->edf->flags & Admitted) == 0) && p != theproc)
            continue;
        p->edf->testtype = Rl;
        p->edf->testtime = 0;
        DPRINT("\tInit: edfenqueue %lud\n", p->pid);
        testenq(p);
    }
    H=0;
    G=0;
    for(steps = 0; steps < Maxsteps; steps++){
        p = qschedulability;
        qschedulability = p->edf->testnext;
        ticks = p->edf->testtime;
        switch (p->edf->testtype){
        case Dl:
            H += p->edf->C;
            Cb = 0;
            DPRINT("\tStep %3d, Ticks %lud, pid %lud, deadline, H += %lud â %lud, Cb = %lud\n",
                steps, ticks, p->pid, p->edf->C, H, Cb);
            if (H+Cb>ticks){
                DPRINT("not schedulable\n");
                return "not schedulable";
            }
            p->edf->testtime += p->edf->T - p->edf->D;
            p->edf->testtype = Rl;
            testenq(p);
            break;
        case Rl:
            DPRINT("\tStep %3d, Ticks %lud, pid %lud, release, G  %lud, C%lud\n",
                steps, ticks, p->pid, p->edf->C, G);
            if(ticks && G <= ticks){
                DPRINT("schedulable\n");
                return nil;
            }
            G += p->edf->C;
            p->edf->testtime += p->edf->D;
            p->edf->testtype = Dl;
            testenq(p);
            break;
        default:
            assert(0);
        }
    }
    DPRINT("probably not schedulable\n");
    return "probably not schedulable";
}
@


\subsection*{[[processes/pgrp.c]]}

<<pgrp.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// Process group, and Namespace.

enum {
    Whinesecs = 10,     /* frequency of out-of-resources printing */
};

static Ref pgrpid;
static Ref mountid;

void
pgrpnote(ulong noteid, char *a, long n, int flag)
{
    Proc *p, *ep;
    char buf[ERRMAX];

    if(n >= ERRMAX-1)
        error(Etoobig);

    memmove(buf, a, n);
    buf[n] = 0;
    p = proctab(0);
    ep = p+conf.nproc;
    for(; p < ep; p++) {
        if(p->state == Dead)
            continue;
        if(up != p && p->noteid == noteid && p->kp == 0) {
            qlock(&p->debug);
            if(p->pid == 0 || p->noteid != noteid){
                qunlock(&p->debug);
                continue;
            }
            if(!waserror()) {
                postnote(p, 0, buf, flag);
                poperror();
            }
            qunlock(&p->debug);
        }
    }
}

Pgrp*
newpgrp(void)
{
    Pgrp *p;

    p = smalloc(sizeof(Pgrp));
    p->ref = 1;
    p->pgrpid = incref(&pgrpid);
    return p;
}

Rgrp*
newrgrp(void)
{
    Rgrp *r;

    r = smalloc(sizeof(Rgrp));
    r->ref = 1;
    return r;
}

void
closergrp(Rgrp *r)
{
    if(decref(r) == 0)
        free(r);
}

void
closepgrp(Pgrp *p)
{
    Mhead **h, **e, *f, *next;

    if(decref(p) != 0)
        return;

    qlock(&p->debug);
    wlock(&p->ns);
    p->pgrpid = -1;

    e = &p->mnthash[MNTHASH];
    for(h = p->mnthash; h < e; h++) {
        for(f = *h; f; f = next) {
            wlock(&f->lock);
            cclose(f->from);
            mountfree(f->mount);
            f->mount = nil;
            next = f->hash;
            wunlock(&f->lock);
            putmhead(f);
        }
    }
    wunlock(&p->ns);
    qunlock(&p->debug);
    free(p);
}

void
pgrpinsert(Mount **order, Mount *m)
{
    Mount *f;

    m->order = 0;
    if(*order == 0) {
        *order = m;
        return;
    }
    for(f = *order; f; f = f->order) {
        if(m->mountid < f->mountid) {
            m->order = f;
            *order = m;
            return;
        }
        order = &f->order;
    }
    *order = m;
}

/*
 * pgrpcpy MUST preserve the mountid allocation order of the parent group
 */
void
pgrpcpy(Pgrp *to, Pgrp *from)
{
    int i;
    Mount *n, *m, **link, *order;
    Mhead *f, **tom, **l, *mh;

    wlock(&from->ns);
    order = 0;
    tom = to->mnthash;
    for(i = 0; i < MNTHASH; i++) {
        l = tom++;
        for(f = from->mnthash[i]; f; f = f->hash) {
            rlock(&f->lock);
            mh = newmhead(f->from);
            *l = mh;
            l = &mh->hash;
            link = &mh->mount;
            for(m = f->mount; m; m = m->next) {
                n = newmount(mh, m->to, m->mflag, m->spec);
                m->copy = n;
                pgrpinsert(&order, m);
                *link = n;
                link = &n->next;
            }
            runlock(&f->lock);
        }
    }
    /*
     * Allocate mount ids in the same sequence as the parent group
     */
    lock(&mountid);
    for(m = order; m; m = m->order)
        m->copy->mountid = mountid.ref++;
    unlock(&mountid);
    wunlock(&from->ns);
}

Fgrp*
dupfgrp(Fgrp *f)
{
    Fgrp *new;
    Chan *c;
    int i;

    new = smalloc(sizeof(Fgrp));
    if(f == nil){
        new->fd = smalloc(DELTAFD*sizeof(Chan*));
        new->nfd = DELTAFD;
        new->ref = 1;
        return new;
    }

    lock(f);
    /* Make new fd list shorter if possible, preserving quantization */
    new->nfd = f->maxfd+1;
    i = new->nfd%DELTAFD;
    if(i != 0)
        new->nfd += DELTAFD - i;
    new->fd = malloc(new->nfd*sizeof(Chan*));
    if(new->fd == nil){
        unlock(f);
        free(new);
        error("no memory for fgrp");
    }
    new->ref = 1;

    new->maxfd = f->maxfd;
    for(i = 0; i <= f->maxfd; i++) {
        if(c = f->fd[i]){
            incref(c);
            new->fd[i] = c;
        }
    }
    unlock(f);

    return new;
}

void
closefgrp(Fgrp *f)
{
    int i;
    Chan *c;

    if(f == 0)
        return;

    if(decref(f) != 0)
        return;

    /*
     * If we get into trouble, forceclosefgrp
     * will bail us out.
     */
    up->closingfgrp = f;
    for(i = 0; i <= f->maxfd; i++)
        if(c = f->fd[i]){
            f->fd[i] = nil;
            cclose(c);
        }
    up->closingfgrp = nil;

    free(f->fd);
    free(f);
}

/*
 * Called from sleep because up is in the middle
 * of closefgrp and just got a kill ctl message.
 * This usually means that up has wedged because
 * of some kind of deadly embrace with mntclose
 * trying to talk to itself.  To break free, hand the
 * unclosed channels to the close queue.  Once they
 * are finished, the blocked cclose that we've 
 * interrupted will finish by itself.
 */
void
forceclosefgrp(void)
{
    int i;
    Chan *c;
    Fgrp *f;

    if(up->procctl != Proc_exitme || up->closingfgrp == nil){
        print("bad forceclosefgrp call");
        return;
    }

    f = up->closingfgrp;
    for(i = 0; i <= f->maxfd; i++)
        if(c = f->fd[i]){
            f->fd[i] = nil;
            ccloseq(c);
        }
}


Mount*
newmount(Mhead *mh, Chan *to, int flag, char *spec)
{
    Mount *m;

    m = smalloc(sizeof(Mount));
    m->to = to;
    m->head = mh;
    incref(to);
    m->mountid = incref(&mountid);
    m->mflag = flag;
    if(spec != 0)
        kstrdup(&m->spec, spec);

    return m;
}

void
mountfree(Mount *m)
{
    Mount *f;

    while(m) {
        f = m->next;
        cclose(m->to);
        m->mountid = 0;
        free(m->spec);
        free(m);
        m = f;
    }
}

void
resrcwait(char *reason)
{
    ulong now;
    char *p;
    static ulong lastwhine;

    if(up == 0)
        panic("resrcwait");

    p = up->psstate;
    if(reason) {
        up->psstate = reason;
        now = seconds();
        /* don't tie up the console with complaints */
        if(now - lastwhine > Whinesecs) {
            lastwhine = now;
            print("%s\n", reason);
        }
    }

    tsleep(&up->sleep, return0, 0, 300);
    up->psstate = p;
}
@


\subsection*{[[processes/portdat_processes.c]]}

<<portdat_processes.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

void (*proctrace)(Proc*, int, vlong) = 0; // was in devproc.c
void (*kproftimer)(ulong);

struct Active active;
@


\subsection*{[[processes/portdat_processes.h]]}

<<portdat_processes.h>>=

// in lib.h: Waitmsg, ERRMAX
// see also ArchProcMMU, ArchProcNotsave, MAXSYSARG in 386/

//*****************************************************************************
// Proc components
//*****************************************************************************
// All the ref<Proc> here are references to Proc in the array<Proc> of
// Procalloc.arena (pool allocator)

//--------------------------------------------------------------------
// State
//--------------------------------------------------------------------

// TODO: state transition diagram
enum procstate
{
  /* Process states, Proc.state */
  Dead = 0,
  Moribund,
  Ready,
  Scheding,
  Running,
  Queueing, // see lock()
  QueueingR, // see rlock()
  QueueingW, // see wlock ()
  Wakeme,
  Broken,
  Stopped,
  Rendezvous,
  Waitrelease,
};

// hash<enum<procstate>, string>, to debug
extern  char* statename[];

//--------------------------------------------------------------------
// Memory
//--------------------------------------------------------------------
/*
 *  process memory segments - NSEG always last !
 */
enum procseg
{
  SSEG, TSEG, DSEG, BSEG, // Stack, Text, Data, Bss
  ESEG, LSEG, // Extra (temporary stack segment), L?
  SEG1, SEG2, SEG3, SEG4,
  NSEG // to count, see Proc.seg array
};

//--------------------------------------------------------------------
// Files
//--------------------------------------------------------------------

enum
{
  DELTAFD = 20    /* incremental increase in Fgrp.fd's */
};

struct Fgrp
{
  // array<ref_counted<Chan>, smalloc'ed?
  Chan  **fd;
  // nelem(fd) ?
  int nfd;      /* number allocated */
  int maxfd;      /* highest fd in use */

  int exceed;     /* debugging */

  // extra
  Ref;
};



enum
{
  MNTLOG  = 5,
  MNTHASH = 1<<MNTLOG,  /* Hash to walk mount table */
};
#define MOUNTH(p,qid) ((p)->mnthash[(qid).path&((1<<MNTLOG)-1)])

// Namespace process group
struct Pgrp
{
  // hash<qid.path, list<ref<Mhead> (next = Mhead.next)>
  Mhead *mnthash[MNTHASH];
  ulong pgrpid;
  bool noattach;

  // extra
  Ref;        /* also used as a lock when mounting */
  QLock debug;      /* single access via devproc.c */
  RWlock  ns;     /* Namespace n read/one write lock */
};

//--------------------------------------------------------------------
// System call
//--------------------------------------------------------------------

// syscall arguments passed in kernel stack
struct Sargs
{
  ulong args[MAXSYSARG];
};


//--------------------------------------------------------------------
// Notes
//--------------------------------------------------------------------

enum {
  NNOTE = 5,
};

enum notekind
{
  NUser,        /* note provided externally */
  NExit,        /* deliver note quietly */
  NDebug,       /* print debug message */
};

// a kind of unix signal
struct Note
{
  char  msg[ERRMAX];
  // enum<notekind>
  int flag;     /* whether system posted it */
};
extern Ref  noteidalloc;

//--------------------------------------------------------------------
// Process children waiting
//--------------------------------------------------------------------

struct Waitq
{
  Waitmsg w;

  // extra
  // list<ref<Waitq>> Proc.waitq
  Waitq *next;
};

//--------------------------------------------------------------------
// Synchronization (Rendez vous)
//--------------------------------------------------------------------

enum
{
  RENDLOG = 5,
  RENDHASH =  1<<RENDLOG, /* Hash to lookup rendezvous tags */
};
#define REND(p,s) ((p)->rendhash[(s)&((1<<RENDLOG)-1)])

struct Rgrp
{
  // hash<??, list<ref<Proc>>>
  Proc  *rendhash[RENDHASH];  /* Rendezvous tag hash */

  // extra
  Ref;        /* the Ref's lock is also the Rgrp's lock */
};

//--------------------------------------------------------------------
// Alarms, timers
//--------------------------------------------------------------------

/*
 * fasttick timer interrupts
 */
enum timermode 
{
  Trelative,  /* timer programmed in ns from now */
  Tperiodic,  /* periodic timer, period in ns */
};

struct Timer
{
  /* Public interface */
  // enum<timermode>
  int tmode;    /* See above */
  vlong tns;    /* meaning defined by mode */
  void  (*tf)(Ureg*, Timer*);
  void  *ta;

  /* Internal */
  Lock;
  // ref<list<Timer>> ??
  Timers  *tt;    /* Timers queue this timer runs on */
  Tval  tticks;   /* tns converted to ticks */
  Tval  twhen;    /* ns represented in fastticks */

  // list<Timer> of Timers.head?
  Timer *tnext;
};

// was in clock.c
struct Timers
{
  // list<Timer> (next = Timer.tnext?)
  Timer *head;

  // extra
  Lock;
};

//--------------------------------------------------------------------
// Scheduling
//--------------------------------------------------------------------

enum {
  Npriq   = 20,   /* number of scheduler priority levels */
  Nrq   = Npriq+2,  /* number of priority levels including real time */
  //NFD =   100,    /* per process file descriptors */
};

enum priority 
{
  PriRelease  = Npriq,  /* released edf processes */
  PriEdf    = Npriq+1,  /* active edf processes */
  PriNormal = 10,   /* base priority for normal processes */
  PriExtra  = Npriq-1,  /* edf processes at high best-effort pri */
  PriKproc  = 13,   /* base priority for kernel processes */
  PriRoot   = 13,   /* base priority for root processes */
};


// was in edf.h
enum 
{
  Maxsteps = 200 * 100 * 2, /* 100 periods of 200 procs */
  Infinity = ~0ULL,
};

enum edfflags 
{
  /* Edf.flags field */
  Admitted    = 0x01,
  Sporadic    = 0x02,
  Yieldonblock    = 0x04,
  Sendnotes   = 0x08,
  Deadline    = 0x10,
  Yield     = 0x20,
  Extratime   = 0x40,
};

struct Edf {
  /* All times in Âµs */
  /* time intervals */
  long    D;    /* Deadline */
  long    Delta;    /* Inherited deadline */
  long    T;    /* period */
  long    C;    /* Cost */
  long    S;    /* Slice: time remaining in this period */
  /* times (only low-order bits of absolute time) */
  long    r;    /* (this) release time */
  long    d;    /* (this) deadline */
  long    t;    /* Start of next period, t += T at release */
  long    s;    /* Time at which this proc was last scheduled */

  /* for schedulability testing */
  long    testDelta;
  int   testtype; /* Release or Deadline */
  long    testtime;
  Proc    *testnext;

  /* other */
  // set<enum<edfflags>>
  ushort    flags;

  Timer;

  /* Stats */
  long    edfused;
  long    extraused;
  long    aged;
  ulong   periods;
  ulong   missed;
};

//--------------------------------------------------------------------
// Error managment
//--------------------------------------------------------------------
enum {
  NERR = 64,
};

//--------------------------------------------------------------------
// Stats, profiling
//--------------------------------------------------------------------
enum proctime 
{
  TUser = 0,    /* Proc.time */
  TSys,
  TReal,
  TCUser,
  TCSys,
  TCReal,
};

//--------------------------------------------------------------------
// Debugger
//--------------------------------------------------------------------

enum devproc 
{
  Proc_stopme = 1,  /* devproc requests */
  Proc_exitme,
  Proc_traceme,
  Proc_exitbig,
  Proc_tracesyscall,
};

//--------------------------------------------------------------------
// Misc
//--------------------------------------------------------------------

/*
 * FPsave.status
 */
enum fpsavestatus
{
  /* this is a state */
  FPinit=   0,
  FPactive= 1,
  FPinactive= 2,

  /* the following is a bit that can be or'd into the state */
  FPillegal=  0x100,
};


//*****************************************************************************
// Proc, the big one
//*****************************************************************************

// the most important fields are set by newproc()
struct Proc
{

//--------------------------------------------------------------------
// Assembly requirements, Low level, have to be first
//--------------------------------------------------------------------
  Label sched;    /* known to l.s */
  char  *kstack;  /* known to l.s */

//--------------------------------------------------------------------
// State
//--------------------------------------------------------------------
  ulong pid;

  // enum<procstate>
  int state; // Dead, Queuing, etc,
  bool insyscall;
  char  *psstate; /* What /proc/#/status reports */

  // e.g. "*init*", or name of executable
  char  *text;
  // e.g.. "eve" (no uid/gid in plan9, because of distributed nature of it?)
  char  *user;

  // set by??
  char  *args;
  int nargs;    /* number of bytes of args */

  int kp;   /* true if a kernel process */

//--------------------------------------------------------------------
// Memory
//--------------------------------------------------------------------
  // hash<enum<procseg>, option<ref_own<Segment>>>, elt smalloc'ed?
  Segment *seg[NSEG];
  QLock seglock;  /* locked whenever seg[] changes */

//--------------------------------------------------------------------
// Scheduling
//--------------------------------------------------------------------
  // enum<priority>
  ulong priority; /* priority level */

  ulong delaysched;

  ulong basepri;  /* base priority level */
  uchar fixedpri; /* priority level deson't change */

  ulong cpu;    /* cpu average */
  ulong lastupdate;
  uchar yield;    /* non-zero if the process just did a sleep(0) */
  ulong readytime;  /* time process came ready */
  ulong movetime; /* last time process switched processors */
  int preempted;  /* true if this process hasn't finished the interrupt
         *  that last preempted it
         */
  // option<ref_own?<edf>>
  Edf *edf;   /* if non-null, real-time proc, edf contains scheduling params */

//--------------------------------------------------------------------
// Files
//--------------------------------------------------------------------
  // ref_counted<pgrp>
  Pgrp  *pgrp;    /* Process group for namespace */
  // ref_counted<egrp>
  Egrp  *egrp;    /* Environment group */
  // ref_counted<fgrp>
  Fgrp  *fgrp;    /* File descriptor group */

  // ref<Chan>
  Chan  *slash; // The root!
  // ref_counted<Chan>
  Chan  *dot; // The current directory

//--------------------------------------------------------------------
// Notes
//--------------------------------------------------------------------
  ulong noteid;   /* Equivalent of note group */

  int notepending;  /* note issued but not acted on */

  Note  note[NNOTE];
  short nnote;
  short notified; /* sysnoted is due */
  Note  lastnote;
  int (*notify)(void*, char*);

  void  *ureg;    /* User registers for notes */

//--------------------------------------------------------------------
// Process hierarchy
//--------------------------------------------------------------------
  //list<ref<Waitq>>
  Waitq *waitq;   /* Exited processes wait children */
  Lock  exl;    /* Lock count and waitq */

  Proc  *parent;
  ulong parentpid;

  int nchild;   /* Number of living children */
  int nwait;    /* Number of uncollected wait records */
  QLock qwaitr;
  Rendez  waitr;    /* Place to hang out in wait */


//--------------------------------------------------------------------
// Synchronization
//--------------------------------------------------------------------

  Rgrp  *rgrp;    /* Rendez group */

  uintptr rendtag;  /* Tag for rendezvous */
  uintptr rendval;  /* Value for rendezvous */
  //??
  Proc  *rendhash;  /* Hash list for tag values */

  Rendez  *r;   /* rendezvous point slept on */
  Rendez  sleep;    /* place for syssleep/debug */

//--------------------------------------------------------------------
// Error managment
//--------------------------------------------------------------------

  // array<Label>, error labels, poor's man exceptions in C
  Label errlab[NERR];
  // length(errlab) used.
  int nerrlab;

  char  *syserrstr; /* last error from a system call, errbuf0 or 1 */
  char  *errstr;  /* reason we're unwinding the error stack, errbuf1 or 0 */
  char  errbuf0[ERRMAX];
  char  errbuf1[ERRMAX];

//--------------------------------------------------------------------
// Stats, profiling
//--------------------------------------------------------------------
  // hash<enum<proctime>, ulong>
  ulong time[6];  /* User, Sys, Real; child U, S, R */

  uvlong  kentry;   /* Kernel entry time stamp (for profiling) */
  /*
   * pcycles: cycles spent in this process (updated on procsave/restore)
   * when this is the current proc and we're in the kernel
   * (procrestores outnumber procsaves by one)
   * the number of cycles spent in the proc is pcycles + cycles()
   * when this is not the current process or we're in user mode
   * (procrestores and procsaves balance), it is pcycles.
   */
  vlong pcycles;

//--------------------------------------------------------------------
// For debugger
//--------------------------------------------------------------------

  void  *dbgreg;  /* User registers for devproc */
  ulong pc;   /* DEBUG only */

  // e.g. Proc_tracesyscall
  int procctl;  /* Control for /proc debugging */

  // Syscall
  int scallnr;  /* sys call number - known by db */
  Sargs s;    /* address of this is known by db */

  QLock debug;    /* to access debugging elements of User */
  Proc  *pdbg;    /* the debugging process */
  bool hang;   /* hang at next exec for debug */

//--------------------------------------------------------------------
// Other
//--------------------------------------------------------------------

  Fgrp  *closingfgrp; /* used during teardown */


  ulong procmode; /* proc device default file mode */
  ulong privatemem; /* proc does not let anyone read mem */

  Lock  rlock;    /* sync sleep/wakeup with postnote */
  int newtlb;   /* Pager has changed my pte's, I must flush */
  int noswap;   /* process is not swappable */

  Timer;      /* For tsleep and real-time */
  Rendez  *trend;
  int (*tfn)(void*);
  void  (*kpfun)(void*);
  void  *kparg;

  ArchFPsave  fpsave;   /* address of this is known by db */

  char  genbuf[128];  /* buffer used e.g. for last name element from namec */


  Lock  *lockwait;
  Lock  *lastlock;  /* debugging */
  Lock  *lastilock; /* debugging */

  Mach  *wired;
  Mach  *mp;    /* machine this process last ran on */

  // As long as the current process hold locks (to kernel data structures),
  // we will not schedule another process in unlock(); only the last unlock
  // will eventually cause a rescheduling.
  Ref nlocks;   /* number of locks held by proc */

  bool trace;    /* process being traced? */

  ulong qpc;    /* pc calling last blocking qlock */

  int setargs;

  // enum<fpsavestatus>
  int fpstate;

  ArchProcNotsave;

  /*
   *  machine specific MMU
   */
  ArchProcMMU;

  char  *syscalltrace;  /* syscall trace */

//--------------------------------------------------------------------
// Extra
//--------------------------------------------------------------------

  // list<ref<Proc>> KQlock.head or RWLock.head
  Proc  *qnext;   /* next process on queue for a QLock */
  // option<ref<Qlock>> ??
  QLock *qlock;   /* addr of qlock being queued for DEBUG */

  // list<ref<Proc>> ?? Schedq.head chain?
  Proc  *rnext;   /* next process in run queue */

  // Alarms.head chain?
  Proc  *palarm;  /* Next alarm time */
  ulong alarm;    /* Time of call */

  // hash<?, list<ref<Proc>> Procalloc.ht ?
  Proc  *pidhash; /* next proc in pid hash */ 

  // option<ref<Mach>>, null when not associated to a machine?
  Mach  *mach;    /* machine running this proc */

};

// poor's man exceptions in C
//  - waserror() =~ try  
//     * if (!waserror()) { } else { } <=> try { } catch { }
//     * if (waserror()) { }  <=> finally { }
//  - poperror() = nothing
//  - error() =~ raise
//  - nexterror() =~ re raise from exn handler
// note, setlabel() return false, so the branch is never taken first
// but nexterror() is using gotolabel() which returns true, see l_switch.s
#define waserror()  (up->nerrlab++, setlabel(&up->errlab[up->nerrlab-1]))
#define poperror()    up->nerrlab--


//*****************************************************************************
// Internal to process/
//*****************************************************************************

// Proc allocator (singleton), was actually in proc.c, but important so here
struct Procalloc
{
  // array<Proc>, xalloc'ed in procinit0() (conf.nproc)
  Proc* arena;

  // list<ref<Proc>> (next = ?)
  Proc* free;
  // hash<Proc.pid?, list<ref<Proc>> (next = Proc.pidhash)>
  Proc* ht[128];

  // extra
  Lock;
};
//IMPORTANT: static struct Procalloc procalloc; (in proc.c)

struct Schedq
{
  // list<ref<Proc>> (next = Proc.rnext?)
  Proc* head;
  // list<ref<Proc>> (next = ??)
  Proc* tail;

  int n;

  // extra
  Lock;
};
// hash<enum<priority>, Schedq>, Nrq is the number of priority level (20+2)
//IMPORTANT: Schedq  runq[Nrq];  (in proc.c)

// was in alarm.c, but important so here
struct Alarms
{
  // list<ref<Proc> (next = ??)
  Proc  *head;

  // extra
  QLock;
};
//IMPORTANT: static Alarms alarms; (in alarm.c)
//IMPORTANT: static Rendez alarmr; (in alarm.c)


struct Active
{
  int machs;      /* bitmap of active CPUs */
  int exiting;    /* shutdown */
  int ispanic;    /* shutdown in response to a panic */

  // 386 specific?
  int thunderbirdsarego;  /* lets the added processors continue to schedinit */
  int rebooting;    /* just idle cpus > 0 */

  // extra
  Lock;
};
extern struct Active active;

#pragma varargck  type  "t"   long
#pragma varargck  type  "U"   uvlong

@


\subsection*{[[processes/portfns_processes.h]]}

<<portfns_processes.h>>=

// tod.c
// initialize the hidden global tod.c#tod
void    todinit(void);
void    todsetfreq(vlong);
void    todset(vlong, vlong, int);
vlong   todget(vlong*);
//uvlong    (*fastticks)(uvlong*); is in 386/devarch.c (but used in port)
uvlong    fastticks2us(uvlong);
uvlong    ns2fastticks(uvlong);
long    seconds(void);
//uvlong    tod2fastticks(vlong);
//uvlong    us2fastticks(uvlong);
//uvlong    ms2fastticks(ulong);
//uvlong    fastticks2ns(uvlong);
//todfix(): TODO false positive, static forward decl

// pgrp.c
Rgrp*   newrgrp(void);
Pgrp*   newpgrp(void);
void    closergrp(Rgrp*);
void    closefgrp(Fgrp*);
Fgrp*   dupfgrp(Fgrp*);
void    closepgrp(Pgrp*);
void    pgrpcpy(Pgrp*, Pgrp*);
void    forceclosefgrp(void);
void    pgrpnote(ulong, char*, long, int);
void    mountfree(Mount*);
Mount*    newmount(Mhead*, Chan*, int, char*);
void    resrcwait(char*);

// portclock.c
ulong   tk2ms(ulong);
#define   TK2MS(x) ((x)*(1000/HZ))
#define   MS2NS(n) (((vlong)(n))*1000000LL)
ulong   ms2tk(ulong);
void    timerdel(Timer*);
void    timeradd(Timer*);
Timer*    addclock0link(void (*)(void), int);
void    timerintr(Ureg*, Tval);
void    timersinit(void);
//void    timerset(Tval); is in 386/devarch.c (but used in port)

// proc.c
void exhausted(char*);
// in portfns_core.h, to remove some backward dependencies
//void    (*sleep)(Rendez*, int(*)(void*), void*);
//int (*postnote)(Proc*, int, char*, int);
void    procctl(Proc*);
void    procwired(Proc*, int);
//Proc*   (*wakeup)(Rendez*);
//void    (*error)(char*);
void    procpriority(Proc*, int, int);
//TODO: fp non-deps twakeup, passed as pointer func
//void    (*nexterror)(void);
//void    (*dumpaproc)(Proc*);
void    accounttime(void);
int   canpage(Proc*);
int   anyhigher(void);
void    scheddump(void);
Proc*   dequeueproc(Schedq*, Proc*);
int   preempted(void);
void    killbig(char*);
//@Scheck: not dead, used in segment.c, weird TODO
void    procflushseg(Segment*); 
void    procdump(void);
void    renameuser(char*, char*);
void    procinit0(void);
int   procindex(ulong);
ulong   pwait(Waitmsg*);
//void    (*tsleep)(Rendez*, int (*)(void*), void*, ulong);
void    unbreak(Proc*);
int   freebroken(void);
void    yield(void);
//void    (*pexit)(char*, int);
//void    (*sched)(void);
void    schedinit(void);
//void    (*ready)(Proc*);
Proc*   newproc(void);
void    kproc(char*, void(*)(void*), void*);
void    hzsched(void);
//not used outside: int   anyready(void);
//TODO cg didn't find ref outside in devproc.c?
int   haswaitq(void*);

// alarm.c
ulong   procalarm(ulong);
void    alarmkproc(void*);
void    checkalarms(void);

// edf.c (used to be declared in edf.h)
Edf*    edflock(Proc*);
void    edfunlock(void);
//TODO fp deadlineintr, static func passed via pointer again
void    edfrun(Proc*, int);
void    edfinit(Proc*);
void    edfrecord(Proc*);
void    edfstop(Proc*);
void    edfyield(void);
int   edfready(Proc*);
char*   edfadmit(Proc*);

// sysproc.c
//@Scheck: not useless, used by misc/rebootcmd.c, weird not recognized by cg
ulong   l2be(long);
// many sysxxx functions (used in syscalls/ without requiring extern decl)




// 386/trap.c (but used in port)
void    callwithureg(void(*)(Ureg*));
ulong   dbgpc(Proc*);
long    execregs(ulong, ulong, ulong);
void    forkchild(Proc*, Ureg*);
ulong   userpc(void);
void    setregisters(Ureg*, char*, char*, int);
void    setkernur(Ureg*, Proc*);
void    kprocchild(Proc*, void (*)(void*), void*);
// intrenable(), but mostly used in 386, just in port/devaudio.c

// 386/main_processes.c (but used in port)
void procsetup(Proc*);
void procsave(Proc*);
void procrestore(Proc *);
void idlehands(void);

// 386/i8253.c (but used in port)
ulong   perfticks(void);

// 386/devarch.c (but used in port)
void    timerset(Tval);
ulong   Âµs(void);

// in 386/l.s (but used in port)
//@Scheck: Assembly
void    gotolabel(Label*);
//@Scheck: Assembly
int   setlabel(Label*);
//@Scheck: Assembly
void    mul64fract(uvlong*, uvlong, uvlong);

// portdat_processes.c
void (*proctrace)(Proc*, int, vlong); // was in devproc.c
void (*kproftimer)(ulong); // was in portfns.h
@


\subsection*{[[processes/proc.c]]}

<<proc.c>>=
#include    <u.h>
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
//#include  "../port/edf.h"
#include    <trace.h>

//*****************************************************************************
// Globals
//*****************************************************************************

// The run queue!!
Schedq  runq[Nrq];
ulong   runvec;

static struct Procalloc procalloc;

int schedgain = 30; /* units in seconds */
int nrdy;
// also used by sysrfork()
Ref noteidalloc;

ulong delayedscheds;    /* statistics */
long skipscheds;
long preempts;
//ulong load;

// Abuse Ref ... it's not reference counting, this is really just a counter
static Ref  pidalloc;

enum
{
    Q=10,
    DQ=4,
    Scaling=2,
};

char *statename[] =
{   /* BUG: generate automatically */
    "Dead",
    "Moribund",
    "Ready",
    "Scheding",
    "Running",
    "Queueing",
    "QueueingR",
    "QueueingW",
    "Wakeme",
    "Broken",
    "Stopped",
    "Rendez",
    "Waitrelease",
};

//*****************************************************************************
// Forward decl
//*****************************************************************************

Proc* runproc(void);
void updatecpu(Proc*);
int reprioritize(Proc*);


static void pidhash(Proc*);
static void pidunhash(Proc*);
static void rebalance(void);

//*****************************************************************************
// Error managment
//*****************************************************************************

// see also waserror() and poperror() macro in portdat_processes.h

void
proc_error(char *err)
{
    spllo();

    assert(up->nerrlab < NERR);
    kstrcpy(up->errstr, err, ERRMAX);
    setlabel(&up->errlab[NERR-1]);
    nexterror();
}

// raise an exception
void
proc_nexterror(void)
{
    gotolabel(&up->errlab[--up->nerrlab]);
}

void
exhausted(char *resource)
{
    char buf[ERRMAX];

    snprint(buf, sizeof buf, "no free %s", resource);
    iprint("%s\n", buf);
    error(buf);
}

//*****************************************************************************
// Functions
//*****************************************************************************

/*
 * Always splhi()'ed.
 */
void
schedinit(void)     /* never returns */
{
    Edf *e;

    setlabel(&m->sched);
    if(up) {
        if((e = up->edf) && (e->flags & Admitted))
            edfrecord(up);
        m->proc = 0;
        switch(up->state) {
        case Running:
            ready(up);
            break;
        case Moribund:
            up->state = Dead;
            edfstop(up);
            if (up->edf)
                free(up->edf);
            up->edf = nil;

            /*
             * Holding locks from pexit:
             *  procalloc
             *  palloc
             */
            mmurelease(up);

            up->qnext = procalloc.free;
            procalloc.free = up;

            unlock(&palloc);
            unlock(&procalloc);
            break;
        }
        up->mach = nil;
        updatecpu(up);
        up = nil;
    }
    sched();
}

/*
 *  If changing this routine, look also at sleep().  It
 *  contains a copy of the guts of sched().
 */
void
proc_sched(void)
{
    Proc *p;

    if(m->ilockdepth)
        panic("cpu%d: ilockdepth %d, last lock %#p at %#p, sched called from %#p",
            m->machno,
            m->ilockdepth,
            up? up->lastilock: nil,
            (up && up->lastilock)? up->lastilock->pc: 0,
            getcallerpc(&p+2));
    if(up){
        /*
         * Delay the sched until the process gives up the locks
         * it is holding.  This avoids dumb lock loops.
         * Don't delay if the process is Moribund.
         * It called sched to die.
         * But do sched eventually.  This avoids a missing unlock
         * from hanging the entire kernel. 
         * But don't reschedule procs holding palloc or procalloc.
         * Those are far too important to be holding while asleep.
         *
         * This test is not exact.  There can still be a few instructions
         * in the middle of taslock when a process holds a lock
         * but Lock.p has not yet been initialized.
         */
        if(up->nlocks.ref)
        if(up->state != Moribund)
        if(up->delaysched < 20
        || palloc.Lock.p == up
        || procalloc.Lock.p == up){
            up->delaysched++;
            delayedscheds++;
            return;
        }
        up->delaysched = 0;

        splhi();

        /* statistics */
        m->cs++;

        procsave(up);
        if(setlabel(&up->sched)){
            procrestore(up);
            spllo();
            return;
        }
        gotolabel(&m->sched);
    }
    p = runproc();
    if(!p->edf){
        updatecpu(p);
        p->priority = reprioritize(p);
    }
    if(p != m->readied)
        m->schedticks = m->ticks + HZ/10;
    m->readied = 0;
    up = p;
    up->state = Running;
    up->mach = MACHP(m->machno);
    m->proc = up;
    mmuswitch(up);
    gotolabel(&up->sched);
}

int
anyready(void)
{
    return runvec;
}

int
anyhigher(void)
{
    return runvec & ~((1<<(up->priority+1))-1);
}

/*
 *  here once per clock tick to see if we should resched
 */
void
hzsched(void)
{
    /* once a second, rebalance will reprioritize ready procs */
    if(m->machno == 0)
        rebalance();

    /* unless preempted, get to run for at least 100ms */
    if(anyhigher()
    || (!up->fixedpri && m->ticks > m->schedticks && anyready())){
        m->readied = nil;   /* avoid cooperative scheduling */
        up->delaysched++;
    }
}

/*
 *  here at the end of non-clock interrupts to see if we should preempt the
 *  current process.  Returns 1 if preempted, 0 otherwise.
 */
int
preempted(void)
{
    if(up && up->state == Running)
    if(up->preempted == 0)
    if(anyhigher())
    if(!active.exiting){
        m->readied = nil;   /* avoid cooperative scheduling */
        up->preempted = 1;
        sched();
        splhi();
        up->preempted = 0;
        return 1;
    }
    return 0;
}

/*
 * Update the cpu time average for this particular process,
 * which is about to change from up -> not up or vice versa.
 * p->lastupdate is the last time an updatecpu happened.
 *
 * The cpu time average is a decaying average that lasts
 * about D clock ticks.  D is chosen to be approximately
 * the cpu time of a cpu-intensive "quick job".  A job has to run
 * for approximately D clock ticks before we home in on its 
 * actual cpu usage.  Thus if you manage to get in and get out
 * quickly, you won't be penalized during your burst.  Once you
 * start using your share of the cpu for more than about D
 * clock ticks though, your p->cpu hits 1000 (1.0) and you end up 
 * below all the other quick jobs.  Interactive tasks, because
 * they basically always use less than their fair share of cpu,
 * will be rewarded.
 *
 * If the process has not been running, then we want to
 * apply the filter
 *
 *  cpu = cpu * (D-1)/D
 *
 * n times, yielding 
 * 
 *  cpu = cpu * ((D-1)/D)^n
 *
 * but D is big enough that this is approximately 
 *
 *  cpu = cpu * (D-n)/D
 *
 * so we use that instead.
 * 
 * If the process has been running, we apply the filter to
 * 1 - cpu, yielding a similar equation.  Note that cpu is 
 * stored in fixed point (* 1000).
 *
 * Updatecpu must be called before changing up, in order
 * to maintain accurate cpu usage statistics.  It can be called
 * at any time to bring the stats for a given proc up-to-date.
 */
void
updatecpu(Proc *p)
{
    int n, t, ocpu;
    int D = schedgain*HZ*Scaling;

    if(p->edf)
        return;

    t = MACHP(0)->ticks*Scaling + Scaling/2;
    n = t - p->lastupdate;
    p->lastupdate = t;

    if(n == 0)
        return;
    if(n > D)
        n = D;

    ocpu = p->cpu;
    if(p != up)
        p->cpu = (ocpu*(D-n))/D;
    else{
        t = 1000 - ocpu;
        t = (t*(D-n))/D;
        p->cpu = 1000 - t;
    }

//iprint("pid %d %s for %d cpu %d -> %d\n", p->pid,p==up?"active":"inactive",n, ocpu,p->cpu);
}

/*
 * On average, p has used p->cpu of a cpu recently.
 * Its fair share is conf.nmach/m->load of a cpu.  If it has been getting
 * too much, penalize it.  If it has been getting not enough, reward it.
 * I don't think you can get much more than your fair share that 
 * often, so most of the queues are for using less.  Having a priority
 * of 3 means you're just right.  Having a higher priority (up to p->basepri) 
 * means you're not using as much as you could.
 */
int
reprioritize(Proc *p)
{
    int fairshare, n, load, ratio;

    load = MACHP(0)->load;
    if(load == 0)
        return p->basepri;

    /*
     *  fairshare = 1.000 * conf.nproc * 1.000/load,
     * except the decimal point is moved three places
     * on both load and fairshare.
     */
    fairshare = (conf.nmach*1000*1000)/load;
    n = p->cpu;
    if(n == 0)
        n = 1;
    ratio = (fairshare+n/2) / n;
    if(ratio > p->basepri)
        ratio = p->basepri;
    if(ratio < 0)
        panic("reprioritize");
//iprint("pid %d cpu %d load %d fair %d pri %d\n", p->pid, p->cpu, load, fairshare, ratio);
    return ratio;
}

/*
 * add a process to a scheduling queue
 */
void
queueproc(Schedq *rq, Proc *p)
{
    int pri;

    pri = rq - runq;
    lock(runq);
    p->priority = pri;
    p->rnext = 0;
    if(rq->tail)
        rq->tail->rnext = p;
    else
        rq->head = p;
    rq->tail = p;
    rq->n++;
    nrdy++;
    runvec |= 1<<pri;
    unlock(runq);
}

/*
 *  try to remove a process from a scheduling queue (called splhi)
 */
Proc*
dequeueproc(Schedq *rq, Proc *tp)
{
    Proc *l, *p;

    if(!canlock(runq))
        return nil;

    /*
     *  the queue may have changed before we locked runq,
     *  refind the target process.
     */
    l = 0;
    for(p = rq->head; p; p = p->rnext){
        if(p == tp)
            break;
        l = p;
    }

    /*
     *  p->mach==0 only when process state is saved
     */
    if(p == 0 || p->mach){
        unlock(runq);
        return nil;
    }
    if(p->rnext == 0)
        rq->tail = l;
    if(l)
        l->rnext = p->rnext;
    else
        rq->head = p->rnext;
    if(rq->head == nil)
        runvec &= ~(1<<(rq-runq));
    rq->n--;
    nrdy--;
    if(p->state != Ready)
        print("dequeueproc %s %lud %s\n", p->text, p->pid, statename[p->state]);

    unlock(runq);
    return p;
}

/*
 *  ready(p) picks a new priority for a process and sticks it in the
 *  runq for that priority.
 */
void
proc_ready(Proc *p)
{
    int s, pri;
    Schedq *rq;
    void (*pt)(Proc*, int, vlong);

    s = splhi();
    if(edfready(p)){
        splx(s);
        return;
    }

    if(up != p && (p->wired == nil || p->wired == m))
        m->readied = p; /* group scheduling */

    updatecpu(p);
    pri = reprioritize(p);
    p->priority = pri;
    rq = &runq[pri];
    p->state = Ready;
    queueproc(rq, p);
    pt = proctrace;
    if(pt)
        pt(p, SReady, 0);
    splx(s);
}

/*
 *  yield the processor and drop our priority
 */
void
yield(void)
{
    if(anyready()){
        /* pretend we just used 1/2 tick */
        up->lastupdate -= Scaling/2;  
        sched();
    }
}

/*
 *  recalculate priorities once a second.  We need to do this
 *  since priorities will otherwise only be recalculated when
 *  the running process blocks.
 */
ulong balancetime;

static void
rebalance(void)
{
    int pri, npri, t, x;
    Schedq *rq;
    Proc *p;

    t = m->ticks;
    if(t - balancetime < HZ)
        return;
    balancetime = t;

    for(pri=0, rq=runq; pri<Npriq; pri++, rq++){
another:
        p = rq->head;
        if(p == nil)
            continue;
        if(p->mp != MACHP(m->machno))
            continue;
        if(pri == p->basepri)
            continue;
        updatecpu(p);
        npri = reprioritize(p);
        if(npri != pri){
            x = splhi();
            p = dequeueproc(rq, p);
            if(p)
                queueproc(&runq[npri], p);
            splx(x);
            goto another;
        }
    }
}
    

/*
 *  pick a process to run
 */
Proc*
runproc(void)
{
    Schedq *rq;
    Proc *p;
    ulong start, now;
    int i;
    void (*pt)(Proc*, int, vlong);

    start = perfticks();

    /* cooperative scheduling until the clock ticks */
    if((p=m->readied) && p->mach==0 && p->state==Ready
    && (p->wired == nil || p->wired == m)
    && runq[Nrq-1].head == nil && runq[Nrq-2].head == nil){
        skipscheds++;
        rq = &runq[p->priority];
        goto found;
    }

    preempts++;

loop:
    /*
     *  find a process that last ran on this processor (affinity),
     *  or one that hasn't moved in a while (load balancing).  Every
     *  time around the loop affinity goes down.
     */
    spllo();
    for(i = 0;; i++){
        /*
         *  find the highest priority target process that this
         *  processor can run given affinity constraints.
         *
         */
        for(rq = &runq[Nrq-1]; rq >= runq; rq--){
            for(p = rq->head; p; p = p->rnext){
                if(p->mp == nil || p->mp == MACHP(m->machno)
                || (!p->wired && i > 0))
                    goto found;
            }
        }

        /* waste time or halt the CPU */
        idlehands();

        /* remember how much time we're here */
        now = perfticks();
        m->perf.inidle += now-start;
        start = now;
    }

found:
    splhi();
    p = dequeueproc(rq, p);
    if(p == nil)
        goto loop;

    p->state = Scheding;
    p->mp = MACHP(m->machno);

    if(edflock(p)){
        edfrun(p, rq == &runq[PriEdf]); /* start deadline timer and do admin */
        edfunlock();
    }
    pt = proctrace;
    if(pt)
        pt(p, SRun, 0);
    return p;
}

int
canpage(Proc *p)
{
    int ok = 0;

    splhi();
    lock(runq);
    /* Only reliable way to see if we are Running */
    if(p->mach == 0) {
        p->newtlb = 1;
        ok = 1;
    }
    unlock(runq);
    spllo();

    return ok;
}

void
noprocpanic(char *msg)
{
    /*
     * setting exiting will make hzclock() on each processor call exit(0).
     * clearing our bit in machs avoids calling exit(0) from hzclock()
     * on this processor.
     */
    lock(&active);
    active.machs &= ~(1<<m->machno);
    active.exiting = 1;
    unlock(&active);

    procdump();
    delay(1000);
    panic(msg);
}

Proc*
newproc(void)
{
    char msg[64];
    Proc *p;

    lock(&procalloc);
    while((p = procalloc.free) == nil) {
        unlock(&procalloc);

        snprint(msg, sizeof msg, "no procs; %s forking",
            up? up->text: "kernel");
        /*
         * the situation is unlikely to heal itself.
         * dump the proc table and restart by default.
         * *noprocspersist in plan9.ini will yield the old
         * behaviour of trying forever.
         */
        if(getconf("*noprocspersist") == nil)
            noprocpanic(msg);
        resrcwait(msg);
        lock(&procalloc);
    }
    procalloc.free = p->qnext;
    unlock(&procalloc);

    p->state = Scheding;
    p->psstate = "New";
    p->mach = 0;
    p->qnext = 0;
    p->nchild = 0;
    p->nwait = 0;
    p->waitq = 0;
    p->parent = 0;
    p->pgrp = 0;
    p->egrp = 0;
    p->fgrp = 0;
    p->rgrp = 0;
    p->pdbg = 0;
    p->fpstate = FPinit;
    p->kp = 0;
    if(up && up->procctl == Proc_tracesyscall)
        p->procctl = Proc_tracesyscall;
    else
        p->procctl = 0;
    p->syscalltrace = 0;    
    p->notepending = 0;
    p->ureg = 0;
    p->privatemem = 0;
    p->noswap = 0;
    p->errstr = p->errbuf0;
    p->syserrstr = p->errbuf1;
    p->errbuf0[0] = '\0';
    p->errbuf1[0] = '\0';
    p->nlocks.ref = 0;
    p->delaysched = 0;
    p->trace = 0;
    kstrdup(&p->user, "*nouser");
    kstrdup(&p->text, "*notext");
    kstrdup(&p->args, "");
    p->nargs = 0;
    p->setargs = 0;
    memset(p->seg, 0, sizeof p->seg);
    p->pid = incref(&pidalloc);
    pidhash(p);
    p->noteid = incref(&noteidalloc);
    if(p->pid==0 || p->noteid==0)
        panic("pidalloc");
    if(p->kstack == 0)
        p->kstack = smalloc(KSTACK);

    /* sched params */
    p->mp = 0;
    p->wired = 0;
    procpriority(p, PriNormal, 0);
    p->cpu = 0;
    p->lastupdate = MACHP(0)->ticks*Scaling;
    p->edf = nil;

    return p;
}

/*
 * wire this proc to a machine
 */
void
procwired(Proc *p, int bm)
{
    Proc *pp;
    int i;
    char nwired[MAXMACH];
    Mach *wm;

    if(bm < 0){
        /* pick a machine to wire to */
        memset(nwired, 0, sizeof(nwired));
        p->wired = 0;
        pp = proctab(0);
        for(i=0; i<conf.nproc; i++, pp++){
            wm = pp->wired;
            if(wm && pp->pid)
                nwired[wm->machno]++;
        }
        bm = 0;
        for(i=0; i<conf.nmach; i++)
            if(nwired[i] < nwired[bm])
                bm = i;
    } else {
        /* use the virtual machine requested */
        bm = bm % conf.nmach;
    }

    p->wired = MACHP(bm);
    p->mp = p->wired;
}

void
procpriority(Proc *p, int pri, int fixed)
{
    if(pri >= Npriq)
        pri = Npriq - 1;
    else if(pri < 0)
        pri = 0;
    p->basepri = pri;
    p->priority = pri;
    if(fixed){
        p->fixedpri = 1;
    } else {
        p->fixedpri = 0;
    }
}

void
procinit0(void)     /* bad planning - clashes with devproc.c */
{
    Proc *p;
    int i;

    procalloc.free = xalloc(conf.nproc*sizeof(Proc));
    if(procalloc.free == nil){
        xsummary();
        panic("cannot allocate %lud procs (%ludMB)\n", 
                      conf.nproc, conf.nproc*sizeof(Proc)/(1024*1024));
    }
    procalloc.arena = procalloc.free;

    p = procalloc.free;
    for(i=0; i<conf.nproc-1; i++,p++)
        p->qnext = p+1;
    p->qnext = 0;
}

/*
 *  sleep if a condition is not true.  Another process will
 *  awaken us after it sets the condition.  When we awaken
 *  the condition may no longer be true.
 *
 *  we lock both the process and the rendezvous to keep r->p
 *  and p->r synchronized.
 */
void
proc_sleep(Rendez *r, int (*f)(void*), void *arg)
{
    int s;
    void (*pt)(Proc*, int, vlong);

    s = splhi();

    if(up->nlocks.ref)
        print("process %lud sleeps with %lud locks held, last lock %#p locked at pc %#lux, sleep called from %#p\n",
            up->pid, up->nlocks.ref, up->lastlock, up->lastlock->pc, getcallerpc(&r));
    lock(r);
    lock(&up->rlock);
    if(r->p){
        print("double sleep called from %#p, %lud %lud\n", getcallerpc(&r), r->p->pid, up->pid);
        dumpstack();
    }

    /*
     *  Wakeup only knows there may be something to do by testing
     *  r->p in order to get something to lock on.
     *  Flush that information out to memory in case the sleep is
     *  committed.
     */
    r->p = up;

    if((*f)(arg) || up->notepending){
        /*
         *  if condition happened or a note is pending
         *  never mind
         */
        r->p = nil;
        unlock(&up->rlock);
        unlock(r);
    } else {
        /*
         *  now we are committed to
         *  change state and call scheduler
         */
        pt = proctrace;
        if(pt)
            pt(up, SSleep, 0);
        up->state = Wakeme;
        up->r = r;

        /* statistics */
        m->cs++;

        procsave(up);
        if(setlabel(&up->sched)) {
            /*
             *  here when the process is awakened
             */
            procrestore(up);
            spllo();
        } else {
            /*
             *  here to go to sleep (i.e. stop Running)
             */
            unlock(&up->rlock);
            unlock(r);
            gotolabel(&m->sched);
        }
    }

    if(up->notepending) {
        up->notepending = 0;
        splx(s);
        if(up->procctl == Proc_exitme && up->closingfgrp)
            forceclosefgrp();
        error(Eintr);
    }

    splx(s);
}

static int
tfn(void *arg)
{
    return up->trend == nil || up->tfn(arg);
}

//@Scheck: FP!! TODO because assigned in field of unnamed substructure
void
twakeup(Ureg*, Timer *t)
{
    Proc *p;
    Rendez *trend;

    p = t->ta;
    trend = p->trend;
    p->trend = 0;
    if(trend)
        wakeup(trend);
}

void
proc_tsleep(Rendez *r, int (*fn)(void*), void *arg, ulong ms)
{
    if (up->tt){
        print("tsleep: timer active: mode %d, tf %#p\n", up->tmode, up->tf);
        timerdel(up);
    }
    up->tns = MS2NS(ms);
    up->tf = twakeup;
    up->tmode = Trelative;
    up->ta = up;
    up->trend = r;
    up->tfn = fn;
    timeradd(up);

    if(waserror()){
        timerdel(up);
        nexterror();
    }
    sleep(r, tfn, arg);
    if(up->tt)
        timerdel(up);
    up->twhen = 0;
    poperror();
}

/*
 *  Expects that only one process can call wakeup for any given Rendez.
 *  We hold both locks to ensure that r->p and p->r remain consistent.
 *  Richard Miller has a better solution that doesn't require both to
 *  be held simultaneously, but I'm a paranoid - presotto.
 */
Proc*
proc_wakeup(Rendez *r)
{
    Proc *p;
    int s;

    s = splhi();

    lock(r);
    p = r->p;

    if(p != nil){
        lock(&p->rlock);
        if(p->state != Wakeme || p->r != r){
            iprint("%p %p %d\n", p->r, r, p->state);
            panic("wakeup: state");
        }
        r->p = nil;
        p->r = nil;
        ready(p);
        unlock(&p->rlock);
    }
    unlock(r);

    splx(s);

    return p;
}

/*
 *  if waking a sleeping process, this routine must hold both
 *  p->rlock and r->lock.  However, it can't know them in
 *  the same order as wakeup causing a possible lock ordering
 *  deadlock.  We break the deadlock by giving up the p->rlock
 *  lock if we can't get the r->lock and retrying.
 */
int
proc_postnote(Proc *p, int dolock, char *n, int flag)
{
    int s, ret;
    Rendez *r;
    Proc *d, **l;

    if(dolock)
        qlock(&p->debug);

    if(flag != NUser && (p->notify == 0 || p->notified))
        p->nnote = 0;

    ret = 0;
    if(p->nnote < NNOTE) {
        strcpy(p->note[p->nnote].msg, n);
        p->note[p->nnote++].flag = flag;
        ret = 1;
    }
    p->notepending = 1;
    if(dolock)
        qunlock(&p->debug);

    /* this loop is to avoid lock ordering problems. */
    for(;;){
        s = splhi();
        lock(&p->rlock);
        r = p->r;

        /* waiting for a wakeup? */
        if(r == nil)
            break;  /* no */

        /* try for the second lock */
        if(canlock(r)){
            if(p->state != Wakeme || r->p != p)
                panic("postnote: state %d %d %d", r->p != p, p->r != r, p->state);
            p->r = nil;
            r->p = nil;
            ready(p);
            unlock(r);
            break;
        }

        /* give other process time to get out of critical section and try again */
        unlock(&p->rlock);
        splx(s);
        sched();
    }
    unlock(&p->rlock);
    splx(s);

    if(p->state != Rendezvous)
        return ret;

    /* Try and pull out of a rendezvous */
    lock(p->rgrp);
    if(p->state == Rendezvous) {
        p->rendval = ~0;
        l = &REND(p->rgrp, p->rendtag);
        for(d = *l; d; d = d->rendhash) {
            if(d == p) {
                *l = p->rendhash;
                break;
            }
            l = &d->rendhash;
        }
        ready(p);
    }
    unlock(p->rgrp);
    return ret;
}

/*
 * weird thing: keep at most NBROKEN around
 */
#define NBROKEN 4
struct
{
    QLock;
    int n;
    Proc    *p[NBROKEN];
}broken;

void
addbroken(Proc *p)
{
    qlock(&broken);
    if(broken.n == NBROKEN) {
        ready(broken.p[0]);
        memmove(&broken.p[0], &broken.p[1], sizeof(Proc*)*(NBROKEN-1));
        --broken.n;
    }
    broken.p[broken.n++] = p;
    qunlock(&broken);

    edfstop(up);
    p->state = Broken;
    p->psstate = 0;
    sched();
}

void
unbreak(Proc *p)
{
    int b;

    qlock(&broken);
    for(b=0; b < broken.n; b++)
        if(broken.p[b] == p) {
            broken.n--;
            memmove(&broken.p[b], &broken.p[b+1],
                    sizeof(Proc*)*(NBROKEN-(b+1)));
            ready(p);
            break;
        }
    qunlock(&broken);
}

int
freebroken(void)
{
    int i, n;

    qlock(&broken);
    n = broken.n;
    for(i=0; i<n; i++) {
        ready(broken.p[i]);
        broken.p[i] = 0;
    }
    broken.n = 0;
    qunlock(&broken);
    return n;
}

void
proc_pexit(char *exitstr, int freemem)
{
    Proc *p;
    Segment **s, **es;
    long utime, stime;
    Waitq *wq, *f, *next;
    Fgrp *fgrp;
    Egrp *egrp;
    Rgrp *rgrp;
    Pgrp *pgrp;
    Chan *dot;
    void (*pt)(Proc*, int, vlong);

    if(up->syscalltrace)
        free(up->syscalltrace);
    up->alarm = 0;
    if (up->tt)
        timerdel(up);
    pt = proctrace;
    if(pt)
        pt(up, SDead, 0);

    /* nil out all the resources under lock (free later) */
    qlock(&up->debug);
    fgrp = up->fgrp;
    up->fgrp = nil;
    egrp = up->egrp;
    up->egrp = nil;
    rgrp = up->rgrp;
    up->rgrp = nil;
    pgrp = up->pgrp;
    up->pgrp = nil;
    dot = up->dot;
    up->dot = nil;
    qunlock(&up->debug);

    if(fgrp)
        closefgrp(fgrp);
    if(egrp)
        closeegrp(egrp);
    if(rgrp)
        closergrp(rgrp);
    if(dot)
        cclose(dot);
    if(pgrp)
        closepgrp(pgrp);

    /*
     * if not a kernel process and have a parent,
     * do some housekeeping.
     */
    if(up->kp == 0) {
        p = up->parent;
        if(p == 0) {
            if(exitstr == 0)
                exitstr = "unknown";
            panic("boot process died: %s", exitstr);
        }

        while(waserror())
            ;

        wq = smalloc(sizeof(Waitq));
        poperror();

        wq->w.pid = up->pid;
        utime = up->time[TUser] + up->time[TCUser];
        stime = up->time[TSys] + up->time[TCSys];
        wq->w.time[TUser] = tk2ms(utime);
        wq->w.time[TSys] = tk2ms(stime);
        wq->w.time[TReal] = tk2ms(MACHP(0)->ticks - up->time[TReal]);
        if(exitstr && exitstr[0])
            snprint(wq->w.msg, sizeof(wq->w.msg), "%s %lud: %s", up->text, up->pid, exitstr);
        else
            wq->w.msg[0] = '\0';

        lock(&p->exl);
        /*
         * Check that parent is still alive.
         */
        if(p->pid == up->parentpid && p->state != Broken) {
            p->nchild--;
            p->time[TCUser] += utime;
            p->time[TCSys] += stime;
            /*
             * If there would be more than 128 wait records
             * processes for my parent, then don't leave a wait
             * record behind.  This helps prevent badly written
             * daemon processes from accumulating lots of wait
             * records.
             */
            if(p->nwait < 128) {
                wq->next = p->waitq;
                p->waitq = wq;
                p->nwait++;
                wq = nil;
                wakeup(&p->waitr);
            }
        }
        unlock(&p->exl);
        if(wq)
            free(wq);
    }

    if(!freemem)
        addbroken(up);

    qlock(&up->seglock);
    es = &up->seg[NSEG];
    for(s = up->seg; s < es; s++) {
        if(*s) {
            putseg(*s);
            *s = 0;
        }
    }
    qunlock(&up->seglock);

    lock(&up->exl);     /* Prevent my children from leaving waits */
    pidunhash(up);
    up->pid = 0;
    wakeup(&up->waitr);
    unlock(&up->exl);

    for(f = up->waitq; f; f = next) {
        next = f->next;
        free(f);
    }

    /* release debuggers */
    qlock(&up->debug);
    if(up->pdbg) {
        wakeup(&up->pdbg->sleep);
        up->pdbg = 0;
    }
    qunlock(&up->debug);

    /* Sched must not loop for these locks */
    lock(&procalloc);
    lock(&palloc);

    edfstop(up);
    up->state = Moribund;
    sched();
    panic("pexit");
}

int
haswaitq(void *x)
{
    Proc *p;

    p = (Proc *)x;
    return p->waitq != 0;
}

ulong
pwait(Waitmsg *w)
{
    ulong cpid;
    Waitq *wq;

    if(!canqlock(&up->qwaitr))
        error(Einuse);

    if(waserror()) {
        qunlock(&up->qwaitr);
        nexterror();
    }

    lock(&up->exl);
    if(up->nchild == 0 && up->waitq == 0) {
        unlock(&up->exl);
        error(Enochild);
    }
    unlock(&up->exl);

    sleep(&up->waitr, haswaitq, up);

    lock(&up->exl);
    wq = up->waitq;
    up->waitq = wq->next;
    up->nwait--;
    unlock(&up->exl);

    qunlock(&up->qwaitr);
    poperror();

    if(w)
        memmove(w, &wq->w, sizeof(Waitmsg));
    cpid = wq->w.pid;
    free(wq);
    return cpid;
}

Proc*
proc_proctab(int i)
{
    return &procalloc.arena[i];
}

void
proc_dumpaproc(Proc *p)
{
    ulong bss;
    char *s;

    if(p == 0)
        return;

    bss = 0;
    if(p->seg[BSEG])
        bss = p->seg[BSEG]->top;

    s = p->psstate;
    if(s == 0)
        s = statename[p->state];
    print("%3lud:%10s pc %8lux dbgpc %8lux  %8s (%s) ut %ld st %ld bss %lux qpc %lux nl %lud nd %lud lpc %lux pri %lud\n",
        p->pid, p->text, p->pc, dbgpc(p),  s, statename[p->state],
        p->time[0], p->time[1], bss, p->qpc, p->nlocks.ref, p->delaysched, p->lastlock ? p->lastlock->pc : 0, p->priority);
}

void
procdump(void)
{
    int i;
    Proc *p;

    if(up)
        print("up %lud\n", up->pid);
    else
        print("no current process\n");
    for(i=0; i<conf.nproc; i++) {
        p = &procalloc.arena[i];
        if(p->state == Dead)
            continue;

        dumpaproc(p);
    }
}

/*
 *  wait till all processes have flushed their mmu
 *  state about segement s
 */
//@Scheck: not dead, used in segment.c, weird
void
procflushseg(Segment *s)
{
    int i, ns, nm, nwait;
    Proc *p;

    /*
     *  tell all processes with this
     *  segment to flush their mmu's
     */
    nwait = 0;
    for(i=0; i<conf.nproc; i++) {
        p = &procalloc.arena[i];
        if(p->state == Dead)
            continue;
        for(ns = 0; ns < NSEG; ns++)
            if(p->seg[ns] == s){
                p->newtlb = 1;
                for(nm = 0; nm < conf.nmach; nm++){
                    if(MACHP(nm)->proc == p){
                        MACHP(nm)->flushmmu = 1;
                        nwait++;
                    }
                }
                break;
            }
    }

    if(nwait == 0)
        return;

    /*
     *  wait for all processors to take a clock interrupt
     *  and flush their mmu's
     */
    for(nm = 0; nm < conf.nmach; nm++)
        if(MACHP(nm) != m)
            while(MACHP(nm)->flushmmu)
                sched();
}

void
scheddump(void)
{
    Proc *p;
    Schedq *rq;

    for(rq = &runq[Nrq-1]; rq >= runq; rq--){
        if(rq->head == 0)
            continue;
        print("rq%ld:", rq-runq);
        for(p = rq->head; p; p = p->rnext)
            print(" %lud(%lud)", p->pid, m->ticks - p->readytime);
        print("\n");
        delay(150);
    }
    print("nrdy %d\n", nrdy);
}

// kernel process (aka kernel_thread in Linux?)
void
kproc(char *name, void (*func)(void *), void *arg)
{
    Proc *p;
    static Pgrp *kpgrp;

    p = newproc();
    p->psstate = 0;
    p->procmode = 0640;
    p->kp = 1; // Kernel Process
    p->noswap = 1;

    p->fpsave = up->fpsave;
    p->scallnr = up->scallnr;
    p->s = up->s;
    p->nerrlab = 0;
    p->slash = up->slash;
    p->dot = up->dot;
    if(p->dot)
        incref(p->dot);

    memmove(p->note, up->note, sizeof(p->note));
    p->nnote = up->nnote;
    p->notified = 0;
    p->lastnote = up->lastnote;
    p->notify = up->notify;
    p->ureg = 0;
    p->dbgreg = 0;

    procpriority(p, PriKproc, 0);

    kprocchild(p, func, arg);

    kstrdup(&p->user, eve);
    kstrdup(&p->text, name);
    if(kpgrp == 0)
        kpgrp = newpgrp();
    p->pgrp = kpgrp;
    incref(kpgrp);

    memset(p->time, 0, sizeof(p->time));
    p->time[TReal] = MACHP(0)->ticks;
    ready(p);
}

/*
 *  called splhi() by notify().  See comment in notify for the
 *  reasoning.
 */
void
procctl(Proc *p)
{
    char *state;
    ulong s;

    switch(p->procctl) {
    case Proc_exitbig:
        spllo();
        pexit("Killed: Insufficient physical memory", 1);

    case Proc_exitme:
        spllo();        /* pexit has locks in it */
        pexit("Killed", 1);

    case Proc_traceme:
        if(p->nnote == 0)
            return;
        /* No break */

    case Proc_stopme:
        p->procctl = 0;
        state = p->psstate;
        p->psstate = "Stopped";
        /* free a waiting debugger */
        s = spllo();
        qlock(&p->debug);
        if(p->pdbg) {
            wakeup(&p->pdbg->sleep);
            p->pdbg = 0;
        }
        qunlock(&p->debug);
        splhi();
        p->state = Stopped;
        sched();
        p->psstate = state;
        splx(s);
        return;
    }
}


void
killbig(char *why)
{
    int i;
    Segment *s;
    ulong l, max;
    Proc *p, *ep, *kp;

    max = 0;
    kp = 0;
    ep = procalloc.arena+conf.nproc;
    for(p = procalloc.arena; p < ep; p++) {
        if(p->state == Dead || p->kp)
            continue;
        l = 0;
        for(i=1; i<NSEG; i++) {
            s = p->seg[i];
            if(s != 0)
                l += s->top - s->base;
        }
        if(l > max && ((p->procmode&0222) || strcmp(eve, p->user)!=0)) {
            kp = p;
            max = l;
        }
    }

    print("%lud: %s killed: %s\n", kp->pid, kp->text, why);
    for(p = procalloc.arena; p < ep; p++) {
        if(p->state == Dead || p->kp)
            continue;
        if(p != kp && p->seg[BSEG] && p->seg[BSEG] == kp->seg[BSEG])
            p->procctl = Proc_exitbig;
    }
    kp->procctl = Proc_exitbig;
    for(i = 0; i < NSEG; i++) {
        s = kp->seg[i];
        if(s != 0 && canqlock(&s->lk)) {
            mfreeseg(s, s->base, (s->top - s->base)/BY2PG);
            qunlock(&s->lk);
        }
    }
}

/*
 *  change ownership to 'new' of all processes owned by 'old'.  Used when
 *  eve changes.
 */
void
renameuser(char *old, char *new)
{
    Proc *p, *ep;

    ep = procalloc.arena+conf.nproc;
    for(p = procalloc.arena; p < ep; p++)
        if(p->user!=nil && strcmp(old, p->user)==0)
            kstrdup(&p->user, new);
}

/*
 *  time accounting called by clock() splhi'd
 */
void
accounttime(void)
{
    Proc *p;
    ulong n, per;
    static ulong nrun;

    p = m->proc;
    if(p) {
        nrun++;
        p->time[p->insyscall]++;
    }

    /* calculate decaying duty cycles */
    n = perfticks();
    per = n - m->perf.last;
    m->perf.last = n;
    per = (m->perf.period*(HZ-1) + per)/HZ;
    if(per != 0)
        m->perf.period = per;

    m->perf.avg_inidle = (m->perf.avg_inidle*(HZ-1)+m->perf.inidle)/HZ;
    m->perf.inidle = 0;

    m->perf.avg_inintr = (m->perf.avg_inintr*(HZ-1)+m->perf.inintr)/HZ;
    m->perf.inintr = 0;

    /* only one processor gets to compute system load averages */
    if(m->machno != 0)
        return;

    /*
     * calculate decaying load average.
     * if we decay by (n-1)/n then it takes
     * n clock ticks to go from load L to .36 L once
     * things quiet down.  it takes about 5 n clock
     * ticks to go to zero.  so using HZ means this is
     * approximately the load over the last second,
     * with a tail lasting about 5 seconds.
     */
    n = nrun;
    nrun = 0;
    n = (nrdy+n)*1000;
    m->load = (m->load*(HZ-1)+n)/HZ;
}

static void
pidhash(Proc *p)
{
    int h;

    h = p->pid % nelem(procalloc.ht);
    lock(&procalloc);
    p->pidhash = procalloc.ht[h];
    procalloc.ht[h] = p;
    unlock(&procalloc);
}

static void
pidunhash(Proc *p)
{
    int h;
    Proc **l;

    h = p->pid % nelem(procalloc.ht);
    lock(&procalloc);
    for(l = &procalloc.ht[h]; *l != nil; l = &(*l)->pidhash)
        if(*l == p){
            *l = p->pidhash;
            break;
        }
    unlock(&procalloc);
}

int
procindex(ulong pid)
{
    Proc *p;
    int h;
    int s;

    s = -1;
    h = pid % nelem(procalloc.ht);
    lock(&procalloc);
    for(p = procalloc.ht[h]; p != nil; p = p->pidhash)
        if(p->pid == pid){
            s = p - procalloc.arena;
            break;
        }
    unlock(&procalloc);
    return s;
}
@


\subsection*{[[processes/sysproc.c]]}

<<sysproc.c>>=
#include    "u.h"
#include    "tos.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
//#include  "../port/edf.h"

#include    <a.out.h>

enum
{
    RFNAMEG     = (1<<0),
    RFENVG      = (1<<1),
    RFFDG       = (1<<2),
    RFNOTEG     = (1<<3),
    RFPROC      = (1<<4),
    RFMEM       = (1<<5),
    RFNOWAIT    = (1<<6),
    RFCNAMEG    = (1<<10),
    RFCENVG     = (1<<11),
    RFCFDG      = (1<<12),
    RFREND      = (1<<13),
    RFNOMNT     = (1<<14),
};


int shargs(char*, int, char**);


long
sysr1(ulong*)
{
    checkpagerefs();
    return 0;
}

long
sysrfork(ulong *arg)
{
    Proc *p;
    int n, i;
    Fgrp *ofg;
    Pgrp *opg;
    Rgrp *org;
    Egrp *oeg;
    ulong pid, flag;
    Mach *wm;

    flag = arg[0];
    /* Check flags before we commit */
    if((flag & (RFFDG|RFCFDG)) == (RFFDG|RFCFDG))
        error(Ebadarg);
    if((flag & (RFNAMEG|RFCNAMEG)) == (RFNAMEG|RFCNAMEG))
        error(Ebadarg);
    if((flag & (RFENVG|RFCENVG)) == (RFENVG|RFCENVG))
        error(Ebadarg);

    if((flag&RFPROC) == 0) {
        if(flag & (RFMEM|RFNOWAIT))
            error(Ebadarg);
        if(flag & (RFFDG|RFCFDG)) {
            ofg = up->fgrp;
            if(flag & RFFDG)
                up->fgrp = dupfgrp(ofg);
            else
                up->fgrp = dupfgrp(nil);
            closefgrp(ofg);
        }
        if(flag & (RFNAMEG|RFCNAMEG)) {
            opg = up->pgrp;
            up->pgrp = newpgrp();
            if(flag & RFNAMEG)
                pgrpcpy(up->pgrp, opg);
            /* inherit noattach */
            up->pgrp->noattach = opg->noattach;
            closepgrp(opg);
        }
        if(flag & RFNOMNT)
            up->pgrp->noattach = 1;
        if(flag & RFREND) {
            org = up->rgrp;
            up->rgrp = newrgrp();
            closergrp(org);
        }
        if(flag & (RFENVG|RFCENVG)) {
            oeg = up->egrp;
            up->egrp = smalloc(sizeof(Egrp));
            up->egrp->ref = 1;
            if(flag & RFENVG)
                envcpy(up->egrp, oeg);
            closeegrp(oeg);
        }
        if(flag & RFNOTEG)
            up->noteid = incref(&noteidalloc);
        return 0;
    }

    p = newproc();

    p->fpsave = up->fpsave;
    p->scallnr = up->scallnr;
    p->s = up->s;
    p->nerrlab = 0;
    p->slash = up->slash;
    p->dot = up->dot;
    incref(p->dot);

    memmove(p->note, up->note, sizeof(p->note));
    p->privatemem = up->privatemem;
    p->noswap = up->noswap;
    p->nnote = up->nnote;
    p->notified = 0;
    p->lastnote = up->lastnote;
    p->notify = up->notify;
    p->ureg = up->ureg;
    p->dbgreg = 0;

    /* Make a new set of memory segments */
    n = flag & RFMEM;
    qlock(&p->seglock);
    if(waserror()){
        qunlock(&p->seglock);
        nexterror();
    }
    for(i = 0; i < NSEG; i++)
        if(up->seg[i])
            p->seg[i] = dupseg(up->seg, i, n);
    qunlock(&p->seglock);
    poperror();

    /* File descriptors */
    if(flag & (RFFDG|RFCFDG)) {
        if(flag & RFFDG)
            p->fgrp = dupfgrp(up->fgrp);
        else
            p->fgrp = dupfgrp(nil);
    }
    else {
        p->fgrp = up->fgrp;
        incref(p->fgrp);
    }

    /* Process groups */
    if(flag & (RFNAMEG|RFCNAMEG)) {
        p->pgrp = newpgrp();
        if(flag & RFNAMEG)
            pgrpcpy(p->pgrp, up->pgrp);
        /* inherit noattach */
        p->pgrp->noattach = up->pgrp->noattach;
    }
    else {
        p->pgrp = up->pgrp;
        incref(p->pgrp);
    }
    if(flag & RFNOMNT)
        p->pgrp->noattach = 1;

    if(flag & RFREND)
        p->rgrp = newrgrp();
    else {
        incref(up->rgrp);
        p->rgrp = up->rgrp;
    }

    /* Environment group */
    if(flag & (RFENVG|RFCENVG)) {
        p->egrp = smalloc(sizeof(Egrp));
        p->egrp->ref = 1;
        if(flag & RFENVG)
            envcpy(p->egrp, up->egrp);
    }
    else {
        p->egrp = up->egrp;
        incref(p->egrp);
    }
    p->hang = up->hang;
    p->procmode = up->procmode;

    /* Craft a return frame which will cause the child to pop out of
     * the scheduler in user mode with the return register zero
     */
    forkchild(p, up->dbgreg);

    p->parent = up;
    p->parentpid = up->pid;
    if(flag&RFNOWAIT)
        p->parentpid = 0;
    else {
        lock(&up->exl);
        up->nchild++;
        unlock(&up->exl);
    }
    if((flag&RFNOTEG) == 0)
        p->noteid = up->noteid;

    /* don't penalize the child, it hasn't done FP in a note handler. */
    p->fpstate = up->fpstate & ~FPillegal;
    pid = p->pid;
    memset(p->time, 0, sizeof(p->time));
    p->time[TReal] = MACHP(0)->ticks;

    kstrdup(&p->text, up->text);
    kstrdup(&p->user, up->user);
    /*
     *  since the bss/data segments are now shareable,
     *  any mmu info about this process is now stale
     *  (i.e. has bad properties) and has to be discarded.
     */
    flushmmu();
    p->basepri = up->basepri;
    p->priority = up->basepri;
    p->fixedpri = up->fixedpri;
    p->mp = up->mp;
    wm = up->wired;
    if(wm)
        procwired(p, wm->machno);
    ready(p);
    sched();
    return pid;
}

ulong
l2be(long l)
{
    uchar *cp;

    cp = (uchar*)&l;
    return (cp[0]<<24) | (cp[1]<<16) | (cp[2]<<8) | cp[3];
}

long
sysexec(ulong *arg)
{
    Segment *s, *ts;
    ulong t, d, b;
    int i;
    Chan *tc;
    char **argv, **argp;
    char *a, *charp, *args, *file, *file0;
    char *progarg[sizeof(Exec)/2+1], *elem, progelem[64];
    ulong ssize, spage, nargs, nbytes, n, bssend;
    int indir;
    Exec exec;
    char line[sizeof(Exec)];
    Fgrp *f;
    KImage *img;
    ulong magic, text, entry, data, bss;
    Tos *tos;

    indir = 0;
    elem = nil;
    validaddr(arg[0], 1, 0);
    file0 = validnamedup((char*)arg[0], 1);
    if(waserror()){
        free(file0);
        free(elem);
        nexterror();
    }
    file = file0;
    for(;;){
        tc = namec(file, Aopen, OEXEC, 0);
        if(waserror()){
            cclose(tc);
            nexterror();
        }
        if(!indir)
            kstrdup(&elem, up->genbuf);

        n = devtab[tc->type]->read(tc, &exec, sizeof(Exec), 0);
        if(n < 2)
            error(Ebadexec);
        magic = l2be(exec.magic);
        text = l2be(exec.text);
        entry = l2be(exec.entry);
        if(n==sizeof(Exec) && (magic == AOUT_MAGIC)){
            if(text >= USTKTOP-UTZERO
            || entry < UTZERO+sizeof(Exec)
            || entry >= UTZERO+sizeof(Exec)+text)
                error(Ebadexec);
            break; /* for binary */
        }

        /*
         * Process #! /bin/sh args ...
         */
        memmove(line, &exec, sizeof(Exec));
        if(indir || line[0]!='#' || line[1]!='!')
            error(Ebadexec);
        n = shargs(line, n, progarg);
        if(n == 0)
            error(Ebadexec);
        indir = 1;
        /*
         * First arg becomes complete file name
         */
        progarg[n++] = file;
        progarg[n] = 0;
        validaddr(arg[1], BY2WD, 1);
        arg[1] += BY2WD;
        file = progarg[0];
        if(strlen(elem) >= sizeof progelem)
            error(Ebadexec);
        strcpy(progelem, elem);
        progarg[0] = progelem;
        poperror();
        cclose(tc);
    }

    data = l2be(exec.data);
    bss = l2be(exec.bss);
    t = UTROUND(UTZERO+sizeof(Exec)+text);
    d = (t + data + (BY2PG-1)) & ~(BY2PG-1);
    bssend = t + data + bss;
    b = (bssend + (BY2PG-1)) & ~(BY2PG-1);
    if(t >= KZERO || d >= KZERO || b >= KZERO)
        error(Ebadexec);

    /*
     * Args: pass 1: count
     */
    nbytes = sizeof(Tos);       /* hole for profiling clock at top of stack (and more) */
    nargs = 0;
    if(indir){
        argp = progarg;
        while(*argp){
            a = *argp++;
            nbytes += strlen(a) + 1;
            nargs++;
        }
    }
    evenaddr(arg[1]);
    argp = (char**)arg[1];
    validaddr((ulong)argp, BY2WD, 0);
    while(*argp){
        a = *argp++;
        if(((ulong)argp&(BY2PG-1)) < BY2WD)
            validaddr((ulong)argp, BY2WD, 0);
        validaddr((ulong)a, 1, 0);
        nbytes += ((char*)vmemchr(a, 0, 0x7FFFFFFF) - a) + 1;
        nargs++;
    }
    ssize = BY2WD*(nargs+1) + ((nbytes+(BY2WD-1)) & ~(BY2WD-1));

    /*
     * 8-byte align SP for those (e.g. sparc) that need it.
     * execregs() will subtract another 4 bytes for argc.
     */
    if((ssize+4) & 7)
        ssize += 4;
    spage = (ssize+(BY2PG-1)) >> PGSHIFT;

    /*
     * Build the stack segment, putting it in kernel virtual for the moment
     */
    if(spage > TSTKSIZ)
        error(Enovmem);

    qlock(&up->seglock);
    if(waserror()){
        qunlock(&up->seglock);
        nexterror();
    }
    up->seg[ESEG] = newseg(SG_STACK, TSTKTOP-USTKSIZE, USTKSIZE/BY2PG);

    /*
     * Args: pass 2: assemble; the pages will be faulted in
     */
    tos = (Tos*)(TSTKTOP - sizeof(Tos));
    tos->cyclefreq = m->cyclefreq;
    cycles((uvlong*)&tos->pcycles);
    tos->pcycles = -tos->pcycles;
    tos->kcycles = tos->pcycles;
    tos->clock = 0;
    argv = (char**)(TSTKTOP - ssize);
    charp = (char*)(TSTKTOP - nbytes);
    args = charp;
    if(indir)
        argp = progarg;
    else
        argp = (char**)arg[1];

    for(i=0; i<nargs; i++){
        if(indir && *argp==0) {
            indir = 0;
            argp = (char**)arg[1];
        }
        *argv++ = charp + (USTKTOP-TSTKTOP);
        n = strlen(*argp) + 1;
        memmove(charp, *argp++, n);
        charp += n;
    }
    free(file0);

    free(up->text);
    up->text = elem;
    elem = nil; /* so waserror() won't free elem */
    USED(elem);

    /* copy args; easiest from new process's stack */
    n = charp - args;
    if(n > 128) /* don't waste too much space on huge arg lists */
        n = 128;
    a = up->args;
    up->args = nil;
    free(a);
    up->args = smalloc(n);
    memmove(up->args, args, n);
    if(n>0 && up->args[n-1]!='\0'){
        /* make sure last arg is NUL-terminated */
        /* put NUL at UTF-8 character boundary */
        for(i=n-1; i>0; --i)
            if(fullrune(up->args+i, n-i))
                break;
        up->args[i] = 0;
        n = i+1;
    }
    up->nargs = n;

    /*
     * Committed.
     * Free old memory.
     * Special segments are maintained across exec
     */
    for(i = SSEG; i <= BSEG; i++) {
        putseg(up->seg[i]);
        /* prevent a second free if we have an error */
        up->seg[i] = 0;
    }
    for(i = BSEG+1; i < NSEG; i++) {
        s = up->seg[i];
        if(s != 0 && (s->type&SG_CEXEC)) {
            putseg(s);
            up->seg[i] = 0;
        }
    }

    /*
     * Close on exec
     */
    f = up->fgrp;
    for(i=0; i<=f->maxfd; i++)
        fdclose(i, CCEXEC);

    /* Text.  Shared. Attaches to cache image if possible */
    /* attachimage returns a locked cache image */
    img = attachimage(SG_TEXT|SG_RONLY, tc, UTZERO, (t-UTZERO)>>PGSHIFT);
    ts = img->s;
    up->seg[TSEG] = ts;
    ts->flushme = 1;
    ts->fstart = 0;
    ts->flen = sizeof(Exec)+text;
    unlock(img);

    /* Data. Shared. */
    s = newseg(SG_DATA, t, (d-t)>>PGSHIFT);
    up->seg[DSEG] = s;

    /* Attached by hand */
    incref(img);
    s->image = img;
    s->fstart = ts->fstart+ts->flen;
    s->flen = data;

    /* BSS. Zero fill on demand */
    up->seg[BSEG] = newseg(SG_BSS, d, (b-d)>>PGSHIFT);

    /*
     * Move the stack
     */
    s = up->seg[ESEG];
    up->seg[ESEG] = 0;
    up->seg[SSEG] = s;
    qunlock(&up->seglock);
    poperror(); /* seglock */
    poperror(); /* elem */
    s->base = USTKTOP-USTKSIZE;
    s->top = USTKTOP;
    relocateseg(s, USTKTOP-TSTKTOP);

    /*
     *  '/' processes are higher priority (hack to make /ip more responsive).
     */
    if(devtab[tc->type]->dc == L'/')
        up->basepri = PriRoot;
    up->priority = up->basepri;
    poperror();
    cclose(tc);

    /*
     *  At this point, the mmu contains info about the old address
     *  space and needs to be flushed
     */
    flushmmu();
    qlock(&up->debug);
    up->nnote = 0;
    up->notify = 0;
    up->notified = 0;
    up->privatemem = 0;
    procsetup(up);
    qunlock(&up->debug);
    if(up->hang)
        up->procctl = Proc_stopme;

    return execregs(entry, ssize, nargs);
}

int
shargs(char *s, int n, char **ap)
{
    int i;

    s += 2;
    n -= 2;     /* skip #! */
    for(i=0; s[i]!='\n'; i++)
        if(i == n-1)
            return 0;
    s[i] = 0;
    *ap = 0;
    i = 0;
    for(;;) {
        while(*s==' ' || *s=='\t')
            s++;
        if(*s == 0)
            break;
        i++;
        *ap++ = s;
        *ap = 0;
        while(*s && *s!=' ' && *s!='\t')
            s++;
        if(*s == 0)
            break;
        else
            *s++ = 0;
    }
    return i;
}

int
sysproc_return0(void*)
{
    return 0;
}

long
syssleep(ulong *arg)
{

    int n;

    n = arg[0];
    if(n <= 0) {
        if (up->edf && (up->edf->flags & Admitted))
            edfyield();
        else
            yield();
        return 0;
    }
    if(n < TK2MS(1))
        n = TK2MS(1);
    tsleep(&up->sleep, return0, 0, n);
    return 0;
}

long
sysalarm(ulong *arg)
{
    return procalarm(arg[0]);
}

long
sysexits(ulong *arg)
{
    char *status;
    char *inval = "invalid exit string";
    char buf[ERRMAX];

    status = (char*)arg[0];
    if(status){
        if(waserror())
            status = inval;
        else{
            validaddr((ulong)status, 1, 0);
            if(vmemchr(status, 0, ERRMAX) == 0){
                memmove(buf, status, ERRMAX);
                buf[ERRMAX-1] = 0;
                status = buf;
            }
            poperror();
        }

    }
    pexit(status, 1);
    return 0;       /* not reached */
}

long
sys_wait(ulong *arg)
{
    int pid;
    Waitmsg w;
    OWaitmsg *ow;

    if(arg[0] == 0)
        return pwait(nil);

    validaddr(arg[0], sizeof(OWaitmsg), 1);
    evenaddr(arg[0]);
    pid = pwait(&w);
    if(pid >= 0){
        ow = (OWaitmsg*)arg[0];
        readnum(0, ow->pid, NUMSIZE, w.pid, NUMSIZE);
        readnum(0, ow->time+TUser*NUMSIZE, NUMSIZE, w.time[TUser], NUMSIZE);
        readnum(0, ow->time+TSys*NUMSIZE, NUMSIZE, w.time[TSys], NUMSIZE);
        readnum(0, ow->time+TReal*NUMSIZE, NUMSIZE, w.time[TReal], NUMSIZE);
        strncpy(ow->msg, w.msg, sizeof(ow->msg));
        ow->msg[sizeof(ow->msg)-1] = '\0';
    }
    return pid;
}

long
sysawait(ulong *arg)
{
    int i;
    int pid;
    Waitmsg w;
    ulong n;

    n = arg[1];
    validaddr(arg[0], n, 1);
    pid = pwait(&w);
    if(pid < 0)
        return -1;
    i = snprint((char*)arg[0], n, "%d %lud %lud %lud %q",
        w.pid,
        w.time[TUser], w.time[TSys], w.time[TReal],
        w.msg);

    return i;
}

//@Scheck: this is also defined in libc, so it's supposed to override it? TODO
void
werrstr(char *fmt, ...)
{
    va_list va;

    if(up == nil)
        return;

    va_start(va, fmt);
    vseprint(up->syserrstr, up->syserrstr+ERRMAX, fmt, va);
    va_end(va);
}

static long
generrstr(char *buf, uint nbuf)
{
    char tmp[ERRMAX];

    if(nbuf == 0)
        error(Ebadarg);
    validaddr((ulong)buf, nbuf, 1);
    if(nbuf > sizeof tmp)
        nbuf = sizeof tmp;
    memmove(tmp, buf, nbuf);

    /* make sure it's NUL-terminated */
    tmp[nbuf-1] = '\0';
    memmove(buf, up->syserrstr, nbuf);
    buf[nbuf-1] = '\0';
    memmove(up->syserrstr, tmp, nbuf);
    return 0;
}

long
syserrstr(ulong *arg)
{
    return generrstr((char*)arg[0], arg[1]);
}

/* compatibility for old binaries */
long
sys_errstr(ulong *arg)
{
    return generrstr((char*)arg[0], 64);
}

long
sysnotify(ulong *arg)
{
    if(arg[0] != 0)
        validaddr(arg[0], sizeof(ulong), 0);
    up->notify = (int(*)(void*, char*))(arg[0]);
    return 0;
}

long
sysnoted(ulong *arg)
{
    if(arg[0]!=NRSTR && !up->notified)
        error(Egreg);
    return 0;
}

long
syssegbrk(ulong *arg)
{
    int i;
    ulong addr;
    Segment *s;

    addr = arg[0];
    for(i = 0; i < NSEG; i++) {
        s = up->seg[i];
        if(s == 0 || addr < s->base || addr >= s->top)
            continue;
        switch(s->type&SG_TYPE) {
        case SG_TEXT:
        case SG_DATA:
        case SG_STACK:
            error(Ebadarg);
        default:
            return ibrk(arg[1], i);
        }
    }

    error(Ebadarg);
    return 0;       /* not reached */
}

long
syssegattach(ulong *arg)
{
    return segattach(up, arg[0], (char*)arg[1], arg[2], arg[3]);
}

long
syssegdetach(ulong *arg)
{
    int i;
    ulong addr;
    Segment *s;

    qlock(&up->seglock);
    if(waserror()){
        qunlock(&up->seglock);
        nexterror();
    }

    s = 0;
    addr = arg[0];
    for(i = 0; i < NSEG; i++)
        if(s = up->seg[i]) {
            qlock(&s->lk);
            if((addr >= s->base && addr < s->top) ||
               (s->top == s->base && addr == s->base))
                goto found;
            qunlock(&s->lk);
        }

    error(Ebadarg);

found:
    /*
     * Check we are not detaching the initial stack segment.
     */
    if(s == up->seg[SSEG]){
        qunlock(&s->lk);
        error(Ebadarg);
    }
    up->seg[i] = 0;
    qunlock(&s->lk);
    putseg(s);
    qunlock(&up->seglock);
    poperror();

    /* Ensure we flush any entries from the lost segment */
    flushmmu();
    return 0;
}

long
syssegfree(ulong *arg)
{
    Segment *s;
    ulong from, to;

    from = arg[0];
    s = seg(up, from, 1);
    if(s == nil)
        error(Ebadarg);
    to = (from + arg[1]) & ~(BY2PG-1);
    from = PGROUND(from);

    if(to > s->top) {
        qunlock(&s->lk);
        error(Ebadarg);
    }

    mfreeseg(s, from, (to - from) / BY2PG);
    qunlock(&s->lk);
    flushmmu();

    return 0;
}

/* For binary compatibility */
long
sysbrk_(ulong *arg)
{
    return ibrk(arg[0], BSEG);
}

long
sysrendezvous(ulong *arg)
{
    uintptr tag, val;
    Proc *p, **l;

    tag = arg[0];
    l = &REND(up->rgrp, tag);
    up->rendval = ~(uintptr)0;

    lock(up->rgrp);
    for(p = *l; p; p = p->rendhash) {
        if(p->rendtag == tag) {
            *l = p->rendhash;
            val = p->rendval;
            p->rendval = arg[1];

            while(p->mach != 0)
                ;
            ready(p);
            unlock(up->rgrp);
            return val;
        }
        l = &p->rendhash;
    }

    /* Going to sleep here */
    up->rendtag = tag;
    up->rendval = arg[1];
    up->rendhash = *l;
    *l = up;
    up->state = Rendezvous;
    unlock(up->rgrp);

    sched();

    return up->rendval;
}

/*
 * The implementation of semaphores is complicated by needing
 * to avoid rescheduling in syssemrelease, so that it is safe
 * to call from real-time processes.  This means syssemrelease
 * cannot acquire any qlocks, only spin locks.
 * 
 * Semacquire and semrelease must both manipulate the semaphore
 * wait list.  Lock-free linked lists only exist in theory, not
 * in practice, so the wait list is protected by a spin lock.
 * 
 * The semaphore value *addr is stored in user memory, so it
 * cannot be read or written while holding spin locks.
 * 
 * Thus, we can access the list only when holding the lock, and
 * we can access the semaphore only when not holding the lock.
 * This makes things interesting.  Note that sleep's condition function
 * is called while holding two locks - r and up->rlock - so it cannot
 * access the semaphore value either.
 * 
 * An acquirer announces its intention to try for the semaphore
 * by putting a Sema structure onto the wait list and then
 * setting Sema.waiting.  After one last check of semaphore,
 * the acquirer sleeps until Sema.waiting==0.  A releaser of n
 * must wake up n acquirers who have Sema.waiting set.  It does
 * this by clearing Sema.waiting and then calling wakeup.
 * 
 * There are three interesting races here.  
 
 * The first is that in this particular sleep/wakeup usage, a single
 * wakeup can rouse a process from two consecutive sleeps!  
 * The ordering is:
 * 
 *  (a) set Sema.waiting = 1
 *  (a) call sleep
 *  (b) set Sema.waiting = 0
 *  (a) check Sema.waiting inside sleep, return w/o sleeping
 *  (a) try for semaphore, fail
 *  (a) set Sema.waiting = 1
 *  (a) call sleep
 *  (b) call wakeup(a)
 *  (a) wake up again
 * 
 * This is okay - semacquire will just go around the loop
 * again.  It does mean that at the top of the for(;;) loop in
 * semacquire, phore.waiting might already be set to 1.
 * 
 * The second is that a releaser might wake an acquirer who is
 * interrupted before he can acquire the lock.  Since
 * release(n) issues only n wakeup calls -- only n can be used
 * anyway -- if the interrupted process is not going to use his
 * wakeup call he must pass it on to another acquirer.
 * 
 * The third race is similar to the second but more subtle.  An
 * acquirer sets waiting=1 and then does a final canacquire()
 * before going to sleep.  The opposite order would result in
 * missing wakeups that happen between canacquire and
 * waiting=1.  (In fact, the whole point of Sema.waiting is to
 * avoid missing wakeups between canacquire() and sleep().) But
 * there can be spurious wakeups between a successful
 * canacquire() and the following semdequeue().  This wakeup is
 * not useful to the acquirer, since he has already acquired
 * the semaphore.  Like in the previous case, though, the
 * acquirer must pass the wakeup call along.
 * 
 * This is all rather subtle.  The code below has been verified
 * with the spin model /sys/src/9/port/semaphore.p.  The
 * original code anticipated the second race but not the first
 * or third, which were caught only with spin.  The first race
 * is mentioned in /sys/doc/sleep.ps, but I'd forgotten about it.
 * It was lucky that my abstract model of sleep/wakeup still managed
 * to preserve that behavior.
 *
 * I remain slightly concerned about memory coherence
 * outside of locks.  The spin model does not take 
 * queued processor writes into account so we have to
 * think hard.  The only variables accessed outside locks
 * are the semaphore value itself and the boolean flag
 * Sema.waiting.  The value is only accessed with cmpswap,
 * whose job description includes doing the right thing as
 * far as memory coherence across processors.  That leaves
 * Sema.waiting.  To handle it, we call coherence() before each
 * read and after each write.       - rsc
 */

/* Add semaphore p with addr a to list in seg. */
static void
semqueue(Segment *s, long *a, Sema *p)
{
    memset(p, 0, sizeof *p);
    p->addr = a;
    lock(&s->sema); /* uses s->sema.Rendez.Lock, but no one else is */
    p->next = &s->sema;
    p->prev = s->sema.prev;
    p->next->prev = p;
    p->prev->next = p;
    unlock(&s->sema);
}

/* Remove semaphore p from list in seg. */
static void
semdequeue(Segment *s, Sema *p)
{
    lock(&s->sema);
    p->next->prev = p->prev;
    p->prev->next = p->next;
    unlock(&s->sema);
}

/* Wake up n waiters with addr a on list in seg. */
static void
semwakeup(Segment *s, long *a, long n)
{
    Sema *p;
    
    lock(&s->sema);
    for(p=s->sema.next; p!=&s->sema && n>0; p=p->next){
        if(p->addr == a && p->waiting){
            p->waiting = 0;
            coherence();
            wakeup(p);
            n--;
        }
    }
    unlock(&s->sema);
}

/* Add delta to semaphore and wake up waiters as appropriate. */
static long
semrelease(Segment *s, long *addr, long delta)
{
    long value;

    do
        value = *addr;
    while(!cmpswap(addr, value, value+delta));
    semwakeup(s, addr, delta);
    return value+delta;
}

/* Try to acquire semaphore using compare-and-swap */
static int
canacquire(long *addr)
{
    long value;
    
    while((value=*addr) > 0)
        if(cmpswap(addr, value, value-1))
            return 1;
    return 0;
}       

/* Should we wake up? */
static int
semawoke(void *p)
{
    coherence();
    return !((Sema*)p)->waiting;
}

/* Acquire semaphore (subtract 1). */
static int
semacquire(Segment *s, long *addr, int block)
{
    int acquired;
    Sema phore;

    if(canacquire(addr))
        return 1;
    if(!block)
        return 0;

    acquired = 0;
    semqueue(s, addr, &phore);
    for(;;){
        phore.waiting = 1;
        coherence();
        if(canacquire(addr)){
            acquired = 1;
            break;
        }
        if(waserror())
            break;
        sleep(&phore, semawoke, &phore);
        poperror();
    }
    semdequeue(s, &phore);
    coherence();    /* not strictly necessary due to lock in semdequeue */
    if(!phore.waiting)
        semwakeup(s, addr, 1);
    if(!acquired)
        nexterror();
    return 1;
}

/* Acquire semaphore or time-out */
static int
tsemacquire(Segment *s, long *addr, ulong ms)
{
    int acquired, timedout;
    ulong t, elms;
    Sema phore;

    if(canacquire(addr))
        return 1;
    if(ms == 0)
        return 0;
    acquired = timedout = 0;
    semqueue(s, addr, &phore);
    for(;;){
        phore.waiting = 1;
        coherence();
        if(canacquire(addr)){
            acquired = 1;
            break;
        }
        if(waserror())
            break;
        t = m->ticks;
        tsleep(&phore, semawoke, &phore, ms);
        elms = TK2MS(m->ticks - t);
        poperror();
        if(elms >= ms){
            timedout = 1;
            break;
        }
        ms -= elms;
    }
    semdequeue(s, &phore);
    coherence();    /* not strictly necessary due to lock in semdequeue */
    if(!phore.waiting)
        semwakeup(s, addr, 1);
    if(timedout)
        return 0;
    if(!acquired)
        nexterror();
    return 1;
}

long
syssemacquire(ulong *arg)
{
    int block;
    long *addr;
    Segment *s;

    validaddr(arg[0], sizeof(long), 1);
    evenaddr(arg[0]);
    addr = (long*)arg[0];
    block = arg[1];
    
    if((s = seg(up, (ulong)addr, 0)) == nil)
        error(Ebadarg);
    if(*addr < 0)
        error(Ebadarg);
    return semacquire(s, addr, block);
}

long
systsemacquire(ulong *arg)
{
    long *addr;
    ulong ms;
    Segment *s;

    validaddr(arg[0], sizeof(long), 1);
    evenaddr(arg[0]);
    addr = (long*)arg[0];
    ms = arg[1];

    if((s = seg(up, (ulong)addr, 0)) == nil)
        error(Ebadarg);
    if(*addr < 0)
        error(Ebadarg);
    return tsemacquire(s, addr, ms);
}

long
syssemrelease(ulong *arg)
{
    long *addr, delta;
    Segment *s;

    validaddr(arg[0], sizeof(long), 1);
    evenaddr(arg[0]);
    addr = (long*)arg[0];
    delta = arg[1];

    if((s = seg(up, (ulong)addr, 0)) == nil)
        error(Ebadarg);
    /* delta == 0 is a no-op, not a release */
    if(delta < 0 || *addr < 0)
        error(Ebadarg);
    return semrelease(s, addr, delta);
}
@


\subsection*{[[processes/tod.c]]}

<<tod.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

// TOD: Time Of Day.

uvlong      mk64fract(uvlong, uvlong);

/*
 * Compute nanosecond epoch time from the fastest ticking clock
 * on the system.  Converting the time to nanoseconds requires
 * the following formula
 *
 *  t = (((1000000000<<31)/f)*ticks)>>31
 *
 *  where
 *
 *  'f'     is the clock frequency
 *  'ticks'     are clock ticks
 *
 *  to avoid too much calculation in todget(), we calculate
 *
 *  mult = (1000000000<<32)/f
 *
 *  each time f is set.  f is normally set by a user level
 *  program writing to /dev/fastclock.  mul64fract will then
 *  take that fractional multiplier and a 64 bit integer and
 *  return the resulting integer product.
 *
 *  We assume that the cpu's of a multiprocessor are synchronized.
 *  This assumption needs to be questioned with each new architecture.
 */

/* frequency of the tod clock */
#define TODFREQ     1000000000ULL
#define MicroFREQ   1000000ULL

struct TOD {
    int init;       /* true if initialized */
    ulong   cnt;
    Lock;
    uvlong  multiplier; /* ns = off + (multiplier*ticks)>>31 */
    uvlong  divider;    /* ticks = (divider*(ns-off))>>31 */
    uvlong  umultiplier;    /* Âµs = (Âµmultiplier*ticks)>>31 */
    uvlong  udivider;   /* ticks = (Âµdivider*Âµs)>>31 */
    vlong   hz;     /* frequency of fast clock */
    vlong   last;       /* last reading of fast clock */
    vlong   off;        /* offset from epoch to last */
    vlong   lasttime;   /* last return value from todget */
    vlong   delta;  /* add 'delta' each slow clock tick from sstart to send */
    ulong   sstart;     /* ... */
    ulong   send;       /* ... */
};

struct TOD tod;

static void todfix(void);

void
todinit(void)
{
    if(tod.init)
        return;
    ilock(&tod);
    tod.init = 1;           /* prevent reentry via fastticks */
    tod.last = fastticks((uvlong *)&tod.hz);
    iunlock(&tod);
    todsetfreq(tod.hz);
    addclock0link(todfix, 100);
}

/*
 *  calculate multiplier
 */
void
todsetfreq(vlong f)
{
    if (f <= 0)
        panic("todsetfreq: freq %lld <= 0", f);
    ilock(&tod);
    tod.hz = f;

    /* calculate multiplier for time conversion */
    tod.multiplier = mk64fract(TODFREQ, f);
    tod.divider = mk64fract(f, TODFREQ) + 1;
    tod.umultiplier = mk64fract(MicroFREQ, f);
    tod.udivider = mk64fract(f, MicroFREQ) + 1;
    iunlock(&tod);
}

/*
 *  Set the time of day struct
 */
void
todset(vlong t, vlong delta, int n)
{
    if(!tod.init)
        todinit();

    ilock(&tod);
    if(t >= 0){
        tod.off = t;
        tod.last = fastticks(nil);
        tod.lasttime = 0;
        tod.delta = 0;
        tod.sstart = tod.send;
    } else {
        if(n <= 0)
            n = 1;
        n *= HZ;
        if(delta < 0 && n > -delta)
            n = -delta;
        if(delta > 0 && n > delta)
            n = delta;
        if (n == 0) {
            iprint("todset: n == 0, delta == %lld\n", delta);
            delta = 0;
        } else
            delta /= n;
        tod.sstart = MACHP(0)->ticks;
        tod.send = tod.sstart + n;
        tod.delta = delta;
    }
    iunlock(&tod);
}

/*
 *  get time of day
 */
vlong
todget(vlong *ticksp)
{
    uvlong x;
    vlong ticks, diff;
    ulong t;

    if(!tod.init)
        todinit();

    /*
     * we don't want time to pass twixt the measuring of fastticks
     * and grabbing tod.last.  Also none of the vlongs are atomic so
     * we have to look at them inside the lock.
     */
    ilock(&tod);
    tod.cnt++;
    ticks = fastticks(nil);

    /* add in correction */
    if(tod.sstart != tod.send){
        t = MACHP(0)->ticks;
        if(t >= tod.send)
            t = tod.send;
        tod.off = tod.off + tod.delta*(t - tod.sstart);
        tod.sstart = t;
    }

    /* convert to epoch */
    diff = ticks - tod.last;
    if(diff < 0)
        diff = 0;
    mul64fract(&x, diff, tod.multiplier);
    x += tod.off;

    /* time can't go backwards */
    if(x < tod.lasttime)
        x = tod.lasttime;
    else
        tod.lasttime = x;

    iunlock(&tod);

    if(ticksp != nil)
        *ticksp = ticks;

    return x;
}

//unused
/*
 *  convert time of day to ticks
 */
//uvlong
//tod2fastticks(vlong ns)
//{
//  uvlong x;
//
//  ilock(&tod);
//  mul64fract(&x, ns-tod.off, tod.divider);
//  x += tod.last;
//  iunlock(&tod);
//  return x;
//}

/*
 *  called regularly to avoid calculation overflows
 */
static void
todfix(void)
{
    vlong ticks, diff;
    uvlong x;

    ticks = fastticks(nil);

    diff = ticks - tod.last;
    if(diff > tod.hz){
        ilock(&tod);

        /* convert to epoch */
        mul64fract(&x, diff, tod.multiplier);
if(x > 30000000000ULL) iprint("todfix %llud\n", x);
        x += tod.off;

        /* protect against overflows */
        tod.last = ticks;
        tod.off = x;

        iunlock(&tod);
    }
}

long
seconds(void)
{
    return (vlong)todget(nil) / TODFREQ;
}

uvlong
fastticks2us(uvlong ticks)
{
    uvlong res;

    if(!tod.init)
        todinit();
    mul64fract(&res, ticks, tod.umultiplier);
    return res;
}

//unused
//uvlong
//us2fastticks(uvlong us)
//{
//  uvlong res;
//
//  if(!tod.init)
//      todinit();
//  mul64fract(&res, us, tod.udivider);
//  return res;
//}

//unused
///*
// *  convert milliseconds to fast ticks
// */
//uvlong
//ms2fastticks(ulong ms)
//{
//  if(!tod.init)
//      todinit();
//  return (tod.hz*ms)/1000ULL;
//}

/*
 *  convert nanoseconds to fast ticks
 */
uvlong
ns2fastticks(uvlong ns)
{
    uvlong res;

    if(!tod.init)
        todinit();
    mul64fract(&res, ns, tod.divider);
    return res;
}

//unused
///*
// *  convert fast ticks to ns
// */
//uvlong
//fastticks2ns(uvlong ticks)
//{
//  uvlong res;
//
//  if(!tod.init)
//      todinit();
//  mul64fract(&res, ticks, tod.multiplier);
//  return res;
//}

/*
 * Make a 64 bit fixed point number that has a decimal point
 * to the left of the low order 32 bits.  This is used with
 * mul64fract for converting twixt nanoseconds and fastticks.
 *
 *  multiplier = (to<<32)/from
 */
uvlong
mk64fract(uvlong to, uvlong from)
{
/*
    int shift;

    if(to == 0ULL)
        return 0ULL;

    shift = 0;
    while(shift < 32 && to < (1ULL<<(32+24))){
        to <<= 8;
        shift += 8;
    }
    while(shift < 32 && to < (1ULL<<(32+31))){
        to <<= 1;
        shift += 1;
    }

    return (to/from)<<(32-shift);
 */
    return (to<<32) / from;
}
@


\section{[[security/]]}

\subsection*{[[security/auth.c]]}

<<auth.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    <authsrv.h>

//char  *eve; now in core/
//int iseve(void) { } now in core/

char    hostdomain[DOMLEN];

long
sysfversion(ulong *arg)
{
    char *vers;
    uint arglen, m, msize;
    Chan *c;

    msize = arg[1];
    vers = (char*)arg[2];
    arglen = arg[3];
    validaddr(arg[2], arglen, 1);
    /* check there's a NUL in the version string */
    if(arglen==0 || memchr(vers, 0, arglen)==0)
        error(Ebadarg);
    c = fdtochan(arg[0], ORDWR, 0, 1);
    if(waserror()){
        cclose(c);
        nexterror();
    }

    m = mntversion(c, vers, msize, arglen);

    cclose(c);
    poperror();
    return m;
}

long
sys_fsession(ulong *arg)
{
    /* deprecated; backwards compatibility only */

    if(arg[2] == 0)
        error(Ebadarg);
    validaddr(arg[1], arg[2], 1);
    ((uchar*)arg[1])[0] = '\0';
    return 0;
}

long
sysfauth(ulong *arg)
{
    Chan *c, *ac;
    char *aname;
    int fd;

    validaddr(arg[1], 1, 0);
    aname = validnamedup((char*)arg[1], 1);
    if(waserror()){
        free(aname);
        nexterror();
    }
    c = fdtochan(arg[0], ORDWR, 0, 1);
    if(waserror()){
        cclose(c);
        nexterror();
    }

    ac = mntauth(c, aname);
    /* at this point ac is responsible for keeping c alive */
    poperror(); /* c */
    cclose(c);
    poperror(); /* aname */
    free(aname);

    if(waserror()){
        cclose(ac);
        nexterror();
    }

    fd = newfd(ac);
    if(fd < 0)
        error(Enofd);
    poperror(); /* ac */

    /* always mark it close on exec */
    ac->flag |= CCEXEC;

    return fd;
}

/*
 *  called by devcons() for user device
 *
 *  anyone can become none
 */
long
userwrite(char *a, int n)
{
    if(n!=4 || strncmp(a, "none", 4)!=0)
        error(Eperm);
    kstrdup(&up->user, "none");
    up->basepri = PriNormal;
    return n;
}

/*
 *  called by devcons() for host owner/domain
 *
 *  writing hostowner also sets user
 */
long
hostownerwrite(char *a, int n)
{
    char buf[128];

    if(!iseve())
        error(Eperm);
    if(n <= 0 || n >= sizeof buf)
        error(Ebadarg);
    memmove(buf, a, n);
    buf[n] = 0;

    renameuser(eve, buf);
    kstrdup(&eve, buf);
    kstrdup(&up->user, buf);
    up->basepri = PriNormal;
    return n;
}

long
hostdomainwrite(char *a, int n)
{
    char buf[DOMLEN];

    if(!iseve())
        error(Eperm);
    if(n >= DOMLEN)
        error(Ebadarg);
    memset(buf, 0, DOMLEN);
    strncpy(buf, a, n);
    if(buf[0] == 0)
        error(Ebadarg);
    memmove(hostdomain, buf, DOMLEN);
    return n;
}
@


\subsection*{[[security/portfns_security.h]]}

<<portfns_security.h>>=

// auth.c
long    userwrite(char*, int);
long    hostdomainwrite(char*, int);
long    hostownerwrite(char*, int);

// and some sysxxx functions
@


\section{[[syscalls/]]}

\subsection*{[[syscalls/386/plan9l.s]]}

<<plan9l.s>>=
#include "mem.h"

/*
 * This must match io.h.
 */
#define VectorSYSCALL   0x40

/*
 *  Used to get to the first process:
 *      set up an interrupt return frame and IRET to user level.
 */
TEXT touser(SB), $0
        PUSHL   $(UDSEL)                        /* old ss */
        MOVL    sp+0(FP), AX                    /* old sp */
        PUSHL   AX
        MOVL    $0x200, AX                      /* interrupt enable flag */
        PUSHL   AX                              /* old flags */
        PUSHL   $(UESEL)                        /* old cs */
        PUSHL   $(UTZERO+32)                    /* old pc */
        MOVL    $(UDSEL), AX
        MOVW    AX, DS
        MOVW    AX, ES
        MOVW    AX, GS
        MOVW    AX, FS
        IRETL

/*
 * This is merely _strayintr from l.s optimised to vector
 * to syscall() without going through trap().
 */
TEXT _syscallintr(SB), $0
        PUSHL   $VectorSYSCALL                  /* trap type */

        PUSHL   DS
        PUSHL   ES
        PUSHL   FS
        PUSHL   GS
        PUSHAL
        MOVL    $(KDSEL), AX
        MOVW    AX, DS
        MOVW    AX, ES
        PUSHL   SP
        CALL    syscall(SB)

        POPL    AX
        POPAL
        POPL    GS
        POPL    FS
        POPL    ES
        POPL    DS
        ADDL    $8, SP                          /* pop error code and trap type */
        IRETL
@


\subsection*{[[syscalls/syscallfmt.c]]}

<<syscallfmt.c>>=
/*
 * Print functions for system call tracing.
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "/sys/src/libc/9syscall/sys.h"
extern  char* sysctab[];
extern  int nsyscall;

// WE ARE OVERRUNNING SOMEHOW
static void
fmtrwdata(Fmt* f, char* a, int n, char* suffix)
{
    int i;
    char *t;

    if(a == nil){
        fmtprint(f, "0x0%s", suffix);
        return;
    }
    validaddr((ulong)a, n, 0);
    t = smalloc(n+1);
    for(i = 0; i < n; i++)
        if(a[i] > 0x20 && a[i] < 0x7f)  /* printable ascii? */
            t[i] = a[i];
        else
            t[i] = '.';

    fmtprint(f, " %#p/\"%s\"%s", a, t, suffix);
    free(t);
}

static void
fmtuserstring(Fmt* f, char* a, char* suffix)
{
    int n;
    char *t;

    if(a == nil){
        fmtprint(f, "0/\"\"%s", suffix);
        return;
    }
    validaddr((ulong)a, 1, 0);
    n = ((char*)vmemchr(a, 0, 0x7fffffff) - a) + 1;
    t = smalloc(n+1);
    memmove(t, a, n);
    t[n] = 0;
    fmtprint(f, "%#p/\"%s\"%s", a, t, suffix);
    free(t);
}

void
syscallfmt(int syscallno, ulong pc, va_list list)
{
    long l;
    Fmt fmt;
    void *v;
    vlong vl;
    uintptr p;
    int i[2], len;
    char *a, **argv;

    fmtstrinit(&fmt);
    fmtprint(&fmt, "%uld %s ", up->pid, up->text);

    if(syscallno > nsyscall)
        fmtprint(&fmt, " %d ", syscallno);
    else
        fmtprint(&fmt, "%s ", sysctab[syscallno]?
            sysctab[syscallno]: "huh?");

    fmtprint(&fmt, "%ulx ", pc);
    if(up->syscalltrace != nil)
        free(up->syscalltrace);

    switch(syscallno){
    case SYSR1:
        p = va_arg(list, uintptr);
        fmtprint(&fmt, "%#p", p);
        break;
    case _ERRSTR:                   /* deprecated */
    case CHDIR:
    case EXITS:
    case REMOVE:
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, "");
        break;
    case BIND:
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%#ux",  i[0]);
        break;
    case CLOSE:
    case NOTED:
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%d", i[0]);
        break;
    case DUP:
        i[0] = va_arg(list, int);
        i[1] = va_arg(list, int);
        fmtprint(&fmt, "%d %d", i[0], i[1]);
        break;
    case ALARM:
        l = va_arg(list, unsigned long);
        fmtprint(&fmt, "%#lud ", l);
        break;
    case EXEC:
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, "");
        argv = va_arg(list, char**);
        evenaddr(PTR2UINT(argv));
        for(;;){
            validaddr((ulong)argv, sizeof(char**), 0);
            a = *(char **)argv;
            if(a == nil)
                break;
            fmtprint(&fmt, " ");
            fmtuserstring(&fmt, a, "");
            argv++;
        }
        break;
    case _FSESSION:                 /* deprecated */
    case _FSTAT:                    /* deprecated */
    case _FWSTAT:                   /* obsolete */
        i[0] = va_arg(list, int);
        a = va_arg(list, char*);
        fmtprint(&fmt, "%d %#p", i[0], a);
        break;
    case FAUTH:
        i[0] = va_arg(list, int);
        a = va_arg(list, char*);
        fmtprint(&fmt, "%d", i[0]);
        fmtuserstring(&fmt, a, "");
        break;
    case SEGBRK:
    case RENDEZVOUS:
        v = va_arg(list, void*);
        fmtprint(&fmt, "%#p ", v);
        v = va_arg(list, void*);
        fmtprint(&fmt, "%#p", v);
        break;
    case _MOUNT:                    /* deprecated */
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%d ", i[0]);
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%#ux ", i[0]);
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, "");
        break;
    case OPEN:
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%#ux", i[0]);
        break;
    case OSEEK:                 /* deprecated */
        i[0] = va_arg(list, int);
        l = va_arg(list, long);
        i[1] = va_arg(list, int);
        fmtprint(&fmt, "%d %ld %d", i[0], l, i[1]);
        break;
    case SLEEP:
        l = va_arg(list, long);
        fmtprint(&fmt, "%ld", l);
        break;
    case _STAT:                 /* obsolete */
    case _WSTAT:                    /* obsolete */
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        a = va_arg(list, char*);
        fmtprint(&fmt, "%#p", a);
        break;
    case RFORK:
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%#ux", i[0]);
        break;
    case PIPE:
    case BRK_:
        v = va_arg(list, int*);
        fmtprint(&fmt, "%#p", v);
        break;
    case CREATE:
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        i[0] = va_arg(list, int);
        i[1] = va_arg(list, int);
        fmtprint(&fmt, "%#ux %#ux", i[0], i[1]);
        break;
    case FD2PATH:
    case FSTAT:
    case FWSTAT:
        i[0] = va_arg(list, int);
        a = va_arg(list, char*);
        l = va_arg(list, unsigned long);
        fmtprint(&fmt, "%d %#p %lud", i[0], a, l);
        break;
    case NOTIFY:
    case SEGDETACH:
    case _WAIT:                 /* deprecated */
        v = va_arg(list, void*);
        fmtprint(&fmt, "%#p", v);
        break;
    case SEGATTACH:
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%d ", i[0]);
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        /*FALLTHROUGH*/
    case SEGFREE:
    case SEGFLUSH:
        v = va_arg(list, void*);
        l = va_arg(list, unsigned long);
        fmtprint(&fmt, "%#p %lud", v, l);
        break;
    case UNMOUNT:
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, "");
        break;
    case SEMACQUIRE:
    case SEMRELEASE:
        v = va_arg(list, int*);
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%#p %d", v, i[0]);
        break;
    case TSEMACQUIRE:
        v = va_arg(list, long*);
        l = va_arg(list, ulong);
        fmtprint(&fmt, "%#p %ld", v, l);
        break;
    case SEEK:
        v = va_arg(list, vlong*);
        i[0] = va_arg(list, int);
        vl = va_arg(list, vlong);
        i[1] = va_arg(list, int);
        fmtprint(&fmt, "%#p %d %#llux %d", v, i[0], vl, i[1]);
        break;
    case FVERSION:
        i[0] = va_arg(list, int);
        i[1] = va_arg(list, int);
        fmtprint(&fmt, "%d %d ", i[0], i[1]);
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        l = va_arg(list, unsigned long);
        fmtprint(&fmt, "%lud", l);
        break;
    case WSTAT:
    case STAT:
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        /*FALLTHROUGH*/
    case ERRSTR:
    case AWAIT:
        a = va_arg(list, char*);
        l = va_arg(list, unsigned long);
        fmtprint(&fmt, "%#p %lud", a, l);
        break;
    case MOUNT:
        i[0] = va_arg(list, int);
        i[1] = va_arg(list, int);
        fmtprint(&fmt, "%d %d ", i[0], i[1]);
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, " ");
        i[0] = va_arg(list, int);
        fmtprint(&fmt, "%#ux ", i[0]);
        a = va_arg(list, char*);
        fmtuserstring(&fmt, a, "");
        break;
    case _READ:                 /* deprecated */
    case PREAD:
        i[0] = va_arg(list, int);
        v = va_arg(list, void*);
        l = va_arg(list, long);
        fmtprint(&fmt, "%d %#p %ld", i[0], v, l);
        if(syscallno == PREAD){
            vl = va_arg(list, vlong);
            fmtprint(&fmt, " %lld", vl);
        }
        break;
    case _WRITE:                    /* deprecated */
    case PWRITE:
        i[0] = va_arg(list, int);
        v = va_arg(list, void*);
        l = va_arg(list, long);
        fmtprint(&fmt, "%d ", i[0]);
        len = MIN(l, 64);
        fmtrwdata(&fmt, v, len, " ");
        fmtprint(&fmt, "%ld", l);
        if(syscallno == PWRITE){
            vl = va_arg(list, vlong);
            fmtprint(&fmt, " %lld", vl);
        }
        break;
    }

    up->syscalltrace = fmtstrflush(&fmt);
}

void
sysretfmt(int syscallno, va_list list, long ret, uvlong start, uvlong stop)
{
    long l;
    void* v;
    Fmt fmt;
    vlong vl;
    int i, len;
    char *a, *errstr;

    fmtstrinit(&fmt);

    if(up->syscalltrace)
        free(up->syscalltrace);

    errstr = "\"\"";
    switch(syscallno){
    default:
    case ALARM:
    case _WRITE:
    case PWRITE:
        if(ret == -1)
            errstr = up->syserrstr;
        fmtprint(&fmt, " = %ld", ret);
        break;
    case EXEC:
    case SEGBRK:
    case SEGATTACH:
    case RENDEZVOUS:
        if((void *)ret == (void*)-1)
            errstr = up->syserrstr;
        fmtprint(&fmt, " = %#p", (void *)ret);
        break;
    case AWAIT:
        a = va_arg(list, char*);
        l = va_arg(list, unsigned long);
        if(ret > 0){
            fmtuserstring(&fmt, a, " ");
            fmtprint(&fmt, "%lud = %ld", l, ret);
        }
        else{
            fmtprint(&fmt, "%#p/\"\" %lud = %ld", a, l, ret);
            errstr = up->syserrstr;
        }
        break;
    case _ERRSTR:
    case ERRSTR:
        a = va_arg(list, char*);
        if(syscallno == _ERRSTR)
            l = 64;
        else
            l = va_arg(list, unsigned long);
        if(ret > 0){
            fmtuserstring(&fmt, a, " ");
            fmtprint(&fmt, "%lud = %ld", l, ret);
        }
        else{
            fmtprint(&fmt, "\"\" %lud = %ld", l, ret);
            errstr = up->syserrstr;
        }
        break;
    case FD2PATH:
        i = va_arg(list, int);
        USED(i);
        a = va_arg(list, char*);
        l = va_arg(list, unsigned long);
        if(ret > 0){
            fmtuserstring(&fmt, a, " ");
            fmtprint(&fmt, "%lud = %ld", l, ret);
        }
        else{
            fmtprint(&fmt, "\"\" %lud = %ld", l, ret);
            errstr = up->syserrstr;
        }
        break;
    case _READ:
    case PREAD:
        i = va_arg(list, int);
        USED(i);
        v = va_arg(list, void*);
        l = va_arg(list, long);
        if(ret > 0){
            len = MIN(ret, 64);
            fmtrwdata(&fmt, v, len, "");
        }
        else{
            fmtprint(&fmt, "/\"\"");
            errstr = up->syserrstr;
        }
        fmtprint(&fmt, " %ld", l);
        if(syscallno == PREAD){
            vl = va_arg(list, vlong);
            fmtprint(&fmt, " %lld", vl);
        }
        fmtprint(&fmt, " = %ld", ret);
        break;
    }
    fmtprint(&fmt, " %s %#llud %#llud\n", errstr, start, stop);
    up->syscalltrace = fmtstrflush(&fmt);
}
@


\subsection*{[[syscalls/systab.c]]}

<<systab.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include "../port/systab.h"

extern Syscall sysr1;
extern Syscall sys_errstr;
extern Syscall sysbind;
extern Syscall syschdir;
extern Syscall sysclose;
extern Syscall sysdup;
extern Syscall sysalarm;
extern Syscall sysexec;
extern Syscall sysexits;
extern Syscall sys_fsession;
extern Syscall sysfauth;
extern Syscall sys_fstat;
extern Syscall syssegbrk;
extern Syscall sys_mount;
extern Syscall sysopen;
extern Syscall sys_read;
extern Syscall sysoseek;
extern Syscall syssleep;
extern Syscall sys_stat;
extern Syscall sysrfork;
extern Syscall sys_write;
extern Syscall syspipe;
extern Syscall syscreate;
extern Syscall sysfd2path;
extern Syscall sysbrk_;
extern Syscall sysremove;
extern Syscall sys_wstat;
extern Syscall sys_fwstat;
extern Syscall sysnotify;
extern Syscall sysnoted;
extern Syscall syssegattach;
extern Syscall syssegdetach;
extern Syscall syssegfree;
extern Syscall syssegflush;
extern Syscall sysrendezvous;
extern Syscall sysunmount;
extern Syscall sys_wait;
extern Syscall syssemacquire;
extern Syscall syssemrelease;
extern Syscall sysseek;
extern Syscall sysfversion;
extern Syscall syserrstr;
extern Syscall sysstat;
extern Syscall sysfstat;
extern Syscall syswstat;
extern Syscall sysfwstat;
extern Syscall sysmount;
extern Syscall sysawait;
extern Syscall syspread;
extern Syscall syspwrite;
extern Syscall systsemacquire;
//@Scheck: TODO? dead?
extern Syscall sysdeath;

//coupling: debuggers/acid/conf/syscall
//coupling: debuggers/acid/conf/truss
//TODO: remove obsolete calls, all _XXX, and maybe even reorder?
// also use an enum instead?
Syscall *systab[] = {
    [SYSR1]     sysr1,
    [_ERRSTR]   sys_errstr,
    [BIND]      sysbind,
    [CHDIR]     syschdir,
    [CLOSE]     sysclose,
    [DUP]       sysdup,
    [ALARM]     sysalarm,
    [EXEC]      sysexec,
    [EXITS]     sysexits,
    [_FSESSION] sys_fsession,
    [FAUTH]     sysfauth,
    [_FSTAT]    sys_fstat,
    [SEGBRK]    syssegbrk,
    [_MOUNT]    sys_mount,
    [OPEN]      sysopen,
    [_READ]     sys_read,
    [OSEEK]     sysoseek,
    [SLEEP]     syssleep,
    [_STAT]     sys_stat,
    [RFORK]     sysrfork,
    [_WRITE]    sys_write,
    [PIPE]      syspipe,
    [CREATE]    syscreate,
    [FD2PATH]   sysfd2path,
    [BRK_]      sysbrk_,
    [REMOVE]    sysremove,
    [_WSTAT]    sys_wstat,
    [_FWSTAT]   sys_fwstat,
    [NOTIFY]    sysnotify,
    [NOTED]     sysnoted,
    [SEGATTACH] syssegattach,
    [SEGDETACH] syssegdetach,
    [SEGFREE]   syssegfree,
    [SEGFLUSH]  syssegflush,
    [RENDEZVOUS]    sysrendezvous,
    [UNMOUNT]   sysunmount,
    [_WAIT]     sys_wait,
    [SEMACQUIRE]    syssemacquire,
    [SEMRELEASE]    syssemrelease,
    [SEEK]      sysseek,
    [FVERSION]  sysfversion,
    [ERRSTR]    syserrstr,
    [STAT]      sysstat,
    [FSTAT]     sysfstat,
    [WSTAT]     syswstat,
    [FWSTAT]    sysfwstat,
    [MOUNT]     sysmount,
    [AWAIT]     sysawait,
    [PREAD]     syspread,
    [PWRITE]    syspwrite,
    [TSEMACQUIRE]   systsemacquire,
};
int nsyscall = nelem(systab);

char *sysctab[] = {
    [SYSR1]     "Running",
    [_ERRSTR]   "_errstr",
    [BIND]      "Bind",
    [CHDIR]     "Chdir",
    [CLOSE]     "Close",
    [DUP]       "Dup",
    [ALARM]     "Alarm",
    [EXEC]      "Exec",
    [EXITS]     "Exits",
    [_FSESSION] "_fsession",
    [FAUTH]     "Fauth",
    [_FSTAT]    "_fstat",
    [SEGBRK]    "Segbrk",
    [_MOUNT]    "_mount",
    [OPEN]      "Open",
    [_READ]     "_read",
    [OSEEK]     "Oseek",
    [SLEEP]     "Sleep",
    [_STAT]     "_stat",
    [RFORK]     "Rfork",
    [_WRITE]    "_write",
    [PIPE]      "Pipe",
    [CREATE]    "Create",
    [FD2PATH]   "Fd2path",
    [BRK_]      "Brk",
    [REMOVE]    "Remove",
    [_WSTAT]    "_wstat",
    [_FWSTAT]   "_fwstat",
    [NOTIFY]    "Notify",
    [NOTED]     "Noted",
    [SEGATTACH] "Segattach",
    [SEGDETACH] "Segdetach",
    [SEGFREE]   "Segfree",
    [SEGFLUSH]  "Segflush",
    [RENDEZVOUS]    "Rendez",
    [UNMOUNT]   "Unmount",
    [_WAIT]     "_wait",
    [SEMACQUIRE]    "Semacquire",
    [SEMRELEASE]    "Semrelease",
    [SEEK]      "Seek",
    [FVERSION]  "Fversion",
    [ERRSTR]    "Errstr",
    [STAT]      "Stat",
    [FSTAT]     "Fstat",
    [WSTAT]     "Wstat",
    [FWSTAT]    "Fwstat",
    [MOUNT]     "Mount",
    [AWAIT]     "Await",
    [PREAD]     "Pread",
    [PWRITE]    "Pwrite",
    [TSEMACQUIRE]   "Tsemacquire",
};
@


\subsection*{[[syscalls/systab.h]]}

<<systab.h>>=
// used by systab.c but also by trap.c for certain codes
#include "/sys/src/libc/9syscall/sys.h"

typedef long Syscall(ulong*);

extern Syscall *systab[];
extern int nsyscall;
extern char *sysctab[];
@


