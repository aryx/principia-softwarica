\documentclass{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
% see also other newif in Macros.tex
\finaltrue\verbosefalse

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things :)
% - introduced syssema.c (found while going through Kernel_extra.tex.nw)
% - removed deadcode (e.g. field Proc.qlock, semalock)
% - moved code in init/user such as preboot vs boot vs init
% - introduced notion of IPC
% - TODO better grouping of things in devcons.c, present together the Qxxx

%thx to codemap/codegraph:
% - see pad.txt#reorganization section

%history LP-ization:
% - skeleton; a not too bad TOC
% - put all content of files in the Extra section, via syncweb -lpize
% - split the files in chunks (for type, helpers, ...), using
%   my emacs macro, and prefixing the chunk with special names:
%    * function, global, struct, enum,
%    * method (for Dev), class??(for xxxdevtab?),
%    * syscall, interrupt callback, clock callback, kernel process, hook
%    * xxx decl, xxx.c forward decl, xxx.c debugging macro, xxx.c Exxx errors,
%    * [[xxx]] other fields, [[xxx]] extra fields, 
%   
% - SEMI distribute parts of the file before
% - TODO add figures (hand made)

%TODO:
% - lots of things could be reduces if C had better support for lists, hash
%   there are lots of duplicated code adding/removing stuff in list
%   (e.g. tdel(), tadd(), etc)

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
 \noweboptions{}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% for typedef forward decl, pragmas, func decl, extern decl, stats, #ifdef,
%  debugging macros

\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
The Plan9 Kernel
}\\
x86 (32 bits) edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 

\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

\dominitoc
\iffinal
\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real operating system\footnote{and in later books to also cover the
compiler, assembler, linker, debugger, windowing system, network
stack, etc}. Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.
% a concrete companion to "Computer systems: a programmer's pespective"

The choice of plan9 may not be obvious, but it is IMHO
the simplest and at the same time fairly complete operating system.
% as simple as possible, but not simpler
If you look at the screenshot in Figure~\ref{fig:X}, you'll see
many features:
\begin{itemize}
\item a screen with basic graphics and windows managment
\item multiple shells running multiple commands
\item a simple clock graphical application
\item a simple program communicating through the network
\end{itemize}

By comparison if you look at the screenshot in Figure~\ref{fig:Y}
you'll see that Plan9 in essence provides the similar core services
of MacOS, Linux or Windows.
% multi tasking, graphics, windows, IO, etc

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item Unix V6 (or its modern incarnation xv6) is too simple;
there is no graphics, no network
\item TECS, excellent for understanding hardware, assemblers,
and even compilers, but the operating part is really too simple
\item MMIX, same issue that for TECS
\item Alan's Kay STEPS project, far more ambitious as
the goal is to have a full system in 20 000 LOC, but not
finished yet.
\item Minix, bigger and does not provide a simple windowing
system as it relies on X11 (which is far more complicated than plan9
Rio windowing system)
\item Gnu/Linux, far far bigger. If you take the source code of glibc,
the Linux kernel, and X11, you'll get at
least 2 orders of magnitude more source code than Plan9, even though
Plan9 provides in essence the same core services. Of course
the Linux kernel contains thousands of specific drivers,
glibc handles many different architectures, and X11 can support
lots of graphic cards and all of those things could be discarded 
when presenting the core of those software, but their core
is still far bigger than Plan9 equivalent core.
\end{itemize}

\section{Getting started}

See \url{https://github.com/aryx/fork-plan9}
and \url{https://github.com/aryx/fork-kencc}.
%kencc install, fork-plan9 install

\section{Assumptions}

I assume you actually know a lot:
\begin{itemize}
\item C
% ref?
% see also comp.ps
\item an assembler
% ref?
% see also asm.ps
\item operating system (yep)
% ref?
\item familiarity with the PC architecture
\end{itemize}

This book is not an introduction to operating systems. The goal
of this book is to present in full details a kernel but we assume
you already have a vague idea of how an operating system
works and so that you are familiar with concepts such as 
virtual memory, critical regions, interrupts, system calls, etc.

\section{About this document}
#include "About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

I would like to acknowledge of course Plan9's authors who wrote
most of this book: Ken Thompson, Rob Pike, Dave Presotto, Phil
Winterbottom, Russ Cox, and many other people from Bell Labs.

Thanks also to Federic Balesteros who wrote a lengthy note about
Plan9's kernel that was very useful.

\chapter{Overview}
\minitoc

\section{Operating system principles}

An operating system is a meta-program: A program that manages other
programs.

It provides convenient abstractions of the hardware and multiplex
those hardware resources for the benefit of user programs:
\begin{itemize}
\item a virtual CPU, so that each process thinks it has all the CPU 
for himself
\item a virtual memory, so that each process thinks it has all memory
for himself
\item a virtual screen, so that each process thinks it has all the screen
for himself
% a file abstraction, continous even though spreaded on concrete disk
% a directory, also continous, even though spread over network and devices
\item a virtual storage (filesystem)
\item a virtual network (NFS)
\end{itemize}

\section{Operating system services}

\begin{verbatim}
 user point of view:
 - start the whole thing, first program!
 - process managment, shell, fork, exec, multi task
 - system calls, =~ APIs of user program
 - interrupt handling, =~ devices and also syscalls and preemptive multi task
 - IO operations, =~ devices and files
 - file managment, =~ filesystem
\end{verbatim}

<<sys.h>>=
#define	NOP		0
<<sys.h process syscalls>>
<<sys.h memory syscalls>>
<<sys.h file syscalls>>
<<sys.h namespace syscalls>>
<<sys.h time syscalls>>
<<sys.h ipc syscalls>>
<<sys.h concurrency syscalls>>
<<sys.h special file syscalls>>
<<sys.h security syscalls>>
#define	ERRSTR		40
@ 
<<sys.h process syscalls>>=
#define	RFORK		1
#define	EXEC		2
#define	EXITS		3
@

<<sys.h memory syscalls>>=
#define	BRK_		32
@ 

<<sys.h file syscalls>>=
#define	CREATE		6
#define	REMOVE		7
#define	OPEN		8
#define	CLOSE		9
#define	PREAD		10
#define	PWRITE		11
#define	SEEK		12
#define	STAT		14
#define	FSTAT		15
#define	WSTAT		16
#define	FWSTAT		17
#define	CHDIR		18
#define	FD2PATH		19
@

<<sys.h namespace syscalls>>=
#define	BIND		22
#define	MOUNT		23
#define	UNMOUNT		24
@

<<sys.h time syscalls>>=
#define	SLEEP		4
#define	ALARM		5
@

<<sys.h ipc syscalls>>=
#define	NOTIFY		30
#define	NOTED		31
#define	PIPE		21
#define	SEGATTACH	33
#define	SEGDETACH	34
#define	SEGFREE		35
#define	SEGFLUSH	36
#define	SEGBRK		37
@

<<sys.h concurrency syscalls>>=
#define	AWAIT		25
#define	RENDEZVOUS	26
#define	SEMACQUIRE	27
#define	SEMRELEASE	28
#define	TSEMACQUIRE	29
@

<<sys.h special file syscalls>>=
#define	DUP		    20
@

<<sys.h security syscalls>>=
#define	FVERSION	38
#define	FAUTH		39
@

\section{Plan9}

%plan9 specifics vs general os principles, e.g. namespace so have
% nice /dev/cons, /dev/draw, which enable easier network and graphics

% see 9.ps, excellent introduction to Plan9 advanced features

%TODO
%things plan9 make so much easier to implement/understand:
% tty
% X11, xterm
% nfs
% fuse
%
%Plan9 approach is good? abuse files? could use different API?
%For instance /dev/draw has a very specific format, so it's
%a bit abusing files.
%But at the same time one for sure needs to store things in files,
%so one need files, at which point you want to define the minimum of 
%concepts and so make files more generic => device can be files,
%but also pipes, etc, and so plan9 just push to its conclusion
%this idea.

% missing stuff in plan9:
% - shared library (help save some memory, but complicated)

\section{The machine}
%PC vs raspberry pi?

\section{C and Asm}

% Kencc extension: anon field. e.g. Lock; 

% the lock+0(FP) is intriguing

\section{Code organization}

% codemap and codegraph screenshot?

<<kernel basic includes>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"
@ 


<<dat.h>>=
#include "dat_forward.h"
#include "../port/portdat_forward.h"

<<enum miscsize_dat>>

// defines Lock (used inline in Mach in portdat_core.h so must be before)
#include "../port/portdat_concurrency.h"

// defines Conf, Mach
#include "dat_core.h"
#include "../port/portdat_core.h"

// defines Page
#include "dat_memory.h"
#include "../port/portdat_memory.h"

// defines Chan
#include "../port/portdat_files.h"

#include "dat_arch.h"

// defines Proc
#include "dat_processes.h"
#include "../port/portdat_processes.h"

// defines Cmd
#include "../port/portdat_misc.h"

// defines Uart
#include "dat_buses.h"
#include "../port/portdat_buses.h"

// defines keyboard queue
#include "../port/portdat_console.h"

<<constant AOUT_MAGIC>>

<<enum misc_dat>>

// could be put in lib.h
<<portdat.h macros>>

// convenient constants
<<enum miscsize_portdat>>

<<portdat.h pragmas>>
@

<<fns.h>>=
#include "../port/portfns_core.h"
#include "../port/portfns_concurrency.h"
#include "../port/portfns_memory.h"
#include "../port/portfns_files.h"
#include "../port/portfns_processes.h"
#include "../port/portfns_misc.h"
#include "../port/portfns_console.h"
#include "../port/portfns_buses.h"
#include "../port/portfns_devices.h"
#include "../port/portfns_security.h"
#include "../port/portfns_network.h"
#include "../port/portfns_init.h"

<<fns.h declarations>>
@


\section{Booting overview}
% kernel that creates first user process!
% introduce dichotomy kernel/user

% there is booting the kernel, booting the kernel environment,
%  and then booting the user environment, and finally booting user programs

% see also:
% http://arjunsreedharan.org/post/82710718100/kernel-101-lets-write-a-kernel

% steps:
% - hardware detection, populate Conf
% - initialization, populate allocators
% - create first process

% then user/preboot setup env, boot is responbile to mount root
% and then init assumes a root and setup last things.

\section{Memory overview}
% kernel vs user memory
% dynamic vs static (the static allocator so can bootstrap things)

%need precise physical map of memory
%
%with first empty page?, idtr, gdt, pdb intel, pte intel, 
%io RAM, vga ram,  then KZERO header, KTZERO, 
%code,  data with important globals like xlist, and array holes,
%palloc with pointer page, and then on top of that confmem area
%
%the data section of the kernel binary is as important as
%the code section. For the code section can also give name
%of procedures, and devtab (in data section) pointing back to it
%via the static "classes" in the data section again).
%
%need also precise virtual map of memory for regular process,
% actually for 2 processes
%
%need also precise virtual map of memory for first handcrafted process?
%

\section{Syscall overview}
% kernel vs user code

% sequence diagram?

% use an enum instead in sys.h? but then the script that generates
%  the .s in libc/ will be more complicated



% show example of generated assembly code
% maybe can even show an example where abuse sysnop so can see things :)

<<typedef Syscall>>=
typedef long Syscall(ulong*);
@

<<systab.h>>=
// used by systab.c but also by trap.c for certain codes
#include "/sys/src/libc/9syscall/sys.h"

<<typedef Syscall>>

extern Syscall *systab[];
extern int nsyscall;
extern char *sysctab[];
@


<<global systab>>=
Syscall *systab[] = {
    [NOP]     sysnop,
<<systab process syscalls>>
<<systab memory syscalls>>
<<systab file syscalls>>
<<systab namespace syscalls>>
<<systab time syscalls>>
<<systab ipc syscalls>>
<<systab concurrency syscalls>>
<<systab special file syscalls>>
<<systab security syscalls>>
    [ERRSTR]    syserrstr,
};
int nsyscall = nelem(systab);
@

<<syscall nop>>=
long
sysnop(ulong*)
{
    //checkpagerefs();
    return 0;
}
@ 



\chapter{Core Data Structures}
\minitoc

% mini libc: bool, int, strings, unicode, etc

\section{[[Conf]] and [[conf]]}

<<struct Conf>>=
struct Conf
{
    ulong nmach;    /* processors */
    ulong nproc;    /* processes */
    Confmem mem[4];   /* physical memory */

    <<[[Conf]] extra fields>>
  
    struct ArchConf;
};
@ 

%    // in bcm/ it's mem[1], important? why 4?

<<global conf>>=
Conf conf;
@ 

<<globals confname and confvar>>=
// conf (boot) parameters *e.g. { "*kernelpercent*" => "60" }
// hash<string, string>
char *confname[MAXCONF];
char *confval[MAXCONF];
// Hashtbl.length(confname)
int nconf;
@ 

<<constant MAXCONF>>=
#define MAXCONF         64
@ 

<<function getconf>>=
char* getconf(char *name)
{
        int i;
        for(i = 0; i < nconf; i++)
                if(cistrcmp(confname[i], name) == 0)
                        return confval[i];
        return nil;
}
@



<<struct Confmem>>=
// memory "bank"
struct Confmem
{
    ulong base; // phys?
    ulong npage;
  
    ulong kbase; // phys?
    ulong klimit; // phys?
};
@ 


\section{[[Mach]] and [[m]]}

<<struct Mach>>=
struct Mach
{
    int machno;     /* physical id of processor (KNOWN TO ASSEMBLY) */
    <<[[Mach]] second field>>
  
    // ref<Proc>
    Proc* proc;     /* current process on this processor */

    <<[[Mach]] stat fields>>

    <<[[Mach]] other fields>>

    struct ArchMach;
  
    // must be at the end of the structure!
    int stack[1];
};
@ 

<<global m>>=
Mach *m;
@ 


<<global machp>>=
/*
 * Each processor sees its own Mach structure at address MACHADDR.
 * However, the Mach structures must also be available via the per-processor
 * MMU information array machp, mainly for disambiguation and access to
 * the clock which is only maintained by the bootstrap processor (0).
 */
// array<ref<Mach>>, MAXMACH is defined in 386/mem.h
Mach* machp[MAXMACH];
@ 

<<macro MACHP>>=
#define MACHP(n)  (machp[n])
@


<<struct Active>>=
struct Active
{
    //array<bool>
    int machs;      /* bitmap of active CPUs */

    int exiting;    /* shutdown */
    int ispanic;    /* shutdown in response to a panic */
  
    // 386 specific?
    int thunderbirdsarego;  /* lets the added processors continue to schedinit */
    int rebooting;    /* just idle cpus > 0 */
  
    // extra
    Lock;
};
@ 

<<global active>>=
struct Active active;
@ 



<<struct ArchMach>>=
struct ArchMach {
    <<[[ArchMach]] other fields>>
};
@ 

\section{[[Proc]] and [[up]]}

<<struct Proc>>=
// the most important fields are set by newproc()
struct Proc
{
//--------------------------------------------------------------------
// Assembly requirements, Low level, have to be first
//--------------------------------------------------------------------
    <<[[Proc]] assembly fields>>
//--------------------------------------------------------------------
// State
//--------------------------------------------------------------------
    <<[[Proc]] state fields>>
//--------------------------------------------------------------------
// Memory
//--------------------------------------------------------------------
    <<[[Proc]] memory fields>>
//--------------------------------------------------------------------
// Scheduling
//--------------------------------------------------------------------
    <<[[Proc]] scheduling fields>>
//--------------------------------------------------------------------
// Files
//--------------------------------------------------------------------
    <<[[Proc]] files fields>>
//--------------------------------------------------------------------
// Notes
//--------------------------------------------------------------------
    <<[[Proc]] notes fields>>
//--------------------------------------------------------------------
// Process hierarchy
//--------------------------------------------------------------------
    <<[[Proc]] hierarchy fields>>
//--------------------------------------------------------------------
// Synchronization
//--------------------------------------------------------------------
    <<[[Proc]] synchronization fields>>
//--------------------------------------------------------------------
// Error managment
//--------------------------------------------------------------------
    <<[[Proc]] error managment fields>>
//--------------------------------------------------------------------
// Stats, profiling
//--------------------------------------------------------------------
    <<[[Proc]] stats and profiling fields>>
//--------------------------------------------------------------------
// Debugging
//--------------------------------------------------------------------
    <<[[Proc]] debugging fields>>
//--------------------------------------------------------------------
// For debugger
//--------------------------------------------------------------------
    <<[[Proc]] debugger fields>>
//--------------------------------------------------------------------
// Other
//--------------------------------------------------------------------
    <<[[Proc]] other fields>>
//--------------------------------------------------------------------
// Extra
//--------------------------------------------------------------------
    <<[[Proc]] extra fields>>
};
@ 

<<[[Proc]] state fields>>=
ulong pid;

// enum<procstate>
int state; // Dead, Queuing, etc,
@ 

<<enum procstate>>=
/* Process states, Proc.state */
enum procstate
{
    Dead = 0,
    Running,
    <<enum procstate cases>>
};
@ 


<<[[ArchMach]] other fields>>=
Proc* externup;   /* extern register Proc *up */
@

<<macro up>>=
// up = user process, MACHADDR is defined in 386/mem.h
#define up  (((Mach*)MACHADDR)->externup)
@

%//TODO: mv in 386/ TODO: why not m->externup? m is not valid?


\section{[[Chan]]}

<<struct Chan>>=
struct Chan
{
    ushort  type; // idx in devtab?
    Qid qid;
    vlong offset;     /* in fd */
    ushort  mode;     /* read/write */

    <<[[Chan]] other fields>>

    // extra
    <<[[Chan]] extra fields>>
};
@ 

% rob pike: "q for unique"
% qid =~ inode =~ internal representation of a file
<<struct Qid>>=
struct Qid
{
  // note that this is not a string, but an int! it's kind of an inode?
  uvlong  path;
  // for cache invalidation
  ulong vers;
  // enum<qidtype>
  uchar type;
};
@ 


<<enum qidtype>>=
/* bits in Qid.type */
enum qidtype {
  QTFILE = 0x00,    /* plain file */
  QTDIR = 0x80,    /* type bit for directories */
  QTMOUNT = 0x10,    /* type bit for mounted channel */

  QTAUTH = 0x08,    /* type bit for authentication file */
  QTAPPEND = 0x40,    /* type bit for append only files */
  QTEXCL = 0x20,    /* type bit for exclusive use files */
};
@ 

\section{[[Dev]] and [[devtab]]}


<<struct Dev>>=
struct Dev
{
    int dc; // dev character code, e.g. '/' (devroot), 'e' (devenv), ...
    char* name;
    
    void  (*reset)(void);
    void  (*init)(void);
    void  (*shutdown)(void);
    Chan* (*attach)(char*);

    Walkqid*(*walk)(Chan*, Chan*, char**, int);

    void  (*create)(Chan*, char*, int, ulong);
    void  (*remove)(Chan*);

    Chan* (*open)(Chan*, int);
    void  (*close)(Chan*);
    long  (*read)(Chan*, void*, long, vlong);
    long  (*write)(Chan*, void*, long, vlong);

    Block* (*bread)(Chan*, long, ulong);
    long  (*bwrite)(Chan*, Block*, ulong);

    int (*stat)(Chan*, uchar*, int);
    int (*wstat)(Chan*, uchar*, int);

    void  (*power)(bool);  /* power mgt: power(1) => on, power (0) => off */
    int (*config)(int, char*, DevConf*);  /* returns nil on error */

    <<[[Dev]] other fields>>
};
@ 

<<global devtab>>=
Dev** devtab = 0;
@

% ex of conf_devtab:
%Dev* conf_devtab[]={
%	&rootdevtab,
%	&consdevtab,
%       ...

\chapter{Concurrency}
\minitoc

% when think about concurrency in userspace program, have
% shared memory of multiple program threads and need to mediate
% access to shared data via semaphore/lock/whatever.

% well OS is a kind of program and it has also mutiple
% "threads" (different processors) and lots of shared data
% (kernel meta data about user processes and its own data)
% (which is why lots of the concurrency issues arised first
% for OS programmers long before the other)

<<systab concurrency syscalls>>=
    [AWAIT]     sysawait,
    [RENDEZVOUS]    sysrendezvous,

    [SEMACQUIRE]    syssemacquire,
    [SEMRELEASE]    syssemrelease,
    [TSEMACQUIRE]   systsemacquire,
@ 

\section{Critical regions}

\begin{verbatim}
 There are different code/data "regions": 
 - user code/data
 - kernel data about user process
 - kernel data
 - kernel init code
 - kernel code of syscalls (soft interrupt), acting on behalf of user process
 - kernel code of interrupt handlers (hard interrupt).
 - kernel code of kernel processes (e.g. the alarm kernel process)

 There is no mutual exclusion need between user and kernel code. 
 Same for init code as only one processor is used during the
 uninterrupted sequential initialization.
 There is also no need between different user processes.

 For the kernel code one wants mutual exclusion because of possible race 
 on shared data structures between the syscalls themselves when run
 on different processors (or even when run on one processor as one syscall
 can be interrupted causing a scheduling that will then lead later to
 another syscall), but also between the syscalls and interrupts.
 The flow of control on one processor can be 
  - User -> Syscall, 
  - User -> Interrupt,
  - or even User -> Syscall -> Interrupt
  - one can even have User -> Syscall -> Interrupt -> Interrupt!!

 This is on one processor. Multiple processors lead to more combinations
 where 2 processors can run at the same time 2 interrupt handlers for instance.
 
 One must take care when using locks inside interrupts as one can deadlock
 if the same lock was used in the enclosing syscall (hence ilock/iunlock)

 For protecting kernel syscall code from interrupt kernel code: splhi(), splo()
 For very small critical region: taslock
 For bigger region, or when have lots of contention on a lock: qlock

\end{verbatim}

\section{[[tas()]]}

<<function tas>>=
TEXT tas(SB), $0
        MOVL    $0xDEADDEAD, AX
        MOVL    lock+0(FP), BX
        // Exchange AX to lock->key. So:
        //  - if the lock was not held, lock->key was 0 and so AX will be 0
        //     and lock->key will be 0xdeaddead
        //  - if the lock was held, AX will be 0xdeaddead and lock->key will
        //    still be 0xdeaddead.
        XCHGL   AX, (BX)                        /* lock->key */
        RET
@ 

% see als cmpswap in arch? and used for semaphore for instance

\section{[[Lock]]}

<<struct Lock>>=
struct Lock
{
    ulong key; // 0 when unset, 0xDEADDEAD when acquired, could be a bool

    // option<ref<Proc>>, None when key = 0
    Proc  *p; // the process locking should be the same unlocking

    // virt_addr?
    uintptr pc; // for debugging

    <<[[Lock]] ilock fields>>
    <<[[Lock]] other fields>>
    <<[[Lock]] debugging fields>>
};
@ 

<<[[Proc]] debugging fields>>=
Lock* lastlock;
@

<<[[Proc]] other fields>>=
// As long as the current process hold locks (to kernel data structures),
// we will not schedule another process in unlock(); only the last unlock
// will eventually cause a rescheduling.
Ref nlocks;   /* number of locks held by proc */
@ 

\ifallcode
<<lock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
        l->lockcycles = -lcycles();
#endif
@ 
\fi

<<function lock>>=
int
lock(Lock *l)
{
    int i;
    ulong pc;

    pc = getcallerpc(&l);

    lockstats.locks++;
    if(up)
        inccnt(&up->nlocks);    /* prevent being scheded */
    if(tas(&l->key) == 0){
        if(up)
            up->lastlock = l;
        l->pc = pc;
        l->p = up;
        l->isilock = false;
        //TODO: not setting l->m = ??
<<lock ifdef LOCKCYCLES>>

        return 0;
    }
    if(up)
        deccnt(&up->nlocks);

    lockstats.glare++;
    for(;;){
        lockstats.inglare++;
        i = 0;
        while(l->key){
            if(conf.nmach < 2 && up && up->edf && (up->edf->flags & Admitted)){
                /*
                 * Priority inversion, yield on a uniprocessor; on a
                 * multiprocessor, the other processor will unlock
                 */
                print("inversion %#p pc %#lux proc %lud held by pc %#lux proc %lud\n",
                    l, pc, up ? up->pid : 0, l->pc, l->p ? l->p->pid : 0);
                up->edf->d = todget(nil);   /* yield to process with lock */
            }
            if(i++ > 100000000){
                i = 0;
                lockloop(l, pc);
            }
        }
        if(up)
            inccnt(&up->nlocks);
        if(tas(&l->key) == 0){
            if(up)
                up->lastlock = l;
            l->pc = pc;
            l->p = up;
            l->isilock = false;
<<lock ifdef LOCKCYCLES>>
            return 1;
        }
        if(up)
            deccnt(&up->nlocks);
    }
}
@ 

\ifallcode
<<unlock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumlockcycles += l->lockcycles;
    if(l->lockcycles > maxlockcycles){
        maxlockcycles = l->lockcycles;
        maxlockpc = l->pc;
    }
#endif
@ 
\fi

<<function unlock>>=
void
unlock(Lock *l)
{
<<unlock ifdef LOCKCYCLES>>

    if(l->key == 0)
        print("unlock: not locked: pc %#p\n", getcallerpc(&l));
    if(l->isilock)
        print("unlock of ilock: pc %lux, held by %lux\n", getcallerpc(&l), l->pc);
    if(l->p != up)
        print("unlock: up changed: pc %#p, acquired at pc %lux, lock p %#p, unlock up %#p\n", getcallerpc(&l), l->pc, l->p, up);

    l->m = nil;
    l->key = 0;
    // for processor caches, to ensure the lock value is seen by other
    // processors so that if they were doing while(l->key) { ... } they
    // can finally exit the while loop.
    coherence();

    if(up && deccnt(&up->nlocks) == 0 && up->delaysched && islo()){
        /*
         * Call sched if the need arose while locks were held
         * But, don't do it from interrupt routines, hence the islo() test
         */
        sched();
    }
}
@ 

<<function canlock>>=
int
canlock(Lock *l)
{
    if(up)
        inccnt(&up->nlocks);
    if(tas(&l->key)){
        if(up)
            deccnt(&up->nlocks);
        return 0;
    }

    if(up)
        up->lastlock = l;
    l->pc = getcallerpc(&l);
    l->p = up;
    l->m = MACHP(m->machno);
    l->isilock = false;
<<lock ifdef LOCKCYCLES>>
    return 1;
}
@ 


\section{Interrupt [[Lock]]}
% can formalize a checking rule? if access any field
% accessed from a xxxintr, then need to use ilock

<<[[Mach]] second field>>=
    // must be second field at 0x04, used by splhi()
    ulong splpc;      /* pc of last caller to splhi */
@ 

<<function splhi>>=
// int   splhi(void);
TEXT splhi(SB), $0
shi:
        PUSHFL
        POPL    AX
        TESTL   $0x200, AX
        JZ      alreadyhi
        MOVL    $(MACHADDR+0x04), CX            /* save PC in m->splpc */
        MOVL    (SP), BX
        MOVL    BX, (CX)
alreadyhi:
        CLI
        RET
@ 


<<function spllo>>=
// int   spllo(void);
TEXT spllo(SB), $0
slo:
        PUSHFL
        POPL    AX
        TESTL   $0x200, AX
        JNZ     alreadylo
        MOVL    $(MACHADDR+0x04), CX            /* clear m->splpc */
        MOVL    $0, (CX)
alreadylo:
        STI
        RET
@ 


<<function splx>>=
// void    splx(int);
TEXT splx(SB), $0
        MOVL    s+0(FP), AX
        TESTL   $0x200, AX
        JNZ     slo
        JMP     shi
@ 


<<function islo>>=
// bool islo(void);
TEXT islo(SB), $0
        PUSHFL
        POPL    AX
        ANDL    $0x200, AX                      /* interrupt enable flag */
        RET
@ 


<<[[Lock]] ilock fields>>=
bool_ushort isilock; // false when from lock(), true when from ilock()
ulong sr; // saved priority level when using ilock() to restore in iunlock()
@ 

<<[[Proc]] debugging fields>>=
Lock  *lastilock; /* debugging */
@ 

<<[[Mach]] other fields>>=
int ilockdepth;
@ 

<<function ilock>>=
// To provide mutual exclusion with interrupt code and avoiding deadlock.
// By using splhi() we disable interrupts while running the critical region
// code.
void
ilock(Lock *l)
{
    ulong x;
    ulong pc;

    pc = getcallerpc(&l);
    lockstats.locks++;

    x = splhi();
    if(tas(&l->key) != 0){
        lockstats.glare++;
        /*
         * Cannot also check l->pc, l->m, or l->isilock here
         * because they might just not be set yet, or
         * (for pc and m) the lock might have just been unlocked.
         */
        for(;;){
            lockstats.inglare++;
            splx(x);
            while(l->key)
                ;
            x = splhi();
            if(tas(&l->key) == 0)
                goto acquire;
        }
    }
acquire:
    m->ilockdepth++;
    if(up)
        up->lastilock = l;
    l->sr = x;
    l->pc = pc;
    l->p = up;
    l->isilock = true;
        //TODO: why not just l->m = m? 
    l->m = MACHP(m->machno);
<<lock ifdef LOCKCYCLES>>
}
@ 

\ifallcode
<<iunlock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumilockcycles += l->lockcycles;
    if(l->lockcycles > maxilockcycles){
        maxilockcycles = l->lockcycles;
        maxilockpc = l->pc;
    }
    if(l->lockcycles > 2400)
        ilockpcs[n++ & 0xff]  = l->pc;
#endif
@ 
\fi

<<function iunlock>>=
void
iunlock(Lock *l)
{
    ulong sr;

<<iunlock ifdef LOCKCYCLES>>
    if(l->key == 0)
        print("iunlock: not locked: pc %#p\n", getcallerpc(&l));
    if(!l->isilock)
        print("iunlock of lock: pc %#p, held by %#lux\n", getcallerpc(&l), l->pc);
    if(islo())
        print("iunlock while lo: pc %#p, held by %#lux\n", getcallerpc(&l), l->pc);

    sr = l->sr;
    l->m = nil;
    l->key = 0;
    coherence();
    m->ilockdepth--;
    if(up)
        up->lastilock = nil;
    splx(sr);
}
@ 

\section{[[QLock]]}

<<struct QLock>>=
// Kernel basic lock with Queue (renamed to avoid ambiguity with libc.h Qlock)
struct KQLock
{
    bool  locked;   /* flag */
  
    // list<ref<Proc>> (next = Proc.qnext)
    Proc  *head;    /* next process waiting for object */
    // list<ref<Proc>> (direct access to tail, queue)
    Proc  *tail;    /* last process waiting for object */
  
    uintptr qpc;    /* pc of the holder */ // for debugging?
  
    Lock  use;    /* to access Qlock structure */
};
@ 

<<[[Proc]] extra fields>>=
// list<ref<Proc>> KQlock.head or RWLock.head
Proc  *qnext;   /* next process on queue for a QLock */
@ 

<<enum procstate cases>>=
Queueing, // see qlock()
@

<<function qlock>>=
void
qlock(QLock *q)
{
    Proc *p;

    if(m->ilockdepth != 0)
        print("qlock: %#p: ilockdepth %d\n", getcallerpc(&q), m->ilockdepth);
    if(up != nil && up->nlocks.ref)
        print("qlock: %#p: nlocks %lud\n", getcallerpc(&q), up->nlocks.ref);

    if(q->use.key == 0x55555555)
        panic("qlock: q %#p, key 5*\n", q);
    lock(&q->use);
    rwstats.qlock++;
    if(!q->locked) {
        q->locked = true;
        q->qpc = getcallerpc(&q);
        unlock(&q->use);
        return;
    }
    if(up == 0)
        panic("qlock");
    rwstats.qlockq++;
    p = q->tail;
    if(p == 0)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = nil;
    up->state = Queueing;
    up->qpc = getcallerpc(&q);
    unlock(&q->use);
    sched();
    q->qpc = getcallerpc(&q);
}
@ 


<<function canqlock>>=
int
canqlock(QLock *q)
{
    if(!canlock(&q->use))
        return 0;
    if(q->locked){
        unlock(&q->use);
        return 0;
    }
    q->locked = true;
    q->qpc = getcallerpc(&q);
    unlock(&q->use);
    return 1;
}
@ 

<<function qunlock>>=
void
qunlock(QLock *q)
{
    Proc *p;

    lock(&q->use);
    if (q->locked == false)
        print("qunlock called with qlock not held, from %#p\n",
            getcallerpc(&q));
    p = q->head;
    if(p){
        q->head = p->qnext;
        if(q->head == 0)
            q->tail = nil;
        unlock(&q->use);
        ready(p);
        return;
    }
    q->locked = false;
    q->qpc = 0;
    unlock(&q->use);
}
@ 

\section{[[RWLock]]}

<<struct RWlock>>=
struct RWlock
{
    int readers;  /* number of readers */
    bool writer;   /* number of writers */
  
    // list<ref<Proc>> (next = Proc.qnext)
    Proc  *head;    /* list of waiting processes */
    // list<ref<Proc>> (direct access to tail, queue)
    Proc  *tail;
    // option<ref<Proc>> 
    Proc  *wproc;   /* writing proc */
  
    uintptr wpc;    /* pc of writer */
  
    Lock  use;
};
@ 

<<enum procstate cases>>=
QueueingR, // see rlock()
@

<<function rlock>>=
void
rlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    rwstats.rlock++;
    if(q->writer == 0 && q->head == nil){
        /* no writer, go for it */
        q->readers++;
        unlock(&q->use);
        return;
    }

    rwstats.rlockq++;
    p = q->tail;
    if(up == nil)
        panic("rlock");
    if(p == 0)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = nil;
    up->state = QueueingR;
    unlock(&q->use);
    sched();
}
@ 

<<function runlock>>=
void
runlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    p = q->head;
    if(--(q->readers) > 0 || p == nil){
        unlock(&q->use);
        return;
    }

    /* start waiting writer */
    if(p->state != QueueingW)
        panic("runlock");
    q->head = p->qnext;
    if(q->head == 0)
        q->tail = nil;
    q->writer = true;
    unlock(&q->use);
    ready(p);
}
@ 

<<enum procstate cases>>=
QueueingW, // see wlock()
@

<<function wlock>>=
void
wlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    rwstats.wlock++;
    if(q->readers == 0 && q->writer == 0){
        /* noone waiting, go for it */
        q->wpc = getcallerpc(&q);
        q->wproc = up;
        q->writer = true;
        unlock(&q->use);
        return;
    }

    /* wait */
    rwstats.wlockq++;
    p = q->tail;
    if(up == nil)
        panic("wlock");
    if(p == nil)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = nil;
    up->state = QueueingW;
    unlock(&q->use);
    sched();
}
@ 


<<function wunlock>>=
void
wunlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    p = q->head;
    if(p == nil){
        q->writer = false;
        unlock(&q->use);
        return;
    }
    if(p->state == QueueingW){
        /* start waiting writer */
        q->head = p->qnext;
        if(q->head == nil)
            q->tail = nil;
        unlock(&q->use);
        ready(p);
        return;
    }

    if(p->state != QueueingR)
        panic("wunlock");

    /* waken waiting readers */
    while(q->head != nil && q->head->state == QueueingR){
        p = q->head;
        q->head = p->qnext;
        q->readers++;
        ready(p);
    }
    if(q->head == nil)
        q->tail = nil;
    q->writer = false;
    unlock(&q->use);
}
@ 


<<function canrlock>>=
/* same as rlock but punts if there are any writers waiting */
int
canrlock(RWlock *q)
{
    lock(&q->use);
    rwstats.rlock++;
    if(q->writer == 0 && q->head == nil){
        /* no writer, go for it */
        q->readers++;
        unlock(&q->use);
        return 1;
    }
    unlock(&q->use);
    return 0;
}
@ 

\section{Atomic [[Ref]]erences}

<<struct Ref>>=
// For reference counting shared things (e.g. a Page)
struct Ref
{
    long  ref;
    Lock;
};
@ 


<<function incref>>=
long
incref(Ref *r)
{
    long x;

    lock(r);
    x = ++r->ref;
    unlock(r);
    return x;
}
@ 


<<function decref>>=
long
decref(Ref *r)
{
    long x;

    lock(r);
    x = --r->ref;
    unlock(r);
    if(x < 0)
        panic("decref pc=%#p", getcallerpc(&r));

    return x;
}
@ 



<<function inccnt>>=
// See also ref.c incref() and decref(), but we can't use them here as they
// themselves rely on lock() and unlock(). 
static void
inccnt(Ref *r)
{
    _xinc(&r->ref);
}
@ 


<<function deccnt>>=
static int
deccnt(Ref *r)
{
    int x;

    x = _xdec(&r->ref);
    if(x < 0)
        panic("deccnt pc=%#p", getcallerpc(&r));
    return x;
}
@ 

<<function _xinc>>=
/* void _xinc(long*); */
TEXT _xinc(SB), $0
        MOVL    l+0(FP), AX
        LOCK;   INCL 0(AX)
        RET
@ 


<<function _xdec>>=
/* long _xdec(long*); */
TEXT _xdec(SB), $0
        MOVL    l+0(FP), BX
        XORL    AX, AX
        LOCK;   DECL 0(BX)
        JLT     _xdeclt
        JGT     _xdecgt
        RET
_xdecgt:
        INCL    AX
        RET
_xdeclt:
        DECL    AX
        RET
@ 


<<struct Counter>>=
typedef struct Ref Counter;
@ 


\section{Synchronization}
% different from critical regions

% see sleep.ps in plan9 documents

\section{[[Rendez]]-vous}
% sleep/wakeup?

<<struct Rendez>>=
struct Rendez
{
    // ??
    Proc  *p;
    Lock;
};
@ 


\section{[[Sema]]phore}
% those are actually used for user-level locks, see libcore/libc/port/lock.c

<<struct Sema>>=
// user level semaphores, used to implement user-level lock, 
// see libc/port/lock.c
struct Sema
{
    long  *addr; // value stored in user space!
    int waiting;
  
    //list<Sema> of Segment.sema
    Sema  *next;
    Sema  *prev;

    Rendez;
};
@ 


\chapter{Memory}
\minitoc

<<systab memory syscalls>>=
    [BRK_]      sysbrk_,
@ 

\section{Overview}
% kernel vs user memory

\section{Pool allocation}

\section{[[xalloc()]]}

\section{Kernel malloc}

\section{User malloc}
%actually brk

\section{Virtual memory}

\section{[[Page]]}

\section{[[Segment]]}

\section{Swapping}

\section{[[sysbrk()]]}




\chapter{Processes}
\minitoc

<<systab process syscalls>>=
    [RFORK]     sysrfork,
    [EXEC]      sysexec,
    [EXITS]     sysexits,
@ 

\section{Overview}

\section{[[Proc]]}

\section{Context switch}

\section{Traps and interrupts}

\section{Clock interrupt}

<<struct I8253>>=
struct I8253
{
    ulong   period;     /* current clock period */
    bool    enabled;

    uvlong  hz;

    ushort  last;       /* last value of clock 1 */
    uvlong  ticks;      /* cumulative ticks of counter 1 */

    ulong   periodset;

    // extra
    Lock;
};
@


<<global i8253>>=
I8253 i8253;
@

<<function i8253init>>=
void
i8253init(void)
{
    int loops, x;

    ioalloc(T0cntr, 4, 0, "i8253");
    ioalloc(T2ctl, 1, 0, "i8253.cntr2ctl");

    i8253.period = Freq/HZ;

    /*
     *  enable a 1/HZ interrupt for providing scheduling interrupts
     */
    outb(Tmode, Load0|Square);
    outb(T0cntr, (Freq/HZ));    /* low byte */
    outb(T0cntr, (Freq/HZ)>>8); /* high byte */

    /*
     *  enable a longer period counter to use as a clock
     */
    outb(Tmode, Load2|Square);
    outb(T2cntr, 0);        /* low byte */
    outb(T2cntr, 0);        /* high byte */
    x = inb(T2ctl);
    x |= T2gate;
    outb(T2ctl, x);
    
    /*
     * Introduce a little delay to make sure the count is
     * latched and the timer is counting down; with a fast
     * enough processor this may not be the case.
     * The i8254 (which this probably is) has a read-back
     * command which can be used to make sure the counting
     * register has been written into the counting element.
     */
    x = (Freq/HZ);
    for(loops = 0; loops < 100000 && x >= (Freq/HZ); loops++){
        outb(Tmode, Latch0);
        x = inb(T0cntr);
        x |= inb(T0cntr)<<8;
    }
}
@

<<function i8253enable>>=
void
i8253enable(void)
{
    i8253.enabled = true;
    i8253.period = Freq/HZ;
    intrenable(IrqCLOCK, i8253clock, 0, BUSUNKNOWN, "clock");
}
@

<<interrupt callback i8253clock>>=
static void
i8253clock(Ureg* ureg, void*)
{
    timerintr(ureg, 0);
}
@



\section{Scheduler, [[sched()]] and [[ready()]]}

\section{[[sleep()]], [[wakeup()]]}

\section{[[sysfork()]]}

\section{[[sysexec()]]}

\section{[[sysexits()]]}


\chapter{Initialization}
\minitoc

\section{Booting the kernel}

\section{Kernel initialization}

\section{The first process}

\section{Booting the user}
% see section on Userspace system programs

\chapter{Files}
\minitoc

<<systab file syscalls>>=
    [CREATE]    syscreate,
    [REMOVE]    sysremove,

    [OPEN]      sysopen,
    [CLOSE]     sysclose,
    [PREAD]     syspread,
    [PWRITE]    syspwrite,
    [SEEK]      sysseek,

    [STAT]      sysstat,
    [FSTAT]     sysfstat,
    [WSTAT]     syswstat,
    [FWSTAT]    sysfwstat,

    [CHDIR]     syschdir,
    [FD2PATH]   sysfd2path, // pwd?
@ 

% note that files are used for many things, including devices!!
% plan has lots of actually file servers
%pike: interface is not everything is not a file, but everything is
% a file server interface!

\section{Overview}

\section{[[Chan]]nels}

\section{[[dev]]ices [[tab]]le}

\section{[[syscreate()]], [[sysremove()]]}

\section {[[sysopen()]], [[sysclose()]]}

\section {[[syspread()]], [[syspwrite()]]}

\section {[[sysstat()]]}

\section {[[syschdir()]]}

\section{Other syscalls}


\chapter{Namespace}
\minitoc

% see names.ps
% see lexnames.ps

<<systab namespace syscalls>>=
    [BIND]      sysbind,
    [MOUNT]     sysmount,
    [UNMOUNT]   sysunmount,
@ 

\section{Overview}

\section{[[bind()]]}

\section{[[mount()]]}

\section{Other syscalls}


\chapter{Devices}
\minitoc

\section{The Console device}

\subsection{Overview}
\subsection{Input}
\subsection{Output}
\subsection{[[devcons.c]]}


\section{System devices}

\subsection{[[devroot.c]]}

% just with that we can already have a working environment
% with a memory fs! where all binaries are processed via data2txt

%#/

\subsection{[[devenv.c]]}

%#e

\subsection{[[devproc.c]]}

%#p


\section{External devices}

\subsection{Screen}
% just cga.c here, see Window.tex.nw for the advanced vga kernel support

\subsection{Keyboard}

\subsection{Mouse}

\subsection{Audio}

\subsection{Storage}


\section{Special devices}
%optional, advanced concepts

<<systab special file syscalls>>=
    [DUP]       sysdup,
@ 

\subsection{[[devdup.c]]}

\subsection{[[devpipe.c]]}
% see section in IPC also?
% have pipe syscall and device, so both useful? named pipe
% can be done only via devpipe.c

\subsection{[[devmnt.c]]}

\subsection{[[devsrv.c]]}




\chapter{Time}
\minitoc

<<systab time syscalls>>=
    [SLEEP]     syssleep,
    [ALARM]     sysalarm,
@

\section{Timers}

% capacity of machine is very low, just timer next point
%  but have many processes, many timer needs, so need map
%  all of that on very limited hardware power

\subsection{Time units}

<<type Tval>>=
typedef vlong   Tval; // ticks
typedef vlong   Tnano; // nanoseconds
typedef vlong   Tmicro; // microseconds
typedef int     Tms; // milliseconds
typedef vlong   Tsec; // seconds
@

<<function tk2ms>>=
/*
 *  This tk2ms avoids overflows that the macro version is prone to.
 *  It is a LOT slower so shouldn't be used if you're just converting
 *  a delta.
 */
ulong
tk2ms(ulong ticks)
{
    uvlong t, hz;

    t = ticks;
    hz = HZ;
    t *= 1000L;
    t = t/hz;
    ticks = t;
    return ticks;
}
@ 


<<function ms2tk>>=
ulong
ms2tk(ulong ms)
{
    /* avoid overflows at the cost of precision */
    if(ms >= 1000000000/HZ)
        return (ms/1000)*HZ;
    return (ms*HZ+500)/1000;
}
@ 

\subsection{[[timerset()]]}

<<function timerset>>=
// used to be static, but now shared between arch.c and devarch.c
int doi8253set = 1;
/*
 *  set next timer interrupt
 */
void
timerset(Tval x)
{
    if(doi8253set)
        (*arch->timerset)(x);
}
@

<<function i8253timerset>>=
void
i8253timerset(uvlong next)
{
    long period;
    ulong want;
    ulong now;

    period = MaxPeriod;
    if(next != 0){
        want = next>>Tickshift;
        now = i8253.ticks;  /* assuming whomever called us just did fastticks() */

        period = want - now;
        if(period < MinPeriod)
            period = MinPeriod;
        else if(period > MaxPeriod)
            period = MaxPeriod;
    }

    /* hysteresis */
    if(i8253.period != period){
        ilock(&i8253);
        /* load new value */
        outb(Tmode, Load0|Square);
        outb(T0cntr, period);       /* low byte */
        outb(T0cntr, period >> 8);      /* high byte */

        /* remember period */
        i8253.period = period;
        i8253.periodset++;
        iunlock(&i8253);
    }
}
@

\subsection{[[Timer]] and [[Timers]]}

<<struct Timer>>=
struct Timer
{
    /* Public interface */
    // enum<timermode>
    int tmode;    /* See above */
    Tnano tns;    /* meaning defined by mode */ //nanosecond
    void  (*tf)(Ureg*, Timer*);
    void  *ta;
  
    /* Internal */
    Lock;
    Tval  tticks;   /* tns converted to ticks */
    Tval  twhen;    /* ns represented in fastticks */

    <<[[Timer extra fields>>
    };
@ 

<<enum timermode>>=
/*
 * fasttick timer interrupts
 */
enum timermode 
{
    Trelative,  /* timer programmed in ns from now */
    Tperiodic,  /* periodic timer, period in ns */
};
@ 

<<struct Timers>>=
struct Timers
{
    // list<Timer> (next = Timer.tnext)
    Timer *head;
    // extra
    Lock;
};
@ 

<<[[Timer extra fields>>=
// list<Timer> of Timers.head
Timer *tnext;
// ref<list<Timer>> Timers.head
Timers  *tt;    /* Timers queue this timer runs on */
@


<<function tadd>>=
static Tval
tadd(Timers *tt, Timer *nt)
{
    Timer *t, **last;

    /* Called with tt locked */
    assert(nt->tt == nil);
    switch(nt->tmode){
    case Trelative:
        if(nt->tns <= 0)
            nt->tns = 1;
        nt->twhen = fastticks(nil) + ns2fastticks(nt->tns);
        break;
    case Tperiodic:
        assert(nt->tns >= 100000);  /* At least 100 Âµs period */
        if(nt->twhen == 0){
            /* look for another timer at same frequency for combining */
            for(t = tt->head; t; t = t->tnext){
                if(t->tmode == Tperiodic && t->tns == nt->tns)
                    break;
            }
            if (t)
                nt->twhen = t->twhen;
            else
                nt->twhen = fastticks(nil);
        }
        nt->twhen += ns2fastticks(nt->tns);
        break;
    default:
        panic("timer: impossible");
        break;
    }

    for(last = &tt->head; t = *last; last = &t->tnext){
        if(t->twhen > nt->twhen)
            break;
    }
    nt->tnext = *last;
    *last = nt;
    nt->tt = tt;
    if(last == &tt->head)
        return nt->twhen;
    return 0;
}
@ 


<<function tdel>>=
static Tval
tdel(Timer *dt)
{
    Timer *t, **last;
    Timers *tt;

    tt = dt->tt;
    if (tt == nil)
        return 0; // possible? panic("impossible") would be better no?
    for(last = &tt->head; t = *last; last = &t->tnext){
        if(t == dt){
            assert(dt->tt);
            dt->tt = nil;
            *last = t->tnext;
            break;
        }
    }
    if(last == &tt->head && tt->head)
        return tt->head->twhen;
    return 0;
}
@ 

\subsection{[[timers]]}
<<global timers>>=
static Timers timers[MAXMACH];
@ 

<<function timeradd>>=
/* add or modify a timer */
void
timeradd(Timer *nt)
{
    Timers *tt;
    Tval when;

    /* Must lock Timer struct before Timers struct */
    ilock(nt);

    if(tt = nt->tt){
        ilock(tt);
        tdel(nt);
        iunlock(tt);
    }

    tt = &timers[m->machno];
    ilock(tt);
    when = tadd(tt, nt);
    if(when)
        timerset(when);
    iunlock(tt);
    iunlock(nt);
}
@ 

<<function timerdel>>=
void
timerdel(Timer *dt)
{
    Timers *tt;
    Tval when;

    ilock(dt);
    if(tt = dt->tt){
        ilock(tt);
        when = tdel(dt);
        if(when && tt == &timers[m->machno])
            timerset(tt->head->twhen);
        iunlock(tt);
    }
    iunlock(dt);
}
@ 


\subsection{Initialisation}

<<function timersinit>>=
void
timersinit(void)
{
    Timer *t;

    timersinited = true;
    todinit();

    t = malloc(sizeof(Timer));
    if(t == nil)
        error(Enomem);
    t->tmode = Tperiodic;
    t->tt = nil;
    t->tns = 1000000000/HZ;
    /*
     * T->tf == nil means the HZ clock for this processor.
     */
    t->tf = nil;
    timeradd(t);
}
@ 

\subsection{[[timerintr()]]}

<<interrupt callback timerintr>>=
// called via i8253clock
void
timerintr(Ureg *u, Tval)
{
    Timer *t;
    Timers *tt;
    uvlong when, now;
    int count, callhzclock;

    intrcount[m->machno]++;
    callhzclock = 0;
    tt = &timers[m->machno];
    now = fastticks(nil);
    if(now == 0)
        panic("timerintr: zero fastticks()");
    ilock(tt);
    count = Maxtimerloops;
    while((t = tt->head) != nil){
        /*
         * No need to ilock t here: any manipulation of t
         * requires tdel(t) and this must be done with a
         * lock to tt held.  We have tt, so the tdel will
         * wait until we're done
         */
        when = t->twhen;
        if(when > now){
            timerset(when);
            iunlock(tt);
            if(callhzclock)
                hzclock(u);
            return;
        }
        tt->head = t->tnext;
        assert(t->tt == tt);
        t->tt = nil;
        fcallcount[m->machno]++;
        iunlock(tt);
        if(t->tf)
            (*t->tf)(u, t);
        else
            callhzclock++;
        ilock(tt);
        if(t->tmode == Tperiodic)
            tadd(tt, t);
        if (--count <= 0) {
            count = Maxtimerloops;
            iprint("timerintr: probably stuck in while loop; "
                "scrutinise clock.c or use faster cycle "
                "counter\n");
        }
    }
    iunlock(tt);
}
@ 

\subsection{Clock callback}

<<function addclock0link>>=
Timer*
addclock0link(void (*f)(void), Tms ms)
{
    Timer *nt;
    Tval when;

    if(!timersinited)
        panic("addclock0link: timersinit not called yet");

    /* Synchronize to hztimer if ms is 0 */
    nt = malloc(sizeof(Timer));
    if(nt == nil)
        error(Enomem);
    if(ms == 0)
        ms = 1000/HZ;

    nt->tns = (Tnano)ms*1000000LL;
    nt->tmode = Tperiodic;
    nt->tt = nil;
    nt->tf = (void (*)(Ureg*, Timer*))f;

    // those clock callbacks are all done on the bootstrap processor
    //dupe: timeradd() but with forced processor number
    ilock(&timers[0]);
    when = tadd(&timers[0], nt);
    if(when)
        timerset(when);
    iunlock(&timers[0]);
    return nt;
}
@ 

\section{[[syssleep()]]}

\section{[[sysalarm()]]}
%related? tsleep, tsemacquire

\section{Time of day}


\chapter{IPC}
\minitoc

% of course can use fs to communicate between process :)

% see also network

<<systab ipc syscalls>>=
    [NOTIFY]    sysnotify,
    [NOTED]     sysnoted,

    [PIPE]      syspipe,

    [SEGATTACH] syssegattach,
    [SEGDETACH] syssegdetach,
    [SEGFREE]   syssegfree,
    [SEGFLUSH]  syssegflush,
    [SEGBRK]    syssegbrk,
@ 

\section{Notes (signals)}

\section{Pipes}

\section{Shared [[Segment]] and [[Sema]]phore}

% shared segment? and so semaphore? libc_thread?

\section{Network}

\chapter{Filesystem}
\minitoc

\section{[[devfs.c]]}

\section{Ramfs}

\section{Dossrv}


\chapter{Userspace System Programs}
\minitoc

\section{[[boot/boot]]}

<<boot.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

/*
 * we should inherit the standard fds all referring to /dev/cons,
 * but we're being paranoid.
 */
static void
opencons(void)
{
  close(0);
  close(1);
  close(2);
  open("/dev/cons", OREAD);
  open("/dev/cons", OWRITE);
  open("/dev/cons", OWRITE);
}

/*
 * init will reinitialize its namespace.
 * #ec gets us plan9.ini settings (*var variables).
 */
static void
bindenvsrv(void)
{
  bind("#ec", "/env", MREPL);
  bind("#e", "/env", MBEFORE|MCREATE);
  bind("#s", "/srv/", MREPL|MCREATE);
}

static void
swapproc(void)
{
    int fd;

    fd = open("#c/swap", OWRITE);
    if(fd < 0){
        warning("opening #c/swap");
        return;
    }
    if(write(fd, "start", 5) <= 0)
        warning("starting swap kproc");
    close(fd);
}

static void
execinit(void)
{
  int fd;

  bind_safe("#p", "/proc", MREPL); //devproc
  // used by rc and many programs, e.g. via open("#d/0")
  bind_safe("#d", "/fd", MREPL); //devdup

  bind_safe("/root", "/", MAFTER|MCREATE);
  bind_safe("/386/bin", "/bin", MREPL);
  bind_safe("/rc/bin", "/bin", MAFTER);

  bind_safe("#v", "/dev", MAFTER); //devvga
  bind_safe("#m", "/dev", MAFTER); //devmouse
  bind_safe("#P", "/dev", MAFTER);

  run("/bin/mouse", "ps2", nil);
  //this just need a regular vga driver
  //run("/bin/vga", "-l", "640x480x8", nil);
  //this need special drivers, such as the clgd424x.c in the kernel
  run("/bin/vga", "-l", "1024x768x8", nil);
  bind_safe("#i", "/dev", MAFTER);

  // for rio
  run("/bin/ramfs", "-m", "/mnt", nil);
  run("/bin/mkdir", "/mnt/temp", nil); // see thread(2), used to create pipes
  run("/bin/mkdir", "/mnt/wsys", nil);
  fd = open_safe("#c/hostowner", OWRITE);
  print_safe(fd, "pad");
  close(fd);

  // network
  bind_safe("#I", "/net", MREPL);
  bind_safe("#l0", "/net", MAFTER);

  run("/bin/rc", nil);
}


// called from boot$CONF.c:main()
void
boot(int argc, char *argv[])
{
  USED(argc);
  USED(argv);

  fmtinstall('r', errfmt);

  //At this point we should have #/ and #c setup by the kernel init0

  opencons();
  bindenvsrv();

  print("booooooooting...\n");

  rfork(RFNAMEG);

  connectlocal();

  swapproc();
  execinit();

  exits("failed to exec init");
}
@

<<local.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

int
connectlocal(void)
{
  int fd;
  
  bind_safe("#S", "/dev", MAFTER);

  fd = open_safe("/dev/sdC0/ctl", ORDWR);
  //TODO: use fdisk -p /dev/sdC1/data > /dev/sdC1/ctl
  //for sdC0: #prep -p /dev/sdC1/plan9 > /dev/sdC1/ctl
  print_safe(fd, "part dos 1 1000063");
  close_safe(fd);

  run("/boot/dossrv", nil);
  run("/boot/mount", "-c", "/srv/dos", "/root", "/dev/sdC0/dos", nil);
  
  return 0;
}
@

\section{[[root/init]]}
% user init, != kernel init

\section{The shell}




\chapter{Conclusion}

% already 900 pages ... so network in another volume

\section{Security}

<<systab security syscalls>>=
    [FAUTH]     sysfauth,
    [FVERSION]  sysfversion,
@ 

\section{Network}
% put also RPC and devmnt here?

\section{Graphics}

\appendix

\chapter{Debugging}

% what to do when have panic, e.g. when I mixed some fields
% and I got a pc error, how do I fix it? how do I find the relevant code?

% rdb.c

% see also printf section all this fmt stuff

% use sysnop (was called sysr1) to show example of debugging session?

% Ctrl-t Ctrl-t <debugcode>

\chapter{Profiling}

% devkprof.c?

\chapter{Error Managment}

% waserror(), nexterror(), etc
% =~ poor's man exn mechanism (=> improve C!!)

% syserrstr?

\chapter{Mini Libc}

\section{Pool allocation}

% set things from lib_core/libc/...?pool.c mainmem? imagmem?

\section{Printf and Fmt}

% see print.c which overrides functions defined in lib_core/libc/fmt/fmtlock.c 

\chapter{Extra Code}

#include "Kernel_extra.tex.nw"

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
up = user process

pc = program counter

spl = set priority level

ilock = interrupt safe version of lock (disable interruptions)

umb = upper memory block

RMAP = RAM map

PDB = page directory base

PTE = page table entry

tod = time of day

ap = application processor

EDF = Earliest Deadline First
http://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling

RPC = remote procedure call

EGRP = Environment group

FGRP = File descriptor Group (chans)

PGRP = Process Group (namespace)

VNO = Vector number (interrupt)

ISR = Interrupt Service Routine

TSC = Time Stamp Counter
http://en.wikipedia.org/wiki/Time_Stamp_Counter

intr = Interrupt (not INT, probably to avoid ambiguity with integer)

APIC = Advanded Programmable Interrupt Controller (a next gen 8259)

ACPI = Advanced Configuration & Power Interface

QID = unique identifier

\end{verbatim}
%cistrcmp= ??


\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}


% TECS, STEPS, MINIX, etc

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
