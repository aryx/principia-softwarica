\documentclass{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
% see also other newif in Macros.tex
\finaltrue\verbosefalse

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things :)
% - introduced syssema.c (found while going through Kernel_extra.tex.nw)
% - removed deadcode (e.g. field Proc.qlock, semalock)
% - moved code in init/user such as preboot vs boot vs init
% - introduced notion of IPC and Time
% - TODO better grouping of things in devcons.c, present together the Qxxx

%thx to codemap/codegraph:
% - see pad.txt#reorganization section

%history LP-ization:
% - skeleton; a not too bad TOC
% - put all content of files in the Extra section, via syncweb -lpize
% - split the files in chunks (for type, helpers, ...), using
%   my emacs macro, and prefixing the chunk with special names:
%    * function, global, struct, enum,
%    * method (for Dev), class??(for xxxdevtab?),
%    * syscall, interrupt callback, clock callback, kernel process, hook
%    * xxx decl, xxx.c forward decl, xxx.c debugging macro, xxx.c Exxx errors,
%    * [[xxx]] other fields, [[xxx]] extra fields, 
%   
% - SEMI distribute parts of the file before
% - TODO add figures (hand made)

%TODO:
% - lots of things could be reduces if C had better support for lists, hash
%   there are lots of duplicated code adding/removing stuff in list
%   (e.g. tdel(), tadd(), etc)

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
 \noweboptions{}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% for typedef forward decl, pragmas, func decl, extern decl, stats, #ifdef,
%  debugging macros

\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
The Plan9 Kernel
}\\
x86 (32 bits) edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 

\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

\dominitoc
\iffinal
\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real operating system\footnote{and in later books to also cover the
compiler, assembler, linker, debugger, windowing system, network
stack, etc}. Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.
% a concrete companion to "Computer systems: a programmer's pespective"

The choice of plan9 may not be obvious, but it is IMHO
the simplest and at the same time fairly complete operating system.
% as simple as possible, but not simpler
If you look at the screenshot in Figure~\ref{fig:X}, you'll see
many features:
\begin{itemize}
\item a screen with basic graphics and windows managment
\item multiple shells running multiple commands
\item a simple clock graphical application
\item a simple program communicating through the network
\end{itemize}

By comparison if you look at the screenshot in Figure~\ref{fig:Y}
you'll see that Plan9 in essence provides the similar core services
of MacOS, Linux or Windows.
% multi tasking, graphics, windows, IO, etc

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item Unix V6 (or its modern incarnation xv6) is too simple;
there is no graphics, no network
\item TECS, excellent for understanding hardware, assemblers,
and even compilers, but the operating part is really too simple
\item MMIX, same issue that for TECS
\item Alan's Kay STEPS project, far more ambitious as
the goal is to have a full system in 20 000 LOC, but not
finished yet.
\item Minix, bigger and does not provide a simple windowing
system as it relies on X11 (which is far more complicated than plan9
Rio windowing system)
\item Gnu/Linux, far far bigger. If you take the source code of glibc,
the Linux kernel, and X11, you'll get at
least 2 orders of magnitude more source code than Plan9, even though
Plan9 provides in essence the same core services. Of course
the Linux kernel contains thousands of specific drivers,
glibc handles many different architectures, and X11 can support
lots of graphic cards and all of those things could be discarded 
when presenting the core of those software, but their core
is still far bigger than Plan9 equivalent core.
\end{itemize}

\section{Getting started}

See \url{https://github.com/aryx/fork-plan9}
and \url{https://github.com/aryx/fork-kencc}.
%kencc install, fork-plan9 install

\section{Assumptions}

I assume you actually know a lot:
\begin{itemize}
\item C
% ref?
% see also comp.ps
\item an assembler
% ref?
% see also asm.ps
\item operating system (yep)
% ref?
\item familiarity with the PC architecture
\end{itemize}

This book is not an introduction to operating systems. The goal
of this book is to present in full details a kernel but we assume
you already have a vague idea of how an operating system
works and so that you are familiar with concepts such as 
virtual memory, critical regions, interrupts, system calls, etc.

\section{About this document}
#include "About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

I would like to acknowledge of course Plan9's authors who wrote
most of this book: Ken Thompson, Rob Pike, Dave Presotto, Phil
Winterbottom, Russ Cox, and many other people from Bell Labs.

Thanks also to Federic Balesteros who wrote a lengthy note about
Plan9's kernel that was very useful.

\chapter{Overview}
\minitoc

\section{Operating system principles}

An operating system is a meta-program: A program that manages other
programs.

It provides convenient abstractions of the hardware and multiplex
those hardware resources for the benefit of user programs:
\begin{itemize}
\item a virtual CPU, so that each process thinks it has all the CPU 
for himself
\item a virtual memory, so that each process thinks it has all memory
for himself
\item a virtual screen, so that each process thinks it has all the screen
for himself
% a file abstraction, continous even though spreaded on concrete disk
% a directory, also continous, even though spread over network and devices
\item a virtual storage (filesystem)
\item a virtual network (NFS)
\end{itemize}

\section{Operating system services}

\begin{verbatim}
 user point of view:
 - start the whole thing, first program!
 - process managment, shell, fork, exec, multi task
 - system calls, =~ APIs of user program
 - interrupt handling, =~ devices and also syscalls and preemptive multi task
 - IO operations, =~ devices and files
 - file managment, =~ filesystem
\end{verbatim}

<<sys.h>>=
#define	NOP		0
<<sys.h process syscalls>>
<<sys.h memory syscalls>>
<<sys.h file syscalls>>
<<sys.h namespace syscalls>>
<<sys.h time syscalls>>
<<sys.h ipc syscalls>>
<<sys.h concurrency syscalls>>
<<sys.h special file syscalls>>
<<sys.h security syscalls>>
#define	ERRSTR		40
@ 
<<sys.h process syscalls>>=
#define	RFORK		1
#define	EXEC		2
#define	EXITS		3
@

<<sys.h memory syscalls>>=
#define	BRK_		32
@ 

<<sys.h file syscalls>>=
#define	CREATE		6
#define	REMOVE		7
#define	OPEN		8
#define	CLOSE		9
#define	PREAD		10
#define	PWRITE		11
#define	SEEK		12
#define	STAT		14
#define	FSTAT		15
#define	WSTAT		16
#define	FWSTAT		17
#define	CHDIR		18
#define	FD2PATH		19
@

<<sys.h namespace syscalls>>=
#define	BIND		22
#define	MOUNT		23
#define	UNMOUNT		24
@

<<sys.h time syscalls>>=
#define	SLEEP		4
#define	ALARM		5
@

<<sys.h ipc syscalls>>=
#define	NOTIFY		30
#define	NOTED		31
#define	PIPE		21
#define	SEGATTACH	33
#define	SEGDETACH	34
#define	SEGFREE		35
#define	SEGFLUSH	36
#define	SEGBRK		37
@

<<sys.h concurrency syscalls>>=
#define	AWAIT		25
#define	RENDEZVOUS	26
#define	SEMACQUIRE	27
#define	SEMRELEASE	28
#define	TSEMACQUIRE	29
@

<<sys.h special file syscalls>>=
#define	DUP		    20
@

<<sys.h security syscalls>>=
#define	FVERSION	38
#define	FAUTH		39
@

\section{Plan9}

%plan9 specifics vs general os principles, e.g. namespace so have
% nice /dev/cons, /dev/draw, which enable easier network and graphics

% see 9.ps, excellent introduction to Plan9 advanced features

%TODO
%things plan9 make so much easier to implement/understand:
% tty
% X11, xterm
% nfs
% fuse
%
%Plan9 approach is good? abuse files? could use different API?
%For instance /dev/draw has a very specific format, so it's
%a bit abusing files.
%But at the same time one for sure needs to store things in files,
%so one need files, at which point you want to define the minimum of 
%concepts and so make files more generic => device can be files,
%but also pipes, etc, and so plan9 just push to its conclusion
%this idea.

% missing stuff in plan9:
% - shared library (help save some memory, but complicated)

\section{The machine}
%PC vs raspberry pi?

\section{C and Asm}

% Kencc extension: anon field. e.g. Lock; 

% the lock+0(FP) is intriguing

\section{Code organization}

% codemap and codegraph screenshot?

<<kernel basic includes>>=
#include <u.h>
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
@ 


<<dat.h>>=
#include "dat_forward.h"
#include "../port/portdat_forward.h"

<<enum miscsize_dat>>

// defines Lock (used inline in Mach in portdat_core.h so must be before)
#include "../port/portdat_concurrency.h"

// defines Conf, Mach
#include "dat_core.h"
#include "../port/portdat_core.h"

// defines Page
#include "dat_memory.h"
#include "../port/portdat_memory.h"

// defines Chan
#include "../port/portdat_files.h"

#include "dat_arch.h"

// defines Proc
#include "dat_processes.h"
#include "../port/portdat_processes.h"

// defines Cmd
#include "../port/portdat_misc.h"

// defines Uart
#include "dat_buses.h"
#include "../port/portdat_buses.h"

// defines keyboard queue
#include "../port/portdat_console.h"

<<constant AOUT_MAGIC>>

<<enum misc_dat>>

// could be put in lib.h
<<portdat.h macros>>

// convenient constants
<<enum miscsize_portdat>>

<<portdat.h pragmas>>
@

<<fns.h>>=
#include "../port/portfns_core.h"
#include "../port/portfns_concurrency.h"
#include "../port/portfns_memory.h"
#include "../port/portfns_files.h"
#include "../port/portfns_processes.h"
#include "../port/portfns_misc.h"
#include "../port/portfns_console.h"
#include "../port/portfns_buses.h"
#include "../port/portfns_devices.h"
#include "../port/portfns_security.h"
#include "../port/portfns_network.h"
#include "../port/portfns_init.h"

<<fns.h declarations>>
@


\section{Booting overview}
% kernel that creates first user process!
% introduce dichotomy kernel/user

% there is booting the kernel, booting the kernel environment,
%  and then booting the user environment, and finally booting user programs

% see also:
% http://arjunsreedharan.org/post/82710718100/kernel-101-lets-write-a-kernel

% steps:
% - hardware detection, populate Conf
% - initialization, populate allocators
% - create first process

% then user/preboot setup env, boot is responbile to mount root
% and then init assumes a root and setup last things.

\section{Memory overview}
% kernel vs user memory
% dynamic vs static (the static allocator so can bootstrap things)

%need precise physical map of memory
%
%with first empty page?, idtr, gdt, pdb intel, pte intel, 
%io RAM, vga ram,  then KZERO header, KTZERO, 
%code,  data with important globals like xlist, and array holes,
%palloc with pointer page, and then on top of that confmem area
%
%the data section of the kernel binary is as important as
%the code section. For the code section can also give name
%of procedures, and devtab (in data section) pointing back to it
%via the static "classes" in the data section again).
%
%need also precise virtual map of memory for regular process,
% actually for 2 processes
%
%need also precise virtual map of memory for first handcrafted process?
%

\section{Syscall overview}
% kernel vs user code

% sequence diagram?

% use an enum instead in sys.h? but then the script that generates
%  the .s in libc/ will be more complicated



% show example of generated assembly code
% maybe can even show an example where abuse sysnop so can see things :)

<<typedef Syscall>>=
typedef long Syscall(ulong*);
@

<<systab.h>>=
// used by systab.c but also by trap.c for certain codes
#include "/sys/src/libc/9syscall/sys.h"

<<typedef Syscall>>

extern Syscall *systab[];
extern int nsyscall;
extern char *sysctab[];
@


<<global systab>>=
Syscall *systab[] = {
    [NOP]     sysnop,
<<systab process syscalls>>
<<systab memory syscalls>>
<<systab file syscalls>>
<<systab namespace syscalls>>
<<systab time syscalls>>
<<systab ipc syscalls>>
<<systab concurrency syscalls>>
<<systab special file syscalls>>
<<systab security syscalls>>
    [ERRSTR]    syserrstr,
};
int nsyscall = nelem(systab);
@

<<syscall nop>>=
long
sysnop(ulong*)
{
    //checkpagerefs();
    return 0;
}
@ 



\chapter{Core Data Structures}
\minitoc

% mini libc: bool, int, strings, unicode, etc

\section{[[Conf]] and [[conf]]}

<<struct Conf>>=
struct Conf
{
    ulong nmach;    /* processors */
    ulong nproc;    /* processes */
    Confmem mem[4];   /* physical memory */

    <<[[Conf]] extra fields>>
  
    struct ArchConf;
};
@ 

%    // in bcm/ it's mem[1], important? why 4?

<<global conf>>=
Conf conf;
@ 

<<globals confname and confvar>>=
// conf (boot) parameters *e.g. { "*kernelpercent*" => "60" }
// hash<string, string>
char *confname[MAXCONF];
char *confval[MAXCONF];
// Hashtbl.length(confname)
int nconf;
@ 

<<constant MAXCONF>>=
#define MAXCONF         64
@ 

<<function getconf>>=
char* getconf(char *name)
{
        int i;
        for(i = 0; i < nconf; i++)
                if(cistrcmp(confname[i], name) == 0)
                        return confval[i];
        return nil;
}
@



<<struct Confmem>>=
// memory "bank"
struct Confmem
{
    ulong base; // phys?
    ulong npage;
  
    ulong kbase; // phys?
    ulong klimit; // phys?
};
@ 


\section{[[Mach]] and [[m]]}

<<struct Mach>>=
struct Mach
{
    int machno;     /* physical id of processor (KNOWN TO ASSEMBLY) */
    <<[[Mach]] second field>>
  
    // ref<Proc>
    Proc* proc;     /* current process on this processor */

    <<[[Mach]] stat fields>>

    <<[[Mach]] other fields>>

    struct ArchMach;
  
    // must be at the end of the structure!
    int stack[1];
};
@ 

<<global m>>=
Mach *m;
@ 


<<global machp>>=
/*
 * Each processor sees its own Mach structure at address MACHADDR.
 * However, the Mach structures must also be available via the per-processor
 * MMU information array machp, mainly for disambiguation and access to
 * the clock which is only maintained by the bootstrap processor (0).
 */
// array<ref<Mach>>, MAXMACH is defined in 386/mem.h
Mach* machp[MAXMACH];
@ 

<<macro MACHP>>=
#define MACHP(n)  (machp[n])
@


<<struct Active>>=
struct Active
{
    //array<bool>
    int machs;      /* bitmap of active CPUs */

    int exiting;    /* shutdown */
    int ispanic;    /* shutdown in response to a panic */
  
    // 386 specific?
    int thunderbirdsarego;  /* lets the added processors continue to schedinit */
    int rebooting;    /* just idle cpus > 0 */
  
    // extra
    Lock;
};
@ 

<<global active>>=
struct Active active;
@ 



<<struct ArchMach>>=
struct ArchMach {
    <<[[ArchMach]] other fields>>
};
@ 

\section{[[Proc]] and [[up]]}

<<struct Proc>>=
// the most important fields are set by newproc()
struct Proc
{
//--------------------------------------------------------------------
// Assembly requirements, Low level, have to be first
//--------------------------------------------------------------------
    <<[[Proc]] assembly fields>>
//--------------------------------------------------------------------
// State
//--------------------------------------------------------------------
    <<[[Proc]] state fields>>
//--------------------------------------------------------------------
// Memory
//--------------------------------------------------------------------
    <<[[Proc]] memory fields>>
//--------------------------------------------------------------------
// Scheduling
//--------------------------------------------------------------------
    <<[[Proc]] scheduling fields>>
//--------------------------------------------------------------------
// Files
//--------------------------------------------------------------------
    <<[[Proc]] files fields>>
//--------------------------------------------------------------------
// Notes
//--------------------------------------------------------------------
    <<[[Proc]] notes fields>>
//--------------------------------------------------------------------
// Process hierarchy
//--------------------------------------------------------------------
    <<[[Proc]] hierarchy fields>>
//--------------------------------------------------------------------
// Synchronization
//--------------------------------------------------------------------
    <<[[Proc]] synchronization fields>>
//--------------------------------------------------------------------
// Error managment
//--------------------------------------------------------------------
    <<[[Proc]] error managment fields>>
//--------------------------------------------------------------------
// Stats, profiling
//--------------------------------------------------------------------
    <<[[Proc]] stats and profiling fields>>
//--------------------------------------------------------------------
// Debugging
//--------------------------------------------------------------------
    <<[[Proc]] debugging fields>>
//--------------------------------------------------------------------
// For debugger
//--------------------------------------------------------------------
    <<[[Proc]] debugger fields>>
//--------------------------------------------------------------------
// Other
//--------------------------------------------------------------------
    <<[[Proc]] other fields>>
//--------------------------------------------------------------------
// Extra
//--------------------------------------------------------------------
    <<[[Proc]] extra fields>>
};
@ 

<<[[Proc]] state fields>>=
ulong pid;

// enum<procstate>
int state; // Dead, Queuing, etc,
@ 

<<enum procstate>>=
/* Process states, Proc.state */
enum procstate
{
    Dead = 0,
    Running,
    <<enum procstate cases>>
};
@ 


<<[[ArchMach]] other fields>>=
Proc* externup;   /* extern register Proc *up */
@

<<macro up>>=
// up = user process, MACHADDR is defined in 386/mem.h
#define up  (((Mach*)MACHADDR)->externup)
@

%//TODO: mv in 386/ TODO: why not m->externup? m is not valid?


\section{[[Chan]]}

<<struct Chan>>=
struct Chan
{
    ushort  type; // idx in devtab?
    Qid qid;
    vlong offset;     /* in fd */
    ushort  mode;     /* read/write */

    <<[[Chan]] other fields>>

    // extra
    <<[[Chan]] extra fields>>
};
@ 

% rob pike: "q for unique"
% qid =~ inode =~ internal representation of a file
<<struct Qid>>=
struct Qid
{
  // note that this is not a string, but an int! it's kind of an inode?
  uvlong  path;
  // for cache invalidation
  ulong vers;
  // enum<qidtype>
  uchar type;
};
@ 


<<enum qidtype>>=
/* bits in Qid.type */
enum qidtype {
  QTFILE = 0x00,    /* plain file */
  QTDIR = 0x80,    /* type bit for directories */
  QTMOUNT = 0x10,    /* type bit for mounted channel */

  QTAUTH = 0x08,    /* type bit for authentication file */
  QTAPPEND = 0x40,    /* type bit for append only files */
  QTEXCL = 0x20,    /* type bit for exclusive use files */
};
@ 

\section{[[Dev]] and [[devtab]]}


<<struct Dev>>=
struct Dev
{
    int dc; // dev character code, e.g. '/' (devroot), 'e' (devenv), ...
    char* name;
    
    void  (*reset)(void);
    void  (*init)(void);
    void  (*shutdown)(void);
    Chan* (*attach)(char*);

    Walkqid*(*walk)(Chan*, Chan*, char**, int);

    void  (*create)(Chan*, char*, int, ulong);
    void  (*remove)(Chan*);

    Chan* (*open)(Chan*, int);
    void  (*close)(Chan*);
    long  (*read)(Chan*, void*, long, vlong);
    long  (*write)(Chan*, void*, long, vlong);

    Block* (*bread)(Chan*, long, ulong);
    long  (*bwrite)(Chan*, Block*, ulong);

    int (*stat)(Chan*, uchar*, int);
    int (*wstat)(Chan*, uchar*, int);

    void  (*power)(bool);  /* power mgt: power(1) => on, power (0) => off */
    int (*config)(int, char*, DevConf*);  /* returns nil on error */

    <<[[Dev]] other fields>>
};
@ 

<<global devtab>>=
Dev** devtab = 0;
@

% ex of conf_devtab:
%Dev* conf_devtab[]={
%	&rootdevtab,
%	&consdevtab,
%       ...

\section{[[PCArch]] and [[arch]]}

<<struct PCArch>>=
struct PCArch
{
  char* id;

  int (*ident)(void);   /* this should be in the model */
  void  (*reset)(void);   /* this should be in the model */

  int (*serialpower)(int);  /* 1 == on, 0 == off */
  int (*modempower)(int); /* 1 == on, 0 == off */

  // interrupts
  void  (*intrinit)(void);
  int (*intrenable)(Vctl*);
  int (*intrvecno)(int);
  int (*intrdisable)(int);
  void  (*introff)(void);
  void  (*intron)(void);

  // clock, timer
  void  (*clockenable)(void);
  uvlong  (*fastclock)(uvlong*);
  void  (*timerset)(uvlong);

  void  (*resetothers)(void); /* put other cpus into reset */
};
@ 

% could add cycles and cmpswap here? and also pcmspecial, fps?

<<global arch>>=
PCArch* arch;
@ 

<<global archgeneric>>=
PCArch archgeneric = {
    .id=        "generic",
    .ident=     0,
    .reset=     archreset,
    .serialpower=   unimplemented,
    .modempower=    unimplemented,
    
    // i8259
    .intrinit=  i8259init,
    .intrenable=    i8259enable,
    .intrvecno= i8259vecno,
    .intrdisable=   i8259disable,
    .intron=    i8259on,
    .introff=   i8259off,
    
    // i8253
    .clockenable=   i8253enable,
    .fastclock= i8253read,
    .timerset=  i8253timerset,
};
@

<<function unimplemented>>=
static int
unimplemented(int)
{
    return 0;
}
@


% SMP is more complex arch, archmp

\chapter{Concurrency}
\minitoc

% when think about concurrency in userspace program, have
% shared memory of multiple program threads and need to mediate
% access to shared data via semaphore/lock/whatever.

% well OS is a kind of program and it has also mutiple
% "threads" (different processors) and lots of shared data
% (kernel meta data about user processes and its own data)
% (which is why lots of the concurrency issues arised first
% for OS programmers long before the other)

<<systab concurrency syscalls>>=
    [AWAIT]     sysawait,
    [RENDEZVOUS]    sysrendezvous,

    [SEMACQUIRE]    syssemacquire,
    [SEMRELEASE]    syssemrelease,
    [TSEMACQUIRE]   systsemacquire,
@ 

\section{Critical regions}

\begin{verbatim}
 There are different code/data "regions": 
 - user code/data
 - kernel data about user process
 - kernel data
 - kernel init code
 - kernel code of syscalls (soft interrupt), acting on behalf of user process
 - kernel code of interrupt handlers (hard interrupt).
 - kernel code of kernel processes (e.g. the alarm kernel process)

 There is no mutual exclusion need between user and kernel code. 
 Same for init code as only one processor is used during the
 uninterrupted sequential initialization.
 There is also no need between different user processes.

 For the kernel code one wants mutual exclusion because of possible race 
 on shared data structures between the syscalls themselves when run
 on different processors (or even when run on one processor as one syscall
 can be interrupted causing a scheduling that will then lead later to
 another syscall), but also between the syscalls and interrupts.
 The flow of control on one processor can be 
  - User -> Syscall, 
  - User -> Interrupt,
  - or even User -> Syscall -> Interrupt
  - one can even have User -> Syscall -> Interrupt -> Interrupt!!

 This is on one processor. Multiple processors lead to more combinations
 where 2 processors can run at the same time 2 interrupt handlers for instance.
 
 One must take care when using locks inside interrupts as one can deadlock
 if the same lock was used in the enclosing syscall (hence ilock/iunlock)

 For protecting kernel syscall code from interrupt kernel code: splhi(), splo()
 For very small critical region: taslock
 For bigger region, or when have lots of contention on a lock: qlock

\end{verbatim}

\section{[[tas()]]}
<<function cmpswap and default implementation>>=
/*
 * 386 has no compare-and-swap instruction.
 * Run it with interrupts turned off instead.
 */
// used to be static, but now shared between arch.c and devarch.c
int
cmpswap386(long *addr, long old, long new)
{
    int r, s;

    s = splhi();
    if(r = (*addr == old))
        *addr = new;
    splx(s);
    return r;
}

int (*cmpswap)(long*, long, long) = cmpswap386;
@



<<function tas>>=
TEXT tas(SB), $0
        MOVL    $0xDEADDEAD, AX
        MOVL    lock+0(FP), BX
        // Exchange AX to lock->key. So:
        //  - if the lock was not held, lock->key was 0 and so AX will be 0
        //     and lock->key will be 0xdeaddead
        //  - if the lock was held, AX will be 0xdeaddead and lock->key will
        //    still be 0xdeaddead.
        XCHGL   AX, (BX)                        /* lock->key */
        RET
@ 

% see als cmpswap in arch? and used for semaphore for instance

\section{[[Lock]]}

<<struct Lock>>=
struct Lock
{
    ulong key; // 0 when unset, 0xDEADDEAD when acquired, could be a bool

    // option<ref<Proc>>, None when key = 0
    Proc  *p; // the process locking should be the same unlocking

    // virt_addr?
    uintptr pc; // for debugging

    <<[[Lock]] ilock fields>>
    <<[[Lock]] other fields>>
    <<[[Lock]] debugging fields>>
};
@ 

<<[[Proc]] debugging fields>>=
Lock* lastlock;
@

<<[[Proc]] other fields>>=
// As long as the current process hold locks (to kernel data structures),
// we will not schedule another process in unlock(); only the last unlock
// will eventually cause a rescheduling.
Ref nlocks;   /* number of locks held by proc */
@ 

\ifallcode
<<lock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
        l->lockcycles = -lcycles();
#endif
@ 
\fi

<<function lock>>=
int
lock(Lock *l)
{
    int i;
    ulong pc;

    pc = getcallerpc(&l);

    lockstats.locks++;
    if(up)
        inccnt(&up->nlocks);    /* prevent being scheded */
    if(tas(&l->key) == 0){
        if(up)
            up->lastlock = l;
        l->pc = pc;
        l->p = up;
        l->isilock = false;
        //TODO: not setting l->m = ??
<<lock ifdef LOCKCYCLES>>

        return 0;
    }
    if(up)
        deccnt(&up->nlocks);

    lockstats.glare++;
    for(;;){
        lockstats.inglare++;
        i = 0;
        while(l->key){
            if(conf.nmach < 2 && up && up->edf && (up->edf->flags & Admitted)){
                /*
                 * Priority inversion, yield on a uniprocessor; on a
                 * multiprocessor, the other processor will unlock
                 */
                print("inversion %#p pc %#lux proc %lud held by pc %#lux proc %lud\n",
                    l, pc, up ? up->pid : 0, l->pc, l->p ? l->p->pid : 0);
                up->edf->d = todget(nil);   /* yield to process with lock */
            }
            if(i++ > 100000000){
                i = 0;
                lockloop(l, pc);
            }
        }
        if(up)
            inccnt(&up->nlocks);
        if(tas(&l->key) == 0){
            if(up)
                up->lastlock = l;
            l->pc = pc;
            l->p = up;
            l->isilock = false;
<<lock ifdef LOCKCYCLES>>
            return 1;
        }
        if(up)
            deccnt(&up->nlocks);
    }
}
@ 

\ifallcode
<<unlock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumlockcycles += l->lockcycles;
    if(l->lockcycles > maxlockcycles){
        maxlockcycles = l->lockcycles;
        maxlockpc = l->pc;
    }
#endif
@ 
\fi

<<function unlock>>=
void
unlock(Lock *l)
{
<<unlock ifdef LOCKCYCLES>>

    if(l->key == 0)
        print("unlock: not locked: pc %#p\n", getcallerpc(&l));
    if(l->isilock)
        print("unlock of ilock: pc %lux, held by %lux\n", getcallerpc(&l), l->pc);
    if(l->p != up)
        print("unlock: up changed: pc %#p, acquired at pc %lux, lock p %#p, unlock up %#p\n", getcallerpc(&l), l->pc, l->p, up);

    l->m = nil;
    l->key = 0;
    // for processor caches, to ensure the lock value is seen by other
    // processors so that if they were doing while(l->key) { ... } they
    // can finally exit the while loop.
    coherence();

    if(up && deccnt(&up->nlocks) == 0 && up->delaysched && islo()){
        /*
         * Call sched if the need arose while locks were held
         * But, don't do it from interrupt routines, hence the islo() test
         */
        sched();
    }
}
@ 

<<function canlock>>=
int
canlock(Lock *l)
{
    if(up)
        inccnt(&up->nlocks);
    if(tas(&l->key)){
        if(up)
            deccnt(&up->nlocks);
        return 0;
    }

    if(up)
        up->lastlock = l;
    l->pc = getcallerpc(&l);
    l->p = up;
    l->m = MACHP(m->machno);
    l->isilock = false;
<<lock ifdef LOCKCYCLES>>
    return 1;
}
@ 


\section{Interrupt [[Lock]]}
% can formalize a checking rule? if access any field
% accessed from a xxxintr, then need to use ilock

<<[[Mach]] second field>>=
    // must be second field at 0x04, used by splhi()
    ulong splpc;      /* pc of last caller to splhi */
@ 

<<function splhi>>=
// int   splhi(void);
TEXT splhi(SB), $0
shi:
        PUSHFL
        POPL    AX
        TESTL   $0x200, AX
        JZ      alreadyhi
        MOVL    $(MACHADDR+0x04), CX            /* save PC in m->splpc */
        MOVL    (SP), BX
        MOVL    BX, (CX)
alreadyhi:
        CLI
        RET
@ 


<<function spllo>>=
// int   spllo(void);
TEXT spllo(SB), $0
slo:
        PUSHFL
        POPL    AX
        TESTL   $0x200, AX
        JNZ     alreadylo
        MOVL    $(MACHADDR+0x04), CX            /* clear m->splpc */
        MOVL    $0, (CX)
alreadylo:
        STI
        RET
@ 


<<function splx>>=
// void    splx(int);
TEXT splx(SB), $0
        MOVL    s+0(FP), AX
        TESTL   $0x200, AX
        JNZ     slo
        JMP     shi
@ 


<<function islo>>=
// bool islo(void);
TEXT islo(SB), $0
        PUSHFL
        POPL    AX
        ANDL    $0x200, AX                      /* interrupt enable flag */
        RET
@ 


<<[[Lock]] ilock fields>>=
bool_ushort isilock; // false when from lock(), true when from ilock()
ulong sr; // saved priority level when using ilock() to restore in iunlock()
@ 

<<[[Proc]] debugging fields>>=
Lock  *lastilock; /* debugging */
@ 

<<[[Mach]] other fields>>=
int ilockdepth;
@ 

<<function ilock>>=
// To provide mutual exclusion with interrupt code and avoiding deadlock.
// By using splhi() we disable interrupts while running the critical region
// code.
void
ilock(Lock *l)
{
    ulong x;
    ulong pc;

    pc = getcallerpc(&l);
    lockstats.locks++;

    x = splhi();
    if(tas(&l->key) != 0){
        lockstats.glare++;
        /*
         * Cannot also check l->pc, l->m, or l->isilock here
         * because they might just not be set yet, or
         * (for pc and m) the lock might have just been unlocked.
         */
        for(;;){
            lockstats.inglare++;
            splx(x);
            while(l->key)
                ;
            x = splhi();
            if(tas(&l->key) == 0)
                goto acquire;
        }
    }
acquire:
    m->ilockdepth++;
    if(up)
        up->lastilock = l;
    l->sr = x;
    l->pc = pc;
    l->p = up;
    l->isilock = true;
        //TODO: why not just l->m = m? 
    l->m = MACHP(m->machno);
<<lock ifdef LOCKCYCLES>>
}
@ 

\ifallcode
<<iunlock ifdef LOCKCYCLES>>=
#ifdef LOCKCYCLES
    l->lockcycles += lcycles();
    cumilockcycles += l->lockcycles;
    if(l->lockcycles > maxilockcycles){
        maxilockcycles = l->lockcycles;
        maxilockpc = l->pc;
    }
    if(l->lockcycles > 2400)
        ilockpcs[n++ & 0xff]  = l->pc;
#endif
@ 
\fi

<<function iunlock>>=
void
iunlock(Lock *l)
{
    ulong sr;

<<iunlock ifdef LOCKCYCLES>>
    if(l->key == 0)
        print("iunlock: not locked: pc %#p\n", getcallerpc(&l));
    if(!l->isilock)
        print("iunlock of lock: pc %#p, held by %#lux\n", getcallerpc(&l), l->pc);
    if(islo())
        print("iunlock while lo: pc %#p, held by %#lux\n", getcallerpc(&l), l->pc);

    sr = l->sr;
    l->m = nil;
    l->key = 0;
    coherence();
    m->ilockdepth--;
    if(up)
        up->lastilock = nil;
    splx(sr);
}
@ 

\section{[[QLock]]}

<<struct QLock>>=
// Kernel basic lock with Queue (renamed to avoid ambiguity with libc.h Qlock)
struct KQLock
{
    bool  locked;   /* flag */
  
    // list<ref<Proc>> (next = Proc.qnext)
    Proc  *head;    /* next process waiting for object */
    // list<ref<Proc>> (direct access to tail, queue)
    Proc  *tail;    /* last process waiting for object */
  
    uintptr qpc;    /* pc of the holder */ // for debugging?
  
    Lock  use;    /* to access Qlock structure */
};
@ 

<<[[Proc]] extra fields>>=
// list<ref<Proc>> KQlock.head or RWLock.head
Proc  *qnext;   /* next process on queue for a QLock */
@ 

<<enum procstate cases>>=
Queueing, // see qlock()
@

<<function qlock>>=
void
qlock(QLock *q)
{
    Proc *p;

    if(m->ilockdepth != 0)
        print("qlock: %#p: ilockdepth %d\n", getcallerpc(&q), m->ilockdepth);
    if(up != nil && up->nlocks.ref)
        print("qlock: %#p: nlocks %lud\n", getcallerpc(&q), up->nlocks.ref);

    if(q->use.key == 0x55555555)
        panic("qlock: q %#p, key 5*\n", q);
    lock(&q->use);
    rwstats.qlock++;
    if(!q->locked) {
        q->locked = true;
        q->qpc = getcallerpc(&q);
        unlock(&q->use);
        return;
    }
    if(up == 0)
        panic("qlock");
    rwstats.qlockq++;
    p = q->tail;
    if(p == 0)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = nil;
    up->state = Queueing;
    up->qpc = getcallerpc(&q);
    unlock(&q->use);
    sched();
    q->qpc = getcallerpc(&q);
}
@ 


<<function canqlock>>=
int
canqlock(QLock *q)
{
    if(!canlock(&q->use))
        return 0;
    if(q->locked){
        unlock(&q->use);
        return 0;
    }
    q->locked = true;
    q->qpc = getcallerpc(&q);
    unlock(&q->use);
    return 1;
}
@ 

<<function qunlock>>=
void
qunlock(QLock *q)
{
    Proc *p;

    lock(&q->use);
    if (q->locked == false)
        print("qunlock called with qlock not held, from %#p\n",
            getcallerpc(&q));
    p = q->head;
    if(p){
        q->head = p->qnext;
        if(q->head == 0)
            q->tail = nil;
        unlock(&q->use);
        ready(p);
        return;
    }
    q->locked = false;
    q->qpc = 0;
    unlock(&q->use);
}
@ 

\section{[[RWLock]]}

<<struct RWlock>>=
struct RWlock
{
    int readers;  /* number of readers */
    bool writer;   /* number of writers */
  
    // list<ref<Proc>> (next = Proc.qnext)
    Proc  *head;    /* list of waiting processes */
    // list<ref<Proc>> (direct access to tail, queue)
    Proc  *tail;
    // option<ref<Proc>> 
    Proc  *wproc;   /* writing proc */
  
    uintptr wpc;    /* pc of writer */
  
    Lock  use;
};
@ 

<<enum procstate cases>>=
QueueingR, // see rlock()
@

<<function rlock>>=
void
rlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    rwstats.rlock++;
    if(q->writer == 0 && q->head == nil){
        /* no writer, go for it */
        q->readers++;
        unlock(&q->use);
        return;
    }

    rwstats.rlockq++;
    p = q->tail;
    if(up == nil)
        panic("rlock");
    if(p == 0)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = nil;
    up->state = QueueingR;
    unlock(&q->use);
    sched();
}
@ 

<<function runlock>>=
void
runlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    p = q->head;
    if(--(q->readers) > 0 || p == nil){
        unlock(&q->use);
        return;
    }

    /* start waiting writer */
    if(p->state != QueueingW)
        panic("runlock");
    q->head = p->qnext;
    if(q->head == 0)
        q->tail = nil;
    q->writer = true;
    unlock(&q->use);
    ready(p);
}
@ 

<<enum procstate cases>>=
QueueingW, // see wlock()
@

<<function wlock>>=
void
wlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    rwstats.wlock++;
    if(q->readers == 0 && q->writer == 0){
        /* noone waiting, go for it */
        q->wpc = getcallerpc(&q);
        q->wproc = up;
        q->writer = true;
        unlock(&q->use);
        return;
    }

    /* wait */
    rwstats.wlockq++;
    p = q->tail;
    if(up == nil)
        panic("wlock");
    if(p == nil)
        q->head = up;
    else
        p->qnext = up;
    q->tail = up;
    up->qnext = nil;
    up->state = QueueingW;
    unlock(&q->use);
    sched();
}
@ 


<<function wunlock>>=
void
wunlock(RWlock *q)
{
    Proc *p;

    lock(&q->use);
    p = q->head;
    if(p == nil){
        q->writer = false;
        unlock(&q->use);
        return;
    }
    if(p->state == QueueingW){
        /* start waiting writer */
        q->head = p->qnext;
        if(q->head == nil)
            q->tail = nil;
        unlock(&q->use);
        ready(p);
        return;
    }

    if(p->state != QueueingR)
        panic("wunlock");

    /* waken waiting readers */
    while(q->head != nil && q->head->state == QueueingR){
        p = q->head;
        q->head = p->qnext;
        q->readers++;
        ready(p);
    }
    if(q->head == nil)
        q->tail = nil;
    q->writer = false;
    unlock(&q->use);
}
@ 


<<function canrlock>>=
/* same as rlock but punts if there are any writers waiting */
int
canrlock(RWlock *q)
{
    lock(&q->use);
    rwstats.rlock++;
    if(q->writer == 0 && q->head == nil){
        /* no writer, go for it */
        q->readers++;
        unlock(&q->use);
        return 1;
    }
    unlock(&q->use);
    return 0;
}
@ 

\section{Atomic [[Ref]]erences}

<<struct Ref>>=
// For reference counting shared things (e.g. a Page)
struct Ref
{
    long  ref;
    Lock;
};
@ 


<<function incref>>=
long
incref(Ref *r)
{
    long x;

    lock(r);
    x = ++r->ref;
    unlock(r);
    return x;
}
@ 


<<function decref>>=
long
decref(Ref *r)
{
    long x;

    lock(r);
    x = --r->ref;
    unlock(r);
    if(x < 0)
        panic("decref pc=%#p", getcallerpc(&r));

    return x;
}
@ 



<<function inccnt>>=
// See also ref.c incref() and decref(), but we can't use them here as they
// themselves rely on lock() and unlock(). 
static void
inccnt(Ref *r)
{
    _xinc(&r->ref);
}
@ 


<<function deccnt>>=
static int
deccnt(Ref *r)
{
    int x;

    x = _xdec(&r->ref);
    if(x < 0)
        panic("deccnt pc=%#p", getcallerpc(&r));
    return x;
}
@ 

<<function _xinc>>=
/* void _xinc(long*); */
TEXT _xinc(SB), $0
        MOVL    l+0(FP), AX
        LOCK;   INCL 0(AX)
        RET
@ 


<<function _xdec>>=
/* long _xdec(long*); */
TEXT _xdec(SB), $0
        MOVL    l+0(FP), BX
        XORL    AX, AX
        LOCK;   DECL 0(BX)
        JLT     _xdeclt
        JGT     _xdecgt
        RET
_xdecgt:
        INCL    AX
        RET
_xdeclt:
        DECL    AX
        RET
@ 


<<struct Counter>>=
typedef struct Ref Counter;
@ 


\section{Synchronization}
% different from critical regions

% see sleep.ps in plan9 documents

\section{[[Rendez]]-vous}
% sleep/wakeup?

<<struct Rendez>>=
struct Rendez
{
    // ??
    Proc  *p;
    Lock;
};
@ 


\section{[[Sema]]phore}
% those are actually used for user-level locks, see libcore/libc/port/lock.c

<<struct Sema>>=
// user level semaphores, used to implement user-level lock, 
// see libc/port/lock.c
struct Sema
{
    long  *addr; // value stored in user space!
    int waiting;
  
    //list<Sema> of Segment.sema
    Sema  *next;
    Sema  *prev;

    Rendez;
};
@ 


\chapter{Memory}
\minitoc

<<systab memory syscalls>>=
    [BRK_]      sysbrk_,
@ 

\section{Overview}
% kernel vs user memory

\section{Pool allocation}

\section{[[xalloc()]]}

\section{Kernel malloc}

\section{User malloc}
%actually brk

\section{Virtual memory}

\section{[[Page]]}

\section{[[Segment]]}

\section{Swapping}

\section{[[sysbrk()]]}


\chapter{Interrupts}
\minitoc

<<struct Vctl>>=
struct Vctl {

    bool isintr;     /* interrupt or fault/trap */
    int irq;
  
    void  (*f)(Ureg*, void*); /* handler to call */
    void* a;      /* argument to call it with */
  
    char  name[KNAMELEN];   /* of driver */
    int tbdf; //?
  
    // interrupt service routine
    int (*isr)(int);    /* get isr bit for this irq */
    int (*eoi)(int);    /* eoi */
  
    // extra
  
    // list<Vctl> of vctl[vno], xalloc'ed (should not have that many so ok)
    Vctl* next;     /* handlers on this vector */
};
@

<<enum vector>>=
enum {
    VectorNMI = 2,    /* non-maskable interrupt */
    VectorBPT = 3,    /* breakpoint */
    VectorUD  = 6,    /* invalid opcode exception */
    VectorCNA = 7,    /* coprocessor not available */
    Vector2F  = 8,    /* double fault */
    VectorCSO = 9,    /* coprocessor segment overrun */
    VectorPF  = 14,   /* page fault */
    Vector15  = 15,   /* reserved */
    VectorCERR  = 16,   /* coprocessor error */
  
    VectorPIC = 32,   /* external i8259 interrupts */
    VectorLAPIC = VectorPIC+16, /* local APIC interrupts */

    //!!! int 64 = way to jump in plan9 OS !!!
    // VectorSYSCALL = 64, in mem.h because used by Assembly too
  
    VectorAPIC  = 65,   /* external APIC interrupts */
    MaxVectorAPIC = 255,
};
@

<<enum irq>>=
enum {
    IrqCLOCK  = 0,
    IrqKBD    = 1,
    IrqUART1  = 3,
    IrqUART0  = 4,
    IrqPCMCIA = 5,
    IrqFLOPPY = 6,
    IrqLPT    = 7,
    IrqIRQ7   = 7,
    IrqAUX    = 12,   /* PS/2 port */
    IrqIRQ13  = 13,   /* coprocessor on 386 */
    IrqATA0   = 14,
    IrqATA1   = 15,
    MaxIrqPIC = 15,
  
    IrqLINT0  = 16,   /* LINT[01] must be offsets 0 and 1 */
    IrqLINT1  = 17,
    IrqTIMER  = 18,
    IrqERROR  = 19,
    IrqPCINT  = 20,
    IrqSPURIOUS = 31,   /* must have bits [3-0] == 0x0F */

    MaxIrqLAPIC = 31,
};
@

\section{Exceptions}

\section{Hardware interrupts}

\section{Software interrupts}

<<constant MAXSYSARG>>=
// used in Proc
MAXSYSARG = 5, /* for mount(fd, afd, mpt, flag, arg) */
@

\chapter{Processes}
\minitoc

<<systab process syscalls>>=
    [RFORK]     sysrfork,
    [EXEC]      sysexec,
    [EXITS]     sysexits,
@ 

\section{Overview}

\section{[[Proc]]}

\section{Context switch}

\section{Clock interrupt}

<<struct I8253>>=
struct I8253
{
    ulong   period;     /* current clock period */
    bool    enabled;

    uvlong  hz;

    ushort  last;       /* last value of clock 1 */
    uvlong  ticks;      /* cumulative ticks of counter 1 */

    ulong   periodset;

    // extra
    Lock;
};
@


<<global i8253>>=
I8253 i8253;
@

<<function i8253init>>=
void
i8253init(void)
{
    int loops, x;

    ioalloc(T0cntr, 4, 0, "i8253");
    ioalloc(T2ctl, 1, 0, "i8253.cntr2ctl");

    i8253.period = Freq/HZ;

    /*
     *  enable a 1/HZ interrupt for providing scheduling interrupts
     */
    outb(Tmode, Load0|Square);
    outb(T0cntr, (Freq/HZ));    /* low byte */
    outb(T0cntr, (Freq/HZ)>>8); /* high byte */

    /*
     *  enable a longer period counter to use as a clock
     */
    outb(Tmode, Load2|Square);
    outb(T2cntr, 0);        /* low byte */
    outb(T2cntr, 0);        /* high byte */
    x = inb(T2ctl);
    x |= T2gate;
    outb(T2ctl, x);
    
    /*
     * Introduce a little delay to make sure the count is
     * latched and the timer is counting down; with a fast
     * enough processor this may not be the case.
     * The i8254 (which this probably is) has a read-back
     * command which can be used to make sure the counting
     * register has been written into the counting element.
     */
    x = (Freq/HZ);
    for(loops = 0; loops < 100000 && x >= (Freq/HZ); loops++){
        outb(Tmode, Latch0);
        x = inb(T0cntr);
        x |= inb(T0cntr)<<8;
    }
}
@

<<function i8253enable>>=
void
i8253enable(void)
{
    i8253.enabled = true;
    i8253.period = Freq/HZ;
    intrenable(IrqCLOCK, i8253clock, 0, BUSUNKNOWN, "clock");
}
@

<<interrupt callback i8253clock>>=
static void
i8253clock(Ureg* ureg, void*)
{
    timerintr(ureg, 0);
}
@



<<clock callback hzclock>>=
void
hzclock(Ureg *ur)
{
    m->ticks++;
    if(m->proc)
        m->proc->pc = ur->pc;

    if(m->flushmmu){
        if(up)
            flushmmu();
        m->flushmmu = 0;
    }

    accounttime();
    kmapinval();

    if(kproftimer != nil)
        kproftimer(ur->pc);

    if((active.machs&(1<<m->machno)) == 0)
        return;

    if(active.exiting) {
        print("someone's exiting\n");
        exit(0);
    }

    checkalarms();

    if(up && up->state == Running)
        hzsched();  /* in proc.c */
}
@ 


\section{Scheduler, [[sched()]] and [[ready()]]}

\section{[[sleep()]], [[wakeup()]]}

\section{[[sysfork()]]}

\section{[[sysexec()]]}

\section{[[sysexits()]]}


\chapter{Initialization}
\minitoc

\section{Booting the kernel}

\section{Kernel initialization}

\section{The first process}

\section{Booting the user}
% see section on Userspace system programs

\chapter{Files}
\minitoc

<<systab file syscalls>>=
    [CREATE]    syscreate,
    [REMOVE]    sysremove,

    [OPEN]      sysopen,
    [CLOSE]     sysclose,
    [PREAD]     syspread,
    [PWRITE]    syspwrite,
    [SEEK]      sysseek,

    [STAT]      sysstat,
    [FSTAT]     sysfstat,
    [WSTAT]     syswstat,
    [FWSTAT]    sysfwstat,

    [CHDIR]     syschdir,
    [FD2PATH]   sysfd2path, // pwd?
@ 

% note that files are used for many things, including devices!!
% plan has lots of actually file servers
%pike: interface is not everything is not a file, but everything is
% a file server interface!

\section{Overview}

\section{[[Chan]]nels}

\section{[[dev]]ices [[tab]]le}

\section{[[syscreate()]], [[sysremove()]]}

\section {[[sysopen()]], [[sysclose()]]}

\section {[[syspread()]], [[syspwrite()]]}

\section {[[sysstat()]]}

\section {[[syschdir()]]}

\section{Other syscalls}


\chapter{Namespace}
\minitoc

% see names.ps
% see lexnames.ps

<<systab namespace syscalls>>=
    [BIND]      sysbind,
    [MOUNT]     sysmount,
    [UNMOUNT]   sysunmount,
@ 

\section{Overview}

\section{[[bind()]]}

\section{[[mount()]]}

\section{Other syscalls}


\chapter{Devices}
\minitoc

\section{The Console device}

\subsection{Overview}

\subsection{Input}
%buffered input


<<struct ConsKbd>>=
struct ConsKbd
{
    bool raw;        /* true if we shouldn't process input */

    char    line[1024]; /* current input line */
    int x;      /* index into line */

    int count;
    int ctlpoff;

    /* a place to save up characters at interrupt time before dumping them in the queue */
    Lock    lockputc;
    char    istage[1024];

    // extra
    QLock;
    Ref ctl;        /* number of opens to the control file */

    //???
    char    *iw;
    char    *ir;
    char    *ie;
};
@ 

<<global kbd>>=
static struct ConsKbd kbd = 
{
    .iw = kbd.istage,
    .ir = kbd.istage,
    .ie = kbd.istage + sizeof(kbd.istage),
};
@ 

<<global kbdq>>=
Queue*  kbdq;           /* unprocessed console input */
@ 


<<global lineq>>=
Queue*  lineq;          /* processed console input */
@ 

<<function printinit>>=
void
printinit(void)
{
    lineq = qopen(2*1024, 0, nil, nil);
    if(lineq == nil)
        panic("printinit");
    qnoblock(lineq, 1);
}
@ 

<<function kbdputc>>=
/*
 *  Put character, possibly a rune, into read queue at interrupt time.
 *  Called at interrupt time to process a character.
 */
int
kbdputc(Queue*, int ch)
{
    int i, n;
    char buf[3];
    Rune r;
    char *next;

    if(kbd.ir == nil)
        return 0;       /* in case we're not inited yet */
    
    ilock(&kbd.lockputc);       /* just a mutex */
    r = ch;
    n = runetochar(buf, &r);
    for(i = 0; i < n; i++){
        next = kbd.iw+1;
        if(next >= kbd.ie)
            next = kbd.istage;
        if(next == kbd.ir)
            break;
        *kbd.iw = buf[i];
        kbd.iw = next;
    }
    iunlock(&kbd.lockputc);
    return 0;
}
@ 

<<clock callback kbdputcclock>>=
/*
 *  we save up input characters till clock time to reduce
 *  per character interrupt overhead.
 */
static void
kbdputcclock(void)
{
    char *iw;

    /* this amortizes cost of qproduce */
    if(kbd.iw != kbd.ir){
        iw = kbd.iw;
        if(iw < kbd.ir){
            echo(kbd.ir, kbd.ie-kbd.ir);
            kbd.ir = kbd.istage;
        }
        if(kbd.ir != iw){
            echo(kbd.ir, iw-kbd.ir);
            kbd.ir = iw;
        }
    }
}
@ 


\subsection{Output}

<<function print>>=
bool noprint; // to debug?

int
devcons_print(char *fmt, ...)
{
    int n;
    va_list arg;
    char buf[PRINTSIZE];

    if(noprint)
        return -1;

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);
    putstrn(buf, n);

    return n;
}
@ 


<<function putstrn>>=
void
putstrn(char *str, int n)
{
    putstrn0(str, n, 0);
}
@ 

<<function putstrn0>>=
/*
 *   Print a string on the console.  Convert \n to \r\n for serial
 *   line consoles.  Locking of the queues is left up to the screen
 *   or uart code.  Multi-line messages to serial consoles may get
 *   interspersed with other messages.
 */
static void
putstrn0(char *str, int n, bool usewrite)
{
    int m;
    char *t;

    if(!islo())
        usewrite = 0;

    /*
     *  how many different output devices do we need?
     */
    kmesgputs(str, n);

    /*
     *  if someone is reading /dev/kprint,
     *  put the message there.
     *  if not and there's an attached bit mapped display,
     *  put the message there.
     *
     *  if there's a serial line being used as a console,
     *  put the message there.
     */
    if(kprintoq != nil && !qisclosed(kprintoq)){
        if(usewrite)
            qwrite(kprintoq, str, n);
        else
            qiwrite(kprintoq, str, n);
    }else if(screenputs != nil)
        screenputs(str, n);

    if(serialoq == nil){
        uartputs(str, n);
        return;
    }

    while(n > 0) {
        t = memchr(str, '\n', n);
        if(t && !kbd.raw) {
            m = t-str;
            if(usewrite){
                qwrite(serialoq, str, m);
                qwrite(serialoq, "\r\n", 2);
            } else {
                qiwrite(serialoq, str, m);
                qiwrite(serialoq, "\r\n", 2);
            }
            n -= m+1;
            str = t+1;
        } else {
            if(usewrite)
                qwrite(serialoq, str, n);
            else
                qiwrite(serialoq, str, n);
            break;
        }
    }
}
@ 


<<hook screenputs>>=
void    (*screenputs)(char*, int) = nil;
@ 


<<global iprintscreenputs>>=
int iprintscreenputs = 1;
@ 

<<function iprint>>=
int
devcons_iprint(char *fmt, ...)
{
    int n, s, locked;
    va_list arg;
    char buf[PRINTSIZE];

    s = splhi();
    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);
    locked = iprintcanlock(&iprintlock);
    if(screenputs != nil && iprintscreenputs)
        screenputs(buf, n);
    uartputs(buf, n);
    if(locked)
        unlock(&iprintlock);
    splx(s);

    return n;
}
@ 

% todo: see balestero note,
% in distributed context we want to print process error at the right place
% not just on kernel console
<<function pprint>>=
int
devcons_pprint(char *fmt, ...)
{
    int n;
    Chan *c;
    va_list arg;
    char buf[2*PRINTSIZE];

    if(up == nil || up->fgrp == nil)
        return 0;

    c = up->fgrp->fd[2];
    if(c==0 || (c->mode!=OWRITE && c->mode!=ORDWR))
        return 0;
    n = snprint(buf, sizeof buf, "%s %lud: ", up->text, up->pid);
    va_start(arg, fmt);
    n = vseprint(buf+n, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    if(waserror())
        return 0;
    devtab[c->type]->write(c, buf, n, c->offset);
    poperror();

    lock(c);
    c->offset += n;
    unlock(c);

    return n;
}
@ 

<<function echoscreen>>=
static void
echoscreen(char *buf, int n)
{
    char *e, *p;
    char ebuf[128];
    int x;

    p = ebuf;
    e = ebuf + sizeof(ebuf) - 4;
    while(n-- > 0){
        if(p >= e){
            screenputs(ebuf, p - ebuf);
            p = ebuf;
        }
        x = *buf++;
        if(x == 0x15){
            *p++ = '^';
            *p++ = 'U';
            *p++ = '\n';
        } else
            *p++ = x;
    }
    if(p != ebuf)
        screenputs(ebuf, p - ebuf);
}
@ 

<<function echo>>=
static void
echo(char *buf, int n)
{
    static int ctrlt, pid;
    int x;
    char *e, *p;

    if(n == 0)
        return;

    e = buf+n;
    for(p = buf; p < e; p++){
        switch(*p){
        case 0x10:  /* ^P */
            if(cpuserver && !kbd.ctlpoff){
                active.exiting = 1;
                return;
            }
            break;
        case 0x14:  /* ^T */
            ctrlt++;
            if(ctrlt > 2)
                ctrlt = 2;
            continue;
        }

        if(ctrlt != 2)
            continue;

        /* ^T escapes */
        ctrlt = 0;
        switch(*p){
        case 'S':
            x = splhi();
            dumpstack();
            procdump();
            splx(x);
            return;
        case 's':
            dumpstack();
            return;
        case 'x':
            xsummary();
            ixsummary();
            mallocsummary();
            memorysummary();
            pagersummary();
            return;
        case 'd':
            if(consdebug == nil)
                consdebug = rdb;
            else
                consdebug = nil;
            print("consdebug now %#p\n", consdebug);
            return;
        case 'D':
            if(consdebug == nil)
                consdebug = rdb;
            consdebug();
            return;
        case 'p':
            x = spllo();
            procdump();
            splx(x);
            return;
        case 'q':
            scheddump();
            return;
        case 'k':
            killbig("^t ^t k");
            return;
        case 'r':
            exit(0);
            return;
        }
    }

    qproduce(kbdq, buf, n);
    if(kbd.raw)
        return;
    kmesgputs(buf, n);
    if(screenputs != nil)
        echoscreen(buf, n);
    if(serialoq)
        echoserialoq(buf, n);
}
@ 

\subsection{[[devcons.c]]}

<<devcons.c enum Qxxx>>=
enum{
    Qdir,
    Qbintime,
    Qcons,
    Qconsctl,
    Qcputime,
    Qdrivers,
    Qkmesg,
    Qkprint,
    Qhostdomain,
    Qhostowner,
    Qnull,
    Qosversion,
    Qpgrpid,
    Qpid,
    Qppid,
    Qrandom,
    Qreboot,
    Qswap,
    Qsysname,
    Qsysstat,
    Qtime,
    Quser,
    Qzero,
    Qconfig,
};
@ 


<<global consdir>>=
static Dirtab consdir[]={
    ".",    {Qdir, 0, QTDIR},   0,      DMDIR|0555,
    "bintime",  {Qbintime}, 24,     0664,
    "cons",     {Qcons},    0,      0660,
    "consctl",  {Qconsctl}, 0,      0220,
    "cputime",  {Qcputime}, 6*NUMSIZE,  0444,
    "drivers",  {Qdrivers}, 0,      0444,
    "hostdomain",   {Qhostdomain},  DOMLEN,     0664,
    "hostowner",    {Qhostowner},   0,      0664,
    "kmesg",    {Qkmesg},   0,      0440,
    "kprint",   {Qkprint, 0, QTEXCL},   0,  DMEXCL|0440,
    "null",     {Qnull},    0,      0666,
    "osversion",    {Qosversion},   0,      0444,
    "pgrpid",   {Qpgrpid},  NUMSIZE,    0444,
    "pid",      {Qpid},     NUMSIZE,    0444,
    "ppid",     {Qppid},    NUMSIZE,    0444,
    "random",   {Qrandom},  0,      0444,
    "reboot",   {Qreboot},  0,      0660,
    "swap",     {Qswap},    0,      0664,
    "sysname",  {Qsysname}, 0,      0664,
    "sysstat",  {Qsysstat}, 0,      0666,
    "time",     {Qtime},    NUMSIZE+3*VLNUMSIZE,    0664,
    "user",     {Quser},    0,      0666,
    "zero",     {Qzero},    0,      0444,
    "config",   {Qconfig},  0,      0444,
};
@ 


<<method consinit>>=
static void
consinit(void)
{
    todinit();
    randominit();
    /*
     * at 115200 baud, the 1024 char buffer takes 56 ms to process,
     * processing it every 22 ms should be fine
     */
    addclock0link(kbdputcclock, 22);
}
@ 


<<method consopen>>=
static Chan*
consopen(Chan *c, int omode)
{
    c->aux = nil;
    c = devopen(c, omode, consdir, nelem(consdir), devgen);
    switch((ulong)c->qid.path){
    case Qconsctl:
        incref(&kbd.ctl);
        break;

    case Qkprint:
        if(tas(&kprintinuse) != 0){
            c->flag &= ~COPEN;
            error(Einuse);
        }
        if(kprintoq == nil){
            kprintoq = qopen(8*1024, Qcoalesce, 0, 0);
            if(kprintoq == nil){
                c->flag &= ~COPEN;
                error(Enomem);
            }
            qnoblock(kprintoq, 1);
        }else
            qreopen(kprintoq);
        c->iounit = qiomaxatomic;
        break;
    }
    return c;
}
@ 


<<method consclose>>=
static void
consclose(Chan *c)
{
    switch((ulong)c->qid.path){
    /* last close of control file turns off raw */
    case Qconsctl:
        if(c->flag&COPEN){
            if(decref(&kbd.ctl) == 0)
                kbd.raw = 0;
        }
        break;

    /* close of kprint allows other opens */
    case Qkprint:
        if(c->flag & COPEN){
            kprintinuse = 0;
            qhangup(kprintoq, nil);
        }
        break;
    }
}
@ 

<<method consread>>=
static long
consread(Chan *c, void *buf, long n, vlong off)
{
    ulong l;
    Mach *mp;
    char *b, *bp, ch;
    char tmp[256];      /* must be >= 18*NUMSIZE (Qswap) */
    int i, k, id, send;
    vlong offset = off;
    extern char configfile[];

    if(n <= 0)
        return n;

    switch((ulong)c->qid.path){
    case Qdir:
        return devdirread(c, buf, n, consdir, nelem(consdir), devgen);

    case Qcons:
        qlock(&kbd);
        if(waserror()) {
            qunlock(&kbd);
            nexterror();
        }
        while(!qcanread(lineq)){
            if(qread(kbdq, &ch, 1) == 0)
                continue;
            send = 0;
            if(ch == 0){
                /* flush output on rawoff -> rawon */
                if(kbd.x > 0)
                    send = !qcanread(kbdq);
            }else if(kbd.raw){
                kbd.line[kbd.x++] = ch;
                send = !qcanread(kbdq);
            }else{
                switch(ch){
                case '\b':
                    if(kbd.x > 0)
                        kbd.x--;
                    break;
                case 0x15:  /* ^U */
                    kbd.x = 0;
                    break;
                case '\n':
                case 0x04:  /* ^D */
                    send = 1;
                default:
                    if(ch != 0x04)
                        kbd.line[kbd.x++] = ch;
                    break;
                }
            }
            if(send || kbd.x == sizeof kbd.line){
                qwrite(lineq, kbd.line, kbd.x);
                kbd.x = 0;
            }
        }
        n = qread(lineq, buf, n);
        qunlock(&kbd);
        poperror();
        return n;

    case Qcputime:
        k = offset;
        if(k >= 6*NUMSIZE)
            return 0;
        if(k+n > 6*NUMSIZE)
            n = 6*NUMSIZE - k;
        /* easiest to format in a separate buffer and copy out */
        for(i=0; i<6 && NUMSIZE*i<k+n; i++){
            l = up->time[i];
            if(i == TReal)
                l = MACHP(0)->ticks - l;
            l = TK2MS(l);
            readnum(0, tmp+NUMSIZE*i, NUMSIZE, l, NUMSIZE);
        }
        memmove(buf, tmp+k, n);
        return n;

    case Qkmesg:
        /*
         * This is unlocked to avoid tying up a process
         * that's writing to the buffer.  kmesg.n never 
         * gets smaller, so worst case the reader will
         * see a slurred buffer.
         */
        if(off >= kmesg.n)
            n = 0;
        else{
            if(off+n > kmesg.n)
                n = kmesg.n - off;
            memmove(buf, kmesg.buf+off, n);
        }
        return n;
        
    case Qkprint:
        return qread(kprintoq, buf, n);

    case Qpgrpid:
        return readnum((ulong)offset, buf, n, up->pgrp->pgrpid, NUMSIZE);

    case Qpid:
        return readnum((ulong)offset, buf, n, up->pid, NUMSIZE);

    case Qppid:
        return readnum((ulong)offset, buf, n, up->parentpid, NUMSIZE);

    case Qtime:
        return readtime((ulong)offset, buf, n);

    case Qbintime:
        return readbintime(buf, n);

    case Qhostowner:
        return readstr((ulong)offset, buf, n, eve);

    case Qhostdomain:
        return readstr((ulong)offset, buf, n, hostdomain);

    case Quser:
        return readstr((ulong)offset, buf, n, up->user);

    case Qnull:
        return 0;

    case Qconfig:
        return readstr((ulong)offset, buf, n, configfile);

    case Qsysstat:
        b = smalloc(conf.nmach*(NUMSIZE*11+1) + 1); /* +1 for NUL */
        bp = b;
        for(id = 0; id < 32; id++) {
            if(active.machs & (1<<id)) {
                mp = MACHP(id);
                readnum(0, bp, NUMSIZE, id, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->cs, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->intr, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->syscall, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->pfault, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->tlbfault, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->tlbpurge, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE, mp->load, NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE,
                    (mp->perf.avg_inidle*100)/mp->perf.period,
                    NUMSIZE);
                bp += NUMSIZE;
                readnum(0, bp, NUMSIZE,
                    (mp->perf.avg_inintr*100)/mp->perf.period,
                    NUMSIZE);
                bp += NUMSIZE;
                *bp++ = '\n';
            }
        }
        if(waserror()){
            free(b);
            nexterror();
        }
        n = readstr((ulong)offset, buf, n, b);
        free(b);
        poperror();
        return n;

    case Qswap:
        snprint(tmp, sizeof tmp,
            "%lud memory\n"
            "%d pagesize\n"
            "%lud kernel\n"
            "%lud/%lud user\n"
            "%lud/%lud swap\n"
            "%lud/%lud kernel malloc\n"
            "%lud/%lud kernel draw\n",
            conf.npage*BY2PG,
            BY2PG,
            conf.npage-conf.upages,
            palloc.user-palloc.freecount, palloc.user,
            conf.nswap-swapalloc.free, conf.nswap,
            mainmem->cursize, mainmem->maxsize,
            imagmem->cursize, imagmem->maxsize);

        return readstr((ulong)offset, buf, n, tmp);

    case Qsysname:
        if(sysname == nil)
            return 0;
        return readstr((ulong)offset, buf, n, sysname);

    case Qrandom:
        return randomread(buf, n);

    case Qdrivers:
        b = malloc(READSTR);
        if(b == nil)
            error(Enomem);
        k = 0;
        for(i = 0; devtab[i] != nil; i++)
            k += snprint(b+k, READSTR-k, "#%C %s\n",
                devtab[i]->dc, devtab[i]->name);
        if(waserror()){
            free(b);
            nexterror();
        }
        n = readstr((ulong)offset, buf, n, b);
        free(b);
        poperror();
        return n;

    case Qzero:
        memset(buf, 0, n);
        return n;

    case Qosversion:
        snprint(tmp, sizeof tmp, "2000");
        n = readstr((ulong)offset, buf, n, tmp);
        return n;

    default:
        print("consread %#llux\n", c->qid.path);
        error(Egreg);
    }
    return -1;      /* never reached */
}
@

<<method conswrite>>=
static long
conswrite(Chan *c, void *va, long n, vlong off)
{
    char buf[256], ch;
    long l, bp;
    char *a;
    Mach *mp;
    int id, fd;
    Chan *swc;
    ulong offset;
    Cmdbuf *cb;
    Cmdtab *ct;

    a = va;
    offset = off;

    switch((ulong)c->qid.path){
    case Qcons:
        /*
         * Can't page fault in putstrn, so copy the data locally.
         */
        l = n;
        while(l > 0){
            bp = l;
            if(bp > sizeof buf)
                bp = sizeof buf;
            memmove(buf, a, bp);
            putstrn0(buf, bp, 1);
            a += bp;
            l -= bp;
        }
        break;

    case Qconsctl:
        if(n >= sizeof(buf))
            n = sizeof(buf)-1;
        strncpy(buf, a, n);
        buf[n] = 0;
        for(a = buf; a;){
            if(strncmp(a, "rawon", 5) == 0){
                kbd.raw = 1;
                /* clumsy hack - wake up reader */
                ch = 0;
                qwrite(kbdq, &ch, 1);           
            } else if(strncmp(a, "rawoff", 6) == 0){
                kbd.raw = 0;
            } else if(strncmp(a, "ctlpon", 6) == 0){
                kbd.ctlpoff = 0;
            } else if(strncmp(a, "ctlpoff", 7) == 0){
                kbd.ctlpoff = 1;
            }
            if(a = strchr(a, ' '))
                a++;
        }
        break;

    case Qtime:
        if(!iseve())
            error(Eperm);
        return writetime(a, n);

    case Qbintime:
        if(!iseve())
            error(Eperm);
        return writebintime(a, n);

    case Qhostowner:
        return hostownerwrite(a, n);

    case Qhostdomain:
        return hostdomainwrite(a, n);

    case Quser:
        return userwrite(a, n);

    case Qnull:
        break;

    case Qconfig:
        error(Eperm);
        break;

    case Qreboot:
        if(!iseve())
            error(Eperm);
        cb = parsecmd(a, n);

        if(waserror()) {
            free(cb);
            nexterror();
        }
        ct = lookupcmd(cb, rebootmsg, nelem(rebootmsg));
        switch(ct->index) {
        case CMhalt:
            reboot(nil, 0, 0);
            break;
        case CMreboot:
            rebootcmd(cb->nf-1, cb->f+1);
            break;
        case CMpanic:
            *(ulong*)0=0;
            panic("/dev/reboot");
        }
        poperror();
        free(cb);
        break;

    case Qsysstat:
        for(id = 0; id < 32; id++) {
            if(active.machs & (1<<id)) {
                mp = MACHP(id);
                mp->cs = 0;
                mp->intr = 0;
                mp->syscall = 0;
                mp->pfault = 0;
                mp->tlbfault = 0;
                mp->tlbpurge = 0;
            }
        }
        break;

    case Qswap:
        if(n >= sizeof buf)
            error(Egreg);
        memmove(buf, va, n);    /* so we can NUL-terminate */
        buf[n] = 0;
        /* start a pager if not already started */
        if(strncmp(buf, "start", 5) == 0){
            kickpager();
            break;
        }
        if(!iseve())
            error(Eperm);
        if(buf[0]<'0' || '9'<buf[0])
            error(Ebadarg);
        fd = strtoul(buf, 0, 0);
        swc = fdtochan(fd, -1, 1, 1);
        setswapchan(swc);
        break;

    case Qsysname:
        if(offset != 0)
            error(Ebadarg);
        if(n <= 0 || n >= sizeof buf)
            error(Ebadarg);
        strncpy(buf, a, n);
        buf[n] = 0;
        if(buf[n-1] == '\n')
            buf[n-1] = 0;
        kstrdup(&sysname, buf);
        break;

    default:
        print("conswrite: %#llux\n", c->qid.path);
        error(Egreg);
    }
    return n;
}
@ 

<<global consdevtab>>=
Dev consdevtab = {
    .dc       =    'c',
    .name     =    "cons",
               
    .reset    =    devreset,
    .init     =    consinit,
    .shutdown =    devshutdown,
    .attach   =    consattach,
    .walk     =    conswalk,
    .stat     =    consstat,
    .open     =    consopen,
    .create   =    devcreate,
    .close    =    consclose,
    .read     =    consread,
    .bread    =    devbread,
    .write    =    conswrite,
    .bwrite   =    devbwrite,
    .remove   =    devremove,
    .wstat    =    devwstat,
};
@ 

\subsection{Other}

<<global sysname>>=
char    *sysname;
@ 

\section{System devices}

\subsection{[[devroot.c]]}

% just with that we can already have a working environment
% with a memory fs! where all binaries are processed via data2txt

%#/

\subsection{[[devenv.c]]}

%#e

\subsection{[[devproc.c]]}

%#p


\section{External devices}

\subsection{Screen}
% just cga.c here, see Window.tex.nw for the advanced vga kernel support

<<cga.c enum color>>=
enum color {
    Black,
    Blue,
    Green,
    Cyan,
    Red,
    Magenta,
    Brown,
    Grey,

    Bright = 0x08,
    Blinking = 0x80,

    Yellow = Bright|Brown,
    White = Bright|Grey,
};
@

<<cga.c enum misc>>=
enum {
    Width       = 80*2,
    Height      = 25,

    Attr        = (Black<<4)|Grey,  /* high nibble background
                         * low foreground
                         */

    Poststrlen  = 0,
    Postcodelen = 2,
    Postlen     = Poststrlen+Postcodelen,
};
@

<<constant CGASCREENBASE>>=
#define CGASCREENBASE   ((uchar*)KADDR(0xB8000))
@


<<global cgapos>>=
static int cgapos;
@


<<global cgascreenlock>>=
static Lock cgascreenlock;
@

<<function screeninit>>=
void
screeninit(void)
{

    cgapos = cgaregr(0x0E)<<8;
    cgapos |= cgaregr(0x0F);
    cgapos *= 2;

    screenputs = cgascreenputs;
}
@


<<function cgaregr>>=
static uchar
cgaregr(int index)
{
    outb(0x3D4, index);
    return inb(0x3D4+1) & 0xFF;
}
@


<<function cgaregw>>=
static void
cgaregw(int index, int data)
{
    outb(0x3D4, index);
    outb(0x3D4+1, data);
}
@


<<function movecursor>>=
static void
movecursor(void)
{
    cgaregw(0x0E, (cgapos/2>>8) & 0xFF);
    cgaregw(0x0F, cgapos/2 & 0xFF);
    CGASCREENBASE[cgapos+1] = Attr;
}
@


<<function cgascreenputc>>=
static void
cgascreenputc(int c)
{
    int i;
    uchar *p;

    if(c == '\n'){
        cgapos = cgapos/Width;
        cgapos = (cgapos+1)*Width;
    }
    else if(c == '\t'){
        i = 8 - ((cgapos/2)&7);
        while(i-->0)
            cgascreenputc(' ');
    }
    else if(c == '\b'){
        if(cgapos >= 2)
            cgapos -= 2;
        cgascreenputc(' ');
        cgapos -= 2;
    }
    else{
        CGASCREENBASE[cgapos++] = c;
        CGASCREENBASE[cgapos++] = Attr;
    }
    if(cgapos >= Width*Height){
        memmove(CGASCREENBASE, &CGASCREENBASE[Width], Width*(Height-1));
        p = &CGASCREENBASE[Width*(Height-1)];
        for(i=0; i<Width/2; i++){
            *p++ = ' ';
            *p++ = Attr;
        }
        cgapos = Width*(Height-1);
    }
    movecursor();
}
@


<<function cgascreenputs>>=
static void
cgascreenputs(char* s, int n)
{
    if(!islo()){
        /*
         * Don't deadlock trying to
         * print in an interrupt.
         */
        if(!canlock(&cgascreenlock))
            return;
    }
    else
        lock(&cgascreenlock);

    while(n-- > 0)
        cgascreenputc(*s++);

    unlock(&cgascreenlock);
}
@


\subsection{Keyboard}

<<global kbtab>>=
/*
 * The codes at 0x79 and 0x7b are produced by the PFU Happy Hacking keyboard.
 * A 'standard' keyboard doesn't produce anything above 0x58.
 */
Rune kbtab[Nscan] = 
{
[0x00]  No, 0x1b,   '1',    '2',    '3',    '4',    '5',    '6',
[0x08]  '7',    '8',    '9',    '0',    '-',    '=',    '\b',   '\t',
[0x10]  'q',    'w',    'e',    'r',    't',    'y',    'u',    'i',
[0x18]  'o',    'p',    '[',    ']',    '\n',   Ctrl,   'a',    's',
[0x20]  'd',    'f',    'g',    'h',    'j',    'k',    'l',    ';',
[0x28]  '\'',   '`',    Shift,  '\\',   'z',    'x',    'c',    'v',
[0x30]  'b',    'n',    'm',    ',',    '.',    '/',    Shift,  '*',
[0x38]  Latin,  ' ',    Ctrl,   KF|1,   KF|2,   KF|3,   KF|4,   KF|5,
[0x40]  KF|6,   KF|7,   KF|8,   KF|9,   KF|10,  Num,    Scroll, '7',
[0x48]  '8',    '9',    '-',    '4',    '5',    '6',    '+',    '1',
[0x50]  '2',    '3',    '0',    '.',    No, No, No, KF|11,
[0x58]  KF|12,  No, No, No, No, No, No, No,
[0x60]  No, No, No, No, No, No, No, No,
[0x68]  No, No, No, No, No, No, No, No,
[0x70]  No, No, No, No, No, No, No, No,
[0x78]  No, View,   No, Up, No, No, No, No,
};
@


<<global kbtabshift>>=
Rune kbtabshift[Nscan] =
{
[0x00]  No, 0x1b,   '!',    '@',    '#',    '$',    '%',    '^',
[0x08]  '&',    '*',    '(',    ')',    '_',    '+',    '\b',   '\t',
[0x10]  'Q',    'W',    'E',    'R',    'T',    'Y',    'U',    'I',
[0x18]  'O',    'P',    '{',    '}',    '\n',   Ctrl,   'A',    'S',
[0x20]  'D',    'F',    'G',    'H',    'J',    'K',    'L',    ':',
[0x28]  '"',    '~',    Shift,  '|',    'Z',    'X',    'C',    'V',
[0x30]  'B',    'N',    'M',    '<',    '>',    '?',    Shift,  '*',
[0x38]  Latin,  ' ',    Ctrl,   KF|1,   KF|2,   KF|3,   KF|4,   KF|5,
[0x40]  KF|6,   KF|7,   KF|8,   KF|9,   KF|10,  Num,    Scroll, '7',
[0x48]  '8',    '9',    '-',    '4',    '5',    '6',    '+',    '1',
[0x50]  '2',    '3',    '0',    '.',    No, No, No, KF|11,
[0x58]  KF|12,  No, No, No, No, No, No, No,
[0x60]  No, No, No, No, No, No, No, No,
[0x68]  No, No, No, No, No, No, No, No,
[0x70]  No, No, No, No, No, No, No, No,
[0x78]  No, Up, No, Up, No, No, No, No,
};
@


<<global kbtabesc1>>=
Rune kbtabesc1[Nscan] =
{
[0x00]  No, No, No, No, No, No, No, No,
[0x08]  No, No, No, No, No, No, No, No,
[0x10]  No, No, No, No, No, No, No, No,
[0x18]  No, No, No, No, '\n',   Ctrl,   No, No,
[0x20]  No, No, No, No, No, No, No, No,
[0x28]  No, No, Shift,  No, No, No, No, No,
[0x30]  No, No, No, No, No, '/',    No, Print,
[0x38]  Altgr,  No, No, No, No, No, No, No,
[0x40]  No, No, No, No, No, No, Break,  Home,
[0x48]  Up, Pgup,   No, Left,   No, Right,  No, End,
[0x50]  Down,   Pgdown, Ins,    Del,    No, No, No, No,
[0x58]  No, No, No, No, No, No, No, No,
[0x60]  No, No, No, No, No, No, No, No,
[0x68]  No, No, No, No, No, No, No, No,
[0x70]  No, No, No, No, No, No, No, No,
[0x78]  No, Up, No, No, No, No, No, No,
};
@


<<global kbtabaltgr>>=
Rune kbtabaltgr[Nscan] =
{
[0x00]  No, No, No, No, No, No, No, No,
[0x08]  No, No, No, No, No, No, No, No,
[0x10]  No, No, No, No, No, No, No, No,
[0x18]  No, No, No, No, '\n',   Ctrl,   No, No,
[0x20]  No, No, No, No, No, No, No, No,
[0x28]  No, No, Shift,  No, No, No, No, No,
[0x30]  No, No, No, No, No, '/',    No, Print,
[0x38]  Altgr,  No, No, No, No, No, No, No,
[0x40]  No, No, No, No, No, No, Break,  Home,
[0x48]  Up, Pgup,   No, Left,   No, Right,  No, End,
[0x50]  Down,   Pgdown, Ins,    Del,    No, No, No, No,
[0x58]  No, No, No, No, No, No, No, No,
[0x60]  No, No, No, No, No, No, No, No,
[0x68]  No, No, No, No, No, No, No, No,
[0x70]  No, No, No, No, No, No, No, No,
[0x78]  No, Up, No, No, No, No, No, No,
};
@


<<global kbtabctrl decl>>=
extern Rune kbtabctrl[];
@


<<struct Kbscan>>=
struct Kbscan {
    bool esc1;
    bool alt;
    bool altgr;
    bool caps;
    bool ctl;
    bool num;
    bool shift;

    int esc2;

    bool collecting;
    int nk;
    Rune    kc[5];
    int buttons;
};
@


<<global kbscans>>=
Kbscan kbscans[Nscans]; /* kernel and external scan code state */
@


<<global nokbd>>=
static bool nokbd = true;           /* flag: no PS/2 keyboard */
@



<<function kbdinit>>=
void
kbdinit(void)
{
    int c, try;

    /* wait for a quiescent controller */
    try = 500;
    while(try-- > 0 && (c = inb(Status)) & (Outbusy | Inready)) {
        if(c & Inready)
            inb(Data);
        delay(1);
    }
    if (try <= 0) {
        print(initfailed);
        return;
    }

    /* get current controller command byte */
    outb(Cmd, 0x20);
    if(inready() < 0){
        print("i8042: kbdinit can't read ccc\n");
        ccc = 0;
    } else
        ccc = inb(Data);

    /* enable kbd xfers and interrupts */
    ccc &= ~Ckbddis;
    ccc |= Csf | Ckbdint | Cscs1;
    if(outready() < 0) {
        print(initfailed);
        return;
    }

    nokbd = false;

    /* disable mouse */
    if (outbyte(Cmd, 0x60) < 0 || outbyte(Data, ccc) < 0)
        print("i8042: kbdinit mouse disable failed\n");

    /* see http://www.computer-engineering.org/ps2keyboard for codes */
    if(getconf("*typematic") != nil)
        /* set typematic rate/delay (0 -> delay=250ms & rate=30cps) */
        if(outbyte(Data, 0xf3) < 0 || outbyte(Data, 0) < 0)
            print("i8042: kbdinit set typematic rate failed\n");
}
@


<<function kbdenable>>=
void
kbdenable(void)
{
    kbdq = qopen(4*1024, 0, 0, 0);
    if(kbdq == nil)
        panic("kbdinit");
    qnoblock(kbdq, 1);

    ioalloc(Data, 1, 0, "kbd");
    ioalloc(Cmd, 1, 0, "kbd");

    intrenable(IrqKBD, i8042intr, 0, BUSUNKNOWN, "kbd");

    kbscans[Int].num = 0;
    setleds(&kbscans[Int]);
}
@

<<global i8042lock>>=
static Lock i8042lock;
@


<<interrupt callback i8042intr>>=
/*
 *  keyboard interrupt
 */
static void
i8042intr(Ureg*, void*)
{
    int s, c;

    /*
     *  get status
     */
    ilock(&i8042lock);
    s = inb(Status);
    if(!(s&Inready)){
        iunlock(&i8042lock);
        return;
    }

    /*
     *  get the character
     */
    c = inb(Data);
    iunlock(&i8042lock);

    /*
     *  if it's the aux port...
     */
    if(s & Minready){
        if(auxputc != nil)
            auxputc(c, kbscans[Int].shift);
        return;
    }

    kbdputsc(c, Int);
}
@







<<function kbdputsc>>=
/*
 * Scan code processing
 */
void
kbdputsc(int c, bool external)
{
    int i, keyup;
    Kbscan *kbscan;

    if(external)
        kbscan = &kbscans[Ext];
    else
        kbscan = &kbscans[Int];

    if(kdebug)
        print("sc %x ms %d\n", c, mouseshifted);
    /*
     *  e0's is the first of a 2 character sequence, e1 the first
     *  of a 3 character sequence (on the safari)
     */
    if(c == 0xe0){
        kbscan->esc1 = 1;
        return;
    } else if(c == 0xe1){
        kbscan->esc2 = 2;
        return;
    }

    keyup = c & 0x80;
    c &= 0x7f;
    if(c > sizeof kbtab){
        c |= keyup;
        if(c != 0xFF)   /* these come fairly often: CAPSLOCK U Y */
            print("unknown key %ux\n", c);
        return;
    }

    if(kbscan->esc1){
        c = kbtabesc1[c];
        kbscan->esc1 = 0;
    } else if(kbscan->esc2){
        kbscan->esc2--;
        return;
    } else if(kbscan->shift)
        c = kbtabshift[c];
    else if(kbscan->altgr)
        c = kbtabaltgr[c];
    else if(kbscan->ctl)
        c = kbtabctrl[c];
    else
        c = kbtab[c];

    if(kbscan->caps && c<='z' && c>='a')
        c += 'A' - 'a';

    /*
     *  keyup only important for shifts
     */
    if(keyup){
        switch(c){
        case Latin:
            kbscan->alt = 0;
            break;
        case Shift:
            kbscan->shift = 0;
            mouseshifted = 0;
            if(kdebug)
                print("shiftclr\n");
            break;
        case Ctrl:
            kbscan->ctl = 0;
            break;
        case Altgr:
            kbscan->altgr = 0;
            break;
        case Kmouse|1:
        case Kmouse|2:
        case Kmouse|3:
        case Kmouse|4:
        case Kmouse|5:
            kbscan->buttons &= ~(1<<(c-Kmouse-1));
            if(kbdmouse)
                kbdmouse(kbscan->buttons);
            break;
        }
        return;
    }

    /*
     *  normal character
     */
    if(!(c & (Spec|KF))){
        if(kbscan->ctl)
            if(kbscan->alt && c == Del)
                exit(0);
        if(!kbscan->collecting){
            kbdputc(kbdq, c);
            return;
        }
        kbscan->kc[kbscan->nk++] = c;
        c = latin1(kbscan->kc, kbscan->nk);
        if(c < -1)  /* need more keystrokes */
            return;
        if(c != -1) /* valid sequence */
            kbdputc(kbdq, c);
        else    /* dump characters */
            for(i=0; i<kbscan->nk; i++)
                kbdputc(kbdq, kbscan->kc[i]);
        kbscan->nk = 0;
        kbscan->collecting = 0;
        return;
    } else {
        switch(c){
        case Caps:
            kbscan->caps ^= 1;
            return;
        case Num:
            kbscan->num ^= 1;
            if(!external)
                setleds(kbscan);
            return;
        case Shift:
            kbscan->shift = 1;
            if(kdebug)
                print("shift\n");
            mouseshifted = 1;
            return;
        case Latin:
            kbscan->alt = 1;
            /*
             * VMware and Qemu use Ctl-Alt as the key combination
             * to make the VM give up keyboard and mouse focus.
             * This has the unfortunate side effect that when you
             * come back into focus, Plan 9 thinks you want to type
             * a compose sequence (you just typed alt). 
             *
             * As a clumsy hack around this, we look for ctl-alt
             * and don't treat it as the start of a compose sequence.
             */
            if(!kbscan->ctl){
                kbscan->collecting = 1;
                kbscan->nk = 0;
            }
            return;
        case Ctrl:
            kbscan->ctl = 1;
            return;
        case Altgr:
            kbscan->altgr = 1;
            return;
        case Kmouse|1:
        case Kmouse|2:
        case Kmouse|3:
        case Kmouse|4:
        case Kmouse|5:
            kbscan->buttons |= 1<<(c-Kmouse-1);
            if(kbdmouse)
                kbdmouse(kbscan->buttons);
            return;
        case KF|11:
            print("kbd debug on, F12 turns it off\n");
            kdebug = 1;
            break;
        case KF|12:
            kdebug = 0;
            break;
        }
    }
    kbdputc(kbdq, c);
}
@

<<function outbyte>>=
static int
outbyte(int port, int c)
{
    outb(port, c);
    if(outready() < 0) {
        print(initfailed);
        return -1;
    }
    return 0;
}
@

<<function outready>>=
/*
 *  wait for output no longer busy
 */
static int
outready(void)
{
    int tries;

    for(tries = 0; (inb(Status) & Outbusy); tries++){
        if(tries > 500)
            return -1;
        delay(2);
    }
    return 0;
}
@


<<function inready>>=
/*
 *  wait for input
 */
static int
inready(void)
{
    int tries;

    for(tries = 0; !(inb(Status) & Inready); tries++){
        if(tries > 500)
            return -1;
        delay(2);
    }
    return 0;
}
@


<<function i8042auxcmd>>=
int
i8042auxcmd(int cmd)
{
    unsigned int c;
    int tries;
    static int badkbd;

    if(badkbd)
        return -1;
    c = 0;
    tries = 0;

    ilock(&i8042lock);
    do{
        if(tries++ > 2)
            break;
        if(outready() < 0)
            break;
        outb(Cmd, 0xD4);
        if(outready() < 0)
            break;
        outb(Data, cmd);
        if(outready() < 0)
            break;
        if(inready() < 0)
            break;
        c = inb(Data);
    } while(c == 0xFE || c == 0);
    iunlock(&i8042lock);

    if(c != 0xFA){
        print("i8042: %2.2ux returned to the %2.2ux command\n", c, cmd);
        badkbd = 1; /* don't keep trying; there might not be one */
        return -1;
    }
    return 0;
}
@

<<function i8042auxenable>>=
void
i8042auxenable(void (*putc)(int, int))
{
    char *err = "i8042: aux init failed\n";

    /* enable kbd/aux xfers and interrupts */
    ccc &= ~Cauxdis;
    ccc |= Cauxint;

    ilock(&i8042lock);
    if(outready() < 0)
        print(err);
    outb(Cmd, 0x60);            /* write control register */
    if(outready() < 0)
        print(err);
    outb(Data, ccc);
    if(outready() < 0)
        print(err);
    outb(Cmd, 0xA8);            /* auxiliary device enable */
    if(outready() < 0){
        iunlock(&i8042lock);
        return;
    }
    auxputc = putc;
    intrenable(IrqAUX, i8042intr, 0, BUSUNKNOWN, "kbdaux");
    iunlock(&i8042lock);
}
@



\subsection{Mouse}

\subsection{Audio}

\subsection{Storage}


\section{Special devices}
%optional, advanced concepts

<<systab special file syscalls>>=
    [DUP]       sysdup,
@ 

\subsection{[[devdup.c]]}

\subsection{[[devpipe.c]]}
% see section in IPC also?
% have pipe syscall and device, so both useful? named pipe
% can be done only via devpipe.c

\subsection{[[devmnt.c]]}

\subsection{[[devsrv.c]]}




\chapter{Time}
\minitoc

<<global fasthz>>=
vlong   fasthz;
@ 

<<function us>>=
ulong
µs(void)
{
    return fastticks2us((*arch->fastclock)(nil));
}
@


<<function fastticks>>=
/*
 *  return value and speed of timer set in arch->clockenable
 */
uvlong
devarch_fastticks(uvlong *hz)
{
    return (*arch->fastclock)(hz);
}
@


<<function cycles and default implementation>>=
static void
simplecycles(uvlong*x)
{
    *x = m->ticks;
}

void    (*cycles)(uvlong*) = simplecycles;
@ 




<<systab time syscalls>>=
    [SLEEP]     syssleep,
    [ALARM]     sysalarm,
@

\section{Timers}

% capacity of machine is very low, just timer next point
%  but have many processes, many timer needs, so need map
%  all of that on very limited hardware power

\subsection{Time units}

<<type Tval>>=
typedef vlong   Tval; // ticks
typedef vlong   Tnano; // nanoseconds
typedef vlong   Tmicro; // microseconds
typedef int     Tms; // milliseconds
typedef vlong   Tsec; // seconds
@

<<function tk2ms>>=
/*
 *  This tk2ms avoids overflows that the macro version is prone to.
 *  It is a LOT slower so shouldn't be used if you're just converting
 *  a delta.
 */
ulong
tk2ms(ulong ticks)
{
    uvlong t, hz;

    t = ticks;
    hz = HZ;
    t *= 1000L;
    t = t/hz;
    ticks = t;
    return ticks;
}
@ 


<<function ms2tk>>=
ulong
ms2tk(ulong ms)
{
    /* avoid overflows at the cost of precision */
    if(ms >= 1000000000/HZ)
        return (ms/1000)*HZ;
    return (ms*HZ+500)/1000;
}
@ 

\subsection{[[timerset()]]}

<<function timerset>>=
// used to be static, but now shared between arch.c and devarch.c
int doi8253set = 1;
/*
 *  set next timer interrupt
 */
void
timerset(Tval x)
{
    if(doi8253set)
        (*arch->timerset)(x);
}
@

<<function i8253timerset>>=
void
i8253timerset(uvlong next)
{
    long period;
    ulong want;
    ulong now;

    period = MaxPeriod;
    if(next != 0){
        want = next>>Tickshift;
        now = i8253.ticks;  /* assuming whomever called us just did fastticks() */

        period = want - now;
        if(period < MinPeriod)
            period = MinPeriod;
        else if(period > MaxPeriod)
            period = MaxPeriod;
    }

    /* hysteresis */
    if(i8253.period != period){
        ilock(&i8253);
        /* load new value */
        outb(Tmode, Load0|Square);
        outb(T0cntr, period);       /* low byte */
        outb(T0cntr, period >> 8);      /* high byte */

        /* remember period */
        i8253.period = period;
        i8253.periodset++;
        iunlock(&i8253);
    }
}
@

\subsection{[[Timer]] and [[Timers]]}

<<struct Timer>>=
struct Timer
{
    /* Public interface */
    // enum<timermode>
    int tmode;    /* See above */
    Tnano tns;    /* meaning defined by mode */ //nanosecond
    void  (*tf)(Ureg*, Timer*);
    void  *ta;
  
    /* Internal */
    Lock;
    Tval  tticks;   /* tns converted to ticks */
    Tval  twhen;    /* ns represented in fastticks */

    <<[[Timer extra fields>>
    };
@ 

<<enum timermode>>=
/*
 * fasttick timer interrupts
 */
enum timermode 
{
    Trelative,  /* timer programmed in ns from now */
    Tperiodic,  /* periodic timer, period in ns */
};
@ 

<<struct Timers>>=
struct Timers
{
    // list<Timer> (next = Timer.tnext)
    Timer *head;
    // extra
    Lock;
};
@ 

<<[[Timer extra fields>>=
// list<Timer> of Timers.head
Timer *tnext;
// ref<list<Timer>> Timers.head
Timers  *tt;    /* Timers queue this timer runs on */
@


<<function tadd>>=
static Tval
tadd(Timers *tt, Timer *nt)
{
    Timer *t, **last;

    /* Called with tt locked */
    assert(nt->tt == nil);
    switch(nt->tmode){
    case Trelative:
        if(nt->tns <= 0)
            nt->tns = 1;
        nt->twhen = fastticks(nil) + ns2fastticks(nt->tns);
        break;
    case Tperiodic:
        assert(nt->tns >= 100000);  /* At least 100 µs period */
        if(nt->twhen == 0){
            /* look for another timer at same frequency for combining */
            for(t = tt->head; t; t = t->tnext){
                if(t->tmode == Tperiodic && t->tns == nt->tns)
                    break;
            }
            if (t)
                nt->twhen = t->twhen;
            else
                nt->twhen = fastticks(nil);
        }
        nt->twhen += ns2fastticks(nt->tns);
        break;
    default:
        panic("timer: impossible");
        break;
    }

    for(last = &tt->head; t = *last; last = &t->tnext){
        if(t->twhen > nt->twhen)
            break;
    }
    nt->tnext = *last;
    *last = nt;
    nt->tt = tt;
    if(last == &tt->head)
        return nt->twhen;
    return 0;
}
@ 


<<function tdel>>=
static Tval
tdel(Timer *dt)
{
    Timer *t, **last;
    Timers *tt;

    tt = dt->tt;
    if (tt == nil)
        return 0; // possible? panic("impossible") would be better no?
    for(last = &tt->head; t = *last; last = &t->tnext){
        if(t == dt){
            assert(dt->tt);
            dt->tt = nil;
            *last = t->tnext;
            break;
        }
    }
    if(last == &tt->head && tt->head)
        return tt->head->twhen;
    return 0;
}
@ 

\subsection{[[timers]]}
<<global timers>>=
static Timers timers[MAXMACH];
@ 

<<function timeradd>>=
/* add or modify a timer */
void
timeradd(Timer *nt)
{
    Timers *tt;
    Tval when;

    /* Must lock Timer struct before Timers struct */
    ilock(nt);

    if(tt = nt->tt){
        ilock(tt);
        tdel(nt);
        iunlock(tt);
    }

    tt = &timers[m->machno];
    ilock(tt);
    when = tadd(tt, nt);
    if(when)
        timerset(when);
    iunlock(tt);
    iunlock(nt);
}
@ 

<<function timerdel>>=
void
timerdel(Timer *dt)
{
    Timers *tt;
    Tval when;

    ilock(dt);
    if(tt = dt->tt){
        ilock(tt);
        when = tdel(dt);
        if(when && tt == &timers[m->machno])
            timerset(tt->head->twhen);
        iunlock(tt);
    }
    iunlock(dt);
}
@ 


\subsection{Initialisation}

<<function timersinit>>=
void
timersinit(void)
{
    Timer *t;

    timersinited = true;
    todinit();

    t = malloc(sizeof(Timer));
    if(t == nil)
        error(Enomem);
    t->tmode = Tperiodic;
    t->tt = nil;
    t->tns = 1000000000/HZ;
    /*
     * T->tf == nil means the HZ clock for this processor.
     */
    t->tf = nil;
    timeradd(t);
}
@ 

\subsection{[[timerintr()]]}

<<interrupt callback timerintr>>=
// called via i8253clock
void
timerintr(Ureg *u, Tval)
{
    Timer *t;
    Timers *tt;
    uvlong when, now;
    int count, callhzclock;

    intrcount[m->machno]++;
    callhzclock = 0;
    tt = &timers[m->machno];
    now = fastticks(nil);
    if(now == 0)
        panic("timerintr: zero fastticks()");
    ilock(tt);
    count = Maxtimerloops;
    while((t = tt->head) != nil){
        /*
         * No need to ilock t here: any manipulation of t
         * requires tdel(t) and this must be done with a
         * lock to tt held.  We have tt, so the tdel will
         * wait until we're done
         */
        when = t->twhen;
        if(when > now){
            timerset(when);
            iunlock(tt);
            if(callhzclock)
                hzclock(u);
            return;
        }
        tt->head = t->tnext;
        assert(t->tt == tt);
        t->tt = nil;
        fcallcount[m->machno]++;
        iunlock(tt);
        if(t->tf)
            (*t->tf)(u, t);
        else
            callhzclock++;
        ilock(tt);
        if(t->tmode == Tperiodic)
            tadd(tt, t);
        if (--count <= 0) {
            count = Maxtimerloops;
            iprint("timerintr: probably stuck in while loop; "
                "scrutinise clock.c or use faster cycle "
                "counter\n");
        }
    }
    iunlock(tt);
}
@ 

\subsection{Clock callback}

<<function addclock0link>>=
Timer*
addclock0link(void (*f)(void), Tms ms)
{
    Timer *nt;
    Tval when;

    if(!timersinited)
        panic("addclock0link: timersinit not called yet");

    /* Synchronize to hztimer if ms is 0 */
    nt = malloc(sizeof(Timer));
    if(nt == nil)
        error(Enomem);
    if(ms == 0)
        ms = 1000/HZ;

    nt->tns = (Tnano)ms*1000000LL;
    nt->tmode = Tperiodic;
    nt->tt = nil;
    nt->tf = (void (*)(Ureg*, Timer*))f;

    // those clock callbacks are all done on the bootstrap processor
    //dupe: timeradd() but with forced processor number
    ilock(&timers[0]);
    when = tadd(&timers[0], nt);
    if(when)
        timerset(when);
    iunlock(&timers[0]);
    return nt;
}
@ 

\section{[[syssleep()]]}

\section{[[sysalarm()]]}
%related? tsleep, tsemacquire

\section{Time of day}

<<devcons.c Exxx errors>>=
char *Ebadtimectl = "bad time control";
@


<<function readtime>>=
/*
 *  like the old #c/time but with added info.  Return
 *
 *  secs    nanosecs    fastticks   fasthz
 */
static int
readtime(ulong off, char *buf, int n)
{
    vlong   nsec, ticks;
    long sec;
    char str[7*NUMSIZE];

    nsec = todget(&ticks);
    if(fasthz == 0LL)
        fastticks((uvlong*)&fasthz);
    sec = nsec/1000000000ULL;
    snprint(str, sizeof(str), "%*lud %*llud %*llud %*llud ",
        NUMSIZE-1, sec,
        VLNUMSIZE-1, nsec,
        VLNUMSIZE-1, ticks,
        VLNUMSIZE-1, fasthz);
    return readstr(off, buf, n, str);
}
@


<<function writetime>>=
/*
 *  set the time in seconds
 */
static int
writetime(char *buf, int n)
{
    char b[13];
    long i;
    vlong now;

    if(n >= sizeof(b))
        error(Ebadtimectl);
    strncpy(b, buf, n);
    b[n] = 0;
    i = strtol(b, 0, 0);
    if(i <= 0)
        error(Ebadtimectl);
    now = i*1000000000LL;
    todset(now, 0, 0);
    return n;
}
@


<<function readbintime>>=
/*
 *  read binary time info.  all numbers are little endian.
 *  ticks and nsec are syncronized.
 */
static int
readbintime(char *buf, int n)
{
    int i;
    vlong nsec, ticks;
    uchar *b = (uchar*)buf;

    i = 0;
    if(fasthz == 0LL)
        fastticks((uvlong*)&fasthz);
    nsec = todget(&ticks);
    if(n >= 3*sizeof(uvlong)){
        vlong2le(b+2*sizeof(uvlong), fasthz);
        i += sizeof(uvlong);
    }
    if(n >= 2*sizeof(uvlong)){
        vlong2le(b+sizeof(uvlong), ticks);
        i += sizeof(uvlong);
    }
    if(n >= 8){
        vlong2le(b, nsec);
        i += sizeof(vlong);
    }
    return i;
}
@


<<function writebintime>>=
/*
 *  set any of the following
 *  - time in nsec
 *  - nsec trim applied over some seconds
 *  - clock frequency
 */
static int
writebintime(char *buf, int n)
{
    uchar *p;
    vlong delta;
    long period;

    n--;
    p = (uchar*)buf + 1;
    switch(*buf){
    case 'n':
        if(n < sizeof(vlong))
            error(Ebadtimectl);
        le2vlong(&delta, p);
        todset(delta, 0, 0);
        break;
    case 'd':
        if(n < sizeof(vlong)+sizeof(long))
            error(Ebadtimectl);
        p = le2vlong(&delta, p);
        le2long(&period, p);
        todset(-1, delta, period);
        break;
    case 'f':
        if(n < sizeof(uvlong))
            error(Ebadtimectl);
        le2vlong(&fasthz, p);
        if(fasthz <= 0)
            error(Ebadtimectl);
        todsetfreq(fasthz);
        break;
    }
    return n;
}
@


\chapter{IPC}
\minitoc

% of course can use fs to communicate between process :)

% see also network

<<systab ipc syscalls>>=
    [NOTIFY]    sysnotify,
    [NOTED]     sysnoted,

    [PIPE]      syspipe,

    [SEGATTACH] syssegattach,
    [SEGDETACH] syssegdetach,
    [SEGFREE]   syssegfree,
    [SEGFLUSH]  syssegflush,
    [SEGBRK]    syssegbrk,
@ 

\section{Notes (signals)}

\section{Pipes}

\section{Shared [[Segment]] and [[Sema]]phore}

% shared segment? and so semaphore? libc_thread?

\section{Network}

\chapter{Filesystem}
\minitoc

\section{[[devfs.c]]}

\section{Ramfs}

\section{Dossrv}


\chapter{Userspace System Programs}
\minitoc

\section{[[boot/boot]]}

<<boot.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

/*
 * we should inherit the standard fds all referring to /dev/cons,
 * but we're being paranoid.
 */
static void
opencons(void)
{
  close(0);
  close(1);
  close(2);
  open("/dev/cons", OREAD);
  open("/dev/cons", OWRITE);
  open("/dev/cons", OWRITE);
}

/*
 * init will reinitialize its namespace.
 * #ec gets us plan9.ini settings (*var variables).
 */
static void
bindenvsrv(void)
{
  bind("#ec", "/env", MREPL);
  bind("#e", "/env", MBEFORE|MCREATE);
  bind("#s", "/srv/", MREPL|MCREATE);
}

static void
swapproc(void)
{
    int fd;

    fd = open("#c/swap", OWRITE);
    if(fd < 0){
        warning("opening #c/swap");
        return;
    }
    if(write(fd, "start", 5) <= 0)
        warning("starting swap kproc");
    close(fd);
}

static void
execinit(void)
{
  int fd;

  bind_safe("#p", "/proc", MREPL); //devproc
  // used by rc and many programs, e.g. via open("#d/0")
  bind_safe("#d", "/fd", MREPL); //devdup

  bind_safe("/root", "/", MAFTER|MCREATE);
  bind_safe("/386/bin", "/bin", MREPL);
  bind_safe("/rc/bin", "/bin", MAFTER);

  bind_safe("#v", "/dev", MAFTER); //devvga
  bind_safe("#m", "/dev", MAFTER); //devmouse
  bind_safe("#P", "/dev", MAFTER);

  run("/bin/mouse", "ps2", nil);
  //this just need a regular vga driver
  //run("/bin/vga", "-l", "640x480x8", nil);
  //this need special drivers, such as the clgd424x.c in the kernel
  run("/bin/vga", "-l", "1024x768x8", nil);
  bind_safe("#i", "/dev", MAFTER);

  // for rio
  run("/bin/ramfs", "-m", "/mnt", nil);
  run("/bin/mkdir", "/mnt/temp", nil); // see thread(2), used to create pipes
  run("/bin/mkdir", "/mnt/wsys", nil);
  fd = open_safe("#c/hostowner", OWRITE);
  print_safe(fd, "pad");
  close(fd);

  // network
  bind_safe("#I", "/net", MREPL);
  bind_safe("#l0", "/net", MAFTER);

  run("/bin/rc", nil);
}


// called from boot$CONF.c:main()
void
boot(int argc, char *argv[])
{
  USED(argc);
  USED(argv);

  fmtinstall('r', errfmt);

  //At this point we should have #/ and #c setup by the kernel init0

  opencons();
  bindenvsrv();

  print("booooooooting...\n");

  rfork(RFNAMEG);

  connectlocal();

  swapproc();
  execinit();

  exits("failed to exec init");
}
@

<<local.c>>=
#include <u.h>
#include <libc.h>
#include "../boot/boot.h"

int
connectlocal(void)
{
  int fd;
  
  bind_safe("#S", "/dev", MAFTER);

  fd = open_safe("/dev/sdC0/ctl", ORDWR);
  //TODO: use fdisk -p /dev/sdC1/data > /dev/sdC1/ctl
  //for sdC0: #prep -p /dev/sdC1/plan9 > /dev/sdC1/ctl
  print_safe(fd, "part dos 1 1000063");
  close_safe(fd);

  run("/boot/dossrv", nil);
  run("/boot/mount", "-c", "/srv/dos", "/root", "/dev/sdC0/dos", nil);
  
  return 0;
}
@

\section{[[root/init]]}
% user init, != kernel init

\section{The shell}


\chapter{Misc}

\section{Random}



<<global randn>>=
static  ulong   randn;
@


<<function seedrand>>=
static void
seedrand(void)
{
    if(!waserror()){
        randomread((void*)&randn, sizeof(randn));
        poperror();
    }
}
@


<<function nrand>>=
int
nrand(int n)
{
    if(randn == 0)
        seedrand();
    randn = randn*1103515245 + 12345 + MACHP(0)->ticks;
    return (randn>>16) % n;
}
@

\chapter{Conclusion}

% already 900 pages ... so network in another volume

% other subjects: SMP, storage (scsi, ata, floppy, ...)

\section{Security}

<<systab security syscalls>>=
    [FAUTH]     sysfauth,
    [FVERSION]  sysfversion,
@ 

\section{Network}
% put also RPC and devmnt here?

\section{Graphics}

\appendix

\chapter{Debugging}

% what to do when have panic, e.g. when I mixed some fields
% and I got a pc error, how do I fix it? how do I find the relevant code?

% see also printf section all this fmt stuff

\section{[[cgapost()]]}

<<function cgapost>>=
char hex[] = "0123456789ABCDEF";

void
cgapost(int code)
{
    uchar *cga;

    cga = CGASCREENBASE;
    cga[Width*Height-Postcodelen*2] = hex[(code>>4) & 0x0F];
    cga[Width*Height-Postcodelen*2+1] = Attr;
    cga[Width*Height-Postcodelen*2+2] = hex[code & 0x0F];
    cga[Width*Height-Postcodelen*2+3] = Attr;
}
@

\section{Special keys}

% Ctrl-t Ctrl-t <debugcode>

\section{[[sysnop()]]}
% use sysnop (was called sysr1) to show example of debugging session?

\section{[[/dev/kmesg]]}

<<constant KMESGSIZE>>=
// used in devcons.c
KMESGSIZE = (256*1024),  /* lots, for acpi debugging */ // default is 16*1024
@

<<struct KMesg>>=
/*
 * Log console output so it can be retrieved via /dev/kmesg.
 * This is good for catching boot-time messages after the fact.
 */
struct KMesg {
    Lock lk;
    char buf[KMESGSIZE];
    uint n;
};
@ 


<<global kmesg>>=
struct KMesg kmesg;
@ 


<<function kmesgputs>>=
static void
kmesgputs(char *str, int n)
{
    uint nn, d;

    ilock(&kmesg.lk);
    /* take the tail of huge writes */
    if(n > sizeof kmesg.buf){
        d = n - sizeof kmesg.buf;
        str += d;
        n -= d;
    }

    /* slide the buffer down to make room */
    nn = kmesg.n;
    if(nn + n >= sizeof kmesg.buf){
        d = nn + n - sizeof kmesg.buf;
        if(d)
            memmove(kmesg.buf, kmesg.buf+d, sizeof kmesg.buf-d);
        nn -= d;
    }

    /* copy the data in */
    memmove(kmesg.buf+nn, str, n);
    nn += n;
    kmesg.n = nn;
    iunlock(&kmesg.lk);
}
@ 

\section{[[/dev/kprint]]}

<<global kprintoq>>=
Queue*  kprintoq;       /* console output, for /dev/kprint */
@ 

\section{Remote debugger}
% rdb.c

<<hook consdebug>>=
void    (*consdebug)(void) = nil; // for rdb
@ 

\chapter{Profiling}

% devkprof.c?

<<hook kproftimer>>=
void (*kproftimer)(ulong);
@ 

\chapter{Error Managment}

\section{[[panic()]]}

<<function panic>>=
void
devcons_panic(char *fmt, ...)
{
    int n, s;
    va_list arg;
    char buf[PRINTSIZE];

    kprintoq = nil; /* don't try to write to /dev/kprint */

    if(panicking)
        for(;;);
    panicking = 1;

    s = splhi();
    strcpy(buf, "panic: ");
    va_start(arg, fmt);
    n = vseprint(buf+strlen(buf), buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);
    iprint("%s\n", buf);
    if(consdebug)
        (*consdebug)();
    splx(s);
    prflush();
    buf[n] = '\n';
    putstrn(buf, n+1);
    //dumpstack();

        //  exit(1);
}
@ 


<<function sysfatal>>=
/* libmp at least contains a few calls to sysfatal; simulate with panic */
//@Scheck: no dead, override also sysfatal from libc/9sys/sysfatal.c
// note that this is not a system call, even though it's prefixed with sys
void
sysfatal(char *fmt, ...)
{
    char err[256];
    va_list arg;

    va_start(arg, fmt);
    vseprint(err, err + sizeof err, fmt, arg);
    va_end(arg);
    panic("sysfatal: %s", err);
}
@ 


<<function _assert>>=
void
devcons__assert(char *fmt)
{
    panic("assert failed at %#p: %s", getcallerpc(&fmt), fmt);
}
@ 

\section{[[error()]]}

<<global Exxx errors>>=
char Emount[] = "inconsistent mount";
char Eunmount[] = "not mounted";
char Eismtpt[] = "is a mount point";
char Eunion[] = "not in union";
char Emountrpc[] = "mount rpc error";
char Eshutdown[] = "device shut down";
char Enocreate[] = "mounted directory forbids creation";
char Enonexist[] = "file does not exist";
char Eexist[] = "file already exists";
char Ebadsharp[] = "unknown device in # filename";
char Enotdir[] = "not a directory";
char Eisdir[] = "file is a directory";
char Ebadchar[] = "bad character in file name";
char Efilename[] = "file name syntax";
char Eperm[] = "permission denied";
char Ebadusefd[] = "inappropriate use of fd";
char Ebadarg[] = "bad arg in system call";
char Einuse[] = "device or object already in use";
char Eio[] = "i/o error";
char Etoobig[] = "read or write too large";
char Etoosmall[] = "read or write too small";
char Ehungup[] = "i/o on hungup channel";
char Ebadctl[] = "bad process or channel control request";
char Enodev[] = "no free devices";
char Eprocdied[] = "process exited";
char Enochild[] = "no living children";
char Eioload[] = "i/o error in demand load";
char Enovmem[] = "virtual memory allocation failed";
char Ebadfd[] = "fd out of range or not open";
char Enofd[] = "no free file descriptors";
char Eisstream[] = "seek on a stream";
char Ebadexec[] = "exec header invalid";
char Etimedout[] = "connection timed out";
char Econrefused[] = "connection refused";
char Econinuse[] = "connection in use";
char Eintr[] = "interrupted";
char Enomem[] = "kernel allocate failed";
char Esoverlap[] = "segments overlap";
char Emouseset[] = "mouse type already set";
char Eshort[] = "i/o count too small";
char Egreg[] = "jmk added reentrancy for threads";
char Ebadspec[] = "bad attach specifier";
char Enoreg[] = "process has no saved registers";
char Enoattach[] = "mount/attach disallowed";
char Eshortstat[] = "stat buffer too small";
char Ebadstat[] = "malformed stat buffer";
char Enegoff[] = "negative i/o offset";
char Ecmdargs[] = "wrong #args in control message";
char Ebadip[] = "bad ip address syntax";
char Edirseek[] = "seek in directory";
char Echange[] = "media or partition has changed";
@ 

\section{[[waserror()]], [[nexterror()]]}
% waserror(), nexterror(), etc
% =~ poor's man exn mechanism (=> improve C!!)

\section{[[syserrstr()]]}

\chapter{Mini Libc}

\section{Pool allocation}

% set things from lib_core/libc/...?pool.c mainmem? imagmem?

\section{Printf and Fmt}

% see print.c which overrides functions defined in lib_core/libc/fmt/fmtlock.c 

\chapter{Extra Code}

#include "Kernel_extra.tex.nw"

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
up = user process

pc = program counter

spl = set priority level

ilock = interrupt safe version of lock (disable interruptions)

umb = upper memory block

RMAP = RAM map

PDB = page directory base

PTE = page table entry

tod = time of day

ap = application processor

EDF = Earliest Deadline First
http://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling

RPC = remote procedure call

EGRP = Environment group

FGRP = File descriptor Group (chans)

PGRP = Process Group (namespace)

VNO = Vector number (interrupt)

ISR = Interrupt Service Routine

TSC = Time Stamp Counter
http://en.wikipedia.org/wiki/Time_Stamp_Counter

intr = Interrupt (not INT, probably to avoid ambiguity with integer)

APIC = Advanded Programmable Interrupt Controller (a next gen 8259)

ACPI = Advanced Configuration & Power Interface

QID = unique identifier

\end{verbatim}
%cistrcmp= ??


\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}


% TECS, STEPS, MINIX, etc

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
