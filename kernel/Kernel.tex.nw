\documentclass{book}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
% see also other newif in Macros.tex
\finaltrue\verbosefalse

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things :)
% - ??

%thx to codemap/codegraph:
% - see pad.txt#reorganization section

%history LP-ization:
% - skeleton; a not too bad TOC
% - TODO put gradually content of files in the Extra section
% - TODO split the files in chunks (for type, helpers, ...), using
%   my emacs macro
% - TODO distribute parts of the file before
% - TODO add figures (hand made)

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
 \noweboptions{}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
\usepackage{fullpage}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\implemtrue
\implemoverviewtrue
\wantrepetitivecodefalse
\allcodefalse

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
The Plan9 Kernel
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 

\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3.
\end{quote}
% hmmm what about the code part?
\hrule

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real operating system (and in later books to also cover compilers,
assemblers, linkers, debuggers, etc). Why? Because I think it makes
you a better programmer if you fully understand how things work under
the hood.
% a concrete companion to "Computer systems: a programmer's pespective"

The choice of plan9 may not be obvious, but it is IMHO
the simplest but at the same time fairly complete operating system.
If you look at the screenshot in~Figure X, you'll see
many features:
\begin{itemize}
\item a screen, with simple graphics and basic windows managment
\item a mouse and keyboard
\item multiple shells running multiple commands
\item a simple clock graphical application 
\item a simple program communicating through the network
\end{itemize}

By comparison if you look at the screenshot in~Figure Y
you'll see that Plan9 in essence provides the similar core services
of MacOS, Linux or Windows.
% multi tasking, graphics, windows, IO, etc

Other candidates were discarded:
\begin{itemize}
\item Unix V6 (or its modern incarnation xv6), too simple,
no graphics, no network
\item TECS, excellent for understanding hardware, but the
software part is too simple. For instance the operating
system is really a toy.
\item Alan's Kay STEPS project, far more ambitious as
the goal is to have a full system in 20 000 LOC, but not
finished yet.
\item Minix, bigger and does not provide a simple windowing
system as it relies on X11 which is far more complicated than plan9
rio windowing system
\item Gnu/Linux, far far bigger. If you take the source code of glibc,
the Linux kernel, X11, and the network stack, you'll get at
least 2 orders of magniture more source code, even though
Plan9 provides in essence the same core services. Of course
the Linux kernel contains thousands of specific drivers,
glibc handles many different architectures, and X11 can support
lots of graphic cards that could be discarded 
when presenting the core of those software, but their core
is still far bigger than Plan9 equivalent software.
\end{itemize}

\section{Getting started}

See \url{https://github.com/aryx/fork-plan9}.

\section{Assumptions}

I assume you actually know a lot:
\begin{itemize}
\item C
% ref?
\item an assembler
% ref?
\item operating system (yep)
% ref?
\end{itemize}

This book is not an introduction to operating systems. The goal
of this book is to present in full details a kernel but we assume
you already have a vague idea of how an operating system
works and so that you are familiar with virtual memory, interrupts,
system calls, etc.

\section{About this document}
%#include "About.tex.nw"

\section{Copyright}
% most of this document is actually code from Plan9, so plan9 copyright.

\section{Acknowledgments}

Of course Plan9's authors who wrote most of this book: Ken Thompson,
Rob Pile, Russ Cox, etc.

Federic Balesteros who wrote lengthy notes about Plan9's kernel.

\chapter{Overview}

\section{Operating system principles}

An operating system is a meta-program: A program that manages other
programs.

It provides convenient abstractions of the hardware and multiplex
those hardware resources for the benefit of user programs:
\begin{itemize}
\item a virtual CPU, each process thinks it has all the CPU for himself
\item a virtual memory, each process thinks it has all memory for himself
\item a virtual screen, each process thinks it has all the screen for himself
\item a virtual storage (filesystem)
\item a virtual network (NFS)
\end{itemize}

\section{Operating system services}

\begin{verbatim}
% user point of view:
% - start the whole thing, first program!
% - process managment, shell, fork, exec, multi task
% - system calls, =~ APIs of user program
% - interrupt handling, =~ devices and also syscalls and preemptive multi task
% - IO operations, =~ devices and files
% - file managment, =~ filesystem
\end{verbatim}

%the syscalls, grouped in different sections
% process, memory, IO, fs, etc

\section{Plan9}
%plan9 specifics vs general os principles, e.g. namespace so have
% nice /dev/cons, /dev/draw, which enable easier network and graphics

\section{The machine}
%PC vs raspberry pi?

\section{Code organization}
% codemap and codegraph screenshot?

\section{Booting overview}
% kernel that creates first user process!
% introduce dichotomy kernel/user

\section{Memory overview}
% kernel vs user memory

\section{Syscall overview}
% kernel vs user code

\chapter{Core Data Structures}

\section{Mini LibC}
% bool, int, strings, unicode, etc

\section{[[Conf]]}

\section{[[Mach]]}

\section{[[Proc]]}

\section{[[Chan]]}

\section{[[Dev]]}

\chapter{Concurrency}

\section{Critical Regions}

\section{TAS}

\section{Lock}

\section{Interrupt Lock}

\section{Queue Lock}

\section{Read Write Lock}

\section{References}

\section{Rendez-vous}

\section{Semaphore}

\chapter{Memory}

\section{Overview}

\section{Xalloc}

\section{Kernel Malloc}

\section{User Malloc}
%actually brk

\section{Virtual Memory}

\section{Paging}

\section{Segments}

\section{Syscalls}

\chapter{Processes}

\section{Overview}

\section{[[Proc]]}

\section{Traps and interrupts}

\section{Clock interrupt}

\section{Scheduler}

\section{SMP}

\section{Fork}

\section{Exec}

\section{Notes (signals)}

\section{Syscalls}

\chapter{Files}

\section{Overview}

\section{Channels}

\section{Devices table}

\section{Open/read/write/close}

\section{Namespace}

\section{Syscalls}

\chapter{Initialization}

\section{Booting the kernel}

\section{Kernel initialization}

\section{The first process}

\chapter{The Console}

\chapter{Core Devices}

\section{[[devroot.c]]}

\section{[[devenv.c]]}

\section{[[devproc.c]]}

\section{[[devdup.c]] and [[devpipe.c]]}

\chapter{Devices}

\section{Screen}

\section{Keyboard}

\section{Mouse}

\section{Audio}

\section{Storage}

\chapter{Filesystem}

\section{Devfs}

\section{Ramfs}

\section{Dossrv}

\section{Devmnt and Devsrv}

\chapter{System programs}

\section{Init}

\section{The shell}

\chapter{Conclusion}

\section{Security}

\section{Network}

\section{Graphics}

\appendix

\chapter{Debugging}

\chapter{Profiling}

\chapter{Error Managment}

\chapter{Mini Libc}

\section{Pool allocation}

\chapter{Extra Code}

\section{[[../include/]]}

\section{[[lib/]]}

\section{[[core/]]}

\section{[[concurrency/]]}

\section{[[memory/]]}

\section{[[processes/]]}

\section{[[files/]]}

\section{[[console/]]}

\section{[[security/]]}

\section{[[network/]]}

\section{[[devices/]]}

\section{[[filesystems/]]}

\section{[[conf/]]}

\section{[[syscalls/]]}

\section{[[init/]]}

\section{[[boot/]]}

\section{[[arch/]]}

\section{[[buses/]]}

\section{[[misc/]]}

\chapter{Changelog}
\label{sec:changelog}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
