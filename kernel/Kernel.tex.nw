\documentclass{book}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
% see also other newif in Macros.tex
\finaltrue\verbosefalse

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things :)
% - ??

%thx to codemap/codegraph:
% - see pad.txt#reorganization section

%history LP-ization:
% - skeleton; a not too bad TOC
% - TODO put gradually content of files in the Extra section
% - TODO split the files in chunks (for type, helpers, ...), using
%   my emacs macro
% - TODO distribute parts of the file before
% - TODO add figures (hand made)

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
 \noweboptions{}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
\usepackage{fullpage}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\implemtrue
\implemoverviewtrue
\wantrepetitivecodefalse
\allcodefalse

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
The Plan9 Kernel
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 

\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3.
\end{quote}
% hmmm what about the code part?
\hrule

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real operating system (and in later books to also cover compilers,
assemblers, linkers, debuggers, etc). Why? Because I think it makes
you a better programmer if you fully understand how things work under
the hood.
% a concrete companion to "Computer systems: a programmer's pespective"

The choice of plan9 may not be obvious, but it is IMHO
the simplest but at the same time fairly complete operating system.
If you look at the screenshot in~Figure X, you'll see
many features:
\begin{itemize}
\item a screen, with simple graphics and basic windows managment
\item a mouse and keyboard
\item multiple shells running multiple commands
\item a simple clock graphical application 
\item a simple program communicating through the network
\end{itemize}

By comparison if you look at the screenshot in~Figure Y
you'll see that Plan9 in essence provides the similar core services
of MacOS, Linux or Windows.
% multi tasking, graphics, windows, IO, etc

Other candidates were discarded:
\begin{itemize}
\item Unix V6 (or its modern incarnation xv6), too simple,
no graphics, no network
\item TECS, excellent for understanding hardware, but the
software part is too simple. For instance the operating
system is really a toy.
\item Alan's Kay STEPS project, far more ambitious as
the goal is to have a full system in 20 000 LOC, but not
finished yet.
\item Minix, bigger and does not provide a simple windowing
system as it relies on X11 which is far more complicated than plan9
rio windowing system
\item Gnu/Linux, far far bigger. If you take the source code of glibc,
the Linux kernel, X11, and the network stack, you'll get at
least 2 orders of magniture more source code, even though
Plan9 provides in essence the same core services. Of course
the Linux kernel contains thousands of specific drivers,
glibc handles many different architectures, and X11 can support
lots of graphic cards that could be discarded 
when presenting the core of those software, but their core
is still far bigger than Plan9 equivalent software.
\end{itemize}

\section{Getting started}

See \url{https://github.com/aryx/fork-plan9}.

\section{Assumptions}

I assume you actually know a lot:
\begin{itemize}
\item C
% ref?
\item an assembler
% ref?
\item operating system (yep)
% ref?
\end{itemize}

This book is not an introduction to operating systems. The goal
of this book is to present in full details a kernel but we assume
you already have a vague idea of how an operating system
works and so that you are familiar with virtual memory, interrupts,
system calls, etc.

\section{About this document}
%#include "About.tex.nw"

\section{Copyright}
% most of this document is actually code from Plan9, so plan9 copyright.

\section{Acknowledgments}

Of course Plan9's authors who wrote most of this book: Ken Thompson,
Rob Pile, Russ Cox, etc.

Federic Balesteros who wrote lengthy notes about Plan9's kernel.

\chapter{Overview}

\section{Operating system principles}

An operating system is a meta-program: A program that manages other
programs.

It provides convenient abstractions of the hardware and multiplex
those hardware resources for the benefit of user programs:
\begin{itemize}
\item a virtual CPU, each process thinks it has all the CPU for himself
\item a virtual memory, each process thinks it has all memory for himself
\item a virtual screen, each process thinks it has all the screen for himself
\item a virtual storage (filesystem)
\item a virtual network (NFS)
\end{itemize}

\section{Operating system services}

\begin{verbatim}
% user point of view:
% - start the whole thing, first program!
% - process managment, shell, fork, exec, multi task
% - system calls, =~ APIs of user program
% - interrupt handling, =~ devices and also syscalls and preemptive multi task
% - IO operations, =~ devices and files
% - file managment, =~ filesystem
\end{verbatim}

%the syscalls, grouped in different sections
% process, memory, IO, fs, etc

\section{Plan9}
%plan9 specifics vs general os principles, e.g. namespace so have
% nice /dev/cons, /dev/draw, which enable easier network and graphics

\section{The machine}
%PC vs raspberry pi?

\section{Code organization}
% codemap and codegraph screenshot?

\section{Booting overview}
% kernel that creates first user process!
% introduce dichotomy kernel/user

\section{Memory overview}
% kernel vs user memory

\section{Syscall overview}
% kernel vs user code

\chapter{Core Data Structures}

\section{Mini LibC}
% bool, int, strings, unicode, etc

<<lib.h>>=

// This file mostly exports code from lib_core/libc/ (linked with the kernel).
// Those functions are also exported in include/libc.h but they prefered to
// not include it and instead to reexport here a subset specific to the kernel.

// There are also the poolxxx() functions exported in include/pool.h
// (also part of libc) that are used in memory/alloc.c.

// Some functions in libc are also "overriden" (via linker abuse):
//  - print.c overrides _fmtlock(), _fmtunlock() that were in libc/fmt/
//  - devcons.s overrides the sysfatal() that was in libc/9sys/

// pad specific, should be in u.h
typedef int bool;
typedef ushort bool_ushort;
typedef ulong bool_ulong;
enum _bool {
  false = 0,
  true = 1
};

/*
 * functions (mostly) linked in from libc.
 */

#define nelem(x)  (sizeof(x)/sizeof((x)[0]))
#define offsetof(s, m)  (ulong)(&(((s*)0)->m))
#define assert(x) if(x){}else _assert("x")

/*
 * mem routines
 */
extern  void* memccpy(void*, void*, int, ulong);
extern  void* memset(void*, int, ulong);
extern  int memcmp(void*, void*, ulong);
extern  void* memmove(void*, void*, ulong);
extern  void* memchr(void*, int, ulong);

/*
 * string routines
 */
extern  char* strchr(char*, int);
extern  char* strrchr(char*, int);
extern  int strcmp(char*, char*);
extern  char* strcpy(char*, char*);
extern  char* strecpy(char*, char*, char*);
extern  char* strncpy(char*, char*, long);
extern  int strncmp(char*, char*, long);
extern  long  strlen(char*);
extern  char* strstr(char*, char*);
extern  int atoi(char*);
extern  int fullrune(char*, int);
//unused: extern  char* strcat(char*, char*);
//unused: extern  char* strncat(char*, char*, long);

//redefined in the kernel
extern  int cistrcmp(char*, char*);
extern  int cistrncmp(char*, char*, int);

enum
{
  UTFmax    = 4,    /* maximum bytes per rune */
  Runeself  = 0x80,   /* rune and UTF sequences are the same (<) */
//unused: Runesync  = 0x80,   /* cannot represent part of a UTF sequence (<) */
//unused: Runeerror = 0xFFFD, /* decoding error in UTF */
//unused: Runemax   = 0x10FFFF, /* 24 bit rune */
//unused: Runemask  = 0x1FFFFF, /* bits used by runes (see grep) */
};

/*
 * rune routines
 */
extern  int runetochar(char*, Rune*);
extern  int chartorune(Rune*, char*);
extern  char* utfrune(char*, long);
extern  int utfnlen(char*, long);
//unused: extern  int utflen(char*);
//unused: extern  int runelen(long);

extern  int abs(int);

/*
 * print routines
 */
typedef struct Fmt  Fmt;
typedef int (*Fmts)(Fmt*);
struct Fmt{
  uchar runes;      /* output buffer is runes or chars? */
  void  *start;     /* of buffer */
  void  *to;      /* current place in the buffer */
  void  *stop;      /* end of the buffer; overwritten if flush fails */
  int (*flush)(Fmt *);  /* called when to == stop */
  void  *farg;      /* to make flush a closure */
  int nfmt;     /* num chars formatted so far */
  va_list args;     /* args passed to dofmt */
  int r;      /* % format Rune */
  int width;
  int prec;
  ulong flags;
};

// This used to be regular function, but to avoid backward deps in the kernel
// I made it into a pointer function (a bit ugly, and maybe unsafe)
extern  int (*print)(char*, ...);

extern  char* seprint(char*, char*, char*, ...);
extern  char* vseprint(char*, char*, char*, va_list);
extern  int snprint(char*, int, char*, ...);
extern  int sprint(char*, char*, ...);
//unused: extern  int vsnprint(char*, int, char*, va_list);

#pragma varargck  argpos  fmtprint  2
#pragma varargck  argpos  print   1
#pragma varargck  argpos  seprint   3
#pragma varargck  argpos  snprint   3
#pragma varargck  argpos  sprint    2

#pragma varargck  type  "lld" vlong
#pragma varargck  type  "llx" vlong
#pragma varargck  type  "lld" uvlong
#pragma varargck  type  "llx" uvlong
#pragma varargck  type  "ld"  long
#pragma varargck  type  "lx"  long
#pragma varargck  type  "ld"  ulong
#pragma varargck  type  "lx"  ulong
#pragma varargck  type  "d" int
#pragma varargck  type  "x" int
#pragma varargck  type  "c" int
#pragma varargck  type  "C" int
#pragma varargck  type  "d" uint
#pragma varargck  type  "x" uint
#pragma varargck  type  "c" uint
#pragma varargck  type  "C" uint
#pragma varargck  type  "s" char*
#pragma varargck  type  "q" char*
#pragma varargck  type  "S" Rune*
#pragma varargck  type  "%" void
#pragma varargck  type  "p" uintptr
#pragma varargck  type  "p" void*
#pragma varargck  flag  ','

extern  int fmtstrinit(Fmt*);
extern  int fmtinstall(int, int (*)(Fmt*));
extern  void  quotefmtinstall(void);
extern  int fmtprint(Fmt*, char*, ...);
extern  int fmtstrcpy(Fmt*, char*);
extern  char* fmtstrflush(Fmt*);

/*
 * one-of-a-kind
 */
extern  char* cleanname(char*);
extern  ulong getcallerpc(void*);

extern  long  strtol(char*, char**, int);
extern  ulong strtoul(char*, char**, int);
extern  vlong strtoll(char*, char**, int);
extern  uvlong  strtoull(char*, char**, int);

extern  int getfields(char*, char**, int, int, char*);
extern  int tokenize(char*, char**, int);
extern  void  qsort(void*, long, long, int (*)(void*, void*));
//unused: extern  int dec64(uchar*, int, char*, int);
//unused: extern  int encodefmt(Fmt*);


extern  char  etext[];
//@Scheck: Assembly, not dead used by 386/l.s
extern  char  edata[];
extern  char  end[];


/*
 * Syscall data structures
 */
enum mount {
  MREPL = 0x0000,  /* mount replaces object */
  MBEFORE = 0x0001,  /* mount goes before others in union directory */
  MAFTER = 0x0002,  /* mount goes after others in union directory */
  MCREATE = 0x0004,  /* permit creation in mounted directory */
  MCACHE = 0x0010,  /* cache some data */

  MORDER =  0x0003,  /* mask for bits defining order of mounting */
  MMASK = 0x0017,  /* all bits on */
};

enum open {
  OREAD = 0, /* open for read */
  OWRITE = 1, /* write */
  ORDWR = 2, /* read and write */
  OEXEC = 3, /* execute, == read but check execute permission */
  OTRUNC = 16,  /* or'ed in (except for exec), truncate file first */
  OCEXEC = 32,  /* or'ed in, close on exec */
  ORCLOSE = 64,  /* or'ed in, remove on close */
  OEXCL = 0x1000,  /* or'ed in, exclusive create */
};

enum note {
  NCONT = 0, /* continue after note */
  NDFLT = 1, /* terminate after note */
  NSAVE = 2, /* clear note but hold state */
  NRSTR = 3, /* restore saved state */
};



enum miscsize {  
  ERRMAX = 128, /* max length of error string */
  KNAMELEN = 28,  /* max length of name held in kernel */
};




/* bits in Qid.type */
enum qidtype {
  QTFILE = 0x00,    /* plain file */
  QTDIR = 0x80,    /* type bit for directories */
  QTMOUNT = 0x10,    /* type bit for mounted channel */

  QTAUTH = 0x08,    /* type bit for authentication file */
  QTAPPEND = 0x40,    /* type bit for append only files */
  QTEXCL = 0x20,    /* type bit for exclusive use files */
};

/* bits in Dir.mode */
enum dirmode {
  DMDIR = 0x80000000,  /* mode bit for directories */
  DMAPPEND = 0x40000000,  /* mode bit for append only files */
  DMEXCL = 0x20000000,  /* mode bit for exclusive use files */
  DMMOUNT = 0x10000000,  /* mode bit for mounted channel */

  DMREAD = 0x4,   /* mode bit for read permission */
  DMWRITE = 0x2,   /* mode bit for write permission */
  DMEXEC = 0x1,   /* mode bit for execute permission */
};

typedef struct Qid  Qid;
typedef struct Dir  Dir;
typedef struct OWaitmsg OWaitmsg;
typedef struct Waitmsg  Waitmsg;

struct Qid
{
  // note that this is not a string, but an int! it's kind of an inode?
  uvlong  path;
  // for cache invalidation
  ulong vers;
  // enum<qidtype>
  uchar type;
};

struct Dir {
  /* system-modified data */
  ushort  type; /* server type */
  uint  dev;  /* server subtype */

  /* file data */
  Qid qid;  /* unique id from server */
  // bitset<enum<dirmode>>
  ulong mode; /* permissions */
  ulong atime;  /* last read time */
  ulong mtime;  /* last write time */
  vlong length; /* file length: see <u.h> */
  char  *name;  /* last element of path */
  char  *uid; /* owner name */
  char  *gid; /* group name */
  char  *muid;  /* last modifier name */
};



struct Waitmsg
{
  int pid;    /* of loved one */
  ulong time[3];  /* of loved one and descendants */
  char  msg[ERRMAX];  /* actually variable-size in user mode */
};

// for byteorder agnostic marshalling?
struct OWaitmsg
{
  char  pid[12];  /* of loved one */
  char  time[3*12]; /* of loved one and descendants */
  char  msg[64];  /* compatibility BUG */
};

@ 
\section{[[Conf]]}

\section{[[Mach]]}

\section{[[Proc]]}

\section{[[Chan]]}

\section{[[Dev]]}

\chapter{Concurrency}

\section{Critical Regions}

\section{TAS}

\section{Lock}

\section{Interrupt Lock}

\section{Queue Lock}

\section{Read Write Lock}

\section{References}

\section{Rendez-vous}

\section{Semaphore}

\chapter{Memory}

\section{Overview}

\section{Xalloc}

\section{Kernel Malloc}

\section{User Malloc}
%actually brk

\section{Virtual Memory}

\section{Paging}

\section{Segments}

\section{Syscalls}

\chapter{Processes}

\section{Overview}

\section{[[Proc]]}

\section{Traps and interrupts}

\section{Clock interrupt}

\section{Scheduler}

\section{SMP}

\section{Fork}

\section{Exec}

\section{Notes (signals)}

\section{Syscalls}

\chapter{Files}

\section{Overview}

\section{Channels}

\section{Devices table}

\section{Open/read/write/close}

\section{Namespace}

\section{Syscalls}

\chapter{Initialization}

\section{Booting the kernel}

\section{Kernel initialization}

\section{The first process}

\chapter{The Console}

\chapter{Core Devices}

\section{[[devroot.c]]}

\section{[[devenv.c]]}

\section{[[devproc.c]]}

\section{[[devdup.c]] and [[devpipe.c]]}

\chapter{Devices}

\section{Screen}

\section{Keyboard}

\section{Mouse}

\section{Audio}

\section{Storage}

\chapter{Filesystem}

\section{Devfs}

\section{Ramfs}

\section{Dossrv}

\section{Devmnt and Devsrv}

\chapter{System programs}

\section{Init}

\section{The shell}

\chapter{Conclusion}

\section{Security}

\section{Network}

\section{Graphics}

\appendix

\chapter{Debugging}

\chapter{Profiling}

\chapter{Error Managment}

<<errstr.c>>=
//char Enoerror[] = "no error";
char Emount[] = "inconsistent mount";
char Eunmount[] = "not mounted";
char Eismtpt[] = "is a mount point";
char Eunion[] = "not in union";
char Emountrpc[] = "mount rpc error";
char Eshutdown[] = "device shut down";
char Enocreate[] = "mounted directory forbids creation";
char Enonexist[] = "file does not exist";
char Eexist[] = "file already exists";
char Ebadsharp[] = "unknown device in # filename";
char Enotdir[] = "not a directory";
char Eisdir[] = "file is a directory";
char Ebadchar[] = "bad character in file name";
char Efilename[] = "file name syntax";
char Eperm[] = "permission denied";
char Ebadusefd[] = "inappropriate use of fd";
char Ebadarg[] = "bad arg in system call";
char Einuse[] = "device or object already in use";
char Eio[] = "i/o error";
char Etoobig[] = "read or write too large";
char Etoosmall[] = "read or write too small";
//char Enoport[] = "network port not available";
char Ehungup[] = "i/o on hungup channel";
char Ebadctl[] = "bad process or channel control request";
char Enodev[] = "no free devices";
char Eprocdied[] = "process exited";
char Enochild[] = "no living children";
char Eioload[] = "i/o error in demand load";
char Enovmem[] = "virtual memory allocation failed";
char Ebadfd[] = "fd out of range or not open";
char Enofd[] = "no free file descriptors";
char Eisstream[] = "seek on a stream";
char Ebadexec[] = "exec header invalid";
char Etimedout[] = "connection timed out";
char Econrefused[] = "connection refused";
char Econinuse[] = "connection in use";
char Eintr[] = "interrupted";
char Enomem[] = "kernel allocate failed";
//char Enoswap[] = "swap space full";
char Esoverlap[] = "segments overlap";
char Emouseset[] = "mouse type already set";
char Eshort[] = "i/o count too small";
char Egreg[] = "jmk added reentrancy for threads";
char Ebadspec[] = "bad attach specifier";
char Enoreg[] = "process has no saved registers";
char Enoattach[] = "mount/attach disallowed";
char Eshortstat[] = "stat buffer too small";
char Ebadstat[] = "malformed stat buffer";
char Enegoff[] = "negative i/o offset";
char Ecmdargs[] = "wrong #args in control message";
char Ebadip[] = "bad ip address syntax";
char Edirseek[] = "seek in directory";
char Echange[] = "media or partition has changed";
//char Estalled[] = "endpoint stalled";
//char Edetach[] = "device is detached";
//char Enotconf[] = "endpoint not configured";
//char Eaoedown[] = "aoe device is down";
@ 

\ifallcode
<<error.h>>=
//extern char Enoerror[];   /* no error */
extern char Emount[];   /* inconsistent mount */
extern char Eunmount[];   /* not mounted */
extern char Eismtpt[];    /* is a mount point */
extern char Eunion[];   /* not in union */
extern char Emountrpc[];  /* mount rpc error */
extern char Eshutdown[];  /* device shut down */
extern char Enocreate[];  /* mounted directory forbids creation */
extern char Enonexist[];  /* file does not exist */
extern char Eexist[];   /* file already exists */
extern char Ebadsharp[];  /* unknown device in # filename */
extern char Enotdir[];    /* not a directory */
extern char Eisdir[];   /* file is a directory */
extern char Ebadchar[];   /* bad character in file name */
extern char Efilename[];  /* file name syntax */
extern char Eperm[];    /* permission denied */
extern char Ebadusefd[];  /* inappropriate use of fd */
extern char Ebadarg[];    /* bad arg in system call */
extern char Einuse[];   /* device or object already in use */
extern char Eio[];    /* i/o error */
extern char Etoobig[];    /* read or write too large */
extern char Etoosmall[];  /* read or write too small */
//extern char Enoport[];    /* network port not available */
extern char Ehungup[];    /* i/o on hungup channel */
extern char Ebadctl[];    /* bad process or channel control request */
extern char Enodev[];   /* no free devices */
extern char Eprocdied[];  /* process exited */
extern char Enochild[];   /* no living children */
extern char Eioload[];    /* i/o error in demand load */
extern char Enovmem[];    /* virtual memory allocation failed */
extern char Ebadfd[];   /* fd out of range or not open */
extern char Enofd[];    /* no free file descriptors */
extern char Eisstream[];  /* seek on a stream */
extern char Ebadexec[];   /* exec header invalid */
extern char Etimedout[];  /* connection timed out */
extern char Econrefused[];  /* connection refused */
extern char Econinuse[];  /* connection in use */
extern char Eintr[];    /* interrupted */
extern char Enomem[];   /* kernel allocate failed */
//extern char Enoswap[];    /* swap space full */
extern char Esoverlap[];  /* segments overlap */
extern char Emouseset[];  /* mouse type already set */
extern char Eshort[];   /* i/o count too small */
extern char Egreg[];    /* jmk added reentrancy for threads */
extern char Ebadspec[];   /* bad attach specifier */
extern char Enoreg[];   /* process has no saved registers */
extern char Enoattach[];  /* mount/attach disallowed */
extern char Eshortstat[]; /* stat buffer too small */
extern char Ebadstat[];   /* malformed stat buffer */
extern char Enegoff[];    /* negative i/o offset */
extern char Ecmdargs[];   /* wrong #args in control message */
extern char Ebadip[];   /* bad ip address syntax */
extern char Edirseek[];   /* seek in directory */
extern char Echange[];    /* media or partition has changed */
//extern char Estalled[];   /* endpoint stalled */
//extern char Edetach[];    /* device is detached */
//extern char Enotconf[];   /* endpoint not configured */
//extern char Eaoedown[];   /* aoe device is down */
@ 
\fi

\chapter{Mini Libc}

\section{Pool allocation}

\chapter{Extra Code}

\section{[[../include/]]}

\section{[[lib/]]}

\section{[[core/]]}

\section{[[concurrency/]]}

\section{[[memory/]]}

\section{[[processes/]]}

\section{[[files/]]}

\section{[[console/]]}

\section{[[security/]]}

\section{[[network/]]}

\section{[[devices/]]}

\section{[[filesystems/]]}

\section{[[conf/]]}

\section{[[syscalls/]]}

\section{[[init/]]}

\section{[[boot/]]}

\section{[[arch/]]}

\section{[[buses/]]}

\section{[[misc/]]}

\chapter{Changelog}
\label{sec:changelog}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
