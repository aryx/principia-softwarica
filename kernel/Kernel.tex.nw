\documentclass{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
% see also other newif in Macros.tex
\finaltrue\verbosefalse

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things :)
% - introduced syssema.c (found while going through Kernel_extra.tex.nw)

%thx to codemap/codegraph:
% - see pad.txt#reorganization section

%history LP-ization:
% - skeleton; a not too bad TOC
% - put all content of files in the Extra section, via syncweb -lpize
% - TODO split the files in chunks (for type, helpers, ...), using
%   my emacs macro
% - TODO distribute parts of the file before
% - TODO add figures (hand made)

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
 \noweboptions{}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
\usepackage{fullpage}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\implemtrue
\implemoverviewtrue

\wantrepetitivecodefalse
\allcodefalse
 % for forward decl, pragmas, 

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
The Plan9 Kernel
}\\
x86 edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 

\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3.
\end{quote}
% hmmm what about the code part?
\hrule

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real operating system (and in later books to also cover the
compiler, assembler, linker, debugger, windowing system, etc). Why?
Because I think it makes you a better programmer if you fully
understand how things work under the hood.
% a concrete companion to "Computer systems: a programmer's pespective"

The choice of plan9 may not be obvious, but it is IMHO
the simplest but at the same time fairly complete operating system.
% as simple as possible, but not simpler
If you look at the screenshot in Figure~\ref{fig:X}, you'll see
many features:
\begin{itemize}
\item a screen, with simple graphics and basic windows managment
\item the use of a mouse
\item multiple shells running multiple commands
\item a simple clock graphical application 
\item a simple program communicating through the network
\end{itemize}

By comparison if you look at the screenshot in Figure~\ref{fig:Y}
you'll see that Plan9 in essence provides the similar core services
of MacOS, Linux or Windows.
% multi tasking, graphics, windows, IO, etc

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item Unix V6 (or its modern incarnation xv6) is too simple;
there is no graphics, no network
\item TECS, excellent for understanding hardware, assemblers,
and even compilers, but the operating part is really too simple.
\item MMIX, same issue that for TECS
\item Alan's Kay STEPS project, far more ambitious as
the goal is to have a full system in 20 000 LOC, but not
finished yet.
\item Minix, bigger and does not provide a simple windowing
system as it relies on X11 (which is far more complicated than plan9
Rio windowing system)
\item Gnu/Linux, far far bigger. If you take the source code of glibc,
the Linux kernel, and X11, you'll get at
least 2 orders of magnitude more source code than Plan9, even though
Plan9 provides in essence the same core services. Of course
the Linux kernel contains thousands of specific drivers,
glibc handles many different architectures, and X11 can support
lots of graphic cards and all of those things could be discarded 
when presenting the core of those software, but their core
is still far bigger than Plan9 equivalent software.
\end{itemize}

\section{Getting started}

See \url{https://github.com/aryx/fork-plan9}
and \url{https://github.com/aryx/fork-kencc}.

%kencc install, fork-plan9 install

\section{Assumptions}

I assume you actually know a lot:
\begin{itemize}
\item C
% ref?
% see also comp.ps
\item an assembler
% ref?
% see also asm.ps
\item operating system (yep)
% ref?
\item familiarity with the PC architecture
\end{itemize}

This book is not an introduction to operating systems. The goal
of this book is to present in full details a kernel but we assume
you already have a vague idea of how an operating system
works and so that you are familiar with concepts such as 
virtual memory, critical regions, interrupts, system calls, etc.

\section{About this document}
#include "About.tex.nw"

\section{Copyright}
% most of this document is actually code from Plan9, so plan9 copyright.

\section{Acknowledgments}

I would like to acknowledge of course Plan9's authors who wrote
most of this book: Ken Thompson, Rob Pile, Dave Presotto, Phil
Winterbottom, Russ Cox, and many other people from Bell Labs.

Thanks also to Federic Balesteros who wrote a lengthy note about
Plan9's kernel that was very useful.

\chapter{Overview}

\section{Operating system principles}

An operating system is a meta-program: A program that manages other
programs.

It provides convenient abstractions of the hardware and multiplex
those hardware resources for the benefit of user programs:
\begin{itemize}
\item a virtual CPU, so that each process thinks it has all the CPU 
for himself
\item a virtual memory, so that each process thinks it has all memory
for himself
\item a virtual screen, so that each process thinks it has all the screen
for himself
\item a virtual storage (filesystem)
\item a virtual network (NFS)
\end{itemize}

\section{Operating system services}

\begin{verbatim}
 user point of view:
 - start the whole thing, first program!
 - process managment, shell, fork, exec, multi task
 - system calls, =~ APIs of user program
 - interrupt handling, =~ devices and also syscalls and preemptive multi task
 - IO operations, =~ devices and files
 - file managment, =~ filesystem
\end{verbatim}

%the syscalls, grouped in different sections
% process, memory, IO, fs, etc

\section{Plan9}
%plan9 specifics vs general os principles, e.g. namespace so have
% nice /dev/cons, /dev/draw, which enable easier network and graphics

% see 9.ps

%TODO
%things plan9 make so much easier to implement/understand:
% tty
% X11, xterm
% nfs
% fuse
%
%Plan9 approach is good? abuse files? could use different API?
%For instance /dev/draw has a very specific format, so it's
%a bit abusing files.
%But at the same time one for sure needs to store things in files,
%so one need files, at which point you want to define the minimum of 
%concepts and so make files more generic => device can be files,
%but also pipes, etc, and so plan9 just push to its conclusion
%this idea.

\section{The machine}
%PC vs raspberry pi?

\section{Code organization}
% codemap and codegraph screenshot?

<<kernel basic includes>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"
@ 


<<dat.h>>=
#include "dat_forward.h"
#include "../port/portdat_forward.h"

<<enum miscsize_dat>>

// defines Lock (used inline in Mach in portdat_core.h so must be before)
#include "../port/portdat_concurrency.h"

// defines Conf, Mach
#include "dat_core.h"
#include "../port/portdat_core.h"

// defines Page
#include "dat_memory.h"
#include "../port/portdat_memory.h"

// defines Chan
#include "../port/portdat_files.h"

#include "dat_arch.h"

// defines Proc
#include "dat_processes.h"
#include "../port/portdat_processes.h"

// defines Cmd (use ??)
#include "../port/portdat_misc.h"

// defines Uart
#include "dat_buses.h"
#include "../port/portdat_buses.h"

#include "../port/portdat_console.h"

#include "../port/portdat.h"

<<constant AOUT_MAGIC>>

<<enum misc_dat>>
@

<<fns.h>>=
#include "../port/portfns.h"

<<fns.h declarations>>
@

<<portfns.h>>=

#include "../port/portfns_core.h"
#include "../port/portfns_concurrency.h"
#include "../port/portfns_memory.h"
#include "../port/portfns_files.h"
#include "../port/portfns_processes.h"
#include "../port/portfns_misc.h"
#include "../port/portfns_console.h"
#include "../port/portfns_buses.h"
#include "../port/portfns_devices.h"
#include "../port/portfns_security.h"
#include "../port/portfns_network.h"
#include "../port/portfns_init.h"

@

\section{Booting overview}
% kernel that creates first user process!
% introduce dichotomy kernel/user

% there is booting the kernel, booting the kernel environment,
%  and then booting the user environment, and finally booting user programs

\section{Memory overview}
% kernel vs user memory
% dynamic vs static (the static allocator so can bootstrap things)

%need precise physical map of memory
%
%with first empty page?, idtr, gdt, pdb intel, pte intel, 
%io RAM, vga ram,  then KZERO header, KTZERO, 
%code,  data with important globals like xlist, and array holes,
%palloc with pointer page, and then on top of that confmem area
%
%the data section of the kernel binary is as important as
%the code section. For the code section can also give name
%of procedures, and devtab (in data section) pointing back to it
%via the static "classes" in the data section again).
%
%need also precise virtual map of memory for regular process,
% actually for 2 processes
%
%need also precise virtual map of memory for first handcrafted process?
%

\section{Syscall overview}
% kernel vs user code

<<systab.h>>=
// used by systab.c but also by trap.c for certain codes
#include "/sys/src/libc/9syscall/sys.h"

<<typedef Syscall>>

extern Syscall *systab[];
extern int nsyscall;
extern char *sysctab[];
@

<<typedef Syscall>>=
typedef long Syscall(ulong*);
@

<<global systab>>=
Syscall *systab[] = {
    [SYSR1]     sysr1,
    [_ERRSTR]   sys_errstr,
    [BIND]      sysbind,
    [CHDIR]     syschdir,
    [CLOSE]     sysclose,
    [DUP]       sysdup,
    [ALARM]     sysalarm,
    [EXEC]      sysexec,
    [EXITS]     sysexits,
    [_FSESSION] sys_fsession,
    [FAUTH]     sysfauth,
    [_FSTAT]    sys_fstat,
    [SEGBRK]    syssegbrk,
    [_MOUNT]    sys_mount,
    [OPEN]      sysopen,
    [_READ]     sys_read,
    [OSEEK]     sysoseek,
    [SLEEP]     syssleep,
    [_STAT]     sys_stat,
    [RFORK]     sysrfork,
    [_WRITE]    sys_write,
    [PIPE]      syspipe,
    [CREATE]    syscreate,
    [FD2PATH]   sysfd2path,
    [BRK_]      sysbrk_,
    [REMOVE]    sysremove,
    [_WSTAT]    sys_wstat,
    [_FWSTAT]   sys_fwstat,
    [NOTIFY]    sysnotify,
    [NOTED]     sysnoted,
    [SEGATTACH] syssegattach,
    [SEGDETACH] syssegdetach,
    [SEGFREE]   syssegfree,
    [SEGFLUSH]  syssegflush,
    [RENDEZVOUS]    sysrendezvous,
    [UNMOUNT]   sysunmount,
    [_WAIT]     sys_wait,
    [SEMACQUIRE]    syssemacquire,
    [SEMRELEASE]    syssemrelease,
    [SEEK]      sysseek,
    [FVERSION]  sysfversion,
    [ERRSTR]    syserrstr,
    [STAT]      sysstat,
    [FSTAT]     sysfstat,
    [WSTAT]     syswstat,
    [FWSTAT]    sysfwstat,
    [MOUNT]     sysmount,
    [AWAIT]     sysawait,
    [PREAD]     syspread,
    [PWRITE]    syspwrite,
    [TSEMACQUIRE]   systsemacquire,
};
int nsyscall = nelem(systab);
@

\chapter{Core Data Structures}

% mini libc: bool, int, strings, unicode, etc

\section{[[Conf]]}

\section{[[Mach]]}

\section{[[Proc]]}

\section{[[Chan]]}

\section{[[Dev]]}

\chapter{Concurrency}

\section{Critical Regions}

\begin{verbatim}
 There are different code "regions": 
 - user code, 
 - kernel init code
 - kernel code of kernel processes (e.g. the alarm kernel process)
 - kernel code of syscalls (soft interrupt), 
 - kernel code of interrupt handlers (hard interrupt).

 There is no mutual exclusion need between user and kernel code. 
 Same for init code as only one processor is used during the
 uninterrupted sequential initialization.

 For the kernel code one wants mutual exclusion because of possible race 
 on shared data structures between the syscalls themselves when run
 on different processors (or even when run on one processor as one syscall
 can be interrupted causing a scheduling that will then lead later to
 another syscall), but also between the syscalls and interrupts.
 The flow of control on one processor can be 
  - User -> Syscall, 
  - User -> Interrupt,
  - or even User -> Syscall -> Interrupt. 
  - one can even have User -> Syscall -> Interrupt -> Interrupt!!
 This is on one processor. Multiple processors lead to more combinations
 where 2 processors can run at the same time 2 interrupt handlers for instance.
 
 One must take care when using locks inside interrupts as one can deadlock
 if the same lock was used in the enclosing syscall (hence ilock/iunlock)

\end{verbatim}

\section{TAS}

\section{Lock}

\section{Interrupt Lock}
% can formalize a checking rule? if access any field
% accessed from a xxxintr, then need to use ilock

\section{Queue Lock}

\section{Read Write Lock}

\section{References}

\section{Synchronization}
% different from critical regions

% see sleep.ps in plan9 documents

\section{Rendez-vous}

\section{Semaphore}

\chapter{Memory}

\section{Overview}
% kernel vs user memory

\section{Pool Allocation}

\section{Xalloc}

\section{Kernel Malloc}

\section{User Malloc}
%actually brk

\section{Virtual Memory}

\section{Paging}

\section{Segments}

\section{Syscalls}

\chapter{Processes}

\section{Overview}

\section{[[Proc]]}

\section{Context switch}

\section{Traps and interrupts}

\section{Clock interrupt}

\section{Scheduler}

\section{SMP}

\section{Fork}

\section{Exec}

\section{Notes (signals)}

\section{Semaphores}

\section{Syscalls}

\chapter{Files}

\section{Overview}

\section{Channels}

\section{Device table}

\section{[[create/open/read/write/close]]}

\section{Syscalls}

\chapter{Namespace}

% see names.ps
% see lexnames.ps

\section{Overview}

\section{Bind}

\section{Mount}

\section{Syscalls}

\chapter{Initialization}

\section{Booting the kernel}

\section{Kernel initialization}

\section{The first process}

\chapter{The Console}

\section{Overview}

\section{Input}

\section{Output}

\chapter{System Devices}

\section{[[devroot.c]]}

%#/

\section{[[devenv.c]]}

%#e

\section{[[devproc.c]]}

%#p


\section{[[devdup.c]] and [[devpipe.c]]}
%optional, advanced concepts

\chapter{External Devices}

\section{Screen}
% just cga.c here, see Window.tex.nw for the advanced vga kernel support

\section{Keyboard}

\section{Mouse}

\section{Audio}

\section{Storage}

\chapter{Filesystem}

\section{Devfs}

\section{Ramfs}

\section{Dossrv}

\section{Devmnt and Devsrv}

\chapter{System programs}

\section{[[boot]]}

\section{[[init]]}

\section{The shell}

\chapter{Conclusion}

% already 900 pages ... so network in another volume

\section{Security}

\section{Network}
% put also RPC and devmnt here?

\section{Graphics}

\appendix

\chapter{Debugging}
% printf? all this fmt stuff?

% rdb?

% what to do when have panic, e.g. when I mixed some fields
% and I got a pc error, how do I fix it? how do I find the relevant code?

\chapter{Profiling}

% devkprof.c?

\chapter{Error Managment}

% waserror(), nexterror(), etc
% =~ poor's man exn mechanism (=> improve C!!)

\chapter{Mini Libc}

\section{Pool allocation}

\chapter{Extra Code}

%\ifallcode
#include "Kernel_extra.tex.nw"
%\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
up = user process

pc = program counter

spl = set priority level

ilock = interrupt safe version of lock (disable interruptions)

umb = upper memory block

RMAP = RAM map

PDB = page directory base

PTE = page table entry

tod = time of day

ap = application processor

EDF = Earliest Deadline First
http://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling

RPC = remote procedure call

EGRP = Environment group

FGRP = File descriptor Group (chans)

PGRP = Process Group (namespace)

VNO = Vector number (interrupt)

ISR = Interrupt Service Routine

TSC = Time Stamp Counter
http://en.wikipedia.org/wiki/Time_Stamp_Counter

intr = Interrupt (not INT, probably to avoid ambiguity with integer)

APIC = Advanded Programmable Interrupt Controller (a next gen 8259)

ACPI = Advanced Configuration & Power Interface

\end{verbatim}
%cistrcmp= ??


\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
