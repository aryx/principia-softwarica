\documentclass{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
% see also other newif in Macros.tex
\finaltrue\verbosefalse

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things :)
% - introduced syssema.c (found while going through Kernel_extra.tex.nw)

%thx to codemap/codegraph:
% - see pad.txt#reorganization section

%history LP-ization:
% - skeleton; a not too bad TOC
% - put all content of files in the Extra section, via syncweb -lpize
% - TODO split the files in chunks (for type, helpers, ...), using
%   my emacs macro,  function, global, struct, xxx decl, method (for Dev)
% - TODO distribute parts of the file before
% - TODO add figures (hand made)

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
 \noweboptions{}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
\usepackage{fullpage}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\implemtrue
\implemoverviewtrue

\wantrepetitivecodefalse
\allcodefalse
 % for typedef forward decl, pragmas, func decl, extern decl, stats, #ifdef

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
The Plan9 Kernel
}\\
x86 (32 bits) edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 

\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3.
\end{quote}
% hmmm what about the code part?
\hrule

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real operating system\footnote{and in later books to also cover the
compiler, assembler, linker, debugger, windowing system, network
stack, etc}. Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.
% a concrete companion to "Computer systems: a programmer's pespective"

The choice of plan9 may not be obvious, but it is IMHO
the simplest and at the same time fairly complete operating system.
% as simple as possible, but not simpler
If you look at the screenshot in Figure~\ref{fig:X}, you'll see
many features:
\begin{itemize}
\item a screen with basic graphics and windows managment
\item multiple shells running multiple commands
\item a simple clock graphical application
\item a simple program communicating through the network
\end{itemize}

By comparison if you look at the screenshot in Figure~\ref{fig:Y}
you'll see that Plan9 in essence provides the similar core services
of MacOS, Linux or Windows.
% multi tasking, graphics, windows, IO, etc

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item Unix V6 (or its modern incarnation xv6) is too simple;
there is no graphics, no network
\item TECS, excellent for understanding hardware, assemblers,
and even compilers, but the operating part is really too simple
\item MMIX, same issue that for TECS
\item Alan's Kay STEPS project, far more ambitious as
the goal is to have a full system in 20 000 LOC, but not
finished yet.
\item Minix, bigger and does not provide a simple windowing
system as it relies on X11 (which is far more complicated than plan9
Rio windowing system)
\item Gnu/Linux, far far bigger. If you take the source code of glibc,
the Linux kernel, and X11, you'll get at
least 2 orders of magnitude more source code than Plan9, even though
Plan9 provides in essence the same core services. Of course
the Linux kernel contains thousands of specific drivers,
glibc handles many different architectures, and X11 can support
lots of graphic cards and all of those things could be discarded 
when presenting the core of those software, but their core
is still far bigger than Plan9 equivalent core.
\end{itemize}

\section{Getting started}

See \url{https://github.com/aryx/fork-plan9}
and \url{https://github.com/aryx/fork-kencc}.
%kencc install, fork-plan9 install

\section{Assumptions}

I assume you actually know a lot:
\begin{itemize}
\item C
% ref?
% see also comp.ps
\item an assembler
% ref?
% see also asm.ps
\item operating system (yep)
% ref?
\item familiarity with the PC architecture
\end{itemize}

This book is not an introduction to operating systems. The goal
of this book is to present in full details a kernel but we assume
you already have a vague idea of how an operating system
works and so that you are familiar with concepts such as 
virtual memory, critical regions, interrupts, system calls, etc.

\section{About this document}
#include "About.tex.nw"

\section{Copyright}
% most of this document is actually code from Plan9, so plan9 copyright.

\section{Acknowledgments}

I would like to acknowledge of course Plan9's authors who wrote
most of this book: Ken Thompson, Rob Pile, Dave Presotto, Phil
Winterbottom, Russ Cox, and many other people from Bell Labs.

Thanks also to Federic Balesteros who wrote a lengthy note about
Plan9's kernel that was very useful.

\chapter{Overview}

\section{Operating system principles}

An operating system is a meta-program: A program that manages other
programs.

It provides convenient abstractions of the hardware and multiplex
those hardware resources for the benefit of user programs:
\begin{itemize}
\item a virtual CPU, so that each process thinks it has all the CPU 
for himself
\item a virtual memory, so that each process thinks it has all memory
for himself
\item a virtual screen, so that each process thinks it has all the screen
for himself
\item a virtual storage (filesystem)
\item a virtual network (NFS)
\end{itemize}

\section{Operating system services}

\begin{verbatim}
 user point of view:
 - start the whole thing, first program!
 - process managment, shell, fork, exec, multi task
 - system calls, =~ APIs of user program
 - interrupt handling, =~ devices and also syscalls and preemptive multi task
 - IO operations, =~ devices and files
 - file managment, =~ filesystem
\end{verbatim}

%the syscalls, grouped in different sections
% process, memory, IO, fs, etc

\section{Plan9}
%plan9 specifics vs general os principles, e.g. namespace so have
% nice /dev/cons, /dev/draw, which enable easier network and graphics

% see 9.ps, excellent introduction to Plan9 advanced features

%TODO
%things plan9 make so much easier to implement/understand:
% tty
% X11, xterm
% nfs
% fuse
%
%Plan9 approach is good? abuse files? could use different API?
%For instance /dev/draw has a very specific format, so it's
%a bit abusing files.
%But at the same time one for sure needs to store things in files,
%so one need files, at which point you want to define the minimum of 
%concepts and so make files more generic => device can be files,
%but also pipes, etc, and so plan9 just push to its conclusion
%this idea.

\section{The machine}
%PC vs raspberry pi?

\section{Code organization}

% codemap and codegraph screenshot?

<<kernel basic includes>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"
@ 


<<dat.h>>=
#include "dat_forward.h"
#include "../port/portdat_forward.h"

<<enum miscsize_dat>>

// defines Lock (used inline in Mach in portdat_core.h so must be before)
#include "../port/portdat_concurrency.h"

// defines Conf, Mach
#include "dat_core.h"
#include "../port/portdat_core.h"

// defines Page
#include "dat_memory.h"
#include "../port/portdat_memory.h"

// defines Chan
#include "../port/portdat_files.h"

#include "dat_arch.h"

// defines Proc
#include "dat_processes.h"
#include "../port/portdat_processes.h"

// defines Cmd
#include "../port/portdat_misc.h"

// defines Uart
#include "dat_buses.h"
#include "../port/portdat_buses.h"

#include "../port/portdat_console.h"

#include "../port/portdat.h"

<<constant AOUT_MAGIC>>

<<enum misc_dat>>
@

<<fns.h>>=
#include "../port/portfns.h"

<<fns.h declarations>>
@

<<portfns.h>>=
#include "../port/portfns_core.h"
#include "../port/portfns_concurrency.h"
#include "../port/portfns_memory.h"
#include "../port/portfns_files.h"
#include "../port/portfns_processes.h"
#include "../port/portfns_misc.h"
#include "../port/portfns_console.h"
#include "../port/portfns_buses.h"
#include "../port/portfns_devices.h"
#include "../port/portfns_security.h"
#include "../port/portfns_network.h"
#include "../port/portfns_init.h"
@

\section{Booting overview}
% kernel that creates first user process!
% introduce dichotomy kernel/user

% there is booting the kernel, booting the kernel environment,
%  and then booting the user environment, and finally booting user programs

% see also:
% http://arjunsreedharan.org/post/82710718100/kernel-101-lets-write-a-kernel

% steps:
% - hardware detection, populate Conf
% - initialization, populate allocators
% - create first process

% then user/preboot setup env, boot is responbile to mount root
% and then init assumes a root and setup last things.

\section{Memory overview}
% kernel vs user memory
% dynamic vs static (the static allocator so can bootstrap things)

%need precise physical map of memory
%
%with first empty page?, idtr, gdt, pdb intel, pte intel, 
%io RAM, vga ram,  then KZERO header, KTZERO, 
%code,  data with important globals like xlist, and array holes,
%palloc with pointer page, and then on top of that confmem area
%
%the data section of the kernel binary is as important as
%the code section. For the code section can also give name
%of procedures, and devtab (in data section) pointing back to it
%via the static "classes" in the data section again).
%
%need also precise virtual map of memory for regular process,
% actually for 2 processes
%
%need also precise virtual map of memory for first handcrafted process?
%

\section{Syscall overview}
% kernel vs user code

% sequence diagram?

<<typedef Syscall>>=
typedef long Syscall(ulong*);
@

<<systab.h>>=
// used by systab.c but also by trap.c for certain codes
#include "/sys/src/libc/9syscall/sys.h"

<<typedef Syscall>>

extern Syscall *systab[];
extern int nsyscall;
extern char *sysctab[];
@


<<global systab>>=
Syscall *systab[] = {
    [SYSR1]     sysr1,
    [_ERRSTR]   sys_errstr,
    [BIND]      sysbind,
    [CHDIR]     syschdir,
    [CLOSE]     sysclose,
    [DUP]       sysdup,
    [ALARM]     sysalarm,
    [EXEC]      sysexec,
    [EXITS]     sysexits,
    [_FSESSION] sys_fsession,
    [FAUTH]     sysfauth,
    [_FSTAT]    sys_fstat,
    [SEGBRK]    syssegbrk,
    [_MOUNT]    sys_mount,
    [OPEN]      sysopen,
    [_READ]     sys_read,
    [OSEEK]     sysoseek,
    [SLEEP]     syssleep,
    [_STAT]     sys_stat,
    [RFORK]     sysrfork,
    [_WRITE]    sys_write,
    [PIPE]      syspipe,
    [CREATE]    syscreate,
    [FD2PATH]   sysfd2path,
    [BRK_]      sysbrk_,
    [REMOVE]    sysremove,
    [_WSTAT]    sys_wstat,
    [_FWSTAT]   sys_fwstat,
    [NOTIFY]    sysnotify,
    [NOTED]     sysnoted,
    [SEGATTACH] syssegattach,
    [SEGDETACH] syssegdetach,
    [SEGFREE]   syssegfree,
    [SEGFLUSH]  syssegflush,
    [RENDEZVOUS]    sysrendezvous,
    [UNMOUNT]   sysunmount,
    [_WAIT]     sys_wait,
    [SEMACQUIRE]    syssemacquire,
    [SEMRELEASE]    syssemrelease,
    [SEEK]      sysseek,
    [FVERSION]  sysfversion,
    [ERRSTR]    syserrstr,
    [STAT]      sysstat,
    [FSTAT]     sysfstat,
    [WSTAT]     syswstat,
    [FWSTAT]    sysfwstat,
    [MOUNT]     sysmount,
    [AWAIT]     sysawait,
    [PREAD]     syspread,
    [PWRITE]    syspwrite,
    [TSEMACQUIRE]   systsemacquire,
};
int nsyscall = nelem(systab);
@

\chapter{Core Data Structures}

% mini libc: bool, int, strings, unicode, etc

\section{[[Conf]]}

<<struct Conf>>=
struct Conf
{
    ulong nmach;    /* processors */
    ulong nproc;    /* processes */
    Confmem mem[4];   /* physical memory */

    <<Conf extra fields>>
  
    struct ArchConf;
};
@ 

%    // in bcm/ it's mem[1], important? why 4?

<<global conf>>=
Conf conf;
@ 

<<globals confname and confvar>>=
// conf (boot) parameters *e.g. { "*kernelpercent*" => "60" }
// hash<string, string>
char *confname[MAXCONF];
char *confval[MAXCONF];
// Hashtbl.length(confname)
int nconf;
@ 

<<constant MAXCONF>>=
#define MAXCONF         64
@ 


<<struct Confmem>>=
// memory "bank"
struct Confmem
{
    ulong base; // phys?
    ulong npage;
  
    ulong kbase; // phys?
    ulong klimit; // phys?
};
@ 


\section{[[Mach]]}

<<struct Mach>>=
struct Mach
{
    int machno;     /* physical id of processor (KNOWN TO ASSEMBLY) */
    // must be second field at 0x04, used by splhi()
    ulong splpc;      /* pc of last caller to splhi */
  
    // ref<Proc>
    Proc* proc;     /* current process on this processor */

    <<Mach extra fields>>

    struct ArchMach;
  
    int stack[1];
};
@ 


<<global m>>=
Mach *m;
@ 


<<global machp>>=
/*
 * Each processor sees its own Mach structure at address MACHADDR.
 * However, the Mach structures must also be available via the per-processor
 * MMU information array machp, mainly for disambiguation and access to
 * the clock which is only maintained by the bootstrap processor (0).
 */
// array<ref<Mach>>, MAXMACH is defined in 386/mem.h
Mach* machp[MAXMACH];
@ 

<<macro MACHP>>=
#define MACHP(n)  (machp[n])
@

% externup is in ArchMach, so put here?

<<macro up>>=
// up = user process, MACHADDR is defined in 386/mem.h
#define up  (((Mach*)MACHADDR)->externup)
@

%//TODO: mv in 386/ TODO: why not m->externup? m is not valid?

\section{[[Proc]]}

<<struct Proc>>=
// the most important fields are set by newproc()
struct Proc
{
//--------------------------------------------------------------------
// Assembly requirements, Low level, have to be first
//--------------------------------------------------------------------
    <<Proc assembly fields>>
//--------------------------------------------------------------------
// State
//--------------------------------------------------------------------
    <<Proc state fields>>
//--------------------------------------------------------------------
// Memory
//--------------------------------------------------------------------
    <<Proc memory fields>>
//--------------------------------------------------------------------
// Scheduling
//--------------------------------------------------------------------
    <<Proc scheduling fields>>
//--------------------------------------------------------------------
// Files
//--------------------------------------------------------------------
    <<Proc files fields>>
//--------------------------------------------------------------------
// Notes
//--------------------------------------------------------------------
    <<Proc notes fields>>
//--------------------------------------------------------------------
// Process hierarchy
//--------------------------------------------------------------------
    <<Proc hierarchy fields>>
//--------------------------------------------------------------------
// Synchronization
//--------------------------------------------------------------------
    <<Proc synchronization fields>>
//--------------------------------------------------------------------
// Error managment
//--------------------------------------------------------------------
    <<Proc error managment fields>>
//--------------------------------------------------------------------
// Stats, profiling
//--------------------------------------------------------------------
    <<Proc stats and profiling fields>>
//--------------------------------------------------------------------
// For debugger
//--------------------------------------------------------------------
    <<Proc debugger fields>>
//--------------------------------------------------------------------
// Other
//--------------------------------------------------------------------
    <<Proc other fields>>
//--------------------------------------------------------------------
// Extra
//--------------------------------------------------------------------
    <<Proc extra fields>>
};
@ 

\section{[[Chan]]}

<<struct Chan>>=
struct Chan
{
    ushort  type; // idx in devtab?
    Qid qid;
    vlong offset;     /* in fd */
    ushort  mode;     /* read/write */

    <<Chan other fields>>

    // Extra
    <<Chan extra fields>>
};
@ 

\section{[[Dev]]}


<<struct Dev>>=
struct Dev
{
    int dc; // dev character code, e.g. '/' (devroot), 'e' (devenv), ...
    char* name;
    
    void  (*reset)(void);
    void  (*init)(void);
    void  (*shutdown)(void);
    Chan* (*attach)(char*);

    Walkqid*(*walk)(Chan*, Chan*, char**, int);

    void  (*create)(Chan*, char*, int, ulong);
    void  (*remove)(Chan*);

    Chan* (*open)(Chan*, int);
    void  (*close)(Chan*);
    long  (*read)(Chan*, void*, long, vlong);
    long  (*write)(Chan*, void*, long, vlong);

    Block* (*bread)(Chan*, long, ulong);
    long  (*bwrite)(Chan*, Block*, ulong);

    int (*stat)(Chan*, uchar*, int);
    int (*wstat)(Chan*, uchar*, int);

    void  (*power)(bool);  /* power mgt: power(1) => on, power (0) => off */
    int (*config)(int, char*, DevConf*);  /* returns nil on error */

    <<Dev other fields>>
};
@ 

<<global devtab decl>>=
extern Dev** devtab;
@

% ex of conf_devtab:
%Dev* conf_devtab[]={
%	&rootdevtab,
%	&consdevtab,
%       ...

\chapter{Concurrency}

\section{Critical Regions}

\begin{verbatim}
 There are different code "regions": 
 - user code, 
 - kernel init code
 - kernel code of kernel processes (e.g. the alarm kernel process)
 - kernel code of syscalls (soft interrupt), 
 - kernel code of interrupt handlers (hard interrupt).

 There is no mutual exclusion need between user and kernel code. 
 Same for init code as only one processor is used during the
 uninterrupted sequential initialization.

 For the kernel code one wants mutual exclusion because of possible race 
 on shared data structures between the syscalls themselves when run
 on different processors (or even when run on one processor as one syscall
 can be interrupted causing a scheduling that will then lead later to
 another syscall), but also between the syscalls and interrupts.
 The flow of control on one processor can be 
  - User -> Syscall, 
  - User -> Interrupt,
  - or even User -> Syscall -> Interrupt. 
  - one can even have User -> Syscall -> Interrupt -> Interrupt!!
 This is on one processor. Multiple processors lead to more combinations
 where 2 processors can run at the same time 2 interrupt handlers for instance.
 
 One must take care when using locks inside interrupts as one can deadlock
 if the same lock was used in the enclosing syscall (hence ilock/iunlock)

 For protecting kernel syscall code from interrupt kernel code: splhi(), splo()
 For very small critical region: taslock
 For bigger region, or when have lots of contention on a lock: qlock

\end{verbatim}

\section{TAS}

\section{Lock}

\section{Interrupt Lock}
% can formalize a checking rule? if access any field
% accessed from a xxxintr, then need to use ilock

\section{Queue Lock}

\section{Read Write Lock}

\section{References}

\section{Synchronization}
% different from critical regions

% see sleep.ps in plan9 documents

\section{Rendez-vous}

\section{Semaphore}



\chapter{Memory}

\section{Overview}
% kernel vs user memory

\section{Pool Allocation}

\section{Xalloc}

\section{Kernel Malloc}

\section{User Malloc}
%actually brk

\section{Virtual Memory}

\section{[[Page]]}

\section{Segments}

\section{Syscalls}




\chapter{Processes}

\section{Overview}

\section{[[Proc]]}

\section{Context switch}

\section{Traps and interrupts}

\section{Clock interrupt}

\section{Scheduler}

\section{SMP}

\section{Fork}

\section{Exec}

\section{Notes (signals)}

\section{Semaphores}

\section{Syscalls}




\chapter{Files}

\section{Overview}

\section{Channels}

\section{Device table}

\section{[[create/open/read/write/close]]}

\section{Syscalls}




\chapter{Namespace}

% see names.ps
% see lexnames.ps

\section{Overview}

\section{Bind}

\section{Mount}

\section{Syscalls}



\chapter{Initialization}

\section{Booting the kernel}

\section{Kernel initialization}

\section{The first process}

\section{Booting the user}
% see section on Userspace system programs

\chapter{The Console Device}

\section{Overview}

\section{Input}

\section{Output}

\section{[[devcons.c]]}



\chapter{System Devices}

\section{[[devroot.c]]}

% just with that we can already have a working environment
% with a memory fs! where all binaries are processed via data2txt

%#/

\section{[[devenv.c]]}

%#e

\section{[[devproc.c]]}

%#p


\chapter{External Devices}

\section{Screen}
% just cga.c here, see Window.tex.nw for the advanced vga kernel support

\section{Keyboard}

\section{Mouse}

\section{Audio}

\section{Storage}



\chapter{Special Devices}
%optional, advanced concepts

\section{[[devdup.c]]}

\section{[[devpipe.c]]}

\section{[[devmnt.c]]}

\section{[[devsrv.c]]}




\chapter{Filesystem}

\section{[[devfs.c]]}

\section{Ramfs}

\section{Dossrv}



\chapter{Userspace System Programs}

\section{[[boot]]}

\section{[[init]]}
% user init, != kernel init

\section{The shell}




\chapter{Conclusion}

% already 900 pages ... so network in another volume

\section{Security}

\section{Network}
% put also RPC and devmnt here?

\section{Graphics}

\appendix

\chapter{Debugging}

% what to do when have panic, e.g. when I mixed some fields
% and I got a pc error, how do I fix it? how do I find the relevant code?

% rdb.c

% see also printf section all this fmt stuff


\chapter{Profiling}

% devkprof.c?

\chapter{Error Managment}

% waserror(), nexterror(), etc
% =~ poor's man exn mechanism (=> improve C!!)

\chapter{Mini Libc}

\section{Pool allocation}

% set things from lib_core/libc/...?pool.c mainmem? imagmem?

\section{Printf and Fmt}

% see print.c which overrides functions defined in lib_core/libc/fmt/fmtlock.c 

\chapter{Extra Code}

%\ifallcode
#include "Kernel_extra.tex.nw"
%\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
up = user process

pc = program counter

spl = set priority level

ilock = interrupt safe version of lock (disable interruptions)

umb = upper memory block

RMAP = RAM map

PDB = page directory base

PTE = page table entry

tod = time of day

ap = application processor

EDF = Earliest Deadline First
http://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling

RPC = remote procedure call

EGRP = Environment group

FGRP = File descriptor Group (chans)

PGRP = Process Group (namespace)

VNO = Vector number (interrupt)

ISR = Interrupt Service Routine

TSC = Time Stamp Counter
http://en.wikipedia.org/wiki/Time_Stamp_Counter

intr = Interrupt (not INT, probably to avoid ambiguity with integer)

APIC = Advanded Programmable Interrupt Controller (a next gen 8259)

ACPI = Advanced Configuration & Power Interface

\end{verbatim}
%cistrcmp= ??


\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
