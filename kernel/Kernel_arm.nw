\part{Files}

\section{[[../include/arch/arm/]]}

\subsection*{[[../include/arch/arm/ureg.h]]}

% Why not under bcm/? Used outside the kernel? in Debugger.nw?
% (ask codegraph!)

%-------------------------------------------------------------

<<arm/ureg.h>>=
typedef struct Ureg Ureg;
<<struct Ureg(arm)>>
@

\section{[[arch/arm/]]}

\subsection*{[[arch/arm/dat_arch.h]]}

%-------------------------------------------------------------

<<arch/arm/dat_arch.h>>=

<<struct Soc(arm)>>

extern Soc soc;
@


\subsection*{[[arch/arm/arm.h]]}


<<[[CpCONTROL.opcode2]] other cases(arm)>>=
#define CpAuxctl    1
#define CpCPaccess  2
@

<<type CpCONTROL CpAuxctl(arm)>>=
/*
 * CpCONTROL: op1==0, CRm==0, op2==CpAuxctl.
 * Auxiliary control register on cortex at least.
 */
#define CpACcachenopipe     (1<<20) /* don't pipeline cache maint. */
#define CpACcp15serial      (1<<18) /* serialise CP1[45] ops. */
#define CpACcp15waitidle    (1<<17) /* CP1[45] wait-on-idle */
#define CpACcp15pipeflush   (1<<16) /* CP1[45] flush pipeline */
#define CpACneonissue1      (1<<12) /* neon single issue */
#define CpACldstissue1      (1<<11) /* force single issue ld, st */
#define CpACissue1      (1<<10) /* force single issue */
#define CpACnobsm       (1<<7)  /* no branch size mispredicts */
#define CpACibe         (1<<6)  /* cp15 invalidate & btb enable */
#define CpACl1neon      (1<<5)  /* cache neon (FP) data in L1 cache */
#define CpACasa         (1<<4)  /* enable speculative accesses */
#define CpACl1pe        (1<<3)  /* l1 cache parity enable */
#define CpACl2en        (1<<1)  /* l2 cache enable; default 1 */

/* cortex-a7 and cortex-a9 */
#define CpACsmp         (1<<6)  /* SMP l1 caches coherence; needed for ldrex/strex */
#define CpACl1pctl      (3<<13) /* l1 prefetch control */
@
% >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >>

<<type CpCONTROL secondary registers(arm)>>=
/*
 * CpCONTROL Secondary (CRm) registers and opcode2 fields.
 */
#define CpCONTROLscr    1
@

<<type CpCONTROL opcode2 bis(arm)>>=
#define CpSCRscr    0
@


<<type CpTTB(arm)>>=
/*
 * CpTTB op1==0, Crm==0 opcode2 values.
 */
#define CpTTB0      0
#define CpTTB1      1           /* cortex */
#define CpTTBctl    2           /* cortex */
@



<<type CpTLB secondary registers(arm)>>=
/*
 * CpTLB Secondary (CRm) registers and opcode2 fields.
 */
#define CpTLBinvi   5           /* instruction */
#define CpTLBinvd   6           /* data */
#define CpTLBinvu   7           /* unified */
@

<<type CpTLB opcode2(arm)>>=
#define CpTLBinv    0           /* invalidate all */
#define CpTLBinvse  1           /* invalidate single entry */
#define CpTBLasid   2           /* by ASID (cortex) */
@

<<type CpSPM secondary registers(arm)>>=
/*
 * CpSPM Secondary (CRm) registers and opcode2 fields (armv6)
 */
#define CpSPMperf   12          /* various counters */
@

<<type CpSPM opcode2(arm)>>=
#define CpSPMctl    0           /* performance monitor control */
#define CpSPMcyc    1           /* cycle counter register */
@

<<type CpCLD secondary registers(arm)>>=
/*
 * CpCLD Secondary (CRm) registers and opcode2 fields for op1==0. (cortex)
 */
#define CpCLDena    12          /* enables */
#define CpCLDcyc    13          /* cycle counter */
#define CpCLDuser   14          /* user enable */
@

<<type CpCLD opcode2(arm)>>=
#define CpCLDenapmnc    0
#define CpCLDenacyc 1
@

%-------------------------------------------------------------


<<arch/arm/arm.h>>=
/*
 * ARM-specific definitions for armv6 (arm11), armv7 (cortex-a7 and -a8)
 * these are used in C and assembler
 */

/*
 * Program Status Registers
 */
<<type PsrMode(arm)>>

<<type PsrDisable(arm)>>

/*
 * Coprocessors
 */
<<type Coprocessors(arm)>>

/*
 * Primary (CRn) CpSC registers.
 */
<<type CpSC primary registers(arm)>>


<<type CpID secondary registers(arm)>>
<<type CpID opcode2(arm)>>

<<type CpCONTROL opcode2(arm)>>
<<type CpCONTROL CpMainctl(arm)>>
<<type CpCONTROL CpAuxctl(arm)>>
<<type CpCONTROL secondary registers(arm)>>
<<type CpCONTROL opcode2 bis(arm)>>

<<type CpTTB(arm)>>

<<type CpFSR(arm)>>

<<type CpCACHE secondary registers(arm)>>
<<type CpCACHE opcode2(arm)>>

<<type CpTLB secondary registers(arm)>>
<<type CpTLB opcode2(arm)>>

<<type CpCLD secondary registers(arm)>>
<<type CpCLD opcode2(arm)>>

<<type CpTIMER(arm)>>

<<type CpSPM secondary registers(arm)>>
<<type CpSPM opcode2(arm)>>


/*
 * CpCACHERANGE opcode2 fields for MCRR instruction (armv6)
 */
#define CpCACHERANGEinvi    5       /* invalidate instruction  */
#define CpCACHERANGEinvd    6       /* invalidate data */
#define CpCACHERANGEdwb     12      /* writeback */
#define CpCACHERANGEdwbi    14      /* writeback+invalidate */

/*
 * CpTTB cache control bits
 */
#define CpTTBnos    (1<<5)  /* only Inner cache shareable */
#define CpTTBinc    (0<<0|0<<6) /* inner non-cacheable */
#define CpTTBiwba   (0<<0|1<<6) /* inner write-back write-allocate */
#define CpTTBiwt    (1<<0|0<<6) /* inner write-through */
#define CpTTBiwb    (1<<0|1<<6) /* inner write-back no write-allocate */
#define CpTTBonc    (0<<3)  /* outer non-cacheable */
#define CpTTBowba   (1<<3)  /* outer write-back write-allocate */
#define CpTTBowt    (2<<3)  /* outer write-through */
#define CpTTBowb    (3<<3)  /* outer write-back no write-allocate */
#define CpTTBs  (1<<1)  /* page table in shareable memory */
#define CpTTBbase   ~0x7F       /* mask off control bits */

/*
 * MMU page table entries.
 */
<<constant Mbz(arm)>>

#define Fault       0x00000000      /* L[12] pte: unmapped */

<<type PageDirGranularity(arm)>>
<<type PageTableGranularity(arm)>>

<<type PageTableEntryAttribute1(arm)>>

#define Dom0        0

<<type PageTableEntryAttribute2(arm)>>

<<type PageTableEntryAttribute3(arm)>>

<<type DAC(arm)>>

#define F(v, o, w)  (((v) & ((1<<(w))-1))<<(o))

#define AP(n, v)    F((v), ((n)*2)+4, 2)
#define L1AP(ap)    (AP(3, (ap)))
/* L2AP differs between armv6 and armv7 -- see l2ap in arch*.c */
#define DAC(n, v)   F((v), (n)*2, 2)

<<constant HVECTORS(arm)>>

@
% >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >>

%dead:
% /*
%  * l2 cache aux. control
%  */
% #define CpCl2ecc    (1<<28)         /* use ecc, not parity */
% #define CpCl2noldforw   (1<<27)         /* no ld forwarding */
% #define CpCl2nowrcomb   (1<<25)         /* no write combining */
% #define CpCl2nowralldel (1<<24)         /* no write allocate delay */
% #define CpCl2nowrallcomb (1<<23)        /* no write allocate combine */
% #define CpCl2nowralloc  (1<<22)         /* no write allocate */
% #define CpCl2eccparity  (1<<21)         /* enable ecc or parity */
% #define CpCl2inner  (1<<16)         /* inner cacheability */
% /* other bits are tag ram & data ram latencies */
% 
% 
% /*
%  * CpCLD Secondary (CRm) registers and opcode2 fields for op1==1.
%  */
% #define CpCLDl2     0           /* l2 cache */
% 
% #define CpCLDl2aux  2           /* auxiliary control */
% 
% 
% /*
%  * CpTLD Secondary (CRm) registers and opcode2 fields.
%  */
% #define CpTLDlock   0           /* TLB lockdown registers */
% #define CpTLDpreload    1           /* TLB preload */
% 
% #define CpTLDi      0           /* TLB instr. lockdown reg. */
% #define CpTLDd      1           /* " data " " */
% 
% /*
%  * CpVECS Secondary (CRm) registers and opcode2 fields.
%  */
% #define CpVECSbase  0
% 
% #define CpVECSnorm  0           /* (non-)secure base addr */
% #define CpVECSmon   1           /* secure monitor base addr */


\subsection*{[[arch/arm/arminstr.ha]]}

<<arch/arm/arminstr.ha>>=
/*
 * armv6/v7 machine assist, definitions
 *
 * loader uses R11 as scratch.
 */
//pad: used to be called arm.s, but I prefer the .ha suffix for asm macros

#define PADDR(va)   (((va) & ~KSEGM))
#define L1X(va)     (((((va))>>20) & 0x0fff)<<2)

/*
 * new instructions
 */
<<instruction ISB(arm)>>
<<instruction DSB(arm)>>
<<instruction BARRIERS(arm)>>


#define MCRR(coproc, op, rd, rn, crm) \
    WORD $(0xec400000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))
#define MRRC(coproc, op, rd, rn, crm) \
    WORD $(0xec500000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))

#define LDREX(fp,t)   WORD $(0xe<<28|0x01900f9f | (fp)<<16 | (t)<<12)
/* `The order of operands is from left to right in dataflow order' - asm man */
#define STREX(f,tp,r) WORD $(0xe<<28|0x01800f90 | (tp)<<16 | (r)<<12 | (f)<<0)
#define CLREX   WORD    $0xf57ff01f

#define CPSIE   WORD    $0xf1080080 /* intr enable: zeroes I bit */
#define CPSID   WORD    $0xf10c0080 /* intr disable: sets I bit */

#define OKAY \
    MOVW    $0x7E200028,R2; \
    MOVW    $0x10000,R3; \
    MOVW    R3,(R2)


/*
 * get cpu id, or zero if armv6
 */
#define CPUID(r) \
    MRC CpSC, 0, r, C(CpID), C(CpIDfeat), 7; \
    CMP $0, r; \
    B.EQ    2(PC); \
    MRC CpSC, 0, r, C(CpID), C(CpIDidct), CpIDmpid; \
    AND.S   $(MAXCPUS-1), r
@
%$
% >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >>
%dead: #define PUTC(s)

\subsection*{[[arch/arm/io.h]]}

<<macro IRQDMA(arm)>>=
#define IRQDMA(chan)    (IRQdma0+(chan))
@

<<enum Dma(arm)>>=
enum {
    DmaD2M      = 0,        /* device to memory */
    DmaM2D      = 1,        /* memory to device */
    DmaM2M      = 2,        /* memory to memory */

    DmaChanEmmc = 4,        /* can only use 2-5, maybe 0 */
    DmaChanSpiTx= 2,
    DmaChanSpiRx= 0,

    DmaDevSpiTx = 6,
    DmaDevSpiRx = 7,
    DmaDevEmmc  = 11,
};
@

<<enum Power(arm)>>=
enum {
    PowerSd     = 0,
    PowerUart0,
    PowerUart1,
    PowerUsb,
    PowerI2c0,
    PowerI2c1,
    PowerI2c2,
    PowerSpi,
    PowerCcp2tx,
};
@

<<enum Clock(arm)>>=
enum {
    ClkEmmc     = 1,
    ClkUart,
    ClkArm,
    ClkCore,
    ClkV3d,
    ClkH264,
    ClkIsp,
    ClkSdram,
    ClkPixel,
    ClkPwm,
};
@


%-------------------------------------------------------------

<<arch/arm/io.h>>=
// could be in dat_interrupts.h?
<<enum IRQ(arm)>>
<<macro IRQDMA(arm)>>

<<enum Dma(arm)>>

<<enum Power(arm)>>

// could be in dat_time.h?
<<enum Clock(arm)>>
@


\subsection*{[[arch/arm/coproc.c]]}

<<enum _anon_(arm)>>=
enum {
    /* alternates:  
     *  0xe12fff1e  BX (R14); last e is R14
     *  0xe28ef000  B 0(R14); second e is R14 (ken)
     */
    RETinst = 0xe1a0f00e,       /* MOV R14, R15 */

    Opmask  = MASK(3),
    Regmask = MASK(4),
};
@

<<function setupcpop(arm)>>=
// setup coprocessor operation
static void
setupcpop(ulong instr[2], ulong opcode, int cp, int op1, int crn, int crm,
    int op2)
{
    ulong instrsz[2];

    op1 &= Opmask;
    op2 &= Opmask;
    crn &= Regmask;
    crm &= Regmask;
    cp  &= Regmask;
    instr[0] = opcode | op1 << 21 | crn << 16 | cp << 8 | op2 << 5 | crm;
    instr[1] = RETinst;

    cachedwbse(instr, sizeof instrsz);
    cacheiinv();
}
@
% >> >> >> >> >> >> >> >>

<<function cprd(arm)>>=
ulong
cprd(int cp, int op1, int crn, int crm, int op2)
{
    int s, r;
    volatile ulong instr[2];
    Pufv fp;

    s = arch_splhi();
    /*
     * MRC.  return value will be in R0, which is convenient.
     * Rt will be R0.
     */
    // MRC 0x e(Mxx) e(Always) 0 (MRC) .... 10 (part of Mxxx opcode)
    setupcpop(instr, 0xee100010, cp, op1, crn, crm, op2);
    fp = (Pufv)instr;
    r = fp();
    arch_splx(s);
    return r;
}
@

<<function cpwr(arm)>>=
void
cpwr(int cp, int op1, int crn, int crm, int op2, ulong val)
{
    int s;
    volatile ulong instr[2];
    Pvfu fp;

    s = arch_splhi();
    // MCR 0x e(Mxx) e(Always) 0 (MCR) .... 10 (part of Mxxx opcode)
    setupcpop(instr, 0xee000010, cp, op1, crn, crm, op2); /* MCR, Rt is R0 */
    fp = (Pvfu)instr;
    fp(val);
    arch_coherence();
    arch_splx(s);
}
@

<<function cprdsc(arm)>>=
ulong
cprdsc(int op1, int crn, int crm, int op2)
{
    return cprd(CpSC, op1, crn, crm, op2);
}
@

<<function cpwrsc(arm)>>=
void
cpwrsc(int op1, int crn, int crm, int op2, ulong val)
{
    cpwr(CpSC, op1, crn, crm, op2, val);
}
@


%-------------------------------------------------------------

<<arch/arm/coproc.c>>=
/*
 * ARM co-processors
 * mainly to cope with ARM hard-wiring register numbers into instructions.
 *
 * CP15 (system control) is the one that gets used the most in practice.
 * these routines must be callable from KZERO space or the 0 segment.
 */
<<kernel basic includes>>

#include "io.h"
#include "arm.h"

//pad: why not have generic assembly functions called from C
// that takes the coprocessor register numbers as arguments in the stack?
<<enum _anon_(arm)>>

// pointer to ulong function void
typedef ulong (*Pufv)(void);
// pointer to void function ulong
typedef void  (*Pvfu)(ulong);

<<function setupcpop(arm)>>

<<function cprd(arm)>>

<<function cpwr(arm)>>

<<function cprdsc(arm)>>

<<function cpwrsc(arm)>>

/* floating point */

<<function setupfpctlop(arm)>>

<<function fprd(arm)>>

<<function fpwr(arm)>>

<<function setupfpop(arm)>>

<<function fpsavereg(arm)>>

<<function fprestreg(arm)>>
@
% >> >> >> >> >> >> >>
% >> >> >> >> >> >> >>
% >> >> >> >> >> >> >>

\subsection*{[[arch/arm/vcore.c]]}


<<enum _anon_ (arch/arm/vcore.c)(arm)>>=
enum {
    Read        = 0x00>>2,
    Write       = 0x00>>2,
    Peek        = 0x10>>2,
    Sender      = 0x14>>2,
    Status      = 0x18>>2,
        Full        = 1<<31,
        Empty       = 1<<30,
    Config      = 0x1C>>2,

    NRegs       = 0x20>>2,
};
@

<<enum _anon_ (arch/arm/vcore.c)2(arm)>>=
enum {
    ChanFb      = 1,
    ChanProps   = 8,
    ChanMask    = 0xF,
};
@

<<enum _anon_ (arch/arm/vcore.c)3(arm)>>=
enum {
    Req         = 0x0,
    RspOk       = 0x80000000,
    TagResp     = 1<<31,
};
@

<<enum _anon_ (arch/arm/vcore.c)4(arm)>>=
enum {
    TagGetfwrev = 0x00000001,
    TagGetrev   = 0x00010002,

    TagGetmac   = 0x00010003,
    TagGetram   = 0x00010005,

    TagGetpower = 0x00020001,
    TagSetpower = 0x00028001,
        Powerwait   = 1<<1,

    TagGetclkspd= 0x00030002,
    TagGetclkmax= 0x00030004,
    TagSetclkspd= 0x00038002,

    TagGettemp  = 0x00030006,

    TagFballoc  = 0x00040001,
    TagFbfree   = 0x00048001,
    TagFbblank  = 0x00040002,

    TagGetres   = 0x00040003,
    TagSetres   = 0x00048003,
    TagGetvres  = 0x00040004,
    TagSetvres  = 0x00048004,
    TagGetdepth = 0x00040005,
    TagSetdepth = 0x00048005,
    TagGetrgb   = 0x00044006,
    TagSetrgb   = 0x00048006,
};
@


<<struct Prophdr(arm)>>=
struct Prophdr {
    u32int  len;
    u32int  req;
    u32int  tag;
    u32int  tagbuflen;
    u32int  taglen;
    u32int  data[1];
};
@

<<function vcwrite(arm)>>=
static void
vcwrite(uint chan, int val)
{
    u32int *r;

    r = (u32int*)MAILBOX + NRegs;
    val &= ~ChanMask;
    while(r[Status] & Full)
        ;
    arch_coherence();
    r[Write] = val | chan;
}
@

<<function vcread(arm)>>=
static int
vcread(uint chan)
{
    u32int *r;
    int x;

    r = (u32int*)MAILBOX;
    do{
        while(r[Status]&Empty)
            ;
        arch_coherence();
        x = r[Read];
    }while((x&ChanMask) != chan);
    return x & ~ChanMask;
}
@

<<function vcreq(arm)>>=
/*
 * Property interface
 */

static int
vcreq(int tag, void *buf, int vallen, int rsplen)
{
    uintptr r;
    int n;
    Prophdr *prop = (Prophdr*)(VCBUFFER);
    uintptr aprop;
    static bool busaddr = true;

    if(rsplen < vallen)
        rsplen = vallen;
    rsplen = (rsplen+3) & ~3;

    n = sizeof(Prophdr) + rsplen + 8;
    memset(prop, 0, n);
    prop->len = n;
    prop->req = Req;
    prop->tag = tag;
    prop->tagbuflen = rsplen;
    prop->taglen = vallen;
    if(vallen > 0)
        memmove(prop->data, buf, vallen);
    cachedwbinvse(prop, prop->len);
    for(;;){
        aprop = busaddr? dmaaddr(prop) : PTR2UINT(prop);
        vcwrite(ChanProps, aprop);
        r = vcread(ChanProps);
        if(r == aprop)
            break;
        if(!busaddr)
            return -1;
        busaddr = false;
    }
    if(prop->req == RspOk &&
       prop->tag == tag &&
       (prop->taglen&TagResp)) {
        if((n = prop->taglen & ~TagResp) < rsplen)
            rsplen = n;
        memmove(buf, prop->data, rsplen);
    }else
        rsplen = -1;

    return rsplen;
}
@

<<function fbdefault(arm)>>=
/*
 * Framebuffer
 */
static errorneg1
fbdefault(int *width, int *height, int *depth)
{
    u32int buf[3];

    if(vcreq(TagGetres, &buf[0], 0, 2*4) != 2*4 ||
       vcreq(TagGetdepth, &buf[2], 0, 4) != 4)
        return ERROR_NEG1;
    *width = buf[0];
    *height = buf[1];
    *depth = buf[2];
    return OK_0;
}
@

<<function fbinit(arm)>>=
void*
fbinit(bool set, int *width, int *height, int *depth)
{
    Fbinfo *fi = (Fbinfo*)(VCBUFFER);
    uintptr va;

    if(!set)
        fbdefault(width, height, depth);
    /* Screen width must be a multiple of 16 */
    *width &= ~0xF;
    memset(fi, 0, sizeof(Fbinfo));
    fi->xres = fi->xresvirtual = *width;
    fi->yres = fi->yresvirtual = *height;
    fi->bpp = *depth;
    cachedwbinvse(fi, sizeof(Fbinfo));
    vcwrite(ChanFb, dmaaddr(fi));
    if(vcread(ChanFb) != 0)
        return nil;
    //TODO: fi->base is in virtual space?? how vcore knows about that? PADDR?
    va = mmukmap(FRAMEBUFFER, PADDR(fi->base), fi->screensize);
    // make it a blue screen
    if(va)
        memset((char*)va, 0x7F, fi->screensize);
    return (void*)va;
}
@

<<function fbblank(arm)>>=
int
fbblank(bool blank)
{
    u32int buf[1];

    buf[0] = blank;
    if(vcreq(TagFbblank, buf, sizeof buf, sizeof buf) != sizeof buf)
        return ERROR_NEG1;
    return buf[0] & 1;
}
@

<<function setpower(arm)>>=
/*
 * Power management
 */
void
setpower(int dev, bool on)
{
    u32int buf[2];

    buf[0] = dev;
    buf[1] = Powerwait | on;
    vcreq(TagSetpower, buf, sizeof buf, sizeof buf);
}
@

<<function getpower(arm)>>=
int
getpower(int dev)
{
    u32int buf[2];

    buf[0] = dev;
    buf[1] = 0;
    if(vcreq(TagGetpower, buf, sizeof buf[0], sizeof buf) != sizeof buf)
        return ERROR_NEG1;
    return buf[0] & 1;
}
@

<<function getethermac(arm)>>=
/*
 * Get ethernet address (as hex string)
 *   [not reentrant]
 */
char *
getethermac(void)
{
    uchar ea[8];
    char *p;
    int i;
    static char buf[16];

    memset(ea, 0, sizeof ea);
    vcreq(TagGetmac, ea, 0, sizeof ea);
    p = buf;
    for(i = 0; i < 6; i++)
        p += sprint(p, "%.2x", ea[i]);
    return buf;
}
@

<<function getboardrev(arm)>>=
/*
 * Get board revision
 */
uint
getboardrev(void)
{
    u32int buf[1];

    if(vcreq(TagGetrev, buf, 0, sizeof buf) != sizeof buf)
        return 0;
    return buf[0];
}
@

<<function getfirmware(arm)>>=
/*
 * Get firmware revision
 */
uint
getfirmware(void)
{
    u32int buf[1];

    if(vcreq(TagGetfwrev, buf, 0, sizeof buf) != sizeof buf)
        return 0;
    return buf[0];
}
@

<<function getramsize(arm)>>=
/*
 * Get ARM ram
 */
void
getramsize(Confmem *mem)
{
    u32int buf[2];

    if(vcreq(TagGetram, buf, 0, sizeof buf) != sizeof buf)
        return;
    mem->base = buf[0];
    mem->limit = buf[1];
}
@

<<function getclkrate(arm)>>=
/*
 * Get clock rate
 */
ulong
getclkrate(int clkid)
{
    u32int buf[2];

    buf[0] = clkid;
    if(vcreq(TagGetclkspd, buf, sizeof(buf[0]), sizeof(buf)) != sizeof buf)
        return 0;
    return buf[1];
}
@

<<function setclkrate(arm)>>=
/*
 * Set clock rate to hz (or max speed if hz == 0)
 */
void
setclkrate(int clkid, ulong hz)
{
    u32int buf[2];

    buf[0] = clkid;
    if(hz != 0)
        buf[1] = hz;
    else if(vcreq(TagGetclkmax, buf, sizeof(buf[0]), sizeof(buf)) != sizeof buf)
        return;
    vcreq(TagSetclkspd, buf, sizeof(buf), sizeof(buf));
}
@

<<function getcputemp(arm)>>=
/*
 * Get cpu temperature
 */
uint
getcputemp(void)
{
    u32int buf[2];

    buf[0] = 0;
    if(vcreq(TagGettemp, buf, sizeof(buf[0]), sizeof buf) != sizeof buf)
        return 0;
    return buf[1];
}
@


%-------------------------------------------------------------

<<arch/arm/vcore.c>>=
<<kernel basic includes>>

/*
 * Mailbox interface with videocore gpu
 */
<<constant MAILBOX(arm)>>

typedef struct Fbinfo Fbinfo;
typedef struct Prophdr Prophdr;

<<enum _anon_ (arch/arm/vcore.c)(arm)>>
<<enum _anon_ (arch/arm/vcore.c)2(arm)>>

<<enum _anon_ (arch/arm/vcore.c)3(arm)>>

<<enum _anon_ (arch/arm/vcore.c)4(arm)>>

<<struct Fbinfo(arm)>>


<<struct Prophdr(arm)>>

<<function vcwrite(arm)>>

<<function vcread(arm)>>

<<function vcreq(arm)>>

<<function fbdefault(arm)>>

<<function fbinit(arm)>>

<<function fbblank(arm)>>

<<function setpower(arm)>>

<<function getpower(arm)>>

<<function getethermac(arm)>>

<<function getboardrev(arm)>>

<<function getfirmware(arm)>>

<<function getramsize(arm)>>

<<function getclkrate(arm)>>

<<function setclkrate(arm)>>

<<function getcputemp(arm)>>
@


\section{[[concurrency/arm/]]}

\subsection*{[[concurrency/arm/spl.s]]}

<<concurrency/arm/spl.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<function arch_splhi(arm)>>

<<function arch_spllo(arm)>>

<<function arch_spllx(arm)>>

TEXT spldone(SB), 1, $0             /* end marker for devkprof.c */
    RET

<<function arch_islo(arm)>>



<<function arm_arch_coherence(arm)>>


// FIQ
TEXT splfhi(SB), 1, $-4
    MOVW    $(CPUADDR+4), R2        /* save caller pc in Mach */
    MOVW    R14, 0(R2)

    MOVW    CPSR, R0            /* turn off irqs and fiqs */
    ORR $(PsrDirq|PsrDfiq), R0, R1
    MOVW    R1, CPSR
    RET

TEXT splflo(SB), 1, $-4
    MOVW    CPSR, R0            /* turn on fiqs */
    BIC $(PsrDfiq), R0, R1
    MOVW    R1, CPSR
    RET
@
%$

\subsection*{[[concurrency/arm/tas_raspi1.s]]}

<<concurrency/arm/tas_raspi1.s>>=
TEXT    _tas(SB), $-4
<<function arch_tas(raspberry pi1)(arm)>>
@
%$
\t _tas used?? remove? used by libc?

\subsection*{[[concurrency/arm/tas_raspi2.s]]}

<<concurrency/arm/tas_raspi2.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

#define DMB WORD    $0xf57ff05f /* data mem. barrier; last f = SY */
        
/* tas/cas strex debugging limits; started at 10000 */
#define MAXSC 100000
        
TEXT    _tas(SB), $-4           /* _tas(ulong *) */
TEXT    arch_tas(SB), $-4
    /* returns old (R0) after modifying (R0) */
    MOVW    R0,R5
    DMB

    MOVW    $1,R2       /* new value of (R0) */
    MOVW    $MAXSC, R8
tas1:
    LDREX(5,7)      /* LDREX 0(R5),R7 */
    CMP.S   $0, R7      /* old value non-zero (lock taken)? */
    BNE lockbusy    /* we lose */
    SUB.S   $1, R8
    BEQ lockloop2
    STREX(2,5,4)        /* STREX R2,(R5),R4 */
    CMP.S   $0, R4
    BNE tas1        /* strex failed? try again */
    DMB
    B   tas0
lockloop2:
    BL  abort(SB)
lockbusy:
    CLREX
tas0:
    MOVW    R7, R0      /* return old value */
    RET
@

\subsection*{[[concurrency/arm/concurrency_raspi1.c]]}

<<function ainc(arm)>>=
// overwrite libc!
int
ainc(int *p)
{
    int s, v;

    s = arch_splhi();
    v = ++*p;
    arch_splx(s);
    return v;
}
@
% otherwise ainc use Lock
% which code in the kernel use ainc? We link with libc but which
% function uses ainc?

<<function adec(arm)>>=
int
adec(int *p)
{
    int s, v;

    s = arch_splhi();
    v = --*p;
    arch_splx(s);
    return v;
}
@

<<function cas32(arm)>>=
bool
cas32(void* addr, u32int old, u32int new)
{
    bool r;
    int s;

    s = arch_splhi();
    r = (*(u32int*)addr == old);
    if(r)
        *(u32int*)addr = new;
    arch_splx(s);
    if (r)
        arch_coherence();
    return r;
}
@

<<function arch_cmpswap(arm)>>=
bool
arch_cmpswap(long *addr, long old, long new)
{
    return cas32(addr, old, new);
}
@


%-------------------------------------------------------------

<<concurrency/arm/concurrency_raspi1.c>>=
/*
 * atomic ops
 * make sure that we don't drag in the C library versions
 */
<<kernel basic includes>>

<<function arch_xdec(arm)>>

<<function arch_xinc(arm)>>

<<function ainc(arm)>>

<<function adec(arm)>>

<<function cas32(arm)>>

<<function arch_cmpswap(arm)>>
@

\subsection*{[[concurrency/arm/concurrency_raspi2.c]]}

%-------------------------------------------------------------

<<concurrency/arm/concurrency_raspi2.c>>=
<<kernel basic includes>>

extern long _xdec(long *p);
extern long _xinc(long *p);

// use libc version?? ok??
long
arch_xdec(long *p)
{
  return _xdec(p);
}

void
arch_xinc(long *p)
{
  _xinc(p);
}

int
arch_cmpswap(long *addr, long old, long new)
{
    return cas((ulong*)addr, old, new);
}
@
\t clean those _xinc vs arch_xinc

\section{[[core/arm/]]}

\subsection*{[[core/arm/dat.h]]}

<<constant STAGESIZE(arm)>>=
// was a default in portdat.h
#define STAGESIZE 64 // for struct Uart
@

<<constant KMESGSIZE(arm)>>=
#define KMESGSIZE (16*1024) // for /dev/kmesg
@


%-------------------------------------------------------------

<<core/arm/dat.h>>=
// pad's memory pointers (used in Lock so must be early)
<<pad memory pointer types(arm)>>

#include "dat_forward.h"
#include "../port/portdat_forward.h"
<<constant STAGESIZE(arm)>>

<<dat.h includes(arm)>>

// DO NOT switch those declarations. 5c allocates R10
// for the first 'extern register' declaration seen in a file
// and R9 for the second one. See Compiler.nw.
// Then mem.h relies on this to define the UP and CPU macros used
// inside assembly code.
<<global cpu(arm)>>
<<global up(arm)>>

// in main.c (used in mmu.c)
extern ulong memsize;

<<constant KMESGSIZE(arm)>>

// TODO: put that in portdat.h or in netif.h?
#pragma varargck  type  "I" uchar*
#pragma varargck  type  "V" uchar*
#pragma varargck  type  "E" uchar*
#pragma varargck  type  "M" uchar*
@


\subsection*{[[core/arm/dat_core.h]]}



<<[[Cpu]] [[Arch]] save of first five registers fields(arm)>>=
/* save areas for exceptions, hold R0-R4 */
u32int  sfiq[5];
u32int  sirq[5];
u32int  sund[5];
u32int  sabt[5];
u32int  smon[5];        /* probably not needed */
@
%dead: u32int  ssys[5];


<<[[Cpu]] [[Arch]] other fields(arm)>>=
Lock    alarmlock;      /* access to alarm list */
void*   alarm;          /* alarms bound to this clock */

int cputype;
ulong   delayloop;

/* stats */

uvlong  fastclock;      /* last sampled value */

int lastintr; // dead?? also redundant with one in Cpu?
@


%-------------------------------------------------------------

<<core/arm/dat_core.h>>=

<<type PTE(arm)>>

<<struct MMMU(arm)>>

<<struct Arch_Cpu(arm)>>
@


\subsection*{[[core/arm/dat_forward.h]]}


%-------------------------------------------------------------

<<core/arm/dat_forward.h>>=
// could be in portdat_forward.h
typedef struct Arch_FPsave  Arch_FPsave;
typedef struct Ureg Ureg;
#pragma incomplete Ureg

typedef struct MMMU MMMU;
typedef struct Soc Soc;
@


\subsection*{[[core/arm/fns.h]]}

<<macro getpgcolor(arm)>>=
#define getpgcolor(a)   0
@

<<macro arch_cycles(arm)>>=
#define arch_cycles(ip) *(ip) = arch_lcycles()
@

<<macro arch_countpagerefs(arm)>>=
// same signatures but optimized away
#define arch_countpagerefs(a, b)
@


<<macro sdfree(arm)>>=
#define sdfree(p) free(p)
@
<<macro sdmalloc(arm)>>=
#define sdmalloc(n) mallocalign(n, BLOCKALIGN, 0, 0)
@


%-------------------------------------------------------------

<<core/arm/fns.h>>=

<<fns.h includes(arm)>>

// not classified yet
void arch_cpuidprint(void);
<<macro getpgcolor(arm)>>

// different signatures in different arch so cant factorize
void  arch_touser(uintptr);
int   arch_cmpswap(long*, long, long);
<<macro arch_cycles(arm)>>

<<macro arch_countpagerefs(arm)>>
<<macro arch_intrenable(arm)>>

void dumpregs(Ureg*);

void confinit(void);
void userinit(void);


extern void mmuinit1(void*);
extern void mmuinvalidate(void);
extern void mmuinvalidateaddr(u32int);

extern void kexit(Ureg*);

extern void irqenable(int, void (*)(Ureg*, void*), void*);

extern void intrcpushutdown(void);
extern void intrshutdown(void);
extern void intrsoff(void);


extern void archreboot(void);
extern void archreset(void);

extern void clockinit(void);
extern void clockshutdown(void);


extern int cas32(void*, u32int, u32int);
extern int cas(ulong*, ulong, ulong);

extern char *cputype2name(char *buf, int size);

extern void armtimerset(int);

extern void cachedwb(void);
extern void cachedwbinv(void);
extern void cachedinvse(void*, int);
extern void cachedwbse(void*, int);
extern void cachedwbinvse(void*, int);
extern void cacheiinv(void);
extern void cacheuwbinv(void);


// coproc.c
extern ulong cprd(int cp, int op1, int crn, int crm, int op2);
extern ulong cprdsc(int op1, int crn, int crm, int op2);
extern void cpwr(int cp, int op1, int crn, int crm, int op2, ulong val);
extern void cpwrsc(int op1, int crn, int crm, int op2, ulong val);

// dma.c
extern uintptr dmaaddr(void *va);
extern void dmastart(int, int, int, void*, void*, int);
extern int dmawait(int);

// vcore.c
extern int fbblank(int);
extern void* fbinit(bool, int*, int*, int*);


extern void fpon(void);
extern ulong fprd(int fpreg);
extern void fprestreg(int fpreg, uvlong val);
extern void fpsave(Arch_FPsave *);
extern ulong fpsavereg(int fpreg, uvlong *fpp);
extern void fpwr(int fpreg, ulong val);

extern u32int fsrget(void);
extern u32int farget(void);

// vcore.c
extern uint getboardrev(void);
extern ulong getclkrate(int);
extern uint getcputemp(void);
extern char *getethermac(void);
extern uint getfirmware(void);
extern void getramsize(Confmem*);

extern int getncpus(void);
extern int getpower(int);


extern void gpiosel(uint, int);
extern void gpiopullup(uint);
extern void gpiopulloff(uint);
extern void gpiopulldown(uint);

extern void i2cread(uint, void*, int);
extern void i2cwrite(uint, void*, int);

extern u32int ifsrget(void);

extern void okay(int);

extern int l2ap(int);
extern void l2cacheuwbinv(void);

<<macro sdfree(arm)>>
<<macro sdmalloc(arm)>>

extern void setclkrate(int, ulong);
extern void setpower(int, int);
extern void setr13(int, u32int*);

extern void spirw(uint, void*, int);
extern int splfhi(void);
extern int splflo(void);

extern int startcpus(uint);
extern void stopcpu(uint);


extern void uartconsinit(void);
extern void vectors(void);
extern void vtable(void);

extern void wdogoff(void);

/*
 * floating point emulation
 */
extern int fpiarm(Ureg*);
extern int fpudevprocio(Proc*, void*, long, uintptr, int);
extern void fpuinit(void);
extern void fpunoted(void);
extern void fpunotify(Ureg*);
extern void fpuprocrestore(Proc*);
extern void fpuprocsave(Proc*);
extern void fpusysprocsetup(Proc*);
extern void fpusysrfork(Ureg*);
extern void fpusysrforkchild(Proc*, Ureg*, Proc*);
extern int fpuemu(Ureg*);

/*
 * Miscellaneous machine dependent stuff.
 */
extern char* getenv(char*, char*, int);

uintptr mmukmap(uintptr, uintptr, usize);
uintptr mmukunmap(uintptr, uintptr, usize);
extern void* mmuuncache(void*, usize);

extern void* ucalloc(usize);
extern Block* ucallocb(int);
extern void* ucallocalign(usize size, int align, int span);
extern void ucfree(void*);
extern void ucfreeb(Block*);

extern void sysprocsetup(Proc*);


<<macro PTR2UINT(arm)>>
<<macro UINT2PTR(arm)>>

<<macro KADDR(arm)>>
<<macro PADDR(arm)>>

@


\section{[[buses/arm/]]}

\section{[[devices/]]}

\subsection*{[[devices/keyboard/arm/kbd.c]]}

<<function arch_setleds(arm)>>=
// empty callback for portkbd.c
void arch_setleds(Kbscan *kbscan) { USED(kbscan); }
@


%-------------------------------------------------------------

<<devices/keyboard/arm/kbd.c>>=
<<kernel basic includes>>

// In the Raspberry Pi, the keyboard is handled by usbd
// with help from /dev/kbin (which then calls functions from portkbd
// which calls arch_setleds below).

<<function arch_setleds(arm)>>
@


\subsection*{[[devices/mouse/arm/mouse.c]]}

<<devices/mouse/arm/mouse.c>>=
<<kernel basic includes>>

// In the Raspberry Pi, the mouse is handled by usbd
// with help from /dev/mousein.

// empty callbacks for portmouse.c

void arch_ps2mouse(void) { }
void arch_setaccelerated(void) { }
void arch_setlinear(void) { }
void arch_setres(int n) { USED(n); }
void arch_setintellimouse(void) { }
void arch_resetmouse(void) { }
@

\subsection*{[[devices/storage/arm/emmc.c]]}


<<enum _anon_ (devices/storage/arm/emmc.c)(arm)>>=
enum {
    Extfreq     = 100*Mhz,  /* guess external clock frequency if */
                    /* not available from vcore */
    Initfreq    = 400000,   /* initialisation frequency for MMC */
    SDfreq      = 25*Mhz,   /* standard SD frequency */
    DTO     = 14,       /* data timeout exponent (guesswork) */

    MMCSelect   = 7,        /* mmc/sd card select command */
    Setbuswidth = 6,        /* mmc/sd set bus width command */
};
@

<<enum _anon_ (devices/storage/arm/emmc.c)2(arm)>>=
enum {
    /* Controller registers */
    Arg2            = 0x00>>2,
    Blksizecnt      = 0x04>>2,
    Arg1            = 0x08>>2,
    Cmdtm           = 0x0c>>2,
    Resp0           = 0x10>>2,
    Resp1           = 0x14>>2,
    Resp2           = 0x18>>2,
    Resp3           = 0x1c>>2,
    Data            = 0x20>>2,
    Status          = 0x24>>2,
    Control0        = 0x28>>2,
    Control1        = 0x2c>>2,
    Interrupt       = 0x30>>2,
    Irptmask        = 0x34>>2,
    Irpten          = 0x38>>2,
    Control2        = 0x3c>>2,
    Forceirpt       = 0x50>>2,
    Boottimeout     = 0x70>>2,
    Dbgsel          = 0x74>>2,
    Exrdfifocfg     = 0x80>>2,
    Exrdfifoen      = 0x84>>2,
    Tunestep        = 0x88>>2,
    Tunestepsstd        = 0x8c>>2,
    Tunestepsddr        = 0x90>>2,
    Spiintspt       = 0xf0>>2,
    Slotisrver      = 0xfc>>2,

    /* Control0 */
    Dwidth4         = 1<<1,
    Dwidth1         = 0<<1,

    /* Control1 */
    Srstdata        = 1<<26,    /* reset data circuit */
    Srstcmd         = 1<<25,    /* reset command circuit */
    Srsthc          = 1<<24,    /* reset complete host controller */
    Datatoshift     = 16,       /* data timeout unit exponent */
    Datatomask      = 0xF0000,
    Clkfreq8shift       = 8,        /* SD clock base divider LSBs */
    Clkfreq8mask        = 0xFF00,
    Clkfreqms2shift     = 6,        /* SD clock base divider MSBs */
    Clkfreqms2mask      = 0xC0,
    Clkgendiv       = 0<<5,     /* SD clock divided */
    Clkgenprog      = 1<<5,     /* SD clock programmable */
    Clken           = 1<<2,     /* SD clock enable */
    Clkstable       = 1<<1, 
    Clkintlen       = 1<<0,     /* enable internal EMMC clocks */

    /* Cmdtm */
    Indexshift      = 24,
    Suspend         = 1<<22,
    Resume          = 2<<22,
    Abort           = 3<<22,
    Isdata          = 1<<21,
    Ixchken         = 1<<20,
    Crcchken        = 1<<19,
    Respmask        = 3<<16,
    Respnone        = 0<<16,
    Resp136         = 1<<16,
    Resp48          = 2<<16,
    Resp48busy      = 3<<16,
    Multiblock      = 1<<5,
    Host2card       = 0<<4,
    Card2host       = 1<<4,
    Autocmd12       = 1<<2,
    Autocmd23       = 2<<2,
    Blkcnten        = 1<<1,

    /* Interrupt */
    Acmderr     = 1<<24,
    Denderr     = 1<<22,
    Dcrcerr     = 1<<21,
    Dtoerr      = 1<<20,
    Cbaderr     = 1<<19,
    Cenderr     = 1<<18,
    Ccrcerr     = 1<<17,
    Ctoerr      = 1<<16,
    Err     = 1<<15,
    Cardintr    = 1<<8,     /* not in Broadcom datasheet */
    Cardinsert  = 1<<6,     /* not in Broadcom datasheet */
    Readrdy     = 1<<5,
    Writerdy    = 1<<4,
    Datadone    = 1<<1,
    Cmddone     = 1<<0,

    /* Status */
    Bufread     = 1<<11,    /* not in Broadcom datasheet */
    Bufwrite    = 1<<10,    /* not in Broadcom datasheet */
    Readtrans   = 1<<9,
    Writetrans  = 1<<8,
    Datactive   = 1<<2,
    Datinhibit  = 1<<1,
    Cmdinhibit  = 1<<0,
};
@

<<global cmdinfo(arm)>>=
int cmdinfo[64] = {
[0]  Ixchken,
[2]  Resp136,
[3]  Resp48 | Ixchken | Crcchken,
[6]  Resp48 | Ixchken | Crcchken,
[7]  Resp48busy | Ixchken | Crcchken,
[8]  Resp48 | Ixchken | Crcchken,
[9]  Resp136,
[12] Resp48busy | Ixchken | Crcchken,
[13] Resp48 | Ixchken | Crcchken,
[16] Resp48,
[17] Resp48 | Isdata | Card2host | Ixchken | Crcchken,
[18] Resp48 | Isdata | Card2host | Multiblock | Blkcnten | Ixchken | Crcchken,
[24] Resp48 | Isdata | Host2card | Ixchken | Crcchken,
[25] Resp48 | Isdata | Host2card | Multiblock | Blkcnten | Ixchken | Crcchken,
[41] Resp48,
[55] Resp48 | Ixchken | Crcchken,
};
@

<<struct Ctlr (devices/storage/arm/emmc.c)(arm)>>=
struct Ctlr {
    Rendez  r;
    int datadone;
    int fastclock;
    ulong   extclk;
};
@

<<global emmc(arm)>>=
static Ctlr emmc;
@

<<function WR(arm)>>=
static void
WR(int reg, u32int val)
{
    u32int *r = (u32int*)EMMCREGS;

    //if(0)print("WR %2.2ux %ux\n", reg<<2, val);
    arch_microdelay(emmc.fastclock? 2 : 20);
    r[reg] = val;
}
@

<<function clkdiv(arm)>>=
static uint
clkdiv(uint d)
{
    uint v;

    assert(d < 1<<10);
    v = (d << Clkfreq8shift) & Clkfreq8mask;
    v |= ((d >> 8) << Clkfreqms2shift) & Clkfreqms2mask;
    return v;
}
@

<<function datadone(arm)>>=
static int
datadone(void*)
{
    int i;

    u32int *r = (u32int*)EMMCREGS;
    i = r[Interrupt];
    return i & (Datadone|Err);
}
@

<<function emmcinit(arm)>>=
static int
emmcinit(void)
{
    u32int *r;
    ulong clk;
    char *s;

    clk = getclkrate(ClkEmmc);
    s = "";
    if(clk == 0){
        s = "Assuming ";
        clk = Extfreq;
    }
    emmc.extclk = clk;
    print("%seMMC external clock %lud Mhz\n", s, clk / Mhz);
    r = (u32int*)EMMCREGS;
    //if(0)print("emmc control %8.8ux %8.8ux %8.8ux\n", r[Control0], r[Control1], r[Control2]);
    WR(Control1, Srsthc);
    arch_delay(10);
    while(r[Control1] & Srsthc)
        ;
    return 0;
}
@

<<function emmcinquiry(arm)>>=
static int
emmcinquiry(char *inquiry, int inqlen)
{
    u32int *r;
    uint ver;

    r = (u32int*)EMMCREGS;
    ver = r[Slotisrver] >> 16;
    return snprint(inquiry, inqlen,
        "Arasan eMMC SD Host Controller %2.2x Version %2.2x",
        ver&0xFF, ver>>8);
}
@

<<function mmcinterrupt(arm)>>=
static void
mmcinterrupt(Ureg*, void*)
{   
    u32int *r;
    r = (u32int*)EMMCREGS;
    if(r[Interrupt]&(Datadone|Err)){
        WR(Irpten, 0);
        wakeup(&emmc.r);
    }
}
@

<<function emmcenable(arm)>>=
static void
emmcenable(void)
{
    u32int *r;
    int i;

    r = (u32int*)EMMCREGS;
    WR(Control1, clkdiv(emmc.extclk/Initfreq - 1) |
        DTO<<Datatoshift | Clkgendiv | Clken | Clkintlen);
    for(i = 0; i < 1000; i++){
        arch_delay(1);
        if(r[Control1] & Clkstable)
            break;
    }
    if(i == 1000)
        print("SD clock won't initialise!\n");
    WR(Irptmask, ~(Dtoerr|Cardintr));
    arch_intrenable(IRQmmc, mmcinterrupt, nil, 0, "mmc");
}
@

<<function emmccmd(arm)>>=
static int
emmccmd(u32int cmd, u32int arg, u32int *resp)
{
    u32int *r;
    u32int c;
    int i;
    ulong now;

    r = (u32int*)EMMCREGS;
    assert(cmd < nelem(cmdinfo) && cmdinfo[cmd] != 0);
    c = (cmd << Indexshift) | cmdinfo[cmd];
    if(r[Status] & Cmdinhibit){
        print("emmccmd: need to reset Cmdinhibit intr %ux stat %ux\n",
            r[Interrupt], r[Status]);
        WR(Control1, r[Control1] | Srstcmd);
        while(r[Control1] & Srstcmd)
            ;
        while(r[Status] & Cmdinhibit)
            ;
    }
    if((r[Status] & Datinhibit) &&
       ((c & Isdata) || (c & Respmask) == Resp48busy)){
        print("emmccmd: need to reset Datinhibit intr %ux stat %ux\n",
            r[Interrupt], r[Status]);
        WR(Control1, r[Control1] | Srstdata);
        while(r[Control1] & Srstdata)
            ;
        while(r[Status] & Datinhibit)
            ;
    }
    WR(Arg1, arg);
    if((i = r[Interrupt]) != 0){
        if(i != Cardinsert)
            print("emmc: before command, intr was %ux\n", i);
        WR(Interrupt, i);
    }
    WR(Cmdtm, c);
    now = cpu->ticks;
    while(((i=r[Interrupt])&(Cmddone|Err)) == 0)
        if(cpu->ticks - now > Arch_HZ)
            break;
    if((i&(Cmddone|Err)) != Cmddone){
        if((i&~Err) != Ctoerr)
            print("emmc: cmd %ux error intr %ux stat %ux\n", c, i, r[Status]);
        WR(Interrupt, i);
        if(r[Status]&Cmdinhibit){
            WR(Control1, r[Control1]|Srstcmd);
            while(r[Control1]&Srstcmd)
                ;
        }
        error(Eio);
    }
    WR(Interrupt, i & ~(Datadone|Readrdy|Writerdy));
    switch(c & Respmask){
    case Resp136:
        resp[0] = r[Resp0]<<8;
        resp[1] = r[Resp0]>>24 | r[Resp1]<<8;
        resp[2] = r[Resp1]>>24 | r[Resp2]<<8;
        resp[3] = r[Resp2]>>24 | r[Resp3]<<8;
        break;
    case Resp48:
    case Resp48busy:
        resp[0] = r[Resp0];
        break;
    case Respnone:
        resp[0] = 0;
        break;
    }
    if((c & Respmask) == Resp48busy){
        WR(Irpten, Datadone|Err);
        tsleep(&emmc.r, datadone, 0, 3000);
        WR(Irpten, 0);
        emmc.datadone = 0;
        i = r[Interrupt];
        if((i & Datadone) == 0)
            print("emmcio: no Datadone after CMD%d\n", cmd);
        if(i & Err)
            print("emmcio: CMD%d error interrupt %ux\n",
                cmd, r[Interrupt]);
        WR(Interrupt, i);
    }
    /*
     * Once card is selected, use faster clock
     */
    if(cmd == MMCSelect){
        arch_delay(10);
        WR(Control1, clkdiv(emmc.extclk/SDfreq - 1) |
            DTO<<Datatoshift | Clkgendiv | Clken | Clkintlen);
        for(i = 0; i < 1000; i++){
            arch_delay(1);
            if(r[Control1] & Clkstable)
                break;
        }
        arch_delay(10);
        emmc.fastclock = 1;
    }
    /*
     * If card bus width changes, change host bus width
     */
    if(cmd == Setbuswidth){
        switch(arg){
        case 0:
            WR(Control0, r[Control0] & ~Dwidth4);
            break;
        case 2:
            WR(Control0, r[Control0] | Dwidth4);
            break;
        }
    }
    return 0;
}
@

<<function emmciosetup(arm)>>=
void
emmciosetup(int write, void *buf, int bsize, int bcount)
{
    USED(write);
    USED(buf);
    WR(Blksizecnt, bcount<<16 | bsize);
}
@

<<function emmcio(arm)>>=
static void
emmcio(int write, uchar *buf, int len)
{
    u32int *r;
    int i;

    r = (u32int*)EMMCREGS;
    assert((len&3) == 0);
    okay(1);
    if(waserror()){
        okay(0);
        nexterror();
    }
    if(write)
        dmastart(DmaChanEmmc, DmaDevEmmc, DmaM2D,
            buf, &r[Data], len);
    else
        dmastart(DmaChanEmmc, DmaDevEmmc, DmaD2M,
            &r[Data], buf, len);
    if(dmawait(DmaChanEmmc) < 0)
        error(Eio);
    if(!write)
        cachedinvse(buf, len);
    WR(Irpten, Datadone|Err);
    tsleep(&emmc.r, datadone, 0, 3000);
    WR(Irpten, 0);
    emmc.datadone = 0;
    i = r[Interrupt];
    if((i & Datadone) == 0){
        print("emmcio: %d timeout intr %ux stat %ux\n",
            write, i, r[Status]);
        WR(Interrupt, i);
        error(Eio);
    }
    if(i & Err){
        print("emmcio: %d error intr %ux stat %ux\n",
            write, r[Interrupt], r[Status]);
        WR(Interrupt, i);
        error(Eio);
    }
    if(i)
        WR(Interrupt, i);
    poperror();
    okay(0);
}
@

<<global sdio(arm)>>=
SDio sdio = {
    "emmc",
    emmcinit,
    emmcenable,
    emmcinquiry,
    emmccmd,
    emmciosetup,
    emmcio,
};
@


%-------------------------------------------------------------

<<devices/storage/arm/emmc.c>>=
/*
 * bcm2835 external mass media controller (mmc / sd host interface)
 *
 * Copyright © 2012 Richard Miller <r.miller@acm.org>
 */
<<kernel basic includes>>

#include "io.h"
#include "../port/sd.h"

<<constant EMMCREGS(arm)>>

<<enum _anon_ (devices/storage/arm/emmc.c)(arm)>>

<<enum _anon_ (devices/storage/arm/emmc.c)2(arm)>>

<<global cmdinfo(arm)>>

typedef struct Ctlr Ctlr;

<<struct Ctlr (devices/storage/arm/emmc.c)(arm)>>

<<global emmc(arm)>>

<<function WR(arm)>>

<<function clkdiv(arm)>>

<<function datadone(arm)>>

<<function emmcinit(arm)>>

<<function emmcinquiry(arm)>>

<<function mmcinterrupt(arm)>>

<<function emmcenable(arm)>>

<<function emmccmd(arm)>>

<<function emmciosetup(arm)>>

<<function emmcio(arm)>>


<<global sdio(arm)>>
@


\subsection*{[[devices/sys/arm/devarch.c]]}

<<enum _anon_ (devices/sys/arm/devarch.c)(arm)>>=
enum {
    Qdir = 0,
    Qbase,

    Qmax = 16,
};
@

<<global readfn(arm)>>=
static Rdwrfn *readfn[Qmax];
@

<<global writefn(arm)>>=
static Rdwrfn *writefn[Qmax];
@

<<global archdir(arm)>>=
static Dirtab archdir[Qmax] = {
    ".",        { Qdir, 0, QTDIR }, 0,  0555,
};
@

<<global archwlock(arm)>>=
Lock archwlock; /* the lock is only for changing archdir */
@

<<global narchdir(arm)>>=
int narchdir = Qbase;
@

<<function addarchfile(arm)>>=
/*
 * Add a file to the #P listing.  Once added, you can't delete it.
 * You can't add a file with the same name as one already there,
 * and you get a pointer to the Dirtab entry so you can do things
 * like change the Qid version.  Changing the Qid path is disallowed.
 */
Dirtab*
addarchfile(char *name, int perm, Rdwrfn *rdfn, Rdwrfn *wrfn)
{
    int i;
    Dirtab d;
    Dirtab *dp;

    memset(&d, 0, sizeof d);
    strcpy(d.name, name);
    d.perm = perm;

    lock(&archwlock);
    if(narchdir >= Qmax){
        unlock(&archwlock);
        return nil;
    }

    for(i=0; i<narchdir; i++)
        if(strcmp(archdir[i].name, name) == 0){
            unlock(&archwlock);
            return nil;
        }

    d.qid.path = narchdir;
    archdir[narchdir] = d;
    readfn[narchdir] = rdfn;
    writefn[narchdir] = wrfn;
    dp = &archdir[narchdir++];
    unlock(&archwlock);

    return dp;
}
@

<<function archattach(arm)>>=
static Chan*
archattach(char* spec)
{
    return devattach('P', spec);
}
@

<<function archwalk(arm)>>=
Walkqid*
archwalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, archdir, narchdir, devgen);
}
@

<<function archstat(arm)>>=
static int
archstat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, archdir, narchdir, devgen);
}
@

<<function archopen(arm)>>=
static Chan*
archopen(Chan* c, int omode)
{
    return devopen(c, omode, archdir, narchdir, devgen);
}
@

<<function archclose(arm)>>=
static void
archclose(Chan*)
{
}
@

<<function archread(arm)>>=
static long
archread(Chan *c, void *a, long n, vlong offset)
{
    Rdwrfn *fn;

    switch((ulong)c->qid.path){
    case Qdir:
        return devdirread(c, a, n, archdir, narchdir, devgen);

    default:
        if(c->qid.path < narchdir && (fn = readfn[c->qid.path]))
            return fn(c, a, n, offset);
        error(Eperm);
        break;
    }

    return 0;
}
@

<<function archwrite(arm)>>=
static long
archwrite(Chan *c, void *a, long n, vlong offset)
{
    Rdwrfn *fn;

    if(c->qid.path < narchdir && (fn = writefn[c->qid.path]))
        return fn(c, a, n, offset);
    error(Eperm);

    return 0;
}
@

<<global archdevtab(arm)>>=
Dev archdevtab = {
    .dc = 'P',
    .name = "arch",

    .reset = devreset,
    .init = archinit,
    .shutdown = devshutdown,
    .attach = archattach,
    .walk = archwalk,
    .stat = archstat,
    .open = archopen,
    .create = devcreate,
    .close = archclose,
    .read = archread,
    .bread = devbread,
    .write = archwrite,
    .bwrite = devbwrite,
    .remove = devremove,
    .wstat = devwstat,
};
@

<<function cputyperead(arm)>>=
static long
cputyperead(Chan*, void *a, long n, vlong offset)
{
    char name[64], str[128];

    cputype2name(name, sizeof name);
    snprint(str, sizeof str, "ARM %s %d\n", name, cpu->cpumhz);
    return readstr(offset, a, n, str);
}
@

<<function cputempread(arm)>>=
static long
cputempread(Chan*, void *a, long n, vlong offset)
{
    char str[16];

    snprint(str, sizeof str, "%ud\n", (getcputemp()+500)/1000);
    return readstr(offset, a, n, str);
}
@

<<function archinit(arm)>>=
void
archinit(void)
{
    addarchfile("cputype", 0444, cputyperead, nil);
    addarchfile("cputemp", 0444, cputempread, nil);
}
@


%-------------------------------------------------------------

<<devices/sys/arm/devarch.c>>=
<<kernel basic includes>>

#include "io.h"

<<enum _anon_ (devices/sys/arm/devarch.c)(arm)>>

typedef long Rdwrfn(Chan*, void*, long, vlong);

<<global readfn(arm)>>
<<global writefn(arm)>>

<<global archdir(arm)>>

<<global archwlock(arm)>>
<<global narchdir(arm)>>

<<function addarchfile(arm)>>

<<function archattach(arm)>>

<<function archwalk(arm)>>

<<function archstat(arm)>>

<<function archopen(arm)>>

<<function archclose(arm)>>

<<function archread(arm)>>

<<function archwrite(arm)>>

void archinit(void);

<<global archdevtab(arm)>>

<<function cputyperead(arm)>>

<<function cputempread(arm)>>

<<function archinit(arm)>>
@


\section{[[init/arm/]]}

\subsection*{[[init/arm/start.s]]}

<<init/arm/start.s>>=
/*
 * Common startup for armv6 and armv7
 * The rest of l.s has been moved to armv[67].s
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

/*
 * on bcm2836, only cpu0 starts here
 * other cpus enter at cpureset in armv7.s
 */
TEXT _start(SB), 1, $-4
    /*
     * load physical base for SB addressing while mmu is off
     * keep a handy zero in R0 until first function call
     */
    MOVW    $setR12(SB), R12
    SUB $KZERO, R12
    MOVW    $0, R0

    /*
     * SVC mode, interrupts disabled
     */
    MOVW    $(PsrDirq|PsrDfiq|PsrMsvc), R1
    MOVW    R1, CPSR

    /*
     * start stack at top of 'cpu' (physical addr)
     */
    MOVW    $PADDR(CPUADDR+CPUSIZE-4), R13

    /*
     * do arch-dependent startup (no return)
     */
    BL  armstart(SB)
    B   0(PC)

    RET
@

\subsection*{[[init/arm/startv6.s]]}

<<init/arm/startv6.s>>=
/*
 * Broadcom bcm2835 SoC, as used in Raspberry Pi
 * arm1176jzf-s processor (armv6)
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

TEXT armstart(SB), 1, $-4

    /*
     * disable the mmu and L1 caches
     * invalidate caches and tlb
     */
    MRC CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    BIC $(CpCdcache|CpCicache|CpCpredict|CpCmmu), R1 // Remove CpCpredict
    MCR CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl

    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvu), CpCACHEall
    MCR CpSC, 0, R0, C(CpTLB), C(CpTLBinvu), CpTLBinv
    ISB

    /*
     * clear mach and page tables
     */
    MOVW    $PADDR(CPUADDR), R1
    MOVW    $PADDR(KTZERO), R2
_ramZ:
    MOVW    R0, (R1)
    ADD $4, R1
    CMP R1, R2
    BNE _ramZ

    /*
     * start stack at top of CPUADDR (physical addr)
     * set up page tables for kernel
     */
    MOVW    $PADDR(CPUADDR+CPUSIZE-4), R13 // done already in start.s
    MOVW    $PADDR(L1), R0
    BL  mmuinit(SB)

    /*
     * set up domain access control and page table base
     */
    MOVW    $Client, R1
    MCR CpSC, 0, R1, C(CpDAC), C(0)

    MOVW    $PADDR(L1), R1
    MCR CpSC, 0, R1, C(CpTTB), C(0)

    /*
     * enable caches, mmu, and high vectors
     */
    MRC CpSC, 0, R0, C(CpCONTROL), C(0), CpMainctl
    ORR $(CpChv|CpCdcache|CpCicache|CpCmmu), R0
    MCR CpSC, 0, R0, C(CpCONTROL), C(0), CpMainctl
    ISB

    /*
     * switch SB, SP, and PC into KZERO space
     */
    MOVW    $setR12(SB), R12
    MOVW    $(CPUADDR+CPUSIZE-4), R13

    MOVW    $_startpg(SB), R15

TEXT _startpg(SB), 1, $-4

    /*
     * enable cycle counter
     */
    MOVW    $1, R1
    MCR CpSC, 0, R1, C(CpSPM), C(CpSPMperf), CpSPMctl // Not CpSPMcyc??

    /*
     * call main and loop forever if it returns
     */
    BL  main(SB)
    B   0(PC)

    BL  _div(SB)        /* hack to load _div, etc. */







        

TEXT arch_idlehands(SB), $-4
    MOVW    CPSR, R3
    ORR $(PsrDirq|PsrDfiq), R3, R1      /* splfhi */
    MOVW    R1, CPSR

    DSB
    MOVW    nrdy(SB), R0
    CMP $0, R0
    MCR.EQ  CpSC, 0, R0, C(CpCACHE), C(CpCACHEintr), CpCACHEwait
    DSB

    MOVW    R3, CPSR            /* splx */
    RET
@

\subsection*{[[init/arm/startv7.s]]}

<<init/arm/startv7.s>>=
/*
 * Broadcom bcm2836 SoC, as used in Raspberry Pi 2
 * 4 x Cortex-A7 processor (armv7)
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

#define WFI WORD    $0xe320f003 /* wait for interrupt */
#define WFI_EQ  WORD    $0x0320f003 /* wait for interrupt if eq */


TEXT armstart(SB), 1, $-4

    /*
     * if not cpu0, go to secondary startup
     */
    CPUID(R1)
    BNE reset

    /*
     * disable the mmu and caches
     * invalidate tlb
     */
    MRC CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    BIC $(CpCdcache|CpCicache|CpCmmu), R1
    ORR $(CpCsbo|CpCsw), R1
    BIC $CpCsbz, R1
    MCR CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    MCR CpSC, 0, R0, C(CpTLB), C(CpTLBinvu), CpTLBinv
    ISB

    /*
     * clear mach and page tables
     */
    MOVW    $PADDR(CPUADDR), R1
    MOVW    $PADDR(KTZERO), R2
_ramZ:
    MOVW    R0, (R1)
    ADD $4, R1
    CMP R1, R2
    BNE _ramZ

    /*
     * start stack at top of mach (physical addr)
     * set up page tables for kernel
     */
    MOVW    $PADDR(CPUADDR+CPUSIZE-4), R13
    MOVW    $PADDR(L1), R0
    BL  ,mmuinit(SB)

    /*
     * set up domain access control and page table base
     */
    MOVW    $Client, R1
    MCR CpSC, 0, R1, C(CpDAC), C(0)
    MOVW    $PADDR(L1), R1
    ORR     $(CpTTBs/*|CpTTBowba|CpTTBiwba*/), R1
    MCR CpSC, 0, R1, C(CpTTB), C(0)
    MCR CpSC, 0, R1, C(CpTTB), C(0), CpTTB1 /* cortex has two */

    /*
     * invalidate my caches before enabling
     */
    BL  cachedinv(SB)
    BL  cacheiinv(SB)
    BL  l2cacheuinv(SB)
    BARRIERS

    /*
     * enable caches, mmu, and high vectors
     */
    MRC CpSC, 0, R1, C(CpCONTROL), C(0), CpAuxctl
    ORR $CpACsmp, R1        /* turn SMP on */
    MCR CpSC, 0, R1, C(CpCONTROL), C(0), CpAuxctl
    BARRIERS

    MRC CpSC, 0, R0, C(CpCONTROL), C(0), CpMainctl
    ORR $(CpChv|CpCdcache|CpCicache|CpCmmu), R0
    MCR CpSC, 0, R0, C(CpCONTROL), C(0), CpMainctl
    BARRIERS

    /*
     * switch SB, SP, and PC into KZERO space
     */
    MOVW    $setR12(SB), R12
    MOVW    $(CPUADDR+CPUSIZE-4), R13
    MOVW    $_startpg(SB), R15

TEXT _startpg(SB), 1, $-4

    /*
     * enable cycle counter
     */
    MOVW    $(1<<31), R1
    MCR CpSC, 0, R1, C(CpCLD), C(CpCLDena), CpCLDenacyc
    MOVW    $1, R1
    MCR CpSC, 0, R1, C(CpCLD), C(CpCLDena), CpCLDenapmnc

    /*
     * call main and loop forever if it returns
     */
    BL  main(SB)
    B   0(PC)

    BL  _div(SB)        /* hack to load _div, etc. */

/*
 * startup entry for cpu(s) other than 0
 */
TEXT cpureset(SB), 1, $-4
reset:
    /*
     * load physical base for SB addressing while mmu is off
     * keep a handy zero in R0 until first function call
     */
    MOVW    $setR12(SB), R12
    SUB $KZERO, R12
    MOVW    $0, R0

    /*
     * SVC mode, interrupts disabled
     */
    MOVW    $(PsrDirq|PsrDfiq|PsrMsvc), R1
    MOVW    R1, CPSR

    /*
     * disable the mmu and caches
     * invalidate tlb
     */
    MRC CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    BIC $(CpCdcache|CpCicache|CpCmmu), R1
    ORR $(CpCsbo|CpCsw), R1
    BIC $CpCsbz, R1
    MCR CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    MCR CpSC, 0, R0, C(CpTLB), C(CpTLBinvu), CpTLBinv
    ISB

    /*
     * find Mach for this cpu
     */
    MRC CpSC, 0, R2, C(CpID), C(CpIDidct), CpIDmpid
    AND $(MAXCPUS-1), R2    /* mask out non-cpu-id bits */
    SLL $2, R2          /* convert to word index */
    MOVW    $cpus(SB), R0
    ADD R2, R0          /* R0 = &cpus[cpuid] */
    MOVW    (R0), R0        /* R0 = cpus[cpuid] */
    CMP $0, R0
    MOVW.EQ $CPUADDR, R0        /* paranoia: use CPUADDR if 0 */
    SUB $KZERO, R0      /* phys addr */
    MOVW    R0, R(CPU)      /* m = PADDR(cpus[cpuid]) */

    /*
     * start stack at top of local Mach
     */
    MOVW    R(CPU), R13
    ADD     $(CPUSIZE-4), R13

    /*
     * set up page tables for kernel
     */
    MOVW    12(R(CPU)), R0  /* m->mmul1 */
    SUB $KZERO, R0      /* phys addr */
    BL  mmuinit(SB)

    /*
     * set up domain access control and page table base
     */
    MOVW    $Client, R1
    MCR CpSC, 0, R1, C(CpDAC), C(0)
    MOVW    12(R(CPU)), R1  /* m->mmul1 */
    SUB $KZERO, R1      /* phys addr */
    ORR     $(CpTTBs/*|CpTTBowba|CpTTBiwba*/), R1
    MCR CpSC, 0, R1, C(CpTTB), C(0)
    MCR CpSC, 0, R1, C(CpTTB), C(0), CpTTB1 /* cortex has two */

    /*
     * invalidate my caches before enabling
     */
    BL  cachedinv(SB)
    BL  cacheiinv(SB)
    BARRIERS

    /*
     * enable caches, mmu, and high vectors
     */
    MRC CpSC, 0, R1, C(CpCONTROL), C(0), CpAuxctl
    ORR $CpACsmp, R1        /* turn SMP on */
    MCR CpSC, 0, R1, C(CpCONTROL), C(0), CpAuxctl
    BARRIERS

    MRC CpSC, 0, R0, C(CpCONTROL), C(0), CpMainctl
    ORR $(CpChv|CpCdcache|CpCicache|CpCmmu), R0
    MCR CpSC, 0, R0, C(CpCONTROL), C(0), CpMainctl
    BARRIERS

    /*
     * switch CPU, SB, SP, and PC into KZERO space
     */
    ADD $KZERO, R(CPU)
    MOVW    $setR12(SB), R12
    ADD $KZERO, R13
    MOVW    $_startpg2(SB), R15

TEXT _startpg2(SB), 1, $-4

    /*
     * enable cycle counter
     */
    MOVW    $(1<<31), R1
    MCR CpSC, 0, R1, C(CpCLD), C(CpCLDena), CpCLDenacyc
    MOVW    $1, R1
    MCR CpSC, 0, R1, C(CpCLD), C(CpCLDena), CpCLDenapmnc

    /*
     * call cpustart and loop forever if it returns
     */
    MRC CpSC, 0, R0, C(CpID), C(CpIDidct), CpIDmpid
    AND $(MAXCPUS-1), R0            /* mask out non-cpu-id bits */
    BL  ,cpustart(SB)
    B   ,0(PC)



        
TEXT cpctget(SB), 1, $-4            /* cache type */
    MRC CpSC, 0, R0, C(CpID), C(CpIDidct), CpIDct
    RET

TEXT cpidget(SB), 1, $-4            /* main ID */
    MRC CpSC, 0, R0, C(CpID), C(0), CpIDid
    RET


TEXT arch_idlehands(SB), $-4
    MOVW    CPSR, R3
    ORR $(PsrDirq|PsrDfiq), R3, R1      /* splfhi */
    MOVW    R1, CPSR

    DSB
    MOVW    nrdy(SB), R0
    CMP $0, R0
/*** with WFI, local timer interrupts can be lost and dispatching stops
    WFI_EQ
***/
    DSB

    MOVW    R3, CPSR            /* splx */
    RET
@

\subsection*{[[init/arm/main.c]]}

<<constant Minfirmrev(arm)>>=
/* Firmware compatibility */
#define Minfirmrev  326770
@

<<constant Minfirmdate(arm)>>=
#define Minfirmdate "19 Aug 2013"
@

<<function getconf(arm)>>=
char*
getconf(char *name)
{
    USED(name);
    //int i;
    // 
    //i = findconf(name);
    //if(i >= 0)
    //  return confval[i];
    return nil;
}
@

<<function cpuinit(arm)>>=
void
cpuinit(void)
{
    Cpu *m0;

    cpu->ticks = 1;
    cpu->perf.period = 1;

    m0 = CPUS(0);
    if (cpu->cpuno != 0) {
        /* synchronise with cpu 0 */
        cpu->ticks = m0->ticks;
        cpu->fastclock = m0->fastclock;
        cpu->delayloop = m0->delayloop;
    }
    //machon(m->cpuno);
}
@

<<function cpu0init(arm)>>=
void
cpu0init(void)
{
    conf.ncpu = 0; // set in machon instead called after cpuinit

    cpu->cpuno = 0;
    cpus[cpu->cpuno] = cpu;

    cpuinit();
    active.exiting = 0;

    up = nil;
}
@

<<function machon(arm)>>=
/* enable scheduling of this cpu */
void
machon(uint xcpu)
{
    ulong cpubit;

    cpubit = 1 << xcpu;
    lock(&active);
    if ((active.cpus & cpubit) == 0) {  /* currently off? */
        conf.ncpu++;
        active.cpus |= cpubit;
    }
    unlock(&active);
}
@

<<global memsize(arm)>>=
// used also in mmu.c
ulong   memsize = 128*1024*1024;
@

<<function confinit(arm)>>=
void
confinit(void)
{
    int i;
    ulong kpages;
    uintptr pa;
    char *p;

    //if(0 && (p = getconf("service")) != nil){
    //  if(strcmp(p, "cpu") == 0)
    //      cpuserver = 1;
    //  else if(strcmp(p,"terminal") == 0)
    //      cpuserver = 0;
    //}
    if((p = getconf("*maxmem")) != nil){
        memsize = strtoul(p, 0, 0);
        if (memsize < 16*MB)        /* sanity */
            memsize = 16*MB;
    }
    // simpler than for x86 :)
    getramsize(&conf.mem[0]);

    if(conf.mem[0].limit == 0){
        conf.mem[0].base = 0;
        conf.mem[0].limit = memsize;
    }else if(p != nil)
        conf.mem[0].limit = conf.mem[0].base + memsize;

    conf.npage = 0;
    pa = PADDR(PGROUND(PTR2UINT(end)));

    /*
     *  we assume that the kernel is at the beginning of one of the
     *  contiguous chunks of memory and fits therein.
     */
    for(i=0; i<nelem(conf.mem); i++){
        /* take kernel out of allocatable space */
        if(pa > conf.mem[i].base && pa < conf.mem[i].limit)
            conf.mem[i].base = pa;

        conf.mem[i].npage = (conf.mem[i].limit - conf.mem[i].base)/BY2PG;
        conf.npage += conf.mem[i].npage;
    }

    conf.upages = (conf.npage*80)/100;
    kpages = conf.npage - conf.upages;

    /* set up other configuration parameters */
    conf.ialloc = (kpages/2)*BY2PG; // max bytes for iallocb
    conf.nproc = 100 + ((conf.npage*BY2PG)/MB)*5;
    if(cpuserver)
        conf.nproc *= 3;
    if(conf.nproc > 2000)
        conf.nproc = 2000;
    conf.nswap = conf.npage*3;
    conf.nswppo = 4096;
    conf.nimage = 200;

    conf.copymode = 1;      /* copy on reference, not copy on write */

    /*
     * Guess how much is taken by the large permanent
     * datastructures. Mntcache and Mntrpc are not accounted for
     * (probably ~300KB).
     */
    kpages *= BY2PG;
    kpages -= 
          conf.upages*sizeof(Page)
        + conf.nproc*sizeof(Proc)
        + conf.nimage*sizeof(KImage)
        + conf.nswap
        + conf.nswppo*sizeof(Page); // BUG, Page -> Page*?

    // memory pool
    mainmem->maxsize = kpages;

    if(!cpuserver)
        /*
         * give terminals lots of image memory, too; the dynamic
         * allocation will balance the load properly, hopefully.
         * be careful with 32-bit overflow.
         */
        imagmem->maxsize = kpages;
}
@

<<global sp(arm)>>=
static uintptr sp;      /* XXX - must go - user stack of init proc */
@

<<function init0(arm)>>=
/*
 *  starting place for first process
 */
void
init0(void)
{
    int i;
    char buf[2*KNAMELEN];

    up->nerrlab = 0;
    arch_coherence();
    arch_spllo();

    /*
     * These are o.k. because rootinit is null.
     * Then early kproc's will have a root and dot.
     */
    up->slash = namec("#/", Atodir, 0, 0);
    pathclose(up->slash->path);
    up->slash->path = newpath("/");
    up->dot = cclone(up->slash);

    chandevinit();

    if(!waserror()){
        snprint(buf, sizeof(buf), "%s %s", "ARM", conffile);
        ksetenv("terminal", buf, 0);
        ksetenv("cputype", "arm", 0);
        if(cpuserver)
            ksetenv("service", "cpu", 0);
        else
            ksetenv("service", "terminal", 0);
        snprint(buf, sizeof(buf), "-a %s", getethermac());
        ksetenv("etherargs", buf, 0);

        /* convert plan9.ini variables to #e and #ec */
        for(i = 0; i < nconf; i++) {
            ksetenv(confname[i], confval[i], 0);
            ksetenv(confname[i], confval[i], 1);
        }
        poperror();
    }
    kproc("alarm", alarmkproc, nil); // ??
    arch_touser(sp);
    assert(0);          /* shouldn't have returned */
}
@

<<function userinit(arm)>>=
/*
 *  create the first process
 */
void
userinit(void)
{
    Proc *p;
    Segment *s;
    Arch_KMap *k;
    Page *pg;

    /* no processes yet */
    up = nil;

    p = newproc();
    p->pgrp = newpgrp();
    p->egrp = smalloc(sizeof(Egrp));
    p->egrp->ref = 1;
    p->fgrp = dupfgrp(nil);
    p->rgrp = newrgrp();
    p->procmode = 0640;

    kstrdup(&eve, "");
    kstrdup(&p->text, "*init*");
    kstrdup(&p->user, eve);

    /*
     * Kernel Stack
     */
    p->sched.pc = PTR2UINT(init0);
    p->sched.sp = PTR2UINT(p->kstack + KSTACK
                           - sizeof(up->sargs.args)
                           - sizeof(uintptr));
    p->sched.sp = STACKALIGN(p->sched.sp);

    /*
     * User Stack
     *
     * Technically, newpage can't be called here because it
     * should only be called when in a user context as it may
     * try to sleep if there are no pages available, but that
     * shouldn't be the case here.
     */
    s = newseg(SG_STACK, USTKTOP-USTKSIZE, USTKSIZE/BY2PG);
    s->flushme++;
    p->seg[SSEG] = s;
    pg = newpage(true, nil, USTKTOP-BY2PG);
    segpage(s, pg);

    k = arch_kmap(pg);
    sp = bootargs(VA(k));
    arch_kunmap(k);

    /*
     * Text
     */
    s = newseg(SG_TEXT, UTZERO, 1); // initcode needs only 1 page
    p->seg[TSEG] = s;
    pg = newpage(true, nil, UTZERO);
    memset(pg->cachectl, PG_TXTFLUSH, sizeof(pg->cachectl));
    segpage(s, pg);

    k = arch_kmap(s->pagedir[0]->pagetab[0]);
    memmove(UINT2PTR(VA(k)), initcode, sizeof initcode);
    arch_kunmap(k);

    // ready to go!
    ready(p);
}
@

<<function shutdown (init/arm/main.c)(arm)>>=
static void
shutdown(int ispanic)
{
    int ms, once;

    lock(&active);
    if(ispanic)
        active.ispanic = ispanic;
    else if(cpu->cpuno == 0 && (active.cpus & (1 << cpu->cpuno)) == 0)
        active.ispanic = 0;
    once = active.cpus & (1 << cpu->cpuno);
    active.cpus &= ~(1 << cpu->cpuno);
    active.exiting = 1;
    unlock(&active);

    if(once)
        iprint("cpu%d: exiting\n", cpu->cpuno);
    arch_spllo();
    for(ms = 5*1000; ms > 0; ms -= TK2MS(2)){
        arch_delay(TK2MS(2));
        if(active.cpus == 0 && consactive() == 0)
            break;
    }
    arch_delay(100*cpu->cpuno);
}
@

<<function main_arch_exit(arm)>>=
/*
 *  exit kernel either on a panic or user request
 */
void
main_arch_exit(int code)
{
    void (*f)(ulong, ulong, ulong);

    shutdown(code);
    splfhi();
    if(cpu->cpuno == 0)
        archreboot();
    else{
        f = (void*)REBOOTADDR;
        intrcpushutdown();
        cacheuwbinv();
        l2cacheuwbinv();
        (*f)(0, 0, 0);
        for(;;){}
    }
}
@

<<function arch_reboot(arm)>>=
/*
 * the new kernel is already loaded at address `code'
 * of size `size' and entry point `entry'.
 */
void
arch_reboot(void *entry, void *code, ulong size)
{
    void (*f)(ulong, ulong, ulong);

    //writeconf();

    /*
     * the boot processor is cpu0.  execute this function on it
     * so that the new kernel has the same cpu0.
     */
    if (cpu->cpuno != 0) {
        procwired(up, 0);
        sched();
    }
    if (cpu->cpuno != 0)
        print("on cpu%d (not 0)!\n", cpu->cpuno);

    /* setup reboot trampoline function */
    f = (void*)REBOOTADDR;
    memmove(f, rebootcode, sizeof(rebootcode));
    cachedwbse(f, sizeof(rebootcode));

    shutdown(0);

    /*
     * should be the only processor running now
     */

    arch_delay(5000);
    print("active.machs = %x\n", active.cpus);
    print("reboot entry %#lux code %#lux size %ld\n",
        PADDR(entry), PADDR(code), size);
    arch_delay(100);

    /* turn off buffered serial console */
    serialoq = nil;
    kprintoq = nil;
    screenputs = nil;

    /* shutdown devices */
    if(!waserror()){
        chandevshutdown();
        poperror();
    }

    /* stop the clock (and watchdog if any) */
    clockshutdown();

    splfhi();
    intrshutdown();

    /* off we go - never to return */
    cacheuwbinv();
    l2cacheuwbinv();
    (*f)(PADDR(entry), PADDR(code), size);

    iprint("loaded kernel returned!\n");
    arch_delay(1000);
    archreboot();
}
@

<<function main_arch_isaconfig(arm)>>=
/*
 * stub for ../omap/devether.c
 */
int
main_arch_isaconfig(char *class, int ctlrno, ISAConf *isa)
{
    char cc[32], *p;
    int i;

    if(strcmp(class, "ether") != 0)
        return 0;
    snprint(cc, sizeof cc, "%s%d", class, ctlrno);
    p = getconf(cc);
    if(p == nil)
        return (ctlrno == 0);
    isa->type = "";
    isa->nopt = tokenize(p, isa->opt, NISAOPT);
    for(i = 0; i < isa->nopt; i++){
        p = isa->opt[i];
        if(cistrncmp(p, "type=", 5) == 0)
            isa->type = p + 5;
    }
    return 1;
}
@

<<function arch_memorysummary(arm)>>=
// called from devcons.c
void
arch_memorysummary(void) {
}
@

<<function launchinit(arm)>>=
void
launchinit(int ncpus)
{
    int mach;
    Cpu *mm;
    PTE *l1;

    if(ncpus > MAXCPUS)
        ncpus = MAXCPUS;
    for(mach = 1; mach < ncpus; mach++){
        cpus[mach] = mm = mallocalign(CPUSIZE, CPUSIZE, 0, 0);
        l1 = mallocalign(L1SIZE, L1SIZE, 0, 0);
        if(mm == nil || l1 == nil)
            panic("launchinit");
        memset(mm, 0, CPUSIZE);
        mm->cpuno = mach;

        memmove(l1, cpu->mmul1, L1SIZE);  /* clone cpu0's l1 table */
        cachedwbse(l1, L1SIZE);
        mm->mmul1 = l1;
        cachedwbse(mm, CPUSIZE);

    }
    cachedwbse(cpus, sizeof cpus);
    if((mach = startcpus(ncpus)) < ncpus)
            panic("only %d cpu%s started", mach, mach == 1? "" : "s");
}
@

<<function main(arm)>>=
void
main(void)
{
    uint firmware, board;

    // backward deps breaker!
    devtab = conf_devtab;

    print = devcons_print;
    iprint = devcons_iprint;
    pprint = devcons_pprint;
    panic = devcons_panic;
    _assert = devcons__assert;
    error = proc_error;
    nexterror = proc_nexterror;
    dumpaproc = proc_dumpaproc;
    wakeup = proc_wakeup;
    sched = proc_sched;
    ready = proc_ready;
    sleep = proc_sleep;
    tsleep = proc_tsleep;
    cclose = chan_cclose;
    proctab = proc_proctab;
    postnote = proc_postnote;
    pexit = proc_pexit;

    arch_exit = main_arch_exit;
    arch_dumpstack = trap_arch_dumpstack;
    arch_delay = clock_arch_delay;
    arch_microdelay = clock_arch_microdelay;
    arch_coherence = arm_arch_coherence;
    arch_fastticks = clock_arch_fastticks;
    arch_isaconfig = main_arch_isaconfig;

    // Let's go!

    cpu = (Cpu*)CPUADDR;
    memset(edata, 0, end - edata);  /* clear bss */
    cpu0init();
    mmuinit1((void*)L1);
    machon(0);

    quotefmtinstall();

    //optionsinit("/boot/boot boot");
    //ataginit((Atag*)BOOTARGS);

    confinit();     /* figures out amount of memory */
    xinit();

    uartconsinit();

    arch_screeninit();

    print("\nPlan 9 from Bell Labs\n"); // yeah!

    board = getboardrev();
    firmware = getfirmware();
    print("board rev: %#ux firmware rev: %d\n", board, firmware);
    if(firmware < Minfirmrev){
        print("Sorry, firmware (start*.elf) must be at least rev %d"
              " or newer than %s\n", Minfirmrev, Minfirmdate);
        for(;;)
            ;
    }
    /* set clock rate to arm_freq from config.txt (default pi1:700Mhz pi2:900MHz) */
    setclkrate(ClkArm, 0);

    arch_trapinit();
    clockinit();

    lineqinit();
    timersinit();
    swcursor_init(); //if(conf.monitor)

    arch_cpuidprint();
    archreset();

    procinit();
    imageinit();

    links();
    chandevreset();         /* most devices are discovered here */

    pageinit();
    swapinit();

    userinit();

    launchinit(getncpus());

    // schedule the only ready user process (the one created by userinit)
    schedinit();

    assert(0);          /* shouldn't have returned */
}
@


%-------------------------------------------------------------

<<init/arm/main.c>>=
<<kernel basic includes>>

#include "io.h"
// for mainmem and imagmem
#include <pool.h>

// initcode binary
#include "init.h"

// rebootcode binary
#include "reboot.h"

// in portscreen.h
extern void swcursor_init(void);

<<constant Minfirmrev(arm)>>
<<constant Minfirmdate(arm)>>


// part of a trick to remove some backward dependencies
int devcons_print(char*, ...);
int devcons_iprint(char*, ...);
int devcons_pprint(char*, ...);
void devcons_panic(char*, ...);
void devcons__assert(char*);
void proc_dumpaproc(Proc *p);
void proc_error(char*);
void proc_nexterror(void);
void proc_sched(void);
void proc_ready(Proc*);
void proc_sleep(Rendez*, int(*)(void*), void*);
void proc_tsleep(Rendez *r, int (*fn)(void*), void *arg, ulong ms);
Proc* proc_wakeup(Rendez*);
void proc_pexit(char *exitstr, bool freemem);
Proc* proc_proctab(int i);
int proc_postnote(Proc *p, int dolock, char *n, int flag);
void chan_cclose(Chan *c);

uvlong clock_arch_fastticks(uvlong *hz);
void clock_arch_delay(int millisecs);
void clock_arch_microdelay(int microsecs);
void trap_arch_dumpstack(void);
void arm_arch_coherence(void);
void main_arch_exit(int ispanic);
int  main_arch_isaconfig(char *class, int ctlrno, ISAConf *isa);

//*****************************************************************************
// Configuration
//*****************************************************************************
// See globals in portdat_globals.h

// <conf>.c
extern  Dev*  conf_devtab[];
extern  char*   conffile;

<<function getconf(arm)>>

//*****************************************************************************
// Boot parameters, see bootconf.c (not used by pad)
//*****************************************************************************

//*****************************************************************************
// Cpu init
//*****************************************************************************
<<function cpuinit(arm)>>

<<function cpu0init(arm)>>

<<function machon(arm)>>

//*****************************************************************************
// Conf init
//*****************************************************************************

<<global memsize(arm)>>

<<function confinit(arm)>>

//*****************************************************************************
// First process init
//*****************************************************************************

<<global sp(arm)>>

// kernel space instructions executed by first process
<<function init0(arm)>>

// user space instructions executed by first process
// see initcode in init.h (comes from ../port/initcode.c and init9.s

extern uintptr bootargs(uintptr base);
<<function userinit(arm)>>


//*****************************************************************************
// Shutdown/reboot
//*****************************************************************************

<<function shutdown (init/arm/main.c)(arm)>>

<<function main_arch_exit(arm)>>

<<function arch_reboot(arm)>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<function main_arch_isaconfig(arm)>>


<<function arch_memorysummary(arm)>>

//*****************************************************************************
// Main entry point!
//*****************************************************************************

<<function launchinit(arm)>>

<<function main(arm)>>
@


\subsection*{[[init/arm/raspi1.c]]}


<<function cputype2name(arm)>>=
char*
cputype2name(char *buf, int size)
{
    seprint(buf, buf + size, "1176JZF-S");
    return buf;
}
@

<<function arch_cpuidprint(arm)>>=
void
arch_cpuidprint(void)
{
    char name[64];

    cputype2name(name, sizeof name);
    arch_delay(50);             /* let uart catch up */
    print("cpu%d: %dMHz ARM %s\n", cpu->cpuno, cpu->cpumhz, name);
}
@

<<function getncpus(arm)>>=
int
getncpus(void)
{
    return 1;
}
@

<<function startcpus(arm)>>=
int
startcpus(uint)
{
    return 1;
}
@

<<function archether(arm)>>=
int
archether(unsigned ctlrno, Ether *ether)
{
    ether->type = "usb";
    ether->ctlrno = ctlrno;
    ether->irq = -1;
    ether->nopt = 0;
    return 1;
}
@

<<function l2ap(arm)>>=
int
l2ap(int ap)
{
    return (AP(3, (ap))|AP(2, (ap))|AP(1, (ap))|AP(0, (ap)));
}
@


%-------------------------------------------------------------

<<init/arm/raspi1.c>>=
/*
 * bcm2835 (e.g. original raspberry pi) architecture-specific stuff
 */
<<kernel basic includes>>

#include "io.h"
#include "arm.h"

#include "../port/netif.h"
#include "../port/etherif.h"

<<global soc(raspberry pi1)(arm)>>

    
<<function cputype2name(arm)>>

<<function arch_cpuidprint(arm)>>

<<function getncpus(arm)>>

<<function startcpus(arm)>>


<<function archether(arm)>>

<<function l2ap(arm)>>
@


\subsection*{[[init/arm/raspi2.c]]}

<<constant ARMLOCAL(arm)>>=
#define ARMLOCAL    (VIRTIO+IOSIZE)
@
\t put in mem.h so can reuse in different files

%-------------------------------------------------------------

<<init/arm/raspi2.c>>=
/*
 * bcm2836 (e.g.raspberry pi 2) architecture-specific stuff
 */
<<kernel basic includes>>

#include "io.h"
#include "arm.h"

#include "../port/netif.h"
#include "../port/etherif.h"

typedef struct Mbox Mbox;
typedef struct Mboxes Mboxes;

<<constant ARMLOCAL(arm)>>

Soc soc = {
    .dramsize   = 1024*MiB,
    .physio     = 0x3F000000,
    .busdram    = 0xC0000000,
    .busio      = 0x7E000000,
    .armlocal   = 0x40000000,
    .l1ptedramattrs = Cached | Buffered | L1wralloc | L1sharable,
    .l2ptedramattrs = Cached | Buffered | L2wralloc | L2sharable,
};


/*
 * Arm local regs for smp
 */
struct Mbox {
    u32int  doorbell;
    u32int  mbox1;
    u32int  mbox2;
    u32int  startcpu;
};
struct Mboxes {
    Mbox    set[4];
    Mbox    clr[4];
};

enum {
    Mboxregs    = 0x80
};

static Lock startlock[MAXCPUS + 1];

// in startv7.s
extern u32int cpidget(void);

char*
cputype2name(char *buf, int size)
{
    ulong r;

    r = cpidget();          /* main id register */
    assert((r >> 24) == 'A');
    seprint(buf, buf + size, "Cortex-A7 r%ldp%ld",
        (r >> 20) & MASK(4), r & MASK(4));
    return buf;
}

void
arch_cpuidprint(void)
{
    char name[64];

    cputype2name(name, sizeof name);
    arch_delay(50);             /* let uart catch up */
    print("cpu%d: %dMHz ARM %s\n", cpu->cpuno, cpu->cpumhz, name);
}

int
getncpus(void)
{
    int n, max;
    char *p;

    n = 4;
    if(n > MAXCPUS)
        n = MAXCPUS;
    p = getconf("*ncpu");
    if(p && (max = atoi(p)) > 0 && n > max)
        n = max;
    return n;
}

static int
startcpu(uint cpu)
{
    Mboxes *mb;
    int i;
    void cpureset();

    mb = (Mboxes*)(ARMLOCAL + Mboxregs);
    if(mb->clr[cpu].startcpu)
        return -1;
    mb->set[cpu].startcpu = PADDR(cpureset);
    for(i = 0; i < 1000; i++)
        if(mb->clr[cpu].startcpu == 0)
            return 0;
    mb->clr[cpu].startcpu = PADDR(cpureset);
    mb->set[cpu].doorbell = 1;
    return 0;
}

int
startcpus(uint ncpu)
{
    int i;

    for(i = 0; i < ncpu; i++)
        lock(&startlock[i]);
    cachedwbse(startlock, sizeof startlock);
    for(i = 1; i < ncpu; i++){
        if(startcpu(i) < 0)
            return i;
        lock(&startlock[i]);
        unlock(&startlock[i]);
    }
    return ncpu;
}


int
archether(unsigned ctlrno, Ether *ether)
{
    ether->type = "usb";
    ether->ctlrno = ctlrno;
    ether->irq = -1;
    ether->nopt = 0;
    return 1;
}

int
l2ap(int ap)
{
    return (AP(0, (ap)));
}


// in main.c
extern void cpuinit(void);
extern void machon(uint);

//TODO: cpus[] set? and cpu->cpuno??
void
cpustart(int xcpu)
{
    Mboxes *mb;

    up = nil;
    cpuinit();
    mmuinit1((void*)cpu->mmul1);

    mb = (Mboxes*)(ARMLOCAL + Mboxregs);
    mb->clr[xcpu].doorbell = 1;

    arch_trapinit();
    clockinit();
    timersinit();
    arch_cpuidprint();
    archreset();

    machon(cpu->cpuno);
    unlock(&startlock[xcpu]);

    // schedule a ready process (not necessarily the first one now)
    schedinit();

    panic("schedinit returned");
}
@

\subsection*{[[init/arm/bootconf.c]]}

<<enum _anon_ (init/arm/bootconf.c)(arm)>>=
enum {
    /* space for syscall args, return PC, top-of-stack struct */
    Ustkheadroom    = sizeof(Sargs) + sizeof(uintptr) + sizeof(Tos),
};
@

<<constant BOOTARGS(arm)>>=
/*
 * Where configuration info is left for the loaded programme.
 */
#define BOOTARGS    ((char*)CONFADDR)
@

<<constant BOOTARGSLEN(arm)>>=
#define BOOTARGSLEN (CPUADDR-CONFADDR)
@

<<global oargc(arm)>>=
/*
 * Option arguments from the command line.
 * oargv[0] is the boot file.
 */
static int oargc;
@

<<global oargv(arm)>>=
static char* oargv[20];
@

<<global oargb(arm)>>=
static char oargb[128];
@

<<global oargblen(arm)>>=
static int oargblen;
@

<<struct Atag(arm)>>=
struct Atag {
    u32int  size;   /* size of atag in words, including this header */
    u32int  tag;    /* atag type */
    union {
        u32int  data[1];    /* actually [size-2] */
        /* AtagMem */
        struct {
            u32int  size;
            u32int  base;
        } mem;
        /* AtagCmdLine */
        char    cmdline[1]; /* actually [4*(size-2)] */
    };
};
@

<<enum _anon_ (init/arm/bootconf.c)2(arm)>>=
enum {
    AtagNone    = 0x00000000,
    AtagCore    = 0x54410001,
    AtagMem     = 0x54410002,
    AtagCmdline = 0x54410009,
};
@

<<function findconf(arm)>>=
static int
findconf(char *name)
{
    int i;

    for(i = 0; i < nconf; i++)
        if(cistrcmp(confname[i], name) == 0)
            return i;
    return -1;
}
@

<<function addconf(arm)>>=
void
addconf(char *name, char *val)
{
    int i;

    i = findconf(name);
    if(i < 0){
        if(val == nil || nconf >= MAXCONF)
            return;
        i = nconf++;
        strecpy(confname[i], confname[i]+sizeof(confname[i]), name);
    }
    strecpy(confval[i], confval[i]+sizeof(confval[i]), val);
}
@

<<function writeconf(arm)>>=
static void
writeconf(void)
{
    char *p, *q;
    int n;

    p = getconfenv();

    if(waserror()) {
        free(p);
        nexterror();
    }

    /* convert to name=value\n format */
    for(q=p; *q; q++) {
        q += strlen(q);
        *q = '=';
        q += strlen(q);
        *q = '\n';
    }
    n = q - p + 1;
    if(n >= BOOTARGSLEN)
        error("kernel configuration too large");
    memmove(BOOTARGS, p, n);
    memset(BOOTARGS + n, '\n', BOOTARGSLEN - n);
    poperror();
    free(p);
}
@

<<function plan9iniinit(arm)>>=
static void
plan9iniinit(char *s, int cmdline)
{
    char *toks[MAXCONF];
    int i, c, n;
    char *v;

    if((c = *s) < ' ' || c >= 0x80)
        return;
    if(cmdline)
        n = tokenize(s, toks, MAXCONF);
    else
        n = getfields(s, toks, MAXCONF, 1, "\n");
    for(i = 0; i < n; i++){
        if(toks[i][0] == '#')
            continue;
        v = strchr(toks[i], '=');
        if(v == nil)
            continue;
        *v++ = '\0';
        addconf(toks[i], v);
    }
}
@

<<function ataginit(arm)>>=
static void
ataginit(Atag *a)
{
    int n;

    if(a->tag != AtagCore){
        plan9iniinit((char*)a, 0);
        return;
    }
    while(a->tag != AtagNone){
        switch(a->tag){
        case AtagMem:
            /* use only first bank */
            if(conf.mem[0].limit == 0 && a->mem.size != 0){
                memsize = a->mem.size;
                conf.mem[0].base = a->mem.base;
                conf.mem[0].limit = a->mem.base + memsize;
            }
            break;
        case AtagCmdline:
            n = (a->size * sizeof(u32int)) - offsetof(Atag, cmdline[0]);
            if(a->cmdline + n < BOOTARGS + BOOTARGSLEN)
                a->cmdline[n] = 0;
            else
                BOOTARGS[BOOTARGSLEN-1] = 0;
            plan9iniinit(a->cmdline, 1);
            break;
        }
        a = (Atag*)((u32int*)a + a->size);
    }
}
@

<<function optionsinit(arm)>>=
static void
optionsinit(char* s)
{
    strecpy(oargb, oargb+sizeof(oargb), s);

    oargblen = strlen(oargb);
    oargc = tokenize(oargb, oargv, nelem(oargv)-1);
    oargv[oargc] = nil;
}
@

<<function bootargs(arm)>>=
uintptr
bootargs(uintptr base)
{
    int i;
    ulong ssize;
    char **av, *p;

    /*
     * Push the boot args onto the stack.
     * The initial value of the user stack must be such
     * that the total used is larger than the maximum size
     * of the argument list checked in syscall.
     */
    i = oargblen+1;
    p = UINT2PTR(STACKALIGN(base + BY2PG - Ustkheadroom - i));
    memmove(p, oargb, i);

    /*
     * Now push the argv pointers.
     * The code jumped to by touser in lproc.s expects arguments
     *  main(char* argv0, ...)
     * and calls
     *  startboot("/boot/boot", &argv0)
     * not the usual (int argc, char* argv[])
     */
    av = (char**)(p - (oargc+1)*sizeof(char*));
    ssize = base + BY2PG - PTR2UINT(av);
    for(i = 0; i < oargc; i++)
        *av++ = (oargv[i] - oargb) + (p - base) + (USTKTOP - BY2PG);
    *av = nil;
    //sp = USTKTOP - ssize;
    return USTKTOP - ssize;
}
@


%-------------------------------------------------------------

<<init/arm/bootconf.c>>=
<<kernel basic includes>>

#include "tos.h"

<<enum _anon_ (init/arm/bootconf.c)(arm)>>

<<constant BOOTARGS(arm)>>
<<constant BOOTARGSLEN(arm)>>
//#define MAXCONF       64
//#define MAXCONFLINE   160

<<global oargc(arm)>>
<<global oargv(arm)>>
<<global oargb(arm)>>
<<global oargblen(arm)>>

/* store plan9.ini contents here at least until we stash them in #ec */
//static char confname[MAXCONF][KNAMELEN];
//static char confval[MAXCONF][MAXCONFLINE];
//static int nconf;

typedef struct Atag Atag;
<<struct Atag(arm)>>

<<enum _anon_ (init/arm/bootconf.c)2(arm)>>

<<function findconf(arm)>>


<<function addconf(arm)>>

<<function writeconf(arm)>>

<<function plan9iniinit(arm)>>

<<function ataginit(arm)>>

<<function optionsinit(arm)>>

<<function bootargs(arm)>>
@


\subsection*{[[init/arm/watchdog.c]]}


<<enum _anon_ (init/arm/watchdog.c)(arm)>>=
enum {
    Wdogfreq    = 65536,
    Wdogtime    = 5,    /* seconds, ≤ 15 */
};
@

<<enum _anon_ (init/arm/watchdog.c)2(arm)>>=
/*
 * Power management / watchdog registers
 */
enum {
    Rstc        = 0x1c>>2,
        Password    = 0x5A<<24,
        CfgMask     = 0x03<<4,
        CfgReset    = 0x02<<4,
    Rsts        = 0x20>>2,
    Wdog        = 0x24>>2,
};
@

<<function archreset(arm)>>=
void
archreset(void)
{
    fpon();
}
@

<<function archreboot(arm)>>=
void
archreboot(void)
{
    u32int *r;

    r = (u32int*)POWERREGS;
    r[Wdog] = Password | 1;
    r[Rstc] = Password | (r[Rstc] & ~CfgMask) | CfgReset;
    arch_coherence();
    for(;;)
        ;
}
@

<<function wdogfeed(arm)>>=
static void
wdogfeed(void)
{
    u32int *r;

    r = (u32int*)POWERREGS;
    r[Wdog] = Password | (Wdogtime * Wdogfreq);
    r[Rstc] = Password | (r[Rstc] & ~CfgMask) | CfgReset;
}
@

<<function wdogoff(arm)>>=
void
wdogoff(void)
{
    u32int *r;

    r = (u32int*)POWERREGS;
    r[Rstc] = Password | (r[Rstc] & ~CfgMask);
}
@

<<function watchdoglink(arm)>>=
void
watchdoglink(void)
{
    addclock0link(wdogfeed, Arch_HZ);
}
@


%-------------------------------------------------------------

<<init/arm/watchdog.c>>=
<<kernel basic includes>>

<<constant POWERREGS(arm)>>

<<enum _anon_ (init/arm/watchdog.c)(arm)>>

<<enum _anon_ (init/arm/watchdog.c)2(arm)>>

<<function archreset(arm)>>

<<function archreboot(arm)>>

<<function wdogfeed(arm)>>

<<function wdogoff(arm)>>

<<function watchdoglink(arm)>>
@

\subsection*{[[init/user/preboot/arm/init9.s]]}

<<init/user/preboot/arm/init9.s>>=
/*
 * This is the same as the C program:
 *
 *  void
 *  main(char* argv0)
 *  {
 *      startboot(argv0, &argv0);
 *  }
 *
 * It is in assembler because SB needs to be
 * set and doing this in C drags in too many
 * other routines.
 */
TEXT main(SB), 1, $8
    MOVW    $setR12(SB), R12        /* load the SB */
    MOVW    $boot(SB), R0

    ADD $12, R13, R1            /* pointer to 0(FP) */

    MOVW    R0, 4(R13)          /* pass argc, argv */
    MOVW    R1, 8(R13)

    BL  startboot(SB)
_loop:
    B   _loop
@

\subsection*{[[init/arm/rebootcode.s]]}

<<init/arm/rebootcode.s>>=
/*
 * armv6/armv7 reboot code
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

#define PTEDRAM     (Dom0|L1AP(Krw)|Section)

#define WFI WORD    $0xe320f003 /* wait for interrupt */
#define WFE WORD    $0xe320f002 /* wait for event */

/*
 * Turn off MMU, then copy the new kernel to its correct location
 * in physical memory.  Then jump to the start of the kernel.
 */

/* main(PADDR(entry), PADDR(code), size); */
TEXT    main(SB), 1, $-4
    MOVW    $setR12(SB), R12

    /* copy in arguments before stack gets unmapped */
    MOVW    R0, R8          /* entry point */
    MOVW    p2+4(FP), R9        /* source */
    MOVW    n+8(FP), R6     /* byte count */

    /* SVC mode, interrupts disabled */
    MOVW    $(PsrDirq|PsrDfiq|PsrMsvc), R1
    MOVW    R1, CPSR

    /* prepare to turn off mmu  */
    BL  cachesoff(SB)

    /* turn off mmu */
    MRC CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    BIC $CpCmmu, R1
    MCR CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl

    /* continue with reboot only on cpu0 */
    CPUID(R2)
    BEQ bootcpu

    /* other cpus wait for inter processor interrupt from cpu0 */
    /* turn icache back on */
    MRC CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    ORR $(CpCicache), R1
    MCR CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    BARRIERS
dowfi:
    WFI
    MOVW    $0x40000060, R1
    ADD     R2<<2, R1
    MOVW    0(R1), R0
    AND     $0x10, R0
    BEQ     dowfi
    MOVW    $0x8000, R1
    BL      (R1)
    B       dowfi

bootcpu:
    /* set up a tiny stack for local vars and memmove args */
    MOVW    R8, SP          /* stack top just before kernel dest */
    SUB $20, SP         /* allocate stack frame */

    /* copy the kernel to final destination */
    MOVW    R8, 16(SP)      /* save dest (entry point) */
    MOVW    R8, R0          /* first arg is dest */
    MOVW    R9, 8(SP)       /* push src */
    MOVW    R6, 12(SP)      /* push size */
    BL  memmove(SB)
    MOVW    16(SP), R8      /* restore entry point */

    /* jump to kernel physical entry point */
    ORR R8,R8
    B   (R8)
    B   0(PC)

/*
 * turn the caches off, double map PHYSDRAM & KZERO, invalidate TLBs, revert
 * to tiny addresses.  upon return, it will be safe to turn off the mmu.
 * clobbers R0-R2, and returns with SP invalid.
 */
TEXT cachesoff(SB), 1, $-4
    MOVM.DB.W [R14,R1-R10], (R13)       /* save regs on stack */

    /* turn caches off, invalidate icache */
    MRC CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    BIC $(CpCdcache|CpCicache|CpCpredict), R1
    MCR CpSC, 0, R1, C(CpCONTROL), C(0), CpMainctl
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvi), CpCACHEall

    /* invalidate stale TLBs before changing them */
    BARRIERS
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpTLB), C(CpTLBinvu), CpTLBinv
    BARRIERS

    /* redo double map of first MiB PHYSDRAM = KZERO */
    MOVW    12(R(CPU)), R2      /* m->mmul1 (virtual addr) */
    MOVW    $PTEDRAM, R1            /* PTE bits */
    MOVW    R1, (R2)

    /* invalidate stale TLBs again */
    BARRIERS
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpTLB), C(CpTLBinvu), CpTLBinv
    BARRIERS

    /* relocate SB and return address to PHYSDRAM addressing */
    MOVW    $KSEGM, R1      /* clear segment bits */
    BIC R1, R12         /* adjust SB */
    MOVM.IA.W (R13), [R14,R1-R10]       /* restore regs from stack */

    MOVW    $KSEGM, R1      /* clear segment bits */
    BIC R1, R14         /* adjust return address */

    RET
@
%$

\section{[[memory/arm/]]}

\subsection*{[[memory/arm/dat_memory.h]]}

<<constant NCOLOR(arm)>>=
/*
 *  MMU stuff in proc
 */
#define NCOLOR  1       /* 1 level cache, don't worry about VCE's */
@



%-------------------------------------------------------------

<<memory/arm/dat_memory.h>>=

<<constant NCOLOR(arm)>>

<<struct Arch_Proc(arm)>>

/*
 * Fake kmap.
 */
typedef void        Arch_KMap;
<<macro VA(arm)>>

@


\subsection*{[[memory/arm/mem.h]]}

<<constant KiB(arm)>>=
#define KiB     1024u           /* Kibi 0x0000000000000400 */
@
\t mv in portdat.h and rename KB MB GB

<<constant MiB(arm)>>=
#define MiB     1048576u        /* Mebi 0x0000000000100000 */
@

<<constant GiB(arm)>>=
#define GiB     1073741824u     /* Gibi 000000000040000000 */
@




<<constant L1SIZE(arm)>>=
#define L1SIZE      (4 * BY2PG)
@
%16K

<<constant KSTKSIZE(arm)>>=
#define KSTKSIZE    (8*KiB)
@

<<macro STACKALIGN(arm)>>=
#define STACKALIGN(sp)  ((sp) & ~3)     /* bug: assure with alloc */
@

<<constant UP(arm)>>=
/*
 * Magic registers
 */

#define UP      9       /* R9 is up-> */
@

<<constant CPU(arm)>>=
#define CPU     10      /* R10 is cpu-> */
@




<<constant CONFADDR(arm)>>=
#define CONFADDR    (KZERO+0x100)       /* unparsed plan9.ini */
@


<<constant L2(arm)>>=
#define L2          (KZERO+0x3000)      /* L2 ptes for vectors etc */
@

<<constant VCBUFFER(arm)>>=
#define VCBUFFER    (KZERO+0x3400)      /* videocore mailbox buffer */
@

<<constant FIQSTKTOP(arm)>>=
#define FIQSTKTOP   (KZERO+0x4000)      /* FIQ stack */
@

<<constant L1(arm)>>=
#define L1          (KZERO+0x4000)      /* ttb ptes: 16KiB aligned */
@






<<constant USTKTOP(arm)>>=
// that's it? only 512 MB for virtual space?
#define USTKTOP     0x20000000      /* user segment end +1 */
@

<<constant USTKSIZE(arm)>>=
#define USTKSIZE    (8*1024*1024)       /* user stack size */
@



<<constant REBOOTADDR(arm)>>=
/* address at which to copy and execute rebootcode */
#define REBOOTADDR  (KZERO+0x1800)
@

<<constant BLOCKALIGN(arm)>>=
// possible alternative fix: git show 2342e706e42d1e6653c51cc1433f44816cf53fe6
#define BLOCKALIGN  32          /* only used in allocb.c */
@

<<constant KSTACK(arm)>>=
#define KSTACK      KSTKSIZE
@





<<macro PPN(arm)>>=
#define PPN(x)      ((x)&~(BY2PG-1))
@



<<constant IOSIZE(arm)>>=
#define IOSIZE      (16*MiB)
@
%BUS  addresses as seen from the videocore gpu.

%-------------------------------------------------------------

<<memory/arm/mem.h>>=
/*
 * Memory and machine-specific definitions.  Used in C and assembler.
 */

<<constant KiB(arm)>>
<<constant MiB(arm)>>
<<constant GiB(arm)>>

/*
 * Sizes
 */
<<constant BY2PG(arm)>>
<<constant PGSHIFT(arm)>>

<<constant MAXCPUS(arm)>>
<<constant CPUSIZE(arm)>>
<<constant L1SIZE(arm)>>

<<constant KSTKSIZE(arm)>>
<<macro STACKALIGN(arm)>>

<<constant UP(arm)>>
<<constant CPU(arm)>>

/*
 * Address spaces.
 * KTZERO is used by kprof and dumpstack (if any).
 *
 * KZERO is mapped to physical 0 (start of ram).
 *
 * vectors are at 0, plan9.ini is at KZERO+256 and is limited to 16K by
 * devenv.
 */
<<constant KSEG0(arm)>>
<<constant KSEGM(arm)>>

<<constant KZERO(arm)>>

<<constant CONFADDR(arm)>>

// L1 must be 16KiB aligned so this dictates the organization below
<<constant CPUADDR(arm)>>
<<constant L2(arm)>>
<<constant VCBUFFER(arm)>>
<<constant FIQSTKTOP(arm)>>
<<constant L1(arm)>>

<<constant KTZERO(arm)>>

<<constant VIRTIO(arm)>>
<<constant FRAMEBUFFER(arm)>>

<<constant UZERO(arm)>>
<<constant UTZERO(arm)>>
<<macro UTROUND(arm)>>
<<constant USTKTOP(arm)>>
<<constant USTKSIZE(arm)>>
<<constant TSTKTOP(arm)>>
<<constant TSTKSIZ(arm)>>

<<constant REBOOTADDR(arm)>>

/*
 * Legacy...
 */
//old: was 64 in bcm-latest, but then get panic in _allocb
<<constant BLOCKALIGN(arm)>>
<<constant KSTACK(arm)>>

/*
 * Sizes
 */
<<constant BI2BY(arm)>>
<<constant BY2WD(arm)>>
<<constant BY2V(arm)>>

<<constant PAGETABMAPMEM(arm)>>
<<constant PAGETABSIZE(arm)>>
<<constant PAGEDIRSIZE(arm)>>
<<constant SMALLPAGEDIRSIZE(arm)>>
<<macro PPN(arm)>>

/*
 * With a little work these move to port.
 */
<<type PTExxx(arm)>>

/*
 * Physical machine information from here on.
 *  PHYS addresses as seen from the arm cpu.
 *  BUS  addresses as seen from the videocore gpu.
 */
<<constant PHYSDRAM(arm)>>
<<constant IOSIZE(arm)>>
@


\subsection*{[[memory/arm/mmu.c]]}

<<macro L1X(arm)>>=
#define L1X(va)     FEXT((va), 20, 12)
@

<<macro L2X(arm)>>=
#define L2X(va)     FEXT((va), 12, 8)
@

<<macro L2AP(arm)>>=
#define L2AP(ap)    l2ap(ap)
@

<<[[Soc]] mmu fields>>=
u32int  l1ptedramattrs;
u32int  l2ptedramattrs;
@

<<[[soc(raspberry pi1)]] other fields(arm)>>=
.l1ptedramattrs = Cached | Buffered,
.l2ptedramattrs = Cached | Buffered,
@

<<constant L1ptedramattrs(arm)>>=
#define L1ptedramattrs  soc.l1ptedramattrs
@

<<constant L2ptedramattrs(arm)>>=
#define L2ptedramattrs  soc.l2ptedramattrs
@

<<enum _anon_ (memory/arm/mmu.c)(arm)>>=
enum {
    L1lo        = UZERO/MiB,        /* L1X(UZERO)? */
    L1hi        = (USTKTOP+MiB-1)/MiB,  /* L1X(USTKTOP+MiB-1)? */
};
@

<<function mmuinit(arm)>>=
/*
 * Set up initial PTEs for this cpu (called with mmu off)
 */
void
mmuinit(void *a)
{
    PTE *l1, *l2;
    uintptr pa, va;

    l1 = (PTE*)a; // PADDR(L1) for cpu0

    /*
     * map all of ram at KZERO
     */
    va = KZERO;
    for(pa = 0; pa < soc.dramsize; pa += MiB, va += MiB)
    {
        l1[L1X(va)] = pa|Dom0|L1AP(Krw)|Section|L1ptedramattrs;
    }

    /*
     * identity map first MB of ram so mmu can be enabled
     */
    // ???
    l1[L1X(0)] = 0|Dom0|L1AP(Krw)|Section|L1ptedramattrs;

    /*
     * map i/o registers 
     */
    va = VIRTIO;
    for(pa = soc.physio; pa < soc.physio + IOSIZE; pa += MiB, va += MiB){
        // No L1ptedramattrs (Cached | Buffered) here, because volatile!
        l1[L1X(va)] = pa|Dom0|L1AP(Krw)|Section; 
    }
    // for raspi2
    pa = soc.armlocal;
    if(pa)
        l1[L1X(va)] = pa|Dom0|L1AP(Krw)|Section;
    
    /*
     * double map exception vectors at top of virtual memory
     */
    // ???
    l2 = (PTE*)PADDR(L2);
    va = HVECTORS;
    l1[L1X(va)] = (uintptr)l2|Dom0|Coarse;
    l2[L2X(va)] = L2AP(Krw)|Small|L2ptedramattrs;
}
@

<<function mmuinit1(arm)>>=
void
mmuinit1(void *a)
{
    PTE *l1;

    l1 = (PTE*)a;
    cpu->mmul1 = l1;

    /*
     * undo identity map of first MB of ram
     */
    l1[L1X(0)] = 0;
    cachedwbse(&l1[L1X(0)], sizeof(PTE));

    mmuinvalidateaddr(0);
}
@
%    //cacheuwbinv();
%    //l2cacheuwbinv();

<<function mmul2empty(arm)>>=
static void
mmul2empty(Proc* proc, int clear)
{
    PTE *l1;
    Page **l2, *page;

    l1 = cpu->mmul1;
    l2 = &proc->mmul2;
    for(page = *l2; page != nil; page = page->next){
        if(clear)
            memset(UINT2PTR(page->va), 0, BY2PG);
        l1[page->daddr] = Fault;
        l2 = &page->next;
    }
    *l2 = proc->mmul2cache;
    proc->mmul2cache = proc->mmul2;
    proc->mmul2 = nil;
}
@

<<function mmul1empty(arm)>>=
static void
mmul1empty(void)
{
    memset(&cpu->mmul1[L1lo], 0, (L1hi - L1lo)*sizeof(PTE));
}
@
%#ifdef notdef
%/* there's a bug in here */
%    PTE *l1;
%
%    /* clean out any user mappings still in l1 */
%    if(cpu->mmul1lo > L1lo){
%        if(cpu->mmul1lo == 1)
%            cpu->mmul1[L1lo] = Fault;
%        else
%            memset(&cpu->mmul1[L1lo], 0, cpu->mmul1lo*sizeof(PTE));
%        cpu->mmul1lo = L1lo;
%    }
%    if(cpu->mmul1hi < L1hi){
%        l1 = &cpu->mmul1[cpu->mmul1hi];
%        if((L1hi - cpu->mmul1hi) == 1)
%            *l1 = Fault;
%        else
%            memset(l1, 0, (L1hi - cpu->mmul1hi)*sizeof(PTE));
%        cpu->mmul1hi = L1hi;
%    }
%#else
%    memset(&cpu->mmul1[L1lo], 0, (L1hi - L1lo)*sizeof(PTE));
%#endif /* notdef */

<<function arch_mmuswitch(arm)>>=
void
arch_mmuswitch(Proc* proc)
{
    int x;
    PTE *l1;
    Page *page;

    /* do kprocs get here and if so, do they need to? */
/*** "This is plausible, but wrong" - Charles Forsyth 1 Mar 2015
    if(cpu->mmupid == proc->pid && !proc->newtlb)
        return;
***/
    cpu->mmupid = proc->pid;

    /* write back dirty and invalidate l1 caches */
    cacheuwbinv();

    if(proc->newtlb){
        mmul2empty(proc, 1);
        proc->newtlb = 0;
    }

    mmul1empty();

    /* move in new map */
    l1 = cpu->mmul1;
    for(page = proc->mmul2; page != nil; page = page->next){
        x = page->daddr;
        l1[x] = PPN(page->pa)|Dom0|Coarse;
        /* know here that L1lo < x < L1hi */
        if(x+1 - cpu->mmul1lo < cpu->mmul1hi - x)
            cpu->mmul1lo = x+1;
        else
            cpu->mmul1hi = x;
    }

    /* make sure map is in memory */
    /* could be smarter about how much? */
    cachedwbse(&l1[L1X(UZERO)], (L1hi - L1lo)*sizeof(PTE));

    /* lose any possible stale tlb entries */
    mmuinvalidate();
}
@



<<function mmuuncache(arm)>>=
void*
mmuuncache(void* v, usize size)
{
    int x;
    PTE *pte;
    uintptr va;

    /*
     * Simple helper for ucalloc().
     * Uncache a Section, must already be
     * valid in the MMU.
     */
    va = PTR2UINT(v);
    assert(!(va & (1*MiB-1)) && size == 1*MiB);

    x = L1X(va);
    pte = &cpu->mmul1[x];
    if((*pte & (Fine|Section|Coarse)) != Section)
        return nil;
    *pte &= ~L1ptedramattrs;
    *pte |= L1sharable;
    mmuinvalidateaddr(va);
    cachedwbinvse(pte, 4);

    return v;
}
@


<<function mmukmap(arm)>>=
uintptr
mmukmap(uintptr va, uintptr pa, usize size)
{
    int o;
    usize n;
    PTE *pte, *pte0;

    assert((va & (MiB-1)) == 0);
    o = pa & (MiB-1);
    pa -= o;
    size += o;
    pte = pte0 = &cpu->mmul1[L1X(va)];
    for(n = 0; n < size; n += MiB)
        if(*pte++ != Fault)
            return 0;
    pte = pte0;
    for(n = 0; n < size; n += MiB){
        *pte++ = (pa+n)|Dom0|L1AP(Krw)|Section;
        mmuinvalidateaddr(va+n);
    }
    cachedwbse(pte0, (uintptr)pte - (uintptr)pte0);
    return va + o;
}
@




%-------------------------------------------------------------

<<memory/arm/mmu.c>>=
<<kernel basic includes>>

#include "arm.h"

<<macro L1X(arm)>>
<<macro L2X(arm)>>
<<macro L2AP(arm)>>

<<constant L1ptedramattrs(arm)>>
<<constant L2ptedramattrs(arm)>>

<<enum _anon_ (memory/arm/mmu.c)(arm)>>

<<function mmuinit(arm)>>

<<function mmuinit1(arm)>>

<<function mmul2empty(arm)>>

<<function mmul1empty(arm)>>

<<function arch_mmuswitch(arm)>>

<<function arch_flushmmu(arm)>>

<<function arch_mmurelease(arm)>>

<<function arch_putmmu(arm)>>

<<function mmuuncache(arm)>>

<<function arch_cankaddr(arm)>>

<<function mmukmap(arm)>>


<<function arch_checkmmu(arm)>>

<<function arch_kmap(arm)>>

<<function arch_kunmap(arm)>>
@


\subsection*{[[memory/arm/mmuinvalidate.s]]}

<<memory/arm/mmuinvalidate.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"
        
/*
 * invalidate tlb
 */
TEXT mmuinvalidate(SB), 1, $-4
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpTLB), C(CpTLBinvu), CpTLBinv
    BARRIERS
    RET

/*
 * mmuinvalidateaddr(va)
 *   invalidate tlb entry for virtual page address va, ASID 0
 */
TEXT mmuinvalidateaddr(SB), 1, $-4
    MCR CpSC, 0, R0, C(CpTLB), C(CpTLBinvu), CpTLBinvse
    BARRIERS
    RET
@
%$


\subsection*{[[memory/arm/cache_raspi1.s]]}

<<memory/arm/cache_raspi1.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

#define CACHELINESZ 32
                
/*
 * drain write buffer
 * writeback data cache
 */
TEXT cachedwb(SB), 1, $-4
    DSB
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEall
    RET

/*
 * drain write buffer
 * writeback and invalidate data cache
 */
TEXT cachedwbinv(SB), 1, $-4
    DSB
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwbi), CpCACHEall
    RET

/*
 * cachedwbinvse(va, n)
 *   drain write buffer
 *   writeback and invalidate data cache range [va, va+n)
 */
TEXT cachedwbinvse(SB), 1, $-4
    MOVW    R0, R1      /* DSB clears R0 */
    DSB
    MOVW    n+4(FP), R2
    ADD R1, R2
    SUB $1, R2
    BIC $(CACHELINESZ-1), R1
    BIC $(CACHELINESZ-1), R2
    MCRR(CpSC, 0, 2, 1, CpCACHERANGEdwbi)
    RET

/*
 * cachedwbse(va, n)
 *   drain write buffer
 *   writeback data cache range [va, va+n)
 */
TEXT cachedwbse(SB), 1, $-4
    MOVW    R0, R1      /* DSB clears R0 */
    DSB
    MOVW    n+4(FP), R2
    ADD R1, R2
    BIC $(CACHELINESZ-1), R1
    BIC $(CACHELINESZ-1), R2
    MCRR(CpSC, 0, 2, 1, CpCACHERANGEdwb)
    RET

/*
 * cachedinvse(va, n)
 *   drain write buffer
 *   invalidate data cache range [va, va+n)
 */
TEXT cachedinvse(SB), 1, $-4
    MOVW    R0, R1      /* DSB clears R0 */
    DSB
    MOVW    n+4(FP), R2
    ADD R1, R2
    SUB $1, R2
    BIC $(CACHELINESZ-1), R1
    BIC $(CACHELINESZ-1), R2
    MCRR(CpSC, 0, 2, 1, CpCACHERANGEinvd)
    RET

/*
 * drain write buffer and prefetch buffer
 * writeback and invalidate data cache
 * invalidate instruction cache
 */
TEXT cacheuwbinv(SB), 1, $-4
    BARRIERS
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwbi), CpCACHEall
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvi), CpCACHEall
    RET

/*
 * L2 cache is not enabled
 */
TEXT l2cacheuwbinv(SB), 1, $-4
    RET

/*
 * invalidate instruction cache
 */
TEXT cacheiinv(SB), 1, $-4
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvi), CpCACHEall
    RET
@


\subsection*{[[memory/arm/cache_raspi2.s]]}

<<memory/arm/cache_raspi2.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

#define CACHELINESZ 64
        
        
/*
 * `single-element' cache operations.
 * in arm arch v7, they operate on all cache levels, so separate
 * l2 functions are unnecessary.
 */

TEXT cachedwbse(SB), $-4            /* D writeback SE */
    MOVW    R0, R2

    MOVW    CPSR, R3
    CPSID                   /* splhi */

    BARRIERS            /* force outstanding stores to cache */
    MOVW    R2, R0
    MOVW    4(FP), R1
    ADD R0, R1              /* R1 is end address */
    BIC $(CACHELINESZ-1), R0        /* cache line start */
_dwbse:
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEse
    /* can't have a BARRIER here since it zeroes R0 */
    ADD $CACHELINESZ, R0
    CMP.S   R0, R1
    BGT _dwbse
    B   _wait

TEXT cachedwbinvse(SB), $-4         /* D writeback+invalidate SE */
    MOVW    R0, R2

    MOVW    CPSR, R3
    CPSID                   /* splhi */

    BARRIERS            /* force outstanding stores to cache */
    MOVW    R2, R0
    MOVW    4(FP), R1
    ADD R0, R1              /* R1 is end address */
    BIC $(CACHELINESZ-1), R0        /* cache line start */
_dwbinvse:
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwbi), CpCACHEse
    /* can't have a BARRIER here since it zeroes R0 */
    ADD $CACHELINESZ, R0
    CMP.S   R0, R1
    BGT _dwbinvse
_wait:                      /* drain write buffer */
    BARRIERS

    MOVW    R3, CPSR            /* splx */
    RET

TEXT cachedinvse(SB), $-4           /* D invalidate SE */
    MOVW    R0, R2

    MOVW    CPSR, R3
    CPSID                   /* splhi */

    BARRIERS            /* force outstanding stores to cache */
    MOVW    R2, R0
    MOVW    4(FP), R1
    ADD R0, R1              /* R1 is end address */
    BIC $(CACHELINESZ-1), R0        /* cache line start */
_dinvse:
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvd), CpCACHEse
    /* can't have a BARRIER here since it zeroes R0 */
    ADD $CACHELINESZ, R0
    CMP.S   R0, R1
    BGT _dinvse
    B   _wait

/*
 * cortex arm arch v7 cache flushing and invalidation
 * shared by l.s and rebootcode.s
 */

TEXT cacheiinv(SB), $-4             /* I invalidate */
    MOVW    $0, R0
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvi), CpCACHEall /* ok on cortex */
    ISB
    RET

/*
 * set/way operators, passed a suitable set/way value in R0.
 */
TEXT cachedwb_sw(SB), $-4
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEsi
    RET

TEXT cachedwbinv_sw(SB), $-4
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwbi), CpCACHEsi
    RET

TEXT cachedinv_sw(SB), $-4
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEinvd), CpCACHEsi
    RET

    /* set cache size select */
TEXT setcachelvl(SB), $-4
    MCR CpSC, CpIDcssel, R0, C(CpID), C(CpIDidct), 0
    ISB
    RET

    /* return cache sizes */
TEXT getwayssets(SB), $-4
    MRC CpSC, CpIDcsize, R0, C(CpID), C(CpIDidct), 0
    RET

/*
 * l1 cache operations.
 * l1 and l2 ops are intended to be called from C, thus need save no
 * caller's regs, only those we need to preserve across calls.
 */

TEXT cachedwb(SB), $-4
    MOVW.W  R14, -8(R13)
    MOVW    $cachedwb_sw(SB), R0
    MOVW    $1, R8
    BL  wholecache(SB)
    MOVW.P  8(R13), R15

TEXT cachedwbinv(SB), $-4
    MOVW.W  R14, -8(R13)
    MOVW    $cachedwbinv_sw(SB), R0
    MOVW    $1, R8
    BL  wholecache(SB)
    MOVW.P  8(R13), R15

TEXT cachedinv(SB), $-4
    MOVW.W  R14, -8(R13)
    MOVW    $cachedinv_sw(SB), R0
    MOVW    $1, R8
    BL  wholecache(SB)
    MOVW.P  8(R13), R15

TEXT cacheuwbinv(SB), $-4
    MOVM.DB.W [R14], (R13)  /* save lr on stack */
    MOVW    CPSR, R1
    CPSID           /* splhi */

    MOVM.DB.W [R1], (R13)   /* save R1 on stack */

    BL  cachedwbinv(SB)
    BL  cacheiinv(SB)

    MOVM.IA.W (R13), [R1]   /* restore R1 (saved CPSR) */
    MOVW    R1, CPSR
    MOVM.IA.W (R13), [R14]  /* restore lr */
    RET

/*
 * l2 cache operations
 */

TEXT l2cacheuwb(SB), $-4
    MOVW.W  R14, -8(R13)
    MOVW    $cachedwb_sw(SB), R0
    MOVW    $2, R8
    BL  wholecache(SB)
    MOVW.P  8(R13), R15

TEXT l2cacheuwbinv(SB), $-4
    MOVW.W  R14, -8(R13)
    MOVW    CPSR, R1
    CPSID           /* splhi */

    MOVM.DB.W [R1], (R13)   /* save R1 on stack */

    MOVW    $cachedwbinv_sw(SB), R0
    MOVW    $2, R8
    BL  wholecache(SB)
    BL  l2cacheuinv(SB)

    MOVM.IA.W (R13), [R1]   /* restore R1 (saved CPSR) */
    MOVW    R1, CPSR
    MOVW.P  8(R13), R15

TEXT l2cacheuinv(SB), $-4
    MOVW.W  R14, -8(R13)
    MOVW    $cachedinv_sw(SB), R0
    MOVW    $2, R8
    BL  wholecache(SB)
    MOVW.P  8(R13), R15

/*
 * these shift values are for the Cortex-A8 L1 cache (A=2, L=6) and
 * the Cortex-A8 L2 cache (A=3, L=6).
 * A = log2(# of ways), L = log2(bytes per cache line).
 * see armv7 arch ref p. 1403.
 */
#define L1WAYSH 30
#define L1SETSH 6
#define L2WAYSH 29
#define L2SETSH 6

/*
 * callers are assumed to be the above l1 and l2 ops.
 * R0 is the function to call in the innermost loop.
 * R8 is the cache level (one-origin: 1 or 2).
 *
 * initial translation by 5c, then massaged by hand.
 */
TEXT wholecache+0(SB), $-4
    MOVW    R0, R1      /* save argument for inner loop in R1 */
    SUB $1, R8      /* convert cache level to zero origin */

    /* we may not have the MMU on yet, so map R1 to PC's space */
    BIC $KSEGM, R1  /* strip segment from address */
    MOVW    PC, R2      /* get PC's segment ... */
    AND $KSEGM, R2
    ORR R2, R1      /* combine them */

    /* drain write buffers */
    BARRIERS
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEwait
    ISB

    MOVW    CPSR, R2
    MOVM.DB.W [R2,R14], (SP) /* save regs on stack */
    CPSID           /* splhi to make entire op atomic */

    /* get cache sizes */
    SLL $1, R8, R0  /* R0 = (cache - 1) << 1 */
    MCR CpSC, CpIDcssel, R0, C(CpID), C(CpIDidct), 0 /* set cache size select */
    ISB
    MRC CpSC, CpIDcsize, R0, C(CpID), C(CpIDidct), 0 /* get cache sizes */

    /* compute # of ways and sets for this cache level */
    SRA $3, R0, R5  /* R5 (ways) = R0 >> 3 */
    AND $1023, R5   /* R5 = (R0 >> 3) & MASK(10) */
    ADD $1, R5      /* R5 (ways) = ((R0 >> 3) & MASK(10)) + 1 */

    SRA $13, R0, R2 /* R2 = R0 >> 13 */
    AND $32767, R2  /* R2 = (R0 >> 13) & MASK(15) */
    ADD $1, R2      /* R2 (sets) = ((R0 >> 13) & MASK(15)) + 1 */

    /* precompute set/way shifts for inner loop */
    CMP $0, R8      /* cache == 1? */
    MOVW.EQ $L1WAYSH, R3    /* yes */
    MOVW.EQ $L1SETSH, R4
    MOVW.NE $L2WAYSH, R3    /* no */
    MOVW.NE $L2SETSH, R4

    /* iterate over ways */
    MOVW    $0, R7      /* R7: way */
outer:
    /* iterate over sets */
    MOVW    $0, R6      /* R6: set */
inner:
    /* compute set/way register contents */
    SLL R3, R7, R0  /* R0 = way << R3 (L?WAYSH) */
    ORR R8<<1, R0   /* R0 = way << L?WAYSH | (cache - 1) << 1 */
    ORR R6<<R4, R0  /* R0 = way<<L?WAYSH | (cache-1)<<1 |set<<R4 */

    BL  (R1)        /* call set/way operation with R0 */

    ADD $1, R6      /* set++ */
    CMP R2, R6      /* set >= sets? */
    BLT inner       /* no, do next set */

    ADD $1, R7      /* way++ */
    CMP R5, R7      /* way >= ways? */
    BLT outer       /* no, do next way */

    MOVM.IA.W (SP), [R2,R14] /* restore regs */
    MOVW    R2, CPSR    /* splx */

    /* drain write buffers */
    MCR CpSC, 0, R0, C(CpCACHE), C(CpCACHEwb), CpCACHEwait
    ISB
    RET
@
%$

\section{[[interrupts/arm/]]}

\subsection*{[[interrupts/arm/trap.c]]}



<<enum _anon_ (interrupts/arm/trap.c)(arm)>>=
enum {
    Debug = 0,

    Nvec = 8,       /* # of vectors at start of lexception.s */
    Fiqenable = 1<<7,

    Localtimerint   = 0x40,
    Localmboxint    = 0x50,
    Localintpending = 0x60,
};
@
% >> >>

<<struct Vpage0(arm)>>=
/*
 *   Layout at virtual address KZERO (double mapped at HVECTORS).
 */
struct Vpage0 {
    void    (*vectors[Nvec])(void);
    u32int  vtable[Nvec];
};
@





<<global vfiq(arm)>>=
static Vctl *vfiq;
@


<<function arch_trapinit(arm)>>=
/*
 *  set up for exceptions
 */
void
arch_trapinit(void)
{
    Vpage0 *vpage0;

    if (cpu->cpuno == 0) {
        /* disable everything */
        intrsoff();
        /* set up the exception vectors */
        vpage0 = (Vpage0*)HVECTORS;
        memmove(vpage0->vectors, vectors, sizeof(vpage0->vectors));
        memmove(vpage0->vtable, vtable, sizeof(vpage0->vtable));
        cacheuwbinv();
        l2cacheuwbinv();
    }

    /* set up the stacks for the interrupt modes */
    setr13(PsrMfiq, (u32int*)(FIQSTKTOP));
    setr13(PsrMirq, cpu->sirq);
    setr13(PsrMabt, cpu->sabt);
    setr13(PsrMund, cpu->sund);

    arch_coherence();
}
@
%dead:    setr13(PsrMsys, cpu->ssys);

<<function intrcpushutdown(arm)>>=
void
intrcpushutdown(void)
{
    u32int *enable;

    if(soc.armlocal == 0)
        return;
    enable = (u32int*)(LOCALREGS + Localtimerint) + cpu->cpuno;
    *enable = 0;
    if(cpu->cpuno){
        enable = (u32int*)(LOCALREGS + Localmboxint) + cpu->cpuno;
        *enable = 1;
    }
}
@

<<function intrsoff(arm)>>=
void
intrsoff(void)
{
    Intregs *ip;
    int disable;

    ip = (Intregs*)INTREGS;
    disable = ~0;
    ip->GPUdisable[0] = disable;
    ip->GPUdisable[1] = disable;
    ip->ARMdisable = disable;
    ip->FIQctl = 0;
}
@

<<function intrshutdown(arm)>>=
/* called from cpu0 after other cpus are shutdown */
void
intrshutdown(void)
{
    intrsoff();
    intrcpushutdown();
}
@

<<function intrtime(arm)>>=
static void
intrtime(void)
{
    ulong diff;
    ulong x;

    x = arch_perfticks();
    diff = x - cpu->perf.intrts;
    cpu->perf.intrts = x;

    cpu->perf.inintr += diff;
    if(up == nil && cpu->perf.inidle > diff)
        cpu->perf.inidle -= diff;
}
@




<<function trapname(arm)>>=
static char *
trapname(int psr)
{
    char *s;

    s = trapnames[psr & PsrMask];
    if(s == nil)
        s = "unknown trap number in psr";
    return s;
}
@

<<function ckfaultstuck(arm)>>=
/* this is quite helpful during mmu and cache debugging */
static void
ckfaultstuck(uintptr va)
{
    static int cnt, lastpid;
    static uintptr lastva;

    if (va == lastva && up->pid == lastpid) {
        ++cnt;
        if (cnt >= 2)
            /* fault() isn't fixing the underlying cause */
            panic("fault: %d consecutive faults for va %#p",
                cnt+1, va);
    } else {
        cnt = 0;
        lastva = va;
        lastpid = up->pid;
    }
}
@




<<function isvalidaddr(arm)>>=
int
isvalidaddr(void *v)
{
    return (uintptr)v >= KZERO;
}
@

<<function dumplongs(arm)>>=
static void
dumplongs(char *msg, ulong *v, int n)
{
    int i, l;

    l = 0;
    iprint("%s at %.8p: ", msg, v);
    for(i=0; i<n; i++){
        if(l >= 4){
            iprint("\n    %.8p: ", v);
            l = 0;
        }
        if(isvalidaddr(v)){
            iprint(" %.8lux", *v++);
            l++;
        }else{
            iprint(" invalid");
            break;
        }
    }
    iprint("\n");
}
@

<<function dumpstackwithureg(arm)>>=
static void
dumpstackwithureg(Ureg *ureg)
{
    uintptr l, i, v, estack;
    u32int *p;
    char *s;

    if((s = getconf("*nodumpstack")) != nil && strcmp(s, "0") != 0){
        iprint("dumpstack disabled\n");
        return;
    }
    iprint("ktrace /kernel/path %#.8lux %#.8lux %#.8lux # pc, sp, link\n",
        ureg->pc, ureg->sp, ureg->r14);
    arch_delay(2000);
    i = 0;
    if(up != nil && (uintptr)&l <= (uintptr)up->kstack+KSTACK)
        estack = (uintptr)up->kstack+KSTACK;
    else if((uintptr)&l >= (uintptr)cpu->stack
         && (uintptr)&l <= (uintptr)cpu + CPUSIZE)
        estack = (uintptr)cpu + CPUSIZE;
    else{
        if(up != nil)
            iprint("&up->kstack %#p &l %#p\n", up->kstack, &l);
        else
            iprint("&m %#p &l %#p\n", cpu, &l);
        return;
    }
    for(l = (uintptr)&l; l < estack; l += sizeof(uintptr)){
        v = *(uintptr*)l;
        if(KTZERO < v && v < (uintptr)etext && !(v & 3)){
            v -= sizeof(u32int);        /* back up an instr */
            p = (u32int*)v;
            if((*p & 0x0f000000) == 0x0b000000){    /* BL instr? */
                iprint("%#8.8lux=%#8.8lux ", l, v);
                i++;
            }
        }
        if(i == 4){
            i = 0;
            iprint("\n");
        }
    }
    if(i)
        iprint("\n");
}
@

<<function getpcsp(arm)>>=
/*
 * Fill in enough of Ureg to get a stack trace, and call a function.
 * Used by debugging interface rdb.
 */

static void
getpcsp(ulong *pc, ulong *sp)
{
    *pc = getcallerpc(&pc);
    *sp = (ulong)&pc-4;
}
@

<<function arch_callwithureg(arm)>>=
void
arch_callwithureg(void (*fn)(Ureg*))
{
    Ureg ureg;

    getpcsp((ulong*)&ureg.pc, (ulong*)&ureg.sp);
    ureg.r14 = getcallerpc(&fn);
    fn(&ureg);
}
@

<<function trap_arch_dumpstack(arm)>>=
void
trap_arch_dumpstack(void)
{
    arch_callwithureg(dumpstackwithureg);
}
@

<<function dumpregs(arm)>>=
void
dumpregs(Ureg* ureg)
{
    int s;

    if (ureg == nil) {
        iprint("trap: no user process\n");
        return;
    }
    s = arch_splhi();
    iprint("trap: %s", trapname(ureg->type));
    if(ureg != nil && (ureg->psr & PsrMask) != PsrMsvc)
        iprint(" in %s", trapname(ureg->psr));
    iprint("\n");
    iprint("psr %8.8lux type %2.2lux pc %8.8lux link %8.8lux\n",
        ureg->psr, ureg->type, ureg->pc, ureg->link);
    iprint("R14 %8.8lux R13 %8.8lux R12 %8.8lux R11 %8.8lux R10 %8.8lux\n",
        ureg->r14, ureg->r13, ureg->r12, ureg->r11, ureg->r10);
    iprint("R9  %8.8lux R8  %8.8lux R7  %8.8lux R6  %8.8lux R5  %8.8lux\n",
        ureg->r9, ureg->r8, ureg->r7, ureg->r6, ureg->r5);
    iprint("R4  %8.8lux R3  %8.8lux R2  %8.8lux R1  %8.8lux R0  %8.8lux\n",
        ureg->r4, ureg->r3, ureg->r2, ureg->r1, ureg->r0);
    iprint("stack is at %#p\n", ureg);
    iprint("pc %#lux link %#lux\n", ureg->pc, ureg->link);

    if(up)
        iprint("user stack: %#p-%#p\n", up->kstack, up->kstack+KSTACK-4);
    else
        iprint("kernel stack: %8.8lux-%8.8lux\n",
            (ulong)(cpu+1), (ulong)cpu+BY2PG-4);
    dumplongs("stack", (ulong *)(ureg + 1), 16);
    arch_delay(2000);
    arch_dumpstack();
    arch_splx(s);
}
@


%-------------------------------------------------------------

<<interrupts/arm/trap.c>>=
/*
 * traps, exceptions, interrupts, system calls.
 */
<<kernel basic includes>>

#include "io.h"
#include "ureg.h"

#include "arm.h"

<<constant INTREGS(arm)>>
<<constant LOCALREGS(arm)>>

typedef struct Intregs Intregs;
typedef struct Vctl Vctl;
typedef struct Vpage0 Vpage0;

<<enum _anon_ (interrupts/arm/trap.c)(arm)>>

<<struct Vpage0(arm)>>

<<struct Intregs(arm)>>

<<struct Vctl(arm)>>

<<global vctllock(arm)>>

<<global vctl(arm)>>

<<global vfiq(arm)>>

<<global trapnames(arm)>>

extern int notify(Ureg*);

<<function arch_trapinit(arm)>>

<<function intrcpushutdown(arm)>>

<<function intrsoff(arm)>>

<<function intrshutdown(arm)>>

<<function intrtime(arm)>>


<<function irq(arm)>>

<<function fiq(arm)>>

<<function irqenable(arm)>>

<<function trapname(arm)>>

<<function ckfaultstuck(arm)>>

<<function faultarm(arm)>>

<<function writetomem(arm)>>

<<function trap(arm)>>

<<function isvalidaddr(arm)>>

<<function dumplongs(arm)>>

<<function dumpstackwithureg(arm)>>

<<function getpcsp(arm)>>

<<function arch_callwithureg(arm)>>

<<function trap_arch_dumpstack(arm)>>

<<function dumpregs(arm)>>
@

\subsection*{[[interrupts/arm/fault_helpers.s]]}

<<interrupts/arm/fault_helpers.s>>=
#include "mem.h"
#include "arm.h"

<< function fstget(arm)>>

<< function ifsrget(arm)>>

<< function farget(arm)>>

@
%$

\subsection*{[[interrupts/arm/lexception.s]]}

<<interrupts/arm/lexception.s>>=
/*
 * arm exception handlers
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<global vectors(arm)>>        

<<global vtable(arm)>>        

<<function _vsvc(arm)>>        

<<function _vund(arm)>>        

<<function _vpabt(arm)>>        

<<function _vdabt(arm)>>        

<<function _virq(arm)>>        

<<label _vswitch(arm)>>

<<function _vfiq(arm)>>        

<<function setr13(arm)>>        
@

<<function setr13(arm)>>=
/*
 *  set the stack value for the mode passed in R0
 */
TEXT setr13(SB), 1, $-4
    MOVW    4(FP), R1

    MOVW    CPSR, R2
    BIC $PsrMask, R2, R3
    ORR $(PsrDirq|PsrDfiq), R3
    ORR R0, R3
    MOVW    R3, CPSR        /* switch to new mode */

    MOVW    R13, R0         /* return old sp */
    MOVW    R1, R13         /* install new one */

    MOVW    R2, CPSR        /* switch back to old mode */
    RET
@
%$

\section{[[time/arm/]]}

\subsection*{[[time/arm/dat_time.h]]}

<<constant Arch_HZ(arm)>>=
#define Arch_HZ     100         /* clock frequency */
@


%-------------------------------------------------------------

<<time/arm/dat_time.h>>=
/*
 * Time.
 *
 * HZ should divide 1000 evenly, ideally.
 * 100, 125, 200, 250 and 333 are okay.
 */
<<constant Arch_HZ(arm)>>

// was vlong in x86
//typedef uvlong        Tval;
@



\subsection*{[[time/arm/clock.c]]}


<<enum _anon_ (time/arm/clock.c)(arm)>>=
enum {
    Localctl    = 0x00,
    Prescaler   = 0x08,
    Localintpending = 0x60,

    SystimerFreq    = 1*Mhz,
    MaxPeriod   = SystimerFreq / Arch_HZ,
    MinPeriod   = SystimerFreq / (100*Arch_HZ),

};
@

<<struct Systimers(arm)>>=
struct Systimers {
    u32int  cs;
    u32int  clo;
    u32int  chi;
    u32int  c0;
    u32int  c1;
    u32int  c2;
    u32int  c3;
};
@

<<struct Armtimer(arm)>>=
struct Armtimer {
    u32int  load;
    u32int  val;
    u32int  ctl;
    u32int  irqack;
    u32int  irq;
    u32int  maskedirq;
    u32int  reload;
    u32int  predivider;
    u32int  count;
};
@

<<enum _anon_ (time/arm/clock.c)2(arm)>>=
enum {
    CntPrescaleShift= 16,   /* freq is sys_clk/(prescale+1) */
    CntPrescaleMask = 0xFF,
    CntEnable   = 1<<9,
    TmrDbgHalt  = 1<<8,
    TmrEnable   = 1<<7,
    TmrIntEnable    = 1<<5,
    TmrPrescale1    = 0x00<<2,
    TmrPrescale16   = 0x01<<2,
    TmrPrescale256  = 0x02<<2,
    CntWidth16  = 0<<1,
    CntWidth32  = 1<<1,

    /* generic timer (cortex-a7) */
    Enable  = 1<<0,
    Imask   = 1<<1,
    Istatus = 1<<2,
};
@

<<function clockintr(arm)>>=
static void
clockintr(Ureg *ureg, void *)
{
    Systimers *tn;

    tn = (Systimers*)SYSTIMERS;
    /* dismiss interrupt */
    tn->cs = 1<<3;
    timerintr(ureg, 0);
}
@
% >> 

<<function localclockintr(arm)>>=
static void
localclockintr(Ureg *ureg, void *)
{
    if(cpu->cpuno == 0)
        panic("cpu0: Unexpected local generic timer interrupt");
    cpwrsc(0, CpTIMER, CpTIMERphys, CpTIMERphysctl, Imask|Enable);
    timerintr(ureg, 0);
}
@

<<function clockshutdown(arm)>>=
void
clockshutdown(void)
{
    Armtimer *tm;

    tm = (Armtimer*)ARMTIMER;
    tm->ctl = 0;
    //wdogoff();
}
@

<<function clockinit(arm)>>=
void
clockinit(void)
{
    Systimers *tn;
    Armtimer *tm;
    u32int t0, t1, tstart, tend;

    if(((cprdsc(0, CpID, CpIDfeat, 1) >> 16) & 0xF) != 0) {
        /* generic timer supported */
        if(cpu->cpuno == 0){
            *(ulong*)(ARMLOCAL + Localctl) = 0;             /* magic */
            *(ulong*)(ARMLOCAL + Prescaler) = 0x06aaaaab;   /* magic for 1 Mhz */
        }
        cpwrsc(0, CpTIMER, CpTIMERphys, CpTIMERphysctl, Imask);
    }

    tn = (Systimers*)SYSTIMERS;
    tstart = tn->clo;
    do{
        t0 = arch_lcycles();
    }while(tn->clo == tstart);
    tend = tstart + 10000;
    do{
        t1 = arch_lcycles();
    }while(tn->clo != tend);
    t1 -= t0;
    cpu->cpuhz = 100 * t1;
    cpu->cpumhz = (cpu->cpuhz + Mhz/2 - 1) / Mhz;
    cpu->cyclefreq = cpu->cpuhz;
    if(cpu->cpuno == 0){
        tn->c3 = tn->clo - 1;
        tm = (Armtimer*)ARMTIMER;
        tm->load = 0;
        tm->ctl = TmrPrescale1|CntEnable|CntWidth32;
        arch_intrenable(IRQtimer3, clockintr, nil, 0, "clock");
    }else
        arch_intrenable(IRQcntpns, localclockintr, nil, 0, "clock");
}
@

<<function arch_timerset(arm)>>=
void
arch_timerset(Tval next)
{
    Systimers *tn;
    uvlong now;
    long period;

    now = arch_fastticks(nil);
    period = next - now;
    if(period < MinPeriod)
        period = MinPeriod;
    else if(period > MaxPeriod)
        period = MaxPeriod;
    if(cpu->cpuno > 0){
        cpwrsc(0, CpTIMER, CpTIMERphys, CpTIMERphysval, period);
        cpwrsc(0, CpTIMER, CpTIMERphys, CpTIMERphysctl, Enable);
    }else{
        tn = (Systimers*)SYSTIMERS;
        tn->c3 = (ulong)(now + period);
    }
}
@

<<function clock_arch_fastticks(arm)>>=
uvlong
clock_arch_fastticks(uvlong *hz)
{
    Systimers *tn;
    ulong lo, hi;
    uvlong now;
    int s;

    if(hz)
        *hz = SystimerFreq;
    tn = (Systimers*)SYSTIMERS;
    s = arch_splhi();
    do{
        hi = tn->chi;
        lo = tn->clo;
    }while(tn->chi != hi);
    now = (uvlong)hi<<32 | lo;
    cpu->fastclock = now;
    arch_splx(s);
    return cpu->fastclock;
}
@

<<function arch_perfticks(arm)>>=
ulong
arch_perfticks(void)
{
    Armtimer *tm;

    tm = (Armtimer*)ARMTIMER;
    return tm->count;
}
@

<<function armtimerset(arm)>>=
void
armtimerset(int n)
{
    Armtimer *tm;

    tm = (Armtimer*)ARMTIMER;
    if(n > 0){
        tm->ctl |= TmrEnable|TmrIntEnable;
        tm->load = n;
    }else{
        tm->load = 0;
        tm->ctl &= ~(TmrEnable|TmrIntEnable);
        tm->irq = 1;
    }
}
@

<<function arch_us(arm)>>=
ulong
arch_us(void)
{
    if(SystimerFreq != 1*Mhz)
        return fastticks2us(arch_fastticks(nil));
    return arch_fastticks(nil);
}
@

<<function clock_arch_microdelay(arm)>>=
void
clock_arch_microdelay(int n)
{
    Systimers *tn;
    u32int now, diff;

    diff = n + 1;
    tn = (Systimers*)SYSTIMERS;
    now = tn->clo;
    while(tn->clo - now < diff)
        ;
}
@

<<function clock_arch_delay(arm)>>=
void
clock_arch_delay(int n)
{
    while(--n >= 0)
        arch_microdelay(1000);
}
@


%-------------------------------------------------------------

<<time/arm/clock.c>>=
/*
 * bcm283[56] timers
 *  System timers run at 1MHz (timers 1 and 2 are used by GPU)
 *  ARM timer usually runs at 250MHz (may be slower in low power modes)
 *  Cycle counter runs at 700MHz (unless overclocked)
 *    All are free-running up-counters
 *  Cortex-a7 has local generic timers per cpu (which we run at 1MHz)
 *
 * Use system timer 3 (64 bits) for hzclock interrupts and fastticks
 *   For smp on bcm2836, use local generic timer for interrupts on cpu1-3
 * Use ARM timer (32 bits) for perfticks
 * Use ARM timer to force immediate interrupt
 * Use cycle counter for cycles()
 */
<<kernel basic includes>>

#include "io.h"
#include "ureg.h"

#include "arm.h"

<<constant SYSTIMERS(arm)>>
<<constant ARMTIMER(arm)>>
//TODO factorize in mem.h
<<constant ARMLOCAL(arm)>>

<<enum _anon_ (time/arm/clock.c)(arm)>>

typedef struct Systimers Systimers;
typedef struct Armtimer Armtimer;

<<struct Systimers(arm)>>

<<struct Armtimer(arm)>>

<<enum _anon_ (time/arm/clock.c)2(arm)>>

<<function clockintr(arm)>>

<<function localclockintr(arm)>>

<<function clockshutdown(arm)>>

<<function clockinit(arm)>>

<<function arch_timerset(arm)>>

<<function clock_arch_fastticks(arm)>>

<<function arch_perfticks(arm)>>

<<function armtimerset(arm)>>

<<function arch_us(arm)>>

<<function clock_arch_microdelay(arm)>>

<<function clock_arch_delay(arm)>>
@


\subsection*{[[time/arm/time_raspi1.s]]}

<<time/arm/time_raspi1.s>>=
#include "mem.h"
#include "arm.h"
        
TEXT arch_lcycles(SB), 1, $-4
    MRC CpSC, 0, R0, C(CpSPM), C(CpSPMperf), CpSPMcyc
    RET

TEXT tmrget(SB), 1, $-4             /* local generic timer physical counter value */
    MOVW    $0, R1              /* not in armv6 */
    MOVW    R1, 0(R0)
    MOVW    R1, 4(R0)
    RET
@
%$

\subsection*{[[time/arm/time_raspi2.s]]}

<<time/arm/time_raspi2.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"
        
TEXT arch_lcycles(SB), 1, $-4
    MRC CpSC, 0, R0, C(CpCLD), C(CpCLDcyc), 0
    RET

TEXT tmrget(SB), 1, $-4             /* local generic timer physical counter value */
    MRRC(CpSC, 0, 1, 2, CpTIMER)
    MOVM.IA [R1-R2], (R0)
    RET
@

\section{[[processes/arm/]]}

\subsection*{[[processes/arm/dat_processes.h]]}



%-------------------------------------------------------------

<<processes/arm/dat_processes.h>>=

<<constant AOUT_MAGIC(arm)>>

<<enum _anon_ (arch/arm/dat_processes.h)(arm)>>

<<struct Arch_FPsave(arm)>>

@


\subsection*{[[processes/arm/arch.c]]}


<<function arch_dbgpc(arm)>>=
/*
 *  pc output by dumpaproc
 */
uintptr
arch_dbgpc(Proc* p)
{
    Ureg *ureg;

    ureg = p->dbgreg;
    if(ureg == 0)
        return 0;

    return ureg->pc;
}
@


<<function arch_setregisters(arm)>>=
/* This routine must save the values of registers the user is not permitted
 * to write from devproc and then restore the saved values before returning.
 */
void
arch_setregisters(Ureg* ureg, char* pureg, char* uva, int n)
{
    USED(ureg, pureg, uva, n);
}
@

<<function arch_setkernur(arm)>>=
/* Give enough context in the ureg to produce a kernel stack for
 * a sleeping process
 */
void
arch_setkernur(Ureg* ureg, Proc* p)
{
    ureg->pc = p->sched.pc;
    ureg->sp = p->sched.sp+4;
    ureg->r14 = PTR2UINT(sched);
}
@

<<function arch_validalign(arm)>>=
/*
 * called in syscallfmt.c, sysfile.c, sysproc.c
 */
void
arch_validalign(uintptr addr, unsigned align)
{
    /*
     * Plan 9 is a 32-bit O/S, and the hardware it runs on
     * does not usually have instructions which move 64-bit
     * quantities directly, synthesizing the operations
     * with 32-bit move instructions. Therefore, the compiler
     * (and hardware) usually only enforce 32-bit alignment,
     * if at all.
     *
     * Take this out if the architecture warrants it.
     */
    if(align == sizeof(vlong))
        align = sizeof(long);

    /*
     * Check align is a power of 2, then addr alignment.
     */
    if((align != 0 && !(align & (align-1))) && !(addr & (align-1)))
        return;
    postnote(up, 1, "sys: odd address", NDebug);
    error(Ebadarg);
    /*NOTREACHED*/
}
@



%-------------------------------------------------------------

<<processes/arm/arch.c>>=
<<kernel basic includes>>

#include <tos.h>
#include "ureg.h"

#include "arm.h"

/*
 * A lot of this stuff doesn't belong here
 * but this is a convenient dumping ground for
 * later sorting into the appropriate buckets.
 */

<<function arch_userpc(arm)>>

<<function arch_dbgpc(arm)>>


<<function arch_userureg(arm)>>




<<function arch_setregisters(arm)>>

<<function arch_setkernur(arm)>>

<<function arch_validalign(arm)>>

<<function kexit(arm)>>


<<function linkproc(arm)>>

<<function arch_kprocchild(arm)>>
@


\subsection*{[[processes/arm/vfp3.c]]}


%-------------------------------------------------------------

<<processes/arm/vfp3.c>>=
/*
 * VFPv2 or VFPv3 floating point unit
 */
<<kernel basic includes>>

#include "ureg.h"
#include "arm.h"

<<enum _anon_ (processes/arm/vfp3.c)(arm)>>

<<enum _anon_ (processes/arm/vfp3.c)2(arm)>>
<<enum _anon_ (processes/arm/vfp3.c)3(arm)>>
<<enum _anon_ (processes/arm/vfp3.c)4(arm)>>

<<function subarch(arm)>>

<<function implement(arm)>>

<<function havefp(arm)>>

<<function fpoff(arm)>>

<<function fpononly(arm)>>

<<function fpcfg(arm)>>

<<function fpinit(arm)>>

<<function fpon(arm)>>

<<function fpclear(arm)>>


<<function fpunotify(arm)>>

<<function fpunoted(arm)>>

<<function fpusysrfork(arm)>>

<<function fpusysrforkchild(arm)>>

<<function fpsave(arm)>>

<<function fprestore(arm)>>

<<function fpuprocsave(arm)>>

<<function fpuprocrestore(arm)>>

<<function fpusysprocsetup(arm)>>


<<function arch_procsetup(arm)>>

<<function arch_procsave(arm)>>

<<function arch_procrestore(arm)>>

<<function mathnote(arm)>>

<<function mathemu(arm)>>

<<function fpstuck(arm)>>

<<enum _anon_ (processes/arm/vfp3.c)5(arm)>>

<<function condok(arm)>>

/* instruction decoding */ // was in arm.h
<<macro ISCPOP(arm)>>
<<macro ISVFPOP(arm)>>

<<function fpuemu(arm)>>
@


\subsection*{[[processes/arm/lproc.s]]}

<<processes/arm/lproc.s>>=
#include "mem.h"
#include "arm.h"

/*
 *  This is the first jump from kernel to user mode.
 *  Fake a return from interrupt.
 *
 *  Enter with R0 containing the user stack pointer.
 *  UTZERO + 0x20 is always the entry point.
 *
 */
TEXT arch_touser(SB), 1, $-4
    /* store the user stack pointer into the USR_r13 */
    MOVM.DB.W [R0], (R13)
    /* avoid the ambiguity described in notes/movm.w. */
//  MOVM.S.IA.W (R13), [R13]
    MOVM.S  (R13), [R13]
    ADD $4, R13

    /* set up a PSR for user level */
    MOVW    $(PsrMusr), R0
    MOVW    R0, SPSR

    /* save the PC on the stack */
    MOVW    $(UTZERO+0x20), R0
    MOVM.DB.W [R0], (R13)

    /*
     * note that 5a's RFE is not the v6 arch. instruction (0xe89d0a00,
     * I think), which loads CPSR from the word after the PC at (R13),
     * but rather the pre-v6 simulation `MOVM.IA.S.W (R13), [R15]'
     * (0xe8fd8000 since MOVM is LDM in this case), which loads CPSR
     * not from memory but from SPSR due to `.S'.
     */
    RFE

<<function arch_forkret(arm)>>
@
%$

\subsection*{[[processes/arm/switch.s]]}

<<processes/arm/switch.s>>=
TEXT arch_setlabel(SB), 1, $-4
    MOVW    R13, 0(R0)      /* sp */
    MOVW    R14, 4(R0)      /* pc */
    MOVW    $0, R0
    RET

TEXT arch_gotolabel(SB), 1, $-4
    MOVW    0(R0), R13      /* sp */
    MOVW    4(R0), R14      /* pc */
    MOVW    $1, R0
    RET

TEXT getcallerpc(SB), 1, $-4
    MOVW    0(R13), R0
    RET
@
%$


\section{[[syscalls/arm/]]}

\subsection*{[[syscalls/arm/syscall.c]]}

<<function noted(arm)>>=
/*
 *   Return user to state before notify()
 */
static void
noted(Ureg* cur, uintptr arg0)
{
    NFrame *nf;
    Ureg *nur;

    qlock(&up->debug);
    if(arg0 != NRSTR && !up->notified){
        qunlock(&up->debug);
        pprint("call to noted() when not notified\n");
        pexit("Suicide", 0);
    }
    up->notified = 0;
    fpunoted();

    nf = up->ureg;

    /* sanity clause */
    if(!okaddr(PTR2UINT(nf), sizeof(NFrame), 0)){
        qunlock(&up->debug);
        pprint("bad ureg in noted %#p\n", nf);
        pexit("Suicide", 0);
    }

    /* don't let user change system flags */
    nur = &nf->ureg;
    nur->psr &= PsrMask|PsrDfiq|PsrDirq;
    nur->psr |= (cur->psr & ~(PsrMask|PsrDfiq|PsrDirq));

    memmove(cur, nur, sizeof(Ureg));

    switch((int)arg0){
    case NCONT:
    case NRSTR:
        if(!okaddr(nur->pc, BY2WD, 0) || !okaddr(nur->sp, BY2WD, 0)){
            qunlock(&up->debug);
            pprint("suicide: trap in noted\n");
            pexit("Suicide", 0);
        }
        up->ureg = nf->old;
        qunlock(&up->debug);
        break;
    case NSAVE:
        if(!okaddr(nur->pc, BY2WD, 0) || !okaddr(nur->sp, BY2WD, 0)){
            qunlock(&up->debug);
            pprint("suicide: trap in noted\n");
            pexit("Suicide", 0);
        }
        qunlock(&up->debug);

        arch_splhi();
        nf->arg1 = nf->msg;
        nf->arg0 = &nf->ureg;
        nf->ip = 0;
        cur->sp = PTR2UINT(nf);
        cur->r0 = PTR2UINT(nf->arg0);
        break;
    default:
        pprint("unknown noted arg %#p\n", arg0);
        up->lastnote.flag = NDebug;
        /*FALLTHROUGH*/
    case NDFLT:
        if(up->lastnote.flag == NDebug){ 
            qunlock(&up->debug);
            pprint("suicide: %s\n", up->lastnote.msg);
        }
        else
            qunlock(&up->debug);
        pexit(up->lastnote.msg, up->lastnote.flag != NDebug);
    }
}
@

<<function notify(arm)>>=
/*
 *  Call user, if necessary, with note.
 *  Pass user the Ureg struct and the note on his stack.
 */
int
notify(Ureg* ureg)
{
    int l;
    Note *n;
    u32int s;
    uintptr sp;
    NFrame *nf;

    if(up->procctl)
        procctl(up);
    if(up->nnote == 0)
        return 0;

    fpunotify(ureg);

    s = arch_spllo();
    qlock(&up->debug);

    up->notepending = 0;
    n = &up->note[0];
    if(strncmp(n->msg, "sys:", 4) == 0){
        l = strlen(n->msg);
        if(l > ERRMAX-23)   /* " pc=0x0123456789abcdef\0" */
            l = ERRMAX-23;
        snprint(n->msg + l, sizeof n->msg - l, " pc=%#lux", ureg->pc);
    }

    if(n->flag != NUser && (up->notified || up->notify == 0)){
        if(n->flag == NDebug)
            pprint("suicide: %s\n", n->msg);
        qunlock(&up->debug);
        pexit(n->msg, n->flag != NDebug);
    }

    if(up->notified){
        qunlock(&up->debug);
        arch_splhi();
        return 0;
    }
        
    if(up->notify == nil){
        qunlock(&up->debug);
        pexit(n->msg, n->flag != NDebug);
    }
    if(!okaddr(PTR2UINT(up->notify), 1, 0)){
        pprint("suicide: notify function address %#p\n", up->notify);
        qunlock(&up->debug);
        pexit("Suicide", 0);
    }

    sp = ureg->sp - sizeof(NFrame);
    if(!okaddr(sp, sizeof(NFrame), 1)){
        qunlock(&up->debug);
        pprint("suicide: notify stack address %#p\n", sp);
        pexit("Suicide", 0);
    }

    nf = UINT2PTR(sp);
    memmove(&nf->ureg, ureg, sizeof(Ureg));
    nf->old = up->ureg;
    up->ureg = nf;
    memmove(nf->msg, up->note[0].msg, ERRMAX);
    nf->arg1 = nf->msg;
    nf->arg0 = &nf->ureg;
    ureg->r0 = PTR2UINT(nf->arg0);
    nf->ip = 0;

    ureg->sp = sp;
    ureg->pc = PTR2UINT(up->notify);
    up->notified = 1;
    up->nnote--;
    memmove(&up->lastnote, &up->note[0], sizeof(Note));
    memmove(&up->note[0], &up->note[1], up->nnote*sizeof(Note));

    qunlock(&up->debug);
    arch_splx(s);

    return 1;
}
@



<<function sysprocsetup(arm)>>=
void
sysprocsetup(Proc* p)
{
    fpusysprocsetup(p);
}
@

<<struct NFrame(arm)>>=
struct NFrame {
    uintptr ip;
    Ureg*   arg0;
    char*   arg1;
    char    msg[ERRMAX];
    Ureg*   old;
    Ureg    ureg;
};
@


%-------------------------------------------------------------

<<syscalls/arm/syscall.c>>=
<<kernel basic includes>>

#include "../port/systab.h"

#include <tos.h>
#include "ureg.h"

#include "arm.h"

typedef struct NFrame NFrame;
<<struct NFrame(arm)>>

<<function noted(arm)>>

<<function notify(arm)>>

<<function syscall(arm)>>

<<function arch_execregs(arm)>>

<<function sysprocsetup(arm)>>

<<function arch_forkchild(arm)>>
@


\part{Extra Extra}

\subsection*{[[buses/arm/devusb.c]]}

<<enum _anon_ (buses/arm/devusb.c)(arm)>>=
enum
{
    /* Qid numbers */
    Qdir = 0,       /* #u */
    Qusbdir,            /* #u/usb */
    Qctl,           /* #u/usb/ctl - control requests */

    Qep0dir,            /* #u/usb/ep0.0 - endpoint 0 dir */
    Qep0io,         /* #u/usb/ep0.0/data - endpoint 0 I/O */
    Qep0ctl,        /* #u/usb/ep0.0/ctl - endpoint 0 ctl. */
    Qep0dummy,      /* give 4 qids to each endpoint */

    Qepdir = 0,     /* (qid-qep0dir)&3 is one of these */
    Qepio,          /* to identify which file for the endpoint */
    Qepctl,

    /* ... */

    /* Usb ctls. */
    CMdebug = 0,        /* debug on|off */
    CMdump,         /* dump (data structures for debug) */

    /* Ep. ctls */
    CMnew = 0,      /* new nb ctl|bulk|intr|iso r|w|rw (endpoint) */
    CMnewdev,       /* newdev full|low|high portnb (allocate new devices) */
    CMhub,          /* hub (set the device as a hub) */
    CMspeed,        /* speed full|low|high|no */
    CMmaxpkt,       /* maxpkt size */
    CMntds,         /* ntds nb (max nb. of tds per µframe) */
    CMclrhalt,      /* clrhalt (halt was cleared on endpoint) */
    CMpollival,     /* pollival interval (interrupt/iso) */
    CMhz,           /* hz n (samples/sec; iso) */
    CMsamplesz,     /* samplesz n (sample size; iso) */
    CMinfo,         /* info infostr (ke.ep info for humans) */
    CMdetach,       /* detach (abort I/O forever on this ep). */
    CMaddress,      /* address (address is assigned) */
    CMdebugep,      /* debug n (set/clear debug for this ep) */
    CMname,         /* name str (show up as #u/name as well) */
    CMtmout,        /* timeout n (activate timeouts for ep) */
    CMpreset,       /* reset the port */

    /* Hub feature selectors */
    Rportenable = 1,
    Rportreset  = 4,

};
@

<<struct Hcitype(arm)>>=
struct Hcitype
{
    char*   type;
    int (*reset)(Hci*);
};
@

<<macro QID(arm)>>=
#define QID(q)  ((int)(q).path)
@

<<global usbctls(arm)>>=
static Cmdtab usbctls[] =
{
    {CMdebug,   "debug",    2},
    {CMdump,    "dump",     1},
};
@

<<global epctls(arm)>>=
static Cmdtab epctls[] =
{
    {CMnew,     "new",      4},
    {CMnewdev,  "newdev",   3},
    {CMhub,     "hub",      1},
    {CMspeed,   "speed",    2},
    {CMmaxpkt,  "maxpkt",   2},
    {CMntds,    "ntds",     2},
    {CMpollival,    "pollival", 2},
    {CMsamplesz,    "samplesz", 2},
    {CMhz,      "hz",       2},
    {CMinfo,    "info",     0},
    {CMdetach,  "detach",   1},
    {CMaddress, "address",  1},
    {CMdebugep, "debug",    2},
    {CMclrhalt, "clrhalt",  1},
    {CMname,    "name",     2},
    {CMtmout,   "timeout",  2},
    {CMpreset,  "reset",    1},
};
@

<<global usbdir(arm)>>=
static Dirtab usbdir[] =
{
    "ctl",      {Qctl},     0,  0666,
};
@

<<global usbmodename(arm)>>=
char *usbmodename[] =
{
    [OREAD] "r",
    [OWRITE]    "w",
    [ORDWR] "rw",
};
@

<<global ttname(arm)>>=
static char *ttname[] =
{
    [Tnone] "none",
    [Tctl]  "control",
    [Tiso]  "iso",
    [Tintr] "interrupt",
    [Tbulk] "bulk",
};
@

<<global spname(arm)>>=
static char *spname[] =
{
    [Fullspeed] "full",
    [Lowspeed]  "low",
    [Highspeed] "high",
    [Nospeed]   "no",
};
@

<<global debug(arm)>>=
static int  debug;
@

<<global hcitypes(arm)>>=
static Hcitype  hcitypes[Nhcis];
@

<<global hcis(arm)>>=
static Hci* hcis[Nhcis];
@

<<global epslck(arm)>>=
static QLock    epslck;     /* add, del, lookup endpoints */
@

<<global eps(arm)>>=
static Ep*  eps[Neps];  /* all endpoints known */
@

<<global epmax(arm)>>=
static int  epmax;      /* 1 + last endpoint index used  */
@

<<global usbidgen(arm)>>=
static int  usbidgen;   /* device address generator */
@

<<function seprintdata(arm)>>=
/*
 * Is there something like this in a library? should it be?
 */
char*
seprintdata(char *s, char *se, uchar *d, int n)
{
    int i, l;

    s = seprint(s, se, " %#p[%d]: ", d, n);
    l = n;
    if(l > 10)
        l = 10;
    for(i=0; i<l; i++)
        s = seprint(s, se, " %2.2ux", d[i]);
    if(l < n)
        s = seprint(s, se, "...");
    return s;
}
@

<<function name2speed(arm)>>=
static int
name2speed(char *name)
{
    int i;

    for(i = 0; i < nelem(spname); i++)
        if(strcmp(name, spname[i]) == 0)
            return i;
    return Nospeed;
}
@

<<function name2ttype(arm)>>=
static int
name2ttype(char *name)
{
    int i;

    for(i = 0; i < nelem(ttname); i++)
        if(strcmp(name, ttname[i]) == 0)
            return i;
    /* may be a std. USB ep. type */
    i = strtol(name, nil, 0);
    switch(i+1){
    case Tctl:
    case Tiso:
    case Tbulk:
    case Tintr:
        return i+1;
    default:
        return Tnone;
    }
}
@

<<function name2mode(arm)>>=
static int
name2mode(char *mode)
{
    int i;

    for(i = 0; i < nelem(usbmodename); i++)
        if(strcmp(mode, usbmodename[i]) == 0)
            return i;
    return -1;
}
@

<<function qid2epidx(arm)>>=
static int
qid2epidx(int q)
{
    q = (q-Qep0dir)/4;
    if(q < 0 || q >= epmax || eps[q] == nil)
        return -1;
    return q;
}
@

<<function isqtype(arm)>>=
static int
isqtype(int q, int type)
{
    if(q < Qep0dir)
        return 0;
    q -= Qep0dir;
    return (q & 3) == type;
}
@

<<function addhcitype(arm)>>=
void
addhcitype(char* t, int (*r)(Hci*))
{
    static int ntype;

    if(ntype == Nhcis)
        panic("too many USB host interface types");
    hcitypes[ntype].type = t;
    hcitypes[ntype].reset = r;
    ntype++;
}
@

<<function seprintep(arm)>>=
static char*
seprintep(char *s, char *se, Ep *ep, int all)
{
    static char* dsnames[] = { "config", "enabled", "detached", "reset" };
    Udev *d;
    int i;
    int di;

    d = ep->dev;

    qlock(ep);
    if(waserror()){
        qunlock(ep);
        nexterror();
    }
    di = ep->dev->nb;
    if(all)
        s = seprint(s, se, "dev %d ep %d ", di, ep->nb);
    s = seprint(s, se, "%s", dsnames[ep->dev->state]);
    s = seprint(s, se, " %s", ttname[ep->ttype]);
    assert(ep->mode == OREAD || ep->mode == OWRITE || ep->mode == ORDWR);
    s = seprint(s, se, " %s", usbmodename[ep->mode]);
    s = seprint(s, se, " speed %s", spname[d->speed]);
    s = seprint(s, se, " maxpkt %ld", ep->maxpkt);
    s = seprint(s, se, " pollival %ld", ep->pollival);
    s = seprint(s, se, " samplesz %ld", ep->samplesz);
    s = seprint(s, se, " hz %ld", ep->hz);
    s = seprint(s, se, " hub %d", ep->dev->hub);
    s = seprint(s, se, " port %d", ep->dev->port);
    if(ep->inuse)
        s = seprint(s, se, " busy");
    else
        s = seprint(s, se, " idle");
    if(all){
        s = seprint(s, se, " load %uld", ep->load);
        s = seprint(s, se, " ref %ld addr %#p", ep->ref, ep);
        s = seprint(s, se, " idx %d", ep->idx);
        if(ep->name != nil)
            s = seprint(s, se, " name '%s'", ep->name);
        if(ep->tmout != 0)
            s = seprint(s, se, " tmout");
        if(ep == ep->ep0){
            s = seprint(s, se, " ctlrno %#x", ep->hp->ctlrno);
            s = seprint(s, se, " eps:");
            for(i = 0; i < nelem(d->eps); i++)
                if(d->eps[i] != nil)
                    s = seprint(s, se, " ep%d.%d", di, i);
        }
    }
    if(ep->info != nil)
        s = seprint(s, se, "\n%s %s\n", ep->info, ep->hp->type);
    else
        s = seprint(s, se, "\n");
    qunlock(ep);
    poperror();
    return s;
}
@

<<function epalloc(arm)>>=
static Ep*
epalloc(Hci *hp)
{
    Ep *ep;
    int i;

    ep = smalloc(sizeof(Ep));
    ep->ref = 1;
    qlock(&epslck);
    for(i = 0; i < Neps; i++)
        if(eps[i] == nil)
            break;
    if(i == Neps){
        qunlock(&epslck);
        free(ep);
        print("usb: bug: too few endpoints.\n");
        return nil;
    }
    ep->idx = i;
    if(epmax <= i)
        epmax = i+1;
    eps[i] = ep;
    ep->hp = hp;
    ep->maxpkt = 8;
    ep->ntds = 1;
    ep->samplesz = ep->pollival = ep->hz = 0; /* make them void */
    qunlock(&epslck);
    return ep;
}
@

<<function getep(arm)>>=
static Ep*
getep(int i)
{
    Ep *ep;

    if(i < 0 || i >= epmax || eps[i] == nil)
        return nil;
    qlock(&epslck);
    ep = eps[i];
    if(ep != nil)
        incref(ep);
    qunlock(&epslck);
    return ep;
}
@

<<function putep(arm)>>=
static void
putep(Ep *ep)
{
    Udev *d;

    if(ep != nil && decref(ep) == 0){
        d = ep->dev;
        deprint("usb: ep%d.%d %#p released\n", d->nb, ep->nb, ep);
        qlock(&epslck);
        eps[ep->idx] = nil;
        if(ep->idx == epmax-1)
            epmax--;
        if(ep == ep->ep0 && ep->dev != nil && ep->dev->nb == usbidgen)
            usbidgen--;
        qunlock(&epslck);
        if(d != nil){
            qlock(ep->ep0);
            d->eps[ep->nb] = nil;
            qunlock(ep->ep0);
        }
        if(ep->ep0 != ep){
            putep(ep->ep0);
            ep->ep0 = nil;
        }
        free(ep->info);
        free(ep->name);
        free(ep);
    }
}
@

<<function dumpeps(arm)>>=
static void
dumpeps(void)
{
    int i;
    static char buf[512];
    char *s;
    char *e;
    Ep *ep;

    print("usb dump eps: epmax %d Neps %d (ref=1+ for dump):\n", epmax, Neps);
    for(i = 0; i < epmax; i++){
        s = buf;
        e = buf+sizeof(buf);
        ep = getep(i);
        if(ep != nil){
            if(waserror()){
                putep(ep);
                nexterror();
            }
            s = seprint(s, e, "ep%d.%d ", ep->dev->nb, ep->nb);
            seprintep(s, e, ep, 1);
            print("%s", buf);
            ep->hp->seprintep(buf, e, ep);
            print("%s", buf);
            poperror();
            putep(ep);
        }
    }
    print("usb dump hcis:\n");
    for(i = 0; i < Nhcis; i++)
        if(hcis[i] != nil)
            hcis[i]->dump(hcis[i]);
}
@

<<function newusbid(arm)>>=
static int
newusbid(Hci *)
{
    int id;

    qlock(&epslck);
    id = ++usbidgen;
    if(id >= 0x7F)
        print("#u: too many device addresses; reuse them more\n");
    qunlock(&epslck);
    return id;
}
@

<<function newdev(arm)>>=
/*
 * Create endpoint 0 for a new device
 */
static Ep*
newdev(Hci *hp, int ishub, int isroot)
{
    Ep *ep;
    Udev *d;

    ep = epalloc(hp);
    d = ep->dev = smalloc(sizeof(Udev));
    d->nb = newusbid(hp);
    d->eps[0] = ep;
    ep->nb = 0;
    ep->toggle[0] = ep->toggle[1] = 0;
    d->ishub = ishub;
    d->isroot = isroot;
    if(hp->highspeed != 0)
        d->speed = Highspeed;
    else
        d->speed = Fullspeed;
    d->state = Dconfig;     /* address not yet set */
    ep->dev = d;
    ep->ep0 = ep;           /* no ref counted here */
    ep->ttype = Tctl;
    ep->tmout = Xfertmout;
    ep->mode = ORDWR;
    dprint("newdev %#p ep%d.%d %#p\n", d, d->nb, ep->nb, ep);
    return ep;
}
@

<<function newdevep(arm)>>=
/*
 * Create a new endpoint for the device
 * accessed via the given endpoint 0.
 */
static Ep*
newdevep(Ep *ep, int i, int tt, int mode)
{
    Ep *nep;
    Udev *d;

    d = ep->dev;
    if(d->eps[i] != nil)
        error("endpoint already in use");
    nep = epalloc(ep->hp);
    incref(ep);
    d->eps[i] = nep;
    nep->nb = i;
    nep->toggle[0] = nep->toggle[1] = 0;
    nep->ep0 = ep;
    nep->dev = ep->dev;
    nep->mode = mode;
    nep->ttype = tt;
    nep->debug = ep->debug;
    /* set defaults */
    switch(tt){
    case Tctl:
        nep->tmout = Xfertmout;
        break;
    case Tintr:
        nep->pollival = 10;
        break;
    case Tiso:
        nep->tmout = Xfertmout;
        nep->pollival = 10;
        nep->samplesz = 4;
        nep->hz = 44100;
        break;
    }
    deprint("newdevep ep%d.%d %#p\n", d->nb, nep->nb, nep);
    return ep;
}
@

<<function epdataperm(arm)>>=
static int
epdataperm(int mode)
{

    switch(mode){
    case OREAD:
        return 0440|DMEXCL;
        break;
    case OWRITE:
        return 0220|DMEXCL;
        break;
    default:
        return 0660|DMEXCL;
    }
}
@

<<function usbgen(arm)>>=
static int
usbgen(Chan *c, char *, Dirtab*, int, int s, Dir *dp)
{
    Qid q;
    Dirtab *dir;
    int perm;
    char *se;
    Ep *ep;
    int nb;
    int mode;

    if(0)ddprint("usbgen q %#x s %d...", QID(c->qid), s);
    if(s == DEVDOTDOT){
        if(QID(c->qid) <= Qusbdir){
            mkqid(&q, Qdir, 0, QTDIR);
            devdir(c, q, "#u", 0, eve, 0555, dp);
        }else{
            mkqid(&q, Qusbdir, 0, QTDIR);
            devdir(c, q, "usb", 0, eve, 0555, dp);
        }
        if(0)ddprint("ok\n");
        return 1;
    }

    switch(QID(c->qid)){
    case Qdir:              /* list #u */
        if(s == 0){
            mkqid(&q, Qusbdir, 0, QTDIR);
            devdir(c, q, "usb", 0, eve, 0555, dp);
            if(0)ddprint("ok\n");
            return 1;
        }
        s--;
        if(s < 0 || s >= epmax)
            goto Fail;
        ep = getep(s);
        if(ep == nil || ep->name == nil){
            if(ep != nil)
                putep(ep);
            if(0)ddprint("skip\n");
            return 0;
        }
        if(waserror()){
            putep(ep);
            nexterror();
        }
        mkqid(&q, Qep0io+s*4, 0, QTFILE);
        devdir(c, q, ep->name, 0, eve, epdataperm(ep->mode), dp);
        putep(ep);
        poperror();
        if(0)ddprint("ok\n");
        return 1;

    case Qusbdir:               /* list #u/usb */
    Usbdir:
        if(s < nelem(usbdir)){
            dir = &usbdir[s];
            mkqid(&q, dir->qid.path, 0, QTFILE);
            devdir(c, q, dir->name, dir->length, eve, dir->perm, dp);
            if(0)ddprint("ok\n");
            return 1;
        }
        s -= nelem(usbdir);
        if(s < 0 || s >= epmax)
            goto Fail;
        ep = getep(s);
        if(ep == nil){
            if(0)ddprint("skip\n");
            return 0;
        }
        if(waserror()){
            putep(ep);
            nexterror();
        }
        se = up->genbuf+sizeof(up->genbuf);
        seprint(up->genbuf, se, "ep%d.%d", ep->dev->nb, ep->nb);
        mkqid(&q, Qep0dir+4*s, 0, QTDIR);
        putep(ep);
        poperror();
        devdir(c, q, up->genbuf, 0, eve, 0755, dp);
        if(0)ddprint("ok\n");
        return 1;

    case Qctl:
        s = 0;
        goto Usbdir;

    default:                /* list #u/usb/epN.M */
        nb = qid2epidx(QID(c->qid));
        ep = getep(nb);
        if(ep == nil)
            goto Fail;
        mode = ep->mode;
        putep(ep);
        if(isqtype(QID(c->qid), Qepdir)){
        Epdir:
            switch(s){
            case 0:
                mkqid(&q, Qep0io+nb*4, 0, QTFILE);
                perm = epdataperm(mode);
                devdir(c, q, "data", 0, eve, perm, dp);
                break;
            case 1:
                mkqid(&q, Qep0ctl+nb*4, 0, QTFILE);
                devdir(c, q, "ctl", 0, eve, 0664, dp);
                break;
            default:
                goto Fail;
            }
        }else if(isqtype(QID(c->qid), Qepctl)){
            s = 1;
            goto Epdir;
        }else{
            s = 0;
            goto Epdir;
        }
        if(0)ddprint("ok\n");
        return 1;
    }
Fail:
    if(0)ddprint("fail\n");
    return -1;
}
@

<<function hciprobe(arm)>>=
static Hci*
hciprobe(int cardno, int ctlrno)
{
    Hci *hp;
    char *type;
    char name[64];
    static int epnb = 1;    /* guess the endpoint nb. for the controller */

    ddprint("hciprobe %d %d\n", cardno, ctlrno);
    hp = smalloc(sizeof(Hci));
    hp->ctlrno = ctlrno;

    if(cardno < 0)
        for(cardno = 0; cardno < Nhcis; cardno++){
            if(hcitypes[cardno].type == nil)
                break;
            type = hp->type;
            if(type==nil || *type==0)
                type = "uhci";
            if(cistrcmp(hcitypes[cardno].type, type) == 0)
                break;
        }

    if(cardno >= Nhcis || hcitypes[cardno].type == nil){
        free(hp);
        return nil;
    }
    dprint("%s...", hcitypes[cardno].type);
    if(hcitypes[cardno].reset(hp) < 0){
        free(hp);
        return nil;
    }

    snprint(name, sizeof(name), "usb%s", hcitypes[cardno].type);
    arch_intrenable(hp->irq, hp->interrupt, hp, UNKNOWN, name);

    print("#u/usb/ep%d.0: %s: port %#luX irq %d\n",
        epnb, hcitypes[cardno].type, hp->port, hp->irq);
    epnb++;

    return hp;
}
@

<<function usbreset(arm)>>=
static void
usbreset(void)
{
    int cardno, ctlrno;
    Hci *hp;

    dprint("usbreset\n");

    for(ctlrno = 0; ctlrno < Nhcis; ctlrno++)
        if((hp = hciprobe(-1, ctlrno)) != nil)
            hcis[ctlrno] = hp;
    cardno = ctlrno = 0;
    while(cardno < Nhcis && ctlrno < Nhcis && hcitypes[cardno].type != nil)
        if(hcis[ctlrno] != nil)
            ctlrno++;
        else{
            hp = hciprobe(cardno, ctlrno);
            if(hp == nil)
                cardno++;
            hcis[ctlrno++] = hp;
        }
    if(hcis[Nhcis-1] != nil)
        print("usbreset: bug: Nhcis too small\n");
}
@

<<function usbinit(arm)>>=
static void
usbinit(void)
{
    Hci *hp;
    int ctlrno;
    Ep *d;
    char info[40];

    dprint("usbinit\n");
    for(ctlrno = 0; ctlrno < Nhcis; ctlrno++){
        hp = hcis[ctlrno];
        if(hp != nil){
            if(hp->init != nil)
                hp->init(hp);
            d = newdev(hp, 1, 1);       /* new root hub */
            d->dev->state = Denabled;   /* although addr == 0 */
            d->maxpkt = 64;
            snprint(info, sizeof(info), "ports %d", hp->nports);
            kstrdup(&d->info, info);
        }
    }
}
@

<<function usbattach(arm)>>=
static Chan*
usbattach(char *spec)
{
    return devattach(L'u', spec);
}
@

<<function usbwalk(arm)>>=
static Walkqid*
usbwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, nil, 0, usbgen);
}
@

<<function usbstat(arm)>>=
static int
usbstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, nil, 0, usbgen);
}
@

<<function usbload(arm)>>=
/*
 * µs for the given transfer, for bandwidth allocation.
 * This is a very rough worst case for what 5.11.3
 * of the usb 2.0 spec says.
 * Also, we are using maxpkt and not actual transfer sizes.
 * Only when we are sure we
 * are not exceeding b/w might we consider adjusting it.
 */
static ulong
usbload(int speed, int maxpkt)
{
    enum{ Hostns = 1000, Hubns = 333 };
    ulong l;
    ulong bs;

    l = 0;
    bs = 10UL * maxpkt;
    switch(speed){
    case Highspeed:
        l = 55*8*2 + 2 * (3 + bs) + Hostns;
        break;
    case Fullspeed:
        l = 9107 + 84 * (4 + bs) + Hostns;
        break;
    case Lowspeed:
        l = 64107 + 2 * Hubns + 667 * (3 + bs) + Hostns;
        break;
    default:
        print("usbload: bad speed %d\n", speed);
        /* let it run */
    }
    return l / 1000UL;  /* in µs */
}
@

<<function usbopen(arm)>>=
static Chan*
usbopen(Chan *c, int omode)
{
    int q;
    Ep *ep;
    int mode;

    mode = openmode(omode);
    q = QID(c->qid);

    if(q >= Qep0dir && qid2epidx(q) < 0)
        error(Eio);
    if(q < Qep0dir || isqtype(q, Qepctl) || isqtype(q, Qepdir))
        return devopen(c, omode, nil, 0, usbgen);

    ep = getep(qid2epidx(q));
    if(ep == nil)
        error(Eio);
    deprint("usbopen q %#x fid %d omode %d\n", q, c->fid, mode);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    qlock(ep);
    if(ep->inuse){
        qunlock(ep);
        error(Einuse);
    }
    ep->inuse = 1;
    qunlock(ep);
    if(waserror()){
        ep->inuse = 0;
        nexterror();
    }
    if(mode != OREAD && ep->mode == OREAD)
        error(Eperm);
    if(mode != OWRITE && ep->mode == OWRITE)
        error(Eperm);
    if(ep->ttype == Tnone)
        error(Enotconf);
    ep->clrhalt = 0;
    ep->rhrepl = -1;
    if(ep->load == 0)
        ep->load = usbload(ep->dev->speed, ep->maxpkt);
    ep->hp->epopen(ep);

    poperror(); /* ep->inuse */
    poperror(); /* don't putep(): ref kept for fid using the ep. */

    c->mode = mode;
    c->flag |= COPEN;
    c->offset = 0;
    c->aux = nil;   /* paranoia */
    return c;
}
@

<<function epclose(arm)>>=
static void
epclose(Ep *ep)
{
    qlock(ep);
    if(waserror()){
        qunlock(ep);
        nexterror();
    }
    if(ep->inuse){
        ep->hp->epclose(ep);
        ep->inuse = 0;
    }
    qunlock(ep);
    poperror();
}
@

<<function usbclose(arm)>>=
static void
usbclose(Chan *c)
{
    int q;
    Ep *ep;

    q = QID(c->qid);
    if(q < Qep0dir || isqtype(q, Qepctl) || isqtype(q, Qepdir))
        return;

    ep = getep(qid2epidx(q));
    if(ep == nil)
        return;
    deprint("usbclose q %#x fid %d ref %ld\n", q, c->fid, ep->ref);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    if(c->flag & COPEN){
        free(c->aux);
        c->aux = nil;
        epclose(ep);
        putep(ep);  /* release ref kept since usbopen */
        c->flag &= ~COPEN;
    }
    poperror();
    putep(ep);
}
@

<<function ctlread(arm)>>=
static long
ctlread(Chan *c, void *a, long n, vlong offset)
{
    int q;
    char *s;
    char *us;
    char *se;
    Ep *ep;
    int i;

    q = QID(c->qid);
    us = s = smalloc(READSTR);
    se = s + READSTR;
    if(waserror()){
        free(us);
        nexterror();
    }
    if(q == Qctl)
        for(i = 0; i < epmax; i++){
            ep = getep(i);
            if(ep != nil){
                if(waserror()){
                    putep(ep);
                    nexterror();
                }
                s = seprint(s, se, "ep%d.%d ", ep->dev->nb, ep->nb);
                s = seprintep(s, se, ep, 0);
                poperror();
            }
            putep(ep);
        }
    else{
        ep = getep(qid2epidx(q));
        if(ep == nil)
            error(Eio);
        if(waserror()){
            putep(ep);
            nexterror();
        }
        if(c->aux != nil){
            /* After a new endpoint request we read
             * the new endpoint name back.
             */
            strecpy(s, se, c->aux);
            free(c->aux);
            c->aux = nil;
        }else
            seprintep(s, se, ep, 0);
        poperror();
        putep(ep);
    }
    n = readstr(offset, a, n, us);
    poperror();
    free(us);
    return n;
}
@

<<function rhubread(arm)>>=
/*
 * Fake root hub emulation.
 */
static long
rhubread(Ep *ep, void *a, long n)
{
    char *b;

    if(ep->dev->isroot == 0 || ep->nb != 0 || n < 2)
        return -1;
    if(ep->rhrepl < 0)
        return -1;

    b = a;
    memset(b, 0, n);
    PUT2(b, ep->rhrepl);
    ep->rhrepl = -1;
    return n;
}
@

<<function rhubwrite(arm)>>=
static long
rhubwrite(Ep *ep, void *a, long n)
{
    uchar *s;
    int cmd;
    int feature;
    int port;
    Hci *hp;

    if(ep->dev == nil || ep->dev->isroot == 0 || ep->nb != 0)
        return -1;
    if(n != Rsetuplen)
        error("root hub is a toy hub");
    ep->rhrepl = -1;
    s = a;
    if(s[Rtype] != (Rh2d|Rclass|Rother) && s[Rtype] != (Rd2h|Rclass|Rother))
        error("root hub is a toy hub");
    hp = ep->hp;
    cmd = s[Rreq];
    feature = GET2(s+Rvalue);
    port = GET2(s+Rindex);
    if(port < 1 || port > hp->nports)
        error("bad hub port number");
    switch(feature){
    case Rportenable:
        ep->rhrepl = hp->portenable(hp, port, cmd == Rsetfeature);
        break;
    case Rportreset:
        ep->rhrepl = hp->portreset(hp, port, cmd == Rsetfeature);
        break;
    case Rgetstatus:
        ep->rhrepl = hp->portstatus(hp, port);
        break;
    default:
        ep->rhrepl = 0;
    }
    return n;
}
@

<<function usbread(arm)>>=
static long
usbread(Chan *c, void *a, long n, vlong offset)
{
    int q;
    Ep *ep;
    int nr;

    q = QID(c->qid);

    if(c->qid.type == QTDIR)
        return devdirread(c, a, n, nil, 0, usbgen);

    if(q == Qctl || isqtype(q, Qepctl))
        return ctlread(c, a, n, offset);

    ep = getep(qid2epidx(q));
    if(ep == nil)
        error(Eio);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    if(ep->dev->state == Ddetach)
        error(Edetach);
    if(ep->mode == OWRITE || ep->inuse == 0)
        error(Ebadusefd);
    switch(ep->ttype){
    case Tnone:
        error("endpoint not configured");
    case Tctl:
        nr = rhubread(ep, a, n);
        if(nr >= 0){
            n = nr;
            break;
        }
        /* else fall */
    default:
        ddeprint("\nusbread q %#x fid %d cnt %ld off %lld\n",q,c->fid,n,offset);
        n = ep->hp->epread(ep, a, n);
        break;
    }
    poperror();
    putep(ep);
    return n;
}
@

<<function pow2(arm)>>=
static long
pow2(int n)
{
    return 1 << n;
}
@

<<function setmaxpkt(arm)>>=
static void
setmaxpkt(Ep *ep, char* s)
{
    long spp;   /* samples per packet */

    if(ep->dev->speed == Highspeed)
        spp = (ep->hz * ep->pollival * ep->ntds + 7999) / 8000;
    else
        spp = (ep->hz * ep->pollival + 999) / 1000;
    ep->maxpkt = spp * ep->samplesz;
    deprint("usb: %s: setmaxpkt: hz %ld poll %ld"
        " ntds %d %s speed -> spp %ld maxpkt %ld\n", s,
        ep->hz, ep->pollival, ep->ntds, spname[ep->dev->speed],
        spp, ep->maxpkt);
    if(ep->maxpkt > 1024){
        print("usb: %s: maxpkt %ld > 1024. truncating\n", s, ep->maxpkt);
        ep->maxpkt = 1024;
    }
}
@

<<function epctl(arm)>>=
/*
 * Many endpoint ctls. simply update the portable representation
 * of the endpoint. The actual controller driver will look
 * at them to setup the endpoints as dictated.
 */
static long
epctl(Ep *ep, Chan *c, void *a, long n)
{
    int i, l, mode, nb, tt;
    char *b, *s;
    Cmdbuf *cb;
    Cmdtab *ct;
    Ep *nep;
    Udev *d;
    static char *Info = "info ";

    d = ep->dev;

    cb = parsecmd(a, n);
    if(waserror()){
        free(cb);
        nexterror();
    }
    ct = lookupcmd(cb, epctls, nelem(epctls));
    if(ct == nil)
        error(Ebadctl);
    i = ct->index;
    if(i == CMnew || i == CMspeed || i == CMhub || i == CMpreset)
        if(ep != ep->ep0)
            error("allowed only on a setup endpoint");
    if(i != CMclrhalt && i != CMdetach && i != CMdebugep && i != CMname)
        if(ep != ep->ep0 && ep->inuse != 0)
            error("must configure before using");
    switch(i){
    case CMnew:
        deprint("usb epctl %s\n", cb->f[0]);
        nb = strtol(cb->f[1], nil, 0);
        if(nb < 0 || nb >= Ndeveps)
            error("bad endpoint number");
        tt = name2ttype(cb->f[2]);
        if(tt == Tnone)
            error("unknown endpoint type");
        mode = name2mode(cb->f[3]);
        if(mode < 0)
            error("unknown i/o mode");
        newdevep(ep, nb, tt, mode);
        break;
    case CMnewdev:
        deprint("usb epctl %s\n", cb->f[0]);
        if(ep != ep->ep0 || d->ishub == 0)
            error("not a hub setup endpoint");
        l = name2speed(cb->f[1]);
        if(l == Nospeed)
            error("speed must be full|low|high");
        nep = newdev(ep->hp, 0, 0);
        nep->dev->speed = l;
        if(nep->dev->speed  != Lowspeed)
            nep->maxpkt = 64;   /* assume full speed */
        nep->dev->hub = d->nb;
        nep->dev->port = atoi(cb->f[2]);
        /* next read request will read
         * the name for the new endpoint
         */
        l = sizeof(up->genbuf);
        snprint(up->genbuf, l, "ep%d.%d", nep->dev->nb, nep->nb);
        kstrdup(&c->aux, up->genbuf);
        break;
    case CMhub:
        deprint("usb epctl %s\n", cb->f[0]);
        d->ishub = 1;
        break;
    case CMspeed:
        l = name2speed(cb->f[1]);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l == Nospeed)
            error("speed must be full|low|high");
        qlock(ep->ep0);
        d->speed = l;
        qunlock(ep->ep0);
        break;
    case CMmaxpkt:
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l < 1 || l > 1024)
            error("maxpkt not in [1:1024]");
        qlock(ep);
        ep->maxpkt = l;
        qunlock(ep);
        break;
    case CMntds:
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l < 1 || l > 3)
            error("ntds not in [1:3]");
        qlock(ep);
        ep->ntds = l;
        qunlock(ep);
        break;
    case CMpollival:
        if(ep->ttype != Tintr && ep->ttype != Tiso)
            error("not an intr or iso endpoint");
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(ep->ttype == Tiso ||
           (ep->ttype == Tintr && ep->dev->speed == Highspeed)){
            if(l < 1 || l > 16)
                error("pollival power not in [1:16]");
            l = pow2(l-1);
        }else
            if(l < 1 || l > 255)
                error("pollival not in [1:255]");
        qlock(ep);
        ep->pollival = l;
        if(ep->ttype == Tiso)
            setmaxpkt(ep, "pollival");
        qunlock(ep);
        break;
    case CMsamplesz:
        if(ep->ttype != Tiso)
            error("not an iso endpoint");
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l <= 0 || l > 8)
            error("samplesz not in [1:8]");
        qlock(ep);
        ep->samplesz = l;
        setmaxpkt(ep, "samplesz");
        qunlock(ep);
        break;
    case CMhz:
        if(ep->ttype != Tiso)
            error("not an iso endpoint");
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l <= 0 || l > 100000)
            error("hz not in [1:100000]");
        qlock(ep);
        ep->hz = l;
        setmaxpkt(ep, "hz");
        qunlock(ep);
        break;
    case CMclrhalt:
        qlock(ep);
        deprint("usb epctl %s\n", cb->f[0]);
        ep->clrhalt = 1;
        qunlock(ep);
        break;
    case CMinfo:
        deprint("usb epctl %s\n", cb->f[0]);
        l = strlen(Info);
        s = a;
        if(n < l+2 || strncmp(Info, s, l) != 0)
            error(Ebadctl);
        if(n > 1024)
            n = 1024;
        b = smalloc(n);
        memmove(b, s+l, n-l);
        b[n-l] = 0;
        if(b[n-l-1] == '\n')
            b[n-l-1] = 0;
        qlock(ep);
        free(ep->info);
        ep->info = b;
        qunlock(ep);
        break;
    case CMaddress:
        deprint("usb epctl %s\n", cb->f[0]);
        ep->dev->state = Denabled;
        break;
    case CMdetach:
        if(ep->dev->isroot != 0)
            error("can't detach a root hub");
        deprint("usb epctl %s ep%d.%d\n",
            cb->f[0], ep->dev->nb, ep->nb);
        ep->dev->state = Ddetach;
        /* Release file system ref. for its endpoints */
        for(i = 0; i < nelem(ep->dev->eps); i++)
            putep(ep->dev->eps[i]);
        break;
    case CMdebugep:
        if(strcmp(cb->f[1], "on") == 0)
            ep->debug = 1;
        else if(strcmp(cb->f[1], "off") == 0)
            ep->debug = 0;
        else
            ep->debug = strtoul(cb->f[1], nil, 0);
        print("usb: ep%d.%d debug %d\n",
            ep->dev->nb, ep->nb, ep->debug);
        break;
    case CMname:
        deprint("usb epctl %s %s\n", cb->f[0], cb->f[1]);
        validname(cb->f[1], 0);
        kstrdup(&ep->name, cb->f[1]);
        break;
    case CMtmout:
        deprint("usb epctl %s\n", cb->f[0]);
        if(ep->ttype == Tiso || ep->ttype == Tctl)
            error("ctl ignored for this endpoint type");
        ep->tmout = strtoul(cb->f[1], nil, 0);
        if(ep->tmout != 0 && ep->tmout < Xfertmout)
            ep->tmout = Xfertmout;
        break;
    case CMpreset:
        deprint("usb epctl %s\n", cb->f[0]);
        if(ep->ttype != Tctl)
            error("not a control endpoint");
        if(ep->dev->state != Denabled)
            error("forbidden on devices not enabled");
        ep->dev->state = Dreset;
        break;
    default:
        panic("usb: unknown epctl %d", ct->index);
    }
    free(cb);
    poperror();
    return n;
}
@

<<function usbctl(arm)>>=
static long
usbctl(void *a, long n)
{
    Cmdtab *ct;
    Cmdbuf *cb;
    Ep *ep;
    int i;

    cb = parsecmd(a, n);
    if(waserror()){
        free(cb);
        nexterror();
    }
    ct = lookupcmd(cb, usbctls, nelem(usbctls));
    dprint("usb ctl %s\n", cb->f[0]);
    switch(ct->index){
    case CMdebug:
        if(strcmp(cb->f[1], "on") == 0)
            debug = 1;
        else if(strcmp(cb->f[1], "off") == 0)
            debug = 0;
        else
            debug = strtol(cb->f[1], nil, 0);
        print("usb: debug %d\n", debug);
        for(i = 0; i < epmax; i++)
            if((ep = getep(i)) != nil){
                ep->hp->debug(ep->hp, debug);
                putep(ep);
            }
        break;
    case CMdump:
        dumpeps();
        break;
    }
    free(cb);
    poperror();
    return n;
}
@

<<function ctlwrite(arm)>>=
static long
ctlwrite(Chan *c, void *a, long n)
{
    int q;
    Ep *ep;

    q = QID(c->qid);
    if(q == Qctl)
        return usbctl(a, n);

    ep = getep(qid2epidx(q));
    if(ep == nil)
        error(Eio);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    if(ep->dev->state == Ddetach)
        error(Edetach);
    if(isqtype(q, Qepctl) && c->aux != nil){
        /* Be sure we don't keep a cloned ep name */
        free(c->aux);
        c->aux = nil;
        error("read, not write, expected");
    }
    n = epctl(ep, c, a, n);
    putep(ep);
    poperror();
    return n;
}
@

<<function usbwrite(arm)>>=
static long
usbwrite(Chan *c, void *a, long n, vlong off)
{
    int nr, q;
    Ep *ep;

    if(c->qid.type == QTDIR)
        error(Eisdir);

    q = QID(c->qid);

    if(q == Qctl || isqtype(q, Qepctl))
        return ctlwrite(c, a, n);

    ep = getep(qid2epidx(q));
    if(ep == nil)
        error(Eio);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    if(ep->dev->state == Ddetach)
        error(Edetach);
    if(ep->mode == OREAD || ep->inuse == 0)
        error(Ebadusefd);

    switch(ep->ttype){
    case Tnone:
        error("endpoint not configured");
    case Tctl:
        nr = rhubwrite(ep, a, n);
        if(nr >= 0){
            n = nr;
            break;
        }
        /* else fall */
    default:
        ddeprint("\nusbwrite q %#x fid %d cnt %ld off %lld\n",q, c->fid, n, off);
        ep->hp->epwrite(ep, a, n);
    }
    putep(ep);
    poperror();
    return n;
}
@

<<function usbbread(arm)>>=
Block*
usbbread(Chan *c, long n, ulong offset)
{
    Block *bp;

    bp = allocb(n);
    if(bp == 0)
        error(Enomem);
    if(waserror()) {
        freeb(bp);
        nexterror();
    }
    bp->wp += usbread(c, bp->wp, n, offset);
    poperror();
    return bp;
}
@

<<function usbbwrite(arm)>>=
long
usbbwrite(Chan *c, Block *bp, ulong offset)
{
    long n;

    if(waserror()) {
        freeb(bp);
        nexterror();
    }
    n = usbwrite(c, bp->rp, BLEN(bp), offset);
    poperror();
    freeb(bp);

    return n;
}
@

<<function usbshutdown(arm)>>=
void
usbshutdown(void)
{
    Hci *hp;
    int i;

    for(i = 0; i < Nhcis; i++){
        hp = hcis[i];
        if(hp == nil)
            continue;
        if(hp->shutdown == nil)
            print("#u: no shutdown function for %s\n", hp->type);
        else
            hp->shutdown(hp);
    }
}
@

<<global usbdevtab(arm)>>=
Dev usbdevtab = {
    .dc = L'u',
    .name = "usb",

    .reset = usbreset,
    .init = usbinit,
    .shutdown = usbshutdown,
    .attach = usbattach,
    .walk = usbwalk,
    .stat = usbstat,
    .open = usbopen,
    .create = devcreate,
    .close = usbclose,
    .read = usbread,
    .bread = usbbread,
    .write = usbwrite,
    .bwrite = usbbwrite,
    .remove = devremove,
    .wstat = devwstat,
};
@


%-------------------------------------------------------------

<<buses/arm/devusb.c>>=
/*
 * USB device driver framework.
 *
 * This is in charge of providing access to actual HCIs
 * and providing I/O to the various endpoints of devices.
 * A separate user program (usbd) is in charge of
 * enumerating the bus, setting up endpoints and
 * starting devices (also user programs).
 *
 * The interface provided is a violation of the standard:
 * you're welcome.
 *
 * The interface consists of a root directory with several files
 * plus a directory (epN.M) with two files per endpoint.
 * A device is represented by its first endpoint, which
 * is a control endpoint automatically allocated for each device.
 * Device control endpoints may be used to create new endpoints.
 * Devices corresponding to hubs may also allocate new devices,
 * perhaps also hubs. Initially, a hub device is allocated for
 * each controller present, to represent its root hub. Those can
 * never be removed.
 *
 * All endpoints refer to the first endpoint (epN.0) of the device,
 * which keeps per-device information, and also to the HCI used
 * to reach them. Although all endpoints cache that information.
 *
 * epN.M/data files permit I/O and are considered DMEXCL.
 * epN.M/ctl files provide status info and accept control requests.
 *
 * Endpoints may be given file names to be listed also at #u,
 * for those drivers that have nothing to do after configuring the
 * device and its endpoints.
 *
 * Drivers for different controllers are kept at usb[oue]hci.c
 * It's likely we could factor out much from controllers into
 * a generic controller driver, the problem is that details
 * regarding how to handle toggles, tokens, Tds, etc. will
 * get in the way. Thus, code is probably easier the way it is.
 */
<<kernel basic includes>>

#include    "io.h"
#include    "../port/usb.h"

typedef struct Hcitype Hcitype;

<<enum _anon_ (buses/arm/devusb.c)(arm)>>

<<struct Hcitype(arm)>>

<<macro QID(arm)>>

<<global usbctls(arm)>>

<<global epctls(arm)>>

<<global usbdir(arm)>>

<<global usbmodename(arm)>>

<<global ttname(arm)>>

<<global spname(arm)>>

<<global debug(arm)>>
<<global hcitypes(arm)>>
<<global hcis(arm)>>
<<global epslck(arm)>>
<<global eps(arm)>>
<<global epmax(arm)>>
<<global usbidgen(arm)>>

<<function seprintdata(arm)>>

<<function name2speed(arm)>>

<<function name2ttype(arm)>>

<<function name2mode(arm)>>

<<function qid2epidx(arm)>>

<<function isqtype(arm)>>

<<function addhcitype(arm)>>

<<function seprintep(arm)>>

<<function epalloc(arm)>>

<<function getep(arm)>>

<<function putep(arm)>>

<<function dumpeps(arm)>>

<<function newusbid(arm)>>

<<function newdev(arm)>>

<<function newdevep(arm)>>

<<function epdataperm(arm)>>

<<function usbgen(arm)>>

<<function hciprobe(arm)>>

<<function usbreset(arm)>>

<<function usbinit(arm)>>

<<function usbattach(arm)>>

<<function usbwalk(arm)>>

<<function usbstat(arm)>>

<<function usbload(arm)>>

<<function usbopen(arm)>>

<<function epclose(arm)>>

<<function usbclose(arm)>>

<<function ctlread(arm)>>

<<function rhubread(arm)>>

<<function rhubwrite(arm)>>

<<function usbread(arm)>>

<<function pow2(arm)>>

<<function setmaxpkt(arm)>>

<<function epctl(arm)>>

<<function usbctl(arm)>>

<<function ctlwrite(arm)>>

<<function usbwrite(arm)>>

<<function usbbread(arm)>>

<<function usbbwrite(arm)>>

<<function usbshutdown(arm)>>

<<global usbdevtab(arm)>>
@


\subsection*{[[buses/arm/dma.c]]}


<<enum _anon_ (buses/arm/dma.c)(arm)>>=
enum {
    Nchan       = 7,        /* number of dma channels */
    Regsize     = 0x100,    /* size of regs for each chan */
    Cbalign     = 32,       /* control block byte alignment */
    Dbg     = 0,
    
    /* registers for each dma controller */
    Cs      = 0x00>>2,
    Conblkad    = 0x04>>2,
    Ti      = 0x08>>2,
    Sourcead    = 0x0c>>2,
    Destad      = 0x10>>2,
    Txfrlen     = 0x14>>2,
    Stride      = 0x18>>2,
    Nextconbk   = 0x1c>>2,
    Debug       = 0x20>>2,

    /* collective registers */
    Intstatus   = 0xfe0>>2,
    Enable      = 0xff0>>2,

    /* Cs */
    Reset       = 1<<31,
    Abort       = 1<<30,
    Error       = 1<<8,
    Waitwrite   = 1<<6,
    Waitdreq    = 1<<5,
    Paused      = 1<<4,
    Dreq        = 1<<3,
    Int     = 1<<2,
    End     = 1<<1,
    Active      = 1<<0,

    /* Ti */
    Permapshift= 16,
    Srcignore   = 1<<11,
    Srcdreq     = 1<<10,
    Srcwidth128 = 1<<9,
    Srcinc      = 1<<8,
    Destignore  = 1<<7,
    Destdreq    = 1<<6,
    Destwidth128    = 1<<5,
    Destinc     = 1<<4,
    Waitresp    = 1<<3,
    Tdmode      = 1<<1,
    Inten       = 1<<0,

    /* Debug */
    Lite        = 1<<28,
    Clrerrors   = 7<<0,
};
@

<<struct Ctlr(arm)>>=
struct Ctlr {
    u32int  *regs;
    Cb  *cb;
    Rendez  r;
    int dmadone;
};
@

<<struct Cb(arm)>>=
struct Cb {
    u32int  ti;
    u32int  sourcead;
    u32int  destad;
    u32int  txfrlen;
    u32int  stride;
    u32int  nextconbk;
    u32int  reserved[2];
};
@

<<global dma(arm)>>=
static Ctlr dma[Nchan];
@

<<global dmaregs(arm)>>=
static u32int *dmaregs = (u32int*)DMAREGS;
@

<<function dmaaddr(arm)>>=
uintptr
dmaaddr(void *va)
{
    return soc.busdram | (PTR2UINT(va) & ~KSEGM); // PADDR?
}
@

<<function dmaioaddr(arm)>>=
static uintptr
dmaioaddr(void *va)
{
    return soc.busio | (PTR2UINT(va) & ~VIRTIO);
}
@

<<function dump(arm)>>=
static void
dump(char *msg, uchar *p, int n)
{
    print("%s", msg);
    while(n-- > 0)
        print(" %2.2x", *p++);
    print("\n");
}
@

<<function dumpdregs(arm)>>=
static void
dumpdregs(char *msg, u32int *r)
{
    int i;

    print("%s: %#p =", msg, r);
    for(i = 0; i < 9; i++)
        print(" %8.8uX", r[i]);
    print("\n");
}
@

<<function dmadone(arm)>>=
static int
dmadone(void *a)
{
    return ((Ctlr*)a)->dmadone;
}
@

<<function dmainterrupt(arm)>>=
static void
dmainterrupt(Ureg*, void *a)
{
    Ctlr *ctlr;

    ctlr = a;
    ctlr->regs[Cs] = Int;
    ctlr->dmadone = 1;
    wakeup(&ctlr->r);
}
@


<<function dmastart(arm)>>=
void
dmastart(int chan, int dev, int dir, void *src, void *dst, int len)
{
    Ctlr *ctlr;
    Cb *cb;
    int ti;

    ctlr = &dma[chan];
    if(ctlr->regs == nil){
        ctlr->regs = (u32int*)(DMAREGS + chan*Regsize);
        ctlr->cb = xspanalloc(sizeof(Cb), Cbalign, 0);
        assert(ctlr->cb != nil);
        dmaregs[Enable] |= 1<<chan;
        ctlr->regs[Cs] = Reset;
        while(ctlr->regs[Cs] & Reset)
            ;
        arch_intrenable(IRQDMA(chan), dmainterrupt, ctlr, 0, "dma");
    }
    cb = ctlr->cb;
    ti = 0;
    switch(dir){
    case DmaD2M:
        cachedinvse(dst, len);
        ti = Srcdreq | Destinc;
        cb->sourcead = dmaioaddr(src);
        cb->destad = dmaaddr(dst);
        break;
    case DmaM2D:
        cachedwbse(src, len);
        ti = Destdreq | Srcinc;
        cb->sourcead = dmaaddr(src);
        cb->destad = dmaioaddr(dst);
        break;
    case DmaM2M:
        cachedwbse(src, len);
        cachedinvse(dst, len);
        ti = Srcinc | Destinc;
        cb->sourcead = dmaaddr(src);
        cb->destad = dmaaddr(dst);
        break;
    }
    cb->ti = ti | dev<<Permapshift | Inten;
    cb->txfrlen = len;
    cb->stride = 0;
    cb->nextconbk = 0;
    cachedwbse(cb, sizeof(Cb));
    ctlr->regs[Cs] = 0;
    arch_microdelay(1);
    ctlr->regs[Conblkad] = dmaaddr(cb);
    DBG print("dma start: %ux %ux %ux %ux %ux %ux\n",
        cb->ti, cb->sourcead, cb->destad, cb->txfrlen,
        cb->stride, cb->nextconbk);
    DBG print("intstatus %ux\n", dmaregs[Intstatus]);
    dmaregs[Intstatus] = 0;
    ctlr->regs[Cs] = Int;
    arch_microdelay(1);
    arch_coherence();
    DBG dumpdregs("before Active", ctlr->regs);
    ctlr->regs[Cs] = Active;
    DBG dumpdregs("after Active", ctlr->regs);
}
@

<<function dmawait(arm)>>=
int
dmawait(int chan)
{
    Ctlr *ctlr;
    u32int *r;
    int s;

    ctlr = &dma[chan];
    tsleep(&ctlr->r, dmadone, ctlr, 3000);
    ctlr->dmadone = 0;
    r = ctlr->regs;
    DBG dumpdregs("after sleep", r);
    s = r[Cs];
    if((s & (Active|End|Error)) != End){
        print("dma chan %d %s Cs %ux Debug %ux\n", chan,
            (s&End)? "error" : "timeout", s, r[Debug]);
        r[Cs] = Reset;
        r[Debug] = Clrerrors;
        return -1;
    }
    r[Cs] = Int|End;
    return 0;
}
@

%-------------------------------------------------------------

<<buses/arm/dma.c>>=
/*
 * bcm2835 dma controller
 *
 * simplest to use only channels 0-6
 *  channels 7-14 have reduced functionality
 *  channel 15 is at a weird address
 *  channels 0 and 15 have an "external 128 bit 8 word read FIFO"
 *    for memory to memory transfers
 *
 * Experiments show that only channels 2-5,11-12 work with mmc
 */
<<kernel basic includes>>

#include "io.h"

<<constant DMAREGS(arm)>>

#define DBG if(Dbg)

<<enum _anon_ (buses/arm/dma.c)(arm)>>

typedef struct Ctlr Ctlr;
typedef struct Cb Cb;

<<struct Ctlr(arm)>>

<<struct Cb(arm)>>

<<global dma(arm)>>
<<global dmaregs(arm)>>

<<function dmaaddr(arm)>>

<<function dmaioaddr(arm)>>

<<function dump(arm)>>

<<function dumpdregs(arm)>>

<<function dmadone(arm)>>

<<function dmainterrupt(arm)>>

<<function dmastart(arm)>>

<<function dmawait(arm)>>

@


\subsection*{[[buses/arm/dwcotg.h]]}

<<enum _anon_ (buses/arm/dwcotg.h)(arm)>>=
enum {
    Maxchans    = 16,   /* actual number of channels in ghwcfg2 */
};
@

<<struct Dwcregs(arm)>>=
struct Dwcregs {
    /* Core global registers 0x000-0x140 */
    Reg gotgctl;    /* OTG Control and Status */
    Reg gotgint;    /* OTG Interrupt */
    Reg gahbcfg;    /* Core AHB Configuration */
    Reg gusbcfg;    /* Core USB Configuration */
    Reg grstctl;    /* Core Reset */
    Reg gintsts;    /* Core Interrupt */
    Reg gintmsk;    /* Core Interrupt Mask */
    Reg grxstsr;    /* Receive Status Queue Read (RO) */
    Reg grxstsp;    /* Receive Status Queue Read & POP (RO) */
    Reg grxfsiz;    /* Receive FIFO Size */
    Reg gnptxfsiz;  /* Non Periodic Transmit FIFO Size */
    Reg gnptxsts;   /* Non Periodic Transmit FIFO/Queue Status (RO) */
    Reg gi2cctl;    /* I2C Access */
    Reg gpvndctl;   /* PHY Vendor Control */
    Reg ggpio;      /* General Purpose Input/Output */
    Reg guid;       /* User ID */
    Reg gsnpsid;    /* Synopsys ID (RO) */
    Reg ghwcfg1;    /* User HW Config1 (RO) (DEVICE) */
    Reg ghwcfg2;    /* User HW Config2 (RO) */
    Reg ghwcfg3;    /* User HW Config3 (RO) */
    Reg ghwcfg4;    /* User HW Config4 (RO)*/
    Reg glpmcfg;    /* Core LPM Configuration */
    Reg gpwrdn;     /* Global PowerDn */
    Reg gdfifocfg;  /* Global DFIFO SW Config (DEVICE?) */
    Reg adpctl;     /* ADP Control */
    Reg reserved0[39];
    Reg hptxfsiz;   /* Host Periodic Transmit FIFO Size */
    Reg dtxfsiz[15];    /* Device Periodic Transmit FIFOs (DEVICE) */
    char    pad0[0x400-0x140];

    /* Host global registers 0x400-0x420 */
    Reg hcfg;       /* Configuration */
    Reg hfir;       /* Frame Interval */
    Reg hfnum;      /* Frame Number / Frame Remaining (RO) */
    Reg reserved1;
    Reg hptxsts;    /* Periodic Transmit FIFO / Queue Status */
    Reg haint;      /* All Channels Interrupt */
    Reg haintmsk;   /* All Channels Interrupt Mask */
    Reg hflbaddr;   /* Frame List Base Address */
    char    pad1[0x440-0x420];

    /* Host port register 0x440 */
    Reg hport0;     /* Host Port 0 Control and Status */
    char    pad2[0x500-0x444];

    /* Host channel specific registers 0x500-0x700 */
    struct  Hostchan {
        Reg hcchar; /* Characteristic */
        Reg hcsplt; /* Split Control */
        Reg hcint;  /* Interrupt */
        Reg hcintmsk; /* Interrupt Mask */
        Reg hctsiz; /* Transfer Size */
        Reg hcdma;  /* DMA Address */
        Reg reserved;
        Reg hcdmab; /* DMA Buffer Address */
    } hchan[Maxchans];
    char    pad3[0xE00-0x700];

    /* Power & clock gating control register 0xE00 */
    Reg pcgcctl;
};
@


%-------------------------------------------------------------

<<buses/arm/dwcotg.h>>=
/*
 * USB host driver for BCM2835
 *  Synopsis DesignWare Core USB 2.0 OTG controller
 *
 * Device register definitions
 */

typedef unsigned int Reg;
typedef struct Dwcregs Dwcregs;
typedef struct Hostchan Hostchan;

<<enum _anon_ (buses/arm/dwcotg.h)(arm)>>

<<struct Dwcregs(arm)>>

enum {
    /* gotgctl */
    Sesreqscs   = 1<<0,
    Sesreq      = 1<<1,
    Vbvalidoven = 1<<2,
    Vbvalidovval    = 1<<3,
    Avalidoven  = 1<<4,
    Avalidovval = 1<<5,
    Bvalidoven  = 1<<6,
    Bvalidovval = 1<<7,
    Hstnegscs   = 1<<8,
    Hnpreq      = 1<<9,
    Hstsethnpen = 1<<10,
    Devhnpen    = 1<<11,
    Conidsts    = 1<<16,
    Dbnctime    = 1<<17,
    Asesvld     = 1<<18,
    Bsesvld     = 1<<19,
    Otgver      = 1<<20,
    Multvalidbc = 0x1F<<22,
    Chirpen     = 1<<27,

    /* gotgint */
    Sesenddet   = 1<<2,
    Sesreqsucstschng= 1<<8,
    Hstnegsucstschng= 1<<9,
    Hstnegdet   = 1<<17,
    Adevtoutchng    = 1<<18,
    Debdone     = 1<<19,
    Mvic        = 1<<20,

    /* gahbcfg */
    Glblintrmsk = 1<<0,
    /* bits 1:4 redefined for BCM2835 */
    Axiburstlen = 0x3<<1,
        BURST1      = 3<<1,
        BURST2      = 2<<1,
        BURST3      = 1<<1,
        BURST4      = 0<<1,
    Axiwaitwrites   = 1<<4,
    Dmaenable   = 1<<5,
    Nptxfemplvl = 1<<7,
        NPTX_HALFEMPTY  = 0<<7,
        NPTX_EMPTY  = 1<<7,
    Ptxfemplvl  = 1<<8,
        PTX_HALFEMPTY   = 0<<8,
        PTX_EMPTY   = 1<<8,
    Remmemsupp  = 1<<21,
    Notialldmawrit  = 1<<22,
    Ahbsingle   = 1<<23,

    /* gusbcfg */
    Toutcal     = 0x7<<0,
    Phyif       = 1<<3,
    Ulpi_utmi_sel   = 1<<4,
    Fsintf      = 1<<5,
        FsUnidir    = 0<<5,
        FsBidir     = 1<<5,
    Physel      = 1<<6,
        PhyHighspeed    = 0<<6,
        PhyFullspeed    = 1<<6,
    Ddrsel      = 1<<7,
    Srpcap      = 1<<8,
    Hnpcap      = 1<<9,
    Usbtrdtim   = 0xf<<10,
        OUsbtrdtim      = 10,
    Phylpwrclksel   = 1<<15,
    Otgutmifssel    = 1<<16,
    Ulpi_fsls   = 1<<17,
    Ulpi_auto_res   = 1<<18,
    Ulpi_clk_sus_m  = 1<<19,
    Ulpi_ext_vbus_drv= 1<<20,
    Ulpi_int_vbus_indicator= 1<<21,
    Term_sel_dl_pulse= 1<<22,
    Indicator_complement= 1<<23,
    Indicator_pass_through= 1<<24,
    Ulpi_int_prot_dis= 1<<25,
    Ic_usb_cap  = 1<<26,
    Ic_traffic_pull_remove= 1<<27,
    Tx_end_delay    = 1<<28,
    Force_host_mode = 1<<29,
    Force_dev_mode  = 1<<30,

    /* grstctl */
    Csftrst     = 1<<0,
    Hsftrst     = 1<<1,
    Hstfrm      = 1<<2,
    Intknqflsh  = 1<<3,
    Rxfflsh     = 1<<4,
    Txfflsh     = 1<<5,
    Txfnum      = 0x1f<<6,
        TXF_ALL     = 0x10<<6,
    Dmareq      = 1<<30,
    Ahbidle     = 1<<31,

    /* gintsts, gintmsk */
    Curmode     = 1<<0,
        HOSTMODE    = 1<<0,
        DEVMODE     = 0<<0,
    Modemismatch    = 1<<1,
    Otgintr     = 1<<2,
    Sofintr     = 1<<3,
    Rxstsqlvl   = 1<<4,
    Nptxfempty  = 1<<5,
    Ginnakeff   = 1<<6,
    Goutnakeff  = 1<<7,
    Ulpickint   = 1<<8,
    I2cintr     = 1<<9,
    Erlysuspend = 1<<10,
    Usbsuspend  = 1<<11,
    Usbreset    = 1<<12,
    Enumdone    = 1<<13,
    Isooutdrop  = 1<<14,
    Eopframe    = 1<<15,
    Restoredone = 1<<16,
    Epmismatch  = 1<<17,
    Inepintr    = 1<<18,
    Outepintr   = 1<<19,
    Incomplisoin    = 1<<20,
    Incomplisoout   = 1<<21,
    Fetsusp     = 1<<22,
    Resetdet    = 1<<23,
    Portintr    = 1<<24,
    Hcintr      = 1<<25,
    Ptxfempty   = 1<<26,
    Lpmtranrcvd = 1<<27,
    Conidstschng    = 1<<28,
    Disconnect  = 1<<29,
    Sessreqintr = 1<<30,
    Wkupintr    = 1<<31,

    /* grxsts[rp] */
    Chnum       = 0xf<<0,
    Bcnt        = 0x7ff<<4,
    Dpid        = 0x3<<15,
    Pktsts      = 0xf<<17,
        PKTSTS_IN       = 2<<17,
        PKTSTS_IN_XFER_COMP = 3<<17,
        PKTSTS_DATA_TOGGLE_ERR  = 5<<17,
        PKTSTS_CH_HALTED    = 7<<17,

    /* hptxfsiz, gnptxfsiz */
    Startaddr   = 0xffff<<0,
    Depth       = 0xffff<<16,
        ODepth      = 16,

    /* gnptxsts */
    Nptxfspcavail   = 0xffff<<0,
    Nptxqspcavail   = 0xff<<16,
    Nptxqtop_terminate= 1<<24,
    Nptxqtop_token  = 0x3<<25,
    Nptxqtop_chnep  = 0xf<<27,

    /* gpvndctl */
    Regdata     = 0xff<<0,
    Vctrl       = 0xff<<8,
    Regaddr16_21    = 0x3f<<16,
    Regwr       = 1<<22,
    Newregreq   = 1<<25,
    Vstsbsy     = 1<<26,
    Vstsdone    = 1<<27,
    Disulpidrvr = 1<<31,

    /* ggpio */
    Gpi     = 0xffff<<0,
    Gpo     = 0xffff<<16,

    /* ghwcfg2 */
    Op_mode     = 0x7<<0,
        HNP_SRP_CAPABLE_OTG = 0<<0,
        SRP_ONLY_CAPABLE_OTG    = 1<<0,
        NO_HNP_SRP_CAPABLE  = 2<<0,
        SRP_CAPABLE_DEVICE  = 3<<0,
        NO_SRP_CAPABLE_DEVICE   = 4<<0,
        SRP_CAPABLE_HOST    = 5<<0,
        NO_SRP_CAPABLE_HOST = 6<<0,
    Architecture    = 0x3<<3,
        SLAVE_ONLY      = 0<<3,
        EXT_DMA         = 1<<3,
        INT_DMA         = 2<<3,
    Point2point = 1<<5,
    Hs_phy_type = 0x3<<6,
        PHY_NOT_SUPPORTED   = 0<<6,
        PHY_UTMI        = 1<<6,
        PHY_ULPI        = 2<<6,
        PHY_UTMI_ULPI       = 3<<6,
    Fs_phy_type = 0x3<<8,
    Num_dev_ep  = 0xf<<10,
    Num_host_chan   = 0xf<<14,
        ONum_host_chan      = 14,
    Perio_ep_supported= 1<<18,
    Dynamic_fifo    = 1<<19,
    Nonperio_tx_q_depth= 0x3<<22,
    Host_perio_tx_q_depth= 0x3<<24,
    Dev_token_q_depth= 0x1f<<26,
    Otg_enable_ic_usb= 1<<31,

    /* ghwcfg3 */
    Xfer_size_cntr_width    = 0xf<<0,
    Packet_size_cntr_width  = 0x7<<4,
    Otg_func        = 1<<7,
    I2c         = 1<<8,
    Vendor_ctrl_if      = 1<<9,
    Optional_features   = 1<<10,
    Synch_reset_type    = 1<<11,
    Adp_supp        = 1<<12,
    Otg_enable_hsic     = 1<<13,
    Bc_support      = 1<<14,
    Otg_lpm_en      = 1<<15,
    Dfifo_depth     = 0xffff<<16,
        ODfifo_depth        = 16,

    /* ghwcfg4 */
    Num_dev_perio_in_ep = 0xf<<0,
    Power_optimiz       = 1<<4,
    Min_ahb_freq        = 1<<5,
    Hiber           = 1<<6,
    Xhiber          = 1<<7,
    Utmi_phy_data_width = 0x3<<14,
    Num_dev_mode_ctrl_ep    = 0xf<<16,
    Iddig_filt_en       = 1<<20,
    Vbus_valid_filt_en  = 1<<21,
    A_valid_filt_en     = 1<<22,
    B_valid_filt_en     = 1<<23,
    Session_end_filt_en = 1<<24,
    Ded_fifo_en     = 1<<25,
    Num_in_eps      = 0xf<<26,
    Desc_dma        = 1<<30,
    Desc_dma_dyn        = 1<<31,

    /* glpmcfg */
    Lpm_cap_en  = 1<<0,
    Appl_resp   = 1<<1,
    Hird        = 0xf<<2,
    Rem_wkup_en = 1<<6,
    En_utmi_sleep   = 1<<7,
    Hird_thres  = 0x1f<<8,
    Lpm_resp    = 0x3<<13,
    Prt_sleep_sts   = 1<<15,
    Sleep_state_resumeok= 1<<16,
    Lpm_chan_index  = 0xf<<17,
    Retry_count = 0x7<<21,
    Send_lpm    = 1<<24,
    Retry_count_sts = 0x7<<25,
    Hsic_connect    = 1<<30,
    Inv_sel_hsic    = 1<<31,

    /* gpwrdn */
    Pmuintsel   = 1<<0,
    Pmuactv     = 1<<1,
    Restore     = 1<<2,
    Pwrdnclmp   = 1<<3,
    Pwrdnrstn   = 1<<4,
    Pwrdnswtch  = 1<<5,
    Dis_vbus    = 1<<6,
    Lnstschng   = 1<<7,
    Lnstchng_msk    = 1<<8,
    Rst_det     = 1<<9,
    Rst_det_msk = 1<<10,
    Disconn_det = 1<<11,
    Disconn_det_msk = 1<<12,
    Connect_det = 1<<13,
    Connect_det_msk = 1<<14,
    Srp_det     = 1<<15,
    Srp_det_msk = 1<<16,
    Sts_chngint = 1<<17,
    Sts_chngint_msk = 1<<18,
    Linestate   = 0x3<<19,
    Idsts       = 1<<21,
    Bsessvld    = 1<<22,
    Adp_int     = 1<<23,
    Mult_val_id_bc  = 0x1f<<24,

    /* gdfifocfg */
    Gdfifocfg   = 0xffff<<0,
    Epinfobase  = 0xffff<<16,

    /* adpctl */
    Prb_dschg   = 0x3<<0,
    Prb_delta   = 0x3<<2,
    Prb_per     = 0x3<<4,
    Rtim        = 0x7ff<<6,
    Enaprb      = 1<<17,
    Enasns      = 1<<18,
    Adpres      = 1<<19,
    Adpen       = 1<<20,
    Adp_prb_int = 1<<21,
    Adp_sns_int = 1<<22,
    Adp_tmout_int   = 1<<23,
    Adp_prb_int_msk = 1<<24,
    Adp_sns_int_msk = 1<<25,
    Adp_tmout_int_msk= 1<<26,
    Ar      = 0x3<<27,

    /* hcfg */
    Fslspclksel = 0x3<<0,
        HCFG_30_60_MHZ  = 0<<0,
        HCFG_48_MHZ = 1<<0,
        HCFG_6_MHZ  = 2<<0,
    Fslssupp    = 1<<2,
    Ena32khzs   = 1<<7,
    Resvalid    = 0xff<<8,
    Descdma     = 1<<23,
    Frlisten    = 0x3<<24,
    Modechtimen = 1<<31,

    /* hfir */
    Frint       = 0xffff<<0,
    Hfirrldctrl = 1<<16,

    /* hfnum */
    Frnum       = 0xffff<<0,
        MAX_FRNUM   = 0x3FFF<<0,
    Frrem       = 0xffff<<16,

    /* hptxsts */
    Ptxfspcavail    = 0xffff<<0,
    Ptxqspcavail    = 0xff<<16,
    Ptxqtop_terminate= 1<<24,
    Ptxqtop_token   = 0x3<<25,
    Ptxqtop_chnum   = 0xf<<27,
    Ptxqtop_odd = 1<<31,

    /* haint, haintmsk */
#define CHANINT(n)  (1<<(n))

    /* hport0 */
    Prtconnsts  = 1<<0,     /* connect status (RO) */
    Prtconndet  = 1<<1,     /* connect detected R/W1C) */
    Prtena      = 1<<2,     /* enable (R/W1C) */
    Prtenchng   = 1<<3,     /* enable/disable change (R/W1C) */
    Prtovrcurract   = 1<<4,     /* overcurrent active (RO) */
    Prtovrcurrchng  = 1<<5,     /* overcurrent change (R/W1C) */
    Prtres      = 1<<6,     /* resume */
    Prtsusp     = 1<<7,     /* suspend */
    Prtrst      = 1<<8,     /* reset */
    Prtlnsts    = 0x3<<10,  /* line state {D+,D-} (RO) */
    Prtpwr      = 1<<12,    /* power on */
    Prttstctl   = 0xf<<13,  /* test */
    Prtspd      = 0x3<<17,  /* speed (RO) */
        HIGHSPEED   = 0<<17,
        FULLSPEED   = 1<<17,
        LOWSPEED    = 2<<17,

    /* hcchar */
    Mps     = 0x7ff<<0, /* endpoint maximum packet size */
    Epnum       = 0xf<<11,  /* endpoint number */
        OEpnum      = 11,
    Epdir       = 1<<15,    /* endpoint direction */
        Epout       = 0<<15,
        Epin        = 1<<15,
    Lspddev     = 1<<17,    /* device is lowspeed */
    Eptype      = 0x3<<18,  /* endpoint type */
        Epctl       = 0<<18,
        Episo       = 1<<18,
        Epbulk      = 2<<18,
        Epintr      = 3<<18,
    Multicnt    = 0x3<<20,  /* transactions per μframe */
                    /* or retries per periodic split */
        OMulticnt   = 20,
    Devaddr     = 0x7f<<22, /* device address */
        ODevaddr    = 22,
    Oddfrm      = 1<<29,    /* xfer in odd frame (iso/interrupt) */
    Chdis       = 1<<30,    /* channel disable (write 1 only) */
    Chen        = 1<<31,    /* channel enable (write 1 only) */

    /* hcsplt */
    Prtaddr     = 0x7f<<0,  /* port address of recipient */
                    /* transaction translator */
    Hubaddr     = 0x7f<<7,  /* dev address of transaction */
                    /* translator's hub */
        OHubaddr    = 7,
    Xactpos     = 0x3<<14,  /* payload's position within transaction */
        POS_MID     = 0<<14,        
        POS_END     = 1<<14,
        POS_BEGIN   = 2<<14,
        POS_ALL     = 3<<14, /* all of data (<= 188 bytes) */
    Compsplt    = 1<<16,    /* do complete split */
    Spltena     = 1<<31,    /* channel enabled to do splits */

    /* hcint, hcintmsk */
    Xfercomp    = 1<<0,     /* transfer completed without error */
    Chhltd      = 1<<1,     /* channel halted */
    Ahberr      = 1<<2,     /* AHB dma error */
    Stall       = 1<<3,
    Nak     = 1<<4,
    Ack     = 1<<5,
    Nyet        = 1<<6,
    Xacterr     = 1<<7, /* transaction error (crc, t/o, bit stuff, eop) */
    Bblerr      = 1<<8,
    Frmovrun    = 1<<9,
    Datatglerr  = 1<<10,
    Bna     = 1<<11,
    Xcs_xact    = 1<<12,
    Frm_list_roll   = 1<<13,

    /* hctsiz */
    Xfersize    = 0x7ffff<<0,   /* expected total bytes */
    Pktcnt      = 0x3ff<<19,    /* expected number of packets */
        OPktcnt     = 19,
    Pid     = 0x3<<29,  /* packet id for initial transaction */
        DATA0       = 0<<29,
        DATA1       = 2<<29,    /* sic */
        DATA2       = 1<<29,    /* sic */
        MDATA       = 3<<29,    /* (non-ctl ep) */
        SETUP       = 3<<29,    /* (ctl ep) */
    Dopng       = 1<<31,    /* do PING protocol */

    /* pcgcctl */
    Stoppclk        = 1<<0,
    Gatehclk        = 1<<1,
    Pwrclmp         = 1<<2,
    Rstpdwnmodule       = 1<<3,
    Enbl_sleep_gating   = 1<<5,
    Phy_in_sleep        = 1<<6,
    Deep_sleep      = 1<<7,
    Resetaftsusp        = 1<<8,
    Restoremode     = 1<<9,
    Enbl_extnd_hiber    = 1<<10,
    Extnd_hiber_pwrclmp = 1<<11,
    Extnd_hiber_switch  = 1<<12,
    Ess_reg_restored    = 1<<13,
    Prt_clk_sel     = 0x3<<14,
    Port_power      = 1<<16,
    Max_xcvrselect      = 0x3<<17,
    Max_termsel     = 1<<19,
    Mac_dev_addr        = 0x7f<<20,
    P2hd_dev_enum_spd   = 0x3<<27,
    P2hd_prt_spd        = 0x3<<29,
    If_dev_mode     = 1<<31,
};
@
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>

\subsection*{[[buses/arm/uartmini.c]]}


<<constant OkLed(arm)>>=
#define OkLed       16
@

<<constant TxPin(arm)>>=
#define TxPin       14
@

<<constant RxPin(arm)>>=
#define RxPin       15
@

<<enum _anon_ (buses/arm/uartmini.c)(arm)>>=
/* GPIO regs */
enum {
    Fsel0   = 0x00>>2,
        FuncMask= 0x7,
        Input   = 0x0,
        Output  = 0x1,
        Alt0    = 0x4,
        Alt1    = 0x5,
        Alt2    = 0x6,
        Alt3    = 0x7,
        Alt4    = 0x3,
        Alt5    = 0x2,
    Set0    = 0x1c>>2,
    Clr0    = 0x28>>2,
    Lev0    = 0x34>>2,
    PUD = 0x94>>2,
        Off = 0x0,
        Pulldown= 0x1,
        Pullup  = 0x2,
    PUDclk0 = 0x98>>2,
    PUDclk1 = 0x9c>>2,
};
@

<<enum _anon_ (buses/arm/uartmini.c)2(arm)>>=
/* AUX regs */
enum {
    Irq = 0x00>>2,
        UartIrq = 1<<0,
    Enables = 0x04>>2,
        UartEn  = 1<<0,
    MuIo    = 0x40>>2,
    MuIer   = 0x44>>2,
        RxIen   = 1<<0,
        TxIen   = 1<<1,
    MuIir   = 0x48>>2,
    MuLcr   = 0x4c>>2,
        Bitsmask= 3<<0,
        Bits7   = 2<<0,
        Bits8   = 3<<0,
    MuMcr   = 0x50>>2,
        RtsN    = 1<<1,
    MuLsr   = 0x54>>2,
        TxDone  = 1<<6,
        TxRdy   = 1<<5,
        RxRdy   = 1<<0,
    MuCntl  = 0x60>>2,
        CtsFlow = 1<<3,
        TxEn    = 1<<1,
        RxEn    = 1<<0,
    MuBaud  = 0x68>>2,
};
@

<<global miniuart(arm)>>=
static Uart miniuart = {
    .regs   = (u32int*)AUXREGS,
    .name   = "uart0",
    .freq   = 250000000,
    .phys   = &miniphysuart,
};
@

<<function gpiosel(arm)>>=
void
gpiosel(uint pin, int func)
{   
    u32int *gp, *fsel;
    int off;

    gp = (u32int*)GPIOREGS;
    fsel = &gp[Fsel0 + pin/10];
    off = (pin % 10) * 3;
    *fsel = (*fsel & ~(FuncMask<<off)) | func<<off;
}
@

<<function gpiopull(arm)>>=
static void
gpiopull(uint pin, int func)
{
    u32int *gp, *reg;
    u32int mask;

    gp = (u32int*)GPIOREGS;
    reg = &gp[PUDclk0 + pin/32];
    mask = 1 << (pin % 32);
    gp[PUD] = func;
    arch_microdelay(1);
    *reg = mask;
    arch_microdelay(1);
    *reg = 0;
}
@

<<function gpiopulloff(arm)>>=
void
gpiopulloff(uint pin)
{
    gpiopull(pin, Off);
}
@

<<function gpiopullup(arm)>>=
void
gpiopullup(uint pin)
{
    gpiopull(pin, Pullup);
}
@

<<function gpiopulldown(arm)>>=
void
gpiopulldown(uint pin)
{
    gpiopull(pin, Pulldown);
}
@

<<function gpioout(arm)>>=
void
gpioout(uint pin, int set)
{
    u32int *gp;
    int v;

    gp = (u32int*)GPIOREGS;
    v = set? Set0 : Clr0;
    gp[v + pin/32] = 1 << (pin % 32);
}
@

<<function gpioin(arm)>>=
int
gpioin(uint pin)
{
    u32int *gp;

    gp = (u32int*)GPIOREGS;
    return (gp[Lev0 + pin/32] & (1 << (pin % 32))) != 0;
}
@

<<function interrupt(arm)>>=
static void
interrupt(Ureg*, void *arg)
{
    Uart *uart;
    u32int *ap;

    uart = arg;
    ap = (u32int*)uart->regs;

    arch_coherence();
    if(0 && (ap[Irq] & UartIrq) == 0)
        return;
    if(ap[MuLsr] & TxRdy)
        uartkick(uart);
    if(ap[MuLsr] & RxRdy){
        if(uart->console){
            if(uart->opens == 1)
                uart->putc = kbdcr2nl;
            else
                uart->putc = nil;
        }
        do{
            uartrecv(uart, ap[MuIo] & 0xFF);
        }while(ap[MuLsr] & RxRdy);
    }
    arch_coherence();
}
@

<<function pnp(arm)>>=
static Uart*
pnp(void)
{
    Uart *uart;

    uart = &miniuart;
    if(uart->console == 0)
        kbdq = qopen(8*1024, 0, nil, nil);
    return uart;
}
@

<<function enable(arm)>>=
static void
enable(Uart *uart, int ie)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    arch_delay(10);
    gpiosel(TxPin, Alt5);
    gpiosel(RxPin, Alt5);
    gpiopulloff(TxPin);
    gpiopulloff(RxPin);
    ap[Enables] |= UartEn;
    ap[MuIir] = 6;
    ap[MuLcr] = Bits8;
    ap[MuCntl] = TxEn|RxEn;
    ap[MuBaud] = uart->freq/(115200*8) - 1;
    if(ie){
        arch_intrenable(IRQaux, interrupt, uart, 0, "uart");
        ap[MuIer] = RxIen|TxIen;
    }else
        ap[MuIer] = 0;
}
@

<<function disable(arm)>>=
static void
disable(Uart *uart)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    ap[MuCntl] = 0;
    ap[MuIer] = 0;
}
@

<<function kick(arm)>>=
static void
kick(Uart *uart)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    if(uart->blocked)
        return;
    arch_coherence();
    while(ap[MuLsr] & TxRdy){
        if(uart->op >= uart->oe && uartstageoutput(uart) == 0)
            break;
        ap[MuIo] = *(uart->op++);
    }
    if(ap[MuLsr] & TxDone)
        ap[MuIer] &= ~TxIen;
    else
        ap[MuIer] |= TxIen;
    arch_coherence();
}
@

<<function dobreak(arm)>>=
/* TODO */
static void
dobreak(Uart *uart, int ms)
{
    USED(uart, ms);
}
@

<<function baud(arm)>>=
static int
baud(Uart *uart, int n)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    if(uart->freq == 0 || n <= 0)
        return -1;
    ap[MuBaud] = (uart->freq + 4*n - 1) / (8 * n) - 1;
    uart->baud = n;
    return 0;
}
@

<<function bits(arm)>>=
static int
bits(Uart *uart, int n)
{
    u32int *ap;
    int set;

    ap = (u32int*)uart->regs;
    switch(n){
    case 7:
        set = Bits7;
        break;
    case 8:
        set = Bits8;
        break;
    default:
        return -1;
    }
    ap[MuLcr] = (ap[MuLcr] & ~Bitsmask) | set;
    uart->bits = n;
    return 0;
}
@

<<function stop(arm)>>=
static int
stop(Uart *uart, int n)
{
    if(n != 1)
        return -1;
    uart->stop = n;
    return 0;
}
@

<<function parity(arm)>>=
static int
parity(Uart *uart, int n)
{
    if(n != 'n')
        return -1;
    uart->parity = n;
    return 0;
}
@

<<function modemctl(arm)>>=
/*
 * cts/rts flow control
 *   need to bring signals to gpio pins before enabling this
 */

static void
modemctl(Uart *uart, int on)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    if(on)
        ap[MuCntl] |= CtsFlow;
    else
        ap[MuCntl] &= ~CtsFlow;
    uart->modem = on;
}
@

<<function rts(arm)>>=
static void
rts(Uart *uart, int on)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    if(on)
        ap[MuMcr] &= ~RtsN;
    else
        ap[MuMcr] |= RtsN;
}
@

<<function status(arm)>>=
static long
status(Uart *uart, void *buf, long n, long offset)
{
    char *p;

    p = malloc(READSTR);
    if(p == nil)
        error(Enomem);
    snprint(p, READSTR,
        "b%d\n"
        "dev(%d) type(%d) framing(%d) overruns(%d) "
        "berr(%d) serr(%d)\n",

        uart->baud,
        uart->dev,
        uart->type,
        uart->ferr,
        uart->oerr,
        uart->berr,
        uart->serr
    );
    n = readstr(offset, buf, n, p);
    free(p);

    return n;
}
@

<<function donothing(arm)>>=
static void
donothing(Uart*, int)
{
}
@

<<function putc(arm)>>=
void
putc(Uart*, int c)
{
    u32int *ap;

    ap = (u32int*)AUXREGS;
    while((ap[MuLsr] & TxRdy) == 0)
        ;
    ap[MuIo] = c;
    while((ap[MuLsr] & TxRdy) == 0)
        ;
}
@

<<function getc(arm)>>=
int
getc(Uart*)
{
    u32int *ap;

    ap = (u32int*)AUXREGS;
    while((ap[MuLsr] & RxRdy) == 0)
        ;
    return ap[MuIo] & 0xFF;
}
@

<<function uartconsinit(arm)>>=
void
uartconsinit(void)
{
    Uart *uart;
    int n;
    char *p, *cmd;

    if((p = getconf("console")) == nil)
        return;
    n = strtoul(p, &cmd, 0);
    if(p == cmd)
        return;
    switch(n){
    default:
        return;
    case 0:
        uart = &miniuart;
        break;
    }

    if(!uart->enabled)
        (*uart->phys->enable)(uart, 0);
    uartctl(uart, "b9600 l8 pn s1");
    if(*cmd != '\0')
        uartctl(uart, cmd);

    consuart = uart;
    uart->console = 1;
}
@

<<global miniphysuart(arm)>>=
PhysUart miniphysuart = {
    .name       = "miniuart",
    .pnp        = pnp,
    .enable     = enable,
    .disable    = disable,
    .kick       = kick,
    .dobreak    = dobreak,
    .baud       = baud,
    .bits       = bits,
    .stop       = stop,
    .parity     = parity,
    .modemctl   = donothing,
    .rts        = rts,
    .dtr        = donothing,
    .status     = status,
    .fifo       = donothing,
    .getc       = getc,
    .putc       = putc,
};
@

<<function okay(arm)>>=
void
okay(int on)
{
    static int first;
    static int okled, polarity;
    char *p;

    if(!first++){
        p = getconf("bcm2709.disk_led_gpio");
        if(p == nil)
            p = getconf("bcm2708.disk_led_gpio");
        if(p != nil)
            okled = strtol(p, 0, 0);
        else
            okled = OkLed;
        p = getconf("bcm2709.disk_led_active_low");
        if(p == nil)
            p = getconf("bcm2708.disk_led_active_low");
        polarity = (p == nil || *p == '1');
        gpiosel(okled, Output);
    }
    gpioout(okled, on^polarity);
}
@


%-------------------------------------------------------------

<<buses/arm/uartmini.c>>=
/*
 * bcm2835 mini uart (UART1)
 */
<<kernel basic includes>>

#include "io.h"

<<constant GPIOREGS(arm)>>
<<constant AUXREGS(arm)>>
<<constant OkLed(arm)>>
<<constant TxPin(arm)>>
<<constant RxPin(arm)>>

<<enum _anon_ (buses/arm/uartmini.c)(arm)>>

<<enum _anon_ (buses/arm/uartmini.c)2(arm)>>

extern PhysUart miniphysuart;

<<global miniuart(arm)>>

<<function gpiosel(arm)>>

<<function gpiopull(arm)>>

<<function gpiopulloff(arm)>>

<<function gpiopullup(arm)>>

<<function gpiopulldown(arm)>>

<<function gpioout(arm)>>

<<function gpioin(arm)>>

<<function interrupt(arm)>>

<<function pnp(arm)>>

<<function enable(arm)>>

<<function disable(arm)>>

<<function kick(arm)>>

<<function dobreak(arm)>>

<<function baud(arm)>>

<<function bits(arm)>>

<<function stop(arm)>>

<<function parity(arm)>>

<<function modemctl(arm)>>

<<function rts(arm)>>

<<function status(arm)>>

<<function donothing(arm)>>

<<function putc(arm)>>

<<function getc(arm)>>

<<function uartconsinit(arm)>>

<<global miniphysuart(arm)>>

<<function okay(arm)>>
@


\subsection*{[[buses/arm/usbdwc.c]]}


<<enum _anon_ (buses/arm/usbdwc.c)(arm)>>=
enum
{
    Enabledelay = 50,
    Resetdelay  = 10,
    ResetdelayHS    = 50,

    Read        = 0,
    Write       = 1,
};
@

<<struct Ctlr (buses/arm/usbdwc.c)(arm)>>=
struct Ctlr {
    Lock;
    Dwcregs *regs;      /* controller registers */
    int nchan;      /* number of host channels */
    ulong   chanbusy;   /* bitmap of in-use channels */
    QLock   chanlock;   /* serialise access to chanbusy */
    QLock   split;      /* serialise split transactions */
    int splitretry; /* count retries of Nyet */
    int sofchan;    /* bitmap of channels waiting for sof */
    int wakechan;   /* bitmap of channels to wakeup after fiq */
    int debugchan;  /* bitmap of channels for interrupt debug */
    Rendez  *chanintr;  /* sleep till interrupt on channel N */
};
@

<<struct Epio(arm)>>=
struct Epio {
    QLock;
    Block   *cb;
    ulong   lastpoll;
};
@

<<global dwc(arm)>>=
static Ctlr dwc;
@

<<global debug (buses/arm/usbdwc.c)(arm)>>=
static int debug;
@

<<global Ebadlen(arm)>>=
static char Ebadlen[] = "bad usb request length";
@

<<function filock(arm)>>=
static void
filock(Lock *l)
{
    int x;

    x = splfhi();
    ilock(l);
    l->sr = x;
}
@

<<function fiunlock(arm)>>=
static void
fiunlock(Lock *l)
{
    iunlock(l);
}
@

<<function chanalloc(arm)>>=
static Hostchan*
chanalloc(Ep *ep)
{
    Ctlr *ctlr;
    int bitmap, i;

    ctlr = ep->hp->aux;
    qlock(&ctlr->chanlock);
    bitmap = ctlr->chanbusy;
    for(i = 0; i < ctlr->nchan; i++)
        if((bitmap & (1<<i)) == 0){
            ctlr->chanbusy = bitmap | 1<<i;
            qunlock(&ctlr->chanlock);
            return &ctlr->regs->hchan[i];
        }
    qunlock(&ctlr->chanlock);
    panic("miller is a lazy git");
    return nil;
}
@

<<function chanrelease(arm)>>=
static void
chanrelease(Ep *ep, Hostchan *chan)
{
    Ctlr *ctlr;
    int i;

    ctlr = ep->hp->aux;
    i = chan - ctlr->regs->hchan;
    qlock(&ctlr->chanlock);
    ctlr->chanbusy &= ~(1<<i);
    qunlock(&ctlr->chanlock);
}
@

<<function chansetup(arm)>>=
static void
chansetup(Hostchan *hc, Ep *ep)
{
    int hcc;
    Ctlr *ctlr = ep->hp->aux;

    if(ep->debug)
        ctlr->debugchan |= 1 << (hc - ctlr->regs->hchan);
    else
        ctlr->debugchan &= ~(1 << (hc - ctlr->regs->hchan));
    switch(ep->dev->state){
    case Dconfig:
    case Dreset:
        hcc = 0;
        break;
    default:
        hcc = ep->dev->nb<<ODevaddr;
        break;
    }
    hcc |= ep->maxpkt | 1<<OMulticnt | ep->nb<<OEpnum;
    switch(ep->ttype){
    case Tctl:
        hcc |= Epctl;
        break;
    case Tiso:
        hcc |= Episo;
        break;
    case Tbulk:
        hcc |= Epbulk;
        break;
    case Tintr:
        hcc |= Epintr;
        break;
    }
    switch(ep->dev->speed){
    case Lowspeed:
        hcc |= Lspddev;
        /* fall through */
    case Fullspeed:
        if(ep->dev->hub > 1){
            hc->hcsplt = Spltena | POS_ALL | ep->dev->hub<<OHubaddr |
                ep->dev->port;
            break;
        }
        /* fall through */
    default:
        hc->hcsplt = 0;
        break;
    }
    hc->hcchar = hcc;
    hc->hcint = ~0;
}
@

<<function sofdone(arm)>>=
static int
sofdone(void *a)
{
    Dwcregs *r;

    r = a;
    return (r->gintmsk & Sofintr) == 0;
}
@

<<function sofwait(arm)>>=
static void
sofwait(Ctlr *ctlr, int n)
{
    Dwcregs *r;

    r = ctlr->regs;
    do{
        filock(ctlr);
        r->gintsts = Sofintr;
        ctlr->sofchan |= 1<<n;
        r->gintmsk |= Sofintr;
        fiunlock(ctlr);
        sleep(&ctlr->chanintr[n], sofdone, r);
    }while((r->hfnum & 7) == 6);
}
@

<<function chandone(arm)>>=
static int
chandone(void *a)
{
    Hostchan *hc;

    hc = a;
    if(hc->hcint == (Chhltd|Ack))
        return 0;
    return (hc->hcint & hc->hcintmsk) != 0;
}
@

<<function chanwait(arm)>>=
static int
chanwait(Ep *ep, Ctlr *ctlr, Hostchan *hc, int mask)
{
    int intr, n, ointr;
    ulong start, now;
    Dwcregs *r;

    r = ctlr->regs;
    n = hc - r->hchan;
    for(;;){
restart:
        filock(ctlr);
        r->haintmsk |= 1<<n;
        hc->hcintmsk = mask;
        fiunlock(ctlr);
        sleep(&ctlr->chanintr[n], chandone, hc);
        hc->hcintmsk = 0;
        intr = hc->hcint;
        if(intr & Chhltd)
            return intr;
        start = arch_fastticks(0);
        ointr = intr;
        now = start;
        do{
            intr = hc->hcint;
            if(intr & Chhltd){
                if((ointr != Ack && ointr != (Ack|Xfercomp)) ||
                   intr != (Ack|Chhltd|Xfercomp) ||
                   (now - start) > 60)
                    dprint("await %x after %ld %x -> %x\n",
                        mask, now - start, ointr, intr);
                return intr;
            }
            if((intr & mask) == 0){
                dprint("ep%d.%d await %x intr %x -> %x\n",
                    ep->dev->nb, ep->nb, mask, ointr, intr);
                goto restart;
            }
            now = arch_fastticks(0);
        }while(now - start < 100);
        dprint("ep%d.%d halting channel %8.8ux hcchar %8.8ux "
            "grxstsr %8.8ux gnptxsts %8.8ux hptxsts %8.8ux\n",
            ep->dev->nb, ep->nb, intr, hc->hcchar, r->grxstsr,
            r->gnptxsts, r->hptxsts);
        mask = Chhltd;
        hc->hcchar |= Chdis;
        start = cpu->ticks;
        while(hc->hcchar & Chen){
            if(cpu->ticks - start >= 100){
                print("ep%d.%d channel won't halt hcchar %8.8ux\n",
                    ep->dev->nb, ep->nb, hc->hcchar);
                break;
            }
        }
        logdump(ep);
    }
}
@

<<function chanintr(arm)>>=
static int
chanintr(Ctlr *ctlr, int n)
{
    Hostchan *hc;
    int i;

    hc = &ctlr->regs->hchan[n];
    if(ctlr->debugchan & (1<<n))
        clog(nil, hc);
    if((hc->hcsplt & Spltena) == 0)
        return 0;
    i = hc->hcint;
    if(i == (Chhltd|Ack)){
        hc->hcsplt |= Compsplt;
        ctlr->splitretry = 0;
    }else if(i == (Chhltd|Nyet)){
        if(++ctlr->splitretry >= 3)
            return 0;
    }else
        return 0;
    if(hc->hcchar & Chen){
        iprint("hcchar %8.8ux hcint %8.8ux", hc->hcchar, hc->hcint);
        hc->hcchar |= Chen | Chdis;
        while(hc->hcchar&Chen)
            ;
        iprint(" %8.8ux\n", hc->hcint);
    }
    hc->hcint = i;
    if(ctlr->regs->hfnum & 1)
        hc->hcchar &= ~Oddfrm;
    else
        hc->hcchar |= Oddfrm;
    hc->hcchar = (hc->hcchar &~ Chdis) | Chen;
    return 1;
}
@

<<global chanlog(arm)>>=
static Reg chanlog[32][5];
@

<<global nchanlog(arm)>>=
static int nchanlog;
@

<<function logstart(arm)>>=
static void
logstart(Ep *ep)
{
    if(ep->debug)
        nchanlog = 0;
}
@

<<function clog(arm)>>=
static void
clog(Ep *ep, Hostchan *hc)
{
    Reg *p;

    if(ep != nil && !ep->debug)
        return;
    if(nchanlog == 32)
        nchanlog--;
    p = chanlog[nchanlog];
    p[0] = dwc.regs->hfnum;
    p[1] = hc->hcchar;
    p[2] = hc->hcint;
    p[3] = hc->hctsiz;
    p[4] = hc->hcdma;
    nchanlog++;
}
@

<<function logdump(arm)>>=
static void
logdump(Ep *ep)
{
    Reg *p;
    int i;

    if(!ep->debug)
        return;
    p = chanlog[0];
    for(i = 0; i < nchanlog; i++){
        print("%5.5d.%5.5d %8.8ux %8.8ux %8.8ux %8.8ux\n",
            p[0]&0xFFFF, p[0]>>16, p[1], p[2], p[3], p[4]);
        p += 5;
    }
    nchanlog = 0;
}
@

<<function chanio(arm)>>=
static int
chanio(Ep *ep, Hostchan *hc, int dir, int pid, void *a, int len)
{
    Ctlr *ctlr;
    int nleft, n, nt, i, maxpkt, npkt;
    uint hcdma, hctsiz;

    ctlr = ep->hp->aux;
    maxpkt = ep->maxpkt;
    npkt = HOWMANY(len, ep->maxpkt);
    if(npkt == 0)
        npkt = 1;

    hc->hcchar = (hc->hcchar & ~Epdir) | dir;
    if(dir == Epin)
        n = ROUND(len, ep->maxpkt);
    else
        n = len;
    hc->hctsiz = n | npkt<<OPktcnt | pid;
    hc->hcdma  = dmaaddr(a);

    nleft = len;
    logstart(ep);
    for(;;){
        hcdma = hc->hcdma;
        hctsiz = hc->hctsiz;
        hc->hctsiz = hctsiz & ~Dopng;
        if(hc->hcchar&Chen){
            dprint("ep%d.%d before chanio hcchar=%8.8ux\n",
                ep->dev->nb, ep->nb, hc->hcchar);
            hc->hcchar |= Chen | Chdis;
            while(hc->hcchar&Chen)
                ;
            hc->hcint = Chhltd;
        }
        if((i = hc->hcint) != 0){
            dprint("ep%d.%d before chanio hcint=%8.8ux\n",
                ep->dev->nb, ep->nb, i);
            hc->hcint = i;
        }
        if(hc->hcsplt & Spltena){
            qlock(&ctlr->split);
            sofwait(ctlr, hc - ctlr->regs->hchan);
            if((dwc.regs->hfnum & 1) == 0)
                hc->hcchar &= ~Oddfrm;
            else
                hc->hcchar |= Oddfrm;
        }
        hc->hcchar = (hc->hcchar &~ Chdis) | Chen;
        clog(ep, hc);
        if(ep->ttype == Tbulk && dir == Epin)
            i = chanwait(ep, ctlr, hc, /* Ack| */ Chhltd);
        else if(ep->ttype == Tintr && (hc->hcsplt & Spltena))
            i = chanwait(ep, ctlr, hc, Chhltd);
        else
            i = chanwait(ep, ctlr, hc, Chhltd|Nak);
        clog(ep, hc);
        hc->hcint = i;

        if(hc->hcsplt & Spltena){
            hc->hcsplt &= ~Compsplt;
            qunlock(&ctlr->split);
        }

        if((i & Xfercomp) == 0 && i != (Chhltd|Ack) && i != Chhltd){
            if(i & Stall)
                error(Estalled);
            if(i & (Nyet|Frmovrun))
                continue;
            if(i & Nak){
                if(ep->ttype == Tintr)
                    tsleep(&up->sleepr, returnfalse, 0, ep->pollival);
                else
                    tsleep(&up->sleepr, returnfalse, 0, 1);
                continue;
            }
            logdump(ep);
            print("usbotg: ep%d.%d error intr %8.8ux\n",
                ep->dev->nb, ep->nb, i);
            if(i & ~(Chhltd|Ack))
                error(Eio);
            if(hc->hcdma != hcdma)
                print("usbotg: weird hcdma %x->%x intr %x->%x\n",
                    hcdma, hc->hcdma, i, hc->hcint);
        }
        n = hc->hcdma - hcdma;
        if(n == 0){
            if((hc->hctsiz & Pktcnt) != (hctsiz & Pktcnt))
                break;
            else
                continue;
        }
        if(dir == Epin && ep->ttype == Tbulk && n == nleft){
            nt = (hctsiz & Xfersize) - (hc->hctsiz & Xfersize);
            if(nt != n){
                if(n == ROUND(nt, 4))
                    n = nt;
                else
                    print("usbotg: intr %8.8ux "
                        "dma %8.8ux-%8.8ux "
                        "hctsiz %8.8ux-%8.ux\n",
                        i, hcdma, hc->hcdma, hctsiz,
                        hc->hctsiz);
            }
        }
        if(n > nleft){
            if(n != ROUND(nleft, 4))
                dprint("too much: wanted %d got %d\n",
                    len, len - nleft + n);
            n = nleft;
        }
        nleft -= n;
        if(nleft == 0 || (n % maxpkt) != 0)
            break;
        if((i & Xfercomp) && ep->ttype != Tctl)
            break;
        if(dir == Epout)
            dprint("too little: nleft %d hcdma %x->%x hctsiz %x->%x intr %x\n",
                nleft, hcdma, hc->hcdma, hctsiz, hc->hctsiz, i);
    }
    logdump(ep);
    return len - nleft;
}
@

<<function multitrans(arm)>>=
static long
multitrans(Ep *ep, Hostchan *hc, int rw, void *a, long n)
{
    long sofar, m;

    sofar = 0;
    do{
        m = n - sofar;
        if(m > ep->maxpkt)
            m = ep->maxpkt;
        m = chanio(ep, hc, rw == Read? Epin : Epout, ep->toggle[rw],
            (char*)a + sofar, m);
        ep->toggle[rw] = hc->hctsiz & Pid;
        sofar += m;
    }while(sofar < n && m == ep->maxpkt);
    return sofar;
}
@

<<function eptrans(arm)>>=
static long
eptrans(Ep *ep, int rw, void *a, long n)
{
    Hostchan *hc;

    if(ep->clrhalt){
        ep->clrhalt = 0;
        if(ep->mode != OREAD)
            ep->toggle[Write] = DATA0;
        if(ep->mode != OWRITE)
            ep->toggle[Read] = DATA0;
    }
    hc = chanalloc(ep);
    if(waserror()){
        ep->toggle[rw] = hc->hctsiz & Pid;
        chanrelease(ep, hc);
        if(strcmp(up->errstr, Estalled) == 0)
            return 0;
        nexterror();
    }
    chansetup(hc, ep);
    if(rw == Read && ep->ttype == Tbulk)
        n = multitrans(ep, hc, rw, a, n);
    else{
        n = chanio(ep, hc, rw == Read? Epin : Epout, ep->toggle[rw],
            a, n);
        ep->toggle[rw] = hc->hctsiz & Pid;
    }
    chanrelease(ep, hc);
    poperror();
    return n;
}
@

<<function ctltrans(arm)>>=
static long
ctltrans(Ep *ep, uchar *req, long n)
{
    Hostchan *hc;
    Epio *epio;
    Block *b;
    uchar *data;
    int datalen;

    epio = ep->aux;
    if(epio->cb != nil){
        freeb(epio->cb);
        epio->cb = nil;
    }
    if(n < Rsetuplen)
        error(Ebadlen);
    if(req[Rtype] & Rd2h){
        datalen = GET2(req+Rcount);
        if(datalen <= 0 || datalen > Maxctllen)
            error(Ebadlen);
        /* XXX cache madness */
        epio->cb = b = allocb(ROUND(datalen, ep->maxpkt));
        assert(((uintptr)b->wp & (BLOCKALIGN-1)) == 0);
        memset(b->wp, 0x55, b->lim - b->wp);
        cachedwbinvse(b->wp, b->lim - b->wp);
        data = b->wp;
    }else{
        b = nil;
        datalen = n - Rsetuplen;
        data = req + Rsetuplen;
    }
    hc = chanalloc(ep);
    if(waserror()){
        chanrelease(ep, hc);
        if(strcmp(up->errstr, Estalled) == 0)
            return 0;
        nexterror();
    }
    chansetup(hc, ep);
    chanio(ep, hc, Epout, SETUP, req, Rsetuplen);
    if(req[Rtype] & Rd2h){
        if(ep->dev->hub <= 1){
            ep->toggle[Read] = DATA1;
            b->wp += multitrans(ep, hc, Read, data, datalen);
        }else
            b->wp += chanio(ep, hc, Epin, DATA1, data, datalen);
        chanio(ep, hc, Epout, DATA1, nil, 0);
        n = Rsetuplen;
    }else{
        if(datalen > 0)
            chanio(ep, hc, Epout, DATA1, data, datalen);
        chanio(ep, hc, Epin, DATA1, nil, 0);
        n = Rsetuplen + datalen;
    }
    chanrelease(ep, hc);
    poperror();
    return n;
}
@

<<function ctldata(arm)>>=
static long
ctldata(Ep *ep, void *a, long n)
{
    Epio *epio;
    Block *b;

    epio = ep->aux;
    b = epio->cb;
    if(b == nil)
        return 0;
    if(n > BLEN(b))
        n = BLEN(b);
    memmove(a, b->rp, n);
    b->rp += n;
    if(BLEN(b) == 0){
        freeb(b);
        epio->cb = nil;
    }
    return n;
}
@

<<function greset(arm)>>=
static void
greset(Dwcregs *r, int bits)
{
    r->grstctl |= bits;
    while(r->grstctl & bits)
        ;
    arch_microdelay(10);
}
@

<<function init(arm)>>=
static void
init(Hci *hp)
{
    Ctlr *ctlr;
    Dwcregs *r;
    uint n, rx, tx, ptx;

    ctlr = hp->aux;
    r = ctlr->regs;

    ctlr->nchan = 1 + ((r->ghwcfg2 & Num_host_chan) >> ONum_host_chan);
    ctlr->chanintr = malloc(ctlr->nchan * sizeof(Rendez));

    r->gahbcfg = 0;
    setpower(PowerUsb, 1);

    while((r->grstctl&Ahbidle) == 0)
        ;
    greset(r, Csftrst);

    r->gusbcfg |= Force_host_mode;
    tsleep(&up->sleepr, returnfalse, 0, 25);
    r->gahbcfg |= Dmaenable;

    n = (r->ghwcfg3 & Dfifo_depth) >> ODfifo_depth;
    rx = 0x306;
    tx = 0x100;
    ptx = 0x200;
    r->grxfsiz = rx;
    r->gnptxfsiz = rx | tx<<ODepth;
    tsleep(&up->sleepr, returnfalse, 0, 1);
    r->hptxfsiz = (rx + tx) | ptx << ODepth;
    greset(r, Rxfflsh);
    r->grstctl = TXF_ALL;
    greset(r, Txfflsh);
    dprint("usbotg: FIFO depth %d sizes rx/nptx/ptx %8.8ux %8.8ux %8.8ux\n",
        n, r->grxfsiz, r->gnptxfsiz, r->hptxfsiz);

    r->hport0 = Prtpwr|Prtconndet|Prtenchng|Prtovrcurrchng;
    r->gintsts = ~0;
    r->gintmsk = Hcintr;
    r->gahbcfg |= Glblintrmsk;
}
@

<<function dump (buses/arm/usbdwc.c)(arm)>>=
static void
dump(Hci*)
{
}
@

<<function fiqintr(arm)>>=
static void
fiqintr(Ureg*, void *a)
{
    Hci *hp;
    Ctlr *ctlr;
    Dwcregs *r;
    uint intr, haint, wakechan;
    int i;

    hp = a;
    ctlr = hp->aux;
    r = ctlr->regs;
    wakechan = 0;
    filock(ctlr);
    intr = r->gintsts;
    if(intr & Hcintr){
        haint = r->haint & r->haintmsk;
        for(i = 0; haint; i++){
            if(haint & 1){
                if(chanintr(ctlr, i) == 0){
                    r->haintmsk &= ~(1<<i);
                    wakechan |= 1<<i;
                }
            }
            haint >>= 1;
        }
    }
    if(intr & Sofintr){
        r->gintsts = Sofintr;
        if((r->hfnum&7) != 6){
            r->gintmsk &= ~Sofintr;
            wakechan |= ctlr->sofchan;
            ctlr->sofchan = 0;
        }
    }
    if(wakechan){
        ctlr->wakechan |= wakechan;
        armtimerset(1);
    }
    fiunlock(ctlr);
}
@

<<function irqintr(arm)>>=
static void
irqintr(Ureg*, void *a)
{
    Ctlr *ctlr;
    uint wakechan;
    int i;

    ctlr = a;
    filock(ctlr);
    armtimerset(0);
    wakechan = ctlr->wakechan;
    ctlr->wakechan = 0;
    fiunlock(ctlr);
    for(i = 0; wakechan; i++){
        if(wakechan & 1)
            wakeup(&ctlr->chanintr[i]);
        wakechan >>= 1;
    }
}
@

<<function epopen(arm)>>=
static void
epopen(Ep *ep)
{
    ddprint("usbotg: epopen ep%d.%d ttype %d\n",
        ep->dev->nb, ep->nb, ep->ttype);
    switch(ep->ttype){
    case Tnone:
        error(Enotconf);
    case Tintr:
        assert(ep->pollival > 0);
        /* fall through */
    case Tbulk:
        if(ep->toggle[Read] == 0)
            ep->toggle[Read] = DATA0;
        if(ep->toggle[Write] == 0)
            ep->toggle[Write] = DATA0;
        break;
    }
    ep->aux = malloc(sizeof(Epio));
    if(ep->aux == nil)
        error(Enomem);
}
@

<<function epclose (buses/arm/usbdwc.c)(arm)>>=
static void
epclose(Ep *ep)
{
    ddprint("usbotg: epclose ep%d.%d ttype %d\n",
        ep->dev->nb, ep->nb, ep->ttype);
    switch(ep->ttype){
    case Tctl:
        freeb(((Epio*)ep->aux)->cb);
        /* fall through */
    default:
        free(ep->aux);
        break;
    }
}
@

<<function epread(arm)>>=
static long
epread(Ep *ep, void *a, long n)
{
    Epio *epio;
    Block *b;
    uchar *p;
    ulong elapsed;
    long nr;

    ddprint("epread ep%d.%d %ld\n", ep->dev->nb, ep->nb, n);
    epio = ep->aux;
    b = nil;
    qlock(epio);
    if(waserror()){
        qunlock(epio);
        if(b)
            freeb(b);
        nexterror();
    }
    switch(ep->ttype){
    default:
        error(Egreg);
    case Tctl:
        nr = ctldata(ep, a, n);
        qunlock(epio);
        poperror();
        return nr;
    case Tintr:
        elapsed = TK2MS(cpu->ticks) - epio->lastpoll;
        if(elapsed < ep->pollival)
            tsleep(&up->sleepr, returnfalse, 0, ep->pollival - elapsed);
        /* fall through */
    case Tbulk:
        /* XXX cache madness */
        b = allocb(ROUND(n, ep->maxpkt));
        p = b->rp;
        assert(((uintptr)p & (BLOCKALIGN-1)) == 0);
        cachedinvse(p, n);
        nr = eptrans(ep, Read, p, n);
        cachedinvse(p, nr);
        epio->lastpoll = TK2MS(cpu->ticks);
        memmove(a, p, nr);
        qunlock(epio);
        freeb(b);
        poperror();
        return nr;
    }
}
@

<<function epwrite(arm)>>=
static long
epwrite(Ep *ep, void *a, long n)
{
    Epio *epio;
    Block *b;
    uchar *p;
    ulong elapsed;

    ddprint("epwrite ep%d.%d %ld\n", ep->dev->nb, ep->nb, n);
    epio = ep->aux;
    b = nil;
    qlock(epio);
    if(waserror()){
        qunlock(epio);
        if(b)
            freeb(b);
        nexterror();
    }
    switch(ep->ttype){
    default:
        error(Egreg);
    case Tintr:
        elapsed = TK2MS(cpu->ticks) - epio->lastpoll;
        if(elapsed < ep->pollival)
            tsleep(&up->sleepr, returnfalse, 0, ep->pollival - elapsed);
        /* fall through */
    case Tctl:
    case Tbulk:
        /* XXX cache madness */
        b = allocb(n);
        p = b->wp;
        assert(((uintptr)p & (BLOCKALIGN-1)) == 0);
        memmove(p, a, n);
        cachedwbse(p, n);
        if(ep->ttype == Tctl)
            n = ctltrans(ep, p, n);
        else{
            n = eptrans(ep, Write, p, n);
            epio->lastpoll = TK2MS(cpu->ticks);
        }
        qunlock(epio);
        freeb(b);
        poperror();
        return n;
    }
}
@

<<function seprintep (buses/arm/usbdwc.c)(arm)>>=
static char*
seprintep(char *s, char*, Ep*)
{
    return s;
}
@

<<function portenable(arm)>>=
static int
portenable(Hci *hp, int port, int on)
{
    Ctlr *ctlr;
    Dwcregs *r;

    assert(port == 1);
    ctlr = hp->aux;
    r = ctlr->regs;
    dprint("usbotg enable=%d; sts %#x\n", on, r->hport0);
    if(!on)
        r->hport0 = Prtpwr | Prtena;
    tsleep(&up->sleepr, returnfalse, 0, Enabledelay);
    dprint("usbotg enable=%d; sts %#x\n", on, r->hport0);
    return 0;
}
@

<<function portreset(arm)>>=
static int
portreset(Hci *hp, int port, int on)
{
    Ctlr *ctlr;
    Dwcregs *r;
    int b, s;

    assert(port == 1);
    ctlr = hp->aux;
    r = ctlr->regs;
    dprint("usbotg reset=%d; sts %#x\n", on, r->hport0);
    if(!on)
        return 0;
    r->hport0 = Prtpwr | Prtrst;
    tsleep(&up->sleepr, returnfalse, 0, ResetdelayHS);
    r->hport0 = Prtpwr;
    tsleep(&up->sleepr, returnfalse, 0, Enabledelay);
    s = r->hport0;
    b = s & (Prtconndet|Prtenchng|Prtovrcurrchng);
    if(b != 0)
        r->hport0 = Prtpwr | b;
    dprint("usbotg reset=%d; sts %#x\n", on, s);
    if((s & Prtena) == 0)
        print("usbotg: host port not enabled after reset");
    return 0;
}
@

<<function portstatus(arm)>>=
static int
portstatus(Hci *hp, int port)
{
    Ctlr *ctlr;
    Dwcregs *r;
    int b, s;

    assert(port == 1);
    ctlr = hp->aux;
    r = ctlr->regs;
    s = r->hport0;
    b = s & (Prtconndet|Prtenchng|Prtovrcurrchng);
    if(b != 0)
        r->hport0 = Prtpwr | b;
    b = 0;
    if(s & Prtconnsts)
        b |= HPpresent;
    if(s & Prtconndet)
        b |= HPstatuschg;
    if(s & Prtena)
        b |= HPenable;
    if(s & Prtenchng)
        b |= HPchange;
    if(s & Prtovrcurract)
         b |= HPovercurrent;
    if(s & Prtsusp)
        b |= HPsuspend;
    if(s & Prtrst)
        b |= HPreset;
    if(s & Prtpwr)
        b |= HPpower;
    switch(s & Prtspd){
    case HIGHSPEED:
        b |= HPhigh;
        break;
    case LOWSPEED:
        b |= HPslow;
        break;
    }
    return b;
}
@

<<function shutdown(arm)>>=
static void
shutdown(Hci*)
{
}
@

<<function setdebug(arm)>>=
static void
setdebug(Hci*, int d)
{
    debug = d;
}
@

<<function reset(arm)>>=
static int
reset(Hci *hp)
{
    Ctlr *ctlr;
    uint id;

    ctlr = &dwc;
    if(ctlr->regs != nil)
        return -1;
    ctlr->regs = (Dwcregs*)USBREGS;
    id = ctlr->regs->gsnpsid;
    if((id>>16) != ('O'<<8 | 'T'))
        return -1;
    dprint("usbotg: rev %d.%3.3x\n", (id>>12)&0xF, id&0xFFF);

    arch_intrenable(IRQtimerArm, irqintr, ctlr, 0, "dwc");

    hp->aux = ctlr;
    hp->port = 0;
    hp->irq = IRQusb;
    hp->tbdf = 0;
    hp->nports = 1;
    hp->highspeed = 1;

    hp->init = init;
    hp->dump = dump;
    hp->interrupt = fiqintr;
    hp->epopen = epopen;
    hp->epclose = epclose;
    hp->epread = epread;
    hp->epwrite = epwrite;
    hp->seprintep = seprintep;
    hp->portenable = portenable;
    hp->portreset = portreset;
    hp->portstatus = portstatus;
    hp->shutdown = shutdown;
    hp->debug = setdebug;
    hp->type = "dwcotg";
    return 0;
}
@

<<function usbdwclink(arm)>>=
void
usbdwclink(void)
{
    addhcitype("dwcotg", reset);
}
@


%-------------------------------------------------------------

<<buses/arm/usbdwc.c>>=
/*
 * USB host driver for BCM2835
 *  Synopsis DesignWare Core USB 2.0 OTG controller
 *
 * Copyright © 2012 Richard Miller <r.miller@acm.org>
 *
 * This is work in progress:
 * - no isochronous pipes
 * - no bandwidth budgeting
 * - frame scheduling is crude
 * - error handling is overly optimistic
 * It should be just about adequate for a Plan 9 terminal with
 * keyboard, mouse, ethernet adapter, and an external flash drive.
 */
<<kernel basic includes>>

#include    "io.h"
#include    "../port/usb.h"

#include "dwcotg.h"

<<constant USBREGS(arm)>>
<<enum _anon_ (buses/arm/usbdwc.c)(arm)>>

typedef struct Ctlr Ctlr;
typedef struct Epio Epio;

<<struct Ctlr (buses/arm/usbdwc.c)(arm)>>

<<struct Epio(arm)>>

<<global dwc(arm)>>
<<global debug (buses/arm/usbdwc.c)(arm)>>

<<global Ebadlen(arm)>>

static void clog(Ep *ep, Hostchan *hc);
static void logdump(Ep *ep);

<<function filock(arm)>>

<<function fiunlock(arm)>>

<<function chanalloc(arm)>>

<<function chanrelease(arm)>>

<<function chansetup(arm)>>

<<function sofdone(arm)>>

<<function sofwait(arm)>>

<<function chandone(arm)>>

<<function chanwait(arm)>>

<<function chanintr(arm)>>

<<global chanlog(arm)>>
<<global nchanlog(arm)>>

<<function logstart(arm)>>

<<function clog(arm)>>

<<function logdump(arm)>>

<<function chanio(arm)>>

<<function multitrans(arm)>>

<<function eptrans(arm)>>

<<function ctltrans(arm)>>

<<function ctldata(arm)>>

<<function greset(arm)>>

<<function init(arm)>>

<<function dump (buses/arm/usbdwc.c)(arm)>>

<<function fiqintr(arm)>>

<<function irqintr(arm)>>

<<function epopen(arm)>>

<<function epclose (buses/arm/usbdwc.c)(arm)>>

<<function epread(arm)>>

<<function epwrite(arm)>>

<<function seprintep (buses/arm/usbdwc.c)(arm)>>
    
<<function portenable(arm)>>

<<function portreset(arm)>>

<<function portstatus(arm)>>

<<function shutdown(arm)>>

<<function setdebug(arm)>>

<<function reset(arm)>>

<<function usbdwclink(arm)>>
@


