\part{Files}

\section{[[../include/arch/arm/]]}

\subsection*{[[../include/arch/arm/ureg.h]]}

%Used outside the kernel: in libcore, libmach, hence in ../include

%-------------------------------------------------------------

<<arm/ureg.h>>=
typedef struct Ureg Ureg;
<<struct Ureg(arm)>>
@

\section{[[arch/arm/]]}

\subsection*{[[arch/arm/dat_arch.h]]}
%pad: I created this file; everything was in a giant dat.h before

%-------------------------------------------------------------

<<arch/arm/dat_arch.h>>=

<<struct Soc(arm)>>

extern Soc soc;
@


\subsection*{[[arch/arm/arm.h]]}


%-------------------------------------------------------------

<<arch/arm/arm.h>>=
/*
 * ARM-specific definitions for armv6 (arm11), armv7 (cortex-a7 and -a8)
 * these are used in C and assembler
 */

/*
 * Program Status Registers
 */
<<type PsrMode(arm)>>

<<type PsrDisable(arm)>>

/*
 * Coprocessors
 */
<<type Coprocessors(arm)>>

/*
 * Primary (CRn) CpSC registers.
 */
<<type CpSC primary registers(arm)>>

// CpSC secondary registers

<<type CpID secondary registers(arm)>>
<<type CpID opcode2(arm)>>

<<type CpCONTROL opcode2(arm)>>
<<type CpCONTROL CpMainctl(arm)>>
<<type CpCONTROL CpAuxctl(arm)>>

<<type CpTTB(arm)>>

<<type CpFSR(arm)>>

<<type CpCACHE secondary registers(arm)>>
<<type CpCACHE opcode2(arm)>>

<<type CpTLB secondary registers(arm)>>
<<type CpTLB opcode2(arm)>>

<<type CpCLD secondary registers(arm)>>
<<type CpCLD opcode2(arm)>>

<<type CpTIMER(arm)>>

<<type CpSPM secondary registers(arm)>>
<<type CpSPM opcode2(arm)>>

// For MCRR

<<type CpCACHERANGE opcode2(arm)>>

// Misc

<<type CpTTB cache control bits(arm)>>

/*
 * MMU page table entries.
 */
<<constant Mbz(arm)>>

<<constant Fault(arm)>>

<<type PageDirGranularity(arm)>>
<<type PageTableGranularity(arm)>>

<<type PageTableEntryAttribute1(arm)>>

<<constant Dom0(arm)>>

<<type PageTableEntryAttribute2(arm)>>

<<type PageTableEntryAttribute3(arm)>>

<<type DAC(arm)>>

<<macro F(arm)>>

<<macro AP(arm)>>
<<macro L1AP(arm)>>
/* L2AP differs between armv6 and armv7 -- see l2ap in arch*.c */
<<macro DAC(arm)>>

<<constant HVECTORS(arm)>>

@

%dead:
% /*
%  * l2 cache aux. control
%  */
% #define CpCl2ecc    (1<<28)         /* use ecc, not parity */
% #define CpCl2noldforw   (1<<27)         /* no ld forwarding */
% #define CpCl2nowrcomb   (1<<25)         /* no write combining */
% #define CpCl2nowralldel (1<<24)         /* no write allocate delay */
% #define CpCl2nowrallcomb (1<<23)        /* no write allocate combine */
% #define CpCl2nowralloc  (1<<22)         /* no write allocate */
% #define CpCl2eccparity  (1<<21)         /* enable ecc or parity */
% #define CpCl2inner  (1<<16)         /* inner cacheability */
% /* other bits are tag ram & data ram latencies */
% 
% /*
%  * CpCLD Secondary (CRm) registers and opcode2 fields for op1==1.
%  */
% #define CpCLDl2     0           /* l2 cache */
% 
% #define CpCLDl2aux  2           /* auxiliary control */
% 
% /*
%  * CpTLD Secondary (CRm) registers and opcode2 fields.
%  */
% #define CpTLDlock   0           /* TLB lockdown registers */
% #define CpTLDpreload    1           /* TLB preload */
% 
% #define CpTLDi      0           /* TLB instr. lockdown reg. */
% #define CpTLDd      1           /* " data " " */
% 
% /*
%  * CpVECS Secondary (CRm) registers and opcode2 fields.
%  */
% #define CpVECSbase  0
% 
% #define CpVECSnorm  0           /* (non-)secure base addr */
% #define CpVECSmon   1           /* secure monitor base addr */

% <<type CpCONTROL secondary registers(arm)>>=
% /*
%  * CpCONTROL Secondary (CRm) registers and opcode2 fields.
%  */
% #define CpCONTROLscr    1
% @
% 
% <<type CpCONTROL opcode2 bis(arm)>>=
% #define CpSCRscr    0
% @


\subsection*{[[arch/arm/arminstr.ha]]}
%pad: used to be called arm.s, but I prefer the .ha suffix for asm macros

<<arch/arm/arminstr.ha>>=
/*
 * armv6/v7 machine assist, definitions
 *
 * loader uses R11 as scratch.
 */

<<macro PADDR bis(arm)>>
<<macro L1X bis(arm)>>

/*
 * new instructions
 */
<<instruction ISB(arm)>>
<<instruction DSB(arm)>>
<<instruction BARRIERS(arm)>>

<<instruction MCRR(arm)>>
<<instruction MRRC(arm)>>

<<instruction LDREX(arm)>>
<<instruction STREX(arm)>>
<<instruction CLREX(arm)>>

<<instruction CPSID(arm)>>

<<instruction CPUID(arm)>>
@
%$
%dead: 
% #define PUTC(s)
% #define OKAY \
%     MOVW    $0x7E200028,R2; \
%     MOVW    $0x10000,R3; \
%     MOVW    R3,(R2)


\subsection*{[[arch/arm/io.h]]}


%-------------------------------------------------------------

<<arch/arm/io.h>>=
// could be in dat_interrupts.h?
<<enum IRQ(arm)>>
<<macro IRQDMA(arm)>>

<<enum Dma(arm)>>

<<enum Power(arm)>>

// could be in dat_time.h?
<<enum Clock(arm)>>
@


\subsection*{[[arch/arm/coproc.c]]}

%pad: why not have generic assembly functions called from C
% that takes the coprocessor register numbers as arguments in the stack?

<<enum _anon_(arm)>>=
enum {
    /* alternates:  
     *  0xe12fff1e  BX (R14); last e is R14
     *  0xe28ef000  B 0(R14); second e is R14 (ken)
     */
    RETinst = 0xe1a0f00e,       /* MOV R14, R15 */

    Opmask  = MASK(3),
    Regmask = MASK(4),
};
@

<<function setupcpop(arm)>>=
// setup coprocessor operation
static void
setupcpop(ulong instr[2], ulong opcode, int cp, int op1, int crn, int crm,
    int op2)
{
    ulong instrsz[2];

    op1 &= Opmask;
    op2 &= Opmask;
    crn &= Regmask;
    crm &= Regmask;
    cp  &= Regmask;
    instr[0] = opcode | op1 << 21 | crn << 16 | cp << 8 | op2 << 5 | crm;
    instr[1] = RETinst;

    cachedwbse(instr, sizeof instrsz);
    cacheiinv();
}
@
% >> >> >> >> >> >> >> >>

<<function cprd(arm)>>=
ulong
cprd(int cp, int op1, int crn, int crm, int op2)
{
    int s, r;
    volatile ulong instr[2];
    Pufv fp;

    s = arch_splhi();
    /*
     * MRC.  return value will be in R0, which is convenient.
     * Rt will be R0.
     */
    // MRC 0x e(Mxx) e(Always) 0 (MRC) .... 10 (part of Mxxx opcode)
    setupcpop(instr, 0xee100010, cp, op1, crn, crm, op2);
    fp = (Pufv)instr;
    r = fp();
    arch_splx(s);
    return r;
}
@

<<function cpwr(arm)>>=
void
cpwr(int cp, int op1, int crn, int crm, int op2, ulong val)
{
    int s;
    volatile ulong instr[2];
    Pvfu fp;

    s = arch_splhi();
    // MCR 0x e(Mxx) e(Always) 0 (MCR) .... 10 (part of Mxxx opcode)
    setupcpop(instr, 0xee000010, cp, op1, crn, crm, op2); /* MCR, Rt is R0 */
    fp = (Pvfu)instr;
    fp(val);
    arch_coherence();
    arch_splx(s);
}
@

<<function cprdsc(arm)>>=
ulong
cprdsc(int op1, int crn, int crm, int op2)
{
    return cprd(CpSC, op1, crn, crm, op2);
}
@

<<function cpwrsc(arm)>>=
void
cpwrsc(int op1, int crn, int crm, int op2, ulong val)
{
    cpwr(CpSC, op1, crn, crm, op2, val);
}
@


%-------------------------------------------------------------

<<arch/arm/coproc.c>>=
/*
 * ARM co-processors
 * mainly to cope with ARM hard-wiring register numbers into instructions.
 *
 * CP15 (system control) is the one that gets used the most in practice.
 * these routines must be callable from KZERO space or the 0 segment.
 */
<<kernel basic includes>>

#include "io.h"
#include "arm.h"

<<enum _anon_(arm)>>

// pointer to ulong function void
typedef ulong (*Pufv)(void);
// pointer to void function ulong
typedef void  (*Pvfu)(ulong);

<<function setupcpop(arm)>>

<<function cprd(arm)>>

<<function cpwr(arm)>>

<<function cprdsc(arm)>>

<<function cpwrsc(arm)>>

/* floating point */

<<function setupfpctlop(arm)>>

<<function fprd(arm)>>

<<function fpwr(arm)>>

<<function setupfpop(arm)>>

<<function fpsavereg(arm)>>

<<function fprestreg(arm)>>
@
% >> >> >> >> >> >> >>

\subsection*{[[arch/arm/vcore.c]]}


<<enum _anon_ (arch/arm/vcore.c)(arm)>>=
enum {
    Read        = 0x00>>2,
    Write       = 0x00>>2,
    Peek        = 0x10>>2,
    Sender      = 0x14>>2,
    Status      = 0x18>>2,
        Full        = 1<<31,
        Empty       = 1<<30,
    Config      = 0x1C>>2,

    NRegs       = 0x20>>2,
};
@

<<enum _anon_ (arch/arm/vcore.c)2(arm)>>=
enum {
    ChanFb      = 1,
    ChanProps   = 8,
    ChanMask    = 0xF,
};
@

<<enum _anon_ (arch/arm/vcore.c)3(arm)>>=
enum {
    Req         = 0x0,
    RspOk       = 0x80000000,
    TagResp     = 1<<31,
};
@

<<enum _anon_ (arch/arm/vcore.c)4(arm)>>=
enum {
    TagGetfwrev = 0x00000001,
    TagGetrev   = 0x00010002,

    TagGetmac   = 0x00010003,
    TagGetram   = 0x00010005,

    TagGetpower = 0x00020001,
    TagSetpower = 0x00028001,
        Powerwait   = 1<<1,

    TagGetclkspd= 0x00030002,
    TagGetclkmax= 0x00030004,
    TagSetclkspd= 0x00038002,

    TagGettemp  = 0x00030006,

    TagFballoc  = 0x00040001,
    TagFbfree   = 0x00048001,
    TagFbblank  = 0x00040002,

    TagGetres   = 0x00040003,
    TagSetres   = 0x00048003,
    TagGetvres  = 0x00040004,
    TagSetvres  = 0x00048004,
    TagGetdepth = 0x00040005,
    TagSetdepth = 0x00048005,
    TagGetrgb   = 0x00044006,
    TagSetrgb   = 0x00048006,
};
@


<<struct Prophdr(arm)>>=
struct Prophdr {
    u32int  len;
    u32int  req;
    u32int  tag;
    u32int  tagbuflen;
    u32int  taglen;
    u32int  data[1];
};
@

<<function vcwrite(arm)>>=
static void
vcwrite(uint chan, int val)
{
    u32int *r;

    r = (u32int*)MAILBOX + NRegs;
    val &= ~ChanMask;
    while(r[Status] & Full)
        ;
    arch_coherence();
    r[Write] = val | chan;
}
@

<<function vcread(arm)>>=
static int
vcread(uint chan)
{
    u32int *r;
    int x;

    r = (u32int*)MAILBOX;
    do{
        while(r[Status]&Empty)
            ;
        arch_coherence();
        x = r[Read];
    }while((x&ChanMask) != chan);
    return x & ~ChanMask;
}
@

<<function vcreq(arm)>>=
/*
 * Property interface
 */

static int
vcreq(int tag, void *buf, int vallen, int rsplen)
{
    uintptr r;
    int n;
    Prophdr *prop = (Prophdr*)(VCBUFFER);
    uintptr aprop;
    static bool busaddr = true;

    if(rsplen < vallen)
        rsplen = vallen;
    rsplen = (rsplen+3) & ~3;

    n = sizeof(Prophdr) + rsplen + 8;
    memset(prop, 0, n);
    prop->len = n;
    prop->req = Req;
    prop->tag = tag;
    prop->tagbuflen = rsplen;
    prop->taglen = vallen;
    if(vallen > 0)
        memmove(prop->data, buf, vallen);
    cachedwbinvse(prop, prop->len);
    for(;;){
        aprop = busaddr? dmaaddr(prop) : PTR2UINT(prop);
        vcwrite(ChanProps, aprop);
        r = vcread(ChanProps);
        if(r == aprop)
            break;
        if(!busaddr)
            return -1;
        busaddr = false;
    }
    if(prop->req == RspOk &&
       prop->tag == tag &&
       (prop->taglen&TagResp)) {
        if((n = prop->taglen & ~TagResp) < rsplen)
            rsplen = n;
        memmove(buf, prop->data, rsplen);
    }else
        rsplen = -1;

    return rsplen;
}
@






<<function getethermac(arm)>>=
/*
 * Get ethernet address (as hex string)
 *   [not reentrant]
 */
char *
getethermac(void)
{
    uchar ea[8];
    char *p;
    int i;
    static char buf[16];

    memset(ea, 0, sizeof ea);
    vcreq(TagGetmac, ea, 0, sizeof ea);
    p = buf;
    for(i = 0; i < 6; i++)
        p += sprint(p, "%.2x", ea[i]);
    return buf;
}
@


<<enum Clock(arm)>>=
enum {
    ClkEmmc     = 1,
    ClkUart,
    ClkArm,
    ClkCore,
    ClkV3d,
    ClkH264,
    ClkIsp,
    ClkSdram,
    ClkPixel,
    ClkPwm,
};
@

<<function getclkrate(arm)>>=
/*
 * Get clock rate
 */
ulong
getclkrate(int clkid)
{
    u32int buf[2];

    buf[0] = clkid;
    if(vcreq(TagGetclkspd, buf, sizeof(buf[0]), sizeof(buf)) != sizeof buf)
        return 0;
    return buf[1];
}
@


<<function setclkrate(arm)>>=
/*
 * Set clock rate to hz (or max speed if hz == 0)
 */
void
setclkrate(int clkid, ulong hz)
{
    u32int buf[2];

    buf[0] = clkid;
    if(hz != 0)
        buf[1] = hz;
    else if(vcreq(TagGetclkmax, buf, sizeof(buf[0]), sizeof(buf)) != sizeof buf)
        return;
    vcreq(TagSetclkspd, buf, sizeof(buf), sizeof(buf));
}
@



<<function getcputemp(arm)>>=
/*
 * Get cpu temperature
 */
uint
getcputemp(void)
{
    u32int buf[2];

    buf[0] = 0;
    if(vcreq(TagGettemp, buf, sizeof(buf[0]), sizeof buf) != sizeof buf)
        return 0;
    return buf[1];
}
@


%-------------------------------------------------------------

<<arch/arm/vcore.c>>=
<<kernel basic includes>>

/*
 * Mailbox interface with videocore gpu
 */
<<constant MAILBOX(arm)>>

typedef struct Fbinfo Fbinfo;
typedef struct Prophdr Prophdr;

<<enum _anon_ (arch/arm/vcore.c)(arm)>>
<<enum _anon_ (arch/arm/vcore.c)2(arm)>>

<<enum _anon_ (arch/arm/vcore.c)3(arm)>>

<<enum _anon_ (arch/arm/vcore.c)4(arm)>>

<<struct Fbinfo(arm)>>


<<struct Prophdr(arm)>>

<<function vcwrite(arm)>>

<<function vcread(arm)>>

<<function vcreq(arm)>>

<<function fbdefault(arm)>>

<<function fbinit(arm)>>

<<function fbblank(arm)>>

<<function setpower(arm)>>

<<function getpower(arm)>>

<<function getethermac(arm)>>

<<function getboardrev(arm)>>

<<function getfirmware(arm)>>

<<function getramsize(arm)>>

<<function getclkrate(arm)>>

<<function setclkrate(arm)>>

<<function getcputemp(arm)>>
@


\section{[[concurrency/arm/]]}

\subsection*{[[concurrency/arm/spl.s]]}

<<concurrency/arm/spl.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<function arch_splhi(arm)>>

<<function arch_spllo(arm)>>

<<function arch_spllx(arm)>>

TEXT spldone(SB), 1, $0             /* end marker for devkprof.c */
    RET

<<function arch_islo(arm)>>


<<function arm_arch_coherence(arm)>>


// FIQ
<<function splfhi(arm)>>

@
%$

\subsection*{[[concurrency/arm/tas_raspi1.s]]}

<<concurrency/arm/tas_raspi1.s>>=
TEXT    _tas(SB), $-4
<<function arch_tas(raspberry pi1)(arm)>>
@
%$
\t _tas used?? remove? used by libc?

\subsection*{[[concurrency/arm/tas_raspi2.s]]}

<<concurrency/arm/tas_raspi2.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<instruction DMB(arm)>>
        
/* tas/cas strex debugging limits; started at 10000 */
#define MAXSC 100000

TEXT    _tas(SB), $-4           /* _tas(ulong *) */
<<function arch_tas(raspberry pi2)(arm)>>
@
%$
\t _tas used?? remove? used by libc?

\subsection*{[[concurrency/arm/concurrency_raspi1.c]]}

<<function ainc(arm)>>=
// overwrite libc!
int
ainc(int *p)
{
    int s, v;

    s = arch_splhi();
    v = ++*p;
    arch_splx(s);
    return v;
}
@
% otherwise ainc use Lock
\t which code in the kernel use ainc? We link with libc but which
% function uses ainc?

<<function adec(arm)>>=
int
adec(int *p)
{
    int s, v;

    s = arch_splhi();
    v = --*p;
    arch_splx(s);
    return v;
}
@


%-------------------------------------------------------------

<<concurrency/arm/concurrency_raspi1.c>>=
/*
 * atomic ops
 * make sure that we don't drag in the C library versions
 */
<<kernel basic includes>>

<<function arch_xdec(arm)>>

<<function arch_xinc(arm)>>


<<function ainc(arm)>>

<<function adec(arm)>>


<<function cas32(arm)>>

<<function arch_cmpswap(raspberry pi1)(arm)>>
@

\subsection*{[[concurrency/arm/concurrency_raspi2.c]]}

%-------------------------------------------------------------

<<concurrency/arm/concurrency_raspi2.c>>=
<<kernel basic includes>>

extern long _xdec(long *p);
extern long _xinc(long *p);

// use libc version?? ok??
long
arch_xdec(long *p)
{
  return _xdec(p);
}

void
arch_xinc(long *p)
{
  _xinc(p);
}

int
arch_cmpswap(long *addr, long old, long new)
{
    return cas((ulong*)addr, old, new);
}
@
\t clean those _xinc vs arch_xinc

\section{[[core/arm/]]}

\subsection*{[[core/arm/dat.h]]}

<<constant STAGESIZE(arm)>>=
// was a default in portdat.h
#define STAGESIZE 64 // for struct Uart
@


%-------------------------------------------------------------

<<core/arm/dat.h>>=
// pad's memory pointers (used in Lock so must be early)
<<pad memory pointer types(arm)>>

#include "dat_forward.h"
#include "../port/portdat_forward.h"
<<constant STAGESIZE(arm)>>

<<dat.h includes(arm)>>

// DO NOT switch those declarations. 5c allocates R10
// for the first 'extern register' declaration seen in a file
// and R9 for the second one. See Compiler.nw.
// Then mem.h relies on this to define the UP and CPU macros used
// inside assembly code.
<<global cpu(arm)>>
<<global up(arm)>>

// in main.c (used in mmu.c)
extern ulong memsize;

<<constant KMESGSIZE(arm)>>

// TODO: put that in portdat.h or in netif.h?
#pragma varargck  type  "I" uchar*
#pragma varargck  type  "V" uchar*
#pragma varargck  type  "E" uchar*
#pragma varargck  type  "M" uchar*
@


\subsection*{[[core/arm/dat_core.h]]}

%-------------------------------------------------------------

<<core/arm/dat_core.h>>=

<<type PTE(arm)>>

<<struct Arch_Cpu(arm)>>
@


\subsection*{[[core/arm/dat_forward.h]]}


%-------------------------------------------------------------

<<core/arm/dat_forward.h>>=
// could be in portdat_forward.h
typedef struct Arch_FPsave  Arch_FPsave;
typedef struct Ureg Ureg;
#pragma incomplete Ureg

typedef struct Soc Soc;
@
%old: typedef struct MMMU MMMU;

\subsection*{[[core/arm/fns.h]]}


%-------------------------------------------------------------

<<core/arm/fns.h>>=

<<fns.h includes(arm)>>

// not classified yet
extern void arch_cpuidprint(void);

// different signatures in archs or macro so cant factorize in portdat_xxx.h
extern void  arch_touser(uintptr);
extern int   arch_cmpswap(long*, long, long);
<<macro getpgcolor(arm)>>
<<macro arch_cycles(arm)>>
<<macro arch_countpagerefs(arm)>>
<<macro arch_intrenable(arm)>>

extern int arch__notify(Ureg*);
extern void arch__kexit(Ureg*);

extern void dumpregs(Ureg*);


extern void mmuinit1(void*);
extern void mmuinvalidate(void);
extern void mmuinvalidateaddr(u32int);


extern void irqenable(int, void (*)(Ureg*, void*), void*);

extern void intrcpushutdown(void);
extern void intrshutdown(void);
extern void intrsoff(void);


extern void archreboot(void);
extern void archreset(void);

extern void clockinit(void);
extern void clockshutdown(void);


extern int cas32(void*, u32int, u32int);
extern int cas(ulong*, ulong, ulong);

extern char *cputype2name(char *buf, int size);

extern void armtimerset(int);

extern void cachedwb(void);
extern void cachedwbinv(void);
extern void cachedinvse(void*, int);
extern void cachedwbse(void*, int);
extern void cachedwbinvse(void*, int);
extern void cacheiinv(void);
extern void cacheuwbinv(void);


// coproc.c
extern ulong cprd(int cp, int op1, int crn, int crm, int op2);
extern ulong cprdsc(int op1, int crn, int crm, int op2);
extern void cpwr(int cp, int op1, int crn, int crm, int op2, ulong val);
extern void cpwrsc(int op1, int crn, int crm, int op2, ulong val);

// dma.c
extern uintptr dmaaddr(void *va);
extern void dmastart(int, int, int, void*, void*, int);
extern int dmawait(int);

// vcore.c
extern int fbblank(int);
extern void* fbinit(bool, int*, int*, int*);


extern void fpon(void);
extern ulong fprd(int fpreg);
extern void fprestreg(int fpreg, uvlong val);
extern void fpsave(Arch_FPsave *);
extern ulong fpsavereg(int fpreg, uvlong *fpp);
extern void fpwr(int fpreg, ulong val);

extern u32int fsrget(void);
extern u32int farget(void);
extern u32int ifsrget(void);

// vcore.c
extern uint getboardrev(void);
extern ulong getclkrate(int);
extern uint getcputemp(void);
extern char *getethermac(void);
extern uint getfirmware(void);
extern void getramsize(Confmem*);

extern int getncpus(void);
extern int getpower(int);


extern void gpiosel(uint, int);
extern void gpiopullup(uint);
extern void gpiopulloff(uint);
extern void gpiopulldown(uint);

extern void i2cread(uint, void*, int);
extern void i2cwrite(uint, void*, int);


extern void okay(int);

extern int l2ap(int);
extern void l2cacheuwbinv(void);

<<macro sdfree(arm)>>
<<macro sdmalloc(arm)>>

extern void setclkrate(int, ulong);
extern void setpower(int, int);
extern void setr13(int, u32int*);

extern void spirw(uint, void*, int);
extern int splfhi(void);
extern int splflo(void);

extern int startcpus(uint);
extern void stopcpu(uint);


extern void uartconsinit(void);
extern void vectors(void);
extern void vtable(void);

extern void wdogoff(void);

/*
 * floating point emulation
 */
extern int fpiarm(Ureg*);
extern int fpudevprocio(Proc*, void*, long, uintptr, int);
extern void fpuinit(void);
extern void fpunoted(void);
extern void fpunotify(Ureg*);
extern void fpuprocrestore(Proc*);
extern void fpuprocsave(Proc*);
extern void fpusysprocsetup(Proc*);
extern void fpusysrfork(Ureg*);
extern void fpusysrforkchild(Proc*, Ureg*, Proc*);
extern int fpuemu(Ureg*);

/*
 * Miscellaneous machine dependent stuff.
 */
extern char* getenv(char*, char*, int);

uintptr mmukmap(uintptr, uintptr, usize);
uintptr mmukunmap(uintptr, uintptr, usize);


<<macro PTR2UINT(arm)>>
<<macro UINT2PTR(arm)>>

<<macro KADDR(arm)>>
<<macro PADDR(arm)>>

@
%dead: ucalloc not used
% extern void* ucalloc(usize);
% extern Block* ucallocb(int);
% extern void* ucallocalign(usize size, int align, int span);
% extern void ucfree(void*);
% extern void ucfreeb(Block*);
% // for ucalloc
% extern void* mmuuncache(void*, usize);
%dead:
% extern void sysprocsetup(Proc*);


\section{[[buses/arm/]]}

\section{[[devices/]]}

\subsection*{[[devices/keyboard/arm/kbd.c]]}

%-------------------------------------------------------------

<<devices/keyboard/arm/kbd.c>>=
<<kernel basic includes>>

// In the Raspberry Pi, the keyboard is handled by usbd
// with help from /dev/kbin (which then calls functions from portkbd
// which calls arch_setleds below).

<<function arch_setleds(arm)>>
@


\subsection*{[[devices/mouse/arm/mouse.c]]}

<<devices/mouse/arm/mouse.c>>=
<<kernel basic includes>>

// In the Raspberry Pi, the mouse is handled by usbd
// with help from /dev/mousein.

// empty callbacks for portmouse.c

void arch_ps2mouse(void) { }
void arch_setaccelerated(void) { }
void arch_setlinear(void) { }
void arch_setres(int n) { USED(n); }
void arch_setintellimouse(void) { }
void arch_resetmouse(void) { }
@

\subsection*{[[devices/sys/arm/devarch.c]]}

<<enum _anon_ (devices/sys/arm/devarch.c)(arm)>>=
enum {
    Qdir = 0,
    Qbase,

    Qmax = 16,
};
@

<<global readfn(arm)>>=
static Rdwrfn *readfn[Qmax];
@

<<global writefn(arm)>>=
static Rdwrfn *writefn[Qmax];
@

<<global archdir(arm)>>=
static Dirtab archdir[Qmax] = {
    ".",        { Qdir, 0, QTDIR }, 0,  0555,
};
@

<<global archwlock(arm)>>=
Lock archwlock; /* the lock is only for changing archdir */
@

<<global narchdir(arm)>>=
int narchdir = Qbase;
@

<<function addarchfile(arm)>>=
/*
 * Add a file to the #P listing.  Once added, you can't delete it.
 * You can't add a file with the same name as one already there,
 * and you get a pointer to the Dirtab entry so you can do things
 * like change the Qid version.  Changing the Qid path is disallowed.
 */
Dirtab*
addarchfile(char *name, int perm, Rdwrfn *rdfn, Rdwrfn *wrfn)
{
    int i;
    Dirtab d;
    Dirtab *dp;

    memset(&d, 0, sizeof d);
    strcpy(d.name, name);
    d.perm = perm;

    lock(&archwlock);
    if(narchdir >= Qmax){
        unlock(&archwlock);
        return nil;
    }

    for(i=0; i<narchdir; i++)
        if(strcmp(archdir[i].name, name) == 0){
            unlock(&archwlock);
            return nil;
        }

    d.qid.path = narchdir;
    archdir[narchdir] = d;
    readfn[narchdir] = rdfn;
    writefn[narchdir] = wrfn;
    dp = &archdir[narchdir++];
    unlock(&archwlock);

    return dp;
}
@

<<function archattach(arm)>>=
static Chan*
archattach(char* spec)
{
    return devattach('P', spec);
}
@

<<function archwalk(arm)>>=
Walkqid*
archwalk(Chan* c, Chan *nc, char** name, int nname)
{
    return devwalk(c, nc, name, nname, archdir, narchdir, devgen);
}
@

<<function archstat(arm)>>=
static int
archstat(Chan* c, uchar* dp, int n)
{
    return devstat(c, dp, n, archdir, narchdir, devgen);
}
@

<<function archopen(arm)>>=
static Chan*
archopen(Chan* c, int omode)
{
    return devopen(c, omode, archdir, narchdir, devgen);
}
@

<<function archclose(arm)>>=
static void
archclose(Chan*)
{
}
@

<<function archread(arm)>>=
static long
archread(Chan *c, void *a, long n, vlong offset)
{
    Rdwrfn *fn;

    switch((ulong)c->qid.path){
    case Qdir:
        return devdirread(c, a, n, archdir, narchdir, devgen);

    default:
        if(c->qid.path < narchdir && (fn = readfn[c->qid.path]))
            return fn(c, a, n, offset);
        error(Eperm);
        break;
    }

    return 0;
}
@

<<function archwrite(arm)>>=
static long
archwrite(Chan *c, void *a, long n, vlong offset)
{
    Rdwrfn *fn;

    if(c->qid.path < narchdir && (fn = writefn[c->qid.path]))
        return fn(c, a, n, offset);
    error(Eperm);

    return 0;
}
@

<<global archdevtab(arm)>>=
Dev archdevtab = {
    .dc = 'P',
    .name = "arch",

    .reset = devreset,
    .init = archinit,
    .shutdown = devshutdown,
    .attach = archattach,
    .walk = archwalk,
    .stat = archstat,
    .open = archopen,
    .create = devcreate,
    .close = archclose,
    .read = archread,
    .bread = devbread,
    .write = archwrite,
    .bwrite = devbwrite,
    .remove = devremove,
    .wstat = devwstat,
};
@

<<function cputyperead(arm)>>=
static long
cputyperead(Chan*, void *a, long n, vlong offset)
{
    char name[64], str[128];

    cputype2name(name, sizeof name);
    snprint(str, sizeof str, "ARM %s %d\n", name, cpu->cpumhz);
    return readstr(offset, a, n, str);
}
@

<<function cputempread(arm)>>=
static long
cputempread(Chan*, void *a, long n, vlong offset)
{
    char str[16];

    snprint(str, sizeof str, "%ud\n", (getcputemp()+500)/1000);
    return readstr(offset, a, n, str);
}
@

<<function archinit(arm)>>=
void
archinit(void)
{
    addarchfile("cputype", 0444, cputyperead, nil);
    addarchfile("cputemp", 0444, cputempread, nil);
}
@


%-------------------------------------------------------------

<<devices/sys/arm/devarch.c>>=
<<kernel basic includes>>

#include "io.h"

<<enum _anon_ (devices/sys/arm/devarch.c)(arm)>>

typedef long Rdwrfn(Chan*, void*, long, vlong);
void archinit(void);

<<global readfn(arm)>>
<<global writefn(arm)>>

<<global archdir(arm)>>

<<global archwlock(arm)>>
<<global narchdir(arm)>>

<<function addarchfile(arm)>>

<<function archattach(arm)>>

<<function archwalk(arm)>>

<<function archstat(arm)>>

<<function archopen(arm)>>

<<function archclose(arm)>>

<<function archread(arm)>>

<<function archwrite(arm)>>

<<global archdevtab(arm)>>

<<function cputyperead(arm)>>

<<function cputempread(arm)>>

<<function archinit(arm)>>
@


\section{[[init/arm/]]}

\subsection*{[[init/arm/start.s]]}

<<init/arm/start.s>>=
/*
 * Common startup for armv6 and armv7
 * The rest of l.s has been moved to armv[67].s
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<function _start(arm)>>
@

\subsection*{[[init/arm/startv6.s]]}

<<init/arm/startv6.s>>=
/*
 * Broadcom bcm2835 SoC, as used in Raspberry Pi
 * arm1176jzf-s processor (armv6)
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<function armstart(raspberry pi1)(arm)>>

<<function _startpg(raspberry pi1)(arm)>>


        
<<function arch_idlehands(raspberry pi1)(arm)>>
@
%$

\subsection*{[[init/arm/startv7.s]]}

<<init/arm/startv7.s>>=
/*
 * Broadcom bcm2836 SoC, as used in Raspberry Pi 2
 * 4 x Cortex-A7 processor (armv7)
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<instruction WFI_EQ(arm)>>

<<function armstart(raspberry pi2)(arm)>>

<<function _startpg(raspberry pi2)(arm)>>

<<function cpureset(raspberry pi2)(arm)>>

<<function _startpg2(raspberry pi2)(arm)>>

<<function cpidget(raspberry pi2)(arm)>>

        
<<function arch_idlehands(raspberry pi2)(arm)>>

@
%$
%dead: 
% TEXT cpctget(SB), 1, $-4            /* cache type */
%     MRC CpSC, 0, R0, C(CpID), C(CpIDidct), CpIDct
%     RET

\subsection*{[[init/arm/main.c]]}


<<function getconf(arm)>>=
char*
getconf(char *name)
{
    USED(name);
    //int i;
    // 
    //i = findconf(name);
    //if(i >= 0)
    //  return confval[i];
    return nil;
}
@


<<function main_arch_isaconfig(arm)>>=
/*
 * stub for ../omap/devether.c
 */
int
main_arch_isaconfig(char *class, int ctlrno, ISAConf *isa)
{
    char cc[32], *p;
    int i;

    if(strcmp(class, "ether") != 0)
        return 0;
    snprint(cc, sizeof cc, "%s%d", class, ctlrno);
    p = getconf(cc);
    if(p == nil)
        return (ctlrno == 0);
    isa->type = "";
    isa->nopt = tokenize(p, isa->opt, NISAOPT);
    for(i = 0; i < isa->nopt; i++){
        p = isa->opt[i];
        if(cistrncmp(p, "type=", 5) == 0)
            isa->type = p + 5;
    }
    return 1;
}
@



%-------------------------------------------------------------

<<init/arm/main.c>>=
<<kernel basic includes>>

#include "io.h"
// for mainmem and imagmem
#include <pool.h>

// initcode binary
#include "init.h"

// rebootcode binary
#include "reboot.h"

// in portscreen.h
extern void swcursor_init(void);

<<constant Minfirmrev(arm)>>
<<constant Minfirmdate(arm)>>


// part of a trick to remove some backward dependencies
int devcons_print(char*, ...);
int devcons_iprint(char*, ...);
int devcons_pprint(char*, ...);
void devcons_panic(char*, ...);
void devcons__assert(char*);
void proc_dumpaproc(Proc *p);
void proc_error(char*);
void proc_nexterror(void);
void proc_sched(void);
void proc_ready(Proc*);
void proc_sleep(Rendez*, int(*)(void*), void*);
void proc_tsleep(Rendez *r, int (*fn)(void*), void *arg, ulong ms);
Proc* proc_wakeup(Rendez*);
void proc_pexit(char *exitstr, bool freemem);
Proc* proc_proctab(int i);
int proc_postnote(Proc *p, int dolock, char *n, int flag);
void chan_cclose(Chan *c);

uvlong clock_arch_fastticks(uvlong *hz);
void clock_arch_delay(int millisecs);
void clock_arch_microdelay(int microsecs);
void trap_arch_dumpstack(void);
void arm_arch_coherence(void);
void main_arch_exit(int ispanic);
int  main_arch_isaconfig(char *class, int ctlrno, ISAConf *isa);

//*****************************************************************************
// Configuration
//*****************************************************************************
// See globals in portdat_globals.h

// <conf>.c
extern  Dev*  conf_devtab[];
extern  char*   conffile;

<<function getconf(arm)>>

//*****************************************************************************
// Boot parameters, see bootconf.c (not used by pad)
//*****************************************************************************

//*****************************************************************************
// Cpu init
//*****************************************************************************
<<function arch__cpuinit(arm)>>

<<function arch__cpu0init(arm)>>

<<function machon(arm)>>

//*****************************************************************************
// Conf init
//*****************************************************************************

<<global memsize(arm)>>

<<function arch__confinit(arm)>>

//*****************************************************************************
// First process init
//*****************************************************************************

<<global sp(arm)>>

// kernel space instructions executed by first process
<<function init0(arm)>>

// user space instructions executed by first process
// see initcode in init.h (comes from ../port/initcode.c and init9.s

extern uintptr bootargs(uintptr base);
<<function arch__userinit(arm)>>


//*****************************************************************************
// Shutdown/reboot
//*****************************************************************************

<<function shutdown (init/arm/main.c)(arm)>>

<<function main_arch_exit(arm)>>

<<function arch_reboot(arm)>>

//*****************************************************************************
// Misc
//*****************************************************************************

<<function main_arch_isaconfig(arm)>>

<<function arch_memorysummary(arm)>>

//*****************************************************************************
// Main entry point!
//*****************************************************************************

<<function launchinit(arm)>>

<<function main(arm)>>
@


\subsection*{[[init/arm/raspi1.c]]}


<<function archether(raspberry pi1)(arm)>>=
int
archether(unsigned ctlrno, Ether *ether)
{
    ether->type = "usb";
    ether->ctlrno = ctlrno;
    ether->irq = -1;
    ether->nopt = 0;
    return 1;
}
@

%-------------------------------------------------------------

<<init/arm/raspi1.c>>=
/*
 * bcm2835 (e.g. original raspberry pi) architecture-specific stuff
 */
<<kernel basic includes>>

#include "io.h"
#include "arm.h"

#include "../port/netif.h"
#include "../port/etherif.h"

<<global soc(raspberry pi1)(arm)>>

    
<<function cputype2name(raspberry pi1)(arm)>>

<<function arch_cpuidprint(raspberry pi1)(arm)>>

<<function getncpus(raspberry pi1)(arm)>>

<<function startcpus(raspberry pi1)(arm)>>


<<function archether(raspberry pi1)(arm)>>

<<function l2ap(raspberry pi1)(arm)>>
@


\subsection*{[[init/arm/raspi2.c]]}



%-------------------------------------------------------------

<<init/arm/raspi2.c>>=
/*
 * bcm2836 (e.g.raspberry pi 2) architecture-specific stuff
 */
<<kernel basic includes>>

#include "io.h"
#include "arm.h"

#include "../port/netif.h"
#include "../port/etherif.h"

typedef struct Mbox Mbox;
typedef struct Mboxes Mboxes;

<<constant ARMLOCAL(arm)>>

<<global soc(raspberry pi2)(arm)>>


<<struct Mbox(arm)>>
<<struct Mboxes(arm)>>

enum {
    Mboxregs    = 0x80
};

static Lock startlock[MAXCPUS + 1];

// in startv7.s
extern u32int cpidget(void);

<<function cputype2name(raspberry pi2)(arm)>>

<<function arch_cpuidprint(raspberry pi2)(arm)>>

<<function getncpus(raspberry pi2)(arm)>>

<<function startcpu(raspberry pi2)(arm)>>

<<function startcpus(raspberry pi2)(arm)>>


int
archether(unsigned ctlrno, Ether *ether)
{
    ether->type = "usb";
    ether->ctlrno = ctlrno;
    ether->irq = -1;
    ether->nopt = 0;
    return 1;
}

<<function l2ap(raspberry pi2)(arm)>>


// in main.c
extern void arch__cpuinit(void);
extern void machon(uint);

<<function cpustart(raspberry pi2)(arm)>>

@

\subsection*{[[init/user/preboot/arm/init9.s]]}



\subsection*{[[init/arm/rebootcode.s]]}

<<init/arm/rebootcode.s>>=
/*
 * armv6/armv7 reboot code
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<constant PTEDRAM(arm)>>

<<instruction WFI(arm)>>
<<instruction WFE(arm)>>

<<function main(rebootcode.s)(arm)>>
@
%$

\section{[[memory/arm/]]}

\subsection*{[[memory/arm/dat_memory.h]]}

%-------------------------------------------------------------

<<memory/arm/dat_memory.h>>=

/*
 *  MMU stuff in proc
 */
<<constant NCOLOR(arm)>>

<<struct Arch_Proc(arm)>>

/*
 * Fake kmap.
 */
typedef void        Arch_KMap;
<<macro VA(arm)>>

@


\subsection*{[[memory/arm/mem.h]]}


%-------------------------------------------------------------

<<memory/arm/mem.h>>=
/*
 * Memory and machine-specific definitions.  Used in C and assembler.
 */

<<constant KiB(arm)>>
<<constant MiB(arm)>>
<<constant GiB(arm)>>

/*
 * Sizes
 */
<<constant BY2PG(arm)>>
<<constant PGSHIFT(arm)>>

<<constant MAXCPUS(arm)>>
<<constant CPUSIZE(arm)>>
<<constant L1SIZE(arm)>>

<<macro STACKALIGN(arm)>>

/*
 * Magic registers
 */
<<constant UP(arm)>>
<<constant CPU(arm)>>

/*
 * Address spaces.
 * KTZERO is used by kprof and dumpstack (if any).
 *
 * KZERO is mapped to physical 0 (start of ram).
 *
 * vectors are at 0, plan9.ini is at KZERO+256 and is limited to 16K by
 * devenv.
 */
<<constant KSEG0(arm)>>
<<constant KSEGM(arm)>>

<<constant KZERO(arm)>>

<<constant CONFADDR(arm)>>

// L1 must be 16KiB aligned so this dictates the organization below
<<constant CPUADDR(arm)>>
<<constant L2(arm)>>
<<constant VCBUFFER(arm)>>
<<constant FIQSTKTOP(arm)>>
<<constant L1(arm)>>

<<constant KTZERO(arm)>>

<<constant VIRTIO(arm)>>
<<constant FRAMEBUFFER(arm)>>

<<constant UZERO(arm)>>
<<constant UTZERO(arm)>>
<<macro UTROUND(arm)>>
<<constant USTKTOP(arm)>>
<<constant USTKSIZE(arm)>>
<<constant TSTKTOP(arm)>>
<<constant TSTKSIZ(arm)>>

<<constant REBOOTADDR(arm)>>

/*
 * Legacy...
 */
//old: was 64 in bcm-latest, but then get panic in _allocb
<<constant BLOCKALIGN(arm)>>
<<constant KSTACK(arm)>>

/*
 * Sizes
 */
<<constant BI2BY(arm)>>
<<constant BY2WD(arm)>>
<<constant BY2V(arm)>>

<<constant PAGETABMAPMEM(arm)>>
<<constant PAGETABSIZE(arm)>>
<<constant PAGEDIRSIZE(arm)>>
<<constant SMALLPAGEDIRSIZE(arm)>>
<<macro PPN(arm)>>

/*
 * Physical machine information from here on.
 *  PHYS addresses as seen from the arm cpu.
 *  BUS  addresses as seen from the videocore gpu.
 */
<<constant PHYSDRAM(arm)>>
<<constant IOSIZE(arm)>>
@


\subsection*{[[memory/arm/mmu.c]]}


<<enum _anon_ (memory/arm/mmu.c)(arm)>>=
enum {
<<constant L1lo(arm)>>
<<constant L1hi(arm)>>
};
@


%-------------------------------------------------------------

<<memory/arm/mmu.c>>=
<<kernel basic includes>>
#include "arm.h"

<<macro L1X(arm)>>
<<macro L2X(arm)>>
<<macro L2AP(arm)>>

<<constant L1ptedramattrs(arm)>>
<<constant L2ptedramattrs(arm)>>

<<enum _anon_ (memory/arm/mmu.c)(arm)>>

<<function mmuinit(arm)>>

<<function mmuinit1(arm)>>

<<function mmul2empty(arm)>>

<<function mmul1empty(arm)>>

<<function arch_mmuswitch(arm)>>

<<function arch_flushmmu(arm)>>

<<function arch_mmurelease(arm)>>

<<function arch_putmmu(arm)>>

<<function arch_cankaddr(arm)>>

<<function mmukmap(arm)>>


<<function arch_checkmmu(arm)>>

<<function arch_kmap(arm)>>

<<function arch_kunmap(arm)>>
@

%dead: used by ucalloc that I do not use
% <<function mmuuncache(arm)>>=
% void*
% mmuuncache(void* v, usize size)
% {
%     int x;
%     PTE *pte;
%     uintptr va;
% 
%     /*
%      * Simple helper for ucalloc().
%      * Uncache a Section, must already be
%      * valid in the MMU.
%      */
%     va = PTR2UINT(v);
%     assert(!(va & (1*MiB-1)) && size == 1*MiB);
% 
%     x = L1X(va);
%     pte = &cpu->mmul1[x];
%     if((*pte & (Fine|Section|Coarse)) != Section)
%         return nil;
%     *pte &= ~L1ptedramattrs;
%     *pte |= L1sharable;
%     mmuinvalidateaddr(va);
%     cachedwbinvse(pte, 4);
% 
%     return v;
% }
% @


\subsection*{[[memory/arm/mmuinvalidate.s]]}

<<memory/arm/mmuinvalidate.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<function mmuinvalidate(arm)>>

<<function mmuinvalidateaddr(arm)>>
@
%$


\subsection*{[[memory/arm/cache_raspi1.s]]}


<<memory/arm/cache_raspi1.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<constant CACHELINESZ(raspberry pi1)(ram)>>

<<function cachexxx(raspberry pi1)(ram)>>
                
@
%$

\subsection*{[[memory/arm/cache_raspi2.s]]}


<<memory/arm/cache_raspi2.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<constant CACHELINESZ(raspberry pi2)(ram)>>

<<function cachexxx(raspberry pi2)(ram)>>
       
@

\section{[[interrupts/arm/]]}

\subsection*{[[interrupts/arm/trap.c]]}

<<enum _anon_ (interrupts/arm/trap.c)(arm)>>=
enum {
    Debug = 0,

    <<constant Nvec(arm)>>
    <<constant Fiqenable(arm)>>

    <<constant Localtimerint(arm)>>
    <<constant Localmboxint(arm)>>
    <<constant Localintpending(arm)>>
};
@
% >> >>


%-------------------------------------------------------------

<<interrupts/arm/trap.c>>=
/*
 * traps, exceptions, interrupts, system calls.
 */
<<kernel basic includes>>
#include "io.h"
#include "ureg.h"
#include "arm.h"

<<constant INTREGS(arm)>>
<<constant LOCALREGS(arm)>>

typedef struct Intregs Intregs;
typedef struct Vctl Vctl;
typedef struct Vpage0 Vpage0;

<<enum _anon_ (interrupts/arm/trap.c)(arm)>>

<<struct Vpage0(arm)>>

<<struct Intregs(arm)>>

<<struct Vctl(arm)>>

<<global vctllock(arm)>>

<<global vctl(arm)>>

<<global vfiq(arm)>>

<<global trapnames(arm)>>

<<function arch__trapinit(arm)>>

<<function intrcpushutdown(arm)>>

<<function intrsoff(arm)>>

<<function intrshutdown(arm)>>

<<function intrtime(arm)>>


<<function irq(arm)>>

<<function fiq(arm)>>

<<function irqenable(arm)>>

<<function trapname(arm)>>

<<function ckfaultstuck(arm)>>

<<function faultarm(arm)>>

<<function writetomem(arm)>>

<<function arch__trap(arm)>>

<<function isvalidaddr(arm)>>

<<function dumplongs(arm)>>

<<function dumpstackwithureg(arm)>>

<<function getpcsp(arm)>>

<<function arch_callwithureg(arm)>>

<<function trap_arch_dumpstack(arm)>>

<<function dumpregs(arm)>>
@

\subsection*{[[interrupts/arm/fault_helpers.s]]}

<<interrupts/arm/fault_helpers.s>>=
#include "mem.h"
#include "arm.h"

<<function fstget(arm)>>

<<function ifsrget(arm)>>

<<function farget(arm)>>

@
%$

\subsection*{[[interrupts/arm/lexception.s]]}

<<interrupts/arm/lexception.s>>=
/*
 * arm exception handlers
 */
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<global vectors(arm)>>

<<global vtable(arm)>>

<<function _vsvc(arm)>>

<<function _vund(arm)>>

<<function _vpabt(arm)>>

<<function _vdabt(arm)>>

<<function _virq(arm)>>

<<label _vswitch(arm)>>

<<function _vfiq(arm)>>

<<function setr13(arm)>>
@


\section{[[time/arm/]]}

\subsection*{[[time/arm/dat_time.h]]}


%-------------------------------------------------------------

<<time/arm/dat_time.h>>=
/*
 * Time.
 *
 * HZ should divide 1000 evenly, ideally.
 * 100, 125, 200, 250 and 333 are okay.
 */
<<constant Arch_HZ(arm)>>

// was vlong in x86
//typedef uvlong        Tval;
@



\subsection*{[[time/arm/clock.c]]}


<<enum _anon_ (time/arm/clock.c)(arm)>>=
enum {
    <<constant Localctl(arm)>>
    <<constant Prescaler(arm)>>

    <<constant SystimerFreq(arm)>>

    <<constant MaxPeriod(arm)>>
    <<constant MinPeriod(arm)>>
};
@
%dead:    Localintpending = 0x60,  
% dead and dup of stuff in trap.c



<<enum _anon_ (time/arm/clock.c)2(arm)>>=
enum {
    CntPrescaleShift= 16,   /* freq is sys_clk/(prescale+1) */
    CntPrescaleMask = 0xFF,
    CntEnable   = 1<<9,
    TmrDbgHalt  = 1<<8,
    TmrEnable   = 1<<7,
    TmrIntEnable    = 1<<5,
    TmrPrescale1    = 0x00<<2,
    TmrPrescale16   = 0x01<<2,
    TmrPrescale256  = 0x02<<2,
    CntWidth16  = 0<<1,
    CntWidth32  = 1<<1,

    /* generic timer (cortex-a7) */
    Enable  = 1<<0,
    Imask   = 1<<1,
    Istatus = 1<<2,
};
@



%-------------------------------------------------------------

<<time/arm/clock.c>>=
/*
 * bcm283[56] timers
 *  System timers run at 1MHz (timers 1 and 2 are used by GPU)
 *  ARM timer usually runs at 250MHz (may be slower in low power modes)
 *  Cycle counter runs at 700MHz (unless overclocked)
 *    All are free-running up-counters
 *  Cortex-a7 has local generic timers per cpu (which we run at 1MHz)
 *
 * Use system timer 3 (64 bits) for hzclock interrupts and fastticks
 *   For smp on bcm2836, use local generic timer for interrupts on cpu1-3
 * Use ARM timer (32 bits) for perfticks
 * Use ARM timer to force immediate interrupt
 * Use cycle counter for cycles()
 */
<<kernel basic includes>>
#include "io.h"
#include "ureg.h"
#include "arm.h"

<<constant SYSTIMERS(arm)>>
<<constant ARMTIMER(arm)>>
//TODO factorize in mem.h
<<constant ARMLOCAL(arm)>>

<<enum _anon_ (time/arm/clock.c)(arm)>>

typedef struct Systimers Systimers;
typedef struct Armtimer Armtimer;

<<struct Systimers(arm)>>

<<struct Armtimer(arm)>>

<<enum _anon_ (time/arm/clock.c)2(arm)>>

<<function clockintr(arm)>>

<<function localclockintr(arm)>>

<<function clockshutdown(arm)>>

<<function clockinit(arm)>>

<<function arch_timerset(arm)>>

<<function clock_arch_fastticks(arm)>>

<<function arch_perfticks(arm)>>

<<function armtimerset(arm)>>

<<function arch_us(arm)>>

<<function clock_arch_microdelay(arm)>>

<<function clock_arch_delay(arm)>>
@


\subsection*{[[time/arm/time_raspi1.s]]}

<<time/arm/time_raspi1.s>>=
#include "mem.h"
#include "arm.h"

<<function arch_lcycles(raspberry pi1)(arm)>>
@
%$

%dead:
% TEXT tmrget(SB), 1, $-4             /* local generic timer physical counter value */
%     MOVW    $0, R1              /* not in armv6 */
%     MOVW    R1, 0(R0)
%     MOVW    R1, 4(R0)
%     RET

\subsection*{[[time/arm/time_raspi2.s]]}


<<instruction MRRC(arm)>>=
#define MRRC(coproc, op, rd, rn, crm) \
    WORD $(0xec500000|(rn)<<16|(rd)<<12|(coproc)<<8|(op)<<4|(crm))
@

<<time/arm/time_raspi2.s>>=
#include "mem.h"
#include "arm.h"
#include "arminstr.ha"

<<function arch_lcycles(raspberry pi2)(arm)>>

@
%$

%dead:
% TEXT tmrget(SB), 1, $-4             /* local generic timer physical counter value */
%     MRRC(CpSC, 0, 1, 2, CpTIMER)
%     MOVM.IA [R1-R2], (R0)
%     RET

\section{[[processes/arm/]]}

\subsection*{[[processes/arm/dat_processes.h]]}

%-------------------------------------------------------------

<<processes/arm/dat_processes.h>>=

<<constant AOUT_MAGIC(arm)>>

<<enum _anon_ (arch/arm/dat_processes.h)(arm)>>

<<struct Arch_FPsave(arm)>>

@


\subsection*{[[processes/arm/arch.c]]}


%-------------------------------------------------------------

<<processes/arm/arch.c>>=
<<kernel basic includes>>

#include <tos.h>
#include "ureg.h"

#include "arm.h"

/*
 * A lot of this stuff doesn't belong here
 * but this is a convenient dumping ground for
 * later sorting into the appropriate buckets.
 */

<<function arch_userpc(arm)>>

<<function arch_dbgpc(arm)>>

<<function arch_userureg(arm)>>


<<function arch_setregisters(arm)>>

<<function arch_setkernur(arm)>>

<<function arch_validalign(arm)>>

<<function arch__kexit(arm)>>


<<function linkproc(arm)>>

<<function arch_kprocchild(arm)>>
@


\subsection*{[[processes/arm/vfp3.c]]}


%-------------------------------------------------------------

<<processes/arm/vfp3.c>>=
/*
 * VFPv2 or VFPv3 floating point unit
 */
<<kernel basic includes>>
#include "ureg.h"
#include "arm.h"

<<enum _anon_ (processes/arm/vfp3.c)(arm)>>

<<enum _anon_ (processes/arm/vfp3.c)2(arm)>>
<<enum _anon_ (processes/arm/vfp3.c)3(arm)>>
<<enum _anon_ (processes/arm/vfp3.c)4(arm)>>

<<function subarch(arm)>>

<<function implement(arm)>>

<<function havefp(arm)>>

<<function fpoff(arm)>>

<<function fpononly(arm)>>

<<function fpcfg(arm)>>

<<function fpinit(arm)>>

<<function fpon(arm)>>

<<function fpclear(arm)>>


<<function fpunotify(arm)>>

<<function fpunoted(arm)>>

<<function fpusysrfork(arm)>>

<<function fpusysrforkchild(arm)>>

<<function fpsave(arm)>>

<<function fprestore(arm)>>

<<function fpuprocsave(arm)>>

<<function fpuprocrestore(arm)>>

<<function fpusysprocsetup(arm)>>


<<function arch_procsetup(arm)>>

<<function arch_procsave(arm)>>

<<function arch_procrestore(arm)>>

<<function mathnote(arm)>>

<<function mathemu(arm)>>

<<function fpstuck(arm)>>

<<enum _anon_ (processes/arm/vfp3.c)5(arm)>>

<<function condok(arm)>>

/* instruction decoding */ // was in arm.h
<<macro ISCPOP(arm)>>
<<macro ISVFPOP(arm)>>

<<function fpuemu(arm)>>
@


\subsection*{[[processes/arm/lproc.s]]}

<<processes/arm/lproc.s>>=
#include "mem.h"
#include "arm.h"

<<function arch_touser(arm)>>

<<function arch__forkret(arm)>>
@
%$

\subsection*{[[processes/arm/switch.s]]}

<<processes/arm/switch.s>>=
<<function arch_setlabel(arm)>>

<<function arch_gotolabel(arm)>>

<<function getcallerpc(arm)>>

@
%$


\section{[[syscalls/arm/]]}

\subsection*{[[syscalls/arm/syscall.c]]}


%-------------------------------------------------------------

<<syscalls/arm/syscall.c>>=
<<kernel basic includes>>
#include "../port/systab.h"
#include <tos.h>
#include "ureg.h"
#include "arm.h"

typedef struct NFrame NFrame;
<<struct NFrame(arm)>>

<<function arch__noted(arm)>>

<<function arch__notify(arm)>>

<<function arch__syscall(arm)>>

<<function arch_execregs(arm)>>

<<function arch_forkchild(arm)>>
@

%dead:
% <<function sysprocsetup(arm)>>=
% void
% sysprocsetup(Proc* p)
% {
%     fpusysprocsetup(p);
% }
% @


\part{Extra Extra}

\subsection*{[[init/arm/bootconf.c]]}

<<enum _anon_ (init/arm/bootconf.c)(arm)>>=
enum {
    /* space for syscall args, return PC, top-of-stack struct */
    Ustkheadroom    = sizeof(Sargs) + sizeof(uintptr) + sizeof(Tos),
};
@

<<constant CONFADDR(arm)>>=
#define CONFADDR    (KZERO+0x100)       /* unparsed plan9.ini */
@

<<constant BOOTARGS(arm)>>=
/*
 * Where configuration info is left for the loaded programme.
 */
#define BOOTARGS    ((char*)CONFADDR)
@

<<constant BOOTARGSLEN(arm)>>=
#define BOOTARGSLEN (CPUADDR-CONFADDR)
@

<<global oargc(arm)>>=
/*
 * Option arguments from the command line.
 * oargv[0] is the boot file.
 */
static int oargc;
@

<<global oargv(arm)>>=
static char* oargv[20];
@

<<global oargb(arm)>>=
static char oargb[128];
@

<<global oargblen(arm)>>=
static int oargblen;
@

<<struct Atag(arm)>>=
struct Atag {
    u32int  size;   /* size of atag in words, including this header */
    u32int  tag;    /* atag type */
    union {
        u32int  data[1];    /* actually [size-2] */
        /* AtagMem */
        struct {
            u32int  size;
            u32int  base;
        } mem;
        /* AtagCmdLine */
        char    cmdline[1]; /* actually [4*(size-2)] */
    };
};
@

<<enum _anon_ (init/arm/bootconf.c)2(arm)>>=
enum {
    AtagNone    = 0x00000000,
    AtagCore    = 0x54410001,
    AtagMem     = 0x54410002,
    AtagCmdline = 0x54410009,
};
@

<<function findconf(arm)>>=
static int
findconf(char *name)
{
    int i;

    for(i = 0; i < nconf; i++)
        if(cistrcmp(confname[i], name) == 0)
            return i;
    return -1;
}
@

<<function addconf(arm)>>=
void
addconf(char *name, char *val)
{
    int i;

    i = findconf(name);
    if(i < 0){
        if(val == nil || nconf >= MAXCONF)
            return;
        i = nconf++;
        strecpy(confname[i], confname[i]+sizeof(confname[i]), name);
    }
    strecpy(confval[i], confval[i]+sizeof(confval[i]), val);
}
@

<<function writeconf(arm)>>=
static void
writeconf(void)
{
    char *p, *q;
    int n;

    p = getconfenv();

    if(waserror()) {
        free(p);
        nexterror();
    }

    /* convert to name=value\n format */
    for(q=p; *q; q++) {
        q += strlen(q);
        *q = '=';
        q += strlen(q);
        *q = '\n';
    }
    n = q - p + 1;
    if(n >= BOOTARGSLEN)
        error("kernel configuration too large");
    memmove(BOOTARGS, p, n);
    memset(BOOTARGS + n, '\n', BOOTARGSLEN - n);
    poperror();
    free(p);
}
@

<<function plan9iniinit(arm)>>=
static void
plan9iniinit(char *s, int cmdline)
{
    char *toks[MAXCONF];
    int i, c, n;
    char *v;

    if((c = *s) < ' ' || c >= 0x80)
        return;
    if(cmdline)
        n = tokenize(s, toks, MAXCONF);
    else
        n = getfields(s, toks, MAXCONF, 1, "\n");
    for(i = 0; i < n; i++){
        if(toks[i][0] == '#')
            continue;
        v = strchr(toks[i], '=');
        if(v == nil)
            continue;
        *v++ = '\0';
        addconf(toks[i], v);
    }
}
@

<<function ataginit(arm)>>=
static void
ataginit(Atag *a)
{
    int n;

    if(a->tag != AtagCore){
        plan9iniinit((char*)a, 0);
        return;
    }
    while(a->tag != AtagNone){
        switch(a->tag){
        case AtagMem:
            /* use only first bank */
            if(conf.mem[0].limit == 0 && a->mem.size != 0){
                memsize = a->mem.size;
                conf.mem[0].base = a->mem.base;
                conf.mem[0].limit = a->mem.base + memsize;
            }
            break;
        case AtagCmdline:
            n = (a->size * sizeof(u32int)) - offsetof(Atag, cmdline[0]);
            if(a->cmdline + n < BOOTARGS + BOOTARGSLEN)
                a->cmdline[n] = 0;
            else
                BOOTARGS[BOOTARGSLEN-1] = 0;
            plan9iniinit(a->cmdline, 1);
            break;
        }
        a = (Atag*)((u32int*)a + a->size);
    }
}
@

<<function optionsinit(arm)>>=
static void
optionsinit(char* s)
{
    strecpy(oargb, oargb+sizeof(oargb), s);

    oargblen = strlen(oargb);
    oargc = tokenize(oargb, oargv, nelem(oargv)-1);
    oargv[oargc] = nil;
}
@

<<function bootargs(arm)>>=
uintptr
bootargs(uintptr base)
{
    int i;
    ulong ssize;
    char **av, *p;

    /*
     * Push the boot args onto the stack.
     * The initial value of the user stack must be such
     * that the total used is larger than the maximum size
     * of the argument list checked in syscall.
     */
    i = oargblen+1;
    p = UINT2PTR(STACKALIGN(base + BY2PG - Ustkheadroom - i));
    memmove(p, oargb, i);

    /*
     * Now push the argv pointers.
     * The code jumped to by touser in lproc.s expects arguments
     *  main(char* argv0, ...)
     * and calls
     *  startboot("/boot/boot", &argv0)
     * not the usual (int argc, char* argv[])
     */
    av = (char**)(p - (oargc+1)*sizeof(char*));
    ssize = base + BY2PG - PTR2UINT(av);
    for(i = 0; i < oargc; i++)
        *av++ = (oargv[i] - oargb) + (p - base) + (USTKTOP - BY2PG);
    *av = nil;
    //sp = USTKTOP - ssize;
    return USTKTOP - ssize;
}
@


%-------------------------------------------------------------

<<init/arm/bootconf.c>>=
<<kernel basic includes>>

#include "tos.h"

<<enum _anon_ (init/arm/bootconf.c)(arm)>>

<<constant BOOTARGS(arm)>>
<<constant BOOTARGSLEN(arm)>>
//#define MAXCONF       64
//#define MAXCONFLINE   160

<<global oargc(arm)>>
<<global oargv(arm)>>
<<global oargb(arm)>>
<<global oargblen(arm)>>

/* store plan9.ini contents here at least until we stash them in #ec */
//static char confname[MAXCONF][KNAMELEN];
//static char confval[MAXCONF][MAXCONFLINE];
//static int nconf;

typedef struct Atag Atag;
<<struct Atag(arm)>>

<<enum _anon_ (init/arm/bootconf.c)2(arm)>>

<<function findconf(arm)>>


<<function addconf(arm)>>

<<function writeconf(arm)>>

<<function plan9iniinit(arm)>>

<<function ataginit(arm)>>

<<function optionsinit(arm)>>

<<function bootargs(arm)>>
@


\subsection*{[[devices/storage/arm/emmc.c]]}


<<enum _anon_ (devices/storage/arm/emmc.c)(arm)>>=
enum {
    Extfreq     = 100*Mhz,  /* guess external clock frequency if */
                    /* not available from vcore */
    Initfreq    = 400000,   /* initialisation frequency for MMC */
    SDfreq      = 25*Mhz,   /* standard SD frequency */
    DTO     = 14,       /* data timeout exponent (guesswork) */

    MMCSelect   = 7,        /* mmc/sd card select command */
    Setbuswidth = 6,        /* mmc/sd set bus width command */
};
@

<<enum _anon_ (devices/storage/arm/emmc.c)2(arm)>>=
enum {
    /* Controller registers */
    Arg2            = 0x00>>2,
    Blksizecnt      = 0x04>>2,
    Arg1            = 0x08>>2,
    Cmdtm           = 0x0c>>2,
    Resp0           = 0x10>>2,
    Resp1           = 0x14>>2,
    Resp2           = 0x18>>2,
    Resp3           = 0x1c>>2,
    Data            = 0x20>>2,
    Status          = 0x24>>2,
    Control0        = 0x28>>2,
    Control1        = 0x2c>>2,
    Interrupt       = 0x30>>2,
    Irptmask        = 0x34>>2,
    Irpten          = 0x38>>2,
    Control2        = 0x3c>>2,
    Forceirpt       = 0x50>>2,
    Boottimeout     = 0x70>>2,
    Dbgsel          = 0x74>>2,
    Exrdfifocfg     = 0x80>>2,
    Exrdfifoen      = 0x84>>2,
    Tunestep        = 0x88>>2,
    Tunestepsstd        = 0x8c>>2,
    Tunestepsddr        = 0x90>>2,
    Spiintspt       = 0xf0>>2,
    Slotisrver      = 0xfc>>2,

    /* Control0 */
    Dwidth4         = 1<<1,
    Dwidth1         = 0<<1,

    /* Control1 */
    Srstdata        = 1<<26,    /* reset data circuit */
    Srstcmd         = 1<<25,    /* reset command circuit */
    Srsthc          = 1<<24,    /* reset complete host controller */
    Datatoshift     = 16,       /* data timeout unit exponent */
    Datatomask      = 0xF0000,
    Clkfreq8shift       = 8,        /* SD clock base divider LSBs */
    Clkfreq8mask        = 0xFF00,
    Clkfreqms2shift     = 6,        /* SD clock base divider MSBs */
    Clkfreqms2mask      = 0xC0,
    Clkgendiv       = 0<<5,     /* SD clock divided */
    Clkgenprog      = 1<<5,     /* SD clock programmable */
    Clken           = 1<<2,     /* SD clock enable */
    Clkstable       = 1<<1, 
    Clkintlen       = 1<<0,     /* enable internal EMMC clocks */

    /* Cmdtm */
    Indexshift      = 24,
    Suspend         = 1<<22,
    Resume          = 2<<22,
    Abort           = 3<<22,
    Isdata          = 1<<21,
    Ixchken         = 1<<20,
    Crcchken        = 1<<19,
    Respmask        = 3<<16,
    Respnone        = 0<<16,
    Resp136         = 1<<16,
    Resp48          = 2<<16,
    Resp48busy      = 3<<16,
    Multiblock      = 1<<5,
    Host2card       = 0<<4,
    Card2host       = 1<<4,
    Autocmd12       = 1<<2,
    Autocmd23       = 2<<2,
    Blkcnten        = 1<<1,

    /* Interrupt */
    Acmderr     = 1<<24,
    Denderr     = 1<<22,
    Dcrcerr     = 1<<21,
    Dtoerr      = 1<<20,
    Cbaderr     = 1<<19,
    Cenderr     = 1<<18,
    Ccrcerr     = 1<<17,
    Ctoerr      = 1<<16,
    Err     = 1<<15,
    Cardintr    = 1<<8,     /* not in Broadcom datasheet */
    Cardinsert  = 1<<6,     /* not in Broadcom datasheet */
    Readrdy     = 1<<5,
    Writerdy    = 1<<4,
    Datadone    = 1<<1,
    Cmddone     = 1<<0,

    /* Status */
    Bufread     = 1<<11,    /* not in Broadcom datasheet */
    Bufwrite    = 1<<10,    /* not in Broadcom datasheet */
    Readtrans   = 1<<9,
    Writetrans  = 1<<8,
    Datactive   = 1<<2,
    Datinhibit  = 1<<1,
    Cmdinhibit  = 1<<0,
};
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>

<<global cmdinfo(arm)>>=
int cmdinfo[64] = {
[0]  Ixchken,
[2]  Resp136,
[3]  Resp48 | Ixchken | Crcchken,
[6]  Resp48 | Ixchken | Crcchken,
[7]  Resp48busy | Ixchken | Crcchken,
[8]  Resp48 | Ixchken | Crcchken,
[9]  Resp136,
[12] Resp48busy | Ixchken | Crcchken,
[13] Resp48 | Ixchken | Crcchken,
[16] Resp48,
[17] Resp48 | Isdata | Card2host | Ixchken | Crcchken,
[18] Resp48 | Isdata | Card2host | Multiblock | Blkcnten | Ixchken | Crcchken,
[24] Resp48 | Isdata | Host2card | Ixchken | Crcchken,
[25] Resp48 | Isdata | Host2card | Multiblock | Blkcnten | Ixchken | Crcchken,
[41] Resp48,
[55] Resp48 | Ixchken | Crcchken,
};
@

<<struct Ctlr (devices/storage/arm/emmc.c)(arm)>>=
struct Ctlr {
    Rendez  r;
    int datadone;
    int fastclock;
    ulong   extclk;
};
@

<<global emmc(arm)>>=
static Ctlr emmc;
@

<<function WR(arm)>>=
static void
WR(int reg, u32int val)
{
    u32int *r = (u32int*)EMMCREGS;

    //if(0)print("WR %2.2ux %ux\n", reg<<2, val);
    arch_microdelay(emmc.fastclock? 2 : 20);
    r[reg] = val;
}
@

<<function clkdiv(arm)>>=
static uint
clkdiv(uint d)
{
    uint v;

    assert(d < 1<<10);
    v = (d << Clkfreq8shift) & Clkfreq8mask;
    v |= ((d >> 8) << Clkfreqms2shift) & Clkfreqms2mask;
    return v;
}
@
% >> >> >> >>

<<function datadone(arm)>>=
static int
datadone(void*)
{
    int i;

    u32int *r = (u32int*)EMMCREGS;
    i = r[Interrupt];
    return i & (Datadone|Err);
}
@

<<function emmcinit(arm)>>=
static int
emmcinit(void)
{
    u32int *r;
    ulong clk;
    char *s;

    clk = getclkrate(ClkEmmc);
    s = "";
    if(clk == 0){
        s = "Assuming ";
        clk = Extfreq;
    }
    emmc.extclk = clk;
    print("%seMMC external clock %lud Mhz\n", s, clk / Mhz);
    r = (u32int*)EMMCREGS;
    //if(0)print("emmc control %8.8ux %8.8ux %8.8ux\n", r[Control0], r[Control1], r[Control2]);
    WR(Control1, Srsthc);
    arch_delay(10);
    while(r[Control1] & Srsthc)
        ;
    return 0;
}
@

<<function emmcinquiry(arm)>>=
static int
emmcinquiry(char *inquiry, int inqlen)
{
    u32int *r;
    uint ver;

    r = (u32int*)EMMCREGS;
    ver = r[Slotisrver] >> 16;
    return snprint(inquiry, inqlen,
        "Arasan eMMC SD Host Controller %2.2x Version %2.2x",
        ver&0xFF, ver>>8);
}
@

<<function mmcinterrupt(arm)>>=
static void
mmcinterrupt(Ureg*, void*)
{   
    u32int *r;
    r = (u32int*)EMMCREGS;
    if(r[Interrupt]&(Datadone|Err)){
        WR(Irpten, 0);
        wakeup(&emmc.r);
    }
}
@

<<function emmcenable(arm)>>=
static void
emmcenable(void)
{
    u32int *r;
    int i;

    r = (u32int*)EMMCREGS;
    WR(Control1, clkdiv(emmc.extclk/Initfreq - 1) |
        DTO<<Datatoshift | Clkgendiv | Clken | Clkintlen);
    for(i = 0; i < 1000; i++){
        arch_delay(1);
        if(r[Control1] & Clkstable)
            break;
    }
    if(i == 1000)
        print("SD clock won't initialise!\n");
    WR(Irptmask, ~(Dtoerr|Cardintr));
    arch_intrenable(IRQmmc, mmcinterrupt, nil, 0, "mmc");
}
@

<<function emmccmd(arm)>>=
static int
emmccmd(u32int cmd, u32int arg, u32int *resp)
{
    u32int *r;
    u32int c;
    int i;
    ulong now;

    r = (u32int*)EMMCREGS;
    assert(cmd < nelem(cmdinfo) && cmdinfo[cmd] != 0);
    c = (cmd << Indexshift) | cmdinfo[cmd];
    if(r[Status] & Cmdinhibit){
        print("emmccmd: need to reset Cmdinhibit intr %ux stat %ux\n",
            r[Interrupt], r[Status]);
        WR(Control1, r[Control1] | Srstcmd);
        while(r[Control1] & Srstcmd)
            ;
        while(r[Status] & Cmdinhibit)
            ;
    }
    if((r[Status] & Datinhibit) &&
       ((c & Isdata) || (c & Respmask) == Resp48busy)){
        print("emmccmd: need to reset Datinhibit intr %ux stat %ux\n",
            r[Interrupt], r[Status]);
        WR(Control1, r[Control1] | Srstdata);
        while(r[Control1] & Srstdata)
            ;
        while(r[Status] & Datinhibit)
            ;
    }
    WR(Arg1, arg);
    if((i = r[Interrupt]) != 0){
        if(i != Cardinsert)
            print("emmc: before command, intr was %ux\n", i);
        WR(Interrupt, i);
    }
    WR(Cmdtm, c);
    now = cpu->ticks;
    while(((i=r[Interrupt])&(Cmddone|Err)) == 0)
        if(cpu->ticks - now > Arch_HZ)
            break;
    if((i&(Cmddone|Err)) != Cmddone){
        if((i&~Err) != Ctoerr)
            print("emmc: cmd %ux error intr %ux stat %ux\n", c, i, r[Status]);
        WR(Interrupt, i);
        if(r[Status]&Cmdinhibit){
            WR(Control1, r[Control1]|Srstcmd);
            while(r[Control1]&Srstcmd)
                ;
        }
        error(Eio);
    }
    WR(Interrupt, i & ~(Datadone|Readrdy|Writerdy));
    switch(c & Respmask){
    case Resp136:
        resp[0] = r[Resp0]<<8;
        resp[1] = r[Resp0]>>24 | r[Resp1]<<8;
        resp[2] = r[Resp1]>>24 | r[Resp2]<<8;
        resp[3] = r[Resp2]>>24 | r[Resp3]<<8;
        break;
    case Resp48:
    case Resp48busy:
        resp[0] = r[Resp0];
        break;
    case Respnone:
        resp[0] = 0;
        break;
    }
    if((c & Respmask) == Resp48busy){
        WR(Irpten, Datadone|Err);
        tsleep(&emmc.r, datadone, 0, 3000);
        WR(Irpten, 0);
        emmc.datadone = 0;
        i = r[Interrupt];
        if((i & Datadone) == 0)
            print("emmcio: no Datadone after CMD%d\n", cmd);
        if(i & Err)
            print("emmcio: CMD%d error interrupt %ux\n",
                cmd, r[Interrupt]);
        WR(Interrupt, i);
    }
    /*
     * Once card is selected, use faster clock
     */
    if(cmd == MMCSelect){
        arch_delay(10);
        WR(Control1, clkdiv(emmc.extclk/SDfreq - 1) |
            DTO<<Datatoshift | Clkgendiv | Clken | Clkintlen);
        for(i = 0; i < 1000; i++){
            arch_delay(1);
            if(r[Control1] & Clkstable)
                break;
        }
        arch_delay(10);
        emmc.fastclock = 1;
    }
    /*
     * If card bus width changes, change host bus width
     */
    if(cmd == Setbuswidth){
        switch(arg){
        case 0:
            WR(Control0, r[Control0] & ~Dwidth4);
            break;
        case 2:
            WR(Control0, r[Control0] | Dwidth4);
            break;
        }
    }
    return 0;
}
@
% >> >> >> >> >> >>

<<function emmciosetup(arm)>>=
void
emmciosetup(int write, void *buf, int bsize, int bcount)
{
    USED(write);
    USED(buf);
    WR(Blksizecnt, bcount<<16 | bsize);
}
@
% >> >>

<<function emmcio(arm)>>=
static void
emmcio(int write, uchar *buf, int len)
{
    u32int *r;
    int i;

    r = (u32int*)EMMCREGS;
    assert((len&3) == 0);
    okay(1);
    if(waserror()){
        okay(0);
        nexterror();
    }
    if(write)
        dmastart(DmaChanEmmc, DmaDevEmmc, DmaM2D,
            buf, &r[Data], len);
    else
        dmastart(DmaChanEmmc, DmaDevEmmc, DmaD2M,
            &r[Data], buf, len);
    if(dmawait(DmaChanEmmc) < 0)
        error(Eio);
    if(!write)
        cachedinvse(buf, len);
    WR(Irpten, Datadone|Err);
    tsleep(&emmc.r, datadone, 0, 3000);
    WR(Irpten, 0);
    emmc.datadone = 0;
    i = r[Interrupt];
    if((i & Datadone) == 0){
        print("emmcio: %d timeout intr %ux stat %ux\n",
            write, i, r[Status]);
        WR(Interrupt, i);
        error(Eio);
    }
    if(i & Err){
        print("emmcio: %d error intr %ux stat %ux\n",
            write, r[Interrupt], r[Status]);
        WR(Interrupt, i);
        error(Eio);
    }
    if(i)
        WR(Interrupt, i);
    poperror();
    okay(0);
}
@

<<global sdio(arm)>>=
SDio sdio = {
    "emmc",
    emmcinit,
    emmcenable,
    emmcinquiry,
    emmccmd,
    emmciosetup,
    emmcio,
};
@


%-------------------------------------------------------------

<<devices/storage/arm/emmc.c>>=
/*
 * bcm2835 external mass media controller (mmc / sd host interface)
 *
 * Copyright  2012 Richard Miller <r.miller@acm.org>
 */
<<kernel basic includes>>
#include "io.h"
#include "../port/sd.h"

<<constant EMMCREGS(arm)>>

<<enum _anon_ (devices/storage/arm/emmc.c)(arm)>>

<<enum _anon_ (devices/storage/arm/emmc.c)2(arm)>>

<<global cmdinfo(arm)>>

typedef struct Ctlr Ctlr;
<<struct Ctlr (devices/storage/arm/emmc.c)(arm)>>

<<global emmc(arm)>>

<<function WR(arm)>>

<<function clkdiv(arm)>>

<<function datadone(arm)>>

<<function emmcinit(arm)>>

<<function emmcinquiry(arm)>>

<<function mmcinterrupt(arm)>>

<<function emmcenable(arm)>>

<<function emmccmd(arm)>>

<<function emmciosetup(arm)>>

<<function emmcio(arm)>>


<<global sdio(arm)>>
@


\subsection*{[[init/arm/watchdog.c]]}


<<enum _anon_ (init/arm/watchdog.c)(arm)>>=
enum {
    Wdogfreq    = 65536,
    Wdogtime    = 5,    /* seconds,  15 */
};
@

<<enum _anon_ (init/arm/watchdog.c)2(arm)>>=
/*
 * Power management / watchdog registers
 */
enum {
    Rstc        = 0x1c>>2,
        Password    = 0x5A<<24,
        CfgMask     = 0x03<<4,
        CfgReset    = 0x02<<4,
    Rsts        = 0x20>>2,
    Wdog        = 0x24>>2,
};
@

<<function archreset(arm)>>=
void
archreset(void)
{
    fpon();
}
@

<<function archreboot(arm)>>=
void
archreboot(void)
{
    u32int *r;

    r = (u32int*)POWERREGS;
    r[Wdog] = Password | 1;
    r[Rstc] = Password | (r[Rstc] & ~CfgMask) | CfgReset;
    arch_coherence();
    for(;;)
        ;
}
@
\l rename? now that I use arch_reboot, it's confusing

<<function wdogfeed(arm)>>=
static void
wdogfeed(void)
{
    u32int *r;

    r = (u32int*)POWERREGS;
    r[Wdog] = Password | (Wdogtime * Wdogfreq);
    r[Rstc] = Password | (r[Rstc] & ~CfgMask) | CfgReset;
}
@

<<function wdogoff(arm)>>=
void
wdogoff(void)
{
    u32int *r;

    r = (u32int*)POWERREGS;
    r[Rstc] = Password | (r[Rstc] & ~CfgMask);
}
@

<<function watchdoglink(arm)>>=
void
watchdoglink(void)
{
    addclock0link(wdogfeed, Arch_HZ);
}
@


%-------------------------------------------------------------

<<init/arm/watchdog.c>>=
<<kernel basic includes>>

<<constant POWERREGS(arm)>>

<<enum _anon_ (init/arm/watchdog.c)(arm)>>

<<enum _anon_ (init/arm/watchdog.c)2(arm)>>

<<function archreset(arm)>>

<<function archreboot(arm)>>

<<function wdogfeed(arm)>>

<<function wdogoff(arm)>>

<<function watchdoglink(arm)>>
@


\subsection*{[[buses/arm/dwcotg.h]]}

<<enum _anon_ (buses/arm/dwcotg.h)(arm)>>=
enum {
    Maxchans    = 16,   /* actual number of channels in ghwcfg2 */
};
@

<<struct Dwcregs(arm)>>=
struct Dwcregs {
    /* Core global registers 0x000-0x140 */
    Reg gotgctl;    /* OTG Control and Status */
    Reg gotgint;    /* OTG Interrupt */
    Reg gahbcfg;    /* Core AHB Configuration */
    Reg gusbcfg;    /* Core USB Configuration */
    Reg grstctl;    /* Core Reset */
    Reg gintsts;    /* Core Interrupt */
    Reg gintmsk;    /* Core Interrupt Mask */
    Reg grxstsr;    /* Receive Status Queue Read (RO) */
    Reg grxstsp;    /* Receive Status Queue Read & POP (RO) */
    Reg grxfsiz;    /* Receive FIFO Size */
    Reg gnptxfsiz;  /* Non Periodic Transmit FIFO Size */
    Reg gnptxsts;   /* Non Periodic Transmit FIFO/Queue Status (RO) */
    Reg gi2cctl;    /* I2C Access */
    Reg gpvndctl;   /* PHY Vendor Control */
    Reg ggpio;      /* General Purpose Input/Output */
    Reg guid;       /* User ID */
    Reg gsnpsid;    /* Synopsys ID (RO) */
    Reg ghwcfg1;    /* User HW Config1 (RO) (DEVICE) */
    Reg ghwcfg2;    /* User HW Config2 (RO) */
    Reg ghwcfg3;    /* User HW Config3 (RO) */
    Reg ghwcfg4;    /* User HW Config4 (RO)*/
    Reg glpmcfg;    /* Core LPM Configuration */
    Reg gpwrdn;     /* Global PowerDn */
    Reg gdfifocfg;  /* Global DFIFO SW Config (DEVICE?) */
    Reg adpctl;     /* ADP Control */
    Reg reserved0[39];
    Reg hptxfsiz;   /* Host Periodic Transmit FIFO Size */
    Reg dtxfsiz[15];    /* Device Periodic Transmit FIFOs (DEVICE) */
    char    pad0[0x400-0x140];

    /* Host global registers 0x400-0x420 */
    Reg hcfg;       /* Configuration */
    Reg hfir;       /* Frame Interval */
    Reg hfnum;      /* Frame Number / Frame Remaining (RO) */
    Reg reserved1;
    Reg hptxsts;    /* Periodic Transmit FIFO / Queue Status */
    Reg haint;      /* All Channels Interrupt */
    Reg haintmsk;   /* All Channels Interrupt Mask */
    Reg hflbaddr;   /* Frame List Base Address */
    char    pad1[0x440-0x420];

    /* Host port register 0x440 */
    Reg hport0;     /* Host Port 0 Control and Status */
    char    pad2[0x500-0x444];

    /* Host channel specific registers 0x500-0x700 */
    struct  Hostchan {
        Reg hcchar; /* Characteristic */
        Reg hcsplt; /* Split Control */
        Reg hcint;  /* Interrupt */
        Reg hcintmsk; /* Interrupt Mask */
        Reg hctsiz; /* Transfer Size */
        Reg hcdma;  /* DMA Address */
        Reg reserved;
        Reg hcdmab; /* DMA Buffer Address */
    } hchan[Maxchans];
    char    pad3[0xE00-0x700];

    /* Power & clock gating control register 0xE00 */
    Reg pcgcctl;
};
@


%-------------------------------------------------------------

<<buses/arm/dwcotg.h>>=
/*
 * USB host driver for BCM2835
 *  Synopsis DesignWare Core USB 2.0 OTG controller
 *
 * Device register definitions
 */

typedef unsigned int Reg;
typedef struct Dwcregs Dwcregs;
typedef struct Hostchan Hostchan;

<<enum _anon_ (buses/arm/dwcotg.h)(arm)>>

<<struct Dwcregs(arm)>>

enum {
    /* gotgctl */
    Sesreqscs   = 1<<0,
    Sesreq      = 1<<1,
    Vbvalidoven = 1<<2,
    Vbvalidovval    = 1<<3,
    Avalidoven  = 1<<4,
    Avalidovval = 1<<5,
    Bvalidoven  = 1<<6,
    Bvalidovval = 1<<7,
    Hstnegscs   = 1<<8,
    Hnpreq      = 1<<9,
    Hstsethnpen = 1<<10,
    Devhnpen    = 1<<11,
    Conidsts    = 1<<16,
    Dbnctime    = 1<<17,
    Asesvld     = 1<<18,
    Bsesvld     = 1<<19,
    Otgver      = 1<<20,
    Multvalidbc = 0x1F<<22,
    Chirpen     = 1<<27,

    /* gotgint */
    Sesenddet   = 1<<2,
    Sesreqsucstschng= 1<<8,
    Hstnegsucstschng= 1<<9,
    Hstnegdet   = 1<<17,
    Adevtoutchng    = 1<<18,
    Debdone     = 1<<19,
    Mvic        = 1<<20,

    /* gahbcfg */
    Glblintrmsk = 1<<0,
    /* bits 1:4 redefined for BCM2835 */
    Axiburstlen = 0x3<<1,
        BURST1      = 3<<1,
        BURST2      = 2<<1,
        BURST3      = 1<<1,
        BURST4      = 0<<1,
    Axiwaitwrites   = 1<<4,
    Dmaenable   = 1<<5,
    Nptxfemplvl = 1<<7,
        NPTX_HALFEMPTY  = 0<<7,
        NPTX_EMPTY  = 1<<7,
    Ptxfemplvl  = 1<<8,
        PTX_HALFEMPTY   = 0<<8,
        PTX_EMPTY   = 1<<8,
    Remmemsupp  = 1<<21,
    Notialldmawrit  = 1<<22,
    Ahbsingle   = 1<<23,

    /* gusbcfg */
    Toutcal     = 0x7<<0,
    Phyif       = 1<<3,
    Ulpi_utmi_sel   = 1<<4,
    Fsintf      = 1<<5,
        FsUnidir    = 0<<5,
        FsBidir     = 1<<5,
    Physel      = 1<<6,
        PhyHighspeed    = 0<<6,
        PhyFullspeed    = 1<<6,
    Ddrsel      = 1<<7,
    Srpcap      = 1<<8,
    Hnpcap      = 1<<9,
    Usbtrdtim   = 0xf<<10,
        OUsbtrdtim      = 10,
    Phylpwrclksel   = 1<<15,
    Otgutmifssel    = 1<<16,
    Ulpi_fsls   = 1<<17,
    Ulpi_auto_res   = 1<<18,
    Ulpi_clk_sus_m  = 1<<19,
    Ulpi_ext_vbus_drv= 1<<20,
    Ulpi_int_vbus_indicator= 1<<21,
    Term_sel_dl_pulse= 1<<22,
    Indicator_complement= 1<<23,
    Indicator_pass_through= 1<<24,
    Ulpi_int_prot_dis= 1<<25,
    Ic_usb_cap  = 1<<26,
    Ic_traffic_pull_remove= 1<<27,
    Tx_end_delay    = 1<<28,
    Force_host_mode = 1<<29,
    Force_dev_mode  = 1<<30,

    /* grstctl */
    Csftrst     = 1<<0,
    Hsftrst     = 1<<1,
    Hstfrm      = 1<<2,
    Intknqflsh  = 1<<3,
    Rxfflsh     = 1<<4,
    Txfflsh     = 1<<5,
    Txfnum      = 0x1f<<6,
        TXF_ALL     = 0x10<<6,
    Dmareq      = 1<<30,
    Ahbidle     = 1<<31,

    /* gintsts, gintmsk */
    Curmode     = 1<<0,
        HOSTMODE    = 1<<0,
        DEVMODE     = 0<<0,
    Modemismatch    = 1<<1,
    Otgintr     = 1<<2,
    Sofintr     = 1<<3,
    Rxstsqlvl   = 1<<4,
    Nptxfempty  = 1<<5,
    Ginnakeff   = 1<<6,
    Goutnakeff  = 1<<7,
    Ulpickint   = 1<<8,
    I2cintr     = 1<<9,
    Erlysuspend = 1<<10,
    Usbsuspend  = 1<<11,
    Usbreset    = 1<<12,
    Enumdone    = 1<<13,
    Isooutdrop  = 1<<14,
    Eopframe    = 1<<15,
    Restoredone = 1<<16,
    Epmismatch  = 1<<17,
    Inepintr    = 1<<18,
    Outepintr   = 1<<19,
    Incomplisoin    = 1<<20,
    Incomplisoout   = 1<<21,
    Fetsusp     = 1<<22,
    Resetdet    = 1<<23,
    Portintr    = 1<<24,
    Hcintr      = 1<<25,
    Ptxfempty   = 1<<26,
    Lpmtranrcvd = 1<<27,
    Conidstschng    = 1<<28,
    Disconnect  = 1<<29,
    Sessreqintr = 1<<30,
    Wkupintr    = 1<<31,

    /* grxsts[rp] */
    Chnum       = 0xf<<0,
    Bcnt        = 0x7ff<<4,
    Dpid        = 0x3<<15,
    Pktsts      = 0xf<<17,
        PKTSTS_IN       = 2<<17,
        PKTSTS_IN_XFER_COMP = 3<<17,
        PKTSTS_DATA_TOGGLE_ERR  = 5<<17,
        PKTSTS_CH_HALTED    = 7<<17,

    /* hptxfsiz, gnptxfsiz */
    Startaddr   = 0xffff<<0,
    Depth       = 0xffff<<16,
        ODepth      = 16,

    /* gnptxsts */
    Nptxfspcavail   = 0xffff<<0,
    Nptxqspcavail   = 0xff<<16,
    Nptxqtop_terminate= 1<<24,
    Nptxqtop_token  = 0x3<<25,
    Nptxqtop_chnep  = 0xf<<27,

    /* gpvndctl */
    Regdata     = 0xff<<0,
    Vctrl       = 0xff<<8,
    Regaddr16_21    = 0x3f<<16,
    Regwr       = 1<<22,
    Newregreq   = 1<<25,
    Vstsbsy     = 1<<26,
    Vstsdone    = 1<<27,
    Disulpidrvr = 1<<31,

    /* ggpio */
    Gpi     = 0xffff<<0,
    Gpo     = 0xffff<<16,

    /* ghwcfg2 */
    Op_mode     = 0x7<<0,
        HNP_SRP_CAPABLE_OTG = 0<<0,
        SRP_ONLY_CAPABLE_OTG    = 1<<0,
        NO_HNP_SRP_CAPABLE  = 2<<0,
        SRP_CAPABLE_DEVICE  = 3<<0,
        NO_SRP_CAPABLE_DEVICE   = 4<<0,
        SRP_CAPABLE_HOST    = 5<<0,
        NO_SRP_CAPABLE_HOST = 6<<0,
    Architecture    = 0x3<<3,
        SLAVE_ONLY      = 0<<3,
        EXT_DMA         = 1<<3,
        INT_DMA         = 2<<3,
    Point2point = 1<<5,
    Hs_phy_type = 0x3<<6,
        PHY_NOT_SUPPORTED   = 0<<6,
        PHY_UTMI        = 1<<6,
        PHY_ULPI        = 2<<6,
        PHY_UTMI_ULPI       = 3<<6,
    Fs_phy_type = 0x3<<8,
    Num_dev_ep  = 0xf<<10,
    Num_host_chan   = 0xf<<14,
        ONum_host_chan      = 14,
    Perio_ep_supported= 1<<18,
    Dynamic_fifo    = 1<<19,
    Nonperio_tx_q_depth= 0x3<<22,
    Host_perio_tx_q_depth= 0x3<<24,
    Dev_token_q_depth= 0x1f<<26,
    Otg_enable_ic_usb= 1<<31,

    /* ghwcfg3 */
    Xfer_size_cntr_width    = 0xf<<0,
    Packet_size_cntr_width  = 0x7<<4,
    Otg_func        = 1<<7,
    I2c         = 1<<8,
    Vendor_ctrl_if      = 1<<9,
    Optional_features   = 1<<10,
    Synch_reset_type    = 1<<11,
    Adp_supp        = 1<<12,
    Otg_enable_hsic     = 1<<13,
    Bc_support      = 1<<14,
    Otg_lpm_en      = 1<<15,
    Dfifo_depth     = 0xffff<<16,
        ODfifo_depth        = 16,

    /* ghwcfg4 */
    Num_dev_perio_in_ep = 0xf<<0,
    Power_optimiz       = 1<<4,
    Min_ahb_freq        = 1<<5,
    Hiber           = 1<<6,
    Xhiber          = 1<<7,
    Utmi_phy_data_width = 0x3<<14,
    Num_dev_mode_ctrl_ep    = 0xf<<16,
    Iddig_filt_en       = 1<<20,
    Vbus_valid_filt_en  = 1<<21,
    A_valid_filt_en     = 1<<22,
    B_valid_filt_en     = 1<<23,
    Session_end_filt_en = 1<<24,
    Ded_fifo_en     = 1<<25,
    Num_in_eps      = 0xf<<26,
    Desc_dma        = 1<<30,
    Desc_dma_dyn        = 1<<31,

    /* glpmcfg */
    Lpm_cap_en  = 1<<0,
    Appl_resp   = 1<<1,
    Hird        = 0xf<<2,
    Rem_wkup_en = 1<<6,
    En_utmi_sleep   = 1<<7,
    Hird_thres  = 0x1f<<8,
    Lpm_resp    = 0x3<<13,
    Prt_sleep_sts   = 1<<15,
    Sleep_state_resumeok= 1<<16,
    Lpm_chan_index  = 0xf<<17,
    Retry_count = 0x7<<21,
    Send_lpm    = 1<<24,
    Retry_count_sts = 0x7<<25,
    Hsic_connect    = 1<<30,
    Inv_sel_hsic    = 1<<31,

    /* gpwrdn */
    Pmuintsel   = 1<<0,
    Pmuactv     = 1<<1,
    Restore     = 1<<2,
    Pwrdnclmp   = 1<<3,
    Pwrdnrstn   = 1<<4,
    Pwrdnswtch  = 1<<5,
    Dis_vbus    = 1<<6,
    Lnstschng   = 1<<7,
    Lnstchng_msk    = 1<<8,
    Rst_det     = 1<<9,
    Rst_det_msk = 1<<10,
    Disconn_det = 1<<11,
    Disconn_det_msk = 1<<12,
    Connect_det = 1<<13,
    Connect_det_msk = 1<<14,
    Srp_det     = 1<<15,
    Srp_det_msk = 1<<16,
    Sts_chngint = 1<<17,
    Sts_chngint_msk = 1<<18,
    Linestate   = 0x3<<19,
    Idsts       = 1<<21,
    Bsessvld    = 1<<22,
    Adp_int     = 1<<23,
    Mult_val_id_bc  = 0x1f<<24,

    /* gdfifocfg */
    Gdfifocfg   = 0xffff<<0,
    Epinfobase  = 0xffff<<16,

    /* adpctl */
    Prb_dschg   = 0x3<<0,
    Prb_delta   = 0x3<<2,
    Prb_per     = 0x3<<4,
    Rtim        = 0x7ff<<6,
    Enaprb      = 1<<17,
    Enasns      = 1<<18,
    Adpres      = 1<<19,
    Adpen       = 1<<20,
    Adp_prb_int = 1<<21,
    Adp_sns_int = 1<<22,
    Adp_tmout_int   = 1<<23,
    Adp_prb_int_msk = 1<<24,
    Adp_sns_int_msk = 1<<25,
    Adp_tmout_int_msk= 1<<26,
    Ar      = 0x3<<27,

    /* hcfg */
    Fslspclksel = 0x3<<0,
        HCFG_30_60_MHZ  = 0<<0,
        HCFG_48_MHZ = 1<<0,
        HCFG_6_MHZ  = 2<<0,
    Fslssupp    = 1<<2,
    Ena32khzs   = 1<<7,
    Resvalid    = 0xff<<8,
    Descdma     = 1<<23,
    Frlisten    = 0x3<<24,
    Modechtimen = 1<<31,

    /* hfir */
    Frint       = 0xffff<<0,
    Hfirrldctrl = 1<<16,

    /* hfnum */
    Frnum       = 0xffff<<0,
        MAX_FRNUM   = 0x3FFF<<0,
    Frrem       = 0xffff<<16,

    /* hptxsts */
    Ptxfspcavail    = 0xffff<<0,
    Ptxqspcavail    = 0xff<<16,
    Ptxqtop_terminate= 1<<24,
    Ptxqtop_token   = 0x3<<25,
    Ptxqtop_chnum   = 0xf<<27,
    Ptxqtop_odd = 1<<31,

    /* haint, haintmsk */
#define CHANINT(n)  (1<<(n))

    /* hport0 */
    Prtconnsts  = 1<<0,     /* connect status (RO) */
    Prtconndet  = 1<<1,     /* connect detected R/W1C) */
    Prtena      = 1<<2,     /* enable (R/W1C) */
    Prtenchng   = 1<<3,     /* enable/disable change (R/W1C) */
    Prtovrcurract   = 1<<4,     /* overcurrent active (RO) */
    Prtovrcurrchng  = 1<<5,     /* overcurrent change (R/W1C) */
    Prtres      = 1<<6,     /* resume */
    Prtsusp     = 1<<7,     /* suspend */
    Prtrst      = 1<<8,     /* reset */
    Prtlnsts    = 0x3<<10,  /* line state {D+,D-} (RO) */
    Prtpwr      = 1<<12,    /* power on */
    Prttstctl   = 0xf<<13,  /* test */
    Prtspd      = 0x3<<17,  /* speed (RO) */
        HIGHSPEED   = 0<<17,
        FULLSPEED   = 1<<17,
        LOWSPEED    = 2<<17,

    /* hcchar */
    Mps     = 0x7ff<<0, /* endpoint maximum packet size */
    Epnum       = 0xf<<11,  /* endpoint number */
        OEpnum      = 11,
    Epdir       = 1<<15,    /* endpoint direction */
        Epout       = 0<<15,
        Epin        = 1<<15,
    Lspddev     = 1<<17,    /* device is lowspeed */
    Eptype      = 0x3<<18,  /* endpoint type */
        Epctl       = 0<<18,
        Episo       = 1<<18,
        Epbulk      = 2<<18,
        Epintr      = 3<<18,
    Multicnt    = 0x3<<20,  /* transactions per frame */
                    /* or retries per periodic split */
        OMulticnt   = 20,
    Devaddr     = 0x7f<<22, /* device address */
        ODevaddr    = 22,
    Oddfrm      = 1<<29,    /* xfer in odd frame (iso/interrupt) */
    Chdis       = 1<<30,    /* channel disable (write 1 only) */
    Chen        = 1<<31,    /* channel enable (write 1 only) */

    /* hcsplt */
    Prtaddr     = 0x7f<<0,  /* port address of recipient */
                    /* transaction translator */
    Hubaddr     = 0x7f<<7,  /* dev address of transaction */
                    /* translator's hub */
        OHubaddr    = 7,
    Xactpos     = 0x3<<14,  /* payload's position within transaction */
        POS_MID     = 0<<14,        
        POS_END     = 1<<14,
        POS_BEGIN   = 2<<14,
        POS_ALL     = 3<<14, /* all of data (<= 188 bytes) */
    Compsplt    = 1<<16,    /* do complete split */
    Spltena     = 1<<31,    /* channel enabled to do splits */

    /* hcint, hcintmsk */
    Xfercomp    = 1<<0,     /* transfer completed without error */
    Chhltd      = 1<<1,     /* channel halted */
    Ahberr      = 1<<2,     /* AHB dma error */
    Stall       = 1<<3,
    Nak     = 1<<4,
    Ack     = 1<<5,
    Nyet        = 1<<6,
    Xacterr     = 1<<7, /* transaction error (crc, t/o, bit stuff, eop) */
    Bblerr      = 1<<8,
    Frmovrun    = 1<<9,
    Datatglerr  = 1<<10,
    Bna     = 1<<11,
    Xcs_xact    = 1<<12,
    Frm_list_roll   = 1<<13,

    /* hctsiz */
    Xfersize    = 0x7ffff<<0,   /* expected total bytes */
    Pktcnt      = 0x3ff<<19,    /* expected number of packets */
        OPktcnt     = 19,
    Pid     = 0x3<<29,  /* packet id for initial transaction */
        DATA0       = 0<<29,
        DATA1       = 2<<29,    /* sic */
        DATA2       = 1<<29,    /* sic */
        MDATA       = 3<<29,    /* (non-ctl ep) */
        SETUP       = 3<<29,    /* (ctl ep) */
    Dopng       = 1<<31,    /* do PING protocol */

    /* pcgcctl */
    Stoppclk        = 1<<0,
    Gatehclk        = 1<<1,
    Pwrclmp         = 1<<2,
    Rstpdwnmodule       = 1<<3,
    Enbl_sleep_gating   = 1<<5,
    Phy_in_sleep        = 1<<6,
    Deep_sleep      = 1<<7,
    Resetaftsusp        = 1<<8,
    Restoremode     = 1<<9,
    Enbl_extnd_hiber    = 1<<10,
    Extnd_hiber_pwrclmp = 1<<11,
    Extnd_hiber_switch  = 1<<12,
    Ess_reg_restored    = 1<<13,
    Prt_clk_sel     = 0x3<<14,
    Port_power      = 1<<16,
    Max_xcvrselect      = 0x3<<17,
    Max_termsel     = 1<<19,
    Mac_dev_addr        = 0x7f<<20,
    P2hd_dev_enum_spd   = 0x3<<27,
    P2hd_prt_spd        = 0x3<<29,
    If_dev_mode     = 1<<31,
};
@
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >>

\subsection*{[[buses/arm/devusb.c]]}

<<enum _anon_ (buses/arm/devusb.c)(arm)>>=
enum
{
    /* Qid numbers */
    Qdir = 0,       /* #u */
    Qusbdir,            /* #u/usb */
    Qctl,           /* #u/usb/ctl - control requests */

    Qep0dir,            /* #u/usb/ep0.0 - endpoint 0 dir */
    Qep0io,         /* #u/usb/ep0.0/data - endpoint 0 I/O */
    Qep0ctl,        /* #u/usb/ep0.0/ctl - endpoint 0 ctl. */
    Qep0dummy,      /* give 4 qids to each endpoint */

    Qepdir = 0,     /* (qid-qep0dir)&3 is one of these */
    Qepio,          /* to identify which file for the endpoint */
    Qepctl,

    /* ... */

    /* Usb ctls. */
    CMdebug = 0,        /* debug on|off */
    CMdump,         /* dump (data structures for debug) */

    /* Ep. ctls */
    CMnew = 0,      /* new nb ctl|bulk|intr|iso r|w|rw (endpoint) */
    CMnewdev,       /* newdev full|low|high portnb (allocate new devices) */
    CMhub,          /* hub (set the device as a hub) */
    CMspeed,        /* speed full|low|high|no */
    CMmaxpkt,       /* maxpkt size */
    CMntds,         /* ntds nb (max nb. of tds per frame) */
    CMclrhalt,      /* clrhalt (halt was cleared on endpoint) */
    CMpollival,     /* pollival interval (interrupt/iso) */
    CMhz,           /* hz n (samples/sec; iso) */
    CMsamplesz,     /* samplesz n (sample size; iso) */
    CMinfo,         /* info infostr (ke.ep info for humans) */
    CMdetach,       /* detach (abort I/O forever on this ep). */
    CMaddress,      /* address (address is assigned) */
    CMdebugep,      /* debug n (set/clear debug for this ep) */
    CMname,         /* name str (show up as #u/name as well) */
    CMtmout,        /* timeout n (activate timeouts for ep) */
    CMpreset,       /* reset the port */

    /* Hub feature selectors */
    Rportenable = 1,
    Rportreset  = 4,

};
@

<<struct Hcitype(arm)>>=
struct Hcitype
{
    char*   type;
    int (*reset)(Hci*);
};
@

<<macro QID(arm)>>=
#define QID(q)  ((int)(q).path)
@

<<global usbctls(arm)>>=
static Cmdtab usbctls[] =
{
    {CMdebug,   "debug",    2},
    {CMdump,    "dump",     1},
};
@

<<global epctls(arm)>>=
static Cmdtab epctls[] =
{
    {CMnew,     "new",      4},
    {CMnewdev,  "newdev",   3},
    {CMhub,     "hub",      1},
    {CMspeed,   "speed",    2},
    {CMmaxpkt,  "maxpkt",   2},
    {CMntds,    "ntds",     2},
    {CMpollival,    "pollival", 2},
    {CMsamplesz,    "samplesz", 2},
    {CMhz,      "hz",       2},
    {CMinfo,    "info",     0},
    {CMdetach,  "detach",   1},
    {CMaddress, "address",  1},
    {CMdebugep, "debug",    2},
    {CMclrhalt, "clrhalt",  1},
    {CMname,    "name",     2},
    {CMtmout,   "timeout",  2},
    {CMpreset,  "reset",    1},
};
@

<<global usbdir(arm)>>=
static Dirtab usbdir[] =
{
    "ctl",      {Qctl},     0,  0666,
};
@

<<global usbmodename(arm)>>=
char *usbmodename[] =
{
    [OREAD] "r",
    [OWRITE]    "w",
    [ORDWR] "rw",
};
@

<<global ttname(arm)>>=
static char *ttname[] =
{
    [Tnone] "none",
    [Tctl]  "control",
    [Tiso]  "iso",
    [Tintr] "interrupt",
    [Tbulk] "bulk",
};
@

<<global spname(arm)>>=
static char *spname[] =
{
    [Fullspeed] "full",
    [Lowspeed]  "low",
    [Highspeed] "high",
    [Nospeed]   "no",
};
@

<<global debug(arm)>>=
static int  debug;
@

<<global hcitypes(arm)>>=
static Hcitype  hcitypes[Nhcis];
@

<<global hcis(arm)>>=
static Hci* hcis[Nhcis];
@

<<global epslck(arm)>>=
static QLock    epslck;     /* add, del, lookup endpoints */
@

<<global eps(arm)>>=
static Ep*  eps[Neps];  /* all endpoints known */
@

<<global epmax(arm)>>=
static int  epmax;      /* 1 + last endpoint index used  */
@

<<global usbidgen(arm)>>=
static int  usbidgen;   /* device address generator */
@

<<function seprintdata(arm)>>=
/*
 * Is there something like this in a library? should it be?
 */
char*
seprintdata(char *s, char *se, uchar *d, int n)
{
    int i, l;

    s = seprint(s, se, " %#p[%d]: ", d, n);
    l = n;
    if(l > 10)
        l = 10;
    for(i=0; i<l; i++)
        s = seprint(s, se, " %2.2ux", d[i]);
    if(l < n)
        s = seprint(s, se, "...");
    return s;
}
@

<<function name2speed(arm)>>=
static int
name2speed(char *name)
{
    int i;

    for(i = 0; i < nelem(spname); i++)
        if(strcmp(name, spname[i]) == 0)
            return i;
    return Nospeed;
}
@

<<function name2ttype(arm)>>=
static int
name2ttype(char *name)
{
    int i;

    for(i = 0; i < nelem(ttname); i++)
        if(strcmp(name, ttname[i]) == 0)
            return i;
    /* may be a std. USB ep. type */
    i = strtol(name, nil, 0);
    switch(i+1){
    case Tctl:
    case Tiso:
    case Tbulk:
    case Tintr:
        return i+1;
    default:
        return Tnone;
    }
}
@

<<function name2mode(arm)>>=
static int
name2mode(char *mode)
{
    int i;

    for(i = 0; i < nelem(usbmodename); i++)
        if(strcmp(mode, usbmodename[i]) == 0)
            return i;
    return -1;
}
@

<<function qid2epidx(arm)>>=
static int
qid2epidx(int q)
{
    q = (q-Qep0dir)/4;
    if(q < 0 || q >= epmax || eps[q] == nil)
        return -1;
    return q;
}
@

<<function isqtype(arm)>>=
static int
isqtype(int q, int type)
{
    if(q < Qep0dir)
        return 0;
    q -= Qep0dir;
    return (q & 3) == type;
}
@

<<function addhcitype(arm)>>=
void
addhcitype(char* t, int (*r)(Hci*))
{
    static int ntype;

    if(ntype == Nhcis)
        panic("too many USB host interface types");
    hcitypes[ntype].type = t;
    hcitypes[ntype].reset = r;
    ntype++;
}
@

<<function seprintep(arm)>>=
static char*
seprintep(char *s, char *se, Ep *ep, int all)
{
    static char* dsnames[] = { "config", "enabled", "detached", "reset" };
    Udev *d;
    int i;
    int di;

    d = ep->dev;

    qlock(ep);
    if(waserror()){
        qunlock(ep);
        nexterror();
    }
    di = ep->dev->nb;
    if(all)
        s = seprint(s, se, "dev %d ep %d ", di, ep->nb);
    s = seprint(s, se, "%s", dsnames[ep->dev->state]);
    s = seprint(s, se, " %s", ttname[ep->ttype]);
    assert(ep->mode == OREAD || ep->mode == OWRITE || ep->mode == ORDWR);
    s = seprint(s, se, " %s", usbmodename[ep->mode]);
    s = seprint(s, se, " speed %s", spname[d->speed]);
    s = seprint(s, se, " maxpkt %ld", ep->maxpkt);
    s = seprint(s, se, " pollival %ld", ep->pollival);
    s = seprint(s, se, " samplesz %ld", ep->samplesz);
    s = seprint(s, se, " hz %ld", ep->hz);
    s = seprint(s, se, " hub %d", ep->dev->hub);
    s = seprint(s, se, " port %d", ep->dev->port);
    if(ep->inuse)
        s = seprint(s, se, " busy");
    else
        s = seprint(s, se, " idle");
    if(all){
        s = seprint(s, se, " load %uld", ep->load);
        s = seprint(s, se, " ref %ld addr %#p", ep->ref, ep);
        s = seprint(s, se, " idx %d", ep->idx);
        if(ep->name != nil)
            s = seprint(s, se, " name '%s'", ep->name);
        if(ep->tmout != 0)
            s = seprint(s, se, " tmout");
        if(ep == ep->ep0){
            s = seprint(s, se, " ctlrno %#x", ep->hp->ctlrno);
            s = seprint(s, se, " eps:");
            for(i = 0; i < nelem(d->eps); i++)
                if(d->eps[i] != nil)
                    s = seprint(s, se, " ep%d.%d", di, i);
        }
    }
    if(ep->info != nil)
        s = seprint(s, se, "\n%s %s\n", ep->info, ep->hp->type);
    else
        s = seprint(s, se, "\n");
    qunlock(ep);
    poperror();
    return s;
}
@

<<function epalloc(arm)>>=
static Ep*
epalloc(Hci *hp)
{
    Ep *ep;
    int i;

    ep = smalloc(sizeof(Ep));
    ep->ref = 1;
    qlock(&epslck);
    for(i = 0; i < Neps; i++)
        if(eps[i] == nil)
            break;
    if(i == Neps){
        qunlock(&epslck);
        free(ep);
        print("usb: bug: too few endpoints.\n");
        return nil;
    }
    ep->idx = i;
    if(epmax <= i)
        epmax = i+1;
    eps[i] = ep;
    ep->hp = hp;
    ep->maxpkt = 8;
    ep->ntds = 1;
    ep->samplesz = ep->pollival = ep->hz = 0; /* make them void */
    qunlock(&epslck);
    return ep;
}
@

<<function getep(arm)>>=
static Ep*
getep(int i)
{
    Ep *ep;

    if(i < 0 || i >= epmax || eps[i] == nil)
        return nil;
    qlock(&epslck);
    ep = eps[i];
    if(ep != nil)
        incref(ep);
    qunlock(&epslck);
    return ep;
}
@

<<function putep(arm)>>=
static void
putep(Ep *ep)
{
    Udev *d;

    if(ep != nil && decref(ep) == 0){
        d = ep->dev;
        deprint("usb: ep%d.%d %#p released\n", d->nb, ep->nb, ep);
        qlock(&epslck);
        eps[ep->idx] = nil;
        if(ep->idx == epmax-1)
            epmax--;
        if(ep == ep->ep0 && ep->dev != nil && ep->dev->nb == usbidgen)
            usbidgen--;
        qunlock(&epslck);
        if(d != nil){
            qlock(ep->ep0);
            d->eps[ep->nb] = nil;
            qunlock(ep->ep0);
        }
        if(ep->ep0 != ep){
            putep(ep->ep0);
            ep->ep0 = nil;
        }
        free(ep->info);
        free(ep->name);
        free(ep);
    }
}
@

<<function dumpeps(arm)>>=
static void
dumpeps(void)
{
    int i;
    static char buf[512];
    char *s;
    char *e;
    Ep *ep;

    print("usb dump eps: epmax %d Neps %d (ref=1+ for dump):\n", epmax, Neps);
    for(i = 0; i < epmax; i++){
        s = buf;
        e = buf+sizeof(buf);
        ep = getep(i);
        if(ep != nil){
            if(waserror()){
                putep(ep);
                nexterror();
            }
            s = seprint(s, e, "ep%d.%d ", ep->dev->nb, ep->nb);
            seprintep(s, e, ep, 1);
            print("%s", buf);
            ep->hp->seprintep(buf, e, ep);
            print("%s", buf);
            poperror();
            putep(ep);
        }
    }
    print("usb dump hcis:\n");
    for(i = 0; i < Nhcis; i++)
        if(hcis[i] != nil)
            hcis[i]->dump(hcis[i]);
}
@

<<function newusbid(arm)>>=
static int
newusbid(Hci *)
{
    int id;

    qlock(&epslck);
    id = ++usbidgen;
    if(id >= 0x7F)
        print("#u: too many device addresses; reuse them more\n");
    qunlock(&epslck);
    return id;
}
@

<<function newdev(arm)>>=
/*
 * Create endpoint 0 for a new device
 */
static Ep*
newdev(Hci *hp, int ishub, int isroot)
{
    Ep *ep;
    Udev *d;

    ep = epalloc(hp);
    d = ep->dev = smalloc(sizeof(Udev));
    d->nb = newusbid(hp);
    d->eps[0] = ep;
    ep->nb = 0;
    ep->toggle[0] = ep->toggle[1] = 0;
    d->ishub = ishub;
    d->isroot = isroot;
    if(hp->highspeed != 0)
        d->speed = Highspeed;
    else
        d->speed = Fullspeed;
    d->state = Dconfig;     /* address not yet set */
    ep->dev = d;
    ep->ep0 = ep;           /* no ref counted here */
    ep->ttype = Tctl;
    ep->tmout = Xfertmout;
    ep->mode = ORDWR;
    dprint("newdev %#p ep%d.%d %#p\n", d, d->nb, ep->nb, ep);
    return ep;
}
@

<<function newdevep(arm)>>=
/*
 * Create a new endpoint for the device
 * accessed via the given endpoint 0.
 */
static Ep*
newdevep(Ep *ep, int i, int tt, int mode)
{
    Ep *nep;
    Udev *d;

    d = ep->dev;
    if(d->eps[i] != nil)
        error("endpoint already in use");
    nep = epalloc(ep->hp);
    incref(ep);
    d->eps[i] = nep;
    nep->nb = i;
    nep->toggle[0] = nep->toggle[1] = 0;
    nep->ep0 = ep;
    nep->dev = ep->dev;
    nep->mode = mode;
    nep->ttype = tt;
    nep->debug = ep->debug;
    /* set defaults */
    switch(tt){
    case Tctl:
        nep->tmout = Xfertmout;
        break;
    case Tintr:
        nep->pollival = 10;
        break;
    case Tiso:
        nep->tmout = Xfertmout;
        nep->pollival = 10;
        nep->samplesz = 4;
        nep->hz = 44100;
        break;
    }
    deprint("newdevep ep%d.%d %#p\n", d->nb, nep->nb, nep);
    return ep;
}
@

<<function epdataperm(arm)>>=
static int
epdataperm(int mode)
{

    switch(mode){
    case OREAD:
        return 0440|DMEXCL;
        break;
    case OWRITE:
        return 0220|DMEXCL;
        break;
    default:
        return 0660|DMEXCL;
    }
}
@

<<function usbgen(arm)>>=
static int
usbgen(Chan *c, char *, Dirtab*, int, int s, Dir *dp)
{
    Qid q;
    Dirtab *dir;
    int perm;
    char *se;
    Ep *ep;
    int nb;
    int mode;

    if(0)ddprint("usbgen q %#x s %d...", QID(c->qid), s);
    if(s == DEVDOTDOT){
        if(QID(c->qid) <= Qusbdir){
            mkqid(&q, Qdir, 0, QTDIR);
            devdir(c, q, "#u", 0, eve, 0555, dp);
        }else{
            mkqid(&q, Qusbdir, 0, QTDIR);
            devdir(c, q, "usb", 0, eve, 0555, dp);
        }
        if(0)ddprint("ok\n");
        return 1;
    }

    switch(QID(c->qid)){
    case Qdir:              /* list #u */
        if(s == 0){
            mkqid(&q, Qusbdir, 0, QTDIR);
            devdir(c, q, "usb", 0, eve, 0555, dp);
            if(0)ddprint("ok\n");
            return 1;
        }
        s--;
        if(s < 0 || s >= epmax)
            goto Fail;
        ep = getep(s);
        if(ep == nil || ep->name == nil){
            if(ep != nil)
                putep(ep);
            if(0)ddprint("skip\n");
            return 0;
        }
        if(waserror()){
            putep(ep);
            nexterror();
        }
        mkqid(&q, Qep0io+s*4, 0, QTFILE);
        devdir(c, q, ep->name, 0, eve, epdataperm(ep->mode), dp);
        putep(ep);
        poperror();
        if(0)ddprint("ok\n");
        return 1;

    case Qusbdir:               /* list #u/usb */
    Usbdir:
        if(s < nelem(usbdir)){
            dir = &usbdir[s];
            mkqid(&q, dir->qid.path, 0, QTFILE);
            devdir(c, q, dir->name, dir->length, eve, dir->perm, dp);
            if(0)ddprint("ok\n");
            return 1;
        }
        s -= nelem(usbdir);
        if(s < 0 || s >= epmax)
            goto Fail;
        ep = getep(s);
        if(ep == nil){
            if(0)ddprint("skip\n");
            return 0;
        }
        if(waserror()){
            putep(ep);
            nexterror();
        }
        se = up->genbuf+sizeof(up->genbuf);
        seprint(up->genbuf, se, "ep%d.%d", ep->dev->nb, ep->nb);
        mkqid(&q, Qep0dir+4*s, 0, QTDIR);
        putep(ep);
        poperror();
        devdir(c, q, up->genbuf, 0, eve, 0755, dp);
        if(0)ddprint("ok\n");
        return 1;

    case Qctl:
        s = 0;
        goto Usbdir;

    default:                /* list #u/usb/epN.M */
        nb = qid2epidx(QID(c->qid));
        ep = getep(nb);
        if(ep == nil)
            goto Fail;
        mode = ep->mode;
        putep(ep);
        if(isqtype(QID(c->qid), Qepdir)){
        Epdir:
            switch(s){
            case 0:
                mkqid(&q, Qep0io+nb*4, 0, QTFILE);
                perm = epdataperm(mode);
                devdir(c, q, "data", 0, eve, perm, dp);
                break;
            case 1:
                mkqid(&q, Qep0ctl+nb*4, 0, QTFILE);
                devdir(c, q, "ctl", 0, eve, 0664, dp);
                break;
            default:
                goto Fail;
            }
        }else if(isqtype(QID(c->qid), Qepctl)){
            s = 1;
            goto Epdir;
        }else{
            s = 0;
            goto Epdir;
        }
        if(0)ddprint("ok\n");
        return 1;
    }
Fail:
    if(0)ddprint("fail\n");
    return -1;
}
@

<<function hciprobe(arm)>>=
static Hci*
hciprobe(int cardno, int ctlrno)
{
    Hci *hp;
    char *type;
    char name[64];
    static int epnb = 1;    /* guess the endpoint nb. for the controller */

    ddprint("hciprobe %d %d\n", cardno, ctlrno);
    hp = smalloc(sizeof(Hci));
    hp->ctlrno = ctlrno;

    if(cardno < 0)
        for(cardno = 0; cardno < Nhcis; cardno++){
            if(hcitypes[cardno].type == nil)
                break;
            type = hp->type;
            if(type==nil || *type==0)
                type = "uhci";
            if(cistrcmp(hcitypes[cardno].type, type) == 0)
                break;
        }

    if(cardno >= Nhcis || hcitypes[cardno].type == nil){
        free(hp);
        return nil;
    }
    dprint("%s...", hcitypes[cardno].type);
    if(hcitypes[cardno].reset(hp) < 0){
        free(hp);
        return nil;
    }

    snprint(name, sizeof(name), "usb%s", hcitypes[cardno].type);
    arch_intrenable(hp->irq, hp->interrupt, hp, UNKNOWN, name);

    print("#u/usb/ep%d.0: %s: port %#luX irq %d\n",
        epnb, hcitypes[cardno].type, hp->port, hp->irq);
    epnb++;

    return hp;
}
@

<<function usbreset(arm)>>=
static void
usbreset(void)
{
    int cardno, ctlrno;
    Hci *hp;

    dprint("usbreset\n");

    for(ctlrno = 0; ctlrno < Nhcis; ctlrno++)
        if((hp = hciprobe(-1, ctlrno)) != nil)
            hcis[ctlrno] = hp;
    cardno = ctlrno = 0;
    while(cardno < Nhcis && ctlrno < Nhcis && hcitypes[cardno].type != nil)
        if(hcis[ctlrno] != nil)
            ctlrno++;
        else{
            hp = hciprobe(cardno, ctlrno);
            if(hp == nil)
                cardno++;
            hcis[ctlrno++] = hp;
        }
    if(hcis[Nhcis-1] != nil)
        print("usbreset: bug: Nhcis too small\n");
}
@

<<function usbinit(arm)>>=
static void
usbinit(void)
{
    Hci *hp;
    int ctlrno;
    Ep *d;
    char info[40];

    dprint("usbinit\n");
    for(ctlrno = 0; ctlrno < Nhcis; ctlrno++){
        hp = hcis[ctlrno];
        if(hp != nil){
            if(hp->init != nil)
                hp->init(hp);
            d = newdev(hp, 1, 1);       /* new root hub */
            d->dev->state = Denabled;   /* although addr == 0 */
            d->maxpkt = 64;
            snprint(info, sizeof(info), "ports %d", hp->nports);
            kstrdup(&d->info, info);
        }
    }
}
@

<<function usbattach(arm)>>=
static Chan*
usbattach(char *spec)
{
    return devattach(L'u', spec);
}
@

<<function usbwalk(arm)>>=
static Walkqid*
usbwalk(Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, nil, 0, usbgen);
}
@

<<function usbstat(arm)>>=
static int
usbstat(Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, nil, 0, usbgen);
}
@

<<function usbload(arm)>>=
/*
 * s for the given transfer, for bandwidth allocation.
 * This is a very rough worst case for what 5.11.3
 * of the usb 2.0 spec says.
 * Also, we are using maxpkt and not actual transfer sizes.
 * Only when we are sure we
 * are not exceeding b/w might we consider adjusting it.
 */
static ulong
usbload(int speed, int maxpkt)
{
    enum{ Hostns = 1000, Hubns = 333 };
    ulong l;
    ulong bs;

    l = 0;
    bs = 10UL * maxpkt;
    switch(speed){
    case Highspeed:
        l = 55*8*2 + 2 * (3 + bs) + Hostns;
        break;
    case Fullspeed:
        l = 9107 + 84 * (4 + bs) + Hostns;
        break;
    case Lowspeed:
        l = 64107 + 2 * Hubns + 667 * (3 + bs) + Hostns;
        break;
    default:
        print("usbload: bad speed %d\n", speed);
        /* let it run */
    }
    return l / 1000UL;  /* in s */
}
@

<<function usbopen(arm)>>=
static Chan*
usbopen(Chan *c, int omode)
{
    int q;
    Ep *ep;
    int mode;

    mode = openmode(omode);
    q = QID(c->qid);

    if(q >= Qep0dir && qid2epidx(q) < 0)
        error(Eio);
    if(q < Qep0dir || isqtype(q, Qepctl) || isqtype(q, Qepdir))
        return devopen(c, omode, nil, 0, usbgen);

    ep = getep(qid2epidx(q));
    if(ep == nil)
        error(Eio);
    deprint("usbopen q %#x fid %d omode %d\n", q, c->fid, mode);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    qlock(ep);
    if(ep->inuse){
        qunlock(ep);
        error(Einuse);
    }
    ep->inuse = 1;
    qunlock(ep);
    if(waserror()){
        ep->inuse = 0;
        nexterror();
    }
    if(mode != OREAD && ep->mode == OREAD)
        error(Eperm);
    if(mode != OWRITE && ep->mode == OWRITE)
        error(Eperm);
    if(ep->ttype == Tnone)
        error(Enotconf);
    ep->clrhalt = 0;
    ep->rhrepl = -1;
    if(ep->load == 0)
        ep->load = usbload(ep->dev->speed, ep->maxpkt);
    ep->hp->epopen(ep);

    poperror(); /* ep->inuse */
    poperror(); /* don't putep(): ref kept for fid using the ep. */

    c->mode = mode;
    c->flag |= COPEN;
    c->offset = 0;
    c->aux = nil;   /* paranoia */
    return c;
}
@

<<function epclose(arm)>>=
static void
epclose(Ep *ep)
{
    qlock(ep);
    if(waserror()){
        qunlock(ep);
        nexterror();
    }
    if(ep->inuse){
        ep->hp->epclose(ep);
        ep->inuse = 0;
    }
    qunlock(ep);
    poperror();
}
@

<<function usbclose(arm)>>=
static void
usbclose(Chan *c)
{
    int q;
    Ep *ep;

    q = QID(c->qid);
    if(q < Qep0dir || isqtype(q, Qepctl) || isqtype(q, Qepdir))
        return;

    ep = getep(qid2epidx(q));
    if(ep == nil)
        return;
    deprint("usbclose q %#x fid %d ref %ld\n", q, c->fid, ep->ref);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    if(c->flag & COPEN){
        free(c->aux);
        c->aux = nil;
        epclose(ep);
        putep(ep);  /* release ref kept since usbopen */
        c->flag &= ~COPEN;
    }
    poperror();
    putep(ep);
}
@

<<function ctlread(arm)>>=
static long
ctlread(Chan *c, void *a, long n, vlong offset)
{
    int q;
    char *s;
    char *us;
    char *se;
    Ep *ep;
    int i;

    q = QID(c->qid);
    us = s = smalloc(READSTR);
    se = s + READSTR;
    if(waserror()){
        free(us);
        nexterror();
    }
    if(q == Qctl)
        for(i = 0; i < epmax; i++){
            ep = getep(i);
            if(ep != nil){
                if(waserror()){
                    putep(ep);
                    nexterror();
                }
                s = seprint(s, se, "ep%d.%d ", ep->dev->nb, ep->nb);
                s = seprintep(s, se, ep, 0);
                poperror();
            }
            putep(ep);
        }
    else{
        ep = getep(qid2epidx(q));
        if(ep == nil)
            error(Eio);
        if(waserror()){
            putep(ep);
            nexterror();
        }
        if(c->aux != nil){
            /* After a new endpoint request we read
             * the new endpoint name back.
             */
            strecpy(s, se, c->aux);
            free(c->aux);
            c->aux = nil;
        }else
            seprintep(s, se, ep, 0);
        poperror();
        putep(ep);
    }
    n = readstr(offset, a, n, us);
    poperror();
    free(us);
    return n;
}
@

<<function rhubread(arm)>>=
/*
 * Fake root hub emulation.
 */
static long
rhubread(Ep *ep, void *a, long n)
{
    char *b;

    if(ep->dev->isroot == 0 || ep->nb != 0 || n < 2)
        return -1;
    if(ep->rhrepl < 0)
        return -1;

    b = a;
    memset(b, 0, n);
    PUT2(b, ep->rhrepl);
    ep->rhrepl = -1;
    return n;
}
@

<<function rhubwrite(arm)>>=
static long
rhubwrite(Ep *ep, void *a, long n)
{
    uchar *s;
    int cmd;
    int feature;
    int port;
    Hci *hp;

    if(ep->dev == nil || ep->dev->isroot == 0 || ep->nb != 0)
        return -1;
    if(n != Rsetuplen)
        error("root hub is a toy hub");
    ep->rhrepl = -1;
    s = a;
    if(s[Rtype] != (Rh2d|Rclass|Rother) && s[Rtype] != (Rd2h|Rclass|Rother))
        error("root hub is a toy hub");
    hp = ep->hp;
    cmd = s[Rreq];
    feature = GET2(s+Rvalue);
    port = GET2(s+Rindex);
    if(port < 1 || port > hp->nports)
        error("bad hub port number");
    switch(feature){
    case Rportenable:
        ep->rhrepl = hp->portenable(hp, port, cmd == Rsetfeature);
        break;
    case Rportreset:
        ep->rhrepl = hp->portreset(hp, port, cmd == Rsetfeature);
        break;
    case Rgetstatus:
        ep->rhrepl = hp->portstatus(hp, port);
        break;
    default:
        ep->rhrepl = 0;
    }
    return n;
}
@

<<function usbread(arm)>>=
static long
usbread(Chan *c, void *a, long n, vlong offset)
{
    int q;
    Ep *ep;
    int nr;

    q = QID(c->qid);

    if(c->qid.type == QTDIR)
        return devdirread(c, a, n, nil, 0, usbgen);

    if(q == Qctl || isqtype(q, Qepctl))
        return ctlread(c, a, n, offset);

    ep = getep(qid2epidx(q));
    if(ep == nil)
        error(Eio);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    if(ep->dev->state == Ddetach)
        error(Edetach);
    if(ep->mode == OWRITE || ep->inuse == 0)
        error(Ebadusefd);
    switch(ep->ttype){
    case Tnone:
        error("endpoint not configured");
    case Tctl:
        nr = rhubread(ep, a, n);
        if(nr >= 0){
            n = nr;
            break;
        }
        /* else fall */
    default:
        ddeprint("\nusbread q %#x fid %d cnt %ld off %lld\n",q,c->fid,n,offset);
        n = ep->hp->epread(ep, a, n);
        break;
    }
    poperror();
    putep(ep);
    return n;
}
@

<<function pow2(arm)>>=
static long
pow2(int n)
{
    return 1 << n;
}
@

<<function setmaxpkt(arm)>>=
static void
setmaxpkt(Ep *ep, char* s)
{
    long spp;   /* samples per packet */

    if(ep->dev->speed == Highspeed)
        spp = (ep->hz * ep->pollival * ep->ntds + 7999) / 8000;
    else
        spp = (ep->hz * ep->pollival + 999) / 1000;
    ep->maxpkt = spp * ep->samplesz;
    deprint("usb: %s: setmaxpkt: hz %ld poll %ld"
        " ntds %d %s speed -> spp %ld maxpkt %ld\n", s,
        ep->hz, ep->pollival, ep->ntds, spname[ep->dev->speed],
        spp, ep->maxpkt);
    if(ep->maxpkt > 1024){
        print("usb: %s: maxpkt %ld > 1024. truncating\n", s, ep->maxpkt);
        ep->maxpkt = 1024;
    }
}
@

<<function epctl(arm)>>=
/*
 * Many endpoint ctls. simply update the portable representation
 * of the endpoint. The actual controller driver will look
 * at them to setup the endpoints as dictated.
 */
static long
epctl(Ep *ep, Chan *c, void *a, long n)
{
    int i, l, mode, nb, tt;
    char *b, *s;
    Cmdbuf *cb;
    Cmdtab *ct;
    Ep *nep;
    Udev *d;
    static char *Info = "info ";

    d = ep->dev;

    cb = parsecmd(a, n);
    if(waserror()){
        free(cb);
        nexterror();
    }
    ct = lookupcmd(cb, epctls, nelem(epctls));
    if(ct == nil)
        error(Ebadctl);
    i = ct->index;
    if(i == CMnew || i == CMspeed || i == CMhub || i == CMpreset)
        if(ep != ep->ep0)
            error("allowed only on a setup endpoint");
    if(i != CMclrhalt && i != CMdetach && i != CMdebugep && i != CMname)
        if(ep != ep->ep0 && ep->inuse != 0)
            error("must configure before using");
    switch(i){
    case CMnew:
        deprint("usb epctl %s\n", cb->f[0]);
        nb = strtol(cb->f[1], nil, 0);
        if(nb < 0 || nb >= Ndeveps)
            error("bad endpoint number");
        tt = name2ttype(cb->f[2]);
        if(tt == Tnone)
            error("unknown endpoint type");
        mode = name2mode(cb->f[3]);
        if(mode < 0)
            error("unknown i/o mode");
        newdevep(ep, nb, tt, mode);
        break;
    case CMnewdev:
        deprint("usb epctl %s\n", cb->f[0]);
        if(ep != ep->ep0 || d->ishub == 0)
            error("not a hub setup endpoint");
        l = name2speed(cb->f[1]);
        if(l == Nospeed)
            error("speed must be full|low|high");
        nep = newdev(ep->hp, 0, 0);
        nep->dev->speed = l;
        if(nep->dev->speed  != Lowspeed)
            nep->maxpkt = 64;   /* assume full speed */
        nep->dev->hub = d->nb;
        nep->dev->port = atoi(cb->f[2]);
        /* next read request will read
         * the name for the new endpoint
         */
        l = sizeof(up->genbuf);
        snprint(up->genbuf, l, "ep%d.%d", nep->dev->nb, nep->nb);
        kstrdup(&c->aux, up->genbuf);
        break;
    case CMhub:
        deprint("usb epctl %s\n", cb->f[0]);
        d->ishub = 1;
        break;
    case CMspeed:
        l = name2speed(cb->f[1]);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l == Nospeed)
            error("speed must be full|low|high");
        qlock(ep->ep0);
        d->speed = l;
        qunlock(ep->ep0);
        break;
    case CMmaxpkt:
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l < 1 || l > 1024)
            error("maxpkt not in [1:1024]");
        qlock(ep);
        ep->maxpkt = l;
        qunlock(ep);
        break;
    case CMntds:
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l < 1 || l > 3)
            error("ntds not in [1:3]");
        qlock(ep);
        ep->ntds = l;
        qunlock(ep);
        break;
    case CMpollival:
        if(ep->ttype != Tintr && ep->ttype != Tiso)
            error("not an intr or iso endpoint");
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(ep->ttype == Tiso ||
           (ep->ttype == Tintr && ep->dev->speed == Highspeed)){
            if(l < 1 || l > 16)
                error("pollival power not in [1:16]");
            l = pow2(l-1);
        }else
            if(l < 1 || l > 255)
                error("pollival not in [1:255]");
        qlock(ep);
        ep->pollival = l;
        if(ep->ttype == Tiso)
            setmaxpkt(ep, "pollival");
        qunlock(ep);
        break;
    case CMsamplesz:
        if(ep->ttype != Tiso)
            error("not an iso endpoint");
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l <= 0 || l > 8)
            error("samplesz not in [1:8]");
        qlock(ep);
        ep->samplesz = l;
        setmaxpkt(ep, "samplesz");
        qunlock(ep);
        break;
    case CMhz:
        if(ep->ttype != Tiso)
            error("not an iso endpoint");
        l = strtoul(cb->f[1], nil, 0);
        deprint("usb epctl %s %d\n", cb->f[0], l);
        if(l <= 0 || l > 100000)
            error("hz not in [1:100000]");
        qlock(ep);
        ep->hz = l;
        setmaxpkt(ep, "hz");
        qunlock(ep);
        break;
    case CMclrhalt:
        qlock(ep);
        deprint("usb epctl %s\n", cb->f[0]);
        ep->clrhalt = 1;
        qunlock(ep);
        break;
    case CMinfo:
        deprint("usb epctl %s\n", cb->f[0]);
        l = strlen(Info);
        s = a;
        if(n < l+2 || strncmp(Info, s, l) != 0)
            error(Ebadctl);
        if(n > 1024)
            n = 1024;
        b = smalloc(n);
        memmove(b, s+l, n-l);
        b[n-l] = 0;
        if(b[n-l-1] == '\n')
            b[n-l-1] = 0;
        qlock(ep);
        free(ep->info);
        ep->info = b;
        qunlock(ep);
        break;
    case CMaddress:
        deprint("usb epctl %s\n", cb->f[0]);
        ep->dev->state = Denabled;
        break;
    case CMdetach:
        if(ep->dev->isroot != 0)
            error("can't detach a root hub");
        deprint("usb epctl %s ep%d.%d\n",
            cb->f[0], ep->dev->nb, ep->nb);
        ep->dev->state = Ddetach;
        /* Release file system ref. for its endpoints */
        for(i = 0; i < nelem(ep->dev->eps); i++)
            putep(ep->dev->eps[i]);
        break;
    case CMdebugep:
        if(strcmp(cb->f[1], "on") == 0)
            ep->debug = 1;
        else if(strcmp(cb->f[1], "off") == 0)
            ep->debug = 0;
        else
            ep->debug = strtoul(cb->f[1], nil, 0);
        print("usb: ep%d.%d debug %d\n",
            ep->dev->nb, ep->nb, ep->debug);
        break;
    case CMname:
        deprint("usb epctl %s %s\n", cb->f[0], cb->f[1]);
        validname(cb->f[1], 0);
        kstrdup(&ep->name, cb->f[1]);
        break;
    case CMtmout:
        deprint("usb epctl %s\n", cb->f[0]);
        if(ep->ttype == Tiso || ep->ttype == Tctl)
            error("ctl ignored for this endpoint type");
        ep->tmout = strtoul(cb->f[1], nil, 0);
        if(ep->tmout != 0 && ep->tmout < Xfertmout)
            ep->tmout = Xfertmout;
        break;
    case CMpreset:
        deprint("usb epctl %s\n", cb->f[0]);
        if(ep->ttype != Tctl)
            error("not a control endpoint");
        if(ep->dev->state != Denabled)
            error("forbidden on devices not enabled");
        ep->dev->state = Dreset;
        break;
    default:
        panic("usb: unknown epctl %d", ct->index);
    }
    free(cb);
    poperror();
    return n;
}
@

<<function usbctl(arm)>>=
static long
usbctl(void *a, long n)
{
    Cmdtab *ct;
    Cmdbuf *cb;
    Ep *ep;
    int i;

    cb = parsecmd(a, n);
    if(waserror()){
        free(cb);
        nexterror();
    }
    ct = lookupcmd(cb, usbctls, nelem(usbctls));
    dprint("usb ctl %s\n", cb->f[0]);
    switch(ct->index){
    case CMdebug:
        if(strcmp(cb->f[1], "on") == 0)
            debug = 1;
        else if(strcmp(cb->f[1], "off") == 0)
            debug = 0;
        else
            debug = strtol(cb->f[1], nil, 0);
        print("usb: debug %d\n", debug);
        for(i = 0; i < epmax; i++)
            if((ep = getep(i)) != nil){
                ep->hp->debug(ep->hp, debug);
                putep(ep);
            }
        break;
    case CMdump:
        dumpeps();
        break;
    }
    free(cb);
    poperror();
    return n;
}
@

<<function ctlwrite(arm)>>=
static long
ctlwrite(Chan *c, void *a, long n)
{
    int q;
    Ep *ep;

    q = QID(c->qid);
    if(q == Qctl)
        return usbctl(a, n);

    ep = getep(qid2epidx(q));
    if(ep == nil)
        error(Eio);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    if(ep->dev->state == Ddetach)
        error(Edetach);
    if(isqtype(q, Qepctl) && c->aux != nil){
        /* Be sure we don't keep a cloned ep name */
        free(c->aux);
        c->aux = nil;
        error("read, not write, expected");
    }
    n = epctl(ep, c, a, n);
    putep(ep);
    poperror();
    return n;
}
@

<<function usbwrite(arm)>>=
static long
usbwrite(Chan *c, void *a, long n, vlong off)
{
    int nr, q;
    Ep *ep;

    if(c->qid.type == QTDIR)
        error(Eisdir);

    q = QID(c->qid);

    if(q == Qctl || isqtype(q, Qepctl))
        return ctlwrite(c, a, n);

    ep = getep(qid2epidx(q));
    if(ep == nil)
        error(Eio);
    if(waserror()){
        putep(ep);
        nexterror();
    }
    if(ep->dev->state == Ddetach)
        error(Edetach);
    if(ep->mode == OREAD || ep->inuse == 0)
        error(Ebadusefd);

    switch(ep->ttype){
    case Tnone:
        error("endpoint not configured");
    case Tctl:
        nr = rhubwrite(ep, a, n);
        if(nr >= 0){
            n = nr;
            break;
        }
        /* else fall */
    default:
        ddeprint("\nusbwrite q %#x fid %d cnt %ld off %lld\n",q, c->fid, n, off);
        ep->hp->epwrite(ep, a, n);
    }
    putep(ep);
    poperror();
    return n;
}
@

<<function usbbread(arm)>>=
Block*
usbbread(Chan *c, long n, ulong offset)
{
    Block *bp;

    bp = allocb(n);
    if(bp == 0)
        error(Enomem);
    if(waserror()) {
        freeb(bp);
        nexterror();
    }
    bp->wp += usbread(c, bp->wp, n, offset);
    poperror();
    return bp;
}
@

<<function usbbwrite(arm)>>=
long
usbbwrite(Chan *c, Block *bp, ulong offset)
{
    long n;

    if(waserror()) {
        freeb(bp);
        nexterror();
    }
    n = usbwrite(c, bp->rp, BLEN(bp), offset);
    poperror();
    freeb(bp);

    return n;
}
@

<<function usbshutdown(arm)>>=
void
usbshutdown(void)
{
    Hci *hp;
    int i;

    for(i = 0; i < Nhcis; i++){
        hp = hcis[i];
        if(hp == nil)
            continue;
        if(hp->shutdown == nil)
            print("#u: no shutdown function for %s\n", hp->type);
        else
            hp->shutdown(hp);
    }
}
@

<<global usbdevtab(arm)>>=
Dev usbdevtab = {
    .dc = L'u',
    .name = "usb",

    .reset = usbreset,
    .init = usbinit,
    .shutdown = usbshutdown,
    .attach = usbattach,
    .walk = usbwalk,
    .stat = usbstat,
    .open = usbopen,
    .create = devcreate,
    .close = usbclose,
    .read = usbread,
    .bread = usbbread,
    .write = usbwrite,
    .bwrite = usbbwrite,
    .remove = devremove,
    .wstat = devwstat,
};
@


%-------------------------------------------------------------

<<buses/arm/devusb.c>>=
/*
 * USB device driver framework.
 *
 * This is in charge of providing access to actual HCIs
 * and providing I/O to the various endpoints of devices.
 * A separate user program (usbd) is in charge of
 * enumerating the bus, setting up endpoints and
 * starting devices (also user programs).
 *
 * The interface provided is a violation of the standard:
 * you're welcome.
 *
 * The interface consists of a root directory with several files
 * plus a directory (epN.M) with two files per endpoint.
 * A device is represented by its first endpoint, which
 * is a control endpoint automatically allocated for each device.
 * Device control endpoints may be used to create new endpoints.
 * Devices corresponding to hubs may also allocate new devices,
 * perhaps also hubs. Initially, a hub device is allocated for
 * each controller present, to represent its root hub. Those can
 * never be removed.
 *
 * All endpoints refer to the first endpoint (epN.0) of the device,
 * which keeps per-device information, and also to the HCI used
 * to reach them. Although all endpoints cache that information.
 *
 * epN.M/data files permit I/O and are considered DMEXCL.
 * epN.M/ctl files provide status info and accept control requests.
 *
 * Endpoints may be given file names to be listed also at #u,
 * for those drivers that have nothing to do after configuring the
 * device and its endpoints.
 *
 * Drivers for different controllers are kept at usb[oue]hci.c
 * It's likely we could factor out much from controllers into
 * a generic controller driver, the problem is that details
 * regarding how to handle toggles, tokens, Tds, etc. will
 * get in the way. Thus, code is probably easier the way it is.
 */
<<kernel basic includes>>

#include    "io.h"
#include    "../port/usb.h"

typedef struct Hcitype Hcitype;

<<enum _anon_ (buses/arm/devusb.c)(arm)>>

<<struct Hcitype(arm)>>

<<macro QID(arm)>>

<<global usbctls(arm)>>

<<global epctls(arm)>>

<<global usbdir(arm)>>

<<global usbmodename(arm)>>

<<global ttname(arm)>>

<<global spname(arm)>>

<<global debug(arm)>>
<<global hcitypes(arm)>>
<<global hcis(arm)>>
<<global epslck(arm)>>
<<global eps(arm)>>
<<global epmax(arm)>>
<<global usbidgen(arm)>>

<<function seprintdata(arm)>>

<<function name2speed(arm)>>

<<function name2ttype(arm)>>

<<function name2mode(arm)>>

<<function qid2epidx(arm)>>

<<function isqtype(arm)>>

<<function addhcitype(arm)>>

<<function seprintep(arm)>>

<<function epalloc(arm)>>

<<function getep(arm)>>

<<function putep(arm)>>

<<function dumpeps(arm)>>

<<function newusbid(arm)>>

<<function newdev(arm)>>

<<function newdevep(arm)>>

<<function epdataperm(arm)>>

<<function usbgen(arm)>>

<<function hciprobe(arm)>>

<<function usbreset(arm)>>

<<function usbinit(arm)>>

<<function usbattach(arm)>>

<<function usbwalk(arm)>>

<<function usbstat(arm)>>

<<function usbload(arm)>>

<<function usbopen(arm)>>

<<function epclose(arm)>>

<<function usbclose(arm)>>

<<function ctlread(arm)>>

<<function rhubread(arm)>>

<<function rhubwrite(arm)>>

<<function usbread(arm)>>

<<function pow2(arm)>>

<<function setmaxpkt(arm)>>

<<function epctl(arm)>>

<<function usbctl(arm)>>

<<function ctlwrite(arm)>>

<<function usbwrite(arm)>>

<<function usbbread(arm)>>

<<function usbbwrite(arm)>>

<<function usbshutdown(arm)>>

<<global usbdevtab(arm)>>
@


\subsection*{[[buses/arm/usbdwc.c]]}


<<enum _anon_ (buses/arm/usbdwc.c)(arm)>>=
enum
{
    Enabledelay = 50,
    Resetdelay  = 10,
    ResetdelayHS    = 50,

    Read        = 0,
    Write       = 1,
};
@

<<struct Ctlr (buses/arm/usbdwc.c)(arm)>>=
struct Ctlr {
    Lock;
    Dwcregs *regs;      /* controller registers */
    int nchan;      /* number of host channels */
    ulong   chanbusy;   /* bitmap of in-use channels */
    QLock   chanlock;   /* serialise access to chanbusy */
    QLock   split;      /* serialise split transactions */
    int splitretry; /* count retries of Nyet */
    int sofchan;    /* bitmap of channels waiting for sof */
    int wakechan;   /* bitmap of channels to wakeup after fiq */
    int debugchan;  /* bitmap of channels for interrupt debug */
    Rendez  *chanintr;  /* sleep till interrupt on channel N */
};
@

<<struct Epio(arm)>>=
struct Epio {
    QLock;
    Block   *cb;
    ulong   lastpoll;
};
@

<<global dwc(arm)>>=
static Ctlr dwc;
@

<<global debug (buses/arm/usbdwc.c)(arm)>>=
static int debug;
@

<<global Ebadlen(arm)>>=
static char Ebadlen[] = "bad usb request length";
@

<<function filock(arm)>>=
static void
filock(Lock *l)
{
    int x;

    x = splfhi();
    ilock(l);
    l->sr = x;
}
@

<<function fiunlock(arm)>>=
static void
fiunlock(Lock *l)
{
    iunlock(l);
}
@

<<function chanalloc(arm)>>=
static Hostchan*
chanalloc(Ep *ep)
{
    Ctlr *ctlr;
    int bitmap, i;

    ctlr = ep->hp->aux;
    qlock(&ctlr->chanlock);
    bitmap = ctlr->chanbusy;
    for(i = 0; i < ctlr->nchan; i++)
        if((bitmap & (1<<i)) == 0){
            ctlr->chanbusy = bitmap | 1<<i;
            qunlock(&ctlr->chanlock);
            return &ctlr->regs->hchan[i];
        }
    qunlock(&ctlr->chanlock);
    panic("miller is a lazy git");
    return nil;
}
@

<<function chanrelease(arm)>>=
static void
chanrelease(Ep *ep, Hostchan *chan)
{
    Ctlr *ctlr;
    int i;

    ctlr = ep->hp->aux;
    i = chan - ctlr->regs->hchan;
    qlock(&ctlr->chanlock);
    ctlr->chanbusy &= ~(1<<i);
    qunlock(&ctlr->chanlock);
}
@

<<function chansetup(arm)>>=
static void
chansetup(Hostchan *hc, Ep *ep)
{
    int hcc;
    Ctlr *ctlr = ep->hp->aux;

    if(ep->debug)
        ctlr->debugchan |= 1 << (hc - ctlr->regs->hchan);
    else
        ctlr->debugchan &= ~(1 << (hc - ctlr->regs->hchan));
    switch(ep->dev->state){
    case Dconfig:
    case Dreset:
        hcc = 0;
        break;
    default:
        hcc = ep->dev->nb<<ODevaddr;
        break;
    }
    hcc |= ep->maxpkt | 1<<OMulticnt | ep->nb<<OEpnum;
    switch(ep->ttype){
    case Tctl:
        hcc |= Epctl;
        break;
    case Tiso:
        hcc |= Episo;
        break;
    case Tbulk:
        hcc |= Epbulk;
        break;
    case Tintr:
        hcc |= Epintr;
        break;
    }
    switch(ep->dev->speed){
    case Lowspeed:
        hcc |= Lspddev;
        /* fall through */
    case Fullspeed:
        if(ep->dev->hub > 1){
            hc->hcsplt = Spltena | POS_ALL | ep->dev->hub<<OHubaddr |
                ep->dev->port;
            break;
        }
        /* fall through */
    default:
        hc->hcsplt = 0;
        break;
    }
    hc->hcchar = hcc;
    hc->hcint = ~0;
}
@

<<function sofdone(arm)>>=
static int
sofdone(void *a)
{
    Dwcregs *r;

    r = a;
    return (r->gintmsk & Sofintr) == 0;
}
@

<<function sofwait(arm)>>=
static void
sofwait(Ctlr *ctlr, int n)
{
    Dwcregs *r;

    r = ctlr->regs;
    do{
        filock(ctlr);
        r->gintsts = Sofintr;
        ctlr->sofchan |= 1<<n;
        r->gintmsk |= Sofintr;
        fiunlock(ctlr);
        sleep(&ctlr->chanintr[n], sofdone, r);
    }while((r->hfnum & 7) == 6);
}
@

<<function chandone(arm)>>=
static int
chandone(void *a)
{
    Hostchan *hc;

    hc = a;
    if(hc->hcint == (Chhltd|Ack))
        return 0;
    return (hc->hcint & hc->hcintmsk) != 0;
}
@

<<function chanwait(arm)>>=
static int
chanwait(Ep *ep, Ctlr *ctlr, Hostchan *hc, int mask)
{
    int intr, n, ointr;
    ulong start, now;
    Dwcregs *r;

    r = ctlr->regs;
    n = hc - r->hchan;
    for(;;){
restart:
        filock(ctlr);
        r->haintmsk |= 1<<n;
        hc->hcintmsk = mask;
        fiunlock(ctlr);
        sleep(&ctlr->chanintr[n], chandone, hc);
        hc->hcintmsk = 0;
        intr = hc->hcint;
        if(intr & Chhltd)
            return intr;
        start = arch_fastticks(0);
        ointr = intr;
        now = start;
        do{
            intr = hc->hcint;
            if(intr & Chhltd){
                if((ointr != Ack && ointr != (Ack|Xfercomp)) ||
                   intr != (Ack|Chhltd|Xfercomp) ||
                   (now - start) > 60)
                    dprint("await %x after %ld %x -> %x\n",
                        mask, now - start, ointr, intr);
                return intr;
            }
            if((intr & mask) == 0){
                dprint("ep%d.%d await %x intr %x -> %x\n",
                    ep->dev->nb, ep->nb, mask, ointr, intr);
                goto restart;
            }
            now = arch_fastticks(0);
        }while(now - start < 100);
        dprint("ep%d.%d halting channel %8.8ux hcchar %8.8ux "
            "grxstsr %8.8ux gnptxsts %8.8ux hptxsts %8.8ux\n",
            ep->dev->nb, ep->nb, intr, hc->hcchar, r->grxstsr,
            r->gnptxsts, r->hptxsts);
        mask = Chhltd;
        hc->hcchar |= Chdis;
        start = cpu->ticks;
        while(hc->hcchar & Chen){
            if(cpu->ticks - start >= 100){
                print("ep%d.%d channel won't halt hcchar %8.8ux\n",
                    ep->dev->nb, ep->nb, hc->hcchar);
                break;
            }
        }
        logdump(ep);
    }
}
@

<<function chanintr(arm)>>=
static int
chanintr(Ctlr *ctlr, int n)
{
    Hostchan *hc;
    int i;

    hc = &ctlr->regs->hchan[n];
    if(ctlr->debugchan & (1<<n))
        clog(nil, hc);
    if((hc->hcsplt & Spltena) == 0)
        return 0;
    i = hc->hcint;
    if(i == (Chhltd|Ack)){
        hc->hcsplt |= Compsplt;
        ctlr->splitretry = 0;
    }else if(i == (Chhltd|Nyet)){
        if(++ctlr->splitretry >= 3)
            return 0;
    }else
        return 0;
    if(hc->hcchar & Chen){
        iprint("hcchar %8.8ux hcint %8.8ux", hc->hcchar, hc->hcint);
        hc->hcchar |= Chen | Chdis;
        while(hc->hcchar&Chen)
            ;
        iprint(" %8.8ux\n", hc->hcint);
    }
    hc->hcint = i;
    if(ctlr->regs->hfnum & 1)
        hc->hcchar &= ~Oddfrm;
    else
        hc->hcchar |= Oddfrm;
    hc->hcchar = (hc->hcchar &~ Chdis) | Chen;
    return 1;
}
@

<<global chanlog(arm)>>=
static Reg chanlog[32][5];
@

<<global nchanlog(arm)>>=
static int nchanlog;
@

<<function logstart(arm)>>=
static void
logstart(Ep *ep)
{
    if(ep->debug)
        nchanlog = 0;
}
@

<<function clog(arm)>>=
static void
clog(Ep *ep, Hostchan *hc)
{
    Reg *p;

    if(ep != nil && !ep->debug)
        return;
    if(nchanlog == 32)
        nchanlog--;
    p = chanlog[nchanlog];
    p[0] = dwc.regs->hfnum;
    p[1] = hc->hcchar;
    p[2] = hc->hcint;
    p[3] = hc->hctsiz;
    p[4] = hc->hcdma;
    nchanlog++;
}
@

<<function logdump(arm)>>=
static void
logdump(Ep *ep)
{
    Reg *p;
    int i;

    if(!ep->debug)
        return;
    p = chanlog[0];
    for(i = 0; i < nchanlog; i++){
        print("%5.5d.%5.5d %8.8ux %8.8ux %8.8ux %8.8ux\n",
            p[0]&0xFFFF, p[0]>>16, p[1], p[2], p[3], p[4]);
        p += 5;
    }
    nchanlog = 0;
}
@

<<function chanio(arm)>>=
static int
chanio(Ep *ep, Hostchan *hc, int dir, int pid, void *a, int len)
{
    Ctlr *ctlr;
    int nleft, n, nt, i, maxpkt, npkt;
    uint hcdma, hctsiz;

    ctlr = ep->hp->aux;
    maxpkt = ep->maxpkt;
    npkt = HOWMANY(len, ep->maxpkt);
    if(npkt == 0)
        npkt = 1;

    hc->hcchar = (hc->hcchar & ~Epdir) | dir;
    if(dir == Epin)
        n = ROUND(len, ep->maxpkt);
    else
        n = len;
    hc->hctsiz = n | npkt<<OPktcnt | pid;
    hc->hcdma  = dmaaddr(a);

    nleft = len;
    logstart(ep);
    for(;;){
        hcdma = hc->hcdma;
        hctsiz = hc->hctsiz;
        hc->hctsiz = hctsiz & ~Dopng;
        if(hc->hcchar&Chen){
            dprint("ep%d.%d before chanio hcchar=%8.8ux\n",
                ep->dev->nb, ep->nb, hc->hcchar);
            hc->hcchar |= Chen | Chdis;
            while(hc->hcchar&Chen)
                ;
            hc->hcint = Chhltd;
        }
        if((i = hc->hcint) != 0){
            dprint("ep%d.%d before chanio hcint=%8.8ux\n",
                ep->dev->nb, ep->nb, i);
            hc->hcint = i;
        }
        if(hc->hcsplt & Spltena){
            qlock(&ctlr->split);
            sofwait(ctlr, hc - ctlr->regs->hchan);
            if((dwc.regs->hfnum & 1) == 0)
                hc->hcchar &= ~Oddfrm;
            else
                hc->hcchar |= Oddfrm;
        }
        hc->hcchar = (hc->hcchar &~ Chdis) | Chen;
        clog(ep, hc);
        if(ep->ttype == Tbulk && dir == Epin)
            i = chanwait(ep, ctlr, hc, /* Ack| */ Chhltd);
        else if(ep->ttype == Tintr && (hc->hcsplt & Spltena))
            i = chanwait(ep, ctlr, hc, Chhltd);
        else
            i = chanwait(ep, ctlr, hc, Chhltd|Nak);
        clog(ep, hc);
        hc->hcint = i;

        if(hc->hcsplt & Spltena){
            hc->hcsplt &= ~Compsplt;
            qunlock(&ctlr->split);
        }

        if((i & Xfercomp) == 0 && i != (Chhltd|Ack) && i != Chhltd){
            if(i & Stall)
                error(Estalled);
            if(i & (Nyet|Frmovrun))
                continue;
            if(i & Nak){
                if(ep->ttype == Tintr)
                    tsleep(&up->sleepr, returnfalse, 0, ep->pollival);
                else
                    tsleep(&up->sleepr, returnfalse, 0, 1);
                continue;
            }
            logdump(ep);
            print("usbotg: ep%d.%d error intr %8.8ux\n",
                ep->dev->nb, ep->nb, i);
            if(i & ~(Chhltd|Ack))
                error(Eio);
            if(hc->hcdma != hcdma)
                print("usbotg: weird hcdma %x->%x intr %x->%x\n",
                    hcdma, hc->hcdma, i, hc->hcint);
        }
        n = hc->hcdma - hcdma;
        if(n == 0){
            if((hc->hctsiz & Pktcnt) != (hctsiz & Pktcnt))
                break;
            else
                continue;
        }
        if(dir == Epin && ep->ttype == Tbulk && n == nleft){
            nt = (hctsiz & Xfersize) - (hc->hctsiz & Xfersize);
            if(nt != n){
                if(n == ROUND(nt, 4))
                    n = nt;
                else
                    print("usbotg: intr %8.8ux "
                        "dma %8.8ux-%8.8ux "
                        "hctsiz %8.8ux-%8.ux\n",
                        i, hcdma, hc->hcdma, hctsiz,
                        hc->hctsiz);
            }
        }
        if(n > nleft){
            if(n != ROUND(nleft, 4))
                dprint("too much: wanted %d got %d\n",
                    len, len - nleft + n);
            n = nleft;
        }
        nleft -= n;
        if(nleft == 0 || (n % maxpkt) != 0)
            break;
        if((i & Xfercomp) && ep->ttype != Tctl)
            break;
        if(dir == Epout)
            dprint("too little: nleft %d hcdma %x->%x hctsiz %x->%x intr %x\n",
                nleft, hcdma, hc->hcdma, hctsiz, hc->hctsiz, i);
    }
    logdump(ep);
    return len - nleft;
}
@

<<function multitrans(arm)>>=
static long
multitrans(Ep *ep, Hostchan *hc, int rw, void *a, long n)
{
    long sofar, m;

    sofar = 0;
    do{
        m = n - sofar;
        if(m > ep->maxpkt)
            m = ep->maxpkt;
        m = chanio(ep, hc, rw == Read? Epin : Epout, ep->toggle[rw],
            (char*)a + sofar, m);
        ep->toggle[rw] = hc->hctsiz & Pid;
        sofar += m;
    }while(sofar < n && m == ep->maxpkt);
    return sofar;
}
@

<<function eptrans(arm)>>=
static long
eptrans(Ep *ep, int rw, void *a, long n)
{
    Hostchan *hc;

    if(ep->clrhalt){
        ep->clrhalt = 0;
        if(ep->mode != OREAD)
            ep->toggle[Write] = DATA0;
        if(ep->mode != OWRITE)
            ep->toggle[Read] = DATA0;
    }
    hc = chanalloc(ep);
    if(waserror()){
        ep->toggle[rw] = hc->hctsiz & Pid;
        chanrelease(ep, hc);
        if(strcmp(up->errstr, Estalled) == 0)
            return 0;
        nexterror();
    }
    chansetup(hc, ep);
    if(rw == Read && ep->ttype == Tbulk)
        n = multitrans(ep, hc, rw, a, n);
    else{
        n = chanio(ep, hc, rw == Read? Epin : Epout, ep->toggle[rw],
            a, n);
        ep->toggle[rw] = hc->hctsiz & Pid;
    }
    chanrelease(ep, hc);
    poperror();
    return n;
}
@

<<function ctltrans(arm)>>=
static long
ctltrans(Ep *ep, uchar *req, long n)
{
    Hostchan *hc;
    Epio *epio;
    Block *b;
    uchar *data;
    int datalen;

    epio = ep->aux;
    if(epio->cb != nil){
        freeb(epio->cb);
        epio->cb = nil;
    }
    if(n < Rsetuplen)
        error(Ebadlen);
    if(req[Rtype] & Rd2h){
        datalen = GET2(req+Rcount);
        if(datalen <= 0 || datalen > Maxctllen)
            error(Ebadlen);
        /* XXX cache madness */
        epio->cb = b = allocb(ROUND(datalen, ep->maxpkt));
        assert(((uintptr)b->wp & (BLOCKALIGN-1)) == 0);
        memset(b->wp, 0x55, b->lim - b->wp);
        cachedwbinvse(b->wp, b->lim - b->wp);
        data = b->wp;
    }else{
        b = nil;
        datalen = n - Rsetuplen;
        data = req + Rsetuplen;
    }
    hc = chanalloc(ep);
    if(waserror()){
        chanrelease(ep, hc);
        if(strcmp(up->errstr, Estalled) == 0)
            return 0;
        nexterror();
    }
    chansetup(hc, ep);
    chanio(ep, hc, Epout, SETUP, req, Rsetuplen);
    if(req[Rtype] & Rd2h){
        if(ep->dev->hub <= 1){
            ep->toggle[Read] = DATA1;
            b->wp += multitrans(ep, hc, Read, data, datalen);
        }else
            b->wp += chanio(ep, hc, Epin, DATA1, data, datalen);
        chanio(ep, hc, Epout, DATA1, nil, 0);
        n = Rsetuplen;
    }else{
        if(datalen > 0)
            chanio(ep, hc, Epout, DATA1, data, datalen);
        chanio(ep, hc, Epin, DATA1, nil, 0);
        n = Rsetuplen + datalen;
    }
    chanrelease(ep, hc);
    poperror();
    return n;
}
@

<<function ctldata(arm)>>=
static long
ctldata(Ep *ep, void *a, long n)
{
    Epio *epio;
    Block *b;

    epio = ep->aux;
    b = epio->cb;
    if(b == nil)
        return 0;
    if(n > BLEN(b))
        n = BLEN(b);
    memmove(a, b->rp, n);
    b->rp += n;
    if(BLEN(b) == 0){
        freeb(b);
        epio->cb = nil;
    }
    return n;
}
@

<<function greset(arm)>>=
static void
greset(Dwcregs *r, int bits)
{
    r->grstctl |= bits;
    while(r->grstctl & bits)
        ;
    arch_microdelay(10);
}
@

<<function init(arm)>>=
static void
init(Hci *hp)
{
    Ctlr *ctlr;
    Dwcregs *r;
    uint n, rx, tx, ptx;

    ctlr = hp->aux;
    r = ctlr->regs;

    ctlr->nchan = 1 + ((r->ghwcfg2 & Num_host_chan) >> ONum_host_chan);
    ctlr->chanintr = malloc(ctlr->nchan * sizeof(Rendez));

    r->gahbcfg = 0;
    setpower(PowerUsb, 1);

    while((r->grstctl&Ahbidle) == 0)
        ;
    greset(r, Csftrst);

    r->gusbcfg |= Force_host_mode;
    tsleep(&up->sleepr, returnfalse, 0, 25);
    r->gahbcfg |= Dmaenable;

    n = (r->ghwcfg3 & Dfifo_depth) >> ODfifo_depth;
    rx = 0x306;
    tx = 0x100;
    ptx = 0x200;
    r->grxfsiz = rx;
    r->gnptxfsiz = rx | tx<<ODepth;
    tsleep(&up->sleepr, returnfalse, 0, 1);
    r->hptxfsiz = (rx + tx) | ptx << ODepth;
    greset(r, Rxfflsh);
    r->grstctl = TXF_ALL;
    greset(r, Txfflsh);
    dprint("usbotg: FIFO depth %d sizes rx/nptx/ptx %8.8ux %8.8ux %8.8ux\n",
        n, r->grxfsiz, r->gnptxfsiz, r->hptxfsiz);

    r->hport0 = Prtpwr|Prtconndet|Prtenchng|Prtovrcurrchng;
    r->gintsts = ~0;
    r->gintmsk = Hcintr;
    r->gahbcfg |= Glblintrmsk;
}
@

<<function dump (buses/arm/usbdwc.c)(arm)>>=
static void
dump(Hci*)
{
}
@

<<function fiqintr(arm)>>=
static void
fiqintr(Ureg*, void *a)
{
    Hci *hp;
    Ctlr *ctlr;
    Dwcregs *r;
    uint intr, haint, wakechan;
    int i;

    hp = a;
    ctlr = hp->aux;
    r = ctlr->regs;
    wakechan = 0;
    filock(ctlr);
    intr = r->gintsts;
    if(intr & Hcintr){
        haint = r->haint & r->haintmsk;
        for(i = 0; haint; i++){
            if(haint & 1){
                if(chanintr(ctlr, i) == 0){
                    r->haintmsk &= ~(1<<i);
                    wakechan |= 1<<i;
                }
            }
            haint >>= 1;
        }
    }
    if(intr & Sofintr){
        r->gintsts = Sofintr;
        if((r->hfnum&7) != 6){
            r->gintmsk &= ~Sofintr;
            wakechan |= ctlr->sofchan;
            ctlr->sofchan = 0;
        }
    }
    if(wakechan){
        ctlr->wakechan |= wakechan;
        armtimerset(1);
    }
    fiunlock(ctlr);
}
@

<<function irqintr(arm)>>=
static void
irqintr(Ureg*, void *a)
{
    Ctlr *ctlr;
    uint wakechan;
    int i;

    ctlr = a;
    filock(ctlr);
    armtimerset(0);
    wakechan = ctlr->wakechan;
    ctlr->wakechan = 0;
    fiunlock(ctlr);
    for(i = 0; wakechan; i++){
        if(wakechan & 1)
            wakeup(&ctlr->chanintr[i]);
        wakechan >>= 1;
    }
}
@

<<function epopen(arm)>>=
static void
epopen(Ep *ep)
{
    ddprint("usbotg: epopen ep%d.%d ttype %d\n",
        ep->dev->nb, ep->nb, ep->ttype);
    switch(ep->ttype){
    case Tnone:
        error(Enotconf);
    case Tintr:
        assert(ep->pollival > 0);
        /* fall through */
    case Tbulk:
        if(ep->toggle[Read] == 0)
            ep->toggle[Read] = DATA0;
        if(ep->toggle[Write] == 0)
            ep->toggle[Write] = DATA0;
        break;
    }
    ep->aux = malloc(sizeof(Epio));
    if(ep->aux == nil)
        error(Enomem);
}
@

<<function epclose (buses/arm/usbdwc.c)(arm)>>=
static void
epclose(Ep *ep)
{
    ddprint("usbotg: epclose ep%d.%d ttype %d\n",
        ep->dev->nb, ep->nb, ep->ttype);
    switch(ep->ttype){
    case Tctl:
        freeb(((Epio*)ep->aux)->cb);
        /* fall through */
    default:
        free(ep->aux);
        break;
    }
}
@

<<function epread(arm)>>=
static long
epread(Ep *ep, void *a, long n)
{
    Epio *epio;
    Block *b;
    uchar *p;
    ulong elapsed;
    long nr;

    ddprint("epread ep%d.%d %ld\n", ep->dev->nb, ep->nb, n);
    epio = ep->aux;
    b = nil;
    qlock(epio);
    if(waserror()){
        qunlock(epio);
        if(b)
            freeb(b);
        nexterror();
    }
    switch(ep->ttype){
    default:
        error(Egreg);
    case Tctl:
        nr = ctldata(ep, a, n);
        qunlock(epio);
        poperror();
        return nr;
    case Tintr:
        elapsed = TK2MS(cpu->ticks) - epio->lastpoll;
        if(elapsed < ep->pollival)
            tsleep(&up->sleepr, returnfalse, 0, ep->pollival - elapsed);
        /* fall through */
    case Tbulk:
        /* XXX cache madness */
        b = allocb(ROUND(n, ep->maxpkt));
        p = b->rp;
        assert(((uintptr)p & (BLOCKALIGN-1)) == 0);
        cachedinvse(p, n);
        nr = eptrans(ep, Read, p, n);
        cachedinvse(p, nr);
        epio->lastpoll = TK2MS(cpu->ticks);
        memmove(a, p, nr);
        qunlock(epio);
        freeb(b);
        poperror();
        return nr;
    }
}
@

<<function epwrite(arm)>>=
static long
epwrite(Ep *ep, void *a, long n)
{
    Epio *epio;
    Block *b;
    uchar *p;
    ulong elapsed;

    ddprint("epwrite ep%d.%d %ld\n", ep->dev->nb, ep->nb, n);
    epio = ep->aux;
    b = nil;
    qlock(epio);
    if(waserror()){
        qunlock(epio);
        if(b)
            freeb(b);
        nexterror();
    }
    switch(ep->ttype){
    default:
        error(Egreg);
    case Tintr:
        elapsed = TK2MS(cpu->ticks) - epio->lastpoll;
        if(elapsed < ep->pollival)
            tsleep(&up->sleepr, returnfalse, 0, ep->pollival - elapsed);
        /* fall through */
    case Tctl:
    case Tbulk:
        /* XXX cache madness */
        b = allocb(n);
        p = b->wp;
        assert(((uintptr)p & (BLOCKALIGN-1)) == 0);
        memmove(p, a, n);
        cachedwbse(p, n);
        if(ep->ttype == Tctl)
            n = ctltrans(ep, p, n);
        else{
            n = eptrans(ep, Write, p, n);
            epio->lastpoll = TK2MS(cpu->ticks);
        }
        qunlock(epio);
        freeb(b);
        poperror();
        return n;
    }
}
@

<<function seprintep (buses/arm/usbdwc.c)(arm)>>=
static char*
seprintep(char *s, char*, Ep*)
{
    return s;
}
@

<<function portenable(arm)>>=
static int
portenable(Hci *hp, int port, int on)
{
    Ctlr *ctlr;
    Dwcregs *r;

    assert(port == 1);
    ctlr = hp->aux;
    r = ctlr->regs;
    dprint("usbotg enable=%d; sts %#x\n", on, r->hport0);
    if(!on)
        r->hport0 = Prtpwr | Prtena;
    tsleep(&up->sleepr, returnfalse, 0, Enabledelay);
    dprint("usbotg enable=%d; sts %#x\n", on, r->hport0);
    return 0;
}
@

<<function portreset(arm)>>=
static int
portreset(Hci *hp, int port, int on)
{
    Ctlr *ctlr;
    Dwcregs *r;
    int b, s;

    assert(port == 1);
    ctlr = hp->aux;
    r = ctlr->regs;
    dprint("usbotg reset=%d; sts %#x\n", on, r->hport0);
    if(!on)
        return 0;
    r->hport0 = Prtpwr | Prtrst;
    tsleep(&up->sleepr, returnfalse, 0, ResetdelayHS);
    r->hport0 = Prtpwr;
    tsleep(&up->sleepr, returnfalse, 0, Enabledelay);
    s = r->hport0;
    b = s & (Prtconndet|Prtenchng|Prtovrcurrchng);
    if(b != 0)
        r->hport0 = Prtpwr | b;
    dprint("usbotg reset=%d; sts %#x\n", on, s);
    if((s & Prtena) == 0)
        print("usbotg: host port not enabled after reset");
    return 0;
}
@

<<function portstatus(arm)>>=
static int
portstatus(Hci *hp, int port)
{
    Ctlr *ctlr;
    Dwcregs *r;
    int b, s;

    assert(port == 1);
    ctlr = hp->aux;
    r = ctlr->regs;
    s = r->hport0;
    b = s & (Prtconndet|Prtenchng|Prtovrcurrchng);
    if(b != 0)
        r->hport0 = Prtpwr | b;
    b = 0;
    if(s & Prtconnsts)
        b |= HPpresent;
    if(s & Prtconndet)
        b |= HPstatuschg;
    if(s & Prtena)
        b |= HPenable;
    if(s & Prtenchng)
        b |= HPchange;
    if(s & Prtovrcurract)
         b |= HPovercurrent;
    if(s & Prtsusp)
        b |= HPsuspend;
    if(s & Prtrst)
        b |= HPreset;
    if(s & Prtpwr)
        b |= HPpower;
    switch(s & Prtspd){
    case HIGHSPEED:
        b |= HPhigh;
        break;
    case LOWSPEED:
        b |= HPslow;
        break;
    }
    return b;
}
@

<<function shutdown(arm)>>=
static void
shutdown(Hci*)
{
}
@

<<function setdebug(arm)>>=
static void
setdebug(Hci*, int d)
{
    debug = d;
}
@

<<function reset(arm)>>=
static int
reset(Hci *hp)
{
    Ctlr *ctlr;
    uint id;

    ctlr = &dwc;
    if(ctlr->regs != nil)
        return -1;
    ctlr->regs = (Dwcregs*)USBREGS;
    id = ctlr->regs->gsnpsid;
    if((id>>16) != ('O'<<8 | 'T'))
        return -1;
    dprint("usbotg: rev %d.%3.3x\n", (id>>12)&0xF, id&0xFFF);

    arch_intrenable(IRQtimerArm, irqintr, ctlr, 0, "dwc");

    hp->aux = ctlr;
    hp->port = 0;
    hp->irq = IRQusb;
    hp->tbdf = 0;
    hp->nports = 1;
    hp->highspeed = 1;

    hp->init = init;
    hp->dump = dump;
    hp->interrupt = fiqintr;
    hp->epopen = epopen;
    hp->epclose = epclose;
    hp->epread = epread;
    hp->epwrite = epwrite;
    hp->seprintep = seprintep;
    hp->portenable = portenable;
    hp->portreset = portreset;
    hp->portstatus = portstatus;
    hp->shutdown = shutdown;
    hp->debug = setdebug;
    hp->type = "dwcotg";
    return 0;
}
@

<<function usbdwclink(arm)>>=
void
usbdwclink(void)
{
    addhcitype("dwcotg", reset);
}
@


%-------------------------------------------------------------

<<buses/arm/usbdwc.c>>=
/*
 * USB host driver for BCM2835
 *  Synopsis DesignWare Core USB 2.0 OTG controller
 *
 * Copyright  2012 Richard Miller <r.miller@acm.org>
 *
 * This is work in progress:
 * - no isochronous pipes
 * - no bandwidth budgeting
 * - frame scheduling is crude
 * - error handling is overly optimistic
 * It should be just about adequate for a Plan 9 terminal with
 * keyboard, mouse, ethernet adapter, and an external flash drive.
 */
<<kernel basic includes>>

#include    "io.h"
#include    "../port/usb.h"

#include "dwcotg.h"

<<constant USBREGS(arm)>>
<<enum _anon_ (buses/arm/usbdwc.c)(arm)>>

typedef struct Ctlr Ctlr;
typedef struct Epio Epio;

<<struct Ctlr (buses/arm/usbdwc.c)(arm)>>

<<struct Epio(arm)>>

<<global dwc(arm)>>
<<global debug (buses/arm/usbdwc.c)(arm)>>

<<global Ebadlen(arm)>>

static void clog(Ep *ep, Hostchan *hc);
static void logdump(Ep *ep);

<<function filock(arm)>>

<<function fiunlock(arm)>>

<<function chanalloc(arm)>>

<<function chanrelease(arm)>>

<<function chansetup(arm)>>

<<function sofdone(arm)>>

<<function sofwait(arm)>>

<<function chandone(arm)>>

<<function chanwait(arm)>>

<<function chanintr(arm)>>

<<global chanlog(arm)>>
<<global nchanlog(arm)>>

<<function logstart(arm)>>

<<function clog(arm)>>

<<function logdump(arm)>>

<<function chanio(arm)>>

<<function multitrans(arm)>>

<<function eptrans(arm)>>

<<function ctltrans(arm)>>

<<function ctldata(arm)>>

<<function greset(arm)>>

<<function init(arm)>>

<<function dump (buses/arm/usbdwc.c)(arm)>>

<<function fiqintr(arm)>>

<<function irqintr(arm)>>

<<function epopen(arm)>>

<<function epclose (buses/arm/usbdwc.c)(arm)>>

<<function epread(arm)>>

<<function epwrite(arm)>>

<<function seprintep (buses/arm/usbdwc.c)(arm)>>
    
<<function portenable(arm)>>

<<function portreset(arm)>>

<<function portstatus(arm)>>

<<function shutdown(arm)>>

<<function setdebug(arm)>>

<<function reset(arm)>>

<<function usbdwclink(arm)>>
@


\subsection*{[[buses/arm/dma.c]]}

<<macro IRQDMA(arm)>>=
#define IRQDMA(chan)    (IRQdma0+(chan))
@

<<enum Dma(arm)>>=
enum DmaFlags {
    DmaD2M      = 0,        /* device to memory */
    DmaM2D      = 1,        /* memory to device */
    DmaM2M      = 2,        /* memory to memory */

    DmaChanEmmc = 4,        /* can only use 2-5, maybe 0 */
    DmaChanSpiTx= 2,
    DmaChanSpiRx= 0,

    DmaDevSpiTx = 6,
    DmaDevSpiRx = 7,
    DmaDevEmmc  = 11,
};
@
% used outside dma.c in emmc.c for example so enum define in io.h


<<enum _anon_ (buses/arm/dma.c)(arm)>>=
enum {
    Nchan       = 7,        /* number of dma channels */
    Regsize     = 0x100,    /* size of regs for each chan */
    Cbalign     = 32,       /* control block byte alignment */
    Dbg     = 0,
    
    /* registers for each dma controller */
    Cs      = 0x00>>2,
    Conblkad    = 0x04>>2,
    Ti      = 0x08>>2,
    Sourcead    = 0x0c>>2,
    Destad      = 0x10>>2,
    Txfrlen     = 0x14>>2,
    Stride      = 0x18>>2,
    Nextconbk   = 0x1c>>2,
    Debug       = 0x20>>2,

    /* collective registers */
    Intstatus   = 0xfe0>>2,
    Enable      = 0xff0>>2,

    /* Cs */
    Reset       = 1<<31,
    Abort       = 1<<30,
    Error       = 1<<8,
    Waitwrite   = 1<<6,
    Waitdreq    = 1<<5,
    Paused      = 1<<4,
    Dreq        = 1<<3,
    Int     = 1<<2,
    End     = 1<<1,
    Active      = 1<<0,

    /* Ti */
    Permapshift= 16,
    Srcignore   = 1<<11,
    Srcdreq     = 1<<10,
    Srcwidth128 = 1<<9,
    Srcinc      = 1<<8,
    Destignore  = 1<<7,
    Destdreq    = 1<<6,
    Destwidth128    = 1<<5,
    Destinc     = 1<<4,
    Waitresp    = 1<<3,
    Tdmode      = 1<<1,
    Inten       = 1<<0,

    /* Debug */
    Lite        = 1<<28,
    Clrerrors   = 7<<0,
};
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>

<<struct Ctlr(arm)>>=
struct Ctlr {
    u32int  *regs;
    Cb  *cb;
    Rendez  r;
    int dmadone;
};
@

<<struct Cb(arm)>>=
struct Cb {
    u32int  ti;
    u32int  sourcead;
    u32int  destad;
    u32int  txfrlen;
    u32int  stride;
    u32int  nextconbk;
    u32int  reserved[2];
};
@

<<global dma(arm)>>=
static Ctlr dma[Nchan];
@

<<global dmaregs(arm)>>=
static u32int *dmaregs = (u32int*)DMAREGS;
@

<<[[Soc]] bus fields>>=
uintptr busdram;
@
<<[[soc(raspberry pi1)]] other fields(arm)>>=
.busdram    = 0x40000000,
@

<<[[soc(raspberry pi2)]] other fields(arm)>>=
.busdram    = 0xC0000000,
@

<<function dmaaddr(arm)>>=
uintptr
dmaaddr(void *va)
{
    return soc.busdram | (PTR2UINT(va) & ~KSEGM); // PADDR?
}
@

<<[[Soc]] bus fields>>=
uintptr busio;
@
% as seen from GPU? vs as seen from CPU?
<<[[soc(raspberry pi1)]] other fields(arm)>>=
.busio      = 0x7E000000,
@
<<[[soc(raspberry pi2)]] other fields(arm)>>=
.busio      = 0x7E000000,
@

<<function dmaioaddr(arm)>>=
static uintptr
dmaioaddr(void *va)
{
    return soc.busio | (PTR2UINT(va) & ~VIRTIO);
}
@

<<function dump(arm)>>=
static void
dump(char *msg, uchar *p, int n)
{
    print("%s", msg);
    while(n-- > 0)
        print(" %2.2x", *p++);
    print("\n");
}
@

<<function dumpdregs(arm)>>=
static void
dumpdregs(char *msg, u32int *r)
{
    int i;

    print("%s: %#p =", msg, r);
    for(i = 0; i < 9; i++)
        print(" %8.8uX", r[i]);
    print("\n");
}
@

<<function dmadone(arm)>>=
static int
dmadone(void *a)
{
    return ((Ctlr*)a)->dmadone;
}
@

<<function dmainterrupt(arm)>>=
static void
dmainterrupt(Ureg*, void *a)
{
    Ctlr *ctlr;

    ctlr = a;
    ctlr->regs[Cs] = Int;
    ctlr->dmadone = 1;
    wakeup(&ctlr->r);
}
@


<<function dmastart(arm)>>=
void
dmastart(int chan, int dev, int dir, void *src, void *dst, int len)
{
    Ctlr *ctlr;
    Cb *cb;
    int ti;

    ctlr = &dma[chan];
    if(ctlr->regs == nil){
        ctlr->regs = (u32int*)(DMAREGS + chan*Regsize);
        ctlr->cb = xspanalloc(sizeof(Cb), Cbalign, 0);
        assert(ctlr->cb != nil);
        dmaregs[Enable] |= 1<<chan;
        ctlr->regs[Cs] = Reset;
        while(ctlr->regs[Cs] & Reset)
            ;
        arch_intrenable(IRQDMA(chan), dmainterrupt, ctlr, 0, "dma");
    }
    cb = ctlr->cb;
    ti = 0;
    switch(dir){
    case DmaD2M:
        cachedinvse(dst, len);
        ti = Srcdreq | Destinc;
        cb->sourcead = dmaioaddr(src);
        cb->destad = dmaaddr(dst);
        break;
    case DmaM2D:
        cachedwbse(src, len);
        ti = Destdreq | Srcinc;
        cb->sourcead = dmaaddr(src);
        cb->destad = dmaioaddr(dst);
        break;
    case DmaM2M:
        cachedwbse(src, len);
        cachedinvse(dst, len);
        ti = Srcinc | Destinc;
        cb->sourcead = dmaaddr(src);
        cb->destad = dmaaddr(dst);
        break;
    }
    cb->ti = ti | dev<<Permapshift | Inten;
    cb->txfrlen = len;
    cb->stride = 0;
    cb->nextconbk = 0;
    cachedwbse(cb, sizeof(Cb));
    ctlr->regs[Cs] = 0;
    arch_microdelay(1);
    ctlr->regs[Conblkad] = dmaaddr(cb);
    DBG print("dma start: %ux %ux %ux %ux %ux %ux\n",
        cb->ti, cb->sourcead, cb->destad, cb->txfrlen,
        cb->stride, cb->nextconbk);
    DBG print("intstatus %ux\n", dmaregs[Intstatus]);
    dmaregs[Intstatus] = 0;
    ctlr->regs[Cs] = Int;
    arch_microdelay(1);
    arch_coherence();
    DBG dumpdregs("before Active", ctlr->regs);
    ctlr->regs[Cs] = Active;
    DBG dumpdregs("after Active", ctlr->regs);
}
@
% >> >> >> >> >>

<<function dmawait(arm)>>=
int
dmawait(int chan)
{
    Ctlr *ctlr;
    u32int *r;
    int s;

    ctlr = &dma[chan];
    tsleep(&ctlr->r, dmadone, ctlr, 3000);
    ctlr->dmadone = 0;
    r = ctlr->regs;
    DBG dumpdregs("after sleep", r);
    s = r[Cs];
    if((s & (Active|End|Error)) != End){
        print("dma chan %d %s Cs %ux Debug %ux\n", chan,
            (s&End)? "error" : "timeout", s, r[Debug]);
        r[Cs] = Reset;
        r[Debug] = Clrerrors;
        return -1;
    }
    r[Cs] = Int|End;
    return 0;
}
@

%-------------------------------------------------------------

<<buses/arm/dma.c>>=
/*
 * bcm2835 dma controller
 *
 * simplest to use only channels 0-6
 *  channels 7-14 have reduced functionality
 *  channel 15 is at a weird address
 *  channels 0 and 15 have an "external 128 bit 8 word read FIFO"
 *    for memory to memory transfers
 *
 * Experiments show that only channels 2-5,11-12 work with mmc
 */
<<kernel basic includes>>
#include "io.h"

<<constant DMAREGS(arm)>>

#define DBG if(Dbg)

<<enum _anon_ (buses/arm/dma.c)(arm)>>

typedef struct Ctlr Ctlr;
typedef struct Cb Cb;

<<struct Ctlr(arm)>>

<<struct Cb(arm)>>

<<global dma(arm)>>
<<global dmaregs(arm)>>

<<function dmaaddr(arm)>>

<<function dmaioaddr(arm)>>

<<function dump(arm)>>

<<function dumpdregs(arm)>>

<<function dmadone(arm)>>

<<function dmainterrupt(arm)>>

<<function dmastart(arm)>>

<<function dmawait(arm)>>

@


\subsection*{[[buses/arm/uartmini.c]]}


<<constant OkLed(arm)>>=
#define OkLed       16
@

<<constant TxPin(arm)>>=
#define TxPin       14
@

<<constant RxPin(arm)>>=
#define RxPin       15
@

<<enum _anon_ (buses/arm/uartmini.c)(arm)>>=
/* GPIO regs */
enum {
    Fsel0   = 0x00>>2,
        FuncMask= 0x7,
        Input   = 0x0,
        Output  = 0x1,
        Alt0    = 0x4,
        Alt1    = 0x5,
        Alt2    = 0x6,
        Alt3    = 0x7,
        Alt4    = 0x3,
        Alt5    = 0x2,
    Set0    = 0x1c>>2,
    Clr0    = 0x28>>2,
    Lev0    = 0x34>>2,
    PUD = 0x94>>2,
        Off = 0x0,
        Pulldown= 0x1,
        Pullup  = 0x2,
    PUDclk0 = 0x98>>2,
    PUDclk1 = 0x9c>>2,
};
@

<<enum _anon_ (buses/arm/uartmini.c)2(arm)>>=
/* AUX regs */
enum {
    Irq = 0x00>>2,
        UartIrq = 1<<0,
    Enables = 0x04>>2,
        UartEn  = 1<<0,
    MuIo    = 0x40>>2,
    MuIer   = 0x44>>2,
        RxIen   = 1<<0,
        TxIen   = 1<<1,
    MuIir   = 0x48>>2,
    MuLcr   = 0x4c>>2,
        Bitsmask= 3<<0,
        Bits7   = 2<<0,
        Bits8   = 3<<0,
    MuMcr   = 0x50>>2,
        RtsN    = 1<<1,
    MuLsr   = 0x54>>2,
        TxDone  = 1<<6,
        TxRdy   = 1<<5,
        RxRdy   = 1<<0,
    MuCntl  = 0x60>>2,
        CtsFlow = 1<<3,
        TxEn    = 1<<1,
        RxEn    = 1<<0,
    MuBaud  = 0x68>>2,
};
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>

<<global miniuart(arm)>>=
static Uart miniuart = {
    .regs   = (u32int*)AUXREGS,
    .name   = "uart0",
    .freq   = 250000000,
    .phys   = &miniphysuart,
};
@

<<function gpiosel(arm)>>=
void
gpiosel(uint pin, int func)
{   
    u32int *gp, *fsel;
    int off;

    gp = (u32int*)GPIOREGS;
    fsel = &gp[Fsel0 + pin/10];
    off = (pin % 10) * 3;
    *fsel = (*fsel & ~(FuncMask<<off)) | func<<off;
}
@

<<function gpiopull(arm)>>=
static void
gpiopull(uint pin, int func)
{
    u32int *gp, *reg;
    u32int mask;

    gp = (u32int*)GPIOREGS;
    reg = &gp[PUDclk0 + pin/32];
    mask = 1 << (pin % 32);
    gp[PUD] = func;
    arch_microdelay(1);
    *reg = mask;
    arch_microdelay(1);
    *reg = 0;
}
@

<<function gpiopulloff(arm)>>=
void
gpiopulloff(uint pin)
{
    gpiopull(pin, Off);
}
@

<<function gpiopullup(arm)>>=
void
gpiopullup(uint pin)
{
    gpiopull(pin, Pullup);
}
@

<<function gpiopulldown(arm)>>=
void
gpiopulldown(uint pin)
{
    gpiopull(pin, Pulldown);
}
@

<<function gpioout(arm)>>=
void
gpioout(uint pin, int set)
{
    u32int *gp;
    int v;

    gp = (u32int*)GPIOREGS;
    v = set? Set0 : Clr0;
    gp[v + pin/32] = 1 << (pin % 32);
}
@

<<function gpioin(arm)>>=
int
gpioin(uint pin)
{
    u32int *gp;

    gp = (u32int*)GPIOREGS;
    return (gp[Lev0 + pin/32] & (1 << (pin % 32))) != 0;
}
@

<<function interrupt(arm)>>=
static void
interrupt(Ureg*, void *arg)
{
    Uart *uart;
    u32int *ap;

    uart = arg;
    ap = (u32int*)uart->regs;

    arch_coherence();
    if(0 && (ap[Irq] & UartIrq) == 0)
        return;
    if(ap[MuLsr] & TxRdy)
        uartkick(uart);
    if(ap[MuLsr] & RxRdy){
        if(uart->console){
            if(uart->opens == 1)
                uart->putc = kbdcr2nl;
            else
                uart->putc = nil;
        }
        do{
            uartrecv(uart, ap[MuIo] & 0xFF);
        }while(ap[MuLsr] & RxRdy);
    }
    arch_coherence();
}
@

<<function pnp(arm)>>=
static Uart*
pnp(void)
{
    Uart *uart;

    uart = &miniuart;
    if(uart->console == 0)
        kbdq = qopen(8*1024, 0, nil, nil);
    return uart;
}
@

<<function enable(arm)>>=
static void
enable(Uart *uart, int ie)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    arch_delay(10);
    gpiosel(TxPin, Alt5);
    gpiosel(RxPin, Alt5);
    gpiopulloff(TxPin);
    gpiopulloff(RxPin);
    ap[Enables] |= UartEn;
    ap[MuIir] = 6;
    ap[MuLcr] = Bits8;
    ap[MuCntl] = TxEn|RxEn;
    ap[MuBaud] = uart->freq/(115200*8) - 1;
    if(ie){
        arch_intrenable(IRQaux, interrupt, uart, 0, "uart");
        ap[MuIer] = RxIen|TxIen;
    }else
        ap[MuIer] = 0;
}
@

<<function disable(arm)>>=
static void
disable(Uart *uart)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    ap[MuCntl] = 0;
    ap[MuIer] = 0;
}
@

<<function kick(arm)>>=
static void
kick(Uart *uart)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    if(uart->blocked)
        return;
    arch_coherence();
    while(ap[MuLsr] & TxRdy){
        if(uart->op >= uart->oe && uartstageoutput(uart) == 0)
            break;
        ap[MuIo] = *(uart->op++);
    }
    if(ap[MuLsr] & TxDone)
        ap[MuIer] &= ~TxIen;
    else
        ap[MuIer] |= TxIen;
    arch_coherence();
}
@

<<function dobreak(arm)>>=
/* TODO */
static void
dobreak(Uart *uart, int ms)
{
    USED(uart, ms);
}
@

<<function baud(arm)>>=
static int
baud(Uart *uart, int n)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    if(uart->freq == 0 || n <= 0)
        return -1;
    ap[MuBaud] = (uart->freq + 4*n - 1) / (8 * n) - 1;
    uart->baud = n;
    return 0;
}
@

<<function bits(arm)>>=
static int
bits(Uart *uart, int n)
{
    u32int *ap;
    int set;

    ap = (u32int*)uart->regs;
    switch(n){
    case 7:
        set = Bits7;
        break;
    case 8:
        set = Bits8;
        break;
    default:
        return -1;
    }
    ap[MuLcr] = (ap[MuLcr] & ~Bitsmask) | set;
    uart->bits = n;
    return 0;
}
@

<<function stop(arm)>>=
static int
stop(Uart *uart, int n)
{
    if(n != 1)
        return -1;
    uart->stop = n;
    return 0;
}
@

<<function parity(arm)>>=
static int
parity(Uart *uart, int n)
{
    if(n != 'n')
        return -1;
    uart->parity = n;
    return 0;
}
@

<<function modemctl(arm)>>=
/*
 * cts/rts flow control
 *   need to bring signals to gpio pins before enabling this
 */

static void
modemctl(Uart *uart, int on)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    if(on)
        ap[MuCntl] |= CtsFlow;
    else
        ap[MuCntl] &= ~CtsFlow;
    uart->modem = on;
}
@

<<function rts(arm)>>=
static void
rts(Uart *uart, int on)
{
    u32int *ap;

    ap = (u32int*)uart->regs;
    if(on)
        ap[MuMcr] &= ~RtsN;
    else
        ap[MuMcr] |= RtsN;
}
@

<<function status(arm)>>=
static long
status(Uart *uart, void *buf, long n, long offset)
{
    char *p;

    p = malloc(READSTR);
    if(p == nil)
        error(Enomem);
    snprint(p, READSTR,
        "b%d\n"
        "dev(%d) type(%d) framing(%d) overruns(%d) "
        "berr(%d) serr(%d)\n",

        uart->baud,
        uart->dev,
        uart->type,
        uart->ferr,
        uart->oerr,
        uart->berr,
        uart->serr
    );
    n = readstr(offset, buf, n, p);
    free(p);

    return n;
}
@

<<function donothing(arm)>>=
static void
donothing(Uart*, int)
{
}
@

<<function putc(arm)>>=
void
putc(Uart*, int c)
{
    u32int *ap;

    ap = (u32int*)AUXREGS;
    while((ap[MuLsr] & TxRdy) == 0)
        ;
    ap[MuIo] = c;
    while((ap[MuLsr] & TxRdy) == 0)
        ;
}
@

<<function getc(arm)>>=
int
getc(Uart*)
{
    u32int *ap;

    ap = (u32int*)AUXREGS;
    while((ap[MuLsr] & RxRdy) == 0)
        ;
    return ap[MuIo] & 0xFF;
}
@

<<function uartconsinit(arm)>>=
void
uartconsinit(void)
{
    Uart *uart;
    int n;
    char *p, *cmd;

    if((p = getconf("console")) == nil)
        return;
    n = strtoul(p, &cmd, 0);
    if(p == cmd)
        return;
    switch(n){
    default:
        return;
    case 0:
        uart = &miniuart;
        break;
    }

    if(!uart->enabled)
        (*uart->phys->enable)(uart, 0);
    uartctl(uart, "b9600 l8 pn s1");
    if(*cmd != '\0')
        uartctl(uart, cmd);

    consuart = uart;
    uart->console = 1;
}
@

<<global miniphysuart(arm)>>=
PhysUart miniphysuart = {
    .name       = "miniuart",
    .pnp        = pnp,
    .enable     = enable,
    .disable    = disable,
    .kick       = kick,
    .dobreak    = dobreak,
    .baud       = baud,
    .bits       = bits,
    .stop       = stop,
    .parity     = parity,
    .modemctl   = donothing,
    .rts        = rts,
    .dtr        = donothing,
    .status     = status,
    .fifo       = donothing,
    .getc       = getc,
    .putc       = putc,
};
@

<<function okay(arm)>>=
void
okay(int on)
{
    static int first;
    static int okled, polarity;
    char *p;

    if(!first++){
        p = getconf("bcm2709.disk_led_gpio");
        if(p == nil)
            p = getconf("bcm2708.disk_led_gpio");
        if(p != nil)
            okled = strtol(p, 0, 0);
        else
            okled = OkLed;
        p = getconf("bcm2709.disk_led_active_low");
        if(p == nil)
            p = getconf("bcm2708.disk_led_active_low");
        polarity = (p == nil || *p == '1');
        gpiosel(okled, Output);
    }
    gpioout(okled, on^polarity);
}
@


%-------------------------------------------------------------

<<buses/arm/uartmini.c>>=
/*
 * bcm2835 mini uart (UART1)
 */
<<kernel basic includes>>

#include "io.h"

<<constant GPIOREGS(arm)>>
<<constant AUXREGS(arm)>>
<<constant OkLed(arm)>>
<<constant TxPin(arm)>>
<<constant RxPin(arm)>>

<<enum _anon_ (buses/arm/uartmini.c)(arm)>>

<<enum _anon_ (buses/arm/uartmini.c)2(arm)>>

extern PhysUart miniphysuart;

<<global miniuart(arm)>>

<<function gpiosel(arm)>>

<<function gpiopull(arm)>>

<<function gpiopulloff(arm)>>

<<function gpiopullup(arm)>>

<<function gpiopulldown(arm)>>

<<function gpioout(arm)>>

<<function gpioin(arm)>>

<<function interrupt(arm)>>

<<function pnp(arm)>>

<<function enable(arm)>>

<<function disable(arm)>>

<<function kick(arm)>>

<<function dobreak(arm)>>

<<function baud(arm)>>

<<function bits(arm)>>

<<function stop(arm)>>

<<function parity(arm)>>

<<function modemctl(arm)>>

<<function rts(arm)>>

<<function status(arm)>>

<<function donothing(arm)>>

<<function putc(arm)>>

<<function getc(arm)>>

<<function uartconsinit(arm)>>

<<global miniphysuart(arm)>>

<<function okay(arm)>>
@


