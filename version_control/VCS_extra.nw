\section{[[version_control/]]}

\subsection*{[[version_control/IO_.ml]]}

<<function IO_.with_close_out>>=
let with_close_out f ch =
  f ch;
  let res = IO.close_out ch in
  res
@

<<function IO_.read_string_and_stop_char>>=
let read_string_and_stop_char ch stop_char =
  let b = Buffer.create 8 in
  let rec loop() =
    let c = IO.read ch in
    if c <> stop_char then begin
      Buffer.add_char b c;
      loop();
    end;
  in
  loop();
  Buffer.contents b
@

<<function IO_.read_int_and_nullbyte>>=
let read_int_and_nullbyte ch =
  let str = IO.read_c_string ch in
  int_of_string str
@

<<function IO_.read_key_space_value_newline>>=
let read_key_space_value_newline ch k f =
  let str = read_string_and_stop_char ch ' ' in
  if str <> k
  then failwith (spf 
    "read_key_space_value_newline: wrong key got %s (expecting %s)"
    str k);
  let v = f ch in
  let c = IO.read ch in
  if c <> '\n'
  then failwith "read_key_space_value_newline: wrong format, no newline";
  v
@


%-------------------------------------------------------------

<<version_control/IO_.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function IO_.with_close_out>>

<<function IO_.read_string_and_stop_char>>

<<function IO_.read_int_and_nullbyte>>

<<function IO_.read_key_space_value_newline>>
@


\subsection*{[[version_control/IO_.mli]]}

<<signature IO_.read_string_and_stop_char>>=
val read_string_and_stop_char: 
  IO.input -> char -> string
@

<<signature IO_.read_int_and_nullbyte>>=
val read_int_and_nullbyte: 
  IO.input -> int
@

<<signature IO_.read_key_space_value_newline>>=
val read_key_space_value_newline: 
  IO.input -> string (* key *) -> (IO.input -> 'a) -> 'a
@

<<signature IO_.with_close_out>>=
val with_close_out: ('a IO.output -> unit) -> 'a IO.output -> 'a
@


%-------------------------------------------------------------

<<version_control/IO_.mli>>=

<<signature IO_.read_string_and_stop_char>>

<<signature IO_.read_int_and_nullbyte>>

<<signature IO_.read_key_space_value_newline>>

<<signature IO_.with_close_out>>
@


\subsection*{[[version_control/blob.ml]]}

<<type Blob.t>>=
type t = bytes
@

<<type Blob.hash>>=
type hash = Sha1.t
@

<<function Blob.read>>=
let read ch =
  IO.read_all ch
@

<<function Blob.write>>=
let write blob ch =
  IO.nwrite ch blob
@

<<function Blob.show>>=
let show x =
  pr x
@


%-------------------------------------------------------------

<<version_control/blob.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Blob.t>>

<<type Blob.hash>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Blob.read>>

<<function Blob.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Blob.show>>
@


\subsection*{[[version_control/blob.mli]]}

<<type Blob.t (version_control/blob.mli)>>=
type t = bytes
@

<<type Blob.hash (version_control/blob.mli)>>=
type hash = Sha1.t
@

<<signature Blob.read>>=
(* assumes have already read the 'blob <size>\000' header from unzipped input *)
val read: IO.input -> t
(* does not write the header, does not compress *)
@

<<signature Blob.write>>=
(* does not write the header, does not compress *)
val write: t -> bytes IO.output -> unit
@

<<signature Blob.show>>=
val show: t -> unit
@


%-------------------------------------------------------------

<<version_control/blob.mli>>=

<<type Blob.t (version_control/blob.mli)>>

<<type Blob.hash (version_control/blob.mli)>>

<<signature Blob.read>>
<<signature Blob.write>>

<<signature Blob.show>>
@


\subsection*{[[version_control/change.ml]]}

<<type Change.content>>=
type content = bytes
@

<<type Change.entry>>=
type entry = {
  (* relative path *)
  path: Common.filename;
  mode: Index.mode;
  content: content Lazy.t;
}
@

<<type Change.t>>=
(* entry below refers only to files (not dirs), and their name
 * are adjusted to show a relative path from the root of the
 * project.
 *)
type t = 
  | Add of entry
  | Del of entry
  | Modify of entry * entry (* before / after *)
  (* less: Rename, Copy *)
  (*| Identical of Tree.entry *)
@


%-------------------------------------------------------------

<<version_control/change.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type Change.content>>

<<type Change.entry>>

<<type Change.t>>
@


\subsection*{[[version_control/change.mli]]}

<<type Change.content (version_control/change.mli)>>=
type content = bytes
@

<<type Change.entry (version_control/change.mli)>>=
type entry = {
  path: Common.filename;
  mode: Index.mode;
  content: content Lazy.t;
}
@

<<type Change.t (version_control/change.mli)>>=
type t = 
  | Add of entry
  | Del of entry
  | Modify of entry * entry
@


%-------------------------------------------------------------

<<version_control/change.mli>>=

<<type Change.content (version_control/change.mli)>>

<<type Change.entry (version_control/change.mli)>>

<<type Change.t (version_control/change.mli)>>
@


\subsection*{[[version_control/changes.ml]]}

<<function Changes.skip_tree_and_adjust_path>>=
let skip_tree_and_adjust_path read_blob dirpath entry_opt =
  match entry_opt with
  | Some { Tree.perm = Tree.Dir } -> None
  | Some { Tree.perm = Tree.Commit } -> failwith "submodule not supported"
  | Some x -> Some ({ Change.
    path = Filename.concat dirpath x.Tree.name;
    mode = Index.mode_of_perm x.Tree.perm;
    
    (* todo: do that later? once know we will return a change with this entry?
     * make it lazy?
     *)
    content = lazy (read_blob x.Tree.node);
  }, x.Tree.node)
  | None -> None
@

<<function Changes.content_from_path_and_stat_index>>=
(* similar to Repository.content_from_path_and_unix_stat *)
let content_from_path_and_stat_index path stat_info =
  match stat_info.Index.mode with
  | Index.Link ->
    Unix.readlink path
  | Index.Normal | Index.Exec ->
      path |> Common.with_file_in (fun ch ->
        ch |> IO.input_channel |> IO.read_all
      )
  | Index.Gitlink -> failwith "submodule not supported"
@

<<function Changes.changes_tree_vs_tree>>=
(* see also Cmd_diff.changes_index_vs_worktree
 *     and  Cmd_status.changes_index_vs_HEAD
 *)
let changes_tree_vs_tree read_tree read_blob tree1 tree2 =
  let changes = ref [] in
  let add x = Common.push x changes in
  Tree.walk_trees read_tree "" (fun dirpath entry1_opt entry2_opt ->
    (* if entries are directories, then we would be called again
     * with their individual files, so safe to skip the dir entries.
     *)
    let entry1_opt = skip_tree_and_adjust_path read_blob dirpath entry1_opt in
    let entry2_opt = skip_tree_and_adjust_path read_blob dirpath entry2_opt in
    
    match entry1_opt, entry2_opt with
    | None, None -> ()
    | Some (a, asha), Some (b, bsha) ->
      (match () with
      (* file type changed reported as delete/add (meh) *)
      | _ when a.Change.mode <> b.Change.mode ->
        add (Change.Del a);
        add (Change.Add b);
      | _ when asha <> bsha ->
        add (Change.Modify (a, b))
      | _ -> ()
      )
    | Some (a,_), None -> add (Change.Del a)
    | None, Some (b,_) -> add (Change.Add b)
  ) tree1 tree2 ;
  List.rev !changes
@

<<function Changes.changes_worktree_vs_index>>=
(* less: could factorize with Diff_tree.changes_tree_vs_tree? would need
 * to generate flat list of files (but then less opti opportunity
 * in changes_tree_vs_tree when hash for a whole subtree is the same)
 * and then just do set differences to compute new, deleted, and
 * for changes just look intersection and check if same content.
 *)
let changes_worktree_vs_index read_blob worktree index =
  index |> List.map (fun entry ->
    let old_stat = entry.Index.stats in
    let path = Filename.concat worktree entry.Index.name in
    let new_stat_opt = 
      try Some (Unix.lstat path |> Index.stat_info_of_lstats)
      with Unix.Unix_error _ -> None
    in
    match new_stat_opt with
    | None -> 
      [Change.Del { Change.path = entry.Index.name;
                    mode = old_stat.Index.mode;
                    content = lazy (read_blob entry.Index.id);
                  }]
    | Some new_stat ->
      (match () with
      (* useful opti? *)
      | _ when new_stat.Index.mtime = old_stat.Index.mtime -> []
      (* a change of mode is converted in a del/add *)
      | _ when new_stat.Index.mode <> old_stat.Index.mode ->
        [Change.Del { Change.path = entry.Index.name;
                      mode = old_stat.Index.mode;
                      content = lazy (read_blob entry.Index.id)};
         Change.Add { Change.path = entry.Index.name;
                      mode = new_stat.Index.mode;
                      content = lazy 
                        (content_from_path_and_stat_index path new_stat)}
          ]
      | _ -> 
        [Change.Modify (
          { Change.path = entry.Index.name;
            mode = old_stat.Index.mode;
            content = lazy (read_blob entry.Index.id) },
          { Change.path = entry.Index.name;
            mode = new_stat.Index.mode;
            content = lazy 
              (content_from_path_and_stat_index path new_stat) }
        )]
      )
  ) |> List.flatten
@

<<function Changes.changes_index_vs_tree>>=
(* some commonalities with Repository.set_worktree_and_index_to_tree *)
let changes_index_vs_tree read_tree index treeid =
  let tree = read_tree treeid in

  let h_in_index_and_head = Hashtbl.create 101 in
  let hindex = 
    index 
    |> List.map (fun entry -> entry.Index.name, entry)
    |> Hashtbl_.of_list
  in
  let changes = ref [] in

  tree |> Tree.walk_tree read_tree "" (fun relpath entry_head ->
    let perm = entry_head.Tree.perm in
    match perm with
    | Tree.Dir -> ()
    | Tree.Commit -> failwith "submodule not yet supported"
    | Tree.Normal | Tree.Exec | Tree.Link ->
      try
        let entry_index = Hashtbl.find hindex relpath in
        Hashtbl.add h_in_index_and_head relpath true;
        (* less: if change mode, then report as del/add *)
        if entry_head.Tree.node <> entry_index.Index.id
        then changes |> Common.push (Change.Modify (
          { Change.path = relpath; 
            mode = Index.mode_of_perm perm; 
            content = lazy (raise (Impossible "not called")); },
          { Change.path = relpath; 
            mode = entry_index.Index.stats.Index.mode;
            content = lazy (raise (Impossible "not called")); }
        ))
      with Not_found ->
        changes |> Common.push (Change.Del { Change.
             path = relpath;
             mode = Index.mode_of_perm perm;
             content = lazy (raise (Impossible "not called"));
                                           });
  );
  index |> List.iter (fun entry ->
    if not (Hashtbl.mem h_in_index_and_head entry.Index.name)
    then changes |> Common.push (Change.Add { Change.
             path = entry.Index.name;
             mode = entry.Index.stats.Index.mode;                                            content = lazy (raise (Impossible "not called")); }
    )
  );
  (* less: sort by path *)
  List.rev !changes
@


%-------------------------------------------------------------

<<version_control/changes.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * todo: 
 *  - rename detection
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Changes.skip_tree_and_adjust_path>>

<<function Changes.content_from_path_and_stat_index>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Changes.changes_tree_vs_tree>>



<<function Changes.changes_worktree_vs_index>>


<<function Changes.changes_index_vs_tree>>
@


\subsection*{[[version_control/changes.mli]]}

<<signature Changes.changes_tree_vs_tree>>=
(* for git show commit *)
val changes_tree_vs_tree: 
  (Tree.hash -> Tree.t) ->
  (Blob.hash -> Change.content) ->
  Tree.t -> Tree.t -> Change.t list
@

<<signature Changes.changes_worktree_vs_index>>=
(* for git diff and git status *)
val changes_worktree_vs_index:
  (Blob.hash -> Change.content) ->
  Common.filename -> Index.t -> Change.t list
@

<<signature Changes.changes_index_vs_tree>>=
(* for git status (to compare index vs HEAD) *)
val changes_index_vs_tree:
  (Tree.hash -> Tree.t) ->
  Index.t -> Tree.hash -> Change.t list
@


%-------------------------------------------------------------

<<version_control/changes.mli>>=

<<signature Changes.changes_tree_vs_tree>>

<<signature Changes.changes_worktree_vs_index>>

<<signature Changes.changes_index_vs_tree>>
@


\subsection*{[[version_control/client.ml]]}

<<type Client.t>>=
type t = {
  (* path to remote (e.g., /path/other/repo, or git://github.com/foo/bar) *)
  url: string;
  (* less: more parameters:
   *  - determine_refs_wanted. for now grabs everything from remote HEAD 
   *  - return set of remote refs, not just the one for HEAD
   * Note that fetch will modify the target repository by side effect.
   *)
  fetch: Repository.t -> Commit.hash;
  (* less: progress *)
}
@


%-------------------------------------------------------------

<<version_control/client.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Client.t>>
@


\subsection*{[[version_control/client.mli]]}

<<type Client.t (version_control/client.mli)>>=
type t = {
  url: string;
  fetch: Repository.t (* dst *)  -> Commit.hash (* remote HEAD *);
}
@


%-------------------------------------------------------------

<<version_control/client.mli>>=

<<type Client.t (version_control/client.mli)>>
@


\subsection*{[[version_control/client_git.ml]]}

<<function Client_git.mk_client>>=
let mk_client url =
  raise Todo
@


%-------------------------------------------------------------

<<version_control/client_git.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Client_git.mk_client>>
@


\subsection*{[[version_control/client_git.mli]]}

<<signature Client_git.mk_client>>=
val mk_client: Common.filename -> Client.t
@


%-------------------------------------------------------------

<<version_control/client_git.mli>>=

<<signature Client_git.mk_client>>
@


\subsection*{[[version_control/client_local.ml]]}

<<type Client_local.graph_walker>>=
(* will start from the heads and iterate over the ancestry of heads
 * until the caller ack that some top commits are already known and
 * do not need to be iterated furthermore.
 *)
type graph_walker = {
  next: unit -> Commit.hash option;
  ack: Commit.hash -> unit;
}
@

<<function Client_local.collect_filetree>>=
let rec collect_filetree read_tree treeid have_sha =
  let tree = read_tree treeid in
  tree |> List.iter (fun entry ->
    let sha = entry.Tree.node in
    if not (Hashtbl.mem have_sha sha) then begin
      Hashtbl.add have_sha sha true;
      match entry.Tree.perm with
      | Tree.Normal | Tree.Exec | Tree.Link -> ()
      | Tree.Dir ->  collect_filetree read_tree sha have_sha
      | Tree.Commit -> failwith "submodule not supported yet"
    end
  )
@

<<function Client_local.find_top_common_commits>>=
(* find the common frontline *)
let find_top_common_commits src dst =
  let top_commons = Hashtbl.create 101 in
  let walker = mk_graph_walker dst in

  let rec loop_while_sha commit_sha_opt =
    commit_sha_opt |> Common.if_some (fun commit_sha ->
      if Repository.has_obj src commit_sha
      then begin
        Hashtbl.add top_commons commit_sha true;
        walker.ack commit_sha;
      end;
      loop_while_sha (walker.next ())
    )
  in
  loop_while_sha (walker.next ());
  top_commons |> Hashtbl_.to_list |> List.map fst
@

<<function Client_local.iter_missing_objects>>=
let iter_missing_objects top_common_commits top_wanted_commits src f =
  (* less: split_commits_and_tags? *)
  let all_common_commits = 
    Commit.collect_ancestors (Repository.read_commit src) top_common_commits 
      (Hashtbl.create 101) in
  (* bugfix: do not forget Hashtbl.copy because collect_ancestors modify 
   * the second parameter by side effect
   *)
  let missing_commits = 
    Commit.collect_ancestors (Repository.read_commit src) top_wanted_commits 
      (Hashtbl.copy all_common_commits)
  in

  (* let's iterate over all common commits *)
  
  let dst_have_sha = Hashtbl.create 101 in
  (* less: start from second returned result from collect_ancestors?
   * common_commits different from all_ancestors in VCS.nw? 
   *)
  (* expensive loop below? so use parallel threads? *)
  all_common_commits |> Hashtbl.iter (fun commit_sha _true ->
    Hashtbl.add dst_have_sha commit_sha true;
    let commit = Repository.read_commit src commit_sha in
    collect_filetree (Repository.read_tree src) commit.Commit.tree dst_have_sha
  );

  (* and now let's iterate over all missing commits *)

  (* less: tags handling *)
  let rec missing sha is_blob = 
    if Hashtbl.mem dst_have_sha sha
    then ()
    else begin
      Hashtbl.add dst_have_sha sha true;
      (if is_blob
       then f sha None
       else begin
        let obj = Repository.read_obj src sha in
        f sha (Some obj);
        (match obj with
        | Objects.Commit commit ->
          missing commit.Commit.tree false
        | Objects.Tree tree ->
          tree |> List.iter (fun entry ->
            if entry.Tree.perm = Tree.Commit
            then failwith "submodule not supported";
            (* bugfix: it's <>, not = *)
            missing entry.Tree.node (entry.Tree.perm <> Tree.Dir)
          )
        | Objects.Blob _ ->
          raise (Impossible "is_blob guard")
        )
       end
      );
    end
  in
  missing_commits |> Hashtbl.iter (fun commit_sha _true ->
    missing commit_sha false
  )
@

<<function Client_local.fetch_objects>>=
let fetch_objects src dst =
  (* less: determine_wants from pull command *)
  let top_wanted_commits = [Repository.follow_ref_some src Refs.Head] in
  (* less: shallows? unshallows? *)
  let top_common_commits = find_top_common_commits src dst in
  iter_missing_objects top_common_commits top_wanted_commits src 
    (fun sha1 obj_opt ->
    (* less: opti: copy raw files directly without unmarshalling/marshalling *)
    let obj = 
      match obj_opt with
      | None -> Repository.read_obj src sha1
      | Some obj -> obj
    in
    (* todo: count objects progress *)
    (* pr2 (spf "adding %s" (Hexsha.of_sha sha1)); *)
    let sha2 = Repository.add_obj dst obj in
    assert (sha1 = sha2)
  )
@

<<function Client_local.mk_client>>=
let mk_client path =
  { Client.
    url = path;
    fetch = (fun dst ->
      let src = Repository.open_ path in
      fetch_objects src dst;
      (* less: all_refs *)
      Repository.follow_ref_some src Refs.Head
   );
  }
@

<<function Client_local.ml_graph_walker>>=
let (mk_graph_walker: Repository.t -> graph_walker) = fun r ->
  (* less: start just from HEAD? *)
  let heads = 
    Repository.all_refs r |> Common.map_filter (fun aref ->
      if aref =~ "refs/heads/"
      then Some (Repository.follow_ref_some r (Refs.Ref aref))
      else None
    )
  in
  let todos = ref heads in
  let todos_next_round = ref [] in
  let last_round = ref None in
  let hdone = Hashtbl.create 101 in
  { next = (fun () ->
    todos := !todos_next_round @ !todos;
    todos_next_round := [];
    match !todos with
    | [] -> None
    | x::xs ->
      todos := xs;
      Hashtbl.add hdone x true;
      last_round := Some x;
      let commit = Repository.read_commit r x in
      let parents = commit.Commit.parents in
      parents |> List.iter (fun parent ->
        if Hashtbl.mem hdone parent
        then ()
        else todos_next_round := parent::!todos_next_round;
      );
      Some x
    );
    ack = (fun commit_sha ->
      (* less: do weird loop where recurse also over parents as in dulwich? *)
      match !last_round with
      | None -> raise (Impossible "ack always after at least one next");
      | Some x ->
        if x <> commit_sha
        then raise (Impossible "'ack(x)' should follow 'x = next()'");
        (* skip those one then because parent already in common *)
        todos_next_round := []
    );
  }
@
%-------------------------------------------------------------

<<version_control/client_local.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Graph walkers *)
(*****************************************************************************)

<<type Client_local.graph_walker>>

<<function Client_local.ml_graph_walker>>

<<function Client_local.collect_filetree>>
    
(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
 
<<function Client_local.find_top_common_commits>>


<<function Client_local.iter_missing_objects>>

  
  

<<function Client_local.fetch_objects>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Client_local.mk_client>>
@


\subsection*{[[version_control/client_local.mli]]}

<<signature Client_local.mk_client>>=
val mk_client: Common.filename -> Client.t
@


%-------------------------------------------------------------

<<version_control/client_local.mli>>=

<<signature Client_local.mk_client>>
@


\subsection*{[[version_control/clients.ml]]}

<<function Clients.client_of_url>>=
(* old: was called get_transport_and_path (and xxx_from_url) in dulwich *)
let client_of_url url =
  match url with
  (* less: should use URL parsing library *)
  | s when s =~ "^git://" -> 
    Client_git.mk_client url
  | s when s =~ "^ssh://" -> 
    failwith "ssh not supported"
  | s when s =~ "^http://" -> 
    failwith "http not supported"
  | s -> 
    if Sys.file_exists s
    then Client_local.mk_client url
    else failwith (spf "remote repository URL not supported: %s" url)
@


%-------------------------------------------------------------

<<version_control/clients.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Clients.client_of_url>>
@


\subsection*{[[version_control/clients.mli]]}

<<signature Clients.client_of_url>>=
val client_of_url: string -> Client.t
@


%-------------------------------------------------------------

<<version_control/clients.mli>>=

<<signature Clients.client_of_url>>
@


\subsection*{[[version_control/cmd.ml]]}

<<type Cmd.t>>=
(* alt: 
 *  - in ocaml-git, use of Term.() and $ to not require
 *    globals for flags?
*)
type t = {
  name: string;
  help: string;
  options: (Arg.key * Arg.spec * Arg.doc) list;
  f: string list -> unit;
  (* less: man: when do git -help get short help, and with --help man page *)
}
@
%$

<<exception Cmd.ShowUsage>>=
(* f can raise ShowUsage which will be catched by caller in main.ml *)
exception ShowUsage
@


%-------------------------------------------------------------

<<version_control/cmd.ml>>=

<<type Cmd.t>>

<<exception Cmd.ShowUsage>>
@


\subsection*{[[version_control/cmd_add.ml]]}

<<function Cmd_add.add>>=
let add r relpaths = 
  (* this will also add some blobs to the object store *)
  Repository.add_in_index r relpaths
@

<<constant Cmd_add.cmd>>=
let cmd = { Cmd.
  name = "add";
  help = " <file>..."; (* less: pathspec? *)
  options = [
    (* todo: --interactive, --patch for picking, --force (if ignored) 
     * --all
    *)
  ];
  f = (fun args ->
    match args with
    | [] -> pr2 "Nothing specified, nothing added."
    | xs ->
      (* todo: allow git add from different location *)
      let r = Repository.open_ "." in
      (* less: support absolute paths, directories *)
      let relpaths = xs |> List.map (fun path ->
        if Filename.is_relative path
        then path
        else failwith (spf "Not a relative path: %s" path)
      )
      in
      add r relpaths
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_add.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_add.add>>

<<constant Cmd_add.cmd>>
@


\subsection*{[[version_control/cmd_branch.ml]]}

<<function Cmd_branch.list_branches>>=
(* less: remote_flag set with --all to also list remote refs *)
let list_branches r =
  let head_branch = Repository.read_ref r (Refs.Head) in
  let all_refs = Repository.all_refs r in
  all_refs |> List.iter (fun refname ->
    if refname =~ "^refs/heads/\\(.*\\)"
    then 
      let short = Regexp_.matched1 refname in
      let prefix = 
        if (Refs.OtherRef refname = head_branch)
        then " * "
        else "   "
      in
      pr (spf "%s%s" prefix short)
  )
@

<<function Cmd_branch.create_branch>>=
let create_branch r name (* sha *) =
  let all_refs = Repository.all_refs r in
  let refname = "refs/heads/" ^ name in
  if List.mem refname all_refs
  (* less: unless -force *)
  then failwith (spf "A branch named '%s' already exists." name);
  let sha = Repository.follow_ref_some r (Refs.Head) in
  let ok = Repository.add_ref_if_new r (Refs.Ref refname) (Refs.Hash sha) in
  if not ok
  then failwith (spf "could not create branch '%s'" name)
@

<<function Cmd_branch.delete_branch>>=
let delete_branch r name force =
  let refname = "refs/heads/" ^ name in
  let aref = Refs.Ref refname in
  let sha = Repository.follow_ref_some r aref in
  if not force
  (* todo: detect if fully merged branch! *)    
  then ();
  Repository.del_ref r aref;
  pr (spf "Deleted branch %s (was %s)" name (Hexsha.of_sha sha))
@

<<constant Cmd_branch.del_flag>>=
let del_flag = ref false
@

<<constant Cmd_branch.del_force>>=
let del_force = ref false
@

<<constant Cmd_branch.cmd>>=
let cmd = { Cmd.
  name = "branch";
  help = " [options]
   or: ogit branch [options] <branchname>
   or: ogit branch [options] (-d | -D) <branchname>
";
  options = [
    "-d",       Arg.Set del_flag, " delete fully merged branch";
    "--delete", Arg.Set del_flag, " delete fully merged branch";
    "-D",       Arg.Set del_force, " delete branch (even if not merged)";
    (* less: --merged, --no-merged, --all for listing 
     *  --move to rename branch
     *  --force (force creation, deletion, rename)
    *)
  ];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let r = Repository.open_ "." in
    match args with
    | [] -> 
      list_branches r
    | [name] ->
      (match () with
      | _ when !del_flag  -> delete_branch r name false
      | _ when !del_force -> delete_branch r name true
      | _ -> create_branch r name
      )
    | [name;objectish] ->
      raise Todo
    | _ -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_branch.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_branch.list_branches>>

<<function Cmd_branch.create_branch>>

<<function Cmd_branch.delete_branch>>

(* less: rename_branch *)

<<constant Cmd_branch.del_flag>>
<<constant Cmd_branch.del_force>>

<<constant Cmd_branch.cmd>>
@


\subsection*{[[version_control/cmd_checkout.ml]]}

<<function Cmd_checkout.checkout>>=
let checkout r str =
  let all_refs = Repository.all_refs r in
  let refname = "refs/heads/" ^ str in
  match () with
  | _ when List.mem refname all_refs ->
    let commitid = Repository.follow_ref_some r (Refs.Ref refname) in
    let commit = Repository.read_commit r commitid in
    let treeid = commit.Commit.tree in
    let tree = Repository.read_tree r treeid in
    (* todo: order of operation? set ref before index? reverse? *)
    Repository.write_ref r (Refs.Head) (Refs.OtherRef refname);
    Repository.set_worktree_and_index_to_tree r tree;
    pr (spf "Switched to branch '%s'" str);
    (* less: if master, then check if up-to-date with origin/master *)
  | _ when Hexsha.is_hexsha str ->
    let commitid = Hexsha.to_sha str in
    let commit = Repository.read_commit r commitid in
    let treeid = commit.Commit.tree in
    let tree = Repository.read_tree r treeid in
    (* todo: order of operation? set ref before index? reverse? *)
    Repository.write_ref r (Refs.Head) (Refs.Hash commitid);
    Repository.set_worktree_and_index_to_tree r tree;
    pr (spf "Note: checking out '%s'." str);
    pr ("You are in 'detached HEAD' state");
  | _ -> raise Cmd.ShowUsage
@

<<function Cmd_checkout.update>>=
(* Your branch is up-to-date with 'origin/master'. *)
let update r =
  raise Todo
@

<<constant Cmd_checkout.cmd>>=
let cmd = { Cmd.
  name = "checkout";
  help = " [options] <branch>
   or: ogit checkout [options] <commitid>
   or: ogit checkout [options]
";
  options = [
    (* less: --detach, --patch?
     * -b create and checkout a branch
     *)
  ];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let r = Repository.open_ "." in
    match args with
    | [] -> update r
    | [str] -> checkout r str
    | _ -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_checkout.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_checkout.checkout>>


<<function Cmd_checkout.update>>

<<constant Cmd_checkout.cmd>>
@


\subsection*{[[version_control/cmd_clone.ml]]}

<<function Cmd_clone.clone>>=
(* =~ git pull from scratch (itself =~ git fetch + git merge) *)
let clone url path_dst =
  let client = Clients.client_of_url url in
  
  Repository.init path_dst;
  let dst = Repository.open_ path_dst in

  (* less: allow to grab from different head? *)
  let remote_HEAD_sha = client.Client.fetch dst in
  Repository.set_ref dst (Refs.Head) remote_HEAD_sha;

  (* =~ reset index *)
  let commit = Repository.read_commit dst remote_HEAD_sha in
  let tree = Repository.read_tree dst (commit.Commit.tree) in
  Repository.set_worktree_and_index_to_tree dst tree
@

<<constant Cmd_clone.cmd>>=
let cmd = { Cmd.
  name = "clone";
  help = " [options] <repo> [<dir>]";
  options = [
    (* less: --bare, --progress, --depth *)
  ];
  f = (fun args ->
    match args with
    | [url] -> 
      clone url "."
    | [url;dst] ->
      clone url dst
    | _ -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_clone.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_clone.clone>>

  (* todo: when clone then repo should have a "refs/remotes/origin/master" *)


<<constant Cmd_clone.cmd>>
@


\subsection*{[[version_control/cmd_commit.ml]]}

<<function Cmd_commit.commit>>=
let commit r author committer message =
  (* todo: imitate git output
   *   [master 0b50159] xxx
   *   1 file changed, 0 insertions(+), 0 deletions(-)
   *   create mode 100644 foobar.txt
   *)
  (* todo: nothing to commit, working directory clean *)
  Repository.commit_index r author committer message
@

<<constant Cmd_commit.author>>=
let author = ref ""
@

<<constant Cmd_commit.committer>>=
let committer = ref ""
@

<<constant Cmd_commit.message>>=
let message = ref ""
@

<<constant Cmd_commit.cmd>>=
let cmd = { Cmd.
  name = "commit";
  help = " [options]"; (* less: <pathspec>... *)
  options = [
    "-m",        Arg.Set_string message, " commit message";
    "--message", Arg.Set_string message, " commit message";
    "--author", Arg.Set_string author, " <author> override author";
    "--committer", Arg.Set_string author, " ";
    (* less: commit mesg option: --file, --date, --signoff *)
    (* less: commit content options: -a, --interactive, --patch *)
    (* todo: --amend *)
  ];
  f = (fun args ->
    match args with
    | [] -> 
      (* todo: allow cmd from different location *)
      let r = Repository.open_ "." in
      let today = 
        (Int64.of_float (Unix.time ()),
         { User.
       (* todo: use localtime vs gmtime? *)
           sign = User.Minus;
           hours = 7; (* SF *)
           min = 0;
         })
      in
      (* todo: read from .git/config or ~/.gitconfig *)
      let author = 
        if !author = ""
        then { User.
               name = Unix.getlogin ();
               email = "todo@todo";
               date = today;
             }
        else raise Todo (* need parse author string *)
      in
      let committer =
        if !committer = ""
        then author
        else raise Todo
      in
      commit r author committer !message

    | xs -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_commit.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_commit.commit>>

<<constant Cmd_commit.author>>
<<constant Cmd_commit.committer>>
<<constant Cmd_commit.message>>

<<constant Cmd_commit.cmd>>
@


\subsection*{[[version_control/cmd_diff.ml]]}

<<function Cmd_diff.diff_worktree_vs_index>>=
let diff_worktree_vs_index r =
  let changes = 
    Changes.changes_worktree_vs_index 
      (Repository.read_blob r)
      r.Repository.worktree 
      r.Repository.index 
  in
  changes |> List.iter Diff_unified.show_change
@

<<constant Cmd_diff.cmd>>=
let cmd = { Cmd.
  name = "diff";
  help = " ";
  options = [];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let r = Repository.open_ "." in
    match args with
    | [] -> diff_worktree_vs_index r
    | xs -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_diff.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common


<<function Cmd_diff.diff_worktree_vs_index>>

<<constant Cmd_diff.cmd>>
@


\subsection*{[[version_control/cmd_dump.ml]]}

<<constant Cmd_dump.raw>>=
let raw = ref false
@

<<constant Cmd_dump.index>>=
let index = ref false
@

<<function Cmd_dump.dump_object>>=
(* =~ git cat-file -p *)
let dump_object file =
  let chan = open_in file in
  let input = IO.input_channel chan in
  let unzipped = Unzip.inflate input in
  
  try
    if !raw
    then 
      let str = IO.read_all unzipped in 
      pr2 str
    else begin
      let obj = Objects.read unzipped in
      let v = Dump.vof_obj obj in
      pr (Ocaml.string_of_v v)
    end
  with Unzip.Error _err ->
    failwith "unzip error"
@

<<function Cmd_dump.dump_index>>=
(* =~ dulwich dump-index, =~ git ls-files --stage *)
let dump_index file =
  let chan = open_in file in
  let input = IO.input_channel chan in
  let index = Index.read input in
  let v = Dump.vof_index index in
  pr (Ocaml.string_of_v v)
@

<<function Cmd_dump.dump>>=
let dump file =
  if !index
  then dump_index file
  else dump_object file
@

<<constant Cmd_dump.cmd>>=
let cmd = { Cmd.
  name = "dump";
  help = " <file>";
  options = [
    "-raw", Arg.Set raw, " do not pretty print";
    "-index", Arg.Set index, " pretty print index content";
  ];
  f = (fun args ->
    match args with
    | [file] -> dump file
    | _ -> failwith (spf "dump command [%s] not supported"
                       (String.concat ";" args))
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_dump.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<constant Cmd_dump.raw>>
<<constant Cmd_dump.index>>

<<function Cmd_dump.dump_object>>

<<function Cmd_dump.dump_index>>

<<function Cmd_dump.dump>>

<<constant Cmd_dump.cmd>>
@


\subsection*{[[version_control/cmd_help.ml]]}

<<constant Cmd_help.list_extra>>=
let list_extra = ref false
@

<<constant Cmd_help.cmd>>=
let rec cmd = { Cmd.
  name = "help";
  help = "";
  options = ["-a", Arg.Set list_extra, " see all commands"];
  f = (fun args ->
    let xs = 
      if !list_extra
      then Cmds.main_commands @ Cmds.extra_commands @ [cmd]
      else Cmds.main_commands
    in
    pr ("Available commands: ");
    xs |> List.iter (fun cmd ->
      pr (spf "  %s" cmd.Cmd.name);
    );
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_help.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<constant Cmd_help.list_extra>>

<<constant Cmd_help.cmd>>
@


\subsection*{[[version_control/cmd_init.ml]]}

<<constant Cmd_init.cmd>>=
let cmd = { Cmd.
  name = "init";
  help = " [directory]";
  options = [
   (* less: -bare, --quiet *)
  ];
  f = (fun args ->
    match args with
    | [] ->
      Repository.init "."
    | [dir] ->
      Repository.init dir
    | _ -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_init.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(* less: let bare = ref false *)

<<constant Cmd_init.cmd>>
@


\subsection*{[[version_control/cmd_log.ml]]}

<<function Cmd_log.print_commit>>=
let print_commit sha commit =
  pr (spf "commit: %s" (Hexsha.of_sha sha));
  (match commit.Commit.parents with
  | [] | [_] -> ()
  | x::xs ->
    pr (spf "merge: %s" 
          (xs |> List.map Hexsha.of_sha |> String.concat "..."));
  );
  let author = commit.Commit.author in
  pr (spf "Author: %s <%s>" author.User.name author.User.email);
  let committer = commit.Commit.committer in
  if author <> committer
  then 
    pr (spf "Committer: %s <%s>" committer.User.name committer.User.email);
  pr (spf "Date:   %s" (User.string_of_date author.User.date));
  pr "";
  pr ("    " ^ commit.Commit.message);
  ()
@

<<function Cmd_log.print_change>>=
let print_change change =
  match change with
  | Change.Add entry ->
    pr (spf "A       %s" entry.Change.path)
  | Change.Del entry ->
    pr (spf "D       %s" entry.Change.path)
  | Change.Modify (entry1, entry2) ->
    pr (spf "M       %s" entry1.Change.path)
@

<<constant Cmd_log.name_status>>=
let name_status = ref false
@

<<function Cmd_log.log>>=
(* todo: track only selected paths 
 * (and then rename detection to track correctly)
 *)
let log r =
  let start = Repository.follow_ref_some r (Refs.Head) in
  start |> Commit.walk_history (Repository.read_commit r) (fun sha commit ->
    print_commit sha commit;
    if !name_status
    then begin
      let tree1 = Repository.read_tree r commit.Commit.tree in
      let tree2 =
        match commit.Commit.parents with
        | [] -> []
        | [sha] -> 
          let commit2 = Repository.read_commit r sha in
          Repository.read_tree r commit2.Commit.tree
        | x::y::xs ->
          failwith "TODO: log: handle merge"
      in
      let changes = Changes.changes_tree_vs_tree
        (Repository.read_tree r)
        (Repository.read_blob r)
        tree2
        tree1
      in
      changes |> List.iter print_change;
      pr "";
    end
  )
@

<<constant Cmd_log.cmd>>=
let cmd = { Cmd.
  name = "log";
  help = " [options]";
  options = [
    "--name-status", Arg.Set name_status, 
    " print name/status for each changed file";
    (* todo: -1, -10 *)
    (* less: --reverse *)
  ];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let r = Repository.open_ "." in
    match args with
    | [] -> log r
    (* todo: git log path *)
    (* less: revision range *)
    | xs -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_log.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(* todo: git log --graph --oneline --decorate --all *)

<<function Cmd_log.print_commit>>

<<function Cmd_log.print_change>>


<<constant Cmd_log.name_status>>

<<function Cmd_log.log>>

<<constant Cmd_log.cmd>>
@


\subsection*{[[version_control/cmd_merge.ml]]}


%-------------------------------------------------------------

<<version_control/cmd_merge.ml>>=
@


\subsection*{[[version_control/cmd_pull.ml]]}

<<function Cmd_pull.pull>>=
(* =~ git fetch + git merge *)
let pull dst url =
  (* todo: detect if clean repo? status is empty? *)
  let client = Clients.client_of_url url in

  (* less: allow to grab from multiple heads, not just HEAD *)
  let remote_HEAD_sha = client.Client.fetch dst in
  
  (* detect if need merge, if current HEAD not parent of new HEAD *)
  let current_HEAD_sha = Repository.follow_ref_some dst (Refs.Head) in
  let ancestors_remote_HEAD = 
    Commit.collect_ancestors (Repository.read_commit dst) [remote_HEAD_sha]
      (Hashtbl.create 101)
  in
  (match () with
  | _ when remote_HEAD_sha = current_HEAD_sha -> ()
  | _ when Hashtbl.mem ancestors_remote_HEAD current_HEAD_sha ->
    (* easy case *)
    pr (spf "fast forward to %s" (Hexsha.of_sha remote_HEAD_sha));
    Repository.set_ref dst (Refs.Head) remote_HEAD_sha;
    let commit = Repository.read_commit dst remote_HEAD_sha in
    let tree = Repository.read_tree dst (commit.Commit.tree) in
    Repository.set_worktree_and_index_to_tree dst tree
  | _ -> failwith "TODO: git pull need merge"
  )
@

<<constant Cmd_pull.cmd>>=
let cmd = { Cmd.
  name = "pull";
  help = " [options] [<url repository>]";
  options = [
  ];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let dst = Repository.open_ "." in
    match args with
    | [] -> 
      failwith "TODO: use remote information in config file"
    | [url] -> 
      pull dst url
    | _ -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_pull.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_pull.pull>>


<<constant Cmd_pull.cmd>>
@


\subsection*{[[version_control/cmd_push.ml]]}

<<function Cmd_push.push>>=
(* =~ git fetch + git merge but inverting dst and src  *)
let push src_repo url_dst =
  let url = src_repo.Repository.worktree in
  let dst = Repository.open_ url_dst in
  (* todo: detect if clean repo? status is empty? *)
  let client = Clients.client_of_url url in


  (* less: allow to grab from multiple heads, not just HEAD *)
  let remote_HEAD_sha = client.Client.fetch dst in
  
  (* detect if need merge, if current HEAD not parent of new HEAD *)
  let current_HEAD_sha = Repository.follow_ref_some dst (Refs.Head) in
  let ancestors_remote_HEAD = 
    Commit.collect_ancestors (Repository.read_commit dst) [remote_HEAD_sha]
      (Hashtbl.create 101)
  in
  (match () with
  | _ when current_HEAD_sha = remote_HEAD_sha -> ()
  | _ when Hashtbl.mem ancestors_remote_HEAD current_HEAD_sha ->
    (* easy case *)
    pr (spf "fast forward to %s" (Hexsha.of_sha remote_HEAD_sha));
    Repository.set_ref dst (Refs.Head) remote_HEAD_sha;
    let commit = Repository.read_commit dst remote_HEAD_sha in
    let tree = Repository.read_tree dst (commit.Commit.tree) in
    Repository.set_worktree_and_index_to_tree dst tree
  | _ -> failwith "TODO: git pull need merge"
  )
@

<<constant Cmd_push.cmd>>=
let cmd = { Cmd.
  name = "push";
  help = " [options] [<url repository>]";
  options = [
    (* less: --all, --force, --progress *)
  ];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let src = Repository.open_ "." in
    match args with
    | [] -> 
      failwith "TODO: use remote information in config file"
    | [url] -> 
      push src url
    | _ -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_push.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_push.push>>

<<constant Cmd_push.cmd>>
@


\subsection*{[[version_control/cmd_reset.ml]]}

<<function Cmd_reset.reset_hard>>=
let reset_hard r =
  let commitid = Repository.follow_ref_some r (Refs.Head) in
  let commit = Repository.read_commit r commitid in
  let treeid = commit.Commit.tree in
  let tree = Repository.read_tree r treeid in
  Repository.set_worktree_and_index_to_tree r tree;
  pr (spf "HEAD is now at %s %s" 
        (String.sub (Hexsha.of_sha commitid) 0 6)
        (String.sub commit.Commit.message 0 40))
@

<<constant Cmd_reset.hard>>=
let hard = ref false
@

<<constant Cmd_reset.soft>>=
let soft = ref false
@

<<constant Cmd_reset.mixed>>=
let mixed = ref false
@

<<constant Cmd_reset.cmd>>=
let cmd = { Cmd.
  name = "reset";
  help = " [options] ";
(* less: or: git reset <paths>... *)
  options = [
    "--hard", Arg.Set hard, " reset HEAD, index and working tree";
    "--soft", Arg.Set soft, " reset only HEAD";
    "--mixed", Arg.Set mixed, " reset HEAD and index";
    (* less: --patch, --quiet, --merge *)
  ];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let r = Repository.open_ "." in
    match args with
    | [] -> 
      if !soft || !mixed || not !hard
      then begin
        pr2 "only --hard supported";
        raise Cmd.ShowUsage
      end;
      reset_hard r
    | _ -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_reset.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_reset.reset_hard>>

<<constant Cmd_reset.hard>>
<<constant Cmd_reset.soft>>
<<constant Cmd_reset.mixed>>

<<constant Cmd_reset.cmd>>
@


\subsection*{[[version_control/cmd_rm.ml]]}

<<function Cmd_rm.rm>>=
let rm r relpaths =
  (* removing is simpler than adding; no need to add blobs in
   * the object store, so can just use functions from Index
   *)
  (* less: not super efficient, could use hashes to speedup things*)
  r.Repository.index <-
    relpaths |> List.fold_left (fun idx relpath ->
          (* todo: -f? remove also file *)
      Index.remove_entry idx relpath
    ) r.Repository.index;
  Repository.write_index r
@

<<constant Cmd_rm.cmd>>=
let cmd = { Cmd.
  name = "rm";
  help = " [options] <file>...";
  options = [
  (* less: -f force, -r recursive, --quiet *)
  ];
  f = (fun args ->
    match args with
    | [] -> raise Cmd.ShowUsage
    | xs ->
      (* todo: allow git rm from different location *)
      let r = Repository.open_ "." in
      (* less: support absolute paths, directories *)
      let relpaths = xs |> List.map (fun path ->
        if Filename.is_relative path
        then path
        else failwith (spf "Not a relative path: %s" path)
      )
      in
      rm r relpaths
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_rm.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_rm.rm>>


<<constant Cmd_rm.cmd>>
@


\subsection*{[[version_control/cmd_show.ml]]}

<<function Cmd_show.show>>=
let show r objectish =
  let obj = Repository.read_objectish r objectish in
  match obj with
  | Objects.Blob x -> 
    Blob.show x
  | Objects.Tree x ->
    (* =~ git ls-tree --names-only *)
    pr "tree\n"; (* less: put sha of tree *)
    Tree.show x
  | Objects.Commit x -> 
    pr "commit"; (* less: put sha of commit *)
    Commit.show x;
    let tree2 = Repository.read_tree r x.Commit.tree in
    let parent1 = Repository.read_commit r (List.hd x.Commit.parents) in
    let tree1 = Repository.read_tree r parent1.Commit.tree in
    let changes = 
      Changes.changes_tree_vs_tree 
        (Repository.read_tree r) 
        (Repository.read_blob r)
        tree1 tree2 
    in
    changes |> List.iter Diff_unified.show_change
@

<<constant Cmd_show.cmd>>=
let cmd = { Cmd.
  name = "show";
  help = " <objectish>";
  (* less: --oneline *)
  options = [];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let r = Repository.open_ "." in
    match args with
    | [] -> show r (Repository.ObjByRef (Refs.Head))
    | xs ->
      xs |> List.iter (fun str ->
        show r (Repository.ObjByHex (str))
      )
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_show.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_show.show>>

<<constant Cmd_show.cmd>>
@


\subsection*{[[version_control/cmd_status.ml]]}

<<type Cmd_status.status>>=
type status = {
  (* diff index vs HEAD *)
  staged: Change.t list;
  (* diff worktree vs index *)
  unstaged: Change.t list;
  (* other *)
  untracked: Common.filename list;
}
@

<<function Cmd_status.changes_index_vs_HEAD>>=
let changes_index_vs_HEAD r =
  let commitid = Repository.follow_ref_some r (Refs.Head) in
  let commit = Repository.read_commit r commitid in
  let treeid = commit.Commit.tree in
  Changes.changes_index_vs_tree (Repository.read_tree r) 
    r.Repository.index
    treeid
@

<<function Cmd_status.untracked>>=
(* todo: need parse .gitignore *)
let untracked r =
  let h = r.Repository.index 
      |> List.map (fun entry -> entry.Index.name, true) 
      |> Hashtbl_.of_list 
  in
  let res = ref [] in
  r.Repository.worktree |> Repository.walk_dir (fun dir dirs files ->
    files |> List.iter (fun file ->
      let path = Filename.concat dir file in
      let path = 
        if path =~ "^\\./\\(.*\\)"
        then Regexp_.matched1 path
        else path
      in
      if not (Hashtbl.mem h path)
      then Common.push path res
    );
  );
  List.rev !res
@

<<function Cmd_status.status_of_repository>>=
let status_of_repository r =
  { staged = changes_index_vs_HEAD r;
    unstaged = 
      Changes.changes_worktree_vs_index 
        (Repository.read_blob r)
        r.Repository.worktree 
        r.Repository.index;
    untracked = untracked r;
  }
@

<<function Cmd_status.print_change_long>>=
(* very similar to Cmd_log.print_change, but with more indentation *)
let print_change_long change =
  match change with
  | Change.Add entry ->
    pr (spf "	new file:	%s" entry.Change.path)
  | Change.Del entry ->
    pr (spf "	deleted:	%s" entry.Change.path)
  | Change.Modify (entry1, entry2) ->
    pr (spf "	modified:	%s" entry1.Change.path)
@

<<function Cmd_status.print_status_long>>=
let print_status_long st =
  if st.staged <> []
  then begin
    pr "Changes to be committed:";
(*  (use "git reset HEAD <file>..." to unstage) *)
    pr "";
    st.staged |> List.iter print_change_long;
    pr "";
  end;
  if st.unstaged <> []
  then begin
    pr "Changes not staged for commit:";
    pr "";
(*
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
*)

    st.unstaged |> List.iter print_change_long;
    pr "";
  end;
  if st.untracked <> []
  then begin
    pr "Untracked files:";
(*  (use "git add <file>..." to include in what will be committed) *)
    pr "";
    st.untracked |> List.iter (fun file ->
      pr (spf "	%s" file)
    );
    pr "";
  end
@

<<function Cmd_status.print_status_short>>=
let print_status_short st =
  raise Todo
@

<<constant Cmd_status.short_format>>=
let short_format = ref false
@

<<function Cmd_status.status>>=
let status r =
  let st = status_of_repository r in
  if !short_format
  then print_status_short st
  else print_status_long st
@

<<constant Cmd_status.cmd>>=
let cmd = { Cmd.
  name = "status";
  help = " [options]"; (* less: <pathspec> *)
  options = [
    "--short", Arg.Set short_format, " show status concisely";
    "--long", Arg.Clear short_format, " show status in long format (default)";
    (* less: --branch, --ignored *)
  ];
  f = (fun args ->
    (* todo: allow git rm from different location *)
    let r = Repository.open_ "." in
    match args with
    | [] -> status r
    | xs -> raise Cmd.ShowUsage
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_status.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<type Cmd_status.status>>

<<function Cmd_status.changes_index_vs_HEAD>>

<<function Cmd_status.untracked>>


<<function Cmd_status.status_of_repository>>

<<function Cmd_status.print_change_long>>


<<function Cmd_status.print_status_long>>
    

<<function Cmd_status.print_status_short>>

<<constant Cmd_status.short_format>>

<<function Cmd_status.status>>

<<constant Cmd_status.cmd>>
@


\subsection*{[[version_control/cmd_test.ml]]}

<<function Cmd_test.test_sha1>>=
(* see https://git-scm.com/book/en/v2/Git-Internals-Git-Objects *)
let test_sha1 () =
  let content = "what is up, doc?"
    (*"test content\n"  *)
  in
  let header = "blob 16\000" in
  let store = header ^ content in

  let sha = Sha1.sha1 store in
  pr (spf "len = %d, raw = %s" (String.length sha) sha);
  let hexsha = Hexsha.of_sha sha in
  pr (spf "len = %d, str = %s" (String.length hexsha) hexsha);
  ()
@

<<constant Cmd_test.cmd>>=
let cmd = { Cmd.
  name = "test";
  help = " ";
  options = [];
  f = (fun args ->
    match args with
    | ["sha1"] -> test_sha1 ()
    | _ -> failwith (spf "test command [%s] not supported"
                       (String.concat ";" args))
  );
}
@


%-------------------------------------------------------------

<<version_control/cmd_test.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

<<function Cmd_test.test_sha1>>

<<constant Cmd_test.cmd>>

@


\subsection*{[[version_control/cmds.ml]]}

<<constant Cmds.main_commands>>=
let main_commands = [
  Cmd_init.cmd;
  Cmd_add.cmd;
  Cmd_rm.cmd;
  Cmd_commit.cmd;

  Cmd_branch.cmd;
  Cmd_checkout.cmd;
  Cmd_reset.cmd;
  
  Cmd_show.cmd;
  Cmd_diff.cmd;
  Cmd_log.cmd;
  Cmd_status.cmd;

  Cmd_pull.cmd;
  Cmd_push.cmd;
  Cmd_clone.cmd;
]
@

<<constant Cmds.extra_commands>>=
let extra_commands = [
  Cmd_test.cmd;
  Cmd_dump.cmd;
]
@


%-------------------------------------------------------------

<<version_control/cmds.ml>>=

<<constant Cmds.main_commands>>

<<constant Cmds.extra_commands>>
@


\subsection*{[[version_control/commit.ml]]}

<<type Commit.t>>=
type t = {
  tree     : Tree.hash;
  (* first commit has no parent, and merge commits have 2 parents *)
  parents  : hash list;
  (* note that User.t contains a time *)
  author   : User.t;
  committer: User.t;

  (* less: encoding, gpgsig, mergetag, extra *)

  message  : string;
}
@

<<type Commit.hash>>=
and hash = Sha1.t
@

<<function Commit.walk_history>>=
(* less: sort by time? so have a sorted queue of commits *)
let walk_history read_commit f sha =
  (* we are walking a DAG, so we need to remember already processed nodes *)
  let hdone = Hashtbl.create 101 in
  let rec aux sha =
    if Hashtbl.mem hdone sha
    then ()
    else begin
      Hashtbl.add hdone sha true;
      let commit = read_commit sha in
      (* todo: path matching *)
      f sha commit;
      commit.parents |> List.iter aux
    end
  in
  aux sha
(* 
let walk_graph r f =
  let heads = 
    Repository.all_refs r |> Common.map_filter (fun aref ->
      if aref =~ "refs/heads/"
      then Some (Repository.follow_ref_some r (Refs.Ref aref))
      else None
    )
  in
  ...
  heads |> List.iter aux
*)
@

<<function Commit.collect_ancestors>>=
(* similar to walk_history but with exposed hdone hash *)
let collect_ancestors read_commit top_commits hdone =
  let hcommits = Hashtbl.create 101 in
  let rec aux sha =
    if Hashtbl.mem hdone sha
    then ()
    else begin
      Hashtbl.add hdone sha true;
      Hashtbl.add hcommits sha true;
      let commit = read_commit sha in
      commit.parents |> List.iter aux
    end
  in
  top_commits |> List.iter aux;
  hcommits
@

<<function Commit.read>>=
let read ch =
  let tree = 
    IO_.read_key_space_value_newline ch "tree" Hexsha.read in
  (* todo: read "parent" or "author", because first commit has no parent *)
  let parents, author = 
    let rec loop parents =
      let str = IO_.read_string_and_stop_char ch ' ' in
      match str with
      | "parent" -> 
        let v = Hexsha.read ch in
        let c = IO.read ch in
        if c <> '\n'
        then failwith "Commit.read: missing newline after parent";
        loop (v::parents)
      | "author" ->
        let v = User.read ch in
        let c = IO.read ch in
        if c <> '\n'
        then failwith "Commit.read: missing newline after author";
        List.rev parents, v
      | _ -> failwith (spf "Commit.read: was expecting parent or author not %s"
                         str)
    in
    loop []
  in
  let committer = 
    IO_.read_key_space_value_newline ch "committer" User.read in
  let c = IO.read ch in
  if c <> '\n'
  then failwith "Commit.read: missing newline before message";
  let msg = IO.read_all ch in
  { tree = Hexsha.to_sha tree; 
    parents = parents |> List.map Hexsha.to_sha; 
    author = author; committer = committer;
    message = msg;
  }
@

<<function Commit.write>>=
let write commit ch =
  IO.nwrite ch "tree ";
  Hexsha.write ch (Hexsha.of_sha commit.tree);
  IO.write ch '\n';
  commit.parents |> List.iter (fun parent ->
    IO.nwrite ch "parent ";
    Hexsha.write ch (Hexsha.of_sha parent);
    IO.write ch '\n';
  );
  IO.nwrite ch "author ";
  User.write ch commit.author;
  IO.write ch '\n';
  IO.nwrite ch "committer ";
  User.write ch commit.committer;
  IO.write ch '\n';

  IO.write ch '\n';
  IO.nwrite ch commit.message
@

<<function Commit.show>>=
let show x =
  pr (spf "Author: %s <%s>" x.author.User.name x.author.User.email);
  (* less: date of author or committer? *)
  let date = x.author.User.date in
  pr (spf "Date:   %s" (User.string_of_date date));
  pr "";
  pr ("    " ^ x.message)
  (* showing diff done in caller in Cmd_show.show *)        
@


%-------------------------------------------------------------

<<version_control/commit.ml>>=
(*
 * Copyright (c) 2013-2017 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Commit.t>>
<<type Commit.hash>>

(*****************************************************************************)
(* API *)
(*****************************************************************************)

(* for git log *)

<<function Commit.walk_history>>

(* for git pull *)
<<function Commit.collect_ancestors>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Commit.read>>

<<function Commit.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Commit.show>>
@


\subsection*{[[version_control/commit.mli]]}

<<type Commit.t (version_control/commit.mli)>>=
type t = {
  tree     : Tree.hash;
  parents  : hash list;
  author   : User.t;
  committer: User.t;

  message  : string;
}
@

<<type Commit.hash (version_control/commit.mli)>>=
and hash = Sha1.t
@

<<signature Commit.read>>=
(* assumes have already read the 'commit <size>\000' hdr from unzipped input *)
val read: IO.input -> t
(* does not write the header, does not compress *)
@

<<signature Commit.write>>=
(* does not write the header, does not compress *)
val write: t -> 'a IO.output -> unit
@

<<signature Commit.show>>=
val show: t -> unit
@

<<signature Commit.collect_ancestors>>=
val collect_ancestors: 
  (hash -> t) ->  hash list -> (hash, bool) Hashtbl.t -> 
  (hash, bool) Hashtbl.t
@

<<signature Commit.walk_history>>=
val walk_history:  
  (hash -> t) -> (hash -> t -> unit) -> hash ->
  unit
@


%-------------------------------------------------------------

<<version_control/commit.mli>>=

<<type Commit.t (version_control/commit.mli)>>
<<type Commit.hash (version_control/commit.mli)>>


<<signature Commit.read>>
<<signature Commit.write>>

<<signature Commit.show>>

<<signature Commit.collect_ancestors>>

<<signature Commit.walk_history>>
@


\subsection*{[[version_control/compression.ml]]}

<<function Compression.decompress>>=
let decompress ch = 
  Unzip.inflate ch
@

<<function Compression.compress>>=
let compress ic oc =
  Zlib.compress 
    (fun buf -> 
      try IO.input ic buf 0 (Bytes.length buf)
      with IO.No_more_input -> 0
    )
    (fun buf len -> 
      IO.output oc buf 0 len |> ignore)
@


%-------------------------------------------------------------

<<version_control/compression.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Compression/decompression wrappers.
 * 
 * alternatives:
 *  * https://github.com/ygrek/ocaml-extlib/src/unzip.ml
 *    just decompression (inflate), pretty small: 450 LOC
 *  - https://github.com/mirage/decompress
 *    compression/decompression, seems complete, but pretty big. 
 *    used by https://github.com/mirage/ocaml-git
 *  * https://github.com/xavierleroy/camlzip
 *    uses C code (some of the code in ocaml-git uses ML code from camlzip)
 *  - https://github.com/madroach/ocaml-zlib
 *    ??
 *  - https://github.com/samoht/ocaml-lz77 
 *    copy-pasted in decompress, but too simple. Does not
 *    support right API where can compress/decompress strings.
 *  - libflate in plan9 :)
 * 
 * Currently used solutions are marked with a '*' above.
 *)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Compression.decompress>>

<<function Compression.compress>>
@


\subsection*{[[version_control/compression.mli]]}

<<signature Compression.decompress>>=
val decompress: 
  IO.input -> IO.input
@

<<signature Compression.compress>>=
val compress: 
  IO.input -> 'a IO.output -> unit
@


%-------------------------------------------------------------

<<version_control/compression.mli>>=

<<signature Compression.decompress>>
<<signature Compression.compress>>
@


\subsection*{[[version_control/diff.ml]]}

<<type Diff.item>>=
type item = string
@

<<type Diff.diff_elem>>=
(* similar to change.ml, but for content of the file *)
type diff_elem = 
  | Added of item
  | Deleted of item
  | Equal of item
@

<<type Diff.diff>>=
type diff = diff_elem list
@

<<function Diff.split_lines>>=
let split_lines str =
  (* alt: let xs = Str.full_split (Str.regexp "\n") str in *)
  let rec aux start = 
    try
      let idx = String.index_from str start '\n' in
      let line = String.sub str start (idx - start + 1) in
      line::aux (idx + 1)
    with Not_found ->
      if start = String.length str
      then []
      else [String.sub str start (String.length str - start)]
  in
  aux 0
@

<<function Diff.diff_buggy>>=
(*
SimpleDiff is buggy!
Here is an example of output after an ogit diff (with some debugging 
information):

diff --git a/authors.txt b/authors.txt
["Yoann Padioleau\n"; "\n"; "except \n"; " - lex/ by Xavier Leroy (from ocaml)\n"; " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n"; " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n"; " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n"; " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n"; " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n"; " - commons/IO.ml by Nicolas Canasse (from exblib)\n"]
["Yoann Padioleau\n"; "\n"; "xxx\n"; "except \n"; " - lex/ by Xavier Leroy (from ocaml)\n"; " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n"; " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n"; " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n"; " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n"; " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n"; " - commons/IO.ml by Nicolas Canasse (from exblib)\n"]
[(()); Tag1 (("Yoann Padioleau\n")); Tag2 (("\n", "xxx\n", "except \n", " - lex/ by Xavier Leroy (from ocaml)\n", " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n", " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n", " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n", " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n", " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n", " - commons/IO.ml by Nicolas Canasse (from exblib)\n"))]
+Yoann Padioleau
 
 xxx
 except 
  - lex/ by Xavier Leroy (from ocaml)
  - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)
  - version_control/sha.ml by Daniel Bunzli (from uuidm)
  - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)
  - version_control/zlib.ml by Xavier Leroy (from camlzip)
  - version_control/unzip.ml by Nicolas Canasse (from extlib)
  - commons/IO.ml by Nicolas Canasse (from exblib)

-----------
SimpleDiff says the diff is the addition of 'Yoann Padioleau' but it's not!
It's in both content. The diff should be the addition of 'xxx'.
*)

let diff_buggy str1 str2 =
  let xs = split_lines str1 in
  let ys = split_lines str2 in
  pr2_gen xs;
  pr2_gen ys;
  let res = SimpleDiff.get_diff (Array.of_list xs) (Array.of_list ys) in
  pr2_gen res;
  res |> List.map (function
    | SimpleDiff.Equal arr   -> 
      arr |> Array.to_list |> List.map (fun x -> Equal x)
    | SimpleDiff.Deleted arr -> 
      arr |> Array.to_list |> List.map (fun x -> Deleted x)
    | SimpleDiff.Added arr   -> 
      arr |> Array.to_list |> List.map (fun x -> Added x)
  )
@

<<function Diff.diff>>=
(* seems correct *)
let diff str1 str2 =
  let xs = split_lines str1 in
  let ys = split_lines str2 in
  let res = StringDiff.diff (Array.of_list xs) (Array.of_list ys) in
  res |> List.rev |> List.map (function
    | `Common (_, _, s) -> Equal s
    | `Removed (_, s) -> Deleted s
    | `Added (_, s) -> Added s
  )
@


%-------------------------------------------------------------

<<version_control/diff.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Compute the differences between 2 files line-wise.
 *
 * alternatives:
 *  - simple diff: https://github.com/gjaldon/simple-diff
 *    (an ocaml port of https://github.com/paulgb/simplediff )
 *    http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1988/8807/8807c/8807c.htm
 *    simple, but no diff -u support by default
 *    and seems buggy!
 *  - myers: https://github.com/leque/ocaml-diff port of
 *    "Eugene Myers, An O(ND) Difference Algorithm and Its Variations, 
 *    Algorithmica Vol. 1 No. 2, pp. 251-266, 1986."
 *  - patience diff: https://github.com/janestreet/patdiff
 *  https://stackoverflow.com/questions/42635889/myers-diff-algorithm-vs-hunt-mcilroy-algorithm
 *    support also colored output, and word diff, but heavily modularized
 *  - plan9 diff (in plan9/utilities/string/diff/)
 *    not myers's diff
 *  - gnu diff (in plan9/ape_cmd/diff)
 *    use myers?
 *  - http://pynash.org/2013/02/26/diff-in-50-lines/ 
 *    (in python, and talk about python difflib)
 *  - Heckle diff mentionned in diff3.py
 *    "P. Heckel. ``A technique for isolating differences between files.''
 *     Communications of the ACM, Vol. 21, No. 4, page 264, April 1978."
 * 
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Diff.item>>

<<type Diff.diff_elem>>

<<type Diff.diff>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Diff.split_lines>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

module SimpleDiff = Diff_simple.Make(String)

<<function Diff.diff_buggy>>

module StringDiff = Diff_myers.Make(struct
  type t = string array
  type elem = string
  let get t i = Array.get t i
  let length t = Array.length t
end)

<<function Diff.diff>>
@


\subsection*{[[version_control/diff.mli]]}

<<type Diff.item (version_control/diff.mli)>>=
type item = string
@

<<type Diff.diff_elem (version_control/diff.mli)>>=
type diff_elem = 
  | Added of item
  | Deleted of item
  | Equal of item
@

<<type Diff.diff (version_control/diff.mli)>>=
type diff = diff_elem list
@

<<signature Diff.diff>>=
val diff: string -> string -> diff
@


%-------------------------------------------------------------

<<version_control/diff.mli>>=

<<type Diff.item (version_control/diff.mli)>>

<<type Diff.diff_elem (version_control/diff.mli)>>

<<type Diff.diff (version_control/diff.mli)>>

<<signature Diff.diff>>
@


\subsection*{[[version_control/diff3.ml]]}


%-------------------------------------------------------------

<<version_control/diff3.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*
 * alternatives:
 *  - gnu diff3, in C
 *    https://www.gnu.org/software/diffutils/manual/html_node/diff3-Merging.html
 *    apparently by Randy Smith in 1988 and popularized by CVS
 *  - Perl Text::Diff3
 *    http://search.cpan.org/~tociyuki/Text-Diff3-0.10/lib/Text/Diff3.pm
 *    with good example of use in man page
 *  - python diff3
 *    https://github.com/schuhschuh/cmake-basis/blob/master/src/utilities/python/diff3.py
 *    apparently translation of the Perl code, itself a translation of the
 *    C code
 *  - formal investigation of diff3:
 *    http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf
 * 
 *)
@


\subsection*{[[version_control/diff_myers.ml]]}

<<type Diff_myers.common>>=
type 'a common =
  [ `Common of int * int * 'a ]
@

<<type Diff_myers.edit>>=
type 'a edit =
  [ `Added of int * 'a
  | `Removed of int * 'a
  | 'a common
  ]
@


%-------------------------------------------------------------

<<version_control/diff_myers.ml>>=
(*
 * Copyright (C) 2016 OOHASHI Daichi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *)

<<type Diff_myers.common>>

<<type Diff_myers.edit>>

module type SeqType = sig
  type t
  type elem
  val get : t -> int -> elem
  val length : t -> int
end

module type S = sig
  type t
  type elem

  val lcs :
      ?equal:(elem -> elem -> bool) ->
      t -> t -> elem common list

  val diff :
      ?equal:(elem -> elem -> bool) ->
      t -> t -> elem edit list

  val fold_left :
      ?equal:(elem -> elem -> bool) ->
      f:('a -> elem edit -> 'a) ->
      init:'a ->
      t -> t -> 'a

  val iter :
      ?equal:(elem -> elem -> bool) ->
      f:(elem edit -> unit) ->
      t -> t -> unit
end

module Make(M : SeqType) : (S with type t = M.t and type elem = M.elem) = struct
  type t = M.t
  type elem = M.elem

  let lcs ?(equal = (=)) a b =
    let n = M.length a in
    let m = M.length b in
    let mn = m + n in
    let sz = 2 * mn + 1 in
    let vd = Array.make sz 0 in
    let vl = Array.make sz 0 in
    let vr = Array.make sz [] in
    let get v i = Array.get v (i + mn) in
    let set v i x = Array.set v (i + mn) x in
    let finish () =
      let rec loop i maxl r =
        if i > mn then
          List.rev r
        else if get vl i > maxl then
          loop (i + 1) (get vl i) (get vr i)
        else
          loop (i + 1) maxl r
      in loop (- mn) 0 []
    in
    if mn = 0 then
      []
    else
      (* For d <- 0 to mn Do *)
      let rec dloop d =
        assert (d <= mn);
        (* For k <- -d to d in steps of 2 Do *)
        let rec kloop k =
          if k > d then
            dloop @@ d + 1
          else
            let x, l, r =
              if k = -d || (k <> d && get vd (k - 1) < get vd (k + 1)) then
                get vd (k + 1), get vl (k + 1), get vr (k + 1)
              else
                get vd (k - 1) + 1, get vl (k - 1), get vr (k - 1)
            in
            let x, y, l, r =
              let rec xyloop x y l r =
                if x < n && y < m && equal (M.get a x) (M.get b y) then
                  xyloop (x + 1) (y + 1) (l + 1) (`Common(x, y, M.get a x) :: r)
                else
                  x, y, l, r
              in xyloop x (x - k) l r
            in
            set vd k x;
            set vl k l;
            set vr k r;
            if x >= n && y >= m then
              (* Stop *)
              finish ()
            else
              kloop @@ k + 2
        in kloop @@ -d
      in dloop 0

  let fold_left ?(equal = (=)) ~f ~init a b =
    let ff x y = f y x in
    let fold_map f g x from to_ init =
      let rec loop i init =
        if i >= to_ then
          init
        else
          loop (i + 1) (f (g i @@ M.get x i) init)
      in loop from init
    in
    let added i x = `Added (i, x) in
    let removed i x = `Removed (i, x) in
    let rec loop cs apos bpos init =
      match cs with
      | [] ->
          init
          |> fold_map ff removed a apos (M.length a)
          |> fold_map ff added b bpos (M.length b)
      | `Common (aoff, boff, _) as e :: rest ->
          init
          |> fold_map ff removed a apos aoff
          |> fold_map ff added b bpos boff
          |> ff e
          |> loop rest (aoff + 1) (boff + 1)
    in loop (lcs ~equal a b) 0 0 init

  let diff ?(equal = (=)) a b =
    fold_left ~equal ~f:(fun xs x -> x::xs) ~init:[] a b

  let iter ?(equal = (=)) ~f a b =
    fold_left a b
      ~equal
      ~f:(fun () x -> f x)
      ~init:()
end
@


\subsection*{[[version_control/diff_myers.mli]]}

<<type Diff_myers.common (version_control/diff_myers.mli)>>=
type 'a common = [
    `Common of int * int * 'a
  ]
@

<<type Diff_myers.edit (version_control/diff_myers.mli)>>=
type 'a edit =
  [ `Removed of int * 'a
  | `Added of int * 'a
  | 'a common
  ]
@


%-------------------------------------------------------------

<<version_control/diff_myers.mli>>=
(**
   An implementation of Eugene Myers' O(ND) Difference Algorithm\[1\].
   This implementation is a port of util.lcs module of
   {{:http://practical-scheme.net/gauche} Gauche Scheme interpreter}.

   - \[1\] Eugene Myers, An O(ND) Difference Algorithm and Its Variations, Algorithmica Vol. 1 No. 2, pp. 251-266, 1986.
 *)

<<type Diff_myers.common (version_control/diff_myers.mli)>>

(** an element of lcs of seq1 and seq2 *)

<<type Diff_myers.edit (version_control/diff_myers.mli)>>

(** an element of diff of seq1 and seq2. *)

module type SeqType = sig
  type t
  (** The type of the sequence. *)

  type elem
  (** The type of the elements of the sequence. *)

  val get : t -> int -> elem
  (** [get t n] returns [n]-th element of the sequence [t]. *)

  val length : t -> int
  (** [length t] returns the length of the sequence [t]. *)
end
(** Input signature of {!Diff.Make}. *)

module type S = sig
  type t
  (** The type of input sequence. *)

  type elem
  (** The type of the elemenents of result / input sequence. *)

  val lcs :
      ?equal:(elem -> elem -> bool) ->
      t -> t -> elem common list
  (**
     [lcs ~equal seq1 seq2] computes the LCS (longest common sequence) of
     [seq1] and [seq2].
     Elements of [seq1] and [seq2] are compared with [equal].
     [equal] defaults to [Pervasives.(=)].

     Elements of lcs are [`Common (pos1, pos2, e)]
     where [e] is an element, [pos1] is a position in [seq1],
     and [pos2] is a position in [seq2].
   *)

  val diff :
      ?equal:(elem -> elem -> bool) ->
      t -> t -> elem edit list
  (**
     [diff ~equal seq1 seq2] computes the diff of [seq1] and [seq2].
     Elements of [seq1] and [seq2] are compared with [equal].

     Elements only in [seq1] are represented as [`Removed (pos, e)]
     where [e] is an element, and [pos] is a position in [seq1];
     those only in [seq2] are represented as [`Added (pos, e)]
     where [e] is an element, and [pos] is a position in [seq2];
     those common in [seq1] and [seq2] are represented as
     [`Common (pos1, pos2, e)]
     where [e] is an element, [pos1] is a position in [seq1],
     and [pos2] is a position in [seq2].
   *)

  val fold_left :
      ?equal:(elem -> elem -> bool) ->
      f:('a -> elem edit -> 'a) ->
      init:'a ->
      t -> t -> 'a
  (**
     [fold_left ~equal ~f ~init seq1 seq2] is same as
     [diff ~equal seq1 seq2 |> ListLabels.fold_left ~f ~init],
     but does not create an intermediate list.
   *)

  val iter :
      ?equal:(elem -> elem -> bool) ->
      f:(elem edit -> unit) ->
      t -> t -> unit
  (**
     [iter ~equal ~f seq1 seq2] is same as
     [diff ~equal seq1 seq2 |> ListLabels.iter ~f],
     but does not create an intermediate list.
   *)
end
(** Output signature of {!Diff.Make}. *)

module Make :
  functor (M : SeqType) -> (S with type t = M.t and type elem = M.elem)
(** Functor building an implementation of the diff structure
    given a sequence type.  *)
@


\subsection*{[[version_control/diff_simple.ml]]}


%-------------------------------------------------------------

<<version_control/diff_simple.ml>>=
module type Comparable =
  sig
    type t
    val compare: t -> t -> int
  end

module type S =
  sig
    type item

    type diff =
      | Deleted of item array
      | Added of item array
      | Equal of item array

    type t = diff list

    val get_diff : item array -> item array -> t
  end

module Make(Item : Comparable) = struct
  type item = Item.t

  type diff =
    | Deleted of item array
    | Added of item array
    | Equal of item array

  type t = diff list

  type subsequence_info =
    { (* Starting index of longest subsequence in the list of new values *)
      sub_start_new : int;
      (* Starting index of longest subsequence in the list of old values *)
      sub_start_old : int;
      (* The length of the longest subsequence *)
      longest_subsequence : int; }

  module CounterMap = Map.Make(Item)

  (* Returns a map with the line as key and a list of indices as value.
     Represents counts of all the lines. *)
  let map_counter keys =
    let keys_and_indices = Array.mapi (fun index key -> index, key) keys in
    Array.fold_left (fun map (index, key) ->
        let indices = try CounterMap.find key map with | Not_found -> [] in
        CounterMap.add key (index :: indices) map
      ) CounterMap.empty keys_and_indices


  (* Computes longest subsequence and returns data on the length of longest
     subsequence and the starting index for the longest subsequence in the old
     and new versions. *)
  let get_longest_subsequence old_lines new_lines =
    let old_values_counter = map_counter old_lines in
    let overlap = Hashtbl.create 5000 in
    let sub_start_old = ref 0 in
    let sub_start_new = ref 0 in
    let longest_subsequence = ref 0 in

    Array.iteri (fun new_index new_value ->
        let indices = try CounterMap.find new_value old_values_counter with
          | Not_found -> []
        in
        List.iter (fun old_index ->
            let prev_subsequence = try Hashtbl.find overlap (old_index - 1) with | Not_found -> 0 in
            let new_subsequence = prev_subsequence + 1 in
            Hashtbl.add overlap old_index new_subsequence;

            if new_subsequence > !longest_subsequence then
              sub_start_old := old_index - new_subsequence + 1;
            sub_start_new := new_index - new_subsequence + 1;
            longest_subsequence := new_subsequence;
          ) indices;
      ) new_lines;

    { sub_start_new = !sub_start_new;
      sub_start_old = !sub_start_old;
      longest_subsequence = !longest_subsequence }


  let rec get_diff old_lines new_lines =
    match old_lines, new_lines with
    | [||], [||] -> []
    | _, _ ->
      let { sub_start_new; sub_start_old; longest_subsequence } =
        get_longest_subsequence old_lines new_lines
      in

      if longest_subsequence == 0 then
        [Deleted old_lines; Added new_lines]
      else
        let old_lines_presubseq = Array.sub old_lines 0 sub_start_old in
        let new_lines_presubseq = Array.sub new_lines 0 sub_start_new in
        let old_lines_postsubseq =
          let start_index = sub_start_old + longest_subsequence in
          let end_index = Array.length old_lines - start_index in
          Array.sub old_lines start_index end_index
        in
        let new_lines_postsubseq =
          let start_index = sub_start_new + longest_subsequence in
          let end_index = Array.length new_lines - start_index in
          Array.sub new_lines start_index end_index
        in
        let unchanged_lines = Array.sub new_lines sub_start_new longest_subsequence in
        get_diff old_lines_presubseq new_lines_presubseq @
        [Equal unchanged_lines] @
        get_diff old_lines_postsubseq new_lines_postsubseq
end
@


\subsection*{[[version_control/diff_simple.mli]]}


%-------------------------------------------------------------

<<version_control/diff_simple.mli>>=
(** A simple diffing algorithm *)

module type Comparable =
  sig
    type t
      (** The type of the items being compared *)

    val compare: t -> t -> int
      (** A way to distinguish if items are equal or unequal. It follows
          the OCaml convention of returning an integer between -1 to 1. *)
  end

module type S =
  sig
    type item
    (** The type of the item that will be compared. *)

    type diff =
      | Deleted of item array
      | Added of item array
      | Equal of item array
    (** Represents the change or lack of change in a line or character
        between the old and new version. *)

    type t = diff list
    (** List of diffs which is the return value of the main function. *)

    val get_diff : item array -> item array -> t
    (** Returns a list of diffs between two arrays *)
  end

module Make (Item: Comparable) : S with type item = Item.t
@


\subsection*{[[version_control/diff_unified.ml]]}

<<function Diff_unified.print>>=
let print = function
  | Diff.Equal s -> 
    print_string (" " ^ s)
  | Diff.Deleted s -> 
    print_string ("-" ^ s)
  | Diff.Added s -> 
    print_string ("+" ^ s)
@

<<function Diff_unified.print_header>>=
let print_header nctx_before nold nnew =
  (* todo: should print size of hunk also here, but then
   * need to wait we finished processing this hunk
   *)
  print_string (spf "@@ -%d, +%d, @@\n"
                  (nold - nctx_before) (nnew - nctx_before))
@

<<constant Diff_unified.nContext>>=
let nContext = 3
@

<<function Diff_unified.show_unified_diff>>=
let show_unified_diff diffs =
  (* naive: no contextual:  diffs |> List.iter print *)
  let rec aux context_lines nctx_before nctx_after nold nnew diffs =
    match diffs with
    (* todo: say if 'No newline at end of file' *)
    | [] -> ()
    | x::xs ->
      (match x with
      | Diff.Equal s ->
        (match () with
        | _ when nctx_after > 0 ->
          print x;
          aux [] 0 (nctx_after - 1) (nold + 1) (nnew + 1) xs
        | _ when nctx_before < nContext ->
          aux (x::context_lines) (nctx_before + 1) 0 (nold + 1) (nnew + 1) xs
        | _ when nctx_before = nContext ->
          let new_context_lines = List_.take nContext (x::context_lines) in
          aux new_context_lines nContext 0 (nold + 1) (nnew + 1) xs
        | _ -> raise (Impossible "")
        )
      | Diff.Deleted s  ->
        let prevs = List_.take nctx_before context_lines |> List.rev in
        if prevs <> [] then print_header nctx_before nold nnew;
        prevs |> List.iter print;
        print x;
        aux [] 0 nContext (nold + 1) (nnew) xs
      | Diff.Added s ->
        let prevs = List_.take nctx_before context_lines |> List.rev in
        if prevs <> [] then print_header nctx_before nold nnew;
        prevs |> List.iter print;
        print x;
        aux [] 0 nContext (nold) (nnew+1) xs
      )
  in
  aux [] 0 0 1 1 diffs
@

<<function Diff_unified.show_change>>=
let show_change change =
  (* less: if mode is gitlink? *)
  let (old_path, old_content), (new_path, new_content) = 
    match change with
    | Change.Add entry ->
      ("dev/null", lazy ""), 
      ("b/" ^ entry.Change.path, entry.Change.content)
    | Change.Del entry ->
      ("a/" ^ entry.Change.path, entry.Change.content), 
      ("dev/null", lazy "")
    | Change.Modify (entry1, entry2) ->
      ("a/" ^ entry1.Change.path, entry1.Change.content), 
      ("b/" ^ entry2.Change.path, entry2.Change.content)
  in
  let diffs = Diff.diff (Lazy.force old_content) (Lazy.force new_content) in
  if not (diffs |> List.for_all (function Diff.Equal _ -> true | _ -> false))
  then begin
    pr (spf "diff --git %s %s" old_path new_path);
    (* less: display change of modes *)
    show_unified_diff diffs
  end
@


%-------------------------------------------------------------

<<version_control/diff_unified.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Show differences between 2 files.
 *
 * Short explanation of unified format:
 *  - https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html
 *  - http://www.artima.com/weblogs/viewpost.jsp?thread=164293  
 * 
 * alternatives:
 *  - ocamldiff: https://github.com/zoggy/ocamldiff 
 *    parse and display unified diffs
 *  - unidiff: https://github.com/gildor478/ocaml-unidiff
 *    parse 
 *  - call diff -u (as I did in pfff) directly via Sys.command
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Diff_unified.print>>

<<function Diff_unified.print_header>>

<<constant Diff_unified.nContext>>

<<function Diff_unified.show_unified_diff>>


(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Diff_unified.show_change>>
@


\subsection*{[[version_control/diff_unified.mli]]}

<<signature Diff_unified.show_change>>=
val show_change: Change.t -> unit
@


%-------------------------------------------------------------

<<version_control/diff_unified.mli>>=

<<signature Diff_unified.show_change>>
@


\subsection*{[[version_control/dump.ml]]}

<<constant Dump.vof_obj>>=
let vof_obj = Objects.vof_t
@

<<constant Dump.vof_index>>=
let vof_index = Index.vof_t
@


%-------------------------------------------------------------

<<version_control/dump.ml>>=
open Ocaml

(* mostly auto-generated by ocamltarzan *)

module Int64 = struct
let vof_t x =
  Ocaml.vof_int (Int64.to_int x)
end

module Int32 = struct
let vof_t x =
  Ocaml.vof_int (Int32.to_int x)
end


module Sha1 = struct
  let vof_t x = 
    Ocaml.VSum (("ShaHex", [Ocaml.vof_string (Hexsha.of_sha x)]))
end

module Blob = struct
  let vof_t x = Ocaml.vof_string x
end

module Tree = struct
open Tree
let vof_perm =
  function
  | Normal -> Ocaml.VSum (("Normal", []))
  | Exec -> Ocaml.VSum (("Exec", []))
  | Link -> Ocaml.VSum (("Link", []))
  | Dir -> Ocaml.VSum (("Dir", []))
  | Commit -> Ocaml.VSum (("Commit", []))
  
let vof_entry { perm = v_perm; name = v_name; node = v_node } =
  let bnds = [] in
  let arg = Sha1.vof_t v_node in
  let bnd = ("node", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_perm v_perm in
  let bnd = ("perm", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  
let vof_t v = Ocaml.vof_list vof_entry v
end

module User = struct
open User
let vof_sign =
  function
  | Plus -> Ocaml.VSum (("Plus", []))
  | Minus -> Ocaml.VSum (("Minus", []))
  
let vof_tz_offset { sign = v_sign; hours = v_hours; min = v_min } =
  let bnds = [] in
  let arg = Ocaml.vof_int v_min in
  let bnd = ("min", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_int v_hours in
  let bnd = ("hours", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_sign v_sign in
  let bnd = ("sign", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let vof_t { name = v_name; email = v_email; date = v_date } =
  let bnds = [] in
  let arg =
    match v_date with
    | (v1, v2) ->
        let v1 = Int64.vof_t v1
        and v2 = vof_tz_offset v2
        in Ocaml.VTuple [ v1; v2 ] in
  let bnd = ("date", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_email in
  let bnd = ("email", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
end

module Commit = struct
open Commit
let vof_t {
            tree = v_tree;
            parents = v_parents;
            author = v_author;
            committer = v_committer;
            message = v_message
          } =
  let bnds = [] in
  let arg = Ocaml.vof_string v_message in
  let bnd = ("message", arg) in
  let bnds = bnd :: bnds in
  let arg = User.vof_t v_committer in
  let bnd = ("committer", arg) in
  let bnds = bnd :: bnds in
  let arg = User.vof_t v_author in
  let bnd = ("author", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list Sha1.vof_t v_parents in
  let bnd = ("parents", arg) in
  let bnds = bnd :: bnds in
  let arg = Sha1.vof_t v_tree in
  let bnd = ("tree", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
end

module Objects = struct
open Objects
let vof_t =
  function
  | Blob v1 -> let v1 = Blob.vof_t v1 in Ocaml.VSum (("Blob", [ v1 ]))
  | Commit v1 -> let v1 = Commit.vof_t v1 in Ocaml.VSum (("Commit", [ v1 ]))
  | Tree v1 -> let v1 = Tree.vof_t v1 in Ocaml.VSum (("Tree", [ v1 ]))
end
<<constant Dump.vof_obj>>

module Index = struct
open Index
let rec
  vof_stat_info {
                  ctime = v_ctime;
                  mtime = v_mtime;
                  dev = v_dev;
                  inode = v_inode;
                  mode = v_mode;
                  uid = v_uid;
                  gid = v_gid;
                  size = v_size
                } =
  let bnds = [] in
  let arg = Int32.vof_t v_size in
  let bnd = ("size", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_gid in
  let bnd = ("gid", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_uid in
  let bnd = ("uid", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_mode v_mode in
  let bnd = ("mode", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_inode in
  let bnd = ("inode", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_dev in
  let bnd = ("dev", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_time v_mtime in
  let bnd = ("mtime", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_time v_ctime in
  let bnd = ("ctime", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_mode =
  function
  | Normal -> Ocaml.VSum (("Normal", []))
  | Exec -> Ocaml.VSum (("Exec", []))
  | Link -> Ocaml.VSum (("Link", []))
  | Gitlink -> Ocaml.VSum (("Gitlink", []))
and vof_time { lsb32 = v_lsb32; nsec = v_nsec } =
  let bnds = [] in
  let arg = Int32.vof_t v_nsec in
  let bnd = ("nsec", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_lsb32 in
  let bnd = ("lsb32", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  

let vof_entry { stats = v_stats; id = v_id; stage = v_stage; name = v_name }
              =
  let bnds = [] in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_int v_stage in
  let bnd = ("stage", arg) in
  let bnds = bnd :: bnds in
  let arg = Sha1.vof_t v_id in
  let bnd = ("id", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_stat_info v_stats in
  let bnd = ("stats", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let vof_t v = Ocaml.vof_list vof_entry v
end
<<constant Dump.vof_index>>
@


\subsection*{[[version_control/dump.mli]]}

<<signature Dump.vof_obj>>=
val vof_obj: Objects.t -> Ocaml.v
@

<<signature Dump.vof_index>>=
val vof_index: Index.t -> Ocaml.v
@


%-------------------------------------------------------------

<<version_control/dump.mli>>=

<<signature Dump.vof_obj>>
<<signature Dump.vof_index>>
@


\subsection*{[[version_control/hexsha.ml]]}

<<type Hexsha.t>>=
type t = string
@

<<function Hexsha.is_hexsha>>=
let is_hexsha x =
 String.length x = 40
 (* less: could also check every chars is between 0 and F,
  * or just call to_sha and catch if any exn.
  *)
@

<<function Hexsha.of_string_fast>>=
let of_string_fast s =
  let len = String.length s in
  let buf = Bytes.create (len * 2) in
  for i = 0 to len - 1 do
    Bytes.unsafe_set buf (i * 2)
      (String.unsafe_get hexa1 (Char.code (String.unsafe_get s i)));
    Bytes.unsafe_set buf (succ (i * 2))
      (String.unsafe_get hexa2 (Char.code (String.unsafe_get s i)));
  done;
  (*pad:`Hex*) buf
@

<<function Hexsha.invalid_arg>>=
let invalid_arg fmt =
  Printf.ksprintf (fun str -> raise (Invalid_argument str)) fmt
@

<<function Hexsha.to_char>>=
let to_char x y =
  let code c = match c with
    | '0'..'9' -> Char.code c - 48 (* Char.code '0' *)
    | 'A'..'F' -> Char.code c - 55 (* Char.code 'A' + 10 *)
    | 'a'..'f' -> Char.code c - 87 (* Char.code 'a' + 10 *)
    | _ -> invalid_arg "Hex.to_char: %d is an invalid char" (Char.code c)
  in
  Char.chr (code x lsl 4 + code y)
@

<<function Hexsha.to_helper>>=
let to_helper ~empty_return ~create ~set ((*`Hex*) s) =
  if s = "" then empty_return
  else
    let n = String.length s in
    let buf = create (n/2) in
    let rec aux i j =
      if i >= n then ()
      else if j >= n then invalid_arg "hex conversion: invalid hex string"
      else (
        set buf (i/2) (to_char s.[i] s.[j]);
        aux (j+1) (j+2)
      )
    in
    aux 0 1;
    buf
@

<<function Hexsha.to_string>>=
let to_string hex =
  to_helper ~empty_return:"" ~create:Bytes.create ~set:Bytes.set hex
@

<<function Hexsha.of_sha>>=
let of_sha x =
  assert (Sha1.is_sha x);
  of_string_fast x
@

<<function Hexsha.to_sha>>=
let to_sha x =
  assert (is_hexsha x);
  to_string x
@

<<function Hexsha.read>>=
let read ch =
  let s = IO.really_nread ch 40 in
  assert (is_hexsha s);
  s
@

<<function Hexsha.write>>=
let write ch x =
  IO.nwrite ch x
@


%-------------------------------------------------------------

<<version_control/hexsha.ml>>=
(*
 * Copyright (c) 2015 Trevor Summers Smith <trevorsummerssmith@gmail.com>
 * Copyright (c) 2014 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * Most of the code below comes from src: https://github.com/mirage/ocaml-hex
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Hexsha.t>>

<<function Hexsha.is_hexsha>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

(* start of copy-pasted code from ocaml-hex *)

let hexa = "0123456789abcdef"
and hexa1 =
  "0000000000000000111111111111111122222222222222223333333333333333\
   4444444444444444555555555555555566666666666666667777777777777777\
   88888888888888889999999999999999aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb\
   ccccccccccccccccddddddddddddddddeeeeeeeeeeeeeeeeffffffffffffffff"
and hexa2 =
  "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

<<function Hexsha.of_string_fast>>


<<function Hexsha.invalid_arg>>

<<function Hexsha.to_char>>

<<function Hexsha.to_helper>>

<<function Hexsha.to_string>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Hexsha.of_sha>>

<<function Hexsha.to_sha>>

<<function Hexsha.read>>
<<function Hexsha.write>>
@


\subsection*{[[version_control/hexsha.mli]]}

<<type Hexsha.t (version_control/hexsha.mli)>>=
(* a 40 characters string, e.g. "d670460b4b4aece5915caf5c68d12f560a9fe3e4" *)
type t = string
@

<<signature Hexsha.of_sha>>=
val of_sha: Sha1.t -> t
@

<<signature Hexsha.to_sha>>=
val to_sha: t -> Sha1.t
@

<<signature Hexsha.read>>=
val read: IO.input -> t
@

<<signature Hexsha.write>>=
val write: 'a IO.output -> t -> unit
@

<<signature Hexsha.is_hexsha>>=
val is_hexsha: t -> bool
@


%-------------------------------------------------------------

<<version_control/hexsha.mli>>=
<<type Hexsha.t (version_control/hexsha.mli)>>

<<signature Hexsha.of_sha>>
<<signature Hexsha.to_sha>>

<<signature Hexsha.read>>
<<signature Hexsha.write>>

<<signature Hexsha.is_hexsha>>

@


\subsection*{[[version_control/index.ml]]}

<<type Index.stat_info>>=
type stat_info = {
  mode : mode;
  ctime: time;
  mtime: time;
  dev  : Int32.t;
  inode: Int32.t;
  uid  : Int32.t;
  gid  : Int32.t;
  size : Int32.t;
}
@

<<type Index.mode>>=
  and mode =
    | Normal
    | Exec
    | Link

    | Gitlink (*?? submodule? *)
@

<<type Index.time>>=
  and time = {
    lsb32: Int32.t;
    nsec : Int32.t;
  }
@

<<type Index.entry>>=
(** The type for a Git index entry. *)
type entry = {
  (* relative path *)
  name  : Common.filename;
  id    : Blob.hash;
  stats : stat_info;
  stage : int; (*?? *)
}
@

<<type Index.t>>=
(* the entries are sorted (see compare_entries below) *)
type t = entry list
@

<<constant Index.empty>>=
let empty = []
@

<<function Index.stat_info_of_lstats>>=
let stat_info_of_lstats stats = 
    { ctime = { lsb32 = Int32.of_float stats.Unix.st_ctime; nsec = 0l };
      mtime = { lsb32 = Int32.of_float stats.Unix.st_mtime; nsec = 0l };
      dev = Int32.of_int stats.Unix.st_dev;
      inode = Int32.of_int stats.Unix.st_ino;
      mode = 
        (match stats.Unix.st_kind, stats.Unix.st_perm with
        | Unix.S_REG, p -> 
          if p land 0o100 = 0o100 
          then Exec 
          else Normal
        | Unix.S_LNK, _ -> Link
        | _ -> failwith (spf "unsupported file type")
        );
      uid = Int32.of_int stats.Unix.st_uid;
      gid = Int32.of_int stats.Unix.st_gid;
      size = Int32.of_int stats.Unix.st_size;
    }
@

<<function Index.mk_entry>>=
let mk_entry relpath sha stats =
  { stats = stat_info_of_lstats stats;
    id = sha;
    stage = 0; (* TODO? *)
    name = relpath
  }
@

<<function Index.perm_of_mode>>=
let perm_of_mode mode = 
  match mode with
  | Normal -> Tree.Normal
  | Exec -> Tree.Exec
  | Link -> Tree.Link
  | Gitlink -> Tree.Commit (* sure? *)
@

<<function Index.mode_of_perm>>=
let mode_of_perm perm = 
  match perm with
  | Tree.Normal -> Normal
  | Tree.Exec -> Exec
  | Tree.Link -> Link
  | Tree.Commit -> Gitlink
  | Tree.Dir -> failwith "index entry does not support Tree.dir perm"
@

<<function Index.remove_entry>>=
let rec remove_entry idx name =
  match idx with
  | [] -> failwith (spf "The file %s is not in the index" name)
  | x::xs ->
    (match name <=> x.name with
    | Sup -> x::(remove_entry xs name)
    | Equal -> xs
    (* the entries are sorted *)
    | Inf -> failwith (spf "The file %s is not in the index" name)
    )
@

<<function Index.add_entry>>=
let rec add_entry idx entry =
  match idx with
  | [] -> [entry]
  | x::xs ->
    (match entry.name <=> x.name with
    | Sup -> x::(add_entry xs entry)
    (* replace old entry is ok *)
    | Equal -> entry::xs
    (* the entries are sorted *)
    | Inf -> entry::x::xs
    )
@

<<type Index.dir>>=
type dir = dir_entry list ref
@

<<type Index.dir_entry>>=
  and dir_entry =
    | Subdir of string (* base *)
    | File of string (* base *) * entry
@

<<type Index.dirs>>=
type dirs = (string (* full relpath of dir *), dir) Hashtbl.t
@

<<function Index.add_dir>>=
(* the code in this section derives from dulwich *)

let rec add_dir dirs dirpath =
  try 
    Hashtbl.find dirs dirpath
  with Not_found ->
    let newdir = ref [] in
    Hashtbl.add dirs dirpath newdir;
    let (parent, base) = 
      Filename.dirname dirpath, Filename.basename dirpath in
    (* !recursive call! should stop at some point because "." is in dirs *)
    let dir = add_dir dirs parent in
    dir := Subdir (base)::!dir;
    newdir
@

<<function Index.build_trees>>=
let rec build_trees dirs dirpath add_tree_obj =
  let dir = Hashtbl.find dirs dirpath in
  (* entries of a Tree.t must be sorted, but entries of an index too,
   * so we can assume add_dir was called in sorted order
   *)
  let xs = List.rev !dir in
  let tree = 
    xs |> List.map (function
      | File (base, entry) ->
        {Tree.
         name = base; 
         node = entry.id; 
         perm = perm_of_mode entry.stats.mode;
        }
      | Subdir base ->
        let sha = 
          build_trees dirs (Filename.concat dirpath base) add_tree_obj in
        {Tree. perm = Tree.Dir; name = base; node = sha }
    )
  in
  add_tree_obj tree
@

<<function Index.tree_of_index>>=
let tree_of_index idx add_tree_obj =
  let (dirs: dirs) = Hashtbl.create 11 in
  Hashtbl.add dirs "." (ref []);
  (* populate dirs *)
  idx |> List.iter (fun entry ->
    let relpath = entry.name in
    let (dir, base) = Filename.dirname relpath, Filename.basename relpath in
    let dir = add_dir dirs dir in
    dir := (File (base, entry))::!dir
  );
  (* build trees *)
  build_trees dirs "." add_tree_obj
@

<<function Index.read_time>>=
let read_time ch =
  (* less: unsigned actually *)
  let lsb32 = IO.BigEndian.read_real_i32 ch in
  let nsec = IO.BigEndian.read_real_i32 ch in
  { lsb32; nsec }
@

<<function Index.write_time>>=
let write_time ch time =
  IO.BigEndian.write_real_i32 ch time.lsb32;
  IO.BigEndian.write_real_i32 ch time.nsec
@

<<function Index.read_mode>>=
let read_mode ch =
  let _zero = IO.BigEndian.read_ui16 ch in
  let n = IO.BigEndian.read_ui16 ch in
  match n lsr 12 with
  | 0b1010 -> Link
  | 0b1110 -> Gitlink
  | 0b1000 ->
    (match n land 0x1FF with
    | 0o755 -> Exec
    | 0o644 -> Normal
    | d     -> failwith (spf "Index.mode: invalid permission (%d)" d)
    )
  | m -> failwith (spf "Index.mode: invalid (%d)" m)
@

<<function Index.write_mode>>=
let write_mode ch mode =
  IO.BigEndian.write_ui16 ch 0;
  let n = 
    match mode with
    | Exec    -> 0b1000__000__111_101_101
    | Normal  -> 0b1000__000__110_100_100
    | Link    -> 0b1010__000__000_000_000
    | Gitlink -> 0b1110__000__000_000_000 
  in
  IO.BigEndian.write_ui16 ch n
@

<<function Index.read_stat_info>>=
let read_stat_info ch =
  let ctime = read_time ch in
  let mtime = read_time ch in
  (* less: unsigned again *)
  let dev = IO.BigEndian.read_real_i32 ch in
  let inode = IO.BigEndian.read_real_i32 ch in
  let mode = read_mode ch in
  let uid = IO.BigEndian.read_real_i32 ch in
  let gid = IO.BigEndian.read_real_i32 ch in
  let size = IO.BigEndian.read_real_i32 ch in
  { mtime; ctime; dev; inode; mode; uid; gid; size }
@

<<function Index.write_stat_info>>=
let write_stat_info ch stats =
  write_time ch stats.ctime;
  write_time ch stats.mtime;
  IO.BigEndian.write_real_i32 ch stats.dev;
  IO.BigEndian.write_real_i32 ch stats.inode;
  write_mode ch stats.mode;
  IO.BigEndian.write_real_i32 ch stats.uid;
  IO.BigEndian.write_real_i32 ch stats.gid;
  IO.BigEndian.write_real_i32 ch stats.size;
  ()
@

<<function Index.read_entry>>=
let read_entry ch =
  let stats = read_stat_info ch in
  let id = Sha1.read ch in
  let stage, len =
    let i = IO.BigEndian.read_ui16 ch in
    (i land 0x3000) lsr 12,
    (i land 0x0FFF)
  in
  let name = IO.really_nread_string ch len in
  let c = IO.read ch in
  if c <> '\000'
  then failwith "Index.read_entry: expecting null char after name";
  let len = 63 + String.length name in
  let pad = 
    match len mod 8 with
    | 0 -> 0
    | n -> 8-n 
  in
  let _zeros = IO.really_nread ch pad in
  (* less: assert zeros *)
  { stats; id; stage; name }
@

<<function Index.write_entry>>=
let write_entry ch e =
  write_stat_info ch e.stats;
  Sha1.write ch e.id;
  let flags = (e.stage lsl 12 + String.length e.name) land 0x3FFF in
  IO.BigEndian.write_ui16 ch flags;
  IO.nwrite ch e.name;
  let len = 63 + String.length e.name in
  let pad = 
    match len mod 8 with
    | 0 -> 0
    | n -> 8-n 
  in
  IO.nwrite ch (Bytes.make pad '\000');
  IO.write ch '\000'
@

<<function Index.read_entries>>=
let read_entries ch =
  let n = IO.BigEndian.read_i32 ch in
  let rec loop acc n =
    if n = 0 
    then List.rev acc
    else
      let entry = read_entry ch in
      loop (entry :: acc) (n - 1) in
  loop [] n
@

<<function Index.read>>=
let read ch =
  let header = IO.really_nread_string ch 4 in
  if header <> "DIRC"
  then failwith "Index.read: expecting DIRC header";
  let version = IO.BigEndian.read_i32 ch in
  if version <> 2
  then failwith "Index.read: expecting version 2";
  let entries = read_entries ch in
  (* todo: read_extensions but need know when reach last 20 bytes *)
  (* todo: check hash correctly stored in last 20 bytes *)
  entries
@

<<function Index.write>>=
let write idx ch =
  let n = List.length idx in
  let body =
    IO.output_bytes () |> IO_.with_close_out (fun ch ->
      IO.nwrite ch "DIRC";
      IO.BigEndian.write_i32 ch 2;
      IO.BigEndian.write_i32 ch n;
      idx |> List.iter (write_entry ch)
    )
  in
  let sha = Sha1.sha1 body in
  IO.nwrite ch body;
  Sha1.write ch sha
@


%-------------------------------------------------------------

<<version_control/index.ml>>=
(*
 * Copyright (c) 2013-2017 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 * in index.ml and git_unix.ml
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(** The type for file-system stat information. *)
<<type Index.stat_info>>
<<type Index.mode>>
  (** The type for a time represented by its [lsb32] and [nsec] parts. *)
<<type Index.time>>
    
<<type Index.entry>>

(* less: extensions *)

<<type Index.t>>

<<constant Index.empty>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*
(* Index entries are sorted by the byte sequence that comprises the
   entry name; with a secondary comparison of the stage bits from the
   <ENTRY_FLAGS> if the entry name byte sequences are identical. *)
let compare_entries e1 e2 =
  match String.compare e1.name e2.name with
  | 0 -> Hash.Blob.compare e2.id e1.id
  | i -> i
*)

<<function Index.stat_info_of_lstats>>

<<function Index.mk_entry>>

<<function Index.perm_of_mode>>

<<function Index.mode_of_perm>>


(*****************************************************************************)
(* Add/Del *)
(*****************************************************************************)

<<function Index.remove_entry>>

<<function Index.add_entry>>

(*****************************************************************************)
(* tree of index *)
(*****************************************************************************)

<<type Index.dir>>
<<type Index.dir_entry>>
<<type Index.dirs>>

<<function Index.add_dir>>

<<function Index.build_trees>>


<<function Index.tree_of_index>>

(*****************************************************************************)
(* index of tree *)
(*****************************************************************************)
(* See repository.set_worktree_and_index_to_tree() *)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Index.read_time>>

<<function Index.write_time>>

<<function Index.read_mode>>

<<function Index.write_mode>>

<<function Index.read_stat_info>>

<<function Index.write_stat_info>>
 

<<function Index.read_entry>>

<<function Index.write_entry>>




<<function Index.read_entries>>

<<function Index.read>>


<<function Index.write>>
@


\subsection*{[[version_control/index.mli]]}

<<type Index.stat_info (version_control/index.mli)>>=
type stat_info = {
  mode : mode;
  ctime: time;
  mtime: time;
  dev  : Int32.t;
  inode: Int32.t;
  uid  : Int32.t;
  gid  : Int32.t;
  size : Int32.t;
}
@

<<type Index.mode (version_control/index.mli)>>=
  and mode =
    (* no directory here *)
    | Normal
    | Exec
    | Link
    | Gitlink
  (** The type for a time represented by its [lsb32] and [nsec] parts. *)
@

<<type Index.time (version_control/index.mli)>>=
  and time = {
    lsb32: Int32.t;
    nsec : Int32.t;
  }
@

<<type Index.entry (version_control/index.mli)>>=
(** The type for a Git index entry. *)
type entry = {
  (* relative path *)
  name  : Common.filename;
  id    : Blob.hash;
  stats : stat_info;
  stage : int;
}
@

<<type Index.t (version_control/index.mli)>>=
(* the entries are sorted *)
type t = entry list
@

<<signature Index.empty>>=
val empty: t
@

<<signature Index.mk_entry>>=
val mk_entry: Common.filename -> Sha1.t -> Unix.stats -> entry
@

<<signature Index.stat_info_of_lstats>>=
val stat_info_of_lstats: Unix.stats -> stat_info
@

<<signature Index.mode_of_perm>>=
val mode_of_perm: Tree.perm -> mode
@

<<signature Index.perm_of_mode>>=
val perm_of_mode: mode -> Tree.perm
@

<<signature Index.read>>=
val read: IO.input -> t
(* will write the header, and sha checksum at the end *)
@

<<signature Index.write>>=
(* will write the header, and sha checksum at the end *)
val write: t -> unit IO.output -> unit
@

<<signature Index.remove_entry>>=
val remove_entry: t -> Common.filename -> t
@

<<signature Index.add_entry>>=
val add_entry: t -> entry -> t
@

<<signature Index.tree_of_index>>=
val tree_of_index: t -> (* add_obj *)(Tree.t -> Tree.hash) -> Tree.hash
(* todo: index_of_tree *)
@


%-------------------------------------------------------------

<<version_control/index.mli>>=

(** The type for file-system stat information. *)
<<type Index.stat_info (version_control/index.mli)>>
<<type Index.mode (version_control/index.mli)>>
<<type Index.time (version_control/index.mli)>>
    
<<type Index.entry (version_control/index.mli)>>

<<type Index.t (version_control/index.mli)>>

<<signature Index.empty>>
<<signature Index.mk_entry>>

<<signature Index.stat_info_of_lstats>>
<<signature Index.mode_of_perm>>
<<signature Index.perm_of_mode>>

<<signature Index.read>>
<<signature Index.write>>

<<signature Index.remove_entry>>
<<signature Index.add_entry>>

<<signature Index.tree_of_index>>
@


\subsection*{[[version_control/main.ml]]}

<<constant Main.commands>>=
let commands = List.flatten [
  Cmds.main_commands;
  Cmds.extra_commands;
  [Cmd_help.cmd];
]
@

<<constant Main.hcommands>>=
let hcommands = 
  commands |> List.map (fun cmd -> cmd.Cmd.name, cmd) |> Hashtbl_.of_list
@

<<function Main.usage>>=
let usage () =
  spf "usage: ogit <%s> [options]"
    (String.concat "|" (commands |> List.map (fun cmd -> cmd.Cmd.name)))
@

<<function Main.main>>=
let main () =
  if Array.length Sys.argv < 2
  then begin
    pr2 (usage ());
    exit 1;
  end
  else begin
    let cmd = 
      try 
        Hashtbl.find hcommands Sys.argv.(1) 
      with Not_found ->
        pr2 (usage ());
        exit 1
    in
    let argv = Array.sub Sys.argv 1 (Array.length Sys.argv -1) in
    let usage_msg_cmd = spf "usage: %s %s%s"
      (Filename.basename Sys.argv.(0))
      cmd.Cmd.name
      cmd.Cmd.help
    in
    let remaining_args = ref [] in
    (try 
     (* todo: look if --help and factorize treatment of usage for subcmds *)
       Arg.parse_argv argv (Arg.align cmd.Cmd.options) 
         (fun arg -> Common.push arg remaining_args) usage_msg_cmd;
     with Arg.Bad str | Arg.Help str->  
       prerr_string str;
       exit 1
    );
    (* finally! *)
    try 
      cmd.Cmd.f (List.rev !remaining_args)
    with 
      | Cmd.ShowUsage ->
        Arg.usage (Arg.align cmd.Cmd.options) usage_msg_cmd;
        exit 1
  end
@

<<toplevel Main._1>>=
let _ =
  main ()
@


%-------------------------------------------------------------

<<version_control/main.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of git, a distributed version control system.
 *
 * Some of the code of ogit derives from dulwich (a clone of git in Python)
 * and ocaml-git (a clone of git in OCaml).
 *
 * Main limitations compared to git/dulwich/ocaml-git:
 *  -??
 * 
 * todo:
 *  - a simplified version where just Marshall data instead of using
 *    the specific git format. Save many LOC?
 *  - ??
 * 
 * The code of ogit uses code from 
 *  - ocaml-git
 *  - ocaml-hex
 *  - camlzip
 *  - extlib
 *  - uuidm
 * 
 * ogit uses lots of code from ocaml-git. However, ogit is simpler because
 * it does not use fancy features of OCaml or fancy libraries:
 *  - no functor, include, module types, polymorphic variants, keyword args,
 *    or excessive nested modules. KISS.
 *  - no functorized Set and Map so no need for hash(), compare(), and equal()
 *    boilerplate functions everywhere
 *  - hardcoded use of SHA1, so no need functors taking Git.DIGEST and HashIO
 *  - no support for mirage, so no need to parametrize many things,
 *    no need Fs module, no need lwt
 *  - no disk vs mem, just disk, so again need less functors
 *  - hardcoded use of zlib so no need functors taking inflate signature
 *  - no support for filename requiring special escapes
 *  - no use of Cstruct or Mstruct or Bigarray (simply use IO.ml and Bytes)
 *  - no logs
 *  - no fmt (use ocamldebug or ocamltarzan dumpers)
 *  - no sexplib
 * 
 * good stuff I took from ocaml-git:
 *  - dotgit (more readable than commondir in dulwich)
 *  - '/' operator (more readable than all those os.path.join in dulwich)
 *  - Hash.Tree.t, Hash.Commit.t, Hash.Blob.t more precise hash types
 *    (but they are not statically checked in ogit)
 *  - TODO GRI (generalization of URI)
 * good stuff I wish I could take from dulwich:
 *  - hashtbl [] overloading, so can do r.refs["refs/tags/"+tag] = obj.id
 *    (thx to __setitem__ and __getitem__)
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<constant Main.commands>>

<<constant Main.hcommands>>

<<function Main.usage>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Main.main>>
        
<<toplevel Main._1>>
@


\subsection*{[[version_control/merge.ml]]}


%-------------------------------------------------------------

<<version_control/merge.ml>>=
(*
https://github.com/schuhschuh/cmake-basis/blob/master/src/utilities/python/diff3.py
*)
@


\subsection*{[[version_control/objects.ml]]}

<<type Objects.t>>=
type t = 
  | Blob   of Blob.t
  | Commit of Commit.t
  | Tree   of Tree.t
(*  | Tag of Tag.t *)
@

<<function Objects.read>>=
let read ch =
  let str = IO_.read_string_and_stop_char ch ' ' in
  let n = IO_.read_int_and_nullbyte ch in
  let raw = IO.really_nread ch n in
  (* less: assert finished ch? use IO.pos_in? *)
  let ch2 = IO.input_bytes raw in
  (* less: just reuse ch so avoid use of intermediate strings? *)
  match str with
  | "blob"   -> Blob   (Blob.read ch2)
  | "commit" -> Commit (Commit.read ch2)
  | "tree"   -> Tree   (Tree.read ch2)
  (* "tag" -> Tag (Tag.read raw) *)
  (* less: assert finished ch2? *)
  | str -> failwith (spf "Objects.read: invalid header: %s" str)
@

<<function Objects.write>>=
let write obj ch =
  let body = 
    IO.output_bytes () |> IO_.with_close_out (fun ch ->
      match obj with
      | Blob x   -> Blob.write x ch
      | Commit x -> Commit.write x ch
      | Tree x   -> Tree.write x ch
    )
  in
  let header = 
    spf "%s %d\000"
      (match obj with
      | Blob _   -> "blob"
      | Commit _ -> "commit"
      | Tree  _  ->  "tree"
      ) 
      (Bytes.length body)
  in
  IO.nwrite ch header;
  IO.nwrite ch body
@


%-------------------------------------------------------------

<<version_control/objects.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Objects.t>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Objects.read>>

<<function Objects.write>>
@


\subsection*{[[version_control/objects.mli]]}

<<type Objects.t (version_control/objects.mli)>>=
type t = 
  | Blob   of Blob.t
  | Commit of Commit.t
  | Tree   of Tree.t
@

<<signature Objects.read>>=
(* assumes input is in decompressed form *)
val read: IO.input -> t
@

<<signature Objects.write>>=
(* will not compress, will return unserialized content for sha1 computation *)
val write: t -> bytes IO.output -> unit
@


%-------------------------------------------------------------

<<version_control/objects.mli>>=

<<type Objects.t (version_control/objects.mli)>>

<<signature Objects.read>>

<<signature Objects.write>>
@


\subsection*{[[version_control/refs.ml]]}

<<type Refs.refname>>=
(* should always start with "refs/", see is_valid_refname later *)
type refname = string (* e.g. "refs/heads/master" *)
@

<<type Refs.t>>=
type t =
  | Head
  | Ref of refname
@

<<type Refs.ref_content>>=
type ref_content =
  (* the final value when follow all the pointers *)
  | Hash of Commit.hash
  (* pointer (may contain sha1 or another pointer again) *)
  | OtherRef of refname
@

<<constant Refs.default_head_content>>=
let default_head_content = 
  OtherRef "refs/heads/master"
@

<<function Refs.is_valid_refname>>=
let is_valid_refname str =
  str =~ "^refs/"
  (* todo: git-check-ref-format *)
@

<<function Refs.string_of_ref>>=
let string_of_ref = function
  | Head -> "HEAD"
  | Ref x -> x
@

<<function Refs.read>>=
let read ch =
  let str = IO.read_all ch in
  (* less: check finish by newline? *)
  match str with
  | _ when str =~ "^ref: \\(.*\\)$" -> OtherRef (Regexp_.matched1 str)
  | _ -> Hash (str |> IO.input_string |> Hexsha.read |> Hexsha.to_sha)
@
%$

<<function Refs.write>>=
let write content ch =
  match content with
  | Hash h -> 
    IO.nwrite_string ch (Hexsha.of_sha h ^ "\n")
  | OtherRef name ->
    IO.nwrite_string ch ("ref: " ^ name ^ "\n")
@


%-------------------------------------------------------------

<<version_control/refs.ml>>=
open Common

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Refs.refname>>

<<type Refs.t>>

<<type Refs.ref_content>>

<<constant Refs.default_head_content>>

<<function Refs.is_valid_refname>>

(*****************************************************************************)
(* Dumper *)
(*****************************************************************************)

<<function Refs.string_of_ref>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Refs.read>>

<<function Refs.write>>
@


\subsection*{[[version_control/refs.mli]]}

<<type Refs.refname (version_control/refs.mli)>>=
type refname = string (* e.g. "refs/heads/master" *)
@

<<type Refs.t (version_control/refs.mli)>>=
type t =
  | Head
  | Ref of refname
@

<<type Refs.ref_content (version_control/refs.mli)>>=
type ref_content =
  | Hash of Commit.hash
  (* pointer (may contain sha1 or another pointer again) *)
  | OtherRef of refname
@

<<signature Refs.default_head_content>>=
val default_head_content: ref_content
@

<<signature Refs.is_valid_refname>>=
val is_valid_refname: refname -> bool
@

<<signature Refs.read>>=
val read: IO.input -> ref_content
@

<<signature Refs.write>>=
val write: ref_content -> unit IO.output -> unit
@

<<signature Refs.string_of_ref>>=
val string_of_ref: t -> string
@


%-------------------------------------------------------------

<<version_control/refs.mli>>=

<<type Refs.refname (version_control/refs.mli)>>

<<type Refs.t (version_control/refs.mli)>>

<<type Refs.ref_content (version_control/refs.mli)>>

<<signature Refs.default_head_content>>

<<signature Refs.is_valid_refname>>

<<signature Refs.read>>
<<signature Refs.write>>

<<signature Refs.string_of_ref>>
@


\subsection*{[[version_control/repository.ml]]}

<<type Repository.t>>=
type t = {
  (* less: on bare repo, this could be None *)
  worktree: Common.filename;
  (* less: on bare repo this could be the toplevel dir *)
  dotgit: Common.filename;

  mutable index: Index.t;

  (* less: compression level config field? *)
}
@

<<constant Repository.TODOOPERATOR>>=
let (/) = Filename.concat
@

<<constant Repository.dirperm>>=
(* rwxr-x--- *)
let dirperm = 0o750
@

<<type Repository.objectish>>=
(* todo: handle ^ like HEAD^, so need more complex objectish parser *)
type objectish =
  | ObjByRef of Refs.t
  | ObjByHex of Hexsha.t
  (* ObjByTag 
     ObjByBranch
     ObjByShortHex
  *)
@

<<function Repository.hexsha_to_filename>>=
(* for loose objects *)
let hexsha_to_filename r hexsha =
  let dir = String.sub hexsha 0 2 in
  let file = String.sub hexsha 2 (String.length hexsha - 2) in
  r.dotgit / "objects" / dir / file
@

<<function Repository.hexsha_to_dirname>>=
let hexsha_to_dirname r hexsha =
  let dir = String.sub hexsha 0 2 in
  r.dotgit / "objects" / dir
@

<<function Repository.ref_to_filename>>=
let ref_to_filename r aref =
  match aref with
  | Refs.Head -> r.dotgit / "HEAD"
  (* less: win32: should actually replace '/' in name *)
  | Refs.Ref name -> r.dotgit / name
@

<<function Repository.index_to_filename>>=
let index_to_filename r =
  r.dotgit / "index"
@

<<function Repository.with_file_out_with_lock>>=
(* todo: see code of _Gitfile.__init__ O_EXCL ... *)
let with_file_out_with_lock f file =
  (* todo: create .lock file and then rename *)
  Common.with_file_out f file
@

<<function Repository.with_opendir>>=
(* less: use finalize *)
let with_opendir f dir =
  let handle = Unix.opendir dir in
  let res = f handle in
  Unix.closedir handle;
  res
@

<<function Repository.walk_dir>>=
(* inspired from os.path.walk in Python *)
let rec walk_dir f dir =
  dir |> with_opendir (fun handle ->
    let dirs = ref [] in
    let files = ref [] in
    try 
      while true do
        let s = Unix.readdir handle in
        (* git specific here *)
        if s <> "." && s <> ".." && s <> ".git" then begin
          let path = Filename.concat dir s in
          let st = Unix.lstat path in
          (match st.Unix.st_kind with
          | Unix.S_DIR -> Common.push s dirs
          | _ -> Common.push s files
          )
        end
      done
    with End_of_file ->
      let dirs = List.rev !dirs in
      let files = List.rev !files in
      f dir dirs files;
      dirs |> List.iter (fun s ->
        walk_dir f (Filename.concat dir s)
      )
  )
@

<<function Repository.read_ref>>=
let read_ref r aref =
  (* less: packed refs *)
  let file = ref_to_filename r aref in
  let ch = open_in file in
  let input = IO.input_channel ch in
  Refs.read input
@

<<function Repository.follow_ref>>=
let rec follow_ref r aref =
  (* less: check if depth > 5? *)
  try (
  let content = read_ref r aref in
  match content with
  | Refs.Hash sha -> [aref], Some sha
  | Refs.OtherRef refname ->
    let (xs, shaopt) = follow_ref r (Refs.Ref refname) in
    aref::xs, shaopt
  ) 
  (* inexistent ref file, can happen at the beginning when have .git/HEAD
   * pointing to an inexistent .git/refs/heads/master
   *)
  with Sys_error _ (* no such file or directory *) -> [aref], None
@

<<function Repository.follow_ref_some>>=
let follow_ref_some r aref =
  match follow_ref r aref |> snd with
  | Some sha -> sha
  | None -> failwith (spf "could not follow %s" (Refs.string_of_ref aref))
@

<<function Repository.add_ref_if_new>>=
let add_ref_if_new r aref refval =
  let (refs, shaopt) = follow_ref r aref in
  if shaopt <> None
  then false
  else begin
    let lastref = List.hd (List.rev refs) in
    let file = ref_to_filename r lastref in
    (* todo: ensure dirname exists *)
    file |> with_file_out_with_lock (fun ch ->
      (* todo: check file does not exist aleady *)
      ch |> IO.output_channel |> IO_.with_close_out (Refs.write refval)
    );
    true
  end
@

<<function Repository.del_ref>>=
let del_ref r aref =
  let file = ref_to_filename r aref in
  Unix.unlink file
@

<<function Repository.set_ref_if_same_old>>=
let set_ref_if_same_old r aref oldh newh =
  let (refs, _) = follow_ref r aref in
  let lastref = List.hd (List.rev refs) in
  let file = ref_to_filename r lastref in
  try 
    file |> with_file_out_with_lock (fun ch ->
      (* TODO generate some IO.No_more_input 
      let prev = read_ref r lastref in
      if prev <> (Refs.Hash oldh)
      then raise Not_found
      else 
      *)
        ch |> IO.output_channel |> IO_.with_close_out 
            (Refs.write (Refs.Hash newh))
    );
    true
  with Not_found -> false
@

<<function Repository.set_ref>>=
let set_ref r aref newh =
  let (refs, _) = follow_ref r aref in
  let lastref = List.hd (List.rev refs) in
  let file = ref_to_filename r lastref in
  file |> with_file_out_with_lock (fun ch ->
    ch |> IO.output_channel |> IO_.with_close_out 
        (Refs.write (Refs.Hash newh))
  )
@

<<function Repository.write_ref>>=
(* low-level *)
let write_ref r aref content =
  let file = ref_to_filename r aref in
  file |> with_file_out_with_lock (fun ch ->
    ch |> IO.output_channel |> IO_.with_close_out (Refs.write content))
@

<<function Repository.all_refs>>=
let all_refs r =
  let root = r.dotgit ^ "/" in
  let rootlen = String.length root in
  let res = ref [] in
  (root / "refs") |> walk_dir (fun path dirs files ->
    files |> List.iter (fun file ->
      (* less: replace os.path.sep *)
      let dir = String.sub path rootlen (String.length path - rootlen) in
      let refname = dir / file in
      Common.push refname res
    );
   );
  List.rev !res
@

<<function Repository.read_obj>>=
let read_obj r h =
  (* todo: look for packed obj *)
  let path = h |> Hexsha.of_sha |> hexsha_to_filename r in
  path |> Common.with_file_in (fun ch ->
    (* less: check read everything from channel? *)
    (* todo: check if sha consistent? *)
    ch |> IO.input_channel |> Compression.decompress |> Objects.read
  )
@

<<function Repository.read_commit>>=
let read_commit r h =
  match read_obj r h with
  | Objects.Commit x -> x
  | _ -> failwith "read_commit: was expecting a commit"
@

<<function Repository.read_tree>>=
let read_tree r h =
  match read_obj r h with
  | Objects.Tree x -> x
  | _ -> failwith "read_commit: was expecting a tree"
@

<<function Repository.read_blob>>=
let read_blob r h =
  match read_obj r h with
  | Objects.Blob x -> x
  | _ -> failwith "read_commit: was expecting a blob"
@

<<function Repository.read_objectish>>=
let read_objectish r objectish =
  match objectish with
  | ObjByRef aref -> 
    (match follow_ref r aref |> snd with
    | None -> failwith (spf "could not resolve %s" (Refs.string_of_ref aref))
    | Some sha -> 
      read_obj r sha
    )
  | ObjByHex hexsha ->
    let sha = Hexsha.to_sha hexsha in
    read_obj r sha
@

<<function Repository.add_obj>>=
let add_obj r obj =
  let bytes = 
    IO.output_bytes () |> IO_.with_close_out (Objects.write obj) in
  let sha = Sha1.sha1 bytes in
  let hexsha = Hexsha.of_sha sha in
  let dir = hexsha_to_dirname r hexsha in
  if not (Sys.file_exists dir)
  then Unix.mkdir dir dirperm;
  let file = hexsha_to_filename r hexsha in
  if (Sys.file_exists file)
  then sha (* deduplication! nothing to write, can share objects *)
  else begin
    file |> with_file_out_with_lock (fun ch ->
      let ic = IO.input_bytes bytes in
      let oc = IO.output_channel ch in
      Compression.compress ic oc;
      IO.close_out oc;
    );
    sha
  end
@

<<function Repository.has_obj>>=
let has_obj r h =
  let path = h |> Hexsha.of_sha |> hexsha_to_filename r in
  Sys.file_exists path
@

<<function Repository.read_index>>=
let read_index r =
  r.index
@

<<function Repository.write_index>>=
let write_index r =
  let path = index_to_filename r in
  path |> with_file_out_with_lock (fun ch ->
    ch |> IO.output_channel |> IO_.with_close_out (Index.write r.index)
  )
@

<<function Repository.content_from_path_and_unix_stat>>=
let content_from_path_and_unix_stat full_path stat =
  match stat.Unix.st_kind with
  | Unix.S_LNK ->
    Unix.readlink full_path
  | Unix.S_REG -> 
    full_path |> Common.with_file_in (fun ch ->
      ch |> IO.input_channel |> IO.read_all
    )
  | _ -> failwith (spf "Repository.add_in_index: %s kind not handled" 
                     full_path)
@

<<function Repository.add_in_index>>=
(* old: was called stage() in dulwich *)
let add_in_index r relpaths =
  assert (relpaths |> List.for_all Filename.is_relative);
  relpaths |> List.iter (fun relpath ->
    let full_path = r.worktree / relpath in
    let stat = 
      try Unix.lstat full_path 
      with Unix.Unix_error _ ->
        failwith (spf "Repository.add_in_index: %s does not exist anymore"
                    relpath)
    in
    let blob = Objects.Blob (content_from_path_and_unix_stat full_path stat) in
    let sha = add_obj r blob in
    let entry = Index.mk_entry relpath sha stat in
    r.index <- Index.add_entry r.index entry;
  );
  write_index r
@

<<function Repository.commit_index>>=
let commit_index r author committer message =
  let aref = Refs.Head in
  let tree = Index.tree_of_index r.index 
    (fun t -> add_obj r (Objects.Tree t)) 
  in
  (* todo: execute pre-commit hook *)

  (* less: Try to read commit message from .git/MERGE_MSG *)
  let message = message in
  (* todo: execute commit-msg hook *)

  let commit = { Commit. parents = []; tree; author; committer; message } in

  let ok =
    match follow_ref r aref |> snd with
    | Some old_head ->
      (* less: merge_heads from .git/MERGE_HEADS *)
      let merge_heads = [] in
      let commit = { commit with Commit.parents = old_head :: merge_heads } in
      let sha = add_obj r (Objects.Commit commit) in
      set_ref_if_same_old r aref old_head sha
    | None ->
      (* maybe first commit so refs/heads/master may not even exist yet *)
      let commit = { commit with Commit.parents = [] } in
      let sha = add_obj r (Objects.Commit commit) in
      add_ref_if_new r aref (Refs.Hash sha)
  in
  if not ok
  then failwith (spf "%s changed during commit" (Refs.string_of_ref aref));
  (* todo: execute post-commit hook *)
  ()
@

<<function Repository.build_file_from_blob>>=
let build_file_from_blob fullpath blob perm =
  let oldstat =
    try 
      Some (Unix.lstat fullpath)
    with Unix.Unix_error _ -> None
  in
  (match perm with 
  | Tree.Link -> 
    if oldstat <> None
    then Unix.unlink fullpath;
    Unix.symlink blob fullpath;
  | Tree.Normal | Tree.Exec ->
    (match oldstat with
    (* opti: if same content, no need to write anything *)
    | Some { Unix.st_size = x } when x = Bytes.length blob && 
      (fullpath |> Common.with_file_in (fun ch -> 
        (ch |> IO.input_channel |> IO.read_all ) = blob
       )) ->
      ()
    | _ ->
      fullpath |> Common.with_file_out (fun ch ->
        output_bytes ch blob
      );
      (* less: honor filemode? *)
      Unix.chmod fullpath 
        (match perm with 
        | Tree.Normal -> 0o644
        | Tree.Exec -> 0o755
        | _ -> raise (Impossible "matched before")
        )
    )
  | Tree.Dir -> raise (Impossible "dirs filtered in walk_tree iteration")
  | Tree.Commit -> failwith "submodule not yet supported"
  );
  Unix.lstat fullpath
@

<<function Repository.set_worktree_and_index_to_tree>>=
let set_worktree_and_index_to_tree r tree =
  (* todo: need lock on index? on worktree? *)
  let hcurrent = 
    r.index |> List.map (fun e -> e.Index.name, false) |> Hashtbl_.of_list in
  let new_index = ref [] in
  (* less: honor file mode from config file? *)
  tree |> Tree.walk_tree (read_tree r) "" (fun relpath entry ->
    let perm = entry.Tree.perm in
    match perm with
    | Tree.Dir -> 
      (* bugfix: need also here to mkdir; doing it below is not enough
       * when a dir has no file but only subdirs
       *)
      let fullpath = r.worktree / relpath in
      if not (Sys.file_exists fullpath)
      then Unix.mkdir fullpath dirperm;
    | Tree.Normal | Tree.Exec | Tree.Link ->
      (* less: validate_path? *)
      let fullpath = r.worktree / relpath in
      if not (Sys.file_exists (Filename.dirname fullpath))
      then Unix.mkdir (Filename.dirname fullpath) dirperm;
      let sha = entry.Tree.node in
      let blob = read_blob r sha in
      let stat = build_file_from_blob fullpath blob perm in
      Hashtbl.replace hcurrent relpath true;
      Common.push (Index.mk_entry relpath sha stat) new_index;
    | Tree.Commit -> failwith "submodule not yet supported"
  );
  let index = List.rev !new_index in
  r.index <- index;
  write_index r;
  hcurrent |> Hashtbl.iter (fun file used ->
    if not used
    then 
      (* todo: should check if modified? otherwise lose modif! *)
      let fullpath = r.worktree / file in
      Unix.unlink fullpath
  )
  (* less: delete if a dir became empty, just walk_dir? *)
@

<<function Repository.init>>=
let init root =
  if not (Sys.file_exists root)
  then Unix.mkdir root dirperm;

  (* less: bare argument? so no .git/ prefix? *)
  let dirs = [
    ".git";
    ".git/objects";
    ".git/refs";
    ".git/refs/heads";
    ".git/refs/tags";
    ".git/refs/remote";
    ".git/refs/remote/origin";
    ".git/hooks";
    ".git/info";
  ] in
  dirs |> List.iter (fun dir ->
    (* less: exn if already there? *)
    Unix.mkdir (root / dir) dirperm;
  );
  let r = {
    worktree = root;
    dotgit = root / ".git";
    index = Index.empty;
  } in
  add_ref_if_new r Refs.Head Refs.default_head_content |> ignore;

  (* less: config file, description, hooks, etc *)
  pr (spf "Initialized empty Git repository in %s" (root / ".git"))
@

<<function Repository.open_>>=
let open_ root = 
  let path = root / ".git" in
  if Sys.file_exists path &&
     (Unix.stat path).Unix.st_kind = Unix.S_DIR
  then 
    { worktree = root;
      dotgit = path;
      (* less: initialize obj store and refs container? *)
      (* less: grafts, hooks *)
      index = 
        if Sys.file_exists (path / "index")
        then 
          (path / "index") |> Common.with_file_in (fun ch ->
            ch |> IO.input_channel |> Index.read)
        else Index.empty
    }
  else failwith (spf "Not a git repository at %s" root)
@


%-------------------------------------------------------------

<<version_control/repository.ml>>=
(* Copyright 2017 Yoann Padioleau, see copyright.txt *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* API to access repository data (objects, index, refs, packs).
 *
 * less: use nested modules for objects, index, refs below?
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Repository.t>>

<<constant Repository.TODOOPERATOR>>

<<constant Repository.dirperm>>

<<type Repository.objectish>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Repository.hexsha_to_filename>>

<<function Repository.hexsha_to_dirname>>

<<function Repository.ref_to_filename>>

<<function Repository.index_to_filename>>

<<function Repository.with_file_out_with_lock>>


(* move in common.ml? *)
<<function Repository.with_opendir>>
    
(* move in common.ml? (but remove .git specific stuff) *)
<<function Repository.walk_dir>>

(*****************************************************************************)
(* Refs *)
(*****************************************************************************)

<<function Repository.read_ref>>

<<function Repository.follow_ref>>

<<function Repository.follow_ref_some>>

<<function Repository.add_ref_if_new>>

<<function Repository.del_ref>>

<<function Repository.set_ref_if_same_old>>

<<function Repository.set_ref>>
  

<<function Repository.write_ref>>

<<function Repository.all_refs>>

(*****************************************************************************)
(* Objects *)
(*****************************************************************************)

<<function Repository.read_obj>>

<<function Repository.read_commit>>
<<function Repository.read_tree>>
<<function Repository.read_blob>>

<<function Repository.read_objectish>>

<<function Repository.add_obj>>

<<function Repository.has_obj>>

(*****************************************************************************)
(* Index *)
(*****************************************************************************)

<<function Repository.read_index>>

<<function Repository.write_index>>

    
<<function Repository.content_from_path_and_unix_stat>>

<<function Repository.add_in_index>>

(*****************************************************************************)
(* Commit *)
(*****************************************************************************)

<<function Repository.commit_index>>
  
(*****************************************************************************)
(* Checkout and reset *)
(*****************************************************************************)

<<function Repository.build_file_from_blob>>


<<function Repository.set_worktree_and_index_to_tree>>

(*****************************************************************************)
(* Packs *)
(*****************************************************************************)

(*****************************************************************************)
(* Repo init/open *)
(*****************************************************************************)

<<function Repository.init>>


<<function Repository.open_>>
@


\subsection*{[[version_control/repository.mli]]}

<<type Repository.t (version_control/repository.mli)>>=
type t = {
  worktree: Common.filename;
  dotgit: Common.filename;

  mutable index: Index.t;
}
@

<<type Repository.objectish (version_control/repository.mli)>>=
type objectish =
  | ObjByRef of Refs.t
  | ObjByHex of Hexsha.t
@

<<signature Repository.init>>=
(* repo *)
val init: Common.filename -> unit
@

<<signature Repository.open_>>=
val open_: Common.filename -> t
@

<<signature Repository.read_obj>>=
(* objects *)
val read_obj: t -> Sha1.t -> Objects.t
@

<<signature Repository.read_objectish>>=
val read_objectish: t -> objectish -> Objects.t
@

<<signature Repository.read_commit>>=
val read_commit: t -> Sha1.t -> Commit.t
@

<<signature Repository.read_tree>>=
val read_tree: t -> Sha1.t -> Tree.t
@

<<signature Repository.read_blob>>=
val read_blob: t -> Sha1.t -> Blob.t
@

<<signature Repository.add_obj>>=
val add_obj: t -> Objects.t -> Sha1.t
@

<<signature Repository.has_obj>>=
val has_obj: t -> Sha1.t -> bool
@

<<signature Repository.read_ref>>=
(* refs *)
val read_ref: t -> Refs.t -> Refs.ref_content
@

<<signature Repository.write_ref>>=
val write_ref: t -> Refs.t -> Refs.ref_content -> unit
@

<<signature Repository.follow_ref>>=
val follow_ref: t -> Refs.t -> Refs.t list * Commit.hash option
@

<<signature Repository.follow_ref_some>>=
val follow_ref_some: t -> Refs.t -> Commit.hash
@

<<signature Repository.all_refs>>=
val all_refs: t -> Refs.refname list
(* better than write_ref, will follow symbolic ref *)
@

<<signature Repository.set_ref>>=
(* better than write_ref, will follow symbolic ref *)
val set_ref: t -> Refs.t -> Commit.hash -> unit
@

<<signature Repository.del_ref>>=
val del_ref: t -> Refs.t -> unit
(* atomic op *)
@

<<signature Repository.add_ref_if_new>>=
(* atomic op *)
val add_ref_if_new: t -> Refs.t -> Refs.ref_content -> bool
@

<<signature Repository.set_ref_if_same_old>>=
val set_ref_if_same_old: t -> Refs.t -> Sha1.t -> Sha1.t -> bool
@

<<signature Repository.read_index>>=
(* index *)
val read_index: t -> Index.t
@

<<signature Repository.write_index>>=
val write_index: t -> unit
@

<<signature Repository.add_in_index>>=
val add_in_index: t -> Common.filename list -> unit
@

<<signature Repository.commit_index>>=
val commit_index: 
  t -> User.t (* author *) -> User.t (* committer *) -> string (* msg *) -> unit
@

<<signature Repository.set_worktree_and_index_to_tree>>=
val set_worktree_and_index_to_tree:
  t -> Tree.t -> unit
@

<<signature Repository.walk_dir>>=
(* misc *)
val walk_dir: 
  (Common.filename -> Common.filename list -> Common.filename list -> unit) ->
  Common.filename ->
  unit
@


%-------------------------------------------------------------

<<version_control/repository.mli>>=

<<type Repository.t (version_control/repository.mli)>>

<<type Repository.objectish (version_control/repository.mli)>>


<<signature Repository.init>>
<<signature Repository.open_>>

<<signature Repository.read_obj>>
<<signature Repository.read_objectish>>
<<signature Repository.read_commit>>
<<signature Repository.read_tree>>
<<signature Repository.read_blob>>
<<signature Repository.add_obj>>
<<signature Repository.has_obj>>

<<signature Repository.read_ref>>
<<signature Repository.write_ref>>
<<signature Repository.follow_ref>>
<<signature Repository.follow_ref_some>>
<<signature Repository.all_refs>>
<<signature Repository.set_ref>>
<<signature Repository.del_ref>>
<<signature Repository.add_ref_if_new>>
<<signature Repository.set_ref_if_same_old>>

<<signature Repository.read_index>>
<<signature Repository.write_index>>
<<signature Repository.add_in_index>>

<<signature Repository.commit_index>>
<<signature Repository.set_worktree_and_index_to_tree>>

(* packs *)

<<signature Repository.walk_dir>>

@


\subsection*{[[version_control/sha1.ml]]}

<<type Sha1.t>>=
type t = bytes
@

<<function Sha1.is_sha>>=
let is_sha x =
  (* less: extra check? forbidden characters? *)
  Bytes.length x = 20
@

<<function Sha1.read>>=
let read ch =
  let s = IO.really_nread ch 20 in
  assert (is_sha s);
  s
@

<<function Sha1.write>>=
let write ch x =
  IO.nwrite ch x
@

<<function Sha1.sha1>>=
(* sha-1 digest. Based on pseudo-code of RFC 3174.
   Slow and ugly but does the job. *)
let sha1 s =
  let sha_1_pad s =
    let len = String.length s in
    let blen = 8 * len in
    let rem = len mod 64 in
    let mlen = if rem > 55 then len + 128 - rem else len + 64 - rem in
    let m = Bytes.create mlen in
    Bytes.blit_string s 0 m 0 len;
    Bytes.fill m len (mlen - len) '\x00';
    Bytes.set m len '\x80';
    if Sys.word_size > 32 then begin
      Bytes.set m (mlen - 8) (Char.unsafe_chr (blen lsr 56 land 0xFF));
      Bytes.set m (mlen - 7) (Char.unsafe_chr (blen lsr 48 land 0xFF));
      Bytes.set m (mlen - 6) (Char.unsafe_chr (blen lsr 40 land 0xFF));
      Bytes.set m (mlen - 5) (Char.unsafe_chr (blen lsr 32 land 0xFF));
    end;
    Bytes.set m (mlen - 4) (Char.unsafe_chr (blen lsr 24 land 0xFF));
    Bytes.set m (mlen - 3) (Char.unsafe_chr (blen lsr 16 land 0xFF));
    Bytes.set m (mlen - 2) (Char.unsafe_chr (blen lsr 8 land 0xFF));
    Bytes.set m (mlen - 1) (Char.unsafe_chr (blen land 0xFF));
    m
  in
  (* Operations on int32 *)
  let ( &&& ) = ( land ) in
  let ( lor ) = Int32.logor in
  let ( lxor ) = Int32.logxor in
  let ( land ) = Int32.logand in
  let ( ++ ) = Int32.add in
  let lnot = Int32.lognot in
  let sr = Int32.shift_right in
  let sl = Int32.shift_left in
  let cls n x = (sl x n) lor (Int32.shift_right_logical x (32 - n)) in
  (* Start *)
  let m = sha_1_pad s in
  let w = Array.make 16 0l in
  let h0 = ref 0x67452301l in
  let h1 = ref 0xEFCDAB89l in
  let h2 = ref 0x98BADCFEl in
  let h3 = ref 0x10325476l in
  let h4 = ref 0xC3D2E1F0l in
  let a = ref 0l in
  let b = ref 0l in
  let c = ref 0l in
  let d = ref 0l in
  let e = ref 0l in
  for i = 0 to ((Bytes.length m) / 64) - 1 do              (* For each block *)
    (* Fill w *)
    let base = i * 64 in
    for j = 0 to 15 do
      let k = base + (j * 4) in
      w.(j) <- sl (Int32.of_int (Char.code @@ Bytes.get m k)) 24 lor
               sl (Int32.of_int (Char.code @@ Bytes.get m (k + 1))) 16 lor
               sl (Int32.of_int (Char.code @@ Bytes.get m (k + 2))) 8 lor
               (Int32.of_int (Char.code @@ Bytes.get m (k + 3)))
    done;
    (* Loop *)
    a := !h0; b := !h1; c := !h2; d := !h3; e := !h4;
    for t = 0 to 79 do
      let f, k =
        if t <= 19 then (!b land !c) lor ((lnot !b) land !d), 0x5A827999l else
        if t <= 39 then !b lxor !c lxor !d, 0x6ED9EBA1l else
        if t <= 59 then
          (!b land !c) lor (!b land !d) lor (!c land !d), 0x8F1BBCDCl
        else
        !b lxor !c lxor !d, 0xCA62C1D6l
      in
      let s = t &&& 0xF in
      if (t >= 16) then begin
        w.(s) <- cls 1 begin
            w.((s + 13) &&& 0xF) lxor
            w.((s + 8) &&& 0xF) lxor
            w.((s + 2) &&& 0xF) lxor
            w.(s)
          end
      end;
      let temp = (cls 5 !a) ++ f ++ !e ++ w.(s) ++ k in
      e := !d;
      d := !c;
      c := cls 30 !b;
      b := !a;
      a := temp;
    done;
    (* Update *)
    h0 := !h0 ++ !a;
    h1 := !h1 ++ !b;
    h2 := !h2 ++ !c;
    h3 := !h3 ++ !d;
    h4 := !h4 ++ !e
  done;
  let h = Bytes.create 20 in
  let i2s h k i =
    Bytes.set h k (Char.unsafe_chr ((Int32.to_int (sr i 24)) &&& 0xFF));
    Bytes.set h (k + 1) (Char.unsafe_chr ((Int32.to_int (sr i 16)) &&& 0xFF));
    Bytes.set h (k + 2) (Char.unsafe_chr ((Int32.to_int (sr i 8)) &&& 0xFF));
    Bytes.set h (k + 3) (Char.unsafe_chr ((Int32.to_int i) &&& 0xFF));
  in
  i2s h 0 !h0;
  i2s h 4 !h1;
  i2s h 8 !h2;
  i2s h 12 !h3;
  i2s h 16 !h4;
  Bytes.unsafe_to_string h
@


%-------------------------------------------------------------

<<version_control/sha1.ml>>=
(*
Copyright (c) 2008 Daniel C. Bünzli

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below comes from: https://github.com/dbuenzli/uuidm 
 * (this code is also copy-pasted and used in git-mirage)
 * 
 * alternatives:
 *  - https://github.com/vincenthz/ocaml-sha 
 *    not maintained and uses C code
 *  - https://github.com/xavierleroy/cryptokit/
 *    by Xavier Leroy, but also uses C code
 *  - nocrypto
 *    seems like the official crypto lib, but also uses C code
 *  - md5sum, produces 128-bit hash value (sha1 is 20 bytes so 160 bits)
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Sha1.t>>

<<function Sha1.is_sha>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Sha1.read>>

<<function Sha1.write>>

(* start of copy-pasted code from uuidm *)

<<function Sha1.sha1>>
@


\subsection*{[[version_control/sha1.mli]]}

<<type Sha1.t (version_control/sha1.mli)>>=
(* a 20 bytes number (really a string of length 20) *)
type t = bytes
@

<<signature Sha1.sha1>>=
(* computes SHA1 of a series of bytes *) 
val sha1: bytes -> t
@

<<signature Sha1.read>>=
val read: IO.input -> t
@

<<signature Sha1.write>>=
val write: 'a IO.output -> t -> unit
@

<<signature Sha1.is_sha>>=
val is_sha: t -> bool
@


%-------------------------------------------------------------

<<version_control/sha1.mli>>=
<<type Sha1.t (version_control/sha1.mli)>>

<<signature Sha1.sha1>>

<<signature Sha1.read>>
<<signature Sha1.write>>

<<signature Sha1.is_sha>>
@


\subsection*{[[version_control/tree.ml]]}

<<type Tree.perm>>=
(* very similar to Index.mode, but with also a 'Dir' *)
type perm = 
  | Normal
  | Exec
  | Link
  | Dir
  | Commit (* ?? submodule? *)
@

<<type Tree.entry>>=
type entry = {
  perm: perm;
  (* relative to tree, so does not contain any '/', or '.' or '..' *)
  name: string;
  (* blob or tree *)
  node: Sha1.t;
}
@

<<type Tree.t>>=
(* todo: entries must be sorted! and each name must be unique *)
type t = entry list
@

<<type Tree.hash>>=
type hash = Sha1.t
@

<<function Tree.walk_tree>>=
(* we must visit in sorted order, so the caller of walk_tree can rely on 'f'
 * being called in order (so it can easily create for example sorted 
 * index entries while visiting a tree)
 *)
let rec walk_tree read_tree dirpath f xs =
  xs |> List.iter (fun entry ->
    let relpath = Filename.concat dirpath entry.name in
    f relpath entry;
    match entry.perm with
    | Dir ->
      walk_tree read_tree relpath f (read_tree entry.node)
    | Commit ->
      failwith "submodule not supported yet"
    | Normal | Exec | Link -> ()
  )
@

<<function Tree.walk_trees>>=
let rec walk_trees read_tree dirpath f xs ys =
  let g dirpath entry1_opt entry2_opt =
    f dirpath entry1_opt entry2_opt;
    (match entry1_opt, entry2_opt with
    | Some { perm = Dir; name = str; node = sha }, None ->
      walk_trees read_tree (Filename.concat dirpath str) f
        (read_tree sha) []
    | None, Some { perm = Dir; name = str; node = sha } ->
      walk_trees read_tree (Filename.concat dirpath str) f
        [] (read_tree sha)
    | Some { perm = Dir; name = str1; node = sha1 },
      Some { perm = Dir; name = str2; node = sha2 } ->
      assert (str1 = str2);
        (* todo: could skip if sha1 = sha2 here, useful opti *)
        walk_trees read_tree (Filename.concat dirpath str1) f
          (read_tree sha1) (read_tree sha2)
    | None, None -> raise (Impossible "two None in walk_trees.g")
    (* no directories, no need to recurse *)
    | Some _, None
    | None, Some _
    | Some _, Some _
      -> ()
    )
  in
  match xs, ys with
  | [], [] -> ()
  | x::xs, [] ->
    g dirpath (Some x) None;
    walk_trees read_tree dirpath f xs ys
  | [], y::ys ->
    g dirpath None (Some y);
    walk_trees read_tree dirpath f xs ys
  | x::xs, y::ys ->
    (match x.name <=> y.name with
    | Equal -> 
      g dirpath (Some x) (Some y);
      walk_trees read_tree dirpath f xs ys
    | Inf -> 
      g dirpath (Some x) None;
      walk_trees read_tree dirpath f xs (y::ys)
    | Sup ->
      g dirpath None (Some y);
      walk_trees read_tree dirpath f (x::xs) ys
    )
@

<<function Tree.perm_of_string>>=
let perm_of_string = function
  | "44"
  | "100644" -> Normal
  | "100755" -> Exec
  | "120000" -> Link
  | "40000"  -> Dir
  | "160000" -> Commit
  | x        -> failwith (spf "Tree.perm_of_string: %s is not a valid perm." x)
@

<<function Tree.string_of_perm>>=
let string_of_perm = function
  | Normal -> "100644"
  | Exec   -> "100755"
  | Link   -> "120000"
  | Dir    -> "40000"
  | Commit -> "160000"
@

<<function Tree.read_entry>>=
(* todo: should transform some No_more_input exn in something bad,
 * on first one it's ok, but after it means incomplete entry.
 *)
let read_entry ch =
  let perm = IO_.read_string_and_stop_char ch ' ' in
  (* todo: handle escape char in filenames? encode/decode *)
  let name = IO_.read_string_and_stop_char ch '\000' in
  let hash = Sha1.read ch in
  { perm = perm_of_string perm; name = name; node = hash }
@

<<function Tree.write_entry>>=
let write_entry ch e =
  IO.nwrite ch (string_of_perm e.perm);
  IO.write ch ' ';
  (* todo: handle escape char in filenames? encode/decode *)
  IO.nwrite ch e.name;
  IO.write ch '\000';
  Sha1.write ch e.node
@

<<function Tree.read>>=
let read ch =
  let rec aux acc =
    try 
      (* todo: how diffentiate no more input from wrong input ?
       * pass size ch and use IO.pos_in ?
       *)
      let e = read_entry ch in
      aux (e::acc)
    with IO.No_more_input ->
      List.rev acc
  in
  aux []
@

<<function Tree.write>>=
let write t ch =
  t |> List.iter (write_entry ch)
@

<<function Tree.show>>=
let show xs =
  xs |> List.iter (fun entry ->
    pr (spf "%s%s" entry.name
          (match entry.perm with
          | Dir -> "/"
          | _ -> ""
          ))
  )
@


%-------------------------------------------------------------

<<version_control/tree.ml>>=
(*
 * Copyright (c) 2013-2017 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Tree.perm>>

<<type Tree.entry>>

<<type Tree.t>>

<<type Tree.hash>>

(*****************************************************************************)
(* Walk *)
(*****************************************************************************)
<<function Tree.walk_tree>>

<<function Tree.walk_trees>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Tree.perm_of_string>>

<<function Tree.string_of_perm>>

<<function Tree.read_entry>>

<<function Tree.write_entry>>
  

<<function Tree.read>>


<<function Tree.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Tree.show>>
@


\subsection*{[[version_control/tree.mli]]}

<<type Tree.perm (version_control/tree.mli)>>=
type perm = 
  | Normal
  | Exec
  | Link
  | Dir
  | Commit (* submodule? *)
@

<<type Tree.entry (version_control/tree.mli)>>=
type entry = {
  perm: perm;
  name: string;
  (* blob or tree *)
  node: Sha1.t;
}
@

<<type Tree.t (version_control/tree.mli)>>=
type t = entry list
@

<<type Tree.hash (version_control/tree.mli)>>=
type hash = Sha1.t
@

<<signature Tree.read>>=
(* assumes have already read the 'tree <size>\000' header from unzipped input *)
val read: IO.input -> t
(* does not write the header, does not compress *)
@

<<signature Tree.write>>=
(* does not write the header, does not compress *)
val write: t -> bytes IO.output -> unit
@

<<signature Tree.show>>=
val show: t -> unit
@

<<signature Tree.walk_tree>>=
val walk_tree: 
  (hash -> t) -> Common.filename (* dir *) -> 
  (Common.filename -> entry -> unit) -> t -> unit
@

<<signature Tree.walk_trees>>=
val walk_trees:
  (hash -> t) -> Common.filename (* dir *) ->
  (Common.filename -> entry option -> entry option -> unit) -> t -> t -> unit
@


%-------------------------------------------------------------

<<version_control/tree.mli>>=

<<type Tree.perm (version_control/tree.mli)>>

<<type Tree.entry (version_control/tree.mli)>>

<<type Tree.t (version_control/tree.mli)>>

<<type Tree.hash (version_control/tree.mli)>>


<<signature Tree.read>>
<<signature Tree.write>>

<<signature Tree.show>>

<<signature Tree.walk_tree>>

<<signature Tree.walk_trees>>

@


\subsection*{[[version_control/unzip.ml]]}

<<type Unzip.huffman>>=
type huffman =
  | Found of int
  | NeedBit of huffman * huffman
  | NeedBits of int * huffman array
@

<<type Unzip.adler32>>=
type adler32 = {
  mutable a1 : int;
  mutable a2 : int;
}
@

<<type Unzip.window>>=
type window = {
  mutable wbuffer : bytes;
  mutable wpos : int;
  wcrc : adler32;
}
@

<<type Unzip.state>>=
type state =
  | Head
  | Block
  | CData
  | Flat
  | Crc
  | Dist
  | DistOne
  | Done
@

<<type Unzip.t>>=
type t = {
  mutable znbits : int;
  mutable zbits : int;
  mutable zstate : state;
  mutable zfinal : bool;
  mutable zhuffman : huffman;
  mutable zhuffdist : huffman option;
  mutable zlen : int;
  mutable zdist : int;
  mutable zneeded : int;
  mutable zoutput : bytes;
  mutable zoutpos : int;
  zinput : IO.input;
  zlengths : int array;
  zwindow : window;
}
@

<<type Unzip.error_msg>>=
type error_msg =
  | Invalid_huffman
  | Invalid_data
  | Invalid_crc
  | Truncated_data
  | Unsupported_dictionary
@

<<exception Unzip.Error>>=
exception Error of error_msg
@

<<function Unzip.error>>=
let error msg = raise (Error msg)
@

<<function Unzip.tree_depth>>=
(* HUFFMAN TREES *)

let rec tree_depth = function
  | Found _ -> 0
  | NeedBits _ -> assert false
  | NeedBit (a,b) ->
    1 + min (tree_depth a) (tree_depth b)
@

<<function Unzip.make_huffman>>=
let make_huffman lengths pos nlengths maxbits =
  let counts = Array.make maxbits 0 in
  for i = 0 to nlengths - 1 do
    let p = Array.unsafe_get lengths (i + pos) in
    if p >= maxbits then error Invalid_huffman;
    Array.unsafe_set counts p (Array.unsafe_get counts p + 1);
  done;
  let code = ref 0 in
  let tmp = Array.make maxbits 0 in
  for i = 1 to maxbits - 2 do
    code := (!code + Array.unsafe_get counts i) lsl 1;
    Array.unsafe_set tmp i !code;
  done;
  let bits = Hashtbl.create 0 in
  for i = 0 to nlengths - 1 do
    let l = Array.unsafe_get lengths (i + pos) in
    if l <> 0 then begin
      let n = Array.unsafe_get tmp (l - 1) in
      Array.unsafe_set tmp (l - 1) (n + 1);
      Hashtbl.add bits (n,l) i;
    end;
  done;
  let rec tree_make v l =
    if l > maxbits then error Invalid_huffman;
    try
      Found (Hashtbl.find bits (v,l))
    with
      Not_found ->
        NeedBit (tree_make (v lsl 1) (l + 1) , tree_make (v lsl 1 lor 1) (l + 1))
  in
  tree_compress (NeedBit (tree_make 0 1 , tree_make 1 1))
@

<<function Unzip.adler32_create>>=
(* ADLER32 (CRC) *)

let adler32_create() = {
  a1 = 1;
  a2 = 0;
}
@

<<function Unzip.adler32_update>>=
let adler32_update a s p l =
  let p = ref p in
  for i = 0 to l - 1 do
    let c = int_of_char (Bytes.unsafe_get s !p) in
    a.a1 <- (a.a1 + c) mod 65521;
    a.a2 <- (a.a2 + a.a1) mod 65521;
    incr p;
  done
@

<<function Unzip.adler32_read>>=
let adler32_read ch =
  let a2a = IO.read_byte ch in
  let a2b = IO.read_byte ch in
  let a1a = IO.read_byte ch in
  let a1b = IO.read_byte ch in
  {
    a1 = (a1a lsl 8) lor a1b;
    a2 = (a2a lsl 8) lor a2b;
  }
@

<<constant Unzip.window_size>>=
(* WINDOW *)

let window_size = 1 lsl 15
@

<<constant Unzip.buffer_size>>=
let buffer_size = 1 lsl 16
@

<<function Unzip.window_create>>=
let window_create size = {
    wbuffer = Bytes.create buffer_size;
    wpos = 0;
    wcrc = adler32_create()
  }
@

<<function Unzip.window_slide>>=
let window_slide w = 
  adler32_update w.wcrc w.wbuffer 0 window_size;
  let b = Bytes.create buffer_size in
  w.wpos <- w.wpos - window_size;
  Bytes.unsafe_blit w.wbuffer window_size b 0 w.wpos;
  w.wbuffer <- b
@

<<function Unzip.window_add_bytes>>=
let window_add_bytes w s p len =
  if w.wpos + len > buffer_size then window_slide w;
  Bytes.unsafe_blit s p w.wbuffer w.wpos len;
  w.wpos <- w.wpos + len
@

<<function Unzip.window_add_char>>=
let window_add_char w c =
  if w.wpos = buffer_size then window_slide w;
  Bytes.unsafe_set w.wbuffer w.wpos c;
  w.wpos <- w.wpos + 1
@

<<function Unzip.window_get_last_char>>=
let window_get_last_char w =
  Bytes.unsafe_get w.wbuffer (w.wpos - 1)
@

<<function Unzip.window_available>>=
let window_available w =
  w.wpos
@

<<function Unzip.window_checksum>>=
let window_checksum w =
  adler32_update w.wcrc w.wbuffer 0 w.wpos;
  w.wcrc
@

<<constant Unzip.len_extra_bits_tbl>>=
let len_extra_bits_tbl = [|0;0;0;0;0;0;0;0;1;1;1;1;2;2;2;2;3;3;3;3;4;4;4;4;5;5;5;5;0;-1;-1|]
@

<<constant Unzip.len_base_val_tbl>>=
let len_base_val_tbl = [|3;4;5;6;7;8;9;10;11;13;15;17;19;23;27;31;35;43;51;59;67;83;99;115;131;163;195;227;258|]
@

<<constant Unzip.dist_extra_bits_tbl>>=
let dist_extra_bits_tbl = [|0;0;0;0;1;1;2;2;3;3;4;4;5;5;6;6;7;7;8;8;9;9;10;10;11;11;12;12;13;13;-1;-1|]
@

<<constant Unzip.dist_base_val_tbl>>=
let dist_base_val_tbl = [|1;2;3;4;5;7;9;13;17;25;33;49;65;97;129;193;257;385;513;769;1025;1537;2049;3073;4097;6145;8193;12289;16385;24577|]
@

<<constant Unzip.code_lengths_pos>>=
let code_lengths_pos = [|16;17;18;0;8;7;9;6;10;5;11;4;12;3;13;2;14;1;15|]
@

<<constant Unzip.fixed_huffman>>=
let fixed_huffman = make_huffman (Array.init 288 (fun n ->
                  if n <= 143 then 8
                  else if n <= 255 then 9
                  else if n <= 279 then 7
                  else 8
                )) 0 288 10
@

<<function Unzip.get_bits>>=
let get_bits z n =
  while z.znbits < n do
    z.zbits <- z.zbits lor ((IO.read_byte z.zinput) lsl z.znbits);
    z.znbits <- z.znbits + 8;
  done;
  let b = z.zbits land (1 lsl n - 1) in
  z.znbits <- z.znbits - n;
  z.zbits <- z.zbits lsr n;
  b
@

<<function Unzip.get_bit>>=
let get_bit z =
  if z.znbits = 0 then begin
    z.znbits <- 8;
    z.zbits <- IO.read_byte z.zinput;
  end;
  let b = z.zbits land 1 = 1 in
  z.znbits <- z.znbits - 1;
  z.zbits <- z.zbits lsr 1;
  b
@

<<function Unzip.get_rev_bits>>=
let rec get_rev_bits z n =
  if n = 0 then
    0
  else if get_bit z then
    (1 lsl (n - 1)) lor (get_rev_bits z (n-1))
  else
    get_rev_bits z (n-1)
@

<<function Unzip.reset_bits>>=
let reset_bits z =
  z.zbits <- 0;
  z.znbits <- 0
@

<<function Unzip.add_bytes>>=
let add_bytes z s p l =
  window_add_bytes z.zwindow s p l;
  Bytes.unsafe_blit s p z.zoutput z.zoutpos l;
  z.zneeded <- z.zneeded - l;
  z.zoutpos <- z.zoutpos + l
@

<<function Unzip.add_char>>=
let add_char z c =
  window_add_char z.zwindow c;
  Bytes.unsafe_set z.zoutput z.zoutpos c;
  z.zneeded <- z.zneeded - 1;
  z.zoutpos <- z.zoutpos + 1
@

<<function Unzip.add_dist_one>>=
let add_dist_one z n =
  let c = window_get_last_char z.zwindow in
  let s = Bytes.make n c in
  add_bytes z s 0 n
@

<<function Unzip.add_dist>>=
let add_dist z d l =
  add_bytes z z.zwindow.wbuffer (z.zwindow.wpos - d) l
@

<<function Unzip.apply_huffman>>=
let rec apply_huffman z = function
  | Found n -> n
  | NeedBit (a,b) -> apply_huffman z (if get_bit z then b else a)
  | NeedBits (n,t) -> apply_huffman z (Array.unsafe_get t (get_bits z n))
@

<<function Unzip.inflate_lengths>>=
let inflate_lengths z a max =
  let i = ref 0 in
  let prev = ref 0 in
  while !i < max do
    match apply_huffman z z.zhuffman with
    | n when n <= 15 ->
      prev := n;
      Array.unsafe_set a !i n;
      incr i
    | 16 ->
      let n = 3 + get_bits z 2 in
      if !i + n > max then error Invalid_data;
      for k = 0 to n - 1 do
        Array.unsafe_set a !i !prev;
        incr i;
      done;
    | 17 ->
      let n = 3 + get_bits z 3 in
      i := !i + n;
      if !i > max then error Invalid_data;
    | 18 ->
      let n = 11 + get_bits z 7 in
      i := !i + n;
      if !i > max then error Invalid_data;
    | _ ->
      error Invalid_data
  done
@

<<function Unzip.inflate_loop>>=
let rec inflate_loop z =
  match z.zstate with
  | Head ->
    let cmf = IO.read_byte z.zinput in
    let cm = cmf land 15 in
    let cinfo = cmf lsr 4 in
    if cm <> 8 || cinfo <> 7 then error Invalid_data;
    let flg = IO.read_byte z.zinput in
    (*let fcheck = flg land 31 in*)
    let fdict = flg land 32 <> 0 in
    (*let flevel = flg lsr 6 in*)
    if (cmf lsl 8 + flg) mod 31 <> 0 then error Invalid_data;
    if fdict then error Unsupported_dictionary;
    z.zstate <- Block;
    inflate_loop z
  | Crc ->
    let calc = window_checksum z.zwindow in
    let crc = adler32_read z.zinput in
    if calc <> crc then error Invalid_crc;
    z.zstate <- Done;
    inflate_loop z
  | Done ->
    ()
  | Block ->
    z.zfinal <- get_bit z;
    let btype = get_bits z 2 in
    (match btype with
    | 0 -> (* no compression *)
      z.zlen <- IO.LittleEndian.read_ui16 z.zinput;
      let nlen = IO.LittleEndian.read_ui16 z.zinput in
      if nlen <> 0xffff - z.zlen then error Invalid_data;
      z.zstate <- Flat;
      inflate_loop z;
      reset_bits z
    | 1 -> (* fixed Huffman *)
      z.zhuffman <- fixed_huffman;
      z.zhuffdist <- None;
      z.zstate <- CData;
      inflate_loop z
    | 2 -> (* dynamic Huffman *)
      let hlit = get_bits z 5 + 257 in
      let hdist = get_bits z 5 + 1 in
      let hclen = get_bits z 4 + 4 in
      for i = 0 to hclen - 1 do
        Array.unsafe_set z.zlengths (Array.unsafe_get code_lengths_pos i) (get_bits z 3);
      done;
      for i = hclen to 18 do
        Array.unsafe_set z.zlengths (Array.unsafe_get code_lengths_pos i) 0;
      done;
      z.zhuffman <- make_huffman z.zlengths 0 19 8;
      let lengths = Array.make (hlit + hdist) 0 in
      inflate_lengths z lengths (hlit + hdist);
      z.zhuffdist <- Some (make_huffman lengths hlit hdist 16);
      z.zhuffman <- make_huffman lengths 0 hlit 16;      
      z.zstate <- CData;
      inflate_loop z
    | _ ->
      error Invalid_data)
  | Flat ->
    let rlen = min z.zlen z.zneeded in
    let str = IO.nread z.zinput rlen in
    let len = Bytes.length str in
    z.zlen <- z.zlen - len;
    add_bytes z str 0 len;
    if z.zlen = 0 then z.zstate <- (if z.zfinal then Crc else Block);
    if z.zneeded > 0 then inflate_loop z
  | DistOne ->
    let len = min z.zlen z.zneeded in
    add_dist_one z len;
    z.zlen <- z.zlen - len;
    if z.zlen = 0 then z.zstate <- CData;
    if z.zneeded > 0 then inflate_loop z
  | Dist ->
    while z.zlen > 0 && z.zneeded > 0 do
      let len = min z.zneeded (min z.zlen z.zdist) in
      add_dist z z.zdist len;
      z.zlen <- z.zlen - len;
    done;
    if z.zlen = 0 then z.zstate <- CData;
    if z.zneeded > 0 then inflate_loop z
  | CData ->
    match apply_huffman z z.zhuffman with
    | n when n < 256 ->
      add_char z (Char.unsafe_chr n);
      if z.zneeded > 0 then inflate_loop z
    | 256 ->
      z.zstate <- if z.zfinal then Crc else Block;
      inflate_loop z
    | n ->
      let n = n - 257 in
      let extra_bits = Array.unsafe_get len_extra_bits_tbl n in
      if extra_bits = -1 then error Invalid_data;
      z.zlen <- (Array.unsafe_get len_base_val_tbl n) + (get_bits z extra_bits);
      let dist_code = (match z.zhuffdist with None -> get_rev_bits z 5 | Some h -> apply_huffman z h) in
      let extra_bits = Array.unsafe_get dist_extra_bits_tbl dist_code in
      if extra_bits = -1 then error Invalid_data;
      z.zdist <- (Array.unsafe_get dist_base_val_tbl dist_code) + (get_bits z extra_bits);
      if z.zdist > window_available z.zwindow then error Invalid_data;
      z.zstate <- (if z.zdist = 1 then DistOne else Dist);
      inflate_loop z
@

<<function Unzip.inflate_data>>=
let inflate_data z s pos len =
  if pos < 0 || len < 0 || pos + len > Bytes.length s then invalid_arg "inflate_data";
  z.zneeded <- len;
  z.zoutpos <- pos;
  z.zoutput <- s;
  try
    if len > 0 then inflate_loop z;
    len - z.zneeded
  with
    IO.No_more_input -> error Truncated_data
@

<<function Unzip.inflate_init>>=
let inflate_init ?(header=true) ch = 
  {
    zfinal = false;
    zhuffman = fixed_huffman;
    zhuffdist = None;
    zlen = 0;
    zdist = 0;
    zstate = (if header then Head else Block);
    zinput = ch;
    zbits = 0;
    znbits = 0;
    zneeded = 0;
    zoutput = Bytes.empty;
    zoutpos = 0;
    zlengths = Array.make 19 (-1);
    zwindow = window_create (1 lsl 15)
  }
@

<<function Unzip.inflate>>=
let inflate ?(header=true) ch =
  let z = inflate_init ~header ch in
  let s = Bytes.create 1 in
  IO.create_in
    ~read:(fun() ->
      let l = inflate_data z s 0 1 in
      if l = 1 then Bytes.unsafe_get s 0 else raise IO.No_more_input
    )
    ~input:(fun s p l ->
      let n = inflate_data z s p l in
      if n = 0 then raise IO.No_more_input;
      n
    )
    ~close:(fun () ->
      IO.close_in ch
    )
@


%-------------------------------------------------------------

<<version_control/unzip.ml>>=
(*
 * Unzip - inflate format decompression algorithm
 * Copyright (C) 2004 Nicolas Cannasse
 * Compliant with RFC 1950 and 1951
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version,
 * with the special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *)

<<type Unzip.huffman>>


<<type Unzip.adler32>>

<<type Unzip.window>>

<<type Unzip.state>>

<<type Unzip.t>>

<<type Unzip.error_msg>>

<<exception Unzip.Error>>

<<function Unzip.error>>

(* ************************************************************************ *)
<<function Unzip.tree_depth>>

let rec tree_compress t =
  match tree_depth t with
  | 0 -> t
  | 1 ->
    (match t with
    | NeedBit (a,b) -> NeedBit (tree_compress a,tree_compress b)
    | _ -> assert false)
  | d ->
    let size = 1 lsl d in
    let tbl = Array.make size (Found (-1)) in
    tree_walk tbl 0 0 d t;
    NeedBits (d,tbl)

and tree_walk tbl p cd d = function
  | NeedBit (a,b) when d > 0 ->
    tree_walk tbl p (cd + 1) (d-1) a;
    tree_walk tbl (p lor (1 lsl cd)) (cd + 1) (d-1) b;
  | t ->
    Array.set tbl p (tree_compress t)

<<function Unzip.make_huffman>>

(* ************************************************************************ *)
<<function Unzip.adler32_create>>

<<function Unzip.adler32_update>>

<<function Unzip.adler32_read>>

(* ************************************************************************ *)
<<constant Unzip.window_size>>
<<constant Unzip.buffer_size>>

<<function Unzip.window_create>>

<<function Unzip.window_slide>>

<<function Unzip.window_add_bytes>>

<<function Unzip.window_add_char>>

<<function Unzip.window_get_last_char>>

<<function Unzip.window_available>>

<<function Unzip.window_checksum>>

(* ************************************************************************ *)

<<constant Unzip.len_extra_bits_tbl>>
<<constant Unzip.len_base_val_tbl>>
<<constant Unzip.dist_extra_bits_tbl>>
<<constant Unzip.dist_base_val_tbl>>
<<constant Unzip.code_lengths_pos>>

<<constant Unzip.fixed_huffman>>

<<function Unzip.get_bits>>

<<function Unzip.get_bit>>

<<function Unzip.get_rev_bits>>

<<function Unzip.reset_bits>>

<<function Unzip.add_bytes>>

<<function Unzip.add_char>>

<<function Unzip.add_dist_one>>

<<function Unzip.add_dist>>

<<function Unzip.apply_huffman>>

<<function Unzip.inflate_lengths>>

<<function Unzip.inflate_loop>>

<<function Unzip.inflate_data>>

<<function Unzip.inflate_init>>

<<function Unzip.inflate>>
@


\subsection*{[[version_control/unzip.mli]]}

<<type Unzip.error_msg (version_control/unzip.mli)>>=
(** Decompression algorithm.

  Unzip decompression algorithm is compliant with RFC 1950 and 1951 which
  are describing the "inflate" algorithm used in most popular file formats.
  This format is also the one used by the popular ZLib library.  
*)

type error_msg =
  | Invalid_huffman
  | Invalid_data
  | Invalid_crc
  | Truncated_data
  | Unsupported_dictionary
@

<<exception Unzip.Error (version_control/unzip.mli)>>=
exception Error of error_msg
@

<<signature Unzip.inflate>>=
val inflate : ?header:bool -> IO.input -> IO.input
(** wrap an input using "inflate" decompression algorithm. raises [Error] if
  an error occurs (this can only be caused by malformed input data). *)
@

<<signature Unzip.inflate_init>>=
val inflate_init : ?header:bool -> IO.input -> t
@

<<signature Unzip.inflate_data>>=
val inflate_data : t -> bytes -> int -> int -> int
@


%-------------------------------------------------------------

<<version_control/unzip.mli>>=
(*
 * Unzip - inflate format decompression algorithm
 * Copyright (C) 2004 Nicolas Cannasse
 * Compliant with RFC 1950 and 1951
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version,
 * with the special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *)

<<type Unzip.error_msg (version_control/unzip.mli)>>

<<exception Unzip.Error (version_control/unzip.mli)>>

<<signature Unzip.inflate>>

type t

<<signature Unzip.inflate_init>>
<<signature Unzip.inflate_data>>
@


\subsection*{[[version_control/user.ml]]}

<<type User.sign>>=
(*****************************************************************************)

type sign = Plus | Minus
@

<<type User.tz_offset>>=
type tz_offset = {
  sign: sign;
  hours: int;
  min: int;
}
@

<<type User.t>>=
type t = {
  name : string;
  email: string;
  date : int64 * tz_offset(*option*);
}
@

<<function User.sign_of_char>>=
let sign_of_char = function
  | '+' -> Plus
  | '-' -> Minus
  | c -> failwith (spf "User.sign_of_string: not a sign, got %c" c)
@

<<function User.char_of_sign>>=
let char_of_sign = function
  | Plus -> '+'
  | Minus -> '-'
@

<<function User.read>>=
let read ch =
  let name = IO_.read_string_and_stop_char ch '<' in
  let email = IO_.read_string_and_stop_char ch '>' in
  let c = IO.read ch in
  if c <> ' ' then failwith "User.read: wrong format, missing space";

  let seconds = IO_.read_string_and_stop_char ch ' ' in
  let sign = IO.read ch in
  let hours = IO.nread_string ch 2 in
  let mins = IO.nread_string ch 2 in
  { name = String.sub name 0 (String.length name - 1);
    email = email;
    date = (Int64.of_string seconds,
            {
              sign = sign_of_char sign;
              hours = int_of_string hours;
              min = int_of_string mins;
            });
  }
@

<<function User.write_date>>=
let write_date ch (date, tz) =
  IO.nwrite ch (Int64.to_string date);
  IO.write ch ' ';
  let sign = match tz.sign with Plus -> "+" | Minus -> "-" in
  IO.nwrite ch (spf "%s%02d%02d" sign tz.hours tz.min)
@

<<function User.write>>=
let write ch user =
  IO.nwrite ch (spf "%s <%s> " user.name user.email);
  write_date ch user.date
@

<<function User.string_of_date>>=
let string_of_date (date, tz) =
  let f = Int64.to_float date in
  let tm = Unix.localtime f in

  spf "%s %s %d %02d:%02d:%02d %d %c%02d%02d"
    (Date.string_of_day tm.Unix.tm_wday) (Date.string_of_month tm.Unix.tm_mon) 
    tm.Unix.tm_mday 
    tm.Unix.tm_hour tm.Unix.tm_min tm.Unix.tm_sec (tm.Unix.tm_year + 1900)
    (char_of_sign tz.sign) tz.hours tz.min
@


%-------------------------------------------------------------

<<version_control/user.ml>>=
(*
 * Copyright (c) 2013-2017 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
<<type User.sign>>

<<type User.tz_offset>>

<<type User.t>>

(* less: default_tz_offset ? *)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function User.sign_of_char>>

<<function User.char_of_sign>>

<<function User.read>>

<<function User.write_date>>

<<function User.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function User.string_of_date>>

@


\subsection*{[[version_control/user.mli]]}

<<type User.sign (version_control/user.mli)>>=
type sign = Plus | Minus
@

<<type User.tz_offset (version_control/user.mli)>>=
type tz_offset = {
  sign: sign;
  hours: int;
  min: int;
}
@

<<type User.t (version_control/user.mli)>>=
type t = {
  name : string;
  email: string;
  date : int64 * tz_offset;
}
@

<<signature User.read>>=
val read: IO.input -> t
@

<<signature User.write>>=
val write: 'a IO.output -> t -> unit
@

<<signature User.string_of_date>>=
(* for show *)
val string_of_date: (int64 * tz_offset) -> string
@


%-------------------------------------------------------------

<<version_control/user.mli>>=

<<type User.sign (version_control/user.mli)>>

<<type User.tz_offset (version_control/user.mli)>>

<<type User.t (version_control/user.mli)>>

<<signature User.read>>
<<signature User.write>>

<<signature User.string_of_date>>
@


\subsection*{[[version_control/zlib.ml]]}

<<exception Zlib.Error>>=
exception Error of string * string
@

<<toplevel Zlib._1>>=
let _ =
  Callback.register_exception "Zlib.Error" (Error("",""))
@

<<type Zlib.flush_command>>=
type flush_command =
    Z_NO_FLUSH
  | Z_SYNC_FLUSH
  | Z_FULL_FLUSH
  | Z_FINISH
@

<<constant Zlib.buffer_size>>=
let buffer_size = 1024
@

<<function Zlib.compress>>=
let compress ?(level = 6) ?(header = true) refill flush =
  let inbuf = Bytes.create buffer_size
  and outbuf = Bytes.create buffer_size in
  let zs = deflate_init level header in
  let rec compr inpos inavail =
    if inavail = 0 then begin
      let incount = refill inbuf in
      if incount = 0 then compr_finish() else compr 0 incount
    end else begin
      let (_, used_in, used_out) =
        deflate zs inbuf inpos inavail outbuf 0 buffer_size Z_NO_FLUSH in
      flush outbuf used_out;
      compr (inpos + used_in) (inavail - used_in)
    end
  and compr_finish () =
    let (finished, _, used_out) =
       deflate zs inbuf 0 0 outbuf 0 buffer_size Z_FINISH in
    flush outbuf used_out;
    if not finished then compr_finish()
  in
    compr 0 0;
    deflate_end zs
@

<<function Zlib.compress_direct>>=
let compress_direct  ?(level = 6) ?(header = true) flush =
  let outbuf = Bytes.create buffer_size in
  let zs = deflate_init level header in
  let rec compr inbuf inpos inavail =
    if inavail = 0 then ()
    else begin
      let (_, used_in, used_out) =
        deflate zs inbuf inpos inavail outbuf 0 buffer_size Z_NO_FLUSH in
      flush outbuf used_out;
      compr inbuf (inpos + used_in) (inavail - used_in)
    end
  and compr_finish () =
    let (finished, _, used_out) =
      deflate zs (Bytes.unsafe_of_string "") 0 0
                 outbuf 0 buffer_size Z_FINISH in
    flush outbuf used_out;
    if not finished then compr_finish()
  in
  compr, compr_finish
@

<<function Zlib.uncompress>>=
let uncompress ?(header = true) refill flush =
  let inbuf = Bytes.create buffer_size
  and outbuf = Bytes.create buffer_size in
  let zs = inflate_init header in
  let rec uncompr inpos inavail =
    if inavail = 0 then begin
      let incount = refill inbuf in
      if incount = 0 then uncompr_finish true else uncompr 0 incount
    end else begin
      let (finished, used_in, used_out) =
        inflate zs inbuf inpos inavail outbuf 0 buffer_size Z_SYNC_FLUSH in
      flush outbuf used_out;
      if not finished then uncompr (inpos + used_in) (inavail - used_in)
    end
  and uncompr_finish first_finish =
    (* Gotcha: if there is no header, inflate requires an extra "dummy" byte
       after the compressed stream in order to complete decompression
       and return finished = true. *)
    let dummy_byte = if first_finish && not header then 1 else 0 in
    let (finished, _, used_out) =
       inflate zs inbuf 0 dummy_byte outbuf 0 buffer_size Z_SYNC_FLUSH in
    flush outbuf used_out;
    if not finished then uncompr_finish false
  in
    uncompr 0 0;
    inflate_end zs
@


%-------------------------------------------------------------

<<version_control/zlib.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                         The CamlZip library                         *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2001 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Lesser General Public License, with     *)
(*  the special exception on linking described in file LICENSE.        *)
(*                                                                     *)
(***********************************************************************)

<<exception Zlib.Error>>

<<toplevel Zlib._1>>

type stream

<<type Zlib.flush_command>>

external deflate_init: int -> bool -> stream = "camlzip_deflateInit"
external deflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_deflate_bytecode" "camlzip_deflate"
external deflate_end: stream -> unit = "camlzip_deflateEnd"

external inflate_init: bool -> stream = "camlzip_inflateInit"
external inflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_inflate_bytecode" "camlzip_inflate"
external inflate_end: stream -> unit = "camlzip_inflateEnd"

external update_crc: int32 -> bytes -> int -> int -> int32
                   = "camlzip_update_crc32"
external update_crc_string: int32 -> string -> int -> int -> int32
                   = "camlzip_update_crc32"

<<constant Zlib.buffer_size>>

<<function Zlib.compress>>

<<function Zlib.compress_direct>>

<<function Zlib.uncompress>>
@


\subsection*{[[version_control/zlib.mli]]}

<<exception Zlib.Error (version_control/zlib.mli)>>=
exception Error of string * string
@

<<signature Zlib.compress>>=
val compress:
  ?level: int -> ?header: bool -> 
  (bytes -> int) -> (bytes -> int -> unit) -> unit
@

<<signature Zlib.compress_direct>>=
val compress_direct:
  ?level: int -> ?header: bool -> (bytes -> int -> unit) ->
  (bytes -> int -> int -> unit) * (unit -> unit)
@

<<signature Zlib.uncompress>>=
val uncompress:
  ?header: bool -> (bytes -> int) -> (bytes -> int -> unit) -> unit
@

<<type Zlib.flush_command (version_control/zlib.mli)>>=
type flush_command =
    Z_NO_FLUSH
  | Z_SYNC_FLUSH
  | Z_FULL_FLUSH
  | Z_FINISH
@


%-------------------------------------------------------------

<<version_control/zlib.mli>>=
open Common
(***********************************************************************)
(*                                                                     *)
(*                         The CamlZip library                         *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 2001 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Lesser General Public License, with     *)
(*  the special exception on linking described in file LICENSE.        *)
(*                                                                     *)
(***********************************************************************)

<<exception Zlib.Error (version_control/zlib.mli)>>

<<signature Zlib.compress>>

<<signature Zlib.compress_direct>>

<<signature Zlib.uncompress>>

type stream

<<type Zlib.flush_command (version_control/zlib.mli)>>

external deflate_init: int -> bool -> stream = "camlzip_deflateInit"
external deflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_deflate_bytecode" "camlzip_deflate"
external deflate_end: stream -> unit = "camlzip_deflateEnd"

external inflate_init: bool -> stream = "camlzip_inflateInit"
external inflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_inflate_bytecode" "camlzip_inflate"
external inflate_end: stream -> unit = "camlzip_inflateEnd"

external update_crc: int32 -> bytes -> int -> int -> int32
                   = "camlzip_update_crc32"
external update_crc_string: int32 -> string -> int -> int -> int32
                   = "camlzip_update_crc32"
@


