\section{[[version_control/]]}

\subsection*{[[version_control/IO_.ml]]}

%-------------------------------------------------------------

<<version_control/IO_.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function IO_.with_close_out>>

<<function IO_.read_string_and_stop_char>>

<<function IO_.read_int_and_nullbyte>>

<<function IO_.read_key_space_value_newline>>
@


\subsection*{[[version_control/IO_.mli]]}

%-------------------------------------------------------------

<<version_control/IO_.mli>>=

<<signature IO_.read_string_and_stop_char>>

<<signature IO_.read_int_and_nullbyte>>

<<signature IO_.read_key_space_value_newline>>

<<signature IO_.with_close_out>>
@


\subsection*{[[version_control/blob.ml]]}

%-------------------------------------------------------------

<<version_control/blob.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Blob.t>>

<<type Blob.hash>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Blob.read>>

<<function Blob.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Blob.show>>
@


\subsection*{[[version_control/blob.mli]]}

%-------------------------------------------------------------

<<version_control/blob.mli>>=

<<type Blob.t>>

<<type Blob.hash>>

<<signature Blob.read>>
<<signature Blob.write>>

<<signature Blob.show>>
@


\subsection*{[[version_control/change.ml]]}

%-------------------------------------------------------------

<<version_control/change.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type Change.content>>

<<type Change.entry>>

<<type Change.t>>
@


\subsection*{[[version_control/change.mli]]}

%-------------------------------------------------------------

<<version_control/change.mli>>=

<<type Change.content>>

<<type Change.entry>>

<<type Change.t>>
@


\subsection*{[[version_control/changes.ml]]}

%-------------------------------------------------------------

<<version_control/changes.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * todo: 
 *  - rename detection
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Changes.skip_tree_and_adjust_path>>

<<function Changes.content_from_path_and_stat_index>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Changes.changes_tree_vs_tree>>

<<function Changes.changes_worktree_vs_index>>

<<function Changes.changes_index_vs_tree>>
@


\subsection*{[[version_control/changes.mli]]}

%-------------------------------------------------------------

<<version_control/changes.mli>>=

<<signature Changes.changes_tree_vs_tree>>

<<signature Changes.changes_worktree_vs_index>>

<<signature Changes.changes_index_vs_tree>>
@


\subsection*{[[version_control/client.ml]]}

%-------------------------------------------------------------

<<version_control/client.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Client.t>>
@


\subsection*{[[version_control/client.mli]]}

%-------------------------------------------------------------

<<version_control/client.mli>>=

<<type Client.t>>
@


\subsection*{[[version_control/client_git.ml]]}

%-------------------------------------------------------------

<<version_control/client_git.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Client_git.mk_client>>
@


\subsection*{[[version_control/client_git.mli]]}

%-------------------------------------------------------------

<<version_control/client_git.mli>>=

<<signature Client_git.mk_client>>
@


\subsection*{[[version_control/client_local.ml]]}

%-------------------------------------------------------------

<<version_control/client_local.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Graph walkers *)
(*****************************************************************************)

<<type Client_local.graph_walker>>

<<function Client_local.ml_graph_walker>>

<<function Client_local.collect_filetree>>
    
(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
 
<<function Client_local.find_top_common_commits>>

<<function Client_local.iter_missing_objects>>


<<function Client_local.fetch_objects>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Client_local.mk_client>>
@


\subsection*{[[version_control/client_local.mli]]}

%-------------------------------------------------------------

<<version_control/client_local.mli>>=

<<signature Client_local.mk_client>>
@


\subsection*{[[version_control/clients.ml]]}

%-------------------------------------------------------------

<<version_control/clients.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Clients.client_of_url>>
@


\subsection*{[[version_control/clients.mli]]}

%-------------------------------------------------------------

<<version_control/clients.mli>>=

<<signature Clients.client_of_url>>
@

\subsection*{[[version_control/cmd.ml]]}

%-------------------------------------------------------------

<<version_control/cmd.ml>>=

<<type Cmd.t>>

<<exception Cmd.ShowUsage>>
@


\subsection*{[[version_control/cmd_add.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_add.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_add.add>>

<<constant Cmd_add.cmd>>
@


\subsection*{[[version_control/cmd_branch.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_branch.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_branch.list_branches>>

<<function Cmd_branch.create_branch>>

<<function Cmd_branch.delete_branch>>

(* less: rename_branch *)

<<constant Cmd_branch.del_flag>>
<<constant Cmd_branch.del_force>>

<<constant Cmd_branch.cmd>>
@


\subsection*{[[version_control/cmd_checkout.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_checkout.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_checkout.checkout>>

<<function Cmd_checkout.update>>

<<constant Cmd_checkout.cmd>>
@


\subsection*{[[version_control/cmd_clone.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_clone.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_clone.clone>>

(* todo: when clone then repo should have a "refs/remotes/origin/master" *)

<<constant Cmd_clone.cmd>>
@


\subsection*{[[version_control/cmd_commit.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_commit.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_commit.commit>>

<<constant Cmd_commit.author>>
<<constant Cmd_commit.committer>>
<<constant Cmd_commit.message>>

<<constant Cmd_commit.cmd>>
@


\subsection*{[[version_control/cmd_diff.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_diff.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_diff.diff_worktree_vs_index>>

<<constant Cmd_diff.cmd>>
@


\subsection*{[[version_control/cmd_dump.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_dump.ml>>=
<<copyright ocamlgit>>
open Common

<<constant Cmd_dump.raw>>
<<constant Cmd_dump.index>>

<<function Cmd_dump.dump_object>>

<<function Cmd_dump.dump_index>>

<<function Cmd_dump.dump>>

<<constant Cmd_dump.cmd>>
@


\subsection*{[[version_control/cmd_help.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_help.ml>>=
<<copyright ocamlgit>>
open Common

<<constant Cmd_help.list_extra>>

<<constant Cmd_help.cmd>>
@


\subsection*{[[version_control/cmd_init.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_init.ml>>=
<<copyright ocamlgit>>
open Common

(* less: let bare = ref false *)

<<constant Cmd_init.cmd>>
@


\subsection*{[[version_control/cmd_log.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_log.ml>>=
<<copyright ocamlgit>>
open Common

(* todo: git log --graph --oneline --decorate --all *)

<<function Cmd_log.print_commit>>

<<function Cmd_log.print_change>>


<<constant Cmd_log.name_status>>

<<function Cmd_log.log>>

<<constant Cmd_log.cmd>>
@


\subsection*{[[version_control/cmd_merge.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_merge.ml>>=
@


\subsection*{[[version_control/cmd_pull.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_pull.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_pull.pull>>

<<constant Cmd_pull.cmd>>
@


\subsection*{[[version_control/cmd_push.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_push.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_push.push>>

<<constant Cmd_push.cmd>>
@


\subsection*{[[version_control/cmd_reset.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_reset.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_reset.reset_hard>>

<<constant Cmd_reset.hard>>
<<constant Cmd_reset.soft>>
<<constant Cmd_reset.mixed>>

<<constant Cmd_reset.cmd>>
@


\subsection*{[[version_control/cmd_rm.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_rm.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_rm.rm>>

<<constant Cmd_rm.cmd>>
@


\subsection*{[[version_control/cmd_show.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_show.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_show.show>>

<<constant Cmd_show.cmd>>
@


\subsection*{[[version_control/cmd_status.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_status.ml>>=
<<copyright ocamlgit>>
open Common

<<type Cmd_status.status>>

<<function Cmd_status.changes_index_vs_HEAD>>

<<function Cmd_status.untracked>>


<<function Cmd_status.status_of_repository>>

<<function Cmd_status.print_change_long>>


<<function Cmd_status.print_status_long>>
    

<<function Cmd_status.print_status_short>>

<<constant Cmd_status.short_format>>

<<function Cmd_status.status>>

<<constant Cmd_status.cmd>>
@


\subsection*{[[version_control/cmd_test.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_test.ml>>=
<<copyright ocamlgit>>
open Common

<<function Cmd_test.test_sha1>>

<<constant Cmd_test.cmd>>

@


\subsection*{[[version_control/cmds.ml]]}

%-------------------------------------------------------------

<<version_control/cmds.ml>>=

<<constant Cmds.main_commands>>

<<constant Cmds.extra_commands>>
@


\subsection*{[[version_control/commit.ml]]}

%-------------------------------------------------------------

<<version_control/commit.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Commit.t>>
<<type Commit.hash>>

(*****************************************************************************)
(* API *)
(*****************************************************************************)

(* for git log *)

<<function Commit.walk_history>>

(* for git pull *)

<<function Commit.collect_ancestors>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Commit.read>>

<<function Commit.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Commit.show>>
@


\subsection*{[[version_control/commit.mli]]}

%-------------------------------------------------------------

<<version_control/commit.mli>>=

<<type Commit.t>>
<<type Commit.hash>>


<<signature Commit.read>>
<<signature Commit.write>>

<<signature Commit.show>>

<<signature Commit.collect_ancestors>>

<<signature Commit.walk_history>>
@


\subsection*{[[version_control/compression.ml]]}

%-------------------------------------------------------------

<<version_control/compression.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Compression/decompression wrappers.
 * 
 * alternatives:
 *  * https://github.com/ygrek/ocaml-extlib/src/unzip.ml
 *    just decompression (inflate), pretty small: 450 LOC
 *  - https://github.com/mirage/decompress
 *    compression/decompression, seems complete, but pretty big. 
 *    used by https://github.com/mirage/ocaml-git
 *  * https://github.com/xavierleroy/camlzip
 *    uses C code (some of the code in ocaml-git uses ML code from camlzip)
 *  - https://github.com/madroach/ocaml-zlib
 *    ??
 *  - https://github.com/samoht/ocaml-lz77 
 *    copy-pasted in decompress, but too simple. Does not
 *    support right API where can compress/decompress strings.
 *  - libflate in plan9 :)
 * 
 * Currently used solutions are marked with a '*' above.
 *)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Compression.decompress>>

<<function Compression.compress>>
@


\subsection*{[[version_control/compression.mli]]}

%-------------------------------------------------------------

<<version_control/compression.mli>>=

<<signature Compression.decompress>>
<<signature Compression.compress>>
@


\subsection*{[[version_control/diff.ml]]}

%
%<<function Diff.diff_buggy>>=
%(*
%SimpleDiff is buggy!
%Here is an example of output after an ogit diff (with some debugging 
%information):
%
%diff --git a/authors.txt b/authors.txt
%["Yoann Padioleau\n"; "\n"; "except \n"; " - lex/ by Xavier Leroy (from ocaml)\n"; " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n"; " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n"; " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n"; " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n"; " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n"; " - commons/IO.ml by Nicolas Canasse (from exblib)\n"]
%["Yoann Padioleau\n"; "\n"; "xxx\n"; "except \n"; " - lex/ by Xavier Leroy (from ocaml)\n"; " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n"; " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n"; " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n"; " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n"; " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n"; " - commons/IO.ml by Nicolas Canasse (from exblib)\n"]
%[(()); Tag1 (("Yoann Padioleau\n")); Tag2 (("\n", "xxx\n", "except \n", " - lex/ by Xavier Leroy (from ocaml)\n", " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n", " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n", " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n", " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n", " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n", " - commons/IO.ml by Nicolas Canasse (from exblib)\n"))]
%+Yoann Padioleau
% 
% xxx
% except 
%  - lex/ by Xavier Leroy (from ocaml)
%  - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)
%  - version_control/sha.ml by Daniel Bunzli (from uuidm)
%  - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)
%  - version_control/zlib.ml by Xavier Leroy (from camlzip)
%  - version_control/unzip.ml by Nicolas Canasse (from extlib)
%  - commons/IO.ml by Nicolas Canasse (from exblib)
%
%-----------
%SimpleDiff says the diff is the addition of 'Yoann Padioleau' but it's not!
%It's in both content. The diff should be the addition of 'xxx'.
%*)
%
%let diff_buggy str1 str2 =
%  let xs = split_lines str1 in
%  let ys = split_lines str2 in
%  pr2_gen xs;
%  pr2_gen ys;
%  let res = SimpleDiff.get_diff (Array.of_list xs) (Array.of_list ys) in
%  pr2_gen res;
%  res |> List.map (function
%    | SimpleDiff.Equal arr   -> 
%      arr |> Array.to_list |> List.map (fun x -> Equal x)
%    | SimpleDiff.Deleted arr -> 
%      arr |> Array.to_list |> List.map (fun x -> Deleted x)
%    | SimpleDiff.Added arr   -> 
%      arr |> Array.to_list |> List.map (fun x -> Added x)
%  )
%@
%module SimpleDiff = Diff_simple.Make(String)

%-------------------------------------------------------------

<<version_control/diff.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Compute the differences between 2 files line-wise.
 *
 * alternatives:
 *  - simple diff: https://github.com/gjaldon/simple-diff
 *    (an ocaml port of https://github.com/paulgb/simplediff )
 *    http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1988/8807/8807c/8807c.htm
 *    simple, but no diff -u support by default
 *    and seems buggy!
 *  - myers: https://github.com/leque/ocaml-diff port of
 *    "Eugene Myers, An O(ND) Difference Algorithm and Its Variations, 
 *    Algorithmica Vol. 1 No. 2, pp. 251-266, 1986."
 *  - patience diff: https://github.com/janestreet/patdiff
 *  https://stackoverflow.com/questions/42635889/myers-diff-algorithm-vs-hunt-mcilroy-algorithm
 *    support also colored output, and word diff, but heavily modularized
 *  - plan9 diff (in plan9/utilities/string/diff/)
 *    not myers's diff
 *  - gnu diff (in plan9/ape_cmd/diff)
 *    use myers?
 *  - http://pynash.org/2013/02/26/diff-in-50-lines/ 
 *    (in python, and talk about python difflib)
 *  - Heckle diff mentionned in diff3.py
 *    "P. Heckel. ``A technique for isolating differences between files.''
 *     Communications of the ACM, Vol. 21, No. 4, page 264, April 1978."
 * 
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Diff.item>>

<<type Diff.diff_elem>>

<<type Diff.diff>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function Diff.split_lines>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<module Diff.StringDiff>>

<<function Diff.diff>>
@


\subsection*{[[version_control/diff.mli]]}

%-------------------------------------------------------------

<<version_control/diff.mli>>=

<<type Diff.item>>

<<type Diff.diff_elem>>

<<type Diff.diff>>


<<signature Diff.diff>>
@


\subsection*{[[version_control/diff3.ml]]}


%-------------------------------------------------------------

<<version_control/diff3.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*
 * alternatives:
 *  - gnu diff3, in C
 *    https://www.gnu.org/software/diffutils/manual/html_node/diff3-Merging.html
 *    apparently by Randy Smith in 1988 and popularized by CVS
 *  - Perl Text::Diff3
 *    http://search.cpan.org/~tociyuki/Text-Diff3-0.10/lib/Text/Diff3.pm
 *    with good example of use in man page
 *  - python diff3
 *    https://github.com/schuhschuh/cmake-basis/blob/master/src/utilities/python/diff3.py
 *    apparently translation of the Perl code, itself a translation of the
 *    C code
 *  - formal investigation of diff3:
 *    http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf
 * 
 *)
@


\subsection*{[[version_control/diff_myers.ml]]}

%-------------------------------------------------------------

<<version_control/diff_myers.ml>>=
<<copyright ocaml-diff-myers>>

<<type Diff_myers.common>>

<<type Diff_myers.edit>>

<<signature Diff_myers.SeqType>>

<<signature Diff_myers.S>>

<<module Diff_myers.Make>>
@


\subsection*{[[version_control/diff_myers.mli]]}

%-------------------------------------------------------------

<<version_control/diff_myers.mli>>=
(**
   An implementation of Eugene Myers' O(ND) Difference Algorithm\[1\].
   This implementation is a port of util.lcs module of
   {{:http://practical-scheme.net/gauche} Gauche Scheme interpreter}.

   - \[1\] Eugene Myers, An O(ND) Difference Algorithm and Its Variations, Algorithmica Vol. 1 No. 2, pp. 251-266, 1986.
 *)

<<type Diff_myers.common>>

<<type Diff_myers.edit>>

<<signature Diff_myers.SeqType>>

<<signature Diff_myers.S>>

<<signature Diff_myers.Make>>
@


\subsection*{[[version_control/diff_simple.ml]]}
%buggy!

%-------------------------------------------------------------

<<version_control/diff_simple.ml>>=
module type Comparable =
  sig
    type t
    val compare: t -> t -> int
  end

module type S =
  sig
    type item

    type diff =
      | Deleted of item array
      | Added of item array
      | Equal of item array

    type t = diff list

    val get_diff : item array -> item array -> t
  end

module Make(Item : Comparable) = struct
  type item = Item.t

  type diff =
    | Deleted of item array
    | Added of item array
    | Equal of item array

  type t = diff list

  type subsequence_info =
    { (* Starting index of longest subsequence in the list of new values *)
      sub_start_new : int;
      (* Starting index of longest subsequence in the list of old values *)
      sub_start_old : int;
      (* The length of the longest subsequence *)
      longest_subsequence : int; }

  module CounterMap = Map.Make(Item)

  (* Returns a map with the line as key and a list of indices as value.
     Represents counts of all the lines. *)
  let map_counter keys =
    let keys_and_indices = Array.mapi (fun index key -> index, key) keys in
    Array.fold_left (fun map (index, key) ->
        let indices = try CounterMap.find key map with | Not_found -> [] in
        CounterMap.add key (index :: indices) map
      ) CounterMap.empty keys_and_indices


  (* Computes longest subsequence and returns data on the length of longest
     subsequence and the starting index for the longest subsequence in the old
     and new versions. *)
  let get_longest_subsequence old_lines new_lines =
    let old_values_counter = map_counter old_lines in
    let overlap = Hashtbl.create 5000 in
    let sub_start_old = ref 0 in
    let sub_start_new = ref 0 in
    let longest_subsequence = ref 0 in

    Array.iteri (fun new_index new_value ->
        let indices = try CounterMap.find new_value old_values_counter with
          | Not_found -> []
        in
        List.iter (fun old_index ->
            let prev_subsequence = try Hashtbl.find overlap (old_index - 1) with | Not_found -> 0 in
            let new_subsequence = prev_subsequence + 1 in
            Hashtbl.add overlap old_index new_subsequence;

            if new_subsequence > !longest_subsequence then
              sub_start_old := old_index - new_subsequence + 1;
            sub_start_new := new_index - new_subsequence + 1;
            longest_subsequence := new_subsequence;
          ) indices;
      ) new_lines;

    { sub_start_new = !sub_start_new;
      sub_start_old = !sub_start_old;
      longest_subsequence = !longest_subsequence }


  let rec get_diff old_lines new_lines =
    match old_lines, new_lines with
    | [||], [||] -> []
    | _, _ ->
      let { sub_start_new; sub_start_old; longest_subsequence } =
        get_longest_subsequence old_lines new_lines
      in

      if longest_subsequence == 0 then
        [Deleted old_lines; Added new_lines]
      else
        let old_lines_presubseq = Array.sub old_lines 0 sub_start_old in
        let new_lines_presubseq = Array.sub new_lines 0 sub_start_new in
        let old_lines_postsubseq =
          let start_index = sub_start_old + longest_subsequence in
          let end_index = Array.length old_lines - start_index in
          Array.sub old_lines start_index end_index
        in
        let new_lines_postsubseq =
          let start_index = sub_start_new + longest_subsequence in
          let end_index = Array.length new_lines - start_index in
          Array.sub new_lines start_index end_index
        in
        let unchanged_lines = Array.sub new_lines sub_start_new longest_subsequence in
        get_diff old_lines_presubseq new_lines_presubseq @
        [Equal unchanged_lines] @
        get_diff old_lines_postsubseq new_lines_postsubseq
end
@


\subsection*{[[version_control/diff_simple.mli]]}

%-------------------------------------------------------------

<<version_control/diff_simple.mli>>=
(** A simple diffing algorithm *)

module type Comparable =
  sig
    type t
      (** The type of the items being compared *)

    val compare: t -> t -> int
      (** A way to distinguish if items are equal or unequal. It follows
          the OCaml convention of returning an integer between -1 to 1. *)
  end

module type S =
  sig
    type item
    (** The type of the item that will be compared. *)

    type diff =
      | Deleted of item array
      | Added of item array
      | Equal of item array
    (** Represents the change or lack of change in a line or character
        between the old and new version. *)

    type t = diff list
    (** List of diffs which is the return value of the main function. *)

    val get_diff : item array -> item array -> t
    (** Returns a list of diffs between two arrays *)
  end

module Make (Item: Comparable) : S with type item = Item.t
@


\subsection*{[[version_control/diff_unified.ml]]}

%-------------------------------------------------------------

<<version_control/diff_unified.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Show differences between 2 files.
 *
 * Short explanation of unified format:
 *  - https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html
 *  - http://www.artima.com/weblogs/viewpost.jsp?thread=164293  
 * 
 * alternatives:
 *  - ocamldiff: https://github.com/zoggy/ocamldiff 
 *    parse and display unified diffs
 *  - unidiff: https://github.com/gildor478/ocaml-unidiff
 *    parse 
 *  - call diff -u (as I did in pfff) directly via Sys.command
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Diff_unified.print>>

<<function Diff_unified.print_header>>

<<constant Diff_unified.nContext>>

<<function Diff_unified.show_unified_diff>>


(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Diff_unified.show_change>>
@


\subsection*{[[version_control/diff_unified.mli]]}

%-------------------------------------------------------------

<<version_control/diff_unified.mli>>=

<<signature Diff_unified.show_change>>
@


\subsection*{[[version_control/dump.ml]]}

%-------------------------------------------------------------

<<version_control/dump.ml>>=
open Ocaml

(* mostly auto-generated by ocamltarzan *)

module Int64 = struct
let vof_t x =
  Ocaml.vof_int (Int64.to_int x)
end

module Int32 = struct
let vof_t x =
  Ocaml.vof_int (Int32.to_int x)
end


module Sha1 = struct
  let vof_t x = 
    Ocaml.VSum (("ShaHex", [Ocaml.vof_string (Hexsha.of_sha x)]))
end

module Blob = struct
  let vof_t x = Ocaml.vof_string x
end

module Tree = struct
open Tree
let vof_perm =
  function
  | Normal -> Ocaml.VSum (("Normal", []))
  | Exec -> Ocaml.VSum (("Exec", []))
  | Link -> Ocaml.VSum (("Link", []))
  | Dir -> Ocaml.VSum (("Dir", []))
  | Commit -> Ocaml.VSum (("Commit", []))
  
let vof_entry { perm = v_perm; name = v_name; id = v_node } =
  let bnds = [] in
  let arg = Sha1.vof_t v_node in
  let bnd = ("id", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_perm v_perm in
  let bnd = ("perm", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  
let vof_t v = Ocaml.vof_list vof_entry v
end

module User = struct
open User
let vof_sign =
  function
  | Plus -> Ocaml.VSum (("Plus", []))
  | Minus -> Ocaml.VSum (("Minus", []))
  
let vof_tz_offset { sign = v_sign; hours = v_hours; min = v_min } =
  let bnds = [] in
  let arg = Ocaml.vof_int v_min in
  let bnd = ("min", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_int v_hours in
  let bnd = ("hours", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_sign v_sign in
  let bnd = ("sign", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let vof_t { name = v_name; email = v_email; date = v_date } =
  let bnds = [] in
  let arg =
    match v_date with
    | (v1, v2) ->
        let v1 = Int64.vof_t v1
        and v2 = vof_tz_offset v2
        in Ocaml.VTuple [ v1; v2 ] in
  let bnd = ("date", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_email in
  let bnd = ("email", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
end

module Commit = struct
open Commit
let vof_t {
            tree = v_tree;
            parents = v_parents;
            author = v_author;
            committer = v_committer;
            message = v_message
          } =
  let bnds = [] in
  let arg = Ocaml.vof_string v_message in
  let bnd = ("message", arg) in
  let bnds = bnd :: bnds in
  let arg = User.vof_t v_committer in
  let bnd = ("committer", arg) in
  let bnds = bnd :: bnds in
  let arg = User.vof_t v_author in
  let bnd = ("author", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list Sha1.vof_t v_parents in
  let bnd = ("parents", arg) in
  let bnds = bnd :: bnds in
  let arg = Sha1.vof_t v_tree in
  let bnd = ("tree", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
end

module Objects = struct
open Objects
let vof_t =
  function
  | Blob v1 -> let v1 = Blob.vof_t v1 in Ocaml.VSum (("Blob", [ v1 ]))
  | Commit v1 -> let v1 = Commit.vof_t v1 in Ocaml.VSum (("Commit", [ v1 ]))
  | Tree v1 -> let v1 = Tree.vof_t v1 in Ocaml.VSum (("Tree", [ v1 ]))
end
<<constant Dump.vof_obj>>

module Index = struct
open Index
let rec
  vof_stat_info {
                  ctime = v_ctime;
                  mtime = v_mtime;
                  dev = v_dev;
                  inode = v_inode;
                  mode = v_mode;
                  uid = v_uid;
                  gid = v_gid;
                  size = v_size
                } =
  let bnds = [] in
  let arg = Int32.vof_t v_size in
  let bnd = ("size", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_gid in
  let bnd = ("gid", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_uid in
  let bnd = ("uid", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_mode v_mode in
  let bnd = ("mode", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_inode in
  let bnd = ("inode", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_dev in
  let bnd = ("dev", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_time v_mtime in
  let bnd = ("mtime", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_time v_ctime in
  let bnd = ("ctime", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_mode =
  function
  | Normal -> Ocaml.VSum (("Normal", []))
  | Exec -> Ocaml.VSum (("Exec", []))
  | Link -> Ocaml.VSum (("Link", []))
  | Gitlink -> Ocaml.VSum (("Gitlink", []))
and vof_time { lsb32 = v_lsb32; nsec = v_nsec } =
  let bnds = [] in
  let arg = Int32.vof_t v_nsec in
  let bnd = ("nsec", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_lsb32 in
  let bnd = ("lsb32", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  

let vof_entry { stats = v_stats; id = v_id; name = v_name }
              =
  let bnds = [] in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in
  let bnds = bnd :: bnds in
  let arg = Sha1.vof_t v_id in
  let bnd = ("id", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_stat_info v_stats in
  let bnd = ("stats", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let vof_t v = Ocaml.vof_list vof_entry v
end
<<constant Dump.vof_index>>
@


\subsection*{[[version_control/dump.mli]]}

%-------------------------------------------------------------

<<version_control/dump.mli>>=

<<signature Dump.vof_obj>>
<<signature Dump.vof_index>>
@


\subsection*{[[version_control/hexsha.ml]]}

%-------------------------------------------------------------

<<version_control/hexsha.ml>>=
<<copyright ocaml-hex>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * Most of the code below comes from src: https://github.com/mirage/ocaml-hex
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Hexsha.t>>

<<function Hexsha.is_hexsha>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

(* start of copy-pasted code from ocaml-hex *)

let hexa = "0123456789abcdef"
and hexa1 =
  "0000000000000000111111111111111122222222222222223333333333333333\
   4444444444444444555555555555555566666666666666667777777777777777\
   88888888888888889999999999999999aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb\
   ccccccccccccccccddddddddddddddddeeeeeeeeeeeeeeeeffffffffffffffff"
and hexa2 =
  "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

<<function Hexsha.of_string_fast>>

<<function Hexsha.to_char>>

<<function Hexsha.to_string>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Hexsha.of_sha>>

<<function Hexsha.to_sha>>

<<function Hexsha.read>>
<<function Hexsha.write>>
@


\subsection*{[[version_control/hexsha.mli]]}

%-------------------------------------------------------------

<<version_control/hexsha.mli>>=
<<type Hexsha.t>>

<<signature Hexsha.of_sha>>
<<signature Hexsha.to_sha>>

<<signature Hexsha.read>>
<<signature Hexsha.write>>

<<signature Hexsha.is_hexsha>>

@


\subsection*{[[version_control/index.ml]]}

%-------------------------------------------------------------

<<version_control/index.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 * in index.ml and git_unix.ml
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Index.stat_info>>
<<type Index.mode>>
<<type Index.time>>
    
<<type Index.entry>>

(* less: extensions *)

<<type Index.t>>

<<constant Index.empty>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*
(* Index entries are sorted by the byte sequence that comprises the
   entry name; with a secondary comparison of the stage bits from the
   <ENTRY_FLAGS> if the entry name byte sequences are identical. *)
let compare_entries e1 e2 =
  match String.compare e1.name e2.name with
  | 0 -> Hash.Blob.compare e2.id e1.id
  | i -> i
*)

<<function Index.stat_info_of_lstats>>

<<function Index.mk_entry>>

<<function Index.perm_of_mode>>

<<function Index.mode_of_perm>>

(*****************************************************************************)
(* Add/Del *)
(*****************************************************************************)

<<function Index.remove_entry>>

<<function Index.add_entry>>

(*****************************************************************************)
(* tree of index *)
(*****************************************************************************)

<<type Index.dir>>
<<type Index.dir_entry>>
<<type Index.dirs>>

(* the code in this section derives from dulwich *)

<<function Index.add_dir>>

<<function Index.build_trees>>


<<function Index.tree_of_index>>

(*****************************************************************************)
(* index of tree *)
(*****************************************************************************)
(* See repository.set_worktree_and_index_to_tree() *)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Index.read_time>>

<<function Index.write_time>>

<<function Index.read_mode>>

<<function Index.write_mode>>

<<function Index.read_stat_info>>

<<function Index.write_stat_info>>
 

<<function Index.read_entry>>

<<function Index.write_entry>>




<<function Index.read_entries>>

<<function Index.read>>


<<function Index.write>>
@


\subsection*{[[version_control/index.mli]]}

%-------------------------------------------------------------

<<version_control/index.mli>>=

<<type Index.stat_info>>
<<type Index.mode>>
<<type Index.time>>
    
<<type Index.entry>>

<<type Index.t>>

<<signature Index.empty>>
<<signature Index.mk_entry>>

<<signature Index.stat_info_of_lstats>>
<<signature Index.mode_of_perm>>
<<signature Index.perm_of_mode>>

<<signature Index.read>>
<<signature Index.write>>

<<signature Index.remove_entry>>
<<signature Index.add_entry>>

<<signature Index.tree_of_index>>
@


\subsection*{[[version_control/main.ml]]}

%-------------------------------------------------------------

<<version_control/main.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of git, a distributed version control system.
 *
 * Some of the code derives from dulwich (a clone of git in Python)
 * and ocaml-git (another clone of git in OCaml).
 *
 * Main limitations compared to git/dulwich/ocaml-git:
 *  -??
 * 
 * todo:
 *  - a simplified version where just Marshall data instead of using
 *    the specific git format. Save many LOC?
 *  - ??
 * 
 * The code of ocamlgit uses code from 
 *  - ocaml-git
 *  - ocaml-hex
 *  - camlzip
 *  - extlib
 *  - uuidm
 * 
 * ocamlgit uses code from ocaml-git. However, ocamlgit is simpler because
 * it does not use fancy features of OCaml or fancy libraries:
 *  - no functor, include, module types, polymorphic variants, keyword args,
 *    or excessive nested modules. KISS.
 *  - no functorized Set and Map so no need for hash(), compare(), and equal()
 *    boilerplate functions everywhere
 *  - hardcoded use of SHA1, so no need functors taking Git.DIGEST and HashIO
 *  - no support for Mirage, so no need to parametrize many things,
 *    no need Fs module, no need lwt
 *  - no disk vs mem, just disk, so again need less functors
 *  - hardcoded use of zlib so no need functors taking inflate signature
 *  - no support for filename requiring special escapes
 *  - no use of Cstruct or Mstruct or Bigarray (simply use IO.ml and Bytes)
 *  - no logs
 *  - no fmt (use ocamldebug or ocamltarzan dumpers)
 *  - no sexplib
 * 
 * good stuff I took from ocaml-git:
 *  - dotgit (more readable than commondir in dulwich)
 *  - '/' operator (more readable than all those os.path.join in dulwich)
 *  - Hash.Tree.t, Hash.Commit.t, Hash.Blob.t more precise hash types
 *    (but they are not statically checked in ocamlgit)
 *  - TODO GRI (generalization of URI)
 * good stuff I wish I could take from dulwich:
 *  - hashtbl [] overloading, so can do r.refs["refs/tags/"+tag] = obj.id
 *    (thx to __setitem__ and __getitem__, but true that it also entails
 *     lots of boilerplate code)
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<constant Main.commands>>

<<constant Main.hcommands>>

<<function Main.usage>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Main.main>>
        
<<toplevel Main._1>>
@


\subsection*{[[version_control/merge.ml]]}

%-------------------------------------------------------------

<<version_control/merge.ml>>=
(*
https://github.com/schuhschuh/cmake-basis/blob/master/src/utilities/python/diff3.py
*)
@


\subsection*{[[version_control/objects.ml]]}

%-------------------------------------------------------------

<<version_control/objects.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Objects.t>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Objects.read>>

<<function Objects.write>>
@


\subsection*{[[version_control/objects.mli]]}

%-------------------------------------------------------------

<<version_control/objects.mli>>=

<<type Objects.t>>

<<signature Objects.read>>

<<signature Objects.write>>
@


\subsection*{[[version_control/refs.ml]]}

%-------------------------------------------------------------

<<version_control/refs.ml>>=
open Common

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Refs.refname>>

<<type Refs.t>>

<<type Refs.ref_content>>

<<constant Refs.default_head_content>>

<<function Refs.is_valid_refname>>

(*****************************************************************************)
(* Dumper *)
(*****************************************************************************)

<<function Refs.string_of_ref>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Refs.read>>

<<function Refs.write>>
@


\subsection*{[[version_control/refs.mli]]}

%-------------------------------------------------------------

<<version_control/refs.mli>>=

<<type Refs.refname>>

<<type Refs.t>>

<<type Refs.ref_content>>

<<signature Refs.default_head_content>>

<<signature Refs.is_valid_refname>>

<<signature Refs.read>>
<<signature Refs.write>>

<<signature Refs.string_of_ref>>
@


\subsection*{[[version_control/repository.ml]]}

%-------------------------------------------------------------

<<version_control/repository.ml>>=
<<copyright ocamlgit>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* API to access repository data (objects, index, refs, packs).
 *
 * less: use nested modules for objects, index, refs below?
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Repository.t>>

<<constant Repository.TODOOPERATOR>>

<<constant Repository.dirperm>>

<<type Repository.objectish>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Repository.hexsha_to_filename>>

<<function Repository.hexsha_to_dirname>>

<<function Repository.ref_to_filename>>

<<function Repository.index_to_filename>>

<<function Repository.with_file_out_with_lock>>


(* move in common.ml? *)
<<function Repository.with_opendir>>
    
(* move in common.ml? (but remove .git specific stuff) *)
<<function Repository.walk_dir>>

(*****************************************************************************)
(* Refs *)
(*****************************************************************************)

<<function Repository.read_ref>>

<<function Repository.follow_ref>>

<<function Repository.follow_ref_some>>

<<function Repository.add_ref_if_new>>

<<function Repository.del_ref>>

<<function Repository.set_ref_if_same_old>>

<<function Repository.set_ref>>
  

<<function Repository.write_ref>>

<<function Repository.all_refs>>

(*****************************************************************************)
(* Objects *)
(*****************************************************************************)

<<function Repository.read_obj>>

<<function Repository.read_commit>>
<<function Repository.read_tree>>
<<function Repository.read_blob>>

<<function Repository.read_objectish>>

<<function Repository.add_obj>>

<<function Repository.has_obj>>

(*****************************************************************************)
(* Index *)
(*****************************************************************************)

<<function Repository.read_index>>

<<function Repository.write_index>>

    
<<function Repository.content_from_path_and_unix_stat>>

<<function Repository.add_in_index>>

(*****************************************************************************)
(* Commit *)
(*****************************************************************************)

<<function Repository.commit_index>>
  
(*****************************************************************************)
(* Checkout and reset *)
(*****************************************************************************)

<<function Repository.build_file_from_blob>>


<<function Repository.set_worktree_and_index_to_tree>>

(*****************************************************************************)
(* Packs *)
(*****************************************************************************)

(*****************************************************************************)
(* Repo init/open *)
(*****************************************************************************)

<<function Repository.init>>

<<function Repository.open_>>

<<function Repository.find_dotgit_root_and_open>>
@


\subsection*{[[version_control/repository.mli]]}

%-------------------------------------------------------------

<<version_control/repository.mli>>=

<<type Repository.t>>

<<type Repository.objectish>>


(* repo *)
<<signature Repository.init>>
<<signature Repository.open_>>
<<signature Repository.find_dotgit_root_and_open>>

(* objects *)
<<signature Repository.read_obj>>
<<signature Repository.read_objectish>>
<<signature Repository.read_commit>>
<<signature Repository.read_tree>>
<<signature Repository.read_blob>>
<<signature Repository.add_obj>>
<<signature Repository.has_obj>>

(* refs *)
<<signature Repository.read_ref>>
<<signature Repository.write_ref>>
<<signature Repository.follow_ref>>
<<signature Repository.follow_ref_some>>
<<signature Repository.all_refs>>
<<signature Repository.set_ref>>
<<signature Repository.del_ref>>
(* atomic op *)
<<signature Repository.add_ref_if_new>>
<<signature Repository.set_ref_if_same_old>>

(* index *)
<<signature Repository.read_index>>
<<signature Repository.write_index>>
<<signature Repository.add_in_index>>

<<signature Repository.commit_index>>
<<signature Repository.set_worktree_and_index_to_tree>>

(* packs *)

(* misc *)
<<signature Repository.walk_dir>>

@


\subsection*{[[version_control/sha1.ml]]}

%-------------------------------------------------------------

<<version_control/sha1.ml>>=
<<copyright uuidm>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below comes from: https://github.com/dbuenzli/uuidm 
 * (this code is also copy-pasted and used in git-mirage)
 * 
 * alternatives:
 *  - https://github.com/vincenthz/ocaml-sha 
 *    not maintained and uses C code
 *  - https://github.com/xavierleroy/cryptokit/
 *    by Xavier Leroy, but also uses C code
 *  - nocrypto
 *    seems like the official crypto lib, but also uses C code
 *  - md5sum, produces 128-bit hash value (sha1 is 20 bytes so 160 bits)
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Sha1.t>>

<<function Sha1.is_sha>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Sha1.read>>

<<function Sha1.write>>

(* start of copy-pasted code from uuidm *)

<<function Sha1.sha1>>
@


\subsection*{[[version_control/sha1.mli]]}

%-------------------------------------------------------------

<<version_control/sha1.mli>>=
<<type Sha1.t>>

<<signature Sha1.sha1>>

<<signature Sha1.read>>
<<signature Sha1.write>>

<<signature Sha1.is_sha>>
@


\subsection*{[[version_control/tree.ml]]}

%-------------------------------------------------------------

<<version_control/tree.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Tree.perm>>

<<type Tree.entry>>

<<type Tree.t>>

<<type Tree.hash>>

(*****************************************************************************)
(* Walk *)
(*****************************************************************************)
<<function Tree.walk_tree>>

<<function Tree.walk_trees>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Tree.perm_of_string>>

<<function Tree.string_of_perm>>

<<function Tree.read_entry>>

<<function Tree.write_entry>>
  

<<function Tree.read>>


<<function Tree.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Tree.show>>
@


\subsection*{[[version_control/tree.mli]]}

%-------------------------------------------------------------

<<version_control/tree.mli>>=

<<type Tree.perm>>

<<type Tree.entry>>

<<type Tree.t>>

<<type Tree.hash>>


<<signature Tree.read>>
<<signature Tree.write>>

<<signature Tree.show>>

<<signature Tree.walk_tree>>

<<signature Tree.walk_trees>>

@


\subsection*{[[version_control/unzip.ml]]}

%-------------------------------------------------------------

<<version_control/unzip.ml>>=
<<copyright ocaml-unzip>>

<<type Unzip.huffman>>


<<type Unzip.adler32>>

<<type Unzip.window>>

<<type Unzip.state>>

<<type Unzip.t>>

<<type Unzip.error_msg>>

<<exception Unzip.Error>>

<<function Unzip.error>>

(* ************************************************************************ *)
(* HUFFMAN TREES *)

<<function Unzip.tree_depth>>

<<function Unzip.tree_compress>>

<<function Unzip.make_huffman>>

(* ************************************************************************ *)
(* ADLER32 (CRC) *)

<<function Unzip.adler32_create>>

<<function Unzip.adler32_update>>

<<function Unzip.adler32_read>>

(* ************************************************************************ *)
(* WINDOW *)

<<constant Unzip.window_size>>
<<constant Unzip.buffer_size>>

<<function Unzip.window_create>>

<<function Unzip.window_slide>>

<<function Unzip.window_add_bytes>>

<<function Unzip.window_add_char>>

<<function Unzip.window_get_last_char>>

<<function Unzip.window_available>>

<<function Unzip.window_checksum>>

(* ************************************************************************ *)

<<constant Unzip.len_extra_bits_tbl>>
<<constant Unzip.len_base_val_tbl>>
<<constant Unzip.dist_extra_bits_tbl>>
<<constant Unzip.dist_base_val_tbl>>
<<constant Unzip.code_lengths_pos>>

<<constant Unzip.fixed_huffman>>

<<function Unzip.get_bits>>

<<function Unzip.get_bit>>

<<function Unzip.get_rev_bits>>

<<function Unzip.reset_bits>>

<<function Unzip.add_bytes>>

<<function Unzip.add_char>>

<<function Unzip.add_dist_one>>

<<function Unzip.add_dist>>

<<function Unzip.apply_huffman>>

<<function Unzip.inflate_lengths>>

<<function Unzip.inflate_loop>>

<<function Unzip.inflate_data>>

<<function Unzip.inflate_init>>

<<function Unzip.inflate>>
@


\subsection*{[[version_control/unzip.mli]]}

%-------------------------------------------------------------

<<version_control/unzip.mli>>=
(*
 * Unzip - inflate format decompression algorithm
 * Copyright (C) 2004 Nicolas Cannasse
 * Compliant with RFC 1950 and 1951
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version,
 * with the special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *)

(** Decompression algorithm.

  Unzip decompression algorithm is compliant with RFC 1950 and 1951 which
  are describing the "inflate" algorithm used in most popular file formats.
  This format is also the one used by the popular ZLib library.  
*)

<<type Unzip.error_msg>>

<<exception Unzip.Error>>

<<signature Unzip.inflate>>

type t

<<signature Unzip.inflate_init>>
<<signature Unzip.inflate_data>>
@


\subsection*{[[version_control/user.ml]]}

%-------------------------------------------------------------

<<version_control/user.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type User.sign>>

<<type User.tz_offset>>

<<type User.t>>

(* less: default_tz_offset ? *)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function User.sign_of_char>>

<<function User.char_of_sign>>

<<function User.read>>

<<function User.write_date>>

<<function User.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function User.string_of_date>>

@


\subsection*{[[version_control/user.mli]]}

%-------------------------------------------------------------

<<version_control/user.mli>>=

<<type User.sign>>

<<type User.tz_offset>>

<<type User.t>>

<<signature User.read>>
<<signature User.write>>

<<signature User.string_of_date>>
@


\subsection*{[[version_control/zlib.ml]]}

%-------------------------------------------------------------

<<version_control/zlib.ml>>=
<<copyright camlzip>>

<<exception Zlib.Error>>

<<toplevel Zlib._1>>

type stream

<<type Zlib.flush_command>>

external deflate_init: int -> bool -> stream = "camlzip_deflateInit"
external deflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_deflate_bytecode" "camlzip_deflate"
external deflate_end: stream -> unit = "camlzip_deflateEnd"

external inflate_init: bool -> stream = "camlzip_inflateInit"
external inflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_inflate_bytecode" "camlzip_inflate"
external inflate_end: stream -> unit = "camlzip_inflateEnd"

external update_crc: int32 -> bytes -> int -> int -> int32
                   = "camlzip_update_crc32"
external update_crc_string: int32 -> string -> int -> int -> int32
                   = "camlzip_update_crc32"

<<constant Zlib.buffer_size>>

<<function Zlib.compress>>

<<function Zlib.compress_direct>>

<<function Zlib.uncompress>>
@


\subsection*{[[version_control/zlib.mli]]}

%-------------------------------------------------------------

<<version_control/zlib.mli>>=
<<copyright camlzip>>
open Common

<<exception Zlib.Error>>

<<signature Zlib.compress>>

<<signature Zlib.compress_direct>>

<<signature Zlib.uncompress>>

type stream

<<type Zlib.flush_command>>

external deflate_init: int -> bool -> stream = "camlzip_deflateInit"
external deflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_deflate_bytecode" "camlzip_deflate"
external deflate_end: stream -> unit = "camlzip_deflateEnd"

external inflate_init: bool -> stream = "camlzip_inflateInit"
external inflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_inflate_bytecode" "camlzip_inflate"
external inflate_end: stream -> unit = "camlzip_inflateEnd"

external update_crc: int32 -> bytes -> int -> int -> int32
                   = "camlzip_update_crc32"
external update_crc_string: int32 -> string -> int -> int -> int32
                   = "camlzip_update_crc32"
@


