\section{[[version_control/]]}

\subsection*{[[version_control/IO_.ml]]}

%-------------------------------------------------------------

<<version_control/IO_.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function IO_.with_close_out>>

<<function IO_.read_string_and_stop_char>>

<<function IO_.read_int_and_nullbyte>>

<<function IO_.read_key_space_value_newline>>
@


\subsection*{[[version_control/IO_.mli]]}

%-------------------------------------------------------------

<<version_control/IO_.mli>>=

<<signature IO_.read_string_and_stop_char>>

<<signature IO_.read_int_and_nullbyte>>

<<signature IO_.read_key_space_value_newline>>

<<signature IO_.with_close_out>>
@


\subsection*{[[version_control/blob.ml]]}

%-------------------------------------------------------------

<<version_control/blob.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Blob.t>>

<<type Blob.hash>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Blob.read>>

<<function Blob.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Blob.show>>
@


\subsection*{[[version_control/blob.mli]]}

%-------------------------------------------------------------

<<version_control/blob.mli>>=

<<type Blob.t>>

<<type Blob.hash>>

<<signature Blob.read>>
<<signature Blob.write>>

<<signature Blob.show>>
@


\subsection*{[[version_control/change.ml]]}

%-------------------------------------------------------------

<<version_control/change.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)
<<type Change.content>>

<<type Change.entry>>

<<type Change.t>>
@


\subsection*{[[version_control/change.mli]]}

%-------------------------------------------------------------

<<version_control/change.mli>>=

<<type Change.content>>

<<type Change.entry>>

<<type Change.t>>
@


\subsection*{[[version_control/changes.ml]]}

<<function Changes.skip_tree_and_adjust_path>>=
let skip_tree_and_adjust_path read_blob dirpath entry_opt =
  match entry_opt with
  | Some { Tree.perm = Tree.Dir } -> None
  | Some { Tree.perm = Tree.Commit } -> failwith "submodule not supported"
  | Some x -> Some ({ Change.
    path = Filename.concat dirpath x.Tree.name;
    mode = Index.mode_of_perm x.Tree.perm;
    
    (* todo: do that later? once know we will return a change with this entry?
     * make it lazy?
     *)
    content = lazy (read_blob x.Tree.node);
  }, x.Tree.node)
  | None -> None
@

<<function Changes.content_from_path_and_stat_index>>=
(* similar to Repository.content_from_path_and_unix_stat *)
let content_from_path_and_stat_index path stat_info =
  match stat_info.Index.mode with
  | Index.Link ->
    Unix.readlink path
  | Index.Normal | Index.Exec ->
      path |> Common.with_file_in (fun ch ->
        ch |> IO.input_channel |> IO.read_all
      )
  | Index.Gitlink -> failwith "submodule not supported"
@

<<function Changes.changes_tree_vs_tree>>=
(* see also Cmd_diff.changes_index_vs_worktree
 *     and  Cmd_status.changes_index_vs_HEAD
 *)
let changes_tree_vs_tree read_tree read_blob tree1 tree2 =
  let changes = ref [] in
  let add x = Common.push x changes in
  Tree.walk_trees read_tree "" (fun dirpath entry1_opt entry2_opt ->
    (* if entries are directories, then we would be called again
     * with their individual files, so safe to skip the dir entries.
     *)
    let entry1_opt = skip_tree_and_adjust_path read_blob dirpath entry1_opt in
    let entry2_opt = skip_tree_and_adjust_path read_blob dirpath entry2_opt in
    
    match entry1_opt, entry2_opt with
    | None, None -> ()
    | Some (a, asha), Some (b, bsha) ->
      (match () with
      (* file type changed reported as delete/add (meh) *)
      | _ when a.Change.mode <> b.Change.mode ->
        add (Change.Del a);
        add (Change.Add b);
      | _ when asha <> bsha ->
        add (Change.Modify (a, b))
      | _ -> ()
      )
    | Some (a,_), None -> add (Change.Del a)
    | None, Some (b,_) -> add (Change.Add b)
  ) tree1 tree2 ;
  List.rev !changes
@


<<function Changes.changes_index_vs_tree>>=
(* some commonalities with Repository.set_worktree_and_index_to_tree *)
let changes_index_vs_tree read_tree index treeid =
  let tree = read_tree treeid in

  let h_in_index_and_head = Hashtbl.create 101 in
  let hindex = 
    index 
    |> List.map (fun entry -> entry.Index.name, entry)
    |> Hashtbl_.of_list
  in
  let changes = ref [] in

  tree |> Tree.walk_tree read_tree "" (fun relpath entry_head ->
    let perm = entry_head.Tree.perm in
    match perm with
    | Tree.Dir -> ()
    | Tree.Commit -> failwith "submodule not yet supported"
    | Tree.Normal | Tree.Exec | Tree.Link ->
      try
        let entry_index = Hashtbl.find hindex relpath in
        Hashtbl.add h_in_index_and_head relpath true;
        (* less: if change mode, then report as del/add *)
        if entry_head.Tree.node <> entry_index.Index.id
        then changes |> Common.push (Change.Modify (
          { Change.path = relpath; 
            mode = Index.mode_of_perm perm; 
            content = lazy (raise (Impossible "not called")); },
          { Change.path = relpath; 
            mode = entry_index.Index.stats.Index.mode;
            content = lazy (raise (Impossible "not called")); }
        ))
      with Not_found ->
        changes |> Common.push (Change.Del { Change.
             path = relpath;
             mode = Index.mode_of_perm perm;
             content = lazy (raise (Impossible "not called"));
                                           });
  );
  index |> List.iter (fun entry ->
    if not (Hashtbl.mem h_in_index_and_head entry.Index.name)
    then changes |> Common.push (Change.Add { Change.
             path = entry.Index.name;
             mode = entry.Index.stats.Index.mode;                                            content = lazy (raise (Impossible "not called")); }
    )
  );
  (* less: sort by path *)
  List.rev !changes
@


%-------------------------------------------------------------

<<version_control/changes.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * todo: 
 *  - rename detection
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Changes.skip_tree_and_adjust_path>>

<<function Changes.content_from_path_and_stat_index>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Changes.changes_tree_vs_tree>>

<<function Changes.changes_worktree_vs_index>>

<<function Changes.changes_index_vs_tree>>
@


\subsection*{[[version_control/changes.mli]]}

<<signature Changes.changes_tree_vs_tree>>=
(* for git show commit *)
val changes_tree_vs_tree: 
  (Tree.hash -> Tree.t) ->
  (Blob.hash -> Change.content) ->
  Tree.t -> Tree.t -> Change.t list
@


<<signature Changes.changes_index_vs_tree>>=
(* for git status (to compare index vs HEAD) *)
val changes_index_vs_tree:
  (Tree.hash -> Tree.t) ->
  Index.t -> Tree.hash -> Change.t list
@


%-------------------------------------------------------------

<<version_control/changes.mli>>=

<<signature Changes.changes_tree_vs_tree>>

<<signature Changes.changes_worktree_vs_index>>

<<signature Changes.changes_index_vs_tree>>
@


\subsection*{[[version_control/client.ml]]}

%-------------------------------------------------------------

<<version_control/client.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Client.t>>
@


\subsection*{[[version_control/client.mli]]}

%-------------------------------------------------------------

<<version_control/client.mli>>=

<<type Client.t>>
@


\subsection*{[[version_control/client_git.ml]]}

%-------------------------------------------------------------

<<version_control/client_git.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Client_git.mk_client>>
@


\subsection*{[[version_control/client_git.mli]]}

%-------------------------------------------------------------

<<version_control/client_git.mli>>=

<<signature Client_git.mk_client>>
@


\subsection*{[[version_control/client_local.ml]]}


<<function Client_local.collect_filetree>>=
let rec collect_filetree read_tree treeid have_sha =
  let tree = read_tree treeid in
  tree |> List.iter (fun entry ->
    let sha = entry.Tree.node in
    if not (Hashtbl.mem have_sha sha) then begin
      Hashtbl.add have_sha sha true;
      match entry.Tree.perm with
      | Tree.Normal | Tree.Exec | Tree.Link -> ()
      | Tree.Dir ->  collect_filetree read_tree sha have_sha
      | Tree.Commit -> failwith "submodule not supported yet"
    end
  )
@


<<function Client_local.fetch_objects>>=
let fetch_objects src dst =
  (* less: determine_wants from pull command *)
  let top_wanted_commits = [Repository.follow_ref_some src Refs.Head] in
  (* less: shallows? unshallows? *)
  let top_common_commits = find_top_common_commits src dst in
  iter_missing_objects top_common_commits top_wanted_commits src 
    (fun sha1 obj_opt ->
    (* less: opti: copy raw files directly without unmarshalling/marshalling *)
    let obj = 
      match obj_opt with
      | None -> Repository.read_obj src sha1
      | Some obj -> obj
    in
    (* todo: count objects progress *)
    (* pr2 (spf "adding %s" (Hexsha.of_sha sha1)); *)
    let sha2 = Repository.add_obj dst obj in
    assert (sha1 = sha2)
  )
@

<<signature Client_local.mk_client>>=
val mk_client: Common.filename -> Client.t
@
<<function Client_local.mk_client>>=
let mk_client path =
  { Client.
    url = path;
    fetch = (fun dst ->
      let src = Repository.open_ path in
      fetch_objects src dst;
      (* less: all_refs *)
      Repository.follow_ref_some src Refs.Head
   );
  }
@

%-------------------------------------------------------------

<<version_control/client_local.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Graph walkers *)
(*****************************************************************************)

<<type Client_local.graph_walker>>

<<function Client_local.ml_graph_walker>>

<<function Client_local.collect_filetree>>
    
(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
 
<<function Client_local.find_top_common_commits>>

<<function Client_local.iter_missing_objects>>


<<function Client_local.fetch_objects>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Client_local.mk_client>>
@


\subsection*{[[version_control/client_local.mli]]}

%-------------------------------------------------------------

<<version_control/client_local.mli>>=

<<signature Client_local.mk_client>>
@


\subsection*{[[version_control/clients.ml]]}

%-------------------------------------------------------------

<<version_control/clients.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Clients.client_of_url>>
@


\subsection*{[[version_control/clients.mli]]}



%-------------------------------------------------------------

<<version_control/clients.mli>>=

<<signature Clients.client_of_url>>
@


\subsection*{[[version_control/cmd.ml]]}

%-------------------------------------------------------------

<<version_control/cmd.ml>>=

<<type Cmd.t>>

<<exception Cmd.ShowUsage>>
@


\subsection*{[[version_control/cmd_add.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_add.ml>>=
<<copyright gut>>
open Common

<<function Cmd_add.add>>

<<constant Cmd_add.cmd>>
@


\subsection*{[[version_control/cmd_branch.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_branch.ml>>=
<<copyright gut>>
open Common

<<function Cmd_branch.list_branches>>

<<function Cmd_branch.create_branch>>

<<function Cmd_branch.delete_branch>>

(* less: rename_branch *)

<<constant Cmd_branch.del_flag>>
<<constant Cmd_branch.del_force>>

<<constant Cmd_branch.cmd>>
@


\subsection*{[[version_control/cmd_checkout.ml]]}

<<function Cmd_checkout.update>>=
(* Your branch is up-to-date with 'origin/master'. *)
let update r =
  raise Todo
@

%-------------------------------------------------------------

<<version_control/cmd_checkout.ml>>=
<<copyright gut>>
open Common

<<function Cmd_checkout.checkout>>

<<function Cmd_checkout.update>>

<<constant Cmd_checkout.cmd>>
@


\subsection*{[[version_control/cmd_clone.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_clone.ml>>=
<<copyright gut>>
open Common

<<function Cmd_clone.clone>>

(* todo: when clone then repo should have a "refs/remotes/origin/master" *)

<<constant Cmd_clone.cmd>>
@


\subsection*{[[version_control/cmd_commit.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_commit.ml>>=
<<copyright gut>>
open Common

<<function Cmd_commit.commit>>

<<constant Cmd_commit.author>>
<<constant Cmd_commit.committer>>
<<constant Cmd_commit.message>>

<<constant Cmd_commit.cmd>>
@


\subsection*{[[version_control/cmd_diff.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_diff.ml>>=
<<copyright gut>>
open Common

<<function Cmd_diff.diff_worktree_vs_index>>

<<constant Cmd_diff.cmd>>
@


\subsection*{[[version_control/cmd_dump.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_dump.ml>>=
<<copyright gut>>
open Common

<<constant Cmd_dump.raw>>
<<constant Cmd_dump.index>>

<<function Cmd_dump.dump_object>>

<<function Cmd_dump.dump_index>>

<<function Cmd_dump.dump>>

<<constant Cmd_dump.cmd>>
@


\subsection*{[[version_control/cmd_help.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_help.ml>>=
<<copyright gut>>
open Common

<<constant Cmd_help.list_extra>>

<<constant Cmd_help.cmd>>
@


\subsection*{[[version_control/cmd_init.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_init.ml>>=
<<copyright gut>>
open Common

(* less: let bare = ref false *)

<<constant Cmd_init.cmd>>
@


\subsection*{[[version_control/cmd_log.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_log.ml>>=
<<copyright gut>>
open Common

(* todo: git log --graph --oneline --decorate --all *)

<<function Cmd_log.print_commit>>

<<function Cmd_log.print_change>>


<<constant Cmd_log.name_status>>

<<function Cmd_log.log>>

<<constant Cmd_log.cmd>>
@


\subsection*{[[version_control/cmd_merge.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_merge.ml>>=
@


\subsection*{[[version_control/cmd_pull.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_pull.ml>>=
<<copyright gut>>
open Common

<<function Cmd_pull.pull>>

<<constant Cmd_pull.cmd>>
@


\subsection*{[[version_control/cmd_push.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_push.ml>>=
<<copyright gut>>
open Common

<<function Cmd_push.push>>

<<constant Cmd_push.cmd>>
@


\subsection*{[[version_control/cmd_reset.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_reset.ml>>=
<<copyright gut>>
open Common

<<function Cmd_reset.reset_hard>>

<<constant Cmd_reset.hard>>
<<constant Cmd_reset.soft>>
<<constant Cmd_reset.mixed>>

<<constant Cmd_reset.cmd>>
@


\subsection*{[[version_control/cmd_rm.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_rm.ml>>=
<<copyright gut>>
open Common

<<function Cmd_rm.rm>>

<<constant Cmd_rm.cmd>>
@


\subsection*{[[version_control/cmd_show.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_show.ml>>=
<<copyright gut>>
open Common

<<function Cmd_show.show>>

<<constant Cmd_show.cmd>>
@


\subsection*{[[version_control/cmd_status.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_status.ml>>=
<<copyright gut>>
open Common

<<type Cmd_status.status>>

<<function Cmd_status.changes_index_vs_HEAD>>

<<function Cmd_status.untracked>>


<<function Cmd_status.status_of_repository>>

<<function Cmd_status.print_change_long>>


<<function Cmd_status.print_status_long>>
    

<<function Cmd_status.print_status_short>>

<<constant Cmd_status.short_format>>

<<function Cmd_status.status>>

<<constant Cmd_status.cmd>>
@


\subsection*{[[version_control/cmd_test.ml]]}

%-------------------------------------------------------------

<<version_control/cmd_test.ml>>=
<<copyright gut>>
open Common

<<function Cmd_test.test_sha1>>

<<constant Cmd_test.cmd>>

@


\subsection*{[[version_control/cmds.ml]]}

%-------------------------------------------------------------

<<version_control/cmds.ml>>=

<<constant Cmds.main_commands>>

<<constant Cmds.extra_commands>>
@


\subsection*{[[version_control/commit.ml]]}


<<signature Commit.collect_ancestors>>=
val collect_ancestors: 
  (hash -> t) ->  hash list -> (hash, bool) Hashtbl.t -> 
  (hash, bool) Hashtbl.t
@
<<function Commit.collect_ancestors>>=
(* similar to walk_history but with exposed hdone hash *)
let collect_ancestors read_commit top_commits hdone =
  let hcommits = Hashtbl.create 101 in
  let rec aux sha =
    if Hashtbl.mem hdone sha
    then ()
    else begin
      Hashtbl.add hdone sha true;
      Hashtbl.add hcommits sha true;
      let commit = read_commit sha in
      commit.parents |> List.iter aux
    end
  in
  top_commits |> List.iter aux;
  hcommits
@

%-------------------------------------------------------------

<<version_control/commit.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Commit.t>>
<<type Commit.hash>>

(*****************************************************************************)
(* API *)
(*****************************************************************************)

(* for git log *)

<<function Commit.walk_history>>

(* for git pull *)
<<function Commit.collect_ancestors>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Commit.read>>

<<function Commit.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Commit.show>>
@


\subsection*{[[version_control/commit.mli]]}

%-------------------------------------------------------------

<<version_control/commit.mli>>=

<<type Commit.t>>
<<type Commit.hash>>


<<signature Commit.read>>
<<signature Commit.write>>

<<signature Commit.show>>

<<signature Commit.collect_ancestors>>

<<signature Commit.walk_history>>
@


\subsection*{[[version_control/compression.ml]]}

%-------------------------------------------------------------

<<version_control/compression.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Compression/decompression wrappers.
 * 
 * alternatives:
 *  * https://github.com/ygrek/ocaml-extlib/src/unzip.ml
 *    just decompression (inflate), pretty small: 450 LOC
 *  - https://github.com/mirage/decompress
 *    compression/decompression, seems complete, but pretty big. 
 *    used by https://github.com/mirage/ocaml-git
 *  * https://github.com/xavierleroy/camlzip
 *    uses C code (some of the code in ocaml-git uses ML code from camlzip)
 *  - https://github.com/madroach/ocaml-zlib
 *    ??
 *  - https://github.com/samoht/ocaml-lz77 
 *    copy-pasted in decompress, but too simple. Does not
 *    support right API where can compress/decompress strings.
 *  - libflate in plan9 :)
 * 
 * Currently used solutions are marked with a '*' above.
 *)

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Compression.decompress>>

<<function Compression.compress>>
@


\subsection*{[[version_control/compression.mli]]}

%-------------------------------------------------------------

<<version_control/compression.mli>>=

<<signature Compression.decompress>>
<<signature Compression.compress>>
@


\subsection*{[[version_control/diff.ml]]}

%
%<<function Diff.diff_buggy>>=
%(*
%SimpleDiff is buggy!
%Here is an example of output after an ogit diff (with some debugging 
%information):
%
%diff --git a/authors.txt b/authors.txt
%["Yoann Padioleau\n"; "\n"; "except \n"; " - lex/ by Xavier Leroy (from ocaml)\n"; " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n"; " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n"; " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n"; " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n"; " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n"; " - commons/IO.ml by Nicolas Canasse (from exblib)\n"]
%["Yoann Padioleau\n"; "\n"; "xxx\n"; "except \n"; " - lex/ by Xavier Leroy (from ocaml)\n"; " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n"; " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n"; " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n"; " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n"; " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n"; " - commons/IO.ml by Nicolas Canasse (from exblib)\n"]
%[(()); Tag1 (("Yoann Padioleau\n")); Tag2 (("\n", "xxx\n", "except \n", " - lex/ by Xavier Leroy (from ocaml)\n", " - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)\n", " - version_control/sha.ml by Daniel Bunzli (from uuidm)\n", " - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)\n", " - version_control/zlib.ml by Xavier Leroy (from camlzip)\n", " - version_control/unzip.ml by Nicolas Canasse (from extlib)\n", " - commons/IO.ml by Nicolas Canasse (from exblib)\n"))]
%+Yoann Padioleau
% 
% xxx
% except 
%  - lex/ by Xavier Leroy (from ocaml)
%  - lib_core/stdlib/ by Xavier Leroy et al. (from ocaml)
%  - version_control/sha.ml by Daniel Bunzli (from uuidm)
%  - version_control/hexsha.ml by Thomas Gazagnaire (from ocaml-hex)
%  - version_control/zlib.ml by Xavier Leroy (from camlzip)
%  - version_control/unzip.ml by Nicolas Canasse (from extlib)
%  - commons/IO.ml by Nicolas Canasse (from exblib)
%
%-----------
%SimpleDiff says the diff is the addition of 'Yoann Padioleau' but it's not!
%It's in both content. The diff should be the addition of 'xxx'.
%*)
%
%let diff_buggy str1 str2 =
%  let xs = split_lines str1 in
%  let ys = split_lines str2 in
%  pr2_gen xs;
%  pr2_gen ys;
%  let res = SimpleDiff.get_diff (Array.of_list xs) (Array.of_list ys) in
%  pr2_gen res;
%  res |> List.map (function
%    | SimpleDiff.Equal arr   -> 
%      arr |> Array.to_list |> List.map (fun x -> Equal x)
%    | SimpleDiff.Deleted arr -> 
%      arr |> Array.to_list |> List.map (fun x -> Deleted x)
%    | SimpleDiff.Added arr   -> 
%      arr |> Array.to_list |> List.map (fun x -> Added x)
%  )
%@
%module SimpleDiff = Diff_simple.Make(String)



%-------------------------------------------------------------

<<version_control/diff.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Compute the differences between 2 files line-wise.
 *
 * alternatives:
 *  - simple diff: https://github.com/gjaldon/simple-diff
 *    (an ocaml port of https://github.com/paulgb/simplediff )
 *    http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1988/8807/8807c/8807c.htm
 *    simple, but no diff -u support by default
 *    and seems buggy!
 *  - myers: https://github.com/leque/ocaml-diff port of
 *    "Eugene Myers, An O(ND) Difference Algorithm and Its Variations, 
 *    Algorithmica Vol. 1 No. 2, pp. 251-266, 1986."
 *  - patience diff: https://github.com/janestreet/patdiff
 *  https://stackoverflow.com/questions/42635889/myers-diff-algorithm-vs-hunt-mcilroy-algorithm
 *    support also colored output, and word diff, but heavily modularized
 *  - plan9 diff (in plan9/utilities/string/diff/)
 *    not myers's diff
 *  - gnu diff (in plan9/ape_cmd/diff)
 *    use myers?
 *  - http://pynash.org/2013/02/26/diff-in-50-lines/ 
 *    (in python, and talk about python difflib)
 *  - Heckle diff mentionned in diff3.py
 *    "P. Heckel. ``A technique for isolating differences between files.''
 *     Communications of the ACM, Vol. 21, No. 4, page 264, April 1978."
 * 
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Diff.item>>

<<type Diff.diff_elem>>

<<type Diff.diff>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)
<<function Diff.split_lines>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<module Diff.StringDiff>>

<<function Diff.diff>>
@


\subsection*{[[version_control/diff.mli]]}

%-------------------------------------------------------------

<<version_control/diff.mli>>=

<<type Diff.item>>

<<type Diff.diff_elem>>

<<type Diff.diff>>


<<signature Diff.diff>>
@


\subsection*{[[version_control/diff3.ml]]}


%-------------------------------------------------------------

<<version_control/diff3.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*
 * alternatives:
 *  - gnu diff3, in C
 *    https://www.gnu.org/software/diffutils/manual/html_node/diff3-Merging.html
 *    apparently by Randy Smith in 1988 and popularized by CVS
 *  - Perl Text::Diff3
 *    http://search.cpan.org/~tociyuki/Text-Diff3-0.10/lib/Text/Diff3.pm
 *    with good example of use in man page
 *  - python diff3
 *    https://github.com/schuhschuh/cmake-basis/blob/master/src/utilities/python/diff3.py
 *    apparently translation of the Perl code, itself a translation of the
 *    C code
 *  - formal investigation of diff3:
 *    http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf
 * 
 *)
@


\subsection*{[[version_control/diff_myers.ml]]}

%-------------------------------------------------------------

<<version_control/diff_myers.ml>>=
<<copyright ocaml-diff-myers>>

<<type Diff_myers.common>>

<<type Diff_myers.edit>>

module type SeqType = sig
  type t
  type elem
  val get : t -> int -> elem
  val length : t -> int
end

module type S = sig
  type t
  type elem

  val lcs :
      ?equal:(elem -> elem -> bool) ->
      t -> t -> elem common list

  val diff :
      ?equal:(elem -> elem -> bool) ->
      t -> t -> elem edit list

  val fold_left :
      ?equal:(elem -> elem -> bool) ->
      f:('a -> elem edit -> 'a) ->
      init:'a ->
      t -> t -> 'a

  val iter :
      ?equal:(elem -> elem -> bool) ->
      f:(elem edit -> unit) ->
      t -> t -> unit
end

module Make(M : SeqType) : (S with type t = M.t and type elem = M.elem) = struct
  type t = M.t
  type elem = M.elem

  let lcs ?(equal = (=)) a b =
    let n = M.length a in
    let m = M.length b in
    let mn = m + n in
    let sz = 2 * mn + 1 in
    let vd = Array.make sz 0 in
    let vl = Array.make sz 0 in
    let vr = Array.make sz [] in
    let get v i = Array.get v (i + mn) in
    let set v i x = Array.set v (i + mn) x in
    let finish () =
      let rec loop i maxl r =
        if i > mn then
          List.rev r
        else if get vl i > maxl then
          loop (i + 1) (get vl i) (get vr i)
        else
          loop (i + 1) maxl r
      in loop (- mn) 0 []
    in
    if mn = 0 then
      []
    else
      (* For d <- 0 to mn Do *)
      let rec dloop d =
        assert (d <= mn);
        (* For k <- -d to d in steps of 2 Do *)
        let rec kloop k =
          if k > d then
            dloop @@ d + 1
          else
            let x, l, r =
              if k = -d || (k <> d && get vd (k - 1) < get vd (k + 1)) then
                get vd (k + 1), get vl (k + 1), get vr (k + 1)
              else
                get vd (k - 1) + 1, get vl (k - 1), get vr (k - 1)
            in
            let x, y, l, r =
              let rec xyloop x y l r =
                if x < n && y < m && equal (M.get a x) (M.get b y) then
                  xyloop (x + 1) (y + 1) (l + 1) (`Common(x, y, M.get a x) :: r)
                else
                  x, y, l, r
              in xyloop x (x - k) l r
            in
            set vd k x;
            set vl k l;
            set vr k r;
            if x >= n && y >= m then
              (* Stop *)
              finish ()
            else
              kloop @@ k + 2
        in kloop @@ -d
      in dloop 0

  let fold_left ?(equal = (=)) ~f ~init a b =
    let ff x y = f y x in
    let fold_map f g x from to_ init =
      let rec loop i init =
        if i >= to_ then
          init
        else
          loop (i + 1) (f (g i @@ M.get x i) init)
      in loop from init
    in
    let added i x = `Added (i, x) in
    let removed i x = `Removed (i, x) in
    let rec loop cs apos bpos init =
      match cs with
      | [] ->
          init
          |> fold_map ff removed a apos (M.length a)
          |> fold_map ff added b bpos (M.length b)
      | `Common (aoff, boff, _) as e :: rest ->
          init
          |> fold_map ff removed a apos aoff
          |> fold_map ff added b bpos boff
          |> ff e
          |> loop rest (aoff + 1) (boff + 1)
    in loop (lcs ~equal a b) 0 0 init

  let diff ?(equal = (=)) a b =
    fold_left ~equal ~f:(fun xs x -> x::xs) ~init:[] a b

  let iter ?(equal = (=)) ~f a b =
    fold_left a b
      ~equal
      ~f:(fun () x -> f x)
      ~init:()
end
@


\subsection*{[[version_control/diff_myers.mli]]}

%-------------------------------------------------------------

<<version_control/diff_myers.mli>>=
(**
   An implementation of Eugene Myers' O(ND) Difference Algorithm\[1\].
   This implementation is a port of util.lcs module of
   {{:http://practical-scheme.net/gauche} Gauche Scheme interpreter}.

   - \[1\] Eugene Myers, An O(ND) Difference Algorithm and Its Variations, Algorithmica Vol. 1 No. 2, pp. 251-266, 1986.
 *)

<<type Diff_myers.common>>

(** an element of lcs of seq1 and seq2 *)

<<type Diff_myers.edit>>

(** an element of diff of seq1 and seq2. *)

module type SeqType = sig
  type t
  (** The type of the sequence. *)

  type elem
  (** The type of the elements of the sequence. *)

  val get : t -> int -> elem
  (** [get t n] returns [n]-th element of the sequence [t]. *)

  val length : t -> int
  (** [length t] returns the length of the sequence [t]. *)
end
(** Input signature of {!Diff.Make}. *)

module type S = sig
  type t
  (** The type of input sequence. *)

  type elem
  (** The type of the elemenents of result / input sequence. *)

  val lcs :
      ?equal:(elem -> elem -> bool) ->
      t -> t -> elem common list
  (**
     [lcs ~equal seq1 seq2] computes the LCS (longest common sequence) of
     [seq1] and [seq2].
     Elements of [seq1] and [seq2] are compared with [equal].
     [equal] defaults to [Pervasives.(=)].

     Elements of lcs are [`Common (pos1, pos2, e)]
     where [e] is an element, [pos1] is a position in [seq1],
     and [pos2] is a position in [seq2].
   *)

  val diff :
      ?equal:(elem -> elem -> bool) ->
      t -> t -> elem edit list
  (**
     [diff ~equal seq1 seq2] computes the diff of [seq1] and [seq2].
     Elements of [seq1] and [seq2] are compared with [equal].

     Elements only in [seq1] are represented as [`Removed (pos, e)]
     where [e] is an element, and [pos] is a position in [seq1];
     those only in [seq2] are represented as [`Added (pos, e)]
     where [e] is an element, and [pos] is a position in [seq2];
     those common in [seq1] and [seq2] are represented as
     [`Common (pos1, pos2, e)]
     where [e] is an element, [pos1] is a position in [seq1],
     and [pos2] is a position in [seq2].
   *)

  val fold_left :
      ?equal:(elem -> elem -> bool) ->
      f:('a -> elem edit -> 'a) ->
      init:'a ->
      t -> t -> 'a
  (**
     [fold_left ~equal ~f ~init seq1 seq2] is same as
     [diff ~equal seq1 seq2 |> ListLabels.fold_left ~f ~init],
     but does not create an intermediate list.
   *)

  val iter :
      ?equal:(elem -> elem -> bool) ->
      f:(elem edit -> unit) ->
      t -> t -> unit
  (**
     [iter ~equal ~f seq1 seq2] is same as
     [diff ~equal seq1 seq2 |> ListLabels.iter ~f],
     but does not create an intermediate list.
   *)
end
(** Output signature of {!Diff.Make}. *)

module Make :
  functor (M : SeqType) -> (S with type t = M.t and type elem = M.elem)
(** Functor building an implementation of the diff structure
    given a sequence type.  *)
@


\subsection*{[[version_control/diff_simple.ml]]}
%buggy!

%-------------------------------------------------------------

<<version_control/diff_simple.ml>>=
module type Comparable =
  sig
    type t
    val compare: t -> t -> int
  end

module type S =
  sig
    type item

    type diff =
      | Deleted of item array
      | Added of item array
      | Equal of item array

    type t = diff list

    val get_diff : item array -> item array -> t
  end

module Make(Item : Comparable) = struct
  type item = Item.t

  type diff =
    | Deleted of item array
    | Added of item array
    | Equal of item array

  type t = diff list

  type subsequence_info =
    { (* Starting index of longest subsequence in the list of new values *)
      sub_start_new : int;
      (* Starting index of longest subsequence in the list of old values *)
      sub_start_old : int;
      (* The length of the longest subsequence *)
      longest_subsequence : int; }

  module CounterMap = Map.Make(Item)

  (* Returns a map with the line as key and a list of indices as value.
     Represents counts of all the lines. *)
  let map_counter keys =
    let keys_and_indices = Array.mapi (fun index key -> index, key) keys in
    Array.fold_left (fun map (index, key) ->
        let indices = try CounterMap.find key map with | Not_found -> [] in
        CounterMap.add key (index :: indices) map
      ) CounterMap.empty keys_and_indices


  (* Computes longest subsequence and returns data on the length of longest
     subsequence and the starting index for the longest subsequence in the old
     and new versions. *)
  let get_longest_subsequence old_lines new_lines =
    let old_values_counter = map_counter old_lines in
    let overlap = Hashtbl.create 5000 in
    let sub_start_old = ref 0 in
    let sub_start_new = ref 0 in
    let longest_subsequence = ref 0 in

    Array.iteri (fun new_index new_value ->
        let indices = try CounterMap.find new_value old_values_counter with
          | Not_found -> []
        in
        List.iter (fun old_index ->
            let prev_subsequence = try Hashtbl.find overlap (old_index - 1) with | Not_found -> 0 in
            let new_subsequence = prev_subsequence + 1 in
            Hashtbl.add overlap old_index new_subsequence;

            if new_subsequence > !longest_subsequence then
              sub_start_old := old_index - new_subsequence + 1;
            sub_start_new := new_index - new_subsequence + 1;
            longest_subsequence := new_subsequence;
          ) indices;
      ) new_lines;

    { sub_start_new = !sub_start_new;
      sub_start_old = !sub_start_old;
      longest_subsequence = !longest_subsequence }


  let rec get_diff old_lines new_lines =
    match old_lines, new_lines with
    | [||], [||] -> []
    | _, _ ->
      let { sub_start_new; sub_start_old; longest_subsequence } =
        get_longest_subsequence old_lines new_lines
      in

      if longest_subsequence == 0 then
        [Deleted old_lines; Added new_lines]
      else
        let old_lines_presubseq = Array.sub old_lines 0 sub_start_old in
        let new_lines_presubseq = Array.sub new_lines 0 sub_start_new in
        let old_lines_postsubseq =
          let start_index = sub_start_old + longest_subsequence in
          let end_index = Array.length old_lines - start_index in
          Array.sub old_lines start_index end_index
        in
        let new_lines_postsubseq =
          let start_index = sub_start_new + longest_subsequence in
          let end_index = Array.length new_lines - start_index in
          Array.sub new_lines start_index end_index
        in
        let unchanged_lines = Array.sub new_lines sub_start_new longest_subsequence in
        get_diff old_lines_presubseq new_lines_presubseq @
        [Equal unchanged_lines] @
        get_diff old_lines_postsubseq new_lines_postsubseq
end
@


\subsection*{[[version_control/diff_simple.mli]]}

%-------------------------------------------------------------

<<version_control/diff_simple.mli>>=
(** A simple diffing algorithm *)

module type Comparable =
  sig
    type t
      (** The type of the items being compared *)

    val compare: t -> t -> int
      (** A way to distinguish if items are equal or unequal. It follows
          the OCaml convention of returning an integer between -1 to 1. *)
  end

module type S =
  sig
    type item
    (** The type of the item that will be compared. *)

    type diff =
      | Deleted of item array
      | Added of item array
      | Equal of item array
    (** Represents the change or lack of change in a line or character
        between the old and new version. *)

    type t = diff list
    (** List of diffs which is the return value of the main function. *)

    val get_diff : item array -> item array -> t
    (** Returns a list of diffs between two arrays *)
  end

module Make (Item: Comparable) : S with type item = Item.t
@


\subsection*{[[version_control/diff_unified.ml]]}

%-------------------------------------------------------------

<<version_control/diff_unified.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Show differences between 2 files.
 *
 * Short explanation of unified format:
 *  - https://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html
 *  - http://www.artima.com/weblogs/viewpost.jsp?thread=164293  
 * 
 * alternatives:
 *  - ocamldiff: https://github.com/zoggy/ocamldiff 
 *    parse and display unified diffs
 *  - unidiff: https://github.com/gildor478/ocaml-unidiff
 *    parse 
 *  - call diff -u (as I did in pfff) directly via Sys.command
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Diff_unified.print>>

<<function Diff_unified.print_header>>

<<constant Diff_unified.nContext>>

<<function Diff_unified.show_unified_diff>>


(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Diff_unified.show_change>>
@


\subsection*{[[version_control/diff_unified.mli]]}

%-------------------------------------------------------------

<<version_control/diff_unified.mli>>=

<<signature Diff_unified.show_change>>
@


\subsection*{[[version_control/dump.ml]]}

%-------------------------------------------------------------

<<version_control/dump.ml>>=
open Ocaml

(* mostly auto-generated by ocamltarzan *)

module Int64 = struct
let vof_t x =
  Ocaml.vof_int (Int64.to_int x)
end

module Int32 = struct
let vof_t x =
  Ocaml.vof_int (Int32.to_int x)
end


module Sha1 = struct
  let vof_t x = 
    Ocaml.VSum (("ShaHex", [Ocaml.vof_string (Hexsha.of_sha x)]))
end

module Blob = struct
  let vof_t x = Ocaml.vof_string x
end

module Tree = struct
open Tree
let vof_perm =
  function
  | Normal -> Ocaml.VSum (("Normal", []))
  | Exec -> Ocaml.VSum (("Exec", []))
  | Link -> Ocaml.VSum (("Link", []))
  | Dir -> Ocaml.VSum (("Dir", []))
  | Commit -> Ocaml.VSum (("Commit", []))
  
let vof_entry { perm = v_perm; name = v_name; node = v_node } =
  let bnds = [] in
  let arg = Sha1.vof_t v_node in
  let bnd = ("node", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_perm v_perm in
  let bnd = ("perm", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  
let vof_t v = Ocaml.vof_list vof_entry v
end

module User = struct
open User
let vof_sign =
  function
  | Plus -> Ocaml.VSum (("Plus", []))
  | Minus -> Ocaml.VSum (("Minus", []))
  
let vof_tz_offset { sign = v_sign; hours = v_hours; min = v_min } =
  let bnds = [] in
  let arg = Ocaml.vof_int v_min in
  let bnd = ("min", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_int v_hours in
  let bnd = ("hours", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_sign v_sign in
  let bnd = ("sign", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let vof_t { name = v_name; email = v_email; date = v_date } =
  let bnds = [] in
  let arg =
    match v_date with
    | (v1, v2) ->
        let v1 = Int64.vof_t v1
        and v2 = vof_tz_offset v2
        in Ocaml.VTuple [ v1; v2 ] in
  let bnd = ("date", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_email in
  let bnd = ("email", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
end

module Commit = struct
open Commit
let vof_t {
            tree = v_tree;
            parents = v_parents;
            author = v_author;
            committer = v_committer;
            message = v_message
          } =
  let bnds = [] in
  let arg = Ocaml.vof_string v_message in
  let bnd = ("message", arg) in
  let bnds = bnd :: bnds in
  let arg = User.vof_t v_committer in
  let bnd = ("committer", arg) in
  let bnds = bnd :: bnds in
  let arg = User.vof_t v_author in
  let bnd = ("author", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_list Sha1.vof_t v_parents in
  let bnd = ("parents", arg) in
  let bnds = bnd :: bnds in
  let arg = Sha1.vof_t v_tree in
  let bnd = ("tree", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
end

module Objects = struct
open Objects
let vof_t =
  function
  | Blob v1 -> let v1 = Blob.vof_t v1 in Ocaml.VSum (("Blob", [ v1 ]))
  | Commit v1 -> let v1 = Commit.vof_t v1 in Ocaml.VSum (("Commit", [ v1 ]))
  | Tree v1 -> let v1 = Tree.vof_t v1 in Ocaml.VSum (("Tree", [ v1 ]))
end
<<constant Dump.vof_obj>>

module Index = struct
open Index
let rec
  vof_stat_info {
                  ctime = v_ctime;
                  mtime = v_mtime;
                  dev = v_dev;
                  inode = v_inode;
                  mode = v_mode;
                  uid = v_uid;
                  gid = v_gid;
                  size = v_size
                } =
  let bnds = [] in
  let arg = Int32.vof_t v_size in
  let bnd = ("size", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_gid in
  let bnd = ("gid", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_uid in
  let bnd = ("uid", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_mode v_mode in
  let bnd = ("mode", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_inode in
  let bnd = ("inode", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_dev in
  let bnd = ("dev", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_time v_mtime in
  let bnd = ("mtime", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_time v_ctime in
  let bnd = ("ctime", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_mode =
  function
  | Normal -> Ocaml.VSum (("Normal", []))
  | Exec -> Ocaml.VSum (("Exec", []))
  | Link -> Ocaml.VSum (("Link", []))
  | Gitlink -> Ocaml.VSum (("Gitlink", []))
and vof_time { lsb32 = v_lsb32; nsec = v_nsec } =
  let bnds = [] in
  let arg = Int32.vof_t v_nsec in
  let bnd = ("nsec", arg) in
  let bnds = bnd :: bnds in
  let arg = Int32.vof_t v_lsb32 in
  let bnd = ("lsb32", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
  

let vof_entry { stats = v_stats; id = v_id; stage = v_stage; name = v_name }
              =
  let bnds = [] in
  let arg = Ocaml.vof_string v_name in
  let bnd = ("name", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_int v_stage in
  let bnd = ("stage", arg) in
  let bnds = bnd :: bnds in
  let arg = Sha1.vof_t v_id in
  let bnd = ("id", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_stat_info v_stats in
  let bnd = ("stats", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let vof_t v = Ocaml.vof_list vof_entry v
end
<<constant Dump.vof_index>>
@


\subsection*{[[version_control/dump.mli]]}

%-------------------------------------------------------------

<<version_control/dump.mli>>=

<<signature Dump.vof_obj>>
<<signature Dump.vof_index>>
@


\subsection*{[[version_control/hexsha.ml]]}


<<signature Hexsha.read>>=
val read: IO.input -> t
@
<<function Hexsha.read>>=
let read ch =
  let s = IO.really_nread ch 40 in
  assert (is_hexsha s);
  s
@

<<signature Hexsha.write>>=
val write: 'a IO.output -> t -> unit
@
<<function Hexsha.write>>=
let write ch x =
  IO.nwrite ch x
@


%-------------------------------------------------------------

<<version_control/hexsha.ml>>=
<<copyright ocaml-hex>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * Most of the code below comes from src: https://github.com/mirage/ocaml-hex
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Hexsha.t>>

<<function Hexsha.is_hexsha>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

(* start of copy-pasted code from ocaml-hex *)

let hexa = "0123456789abcdef"
and hexa1 =
  "0000000000000000111111111111111122222222222222223333333333333333\
   4444444444444444555555555555555566666666666666667777777777777777\
   88888888888888889999999999999999aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb\
   ccccccccccccccccddddddddddddddddeeeeeeeeeeeeeeeeffffffffffffffff"
and hexa2 =
  "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\
   0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

<<function Hexsha.of_string_fast>>


<<function Hexsha.invalid_arg>>

<<function Hexsha.to_char>>

<<function Hexsha.to_helper>>

<<function Hexsha.to_string>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Hexsha.of_sha>>

<<function Hexsha.to_sha>>

<<function Hexsha.read>>
<<function Hexsha.write>>
@


\subsection*{[[version_control/hexsha.mli]]}

%-------------------------------------------------------------

<<version_control/hexsha.mli>>=
<<type Hexsha.t>>

<<signature Hexsha.of_sha>>
<<signature Hexsha.to_sha>>

<<signature Hexsha.read>>
<<signature Hexsha.write>>

<<signature Hexsha.is_hexsha>>

@


\subsection*{[[version_control/index.ml]]}


<<function Index.stat_info_of_lstats>>=
let stat_info_of_lstats stats = 
    { ctime = { lsb32 = Int32.of_float stats.Unix.st_ctime; nsec = 0l };
      mtime = { lsb32 = Int32.of_float stats.Unix.st_mtime; nsec = 0l };
      dev = Int32.of_int stats.Unix.st_dev;
      inode = Int32.of_int stats.Unix.st_ino;
      mode = 
        (match stats.Unix.st_kind, stats.Unix.st_perm with
        | Unix.S_REG, p -> 
          if p land 0o100 = 0o100 
          then Exec 
          else Normal
        | Unix.S_LNK, _ -> Link
        | _ -> failwith (spf "unsupported file type")
        );
      uid = Int32.of_int stats.Unix.st_uid;
      gid = Int32.of_int stats.Unix.st_gid;
      size = Int32.of_int stats.Unix.st_size;
    }
@


<<function Index.perm_of_mode>>=
let perm_of_mode mode = 
  match mode with
  | Normal -> Tree.Normal
  | Exec -> Tree.Exec
  | Link -> Tree.Link
  | Gitlink -> Tree.Commit (* sure? *)
@

<<function Index.mode_of_perm>>=
let mode_of_perm perm = 
  match perm with
  | Tree.Normal -> Normal
  | Tree.Exec -> Exec
  | Tree.Link -> Link
  | Tree.Commit -> Gitlink
  | Tree.Dir -> failwith "index entry does not support Tree.dir perm"
@


%-------------------------------------------------------------

<<version_control/index.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 * in index.ml and git_unix.ml
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Index.stat_info>>
<<type Index.mode>>
<<type Index.time>>
    
<<type Index.entry>>

(* less: extensions *)

<<type Index.t>>

<<constant Index.empty>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*
(* Index entries are sorted by the byte sequence that comprises the
   entry name; with a secondary comparison of the stage bits from the
   <ENTRY_FLAGS> if the entry name byte sequences are identical. *)
let compare_entries e1 e2 =
  match String.compare e1.name e2.name with
  | 0 -> Hash.Blob.compare e2.id e1.id
  | i -> i
*)

<<function Index.stat_info_of_lstats>>

<<function Index.mk_entry>>

<<function Index.perm_of_mode>>

<<function Index.mode_of_perm>>


(*****************************************************************************)
(* Add/Del *)
(*****************************************************************************)

<<function Index.remove_entry>>

<<function Index.add_entry>>

(*****************************************************************************)
(* tree of index *)
(*****************************************************************************)

<<type Index.dir>>
<<type Index.dir_entry>>
<<type Index.dirs>>

(* the code in this section derives from dulwich *)

<<function Index.add_dir>>

<<function Index.build_trees>>


<<function Index.tree_of_index>>

(*****************************************************************************)
(* index of tree *)
(*****************************************************************************)
(* See repository.set_worktree_and_index_to_tree() *)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Index.read_time>>

<<function Index.write_time>>

<<function Index.read_mode>>

<<function Index.write_mode>>

<<function Index.read_stat_info>>

<<function Index.write_stat_info>>
 

<<function Index.read_entry>>

<<function Index.write_entry>>




<<function Index.read_entries>>

<<function Index.read>>


<<function Index.write>>
@


\subsection*{[[version_control/index.mli]]}

<<signature Index.stat_info_of_lstats>>=
val stat_info_of_lstats: Unix.stats -> stat_info
@

<<signature Index.mode_of_perm>>=
val mode_of_perm: Tree.perm -> mode
@

<<signature Index.perm_of_mode>>=
val perm_of_mode: mode -> Tree.perm
@



<<signature Index.tree_of_index>>=
val tree_of_index: t -> (* add_obj *)(Tree.t -> Tree.hash) -> Tree.hash
(* todo: index_of_tree *)
@


%-------------------------------------------------------------

<<version_control/index.mli>>=

<<type Index.stat_info>>
<<type Index.mode>>
<<type Index.time>>
    
<<type Index.entry>>

<<type Index.t>>

<<signature Index.empty>>
<<signature Index.mk_entry>>

<<signature Index.stat_info_of_lstats>>
<<signature Index.mode_of_perm>>
<<signature Index.perm_of_mode>>

<<signature Index.read>>
<<signature Index.write>>

<<signature Index.remove_entry>>
<<signature Index.add_entry>>

<<signature Index.tree_of_index>>
@


\subsection*{[[version_control/main.ml]]}

%-------------------------------------------------------------

<<version_control/main.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* An OCaml port of git, a distributed version control system.
 *
 * Some of the code of ogit derives from dulwich (a clone of git in Python)
 * and ocaml-git (a clone of git in OCaml).
 *
 * Main limitations compared to git/dulwich/ocaml-git:
 *  -??
 * 
 * todo:
 *  - a simplified version where just Marshall data instead of using
 *    the specific git format. Save many LOC?
 *  - ??
 * 
 * The code of ogit uses code from 
 *  - ocaml-git
 *  - ocaml-hex
 *  - camlzip
 *  - extlib
 *  - uuidm
 * 
 * ogit uses lots of code from ocaml-git. However, ogit is simpler because
 * it does not use fancy features of OCaml or fancy libraries:
 *  - no functor, include, module types, polymorphic variants, keyword args,
 *    or excessive nested modules. KISS.
 *  - no functorized Set and Map so no need for hash(), compare(), and equal()
 *    boilerplate functions everywhere
 *  - hardcoded use of SHA1, so no need functors taking Git.DIGEST and HashIO
 *  - no support for mirage, so no need to parametrize many things,
 *    no need Fs module, no need lwt
 *  - no disk vs mem, just disk, so again need less functors
 *  - hardcoded use of zlib so no need functors taking inflate signature
 *  - no support for filename requiring special escapes
 *  - no use of Cstruct or Mstruct or Bigarray (simply use IO.ml and Bytes)
 *  - no logs
 *  - no fmt (use ocamldebug or ocamltarzan dumpers)
 *  - no sexplib
 * 
 * good stuff I took from ocaml-git:
 *  - dotgit (more readable than commondir in dulwich)
 *  - '/' operator (more readable than all those os.path.join in dulwich)
 *  - Hash.Tree.t, Hash.Commit.t, Hash.Blob.t more precise hash types
 *    (but they are not statically checked in ogit)
 *  - TODO GRI (generalization of URI)
 * good stuff I wish I could take from dulwich:
 *  - hashtbl [] overloading, so can do r.refs["refs/tags/"+tag] = obj.id
 *    (thx to __setitem__ and __getitem__)
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<constant Main.commands>>

<<constant Main.hcommands>>

<<function Main.usage>>

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)

<<function Main.main>>
        
<<toplevel Main._1>>
@


\subsection*{[[version_control/merge.ml]]}

%-------------------------------------------------------------

<<version_control/merge.ml>>=
(*
https://github.com/schuhschuh/cmake-basis/blob/master/src/utilities/python/diff3.py
*)
@


\subsection*{[[version_control/objects.ml]]}

%-------------------------------------------------------------

<<version_control/objects.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Objects.t>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Objects.read>>

<<function Objects.write>>
@


\subsection*{[[version_control/objects.mli]]}

%-------------------------------------------------------------

<<version_control/objects.mli>>=

<<type Objects.t>>

<<signature Objects.read>>

<<signature Objects.write>>
@


\subsection*{[[version_control/refs.ml]]}

%-------------------------------------------------------------

<<version_control/refs.ml>>=
open Common

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Refs.refname>>

<<type Refs.t>>

<<type Refs.ref_content>>

<<constant Refs.default_head_content>>

<<function Refs.is_valid_refname>>

(*****************************************************************************)
(* Dumper *)
(*****************************************************************************)

<<function Refs.string_of_ref>>

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Refs.read>>

<<function Refs.write>>
@


\subsection*{[[version_control/refs.mli]]}

%-------------------------------------------------------------

<<version_control/refs.mli>>=

<<type Refs.refname>>

<<type Refs.t>>

<<type Refs.ref_content>>

<<signature Refs.default_head_content>>

<<signature Refs.is_valid_refname>>

<<signature Refs.read>>
<<signature Refs.write>>

<<signature Refs.string_of_ref>>
@


\subsection*{[[version_control/repository.ml]]}

<<function Repository.with_file_out_with_lock>>=
(* todo: see code of _Gitfile.__init__ O_EXCL ... *)
let with_file_out_with_lock f file =
  (* todo: create .lock file and then rename *)
  Common.with_file_out f file
@

<<function Repository.with_opendir>>=
(* less: use finalize *)
let with_opendir f dir =
  let handle = Unix.opendir dir in
  let res = f handle in
  Unix.closedir handle;
  res
@

<<function Repository.walk_dir>>=
(* inspired from os.path.walk in Python *)
let rec walk_dir f dir =
  dir |> with_opendir (fun handle ->
    let dirs = ref [] in
    let files = ref [] in
    try 
      while true do
        let s = Unix.readdir handle in
        (* git specific here *)
        if s <> "." && s <> ".." && s <> ".git" then begin
          let path = Filename.concat dir s in
          let st = Unix.lstat path in
          (match st.Unix.st_kind with
          | Unix.S_DIR -> Common.push s dirs
          | _ -> Common.push s files
          )
        end
      done
    with End_of_file ->
      let dirs = List.rev !dirs in
      let files = List.rev !files in
      f dir dirs files;
      dirs |> List.iter (fun s ->
        walk_dir f (Filename.concat dir s)
      )
  )
@


<<function Repository.set_ref>>=
let set_ref r aref newh =
  let (refs, _) = follow_ref r aref in
  let lastref = List.hd (List.rev refs) in
  let file = ref_to_filename r lastref in
  file |> with_file_out_with_lock (fun ch ->
    ch |> IO.output_channel |> IO_.with_close_out 
        (Refs.write (Refs.Hash newh))
  )
@







<<function Repository.has_obj>>=
let has_obj r h =
  let path = h |> Hexsha.of_sha |> hexsha_to_filename r in
  Sys.file_exists path
@




%-------------------------------------------------------------

<<version_control/repository.ml>>=
<<copyright gut>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* API to access repository data (objects, index, refs, packs).
 *
 * less: use nested modules for objects, index, refs below?
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Repository.t>>

<<constant Repository.TODOOPERATOR>>

<<constant Repository.dirperm>>

<<type Repository.objectish>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Repository.hexsha_to_filename>>

<<function Repository.hexsha_to_dirname>>

<<function Repository.ref_to_filename>>

<<function Repository.index_to_filename>>

<<function Repository.with_file_out_with_lock>>


(* move in common.ml? *)
<<function Repository.with_opendir>>
    
(* move in common.ml? (but remove .git specific stuff) *)
<<function Repository.walk_dir>>

(*****************************************************************************)
(* Refs *)
(*****************************************************************************)

<<function Repository.read_ref>>

<<function Repository.follow_ref>>

<<function Repository.follow_ref_some>>

<<function Repository.add_ref_if_new>>

<<function Repository.del_ref>>

<<function Repository.set_ref_if_same_old>>

<<function Repository.set_ref>>
  

<<function Repository.write_ref>>

<<function Repository.all_refs>>

(*****************************************************************************)
(* Objects *)
(*****************************************************************************)

<<function Repository.read_obj>>

<<function Repository.read_commit>>
<<function Repository.read_tree>>
<<function Repository.read_blob>>

<<function Repository.read_objectish>>

<<function Repository.add_obj>>

<<function Repository.has_obj>>

(*****************************************************************************)
(* Index *)
(*****************************************************************************)

<<function Repository.read_index>>

<<function Repository.write_index>>

    
<<function Repository.content_from_path_and_unix_stat>>

<<function Repository.add_in_index>>

(*****************************************************************************)
(* Commit *)
(*****************************************************************************)

<<function Repository.commit_index>>
  
(*****************************************************************************)
(* Checkout and reset *)
(*****************************************************************************)

<<function Repository.build_file_from_blob>>


<<function Repository.set_worktree_and_index_to_tree>>

(*****************************************************************************)
(* Packs *)
(*****************************************************************************)

(*****************************************************************************)
(* Repo init/open *)
(*****************************************************************************)

<<function Repository.init>>


<<function Repository.open_>>
@


\subsection*{[[version_control/repository.mli]]}


<<signature Repository.has_obj>>=
val has_obj: t -> Sha1.t -> bool
@



<<signature Repository.set_ref>>=
(* better than write_ref, will follow symbolic ref *)
val set_ref: t -> Refs.t -> Commit.hash -> unit
@


<<signature Repository.add_ref_if_new>>=
val add_ref_if_new: t -> Refs.t -> Refs.ref_content -> bool
@

<<signature Repository.set_ref_if_same_old>>=
val set_ref_if_same_old: t -> Refs.t -> Sha1.t -> Sha1.t -> bool
@




<<signature Repository.commit_index>>=
val commit_index: 
  t -> User.t (* author *) -> User.t (* committer *) -> string (* msg *) -> unit
@


<<signature Repository.walk_dir>>=
val walk_dir: 
  (Common.filename -> Common.filename list -> Common.filename list -> unit) ->
  Common.filename ->
  unit
@


%-------------------------------------------------------------

<<version_control/repository.mli>>=

<<type Repository.t>>

<<type Repository.objectish>>


(* repo *)
<<signature Repository.init>>
<<signature Repository.open_>>

(* objects *)
<<signature Repository.read_obj>>
<<signature Repository.read_objectish>>
<<signature Repository.read_commit>>
<<signature Repository.read_tree>>
<<signature Repository.read_blob>>
<<signature Repository.add_obj>>
<<signature Repository.has_obj>>

(* refs *)
<<signature Repository.read_ref>>
<<signature Repository.write_ref>>
<<signature Repository.follow_ref>>
<<signature Repository.follow_ref_some>>
<<signature Repository.all_refs>>
<<signature Repository.set_ref>>
<<signature Repository.del_ref>>
(* atomic op *)
<<signature Repository.add_ref_if_new>>
<<signature Repository.set_ref_if_same_old>>

(* index *)
<<signature Repository.read_index>>
<<signature Repository.write_index>>
<<signature Repository.add_in_index>>

<<signature Repository.commit_index>>
<<signature Repository.set_worktree_and_index_to_tree>>

(* packs *)

(* misc *)
<<signature Repository.walk_dir>>

@


\subsection*{[[version_control/sha1.ml]]}

<<signature Sha1.read>>=
val read: IO.input -> t
@
<<function Sha1.read>>=
let read ch =
  let s = IO.really_nread ch 20 in
  assert (is_sha s);
  s
@


<<signature Sha1.write>>=
val write: 'a IO.output -> t -> unit
@
<<function Sha1.write>>=
let write ch x =
  IO.nwrite ch x
@

%-------------------------------------------------------------

<<version_control/sha1.ml>>=
<<copyright uuidm>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * Most of the code below comes from: https://github.com/dbuenzli/uuidm 
 * (this code is also copy-pasted and used in git-mirage)
 * 
 * alternatives:
 *  - https://github.com/vincenthz/ocaml-sha 
 *    not maintained and uses C code
 *  - https://github.com/xavierleroy/cryptokit/
 *    by Xavier Leroy, but also uses C code
 *  - nocrypto
 *    seems like the official crypto lib, but also uses C code
 *  - md5sum, produces 128-bit hash value (sha1 is 20 bytes so 160 bits)
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Sha1.t>>

<<function Sha1.is_sha>>

(*****************************************************************************)
(* Entry points *)
(*****************************************************************************)

<<function Sha1.read>>

<<function Sha1.write>>

(* start of copy-pasted code from uuidm *)

<<function Sha1.sha1>>
@


\subsection*{[[version_control/sha1.mli]]}

%-------------------------------------------------------------

<<version_control/sha1.mli>>=
<<type Sha1.t>>

<<signature Sha1.sha1>>

<<signature Sha1.read>>
<<signature Sha1.write>>

<<signature Sha1.is_sha>>
@


\subsection*{[[version_control/tree.ml]]}


<<function Tree.walk_tree>>=
(* we must visit in sorted order, so the caller of walk_tree can rely on 'f'
 * being called in order (so it can easily create for example sorted 
 * index entries while visiting a tree)
 *)
let rec walk_tree read_tree dirpath f xs =
  xs |> List.iter (fun entry ->
    let relpath = Filename.concat dirpath entry.name in
    f relpath entry;
    match entry.perm with
    | Dir ->
      walk_tree read_tree relpath f (read_tree entry.node)
    | Commit ->
      failwith "submodule not supported yet"
    | Normal | Exec | Link -> ()
  )
@

<<function Tree.walk_trees>>=
let rec walk_trees read_tree dirpath f xs ys =
  let g dirpath entry1_opt entry2_opt =
    f dirpath entry1_opt entry2_opt;
    (match entry1_opt, entry2_opt with
    | Some { perm = Dir; name = str; node = sha }, None ->
      walk_trees read_tree (Filename.concat dirpath str) f
        (read_tree sha) []
    | None, Some { perm = Dir; name = str; node = sha } ->
      walk_trees read_tree (Filename.concat dirpath str) f
        [] (read_tree sha)
    | Some { perm = Dir; name = str1; node = sha1 },
      Some { perm = Dir; name = str2; node = sha2 } ->
      assert (str1 = str2);
        (* todo: could skip if sha1 = sha2 here, useful opti *)
        walk_trees read_tree (Filename.concat dirpath str1) f
          (read_tree sha1) (read_tree sha2)
    | None, None -> raise (Impossible "two None in walk_trees.g")
    (* no directories, no need to recurse *)
    | Some _, None
    | None, Some _
    | Some _, Some _
      -> ()
    )
  in
  match xs, ys with
  | [], [] -> ()
  | x::xs, [] ->
    g dirpath (Some x) None;
    walk_trees read_tree dirpath f xs ys
  | [], y::ys ->
    g dirpath None (Some y);
    walk_trees read_tree dirpath f xs ys
  | x::xs, y::ys ->
    (match x.name <=> y.name with
    | Equal -> 
      g dirpath (Some x) (Some y);
      walk_trees read_tree dirpath f xs ys
    | Inf -> 
      g dirpath (Some x) None;
      walk_trees read_tree dirpath f xs (y::ys)
    | Sup ->
      g dirpath None (Some y);
      walk_trees read_tree dirpath f (x::xs) ys
    )
@


%-------------------------------------------------------------

<<version_control/tree.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Tree.perm>>

<<type Tree.entry>>

<<type Tree.t>>

<<type Tree.hash>>

(*****************************************************************************)
(* Walk *)
(*****************************************************************************)
<<function Tree.walk_tree>>

<<function Tree.walk_trees>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Tree.perm_of_string>>

<<function Tree.string_of_perm>>

<<function Tree.read_entry>>

<<function Tree.write_entry>>
  

<<function Tree.read>>


<<function Tree.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function Tree.show>>
@


\subsection*{[[version_control/tree.mli]]}


<<signature Tree.walk_tree>>=
val walk_tree: 
  (hash -> t) -> Common.filename (* dir *) -> 
  (Common.filename -> entry -> unit) -> t -> unit
@

<<signature Tree.walk_trees>>=
val walk_trees:
  (hash -> t) -> Common.filename (* dir *) ->
  (Common.filename -> entry option -> entry option -> unit) -> t -> t -> unit
@


%-------------------------------------------------------------

<<version_control/tree.mli>>=

<<type Tree.perm>>

<<type Tree.entry>>

<<type Tree.t>>

<<type Tree.hash>>


<<signature Tree.read>>
<<signature Tree.write>>

<<signature Tree.show>>

<<signature Tree.walk_tree>>

<<signature Tree.walk_trees>>

@


\subsection*{[[version_control/unzip.ml]]}

%-------------------------------------------------------------

<<version_control/unzip.ml>>=
<<copyright ocaml-unzip>>

<<type Unzip.huffman>>


<<type Unzip.adler32>>

<<type Unzip.window>>

<<type Unzip.state>>

<<type Unzip.t>>

<<type Unzip.error_msg>>

<<exception Unzip.Error>>

<<function Unzip.error>>

(* ************************************************************************ *)
(* HUFFMAN TREES *)

<<function Unzip.tree_depth>>

<<function Unzip.tree_compress>>

<<function Unzip.make_huffman>>

(* ************************************************************************ *)
(* ADLER32 (CRC) *)

<<function Unzip.adler32_create>>

<<function Unzip.adler32_update>>

<<function Unzip.adler32_read>>

(* ************************************************************************ *)
(* WINDOW *)

<<constant Unzip.window_size>>
<<constant Unzip.buffer_size>>

<<function Unzip.window_create>>

<<function Unzip.window_slide>>

<<function Unzip.window_add_bytes>>

<<function Unzip.window_add_char>>

<<function Unzip.window_get_last_char>>

<<function Unzip.window_available>>

<<function Unzip.window_checksum>>

(* ************************************************************************ *)

<<constant Unzip.len_extra_bits_tbl>>
<<constant Unzip.len_base_val_tbl>>
<<constant Unzip.dist_extra_bits_tbl>>
<<constant Unzip.dist_base_val_tbl>>
<<constant Unzip.code_lengths_pos>>

<<constant Unzip.fixed_huffman>>

<<function Unzip.get_bits>>

<<function Unzip.get_bit>>

<<function Unzip.get_rev_bits>>

<<function Unzip.reset_bits>>

<<function Unzip.add_bytes>>

<<function Unzip.add_char>>

<<function Unzip.add_dist_one>>

<<function Unzip.add_dist>>

<<function Unzip.apply_huffman>>

<<function Unzip.inflate_lengths>>

<<function Unzip.inflate_loop>>

<<function Unzip.inflate_data>>

<<function Unzip.inflate_init>>

<<function Unzip.inflate>>
@


\subsection*{[[version_control/unzip.mli]]}

<<signature Unzip.inflate>>=
val inflate : ?header:bool -> IO.input -> IO.input
(** wrap an input using "inflate" decompression algorithm. raises [Error] if
  an error occurs (this can only be caused by malformed input data). *)
@

<<signature Unzip.inflate_init>>=
val inflate_init : ?header:bool -> IO.input -> t
@

<<signature Unzip.inflate_data>>=
val inflate_data : t -> bytes -> int -> int -> int
@


%-------------------------------------------------------------

<<version_control/unzip.mli>>=
(*
 * Unzip - inflate format decompression algorithm
 * Copyright (C) 2004 Nicolas Cannasse
 * Compliant with RFC 1950 and 1951
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version,
 * with the special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *)

(** Decompression algorithm.

  Unzip decompression algorithm is compliant with RFC 1950 and 1951 which
  are describing the "inflate" algorithm used in most popular file formats.
  This format is also the one used by the popular ZLib library.  
*)

<<type Unzip.error_msg>>

<<exception Unzip.Error>>

<<signature Unzip.inflate>>

type t

<<signature Unzip.inflate_init>>
<<signature Unzip.inflate_data>>
@


\subsection*{[[version_control/user.ml]]}

%-------------------------------------------------------------

<<version_control/user.ml>>=
<<copyright ocaml-git>>
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* 
 * 
 * Most of the code below derives from: https://github.com/mirage/ocaml-git
 *)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type User.sign>>

<<type User.tz_offset>>

<<type User.t>>

(* less: default_tz_offset ? *)

(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function User.sign_of_char>>

<<function User.char_of_sign>>

<<function User.read>>

<<function User.write_date>>

<<function User.write>>

(*****************************************************************************)
(* Show *)
(*****************************************************************************)

<<function User.string_of_date>>

@


\subsection*{[[version_control/user.mli]]}

%-------------------------------------------------------------

<<version_control/user.mli>>=

<<type User.sign>>

<<type User.tz_offset>>

<<type User.t>>

<<signature User.read>>
<<signature User.write>>

<<signature User.string_of_date>>
@


\subsection*{[[version_control/zlib.ml]]}

<<exception Zlib.Error>>=
exception Error of string * string
@

<<toplevel Zlib._1>>=
let _ =
  Callback.register_exception "Zlib.Error" (Error("",""))
@

<<type Zlib.flush_command>>=
type flush_command =
    Z_NO_FLUSH
  | Z_SYNC_FLUSH
  | Z_FULL_FLUSH
  | Z_FINISH
@

<<constant Zlib.buffer_size>>=
let buffer_size = 1024
@

<<function Zlib.compress>>=
let compress ?(level = 6) ?(header = true) refill flush =
  let inbuf = Bytes.create buffer_size
  and outbuf = Bytes.create buffer_size in
  let zs = deflate_init level header in
  let rec compr inpos inavail =
    if inavail = 0 then begin
      let incount = refill inbuf in
      if incount = 0 then compr_finish() else compr 0 incount
    end else begin
      let (_, used_in, used_out) =
        deflate zs inbuf inpos inavail outbuf 0 buffer_size Z_NO_FLUSH in
      flush outbuf used_out;
      compr (inpos + used_in) (inavail - used_in)
    end
  and compr_finish () =
    let (finished, _, used_out) =
       deflate zs inbuf 0 0 outbuf 0 buffer_size Z_FINISH in
    flush outbuf used_out;
    if not finished then compr_finish()
  in
    compr 0 0;
    deflate_end zs
@

<<function Zlib.compress_direct>>=
let compress_direct  ?(level = 6) ?(header = true) flush =
  let outbuf = Bytes.create buffer_size in
  let zs = deflate_init level header in
  let rec compr inbuf inpos inavail =
    if inavail = 0 then ()
    else begin
      let (_, used_in, used_out) =
        deflate zs inbuf inpos inavail outbuf 0 buffer_size Z_NO_FLUSH in
      flush outbuf used_out;
      compr inbuf (inpos + used_in) (inavail - used_in)
    end
  and compr_finish () =
    let (finished, _, used_out) =
      deflate zs (Bytes.unsafe_of_string "") 0 0
                 outbuf 0 buffer_size Z_FINISH in
    flush outbuf used_out;
    if not finished then compr_finish()
  in
  compr, compr_finish
@

<<function Zlib.uncompress>>=
let uncompress ?(header = true) refill flush =
  let inbuf = Bytes.create buffer_size
  and outbuf = Bytes.create buffer_size in
  let zs = inflate_init header in
  let rec uncompr inpos inavail =
    if inavail = 0 then begin
      let incount = refill inbuf in
      if incount = 0 then uncompr_finish true else uncompr 0 incount
    end else begin
      let (finished, used_in, used_out) =
        inflate zs inbuf inpos inavail outbuf 0 buffer_size Z_SYNC_FLUSH in
      flush outbuf used_out;
      if not finished then uncompr (inpos + used_in) (inavail - used_in)
    end
  and uncompr_finish first_finish =
    (* Gotcha: if there is no header, inflate requires an extra "dummy" byte
       after the compressed stream in order to complete decompression
       and return finished = true. *)
    let dummy_byte = if first_finish && not header then 1 else 0 in
    let (finished, _, used_out) =
       inflate zs inbuf 0 dummy_byte outbuf 0 buffer_size Z_SYNC_FLUSH in
    flush outbuf used_out;
    if not finished then uncompr_finish false
  in
    uncompr 0 0;
    inflate_end zs
@


%-------------------------------------------------------------

<<version_control/zlib.ml>>=
<<copyright camlzip>>

<<exception Zlib.Error>>

<<toplevel Zlib._1>>

type stream

<<type Zlib.flush_command>>

external deflate_init: int -> bool -> stream = "camlzip_deflateInit"
external deflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_deflate_bytecode" "camlzip_deflate"
external deflate_end: stream -> unit = "camlzip_deflateEnd"

external inflate_init: bool -> stream = "camlzip_inflateInit"
external inflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_inflate_bytecode" "camlzip_inflate"
external inflate_end: stream -> unit = "camlzip_inflateEnd"

external update_crc: int32 -> bytes -> int -> int -> int32
                   = "camlzip_update_crc32"
external update_crc_string: int32 -> string -> int -> int -> int32
                   = "camlzip_update_crc32"

<<constant Zlib.buffer_size>>

<<function Zlib.compress>>

<<function Zlib.compress_direct>>

<<function Zlib.uncompress>>
@


\subsection*{[[version_control/zlib.mli]]}

<<signature Zlib.compress>>=
val compress:
  ?level: int -> ?header: bool -> 
  (bytes -> int) -> (bytes -> int -> unit) -> unit
@

<<signature Zlib.compress_direct>>=
val compress_direct:
  ?level: int -> ?header: bool -> (bytes -> int -> unit) ->
  (bytes -> int -> int -> unit) * (unit -> unit)
@

<<signature Zlib.uncompress>>=
val uncompress:
  ?header: bool -> (bytes -> int) -> (bytes -> int -> unit) -> unit
@


%-------------------------------------------------------------

<<version_control/zlib.mli>>=
<<copyright camlzip>>
open Common

<<exception Zlib.Error>>

<<signature Zlib.compress>>

<<signature Zlib.compress_direct>>

<<signature Zlib.uncompress>>

type stream

<<type Zlib.flush_command>>

external deflate_init: int -> bool -> stream = "camlzip_deflateInit"
external deflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_deflate_bytecode" "camlzip_deflate"
external deflate_end: stream -> unit = "camlzip_deflateEnd"

external inflate_init: bool -> stream = "camlzip_inflateInit"
external inflate:
  stream -> bytes -> int -> int -> bytes -> int -> int -> flush_command
         -> bool * int * int
  = "camlzip_inflate_bytecode" "camlzip_inflate"
external inflate_end: stream -> unit = "camlzip_inflateEnd"

external update_crc: int32 -> bytes -> int -> int -> int32
                   = "camlzip_update_crc32"
external update_crc_string: int32 -> string -> int -> int -> int32
                   = "camlzip_update_crc32"
@


