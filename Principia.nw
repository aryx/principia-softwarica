\documentclass[]{article}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finalfalse\verbosetrue % see also other newif in Macros.tex

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------
\usepackage{docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\t subtitle? literate (system) programs for the third millenium :)
\l source code of an entire modern operating system, Plan 9 graphics and network

\hrule
\begin{quote}
Copyright \copyright{} 2015 Yoann Padioleau \\
Permission is granted to copy, distribute and/or modify this document,
under the terms of the GNU Free Documentation License, Version 1.3.
\end{quote}
\hrule

\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\section{Introduction}

Principia softwarica is a serie of books explaining how things work in a
{computer} by describing with full details all the {source code} of all
the essential software running on a typical computer. 
\l https://en.wikipedia.org/wiki/Computer#Software nice categories

Among those essential software are the {kernel}, the {shell}, the 
{windowing system}, the {compiler}, the {linker}, the {debugger}, etc.
The sections below will give an overview of each of those software.
They are mostly all {meta} programs,
programs dealing with other programs (also known as {system software}).
\l https://en.wikipedia.org/wiki/System_software
For instance the kernel is a program that {\em manages} other programs,
the compiler is a program that {\em generates} other programs.

\subsection{Motivations}

Why writing those books?

\begin{verbatim}

software is running the world! important to understand it :)
computer literate :)
for programmer, really important to undertand what is under the hood,
and here we want to go as deep as possible, full details, full code!
a concrete companion to "Computer systems: a programmer's pespective"

Note that lots of books to understand how computer works, 
on theory, concepts, of most of those
software (many kernel books, compiler, even debugger, not
so much windowing system, network stack, etc).
but rarely goes
in full details, which is what ultimately the code is about!
There are few books like minix, lcc, but covers
only a few essential software, and do not form a coherent set.

Enter Principia softwarica! many books for all essential software!
CAR Hoare wanted that (see Oberon book intro)

Which concrete software?
if look at typical computer, mac, windows, linux
right now huge codebase underlying. Impossible to understand.
But if reduced to its essence, we think not that complicated,
doable to have a full understanding of all the important concepts
until its final details, its source code

Also maybe to help people imagine a better system. Hard to invent
something if have no clue that it's actually not that hard to build
a complete thing.

We want to describe the source code of core software:

requirements:
 - open source, we will show the code, and we want people to be able
   to play with it, to modify it
 - small source, so can be described in books of reasonable size.
   needs to be a bit minimalistic.
 - as simple as possible, but not simpler
   so not x86, but ARM, and ARM but not Hack
   so not all C optimisations, but C not tiger
 - real, can run on real machine (e.g. raspberry!)
 - complete, need a graphic stack, a windowing system, a networking stack
 - coherent
 - self hosting: can recompile/run everything under the system itself


We think best candidate for principia is plan9!
LOC?

\end{verbatim}

\subsection{Plan 9}

The choice of plan9 may not be obvious, but it is in our opinion
the simplest and at the same time fairly complete operating system.
\l as simple as possible, but not simpler
If you look at the screenshot in Figure~\ref{fig:X}, you'll see
many features:
\begin{itemize}
\item multiple shells running multiple commands
\item a screen with basic graphics and windows managment
\item a simple clock graphical application
\item a simple program communicating through the network
\end{itemize}

By comparison if you look at the screenshot in Figure~\ref{fig:Y}
you'll see that Plan9 in essence provides the same core services
of MacOS, Linux or Windows.
\l multi tasking, graphics, windows, IO, etc

\begin{verbatim}

Plan9 is a sucessor to Unix. Unix + graphics + network better integrated.
Unix 2.0 in some sense.
Made by great programmers, great designers.
Minimalistic. Started from scratch! Not afraid to
rethink everything, even if not compatible anymore.
So smaller in the end and elegant. Removed all ugly stuff
The Right Way!
Very complete too (rio, /net, 5l) and a coherent set of software
because made by a small team of people.

\end{verbatim}


Here are other candidates that were considered but ultimately discarded:
\n (helps to appreciate even more how good plan9  choice is too):
\n dup: readme.txt

\begin{itemize}

\item Unix V6 (Ken Thompson et al.)
or its modern incarnation xv6 are too simple;
there is no graphics, no network
\l   http://minnie.tuhs.org/cgi-bin/utree.pl

\item GNU/Linux (Richard Stallman et al.) is far far bigger.
\l   http://www.gnu.org/
If you take the source code of glibc,
the Linux kernel, and X11, you'll get
orders of magnitude more source code than Plan9, even though
Plan9 provides in essence the same core services. 
Of course the Linux kernel contains thousands of specific device drivers,
glibc handles many different architectures, and X11 can support lots
of graphic cards; all of those things could be discarded when
presenting the core of those software. But their core is still far
bigger than Plan9 equivalent core.
\n Linux 1991, Plan9 1992 (but open source only in 2000)


\item XINU (Douglas Comer), has a network stack but the operating system itself
is too simple with no virtual memory for instance
\t and has multi processor support?
\l   http://minnie.tuhs.org/cgi-bin/utree.pl?file=Xinu7

\item Minix (Andrew Tannenbaum et al.) is bigger and does not provide a
simple windowing system as it relies on X11 
(which is far more complicated than plan9 Rio windowing system)
\l   http://minnie.tuhs.org/cgi-bin/utree.pl?file=Minix1.1

\item Hack (Noam Nisan and Shimon Shocken), excellent for understanding hardware, assemblers,
and even compilers, but the operating system part is really too simple
\l TECS 
\l http://www.nand2tetris.org/

\item MMIX (Donald Knuth) same issue than TECS
\l   http://www-cs-faculty.stanford.edu/~uno/mmix-news.html

\item STEPS (Alan Kay et al.) project, far more ambitious as
the goal is to have a full system in 20 000 LOC, but it is not
finished yet
\l this book is 30 000 Lines, but it's just the kernel (and actually not all of it)
\l   http://vpri.org/html/writings.php

\item Oberon (Niklaus Wirth)
\l   http://www.projectoberon.com/
\l   javascript emulator: http://schierlm.github.io/OberonEmulator/

\item TempleOS (Terry A. Davis)
\l   http://www.templeos.org/

\end{itemize}

\l - nuttx, ils ont meme une graphic stack, widget, window manager
\l - http://www.homebrewcpu.com/, full stack too, LCC, minix 2, tcp/ip, etc
\l - RECC collection (Robert Elder)
\l   http://recc.robertelder.org/ 
\l - short canonical programs:
\l   http://aosabook.org/blog/2014/01/call-for-technical-reviewers-for-500-lines-or-less/
\l   https://github.com/aosabook/500lines
\l - A tiny hand crafted CPU emulator, C compiler, and Operating System
\l   https://github.com/rswier/swieros

\subsection{C and ARM}
\n (and ocaml for a few books)
\n hopefully later a bit Rust, so safer than C

\begin{verbatim}

We will describe code in C, so assume knows C.
Big basis, but at least describe C compiler (written in C though ...)
targetting ARM (so conceptually can run compiler in your head
and manually hand translate all the code reduced to ARM assembly
that is a smaller basis).

We will focus on ARM architecture, so assume ARM machine.
Big basis again, but at least describe ARM emulator (written in C though ...
so loop :) )

nand2tetris better for that, just from nand!
but we focus on software, less hardware, so we assume a bit hardware.
But nand2tetris had bootstrapping issue too.
Ater all I wrote hack assembler and a few other things in ocaml :)

Raspberry Pi target machine? Qemu?
\end{verbatim}


\subsection{Literate programming}

\begin{verbatim}

oberon book:
Program listings play a key role [in those books], because they alone
 contain the ultimate explanations

 Will use LP, not raw program listings. Better.
 I actually lpized all those software!

\end{verbatim}

\subsection{Getting started}

\begin{verbatim}

url principia to install.
essentially git clone, git clone, configure, make, make run
with a few software to install first (git, qemu, gcc)


\end{verbatim}

\l or can try on Raspberry pi too.

\subsection{Requirements}

The \principia books are not introductions to programming,
computer science, or to any of its subfields.
For instance our book about the kernel is not an introduction
to operating systems. Indeed, we will assume the reader 
has already a vague idea of how an operating system
works and so is already familiar 
with concepts such as virtual memory, critical regions, interrupts, 
system calls, etc.
%
We will present with full details the source
code of different software, but we assume you already know
most of the \co{theory} and concepts behind those software.
The \principia books are there to cover the \co{practice}.
\n Software Practice and Experience style!

\t Master in CS. More to consolidate.


\subsection{Copyright}

\begin{verbatim}
Mostly code from plan9
\end{verbatim}

\subsection{Acknowledgments}

\section{Overview}

\begin{verbatim}
Core software

https://en.wikipedia.org/wiki/Computer#Software nice categories

\end{verbatim}
\n https://en.wikipedia.org/wiki/Computer#Software nice categories
\n https://en.wikipedia.org/wiki/Computer_software

\subsection{Code organisation}

\begin{verbatim}
kernel/
lib_core/
include/

assembler/ linker/ ...

sys/
\end{verbatim}

\subsection{Software architecture}
\n old: was Architecture overview but oxymoron, architecture is already an overview

\begin{verbatim}

 kernel use some of libc (malloc, a few globals) and 
 some of graphics libs.
 other use full libc.
 then rio use graphics stack

 then have /dev, /net, used by other


like in cs illuminated, show the different layers.
 - information

\end{verbatim}


\subsection{Bootstrapping}

\begin{verbatim}

put mkfile that builds plan9? 
and then run under real raspberry machine or qemu!
talk about kencc! but then show how can compile under itself!
(even kernel? yes if can make a floppy under qemu or rpi ...)

ROOT/

not complete in some sense, rely on 5i for the bottom
which is an incomplete simulator, and even loop because
rely on C. 
Nand2tetris is more complete in this sense. Its basis
is just the nand gate! everything is built on top of that after!
A bit like in math where can just rely on gentzen sequent calculus
and build everything on top of it (principia mathematic does that?)
We could even been build physically Hack (hmm but how enter
program in its memory? still an issue)

\end{verbatim}


\section{The Core System}

\subsection{The kernel, [[9]]}

\begin{verbatim}
basis. Without it nothing.
\end{verbatim}

\subsection{The core library, [[libc]]}

\begin{verbatim}
kernel bridge, malloc, threads
unicode
\end{verbatim}

\subsection{The shell, [[rc]]}

\begin{verbatim}
 first user program, using core lib, requiring
 compiler/assembler/linker. 
 (and actually relying also on lex/yacc)

\end{verbatim}
\l mv later though?

\section{The Development Toolchain}
\l bootstrapping issue

\subsection{The processor emulator, [[5i]]}

\begin{verbatim}
ARM
need to agree on a machine, specific archi.
not really part of toolchain, but good start.

\end{verbatim}

\subsection{The assembler, [[5a]]}

\begin{verbatim}
produce object files

\end{verbatim}

\subsection{The linker, [[5l]]}

\begin{verbatim}
link them! produce executable
\end{verbatim}

%\subsection{The macro processor, [[cpp]]}

\subsection{The C compiler, [[5c]]}

\begin{verbatim}
looping issue again here, bootstrapping.

More high level than assembler language ...
\end{verbatim}

\section{The Developer Tools}

\subsection{The editor, [[efuns]]}

\begin{verbatim}
in ocaml!
will use a bit the graphical stack
kinda of a complex application.
\end{verbatim}

\subsection{The builder, [[mk]]}

\begin{verbatim}
useful to build the whole plan9 itself!

\end{verbatim}

\subsection{The debugger, [[db]]}

\subsection{The profiler, [[prof]]}

\subsection{The code generators, [[lex]] and [[yacc]]}

\begin{verbatim}
in ocaml!
described because some of the soft before use thems
\end{verbatim}

\t Version control system

\section{Graphics}

\subsection{The graphics stack, [[/dev/draw]]}

\subsection{The windowing system, [[rio]]}

\section{Networking}

\subsection{The network stack, [[/net]]}

\subsection{The web browser, [[mmm]]}
\l in ocaml!

\section{Advanced Languages}

%%%\subsection{The toy frontend compiler, [[tigerc]]}
%%%\subsection{The backend compiler, [[c--]]}

\subsection{The Scheme interpreter, [[s9]]}

\begin{verbatim}
dynamic, very powerful

\end{verbatim}

\subsection{The OCaml (light) compiler, [[ocamlc]]}

\begin{verbatim}
static like C, but more expressive.
ultimate lang IMHO, even in 2015!
\end{verbatim}

\section{Utilities}

\begin{verbatim}
command line utilities
\end{verbatim}

\section{Applications}

%%%\subsection{The videogame, [[soldat]]}

\section{Related works}

\section{Conclusion}


\begin{thebibliography}{99}
\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
