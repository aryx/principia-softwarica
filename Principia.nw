\documentclass[]{article}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosetrue % see also other newif in Macros.tex

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------
\usepackage{docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica
}\\
Literate System Programs for the New Millenium\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\l source code of an entire modern operating system, Plan 9 graphics and network

\hrule
\input{docs/latex/Copyright}
\hrule

\begingroup
\hypersetup{linkcolor=blue}
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\section{Introduction}

\l computer, machine, programs, software, systems, source code, code, processes

Principia softwarica is a serie of books explaining how things work in a
{computer} by describing with full details all the {source code} of all
the {essential software} used by a {programmer}.
\l https://en.wikipedia.org/wiki/Computer#Software nice categories

Among those essential software are 
the {kernel}, 
the {shell}, 
the {windowing system}, 
the {compiler}, 
the {linker}, 
the {debugger}, etc.
Each software will be covered by a separate book.
The sections below will give a quick overview of each of those software.
%
They are mostly all {meta} programs, that is
programs dealing with other programs (also known as {system software}).
\l https://en.wikipedia.org/wiki/System_software (short)
For instance the kernel is a program that {\em manages} other programs,
the compiler is a program that {\em generates} other programs.
\l we will not see applications

\subsection{Motivations}

Why writing those books?
%
The main reason is that I, Yoann, have always been curious and always
wanted to understand how things work under the hood, fully, to the 
smallest detail.
Software is now running the world; it is thus important to
understand all those software, to be computer literate.

There are already lots of books explaining how computers work, explaining
the {concepts}, {theories}, and {algorithms} behind software such as
kernels, compilers, a few also about debuggers, but
all those books rarely explain everything with full details, which
is what source code is all about. 
%
There are a few books which
include the whole source code of the software
described, e.g. the books about Minix, XINU, lcc, 
but those books cover only
a few essential software, mostly always either
the kernel or the compiler, and they do not form a coherent set.

Enter \principia, a set of books covering all essential
software, in a coherent way. In addition to the kernel and compiler,
\principia covers also
the graphics stack, 
the networking stack, 
the windowing system, 
the assembler, 
the linker, 
and many other important software
that have never been fully explained before to the best of our knowledge.
\l with full details, as deep as possible, with all the source code.

We want to demistify those software by showing their code
and by showing that they are actually not that complicated.
As a side effect it will also maybe help people imagine better systems.
Indeed it can be very intimidating to invent something completely new
if you have no clue that it is actually not that hard to build from
scratch a complete operating system.

\l CAR Hoare wanted that (see Oberon book intro), show real code

Another motivation for those books, in addition to satisfy our curiosity, 
is that we think you are a better programmer if you understand
how things work under the hood. 
%
In our opinion, you become a better C programmer
if you understand roughly what code generates the C compiler.
A good way to write more efficient code, or to avoid
writing really slow code, is to have some ideas of the
assembly code that will be generated for your code by
the compiler. 
%
In the same way, you can better use resources, e.g. memory, if you
have some ideas about how the kernel manages for you
these resources. You can better fix latency issues if
you understand how the networking stack works.
\l a concrete companion to "Computer systems: a programmer's pespective"


We also think it is easier to debug
programs if you better understand the environment in which
those programs evolve, if you understand the whole
software stack, and how things interact with each other.
Indeed, to fully understand certain error messages, e.g. from the kernel,
from the networking stack, or from the linker, it is very useful
to have some ideas about what those software do.
Moreover, even if in most situations the bug is in your program,
it could also be sometimes in a core library, in the kernel,
in the compiler, or in the linker. 
It is rare, but when
those situations happen, if you have no clue about
the environment in which you program runs, you will
never been able to fix your program.
\l it happens at facebook, and those people like maurer, paul saab are valued



Here are a few questions we hope the \principia books will answer:
\begin{itemize}
\item What exactly happens when the user type [[ls]] in a terminal?
What are the set of software involved in such a command? What
is the trace of such a command through the different layers
of the software stack, from the keyboard interrupt to
the display of text glyphs on the screen?
\item How a debugger works? Does it rely on special
services from the machine or from the kernel to implement
breakpoints?
\item How source code gets compiled, assembled, linked,
and finally loaded in memory? What is the memory image
of a program? How it relates to the original source code?
How a debugger can display debugging information on a binary?
\item Which software does memory allocation? The kernel?
The C library? How [[malloc()]] is implemented?
How it relates to the [[sbrk()]] system call?
\item How certain graphical elements, rectangles, ellipses, fonts, are
rendered on the screen? How the graphics card helps? How
the kernel helps? How things are intercepted
by the windowing system to make sure applications can not
draw in other windows?
\item What happens when you open a connection to another machine?
When you type a URL in your web browser? How one can
achieve a reliable communication on an unreliable physical network?
\item What does it take to port an entire operating system
on a new architecture, e.g. on the Raspberry Pi?
\end{itemize}





\subsection{The ideal teaching operating system}

Very few programmers actually fully understand how everything work, 
how things interact with each other. It is easy to find
programming languages specialists, or kernel specialists, but
it is very rare to find people who can write compilers and
at the same time have a very good knowledge of the kernel
or networking stack and can optimize things also at this level.
%
Such programmers though are tremendously useful in companies
because they can think at multiple levels and optimize things globally.
\l saab, maurer at facebiij
%
It is even more difficult those days 
to find those knowledgable programmers as
the code of the major operating systems, Linux, Windows, and MacOS
is just gigantic, with hundreds of millions lines of code (LOC).
It is impossible to understand such codebase.

We think there is hope though, that it is possible to understand fairly
well everything, that it is possible to answer all of the questions
mentioned in the previous section,
by focusing on the {essence} of those major operating systems.
Here by operating system we mean not only the kernel but also
all the software that is useful to operate the machine (the compiler,
windowing system, etc).
We think it is possible to find and describe an operating system
with similar capabilities to the mainstream operating systems,
with a fraction of their code size.

Here are the requirements for an ideal teaching
operating system which we could use as the basis for our
\principia books:

\begin{itemize}
\item {open source}: we want to show (lots of) code, 
and we want people to be able
to play with such code, to modify it, so our ideal operating
system must be open source

\item {small}: so the software can be described in
books of reasonable size. The software needs to be a bit minimalistic.

\item {as simple as possible, but not simpler}: we want
small code, but we don't want to show toy code.
For instance ARM is probably a simpler architecture than x86
so it makes sense to present the code of an ARM assembler
rather than an x86 assembler, but we don't want to show
a toy assembler for a toy architecture.
In the same way we can present the code of a C compiler
without certain advanced state of the art
optimisations, to simplify the presentation,
but we don't want to show a toy compiler for a toy language.

\item {real}: it has to run on real machines, e.g. a Raspberry Pi,
an x86 desktop, or a PC laptop.

\item {complete}: it needs to not only have a kernel and a compiler
but also a graphics stack, a networking stack, a windowing system, etc.

\item {coherent}: the whole set of software must form a coherent
set, so that the interactions between those software can also be
described, succintely.

\item {self hosting}: we want to be able
to recompile and run everything under the system itself.

\end{itemize}

\l jean louis gasse nostalgia about the time solo programmers could do huge
%  things, when things were still manageable (os, compiler, etc)
%http://www.mondaynote.com/2015/08/24/a-salute-to-solo-programmers/

We think such an ideal teaching operating system exists, we think
it is \plan!

\subsection{\plan}

\plan\furl{plan9.bell-labs.com/plan9/}
is the successor of Unix. It was designed from scratch
by the original designer of Unix (Ken Thompson) as well as a few other great
programmers and designers (Rob Pike, Dave Presotto, Phil Winterbottom).
The goal was to reinvent Unix and better integrate graphics
and networking. In some sense \plan is a kind of Unix 2.0.

The choice of \plan as the basis for our \principia books
may not be obvious, but it is in our opinion
the simplest and at the same time fairly complete operating system.

If you look at the screenshot of \plan in action in Figure~\ref{fig:plan9},
you'll see many features:
\begin{itemize}
\item multiple shells running multiple commands

\item a screen with basic graphics and windows managment

\item a simple clock graphical application

\item a simple program communicating through the network

\end{itemize}

By comparison, if you look at screenshots of other systems,
you'll see that \plan in essence provides the same core services
than MacOS, Linux or Windows,
\l multi tasking, graphics, windows, IO, etc
with a codebase that is significantly smaller.
Indeed, our fork of \plan, which includes all the
essential software described in all our \principia book, and a 
few more programs, 
is less than 400 KLOC.
\n via make loc from the root directory

\begin{verbatim}
Minimalistic. Started from scratch! Not afraid to
rethink everything, even if not compatible anymore.
So smaller in the end and elegant. Removed all ugly stuff
The Right Way!
Very complete too (rio, /net, 5l) and a coherent set of software
because made by a small team of people.

Why is X so big - Ken thompson / http://c2.com/cgi/wiki?PlanNineFromBellLabs
\end{verbatim}



\subsection{The C language and ARM architecture}
\n (and ocaml for a few books)
\n hopefully later a bit Rust, so safer than C

% not MIXAL and MMIX

\begin{verbatim}

We will describe code in C, so assume knows C.
Big basis, but at least describe C compiler (written in C though ...)
targetting ARM (so conceptually can run compiler in your head
and manually hand translate all the code reduced to ARM assembly
that is a smaller basis).

We will focus on ARM architecture, so assume ARM machine.
Big basis again, but at least describe ARM emulator (written in C though ...
so loop :) )

nand2tetris better for that, just from nand!
but we focus on software, less hardware, so we assume a bit hardware.
But nand2tetris had bootstrapping issue too.
Ater all I wrote hack assembler and a few other things in ocaml :)

Raspberry Pi target machine? Qemu?
\end{verbatim}


\subsection{Literate programming}

\begin{verbatim}

oberon book:
Program listings play a key role [in those books], because they alone
 contain the ultimate explanations

 Will use LP, not raw program listings. Better.
 I actually lpized all those software!

\end{verbatim}

\subsection{Getting started}

To play with the different software described in the \principia books,
we recommend to install our fork of \plan. See \urlprincipia.
\l what is special about this fork?
%
The installation essentially consists in cloning our fork of \plan
and cloning our fork of Ken Thompson's C (cross) compilers, [[kencc]].
You can then compile [[kencc]] using a regular C compiler (e.g. [[gcc]]).
Then you can {cross compile}, e.g. from MacOS or Linux, the \plan kernel,
the C standard library, and then the whole \plan operating
system, with all its libraries and software,
using the \plan C cross compilers ([[kencc]]) installed in the previous step.
\l also need plan9port

Finally, you can run \plan either under Qemu, which makes it
easy to experiment, or you can also install it on a
real machine such as a Raspberry Pi.

\subsection{Requirements}

The \principia books are not introductions to programming,
computer science, or to any of its subfields.
%
For instance our book about the kernel is not an introduction
to operating systems. Indeed, we will assume the reader 
has already a vague idea of how an operating system
works and so is already familiar 
with concepts such as 
virtual memory, 
critical regions, 
interrupts, 
system calls, etc.

We will present with full details the source
code of different software, but we assume you already know
most of the {concepts}, {theories}, and {algorithms} behind those software.
The \principia books are there to cover the {practice}.
\n Software Practice and Experience style!
We assume our readers are mainly students in computer science with
a bachelor or PhD, and who desire to consolidate their knowledge
by reading the ultimate computer science explanations: the source code
of major software.

Because most of the books are made of C source code, 
you'll need to have a good knowledge of 
the C programming language~\cite{k-r} to understand them.


\subsection{Copyright}

Most of the software in \principia are \plan software with copyrights
from Lucent Technologies Inc. They are open source though; permission
is granted to copy, distribute and/or modify the source code.

\subsection{Acknowledgments}

We would like to acknowledge of course \plan's authors who wrote
in some sense most of the content of the \principia books: 
Ken Thompson, Rob Pike, Dave Presotto, Phil
Winterbottom, Russ Cox, and many other people from Bell Labs.








\section{Overview}

\n https://en.wikipedia.org/wiki/Computer#Software nice categories
\n https://en.wikipedia.org/wiki/Computer_software

\subsection{Code organisation}

Table~\ref{tab:code-orga} presents a short description
of the main directories in our \plan fork
as well as the corresponding sections in this document
in which the software associated with the directory is discussed.
%
Table~\ref{tab:other-dirs} presents the remaining directories.

A few \plan software have some architecture specific parts,
with support for x86 and ARM.
The LOC in the table accounts only for the code to support
one of the architecture, ARM.

\begin{table*}[tbh!]
\begin{tabular}{lllr}
\toprule
{\bf Directory} & {\bf Description} & {\bf Section} & {\bf LOC} \\
\otoprule
[[kernel/]] & The \plan kernel (no graphics, no network) & \ref{sec:kernel} & 60 000 \\
            & graphics stack, kernel code & \ref{sec:graphics}  & 10 000 \\
            & network stack, kernel code & \ref{sec:network} & 23 000 \\
[[include/]] & The header files, especially [[core/libc.h]] & 
   \ref{sec:libc} & 5 500 \\
% no x86, just ARM
[[lib_core/]] & The core C library & \ref{sec:libc} & 21 500 \\
% no x86, just ARM
[[shells/]] & The shell & \ref{sec:shell} & 7 500 \\

\midrule
[[machine/]] & The ARM emulator & \ref{sec:emulator} & 4 400\\
[[assemblers/]] & The ARM and x86 assemblers & \ref{sec:assembler} & 4 100 \\
% includes also include/arm/5.out.h, no x86 just ARM
[[linkers/]] & The ARM and x86 linkers & \ref{sec:linker} & 9 600 \\
% includes also include/debug/a.out.h and a few other header files, no x86
[[compilers/]] & The C compiler with ARM and x86 backends & \ref{sec:compiler} &25 000 \\

\midrule
[[editors/]] & The editor & \ref{sec:editor} & 10 000\\
%ocaml, but not the pfff major modes
[[builders/]] & The [[mk]] tool & \ref{sec:builder} & 4 800 \\
[[debuggers/]] & The debuggers [[db]] and [[acid]] & \ref{sec:debugger} & 17 000\\
% no x86 just ARM
[[profilers/]] & The profilers & \ref{sec:profiler} & 4 900 \\
[[generators/]] & The code generators [[lex]] and [[yacc]] & \ref{sec:generators} & 3 500\\
%ocaml

\midrule
[[lib_graphics/]] & A large part of the graphics stack & \ref{sec:graphics} & 16 000 \\
% does not include kernel/, but include include/graphics/
[[windows/]] & The windowing system & \ref{sec:windowing} & 10 500\\

\midrule
[[lib_networking/]] & A small part of the network stack & \ref{sec:network} & 1 000\\
[[networking/]] & Networking applications, clients and servers & \ref{sec:network} & 75 000\\
%ocaml
[[browsers/]] & The web browser & \ref{sec:browser} & \\

\midrule
[[interpreters/]] & The Scheme interpreter & \ref{sec:scheme} & 4 600\\
[[languages/]] & The OCaml compiler & \ref{sec:ocaml} & 30 000\\
%ocaml, but not the native code compiler, nor external/libs nor debugger


\midrule
[[utilities/]] & Utilities such as [[ls]], [[cp]], [[mv]] & \ref{sec:utilities} & 16 000\\
               & [[grep]], [[gzip]], [[tar]], [[sed]], [[diff]], & \\
               & [[xargs]], [[ps]],  etc & \\
\otoprule
Total & & & 363 900 \\
\bottomrule
\end{tabular}
\caption{Main directories of the \plan source code repository}
\label{tab:code-orga}
\end{table*}
\n for the LOC it's a mix of cm -test_loc CROSS xxx/, or make loc in the dir


\begin{table*}[tbh!]
\begin{tabular}{llll}
\toprule
{\bf Directory} & {\bf Description} & \\
\otoprule
[[docs/]] & Articles and man pages  \\
[[ROOT/]] & The target directory where compiled binaries and libraries will \\
          & be installed which will form the \plan {distribution} \\
[[sys/]] & Backward compatible directory containing \\
         & mostly symbolic links and build scripts  \\
[[ape/]] & ANSI and POSIX environment, to ease \\
         & the compilation of legacy UNIX applications & \\
[[CROSS/]] & Scripts to support cross compilation  \\

\midrule
[[security/]] & Security, authentification, cryptography \\
[[lib_math/]] & Arbitrary precision mathematics library \\
[[lib_misc/]] & String, regexps, and compression libraries  \\
[[typesetting/]] & Tools to generate documents [[troff]], [[tbl]], [[pic]], [[grap]], [[eqn]] and [[man]] \\
[[database/]] & Simple key-value database, mostly used for storing network information \\
[[games/]] & Video games \\
[[misc-apps/]] & Small applications \\
[[BIG/]] & software of interest not yet included \\
[[version_control/]] &  \\
[[lib_audio/]] & \\
\bottomrule
\end{tabular}
\caption{Other directories}
\label{tab:other-dirs}
\end{table*}


\subsection{Software architecture}
\n old: was Architecture overview but oxymoron, archi is already an overview

\begin{verbatim}

 kernel use some of libc (malloc, a few globals) and 
 some of graphics libs.
 other use full libc.
 then rio use graphics stack

 then have /dev, /net, used by other


like in cs illuminated, show the different layers.
 - information

\end{verbatim}


\subsection{Bootstrapping}

\begin{verbatim}

put mkfile that builds plan9? 
and then run under real raspberry machine or qemu!
talk about kencc! but then show how can compile under itself!
(even kernel? yes if can make a floppy under qemu or rpi ...)

ROOT/

not complete in some sense, rely on 5i for the bottom
which is an incomplete simulator, and even loop because
rely on C. 
Nand2tetris is more complete in this sense. Its basis
is just the nand gate! everything is built on top of that after!
A bit like in math where can just rely on gentzen sequent calculus
and build everything on top of it (principia mathematic does that?)
We could even been build physically Hack (hmm but how enter
program in its memory? still an issue)

\end{verbatim}




\section{The Core System}

What we call the {core system} is the minimal set of software that 
are needed to reach the point where the programmer can 
interactively launch other programs.
In the case of \plan it means the 
kernel, 
the shell, and the
standard C library.
%
The C library is used by the shell as the library provides
the necessary bridge to call the kernel from user applications
as well as memory allocation routines,
but it is actually also used internally by the kernel.

\l figure? showing relation between kernel/shell/libc?

\subsection{The kernel, [[9]]}
\label{sec:kernel}

The kernel is the program that {manages} other programs.
%
It is arguably the most important program; without the kernel
no other program can run. The kernel provides
the main abstractions of the computer and
{demultiplex} its resources (the processor,
the memory, and the input and output devices)
to multiple programs at the same time.

\subsection{The core library, [[libc]]}
\label{sec:libc}

The C library is the program that is {used} by all the other programs.
%
In the case of \plan the C library contains
the memory allocation routines and algorithms ([[malloc()]], [[free()]]),
the bridge to call the kernel (the system calls),
the unicode functions, and many other
utility functions.

\subsection{The shell, [[rc]]}
\label{sec:shell}

The shell is the program that {launches} other programs.
%
In \plan, and also in its ancestor Unix, the shell is a regular
user program. It does not have to be included in the kernel.
The user can actually change the shell without changing
the kernel.
\l requiring compiler/assembler/linker (and actually relying also on lex/yacc)
\l mv later though?

\section{The Development Toolchain}
\l bootstrapping issue

Once you have a terminal where you can launch programs,
you'll need a set of tools to produce those programs
from source code. The {development toolchain}
is a set of tools working together to be able to produce
{executables}.
This toolchain is made of
an assembler,
a linker,
and a C Compiler.

\n note that actually could be part of core system because need compiler
\n to compile the kernel ...

\l figure? showing the compilation pipeline?

\subsection{The processor emulator, [[5i]]}
\label{sec:emulator}

An emulator (or simulator) is a program that 
emulates the hardware and {run} another (binary) program.
%
It is not really a part of the development toolchain

\begin{verbatim}
ARM
need to agree on a machine, specific archi.
not really part of toolchain, but good start.

\end{verbatim}

\subsection{The assembler, [[5a]]}
\label{sec:assembler}

\begin{verbatim}
produce object files

\end{verbatim}

\subsection{The linker, [[5l]]}
\label{sec:linker}

\begin{verbatim}
link them! produce executable
\end{verbatim}

%\subsection{The macro processor, [[cpp]]}

\subsection{The C compiler, [[5c]]}
\label{sec:compiler}

\begin{verbatim}
looping issue again here, bootstrapping.

More high level than assembler language ...
\end{verbatim}

\section{The Developer Tools}

The {developer tools} are a set of tools which are not
strictly necessary to produce programs, like the software
development toolchain we've seen in the previous section, but which 
are really useful in the software development process.
Those tools are
the text editor,
the builder,
the debugger,
the profiler,
and code generators.

\l figure? showing the source code at the center and the tools around?

\subsection{The editor, [[efuns]]}
\label{sec:editor}

The editor is a program to help {write} programs.

\begin{verbatim}
in ocaml!
will use a bit the graphical stack
kinda of a complex application.
\end{verbatim}

\subsection{The builder, [[mk]]}
\label{sec:builder}

The builder is a program to help {build} programs
by calling appropriately tools from the development toolchain
such as the compiler, the assembler, the linker, etc.
%
The whole \plan operating system is built from scratch
by using a builder.

\subsection{The debugger, [[db]]}
\label{sec:debugger}

The debugger is a program that {commands} and {inspect} another program.

\subsection{The profiler, [[prof]]}
\label{sec:profiler}

The profiler is a program that {generates statistics} about another program.

\subsection{The code generators, [[lex]] and [[yacc]]}
\label{sec:generators}

Code generators are programs that generate other programs.
%
We will describe two such generators, [[lex]] and [[yacc]].
They provide both domain speficic languages (DSLs) to
help scan and parse languages.
They are used by a few other software in \principia 
(the assembler, the C compiler, the shell, the builder, etc).
\t in ocaml!


\t Version control system

\section{Graphics}

Up until now we have mostly seen {command line} tools
and interactions through a simple text-based terminal.
One of the most important invention in computer science though is the 
{graphical user interface} (GUI). Even regular
command line tools benefit from a graphical user interface
as one can run multiple tools in different {windows}
at the same time.

\l figure? showing screenshot and what the graphics stack does and what rio do?

\subsection{The graphics stack, [[/dev/draw]]}
\label{sec:graphics}

The graphics stack provides the basis on which
graphical application can be built. 
Graphical user interface elements such as menus,
windows, lines, texts, ultimately are rendered
on the screen using simple graphic operations provided
by the graphics stack.

\subsection{The windowing system, [[rio]]}
\label{sec:windowing}

One of the most important graphical application is
the windowing system. In some sense it
is an extension of the kernel and the shell; it is a
program that also {manages and launches} other programs,
represented by separate {windows}.

\section{Networking}

Up until now we have mostly seen software running on 
a single machine. We'll now switch to programs
that can communicate with each other on different machines.

\l figure? ???

\subsection{The network stack, [[/net]]}
\label{sec:network}

The network stack is a part of the kernel, fairly
large, which provides the necessary abstractions
for programs to communicate with each other on
different machines, using different protocols.

\subsection{The web browser, [[mmm]]}
\label{sec:browser}

\l in ocaml!


\section{Advanced Languages}

%%%\subsection{The toy frontend compiler, [[tigerc]]}
%%%\subsection{The backend compiler, [[c--]]}

\subsection{The Scheme interpreter, [[s9]]}
\label{sec:scheme}

\begin{verbatim}
dynamic, very powerful

\end{verbatim}

\subsection{The OCaml (light) compiler, [[ocamlc]]}
\label{sec:ocaml}

\begin{verbatim}
static like C, but more expressive.
ultimate lang IMHO, even in 2015!
\end{verbatim}

\section{Utilities}
\label{sec:utilities}

\begin{verbatim}
command line utilities
\end{verbatim}

\section{Applications}

% This is the limit that we fixed for \principia.
% We do not describe regular applications, only software
% that are relevant for the programmer. 

%%%\subsection{The videogame, [[soldat]]}

\section{Related works}

Here are other operating systems that were considered for \principia
but which were ultimately discarded:
\n (helps to appreciate even more how good our plan9 choice is):
\n dup: readme.txt

\begin{itemize}

\item Unix V6 (Ken Thompson et al.)
\furl{http://minnie.tuhs.org/cgi-bin/utree.pl},
\l tuhs = the unix heritage society
or its modern incarnation xv6
\furl{http://pdos.csail.mit.edu/6.828/2014/xv6.html},
are too simple;
there is no graphics, no network

\item GNU/Linux/X11 (Richard Stallman et al.)
\furl{http://www.gnu.org/}
is far bigger.
If you take the source code of 
the Linux kernel, 
the glibc,
bash,
binutils (gas, ld)
gcc,
emacs, 
make,
gdb, 
gprof,
flex, bison
and X11, you'll get
orders of magnitude more source code than \plan, even though
\plan provides in essence the same core services. 
Of course the Linux kernel contains thousands of specific device drivers,
glibc and gcc handle many different architectures, and X11 can support lots
of graphic cards; all of those things could be discarded when
presenting the core of those software. But their core is still far
bigger than the equivalent core in \plan.
\n Linux 1991, Plan9 1992 (but open source only in 2000)


\item XINU (Douglas Comer)
\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=Xinu7}
has a network stack but the operating system itself
is too simple with no virtual memory for instance
\t and has multi processor support?

\item Minix (Andrew Tannenbaum et al.)
\furl{http://minnie.tuhs.org/cgi-bin/utree.pl?file=Minix1.1}
is bigger and does not provide a
simple windowing system as it relies on X11 
(which is far more complicated than \plan windowing system)


\item Hack (Noam Nisan and Shimon Shocken)
\furl{http://www.nand2tetris.org/}
is excellent for understanding 
hardware, assemblers,
and even compilers, but the operating system part is really too simple.
\l TECS 

\item MMIX (Donald Knuth)
\furl{http://www-cs-faculty.stanford.edu/~uno/mmix-news.html}
same issue than for Hack

\item Squeak (Alan Kay et al.),
\furl{http://squeak.org/}

\item STEPS project (Alan Kay et al.)
\furl{http://vpri.org/html/writings.php}
is far more ambitious as
the goal is to have a full system in 20 000 LOC, but it is not
finished yet
\l the kernel book is 30 000 Lines, and it's just the kernel (and actually not all of it), so hmmm

\item Oberon (Niklaus Wirth)
\furl{http://www.projectoberon.com/} 
is an operating system,
compiler, 
and windowing system 
designed from scratch. It is
a great system, very compact, and fully documented in a book.
\l cite
It imposes though strong restrictions on the programmer:
only applications written in Oberon can be run. This is
very different from UNIX which acts more like a universal operating
system which can run anything, as long as it is compiled into
a binary.
\l   javascript emulator: http://schierlm.github.io/OberonEmulator/

\item TempleOS (Terry A. Davis)
\furl{http://www.templeos.org/}

\end{itemize}

\l too many other to list here, see the comment in the .tex
% - nuttx, ils ont meme une graphic stack, widget, window manager
% - http://www.homebrewcpu.com/, full stack too, LCC, minix 2, tcp/ip, etc
% - RECC collection (Robert Elder)
%   http://recc.robertelder.org/ 
% - short canonical programs:
%   http://aosabook.org/blog/2014/01/call-for-technical-reviewers-for-500-lines-or-less/
%   https://github.com/aosabook/500lines
% - A tiny hand crafted CPU emulator, C compiler, and Operating System
%   https://github.com/rswier/swieros
% - http://menuetos.net/, written in assembly

\section{Conclusion}


\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}
\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
