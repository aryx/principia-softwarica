-*- org -*-

* Problems

** 5c does not work anymore! can not parse even very simple programs

** kernel has pb if you touch the mouse during the boot

** kernel oops:
ctrl shift P ==> suice invalid address 0x0/0 in sys call pc= ...
what is that?

** Shell control? how kill process? C-c ?
 HOW INTERRUPT process?? see mk, I tried C-d, C-c, but could not stop

* Getting feedback, getting published

** contact other publishers?

*** MIT press? marie lee https://mitpress.mit.edu/content/marie-lee
cite TECS as major inspiration?

*** Michael K. Loukides <mikel@oreilly.com> (50% to famous author) Chetan?
 Bryan O'sullivan? Andrei?

*** go with lulu.com? 
http://www.lulu.com/sell

*** kickstarter/indiegogo?

*** ex to follow for distribution?
http://dev.stephendiehl.com/fun/
self published?

*** other

mcgraw hill, cambridge university press
no starch press

** send to people?

Erling?
katrik?

Alan Kay? HARC?

send to the guy who did "whole new world" video
https://www.destroyallsoftware.com/talks/a-whole-new-world

pichardie, ridoux, fradet, banatre
jarod, alok, julien
pike, russ, knuth
csapp authors

https://news.ycombinator.com/item?id=10572976

** prepare more things to discuss with publisher:

 - copyright issues?
   * copyright owner? 
   * if dont do full series? can I get back the copyright?
 - money issues
   * if series do good, augment percentage?
 - grouping of books? 1 with asm+linker+compiler? so not 18 but
   maybe 6 in total? fascicle a la Knuth?
 - english editors?
 - reviewers?
 - marketing?

 - contact Brian Kernighan? Part of the professional series?
   (like Hanson book, software tools, etc)

*** arguments for publisher

**** pro assembler/linker book

Not a toy. Powered plan9 used for years at Bell Labs.
And found new place in Go and Google.
So production-quality toolchain!

companies like Google/Facebook/Apple got pbs with assembler/linker toolchain.
Linker very slow. New machines, new infrastructure. binutils huge.
They invested money to make new one!

even llvm/clang decided finally to replace binutils. Sponsored by Apple,
made their own linker! lld.

Go used 5a/5l/5c internally. So google internally used binaries
produces by this toolchain (now Go switch to rewrite of those tools
in Go in 2015, but very similar code).
And Go powers an incrinsing numbers of services at Google,
but also in startups (e.g., Docker). .

Popular topic on HN. Many blog posts on ELF, toy hello world.

Trendy in research, see Oopsla paper on verified linking
(Xavier Leroy too formalized linking I think).

I could even generate code for Linux or mac OS or Windows (copy code
 in old version of Go).
Explain ELF! PE! Mach-O!

learn machine, for real! also float, mul64, shift.

I could also speak about how to make helloworld.s on Linux,
with a Real Stuff section! Same for linker. Like Hennessy and Patterson.
%real-world:

Also would be nice to have Further readings like in lcc book.

Can learn compiler a bit. Use more output of 5c -S so do
like in CSPP book, good insight in how compiler works.

By learning to write an assembler, you'll learn general techniques
useful in many programs. For instance, writing a lexer and parser,
error location, error management. Also debugging information
in output to precicely point back to original code, even when
code preprocessed. 
Learn also data structures: Lists, stacks, hash table.
And general algorithms: symbol table, def/use two-passes.
arith expression evaluator.

**** pro ARM

complicated x86, but now new opporunity, ARM! fundamental in phones,
become pervasive. So also learn about ARM!

Raspberry Pi! quite popular, including in publishing industry (many books).

A few classic books cover ARM now: hennessy patterson, in 2016!
 other book in 2014 about ARM assembly.
14 billions processors shipped in 2015.


**** argument pro plan9 or more generally pro non-mainsteam OSes

plan9 is quite popular on HN

plan9 programs, but many work on Linux, macos, windows, see plan9port!

Go used 5a/5l/5c internally! so Google!

xv6 is popular at MIT and all around! it's Unix, not even plan9!
 It's not Linux either, but it works.

**** arguments pro principia in general
code! master! fully understand!

learn from the master! software architecture for real!

learn data structures (hash table, lists, queues, graph, growing arrays)
algorithms (graph DFS, compression), 
parsing, 
lexing, 
error management,
debugging techniques.

Facebook, Google, they do those stuff: their own build system, compiler,
 debugger, network stack, kernel modifications, editors (well reuse
 open source components), database, etc.

education program: add exercises, nice extensions to the linker,
 assembler, nice projects for the students?

**** argument pro LP

more and more articles and blogs posted on HN where people use kinda
LP to explain quite some code.

A few books already in Addison-Wesley like that by Hanson
(C interfaces and implem and lcc book)

Software tools: 1976
 also John Lions classic comments on Unix v6? kernel 
Lcc: 1996
Principia: 2016 :)
=> every 20 years new wave :)

Also recent book about rendering that got an Oscar!


*** bundles

assembler + linker (+ machine | compiler)
graphics system + windowing system

compiler (including the macroprocessor)
libcore

kernel
network stack

builder + shell
debugger + profiler

editor
browser (great, but needs work)

ocaml
lex + yacc

utilities

** blog post?
Can finally trace and explain fully what happens when you type 'ls'! 

** Questions to Plan 9 people?


- plan 9? because unix v9? chapter 9 in programmer's manual? Section 9 in man?
- who are the authors of 5i? 5a? 5l? draw?
- why called rio? and 8-1/2?

- AEND?? reading syntax?
- symidx and symkind in ANAME entry? useful? redundant?
- why $ for constants in 5a? ok for $foo(SB) but why for all constants?
- why LPOOL?

- draw, Tom Duff coded parts?

also need discuss licensing issues, GPL compatible with creative commons?

** license: http://creativecommons.org/licenses/by-sa/4.0/
this one seems simple and good

use creative commons? like in llc.pdf? and atom manual?
 or bsd license; the bsd is so much shorter. Keep xix spirit, KISS
 even for the license.

* Books

** status
% of code understood (if forget a bit about advanced topics and extensions)
19 books ... hmm

**** 80% kernel (without network, without graphics)

**** 95% shell

**** 50% graphics system (can expose vga in kernel, memdraw)

**** 80% windowing system

**** 40% network system (including devmnt? rpc, etc?)

**** 10% libc (memory allocator, threads, unicode, ??)

**** utilities


**** 80% machine

**** 95% assembler

**** 95% linker

**** 70% C compiler

**** 50% ocaml compiler

**** 70% generator, lex/yacc



**** 90% editor

**** 50% debugger

**** profiler

**** 95% make

**** 15% browser


**** 10% game soldat


** Principia

*** reduce number of books? so easier to sell to publishers? or make bundles?
with 10 I already have something solid:
 - toolchain (5a, 5l, 5c)
 - kernel (9, libcore)
 - windowing system (draw, rio)
 - network (net)
 - tools (mk, rc)

*** table footnote on LOC in principia, so cleaner ARM and x86 mess
also add explanation in the text.

*** still? Turing machine section

*** terminal sessions for bootstrap programs, e.g interaction
in assembler0-M-card, or boot loader which ask boot cards
or tape

*** ascii kernel/shell/libc
hardware, kernel, libc, shell

*** ascii compiler pipeline
with .c on arrow

*** represent all books on one diagram?
could also have a screenshot of plan9 are link to books
in the screenshot?

*** other ascii diagrams for bootstrapping section?
for virtual memory? fs?


** All.nw

*** Put more examples of data next to the data definition, see THIH how he did.
Or even better unit tests!

*** Try also to have simpler version and debugging code in it, for instance simpler
ocamllex version, simpler SLR backend for ocamlyacc, no opti for C compiler,
etc.


*** less: fix bibtex and uppercase for titles for inproceeding stuff

*** less: fix ~/github/syncweb/scripts/noweblatex and generate correct
thing for << instead of xx

** -------------------------

** Compiler

*** intro+overview, so match the other books
may be easier to write, I can assume more, and I know more compilers
than other programs.

*** SEMI can remove the opti? check if can remove code and still
get a working compiler? or mv into its own file this opti
so more guarantees no interference with the rest.

*** try modify nodretval to disable ANOP
so that can test if can compile with -N to disable
regopt and see if it still work


*** understand

**** understand deadheads()?

*** LP split

**** LP split bcomplex()

**** LP split part of boolgen()
so can see the AB generated at the end

**** LP arrange tcomo() split

*** rename

**** rename reg field for Node, Prog, and Adr
overloaded

**** rename offset fields, too many of them

**** rename OPROTO -> OPARAM?

*** remove

**** remove old style proto, and non ANSI stuff?
TOLD, OLDPROTO
so no need tmerge

**** remove -B (non ANSI) so transform some warn in diag

*** LP aspectize?

*** read 

**** read articles on making compiler in 22 steps


**** read article again by ken thompson, will help to
understand for example the handling of complex returned values

**** read dragon book, lots of references to this book apparently,
will help understand acom()?

**** read johnson and ritchie paper (and latest thompson)
read aho?

**** read plan9 C compiler manual


*** errorcodeify compiler
so many different error conventions there ...

*** elements OYYY that appears after parsing?

*** restore the packxxx? dpchck?
was dead in assembler but live in compiler no?
look at kencc/?

*** change order AST? closer to my ast_c.ml?

*** Xconv study

*** cg on Node, see stuff unused, or stuff used only after parsing

*** move xnames in debugging section

*** !!!!bench it!!!! like compcert, evaluate how fast it is compared to
gcc ... use the benchmark of compcert? need backport the macos
binary to kencc? or try compile on linux? (would be good to compile
on linux anyway plan9 at some point anyway)

see ~/bench_c/

can bench on leroy's examples?
at least can bench between unoptimized version of 5c
and optimized one. See if worth the complexity.


*** mv code out of pswt.c, nullwarn, etc portable but not related to switch

*** look at all the debugging options
(and maybe try on tests/helloc.c)
and add relevant sections in TOC?

*** remove 64bit stuff?

*** move globals closer to their module?
look what I did for the assembler


** Linker.nw

*** revise whole book, annotate, fill TODOs, and fix

*** we -> I

*** program counter line table section

*** offset_to_r12, absolute_address
final_auto_size()

*** more WORDS rule, instead of ugly cases in switch
for LEXT, for all Lxxx

*** ARM architecture section in overview and overview/principles
can delay? Resolving needs that to make things clearer.

*** ARM format in codegen chapter, and finish the C_xXXX and immaddr()

*** datblk and endianess explanations

*** core DS big figure? list of Xxx, cond vs link, sym table link,
Adr, etc.

*** style: ambiguous to use "instruction"? use "object instruction"? 
or Asm5 instruction?


*** understand

**** SP? where is it saved? caller is responsible to restore?
see save and rest procedure with div?
what the compiler generates? 5c -S ?

**** immrot, look machine.nw semantic vs immrot() code

**** pool? immaddr? immhalf?

**** comment profiling section and the code that generate instructions,
can help also understand Assembler.nw

****  asmsym()

**** D_FILE1??


*** when used multiple times the same [xxx] = yyy entry
in 5i:
(1770)	DATA	itab+2040(SB)/4,$Ilsm+0(SB)
memchr: multiple initialization

*** errorcodeify linker

*** linker: debugging support section, can help understand
different kinds of entities

*** linker: lp split fields Prog, put closer to the functions that are using
them

*** linker: factorize the ugly gethunk


** Assembler.nw
mostly done

*** style: get rid of all those (virtual) or clarify
for code address, for memory address, for program counter

maybe use pseudo code address! less confusing with virtual code
address and virtual memory (but use virtual pc in asm.pdf)

similar issue with local vs private

*** learn

**** use of R15 instead of SB for hello? 

**** 5l opti with string -> code section? disable it?

**** R12? why need that? cant have static value for address of things?
need to pass though a content? is it because anyway there
is a symbol table?

**** look initstk, how R14 is set

**** look linker, look machine, learn about what BL actually
do regarding the registers


*** toy.s! helloworld.s with just interrupt
easier if can learn to use sam ... so can edit
from plan9 and refine

*** assembler: more output code generation part

*** assembler: lp split Sym and typeify fields
hmm but take care because 5a and va must define Sym in the same way
otherwise get some conflicts with aa/ when linking

*** assembler: lp split Gen?

*** reread manual assembler again, note concepts and explain better
things

*** less: xix-assembler.ml?

** Machine.nw
good to get closure after Assembler/Linker, full circle, also still
remaining issues.

*** intro+overview, so match the other books

*** code 5i: make a real prompt 5i>, more readable

*** EASY aspectize more Imem1 and Imem2, too complex right now

*** EASY core DS

*** EASY code orga?

*** soft archi

*** EASY command line interface
few examples

*** start with overview chapter, principles of machines
just simple description of a computer
or start with code orga?



*** look vi/, simpler?

*** LP split dpex()

*** add opcode_ir, opcode_class, opcode_cond
`so clearer what is derived from opcode and what is runtime

*** dodge the bullet, have a cleaner opcode enum?
with AND_0, AND_1, etc
but then arm_class code is less short ...

*** need machdata = armmach?

*** LPize the -=4 or make it cleaner,
like actually do the REGPC+=4 instead?

*** less: Instr -> InstrDecoder? InstrInfo?

** Make.mw
mostly done

mk: don't know how to make 'screen.h' in /Users/pad/github/fork-plan9/sys/src/9/pc

=> improve error! at least say where this screen.h come from

mk objtype=arm
does not work when run under plan9 :( rc issue apparently

** Shell.nw

*** Shell.nw intro+overview, so match the other books

*** read 

**** read article on sh

**** read code of Bourne original sh?
written in "BourneGol"

**** look bash source code?

*** aspectize error management at many places

*** bug: rc2 C-d => panic
use acid? need a /sys/lib/acid/port and /sys/lib/acid/386/
because remove some code?

rc2 is my own variant of rc with a simplified bootstrapcode,
so this is probably why C-d have some errors, because my bootstrap
is not correct.

*** function via emit(fnstr), nice :) fn are actually local variables? :)
and then eval?

*** EASY ctor, builtin, opcode
=> rename execxxx that are not builtins!

*** EASY more consistent type capitalized, and consistent use of typedefs
Code, Tree, etc


** Graphics.nw
Lots of things I don't know codewise and algorithmic wise, so interesting!

http://blog.golang.org/go-imagedraw-package

*** start explaining code! Core Data Structures chapter

*** use arctest.c and other tests to illustrate APIs?

*** svgalib? LOC? mgr? twin? draw from plan9port?

*** rename chunks with "layer" to "window"? or overlapping windows?
called layer originally in Blit paper by Pike,

*** still lots of special code when have no alpha
in src, or mask, or dest

*** still lots of special code when grey
in src, or mask, or dest

*** memfillpoly, split, mv opti in adv topics,
understand the sort and div and xscan and yscan

*** mention dtor too next to DS too?

*** understand Screen, screenimage in Display, etc

*** move more generic stuff that now just depends on gscreen to screen.c
like software cursor, graphical text mode

*** merge screenimage and gscreen in a screen.c?

*** remove hwdraw.c and iprint.c?


*** can get rid of vgavesa now? just put in BIG/?

*** apps/clock.c, try to understand main APIs, feel
 
*** Extra libmemdraw/draw.c, lots of stuff still
memimagedraw()? hwdraw?

*** memdrawtest.c? run?

*** follow one op until the end, full trace of a draw
rectangle!

*** EASY reorg initdisplay to better error managment style a la Linux style

*** EASY the drawxxx unmarshaller

*** LP split initdisplay
depends on previous item

*** LPize windows/layers/screens
in many places arguments can take an additional screenid
that complicate a lot things

** Window.nw

*** fix annotations on Windows.pdf

*** still? grammarly, send pdf!!
use pandoc to convert to docx?

remove grammarly recurrent subscription?

*** could have each thread section start with a zoom of the
big process archi, with more details with channel names,
DS

*** DS diagram? not sure; maybe too overwhelming. maybe later
or as summary of core DS chapter.

mousectl, keyboardctl, windows (with a set of rectangles
with window[0], window[1], etc?)
and the channels!

*** SEMI see my notes on history of windowing systems printed chapter

*** less: need ramfs for /mnt/ ??? because ugly DOS?
anyway, virtual FS mostly

*** look code of mgr? nanoX? similarities?
similar concepts? thread/process architecture?

*** split WCwrite

*** wbacknl()

*** EASY aspectize more sanity checking code

*** put core DS of textual window content
see wcontent, put that earlier in core DS chapter

*** aspectize scrolling


*** wmousectl can be called with middle click or right click??
I think it's intercepted before

*** put file server before? will need to fully explain
graphical and textual windows anyway, with their /dev/xxx

*** understand mousethread drag and bandsize, what are the conditions?
winborder!! so LP split it to put in right section!

*** LP split window creation, mv stuff from new() and wmk()
below

*** debug rio? can have list of threads?

*** thread xxx, all places where threadname()


** Kernel.nw

*** resume, cleanup those proc_error, etc,
use regular names and put a special comment in the .tex.nw

*** plan9: filesystem

**** use the fs of xv6?
need to port to 9p though

is compatible also with mac, in the sense that can build distrib
from my mac I think, via their scripts/mkfs.c :)

**** simplefs? dosfs? instead of dossrv?
make my own? include dossrv core in kernel directly?

vfat is a bit ugly ... with the 8.3 original limitation and verrue
on top of it to handle longer filenames. but fat is compatible
easily with mac so easy to mount/inspect and make a distribution.

look paqfs, flashfs?
devtinyfs (from 9atom): hmm looks really a toy

*** plan9: understand stuff
start Windows.tex.nw? I would like to understand how xterm works with the
buffered input and redirection! but will need to understand lib_graphics and
lib_thread?

**** proctext, Qtext, put where?
nice redirection :) useful to have open indeed!

**** Qns, use of mountid?

**** umh = mount head when have union (that is at least 2)
if have just one then just use channel gqid itself, that is mh->mount-to
first Mount stuff.

**** pgrpid?

**** newfgrp(), just call duppgrp
and generalizes this?

**** have a type for type + dev + qid?
gqid? globally unique id?

**** consistent put vs close vs free, new vs dup vs alloc, dup vs cpy
cclose vs putmhead? newchan vs duppgrp?
put is a bad name I think.

**** 2 chans parameters of walk()? look at devwalk()?

**** have a typedef for permission and openmode, and use PERM_EMPTY instead of 0

**** -----------------------------------------------

**** serial? 8250 controller? qemu special console?
minicom?

**** include devmouse.c? in device?
even though not really used
cat /dev/mouse and do stuff?
also explain that actually draws the cursor somewhere?

**** remove Kmouse, seems not executed

**** try produce ^P that reboots?
need that when want to reboot at distance? hmm could just
run /bin/reboot no?

**** try produce ^U?

**** --------------------------------------------------------

**** lp split fault(), split error checking, split pagetable walk

**** lp split pio()
with demand load or swapping in case

**** lp split page fault
with demand load, copy on write, swapping in

**** lp split sysrfork()

**** lp split sysexec()

**** cachedel

**** -----------------------------------------------

**** how setup serial console! i8250console, rdb, etc?
C-Alt-3 on qemu?

**** more on meminit()?

**** assign dbgreg to the right section, try understand the debugger?
what about Trace_me too?

**** perfticks, fastticks, ??

**** implement a 'strace pid' that attach to existing process that works!
need write stop I think, and then not do the waitstop

**** understand ps and pstree

**** can emulate C-z? C-c? ask to 9fans? what about ulimit?

*** plan9: emails 9fans

**** report deadcode about OTRUNC?
because if put special logic for this special flag, should do the
same with the other like OCEXEC, etc no?

**** Ref for Mount? ugly cafebeef

*** plan9: add comments

**** keyboard comment
job of Keyboard section lead to adjust Conskbd things and
also echo back on the screen running the hooks

but then buffered input! when do \b then go back don't add in kbdq
for programs that read, and also block them until \n, and
in turn those programs can output stuff (but note that
it's the job of kernel to output keyboard typed key! not the program!)

**** add notes about simplified memory model

***** typedef page_or_swap?
and add note that pagedir/pagetable are in mmused, so not swappable.
only pages from process segments are considered for swapping.
PageOrSwap is used only at one place!

***** imitate more other archi so that don't need kmap thing?
if give less virtual space to process, and make kernel start earlier,
and that import limitations on DRAM, then far easier!

try first with changing KZERO and see if it compiles!

then add a check in memory detection that panic if too much memory!

maybe then can move this discussion in advanced chapter? like SMP
but called BIG MEMORY system?

***** rename CPU0PTE to CPU0KZEROPAGETABLE
and CPU0PDB to CPU0MMUPAGEDIR?

*****
Note that far less efficient that Intel way to represent things no?
but here we want to store the reverse information too? and free list.
and want
to be portable so have to store this info. Compute
sizeof info when use mmu and when use portable stuff?
for mmu:  1 mmupd (= 4KB), 1024 mmupt (= 1024 x 4KB) => 1025 Pages = 4Mo.
for plan9: 1 Segment (= x?), 1984 Pagetable* (= 1984 x 4B),
 1984 Pagetable (= 1984 x ?) + 1984 x 256 Page* (=? x 4B),
 = 1984 x 256 x Page (=? x ??) => ?? Mo?
 except can't have more Page than physical memory (+swap?)

sizeof Page? sizeof Pte?
will have enough of space to store meta data about all physical pages?
need it? could do without?

***** MAXKPA
can help to explain that when turn on segment+pagination (which we want,
it's a too nice hardware feature),
then every memory access involve the MMU. There is no way to do a 
MOV_WITH_DISABLED_MMU PHYSICAL_ADDRESS, AX.
MMU configured so that from KZERO up to 0xFFFFFFFF it's simple
mapping 1 to 1 to physical memory. Very simple. Convenient. so never fault
when access kernel data (and chicken and egg issues).
if kernel need access physical memory < maxkpa, great, easy.

But if machine has more than that ... then it needs
to adjust VPT to point to the right place ...
VPT itself is in virtual memory? chicken and egg?

    /*
     * can't go past the end of virtual memory
     * (ulong)-KZERO is 2^32 - KZERO
     */


***** understand the double map of kzero thing. Mentioned in balestero?
like in bcm, you can't enable pagniation if there is no identity mapping
for the first MB? it's like a pre condition?

***** can have fixfault from kernel? if don't use the VPT,
tmpmap, kmap, etc, can have a fault while in kernel code?

YES, for instance if process ask to write at certain va,
and do a syscall that for instance try to read /proc/self/mem
then procread could cause a fault addr when writing in va
if it's not allocated. It's ok.

***** more types?
Page* is abused for speaking about the page that can contain
many things, a page directory, a page table, user content, 
kernel content, other? introduce extra type?
typedef Page PageDirectory;?
typedef Page PageTable;?
typedef Page ??PageTable;

and also have the PortablePageTable vs MMUPageTable ...
and PortablePageDirectory vs MMUPageDirectory.

hmm but the name of the local pdb, pt, ... or field
should help find what kind of Page it is about.

***** mmuwalk, LEVEL1, LEVEL2 instead of 1 and 2, define enum!
so clearly explain data structure


*** plan9: kernel
spirit:
- use (and improve) codemap/codegraph to understand the code
- remove as much stuff as possible, especially optimizations (e.g. cache.c)
  but not too much, for instance support for SMP is important but can aspectize
  it and mv in in an Extra section

http://www.tldp.org/LDP/tlk/tlk-toc.html

**** keyboard issue: kencc bug? wrong compilation of unicode?
I only updated partially kencc/lib9 with UTFmax from 3 to 4, but
probably I have to port more code.

Alt-w-k does not generate the good character, how produce e cute?
I think kencc generates wrong things. 

**** halt works?
print when resume from halt?

put in power managment section?

**** typedef int error; !! OK0, OK1, ERROR1, ERRORNEG1
replace some of the int to error?

and make more consistent? some places where they do if(xx() < 0)
and where xx clearly does not return a count, then can
switch to a better error scheme.

count_or_error?

**** put back exit(1) in panic()
Also why so many Broken processes in ps?

panic because removed mtrrclock?

**** ----------------------------------------------------------


**** split some .c based on LP new TOC
(but use cg to make sure it does not depend on fancy stuff before doing the mv)

each time there is a newxxx there should be a file xxx.c and
if possible only the core stuff about this xxx in it
(so path.c, etc)

proc.c: 
 - scheduler.c
 - sleep_wakuep.c? or put in rendez?
 - notes.c
pgrp.c:
 - rendez.c? why in pgrp.c rendez vous stuff?
sysproc.c:
 - fork.c
 - exec.c

file.c:
 - path.c
 - block.c (mv stuff from iallocb.c and qio.c)
 - queue.c
 - fd.c? 

console.c:
 - cons_input.c
 - cons_output.c

files/env.c mv? in process/?

introduce ipc/ directory?

**** still? now that smaller kernel, can put on floppy? can do with
pbs? still this 'pbs' code is very ugly too

**** ------------------------------------------------------

**** still? disable SMP? easier to understand boot kmesgs?

**** less: remove in paddr() and kaddr() the ugly kern_addr2 and so on
hard to do

**** typedef enum xxx Xxx; ?

**** use foreach instead of those emap, end, etc
or at least be consistent and use nelem
or is it to avoid races? nah.

**** less: remove cpuserver?

**** again? remove vesa and realmode?
used by vga, vesa, can remove vesa support? cirrus logic not enough?
seems not enough last time I tried but maybe I did a mistake

**** still? try merge sched() and schedinit() and so remove need for Label
in cpu? can abuse the per-process kernel stack of another process
for more time?

Maybe can also try make sched() less defensive and panic earlier. I'm scared
we actually call sched() expecting the process would go to sleep
but it actually returns! like in qlock() ...

look balestero's notes!

**** lock return type? useless? send email?

**** semi: get rid of cache.c? or mv it closer to devmnt?

**** less: mv some err into error.h?

**** cleanup portdat_files.h, remove mnt stuff in devmnt?
or put more mnt stuff in devmnt? like mntrpc, etc.
Mnthead can stay in portdat_files.h though, for pgrp, but
specifics on mount and rpc not.

**** mv mpinit() in main.c?

**** get rid of some x86 cruft, like cmpswap386, etc?

**** get rid of ipv6? maybe better to understand first well
enough what is done in kernel/network/ in general

**** less: kerndate, cpuserver, do assign of kerndate = conf_kerndate; ?

**** make an alterative boot/ that is just boot.rc, no need boot/*.c

**** replace all those arenas by a more generic slab allocator?

*** plan9: lp

**** SEMI EASY more split LP devcons, put in the /dev/ section

**** SEMI EASY split LP /proc

**** less: LP split error.c?

**** -----------------------------------------------

**** less: rename more rendez vous r in something better
pager, clunq?

**** TVal -> Ttk?

**** kstack, kkstack?

**** ticks? = Hz per second clock interrupt?

**** syscall fd2path try to understand (in the end it's namec())

**** SEMI different forms of use of waserror, tricky
(but I start to get used to it, not so many ways)

**** do pathological case for xalloc, many
xalloc, free in the middle => fucked because too many holes

**** hzclock! and limited timerintr

**** split struct I8253, macro split FREQ and HZ, tod

**** i8253 with its field for timer

**** less: dumper category?

**** reread balestero's notes, should better understand more subtle things

** Libcore.nw

*** continue mv from Extra to Libcore.nw

*** Thread.nw (via Libcore.tex.nw)

**** understand alts()?
how listen to mouse and keyboard at the same time?
I didn't see any select syscall in plan9


** Network.nw

*** etheriq, etheroq
call pktin? or something else?

*** understand broadcast, how find route for ip out of range?

*** need self cache? /net/ipselftab is needed?

*** continue distribute for ipifc.c

*** reorg Route and Routetree?  simplify allocroute?
at the same time it's a nice opti, a clever C trick.

sizeof(Route) - sizeof(V6Route) + sizeof(V4Route)?
C compiler will honor that? no tricky padding?

*** EASY DP_DF aspectize

*** Qlisten?
comes with announce? does not use data?

*** import more stuff from snoopy?
the headers are cleans

*** continue understand IL

*** who calls pktin?

*** LP split ipifcadd, big, complex

*** netif? works with /net/ether/?

*** user initialization?

*** EASY factorize IPaddrelen kernel and user

*** EASY factorize hnputs stuff?
or even remove, the kernel is linked with libip anyway

*** try telnet? on google?

* Books later

** Remaining Xxx.nw
profiler
utilities

*** make graph
so can get order of files for the list_xx to be the basis
of pfff -lpizer

*** make check, scheckify, remove deadcode, useless export, or mv as forward decl
in .c

*** pfff -lpize

*** try pfff -lpizer that does more than just lp split!
what about inferring core DS? and their order?
and LP split fields? and find main? and LP split main?

** Compiler HLL (ocaml light)
see also ocaml/todo.start

*** remove more of Obj_val, Oid_val, etc, which mean
aspectize more also generic compare, hash, and marshall

*** lpize

**** caml_main LP split

**** aspectize exception mechanism
setjmp, from ocaml, from C

*** migrate from Extra to OCaml.nw for byterun/ stuff

**** gc DS

**** gc major

**** gc minor

*** later: last touch forward port threads

@@ -80,8 +80,9 @@ struct thread_struct {
   value * stack_threshold;
   value * sp;
   value * trapsp;
-  value backtrace_pos;          /* The backtrace buffer for this thread */
+  value backtrace_pos;          /* The backtrace info for this thread */
   code_t * backtrace_buffer;
+  value backtrace_last_exn;
   value status;                 /* RUNNABLE, KILLED. etc (see below) */

@@ -170,6 +171,7 @@ value thread_initialize(value unit)       /* ML */
   curr_thread->trapsp = trapsp;
   curr_thread->backtrace_pos = Val_int(backtrace_pos);
   curr_thread->backtrace_buffer = backtrace_buffer;
+  curr_thread->backtrace_last_exn = backtrace_last_exn;

@@ -232,6 +234,7 @@ value thread_new(value clos)          /* ML */
   /* Finish initialization of th */
   th->backtrace_pos = Val_int(0);
   th->backtrace_buffer = NULL;
+  th->backtrace_last_exn = Val_unit;

@@ -296,6 +299,7 @@ static value schedule_thread(void)
   curr_thread->trapsp = trapsp;
   curr_thread->backtrace_pos = Val_int(backtrace_pos);
   curr_thread->backtrace_buffer = backtrace_buffer;
+  curr_thread->backtrace_last_exn = backtrace_last_exn;

 try_again:
   /* Find if a thread is runnable.
@@ -488,6 +492,7 @@ try_again:
   trapsp = curr_thread->trapsp;
   backtrace_pos = Int_val(curr_thread->backtrace_pos);
   backtrace_buffer = curr_thread->backtrace_buffer;
+  backtrace_last_exn = curr_thread->backtrace_last_exn;


*** later: ocaml features to add for fork-efuns and other

**** later: fix Str to allow [xxx-] and also [xxx.-]

**** later: port the stuff from ocaml 2.?? that include info
in .cma so just need to add unix.cma and it will also add
the -cclib -lunix! useful! hide complexity

**** later: more backtrace support

1ca0e80c73759ff22c33660cd166af1095c2a835
Ameliore backtrace dans le cas ou l'exception est levee par une primitive C
 (PR#654)
was important indeed :) partially implemented to fix segfault in efuns

736d2cfe14b025da924c0c1aa3ebd293433edd63
47d37cc125e5650ec14d156e1c1eef74f0eb9871
64666f7de7af6e194cd147fd5a038196856c684f
PR#3809 wrong line numbers in backtrace (partial)

4b5512c74cda289652ff53c01098c53a6c4b0c7a
Stack backtraces on uncaught exceptions in native code (merge of the opt_backtrace branch)

5902603b2ca505299f141d33b891166e9b9a31d7
PR#4308 (partial fix): improve backtraces for 'spontaneous' exceptions such as Stack_overflow or Out_of_memory


*** fix compiler warnings

*** code organisation, I have a better picture now

*** lpize ml stuff part 2, tools/debugger!, tools/profiler?

*** later: typeclass, deriving, etc
woohoo


** VCS.nw

*** read more of dulwich? split in chapters, lpize?

*** mv code from Extra to main for camp
maybe good anyway even if not final candidate to look at some haskell code

*** mercurial 1.0? darcs 1.0? camp?

** Debugger.nw

*** mv from libmach Extra to Debugger

*** LP split Mach, Machdata

*** include ARM stuff

** Profiler.nw

** CompilerGenerator.nw

** Browser (mmm)
see also mmm/todo.txt

*** refactor (to help understanding)

**** have display_html and display_machine, which is confusing
=> better to have display_html, and then machine_html
so rename! or even interpret_html! or html_interpreter

**** more types? or better chapters?
type retriever?
type viewer?
type formatter?
type interpreter?
type cacher?

so Http.req has type retriever, more readable? factorize also
same for File.req, or a requester?

*** LPize

**** LP split stdctx

**** Plink.make
mv closer to parsing? or in core DS?
P for ?

*** aspectize 

**** aspectize frames, not in html5 anyway

**** aspectize more img and embedded

*** look at Form display :)
could learn stuff for my rsvp form :)

*** add "frame" and head_hook

*** test dumpers
URI?
URL?
link
request, headers
html
diff?

*** less: run scheck, remove deadcode?

*** later: CSS, JS, etc
implement enough for this examples:
https://khanacademy.org/html-css-js


* Extra books

** Compiler frontend (tiger)

*** understand linearization
LP split it

*** continue moving out code from Extra to Tiger.nw,

**** c-- generation chapter

*** change backend to 5a asm :) so can run under plan9 with 5i

**** register allocation

**** runtime support

**** gc

*** need uid? look in appel's book?

*** EASY fix the conflicts in the grammar

*** EASY get rid of all those mkXXX

** Intepreter.nw

*** switch to 2014 version? file not that much longer,
but better organized, more efficient,
and support call/cc

now that distributed first version, can now switch to other one
with same split, so also interesting to see evolution.

also maybe can do bench!

** Compiler backend (c--)
good to vary a bit, not always C code written by the same people :)
and also different language!

*** start migrate code from Cminusmins_extra.nw to Cminusminus.nw

*** weird: can not update to latests commons/ of pfff
get some linking errors


* Code

** plan9

*** purge a bit more networking/?, so can maybe get less than 300 000 LOC!!

*** now that have troff, can make 'man' to work?
need more fonts?

*** BUG!! if click with mouse on windows before it finish the kernel
then pb :(

git bisect? fault seems easy to reproduce determinstically
error message has a a i8042

*** BUG!! clock error


** 5l

*** figure out why lineno seems wrong in overview/hello.5 world.5
tutorial
maybe because wrong in object file too no? seems bug which I solved
via TSEMICOLON in 5a-in-ocaml
further

*** report bugs found detected by 5a/5l ocaml but not 5a/5l,
see tests/5a/cant_*.s

*** create pb crashing 5l when pool for C_LEXT?
no rule found? WORD rule matching?
then simplify code to use rules insted of ugly switch

*** create pb crashing 5l when etext becomes an LCON
and was a RECON first.

*** bug 5l things not initialized? email 9fans?
lucky that redefined alloc

*** MOVW foo(SB), R1 ??? meaning? cant_move_code.s
correct addressing? s->value of that?
real pc but then treated like an offset to R12??

*** rewrite code calling datblk, remove the -100
so simpler code, do that in callee,  pass offset start and end

*** need $-4? and why need leaf and no locals?

*** linker: rename Prog -> Instr?


*** rename

**** rename Gen -> Operand?

**** rename Adr -> Operand?

**** rename Prog -> Instruction?

**** disambiguate Prog.reg and Adr.reg, choose different names
add some unions for abuse of same field?


*** refactor

**** better orga symbol table with different namespace,
like in compiler! and now assembler

**** easy: designator for Mach fields


** 5a

*** bug 5a should report when BL foo+4(SB) because 5l overwrites it!

*** lineno right? not read too soon newline tok?
this is why 5l -W was wrong?

*** bug 5a with symidx not initialized? email 9fans?

*** bug 5a wrong prfile(), wrong line number. email 9fans?
port correct code from 5c in Lconv()?

*** EASY Always -> C_ALWAYS

*** Gen -> Operand, registr -> Register, zaddr -> outoperand
enum Registr (can Register?)
also Token chunk name -> token union

itab -> ttab
genval -> oval
cinit -> init
pinit -> pass_init
Sym -> Symbol
Sym_kind -> Symbol_kind



*** delete compat.c, inline the code mycreat, etc.

*** disambiguate Prog.reg and Adr.reg, choose different names
add some unions for abuse of same field?

*** use SYMIDX_NONE?

*** less: understand AHISTORY

*** introduce a D_ADDR? they abuse D_CONST I Think
for $ oreg



** draw

*** EASY screen -> desktop, or base layer? or root?
Baselayer!

*** EASY start renaming screen globals? draw_screen? screen_screen?
vga_screen?

**** big renames!! x_screen, screen -> layer, ...

*** lots of time they introduce local variable which alias
a field, but it leads to lots of boilerplate initializations.

*** comment all the opti, still works?
get rid of flushing opti
get rid of draw and windows opti, just draw on save everytime
get rid of windows stack opti, just draw in a painting fashion

** rio

*** EASY input -> winput? or current? or topw?
need save old value?

*** typedef uint text_cursor; or tcursor?
mcursor vs tcursor

** mk

*** rename files? word.c -> words.c

*** refactor did in a global!
(and check still no bugs!)

** 5c

*** use malloc instead of gethunk in cpp of 5c?
copy what I did for 5a?

*** put back full #pragma handling for 5c?

** Plan9

*** try compile mk with regular C compiler and lib9 of kencc!
=> faster devel loop!
same for rc!

*** get rid of elf.h? (at least move it out of include/)
I don't have macho.h anyway
hmm but to bench 8c it might be good at one point to
generate elf

*** try compile with lib9.h on mac?
lib9.h -> libc.h and have a -Include that puts it first!
in CROSS/MacOSX ?

** Kencc

*** compare with otool -h

*** make inm work for macho binaries?
still does not work :(

** libcore

*** strcmp is really ugly
strcmp(s->name, mactab[i].macname) == 0)
bool string__equal()!
macro? would like inline function ... hmm would like ocamlopt that does
this for you!

what is string_equal in Go? They use strcmp too?

* Code for Raspberry

** raspberry

latest:
https://code.google.com/p/inferno-rpi/

*** apparently plan9 can run on raspbery too!!!
This would be a better basis for a book (also more trendy)

*** rpi and qemu? copy what they have done for xv6-rpi?
https://code.google.com/p/xv6-rpi/source/diff?spec=svne6b8cc7138d0197d90c3b75426012e7490e03c6d&r=e6b8cc7138d0197d90c3b75426012e7490e03c6d&format=side&path=/src/Makefile

*** try ls compiled by 5c and run via 5i :)
hihihi

need 5c -f richard miller says, to compile with floating point hardware
or something. See plan9 mailing list answer by richard miller to my post.

* Misc

** Try install on linux for katrik
look at email of katrik

*** kencc: will have to adjust lib9.h like I did for Macos

*** $ROOT/sys/...
which will obleviate the need for make setup_host too!
do like in kencc?

** xv6: look at deps, cleanup? remove backward deps?
compile again? argh, cant use kencc

** Sam/acme? 
or rely more on efuns?

*** learn to use sam




