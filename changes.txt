-*- org -*-

* 0.17 (Q1 2018) (intro and overview Shell.pdf, GioGio!)

- intro+overview Shell.pdf
- lots of lineage.txt

* -----------------------------------------------------------

* 0.16 (Q4 2017) (VCS.pdf core-DS/main/, LPization git algorithms)

- core-ds/main/... VCS.pdf
- LP split diff_myers, basic edit distance, sha1, unzip
(git in ocaml v2: diff3 in ocaml, ???? zip in ocaml? merge? packing? network?)

* 0.15 (Q3 2017) (LPization VCS.nw, intro and overview VCS.pdf, GioGio!)

- LP split of dulwich for VCS.nw
- LP split of ocaml port of dulwich
- intro+overview VCS.pdf
(git in ocaml v1)

* 0.14 (Q2 2017) (GioGio!)

- LP split more Kernel.nw
(kernel in ocaml, until scheduler, but no real process, no files, basic memory)

- LP split more Graphics.nw
(draw in ocaml, just userspace side (libdraw/))

- LP split more Windows.nw
(rio in ocaml, and lib_system with 9P protocol)

* 0.13 (Q1 2017) (Kernel.nw port to Raspberry Pi, GioGio!)

- integrate Richard Miller's port of 9 to the Raspberry Pi (bcm/).
- adapt the kernel code to pad's style in Kernel.nw
- switch to ARM for Kernel.nw
!!it works under my Raspberry Pi!! Principia on Raspberry Pi!!

* -----------------------------------------------------------

* 0.12 (Q4 2016) (Make.pdf, LPized Libcore.nw, LP split understand Compiler.nw)

- finish Make.pdf v1
- first lpized version of Libcore.nw
- deeper understanding of Compiler.nw, better LP split
(5c typechecker and basic code generation in ocaml)

- Assembler.pdf v2, major revisions, finish Todos, more figures, better english

- started contact publishers


* 0.11 (Q3 2016) (intro and overview Make.pdf, LP split and understand Shell.nw)

- intro+overview Make.pdf
- deeper understanding of Make.nw, better LP split
(mk in ocaml)
- deeper understanding of Shell.nw, better LP split
(rc in ocaml)

(cpp in ocaml)
(5c parser in ocaml)

* 0.10 (Q2 2016) (intro and overview chapters for Graphics.pdf and Windows.pdf)

- intro+overview Windows.pdf
- intro+overview Graphics.pdf

- reorg code draw, rio

* 0.9 (Q1 2016) (LP split and understand more Graphics and Windows)

- deeper understanding of Graphics.nw, better LP split
- deeper understanding of Windows.nw, better LP split

- reorg code 5l, 5a, better tabular
(5l in ocaml)

* -----------------------------------------------------------

* 0.8 (Q4 2015) (Assembler.pdf, Linker.pdf)

- finish Assembler.pdf v1 (explanations for most chapters, figures)
(5a in ocaml)

- finish Linker.pdf v1 (explanations for most chapters, figures)

- Meeting Knuth! got emails from Knuth!

* 0.7 (Q3 2015) (marriage :), Principia.pdf)

- Principia.nw, the meta book! pretty good Principia.pdf

- started explaining the code and produce readable books:
  * Assembler.nw: intro + overview chapters finished
  * Machine.nw: intro chapter finished

- first lpized versions for:
  * Soldat (cruel hessian)

* 0.6 (Q2 2015) (plan9 port of ocaml/efuns, LPization Generator, Network)

Finished first lpized versions for almost all principia components except for
Libc/Profiler/Utilities.nw. Added a few other though (Efuns, OCaml, Mmm).

- OCaml, continue extensions (backtrace)
  and port to plan9!
- Efuns, continue extensions (minimap, position history, etc),
  and port to plan9!
- first lpized versions for
  * Lex/yacc Generator (actually ocamllex and my own ocamlyacc)
  * Network
  * Debugger (very partial)

* 0.5 (Q1 2015) (LPization Compiler, OCaml/Editor(Efuns)/Browser(mmm))

- switch to ARM for Compiler.nw
- continue work on
  * Linker.nw, Machine.nw, Assembler.nw
- switch to OCaml for Editor.nw, better than C candidates, and
  also for Browser.nw (and later for Generators.nw too)
- first lpized versions for a few ocaml programs:
  * Efuns (and ported it to mac, extended it, eshell, dircolors, etc)
  * Ocaml (light) (and simplified the code, removed objects, functors, etc)
  * Browser mmm

* -----------------------------------------------------------

* 0.4 (Q4 2014) (LPization Graphics/Window/Shell, Machine/Assembler/Linker, Make)

- first lpized versions of many components:
   * Machine, Assembler, Linker, Compiler, 
   * Graphics, Window, Shell,
   * Make, 
    with each time a similar procedure summarized in Template.nw
- switched to ARM, starting with Machine.nw, and then Assembler.nw, Linker.nw
- left facebook so full-time on principia

* 0.3 (Q3 2014) (pfff -lpize finer-grained split)

spent time on datalog and graph_code_c to answer questions I had while looking
at the kernel, such as who calls that, what constants can flow in this
integer field

- started Window.nw, Make.nw, etc.
- pfff -lpize which not only split in files but also split entities
  (thx to better pfff -parse_c), so quicker to get a first workable
  literate document
- change code to get codegraph -lang c to work on, and also introduced many
  globals.c to remove some backward dependencies.
- codegraph now works (conservatively) on the whole plan9

syncweb: pfff -lpize finer-grained split

* 0.2 (Q2 2014) (Kernel.nw)

- made a first version of the literate program for the kernel, good TOC,
  Kernel.nw
- almost full LPization, 20 chapters!!, aspectize, lp split, reorg again,
  try to understand almost every parts of the code, simplified the code many
  times (e.g. for virtual memory), removed dead code, renamed important
  structures (e.g. Mach -> Cpu, m->cpus, externup removal), added arch/, 
  get rid of edf.c, aspectized advanced virtual memory (MAXKPA), rename
  Pte to pagetable, more consistent pte, pt, pde, pd, mmupxxx
- 4 or 5 bugs reported on 9fans!

syncweb: -lpize initial, M-x pad-literate-split refresh

* 0.1 (Q1 2014) (fork kencc and plan9, cross compile whole distro from Mac)

- got kencc working on my mac (but had to backport features from plan9 labs 8c
  such as ELF support, and later some fixes related to unicode)
- forked kencc, cg/cm on kencc

- was able to cross compile 
   * the kernel, and then 
   * all the utilities, 
   * libraries
  (xv6 was actually hard to cross compile on Macos, binutils sucked)
- forked plan9 with the idea of making a xix based on plan9. I simplified 
  the code, removed support for some architectures, device drivers, etc
  I reorganized also a lot the code (and use xmv and symlinks to be compatible)
- was able to get to work on my own plan9 fork and my own plan9 distribution:
   * the kernel (via qemu -kernel), 
   * mini shell,
   * full shell,
   * dossrv
   * rio 
   * the network 
  very quick iterative loop!
- simplified a lot the kernel, removed many syscalls, lots of dead code,
  reorg in different directories. Used codemap/codegraph on .clang/.clang2
  and introduced hook to remove some backward deps, split portdat.h, dat.h, etc,
  used scheck on plan9 code, annotated code with @scheck for false positives
- read balestero's notes on plan9 kernel

* -----------------------------------------------------------

* Alpha (Dec 2013) (it runs!)

- got Plan9 working on Virtual Box and then QEMU (was not that easy,
  QEMU had some bugs and Plan9-labs was not very qemu friendly),
- played with rio! (30 dec 2013, just before new year :) )
