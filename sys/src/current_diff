Only in .: .#current_diff
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/arch.c /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/arch.c
--- ./9/bcm/arch.c	2014-01-24 19:18:34.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/arch.c	2012-07-26 04:52:43.000000000 -0700
@@ -1,223 +1 @@
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "../port/error.h"
-
-#include <tos.h>
-#include "ureg.h"
-
-#include "arm.h"
-
-/*
- * A lot of this stuff doesn't belong here
- * but this is a convenient dumping ground for
- * later sorting into the appropriate buckets.
- */
-
-/* Give enough context in the ureg to produce a kernel stack for
- * a sleeping process
- */
-void
-setkernur(Ureg* ureg, Proc* p)
-{
-	ureg->pc = p->sched.pc;
-	ureg->sp = p->sched.sp+4;
-	ureg->r14 = PTR2UINT(sched);
-}
-
-/*
- * called in sysfile.c
- */
-void
-evenaddr(uintptr addr)
-{
-	if(addr & 3){
-		postnote(up, 1, "sys: odd address", NDebug);
-		error(Ebadarg);
-	}
-}
-
-/* go to user space */
-void
-kexit(Ureg*)
-{
-	uvlong t;
-	Tos *tos;
-
-	/* precise time accounting, kernel exit */
-	tos = (Tos*)(USTKTOP-sizeof(Tos));
-	cycles(&t);
-	tos->kcycles += t - up->kentry;
-	tos->pcycles = up->pcycles;
-	tos->cyclefreq = m->cpuhz;
-	tos->pid = up->pid;
-
-	/* make visible immediately to user proc */
-	cachedwbinvse(tos, sizeof *tos);
-}
-
-/*
- *  return the userpc the last exception happened at
- */
-uintptr
-userpc(void)
-{
-	Ureg *ureg = up->dbgreg;
-	return ureg->pc;
-}
-
-/* This routine must save the values of registers the user is not permitted
- * to write from devproc and then restore the saved values before returning.
- */
-void
-setregisters(Ureg* ureg, char* pureg, char* uva, int n)
-{
-	USED(ureg, pureg, uva, n);
-}
-
-/*
- *  this is the body for all kproc's
- */
-static void
-linkproc(void)
-{
-	spllo();
-	up->kpfun(up->kparg);
-	pexit("kproc exiting", 0);
-}
-
-/*
- *  setup stack and initial PC for a new kernel proc.  This is architecture
- *  dependent because of the starting stack location
- */
-void
-kprocchild(Proc *p, void (*func)(void*), void *arg)
-{
-	p->sched.pc = PTR2UINT(linkproc);
-	p->sched.sp = PTR2UINT(p->kstack+KSTACK);
-
-	p->kpfun = func;
-	p->kparg = arg;
-}
-
-/*
- *  pc output by dumpaproc
- */
-uintptr
-dbgpc(Proc* p)
-{
-	Ureg *ureg;
-
-	ureg = p->dbgreg;
-	if(ureg == 0)
-		return 0;
-
-	return ureg->pc;
-}
-
-/*
- *  set mach dependent process state for a new process
- */
-void
-procsetup(Proc* p)
-{
-	fpusysprocsetup(p);
-}
-
-/*
- *  Save the mach dependent part of the process state.
- */
-void
-procsave(Proc* p)
-{
-	uvlong t;
-
-	cycles(&t);
-	p->pcycles += t;
-
-// TODO: save and restore VFPv3 FP state once 5[cal] know the new registers.
-	fpuprocsave(p);
-}
-
-void
-procrestore(Proc* p)
-{
-	uvlong t;
-
-	if(p->kp)
-		return;
-	cycles(&t);
-	p->pcycles -= t;
-
-	fpuprocrestore(p);
-}
-
-int
-userureg(Ureg* ureg)
-{
-	return (ureg->psr & PsrMask) == PsrMusr;
-}
-
-/*
- * atomic ops
- * make sure that we don't drag in the C library versions
- */
-
-long
-_xdec(long *p)
-{
-	int s, v;
-
-	s = splhi();
-	v = --*p;
-	splx(s);
-	return v;
-}
-
-void
-_xinc(long *p)
-{
-	int s;
-
-	s = splhi();
-	++*p;
-	splx(s);
-}
-
-int
-ainc(int *p)
-{
-	int s, v;
-
-	s = splhi();
-	v = ++*p;
-	splx(s);
-	return v;
-}
-
-int
-adec(int *p)
-{
-	int s, v;
-
-	s = splhi();
-	v = --*p;
-	splx(s);
-	return v;
-}
-
-int
-cas32(void* addr, u32int old, u32int new)
-{
-	int r, s;
-
-	s = splhi();
-	if(r = (*(u32int*)addr == old))
-		*(u32int*)addr = new;
-	splx(s);
-	if (r)
-		coherence();
-	return r;
-}
+#include "../omap/arch.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/coproc.c /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/coproc.c
--- ./9/bcm/coproc.c	2014-01-24 19:24:53.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/coproc.c	2013-01-07 12:48:58.000000000 -0800
@@ -1,200 +1 @@
-/*
- * arm co-processors
- * mainly to cope with arm hard-wiring register numbers into instructions.
- *
- * CP15 (system control) is the one that gets used the most in practice.
- * these routines must be callable from KZERO space or the 0 segment.
- */
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "io.h"
-
-#include "arm.h"
-
-enum {
-	/* alternates:	0xe12fff1e	BX (R14); last e is R14 */
-	/*		0xe28ef000	B 0(R14); second e is R14 (ken) */
-	Retinst	= 0xe1a0f00e,		/* MOV R14, R15 */
-
-	Opmask	= MASK(3),
-	Regmask	= MASK(4),
-};
-
-typedef ulong (*Pufv)(void);
-typedef void  (*Pvfu)(ulong);
-
-static void
-setupcpop(ulong instr[2], ulong opcode, int cp, int op1, int crn, int crm,
-	int op2)
-{
-	ulong instrsz[2];
-
-	op1 &= Opmask;
-	op2 &= Opmask;
-	crn &= Regmask;
-	crm &= Regmask;
-	cp  &= Regmask;
-	instr[0] = opcode | op1 << 21 | crn << 16 | cp << 8 | op2 << 5 | crm;
-	instr[1] = Retinst;
-
-	cachedwbse(instr, sizeof instrsz);
-	cacheiinv();
-}
-
-ulong
-cprd(int cp, int op1, int crn, int crm, int op2)
-{
-	int s, r;
-	volatile ulong instr[2];
-	Pufv fp;
-
-	s = splhi();
-	/*
-	 * MRC.  return value will be in R0, which is convenient.
-	 * Rt will be R0.
-	 */
-	setupcpop(instr, 0xee100010, cp, op1, crn, crm, op2);
-	fp = (Pufv)instr;
-	r = fp();
-	splx(s);
-	return r;
-}
-
-void
-cpwr(int cp, int op1, int crn, int crm, int op2, ulong val)
-{
-	int s;
-	volatile ulong instr[2];
-	Pvfu fp;
-
-	s = splhi();
-	setupcpop(instr, 0xee000010, cp, op1, crn, crm, op2); /* MCR, Rt is R0 */
-	fp = (Pvfu)instr;
-	fp(val);
-	coherence();
-	splx(s);
-}
-
-ulong
-cprdsc(int op1, int crn, int crm, int op2)
-{
-	return cprd(CpSC, op1, crn, crm, op2);
-}
-
-void
-cpwrsc(int op1, int crn, int crm, int op2, ulong val)
-{
-	cpwr(CpSC, op1, crn, crm, op2, val);
-}
-
-/* floating point */
-
-/* fp coproc control */
-static void
-setupfpctlop(ulong instr[2], int opcode, int fpctlreg)
-{
-	ulong instrsz[2];
-
-	fpctlreg &= Nfpctlregs - 1;
-	instr[0] = opcode | fpctlreg << 16 | 0 << 12 | CpFP << 8;
-	instr[1] = Retinst;
-
-	cachedwbse(instr, sizeof instrsz);
-	cacheiinv();
-}
-
-ulong
-fprd(int fpreg)
-{
-	int s, r;
-	volatile ulong instr[2];
-	Pufv fp;
-
-	if (!m->fpon) {
-		dumpstack();
-		panic("fprd: cpu%d fpu off", m->machno);
-	}
-	s = splhi();
-	/*
-	 * VMRS.  return value will be in R0, which is convenient.
-	 * Rt will be R0.
-	 */
-	setupfpctlop(instr, 0xeef00010, fpreg);
-	fp = (Pufv)instr;
-	r = fp();
-	splx(s);
-	return r;
-}
-
-void
-fpwr(int fpreg, ulong val)
-{
-	int s;
-	volatile ulong instr[2];
-	Pvfu fp;
-
-	/* fpu might be off and this VMSR might enable it */
-	s = splhi();
-	setupfpctlop(instr, 0xeee00010, fpreg);		/* VMSR, Rt is R0 */
-	fp = (Pvfu)instr;
-	fp(val);
-	coherence();
-	splx(s);
-}
-
-/* fp register access; don't bother with single precision */
-static void
-setupfpop(ulong instr[2], int opcode, int fpreg)
-{
-	ulong instrsz[2];
-
-	instr[0] = opcode | 0 << 16 | (fpreg & (16 - 1)) << 12;
-	if (fpreg >= 16)
-		instr[0] |= 1 << 22;		/* high bit of dfp reg # */
-	instr[1] = Retinst;
-
-	cachedwbse(instr, sizeof instrsz);
-	cacheiinv();
-}
-
-ulong
-fpsavereg(int fpreg, uvlong *fpp)
-{
-	int s, r;
-	volatile ulong instr[2];
-	ulong (*fp)(uvlong *);
-
-	if (!m->fpon)
-		panic("fpsavereg: cpu%d fpu off", m->machno);
-	s = splhi();
-	/*
-	 * VSTR.  pointer will be in R0, which is convenient.
-	 * Rt will be R0.
-	 */
-	setupfpop(instr, 0xed000000 | CpDFP << 8, fpreg);
-	fp = (ulong (*)(uvlong *))instr;
-	r = fp(fpp);
-	splx(s);
-	coherence();
-	return r;			/* not too meaningful */
-}
-
-void
-fprestreg(int fpreg, uvlong val)
-{
-	int s;
-	volatile ulong instr[2];
-	void (*fp)(uvlong *);
-
-	if (!m->fpon)
-		panic("fprestreg: cpu%d fpu off", m->machno);
-	s = splhi();
-	setupfpop(instr, 0xed100000 | CpDFP << 8, fpreg); /* VLDR, Rt is R0 */
-	fp = (void (*)(uvlong *))instr;
-	fp(&val);
-	coherence();
-	splx(s);
-}
+#include "../teg2/coproc.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/devether.c /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/devether.c
--- ./9/bcm/devether.c	2014-01-24 19:24:17.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/devether.c	2012-12-16 01:58:43.000000000 -0800
@@ -1,530 +1 @@
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "io.h"
-#include "../port/error.h"
-
-#include "../port/netif.h"
-#include "etherif.h"
-
-extern int archether(unsigned ctlno, Ether *ether);
-
-static Ether *etherxx[MaxEther];
-
-Chan*
-etherattach(char* spec)
-{
-	int ctlrno;
-	char *p;
-	Chan *chan;
-
-	ctlrno = 0;
-	if(spec && *spec){
-		ctlrno = strtoul(spec, &p, 0);
-		if((ctlrno == 0 && p == spec) || *p != 0)
-			error(Ebadarg);
-		if(ctlrno < 0 || ctlrno >= MaxEther)
-			error(Ebadarg);
-	}
-	if(etherxx[ctlrno] == 0)
-		error(Enodev);
-
-	chan = devattach('l', spec);
-	if(waserror()){
-		chanfree(chan);
-		nexterror();
-	}
-	chan->dev = ctlrno;
-	if(etherxx[ctlrno]->attach)
-		etherxx[ctlrno]->attach(etherxx[ctlrno]);
-	poperror();
-	return chan;
-}
-
-static Walkqid*
-etherwalk(Chan* chan, Chan* nchan, char** name, int nname)
-{
-	return netifwalk(etherxx[chan->dev], chan, nchan, name, nname);
-}
-
-static int
-etherstat(Chan* chan, uchar* dp, int n)
-{
-	return netifstat(etherxx[chan->dev], chan, dp, n);
-}
-
-static Chan*
-etheropen(Chan* chan, int omode)
-{
-	return netifopen(etherxx[chan->dev], chan, omode);
-}
-
-static void
-ethercreate(Chan*, char*, int, ulong)
-{
-}
-
-static void
-etherclose(Chan* chan)
-{
-	netifclose(etherxx[chan->dev], chan);
-}
-
-static long
-etherread(Chan* chan, void* buf, long n, vlong off)
-{
-	Ether *ether;
-	ulong offset = off;
-
-	ether = etherxx[chan->dev];
-	if((chan->qid.type & QTDIR) == 0 && ether->ifstat){
-		/*
-		 * With some controllers it is necessary to reach
-		 * into the chip to extract statistics.
-		 */
-		if(NETTYPE(chan->qid.path) == Nifstatqid)
-			return ether->ifstat(ether, buf, n, offset);
-		else if(NETTYPE(chan->qid.path) == Nstatqid)
-			ether->ifstat(ether, buf, 0, offset);
-	}
-
-	return netifread(ether, chan, buf, n, offset);
-}
-
-static Block*
-etherbread(Chan* chan, long n, ulong offset)
-{
-	return netifbread(etherxx[chan->dev], chan, n, offset);
-}
-
-static int
-etherwstat(Chan* chan, uchar* dp, int n)
-{
-	return netifwstat(etherxx[chan->dev], chan, dp, n);
-}
-
-static void
-etherrtrace(Netfile* f, Etherpkt* pkt, int len)
-{
-	int i, n;
-	Block *bp;
-
-	if(qwindow(f->in) <= 0)
-		return;
-	if(len > 58)
-		n = 58;
-	else
-		n = len;
-	bp = iallocb(64);
-	if(bp == nil)
-		return;
-	memmove(bp->wp, pkt->d, n);
-	i = TK2MS(MACHP(0)->ticks);
-	bp->wp[58] = len>>8;
-	bp->wp[59] = len;
-	bp->wp[60] = i>>24;
-	bp->wp[61] = i>>16;
-	bp->wp[62] = i>>8;
-	bp->wp[63] = i;
-	bp->wp += 64;
-	qpass(f->in, bp);
-}
-
-Block*
-etheriq(Ether* ether, Block* bp, int fromwire)
-{
-	Etherpkt *pkt;
-	ushort type;
-	int len, multi, tome, fromme;
-	Netfile **ep, *f, **fp, *fx;
-	Block *xbp;
-
-	ether->inpackets++;
-
-	pkt = (Etherpkt*)bp->rp;
-	len = BLEN(bp);
-	type = (pkt->type[0]<<8)|pkt->type[1];
-	fx = 0;
-	ep = &ether->f[Ntypes];
-
-	multi = pkt->d[0] & 1;
-	/* check for valid multicast addresses */
-	if(multi && memcmp(pkt->d, ether->bcast, sizeof(pkt->d)) != 0 &&
-	    ether->prom == 0){
-		if(!activemulti(ether, pkt->d, sizeof(pkt->d))){
-			if(fromwire){
-				freeb(bp);
-				bp = 0;
-			}
-			return bp;
-		}
-	}
-	/* is it for me? */
-	tome = memcmp(pkt->d, ether->ea, sizeof(pkt->d)) == 0;
-	fromme = memcmp(pkt->s, ether->ea, sizeof(pkt->s)) == 0;
-
-	/*
-	 * Multiplex the packet to all the connections which want it.
-	 * If the packet is not to be used subsequently (fromwire != 0),
-	 * attempt to simply pass it into one of the connections, thereby
-	 * saving a copy of the data (usual case hopefully).
-	 */
-	for(fp = ether->f; fp < ep; fp++){
-		if((f = *fp) != nil && (f->type == type || f->type < 0) &&
-		    (tome || multi || f->prom)){
-			/* Don't want to hear bridged packets */
-			if(f->bridge && !fromwire && !fromme)
-				continue;
-			if(!f->headersonly){
-				if(fromwire && fx == 0)
-					fx = f;
-				else if(xbp = iallocb(len)){
-					memmove(xbp->wp, pkt, len);
-					xbp->wp += len;
-					if(qpass(f->in, xbp) < 0)
-						ether->soverflows++;
-				}
-				else
-					ether->soverflows++;
-			}
-			else
-				etherrtrace(f, pkt, len);
-		}
-	}
-
-	if(fx){
-		if(qpass(fx->in, bp) < 0)
-			ether->soverflows++;
-		return 0;
-	}
-	if(fromwire){
-		freeb(bp);
-		return 0;
-	}
-	return bp;
-}
-
-static int
-etheroq(Ether* ether, Block* bp)
-{
-	int len, loopback, s;
-	Etherpkt *pkt;
-
-	ether->outpackets++;
-
-	/*
-	 * Check if the packet has to be placed back onto the input queue,
-	 * i.e. if it's a loopback or broadcast packet or the interface is
-	 * in promiscuous mode.
-	 * If it's a loopback packet indicate to etheriq that the data isn't
-	 * needed and return, etheriq will pass-on or free the block.
-	 * To enable bridging to work, only packets that were originated
-	 * by this interface are fed back.
-	 */
-	pkt = (Etherpkt*)bp->rp;
-	len = BLEN(bp);
-	loopback = memcmp(pkt->d, ether->ea, sizeof(pkt->d)) == 0;
-	if(loopback || memcmp(pkt->d, ether->bcast, sizeof(pkt->d)) == 0 || ether->prom){
-		s = splhi();
-		etheriq(ether, bp, 0);
-		splx(s);
-	}
-
-	if(!loopback){
-		qbwrite(ether->oq, bp);
-		if(ether->transmit != nil)
-			ether->transmit(ether);
-	} else
-		freeb(bp);
-
-	return len;
-}
-
-static long
-etherwrite(Chan* chan, void* buf, long n, vlong)
-{
-	Ether *ether;
-	Block *bp;
-	int nn, onoff;
-	Cmdbuf *cb;
-
-	ether = etherxx[chan->dev];
-	if(NETTYPE(chan->qid.path) != Ndataqid) {
-		nn = netifwrite(ether, chan, buf, n);
-		if(nn >= 0)
-			return nn;
-		cb = parsecmd(buf, n);
-		if(cb->f[0] && strcmp(cb->f[0], "nonblocking") == 0){
-			if(cb->nf <= 1)
-				onoff = 1;
-			else
-				onoff = atoi(cb->f[1]);
-			qnoblock(ether->oq, onoff);
-			free(cb);
-			return n;
-		}
-		free(cb);
-		if(ether->ctl!=nil)
-			return ether->ctl(ether,buf,n);
-			
-		error(Ebadctl);
-	}
-
-	if(n > ether->maxmtu)
-		error(Etoobig);
-	if(n < ether->minmtu)
-		error(Etoosmall);
-
-	bp = allocb(n);
-	if(waserror()){
-		freeb(bp);
-		nexterror();
-	}
-	memmove(bp->rp, buf, n);
-	memmove(bp->rp+Eaddrlen, ether->ea, Eaddrlen);
-	poperror();
-	bp->wp += n;
-
-	return etheroq(ether, bp);
-}
-
-static long
-etherbwrite(Chan* chan, Block* bp, ulong)
-{
-	Ether *ether;
-	long n;
-
-	n = BLEN(bp);
-	if(NETTYPE(chan->qid.path) != Ndataqid){
-		if(waserror()) {
-			freeb(bp);
-			nexterror();
-		}
-		n = etherwrite(chan, bp->rp, n, 0);
-		poperror();
-		freeb(bp);
-		return n;
-	}
-	ether = etherxx[chan->dev];
-
-	if(n > ether->maxmtu){
-		freeb(bp);
-		error(Etoobig);
-	}
-	if(n < ether->minmtu){
-		freeb(bp);
-		error(Etoosmall);
-	}
-
-	return etheroq(ether, bp);
-}
-
-static struct {
-	char*	type;
-	int	(*reset)(Ether*);
-} cards[MaxEther+1];
-
-void
-addethercard(char* t, int (*r)(Ether*))
-{
-	static int ncard;
-
-	if(ncard == MaxEther)
-		panic("too many ether cards");
-	cards[ncard].type = t;
-	cards[ncard].reset = r;
-	ncard++;
-}
-
-int
-parseether(uchar *to, char *from)
-{
-	char nip[4];
-	char *p;
-	int i;
-
-	p = from;
-	for(i = 0; i < Eaddrlen; i++){
-		if(*p == 0)
-			return -1;
-		nip[0] = *p++;
-		if(*p == 0)
-			return -1;
-		nip[1] = *p++;
-		nip[2] = 0;
-		to[i] = strtoul(nip, 0, 16);
-		if(*p == ':')
-			p++;
-	}
-	return 0;
-}
-
-static void
-etherreset(void)
-{
-	Ether *ether;
-	int i, n, ctlrno;
-	char name[KNAMELEN], buf[128];
-
-	for(ether = 0, ctlrno = 0; ctlrno < MaxEther; ctlrno++){
-		if(ether == 0)
-			ether = malloc(sizeof(Ether));
-		memset(ether, 0, sizeof(Ether));
-		ether->ctlrno = ctlrno;
-		ether->mbps = 10;
-		ether->minmtu = ETHERMINTU;
-		ether->maxmtu = ETHERMAXTU;
-
-		if(archether(ctlrno, ether) <= 0)
-			continue;
-
-		if(isaconfig("ether", ctlrno, ether) == 0){
-//			free(ether);
-//			return nil;
-			continue;
-		}
-		for(n = 0; cards[n].type; n++){
-			if(cistrcmp(cards[n].type, ether->type))
-				continue;
-			for(i = 0; i < ether->nopt; i++)
-				if(cistrncmp(ether->opt[i], "ea=", 3) == 0){
-					if(parseether(ether->ea,
-					    &ether->opt[i][3]) == -1)
-						memset(ether->ea, 0, Eaddrlen);
-				} else if(cistrcmp(ether->opt[i],
-				    "100BASE-TXFD") == 0)
-					ether->mbps = 100;
-			if(cards[n].reset(ether))
-				break;
-			snprint(name, sizeof(name), "ether%d", ctlrno);
-
-			if(ether->interrupt != nil && ether->irq >= 0)
-				intrenable(ether->irq, ether->interrupt,
-					ether, 0, name);
-
-			i = snprint(buf, sizeof buf,
-				"#l%d: %s: %dMbps port %#lux irq %d",
-				ctlrno, ether->type, ether->mbps, ether->port,
-				ether->irq);
-			if(ether->mem)
-				i += snprint(buf+i, sizeof buf - i,
-					" addr %#lux", PADDR(ether->mem));
-			if(ether->size)
-				i += snprint(buf+i, sizeof buf - i,
-					" size %#luX", ether->size);
-			i += snprint(buf+i, sizeof buf - i,
-				": %2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux",
-				ether->ea[0], ether->ea[1], ether->ea[2],
-				ether->ea[3], ether->ea[4], ether->ea[5]);
-			snprint(buf+i, sizeof buf - i, "\n");
-			iprint("%s", buf);  /* it may be too early for print */
-
-			if(ether->mbps >= 1000)
-				netifinit(ether, name, Ntypes, 4*1024*1024);
-			else if(ether->mbps >= 100)
-				netifinit(ether, name, Ntypes, 1024*1024);
-			else
-				netifinit(ether, name, Ntypes, 65*1024);
-			if(ether->oq == 0)
-				ether->oq = qopen(ether->limit, Qmsg, 0, 0);
-			if(ether->oq == 0)
-				panic("etherreset %s", name);
-			ether->alen = Eaddrlen;
-			memmove(ether->addr, ether->ea, Eaddrlen);
-			memset(ether->bcast, 0xFF, Eaddrlen);
-
-			etherxx[ctlrno] = ether;
-			ether = 0;
-			break;
-		}
-	}
-	if(ether)
-		free(ether);
-}
-
-static void
-ethershutdown(void)
-{
-	Ether *ether;
-	int i;
-
-	for(i = 0; i < MaxEther; i++){
-		ether = etherxx[i];
-		if(ether == nil)
-			continue;
-		if(ether->shutdown == nil) {
-			print("#l%d: no shutdown function\n", i);
-			continue;
-		}
-		(*ether->shutdown)(ether);
-	}
-}
-
-
-#define POLY 0xedb88320
-
-/* really slow 32 bit crc for ethers */
-ulong
-ethercrc(uchar *p, int len)
-{
-	int i, j;
-	ulong crc, b;
-
-	crc = 0xffffffff;
-	for(i = 0; i < len; i++){
-		b = *p++;
-		for(j = 0; j < 8; j++){
-			crc = (crc>>1) ^ (((crc^b) & 1) ? POLY : 0);
-			b >>= 1;
-		}
-	}
-	return crc;
-}
-
-void
-dumpoq(Queue *oq)
-{
-	if (oq == nil)
-		print("no outq! ");
-	else if (qisclosed(oq))
-		print("outq closed ");
-	else if (qfull(oq))
-		print("outq full ");
-	else
-		print("outq %d ", qlen(oq));
-}
-
-void
-dumpnetif(Netif *netif)
-{
-	print("netif %s ", netif->name);
-	print("limit %d mbps %d link %d ",
-		netif->limit, netif->mbps, netif->link);
-	print("inpkts %lld outpkts %lld errs %d\n",
-		netif->inpackets, netif->outpackets,
-		netif->crcs + netif->oerrs + netif->frames + netif->overflows +
-		netif->buffs + netif->soverflows);
-}
-
-Dev etherdevtab = {
-	'l',
-	"ether",
-
-	etherreset,
-	devinit,
-	ethershutdown,
-	etherattach,
-	etherwalk,
-	etherstat,
-	etheropen,
-	ethercreate,
-	etherclose,
-	etherread,
-	etherbread,
-	etherwrite,
-	etherbwrite,
-	devremove,
-	etherwstat,
-};
+#include "../omap/devether.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/etherif.h /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/etherif.h
--- ./9/bcm/etherif.h	2014-01-24 19:23:58.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/etherif.h	2012-10-31 03:33:22.000000000 -0700
@@ -1,41 +1 @@
-enum
-{
-	MaxEther	= 4,
-	Ntypes		= 8,
-};
-
-typedef struct Ether Ether;
-struct Ether {
-	RWlock;
-	ISAConf;			/* hardware info */
-
-	int	ctlrno;
-	int	minmtu;
-	int 	maxmtu;
-
-	Netif;
-
-	void	(*attach)(Ether*);	/* filled in by reset routine */
-	void	(*detach)(Ether*);
-	void	(*transmit)(Ether*);
-	void	(*interrupt)(Ureg*, void*);
-	long	(*ifstat)(Ether*, void*, long, ulong);
-	long 	(*ctl)(Ether*, void*, long); /* custom ctl messages */
-	void	(*power)(Ether*, int);	/* power on/off */
-	void	(*shutdown)(Ether*);	/* shutdown hardware before reboot */
-
-	void*	ctlr;
-	uchar	ea[Eaddrlen];
-	void*	address;
-	int	irq;
-
-	Queue*	oq;
-};
-
-extern Block* etheriq(Ether*, Block*, int);
-extern void addethercard(char*, int(*)(Ether*));
-extern ulong ethercrc(uchar*, int);
-extern int parseether(uchar*, char*);
-
-#define NEXT(x, l)	(((x)+1)%(l))
-#define PREV(x, l)	(((x) == 0) ? (l)-1: (x)-1)
+#include "../omap/etherif.h"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/init9.s /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/init9.s
--- ./9/bcm/init9.s	2014-01-24 19:22:35.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/init9.s	2012-10-19 03:57:06.000000000 -0700
@@ -1,25 +1 @@
-/*
- * This is the same as the C programme:
- *
- *	void
- *	main(char* argv0)
- *	{
- *		startboot(argv0, &argv0);
- *	}
- *
- * It is in assembler because SB needs to be
- * set and doing this in C drags in too many
- * other routines.
- */
-TEXT main(SB), 1, $8
-	MOVW	$setR12(SB), R12		/* load the SB */
-	MOVW	$boot(SB), R0
-
-	ADD	$12, R13, R1			/* pointer to 0(FP) */
-
-	MOVW	R0, 4(R13)			/* pass argc, argv */
-	MOVW	R1, 8(R13)
-
-	BL	startboot(SB)
-_loop:
-	B	_loop
+#include "../omap/init9.s"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/kbd.c /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/kbd.c
--- ./9/bcm/kbd.c	2014-01-24 19:26:04.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/kbd.c	2012-09-02 11:41:17.000000000 -0700
@@ -1,410 +1 @@
-/*
- * simulated keyboard input for systems with none (except via uart or usb)
- *
- * gutted version of ps2 version from ../pc
- */
-#include	"u.h"
-#include	"../port/lib.h"
-#include	"mem.h"
-#include	"dat.h"
-#include	"fns.h"
-#include	"io.h"
-#include	"../port/error.h"
-
-enum {
-	Spec=		0xF800,		/* Unicode private space */
-	PF=		Spec|0x20,	/* num pad function key */
-	View=		Spec|0x00,	/* view (shift window up) */
-	KF=		0xF000,		/* function key (begin Unicode private space) */
-	Shift=		Spec|0x60,
-	Break=		Spec|0x61,
-	Ctrl=		Spec|0x62,
-	Latin=		Spec|0x63,
-	Caps=		Spec|0x64,
-	Num=		Spec|0x65,
-	Middle=		Spec|0x66,
-	Altgr=		Spec|0x67,
-	Kmouse=		Spec|0x100,
-	No=		0x00,		/* peter */
-
-	Home=		KF|13,
-	Up=		KF|14,
-	Pgup=		KF|15,
-	Print=		KF|16,
-	Left=		KF|17,
-	Right=		KF|18,
-	End=		KF|24,
-	Down=		View,
-	Pgdown=		KF|19,
-	Ins=		KF|20,
-	Del=		0x7F,
-	Scroll=		KF|21,
-
-	Nscan=	128,
-
-	Int=	0,			/* kbscans indices */
-	Ext,
-	Nscans,
-};
-
-/*
- * The codes at 0x79 and 0x7b are produced by the PFU Happy Hacking keyboard.
- * A 'standard' keyboard doesn't produce anything above 0x58.
- */
-Rune kbtab[Nscan] = 
-{
-[0x00]	No,	0x1b,	'1',	'2',	'3',	'4',	'5',	'6',
-[0x08]	'7',	'8',	'9',	'0',	'-',	'=',	'\b',	'\t',
-[0x10]	'q',	'w',	'e',	'r',	't',	'y',	'u',	'i',
-[0x18]	'o',	'p',	'[',	']',	'\n',	Ctrl,	'a',	's',
-[0x20]	'd',	'f',	'g',	'h',	'j',	'k',	'l',	';',
-[0x28]	'\'',	'`',	Shift,	'\\',	'z',	'x',	'c',	'v',
-[0x30]	'b',	'n',	'm',	',',	'.',	'/',	Shift,	'*',
-[0x38]	Latin,	' ',	Ctrl,	KF|1,	KF|2,	KF|3,	KF|4,	KF|5,
-[0x40]	KF|6,	KF|7,	KF|8,	KF|9,	KF|10,	Num,	Scroll,	'7',
-[0x48]	'8',	'9',	'-',	'4',	'5',	'6',	'+',	'1',
-[0x50]	'2',	'3',	'0',	'.',	No,	No,	No,	KF|11,
-[0x58]	KF|12,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	View,	No,	Up,	No,	No,	No,	No,
-};
-
-Rune kbtabshift[Nscan] =
-{
-[0x00]	No,	0x1b,	'!',	'@',	'#',	'$',	'%',	'^',
-[0x08]	'&',	'*',	'(',	')',	'_',	'+',	'\b',	'\t',
-[0x10]	'Q',	'W',	'E',	'R',	'T',	'Y',	'U',	'I',
-[0x18]	'O',	'P',	'{',	'}',	'\n',	Ctrl,	'A',	'S',
-[0x20]	'D',	'F',	'G',	'H',	'J',	'K',	'L',	':',
-[0x28]	'"',	'~',	Shift,	'|',	'Z',	'X',	'C',	'V',
-[0x30]	'B',	'N',	'M',	'<',	'>',	'?',	Shift,	'*',
-[0x38]	Latin,	' ',	Ctrl,	KF|1,	KF|2,	KF|3,	KF|4,	KF|5,
-[0x40]	KF|6,	KF|7,	KF|8,	KF|9,	KF|10,	Num,	Scroll,	'7',
-[0x48]	'8',	'9',	'-',	'4',	'5',	'6',	'+',	'1',
-[0x50]	'2',	'3',	'0',	'.',	No,	No,	No,	KF|11,
-[0x58]	KF|12,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	Up,	No,	Up,	No,	No,	No,	No,
-};
-
-Rune kbtabesc1[Nscan] =
-{
-[0x00]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x08]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x10]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x18]	No,	No,	No,	No,	'\n',	Ctrl,	No,	No,
-[0x20]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x28]	No,	No,	Shift,	No,	No,	No,	No,	No,
-[0x30]	No,	No,	No,	No,	No,	'/',	No,	Print,
-[0x38]	Altgr,	No,	No,	No,	No,	No,	No,	No,
-[0x40]	No,	No,	No,	No,	No,	No,	Break,	Home,
-[0x48]	Up,	Pgup,	No,	Left,	No,	Right,	No,	End,
-[0x50]	Down,	Pgdown,	Ins,	Del,	No,	No,	No,	No,
-[0x58]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	Up,	No,	No,	No,	No,	No,	No,
-};
-
-Rune kbtabaltgr[Nscan] =
-{
-[0x00]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x08]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x10]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x18]	No,	No,	No,	No,	'\n',	Ctrl,	No,	No,
-[0x20]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x28]	No,	No,	Shift,	No,	No,	No,	No,	No,
-[0x30]	No,	No,	No,	No,	No,	'/',	No,	Print,
-[0x38]	Altgr,	No,	No,	No,	No,	No,	No,	No,
-[0x40]	No,	No,	No,	No,	No,	No,	Break,	Home,
-[0x48]	Up,	Pgup,	No,	Left,	No,	Right,	No,	End,
-[0x50]	Down,	Pgdown,	Ins,	Del,	No,	No,	No,	No,
-[0x58]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	Up,	No,	No,	No,	No,	No,	No,
-};
-
-Rune kbtabctrl[Nscan] =
-{
-[0x00]	No,	'', 	'', 	'', 	'', 	'', 	'', 	'', 
-[0x08]	'', 	'', 	'', 	'', 	'', 	'', 	'\b',	'\t',
-[0x10]	'', 	'', 	'', 	'', 	'', 	'', 	'', 	'\t',
-[0x18]	'', 	'', 	'', 	'', 	'\n',	Ctrl,	'', 	'', 
-[0x20]	'', 	'', 	'', 	'\b',	'\n',	'', 	'', 	'', 
-[0x28]	'', 	No, 	Shift,	'', 	'', 	'', 	'', 	'', 
-[0x30]	'', 	'', 	'', 	'', 	'', 	'', 	Shift,	'\n',
-[0x38]	Latin,	No, 	Ctrl,	'', 	'', 	'', 	'', 	'', 
-[0x40]	'', 	'', 	'', 	'', 	'', 	'', 	'', 	'', 
-[0x48]	'', 	'', 	'', 	'', 	'', 	'', 	'', 	'', 
-[0x50]	'', 	'', 	'', 	'', 	No,	No,	No,	'', 
-[0x58]	'', 	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	'', 	No,	'\b',	No,	No,	No,	No,
-};
-
-int mouseshifted;
-void (*kbdmouse)(int);
-
-static int kdebug;
-
-typedef struct Kbscan Kbscan;
-struct Kbscan {
-	int	esc1;
-	int	esc2;
-	int	alt;
-	int	altgr;
-	int	caps;
-	int	ctl;
-	int	num;
-	int	shift;
-	int	collecting;
-	int	nk;
-	Rune	kc[5];
-	int	buttons;
-};
-
-Kbscan kbscans[Nscans];	/* kernel and external scan code state */
-
-/*
- * Scan code processing
- */
-void
-kbdputsc(int c, int external)
-{
-	int i, keyup;
-	Kbscan *kbscan;
-
-	if(external)
-		kbscan = &kbscans[Ext];
-	else
-		kbscan = &kbscans[Int];
-
-	if(kdebug)
-		print("sc %x ms %d\n", c, mouseshifted);
-	/*
-	 *  e0's is the first of a 2 character sequence, e1 the first
-	 *  of a 3 character sequence (on the safari)
-	 */
-	if(c == 0xe0){
-		kbscan->esc1 = 1;
-		return;
-	} else if(c == 0xe1){
-		kbscan->esc2 = 2;
-		return;
-	}
-
-	keyup = c & 0x80;
-	c &= 0x7f;
-	if(c > sizeof kbtab){
-		c |= keyup;
-		if(c != 0xFF)	/* these come fairly often: CAPSLOCK U Y */
-			print("unknown key %ux\n", c);
-		return;
-	}
-
-	if(kbscan->esc1){
-		c = kbtabesc1[c];
-		kbscan->esc1 = 0;
-	} else if(kbscan->esc2){
-		kbscan->esc2--;
-		return;
-	} else if(kbscan->shift)
-		c = kbtabshift[c];
-	else if(kbscan->altgr)
-		c = kbtabaltgr[c];
-	else if(kbscan->ctl)
-		c = kbtabctrl[c];
-	else
-		c = kbtab[c];
-
-	if(kbscan->caps && c<='z' && c>='a')
-		c += 'A' - 'a';
-
-	/*
-	 *  keyup only important for shifts
-	 */
-	if(keyup){
-		switch(c){
-		case Latin:
-			kbscan->alt = 0;
-			break;
-		case Shift:
-			kbscan->shift = 0;
-			mouseshifted = 0;
-			if(kdebug)
-				print("shiftclr\n");
-			break;
-		case Ctrl:
-			kbscan->ctl = 0;
-			break;
-		case Altgr:
-			kbscan->altgr = 0;
-			break;
-		case Kmouse|1:
-		case Kmouse|2:
-		case Kmouse|3:
-		case Kmouse|4:
-		case Kmouse|5:
-			kbscan->buttons &= ~(1<<(c-Kmouse-1));
-			if(kbdmouse)
-				kbdmouse(kbscan->buttons);
-			break;
-		}
-		return;
-	}
-
-	/*
-	 *  normal character
-	 */
-	if(!(c & (Spec|KF))){
-		if(kbscan->ctl)
-			if(kbscan->alt && c == Del)
-				exit(0);
-		if(!kbscan->collecting){
-			kbdputc(kbdq, c);
-			return;
-		}
-		kbscan->kc[kbscan->nk++] = c;
-		c = latin1(kbscan->kc, kbscan->nk);
-		if(c < -1)	/* need more keystrokes */
-			return;
-		if(c != -1)	/* valid sequence */
-			kbdputc(kbdq, c);
-		else	/* dump characters */
-			for(i=0; i<kbscan->nk; i++)
-				kbdputc(kbdq, kbscan->kc[i]);
-		kbscan->nk = 0;
-		kbscan->collecting = 0;
-		return;
-	} else {
-		switch(c){
-		case Caps:
-			kbscan->caps ^= 1;
-			return;
-		case Num:
-			kbscan->num ^= 1;
-			return;
-		case Shift:
-			kbscan->shift = 1;
-			if(kdebug)
-				print("shift\n");
-			mouseshifted = 1;
-			return;
-		case Latin:
-			kbscan->alt = 1;
-			/*
-			 * VMware and Qemu use Ctl-Alt as the key combination
-			 * to make the VM give up keyboard and mouse focus.
-			 * This has the unfortunate side effect that when you
-			 * come back into focus, Plan 9 thinks you want to type
-			 * a compose sequence (you just typed alt). 
-			 *
-			 * As a clumsy hack around this, we look for ctl-alt
-			 * and don't treat it as the start of a compose sequence.
-			 */
-			if(!kbscan->ctl){
-				kbscan->collecting = 1;
-				kbscan->nk = 0;
-			}
-			return;
-		case Ctrl:
-			kbscan->ctl = 1;
-			return;
-		case Altgr:
-			kbscan->altgr = 1;
-			return;
-		case Kmouse|1:
-		case Kmouse|2:
-		case Kmouse|3:
-		case Kmouse|4:
-		case Kmouse|5:
-			kbscan->buttons |= 1<<(c-Kmouse-1);
-			if(kbdmouse)
-				kbdmouse(kbscan->buttons);
-			return;
-		case KF|11:
-			print("kbd debug on, F12 turns it off\n");
-			kdebug = 1;
-			break;
-		case KF|12:
-			kdebug = 0;
-			break;
-		}
-	}
-	kbdputc(kbdq, c);
-}
-
-void
-kbdenable(void)
-{
-#ifdef notdef
-	kbdq = qopen(4*1024, 0, 0, 0);
-	if(kbdq == nil)
-		panic("kbdinit");
-	qnoblock(kbdq, 1);
-#endif
-	kbscans[Int].num = 0;
-}
-
-void
-kbdputmap(ushort m, ushort scanc, Rune r)
-{
-	if(scanc >= Nscan)
-		error(Ebadarg);
-	switch(m) {
-	default:
-		error(Ebadarg);
-	case 0:
-		kbtab[scanc] = r;
-		break;
-	case 1:
-		kbtabshift[scanc] = r;
-		break;
-	case 2:
-		kbtabesc1[scanc] = r;
-		break;
-	case 3:
-		kbtabaltgr[scanc] = r;
-		break;
-	case 4:	
-		kbtabctrl[scanc] = r;
-		break;
-	}
-}
-
-int
-kbdgetmap(uint offset, int *t, int *sc, Rune *r)
-{
-	if ((int)offset < 0)
-		error(Ebadarg);
-	*t = offset/Nscan;
-	*sc = offset%Nscan;
-	switch(*t) {
-	default:
-		return 0;
-	case 0:
-		*r = kbtab[*sc];
-		return 1;
-	case 1:
-		*r = kbtabshift[*sc];
-		return 1;
-	case 2:
-		*r = kbtabesc1[*sc];
-		return 1;
-	case 3:
-		*r = kbtabaltgr[*sc];
-		return 1;
-	case 4:
-		*r = kbtabctrl[*sc];
-		return 1;
-	}
-}
+#include "../omap/kbd.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/lproc.s /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/lproc.s
--- ./9/bcm/lproc.s	2014-01-24 19:17:23.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/lproc.s	2012-10-18 11:00:54.000000000 -0700
@@ -1,47 +1 @@
-#include "mem.h"
-#include "arm.h"
-
-/*
- *  This is the first jump from kernel to user mode.
- *  Fake a return from interrupt.
- *
- *  Enter with R0 containing the user stack pointer.
- *  UTZERO + 0x20 is always the entry point.
- *
- */
-TEXT touser(SB), 1, $-4
-	/* store the user stack pointer into the USR_r13 */
-	MOVM.DB.W [R0], (R13)
-	/* avoid the ambiguity described in notes/movm.w. */
-//	MOVM.S.IA.W (R13), [R13]
-	MOVM.S	(R13), [R13]
-	ADD	$4, R13
-
-	/* set up a PSR for user level */
-	MOVW	$(PsrMusr), R0
-	MOVW	R0, SPSR
-
-	/* save the PC on the stack */
-	MOVW	$(UTZERO+0x20), R0
-	MOVM.DB.W [R0], (R13)
-
-	/*
-	 * note that 5a's RFE is not the v6 arch. instruction (0xe89d0a00,
-	 * I think), which loads CPSR from the word after the PC at (R13),
-	 * but rather the pre-v6 simulation `MOVM.IA.S.W (R13), [R15]'
-	 * (0xe8fd8000 since MOVM is LDM in this case), which loads CPSR
-	 * not from memory but from SPSR due to `.S'.
-	 */
-	RFE
-
-/*
- *  here to jump to a newly forked process
- */
-TEXT forkret(SB), 1, $-4
-	ADD	$(4*15), R13		/* make r13 point to ureg->type */
-	MOVW	8(R13), R14		/* restore link */
-	MOVW	4(R13), R0		/* restore SPSR */
-	MOVW	R0, SPSR		/* ... */
-	MOVM.DB.S (R13), [R0-R14]	/* restore registers */
-	ADD	$8, R13			/* pop past ureg->{type+psr} */
-	RFE				/* MOVM.IA.S.W (R13), [R15] */
+#include "../omap/lproc.s"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/mkfile /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/mkfile
--- ./9/bcm/mkfile	2014-01-24 19:27:03.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/mkfile	2013-03-25 20:38:21.000000000 -0700
@@ -1,9 +1,5 @@
-MKSHELL=$PLAN9/bin/rc
-
 CONF=pi
-CONFLIST=pi
-# picpu pifat
-
+CONFLIST=pi picpu pifat
 EXTRACOPIES=
 
 loadaddr=0x80008000
@@ -118,7 +114,7 @@ devusb.$O: ../port/usb.h
 usbehci.$O usbohci.$O usbuhci.$O: ../port/usb.h usbehci.h uncached.h
 
 init.h:D:	../port/initcode.c init9.s
-	$CC $CFLAGS ../port/initcode.c
+	$CC ../port/initcode.c
 	$AS init9.s
 	$LD -l -R1 -s -o init.out init9.$O initcode.$O /$objtype/lib/libc.a
 	{echo 'uchar initcode[]={'
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/mouse.c /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/mouse.c
--- ./9/bcm/mouse.c	2014-01-24 19:26:13.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/mouse.c	2012-09-02 11:24:10.000000000 -0700
@@ -1,255 +1 @@
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "../port/error.h"
-#include "io.h"
-
-#define	Image	IMAGE
-#include <draw.h>
-#include <memdraw.h>
-#include <cursor.h>
-#include "screen.h"
-
-/*
- *  mouse types
- */
-enum
-{
-	Mouseother=	0,
-	Mouseserial=	1,
-	MousePS2=	2,
-};
-
-extern int mouseshifted;
-
-static QLock mousectlqlock;
-static int mousetype;
-static int intellimouse;
-static int packetsize;
-static int resolution;
-static int accelerated;
-static int mousehwaccel;
-static char mouseport[5];
-
-enum
-{
-	CMaccelerated,
-	CMhwaccel,
-	CMintellimouse,
-	CMlinear,
-	CMps2,
-	CMps2intellimouse,
-	CMres,
-	CMreset,
-	CMserial,
-};
-
-static Cmdtab mousectlmsg[] =
-{
-	CMaccelerated,		"accelerated",		0,
-	CMhwaccel,		"hwaccel",		2,
-	CMintellimouse,		"intellimouse",		1,
-	CMlinear,		"linear",		1,
-	CMps2,			"ps2",			1,
-	CMps2intellimouse,	"ps2intellimouse",	1,
-	CMres,			"res",			0,
-	CMreset,		"reset",		1,
-	CMserial,		"serial",		0,
-};
-
-/*
- *  ps/2 mouse message is three bytes
- *
- *	byte 0 -	0 0 SDY SDX 1 M R L
- *	byte 1 -	DX
- *	byte 2 -	DY
- *
- *  shift & right button is the same as middle button
- *
- * Intellimouse and AccuPoint with extra buttons deliver
- *	byte 3 -	00 or 01 or FF according to extra button state.
- * extra buttons are mapped in this code to buttons 4 and 5.
- * AccuPoint generates repeated events for these buttons;
-*  it and Intellimouse generate 'down' events only, so
- * user-level code is required to generate button 'up' events
- * if they are needed by the application.
- * Also on laptops with AccuPoint AND external mouse, the
- * controller may deliver 3 or 4 bytes according to the type
- * of the external mouse; code must adapt.
- *
- * On the NEC Versa series (and perhaps others?) we seem to
- * lose a byte from the packet every once in a while, which
- * means we lose where we are in the instruction stream.
- * To resynchronize, if we get a byte more than two seconds
- * after the previous byte, we assume it's the first in a packet.
- */
-static void
-ps2mouseputc(int c, int shift)
-{
-	static short msg[4];
-	static int nb;
-	static uchar b[] = {0, 1, 4, 5, 2, 3, 6, 7, 0, 1, 2, 3, 2, 3, 6, 7 };
-	static ulong lasttick;
-	ulong m;
-	int buttons, dx, dy;
-
-	shift |= mouseshifted;
-	m = MACHP(0)->ticks;
-	if(TK2SEC(m - lasttick) > 2)
-		nb = 0;
-	lasttick = m;
-	if(nb==0 && (c&0xc8)!=0x08)
-		if(intellimouse && (c==0x00 || c==0x01 || c==0xFF)){
-			packetsize = 4;
-			return;
-		}
-
-	msg[nb] = c;
-	if(++nb == packetsize){
-		nb = 0;
-		if(msg[0] & 0x10)
-			msg[1] |= 0xFF00;
-		if(msg[0] & 0x20)
-			msg[2] |= 0xFF00;
-
-		buttons = b[(msg[0]&7) | (shift ? 8 : 0)];
-		if(intellimouse && packetsize==4){
-			if((msg[3]&0xc8) == 0x08){
-				packetsize = 3;
-				msg[0] = msg[3];
-				nb = 1;
-			}else{
-				if((msg[3] >> 3) & 1)
-					buttons |= 1<<3;
-				else if(msg[3] & 0x7)
-					buttons |= 1<<4;
-			}
-		}
-		dx = msg[1];
-		dy = -msg[2];
-		mousetrack(dx, dy, buttons, TK2MS(MACHP(0)->ticks));
-	}
-}
-
-/*
- *  set up a ps2 mouse
- */
-static void
-ps2mouse(void)
-{
-	if(mousetype == MousePS2)
-		return;
-
-//	i8042auxenable(ps2mouseputc);
-//	i8042auxcmd(0xEA);	// TODO
-//	i8042auxcmd(0xF4);
-
-	mousetype = MousePS2;
-	packetsize = 3;
-	mousehwaccel = 1;
-}
-
-/*
- * The PS/2 Trackpoint multiplexor on the IBM Thinkpad T23 ignores
- * acceleration commands.  It is supposed to pass them on
- * to the attached device, but my Logitech mouse is simply
- * not behaving any differently.  For such devices, we allow
- * the user to use "hwaccel off" to tell us to back off to
- * software acceleration even if we're using the PS/2 port.
- * (Serial mice are always software accelerated.)
- * For more information on the Thinkpad multiplexor, see
- * http://wwwcssrv.almaden.ibm.com/trackpoint/
- */
-static void
-setaccelerated(int x)
-{
-	accelerated = x;
-	mouseaccelerate(x);
-}
-
-static void
-setlinear(void)
-{
-	accelerated = 0;
-	mouseaccelerate(0);
-}
-
-static void
-setres(int n)
-{
-	resolution = n;
-}
-
-static void
-setintellimouse(void)
-{
-	intellimouse = 1;
-	packetsize = 4;
-}
-
-static void
-resetmouse(void)
-{
-	packetsize = 3;
-}
-
-void
-mousectl(Cmdbuf *cb)
-{
-	Cmdtab *ct;
-
-	qlock(&mousectlqlock);
-	if(waserror()){
-		qunlock(&mousectlqlock);
-		nexterror();
-	}
-
-	ct = lookupcmd(cb, mousectlmsg, nelem(mousectlmsg));
-	switch(ct->index){
-	case CMaccelerated:
-		setaccelerated(cb->nf == 1? 1: atoi(cb->f[1]));
-		break;
-	case CMintellimouse:
-		setintellimouse();
-		break;
-	case CMlinear:
-		setlinear();
-		break;
-	case CMps2:
-		intellimouse = 0;
-		break;
-	case CMps2intellimouse:
-		setintellimouse();
-		break;
-	case CMres:
-		if(cb->nf >= 2)
-			setres(atoi(cb->f[1]));
-		else
-			setres(1);
-		break;
-	case CMreset:
-		resetmouse();
-		if(accelerated)
-			setaccelerated(accelerated);
-		if(resolution)
-			setres(resolution);
-		if(intellimouse)
-			setintellimouse();
-		break;
-	case CMserial:
-		error("serial mice not supported");
-		break;
-	case CMhwaccel:
-		if(strcmp(cb->f[1], "on")==0)
-			mousehwaccel = 1;
-		else if(strcmp(cb->f[1], "off")==0)
-			mousehwaccel = 0;
-		else
-			cmderror(cb, "bad mouse control message");
-	}
-
-	qunlock(&mousectlqlock);
-	poperror();
-}
+#include "../omap/mouse.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/pi /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/pi
--- ./9/bcm/pi	2014-01-24 19:25:27.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/pi	2013-01-25 14:10:17.000000000 -0800
@@ -8,8 +8,8 @@ dev
 	srv
 	dup
 	arch
-#	ssl
-#	tls
+	ssl
+	tls
 	cap
 	fs
 	ip		arp chandial ip ipv6 ipaux iproute netlog nullmedium pktmedium ptclbsum inferno
@@ -21,15 +21,15 @@ dev
 
 	fakertc
 	sd
-#	usb
+	usb
 	ether	netif
 
 link
 	archbcm
 	loopbackmedium
 	ethermedium
-#	usbdwc
-#	etherusb
+	usbdwc
+	etherusb
 
 ip
 	tcp
@@ -37,7 +37,7 @@ ip
 	ipifc
 	icmp
 	icmp6
-#	ipmux
+	ipmux
 
 misc
 	uartmini
@@ -51,11 +51,11 @@ port
 
 boot boot #S/sdM0/
 	local
-#	tcp
+	tcp
 
 bootdir
 	boot$CONF.out	boot
-#	/arm/bin/ip/ipconfig
-#	/arm/bin/auth/factotum
-#	/arm/bin/fossil/fossil
-#	/arm/bin/usb/usbd
+	/arm/bin/ip/ipconfig
+	/arm/bin/auth/factotum
+	/arm/bin/fossil/fossil
+	/arm/bin/usb/usbd
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/syscall.c /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/syscall.c
--- ./9/bcm/syscall.c	2014-01-24 19:23:30.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/syscall.c	2012-11-07 09:10:58.000000000 -0800
@@ -1,356 +1 @@
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "../port/error.h"
-#include "../port/systab.h"
-
-#include <tos.h>
-#include "ureg.h"
-
-#include "arm.h"
-
-typedef struct {
-	uintptr	ip;
-	Ureg*	arg0;
-	char*	arg1;
-	char	msg[ERRMAX];
-	Ureg*	old;
-	Ureg	ureg;
-} NFrame;
-
-/*
- *   Return user to state before notify()
- */
-static void
-noted(Ureg* cur, uintptr arg0)
-{
-	NFrame *nf;
-	Ureg *nur;
-
-	qlock(&up->debug);
-	if(arg0 != NRSTR && !up->notified){
-		qunlock(&up->debug);
-		pprint("call to noted() when not notified\n");
-		pexit("Suicide", 0);
-	}
-	up->notified = 0;
-	fpunoted();
-
-	nf = up->ureg;
-
-	/* sanity clause */
-	if(!okaddr(PTR2UINT(nf), sizeof(NFrame), 0)){
-		qunlock(&up->debug);
-		pprint("bad ureg in noted %#p\n", nf);
-		pexit("Suicide", 0);
-	}
-
-	/* don't let user change system flags */
-	nur = &nf->ureg;
-	nur->psr &= PsrMask|PsrDfiq|PsrDirq;
-	nur->psr |= (cur->psr & ~(PsrMask|PsrDfiq|PsrDirq));
-
-	memmove(cur, nur, sizeof(Ureg));
-
-	switch((int)arg0){
-	case NCONT:
-	case NRSTR:
-		if(!okaddr(nur->pc, BY2WD, 0) || !okaddr(nur->sp, BY2WD, 0)){
-			qunlock(&up->debug);
-			pprint("suicide: trap in noted\n");
-			pexit("Suicide", 0);
-		}
-		up->ureg = nf->old;
-		qunlock(&up->debug);
-		break;
-	case NSAVE:
-		if(!okaddr(nur->pc, BY2WD, 0) || !okaddr(nur->sp, BY2WD, 0)){
-			qunlock(&up->debug);
-			pprint("suicide: trap in noted\n");
-			pexit("Suicide", 0);
-		}
-		qunlock(&up->debug);
-
-		splhi();
-		nf->arg1 = nf->msg;
-		nf->arg0 = &nf->ureg;
-		nf->ip = 0;
-		cur->sp = PTR2UINT(nf);
-		cur->r0 = PTR2UINT(nf->arg0);
-		break;
-	default:
-		pprint("unknown noted arg %#p\n", arg0);
-		up->lastnote.flag = NDebug;
-		/*FALLTHROUGH*/
-	case NDFLT:
-		if(up->lastnote.flag == NDebug){ 
-			qunlock(&up->debug);
-			pprint("suicide: %s\n", up->lastnote.msg);
-		}
-		else
-			qunlock(&up->debug);
-		pexit(up->lastnote.msg, up->lastnote.flag != NDebug);
-	}
-}
-
-/*
- *  Call user, if necessary, with note.
- *  Pass user the Ureg struct and the note on his stack.
- */
-int
-notify(Ureg* ureg)
-{
-	int l;
-	Note *n;
-	u32int s;
-	uintptr sp;
-	NFrame *nf;
-
-	if(up->procctl)
-		procctl(up);
-	if(up->nnote == 0)
-		return 0;
-
-	fpunotify(ureg);
-
-	s = spllo();
-	qlock(&up->debug);
-
-	up->notepending = 0;
-	n = &up->note[0];
-	if(strncmp(n->msg, "sys:", 4) == 0){
-		l = strlen(n->msg);
-		if(l > ERRMAX-23)	/* " pc=0x0123456789abcdef\0" */
-			l = ERRMAX-23;
-		snprint(n->msg + l, sizeof n->msg - l, " pc=%#lux", ureg->pc);
-	}
-
-	if(n->flag != NUser && (up->notified || up->notify == 0)){
-		if(n->flag == NDebug)
-			pprint("suicide: %s\n", n->msg);
-		qunlock(&up->debug);
-		pexit(n->msg, n->flag != NDebug);
-	}
-
-	if(up->notified){
-		qunlock(&up->debug);
-		splhi();
-		return 0;
-	}
-		
-	if(up->notify == nil){
-		qunlock(&up->debug);
-		pexit(n->msg, n->flag != NDebug);
-	}
-	if(!okaddr(PTR2UINT(up->notify), 1, 0)){
-		pprint("suicide: notify function address %#p\n", up->notify);
-		qunlock(&up->debug);
-		pexit("Suicide", 0);
-	}
-
-	sp = ureg->sp - sizeof(NFrame);
-	if(!okaddr(sp, sizeof(NFrame), 1)){
-		qunlock(&up->debug);
-		pprint("suicide: notify stack address %#p\n", sp);
-		pexit("Suicide", 0);
-	}
-
-	nf = UINT2PTR(sp);
-	memmove(&nf->ureg, ureg, sizeof(Ureg));
-	nf->old = up->ureg;
-	up->ureg = nf;
-	memmove(nf->msg, up->note[0].msg, ERRMAX);
-	nf->arg1 = nf->msg;
-	nf->arg0 = &nf->ureg;
-	ureg->r0 = PTR2UINT(nf->arg0);
-	nf->ip = 0;
-
-	ureg->sp = sp;
-	ureg->pc = PTR2UINT(up->notify);
-	up->notified = 1;
-	up->nnote--;
-	memmove(&up->lastnote, &up->note[0], sizeof(Note));
-	memmove(&up->note[0], &up->note[1], up->nnote*sizeof(Note));
-
-	qunlock(&up->debug);
-	splx(s);
-
-	return 1;
-}
-
-void
-syscall(Ureg* ureg)
-{
-	char *e;
-	u32int s;
-	ulong sp;
-	long ret;
-	int i, scallnr;
-	vlong startns, stopns;
-
-	if(!userureg(ureg))
-		panic("syscall: from kernel: pc %#lux r14 %#lux psr %#lux",
-			ureg->pc, ureg->r14, ureg->psr);
-
-	cycles(&up->kentry);
-
-	m->syscall++;
-	up->insyscall = 1;
-	up->pc = ureg->pc;
-	up->dbgreg = ureg;
-
-	scallnr = ureg->r0;
-	up->scallnr = scallnr;
-	if(scallnr == RFORK)
-		fpusysrfork(ureg);
-	spllo();
-	sp = ureg->sp;
-
-	if(up->procctl == Proc_tracesyscall){
-		/*
-		 * Redundant validaddr.  Do we care?
-		 * Tracing syscalls is not exactly a fast path...
-		 * Beware, validaddr currently does a pexit rather
-		 * than an error if there's a problem; that might
-		 * change in the future.
-		 */
-		if(sp < (USTKTOP-BY2PG) || sp > (USTKTOP-sizeof(Sargs)-BY2WD))
-			validaddr(sp, sizeof(Sargs)+BY2WD, 0);
-
-		syscallfmt(scallnr, ureg->pc, (va_list)(sp+BY2WD));
-		up->procctl = Proc_stopme;
-		procctl(up);
-		if (up->syscalltrace) 
-			free(up->syscalltrace);
-		up->syscalltrace = nil;
-	}
-
-	up->nerrlab = 0;
-	ret = -1;
-	startns = todget(nil);
-	if(!waserror()){
-		if(scallnr >= nsyscall){
-			pprint("bad sys call number %d pc %#lux\n",
-				scallnr, ureg->pc);
-			postnote(up, 1, "sys: bad sys call", NDebug);
-			error(Ebadarg);
-		}
-
-		if(sp < (USTKTOP-BY2PG) || sp > (USTKTOP-sizeof(Sargs)-BY2WD))
-			validaddr(sp, sizeof(Sargs)+BY2WD, 0);
-
-		up->s = *((Sargs*)(sp+BY2WD));
-		up->psstate = sysctab[scallnr];
-
-	/*	iprint("%s: syscall %s\n", up->text, sysctab[scallnr]?sysctab[scallnr]:"huh?"); */
-
-		ret = systab[scallnr](up->s.args);
-		poperror();
-	}else{
-		/* failure: save the error buffer for errstr */
-		e = up->syserrstr;
-		up->syserrstr = up->errstr;
-		up->errstr = e;
-	}
-	if(up->nerrlab){
-		print("bad errstack [%d]: %d extra\n", scallnr, up->nerrlab);
-		for(i = 0; i < NERR; i++)
-			print("sp=%#p pc=%#p\n",
-				up->errlab[i].sp, up->errlab[i].pc);
-		panic("error stack");
-	}
-
-	/*
-	 *  Put return value in frame.  On the x86 the syscall is
-	 *  just another trap and the return value from syscall is
-	 *  ignored.  On other machines the return value is put into
-	 *  the results register by caller of syscall.
-	 */
-	ureg->r0 = ret;
-
-	if(up->procctl == Proc_tracesyscall){
-		stopns = todget(nil);
-		up->procctl = Proc_stopme;
-		sysretfmt(scallnr, (va_list)(sp+BY2WD), ret, startns, stopns);
-		s = splhi();
-		procctl(up);
-		splx(s);
-		if(up->syscalltrace)
-			free(up->syscalltrace);
-		up->syscalltrace = nil;
-	}
-
-	up->insyscall = 0;
-	up->psstate = 0;
-
-	if(scallnr == NOTED)
-		noted(ureg, *(ulong*)(sp+BY2WD));
-
-	splhi();
-	if(scallnr != RFORK && (up->procctl || up->nnote))
-		notify(ureg);
-
-	/* if we delayed sched because we held a lock, sched now */
-	if(up->delaysched){
-		sched();
-		splhi();
-	}
-	kexit(ureg);
-}
-
-long
-execregs(ulong entry, ulong ssize, ulong nargs)
-{
-	ulong *sp;
-	Ureg *ureg;
-
-	sp = (ulong*)(USTKTOP - ssize);
-	*--sp = nargs;
-
-	ureg = up->dbgreg;
-//	memset(ureg, 0, 15*sizeof(ulong));
-	ureg->r13 = (ulong)sp;
-	ureg->pc = entry;
-//print("%lud: EXECREGS pc %#ux sp %#ux nargs %ld\n", up->pid, ureg->pc, ureg->r13, nargs);
-
-	/*
-	 * return the address of kernel/user shared data
-	 * (e.g. clock stuff)
-	 */
-	return USTKTOP-sizeof(Tos);
-}
-
-void
-sysprocsetup(Proc* p)
-{
-	fpusysprocsetup(p);
-}
-
-/* 
- *  Craft a return frame which will cause the child to pop out of
- *  the scheduler in user mode with the return register zero.  Set
- *  pc to point to a l.s return function.
- */
-void
-forkchild(Proc *p, Ureg *ureg)
-{
-	Ureg *cureg;
-
-//print("%lud setting up for forking child %lud\n", up->pid, p->pid);
-	p->sched.sp = (ulong)p->kstack+KSTACK-sizeof(Ureg);
-	p->sched.pc = (ulong)forkret;
-
-	cureg = (Ureg*)(p->sched.sp);
-	memmove(cureg, ureg, sizeof(Ureg));
-
-	/* syscall returns 0 for child */
-	cureg->r0 = 0;
-
-	/* Things from bottom of syscall which were never executed */
-	p->psstate = 0;
-	p->insyscall = 0;
-
-	fpusysrforkchild(p, cureg, up);
-}
+#include "../kw/syscall.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/bcm/vfp3.c /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/vfp3.c
--- ./9/bcm/vfp3.c	2014-01-24 19:25:47.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/bcm/vfp3.c	2013-01-29 14:06:54.000000000 -0800
@@ -1,516 +1 @@
-/*
- * VFPv2 or VFPv3 floating point unit
- */
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "ureg.h"
-#include "arm.h"
-
-/* subarchitecture code in m->havefp */
-enum {
-	VFPv2	= 2,
-	VFPv3	= 3,
-};
-
-/* fp control regs.  most are read-only */
-enum {
-	Fpsid =	0,
-	Fpscr =	1,			/* rw */
-	Mvfr1 =	6,
-	Mvfr0 =	7,
-	Fpexc =	8,			/* rw */
-	Fpinst= 9,			/* optional, for exceptions */
-	Fpinst2=10,
-};
-enum {
-	/* Fpexc bits */
-	Fpex =		1u << 31,
-	Fpenabled =	1 << 30,
-	Fpdex =		1 << 29,	/* defined synch exception */
-//	Fp2v =		1 << 28,	/* Fpinst2 reg is valid */
-//	Fpvv =		1 << 27,	/* if Fpdex, vecitr is valid */
-//	Fptfv = 	1 << 26,	/* trapped fault is valid */
-//	Fpvecitr =	MASK(3) << 8,
-	/* FSR bits appear here */
-	Fpmbc =		Fpdex,		/* bits exception handler must clear */
-
-	/* Fpscr bits; see u.h for more */
-	Stride =	MASK(2) << 20,
-	Len =		MASK(3) << 16,
-	Dn=		1 << 25,
-	Fz=		1 << 24,
-	/* trap exception enables (not allowed in vfp3) */
-	FPIDNRM =	1 << 15,	/* input denormal */
-	Alltraps = FPIDNRM | FPINEX | FPUNFL | FPOVFL | FPZDIV | FPINVAL,
-	/* pending exceptions */
-	FPAIDNRM =	1 << 7,		/* input denormal */
-	Allexc = FPAIDNRM | FPAINEX | FPAUNFL | FPAOVFL | FPAZDIV | FPAINVAL,
-	/* condition codes */
-	Allcc =		MASK(4) << 28,
-};
-enum {
-	/* CpCPaccess bits */
-	Cpaccnosimd =	1u << 31,
-	Cpaccd16 =	1 << 30,
-};
-
-static char *
-subarch(int impl, uint sa)
-{
-	static char *armarchs[] = {
-		"VFPv1 (unsupported)",
-		"VFPv2",
-		"VFPv3+ with common VFP subarch v2",
-		"VFPv3+ with null subarch",
-		"VFPv3+ with common VFP subarch v3",
-	};
-
-	if (impl != 'A' || sa >= nelem(armarchs))
-		return "GOK";
-	else
-		return armarchs[sa];
-}
-
-static char *
-implement(uchar impl)
-{
-	if (impl == 'A')
-		return "arm";
-	else
-		return "unknown";
-}
-
-static int
-havefp(void)
-{
-	int gotfp;
-	ulong acc, sid;
-
-	if (m->havefpvalid)
-		return m->havefp;
-
-	m->havefp = 0;
-	gotfp = 1 << CpFP | 1 << CpDFP;
-	cpwrsc(0, CpCONTROL, 0, CpCPaccess, MASK(28));
-	acc = cprdsc(0, CpCONTROL, 0, CpCPaccess);
-	if ((acc & (MASK(2) << (2*CpFP))) == 0) {
-		gotfp &= ~(1 << CpFP);
-		print("fpon: no single FP coprocessor\n");
-	}
-	if ((acc & (MASK(2) << (2*CpDFP))) == 0) {
-		gotfp &= ~(1 << CpDFP);
-		print("fpon: no double FP coprocessor\n");
-	}
-	if (!gotfp) {
-		print("fpon: no FP coprocessors\n");
-		m->havefpvalid = 1;
-		return 0;
-	}
-	m->fpon = 1;			/* don't panic */
-	sid = fprd(Fpsid);
-	m->fpon = 0;
-	switch((sid >> 16) & MASK(7)){
-	case 0:				/* VFPv1 */
-		break;
-	case 1:				/* VFPv2 */
-		m->havefp = VFPv2;
-		m->fpnregs = 16;
-		break;
-	default:			/* VFPv3 or later */
-		m->havefp = VFPv3;
-		m->fpnregs = (acc & Cpaccd16) ? 16 : 32;
-		break;
-	}
-	if (m->machno == 0)
-		print("fp: %d registers, %s simd\n", m->fpnregs,
-			(acc & Cpaccnosimd? " no": ""));
-	m->havefpvalid = 1;
-	return 1;
-}
-
-/*
- * these can be called to turn the fpu on or off for user procs,
- * not just at system start up or shutdown.
- */
-
-void
-fpoff(void)
-{
-	if (m->fpon) {
-		fpwr(Fpexc, 0);
-		m->fpon = 0;
-	}
-}
-
-void
-fpononly(void)
-{
-	if (!m->fpon && havefp()) {
-		/* enable fp.  must be first operation on the FPUs. */
-		fpwr(Fpexc, Fpenabled);
-		m->fpon = 1;
-	}
-}
-
-static void
-fpcfg(void)
-{
-	int impl;
-	ulong sid;
-	static int printed;
-
-	/* clear pending exceptions; no traps in vfp3; all v7 ops are scalar */
-	m->fpscr = Dn | Fz | FPRNR | (FPINVAL | FPZDIV | FPOVFL) & ~Alltraps;
-	fpwr(Fpscr, m->fpscr);
-	m->fpconfiged = 1;
-
-	if (printed)
-		return;
-	sid = fprd(Fpsid);
-	impl = sid >> 24;
-	print("fp: %s arch %s; rev %ld\n", implement(impl),
-		subarch(impl, (sid >> 16) & MASK(7)), sid & MASK(4));
-	printed = 1;
-}
-
-void
-fpinit(void)
-{
-	if (havefp()) {
-		fpononly();
-		fpcfg();
-	}
-}
-
-void
-fpon(void)
-{
-	if (havefp()) {
-	 	fpononly();
-		if (m->fpconfiged)
-			fpwr(Fpscr, (fprd(Fpscr) & Allcc) | m->fpscr);
-		else
-			fpcfg();	/* 1st time on this fpu; configure it */
-	}
-}
-
-void
-fpclear(void)
-{
-//	ulong scr;
-
-	fpon();
-//	scr = fprd(Fpscr);
-//	m->fpscr = scr & ~Allexc;
-//	fpwr(Fpscr, m->fpscr);
-
-	fpwr(Fpexc, fprd(Fpexc) & ~Fpmbc);
-}
-
-
-/*
- * Called when a note is about to be delivered to a
- * user process, usually at the end of a system call.
- * Note handlers are not allowed to use the FPU so
- * the state is marked (after saving if necessary) and
- * checked in the Device Not Available handler.
- */
-void
-fpunotify(Ureg*)
-{
-	if(up->fpstate == FPactive){
-		fpsave(&up->fpsave);
-		up->fpstate = FPinactive;
-	}
-	up->fpstate |= FPillegal;
-}
-
-/*
- * Called from sysnoted() via the machine-dependent
- * noted() routine.
- * Clear the flag set above in fpunotify().
- */
-void
-fpunoted(void)
-{
-	up->fpstate &= ~FPillegal;
-}
-
-/*
- * Called early in the non-interruptible path of
- * sysrfork() via the machine-dependent syscall() routine.
- * Save the state so that it can be easily copied
- * to the child process later.
- */
-void
-fpusysrfork(Ureg*)
-{
-	if(up->fpstate == FPactive){
-		fpsave(&up->fpsave);
-		up->fpstate = FPinactive;
-	}
-}
-
-/*
- * Called later in sysrfork() via the machine-dependent
- * sysrforkchild() routine.
- * Copy the parent FPU state to the child.
- */
-void
-fpusysrforkchild(Proc *p, Ureg *, Proc *up)
-{
-	/* don't penalize the child, it hasn't done FP in a note handler. */
-	p->fpstate = up->fpstate & ~FPillegal;
-}
-
-/* should only be called if p->fpstate == FPactive */
-void
-fpsave(FPsave *fps)
-{
-	int n;
-
-	fpon();
-	fps->control = fps->status = fprd(Fpscr);
-	assert(m->fpnregs);
-	for (n = 0; n < m->fpnregs; n++)
-		fpsavereg(n, (uvlong *)fps->regs[n]);
-	fpoff();
-}
-
-static void
-fprestore(Proc *p)
-{
-	int n;
-
-	fpon();
-	fpwr(Fpscr, p->fpsave.control);
-	m->fpscr = fprd(Fpscr) & ~Allcc;
-	assert(m->fpnregs);
-	for (n = 0; n < m->fpnregs; n++)
-		fprestreg(n, *(uvlong *)p->fpsave.regs[n]);
-}
-
-/*
- * Called from sched() and sleep() via the machine-dependent
- * procsave() routine.
- * About to go in to the scheduler.
- * If the process wasn't using the FPU
- * there's nothing to do.
- */
-void
-fpuprocsave(Proc *p)
-{
-	if(p->fpstate == FPactive){
-		if(p->state == Moribund)
-			fpclear();
-		else{
-			/*
-			 * Fpsave() stores without handling pending
-			 * unmasked exeptions. Postnote() can't be called
-			 * here as sleep() already has up->rlock, so
-			 * the handling of pending exceptions is delayed
-			 * until the process runs again and generates an
-			 * emulation fault to activate the FPU.
-			 */
-			fpsave(&p->fpsave);
-		}
-		p->fpstate = FPinactive;
-	}
-}
-
-/*
- * The process has been rescheduled and is about to run.
- * Nothing to do here right now. If the process tries to use
- * the FPU again it will cause a Device Not Available
- * exception and the state will then be restored.
- */
-void
-fpuprocrestore(Proc *)
-{
-}
-
-/*
- * Disable the FPU.
- * Called from sysexec() via sysprocsetup() to
- * set the FPU for the new process.
- */
-void
-fpusysprocsetup(Proc *p)
-{
-	p->fpstate = FPinit;
-	fpoff();
-}
-
-static void
-mathnote(void)
-{
-	ulong status;
-	char *msg, note[ERRMAX];
-
-	status = up->fpsave.status;
-
-	/*
-	 * Some attention should probably be paid here to the
-	 * exception masks and error summary.
-	 */
-	if (status & FPAINEX)
-		msg = "inexact";
-	else if (status & FPAOVFL)
-		msg = "overflow";
-	else if (status & FPAUNFL)
-		msg = "underflow";
-	else if (status & FPAZDIV)
-		msg = "divide by zero";
-	else if (status & FPAINVAL)
-		msg = "bad operation";
-	else
-		msg = "spurious";
-	snprint(note, sizeof note, "sys: fp: %s fppc=%#p status=%#lux",
-		msg, up->fpsave.pc, status);
-	postnote(up, 1, note, NDebug);
-}
-
-static void
-mathemu(Ureg *)
-{
-	switch(up->fpstate){
-	case FPemu:
-		error("illegal instruction: VFP opcode in emulated mode");
-	case FPinit:
-		fpinit();
-		up->fpstate = FPactive;
-		break;
-	case FPinactive:
-		/*
-		 * Before restoring the state, check for any pending
-		 * exceptions.  There's no way to restore the state without
-		 * generating an unmasked exception.
-		 * More attention should probably be paid here to the
-		 * exception masks and error summary.
-		 */
-		if(up->fpsave.status & (FPAINEX|FPAUNFL|FPAOVFL|FPAZDIV|FPAINVAL)){
-			mathnote();
-			break;
-		}
-		fprestore(up);
-		up->fpstate = FPactive;
-		break;
-	case FPactive:
-		error("illegal instruction: bad vfp fpu opcode");
-		break;
-	}
-	fpclear();
-}
-
-void
-fpstuck(uintptr pc)
-{
-	if (m->fppc == pc && m->fppid == up->pid) {
-		m->fpcnt++;
-		if (m->fpcnt > 4)
-			panic("fpuemu: cpu%d stuck at pid %ld %s pc %#p "
-				"instr %#8.8lux", m->machno, up->pid, up->text,
-				pc, *(ulong *)pc);
-	} else {
-		m->fppid = up->pid;
-		m->fppc = pc;
-		m->fpcnt = 0;
-	}
-}
-
-enum {
-	N = 1<<31,
-	Z = 1<<30,
-	C = 1<<29,
-	V = 1<<28,
-	REGPC = 15,
-};
-
-static int
-condok(int cc, int c)
-{
-	switch(c){
-	case 0:	/* Z set */
-		return cc&Z;
-	case 1:	/* Z clear */
-		return (cc&Z) == 0;
-	case 2:	/* C set */
-		return cc&C;
-	case 3:	/* C clear */
-		return (cc&C) == 0;
-	case 4:	/* N set */
-		return cc&N;
-	case 5:	/* N clear */
-		return (cc&N) == 0;
-	case 6:	/* V set */
-		return cc&V;
-	case 7:	/* V clear */
-		return (cc&V) == 0;
-	case 8:	/* C set and Z clear */
-		return cc&C && (cc&Z) == 0;
-	case 9:	/* C clear or Z set */
-		return (cc&C) == 0 || cc&Z;
-	case 10:	/* N set and V set, or N clear and V clear */
-		return (~cc&(N|V))==0 || (cc&(N|V)) == 0;
-	case 11:	/* N set and V clear, or N clear and V set */
-		return (cc&(N|V))==N || (cc&(N|V))==V;
-	case 12:	/* Z clear, and either N set and V set or N clear and V clear */
-		return (cc&Z) == 0 && ((~cc&(N|V))==0 || (cc&(N|V))==0);
-	case 13:	/* Z set, or N set and V clear or N clear and V set */
-		return (cc&Z) || (cc&(N|V))==N || (cc&(N|V))==V;
-	case 14:	/* always */
-		return 1;
-	case 15:	/* never (reserved) */
-		return 0;
-	}
-	return 0;	/* not reached */
-}
-
-/* only called to deal with user-mode instruction faults */
-int
-fpuemu(Ureg* ureg)
-{
-	int s, nfp, cop, op;
-	uintptr pc;
-
-	if(waserror()){
-		postnote(up, 1, up->errstr, NDebug);
-		return 1;
-	}
-
-	if(up->fpstate & FPillegal)
-		error("floating point in note handler");
-
-	nfp = 0;
-	pc = ureg->pc;
-	validaddr(pc, 4, 0);
-	if(!condok(ureg->psr, *(ulong*)pc >> 28))
-		iprint("fpuemu: conditional instr shouldn't have got here\n");
-	op  = (*(ulong *)pc >> 24) & MASK(4);
-	cop = (*(ulong *)pc >>  8) & MASK(4);
-	if(m->fpon)
-		fpstuck(pc);		/* debugging; could move down 1 line */
-	if (ISFPAOP(cop, op)) {		/* old arm 7500 fpa opcode? */
-//		iprint("fpuemu: fpa instr %#8.8lux at %#p\n", *(ulong *)pc, pc);
-//		error("illegal instruction: old arm 7500 fpa opcode");
-		s = spllo();
-		if(waserror()){
-			splx(s);
-			nexterror();
-		}
-		nfp = fpiarm(ureg);	/* advances pc past emulated instr(s) */
-		if (nfp > 1)		/* could adjust this threshold */
-			m->fppc = m->fpcnt = 0;
-		splx(s);
-		poperror();
-	} else if (ISVFPOP(cop, op)) {	/* if vfp, fpu must be off */
-		mathemu(ureg);		/* enable fpu & retry */
-		nfp = 1;
-	}
-
-	poperror();
-	return nfp;
-}
+#include "../teg2/vfp3.c"
Only in ./9/boot: Makefile
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/boot/aux.c /Volumes/Plan 9 - Dec 29/sys/src/9/boot/aux.c
--- ./9/boot/aux.c	2014-01-20 15:58:02.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/boot/aux.c	2013-06-27 14:49:32.000000000 -0700
@@ -2,6 +2,57 @@
 #include <libc.h>
 #include <../boot/boot.h>
 
+/*
+int
+plumb(char *dir, char *dest, int *efd, char *here)
+{
+	char buf[128];
+	char name[128];
+	int n;
+
+	sprint(name, "%s/clone", dir);
+	efd[0] = open(name, ORDWR);
+	if(efd[0] < 0)
+		return -1;
+	n = read(efd[0], buf, sizeof(buf)-1);
+	if(n < 0){
+		close(efd[0]);
+		return -1;
+	}
+	buf[n] = 0;
+	sprint(name, "%s/%s/data", dir, buf);
+	if(here){
+		sprint(buf, "announce %s", here);
+		if(sendmsg(efd[0], buf) < 0){
+			close(efd[0]);
+			return -1;
+		}
+	}
+	sprint(buf, "connect %s", dest);
+	if(sendmsg(efd[0], buf) < 0){
+		close(efd[0]);
+		return -1;
+	}
+	efd[1] = open(name, ORDWR);
+	if(efd[1] < 0){
+		close(efd[0]);
+		return -1;
+	}
+	return efd[1];
+}
+
+int
+sendmsg(int fd, char *msg)
+{
+	int n;
+
+	n = strlen(msg);
+	if(write(fd, msg, n) != n)
+		return -1;
+	return 0;
+}
+ */
+
 void
 warning(char *s)
 {
@@ -25,55 +76,109 @@ fatal(char *s)
 	exits(msg);			/* this will trigger a panic */
 }
 
-void
-runv(char **argv)
+int
+readfile(char *name, char *buf, int len)
 {
-  int i, pid;
+	int f, n;
   
-  switch(pid = fork()){
-  case -1:
-    fatal("fork");
-  case 0:
-    exec(argv[0], argv);
-    fatal(smprint("can't exec %s: %r", argv[0]));
-  default:
-    while ((i = waitpid()) != pid && i != -1)
-      ;
-    if(i == -1)
-      fatal(smprint("wait failed running %s", argv[0]));
-  }
+	buf[0] = 0;
+	f = open(name, OREAD);
+	if(f < 0)
+		return -1;
+	n = read(f, buf, len-1);
+	if(n >= 0)
+		buf[n] = 0;
+	close(f);
+	return 0;
 }
 
-void
-run(char *file, ...)
+int
+writefile(char *name, char *buf, int len)
 {
-  runv(&file);
+	int f, n;
+
+	f = open(name, OWRITE);
+	if(f < 0)
+		return -1;
+	n = write(f, buf, len);
+	close(f);
+	return (n != len) ? -1 : 0;
 }
 
+void
+setenv(char *name, char *val)
+{
+	int f;
+	char ename[64];
 
-void bind_safe(char* old, char* new, int flag) {
-  if(bind(old, new, flag) < 0)
-    fatal("bind");
+	snprint(ename, sizeof ename, "#e/%s", name);
+	f = create(ename, 1, 0666);
+	if(f < 0){
+		fprint(2, "create %s: %r\n", ename);
   return;
+	}
+	write(f, val, strlen(val));
+	close(f);
 }
 
-int open_safe(char* path, int flag) {
-  int fd;
-  if((fd = open(path, flag)) < 0) {
-    fatal("open");
-  }
-  return fd;
+void
+srvcreate(char *name, int fd)
+{
+	char *srvname;
+	int f;
+	char buf[64];
+
+	srvname = strrchr(name, '/');
+	if(srvname)
+		srvname++;
+	else
+		srvname = name;
+
+	snprint(buf, sizeof buf, "#s/%s", srvname);
+	f = create(buf, 1, 0666);
+	if(f < 0)
+		fatal(buf);
+	sprint(buf, "%d", fd);
+	if(write(f, buf, strlen(buf)) != strlen(buf))
+		fatal("write");
+	close(f);
 }
 
-void print_safe(int fd, char* str) {
-  if(write(fd, str, strlen(str)) < 0) {
-    fatal("print");
-  };
-  return;
+void
+catchint(void *a, char *note)
+{
+	USED(a);
+	if(strcmp(note, "alarm") == 0)
+		noted(NCONT);
+	noted(NDFLT);
 }
 
-void close_safe(int fd) {
-  if(close(fd) < 0) {
-    fatal("close");
+int
+outin(char *prompt, char *def, int len)
+{
+	int n;
+	char buf[256];
+
+	if(len >= sizeof buf)
+		len = sizeof(buf)-1;
+
+	if(cpuflag){
+		notify(catchint);
+		alarm(15*1000);
+	}
+	print("%s[%s]: ", prompt, *def ? def : "no default");
+	memset(buf, 0, sizeof buf);
+	n = read(0, buf, len);
+	if(cpuflag){
+		alarm(0);
+		notify(0);
+	}
+
+	if(n < 0)
+		return 1;
+	if(n > 1){
+		buf[n-1] = 0;
+		strcpy(def, buf);
   }
+	return n;
 }
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/boot/boot.c /Volumes/Plan 9 - Dec 29/sys/src/9/boot/boot.c
--- ./9/boot/boot.c	2014-01-24 17:09:40.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/boot/boot.c	2013-12-05 13:50:15.000000000 -0800
@@ -1,7 +1,32 @@
 #include <u.h>
 #include <libc.h>
+#include <auth.h>
+#include <fcall.h>
 #include "../boot/boot.h"
 
+#define PARTSRV "partfs.sdXX"
+
+enum {
+	Dontpost,
+	Post,
+};
+
+char	cputype[64];
+char	sys[2*64];
+char 	reply[256];
+int	printcol;
+int	mflag;
+int	fflag;
+int	kflag;
+int	debugboot;
+
+char	*bargv[Nbarg];
+int	bargc;
+
+static void	swapproc(void);
+static Method	*rootserver(char*);
+static void	kbmap(void);
+
 /*
  * we should inherit the standard fds all referring to /dev/cons,
  * but we're being paranoid.
@@ -12,6 +37,7 @@ opencons(void)
   close(0);
   close(1);
   close(2);
+	bind("#c", "/dev", MBEFORE);
   open("/dev/cons", OREAD);
   open("/dev/cons", OWRITE);
   open("/dev/cons", OWRITE);
@@ -30,80 +56,385 @@ bindenvsrv(void)
 }
 
 static void
-swapproc(void)
+debuginit(int argc, char **argv)
 {
 	int fd;
 
-	fd = open("#c/swap", OWRITE);
-	if(fd < 0){
-		warning("opening #c/swap");
-		return;
-	}
-	if(write(fd, "start", 5) <= 0)
-		warning("starting swap kproc");
-	close(fd);
+	if(getenv("debugboot"))
+		debugboot = 1;
+#ifdef DEBUG
+	print("argc=%d\n", argc);
+	for(fd = 0; fd < argc; fd++)
+		print("%#p %s ", argv[fd], argv[fd]);
+	print("\n");
+#endif	/* DEBUG */
+	SET(fd);
+	USED(argc, argv, fd);
 }
 
+/*
+ * read disk partition tables here so that readnvram via factotum
+ * can see them.  ideally we would have this information in
+ * environment variables before attaching #S, which would then
+ * parse them and create partitions.
+ */
 static void
-execinit(void)
+partinit(void)
 {
-  int fd;
+	char *rdparts;
 
-  bind_safe("#p", "/proc", MREPL);
-  bind_safe("#d", "/fd", MREPL);
+	rdparts = getenv("readparts");
+	if(rdparts)
+		readparts();
+	free(rdparts);
+}
 
-  bind_safe("/root", "/", MAFTER|MCREATE);
-  bind_safe("/386/bin", "/bin", MREPL);
-  bind_safe("/rc/bin", "/bin", MAFTER);
-
-  bind_safe("#v", "/dev", MAFTER);
-  bind_safe("#m", "/dev", MAFTER);
-  bind_safe("#P", "/dev", MAFTER);
-
-  run("/bin/aux/mouse", "ps2", nil);
-  //this just need a regular vga driver
-  //run("/bin/aux/vga", "-l", "640x480x8", nil);
-  //this need special drivers, such as the clgd424x.c in the kernel
-  run("/bin/aux/vga", "-l", "1024x768x8", nil);
-  bind_safe("#i", "/dev", MAFTER);
-
-  // for rio
-  run("/bin/ramfs", "-m", "/mnt", nil);
-  run("/bin/mkdir", "/mnt/temp", nil); // see thread(2), used to create pipes
-  run("/bin/mkdir", "/mnt/wsys", nil);
-  fd = open_safe("#c/hostowner", OWRITE);
-  print_safe(fd, "pad");
-  close(fd);
+/*
+ *  pick a method and initialize it
+ */
+static Method *
+pickmethod(int argc, char **argv)
+{
+	Method *mp;
+
+	if(method[0].name == nil)
+		fatal("no boot methods");
+	mp = rootserver(argc ? *argv : 0);
+	(*mp->config)(mp);
+	return mp;
+}
+
+/*
+ *  authentication agent
+ *  sets hostowner, creating an auth discontinuity
+ */
+static void
+doauth(int cpuflag)
+{
+	if(debugboot)
+		fprint(2, "auth...");
+	authentication(cpuflag);
+}
 
-  // network
-  bind_safe("#I", "/net", MREPL);
-  bind_safe("#l0", "/net", MAFTER);
+/*
+ *  connect to the root file system
+ */
+static int
+connectroot(Method *mp, int islocal, int ishybrid)
+{
+	int fd, n;
+	char buf[32];
 
-  run("/bin/rc", nil);
+	fd = (*mp->connect)();
+	if(fd < 0)
+		fatal("can't connect to file server");
+	if(getenv("srvold9p"))
+		fd = old9p(fd);
+	if(!islocal && !ishybrid){
+		if(cfs)
+			fd = (*cfs)(fd);
+	}
+	print("version...");
+	buf[0] = '\0';
+	n = fversion(fd, 0, buf, sizeof buf);
+	if(n < 0)
+		fatal("can't init 9P");
+	srvcreate("boot", fd);
+	return fd;
+}
+
+/*
+ *  create the name space, mount the root fs
+ */
+static int
+nsinit(int fd, char **rspp)
+{
+	int afd;
+	char *rp, *rsp;
+	AuthInfo *ai;
+	static char rootbuf[64];
+
+	if(bind("/", "/", MREPL) < 0)
+		fatal("bind /");
+	rp = getenv("rootspec");
+	if(rp == nil)
+		rp = "";
+	
+	afd = fauth(fd, rp);
+	if(afd >= 0){
+		ai = auth_proxy(afd, auth_getkey, "proto=p9any role=client");
+		if(ai == nil)
+			print("authentication failed (%r), trying mount anyways\n");
+	}
+	if(mount(fd, afd, "/root", MREPL|MCREATE, rp) < 0)
+		fatal("mount /");
+	rsp = rp;
+	rp = getenv("rootdir");
+	if(rp == nil)
+		rp = rootdir;
+	if(bind(rp, "/", MAFTER|MCREATE) < 0){
+		if(strncmp(rp, "/root", 5) == 0){
+			fprint(2, "boot: couldn't bind $rootdir=%s to root: %r\n", rp);
+			fatal("second bind /");
+		}
+		snprint(rootbuf, sizeof rootbuf, "/root/%s", rp);
+		rp = rootbuf;
+		if(bind(rp, "/", MAFTER|MCREATE) < 0){
+			fprint(2, "boot: couldn't bind $rootdir=%s to root: %r\n", rp);
+			if(strcmp(rootbuf, "/root//plan9") != 0)
+				fatal("second bind /");
+			/* undo installer's work */
+			fprint(2, "**** warning: remove rootdir=/plan9 "
+				"entry from plan9.ini\n");
+			rp = "/root";
+			if(bind(rp, "/", MAFTER|MCREATE) < 0)
+				fatal("second bind /");
+		}
+	}
+	setenv("rootdir", rp);
+	*rspp = rsp;
+	return afd;
 }
 
+static void
+execinit(void)
+{
+	int iargc;
+	char *cmd, cmdbuf[64], *iargv[16];
+
+	/* exec init */
+	cmd = getenv("init");
+	if(cmd == nil){
+		sprint(cmdbuf, "/%s/init -%s%s", cputype,
+			cpuflag ? "c" : "t", mflag ? "m" : "");
+		cmd = cmdbuf;
+	}
+	iargc = tokenize(cmd, iargv, nelem(iargv)-1);
+	cmd = iargv[0];
+
+	/* make iargv[0] basename(iargv[0]) */
+	if(iargv[0] = strrchr(iargv[0], '/'))
+		iargv[0]++;
+	else
+		iargv[0] = cmd;
+
+	iargv[iargc] = nil;
+
+	chmod("/srv/" PARTSRV, 0600);
+	exec(cmd, iargv);
+	fatal(cmd);
+}
 
 void
 boot(int argc, char *argv[])
 {
-  USED(argc);
-  USED(argv);
+	int fd, afd, islocal, ishybrid;
+	char *rsp;
+	Method *mp;
 
   fmtinstall('r', errfmt);
-
-  //At this point we should have #/ and #c setup by the kernel init0
-
   opencons();
   bindenvsrv();
+	debuginit(argc, argv);
 
-  print("booooooooting...\n");
-
-  rfork(RFNAMEG);
+	ARGBEGIN{
+	case 'k':
+		kflag = 1;
+		break;
+	case 'm':
+		mflag = 1;
+		break;
+	case 'f':
+		fflag = 1;
+		break;
+	}ARGEND
+
+	readfile("#e/cputype", cputype, sizeof(cputype));
+
+	/*
+	 *  set up usb keyboard & mouse, if any.
+	 *  starts partfs on first disk, if any, to permit nvram on usb.
+	 */
+	usbinit(Dontpost);
 
-  connectlocal();
+	mp = pickmethod(argc, argv);
+	islocal = strcmp(mp->name, "local") == 0;
+	ishybrid = strcmp(mp->name, "hybrid") == 0;
+
+	kbmap();			/*  load keymap if it's there. */
+
+	/* don't trigger aoe until the network has been configured */
+	bind("#Ã¦", "/dev", MAFTER);	/* nvram could be here */
+	bind("#S", "/dev", MAFTER);	/* nvram could be here */
+	partinit();
+
+	doauth(cpuflag);	/* authentication usually changes hostowner */
+	rfork(RFNAMEG);		/* leave existing subprocs in own namespace */
+	usbinit(Post);		/* restart partfs under the new hostowner id */
+	fd = connectroot(mp, islocal, ishybrid);
+	afd = nsinit(fd, &rsp);
+	close(fd);
 
+	settime(islocal, afd, rsp);
+	if(afd > 0)
+		close(afd);
   swapproc();
   execinit();
-
   exits("failed to exec init");
 }
+
+static Method*
+findmethod(char *a)
+{
+	Method *mp;
+	int i, j;
+	char *cp;
+
+	if((i = strlen(a)) == 0)
+		return nil;
+	cp = strchr(a, '!');
+	if(cp)
+		i = cp - a;
+	for(mp = method; mp->name; mp++){
+		j = strlen(mp->name);
+		if(j > i)
+			j = i;
+		if(strncmp(a, mp->name, j) == 0)
+			break;
+	}
+	if(mp->name)
+		return mp;
+	return nil;
+}
+
+/*
+ *  ask user from whence cometh the root file system
+ */
+static Method*
+rootserver(char *arg)
+{
+	char prompt[256];
+	Method *mp;
+	char *cp;
+	int n;
+
+	/* look for required reply */
+	readfile("#e/nobootprompt", reply, sizeof(reply));
+	if(reply[0]){
+		mp = findmethod(reply);
+		if(mp)
+			goto HaveMethod;
+		print("boot method %s not found\n", reply);
+		reply[0] = 0;
+	}
+
+	/* make list of methods */
+	mp = method;
+	n = sprint(prompt, "root is from (%s", mp->name);
+	for(mp++; mp->name; mp++)
+		n += sprint(prompt+n, ", %s", mp->name);
+	sprint(prompt+n, ")");
+
+	/* create default reply */
+	readfile("#e/bootargs", reply, sizeof(reply));
+	if(reply[0] == 0 && arg != 0)
+		strcpy(reply, arg);
+	if(reply[0]){
+		mp = findmethod(reply);
+		if(mp == 0)
+			reply[0] = 0;
+	}
+	if(reply[0] == 0)
+		strcpy(reply, method->name);
+
+	/* parse replies */
+	do{
+		outin(prompt, reply, sizeof(reply));
+		mp = findmethod(reply);
+	}while(mp == nil);
+
+HaveMethod:
+	bargc = tokenize(reply, bargv, Nbarg-2);
+	bargv[bargc] = nil;
+	cp = strchr(reply, '!');
+	if(cp)
+		strcpy(sys, cp+1);
+	return mp;
+}
+
+static void
+swapproc(void)
+{
+	int fd;
+
+	fd = open("#c/swap", OWRITE);
+	if(fd < 0){
+		warning("opening #c/swap");
+		return;
+	}
+	if(write(fd, "start", 5) <= 0)
+		warning("starting swap kproc");
+	close(fd);
+}
+
+int
+old9p(int fd)
+{
+	int p[2];
+
+	if(pipe(p) < 0)
+		fatal("pipe");
+
+	print("srvold9p...");
+	switch(fork()) {
+	case -1:
+		fatal("rfork srvold9p");
+	case 0:
+		dup(fd, 1);
+		close(fd);
+		dup(p[0], 0);
+		close(p[0]);
+		close(p[1]);
+		execl("/srvold9p", "srvold9p", "-s", 0);
+		fatal("exec srvold9p");
+	default:
+		close(fd);
+		close(p[0]);
+	}
+	return p[1];
+}
+
+static void
+kbmap(void)
+{
+	char *f;
+	int n, in, out;
+	char buf[1024];
+
+	f = getenv("kbmap");
+	if(f == nil)
+		return;
+	if(bind("#Îº", "/dev", MAFTER) < 0){
+		warning("can't bind #Îº");
+		return;
+	}
+
+	in = open(f, OREAD);
+	if(in < 0){
+		warning("can't open kbd map");
+		return;
+	}
+	out = open("/dev/kbmap", OWRITE);
+	if(out < 0) {
+		warning("can't open /dev/kbmap");
+		close(in);
+		return;
+	}
+	while((n = read(in, buf, sizeof(buf))) > 0)
+		if(write(out, buf, n) != n){
+			warning("write to /dev/kbmap failed");
+			break;
+		}
+	close(in);
+	close(out);
+}
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/boot/boot.h /Volumes/Plan 9 - Dec 29/sys/src/9/boot/boot.h
--- ./9/boot/boot.h	2014-01-20 15:57:22.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/boot/boot.h	2012-08-15 14:26:08.000000000 -0700
@@ -1,21 +1,3 @@
-/* libc equivalent */
-extern void	fatal(char*);
-extern void	warning(char*);
-extern void	run(char *file, ...);
-extern void	runv(char **argv);
-
-/* pad style */
-void bind_safe(char* old, char* new, int flag);
-int open_safe(char* path, int flag);
-void print_safe(int fd, char* str);
-void close_safe(int fd);
-
-/* main entry point */
-extern void	boot(int, char **);
-
-
-
-/* what bootpcf.c expect */
 typedef struct Method	Method;
 struct Method
 {
@@ -24,11 +6,71 @@ struct Method
 	int	(*connect)(void);
 	char	*arg;
 };
+enum
+{
+	Statsz=	256,
+	Nbarg=	16,
+};
 
-extern Method	method[];		/* defined in ../$arch/boot$CONF.c */
 extern char*	bootdisk;		/* defined in ../$arch/boot$CONF.c */
+extern char*	rootdir;
+extern int	(*cfs)(int);
+extern int	cpuflag;
+extern char	cputype[];
+extern int	debugboot;
+extern int	fflag;
+extern int	kflag;
+extern Method	method[];		/* defined in ../$arch/boot$CONF.c */
+extern void	(*pword)(int, Method*);
+extern char	sys[];
+extern uchar	hostkey[];
+extern uchar	statbuf[Statsz];
+extern int	bargc;
+extern char	*bargv[Nbarg];
+extern int	pcload;
+
+/* libc equivalent */
+extern void	authentication(int);
+extern int	cache(int);
+extern char*	checkkey(Method*, char*, char*);
+extern int	chmod(char *file, int mode);
+extern void	fatal(char*);
+extern void	getpasswd(char*, int);
+extern void	key(int, Method*);
+extern int	mountusbparts(void);
+extern int	outin(char*, char*, int);
+extern int	plumb(char*, char*, int*, char*);
+extern int	readfile(char*, char*, int);
+extern int	readparts(void);
+extern long	readn(int, void*, long);
+extern void	run(char *file, ...);
+extern void	runv(char **argv);
+extern int	sendmsg(int, char*);
+extern void	setenv(char*, char*);
+extern void	settime(int, int, char*);
+extern void	srvcreate(char*, int);
+extern void	usbinit(int post);
+extern void	warning(char*);
+extern int	writefile(char*, char*, int);
+extern void	boot(int, char **);
+extern void	doauthenticate(int, Method*);
+extern int		old9p(int);
+extern int	parsefields(char*, char**, int, char*);
 
 /* methods */
+extern void	configtcp(Method*);
+extern int	connecttcp(void);
+
 extern void	configlocal(Method*);
 extern int	connectlocal(void);
 
+extern void	configpaq(Method*);
+extern int	connectpaq(void);
+
+extern void	configembed(Method*);
+extern int	connectembed(void);
+
+extern void	configip(int, char**, int);
+
+/* hack for passing authentication address */
+extern char	*authaddr;
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: bootauth.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: bootcache.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: bootip.c
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/boot/bootmkfile /Volumes/Plan 9 - Dec 29/sys/src/9/boot/bootmkfile
--- ./9/boot/bootmkfile	2014-01-20 13:28:33.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/boot/bootmkfile	2012-08-15 14:26:08.000000000 -0700
@@ -1,18 +1,25 @@
-MKSHELL=$PLAN9/bin/rc
-
 BOOTDIR=../boot
 BOOTLIB=$BOOTDIR/libboot.a$O
 
 BOOTFILES=\
+	bootauth.$O\
         aux.$O\
 	boot.$O\
+	bootcache.$O\
+	bootip.$O\
 	local.$O\
+	embed.$O\
+	settime.$O\
+	paq.$O\
+	parts.$O\
+	printstub.$O\
+	usb.$O\
 
 $BOOTLIB(%.$O):N:	%.$O
 
 $BOOTLIB:	${BOOTFILES:%=$BOOTLIB(%)}
 	names=`{membername $newprereq}
-	iar vu $BOOTLIB $names
+	ar vu $BOOTLIB $names
 	rm $names
 
 $BOOTFILES:	$BOOTDIR/boot.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: doauthenticate.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: embed.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: getpasswd.c
Only in ./9/boot: libboot.a5
Binary files ./9/boot/libboot.a8 and /Volumes/Plan 9 - Dec 29/sys/src/9/boot/libboot.a8 differ
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/boot/local.c /Volumes/Plan 9 - Dec 29/sys/src/9/boot/local.c
--- ./9/boot/local.c	2014-01-20 19:24:18.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/boot/local.c	2011-05-13 15:49:17.000000000 -0700
@@ -2,28 +2,287 @@
 #include <libc.h>
 #include <../boot/boot.h>
 
+static char diskname[64];
+static char *disk;
+static char **args;
+
 void
 configlocal(Method *mp)
 {
-  USED(mp);
+	char *p, *inibootdisk;
+	int n;
+
+	inibootdisk = getenv("bootdisk");
+	if(*sys == '/' || *sys == '#'){
+		/*
+		 *  if the user specifies the disk in the boot cmd or
+		 * 'root is from' prompt, use it
+		 */
+		disk = sys;
+	} else if(strncmp(argv0, "dksc(0,", 7) == 0){
+		/*
+		 *  on many mips arg0 of the boot command specifies the
+		 *  scsi logical unit number
+		 */
+		p = strchr(argv0, ',');
+		n = strtoul(p+1, 0, 10);
+		sprint(diskname, "#w%d/sd%dfs", n, n);
+		disk = diskname;
+	} else if(mp->arg){
+		/*
+		 *  a default is optionally supplied when the kernel is made
+		 */
+		disk = mp->arg;
+	} else if(inibootdisk != nil && *inibootdisk)
+		/* plan9.ini overrides default from config file */
+		disk = inibootdisk;
+	else if(bootdisk != nil && *bootdisk){
+		/*
+		 *  an environment variable from a pc's plan9.ini or
+		 *  from the mips nvram or generated by the kernel
+		 *  is the last resort.
+		 */
+		disk = bootdisk;
+	}
+
+	/* if we've decided on one, pass it on to all programs */
+	if(disk) {
+		bootdisk = disk;
+		setenv("bootdisk", bootdisk);
+	}
+}
+
+int
+connectlocalkfs(void)
+{
+	int i, pid, fd, p[2];
+	char partition[64];
+	char *dev;
+	char **arg, **argp;
+	Dir *d;
+
+	if(stat("/boot/kfs", statbuf, sizeof statbuf) < 0)
+		return -1;
+
+	dev = disk ? disk : bootdisk;
+	snprint(partition, sizeof partition, "%sfs", dev);
+	fd = open(partition, OREAD);
+	if(fd < 0){
+		strcpy(partition, dev);
+		fd = open(partition, OREAD);
+		if(fd < 0)
+			return -1;
+	}
+	/*
+	 * can't do this check -- might be some other server posing as kfs.
+	 *
+	memset(buf, 0, sizeof buf);
+	pread(fd, buf, 512, 0);
+	close(fd);
+	if(memcmp(buf+256, "kfs wren device\n", 16) != 0){
+		if(strstr(partition, "/fs"))
+			print("no kfs file system found on %s\n", partition);
+		return -1;
+	}
+	 *
+	 */
+	d = dirfstat(fd);
+	close(fd);
+	if(d == nil)
+		return -1;
+	if(d->mode&DMDIR){
+		free(d);
+		return -1;
+	}
+	free(d);
+
+	print("kfs...");
+	if(pipe(p)<0)
+		fatal("pipe");
+	switch(pid = fork()){
+	case -1:
+		fatal("fork");
+	case 0:
+		arg = malloc((bargc+5)*sizeof(char*));
+		argp = arg;
+		*argp++ = "kfs";
+		*argp++ = "-f";
+		*argp++ = partition;
+		*argp++ = "-s";
+		for(i=1; i<bargc; i++)
+			*argp++ = bargv[i];
+		*argp = 0;
+
+		dup(p[0], 0);
+		dup(p[1], 1);
+		close(p[0]);
+		close(p[1]);
+		exec("/boot/kfs", arg);
+		fatal("can't exec kfs");
+	default:
+		break;
+	}
+	for(;;){
+		if((i = waitpid()) == -1)
+			fatal("waitpid for kfs failed");
+		if(i == pid)
+			break;
+	}
+
+	close(p[1]);
+	return p[0];
+}
+
+void
+runv(char **argv)
+{
+	int i, pid;
+
+	switch(pid = fork()){
+	case -1:
+		fatal("fork");
+	case 0:
+		exec(argv[0], argv);
+		fatal(smprint("can't exec %s: %r", argv[0]));
+	default:
+		while ((i = waitpid()) != pid && i != -1)
+			;
+		if(i == -1)
+			fatal(smprint("wait failed running %s", argv[0]));
+	}
 }
 
+void
+run(char *file, ...)
+{
+	runv(&file);
+}
+
+static int
+print1(int fd, char *s)
+{
+	return write(fd, s, strlen(s));
+}
+
+void
+configloopback(void)
+{
+	int fd;
+
+	if((fd = open("/net/ipifc/clone", ORDWR)) < 0){
+		bind("#I", "/net", MAFTER);
+		if((fd = open("/net/ipifc/clone", ORDWR)) < 0)
+			fatal("open /net/ipifc/clone for loopback");
+	}
+	if(print1(fd, "bind loopback /dev/null") < 0
+	|| print1(fd, "add 127.0.0.1 255.255.255.255") < 0)
+		fatal("write /net/ipifc/clone for loopback");
+}
 
 int
-connectlocal(void)
+connectlocalfossil(void)
 {
   int fd;
+	char *venti, *f[32], *p;
+	int nf;
+	char partition[128], buf[512];
+	char *dev;
   
-  bind_safe("#S", "/dev", MAFTER);
+	if(stat("/boot/fossil", statbuf, sizeof statbuf) < 0)
+		return -1;
 
-  fd = open_safe("/dev/sdC1/ctl", ORDWR);
-  //TODO: use fdisk -p /dev/sdC1/data > /dev/sdC1/ctl
-  //for sdC0: #prep -p /dev/sdC1/plan9 > /dev/sdC1/ctl
-  print_safe(fd, "part dos 1 1000063");
-  close_safe(fd);
+	/* look for fossil partition */
+	dev = disk ? disk : bootdisk;
+	snprint(partition, sizeof partition, "%sfossil", dev);
+	fd = open(partition, OREAD);
+	if(fd < 0){
+		strcpy(partition, dev);
+		fd = open(partition, OREAD);
+		if(fd < 0)
+			return -1;
+	}
+	memset(buf, 0, sizeof buf);
+	pread(fd, buf, 512, 127*1024);
+	close(fd);
+	if(memcmp(buf, "fossil config\n", 14) != 0){
+		if(strstr(partition, "/fossil"))
+			print("no fossil config found on %s\n", partition);
+		return -1;
+	}
+
+	settime(1, -1, nil);
+
+	/* make venti available.  give it 20% of free memory. */
+	if((venti = getenv("venti")) && (nf = tokenize(venti, f, nelem(f)))){
+		if((fd = open(f[0], OREAD)) >= 0){
+			print("venti...");
+			memset(buf, 0, sizeof buf);
+			pread(fd, buf, 512, 248*1024);
+			close(fd);
+			if(memcmp(buf, "venti config\n", 13) != 0){
+				print("no venti config found on %s\n", f[0]);
+				return -1;
+			}
+			if(stat("/boot/venti", statbuf, sizeof statbuf) < 0){
+				print("/boot/venti does not exist\n");
+				return -1;
+			}
+			switch(nf){
+			case 1:
+				f[1] = "tcp!127.1!17034";
+			case 2:
+				f[2] = "tcp!127.1!8000";
+			}
+			configloopback();
+			run("/boot/venti", "-m", "20", "-c", f[0],
+				"-a", f[1], "-h", f[2], nil);
+			/*
+			 * If the announce address is tcp!*!foo, then set
+			 * $venti to tcp!127.1!foo instead, which is actually dialable.
+			 */
+			if((p = strstr(f[1], "!*!")) != 0){
+				*p = 0;
+				snprint(buf, sizeof buf, "%s!127.1!%s", f[1], p+3);
+				f[1] = buf;
+			}
+			setenv("venti", f[1]);
+		}else{
+			/* set up the network so we can talk to the venti server */
+			/* this is such a crock. */
+			configip(nf, f, 0);
+			setenv("venti", f[0]);
+		}
+	}
+
+	/* start fossil.  give it 20% of free memory. */
+	print("fossil(%s)...", partition);
+	run("/boot/fossil", "-m", "20", "-f", partition,
+		"-c", "srv -A fboot", "-c", "srv -p fscons", nil);
+	fd = open("#s/fboot", ORDWR);
+	if(fd < 0){
+		warning("open #s/fboot");
+		return -1;
+	}
+	remove("#s/fboot");  /* we'll repost fd as #s/boot after fversion(fd) */
+	return fd;
+}
+
+int
+connectlocal(void)
+{
+	int fd;
 
-  run("/boot/dossrv", nil);
-  run("/boot/mount", "-c", "/srv/dos", "/root", "/dev/sdC1/dos", nil);
+	if(bind("#c", "/dev", MREPL) < 0)
+		fatal("bind #c");
+	if(bind("#p", "/proc", MREPL) < 0)
+		fatal("bind #p");
+	bind("#S", "/dev", MAFTER);
+	bind("#k", "/dev", MAFTER);
+	bind("#u", "/dev", MAFTER);
+	bind("#Ã¦", "/dev", MAFTER);
+	mountusbparts();	/* make partfs partitions visible again */
   
-  return 0;
+	if((fd = connectlocalfossil()) < 0)
+		fd = connectlocalkfs();
+	return fd;
 }
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/boot/mkboot /Volumes/Plan 9 - Dec 29/sys/src/9/boot/mkboot
--- ./9/boot/mkboot	2014-01-15 12:18:18.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/boot/mkboot	2007-02-15 22:45:07.000000000 -0800
@@ -85,3 +85,17 @@ awk '
 		  print "}"
 		}
 ' $1
+
+#
+#  configure in a cache file system if a 
+# /386/bin/root appears in the bootdir section.
+#
+../port/mkextract bootdir 0 $* | awk '
+	BEGIN			{ cfs = 0 }
+	$1 ~ "bin/cfs$"	{ cfs = 1 }
+	END			{ if(cfs)
+					print "int (*cfs)(int) = cache;"
+				  else
+					print "int (*cfs)(int) = 0;"
+				}
+	'
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: nopsession.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: paq.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: parts.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: printstub.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: sac.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: settime.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: testboot.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/boot: usb.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/ip: eipconvtest.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/ip: esp.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/ip: gre.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/ip: igmp.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/ip: ipmux.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/ip: netdevmedium.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/ip: rudp.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9: kw
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/mkfile /Volumes/Plan 9 - Dec 29/sys/src/9/mkfile
--- ./9/mkfile	2014-01-22 23:44:14.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/mkfile	2013-08-02 16:57:51.000000000 -0700
@@ -1,23 +1,36 @@
-MKSHELL=$PLAN9/bin/rc
-
 ARCH=\
-	pc\
 	bcm\
+	kw\
+	mtx\
+	omap\
+	pc\
+	ppc\
+	rb\
+	teg2\
 
 all:V:
 	for(i in $ARCH)@{
 		cd $i
 		mk
 	}
+	# build pc boots last
+	@{ cd pc; mk clean }
+	@{ cd pcboot; mk }
+pcboot:V:
+	@{ cd pc; mk clean }
+	@{ cd pcboot; mk }
 
 installall install:V:
 	for(i in $ARCH) @{
 		cd $i
 		mk $target
 	}
+	@{ cd pc; mk clean }
+	@{ cd pcboot; mk install }
+	@{ cd pc; mk clean }
 
 clean:V:
-	for(i in $ARCH) @{
+	for(i in $ARCH pcboot) @{
 		cd $i
 		mk clean
 	}
Only in /Volumes/Plan 9 - Dec 29/sys/src/9: mtx
Only in /Volumes/Plan 9 - Dec 29/sys/src/9: omap
Only in ./9/pc: 9pcf
Only in ./9/pc: Makefile
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: a100p.cp
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ahci.h
Only in ./9/pc: alarm.8
Only in ./9/pc: alloc.8
Only in ./9/pc: allocb.8
Only in ./9/pc: apbootstrap.8
Only in ./9/pc: apbootstrap.h
Only in ./9/pc: apbootstrap.out
Only in ./9/pc: apic.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: apm.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: apmjump.s
Only in ./9/pc: archmp.8
Only in ./9/pc: arp.8
Only in ./9/pc: auth.8
Only in ./9/pc: bios32.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/pc/bios32.c /Volumes/Plan 9 - Dec 29/sys/src/9/pc/bios32.c
--- ./9/pc/bios32.c	2014-01-14 12:50:17.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/pc/bios32.c	2011-10-10 13:47:52.000000000 -0700
@@ -5,8 +5,7 @@
 #include "fns.h"
 #include "io.h"
 
-//#define VFLAG(...)	if(vflag) print(__VA_ARGS__)
-#define VFLAG if(vflag) print
+#define VFLAG(...)	if(vflag) print(__VA_ARGS__)
 
 #define UPTR2INT(p)	((uintptr)(p))
 
Only in ./9/pc: bootpcf.8
Only in ./9/pc: bootpcf.c
Only in ./9/pc: bootpcf.out
Only in ./9/pc: cache.8
Only in ./9/pc: cga.8
Only in ./9/pc: chan.8
Only in ./9/pc: chandial.8
Only in ./9/pc: cis.8
Only in ./9/pc: compile.sh
Only in ./9/pc: dev.8
Only in ./9/pc: devarch.8
Only in ./9/pc: devaudio.8
Only in ./9/pc: devcap.8
Only in ./9/pc: devcons.8
Only in ./9/pc: devdraw.8
Only in ./9/pc: devdup.8
Only in ./9/pc: devenv.8
Only in ./9/pc: devether.8
Only in ./9/pc: devfloppy.8
Only in ./9/pc: devfs.8
Only in ./9/pc: devi82365.8
Only in ./9/pc: devip.8
Only in ./9/pc: devkbin.8
Only in ./9/pc: devkbmap.8
Only in ./9/pc: devkprof.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: devlm78.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: devlml.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: devlml.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: devlpt.c
Only in ./9/pc: devmnt.8
Only in ./9/pc: devmouse.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: devpccard.c
Only in ./9/pc: devpipe.8
Only in ./9/pc: devpnp.8
Only in ./9/pc: devproc.8
Only in ./9/pc: devroot.8
Only in ./9/pc: devrtc.8
Only in ./9/pc: devsd.8
Only in ./9/pc: devsrv.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: devtv.c
Only in ./9/pc: devuart.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: devusb.c
Only in ./9/pc: devvga.8
Only in ./9/pc: dma.8
Only in ./9/pc: edf.8
Only in ./9/pc: errstr.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether2000.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether2114x.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether589.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether79c970.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether8003.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether8139.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether8169.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether82543gc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether82557.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether82563.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether82598.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether83815.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether8390.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ether8390.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherdp83820.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherec2t.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherelnk3.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherga620.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherga620fw.h
Only in ./9/pc: etherigbe.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherm10g.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherm10g2k.i
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherm10g4k.i
Only in ./9/pc: ethermedium.8
Only in ./9/pc: ethermii.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ethersink.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ethersmc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ethervgbe.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ethervt6102.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: ethervt6105m.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: etherwavelan.c
Only in ./9/pc: fault.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/pc/fns.h /Volumes/Plan 9 - Dec 29/sys/src/9/pc/fns.h
--- ./9/pc/fns.h	2014-01-14 15:55:28.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/pc/fns.h	2013-06-13 14:01:35.000000000 -0700
@@ -200,5 +200,3 @@ int	xchgw(ushort*, int);
 
 #define L16GET(p)	(((p)[1]<<8)|(p)[0])
 #define L32GET(p)	(((u32int)L16GET((p)+2)<<16)|L16GET(p))
-
-void loop();
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: hcwAMC.h
Only in ./9/pc: i8253.8
Only in ./9/pc: i8259.8
Only in ./9/pc: icmp.8
Only in ./9/pc: icmp6.8
Only in ./9/pc: inferno.8
Only in ./9/pc: init.h
Only in ./9/pc: init.out
Only in ./9/pc: init9.8
Only in ./9/pc: initcode.8
Only in ./9/pc: ip.8
Only in ./9/pc: ipaux.8
Only in ./9/pc: ipifc.8
Only in ./9/pc: iproute.8
Only in ./9/pc: ipv6.8
Only in ./9/pc: kbd.8
Only in ./9/pc: l.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/pc/l.s /Volumes/Plan 9 - Dec 29/sys/src/9/pc/l.s
--- ./9/pc/l.s	2014-01-14 15:26:26.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/pc/l.s	2013-05-28 13:52:06.000000000 -0700
@@ -49,39 +49,13 @@ TEXT _multibootheader(SB), $0
 	LONG	$_startKADDR-KZERO(SB)		/* load_addr */
 	LONG	$edata-KZERO(SB)		/* load_end_addr */
 	LONG	$end-KZERO(SB)			/* bss_end_addr */
-	LONG	$_multibootentry-KZERO(SB)		/* entry_addr */
+	LONG	$_startKADDR-KZERO(SB)		/* entry_addr */
 	LONG	$0				/* mode_type */
 	LONG	$0				/* width */
 	LONG	$0				/* height */
 	LONG	$0				/* depth */
 
 /* 
- * the kernel expects the data segment to be page-aligned
- * multiboot bootloaders put the data segment right behind text
- */
-TEXT _multibootentry(SB), $0
-	MOVL	$etext-KZERO(SB), SI
-	MOVL	SI, DI
-	ADDL	$0xfff, DI
-	ANDL	$~0xfff, DI
-	MOVL	$edata-KZERO(SB), CX
-	SUBL	DI, CX
-	ADDL	CX, SI
-	ADDL	CX, DI
-	STD
-	REP; MOVSB
-	CLD
-	ADDL	$KZERO, BX
-	MOVL	BX, multiboot-KZERO(SB)
-	MOVL	$_startPADDR(SB), AX
-	ANDL	$~KZERO, AX
-	JMP*	AX
-
-/* multiboot structure pointer */
-TEXT multiboot(SB), $0
-	LONG	$0
-
-/*
  * In protected mode with paging turned off and segment registers setup
  * to linear map all memory. Entered via a jump to PADDR(entry),
  * the physical address of the virtual kernel entry point of KADDR(entry).
Only in ./9/pc: latin1.8
Only in ./9/pc: loopbackmedium.8
Only in ./9/pc: main.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/pc/main.c /Volumes/Plan 9 - Dec 29/sys/src/9/pc/main.c
--- ./9/pc/main.c	2014-01-17 23:29:18.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/pc/main.c	2013-07-25 15:28:23.000000000 -0700
@@ -13,11 +13,6 @@
 
 Mach *m;
 
-void loop() {
-  while(1) {
-  }
-}
-
 /*
  * Where configuration info is left for the loaded programme.
  * This will turn into a structure as more is done by the boot loader
@@ -49,22 +44,6 @@ options(void)
 {
 	long i, n;
 	char *cp, *line[MAXCONF], *p, *q;
-	ulong *m, l;
-	extern ulong *multiboot;
-
-	if(multiboot != nil){
-		cp = BOOTARGS;
-		*cp = 0;
-		if((*multiboot & 8) != 0 && multiboot[5] > 0){
-			m = KADDR(multiboot[6]);
-			l = m[1] - m[0];
-			m = KADDR(m[0]);
-			if(l >= BOOTARGSLEN)
-				l = BOOTARGSLEN - 1;
-			memmove(cp, m, l);
-			cp[l] = 0;
-		}
-	}
 
 	/*
 	 *  parse configuration args from dos file plan9.ini
@@ -121,7 +100,7 @@ main(void)
 	quotefmtinstall();
 	screeninit();
 
-	print("\nPlan 99999999999999\n");
+	print("\nPlan 9\n");
 
 	trapinit0();
 	mmuinit0();
Only in ./9/pc: mem.h.8
Only in ./9/pc: memory.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/pc/mkfile /Volumes/Plan 9 - Dec 29/sys/src/9/pc/mkfile
--- ./9/pc/mkfile	2014-01-15 12:59:57.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/pc/mkfile	2012-04-16 20:31:35.000000000 -0700
@@ -1,7 +1,8 @@
-MKSHELL=$PLAN9/bin/rc
-
-CONF=pcf
-CONFLIST=pcf
+CONF=pc
+CONFLIST=pc pccpu pcf pcdisk # pccpuf pcauth
+CRAPLIST=pccd pcflop
+EXTRACOPIES=
+#EXTRACOPIES=lookout boundary	# copy to these servers on install
 
 objtype=386
 </$objtype/mkfile
@@ -60,13 +61,13 @@ OBJ=\
 	$DEVS\
 	$PORT\
 
-#pad: the order matters!
 LIB=\
 	/$objtype/lib/libmemlayer.a\
 	/$objtype/lib/libmemdraw.a\
 	/$objtype/lib/libdraw.a\
 	/$objtype/lib/libip.a\
 	/$objtype/lib/libc.a\
+	/$objtype/lib/libsec.a\
 	/$objtype/lib/libmp.a\
 
 ETHER=`{echo devether.c ether*.c | sed 's/\.c/.'$O'/g'}
@@ -76,32 +77,50 @@ SDEV=`{echo devsd.c sd*.c | sed 's/\.c/.
 $p$CONF:	$CONF.c $OBJ $LIB
 	$CC $CFLAGS '-DKERNDATE='`{date -n} $CONF.c
 	$LD -o $target -T$KTZERO -l $OBJ $CONF.$O $LIB
-	ksize $target
+	size $target
 
 # don't strip the gzipped kernels -- too frustrating when that's all you have!
 $p%.gz:D:	$p%
 	gzip -9 <$p$stem >$p$stem.gz
 
 
+# pcflop and pccd need all the space they can get
+9pcflop.gz:D: 9pcflop
+	strip -o /fd/1 9pcflop | gzip -9 >9pcflop.gz
+
+9pccd.gz:D: 9pccd
+	strip -o /fd/1 9pccd | gzip -9 >9pccd.gz
+
+
 install:V:	$p$CONF
 	cp $p$CONF /$objtype/
+	for(i in $EXTRACOPIES)
+		import $i / /n/$i && cp $p$CONF /n/$i/$objtype/
 
 <../boot/bootmkfile
 <../port/portmkfile
 <|../port/mkbootrules $CONF
 
-#PAD: todo should be done via 'mk depend'
 $ETHER: 			etherif.h ../port/netif.h
+ether8003.$O ether8390.$O:	ether8390.h
 $VGA mouse.$O:			screen.h /sys/include/memdraw.h
-$SDEV:				../port/sd.h
 devfloppy.$O: 			floppy.h
 archmp.$O mp.$O:		apbootstrap.h
 apic.$O archmp.$O mp.$O:	mp.h
+$SDEV:				../port/sd.h
+sd53c8xx.$O:			sd53c8xx.i
+sdiahci.$O:			ahci.h
+devaoe.$O sdaoe.$O:		../port/aoe.h
 main.$O:			init.h reboot.h
+wavelan.$O:			wavelan.c ../pc/wavelan.c ../pc/wavelan.h
+etherwavelan.$O:		etherwavelan.c ../pc/wavelan.h
+devusb.$O usbuhci.$O usbohci.$O usbehci.$O: ../port/usb.h
 trap.$O:			/sys/include/tos.h
+uartaxp.$O:			uartaxp.i
+etherm10g.$O:			etherm10g2k.i etherm10g4k.i
 
 init.h:D:		../port/initcode.c init9.c
-	$CC $CFLAGS ../port/initcode.c
+	$CC ../port/initcode.c
 	$CC init9.c
 	$LD -l -R1 -s -o init.out init9.$O initcode.$O /386/lib/libc.a
 	{echo 'uchar initcode[]={'
@@ -125,14 +144,15 @@ apbootstrap.h:	apbootstrap.s mem.h
 		sed -e '1,2d' -e 's/^[0-9a-f]+ //' -e 's/ ([0-9a-f][0-9a-f])/0x\1,/g'
 	 echo '};'} > $target
 
+sd53c8xx.i:	sd53c8xx.n
+	aux/na $prereq > $target
 
-
-%.clean:V:
-	rm -f $stem.c [9bz]$stem [9bz]$stem.gz reboot.h apbootstrap.h init.h
-#boot$stem.* 
-
-
-
+uartaxp.i:	a100p.cp
+	{echo 'static uchar uartaxpcp[] = {'
+	 xd -1x $prereq |
+		sed -e 's/^[0-9a-f]+ //' -e '/^$/d' -e 's/ ([0-9a-f][0-9a-f])/0x\1,/g'
+	 echo '};'
+	} > $target
 
 acid:V:
 	8c -a -w -I. i8253.c>acid
@@ -153,3 +173,20 @@ acid:V:
 	}
 	exit 0
 
+checkdist:VQ:
+	for(i in pcdisk pcflop)
+	for(j in checkvga checkether)
+		mk $i.$j
+
+%.clean:V:
+	rm -f $stem.c [9bz]$stem [9bz]$stem.gz boot$stem.* reboot.h apbootstrap.h init.h
+
+# testing
+9load:D: /usr/rsc/boot/$O.load 9pcload
+	cat $prereq >$target
+
+9load.flp: 9load
+	disk/format -b /386/pbs -df $target $prereq
+
+$p$CONF.flp: /386/9load plan9.ini $p$CONF.gz
+	disk/format -b /386/pbs -df $target $prereq
Only in ./9/pc: mmu.8
Only in ./9/pc: mouse.8
Only in ./9/pc: mp.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/pc/mp.c /Volumes/Plan 9 - Dec 29/sys/src/9/pc/mp.c
--- ./9/pc/mp.c	2014-01-14 12:51:05.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/pc/mp.c	2013-06-13 14:01:42.000000000 -0700
@@ -9,8 +9,7 @@
 #include "mp.h"
 #include "apbootstrap.h"
 
-//#define dprint(...)	if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
-#define dprint if(mpdebug) print
+#define dprint(...)	if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
 
 /* from mpacpi.c */
 Apic *bootapic;
Only in ./9/pc: mpacpi.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/pc/mpacpi.c /Volumes/Plan 9 - Dec 29/sys/src/9/pc/mpacpi.c
--- ./9/pc/mpacpi.c	2014-01-14 13:06:47.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/pc/mpacpi.c	2012-08-23 16:18:02.000000000 -0700
@@ -37,8 +37,7 @@ enum {
 	Lapicae	= 1<<11,		/* apic enable in Lapicbase */
 };
 
-//#define dprint(...)	if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
-#define dprint if(mpdebug) print
+#define dprint(...)	if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)
 
 /* from mp.c */
 int	mpdebug;
Only in ./9/pc: mtrr.8
Only in ./9/pc: netif.8
Only in ./9/pc: netlog.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: nomtrr.c
Only in ./9/pc: nullmedium.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: nv_dma.h
Only in ./9/pc: page.8
Only in ./9/pc: parse.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pc
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pcauth
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pccd
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pccpu
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pccpuf
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pcdisk
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/pc/pcf /Volumes/Plan 9 - Dec 29/sys/src/9/pc/pcf
--- ./9/pc/pcf	2014-01-22 23:26:50.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/pc/pcf	2012-08-17 14:44:56.000000000 -0700
@@ -1,4 +1,4 @@
-# pcf - pc terminal with fossil root
+# pcf - pc terminal with fossil root and maybe venti block store
 dev
 	root
 	cons
@@ -11,6 +11,8 @@ dev
 	srv
 	dup
 	rtc
+	ssl
+	tls
 	cap
 	kprof
 	fs
@@ -26,66 +28,117 @@ dev
 
 	sd
 	floppy		dma
+	aoe
+	lpt
 
 	audio		dma
+	pccard
 	i82365		cis
 	uart
+	usb
 
 link
 	realmode
+	devpccard
 	devi82365
+	apm		apmjump
 
+# order of ethernet drivers should match that in ../pcboot/boot so that
+# devices are detected in the same order by bootstraps and kernels
+# and thus given the same controller numbers.
+	ether2000	ether8390
+	ether2114x	pci
+	ether589	etherelnk3
+	ether79c970	pci
+	ether8003	ether8390
+	ether8139	pci
+	ether8169	pci ethermii
+	ether82543gc	pci
+	ether82557	pci
+	ether82563	pci
+	ether83815	pci
+	etherdp83820	pci
+	etherec2t	ether8390
+	etherelnk3	pci
+	etherga620	pci
 	etherigbe	pci ethermii
+	ethervgbe	pci ethermii
+	ethervt6102	pci ethermii
+	ethervt6105m	pci ethermii
+	ethersink
+	ethersmc	devi82365 cis
+	etherwavelan	wavelan devi82365 cis pci
 
 	ethermedium
+	pcmciamodem
+	netdevmedium
 	loopbackmedium
 
+	usbuhci
+	usbohci
+	usbehci		usbehcipc
+
 misc
 	archmp		mp apic mpacpi
 	mtrr
 
 	sdata		pci sdscsi
+	sd53c8xx	pci sdscsi
+	sdmylex		pci sdscsi
+	sdiahci		pci sdscsi
+	sdaoe
 
 	uarti8250
-	vgavesa
-
 	uartpci		pci
-	uartisa
 
+	vga3dfx		+cur
+	vgaark2000pv	+cur
+	vgabt485	=cur
 	vgaclgd542x	+cur
+	vgaclgd546x	+cur
+	vgact65545	+cur
+	vgacyber938x	+cur
+	vgaet4000	+cur
+	vgahiqvideo	+cur
+	vgai81x		+cur
+	vgamach64xx	+cur
+	vgamga2164w	+cur
+	vgamga4xx	+cur
+	vganeomagic	+cur
+	vganvidia	+cur
+	vgaradeon	+cur
+	vgargb524	=cur
+	vgas3		+cur vgasavage
+	vgat2r4		+cur
+	vgatvp3020	=cur
+	vgatvp3026	=cur
+	vgavesa
+	vgavmware	+cur
 
 ip
 	tcp
 	udp
+	rudp
 	ipifc
 	icmp
 	icmp6
-
+	gre
+	ipmux
+	esp
 
 port
 	int cpuserver = 0;
 
 boot boot #S/sdC0/
+	tcp
 	local
 
-#pad: can also put the 'boot' behind sh to bypass the default boot program
 bootdir
 	boot$CONF.out boot
-	/386/bin/dossrv
-	/386/bin/mount
-#	/386/bin/sh
-#	/386/bin/disk/fdisk
-#	/386/bin/ls
-#	/386/bin/cat
-#	/386/bin/echo
-#	/386/bin/mkdir
-#	/386/bin/rm
-#	/386/bin/ramfs
-#	/386/bin/bind
-#	/386/bin/disk/prep
-#	/386/bin/fossil
-#	/386/bin/pad
-#	/386/bin/rc
-#	/386/bin/disk/format
-#	/386/bin/9660srv
-#	/386/bin/ipconfig
+	/386/bin/ip/ipconfig
+	/386/bin/auth/factotum
+	/386/bin/fossil/fossil
+	/386/bin/venti/venti
+	/386/bin/usb/usbd
+# needed to boot from a usb key and use its fossil
+	/386/bin/disk/partfs
Only in ./9/pc: pcf.8
Only in ./9/pc: pcf.c
Only in ./9/pc: pcf.root.8
Only in ./9/pc: pcf.root.s
Only in ./9/pc: pcf.rootc.8
Only in ./9/pc: pcf.rootc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pcflop
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pcfs
Only in ./9/pc: pci.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pcmciamodem.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: pcmkfile
Only in ./9/pc: pgrp.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: piix4smbus.c
Only in ./9/pc: pktmedium.8
Only in ./9/pc: plan9l.8
Only in ./9/pc: portclock.8
Only in ./9/pc: print.8
Only in ./9/pc: proc.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: psaux.c
Only in ./9/pc: ptclbsum386.8
Only in ./9/pc: qio.8
Only in ./9/pc: qlock.8
Only in ./9/pc: random.8
Only in ./9/pc: rdb.8
Only in ./9/pc: realmode.8
Only in ./9/pc: reboot.h
Only in ./9/pc: reboot.out
Only in ./9/pc: rebootcmd.8
Only in ./9/pc: rebootcode.8
Only in ./9/pc: screen.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: sd53c8xx.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: sd53c8xx.i
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: sd53c8xx.n
Only in ./9/pc: sdata.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: sdiahci.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: sdmv50xx.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: sdmylex.c
Only in ./9/pc: sdscsi.8
Only in ./9/pc: segment.8
Only in ./9/pc: swap.8
Only in ./9/pc: syscallfmt.8
Only in ./9/pc: sysfile.8
Only in ./9/pc: sysproc.8
Only in ./9/pc: taslock.8
Only in ./9/pc: tcp.8
Only in ./9/pc: tod.8
Only in ./9/pc: trap.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: uartaxp.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: uartaxp.i
Only in ./9/pc: uarti8250.8
Only in ./9/pc: uartisa.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: uartox.c
Only in ./9/pc: uartpci.8
Only in ./9/pc: udp.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: uncached.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: usbehci.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: usbehcipc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: usbohci.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: usbuhci.c
Only in ./9/pc: vga.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vga3dfx.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgaark2000pv.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgabt485.c
Only in ./9/pc: vgaclgd542x.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgaclgd546x.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgact65545.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgacyber938x.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgaet4000.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgahiqvideo.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgai81x.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgamach64xx.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgamga2164w.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgamga4xx.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vganeomagic.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vganvidia.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgaradeon.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgargb524.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgas3.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgasavage.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgat2r4.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgatvp3020.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgatvp3026.c
Only in ./9/pc: vgavesa.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: vgavmware.c
Only in ./9/pc: vgax.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: wavelan.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: wavelan.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/pc: x86watchdog.c
Only in ./9/pc: xalloc.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/9: pcboot
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: aoe.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: debugalloc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devaoe.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devbridge.c
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/port/devcap.c /Volumes/Plan 9 - Dec 29/sys/src/9/port/devcap.c
--- ./9/port/devcap.c	2014-01-15 12:55:57.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/port/devcap.c	2013-06-13 14:25:24.000000000 -0700
@@ -229,8 +229,7 @@ capwrite(Chan *c, void *va, long n, vlon
 			error(Eshort);
 		*key++ = 0;
 
-                //		hmac_sha1((uchar*)from, strlen(from), (uchar*)key, strlen(key), hash, nil);
-                panic("TODO: hmac_sha1");
+		hmac_sha1((uchar*)from, strlen(from), (uchar*)key, strlen(key), hash, nil);
 
 		p = remcap(hash);
 		if(p == nil){
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/port/devcons.c /Volumes/Plan 9 - Dec 29/sys/src/9/port/devcons.c
--- ./9/port/devcons.c	2014-01-14 17:02:02.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/port/devcons.c	2013-07-18 23:22:41.000000000 -0700
@@ -294,9 +294,9 @@ panic(char *fmt, ...)
 	prflush();
 	buf[n] = '\n';
 	putstrn(buf, n+1);
-	//dumpstack();
+	dumpstack();
 
-        //	exit(1);
+	exit(1);
 }
 
 /* libmp at least contains a few calls to sysfatal; simulate with panic */
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devflash.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devloopback.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devsdp.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devsegment.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devssl.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devtls.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: devwd.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: ecc.c
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/port/latin1.h /Volumes/Plan 9 - Dec 29/sys/src/9/port/latin1.h
--- ./9/port/latin1.h	2014-01-14 14:40:46.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/port/latin1.h	2007-07-18 14:43:05.000000000 -0700
@@ -0,0 +1,100 @@
+	" ", " i",	L"â£Ä±",
+	"!~", "-=~",	L"âââ",
+	"!", "!<=>?bmp",	L"Â¡â®â â¯â½âââ",
+	"\"*", "IUiu",	L"ÎªÎ«ÏÏ",
+	"\"", "\"AEIOUYaeiouy",	L"Â¨ÃÃÃÃÃÅ¸Ã¤Ã«Ã¯Ã¶Ã¼Ã¿",
+	"$*", "fhk",	L"ÏÏÏ°",
+	"$", "BEFHILMRVaefglopv",	L"â¬â°â±ââââ³âÆ²Éâ¯Æâââ´âÊ",
+	"\'\"", "Uu",	L"ÇÇ",
+	"\'", "\'ACEILNORSUYZacegilnorsuyz",	L"Â´ÃÄÃÃÄ¹ÅÃÅÅÃÃÅ¹Ã¡ÄÃ©Ä£Ã­ÄºÅÃ³ÅÅÃºÃ½Åº",
+	"*", "*ABCDEFGHIKLMNOPQRSTUWXYZabcdefghiklmnopqrstuwxyz",	L"âÎÎÎÎÎÎ¦ÎÎÎÎÎÎÎÎÎ Î¨Î¡Î£Î¤Î¥Î©Î§ÎÎÎ±Î²Î¾Î´ÎµÏÎ³Î¸Î¹ÎºÎ»Î¼Î½Î¿ÏÏÏÏÏÏÏÏÎ·Î¶",
+	"+", "-O",	L"Â±â",
+	",", ",ACEGIKLNORSTUacegiklnorstu",	L"Â¸ÄÃÄÄ¢Ä®Ä¶Ä»ÅÇªÅÅÅ¢Å²ÄÃ§ÄÄ£Ä¯Ä·Ä¼ÅÇ«ÅÅÅ£Å³",
+	"-*", "l",	L"Æ",
+	"-", "+-2:>DGHILOTZbdghiltuz~",	L"âÂ­Æ»Ã·âÃÇ¤Ä¦ÆÅâÅ¦ÆµÆÃ°Ç¥âÉ¨ÅÅ§ÊÆ¶â",
+	".", ".CEGILOZceglz",	L"Â·ÄÄÄ Ä°Ä¿âÅ»ÄÄÄ¡ÅÅ¼",
+	"/", "Oo",	L"ÃÃ¸",
+	"1", ".234568",	L"â¤Â½âÂ¼âââ",
+	"2", "-.35",	L"Æ»â¥ââ",
+	"3", ".458",	L"â¦Â¾ââ",
+	"4", "5",	L"â",
+	"5", "68",	L"ââ",
+	"7", "8",	L"â",
+	":", "()-=",	L"â¹âºÃ·â",
+	"<!", "=~",	L"â¨â¦",
+	"<", "-<=>~",	L"âÂ«â¤â¶â²",
+	"=", ":<=>OV",	L"âââ¡âââ",
+	">!", "=~",	L"â©â§",
+	">", "<=>~",	L"â·â¥Â»â³",
+	"?", "!?",	L"â½Â¿",
+	"@\'", "\'",	L"Ñ",
+	"@@", "\'EKSTYZekstyz",	L"ÑÐÐÐ¡Ð¢Ð«ÐÐµÐºÑÑÑÐ·",
+	"@C", "Hh",	L"Ð§Ð§",
+	"@E", "Hh",	L"Ð­Ð­",
+	"@K", "Hh",	L"Ð¥Ð¥",
+	"@S", "CHch",	L"Ð©Ð¨Ð©Ð¨",
+	"@T", "Ss",	L"Ð¦Ð¦",
+	"@Y", "AEOUaeou",	L"Ð¯ÐÐÐ®Ð¯ÐÐÐ®",
+	"@Z", "Hh",	L"ÐÐ",
+	"@c", "h",	L"Ñ",
+	"@e", "h",	L"Ñ",
+	"@k", "h",	L"Ñ",
+	"@s", "ch",	L"ÑÑ",
+	"@t", "s",	L"Ñ",
+	"@y", "aeou",	L"ÑÐµÑÑ",
+	"@z", "h",	L"Ð¶",
+	"@", "ABDFGIJLMNOPRUVXabdfgijlmnopruvx",	L"ÐÐÐÐ¤ÐÐÐÐÐÐÐÐÐ Ð£ÐÐ¥Ð°Ð±Ð´ÑÐ³Ð¸Ð¹Ð»Ð¼Ð½Ð¾Ð¿ÑÑÐ²Ñ",
+	"A", "E",	L"Ã",
+	"C", "ACU",	L"âââ",
+	"Dv", "Zz",	L"ÇÇ",
+	"D", "-e",	L"Ãâ",
+	"G", "-",	L"Ç¤",
+	"H", "-H",	L"Ä¦â",
+	"I", "-J",	L"ÆÄ²",
+	"L", "&-Jj|",	L"âÅÇÇâ",
+	"M", "#48bs",	L"â®â©âªâ­â¯",
+	"N", "JNj",	L"ÇâÇ",
+	"O", "*+-./=EIcoprx",	L"ââââââÅÆ¢Â©ââÂ®â",
+	"P", "P",	L"â",
+	"Q", "Q",	L"â",
+	"R", "R",	L"â",
+	"S", "123S",	L"Â¹Â²Â³Â§",
+	"T", "-u",	L"Å¦â¨",
+	"V", "=",	L"â",
+	"Y", "R",	L"Æ¦",
+	"Z", "-ACSZ",	L"Æµïïïâ¤",
+	"^", "ACEGHIJOSUWYaceghijosuwy",	L"ÃÄÃÄÄ¤ÃÄ´ÃÅÃÅ´Å¶Ã¢ÄÃªÄÄ¥Ã®ÄµÃ´ÅÃ»ÅµÅ·",
+	"_\"", "AUau",	L"ÇÇÇÇ",
+	"_,", "Oo",	L"Ç¬Ç­",
+	"_.", "Aa",	L"Ç Ç¡",
+	"_", "AEIOU_aeiou",	L"ÄÄÄªÅÅªÂ¯ÄÄÄ«ÅÅ«",
+	"`\"", "Uu",	L"ÇÇ",
+	"`", "AEIOUaeiou",	L"ÃÃÃÃÃÃ Ã¨Ã¬Ã²Ã¹",
+	"a", "ben",	L"âÃ¦â ",
+	"b", "()+-0123456789=bknpqru",	L"ââââââââââââââââââââââ¢",
+	"c", "$Oagu",	L"Â¢Â©â©ââª",
+	"dv", "z",	L"Ç",
+	"d", "-adegz",	L"Ã°ââ¡Â°â Ê£",
+	"e", "$lmns",	L"â¬â¯âââ",
+	"f", "a",	L"â",
+	"g", "$-r",	L"Â¤Ç¥â",
+	"h", "-v",	L"âÆ",
+	"i", "-bfjps",	L"É¨ââÄ³ââ«",
+	"l", "\"$&\'-jz|",	L"âÂ£â§âÅÇââ¨",
+	"m", "iou",	L"ÂµâÃ",
+	"n", "jo",	L"ÇÂ¬",
+	"o", "AOUaeiu",	L"ÃâÅ®Ã¥ÅÆ£Å¯",
+	"p", "Odgrt",	L"ââÂ¶ââ",
+	"r", "\"\'O",	L"ââÂ®",
+	"s", "()+-0123456789=abnoprstu",	L"â½â¾âºâ»â°â±â²â³â´âµâ¶â·â¸â¹â¼Âªââ¿ÂºââÃââ",
+	"t", "-efmsu",	L"Å§ââ´â¢Ïâ¢",
+	"u", "-AEGIOUaegiou",	L"ÊÄÄÄÄ¬ÅÅ¬âÄÄÄ­ÅÅ­",
+	"v\"", "Uu",	L"ÇÇ",
+	"v", "ACDEGIKLNORSTUZacdegijklnorstuz",	L"ÇÄÄÄÇ¦ÇÇ¨Ä½ÅÇÅÅ Å¤ÇÅ½ÇÄÄÄÇ§ÇÇ°Ç©Ä¾ÅÇÅÅ¡Å¥ÇÅ¾",
+	"w", "bknpqr",	L"ââââââ",
+	"x", "O",	L"â",
+	"y", "$",	L"Â¥",
+	"z", "-",	L"Æ¶",
+	"|", "Pp|",	L"ÃÃ¾Â¦",
+	"~!", "=",	L"â",
+	"~", "-=AINOUainou~",	L"ââÃÄ¨ÃÃÅ¨Ã£Ä©Ã±ÃµÅ©â",
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: log.c
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/port/mkroot /Volumes/Plan 9 - Dec 29/sys/src/9/port/mkroot
--- ./9/port/mkroot	2014-01-14 13:12:58.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/port/mkroot	2002-12-12 20:22:14.000000000 -0800
@@ -11,5 +11,5 @@ cp $1 $2.out
 t=`{file $2.out}
 if(~ $"t *executable*)
 	strip $2.out
-data2s $2 < $2.out > $2.root.s
+aux/data2s $2 < $2.out > $2.root.s
 echo mkroot $* done
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/port/mkrootall /Volumes/Plan 9 - Dec 29/sys/src/9/port/mkrootall
--- ./9/port/mkrootall	2014-01-14 13:13:28.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/port/mkrootall	2007-10-03 09:55:40.000000000 -0700
@@ -26,6 +26,6 @@ while(! ~ $#* 0){
 	# do not strip venti - it uses its own symbols
 	if(~ $"t *executable* && ! ~ $name venti)
 		strip $tmp
-	data2s $cname < $tmp
+	aux/data2s $cname < $tmp
 }
 exit 0
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: nandecc.h
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./9/port/portmkfile /Volumes/Plan 9 - Dec 29/sys/src/9/port/portmkfile
--- ./9/port/portmkfile	2014-01-15 11:49:29.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/9/port/portmkfile	2013-02-13 12:18:57.000000000 -0800
@@ -1,5 +1,3 @@
-MKSHELL=$PLAN9/bin/rc
-
 PORTFILES=`{../port/mkfilelist ../port}
 ^($PORTFILES)\.$O:R:	'../port/\1.c'
 	$CC $CFLAGS -I. ../port/$stem1.c
@@ -14,6 +12,15 @@ IPFILES=`{../port/mkfilelist ../ip}
 %.$O:	%.c
 	$CC $CFLAGS $stem.c
 
+%.acid:	%.c
+	$CC $CFLAGS -a $stem.c >$stem.acid
+
+%.acid:	../ip/%.c
+	$CC $CFLAGS -a -I.  ../ip/$stem.c >$stem.acid
+
+%.acid:	../port/%.c
+	$CC $CFLAGS -a -I. ../port/$stem.c >$stem.acid
+
 installall:V:
 	for(i in $CONFLIST)
 		mk 'CONF='$i install
@@ -23,8 +30,8 @@ all:V:
 		mk 'CONF='$i
 
 clean:V:
-	rm -f *.[$OS] *.root.s *.rootc.c init.h conf.h reboot.h reboot.list *.out *.m errstr.h
-	for(i in $CONFLIST)
+	rm -f *.[$OS] *.root.s *.rootc.c cfs.h fs.h init.h conf.h reboot.h reboot.list *.out *.m errstr.h
+	for(i in $CONFLIST $CRAPLIST)
 		mk $i.clean
 
 %.clean:V:
@@ -55,9 +60,7 @@ errstr.h:	../port/mkerrstr ../port/error
 	rc ../port/mkerrstr > errstr.h
 
 ../port/latin1.h:	/lib/keyboard
-	#mklatinkbd /lib/keyboard > ../port/latin1.h
-        touch ../port/latin1.h
-
+	aux/mklatinkbd /lib/keyboard > ../port/latin1.h
 
 %.db:		main.$O
 	$CC -s$stem main.c | dbfmt > $stem.db
@@ -90,14 +93,5 @@ devproc.$O edf.$O proc.$O: /sys/include/
 boot$CONF.out: $CONF print.$O $BOOTDIR/boot.c $BOOTLIB
 	$BOOTDIR/mkboot $CONF > boot$CONF.c
 	$CC $CFLAGS boot$CONF.c
-	$LD -o boot$CONF.out boot$CONF.$O $BOOTLIB
-
-%.acid:	%.c
-	$CC $CFLAGS -a $stem.c >$stem.acid
-
-%.acid:	../ip/%.c
-	$CC $CFLAGS -a -I.  ../ip/$stem.c >$stem.acid
-
-%.acid:	../port/%.c
-	$CC $CFLAGS -a -I. ../port/$stem.c >$stem.acid
-
+	$CC $CFLAGS ../boot/printstub.c
+	$LD -o boot$CONF.out boot$CONF.$O $BOOTLIB printstub.$O
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: portusbehci.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: sdaoe.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: thwack.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: thwack.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: ucalloc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: ucallocb.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: unthwack.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: usb.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/9/port: usbehci.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/9: ppc
Only in /Volumes/Plan 9 - Dec 29/sys/src/9: rb
Only in /Volumes/Plan 9 - Dec 29/sys/src/9: teg2
Only in .: Makefile
Only in .: PFFF_DB.marshall
Only in .: TAGS
Only in /Volumes/Plan 9 - Dec 29/sys/src/: ape
Only in /Volumes/Plan 9 - Dec 29/sys/src/boot/pc: pbsdebug.s
Only in /Volumes/Plan 9 - Dec 29/sys/src/boot/pc: pbslba.s
Only in /Volumes/Plan 9 - Dec 29/sys/src/boot/pc: pbslbadebug.s
Only in /Volumes/Plan 9 - Dec 29/sys/src/boot/pc: pbsraw.s
Only in ./cmd/5a: 8.out
Only in ./cmd/5a: lex.8
Only in ./cmd/5a: y.debug
Only in ./cmd/5a: y.tab.8
Only in ./cmd/5a: y.tab.c
Only in ./cmd/5a: y.tab.h
Only in ./cmd/5c: 8.out
Only in ./cmd/5c: cgen.8
Only in ./cmd/5c: enam.8
Only in ./cmd/5c: list.8
Only in ./cmd/5c: mul.8
Only in ./cmd/5c: peep.8
Only in ./cmd/5c: pgen.8
Only in ./cmd/5c: pswt.8
Only in ./cmd/5c: reg.8
Only in ./cmd/5c: sgen.8
Only in ./cmd/5c: swt.8
Only in ./cmd/5c: txt.8
Only in ./cmd/5i: 5i.8
Only in ./cmd/5i: 8.out
Only in ./cmd/5i: bpt.8
Only in ./cmd/5i: cmd.8
Only in ./cmd/5i: icache.8
Only in ./cmd/5i: mem.8
Only in ./cmd/5i: run.8
Only in ./cmd/5i: stats.8
Only in ./cmd/5i: symbols.8
Only in ./cmd/5i: syscall.8
Only in ./cmd/5l: 8.out
Only in ./cmd/5l: asm.8
Only in ./cmd/5l: compat.8
Only in ./cmd/5l: elf.8
Only in ./cmd/5l: enam.8
Only in ./cmd/5l: list.8
Only in ./cmd/5l: noop.8
Only in ./cmd/5l: obj.8
Only in ./cmd/5l: optab.8
Only in ./cmd/5l: pass.8
Only in ./cmd/5l: span.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: 6a
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: 6c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: 6l
Only in ./cmd: 8._cp
Only in ./cmd: 8.ar
Only in ./cmd: 8.basename
Only in ./cmd: 8.bind
Only in ./cmd: 8.cal
Only in ./cmd: 8.calls
Only in ./cmd: 8.cat
Only in ./cmd: 8.chgrp
Only in ./cmd: 8.chmod
Only in ./cmd: 8.clock
Only in ./cmd: 8.colors
Only in ./cmd: 8.cp
Only in ./cmd: 8.date
Only in ./cmd: 8.dd
Only in ./cmd: 8.du
Only in ./cmd: 8.echo
Only in ./cmd: 8.file
Only in ./cmd: 8.hget
Only in ./cmd: 8.iconv
Only in ./cmd: 8.init
Only in ./cmd: 8.kbmap
Only in ./cmd: 8.kprof
Only in ./cmd: 8.ktrace
Only in ./cmd: 8.lens
Only in ./cmd: 8.life
Only in ./cmd: 8.ls
Only in ./cmd: 8.mc
Only in ./cmd: 8.mkdir
Only in ./cmd: 8.mntgen
Only in ./cmd: 8.mount
Only in ./cmd: 8.mtime
Only in ./cmd: 8.mug
Only in ./cmd: 8.mv
Only in ./cmd: 8.netstat
Only in ./cmd: 8.nm
Only in ./cmd: 8.ns
Only in ./cmd: 8.p
Only in ./cmd: 8.prof
Only in ./cmd: 8.ps
Only in ./cmd: 8.pstree
Only in ./cmd: 8.pwd
Only in ./cmd: 8.ramfs
Only in ./cmd: 8.ratrace
Only in ./cmd: 8.rm
Only in ./cmd: 8.rx
Only in ./cmd: 8.screenlock
Only in ./cmd: 8.sed
Only in ./cmd: 8.sh
Only in ./cmd: 8.size
Only in ./cmd: 8.sleep
Only in ./cmd: 8.sort
Only in ./cmd: 8.stats
Only in ./cmd: 8.strings
Only in ./cmd: 8.strip
Only in ./cmd: 8.swap
Only in ./cmd: 8.tail
Only in ./cmd: 8.tar
Only in ./cmd: 8.tee
Only in ./cmd: 8.test
Only in ./cmd: 8.test_pad
Only in ./cmd: 8.time
Only in ./cmd: 8.touch
Only in ./cmd: 8.tprof
Only in ./cmd: 8.tr
Only in ./cmd: 8.trace
Only in ./cmd: 8.unicode
Only in ./cmd: 8.uniq
Only in ./cmd: 8.unmount
Only in ./cmd: 8.wc
Only in ./cmd: 8.winwatch
Only in ./cmd: 8.xargs
Only in ./cmd: 8.xd
Only in ./cmd: 8.yacc
Only in ./cmd/8a: 8.out
Only in ./cmd/8a: lex.8
Only in ./cmd/8a: y.debug
Only in ./cmd/8a: y.tab.8
Only in ./cmd/8a: y.tab.c
Only in ./cmd/8a: y.tab.h
Only in ./cmd/8c: 8.out
Only in ./cmd/8c: cgen.8
Only in ./cmd/8c: cgen64.8
Only in ./cmd/8c: div.8
Only in ./cmd/8c: enam.8
Only in ./cmd/8c: list.8
Only in ./cmd/8c: machcap.8
Only in ./cmd/8c: mul.8
Only in ./cmd/8c: peep.8
Only in ./cmd/8c: pgen.8
Only in ./cmd/8c: pswt.8
Only in ./cmd/8c: reg.8
Only in ./cmd/8c: sgen.8
Only in ./cmd/8c: swt.8
Only in ./cmd/8c: txt.8
Only in ./cmd/8l: 8.out
Only in ./cmd/8l: asm.8
Only in ./cmd/8l: compat.8
Only in ./cmd/8l: elf.8
Only in ./cmd/8l: enam.8
Only in ./cmd/8l: list.8
Only in ./cmd/8l: obj.8
Only in ./cmd/8l: optab.8
Only in ./cmd/8l: pass.8
Only in ./cmd/8l: span.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: 9660srv
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: 9nfs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: aan.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: abaco
Only in ./cmd/acid: 8.out
Only in ./cmd/acid: builtin.8
Only in ./cmd/acid: dot.8
Only in ./cmd/acid: exec.8
Only in ./cmd/acid: expr.8
Only in ./cmd/acid: lex.8
Only in ./cmd/acid: list.8
Only in ./cmd/acid: main.8
Only in ./cmd/acid: print.8
Only in ./cmd/acid: proc.8
Only in ./cmd/acid: util.8
Only in ./cmd/acid: y.tab.8
Only in ./cmd/acid: y.tab.c
Only in ./cmd/acid: y.tab.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: acme
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: aquarela
Only in ./cmd: ar.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: archfs.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ascii.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: astro
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: auth
Only in ./cmd/aux: 8.data2s
Only in ./cmd/aux: 8.mouse
Only in ./cmd/aux: 8.reboot
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: 8prefix.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: 9pcon.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: accupoint.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: acidleak.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: antiword
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: apm.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: astarld.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: cddb.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: clog.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: consolefs.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: conswdir.c
Only in ./cmd/aux: data2s.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: depend.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: disksim.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: flashfs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: getflags.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: gps
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: lines.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: lis
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: listen.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: listen1.c
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/aux/mkfile /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/mkfile
--- ./cmd/aux/mkfile	2014-01-19 12:03:15.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/mkfile	2012-08-16 15:50:45.000000000 -0700
@@ -1,13 +1,42 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
-#TODO: consolefs? depend? mouse? reboot? searchfs? statusbar
-#LESS: mklatinkbd
 TARG=\
+	8prefix\
+	9pcon\
+	accupoint\
+	acidleak\
+	apm\
+	astarld\
+	cddb\
+	clog\
+	consolefs\
 	data2s\
-	reboot\
+	depend\
+	disksim\
+	getflags\
+	lines\
+	listen\
+	listen1\
+	mklatinkbd\
+	ms2\
+	msexceltables\
+	mswordstrings\
         mouse\
+	nfsmount\
+	olefs\
+	pcmcia\
+	portmap\
+	rdwr\
+	reboot\
+	searchfs\
+	statusbar\
+	stub\
+	timesync\
+	trampoline\
+	usage\
+	watchdog\
+	write\
+	zerotrunc\
 
 BIN=/$objtype/bin/aux
 
@@ -19,13 +48,17 @@ UPDATE=\
 
 </sys/src/cmd/mkmany
 
-DIRS=vga\
+DIRS=mnihongo\
+	flashfs\
+	gps\
+	na\
+	vga
 
 all:V:	$DIRS
 
 $DIRS:V:
 	for (i in $DIRS) @{
-		echo DIR: cmd/aux/$i
+		echo mk $i
 		cd $i
 		mk all
 	}
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: mklatinkbd.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: mnihongo
Only in ./cmd/aux: mouse.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: ms2.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: msexceltables.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: mswordstrings.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: na
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: nfsmount.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: olefs.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: pcmcia.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: portmap.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: rdwr.c
Only in ./cmd/aux: reboot.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: searchfs.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: stub.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: timesync.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: trampoline.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: unlock
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: usage.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: 3dfx.c
Only in ./cmd/aux/vga: 8.out
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: ark2000pv.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: att20c49x.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: att21c498.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: bt485.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: ch9294.c
Only in ./cmd/aux/vga: clgd542x.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: clgd546x.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: ct65540.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: cyber938x.c
Only in ./cmd/aux/vga: data.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/aux/vga/data.c /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga/data.c
--- ./cmd/aux/vga/data.c	2014-01-22 22:28:00.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga/data.c	2010-01-19 13:07:59.000000000 -0800
@@ -9,11 +9,82 @@ int cflag;					/* do not use hwgc */
 int dflag;					/* do the palette */
 
 Ctlr* ctlrs[] = {
+	&ark2000pv,				/* ctlr */
+	&ark2000pvhwgc,				/* hwgc */
+	&att20c490,				/* ramdac */
+	&att20c491,				/* ramdac */
+	&att20c492,				/* ramdac */
+	&att21c498,				/* ramdac */
+	&bt485,					/* ramdac */
+	&bt485hwgc,				/* hwgc */
+	&ch9294,				/* clock */
 	&clgd542x,				/* ctlr */
 	&clgd542xhwgc,				/* hwgc */
+	&clgd546x,				/* ctlr */
+	&clgd546xhwgc,				/* hwgc */
+	&ct65540,				/* ctlr */
+	&ct65545,				/* ctlr */
+	&ct65545hwgc,				/* hwgc */
+	&cyber938x,				/* ctlr */
+	&cyber938xhwgc,				/* hwgc */
+	&et4000,				/* ctlr */
+	&et4000hwgc,				/* hwgc */
 	&generic,				/* ctlr */
+	&hiqvideo,				/* ctlr */
+	&hiqvideohwgc,				/* hwgc */
+	&i81x,				/* ctlr */
+	&i81xhwgc,				/* hwgc */
+	&ibm8514,				/* ctlr */
+	&icd2061a,				/* clock */
+	&ics2494,				/* clock */
+	&ics2494a,				/* clock */
+	&ics534x,				/* gendac */
+	&mach32,				/* ctlr */
+	&mach64,				/* ctlr */
+	&mach64xx,				/* ctlr */
+	&mach64xxhwgc,				/* hwgc */
+	&mga2164w,				/* ctlr */
+	&mga2164whwgc,				/* hwgc */
+	&neomagic,				/* ctlr */
+	&neomagichwgc,				/* hwgc */
+	&nvidia,				/* ctlr */
+	&nvidiahwgc,				/* hwgc */
+	&radeon,				/* ctlr */
+	&radeonhwgc,				/* hwgc */
 	&palette,				/* ctlr */
+	&rgb524,				/* ramdac */
+	&rgb524hwgc,				/* hwgc */
+	&rgb524mn,				/* ramdac */
+	&s3801,					/* ctlr */
+	&s3805,					/* ctlr */
+	&s3928,					/* ctlr */
+	&s3clock,				/* clock */
+	&s3hwgc,				/* hwgc */
+	&sc15025,				/* ramdac */
+	&softhwgc,				/* hwgc */
+	&stg1702,				/* ramdac */
+	&t2r4,					/* ctlr */
+	&t2r4hwgc,				/* hwgc */
+	&tdfx,					/* ctlr */
+	&tdfxhwgc,				/* hwgc */
+	&trio64,				/* ctlr */
+	&tvp3020,				/* ramdac */
+	&tvp3020hwgc,				/* hwgc */
+	&tvp3025,				/* ramdac */
+	&tvp3025clock,				/* clock */
+	&tvp3026,				/* ramdac */
+	&tvp3026clock,				/* clock */
+	&tvp3026hwgc,				/* hwgc */
 	&vesa,					/* ctlr */
+	&virge,					/* ctlr */
+	&vision864,				/* ctlr */
+	&vision964,				/* ctlr */
+	&vision968,				/* ctlr */
+	&vmware,				/* ctlr */
+	&vmwarehwgc,				/* hwgc */
+	&w30c516,				/* ctlr */
+	&mga4xx,
+	&mga4xxhwgc,
 	0,
 };
 
Only in ./cmd/aux/vga: db.8
Only in ./cmd/aux/vga: error.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: et4000.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: et4000hwgc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: hiqvideo.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: i81x.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: ibm8514.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: icd2061a.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: ics2494.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: ics534x.c
Only in ./cmd/aux/vga: io.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: mach32.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: mach64.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: mach64xx.c
Only in ./cmd/aux/vga: main.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: mga2164w.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: mga4xx.c
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/aux/vga/mkfile /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga/mkfile
--- ./cmd/aux/vga/mkfile	2014-01-22 22:24:53.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga/mkfile	2010-01-19 13:07:59.000000000 -0800
@@ -3,17 +3,64 @@ BIN=/$objtype/bin/aux
 
 TARG=vga
 OFILES=\
+	3dfx.$O\
+	ark2000pv.$O\
+	att20c49x.$O\
+	att21c498.$O\
+	bt485.$O\
+	ch9294.$O\
 	clgd542x.$O\
+	clgd546x.$O\
+	ct65540.$O\
+	cyber938x.$O\
 	data.$O\
 	db.$O\
 	error.$O\
+	et4000.$O\
+	et4000hwgc.$O\
+	hiqvideo.$O\
+	i81x.$O\
+	ibm8514.$O\
+	icd2061a.$O\
+	ics2494.$O\
+	ics534x.$O\
 	io.$O\
+	mach32.$O\
+	mach64.$O\
+	mach64xx.$O\
 	main.$O\
+	mga2164w.$O\
+	mga4xx.$O\
+	neomagic.$O\
+	nvidia.$O\
+	radeon.$O\
 	palette.$O\
 	pci.$O\
+	rgb524.$O\
+	rgb524mn.$O\
+	s3801.$O\
+	s3928.$O\
+	s3clock.$O\
+	s3generic.$O\
+	s3hwgc.$O\
+	sc15025.$O\
+	stg1702.$O\
+	t2r4.$O\
+	trio64.$O\
+	tvp3020.$O\
+	tvp3025.$O\
+	tvp3025clock.$O\
+	tvp3026.$O\
+	tvp3026clock.$O\
 	vesa.$O\
 	vesadb.$O\
 	vga.$O\
+	virge.$O\
+	vision864.$O\
+	vision964.$O\
+	vision968.$O\
+	vmware.$O\
+	w30c516.$O\
 
 HFILES=\
 	pci.h\
@@ -29,3 +76,4 @@ UPDATE=\
 
 </sys/src/cmd/mkone
 
+nvidia.$O:	riva_tbl.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: neomagic.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: nvidia.c
Only in ./cmd/aux/vga: palette.8
Only in ./cmd/aux/vga: pci.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: radeon.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: radeon.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: rgb524.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: rgb524mn.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: riva_tbl.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: s3801.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: s3928.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: s3clock.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: s3generic.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: s3hwgc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: sc15025.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: stg1702.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: t2r4.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: trio64.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: tvp3020.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: tvp3025.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: tvp3025clock.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: tvp3026.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: tvp3026clock.c
Only in ./cmd/aux/vga: vesa.8
Only in ./cmd/aux/vga: vesadb.8
Only in ./cmd/aux/vga: vga.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/aux/vga/vga.h /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga/vga.h
--- ./cmd/aux/vga/vga.h	2014-01-22 22:27:09.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga/vga.h	2010-01-19 13:07:59.000000000 -0800
@@ -196,11 +196,50 @@ typedef struct Vga {
 	void*	private;
 } Vga;
 
+/* 3dfx.c */
+extern Ctlr tdfx;
+extern Ctlr tdfxhwgc;
+
+/* ark2000pv.c */
+extern Ctlr ark2000pv;
+extern Ctlr ark2000pvhwgc;
+
+/* att20c49x.c */
+extern Ctlr att20c490;
+extern Ctlr att20c491;
+extern Ctlr att20c492;
+
+/* att21c498.c */
+extern uchar attdaci(uchar);
+extern void attdaco(uchar, uchar);
+extern Ctlr att21c498;
+
+/* bt485.c */
+extern uchar bt485i(uchar);
+extern void bt485o(uchar, uchar);
+extern Ctlr bt485;
+
+/* ch9294.c */
+extern Ctlr ch9294;
+
 /* clgd542x.c */
 extern void clgd54xxclock(Vga*, Ctlr*);
 extern Ctlr clgd542x;
 extern Ctlr clgd542xhwgc;
 
+/* clgd546x.c */
+extern Ctlr clgd546x;
+extern Ctlr clgd546xhwgc;
+
+/* ct65540.c */
+extern Ctlr ct65540;
+extern Ctlr ct65545;
+extern Ctlr ct65545hwgc;
+
+/* cyber938x.c */
+extern Ctlr cyber938x;
+extern Ctlr cyber938xhwgc;
+
 /* data.c */
 extern int cflag;
 extern int dflag;
@@ -218,6 +257,32 @@ extern void error(char*, ...);
 extern void trace(char*, ...);
 extern int vflag, Vflag;
 
+/* et4000.c */
+extern Ctlr et4000;
+
+/* et4000hwgc.c */
+extern Ctlr et4000hwgc;
+
+/* hiqvideo.c */
+extern Ctlr hiqvideo;
+extern Ctlr hiqvideohwgc;
+
+/* i81x.c */
+extern Ctlr i81x;
+extern Ctlr i81xhwgc;
+
+/* ibm8514.c */
+extern Ctlr ibm8514;
+
+/* icd2061a.c */
+extern Ctlr icd2061a;
+
+/* ics2494.c */
+extern Ctlr ics2494;
+extern Ctlr ics2494a;
+
+/* ics534x.c */
+extern Ctlr ics534x;
 
 /* io.c */
 extern uchar inportb(long);
@@ -238,6 +303,16 @@ extern void printflag(ulong);
 extern void setpalette(int, int, int, int);
 extern int curprintindex;
 
+/* mach32.c */
+extern Ctlr mach32;
+
+/* mach64.c */
+extern Ctlr mach64;
+
+/* mach64xx.c */
+extern Ctlr mach64xx;
+extern Ctlr mach64xxhwgc;
+
 /* main.c */
 extern char* chanstr[];
 extern void resyncinit(Vga*, Ctlr*, ulong, ulong);
@@ -245,6 +320,22 @@ extern void sequencer(Vga*, int);
 extern void main(int, char*[]);
 Biobuf stdout;
 
+/* mga2164w.c */
+extern Ctlr mga2164w;
+extern Ctlr mga2164whwgc;
+
+/* neomagic.c */
+extern Ctlr neomagic;
+extern Ctlr neomagichwgc;
+
+/* nvidia.c */
+extern Ctlr nvidia;
+extern Ctlr nvidiahwgc;
+
+/* radeon.c */
+extern Ctlr radeon;
+extern Ctlr radeonhwgc;
+
 /* palette.c */
 extern Ctlr palette;
 
@@ -260,6 +351,68 @@ extern void pcicfgw32(Pcidev*, int, int)
 extern void pcihinv(Pcidev*);
 extern Pcidev* pcimatch(Pcidev*, int, int);
 
+/* rgb524.c */
+extern Ctlr rgb524;
+
+/* rgb524mn.c */
+extern uchar (*rgb524mnxi)(Vga*, int);
+extern void (*rgb524mnxo)(Vga*, int, uchar);
+extern Ctlr rgb524mn;
+
+/* s3801.c */
+extern Ctlr s3801;
+extern Ctlr s3805;
+
+/* s3928.c */
+extern Ctlr s3928;
+
+/* s3clock.c */
+extern Ctlr s3clock;
+
+/* s3generic.c */
+extern Ctlr s3generic;
+
+/* s3hwgc.c */
+extern Ctlr bt485hwgc;
+extern Ctlr rgb524hwgc;
+extern Ctlr s3hwgc;
+extern Ctlr tvp3020hwgc;
+extern Ctlr tvp3026hwgc;
+
+/* sc15025.c */
+extern Ctlr sc15025;
+
+/* stg1702.c */
+extern Ctlr stg1702;
+
+/* t2r4.c */
+extern Ctlr t2r4;
+extern Ctlr t2r4hwgc;
+
+/* trio64.c */
+extern void trio64clock(Vga*, Ctlr*);
+extern Ctlr trio64;
+
+/* tvp3020.c */
+extern uchar tvp3020i(uchar);
+extern uchar tvp3020xi(uchar);
+extern void tvp3020o(uchar, uchar);
+extern void tvp3020xo(uchar, uchar);
+extern Ctlr tvp3020;
+
+/* tvp3025.c */
+extern Ctlr tvp3025;
+
+/* tvp3025clock.c */
+extern Ctlr tvp3025clock;
+
+/* tvp3026.c */
+extern uchar tvp3026xi(uchar);
+extern void tvp3026xo(uchar, uchar);
+extern Ctlr tvp3026;
+
+/* tvp3026clock.c */
+extern Ctlr tvp3026clock;
 
 /* vga.c */
 extern uchar vgai(long);
@@ -275,5 +428,28 @@ extern int dbvesa(Vga*);
 extern Mode *dbvesamode(char*);
 extern void vesatextmode(void);
 
+/* virge.c */
+extern Ctlr virge;
+
+/* vision864.c */
+extern Ctlr vision864;
+
+/* vision964.c */
+extern Ctlr vision964;
+
+/* vision968.c */
+extern Ctlr vision968;
+
+/* vmware.c */
+extern Ctlr vmware;
+extern Ctlr vmwarehwgc;
+
+/* w30c516.c */
+extern Ctlr w30c516;
+
+/* mga4xx.c */
+extern Ctlr mga4xx;
+extern Ctlr mga4xxhwgc;
+
 #pragma	varargck	argpos	error	1
 #pragma	varargck	argpos	trace	1
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: virge.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: vision864.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: vision964.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: vision968.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: vmware.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux/vga: w30c516.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: watchdog.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: write.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/aux: zerotrunc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: awd.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: awk
Only in ./cmd: basename.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: bc.y
Only in ./cmd: bind.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: bsplit.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: bzip2
Only in ./cmd: cal.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: calendar.c
Only in ./cmd: calls.8
Only in ./cmd: cat.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cb
Only in ./cmd/cc: acid.8
Only in ./cmd/cc: bits.8
Only in ./cmd/cc: cc.a8
Only in ./cmd/cc: com.8
Only in ./cmd/cc: com64.8
Only in ./cmd/cc: compat.8
Only in ./cmd/cc: dcl.8
Only in ./cmd/cc: dpchk.8
Only in ./cmd/cc: funct.8
Only in ./cmd/cc: lex.8
Only in ./cmd/cc: mac.8
Only in ./cmd/cc: omachcap.8
Only in ./cmd/cc: pickle.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/cc/pswt.c /Volumes/Plan 9 - Dec 29/sys/src/cmd/cc/pswt.c
--- ./cmd/cc/pswt.c	2014-01-16 22:49:50.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/cc/pswt.c	2013-04-23 16:19:31.000000000 -0700
@@ -110,14 +110,14 @@ doswit(Node *n)
 			q++;
 		}
 		qsort(iql,  q-iql, sizeof(C1), swcmp);
-                //if(0){for(int k=0; k<(q-iql); k++)print("nh=%ld k=%d h=%#llux l=%#llux lab=%ld\n", nh, k, (vlong)iqh[nh].val,  (vlong)iql[k].val, iql[k].label);}
+if(0){for(int k=0; k<(q-iql); k++)print("nh=%ld k=%d h=%#llux l=%#llux lab=%ld\n", nh, k, (vlong)iqh[nh].val,  (vlong)iql[k].val, iql[k].label);}
 		iqh[nh].label = pc;
 		nh++;
 		swit1(iql, q-iql, def, vr[0]);
 		i = j;
 	}
 	patch(hsb, pc);
-        //if(0){for(int k=0; k<nh; k++)print("k*=%d h=%#llux lab=%ld\n", k, (vlong)iqh[k].val,  iqh[k].label);}
+if(0){for(int k=0; k<nh; k++)print("k*=%d h=%#llux lab=%ld\n", k, (vlong)iqh[k].val,  iqh[k].label);}
 	swit1(iqh, nh, def, vr[1]);
 }
 
Only in ./cmd/cc: scon.8
Only in ./cmd/cc: sub.8
Only in ./cmd/cc: y.tab.8
Only in ./cmd/cc: y.tab.c
Only in ./cmd/cc: y.tab.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cdfs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cec
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cfs
Only in ./cmd: chgrp.8
Only in ./cmd: chmod.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cifs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cleanname.c
Only in ./cmd: clock.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cmp.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: col.c
Only in ./cmd: colors.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: comm.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: compress
Only in ./cmd/con: 8.con
Only in ./cmd/con: 8.hayes
Only in ./cmd/con: 8.xmr
Only in ./cmd/con: 8.xms
Only in ./cmd/con: con.8
Only in ./cmd/con: hayes.8
Only in ./cmd/con: xmr.8
Only in ./cmd/con: xms.8
Only in ./cmd: cp.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cpp
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cpu.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: crop.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: cwfs
Only in ./cmd: date.8
Only in ./cmd/db: 8.out
Only in ./cmd/db: command.8
Only in ./cmd/db: expr.8
Only in ./cmd/db: format.8
Only in ./cmd/db: input.8
Only in ./cmd/db: main.8
Only in ./cmd/db: output.8
Only in ./cmd/db: pcs.8
Only in ./cmd/db: print.8
Only in ./cmd/db: regs.8
Only in ./cmd/db: runpcs.8
Only in ./cmd/db: setup.8
Only in ./cmd/db: trcrun.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: dc.c
Only in ./cmd: dd.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: deroff.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: dial
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: dict
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: diff
Only in ./cmd/disk: 8.format
Only in ./cmd/disk: 8.mbr
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk: 9660
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk: exsort.c
Only in ./cmd/disk: format.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk: kfs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk: kfscmd.c
Only in ./cmd/disk: mbr.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk: mkext.c
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/disk/mkfile /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk/mkfile
--- ./cmd/disk/mkfile	2014-01-19 11:51:25.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk/mkfile	2012-06-15 14:48:50.000000000 -0700
@@ -1,11 +1,16 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
-TARG=	format\
+TARG=exsort\
+	format\
+	kfscmd\
 	mbr\
+	mkext\
+	mkfs\
+	partfs\
 
 DIRS=\
+	9660\
+	kfs\
 	prep\
 
 OFILES=
@@ -23,7 +28,7 @@ UPDATE=\
 
 all:V:	all-kfs
 
-install:V:	install-kfs
+install:V:	install-kfs ksync
 
 clean:V:	clean-kfs
 
@@ -34,9 +39,10 @@ installall:V:	installall-kfs
 %-kfs:V:
 	for(i in $DIRS) @{
 		cd $i
-                echo DIR: cmd/disk/$i
 		mk $MKFLAGS $stem
 	}
-        echo DIR: cmd/disk
+
+ksync:
+	touch $BIN/ksync
 
 $O.format: /$objtype/lib/libdisk.a
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk: mkfs.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk: partfs.c
Only in ./cmd/disk/prep: 8.fdisk
Only in ./cmd/disk/prep: 8.prep
Only in ./cmd/disk/prep: edit.8
Only in ./cmd/disk/prep: fdisk.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/disk/prep/mkfile /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk/prep/mkfile
--- ./cmd/disk/prep/mkfile	2014-01-17 12:25:59.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk/prep/mkfile	2002-05-26 14:56:40.000000000 -0700
@@ -1,5 +1,3 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
 TARG=fdisk prep
Only in ./cmd/disk/prep: prep.8
Only in ./cmd/disk/prep: y.tab.8
Only in ./cmd/disk/prep: y.tab.c
Only in ./cmd/disk/prep: y.tab.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd/disk: rd9660.c
Only in ./cmd/dossrv: 8.out
Only in ./cmd/dossrv: chat.8
Only in ./cmd/dossrv: devio.8
Only in ./cmd/dossrv: dosfs.8
Only in ./cmd/dossrv: dossubs.8
Only in ./cmd/dossrv: iotrack.8
Only in ./cmd/dossrv: lock.8
Only in ./cmd/dossrv: xfile.8
Only in ./cmd/dossrv: xfssrv.8
Only in ./cmd: du.8
Only in ./cmd: echo.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ecp.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ed.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: eqn
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: execnet
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: exportfs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ext2srv
Only in ./cmd/faces: 8.out
Only in ./cmd/faces: facedb.8
Only in ./cmd/faces: main.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/faces/mkfile /Volumes/Plan 9 - Dec 29/sys/src/cmd/faces/mkfile
--- ./cmd/faces/mkfile	2014-01-25 17:34:42.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/faces/mkfile	2003-09-01 16:51:02.000000000 -0700
@@ -1,7 +1,7 @@
 </$objtype/mkfile
 
 # default domain for faces, overridden by $facedom
-DEFAULT="pad"
+DEFAULT="astro"
 
 TARG=faces
 
Only in ./cmd/faces: plumb.8
Only in ./cmd/faces: util.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: factor.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: fax
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: fcp.c
Only in ./cmd: file.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: fmt.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: fortune.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: fossil
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: freq.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: getmap.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: grap
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: graph
Only in ./cmd/grep: 8.out
Only in ./cmd/grep: comp.8
Only in ./cmd/grep: main.8
Only in ./cmd/grep: sub.8
Only in ./cmd/grep: y.tab.8
Only in ./cmd/grep: y.tab.c
Only in ./cmd/grep: y.tab.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: gs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: gview.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: gzip
Only in ./cmd: hget.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: histogram.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: history.c
Only in ./cmd/hoc: 8.out
Only in ./cmd/hoc: code.8
Only in ./cmd/hoc: init.8
Only in ./cmd/hoc: math.8
Only in ./cmd/hoc: symbol.8
Only in ./cmd/hoc: y.tab.8
Only in ./cmd/hoc: y.tab.c
Only in ./cmd/hoc: y.tab.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: html2ms.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: htmlfmt
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: htmlroff
Only in ./cmd: iconv.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: idiff.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: import.c
Only in ./cmd: init.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/init.c /Volumes/Plan 9 - Dec 29/sys/src/cmd/init.c
--- ./cmd/init.c	2014-01-20 18:34:56.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/init.c	2011-06-14 11:16:12.000000000 -0700
@@ -1,7 +1,7 @@
 #include <u.h>
 #include <libc.h>
 #include <auth.h>
-//#include <authsrv.h>
+#include <authsrv.h>
 
 char*	readenv(char*);
 void	setenv(char*, char*);
@@ -78,39 +78,39 @@ main(int argc, char *argv[])
 void
 pass(int fd)
 {
-//PAD: 	char key[DESKEYLEN];
-//PAD: 	char typed[32];
-//PAD: 	char crypted[DESKEYLEN];
-//PAD: 	int i;
-//PAD: 
-//PAD: 	for(;;){
-//PAD: 		print("\n%s password:", systemname);
-//PAD: 		for(i=0; i<sizeof typed; i++){
-//PAD: 			if(read(0, typed+i, 1) != 1){
-//PAD: 				print("init: can't read password; insecure\n");
-//PAD: 				return;
-//PAD: 			}
-//PAD: 			if(typed[i] == '\n'){
-//PAD: 				typed[i] = 0;
-//PAD: 				break;
-//PAD: 			}
-//PAD: 		}
-//PAD: 		if(i == sizeof typed)
-//PAD: 			continue;
-//PAD: 		if(passtokey(crypted, typed) == 0)
-//PAD: 			continue;
-//PAD: 		seek(fd, 0, 0);
-//PAD: 		if(read(fd, key, DESKEYLEN) != DESKEYLEN){
-//PAD: 			print("init: can't read key; insecure\n");
-//PAD: 			return;
-//PAD: 		}
-//PAD: 		if(memcmp(crypted, key, sizeof key))
-//PAD: 			continue;
-//PAD: 		/* clean up memory */
-//PAD: 		memset(crypted, 0, sizeof crypted);
-//PAD: 		memset(key, 0, sizeof key);
-//PAD: 		return;
-//PAD: 	}
+	char key[DESKEYLEN];
+	char typed[32];
+	char crypted[DESKEYLEN];
+	int i;
+
+	for(;;){
+		print("\n%s password:", systemname);
+		for(i=0; i<sizeof typed; i++){
+			if(read(0, typed+i, 1) != 1){
+				print("init: can't read password; insecure\n");
+				return;
+			}
+			if(typed[i] == '\n'){
+				typed[i] = 0;
+				break;
+			}
+		}
+		if(i == sizeof typed)
+			continue;
+		if(passtokey(crypted, typed) == 0)
+			continue;
+		seek(fd, 0, 0);
+		if(read(fd, key, DESKEYLEN) != DESKEYLEN){
+			print("init: can't read key; insecure\n");
+			return;
+		}
+		if(memcmp(crypted, key, sizeof key))
+			continue;
+		/* clean up memory */
+		memset(crypted, 0, sizeof crypted);
+		memset(key, 0, sizeof key);
+		return;
+	}
 }
 
 static int gotnote;
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: iostats
Only in ./cmd/ip: 6in4.8
Only in ./cmd/ip: 8.6in4
Only in ./cmd/ip: 8.dhcpclient
Only in ./cmd/ip: 8.ftpd
Only in ./cmd/ip: 8.gping
Only in ./cmd/ip: 8.hogports
Only in ./cmd/ip: 8.httpfile
Only in ./cmd/ip: 8.linklocal
Only in ./cmd/ip: 8.ping
Only in ./cmd/ip: 8.pppoe
Only in ./cmd/ip: 8.pptp
Only in ./cmd/ip: 8.pptpd
Only in ./cmd/ip: 8.rarpd
Only in ./cmd/ip: 8.rexexec
Only in ./cmd/ip: 8.rip
Only in ./cmd/ip: 8.rlogind
Only in ./cmd/ip: 8.telnet
Only in ./cmd/ip: 8.telnetd
Only in ./cmd/ip: 8.tftpd
Only in ./cmd/ip: 8.traceroute
Only in ./cmd/ip: 8.udpecho
Only in ./cmd/ip: 8.wol
Only in ./cmd/ip: dhcpclient.8
Only in ./cmd/ip/dhcpd: 8.dhcpd
Only in ./cmd/ip/dhcpd: 8.dhcpleases
Only in ./cmd/ip/dhcpd: db.8
Only in ./cmd/ip/dhcpd: dhcpd.8
Only in ./cmd/ip/dhcpd: dhcpleases.8
Only in ./cmd/ip/dhcpd: ndb.8
Only in ./cmd/ip/dhcpd: ping.8
Only in ./cmd/ip: ftpd.8
Only in ./cmd/ip/ftpfs: 8.out
Only in ./cmd/ip/ftpfs: file.8
Only in ./cmd/ip/ftpfs: ftpfs.8
Only in ./cmd/ip/ftpfs: proto.8
Only in ./cmd/ip: glob.8
Only in ./cmd/ip: gping.8
Only in ./cmd/ip: hogports.8
Only in ./cmd/ip: httpfile.8
Only in ./cmd/ip/ipconfig: 8.out
Only in ./cmd/ip/ipconfig: ipv6.8
Only in ./cmd/ip/ipconfig: main.8
Only in ./cmd/ip/ipconfig: ppp.8
Only in ./cmd/ip: linklocal.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/ip/mkfile /Volumes/Plan 9 - Dec 29/sys/src/cmd/ip/mkfile
--- ./cmd/ip/mkfile	2014-01-24 17:05:06.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/ip/mkfile	2008-05-09 15:01:31.000000000 -0700
@@ -1,5 +1,3 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
 TARG = 	6in4\
@@ -24,8 +22,7 @@ TARG = 	6in4\
 	udpecho\
 	wol\
 
-#imap4d httpd snoopy
-DIRS=ftpfs dhcpd ipconfig ppp 
+DIRS=ftpfs dhcpd httpd ipconfig ppp imap4d snoopy
 
 BIN=/$objtype/bin/ip
 HFILES=dhcp.h arp.h glob.h icmp.h telnet.h
Only in ./cmd/ip: ping.8
Only in ./cmd/ip/ppp: 8.out
Only in ./cmd/ip/ppp: block.8
Only in ./cmd/ip/ppp: compress.8
Only in ./cmd/ip/ppp: ipaux.8
Only in ./cmd/ip/ppp: mppc.8
Only in ./cmd/ip/ppp: ppp.8
Only in ./cmd/ip/ppp: thw.8
Only in ./cmd/ip/ppp: thwack.8
Only in ./cmd/ip/ppp: unthwack.8
Only in ./cmd/ip: pppoe.8
Only in ./cmd/ip: pptp.8
Only in ./cmd/ip: pptpd.8
Only in ./cmd/ip: rarpd.8
Only in ./cmd/ip: rexexec.8
Only in ./cmd/ip: rip.8
Only in ./cmd/ip: rlogind.8
Only in ./cmd/ip: telnet.8
Only in ./cmd/ip: telnetd.8
Only in ./cmd/ip: tftpd.8
Only in ./cmd/ip: traceroute.8
Only in ./cmd/ip: udpecho.8
Only in ./cmd/ip: wol.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: join.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: jpg
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ka
Only in ./cmd: kbmap.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: kc
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ki
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: kl
Only in ./cmd: kprof.8
Only in ./cmd: ktrace.8
Only in ./cmd: lens.8
Only in ./cmd/lex: 8.out
Only in ./cmd/lex: header.8
Only in ./cmd/lex: lmain.8
Only in ./cmd/lex: sub1.8
Only in ./cmd/lex: sub2.8
Only in ./cmd/lex: y.tab.8
Only in ./cmd/lex: y.tab.c
Only in ./cmd/lex: y.tab.h
Only in ./cmd: life.8
Only in ./cmd: life.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: lnfs.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: lock.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: look.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: lp
Only in ./cmd: ls.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: map
Only in ./cmd: mc.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: md5sum.c
Only in ./cmd/mk: 8.out
Only in ./cmd/mk: arc.8
Only in ./cmd/mk: archive.8
Only in ./cmd/mk: bufblock.8
Only in ./cmd/mk: env.8
Only in ./cmd/mk: file.8
Only in ./cmd/mk: graph.8
Only in ./cmd/mk: job.8
Only in ./cmd/mk: lex.8
Only in ./cmd/mk: main.8
Only in ./cmd/mk: match.8
Only in ./cmd/mk: mk.8
Only in ./cmd/mk: parse.8
Only in ./cmd/mk: plan9.8
Only in ./cmd/mk: rc.8
Only in ./cmd/mk: recipe.8
Only in ./cmd/mk: rule.8
Only in ./cmd/mk: run.8
Only in ./cmd/mk: shprint.8
Only in ./cmd/mk: symtab.8
Only in ./cmd/mk: var.8
Only in ./cmd/mk: varsub.8
Only in ./cmd/mk: word.8
Only in ./cmd: mkdir.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/mkfile /Volumes/Plan 9 - Dec 29/sys/src/cmd/mkfile
--- ./cmd/mkfile	2014-01-19 11:51:10.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/mkfile	2007-05-06 14:38:02.000000000 -0700
@@ -1,35 +1,46 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
 TARG=`{ls *.[cy] | sed '/\.tab\.c$/d;s/..$//'}
 HFILES=/$objtype/include/u.h /sys/include/libc.h /sys/include/bio.h
 BIN=/$objtype/bin
 PROGS=${TARG:%=$O.%}
+LDFLAGS=
 YFLAGS=-d
 
-NOMK=awk
+NOTSYS=sml|dup|.+\..+
+BUGGERED=unix|postscript
+OUTOFDATE=old
+
+NOMK=$NOTSYS|$BUGGERED|$OUTOFDATE
 
 cpuobjtype=`{sed -n 's/^O=//p' /$cputype/mkfile}
 DIRS=`{ls -l | sed '/^d/!d; s/.* //; /^('$NOMK')$/d'}
+APEDIRS=awk bzip2 compress cvs eqn grap gs links-ape lp pic postscript spin \
+	tex troff
 
 none:VQ:
 	echo usage: mk cmds, dirs, all, install, installall, '$O'.cmd, cmd.install, or cmd.installall
 
 cmds:V:	$PROGS
 
+ape:V: $APE
+	for(i in $APEDIRS) @{
+		cd $i
+		echo mk $i
+		mk $MKFLAGS all
+	}
+
 dirs:V:
 	for(i in cc $DIRS) @{
 		cd $i
-		echo DIR: cmd/$i
+		echo mk $i
 		mk $MKFLAGS all
 	}
 
 all:V:	$PROGS dirs
 
-#PAD: put $LDFLAGS and have weird behavior => I've removed it
 ^([$OS])\.(.*):R:	\2.\1
-	$stem1^l -o $target $stem2.$stem1
+	$stem1^l $LDFLAGS -o $target $stem2.$stem1
 
 .*\.[$OS]:R:	$HFILES
 
@@ -99,9 +110,15 @@ installall:V:
 %.acid: %.$O $HFILES
 	$CC $CFLAGS -a $stem.c >$target
 
+(bc|units).c:R:	\1.tab.c
+	mv $stem1.tab.c $stem1.c
+
 $BIN/init:	$O.init
 	cp $prereq /$objtype/init
 
+$O.cj:	cj.$O
+	$LD $LDFLAGS -o $O.cj cj.$O /$objtype/lib/libjpg.a
+
 %.update:V:
 	update $stem.c /386/bin/$stem
 
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/mkmany /Volumes/Plan 9 - Dec 29/sys/src/cmd/mkmany
--- ./cmd/mkmany	2014-01-17 12:27:33.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/mkmany	2011-03-17 16:40:20.000000000 -0700
@@ -1,7 +1,6 @@
-MKSHELL=$PLAN9/bin/rc
-
 PROGS=${TARG:%=$O.%}
 MANFILES=${TARG:%=%.man}
+LDFLAGS=
 YFLAGS=-d
 
 none:VQ:
@@ -10,7 +9,7 @@ none:VQ:
 all:V:	$PROGS
 
 $O.%:	%.$O $OFILES $LIB
-	$LD -o $target $prereq
+	$LD $LDFLAGS -o $target $prereq
 
 %.$O:	$HFILES		# don't combine with following %.$O rules
 
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/mksyslib /Volumes/Plan 9 - Dec 29/sys/src/cmd/mksyslib
--- ./cmd/mksyslib	2014-01-16 23:01:15.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/mksyslib	2005-12-12 04:22:17.000000000 -0800
@@ -1,5 +1,3 @@
-MKSHELL=$PLAN9/bin/rc
-
 AFLAGS=
 
 all:V:	$LIB
@@ -16,7 +14,7 @@ $LIB:V:	$OFILES			# force archive even w
 	$CC $CFLAGS $stem.c
 
 %.$O:	%.s
-	$AS $stem.s
+	$AS $AFLAGS $stem.s
 
 install:V: $LIB
 
Only in ./cmd: mntgen.8
Only in ./cmd: mount.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ms2html.c
Only in ./cmd: mtime.8
Only in ./cmd: mug.8
Only in ./cmd: mv.8
Only in ./cmd/ndb: 8.cs
Only in ./cmd/ndb: 8.csquery
Only in ./cmd/ndb: 8.dns
Only in ./cmd/ndb: 8.dnsdebug
Only in ./cmd/ndb: 8.dnsquery
Only in ./cmd/ndb: 8.dnstcp
Only in ./cmd/ndb: 8.inform
Only in ./cmd/ndb: 8.ipquery
Only in ./cmd/ndb: 8.mkdb
Only in ./cmd/ndb: 8.mkhash
Only in ./cmd/ndb: 8.mkhosts
Only in ./cmd/ndb: 8.query
Only in ./cmd/ndb: convDNS2M.8
Only in ./cmd/ndb: convM2DNS.8
Only in ./cmd/ndb: cs.8
Only in ./cmd/ndb: csquery.8
Only in ./cmd/ndb: dblookup.8
Only in ./cmd/ndb: dn.8
Only in ./cmd/ndb: dnarea.8
Only in ./cmd/ndb: dnnotify.8
Only in ./cmd/ndb: dnresolve.8
Only in ./cmd/ndb: dns.8
Only in ./cmd/ndb: dnsdebug.8
Only in ./cmd/ndb: dnserver.8
Only in ./cmd/ndb: dnsquery.8
Only in ./cmd/ndb: dnstcp.8
Only in ./cmd/ndb: dnudpserver.8
Only in ./cmd/ndb: inform.8
Only in ./cmd/ndb: ipquery.8
Only in ./cmd/ndb: mkdb.8
Only in ./cmd/ndb: mkhash.8
Only in ./cmd/ndb: mkhosts.8
Only in ./cmd/ndb: query.8
Only in ./cmd: netstat.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: news.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: nfs.c
Only in ./cmd: nm.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: nntpfs.c
Only in ./cmd: ns.8
Only in ./cmd: p.8
Only in ./cmd: pad.txt
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: page
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: paqfs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: pbd.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: pcc.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: pic
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: pipefile.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: plot
Only in ./cmd/plumb: 8.plumb
Only in ./cmd/plumb: 8.plumber
Only in ./cmd/plumb: fsys.8
Only in ./cmd/plumb: match.8
Only in ./cmd/plumb: plumb.8
Only in ./cmd/plumb: plumber.8
Only in ./cmd/plumb: rules.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: postscript
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: pr.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: primes.c
Only in ./cmd: prof.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: proof
Only in ./cmd: ps.8
Only in ./cmd: pstree.8
Only in ./cmd: pstree.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: pump.c
Only in ./cmd: pwd.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: qa
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: qc
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: qi
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ql
Only in ./cmd: ramfs.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ratfs
Only in ./cmd: ratrace.8
Only in ./cmd/rc: 8.out
Only in ./cmd/rc: code.8
Only in ./cmd/rc: exec.8
Only in ./cmd/rc: getflags.8
Only in ./cmd/rc: glob.8
Only in ./cmd/rc: havefork.8
Only in ./cmd/rc: here.8
Only in ./cmd/rc: io.8
Only in ./cmd/rc: lex.8
Only in ./cmd/rc: pcmd.8
Only in ./cmd/rc: pfnc.8
Only in ./cmd/rc: plan9.8
Only in ./cmd/rc: simple.8
Only in ./cmd/rc: subr.8
Only in ./cmd/rc: trap.8
Only in ./cmd/rc: tree.8
Only in ./cmd/rc: var.8
Only in ./cmd/rc: x.tab.h
Only in ./cmd/rc: y.tab.8
Only in ./cmd/rc: y.tab.c
Only in ./cmd/rc: y.tab.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: rdbfs.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: read.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: replica
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: resample.c
Only in ./cmd/rio: 8.out
Only in ./cmd/rio: data.8
Only in ./cmd/rio: fsys.8
Only in ./cmd/rio: pfff.log
Only in ./cmd/rio: rio.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./cmd/rio/rio.c /Volumes/Plan 9 - Dec 29/sys/src/cmd/rio/rio.c
--- ./cmd/rio/rio.c	2014-01-20 22:36:41.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/cmd/rio/rio.c	2009-05-04 10:20:55.000000000 -0700
@@ -124,11 +124,10 @@ threadmain(int argc, char *argv[])
 	Image *i;
 	Rectangle r;
 
-        //PAD: let's keep the Exit option!
-	//PAD: if(strstr(argv[0], ".out") == nil){
-	//PAD: 	menu3str[Exit] = nil;
-	//PAD: 	Hidden--;
-	//PAD: }
+	if(strstr(argv[0], ".out") == nil){
+		menu3str[Exit] = nil;
+		Hidden--;
+	}
 	initstr = nil;
 	kbdin = nil;
 	maxtab = 0;
Only in ./cmd/rio: scrl.8
Only in ./cmd/rio: time.8
Only in ./cmd/rio: util.8
Only in ./cmd/rio: wctl.8
Only in ./cmd/rio: wind.8
Only in ./cmd/rio: xfid.8
Only in ./cmd: rm.8
Only in ./cmd: rx.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: sam
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: samterm
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: scat
Only in ./cmd: screenlock.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: scuzz
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: seconds.c
Only in ./cmd: sed.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: seq.c
Only in ./cmd: sh.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: sh.C
Only in ./cmd: sh.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: sha1sum.c
Only in ./cmd: size.8
Only in ./cmd: sleep.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: snap
Only in ./cmd: sokoban
Only in ./cmd: sort.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: spell
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: spin
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: split.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: srv.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: srvfs.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: srvold9p
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ssh1
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: ssh2
Only in ./cmd: stats.8
Only in ./cmd: strings.8
Only in ./cmd: strip.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: sum.c
Only in ./cmd: swap.8
Only in ./cmd/syscall: 8.out
Only in ./cmd/syscall: syscall.8
Only in ./cmd/syscall: tab.h
Only in ./cmd: tail.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: tapefs
Only in ./cmd: tar.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: tarsplit
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: tbl
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: tcs
Only in ./cmd: tee.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: telco
Only in ./cmd: test.8
Only in ./cmd: test_pad.8
Only in ./cmd: test_pad.c
Only in ./cmd: time.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: tlsclient.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: tlssrv.c
Only in ./cmd: touch.8
Only in ./cmd: tprof.8
Only in ./cmd: tr.8
Only in ./cmd: trace.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: troff
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: troff2html
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: tweak.c
Only in ./cmd: unicode.8
Only in ./cmd: uniq.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: units.y
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: unix
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: unlnfs.c
Only in ./cmd: unmount.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: upas
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: usb
Only in ./cmd/va: 8.out
Only in ./cmd/va: lex.8
Only in ./cmd/va: y.debug
Only in ./cmd/va: y.tab.8
Only in ./cmd/va: y.tab.c
Only in ./cmd/va: y.tab.h
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: vac
Only in ./cmd/vc: 8.out
Only in ./cmd/vc: cgen.8
Only in ./cmd/vc: enam.8
Only in ./cmd/vc: list.8
Only in ./cmd/vc: mul.8
Only in ./cmd/vc: peep.8
Only in ./cmd/vc: pgen.8
Only in ./cmd/vc: pswt.8
Only in ./cmd/vc: reg.8
Only in ./cmd/vc: sgen.8
Only in ./cmd/vc: swt.8
Only in ./cmd/vc: txt.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: venti
Only in ./cmd/vi: 8.out
Only in ./cmd/vi: bpt.8
Only in ./cmd/vi: cmd.8
Only in ./cmd/vi: float.8
Only in ./cmd/vi: icache.8
Only in ./cmd/vi: mem.8
Only in ./cmd/vi: run.8
Only in ./cmd/vi: special.8
Only in ./cmd/vi: stats.8
Only in ./cmd/vi: symbols.8
Only in ./cmd/vi: syscall.8
Only in ./cmd/vi: vi.8
Only in ./cmd/vl: 8.out
Only in ./cmd/vl: asm.8
Only in ./cmd/vl: compat.8
Only in ./cmd/vl: elf.8
Only in ./cmd/vl: enam.8
Only in ./cmd/vl: list.8
Only in ./cmd/vl: noop.8
Only in ./cmd/vl: obj.8
Only in ./cmd/vl: optab.8
Only in ./cmd/vl: pass.8
Only in ./cmd/vl: sched.8
Only in ./cmd/vl: span.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: vnc
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: vt
Only in ./cmd: wc.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: webcookies.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: webfs
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: webfsget.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/cmd: wikifs
Only in ./cmd: winwatch.8
Only in ./cmd: xargs.8
Only in ./cmd: xargs.c
Only in ./cmd: xd.8
Only in ./cmd: yacc.8
Only in .: compile_commands.json
Only in .: current_diff
Only in /Volumes/Plan 9 - Dec 29/sys/src/: games
Only in .: graph_code.marshall
Only in .: graph_code.marshall.opti
Only in .: include
Only in .: layer_bottomup.json
Only in .: layer_graphcode_stats.json
Only in .: layer_topdown.json
Only in ./lib9p: auth.8
Only in ./lib9p: dirread.8
Only in ./lib9p: fid.8
Only in ./lib9p: file.8
Only in ./lib9p: intmap.8
Only in ./lib9p: listen.8
Only in ./lib9p: mem.8
Only in ./lib9p: parse.8
Only in ./lib9p: post.8
Only in ./lib9p: req.8
Only in ./lib9p: rfork.8
Only in ./lib9p: srv.8
Only in ./lib9p: thread.8
Only in ./lib9p: uid.8
Only in ./lib9p: util.8
Only in ./libString: s_alloc.8
Only in ./libString: s_append.8
Only in ./libString: s_array.8
Only in ./libString: s_copy.8
Only in ./libString: s_getline.8
Only in ./libString: s_grow.8
Only in ./libString: s_memappend.8
Only in ./libString: s_nappend.8
Only in ./libString: s_parse.8
Only in ./libString: s_putc.8
Only in ./libString: s_rdinstack.8
Only in ./libString: s_read.8
Only in ./libString: s_read_line.8
Only in ./libString: s_reset.8
Only in ./libString: s_terminate.8
Only in ./libString: s_tolower.8
Only in ./libString: s_unique.8
Only in ./libauth: amount.8
Only in ./libauth: amount_getkey.8
Only in ./libauth: attr.8
Only in ./libauth: auth_attr.8
Only in ./libauth: auth_challenge.8
Only in ./libauth: auth_chuid.8
Only in ./libauth: auth_getkey.8
Only in ./libauth: auth_getuserpasswd.8
Only in ./libauth: auth_proxy.8
Only in ./libauth: auth_respond.8
Only in ./libauth: auth_rpc.8
Only in ./libauth: auth_userpasswd.8
Only in ./libauth: auth_wep.8
Only in ./libauth: login.8
Only in ./libauth: newns.8
Only in ./libauth: noworld.8
Only in ./libauthsrv: _asgetticket.8
Only in ./libauthsrv: _asrdresp.8
Only in ./libauthsrv: authdial.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libauthsrv/authdial.c /Volumes/Plan 9 - Dec 29/sys/src/libauthsrv/authdial.c
--- ./libauthsrv/authdial.c	2014-01-16 21:07:53.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libauthsrv/authdial.c	2007-10-18 12:50:14.000000000 -0700
@@ -2,35 +2,35 @@
 #include <libc.h>
 #include <authsrv.h>
 #include <bio.h>
-//PAD #include <ndb.h>
+#include <ndb.h>
 
 int
 authdial(char *netroot, char *dom)
 {
-//PAD: 	char *p;
-//PAD: 	int rv;
-//PAD: 
-//PAD: 	if(dom == nil)
-//PAD: 		/* look for one relative to my machine */
-//PAD: 		return dial(netmkaddr("$auth", netroot, "ticket"), 0, 0, 0);
-//PAD: 
-//PAD: 	/* look up an auth server in an authentication domain */
-//PAD: 	p = csgetvalue(netroot, "authdom", dom, "auth", nil);
-//PAD: 
-//PAD: 	/* if that didn't work, just try the IP domain */
-//PAD: 	if(p == nil)
-//PAD: 		p = csgetvalue(netroot, "dom", dom, "auth", nil);
-//PAD: 	/*
-//PAD: 	 * if that didn't work, try p9auth.$dom.  this is very helpful if
-//PAD: 	 * you can't edit /lib/ndb.
-//PAD: 	 */
-//PAD: 	if(p == nil)
-//PAD: 		p = smprint("p9auth.%s", dom);
-//PAD: 	if(p == nil){			/* should no longer ever happen */
-//PAD: 		werrstr("no auth server found for %s", dom);
-//PAD: 		return -1;
-//PAD: 	}
-//PAD: 	rv = dial(netmkaddr(p, netroot, "ticket"), 0, 0, 0);
-//PAD: 	free(p);
-//PAD: 	return rv;
+	char *p;
+	int rv;
+
+	if(dom == nil)
+		/* look for one relative to my machine */
+		return dial(netmkaddr("$auth", netroot, "ticket"), 0, 0, 0);
+
+	/* look up an auth server in an authentication domain */
+	p = csgetvalue(netroot, "authdom", dom, "auth", nil);
+
+	/* if that didn't work, just try the IP domain */
+	if(p == nil)
+		p = csgetvalue(netroot, "dom", dom, "auth", nil);
+	/*
+	 * if that didn't work, try p9auth.$dom.  this is very helpful if
+	 * you can't edit /lib/ndb.
+	 */
+	if(p == nil)
+		p = smprint("p9auth.%s", dom);
+	if(p == nil){			/* should no longer ever happen */
+		werrstr("no auth server found for %s", dom);
+		return -1;
+	}
+	rv = dial(netmkaddr(p, netroot, "ticket"), 0, 0, 0);
+	free(p);
+	return rv;
 }
Only in ./libauthsrv: convA2M.8
Only in ./libauthsrv: convM2A.8
Only in ./libauthsrv: convM2PR.8
Only in ./libauthsrv: convM2T.8
Only in ./libauthsrv: convM2TR.8
Only in ./libauthsrv: convPR2M.8
Only in ./libauthsrv: convT2M.8
Only in ./libauthsrv: convTR2M.8
Only in ./libauthsrv: nvcsum.8
Only in ./libauthsrv: opasstokey.8
Only in ./libauthsrv: passtokey.8
Only in ./libauthsrv: readnvram.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libavl
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libbin
Only in ./libbio: bbuffered.8
Only in ./libbio: bfildes.8
Only in ./libbio: bflush.8
Only in ./libbio: bgetc.8
Only in ./libbio: bgetd.8
Only in ./libbio: bgetrune.8
Only in ./libbio: binit.8
Only in ./libbio: boffset.8
Only in ./libbio: bprint.8
Only in ./libbio: bputc.8
Only in ./libbio: bputrune.8
Only in ./libbio: brdline.8
Only in ./libbio: brdstr.8
Only in ./libbio: bread.8
Only in ./libbio: bseek.8
Only in ./libbio: bvprint.8
Only in ./libbio: bwrite.8
Only in ./libc/386: argv0.8
Only in ./libc/386: atom.8
Only in ./libc/386: cycles.8
Only in ./libc/386: getcallerpc.8
Only in ./libc/386: getfcr.8
Only in ./libc/386: main9.8
Only in ./libc/386: main9p.8
Only in ./libc/386: memccpy.8
Only in ./libc/386: memchr.8
Only in ./libc/386: memcmp.8
Only in ./libc/386: memcpy.8
Only in ./libc/386: memmove.8
Only in ./libc/386: memset.8
Only in ./libc/386: muldiv.8
Only in ./libc/386: notejmp.8
Only in ./libc/386: setjmp.8
Only in ./libc/386: sqrt.8
Only in ./libc/386: strcat.8
Only in ./libc/386: strchr.8
Only in ./libc/386: strcpy.8
Only in ./libc/386: strlen.8
Only in ./libc/386: tas.8
Only in ./libc/386: vlop.8
Only in ./libc/386: vlrt.8
Only in ./libc/9sys: abort.8
Only in ./libc/9sys: access.8
Only in ./libc/9sys: announce.8
Only in ./libc/9sys: convD2M.8
Only in ./libc/9sys: convM2D.8
Only in ./libc/9sys: convM2S.8
Only in ./libc/9sys: convS2M.8
Only in ./libc/9sys: cputime.8
Only in ./libc/9sys: ctime.8
Only in ./libc/9sys: dial.8
Only in ./libc/9sys: dirfstat.8
Only in ./libc/9sys: dirfwstat.8
Only in ./libc/9sys: dirmodefmt.8
Only in ./libc/9sys: dirread.8
Only in ./libc/9sys: dirstat.8
Only in ./libc/9sys: dirwstat.8
Only in ./libc/9sys: fcallfmt.8
Only in ./libc/9sys: fork.8
Only in ./libc/9sys: getenv.8
Only in ./libc/9sys: getnetconninfo.8
Only in ./libc/9sys: getpid.8
Only in ./libc/9sys: getppid.8
Only in ./libc/9sys: getwd.8
Only in ./libc/9sys: iounit.8
Only in ./libc/9sys: nsec.8
Only in ./libc/9sys: nulldir.8
Only in ./libc/9sys: postnote.8
Only in ./libc/9sys: privalloc.8
Only in ./libc/9sys: pushssl.8
Only in ./libc/9sys: pushtls.8
Only in ./libc/9sys: putenv.8
Only in ./libc/9sys: qlock.8
Only in ./libc/9sys: read.8
Only in ./libc/9sys: read9pmsg.8
Only in ./libc/9sys: readv.8
Only in ./libc/9sys: rerrstr.8
Only in ./libc/9sys: sbrk.8
Only in ./libc/9sys: setnetmtpt.8
Only in ./libc/9sys: sysfatal.8
Only in ./libc/9sys: syslog.8
Only in ./libc/9sys: sysname.8
Only in ./libc/9sys: time.8
Only in ./libc/9sys: times.8
Only in ./libc/9sys: tm2sec.8
Only in ./libc/9sys: truerand.8
Only in ./libc/9sys: wait.8
Only in ./libc/9sys: waitpid.8
Only in ./libc/9sys: werrstr.8
Only in ./libc/9sys: write.8
Only in ./libc/9sys: writev.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libc/9syscall/mkfile /Volumes/Plan 9 - Dec 29/sys/src/libc/9syscall/mkfile
--- ./libc/9syscall/mkfile	2014-01-15 14:14:08.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libc/9syscall/mkfile	2013-04-09 07:21:15.000000000 -0700
@@ -1,5 +1,3 @@
-MKSHELL=$PLAN9/bin/rc
-
 NPROC=1
 </$objtype/mkfile
 
Only in ./libc/fmt: dofmt.8
Only in ./libc/fmt: dorfmt.8
Only in ./libc/fmt: errfmt.8
Only in ./libc/fmt: fltfmt.8
Only in ./libc/fmt: fmt.8
Only in ./libc/fmt: fmtfd.8
Only in ./libc/fmt: fmtlock.8
Only in ./libc/fmt: fmtprint.8
Only in ./libc/fmt: fmtquote.8
Only in ./libc/fmt: fmtrune.8
Only in ./libc/fmt: fmtstr.8
Only in ./libc/fmt: fmtvprint.8
Only in ./libc/fmt: fprint.8
Only in ./libc/fmt: print.8
Only in ./libc/fmt: runefmtstr.8
Only in ./libc/fmt: runeseprint.8
Only in ./libc/fmt: runesmprint.8
Only in ./libc/fmt: runesnprint.8
Only in ./libc/fmt: runesprint.8
Only in ./libc/fmt: runevseprint.8
Only in ./libc/fmt: runevsmprint.8
Only in ./libc/fmt: runevsnprint.8
Only in ./libc/fmt: seprint.8
Only in ./libc/fmt: smprint.8
Only in ./libc/fmt: snprint.8
Only in ./libc/fmt: sprint.8
Only in ./libc/fmt: vfprint.8
Only in ./libc/fmt: vseprint.8
Only in ./libc/fmt: vsmprint.8
Only in ./libc/fmt: vsnprint.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libc/mkfile /Volumes/Plan 9 - Dec 29/sys/src/libc/mkfile
--- ./libc/mkfile	2014-01-17 15:13:51.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libc/mkfile	2012-09-28 15:30:10.000000000 -0700
@@ -1,5 +1,3 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
 PORTDIRS=9sys 9syscall fmt port
@@ -8,7 +6,7 @@ OLDCPUS=sparc
 
 all install:V:
 	for(i in $PORTDIRS $objtype)@{
-		echo DIR: libc/$i
+		echo $i
 		cd $i
 		mk $MKFLAGS install
 	}
Only in ./libc/port: _assert.8
Only in ./libc/port: abs.8
Only in ./libc/port: asin.8
Only in ./libc/port: atan.8
Only in ./libc/port: atan2.8
Only in ./libc/port: atexit.8
Only in ./libc/port: atnotify.8
Only in ./libc/port: atof.8
Only in ./libc/port: atol.8
Only in ./libc/port: atoll.8
Only in ./libc/port: charstod.8
Only in ./libc/port: cistrcmp.8
Only in ./libc/port: cistrncmp.8
Only in ./libc/port: cistrstr.8
Only in ./libc/port: cleanname.8
Only in ./libc/port: crypt.8
Only in ./libc/port: ctype.8
Only in ./libc/port: encodefmt.8
Only in ./libc/port: execl.8
Only in ./libc/port: exp.8
Only in ./libc/port: fabs.8
Only in ./libc/port: floor.8
Only in ./libc/port: fmod.8
Only in ./libc/port: frand.8
Only in ./libc/port: frexp.8
Only in ./libc/port: getfields.8
Only in ./libc/port: getuser.8
Only in ./libc/port: hangup.8
Only in ./libc/port: hypot.8
Only in ./libc/port: lnrand.8
Only in ./libc/port: lock.8
Only in ./libc/port: log.8
Only in ./libc/port: lrand.8
Only in ./libc/port: malloc.8
Only in ./libc/port: mktemp.8
Only in ./libc/port: nan.8
Only in ./libc/port: needsrcquote.8
Only in ./libc/port: netcrypt.8
Only in ./libc/port: netmkaddr.8
Only in ./libc/port: nrand.8
Only in ./libc/port: ntruerand.8
Only in ./libc/port: perror.8
Only in ./libc/port: pool.8
Only in ./libc/port: pow.8
Only in ./libc/port: pow10.8
Only in ./libc/port: profile.8
Only in ./libc/port: qsort.8
Only in ./libc/port: quote.8
Only in ./libc/port: rand.8
Only in ./libc/port: readn.8
Only in ./libc/port: rune.8
Only in ./libc/port: runebase.8
Only in ./libc/port: runebsearch.8
Only in ./libc/port: runestrcat.8
Only in ./libc/port: runestrchr.8
Only in ./libc/port: runestrcmp.8
Only in ./libc/port: runestrcpy.8
Only in ./libc/port: runestrdup.8
Only in ./libc/port: runestrecpy.8
Only in ./libc/port: runestrlen.8
Only in ./libc/port: runestrncat.8
Only in ./libc/port: runestrncmp.8
Only in ./libc/port: runestrncpy.8
Only in ./libc/port: runestrrchr.8
Only in ./libc/port: runestrstr.8
Only in ./libc/port: runetype.8
Only in ./libc/port: sin.8
Only in ./libc/port: sinh.8
Only in ./libc/port: strcmp.8
Only in ./libc/port: strcspn.8
Only in ./libc/port: strdup.8
Only in ./libc/port: strecpy.8
Only in ./libc/port: strncat.8
Only in ./libc/port: strncmp.8
Only in ./libc/port: strncpy.8
Only in ./libc/port: strpbrk.8
Only in ./libc/port: strrchr.8
Only in ./libc/port: strspn.8
Only in ./libc/port: strstr.8
Only in ./libc/port: strtod.8
Only in ./libc/port: strtok.8
Only in ./libc/port: strtol.8
Only in ./libc/port: strtoll.8
Only in ./libc/port: strtoul.8
Only in ./libc/port: strtoull.8
Only in ./libc/port: tan.8
Only in ./libc/port: tanh.8
Only in ./libc/port: tokenize.8
Only in ./libc/port: toupper.8
Only in ./libc/port: u16.8
Only in ./libc/port: u32.8
Only in ./libc/port: u64.8
Only in ./libc/port: utfecpy.8
Only in ./libc/port: utflen.8
Only in ./libc/port: utfnlen.8
Only in ./libc/port: utfrrune.8
Only in ./libc/port: utfrune.8
Only in ./libc/port: utfutf.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libc: power
Only in /Volumes/Plan 9 - Dec 29/sys/src/libc: sparc
Only in ./libcomplete: complete.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libcontrol
Only in ./libdisk: disk.8
Only in ./libdisk: proto.8
Only in ./libdisk: scsi.8
Only in ./libdraw: alloc.8
Only in ./libdraw: allocimagemix.8
Only in ./libdraw: arith.8
Only in ./libdraw: bezier.8
Only in ./libdraw: border.8
Only in ./libdraw: buildfont.8
Only in ./libdraw: bytesperline.8
Only in ./libdraw: chan.8
Only in ./libdraw: cloadimage.8
Only in ./libdraw: computil.8
Only in ./libdraw: creadimage.8
Only in ./libdraw: debug.8
Only in ./libdraw: defont.8
Only in ./libdraw: draw.8
Only in ./libdraw: drawrepl.8
Only in ./libdraw: egetrect.8
Only in ./libdraw: ellipse.8
Only in ./libdraw: emenuhit.8
Only in ./libdraw: event.8
Only in ./libdraw: fmt.8
Only in ./libdraw: font.8
Only in ./libdraw: freesubfont.8
Only in ./libdraw: getdefont.8
Only in ./libdraw: getrect.8
Only in ./libdraw: getsubfont.8
Only in ./libdraw: icossin.8
Only in ./libdraw: icossin2.8
Only in ./libdraw: init.8
Only in ./libdraw: keyboard.8
Only in ./libdraw: line.8
Only in ./libdraw: loadimage.8
Only in ./libdraw: menuhit.8
Only in ./libdraw: mkfont.8
Only in ./libdraw: mouse.8
Only in ./libdraw: newwindow.8
Only in ./libdraw: openfont.8
Only in ./libdraw: poly.8
Only in ./libdraw: readcolmap.8
Only in ./libdraw: readimage.8
Only in ./libdraw: readsubfont.8
Only in ./libdraw: rectclip.8
Only in ./libdraw: replclipr.8
Only in ./libdraw: rgb.8
Only in ./libdraw: scroll.8
Only in ./libdraw: string.8
Only in ./libdraw: stringbg.8
Only in ./libdraw: stringsubfont.8
Only in ./libdraw: stringwidth.8
Only in ./libdraw: subfont.8
Only in ./libdraw: subfontcache.8
Only in ./libdraw: subfontname.8
Only in ./libdraw: unloadimage.8
Only in ./libdraw: window.8
Only in ./libdraw: writecolmap.8
Only in ./libdraw: writeimage.8
Only in ./libdraw: writesubfont.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libflate
Only in ./libframe: frbox.8
Only in ./libframe: frdelete.8
Only in ./libframe: frdraw.8
Only in ./libframe: frinit.8
Only in ./libframe: frinsert.8
Only in ./libframe: frptofchar.8
Only in ./libframe: frselect.8
Only in ./libframe: frstr.8
Only in ./libframe: frutil.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libgeometry
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libhtml
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libhttpd
Only in ./libip: bo.8
Only in ./libip: classmask.8
Only in ./libip: eipfmt.8
Only in ./libip: equivip.8
Only in ./libip: ipaux.8
Only in ./libip: myetheraddr.8
Only in ./libip: myipaddr.8
Only in ./libip: parseether.8
Only in ./libip: parseip.8
Only in ./libip: ptclbsum.8
Only in ./libip: readipifc.8
Only in ./liblex: allprint.8
Only in ./liblex: main.8
Only in ./liblex: reject.8
Only in ./liblex: yyless.8
Only in ./liblex: yywrap.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 0.c
Only in ./libmach: 5.8
Only in ./libmach: 5db.8
Only in ./libmach: 5obj.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 6.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 68020
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 68020.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 68020db.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 68020obj.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 6c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 6obj.c
Only in ./libmach: 8.8
Only in ./libmach: 8db.8
Only in ./libmach: 8obj.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 9.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 9c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: 9obj.c
Only in ./libmach: access.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: alpha
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: alpha.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: alphadb.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: alphaobj.c
Only in ./libmach: executable.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libmach/executable.c /Volumes/Plan 9 - Dec 29/sys/src/libmach/executable.c
--- ./libmach/executable.c	2014-01-23 00:01:24.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libmach/executable.c	2013-08-15 12:07:41.000000000 -0700
@@ -57,10 +57,18 @@ typedef struct Exectable{
 	int	(*hparse)(int, Fhdr*, ExecHdr*);
 } ExecTable;
 
-//PAD: removed many archi
 extern	Mach	mmips;
+extern	Mach	mmips2le;
+extern	Mach	mmips2be;
+extern	Mach	msparc;
+extern	Mach	msparc64;
+extern	Mach	m68020;
 extern	Mach	mi386;
+extern	Mach	mamd64;
 extern	Mach	marm;
+extern	Mach	mpower;
+extern	Mach	mpower64;
+extern	Mach	malpha;
 
 ExecTable exectab[] =
 {
@@ -82,6 +90,24 @@ ExecTable exectab[] =
 		sizeof(Exec),
 		beswal,
 		adotout },
+	{ M_MAGIC,			/* Mips 4.out */
+		"mips 4k plan 9 executable BE",
+		"mips 4k plan 9 dlm BE",
+		FMIPS2BE,
+		1,
+		&mmips2be,
+		sizeof(Exec),
+		beswal,
+		adotout },
+	{ N_MAGIC,			/* Mips 0.out */
+		"mips 4k plan 9 executable LE",
+		"mips 4k plan 9 dlm LE",
+		FMIPS2LE,
+		1,
+		&mmips2le,
+		sizeof(Exec),
+		beswal,
+		adotout },
 	{ 0x160<<16,			/* Mips boot image */
 		"mips plan 9 boot image",
 		nil,
@@ -91,6 +117,60 @@ ExecTable exectab[] =
 		sizeof(struct mipsexec),
 		beswal,
 		mipsboot },
+	{ (0x160<<16)|3,		/* Mips boot image */
+		"mips 4k plan 9 boot image",
+		nil,
+		FMIPSB,
+		0,
+		&mmips2be,
+		sizeof(struct mips4kexec),
+		beswal,
+		mips4kboot },
+	{ K_MAGIC,			/* Sparc k.out */
+		"sparc plan 9 executable",
+		"sparc plan 9 dlm",
+		FSPARC,
+		1,
+		&msparc,
+		sizeof(Exec),
+		beswal,
+		adotout },
+	{ 0x01030107, 			/* Sparc boot image */
+		"sparc plan 9 boot image",
+		nil,
+		FSPARCB,
+		0,
+		&msparc,
+		sizeof(struct sparcexec),
+		beswal,
+		sparcboot },
+	{ U_MAGIC,			/* Sparc64 u.out */
+		"sparc64 plan 9 executable",
+		"sparc64 plan 9 dlm",
+		FSPARC64,
+		1,
+		&msparc64,
+		sizeof(Exec),
+		beswal,
+		adotout },
+	{ A_MAGIC,			/* 68020 2.out & boot image */
+		"68020 plan 9 executable",
+		"68020 plan 9 dlm",
+		F68020,
+		1,
+		&m68020,
+		sizeof(Exec),
+		beswal,
+		common },
+	{ 0xFEEDFACE,			/* Next boot image */
+		"next plan 9 boot image",
+		nil,
+		FNEXTB,
+		0,
+		&m68020,
+		sizeof(struct nextexec),
+		beswal,
+		nextboot },
 	{ I_MAGIC,			/* I386 8.out & boot image */
 		"386 plan 9 executable",
 		"386 plan 9 dlm",
@@ -100,6 +180,33 @@ ExecTable exectab[] =
 		sizeof(Exec),
 		beswal,
 		common },
+	{ S_MAGIC,			/* amd64 6.out & boot image */
+		"amd64 plan 9 executable",
+		"amd64 plan 9 dlm",
+		FAMD64,
+		1,
+		&mamd64,
+		sizeof(Exec)+8,
+		nil,
+		commonllp64 },
+	{ Q_MAGIC,			/* PowerPC q.out & boot image */
+		"power plan 9 executable",
+		"power plan 9 dlm",
+		FPOWER,
+		1,
+		&mpower,
+		sizeof(Exec),
+		beswal,
+		common },
+	{ T_MAGIC,			/* power64 9.out & boot image */
+		"power64 plan 9 executable",
+		"power64 plan 9 dlm",
+		FPOWER64,
+		1,
+		&mpower64,
+		sizeof(Exec)+8,
+		nil,
+		commonllp64 },
 	{ ELF_MAG,			/* any ELF */
 		"elf executable",
 		nil,
@@ -118,7 +225,33 @@ ExecTable exectab[] =
 		sizeof(Exec),
 		beswal,
 		common },
-
+	{ (143<<16)|0413,		/* (Free|Net)BSD Arm */
+		"arm *bsd executable",
+		nil,
+		FARM,
+		0,
+		&marm,
+		sizeof(Exec),
+		leswal,
+		armdotout },
+	{ L_MAGIC,			/* alpha 7.out */
+		"alpha plan 9 executable",
+		"alpha plan 9 dlm",
+		FALPHA,
+		1,
+		&malpha,
+		sizeof(Exec),
+		beswal,
+		common },
+	{ 0x0700e0c3,			/* alpha boot image */
+		"alpha plan 9 boot image",
+		nil,
+		FALPHA,
+		0,
+		&malpha,
+		sizeof(Exec),
+		beswal,
+		common },
 	{ 0 },
 };
 
@@ -484,6 +617,16 @@ elf64dotout(int fd, Fhdr *fp, ExecHdr *h
 	switch(ep->machine) {
 	default:
 		return 0;
+	case AMD64:
+		mach = &mamd64;
+		fp->type = FAMD64;
+		fp->name = "amd64 ELF64 executable";
+		break;
+	case POWER64:
+		mach = &mpower64;
+		fp->type = FPOWER64;
+		fp->name = "power64 ELF64 executable";
+		break;
 	}
 
 	if(ep->phentsize != sizeof(P64hdr)) {
@@ -593,6 +736,26 @@ elf32dotout(int fd, Fhdr *fp, ExecHdr *h
 		fp->type = FMIPS;
 		fp->name = "mips ELF32 executable";
 		break;
+	case SPARC64:
+		mach = &msparc64;
+		fp->type = FSPARC64;
+		fp->name = "sparc64 ELF32 executable";
+		break;
+	case POWER:
+		mach = &mpower;
+		fp->type = FPOWER;
+		fp->name = "power ELF32 executable";
+		break;
+	case POWER64:
+		mach = &mpower64;
+		fp->type = FPOWER64;
+		fp->name = "power64 ELF32 executable";
+		break;
+	case AMD64:
+		mach = &mamd64;
+		fp->type = FAMD64;
+		fp->name = "amd64 ELF32 executable";
+		break;
 	case ARM:
 		mach = &marm;
 		fp->type = FARM;
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: k.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: kdb.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: kobj.c
Only in ./libmach: machdata.8
Only in ./libmach: map.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libmach/mkfile /Volumes/Plan 9 - Dec 29/sys/src/libmach/mkfile
--- ./libmach/mkfile	2014-01-22 23:58:40.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libmach/mkfile	2012-09-27 11:01:07.000000000 -0700
@@ -11,14 +11,34 @@ FILES=\
 	machdata\
 	setmach\
 	v\
+	k\
+	sparc64\
+	q\
+	0\
+	68020\
         5\
+	6\
+	alpha\
 	8\
+	9\
 	vdb\
+	kdb\
+	sparc64db\
+	qdb\
+	68020db\
         5db\
+	alphadb\
 	8db\
 	vobj\
+	kobj\
+	sparc64obj\
+	68020obj\
         5obj\
+	6obj\
+	alphaobj\
 	8obj\
+	9obj\
+	qobj\
 	vcodas\
 
 HFILES=/sys/include/mach.h elf.h obj.h
@@ -36,7 +56,13 @@ UPDATE=mkfile\
 
 CFLAGS=$CFLAGS -I/sys/src/cmd
 
+68020obj.$O: 68020/2.out.h
+5obj.$O: /sys/src/cmd/5c/5.out.h
+6obj.$O: /sys/src/cmd/6c/6.out.h
+alphaobj.$O: alpha/7.out.h
 8obj.$O: /sys/src/cmd/8c/8.out.h
+9obj.$O: 9c/9.out.h
+kobj.$O: /sys/src/cmd/kc/k.out.h
+qobj.$O: /sys/src/cmd/qc/q.out.h
+sparc64obj.$O: sparc64/u.out.h
 vobj.$O: /sys/src/cmd/vc/v.out.h
-5obj.$O: /sys/src/cmd/5c/5.out.h
-
Only in ./libmach: obj.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libmach/obj.c /Volumes/Plan 9 - Dec 29/sys/src/libmach/obj.c
--- ./libmach/obj.c	2014-01-23 00:04:25.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libmach/obj.c	2007-05-11 06:38:41.000000000 -0700
@@ -20,14 +20,26 @@ enum
 	HASHMUL	= 79L,
 };
 
-int			/* in [$OS].c */
+int	_is2(char*),		/* in [$OS].c */
   _is5(char*),
+	_is6(char*),
+	_is7(char*),
   _is8(char*),
+	_is9(char*),
+	_isk(char*),
+	_isq(char*),
   _isv(char*),
+	_isu(char*),
+	_read2(Biobuf*, Prog*),
   _read5(Biobuf*, Prog*),
+	_read6(Biobuf*, Prog*),
+	_read7(Biobuf*, Prog*),
   _read8(Biobuf*, Prog*),
-  _readv(Biobuf*, Prog*);
-
+	_read9(Biobuf*, Prog*),
+	_readk(Biobuf*, Prog*),
+	_readq(Biobuf*, Prog*),
+	_readv(Biobuf*, Prog*),
+	_readu(Biobuf*, Prog*);
 
 typedef struct Obj	Obj;
 typedef struct Symtab	Symtab;
@@ -41,9 +53,16 @@ struct	Obj		/* functions to handle each 
 
 static Obj	obj[] =
 {			/* functions to identify and parse each type of obj */
+	[Obj68020]	"68020 .2",	_is2, _read2,
+	[ObjAmd64]	"amd64 .6",	_is6, _read6,
 	[ObjArm]	"arm .5",	_is5, _read5,
+	[ObjAlpha]	"alpha .7",	_is7, _read7,
 	[Obj386]	"386 .8",	_is8, _read8,
+	[ObjSparc]	"sparc .k",	_isk, _readk,
+	[ObjPower]	"power .q",	_isq, _readq,
 	[ObjMips]	"mips .v",	_isv, _readv,
+	[ObjSparc64]	"sparc64 .u",	_isu, _readu,
+	[ObjPower64]	"power64 .9",	_is9, _read9,
 	[Maxobjtype]	0, 0
 };
 
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: q.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: qdb.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: qobj.c
Only in ./libmach: setmach.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libmach/setmach.c /Volumes/Plan 9 - Dec 29/sys/src/libmach/setmach.c
--- ./libmach/setmach.c	2014-01-23 00:03:04.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libmach/setmach.c	2009-10-16 07:19:07.000000000 -0700
@@ -16,8 +16,10 @@ struct machtab
 	Machdata	*machdata;		/* machine functions */
 };
 
-extern	Mach		mmips, mi386, marm;
-extern	Machdata	mipsmach, i386mach, armmach;
+extern	Mach		mmips, msparc, m68020, mi386, mamd64,
+			marm, mmips2be, mmips2le, mpower, mpower64, malpha, msparc64;
+extern	Machdata	mipsmach, mipsmachle, sparcmach, m68020mach, i386mach,
+			armmach, mipsmach2le, powermach, alphamach, sparc64mach;
 
 /*
  *	machine selection table.  machines with native disassemblers should
@@ -26,18 +28,60 @@ extern	Machdata	mipsmach, i386mach, armm
  */
 Machtab	machines[] =
 {
+	{	"68020",			/*68020*/
+		F68020,
+		F68020B,
+		A68020,
+		&m68020,
+		&m68020mach,	},
+	{	"68020",			/*Next 68040 bootable*/
+		F68020,
+		FNEXTB,
+		A68020,
+		&m68020,
+		&m68020mach,	},
+	{	"mips2LE",			/*plan 9 mips2 little endian*/
+		FMIPS2LE,
+		0,
+		AMIPS,
+		&mmips2le,
+		&mipsmach2le, 	},
+	{	"mipsLE",				/*plan 9 mips little endian*/
+		FMIPSLE,
+		0,
+		AMIPS,
+		&mmips,
+		&mipsmachle, 	},
 	{	"mips",				/*plan 9 mips*/
 		FMIPS,
 		FMIPSB,
 		AMIPS,
 		&mmips,
 		&mipsmach, 	},
+	{	"mips2",			/*plan 9 mips2*/
+		FMIPS2BE,
+		FMIPSB,
+		AMIPS,
+		&mmips2be,
+		&mipsmach, 	},		/* shares debuggers with native mips */
 	{	"mipsco",			/*native mips - must follow plan 9*/
 		FMIPS,
 		FMIPSB,
 		AMIPSCO,
 		&mmips,
 		&mipsmach,	},
+	{	"sparc",			/*plan 9 sparc */
+		FSPARC,
+		FSPARCB,
+		ASPARC,
+		&msparc,
+		&sparcmach,	},
+	{	"sunsparc",			/*native sparc - must follow plan 9*/
+		FSPARC,
+		FSPARCB,
+		ASUNSPARC,
+		&msparc,
+		&sparcmach,	},
 	{	"386",				/*plan 9 386*/
 		FI386,
 		FI386B,
@@ -50,12 +94,42 @@ Machtab	machines[] =
 		AI8086,
 		&mi386,
 		&i386mach,	},
+	{	"amd64",			/*amd64*/
+		FAMD64,
+		FAMD64B,
+		AAMD64,
+		&mamd64,
+		&i386mach,	},
 	{	"arm",				/*ARM*/
 		FARM,
 		FARMB,
 		AARM,
 		&marm,
 		&armmach,	},
+	{	"power",			/*PowerPC*/
+		FPOWER,
+		FPOWERB,
+		APOWER,
+		&mpower,
+		&powermach,	},
+	{	"power64",			/*PowerPC*/
+		FPOWER64,
+		FPOWER64B,
+		APOWER64,
+		&mpower64,
+		&powermach,	},
+	{	"alpha",			/*Alpha*/
+		FALPHA,
+		FALPHAB,
+		AALPHA,
+		&malpha,
+		&alphamach,	},
+	{	"sparc64",			/*plan 9 sparc64 */
+		FSPARC64,
+		FSPARCB,			/* XXX? */
+		ASPARC64,
+		&msparc64,
+		&sparc64mach,	},
 	{	0		},		/*the terminator*/
 };
 
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: sparc64
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: sparc64.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: sparc64db.c
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmach: sparc64obj.c
Only in ./libmach: swap.8
Only in ./libmach: sym.8
Only in ./libmach: v.8
Only in ./libmach: vcodas.8
Only in ./libmach: vdb.8
Only in ./libmach: vobj.8
Only in ./libmemdraw: alloc.8
Only in ./libmemdraw: arc.8
Only in ./libmemdraw: cload.8
Only in ./libmemdraw: cmap.8
Only in ./libmemdraw: cread.8
Only in ./libmemdraw: defont.8
Only in ./libmemdraw: draw.8
Only in ./libmemdraw: ellipse.8
Only in ./libmemdraw: fillpoly.8
Only in ./libmemdraw: hwdraw.8
Only in ./libmemdraw: iprint.8
Only in ./libmemdraw: line.8
Only in ./libmemdraw: load.8
Only in ./libmemdraw: openmemsubfont.8
Only in ./libmemdraw: poly.8
Only in ./libmemdraw: read.8
Only in ./libmemdraw: string.8
Only in ./libmemdraw: subfont.8
Only in ./libmemdraw: unload.8
Only in ./libmemdraw: write.8
Only in ./libmemlayer: draw.8
Only in ./libmemlayer: lalloc.8
Only in ./libmemlayer: layerop.8
Only in ./libmemlayer: ldelete.8
Only in ./libmemlayer: lhide.8
Only in ./libmemlayer: line.8
Only in ./libmemlayer: load.8
Only in ./libmemlayer: lorigin.8
Only in ./libmemlayer: lsetrefresh.8
Only in ./libmemlayer: ltofront.8
Only in ./libmemlayer: ltorear.8
Only in ./libmemlayer: unload.8
Only in ./libmp/386: mpdigdiv.8
Only in ./libmp/386: mpvecadd.8
Only in ./libmp/386: mpvecdigmuladd.8
Only in ./libmp/386: mpvecdigmulsub.8
Only in ./libmp/386: mpvecsub.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libmp/mkfile /Volumes/Plan 9 - Dec 29/sys/src/libmp/mkfile
--- ./libmp/mkfile	2014-01-17 15:14:48.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libmp/mkfile	2011-04-30 13:05:58.000000000 -0700
@@ -1,5 +1,3 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
 DIRS=port $CPUS
@@ -8,7 +6,7 @@ default:V:	all
 
 install all:V:
 	for(i in port $objtype)@{
-		echo DIR: libmp/$i
+		echo $i
 		cd $i
 		mk $MKFLAGS $target
 	}
Only in ./libmp/port: betomp.8
Only in ./libmp/port: crt.8
Only in ./libmp/port: letomp.8
Only in ./libmp/port: mpadd.8
Only in ./libmp/port: mpaux.8
Only in ./libmp/port: mpcmp.8
Only in ./libmp/port: mpdiv.8
Only in ./libmp/port: mpexp.8
Only in ./libmp/port: mpextendedgcd.8
Only in ./libmp/port: mpfactorial.8
Only in ./libmp/port: mpfmt.8
Only in ./libmp/port: mpinvert.8
Only in ./libmp/port: mpleft.8
Only in ./libmp/port: mpmod.8
Only in ./libmp/port: mpmul.8
Only in ./libmp/port: mprand.8
Only in ./libmp/port: mpright.8
Only in ./libmp/port: mpsub.8
Only in ./libmp/port: mptobe.8
Only in ./libmp/port: mptoi.8
Only in ./libmp/port: mptole.8
Only in ./libmp/port: mptoui.8
Only in ./libmp/port: mptouv.8
Only in ./libmp/port: mptov.8
Only in ./libmp/port: mpveccmp.8
Only in ./libmp/port: strtomp.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libmp: power
Only in ./libndb: csgetval.8
Only in ./libndb: csipinfo.8
Only in ./libndb: dnsquery.8
Only in ./libndb: ipattr.8
Only in ./libndb: ndbaux.8
Only in ./libndb: ndbcache.8
Only in ./libndb: ndbcat.8
Only in ./libndb: ndbconcatenate.8
Only in ./libndb: ndbdiscard.8
Only in ./libndb: ndbfree.8
Only in ./libndb: ndbgetipaddr.8
Only in ./libndb: ndbgetval.8
Only in ./libndb: ndbhash.8
Only in ./libndb: ndbipinfo.8
Only in ./libndb: ndblookval.8
Only in ./libndb: ndbopen.8
Only in ./libndb: ndbparse.8
Only in ./libndb: ndbreorder.8
Only in ./libndb: ndbsubstitute.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/: liboventi
Only in ./libplumb: event.8
Only in ./libplumb: mesg.8
Only in ./libplumb: plumbsendtext.8
Only in ./libregexp: regaux.8
Only in ./libregexp: regcomp.8
Only in ./libregexp: regerror.8
Only in ./libregexp: regexec.8
Only in ./libregexp: regsub.8
Only in ./libregexp: rregexec.8
Only in ./libregexp: rregsub.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libscribble
Only in ./libsec/386: md5block.8
Only in ./libsec/386: sha1block.8
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./libsec/mkfile /Volumes/Plan 9 - Dec 29/sys/src/libsec/mkfile
--- ./libsec/mkfile	2014-01-17 15:15:29.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/libsec/mkfile	2005-12-12 14:28:17.000000000 -0800
@@ -1,5 +1,3 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
 DIRS=port $CPUS
@@ -8,7 +6,7 @@ default:V:	all
 
 install all:V:
 	for(i in port $objtype)@{
-		echo DIR: libsec/$i
+		echo $i
 		cd $i
 		mk $MKFLAGS $target
 	}
Only in ./libsec/port: aes.8
Only in ./libsec/port: blowfish.8
Only in ./libsec/port: decodepem.8
Only in ./libsec/port: des.8
Only in ./libsec/port: des3CBC.8
Only in ./libsec/port: des3ECB.8
Only in ./libsec/port: desCBC.8
Only in ./libsec/port: desECB.8
Only in ./libsec/port: desmodes.8
Only in ./libsec/port: dsaalloc.8
Only in ./libsec/port: dsagen.8
Only in ./libsec/port: dsaprimes.8
Only in ./libsec/port: dsaprivtopub.8
Only in ./libsec/port: dsasign.8
Only in ./libsec/port: dsaverify.8
Only in ./libsec/port: egalloc.8
Only in ./libsec/port: egdecrypt.8
Only in ./libsec/port: egencrypt.8
Only in ./libsec/port: eggen.8
Only in ./libsec/port: egprivtopub.8
Only in ./libsec/port: egsign.8
Only in ./libsec/port: egverify.8
Only in ./libsec/port: fastrand.8
Only in ./libsec/port: genprime.8
Only in ./libsec/port: genrandom.8
Only in ./libsec/port: gensafeprime.8
Only in ./libsec/port: genstrongprime.8
Only in ./libsec/port: hmac.8
Only in ./libsec/port: md4.8
Only in ./libsec/port: md5.8
Only in ./libsec/port: md5pickle.8
Only in ./libsec/port: nfastrand.8
Only in ./libsec/port: prng.8
Only in ./libsec/port: probably_prime.8
Only in ./libsec/port: rc4.8
Only in ./libsec/port: readcert.8
Only in ./libsec/port: rsaalloc.8
Only in ./libsec/port: rsadecrypt.8
Only in ./libsec/port: rsaencrypt.8
Only in ./libsec/port: rsafill.8
Only in ./libsec/port: rsagen.8
Only in ./libsec/port: rsaprivtopub.8
Only in ./libsec/port: sha1.8
Only in ./libsec/port: sha1pickle.8
Only in ./libsec/port: sha2_128.8
Only in ./libsec/port: sha2_64.8
Only in ./libsec/port: sha2block128.8
Only in ./libsec/port: sha2block64.8
Only in ./libsec/port: smallprimetest.8
Only in ./libsec/port: thumb.8
Only in ./libsec/port: tlshand.8
Only in ./libsec/port: x509.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libsec: power
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libstdio
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libsunrpc
Only in ./libthread: 386.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libthread: amd64.c
Only in ./libthread: channel.8
Only in ./libthread: chanprint.8
Only in ./libthread: create.8
Only in ./libthread: debug.8
Only in ./libthread: dial.8
Only in ./libthread: exec.8
Only in ./libthread: exit.8
Only in ./libthread: id.8
Only in ./libthread: iocall.8
Only in ./libthread: ioclose.8
Only in ./libthread: iodial.8
Only in ./libthread: ioopen.8
Only in ./libthread: ioproc.8
Only in ./libthread: ioread.8
Only in ./libthread: ioreadn.8
Only in ./libthread: iosleep.8
Only in ./libthread: iowrite.8
Only in ./libthread: kill.8
Only in ./libthread: lib.8
Only in ./libthread: main.8
Only in ./libthread: note.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libthread: power.c
Only in ./libthread: ref.8
Only in ./libthread: rendez.8
Only in ./libthread: sched.8
Only in /Volumes/Plan 9 - Dec 29/sys/src/libthread: xincamd64.s
Only in /Volumes/Plan 9 - Dec 29/sys/src/libthread: xincpower.s
Only in /Volumes/Plan 9 - Dec 29/sys/src/: libventi
Only in .: make_trace.txt
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./mkfile /Volumes/Plan 9 - Dec 29/sys/src/mkfile
--- ./mkfile	2014-01-18 14:30:15.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/mkfile	2008-05-09 15:24:50.000000000 -0700
@@ -1,57 +1,57 @@
-MKSHELL=$PLAN9/bin/rc
-
 </$objtype/mkfile
 
-# libs used by the kernel
-LIBS1=\
-	libmemlayer\
-	libmemdraw\
-	libdraw\
-	libip\
-	libc\
-	libmp\
-
-# libs used by the core cmds (cc, lex, ...)
-LIBS2=\
+LIBS=\
+	lib9p\
 	libString\
-	libregexp\
-	libbio\
-	libthread\
-	liblex\
-	libmach\
 	libauth\
 	libauthsrv\
-
-# libs used by cmd/disk
-LIBS3=\
+	libavl\
+	libbin\
+	libbio\
+	libc\
+	libcomplete\
+	libcontrol\
         libdisk\
-        lib9p\
-        libsec\
-
-# libs used by rio
-LIBS4=\
+	libdraw\
+	libflate\
         libframe\
+	libgeometry\
+	libhtml\
+	libhttpd\
+	libip\
+	liblex\
+	libmach\
+	libmemdraw\
+	libmemlayer\
+	libmp\
+	libndb\
+	liboventi\
         libplumb\
-        libcomplete\
-
-# libs used by aux/vga/db
-LIBS5=\
-        libndb
+	libregexp\
+	libscribble\
+	libsec\
+	libstdio\
+	libsunrpc\
+	libthread\
+	libventi\
 
 
-LIBS=$LIBS1 $LIBS2 $LIBS3 $LIBS4 $LIBS5
+CMDS=cmd\
+	games\
 
-CMDS=cmd
+SUBSYS=ape\
+	/acme\
 
 none:VQ:
-	echo mk all, install, clean, nuke, release, cmds, kernels, or libs
+	echo mk all, install, clean, nuke, release, kernels, or libs
 
 all install clean nuke:VQ:
-	for (i in $LIBS $CMDS 9/pc) @{
+	date
+	for (i in $LIBS $SUBSYS $CMDS) @{
 		cd $i
-                echo DIR: $i
 		mk $target
 	}
+	date
 
 installall:V:
 	echo "installall not supported"
@@ -64,29 +64,22 @@ release:V:
 	mk clean
 
 kernels:V:
-	for (i in 9/pc) @{
+	for (i in 9 boot) @{
 		cd $i
-                echo DIR: $i
 		mk clean
 		mk install
-	}
-
-cmds:V:
-       for (i in $CMDS) @{
-                cd $i
                 mk clean
-                echo DIR: $i
-                mk cmds
-                mk dirs
        }
 
 libs:V:
+	date
 	for (i in $LIBS) @{
 		cd $i
-                echo DIR: $i
 		mk clean
 		mk install
+		mk clean
 	}
+	date
 
 cleanlibs:V:
 	for (i in $LIBS) @{
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./mkfile.proto /Volumes/Plan 9 - Dec 29/sys/src/mkfile.proto
--- ./mkfile.proto	2014-01-22 23:56:28.000000000 -0800
+++ /Volumes/Plan 9 - Dec 29/sys/src/mkfile.proto	2012-09-20 16:11:02.000000000 -0700
@@ -2,16 +2,13 @@
 # common mkfile parameters shared by all architectures
 #
 
-OS=58v
-CPUS=386 mips arm
-CFLAGS=-FTVw -I/home/pad/plan9/$objtype/include -I/home/pad/plan9/sys/include
+OS=58qv
+CPUS=arm 386 power mips
+CFLAGS=-FTVw
 LEX=lex
 YACC=yacc
 MK=/bin/mk
 
-# does not seem to work though :(
-MKSHELL=$PLAN9/bin/rc
-
 # recursive mk will have these set from the parent
 # this is never what we want.  clear them
 
Only in .: pfff.log
Only in .: skip_list.txt
