
<<[[defmask()]] if ipv6>>=
else {
    if(ipcmp(ip, v6loopback) == 0)
        return IPallbits;
    else if(memcmp(ip, v6linklocal, v6llpreflen) == 0)
        return v6linklocalmask;
    else if(memcmp(ip, v6solicitednode, v6snpreflen) == 0)
        return v6solicitednodemask;
    else if(memcmp(ip, v6multicast, v6mcpreflen) == 0)
        return v6multicastmask;
    return IPallbits;
}
@

<<[[Ipifc(user)]] ipv6 fields>>=
    Ipv6rp	rp;
@

<<[[Ipifc(user)]] ipv6 fields>>=
    uchar	sendra6;		/* on == send router adv */
    uchar	recvra6;		/* on == rcv router adv */
@

<<[[Fs(kernel)]] ipv6 fields>>=
  v6params  *v6p;
  Route *v6root[1<<Lroot];  /* v6 routing forest */
@

<<[[IP(kernel)]] ipv6 fields>>=
  QLock   fraglock6;
  Fragment6*  flisthead6;
  Fragment6*  fragfree6;
  Ref   id6;
@

<<[[Ipifc(kernel)]] ipv6 fields>>=
uchar sendra6;  /* flag: send router advs on this ifc */
uchar recvra6;  /* flag: recv router advs on this ifc */
@
% mimic user side, ipv6 stuff?


% ip_init -> <>
<<function ip_init_6>>=
void
ip_init_6(Fs *f)
{
    v6params *v6p;

    v6p = smalloc(sizeof(v6params));

    v6p->rp.mflag       = 0;        /* default not managed */
    v6p->rp.oflag       = 0;
    v6p->rp.maxraint    = 600000;   /* millisecs */
    v6p->rp.minraint    = 200000;
    v6p->rp.linkmtu     = 0;        /* no mtu sent */
    v6p->rp.reachtime   = 0;
    v6p->rp.rxmitra     = 0;
    v6p->rp.ttl     = MAXTTL;
    v6p->rp.routerlt    = 3 * v6p->rp.maxraint;

    v6p->hp.rxmithost   = 1000;     /* v6 RETRANS_TIMER */

    v6p->cdrouter       = -1;

    f->v6p          = v6p;
}
@


<<struct Ipv6rp>>=
/* default values, one per stack */
struct Ipv6rp
{
    int	mflag;
    int	oflag;
    int 	maxraint;
    int	minraint;
    int	linkmtu;
    int	reachtime;
    int	rxmitra;
    int	ttl;
    int	routerlt;	
};
@

<<macro ISIPV6MCAST>>=
#define ISIPV6MCAST(addr)	((addr)[0] == 0xff)
@

<<macro ISIPV6LINKLOCAL>>=
#define ISIPV6LINKLOCAL(addr) ((addr)[0] == 0xfe && ((addr)[1] & 0xc0) == 0x80)
@

<<enum _anon_ (include/net/ip.h)>>=
/*
 * ipv6 constants
 * `ra' is `router advertisement', `rs' is `router solicitation'.
 * `na' is `neighbour advertisement'.
 */
enum {
    IPV6HDR_LEN	= 40,

    /* neighbour discovery option types */
    V6nd_srclladdr	= 1,
    V6nd_targlladdr	= 2,
    V6nd_pfxinfo	= 3,
    V6nd_redirhdr	= 4,
    V6nd_mtu	= 5,
    /* new since rfc2461; see iana.org/assignments/icmpv6-parameters */
    V6nd_home	= 8,
    V6nd_srcaddrs	= 9,		/* rfc3122 */
    V6nd_ip		= 17,
    /* /lib/rfc/drafts/draft-jeong-dnsop-ipv6-dns-discovery-12.txt */
    V6nd_rdns	= 25,
    /* plan 9 extensions */
    V6nd_9fs	= 250,
    V6nd_9auth	= 251,

    /* Router constants (all times in ms.) */
    Maxv6initraintvl= 16000,
    Maxv6initras	= 3,
    Maxv6finalras	= 3,
    Minv6interradelay= 3000,
    Maxv6radelay	= 500,

    /* Host constants */
    Maxv6rsdelay	= 1000,
    V6rsintvl	= 4000,
    Maxv6rss	= 3,

    /* Node constants */
    Maxv6mcastrss	= 3,
    Maxv6unicastrss	= 3,
    Maxv6anycastdelay= 1000,
    Maxv6na		= 3,
    V6reachabletime	= 30000,
    V6retranstimer	= 1000,
    V6initprobedelay= 5000,
};
@

<<struct Ip6hdr>>=
/* V6 header on the wire */
struct Ip6hdr {
    uchar	vcf[4];		/* version:4, traffic class:8, flow label:20 */
    uchar	ploadlen[2];	/* payload length: packet length - 40 */
    uchar	proto;		/* next header type */
    uchar	ttl;		/* hop limit */
    uchar	src[IPaddrlen];	/* source address */
    uchar	dst[IPaddrlen];	/* destination address */
    uchar	payload[];
};
@

<<struct Icmp6hdr>>=
/*
 *  user-level icmpv6 with control message "headers"
 */
struct Icmp6hdr {
    uchar	_0_[8];
    uchar	laddr[IPaddrlen];	/* local address */
    uchar	raddr[IPaddrlen];	/* remote address */
};
@


<<function equivip6>>=
bool
equivip6(uchar *a, uchar *b)
{
    int i;

    for(i = 0; i < IPaddrlen; i++)
        if(a[i] != b[i])
            return false;
    return true;
}
@


<<global v6loopback>>=
static uchar v6loopback[IPaddrlen] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0x01
};
@

<<global v6linklocal>>=
static uchar v6linklocal[IPaddrlen] = {
    0xfe, 0x80, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global v6linklocalmask>>=
static uchar v6linklocalmask[IPaddrlen] = {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global v6llpreflen>>=
static int v6llpreflen = 8;	/* link-local prefix length in bytes */
@

<<global v6multicast>>=
static uchar v6multicast[IPaddrlen] = {
    0xff, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global v6multicastmask>>=
static uchar v6multicastmask[IPaddrlen] = {
    0xff, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global v6mcpreflen>>=
static int v6mcpreflen = 1;	/* multicast prefix length */
@

<<global v6solicitednode>>=
static uchar v6solicitednode[IPaddrlen] = {
    0xff, 0x02, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0x01,
    0xff, 0, 0, 0
};
@

<<global v6solicitednodemask>>=
static uchar v6solicitednodemask[IPaddrlen] = {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0x0, 0x0, 0x0
};
@

<<global v6snpreflen>>=
static int v6snpreflen = 13;
@



<<function v6tov4>>=
errorneg1
v6tov4(uchar *v4, uchar *v6)
{
    if(v6[0] == 0
    && v6[1] == 0
    && v6[2] == 0
    && v6[3] == 0
    && v6[4] == 0
    && v6[5] == 0
    && v6[6] == 0
    && v6[7] == 0
    && v6[8] == 0
    && v6[9] == 0
    && v6[10] == 0xff
    && v6[11] == 0xff)
    {
        v4[0] = v6[12];
        v4[1] = v6[13];
        v4[2] = v6[14];
        v4[3] = v6[15];
        return OK_0;
    } else {
        memset(v4, 0, 4);
        if(memcmp(v6, IPnoaddr, IPaddrlen) == 0)
            return OK_0;
        return ERROR_NEG1;
    }
}
@


<<[[ip_init()]] ipv6 init>>=
ip_init_6(f);
@

<<[[initfrag()]] locals>>=
    Fragment6 *fq6, *eq6;
@


<<[[initfrag()]] ipv6 init fragfree6>>=
    ip->fragfree6 = (Fragment6*)malloc(sizeof(Fragment6) * size);
    if(ip->fragfree6 == nil)
        panic("initfrag");

    eq6 = &ip->fragfree6[size];
    for(fq6 = ip->fragfree6; fq6 < eq6; fq6++)
        fq6->next = fq6+1;

    ip->fragfree6[size-1].next = nil;
@

<<struct Fragment6>>=
struct Fragment6
{
  Block*  blist;
  Fragment6*  next;
  uchar   src[IPaddrlen];
  uchar   dst[IPaddrlen];
  uint  id;
  ulong   age;
};
@

<<struct v6router>>=
/* one per default router known to host */
struct v6router {
  uchar inuse;
  Ipifc *ifc;
  int ifcid;
  uchar routeraddr[IPaddrlen];
  long  ltorigin;
  Routerparams  rp;
};
@

<<struct v6params>>=
struct v6params
{
  Routerparams  rp;   /* v6 params, one copy per node now */
  Hostparams  hp;
  v6router  v6rlist[3]; /* max 3 default routers, currently */
  int   cdrouter; /* uses only v6rlist[cdrouter] if   */
          /* cdrouter >= 0. */
};
@

<<struct V6route>>=
struct V6route
{
  ulong address[IPllen];
  ulong endaddress[IPllen];
  uchar gate[IPaddrlen];
};
@

<<function etherread6>>=
/*
 *  process to read from the ethernet, IPv6
 */
static void
etherread6(void *a)
{
    Ipifc *ifc;
    Block *bp;
    Etherrock *er;

    ifc = a;
    er = ifc->arg;
    er->read6p = up;    /* hide identity under a rock for unbind */
    if(waserror()){
        er->read6p = 0;
        pexit("hangup", 1);
    }
    for(;;){
        bp = devtab[er->mchan6->type]->bread(er->mchan6, ifc->maxtu, 0);
        if(!canrlock(ifc)){
            freeb(bp);
            continue;
        }
        if(waserror()){
            runlock(ifc);
            nexterror();
        }
        ifc->in++;
        bp->rp += ifc->m->hsize;
        if(ifc->lifc == nil)
            freeb(bp);
        else
            ipiput6(er->f, ifc, bp);
        runlock(ifc);
        poperror();
    }
}
@

<<global v6freelist>>=
static Route*   v6freelist;
@

<<macro V6H>>=
#define V6H(a)  (((a)[IPllen-1] & 0x07ffffff)>>(32-Lroot-5))
@

<<function v6addroute>>=
//#define ISDFLT(a, mask, tag) ((ipcmp((a),v6Unspecified)==0) && (ipcmp((mask),v6Unspecified)==0) && (strcmp((tag), "ra")!=0))

void
v6addroute(Fs *f, char *tag, uchar *a, uchar *mask, uchar *gate, int type)
{
    Route *p;
    ulong sa[IPllen], ea[IPllen];
    ulong x, y;
    int h, eh;

    /*
    if(ISDFLT(a, mask, tag))
        f->v6p->cdrouter = -1;
    */


    for(h = 0; h < IPllen; h++){
        x = nhgetl(a+4*h);
        y = nhgetl(mask+4*h);
        sa[h] = x & y;
        ea[h] = x | ~y;
    }

    eh = V6H(ea);
    for(h = V6H(sa); h <= eh; h++) {
        p = allocroute(type);
        memmove(p->v6.address, sa, IPaddrlen);
        memmove(p->v6.endaddress, ea, IPaddrlen);
        memmove(p->v6.gate, gate, IPaddrlen);
        memmove(p->tag, tag, sizeof(p->tag));

        wlock(&routelock);
        addnode(f, &f->v6root[h], p);
        while(p = f->queue) {
            f->queue = p->mid;
            walkadd(f, &f->v6root[h], p->left);
            freeroute(p);
        }
        wunlock(&routelock);
    }
    v6routegeneration++;

    ipifcaddroute(f, 0, a, mask, gate, type);
}
@

<<function v6delroute>>=
void
v6delroute(Fs *f, uchar *a, uchar *mask, int dolock)
{
    Route **r, *p;
    Route rt;
    int h, eh;
    ulong x, y;

    for(h = 0; h < IPllen; h++){
        x = nhgetl(a+4*h);
        y = nhgetl(mask+4*h);
        rt.v6.address[h] = x & y;
        rt.v6.endaddress[h] = x | ~y;
    }
    rt.type = 0;

    eh = V6H(rt.v6.endaddress);
    for(h=V6H(rt.v6.address); h<=eh; h++) {
        if(dolock)
            wlock(&routelock);
        r = looknode(&f->v6root[h], &rt);
        if(r) {
            p = *r;
            if(--(p->ref) == 0){
                *r = 0;
                addqueue(&f->queue, p->left);
                addqueue(&f->queue, p->mid);
                addqueue(&f->queue, p->right);
                freeroute(p);
                while(p = f->queue) {
                    f->queue = p->mid;
                    walkadd(f, &f->v6root[h], p->left);
                    freeroute(p);
                }
            }
        }
        if(dolock)
            wunlock(&routelock);
    }
    v6routegeneration++;

    ipifcremroute(f, 0, a, mask);
}
@

<<function v6lookup>>=
Route*
v6lookup(Fs *f, uchar *a, Conv *c)
{
    Route *p, *q;
    ulong la[IPllen];
    int h;
    ulong x, y;
    uchar gate[IPaddrlen];
    Ipifc *ifc;

    if(memcmp(a, v4prefix, IPv4off) == 0){
        q = v4lookup(f, a+IPv4off, c);
        if(q != nil)
            return q;
    }

    if(c != nil && c->r != nil && c->r->ifc != nil && c->rgen == v6routegeneration)
        return c->r;

    for(h = 0; h < IPllen; h++)
        la[h] = nhgetl(a+4*h);

    q = 0;
    for(p=f->v6root[V6H(la)]; p;){
        for(h = 0; h < IPllen; h++){
            x = la[h];
            y = p->v6.address[h];
            if(x == y)
                continue;
            if(x < y){
                p = p->left;
                goto next;
            }
            break;
        }
        for(h = 0; h < IPllen; h++){
            x = la[h];
            y = p->v6.endaddress[h];
            if(x == y)
                continue;
            if(x > y){
                p = p->right;
                goto next;
            }
            break;
        }
        q = p;
        p = p->mid;
next:       ;
    }

    if(q && (q->ifc == nil || q->ifcid != q->ifc->ifcid)){
        if(q->type & Rifc) {
            for(h = 0; h < IPllen; h++)
                hnputl(gate+4*h, q->v6.address[h]);
            ifc = findipifc(f, gate, q->type);
        } else
            ifc = findipifc(f, q->v6.gate, q->type);
        if(ifc == nil)
            return nil;
        q->ifc = ifc;
        q->ifcid = ifc->ifcid;
    }
    if(c != nil){
        c->r = q;
        c->rgen = v6routegeneration;
    }

    return q;
}
@

<<function ipifcra6>>=
char*
ipifcra6(Ipifc *ifc, char **argv, int argc)
{
    int i, argsleft, vmax = ifc->rp.maxraint, vmin = ifc->rp.minraint;

    argsleft = argc - 1;
    i = 1;

    if(argsleft % 2 != 0)
        return Ebadarg;

    while (argsleft > 1) {
        if(strcmp(argv[i], "recvra") == 0)
            ifc->recvra6 = (atoi(argv[i+1]) != 0);
        else if(strcmp(argv[i], "sendra") == 0)
            ifc->sendra6 = (atoi(argv[i+1]) != 0);
        else if(strcmp(argv[i], "mflag") == 0)
            ifc->rp.mflag = (atoi(argv[i+1]) != 0);
        else if(strcmp(argv[i], "oflag") == 0)
            ifc->rp.oflag = (atoi(argv[i+1]) != 0);
        else if(strcmp(argv[i], "maxraint") == 0)
            ifc->rp.maxraint = atoi(argv[i+1]);
        else if(strcmp(argv[i], "minraint") == 0)
            ifc->rp.minraint = atoi(argv[i+1]);
        else if(strcmp(argv[i], "linkmtu") == 0)
            ifc->rp.linkmtu = atoi(argv[i+1]);
        else if(strcmp(argv[i], "reachtime") == 0)
            ifc->rp.reachtime = atoi(argv[i+1]);
        else if(strcmp(argv[i], "rxmitra") == 0)
            ifc->rp.rxmitra = atoi(argv[i+1]);
        else if(strcmp(argv[i], "ttl") == 0)
            ifc->rp.ttl = atoi(argv[i+1]);
        else if(strcmp(argv[i], "routerlt") == 0)
            ifc->rp.routerlt = atoi(argv[i+1]);
        else
            return Ebadarg;

        argsleft -= 2;
        i += 2;
    }

    /* consistency check */
    if(ifc->rp.maxraint < ifc->rp.minraint) {
        ifc->rp.maxraint = vmax;
        ifc->rp.minraint = vmin;
        return Ebadarg;
    }
    return nil;
}
@


<<enum _anon_ (kernel/network/ip/ipifc.c)3>>=
enum {
    unknownv6,      /* UGH */
//  multicastv6,
    unspecifiedv6,
    linklocalv6,
    globalv6,
};
@

<<function v6addrtype>>=
int
v6addrtype(uchar *addr)
{
    if(isv4(addr) || ipcmp(addr, IPnoaddr) == 0)
        return unknownv6;
    else if(islinklocal(addr) ||
        isv6mcast(addr) && (addr[1] & 0xF) <= Link_local_scop)
        return linklocalv6;
    else
        return globalv6;
}
@

<<macro v6addrcurr>>=
#define v6addrcurr(lifc) ((lifc)->preflt == ~0L || \
            (lifc)->origint + (lifc)->preflt >= NOW/1000)
@

<<function findprimaryipv6>>=
static void
findprimaryipv6(Fs *f, uchar *local)
{
    int atype, atypel;
    Conv **cp, **e;
    Ipifc *ifc;
    Iplifc *lifc;

    ipmove(local, v6Unspecified);
    atype = unspecifiedv6;

    /*
     * find "best" (global > link local > unspecified)
     * local address; address must be current.
     */
    e = &f->ipifc->conv[f->ipifc->nc];
    for(cp = f->ipifc->conv; cp < e; cp++){
        if(*cp == 0)
            continue;
        ifc = (Ipifc*)(*cp)->ptcl;
        for(lifc = ifc->lifc; lifc; lifc = lifc->next){
            atypel = v6addrtype(lifc->local);
            if(atypel > atype && v6addrcurr(lifc)) {
                ipmove(local, lifc->local);
                atype = atypel;
                if(atype == globalv6)
                    return;
            }
        }
    }
}
@

<<function ipv6local>>=
/*
 *  return first v6 address associated with an interface
 */
int
ipv6local(Ipifc *ifc, uchar *addr)
{
    Iplifc *lifc;

    for(lifc = ifc->lifc; lifc; lifc = lifc->next){
        if(!isv4(lifc->local) && !(lifc->tentative)){
            ipmove(addr, lifc->local);
            return 1;
        }
    }
    return 0;
}
@

<<function ipv6anylocal>>=
int
ipv6anylocal(Ipifc *ifc, uchar *addr)
{
    Iplifc *lifc;

    for(lifc = ifc->lifc; lifc; lifc = lifc->next){
        if(!isv4(lifc->local)){
            ipmove(addr, lifc->local);
            return SRC_UNI;
        }
    }
    return SRC_UNSPEC;
}
@

<<function ipifcadd6>>=
char*
ipifcadd6(Ipifc *ifc, char**argv, int argc)
{
    int plen = 64;
    long origint = NOW / 1000, preflt = ~0L, validlt = ~0L;
    char addr[40], preflen[6];
    char *params[3];
    uchar autoflag = 1, onlink = 1;
    uchar prefix[IPaddrlen];
    Iplifc *lifc;

    switch(argc) {
    case 7:
        preflt = atoi(argv[6]);
        /* fall through */
    case 6:
        validlt = atoi(argv[5]);
        /* fall through */
    case 5:
        autoflag = atoi(argv[4]);
        /* fall through */
    case 4:
        onlink = atoi(argv[3]);
        /* fall through */
    case 3:
        plen = atoi(argv[2]);
        /* fall through */
    case 2:
        break;
    default:
        return Ebadarg;
    }

    if (parseip(prefix, argv[1]) != 6 || validlt < preflt || plen < 0 ||
        plen > 64 || islinklocal(prefix))
        return Ebadarg;

    lifc = smalloc(sizeof(Iplifc));
    lifc->onlink = (onlink != 0);
    lifc->autoflag = (autoflag != 0);
    lifc->validlt = validlt;
    lifc->preflt = preflt;
    lifc->origint = origint;

    /* issue "add" ctl msg for v6 link-local addr and prefix len */
    if(!ifc->m->pref2addr)
        return Ebadarg;
    ifc->m->pref2addr(prefix, ifc->mac);    /* mac → v6 link-local addr */
    snprint(addr, sizeof addr, "%I", prefix);
    snprint(preflen, sizeof preflen, "/%d", plen);
    params[0] = "add";
    params[1] = addr;
    params[2] = preflen;

    return ipifcadd(ifc, params, 3, 0, lifc);
}
@


<<struct Udp6hdr>>=
struct Udp6hdr {
    uchar viclfl[4];
    uchar len[2];
    uchar nextheader;
    uchar hoplimit;
    uchar udpsrc[IPaddrlen];
    uchar udpdst[IPaddrlen];

    /* udp header */
    uchar   udpsport[2];    /* Source port */
    uchar   udpdport[2];    /* Destination port */
    uchar   udplen[2];  /* data length */
    uchar   udpcksum[2];    /* Checksum */
};
@
