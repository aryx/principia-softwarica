\section{[[include/net/]]}

\subsection*{[[include/net/ip.h]]}

<<enum _anon_>>=
enum 
{
    <<constant IPaddrlen>>
    <<constant IPv4addrlen>>
    <<constant IPv4off>>

    IPllen=		4,
    IPV4HDR_LEN=	20,

    /* vihl & vcf[0] values */
    IP_VER4= 	0x40,
    IP_VER6=	0x60,
};
@

<<constant Udphdrsize>>=
/*
 *  user level udp headers with control message "headers"
 */
#define Udphdrsize 52 /* size of a Udphdr */
@
% for some user side programs


%-------------------------------------------------------------

<<include/net/ip.h>>=
#pragma	src	"/sys/src/libip"
#pragma	lib	"libip.a"

<<enum _anon_>>

<<typedef ipv4>>
<<typedef ipaddr>>
<<typedef iplong>>


// forward decl
typedef struct Ipifc Ipifc;
typedef struct Iplifc Iplifc;
typedef struct Ipv6rp Ipv6rp;
typedef struct Ip6hdr Ip6hdr;
typedef struct Icmp6hdr Icmp6hdr;
typedef struct Udphdr Udphdr;

/*
 *  for reading /net/ipifc
 */

<<struct Iplifc (user)>>

<<struct Ipv6rp>>

<<struct Ipifc (user)>>

<<macro ISIPV6MCAST>>
<<macro ISIPV6LINKLOCAL>>

<<enum _anon_ (include/net/ip.h)>>


<<struct Ip6hdr>>

<<struct Icmp6hdr>>

<<constant Udphdrsize>>

<<struct Udphdr (user)>>

uchar*	defmask(ipaddr);
void	maskip(ipaddr, ipaddr, ipaddr);
int		eipfmt(Fmt*);
bool	isv4(ipaddr);
vlong	parseip(uchar*, char*);
vlong	parseipmask(uchar*, char*);
char*	v4parseip(uchar*, char*);
//char*	v4parsecidr(uchar*, uchar*, char*);
int	parseether(uchar*, char*);
int	myipaddr(uchar*, char*);
int	myetheraddr(uchar*, char*);
int	equivip4(uchar*, uchar*);
int	equivip6(uchar*, uchar*);

Ipifc*	readipifc(char*, Ipifc*, int);

void	hnputs(void*, ushort);
void	hnputl(void*, uint);
void	hnputv(void*, uvlong);
ushort	nhgets(void*);
uint	nhgetl(void*);
uvlong	nhgetv(void*);

ushort	ptclbsum(uchar*, int);

int		v6tov4(uchar*, uchar*);
void	v4tov6(uchar*, uchar*);

<<macro ipcmp>>
<<macro ipmove>>

extern ipaddr IPv4bcast;
extern ipaddr IPv4bcastobs;
extern ipaddr IPv4allsys;
extern ipaddr IPv4allrouter;
extern ipaddr IPnoaddr;
extern ipaddr v4prefix;
extern ipaddr IPallbits;

<<macro CLASS>>

#pragma	varargck	type	"I"	uchar*
#pragma	varargck	type	"V"	uchar*
#pragma	varargck	type	"E"	uchar*
#pragma	varargck	type	"M"	uchar*
@


\section{[[lib_networking/libip/]]}

\subsection*{[[lib_networking/libip/parseether.c]]}


%-------------------------------------------------------------

<<lib_networking/libip/parseether.c>>=
#include <u.h>
#include <libc.h>

<<function parseether>>
@


\subsection*{[[lib_networking/libip/parseip.c]]}

<<function ipcharok>>=
static int
ipcharok(int c)
{
    return c == '.' || c == ':' || isascii(c) && isxdigit(c);
}
@

<<function delimchar>>=
static bool
delimchar(int c)
{
    if(c == '\0')
        return true;
    if(c == '.' || c == ':' || isascii(c) && isalnum(c))
        return false;
    return true;
}
@


<<function parseipmask>>=
/*
 *  hack to allow ip v4 masks to be entered in the old
 *  style
 */
vlong
parseipmask(uchar *to, char *from)
{
    int i, w;
    vlong x;
    uchar *p;

    if(*from == '/'){
        /* as a number of prefix bits */
        i = atoi(from+1);
        if(i < 0)
            i = 0;
        if(i > 128)
            i = 128;
        w = i;
        memset(to, 0, IPaddrlen);
        for(p = to; i >= 8; i -= 8)
            *p++ = 0xff;
        if(i > 0)
            *p = ~((1<<(8-i))-1);
        x = nhgetl(to+IPv4off);
        /*
         * identify as ipv6 if the mask is inexpressible as a v4 mask
         * (because it has too few mask bits).  Arguably, we could
         * always return 6 here.
         */
        if (w < 8*(IPaddrlen-IPv4addrlen))
            return 6;
    } else {
        /* as a straight v4 bit mask */
        x = parseip(to, from);
        if (x != -1)
            x = (ulong)nhgetl(to + IPv4off);
        if(memcmp(to, v4prefix, IPv4off) == 0)
            memset(to, 0xff, IPv4off);
    }
    return x;
}
@
% >> >> >> >>

%<<function v4parsecidr>>=
%/*
% *  parse a v4 ip address/mask in cidr format
% */
%char*
%v4parsecidr(uchar *addr, uchar *mask, char *from)
%{
%    int i;
%    char *p;
%    uchar *a;
%
%    p = v4parseip(addr, from);
%
%    if(*p == '/'){
%        /* as a number of prefix bits */
%        i = strtoul(p+1, &p, 0);
%        if(i > 32)
%            i = 32;
%        memset(mask, 0, IPv4addrlen);
%        for(a = mask; i >= 8; i -= 8)
%            *a++ = 0xff;
%        if(i > 0)
%            *a = ~((1<<(8-i))-1);
%    } else 
%        memcpy(mask, defmask(addr), IPv4addrlen);
%    return p;
%}
%@
% >> >> >> >> >> >>

%-------------------------------------------------------------

<<lib_networking/libip/parseip.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include <ip.h>

<<function v4parseip>>

<<function ipcharok>>

<<function delimchar>>

<<function parseip>>

<<function parseipmask>>

@


\subsection*{[[lib_networking/libip/myetheraddr.c]]}



%-------------------------------------------------------------

<<lib_networking/libip/myetheraddr.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<function myetheraddr>>
@


\subsection*{[[lib_networking/libip/myipaddr.c]]}

<<global loopbacknet>>=
static ipaddr loopbacknet = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,
    127, 0, 0, 0
};
@

<<global loopbackmask>>=
static ipaddr loopbackmask = {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0, 0, 0
};
@



%-------------------------------------------------------------

<<lib_networking/libip/myipaddr.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<global loopbacknet>>
<<global loopbackmask>>

<<function myipaddr>>
@


\subsection*{[[lib_networking/libip/eipfmt.c]]}

<<enum _anon_ (lib_networking/libip/eipfmt.c)>>=
enum
{
    Isprefix= 16,
};
@

<<global prefixvals>>=
uchar prefixvals[256] =
{
[0x00] 0 | Isprefix,
[0x80] 1 | Isprefix,
[0xC0] 2 | Isprefix,
[0xE0] 3 | Isprefix,
[0xF0] 4 | Isprefix,
[0xF8] 5 | Isprefix,
[0xFC] 6 | Isprefix,
[0xFE] 7 | Isprefix,
[0xFF] 8 | Isprefix,
};
@



%-------------------------------------------------------------

<<lib_networking/libip/eipfmt.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<enum _anon_ (lib_networking/libip/eipfmt.c)>>

<<global prefixvals>>

<<function eipfmt>>
@


\subsection*{[[lib_networking/libip/equivip.c]]}


%-------------------------------------------------------------

<<lib_networking/libip/equivip.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<function equivip4>>

<<function equivip6>>
@


\subsection*{[[lib_networking/libip/ipaux.c]]}


<<global IPv4allsys>>=
ipaddr IPv4allsys = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,

    0xe0, 0, 0, 0x01
};
@

<<global IPv4allrouter>>=
ipaddr IPv4allrouter = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,

    0xe0, 0, 0, 0x02
};
@

<<global IPallbits>>=
ipaddr IPallbits = {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff
};
@






%-------------------------------------------------------------

<<lib_networking/libip/ipaux.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<global IPv4bcast>>
<<global IPv4allsys>>
<<global IPv4allrouter>>
<<global IPallbits>>
<<global IPnoaddr>>

<<global v4prefix>>

<<function isv4>>

<<function v4tov6>>

<<function v6tov4>>
@


\subsection*{[[lib_networking/libip/bo.c]]}

% s = short, l = long, v = vlong

<<function hnputv>>=
void
hnputv(void *p, uvlong v)
{
    uchar *a;

    a = p;
    a[0] = v>>56;
    a[1] = v>>48;
    a[2] = v>>40;
    a[3] = v>>32;
    a[4] = v>>24;
    a[5] = v>>16;
    a[6] = v>>8;
    a[7] = v;
}
@

<<function hnputl>>=
void
hnputl(void *p, uint v)
{
    uchar *a;

    a = p;
    a[0] = v>>24;
    a[1] = v>>16;
    a[2] = v>>8;
    a[3] = v;
}
@

<<function hnputs>>=
void
hnputs(void *p, ushort v)
{
    uchar *a;

    a = p;
    a[0] = v>>8;
    a[1] = v;
}
@

<<function nhgetv>>=
uvlong
nhgetv(void *p)
{
    uchar *a;
    uvlong v;

    a = p;
    v = (uvlong)a[0]<<56;
    v |= (uvlong)a[1]<<48;
    v |= (uvlong)a[2]<<40;
    v |= (uvlong)a[3]<<32;
    v |= a[4]<<24;
    v |= a[5]<<16;
    v |= a[6]<<8;
    v |= a[7]<<0;
    return v;
}
@
% >> >> >> >> >> >> >> >>

<<function nhgetl>>=
uint
nhgetl(void *p)
{
    uchar *a;

    a = p;
    return (a[0]<<24)|(a[1]<<16)|(a[2]<<8)|(a[3]<<0);
}
@
% >> >> >> >> >> >> >>

<<function nhgets>>=
ushort
nhgets(void *p)
{
    uchar *a;

    a = p;
    return (a[0]<<8)|(a[1]<<0);
}
@
% >> >>

%-------------------------------------------------------------

% bo? byte order probably

<<lib_networking/libip/bo.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<function hnputv>>

<<function hnputl>>

<<function hnputs>>

<<function nhgetv>>

<<function nhgetl>>

<<function nhgets>>
@


\subsection*{[[lib_networking/libip/classmask.c]]}



%-------------------------------------------------------------

<<lib_networking/libip/classmask.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<global classmask>>

<<global v6loopback>>

<<global v6linklocal>>
<<global v6linklocalmask>>
<<global v6llpreflen>>

<<global v6multicast>>
<<global v6multicastmask>>
<<global v6mcpreflen>>

<<global v6solicitednode>>
<<global v6solicitednodemask>>
<<global v6snpreflen>>

<<function defmask>>

<<function maskip>>
@


\subsection*{[[lib_networking/libip/ptclbsum.c]]}

<<global endian>>=
static	short	endian	= 1;
@

<<global aendian>>=
static	uchar*	aendian	= (uchar*)&endian;
@

<<constant LITTLE>>=
#define	LITTLE	*aendian
@

<<function ptclbsum>>=
ushort
ptclbsum(uchar *addr, int len)
{
    ulong losum, hisum, mdsum, x;
    ulong t1, t2;

    losum = 0;
    hisum = 0;
    mdsum = 0;

    x = 0;
    if((uintptr)addr & 1) {
        if(len) {
            hisum += addr[0];
            len--;
            addr++;
        }
        x = 1;
    }
    while(len >= 16) {
        t1 = *(ushort*)(addr+0);
        t2 = *(ushort*)(addr+2);	mdsum += t1;
        t1 = *(ushort*)(addr+4);	mdsum += t2;
        t2 = *(ushort*)(addr+6);	mdsum += t1;
        t1 = *(ushort*)(addr+8);	mdsum += t2;
        t2 = *(ushort*)(addr+10);	mdsum += t1;
        t1 = *(ushort*)(addr+12);	mdsum += t2;
        t2 = *(ushort*)(addr+14);	mdsum += t1;
        mdsum += t2;
        len -= 16;
        addr += 16;
    }
    while(len >= 2) {
        mdsum += *(ushort*)addr;
        len -= 2;
        addr += 2;
    }
    if(x) {
        if(len)
            losum += addr[0];
        if(LITTLE)
            losum += mdsum;
        else
            hisum += mdsum;
    } else {
        if(len)
            hisum += addr[0];
        if(LITTLE)
            hisum += mdsum;
        else
            losum += mdsum;
    }

    losum += hisum >> 8;
    losum += (hisum & 0xff) << 8;
    while(hisum = losum>>16)
        losum = hisum + (losum & 0xffff);

    return losum & 0xffff;
}
@


%-------------------------------------------------------------

<<lib_networking/libip/ptclbsum.c>>=
#include	<u.h>
#include	<libc.h>
#include	<ip.h>

<<global endian>>
<<global aendian>>
<<constant LITTLE>>

<<function ptclbsum>>
@


\subsection*{[[lib_networking/libip/readipifc.c]]}


%-------------------------------------------------------------

<<lib_networking/libip/readipifc.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include <ip.h>

<<function findfield>>

<<function _readipifc>>

<<function _freeifc>>

<<function readipifc>>
@


\section{[[lib_networking/libip/tests/]]}

\subsection*{[[lib_networking/libip/tests/testreadipifc.c]]}


%-------------------------------------------------------------

<<lib_networking/libip/tests/testreadipifc.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<function main>>
@





\section{[[kernel/network/ip/]]}

\subsection*{[[kernel/network/ip/ip.h]]}

<<constant Nhash>>=
Nhash=    64,
@


<<enum _anon_ (kernel/network/ip/ip.h)>>=
enum
{
  Addrlen=  64,
  <<constant Maxproto>>
  <<constant Nhash>>
  Maxincall=  32, /* max. conn.s in listen q not accepted yet */
  <<constant Nchans>>
  MAClen=   16,   /* longest mac address */

  <<constant MAXTTL>>
  DFLTTOS=  0,

  <<constant IPaddrlen>>
  <<constant IPv4addrlen>>
  <<constant IPv4off>>
  IPllen=   4,

  <<constant IP_VER4>>
  <<constant IP_HLEN4>>
  IP_VER6=  0x60,

  IP_DF=    0x4000,   /* v4: Don't fragment */
  IP_MF=    0x2000,   /* v4: More fragments */
  IP4HDR=   20,   /* sizeof(Ip4hdr) */

  <<constant IP_MAX>>

  <<constant Lroot>>

  Maxpath = 64,
};
@




<<struct Ipfrag>>=
//@Scheck: used only for its macro below, could maybe simplify?
struct Ipfrag
{
  ushort  foff;
  ushort  flen;

  uchar payload[];
};
@

<<constant IPFRAGSZ>>=
#define IPFRAGSZ offsetof(Ipfrag, payload[0])
@







<<struct Routerparams>>=
/* default values, one per stack */
struct Routerparams {
  int mflag;    /* flag: managed address configuration */
  int oflag;    /* flag: other stateful configuration */
  int   maxraint; /* max. router adv interval (ms) */
  int minraint; /* min. router adv interval (ms) */
  int linkmtu;  /* mtu options */
  int reachtime;  /* reachable time */
  int rxmitra;  /* retransmit interval */
  int ttl;    /* cur hop count limit */
  int routerlt; /* router lifetime */
};
@

<<struct Hostparams>>=
struct Hostparams {
  int rxmithost;
};
@



<<enum _anon_ (kernel/network/ip/ip.h)4>>=
enum
{
  <<constant Nipht>>
};
@






<<enum _anon_ (kernel/network/ip/ip.h)5>>=
/*
 *  logging
 */
enum
{
  Logip=    1<<1,
  Logtcp=   1<<2,
  Logfs=    1<<3,
  Logicmp=  1<<5,
  Logudp=   1<<6,
  Logcompress=  1<<7,
  Loggre=   1<<9,
  Logppp=   1<<10,
  Logtcprxmt= 1<<11,
  Logigmp=  1<<12,
  Logudpmsg=  1<<13,
  Logipmsg= 1<<14,
  Logrudp=  1<<15,
  Logrudpmsg= 1<<16,
  Logesp=   1<<17,
  Logtcpwin=  1<<18,
};
@


<<struct Routewalk>>=
struct Routewalk
{
  int o;
  int h;
  char* p;
  char* e;
  void* state;
  void  (*walk)(Route*, Routewalk*);
};
@








<<constant NOW>>=
#define NOW TK2MS(CPUS(0)->ticks)
@


%-------------------------------------------------------------

<<kernel/network/ip/ip.h>>=

// coupling: include/ip.h
// This file references also code in lib_networking (linked with the kernel).
// Those functions are also exported in include/ip.h.
// Some types are duplicated with include/ip.h.

// forward decls
typedef struct  Conv  Conv;
typedef struct  Fragment4 Fragment4;
typedef struct  Fragment6 Fragment6;
typedef struct  Fs  Fs;
typedef struct  IP  IP;
typedef struct  IPaux IPaux;
typedef struct  Ip4hdr  Ip4hdr;
typedef struct  Ipfrag  Ipfrag;
typedef struct  Ipself  Ipself;
typedef struct  Ipselftab Ipselftab;
typedef struct  Iplink  Iplink;
typedef struct  Iplifc  Iplifc;
typedef struct  Ipmulti Ipmulti;
typedef struct  Ipifc Ipifc;
typedef struct  Iphash  Iphash;
typedef struct  Ipht  Ipht;
typedef struct  Netlog  Netlog;
typedef struct  Medium  Medium;
typedef struct  Proto Proto;
typedef struct  Arpent  Arpent;
typedef struct  Arp Arp;
typedef struct  Route Route;
typedef struct  Routerparams  Routerparams;
typedef struct  Hostparams  Hostparams;
typedef struct  v6router  v6router;
typedef struct  v6params  v6params;

#pragma incomplete Arp
#pragma incomplete Ipself
#pragma incomplete Ipselftab
#pragma incomplete IP
#pragma incomplete Netlog

<<enum _anon_ (kernel/network/ip/ip.h)>>

<<enum ip_version>>

<<typedef ipv4>>
<<typedef ipaddr>>
<<typedef iplong>>
<<typedef ipv4or6>>
<<typedef ipv4p>>

<<enum conversation_state>>

<<enum _anon_ (kernel/network/ip/ip.h)3>>

<<struct Fragment4>>

<<struct Fragment6>>

<<struct Ipfrag>>

<<constant IPFRAGSZ>>

<<struct IP (kernel)>>

<<struct Ip4hdr>>

<<struct Conv (kernel)>>

<<struct Medium (kernel)>>

<<struct Iplifc (kernel)>>

<<struct Iplink>>

/* rfc 2461, pp.40—43. */

<<struct Routerparams>>

<<struct Hostparams>>

<<struct Ipifc (kernel)>>

<<struct Ipmulti>>

<<enum _anon_ (kernel/network/ip/ip.h)4>>

<<enum matchtype>>

<<struct Iphash>>
<<struct Ipht>>

void iphtadd(Ipht*, Conv*);
void iphtrem(Ipht*, Conv*);
Conv* iphtlook(Ipht *ht, uchar *sa, ushort sp, uchar *da, ushort dp);

<<struct Proto (kernel)>>


<<struct Fs (kernel)>>

<<struct v6router>>

<<struct v6params>>

int Fsconnected(Conv*, char*);
Conv* Fsnewcall(Conv*, uchar*, ushort, uchar*, ushort, uchar);
//int Fspcolstats(char*, int);
int Fsproto(Fs*, Proto*);
//int Fsbuiltinproto(Fs*, uchar);
//Conv* Fsprotoclone(Proto*, char*);
Proto*  Fsrcvpcol(Fs*, uchar);
Proto*  Fsrcvpcolx(Fs*, uchar);
char* Fsstdconnect(Conv*, char**, int);
char* Fsstdannounce(Conv*, char**, int);
//char* Fsstdbind(Conv*, char**, int);
ulong scalednconv(void);
//void  closeconv(Conv*);
<<enum _anon_ (kernel/network/ip/ip.h)5>>

void  netloginit(Fs*);
void  netlogopen(Fs*);
void  netlogclose(Fs*);
void  netlogctl(Fs*, char*, int);
long  netlogread(Fs*, void*, ulong, long);
void  netlog(Fs*, int, char*, ...);
//void  ifcloginit(Fs*);
//long  ifclogread(Fs*, Chan *,void*, ulong, long);
//void  ifclog(Fs*, uchar *, int);
//void  ifclogopen(Fs*, Chan*);
//void  ifclogclose(Fs*, Chan*);

#pragma varargck argpos netlog  3

/*
 *  iproute.c
 */
typedef struct RouteTree RouteTree;
typedef struct Routewalk Routewalk;
typedef struct V4route V4route;
typedef struct V6route V6route;

<<enum _anon_ (kernel/network/ip/ip.h)6>>

<<struct Routewalk>>

<<struct RouteTree (kernel)>>

<<struct V4route>>

<<struct V6route>>

<<struct Route (kernel)>>
extern void v4addroute(Fs *f, char *tag, uchar *a, uchar *mask, uchar *gate, int type);
extern void v4delroute(Fs *f, uchar *a, uchar *mask, int dolock);
extern Route* v4lookup(Fs *f, uchar *a, Conv *c);

extern void v6addroute(Fs *f, char *tag, uchar *a, uchar *mask, uchar *gate, int type);
extern void v6delroute(Fs *f, uchar *a, uchar *mask, int dolock);
extern Route* v6lookup(Fs *f, uchar *a, Conv *c);

extern long routeread(Fs *f, char*, ulong, int);
extern long routewrite(Fs *f, Chan*, char*, int);
extern void routetype(int, char*);
//extern void ipwalkroutes(Fs*, Routewalk*);
//extern void convroute(Route*, uchar*, uchar*, uchar*, char*, int*);

/*
 *  devip.c
 */

<<struct IPaux>>

extern IPaux* newipaux(char*, char*);

/*
 *  arp.c
 */
<<struct Arpent>>

extern void arpinit(Fs*);
extern int  arpread(Arp*, char*, ulong, int);
extern int  arpwrite(Fs*, char*, int);
extern Arpent*  arpget(Arp*, Block *bp, int version, Ipifc *ifc, uchar *ip, uchar *h);
extern void arprelease(Arp*, Arpent *a);
extern Block* arpresolve(Arp*, Arpent *a, Medium *type, uchar *mac);
extern void arpenter(Fs*, int version, uchar *ip, uchar *mac, int len, int norefresh);

/*
 * ipaux.c
 */

//extern int  myetheraddr(uchar*, char*);
extern vlong  parseip(uchar*, char*);
extern vlong  parseipmask(uchar*, char*);
//extern char*  v4parseip(uchar*, char*);
extern void maskip(uchar *from, uchar *mask, uchar *to);
extern int  parsemac(uchar *to, char *from, int len);
extern uchar* defmask(uchar*);
extern int  isv4(uchar*);
extern void v4tov6(uchar *v6, uchar *v4);
extern int  v6tov4(uchar *v4, uchar *v6);
extern int  eipfmt(Fmt*);

<<macro ipmove (kernel/network/ip/ip.h)>>
<<macro ipcmp (kernel/network/ip/ip.h)>>

extern ipaddr IPv4bcast;
extern ipaddr IPnoaddr;
extern ipaddr v4prefix;
extern ipaddr IPallbits;
//extern ipaddr IPv4bcastobs;
//extern ipaddr IPv4allsys;
//extern ipaddr IPv4allrouter;

<<constant NOW>>

/*
 *  media
 */
//extern Medium ethermedium;
//extern Medium nullmedium;
//extern Medium pktmedium;

/*
 *  ipifc.c
 */
extern Medium*  ipfindmedium(char *name);
extern void addipmedium(Medium *med);
extern int  ipforme(Fs*, uchar *addr);
extern int  iptentative(Fs*, uchar *addr);
//extern int  ipisbm(uchar *);
extern int  ipismulticast(uchar *);
extern Ipifc* findipifc(Fs*, uchar *remote, int type);
extern void findlocalip(Fs*, uchar *local, uchar *remote);
extern int  ipv4local(Ipifc *ifc, uchar *addr);
extern int  ipv6local(Ipifc *ifc, uchar *addr);
extern int  ipv6anylocal(Ipifc *ifc, uchar *addr);
extern Iplifc*  iplocalonifc(Ipifc *ifc, uchar *ip);
extern int  ipproxyifc(Fs *f, Ipifc *ifc, uchar *ip);
extern int  ipismulticast(uchar *ip);
//extern int  ipisbooting(void);
//extern int  ipifccheckin(Ipifc *ifc, Medium *med);
//extern void ipifccheckout(Ipifc *ifc);
//extern int  ipifcgrab(Ipifc *ifc);
extern void ipifcaddroute(Fs*, int, uchar*, uchar*, uchar*, int);
extern void ipifcremroute(Fs*, int, uchar*, uchar*);
extern void ipifcremmulti(Conv *c, uchar *ma, uchar *ia);
extern void ipifcaddmulti(Conv *c, uchar *ma, uchar *ia);
//extern char*  ipifcrem(Ipifc *ifc, char **argv, int argc);
//extern char*  ipifcadd(Ipifc *ifc, char **argv, int argc, int tentative, Iplifc *lifcp);
extern long ipselftabread(Fs*, char *a, ulong offset, int n);
//extern char*  ipifcadd6(Ipifc *ifc, char**argv, int argc);

/*
 *  ip.c
 */
extern void iprouting(Fs*, int);
extern void icmpnoconv(Fs*, Block*);
extern void icmpcantfrag(Fs*, Block*, int);
extern void icmpttlexceeded(Fs*, uchar*, Block*);
extern ushort ipcsum(uchar*);
extern void ipiput4(Fs*, Ipifc*, Block*);
extern void ipiput6(Fs*, Ipifc*, Block*);
extern int  ipoput4(Fs*, Block*, int, int, int, Conv*);
extern int  ipoput6(Fs*, Block*, int, int, int, Conv*);
extern int  ipstats(Fs*, char*, int);
extern ushort ptclbsum(uchar*, int);
extern ushort ptclcsum(Block*, int, int);
extern void ip_init(Fs*);
//extern void update_mtucache(uchar*, ulong);
//extern ulong  restrict_mtu(uchar*, ulong);

/*
 * bootp.c
 */
extern int  bootpread(char*, ulong, int);

/*
 * chandial.c
 */
extern Chan*  chandial(char*, char*, char*, Chan**);

/*
 *  global to all of the stack
 */
//extern void (*igmpreportfn)(Ipifc*, uchar*);
@


\subsection*{[[kernel/network/ip/ip.c]]}


<<macro BKFG>>=
/*
 * This sleazy macro relies on the media header size being
 * larger than sizeof(Ipfrag). ipreassemble checks this is true
 */
#define BKFG(xp)    ((Ipfrag*)((xp)->base))
@







%-------------------------------------------------------------

<<kernel/network/ip/ip.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    "ip.h"

<<macro BLKIPVER>>

<<global statnames>>

<<macro BLKIP>>
<<macro BKFG>>

ushort      ipcsum(uchar*);
Block*      ip4reassemble(IP*, int, Block*, Ip4hdr*);
void        ipfragfree4(IP*, Fragment4*);
Fragment4*  ipfragallo4(IP*);

<<function ip_init_6>>

<<function initfrag>>

<<function ip_init>>

<<function iprouting>>

<<function ipoput4>>

<<function ipiput4>>

<<function ipstats>>

<<function ip4reassemble>>

<<function ipfragfree4>>

<<function ipfragallo4>>

<<function ipcsum>>
@


\section{[[kernel/network/]]}

\subsection*{[[kernel/network/portfns_network.h]]}


%-------------------------------------------------------------

% in libip/?
<<kernel/network/portfns_network.h>>=

void   hnputl(void*, uint);
void   hnputs(void*, ushort);
uint   nhgetl(void*);
ushort nhgets(void*);

//void    hnputv(void*, uvlong);
//uvlong    nhgetv(void*);
@


\subsection*{[[kernel/network/netif.h]]}

<<enum _anon_ (kernel/network/netif.h)>>=
enum
{
  Nmaxaddr= 64,
  Nmhash=   31,

  Ncloneqid=  1,
  Naddrqid,
  N2ndqid,
  N3rdqid,
  Ndataqid,
  Nctlqid,
  Nstatqid,
  Ntypeqid,
  Nifstatqid,
  Nmtuqid,
};
@

<<macro NETTYPE>>=
/*
 *  Macros to manage Qid's used for multiplexed devices
 */
#define NETTYPE(x)  (((ulong)x)&0x1f)
@

<<macro NETID>>=
#define NETID(x)  ((((ulong)x))>>5)
@

<<macro NETQID>>=
#define NETQID(i,t) ((((ulong)i)<<5)|(t))
@



<<struct Netaddr>>=
/*
 *  a network address
 */
struct Netaddr
{
  Netaddr *next;    /* allocation chain */
  Netaddr *hnext;
  uchar addr[Nmaxaddr];
  int ref;
};
@


<<enum _anon_ (kernel/network/netif.h)2>>=
/*
 *  Ethernet specific
 */
enum
{
  <<constant Eaddrlen>>
  ETHERMINTU =  60,   /* minimum transmit size */
  ETHERMAXTU =  1514,   /* maximum transmit size */
  ETHERHDRSIZE =  14,   /* size of an ethernet header */

  /* ethernet packet types */
  ETARP   = 0x0806,
  ETIP4   = 0x0800,

  ETIP6   = 0x86DD,
};
@



%-------------------------------------------------------------

<<kernel/network/netif.h>>=

// todo: split in portdat_network.h? and portfns_network.h

typedef struct Etherpkt Etherpkt;
typedef struct Netaddr  Netaddr;
typedef struct Netfile  Netfile;
typedef struct Netif  Netif;

<<enum _anon_ (kernel/network/netif.h)>>

<<macro NETTYPE>>
<<macro NETID>>
<<macro NETQID>>

<<struct Netfile>>

<<struct Netaddr>>

<<struct Netif (kernel)>>

void  netifinit(Netif*, char*, int, ulong);
Walkqid*  netifwalk(Netif*, Chan*, Chan*, char **, int);
Chan* netifopen(Netif*, Chan*, int);
void  netifclose(Netif*, Chan*);
long  netifread(Netif*, Chan*, void*, long, ulong);
Block*  netifbread(Netif*, Chan*, long, ulong);
long  netifwrite(Netif*, Chan*, void*, long);
int netifwstat(Netif*, Chan*, uchar*, int);
int netifstat(Netif*, Chan*, uchar*, int);
int activemulti(Netif*, uchar*, int);

<<enum _anon_ (kernel/network/netif.h)2>>

<<typedef eaddr>>

<<struct Etherpkt>>


@


\subsection*{[[kernel/network/netif.c]]}

<<function netifinit>>=
/*
 *  set up a new network interface
 */
void
netifinit(Netif *nif, char *name, int nfile, ulong limit)
{
    strncpy(nif->name, name, KNAMELEN-1);
    nif->name[KNAMELEN-1] = 0;
    nif->nfile = nfile;
    nif->f = xalloc(nfile*sizeof(Netfile*));
    if (nif->f == nil)
        panic("netifinit: no memory");
    memset(nif->f, 0, nfile*sizeof(Netfile*));
    nif->limit = limit;
}
@

<<function netifgen>>=
/*
 *  generate a 3 level directory
 */
static int
netifgen(Chan *c, char*, Dirtab *vp, int, int i, Dir *dp)
{
    Qid q;
    Netif *nif = (Netif*)vp;
    Netfile *f;
    int t;
    int perm;
    char *o;

    q.type = QTFILE;
    q.vers = 0;

    /* top level directory contains the name of the network */
    if(c->qid.path == 0){
        switch(i){
        case DEVDOTDOT:
            q.path = 0;
            q.type = QTDIR;
            devdir(c, q, ".", 0, eve, 0555, dp);
            break;
        case 0:
            q.path = N2ndqid;
            q.type = QTDIR;
            strcpy(up->genbuf, nif->name);
            devdir(c, q, up->genbuf, 0, eve, 0555, dp);
            break;
        default:
            return -1;
        }
        return 1;
    }

    /* second level contains clone plus all the conversations */
    t = NETTYPE(c->qid.path);
    if(t == N2ndqid || t == Ncloneqid || t == Naddrqid){
        switch(i) {
        case DEVDOTDOT:
            q.type = QTDIR;
            q.path = 0;
            devdir(c, q, ".", 0, eve, DMDIR|0555, dp);
            break;
        case 0:
            q.path = Ncloneqid;
            devdir(c, q, "clone", 0, eve, 0666, dp);
            break;
        case 1:
            q.path = Naddrqid;
            devdir(c, q, "addr", 0, eve, 0666, dp);
            break;
        case 2:
            q.path = Nstatqid;
            devdir(c, q, "stats", 0, eve, 0444, dp);
            break;
        case 3:
            q.path = Nifstatqid;
            devdir(c, q, "ifstats", 0, eve, 0444, dp);
            break;
        default:
            i -= 4;
            if(i >= nif->nfile)
                return -1;
            if(nif->f[i] == 0)
                return 0;
            q.type = QTDIR;
            q.path = NETQID(i, N3rdqid);
            snprint(up->genbuf, sizeof up->genbuf, "%d", i);
            devdir(c, q, up->genbuf, 0, eve, DMDIR|0555, dp);
            break;
        }
        return 1;
    }

    /* third level */
    f = nif->f[NETID(c->qid.path)];
    if(f == 0)
        return 0;
    if(*f->owner){
        o = f->owner;
        perm = f->mode;
    } else {
        o = eve;
        perm = 0666;
    }
    switch(i){
    case DEVDOTDOT:
        q.type = QTDIR;
        q.path = N2ndqid;
        strcpy(up->genbuf, nif->name);
        devdir(c, q, up->genbuf, 0, eve, DMDIR|0555, dp);
        break;
    case 0:
        q.path = NETQID(NETID(c->qid.path), Ndataqid);
        devdir(c, q, "data", 0, o, perm, dp);
        break;
    case 1:
        q.path = NETQID(NETID(c->qid.path), Nctlqid);
        devdir(c, q, "ctl", 0, o, perm, dp);
        break;
    case 2:
        q.path = NETQID(NETID(c->qid.path), Nstatqid);
        devdir(c, q, "stats", 0, eve, 0444, dp);
        break;
    case 3:
        q.path = NETQID(NETID(c->qid.path), Ntypeqid);
        devdir(c, q, "type", 0, eve, 0444, dp);
        break;
    case 4:
        q.path = NETQID(NETID(c->qid.path), Nifstatqid);
        devdir(c, q, "ifstats", 0, eve, 0444, dp);
        break;
    default:
        return -1;
    }
    return 1;
}
@

<<function netifwalk>>=
Walkqid*
netifwalk(Netif *nif, Chan *c, Chan *nc, char **name, int nname)
{
    return devwalk(c, nc, name, nname, (Dirtab *)nif, 0, netifgen);
}
@

<<function netifopen>>=
Chan*
netifopen(Netif *nif, Chan *c, int omode)
{
    int id;
    Netfile *f;

    id = 0;
    if(c->qid.type & QTDIR){
        if(omode != OREAD)
            error(Eperm);
    } else {
        switch(NETTYPE(c->qid.path)){
        case Ndataqid:
        case Nctlqid:
            id = NETID(c->qid.path);
            openfile(nif, id);
            break;
        case Ncloneqid:
            id = openfile(nif, -1);
            c->qid.path = NETQID(id, Nctlqid);
            break;
        default:
            if(omode != OREAD)
                error(Ebadarg);
        }
        switch(NETTYPE(c->qid.path)){
        case Ndataqid:
        case Nctlqid:
            f = nif->f[id];
            if(netown(f, up->user, omode&7) < 0)
                error(Eperm);
            break;
        }
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    c->iounit = qiomaxatomic;
    return c;
}
@

<<function netifread>>=
long
netifread(Netif *nif, Chan *c, void *a, long n, ulong offset)
{
    int i, j;
    Netfile *f;
    char *p;

    if(c->qid.type&QTDIR)
        return devdirread(c, a, n, (Dirtab*)nif, 0, netifgen);

    switch(NETTYPE(c->qid.path)){
    case Ndataqid:
        f = nif->f[NETID(c->qid.path)];
        return qread(f->in, a, n);
    case Nctlqid:
        return readnum(offset, a, n, NETID(c->qid.path), NUMSIZE);
    case Nstatqid:
        p = malloc(READSTR);
        if(p == nil)
            error(Enomem);
        j = snprint(p, READSTR, "in: %llud\n", nif->inpackets);
        j += snprint(p+j, READSTR-j, "link: %d\n", nif->link);
        j += snprint(p+j, READSTR-j, "out: %llud\n", nif->outpackets);
        j += snprint(p+j, READSTR-j, "crc errs: %d\n", nif->crcs);
        j += snprint(p+j, READSTR-j, "overflows: %d\n", nif->overflows);
        j += snprint(p+j, READSTR-j, "soft overflows: %d\n", nif->soverflows);
        j += snprint(p+j, READSTR-j, "framing errs: %d\n", nif->frames);
        j += snprint(p+j, READSTR-j, "buffer errs: %d\n", nif->buffs);
        j += snprint(p+j, READSTR-j, "output errs: %d\n", nif->oerrs);
        j += snprint(p+j, READSTR-j, "prom: %d\n", nif->prom);
        j += snprint(p+j, READSTR-j, "mbps: %d\n", nif->mbps);
        j += snprint(p+j, READSTR-j, "addr: ");
        for(i = 0; i < nif->alen; i++)
            j += snprint(p+j, READSTR-j, "%2.2ux", nif->addr[i]);
        snprint(p+j, READSTR-j, "\n");
        n = readstr(offset, a, n, p);
        free(p);
        return n;
    case Naddrqid:
        p = malloc(READSTR);
        if(p == nil)
            error(Enomem);
        j = 0;
        for(i = 0; i < nif->alen; i++)
            j += snprint(p+j, READSTR-j, "%2.2ux", nif->addr[i]);
        n = readstr(offset, a, n, p);
        free(p);
        return n;
    case Ntypeqid:
        f = nif->f[NETID(c->qid.path)];
        return readnum(offset, a, n, f->type, NUMSIZE);
    case Nifstatqid:
        return 0;
    }
    error(Ebadarg);
    return -1;  /* not reached */
}
@

<<function netifbread>>=
Block*
netifbread(Netif *nif, Chan *c, long n, ulong offset)
{
    if((c->qid.type & QTDIR) || NETTYPE(c->qid.path) != Ndataqid)
        return devbread(c, n, offset);

    return qbread(nif->f[NETID(c->qid.path)]->in, n);
}
@

<<function typeinuse>>=
/*
 *  make sure this type isn't already in use on this device
 */
static int
typeinuse(Netif *nif, int type)
{
    Netfile *f, **fp, **efp;

    if(type <= 0)
        return 0;

    efp = &nif->f[nif->nfile];
    for(fp = nif->f; fp < efp; fp++){
        f = *fp;
        if(f == 0)
            continue;
        if(f->type == type)
            return 1;
    }
    return 0;
}
@

<<function netifwrite>>=
/*
 *  the devxxx.c that calls us handles writing data, it knows best
 */
long
netifwrite(Netif *nif, Chan *c, void *a, long n)
{
    Netfile *f;
    int type;
    char *p, buf[64];
    uchar binaddr[Nmaxaddr];

    if(NETTYPE(c->qid.path) != Nctlqid)
        error(Eperm);

    if(n >= sizeof(buf))
        n = sizeof(buf)-1;
    memmove(buf, a, n);
    buf[n] = 0;

    if(waserror()){
        qunlock(nif);
        nexterror();
    }

    qlock(nif);
    f = nif->f[NETID(c->qid.path)];
    if((p = matchtoken(buf, "connect")) != 0){
        type = atoi(p);
        if(typeinuse(nif, type))
            error(Einuse);
        f->type = type;
        if(f->type < 0)
            nif->all++;
    } else if(matchtoken(buf, "promiscuous")){
        if(f->prom == 0){
            if(nif->prom == 0 && nif->promiscuous != nil)
                nif->promiscuous(nif->arg, 1);
            f->prom = 1;
            nif->prom++;
        }
    } else if((p = matchtoken(buf, "scanbs")) != 0){
        /* scan for base stations */
        if(f->scan == 0){
            type = atoi(p);
            if(type < 5)
                type = 5;
            if(nif->scanbs != nil)
                nif->scanbs(nif->arg, type);
            f->scan = type;
            nif->scan++;
        }
    } else if(matchtoken(buf, "bridge")){
        f->bridge = 1;
    } else if(matchtoken(buf, "headersonly")){
        f->headersonly = 1;
    } else if((p = matchtoken(buf, "addmulti")) != 0){
        if(parseaddr(binaddr, p, nif->alen) < 0)
            error("bad address");
        p = netmulti(nif, f, binaddr, 1);
        if(p)
            error(p);
    } else if((p = matchtoken(buf, "remmulti")) != 0){
        if(parseaddr(binaddr, p, nif->alen) < 0)
            error("bad address");
        p = netmulti(nif, f, binaddr, 0);
        if(p)
            error(p);
    } else
        n = -1;
    qunlock(nif);
    poperror();
    return n;
}
@

<<function netifwstat>>=
int
netifwstat(Netif *nif, Chan *c, uchar *db, int n)
{
    Dir *dir;
    Netfile *f;
    int m;

    f = nif->f[NETID(c->qid.path)];
    if(f == 0)
        error(Enonexist);

    if(netown(f, up->user, OWRITE) < 0)
        error(Eperm);

    dir = smalloc(sizeof(Dir)+n);
    m = convM2D(db, n, &dir[0], (char*)&dir[1]);
    if(m == 0){
        free(dir);
        error(Eshortstat);
    }
    if(!emptystr(dir[0].uid))
        strncpy(f->owner, dir[0].uid, KNAMELEN);
    if(dir[0].mode != ~0UL)
        f->mode = dir[0].mode;
    free(dir);
    return m;
}
@

<<function netifstat>>=
int
netifstat(Netif *nif, Chan *c, uchar *db, int n)
{
    return devstat(c, db, n, (Dirtab *)nif, 0, netifgen);
}
@

<<function netifclose>>=
void
netifclose(Netif *nif, Chan *c)
{
    Netfile *f;
    int t;
    Netaddr *ap;

    if((c->flag & COPEN) == 0)
        return;

    t = NETTYPE(c->qid.path);
    if(t != Ndataqid && t != Nctlqid)
        return;

    f = nif->f[NETID(c->qid.path)];
    qlock(f);
    if(--(f->inuse) == 0){
        if(f->prom){
            qlock(nif);
            if(--(nif->prom) == 0 && nif->promiscuous != nil)
                nif->promiscuous(nif->arg, 0);
            qunlock(nif);
            f->prom = 0;
        }
        if(f->scan){
            qlock(nif);
            if(--(nif->scan) == 0 && nif->scanbs != nil)
                nif->scanbs(nif->arg, 0);
            qunlock(nif);
            f->prom = 0;
            f->scan = 0;
        }
        if(f->nmaddr){
            qlock(nif);
            t = 0;
            for(ap = nif->maddr; ap; ap = ap->next){
                if(f->maddr[t/8] & (1<<(t%8)))
                    netmulti(nif, f, ap->addr, 0);
            }
            qunlock(nif);
            f->nmaddr = 0;
        }
        if(f->type < 0){
            qlock(nif);
            --(nif->all);
            qunlock(nif);
        }
        f->owner[0] = 0;
        f->type = 0;
        f->bridge = 0;
        f->headersonly = 0;
        qclose(f->in);
    }
    qunlock(f);
}
@
% >>

<<global netlock>>=
Lock netlock;
@

<<function netown>>=
static int
netown(Netfile *p, char *o, int omode)
{
    static int access[] = { 0400, 0200, 0600, 0100 };
    int mode;
    int t;

    lock(&netlock);
    if(*p->owner){
        if(strncmp(o, p->owner, KNAMELEN) == 0) /* User */
            mode = p->mode;
        else if(strncmp(o, eve, KNAMELEN) == 0) /* Bootes is group */
            mode = p->mode<<3;
        else
            mode = p->mode<<6;      /* Other */

        t = access[omode&3];
        if((t & mode) == t){
            unlock(&netlock);
            return 0;
        } else {
            unlock(&netlock);
            return -1;
        }
    }
    strncpy(p->owner, o, KNAMELEN);
    p->mode = 0660;
    unlock(&netlock);
    return 0;
}
@
% >> >> >>

<<function openfile>>=
/*
 *  Increment the reference count of a network device.
 *  If id < 0, return an unused ether device.
 */
static int
openfile(Netif *nif, int id)
{
    Netfile *f, **fp, **efp;

    if(id >= 0){
        f = nif->f[id];
        if(f == 0)
            error(Enodev);
        qlock(f);
        qreopen(f->in);
        f->inuse++;
        qunlock(f);
        return id;
    }

    qlock(nif);
    if(waserror()){
        qunlock(nif);
        nexterror();
    }
    efp = &nif->f[nif->nfile];
    for(fp = nif->f; fp < efp; fp++){
        f = *fp;
        if(f == 0){
            f = malloc(sizeof(Netfile));
            if(f == 0)
                exhausted("memory");
            f->in = qopen(nif->limit, Qmsg, 0, 0);
            if(f->in == nil){
                free(f);
                exhausted("memory");
            }
            *fp = f;
            qlock(f);
        } else {
            qlock(f);
            if(f->inuse){
                qunlock(f);
                continue;
            }
        }
        f->inuse = 1;
        qreopen(f->in);
        netown(f, up->user, 0);
        qunlock(f);
        qunlock(nif);
        poperror();
        return fp - nif->f;
    }
    error(Enodev);
    return -1;  /* not reached */
}
@

<<function matchtoken>>=
/*
 *  look for a token starting a string,
 *  return a pointer to first non-space char after it
 */
static char*
matchtoken(char *p, char *token)
{
    int n;

    n = strlen(token);
    if(strncmp(p, token, n))
        return 0;
    p += n;
    if(*p == 0)
        return p;
    if(*p != ' ' && *p != '\t' && *p != '\n')
        return 0;
    while(*p == ' ' || *p == '\t' || *p == '\n')
        p++;
    return p;
}
@

<<function hnputl (kernel/network/netif.c)>>=
void
hnputl(void *p, uint v)
{
    uchar *a;

    a = p;
    a[0] = v>>24;
    a[1] = v>>16;
    a[2] = v>>8;
    a[3] = v;
}
@

<<function hnputs (kernel/network/netif.c)>>=
void
hnputs(void *p, ushort v)
{
    uchar *a;

    a = p;
    a[0] = v>>8;
    a[1] = v;
}
@

<<function nhgetl (kernel/network/netif.c)>>=
uint
nhgetl(void *p)
{
    uchar *a;

    a = p;
    return (a[0]<<24)|(a[1]<<16)|(a[2]<<8)|(a[3]<<0);
}
@
% >> >> >> >> >> 

<<function nhgets (kernel/network/netif.c)>>=
ushort
nhgets(void *p)
{
    uchar *a;

    a = p;
    return (a[0]<<8)|(a[1]<<0);
}
@
% >> >> >>

<<function hash>>=
static ulong
hash(uchar *a, int len)
{
    ulong sum = 0;

    while(len-- > 0)
        sum = (sum << 1) + *a++;
    return sum%Nmhash;
}
@
% >>

<<function activemulti>>=
int
activemulti(Netif *nif, uchar *addr, int alen)
{
    Netaddr *hp;

    for(hp = nif->mhash[hash(addr, alen)]; hp; hp = hp->hnext)
        if(memcmp(addr, hp->addr, alen) == 0){
            if(hp->ref)
                return 1;
            else
                break;
        }
    return 0;
}
@

<<function parseaddr>>=
static int
parseaddr(uchar *to, char *from, int alen)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    for(i = 0; i < alen; i++){
        if(*p == 0)
            return -1;
        nip[0] = *p++;
        if(*p == 0)
            return -1;
        nip[1] = *p++;
        nip[2] = 0;
        to[i] = strtoul(nip, 0, 16);
        if(*p == ':')
            p++;
    }
    return 0;
}
@

<<function netmulti>>=
/*
 *  keep track of multicast addresses
 */
static char*
netmulti(Netif *nif, Netfile *f, uchar *addr, int add)
{
    Netaddr **l, *ap;
    int i;
    ulong h;

    if(nif->multicast == nil)
        return "interface does not support multicast";

    l = &nif->maddr;
    i = 0;
    for(ap = *l; ap; ap = *l){
        if(memcmp(addr, ap->addr, nif->alen) == 0)
            break;
        i++;
        l = &ap->next;
    }

    if(add){
        if(ap == 0){
            *l = ap = smalloc(sizeof(*ap));
            memmove(ap->addr, addr, nif->alen);
            ap->next = 0;
            ap->ref = 1;
            h = hash(addr, nif->alen);
            ap->hnext = nif->mhash[h];
            nif->mhash[h] = ap;
        } else {
            ap->ref++;
        }
        if(ap->ref == 1){
            nif->nmaddr++;
            nif->multicast(nif->arg, addr, 1);
        }
        if(i < 8*sizeof(f->maddr)){
            if((f->maddr[i/8] & (1<<(i%8))) == 0)
                f->nmaddr++;
            f->maddr[i/8] |= 1<<(i%8);
        }
    } else {
        if(ap == 0 || ap->ref == 0)
            return 0;
        ap->ref--;
        if(ap->ref == 0){
            nif->nmaddr--;
            nif->multicast(nif->arg, addr, 0);
        }
        if(i < 8*sizeof(f->maddr)){
            if((f->maddr[i/8] & (1<<(i%8))) != 0)
                f->nmaddr--;
            f->maddr[i/8] &= ~(1<<(i%8));
        }
    }
    return 0;
}
@
% >> >> >> >>
% >> >> >> >>
% >> >> >> >>

%-------------------------------------------------------------

<<kernel/network/netif.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
#include    "../port/netif.h"

static int netown(Netfile*, char*, int);
static int openfile(Netif*, int);
static char* matchtoken(char*, char*);
static char* netmulti(Netif*, Netfile*, uchar*, int);
static int parseaddr(uchar*, char*, int);

<<function netifinit>>

<<function netifgen>>

<<function netifwalk>>

<<function netifopen>>

<<function netifread>>

<<function netifbread>>

<<function typeinuse>>

<<function netifwrite>>

<<function netifwstat>>

<<function netifstat>>

<<function netifclose>>

<<global netlock>>

<<function netown>>

<<function openfile>>

<<function matchtoken>>

<<function hnputl (kernel/network/netif.c)>>

<<function hnputs (kernel/network/netif.c)>>

<<function nhgetl (kernel/network/netif.c)>>

<<function nhgets (kernel/network/netif.c)>>

<<function hash>>

<<function activemulti>>

<<function parseaddr>>

<<function netmulti>>
@

%//void
%//hnputv(void *p, uvlong v)
%//{
%//  uchar *a;
%//
%//  a = p;
%//  hnputl(a, v>>32);
%//  hnputl(a+4, v);
%//}

%//uvlong
%//nhgetv(void *p)
%//{
%//  uchar *a;
%//
%//  a = p;
%//  return ((vlong)nhgetl(a) << 32) | nhgetl(a+4);
%//}


\section{[[kernel/network/386/]]}

% not sure it's 386 specific actually, maybe have network/ethernet/...?

\subsection*{[[kernel/network/etherif.h]]}

% used to be in pc/ but seems portable because almost identical in bcm/

<<enum _anon_ (kernel/network/etherif.h)>>=
enum {
  <<constant MaxEther>>
  Ntypes    = 8,
};
@


<<macro NEXT>>=
#define NEXT(x, l)  (((x)+1)%(l))
@

<<macro PREV>>=
#define PREV(x, l)  (((x) == 0) ? (l)-1: (x)-1)
@


%-------------------------------------------------------------

<<kernel/network/etherif.h>>=
<<enum _anon_ (kernel/network/etherif.h)>>

typedef struct Ether Ether;
<<struct Ether (kernel)>>

extern Block* etheriq(Ether*, Block*, int);
extern void addethercard(char*, int(*)(Ether*));
extern ulong ethercrc(uchar*, int);
//extern int parseether(uchar*, char*);

<<macro NEXT>>
<<macro PREV>>
@


\subsection*{[[kernel/network/386/devether.c]]}



<<function etherwalk>>=
static Walkqid*
etherwalk(Chan* chan, Chan* nchan, char** name, int nname)
{
    return netifwalk(etherxx[chan->dev], chan, nchan, name, nname);
}
@

<<function etherstat>>=
static int
etherstat(Chan* chan, uchar* dp, int n)
{
    return netifstat(etherxx[chan->dev], chan, dp, n);
}
@

<<function etheropen>>=
static Chan*
etheropen(Chan* chan, int omode)
{
    return netifopen(etherxx[chan->dev], chan, omode);
}
@

<<function ethercreate>>=
static void
ethercreate(Chan*, char*, int, ulong)
{
}
@

<<function etherclose>>=
static void
etherclose(Chan* chan)
{
    netifclose(etherxx[chan->dev], chan);
}
@

<<function etherread>>=
static long
etherread(Chan* chan, void* buf, long n, vlong off)
{
    Ether *ether;
    ulong offset = off;

    ether = etherxx[chan->dev];
    if((chan->qid.type & QTDIR) == 0 && ether->ifstat){
        /*
         * With some controllers it is necessary to reach
         * into the chip to extract statistics.
         */
        if(NETTYPE(chan->qid.path) == Nifstatqid)
            return ether->ifstat(ether, buf, n, offset);
        else if(NETTYPE(chan->qid.path) == Nstatqid)
            ether->ifstat(ether, buf, 0, offset);
    }

    return netifread(ether, chan, buf, n, offset);
}
@

<<function etherbread>>=
static Block*
etherbread(Chan* chan, long n, ulong offset)
{
    return netifbread(etherxx[chan->dev], chan, n, offset);
}
@

<<function etherwstat>>=
static int
etherwstat(Chan* chan, uchar* dp, int n)
{
    return netifwstat(etherxx[chan->dev], chan, dp, n);
}
@

<<function etherrtrace>>=
static void
etherrtrace(Netfile* f, Etherpkt* pkt, int len)
{
    int i, n;
    Block *bp;

    if(qwindow(f->in) <= 0)
        return;
    if(len > 58)
        n = 58;
    else
        n = len;
    bp = iallocb(64);
    if(bp == nil)
        return;
    memmove(bp->wp, pkt->d, n);
    i = TK2MS(CPUS(0)->ticks);
    bp->wp[58] = len>>8;
    bp->wp[59] = len;
    bp->wp[60] = i>>24;
    bp->wp[61] = i>>16;
    bp->wp[62] = i>>8;
    bp->wp[63] = i;
    bp->wp += 64;
    qpass(f->in, bp);
}
@

<<function etheriq>>=
Block*
etheriq(Ether* ether, Block* bp, int fromwire)
{
    Etherpkt *pkt;
    ushort type;
    int len, multi, tome, fromme;
    Netfile **ep, *f, **fp, *fx;
    Block *xbp;

    ether->inpackets++;

    pkt = (Etherpkt*)bp->rp;
    len = BLEN(bp);
    type = (pkt->type[0]<<8)|pkt->type[1];
    fx = 0;
    ep = &ether->f[Ntypes];

    multi = pkt->d[0] & 1;
    /* check for valid multicast addresses */
    if(multi && memcmp(pkt->d, ether->bcast, sizeof(pkt->d)) != 0 && ether->prom == 0){
        if(!activemulti(ether, pkt->d, sizeof(pkt->d))){
            if(fromwire){
                freeb(bp);
                bp = 0;
            }
            return bp;
        }
    }

    /* is it for me? */
    tome = memcmp(pkt->d, ether->ea, sizeof(pkt->d)) == 0;
    fromme = memcmp(pkt->s, ether->ea, sizeof(pkt->s)) == 0;

    /*
     * Multiplex the packet to all the connections which want it.
     * If the packet is not to be used subsequently (fromwire != 0),
     * attempt to simply pass it into one of the connections, thereby
     * saving a copy of the data (usual case hopefully).
     */
    for(fp = ether->f; fp < ep; fp++){
        if(f = *fp)
        if(f->type == type || f->type < 0)
        if(tome || multi || f->prom){
            /* Don't want to hear bridged packets */
            if(f->bridge && !fromwire && !fromme)
                continue;
            if(!f->headersonly){
                if(fromwire && fx == 0)
                    fx = f;
                else if(xbp = iallocb(len)){
                    memmove(xbp->wp, pkt, len);
                    xbp->wp += len;
                    if(qpass(f->in, xbp) < 0){
                        // print("soverflow for f->in\n");
                        ether->soverflows++;
                    }
                }
                else{
                    // print("soverflow iallocb\n");
                    ether->soverflows++;
                }
            }
            else
                etherrtrace(f, pkt, len);
        }
    }

    if(fx){
        if(qpass(fx->in, bp) < 0){
            // print("soverflow for fx->in\n");
            ether->soverflows++;
        }
        return 0;
    }
    if(fromwire){
        freeb(bp);
        return 0;
    }

    return bp;
}
@

<<function etheroq>>=
static int
etheroq(Ether* ether, Block* bp)
{
    int len, loopback, s;
    Etherpkt *pkt;

    ether->outpackets++;

    /*
     * Check if the packet has to be placed back onto the input queue,
     * i.e. if it's a loopback or broadcast packet or the interface is
     * in promiscuous mode.
     * If it's a loopback packet indicate to etheriq that the data isn't
     * needed and return, etheriq will pass-on or free the block.
     * To enable bridging to work, only packets that were originated
     * by this interface are fed back.
     */
    pkt = (Etherpkt*)bp->rp;
    len = BLEN(bp);
    loopback = memcmp(pkt->d, ether->ea, sizeof(pkt->d)) == 0;
    if(loopback || memcmp(pkt->d, ether->bcast, sizeof(pkt->d)) == 0 || ether->prom){
        s = arch_splhi();
        etheriq(ether, bp, 0);
        arch_splx(s);
    }

    if(!loopback){
        if(qfull(ether->oq))
            print("etheroq: WARNING: ether->oq full!\n");
        qbwrite(ether->oq, bp);
        if(ether->transmit != nil)
            ether->transmit(ether);
    } else
        freeb(bp);

    return len;
}
@

<<function etherwrite>>=
static long
etherwrite(Chan* chan, void* buf, long n, vlong)
{
    Ether *ether;
    Block *bp;
    int nn, onoff;
    Cmdbuf *cb;

    ether = etherxx[chan->dev];
    if(NETTYPE(chan->qid.path) != Ndataqid) {
        nn = netifwrite(ether, chan, buf, n);
        if(nn >= 0)
            return nn;
        cb = parsecmd(buf, n);
        if(cb->f[0] && strcmp(cb->f[0], "nonblocking") == 0){
            if(cb->nf <= 1)
                onoff = 1;
            else
                onoff = atoi(cb->f[1]);
            qnoblock(ether->oq, onoff);
            free(cb);
            return n;
        }
        free(cb);
        if(ether->ctl != nil)
            return ether->ctl(ether, buf, n);

        error(Ebadctl);
    }

    if(n > ether->mtu)
        error(Etoobig);
    if(n < ether->minmtu)
        error(Etoosmall);

    bp = allocb(n);
    if(waserror()){
        freeb(bp);
        nexterror();
    }
    memmove(bp->rp, buf, n);
    memmove(bp->rp+Eaddrlen, ether->ea, Eaddrlen);
    poperror();
    bp->wp += n;

    return etheroq(ether, bp);
}
@

<<function etherbwrite>>=
static long
etherbwrite(Chan* chan, Block* bp, ulong)
{
    Ether *ether;
    long n;

    n = BLEN(bp);
    if(NETTYPE(chan->qid.path) != Ndataqid){
        if(waserror()) {
            freeb(bp);
            nexterror();
        }
        n = etherwrite(chan, bp->rp, n, 0);
        poperror();
        freeb(bp);
        return n;
    }
    ether = etherxx[chan->dev];

    if(n > ether->mtu){
        freeb(bp);
        error(Etoobig);
    }
    if(n < ether->minmtu){
        freeb(bp);
        error(Etoosmall);
    }

    return etheroq(ether, bp);
}
@

<<global cards>>=
static struct {
    char*   type;
    int (*reset)(Ether*);
} cards[MaxEther+1];
@

<<function addethercard>>=
void
addethercard(char* t, int (*r)(Ether*))
{
    static int ncard;

    if(ncard == MaxEther)
        panic("too many ether cards");
    cards[ncard].type = t;
    cards[ncard].reset = r;
    ncard++;
}
@

% factorize again no?
<<function parseether (kernel/network/386/devether.c)>>=
int
parseether(uchar *to, char *from)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    for(i = 0; i < Eaddrlen; i++){
        if(*p == 0)
            return -1;
        nip[0] = *p++;
        if(*p == 0)
            return -1;
        nip[1] = *p++;
        nip[2] = 0;
        to[i] = strtoul(nip, 0, 16);
        if(*p == ':')
            p++;
    }
    return 0;
}
@

<<function etherprobe>>=
static Ether*
etherprobe(int cardno, int ctlrno)
{
    int i, lg;
    ulong mb, bsz;
    Ether *ether;
    char buf[128], name[32];

    ether = malloc(sizeof(Ether));
    if(ether == nil)
        error(Enomem);
    memset(ether, 0, sizeof(Ether));
    ether->ctlrno = ctlrno;
    ether->tbdf = BUSUNKNOWN;
    ether->mbps = 10;
    ether->minmtu = ETHERMINTU;
    ether->maxmtu = ETHERMAXTU;
    ether->mtu = ETHERMAXTU;

    if(cardno < 0){
        if(arch_isaconfig("ether", ctlrno, ether) == 0){
            free(ether);
            return nil;
        }
        for(cardno = 0; cards[cardno].type; cardno++){
            if(cistrcmp(cards[cardno].type, ether->type))
                continue;
            for(i = 0; i < ether->nopt; i++){
                if(strncmp(ether->opt[i], "ea=", 3))
                    continue;
                if(parseether(ether->ea, &ether->opt[i][3]))
                    memset(ether->ea, 0, Eaddrlen);
            }
            break;
        }
    }

    if(cardno >= MaxEther || cards[cardno].type == nil){
        free(ether);
        return nil;
    }
    if(cards[cardno].reset(ether) < 0){
        free(ether);
        return nil;
    }

    /*
     * IRQ2 doesn't really exist, it's used to gang the interrupt
     * controllers together. A device set to IRQ2 will appear on
     * the second interrupt controller as IRQ9.
     */
    if(ether->irq == 2)
        ether->irq = 9;
    snprint(name, sizeof(name), "ether%d", ctlrno);

    /*
     * If ether->irq is <0, it is a hack to indicate no interrupt
     * used by ethersink.
     */
    if(ether->irq >= 0)
        arch_intrenable(ether->irq, ether->interrupt, ether, ether->tbdf, name);

    i = sprint(buf, "#l%d: %s: ", ctlrno, cards[cardno].type);
    if(ether->mbps >= 1000)
        i += sprint(buf+i, "%dGbps", ether->mbps/1000);
    else
        i += sprint(buf+i, "%dMbps", ether->mbps);
    i += sprint(buf+i, " port 0x%luX irq %d", ether->port, ether->irq);
    if(ether->mem)
        i += sprint(buf+i, " addr 0x%luX", ether->mem);
    if(ether->size)
        i += sprint(buf+i, " size 0x%luX", ether->size);
    i += sprint(buf+i, ": %2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux",
        ether->ea[0], ether->ea[1], ether->ea[2],
        ether->ea[3], ether->ea[4], ether->ea[5]);
    sprint(buf+i, "\n");
    print(buf);

    /*
     * input queues are allocated by ../port/netif.c:/^openfile.
     * the size will be the last argument to netifinit() below.
     *
     * output queues should be small, to minimise `bufferbloat',
     * which confuses tcp's feedback loop.  at 1Gb/s, it only takes
     * ~15µs to transmit a full-sized non-jumbo packet.
     */

    /* compute log10(ether->mbps) into lg */
    for(lg = 0, mb = ether->mbps; mb >= 10; lg++)
        mb /= 10;
    if (lg > 14)            /* sanity cap; 2**(14+15) = 2²⁹ */
        lg = 14;

    /* allocate larger input queues for higher-speed interfaces */
    bsz = 1UL << (lg + 15);     /* 2ⁱ⁵ = 32K, bsz = 2ⁿ × 32K */
    while (bsz > mainmem->maxsize / 8 && bsz > 128*1024)    /* sanity */
        bsz /= 2;
    netifinit(ether, name, Ntypes, bsz);

    if(ether->oq == nil)
        ether->oq = qopen(1 << (lg + 13), Qmsg, 0, 0);
    if(ether->oq == nil)
        panic("etherreset %s: can't allocate output queue", name);

    ether->alen = Eaddrlen;
    memmove(ether->addr, ether->ea, Eaddrlen);
    memset(ether->bcast, 0xFF, Eaddrlen);

    return ether;
}
@
% >> >>>>

<<function etherreset>>=
static void
etherreset(void)
{
    Ether *ether;
    int cardno, ctlrno;

    for(ctlrno = 0; ctlrno < MaxEther; ctlrno++){
        if((ether = etherprobe(-1, ctlrno)) == nil)
            continue;
        etherxx[ctlrno] = ether;
    }

    if(getconf("*noetherprobe"))
        return;

    cardno = ctlrno = 0;
    while(cards[cardno].type != nil && ctlrno < MaxEther){
        if(etherxx[ctlrno] != nil){
            ctlrno++;
            continue;
        }
        if((ether = etherprobe(cardno, ctlrno)) == nil){
            cardno++;
            continue;
        }
        etherxx[ctlrno] = ether;
        ctlrno++;
    }
}
@

<<function ethershutdown>>=
static void
ethershutdown(void)
{
    Ether *ether;
    int i;

    for(i = 0; i < MaxEther; i++){
        ether = etherxx[i];
        if(ether == nil)
            continue;
        if(ether->shutdown == nil) {
            print("#l%d: no shutdown function\n", i);
            continue;
        }
        (*ether->shutdown)(ether);
    }
}
@
% >> >> >> 



%-------------------------------------------------------------

<<kernel/network/386/devether.c>>=
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include "pool.h"
#include <ureg.h>
#include "../port/netif.h"
#include "../port/etherif.h"

<<global etherxx (kernel)>>

<<function etherattach>>

<<function etherwalk>>

<<function etherstat>>

<<function etheropen>>

<<function ethercreate>>

<<function etherclose>>

<<function etherread>>

<<function etherbread>>

<<function etherwstat>>

<<function etherrtrace>>

<<function etheriq>>

<<function etheroq>>

<<function etherwrite>>

<<function etherbwrite>>

<<global cards>>

<<function addethercard>>

<<function parseether (kernel/network/386/devether.c)>>

<<function etherprobe>>

<<function etherreset>>

<<function ethershutdown>>

<<global etherdevtab>>

<<constant POLY>>

<<function ethercrc>>
@

<<constant POLY>>=
#define POLY 0xedb88320
@

% used only by ne2000 (ether8390.c)
<<function ethercrc>>=
/* really slow 32 bit crc for ethers */
ulong
ethercrc(uchar *p, int len)
{
  int i, j;
  ulong crc, b;

  crc = 0xffffffff;
  for(i = 0; i < len; i++){
      b = *p++;
      for(j = 0; j < 8; j++){
          crc = (crc>>1) ^ (((crc^b) & 1) ? POLY : 0);
          b >>= 1;
      }
  }
  return crc;
}
@

\subsection*{[[kernel/network/386/ether8390.h]]}

<<constant Dp8390BufSz>>=
#define Dp8390BufSz	256
@



<<function rdread>>=
static void
rdread(Dp8390* ctlr, void* to, int len)
{
    switch(ctlr->width){
    default:
        panic("dp8390 rdread: width %d\n", ctlr->width);
        break;

    case 2:
        inss(ctlr->data, to, len/2);
        break;

    case 1:
        insb(ctlr->data, to, len);
        break;
    }
}
@



%-------------------------------------------------------------

<<kernel/network/386/ether8390.h>>=

typedef struct Dp8390 Dp8390;
<<struct Dp8390>>

<<constant Dp8390BufSz>>

extern int dp8390reset(Ether*);
extern void *dp8390read(Dp8390*, void*, ulong, ulong);
extern void dp8390getea(Ether*, uchar*);
extern void dp8390setea(Ether*);

<<macro regr>>
<<macro regw>>

<<function rdread>>

<<function rdwrite>>
@


\subsection*{[[kernel/network/386/ether8390.c]]}

<<enum _anon_ (kernel/network/386/ether8390.c)0>>=
enum {					/* NIC core registers */
    Cr		= 0x00,		/* command register, all pages */

                    /* Page 0, read */
    Clda0		= 0x01,		/* current local DMA address 0 */
    Clda1		= 0x02,		/* current local DMA address 1 */
    Bnry		= 0x03,		/* boundary pointer (R/W) */
    Tsr		= 0x04,		/* transmit status register */
    Ncr		= 0x05,		/* number of collisions register */
    Fifo		= 0x06,		/* FIFO */
    Isr		= 0x07,		/* interrupt status register (R/W) */
    Crda0		= 0x08,		/* current remote DMA address 0 */
    Crda1		= 0x09,		/* current remote DMA address 1 */
    Rsr		= 0x0C,		/* receive status register */
    Ref0		= 0x0D,		/* frame alignment errors */
    Ref1		= 0x0E,		/* CRC errors */
    Ref2		= 0x0F,		/* missed packet errors */

                    /* Page 0, write */
    Pstart		= 0x01,		/* page start register */
    Pstop		= 0x02,		/* page stop register */
    Tpsr		= 0x04,		/* transmit page start address */
    Tbcr0		= 0x05,		/* transmit byte count register 0 */
    Tbcr1		= 0x06,		/* transmit byte count register 1 */
    Rsar0		= 0x08,		/* remote start address register 0 */
    Rsar1		= 0x09,		/* remote start address register 1 */
    Rbcr0		= 0x0A,		/* remote byte count register 0 */
    Rbcr1		= 0x0B,		/* remote byte count register 1 */
    Rcr		= 0x0C,		/* receive configuration register */
    Tcr		= 0x0D,		/* transmit configuration register */
    Dcr		= 0x0E,		/* data configuration register */
    Imr		= 0x0F,		/* interrupt mask */

                    /* Page 1, read/write */
    Par0		= 0x01,		/* physical address register 0 */
    Curr		= 0x07,		/* current page register */
    Mar0		= 0x08,		/* multicast address register 0 */
};
@

<<enum _anon_ (kernel/network/386/ether8390.c)1>>=
enum {					/* Cr */
    Stp		= 0x01,		/* stop */
    Sta		= 0x02,		/* start */
    Txp		= 0x04,		/* transmit packet */
    Rd0		= 0x08,		/* remote DMA command */
    Rd1		= 0x10,	
    Rd2		= 0x20,
    RdREAD		= Rd0,		/* remote read */
    RdWRITE		= Rd1,		/* remote write */
    RdSEND		= Rd1|Rd0,	/* send packet */
    RdABORT		= Rd2,		/* abort/complete remote DMA */
    Ps0		= 0x40,		/* page select */
    Ps1		= 0x80,
    Page0		= 0x00,
    Page1		= Ps0,
    Page2		= Ps1,
};
@

<<enum _anon_ (kernel/network/386/ether8390.c)2>>=
enum {					/* Isr/Imr */
    Prx		= 0x01,		/* packet received */
    Ptx		= 0x02,		/* packet transmitted */
    Rxe		= 0x04,		/* receive error */
    Txe		= 0x08,		/* transmit error */
    Ovw		= 0x10,		/* overwrite warning */
    Cnt		= 0x20,		/* counter overflow */
    Rdc		= 0x40,		/* remote DMA complete */
    Rst		= 0x80,		/* reset status */
};
@

<<enum _anon_ (kernel/network/386/ether8390.c)3>>=
enum {					/* Dcr */
    Wts		= 0x01,		/* word transfer select */
    Bos		= 0x02,		/* byte order select */
    Las		= 0x04,		/* long address select */
    Ls		= 0x08,		/* loopback select */
    Arm		= 0x10,		/* auto-initialise remote */
    Ft0		= 0x20,		/* FIFO threshold select */
    Ft1		= 0x40,
    Ft1WORD		= 0x00,
    Ft2WORD		= Ft0,
    Ft4WORD		= Ft1,
    Ft6WORD		= Ft1|Ft0,
};
@

<<enum _anon_ (kernel/network/386/ether8390.c)4>>=
enum {					/* Tcr */
    Crc		= 0x01,		/* inhibit CRC */
    Lb0		= 0x02,		/* encoded loopback control */
    Lb1		= 0x04,
    LpbkNORMAL	= 0x00,		/* normal operation */
    LpbkNIC		= Lb0,		/* internal NIC module loopback */
    LpbkENDEC	= Lb1,		/* internal ENDEC module loopback */
    LpbkEXTERNAL	= Lb1|Lb0,	/* external loopback */
    Atd		= 0x08,		/* auto transmit disable */
    Ofst		= 0x10,		/* collision offset enable */
};
@

<<enum _anon_ (kernel/network/386/ether8390.c)5>>=
enum {					/* Tsr */
    Ptxok		= 0x01,		/* packet transmitted */
    Col		= 0x04,		/* transmit collided */
    Abt		= 0x08,		/* tranmit aborted */
    Crs		= 0x10,		/* carrier sense lost */
    Fu		= 0x20,		/* FIFO underrun */
    Cdh		= 0x40,		/* CD heartbeat */
    Owc		= 0x80,		/* out of window collision */
};
@

<<enum _anon_ (kernel/network/386/ether8390.c)6>>=
enum {					/* Rcr */
    Sep		= 0x01,		/* save errored packets */
    Ar		= 0x02,		/* accept runt packets */
    Ab		= 0x04,		/* accept broadcast */
    Am		= 0x08,		/* accept multicast */
    Pro		= 0x10,		/* promiscuous physical */
    Mon		= 0x20,		/* monitor mode */
};
@

<<enum _anon_ (kernel/network/386/ether8390.c)7>>=
enum {					/* Rsr */
    Prxok		= 0x01,		/* packet received intact */
    Crce		= 0x02,		/* CRC error */
    Fae		= 0x04,		/* frame alignment error */
    Fo		= 0x08,		/* FIFO overrun */
    Mpa		= 0x10,		/* missed packet */
    Phy		= 0x20,		/* physical/multicast address */
    Dis		= 0x40,		/* receiver disabled */
    Dfr		= 0x80,		/* deferring */
};
@

<<struct Hdr (kernel/network/386/ether8390.c)>>=
struct Hdr {
    uchar	status;
    uchar	next;
    uchar	len0;
    uchar	len1;
};
@

%dead?
%<<function dp8390getea>>=
%void
%dp8390getea(Ether* ether, uchar* ea)
%{
%    Dp8390 *ctlr;
%    uchar cr;
%    int i;
%
%    ctlr = ether->ctlr;
%
%    /*
%     * Get the ethernet address from the chip.
%     * Take care to restore the command register
%     * afterwards.
%     */
%    ilock(ctlr);
%    cr = regr(ctlr, Cr) & ~Txp;
%    regw(ctlr, Cr, Page1|(~(Ps1|Ps0) & cr));
%    for(i = 0; i < Eaddrlen; i++)
%        ea[i] = regr(ctlr, Par0+i);
%    regw(ctlr, Cr, cr);
%    iunlock(ctlr);
%}
%@


%-------------------------------------------------------------

<<kernel/network/386/ether8390.c>>=
/*
 * National Semiconductor DP8390 and clone
 * Network Interface Controller.
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"
#include "../port/netif.h"
#include "../port/etherif.h"

#include "ether8390.h"

<<enum _anon_ (kernel/network/386/ether8390.c)0>>

<<enum _anon_ (kernel/network/386/ether8390.c)1>>

<<enum _anon_ (kernel/network/386/ether8390.c)2>>

<<enum _anon_ (kernel/network/386/ether8390.c)3>>

<<enum _anon_ (kernel/network/386/ether8390.c)4>>

<<enum _anon_ (kernel/network/386/ether8390.c)5>>

<<enum _anon_ (kernel/network/386/ether8390.c)6>>

<<enum _anon_ (kernel/network/386/ether8390.c)7>>

typedef struct Hdr Hdr;


<<struct Hdr (kernel/network/386/ether8390.c)>>


<<function dp8390setea>>

<<function _dp8390read>>

<<function dp8390read>>

<<function dp8390write>>

<<function ringinit>>

<<function getcurr>>

<<function receive (kernel/network/386/ether8390.c)>>

<<function txstart>>

<<function transmit (kernel/network/386/ether8390.c)>>

<<function overflow>>

<<function interrupt (kernel/network/386/ether8390.c)>>

<<global allmar>>

<<function setfilter>>

<<function promiscuous>>

<<function setbit>>

<<global reverse>>

<<function multicast>>

<<function attach>>

<<function disable>>

<<function shutdown>>

<<function dp8390reset>>
@


\subsection*{[[kernel/network/386/ether2000.c]]}

<<enum _anon_ (kernel/network/386/ether2000.c)>>=
enum {
    Data		= 0x10,		/* offset from I/O base of data port */
    Reset		= 0x1F,		/* offset from I/O base of reset port */
};
@



%-------------------------------------------------------------

<<kernel/network/386/ether2000.c>>=
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include "../port/netif.h"
#include "../port/etherif.h"

#include "ether8390.h"

/*
 * Driver written for the 'Notebook Computer Ethernet LAN Adapter',
 * a plug-in to the bus-slot on the rear of the Gateway NOMAD 425DXL
 * laptop. The manual says NE2000 compatible.
 * The interface appears to be pretty well described in the National
 * Semiconductor Local Area Network Databook (1992) as one of the
 * AT evaluation cards.
 *
 * The NE2000 is really just a DP8390[12] plus a data port
 * and a reset port.
 */

<<enum _anon_ (kernel/network/386/ether2000.c)>>

typedef struct Ctlr Ctlr;
<<struct Ctlr (kernel/network/386/ether2000.c)>>

<<global ctlrhead (kernel/network/386/ether2000.c)>>
<<global ctlrtail (kernel/network/386/ether2000.c)>>

<<global ne2000pci>>

<<function ne2000match>>

<<function ne2000pnp>>

<<function ne2000reset>>

<<function ether2000link>>
@




\subsection*{[[kernel/network/386/etherigbe.c]]}

<<enum _anon_ (kernel/network/386/etherigbe.c)>>=
enum {
    i82542      = (0x1000<<16)|0x8086,
    i82543gc    = (0x1004<<16)|0x8086,
    i82544ei    = (0x1008<<16)|0x8086,
    i82544eif   = (0x1009<<16)|0x8086,
    i82544gc    = (0x100d<<16)|0x8086,
    i82540em    = (0x100E<<16)|0x8086,
    i82540eplp  = (0x101E<<16)|0x8086,
    i82545em    = (0x100F<<16)|0x8086,
    i82545gmc   = (0x1026<<16)|0x8086,
    i82547ei    = (0x1019<<16)|0x8086,
    i82547gi    = (0x1075<<16)|0x8086,
    i82541ei    = (0x1013<<16)|0x8086,
    i82541gi    = (0x1076<<16)|0x8086,
    i82541gi2   = (0x1077<<16)|0x8086,
    i82541pi    = (0x107c<<16)|0x8086,
    i82546gb    = (0x1079<<16)|0x8086,
    i82546eb    = (0x1010<<16)|0x8086,
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)2>>=
enum {
    Ctrl        = 0x00000000,   /* Device Control */
    Ctrldup     = 0x00000004,   /* Device Control Duplicate */
    Status      = 0x00000008,   /* Device Status */
    Eecd        = 0x00000010,   /* EEPROM/Flash Control/Data */
    Ctrlext     = 0x00000018,   /* Extended Device Control */
    Mdic        = 0x00000020,   /* MDI Control */
    Fcal        = 0x00000028,   /* Flow Control Address Low */
    Fcah        = 0x0000002C,   /* Flow Control Address High */
    Fct     = 0x00000030,   /* Flow Control Type */
    Icr     = 0x000000C0,   /* Interrupt Cause Read */
    Ics     = 0x000000C8,   /* Interrupt Cause Set */
    Ims     = 0x000000D0,   /* Interrupt Mask Set/Read */
    Imc     = 0x000000D8,   /* Interrupt mask Clear */
    Rctl        = 0x00000100,   /* Receive Control */
    Fcttv       = 0x00000170,   /* Flow Control Transmit Timer Value */
    Txcw        = 0x00000178,   /* Transmit Configuration Word */
    Rxcw        = 0x00000180,   /* Receive Configuration Word */
    /* on the oldest cards (8254[23]), the Mta register is at 0x200 */
    Tctl        = 0x00000400,   /* Transmit Control */
    Tipg        = 0x00000410,   /* Transmit IPG */
    Tbt     = 0x00000448,   /* Transmit Burst Timer */
    Ait     = 0x00000458,   /* Adaptive IFS Throttle */
    Fcrtl       = 0x00002160,   /* Flow Control RX Threshold Low */
    Fcrth       = 0x00002168,   /* Flow Control Rx Threshold High */
    Rdfh        = 0x00002410,   /* Receive data fifo head */
    Rdft        = 0x00002418,   /* Receive data fifo tail */
    Rdfhs       = 0x00002420,   /* Receive data fifo head saved */
    Rdfts       = 0x00002428,   /* Receive data fifo tail saved */
    Rdfpc       = 0x00002430,   /* Receive data fifo packet count */
    Rdbal       = 0x00002800,   /* Rd Base Address Low */
    Rdbah       = 0x00002804,   /* Rd Base Address High */
    Rdlen       = 0x00002808,   /* Receive Descriptor Length */
    Rdh     = 0x00002810,   /* Receive Descriptor Head */
    Rdt     = 0x00002818,   /* Receive Descriptor Tail */
    Rdtr        = 0x00002820,   /* Receive Descriptor Timer Ring */
    Rxdctl      = 0x00002828,   /* Receive Descriptor Control */
    Radv        = 0x0000282C,   /* Receive Interrupt Absolute Delay Timer */
    Txdmac      = 0x00003000,   /* Transfer DMA Control */
    Ett     = 0x00003008,   /* Early Transmit Control */
    Tdfh        = 0x00003410,   /* Transmit data fifo head */
    Tdft        = 0x00003418,   /* Transmit data fifo tail */
    Tdfhs       = 0x00003420,   /* Transmit data Fifo Head saved */
    Tdfts       = 0x00003428,   /* Transmit data fifo tail saved */
    Tdfpc       = 0x00003430,   /* Trasnmit data Fifo packet count */
    Tdbal       = 0x00003800,   /* Td Base Address Low */
    Tdbah       = 0x00003804,   /* Td Base Address High */
    Tdlen       = 0x00003808,   /* Transmit Descriptor Length */
    Tdh     = 0x00003810,   /* Transmit Descriptor Head */
    Tdt     = 0x00003818,   /* Transmit Descriptor Tail */
    Tidv        = 0x00003820,   /* Transmit Interrupt Delay Value */
    Txdctl      = 0x00003828,   /* Transmit Descriptor Control */
    Tadv        = 0x0000382C,   /* Transmit Interrupt Absolute Delay Timer */

    Statistics  = 0x00004000,   /* Start of Statistics Area */
    Gorcl       = 0x88/4,   /* Good Octets Received Count */
    Gotcl       = 0x90/4,   /* Good Octets Transmitted Count */
    Torl        = 0xC0/4,   /* Total Octets Received */
    Totl        = 0xC8/4,   /* Total Octets Transmitted */
    Nstatistics = 64,

    Rxcsum      = 0x00005000,   /* Receive Checksum Control */
    Mta     = 0x00005200,   /* Multicast Table Array */
    Ral     = 0x00005400,   /* Receive Address Low */
    Rah     = 0x00005404,   /* Receive Address High */
    Manc        = 0x00005820,   /* Management Control */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)3>>=
enum {                  /* Ctrl */
    Bem     = 0x00000002,   /* Big Endian Mode */
    Prior       = 0x00000004,   /* Priority on the PCI bus */
    Lrst        = 0x00000008,   /* Link Reset */
    Asde        = 0x00000020,   /* Auto-Speed Detection Enable */
    Slu     = 0x00000040,   /* Set Link Up */
    Ilos        = 0x00000080,   /* Invert Loss of Signal (LOS) */
    SspeedMASK  = 0x00000300,   /* Speed Selection */
    SspeedSHIFT = 8,
    Sspeed10    = 0x00000000,   /* 10Mb/s */
    Sspeed100   = 0x00000100,   /* 100Mb/s */
    Sspeed1000  = 0x00000200,   /* 1000Mb/s */
    Frcspd      = 0x00000800,   /* Force Speed */
    Frcdplx     = 0x00001000,   /* Force Duplex */
    SwdpinsloMASK   = 0x003C0000,   /* Software Defined Pins - lo nibble */
    SwdpinsloSHIFT  = 18,
    SwdpioloMASK    = 0x03C00000,   /* Software Defined Pins - I or O */
    SwdpioloSHIFT   = 22,
    Devrst      = 0x04000000,   /* Device Reset */
    Rfce        = 0x08000000,   /* Receive Flow Control Enable */
    Tfce        = 0x10000000,   /* Transmit Flow Control Enable */
    Vme     = 0x40000000,   /* VLAN Mode Enable */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)4>>=
/*
 * can't find Tckok nor Rbcok in any Intel docs,
 * but even 82543gc docs define Lanid.
 */
enum {                  /* Status */
    Lu      = 0x00000002,   /* Link Up */
    Lanid       = 0x0000000C,   /* mask for Lan ID. (function id) */
//  Tckok       = 0x00000004,   /* Transmit clock is running */
//  Rbcok       = 0x00000008,   /* Receive clock is running */
    Txoff       = 0x00000010,   /* Transmission Paused */
    Tbimode     = 0x00000020,   /* TBI Mode Indication */
    LspeedMASK  = 0x000000C0,   /* Link Speed Setting */
    LspeedSHIFT = 6,
    Lspeed10    = 0x00000000,   /* 10Mb/s */
    Lspeed100   = 0x00000040,   /* 100Mb/s */
    Lspeed1000  = 0x00000080,   /* 1000Mb/s */
    Mtxckok     = 0x00000400,   /* MTX clock is running */
    Pci66       = 0x00000800,   /* PCI Bus speed indication */
    Bus64       = 0x00001000,   /* PCI Bus width indication */
    Pcixmode    = 0x00002000,   /* PCI-X mode */
    PcixspeedMASK   = 0x0000C000,   /* PCI-X bus speed */
    PcixspeedSHIFT  = 14,
    Pcix66      = 0x00000000,   /* 50-66MHz */
    Pcix100     = 0x00004000,   /* 66-100MHz */
    Pcix133     = 0x00008000,   /* 100-133MHz */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)5>>=
enum {                  /* Ctrl and Status */
    Fd      = 0x00000001,   /* Full-Duplex */
    AsdvMASK    = 0x00000300,
    AsdvSHIFT   = 8,
    Asdv10      = 0x00000000,   /* 10Mb/s */
    Asdv100     = 0x00000100,   /* 100Mb/s */
    Asdv1000    = 0x00000200,   /* 1000Mb/s */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)6>>=
enum {                  /* Eecd */
    Sk      = 0x00000001,   /* Clock input to the EEPROM */
    Cs      = 0x00000002,   /* Chip Select */
    Di      = 0x00000004,   /* Data Input to the EEPROM */
    Do      = 0x00000008,   /* Data Output from the EEPROM */
    Areq        = 0x00000040,   /* EEPROM Access Request */
    Agnt        = 0x00000080,   /* EEPROM Access Grant */
    Eepresent   = 0x00000100,   /* EEPROM Present */
    Eesz256     = 0x00000200,   /* EEPROM is 256 words not 64 */
    Eeszaddr    = 0x00000400,   /* EEPROM size for 8254[17] */
    Spi     = 0x00002000,   /* EEPROM is SPI not Microwire */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)7>>=
enum {                  /* Ctrlext */
    Gpien       = 0x0000000F,   /* General Purpose Interrupt Enables */
    SwdpinshiMASK   = 0x000000F0,   /* Software Defined Pins - hi nibble */
    SwdpinshiSHIFT  = 4,
    SwdpiohiMASK    = 0x00000F00,   /* Software Defined Pins - I or O */
    SwdpiohiSHIFT   = 8,
    Asdchk      = 0x00001000,   /* ASD Check */
    Eerst       = 0x00002000,   /* EEPROM Reset */
    Ips     = 0x00004000,   /* Invert Power State */
    Spdbyps     = 0x00008000,   /* Speed Select Bypass */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)8>>=
enum {                  /* EEPROM content offsets */
    Ea      = 0x00,     /* Ethernet Address */
    Cf      = 0x03,     /* Compatibility Field */
    Pba     = 0x08,     /* Printed Board Assembly number */
    Icw1        = 0x0A,     /* Initialization Control Word 1 */
    Sid     = 0x0B,     /* Subsystem ID */
    Svid        = 0x0C,     /* Subsystem Vendor ID */
    Did     = 0x0D,     /* Device ID */
    Vid     = 0x0E,     /* Vendor ID */
    Icw2        = 0x0F,     /* Initialization Control Word 2 */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)9>>=
enum {                  /* Mdic */
    MDIdMASK    = 0x0000FFFF,   /* Data */
    MDIdSHIFT   = 0,
    MDIrMASK    = 0x001F0000,   /* PHY Register Address */
    MDIrSHIFT   = 16,
    MDIpMASK    = 0x03E00000,   /* PHY Address */
    MDIpSHIFT   = 21,
    MDIwop      = 0x04000000,   /* Write Operation */
    MDIrop      = 0x08000000,   /* Read Operation */
    MDIready    = 0x10000000,   /* End of Transaction */
    MDIie       = 0x20000000,   /* Interrupt Enable */
    MDIe        = 0x40000000,   /* Error */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)10>>=
enum {                  /* Icr, Ics, Ims, Imc */
    Txdw        = 0x00000001,   /* Transmit Descriptor Written Back */
    Txqe        = 0x00000002,   /* Transmit Queue Empty */
    Lsc     = 0x00000004,   /* Link Status Change */
    Rxseq       = 0x00000008,   /* Receive Sequence Error */
    Rxdmt0      = 0x00000010,   /* Rd Minimum Threshold Reached */
    Rxo     = 0x00000040,   /* Receiver Overrun */
    Rxt0        = 0x00000080,   /* Receiver Timer Interrupt */
    Mdac        = 0x00000200,   /* MDIO Access Completed */
    Rxcfg       = 0x00000400,   /* Receiving /C/ ordered sets */
    Gpi0        = 0x00000800,   /* General Purpose Interrupts */
    Gpi1        = 0x00001000,
    Gpi2        = 0x00002000,
    Gpi3        = 0x00004000,
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)11>>=
/*
 * The Mdic register isn't implemented on the 82543GC,
 * the software defined pins are used instead.
 * These definitions work for the Intel PRO/1000 T Server Adapter.
 * The direction pin bits are read from the EEPROM.
 */
enum {
    Mdd     = ((1<<2)<<SwdpinsloSHIFT), /* data */
    Mddo        = ((1<<2)<<SwdpioloSHIFT),  /* pin direction */
    Mdc     = ((1<<3)<<SwdpinsloSHIFT), /* clock */
    Mdco        = ((1<<3)<<SwdpioloSHIFT),  /* pin direction */
    Mdr     = ((1<<0)<<SwdpinshiSHIFT), /* reset */
    Mdro        = ((1<<0)<<SwdpiohiSHIFT),  /* pin direction */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)12>>=
enum {                  /* Txcw */
    TxcwFd      = 0x00000020,   /* Full Duplex */
    TxcwHd      = 0x00000040,   /* Half Duplex */
    TxcwPauseMASK   = 0x00000180,   /* Pause */
    TxcwPauseSHIFT  = 7,
    TxcwPs      = (1<<TxcwPauseSHIFT),  /* Pause Supported */
    TxcwAs      = (2<<TxcwPauseSHIFT),  /* Asymmetric FC desired */
    TxcwRfiMASK = 0x00003000,   /* Remote Fault Indication */
    TxcwRfiSHIFT    = 12,
    TxcwNpr     = 0x00008000,   /* Next Page Request */
    TxcwConfig  = 0x40000000,   /* Transmit COnfig Control */
    TxcwAne     = 0x80000000,   /* Auto-Negotiation Enable */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)13>>=
enum {                  /* Rxcw */
    Rxword      = 0x0000FFFF,   /* Data from auto-negotiation process */
    Rxnocarrier = 0x04000000,   /* Carrier Sense indication */
    Rxinvalid   = 0x08000000,   /* Invalid Symbol during configuration */
    Rxchange    = 0x10000000,   /* Change to the Rxword indication */
    Rxconfig    = 0x20000000,   /* /C/ order set reception indication */
    Rxsync      = 0x40000000,   /* Lost bit synchronization indication */
    Anc     = 0x80000000,   /* Auto Negotiation Complete */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)14>>=
enum {                  /* Rctl */
    Rrst        = 0x00000001,   /* Receiver Software Reset */
    Ren     = 0x00000002,   /* Receiver Enable */
    Sbp     = 0x00000004,   /* Store Bad Packets */
    Upe     = 0x00000008,   /* Unicast Promiscuous Enable */
    Mpe     = 0x00000010,   /* Multicast Promiscuous Enable */
    Lpe     = 0x00000020,   /* Long Packet Reception Enable */
    LbmMASK     = 0x000000C0,   /* Loopback Mode */
    LbmOFF      = 0x00000000,   /* No Loopback */
    LbmTBI      = 0x00000040,   /* TBI Loopback */
    LbmMII      = 0x00000080,   /* GMII/MII Loopback */
    LbmXCVR     = 0x000000C0,   /* Transceiver Loopback */
    RdtmsMASK   = 0x00000300,   /* Rd Minimum Threshold Size */
    RdtmsHALF   = 0x00000000,   /* Threshold is 1/2 Rdlen */
    RdtmsQUARTER    = 0x00000100,   /* Threshold is 1/4 Rdlen */
    RdtmsEIGHTH = 0x00000200,   /* Threshold is 1/8 Rdlen */
    MoMASK      = 0x00003000,   /* Multicast Offset */
    Mo47b36     = 0x00000000,   /* bits [47:36] of received address */
    Mo46b35     = 0x00001000,   /* bits [46:35] of received address */
    Mo45b34     = 0x00002000,   /* bits [45:34] of received address */
    Mo43b32     = 0x00003000,   /* bits [43:32] of received address */
    Bam     = 0x00008000,   /* Broadcast Accept Mode */
    BsizeMASK   = 0x00030000,   /* Receive Buffer Size */
    Bsize2048   = 0x00000000,   /* Bsex = 0 */
    Bsize1024   = 0x00010000,   /* Bsex = 0 */
    Bsize512    = 0x00020000,   /* Bsex = 0 */
    Bsize256    = 0x00030000,   /* Bsex = 0 */
    Bsize16384  = 0x00010000,   /* Bsex = 1 */
    Vfe     = 0x00040000,   /* VLAN Filter Enable */
    Cfien       = 0x00080000,   /* Canonical Form Indicator Enable */
    Cfi     = 0x00100000,   /* Canonical Form Indicator value */
    Dpf     = 0x00400000,   /* Discard Pause Frames */
    Pmcf        = 0x00800000,   /* Pass MAC Control Frames */
    Bsex        = 0x02000000,   /* Buffer Size Extension */
    Secrc       = 0x04000000,   /* Strip CRC from incoming packet */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)15>>=
enum {                  /* Tctl */
    Trst        = 0x00000001,   /* Transmitter Software Reset */
    Ten     = 0x00000002,   /* Transmit Enable */
    Psp     = 0x00000008,   /* Pad Short Packets */
    CtMASK      = 0x00000FF0,   /* Collision Threshold */
    CtSHIFT     = 4,
    ColdMASK    = 0x003FF000,   /* Collision Distance */
    ColdSHIFT   = 12,
    Swxoff      = 0x00400000,   /* Sofware XOFF Transmission */
    Pbe     = 0x00800000,   /* Packet Burst Enable */
    Rtlc        = 0x01000000,   /* Re-transmit on Late Collision */
    Nrtu        = 0x02000000,   /* No Re-transmit on Underrrun */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)16>>=
enum {                  /* [RT]xdctl */
    PthreshMASK = 0x0000003F,   /* Prefetch Threshold */
    PthreshSHIFT    = 0,
    HthreshMASK = 0x00003F00,   /* Host Threshold */
    HthreshSHIFT    = 8,
    WthreshMASK = 0x003F0000,   /* Writeback Threshold */
    WthreshSHIFT    = 16,
    Gran        = 0x01000000,   /* Granularity */
    LthreshMASK = 0xFE000000,   /* Low Threshold */
    LthreshSHIFT    = 25,
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)17>>=
enum {                  /* Rxcsum */
    PcssMASK    = 0x000000FF,   /* Packet Checksum Start */
    PcssSHIFT   = 0,
    Ipofl       = 0x00000100,   /* IP Checksum Off-load Enable */
    Tuofl       = 0x00000200,   /* TCP/UDP Checksum Off-load Enable */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)18>>=
enum {                  /* Manc */
    Arpen       = 0x00002000,   /* Enable ARP Request Filtering */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)19>>=
enum {                  /* Receive Delay Timer Ring */
    DelayMASK   = 0x0000FFFF,   /* delay timer in 1.024nS increments */
    DelaySHIFT  = 0,
    Fpd     = 0x80000000,   /* Flush partial Descriptor Block */
};
@

<<struct Rd>>=
typedef struct Rd {         /* Receive Descriptor */
    uint    addr[2];
    ushort  length;
    ushort  checksum;
    uchar   status;
    uchar   errors;
    ushort  special;
} Rd;
@

<<enum _anon_ (kernel/network/386/etherigbe.c)20>>=
enum {                  /* Rd status */
    Rdd     = 0x01,     /* Descriptor Done */
    Reop        = 0x02,     /* End of Packet */
    Ixsm        = 0x04,     /* Ignore Checksum Indication */
    Vp      = 0x08,     /* Packet is 802.1Q (matched VET) */
    Tcpcs       = 0x20,     /* TCP Checksum Calculated on Packet */
    Ipcs        = 0x40,     /* IP Checksum Calculated on Packet */
    Pif     = 0x80,     /* Passed in-exact filter */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)21>>=
enum {                  /* Rd errors */
    Ce      = 0x01,     /* CRC Error or Alignment Error */
    Se      = 0x02,     /* Symbol Error */
    Seq     = 0x04,     /* Sequence Error */
    Cxe     = 0x10,     /* Carrier Extension Error */
    Tcpe        = 0x20,     /* TCP/UDP Checksum Error */
    Ipe     = 0x40,     /* IP Checksum Error */
    Rxe     = 0x80,     /* RX Data Error */
};
@

<<struct Td>>=
struct Td {             /* Transmit Descriptor */
    union {
        uint    addr[2];    /* Data */
        struct {        /* Context */
            uchar   ipcss;
            uchar   ipcso;
            ushort  ipcse;
            uchar   tucss;
            uchar   tucso;
            ushort  tucse;
        };
    };
    uint    control;
    uint    status;
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)22>>=
enum {                  /* Td control */
    LenMASK     = 0x000FFFFF,   /* Data/Packet Length Field */
    LenSHIFT    = 0,
    DtypeCD     = 0x00000000,   /* Data Type 'Context Descriptor' */
    DtypeDD     = 0x00100000,   /* Data Type 'Data Descriptor' */
    PtypeTCP    = 0x01000000,   /* TCP/UDP Packet Type (CD) */
    Teop        = 0x01000000,   /* End of Packet (DD) */
    PtypeIP     = 0x02000000,   /* IP Packet Type (CD) */
    Ifcs        = 0x02000000,   /* Insert FCS (DD) */
    Tse     = 0x04000000,   /* TCP Segmentation Enable */
    Rs      = 0x08000000,   /* Report Status */
    Rps     = 0x10000000,   /* Report Status Sent */
    Dext        = 0x20000000,   /* Descriptor Extension */
    Vle     = 0x40000000,   /* VLAN Packet Enable */
    Ide     = 0x80000000,   /* Interrupt Delay Enable */
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)23>>=
enum {                  /* Td status */
    Tdd     = 0x00000001,   /* Descriptor Done */
    Ec      = 0x00000002,   /* Excess Collisions */
    Lc      = 0x00000004,   /* Late Collision */
    Tu      = 0x00000008,   /* Transmit Underrun */
    Iixsm       = 0x00000100,   /* Insert IP Checksum */
    Itxsm       = 0x00000200,   /* Insert TCP/UDP Checksum */
    HdrlenMASK  = 0x0000FF00,   /* Header Length (Tse) */
    HdrlenSHIFT = 8,
    VlanMASK    = 0x0FFF0000,   /* VLAN Identifier */
    VlanSHIFT   = 16,
    Tcfi        = 0x10000000,   /* Canonical Form Indicator */
    PriMASK     = 0xE0000000,   /* User Priority */
    PriSHIFT    = 29,
    MssMASK     = 0xFFFF0000,   /* Maximum Segment Size (Tse) */
    MssSHIFT    = 16,
};
@

<<enum _anon_ (kernel/network/386/etherigbe.c)24>>=
enum {
    Nrd     = 256,      /* multiple of 8 */
    Ntd     = 64,       /* multiple of 8 */
    Nrb     = 1024,     /* private receive buffers per Ctlr */
    Rbsz        = 2048,
};
@

<<struct CtlrEtherIgbe>>=
struct CtlrEtherIgbe {
    int port;
    Pcidev* pcidev;
    CtlrEtherIgbe*  next;
    Ether*  edev;
    int active;
    int started;
    int id;
    int cls;
    ushort  eeprom[0x40];

    QLock   alock;          /* attach */
    void*   alloc;          /* receive/transmit descriptors */
    int nrd;
    int ntd;
    int nrb;            /* # bufs this Ctlr has in the pool */

    int*    nic;
    Lock    imlock;
    int im;         /* interrupt mask */

    Mii*    mii;
    Rendez  lrendez;
    int lim;

    int link;

    QLock   slock;
    uint    statistics[Nstatistics];
    uint    lsleep;
    uint    lintr;
    uint    rsleep;
    uint    rintr;
    uint    txdw;
    uint    tintr;
    uint    ixsm;
    uint    ipcs;
    uint    tcpcs;

    eaddr   ra;       /* receive address */
    ulong   mta[128];       /* multicast table array */

    Rendez  rrendez;
    int rim;
    int rdfree;         /* rx descriptors awaiting packets */
    Rd* rdba;           /* receive descriptor base address */
    Block** rb;         /* receive buffers */
    int rdh;            /* receive descriptor head */
    int rdt;            /* receive descriptor tail */
    int rdtr;           /* receive delay timer ring value */

    Lock    tlock;
    int tdfree;
    Td* tdba;           /* transmit descriptor base address */
    Block** tb;         /* transmit buffers */
    int tdh;            /* transmit descriptor head */
    int tdt;            /* transmit descriptor tail */

    int txcw;
    int fcrtl;
    int fcrth;
};
@

<<macro csr32r>>=
#define csr32r(c, r)    (*((c)->nic+((r)/4)))
@

<<macro csr32w>>=
#define csr32w(c, r, v) (*((c)->nic+((r)/4)) = (v))
@

<<global igbectlrhead>>=
static CtlrEtherIgbe* igbectlrhead;
@

<<global igbectlrtail>>=
static CtlrEtherIgbe* igbectlrtail;
@

<<global igberblock>>=
static Lock igberblock;     /* free receive Blocks */
@

<<global igberbpool>>=
static Block* igberbpool;   /* receive Blocks for all igbe controllers */
@

<<global statistics>>=
static char* statistics[Nstatistics] = {
    "CRC Error",
    "Alignment Error",
    "Symbol Error",
    "RX Error",
    "Missed Packets",
    "Single Collision",
    "Excessive Collisions",
    "Multiple Collision",
    "Late Collisions",
    nil,
    "Collision",
    "Transmit Underrun",
    "Defer",
    "Transmit - No CRS",
    "Sequence Error",
    "Carrier Extension Error",
    "Receive Error Length",
    nil,
    "XON Received",
    "XON Transmitted",
    "XOFF Received",
    "XOFF Transmitted",
    "FC Received Unsupported",
    "Packets Received (64 Bytes)",
    "Packets Received (65-127 Bytes)",
    "Packets Received (128-255 Bytes)",
    "Packets Received (256-511 Bytes)",
    "Packets Received (512-1023 Bytes)",
    "Packets Received (1024-1522 Bytes)",
    "Good Packets Received",
    "Broadcast Packets Received",
    "Multicast Packets Received",
    "Good Packets Transmitted",
    nil,
    "Good Octets Received",
    nil,
    "Good Octets Transmitted",
    nil,
    nil,
    nil,
    "Receive No Buffers",
    "Receive Undersize",
    "Receive Fragment",
    "Receive Oversize",
    "Receive Jabber",
    nil,
    nil,
    nil,
    "Total Octets Received",
    nil,
    "Total Octets Transmitted",
    nil,
    "Total Packets Received",
    "Total Packets Transmitted",
    "Packets Transmitted (64 Bytes)",
    "Packets Transmitted (65-127 Bytes)",
    "Packets Transmitted (128-255 Bytes)",
    "Packets Transmitted (256-511 Bytes)",
    "Packets Transmitted (512-1023 Bytes)",
    "Packets Transmitted (1024-1522 Bytes)",
    "Multicast Packets Transmitted",
    "Broadcast Packets Transmitted",
    "TCP Segmentation Context Transmitted",
    "TCP Segmentation Context Fail",
};
@

<<function igbeifstat>>=
static long
igbeifstat(Ether* edev, void* a, long n, ulong offset)
{
    CtlrEtherIgbe *ctlr;
    char *p, *s;
    int i, l, r;
    uvlong tuvl, ruvl;

    ctlr = edev->ctlr;
    qlock(&ctlr->slock);
    p = malloc(READSTR);
    if(p == nil) {
        qunlock(&ctlr->slock);
        error(Enomem);
    }
    l = 0;
    for(i = 0; i < Nstatistics; i++){
        r = csr32r(ctlr, Statistics+i*4);
        if((s = statistics[i]) == nil)
            continue;
        switch(i){
        case Gorcl:
        case Gotcl:
        case Torl:
        case Totl:
            ruvl = r;
            ruvl += ((uvlong)csr32r(ctlr, Statistics+(i+1)*4))<<32;
            tuvl = ruvl;
            tuvl += ctlr->statistics[i];
            tuvl += ((uvlong)ctlr->statistics[i+1])<<32;
            if(tuvl == 0)
                continue;
            ctlr->statistics[i] = tuvl;
            ctlr->statistics[i+1] = tuvl>>32;
            l += snprint(p+l, READSTR-l, "%s: %llud %llud\n",
                s, tuvl, ruvl);
            i++;
            break;

        default:
            ctlr->statistics[i] += r;
            if(ctlr->statistics[i] == 0)
                continue;
            l += snprint(p+l, READSTR-l, "%s: %ud %ud\n",
                s, ctlr->statistics[i], r);
            break;
        }
    }

    l += snprint(p+l, READSTR-l, "lintr: %ud %ud\n",
        ctlr->lintr, ctlr->lsleep);
    l += snprint(p+l, READSTR-l, "rintr: %ud %ud\n",
        ctlr->rintr, ctlr->rsleep);
    l += snprint(p+l, READSTR-l, "tintr: %ud %ud\n",
        ctlr->tintr, ctlr->txdw);
    l += snprint(p+l, READSTR-l, "ixcs: %ud %ud %ud\n",
        ctlr->ixsm, ctlr->ipcs, ctlr->tcpcs);
    l += snprint(p+l, READSTR-l, "rdtr: %ud\n", ctlr->rdtr);
    l += snprint(p+l, READSTR-l, "Ctrlext: %08x\n", csr32r(ctlr, Ctrlext));

    l += snprint(p+l, READSTR-l, "eeprom:");
    for(i = 0; i < 0x40; i++){
        if(i && ((i & 0x07) == 0))
            l += snprint(p+l, READSTR-l, "\n       ");
        l += snprint(p+l, READSTR-l, " %4.4uX", ctlr->eeprom[i]);
    }
    l += snprint(p+l, READSTR-l, "\n");

    if(ctlr->mii != nil && ctlr->mii->curphy != nil){
        l += snprint(p+l, READSTR-l, "phy:   ");
        for(i = 0; i < NMiiPhyr; i++){
            if(i && ((i & 0x07) == 0))
                l += snprint(p+l, READSTR-l, "\n       ");
            r = miimir(ctlr->mii, i);
            l += snprint(p+l, READSTR-l, " %4.4uX", r);
        }
        snprint(p+l, READSTR-l, "\n");
    }
    n = readstr(offset, a, n, p);
    free(p);
    qunlock(&ctlr->slock);

    return n;
}
@
% >> >> >> >> >>

<<enum _anon_ (kernel/network/386/etherigbe.c)25>>=
enum {
    CMrdtr,
};
@

<<global igbectlmsg>>=
static Cmdtab igbectlmsg[] = {
    CMrdtr, "rdtr", 2,
};
@

<<function igbectl>>=
static long
igbectl(Ether* edev, void* buf, long n)
{
    int v;
    char *p;
    CtlrEtherIgbe *ctlr;
    Cmdbuf *cb;
    Cmdtab *ct;

    if((ctlr = edev->ctlr) == nil)
        error(Enonexist);

    cb = parsecmd(buf, n);
    if(waserror()){
        free(cb);
        nexterror();
    }

    ct = lookupcmd(cb, igbectlmsg, nelem(igbectlmsg));
    switch(ct->index){
    case CMrdtr:
        v = strtol(cb->f[1], &p, 0);
        if(v < 0 || p == cb->f[1] || v > 0xFFFF)
            error(Ebadarg);
        ctlr->rdtr = v;
        csr32w(ctlr, Rdtr, Fpd|v);
        break;
    }
    free(cb);
    poperror();

    return n;
}
@

<<function igbepromiscuous>>=
static void
igbepromiscuous(void* arg, int on)
{
    int rctl;
    CtlrEtherIgbe *ctlr;
    Ether *edev;

    edev = arg;
    ctlr = edev->ctlr;

    rctl = csr32r(ctlr, Rctl);
    rctl &= ~MoMASK;
    rctl |= Mo47b36;
    if(on)
        rctl |= Upe|Mpe;
    else
        rctl &= ~(Upe|Mpe);
    csr32w(ctlr, Rctl, rctl|Mpe);   /* temporarily keep Mpe on */
}
@

<<function igbemulticast>>=
static void
igbemulticast(void* arg, uchar* addr, int add)
{
    int bit, x;
    CtlrEtherIgbe *ctlr;
    Ether *edev;

    edev = arg;
    ctlr = edev->ctlr;

    x = addr[5]>>1;
    bit = ((addr[5] & 1)<<4)|(addr[4]>>4);
    /*
     * multiple ether addresses can hash to the same filter bit,
     * so it's never safe to clear a filter bit.
     * if we want to clear filter bits, we need to keep track of
     * all the multicast addresses in use, clear all the filter bits,
     * then set the ones corresponding to in-use addresses.
     */
    if(add)
        ctlr->mta[x] |= 1<<bit;
//  else
//      ctlr->mta[x] &= ~(1<<bit);

    csr32w(ctlr, Mta+x*4, ctlr->mta[x]);
}
@

<<function igberballoc>>=
static Block*
igberballoc(void)
{
    Block *bp;

    ilock(&igberblock);
    if((bp = igberbpool) != nil){
        igberbpool = bp->next;
        bp->next = nil;
        arch_xinc(&bp->ref);    /* prevent bp from being freed */
    }
    iunlock(&igberblock);

    return bp;
}
@

<<function igberbfree>>=
static void
igberbfree(Block* bp)
{
    bp->rp = bp->lim - Rbsz;
    bp->wp = bp->rp;
    bp->flag &= ~(Bipck | Budpck | Btcpck | Bpktck);

    ilock(&igberblock);
    bp->next = igberbpool;
    igberbpool = bp;
    iunlock(&igberblock);
}
@

<<function igbeim>>=
static void
igbeim(CtlrEtherIgbe* ctlr, int im)
{
    ilock(&ctlr->imlock);
    ctlr->im |= im;
    csr32w(ctlr, Ims, ctlr->im);
    iunlock(&ctlr->imlock);
}
@

<<function igbelim>>=
static int
igbelim(void* ctlr)
{
    return ((CtlrEtherIgbe*)ctlr)->lim != 0;
}
@

<<function igbelproc>>=
static void
igbelproc(void* arg)
{
    CtlrEtherIgbe *ctlr;
    Ether *edev;
    MiiPhy *phy;
    int ctrl, r;

    edev = arg;
    ctlr = edev->ctlr;
    for(;;){
        if(ctlr->mii == nil || ctlr->mii->curphy == nil) {
            sched();
            continue;
        }

        /*
         * To do:
         *  logic to manage status change,
         *  this is incomplete but should work
         *  one time to set up the hardware.
         *
         *  MiiPhy.speed, etc. should be in Mii.
         */
        if(miistatus(ctlr->mii) < 0)
            //continue;
            goto enable;

        phy = ctlr->mii->curphy;
        ctrl = csr32r(ctlr, Ctrl);

        switch(ctlr->id){
        case i82543gc:
        case i82544ei:
        case i82544eif:
        default:
            if(!(ctrl & Asde)){
                ctrl &= ~(SspeedMASK|Ilos|Fd);
                ctrl |= Frcdplx|Frcspd;
                if(phy->speed == 1000)
                    ctrl |= Sspeed1000;
                else if(phy->speed == 100)
                    ctrl |= Sspeed100;
                if(phy->fd)
                    ctrl |= Fd;
            }
            break;

        case i82540em:
        case i82540eplp:
        case i82547gi:
        case i82541gi:
        case i82541gi2:
        case i82541pi:
            break;
        }

        /*
         * Collision Distance.
         */
        r = csr32r(ctlr, Tctl);
        r &= ~ColdMASK;
        if(phy->fd)
            r |= 64<<ColdSHIFT;
        else
            r |= 512<<ColdSHIFT;
        csr32w(ctlr, Tctl, r);

        /*
         * Flow control.
         */
        if(phy->rfc)
            ctrl |= Rfce;
        if(phy->tfc)
            ctrl |= Tfce;
        csr32w(ctlr, Ctrl, ctrl);

enable:
        ctlr->lim = 0;
        igbeim(ctlr, Lsc);

        ctlr->lsleep++;
        sleep(&ctlr->lrendez, igbelim, ctlr);
    }
}
@

<<function igbetxinit>>=
static void
igbetxinit(CtlrEtherIgbe* ctlr)
{
    int i, r;
    Block *bp;

    csr32w(ctlr, Tctl, (0x0F<<CtSHIFT)|Psp|(66<<ColdSHIFT));
    switch(ctlr->id){
    default:
        r = 6;
        break;
    case i82543gc:
    case i82544ei:
    case i82544eif:
    case i82544gc:
    case i82540em:
    case i82540eplp:
    case i82541ei:
    case i82541gi:
    case i82541gi2:
    case i82541pi:
    case i82545em:
    case i82545gmc:
    case i82546gb:
    case i82546eb:
    case i82547ei:
    case i82547gi:
        r = 8;
        break;
    }
    csr32w(ctlr, Tipg, (6<<20)|(8<<10)|r);
    csr32w(ctlr, Ait, 0);
    csr32w(ctlr, Txdmac, 0);

    csr32w(ctlr, Tdbal, PCIWADDR(ctlr->tdba));
    csr32w(ctlr, Tdbah, 0);
    csr32w(ctlr, Tdlen, ctlr->ntd*sizeof(Td));
    ctlr->tdh = PREV(0, ctlr->ntd);
    csr32w(ctlr, Tdh, 0);
    ctlr->tdt = 0;
    csr32w(ctlr, Tdt, 0);

    for(i = 0; i < ctlr->ntd; i++){
        if((bp = ctlr->tb[i]) != nil){
            ctlr->tb[i] = nil;
            freeb(bp);
        }
        memset(&ctlr->tdba[i], 0, sizeof(Td));
    }
    ctlr->tdfree = ctlr->ntd;

    csr32w(ctlr, Tidv, 128);
    r = (4<<WthreshSHIFT)|(4<<HthreshSHIFT)|(8<<PthreshSHIFT);

    switch(ctlr->id){
    default:
        break;
    case i82540em:
    case i82540eplp:
    case i82547gi:
    case i82545em:
    case i82545gmc:
    case i82546gb:
    case i82546eb:
    case i82541gi:
    case i82541gi2:
    case i82541pi:
        r = csr32r(ctlr, Txdctl);
        r &= ~WthreshMASK;
        r |= Gran|(4<<WthreshSHIFT);

        csr32w(ctlr, Tadv, 64);
        break;
    }

    csr32w(ctlr, Txdctl, r);

    r = csr32r(ctlr, Tctl);
    r |= Ten;
    csr32w(ctlr, Tctl, r);
}
@

<<function igbetransmit>>=
static void
igbetransmit(Ether* edev)
{
    Td *td;
    Block *bp;
    CtlrEtherIgbe *ctlr;
    int tdh, tdt;

    ctlr = edev->ctlr;

    ilock(&ctlr->tlock);

    /*
     * Free any completed packets
     */
    tdh = ctlr->tdh;
    while(NEXT(tdh, ctlr->ntd) != csr32r(ctlr, Tdh)){
        if((bp = ctlr->tb[tdh]) != nil){
            ctlr->tb[tdh] = nil;
            freeb(bp);
        }
        memset(&ctlr->tdba[tdh], 0, sizeof(Td));
        tdh = NEXT(tdh, ctlr->ntd);
    }
    ctlr->tdh = tdh;

    /*
     * Try to fill the ring back up.
     */
    tdt = ctlr->tdt;
    while(NEXT(tdt, ctlr->ntd) != tdh){
        if((bp = qget(edev->oq)) == nil)
            break;
        td = &ctlr->tdba[tdt];
        td->addr[0] = PCIWADDR(bp->rp);
        td->control = ((BLEN(bp) & LenMASK)<<LenSHIFT);
        td->control |= Dext|Ifcs|Teop|DtypeDD;
        ctlr->tb[tdt] = bp;
        tdt = NEXT(tdt, ctlr->ntd);
        if(NEXT(tdt, ctlr->ntd) == tdh){
            td->control |= Rs;
            ctlr->txdw++;
            ctlr->tdt = tdt;
            csr32w(ctlr, Tdt, tdt);
            igbeim(ctlr, Txdw);
            break;
        }
        ctlr->tdt = tdt;
        csr32w(ctlr, Tdt, tdt);
    }

    iunlock(&ctlr->tlock);
}
@

<<function igbereplenish>>=
static void
igbereplenish(CtlrEtherIgbe* ctlr)
{
    Rd *rd;
    int rdt;
    Block *bp;

    rdt = ctlr->rdt;
    while(NEXT(rdt, ctlr->nrd) != ctlr->rdh){
        rd = &ctlr->rdba[rdt];
        if(ctlr->rb[rdt] == nil){
            bp = igberballoc();
            if(bp == nil){
                iprint("#l%d: igbereplenish: no available buffers\n",
                    ctlr->edev->ctlrno);
                break;
            }
            ctlr->rb[rdt] = bp;
            rd->addr[0] = PCIWADDR(bp->rp);
            rd->addr[1] = 0;
        }
        arch_coherence();
        rd->status = 0;
        rdt = NEXT(rdt, ctlr->nrd);
        ctlr->rdfree++;
    }
    ctlr->rdt = rdt;
    csr32w(ctlr, Rdt, rdt);
}
@

<<function igberxinit>>=
static void
igberxinit(CtlrEtherIgbe* ctlr)
{
    int i;
    Block *bp;

    /* temporarily keep Mpe on */
    csr32w(ctlr, Rctl, Dpf|Bsize2048|Bam|RdtmsHALF|Mpe);

    csr32w(ctlr, Rdbal, PCIWADDR(ctlr->rdba));
    csr32w(ctlr, Rdbah, 0);
    csr32w(ctlr, Rdlen, ctlr->nrd*sizeof(Rd));
    ctlr->rdh = 0;
    csr32w(ctlr, Rdh, 0);
    ctlr->rdt = 0;
    csr32w(ctlr, Rdt, 0);
    ctlr->rdtr = 0;
    csr32w(ctlr, Rdtr, Fpd|0);

    for(i = 0; i < ctlr->nrd; i++){
        if((bp = ctlr->rb[i]) != nil){
            ctlr->rb[i] = nil;
            freeb(bp);
        }
    }
    igbereplenish(ctlr);

    switch(ctlr->id){
    case i82540em:
    case i82540eplp:
    case i82541gi:
    case i82541gi2:
    case i82541pi:
    case i82545em:
    case i82545gmc:
    case i82546gb:
    case i82546eb:
    case i82547gi:
        csr32w(ctlr, Radv, 64);
        break;
    }
    csr32w(ctlr, Rxdctl, (8<<WthreshSHIFT)|(8<<HthreshSHIFT)|4);

    /*
     * Disable checksum offload as it has known bugs.
     */
    csr32w(ctlr, Rxcsum, ETHERHDRSIZE<<PcssSHIFT);
}
@

<<function igberim>>=
static int
igberim(void* ctlr)
{
    return ((CtlrEtherIgbe*)ctlr)->rim != 0;
}
@

<<function igberproc>>=
static void
igberproc(void* arg)
{
    Rd *rd;
    Block *bp;
    CtlrEtherIgbe *ctlr;
    int r, rdh;
    Ether *edev;

    edev = arg;
    ctlr = edev->ctlr;

    igberxinit(ctlr);
    r = csr32r(ctlr, Rctl);
    r |= Ren;
    csr32w(ctlr, Rctl, r);

    for(;;){
        ctlr->rim = 0;
        igbeim(ctlr, Rxt0|Rxo|Rxdmt0|Rxseq);
        ctlr->rsleep++;
        sleep(&ctlr->rrendez, igberim, ctlr);

        rdh = ctlr->rdh;
        for(;;){
            rd = &ctlr->rdba[rdh];

            if(!(rd->status & Rdd))
                break;

            /*
             * Accept eop packets with no errors.
             * With no errors and the Ixsm bit set,
             * the descriptor status Tpcs and Ipcs bits give
             * an indication of whether the checksums were
             * calculated and valid.
             */
            if((rd->status & Reop) && rd->errors == 0){
                bp = ctlr->rb[rdh];
                ctlr->rb[rdh] = nil;
                bp->wp += rd->length;
                bp->next = nil;
                if(!(rd->status & Ixsm)){
                    ctlr->ixsm++;
                    if(rd->status & Ipcs){
                        /*
                         * IP checksum calculated
                         * (and valid as errors == 0).
                         */
                        ctlr->ipcs++;
                        bp->flag |= Bipck;
                    }
                    if(rd->status & Tcpcs){
                        /*
                         * TCP/UDP checksum calculated
                         * (and valid as errors == 0).
                         */
                        ctlr->tcpcs++;
                        bp->flag |= Btcpck|Budpck;
                    }
                    bp->checksum = rd->checksum;
                    bp->flag |= Bpktck;
                }
                etheriq(edev, bp, 1);
            }
            else if(ctlr->rb[rdh] != nil){
                freeb(ctlr->rb[rdh]);
                ctlr->rb[rdh] = nil;
            }

            memset(rd, 0, sizeof(Rd));
            arch_coherence();
            ctlr->rdfree--;
            rdh = NEXT(rdh, ctlr->nrd);
        }
        ctlr->rdh = rdh;

        if(ctlr->rdfree < ctlr->nrd/2 || (ctlr->rim & Rxdmt0))
            igbereplenish(ctlr);
    }
}
@

<<function igbeattach>>=
static void
igbeattach(Ether* edev)
{
    Block *bp;
    CtlrEtherIgbe *ctlr;
    char name[KNAMELEN];

    ctlr = edev->ctlr;
    ctlr->edev = edev;          /* point back to Ether* */
    qlock(&ctlr->alock);
    if(ctlr->alloc != nil){         /* already allocated? */
        qunlock(&ctlr->alock);
        return;
    }

    ctlr->tb = nil;
    ctlr->rb = nil;
    ctlr->alloc = nil;
    ctlr->nrb = 0;
    if(waserror()){
        while(ctlr->nrb > 0){
            bp = igberballoc();
            bp->free = nil;
            freeb(bp);
            ctlr->nrb--;
        }
        free(ctlr->tb);
        ctlr->tb = nil;
        free(ctlr->rb);
        ctlr->rb = nil;
        free(ctlr->alloc);
        ctlr->alloc = nil;
        qunlock(&ctlr->alock);
        nexterror();
    }

    ctlr->nrd = ROUND(Nrd, 8);
    ctlr->ntd = ROUND(Ntd, 8);
    ctlr->alloc = malloc(ctlr->nrd*sizeof(Rd)+ctlr->ntd*sizeof(Td) + 127);
    if(ctlr->alloc == nil) {
        print("igbe: can't allocate ctlr->alloc\n");
        error(Enomem);
    }
    ctlr->rdba = (Rd*)ROUNDUP((uintptr)ctlr->alloc, 128);
    ctlr->tdba = (Td*)(ctlr->rdba+ctlr->nrd);

    ctlr->rb = malloc(ctlr->nrd*sizeof(Block*));
    ctlr->tb = malloc(ctlr->ntd*sizeof(Block*));
    if (ctlr->rb == nil || ctlr->tb == nil) {
        print("igbe: can't allocate ctlr->rb or ctlr->tb\n");
        error(Enomem);
    }

    for(ctlr->nrb = 0; ctlr->nrb < Nrb; ctlr->nrb++){
        if((bp = allocb(Rbsz)) == nil)
            break;
        bp->free = igberbfree;
        freeb(bp);
    }

    snprint(name, KNAMELEN, "#l%dlproc", edev->ctlrno);
    kproc(name, igbelproc, edev);

    snprint(name, KNAMELEN, "#l%drproc", edev->ctlrno);
    kproc(name, igberproc, edev);

    igbetxinit(ctlr);

    qunlock(&ctlr->alock);
    poperror();
}
@

<<function igbeinterrupt>>=
static void
igbeinterrupt(Ureg*, void* arg)
{
    CtlrEtherIgbe *ctlr;
    Ether *edev;
    int icr, im, txdw;

    edev = arg;
    ctlr = edev->ctlr;

    ilock(&ctlr->imlock);
    csr32w(ctlr, Imc, ~0);
    im = ctlr->im;
    txdw = 0;

    while((icr = csr32r(ctlr, Icr) & ctlr->im) != 0){
        if(icr & Lsc){
            im &= ~Lsc;
            ctlr->lim = icr & Lsc;
            wakeup(&ctlr->lrendez);
            ctlr->lintr++;
        }
        if(icr & (Rxt0|Rxo|Rxdmt0|Rxseq)){
            im &= ~(Rxt0|Rxo|Rxdmt0|Rxseq);
            ctlr->rim = icr & (Rxt0|Rxo|Rxdmt0|Rxseq);
            wakeup(&ctlr->rrendez);
            ctlr->rintr++;
        }
        if(icr & Txdw){
            im &= ~Txdw;
            txdw++;
            ctlr->tintr++;
        }
    }

    ctlr->im = im;
    csr32w(ctlr, Ims, im);
    iunlock(&ctlr->imlock);

    if(txdw)
        igbetransmit(edev);
}
@

<<function i82543mdior>>=
static int
i82543mdior(CtlrEtherIgbe* ctlr, int n)
{
    int ctrl, data, i, r;

    /*
     * Read n bits from the Management Data I/O Interface.
     */
    ctrl = csr32r(ctlr, Ctrl);
    r = (ctrl & ~Mddo)|Mdco;
    data = 0;
    for(i = n-1; i >= 0; i--){
        if(csr32r(ctlr, Ctrl) & Mdd)
            data |= (1<<i);
        csr32w(ctlr, Ctrl, Mdc|r);
        csr32w(ctlr, Ctrl, r);
    }
    csr32w(ctlr, Ctrl, ctrl);

    return data;
}
@

<<function i82543mdiow>>=
static int
i82543mdiow(CtlrEtherIgbe* ctlr, int bits, int n)
{
    int ctrl, i, r;

    /*
     * Write n bits to the Management Data I/O Interface.
     */
    ctrl = csr32r(ctlr, Ctrl);
    r = Mdco|Mddo|ctrl;
    for(i = n-1; i >= 0; i--){
        if(bits & (1<<i))
            r |= Mdd;
        else
            r &= ~Mdd;
        csr32w(ctlr, Ctrl, Mdc|r);
        csr32w(ctlr, Ctrl, r);
    }
    csr32w(ctlr, Ctrl, ctrl);

    return 0;
}
@

<<function i82543miimir>>=
static int
i82543miimir(Mii* mii, int pa, int ra)
{
    int data;
    CtlrEtherIgbe *ctlr;

    ctlr = mii->ctlr;

    /*
     * MII Management Interface Read.
     *
     * Preamble;
     * ST+OP+PHYAD+REGAD;
     * TA + 16 data bits.
     */
    i82543mdiow(ctlr, 0xFFFFFFFF, 32);
    i82543mdiow(ctlr, 0x1800|(pa<<5)|ra, 14);
    data = i82543mdior(ctlr, 18);

    if(data & 0x10000)
        return -1;

    return data & 0xFFFF;
}
@

<<function i82543miimiw>>=
static int
i82543miimiw(Mii* mii, int pa, int ra, int data)
{
    CtlrEtherIgbe *ctlr;

    ctlr = mii->ctlr;

    /*
     * MII Management Interface Write.
     *
     * Preamble;
     * ST+OP+PHYAD+REGAD+TA + 16 data bits;
     * Z.
     */
    i82543mdiow(ctlr, 0xFFFFFFFF, 32);
    data &= 0xFFFF;
    data |= (0x05<<(5+5+2+16))|(pa<<(5+2+16))|(ra<<(2+16))|(0x02<<16);
    i82543mdiow(ctlr, data, 32);

    return 0;
}
@

<<function igbemiimir>>=
static int
igbemiimir(Mii* mii, int pa, int ra)
{
    CtlrEtherIgbe *ctlr;
    int mdic, timo;

    ctlr = mii->ctlr;

    csr32w(ctlr, Mdic, MDIrop|(pa<<MDIpSHIFT)|(ra<<MDIrSHIFT));
    mdic = 0;
    for(timo = 64; timo; timo--){
        mdic = csr32r(ctlr, Mdic);
        if(mdic & (MDIe|MDIready))
            break;
        arch_microdelay(1);
    }

    if((mdic & (MDIe|MDIready)) == MDIready)
        return mdic & 0xFFFF;
    return -1;
}
@

<<function igbemiimiw>>=
static int
igbemiimiw(Mii* mii, int pa, int ra, int data)
{
    CtlrEtherIgbe *ctlr;
    int mdic, timo;

    ctlr = mii->ctlr;

    data &= MDIdMASK;
    csr32w(ctlr, Mdic, MDIwop|(pa<<MDIpSHIFT)|(ra<<MDIrSHIFT)|data);
    mdic = 0;
    for(timo = 64; timo; timo--){
        mdic = csr32r(ctlr, Mdic);
        if(mdic & (MDIe|MDIready))
            break;
        arch_microdelay(1);
    }
    if((mdic & (MDIe|MDIready)) == MDIready)
        return 0;
    return -1;
}
@

<<function igbemii>>=
static int
igbemii(CtlrEtherIgbe* ctlr)
{
    MiiPhy *phy;
    int ctrl, p, r;

    r = csr32r(ctlr, Status);
    if(r & Tbimode)
        return -1;
    if((ctlr->mii = malloc(sizeof(Mii))) == nil)
        return -1;
    ctlr->mii->ctlr = ctlr;

    ctrl = csr32r(ctlr, Ctrl);
    ctrl |= Slu;

    switch(ctlr->id){
    case i82543gc:
        ctrl |= Frcdplx|Frcspd;
        csr32w(ctlr, Ctrl, ctrl);

        /*
         * The reset pin direction (Mdro) should already
         * be set from the EEPROM load.
         * If it's not set this configuration is unexpected
         * so bail.
         */
        r = csr32r(ctlr, Ctrlext);
        if(!(r & Mdro)) {
            print("igbe: 82543gc Mdro not set\n");
            return -1;
        }
        csr32w(ctlr, Ctrlext, r);
        arch_delay(20);
        r = csr32r(ctlr, Ctrlext);
        r &= ~Mdr;
        csr32w(ctlr, Ctrlext, r);
        arch_delay(20);
        r = csr32r(ctlr, Ctrlext);
        r |= Mdr;
        csr32w(ctlr, Ctrlext, r);
        arch_delay(20);

        ctlr->mii->mir = i82543miimir;
        ctlr->mii->miw = i82543miimiw;
        break;
    case i82544ei:
    case i82544eif:
    case i82544gc:
    case i82540em:
    case i82540eplp:
    case i82547ei:
    case i82547gi:
    case i82541ei:
    case i82541gi:
    case i82541gi2:
    case i82541pi:
    case i82545em:
    case i82545gmc:
    case i82546gb:
    case i82546eb:
        ctrl &= ~(Frcdplx|Frcspd);
        csr32w(ctlr, Ctrl, ctrl);
        ctlr->mii->mir = igbemiimir;
        ctlr->mii->miw = igbemiimiw;
        break;
    default:
        free(ctlr->mii);
        ctlr->mii = nil;
        return -1;
    }

    if(mii(ctlr->mii, ~0) == 0 || (phy = ctlr->mii->curphy) == nil){
        free(ctlr->mii);
        ctlr->mii = nil;
        return -1;
    }
    USED(phy);
    // print("oui %X phyno %d\n", phy->oui, phy->phyno);

    /*
     * 8254X-specific PHY registers not in 802.3:
     *  0x10    PHY specific control
     *  0x14    extended PHY specific control
     * Set appropriate values then reset the PHY to have
     * changes noted.
     */
    switch(ctlr->id){
    case i82547gi:
    case i82541gi:
    case i82541gi2:
    case i82541pi:
    case i82545em:
    case i82545gmc:
    case i82546gb:
    case i82546eb:
        break;
    default:
        r = miimir(ctlr->mii, 16);
        r |= 0x0800;            /* assert CRS on Tx */
        r |= 0x0060;            /* auto-crossover all speeds */
        r |= 0x0002;            /* polarity reversal enabled */
        miimiw(ctlr->mii, 16, r);

        r = miimir(ctlr->mii, 20);
        r |= 0x0070;            /* +25MHz clock */
        r &= ~0x0F00;
        r |= 0x0100;            /* 1x downshift */
        miimiw(ctlr->mii, 20, r);

        miireset(ctlr->mii);
        p = 0;
        if(ctlr->txcw & TxcwPs)
            p |= AnaP;
        if(ctlr->txcw & TxcwAs)
            p |= AnaAP;
        miiane(ctlr->mii, ~0, p, ~0);
        break;
    }
    return 0;
}
@

<<function at93c46io>>=
static int
at93c46io(CtlrEtherIgbe* ctlr, char* op, int data)
{
    char *lp, *p;
    int i, loop, eecd, r;

    eecd = csr32r(ctlr, Eecd);

    r = 0;
    loop = -1;
    lp = nil;
    for(p = op; *p != '\0'; p++){
        switch(*p){
        default:
            return -1;
        case ' ':
            continue;
        case ':':           /* start of loop */
            loop = strtol(p+1, &lp, 0)-1;
            lp--;
            if(p == lp)
                loop = 7;
            p = lp;
            continue;
        case ';':           /* end of loop */
            if(lp == nil)
                return -1;
            loop--;
            if(loop >= 0)
                p = lp;
            else
                lp = nil;
            continue;
        case 'C':           /* assert clock */
            eecd |= Sk;
            break;
        case 'c':           /* deassert clock */
            eecd &= ~Sk;
            break;
        case 'D':           /* next bit in 'data' byte */
            if(loop < 0)
                return -1;
            if(data & (1<<loop))
                eecd |= Di;
            else
                eecd &= ~Di;
            break;
        case 'O':           /* collect data output */
            i = (csr32r(ctlr, Eecd) & Do) != 0;
            if(loop >= 0)
                r |= (i<<loop);
            else
                r = i;
            continue;
        case 'I':           /* assert data input */
            eecd |= Di;
            break;
        case 'i':           /* deassert data input */
            eecd &= ~Di;
            break;
        case 'S':           /* enable chip select */
            eecd |= Cs;
            break;
        case 's':           /* disable chip select */
            eecd &= ~Cs;
            break;
        }
        csr32w(ctlr, Eecd, eecd);
        arch_microdelay(50);
    }
    if(loop >= 0)
        return -1;
    return r;
}
@
% >> >> >>

<<function at93c46r>>=
static int
at93c46r(CtlrEtherIgbe* ctlr)
{
    ushort sum;
    char rop[20];
    int addr, areq, bits, data, eecd, i;

    eecd = csr32r(ctlr, Eecd);
    if(eecd & Spi){
        print("igbe: SPI EEPROM access not implemented\n");
        return 0;
    }
    if(eecd & (Eeszaddr|Eesz256))
        bits = 8;
    else
        bits = 6;

    sum = 0;

    switch(ctlr->id){
    default:
        areq = 0;
        break;
    case i82540em:
    case i82540eplp:
    case i82541ei:
    case i82541gi:
    case i82541gi2:
    case i82541pi:
    case i82545em:
    case i82545gmc:
    case i82546gb:
    case i82546eb:
    case i82547ei:
    case i82547gi:
        areq = 1;
        csr32w(ctlr, Eecd, eecd|Areq);
        for(i = 0; i < 1000; i++){
            if((eecd = csr32r(ctlr, Eecd)) & Agnt)
                break;
            arch_microdelay(5);
        }
        if(!(eecd & Agnt)){
            print("igbe: not granted EEPROM access\n");
            goto release;
        }
        break;
    }
    snprint(rop, sizeof(rop), "S :%dDCc;", bits+3);

    for(addr = 0; addr < 0x40; addr++){
        /*
         * Read a word at address 'addr' from the Atmel AT93C46
         * 3-Wire Serial EEPROM or compatible. The EEPROM access is
         * controlled by 4 bits in Eecd. See the AT93C46 datasheet
         * for protocol details.
         */
        if(at93c46io(ctlr, rop, (0x06<<bits)|addr) != 0){
            print("igbe: can't set EEPROM address 0x%2.2X\n", addr);
            goto release;
        }
        data = at93c46io(ctlr, ":16COc;", 0);
        at93c46io(ctlr, "sic", 0);
        ctlr->eeprom[addr] = data;
        sum += data;
    }

release:
    if(areq)
        csr32w(ctlr, Eecd, eecd & ~Areq);
    return sum;
}
@
% >> >> 

<<function igbedetach>>=
static int
igbedetach(CtlrEtherIgbe* ctlr)
{
    int r, timeo;

    /*
     * Perform a device reset to get the chip back to the
     * power-on state, followed by an EEPROM reset to read
     * the defaults for some internal registers.
     */
    csr32w(ctlr, Imc, ~0);
    csr32w(ctlr, Rctl, 0);
    csr32w(ctlr, Tctl, 0);

    arch_delay(10);

    csr32w(ctlr, Ctrl, Devrst);
    arch_delay(1);
    for(timeo = 0; timeo < 1000; timeo++){
        if(!(csr32r(ctlr, Ctrl) & Devrst))
            break;
        arch_delay(1);
    }
    if(csr32r(ctlr, Ctrl) & Devrst)
        return -1;
    r = csr32r(ctlr, Ctrlext);
    csr32w(ctlr, Ctrlext, r|Eerst);
    arch_delay(1);
    for(timeo = 0; timeo < 1000; timeo++){
        if(!(csr32r(ctlr, Ctrlext) & Eerst))
            break;
        arch_delay(1);
    }
    if(csr32r(ctlr, Ctrlext) & Eerst)
        return -1;

    switch(ctlr->id){
    default:
        break;
    case i82540em:
    case i82540eplp:
    case i82541gi:
    case i82541gi2:
    case i82541pi:
    case i82545em:
    case i82545gmc:
    case i82547gi:
    case i82546gb:
    case i82546eb:
        r = csr32r(ctlr, Manc);
        r &= ~Arpen;
        csr32w(ctlr, Manc, r);
        break;
    }

    csr32w(ctlr, Imc, ~0);
    arch_delay(1);
    for(timeo = 0; timeo < 1000; timeo++){
        if(!csr32r(ctlr, Icr))
            break;
        arch_delay(1);
    }
    if(csr32r(ctlr, Icr))
        return -1;

    return 0;
}
@

<<function igbeshutdown>>=
static void
igbeshutdown(Ether* ether)
{
    igbedetach(ether->ctlr);
}
@

<<function igbereset>>=
static int
igbereset(CtlrEtherIgbe* ctlr)
{
    int ctrl, i, pause, r, swdpio, txcw;

    if(igbedetach(ctlr))
        return -1;

    /*
     * Read the EEPROM, validate the checksum
     * then get the device back to a power-on state.
     */
    if((r = at93c46r(ctlr)) != 0xBABA){
        print("igbe: bad EEPROM checksum - 0x%4.4uX\n", r);
        return -1;
    }

    /*
     * Snarf and set up the receive addresses.
     * There are 16 addresses. The first should be the MAC address.
     * The others are cleared and not marked valid (MS bit of Rah).
     */
    if ((ctlr->id == i82546gb || ctlr->id == i82546eb) &&
        BUSFNO(ctlr->pcidev->tbdf) == 1)
        ctlr->eeprom[Ea+2] += 0x100;        /* second interface */
    if(ctlr->id == i82541gi && ctlr->eeprom[Ea] == 0xFFFF)
        ctlr->eeprom[Ea] = 0xD000;
    for(i = Ea; i < Eaddrlen/2; i++){
        ctlr->ra[2*i] = ctlr->eeprom[i];
        ctlr->ra[2*i+1] = ctlr->eeprom[i]>>8;
    }
    /* lan id seems to vary on 82543gc; don't use it */
    if (ctlr->id != i82543gc) {
        r = (csr32r(ctlr, Status) & Lanid) >> 2;
        ctlr->ra[5] += r;       /* ea ctlr[1] = ea ctlr[0]+1 */
    }

    r = (ctlr->ra[3]<<24)|(ctlr->ra[2]<<16)|(ctlr->ra[1]<<8)|ctlr->ra[0];
    csr32w(ctlr, Ral, r);
    r = 0x80000000|(ctlr->ra[5]<<8)|ctlr->ra[4];
    csr32w(ctlr, Rah, r);
    for(i = 1; i < 16; i++){
        csr32w(ctlr, Ral+i*8, 0);
        csr32w(ctlr, Rah+i*8, 0);
    }

    /*
     * Clear the Multicast Table Array.
     * It's a 4096 bit vector accessed as 128 32-bit registers.
     */
    memset(ctlr->mta, 0, sizeof(ctlr->mta));
    for(i = 0; i < 128; i++)
        csr32w(ctlr, Mta+i*4, 0);

    /*
     * Just in case the Eerst didn't load the defaults
     * (doesn't appear to fully on the 82543GC), do it manually.
     */
    if (ctlr->id == i82543gc) {
        txcw = csr32r(ctlr, Txcw);
        txcw &= ~(TxcwAne|TxcwPauseMASK|TxcwFd);
        ctrl = csr32r(ctlr, Ctrl);
        ctrl &= ~(SwdpioloMASK|Frcspd|Ilos|Lrst|Fd);

        if(ctlr->eeprom[Icw1] & 0x0400){
            ctrl |= Fd;
            txcw |= TxcwFd;
        }
        if(ctlr->eeprom[Icw1] & 0x0200)
            ctrl |= Lrst;
        if(ctlr->eeprom[Icw1] & 0x0010)
            ctrl |= Ilos;
        if(ctlr->eeprom[Icw1] & 0x0800)
            ctrl |= Frcspd;
        swdpio = (ctlr->eeprom[Icw1] & 0x01E0)>>5;
        ctrl |= swdpio<<SwdpioloSHIFT;
        csr32w(ctlr, Ctrl, ctrl);

        ctrl = csr32r(ctlr, Ctrlext);
        ctrl &= ~(Ips|SwdpiohiMASK);
        swdpio = (ctlr->eeprom[Icw2] & 0x00F0)>>4;
        if(ctlr->eeprom[Icw1] & 0x1000)
            ctrl |= Ips;
        ctrl |= swdpio<<SwdpiohiSHIFT;
        csr32w(ctlr, Ctrlext, ctrl);

        if(ctlr->eeprom[Icw2] & 0x0800)
            txcw |= TxcwAne;
        pause = (ctlr->eeprom[Icw2] & 0x3000)>>12;
        txcw |= pause<<TxcwPauseSHIFT;
        switch(pause){
        default:
            ctlr->fcrtl = 0x00002000;
            ctlr->fcrth = 0x00004000;
            txcw |= TxcwAs|TxcwPs;
            break;
        case 0:
            ctlr->fcrtl = 0x00002000;
            ctlr->fcrth = 0x00004000;
            break;
        case 2:
            ctlr->fcrtl = 0;
            ctlr->fcrth = 0;
            txcw |= TxcwAs;
            break;
        }
        ctlr->txcw = txcw;
        csr32w(ctlr, Txcw, txcw);
    }


    /*
     * Flow control - values from the datasheet.
     */
    csr32w(ctlr, Fcal, 0x00C28001);
    csr32w(ctlr, Fcah, 0x00000100);
    csr32w(ctlr, Fct, 0x00008808);
    csr32w(ctlr, Fcttv, 0x00000100);

    csr32w(ctlr, Fcrtl, ctlr->fcrtl);
    csr32w(ctlr, Fcrth, ctlr->fcrth);

    if(!(csr32r(ctlr, Status) & Tbimode) && igbemii(ctlr) < 0)
        return -1;

    return 0;
}
@

<<function igbepci>>=
static void
igbepci(void)
{
    int cls;
    Pcidev *p;
    CtlrEtherIgbe *ctlr;
    void *mem;

    p = nil;
    while(p = pcimatch(p, 0, 0)){
        if(p->ccrb != 0x02 || p->ccru != 0)
            continue;

        switch((p->did<<16)|p->vid){
        default:
            continue;
        case i82543gc:
        case i82544ei:
        case i82544eif:
        case i82544gc:
        case i82547ei:
        case i82547gi:
        case i82540em:
        case i82540eplp:
        case i82541ei:
        case i82541gi:
        case i82541gi2:
        case i82541pi:
        case i82545em:
        case i82545gmc:
        case i82546gb:
        case i82546eb:
            break;
        }

        mem = vmap(p->mem[0].bar & ~0x0F, p->mem[0].size);
        if(mem == nil){
            print("igbe: can't map %8.8luX\n", p->mem[0].bar);
            continue;
        }
        cls = pcicfgr8(p, PciCLS);
        switch(cls){
        default:
            print("igbe: p->cls %#ux, setting to 0x10\n", p->cls);
            p->cls = 0x10;
            pcicfgw8(p, PciCLS, p->cls);
            break;
        case 0x08:
        case 0x10:
            break;
        }
        ctlr = malloc(sizeof(CtlrEtherIgbe));
        if(ctlr == nil) {
            vunmap(mem, p->mem[0].size);
            error(Enomem);
        }
        ctlr->port = p->mem[0].bar & ~0x0F;
        ctlr->pcidev = p;
        ctlr->id = (p->did<<16)|p->vid;
        ctlr->cls = cls*4;
        ctlr->nic = mem;

        if(igbereset(ctlr)){
            free(ctlr);
            vunmap(mem, p->mem[0].size);
            continue;
        }
        pcisetbme(p);

        if(igbectlrhead != nil)
            igbectlrtail->next = ctlr;
        else
            igbectlrhead = ctlr;
        igbectlrtail = ctlr;
    }
}
@

<<function igbepnp>>=
static int
igbepnp(Ether* edev)
{
    CtlrEtherIgbe *ctlr;

    if(igbectlrhead == nil)
        igbepci();

    /*
     * Any adapter matches if no edev->port is supplied,
     * otherwise the ports must match.
     */
    for(ctlr = igbectlrhead; ctlr != nil; ctlr = ctlr->next){
        if(ctlr->active)
            continue;
        if(edev->port == 0 || edev->port == ctlr->port){
            ctlr->active = 1;
            break;
        }
    }
    if(ctlr == nil)
        return -1;

    edev->ctlr = ctlr;
    edev->port = ctlr->port;
    edev->irq = ctlr->pcidev->intl;
    edev->tbdf = ctlr->pcidev->tbdf;
    edev->mbps = 1000;
    memmove(edev->ea, ctlr->ra, Eaddrlen);

    /*
     * Linkage to the generic ethernet driver.
     */
    edev->attach = igbeattach;
    edev->transmit = igbetransmit;
    edev->interrupt = igbeinterrupt;
    edev->ifstat = igbeifstat;
    edev->ctl = igbectl;

    edev->arg = edev;
    edev->promiscuous = igbepromiscuous;
    edev->shutdown = igbeshutdown;
    edev->multicast = igbemulticast;

    return 0;
}
@

<<function etherigbelink>>=
void
etherigbelink(void)
{
    addethercard("i82543", igbepnp);
    addethercard("igbe", igbepnp);
}
@


%-------------------------------------------------------------

<<kernel/network/386/etherigbe.c>>=
/*
 * Intel 8254[340]NN Gigabit Ethernet PCI Controllers
 * as found on the Intel PRO/1000 series of adapters:
 *  82543GC Intel PRO/1000 T
 *  82544EI Intel PRO/1000 XT
 *  82540EM Intel PRO/1000 MT
 *  82541[GP]I
 *  82547GI
 *  82546GB
 *  82546EB
 * To Do:
 *  finish autonegotiation code;
 *  integrate fiber stuff back in (this ONLY handles
 *  the CAT5 cards at the moment);
 *  add tuning control via ctl file;
 *  this driver is little-endian specific.
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"

#include "io.h"
#include "../port/error.h"
#include "../port/netif.h"
#include "../port/etherif.h"

#include "ethermii.h"

typedef struct Td Td;
typedef struct CtlrEtherIgbe CtlrEtherIgbe;


<<enum _anon_ (kernel/network/386/etherigbe.c)>>

<<enum _anon_ (kernel/network/386/etherigbe.c)2>>

<<enum _anon_ (kernel/network/386/etherigbe.c)3>>

<<enum _anon_ (kernel/network/386/etherigbe.c)4>>

<<enum _anon_ (kernel/network/386/etherigbe.c)5>>

<<enum _anon_ (kernel/network/386/etherigbe.c)6>>

<<enum _anon_ (kernel/network/386/etherigbe.c)7>>

<<enum _anon_ (kernel/network/386/etherigbe.c)8>>

<<enum _anon_ (kernel/network/386/etherigbe.c)9>>

<<enum _anon_ (kernel/network/386/etherigbe.c)10>>

<<enum _anon_ (kernel/network/386/etherigbe.c)11>>

<<enum _anon_ (kernel/network/386/etherigbe.c)12>>

<<enum _anon_ (kernel/network/386/etherigbe.c)13>>

<<enum _anon_ (kernel/network/386/etherigbe.c)14>>

<<enum _anon_ (kernel/network/386/etherigbe.c)15>>

<<enum _anon_ (kernel/network/386/etherigbe.c)16>>

<<enum _anon_ (kernel/network/386/etherigbe.c)17>>

<<enum _anon_ (kernel/network/386/etherigbe.c)18>>

<<enum _anon_ (kernel/network/386/etherigbe.c)19>>

<<struct Rd>>

<<enum _anon_ (kernel/network/386/etherigbe.c)20>>

<<enum _anon_ (kernel/network/386/etherigbe.c)21>>

<<struct Td>>

<<enum _anon_ (kernel/network/386/etherigbe.c)22>>

<<enum _anon_ (kernel/network/386/etherigbe.c)23>>

<<enum _anon_ (kernel/network/386/etherigbe.c)24>>

<<struct CtlrEtherIgbe>>

<<macro csr32r>>
<<macro csr32w>>

<<global igbectlrhead>>
<<global igbectlrtail>>

<<global igberblock>>
<<global igberbpool>>

<<global statistics>>

<<function igbeifstat>>

<<enum _anon_ (kernel/network/386/etherigbe.c)25>>

<<global igbectlmsg>>

<<function igbectl>>

<<function igbepromiscuous>>

<<function igbemulticast>>

<<function igberballoc>>

<<function igberbfree>>

<<function igbeim>>

<<function igbelim>>

<<function igbelproc>>

<<function igbetxinit>>

<<function igbetransmit>>

<<function igbereplenish>>

<<function igberxinit>>

<<function igberim>>

<<function igberproc>>

<<function igbeattach>>

<<function igbeinterrupt>>

<<function i82543mdior>>

<<function i82543mdiow>>

<<function i82543miimir>>

<<function i82543miimiw>>

<<function igbemiimir>>

<<function igbemiimiw>>

<<function igbemii>>

<<function at93c46io>>

<<function at93c46r>>

<<function igbedetach>>

<<function igbeshutdown>>

<<function igbereset>>

<<function igbepci>>

<<function igbepnp>>

<<function etherigbelink>>

@


\subsection*{[[kernel/network/386/ethermii.c]]}

<<function mii>>=
int
mii(Mii* mii, int mask)
{
    MiiPhy *miiphy;
    int bit, oui, phyno, r, rmask;

    /*
     * Probe through mii for PHYs in mask;
     * return the mask of those found in the current probe.
     * If the PHY has not already been probed, update
     * the Mii information.
     */
    rmask = 0;
    for(phyno = 0; phyno < NMiiPhy; phyno++){
        bit = 1<<phyno;
        if(!(mask & bit))
            continue;
        if(mii->mask & bit){
            rmask |= bit;
            continue;
        }
        if(mii->mir(mii, phyno, Bmsr) == -1)
            continue;
        r = mii->mir(mii, phyno, Phyidr1);
        oui = (r & 0x3FFF)<<6;
        r = mii->mir(mii, phyno, Phyidr2);
        oui |= r>>10;
        if(oui == 0xFFFFF || oui == 0)
            continue;

        if((miiphy = malloc(sizeof(MiiPhy))) == nil)
            continue;

        miiphy->mii = mii;
        miiphy->oui = oui;
        miiphy->phyno = phyno;

        miiphy->anar = ~0;
        miiphy->fc = ~0;
        miiphy->mscr = ~0;

        mii->phy[phyno] = miiphy;
        if(mii->curphy == nil)
            mii->curphy = miiphy;
        mii->mask |= bit;
        mii->nphy++;

        rmask |= bit;
    }
    return rmask;
}
@

<<function miimir>>=
int
miimir(Mii* mii, int r)
{
    if(mii == nil || mii->ctlr == nil || mii->curphy == nil)
        return -1;
    return mii->mir(mii, mii->curphy->phyno, r);
}
@

<<function miimiw>>=
int
miimiw(Mii* mii, int r, int data)
{
    if(mii == nil || mii->ctlr == nil || mii->curphy == nil)
        return -1;
    return mii->miw(mii, mii->curphy->phyno, r, data);
}
@

<<function miireset>>=
int
miireset(Mii* mii)
{
    int bmcr;

    if(mii == nil || mii->ctlr == nil || mii->curphy == nil)
        return -1;
    bmcr = mii->mir(mii, mii->curphy->phyno, Bmcr);
    bmcr |= BmcrR;
    mii->miw(mii, mii->curphy->phyno, Bmcr, bmcr);
    arch_microdelay(1);

    return 0;
}
@

<<function miiane>>=
int
miiane(Mii* mii, int a, int p, int e)
{
    int anar, bmsr, mscr, r, phyno;

    if(mii == nil || mii->ctlr == nil || mii->curphy == nil)
        return -1;
    phyno = mii->curphy->phyno;

    bmsr = mii->mir(mii, phyno, Bmsr);
    if(!(bmsr & BmsrAna))
        return -1;

    if(a != ~0)
        anar = (AnaTXFD|AnaTXHD|Ana10FD|Ana10HD) & a;
    else if(mii->curphy->anar != ~0)
        anar = mii->curphy->anar;
    else{
        anar = mii->mir(mii, phyno, Anar);
        anar &= ~(AnaAP|AnaP|AnaT4|AnaTXFD|AnaTXHD|Ana10FD|Ana10HD);
        if(bmsr & Bmsr10THD)
            anar |= Ana10HD;
        if(bmsr & Bmsr10TFD)
            anar |= Ana10FD;
        if(bmsr & Bmsr100TXHD)
            anar |= AnaTXHD;
        if(bmsr & Bmsr100TXFD)
            anar |= AnaTXFD;
    }
    mii->curphy->anar = anar;

    if(p != ~0)
        anar |= (AnaAP|AnaP) & p;
    else if(mii->curphy->fc != ~0)
        anar |= mii->curphy->fc;
    mii->curphy->fc = (AnaAP|AnaP) & anar;

    if(bmsr & BmsrEs){
        mscr = mii->mir(mii, phyno, Mscr);
        mscr &= ~(Mscr1000TFD|Mscr1000THD);
        if(e != ~0)
            mscr |= (Mscr1000TFD|Mscr1000THD) & e;
        else if(mii->curphy->mscr != ~0)
            mscr = mii->curphy->mscr;
        else{
            r = mii->mir(mii, phyno, Esr);
            if(r & Esr1000THD)
                mscr |= Mscr1000THD;
            if(r & Esr1000TFD)
                mscr |= Mscr1000TFD;
        }
        mii->curphy->mscr = mscr;
        mii->miw(mii, phyno, Mscr, mscr);
    }
    mii->miw(mii, phyno, Anar, anar);

    r = mii->mir(mii, phyno, Bmcr);
    if(!(r & BmcrR)){
        r |= BmcrAne|BmcrRan;
        mii->miw(mii, phyno, Bmcr, r);
    }

    return 0;
}
@

<<function miistatus>>=
int
miistatus(Mii* mii)
{
    MiiPhy *phy;
    int anlpar, bmsr, p, r, phyno;

    if(mii == nil || mii->ctlr == nil || mii->curphy == nil)
        return -1;
    phy = mii->curphy;
    phyno = phy->phyno;

    /*
     * Check Auto-Negotiation is complete and link is up.
     * (Read status twice as the Ls bit is sticky).
     */
    bmsr = mii->mir(mii, phyno, Bmsr);
    if(!(bmsr & (BmsrAnc|BmsrAna))) {
        // print("miistatus: auto-neg incomplete\n");
        return -1;
    }

    bmsr = mii->mir(mii, phyno, Bmsr);
    if(!(bmsr & BmsrLs)){
        // print("miistatus: link down\n");
        phy->link = 0;
        return -1;
    }

    phy->speed = phy->fd = phy->rfc = phy->tfc = 0;
    if(phy->mscr){
        r = mii->mir(mii, phyno, Mssr);
        if((phy->mscr & Mscr1000TFD) && (r & Mssr1000TFD)){
            phy->speed = 1000;
            phy->fd = 1;
        }
        else if((phy->mscr & Mscr1000THD) && (r & Mssr1000THD))
            phy->speed = 1000;
    }

    anlpar = mii->mir(mii, phyno, Anlpar);
    if(phy->speed == 0){
        r = phy->anar & anlpar;
        if(r & AnaTXFD){
            phy->speed = 100;
            phy->fd = 1;
        }
        else if(r & AnaTXHD)
            phy->speed = 100;
        else if(r & Ana10FD){
            phy->speed = 10;
            phy->fd = 1;
        }
        else if(r & Ana10HD)
            phy->speed = 10;
    }
    if(phy->speed == 0) {
        // print("miistatus: phy speed 0\n");
        return -1;
    }

    if(phy->fd){
        p = phy->fc;
        r = anlpar & (AnaAP|AnaP);
        if(p == AnaAP && r == (AnaAP|AnaP))
            phy->tfc = 1;
        else if(p == (AnaAP|AnaP) && r == AnaAP)
            phy->rfc = 1;
        else if((p & AnaP) && (r & AnaP))
            phy->rfc = phy->tfc = 1;
    }

    phy->link = 1;

    return 0;
}
@


%-------------------------------------------------------------

<<kernel/network/386/ethermii.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "../port/error.h"
#include "../port/netif.h"
#include "../port/etherif.h"

#include "ethermii.h"

<<function mii>>

<<function miimir>>

<<function miimiw>>

<<function miireset>>

<<function miiane>>

<<function miistatus>>
@


\subsection*{[[kernel/network/386/ethermii.h]]}

<<enum _anon_ (kernel/network/386/ethermii.h)>>=
enum {          /* registers */
  Bmcr    = 0x00,   /* Basic Mode Control */
  Bmsr    = 0x01,   /* Basic Mode Status */
  Phyidr1   = 0x02,   /* PHY Identifier #1 */
  Phyidr2   = 0x03,   /* PHY Identifier #2 */
  Anar    = 0x04,   /* Auto-Negotiation Advertisement */
  Anlpar    = 0x05,   /* AN Link Partner Ability */
  Aner    = 0x06,   /* AN Expansion */
  Annptr    = 0x07,   /* AN Next Page TX */
  Annprr    = 0x08,   /* AN Next Page RX */
  Mscr    = 0x09,   /* MASTER-SLAVE Control */
  Mssr    = 0x0A,   /* MASTER-SLAVE Status */
  Esr   = 0x0F,   /* Extended Status */

  NMiiPhyr  = 32,
  NMiiPhy   = 32,
};
@

<<enum _anon_ (kernel/network/386/ethermii.h)2>>=
enum {          /* Bmcr */
  BmcrSs1   = 0x0040, /* Speed Select[1] */
  BmcrCte   = 0x0080, /* Collision Test Enable */
  BmcrDm    = 0x0100, /* Duplex Mode */
  BmcrRan   = 0x0200, /* Restart Auto-Negotiation */
  BmcrI   = 0x0400, /* Isolate */
  BmcrPd    = 0x0800, /* Power Down */
  BmcrAne   = 0x1000, /* Auto-Negotiation Enable */
  BmcrSs0   = 0x2000, /* Speed Select[0] */
  BmcrLe    = 0x4000, /* Loopback Enable */
  BmcrR   = 0x8000, /* Reset */
};
@

<<enum _anon_ (kernel/network/386/ethermii.h)3>>=
enum {          /* Bmsr */
  BmsrEc    = 0x0001, /* Extended Capability */
  BmsrJd    = 0x0002, /* Jabber Detect */
  BmsrLs    = 0x0004, /* Link Status */
  BmsrAna   = 0x0008, /* Auto-Negotiation Ability */
  BmsrRf    = 0x0010, /* Remote Fault */
  BmsrAnc   = 0x0020, /* Auto-Negotiation Complete */
  BmsrPs    = 0x0040, /* Preamble Suppression Capable */
  BmsrEs    = 0x0100, /* Extended Status */
  Bmsr100T2HD = 0x0200, /* 100BASE-T2 HD Capable */
  Bmsr100T2FD = 0x0400, /* 100BASE-T2 FD Capable */
  Bmsr10THD = 0x0800, /* 10BASE-T HD Capable */
  Bmsr10TFD = 0x1000, /* 10BASE-T FD Capable */
  Bmsr100TXHD = 0x2000, /* 100BASE-TX HD Capable */
  Bmsr100TXFD = 0x4000, /* 100BASE-TX FD Capable */
  Bmsr100T4 = 0x8000, /* 100BASE-T4 Capable */
};
@

<<enum _anon_ (kernel/network/386/ethermii.h)4>>=
enum {          /* Anar/Anlpar */
  Ana10HD   = 0x0020, /* Advertise 10BASE-T */
  Ana10FD   = 0x0040, /* Advertise 10BASE-T FD */
  AnaTXHD   = 0x0080, /* Advertise 100BASE-TX */
  AnaTXFD   = 0x0100, /* Advertise 100BASE-TX FD */
  AnaT4   = 0x0200, /* Advertise 100BASE-T4 */
  AnaP    = 0x0400, /* Pause */
  AnaAP   = 0x0800, /* Asymmetrical Pause */
  AnaRf   = 0x2000, /* Remote Fault */
  AnaAck    = 0x4000, /* Acknowledge */
  AnaNp   = 0x8000, /* Next Page Indication */
};
@

<<enum _anon_ (kernel/network/386/ethermii.h)5>>=
enum {          /* Mscr */
  Mscr1000THD = 0x0100, /* Advertise 1000BASE-T HD */
  Mscr1000TFD = 0x0200, /* Advertise 1000BASE-T FD */
};
@

<<enum _anon_ (kernel/network/386/ethermii.h)6>>=
enum {          /* Mssr */
  Mssr1000THD = 0x0400, /* Link Partner 1000BASE-T HD able */
  Mssr1000TFD = 0x0800, /* Link Partner 1000BASE-T FD able */
};
@

<<enum _anon_ (kernel/network/386/ethermii.h)7>>=
enum {          /* Esr */
  Esr1000THD  = 0x1000, /* 1000BASE-T HD Capable */
  Esr1000TFD  = 0x2000, /* 1000BASE-T FD Capable */
  Esr1000XHD  = 0x4000, /* 1000BASE-X HD Capable */
  Esr1000XFD  = 0x8000, /* 1000BASE-X FD Capable */
};
@

<<struct Mii>>=
struct Mii {
  Lock;
  int nphy;
  int mask;
  MiiPhy* phy[NMiiPhy];
  MiiPhy* curphy;

  void* ctlr;
  int (*mir)(Mii*, int, int);
  int (*miw)(Mii*, int, int, int);
};
@

<<struct MiiPhy>>=
struct MiiPhy {
  Mii*  mii;
  int oui;
  int phyno;

  int anar;
  int fc;
  int mscr;

  int link;
  int speed;
  int fd;
  int rfc;
  int tfc;
};
@


%-------------------------------------------------------------

<<kernel/network/386/ethermii.h>>=
typedef struct Mii Mii;
typedef struct MiiPhy MiiPhy;

<<enum _anon_ (kernel/network/386/ethermii.h)>>

<<enum _anon_ (kernel/network/386/ethermii.h)2>>

<<enum _anon_ (kernel/network/386/ethermii.h)3>>

<<enum _anon_ (kernel/network/386/ethermii.h)4>>

<<enum _anon_ (kernel/network/386/ethermii.h)5>>

<<enum _anon_ (kernel/network/386/ethermii.h)6>>

<<enum _anon_ (kernel/network/386/ethermii.h)7>>

<<struct Mii>>

<<struct MiiPhy>>

extern int mii(Mii*, int);
extern int miiane(Mii*, int, int, int);
extern int miimir(Mii*, int);
extern int miimiw(Mii*, int, int);
extern int miireset(Mii*);
extern int miistatus(Mii*);
@

\section{[[kernel/network/arm/]]}

\subsection*{[[network/arm/devether.c]]}

<<global etherxx(arm)>>=
static Ether *etherxx[MaxEther];
@

<<function etherattach(arm)>>=
Chan*
etherattach(char* spec)
{
    int ctlrno;
    char *p;
    Chan *chan;

    ctlrno = 0;
    if(spec && *spec){
        ctlrno = strtoul(spec, &p, 0);
        if((ctlrno == 0 && p == spec) || *p != 0)
            error(Ebadarg);
        if(ctlrno < 0 || ctlrno >= MaxEther)
            error(Ebadarg);
    }
    if(etherxx[ctlrno] == 0)
        error(Enodev);

    chan = devattach('l', spec);
    if(waserror()){
        chanfree(chan);
        nexterror();
    }
    chan->dev = ctlrno;
    if(etherxx[ctlrno]->attach)
        etherxx[ctlrno]->attach(etherxx[ctlrno]);
    poperror();
    return chan;
}
@

<<function etherwalk(arm)>>=
static Walkqid*
etherwalk(Chan* chan, Chan* nchan, char** name, int nname)
{
    return netifwalk(etherxx[chan->dev], chan, nchan, name, nname);
}
@

<<function etherstat(arm)>>=
static int
etherstat(Chan* chan, uchar* dp, int n)
{
    return netifstat(etherxx[chan->dev], chan, dp, n);
}
@

<<function etheropen(arm)>>=
static Chan*
etheropen(Chan* chan, int omode)
{
    return netifopen(etherxx[chan->dev], chan, omode);
}
@

<<function ethercreate(arm)>>=
static void
ethercreate(Chan*, char*, int, ulong)
{
}
@

<<function etherclose(arm)>>=
static void
etherclose(Chan* chan)
{
    netifclose(etherxx[chan->dev], chan);
}
@

<<function etherread(arm)>>=
static long
etherread(Chan* chan, void* buf, long n, vlong off)
{
    Ether *ether;
    ulong offset = off;

    ether = etherxx[chan->dev];
    if((chan->qid.type & QTDIR) == 0 && ether->ifstat){
        /*
         * With some controllers it is necessary to reach
         * into the chip to extract statistics.
         */
        if(NETTYPE(chan->qid.path) == Nifstatqid)
            return ether->ifstat(ether, buf, n, offset);
        else if(NETTYPE(chan->qid.path) == Nstatqid)
            ether->ifstat(ether, buf, 0, offset);
    }

    return netifread(ether, chan, buf, n, offset);
}
@

<<function etherbread(arm)>>=
static Block*
etherbread(Chan* chan, long n, ulong offset)
{
    return netifbread(etherxx[chan->dev], chan, n, offset);
}
@

<<function etherwstat(arm)>>=
static int
etherwstat(Chan* chan, uchar* dp, int n)
{
    return netifwstat(etherxx[chan->dev], chan, dp, n);
}
@

<<function etherrtrace(arm)>>=
static void
etherrtrace(Netfile* f, Etherpkt* pkt, int len)
{
    int i, n;
    Block *bp;

    if(qwindow(f->in) <= 0)
        return;
    if(len > 58)
        n = 58;
    else
        n = len;
    bp = iallocb(64);
    if(bp == nil)
        return;
    memmove(bp->wp, pkt->d, n);
    i = TK2MS(CPUS(0)->ticks);
    bp->wp[58] = len>>8;
    bp->wp[59] = len;
    bp->wp[60] = i>>24;
    bp->wp[61] = i>>16;
    bp->wp[62] = i>>8;
    bp->wp[63] = i;
    bp->wp += 64;
    qpass(f->in, bp);
}
@

<<function etheriq(arm)>>=
Block*
etheriq(Ether* ether, Block* bp, int fromwire)
{
    Etherpkt *pkt;
    ushort type;
    int len, multi, tome, fromme;
    Netfile **ep, *f, **fp, *fx;
    Block *xbp;

    ether->inpackets++;

    pkt = (Etherpkt*)bp->rp;
    len = BLEN(bp);
    type = (pkt->type[0]<<8)|pkt->type[1];
    fx = 0;
    ep = &ether->f[Ntypes];

    multi = pkt->d[0] & 1;
    /* check for valid multicast addresses */
    if(multi && memcmp(pkt->d, ether->bcast, sizeof(pkt->d)) != 0 &&
        ether->prom == 0){
        if(!activemulti(ether, pkt->d, sizeof(pkt->d))){
            if(fromwire){
                freeb(bp);
                bp = 0;
            }
            return bp;
        }
    }
    /* is it for me? */
    tome = memcmp(pkt->d, ether->ea, sizeof(pkt->d)) == 0;
    fromme = memcmp(pkt->s, ether->ea, sizeof(pkt->s)) == 0;

    /*
     * Multiplex the packet to all the connections which want it.
     * If the packet is not to be used subsequently (fromwire != 0),
     * attempt to simply pass it into one of the connections, thereby
     * saving a copy of the data (usual case hopefully).
     */
    for(fp = ether->f; fp < ep; fp++){
        if((f = *fp) != nil && (f->type == type || f->type < 0) &&
            (tome || multi || f->prom)){
            /* Don't want to hear bridged packets */
            if(f->bridge && !fromwire && !fromme)
                continue;
            if(!f->headersonly){
                if(fromwire && fx == 0)
                    fx = f;
                else if(xbp = iallocb(len)){
                    memmove(xbp->wp, pkt, len);
                    xbp->wp += len;
                    if(qpass(f->in, xbp) < 0)
                        ether->soverflows++;
                }
                else
                    ether->soverflows++;
            }
            else
                etherrtrace(f, pkt, len);
        }
    }

    if(fx){
        if(qpass(fx->in, bp) < 0)
            ether->soverflows++;
        return 0;
    }
    if(fromwire){
        freeb(bp);
        return 0;
    }
    return bp;
}
@

<<function etheroq(arm)>>=
static int
etheroq(Ether* ether, Block* bp)
{
    int len, loopback, s;
    Etherpkt *pkt;

    ether->outpackets++;

    /*
     * Check if the packet has to be placed back onto the input queue,
     * i.e. if it's a loopback or broadcast packet or the interface is
     * in promiscuous mode.
     * If it's a loopback packet indicate to etheriq that the data isn't
     * needed and return, etheriq will pass-on or free the block.
     * To enable bridging to work, only packets that were originated
     * by this interface are fed back.
     */
    pkt = (Etherpkt*)bp->rp;
    len = BLEN(bp);
    loopback = memcmp(pkt->d, ether->ea, sizeof(pkt->d)) == 0;
    if(loopback || memcmp(pkt->d, ether->bcast, sizeof(pkt->d)) == 0 || ether->prom){
        s = arch_splhi();
        etheriq(ether, bp, 0);
        arch_splx(s);
    }

    if(!loopback){
        qbwrite(ether->oq, bp);
        if(ether->transmit != nil)
            ether->transmit(ether);
    } else
        freeb(bp);

    return len;
}
@

<<function etherwrite(arm)>>=
static long
etherwrite(Chan* chan, void* buf, long n, vlong)
{
    Ether *ether;
    Block *bp;
    int nn, onoff;
    Cmdbuf *cb;

    ether = etherxx[chan->dev];
    if(NETTYPE(chan->qid.path) != Ndataqid) {
        nn = netifwrite(ether, chan, buf, n);
        if(nn >= 0)
            return nn;
        cb = parsecmd(buf, n);
        if(cb->f[0] && strcmp(cb->f[0], "nonblocking") == 0){
            if(cb->nf <= 1)
                onoff = 1;
            else
                onoff = atoi(cb->f[1]);
            qnoblock(ether->oq, onoff);
            free(cb);
            return n;
        }
        free(cb);
        if(ether->ctl!=nil)
            return ether->ctl(ether,buf,n);
            
        error(Ebadctl);
    }

    if(n > ether->maxmtu)
        error(Etoobig);
    if(n < ether->minmtu)
        error(Etoosmall);

    bp = allocb(n);
    if(waserror()){
        freeb(bp);
        nexterror();
    }
    memmove(bp->rp, buf, n);
    memmove(bp->rp+Eaddrlen, ether->ea, Eaddrlen);
    poperror();
    bp->wp += n;

    return etheroq(ether, bp);
}
@

<<function etherbwrite(arm)>>=
static long
etherbwrite(Chan* chan, Block* bp, ulong)
{
    Ether *ether;
    long n;

    n = BLEN(bp);
    if(NETTYPE(chan->qid.path) != Ndataqid){
        if(waserror()) {
            freeb(bp);
            nexterror();
        }
        n = etherwrite(chan, bp->rp, n, 0);
        poperror();
        freeb(bp);
        return n;
    }
    ether = etherxx[chan->dev];

    if(n > ether->maxmtu){
        freeb(bp);
        error(Etoobig);
    }
    if(n < ether->minmtu){
        freeb(bp);
        error(Etoosmall);
    }

    return etheroq(ether, bp);
}
@

<<global cards(arm)>>=
static struct {
    char*	type;
    int	(*reset)(Ether*);
} cards[MaxEther+1];
@

<<function addethercard(arm)>>=
void
addethercard(char* t, int (*r)(Ether*))
{
    static int ncard;

    if(ncard == MaxEther)
        panic("too many ether cards");
    cards[ncard].type = t;
    cards[ncard].reset = r;
    ncard++;
}
@

<<function parseether(arm)>>=
int
parseether(uchar *to, char *from)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    for(i = 0; i < Eaddrlen; i++){
        if(*p == 0)
            return -1;
        nip[0] = *p++;
        if(*p == 0)
            return -1;
        nip[1] = *p++;
        nip[2] = 0;
        to[i] = strtoul(nip, 0, 16);
        if(*p == ':')
            p++;
    }
    return 0;
}
@

<<function etherreset(arm)>>=
static void
etherreset(void)
{
    Ether *ether;
    int i, n, ctlrno;
    char name[KNAMELEN], buf[128];

    for(ether = 0, ctlrno = 0; ctlrno < MaxEther; ctlrno++){
        if(ether == 0)
            ether = malloc(sizeof(Ether));
        memset(ether, 0, sizeof(Ether));
        ether->ctlrno = ctlrno;
        ether->mbps = 10;
        ether->minmtu = ETHERMINTU;
        ether->maxmtu = ETHERMAXTU;

        if(archether(ctlrno, ether) <= 0)
            continue;

        if(arch_isaconfig("ether", ctlrno, ether) == 0){
//			free(ether);
//			return nil;
            continue;
        }
        for(n = 0; cards[n].type; n++){
            if(cistrcmp(cards[n].type, ether->type))
                continue;
            for(i = 0; i < ether->nopt; i++)
                if(cistrncmp(ether->opt[i], "ea=", 3) == 0){
                    if(parseether(ether->ea,
                        &ether->opt[i][3]) == -1)
                        memset(ether->ea, 0, Eaddrlen);
                } else if(cistrcmp(ether->opt[i],
                    "100BASE-TXFD") == 0)
                    ether->mbps = 100;
            if(cards[n].reset(ether))
                break;
            snprint(name, sizeof(name), "ether%d", ctlrno);

            if(ether->interrupt != nil && ether->irq >= 0)
                arch_intrenable(ether->irq, ether->interrupt,
                    ether, 0, name);

            i = snprint(buf, sizeof buf,
                "#l%d: %s: %dMbps port %#lux irq %d",
                ctlrno, ether->type, ether->mbps, ether->port,
                ether->irq);
            if(ether->mem)
                i += snprint(buf+i, sizeof buf - i,
                    " addr %#lux", PADDR(ether->mem));
            if(ether->size)
                i += snprint(buf+i, sizeof buf - i,
                    " size %#luX", ether->size);
            i += snprint(buf+i, sizeof buf - i,
                ": %2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux",
                ether->ea[0], ether->ea[1], ether->ea[2],
                ether->ea[3], ether->ea[4], ether->ea[5]);
            snprint(buf+i, sizeof buf - i, "\n");
            iprint("%s", buf);  /* it may be too early for print */

            if(ether->mbps >= 1000)
                netifinit(ether, name, Ntypes, 4*1024*1024);
            else if(ether->mbps >= 100)
                netifinit(ether, name, Ntypes, 1024*1024);
            else
                netifinit(ether, name, Ntypes, 65*1024);
            if(ether->oq == 0)
                ether->oq = qopen(ether->limit, Qmsg, 0, 0);
            if(ether->oq == 0)
                panic("etherreset %s", name);
            ether->alen = Eaddrlen;
            memmove(ether->addr, ether->ea, Eaddrlen);
            memset(ether->bcast, 0xFF, Eaddrlen);

            etherxx[ctlrno] = ether;
            ether = 0;
            break;
        }
    }
    if(ether)
        free(ether);
}
@

<<function ethershutdown(arm)>>=
static void
ethershutdown(void)
{
    Ether *ether;
    int i;

    for(i = 0; i < MaxEther; i++){
        ether = etherxx[i];
        if(ether == nil)
            continue;
        if(ether->shutdown == nil) {
            print("#l%d: no shutdown function\n", i);
            continue;
        }
        (*ether->shutdown)(ether);
    }
}
@

<<constant POLY(arm)>>=
#define POLY 0xedb88320
@

<<function ethercrc(arm)>>=
/* really slow 32 bit crc for ethers */
ulong
ethercrc(uchar *p, int len)
{
    int i, j;
    ulong crc, b;

    crc = 0xffffffff;
    for(i = 0; i < len; i++){
        b = *p++;
        for(j = 0; j < 8; j++){
            crc = (crc>>1) ^ (((crc^b) & 1) ? POLY : 0);
            b >>= 1;
        }
    }
    return crc;
}
@

<<function dumpoq(arm)>>=
void
dumpoq(Queue *oq)
{
    if (oq == nil)
        print("no outq! ");
    else if (qisclosed(oq))
        print("outq closed ");
    else if (qfull(oq))
        print("outq full ");
    else
        print("outq %d ", qlen(oq));
}
@

<<function dumpnetif(arm)>>=
void
dumpnetif(Netif *netif)
{
    print("netif %s ", netif->name);
    print("limit %d mbps %d link %d ",
        netif->limit, netif->mbps, netif->link);
    print("inpkts %lld outpkts %lld errs %d\n",
        netif->inpackets, netif->outpackets,
        netif->crcs + netif->oerrs + netif->frames + netif->overflows +
        netif->buffs + netif->soverflows);
}
@

<<global etherdevtab(arm)>>=
Dev etherdevtab = {
    .dc = 'l',
    .name = "ether",

    .reset = etherreset,
    .init = devinit,
    .shutdown = ethershutdown,
    .attach = etherattach,
    .walk = etherwalk,
    .stat = etherstat,
    .open = etheropen,
    .create = ethercreate,
    .close = etherclose,
    .read = etherread,
    .bread = etherbread,
    .write = etherwrite,
    .bwrite = etherbwrite,
    .remove = devremove,
    .wstat = etherwstat,
};
@


%-------------------------------------------------------------

<<kernel/network/arm/devether.c>>=
#include "u.h"
#include "../port/lib.h"
#include "../port/error.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"

#include "../port/netif.h"
#include "../port/etherif.h"

extern int archether(unsigned ctlno, Ether *ether);

<<global etherxx(arm)>>

<<function etherattach(arm)>>

<<function etherwalk(arm)>>

<<function etherstat(arm)>>

<<function etheropen(arm)>>

<<function ethercreate(arm)>>

<<function etherclose(arm)>>

<<function etherread(arm)>>

<<function etherbread(arm)>>

<<function etherwstat(arm)>>

<<function etherrtrace(arm)>>

<<function etheriq(arm)>>

<<function etheroq(arm)>>

<<function etherwrite(arm)>>

<<function etherbwrite(arm)>>

<<global cards(arm)>>

<<function addethercard(arm)>>

<<function parseether(arm)>>

<<function etherreset(arm)>>

<<function ethershutdown(arm)>>


<<constant POLY(arm)>>

<<function ethercrc(arm)>>

<<function dumpoq(arm)>>

<<function dumpnetif(arm)>>

<<global etherdevtab(arm)>>
@



\section{[[kernel/network/ip/]]}

\subsection*{[[kernel/network/ip/devip.c]]}


% ??? -> <>
<<function ipreset>>=
static void
ipreset(void)
{
    nullmediumlink();
    pktmediumlink();

    fmtinstall('i', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('E', eipfmt);
    fmtinstall('V', eipfmt);
    fmtinstall('M', eipfmt);
}
@




<<function ipstat>>=
static int
ipstat(Chan* c, uchar* db, int n)
{
    return devstat(c, db, n, nil, 0, ipgen);
}
@

<<function incoming>>=
static int
incoming(void* arg)
{
    Conv *conv;

    conv = arg;
    return conv->incall != nil;
}
@




<<function ipwstat>>=
static int
ipwstat(Chan *c, uchar *dp, int n)
{
    Dir d;
    Conv *cv;
    Fs *f;
    Proto *p;

    f = ipfs[c->dev];
    switch(TYPE(c->qid)) {
    default:
        error(Eperm);
        break;
    case Qctl:
    case Qdata:
        break;
    }

    n = convM2D(dp, n, &d, nil);
    if(n > 0){
        p = f->p[PROTO(c->qid)];
        cv = p->conv[CONV(c->qid)];
        if(!iseve() && strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if(d.uid[0])
            kstrdup(&cv->owner, d.uid);
        cv->perm = d.mode & 0777;
    }
    return n;
}
@



<<enum _anon_ (kernel/network/ip/devip.c)2>>=
enum
{
    <<constant Statelen>>
};
@


<<function ipbread>>=
static Block*
ipbread(Chan* ch, long n, ulong offset)
{
    Conv *c;
    Proto *x;
    Fs *f;

    switch(TYPE(ch->qid)){
    case Qdata:
        f = ipfs[ch->dev];
        x = f->p[PROTO(ch->qid)];
        c = x->conv[CONV(ch->qid)];
        return qbread(c->rq, n);
    default:
        return devbread(ch, n, offset);
    }
}
@

<<function setladdr>>=
/*
 *  set local address to be that of the ifc closest to remote address
 */
static void
setladdr(Conv* c)
{
    findlocalip(c->p->f, c->laddr, c->raddr);
}
@

<<function setluniqueport>>=
/*
 *  set a local port making sure the quad of raddr,rport,laddr,lport is unique
 */
char*
setluniqueport(Conv* c, int lport)
{
    Proto *p;
    Conv *xp;
    int x;

    p = c->p;

    qlock(p);
    for(x = 0; x < p->nc; x++){
        xp = p->conv[x];
        if(xp == nil)
            break;
        if(xp == c)
            continue;
        if((xp->state == Connected || xp->state == Announced)
        && xp->lport == lport
        && xp->rport == c->rport
        && ipcmp(xp->raddr, c->raddr) == 0
        && ipcmp(xp->laddr, c->laddr) == 0){
            qunlock(p);
            return "address in use";
        }
    }
    c->lport = lport;
    qunlock(p);
    return nil;
}
@

<<function lportinuse>>=
/*
 * is lport in use by anyone?
 */
static int
lportinuse(Proto *p, ushort lport)
{
    int x;

    for(x = 0; x < p->nc && p->conv[x]; x++)
        if(p->conv[x]->lport == lport)
            return 1;
    return 0;
}
@





<<function ipbwrite>>=
static long
ipbwrite(Chan* ch, Block* bp, ulong offset)
{
    Conv *c;
    Proto *x;
    Fs *f;
    int n;

    switch(TYPE(ch->qid)){
    case Qdata:
        f = ipfs[ch->dev];
        x = f->p[PROTO(ch->qid)];
        c = x->conv[CONV(ch->qid)];

        if(c->wq == nil)
            error(Eperm);

        if(bp->next)
            bp = concatblock(bp);
        n = BLEN(bp);
        qbwrite(c->wq, bp);
        return n;
    default:
        return devbwrite(ch, bp, offset);
    }
}
@






<<function Fsrcvpcolx>>=
Proto*
Fsrcvpcolx(Fs *f, uchar proto)
{
    return f->t2p[proto];
}
@


<<function ndbwrite>>=
long
ndbwrite(Fs *f, char *a, ulong off, int n)
{
    if(off > strlen(f->ndb))
        error(Eio);
    if(off+n >= sizeof(f->ndb))
        error(Eio);
    memmove(f->ndb+off, a, n);
    f->ndb[off+n] = 0;
    f->ndbvers++;
    f->ndbmtime = seconds();
    return n;
}
@



%-------------------------------------------------------------

<<kernel/network/ip/devip.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
#include    "../ip/ip.h"

<<enum qid (kernel/network/ip/devip.c)>>

<<enum misc (kernel/network/ip/devip.c)>>

<<macro TYPE>>
<<macro CONV>>
<<macro PROTO>>
<<macro QID>>

<<global network>>

<<global fslock>>
<<global ipfs>>
//Queue *qlog;

extern  void nullmediumlink(void);
extern  void pktmediumlink(void);
long ndbwrite(Fs *f, char *a, ulong off, int n);
Conv*   Fsprotoclone(Proto*, char*);
char*   Fsstdbind(Conv*, char**, int);
void    closeconv(Conv*);

<<function ip3gen>>

<<function ip2gen>>

<<function ip1gen>>

<<function ipgen>>

<<function ipreset>>

<<function ipgetfs>>

<<function newipaux>>

<<macro ATTACHER>>

<<function ipattach>>

<<function ipwalk>>


<<function ipstat>>

<<function incoming>>

<<global m2p>>

<<function ipopen>>

<<function ipcreate>>

<<function ipremove>>

<<function ipwstat>>

<<function closeconv>>

<<function ipclose>>

<<enum _anon_ (kernel/network/ip/devip.c)2>>

<<function ipread>>

<<function ipbread>>

<<function setladdr>>

<<function setluniqueport>>

<<function lportinuse>>

<<function setlport>>

<<function setladdrport>>

<<function setraddrport>>

<<function Fsstdconnect>>
<<function connected>>
<<function connectctlmsg>>

<<function Fsstdannounce>>

<<function announced>>
<<function announcectlmsg>>

<<function Fsstdbind>>

<<function bindctlmsg>>

<<function tosctlmsg>>

<<function ttlctlmsg>>

<<function ipwrite>>

<<function ipbwrite>>

<<global ipdevtab>>

<<function Fsproto>>

<<function Fsprotoclone>>

<<function Fsconnected>>

<<function Fsrcvpcol>>

<<function Fsrcvpcolx>>

<<function Fsnewcall>>

<<function ndbwrite>>

<<function scalednconv>>
@

%/*
% *  return true if this protocol is
% *  built in
% */
%//int
%//Fsbuiltinproto(Fs* f, uchar proto)
%//{
%//  return f->t2p[proto] != nil;
%//}



\subsection*{[[kernel/network/ip/arp.c]]}

<<enum _anon_ (kernel/network/ip/arp.c)>>=
/*
 *  address resolution tables
 */

enum
{
    NHASH       = (1<<6),
    NCACHE      = 256,

    AOK     = 1,
    AWAIT       = 2,
};
@

<<global arpstate>>=
char *arpstate[] =
{
    "UNUSED",
    "OK",
    "WAIT",
};
@


<<global Ebadarp>>=
char *Ebadarp = "bad arp";
@

<<macro haship>>=
#define haship(s) ((s)[IPaddrlen-1]%NHASH)
@

<<global ReTransTimer>>=
int     ReTransTimer = RETRANS_TIMER;
@


<<function newarp6>>=
/*
 *  create a new arp entry for an ip address.
 */
static Arpent*
newarp6(Arp *arp, uchar *ip, Ipifc *ifc, int addrxt)
{
    uint t;
    Block *next, *xp;
    Arpent *a, *e, *f, **l;
    Medium *m = ifc->m;
    int empty;

    /* find oldest entry */
    e = &arp->cache[NCACHE];
    a = arp->cache;
    t = a->utime;
    for(f = a; f < e; f++){
        if(f->utime < t){
            t = f->utime;
            a = f;
        }
    }

    /* dump waiting packets */
    xp = a->hold;
    a->hold = nil;

    if(isv4(a->ip)){
        while(xp){
            next = xp->list;
            freeblist(xp);
            xp = next;
        }
    }
    else { /* queue icmp unreachable for rxmitproc later on, w/o arp lock */
        if(xp){
            if(arp->dropl == nil)
                arp->dropf = xp;
            else
                arp->dropl->list = xp;

            for(next = xp->list; next; next = next->list)
                xp = next;
            arp->dropl = xp;
            wakeup(&arp->rxmtq);
        }
    }

    /* take out of current chain */
    l = &arp->hash[haship(a->ip)];
    for(f = *l; f; f = f->hash){
        if(f == a){
            *l = a->hash;
            break;
        }
        l = &f->hash;
    }

    /* insert into new chain */
    l = &arp->hash[haship(ip)];
    a->hash = *l;
    *l = a;

    memmove(a->ip, ip, sizeof(a->ip));
    a->utime = NOW;
    a->ctime = 0;
    a->type = m;

    a->rtime = NOW + ReTransTimer;
    a->rxtsrem = MAX_MULTICAST_SOLICIT;
    a->ifc = ifc;
    a->ifcid = ifc->ifcid;

    /* put to the end of re-transmit chain; addrxt is 0 when isv4(a->ip) */
    if(!ipismulticast(a->ip) && addrxt){
        l = &arp->rxmt;
        empty = (*l==nil);

        for(f = *l; f; f = f->nextrxt){
            if(f == a){
                *l = a->nextrxt;
                break;
            }
            l = &f->nextrxt;
        }
        for(f = *l; f; f = f->nextrxt){
            l = &f->nextrxt;
        }
        *l = a;
        if(empty)
            wakeup(&arp->rxmtq);
    }

    a->nextrxt = nil;

    return a;
}
@

<<function cleanarpent>>=
/* called with arp qlocked */

void
cleanarpent(Arp *arp, Arpent *a)
{
    Arpent *f, **l;

    a->utime = 0;
    a->ctime = 0;
    a->type = 0;
    a->state = 0;

    /* take out of current chain */
    l = &arp->hash[haship(a->ip)];
    for(f = *l; f; f = f->hash){
        if(f == a){
            *l = a->hash;
            break;
        }
        l = &f->hash;
    }

    /* take out of re-transmit chain */
    l = &arp->rxmt;
    for(f = *l; f; f = f->nextrxt){
        if(f == a){
            *l = a->nextrxt;
            break;
        }
        l = &f->nextrxt;
    }
    a->nextrxt = nil;
    a->hash = nil;
    a->hold = nil;
    a->last = nil;
    a->ifc = nil;
}
@

<<function arpget>>=
/*
 *  fill in the media address if we have it.  Otherwise return an
 *  Arpent that represents the state of the address resolution FSM
 *  for ip.  Add the packet to be sent onto the list of packets
 *  waiting for ip->mac to be resolved.
 */
Arpent*
arpget(Arp *arp, Block *bp, int version, Ipifc *ifc, uchar *ip, uchar *mac)
{
    int hash;
    Arpent *a;
    Medium *type = ifc->m;
    ipaddr v6ip;

    if(version == V4){
        v4tov6(v6ip, ip);
        ip = v6ip;
    }

    qlock(arp);
    hash = haship(ip);
    for(a = arp->hash[hash]; a; a = a->hash){
        if(memcmp(ip, a->ip, sizeof(a->ip)) == 0)
        if(type == a->type)
            break;
    }

    if(a == nil){
        a = newarp6(arp, ip, ifc, (version != V4));
        a->state = AWAIT;
    }
    a->utime = NOW;
    if(a->state == AWAIT){
        if(bp != nil){
            if(a->hold)
                a->last->list = bp;
            else
                a->hold = bp;
            a->last = bp;
            bp->list = nil;
        }
        return a;       /* return with arp qlocked */
    }

    memmove(mac, a->mac, a->type->maclen);

    /* remove old entries */
    if(NOW - a->ctime > 15*60*1000)
        cleanarpent(arp, a);

    qunlock(arp);
    return nil;
}
@

<<function arprelease>>=
/*
 * called with arp locked
 */
void
arprelease(Arp *arp, Arpent*)
{
    qunlock(arp);
}
@

<<function arpresolve>>=
/*
 * Copy out the mac address from the Arpent.  Return the
 * block waiting to get sent to this mac address.
 *
 * called with arp locked
 */
Block*
arpresolve(Arp *arp, Arpent *a, Medium *type, uchar *mac)
{
    Block *bp;
    Arpent *f, **l;

    if(!isv4(a->ip)){
        l = &arp->rxmt;
        for(f = *l; f; f = f->nextrxt){
            if(f == a){
                *l = a->nextrxt;
                break;
            }
            l = &f->nextrxt;
        }
    }

    memmove(a->mac, mac, type->maclen);
    a->type = type;
    a->state = AOK;
    a->utime = NOW;
    bp = a->hold;
    a->hold = nil;
    qunlock(arp);

    return bp;
}
@

<<function arpenter>>=
void
arpenter(Fs *fs, int version, uchar *ip, uchar *mac, int n, int refresh)
{
    Arp *arp;
    Route *r;
    Arpent *a, *f, **l;
    Ipifc *ifc;
    Medium *type;
    Block *bp, *next;
    ipaddr v6ip;

    arp = fs->arp;

    if(n != 6){
//      print("arp: len = %d\n", n);
        return;
    }

    switch(version){
    case V4:
        r = v4lookup(fs, ip, nil);
        v4tov6(v6ip, ip);
        ip = v6ip;
        break;
    case V6:
        r = v6lookup(fs, ip, nil);
        break;
    default:
        panic("arpenter: version %d", version);
        return; /* to supress warnings */
    }

    if(r == nil){
//      print("arp: no route for entry\n");
        return;
    }

    ifc = r->ifc;
    type = ifc->m;

    qlock(arp);
    for(a = arp->hash[haship(ip)]; a; a = a->hash){
        if(a->type != type || (a->state != AWAIT && a->state != AOK))
            continue;

        if(ipcmp(a->ip, ip) == 0){
            a->state = AOK;
            memmove(a->mac, mac, type->maclen);

            if(version == V6){
                /* take out of re-transmit chain */
                l = &arp->rxmt;
                for(f = *l; f; f = f->nextrxt){
                    if(f == a){
                        *l = a->nextrxt;
                        break;
                    }
                    l = &f->nextrxt;
                }
            }

            a->ifc = ifc;
            a->ifcid = ifc->ifcid;
            bp = a->hold;
            a->hold = nil;
            if(version == V4)
                ip += IPv4off;
            a->utime = NOW;
            a->ctime = a->utime;
            qunlock(arp);

            while(bp){
                next = bp->list;
                if(ifc != nil){
                    if(waserror()){
                        runlock(ifc);
                        nexterror();
                    }
                    rlock(ifc);
                    if(ifc->m != nil)
                        ifc->m->bwrite(ifc, bp, version, ip);
                    else
                        freeb(bp);
                    runlock(ifc);
                    poperror();
                } else
                    freeb(bp);
                bp = next;
            }
            return;
        }
    }

    if(refresh == 0){
        a = newarp6(arp, ip, ifc, 0);
        a->state = AOK;
        a->type = type;
        a->ctime = NOW;
        memmove(a->mac, mac, type->maclen);
    }

    qunlock(arp);
}
@


<<enum _anon_ (kernel/network/ip/arp.c)2>>=
enum
{
    Alinelen=   90,
};
@

<<global aformat>>=
char *aformat = "%-6.6s %-8.8s %-40.40I %-32.32s\n";
@

<<function convmac>>=
static void
convmac(char *p, char *ep, uchar *mac, int n)
{
    while(n-- > 0)
        p = seprint(p, ep, "%2.2ux", *mac++);
}
@


<<function rxmitsols>>=
extern int
rxmitsols(Arp *arp)
{
    uint sflag;
    Block *next, *xp;
    Arpent *a, *b, **l;
    Fs *f;
    ipaddr ipsrc;
    Ipifc *ifc = nil;
    long nrxt;

    qlock(arp);
    f = arp->f;

    a = arp->rxmt;
    if(a==nil){
        nrxt = 0;
        goto dodrops;       /* return nrxt; */
    }
    nrxt = a->rtime - NOW;
    if(nrxt > 3*ReTransTimer/4)
        goto dodrops;       /* return nrxt; */

    for(; a; a = a->nextrxt){
        ifc = a->ifc;
        assert(ifc != nil);
        if((a->rxtsrem <= 0) || !(canrlock(ifc)) || (a->ifcid != ifc->ifcid)){
            xp = a->hold;
            a->hold = nil;

            if(xp){
                if(arp->dropl == nil)
                    arp->dropf = xp;
                else
                    arp->dropl->list = xp;
            }

            cleanarpent(arp, a);
        }
        else
            break;
    }
    if(a == nil)
        goto dodrops;


    qunlock(arp);   /* for icmpns */
    if((sflag = ipv6anylocal(ifc, ipsrc)) != SRC_UNSPEC)
        icmpns(f, ipsrc, sflag, a->ip, TARG_MULTI, ifc->mac);

    runlock(ifc);
    qlock(arp);

    /* put to the end of re-transmit chain */
    l = &arp->rxmt;
    for(b = *l; b; b = b->nextrxt){
        if(b == a){
            *l = a->nextrxt;
            break;
        }
        l = &b->nextrxt;
    }
    for(b = *l; b; b = b->nextrxt){
        l = &b->nextrxt;
    }
    *l = a;
    a->rxtsrem--;
    a->nextrxt = nil;
    a->rtime = NOW + ReTransTimer;

    a = arp->rxmt;
    if(a==nil)
        nrxt = 0;
    else
        nrxt = a->rtime - NOW;

dodrops:
    xp = arp->dropf;
    arp->dropf = nil;
    arp->dropl = nil;
    qunlock(arp);

    for(; xp; xp = next){
        next = xp->list;
        icmphostunr(f, ifc, xp, Icmp6_adr_unreach, 1);
    }

    return nrxt;

}
@

<<function rxready>>=
static int
rxready(void *v)
{
    Arp *arp = (Arp *) v;
    int x;

    x = ((arp->rxmt != nil) || (arp->dropf != nil));

    return x;
}
@



%-------------------------------------------------------------

<<kernel/network/ip/arp.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "ip.h"
#include "ipv6.h"

<<enum _anon_ (kernel/network/ip/arp.c)>>

<<global arpstate>>

<<struct Arp>>

<<global Ebadarp>>

<<macro haship>>

<<global ReTransTimer>>

static void     rxmitproc(void *v);

<<function arpinit>>

<<function newarp6>>

<<function cleanarpent>>

<<function arpget>>

<<function arprelease>>

<<function arpresolve>>

<<function arpenter>>

<<function arpwrite>>

<<enum _anon_ (kernel/network/ip/arp.c)2>>

<<global aformat>>

<<function convmac>>

<<function arpread>>

<<function rxmitsols>>

<<function rxready>>

<<function rxmitproc>>

@


\subsection*{[[kernel/network/ip/icmp.c]]}

<<struct Icmp>>=
typedef struct Icmp {
    // ip header
    uchar   vihl;       /* Version and header length */
    uchar   tos;        /* Type of service */
    uchar   length[2];  /* packet length */
    uchar   id[2];      /* Identification */
    uchar   frag[2];    /* Fragment information */
    uchar   ttl;        /* Time to live */
    uchar   proto;      /* Protocol */
    uchar   ipcksum[2]; /* Header checksum */
    uchar   src[4];     /* Ip source */
    uchar   dst[4];     /* Ip destination */

    // icmp specifics
    uchar   type;
    uchar   code;
    uchar   cksum[2];
    uchar   icmpid[2];
    uchar   seq[2];
    uchar   data[1];
} Icmp;
@

<<enum _anon_ (kernel/network/ip/icmp.c)>>=
enum {          /* Packet Types */
    EchoReply   = 0,
    Unreachable = 3,
    SrcQuench   = 4,
    Redirect    = 5,
    EchoRequest = 8,
    TimeExceed  = 11,
    InParmProblem   = 12,
    Timestamp   = 13,
    TimestampReply  = 14,
    InfoRequest = 15,
    InfoReply   = 16,
    AddrMaskRequest = 17,
    AddrMaskReply   = 18,

    Maxtype     = 18,
};
@

<<enum _anon_ (kernel/network/ip/icmp.c)2>>=
enum
{
    MinAdvise   = 24,   /* minimum needed for us to advise another protocol */
};
@

<<global icmpnames>>=
char *icmpnames[Maxtype+1] =
{
[EchoReply]     "EchoReply",
[Unreachable]       "Unreachable",
[SrcQuench]     "SrcQuench",
[Redirect]      "Redirect",
[EchoRequest]       "EchoRequest",
[TimeExceed]        "TimeExceed",
[InParmProblem]     "InParmProblem",
[Timestamp]     "Timestamp",
[TimestampReply]    "TimestampReply",
[InfoRequest]       "InfoRequest",
[InfoReply]     "InfoReply",
[AddrMaskRequest]   "AddrMaskRequest",
[AddrMaskReply  ]   "AddrMaskReply  ",
};
@

<<enum _anon_ (kernel/network/ip/icmp.c)3>>=
enum {
    IP_ICMPPROTO    = 1,
    ICMP_IPSIZE = 20,
    ICMP_HDRSIZE    = 8,
};
@

<<enum _anon_ (kernel/network/ip/icmp.c)4>>=
enum
{
    InMsgs,
    InErrors,
    OutMsgs,
    CsumErrs,
    LenErrs,
    HlenErrs,

    Nstats,
};
@

<<global statnames (kernel/network/ip/icmp.c)>>=
static char *statnames[Nstats] =
{
[InMsgs]    "InMsgs",
[InErrors]  "InErrors",
[OutMsgs]   "OutMsgs",
[CsumErrs]  "CsumErrs",
[LenErrs]   "LenErrs",
[HlenErrs]  "HlenErrs",
};
@

<<struct Icmppriv>>=
struct Icmppriv
{
    ulong   stats[Nstats];

    /* message counts */
    ulong   in[Maxtype+1];
    ulong   out[Maxtype+1];
};
@

<<function icmpcreate>>=
static void
icmpcreate(Conv *c)
{
    c->rq = qopen(64*1024, Qmsg, 0, c);
    c->wq = qbypass(icmpkick, c);
}
@

<<function icmpconnect>>=
extern char*
icmpconnect(Conv *c, char **argv, int argc)
{
    char *e;

    e = Fsstdconnect(c, argv, argc);
    if(e != nil)
        return e;
    Fsconnected(c, e);

    return nil;
}
@

<<function icmpstate>>=
extern int
icmpstate(Conv *c, char *state, int n)
{
    USED(c);
    return snprint(state, n, "%s qin %d qout %d\n",
        "Datagram",
        c->rq ? qlen(c->rq) : 0,
        c->wq ? qlen(c->wq) : 0
    );
}
@

<<function icmpannounce>>=
extern char*
icmpannounce(Conv *c, char **argv, int argc)
{
    char *e;

    e = Fsstdannounce(c, argv, argc);
    if(e != nil)
        return e;
    Fsconnected(c, nil);

    return nil;
}
@

<<function icmpclose>>=
extern void
icmpclose(Conv *c)
{
    qclose(c->rq);
    qclose(c->wq);
    ipmove(c->laddr, IPnoaddr);
    ipmove(c->raddr, IPnoaddr);
    c->lport = 0;
}
@

<<function icmpkick>>=
static void
icmpkick(void *x, Block *bp)
{
    Conv *c = x;
    Icmp *p;
    Icmppriv *ipriv;

    if(bp == nil)
        return;

    if(blocklen(bp) < ICMP_IPSIZE + ICMP_HDRSIZE){
        freeblist(bp);
        return;
    }
    p = (Icmp *)(bp->rp);
    p->vihl = IP_VER4;
    ipriv = c->p->priv;
    if(p->type <= Maxtype)
        ipriv->out[p->type]++;

    v6tov4(p->dst, c->raddr);
    v6tov4(p->src, c->laddr);
    p->proto = IP_ICMPPROTO;
    hnputs(p->icmpid, c->lport);
    memset(p->cksum, 0, sizeof(p->cksum));
    hnputs(p->cksum, ptclcsum(bp, ICMP_IPSIZE, blocklen(bp) - ICMP_IPSIZE));
    ipriv->stats[OutMsgs]++;
    ipoput4(c->p->f, bp, 0, c->ttl, c->tos, nil);
}
@

<<function icmpttlexceeded>>=
extern void
icmpttlexceeded(Fs *f, uchar *ia, Block *bp)
{
    Block   *nbp;
    Icmp    *p, *np;

    p = (Icmp *)bp->rp;

    netlog(f, Logicmp, "sending icmpttlexceeded -> %V\n", p->src);
    nbp = allocb(ICMP_IPSIZE + ICMP_HDRSIZE + ICMP_IPSIZE + 8);
    nbp->wp += ICMP_IPSIZE + ICMP_HDRSIZE + ICMP_IPSIZE + 8;
    np = (Icmp *)nbp->rp;
    np->vihl = IP_VER4;
    memmove(np->dst, p->src, sizeof(np->dst));
    v6tov4(np->src, ia);
    memmove(np->data, bp->rp, ICMP_IPSIZE + 8);
    np->type = TimeExceed;
    np->code = 0;
    np->proto = IP_ICMPPROTO;
    hnputs(np->icmpid, 0);
    hnputs(np->seq, 0);
    memset(np->cksum, 0, sizeof(np->cksum));
    hnputs(np->cksum, ptclcsum(nbp, ICMP_IPSIZE, blocklen(nbp) - ICMP_IPSIZE));
    ipoput4(f, nbp, 0, MAXTTL, DFLTTOS, nil);

}
@

<<function icmpunreachable>>=
static void
icmpunreachable(Fs *f, Block *bp, int code, int seq)
{
    Block   *nbp;
    Icmp    *p, *np;
    int i;
    ipaddr   addr;

    p = (Icmp *)bp->rp;

    /* only do this for unicast sources and destinations */
    v4tov6(addr, p->dst);
    i = ipforme(f, addr);
    if((i&Runi) == 0)
        return;
    v4tov6(addr, p->src);
    i = ipforme(f, addr);
    if(i != 0 && (i&Runi) == 0)
        return;

    netlog(f, Logicmp, "sending icmpnoconv -> %V\n", p->src);
    nbp = allocb(ICMP_IPSIZE + ICMP_HDRSIZE + ICMP_IPSIZE + 8);
    nbp->wp += ICMP_IPSIZE + ICMP_HDRSIZE + ICMP_IPSIZE + 8;
    np = (Icmp *)nbp->rp;
    np->vihl = IP_VER4;
    memmove(np->dst, p->src, sizeof(np->dst));
    memmove(np->src, p->dst, sizeof(np->src));
    memmove(np->data, bp->rp, ICMP_IPSIZE + 8);
    np->type = Unreachable;
    np->code = code;
    np->proto = IP_ICMPPROTO;
    hnputs(np->icmpid, 0);
    hnputs(np->seq, seq);
    memset(np->cksum, 0, sizeof(np->cksum));
    hnputs(np->cksum, ptclcsum(nbp, ICMP_IPSIZE, blocklen(nbp) - ICMP_IPSIZE));
    ipoput4(f, nbp, 0, MAXTTL, DFLTTOS, nil);
}
@

<<function icmpnoconv>>=
extern void
icmpnoconv(Fs *f, Block *bp)
{
    icmpunreachable(f, bp, 3, 0);
}
@

<<function icmpcantfrag>>=
extern void
icmpcantfrag(Fs *f, Block *bp, int mtu)
{
    icmpunreachable(f, bp, 4, mtu);
}
@

<<function goticmpkt>>=
static void
goticmpkt(Proto *icmp, Block *bp)
{
    Conv    **c, *s;
    Icmp    *p;
    ipaddr  dst;
    ushort  recid;

    p = (Icmp *) bp->rp;
    v4tov6(dst, p->src);
    recid = nhgets(p->icmpid);

    for(c = icmp->conv; *c; c++) {
        s = *c;
        if(s->lport == recid)
        if(ipcmp(s->raddr, dst) == 0){
            bp = concatblock(bp);
            if(bp != nil)
                qpass(s->rq, bp);
            return;
        }
    }
    freeblist(bp);
}
@

<<function mkechoreply>>=
static Block *
mkechoreply(Block *bp)
{
    Icmp    *q;
    uchar   ip[4];

    q = (Icmp *)bp->rp;
    q->vihl = IP_VER4;
    memmove(ip, q->src, sizeof(q->dst));
    memmove(q->src, q->dst, sizeof(q->src));
    memmove(q->dst, ip,  sizeof(q->dst));
    q->type = EchoReply;
    memset(q->cksum, 0, sizeof(q->cksum));
    hnputs(q->cksum, ptclcsum(bp, ICMP_IPSIZE, blocklen(bp) - ICMP_IPSIZE));

    return bp;
}
@

<<global unreachcode>>=
static char *unreachcode[] =
{
[0] "net unreachable",
[1] "host unreachable",
[2] "protocol unreachable",
[3] "port unreachable",
[4] "fragmentation needed and DF set",
[5] "source route failed",
};
@

<<function icmpiput>>=
static void
icmpiput(Proto *icmp, Ipifc*, Block *bp)
{
    int n, iplen;
    Icmp    *p;
    Block   *r;
    Proto   *pr;
    char    *msg;
    char    m2[128];
    Icmppriv *ipriv;

    ipriv = icmp->priv;

    ipriv->stats[InMsgs]++;

    p = (Icmp *)bp->rp;
    netlog(icmp->f, Logicmp, "icmpiput %s (%d) %d\n",
        (p->type < nelem(icmpnames)? icmpnames[p->type]: ""),
        p->type, p->code);
    n = blocklen(bp);
    if(n < ICMP_IPSIZE+ICMP_HDRSIZE){
        ipriv->stats[InErrors]++;
        ipriv->stats[HlenErrs]++;
        netlog(icmp->f, Logicmp, "icmp hlen %d\n", n);
        goto raise;
    }
    iplen = nhgets(p->length);
    if(iplen > n){
        ipriv->stats[LenErrs]++;
        ipriv->stats[InErrors]++;
        netlog(icmp->f, Logicmp, "icmp length %d\n", iplen);
        goto raise;
    }
    if(ptclcsum(bp, ICMP_IPSIZE, iplen - ICMP_IPSIZE)){
        ipriv->stats[InErrors]++;
        ipriv->stats[CsumErrs]++;
        netlog(icmp->f, Logicmp, "icmp checksum error\n");
        goto raise;
    }
    if(p->type <= Maxtype)
        ipriv->in[p->type]++;

    switch(p->type) {
    case EchoRequest:
        if (iplen < n)
            bp = trimblock(bp, 0, iplen);
        r = mkechoreply(bp);
        ipriv->out[EchoReply]++;
        ipoput4(icmp->f, r, 0, MAXTTL, DFLTTOS, nil);
        break;
    case Unreachable:
        if(p->code > 5)
            msg = unreachcode[1];
        else
            msg = unreachcode[p->code];

        bp->rp += ICMP_IPSIZE+ICMP_HDRSIZE;
        if(blocklen(bp) < MinAdvise){
            ipriv->stats[LenErrs]++;
            goto raise;
        }
        p = (Icmp *)bp->rp;
        pr = Fsrcvpcolx(icmp->f, p->proto);
        if(pr != nil && pr->advise != nil) {
            // Protocol dispatch
            (*pr->advise)(pr, bp, msg);
            return;
        }

        bp->rp -= ICMP_IPSIZE+ICMP_HDRSIZE;
        goticmpkt(icmp, bp);
        break;
    case TimeExceed:
        if(p->code == 0){
            snprint(m2, sizeof m2, "ttl exceeded at %V", p->src);

            bp->rp += ICMP_IPSIZE+ICMP_HDRSIZE;
            if(blocklen(bp) < MinAdvise){
                ipriv->stats[LenErrs]++;
                goto raise;
            }
            p = (Icmp *)bp->rp;
            pr = Fsrcvpcolx(icmp->f, p->proto);
            if(pr != nil && pr->advise != nil) {
                // Protocol dispatch
                (*pr->advise)(pr, bp, m2);
                return;
            }
            bp->rp -= ICMP_IPSIZE+ICMP_HDRSIZE;
        }

        goticmpkt(icmp, bp);
        break;
    default:
        goticmpkt(icmp, bp);
        break;
    }
    return;

raise:
    freeblist(bp);
}
@

<<function icmpadvise>>=
void
icmpadvise(Proto *icmp, Block *bp, char *msg)
{
    Conv    **c, *s;
    Icmp    *p;
    ipaddr   dst;
    ushort  recid;

    p = (Icmp *) bp->rp;
    v4tov6(dst, p->dst);
    recid = nhgets(p->icmpid);

    for(c = icmp->conv; *c; c++) {
        s = *c;
        if(s->lport == recid)
        if(ipcmp(s->raddr, dst) == 0){
            qhangup(s->rq, msg);
            qhangup(s->wq, msg);
            break;
        }
    }
    freeblist(bp);
}
@

<<function icmpstats>>=
int
icmpstats(Proto *icmp, char *buf, int len)
{
    Icmppriv *priv;
    char *p, *e;
    int i;

    priv = icmp->priv;
    p = buf;
    e = p+len;
    for(i = 0; i < Nstats; i++)
        p = seprint(p, e, "%s: %lud\n", statnames[i], priv->stats[i]);
    for(i = 0; i <= Maxtype; i++){
        if(icmpnames[i])
            p = seprint(p, e, "%s: %lud %lud\n", icmpnames[i], priv->in[i], priv->out[i]);
        else
            p = seprint(p, e, "%d: %lud %lud\n", i, priv->in[i], priv->out[i]);
    }
    return p - buf;
}
@

<<function icmpinit>>=
void
icmpinit(Fs *fs)
{
    Proto *icmp;

    icmp = smalloc(sizeof(Proto));
    icmp->priv = smalloc(sizeof(Icmppriv));
    icmp->name = "icmp";
    icmp->connect = icmpconnect;
    icmp->announce = icmpannounce;
    icmp->state = icmpstate;
    icmp->create = icmpcreate;
    icmp->close = icmpclose;
    icmp->rcv = icmpiput;
    icmp->stats = icmpstats;
    icmp->ctl = nil;
    icmp->advise = icmpadvise;
    icmp->gc = nil;
    icmp->ipproto = IP_ICMPPROTO;
    icmp->nc = 128;
    icmp->ptclsize = 0;

    Fsproto(fs, icmp);
}
@


%-------------------------------------------------------------

<<kernel/network/ip/icmp.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "ip.h"

typedef struct Icmppriv Icmppriv;

<<struct Icmp>>

<<enum _anon_ (kernel/network/ip/icmp.c)>>

<<enum _anon_ (kernel/network/ip/icmp.c)2>>

<<global icmpnames>>

<<enum _anon_ (kernel/network/ip/icmp.c)3>>

<<enum _anon_ (kernel/network/ip/icmp.c)4>>

<<global statnames (kernel/network/ip/icmp.c)>>

<<struct Icmppriv>>

static void icmpkick(void *x, Block*);

<<function icmpcreate>>

<<function icmpconnect>>

<<function icmpstate>>

<<function icmpannounce>>

<<function icmpclose>>

<<function icmpkick>>

<<function icmpttlexceeded>>

<<function icmpunreachable>>

<<function icmpnoconv>>

<<function icmpcantfrag>>

<<function goticmpkt>>

<<function mkechoreply>>

<<global unreachcode>>

<<function icmpiput>>

<<function icmpadvise>>

<<function icmpstats>>

<<function icmpinit>>
@


\subsection*{[[kernel/network/ip/chandial.c]]}

<<enum _anon_ (kernel/network/ip/chandial.c)>>=
enum
{
    Maxstring=  128,
};
@

<<struct DS (kernel/network/ip/chandial.c)>>=
struct DS
{
    char    buf[Maxstring];         /* dist string */
    char    *netdir;
    char    *proto;
    char    *rem;
    char    *local;             /* other args */
    char    *dir;
    Chan    **ctlp;
};
@

<<function chandial>>=
/*
 *  the dialstring is of the form '[/net/]proto!dest'
 */
Chan*
chandial(char *dest, char *local, char *dir, Chan **ctlp)
{
    DS ds;
    char clone[Maxpath];

    ds.local = local;
    ds.dir = dir;
    ds.ctlp = ctlp;

    _dial_string_parse(dest, &ds);
    if(ds.netdir == 0)
        ds.netdir = "/net";

    /* no connection server, don't translate */
    snprint(clone, sizeof(clone), "%s/%s/clone", ds.netdir, ds.proto);
    return call(clone, ds.rem, &ds);
}
@

<<function call (kernel/network/ip/chandial.c)>>=
static Chan*
call(char *clone, char *dest, DS *ds)
{
    int n;
    Chan *dchan, *cchan;
    char name[Maxpath], data[Maxpath], *p;

    cchan = namec(clone, Aopen, ORDWR, 0);

    /* get directory name */
    if(waserror()){
        cclose(cchan);
        nexterror();
    }
    n = devtab[cchan->type]->read(cchan, name, sizeof(name)-1, 0);
    name[n] = 0;
    for(p = name; *p == ' '; p++)
        ;
    snprint(name, sizeof name, "%lud", strtoul(p, 0, 0));
    p = strrchr(clone, '/');
    *p = 0;
    if(ds->dir)
        snprint(ds->dir, Maxpath, "%s/%s", clone, name);
    snprint(data, sizeof(data), "%s/%s/data", clone, name);

    /* connect */
    if(ds->local)
        snprint(name, sizeof(name), "connect %s %s", dest, ds->local);
    else
        snprint(name, sizeof(name), "connect %s", dest);
    devtab[cchan->type]->write(cchan, name, strlen(name), 0);

    /* open data connection */
    dchan = namec(data, Aopen, ORDWR, 0);
    if(ds->ctlp)
        *ds->ctlp = cchan;
    else
        cclose(cchan);
    poperror();
    return dchan;

}
@

<<function _dial_string_parse (kernel/network/ip/chandial.c)>>=
/*
 *  parse a dial string
 */
static void
_dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-1] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "net";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/' && *ds->buf != '#'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            for(p2 = p; *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
}
@


%-------------------------------------------------------------

<<kernel/network/ip/chandial.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
#include    "../ip/ip.h"

typedef struct DS DS;
static Chan*    call(char*, char*, DS*);
static void _dial_string_parse(char*, DS*);

<<enum _anon_ (kernel/network/ip/chandial.c)>>

<<struct DS (kernel/network/ip/chandial.c)>>

<<function chandial>>

<<function call (kernel/network/ip/chandial.c)>>

<<function _dial_string_parse (kernel/network/ip/chandial.c)>>
@


\subsection*{[[kernel/network/ip/nullmedium.c]]}



%-------------------------------------------------------------

<<kernel/network/ip/nullmedium.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "ip.h"

<<function nullbind>>

<<function nullunbind>>

<<function nullbwrite>>

<<global nullmedium>>

<<function nullmediumlink>>
@


\subsection*{[[kernel/network/ip/loopbackmedium.c]]}




%-------------------------------------------------------------

<<kernel/network/ip/loopbackmedium.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "ip.h"

typedef struct LB LB;

<<enum _anon_ (kernel/network/ip/loopbackmedium.c)>>

<<struct LB>>

static void loopbackread(void *a);

<<function loopbackbind>>

<<function loopbackunbind>>

<<function loopbackbwrite>>

<<function loopbackread>>

<<global loopbackmedium>>

<<function loopbackmediumlink>>
@


\subsection*{[[kernel/network/ip/ethermedium.c]]}


<<global ipbroadcast>>=
static ipaddr ipbroadcast = {
    0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,
    0xff,0xff,0xff,0xff,
};
@



<<global gbemedium>>=
Medium gbemedium =
{
.name=      "gbe",
.hsize=     14,
.mintu=     60,
.maxtu=     9014,
.maclen=    6,
.bind=      etherbind,
.unbind=    etherunbind,
.bwrite=    etherbwrite,
.addmulti=  etheraddmulti,
.remmulti=  etherremmulti,
.ares=      arpenter,
.areg=      sendgarp,
.pref2addr= etherpref2addr,
};
@

<<struct Etherrock>>=
struct Etherrock
{
    Fs  *f;     /* file system we belong to */
    Proc    *arpp;      /* arp process */
    Proc    *read4p;    /* reading process (v4)*/
    Proc    *read6p;    /* reading process (v6)*/
    Chan    *mchan4;    /* Data channel for v4 */
    Chan    *achan;     /* Arp channel */
    Chan    *cchan4;    /* Control channel for v4 */
    Chan    *mchan6;    /* Data channel for v6 */
    Chan    *cchan6;    /* Control channel for v6 */
};
@

<<enum _anon_ (kernel/network/ip/ethermedium.c)>>=
/*
 *  ethernet arp request
 */
enum
{
    ARPREQUEST  = 1,
    ARPREPLY    = 2,
};
@

<<struct Etherarp>>=
struct Etherarp
{
    uchar   d[6];
    uchar   s[6];
    uchar   type[2];
    uchar   hrd[2];
    uchar   pro[2];
    uchar   hln;
    uchar   pln;
    uchar   op[2];
    uchar   sha[6];
    uchar   spa[4];
    uchar   tha[6];
    uchar   tpa[4];
};
@

<<global nbmsg>>=
static char *nbmsg = "nonblocking";
@


<<function etherunbind>>=
/*
 *  called with ifc wlock'd
 */
static void
etherunbind(Ipifc *ifc)
{
    Etherrock *er = ifc->arg;

    if(er->read4p)
        postnote(er->read4p, 1, "unbind", 0);
    if(er->read6p)
        postnote(er->read6p, 1, "unbind", 0);
    if(er->arpp)
        postnote(er->arpp, 1, "unbind", 0);

    /* wait for readers to die */
    while(er->arpp != 0 || er->read4p != 0 || er->read6p != 0)
        tsleep(&up->sleepr, returnfalse, 0, 300);

    if(er->mchan4 != nil)
        cclose(er->mchan4);
    if(er->achan != nil)
        cclose(er->achan);
    if(er->cchan4 != nil)
        cclose(er->cchan4);
    if(er->mchan6 != nil)
        cclose(er->mchan6);
    if(er->cchan6 != nil)
        cclose(er->cchan6);

    free(er);
}
@

<<function etherbwrite (kernel/network/ip/ethermedium.c)>>=
/*
 *  called by ipoput with a single block to write with ifc rlock'd
 */
static void
etherbwrite(Ipifc *ifc, Block *bp, int version, uchar *ip)
{
    Etherhdr *eh;
    Arpent *a;
    uchar mac[6];
    Etherrock *er = ifc->arg;

    /* get mac address of destination */
    a = arpget(er->f->arp, bp, version, ifc, ip, mac);
    if(a){
        /* check for broadcast or multicast */
        bp = multicastarp(er->f, a, ifc->m, mac);
        if(bp==nil){
            switch(version){
            case V4:
                sendarp(ifc, a);
                break;
            case V6:
                resolveaddr6(ifc, a);
                break;
            default:
                panic("etherbwrite: version %d", version);
            }
            return;
        }
    }

    /* make it a single block with space for the ether header */
    bp = padblock(bp, ifc->m->hsize);
    if(bp->next)
        bp = concatblock(bp);
    if(BLEN(bp) < ifc->mintu)
        bp = adjustblock(bp, ifc->mintu);
    eh = (Etherhdr*)bp->rp;

    /* copy in mac addresses and ether type */
    memmove(eh->s, ifc->mac, sizeof(eh->s));
    memmove(eh->d, mac, sizeof(eh->d));

    switch(version){
    case V4:
        eh->t[0] = 0x08;
        eh->t[1] = 0x00;
        devtab[er->mchan4->type]->bwrite(er->mchan4, bp, 0);
        break;
    case V6:
        eh->t[0] = 0x86;
        eh->t[1] = 0xDD;
        devtab[er->mchan6->type]->bwrite(er->mchan6, bp, 0);
        break;
    default:
        panic("etherbwrite2: version %d", version);
    }
    ifc->out++;
}
@

<<function etherread4>>=
/*
 *  process to read from the ethernet
 */
static void
etherread4(void *a)
{
    Ipifc *ifc;
    Block *bp;
    Etherrock *er;

    ifc = a;
    er = ifc->arg;
    er->read4p = up;    /* hide identity under a rock for unbind */
    if(waserror()){
        er->read4p = 0;
        pexit("hangup", 1);
    }
    for(;;){
        bp = devtab[er->mchan4->type]->bread(er->mchan4, ifc->maxtu, 0);
        if(!canrlock(ifc)){
            freeb(bp);
            continue;
        }
        if(waserror()){
            runlock(ifc);
            nexterror();
        }
        ifc->in++;
        bp->rp += ifc->m->hsize;
        if(ifc->lifc == nil)
            freeb(bp);
        else
            ipiput4(er->f, ifc, bp);
        runlock(ifc);
        poperror();
    }
}
@


<<function etheraddmulti>>=
static void
etheraddmulti(Ipifc *ifc, uchar *a, uchar *)
{
    uchar mac[6];
    char buf[64];
    Etherrock *er = ifc->arg;
    int version;

    version = multicastea(mac, a);
    snprint(buf, sizeof buf, "addmulti %E", mac);
    switch(version){
    case V4:
        devtab[er->cchan4->type]->write(er->cchan4, buf, strlen(buf), 0);
        break;
    case V6:
        devtab[er->cchan6->type]->write(er->cchan6, buf, strlen(buf), 0);
        break;
    default:
        panic("etheraddmulti: version %d", version);
    }
}
@

<<function etherremmulti>>=
static void
etherremmulti(Ipifc *ifc, uchar *a, uchar *)
{
    uchar mac[6];
    char buf[64];
    Etherrock *er = ifc->arg;
    int version;

    version = multicastea(mac, a);
    snprint(buf, sizeof buf, "remmulti %E", mac);
    switch(version){
    case V4:
        devtab[er->cchan4->type]->write(er->cchan4, buf, strlen(buf), 0);
        break;
    case V6:
        devtab[er->cchan6->type]->write(er->cchan6, buf, strlen(buf), 0);
        break;
    default:
        panic("etherremmulti: version %d", version);
    }
}
@

<<function sendarp>>=
/*
 *  send an ethernet arp
 *  (only v4, v6 uses the neighbor discovery, rfc1970)
 */
static void
sendarp(Ipifc *ifc, Arpent *a)
{
    int n;
    Block *bp;
    Etherarp *e;
    Etherrock *er = ifc->arg;

    /* don't do anything if it's been less than a second since the last */
    if(NOW - a->ctime < 1000){
        arprelease(er->f->arp, a);
        return;
    }

    /* remove all but the last message */
    while((bp = a->hold) != nil){
        if(bp == a->last)
            break;
        a->hold = bp->list;
        freeblist(bp);
    }

    /* try to keep it around for a second more */
    a->ctime = NOW;
    arprelease(er->f->arp, a);

    n = sizeof(Etherarp);
    if(n < a->type->mintu)
        n = a->type->mintu;
    bp = allocb(n);
    memset(bp->rp, 0, n);
    e = (Etherarp*)bp->rp;
    memmove(e->tpa, a->ip+IPv4off, sizeof(e->tpa));
    ipv4local(ifc, e->spa);
    memmove(e->sha, ifc->mac, sizeof(e->sha));
    memset(e->d, 0xff, sizeof(e->d));       /* ethernet broadcast */
    memmove(e->s, ifc->mac, sizeof(e->s));

    hnputs(e->type, ETARP);
    hnputs(e->hrd, 1);
    hnputs(e->pro, ETIP4);
    e->hln = sizeof(e->sha);
    e->pln = sizeof(e->spa);
    hnputs(e->op, ARPREQUEST);
    bp->wp += n;

    devtab[er->achan->type]->bwrite(er->achan, bp, 0);
}
@

<<function resolveaddr6>>=
static void
resolveaddr6(Ipifc *ifc, Arpent *a)
{
    int sflag;
    Block *bp;
    Etherrock *er = ifc->arg;
    ipaddr ipsrc;

    /* don't do anything if it's been less than a second since the last */
    if(NOW - a->ctime < ReTransTimer){
        arprelease(er->f->arp, a);
        return;
    }

    /* remove all but the last message */
    while((bp = a->hold) != nil){
        if(bp == a->last)
            break;
        a->hold = bp->list;
        freeblist(bp);
    }

    /* try to keep it around for a second more */
    a->ctime = NOW;
    a->rtime = NOW + ReTransTimer;
    if(a->rxtsrem <= 0) {
        arprelease(er->f->arp, a);
        return;
    }

    a->rxtsrem--;
    arprelease(er->f->arp, a);

    if(sflag = ipv6anylocal(ifc, ipsrc))
        icmpns(er->f, ipsrc, sflag, a->ip, TARG_MULTI, ifc->mac);
}
@

<<function sendgarp>>=
/*
 *  send a gratuitous arp to refresh arp caches
 */
static void
sendgarp(Ipifc *ifc, uchar *ip)
{
    int n;
    Block *bp;
    Etherarp *e;
    Etherrock *er = ifc->arg;

    /* don't arp for our initial non address */
    if(ipcmp(ip, IPnoaddr) == 0)
        return;

    n = sizeof(Etherarp);
    if(n < ifc->m->mintu)
        n = ifc->m->mintu;
    bp = allocb(n);
    memset(bp->rp, 0, n);
    e = (Etherarp*)bp->rp;
    memmove(e->tpa, ip+IPv4off, sizeof(e->tpa));
    memmove(e->spa, ip+IPv4off, sizeof(e->spa));
    memmove(e->sha, ifc->mac, sizeof(e->sha));
    memset(e->d, 0xff, sizeof(e->d));       /* ethernet broadcast */
    memmove(e->s, ifc->mac, sizeof(e->s));

    hnputs(e->type, ETARP);
    hnputs(e->hrd, 1);
    hnputs(e->pro, ETIP4);
    e->hln = sizeof(e->sha);
    e->pln = sizeof(e->spa);
    hnputs(e->op, ARPREQUEST);
    bp->wp += n;

    devtab[er->achan->type]->bwrite(er->achan, bp, 0);
}
@

<<function recvarp>>=
static void
recvarp(Ipifc *ifc)
{
    int n;
    Block *ebp, *rbp;
    Etherarp *e, *r;
    ipaddr ip;
    static uchar eprinted[4];
    Etherrock *er = ifc->arg;

    ebp = devtab[er->achan->type]->bread(er->achan, ifc->maxtu, 0);
    if(ebp == nil)
        return;

    e = (Etherarp*)ebp->rp;
    switch(nhgets(e->op)) {
    default:
        break;

    case ARPREPLY:
        /* check for machine using my ip address */
        v4tov6(ip, e->spa);
        if(iplocalonifc(ifc, ip) || ipproxyifc(er->f, ifc, ip)){
            if(memcmp(e->sha, ifc->mac, sizeof(e->sha)) != 0){
                print("arprep: 0x%E/0x%E also has ip addr %V\n",
                    e->s, e->sha, e->spa);
                break;
            }
        }

        /* make sure we're not entering broadcast addresses */
        if(ipcmp(ip, ipbroadcast) == 0 ||
            !memcmp(e->sha, etherbroadcast, sizeof(e->sha))){
            print("arprep: 0x%E/0x%E cannot register broadcast address %I\n",
                e->s, e->sha, e->spa);
            break;
        }

        arpenter(er->f, V4, e->spa, e->sha, sizeof(e->sha), 0);
        break;

    case ARPREQUEST:
        /* don't answer arps till we know who we are */
        if(ifc->lifc == 0)
            break;

        /* check for machine using my ip or ether address */
        v4tov6(ip, e->spa);
        if(iplocalonifc(ifc, ip) || ipproxyifc(er->f, ifc, ip)){
            if(memcmp(e->sha, ifc->mac, sizeof(e->sha)) != 0){
                if (memcmp(eprinted, e->spa, sizeof(e->spa))){
                    /* print only once */
                    print("arpreq: 0x%E also has ip addr %V\n", e->sha, e->spa);
                    memmove(eprinted, e->spa, sizeof(e->spa));
                }
            }
        } else {
            if(memcmp(e->sha, ifc->mac, sizeof(e->sha)) == 0){
                print("arpreq: %V also has ether addr %E\n", e->spa, e->sha);
                break;
            }
        }

        /* refresh what we know about sender */
        arpenter(er->f, V4, e->spa, e->sha, sizeof(e->sha), 1);

        /* answer only requests for our address or systems we're proxying for */
        v4tov6(ip, e->tpa);
        if(!iplocalonifc(ifc, ip))
        if(!ipproxyifc(er->f, ifc, ip))
            break;

        n = sizeof(Etherarp);
        if(n < ifc->mintu)
            n = ifc->mintu;
        rbp = allocb(n);
        r = (Etherarp*)rbp->rp;
        memset(r, 0, sizeof(Etherarp));
        hnputs(r->type, ETARP);
        hnputs(r->hrd, 1);
        hnputs(r->pro, ETIP4);
        r->hln = sizeof(r->sha);
        r->pln = sizeof(r->spa);
        hnputs(r->op, ARPREPLY);
        memmove(r->tha, e->sha, sizeof(r->tha));
        memmove(r->tpa, e->spa, sizeof(r->tpa));
        memmove(r->sha, ifc->mac, sizeof(r->sha));
        memmove(r->spa, e->tpa, sizeof(r->spa));
        memmove(r->d, e->sha, sizeof(r->d));
        memmove(r->s, ifc->mac, sizeof(r->s));
        rbp->wp += n;

        devtab[er->achan->type]->bwrite(er->achan, rbp, 0);
    }
    freeb(ebp);
}
@

<<function recvarpproc>>=
static void
recvarpproc(void *v)
{
    Ipifc *ifc = v;
    Etherrock *er = ifc->arg;

    er->arpp = up;
    if(waserror()){
        er->arpp = 0;
        pexit("hangup", 1);
    }
    for(;;)
        recvarp(ifc);
}
@

<<function multicastea>>=
static int
multicastea(uchar *ea, uchar *ip)
{
    int x;

    switch(x = ipismulticast(ip)){
    case V4:
        ea[0] = 0x01;
        ea[1] = 0x00;
        ea[2] = 0x5e;
        ea[3] = ip[13] & 0x7f;
        ea[4] = ip[14];
        ea[5] = ip[15];
        break;
    case V6:
        ea[0] = 0x33;
        ea[1] = 0x33;
        ea[2] = ip[12];
        ea[3] = ip[13];
        ea[4] = ip[14];
        ea[5] = ip[15];
        break;
    }
    return x;
}
@

<<function multicastarp>>=
/*
 *  fill in an arp entry for broadcast or multicast
 *  addresses.  Return the first queued packet for the
 *  IP address.
 */
static Block*
multicastarp(Fs *f, Arpent *a, Medium *medium, uchar *mac)
{
    /* is it broadcast? */
    switch(ipforme(f, a->ip)){
    case Runi:
        return nil;
    case Rbcast:
        memset(mac, 0xff, 6);
        return arpresolve(f->arp, a, medium, mac);
    default:
        break;
    }

    /* if multicast, fill in mac */
    switch(multicastea(mac, a->ip)){
    case V4:
    case V6:
        return arpresolve(f->arp, a, medium, mac);
    }

    /* let arp take care of it */
    return nil;
}
@

<<function ethermediumlink>>=
void
ethermediumlink(void)
{
    addipmedium(&ethermedium);
    addipmedium(&gbemedium);
}
@

<<function etherpref2addr>>=
static void
etherpref2addr(uchar *pref, uchar *ea)
{
    pref[8] = ea[0] | 0x2;
    pref[9] = ea[1];
    pref[10] = ea[2];
    pref[11] = 0xFF;
    pref[12] = 0xFE;
    pref[13] = ea[3];
    pref[14] = ea[4];
    pref[15] = ea[5];
}
@


%-------------------------------------------------------------

<<kernel/network/ip/ethermedium.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "../port/netif.h"
#include "ip.h"
#include "ipv6.h"

typedef struct Etherhdr Etherhdr;
typedef struct  Etherrock Etherrock;
typedef struct Etherarp Etherarp;

<<struct Etherhdr>>

<<global ipbroadcast>>

<<global etherbroadcast>>

static void etherread4(void *a);
static void etherread6(void *a);
static void etherbind(Ipifc *ifc, int argc, char **argv);
static void etherunbind(Ipifc *ifc);
static void etherbwrite(Ipifc *ifc, Block *bp, int version, uchar *ip);
static void etheraddmulti(Ipifc *ifc, uchar *a, uchar *ia);
static void etherremmulti(Ipifc *ifc, uchar *a, uchar *ia);
static Block*   multicastarp(Fs *f, Arpent *a, Medium*, uchar *mac);
static void sendarp(Ipifc *ifc, Arpent *a);
static void sendgarp(Ipifc *ifc, uchar*);
static int  multicastea(uchar *ea, uchar *ip);
static void recvarpproc(void*);
static void resolveaddr6(Ipifc *ifc, Arpent *a);
static void etherpref2addr(uchar *pref, uchar *ea);


<<global ethermedium (kernel)>>

<<global gbemedium>>

<<struct Etherrock>>

<<enum _anon_ (kernel/network/ip/ethermedium.c)>>

<<struct Etherarp>>

<<global nbmsg>>

<<function etherbind>>

<<function etherunbind>>

<<function etherbwrite (kernel/network/ip/ethermedium.c)>>


<<function etherread4>>


<<function etherread6>>

<<function etheraddmulti>>

<<function etherremmulti>>

<<function sendarp>>

<<function resolveaddr6>>

<<function sendgarp>>

<<function recvarp>>

<<function recvarpproc>>

<<function multicastea>>

<<function multicastarp>>

<<function ethermediumlink>>


<<function etherpref2addr>>
@


\subsection*{[[kernel/network/ip/pktmedium.c]]}

<<global pktmedium>>=
Medium pktmedium =
{
    .name=      "pkt",
    .hsize=     14,
    .mintu=     40,
    .maxtu=     4*1024,
    .maclen=    6,
    .bind=      pktbind,
    .unbind=    pktunbind,
    .bwrite=    pktbwrite,
    .pktin=     pktin,
};
@

<<function pktbind>>=
/*
 *  called to bind an IP ifc to an ethernet device
 *  called with ifc wlock'd
 */
static void
pktbind(Ipifc*, int argc, char **argv)
{
    USED(argc, argv);
}
@

<<function pktunbind>>=
/*
 *  called with ifc wlock'd
 */
static void
pktunbind(Ipifc*)
{
}
@

<<function pktbwrite>>=
/*
 *  called by ipoput with a single packet to write
 */
static void
pktbwrite(Ipifc *ifc, Block *bp, int, uchar*)
{
    /* enqueue onto the conversation's rq */
    bp = concatblock(bp);
    if(ifc->conv->snoopers.ref > 0)
        qpass(ifc->conv->sq, copyblock(bp, BLEN(bp)));
    qpass(ifc->conv->rq, bp);
}
@

<<function pktin>>=
/*
 *  called with ifc rlocked when someone write's to 'data'
 */
static void
pktin(Fs *f, Ipifc *ifc, Block *bp)
{
    if(ifc->lifc == nil)
        freeb(bp);
    else {
        if(ifc->conv->snoopers.ref > 0)
            qpass(ifc->conv->sq, copyblock(bp, BLEN(bp)));
        ipiput4(f, ifc, bp);
    }
}
@

<<function pktmediumlink>>=
void
pktmediumlink(void)
{
    addipmedium(&pktmedium);
}
@


%-------------------------------------------------------------

<<kernel/network/ip/pktmedium.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "ip.h"


static void pktbind(Ipifc*, int, char**);
static void pktunbind(Ipifc*);
static void pktbwrite(Ipifc*, Block*, int, uchar*);
static void pktin(Fs*, Ipifc*, Block*);

<<global pktmedium>>

<<function pktbind>>

<<function pktunbind>>

<<function pktbwrite>>

<<function pktin>>

<<function pktmediumlink>>
@


\subsection*{[[kernel/network/ip/iproute.c]]}


%-------------------------------------------------------------

<<kernel/network/ip/iproute.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    "ip.h"

static void walkadd(Fs*, Route**, Route*);
static void addnode(Fs*, Route**, Route*);
static void calcd(Route*);

<<global v4freelist>>
<<global v4routegeneration>>
<<global routelock>>

<<global v6freelist>>
<<global v6routegeneration>>

<<function freeroute>>

<<function allocroute>>

<<function addqueue>>

<<function lcmp>>

<<enum _anon_ (kernel/network/ip/iproute.c)>>

<<function rangecompare>>

<<function copygate>>

<<function walkadd>>

<<function calcd>>

<<function balancetree>>

<<function addnode>>

<<macro V4H>>

<<function v4addroute>>

<<macro V6H>>
<<function v6addroute>>

<<function looknode>>

<<function v4delroute>>

<<function v6delroute>>

<<function v4lookup>>

<<function v6lookup>>

<<function routetype>>

<<global rformat>>

<<function convroute>>

<<function sprintroute>>

<<function rr>>

<<function ipwalkroutes>>

<<function routeread>>

<<function delroute>>

<<function routeflush>>

<<function iproute>>

<<function printroute>>

<<function routewrite>>
@


\subsection*{[[kernel/network/ip/ipaux.c]]}

<<global v6Unspecified>>=
/*
 *  well known IPv6 addresses
 */
ipaddr v6Unspecified = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global v6loopback (kernel/network/ip/ipaux.c)>>=
ipaddr v6loopback = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0x01
};
@

<<global v6linklocal (kernel/network/ip/ipaux.c)>>=
ipaddr v6linklocal = {
    0xfe, 0x80, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global v6llpreflen (kernel/network/ip/ipaux.c)>>=
//};
int v6llpreflen = 8;    /* link-local prefix length in bytes */
@

<<global v6allnodesN>>=
//int v6mcpreflen = 1;  /* multicast prefix length */

ipaddr v6allnodesN = {
    0xff, 0x01, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0x01
};
@

<<global v6allnodesNmask>>=
//};
ipaddr v6allnodesNmask = {
    0xff, 0xff, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global v6allnodesL>>=
//int v6aNpreflen = 2;  /* all nodes (N) prefix */

ipaddr v6allnodesL = {
    0xff, 0x02, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0x01
};
@

<<global v6allnodesLmask>>=
//};
ipaddr v6allnodesLmask = {
    0xff, 0xff, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global v6solicitednode (kernel/network/ip/ipaux.c)>>=
//int v6aLpreflen = 2;  /* all nodes (L) prefix */

ipaddr v6solicitednode = {
    0xff, 0x02, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0x01,
    0xff, 0, 0, 0
};
@


<<enum _anon_ (kernel/network/ip/ipaux.c)>>=
enum
{
    Isprefix= 16,
};
@

<<function ipv62smcast>>=
//#define CLASS(p) ((*(uchar*)(p))>>6)

void
ipv62smcast(uchar *smcast, uchar *a)
{
    assert(IPaddrlen == 16);
    memmove(smcast, v6solicitednode, IPaddrlen);
    smcast[13] = a[13];
    smcast[14] = a[14];
    smcast[15] = a[15];
}
@

<<function parsemac>>=
/*
 *  parse a hex mac address
 */
int
parsemac(uchar *to, char *from, int len)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    memset(to, 0, len);
    for(i = 0; i < len; i++){
        if(p[0] == '\0' || p[1] == '\0')
            break;

        nip[0] = p[0];
        nip[1] = p[1];
        nip[2] = '\0';
        p += 2;

        to[i] = strtoul(nip, 0, 16);
        if(*p == ':')
            p++;
    }
    return i;
}
@



%-------------------------------------------------------------

<<kernel/network/ip/ipaux.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
#include    "ip.h"
#include    "ipv6.h"

//char *v6hdrtypes[Maxhdrtype] =
//{
//  [HBH]       "HopbyHop",
//  [ICMP]      "ICMP",
//  [IGMP]      "IGMP",
//  [GGP]       "GGP",
//  [IPINIP]    "IP",
//  [ST]        "ST",
//  [TCP]       "TCP",
//  [UDP]       "UDP",
//  [ISO_TP4]   "ISO_TP4",
//  [RH]        "Routinghdr",
//  [FH]        "Fraghdr",
//  [IDRP]      "IDRP",
//  [RSVP]      "RSVP",
//  [AH]        "Authhdr",
//  [ESP]       "ESP",
//  [ICMPv6]    "ICMPv6",
//  [NNH]       "Nonexthdr",
//  [ISO_IP]    "ISO_IP",
//  [IGRP]      "IGRP",
//  [OSPF]      "OSPF",
//};

<<global v6Unspecified>>
<<global v6loopback (kernel/network/ip/ipaux.c)>>

<<global v6linklocal (kernel/network/ip/ipaux.c)>>
//ipaddr v6linklocalmask = {
//  0xff, 0xff, 0xff, 0xff,
//  0xff, 0xff, 0xff, 0xff,
//  0, 0, 0, 0,
//  0, 0, 0, 0
<<global v6llpreflen (kernel/network/ip/ipaux.c)>>

//ipaddr v6multicast = {
//  0xff, 0, 0, 0,
//  0, 0, 0, 0,
//  0, 0, 0, 0,
//  0, 0, 0, 0
//};
//ipaddr v6multicastmask = {
//  0xff, 0, 0, 0,
//  0, 0, 0, 0,
//  0, 0, 0, 0,
//  0, 0, 0, 0
//};
<<global v6allnodesN>>
//ipaddr v6allroutersN = {
//  0xff, 0x01, 0, 0,
//  0, 0, 0, 0,
//  0, 0, 0, 0,
//  0, 0, 0, 0x02
<<global v6allnodesNmask>>
<<global v6allnodesL>>
//ipaddr v6allroutersL = {
//  0xff, 0x02, 0, 0,
//  0, 0, 0, 0,
//  0, 0, 0, 0,
//  0, 0, 0, 0x02
<<global v6allnodesLmask>>
<<global v6solicitednode (kernel/network/ip/ipaux.c)>>
//ipaddr v6solicitednodemask = {
//  0xff, 0xff, 0xff, 0xff,
//  0xff, 0xff, 0xff, 0xff,
//  0xff, 0xff, 0xff, 0xff,
//  0xff, 0x0, 0x0, 0x0
//};
//int v6snpreflen = 13;

<<function ptclcsum>>

<<enum _anon_ (kernel/network/ip/ipaux.c)>>

<<function ipv62smcast>>


<<function parsemac>>

<<function iphash>>

<<function iphtadd>>

<<function iphtrem>>

<<function iphtlook>>
@


\subsection*{[[kernel/network/ip/ipifc.c]]}

<<enum _anon_ (kernel/network/ip/ipifc.c)>>=
enum {
    <<constant Maxmedia>>
    Nself       = Maxmedia*5,
    NHASH       = 1<<6,
    NCACHE      = 256,
    QMAX        = 192*1024-1,
};
@











<<global sfixedformat>>=
char sfixedformat[] = "device %s maxtu %d sendra %d recvra %d mflag %d oflag"
" %d maxraint %d minraint %d linkmtu %d reachtime %d rxmitra %d ttl %d routerlt"
" %d pktin %lud pktout %lud errin %lud errout %lud\n";
@

<<global slineformat>>=
char slineformat[] = "  %-40I %-10M %-40I %-12lud %-12lud\n";
@

<<function ipifcstate>>=
static int
ipifcstate(Conv *c, char *state, int n)
{
    Ipifc *ifc;
    Iplifc *lifc;
    int m;

    ifc = (Ipifc*)c->ptcl;
    m = snprint(state, n, sfixedformat,
        ifc->dev, ifc->maxtu, ifc->sendra6, ifc->recvra6,
        ifc->rp.mflag, ifc->rp.oflag, ifc->rp.maxraint,
        ifc->rp.minraint, ifc->rp.linkmtu, ifc->rp.reachtime,
        ifc->rp.rxmitra, ifc->rp.ttl, ifc->rp.routerlt,
        ifc->in, ifc->out, ifc->inerr, ifc->outerr);

    rlock(ifc);
    for(lifc = ifc->lifc; lifc && n > m; lifc = lifc->next)
        m += snprint(state+m, n - m, slineformat, lifc->local,
            lifc->mask, lifc->remote, lifc->validlt, lifc->preflt);
    if(ifc->lifc == nil)
        m += snprint(state+m, n - m, "\n");
    runlock(ifc);
    return m;
}
@

<<function ipifclocal>>=
static int
ipifclocal(Conv *c, char *state, int n)
{
    Ipifc *ifc;
    Iplifc *lifc;
    Iplink *link;
    int m;

    ifc = (Ipifc*)c->ptcl;
    m = 0;

    rlock(ifc);
    for(lifc = ifc->lifc; lifc; lifc = lifc->next){
        m += snprint(state+m, n - m, "%-40.40I ->", lifc->local);
        for(link = lifc->link; link; link = link->lifclink)
            m += snprint(state+m, n - m, " %-40.40I", link->self->a);
        m += snprint(state+m, n - m, "\n");
    }
    runlock(ifc);
    return m;
}
@

<<function ipifcinuse>>=
static int
ipifcinuse(Conv *c)
{
    Ipifc *ifc;

    ifc = (Ipifc*)c->ptcl;
    return ifc->m != nil;
}
@

<<function ipifckick>>=
/*
 *  called when a process writes to an interface's 'data'
 */
static void
ipifckick(void *x)
{
    Conv *c = x;
    Block *bp;
    Ipifc *ifc;

    bp = qget(c->wq);
    if(bp == nil)
        return;

    ifc = (Ipifc*)c->ptcl;
    if(!canrlock(ifc)){
        freeb(bp);
        return;
    }
    if(waserror()){
        runlock(ifc);
        nexterror();
    }
    if(ifc->m == nil || ifc->m->pktin == nil)
        freeb(bp);
    else
        (*ifc->m->pktin)(c->p->f, ifc, bp);
    runlock(ifc);
    poperror();
}
@









<<function ipifcconnect>>=
/*
 *  associate an address with the interface.  This wipes out any previous
 *  addresses.  This is a macro that means, remove all the old interfaces
 *  and add a new one.
 */
static char*
ipifcconnect(Conv* c, char **argv, int argc)
{
    char *err;
    Ipifc *ifc;

    ifc = (Ipifc*)c->ptcl;

    if(ifc->m == nil)
         return "ipifc not yet bound to device";

    if(waserror()){
        wunlock(ifc);
        nexterror();
    }
    wlock(ifc);
    while(ifc->lifc){
        err = ipifcremlifc(ifc, ifc->lifc);
        if(err)
            error(err);
    }
    wunlock(ifc);
    poperror();

    err = ipifcadd(ifc, argv, argc, 0, nil);
    if(err)
        return err;

    Fsconnected(c, nil);
    return nil;
}
@





<<global freeiplink>>=
/*
 *  These structures are unlinked from their chains while
 *  other threads may be using them.  To avoid excessive locking,
 *  just put them aside for a while before freeing them.
 *  called with f->self locked
 */
static Iplink *freeiplink;
@

<<global freeipself>>=
static Ipself *freeipself;
@

<<function iplinkfree>>=
static void
iplinkfree(Iplink *p)
{
    Iplink **l, *np;
    ulong now = NOW;

    l = &freeiplink;
    for(np = *l; np; np = *l){
        if(np->expire > now){
            *l = np->next;
            free(np);
            continue;
        }
        l = &np->next;
    }
    p->expire = now + 5000; /* give other threads 5 secs to get out */
    p->next = nil;
    *l = p;
}
@

<<function ipselffree>>=
static void
ipselffree(Ipself *p)
{
    Ipself **l, *np;
    ulong now = NOW;

    l = &freeipself;
    for(np = *l; np; np = *l){
        if(np->expire > now){
            *l = np->next;
            free(np);
            continue;
        }
        l = &np->next;
    }
    p->expire = now + 5000; /* give other threads 5 secs to get out */
    p->next = nil;
    *l = p;
}
@


<<global stformat>>=
static char *stformat = "%-44.44I %2.2d %4.4s\n";
@

<<enum _anon_ (kernel/network/ip/ipifc.c)2>>=
enum
{
    Nstformat= 41,
};
@


<<function iptentative>>=
int
iptentative(Fs *f, uchar *addr)
{
    Ipself *p;

    p = f->self->hash[hashipa(addr)];
    for(; p; p = p->next){
        if(ipcmp(addr, p->a) == 0)
            return p->link->lifc->tentative;
    }
    return 0;
}
@



<<function findprimaryipv4>>=
/*
 *  returns first ip address configured
 */
static void
findprimaryipv4(Fs *f, uchar *local)
{
    Conv **cp, **e;
    Ipifc *ifc;
    Iplifc *lifc;

    /* find first ifc local address */
    e = &f->ipifc->conv[f->ipifc->nc];
    for(cp = f->ipifc->conv; cp < e; cp++){
        if(*cp == 0)
            continue;
        ifc = (Ipifc*)(*cp)->ptcl;
        if((lifc = ifc->lifc) != nil){
            ipmove(local, lifc->local);
            return;
        }
    }
}
@

<<function findlocalip>>=
/*
 *  find the local address 'closest' to the remote system, copy it to
 *  local and return the ifc for that address
 */
void
findlocalip(Fs *f, uchar *local, uchar *remote)
{
    int version, atype = unspecifiedv6, atypel = unknownv6;
    int atyper, deprecated;
    ipaddr gate, gnet;
    Ipifc *ifc;
    Iplifc *lifc;
    Route *r;

    USED(atype);
    USED(atypel);
    qlock(f->ipifc);
    r = v6lookup(f, remote, nil);
    version = (memcmp(remote, v4prefix, IPv4off) == 0)? V4: V6;

    if(r != nil){
        ifc = r->ifc;
        if(r->type & Rv4)
            v4tov6(gate, r->v4.gate);
        else {
            ipmove(gate, r->v6.gate);
            ipmove(local, v6Unspecified);
        }

        switch(version) {
        case V4:
            /* find ifc address closest to the gateway to use */
            for(lifc = ifc->lifc; lifc; lifc = lifc->next){
                maskip(gate, lifc->mask, gnet);
                if(ipcmp(gnet, lifc->net) == 0){
                    ipmove(local, lifc->local);
                    goto out;
                }
            }
            break;
        case V6:
            /* find ifc address with scope matching the destination */
            atyper = v6addrtype(remote);
            deprecated = 0;
            for(lifc = ifc->lifc; lifc; lifc = lifc->next){
                atypel = v6addrtype(lifc->local);
                /* prefer appropriate scope */
                if(atypel > atype && atype < atyper ||
                   atypel < atype && atype > atyper){
                    ipmove(local, lifc->local);
                    deprecated = !v6addrcurr(lifc);
                    atype = atypel;
                } else if(atypel == atype){
                    /* avoid deprecated addresses */
                    if(deprecated && v6addrcurr(lifc)){
                        ipmove(local, lifc->local);
                        atype = atypel;
                        deprecated = 0;
                    }
                }
                if(atype == atyper && !deprecated)
                    goto out;
            }
            if(atype >= atyper)
                goto out;
            break;
        default:
            panic("findlocalip: version %d", version);
        }
    }

    switch(version){
    case V4:
        findprimaryipv4(f, local);
        break;
    case V6:
        findprimaryipv6(f, local);
        break;
    default:
        panic("findlocalip2: version %d", version);
    }

out:
    qunlock(f->ipifc);
}
@

<<function ipv4local>>=
/*
 *  return first v4 address associated with an interface
 */
int
ipv4local(Ipifc *ifc, uchar *addr)
{
    Iplifc *lifc;

    for(lifc = ifc->lifc; lifc; lifc = lifc->next){
        if(isv4(lifc->local)){
            memmove(addr, lifc->local+IPv4off, IPv4addrlen);
            return 1;
        }
    }
    return 0;
}
@


<<function iplocalonifc>>=
/*
 *  see if this address is bound to the interface
 */
Iplifc*
iplocalonifc(Ipifc *ifc, uchar *ip)
{
    Iplifc *lifc;

    for(lifc = ifc->lifc; lifc; lifc = lifc->next)
        if(ipcmp(ip, lifc->local) == 0)
            return lifc;
    return nil;
}
@

<<function ipproxyifc>>=
/*
 *  See if we're proxying for this address on this interface
 */
int
ipproxyifc(Fs *f, Ipifc *ifc, uchar *ip)
{
    Route *r;
    ipaddr net;
    Iplifc *lifc;

    /* see if this is a direct connected pt to pt address */
    r = v6lookup(f, ip, nil);
    if(r == nil || (r->type & (Rifc|Rproxy)) != (Rifc|Rproxy))
        return 0;

    /* see if this is on the right interface */
    for(lifc = ifc->lifc; lifc; lifc = lifc->next){
        maskip(ip, lifc->mask, net);
        if(ipcmp(net, lifc->remote) == 0)
            return 1;
    }
    return 0;
}
@

<<function ipismulticast>>=
/*
 *  return multicast version if any
 */
int
ipismulticast(uchar *ip)
{
    if(isv4(ip)){
        if(ip[IPv4off] >= 0xe0 && ip[IPv4off] < 0xf0)
            return V4;
    }
    else if(ip[0] == 0xff)
        return V6;
    return 0;
}
@

<<function ipifcaddmulti>>=
/*
 *  add a multicast address to an interface, called with c->car locked
 */
void
ipifcaddmulti(Conv *c, uchar *ma, uchar *ia)
{
    Ipifc *ifc;
    Iplifc *lifc;
    Conv **p;
    Ipmulti *multi, **l;
    Fs *f;

    f = c->p->f;

    for(l = &c->multi; *l; l = &(*l)->next)
        if(ipcmp(ma, (*l)->ma) == 0 && ipcmp(ia, (*l)->ia) == 0)
            return;     /* it's already there */

    multi = *l = smalloc(sizeof(*multi));
    ipmove(multi->ma, ma);
    ipmove(multi->ia, ia);
    multi->next = nil;

    for(p = f->ipifc->conv; *p; p++){
        if((*p)->inuse == 0)
            continue;
        ifc = (Ipifc*)(*p)->ptcl;
        if(waserror()){
            wunlock(ifc);
            nexterror();
        }
        wlock(ifc);
        for(lifc = ifc->lifc; lifc; lifc = lifc->next)
            if(ipcmp(ia, lifc->local) == 0)
                addselfcache(f, ifc, lifc, ma, Rmulti);
        wunlock(ifc);
        poperror();
    }
}
@

<<function ipifcremmulti>>=
/*
 *  remove a multicast address from an interface, called with c->car locked
 */
void
ipifcremmulti(Conv *c, uchar *ma, uchar *ia)
{
    Ipmulti *multi, **l;
    Iplifc *lifc;
    Conv **p;
    Ipifc *ifc;
    Fs *f;

    f = c->p->f;

    for(l = &c->multi; *l; l = &(*l)->next)
        if(ipcmp(ma, (*l)->ma) == 0 && ipcmp(ia, (*l)->ia) == 0)
            break;

    multi = *l;
    if(multi == nil)
        return;     /* we don't have it open */

    *l = multi->next;

    for(p = f->ipifc->conv; *p; p++){
        if((*p)->inuse == 0)
            continue;

        ifc = (Ipifc*)(*p)->ptcl;
        if(waserror()){
            wunlock(ifc);
            nexterror();
        }
        wlock(ifc);
        for(lifc = ifc->lifc; lifc; lifc = lifc->next)
            if(ipcmp(ia, lifc->local) == 0)
                remselfcache(f, ifc, lifc, ma);
        wunlock(ifc);
        poperror();
    }

    free(multi);
}
@

<<function ipifcjoinmulti>>=
/*
 *  make lifc's join and leave multicast groups
 */
static char*
ipifcjoinmulti(Ipifc *ifc, char **argv, int argc)
{
    USED(ifc, argv, argc);
    return nil;
}
@

<<function ipifcleavemulti>>=
static char*
ipifcleavemulti(Ipifc *ifc, char **argv, int argc)
{
    USED(ifc, argv, argc);
    return nil;
}
@

<<function ipifcregisterproxy>>=
static void
ipifcregisterproxy(Fs *f, Ipifc *ifc, uchar *ip)
{
    Conv **cp, **e;
    Ipifc *nifc;
    Iplifc *lifc;
    Medium *m;
    ipaddr net;

    /* register the address on any network that will proxy for us */
    e = &f->ipifc->conv[f->ipifc->nc];

    if(!isv4(ip)) {             /* V6 */
        for(cp = f->ipifc->conv; cp < e; cp++){
            if(*cp == nil || (nifc = (Ipifc*)(*cp)->ptcl) == ifc)
                continue;
            rlock(nifc);
            m = nifc->m;
            if(m == nil || m->addmulti == nil) {
                runlock(nifc);
                continue;
            }
            for(lifc = nifc->lifc; lifc; lifc = lifc->next){
                maskip(ip, lifc->mask, net);
                if(ipcmp(net, lifc->remote) == 0) {
                    /* add solicited-node multicast addr */
                    ipv62smcast(net, ip);
                    addselfcache(f, nifc, lifc, net, Rmulti);
                    arpenter(f, V6, ip, nifc->mac, 6, 0);
                    // (*m->addmulti)(nifc, net, ip);
                    break;
                }
            }
            runlock(nifc);
        }
    }
    else {                  /* V4 */
        for(cp = f->ipifc->conv; cp < e; cp++){
            if(*cp == nil || (nifc = (Ipifc*)(*cp)->ptcl) == ifc)
                continue;
            rlock(nifc);
            m = nifc->m;
            if(m == nil || m->areg == nil){
                runlock(nifc);
                continue;
            }
            for(lifc = nifc->lifc; lifc; lifc = lifc->next){
                maskip(ip, lifc->mask, net);
                if(ipcmp(net, lifc->remote) == 0){
                    (*m->areg)(nifc, ip);
                    break;
                }
            }
            runlock(nifc);
        }
    }
}
@

<<enum _anon_ (kernel/network/ip/ipifc.c)4>>=
//}

enum {
    Ngates = 3,
};
@


%-------------------------------------------------------------

<<kernel/network/ip/ipifc.c>>=
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"

#include "ip.h"
#include "ipv6.h"

//#define DPRINT if(0)print

extern char*    ipifcadd6(Ipifc *ifc, char**argv, int argc);
extern char*    ipifcadd(Ipifc *ifc, char **argv, int argc, int tentative, Iplifc *lifcp);
extern char*    ipifcrem(Ipifc *ifc, char **argv, int argc);

<<enum _anon_ (kernel/network/ip/ipifc.c)>>

<<global media>>

<<struct Ipself>>

<<struct Ipselftab>>

/*
 *  Multicast addresses are chained onto a Chan so that
 *  we can remove them when the Chan is closed.
 */
typedef struct Ipmcast Ipmcast;
<<struct Ipmcast>>

<<macro hashipa>>

<<global tifc>>

static void addselfcache(Fs *f, Ipifc *ifc, Iplifc *lifc, uchar *a, int type);
static void remselfcache(Fs *f, Ipifc *ifc, Iplifc *lifc, uchar *a);
static char*    ipifcjoinmulti(Ipifc *ifc, char **argv, int argc);
static char*    ipifcleavemulti(Ipifc *ifc, char **argv, int argc);
static void ipifcregisterproxy(Fs*, Ipifc*, uchar*);
static char*    ipifcremlifc(Ipifc*, Iplifc*);

<<function addipmedium>>

<<function ipfindmedium>>

<<function ipifcbind>>

<<function ipifcunbind>>

<<global sfixedformat>>

<<global slineformat>>

<<function ipifcstate>>

<<function ipifclocal>>

<<function ipifcinuse>>

<<function ipifckick>>

<<function ipifccreate>>

<<function ipifcclose>>

<<function ipifcsetmtu>>

<<function ipifcadd>>

<<function ipifcremlifc>>

<<function ipifcrem>>

<<function ipifcaddroute>>

<<function ipifcremroute>>

<<function ipifcconnect>>

<<function ipifcra6>>

<<function ipifcctl>>

<<function ipifcstats>>

<<function ipifcinit>>

<<function addselfcache>>

<<global freeiplink>>
<<global freeipself>>

<<function iplinkfree>>

<<function ipselffree>>

<<function remselfcache>>

<<global stformat>>
<<enum _anon_ (kernel/network/ip/ipifc.c)2>>

<<function ipselftabread>>

<<function iptentative>>

<<function ipforme>>

<<function findipifc>>

<<enum _anon_ (kernel/network/ip/ipifc.c)3>>

<<function v6addrtype>>

<<macro v6addrcurr>>

<<function findprimaryipv6>>

<<function findprimaryipv4>>

<<function findlocalip>>

<<function ipv4local>>

<<function ipv6local>>

<<function ipv6anylocal>>

<<function iplocalonifc>>


<<function ipproxyifc>>

<<function ipismulticast>>

//int
//ipisbm(uchar *ip)
//{
//  if(isv4(ip)){
//      if(ip[IPv4off] >= 0xe0 && ip[IPv4off] < 0xf0)
//          return V4;
//      else if(ipcmp(ip, IPv4bcast) == 0)
//          return V4;
//  }
//  else if(ip[0] == 0xff)
//      return V6;
//  return 0;
//}


<<function ipifcaddmulti>>


<<function ipifcremmulti>>

<<function ipifcjoinmulti>>

<<function ipifcleavemulti>>

<<function ipifcregisterproxy>>


/* added for new v6 mesg types */
//static void
//adddefroute6(Fs *f, uchar *gate, int force)
//{
//  Route *r;
//
//  r = v6lookup(f, v6Unspecified, nil);
//  /*
//   * route entries generated by all other means take precedence
//   * over router announcements.
//   */
//  if (r && !force && strcmp(r->tag, "ra") != 0)
//      return;
//
//  v6delroute(f, v6Unspecified, v6Unspecified, 1);
//  v6addroute(f, "ra", v6Unspecified, v6Unspecified, gate, 0);
<<enum _anon_ (kernel/network/ip/ipifc.c)4>>

<<function ipifcadd6>>
@


\subsection*{[[kernel/network/ip/netlog.c]]}


<<struct Netlogflag>>=
typedef struct Netlogflag {
    char*   name;
    int mask;
} Netlogflag;
@

<<global flags>>=
static Netlogflag flags[] =
{
    { "ppp",    Logppp, },
    { "ip",     Logip, },
    { "fs",     Logfs, },
    { "tcp",    Logtcp, },
    { "icmp",   Logicmp, },
    { "udp",    Logudp, },
    { "compress",   Logcompress, },
    { "gre",    Loggre, },
    { "tcpwin", Logtcp|Logtcpwin, },
    { "tcprxmt",    Logtcp|Logtcprxmt, },
    { "udpmsg", Logudp|Logudpmsg, },
    { "ipmsg",  Logip|Logipmsg, },
    { "esp",    Logesp, },
    { nil,      0, },
};
@

<<global Ebadnetctl>>=
char Ebadnetctl[] = "too few arguments for netlog control message";
@




<<function netlogclose>>=
void
netlogclose(Fs *f)
{
    lock(f->alog);
    if(waserror()){
        unlock(f->alog);
        nexterror();
    }
    f->alog->opens--;
    if(f->alog->opens == 0){
        free(f->alog->buf);
        f->alog->buf = nil;
    }
    unlock(f->alog);
    poperror();
}
@




<<function netlog>>=
void
netlog(Fs *f, int mask, char *fmt, ...)
{
    char buf[256], *t, *fp;
    int i, n;
    va_list arg;

    if(!(f->alog->logmask & mask))
        return;

    if(f->alog->opens == 0)
        return;

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);

    lock(f->alog);
    i = f->alog->len + n - Nlog;
    if(i > 0){
        f->alog->len -= i;
        f->alog->rptr += i;
        if(f->alog->rptr >= f->alog->end)
            f->alog->rptr = f->alog->buf + (f->alog->rptr - f->alog->end);
    }
    t = f->alog->rptr + f->alog->len;
    fp = buf;
    f->alog->len += n;
    while(n-- > 0){
        if(t >= f->alog->end)
            t = f->alog->buf + (t - f->alog->end);
        *t++ = *fp++;
    }
    unlock(f->alog);

    wakeup(f->alog);
}
@


%-------------------------------------------------------------

<<kernel/network/ip/netlog.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
#include    "../ip/ip.h"

<<enum _anon_ (kernel/network/ip/netlog.c)>>

<<struct Netlog>>

<<struct Netlogflag>>

<<global flags>>

<<global Ebadnetctl>>

<<enum _anon_ (kernel/network/ip/netlog.c)2>>

<<global routecmd>>

<<function netloginit>>

<<function netlogopen>>

<<function netlogclose>>

<<function netlogready>>

<<function netlogread>>

<<function netlogctl>>

<<function netlog>>
@


\subsection*{[[kernel/network/ip/ptclbsum.c]]}

<<global endian (kernel/network/ip/ptclbsum.c)>>=
static  short   endian  = 1;
@

<<global aendian (kernel/network/ip/ptclbsum.c)>>=
static  uchar*  aendian = (uchar*)&endian;
@

<<constant LITTLE (kernel/network/ip/ptclbsum.c)>>=
#define LITTLE  *aendian
@

<<function ptclbsum (kernel/network/ip/ptclbsum.c)>>=
ushort
ptclbsum(uchar *addr, int len)
{
    ulong losum, hisum, mdsum, x;
    ulong t1, t2;

    losum = 0;
    hisum = 0;
    mdsum = 0;

    x = 0;
    if((ulong)addr & 1) {
        if(len) {
            hisum += addr[0];
            len--;
            addr++;
        }
        x = 1;
    }
    while(len >= 16) {
        t1 = *(ushort*)(addr+0);
        t2 = *(ushort*)(addr+2);    mdsum += t1;
        t1 = *(ushort*)(addr+4);    mdsum += t2;
        t2 = *(ushort*)(addr+6);    mdsum += t1;
        t1 = *(ushort*)(addr+8);    mdsum += t2;
        t2 = *(ushort*)(addr+10);   mdsum += t1;
        t1 = *(ushort*)(addr+12);   mdsum += t2;
        t2 = *(ushort*)(addr+14);   mdsum += t1;
        mdsum += t2;
        len -= 16;
        addr += 16;
    }
    while(len >= 2) {
        mdsum += *(ushort*)addr;
        len -= 2;
        addr += 2;
    }
    if(x) {
        if(len)
            losum += addr[0];
        if(LITTLE)
            losum += mdsum;
        else
            hisum += mdsum;
    } else {
        if(len)
            hisum += addr[0];
        if(LITTLE)
            hisum += mdsum;
        else
            losum += mdsum;
    }

    losum += hisum >> 8;
    losum += (hisum & 0xff) << 8;
    while(hisum = losum>>16)
        losum = hisum + (losum & 0xffff);

    return losum & 0xffff;
}
@


%-------------------------------------------------------------

<<kernel/network/ip/ptclbsum.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"
#include    "ip.h"

<<global endian (kernel/network/ip/ptclbsum.c)>>
<<global aendian (kernel/network/ip/ptclbsum.c)>>
<<constant LITTLE (kernel/network/ip/ptclbsum.c)>>

<<function ptclbsum (kernel/network/ip/ptclbsum.c)>>
@


\subsection*{[[kernel/network/ip/il.c]]}

<<enum _anon_ (kernel/network/ip/il.c)3>>=
enum
{
    Seconds		= 1000,
    Iltickms 	= 50,		/* time base */
    AckDelay	= 2*Iltickms,	/* max time twixt message rcvd & ack sent */
    MaxTimeout 	= 30*Seconds,	/* max time between rexmit */
    QueryTime	= 10*Seconds,	/* time between subsequent queries */
    DeathTime	= 30*QueryTime,

    MaxRexmit 	= 16,		/* max retransmissions before hangup */
    Defaultwin	= 20,

    LogAGain	= 3,
    AGain		= 1<<LogAGain,
    LogDGain	= 2,
    DGain		= 1<<LogDGain,

    DefByteRate	= 100,		/* assume a megabit link */
    DefRtt		= 50,		/* cross country on a great day */

    <<constant Maxrq(IL)>>
};
@
% >> >> >>

<<enum _anon_ (kernel/network/ip/il.c)4>>=
enum
{
    Nqt=	8,
};
@


<<enum _anon_ (kernel/network/ip/il.c)5>>=
enum
{
    <<constant IL_xxxSIZE>>
    <<constant IP_ILPROTO>>

};
@

<<global etime>>=
static	char	*etime = "connection timed out";
@










<<function ilackq>>=
void
ilackq(Ilcb *ic, Block *bp)
{
    Block *np;
    int n;

    n = blocklen(bp);

    /* Enqueue a copy on the unacked queue in case this one gets lost */
    np = copyblock(bp, n);
    if(ic->unacked)
        ic->unackedtail->list = np;
    else
        ic->unacked = np;
    ic->unackedtail = np;
    np->list = nil;
    ic->unackedbytes += n;
}
@

<<function ilrttcalc>>=
static
void
ilrttcalc(Ilcb *ic, Block *bp)
{
    int rtt, tt, pt, delay, rate;

    rtt = arch_fastticks(nil) - ic->rttstart;
    rtt = (rtt*scalemul)/scalediv;
    delay = ic->delay;
    rate = ic->rate;

    /* Guard against zero wrap */
    if(rtt > 120000 || rtt < 0)
        return;

    /* this block had to be transmitted after the one acked so count its size */
    ic->rttlen += blocklen(bp)  + IL_IPSIZE + IL_HDRSIZE;

    if(ic->rttlen < 256){
        /* guess fixed delay as rtt of small packets */
        delay += rtt - (delay>>LogAGain);
        if(delay < AGain)
            delay = AGain;
        ic->delay = delay;
    } else {
        /* if packet took longer than avg rtt delay, recalc rate */
        tt = rtt - (delay>>LogAGain);
        if(tt > 0){
            rate += ic->rttlen/tt - (rate>>LogAGain);
            if(rate < AGain)
                rate = AGain;
            ic->rate = rate;
        }
    }

    /* mdev */
    pt = ic->rttlen/(rate>>LogAGain) + (delay>>LogAGain);
    ic->mdev += abs(rtt-pt) - (ic->mdev>>LogDGain);

    if(rtt > ic->maxrtt)
        ic->maxrtt = rtt;
}
@

<<function ilackto>>=
void
ilackto(Ilcb *ic, ulong ackto, Block *bp)
{
    Ilhdr *h;
    ulong id;

    if(ic->rttack == ackto)
        ilrttcalc(ic, bp);

    /* Cancel if we've passed the packet we were interested in */
    if(ic->rttack <= ackto)
        ic->rttack = 0;

    qlock(&ic->ackq);
    while(ic->unacked) {
        h = (Ilhdr *)ic->unacked->rp;
        id = nhgetl(h->ilid);
        if(ackto < id)
            break;

        bp = ic->unacked;
        ic->unacked = bp->list;
        bp->list = nil;
        ic->unackedbytes -= blocklen(bp);
        freeblist(bp);
        ic->rexmit = 0;
        ilsettimeout(ic);
    }
    qunlock(&ic->ackq);
}
@



<<function ilrexmit>>=
void
ilrexmit(Ilcb *ic)
{
    Ilhdr *h;
    Block *nb;
    Conv *c;
//    ulong id; BUG?
    Ilpriv *priv;

    nb = nil;
    qlock(&ic->ackq);
    if(ic->unacked)
        nb = copyblock(ic->unacked, blocklen(ic->unacked));
    qunlock(&ic->ackq);

    if(nb == nil)
        return;

    h = (Ilhdr*)nb->rp;
    h->vihl = IP_VER4;

    h->iltype = Ildataquery;
    hnputl(h->ilack, ic->recvd);
    h->ilspec = ilnextqt(ic);
    h->ilsum[0] = 0;
    h->ilsum[1] = 0;
    hnputs(h->ilsum, ptclcsum(nb, IL_IPSIZE, nhgets(h->illen)));

    c = ic->conv;
    //id = nhgetl(h->ilid);
    //netlog(c->p->f, Logil, "il: rexmit %lud %lud: %d %lud: %I %d/%d\n", id, ic->recvd,
//		ic->rexmit, ic->timeout,
//		c->raddr, c->lport, c->rport);

    ilbackoff(ic);

    ipoput4(c->p->f, nb, 0, c->ttl, c->tos, c);

    /* statistics */
    ic->rxtot++;
    priv = c->p->priv;
    priv->rexmit++;
}
@


<<function ilhangup>>=
void
ilhangup(Conv *s, char *msg)
{
    Ilcb *ic;
    int callout;

    //netlog(s->p->f, Logil, "il: hangup! %I %d/%d: %s\n", s->raddr,
//		s->lport, s->rport, msg?msg:"no reason");

    ic = (Ilcb*)s->ptcl;
    callout = ic->state == Ilsyncer;
    illocalclose(s);

    qhangup(s->rq, msg);
    qhangup(s->wq, msg);

    if(callout)
        Fsconnected(s, msg);
}
@

<<function ilpullup>>=
void
ilpullup(Conv *s)
{
    Ilcb *ic;
    Ilhdr *oh;
    Block *bp;
    ulong oid, dlen;
    Ilpriv *ipriv;

    ic = (Ilcb*)s->ptcl;
    if(ic->state != Ilestablished)
        return;

    qlock(&ic->outo);
    while(ic->outoforder) {
        bp = ic->outoforder;
        oh = (Ilhdr*)bp->rp;
        oid = nhgetl(oh->ilid);
        if(oid <= ic->recvd) {
            ic->outoforder = bp->list;
            freeblist(bp);
            continue;
        }
        if(oid != ic->recvd+1){
            ipriv = s->p->priv;
            ipriv->stats[OutOfOrder]++;
            break;
        }

        ic->recvd = oid;
        ic->outoforder = bp->list;

        bp->list = nil;
        dlen = nhgets(oh->illen)-IL_HDRSIZE;
        bp = trimblock(bp, IL_IPSIZE+IL_HDRSIZE, dlen);
        /*
         * Upper levels don't know about multiple-block
         * messages so copy all into one (yick).
         */
        bp = concatblock(bp);
        if(bp == 0)
            panic("ilpullup");
        bp = packblock(bp);
        if(bp == 0)
            panic("ilpullup2");
        qpass(s->rq, bp);
    }
    qunlock(&ic->outo);
}
@

<<function iloutoforder>>=
void
iloutoforder(Conv *s, Ilhdr *h, Block *bp)
{
    Ilcb *ic;
    uchar *lid;
    Block *f, **l;
    ulong id, newid;
    Ilpriv *ipriv;

    ipriv = s->p->priv;
    ic = (Ilcb*)s->ptcl;
    bp->list = nil;

    id = nhgetl(h->ilid);
    /* Window checks */
    if(id <= ic->recvd || id > ic->recvd+ic->window) {
        //netlog(s->p->f, Logil, "il: message outside window %lud <%lud-%lud>: %I %d/%d\n",
//			id, ic->recvd, ic->recvd+ic->window, s->raddr, s->lport, s->rport);
        freeblist(bp);
        return;
    }

    /* Packet is acceptable so sort onto receive queue for pullup */
    qlock(&ic->outo);
    if(ic->outoforder == nil)
        ic->outoforder = bp;
    else {
        l = &ic->outoforder;
        for(f = *l; f; f = f->list) {
            lid = ((Ilhdr*)(f->rp))->ilid;
            newid = nhgetl(lid);
            if(id <= newid) {
                if(id == newid) {
                    ipriv->stats[DupMsg]++;
                    ipriv->stats[DupBytes] += blocklen(bp);
                    qunlock(&ic->outo);
                    freeblist(bp);
                    return;
                }
                bp->list = f;
                *l = bp;
                qunlock(&ic->outo);
                return;
            }
            l = &f->list;
        }
        *l = bp;
    }
    qunlock(&ic->outo);
}
@


<<function ilreject>>=
void
ilreject(Fs *f, Ilhdr *inih)
{
    Ilhdr *ih;
    Block *bp;

    bp = allocb(IL_IPSIZE+IL_HDRSIZE);
    bp->wp += IL_IPSIZE+IL_HDRSIZE;

    ih = (Ilhdr *)(bp->rp);
    ih->vihl = IP_VER4;

    /* Ip fields */
    ih->proto = IP_ILPROTO;
    hnputs(ih->illen, IL_HDRSIZE);
    ih->frag[0] = 0;
    ih->frag[1] = 0;
    hnputl(ih->dst, nhgetl(inih->src));
    hnputl(ih->src, nhgetl(inih->dst));
    hnputs(ih->ilsrc, nhgets(inih->ildst));
    hnputs(ih->ildst, nhgets(inih->ilsrc));
    hnputl(ih->ilid, nhgetl(inih->ilack));
    hnputl(ih->ilack, nhgetl(inih->ilid));
    ih->iltype = Ilclose;
    ih->ilspec = 0;
    ih->ilsum[0] = 0;
    ih->ilsum[1] = 0;

    if(ilcksum)
        hnputs(ih->ilsum, ptclcsum(bp, IL_IPSIZE, IL_HDRSIZE));

    ipoput4(f, bp, 0, MAXTTL, DFLTTOS, nil);
}
@

<<function ilsettimeout>>=
void
ilsettimeout(Ilcb *ic)
{
    ulong pt;

    pt = (ic->delay>>LogAGain)
        + ic->unackedbytes/(ic->rate>>LogAGain)
        + (ic->mdev>>(LogDGain-1))
        + AckDelay;
    if(pt > MaxTimeout)
        pt = MaxTimeout;
    ic->timeout = NOW + pt;
}
@

<<function ilbackoff>>=
void
ilbackoff(Ilcb *ic)
{
    ulong pt;
    int i;

    pt = (ic->delay>>LogAGain)
        + ic->unackedbytes/(ic->rate>>LogAGain)
        + (ic->mdev>>(LogDGain-1))
        + AckDelay;
    for(i = 0; i < ic->rexmit; i++)
        pt = pt + (pt>>1);
    if(pt > MaxTimeout)
        pt = MaxTimeout;
    ic->timeout = NOW + pt;

    if(ic->fasttimeout)
        ic->timeout = NOW+Iltickms;

    ic->rexmit++;
}
@

<<constant Tfuture>>=
// complain if two numbers not within an hour of each other
#define Tfuture (1000*60*60)
@

<<function later>>=
int
later(ulong t1, ulong t2, char *x)
{
    int dt;

    dt = t1 - t2;
    if(dt > 0) {
        if(x != nil && dt > Tfuture)
            print("%s: way future %d\n", x, dt);
        return 1;
    }
    if(dt < -Tfuture) {
        if(x != nil)
            print("%s: way past %d\n", x, -dt);
        return 1;
    }
    return 0;
}
@

<<function ilackproc>>=
void
ilackproc(void *x)
{
    Ilcb *ic;
    Conv **s, *p;
    Proto *il;

    il = x;

    while(waserror())
        ;
loop:
    tsleep(&up->sleepr, returnfalse, 0, Iltickms);
    for(s = il->conv; s && *s; s++) {
        p = *s;
        ic = (Ilcb*)p->ptcl;

        switch(ic->state) {
        case Ilclosed:
        case Illistening:
            break;
        case Ilclosing:
            if(later(NOW, ic->timeout, "timeout0")) {
                if(ic->rexmit > MaxRexmit){
                    ilhangup(p, nil);
                    break;
                }
                ilsendctl(p, nil, Ilclose, ic->next, ic->recvd, 0);
                ilbackoff(ic);
            }
            break;

        case Ilsyncee:
        case Ilsyncer:
            if(later(NOW, ic->timeout, "timeout1")) {
                if(ic->rexmit > MaxRexmit){
                    ilhangup(p, etime);
                    break;
                }
                ilsendctl(p, nil, Ilsync, ic->start, ic->recvd, 0);
                ilbackoff(ic);
            }
            break;

        case Ilestablished:
            if(ic->recvd != ic->acksent)
            if(later(NOW, ic->acktime, "acktime"))
                ilsendctl(p, nil, Ilack, ic->next, ic->recvd, 0);

            if(later(NOW, ic->querytime, "querytime")){
                if(later(NOW, ic->lastrecv+DeathTime, "deathtime")){
                    //netlog(il->f, Logil, "il: hangup: deathtime\n");
                    ilhangup(p, etime);
                    break;
                }
                ilsendctl(p, nil, Ilquery, ic->next, ic->recvd, ilnextqt(ic));
                ic->querytime = NOW + QueryTime;
            }

            if(ic->unacked != nil)
            if(later(NOW, ic->timeout, "timeout2")) {
                if(ic->rexmit > MaxRexmit){
                    //netlog(il->f, Logil, "il: hangup: too many rexmits\n");
                    ilhangup(p, etime);
                    break;
                }
                ilsendctl(p, nil, Ilquery, ic->next, ic->recvd, ilnextqt(ic));
                ic->rxquery++;
                ilbackoff(ic);
            }
            break;
        }
    }
    goto loop;
}
@



<<function ilfreeq>>=
void
ilfreeq(Ilcb *ic)
{
    Block *bp, *next;

    qlock(&ic->ackq);
    for(bp = ic->unacked; bp; bp = next) {
        next = bp->list;
        freeblist(bp);
    }
    ic->unacked = nil;
    qunlock(&ic->ackq);

    qlock(&ic->outo);
    for(bp = ic->outoforder; bp; bp = next) {
        next = bp->list;
        freeblist(bp);
    }
    ic->outoforder = nil;
    qunlock(&ic->outo);
}
@

<<function iladvise>>=
void
iladvise(Proto *il, Block *bp, char *msg)
{
    Ilhdr *h;
    Ilcb *ic;		
    ipaddr source, dest;
    ushort psource;
    Conv *s, **p;

    h = (Ilhdr*)(bp->rp);

    v4tov6(dest, h->dst);
    v4tov6(source, h->src);
    psource = nhgets(h->ilsrc);


    /* Look for a connection, unfortunately the destination port is missing */
    qlock(il);
    for(p = il->conv; *p; p++) {
        s = *p;
        if(s->lport == psource)
        if(ipcmp(s->laddr, source) == 0)
        if(ipcmp(s->raddr, dest) == 0){
            qunlock(il);
            ic = (Ilcb*)s->ptcl;
            switch(ic->state){
            case Ilsyncer:
                ilhangup(s, msg);
                break;
            }
            freeblist(bp);
            return;
        }
    }
    qunlock(il);
    freeblist(bp);
}
@

<<function ilnextqt>>=
int
ilnextqt(Ilcb *ic)
{
    int x;

    qlock(&ic->ackq);
    x = ic->qtx;
    if(++x > Nqt)
        x = 1;
    ic->qtx = x;
    ic->qt[x] = ic->next-1;	/* highest xmitted packet */
    ic->qt[0] = ic->qt[x];	/* compatibility with old implementations */
    qunlock(&ic->ackq);

    return x;
}
@




%-------------------------------------------------------------

<<kernel/network/ip/il.c>>=
#include	"u.h"
#include	"../port/lib.h"
#include	"mem.h"
#include	"dat.h"
#include	"fns.h"
#include	"../port/error.h"

#include	"ip.h"

// forward decl
typedef struct Ilcb Ilcb;
typedef struct Ilhdr Ilhdr;
typedef struct Ilpriv Ilpriv;

<<enum _anon_ (kernel/network/ip/il.c)>>

<<global ilstates>>

<<enum _anon_ (kernel/network/ip/il.c)2>>

<<global iltype>>

<<enum _anon_ (kernel/network/ip/il.c)3>>

<<enum _anon_ (kernel/network/ip/il.c)4>>

<<struct Ilcb>>

<<enum _anon_ (kernel/network/ip/il.c)5>>

<<enum mode (kernel/network/ip/il.c)>>

<<struct Ilhdr>>

<<enum _anon_ (kernel/network/ip/il.c)6>>

<<global statnames (kernel/network/ip/il.c)>>

<<struct Ilpriv>>

/* state for query/dataquery messages */

void	ilsendctl(Conv*, Ilhdr*, int, ulong, ulong, int);
void	ilackq(Ilcb*, Block*);
void	ilprocess(Conv*, Ilhdr*, Block*);
void	ilpullup(Conv*);
void	ilhangup(Conv*, char*);
void	ilfreeq(Ilcb*);
void	ilrexmit(Ilcb*);
void	ilbackoff(Ilcb*);
void	ilsettimeout(Ilcb*);
char*	ilstart(Conv*, int, int);
void	ilackproc(void*);
void	iloutoforder(Conv*, Ilhdr*, Block*);
void	iliput(Proto*, Ipifc*, Block*);
void	iladvise(Proto*, Block*, char*);
int	ilnextqt(Ilcb*);
void	ilcbinit(Ilcb*);
int	later(ulong, ulong, char*);
void	ilreject(Fs*, Ilhdr*);
void	illocalclose(Conv *c);


<<global ilcksum>>
<<global scalexxx>>
<<global etime>>

<<function ilconnect>>

<<function ilstate>>

<<function ilinuse>>

<<function ilannounce>>

<<function illocalclose>>

<<function ilclose>>

<<function ilkick>>

<<function ilcreate>>

<<function ilxstats>>

<<function ilackq>>

<<function ilrttcalc>>

<<function ilackto>>

<<function iliput>>

<<function _ilprocess>>

<<function ilrexmit>>

<<function ilprocess>>

<<function ilhangup>>

<<function ilpullup>>

<<function iloutoforder>>

<<function ilsendctl>>

<<function ilreject>>

<<function ilsettimeout>>

<<function ilbackoff>>

<<constant Tfuture>>
<<function later>>

<<function ilackproc>>

<<function ilcbinit>>

<<function ilstart>>

<<function ilfreeq>>

<<function iladvise>>

<<function ilnextqt>>

<<function inittimescale>>

<<function ilinit>>
@


\subsection*{[[kernel/network/ip/udp.c]]}

<<constant DPRINT>>=
#define DPRINT if(0)print
@

<<enum _anon_ (kernel/network/ip/udp.c)>>=
enum
{
    <<constant UDP_UDPHDR_SZ>>

    <<constant UDP4_PHDR_OFF>>
    <<constant UDP4_PHDR_SZ>>
    <<constant UDP4_IPHDR_SZ>>

    <<constant UDP6_xxx>>
    <<constant IP_UDPPROTO>>

    <<constant UDP_USEAD7>>

    Udprxms     = 200,
    Udptickms   = 100,
    Udpmaxxmit  = 10,
};
@
%less: dead constants?





<<function udpadvise>>=
void
udpadvise(Proto *udp, Block *bp, char *msg)
{
    Udp4hdr *h4;
    Udp6hdr *h6;
    ipaddr source, dest;
    ushort psource, pdest;
    Conv *s, **p;
    int version;

    h4 = (Udp4hdr*)(bp->rp);
    version = ((h4->vihl&0xF0)==IP_VER6) ? 6 : 4;

    switch(version) {
    case V4:
        v4tov6(dest, h4->udpdst);
        v4tov6(source, h4->udpsrc);
        psource = nhgets(h4->udpsport);
        pdest = nhgets(h4->udpdport);
        break;
    case V6:
        h6 = (Udp6hdr*)(bp->rp);
        ipmove(dest, h6->udpdst);
        ipmove(source, h6->udpsrc);
        psource = nhgets(h6->udpsport);
        pdest = nhgets(h6->udpdport);
        break;
    default:
        panic("udpadvise: version %d", version);
        return;  /* to avoid a warning */
    }

    /* Look for a connection */
    qlock(udp);
    for(p = udp->conv; *p; p++) {
        s = *p;
        if(s->rport == pdest)
        if(s->lport == psource)
        if(ipcmp(s->raddr, dest) == 0)
        if(ipcmp(s->laddr, source) == 0){
            if(s->ignoreadvice)
                break;
            qlock(s);
            qunlock(udp);
            qhangup(s->rq, msg);
            qhangup(s->wq, msg);
            qunlock(s);
            freeblist(bp);
            return;
        }
    }
    qunlock(udp);
    freeblist(bp);
}
@



%-------------------------------------------------------------

<<kernel/network/ip/udp.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    "ip.h"
#include    "ipv6.h"


<<constant DPRINT>>

<<enum _anon_ (kernel/network/ip/udp.c)>>

// forward decl
typedef struct Udp4hdr Udp4hdr;
typedef struct Udp6hdr Udp6hdr;
typedef struct Udpstats Udpstats;
typedef struct Udppriv Udppriv;
typedef struct Udpcb Udpcb;

//void (*etherprofiler)(char *name, int qlen);
void udpkick(void *x, Block *bp);


<<struct Udp4hdr>>

<<struct Udp6hdr>>

<<struct Udpstats>>

<<struct Udppriv>>

/*
 *  protocol specific part of Conv
 */
<<struct Udpcb>>

<<function udpconnect>>


<<function udpstate>>

<<function udpannounce>>

<<function udpcreate>>

<<function udpclose>>

<<function udpkick>>

<<function udpiput>>

<<function udpctl>>

<<function udpadvise>>

<<function udpstats>>

<<function udpinit>>
@


\subsection*{[[kernel/network/ip/tcp.c]]}

<<enum _anon_ (kernel/network/ip/tcp.c)>>=
enum
{
    QMAX        = 64*1024-1,
    IP_TCPPROTO = 6,

    TCP4_IPLEN  = 8,
    TCP4_PHDRSIZE   = 12,
    TCP4_HDRSIZE    = 20,
    TCP4_TCBPHDRSZ  = 40,
    TCP4_PKT    = TCP4_IPLEN+TCP4_PHDRSIZE,

    TCP6_IPLEN  = 0,
    TCP6_PHDRSIZE   = 40,
    TCP6_HDRSIZE    = 20,
    TCP6_TCBPHDRSZ  = 60,
    TCP6_PKT    = TCP6_IPLEN+TCP6_PHDRSIZE,

    TcptimerOFF = 0,
    TcptimerON  = 1,
    TcptimerDONE    = 2,
    MAX_TIME    = (1<<20),  /* Forever */
    TCP_ACK     = 50,       /* Timed ack sequence in ms */
    MAXBACKMS   = 9*60*1000,    /* longest backoff time (ms) before hangup */

    URG     = 0x20,     /* Data marked urgent */
    ACK     = 0x10,     /* Acknowledge is valid */
    PSH     = 0x08,     /* Whole data pipe is pushed */
    RST     = 0x04,     /* Reset connection */
    SYN     = 0x02,     /* Pkt. is synchronise */
    FIN     = 0x01,     /* Start close down */

    EOLOPT      = 0,
    NOOPOPT     = 1,
    MSSOPT      = 2,
    MSS_LENGTH  = 4,        /* Maximum segment size */
    WSOPT       = 3,
    WS_LENGTH   = 3,        /* Bits to scale window size by */
    MSL2        = 10,
    MSPTICK     = 50,       /* Milliseconds per timer tick */
    DEF_MSS     = 1460,     /* Default maximum segment */
    DEF_MSS6    = 1280,     /* Default maximum segment (min) for v6 */
    DEF_RTT     = 500,      /* Default round trip */
    DEF_KAT     = 120000,   /* Default time (ms) between keep alives */
    TCP_LISTEN  = 0,        /* Listen connection */
    TCP_CONNECT = 1,        /* Outgoing connection */
    SYNACK_RXTIMER  = 250,      /* ms between SYNACK retransmits */

    TCPREXMTTHRESH  = 3,        /* dupack threshhold for rxt */

    FORCE       = 1,
    CLONE       = 2,
    RETRAN      = 4,
    ACTIVE      = 8,
    SYNACK      = 16,

    LOGAGAIN    = 3,
    LOGDGAIN    = 2,

    Closed      = 0,        /* Connection states */
    Listen,
    Syn_sent,
    Syn_received,
    Established,
    Finwait1,
    Finwait2,
    Close_wait,
    Closing,
    Last_ack,
    Time_wait,

    Maxlimbo    = 1000,     /* maximum procs waiting for response to SYN ACK */
    NLHT        = 256,      /* hash table size, must be a power of 2 */
    LHTMASK     = NLHT-1,

    /*
     * window is 64kb * 2ⁿ
     * these factors determine the ultimate bandwidth-delay product.
     * 64kb * 2⁵ = 2mb, or 2× overkill for 100mbps * 70ms.
     */
    Maxqscale   = 4,        /* maximum queuing scale */
    Defadvscale = 4,        /* default advertisement */
};
@

<<global tcpstates>>=
/* Must correspond to the enumeration above */
char *tcpstates[] =
{
    "Closed",   "Listen",   "Syn_sent", "Syn_received",
    "Established",  "Finwait1", "Finwait2", "Close_wait",
    "Closing",  "Last_ack",     "Time_wait"
};
@

<<struct Tcptimer>>=
struct Tcptimer
{
    Tcptimer    *next;
    Tcptimer    *prev;
    Tcptimer    *readynext;
    int state;
    int start;
    int count;
    void    (*func)(void*);
    void    *arg;
};
@

<<struct Tcp4hdr>>=
struct Tcp4hdr
{
    uchar   vihl;       /* Version and header length */
    uchar   tos;        /* Type of service */
    uchar   length[2];  /* packet length */
    uchar   id[2];      /* Identification */
    uchar   frag[2];    /* Fragment information */
    uchar   Unused;
    uchar   proto;
    uchar   tcplen[2];
    uchar   tcpsrc[4];
    uchar   tcpdst[4];
    uchar   tcpsport[2];
    uchar   tcpdport[2];
    uchar   tcpseq[4];
    uchar   tcpack[4];
    uchar   tcpflag[2];
    uchar   tcpwin[2];
    uchar   tcpcksum[2];
    uchar   tcpurg[2];
    /* Options segment */
    uchar   tcpopt[1];
};
@

<<struct Tcp6hdr>>=
struct Tcp6hdr
{
    uchar   vcf[4];
    uchar   ploadlen[2];
    uchar   proto;
    uchar   ttl;
    ipaddr   tcpsrc;
    ipaddr   tcpdst;
    uchar   tcpsport[2];
    uchar   tcpdport[2];
    uchar   tcpseq[4];
    uchar   tcpack[4];
    uchar   tcpflag[2];
    uchar   tcpwin[2];
    uchar   tcpcksum[2];
    uchar   tcpurg[2];
    /* Options segment */
    uchar   tcpopt[1];
};
@

<<struct Tcp>>=
struct  Tcp
{
    ushort  source;
    ushort  dest;
    ulong   seq;
    ulong   ack;
    uchar   flags;
    uchar   update;
    ushort  ws; /* window scale option */
    ulong   wnd;    /* prescaled window*/
    ushort  urg;
    ushort  mss;    /* max segment size option (if not zero) */
    ushort  len;    /* size of data */
};
@

<<struct Reseq>>=
struct Reseq
{
    Reseq   *next;
    Tcp seg;
    Block   *bp;
    ushort  length;
};
@

<<struct Tcpctl>>=
struct Tcpctl
{
    uchar   state;          /* Connection state */
    uchar   type;           /* Listening or active connection */
    uchar   code;           /* Icmp code */
    struct {
        ulong   una;        /* Unacked data pointer */
        ulong   nxt;        /* Next sequence expected */
        ulong   ptr;        /* Data pointer */
        ulong   wnd;        /* Tcp send window */
        ulong   urg;        /* Urgent data pointer */
        ulong   wl2;
        uint    scale;      /* how much to right shift window */
                    /* in xmitted packets */
        /* to implement tahoe and reno TCP */
        ulong   dupacks;    /* number of duplicate acks rcvd */
        ulong   partialack;
        int recovery;   /* loss recovery flag */
        int retransmit; /* retransmit 1 packet @ una flag */
        int rto;
        ulong   rxt;        /* right window marker for recovery */
                    /* "recover" rfc3782 */
    } snd;
    struct {
        ulong   nxt;        /* Receive pointer to next uchar slot */
        ulong   wnd;        /* Receive window incoming */
        ulong   wsnt;       /* Last wptr sent.  important to */
                    /* track for large bdp */
        ulong   wptr;
        ulong   urg;        /* Urgent pointer */
        ulong   ackptr;     /* last acked sequence */
        int blocked;
        uint    scale;      /* how much to left shift window in */
                    /* rcv'd packets */
    } rcv;
    ulong   iss;            /* Initial sequence number */
    ulong   cwind;          /* Congestion window */
    ulong   abcbytes;       /* appropriate byte counting rfc 3465 */
    uint    scale;          /* desired snd.scale */
    ulong   ssthresh;       /* Slow start threshold */
    int resent;         /* Bytes just resent */
    int irs;            /* Initial received squence */
    ushort  mss;            /* Maximum segment size */
    int rerecv;         /* Overlap of data rerecevived */
    ulong   window;         /* Our receive window (queue) */
    uint    qscale;         /* Log2 of our receive window (queue) */
    uchar   backoff;        /* Exponential backoff counter */
    int backedoff;      /* ms we've backed off for rexmits */
    uchar   flags;          /* State flags */
    Reseq   *reseq;         /* Resequencing queue */
    int nreseq;
    int reseqlen;
    Tcptimer    timer;          /* Activity timer */
    Tcptimer    acktimer;       /* Acknowledge timer */
    Tcptimer    rtt_timer;      /* Round trip timer */
    Tcptimer    katimer;        /* keep alive timer */
    ulong   rttseq;         /* Round trip sequence */
    int srtt;           /* Smoothed round trip */
    int mdev;           /* Mean deviation of round trip */
    int kacounter;      /* count down for keep alive */
    uint    sndsyntime;     /* time syn sent */
    ulong   time;           /* time Finwait2 or Syn_received was sent */
    ulong   timeuna;        /* snd.una when time was set */
    int nochecksum;     /* non-zero means don't send checksums */
    int flgcnt;         /* number of flags in the sequence (FIN,SEQ) */

    union {
        Tcp4hdr tcp4hdr;
        Tcp6hdr tcp6hdr;
    } protohdr;     /* prototype header */
};
@

<<struct Limbo>>=
struct Limbo
{
    Limbo   *next;

    ipaddr   laddr;
    ipaddr   raddr;
    ushort  lport;
    ushort  rport;
    ulong   irs;        /* initial received sequence */
    ulong   iss;        /* initial sent sequence */
    ushort  mss;        /* mss from the other end */
    ushort  rcvscale;   /* how much to scale rcvd windows */
    ushort  sndscale;   /* how much to scale sent windows */
    ulong   lastsend;   /* last time we sent a synack */
    uchar   version;    /* v4 or v6 */
    uchar   rexmits;    /* number of retransmissions */
};
@

<<global tcp_irtt>>=
int tcp_irtt = DEF_RTT; /* Initial guess at round trip time */
@

<<enum _anon_ (kernel/network/ip/tcp.c)2>>=
enum {
    /* MIB stats */
    MaxConn,
    Mss,
    ActiveOpens,
    PassiveOpens,
    EstabResets,
    CurrEstab,
    InSegs,
    OutSegs,
    RetransSegs,
    RetransSegsSent,
    RetransTimeouts,
    InErrs,
    OutRsts,

    /* non-MIB stats */
    CsumErrs,
    HlenErrs,
    LenErrs,
    Resequenced,
    OutOfOrder,
    ReseqBytelim,
    ReseqPktlim,
    Delayack,
    Wopenack,

    Recovery,
    RecoveryDone,
    RecoveryRTO,
    RecoveryNoSeq,
    RecoveryCwind,
    RecoveryPA,

    Nstats
};
@

<<global statnames (kernel/network/ip/tcp.c)>>=
static char *statnames[Nstats] =
{
[MaxConn]   "MaxConn",
[Mss]       "MaxSegment",
[ActiveOpens]   "ActiveOpens",
[PassiveOpens]  "PassiveOpens",
[EstabResets]   "EstabResets",
[CurrEstab] "CurrEstab",
[InSegs]    "InSegs",
[OutSegs]   "OutSegs",
[RetransSegs]   "RetransSegs",
[RetransSegsSent]   "RetransSegsSent",
[RetransTimeouts]   "RetransTimeouts",
[InErrs]    "InErrs",
[OutRsts]   "OutRsts",
[CsumErrs]  "CsumErrs",
[HlenErrs]  "HlenErrs",
[LenErrs]   "LenErrs",
[OutOfOrder]    "OutOfOrder",
[Resequenced]   "Resequenced",
[ReseqBytelim]  "ReseqBytelim",
[ReseqPktlim]   "ReseqPktlim",
[Delayack]  "Delayack",
[Wopenack]  "Wopenack",

[Recovery]  "Recovery",
[RecoveryDone]  "RecoveryDone",
[RecoveryRTO]   "RecoveryRTO",

[RecoveryNoSeq] "RecoveryNoSeq",
[RecoveryCwind] "RecoveryCwind",
[RecoveryPA]    "RecoveryPA",
};
@

<<struct Tcppriv>>=
struct Tcppriv
{
    /* List of active timers */
    QLock   tl;
    Tcptimer *timers;

    /* hash table for matching conversations */
    Ipht    ht;

    /* calls in limbo waiting for an ACK to our SYN ACK */
    int nlimbo;
    Limbo   *lht[NLHT];

    /* for keeping track of tcpackproc */
    QLock   apl;
    int ackprocstarted;

    uvlong  stats[Nstats];
};
@

<<global tcpporthogdefense>>=
/*
 *  Setting tcpporthogdefense to non-zero enables Dong Lin's
 *  solution to hijacked systems staking out port's as a form
 *  of DoS attack.
 *
 *  To avoid stateless Conv hogs, we pick a sequence number at random.  If
 *  that number gets acked by the other end, we shut down the connection.
 *  Look for tcpporthogdefense in the code.
 */
int tcpporthogdefense = 0;
@

<<function tcpsetstate>>=
static void
tcpsetstate(Conv *s, uchar newstate)
{
    Tcpctl *tcb;
    uchar oldstate;
    Tcppriv *tpriv;

    tpriv = s->p->priv;

    tcb = (Tcpctl*)s->ptcl;

    oldstate = tcb->state;
    if(oldstate == newstate)
        return;

    if(oldstate == Established)
        tpriv->stats[CurrEstab]--;
    if(newstate == Established)
        tpriv->stats[CurrEstab]++;

    switch(newstate) {
    case Closed:
        qclose(s->rq);
        qclose(s->wq);
        qclose(s->eq);
        break;

    case Close_wait:        /* Remote closes */
        qhangup(s->rq, nil);
        break;
    }

    tcb->state = newstate;

    if(oldstate == Syn_sent && newstate != Closed)
        Fsconnected(s, nil);
}
@

<<function tcpconnect>>=
static char*
tcpconnect(Conv *c, char **argv, int argc)
{
    char *e;
    Tcpctl *tcb;

    tcb = (Tcpctl*)(c->ptcl);
    if(tcb->state != Closed)
        return Econinuse;

    e = Fsstdconnect(c, argv, argc);
    if(e != nil)
        return e;
    tcpstart(c, TCP_CONNECT);

    return nil;
}
@

<<function tcpstate>>=
static int
tcpstate(Conv *c, char *state, int n)
{
    Tcpctl *s;

    s = (Tcpctl*)(c->ptcl);

    return snprint(state, n,
        "%s qin %d qout %d rq %d.%d srtt %d mdev %d sst %lud cwin %lud "
        "swin %lud>>%d rwin %lud>>%d qscale %d timer.start %d "
        "timer.count %d rerecv %d katimer.start %d katimer.count %d\n",
        tcpstates[s->state],
        c->rq ? qlen(c->rq) : 0,
        c->wq ? qlen(c->wq) : 0,
        s->nreseq, s->reseqlen,
        s->srtt, s->mdev, s->ssthresh,
        s->cwind, s->snd.wnd, s->rcv.scale, s->rcv.wnd, s->snd.scale,
        s->qscale,
        s->timer.start, s->timer.count, s->rerecv,
        s->katimer.start, s->katimer.count);
}
@

<<function tcpinuse>>=
static int
tcpinuse(Conv *c)
{
    Tcpctl *s;

    s = (Tcpctl*)(c->ptcl);
    return s->state != Closed;
}
@

<<function tcpannounce>>=
static char*
tcpannounce(Conv *c, char **argv, int argc)
{
    char *e;
    Tcpctl *tcb;

    tcb = (Tcpctl*)(c->ptcl);
    if(tcb->state != Closed)
        return Econinuse;

    e = Fsstdannounce(c, argv, argc);
    if(e != nil)
        return e;
    tcpstart(c, TCP_LISTEN);
    Fsconnected(c, nil);

    return nil;
}
@

<<function tcpclose>>=
/*
 *  tcpclose is always called with the q locked
 */
static void
tcpclose(Conv *c)
{
    Tcpctl *tcb;

    tcb = (Tcpctl*)c->ptcl;

    qhangup(c->rq, nil);
    qhangup(c->wq, nil);
    qhangup(c->eq, nil);
    qflush(c->rq);

    switch(tcb->state) {
    case Listen:
        /*
         *  reset any incoming calls to this listener
         */
        Fsconnected(c, "Hangup");

        localclose(c, nil);
        break;
    case Closed:
    case Syn_sent:
        localclose(c, nil);
        break;
    case Syn_received:
    case Established:
        tcb->flgcnt++;
        tcb->snd.nxt++;
        tcpsetstate(c, Finwait1);
        tcpoutput(c);
        break;
    case Close_wait:
        tcb->flgcnt++;
        tcb->snd.nxt++;
        tcpsetstate(c, Last_ack);
        tcpoutput(c);
        break;
    }
}
@

<<function tcpkick>>=
static void
tcpkick(void *x)
{
    Conv *s = x;
    Tcpctl *tcb;

    tcb = (Tcpctl*)s->ptcl;

    if(waserror()){
        qunlock(s);
        nexterror();
    }
    qlock(s);

    switch(tcb->state) {
    case Syn_sent:
    case Syn_received:
    case Established:
    case Close_wait:
        /*
         * Push data
         */
        tcpoutput(s);
        break;
    default:
        localclose(s, "Hangup");
        break;
    }

    qunlock(s);
    poperror();
}
@

<<function tcprcvwin>>=
static void
tcprcvwin(Conv *s)              /* Call with tcb locked */
{
    int w;
    Tcpctl *tcb;

    tcb = (Tcpctl*)s->ptcl;
    w = tcb->window - qlen(s->rq);
    if(w < 0)
        w = 0;
    /* RFC 1122 § 4.2.2.17 do not move right edge of window left */
    if(seq_lt(tcb->rcv.nxt + w, tcb->rcv.wptr))
        w = tcb->rcv.wptr - tcb->rcv.nxt;
    if(w != tcb->rcv.wnd)
    if(w>>tcb->rcv.scale == 0 || tcb->window > 4*tcb->mss && w < tcb->mss/4){
        tcb->rcv.blocked = 1;
        netlog(s->p->f, Logtcp, "tcprcvwin: window %lud qlen %d ws %ud lport %d\n",
            tcb->window, qlen(s->rq), tcb->rcv.scale, s->lport);
    }
    tcb->rcv.wnd = w;
    tcb->rcv.wptr = tcb->rcv.nxt + w;
}
@

<<function tcpacktimer>>=
static void
tcpacktimer(void *v)
{
    Tcpctl *tcb;
    Conv *s;

    s = v;
    tcb = (Tcpctl*)s->ptcl;

    if(waserror()){
        qunlock(s);
        nexterror();
    }
    qlock(s);
    if(tcb->state != Closed){
        tcb->flags |= FORCE;
        tcpoutput(s);
    }
    qunlock(s);
    poperror();
}
@

<<function tcpcongestion>>=
static void
tcpcongestion(Tcpctl *tcb)
{
    ulong inflight;

    inflight = tcb->snd.nxt - tcb->snd.una;
    if(inflight > tcb->cwind)
        inflight = tcb->cwind;
    tcb->ssthresh = inflight / 2;
    if(tcb->ssthresh < 2*tcb->mss)
        tcb->ssthresh = 2*tcb->mss;
}
@

<<enum _anon_ (kernel/network/ip/tcp.c)3>>=
enum {
    L   = 2,    /* aggressive slow start; legal values ∈ (1.0, 2.0) */
};
@

<<function tcpabcincr>>=
static void
tcpabcincr(Tcpctl *tcb, uint acked)
{
    uint limit;

    tcb->abcbytes += acked;
    if(tcb->cwind < tcb->ssthresh){
        /* slow start */
        if(tcb->snd.rto)
            limit = tcb->mss;
        else
            limit = L*tcb->mss;
        tcb->cwind += MIN(tcb->abcbytes, limit);
        tcb->abcbytes = 0;
    } else {
        tcb->snd.rto = 0;
        /* avoidance */
        if(tcb->abcbytes >= tcb->cwind){
            tcb->abcbytes -= tcb->cwind;
            tcb->cwind += tcb->mss;
        }
    }
}
@

<<function tcpcreate>>=
static void
tcpcreate(Conv *c)
{
    c->rq = qopen(QMAX, Qcoalesce, tcpacktimer, c);
    c->wq = qopen(QMAX, Qkick, tcpkick, c);
}
@

<<function timerstate>>=
static void
timerstate(Tcppriv *priv, Tcptimer *t, int newstate)
{
    if(newstate != TcptimerON){
        if(t->state == TcptimerON){
            /* unchain */
            if(priv->timers == t){
                priv->timers = t->next;
                if(t->prev != nil)
                    panic("timerstate1");
            }
            if(t->next)
                t->next->prev = t->prev;
            if(t->prev)
                t->prev->next = t->next;
            t->next = t->prev = nil;
        }
    } else {
        if(t->state != TcptimerON){
            /* chain */
            if(t->prev != nil || t->next != nil)
                panic("timerstate2");
            t->prev = nil;
            t->next = priv->timers;
            if(t->next)
                t->next->prev = t;
            priv->timers = t;
        }
    }
    t->state = newstate;
}
@

<<function tcpackproc>>=
static void
tcpackproc(void *a)
{
    Tcptimer *t, *tp, *timeo;
    Proto *tcp;
    Tcppriv *priv;
    int loop;

    tcp = a;
    priv = tcp->priv;

    for(;;) {
        tsleep(&up->sleepr, returnfalse, 0, MSPTICK);

        qlock(&priv->tl);
        timeo = nil;
        loop = 0;
        for(t = priv->timers; t != nil; t = tp) {
            if(loop++ > 10000)
                panic("tcpackproc1");
            tp = t->next;
            if(t->state == TcptimerON) {
                t->count--;
                if(t->count == 0) {
                    timerstate(priv, t, TcptimerDONE);
                    t->readynext = timeo;
                    timeo = t;
                }
            }
        }
        qunlock(&priv->tl);

        loop = 0;
        for(t = timeo; t != nil; t = t->readynext) {
            if(loop++ > 10000)
                panic("tcpackproc2");
            if(t->state == TcptimerDONE && t->func != nil && !waserror()){
                (*t->func)(t->arg);
                poperror();
            }
        }

        limborexmit(tcp);
    }
}
@

<<function tcpgo>>=
static void
tcpgo(Tcppriv *priv, Tcptimer *t)
{
    if(t == nil || t->start == 0)
        return;

    qlock(&priv->tl);
    t->count = t->start;
    timerstate(priv, t, TcptimerON);
    qunlock(&priv->tl);
}
@

<<function tcphalt>>=
static void
tcphalt(Tcppriv *priv, Tcptimer *t)
{
    if(t == nil)
        return;

    qlock(&priv->tl);
    timerstate(priv, t, TcptimerOFF);
    qunlock(&priv->tl);
}
@

<<function backoff>>=
static int
backoff(int n)
{
    return 1 << n;
}
@

<<function localclose>>=
static void
localclose(Conv *s, char *reason)   /* called with tcb locked */
{
    Tcpctl *tcb;
    Tcppriv *tpriv;

    tpriv = s->p->priv;
    tcb = (Tcpctl*)s->ptcl;

    iphtrem(&tpriv->ht, s);

    tcphalt(tpriv, &tcb->timer);
    tcphalt(tpriv, &tcb->rtt_timer);
    tcphalt(tpriv, &tcb->acktimer);
    tcphalt(tpriv, &tcb->katimer);

    /* Flush reassembly queue; nothing more can arrive */
    dumpreseq(tcb);

    if(tcb->state == Syn_sent)
        Fsconnected(s, reason);
    if(s->state == Announced)
        wakeup(&s->listenr);

    qhangup(s->rq, reason);
    qhangup(s->wq, reason);

    tcpsetstate(s, Closed);
}
@

<<function tcpmtu>>=
/* mtu (- TCP + IP hdr len) of 1st hop */
static int
tcpmtu(Proto *tcp, uchar *addr, int version, uint *scale)
{
    Ipifc *ifc;
    int mtu;

    ifc = findipifc(tcp->f, addr, 0);
    switch(version){
    default:
    case V4:
        mtu = DEF_MSS;
        if(ifc != nil)
            mtu = ifc->maxtu - ifc->m->hsize - (TCP4_PKT + TCP4_HDRSIZE);
        break;
    case V6:
        mtu = DEF_MSS6;
        if(ifc != nil)
            mtu = ifc->maxtu - ifc->m->hsize - (TCP6_PKT + TCP6_HDRSIZE);
        break;
    }
    /*
     * set the ws.  it doesn't commit us to anything.
     * ws is the ultimate limit to the bandwidth-delay product.
     */
    *scale = Defadvscale;

    return mtu;
}
@

<<function inittcpctl>>=
static void
inittcpctl(Conv *s, int mode)
{
    Tcpctl *tcb;
    Tcp4hdr* h4;
    Tcp6hdr* h6;
    Tcppriv *tpriv;
    int mss;

    tcb = (Tcpctl*)s->ptcl;

    memset(tcb, 0, sizeof(Tcpctl));

    tcb->ssthresh = QMAX;           /* reset by tcpsetscale() */
    tcb->srtt = tcp_irtt<<LOGAGAIN;
    tcb->mdev = 0;

    /* setup timers */
    tcb->timer.start = tcp_irtt / MSPTICK;
    tcb->timer.func = tcptimeout;
    tcb->timer.arg = s;
    tcb->rtt_timer.start = MAX_TIME;
    tcb->acktimer.start = TCP_ACK / MSPTICK;
    tcb->acktimer.func = tcpacktimer;
    tcb->acktimer.arg = s;
    tcb->katimer.start = DEF_KAT / MSPTICK;
    tcb->katimer.func = tcpkeepalive;
    tcb->katimer.arg = s;

    mss = DEF_MSS;

    /* create a prototype(pseudo) header */
    if(mode != TCP_LISTEN){
        if(ipcmp(s->laddr, IPnoaddr) == 0)
            findlocalip(s->p->f, s->laddr, s->raddr);

        switch(s->ipversion){
        case V4:
            h4 = &tcb->protohdr.tcp4hdr;
            memset(h4, 0, sizeof(*h4));
            h4->proto = IP_TCPPROTO;
            hnputs(h4->tcpsport, s->lport);
            hnputs(h4->tcpdport, s->rport);
            v6tov4(h4->tcpsrc, s->laddr);
            v6tov4(h4->tcpdst, s->raddr);
            break;
        case V6:
            h6 = &tcb->protohdr.tcp6hdr;
            memset(h6, 0, sizeof(*h6));
            h6->proto = IP_TCPPROTO;
            hnputs(h6->tcpsport, s->lport);
            hnputs(h6->tcpdport, s->rport);
            ipmove(h6->tcpsrc, s->laddr);
            ipmove(h6->tcpdst, s->raddr);
            mss = DEF_MSS6;
            break;
        default:
            panic("inittcpctl: version %d", s->ipversion);
        }
    }

    tcb->mss = tcb->cwind = mss;
    tcb->abcbytes = 0;
    tpriv = s->p->priv;
    tpriv->stats[Mss] = tcb->mss;

    /* default is no window scaling */
    tcpsetscale(s, tcb, 0, 0);
}
@

<<function tcpstart>>=
/*
 *  called with s qlocked
 */
static void
tcpstart(Conv *s, int mode)
{
    Tcpctl *tcb;
    Tcppriv *tpriv;
    char kpname[KNAMELEN];

    tpriv = s->p->priv;

    if(tpriv->ackprocstarted == 0){
        qlock(&tpriv->apl);
        if(tpriv->ackprocstarted == 0){
            snprint(kpname, sizeof kpname, "#I%dtcpack", s->p->f->dev);
            kproc(kpname, tcpackproc, s->p);
            tpriv->ackprocstarted = 1;
        }
        qunlock(&tpriv->apl);
    }

    tcb = (Tcpctl*)s->ptcl;

    inittcpctl(s, mode);

    iphtadd(&tpriv->ht, s);
    switch(mode) {
    case TCP_LISTEN:
        tpriv->stats[PassiveOpens]++;
        tcb->flags |= CLONE;
        tcpsetstate(s, Listen);
        break;

    case TCP_CONNECT:
        tpriv->stats[ActiveOpens]++;
        tcb->flags |= ACTIVE;
        tcpsndsyn(s, tcb);
        tcpsetstate(s, Syn_sent);
        tcpoutput(s);
        break;
    }
}
@

<<function htontcp6>>=
//}

static Block*
htontcp6(Tcp *tcph, Block *data, Tcp6hdr *ph, Tcpctl *tcb)
{
    int dlen;
    Tcp6hdr *h;
    ushort csum;
    ushort hdrlen, optpad = 0;
    uchar *opt;

    hdrlen = TCP6_HDRSIZE;
    if(tcph->flags & SYN){
        if(tcph->mss)
            hdrlen += MSS_LENGTH;
        if(tcph->ws)
            hdrlen += WS_LENGTH;
        optpad = hdrlen & 3;
        if(optpad)
            optpad = 4 - optpad;
        hdrlen += optpad;
    }

    if(data) {
        dlen = blocklen(data);
        data = padblock(data, hdrlen + TCP6_PKT);
        if(data == nil)
            return nil;
    }
    else {
        dlen = 0;
        data = allocb(hdrlen + TCP6_PKT + 64);  /* the 64 pad is to meet mintu's */
        if(data == nil)
            return nil;
        data->wp += hdrlen + TCP6_PKT;
    }

    /* copy in pseudo ip header plus port numbers */
    h = (Tcp6hdr *)(data->rp);
    memmove(h, ph, TCP6_TCBPHDRSZ);

    /* compose pseudo tcp header, do cksum calculation */
    hnputl(h->vcf, hdrlen + dlen);
    h->ploadlen[0] = h->ploadlen[1] = h->proto = 0;
    h->ttl = ph->proto;

    /* copy in variable bits */
    hnputl(h->tcpseq, tcph->seq);
    hnputl(h->tcpack, tcph->ack);
    hnputs(h->tcpflag, (hdrlen<<10) | tcph->flags);
    hnputs(h->tcpwin, tcph->wnd>>(tcb != nil ? tcb->snd.scale : 0));
    hnputs(h->tcpurg, tcph->urg);

    if(tcph->flags & SYN){
        opt = h->tcpopt;
        if(tcph->mss != 0){
            *opt++ = MSSOPT;
            *opt++ = MSS_LENGTH;
            hnputs(opt, tcph->mss);
            opt += 2;
        }
        if(tcph->ws != 0){
            *opt++ = WSOPT;
            *opt++ = WS_LENGTH;
            *opt++ = tcph->ws;
        }
        while(optpad-- > 0)
            *opt++ = NOOPOPT;
    }

    if(tcb != nil && tcb->nochecksum){
        h->tcpcksum[0] = h->tcpcksum[1] = 0;
    } else {
        csum = ptclcsum(data, TCP6_IPLEN, hdrlen+dlen+TCP6_PHDRSIZE);
        hnputs(h->tcpcksum, csum);
    }

    /* move from pseudo header back to normal ip header */
    memset(h->vcf, 0, 4);
    h->vcf[0] = IP_VER6;
    hnputs(h->ploadlen, hdrlen+dlen);
    h->proto = ph->proto;

    return data;
}
@

<<function htontcp4>>=
static Block*
htontcp4(Tcp *tcph, Block *data, Tcp4hdr *ph, Tcpctl *tcb)
{
    int dlen;
    Tcp4hdr *h;
    ushort csum;
    ushort hdrlen, optpad = 0;
    uchar *opt;

    hdrlen = TCP4_HDRSIZE;
    if(tcph->flags & SYN){
        if(tcph->mss)
            hdrlen += MSS_LENGTH;
        if(1)
            hdrlen += WS_LENGTH;
        optpad = hdrlen & 3;
        if(optpad)
            optpad = 4 - optpad;
        hdrlen += optpad;
    }

    if(data) {
        dlen = blocklen(data);
        data = padblock(data, hdrlen + TCP4_PKT);
        if(data == nil)
            return nil;
    }
    else {
        dlen = 0;
        data = allocb(hdrlen + TCP4_PKT + 64);  /* the 64 pad is to meet mintu's */
        if(data == nil)
            return nil;
        data->wp += hdrlen + TCP4_PKT;
    }

    /* copy in pseudo ip header plus port numbers */
    h = (Tcp4hdr *)(data->rp);
    memmove(h, ph, TCP4_TCBPHDRSZ);

    /* copy in variable bits */
    hnputs(h->tcplen, hdrlen + dlen);
    hnputl(h->tcpseq, tcph->seq);
    hnputl(h->tcpack, tcph->ack);
    hnputs(h->tcpflag, (hdrlen<<10) | tcph->flags);
    hnputs(h->tcpwin, tcph->wnd>>(tcb != nil ? tcb->snd.scale : 0));
    hnputs(h->tcpurg, tcph->urg);

    if(tcph->flags & SYN){
        opt = h->tcpopt;
        if(tcph->mss != 0){
            *opt++ = MSSOPT;
            *opt++ = MSS_LENGTH;
            hnputs(opt, tcph->mss);
            opt += 2;
        }
        /* always offer.  rfc1323 §2.2 */
        if(1){
            *opt++ = WSOPT;
            *opt++ = WS_LENGTH;
            *opt++ = tcph->ws;
        }
        while(optpad-- > 0)
            *opt++ = NOOPOPT;
    }

    if(tcb != nil && tcb->nochecksum){
        h->tcpcksum[0] = h->tcpcksum[1] = 0;
    } else {
        csum = ptclcsum(data, TCP4_IPLEN, hdrlen+dlen+TCP4_PHDRSIZE);
        hnputs(h->tcpcksum, csum);
    }

    return data;
}
@

<<function ntohtcp6>>=
static int
ntohtcp6(Tcp *tcph, Block **bpp)
{
    Tcp6hdr *h;
    uchar *optr;
    ushort hdrlen;
    ushort optlen;
    int n;

    *bpp = pullupblock(*bpp, TCP6_PKT+TCP6_HDRSIZE);
    if(*bpp == nil)
        return -1;

    h = (Tcp6hdr *)((*bpp)->rp);
    tcph->source = nhgets(h->tcpsport);
    tcph->dest = nhgets(h->tcpdport);
    tcph->seq = nhgetl(h->tcpseq);
    tcph->ack = nhgetl(h->tcpack);
    hdrlen = (h->tcpflag[0]>>2) & ~3;
    if(hdrlen < TCP6_HDRSIZE) {
        freeblist(*bpp);
        return -1;
    }

    tcph->flags = h->tcpflag[1];
    tcph->wnd = nhgets(h->tcpwin);
    tcph->urg = nhgets(h->tcpurg);
    tcph->mss = 0;
    tcph->ws = 0;
    tcph->update = 0;
    tcph->len = nhgets(h->ploadlen) - hdrlen;

    *bpp = pullupblock(*bpp, hdrlen+TCP6_PKT);
    if(*bpp == nil)
        return -1;

    optr = h->tcpopt;
    n = hdrlen - TCP6_HDRSIZE;
    while(n > 0 && *optr != EOLOPT) {
        if(*optr == NOOPOPT) {
            n--;
            optr++;
            continue;
        }
        optlen = optr[1];
        if(optlen < 2 || optlen > n)
            break;
        switch(*optr) {
        case MSSOPT:
            if(optlen == MSS_LENGTH)
                tcph->mss = nhgets(optr+2);
            break;
        case WSOPT:
            if(optlen == WS_LENGTH && *(optr+2) <= 14)
                tcph->ws = *(optr+2);
            break;
        }
        n -= optlen;
        optr += optlen;
    }
    return hdrlen;
}
@

<<function ntohtcp4>>=
static int
ntohtcp4(Tcp *tcph, Block **bpp)
{
    Tcp4hdr *h;
    uchar *optr;
    ushort hdrlen;
    ushort optlen;
    int n;

    *bpp = pullupblock(*bpp, TCP4_PKT+TCP4_HDRSIZE);
    if(*bpp == nil)
        return -1;

    h = (Tcp4hdr *)((*bpp)->rp);
    tcph->source = nhgets(h->tcpsport);
    tcph->dest = nhgets(h->tcpdport);
    tcph->seq = nhgetl(h->tcpseq);
    tcph->ack = nhgetl(h->tcpack);

    hdrlen = (h->tcpflag[0]>>2) & ~3;
    if(hdrlen < TCP4_HDRSIZE) {
        freeblist(*bpp);
        return -1;
    }

    tcph->flags = h->tcpflag[1];
    tcph->wnd = nhgets(h->tcpwin);
    tcph->urg = nhgets(h->tcpurg);
    tcph->mss = 0;
    tcph->ws = 0;
    tcph->update = 0;
    tcph->len = nhgets(h->length) - (hdrlen + TCP4_PKT);

    *bpp = pullupblock(*bpp, hdrlen+TCP4_PKT);
    if(*bpp == nil)
        return -1;

    optr = h->tcpopt;
    n = hdrlen - TCP4_HDRSIZE;
    while(n > 0 && *optr != EOLOPT) {
        if(*optr == NOOPOPT) {
            n--;
            optr++;
            continue;
        }
        optlen = optr[1];
        if(optlen < 2 || optlen > n)
            break;
        switch(*optr) {
        case MSSOPT:
            if(optlen == MSS_LENGTH)
                tcph->mss = nhgets(optr+2);
            break;
        case WSOPT:
            if(optlen == WS_LENGTH && *(optr+2) <= 14)
                tcph->ws = *(optr+2);
            break;
        }
        n -= optlen;
        optr += optlen;
    }
    return hdrlen;
}
@

<<function tcpsndsyn>>=
/*
 *  For outgoing calls, generate an initial sequence
 *  number and put a SYN on the send queue
 */
static void
tcpsndsyn(Conv *s, Tcpctl *tcb)
{
    Tcppriv *tpriv;

    tcb->iss = (nrand(1<<16)<<16)|nrand(1<<16);
    tcb->rttseq = tcb->iss;
    tcb->snd.wl2 = tcb->iss;
    tcb->snd.una = tcb->iss;
    tcb->snd.rxt = tcb->iss;
    tcb->snd.ptr = tcb->rttseq;
    tcb->snd.nxt = tcb->rttseq;
    tcb->flgcnt++;
    tcb->flags |= FORCE;
    tcb->sndsyntime = NOW;

    /* set desired mss and scale */
    tcb->mss = tcpmtu(s->p, s->laddr, s->ipversion, &tcb->scale);
    tpriv = s->p->priv;
    tpriv->stats[Mss] = tcb->mss;
}
@

<<function sndrst>>=
void
sndrst(Proto *tcp, uchar *source, uchar *dest, ushort length, Tcp *seg, uchar version, char *reason)
{
    Block *hbp;
    uchar rflags;
    Tcppriv *tpriv;
    Tcp4hdr ph4;
    Tcp6hdr ph6;

    netlog(tcp->f, Logtcp, "sndrst: %s\n", reason);

    tpriv = tcp->priv;

    if(seg->flags & RST)
        return;

    /* make pseudo header */
    switch(version) {
    case V4:
        memset(&ph4, 0, sizeof(ph4));
        ph4.vihl = IP_VER4;
        v6tov4(ph4.tcpsrc, dest);
        v6tov4(ph4.tcpdst, source);
        ph4.proto = IP_TCPPROTO;
        hnputs(ph4.tcplen, TCP4_HDRSIZE);
        hnputs(ph4.tcpsport, seg->dest);
        hnputs(ph4.tcpdport, seg->source);
        break;
    case V6:
        memset(&ph6, 0, sizeof(ph6));
        ph6.vcf[0] = IP_VER6;
        ipmove(ph6.tcpsrc, dest);
        ipmove(ph6.tcpdst, source);
        ph6.proto = IP_TCPPROTO;
        hnputs(ph6.ploadlen, TCP6_HDRSIZE);
        hnputs(ph6.tcpsport, seg->dest);
        hnputs(ph6.tcpdport, seg->source);
        break;
    default:
        panic("sndrst: version %d", version);
    }

    tpriv->stats[OutRsts]++;
    rflags = RST;

    /* convince the other end that this reset is in band */
    if(seg->flags & ACK) {
        seg->seq = seg->ack;
        seg->ack = 0;
    }
    else {
        rflags |= ACK;
        seg->ack = seg->seq;
        seg->seq = 0;
        if(seg->flags & SYN)
            seg->ack++;
        seg->ack += length;
        if(seg->flags & FIN)
            seg->ack++;
    }
    seg->flags = rflags;
    seg->wnd = 0;
    seg->urg = 0;
    seg->mss = 0;
    seg->ws = 0;
    switch(version) {
    case V4:
        hbp = htontcp4(seg, nil, &ph4, nil);
        if(hbp == nil)
            return;
        ipoput4(tcp->f, hbp, 0, MAXTTL, DFLTTOS, nil);
        break;
    case V6:
        hbp = htontcp6(seg, nil, &ph6, nil);
        if(hbp == nil)
            return;
        ipoput6(tcp->f, hbp, 0, MAXTTL, DFLTTOS, nil);
        break;
    default:
        panic("sndrst2: version %d", version);
    }
}
@

<<function tcphangup>>=
/*
 *  send a reset to the remote side and close the conversation
 *  called with s qlocked
 */
static char*
tcphangup(Conv *s)
{
    Tcp seg;
    Tcpctl *tcb;
    Block *hbp;

    tcb = (Tcpctl*)s->ptcl;
    if(waserror())
        return up->errstr;
    if(ipcmp(s->raddr, IPnoaddr) != 0) {
        if(!waserror()){
            memset(&seg, 0, sizeof seg);
            seg.flags = RST | ACK;
            seg.ack = tcb->rcv.nxt;
            tcb->rcv.ackptr = seg.ack;
            seg.seq = tcb->snd.ptr;
            seg.wnd = 0;
            seg.urg = 0;
            seg.mss = 0;
            seg.ws = 0;
            switch(s->ipversion) {
            case V4:
                tcb->protohdr.tcp4hdr.vihl = IP_VER4;
                hbp = htontcp4(&seg, nil, &tcb->protohdr.tcp4hdr, tcb);
                ipoput4(s->p->f, hbp, 0, s->ttl, s->tos, s);
                break;
            case V6:
                tcb->protohdr.tcp6hdr.vcf[0] = IP_VER6;
                hbp = htontcp6(&seg, nil, &tcb->protohdr.tcp6hdr, tcb);
                ipoput6(s->p->f, hbp, 0, s->ttl, s->tos, s);
                break;
            default:
                panic("tcphangup: version %d", s->ipversion);
            }
            poperror();
        }
    }
    localclose(s, nil);
    poperror();
    return nil;
}
@

<<function sndsynack>>=
/*
 *  (re)send a SYN ACK
 */
static int
sndsynack(Proto *tcp, Limbo *lp)
{
    Block *hbp;
    Tcp4hdr ph4;
    Tcp6hdr ph6;
    Tcp seg;
    uint scale;

    /* make pseudo header */
    switch(lp->version) {
    case V4:
        memset(&ph4, 0, sizeof(ph4));
        ph4.vihl = IP_VER4;
        v6tov4(ph4.tcpsrc, lp->laddr);
        v6tov4(ph4.tcpdst, lp->raddr);
        ph4.proto = IP_TCPPROTO;
        hnputs(ph4.tcplen, TCP4_HDRSIZE);
        hnputs(ph4.tcpsport, lp->lport);
        hnputs(ph4.tcpdport, lp->rport);
        break;
    case V6:
        memset(&ph6, 0, sizeof(ph6));
        ph6.vcf[0] = IP_VER6;
        ipmove(ph6.tcpsrc, lp->laddr);
        ipmove(ph6.tcpdst, lp->raddr);
        ph6.proto = IP_TCPPROTO;
        hnputs(ph6.ploadlen, TCP6_HDRSIZE);
        hnputs(ph6.tcpsport, lp->lport);
        hnputs(ph6.tcpdport, lp->rport);
        break;
    default:
        panic("sndrst: version %d", lp->version);
    }

    memset(&seg, 0, sizeof seg);
    seg.seq = lp->iss;
    seg.ack = lp->irs+1;
    seg.flags = SYN|ACK;
    seg.urg = 0;
    seg.mss = tcpmtu(tcp, lp->laddr, lp->version, &scale);
    seg.wnd = QMAX;

    /* if the other side set scale, we should too */
    if(lp->rcvscale){
        seg.ws = scale;
        lp->sndscale = scale;
    } else {
        seg.ws = 0;
        lp->sndscale = 0;
    }

    switch(lp->version) {
    case V4:
        hbp = htontcp4(&seg, nil, &ph4, nil);
        if(hbp == nil)
            return -1;
        ipoput4(tcp->f, hbp, 0, MAXTTL, DFLTTOS, nil);
        break;
    case V6:
        hbp = htontcp6(&seg, nil, &ph6, nil);
        if(hbp == nil)
            return -1;
        ipoput6(tcp->f, hbp, 0, MAXTTL, DFLTTOS, nil);
        break;
    default:
        panic("sndsnack: version %d", lp->version);
    }
    lp->lastsend = NOW;
    return 0;
}
@

<<macro hashipa (kernel/network/ip/tcp.c)>>=
#define hashipa(a, p) ( ( (a)[IPaddrlen-2] + (a)[IPaddrlen-1] + p )&LHTMASK )
@

<<function limbo>>=
/*
 *  put a call into limbo and respond with a SYN ACK
 *
 *  called with proto locked
 */
static void
limbo(Conv *s, uchar *source, uchar *dest, Tcp *seg, int version)
{
    Limbo *lp, **l;
    Tcppriv *tpriv;
    int h;

    tpriv = s->p->priv;
    h = hashipa(source, seg->source);

    for(l = &tpriv->lht[h]; *l != nil; l = &lp->next){
        lp = *l;
        if(lp->lport != seg->dest || lp->rport != seg->source || lp->version != version)
            continue;
        if(ipcmp(lp->raddr, source) != 0)
            continue;
        if(ipcmp(lp->laddr, dest) != 0)
            continue;

        /* each new SYN restarts the retransmits */
        lp->irs = seg->seq;
        break;
    }
    lp = *l;
    if(lp == nil){
        if(tpriv->nlimbo >= Maxlimbo && tpriv->lht[h]){
            lp = tpriv->lht[h];
            tpriv->lht[h] = lp->next;
            lp->next = nil;
        } else {
            lp = malloc(sizeof(*lp));
            if(lp == nil)
                return;
            tpriv->nlimbo++;
        }
        *l = lp;
        lp->version = version;
        ipmove(lp->laddr, dest);
        ipmove(lp->raddr, source);
        lp->lport = seg->dest;
        lp->rport = seg->source;
        lp->mss = seg->mss;
        lp->rcvscale = seg->ws;
        lp->irs = seg->seq;
        lp->iss = (nrand(1<<16)<<16)|nrand(1<<16);
    }

    if(sndsynack(s->p, lp) < 0){
        *l = lp->next;
        tpriv->nlimbo--;
        free(lp);
    }
}
@

<<function limborexmit>>=
/*
 *  resend SYN ACK's once every SYNACK_RXTIMER ms.
 */
static void
limborexmit(Proto *tcp)
{
    Tcppriv *tpriv;
    Limbo **l, *lp;
    int h;
    int seen;
    ulong now;

    tpriv = tcp->priv;

    if(!canqlock(tcp))
        return;
    seen = 0;
    now = NOW;
    for(h = 0; h < NLHT && seen < tpriv->nlimbo; h++){
        for(l = &tpriv->lht[h]; *l != nil && seen < tpriv->nlimbo; ){
            lp = *l;
            seen++;
            if(now - lp->lastsend < (lp->rexmits+1)*SYNACK_RXTIMER)
                continue;

            /* time it out after 1 second */
            if(++(lp->rexmits) > 5){
                tpriv->nlimbo--;
                *l = lp->next;
                free(lp);
                continue;
            }

            /* if we're being attacked, don't bother resending SYN ACK's */
            if(tpriv->nlimbo > 100)
                continue;

            if(sndsynack(tcp, lp) < 0){
                tpriv->nlimbo--;
                *l = lp->next;
                free(lp);
                continue;
            }

            l = &lp->next;
        }
    }
    qunlock(tcp);
}
@

<<function limborst>>=
/*
 *  lookup call in limbo.  if found, throw it out.
 *
 *  called with proto locked
 */
static void
limborst(Conv *s, Tcp *segp, uchar *src, uchar *dst, uchar version)
{
    Limbo *lp, **l;
    int h;
    Tcppriv *tpriv;

    tpriv = s->p->priv;

    /* find a call in limbo */
    h = hashipa(src, segp->source);
    for(l = &tpriv->lht[h]; *l != nil; l = &lp->next){
        lp = *l;
        if(lp->lport != segp->dest || lp->rport != segp->source || lp->version != version)
            continue;
        if(ipcmp(lp->laddr, dst) != 0)
            continue;
        if(ipcmp(lp->raddr, src) != 0)
            continue;

        /* RST can only follow the SYN */
        if(segp->seq == lp->irs+1){
            tpriv->nlimbo--;
            *l = lp->next;
            free(lp);
        }
        break;
    }
}
@

<<function initialwindow>>=
static void
initialwindow(Tcpctl *tcb)
{
    /* RFC 3390 initial window */
    if(tcb->mss < 1095)
        tcb->cwind = 4*tcb->mss;
    else if(tcb->mss < 2190)
        tcb->cwind = 2*2190;
    else
        tcb->cwind = 2*tcb->mss;
}
@

<<function tcpincoming>>=
/*
 *  come here when we finally get an ACK to our SYN-ACK.
 *  lookup call in limbo.  if found, create a new conversation
 *
 *  called with proto locked
 */
static Conv*
tcpincoming(Conv *s, Tcp *segp, uchar *src, uchar *dst, uchar version)
{
    Conv *new;
    Tcpctl *tcb;
    Tcppriv *tpriv;
    Tcp4hdr *h4;
    Tcp6hdr *h6;
    Limbo *lp, **l;
    int h;

    /* unless it's just an ack, it can't be someone coming out of limbo */
    if((segp->flags & SYN) || (segp->flags & ACK) == 0)
        return nil;

    tpriv = s->p->priv;

    /* find a call in limbo */
    h = hashipa(src, segp->source);
    for(l = &tpriv->lht[h]; (lp = *l) != nil; l = &lp->next){
        netlog(s->p->f, Logtcp, "tcpincoming s %I!%ud/%I!%ud d %I!%ud/%I!%ud v %d/%d\n",
            src, segp->source, lp->raddr, lp->rport,
            dst, segp->dest, lp->laddr, lp->lport,
            version, lp->version
        );

        if(lp->lport != segp->dest || lp->rport != segp->source || lp->version != version)
            continue;
        if(ipcmp(lp->laddr, dst) != 0)
            continue;
        if(ipcmp(lp->raddr, src) != 0)
            continue;

        /* we're assuming no data with the initial SYN */
        if(segp->seq != lp->irs+1 || segp->ack != lp->iss+1){
            netlog(s->p->f, Logtcp, "tcpincoming s %lux/%lux a %lux %lux\n",
                segp->seq, lp->irs+1, segp->ack, lp->iss+1);
            lp = nil;
        } else {
            tpriv->nlimbo--;
            *l = lp->next;
        }
        break;
    }
    if(lp == nil)
        return nil;

    new = Fsnewcall(s, src, segp->source, dst, segp->dest, version);
    if(new == nil)
        return nil;

    memmove(new->ptcl, s->ptcl, sizeof(Tcpctl));
    tcb = (Tcpctl*)new->ptcl;
    tcb->flags &= ~CLONE;
    tcb->timer.arg = new;
    tcb->timer.state = TcptimerOFF;
    tcb->acktimer.arg = new;
    tcb->acktimer.state = TcptimerOFF;
    tcb->katimer.arg = new;
    tcb->katimer.state = TcptimerOFF;
    tcb->rtt_timer.arg = new;
    tcb->rtt_timer.state = TcptimerOFF;

    tcb->irs = lp->irs;
    tcb->rcv.nxt = tcb->irs+1;
    tcb->rcv.wptr = tcb->rcv.nxt;
    tcb->rcv.wsnt = 0;
    tcb->rcv.urg = tcb->rcv.nxt;

    tcb->iss = lp->iss;
    tcb->rttseq = tcb->iss;
    tcb->snd.wl2 = tcb->iss;
    tcb->snd.una = tcb->iss+1;
    tcb->snd.ptr = tcb->iss+1;
    tcb->snd.nxt = tcb->iss+1;
    tcb->snd.rxt = tcb->iss+1;
    tcb->flgcnt = 0;
    tcb->flags |= SYNACK;

    /* our sending max segment size cannot be bigger than what he asked for */
    if(lp->mss != 0 && lp->mss < tcb->mss) {
        tcb->mss = lp->mss;
        tpriv->stats[Mss] = tcb->mss;
    }

    /* window scaling */
    tcpsetscale(new, tcb, lp->rcvscale, lp->sndscale);

    /* congestion window */
    tcb->snd.wnd = segp->wnd;
    initialwindow(tcb);

    /* set initial round trip time */
    tcb->sndsyntime = lp->lastsend+lp->rexmits*SYNACK_RXTIMER;
    tcpsynackrtt(new);

    free(lp);

    /* set up proto header */
    switch(version){
    case V4:
        h4 = &tcb->protohdr.tcp4hdr;
        memset(h4, 0, sizeof(*h4));
        h4->proto = IP_TCPPROTO;
        hnputs(h4->tcpsport, new->lport);
        hnputs(h4->tcpdport, new->rport);
        v6tov4(h4->tcpsrc, dst);
        v6tov4(h4->tcpdst, src);
        break;
    case V6:
        h6 = &tcb->protohdr.tcp6hdr;
        memset(h6, 0, sizeof(*h6));
        h6->proto = IP_TCPPROTO;
        hnputs(h6->tcpsport, new->lport);
        hnputs(h6->tcpdport, new->rport);
        ipmove(h6->tcpsrc, dst);
        ipmove(h6->tcpdst, src);
        break;
    default:
        panic("tcpincoming: version %d", new->ipversion);
    }

    tcpsetstate(new, Established);

    iphtadd(&tpriv->ht, new);

    return new;
}
@

<<function seq_within>>=
static int
seq_within(ulong x, ulong low, ulong high)
{
    if(low <= high){
        if(low <= x && x <= high)
            return 1;
    }
    else {
        if(x >= low || x <= high)
            return 1;
    }
    return 0;
}
@

<<function seq_lt>>=
static int
seq_lt(ulong x, ulong y)
{
    return (int)(x-y) < 0;
}
@

<<function seq_le>>=
static int
seq_le(ulong x, ulong y)
{
    return (int)(x-y) <= 0;
}
@

<<function seq_gt>>=
static int
seq_gt(ulong x, ulong y)
{
    return (int)(x-y) > 0;
}
@

<<function seq_ge>>=
static int
seq_ge(ulong x, ulong y)
{
    return (int)(x-y) >= 0;
}
@

<<function tcpsynackrtt>>=
/*
 *  use the time between the first SYN and it's ack as the
 *  initial round trip time
 */
static void
tcpsynackrtt(Conv *s)
{
    Tcpctl *tcb;
    int delta;
    Tcppriv *tpriv;

    tcb = (Tcpctl*)s->ptcl;
    tpriv = s->p->priv;

    delta = NOW - tcb->sndsyntime;
    tcb->srtt = delta<<LOGAGAIN;
    tcb->mdev = delta<<LOGDGAIN;

    /* halt round trip timer */
    tcphalt(tpriv, &tcb->rtt_timer);
}
@

<<function update>>=
static void
update(Conv *s, Tcp *seg)
{
    int rtt, delta;
    Tcpctl *tcb;
    ulong acked;
    Tcppriv *tpriv;

    if(seg->update)
        return;
    seg->update = 1;

    tpriv = s->p->priv;
    tcb = (Tcpctl*)s->ptcl;

    /* catch zero-window updates, update window & recover */
    if(tcb->snd.wnd == 0 && seg->wnd > 0 &&
        seq_lt(seg->ack, tcb->snd.ptr)){
        netlog(s->p->f, Logtcp, "tcp: zwu ack %lud una %lud ptr %lud win %lud\n",
            seg->ack,  tcb->snd.una, tcb->snd.ptr, seg->wnd);
        tcb->snd.wnd = seg->wnd;
        goto recovery;
    }

    /* newreno fast retransmit */
    if(seg->ack == tcb->snd.una && tcb->snd.una != tcb->snd.nxt &&
        ++tcb->snd.dupacks == 3){       /* was TCPREXMTTHRESH */
recovery:
        if(tcb->snd.recovery){
            tpriv->stats[RecoveryCwind]++;
            tcb->cwind += tcb->mss;
        }else if(seq_le(tcb->snd.rxt, seg->ack)){
            tpriv->stats[Recovery]++;
            tcb->abcbytes = 0;
            tcb->snd.recovery = 1;
            tcb->snd.partialack = 0;
            tcb->snd.rxt = tcb->snd.nxt;
            tcpcongestion(tcb);
            tcb->cwind = tcb->ssthresh + 3*tcb->mss;
            netlog(s->p->f, Logtcpwin, "recovery inflate %ld ss %ld @%lud\n",
                tcb->cwind, tcb->ssthresh, tcb->snd.rxt);
            tcprxmit(s);
        }else{
            tpriv->stats[RecoveryNoSeq]++;
            netlog(s->p->f, Logtcpwin, "!recov %lud not ≤ %lud %ld\n",
                tcb->snd.rxt, seg->ack, tcb->snd.rxt - seg->ack);
            /* don't enter fast retransmit, don't change ssthresh */
        }
    }else if(tcb->snd.recovery){
        tpriv->stats[RecoveryCwind]++;
        tcb->cwind += tcb->mss;
    }

    /*
     *  update window
     */
    if(seq_gt(seg->ack, tcb->snd.wl2)
    || (tcb->snd.wl2 == seg->ack && seg->wnd > tcb->snd.wnd)){
        /* clear dupack if we advance wl2 */
        if(tcb->snd.wl2 != seg->ack)
            tcb->snd.dupacks = 0;
        tcb->snd.wnd = seg->wnd;
        tcb->snd.wl2 = seg->ack;
    }

    if(!seq_gt(seg->ack, tcb->snd.una)){
        /*
         *  don't let us hangup if sending into a closed window and
         *  we're still getting acks
         */
        if((tcb->flags&RETRAN) && tcb->snd.wnd == 0)
            tcb->backedoff = MAXBACKMS/4;
        return;
    }

    /* Compute the new send window size */
    acked = seg->ack - tcb->snd.una;

    /* avoid slow start and timers for SYN acks */
    if((tcb->flags & SYNACK) == 0) {
        tcb->flags |= SYNACK;
        acked--;
        tcb->flgcnt--;
        goto done;
    }

    /*
     * congestion control
     */
    if(tcb->snd.recovery){
        if(seq_ge(seg->ack, tcb->snd.rxt)){
            /* recovery finished; deflate window */
            tpriv->stats[RecoveryDone]++;
            tcb->snd.dupacks = 0;
            tcb->snd.recovery = 0;
            tcb->cwind = (tcb->snd.nxt - tcb->snd.una) + tcb->mss;
            if(tcb->ssthresh < tcb->cwind)
                tcb->cwind = tcb->ssthresh;
            netlog(s->p->f, Logtcpwin, "recovery deflate %ld %ld\n",
                tcb->cwind, tcb->ssthresh);
        } else {
            /* partial ack; we lost more than one segment */
            tpriv->stats[RecoveryPA]++;
            if(tcb->cwind > acked)
                tcb->cwind -= acked;
            else{
                netlog(s->p->f, Logtcpwin, "partial ack neg\n");
                tcb->cwind = tcb->mss;
            }
            netlog(s->p->f, Logtcpwin, "partial ack %ld left %ld cwind %ld\n",
                acked, tcb->snd.rxt - seg->ack, tcb->cwind);

            if(acked >= tcb->mss)
                tcb->cwind += tcb->mss;
            tcb->snd.partialack++;
        }
    } else
        tcpabcincr(tcb, acked);

    /* Adjust the timers according to the round trip time */
    /* TODO: fix sloppy treatment of overflow cases here. */
    if(tcb->rtt_timer.state == TcptimerON && seq_ge(seg->ack, tcb->rttseq)) {
        tcphalt(tpriv, &tcb->rtt_timer);
        if((tcb->flags&RETRAN) == 0) {
            tcb->backoff = 0;
            tcb->backedoff = 0;
            rtt = tcb->rtt_timer.start - tcb->rtt_timer.count;
            if(rtt == 0)
                rtt = 1; /* else all close sys's will rexmit in 0 time */
            rtt *= MSPTICK;
            if(tcb->srtt == 0) {
                tcb->srtt = rtt << LOGAGAIN;
                tcb->mdev = rtt << LOGDGAIN;
            } else {
                delta = rtt - (tcb->srtt>>LOGAGAIN);
                tcb->srtt += delta;
                if(tcb->srtt <= 0)
                    tcb->srtt = 1;

                delta = abs(delta) - (tcb->mdev>>LOGDGAIN);
                tcb->mdev += delta;
                if(tcb->mdev <= 0)
                    tcb->mdev = 1;
            }
            tcpsettimer(tcb);
        }
    }

done:
    if(qdiscard(s->wq, acked) < acked)
        tcb->flgcnt--;
    tcb->snd.una = seg->ack;

    /* newreno fast recovery */
    if(tcb->snd.recovery)
        tcprxmit(s);

    if(seq_gt(seg->ack, tcb->snd.urg))
        tcb->snd.urg = seg->ack;

    if(tcb->snd.una != tcb->snd.nxt){
        /* `impatient' variant */
        if(!tcb->snd.recovery || tcb->snd.partialack == 1){
            tcb->time = NOW;
            tcb->timeuna = tcb->snd.una;
            tcpgo(tpriv, &tcb->timer);
        }
    } else
        tcphalt(tpriv, &tcb->timer);

    if(seq_lt(tcb->snd.ptr, tcb->snd.una))
        tcb->snd.ptr = tcb->snd.una;

    if(!tcb->snd.recovery)
        tcb->flags &= ~RETRAN;
    tcb->backoff = 0;
    tcb->backedoff = 0;
}
@

<<function tcpiput>>=
static void
tcpiput(Proto *tcp, Ipifc*, Block *bp)
{
    Tcp seg;
    Tcp4hdr *h4;
    Tcp6hdr *h6;
    int hdrlen;
    Tcpctl *tcb;
    ushort length, csum;
    ipaddr source, dest;
    Conv *s;
    Fs *f;
    Tcppriv *tpriv;
    uchar version;

    f = tcp->f;
    tpriv = tcp->priv;

    tpriv->stats[InSegs]++;

    h4 = (Tcp4hdr*)(bp->rp);
    h6 = (Tcp6hdr*)(bp->rp);

    if((h4->vihl&0xF0)==IP_VER4) {
        version = V4;
        length = nhgets(h4->length);
        v4tov6(dest, h4->tcpdst);
        v4tov6(source, h4->tcpsrc);

        h4->Unused = 0;
        hnputs(h4->tcplen, length-TCP4_PKT);
        if(!(bp->flag & Btcpck) && (h4->tcpcksum[0] || h4->tcpcksum[1]) &&
            ptclcsum(bp, TCP4_IPLEN, length-TCP4_IPLEN)) {
            tpriv->stats[CsumErrs]++;
            tpriv->stats[InErrs]++;
            netlog(f, Logtcp, "bad tcp proto cksum\n");
            freeblist(bp);
            return;
        }

        hdrlen = ntohtcp4(&seg, &bp);
        if(hdrlen < 0){
            tpriv->stats[HlenErrs]++;
            tpriv->stats[InErrs]++;
            netlog(f, Logtcp, "bad tcp hdr len\n");
            return;
        }

        /* trim the packet to the size claimed by the datagram */
        length -= hdrlen+TCP4_PKT;
        bp = trimblock(bp, hdrlen+TCP4_PKT, length);
        if(bp == nil){
            tpriv->stats[LenErrs]++;
            tpriv->stats[InErrs]++;
            netlog(f, Logtcp, "tcp len < 0 after trim\n");
            return;
        }
    }
    else {
        int ttl = h6->ttl;
        int proto = h6->proto;

        version = V6;
        length = nhgets(h6->ploadlen);
        ipmove(dest, h6->tcpdst);
        ipmove(source, h6->tcpsrc);

        h6->ploadlen[0] = h6->ploadlen[1] = h6->proto = 0;
        h6->ttl = proto;
        hnputl(h6->vcf, length);
        if((h6->tcpcksum[0] || h6->tcpcksum[1]) &&
            (csum = ptclcsum(bp, TCP6_IPLEN, length+TCP6_PHDRSIZE)) != 0) {
            tpriv->stats[CsumErrs]++;
            tpriv->stats[InErrs]++;
            netlog(f, Logtcp,
                "bad tcpv6 proto cksum: got %#ux, computed %#ux\n",
                h6->tcpcksum[0]<<8 | h6->tcpcksum[1], csum);
            freeblist(bp);
            return;
        }
        h6->ttl = ttl;
        h6->proto = proto;
        hnputs(h6->ploadlen, length);

        hdrlen = ntohtcp6(&seg, &bp);
        if(hdrlen < 0){
            tpriv->stats[HlenErrs]++;
            tpriv->stats[InErrs]++;
            netlog(f, Logtcp, "bad tcpv6 hdr len\n");
            return;
        }

        /* trim the packet to the size claimed by the datagram */
        length -= hdrlen;
        bp = trimblock(bp, hdrlen+TCP6_PKT, length);
        if(bp == nil){
            tpriv->stats[LenErrs]++;
            tpriv->stats[InErrs]++;
            netlog(f, Logtcp, "tcpv6 len < 0 after trim\n");
            return;
        }
    }

    /* lock protocol while searching for a conversation */
    qlock(tcp);

    /* Look for a matching conversation */
    s = iphtlook(&tpriv->ht, source, seg.source, dest, seg.dest);
    if(s == nil){
        netlog(f, Logtcp, "iphtlook(src %I!%d, dst %I!%d) failed\n",
            source, seg.source, dest, seg.dest);
reset:
        qunlock(tcp);
        sndrst(tcp, source, dest, length, &seg, version, "no conversation");
        freeblist(bp);
        return;
    }

    /* if it's a listener, look for the right flags and get a new conv */
    tcb = (Tcpctl*)s->ptcl;
    if(tcb->state == Listen){
        if(seg.flags & RST){
            limborst(s, &seg, source, dest, version);
            qunlock(tcp);
            freeblist(bp);
            return;
        }

        /* if this is a new SYN, put the call into limbo */
        if((seg.flags & SYN) && (seg.flags & ACK) == 0){
            limbo(s, source, dest, &seg, version);
            qunlock(tcp);
            freeblist(bp);
            return;
        }

        /*
         *  if there's a matching call in limbo, tcpincoming will
         *  return it in state Syn_received
         */
        s = tcpincoming(s, &seg, source, dest, version);
        if(s == nil)
            goto reset;
    }

    /* The rest of the input state machine is run with the control block
     * locked and implements the state machine directly out of the RFC.
     * Out-of-band data is ignored - it was always a bad idea.
     */
    tcb = (Tcpctl*)s->ptcl;
    if(waserror()){
        qunlock(s);
        nexterror();
    }
    qlock(s);
    qunlock(tcp);

    /* fix up window */
    seg.wnd <<= tcb->rcv.scale;

    /* every input packet in puts off the keep alive time out */
    tcpsetkacounter(tcb);

    switch(tcb->state) {
    case Closed:
        sndrst(tcp, source, dest, length, &seg, version, "sending to Closed");
        goto raise;
    case Syn_sent:
        if(seg.flags & ACK) {
            if(!seq_within(seg.ack, tcb->iss+1, tcb->snd.nxt)) {
                sndrst(tcp, source, dest, length, &seg, version,
                     "bad seq in Syn_sent");
                goto raise;
            }
        }
        if(seg.flags & RST) {
            if(seg.flags & ACK)
                localclose(s, Econrefused);
            goto raise;
        }

        if(seg.flags & SYN) {
            procsyn(s, &seg);
            if(seg.flags & ACK){
                update(s, &seg);
                tcpsynackrtt(s);
                tcpsetstate(s, Established);
                tcpsetscale(s, tcb, seg.ws, tcb->scale);
            }
            else {
                tcb->time = NOW;
                tcpsetstate(s, Syn_received);   /* DLP - shouldn't this be a reset? */
            }

            if(length != 0 || (seg.flags & FIN))
                break;

            freeblist(bp);
            goto output;
        }
        else
            freeblist(bp);

        qunlock(s);
        poperror();
        return;
    case Syn_received:
        /* doesn't matter if it's the correct ack, we're just trying to set timing */
        if(seg.flags & ACK)
            tcpsynackrtt(s);
        break;
    }

    /*
     *  One DOS attack is to open connections to us and then forget about them,
     *  thereby tying up a conv at no long term cost to the attacker.
     *  This is an attempt to defeat these stateless DOS attacks.  See
     *  corresponding code in tcpsendka().
     */
    if(tcb->state != Syn_received && (seg.flags & RST) == 0){
        if(tcpporthogdefense
        && seq_within(seg.ack, tcb->snd.una-(1<<31), tcb->snd.una-(1<<29))){
            print("stateless hog %I.%d->%I.%d f %ux %lux - %lux - %lux\n",
                source, seg.source, dest, seg.dest, seg.flags,
                tcb->snd.una-(1<<31), seg.ack, tcb->snd.una-(1<<29));
            localclose(s, "stateless hog");
        }
    }

    /* Cut the data to fit the receive window */
    tcprcvwin(s);
    if(tcptrim(tcb, &seg, &bp, &length) == -1) {
        if(seg.seq+1 != tcb->rcv.nxt || length != 1)
        netlog(f, Logtcp, "tcp: trim: !inwind: seq %lud-%lud win "
            "%lud-%lud l %d from %I\n", seg.seq,
            seg.seq + length - 1, tcb->rcv.nxt,
            tcb->rcv.nxt + tcb->rcv.wnd-1, length, s->raddr);
        update(s, &seg);
        if(qlen(s->wq)+tcb->flgcnt == 0 && tcb->state == Closing) {
            tcphalt(tpriv, &tcb->rtt_timer);
            tcphalt(tpriv, &tcb->acktimer);
            tcphalt(tpriv, &tcb->katimer);
            tcpsetstate(s, Time_wait);
            tcb->timer.start = MSL2*(1000 / MSPTICK);
            tcpgo(tpriv, &tcb->timer);
        }
        if(!(seg.flags & RST)) {
            tcb->flags |= FORCE;
            goto output;
        }
        qunlock(s);
        poperror();
        return;
    }

    /* Cannot accept so answer with a rst */
    if(length && tcb->state == Closed) {
        sndrst(tcp, source, dest, length, &seg, version, "sending to Closed");
        goto raise;
    }

    /* The segment is beyond the current receive pointer so
     * queue the data in the resequence queue
     */
    if(seg.seq != tcb->rcv.nxt)
    if(length != 0 || (seg.flags & (SYN|FIN))) {
        update(s, &seg);
        if(addreseq(f, tcb, tpriv, &seg, bp, length) < 0)
            print("reseq %I.%d -> %I.%d\n", s->raddr, s->rport,
                s->laddr, s->lport);
        tcb->flags |= FORCE;    /* force duplicate ack; RFC 5681 §3.2 */
        goto output;
    }

    if(tcb->nreseq > 0)
        tcb->flags |= FORCE; /* filled hole in seq. space; RFC 5681 §3.2 */

    /*
     *  keep looping till we've processed this packet plus any
     *  adjacent packets in the resequence queue
     */
    for(;;) {
        if(seg.flags & RST) {
            if(tcb->state == Established) {
                tpriv->stats[EstabResets]++;
                if(tcb->rcv.nxt != seg.seq)
                    print("out of order RST rcvd: %I.%d -> "
                        "%I.%d, rcv.nxt %lux seq %lux\n",
                        s->raddr, s->rport, s->laddr,
                        s->lport, tcb->rcv.nxt, seg.seq);
            }
            localclose(s, Econrefused);
            goto raise;
        }

        if((seg.flags&ACK) == 0)
            goto raise;

        switch(tcb->state) {
        case Syn_received:
            if(!seq_within(seg.ack, tcb->snd.una+1, tcb->snd.nxt)){
                sndrst(tcp, source, dest, length, &seg, version,
                    "bad seq in Syn_received");
                goto raise;
            }
            update(s, &seg);
            tcpsetstate(s, Established);
        case Established:
        case Close_wait:
            update(s, &seg);
            break;
        case Finwait1:
            update(s, &seg);
            if(qlen(s->wq)+tcb->flgcnt == 0){
                tcphalt(tpriv, &tcb->rtt_timer);
                tcphalt(tpriv, &tcb->acktimer);
                tcpsetkacounter(tcb);
                tcb->time = NOW;
                tcpsetstate(s, Finwait2);
                tcb->katimer.start = MSL2 * (1000 / MSPTICK);
                tcpgo(tpriv, &tcb->katimer);
            }
            break;
        case Finwait2:
            update(s, &seg);
            break;
        case Closing:
            update(s, &seg);
            if(qlen(s->wq)+tcb->flgcnt == 0) {
                tcphalt(tpriv, &tcb->rtt_timer);
                tcphalt(tpriv, &tcb->acktimer);
                tcphalt(tpriv, &tcb->katimer);
                tcpsetstate(s, Time_wait);
                tcb->timer.start = MSL2*(1000 / MSPTICK);
                tcpgo(tpriv, &tcb->timer);
            }
            break;
        case Last_ack:
            update(s, &seg);
            if(qlen(s->wq)+tcb->flgcnt == 0) {
                localclose(s, nil);
                goto raise;
            }
        case Time_wait:
            tcb->flags |= FORCE;
            if(tcb->timer.state != TcptimerON)
                tcpgo(tpriv, &tcb->timer);
        }

        if((seg.flags&URG) && seg.urg) {
            if(seq_gt(seg.urg + seg.seq, tcb->rcv.urg)) {
                tcb->rcv.urg = seg.urg + seg.seq;
                pullblock(&bp, seg.urg);
            }
        }
        else
        if(seq_gt(tcb->rcv.nxt, tcb->rcv.urg))
            tcb->rcv.urg = tcb->rcv.nxt;

        if(length == 0) {
            if(bp != nil)
                freeblist(bp);
        }
        else {
            switch(tcb->state){
            default:
                /* Ignore segment text */
                if(bp != nil)
                    freeblist(bp);
                break;

            case Syn_received:
            case Established:
            case Finwait1:
                /* If we still have some data place on
                 * receive queue
                 */
                if(bp) {
                    bp = packblock(bp);
                    if(bp == nil)
                        panic("tcp packblock");
                    qpassnolim(s->rq, bp);
                    bp = nil;
                }
                tcb->rcv.nxt += length;

                /*
                 *  turn on the acktimer if there's something
                 *  to ack
                 */
                if(tcb->acktimer.state != TcptimerON)
                    tcpgo(tpriv, &tcb->acktimer);

                break;
            case Finwait2:
                /* no process to read the data, send a reset */
                if(bp != nil)
                    freeblist(bp);
                sndrst(tcp, source, dest, length, &seg, version,
                    "send to Finwait2");
                qunlock(s);
                poperror();
                return;
            }
        }

        if(seg.flags & FIN) {
            tcb->flags |= FORCE;

            switch(tcb->state) {
            case Syn_received:
            case Established:
                tcb->rcv.nxt++;
                tcpsetstate(s, Close_wait);
                break;
            case Finwait1:
                tcb->rcv.nxt++;
                if(qlen(s->wq)+tcb->flgcnt == 0) {
                    tcphalt(tpriv, &tcb->rtt_timer);
                    tcphalt(tpriv, &tcb->acktimer);
                    tcphalt(tpriv, &tcb->katimer);
                    tcpsetstate(s, Time_wait);
                    tcb->timer.start = MSL2*(1000/MSPTICK);
                    tcpgo(tpriv, &tcb->timer);
                }
                else
                    tcpsetstate(s, Closing);
                break;
            case Finwait2:
                tcb->rcv.nxt++;
                tcphalt(tpriv, &tcb->rtt_timer);
                tcphalt(tpriv, &tcb->acktimer);
                tcphalt(tpriv, &tcb->katimer);
                tcpsetstate(s, Time_wait);
                tcb->timer.start = MSL2 * (1000/MSPTICK);
                tcpgo(tpriv, &tcb->timer);
                break;
            case Close_wait:
            case Closing:
            case Last_ack:
                break;
            case Time_wait:
                tcpgo(tpriv, &tcb->timer);
                break;
            }
        }

        /*
         *  get next adjacent segment from the resequence queue.
         *  dump/trim any overlapping segments
         */
        for(;;) {
            if(tcb->reseq == nil)
                goto output;

            if(seq_ge(tcb->rcv.nxt, tcb->reseq->seg.seq) == 0)
                goto output;

            getreseq(tcb, &seg, &bp, &length);

            tcprcvwin(s);
            if(tcptrim(tcb, &seg, &bp, &length) == 0){
                tcb->flags |= FORCE;
                break;
            }
        }
    }
output:
    tcpoutput(s);
    qunlock(s);
    poperror();
    return;
raise:
    qunlock(s);
    poperror();
    freeblist(bp);
    tcpkick(s);
}
@

<<function tcpoutput>>=
/*
 *  always enters and exits with the s locked.  We drop
 *  the lock to ipoput the packet so some care has to be
 *  taken by callers.
 */
static void
tcpoutput(Conv *s)
{
    Tcp seg;
    uint msgs;
    Tcpctl *tcb;
    Block *hbp, *bp;
    int sndcnt;
    ulong ssize, dsize, sent;
    Fs *f;
    Tcppriv *tpriv;
    uchar version;

    f = s->p->f;
    tpriv = s->p->priv;
    version = s->ipversion;

    tcb = (Tcpctl*)s->ptcl;

    /* force ack every 2*mss */
    if((tcb->flags & FORCE) == 0 &&
        tcb->rcv.nxt - tcb->rcv.ackptr >= 2*tcb->mss){
        tpriv->stats[Delayack]++;
        tcb->flags |= FORCE;
    }

    /* force ack if window opening */
    if((tcb->flags & FORCE) == 0){
        tcprcvwin(s);
        if((int)(tcb->rcv.wptr - tcb->rcv.wsnt) >= 2*tcb->mss){
            tpriv->stats[Wopenack]++;
            tcb->flags |= FORCE;
        }
    }

    for(msgs = 0; msgs < 100; msgs++) {
        switch(tcb->state) {
        case Listen:
        case Closed:
        case Finwait2:
            return;
        }

        /* Don't send anything else until our SYN has been acked */
        if(tcb->snd.ptr != tcb->iss && (tcb->flags & SYNACK) == 0)
            break;

        /* force an ack when a window has opened up */
        tcprcvwin(s);
        if(tcb->rcv.blocked && tcb->rcv.wnd > 0){
            tcb->rcv.blocked = 0;
            tcb->flags |= FORCE;
        }

        sndcnt = qlen(s->wq)+tcb->flgcnt;
        sent = tcb->snd.ptr - tcb->snd.una;
        ssize = sndcnt;
        if(tcb->snd.wnd == 0){
            /* zero window probe */
            if(sent > 0 && !(tcb->flags & FORCE))
                break;  /* already probing, rto re-probes */
            if(ssize < sent)
                ssize = 0;
            else{
                ssize -= sent;
                if(ssize > 0)
                    ssize = 1;
            }
        } else {
            /* calculate usable segment size */
            if(ssize > tcb->cwind)
                ssize = tcb->cwind;
            if(ssize > tcb->snd.wnd)
                ssize = tcb->snd.wnd;

            if(ssize < sent)
                ssize = 0;
            else {
                ssize -= sent;
                if(ssize > tcb->mss)
                    ssize = tcb->mss;
            }
        }

        dsize = ssize;
        seg.urg = 0;

        if(!(tcb->flags & FORCE))
            if(ssize == 0 ||
                ssize < tcb->mss && tcb->snd.nxt == tcb->snd.ptr &&
                sent > TCPREXMTTHRESH * tcb->mss)
                break;

        tcb->flags &= ~FORCE;

        /* By default we will generate an ack */
        tcphalt(tpriv, &tcb->acktimer);
        seg.source = s->lport;
        seg.dest = s->rport;
        seg.flags = ACK;
        seg.mss = 0;
        seg.ws = 0;
        seg.update = 0;
        switch(tcb->state){
        case Syn_sent:
            seg.flags = 0;
            if(tcb->snd.ptr == tcb->iss){
                seg.flags |= SYN;
                dsize--;
                seg.mss = tcb->mss;
                seg.ws = tcb->scale;
            }
            break;
        case Syn_received:
            /*
             *  don't send any data with a SYN/ACK packet
             *  because Linux rejects the packet in its
             *  attempt to solve the SYN attack problem
             */
            if(tcb->snd.ptr == tcb->iss){
                seg.flags |= SYN;
                dsize = 0;
                ssize = 1;
                seg.mss = tcb->mss;
                seg.ws = tcb->scale;
            }
            break;
        }
        seg.seq = tcb->snd.ptr;
        seg.ack = tcb->rcv.nxt;
        seg.wnd = tcb->rcv.wnd;

        /* Pull out data to send */
        bp = nil;
        if(dsize != 0) {
            bp = qcopy(s->wq, dsize, sent);
            if(BLEN(bp) != dsize) {
                seg.flags |= FIN;
                dsize--;
            }
        }

        if(sent+dsize == sndcnt && dsize)
            seg.flags |= PSH;

        tcb->snd.ptr += ssize;

        /* Pull up the send pointer so we can accept acks
         * for this window
         */
        if(seq_gt(tcb->snd.ptr,tcb->snd.nxt))
            tcb->snd.nxt = tcb->snd.ptr;

        /* Build header, link data and compute cksum */
        switch(version){
        case V4:
            tcb->protohdr.tcp4hdr.vihl = IP_VER4;
            hbp = htontcp4(&seg, bp, &tcb->protohdr.tcp4hdr, tcb);
            if(hbp == nil) {
                freeblist(bp);
                return;
            }
            break;
        case V6:
            tcb->protohdr.tcp6hdr.vcf[0] = IP_VER6;
            hbp = htontcp6(&seg, bp, &tcb->protohdr.tcp6hdr, tcb);
            if(hbp == nil) {
                freeblist(bp);
                return;
            }
            break;
        default:
            hbp = nil;  /* to suppress a warning */
            panic("tcpoutput: version %d", version);
        }

        /* Start the transmission timers if there is new data and we
         * expect acknowledges
         */
        if(ssize != 0){
            if(tcb->timer.state != TcptimerON){
                tcb->time = NOW;
                tcb->timeuna = tcb->snd.una;
                tcpgo(tpriv, &tcb->timer);
            }

            /*  If round trip timer isn't running, start it.
             *  measure the longest packet only in case the
             *  transmission time dominates RTT
             */
            if(tcb->snd.retransmit == 0)
            if(tcb->rtt_timer.state != TcptimerON)
            if(ssize == tcb->mss) {
                tcpgo(tpriv, &tcb->rtt_timer);
                tcb->rttseq = tcb->snd.ptr;
            }
        }

        tpriv->stats[OutSegs]++;
        if(tcb->snd.retransmit)
            tpriv->stats[RetransSegsSent]++;
        tcb->rcv.ackptr = seg.ack;
        tcb->rcv.wsnt = tcb->rcv.wptr;

        /* put off the next keep alive */
        tcpgo(tpriv, &tcb->katimer);

        switch(version){
        case V4:
            if(ipoput4(f, hbp, 0, s->ttl, s->tos, s) < 0){
                /* a negative return means no route */
                localclose(s, "no route");
            }
            break;
        case V6:
            if(ipoput6(f, hbp, 0, s->ttl, s->tos, s) < 0){
                /* a negative return means no route */
                localclose(s, "no route");
            }
            break;
        default:
            panic("tcpoutput2: version %d", version);
        }
        if((msgs%4) == 3){
            qunlock(s);
            qlock(s);
        }
    }
}
@

<<function tcpsendka>>=
/*
 *  the BSD convention (hack?) for keep alives.  resend last uchar acked.
 */
static void
tcpsendka(Conv *s)
{
    Tcp seg;
    Tcpctl *tcb;
    Block *hbp,*dbp;

    tcb = (Tcpctl*)s->ptcl;

    dbp = nil;
    memset(&seg, 0, sizeof seg);
    seg.urg = 0;
    seg.source = s->lport;
    seg.dest = s->rport;
    seg.flags = ACK|PSH;
    seg.mss = 0;
    seg.ws = 0;
    if(tcpporthogdefense)
        seg.seq = tcb->snd.una-(1<<30)-nrand(1<<20);
    else
        seg.seq = tcb->snd.una-1;
    seg.ack = tcb->rcv.nxt;
    tcb->rcv.ackptr = seg.ack;
    tcprcvwin(s);
    seg.wnd = tcb->rcv.wnd;
    if(tcb->state == Finwait2){
        seg.flags |= FIN;
    } else {
        dbp = allocb(1);
        dbp->wp++;
    }

    if(isv4(s->raddr)) {
        /* Build header, link data and compute cksum */
        tcb->protohdr.tcp4hdr.vihl = IP_VER4;
        hbp = htontcp4(&seg, dbp, &tcb->protohdr.tcp4hdr, tcb);
        if(hbp == nil) {
            freeblist(dbp);
            return;
        }
        ipoput4(s->p->f, hbp, 0, s->ttl, s->tos, s);
    }
    else {
        /* Build header, link data and compute cksum */
        tcb->protohdr.tcp6hdr.vcf[0] = IP_VER6;
        hbp = htontcp6(&seg, dbp, &tcb->protohdr.tcp6hdr, tcb);
        if(hbp == nil) {
            freeblist(dbp);
            return;
        }
        ipoput6(s->p->f, hbp, 0, s->ttl, s->tos, s);
    }
}
@

<<function tcpsetkacounter>>=
/*
 *  set connection to time out after 12 minutes
 */
static void
tcpsetkacounter(Tcpctl *tcb)
{
    tcb->kacounter = (12 * 60 * 1000) / (tcb->katimer.start*MSPTICK);
    if(tcb->kacounter < 3)
        tcb->kacounter = 3;
}
@

<<function tcpkeepalive>>=
/*
 *  if we've timed out, close the connection
 *  otherwise, send a keepalive and restart the timer
 */
static void
tcpkeepalive(void *v)
{
    Tcpctl *tcb;
    Conv *s;

    s = v;
    tcb = (Tcpctl*)s->ptcl;
    if(waserror()){
        qunlock(s);
        nexterror();
    }
    qlock(s);
    if(tcb->state != Closed){
        if(--(tcb->kacounter) <= 0) {
            localclose(s, Etimedout);
        } else {
            tcpsendka(s);
            tcpgo(s->p->priv, &tcb->katimer);
        }
    }
    qunlock(s);
    poperror();
}
@

<<function tcpstartka>>=
/*
 *  start keepalive timer
 */
static char*
tcpstartka(Conv *s, char **f, int n)
{
    Tcpctl *tcb;
    int x;

    tcb = (Tcpctl*)s->ptcl;
    if(tcb->state != Established)
        return "connection must be in Establised state";
    if(n > 1){
        x = atoi(f[1]);
        if(x >= MSPTICK)
            tcb->katimer.start = x/MSPTICK;
    }
    tcpsetkacounter(tcb);
    tcpgo(s->p->priv, &tcb->katimer);

    return nil;
}
@

<<function tcpsetchecksum>>=
/*
 *  turn checksums on/off
 */
static char*
tcpsetchecksum(Conv *s, char **f, int)
{
    Tcpctl *tcb;

    tcb = (Tcpctl*)s->ptcl;
    tcb->nochecksum = !atoi(f[1]);

    return nil;
}
@

<<function tcprxmit>>=
/*
 *  retransmit (at most) one segment at snd.una.
 *  preserve cwind & snd.ptr
 */
static void
tcprxmit(Conv *s)
{
    Tcpctl *tcb;
    Tcppriv *tpriv;
    ulong tcwind, tptr;

    tcb = (Tcpctl*)s->ptcl;
    tcb->flags |= RETRAN|FORCE;

    tptr = tcb->snd.ptr;
    tcwind = tcb->cwind;
    tcb->snd.ptr = tcb->snd.una;
    tcb->cwind = tcb->mss;
    tcb->snd.retransmit = 1;
    tcpoutput(s);
    tcb->snd.retransmit = 0;
    tcb->cwind = tcwind;
    tcb->snd.ptr = tptr;

    tpriv = s->p->priv;
    tpriv->stats[RetransSegs]++;
}
@

<<function tcptimeout>>=
/*
 *  TODO: RFC 4138 F-RTO
 */
static void
tcptimeout(void *arg)
{
    Conv *s;
    Tcpctl *tcb;
    int maxback;
    Tcppriv *tpriv;

    s = (Conv*)arg;
    tpriv = s->p->priv;
    tcb = (Tcpctl*)s->ptcl;

    if(waserror()){
        qunlock(s);
        nexterror();
    }
    qlock(s);
    switch(tcb->state){
    default:
        tcb->backoff++;
        if(tcb->state == Syn_sent)
            maxback = MAXBACKMS/2;
        else
            maxback = MAXBACKMS;
        tcb->backedoff += tcb->timer.start * MSPTICK;
        if(tcb->backedoff >= maxback) {
            localclose(s, Etimedout);
            break;
        }
        netlog(s->p->f, Logtcprxmt, "rxm %d/%d %ldms %lud rto %d %lud %s\n",
            tcb->srtt, tcb->mdev, NOW - tcb->time,
            tcb->snd.una - tcb->timeuna, tcb->snd.rto, tcb->snd.ptr,
            tcpstates[s->state]);
        tcpsettimer(tcb);
        if(tcb->snd.rto == 0)
            tcpcongestion(tcb);
        tcprxmit(s);
        tcb->snd.ptr = tcb->snd.una;
        tcb->cwind = tcb->mss;
        tcb->snd.rto = 1;
        tpriv->stats[RetransTimeouts]++;

        if(tcb->snd.recovery){
            tcb->snd.dupacks = 0;       /* reno rto */
            tcb->snd.recovery = 0;
            tpriv->stats[RecoveryRTO]++;
            tcb->snd.rxt = tcb->snd.nxt;
            netlog(s->p->f, Logtcpwin,
                "rto recovery rxt @%lud\n", tcb->snd.nxt);
        }

        tcb->abcbytes = 0;
        break;
    case Time_wait:
        localclose(s, nil);
        break;
    case Closed:
        break;
    }
    qunlock(s);
    poperror();
}
@

<<function inwindow>>=
static int
inwindow(Tcpctl *tcb, int seq)
{
    return seq_within(seq, tcb->rcv.nxt, tcb->rcv.nxt+tcb->rcv.wnd-1);
}
@

<<function procsyn>>=
/*
 *  set up state for a received SYN (or SYN ACK) packet
 */
static void
procsyn(Conv *s, Tcp *seg)
{
    Tcpctl *tcb;
    Tcppriv *tpriv;

    tcb = (Tcpctl*)s->ptcl;
    tcb->flags |= FORCE;

    tcb->rcv.nxt = seg->seq + 1;
    tcb->rcv.wptr = tcb->rcv.nxt;
    tcb->rcv.wsnt = 0;
    tcb->rcv.urg = tcb->rcv.nxt;
    tcb->irs = seg->seq;

    /* our sending max segment size cannot be bigger than what he asked for */
    if(seg->mss != 0 && seg->mss < tcb->mss) {
        tcb->mss = seg->mss;
        tpriv = s->p->priv;
        tpriv->stats[Mss] = tcb->mss;
    }

    tcb->snd.wnd = seg->wnd;
    initialwindow(tcb);
}
@

<<function dumpreseq>>=
static int
dumpreseq(Tcpctl *tcb)
{
    Reseq *r, *next;

    for(r = tcb->reseq; r != nil; r = next){
        next = r->next;
        freeblist(r->bp);
        free(r);
    }
    tcb->reseq = nil;
    tcb->nreseq = 0;
    tcb->reseqlen = 0;
    return -1;
}
@

<<function logreseq>>=
static void
logreseq(Fs *f, Reseq *r, ulong n)
{
    char *s;

    for(; r != nil; r = r->next){
        s = nil;
        if(r->next == nil && r->seg.seq != n)
            s = "hole/end";
        else if(r->next == nil)
            s = "end";
        else if(r->seg.seq != n)
            s = "hole";
        if(s != nil)
            netlog(f, Logtcp, "%s %lud-%lud (%ld) %#ux\n", s,
                n, r->seg.seq, r->seg.seq - n, r->seg.flags);
        n = r->seg.seq + r->seg.len;
    }
}
@

<<function addreseq>>=
static int
addreseq(Fs *f, Tcpctl *tcb, Tcppriv *tpriv, Tcp *seg, Block *bp, ushort length)
{
    Reseq *rp, **rr;
    int qmax;

    rp = malloc(sizeof *rp);
    if(rp == nil){
        freeblist(bp);      /* bp always consumed by addreseq */
        return 0;
    }

    rp->seg = *seg;
    rp->bp = bp;
    rp->length = length;

    tcb->reseqlen += length;
    tcb->nreseq++;

    /* Place on reassembly list sorting by starting seq number */
    for(rr = &tcb->reseq; ; rr = &(*rr)->next)
        if(*rr == nil || seq_lt(seg->seq, (*rr)->seg.seq)){
            rp->next = *rr;
            *rr = rp;
            tpriv->stats[Resequenced]++;
            if(rp->next != nil)
                tpriv->stats[OutOfOrder]++;
            break;
        }

    qmax = tcb->window;
    if(tcb->reseqlen > qmax){
        netlog(f, Logtcp, "tcp: reseq: queue > window: %d > %d; %d packets\n",
            tcb->reseqlen, qmax, tcb->nreseq);
        logreseq(f, tcb->reseq, tcb->rcv.nxt);
        tpriv->stats[ReseqBytelim]++;
        return dumpreseq(tcb);
    }
    qmax = tcb->window / tcb->mss; /* ~190 for qscale=2, 390 for qscale=3 */
    if(tcb->nreseq > qmax){
        netlog(f, Logtcp, "resequence queue > packets: %d %d; %d bytes\n",
            tcb->nreseq, qmax, tcb->reseqlen);
        logreseq(f, tcb->reseq, tcb->rcv.nxt);
        tpriv->stats[ReseqPktlim]++;
        return dumpreseq(tcb);
    }
    return 0;
}
@

<<function getreseq>>=
static void
getreseq(Tcpctl *tcb, Tcp *seg, Block **bp, ushort *length)
{
    Reseq *rp;

    rp = tcb->reseq;
    if(rp == nil)
        return;

    tcb->reseq = rp->next;

    *seg = rp->seg;
    *bp = rp->bp;
    *length = rp->length;

    tcb->nreseq--;
    tcb->reseqlen -= rp->length;

    free(rp);
}
@

<<function tcptrim>>=
static int
tcptrim(Tcpctl *tcb, Tcp *seg, Block **bp, ushort *length)
{
    ushort len;
    uchar accept;
    int dupcnt, excess;

    accept = 0;
    len = *length;
    if(seg->flags & SYN)
        len++;
    if(seg->flags & FIN)
        len++;

    if(tcb->rcv.wnd == 0) {
        if(len == 0 && seg->seq == tcb->rcv.nxt)
            return 0;
    }
    else {
        /* Some part of the segment should be in the window */
        if(inwindow(tcb,seg->seq))
            accept++;
        else
        if(len != 0) {
            if(inwindow(tcb, seg->seq+len-1) ||
            seq_within(tcb->rcv.nxt, seg->seq,seg->seq+len-1))
                accept++;
        }
    }
    if(!accept) {
        freeblist(*bp);
        return -1;
    }
    dupcnt = tcb->rcv.nxt - seg->seq;
    if(dupcnt > 0){
        tcb->rerecv += dupcnt;
        if(seg->flags & SYN){
            seg->flags &= ~SYN;
            seg->seq++;

            if(seg->urg > 1)
                seg->urg--;
            else
                seg->flags &= ~URG;
            dupcnt--;
        }
        if(dupcnt > 0){
            pullblock(bp, (ushort)dupcnt);
            seg->seq += dupcnt;
            *length -= dupcnt;

            if(seg->urg > dupcnt)
                seg->urg -= dupcnt;
            else {
                seg->flags &= ~URG;
                seg->urg = 0;
            }
        }
    }
    excess = seg->seq + *length - (tcb->rcv.nxt + tcb->rcv.wnd);
    if(excess > 0) {
        tcb->rerecv += excess;
        *length -= excess;
        *bp = trimblock(*bp, 0, *length);
        if(*bp == nil)
            panic("presotto is a boofhead");
        seg->flags &= ~FIN;
    }
    return 0;
}
@

<<function tcpadvise>>=
static void
tcpadvise(Proto *tcp, Block *bp, char *msg)
{
    Tcp4hdr *h4;
    Tcp6hdr *h6;
    Tcpctl *tcb;
    ipaddr source, dest;
    ushort psource, pdest;
    Conv *s, **p;

    h4 = (Tcp4hdr*)(bp->rp);
    h6 = (Tcp6hdr*)(bp->rp);

    if((h4->vihl&0xF0)==IP_VER4) {
        v4tov6(dest, h4->tcpdst);
        v4tov6(source, h4->tcpsrc);
        psource = nhgets(h4->tcpsport);
        pdest = nhgets(h4->tcpdport);
    }
    else {
        ipmove(dest, h6->tcpdst);
        ipmove(source, h6->tcpsrc);
        psource = nhgets(h6->tcpsport);
        pdest = nhgets(h6->tcpdport);
    }

    /* Look for a connection */
    qlock(tcp);
    for(p = tcp->conv; *p; p++) {
        s = *p;
        tcb = (Tcpctl*)s->ptcl;
        if(s->rport == pdest)
        if(s->lport == psource)
        if(tcb->state != Closed)
        if(ipcmp(s->raddr, dest) == 0)
        if(ipcmp(s->laddr, source) == 0){
            qlock(s);
            qunlock(tcp);
            switch(tcb->state){
            case Syn_sent:
                localclose(s, msg);
                break;
            }
            qunlock(s);
            freeblist(bp);
            return;
        }
    }
    qunlock(tcp);
    freeblist(bp);
}
@

<<function tcpporthogdefensectl>>=
static char*
tcpporthogdefensectl(char *val)
{
    if(strcmp(val, "on") == 0)
        tcpporthogdefense = 1;
    else if(strcmp(val, "off") == 0)
        tcpporthogdefense = 0;
    else
        return "unknown value for tcpporthogdefense";
    return nil;
}
@

<<function tcpctl>>=
/* called with c qlocked */
static char*
tcpctl(Conv* c, char** f, int n)
{
    if(n == 1 && strcmp(f[0], "hangup") == 0)
        return tcphangup(c);
    if(n >= 1 && strcmp(f[0], "keepalive") == 0)
        return tcpstartka(c, f, n);
    if(n >= 1 && strcmp(f[0], "checksum") == 0)
        return tcpsetchecksum(c, f, n);
    if(n >= 1 && strcmp(f[0], "tcpporthogdefense") == 0)
        return tcpporthogdefensectl(f[1]);
    return "unknown control request";
}
@

<<function tcpstats>>=
static int
tcpstats(Proto *tcp, char *buf, int len)
{
    Tcppriv *priv;
    char *p, *e;
    int i;

    priv = tcp->priv;
    p = buf;
    e = p+len;
    for(i = 0; i < Nstats; i++)
        p = seprint(p, e, "%s: %llud\n", statnames[i], priv->stats[i]);
    return p - buf;
}
@

<<function tcpgc>>=
/*
 *  garbage collect any stale conversations:
 *  - SYN received but no SYN-ACK after 5 seconds (could be the SYN attack)
 *  - Finwait2 after 5 minutes
 *
 *  this is called whenever we run out of channels.  Both checks are
 *  of questionable validity so we try to use them only when we're
 *  up against the wall.
 */
static int
tcpgc(Proto *tcp)
{
    Conv *c, **pp, **ep;
    int n;
    Tcpctl *tcb;


    n = 0;
    ep = &tcp->conv[tcp->nc];
    for(pp = tcp->conv; pp < ep; pp++) {
        c = *pp;
        if(c == nil)
            break;
        if(!canqlock(c))
            continue;
        tcb = (Tcpctl*)c->ptcl;
        switch(tcb->state){
        case Syn_received:
            if(NOW - tcb->time > 5000){
                localclose(c, Etimedout);
                n++;
            }
            break;
        case Finwait2:
            if(NOW - tcb->time > 5*60*1000){
                localclose(c, Etimedout);
                n++;
            }
            break;
        }
        qunlock(c);
    }
    return n;
}
@

<<function tcpsettimer>>=
static void
tcpsettimer(Tcpctl *tcb)
{
    int x;

    /* round trip dependency */
    x = backoff(tcb->backoff) *
        (tcb->mdev + (tcb->srtt>>LOGAGAIN) + MSPTICK) / MSPTICK;

    /* bounded twixt 0.3 and 64 seconds */
    if(x < 300/MSPTICK)
        x = 300/MSPTICK;
    else if(x > (64000/MSPTICK))
        x = 64000/MSPTICK;
    tcb->timer.start = x;
}
@


<<function tcpsetscale>>=
static void
tcpsetscale(Conv *s, Tcpctl *tcb, ushort rcvscale, ushort sndscale)
{
    /*
     * guess at reasonable queue sizes.  there's no current way
     * to know how many nic receive buffers we can safely tie up in the
     * tcp stack, and we don't adjust our queues to maximize throughput
     * and minimize bufferbloat.  n.b. the offer (rcvscale) needs to be
     * respected, but we still control our own buffer commitment by
     * keeping a seperate qscale.
     */
    tcb->rcv.scale = rcvscale & 0xff;
    tcb->snd.scale = sndscale & 0xff;
    tcb->qscale = rcvscale & 0xff;
    if(rcvscale > Maxqscale)
        tcb->qscale = Maxqscale;

    if(rcvscale != tcb->rcv.scale)
        netlog(s->p->f, Logtcp, "tcpsetscale: window %lud "
            "qlen %d >> window %ud lport %d\n",
            tcb->window, qlen(s->rq), QMAX<<tcb->qscale, s->lport);
    tcb->window = QMAX << tcb->qscale;
    tcb->ssthresh = tcb->window;

    /*
     * it's important to set wq large enough to cover the full
     * bandwidth-delay product.  it's possible to be in loss
     * recovery with a big window, and we need to keep sending
     * into the inflated window.  the difference can be huge
     * for even modest (70ms) ping times.
     */
    qsetlimit(s->rq, tcb->window);
    qsetlimit(s->wq, tcb->window);
    tcprcvwin(s);
}
@
% >> >> >>


%-------------------------------------------------------------

<<kernel/network/ip/tcp.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "../port/error.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"

#include    "ip.h"

typedef struct Tcptimer Tcptimer;
typedef struct Tcp4hdr Tcp4hdr;
typedef struct Tcp6hdr Tcp6hdr;
typedef struct Tcp Tcp;
typedef struct Reseq Reseq;
typedef struct Tcpctl Tcpctl;
typedef struct Limbo Limbo;
typedef struct Tcppriv Tcppriv;

<<enum _anon_ (kernel/network/ip/tcp.c)>>

<<global tcpstates>>

<<struct Tcptimer>>

/*
 *  v4 and v6 pseudo headers used for
 *  checksuming tcp
 */
<<struct Tcp4hdr>>

<<struct Tcp6hdr>>

/*
 *  this represents the control info
 *  for a single packet.  It is derived from
 *  a packet in ntohtcp{4,6}() and stuck into
 *  a packet in htontcp{4,6}().
 */
<<struct Tcp>>

/*
 *  this header is malloc'd to thread together fragments
 *  waiting to be coalesced
 */
<<struct Reseq>>

/*
 *  the qlock in the Conv locks this structure
 */
<<struct Tcpctl>>

/*
 *  New calls are put in limbo rather than having a conversation structure
 *  allocated.  Thus, a SYN attack results in lots of limbo'd calls but not
 *  any real Conv structures mucking things up.  Calls in limbo rexmit their
 *  SYN ACK every SYNACK_RXTIMER ms up to 4 times, i.e., they disappear after 1 second.
 *
 *  In particular they aren't on a listener's queue so that they don't figure
 *  in the input queue limit.
 *
 *  If 1/2 of a T3 was attacking SYN packets, we'ld have a permanent queue
 *  of 70000 limbo'd calls.  Not great for a linear list but doable.  Therefore
 *  there is no hashing of this list.
 */
<<struct Limbo>>

<<global tcp_irtt>>

<<enum _anon_ (kernel/network/ip/tcp.c)2>>

<<global statnames (kernel/network/ip/tcp.c)>>

<<struct Tcppriv>>

<<global tcpporthogdefense>>

static  int addreseq(Fs*, Tcpctl*, Tcppriv*, Tcp*, Block*, ushort);
static  int dumpreseq(Tcpctl*);
static  void    getreseq(Tcpctl*, Tcp*, Block**, ushort*);
static  void    limbo(Conv*, uchar*, uchar*, Tcp*, int);
static  void    limborexmit(Proto*);
static  void    localclose(Conv*, char*);
static  void    procsyn(Conv*, Tcp*);
static  void    tcpacktimer(void*);
static  void    tcpiput(Proto*, Ipifc*, Block*);
static  void    tcpkeepalive(void*);
static  void    tcpoutput(Conv*);
static  void    tcprcvwin(Conv*);
static  void    tcprxmit(Conv*);
static  void    tcpsetkacounter(Tcpctl*);
static  void    tcpsetscale(Conv*, Tcpctl*, ushort, ushort);
static  void    tcpsettimer(Tcpctl*);
static  void    tcpsndsyn(Conv*, Tcpctl*);
static  void    tcpstart(Conv*, int);
static  void    tcpsynackrtt(Conv*);
static  void    tcptimeout(void*);
static  int tcptrim(Tcpctl*, Tcp*, Block**, ushort*);

<<function tcpsetstate>>

<<function tcpconnect>>

<<function tcpstate>>

<<function tcpinuse>>

<<function tcpannounce>>

<<function tcpclose>>

<<function tcpkick>>

static int seq_lt(ulong, ulong);

<<function tcprcvwin>>

<<function tcpacktimer>>

<<function tcpcongestion>>

<<enum _anon_ (kernel/network/ip/tcp.c)3>>

<<function tcpabcincr>>

<<function tcpcreate>>

<<function timerstate>>

<<function tcpackproc>>

<<function tcpgo>>

<<function tcphalt>>

<<function backoff>>

<<function localclose>>

<<function tcpmtu>>

<<function inittcpctl>>

<<function tcpstart>>

//static char*
//tcpflag(char *buf, char *e, ushort flag)
//{
//  char *p;
//
//  p = seprint(buf, e, "%d", flag>>10);    /* Head len */
//  if(flag & URG)
//      p = seprint(p, e, " URG");
//  if(flag & ACK)
//      p = seprint(p, e, " ACK");
//  if(flag & PSH)
//      p = seprint(p, e, " PSH");
//  if(flag & RST)
//      p = seprint(p, e, " RST");
//  if(flag & SYN)
//      p = seprint(p, e, " SYN");
//  if(flag & FIN)
//      p = seprint(p, e, " FIN");
//  USED(p);
//  return buf;
<<function htontcp6>>

<<function htontcp4>>

<<function ntohtcp6>>

<<function ntohtcp4>>

<<function tcpsndsyn>>

<<function sndrst>>

<<function tcphangup>>

<<function sndsynack>>

<<macro hashipa (kernel/network/ip/tcp.c)>>

<<function limbo>>

<<function limborexmit>>

<<function limborst>>

<<function initialwindow>>

<<function tcpincoming>>

<<function seq_within>>

<<function seq_lt>>

<<function seq_le>>

<<function seq_gt>>

<<function seq_ge>>

<<function tcpsynackrtt>>

<<function update>>

<<function tcpiput>>

<<function tcpoutput>>

<<function tcpsendka>>

<<function tcpsetkacounter>>

<<function tcpkeepalive>>

<<function tcpstartka>>

<<function tcpsetchecksum>>

<<function tcprxmit>>

<<function tcptimeout>>

<<function inwindow>>

<<function procsyn>>

<<function dumpreseq>>

<<function logreseq>>

<<function addreseq>>

<<function getreseq>>

<<function tcptrim>>

<<function tcpadvise>>

<<function tcpporthogdefensectl>>

<<function tcpctl>>

<<function tcpstats>>

<<function tcpgc>>

<<function tcpsettimer>>

<<function tcpinit>>

<<function tcpsetscale>>
@


%\subsection*{[[kernel/network/ip/inferno.c]]}
%
%
%
%%-------------------------------------------------------------
%
%<<kernel/network/ip/inferno.c>>=
%#include    "u.h"
%#include    "../port/lib.h"
%#include    "mem.h"
%#include    "dat.h"
%#include    "fns.h"
%#include    "../port/error.h"
%
%@
%<<function bootpread>>



