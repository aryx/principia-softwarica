\section{[[networking/ip/]]}

\subsection*{[[networking/ip/ping.c]]}

<<enum [[_anon_ (networking/ip/ping.c)]]>>=
enum {
    MAXMSG		= 32,
    SLEEPMS		= 1000,

    SECOND		= 1000000000LL,
    MINUTE		= 60*SECOND,
};
@

<<struct [[Req]]>>=
struct Req
{
    ushort	seq;	/* sequence number */
    vlong	time;	/* time sent */
    vlong	rtt;
    int	ttl;
    int	replied;
    Req	 *next;
};
@

<<global [[first]]>>=
Req	*first;		/* request list */
@

<<global [[last]]>>=
Req	*last;		/* ... */
@

<<global [[listlock]]>>=
Lock	listlock;
@

<<global [[argv0]]>>=
char *argv0;
@

<<global [[addresses]]>>=
int addresses;
@

<<global [[debug]]>>=
int debug;
@

<<global [[done]]>>=
int done;
@

<<global [[flood]]>>=
int flood;
@

<<global [[lostmsgs]]>>=
int lostmsgs;
@

<<global [[lostonly]]>>=
int lostonly;
@

<<global [[quiet]]>>=
int quiet;
@

<<global [[rcvdmsgs]]>>=
int rcvdmsgs;
@

<<global [[rint]]>>=
int rint;
@

<<global [[firstseq]]>>=
ushort firstseq;
@

<<global [[sum]]>>=
vlong sum;
@

<<global [[waittime]]>>=
int waittime = 5000;
@

<<function [[usage]]>>=
static void
usage(void)
{
    fprint(2,
        "usage: %s [-6alq] [-s msgsize] [-i millisecs] [-n #pings] dest\n",
        argv0);
    exits("usage");
}
@

<<function [[catch]]>>=
static void
catch(void *a, char *msg)
{
    USED(a);
    if(strstr(msg, "alarm"))
        noted(NCONT);
    else if(strstr(msg, "die"))
        exits("errors");
    else
        noted(NDFLT);
}
@

<<function [[prlost4]]>>=
static void
prlost4(ushort seq, void *v)
{
    Ip4hdr *ip4 = v;

    print("lost %ud: %V -> %V\n", seq, ip4->src, ip4->dst);
}
@

<<function [[prlost6]]>>=
static void
prlost6(ushort seq, void *v)
{
    Ip6hdr *ip6 = v;

    print("lost %ud: %I -> %I\n", seq, ip6->src, ip6->dst);
}
@

<<function [[prreply4]]>>=
static void
prreply4(Req *r, void *v)
{
    Ip4hdr *ip4 = v;

    print("%ud: %V -> %V rtt %lld µs, avg rtt %lld µs, ttl = %d\n",
        r->seq - firstseq, ip4->src, ip4->dst, r->rtt, sum/rcvdmsgs,
        r->ttl);
}
@

<<function [[prreply6]]>>=
static void
prreply6(Req *r, void *v)
{
    Ip6hdr *ip6 = v;

    print("%ud: %I -> %I rtt %lld µs, avg rtt %lld µs, ttl = %d\n",
        r->seq - firstseq, ip6->src, ip6->dst, r->rtt, sum/rcvdmsgs,
        r->ttl);
}
@

<<global [[v4pr]]>>=
static Proto v4pr = {
    4,		"icmp",
    EchoRequest,	EchoReply,
    IPV4HDR_LEN,
    prreply4,	prlost4,
};
@

<<global [[v6pr]]>>=
static Proto v6pr = {
    6,		"icmpv6",
    EchoRequestV6,	EchoReplyV6,
    IPV6HDR_LEN,
    prreply6,	prlost6,
};
@

<<global [[proto]]>>=
static Proto *proto = &v4pr;
@

<<function [[geticmp]]>>=
Icmphdr *
geticmp(void *v)
{
    char *p = v;

    return (Icmphdr *)(p + proto->iphdrsz);
}
@

<<function [[clean]]>>=
void
clean(ushort seq, vlong now, void *v)
{
    int ttl;
    Req **l, *r;

    ttl = 0;
    if (v) {
        if (proto->version == 4)
            ttl = ((Ip4hdr *)v)->ttl;
        else
            ttl = ((Ip6hdr *)v)->ttl;
    }
    lock(&listlock);
    last = nil;
    for(l = &first; *l; ){
        r = *l;

        if(v && r->seq == seq){
            r->rtt = now-r->time;
            r->ttl = ttl;
            reply(r, v);
        }

        if(now-r->time > MINUTE){
            *l = r->next;
            r->rtt = now-r->time;
            if(v)
                r->ttl = ttl;
            if(r->replied == 0)
                lost(r, v);
            free(r);
        }else{
            last = r;
            l = &r->next;
        }
    }
    unlock(&listlock);
}
@

<<global [[loopbacknet]]([[(networking/ip/ping.c)]])>>=
static uchar loopbacknet[IPaddrlen] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,
    127, 0, 0, 0
};
@

<<global [[loopbackmask]]([[(networking/ip/ping.c)]])>>=
static uchar loopbackmask[IPaddrlen] = {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0, 0, 0
};
@

<<function [[myipvnaddr]]>>=
/*
 * find first ip addr suitable for proto and
 * that isn't the friggin loopback address.
 * deprecate link-local and multicast addresses.
 */
static int
myipvnaddr(uchar *ip, Proto *proto, char *net)
{
    int ipisv4, wantv4;
    Ipifc *nifc;
    Iplifc *lifc;
    uchar mynet[IPaddrlen], linklocal[IPaddrlen];
    static Ipifc *ifc;

    ipmove(linklocal, IPnoaddr);
    wantv4 = proto->version == 4;
    ifc = readipifc(net, ifc, -1);
    for(nifc = ifc; nifc; nifc = nifc->next)
        for(lifc = nifc->lifc; lifc; lifc = lifc->next){
            maskip(lifc->ip, loopbackmask, mynet);
            if(ipcmp(mynet, loopbacknet) == 0)
                continue;
            if(ISIPV6MCAST(lifc->ip) || ISIPV6LINKLOCAL(lifc->ip)) {
                ipmove(linklocal, lifc->ip);
                continue;
            }
            ipisv4 = isv4(lifc->ip) != 0;
            if(ipcmp(lifc->ip, IPnoaddr) != 0 && wantv4 == ipisv4){
                ipmove(ip, lifc->ip);
                return 0;
            }
        }
    /* no global unicast addrs found, fall back to link-local, if any */
    ipmove(ip, linklocal);
    return ipcmp(ip, IPnoaddr) == 0? -1: 0;
}
@

<<function [[sender]]>>=
void
sender(int fd, int msglen, int interval, int n)
{
    int i, extra;
    ushort seq;
    char buf[64*1024+512];
    uchar me[IPaddrlen], mev4[IPv4addrlen];
    Icmphdr *icmp;
    Req *r;

    srand(time(0));
    firstseq = seq = rand();

    icmp = geticmp(buf);
    memset(buf, 0, proto->iphdrsz + ICMP_HDRSIZE);
    for(i = proto->iphdrsz + ICMP_HDRSIZE; i < msglen; i++)
        buf[i] = i;
    icmp->type = proto->echocmd;
    icmp->code = 0;

    /* arguably the kernel should fill in the right src addr. */
    myipvnaddr(me, proto, network);
    if (proto->version == 4) {
        v6tov4(mev4, me);
        memmove(((Ip4hdr *)buf)->src, mev4, IPv4addrlen);
    } else
        ipmove(((Ip6hdr *)buf)->src, me);
    if (addresses)
        print("\t%I -> %s\n", me, target);

    if(rint != 0 && interval <= 0)
        rint = 0;
    extra = 0;
    for(i = 0; i < n; i++){
        if(i != 0){
            if(rint != 0)
                extra = nrand(interval);
            sleep(interval + extra);
        }
        r = malloc(sizeof *r);
        if (r == nil)
            continue;
        hnputs(icmp->seq, seq);
        r->seq = seq;
        r->next = nil;
        r->replied = 0;
        r->time = nsec();	/* avoid early free in reply! */
        lock(&listlock);
        if(first == nil)
            first = r;
        else
            last->next = r;
        last = r;
        unlock(&listlock);
        r->time = nsec();
        if(write(fd, buf, msglen) < msglen){
            fprint(2, "%s: write failed: %r\n", argv0);
            return;
        }
        seq++;
    }
    done = 1;
}
@

<<function [[rcvr]]>>=
void
rcvr(int fd, int msglen, int interval, int nmsg)
{
    int i, n, munged;
    ushort x;
    vlong now;
    uchar buf[64*1024+512];
    Icmphdr *icmp;
    Req *r;

    sum = 0;
    while(lostmsgs+rcvdmsgs < nmsg){
        alarm((nmsg-lostmsgs-rcvdmsgs)*interval+waittime);
        n = read(fd, buf, sizeof buf);
        alarm(0);
        now = nsec();
        if(n <= 0){	/* read interrupted - time to go */
            clean(0, now+MINUTE, nil);
            continue;
        }
        if(n < msglen){
            print("bad len %d/%d\n", n, msglen);
            continue;
        }
        icmp = geticmp(buf);
        munged = 0;
        for(i = proto->iphdrsz + ICMP_HDRSIZE; i < msglen; i++)
            if(buf[i] != (uchar)i)
                munged++;
        if(munged)
            print("corrupted reply\n");
        x = nhgets(icmp->seq);
        if(icmp->type != proto->echoreply || icmp->code != 0) {
            print("bad type/code/sequence %d/%d/%d (want %d/%d/%d)\n",
                icmp->type, icmp->code, x,
                proto->echoreply, 0, x);
            continue;
        }
        clean(x, now, buf);
    }

    lock(&listlock);
    for(r = first; r; r = r->next)
        if(r->replied == 0)
            lostmsgs++;
    unlock(&listlock);

    if(!quiet && lostmsgs)
        print("%d out of %d messages lost\n", lostmsgs,
            lostmsgs+rcvdmsgs);
}
@

<<function [[isdottedquad]]>>=
static int
isdottedquad(char *name)
{
    int dot = 0, digit = 0;

    for (; *name != '\0'; name++)
        if (*name == '.')
            dot++;
        else if (isdigit(*name))
            digit++;
        else
            return 0;
    return dot && digit;
}
@

<<function [[isv6lit]]>>=
static int
isv6lit(char *name)
{
    int colon = 0, hex = 0;

    for (; *name != '\0'; name++)
        if (*name == ':')
            colon++;
        else if (isxdigit(*name))
            hex++;
        else
            return 0;
    return colon;
}
@

<<enum [[_anon_ (networking/ip/ping.c)2]]>>=
/* from /sys/src/libc/9sys/dial.c */

enum
{
    Maxstring	= 128,
    Maxpath		= 256,
};
@

<<struct [[DS]]>>=
struct DS {
    /* dist string */
    char	buf[Maxstring];
    char	*netdir;
    char	*proto;
    char	*rem;

    /* other args */
    char	*local;
    char	*dir;
    int	*cfdp;
};
@

<<function [[_dial_string_parse]]>>=
/*
 *  parse a dial string
 */
static void
_dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-1] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "net";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/' && *ds->buf != '#'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            for(p2 = p; *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
}
@

<<function [[isv4name]]>>=
/* side effect: sets network & target */
static int
isv4name(char *name)
{
    int r = 1;
    char *root, *ip, *pr;
    DS ds;

    _dial_string_parse(name, &ds);

    /* cope with leading /net.alt/icmp! and the like */
    root = nil;
    if (ds.netdir != nil) {
        pr = strrchr(ds.netdir, '/');
        if (pr == nil)
            pr = ds.netdir;
        else {
            *pr++ = '\0';
            root = ds.netdir;
            network = strdup(root);
        }
        if (strcmp(pr, v4pr.net) == 0)
            return 1;
        if (strcmp(pr, v6pr.net) == 0)
            return 0;
    }

    /* if it's a literal, it's obvious from syntax which proto it is */
    free(target);
    target = strdup(ds.rem);
    if (isdottedquad(ds.rem))
        return 1;
    else if (isv6lit(ds.rem))
        return 0;

    /* map name to ip and look at its syntax */
    ip = csgetvalue(root, "sys", ds.rem, "ip", nil);
    if (ip == nil)
        ip = csgetvalue(root, "dom", ds.rem, "ip", nil);
    if (ip == nil)
        ip = csgetvalue(root, "sys", ds.rem, "ipv6", nil);
    if (ip == nil)
        ip = csgetvalue(root, "dom", ds.rem, "ipv6", nil);
    if (ip != nil)
        r = isv4name(ip);
    free(ip);
    return r;
}
@

<<function [[main]]([[(networking/ip/ping.c)]])>>=
void
main(int argc, char **argv)
{
    int fd, msglen, interval, nmsg;
    char *ds;

    nsec();		/* make sure time file is already open */

    fmtinstall('V', eipfmt);
    fmtinstall('I', eipfmt);

    msglen = interval = 0;
    nmsg = MAXMSG;
    ARGBEGIN {
    case '6':
        proto = &v6pr;
        break;
    case 'a':
        addresses = 1;
        break;
    case 'd':
        debug++;
        break;
    case 'f':
        flood = 1;
        break;
    case 'i':
        interval = atoi(EARGF(usage()));
        if(interval < 0)
            usage();
        break;
    case 'l':
        lostonly++;
        break;
    case 'n':
        nmsg = atoi(EARGF(usage()));
        if(nmsg < 0)
            usage();
        break;
    case 'q':
        quiet = 1;
        break;
    case 'r':
        rint = 1;
        break;
    case 's':
        msglen = atoi(EARGF(usage()));
        break;
    case 'w':
        waittime = atoi(EARGF(usage()));
        if(waittime < 0)
            usage();
        break;
    default:
        usage();
        break;
    } ARGEND;

    if(msglen < proto->iphdrsz + ICMP_HDRSIZE)
        msglen = proto->iphdrsz + ICMP_HDRSIZE;
    if(msglen < 64)
        msglen = 64;
    if(msglen >= 64*1024)
        msglen = 64*1024-1;
    if(interval <= 0 && !flood)
        interval = SLEEPMS;

    if(argc < 1)
        usage();

    notify(catch);

    if (!isv4name(argv[0]))
        proto = &v6pr;
    ds = netmkaddr(argv[0], proto->net, "1");
    fd = dial(ds, 0, 0, 0);
    if(fd < 0){
        fprint(2, "%s: couldn't dial %s: %r\n", argv0, ds);
        exits("dialing");
    }

    if (!quiet)
        print("sending %d %d byte messages %d ms apart to %s\n",
            nmsg, msglen, interval, ds);

    switch(rfork(RFPROC|RFMEM|RFFDG)){
    case -1:
        fprint(2, "%s: can't fork: %r\n", argv0);
        /* fallthrough */
    case 0:
        rcvr(fd, msglen, interval, nmsg);
        exits(0);
    default:
        sender(fd, msglen, interval, nmsg);
        wait();
        exits(lostmsgs ? "lost messages" : "");
    }
}
@

<<function [[reply]]>>=
void
reply(Req *r, void *v)
{
    r->rtt /= 1000LL;
    sum += r->rtt;
    if(!r->replied)
        rcvdmsgs++;
    if(!quiet && !lostonly)
        if(addresses)
            (*proto->prreply)(r, v);
        else
            print("%ud: rtt %lld µs, avg rtt %lld µs, ttl = %d\n",
                r->seq - firstseq, r->rtt, sum/rcvdmsgs, r->ttl);
    r->replied = 1;
}
@

<<function [[lost]]>>=
void
lost(Req *r, void *v)
{
    if(!quiet)
        if(addresses && v != nil)
            (*proto->prlost)(r->seq - firstseq, v);
        else
            print("lost %ud\n", r->seq - firstseq);
    lostmsgs++;
}
@


%-------------------------------------------------------------

<<networking/ip/ping.c>>=
/* ping for ip v4 and v6 */
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include "icmp.h"

<<enum [[_anon_ (networking/ip/ping.c)]]>>

typedef struct Req Req;
<<struct [[Req]]>>

typedef struct {
    int	version;
    char	*net;
    int	echocmd;
    int	echoreply;
    unsigned iphdrsz;

    void	(*prreply)(Req *r, void *v);
    void	(*prlost)(ushort seq, void *v);
} Proto;


<<global [[first]]>>
<<global [[last]]>>
<<global [[listlock]]>>

<<global [[argv0]]>>

<<global [[addresses]]>>
<<global [[debug]]>>
<<global [[done]]>>
<<global [[flood]]>>
<<global [[lostmsgs]]>>
<<global [[lostonly]]>>
<<global [[quiet]]>>
<<global [[rcvdmsgs]]>>
<<global [[rint]]>>
<<global [[firstseq]]>>
<<global [[sum]]>>
<<global [[waittime]]>>

static char *network, *target;

void lost(Req*, void*);
void reply(Req*, void*);

<<function [[usage]]>>

<<function [[catch]]>>

<<function [[prlost4]]>>

<<function [[prlost6]]>>

<<function [[prreply4]]>>

<<function [[prreply6]]>>

<<global [[v4pr]]>>
<<global [[v6pr]]>>

<<global [[proto]]>>


<<function [[geticmp]]>>

<<function [[clean]]>>

<<global [[loopbacknet]]([[(networking/ip/ping.c)]])>>
<<global [[loopbackmask]]([[(networking/ip/ping.c)]])>>

<<function [[myipvnaddr]]>>

<<function [[sender]]>>

<<function [[rcvr]]>>

<<function [[isdottedquad]]>>

<<function [[isv6lit]]>>

<<enum [[_anon_ (networking/ip/ping.c)2]]>>

typedef struct DS DS;
<<struct [[DS]]>>

<<function [[_dial_string_parse]]>>

/* end excerpt from /sys/src/libc/9sys/dial.c */

<<function [[isv4name]]>>

<<function [[main]]([[(networking/ip/ping.c)]])>>

<<function [[reply]]>>

<<function [[lost]]>>
@


\subsection*{[[networking/ip/traceroute.c]]}

<<enum [[_anon_ (networking/ip/traceroute.c)]]>>=
enum{
    Maxstring=	128,
    Maxpath=	256,
};
@

<<struct [[DS]]([[(networking/ip/traceroute.c)]])>>=
struct DS {
    /* dial string */
    char	buf[Maxstring];
    char	*netdir;
    char	*proto;
    char	*rem;
};
@

<<global [[argv0]]([[(networking/ip/traceroute.c)]])>>=
char *argv0;
@

<<global [[debug]]([[(networking/ip/traceroute.c)]])>>=
int debug;
@

<<function [[usage]]([[(networking/ip/traceroute.c)]])>>=
void
usage(void)
{
    fprint(2,
"usage: %s [-n][-a tries][-h buckets][-t ttl][-x net] [protocol!]destination\n",
        argv0);
    exits("usage");
}
@

<<function [[csquery]]>>=
static int
csquery(DS *ds, char *clone, char *dest)
{
    int n, fd;
    char *p, buf[Maxstring];

    /*
     *  open connection server
     */
    snprint(buf, sizeof(buf), "%s/cs", ds->netdir);
    fd = open(buf, ORDWR);
    if(fd < 0){
        if(!isdigit(*dest)){
            werrstr("can't translate");
            return -1;
        }

        /* no connection server, don't translate */
        snprint(clone, sizeof(clone), "%s/%s/clone", ds->netdir, ds->proto);
        strcpy(dest, ds->rem);
        return 0;
    }

    /*
     *  ask connection server to translate
     */
    sprint(buf, "%s!%s", ds->proto, ds->rem);
    if(write(fd, buf, strlen(buf)) < 0){
        close(fd);
        return -1;
    }

    /*
     *  get an address.
     */
    seek(fd, 0, 0);
    n = read(fd, buf, sizeof(buf) - 1);
    close(fd);
    if(n <= 0){
        werrstr("problem with cs");
        return -1;
    }

    buf[n] = 0;
    p = strchr(buf, ' ');
    if(p == 0){
        werrstr("problem with cs");
        return -1;
    }

    *p++ = 0;
    strcpy(clone, buf);
    strcpy(dest, p);
    return 0;
}
@

<<function [[dodnsquery]]>>=
/*
 *  call the dns process and have it try to resolve the mx request
 */
static int
dodnsquery(DS *ds, char *ip, char *dom)
{
    char *p;
    Ndbtuple *t, *nt;

    p = strchr(ip, '!');
    if(p)
        *p = 0;

    t = dnsquery(ds->netdir, ip, "ptr");
    for(nt = t; nt != nil; nt = nt->entry)
        if(strcmp(nt->attr, "dom") == 0){
            strcpy(dom, nt->val);
            ndbfree(t);
            return 0;
        }
    ndbfree(t);
    return -1;
}
@

<<function [[tcpilprobe]]>>=
/*  for connection oriented protocols (il, tcp) we just need
 *  to try dialing.  resending is up to it.
 */
static int
tcpilprobe(int cfd, int dfd, char *dest, int interval)
{
    int n;
    char msg[Maxstring];

    USED(dfd);

    n = snprint(msg, sizeof msg, "connect %s", dest);
    alarm(interval);
    n = write(cfd, msg, n);
    alarm(0);
    return n;
}
@

<<function [[udpprobe]]>>=
/*
 *  for udp, we keep sending to an improbable port
 *  till we timeout or someone complains
 */
static int
udpprobe(int cfd, int dfd, char *dest, int interval)
{
    int n, i, rv;
    char msg[Maxstring];
    char err[Maxstring];

    seek(cfd, 0, 0);
    n = snprint(msg, sizeof msg, "connect %s", dest);
    if(write(cfd, msg, n)< 0)
        return -1;

    rv = -1;
    for(i = 0; i < 3; i++){
        alarm(interval/3);
        if(write(dfd, "boo hoo ", 8) < 0)
            break;
        /*
         *  a hangup due to an error looks like 3 eofs followed
         *  by a real error.  this is a qio.c qbread() strangeness
         *  done for pipes.
         */
        do {
            n = read(dfd, msg, sizeof(msg)-1);
        } while(n == 0);
        alarm(0);
        if(n > 0){
            rv = 0;
            break;
        }
        errstr(err, sizeof err);
        if(strstr(err, "alarm") == 0){
            werrstr(err);
            break;
        }
        werrstr(err);
    }
    alarm(0);
    return rv;
}
@

<<constant [[MSG]]>>=
#define MSG "traceroute probe"
@

<<constant [[MAGIC]]>>=
#define MAGIC 0xdead
@

<<function [[icmpprobe]]>>=
/* ICMPv4 only */
static int
icmpprobe(int cfd, int dfd, char *dest, int interval)
{
    int x, i, n, len, rv;
    char buf[512], err[Maxstring], msg[Maxstring];
    Icmphdr *ip;

    seek(cfd, 0, 0);
    n = snprint(msg, sizeof msg, "connect %s", dest);
    if(write(cfd, msg, n)< 0)
        return -1;

    rv = -1;
    ip = (Icmphdr *)(buf + IPV4HDR_LEN);
    for(i = 0; i < 3; i++){
        alarm(interval/3);
        ip->type = EchoRequest;
        ip->code = 0;
        strcpy((char*)ip->data, MSG);
        ip->seq[0] = MAGIC;
        ip->seq[1] = MAGIC>>8;
        len = IPV4HDR_LEN + ICMP_HDRSIZE + sizeof(MSG);

        /* send a request */
        if(write(dfd, buf, len) < len)
            break;

        /* wait for reply */
        n = read(dfd, buf, sizeof(buf));
        alarm(0);
        if(n < 0){
            errstr(err, sizeof err);
            if(strstr(err, "alarm") == 0){
                werrstr(err);
                break;
            }
            werrstr(err);
            continue;
        }
        x = (ip->seq[1]<<8) | ip->seq[0];
        if(n >= len && ip->type == EchoReply && x == MAGIC &&
            strcmp((char*)ip->data, MSG) == 0){
            rv = 0;
            break;
        }
    }
    alarm(0);
    return rv;
}
@

<<function [[catch]]([[(networking/ip/traceroute.c)]])>>=
static void
catch(void *a, char *msg)
{
    USED(a);
    if(strstr(msg, "alarm"))
        noted(NCONT);
    else
        noted(NDFLT);
}
@

<<function [[call]]>>=
static int
call(DS *ds, char *clone, char *dest, int ttl, long *interval)
{
    int cfd, dfd, rv, n;
    char msg[Maxstring];
    char file[Maxstring];
    vlong start;

    notify(catch);

    /* start timing */
    start = nsec()/1000;
    rv = -1;

    cfd = open(clone, ORDWR);
    if(cfd < 0){
        werrstr("%s: %r", clone);
        return -1;
    }
    dfd = -1;

    /* get conversation number */
    n = read(cfd, msg, sizeof(msg)-1);
    if(n <= 0)
        goto out;
    msg[n] = 0;

    /* open data file */
    sprint(file, "%s/%s/%s/data", ds->netdir, ds->proto, msg);
    dfd = open(file, ORDWR);
    if(dfd < 0)
        goto out;

    /* set ttl */
    if(ttl)
        fprint(cfd, "ttl %d", ttl);

    /* probe */
    if(strcmp(ds->proto, "udp") == 0)
        rv = udpprobe(cfd, dfd, dest, 3000);
    else if(strcmp(ds->proto, "icmp") == 0)
        rv = icmpprobe(cfd, dfd, dest, 3000);
    else	/* il and tcp */
        rv = tcpilprobe(cfd, dfd, dest, 3000);
out:
    /* turn off alarms */
    alarm(0);
    *interval = nsec()/1000 - start;
    close(cfd);
    close(dfd);
    return rv;
}
@

<<function [[dial_string_parse]]>>=
/*
 *  parse a dial string.  default netdir is /net.
 *  default proto is tcp.
 */
static void
dial_string_parse(char *str, DS *ds)
{
    char *p, *p2;

    strncpy(ds->buf, str, Maxstring);
    ds->buf[Maxstring-3] = 0;

    p = strchr(ds->buf, '!');
    if(p == 0) {
        ds->netdir = 0;
        ds->proto = "tcp";
        ds->rem = ds->buf;
    } else {
        if(*ds->buf != '/'){
            ds->netdir = 0;
            ds->proto = ds->buf;
        } else {
            for(p2 = p; *p2 != '/'; p2--)
                ;
            *p2++ = 0;
            ds->netdir = ds->buf;
            ds->proto = p2;
        }
        *p = 0;
        ds->rem = p + 1;
    }
    if(strchr(ds->rem, '!') == 0)
        strcat(ds->rem, "!32767");
}
@

<<function [[main]]([[(networking/ip/traceroute.c)]])>>=
void
main(int argc, char **argv)
{
    int buckets, ttl, j, done, tries, notranslate;
    long lo, hi, sum, x;
    long *t;
    char *net, *p;
    char clone[Maxpath], dest[Maxstring], hop[Maxstring], dom[Maxstring];
    char err[Maxstring];
    DS ds;

    buckets = 0;
    tries = 3;
    notranslate = 0;
    net = "/net";
    ttl = 1;
    ARGBEGIN{
    case 'a':
        tries = atoi(EARGF(usage()));
        break;
    case 'd':
        debug++;
        break;
    case 'h':
        buckets = atoi(EARGF(usage()));
        break;
    case 'n':
        notranslate++;
        break;
    case 't':
        ttl = atoi(EARGF(usage()));
        break;
    case 'x':
        net = EARGF(usage());
        break;
    default:
        usage();
    }ARGEND;

    if(argc < 1)
        usage();

    t = malloc(tries*sizeof(ulong));

    dial_string_parse(argv[0], &ds);

    if(ds.netdir == 0)
        ds.netdir = net;
    if(csquery(&ds, clone, dest) < 0){
        fprint(2, "%s: %s: %r\n", argv0, argv[0]);
        exits(0);
    }
    print("trying %s/%s!%s\n\n", ds.netdir, ds.proto, dest);
    print("                       round trip times in µs\n");
    print("                        low      avg     high\n");
    print("                     --------------------------\n");

    done = 0;
    for(; ttl < 32; ttl++){
        for(j = 0; j < tries; j++){
            if(call(&ds, clone, dest, ttl, &t[j]) >= 0){
                if(debug)
                    print("%ld %s\n", t[j], dest);
                strcpy(hop, dest);
                done = 1;
                continue;
            }
            errstr(err, sizeof err);
            if(strstr(err, "refused")){
                strcpy(hop, dest);
                p = strchr(hop, '!');
                if(p)
                    *p = 0;
                done = 1;
            } else if(strstr(err, "unreachable")){
                snprint(hop, sizeof(hop), "%s", err);
                p = strchr(hop, '!');
                if(p)
                    *p = 0;
                done = 1;
            } else if(strncmp(err, "ttl exceeded at ", 16) == 0)
                strcpy(hop, err+16);
            else {
                strcpy(hop, "*");
                break;
            }
            if(debug)
                print("%ld %s\n", t[j], hop);
        }
        if(strcmp(hop, "*") == 0){
            print("*\n");
            continue;
        }
        lo = 10000000;
        hi = 0;
        sum = 0;
        for(j = 0; j < tries; j++){
            x = t[j];
            sum += x;
            if(x < lo)
                lo = x;
            if(x > hi)
                hi = x;
        }
        if(notranslate == 1 || dodnsquery(&ds, hop, dom) < 0)
            dom[0] = 0;
        /* don't truncate: ipv6 addresses can be quite long */
        print("%-18s %8ld %8ld %8ld %s\n", hop, lo, sum/tries, hi, dom);
        if(buckets)
            histogram(t, tries, buckets, lo, hi);
        if(done)
            break;
    }
    exits(0);
}
@

<<global [[order]]>>=
char *order = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
@

<<function [[histogram]]>>=
void
histogram(long *t, int n, int buckets, long lo, long hi)
{
    int i, j, empty;
    long span;
    static char *bar;
    char *p;
    char x[64];

    if(bar == nil)
        bar = malloc(n+1);

    print("+++++++++++++++++++++++\n");
    span = (hi-lo)/buckets;
    span++;
    empty = 0;
    for(i = 0; i < buckets; i++){
        p = bar;
        for(j = 0; j < n; j++)
            if(t[j] >= lo+i*span && t[j] <= lo+(i+1)*span)
                *p++ = order[j];
        *p = 0;
        if(p != bar){
            snprint(x, sizeof x, "[%ld-%ld]", lo+i*span, lo+(i+1)*span);
            print("%-16s %s\n", x, bar);
            empty = 0;
        } else if(!empty){
            print("...\n");
            empty = 1;
        }
    }
    print("+++++++++++++++++++++++\n");
}
@


%-------------------------------------------------------------

<<networking/ip/traceroute.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include <bio.h>
#include <ndb.h>
#include <ip.h>
#include "icmp.h"

<<enum [[_anon_ (networking/ip/traceroute.c)]]>>

typedef struct DS DS;
<<struct [[DS]]([[(networking/ip/traceroute.c)]])>>

<<global [[argv0]]([[(networking/ip/traceroute.c)]])>>
<<global [[debug]]([[(networking/ip/traceroute.c)]])>>

void	histogram(long *t, int n, int buckets, long lo, long hi);

<<function [[usage]]([[(networking/ip/traceroute.c)]])>>

<<function [[csquery]]>>

<<function [[dodnsquery]]>>

<<function [[tcpilprobe]]>>

<<function [[udpprobe]]>>

<<constant [[MSG]]>>
<<constant [[MAGIC]]>>

<<function [[icmpprobe]]>>

<<function [[catch]]([[(networking/ip/traceroute.c)]])>>

<<function [[call]]>>

<<function [[dial_string_parse]]>>

<<function [[main]]([[(networking/ip/traceroute.c)]])>>

<<global [[order]]>>

<<function [[histogram]]>>
@


\subsection*{[[networking/ip/gping.c]]}

<<constant [[MAXNUM]]>>=
#define	MAXNUM	8	/* maximum number of numbers on data line */
@

<<enum [[_anon_ (networking/ip/gping.c)]]>>=
enum {
    Gmsglen	= 16,
};
@

<<struct [[Graph]]>>=
struct Graph
{
    int		colindex;
    Rectangle	r;
    long		*data;
    int		ndata;
    char		*label;
    void		(*newvalue)(Machine*, long*, long*, long*);
    void		(*update)(Graph*, long, long, long);
    Machine		*mach;
    int		overflow;
    Image		*overtmp;
    int		overtmplen;
    char		msg[Gmsglen];
    int		cursor;
    int		vmax;
};
@

<<enum [[_anon_ (networking/ip/gping.c)2]]>>=
enum
{
    MSGLEN		= 64,

    Rttmax		= 50,
};
@

<<struct [[Req]]([[(networking/ip/gping.c)]])>>=
struct Req
{
    int	seq;	/* sequence number */
    vlong	time;	/* time sent */
//	int	rtt;
    Req	*next;
};
@

<<struct [[Machine]]>>=
struct Machine
{
    Lock;
    char	*name;
    int	pingfd;
    int	nproc;

    int	rttmsgs;
    ulong	rttsum;
    ulong	lastrtt;

    int	lostmsgs;
    int	rcvdmsgs;
    ulong	lostavg;
    int	unreachable;

    ushort	seq;
    Req	*first;
    Req	*last;
    Req	*rcvd;

    char	buf[1024];
    char	*bufp;
    char	*ebufp;
};
@

<<enum [[_anon_ (networking/ip/gping.c)3]]>>=
enum
{
    Ncolor		= 6,
    Ysqueeze	= 2,	/* vertical squeezing of label text */
    Labspace	= 2,	/* room around label */
    Dot		= 2,	/* height of dot */
    Opwid		= 5,	/* strlen("add  ") or strlen("drop ") */
    NPROC		= 128,
    NMACH		= 32,
};
@

<<enum [[Menu2]]>>=
enum Menu2
{
    Mrtt,
    Mlost,
    Nmenu2,
};
@

<<global [[menu2str]]>>=
char	*menu2str[Nmenu2+1] = {
    "add  sec rtt",
    "add  % lost ",
    nil,
};
@

<<global [[menu2]]>>=
Menu	menu2 = {menu2str, nil};
@

<<global [[present]]>>=
int		present[Nmenu2];
@

<<global [[newvaluefn]]>>=
void		(*newvaluefn[Nmenu2])(Machine*, long*, long*, long*) = {
    rttval,
    lostval,
};
@

<<global [[cols]]>>=
Image		*cols[Ncolor][3];
@

<<global [[graph]]>>=
Graph		*graph;
@

<<global [[mach]]>>=
Machine		mach[NMACH];
@

<<global [[mediumfont]]>>=
Font		*mediumfont;
@

<<global [[pids]]>>=
int		pids[NPROC];
@

<<global [[npid]]>>=
int		npid;
@

<<global [[parity]]>>=
int 		parity;	/* toggled to avoid patterns in textured background */
@

<<global [[nmach]]>>=
int		nmach;
@

<<global [[ngraph]]>>=
int		ngraph;	/* totaly number is ngraph*nmach */
@

<<global [[starttime]]>>=
long		starttime;
@

<<global [[pinginterval]]>>=
int		pinginterval;
@

<<function [[killall]]>>=
void
killall(char *s)
{
    int i, pid;

    pid = getpid();
    for(i=0; i<NPROC; i++)
        if(pids[i] && pids[i]!=pid)
            postnote(PNPROC, pids[i], "kill");
    exits(s);
}
@

<<function [[emalloc]]>>=
void*
emalloc(ulong sz)
{
    void *v;
    v = malloc(sz);
    if(v == nil) {
        fprint(2, "%s: out of memory allocating %ld: %r\n", argv0, sz);
        killall("mem");
    }
    memset(v, 0, sz);
    return v;
}
@

<<function [[erealloc]]>>=
void*
erealloc(void *v, ulong sz)
{
    v = realloc(v, sz);
    if(v == nil) {
        fprint(2, "%s: out of memory reallocating %ld: %r\n", argv0, sz);
        killall("mem");
    }
    return v;
}
@

<<function [[estrdup]]>>=
char*
estrdup(char *s)
{
    char *t;
    if((t = strdup(s)) == nil) {
        fprint(2, "%s: out of memory in strdup(%.10s): %r\n", argv0, s);
        killall("mem");
    }
    return t;
}
@

<<function [[mkcol]]>>=
void
mkcol(int i, int c0, int c1, int c2)
{
    cols[i][0] = allocimagemix(display, c0, DWhite);
    cols[i][1] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, c1);
    cols[i][2] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, c2);
}
@

<<function [[colinit]]>>=
void
colinit(void)
{
    mediumfont = openfont(display, "/lib/font/bit/pelm/latin1.8.font");
    if(mediumfont == nil)
        mediumfont = font;

    /* Peach */
    mkcol(0, 0xFFAAAAFF, 0xFFAAAAFF, 0xBB5D5DFF);
    /* Aqua */
    mkcol(1, DPalebluegreen, DPalegreygreen, DPurpleblue);
    /* Yellow */
    mkcol(2, DPaleyellow, DDarkyellow, DYellowgreen);
    /* Green */
    mkcol(3, DPalegreen, DMedgreen, DDarkgreen);
    /* Blue */
    mkcol(4, 0x00AAFFFF, 0x00AAFFFF, 0x0088CCFF);
    /* Grey */
    cols[5][0] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0xEEEEEEFF);
    cols[5][1] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0xCCCCCCFF);
    cols[5][2] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0x888888FF);
}
@

<<function [[loadbuf]]>>=
int
loadbuf(Machine *m, int *fd)
{
    int n;


    if(*fd < 0)
        return 0;
    seek(*fd, 0, 0);
    n = read(*fd, m->buf, sizeof m->buf);
    if(n <= 0){
        close(*fd);
        *fd = -1;
        return 0;
    }
    m->bufp = m->buf;
    m->ebufp = m->buf+n;
    return 1;
}
@

<<function [[label]]>>=
void
label(Point p, int dy, char *text)
{
    char *s;
    Rune r[2];
    int w, maxw, maxy;

    p.x += Labspace;
    maxy = p.y+dy;
    maxw = 0;
    r[1] = '\0';
    for(s=text; *s; ){
        if(p.y+mediumfont->height-Ysqueeze > maxy)
            break;
        w = chartorune(r, s);
        s += w;
        w = runestringwidth(mediumfont, r);
        if(w > maxw)
            maxw = w;
        runestring(view, p, display->black, ZP, mediumfont, r);
        p.y += mediumfont->height-Ysqueeze;
    }
}
@

<<function [[hashmark]]>>=
void
hashmark(Point p, int dy, long v, long vmax, char *label)
{
    int y;
    int x;

    x = p.x + Labspace;
    y = p.y + (dy*(vmax-v))/vmax;
    draw(view, Rect(p.x, y-1, p.x+Labspace, y+1), display->black, nil, ZP);
    if(dy > 5*mediumfont->height)
        string(view, Pt(x, y-mediumfont->height/2),
            display->black, ZP, mediumfont, label);
}
@

<<function [[hashmarks]]>>=
void
hashmarks(Point p, int dy, int which)
{
    switch(index2which(which)){
    case Mrtt:
        hashmark(p, dy, rttscale(1000000), Rttmax, "1.");
        hashmark(p, dy, rttscale(100000), Rttmax, "0.1");
        hashmark(p, dy, rttscale(10000), Rttmax, "0.01");
        hashmark(p, dy, rttscale(1000), Rttmax, "0.001");
        break;
    case Mlost:
        hashmark(p, dy, 75, 100, " 75%");
        hashmark(p, dy, 50, 100, " 50%");
        hashmark(p, dy, 25, 100, " 25%");
        break;
    }
}
@

<<function [[paritypt]]>>=
Point
paritypt(int x)
{
    return Pt(x+parity, 0);
}
@

<<function [[datapoint]]>>=
Point
datapoint(Graph *g, int x, long v, long vmax)
{
    Point p;

    p.x = x;
    p.y = g->r.max.y - Dy(g->r)*v/vmax - Dot;
    if(p.y < g->r.min.y)
        p.y = g->r.min.y;
    if(p.y > g->r.max.y-Dot)
        p.y = g->r.max.y-Dot;
    return p;
}
@

<<function [[drawdatum]]>>=
void
drawdatum(Graph *g, int x, long prev, long v, long vmax)
{
    int c;
    Point p, q;

    c = g->colindex;
    p = datapoint(g, x, v, vmax);
    q = datapoint(g, x, prev, vmax);
    if(p.y < q.y){
        draw(view, Rect(p.x, g->r.min.y, p.x+1, p.y), cols[c][0], nil, paritypt(p.x));
        draw(view, Rect(p.x, p.y, p.x+1, q.y+Dot), cols[c][2], nil, ZP);
        draw(view, Rect(p.x, q.y+Dot, p.x+1, g->r.max.y), cols[c][1], nil, ZP);
    }else{
        draw(view, Rect(p.x, g->r.min.y, p.x+1, q.y), cols[c][0], nil, paritypt(p.x));
        draw(view, Rect(p.x, q.y, p.x+1, p.y+Dot), cols[c][2], nil, ZP);
        draw(view, Rect(p.x, p.y+Dot, p.x+1, g->r.max.y), cols[c][1], nil, ZP);
    }
    g->vmax = vmax;
}
@

<<function [[drawmark]]>>=
void
drawmark(Graph *g, int x)
{
    int c;

    c = (g->colindex+1)&Ncolor;
    draw(view, Rect(x, g->r.min.y, x+1, g->r.max.y), cols[c][2], nil, ZP);
}
@

<<function [[redraw]]>>=
void
redraw(Graph *g, int vmax)
{
    int i, c;

    c = g->colindex;
    draw(view, g->r, cols[c][0], nil, paritypt(g->r.min.x));
    for(i=1; i<Dx(g->r); i++)
        drawdatum(g, g->r.max.x-i, g->data[i-1], g->data[i], vmax);
    drawdatum(g, g->r.min.x, g->data[i], g->data[i], vmax);
}
@

<<function [[clearmsg]]>>=
void
clearmsg(Graph *g)
{
    if(g->overtmp != nil)
        draw(view, g->overtmp->r, g->overtmp, nil, g->overtmp->r.min);
    g->overflow = 0;
}
@

<<function [[drawmsg]]>>=
void
drawmsg(Graph *g, char *msg)
{
    if(g->overtmp == nil)
        return;

    /* save previous contents of view */
    draw(g->overtmp, g->overtmp->r, view, nil, g->overtmp->r.min);

    /* draw message */
    if(strlen(msg) > g->overtmplen)
        msg[g->overtmplen] = 0;
    string(view, g->overtmp->r.min, display->black, ZP, mediumfont, msg);
}
@

<<function [[clearcursor]]>>=
void
clearcursor(Graph *g)
{
    int x;
    long prev;

    if(g->overtmp == nil)
        return;

    if(g->cursor > 0 && g->cursor < g->ndata){
        x = g->r.max.x - g->cursor;
        prev = 0;
        if(g->cursor > 0)
            prev = g->data[g->cursor-1];
        drawdatum(g, x, prev, g->data[g->cursor], g->vmax);
        g->cursor = -1;
    }
}
@

<<function [[drawcursor]]>>=
void
drawcursor(Graph *g, int x)
{
    if(g->overtmp == nil)
        return;

    draw(view, Rect(x, g->r.min.y, x+1, g->r.max.y), cols[g->colindex][2], nil, ZP);
}
@

<<function [[update1]]>>=
void
update1(Graph *g, long v, long vmax, long mark)
{
    char buf[Gmsglen];

    /* put back view value sans message */
    if(g->overflow || *g->msg){
        clearmsg(g);
        g->overflow = 0;
    }

    draw(view, g->r, view, nil, Pt(g->r.min.x+1, g->r.min.y));
    drawdatum(g, g->r.max.x-1, g->data[0], v, vmax);
    if(mark)
        drawmark(g, g->r.max.x-1);
    memmove(g->data+1, g->data, (g->ndata-1)*sizeof(g->data[0]));
    g->data[0] = v;
    if(v>vmax){
        g->overflow = 1;
        sprint(buf, "%ld", v);
        drawmsg(g, buf);
    } else if(*g->msg)
        drawmsg(g, g->msg);

    if(g->cursor >= 0){
        g->cursor++;
        if(g->cursor >= g->ndata){
            g->cursor = -1;
            if(*g->msg){
                clearmsg(g);
                *g->msg = 0;
            }
        }
    }

}
@

<<function [[pinglost]]>>=
void
pinglost(Machine *m, Req*)
{
    m->lostmsgs++;
}
@

<<function [[pingreply]]>>=
void
pingreply(Machine *m, Req *r)
{
    ulong x;

    x = r->time/1000LL;
    m->rttsum += x;
    m->rcvdmsgs++;
    m->rttmsgs++;
}
@

<<function [[pingclean]]>>=
void
pingclean(Machine *m, ushort seq, vlong now, int)
{
    Req **l, *r;
    vlong x, y;

    y = 10LL*1000000000LL;
    for(l = &m->first; *l; ){
        r = *l;
        x = now - r->time;
        if(x > y || r->seq == seq){
            *l = r->next;
            r->time = x;
            if(r->seq != seq)
                pinglost(m, r);
            else
                pingreply(m, r);
            free(r);
        } else
            l = &(r->next);
    }
}
@

<<function [[pingsend]]>>=
/* IPv4 only */
void
pingsend(Machine *m)
{
    int i;
    char buf[128], err[ERRMAX];
    Icmphdr *ip;
    Req *r;

    ip = (Icmphdr *)(buf + IPV4HDR_LEN);
    memset(buf, 0, sizeof buf);
    r = malloc(sizeof *r);
    if(r == nil)
        return;

    for(i = 32; i < MSGLEN; i++)
        buf[i] = i;
    ip->type = EchoRequest;
    ip->code = 0;
    ip->seq[0] = m->seq;
    ip->seq[1] = m->seq>>8;
    r->seq = m->seq;
    r->next = nil;
    lock(m);
    pingclean(m, -1, nsec(), 0);
    if(m->first == nil)
        m->first = r;
    else
        m->last->next = r;
    m->last = r;
    r->time = nsec();
    unlock(m);
    if(write(m->pingfd, buf, MSGLEN) < MSGLEN){
        errstr(err, sizeof err);
        if(strstr(err, "unreach")||strstr(err, "exceed"))
            m->unreachable++;
    }
    m->seq++;
}
@

<<function [[pingrcv]]>>=
/* IPv4 only */
void
pingrcv(void *arg)
{
    int i, n, fd;
    uchar buf[512];
    ushort x;
    vlong now;
    Icmphdr *ip;
    Ip4hdr *ip4;
    Machine *m = arg;

    ip4 = (Ip4hdr *)buf;
    ip = (Icmphdr *)(buf + IPV4HDR_LEN);
    fd = dup(m->pingfd, -1);
    for(;;){
        n = read(fd, buf, sizeof(buf));
        now = nsec();
        if(n <= 0)
            continue;
        if(n < MSGLEN){
            print("bad len %d/%d\n", n, MSGLEN);
            continue;
        }
        for(i = 32; i < MSGLEN; i++)
            if(buf[i] != (i&0xff))
                continue;
        x = (ip->seq[1]<<8) | ip->seq[0];
        if(ip->type != EchoReply || ip->code != 0)
            continue;
        lock(m);
        pingclean(m, x, now, ip4->ttl);
        unlock(m);
    }
}
@
% >> >>

<<function [[initmach]]>>=
void
initmach(Machine *m, char *name)
{
    char *p;

    srand(time(0));
    p = strchr(name, '!');
    if(p){
        p++;
        m->name = estrdup(p+1);
    }else
        p = name;

    m->name = estrdup(p);
    m->nproc = 1;
    m->pingfd = dial(netmkaddr(m->name, "icmp", "1"), 0, 0, 0);
    if(m->pingfd < 0)
        sysfatal("dialing %s: %r", m->name);
    startproc(pingrcv, m);
}
@

<<function [[rttscale]]>>=
long
rttscale(long x)
{
    if(x == 0)
        return 0;
    x = 10.0*log10(x) - 20.0;
    if(x < 0)
        x = 0;
    return x;
}
@

<<function [[rttunscale]]>>=
double
rttunscale(long x)
{
    double dx;

    x += 20;
    dx = x;
    return pow(10.0, dx/10.0);
}
@

<<function [[rttval]]>>=
void
rttval(Machine *m, long *v, long *vmax, long *mark)
{
    ulong x;

    if(m->rttmsgs == 0){
        x = m->lastrtt;
    } else {
        x = m->rttsum/m->rttmsgs;
        m->rttsum = m->rttmsgs = 0;
        m->lastrtt = x;
    }

    *v = rttscale(x);
    *vmax = Rttmax;
    *mark = 0;
}
@

<<function [[lostval]]>>=
void
lostval(Machine *m, long *v, long *vmax, long *mark)
{
    ulong x;

    if(m->rcvdmsgs+m->lostmsgs > 0)
        x = (m->lostavg>>1) + (((m->lostmsgs*100)/(m->lostmsgs + m->rcvdmsgs))>>1);
    else
        x = m->lostavg;
    m->lostavg = x;
    m->lostmsgs = m->rcvdmsgs = 0;

    if(m->unreachable){
        m->unreachable = 0;
        *mark = 100;
    } else
        *mark = 0;

    *v = x;
    *vmax = 100;
}
@

<<global [[catchalarm]]>>=
jmp_buf catchalarm;
@

<<function [[alarmed]]>>=
void
alarmed(void *a, char *s)
{
    if(strcmp(s, "alarm") == 0)
        notejmp(a, catchalarm, 1);
    noted(NDFLT);
}
@

<<function [[usage]]([[(networking/ip/gping.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s machine [machine...]\n", argv0);
    exits("usage");
}
@

<<function [[addgraph]]>>=
void
addgraph(int n)
{
    Graph *g, *ograph;
    int i, j;
    static int nadd;

    if(n > nelem(menu2str))
        abort();
    /* avoid two adjacent graphs of same color */
    if(ngraph>0 && graph[ngraph-1].colindex==nadd%Ncolor)
        nadd++;
    ograph = graph;
    graph = emalloc(nmach*(ngraph+1)*sizeof(Graph));
    for(i=0; i<nmach; i++)
        for(j=0; j<ngraph; j++)
            graph[i*(ngraph+1)+j] = ograph[i*ngraph+j];
    free(ograph);
    ngraph++;
    for(i=0; i<nmach; i++){
        g = &graph[i*ngraph+(ngraph-1)];
        memset(g, 0, sizeof(Graph));
        g->label = menu2str[n]+Opwid;
        g->newvalue = newvaluefn[n];
        g->update = update1;	/* no other update functions yet */
        g->mach = &mach[i];
        g->colindex = nadd%Ncolor;
    }
    present[n] = 1;
    nadd++;
}
@

<<function [[which2index]]>>=
int
which2index(int which)
{
    int i, n;

    n = -1;
    for(i=0; i<ngraph; i++){
        if(strcmp(menu2str[which]+Opwid, graph[i].label) == 0){
            n = i;
            break;
        }
    }
    if(n < 0){
        fprint(2, "%s: internal error can't drop graph\n", argv0);
        killall("error");
    }
    return n;
}
@

<<function [[index2which]]>>=
int
index2which(int index)
{
    int i, n;

    n = -1;
    for(i=0; i<Nmenu2; i++){
        if(strcmp(menu2str[i]+Opwid, graph[index].label) == 0){
            n = i;
            break;
        }
    }
    if(n < 0){
        fprint(2, "%s: internal error can't identify graph\n", argv0);
        killall("error");
    }
    return n;
}
@

<<function [[dropgraph]]>>=
void
dropgraph(int which)
{
    Graph *ograph;
    int i, j, n;

    if(which > nelem(menu2str))
        abort();
    /* convert n to index in graph table */
    n = which2index(which);
    ograph = graph;
    graph = emalloc(nmach*(ngraph-1)*sizeof(Graph));
    for(i=0; i<nmach; i++){
        for(j=0; j<n; j++)
            graph[i*(ngraph-1)+j] = ograph[i*ngraph+j];
        free(ograph[i*ngraph+j].data);
        freeimage(ograph[i*ngraph+j].overtmp);
        for(j++; j<ngraph; j++)
            graph[i*(ngraph-1)+j-1] = ograph[i*ngraph+j];
    }
    free(ograph);
    ngraph--;
    present[which] = 0;
}
@

<<function [[addmachine]]>>=
void
addmachine(char *name)
{
    if(ngraph > 0){
        fprint(2, "%s: internal error: ngraph>0 in addmachine()\n", argv0);
        usage();
    }
    if(nmach == NMACH)
        sysfatal("too many machines");
    initmach(&mach[nmach++], name);
}
@

<<function [[resize]]>>=
void
resize(void)
{
    int i, j, n, startx, starty, x, y, dx, dy, hashdx, ondata;
    Graph *g;
    Rectangle machr, r;
    long v, vmax, mark;
    char buf[128];

    draw(view, view->r, display->white, nil, ZP);

    /* label left edge */
    x = view->r.min.x;
    y = view->r.min.y + Labspace+mediumfont->height+Labspace;
    dy = (view->r.max.y - y)/ngraph;
    dx = Labspace+stringwidth(mediumfont, "0")+Labspace;
    startx = x+dx+1;
    starty = y;
    for(i=0; i<ngraph; i++,y+=dy){
        draw(view, Rect(x, y-1, view->r.max.x, y), display->black, nil, ZP);
        draw(view, Rect(x, y, x+dx, view->r.max.y), cols[graph[i].colindex][0], nil, paritypt(x));
        label(Pt(x, y), dy, graph[i].label);
        draw(view, Rect(x+dx, y, x+dx+1, view->r.max.y), cols[graph[i].colindex][2], nil, ZP);
    }

    /* label right edge */
    dx = Labspace+stringwidth(mediumfont, "0.001")+Labspace;
    hashdx = dx;
    x = view->r.max.x - dx;
    y = view->r.min.y + Labspace+mediumfont->height+Labspace;
    for(i=0; i<ngraph; i++,y+=dy){
        draw(view, Rect(x, y-1, view->r.max.x, y), display->black, nil, ZP);
        draw(view, Rect(x, y, x+dx, view->r.max.y), cols[graph[i].colindex][0], nil, paritypt(x));
        hashmarks(Pt(x, y), dy, i);
        draw(view, Rect(x+dx, y, x+dx+1, view->r.max.y), cols[graph[i].colindex][2], nil, ZP);
    }

    /* label top edge */
    dx = (view->r.max.x - dx - startx)/nmach;
    for(x=startx, i=0; i<nmach; i++,x+=dx){
        draw(view, Rect(x-1, starty-1, x, view->r.max.y), display->black, nil, ZP);
        j = dx/stringwidth(mediumfont, "0");
        n = mach[i].nproc;
        if(n>1 && j>=1+3+(n>10)+(n>100)){	/* first char of name + (n) */
            j -= 3+(n>10)+(n>100);
            if(j <= 0)
                j = 1;
            snprint(buf, sizeof buf, "%.*s(%d)", j, mach[i].name, n);
        }else
            snprint(buf, sizeof buf, "%.*s", j, mach[i].name);
        string(view, Pt(x+Labspace, view->r.min.y + Labspace), display->black, ZP,
            mediumfont, buf);
    }
    /* draw last vertical line */
    draw(view,
        Rect(view->r.max.x-hashdx-1, starty-1, view->r.max.x-hashdx, view->r.max.y),
        display->black, nil, ZP);

    /* create graphs */
    for(i=0; i<nmach; i++){
        machr = Rect(startx+i*dx, starty, view->r.max.x, view->r.max.y);
        if(i < nmach-1)
            machr.max.x = startx+(i+1)*dx - 1;
        else
            machr.max.x = view->r.max.x - hashdx - 1;
        y = starty;
        for(j=0; j<ngraph; j++, y+=dy){
            g = &graph[i*ngraph+j];
            /* allocate data */
            ondata = g->ndata;
            g->ndata = Dx(machr)+1;	/* may be too many if label will be drawn here; so what? */
            g->data = erealloc(g->data, g->ndata*sizeof(long));
            if(g->ndata > ondata)
                memset(g->data+ondata, 0, (g->ndata-ondata)*sizeof(long));
            /* set geometry */
            g->r = machr;
            g->r.min.y = y;
            g->r.max.y = y+dy - 1;
            if(j == ngraph-1)
                g->r.max.y = view->r.max.y;
            draw(view, g->r, cols[g->colindex][0], nil, paritypt(g->r.min.x));
            g->overflow = 0;
            *g->msg = 0;
            freeimage(g->overtmp);
            g->overtmp = nil;
            g->overtmplen = 0;
            r = g->r;
            r.max.y = r.min.y+mediumfont->height;
            n = (g->r.max.x - r.min.x)/stringwidth(mediumfont, "9");
            if(n > 4){
                if(n > Gmsglen)
                    n = Gmsglen;
                r.max.x = r.min.x+stringwidth(mediumfont, "9")*n;
                g->overtmplen = n;
                g->overtmp = allocimage(display, r, view->chan, 0, -1);
            }
            g->newvalue(g->mach, &v, &vmax, &mark);
            redraw(g, vmax);
        }
    }

    flushimage(display, 1);
}
@

<<function [[eresized]]>>=
void
eresized(int new)
{
    lockdisplay(display);
    if(new && getwindow(display, Refnone) < 0) {
        fprint(2, "%s: can't reattach to window\n", argv0);
        killall("reattach");
    }
    resize();
    unlockdisplay(display);
}
@

<<function [[dobutton2]]>>=
void
dobutton2(Mouse *m)
{
    int i;

    for(i=0; i<Nmenu2; i++)
        if(present[i])
            memmove(menu2str[i], "drop ", Opwid);
        else
            memmove(menu2str[i], "add  ", Opwid);
    i = emenuhit(3, m, &menu2);
    if(i >= 0){
        if(!present[i])
            addgraph(i);
        else if(ngraph > 1)
            dropgraph(i);
        resize();
    }
}
@

<<function [[dobutton1]]>>=
void
dobutton1(Mouse *m)
{
    int i, n, dx, dt;
    Graph *g;
    char *e;
    double f;

    for(i = 0; i < ngraph*nmach; i++){
        if(ptinrect(m->xy, graph[i].r))
            break;
    }
    if(i == ngraph*nmach)
        return;

    g = &graph[i];
    if(g->overtmp == nil)
        return;

    /* clear any previous message and cursor */
    if(g->overflow || *g->msg){
        clearmsg(g);
        *g->msg = 0;
        clearcursor(g);
    }

    dx = g->r.max.x - m->xy.x;
    g->cursor = dx;
    dt = dx*pinginterval;
    e = &g->msg[sizeof(g->msg)];
    seprint(g->msg, e, "%s", ctime(starttime-dt/1000)+11);
    g->msg[8] = 0;
    n = 8;

    switch(index2which(i)){
    case Mrtt:
        f = rttunscale(g->data[dx]);
        seprint(g->msg+n, e, " %3.3g", f/1000000);
        break;
    case Mlost:
        seprint(g->msg+n, e, " %ld%%", g->data[dx]);
        break;
    }

    drawmsg(g, g->msg);
    drawcursor(g, m->xy.x);
}
@

<<function [[mouseproc]]>>=
void
mouseproc(void*)
{
    Mouse mouse;

    for(;;){
        mouse = emouse();
        if(mouse.buttons == 4){
            lockdisplay(display);
            dobutton2(&mouse);
            unlockdisplay(display);
        } else if(mouse.buttons == 1){
            lockdisplay(display);
            dobutton1(&mouse);
            unlockdisplay(display);
        }
    }
}
@

<<function [[startproc]]>>=
void
startproc(void (*f)(void*), void *arg)
{
    int pid;

    switch(pid = rfork(RFPROC|RFMEM|RFNOWAIT)){
    case -1:
        fprint(2, "%s: fork failed: %r\n", argv0);
        killall("fork failed");
    case 0:
        f(arg);
        killall("process died");
        exits(nil);
    }
    pids[npid++] = pid;
}
@

<<function [[main]]([[(networking/ip/gping.c)]])>>=
void
main(int argc, char *argv[])
{
    int i, j;
    long v, vmax, mark;
    char flags[10], *f, *p;

    fmtinstall('V', eipfmt);

    f = flags;
    pinginterval = 5000;		/* 5 seconds */
    ARGBEGIN{
    case 'i':
        p = ARGF();
        if(p == nil)
            usage();
        pinginterval = atoi(p);
        break;
    default:
        if(f - flags >= sizeof(flags)-1)
            usage();
        *f++ = ARGC();
        break;
    }ARGEND
    *f = 0;

    for(i=0; i<argc; i++)
        addmachine(argv[i]);

    for(f = flags; *f; f++)
        switch(*f){
        case 'l':
            addgraph(Mlost);
            break;
        case 'r':
            addgraph(Mrtt);
            break;
        }

    if(nmach == 0)
        usage();

    if(ngraph == 0)
        addgraph(Mrtt);

    for(i=0; i<nmach; i++)
        for(j=0; j<ngraph; j++)
            graph[i*ngraph+j].mach = &mach[i];

    if(initdraw(nil, nil, argv0) < 0){
        fprint(2, "%s: initdraw failed: %r\n", argv0);
        exits("initdraw");
    }
    colinit();
    einit(Emouse);
    notify(nil);
    startproc(mouseproc, 0);
    display->locking = 1;	/* tell library we're using the display lock */

    resize();

    starttime = time(0);

    unlockdisplay(display); /* display is still locked from initdraw() */
    for(j = 0; ; j++){
        lockdisplay(display);
        if(j == nmach){
            parity = 1-parity;
            j = 0;
            for(i=0; i<nmach*ngraph; i++){
                graph[i].newvalue(graph[i].mach, &v, &vmax, &mark);
                graph[i].update(&graph[i], v, vmax, mark);
            }
            starttime = time(0);
        }
        flushimage(display, 1);
        unlockdisplay(display);
        pingsend(&mach[j%nmach]);
        sleep(pinginterval/nmach);
    }
}
@


%-------------------------------------------------------------

<<networking/ip/gping.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include <auth.h>
#include <fcall.h>
#include <draw.h>
#include <event.h>
#include <ip.h>
#include "icmp.h"

<<constant [[MAXNUM]]>>

typedef struct Graph	Graph;
typedef struct Machine	Machine;
typedef struct Req	Req;

<<enum [[_anon_ (networking/ip/gping.c)]]>>

<<struct [[Graph]]>>

<<enum [[_anon_ (networking/ip/gping.c)2]]>>

<<struct [[Req]]([[(networking/ip/gping.c)]])>>

<<struct [[Machine]]>>

<<enum [[_anon_ (networking/ip/gping.c)3]]>>

<<enum [[Menu2]]>>

<<global [[menu2str]]>>


void	rttval(Machine*, long*, long*, long*);
void	lostval(Machine*, long*, long*, long*);

<<global [[menu2]]>>
<<global [[present]]>>
<<global [[newvaluefn]]>>

<<global [[cols]]>>
<<global [[graph]]>>
<<global [[mach]]>>
<<global [[mediumfont]]>>
<<global [[pids]]>>
<<global [[npid]]>>
<<global [[parity]]>>
<<global [[nmach]]>>
<<global [[ngraph]]>>
<<global [[starttime]]>>
<<global [[pinginterval]]>>

void	dropgraph(int);
void	addgraph(int);
void	startproc(void (*)(void*), void*);
void	resize(void);
long	rttscale(long);
int	which2index(int);
int	index2which(int);

<<function [[killall]]>>

<<function [[emalloc]]>>

<<function [[erealloc]]>>

<<function [[estrdup]]>>

<<function [[mkcol]]>>

<<function [[colinit]]>>

<<function [[loadbuf]]>>

<<function [[label]]>>

<<function [[hashmark]]>>

<<function [[hashmarks]]>>

<<function [[paritypt]]>>

<<function [[datapoint]]>>

<<function [[drawdatum]]>>

<<function [[drawmark]]>>

<<function [[redraw]]>>

<<function [[clearmsg]]>>

<<function [[drawmsg]]>>

<<function [[clearcursor]]>>

<<function [[drawcursor]]>>

<<function [[update1]]>>

<<function [[pinglost]]>>

<<function [[pingreply]]>>


<<function [[pingclean]]>>

<<function [[pingsend]]>>

<<function [[pingrcv]]>>

<<function [[initmach]]>>

<<function [[rttscale]]>>

<<function [[rttunscale]]>>

<<function [[rttval]]>>

<<function [[lostval]]>>

<<global [[catchalarm]]>>

<<function [[alarmed]]>>

<<function [[usage]]([[(networking/ip/gping.c)]])>>

<<function [[addgraph]]>>

<<function [[which2index]]>>

<<function [[index2which]]>>

<<function [[dropgraph]]>>

<<function [[addmachine]]>>


<<function [[resize]]>>

<<function [[eresized]]>>

<<function [[dobutton2]]>>

<<function [[dobutton1]]>>

<<function [[mouseproc]]>>

<<function [[startproc]]>>

<<function [[main]]([[(networking/ip/gping.c)]])>>
@


\subsection*{[[networking/ip/hogports.c]]}

<<function [[hogport]]>>=
void
hogport(char *proto, int port)
{
    char buf[256];
    char dir[40];

    snprint(buf, sizeof(buf), "%s!%d", proto, port);
    if(announce(buf, dir) < 0)
        fprint(2, "%s: can't hog %s\n", argv0, buf);
}
@

<<function [[hogrange]]>>=
void
hogrange(char *str)
{
    char *er, *sr;
    int start, end;

    sr = strrchr(str, '!');
    if(sr == nil)
        sysfatal("bad range: %s", str);
    *sr++ = 0;

    er = strchr(sr, '-');
    if(er == nil)
        er = sr;
    else
        er++;

    start = atoi(sr);
    end = atoi(er);
    if(end < start)
        sysfatal("bad range: %s", sr);

    for(; start <= end; start++)
        hogport(str, start);
}
@

<<function [[main]]([[(networking/ip/hogports.c)]])>>=
void
main(int argc, char **argv)
{
    int i;

    ARGBEGIN{
    }ARGEND;

    if(argc == 0){
        fprint(2, "usage: %s portrange\n", argv0);
        exits("usage");
    }

    switch(rfork(RFREND|RFNOTEG|RFFDG|RFPROC|RFNAMEG)){
    case 0:
        close(0);
        close(1);
        break;
    case -1:
        abort(); /* "fork failed\n" */;
    default:
        _exits(0);
    }

    for(i = 0; i < argc; i++)
        hogrange(argv[i]);

    close(2);
    for(;;)
        sleep(10000);
}
@


%-------------------------------------------------------------

<<networking/ip/hogports.c>>=
#include <u.h>
#include <libc.h>

<<function [[hogport]]>>

<<function [[hogrange]]>>

<<function [[main]]([[(networking/ip/hogports.c)]])>>
@


\subsection*{[[networking/ip/udpecho.c]]}

<<function [[usage]]([[(networking/ip/udpecho.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-x netmtpt]\n", argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/udpecho.c)]])>>=
void
main(int argc, char **argv)
{
    int fd, cfd, n;
    char buf[4096], data[128], devdir[40], net[32];

    setnetmtpt(net, sizeof net, nil);

    ARGBEGIN{
    case 'x':
        setnetmtpt(net, sizeof net, EARGF(usage()));
        break;
    }ARGEND;

    sprint(data, "%s/udp!*!echo", net);
    cfd = announce(data, devdir);
    if(cfd < 0)
        sysfatal("can't announce %s: %r", data);
    if(fprint(cfd, "headers") < 0)
        sysfatal("can't set header mode: %r");

    sprint(data, "%s/data", devdir);
    fd = open(data, ORDWR);
    if(fd < 0)
        sysfatal("open %s: %r", data);
    while ((n = read(fd, buf, sizeof buf)) > 0)
        write(fd, buf, n);
    if (n < 0)
        sysfatal("error reading: %r");
    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ip/udpecho.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>

<<function [[usage]]([[(networking/ip/udpecho.c)]])>>

<<function [[main]]([[(networking/ip/udpecho.c)]])>>
@


\section{[[networking/ip/ipconfig/]]}

\subsection*{[[networking/ip/ipconfig/ipconfig.h]]}

<<struct [[Conf]]>>=
struct Conf
{
    /* locally generated */
    char	*type;
    char	*dev;
    char	mpoint[32];
    int	cfd;			/* ifc control channel */
    int	dfd;			/* ifc data channel (for ppp) */
    char	*cputype;
    uchar	hwa[32];		/* hardware address */
    int	hwatype;
    int	hwalen;
    uchar	cid[32];
    int	cidlen;
    char	*baud;

    /* learned info */
    uchar	gaddr[IPaddrlen];
    uchar	laddr[IPaddrlen];
    uchar	mask[IPaddrlen];
    uchar	raddr[IPaddrlen];
    uchar	dns[2*IPaddrlen];
    uchar	fs[2*IPaddrlen];
    uchar	auth[2*IPaddrlen];
    uchar	ntp[IPaddrlen];
    int	mtu;

    /* dhcp specific */
    int	state;
    int	fd;
    ulong	xid;
    ulong	starttime;
    char	sname[64];
    char	hostname[32];
    char	domainname[64];
    uchar	server[IPaddrlen];	/* server IP address */
    ulong	offered;		/* offered lease time */
    ulong	lease;			/* lease time */
    ulong	resend;			/* # of resends for current state */
    ulong	timeout;		/* time to timeout - seconds */

    /*
     * IPv6
     */

    /* solicitation specific - XXX add support for IPv6 leases */
//	ulong	solicit_retries;

    /* router-advertisement related */
    uchar	sendra;
    uchar	recvra;
    uchar	mflag;
    uchar	oflag;
    int 	maxraint; /* rfc2461, p.39: 4sec ≤ maxraint ≤ 1800sec, def 600 */
    int	minraint;	/* 3sec ≤ minraint ≤ 0.75*maxraint */
    int	linkmtu;
    int	reachtime;	/* 3,600,000 msec, default 0 */
    int	rxmitra;	/* default 0 */
    int	ttl;		/* default 0 (unspecified) */
    /* default gateway params */
    uchar	v6gaddr[IPaddrlen];
    int	routerlt;	/* router life time */

    /* prefix related */
    uchar	v6pref[IPaddrlen];
    int	prefixlen;
    uchar	onlink;		/* flag: address is `on-link' */
    uchar	autoflag;	/* flag: autonomous */
    ulong	validlt;	/* valid lifetime (seconds) */
    ulong	preflt;		/* preferred lifetime (seconds) */
};
@

<<struct [[Ctl]]>>=
struct Ctl
{
    Ctl	*next;
    char	*ctl;
};
@

<<enum [[_anon_ (networking/ip/ipconfig/ipconfig.h)]]>>=
enum {
    IsRouter 	= 1,
    IsHostRecv	= 2,
    IsHostNoRecv	= 3,

    MAClen		= 6,

    IPv4		= 4,
    IPv6		= 6,
    Defmtu		= 1400,

    IP_HOPBYHOP	= 0,
    ICMPv4		= 1,
    IP_IGMPPROTO	= 2,
    IP_TCPPROTO	= 6,
    IP_UDPPROTO	= 17,
    IP_ILPROTO	= 40,
    IP_v6ROUTE	= 43,
    IP_v6FRAG	= 44,
    IP_IPsecESP	= 50,
    IP_IPsecAH	= 51,
    IP_v6NOMORE	= 59,
    ICMP6_RS	= 133,
    ICMP6_RA	= 134,

    IP_IN_IP	= 41,
};
@

<<enum [[_anon_ (networking/ip/ipconfig/ipconfig.h)2]]>>=
enum {
    MFMASK = 1 << 7,
    OCMASK = 1 << 6,
    OLMASK = 1 << 7,
    AFMASK = 1 << 6,
};
@

<<enum [[_anon_ (networking/ip/ipconfig/ipconfig.h)3]]>>=
enum {
    MAXTTL		= 255,
    D64HLEN		= IPV6HDR_LEN - IPV4HDR_LEN,
    IP_MAX		= 32*1024,
};
@

<<struct [[Headers]]>>=
struct Headers {
    uchar	dst[IPaddrlen];
    uchar	src[IPaddrlen];
};
@

<<struct [[Routersol]]>>=
struct Routersol {
    uchar	vcf[4];		/* version:4, traffic class:8, flow label:20 */
    uchar	ploadlen[2];	/* payload length: packet length - 40 */
    uchar	proto;		/* next header	type */
    uchar	ttl;		/* hop limit */
    uchar	src[IPaddrlen];
    uchar	dst[IPaddrlen];
    uchar	type;
    uchar	code;
    uchar	cksum[2];
    uchar	res[4];
};
@

<<struct [[Routeradv]]>>=
struct Routeradv {
    uchar	vcf[4];		/* version:4, traffic class:8, flow label:20 */
    uchar	ploadlen[2];	/* payload length: packet length - 40 */
    uchar	proto;		/* next header	type */
    uchar	ttl;		/* hop limit */
    uchar	src[IPaddrlen];
    uchar	dst[IPaddrlen];
    uchar	type;
    uchar	code;
    uchar	cksum[2];
    uchar	cttl;
    uchar	mor;
    uchar	routerlt[2];
    uchar	rchbltime[4];
    uchar	rxmtimer[4];
};
@

<<struct [[Lladdropt]]>>=
struct Lladdropt {
    uchar	type;
    uchar	len;
    uchar	lladdr[MAClen];
};
@

<<struct [[Prefixopt]]>>=
struct Prefixopt {
    uchar	type;
    uchar	len;
    uchar	plen;
    uchar	lar;
    uchar	validlt[4];
    uchar	preflt[4];
    uchar	reserv[4];
    uchar	pref[IPaddrlen];
};
@

<<struct [[Mtuopt]]>>=
struct Mtuopt {
    uchar	type;
    uchar	len;
    uchar	reserv[2];
    uchar	mtu[4];
};
@


%-------------------------------------------------------------

<<networking/ip/ipconfig/ipconfig.h>>=
typedef struct Conf Conf;
typedef struct Ctl Ctl;

<<struct [[Conf]]>>

<<struct [[Ctl]]>>

extern Ctl *firstctl, **ctll;

extern Conf conf;

extern int	noconfig;
extern int	ipv6auto;
extern int	debug;
extern int	dodhcp;
extern int	dolog;
extern int	nip;
extern int	plan9;
extern int	dupl_disc;

extern int	myifc;
extern char	*vs;

void	adddefroute(char*, uchar*);
void	binddevice(void);
void	bootprequest(void);
void	controldevice(void);
void	dhcpquery(int, int);
void	dhcprecv(void);
void	dhcpsend(int);
int	dhcptimer(void);
void	dhcpwatch(int);
void	doadd(int);
void	doremove(void);
void	dounbind(void);
int	getndb(void);
int	ipconfig4(void);
int	ipconfig6(int);
long	jitter(void);
void	lookforip(char*);
void	mkclientid(void);
int	nipifcs(char*);
int	openlisten(void);
uchar	*optaddaddr(uchar*, int, uchar*);
uchar	*optaddbyte(uchar*, int, int);
uchar	*optaddstr(uchar*, int, char*);
uchar	*optadd(uchar*, int, void*, int);
uchar	*optaddulong(uchar*, int, ulong);
uchar	*optaddvec(uchar*, int, uchar*, int);
int	optgetaddrs(uchar*, int, uchar*, int);
int	optgetaddr(uchar*, int, uchar*);
int	optgetbyte(uchar*, int);
int	optgetstr(uchar*, int, char*, int);
uchar	*optget(uchar*, int, int*);
ulong	optgetulong(uchar*, int);
int	optgetvec(uchar*, int, uchar*, int);
int	parseoptions(uchar *p, int n);
int	parseverb(char*);
void	procsetname(char *fmt, ...);
void	putndb(void);
ulong	randint(ulong low, ulong hi);
void	tweakservers(void);
void	usage(void);
int	validip(uchar*);
void	warning(char *fmt, ...);
void	writendb(char*, int, int);

/*
 * IPv6
 */

void	doipv6(int);
int	ipconfig6(int);
void	recvra6(void);
void	sendra6(void);
void	v6paraminit(Conf *);

typedef struct Headers Headers;
typedef struct Ip4hdr  Ip4hdr;
typedef struct Lladdropt Lladdropt;
typedef struct Mtuopt Mtuopt;
typedef struct Prefixopt Prefixopt;
typedef struct Routeradv Routeradv;
typedef struct Routersol Routersol;

<<enum [[_anon_ (networking/ip/ipconfig/ipconfig.h)]]>>

<<enum [[_anon_ (networking/ip/ipconfig/ipconfig.h)2]]>>

<<enum [[_anon_ (networking/ip/ipconfig/ipconfig.h)3]]>>

<<struct [[Headers]]>>

<<struct [[Routersol]]>>

<<struct [[Routeradv]]>>

<<struct [[Lladdropt]]>>

<<struct [[Prefixopt]]>>

<<struct [[Mtuopt]]>>

void	ea2lla(uchar *lla, uchar *ea);
void	ipv62smcast(uchar *smcast, uchar *a);
@


\subsection*{[[networking/ip/ipconfig/main.c]]}

<<constant [[DEBUG]]>>=
#define DEBUG if(debug)warning
@

<<enum [[_anon_ (networking/ip/ipconfig/main.c)]]>>=
/* possible verbs */
enum
{
    /* commands */
    Vadd,
    Vremove,
    Vunbind,
    Vaddpref6,
    Vra6,
    /* media */
    Vether,
    Vgbe,
    Vppp,
    Vloopback,
    Vtorus,
    Vtree,
    Vpkt,
};
@

<<enum [[_anon_ (networking/ip/ipconfig/main.c)2]]>>=
enum
{
    Taddr,
    Taddrs,
    Tstr,
    Tbyte,
    Tulong,
    Tvec,
};
@

<<struct [[Option]]>>=
struct Option
{
    char	*name;
    int	type;
};
@

<<global [[option]]>>=
/*
 * I was too lazy to look up the types for each of these
 * options.  If someone feels like it, please mail me a
 * corrected array -- presotto
 */
Option option[256] =
{
[OBmask]		{ "ipmask",		Taddr },
[OBtimeoff]		{ "timeoff",		Tulong },
[OBrouter]		{ "ipgw",		Taddrs },
[OBtimeserver]		{ "time",		Taddrs },
[OBnameserver]		{ "name",		Taddrs },
[OBdnserver]		{ "dns",		Taddrs },
[OBlogserver]		{ "log",		Taddrs },
[OBcookieserver]	{ "cookie",		Taddrs },
[OBlprserver]		{ "lpr",		Taddrs },
[OBimpressserver]	{ "impress",		Taddrs },
[OBrlserver]		{ "rl",			Taddrs },
[OBhostname]		{ "sys",		Tstr },
[OBbflen]		{ "bflen",		Tulong },
[OBdumpfile]		{ "dumpfile",		Tstr },
[OBdomainname]		{ "dom",		Tstr },
[OBswapserver]		{ "swap",		Taddrs },
[OBrootpath]		{ "rootpath",		Tstr },
[OBextpath]		{ "extpath",		Tstr },
[OBipforward]		{ "ipforward",		Taddrs },
[OBnonlocal]		{ "nonlocal",		Taddrs },
[OBpolicyfilter]	{ "policyfilter",	Taddrs },
[OBmaxdatagram]		{ "maxdatagram",	Tulong },
[OBttl]			{ "ttl",		Tulong },
[OBpathtimeout]		{ "pathtimeout",	Taddrs },
[OBpathplateau]		{ "pathplateau",	Taddrs },
[OBmtu]			{ "mtu",		Tulong },
[OBsubnetslocal]	{ "subnetslocal",	Taddrs },
[OBbaddr]		{ "baddr",		Taddrs },
[OBdiscovermask]	{ "discovermask",	Taddrs },
[OBsupplymask]		{ "supplymask",		Taddrs },
[OBdiscoverrouter]	{ "discoverrouter",	Taddrs },
[OBrsserver]		{ "rs",			Taddrs },
[OBstaticroutes]	{ "staticroutes",	Taddrs },
[OBtrailerencap]	{ "trailerencap",	Taddrs },
[OBarptimeout]		{ "arptimeout",		Tulong },
[OBetherencap]		{ "etherencap",		Taddrs },
[OBtcpttl]		{ "tcpttl",		Tulong },
[OBtcpka]		{ "tcpka",		Tulong },
[OBtcpkag]		{ "tcpkag",		Tulong },
[OBnisdomain]		{ "nisdomain",		Tstr },
[OBniserver]		{ "ni",			Taddrs },
[OBntpserver]		{ "ntp",		Taddrs },
[OBnetbiosns]		{ "netbiosns",		Taddrs },
[OBnetbiosdds]		{ "netbiosdds",		Taddrs },
[OBnetbiostype]		{ "netbiostype",	Taddrs },
[OBnetbiosscope]	{ "netbiosscope",	Taddrs },
[OBxfontserver]		{ "xfont",		Taddrs },
[OBxdispmanager]	{ "xdispmanager",	Taddrs },
[OBnisplusdomain]	{ "nisplusdomain",	Tstr },
[OBnisplusserver]	{ "nisplus",		Taddrs },
[OBhomeagent]		{ "homeagent",		Taddrs },
[OBsmtpserver]		{ "smtp",		Taddrs },
[OBpop3server]		{ "pop3",		Taddrs },
[OBnntpserver]		{ "nntp",		Taddrs },
[OBwwwserver]		{ "www",		Taddrs },
[OBfingerserver]	{ "finger",		Taddrs },
[OBircserver]		{ "irc",		Taddrs },
[OBstserver]		{ "st",			Taddrs },
[OBstdaserver]		{ "stdar",		Taddrs },

[ODipaddr]		{ "ipaddr",		Taddr },
[ODlease]		{ "lease",		Tulong },
[ODoverload]		{ "overload",		Taddr },
[ODtype]		{ "type",		Tbyte },
[ODserverid]		{ "serverid",		Taddr },
[ODparams]		{ "params",		Tvec },
[ODmessage]		{ "message",		Tstr },
[ODmaxmsg]		{ "maxmsg",		Tulong },
[ODrenewaltime]		{ "renewaltime",	Tulong },
[ODrebindingtime]	{ "rebindingtime",	Tulong },
[ODvendorclass]		{ "vendorclass",	Tvec },
[ODclientid]		{ "clientid",		Tvec },
[ODtftpserver]		{ "tftp",		Taddr },
[ODbootfile]		{ "bootfile",		Tstr },
};
@

<<global [[defrequested]]>>=
uchar defrequested[] = {
    OBmask, OBrouter, OBdnserver, OBhostname, OBdomainname, OBntpserver,
};
@

<<global [[requested]]>>=
uchar	requested[256];
@

<<global [[nrequested]]>>=
int	nrequested;
@

<<global [[Oflag]]>>=
int	Oflag;
@

<<global [[beprimary]]>>=
int	beprimary = -1;
@

<<global [[conf]]>>=
Conf	conf;
@

<<global [[debug]]([[(networking/ip/ipconfig/main.c)]])>>=
int	debug;
@

<<global [[dodhcp]]>>=
int	dodhcp;
@

<<global [[dolog]]>>=
int	dolog;
@

<<global [[dondbconfig]]>>=
int	dondbconfig = 0;
@

<<global [[dupl_disc]]>>=
int	dupl_disc = 1;		/* flag: V6 duplicate neighbor discovery */
@

<<global [[ifc]]>>=
Ipifc	*ifc;
@

<<global [[ipv6auto]]>>=
int	ipv6auto = 0;
@

<<global [[myifc]]>>=
int	myifc = -1;
@

<<global [[ndboptions]]>>=
char	*ndboptions;
@

<<global [[nip]]>>=
int	nip;
@

<<global [[noconfig]]>>=
int	noconfig;
@

<<global [[nodhcpwatch]]>>=
int	nodhcpwatch;
@

<<global [[optmagic]]>>=
char 	optmagic[4] = { 0x63, 0x82, 0x53, 0x63 };
@

<<global [[plan9]]>>=
int	plan9 = 1;
@

<<global [[sendhostname]]>>=
int	sendhostname;
@

<<global [[logfile]]>>=
static char logfile[] = "ipconfig";
@

<<global [[verbs]]>>=
char *verbs[] = {
[Vadd]		"add",
[Vremove]	"remove",
[Vunbind]	"unbind",
[Vether]	"ether",
[Vgbe]		"gbe",
[Vppp]		"ppp",
[Vloopback]	"loopback",
[Vaddpref6]	"add6",
[Vra6]		"ra6",
[Vtorus]	"torus",
[Vtree]		"tree",
[Vpkt]		"pkt",
};
@

<<function [[usage]]([[(networking/ip/ipconfig/main.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-6dDGnNOpPruX][-b baud][-c ctl]* [-g gw]"
        "[-h host][-m mtu]\n"
        "\t[-x mtpt][-o dhcpopt] type dev [verb] [laddr [mask "
        "[raddr [fs [auth]]]]]\n", argv0);
    exits("usage");
}
@

<<function [[warning]]>>=
void
warning(char *fmt, ...)
{
    char buf[1024];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf + sizeof buf, fmt, arg);
    va_end(arg);
    if (dolog)
        syslog(0, logfile, "%s", buf);
    else
        fprint(2, "%s: %s\n", argv0, buf);
}
@

<<function [[parsenorm]]>>=
static void
parsenorm(int argc, char **argv)
{
    switch(argc){
    case 5:
         if (parseip(conf.auth, argv[4]) == -1)
            usage();
        /* fall through */
    case 4:
         if (parseip(conf.fs, argv[3]) == -1)
            usage();
        /* fall through */
    case 3:
         if (parseip(conf.raddr, argv[2]) == -1)
            usage();
        /* fall through */
    case 2:
        /*
         * can't test for parseipmask()==-1 cuz 255.255.255.255
         * looks like that.
         */
        if (strcmp(argv[1], "0") != 0)
            parseipmask(conf.mask, argv[1]);
        /* fall through */
    case 1:
         if (parseip(conf.laddr, argv[0]) == -1)
            usage();
        /* fall through */
    case 0:
        break;
    default:
        usage();
    }
}
@

<<function [[parse6pref]]>>=
static void
parse6pref(int argc, char **argv)
{
    switch(argc){
    case 6:
        conf.preflt = strtoul(argv[5], 0, 10);
        /* fall through */
    case 5:
        conf.validlt = strtoul(argv[4], 0, 10);
        /* fall through */
    case 4:
        conf.autoflag = (atoi(argv[3]) != 0);
        /* fall through */
    case 3:
        conf.onlink = (atoi(argv[2]) != 0);
        /* fall through */
    case 2:
        conf.prefixlen = atoi(argv[1]);
        /* fall through */
    case 1:
        if (parseip(conf.v6pref, argv[0]) == -1)
            sysfatal("bad address %s", argv[0]);
        break;
    }
    DEBUG("parse6pref: pref %I len %d", conf.v6pref, conf.prefixlen);
}
@

<<function [[parse6ra]]>>=
/* parse router advertisement (keyword, value) pairs */
static void
parse6ra(int argc, char **argv)
{
    int i, argsleft;
    char *kw, *val;

    if (argc % 2 != 0)
        usage();

    i = 0;
    for (argsleft = argc; argsleft > 1; argsleft -= 2) {
        kw =  argv[i];
        val = argv[i+1];
        if (strcmp(kw, "recvra") == 0)
            conf.recvra = (atoi(val) != 0);
        else if (strcmp(kw, "sendra") == 0)
            conf.sendra = (atoi(val) != 0);
        else if (strcmp(kw, "mflag") == 0)
            conf.mflag = (atoi(val) != 0);
        else if (strcmp(kw, "oflag") == 0)
            conf.oflag = (atoi(val) != 0);
        else if (strcmp(kw, "maxraint") == 0)
            conf.maxraint = atoi(val);
        else if (strcmp(kw, "minraint") == 0)
            conf.minraint = atoi(val);
        else if (strcmp(kw, "linkmtu") == 0)
            conf.linkmtu = atoi(val);
        else if (strcmp(kw, "reachtime") == 0)
            conf.reachtime = atoi(val);
        else if (strcmp(kw, "rxmitra") == 0)
            conf.rxmitra = atoi(val);
        else if (strcmp(kw, "ttl") == 0)
            conf.ttl = atoi(val);
        else if (strcmp(kw, "routerlt") == 0)
            conf.routerlt = atoi(val);
        else {
            warning("bad ra6 keyword %s", kw);
            usage();
        }
        i += 2;
    }

    /* consistency check */
    if (conf.maxraint < conf.minraint)
        sysfatal("maxraint %d < minraint %d",
            conf.maxraint, conf.minraint);
}
@

<<function [[init]]>>=
static void
init(void)
{
    srand(truerand());
    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('M', eipfmt);
    fmtinstall('V', eipfmt);
  nsec();			/* make sure time file is open before forking */

    setnetmtpt(conf.mpoint, sizeof conf.mpoint, nil);
    conf.cputype = getenv("cputype");
    if(conf.cputype == nil)
        conf.cputype = "386";

    ctll = &firstctl;
    v6paraminit(&conf);

    /* init set of requested dhcp parameters with the default */
    nrequested = sizeof defrequested;
    memcpy(requested, defrequested, nrequested);
}
@

<<function [[parseargs]]>>=
static int
parseargs(int argc, char **argv)
{
    char *p;
    int action, verb;

    /* default to any host name we already have */
    if(*conf.hostname == 0){
        p = getenv("sysname");
        if(p == nil || *p == 0)
            p = sysname();
        if(p != nil)
            strncpy(conf.hostname, p, sizeof conf.hostname-1);
    }

    /* defaults */
    conf.type = "ether";
    conf.dev = "/net/ether0";
    action = Vadd;

    /* get optional medium and device */
    if (argc > 0){
        verb = parseverb(*argv);
        switch(verb){
        case Vether:
        case Vgbe:
        case Vppp:
        case Vloopback:
        case Vtorus:
        case Vtree:
        case Vpkt:
            conf.type = *argv++;
            argc--;
            if(argc > 0){
                conf.dev = *argv++;
                argc--;
            } else if(verb == Vppp)
                conf.dev = "/dev/eia0";
            break;
        }
    }

    /* get optional verb */
    if (argc > 0){
        verb = parseverb(*argv);
        switch(verb){
        case Vether:
        case Vgbe:
        case Vppp:
        case Vloopback:
        case Vtorus:
        case Vtree:
        case Vpkt:
            sysfatal("medium %s already specified", conf.type);
        case Vadd:
        case Vremove:
        case Vunbind:
        case Vaddpref6:
        case Vra6:
            argv++;
            argc--;
            action = verb;
            break;
        }
    }

    /* get verb-dependent arguments */
    switch (action) {
    case Vadd:
    case Vremove:
    case Vunbind:
        parsenorm(argc, argv);
        break;
    case Vaddpref6:
        parse6pref(argc, argv);
        break;
    case Vra6:
        parse6ra(argc, argv);
        break;
    }
    return action;
}
@

<<function [[main]]([[(networking/ip/ipconfig/main.c)]])>>=
void
main(int argc, char **argv)
{
    int retry, action;
    Ctl *cp;

    init();
    retry = 0;
    ARGBEGIN {
    case '6': 			/* IPv6 auto config */
        ipv6auto = 1;
        break;
    case 'b':
        conf.baud = EARGF(usage());
        break;
    case 'c':
        cp = malloc(sizeof *cp);
        if(cp == nil)
            sysfatal("%r");
        *ctll = cp;
        ctll = &cp->next;
        cp->next = nil;
        cp->ctl = EARGF(usage());
        break;
    case 'd':
        dodhcp = 1;
        break;
    case 'D':
        debug = 1;
        break;
    case 'g':
        if (parseip(conf.gaddr, EARGF(usage())) == -1)
            usage();
        break;
    case 'G':
        plan9 = 0;
        break;
    case 'h':
        snprint(conf.hostname, sizeof conf.hostname, "%s",
            EARGF(usage()));
        sendhostname = 1;
        break;
    case 'm':
        conf.mtu = atoi(EARGF(usage()));
        break;
    case 'n':
        noconfig = 1;
        break;
    case 'N':
        dondbconfig = 1;
        break;
    case 'o':
        if(addoption(EARGF(usage())) < 0)
            usage();
        break;
    case 'O':
        Oflag = 1;
        break;
    case 'p':
        beprimary = 1;
        break;
    case 'P':
        beprimary = 0;
        break;
    case 'r':
        retry = 1;
        break;
    case 'u':		/* IPv6: duplicate neighbour disc. off */
        dupl_disc = 0;
        break;
    case 'x':
        setnetmtpt(conf.mpoint, sizeof conf.mpoint, EARGF(usage()));
        break;
    case 'X':
        nodhcpwatch = 1;
        break;
    default:
        usage();
    } ARGEND;
    argv0 = "ipconfig";		/* boot invokes us as tcp? */

    action = parseargs(argc, argv);
    switch(action){
    case Vadd:
        doadd(retry);
        break;
    case Vremove:
        doremove();
        break;
    case Vunbind:
        dounbind();
        break;
    case Vaddpref6:
    case Vra6:
        doipv6(action);
        break;
    }
    exits(0);
}
@

<<function [[havendb]]>>=
int
havendb(char *net)
{
    Dir *d;
    char buf[128];

    snprint(buf, sizeof buf, "%s/ndb", net);
    if((d = dirstat(buf)) == nil)
        return 0;
    if(d->length == 0){
        free(d);
        return 0;
    }
    free(d);
    return 1;
}
@

<<function [[doadd]]>>=
void
doadd(int retry)
{
    int tries, ppp;

    ppp = strcmp(conf.type, "ppp") == 0;

    /* get number of preexisting interfaces */
    nip = nipifcs(conf.mpoint);
    if(beprimary == -1 && (nip == 0 || !havendb(conf.mpoint)))
        beprimary = 1;

    /* get ipifc into name space and condition device for ip */
    if(!noconfig){
        lookforip(conf.mpoint);
        controldevice();
        binddevice();
    }

    if (ipv6auto && !ppp) {
        if (ip6cfg(ipv6auto) < 0)
            sysfatal("can't automatically start IPv6 on %s",
                conf.dev);
//		return;
    } else if (validip(conf.laddr) && !isv4(conf.laddr)) {
        if (ip6cfg(0) < 0)
            sysfatal("can't start IPv6 on %s, address %I",
                conf.dev, conf.laddr);
//		return;
    }

    if(!validip(conf.laddr) && !ppp)
        if(dondbconfig)
            ndbconfig();
        else
            dodhcp = 1;

    /* run dhcp if we need something */
    if(dodhcp){
        mkclientid();
        for(tries = 0; tries < 30; tries++){
            dhcpquery(!noconfig, Sselecting);
            if(conf.state == Sbound)
                break;
            sleep(1000);
        }
    }

    if(!validip(conf.laddr))
        if(retry && dodhcp && !noconfig){
            warning("couldn't determine ip address, retrying");
            dhcpwatch(1);
            return;
        } else
            sysfatal("no success with DHCP");

    if(!noconfig)
        if(ip4cfg() < 0)
            sysfatal("can't start ip");
        else if(dodhcp && conf.lease != Lforever)
            dhcpwatch(0);

    /* leave everything we've learned somewhere other procs can find it */
    if(beprimary == 1){
        putndb();
        tweakservers();
    }
}
@

<<function [[doremove]]>>=
void
doremove(void)
{
    char file[128];
    int cfd;
    Ipifc *nifc;
    Iplifc *lifc;

    if(!validip(conf.laddr))
        sysfatal("remove requires an address");
    ifc = readipifc(conf.mpoint, ifc, -1);
    for(nifc = ifc; nifc != nil; nifc = nifc->next){
        if(strcmp(nifc->dev, conf.dev) != 0)
            continue;
        for(lifc = nifc->lifc; lifc != nil; lifc = lifc->next){
            if(ipcmp(conf.laddr, lifc->ip) != 0)
                continue;
            if (validip(conf.mask) &&
                ipcmp(conf.mask, lifc->mask) != 0)
                continue;
            if (validip(conf.raddr) &&
                ipcmp(conf.raddr, lifc->net) != 0)
                continue;

            snprint(file, sizeof file, "%s/ipifc/%d/ctl",
                conf.mpoint, nifc->index);
            cfd = open(file, ORDWR);
            if(cfd < 0){
                warning("can't open %s: %r", conf.mpoint);
                continue;
            }
            if(fprint(cfd, "remove %I %M", lifc->ip, lifc->mask) < 0)
                warning("can't remove %I %M from %s: %r",
                    lifc->ip, lifc->mask, file);
        }
    }
}
@

<<function [[dounbind]]>>=
void
dounbind(void)
{
    Ipifc *nifc;
    char file[128];
    int cfd;

    ifc = readipifc(conf.mpoint, ifc, -1);
    for(nifc = ifc; nifc != nil; nifc = nifc->next){
        if(strcmp(nifc->dev, conf.dev) == 0){
            snprint(file, sizeof file, "%s/ipifc/%d/ctl",
                conf.mpoint, nifc->index);
            cfd = open(file, ORDWR);
            if(cfd < 0){
                warning("can't open %s: %r", conf.mpoint);
                break;
            }
            if(fprint(cfd, "unbind") < 0)
                warning("can't unbind from %s: %r", file);
            break;
        }
    }
}
@

<<function [[adddefroute]]>>=
/* set the default route */
void
adddefroute(char *mpoint, uchar *gaddr)
{
    char buf[256];
    int cfd;

    sprint(buf, "%s/iproute", mpoint);
    cfd = open(buf, ORDWR);
    if(cfd < 0)
        return;

    if(isv4(gaddr))
        fprint(cfd, "add 0 0 %I", gaddr);
    else
        fprint(cfd, "add :: /0 %I", gaddr);
    close(cfd);
}
@

<<function [[mkclientid]]>>=
/* create a client id */
void
mkclientid(void)
{
    if(strcmp(conf.type, "ether") == 0 || strcmp(conf.type, "gbe") == 0)
        if(myetheraddr(conf.hwa, conf.dev) == 0){
            conf.hwalen = 6;
            conf.hwatype = 1;
            conf.cid[0] = conf.hwatype;
            memmove(&conf.cid[1], conf.hwa, conf.hwalen);
            conf.cidlen = conf.hwalen+1;
        } else {
            conf.hwatype = -1;
            snprint((char*)conf.cid, sizeof conf.cid,
                "plan9_%ld.%d", lrand(), getpid());
            conf.cidlen = strlen((char*)conf.cid);
        }
}
@

<<function [[lookforip]]>>=
/* bind ip into the namespace */
void
lookforip(char *net)
{
    char proto[64];

    snprint(proto, sizeof proto, "%s/ipifc", net);
    if(access(proto, 0) == 0)
        return;
    sysfatal("no ip stack bound onto %s", net);
}
@

<<function [[controldevice]]>>=
/* send some ctls to a device */
void
controldevice(void)
{
    char ctlfile[256];
    int fd;
    Ctl *cp;

    if (firstctl == nil ||
        strcmp(conf.type, "ether") != 0 && strcmp(conf.type, "gbe") != 0)
        return;

    snprint(ctlfile, sizeof ctlfile, "%s/clone", conf.dev);
    fd = open(ctlfile, ORDWR);
    if(fd < 0)
        sysfatal("can't open %s", ctlfile);

    for(cp = firstctl; cp != nil; cp = cp->next){
        if(write(fd, cp->ctl, strlen(cp->ctl)) < 0)
            sysfatal("ctl message %s: %r", cp->ctl);
        seek(fd, 0, 0);
    }
//	close(fd);		/* or does it need to be left hanging? */
}
@

<<function [[binddevice]]>>=
/* bind an ip stack to a device, leave the control channel open */
void
binddevice(void)
{
    char buf[256];

    if(strcmp(conf.type, "ppp") == 0)
        pppbinddev();
    else if(myifc < 0){
        /* get a new ip interface */
        snprint(buf, sizeof buf, "%s/ipifc/clone", conf.mpoint);
        conf.cfd = open(buf, ORDWR);
        if(conf.cfd < 0)
            sysfatal("opening %s/ipifc/clone: %r", conf.mpoint);

        /* specify medium as ethernet, bind the interface to it */
        if(fprint(conf.cfd, "bind %s %s", conf.type, conf.dev) < 0)
            sysfatal("%s: bind %s %s: %r", buf, conf.type, conf.dev);
    } else {
        /* open the old interface */
        snprint(buf, sizeof buf, "%s/ipifc/%d/ctl", conf.mpoint, myifc);
        conf.cfd = open(buf, ORDWR);
        if(conf.cfd < 0)
            sysfatal("open %s: %r", buf);
    }

}
@

<<function [[ip4cfg]]>>=
/* add a logical interface to the ip stack */
int
ip4cfg(void)
{
    char buf[256];
    int n;

    if(!validip(conf.laddr))
        return -1;

    n = sprint(buf, "add");
    n += snprint(buf+n, sizeof buf-n, " %I", conf.laddr);

    if(!validip(conf.mask))
        ipmove(conf.mask, defmask(conf.laddr));
    n += snprint(buf+n, sizeof buf-n, " %I", conf.mask);

    if(validip(conf.raddr)){
        n += snprint(buf+n, sizeof buf-n, " %I", conf.raddr);
        if(conf.mtu != 0)
            n += snprint(buf+n, sizeof buf-n, " %d", conf.mtu);
    }

    if(write(conf.cfd, buf, n) < 0){
        warning("write(%s): %r", buf);
        return -1;
    }

    if(beprimary==1 && validip(conf.gaddr))
        adddefroute(conf.mpoint, conf.gaddr);

    return 0;
}
@

<<function [[ipunconfig]]>>=
/* remove a logical interface to the ip stack */
void
ipunconfig(void)
{
    char buf[256];
    int n;

    if(!validip(conf.laddr))
        return;
    DEBUG("couldn't renew IP lease, releasing %I", conf.laddr);
    n = sprint(buf, "remove");
    n += snprint(buf+n, sizeof buf-n, " %I", conf.laddr);

    if(!validip(conf.mask))
        ipmove(conf.mask, defmask(conf.laddr));
    n += snprint(buf+n, sizeof buf-n, " %I", conf.mask);

    write(conf.cfd, buf, n);

    ipmove(conf.laddr, IPnoaddr);
    ipmove(conf.raddr, IPnoaddr);
    ipmove(conf.mask, IPnoaddr);

    /* forget configuration info */
    if(beprimary==1)
        writendb("", 0, 0);
}
@

<<function [[ding]]>>=
void
ding(void*, char *msg)
{
    if(strstr(msg, "alarm"))
        noted(NCONT);
    noted(NDFLT);
}
@

<<function [[dhcpquery]]>>=
void
dhcpquery(int needconfig, int startstate)
{
    if(needconfig)
        fprint(conf.cfd, "add %I %I", IPnoaddr, IPnoaddr);

    conf.fd = openlisten();
    if(conf.fd < 0){
        conf.state = Sinit;
        return;
    }
    notify(ding);

    /* try dhcp for 10 seconds */
    conf.xid = lrand();
    conf.starttime = time(0);
    conf.state = startstate;
    switch(startstate){
    case Sselecting:
        conf.offered = 0;
        dhcpsend(Discover);
        break;
    case Srenewing:
        dhcpsend(Request);
        break;
    default:
        sysfatal("internal error 0");
    }
    conf.resend = 0;
    conf.timeout = time(0) + 4;

    while(conf.state != Sbound){
        dhcprecv();
        if(dhcptimer() < 0)
            break;
        if(time(0) - conf.starttime > 10)
            break;
    }
    close(conf.fd);

    if(needconfig)
        fprint(conf.cfd, "remove %I %I", IPnoaddr, IPnoaddr);

}
@

<<enum [[_anon_ (networking/ip/ipconfig/main.c)3]]>>=
enum {
    /*
     * was an hour, needs to be less for the ARM/GS1 until the timer
     * code has been cleaned up (pb).
     */
    Maxsleep = 450,
};
@

<<function [[dhcpwatch]]>>=
void
dhcpwatch(int needconfig)
{
    int secs, s;
    ulong t;

    if(nodhcpwatch)
        return;

    switch(rfork(RFPROC|RFFDG|RFNOWAIT|RFNOTEG)){
    default:
        return;
    case 0:
        break;
    }

    dolog = 1;			/* log, don't print */
    procsetname("dhcpwatch");
    /* keep trying to renew the lease */
    for(;;){
        if(conf.lease == 0)
            secs = 5;
        else
            secs = conf.lease >> 1;

        /* avoid overflows */
        for(s = secs; s > 0; s -= t){
            if(s > Maxsleep)
                t = Maxsleep;
            else
                t = s;
            sleep(t*1000);
        }

        if(conf.lease > 0){
            /*
             * during boot, the starttime can be bogus so avoid
             * spurious ipunconfig's
             */
            t = time(0) - conf.starttime;
            if(t > (3*secs)/2)
                t = secs;
            if(t >= conf.lease){
                conf.lease = 0;
                if(!noconfig){
                    ipunconfig();
                    needconfig = 1;
                }
            } else
                conf.lease -= t;
        }
        dhcpquery(needconfig, needconfig? Sselecting: Srenewing);

        if(needconfig && conf.state == Sbound){
            if(ip4cfg() < 0)
                sysfatal("can't start ip: %r");
            needconfig = 0;
            /*
             * leave everything we've learned somewhere that
             * other procs can find it.
             */
            if(beprimary==1){
                putndb();
                tweakservers();
            }
        }
    }
}
@

<<function [[dhcptimer]]>>=
int
dhcptimer(void)
{
    ulong now;

    now = time(0);
    if(now < conf.timeout)
        return 0;

    switch(conf.state) {
    default:
        sysfatal("dhcptimer: unknown state %d", conf.state);
    case Sinit:
    case Sbound:
        break;
    case Sselecting:
    case Srequesting:
    case Srebinding:
        dhcpsend(conf.state == Sselecting? Discover: Request);
        conf.timeout = now + 4;
        if(++conf.resend > 5) {
            conf.state = Sinit;
            return -1;
        }
        break;
    case Srenewing:
        dhcpsend(Request);
        conf.timeout = now + 1;
        if(++conf.resend > 3) {
            conf.state = Srebinding;
            conf.resend = 0;
        }
        break;
    }
    return 0;
}
@

<<function [[dhcpsend]]>>=
void
dhcpsend(int type)
{
    Bootp bp;
    uchar *p;
    int n;
    uchar vendor[64];
    Udphdr *up = (Udphdr*)bp.udphdr;

    memset(&bp, 0, sizeof bp);

    hnputs(up->rport, 67);
    bp.op = Bootrequest;
    hnputl(bp.xid, conf.xid);
    hnputs(bp.secs, time(0)-conf.starttime);
    hnputs(bp.flags, 0);
    memmove(bp.optmagic, optmagic, 4);
    if(conf.hwatype >= 0 && conf.hwalen < sizeof bp.chaddr){
        memmove(bp.chaddr, conf.hwa, conf.hwalen);
        bp.hlen = conf.hwalen;
        bp.htype = conf.hwatype;
    }
    p = bp.optdata;
    p = optaddbyte(p, ODtype, type);
    p = optadd(p, ODclientid, conf.cid, conf.cidlen);
    switch(type) {
    default:
        sysfatal("dhcpsend: unknown message type: %d", type);
    case Discover:
        ipmove(up->raddr, IPv4bcast);	/* broadcast */
        if(*conf.hostname && sendhostname)
            p = optaddstr(p, OBhostname, conf.hostname);
        if(plan9){
            n = snprint((char*)vendor, sizeof vendor,
                "plan9_%s", conf.cputype);
            p = optaddvec(p, ODvendorclass, vendor, n);
        }
        p = optaddvec(p, ODparams, requested, nrequested);
        if(validip(conf.laddr))
            p = optaddaddr(p, ODipaddr, conf.laddr);
        break;
    case Request:
        switch(conf.state){
        case Srenewing:
            ipmove(up->raddr, conf.server);
            v6tov4(bp.ciaddr, conf.laddr);
            break;
        case Srebinding:
            ipmove(up->raddr, IPv4bcast);	/* broadcast */
            v6tov4(bp.ciaddr, conf.laddr);
            break;
        case Srequesting:
            ipmove(up->raddr, IPv4bcast);	/* broadcast */
            p = optaddaddr(p, ODipaddr, conf.laddr);
            p = optaddaddr(p, ODserverid, conf.server);
            break;
        }
        p = optaddulong(p, ODlease, conf.offered);
        if(plan9){
            n = snprint((char*)vendor, sizeof vendor,
                "plan9_%s", conf.cputype);
            p = optaddvec(p, ODvendorclass, vendor, n);
        }
        p = optaddvec(p, ODparams, requested, nrequested);
        if(*conf.hostname && sendhostname)
            p = optaddstr(p, OBhostname, conf.hostname);
        break;
    case Release:
        ipmove(up->raddr, conf.server);
        v6tov4(bp.ciaddr, conf.laddr);
        p = optaddaddr(p, ODipaddr, conf.laddr);
        p = optaddaddr(p, ODserverid, conf.server);
        break;
    }

    *p++ = OBend;

    n = p - (uchar*)&bp;
    USED(n);

    /*
     *  We use a maximum size DHCP packet to survive the
     *  All_Aboard NAT package from Internet Share.  It
     *  always replies to DHCP requests with a packet of the
     *  same size, so if the request is too short the reply
     *  is truncated.
     */
    if(write(conf.fd, &bp, sizeof bp) != sizeof bp)
        warning("dhcpsend: write failed: %r");
}
@

<<function [[dhcprecv]]>>=
void
dhcprecv(void)
{
    int i, n, type;
    ulong lease;
    char err[ERRMAX];
    uchar buf[8000], vopts[256], taddr[IPaddrlen];
    Bootp *bp;

    memset(buf, 0, sizeof buf);
    alarm(1000);
    n = read(conf.fd, buf, sizeof buf);
    alarm(0);

    if(n < 0){
        rerrstr(err, sizeof err);
        if(strstr(err, "interrupt") == nil)
            warning("dhcprecv: bad read: %s", err);
        else
            DEBUG("dhcprecv: read timed out");
        return;
    }
    if(n == 0){
        warning("dhcprecv: zero-length packet read");
        return;
    }

    bp = parsebootp(buf, n);
    if(bp == 0) {
        DEBUG("parsebootp failed: dropping packet");
        return;
    }

    type = optgetbyte(bp->optdata, ODtype);
    switch(type) {
    default:
        warning("dhcprecv: unknown type: %d", type);
        break;
    case Offer:
        DEBUG("got offer from %V ", bp->siaddr);
        if(conf.state != Sselecting){
//			DEBUG("");
            break;
        }
        lease = optgetulong(bp->optdata, ODlease);
        if(lease == 0){
            /*
             * The All_Aboard NAT package from Internet Share
             * doesn't give a lease time, so we have to assume one.
             */
            warning("Offer with %lud lease, using %d", lease, MinLease);
            lease = MinLease;
        }
        DEBUG("lease=%lud ", lease);
        if(!optgetaddr(bp->optdata, ODserverid, conf.server)) {
            warning("Offer from server with invalid serverid");
            break;
        }

        v4tov6(conf.laddr, bp->yiaddr);
        memmove(conf.sname, bp->sname, sizeof conf.sname);
        conf.sname[sizeof conf.sname-1] = 0;
        DEBUG("server=%I sname=%s", conf.server, conf.sname);
        conf.offered = lease;
        conf.state = Srequesting;
        dhcpsend(Request);
        conf.resend = 0;
        conf.timeout = time(0) + 4;
        break;
    case Ack:
        DEBUG("got ack from %V ", bp->siaddr);
        if (conf.state != Srequesting && conf.state != Srenewing &&
            conf.state != Srebinding)
            break;

        /* ignore a bad lease */
        lease = optgetulong(bp->optdata, ODlease);
        if(lease == 0){
            /*
             * The All_Aboard NAT package from Internet Share
             * doesn't give a lease time, so we have to assume one.
             */
            warning("Ack with %lud lease, using %d", lease, MinLease);
            lease = MinLease;
        }
        DEBUG("lease=%lud ", lease);

        /* address and mask */
        if(!validip(conf.laddr) || !Oflag)
            v4tov6(conf.laddr, bp->yiaddr);
        if(!validip(conf.mask) || !Oflag){
            if(!optgetaddr(bp->optdata, OBmask, conf.mask))
                ipmove(conf.mask, IPnoaddr);
        }
        DEBUG("ipaddr=%I ipmask=%M ", conf.laddr, conf.mask);

        /*
         * get a router address either from the router option
         * or from the router that forwarded the dhcp packet
         */
        if(validip(conf.gaddr) && Oflag) {
            DEBUG("ipgw=%I ", conf.gaddr);
        } else if(optgetaddr(bp->optdata, OBrouter, conf.gaddr)){
            DEBUG("ipgw=%I ", conf.gaddr);
        } else if(memcmp(bp->giaddr, IPnoaddr+IPv4off, IPv4addrlen)!=0){
            v4tov6(conf.gaddr, bp->giaddr);
            DEBUG("giaddr=%I ", conf.gaddr);
        }

        /* get dns servers */
        memset(conf.dns, 0, sizeof conf.dns);
        n = optgetaddrs(bp->optdata, OBdnserver, conf.dns,
            sizeof conf.dns/IPaddrlen);
        for(i = 0; i < n; i++)
            DEBUG("dns=%I ", conf.dns + i*IPaddrlen);

        /* get ntp servers */
        memset(conf.ntp, 0, sizeof conf.ntp);
        n = optgetaddrs(bp->optdata, OBntpserver, conf.ntp,
            sizeof conf.ntp/IPaddrlen);
        for(i = 0; i < n; i++)
            DEBUG("ntp=%I ", conf.ntp + i*IPaddrlen);

        /* get names */
        optgetstr(bp->optdata, OBhostname,
            conf.hostname, sizeof conf.hostname);
        optgetstr(bp->optdata, OBdomainname,
            conf.domainname, sizeof conf.domainname);

        /* get anything else we asked for */
        getoptions(bp->optdata);

        /* get plan9-specific options */
        n = optgetvec(bp->optdata, OBvendorinfo, vopts, sizeof vopts-1);
        if(n > 0 && parseoptions(vopts, n) == 0){
            if(validip(conf.fs) && Oflag)
                n = 1;
            else {
                n = optgetp9addrs(vopts, OP9fs, conf.fs, 2);
                if (n == 0)
                    n = optgetaddrs(vopts, OP9fsv4,
                        conf.fs, 2);
            }
            for(i = 0; i < n; i++)
                DEBUG("fs=%I ", conf.fs + i*IPaddrlen);

            if(validip(conf.auth) && Oflag)
                n = 1;
            else {
                n = optgetp9addrs(vopts, OP9auth, conf.auth, 2);
                if (n == 0)
                    n = optgetaddrs(vopts, OP9authv4,
                        conf.auth, 2);
            }
            for(i = 0; i < n; i++)
                DEBUG("auth=%I ", conf.auth + i*IPaddrlen);

            n = optgetp9addrs(vopts, OP9ipaddr, taddr, 1);
            if (n > 0)
                memmove(conf.laddr, taddr, IPaddrlen);
            n = optgetp9addrs(vopts, OP9ipmask, taddr, 1);
            if (n > 0)
                memmove(conf.mask, taddr, IPaddrlen);
            n = optgetp9addrs(vopts, OP9ipgw, taddr, 1);
            if (n > 0)
                memmove(conf.gaddr, taddr, IPaddrlen);
            DEBUG("new ipaddr=%I new ipmask=%M new ipgw=%I",
                conf.laddr, conf.mask, conf.gaddr);
        }
        conf.lease = lease;
        conf.state = Sbound;
        DEBUG("server=%I sname=%s", conf.server, conf.sname);
        break;
    case Nak:
        conf.state = Sinit;
        warning("recved dhcpnak on %s", conf.mpoint);
        break;
    }
}
@

<<function [[randint]]>>=
/* return pseudo-random integer in range low...(hi-1) */
ulong
randint(ulong low, ulong hi)
{
    if (hi < low)
        return low;
    return low + nrand(hi - low);
}
@

<<function [[jitter]]>>=
long
jitter(void)		/* compute small pseudo-random delay in ms */
{
    return randint(0, 10*1000);
}
@

<<function [[openlisten]]>>=
int
openlisten(void)
{
    int n, fd, cfd;
    char data[128], devdir[40];

    if (validip(conf.laddr) &&
        (conf.state == Srenewing || conf.state == Srebinding))
        sprint(data, "%s/udp!%I!68", conf.mpoint, conf.laddr);
    else
        sprint(data, "%s/udp!*!68", conf.mpoint);
    for (n = 0; (cfd = announce(data, devdir)) < 0; n++) {
        if(!noconfig)
            sysfatal("can't announce for dhcp: %r");

        /* might be another client - wait and try again */
        warning("can't announce %s: %r", data);
        sleep(jitter());
        if(n > 10)
            return -1;
    }

    if(fprint(cfd, "headers") < 0)
        sysfatal("can't set header mode: %r");

    sprint(data, "%s/data", devdir);
    fd = open(data, ORDWR);
    if(fd < 0)
        sysfatal("open %s: %r", data);
    close(cfd);
    return fd;
}
@

<<function [[optadd]]>>=
uchar*
optadd(uchar *p, int op, void *d, int n)
{
    p[0] = op;
    p[1] = n;
    memmove(p+2, d, n);
    return p+n+2;
}
@

<<function [[optaddbyte]]>>=
uchar*
optaddbyte(uchar *p, int op, int b)
{
    p[0] = op;
    p[1] = 1;
    p[2] = b;
    return p+3;
}
@

<<function [[optaddulong]]>>=
uchar*
optaddulong(uchar *p, int op, ulong x)
{
    p[0] = op;
    p[1] = 4;
    hnputl(p+2, x);
    return p+6;
}
@

<<function [[optaddaddr]]>>=
uchar *
optaddaddr(uchar *p, int op, uchar *ip)
{
    p[0] = op;
    p[1] = 4;
    v6tov4(p+2, ip);
    return p+6;
}
@

<<function [[optaddvec]]>>=
/* add dhcp option op with value v of length n to dhcp option array p */
uchar *
optaddvec(uchar *p, int op, uchar *v, int n)
{
    p[0] = op;
    p[1] = n;
    memmove(p+2, v, n);
    return p+2+n;
}
@

<<function [[optaddstr]]>>=
uchar *
optaddstr(uchar *p, int op, char *v)
{
    int n;

    n = strlen(v)+1;	/* microsoft leaves on the NUL, so we do too */
    p[0] = op;
    p[1] = n;
    memmove(p+2, v, n);
    return p+2+n;
}
@

<<function [[optget]]>>=
/*
 * parse p, looking for option `op'.  if non-nil, np points to minimum length.
 * return nil if option is too small, else ptr to opt, and
 * store actual length via np if non-nil.
 */
uchar*
optget(uchar *p, int op, int *np)
{
    int len, code;

    while ((code = *p++) != OBend) {
        if(code == OBpad)
            continue;
        len = *p++;
        if(code != op) {
            p += len;
            continue;
        }
        if(np != nil){
            if(*np > len) {
                return 0;
            }
            *np = len;
        }
        return p;
    }
    return 0;
}
@

<<function [[optgetbyte]]>>=
int
optgetbyte(uchar *p, int op)
{
    int len;

    len = 1;
    p = optget(p, op, &len);
    if(p == nil)
        return 0;
    return *p;
}
@

<<function [[optgetulong]]>>=
ulong
optgetulong(uchar *p, int op)
{
    int len;

    len = 4;
    p = optget(p, op, &len);
    if(p == nil)
        return 0;
    return nhgetl(p);
}
@

<<function [[optgetaddr]]>>=
int
optgetaddr(uchar *p, int op, uchar *ip)
{
    int len;

    len = 4;
    p = optget(p, op, &len);
    if(p == nil)
        return 0;
    v4tov6(ip, p);
    return 1;
}
@

<<function [[optgetaddrs]]>>=
/* expect at most n addresses; ip[] only has room for that many */
int
optgetaddrs(uchar *p, int op, uchar *ip, int n)
{
    int len, i;

    len = 4;
    p = optget(p, op, &len);
    if(p == nil)
        return 0;
    len /= IPv4addrlen;
    if(len > n)
        len = n;
    for(i = 0; i < len; i++)
        v4tov6(&ip[i*IPaddrlen], &p[i*IPv4addrlen]);
    return i;
}
@

<<function [[optgetp9addrs]]>>=
/* expect at most n addresses; ip[] only has room for that many */
int
optgetp9addrs(uchar *ap, int op, uchar *ip, int n)
{
    int len, i, slen, addrs;
    char *p;

    len = 1;			/* minimum bytes needed */
    p = (char *)optget(ap, op, &len);
    if(p == nil)
        return 0;
    addrs = *p++;			/* first byte is address count */
    for (i = 0; i < n  && i < addrs && len > 0; i++) {
        slen = strlen(p) + 1;
        if (parseip(&ip[i*IPaddrlen], p) == -1)
            fprint(2, "%s: bad address %s\n", argv0, p);
        DEBUG("got plan 9 option %d addr %I (%s)",
            op, &ip[i*IPaddrlen], p);
        p += slen;
        len -= slen;
    }
    return addrs;
}
@

<<function [[optgetvec]]>>=
int
optgetvec(uchar *p, int op, uchar *v, int n)
{
    int len;

    len = 1;
    p = optget(p, op, &len);
    if(p == nil)
        return 0;
    if(len > n)
        len = n;
    memmove(v, p, len);
    return len;
}
@

<<function [[optgetstr]]>>=
int
optgetstr(uchar *p, int op, char *s, int n)
{
    int len;

    len = 1;
    p = optget(p, op, &len);
    if(p == nil)
        return 0;
    if(len >= n)
        len = n-1;
    memmove(s, p, len);
    s[len] = 0;
    return len;
}
@

<<function [[parseoptions]]>>=
/*
 * sanity check options area
 * 	- options don't overflow packet
 * 	- options end with an OBend
 */
int
parseoptions(uchar *p, int n)
{
    int code, len, nin = n;

    while (n > 0) {
        code = *p++;
        n--;
        if(code == OBend)
            return 0;
        if(code == OBpad)
            continue;
        if(n == 0) {
            warning("parseoptions: bad option: 0x%ux: truncated: "
                "opt length = %d", code, nin);
            return -1;
        }

        len = *p++;
        n--;
        DEBUG("parseoptions: %s(%d) len %d, bytes left %d",
            option[code].name, code, len, n);
        if(len > n) {
            warning("parseoptions: bad option: 0x%ux: %d > %d: "
                "opt length = %d", code, len, n, nin);
            return -1;
        }
        p += len;
        n -= len;
    }

    /* make sure packet ends with an OBend after all the optget code */
    *p = OBend;
    return 0;
}
@

<<function [[parsebootp]]>>=
/*
 * sanity check received packet:
 * 	- magic is dhcp magic
 * 	- options don't overflow packet
 */
Bootp *
parsebootp(uchar *p, int n)
{
    Bootp *bp;

    bp = (Bootp*)p;
    if(n < bp->optmagic - p) {
        warning("parsebootp: short bootp packet; with options, "
            "need %d bytes, got %d", bp->optmagic - p, n);
        return nil;
    }

    if(conf.xid != nhgetl(bp->xid))		/* not meant for us */
        return nil;

    if(bp->op != Bootreply) {
        warning("parsebootp: bad op %d", bp->op);
        return nil;
    }

    n -= bp->optmagic - p;
    p = bp->optmagic;

    if(n < 4) {
        warning("parsebootp: no option data");
        return nil;
    }
    if(memcmp(optmagic, p, 4) != 0) {
        warning("parsebootp: bad opt magic %ux %ux %ux %ux",
            p[0], p[1], p[2], p[3]);
        return nil;
    }
    p += 4;
    n -= 4;
    DEBUG("parsebootp: new packet");
    if(parseoptions(p, n) < 0)
        return nil;
    return bp;
}
@

<<function [[writendb]]>>=
/* write out an ndb entry */
void
writendb(char *s, int n, int append)
{
    char file[64];
    int fd;

    snprint(file, sizeof file, "%s/ndb", conf.mpoint);
    if(append){
        fd = open(file, OWRITE);
        seek(fd, 0, 2);
    } else
        fd = open(file, OWRITE|OTRUNC);
    write(fd, s, n);
    close(fd);
}
@

<<function [[putaddrs]]>>=
/* put server addresses into the ndb entry */
char*
putaddrs(char *p, char *e, char *attr, uchar *a, int len)
{
    int i;

    for(i = 0; i < len && validip(a); i += IPaddrlen, a += IPaddrlen)
        p = seprint(p, e, "%s=%I\n", attr, a);
    return p;
}
@

<<function [[putndb]]>>=
/* make an ndb entry and put it into /net/ndb for the servers to see */
void
putndb(void)
{
    int append;
    char buf[1024];
    char *p, *e, *np;

    p = buf;
    e = buf + sizeof buf;
    if(getndb() == 0)
        append = 1;
    else {
        append = 0;
        p = seprint(p, e, "ip=%I ipmask=%M ipgw=%I\n",
            conf.laddr, conf.mask, conf.gaddr);
    }
    if(np = strchr(conf.hostname, '.')){
        if(*conf.domainname == 0)
            strcpy(conf.domainname, np+1);
        *np = 0;
    }
    if(*conf.hostname)
        p = seprint(p, e, "\tsys=%s\n", conf.hostname);
    if(*conf.domainname)
        p = seprint(p, e, "\tdom=%s.%s\n",
            conf.hostname, conf.domainname);
    if(validip(conf.fs))
        p = putaddrs(p, e, "\tfs", conf.fs, sizeof conf.fs);
    if(validip(conf.auth))
        p = putaddrs(p, e, "\tauth", conf.auth, sizeof conf.auth);
    if(validip(conf.dns))
        p = putaddrs(p, e, "\tdns", conf.dns, sizeof conf.dns);
    if(validip(conf.ntp))
        p = putaddrs(p, e, "\tntp", conf.ntp, sizeof conf.ntp);
    if(ndboptions)
        p = seprint(p, e, "%s\n", ndboptions);
    if(p > buf)
        writendb(buf, p-buf, append);
}
@

<<function [[getndb]]>>=
/* get an ndb entry someone else wrote */
int
getndb(void)
{
    char buf[1024];
    int fd, n;
    char *p;

    snprint(buf, sizeof buf, "%s/ndb", conf.mpoint);
    fd = open(buf, OREAD);
    n = read(fd, buf, sizeof buf-1);
    close(fd);
    if(n <= 0)
        return -1;
    buf[n] = 0;
    p = strstr(buf, "ip=");
    if(p == nil)
        return -1;
    if (parseip(conf.laddr, p+3) == -1)
        fprint(2, "%s: bad address %s\n", argv0, p+3);
    return 0;
}
@

<<function [[tweakserver]]>>=
/* tell a server to refresh */
void
tweakserver(char *server)
{
    int fd;
    char file[64];

    snprint(file, sizeof file, "%s/%s", conf.mpoint, server);
    fd = open(file, ORDWR);
    if(fd < 0)
        return;
    fprint(fd, "refresh");
    close(fd);
}
@

<<function [[tweakservers]]>>=
/* tell all servers to refresh their information */
void
tweakservers(void)
{
    tweakserver("dns");
    tweakserver("cs");
}
@

<<function [[nipifcs]]>>=
/* return number of networks */
int
nipifcs(char *net)
{
    int n;
    Ipifc *nifc;
    Iplifc *lifc;

    n = 0;
    ifc = readipifc(net, ifc, -1);
    for(nifc = ifc; nifc != nil; nifc = nifc->next){
        /*
         * ignore loopback devices when trying to
         * figure out if we're the primary interface.
         */
        if(strcmp(nifc->dev, "/dev/null") != 0)
            for(lifc = nifc->lifc; lifc != nil; lifc = lifc->next)
                if(validip(lifc->ip)){
                    n++;
                    break;
                }
        if(strcmp(nifc->dev, conf.dev) == 0)
            myifc = nifc->index;
    }
    return n;
}
@

<<function [[validip]]>>=
/* return true if this is a valid v4 address */
int
validip(uchar *addr)
{
    return ipcmp(addr, IPnoaddr) != 0 && ipcmp(addr, v4prefix) != 0;
}
@

<<function [[parseverb]]>>=
/* look for an action */
int
parseverb(char *name)
{
    int i;

    for(i = 0; i < nelem(verbs); i++)
        if(verbs[i] != nil && strcmp(name, verbs[i]) == 0)
            return i;
    return -1;
}
@

<<function [[ndbconfig]]>>=
/* get everything out of ndb */
void
ndbconfig(void)
{
    int nattr, nauth = 0, ndns = 0, nfs = 0, ok;
    char etheraddr[32];
    char *attrs[10];
    Ndb *db;
    Ndbtuple *t, *nt;

    db = ndbopen(0);
    if(db == nil)
        sysfatal("can't open ndb: %r");
    if (strcmp(conf.type, "ether") != 0 && strcmp(conf.type, "gbe") != 0 ||
        myetheraddr(conf.hwa, conf.dev) != 0)
        sysfatal("can't read hardware address");
    sprint(etheraddr, "%E", conf.hwa);
    nattr = 0;
    attrs[nattr++] = "ip";
    attrs[nattr++] = "ipmask";
    attrs[nattr++] = "ipgw";
    /* the @ triggers resolution to an IP address; see ndb(2) */
    attrs[nattr++] = "@dns";
    attrs[nattr++] = "@ntp";
    attrs[nattr++] = "@fs";
    attrs[nattr++] = "@auth";
    attrs[nattr] = nil;
    t = ndbipinfo(db, "ether", etheraddr, attrs, nattr);
    for(nt = t; nt != nil; nt = nt->entry) {
        ok = 1;
        if(strcmp(nt->attr, "ip") == 0)
            ok = parseip(conf.laddr, nt->val);
        else if(strcmp(nt->attr, "ipmask") == 0)
            parseipmask(conf.mask, nt->val);  /* could be -1 */
        else if(strcmp(nt->attr, "ipgw") == 0)
            ok = parseip(conf.gaddr, nt->val);
        else if(ndns < 2 && strcmp(nt->attr, "dns") == 0)
            ok = parseip(conf.dns+IPaddrlen*ndns, nt->val);
        else if(strcmp(nt->attr, "ntp") == 0)
            ok = parseip(conf.ntp, nt->val);
        else if(nfs < 2 && strcmp(nt->attr, "fs") == 0)
            ok = parseip(conf.fs+IPaddrlen*nfs, nt->val);
        else if(nauth < 2 && strcmp(nt->attr, "auth") == 0)
            ok = parseip(conf.auth+IPaddrlen*nauth, nt->val);
        if (!ok)
            fprint(2, "%s: bad %s address in ndb: %s\n", argv0,
                nt->attr, nt->val);
    }
    ndbfree(t);
    if(!validip(conf.laddr))
        sysfatal("address not found in ndb");
}
@

<<function [[addoption]]>>=
int
addoption(char *opt)
{
    int i;
    Option *o;

    if(opt == nil)
        return -1;
    for(o = option; o < &option[nelem(option)]; o++)
        if(o->name && strcmp(opt, o->name) == 0){
            i = o - option;
            if(memchr(requested, i, nrequested) == 0 &&
                nrequested < nelem(requested))
                requested[nrequested++] = i;
            return 0;
        }
    return -1;
}
@

<<function [[optgetx]]>>=
char*
optgetx(uchar *p, uchar opt)
{
    int i, n;
    ulong x;
    char *s, *ns;
    char str[256];
    uchar ip[IPaddrlen], ips[16*IPaddrlen], vec[256];
    Option *o;

    o = &option[opt];
    if(o->name == nil)
        return nil;

    s = nil;
    switch(o->type){
    case Taddr:
        if(optgetaddr(p, opt, ip))
            s = smprint("%s=%I", o->name, ip);
        break;
    case Taddrs:
        n = optgetaddrs(p, opt, ips, 16);
        if(n > 0)
            s = smprint("%s=%I", o->name, ips);
        for(i = 1; i < n; i++){
            ns = smprint("%s %s=%I", s, o->name, &ips[i*IPaddrlen]);
            free(s);
            s = ns;
        }
        break;
    case Tulong:
        x = optgetulong(p, opt);
        if(x != 0)
            s = smprint("%s=%lud", o->name, x);
        break;
    case Tbyte:
        x = optgetbyte(p, opt);
        if(x != 0)
            s = smprint("%s=%lud", o->name, x);
        break;
    case Tstr:
        if(optgetstr(p, opt, str, sizeof str))
            s = smprint("%s=%s", o->name, str);
        break;
    case Tvec:
        n = optgetvec(p, opt, vec, sizeof vec);
        if(n > 0)
            /* what's %H?  it's not installed */
            s = smprint("%s=%.*H", o->name, n, vec);
        break;
    }
    return s;
}
@

<<function [[getoptions]]>>=
void
getoptions(uchar *p)
{
    int i;
    char *s, *t;

    for(i = nelem(defrequested); i < nrequested; i++){
        s = optgetx(p, requested[i]);
        if(s != nil)
            DEBUG("%s ", s);
        if(ndboptions == nil)
            ndboptions = smprint("\t%s", s);
        else{
            t = ndboptions;
            ndboptions = smprint("\t%s%s", s, ndboptions);
            free(t);
        }
        free(s);
    }
}
@


%-------------------------------------------------------------

<<networking/ip/ipconfig/main.c>>=
/*
 * ipconfig - configure parameters of an ip stack
 */
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include "../dhcp.h"
#include "ipconfig.h"

<<constant [[DEBUG]]>>

<<enum [[_anon_ (networking/ip/ipconfig/main.c)]]>>

<<enum [[_anon_ (networking/ip/ipconfig/main.c)2]]>>

typedef struct Option Option;
<<struct [[Option]]>>

<<global [[option]]>>

<<global [[defrequested]]>>

<<global [[requested]]>>
<<global [[nrequested]]>>

<<global [[Oflag]]>>
<<global [[beprimary]]>>
<<global [[conf]]>>
<<global [[debug]]([[(networking/ip/ipconfig/main.c)]])>>
<<global [[dodhcp]]>>
<<global [[dolog]]>>
<<global [[dondbconfig]]>>
<<global [[dupl_disc]]>>
Ctl	*firstctl, **ctll;
<<global [[ifc]]>>
<<global [[ipv6auto]]>>
<<global [[myifc]]>>
<<global [[ndboptions]]>>
<<global [[nip]]>>
<<global [[noconfig]]>>
<<global [[nodhcpwatch]]>>
<<global [[optmagic]]>>
<<global [[plan9]]>>
<<global [[sendhostname]]>>

<<global [[logfile]]>>

<<global [[verbs]]>>

void	adddefroute(char*, uchar*);
int	addoption(char*);
void	binddevice(void);
void	bootprequest(void);
void	controldevice(void);
void	dhcpquery(int, int);
void	dhcprecv(void);
void	dhcpsend(int);
int	dhcptimer(void);
void	dhcpwatch(int);
void	doadd(int);
void	doremove(void);
void	dounbind(void);
int	getndb(void);
void	getoptions(uchar*);
int	ip4cfg(void);
int	ip6cfg(int a);
void	lookforip(char*);
void	mkclientid(void);
void	ndbconfig(void);
int	nipifcs(char*);
int	openlisten(void);
uchar*	optaddaddr(uchar*, int, uchar*);
uchar*	optaddbyte(uchar*, int, int);
uchar*	optaddstr(uchar*, int, char*);
uchar*	optadd(uchar*, int, void*, int);
uchar*	optaddulong(uchar*, int, ulong);
uchar*	optaddvec(uchar*, int, uchar*, int);
int	optgetaddrs(uchar*, int, uchar*, int);
int	optgetp9addrs(uchar*, int, uchar*, int);
int	optgetaddr(uchar*, int, uchar*);
int	optgetbyte(uchar*, int);
int	optgetstr(uchar*, int, char*, int);
uchar*	optget(uchar*, int, int*);
ulong	optgetulong(uchar*, int);
int	optgetvec(uchar*, int, uchar*, int);
char*	optgetx(uchar*, uchar);
Bootp*	parsebootp(uchar*, int);
int	parseoptions(uchar *p, int n);
int	parseverb(char*);
void	pppbinddev(void);
void	putndb(void);
void	tweakservers(void);
void	usage(void);
int	validip(uchar*);
void	writendb(char*, int, int);

<<function [[usage]]([[(networking/ip/ipconfig/main.c)]])>>

<<function [[warning]]>>

<<function [[parsenorm]]>>

<<function [[parse6pref]]>>

<<function [[parse6ra]]>>

<<function [[init]]>>

<<function [[parseargs]]>>

<<function [[main]]([[(networking/ip/ipconfig/main.c)]])>>

<<function [[havendb]]>>

<<function [[doadd]]>>

<<function [[doremove]]>>

<<function [[dounbind]]>>

<<function [[adddefroute]]>>

<<function [[mkclientid]]>>

<<function [[lookforip]]>>

<<function [[controldevice]]>>

<<function [[binddevice]]>>

<<function [[ip4cfg]]>>

<<function [[ipunconfig]]>>

<<function [[ding]]>>

<<function [[dhcpquery]]>>

<<enum [[_anon_ (networking/ip/ipconfig/main.c)3]]>>

<<function [[dhcpwatch]]>>

<<function [[dhcptimer]]>>

<<function [[dhcpsend]]>>

<<function [[dhcprecv]]>>

<<function [[randint]]>>

<<function [[jitter]]>>

<<function [[openlisten]]>>

<<function [[optadd]]>>

<<function [[optaddbyte]]>>

<<function [[optaddulong]]>>

<<function [[optaddaddr]]>>

<<function [[optaddvec]]>>

<<function [[optaddstr]]>>

<<function [[optget]]>>

<<function [[optgetbyte]]>>

<<function [[optgetulong]]>>

<<function [[optgetaddr]]>>

<<function [[optgetaddrs]]>>

<<function [[optgetp9addrs]]>>

<<function [[optgetvec]]>>

<<function [[optgetstr]]>>

<<function [[parseoptions]]>>

<<function [[parsebootp]]>>

<<function [[writendb]]>>

<<function [[putaddrs]]>>

<<function [[putndb]]>>

<<function [[getndb]]>>

<<function [[tweakserver]]>>

<<function [[tweakservers]]>>

<<function [[nipifcs]]>>

<<function [[validip]]>>

<<function [[parseverb]]>>

<<function [[ndbconfig]]>>

<<function [[addoption]]>>

<<function [[optgetx]]>>

<<function [[getoptions]]>>
@


\subsection*{[[networking/ip/ipconfig/ppp.c]]}

<<function [[pppbinddev]]>>=
void
pppbinddev(void)
{
    int ac, pid;
    char *av[12];
    Waitmsg *w;

    /* ppp does the binding */

    /* start with an empty config file */
    if(nip == 0)
        writendb("", 0, 0);

    switch(pid = rfork(RFPROC|RFFDG|RFMEM)){
    case -1:
        sysfatal("can't start ppp: %r");
    case 0:
        ac = 0;
        av[ac++] = "ppp";
        av[ac++] = "-uf";
        av[ac++] = "-p";
        av[ac++] = conf.dev;
        av[ac++] = "-x";
        av[ac++] = conf.mpoint;
        if(conf.baud != nil){
            av[ac++] = "-b";
            av[ac++] = conf.baud;
        }
        av[ac] = nil;
        exec("/bin/ip/ppp", av);
        exec("/ppp", av);
        sysfatal("execing /ppp: %r");
    }

    /* wait for ppp to finish connecting and configuring */
    while((w = wait()) != nil){
        if(w->pid == pid){
            if(w->msg[0] != 0)
                sysfatal("/ppp exited with status: %s", w->msg);
            free(w);
            break;
        }
        free(w);
    }
    if(w == nil)
        sysfatal("/ppp disappeared");

    /* ppp sets up the configuration itself */
    noconfig = 1;
    getndb();
}
@


%-------------------------------------------------------------

<<networking/ip/ipconfig/ppp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include "../dhcp.h"
#include "ipconfig.h"

<<function [[pppbinddev]]>>

@


\section{[[networking/ip/]]}

\subsection*{[[networking/ip/rip.c]]}

<<enum [[_anon_ (networking/ip/rip.c)]]>>=
enum
{
    Version=	1,
    Pasize=		4,

    /*
     *  definitions that are innately tied to BSD
     */
    AF_INET=	2,
    AF_UNSPEC=	0,

    /*
     *  Packet types.
     */
    Request=	1,
    Response=	2,
    Traceon=	3,
    Traceoff=	4,

    Infinity=	16,	/* infinite hop count */
    Maxpacket=	488,	/* largest packet body */
};
@

<<struct [[Rip]]>>=
struct Rip
{
    uchar	family[2];
    uchar	port[2];
    uchar	addr[Pasize];
    uchar	pad[8];
    uchar	metric[4];
};
@

<<struct [[Ripmsg]]>>=
struct Ripmsg
{
    uchar	type;
    uchar	vers;
    uchar	pad[2];
    Rip	rip[1];		/* the rest of the packet consists of routes */
};
@

<<enum [[_anon_ (networking/ip/rip.c)2]]>>=
enum
{
    Maxroutes=	(Maxpacket-4)/sizeof(Ripmsg),
};
@

<<enum [[_anon_ (networking/ip/rip.c)3]]>>=
/*
 *  internal route info
 */
enum
{
    Nroute=	2048,		/* this has to be smaller than what /ip has */
    Nhash=	256,		/* routing hash buckets */
    Nifc=	16,
};
@

<<struct [[Route]]([[(networking/ip/rip.c)]])>>=
struct Route
{
    Route	*next;

    uchar	dest[Pasize];
    uchar	mask[Pasize];
    uchar	gate[Pasize];
    int	metric;
    int	inuse;
    long	time;
};
@

<<global [[ralloc]]>>=
struct {
    Route	route[Nroute];
    Route	*hash[Nhash];
    int	nroute;
    Route	def;	/* default route (immutable by us) */
} ralloc;
@

<<struct [[Ifc]]>>=
struct Ifc
{
    int	bcast;
    uchar	addr[Pasize];	/* my address */
    uchar	mask[Pasize];	/* subnet mask */
    uchar	net[Pasize];	/* subnet */
    uchar	*cmask;		/* class mask */
    uchar	cnet[Pasize];	/* class net */
};
@

<<global [[ialloc]]>>=
struct {
    Ifc	ifc[Nifc];
    int	nifc;
} ialloc;
@

<<struct [[Bnet]]>>=
struct Bnet
{
    Bnet	*next;
    uchar	addr[Pasize];
};
@

<<global [[bnets]]>>=
Bnet	*bnets;
@

<<global [[ripfd]]>>=
int	ripfd;
@

<<global [[now]]>>=
long	now;
@

<<global [[debug]]([[(networking/ip/rip.c)]])>>=
int	debug;
@

<<global [[readonly]]>>=
int	readonly;
@

<<global [[routefile]]>>=
char	routefile[256];
@

<<global [[netdir]]>>=
char	netdir[256];
@

<<function [[fatal]]>>=
void
fatal(int syserr, char *fmt, ...)
{
    char buf[ERRMAX], sysbuf[ERRMAX];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    if(syserr) {
        errstr(sysbuf, sizeof sysbuf);
        fprint(2, "routed: %s: %s\n", buf, sysbuf);
    }
    else
        fprint(2, "routed: %s\n", buf);
    exits(buf);
}
@

<<function [[v4parseipmask]]>>=
ulong
v4parseipmask(uchar *ip, char *p)
{
    ulong x;
    uchar v6ip[IPaddrlen];

    x = parseipmask(v6ip, p);
    memmove(ip, v6ip+IPv4off, 4);
    return x;
}
@

<<function [[v4defmask]]>>=
uchar*
v4defmask(uchar *ip)
{
    uchar v6ip[IPaddrlen];

    v4tov6(v6ip, ip);
    ip = defmask(v6ip);
    return ip+IPv4off;
}
@

<<function [[v4maskip]]>>=
void
v4maskip(uchar *from, uchar *mask, uchar *to)
{
    int i;

    for(i = 0; i < Pasize; i++)
        *to++ = *from++ & *mask++;
}
@

<<function [[v6tov4mask]]>>=
void
v6tov4mask(uchar *v4, uchar *v6)
{
    memmove(v4, v6+IPv4off, 4);
}
@

<<macro [[equivip]]>>=
#define equivip(a, b) (memcmp((a), (b), Pasize) == 0)
@

<<function [[ding]]([[(networking/ip/rip.c)]])>>=
void
ding(void *u, char *msg)
{
    USED(u);

    if(strstr(msg, "alarm"))
        noted(NCONT);
    noted(NDFLT);
}
@

<<function [[usage]]([[(networking/ip/rip.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-bnd] [-x netmtpt]\n", argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/rip.c)]])>>=
void
main(int argc, char *argv[])
{
    int dobroadcast, i, n;
    long diff;
    char *p;
    char buf[2*1024];
    uchar raddr[Pasize];
    Bnet *bn, **l;
    Udphdr *up;
    Rip *r;
    Ripmsg *m;
    Route route;
    static long btime;

    setnetmtpt(netdir, sizeof(netdir), nil);
    dobroadcast = 0;
    ARGBEGIN{
    case 'b':
        dobroadcast++;
        break;
    case 'd':
        debug++;
        break;
    case 'n':
        readonly++;
        break;
    case 'x':
        p = ARGF();
        if(p == nil)
            usage();
        setnetmtpt(netdir, sizeof(netdir), p);
        break;
    default:
        usage();
    }ARGEND

    /* specific broadcast nets */
    l = &bnets;
    while(argc > 0){
        bn = (Bnet*)malloc(sizeof(Bnet));
        if(bn == 0)
            fatal(1, "out of mem");
        v4parseip(bn->addr, *argv);
        *l = bn;
        l = &bn->next;
        argc--;
        argv++;
        dobroadcast++;
    }

    /* command returns */
    if(!debug)
        switch(rfork(RFNOTEG|RFPROC|RFFDG|RFNOWAIT)) {
        case -1:
            fatal(1, "fork");
        case 0:
            break;
        default:
            exits(0);
        }


    fmtinstall('E', eipfmt);
    fmtinstall('V', eipfmt);

    snprint(routefile, sizeof(routefile), "%s/iproute", netdir);
    snprint(buf, sizeof(buf), "%s/iproute", netdir);

    now = time(0);
    readifcs();
    readroutes();

    notify(ding);

    ripfd = openport();
    for(;;) {
        diff = btime - time(0);
        if(diff <= 0){
            if(dobroadcast)
                broadcast();
            timeoutroutes();

            btime = time(0) + 2*60;
            diff = 2*60;
        }
        alarm(diff*1000);
        n = read(ripfd, buf, sizeof(buf));
        alarm(0);
        if(n <= 0)
            continue;

        n = (n - Udphdrsize - 4) / sizeof(Rip);
        if(n <= 0)
            continue;

        up = (Udphdr*)buf;
        m = (Ripmsg*)(buf+Udphdrsize);
        if(m->type != Response || m->vers != Version)
            continue;
        v6tov4(raddr, up->raddr);

        /* ignore our own messages */
        for(i = 0; i < ialloc.nifc; i++)
            if(equivip(ialloc.ifc[i].addr, raddr))
                continue;

        now = time(0);
        for(r = m->rip; r < &m->rip[n]; r++){
            memmove(route.gate, raddr, Pasize);
            memmove(route.mask, getmask(r->addr), Pasize);
            v4maskip(r->addr, route.mask, route.dest);
            route.metric = nhgetl(r->metric) + 1;
            if(route.metric < 1)
                continue;
            considerroute(&route);
        }
    }
    /* not reached */
}
@

<<function [[openport]]>>=
int
openport(void)
{
    int ripctl, rip;
    char data[128], devdir[40];

    snprint(data, sizeof(data), "%s/udp!*!rip", netdir);
    ripctl = announce(data, devdir);
    if(ripctl < 0)
        fatal(1, "can't announce");
    if(fprint(ripctl, "headers") < 0)
        fatal(1, "can't set header mode");

    sprint(data, "%s/data", devdir);
    rip = open(data, ORDWR);
    if(rip < 0)
        fatal(1, "open udp data");
    return rip;
}
@

<<global [[ifcs]]>>=
Ipifc *ifcs;
@

<<function [[readifcs]]>>=
void
readifcs(void)
{
    Ipifc *ifc;
    Iplifc *lifc;
    Ifc *ip;
    Bnet *bn;
    Route route;
    int i;

    ifcs = readipifc(netdir, ifcs, -1);
    i = 0;
    for(ifc = ifcs; ifc != nil; ifc = ifc->next){
        for(lifc = ifc->lifc; lifc != nil && i < Nifc; lifc = lifc->next){
            // ignore any interfaces that aren't v4
            if(memcmp(lifc->ip, v4prefix, IPaddrlen-IPv4addrlen) != 0)
                continue;
            ip = &ialloc.ifc[i++];
            v6tov4(ip->addr, lifc->ip);
            v6tov4mask(ip->mask, lifc->mask);
            v6tov4(ip->net, lifc->net);
            ip->cmask = v4defmask(ip->net);
            v4maskip(ip->net, ip->cmask, ip->cnet);
            ip->bcast = 0;

            /* add as a route */
            memmove(route.mask, ip->mask, Pasize);
            memmove(route.dest, ip->net, Pasize);
            memset(route.gate, 0, Pasize);
            route.metric = 0;
            considerroute(&route);

            /* mark as broadcast */
            if(bnets == 0)
                ip->bcast = 1;
            else for(bn = bnets; bn; bn = bn->next)
                if(memcmp(bn->addr, ip->net, Pasize) == 0){
                    ip->bcast = 1;
                    break;
                }
        }
    }
    ialloc.nifc = i;
}
@

<<function [[readroutes]]>>=
void
readroutes(void)
{
    int n;
    char *p;
    Biobuf *b;
    char *f[6];
    Route route;

    b = Bopen(routefile, OREAD);
    if(b == 0)
        return;
    while(p = Brdline(b, '\n')){
        p[Blinelen(b)-1] = 0;
        n = getfields(p, f, 6, 1, " \t");
        if(n < 5)
            continue;
        v4parseip(route.dest, f[0]);
        v4parseipmask(route.mask, f[1]);
        v4parseip(route.gate, f[2]);
        route.metric = Infinity;
        if(equivip(route.dest, ralloc.def.dest)
        && equivip(route.mask, ralloc.def.mask))
            memmove(ralloc.def.gate, route.gate, Pasize);
        else if(!equivip(route.dest, route.gate) && strchr(f[3], 'i') == 0)
            considerroute(&route);
    }
    Bterm(b);
}
@

<<function [[rhash]]>>=
/*
 *  route's hashed by net, not subnet
 */
ulong
rhash(uchar *d)
{
    ulong h;
    uchar net[Pasize];

    v4maskip(d, v4defmask(d), net);
    h = net[0] + net[1] + net[2];
    return h % Nhash;
}
@

<<function [[considerroute]]>>=
/*
 *  consider installing a route.  Do so only if it is better than what
 *  we have.
 */
void
considerroute(Route *r)
{
    ulong h;
    Route *hp;

    if(debug)
        fprint(2, "consider %16V & %16V -> %16V %d\n", r->dest, r->mask, r->gate, r->metric);

    r->next = 0;
    r->time = now;
    r->inuse = 1;

    /* don't allow our default route to be highjacked */
    if(equivip(r->dest, ralloc.def.dest) || equivip(r->mask, ralloc.def.mask))
        return;

    h = rhash(r->dest);
    for(hp = ralloc.hash[h]; hp; hp = hp->next){
        if(equivip(hp->dest, r->dest)){
            /*
             *  found a match, replace if better (or much newer)
             */
            if(r->metric < hp->metric || now-hp->time > 5*60){
                removeroute(hp);
                memmove(hp->mask, r->mask, Pasize);
                memmove(hp->gate, r->gate, Pasize);
                hp->metric = r->metric;
                installroute(hp);
            }
            if(equivip(hp->gate, r->gate))
                hp->time = now;
            return;
        }
    }

    /*
     *  no match, look for space
     */
    for(hp = ralloc.route; hp < &ralloc.route[Nroute]; hp++)
        if(hp->inuse == 0)
            break;

    if(hp == 0)
        fatal(0, "no more routes");

    memmove(hp, r, sizeof(Route));
    hp->next = ralloc.hash[h];
    ralloc.hash[h] = hp;
    installroute(hp);
}
@

<<function [[removeroute]]>>=
void
removeroute(Route *r)
{
    int fd;

    fd = open(routefile, ORDWR);
    if(fd < 0){
        fprint(2, "can't open oproute\n");
        return;
    }
    if(!readonly)
        fprint(fd, "delete %V", r->dest);
    if(debug)
        fprint(2, "removeroute %V\n", r->dest);
    close(fd);
}
@

<<function [[installroute]]>>=
/*
 *  pass a route to the kernel or /ip.  Don't bother if it is just the default
 *  gateway.
 */
void
installroute(Route *r)
{
    int fd;
    ulong h;
    Route *hp;
    uchar net[Pasize];

    /*
     *  don't install routes whose gateway is 00000000
     */
    if(equivip(r->gate, ralloc.def.dest))
        return;

    fd = open(routefile, ORDWR);
    if(fd < 0){
        fprint(2, "can't open oproute\n");
        return;
    }
    h = rhash(r->dest);

    /*
     *  if the gateway is the same as the default gateway
     *  we may be able to avoid a entry in the kernel
     */
    if(equivip(r->gate, ralloc.def.gate)){
        /*
         *  look for a less specific match
         */
        for(hp = ralloc.hash[h]; hp; hp = hp->next){
            v4maskip(hp->mask, r->dest, net);
            if(equivip(net, hp->dest) && !equivip(hp->gate, ralloc.def.gate))
                break;
        }
        /*
         *  if no less specific match, just use the default
         */
        if(hp == 0){
            if(!readonly)
                fprint(fd, "delete %V", r->dest);
            if(debug)
                fprint(2, "delete %V\n", r->dest);
            close(fd);
            return;
        }
    }
    if(!readonly)
        fprint(fd, "add %V %V %V", r->dest, r->mask, r->gate);
    if(debug)
        fprint(2, "add %V & %V -> %V\n", r->dest, r->mask, r->gate);
    close(fd);
}
@

<<function [[onnet]]>>=
/*
 *  return true of dest is on net
 */
int
onnet(uchar *dest, uchar *net, uchar *netmask)
{
    uchar dnet[Pasize];

    v4maskip(dest, netmask, dnet);
    return equivip(dnet, net);
}
@

<<function [[getmask]]>>=
/*
 *  figure out what mask to use, if we have a direct connected network
 *  with the same class net use its subnet mask.
 */
uchar*
getmask(uchar *dest)
{
    int i;
    Ifc *ip;
    ulong mask, nmask;
    uchar *m;

    m = 0;
    mask = 0xffffffff;
    for(i = 0; i < ialloc.nifc; i++){
        ip = &ialloc.ifc[i];
        if(onnet(dest, ip->cnet, ip->cmask)){
            nmask = nhgetl(ip->mask);
            if(nmask < mask){
                mask = nmask;
                m = ip->mask;
            }
        }
    }

    if(m == 0)
        m = v4defmask(dest);
    return m;
}
@

<<function [[sendto]]>>=
/*
 *  broadcast routes onto all networks
 */
void
sendto(Ifc *ip)
{
    int h, n;
    uchar raddr[Pasize], mbuf[Udphdrsize+512];
    Ripmsg *m;
    Route *r;
    Udphdr *u;

    u = (Udphdr*)mbuf;
    for(n = 0; n < Pasize; n++)
        raddr[n] = ip->net[n] | ~(ip->mask[n]);
    v4tov6(u->raddr, raddr);
    hnputs(u->rport, 520);
    m = (Ripmsg*)(mbuf+Udphdrsize);
    m->type = Response;
    m->vers = Version;
    if(debug)
        fprint(2, "to %V\n", u->raddr);

    n = 0;
    for(h = 0; h < Nhash; h++){
        for(r = ralloc.hash[h]; r; r = r->next){
            /*
             *  don't send any route back to the net
             *  it came from
             */
            if(onnet(r->gate, ip->net, ip->mask))
                continue;

            /*
             *  don't tell a network about itself
             */
            if(equivip(r->dest, ip->net))
                continue;

            /*
             *  don't tell nets about other net's subnets
             */
            if(!equivip(r->mask, v4defmask(r->dest))
            && !equivip(ip->cmask, v4defmask(r->dest)))
                continue;

            memset(&m->rip[n], 0, sizeof(m->rip[n]));
            memmove(m->rip[n].addr, r->dest, Pasize);
            if(r->metric < 1)
                hnputl(m->rip[n].metric, 1);
            else
                hnputl(m->rip[n].metric, r->metric);
            hnputs(m->rip[n].family, AF_INET);

            if(debug)
                fprint(2, " %16V & %16V -> %16V %2d\n",
                    r->dest, r->mask, r->gate, r->metric);

            if(++n == Maxroutes && !readonly){
                write(ripfd, mbuf, Udphdrsize + 4 + n*20);
                n = 0;
            }
        }
    }

    if(n && !readonly)
        write(ripfd, mbuf, Udphdrsize+4+n*20);
}
@

<<function [[broadcast]]>>=
void
broadcast(void)
{
    int i;

    readifcs();
    for(i = 0; i < ialloc.nifc; i++){
        if(ialloc.ifc[i].bcast)
            sendto(&ialloc.ifc[i]);
    }
}
@

<<function [[timeoutroutes]]>>=
/*
 *  timeout any routes that haven't been refreshed and aren't wired
 */
void
timeoutroutes(void)
{
    int h;
    long now;
    Route *r, **l;

    now = time(0);

    for(h = 0; h < Nhash; h++){
        l = &ralloc.hash[h];
        for(r = *l; r; r = *l){
            if(r->metric < Infinity && now - r->time > 10*60){
                removeroute(r);
                r->inuse = 0;
                *l = r->next;
                continue;
            }
            l = &r->next;
        }
    }
}
@


%-------------------------------------------------------------

<<networking/ip/rip.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ip.h>

<<enum [[_anon_ (networking/ip/rip.c)]]>>

// forward decl
typedef struct Rip	Rip;
typedef struct Ripmsg	Ripmsg;
typedef struct Route	Route;
typedef struct Ifc	Ifc;
typedef struct Bnet Bnet;

/*
 *  network info
 */
<<struct [[Rip]]>>
<<struct [[Ripmsg]]>>

<<enum [[_anon_ (networking/ip/rip.c)2]]>>

<<enum [[_anon_ (networking/ip/rip.c)3]]>>

<<struct [[Route]]([[(networking/ip/rip.c)]])>>
<<global [[ralloc]]>>

<<struct [[Ifc]]>>
<<global [[ialloc]]>>

/*
 *  specific networks to broadcast on
 */
<<struct [[Bnet]]>>
<<global [[bnets]]>>

<<global [[ripfd]]>>
<<global [[now]]>>
<<global [[debug]]([[(networking/ip/rip.c)]])>>
<<global [[readonly]]>>
<<global [[routefile]]>>
<<global [[netdir]]>>

int	openport(void);
void	readroutes(void);
void	readifcs(void);
void	considerroute(Route*);
void	installroute(Route*);
void	removeroute(Route*);
uchar	*getmask(uchar*);
void	broadcast(void);
void	timeoutroutes(void);

<<function [[fatal]]>>

<<function [[v4parseipmask]]>>

<<function [[v4defmask]]>>

<<function [[v4maskip]]>>

<<function [[v6tov4mask]]>>

<<macro [[equivip]]>>

<<function [[ding]]([[(networking/ip/rip.c)]])>>

<<function [[usage]]([[(networking/ip/rip.c)]])>>

<<function [[main]]([[(networking/ip/rip.c)]])>>

<<function [[openport]]>>

<<global [[ifcs]]>>

<<function [[readifcs]]>>

<<function [[readroutes]]>>

<<function [[rhash]]>>

<<function [[considerroute]]>>

<<function [[removeroute]]>>

<<function [[installroute]]>>

<<function [[onnet]]>>

<<function [[getmask]]>>

<<function [[sendto]]>>
<<function [[broadcast]]>>

<<function [[timeoutroutes]]>>
@


\subsection*{[[networking/ip/linklocal.c]]}

<<enum [[_anon_ (networking/ip/linklocal.c)]]>>=
enum {
    Mac0mcast	= 1<<0,		/* multicast address */
    Mac0localadm	= 1<<1,		/* locally-administered address, */
    V60globaladm	= 1<<1,		/* but ipv6 reverses the meaning */
};
@

<<global [[v4_6to4]]>>=
static char *v4_6to4;
@

<<function [[usage]]([[(networking/ip/linklocal.c)]])>>=
static void
usage(void)
{
    fprint(2, "usage: %s [-t ipv4] ether...\n", argv0);
    exits("usage");
}
@

<<function [[ea2eui64]]>>=
void
ea2eui64(uchar *lla, uchar *ea)
{
    *lla++ = *ea++ | V60globaladm;	/* oui (company id) */
    *lla++ = *ea++;			/* " */
    *lla++ = *ea++;			/* " */
    *lla++ = 0xFF;			/* mac-48 in eui-64 (sic) */
    *lla++ = 0xFE;			/* " */
    *lla++ = *ea++;			/* manufacturer-assigned */
    *lla++ = *ea++;			/* " */
    *lla = *ea;			/* " */
}
@

<<function [[eaip26to4]]>>=
void
eaip26to4(uchar *lla, uchar *ea, uchar *ipv4)
{
    *lla++ = 0x20;			/* 6to4 address */
    *lla++ = 0x02;			/* " */
    memmove(lla, ipv4, IPv4addrlen);
    lla += IPv4addrlen;
    memset(lla, 0, 2);
    ea2eui64(lla + 2, ea);
}
@

<<function [[ea2lla]]>>=
void
ea2lla(uchar *lla, uchar *ea)
{
    *lla++ = 0xFE;			/* link-local v6 */
    *lla++ = 0x80;			/* " */
    memset(lla, 0, 6);
    ea2eui64(lla + 6, ea);
}
@

<<function [[process]]>>=
static void
process(char *ether)
{
    uchar ethaddr[6], ipaddr[IPaddrlen], ipv4[IPv4addrlen];

    if (parseether(ethaddr, ether) < 0)
        sysfatal("%s: not an ether address", ether);
    if (v4_6to4) {
        v4parseip(ipv4, v4_6to4);
        eaip26to4(ipaddr, ethaddr, ipv4);
    } else
        ea2lla(ipaddr, ethaddr);
    print("%I\n", ipaddr);
}
@

<<function [[main]]([[(networking/ip/linklocal.c)]])>>=
void
main(int argc, char *argv[])
{
    int i;

    ARGBEGIN {
    case 't':
        v4_6to4 = EARGF(usage());
        break;
    default:
        usage();
        break;
    } ARGEND

    fmtinstall('I', eipfmt);
    if (argc <= 0)
        usage();

    for (i = 0; i < argc; i++)
        process(argv[i]);
    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ip/linklocal.c>>=
/*
 * linklocal - print ipv6 link-local or 6to4 address of a mac address.
 * eui is ieee's extended unique identifier, per rfc2373.
 */

#include <u.h>
#include <libc.h>
#include <ip.h>

<<enum [[_anon_ (networking/ip/linklocal.c)]]>>

<<global [[v4_6to4]]>>

<<function [[usage]]([[(networking/ip/linklocal.c)]])>>

<<function [[ea2eui64]]>>

<<function [[eaip26to4]]>>

<<function [[ea2lla]]>>

<<function [[process]]>>

<<function [[main]]([[(networking/ip/linklocal.c)]])>>
@


\subsection*{[[networking/ip/telnet.c]]}

<<global [[ctl]]>>=
int ctl = -1;		/* control fd (for break's) */
@

<<global [[consctl]]>>=
int consctl = -1;	/* consctl fd */
@

<<global [[ttypid]]>>=
int ttypid;		/* pid's if the 2 processes (used to kill them) */
@

<<global [[netpid]]>>=
int netpid;
@

<<global [[interrupted]]>>=
int interrupted;
@

<<global [[localecho]]>>=
int localecho;
@

<<global [[notkbd]]>>=
int notkbd;
@

<<global [[srv]]>>=
static char *srv;
@

<<struct [[Comm]]>>=
struct Comm {
    int returns;
    int stopped;
};
@

<<global [[comm]]>>=
Comm *comm;
@

<<function [[usage]]([[(networking/ip/telnet.c)]])>>=
void
usage(void)
{
    fatal("usage: telnet [-Cdnr] [-s srv] net!host[!service]", 0, 0);
}
@

<<function [[main]]([[(networking/ip/telnet.c)]])>>=
void
main(int argc, char *argv[])
{
    int returns;

    returns = 1;
    ARGBEGIN{
    case 'C':
        opt[Echo].noway = 1;
        break;
    case 'd':
        debug = 1;
        break;
    case 'n':
        notkbd = 1;
        break; 
    case 'r':
        returns = 0;
        break;
    case 's':
        srv = EARGF(usage());
        break;
    default:
        usage();
    }ARGEND

    if(argc != 1)
        usage();

    /* options we need routines for */
    opt[Echo].change = echochange;
    opt[Term].sub = termsub;
    opt[Xloc].sub = xlocsub;

    comm = share(sizeof(comm));
    comm->returns = returns;

    telnet(dodial(argv[0]));
}
@

<<function [[dodial]]>>=
/*
 *  dial and return a data connection
 */
int
dodial(char *dest)
{
    char *name;
    int data;
    char devdir[NETPATHLEN];

    name = netmkaddr(dest, "tcp", "telnet");
    data = dial(name, 0, devdir, 0);
    if(data < 0)
        fatal("%s: %r", name, 0);
    fprint(2, "connected to %s on %s\n", name, devdir);
    return data;
}
@

<<function [[post]]>>=
void
post(char *srv, int fd)
{
    int f;
    char buf[32];

    f = create(srv, OWRITE, 0666);
    if(f < 0)
        sysfatal("create %s: %r", srv);
    snprint(buf, sizeof buf, "%d", fd);
    if(write(f, buf, strlen(buf)) != strlen(buf))
        sysfatal("write %s: %r", srv);
    close(f);
}
@

<<function [[telnet]]>>=
/*
 *  two processes pass bytes back and forth between the
 *  terminal and the network.
 */
void
telnet(int net)
{
    int pid;
    int p[2];
    char *svc;

    rawoff();
    svc = nil;
    if (srv) {
        if(pipe(p) < 0)
            sysfatal("pipe: %r");
        if (srv[0] != '/')
            svc = smprint("/srv/%s", srv);
        else
            svc = srv;
        post(svc, p[0]);
        close(p[0]);
        dup(p[1], 0);
        dup(p[1], 1);
        /* pipe is now std in & out */
    }
    ttypid = getpid();
    switch(pid = rfork(RFPROC|RFFDG|RFMEM)){
    case -1:
        perror("con");
        exits("fork");
    case 0:
        rawoff();
        notify(notifyf);
        fromnet(net);
        if (svc)
            remove(svc);
        sendnote(ttypid, "die");
        exits(0);
    default:
        netpid = pid;
        notify(notifyf);
        fromkbd(net);
        if(notkbd)
            for(;;)
                sleep(1000); // sleep(0) is a cpuhog
        if (svc)
            remove(svc);
        sendnote(netpid, "die");
        exits(0);
    }
}
@

<<function [[fromkbd]]>>=
/*
 *  Read the keyboard and write it to the network.  '^\' gets us into
 *  the menu.
 */
void
fromkbd(int net)
{
    Biobuf ib, ob;
    int c, likeatty;
    int eofs;

    Binit(&ib, 0, OREAD);
    Binit(&ob, net, OWRITE);

    likeatty = islikeatty(0);
    eofs = 0;
    for(;;){
        c = Bgetc(&ib);

        /*
         *  with raw off, all ^D's get turned into Eof's.
         *  change them back.
         *  10 in a row implies that the terminal is really gone so
         *  just hang up.
         */
        if(c < 0){
            if(notkbd)
                return;
            if(eofs++ > 10)
                return;
            c = 004;
        } else
            eofs = 0;

        /*
         *  if not in binary mode, look for the ^\ escape to menu.
         *  also turn \n into \r\n
         */
        if(likeatty || !opt[Binary].local){
            if(c == 0034){ /* CTRL \ */
                if(Bflush(&ob) < 0)
                    return;
                if(menu(&ib, net) < 0)
                    return;
                continue;
            }
        }
        if(!opt[Binary].local){
            if(c == '\n'){
                /*
                 *  This is a very strange use of the SGA option.
                 *  I did this because some systems that don't
                 *  announce a willingness to supress-go-ahead
                 *  need the \r\n sequence to recognize input.
                 *  If someone can explain this to me, please
                 *  send me mail. - presotto
                 */
                if(opt[SGA].remote){
                    c = '\r';
                } else {
                    if(Bputc(&ob, '\r') < 0)
                        return;
                }
            }
        }
        if(Bputc(&ob, c) < 0)
            return;
        if(Bbuffered(&ib) == 0)
            if(Bflush(&ob) < 0)
                return;
    }
}
@

<<function [[fromnet]]>>=
/*
 *  Read from the network and write to the screen.  If 'stopped' is set
 *  spin and don't read.  Filter out spurious carriage returns.
 */
void
fromnet(int net)
{
    int c;
    int crnls = 0, freenl = 0, eofs;
    Biobuf ib, ob;

    Binit(&ib, net, OREAD);
    Binit(&ob, 1, OWRITE);
    eofs = 0;
    for(;;){
        if(Bbuffered(&ib) == 0)
            Bflush(&ob);
        if(interrupted){
            interrupted = 0;
            send2(net, Iac, Interrupt);
        }
        c = Bgetc(&ib);
        if(c < 0){
            if(eofs++ >= 2)
                return;
            continue;
        }
        eofs = 0;
        switch(c){
        case '\n':	/* skip nl after string of cr's */
            if(!opt[Binary].local && !comm->returns){
                ++crnls;
                if(freenl == 0)
                    break;
                freenl = 0;
                continue;
            }
            break;
        case '\r':	/* first cr becomes nl, remainder dropped */
            if(!opt[Binary].local && !comm->returns){
                if(crnls++ == 0){
                    freenl = 1;
                    c = '\n';
                    break;
                }
                continue;
            }
            break;
        case 0:		/* remove nulls from crnl string */
            if(crnls)
                continue;
            break;

        case Iac:
            crnls = 0;
            freenl = 0;
            c = Bgetc(&ib);
            if(c == Iac)
                break;
            if(Bflush(&ob) < 0)
                return;
            if(control(&ib, c) < 0)
                return;
            continue;

        default:
            crnls = 0;
            freenl = 0;
            break;
        }
        if(Bputc(&ob, c) < 0)
            return;
    }
}
@

<<function [[rawon]]>>=
/*
 *  turn keyboard raw mode on
 */
void
rawon(void)
{
    if(debug)
        fprint(2, "rawon\n");
    if(consctl < 0)
        consctl = open("/dev/consctl", OWRITE);
    if(consctl < 0){
        fprint(2, "%s: can't open consctl: %r\n", argv0);
        return;
    }
    write(consctl, "rawon", 5);
}
@

<<function [[rawoff]]>>=
/*
 *  turn keyboard raw mode off
 */
void
rawoff(void)
{
    if(debug)
        fprint(2, "rawoff\n");
    if(consctl < 0)
        consctl = open("/dev/consctl", OWRITE);
    if(consctl < 0){
        fprint(2, "%s: can't open consctl: %r\n", argv0);
        return;
    }
    write(consctl, "rawoff", 6);
}
@

<<constant [[STDHELP]]>>=
/*
 *  control menu
 */
#define STDHELP	"\t(b)reak, (i)nterrupt, (q)uit, (r)eturns, (!cmd), (.)continue\n"
@

<<function [[menu]]>>=
int
menu(Biobuf *bp, int net)
{
    char *cp;
    int done;

    comm->stopped = 1;

    rawoff();
    fprint(2, ">>> ");
    for(done = 0; !done; ){
        cp = Brdline(bp, '\n');
        if(cp == 0){
            comm->stopped = 0;
            return -1;
        }
        cp[Blinelen(bp)-1] = 0;
        switch(*cp){
        case '!':
            system(Bfildes(bp), cp+1);
            done = 1;
            break;
        case '.':
            done = 1;
            break;
        case 'q':
            comm->stopped = 0;
            return -1;
        case 'o':
            switch(*(cp+1)){
            case 'd':
                send3(net, Iac, Do, atoi(cp+2));
                break;
            case 'w':
                send3(net, Iac, Will, atoi(cp+2));
                break;
            }
            break;
        case 'r':
            comm->returns = !comm->returns;
            done = 1;
            break;
        case 'i':
            send2(net, Iac, Interrupt);
            break;
        case 'b':
            send2(net, Iac, Break);
            break;
        default:
            fprint(2, STDHELP);
            break;
        }
        if(!done)
            fprint(2, ">>> ");
    }

    rawon();
    comm->stopped = 0;
    return 0;
}
@

<<function [[notifyf]]>>=
/*
 *  ignore interrupts
 */
void
notifyf(void *a, char *msg)
{
    USED(a);
    if(strcmp(msg, "interrupt") == 0){
        interrupted = 1;
        noted(NCONT);
    }
    if(strcmp(msg, "hangup") == 0)
        noted(NCONT);
    noted(NDFLT);
}
@

<<function [[system]]>>=
/*
 *  run a command with the network connection as standard IO
 */
char *
system(int fd, char *cmd)
{
    int pid;
    int p;
    static Waitmsg msg;

    if((pid = fork()) == -1){
        perror("con");
        return "fork failed";
    }
    else if(pid == 0){
        dup(fd, 0);
        close(ctl);
        close(fd);
        if(*cmd)
            execl("/bin/rc", "rc", "-c", cmd, nil);
        else
            execl("/bin/rc", "rc", nil);
        perror("con");
        exits("exec");
    }
    for(p = waitpid(); p >= 0; p = waitpid()){
        if(p == pid)
            return msg.msg;	
    }
    return "lost child";
}
@

<<function [[echochange]]>>=
/*
 *  suppress local echo if the remote side is doing it
 */
int
echochange(Biobuf *bp, int cmd)
{
    USED(bp);

    switch(cmd){
    case Will:
        rawon();
        break;
    case Wont:
        rawoff();
        break;
    }
    return 0;
}
@

<<function [[termsub]]>>=
/*
 *  send terminal type to the other side
 */
int
termsub(Biobuf *bp, uchar *sub, int n)
{
    char buf[64];
    char *term;
    char *p = buf;

    if(n < 1)
        return 0;
    if(sub[0] == 1){
        *p++ = Iac;
        *p++ = Sb;
        *p++ = opt[Term].code;
        *p++ = 0;
        term = getenv("TERM");
        if(term == 0 || *term == 0)
            term = "p9win";
        strncpy(p, term, sizeof(buf) - (p - buf) - 2);
        buf[sizeof(buf)-2] = 0;
        p += strlen(p);
        *p++ = Iac;
        *p++ = Se;
        return iwrite(Bfildes(bp), buf, p-buf);
    }
    return 0;
}
@

<<function [[xlocsub]]>>=
/*
 *  send an x display location to the other side
 */
int
xlocsub(Biobuf *bp, uchar *sub, int n)
{
    char buf[64];
    char *term;
    char *p = buf;

    if(n < 1)
        return 0;
    if(sub[0] == 1){
        *p++ = Iac;
        *p++ = Sb;
        *p++ = opt[Xloc].code;
        *p++ = 0;
        term = getenv("XDISP");
        if(term == 0 || *term == 0)
            term = "unknown";
        strncpy(p, term, p - buf - 2);
        p += strlen(term);
        *p++ = Iac;
        *p++ = Se;
        return iwrite(Bfildes(bp), buf, p-buf);
    }
    return 0;
}
@

<<function [[islikeatty]]>>=
static int
islikeatty(int fd)
{
    char buf[64];

    if(fd2path(fd, buf, sizeof buf) != 0)
        return 0;

    /* might be /mnt/term/dev/cons */
    return strlen(buf) >= 9 && strcmp(buf+strlen(buf)-9, "/dev/cons") == 0;
}
@

<<function [[share]]>>=
/*
 *  create a shared segment.  Make is start 2 meg higher than the current
 *  end of process memory.
 */
void*
share(ulong len)
{
    uchar *vastart;

    vastart = sbrk(0);
    if(vastart == (void*)-1)
        return 0;
    vastart += 2*1024*1024;

    if(segattach(0, "shared", vastart, len) == (void*)-1)
        return 0;

    return vastart;
}
@


%-------------------------------------------------------------

<<networking/ip/telnet.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "telnet.h"

<<global [[ctl]]>>
<<global [[consctl]]>>

<<global [[ttypid]]>>
<<global [[netpid]]>>
<<global [[interrupted]]>>
<<global [[localecho]]>>
<<global [[notkbd]]>>

<<global [[srv]]>>

// forward decl
typedef struct Comm Comm;

<<struct [[Comm]]>>
<<global [[comm]]>>

int	dodial(char*);
void	fromkbd(int);
void	fromnet(int);
int	menu(Biobuf*,  int);
void	notifyf(void*, char*);
void	rawoff(void);
void	rawon(void);
void	telnet(int);
char*	system(int, char*);
int	echochange(Biobuf*, int);
int	termsub(Biobuf*, uchar*, int);
int	xlocsub(Biobuf*, uchar*, int);
void*	share(ulong);

static int islikeatty(int);

<<function [[usage]]([[(networking/ip/telnet.c)]])>>

<<function [[main]]([[(networking/ip/telnet.c)]])>>

<<function [[dodial]]>>

<<function [[post]]>>

<<function [[telnet]]>>

<<function [[fromkbd]]>>

<<function [[fromnet]]>>

<<function [[rawon]]>>

<<function [[rawoff]]>>

<<constant [[STDHELP]]>>

<<function [[menu]]>>

<<function [[notifyf]]>>

<<function [[system]]>>

<<function [[echochange]]>>

<<function [[termsub]]>>

<<function [[xlocsub]]>>

<<function [[islikeatty]]>>

<<function [[share]]>>
@


\subsection*{[[networking/ip/telnet.h]]}

<<global [[debug]]([[(networking/ip/telnet.h)]])>>=
int debug;
@

<<constant [[DPRINT]]([[(networking/ip/telnet.h)]])>>=
#define DPRINT if(debug)fprint
@

<<enum [[_anon_ (networking/ip/telnet.h)]]>>=
enum
{
    /* control characters */
    Se=		240,		/* end subnegotiation */
    NOP=		241,
    Mark=		242,		/* data mark */
    Break=		243,
    Interrupt=	244,
    Abort=		245,		/* TENEX ^O */
    AreYouThere=	246,
    Erasechar=	247,		/* erase last character */
    Eraseline=	248,		/* erase line */
    GoAhead=	249,		/* half duplex clear to send */
    Sb=		250,		/* start subnegotiation */
    Will=		251,
    Wont=		252,
    Do=		253,
    Dont=		254,
    Iac=		255,

    /* options */
    Binary=		0,
    Echo,
    SGA,
    Stat,
    Timing,
    Det,
    Term,
    EOR,
    Uid,
    Outmark,
    Ttyloc,
    M3270,
    Padx3,
    Window,
    Speed,
    Flow,
    Line,
    Xloc,
    Extend,
};
@

<<struct [[Opt]]>>=
struct Opt
{
    char	*name;
    int	code;
    char	noway;	
    int	(*change)(Biobuf*, int);	/* routine for status change */
    int	(*sub)(Biobuf*, uchar*, int n);	/* routine for subnegotiation */
    char	remote;				/* remote value */
    char	local;				/* local value */
};
@

<<global [[opt]]>>=
Opt opt[] =
{
[Binary]	{ "binary",		0,  0, },
[Echo]		{ "echo",		1,  0, },
[SGA]		{ "suppress Go Ahead",	3,  0, },
[Stat]		{ "status",		5,  1, },
[Timing]	{ "timing",		6,  1, },
[Det]		{ "det",		20, 1, },
[Term]		{ "terminal",		24, 0, },
[EOR]		{ "end of record",	25, 1, },
[Uid]		{ "uid",		26, 1, },
[Outmark]	{ "outmark",		27, 1, },
[Ttyloc]	{ "ttyloc",		28, 1, },
[M3270]		{ "3270 mode",		29, 1, },
[Padx3]		{ "pad x.3",		30, 1, },
[Window]	{ "window size",	31, 1, },
[Speed]		{ "speed",		32, 1, },
[Flow]		{ "flow control",	33, 1, },
[Line]		{ "line mode",		34, 1, },
[Xloc]		{ "X display loc",	35, 0, },
[Extend]	{ "Extended",		255, 1, },
};
@

<<function [[control]]>>=
/*
 *  parse telnet control messages
 */
int
control(Biobuf *bp, int c)
{
    if(c < 0)
        return -1;
    switch(c){
    case AreYouThere:
        fprint(Bfildes(bp), "Plan 9 telnet, version 1\r\n");
        break;
    case Sb:
        return sub(bp);
    case Will:
        return will(bp);
    case Wont:
        return wont(bp);
    case Do:
        return doit(bp);
    case Dont:
        return dont(bp);
    case Se:
        fprint(2, "telnet: SE without an SB\n");
        break;
    default:
        break;
    }
    return 0;
}
@

<<function [[findopt]]>>=
Opt*
findopt(int c)
{
    Opt *o;

    for(o = opt; o <= &opt[Extend]; o++)
        if(o->code == c)
            return o;
    return 0;
}
@

<<function [[will]]>>=
int
will(Biobuf *bp)
{
    Opt *o;
    int c;
    int rv = 0;

    c = Bgetc(bp);
    if(c < 0)
        return -1;
    DPRINT(2, "will %d\n", c);
    o = findopt(c);
    if(o == 0){
        send3(Bfildes(bp), Iac, Dont, c);
        return 0;
    }
    if(o->noway)
        send3(Bfildes(bp), Iac, Dont, c);
    else if(o->remote == 0)
        rv |= send3(Bfildes(bp), Iac, Do, c);
    if(o->remote == 0){
        if(o->change)
            rv |= (*o->change)(bp, Will);
    }
    o->remote = 1;
    return rv;
}
@

<<function [[wont]]>>=
int
wont(Biobuf *bp)
{
    Opt *o;
    int c;
    int rv = 0;

    c = Bgetc(bp);
    if(c < 0)
        return -1;
    DPRINT(2, "wont %d\n", c);
    o = findopt(c);
    if(o == 0)
        return 0;
    if(o->remote){
        if(o->change)
            rv |= (*o->change)(bp, Wont);
        rv |= send3(Bfildes(bp), Iac, Dont, c);
    }
    o->remote = 0;
    return rv;
}
@

<<function [[doit]]>>=
int
doit(Biobuf *bp)
{
    Opt *o;
    int c;
    int rv = 0;

    c = Bgetc(bp);
    if(c < 0)
        return -1;
    DPRINT(2, "do %d\n", c);
    o = findopt(c);
    if(o == 0 || o->noway){
        send3(Bfildes(bp), Iac, Wont, c);
        return 0;
    }
    if(o->noway)
        return 0;
    if(o->local == 0){
        if(o->change)
            rv |= (*o->change)(bp, Do);
        rv |= send3(Bfildes(bp), Iac, Will, c);
    }
    o->local = 1;
    return rv;
}
@

<<function [[dont]]>>=
int
dont(Biobuf *bp)
{
    Opt *o;
    int c;
    int rv = 0;

    c = Bgetc(bp);
    if(c < 0)
        return -1;
    DPRINT(2, "dont %d\n", c);
    o = findopt(c);
    if(o == 0)
        return 0;
    if(o->noway)
        return 0;
    if(o->local){
        o->local = 0;
        if(o->change)
            rv |= (*o->change)(bp, Dont);
        rv |= send3(Bfildes(bp), Iac, Wont, c);
    }
    o->local = 0;
    return rv;
}
@

<<function [[sub]]>>=
/* read in a subnegotiation message and pass it to a routine for that option */
int
sub(Biobuf *bp)
{
    uchar subneg[128];
    uchar *p;
    Opt *o;
    int c;

    p = subneg;
    for(;;){
        c = Bgetc(bp);
        if(c == Iac){
            c = Bgetc(bp);
            if(c == Se)
                break;
            if(p < &subneg[sizeof(subneg)])
                *p++ = Iac;
        }
        if(c < 0)
            return -1;
        if(p < &subneg[sizeof(subneg)])
            *p++ = c;
    }
    if(p == subneg)
        return 0;
    DPRINT(2, "sub %d %d n = %d\n", subneg[0], subneg[1], (int)(p - subneg - 1));
    o = findopt(subneg[0]);
    if(o == 0 || o->sub == 0)
        return 0;
    return (*o->sub)(bp, subneg+1, p - subneg - 1);
}
@

<<function [[sendd]]>>=
void
sendd(int c0, int c1)
{
    char *t = 0;

    switch(c0){
    case Will:
        t = "Will";
        break;
    case Wont:
        t = "Wont";
        break;
    case Do:
        t = "Do";
        break;
    case Dont:
        t = "Dont";
        break;
    }
    if(t)
        DPRINT(2, "r %s %d\n", t, c1);
}
@

<<function [[send2]]>>=
int
send2(int f, int c0, int c1)
{
    uchar buf[2];

    buf[0] = c0;
    buf[1] = c1;
    return iwrite(f, buf, 2) == 2 ? 0 : -1;
}
@

<<function [[send3]]>>=
int
send3(int f, int c0, int c1, int c2)
{
    uchar buf[3];

    buf[0] = c0;
    buf[1] = c1;
    buf[2] = c2;
    sendd(c1, c2);
    return iwrite(f, buf, 3) == 3 ? 0 : -1;
}
@

<<function [[sendnote]]>>=
int
sendnote(int pid, char *msg)
{
    int fd;
    char name[128];

    sprint(name, "/proc/%d/note", pid);
    fd = open(name, OWRITE);
    if(fd < 0)
        return -1;
    if(write(fd, msg, strlen(msg))!=strlen(msg))
        return -1;
    return close(fd);
}
@

<<function [[fatal]]([[(networking/ip/telnet.h)]])>>=
void
fatal(char *fmt, void *a0, void *a1)
{
    char buf[128];

    sprint(buf, fmt, a0, a1);
    fprint(2, "%s: %s\n", argv0, buf);
    exits(buf);
}
@

<<function [[syserr]]>>=
char*
syserr(void)
{
    static char err[ERRMAX];

    errstr(err, sizeof err);
    return err;
}
@

<<function [[wasintr]]>>=
int
wasintr(void)
{
    return strcmp(syserr(), "interrupted") == 0;
}
@

<<function [[iread]]>>=
long
iread(int f, void *a, int n)
{
    long m;

    for(;;){
        m = read(f, a, n);
        if(m >= 0 || !wasintr())
            break;
    }
    return m;
}
@

<<function [[iwrite]]>>=
long
iwrite(int f, void *a, int n)
{
    long m;

    m = write(f, a, n);
    if(m < 0 && wasintr())
        return n;
    return m;
}
@


%-------------------------------------------------------------

<<networking/ip/telnet.h>>=
typedef struct Opt	Opt;

<<global [[debug]]([[(networking/ip/telnet.h)]])>>
<<constant [[DPRINT]]([[(networking/ip/telnet.h)]])>>

<<enum [[_anon_ (networking/ip/telnet.h)]]>>

<<struct [[Opt]]>>

<<global [[opt]]>>

int	control(Biobuf*, int);
Opt*	findopt(int);
int	will(Biobuf*);
int	wont(Biobuf*);
int	doit(Biobuf*);
int	dont(Biobuf*);
int	sub(Biobuf*);
int	send2(int, int, int);
int	send3(int, int, int, int);
int	sendnote(int, char*);
void	fatal(char*, void*, void*);
char*	syserr(void);
int	wasintr(void);
long	iread(int, void*, int);
long	iwrite(int, void*, int);
void	binit(Biobuf*, int);
void	berase(Biobuf*);
void	bkill(Biobuf*);

<<function [[control]]>>

<<function [[findopt]]>>

<<function [[will]]>>

<<function [[wont]]>>

<<function [[doit]]>>

<<function [[dont]]>>

<<function [[sub]]>>

<<function [[sendd]]>>

<<function [[send2]]>>

<<function [[send3]]>>

<<function [[sendnote]]>>

<<function [[fatal]]([[(networking/ip/telnet.h)]])>>

<<function [[syserr]]>>

<<function [[wasintr]]>>

<<function [[iread]]>>

<<function [[iwrite]]>>
@


\subsection*{[[networking/ip/telnetd.c]]}

<<struct [[Consstate]]>>=
struct Consstate{
    int raw;
    int hold;
};
@

<<global [[cons]]>>=
Consstate *cons;
@

<<global [[notefd]]>>=
int notefd;		/* for sending notes to the child */
@

<<global [[noproto]]>>=
int noproto;		/* true if we shouldn't be using the telnet protocol */
@

<<global [[trusted]]>>=
int trusted;		/* true if we need not authenticate - current user is ok */
@

<<global [[nonone]]>>=
int nonone = 1;		/* don't allow none logins */
@

<<global [[noworldonly]]>>=
int noworldonly;	/* only noworld accounts */
@

<<enum [[_anon_ (networking/ip/telnetd.c)]]>>=
enum
{
    Maxpath=	256,
    Maxuser=	64,
    Maxvar=		32,
};
@

<<global [[netib]]>>=
/* input and output buffers for network connection */
Biobuf	netib;
@

<<global [[childib]]>>=
Biobuf	childib;
@

<<global [[remotesys]]>>=
char	remotesys[Maxpath];	/* name of remote system */
@

<<constant [[TELNETLOG]]>>=
#define TELNETLOG "telnet"
@

<<function [[logit]]>>=
void
logit(char *fmt, ...)
{
    va_list arg;
    char buf[8192];

    va_start(arg, fmt);
    vseprint(buf, buf + sizeof(buf) / sizeof(*buf), fmt, arg);
    va_end(arg);
    syslog(0, TELNETLOG, "(%s) %s", remotesys, buf);
}
@

<<function [[getremote]]>>=
void
getremote(char *dir)
{
    int fd, n;
    char remfile[Maxpath];

    sprint(remfile, "%s/remote", dir);
    fd = open(remfile, OREAD);
    if(fd < 0)
        strcpy(remotesys, "unknown2");
    n = read(fd, remotesys, sizeof(remotesys)-1);
    if(n>0)
        remotesys[n-1] = 0;
    else
        strcpy(remotesys, remfile);
    close(fd);
}
@

<<function [[main]]([[(networking/ip/telnetd.c)]])>>=
void
main(int argc, char *argv[])
{
    char buf[1024];
    int fd;
    char user[Maxuser];
    int tries = 0;
    int childpid;
    int n, eofs;

    memset(user, 0, sizeof(user));
    ARGBEGIN {
    case 'n':
        opt[Echo].local = 1;
        noproto = 1;
        break;
    case 'p':
        noproto = 1;
        break;
    case 'a':
        nonone = 0;
        break;
    case 't':
        trusted = 1;
        strncpy(user, getuser(), sizeof(user)-1);
        break;
    case 'u':
        strncpy(user, ARGF(), sizeof(user)-1);
        break;
    case 'd':
        debug = 1;
        break;
    case 'N':
        noworldonly = 1;
        break;
    } ARGEND

    if(argc)
        getremote(argv[argc-1]);
    else
        strcpy(remotesys, "unknown");

    /* options we need routines for */
    opt[Term].change = termchange;
    opt[Term].sub = termsub;
    opt[Xloc].sub = xlocsub;

    /* setup default telnet options */
    if(!noproto){
        send3(1, Iac, Will, opt[Echo].code);
        send3(1, Iac, Do, opt[Term].code);
        send3(1, Iac, Do, opt[Xloc].code);
    }

    /* shared data for console state */
    cons = share(sizeof(Consstate));
    if(cons == 0)
        fatal("shared memory", 0, 0);

    /* authenticate and create new name space */
    Binit(&netib, 0, OREAD);
    if (!trusted){
        while(doauth(user) < 0)
            if(++tries == 5){
                logit("failed as %s: %r", user);
                print("authentication failure:%r\r\n");
                exits("authentication");
            }
    }
    logit("logged in as %s", user);
    putenv("service", "con");

    /* simulate /dev/consctl and /dev/cons using pipes */
    fd = conssim();
    if(fd < 0)
        fatal("simulating", 0, 0);
    Binit(&childib, fd, OREAD);

    /* start a shell in a different process group */
    switch(childpid = rfork(RFPROC|RFNAMEG|RFFDG|RFNOTEG)){
    case -1:
        fatal("fork", 0, 0);
    case 0:
        close(fd);
        fd = open("/dev/cons", OREAD);
        dup(fd, 0);
        close(fd);
        fd = open("/dev/cons", OWRITE);
        dup(fd, 1);
        dup(fd, 2);
        close(fd);
        segdetach(cons);
        execl("/bin/rc", "rc", "-il", nil);
        fatal("/bin/rc", 0, 0);
    default:
        sprint(buf, "/proc/%d/notepg", childpid);
        notefd = open(buf, OWRITE);
        break;
    }

    /* two processes to shuttle bytes twixt children and network */
    switch(fork()){
    case -1:
        fatal("fork", 0, 0);
    case 0:
        eofs = 0;
        for(;;){
            n = fromchild(buf, sizeof(buf));
            if(n <= 0){
                if(eofs++ > 2)
                    break;
                continue;
            }
            eofs = 0;
            if(write(1, buf, n) != n)
                break;
        }
        break;
    default:
        while((n = fromnet(buf, sizeof(buf))) >= 0)
            if(write(fd, buf, n) != n)
                break;
        break;
    }

    /* kill off all server processes */
    sprint(buf, "/proc/%d/notepg", getpid());
    fd = open(buf, OWRITE);
    write(fd, "die", 3);
    exits(0);
}
@

<<function [[prompt]]>>=
void
prompt(char *p, char *b, int n, int raw)
{
    char *e;
    int i;
    int echo;

    echo = opt[Echo].local;
    if(raw)
        opt[Echo].local = 0;
    print("%s: ", p);
    for(e = b+n; b < e;){
        i = fromnet(b, e-b);
        if(i <= 0)
            exits("fromnet: hungup");
        b += i;
        if(*(b-1) == '\n' || *(b-1) == '\r'){
            *(b-1) = 0;
            break;
        }
    }
    if(raw)
        opt[Echo].local = echo;
}
@

<<function [[challuser]]>>=
/*
 *  challenge user
 */
int
challuser(char *user)
{
    char nchall[64];
    char response[64];
    Chalstate *ch;
    AuthInfo *ai;

    if(strcmp(user, "none") == 0){
        if(nonone)
            return -1;
        newns("none", nil);
        return 0;
    }
    if((ch = auth_challenge("proto=p9cr role=server user=%q", user)) == nil)
        return -1;
    snprint(nchall, sizeof nchall, "challenge: %s\r\nresponse", ch->chal);
    prompt(nchall, response, sizeof response, 0);
    ch->resp = response;
    ch->nresp = strlen(response);
    ai = auth_response(ch);
    auth_freechal(ch);
    if(ai == nil){
        rerrstr(response, sizeof response);
        print("!%s\n", response);
        return -1;
    }
    if(auth_chuid(ai, nil) < 0)
        return -1;
    return 0;
}
@

<<function [[noworldlogin]]>>=
/*
 *  use the in the clear apop password to change user id
 */
int
noworldlogin(char *user)
{
    char password[256];

    prompt("password", password, sizeof(password), 1);
    if(login(user, password, "/lib/namespace.noworld") < 0)
        return -1;
    rfork(RFNOMNT);	/* sandbox */
    return 0;
}
@

<<function [[doauth]]>>=
int
doauth(char *user)
{
    if(*user == 0)
        prompt("user", user, Maxuser, 0);
    if(noworld(user))
        return noworldlogin(user);
    if(noworldonly)
        return -1;
    return challuser(user);
        
}
@

<<function [[fromchild]]>>=
/*
 *  Process some input from the child, add protocol if needed.  If
 *  the input buffer goes empty, return.
 */
int
fromchild(char *bp, int len)
{
    int c;
    char *start;

    for(start = bp; bp-start < len-1; ){
        c = Bgetc(&childib);
        if(c < 0){
            if(bp == start)
                return -1;
            else
                break;
        }
        if(cons->raw == 0 && c == '\n')
            *bp++ = '\r';
        *bp++ = c;
        if(Bbuffered(&childib) == 0)
            break;
    }
    return bp-start;
}
@

<<macro [[ECHO]]>>=
/*
 *  Read from the network up to a '\n' or some other break.
 *
 *  If in binary mode, buffer characters but don't 
 *
 *  The following characters are special:
 *	'\r\n's and '\r's get turned into '\n's.
 *	^H erases the last character buffered.
 *	^U kills the whole line buffered.
 *	^W erases the last word
 *	^D causes a 0-length line to be returned.
 *	Intr causes an "interrupt" note to be sent to the children.
 */
#define ECHO(c) { *ebp++ = (c); }
@

<<function [[fromnet]]([[(networking/ip/telnetd.c)]])>>=
int
fromnet(char *bp, int len)
{
    int c;
    char echobuf[1024];
    char *ebp;
    char *start;
    static int crnl;
    static int doeof;


    /* simulate an EOF as a 0 length input */
    if(doeof){
        doeof = 0;
        return 0;
    }

    for(ebp = echobuf,start = bp; bp-start < len && ebp-echobuf < sizeof(echobuf); ){
        c = Bgetc(&netib);
        if(c < 0){
            if(bp == start)
                return -1;
            else
                break;
        }

        /* telnet protocol only */
        if(!noproto){
            /* protocol messages */
            switch(c){
            case Iac:
                crnl = 0;
                c = Bgetc(&netib);
                if(c == Iac)
                    break;
                control(&netib, c);
                continue;
            }

        }

        /* \r\n or \n\r become \n  */
        if(c == '\r' || c == '\n'){
            if(crnl && crnl != c){
                crnl = 0;
                continue;
            }
            if(cons->raw == 0 && opt[Echo].local){
                ECHO('\r');
                ECHO('\n');
            }
            crnl = c;
            if(cons->raw == 0)
                *bp++ = '\n';
            else
                *bp++ = c;
            break;
        } else
            crnl = 0;

        /* raw processing (each character terminates */
        if(cons->raw){
            *bp++ = c;
            break;
        }

        /* in binary mode, there are no control characters */
        if(opt[Binary].local){
            if(opt[Echo].local)
                ECHO(c);
            *bp++ = c;
            continue;
        }

        /* cooked processing */
        switch(c){
        case 0x00:
            if(noproto)		/* telnet ignores nulls */
                *bp++ = c;
            continue;
        case 0x04:
            if(bp != start)
                doeof = 1;
            goto out;

        case 0x08:	/* ^H */
            if(start < bp)
                bp--;
            if(opt[Echo].local)
                ECHO(c);
            break;

        case 0x15:	/* ^U */
            bp = start;
            if(opt[Echo].local){
                ECHO('^');
                ECHO('U');
                ECHO('\r');
                ECHO('\n');
            }
            break;

        case 0x17:	/* ^W */
            if (opt[Echo].local) {
                while (--bp >= start && !alnum(*bp))
                    ECHO('\b');
                while (bp >= start && alnum(*bp)) {
                    ECHO('\b');
                    bp--;
                }
                bp++;
            }
            break;

        case 0x7f:	/* Del */
            write(notefd, "interrupt", 9);
            bp = start;
            break;

        default:
            if(opt[Echo].local)
                ECHO(c);
            *bp++ = c;
        }
        if(ebp != echobuf)
            write(1, echobuf, ebp-echobuf);
        ebp = echobuf;
    }
out:
    if(ebp != echobuf)
        write(1, echobuf, ebp-echobuf);
    return bp - start;
}
@

<<function [[termchange]]>>=
int
termchange(Biobuf *bp, int cmd)
{
    char buf[8];
    char *p = buf;

    if(cmd != Will)
        return 0;

    /* ask other side to send term type info */
    *p++ = Iac;
    *p++ = Sb;
    *p++ = opt[Term].code;
    *p++ = 1;
    *p++ = Iac;
    *p++ = Se;
    return iwrite(Bfildes(bp), buf, p-buf);
}
@

<<function [[termsub]]([[(networking/ip/telnetd.c)]])>>=
int
termsub(Biobuf *bp, uchar *sub, int n)
{
    char term[Maxvar];

    USED(bp);
    if(n-- < 1 || sub[0] != 0)
        return 0;
    if(n >= sizeof term)
        n = sizeof term;
    strncpy(term, (char*)sub, n);
    putenv("TERM", term);
    return 0;
}
@

<<function [[xlocchange]]>>=
int
xlocchange(Biobuf *bp, int cmd)
{
    char buf[8];
    char *p = buf;

    if(cmd != Will)
        return 0;

    /* ask other side to send x display info */
    *p++ = Iac;
    *p++ = Sb;
    *p++ = opt[Xloc].code;
    *p++ = 1;
    *p++ = Iac;
    *p++ = Se;
    return iwrite(Bfildes(bp), buf, p-buf);
}
@

<<function [[xlocsub]]([[(networking/ip/telnetd.c)]])>>=
int
xlocsub(Biobuf *bp, uchar *sub, int n)
{
    char xloc[Maxvar];

    USED(bp);
    if(n-- < 1 || sub[0] != 0)
        return 0;
    if(n >= sizeof xloc)
        n = sizeof xloc;
    strncpy(xloc, (char*)sub, n);
    putenv("DISPLAY", xloc);
    return 0;
}
@

<<function [[share]]([[(networking/ip/telnetd.c)]])>>=
/*
 *  create a shared segment.  Make is start 2 meg higher than the current
 *  end of process memory.
 */
void*
share(ulong len)
{
    uchar *vastart;

    vastart = sbrk(0);
    if(vastart == (void*)-1)
        return 0;
    vastart += 2*1024*1024;

    if(segattach(0, "shared", vastart, len) == (void*)-1)
        return 0;

    return vastart;
}
@

<<function [[conssim]]>>=
/*
 *  bind a pipe onto consctl and keep reading it to
 *  get changes to console state.
 */
int
conssim(void)
{
    int i, n;
    int fd;
    int tries;
    char buf[128];
    char *field[10];

    /* a pipe to simulate the /dev/cons */
    if(bind("#|", "/mnt/cons/cons", MREPL) < 0)
        fatal("/dev/cons1", 0, 0);
    if(bind("/mnt/cons/cons/data1", "/dev/cons", MREPL) < 0)
        fatal("/dev/cons2", 0, 0);

    /* a pipe to simulate consctl */
    if(bind("#|", "/mnt/cons/consctl", MBEFORE) < 0
    || bind("/mnt/cons/consctl/data1", "/dev/consctl", MREPL) < 0)
        fatal("/dev/consctl", 0, 0);

    /* a process to read /dev/consctl and set the state in cons */
    switch(fork()){
    case -1:
        fatal("forking", 0, 0);
    case 0:
        break;
    default:
        return open("/mnt/cons/cons/data", ORDWR);
    }

    for(tries = 0; tries < 100; tries++){
        cons->raw = 0;
        cons->hold = 0;
        fd = open("/mnt/cons/consctl/data", OREAD);
        if(fd < 0)
            continue;
        tries = 0;
        for(;;){
            n = read(fd, buf, sizeof(buf)-1);
            if(n <= 0)
                break;
            buf[n] = 0;
            n = getfields(buf, field, 10, 1, " ");
            for(i = 0; i < n; i++){
                if(strcmp(field[i], "rawon") == 0) {
                    if(debug) fprint(2, "raw = 1\n");
                    cons->raw = 1;
                } else if(strcmp(field[i], "rawoff") == 0) {
                    if(debug) fprint(2, "raw = 0\n");
                    cons->raw = 0;
                } else if(strcmp(field[i], "holdon") == 0) {
                    cons->hold = 1;
                    if(debug) fprint(2, "raw = 1\n");
                } else if(strcmp(field[i], "holdoff") == 0) {
                    cons->hold = 0;
                    if(debug) fprint(2, "raw = 0\n");
                }
            }
        }
        close(fd);
    }
    exits(0);
    return -1;
}
@

<<function [[alnum]]>>=
int
alnum(int c)
{
    /*
     * Hard to get absolutely right.  Use what we know about ASCII
     * and assume anything above the Latin control characters is
     * potentially an alphanumeric.
     */
    if(c <= ' ')
        return 0;
    if(0x7F<=c && c<=0xA0)
        return 0;
    if(strchr("!\"#$%&'()*+,-./:;<=>?@`[\\]^{|}~", c))
        return 0;
    return 1;
}
@
%$


%-------------------------------------------------------------

<<networking/ip/telnetd.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include <libsec.h>

#include "../ip/telnet.h"

/*  console state (for consctl) */
typedef struct Consstate	Consstate;
<<struct [[Consstate]]>>
<<global [[cons]]>>

<<global [[notefd]]>>
<<global [[noproto]]>>
<<global [[trusted]]>>
<<global [[nonone]]>>
<<global [[noworldonly]]>>

<<enum [[_anon_ (networking/ip/telnetd.c)]]>>

<<global [[netib]]>>
<<global [[childib]]>>
<<global [[remotesys]]>>

int	alnum(int);
int	conssim(void);
int	fromchild(char*, int);
int	fromnet(char*, int);
int	termchange(Biobuf*, int);
int	termsub(Biobuf*, uchar*, int);
int	xlocchange(Biobuf*, int);
int	xlocsub(Biobuf*, uchar*, int);
int	challuser(char*);
int	noworldlogin(char*);
void*	share(ulong);
int	doauth(char*);

<<constant [[TELNETLOG]]>>

<<function [[logit]]>>

<<function [[getremote]]>>

<<function [[main]]([[(networking/ip/telnetd.c)]])>>

<<function [[prompt]]>>

<<function [[challuser]]>>
<<function [[noworldlogin]]>>

<<function [[doauth]]>>

<<function [[fromchild]]>>

<<macro [[ECHO]]>>
<<function [[fromnet]]([[(networking/ip/telnetd.c)]])>>

<<function [[termchange]]>>

<<function [[termsub]]([[(networking/ip/telnetd.c)]])>>

<<function [[xlocchange]]>>

<<function [[xlocsub]]([[(networking/ip/telnetd.c)]])>>

<<function [[share]]([[(networking/ip/telnetd.c)]])>>

<<function [[conssim]]>>

<<function [[alnum]]>>
@


\subsection*{[[networking/ip/arp.h]]}

<<struct [[Arppkt]]>>=
/* Format of ethernet arp request */
struct Arppkt {
    uchar	d[6];
    uchar	s[6];
    uchar	type[2];
    uchar	hrd[2];
    uchar	pro[2];
    uchar	hln;
    uchar	pln;
    uchar	op[2];
    uchar	sha[6];
    uchar	spa[4];
    uchar	tha[6];
    uchar	tpa[4];
    };
@

<<constant [[ARPSIZE]]>>=
#define ARPSIZE		42
@

<<struct [[Arpentry]]>>=
/* Format of request from starp to user level arpd */
struct Arpentry {
    uchar	etaddr[6];
    uchar	ipaddr[4];
    };
@

<<struct [[Arpstats]]>>=
/* Arp cache statistics */
struct Arpstats {
    int	hit;
    int	miss;
    int	failed;
    };
@

<<constant [[ET_ARP]]>>=
#define ET_ARP		0x0806
@

<<constant [[ET_RARP]]>>=
#define ET_RARP		0x8035
@

<<constant [[ARP_REQUEST]]>>=
#define ARP_REQUEST	1
@

<<constant [[ARP_REPLY]]>>=
#define ARP_REPLY	2
@

<<constant [[RARP_REQUEST]]>>=
#define RARP_REQUEST	3
@

<<constant [[RARP_REPLY]]>>=
#define RARP_REPLY	4
@


%-------------------------------------------------------------

% used by the kernel? really?

<<networking/ip/arp.h>>=
/*
 *  this file used by (at least) the kernel, arpd, snoopy, tboot
 */
typedef struct Arppkt	Arppkt;
typedef struct Arpentry	Arpentry;
typedef struct Arpstats	Arpstats;

<<struct [[Arppkt]]>>

<<constant [[ARPSIZE]]>>

<<struct [[Arpentry]]>>

<<struct [[Arpstats]]>>

<<constant [[ET_ARP]]>>
<<constant [[ET_RARP]]>>

<<constant [[ARP_REQUEST]]>>
<<constant [[ARP_REPLY]]>>
<<constant [[RARP_REQUEST]]>>
<<constant [[RARP_REPLY]]>>
@


\subsection*{[[networking/ip/icmp.h]]}

<<enum [[_anon_ (networking/ip/icmp.h)]]>>=
/* ICMP for IP v4 and v6 */
enum
{
    /* Packet Types, icmp v4 (rfc 792) */
    EchoReply	= 0,
    Unreachable	= 3,
    SrcQuench	= 4,
    Redirect	= 5,
    EchoRequest	= 8,
    TimeExceed	= 11,
    InParmProblem	= 12,
    Timestamp	= 13,
    TimestampReply	= 14,
    InfoRequest	= 15,
    InfoReply	= 16,
    AddrMaskRequest = 17,
    AddrMaskReply   = 18,
    Traceroute	= 30,
    IPv6WhereAreYou	= 33,
    IPv6IAmHere	= 34,

    /* packet types, icmp v6 (rfc 2463) */

        /* error messages */
    UnreachableV6	= 1,
    PacketTooBigV6	= 2,
    TimeExceedV6	= 3,
    ParamProblemV6	= 4,

        /* informational messages (rfc 2461 also) */
    EchoRequestV6	= 128,
    EchoReplyV6	= 129,
    RouterSolicit	= 133,
    RouterAdvert	= 134,
    NbrSolicit	= 135,
    NbrAdvert	= 136,
    RedirectV6	= 137,

    Maxtype6	= 137,

    ICMP_HDRSIZE	= 8,
};
@

<<struct [[Ip4hdr]]([[(networking/ip/icmp.h)]])>>=
struct Ip4hdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	ipcksum[2];	/* Header checksum */
    uchar	src[4];		/* Ipv4 source */
    uchar	dst[4];		/* Ipv4 destination */

    uchar	data[];
};
@

<<struct [[Icmphdr]]>>=
struct Icmphdr {
    uchar	type;
    uchar	code;
    uchar	cksum[2];
    uchar	icmpid[2];
    uchar	seq[2];
    uchar	data[];
};
@


%-------------------------------------------------------------

<<networking/ip/icmp.h>>=
<<enum [[_anon_ (networking/ip/icmp.h)]]>>

typedef struct Ip4hdr Ip4hdr;
typedef struct Icmphdr Icmphdr;

<<struct [[Ip4hdr]]([[(networking/ip/icmp.h)]])>>

/* the icmp payload has the same format in v4 and v6 */
<<struct [[Icmphdr]]>>

// #define IP4HDRSZ offsetof(Ip4hdr, data[0])
// #define ICMPHDRSZ offsetof(Icmphdr, data[0])
@


\subsection*{[[networking/ip/glob.c]]}

<<function [[globnew]]>>=
static Glob*
globnew(void)
{
    Glob *g;

    g = mallocz(sizeof(*g), 1);
    if(g == nil)
        sysfatal("globnew: %r");
    return g;
}
@

<<function [[globfree1]]>>=
static void
globfree1(Glob *g)
{
    s_free(g->glob);
    free(g);
}
@

<<function [[globfree]]>>=
static void
globfree(Glob *g)
{
    Glob *next;

    for(; g != nil; g = next){
        next = g->next;
        globfree1(g);
    }
}
@

<<function [[globlistnew]]>>=
static Globlist*
globlistnew(char *x)
{
    Globlist *gl;

    gl = mallocz(sizeof *gl, 1);
    if(gl == nil)
        sysfatal("globlistnew: %r");
    gl->first = globnew();
    gl->first->glob = s_copy(x);
    gl->l = &gl->first->next;
    return gl;
}
@

<<function [[globlistfree]]>>=
void
globlistfree(Globlist *gl)
{
    if(gl == nil)
        return;
    globfree(gl->first);
    free(gl);
}
@

<<function [[globadd]]>>=
void
globadd(Globlist *gl, char *dir, char *file)
{
    Glob *g;

    g = globnew();
    g->glob = s_copy(dir);
    if(strcmp(dir, "/") != 0 && *dir != 0)
        s_append(g->glob, "/");
    s_append(g->glob, file);
    *(gl->l) = g;
    gl->l = &(g->next); 
}
@

<<function [[globdir]]>>=
static void
globdir(Globlist *gl, char *dir, Reprog *re)
{
    Dir *d;
    int i, n, fd;

    if(*dir == 0)
        fd = open(".", OREAD);
    else
        fd = open(dir, OREAD);
    if(fd < 0)
        return;
    n = dirreadall(fd, &d);
    if(n == 0)
        return;
    close(fd);
    for(i = 0; i < n; i++)
        if(regexec(re, d[i].name, nil, 0))
            globadd(gl, dir, d[i].name);
    free(d);
}
@

<<function [[globdot]]>>=
static void
globdot(Globlist *gl, char *dir)
{
    Dir *d;

    if(*dir == 0){
        globadd(gl, "", ".");
        return;
    }
    d = dirstat(dir);
    if(d == nil)
        return;
    if(d->qid.type & QTDIR)
        globadd(gl, dir, ".");
    free(d);
}
@

<<function [[globnext]]>>=
static void
globnext(Globlist *gl, char *pattern)
{
    String *np;
    Glob *g, *inlist;
    Reprog *re;
    int c;

    /* nothing left */
    if(*pattern == 0)
        return;

    inlist = gl->first;
    gl->first = nil;
    gl->l = &gl->first;

    /* pick off next pattern and turn into a reg exp */
    np = s_new();
    s_putc(np, '^');
    for(; c = *pattern; pattern++){
        if(c == '/'){
            pattern++;
            break;
        }
        switch(c){
        case '|':
        case '+':
        case '.':
        case '^':
        case '$':
        case '(':
        case ')':
            s_putc(np, '\\');
            s_putc(np, c);
            break;
        case '?':
            s_putc(np, '.');
            break;
        case '*':
            s_putc(np, '.');
            s_putc(np, '*');
            break;
        default:
            s_putc(np, c);
            break;
        }
    }
    s_putc(np, '$');
    s_terminate(np);
    if(strcmp(s_to_c(np), "^\\.$") == 0){
        /* anything that's a directory works */
        for(g = inlist; g != nil; g = g->next)
            globdot(gl, s_to_c(g->glob));
    } else {
        re = regcomp(s_to_c(np));

        /* run input list as directories */
        for(g = inlist; g != nil; g = g->next)
            globdir(gl, s_to_c(g->glob), re);
        free(re);
    }
    s_free(np);
    globfree(inlist);

    if(gl->first != nil)
        globnext(gl, pattern);
}
@
%$

<<function [[globiter]]>>=
char *
globiter(Globlist *gl)
{
    Glob *g;
    char *s;

    if(gl->first == nil)
        return nil;
    g = gl->first;
    gl->first = g->next;
    if(gl->first == nil)
        gl->l = &gl->first;
    s = strdup(s_to_c(g->glob));
    if(s == nil)
        sysfatal("globiter: %r");
    globfree1(g);
    return s;
}
@

<<function [[glob]]>>=
Globlist*
glob(char *pattern)
{
    Globlist *gl;

    if(pattern == nil || *pattern == 0)
        return nil;
    if(*pattern == '/'){
        pattern++;
        gl = globlistnew("/");
    } else
        gl = globlistnew("");
    globnext(gl, pattern);
    return gl;
}
@


%-------------------------------------------------------------

<<networking/ip/glob.c>>=
#include <u.h>
#include <libc.h>
#include <regexp.h>
#include <string.h>
#include "glob.h"

/*
 *  I wrote this glob so that there would be no limit
 *  on element or path size.  The one in rc is probably
 *  better, certainly faster. - presotto
 */

<<function [[globnew]]>>

<<function [[globfree1]]>>

<<function [[globfree]]>>

<<function [[globlistnew]]>>

<<function [[globlistfree]]>>

<<function [[globadd]]>>

<<function [[globdir]]>>

<<function [[globdot]]>>

<<function [[globnext]]>>

<<function [[globiter]]>>

<<function [[glob]]>>
@


\subsection*{[[networking/ip/glob.h]]}

<<struct [[Glob]]>>=
struct Glob{
    String	*glob;
    Glob	*next;
};
@

<<struct [[Globlist]]>>=
struct Globlist{
    Glob	*first;
    Glob	**l;
};
@


%-------------------------------------------------------------

<<networking/ip/glob.h>>=
typedef struct Glob Glob;
typedef struct Globlist Globlist;

<<struct [[Glob]]>>

<<struct [[Globlist]]>>

extern	Globlist*	glob(char*);
extern	void		globadd(Globlist*, char*, char*);
extern	void		globlistfree(Globlist *gl);
extern	char*		globiter(Globlist *gl);
@


\subsection*{[[networking/ip/measure.c]]}

<<struct [[Etherpkt]]([[(networking/ip/measure.c)]])>>=
struct Etherpkt {
    uchar d[6];
    uchar s[6];
    uchar type[2];
    char data[1500];
};
@

<<constant [[ETHERMINTU]]>>=
#define	ETHERMINTU	60	/* minimum transmit size */
@

<<constant [[ETHERMAXTU]]>>=
#define	ETHERMAXTU	1514	/* maximum transmit size */
@

<<constant [[ETHERHDRSIZE]]>>=
#define ETHERHDRSIZE	14	/* size of an ethernet header */
@

<<struct [[Ippkt]]>>=
struct Ippkt
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* Ip source */
    uchar	dst[4];		/* Ip destination */
    char	data[1];
};
@

<<constant [[IP_HDRSIZE]]>>=
#define IP_HDRSIZE	20
@

<<constant IP_UDPPROTO (measure.c)>>=
#define IP_UDPPROTO	17
@

<<constant [[IP_MBONEPROTO]]>>=
#define IP_MBONEPROTO	4
@

<<constant [[IP_TCPPROTO]]>>=
#define IP_TCPPROTO	6
@

<<constant IP_ILPROTO (measure.c)>>=
#define	IP_ILPROTO	40
@

<<constant [[IP_ICMPPROTO]]>>=
#define	IP_ICMPPROTO	1
@

<<constant [[IP_DF]]>>=
#define	IP_DF		0x4000
@

<<constant [[IP_MF]]>>=
#define	IP_MF		0x2000
@

<<macro [[NetS]]>>=
#define NetS(x) (((x)[0]<<8) | (x)[1])
@

<<macro [[NetL]]>>=
#define NetL(x) (((x)[0]<<24) | ((x)[1]<<16) | ((x)[2]<<8) | (x)[3])
@

<<global [[debug]]([[(networking/ip/measure.c)]])>>=
/*
 *  run flags
 */
int	debug;
@

<<global [[mbone]]>>=
int	mbone;
@

<<global [[protoin]]>>=
ulong protoin[256];
@

<<global [[protoout]]>>=
ulong protoout[256];
@

<<global [[protopin]]>>=
ulong protopin[256];
@

<<global [[protopout]]>>=
ulong protopout[256];
@

<<function [[error]]>>=
void
error(char *s)
{
    char buf[ERRMAX];

    errstr(buf, sizeof buf);
    fprint(2, "snoopy: %s %s\n", buf, s);
    exits("death");
}
@

<<function [[warning]]([[(networking/ip/measure.c)]])>>=
void
warning(char *s)
{
    char buf[ERRMAX];

    errstr(buf, sizeof buf);
    fprint(2, "snoopy: %s %s\n", buf, s);
}
@

<<function [[printproto]]>>=
void
printproto(int p)
{
    print("\t%d(%ld %ld %ld %ld)", p, protoin[p], protopin[p], protoout[p], protopout[p]);
}
@

<<function [[main]]([[(networking/ip/measure.c)]])>>=
void
main(int argc, char *argv[])
{
    Etherpkt e;
    Ippkt *ip;
    long n;
    int fd, cfd;
    int ts, len, t;
    long start;
    int delta;
    uchar target[6];
    char buf[256];
    ulong samples;

    samples = -1;
    ARGBEGIN{
    case 'd':
        debug++;
        break;
    case 's':
        samples = atoi(ARGF());
        break;
    }ARGEND;

    if(argc < 2){
        fprint(2, "usage: %s device ip-addr [minutes-per-sample]\n", argv0);
        exits("usage");
    }
    if(argc > 2)
        delta = atoi(argv[2])*60*1000;
    else
        delta = 5*60*1000;
    parseether(target, argv[1]);

    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);

    snprint(buf, sizeof(buf), "%s!-2", argv[0]);
    fd = dial(buf, 0, 0, &cfd);
    if(fd < 0)
        error("opening ether data");
    if(write(cfd, "promiscuous", sizeof("promiscuous")-1) <= 0)
        error("connecting");

    start = 0;
    fd = -1;

    for(;;){
        if(fd < 0){
            fd = dial(buf, 0, 0, &cfd);
            if(fd < 0)
                error("opening ether data");
            if(write(cfd, "promiscuous", sizeof("promiscuous")-1) <= 0)
                error("connecting");
            close(cfd);
        }
        n = read(fd, &e, sizeof(e));
        if(n <= 0)
            break;
        ts = NetL(&e.d[60]);
        n = NetS(&e.d[58]) - ETHERHDRSIZE;
        if(n < 0)
            continue;
        if(start == 0)
            start = ts;
        t = NetS(e.type);
        if(t == 0x0800 || (t&0xFF00) == 0x1000){
            ip = (Ippkt*)e.data;
            len = NetS(ip->length);
            if(len > n)
                len = n;
            if(debug)
                fprint(2, "%I -> %I %d\n", ip->src, ip->dst, len);
            if(memcmp(e.s, target, 6) == 0){
                protopin[0]++;
                protoin[0] += len;
                if(ip->proto){
                    protopin[ip->proto]++;
                    protoin[ip->proto] += len;
                }
            }
            if(memcmp(e.d, target, 6) == 0){
                protopout[0]++;
                protoout[0] += len;
                if(ip->proto){
                    protopout[ip->proto]++;
                    protoout[ip->proto] += len;
                }
            }
        }
        if(ts - start >= delta){
            print("%8.8ld %ld", time(0), ts - start);
            printproto(0);
            printproto(IP_MBONEPROTO);
            printproto(IP_UDPPROTO);
            printproto(IP_TCPPROTO);
            print("\n");
            start = 0;
            memset(protoin, 0, sizeof(protoin));
            memset(protoout, 0, sizeof(protoout));
            memset(protopin, 0, sizeof(protopin));
            memset(protopout, 0, sizeof(protopout));
            close(fd);
            fd = -1;
            if(--samples == 0)
                break;
        }
    }
    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ip/measure.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ip.h>

typedef struct Etherpkt	Etherpkt;
typedef struct Ippkt	Ippkt;

/*
 *  ether packet
 */
<<struct [[Etherpkt]]([[(networking/ip/measure.c)]])>>
<<constant [[ETHERMINTU]]>>
<<constant [[ETHERMAXTU]]>>
<<constant [[ETHERHDRSIZE]]>>

/*
 *  ip packets
 */
<<struct [[Ippkt]]>>

<<constant [[IP_HDRSIZE]]>>
<<constant IP_UDPPROTO (measure.c)>>
<<constant [[IP_MBONEPROTO]]>>
<<constant [[IP_TCPPROTO]]>>
<<constant IP_ILPROTO (measure.c)>>
<<constant [[IP_ICMPPROTO]]>>
<<constant [[IP_DF]]>>
<<constant [[IP_MF]]>>

<<macro [[NetS]]>>
<<macro [[NetL]]>>

<<global [[debug]]([[(networking/ip/measure.c)]])>>
<<global [[mbone]]>>

<<global [[protoin]]>>
<<global [[protoout]]>>
<<global [[protopin]]>>
<<global [[protopout]]>>

<<function [[error]]>>

<<function [[warning]]([[(networking/ip/measure.c)]])>>

<<function [[printproto]]>>

<<function [[main]]([[(networking/ip/measure.c)]])>>
@


\subsection*{[[networking/ip/rexexec.c]]}

<<function [[main]]([[(networking/ip/rexexec.c)]])>>=
/*
 * called by listen as rexexec rexexec net dir ...
 */
void
main(int argc, char **argv)
{
    char buf[8192];
    int n, nn;
    AuthInfo *ai;

    ARGBEGIN{
    }ARGEND;

    ai = auth_proxy(0, auth_getkey, "proto=p9any role=server");
    if(ai == nil)
        sysfatal("auth_proxy: %r");
    if(strcmp(ai->cuid, "none") == 0)
        sysfatal("rexexec by none disallowed");
    if(auth_chuid(ai, nil) < 0)
        sysfatal("auth_chuid: %r");

    n = 0;
    do {
        nn = read(0, buf+n, 1);
        if(nn <= 0)
            sysfatal("can't read command");
        n += nn;
        if(n == sizeof buf)
            buf[n-1] = '\0';
    } while (buf[n-1] != '\0');

    putenv("service", "rx");
    execl("/bin/rc", "rc", "-lc", buf, nil);
    sysfatal("can't exec rc");
}
@


%-------------------------------------------------------------

<<networking/ip/rexexec.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>

<<function [[main]]([[(networking/ip/rexexec.c)]])>>
@


\subsection*{[[networking/ip/wol.c]]}

<<enum [[_anon_ (networking/ip/wol.c)]]>>=
enum {
    Eaddrlen = 6,	/* 48 bits */
};
@

<<struct [[Wolpack]]>>=
struct Wolpack{
    uchar	magic[6];
    uchar	macs[16][Eaddrlen];
    char	pass[6+1];
};
@

<<global [[verbose]]>>=
int verbose;
@

<<function [[usage]]([[(networking/ip/wol.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: wol [-v] [-a dialstr] [-c password] macaddr\n");
    exits("usage");
}
@

<<function [[fillmac]]>>=
void
fillmac(Wolpack *w, uchar *mac)
{
    int i;

    for(i = 0; i < nelem(w->macs); i++)
        memmove(w->macs[i], mac, Eaddrlen);
}
@

<<function [[dumppack]]>>=
void
dumppack(Wolpack *w)
{
    int i;

    print("packet: [\n");
    print("\t%E\n", w->magic);
    for(i = 0; i < nelem(w->macs); i++)
        print("\t%E\n", w->macs[i]);
    print("\t%6s\n", w->pass);
    print("]\n");
}
@

<<function [[main]]([[(networking/ip/wol.c)]])>>=
void
main(int argc, char* argv[])
{
    int fd, nw;
    char *argmac, *pass, *address;
    uchar mac[Eaddrlen];
    static Wolpack w = {
        .magic = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, }
    };

    address = pass = nil;
    fmtinstall('E', eipfmt);

    ARGBEGIN{
    case 'a':
        address = EARGF(usage());
        break;
    case 'c':
        pass = EARGF(usage());
        break;
    case 'v':
        verbose++;
        break;
    default:
        usage();
    }ARGEND

    if(argc != 1)
        usage();
    argmac = argv[0];
    if(verbose)
        print("mac is %s, pass is %s\n", argmac, pass);

    parseether(mac, argmac);
    fillmac(&w, mac);
    if(pass){
        if(strlen(pass) > 6)
            sysfatal("password greater than 6 bytes");
        strcpy(w.pass, pass);
    }
    if(verbose)
        dumppack(&w);

    if(!address)
        address = "udp!255.255.255.255!0";

    fd = dial(address, nil, nil, nil);
    if(fd < 0)
        sysfatal("%s: %r", address);
    nw = write(fd, &w, sizeof w);
    if(nw != sizeof w)
        sysfatal("error sending: %r");
    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ip/wol.c>>=
/* send wake-on-lan magic ethernet packet */
#include <u.h>
#include <libc.h>
#include <ip.h>

<<enum [[_anon_ (networking/ip/wol.c)]]>>

typedef struct Wolpack Wolpack;
<<struct [[Wolpack]]>>

<<global [[verbose]]>>

<<function [[usage]]([[(networking/ip/wol.c)]])>>

<<function [[fillmac]]>>

<<function [[dumppack]]>>

<<function [[main]]([[(networking/ip/wol.c)]])>>
@


\subsection*{[[networking/ip/6in4.c]]}

<<enum [[_anon_ (networking/ip/6in4.c)]]>>=
/*
 * IPv6 and related IP protocols & their numbers:
 *
 * ipv6		41      IPv6            # Internet Protocol, version 6
 * ipv6-route	43      IPv6-Route      # Routing Header for IPv6
 * ipv6-frag	44      IPv6-Frag       # Fragment Header for IPv6
 * esp		50      ESP             # Encapsulating Security Payload
 * ah		51      AH              # Authentication Header
 * ipv6-icmp	58      IPv6-ICMP icmp6 # ICMP version 6
 * ipv6-nonxt	59      IPv6-NoNxt      # No Next Header for IPv6
 * ipv6-opts	60      IPv6-Opts       # Destination Options for IPv6
 */

enum {
    IP_IPV6PROTO	= 41,		/* IPv4 protocol number for IPv6 */
  IP_ESPPROTO	= 50,		/* IP v4 and v6 protocol number */
  IP_AHPROTO	= 51,		/* IP v4 and v6 protocol number */
    IP_ICMPV6PROTO	= 58,
    V6to4pfx	= 0x2002,
};
@

<<struct [[Iphdr]]>>=
struct Iphdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* Ip source (uchar ordering unimportant) */
    uchar	dst[4];		/* Ip destination (uchar ordering unimportant) */
    uchar	payload[];
};
@

<<constant [[STFHDR]]>>=
#define STFHDR offsetof(Iphdr, payload[0])
@

<<global [[anysender]]>>=
int anysender;
@

<<global [[gateway]]>>=
int gateway;
@

<<global [[debug]]([[(networking/ip/6in4.c)]])>>=
int debug;
@

<<global [[local6]]>>=
uchar local6[IPaddrlen];
@

<<global [[remote6]]>>=
uchar remote6[IPaddrlen];
@

<<global [[remote4]]>>=
uchar remote4[IPaddrlen];
@

<<global [[localmask]]>>=
uchar localmask[IPaddrlen];
@

<<global [[localnet]]>>=
uchar localnet[IPaddrlen];
@

<<global [[myip]]>>=
uchar myip[IPaddrlen];
@

<<global [[anycast6to4]]>>=
/* magic anycast address from rfc3068 */
uchar anycast6to4[IPv4addrlen] = { 192, 88, 99, 1 };
@

<<global [[net]]>>=
static char *net = "/net";
@

<<function [[usage]]([[(networking/ip/6in4.c)]])>>=
static void
usage(void)
{
    fprint(2, "usage: %s [-ag] [-x mtpt] [local6[/mask]] [remote4 [remote6]]\n",
        argv0);
    exits("Usage");
}
@

<<function [[defv6addr]]>>=
static char *
defv6addr(void)
{
    uchar *ipv4 = &myip[IPaddrlen - IPv4addrlen];

    return smprint("%ux:%2.2x%2.2x:%2.2x%2.2x::1/48", V6to4pfx,
        ipv4[0], ipv4[1], ipv4[2], ipv4[3]);
}
@

<<function [[procargs]]>>=
/* process non-option arguments */
static void
procargs(int argc, char **argv)
{
    char *p, *loc6;

    if (argc < 1)
        loc6 = defv6addr();
    else if (strcmp(argv[0], "-") == 0) {
        loc6 = defv6addr();
        argv++;
        argc--;
    } else {
        loc6 = *argv++;
        argc--;
    }

    /* local v6 address (mask defaults to /128) */
    memcpy(localmask, IPallbits, sizeof localmask);
    p = strchr(loc6, '/');
    if (p != nil) {
        parseipmask(localmask, p);
        *p = 0;
    }
    if (parseip(local6, loc6) == -1)
        sysfatal("bad local v6 address %s", loc6);
    if (isv4(local6))
        usage();
    if (argc >= 1 && argv[0][0] == '/') {
        parseipmask(localmask, *argv++);
        argc--;
    }
    if (debug)
        fprint(2, "local6 %I %M\n", local6, localmask);

    /* remote v4 address (defaults to anycast 6to4) */
    if (argc >= 1) {
        if (parseip(remote4, *argv++) == -1)
            sysfatal("bad remote v4 address %s", argv[-1]);
        argc--;
        if (!isv4(remote4))
            usage();
    } else {
        v4tov6(remote4, anycast6to4);
        anysender++;
    }
    if (debug)
        fprint(2, "remote4 %I\n", remote4);

    /* remote v6 address (defaults to link-local w/ v4 as interface part) */
    if (argc >= 1) {
        if (parseip(remote6, *argv++) == -1)
            sysfatal("bad remote v6 address %s", argv[-1]);
        argc--;
    } else {
        remote6[0] = 0xFE;		/* link local */
        remote6[1] = 0x80;
        memcpy(remote6 + IPv4off, remote4 + IPv4off, IPv4addrlen);
    }
    USED(argv);
    if (argc != 0)
        usage();

    maskip(local6, localmask, localnet);
    if (debug)
        fprint(2, "localnet %I remote6 %I\n", localnet, remote6);
}
@

<<function [[setup]]>>=
static void
setup(int *v6net, int *tunp)
{
    int n, cfd;
    char *p, *cl, *ir;
    char buf[128], path[64];

    /*
     * gain access to IPv6-in-IPv4 packets via ipmux
     */
    p = seprint(buf, buf + sizeof buf, "%s/ipmux!proto=%2.2x|%2.2x;dst=%V",
        net, IP_IPV6PROTO, IP_ICMPV6PROTO, myip + IPv4off);
    if (!anysender)
        seprint(p, buf + sizeof buf, ";src=%V", remote4 + IPv4off);
    *tunp = dial(buf, 0, 0, 0);
    if (*tunp < 0)
        sysfatal("can't access ipv6-in-ipv4 with dial str %s: %r", buf);
    if (debug)
        fprint(2, "dialed %s for v6-in-v4 access\n", buf);

    /*
     * open local IPv6 interface (as a packet interface)
     */

    cl = smprint("%s/ipifc/clone", net);
    cfd = open(cl, ORDWR);			/* allocate a conversation */
    n = 0;
    if (cfd < 0 || (n = read(cfd, buf, sizeof buf - 1)) <= 0)
        sysfatal("can't make packet interface %s: %r", cl);
    if (debug)
        fprint(2, "cloned %s as local v6 interface\n", cl);
    free(cl);
    buf[n] = 0;

    snprint(path, sizeof path, "%s/ipifc/%s/data", net, buf);
    *v6net = open(path, ORDWR);
    if (*v6net < 0 || fprint(cfd, "bind pkt") < 0)
        sysfatal("can't bind packet interface: %r");
    /* 1280 is MTU, apparently from rfc2460 */
    if (fprint(cfd, "add %I /128 %I 1280", local6, remote6) <= 0)
        sysfatal("can't set local ipv6 address: %r");
    close(cfd);
    if (debug)
        fprint(2, "opened & bound %s as local v6 interface\n", path);

    if (gateway) {
        /* route global addresses through the tunnel to remote6 */
        ir = smprint("%s/iproute", net);
        cfd = open(ir, OWRITE);
        if (cfd >= 0 && debug)
            fprint(2, "injected 2000::/3 %I into %s\n", remote6, ir);
        free(ir);
        if (cfd < 0 || fprint(cfd, "add 2000:: /3 %I", remote6) <= 0)
            sysfatal("can't set default global route: %r");
    }
}
@

<<function [[runtunnel]]>>=
static void
runtunnel(int v6net, int tunnel)
{
    /* run the tunnel copying in the background */
    switch (rfork(RFPROC|RFNOWAIT|RFMEM|RFNOTEG)) {
    case -1:
        sysfatal("rfork");
    default:
        exits(nil);
    case 0:
        break;
    }

    switch (rfork(RFPROC|RFNOWAIT|RFMEM)) {
    case -1:
        sysfatal("rfork");
    default:
        tunnel2ip(tunnel, v6net);
        break;
    case 0:
        ip2tunnel(v6net, tunnel);
        break;
    }
    exits("tunnel gone");
}
@

<<function [[main]]([[(networking/ip/6in4.c)]])>>=
void
main(int argc, char **argv)
{
    int tunnel, v6net;

    fmtinstall('I', eipfmt);
    fmtinstall('V', eipfmt);
    fmtinstall('M', eipfmt);

    ARGBEGIN {
    case 'a':
        anysender++;
        break;
    case 'd':
        debug++;
        break;
    case 'g':
        gateway++;
        break;
    case 'x':
        net = EARGF(usage());
        break;
    default:
        usage();
    } ARGEND

    if (myipaddr(myip, net) < 0)
        sysfatal("can't find my ipv4 address on %s", net);
    if (!isv4(myip))
        sysfatal("my ip, %I, is not a v4 address", myip);

    procargs(argc, argv);
    setup(&v6net, &tunnel);
    runtunnel(v6net, tunnel);
    exits(0);
}
@

<<function [[procsetname]]>>=
/*
 * based on libthread's threadsetname, but drags in less library code.
 * actually just sets the arguments displayed.
 */
void
procsetname(char *fmt, ...)
{
    int fd;
    char *cmdname;
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if (cmdname == nil)
        return;
    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OWRITE)) >= 0){
        write(fd, cmdname, strlen(cmdname)+1);
        close(fd);
    }
    free(cmdname);
}
@

<<function [[ip2tunnel]]>>=
/*
 * encapsulate v6 packets from the packet interface in v4 ones
 * and send them into the tunnel.
 */
static void
ip2tunnel(int in, int out)
{
    int n, m;
    char buf[64*1024];
    Iphdr *op;
    Ip6hdr *ip;

    if (anysender)
        procsetname("v6 %I -> tunnel", local6);
    else
        procsetname("v6 %I -> tunnel %I %I", local6, remote4, remote6);

    /* populate v4 header */
    op = (Iphdr*)buf;
    op->vihl = IP_VER4 | 5;		/* hdr is 5 longs? */
    memcpy(op->src, myip + IPv4off, sizeof op->src);
    op->proto = IP_IPV6PROTO;	/* inner protocol */
    op->ttl = 100;

    /* get a V6 packet destined for the tunnel */
    ip = (Ip6hdr*)(buf + STFHDR);
    while ((n = read(in, ip, sizeof buf - STFHDR)) > 0) {
        /* if not IPV6, drop it */
        if ((ip->vcf[0] & 0xF0) != IP_VER6)
            continue;

        /* check length: drop if too short, trim if too long */
        m = nhgets(ip->ploadlen) + IPV6HDR_LEN;
        if (m > n)
            continue;
        if (m < n)
            n = m;

        /* drop if v6 source or destination address is naughty */
        if (badipv6(ip->src)) {
            syslog(0, "6in4", "egress filtered %I -> %I; bad src",
                ip->src, ip->dst);
            continue;
        }
        if ((!equivip6(ip->dst, remote6) && badipv6(ip->dst))) {
            syslog(0, "6in4", "egress filtered %I -> %I; "
                "bad dst not remote", ip->src, ip->dst);
            continue;
        }

        if (debug > 1)
            fprint(2, "v6 to tunnel %I -> %I\n", ip->src, ip->dst);

        /* send 6to4 packets directly to ipv4 target */
        if ((ip->dst[0]<<8 | ip->dst[1]) == V6to4pfx)
            memcpy(op->dst, ip->dst+2, sizeof op->dst);
        else
            memcpy(op->dst, remote4+IPv4off, sizeof op->dst);

        n += STFHDR;
        /* pass packet to the other end of the tunnel */
        if (write(out, op, n) != n) {
            syslog(0, "6in4", "error writing to tunnel (%r), giving up");
            break;
        }
    }
}
@

<<function [[tunnel2ip]]>>=
/*
 * decapsulate v6 packets from v4 ones from the tunnel
 * and forward them to the packet interface
 */
static void
tunnel2ip(int in, int out)
{
    int n, m;
    char buf[64*1024];
    uchar a[IPaddrlen];
    Ip6hdr *op;
    Iphdr *ip;

    if (anysender)
        procsetname("tunnel -> v6 %I", local6);
    else
        procsetname("tunnel %I %I -> v6 %I", remote4, remote6, local6);

    for (;;) {
        /* get a packet from the tunnel */
        n = read(in, buf, sizeof buf);
        ip = (Iphdr*)(buf + IPaddrlen);
        n -= IPaddrlen;
        if (n <= 0) {
            syslog(0, "6in4", "error reading from tunnel (%r), giving up");
            break;
        }

        /* if not IPv4 nor IPv4 protocol IPv6 nor ICMPv6, drop it */
        if ((ip->vihl & 0xF0) != IP_VER4 ||
            ip->proto != IP_IPV6PROTO && ip->proto != IP_ICMPV6PROTO) {
            syslog(0, "6in4",
                "dropping pkt from tunnel with inner proto %d",
                ip->proto);
            continue;
        }

        /* check length: drop if too short, trim if too long */
        m = nhgets(ip->length);
        if (m > n)
            continue;
        if (m < n)
            n = m;

        op = (Ip6hdr*)(buf + IPaddrlen + STFHDR);
        n -= STFHDR;

        /*
         * don't relay: just accept packets for local host/subnet
         * (this blocks link-local and multicast addresses as well)
         */
        maskip(op->dst, localmask, a);
        if (!equivip6(a, localnet)) {
            syslog(0, "6in4", "ingress filtered %I -> %I; "
                "dst not on local net", op->src, op->dst);
            continue;
        }
        if (debug > 1)
            fprint(2, "tunnel to v6 %I -> %I\n", op->src, op->dst);

        /* pass V6 packet to the interface */
        if (write(out, op, n) != n) {
            syslog(0, "6in4", "error writing to packet interface (%r), giving up");
            break;
        }
    }
}
@

<<function [[badipv4]]>>=
static int
badipv4(uchar *a)
{
    switch (a[0]) {
    case 0:				/* unassigned */
    case 10:			/* private */
    case 127:			/* loopback */
        return 1;
    case 172:
        return a[1] >= 16;	/* 172.16.0.0/12 private */
    case 192:
        return a[1] == 168;	/* 192.168.0.0/16 private */
    case 169:
        return a[1] == 254;	/* 169.254.0.0/16 DHCP link-local */
    }
    /* 224.0.0.0/4 multicast, 240.0.0.0/4 reserved, broadcast */
    return a[0] >= 240;
}
@

<<function [[badipv6]]>>=
/*
 * 0x0000/16 prefix = v4 compatible, v4 mapped, loopback, unspecified...
 * site-local is now deprecated, rfc3879
 */
static int
badipv6(uchar *a)
{
    int h = a[0]<<8 | a[1];

    return h == 0 || ISIPV6MCAST(a) || ISIPV6LINKLOCAL(a) ||
        h == V6to4pfx && badipv4(a+2);
}
@


%-------------------------------------------------------------

<<networking/ip/6in4.c>>=
/*
 * 6in4 - tunnel client for automatic 6to4 or configured v6-in-v4 tunnels.
 *	see rfc3056.
 */

#include <u.h>
#include <libc.h>
#include <ip.h>

<<enum [[_anon_ (networking/ip/6in4.c)]]>>

typedef struct Iphdr Iphdr;
<<struct [[Iphdr]]>>

<<constant [[STFHDR]]>>

<<global [[anysender]]>>
<<global [[gateway]]>>
<<global [[debug]]([[(networking/ip/6in4.c)]])>>

<<global [[local6]]>>
<<global [[remote6]]>>
<<global [[remote4]]>>
<<global [[localmask]]>>
<<global [[localnet]]>>
<<global [[myip]]>>

<<global [[anycast6to4]]>>

<<global [[net]]>>

static int	badipv4(uchar*);
static int	badipv6(uchar*);
static void	ip2tunnel(int, int);
static void	tunnel2ip(int, int);

<<function [[usage]]([[(networking/ip/6in4.c)]])>>

<<function [[defv6addr]]>>

<<function [[procargs]]>>

<<function [[setup]]>>

<<function [[runtunnel]]>>

<<function [[main]]([[(networking/ip/6in4.c)]])>>

<<function [[procsetname]]>>

<<function [[ip2tunnel]]>>

<<function [[tunnel2ip]]>>

<<function [[badipv4]]>>

<<function [[badipv6]]>>
@


\section{[[networking/misc/]]}

\subsection*{[[networking/misc/cpu.c]]}

<<constant [[Maxfdata]]>>=
#define	Maxfdata 8192
@

<<constant [[MaxStr]]>>=
#define MaxStr 128
@

<<global [[keyspec]]>>=
char *keyspec = "";
@

<<global [[notechan]]>>=
int 	notechan;
@

<<global [[exportpid]]>>=
int	exportpid;
@

<<global [[system]]>>=
char	*system;
@

<<global [[cflag]]>>=
int	cflag;
@

<<global [[dbg]]>>=
int	dbg;
@

<<global [[user]]>>=
char	*user;
@

<<global [[patternfile]]>>=
char	*patternfile;
@

<<global [[origargs]]>>=
char	*origargs;
@

<<global [[srvname]]>>=
char	*srvname = "ncpu";
@

<<global [[exportfs]]>>=
char	*exportfs = "/bin/exportfs";
@

<<global [[ealgs]]>>=
char	*ealgs = "rc4_256 sha1";
@

<<global [[msgsize]]>>=
/* message size for exportfs; may be larger so we can do big graphics in CPU window */
int	msgsize = Maxfdata+IOHDRSZ;
@

<<global [[authmethod]]>>=
struct AuthMethod {
    char	*name;			/* name of method */
    int	(*cf)(int);		/* client side authentication */
    int	(*sf)(int, char*);	/* server side authentication */
} authmethod[] =
{
    { "p9",		p9auth,		srvp9auth,},
    { "netkey",	netkeyauth,	netkeysrvauth,},
//	{ "none",	noauth,		srvnoauth,},
    { nil,	nil}
};
@

<<global [[am]]>>=
AuthMethod *am = authmethod;	/* default is p9 */
@

<<global [[p9authproto]]>>=
char *p9authproto = "p9any";
@

<<function [[usage]]([[(networking/misc/cpu.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: cpu [-h system] [-u user] [-a authmethod] "
        "[-e 'crypt hash'] [-k keypattern] [-P patternfile] "
        "[-c cmd arg ...]\n");
    exits("usage");
}
@

<<function [[procgetname]]>>=
/*
 * reading /proc/pid/args yields either "name args" or "name [display args]",
 * so return only args or display args.
 */
static char *
procgetname(void)
{
    int fd, n;
    char *lp, *rp;
    char buf[256];

    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OREAD)) < 0)
        return strdup("");
    *buf = '\0';
    n = read(fd, buf, sizeof buf-1);
    close(fd);
    if (n >= 0)
        buf[n] = '\0';
    if ((lp = strchr(buf, '[')) == nil || (rp = strrchr(buf, ']')) == nil) {
        lp = strchr(buf, ' ');
        if (lp == nil)
            return strdup("");
        else
            return strdup(lp+1);
    }
    *rp = '\0';
    return strdup(lp+1);
}
@

<<function [[procsetname]]([[(networking/misc/cpu.c)]])>>=
/*
 * based on libthread's threadsetname, but drags in less library code.
 * actually just sets the arguments displayed.
 */
void
procsetname(char *fmt, ...)
{
    int fd;
    char *cmdname;
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if (cmdname == nil)
        return;
    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OWRITE)) >= 0){
        write(fd, cmdname, strlen(cmdname)+1);
        close(fd);
    }
    free(cmdname);
}
@

<<function [[main]]([[(networking/misc/cpu.c)]])>>=
void
main(int argc, char **argv)
{
    char dat[MaxStr], buf[MaxStr], cmd[MaxStr], *p, *err;
    int ac, fd, ms, data;
    char *av[10];

    quotefmtinstall();
    origargs = procgetname();
    /* see if we should use a larger message size */
    fd = open("/dev/draw", OREAD);
    if(fd > 0){
        ms = iounit(fd);
        if(msgsize < ms+IOHDRSZ)
            msgsize = ms+IOHDRSZ;
        close(fd);
    }

    user = getuser();
    if(user == nil)
        fatal(1, "can't read user name");
    ARGBEGIN{
    case 'a':
        p = EARGF(usage());
        if(setam(p) < 0)
            fatal(0, "unknown auth method %s", p);
        break;
    case 'e':
        ealgs = EARGF(usage());
        if(*ealgs == 0 || strcmp(ealgs, "clear") == 0)
            ealgs = nil;
        break;
    case 'd':
        dbg++;
        break;
    case 'f':
        /* ignored but accepted for compatibility */
        break;
    case 'O':
        p9authproto = "p9sk2";
        remoteside(1);				/* From listen */
        break;
    case 'R':				/* From listen */
        remoteside(0);
        break;
    case 'h':
        system = EARGF(usage());
        break;
    case 'c':
        cflag++;
        cmd[0] = '!';
        cmd[1] = '\0';
        while(p = ARGF()) {
            strcat(cmd, " ");
            strcat(cmd, p);
        }
        break;
    case 'k':
        keyspec = smprint("%s %s", keyspec, EARGF(usage()));
        break;
    case 'P':
        patternfile = EARGF(usage());
        break;
    case 'u':
        user = EARGF(usage());
        keyspec = smprint("%s user=%s", keyspec, user);
        break;
    default:
        usage();
    }ARGEND;


    if(argc != 0)
        usage();

    if(system == nil) {
        p = getenv("cpu");
        if(p == 0)
            fatal(0, "set $cpu");
        system = p;
    }

    if(err = rexcall(&data, system, srvname))
        fatal(1, "%s: %s", err, system);

    procsetname("%s", origargs);
    /* Tell the remote side the command to execute and where our working directory is */
    if(cflag)
        writestr(data, cmd, "command", 0);
    if(getwd(dat, sizeof(dat)) == 0)
        writestr(data, "NO", "dir", 0);
    else
        writestr(data, dat, "dir", 0);

    /* start up a process to pass along notes */
    lclnoteproc(data);

    /* 
     *  Wait for the other end to execute and start our file service
     *  of /mnt/term
     */
    if(readstr(data, buf, sizeof(buf)) < 0)
        fatal(1, "waiting for FS: %r");
    if(strncmp("FS", buf, 2) != 0) {
        print("remote cpu: %s", buf);
        exits(buf);
    }

    /* Begin serving the gnot namespace */
    close(0);
    dup(data, 0);
    close(data);

    sprint(buf, "%d", msgsize);
    ac = 0;
    av[ac++] = exportfs;
    av[ac++] = "-m";
    av[ac++] = buf;
    if(dbg)
        av[ac++] = "-d";
    if(patternfile != nil){
        av[ac++] = "-P";
        av[ac++] = patternfile;
    }
    av[ac] = nil;
    exec(exportfs, av);
    fatal(1, "starting exportfs");
}
@
%$

<<function [[fatal]]([[(networking/misc/cpu.c)]])>>=
void
fatal(int syserr, char *fmt, ...)
{
    Fmt f;
    char *str;
    va_list arg;

    fmtstrinit(&f);
    fmtprint(&f, "cpu: ");
    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    if(syserr)
        fmtprint(&f, ": %r");
    str = fmtstrflush(&f);

    fprint(2, "%s\n", str);
    syslog(0, "cpu", str);
    exits(str);
}
@

<<global [[negstr]]>>=
char *negstr = "negotiating authentication method";
@

<<global [[bug]]>>=
char bug[256];
@

<<function [[old9p]]>>=
int
old9p(int fd)
{
    int p[2];

    if(pipe(p) < 0)
        fatal(1, "pipe");

    switch(rfork(RFPROC|RFFDG|RFNAMEG)) {
    case -1:
        fatal(1, "rfork srvold9p");
    case 0:
        if(fd != 1){
            dup(fd, 1);
            close(fd);
        }
        if(p[0] != 0){
            dup(p[0], 0);
            close(p[0]);
        }
        close(p[1]);
        if(0){
            fd = open("/sys/log/cpu", OWRITE);
            if(fd != 2){
                dup(fd, 2);
                close(fd);
            }
            execl("/bin/srvold9p", "srvold9p", "-ds", nil);
        } else
            execl("/bin/srvold9p", "srvold9p", "-s", nil);
        fatal(1, "exec srvold9p");
    default:
        close(fd);
        close(p[0]);
    }
    return p[1];	
}
@

<<function [[remoteside]]>>=
/* Invoked with stdin, stdout and stderr connected to the network connection */
void
remoteside(int old)
{
    char user[MaxStr], home[MaxStr], buf[MaxStr], xdir[MaxStr], cmd[MaxStr];
    int i, n, fd, badchdir, gotcmd;

    rfork(RFENVG);
    putenv("service", "cpu");
    fd = 0;

    /* negotiate authentication mechanism */
    n = readstr(fd, cmd, sizeof(cmd));
    if(n < 0)
        fatal(1, "authenticating");
    if(setamalg(cmd) < 0){
        writestr(fd, "unsupported auth method", nil, 0);
        fatal(1, "bad auth method %s", cmd);
    } else
        writestr(fd, "", "", 1);

    fd = (*am->sf)(fd, user);
    if(fd < 0)
        fatal(1, "srvauth");

    /* Set environment values for the user */
    putenv("user", user);
    sprint(home, "/usr/%s", user);
    putenv("home", home);

    /* Now collect invoking cpu's current directory or possibly a command */
    gotcmd = 0;
    if(readstr(fd, xdir, sizeof(xdir)) < 0)
        fatal(1, "dir/cmd");
    if(xdir[0] == '!') {
        strcpy(cmd, &xdir[1]);
        gotcmd = 1;
        if(readstr(fd, xdir, sizeof(xdir)) < 0)
            fatal(1, "dir");
    }

    /* Establish the new process at the current working directory of the
     * gnot */
    badchdir = 0;
    if(strcmp(xdir, "NO") == 0)
        chdir(home);
    else if(chdir(xdir) < 0) {
        badchdir = 1;
        chdir(home);
    }

    /* Start the gnot serving its namespace */
    writestr(fd, "FS", "FS", 0);
    writestr(fd, "/", "exportfs dir", 0);

    n = read(fd, buf, sizeof(buf));
    if(n != 2 || buf[0] != 'O' || buf[1] != 'K')
        exits("remote tree");

    if(old)
        fd = old9p(fd);

    /* make sure buffers are big by doing fversion explicitly; pick a huge number; other side will trim */
    strcpy(buf, VERSION9P);
    if(fversion(fd, 64*1024, buf, sizeof buf) < 0)
        exits("fversion failed");
    if(mount(fd, -1, "/mnt/term", MCREATE|MREPL, "") < 0)
        exits("mount failed");

    close(fd);

    /* the remote noteproc uses the mount so it must follow it */
    rmtnoteproc();

    for(i = 0; i < 3; i++)
        close(i);

    if(open("/mnt/term/dev/cons", OREAD) != 0)
        exits("open stdin");
    if(open("/mnt/term/dev/cons", OWRITE) != 1)
        exits("open stdout");
    dup(1, 2);

    if(badchdir)
        print("cpu: failed to chdir to '%s'\n", xdir);

    if(gotcmd)
        execl("/bin/rc", "rc", "-lc", cmd, nil);
    else
        execl("/bin/rc", "rc", "-li", nil);
    fatal(1, "exec shell");
}
@

<<function [[rexcall]]>>=
char*
rexcall(int *fd, char *host, char *service)
{
    char *na;
    char dir[MaxStr];
    char err[ERRMAX];
    char msg[MaxStr];
    int n;

    na = netmkaddr(host, 0, service);
    procsetname("dialing %s", na);
    if((*fd = dial(na, 0, dir, 0)) < 0)
        return "can't dial";

    /* negotiate authentication mechanism */
    if(ealgs != nil)
        snprint(msg, sizeof(msg), "%s %s", am->name, ealgs);
    else
        snprint(msg, sizeof(msg), "%s", am->name);
    procsetname("writing %s", msg);
    writestr(*fd, msg, negstr, 0);
    procsetname("awaiting auth method");
    n = readstr(*fd, err, sizeof err);
    if(n < 0)
        return negstr;
    if(*err){
        werrstr(err);
        return negstr;
    }

    /* authenticate */
    procsetname("%s: auth via %s", origargs, am->name);
    *fd = (*am->cf)(*fd);
    if(*fd < 0)
        return "can't authenticate";
    return 0;
}
@

<<function [[writestr]]>>=
void
writestr(int fd, char *str, char *thing, int ignore)
{
    int l, n;

    l = strlen(str);
    n = write(fd, str, l+1);
    if(!ignore && n < 0)
        fatal(1, "writing network: %s", thing);
}
@

<<function [[readstr]]>>=
int
readstr(int fd, char *str, int len)
{
    int n;

    while(len) {
        n = read(fd, str, 1);
        if(n < 0) 
            return -1;
        if(*str == '\0')
            return 0;
        str++;
        len--;
    }
    return -1;
}
@

<<function [[readln]]>>=
static int
readln(char *buf, int n)
{
    int i;
    char *p;

    n--;	/* room for \0 */
    p = buf;
    for(i=0; i<n; i++){
        if(read(0, p, 1) != 1)
            break;
        if(*p == '\n' || *p == '\r')
            break;
        p++;
    }
    *p = '\0';
    return p-buf;
}
@

<<function [[netkeyauth]]>>=
/*
 *  user level challenge/response
 */
static int
netkeyauth(int fd)
{
    char chall[32];
    char resp[32];

    strecpy(chall, chall+sizeof chall, getuser());
    print("user[%s]: ", chall);
    if(readln(resp, sizeof(resp)) < 0)
        return -1;
    if(*resp != 0)
        strcpy(chall, resp);
    writestr(fd, chall, "challenge/response", 1);

    for(;;){
        if(readstr(fd, chall, sizeof chall) < 0)
            break;
        if(*chall == 0)
            return fd;
        print("challenge: %s\nresponse: ", chall);
        if(readln(resp, sizeof(resp)) < 0)
            break;
        writestr(fd, resp, "challenge/response", 1);
    }
    return -1;
}
@

<<function [[netkeysrvauth]]>>=
static int
netkeysrvauth(int fd, char *user)
{
    char response[32];
    Chalstate *ch;
    int tries;
    AuthInfo *ai;

    if(readstr(fd, user, 32) < 0)
        return -1;

    ai = nil;
    ch = nil;
    for(tries = 0; tries < 10; tries++){
        if((ch = auth_challenge("proto=p9cr role=server user=%q", user)) == nil)
            return -1;
        writestr(fd, ch->chal, "challenge", 1);
        if(readstr(fd, response, sizeof response) < 0)
            return -1;
        ch->resp = response;
        ch->nresp = strlen(response);
        if((ai = auth_response(ch)) != nil)
            break;
    }
    auth_freechal(ch);
    if(ai == nil)
        return -1;
    writestr(fd, "", "challenge", 1);
    if(auth_chuid(ai, 0) < 0)
        fatal(1, "newns");
    auth_freeAI(ai);
    return fd;
}
@

<<function [[mksecret]]>>=
static void
mksecret(char *t, uchar *f)
{
    sprint(t, "%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux",
        f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9]);
}
@

<<function [[p9auth]]>>=
/*
 *  plan9 authentication followed by rc4 encryption
 */
static int
p9auth(int fd)
{
    uchar key[16];
    uchar digest[SHA1dlen];
    char fromclientsecret[21];
    char fromserversecret[21];
    int i;
    AuthInfo *ai;

    procsetname("%s: auth_proxy proto=%q role=client %s",
        origargs, p9authproto, keyspec);
    ai = auth_proxy(fd, auth_getkey, "proto=%q role=client %s", p9authproto, keyspec);
    if(ai == nil)
        return -1;
    memmove(key+4, ai->secret, ai->nsecret);
    if(ealgs == nil)
        return fd;

    /* exchange random numbers */
    srand(truerand());
    for(i = 0; i < 4; i++)
        key[i] = rand();
    procsetname("writing p9 key");
    if(write(fd, key, 4) != 4)
        return -1;
    procsetname("reading p9 key");
    if(readn(fd, key+12, 4) != 4)
        return -1;

    /* scramble into two secrets */
    sha1(key, sizeof(key), digest, nil);
    mksecret(fromclientsecret, digest);
    mksecret(fromserversecret, digest+10);

    /* set up encryption */
    procsetname("pushssl");
    i = pushssl(fd, ealgs, fromclientsecret, fromserversecret, nil);
    if(i < 0)
        werrstr("can't establish ssl connection: %r");
    return i;
}
@

<<function [[noauth]]>>=
static int
noauth(int fd)
{
    ealgs = nil;
    return fd;
}
@

<<function [[srvnoauth]]>>=
static int
srvnoauth(int fd, char *user)
{
    strecpy(user, user+MaxStr, getuser());
    ealgs = nil;
    newns(user, nil);
    return fd;
}
@

<<function [[loghex]]>>=
void
loghex(uchar *p, int n)
{
    char buf[100];
    int i;

    for(i = 0; i < n; i++)
        sprint(buf+2*i, "%2.2ux", p[i]);
    syslog(0, "cpu", buf);
}
@

<<function [[srvp9auth]]>>=
static int
srvp9auth(int fd, char *user)
{
    uchar key[16];
    uchar digest[SHA1dlen];
    char fromclientsecret[21];
    char fromserversecret[21];
    int i;
    AuthInfo *ai;

    ai = auth_proxy(0, nil, "proto=%q role=server %s", p9authproto, keyspec);
    if(ai == nil)
        return -1;
    if(auth_chuid(ai, nil) < 0)
        return -1;
    strecpy(user, user+MaxStr, ai->cuid);
    memmove(key+4, ai->secret, ai->nsecret);

    if(ealgs == nil)
        return fd;

    /* exchange random numbers */
    srand(truerand());
    for(i = 0; i < 4; i++)
        key[i+12] = rand();
    if(readn(fd, key, 4) != 4)
        return -1;
    if(write(fd, key+12, 4) != 4)
        return -1;

    /* scramble into two secrets */
    sha1(key, sizeof(key), digest, nil);
    mksecret(fromclientsecret, digest);
    mksecret(fromserversecret, digest+10);

    /* set up encryption */
    i = pushssl(fd, ealgs, fromserversecret, fromclientsecret, nil);
    if(i < 0)
        werrstr("can't establish ssl connection: %r");
    return i;
}
@

<<function [[setam]]>>=
/*
 *  set authentication mechanism
 */
int
setam(char *name)
{
    for(am = authmethod; am->name != nil; am++)
        if(strcmp(am->name, name) == 0)
            return 0;
    am = authmethod;
    return -1;
}
@

<<function [[setamalg]]>>=
/*
 *  set authentication mechanism and encryption/hash algs
 */
int
setamalg(char *s)
{
    ealgs = strchr(s, ' ');
    if(ealgs != nil)
        *ealgs++ = 0;
    return setam(s);
}
@

<<global [[rmtnotefile]]>>=
char *rmtnotefile = "/mnt/term/dev/cpunote";
@

<<function [[rmtnoteproc]]>>=
/*
 *  loop reading /mnt/term/dev/note looking for notes.
 *  The child returns to start the shell.
 */
void
rmtnoteproc(void)
{
    int n, fd, pid, notepid;
    char buf[256];

    /* new proc returns to start shell */
    pid = rfork(RFPROC|RFFDG|RFNOTEG|RFNAMEG|RFMEM);
    switch(pid){
    case -1:
        syslog(0, "cpu", "cpu -R: can't start noteproc: %r");
        return;
    case 0:
        return;
    }

    /* new proc reads notes from other side and posts them to shell */
    switch(notepid = rfork(RFPROC|RFFDG|RFMEM)){
    case -1:
        syslog(0, "cpu", "cpu -R: can't start wait proc: %r");
        _exits(0);
    case 0:
        fd = open(rmtnotefile, OREAD);
        if(fd < 0){
            syslog(0, "cpu", "cpu -R: can't open %s", rmtnotefile);
            _exits(0);
        }
    
        for(;;){
            n = read(fd, buf, sizeof(buf)-1);
            if(n <= 0){
                postnote(PNGROUP, pid, "hangup");
                _exits(0);
            }
            buf[n] = 0;
            postnote(PNGROUP, pid, buf);
        }
    }

    /* original proc waits for shell proc to die and kills note proc */
    for(;;){
        n = waitpid();
        if(n < 0 || n == pid)
            break;
    }
    postnote(PNPROC, notepid, "kill");
    _exits(0);
}
@

<<enum [[_anon_ (networking/misc/cpu.c)]]>>=
enum
{
    Qdir,
    Qcpunote,

    Nfid = 32,
};
@

<<global [[fstab]]>>=
struct {
    char	*name;
    Qid	qid;
    ulong	perm;
} fstab[] =
{
    [Qdir]		{ ".",		{Qdir, 0, QTDIR},	DMDIR|0555	},
    [Qcpunote]	{ "cpunote",	{Qcpunote, 0},		0444		},
};
@

<<struct [[Note]]>>=
struct Note
{
    Note *next;
    char msg[ERRMAX];
};
@

<<struct [[Request]]>>=
struct Request
{
    Request *next;
    Fcall f;
};
@

<<struct [[Fid]]>>=
struct Fid
{
    int	fid;
    int	file;
    int	omode;
};
@

<<global [[fids]]>>=
Fid fids[Nfid];
@

<<global [[nfs]]>>=
struct {
    Lock;
    Note *nfirst, *nlast;
    Request *rfirst, *rlast;
} nfs;
@

<<function [[fsreply]]>>=
int
fsreply(int fd, Fcall *f)
{
    uchar buf[IOHDRSZ+Maxfdata];
    int n;

    if(dbg)
        fprint(2, "notefs: <-%F\n", f);
    n = convS2M(f, buf, sizeof buf);
    if(n > 0){
        if(write(fd, buf, n) != n){
            close(fd);
            return -1;
        }
    }
    return 0;
}
@

<<function [[kick]]>>=
/* match a note read request with a note, reply to the request */
int
kick(int fd)
{
    Request *rp;
    Note *np;
    int rv;

    for(;;){
        lock(&nfs);
        rp = nfs.rfirst;
        np = nfs.nfirst;
        if(rp == nil || np == nil){
            unlock(&nfs);
            break;
        }
        nfs.rfirst = rp->next;
        nfs.nfirst = np->next;
        unlock(&nfs);

        rp->f.type = Rread;
        rp->f.count = strlen(np->msg);
        rp->f.data = np->msg;
        rv = fsreply(fd, &rp->f);
        free(rp);
        free(np);
        if(rv < 0)
            return -1;
    }
    return 0;
}
@

<<function [[flushreq]]>>=
void
flushreq(int tag)
{
    Request **l, *rp;

    lock(&nfs);
    for(l = &nfs.rfirst; *l != nil; l = &(*l)->next){
        rp = *l;
        if(rp->f.tag == tag){
            *l = rp->next;
            unlock(&nfs);
            free(rp);
            return;
        }
    }
    unlock(&nfs);
}
@

<<function [[getfid]]>>=
Fid*
getfid(int fid)
{
    int i, freefid;

    freefid = -1;
    for(i = 0; i < Nfid; i++){
        if(freefid < 0 && fids[i].file < 0)
            freefid = i;
        if(fids[i].fid == fid)
            return &fids[i];
    }
    if(freefid >= 0){
        fids[freefid].fid = fid;
        return &fids[freefid];
    }
    return nil;
}
@

<<function [[fsstat]]>>=
int
fsstat(int fd, Fid *fid, Fcall *f)
{
    Dir d;
    uchar statbuf[256];

    memset(&d, 0, sizeof(d));
    d.name = fstab[fid->file].name;
    d.uid = user;
    d.gid = user;
    d.muid = user;
    d.qid = fstab[fid->file].qid;
    d.mode = fstab[fid->file].perm;
    d.atime = d.mtime = time(0);
    f->stat = statbuf;
    f->nstat = convD2M(&d, statbuf, sizeof statbuf);
    return fsreply(fd, f);
}
@

<<function [[fsread]]>>=
int
fsread(int fd, Fid *fid, Fcall *f)
{
    Dir d;
    uchar buf[256];
    Request *rp;

    switch(fid->file){
    default:
        return -1;
    case Qdir:
        if(f->offset == 0 && f->count >0){
            memset(&d, 0, sizeof(d));
            d.name = fstab[Qcpunote].name;
            d.uid = user;
            d.gid = user;
            d.muid = user;
            d.qid = fstab[Qcpunote].qid;
            d.mode = fstab[Qcpunote].perm;
            d.atime = d.mtime = time(0);
            f->count = convD2M(&d, buf, sizeof buf);
            f->data = (char*)buf;
        } else
            f->count = 0;
        return fsreply(fd, f);
    case Qcpunote:
        rp = mallocz(sizeof(*rp), 1);
        if(rp == nil)
            return -1;
        rp->f = *f;
        lock(&nfs);
        if(nfs.rfirst == nil)
            nfs.rfirst = rp;
        else
            nfs.rlast->next = rp;
        nfs.rlast = rp;
        unlock(&nfs);
        return kick(fd);;
    }
}
@

<<global [[Eperm]]>>=
char Eperm[] = "permission denied";
@

<<global [[Enofile]]>>=
char Enofile[] = "out of files";
@

<<global [[Enotdir]]>>=
char Enotdir[] = "not a directory";
@

<<function [[notefs]]>>=
void
notefs(int fd)
{
    uchar buf[IOHDRSZ+Maxfdata];
    int i, n, ncpunote;
    Fcall f;
    Qid wqid[MAXWELEM];
    Fid *fid, *nfid;
    int doreply;

    rfork(RFNOTEG);
    fmtinstall('F', fcallfmt);

    for(n = 0; n < Nfid; n++){
        fids[n].file = -1;
        fids[n].omode = -1;
    }

    ncpunote = 0;
    for(;;){
        n = read9pmsg(fd, buf, sizeof(buf));
        if(n <= 0){
            if(dbg)
                fprint(2, "read9pmsg(%d) returns %d: %r\n", fd, n);
            break;
        }
        if(convM2S(buf, n, &f) <= BIT16SZ)
            break;
        if(dbg)
            fprint(2, "notefs: ->%F\n", &f);
        doreply = 1;
        fid = getfid(f.fid);
        if(fid == nil){
nofids:
            f.type = Rerror;
            f.ename = Enofile;
            fsreply(fd, &f);
            continue;
        }
        switch(f.type++){
        default:
            f.type = Rerror;
            f.ename = "unknown type";
            break;
        case Tflush:
            flushreq(f.oldtag);
            break;
        case Tversion:
            if(f.msize > IOHDRSZ+Maxfdata)
                f.msize = IOHDRSZ+Maxfdata;
            break;
        case Tauth:
            f.type = Rerror;
            f.ename = "authentication not required";
            break;
        case Tattach:
            f.qid = fstab[Qdir].qid;
            fid->file = Qdir;
            break;
        case Twalk:
            nfid = nil;
            if(f.newfid != f.fid){
                nfid = getfid(f.newfid);
                if(nfid == nil)
                    goto nofids;
                nfid->file = fid->file;
                fid = nfid;
            }
            for(i=0; i<f.nwname && i<MAXWELEM; i++){
                if(fid->file != Qdir){
                    f.type = Rerror;
                    f.ename = Enotdir;
                    break;
                }
                if(strcmp(f.wname[i], "..") == 0){
                    wqid[i] = fstab[Qdir].qid;
                    continue;
                }
                if(strcmp(f.wname[i], "cpunote") != 0){
                    if(i == 0){
                        f.type = Rerror;
                        f.ename = "file does not exist";
                    }
                    break;
                }
                fid->file = Qcpunote;
                wqid[i] = fstab[Qcpunote].qid;
            }
            if(nfid != nil && (f.type == Rerror || i < f.nwname))
                nfid ->file = -1;
            if(f.type != Rerror){
                f.nwqid = i;
                for(i=0; i<f.nwqid; i++)
                    f.wqid[i] = wqid[i];
            }
            break;
        case Topen:
            if(f.mode != OREAD){
                f.type = Rerror;
                f.ename = Eperm;
                break;
            }
            fid->omode = f.mode;
            if(fid->file == Qcpunote)
                ncpunote++;
            f.qid = fstab[fid->file].qid;
            f.iounit = 0;
            break;
        case Tread:
            if(fsread(fd, fid, &f) < 0)
                goto err;
            doreply = 0;
            break;
        case Tclunk:
            if(fid->omode != -1 && fid->file == Qcpunote){
                ncpunote--;
                if(ncpunote == 0)	/* remote side is done */
                    goto err;
            }
            fid->file = -1;
            fid->omode = -1;
            break;
        case Tstat:
            if(fsstat(fd, fid, &f) < 0)
                goto err;
            doreply = 0;
            break;
        case Tcreate:
        case Twrite:
        case Tremove:
        case Twstat:
            f.type = Rerror;
            f.ename = Eperm;
            break;
        }
        if(doreply)
            if(fsreply(fd, &f) < 0)
                break;
    }
err:
    if(dbg)
        fprint(2, "notefs exiting: %r\n");
    werrstr("success");
    postnote(PNGROUP, exportpid, "kill");
    if(dbg)
        fprint(2, "postnote PNGROUP %d: %r\n", exportpid);
    close(fd);
}
@

<<global [[notebuf]]>>=
char 	notebuf[ERRMAX];
@

<<function [[catcher]]>>=
void
catcher(void*, char *text)
{
    int n;

    n = strlen(text);
    if(n >= sizeof(notebuf))
        n = sizeof(notebuf)-1;
    memmove(notebuf, text, n);
    notebuf[n] = '\0';
    noted(NCONT);
}
@

<<function [[lclnoteproc]]>>=
/*
 *  mount in /dev a note file for the remote side to read.
 */
void
lclnoteproc(int netfd)
{
    Waitmsg *w;
    Note *np;
    int pfd[2];
    int pid;

    if(pipe(pfd) < 0){
        fprint(2, "cpu: can't start note proc: pipe: %r\n");
        return;
    }

    /* new proc mounts and returns to start exportfs */
    switch(pid = rfork(RFPROC|RFNAMEG|RFFDG|RFMEM)){
    default:
        exportpid = pid;
        break;
    case -1:
        fprint(2, "cpu: can't start note proc: rfork: %r\n");
        return;
    case 0:
        close(pfd[0]);
        if(mount(pfd[1], -1, "/dev", MBEFORE, "") < 0)
            fprint(2, "cpu: can't mount note proc: %r\n");
        close(pfd[1]);
        return;
    }

    close(netfd);
    close(pfd[1]);

    /* new proc listens for note file system rpc's */
    switch(rfork(RFPROC|RFNAMEG|RFMEM)){
    case -1:
        fprint(2, "cpu: can't start note proc: rfork1: %r\n");
        _exits(0);
    case 0:
        notefs(pfd[0]);
        _exits(0);
    }

    /* original proc waits for notes */
    notify(catcher);
    w = nil;
    for(;;) {
        *notebuf = 0;
        free(w);
        w = wait();
        if(w == nil) {
            if(*notebuf == 0)
                break;
            np = mallocz(sizeof(Note), 1);
            if(np != nil){
                strcpy(np->msg, notebuf);
                lock(&nfs);
                if(nfs.nfirst == nil)
                    nfs.nfirst = np;
                else
                    nfs.nlast->next = np;
                nfs.nlast = np;
                unlock(&nfs);
                kick(pfd[0]);
            }
            unlock(&nfs);
        } else if(w->pid == exportpid)
            break;
    }

    if(w == nil)
        exits(nil);
    exits(0);
/*	exits(w->msg); */
}
@


%-------------------------------------------------------------

<<networking/misc/cpu.c>>=
/*
 * cpu.c - Make a connection to a cpu server
 *
 *	   Invoked by listen as 'cpu -R | -N service net netdir'
 *	    	   by users  as 'cpu [-h system] [-c cmd args ...]'
 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include <fcall.h>
#include <libsec.h>

<<constant [[Maxfdata]]>>
<<constant [[MaxStr]]>>

void	remoteside(int);
void	fatal(int, char*, ...);
void	lclnoteproc(int);
void	rmtnoteproc(void);
void	catcher(void*, char*);
void	usage(void);
void	writestr(int, char*, char*, int);
int	readstr(int, char*, int);
char	*rexcall(int*, char*, char*);
int	setamalg(char*);
<<global [[keyspec]]>>

<<global [[notechan]]>>
<<global [[exportpid]]>>
<<global [[system]]>>
<<global [[cflag]]>>
<<global [[dbg]]>>
<<global [[user]]>>
<<global [[patternfile]]>>
<<global [[origargs]]>>

<<global [[srvname]]>>
<<global [[exportfs]]>>
<<global [[ealgs]]>>

<<global [[msgsize]]>>

/* authentication mechanisms */
static int	netkeyauth(int);
static int	netkeysrvauth(int, char*);
static int	p9auth(int);
static int	srvp9auth(int, char*);
static int	noauth(int);
static int	srvnoauth(int, char*);

typedef struct AuthMethod AuthMethod;
<<global [[authmethod]]>>
<<global [[am]]>>

<<global [[p9authproto]]>>

int setam(char*);

<<function [[usage]]([[(networking/misc/cpu.c)]])>>

<<function [[procgetname]]>>

<<function [[procsetname]]([[(networking/misc/cpu.c)]])>>

<<function [[main]]([[(networking/misc/cpu.c)]])>>

<<function [[fatal]]([[(networking/misc/cpu.c)]])>>

<<global [[negstr]]>>

<<global [[bug]]>>

<<function [[old9p]]>>

<<function [[remoteside]]>>

<<function [[rexcall]]>>

<<function [[writestr]]>>

<<function [[readstr]]>>

<<function [[readln]]>>

<<function [[netkeyauth]]>>

<<function [[netkeysrvauth]]>>

<<function [[mksecret]]>>

<<function [[p9auth]]>>

<<function [[noauth]]>>

<<function [[srvnoauth]]>>

<<function [[loghex]]>>

<<function [[srvp9auth]]>>

<<function [[setam]]>>

<<function [[setamalg]]>>

<<global [[rmtnotefile]]>>

<<function [[rmtnoteproc]]>>

<<enum [[_anon_ (networking/misc/cpu.c)]]>>

<<global [[fstab]]>>

typedef struct Note Note;
<<struct [[Note]]>>

typedef struct Request Request;
<<struct [[Request]]>>

typedef struct Fid Fid;
<<struct [[Fid]]>>
<<global [[fids]]>>

<<global [[nfs]]>>

<<function [[fsreply]]>>

<<function [[kick]]>>

<<function [[flushreq]]>>

<<function [[getfid]]>>

<<function [[fsstat]]>>

<<function [[fsread]]>>

<<global [[Eperm]]>>
<<global [[Enofile]]>>
<<global [[Enotdir]]>>

<<function [[notefs]]>>

<<global [[notebuf]]>>

<<function [[catcher]]>>

<<function [[lclnoteproc]]>>
@


\subsection*{[[networking/misc/import.c]]}

<<enum [[_anon_ (networking/misc/import.c)]]>>=
enum {
    Encnone,
    Encssl,
    Enctls,
};
@

<<global [[encprotos]]>>=
static char *encprotos[] = {
    [Encnone] =	"clear",
    [Encssl] =	"ssl",
    [Enctls] = 	"tls",
            nil,
};
@

<<global [[keyspec]]([[(networking/misc/import.c)]])>>=
char		*keyspec = "";
@

<<global [[filterp]]>>=
char		*filterp;
@

<<global [[ealgs]]([[(networking/misc/import.c)]])>>=
char		*ealgs = "rc4_256 sha1";
@

<<global [[encproto]]>>=
int		encproto = Encnone;
@

<<global [[aan]]>>=
char		*aan = "/bin/aan";
@

<<global [[ai]]>>=
AuthInfo 	*ai;
@

<<global [[debug]]([[(networking/misc/import.c)]])>>=
int		debug;
@

<<global [[doauth]]>>=
int		doauth = 1;
@

<<global [[timedout]]>>=
int		timedout;
@

<<function [[procsetname]]([[(networking/misc/import.c)]])>>=
/*
 * based on libthread's threadsetname, but drags in less library code.
 * actually just sets the arguments displayed.
 */
void
procsetname(char *fmt, ...)
{
    int fd;
    char *cmdname;
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if (cmdname == nil)
        return;
    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OWRITE)) >= 0){
        write(fd, cmdname, strlen(cmdname)+1);
        close(fd);
    }
    free(cmdname);
}
@

<<function [[post]]([[(networking/misc/import.c)]])>>=
void
post(char *name, char *envname, int srvfd)
{
    int fd;
    char buf[32];

    fd = create(name, OWRITE, 0600);
    if(fd < 0)
        return;
    sprint(buf, "%d",srvfd);
    if(write(fd, buf, strlen(buf)) != strlen(buf))
        sysfatal("srv write: %r");
    close(fd);
    putenv(envname, name);
}
@

<<function [[lookup]]>>=
static int
lookup(char *s, char *l[])
{
    int i;

    for (i = 0; l[i] != 0; i++)
        if (strcmp(l[i], s) == 0)
            return i;
    return -1;
}
@

<<function [[main]]([[(networking/misc/import.c)]])>>=
void
main(int argc, char **argv)
{
    char *mntpt, *srvpost, srvfile[64];
    int backwards = 0, fd, mntflags, oldserver, notree;

    quotefmtinstall();
    srvpost = nil;
    oldserver = 0;
    notree = 0;
    mntflags = MREPL;
    ARGBEGIN{
    case 'A':
        doauth = 0;
        break;
    case 'a':
        mntflags = MAFTER;
        break;
    case 'b':
        mntflags = MBEFORE;
        break;
    case 'c':
        mntflags |= MCREATE;
        break;
    case 'C':
        mntflags |= MCACHE;
        break;
    case 'd':
        debug++;
        break;
    case 'f':
        /* ignored but allowed for compatibility */
        break;
    case 'O':
    case 'o':
        oldserver = 1;
        break;
    case 'E':
        if ((encproto = lookup(EARGF(usage()), encprotos)) < 0)
            usage();
        break;
    case 'e':
        ealgs = EARGF(usage());
        if(*ealgs == 0 || strcmp(ealgs, "clear") == 0)
            ealgs = nil;
        break;
    case 'k':
        keyspec = EARGF(usage());
        break;
    case 'p':
        filterp = aan;
        break;
    case 's':
        srvpost = EARGF(usage());
        break;
    case 'B':
        backwards = 1;
        break;
    case 'm':
        notree = 1;
        break;
    default:
        usage();
    }ARGEND;

    mntpt = 0;		/* to shut up compiler */
    if(backwards){
        switch(argc) {
        default:
            mntpt = argv[0];
            break;
        case 0:
            usage();
        }
    } else {
        switch(argc) {
        case 2:
            mntpt = argv[1];
            break;
        case 3:
            if(notree)
                usage();
            mntpt = argv[2];
            break;
        default:
            usage();
        }
    }

    if (encproto == Enctls)
        sysfatal("%s: tls has not yet been implemented", argv[0]);

    notify(catcher);
    alarm(60*1000);

    if(backwards)
        fd = passive();
    else if(notree)
        fd = connect(argv[0], nil, oldserver);
    else
        fd = connect(argv[0], argv[1], oldserver);

    if (!oldserver)
        fprint(fd, "impo %s %s\n", filterp? "aan": "nofilter",
            encprotos[encproto]);

    if (encproto != Encnone && ealgs && ai) {
        uchar key[16];
        uchar digest[SHA1dlen];
        char fromclientsecret[21];
        char fromserversecret[21];
        int i;

        memmove(key+4, ai->secret, ai->nsecret);

        /* exchange random numbers */
        srand(truerand());
        for(i = 0; i < 4; i++)
            key[i] = rand();
        if(write(fd, key, 4) != 4)
            sysfatal("can't write key part: %r");
        if(readn(fd, key+12, 4) != 4)
            sysfatal("can't read key part: %r");

        /* scramble into two secrets */
        sha1(key, sizeof(key), digest, nil);
        mksecret(fromclientsecret, digest);
        mksecret(fromserversecret, digest+10);

        if (filterp)
            fd = filter(fd, filterp, argv[0]);

        /* set up encryption */
        procsetname("pushssl");
        fd = pushssl(fd, ealgs, fromclientsecret, fromserversecret, nil);
        if(fd < 0)
            sysfatal("can't establish ssl connection: %r");
    }
    else if (filterp)
        fd = filter(fd, filterp, argv[0]);

    if(srvpost){
        sprint(srvfile, "/srv/%s", srvpost);
        remove(srvfile);
        post(srvfile, srvpost, fd);
    }
    procsetname("mount on %s", mntpt);
    if(mount(fd, -1, mntpt, mntflags, "") < 0)
        sysfatal("can't mount %s: %r", argv[1]);
    alarm(0);

    if(backwards && argc > 1){
        exec(argv[1], &argv[1]);
        sysfatal("exec: %r");
    }
    exits(0);
}
@

<<function [[catcher]]([[(networking/misc/import.c)]])>>=
void
catcher(void*, char *msg)
{
    timedout = 1;
    if(strcmp(msg, "alarm") == 0)
        noted(NCONT);
    noted(NDFLT);
}
@

<<function [[old9p]]([[(networking/misc/import.c)]])>>=
int
old9p(int fd)
{
    int p[2];

    procsetname("old9p");
    if(pipe(p) < 0)
        sysfatal("pipe: %r");

    switch(rfork(RFPROC|RFFDG|RFNAMEG)) {
    case -1:
        sysfatal("rfork srvold9p: %r");
    case 0:
        if(fd != 1){
            dup(fd, 1);
            close(fd);
        }
        if(p[0] != 0){
            dup(p[0], 0);
            close(p[0]);
        }
        close(p[1]);
        if(0){
            fd = open("/sys/log/cpu", OWRITE);
            if(fd != 2){
                dup(fd, 2);
                close(fd);
            }
            execl("/bin/srvold9p", "srvold9p", "-ds", nil);
        } else
            execl("/bin/srvold9p", "srvold9p", "-s", nil);
        sysfatal("exec srvold9p: %r");
    default:
        close(fd);
        close(p[0]);
    }
    return p[1];
}
@

<<function [[connect]]>>=
int
connect(char *system, char *tree, int oldserver)
{
    char buf[ERRMAX], dir[128], *na;
    int fd, n;
    char *authp;

    na = netmkaddr(system, 0, "exportfs");
    procsetname("dial %s", na);
    if((fd = dial(na, 0, dir, 0)) < 0)
        sysfatal("can't dial %s: %r", system);

    if(doauth){
        if(oldserver)
            authp = "p9sk2";
        else
            authp = "p9any";

        procsetname("auth_proxy auth_getkey proto=%q role=client %s",
            authp, keyspec);
        ai = auth_proxy(fd, auth_getkey, "proto=%q role=client %s",
            authp, keyspec);
        if(ai == nil)
            sysfatal("%r: %s", system);
    }

    if(tree != nil){
        procsetname("writing tree name %s", tree);
        n = write(fd, tree, strlen(tree));
        if(n < 0)
            sysfatal("can't write tree: %r");

        strcpy(buf, "can't read tree");

        procsetname("awaiting OK for %s", tree);
        n = read(fd, buf, sizeof buf - 1);
        if(n!=2 || buf[0]!='O' || buf[1]!='K'){
            if (timedout)
                sysfatal("timed out connecting to %s", na);
            buf[sizeof buf - 1] = '\0';
            sysfatal("bad remote tree: %s", buf);
        }
    }

    if(oldserver)
        return old9p(fd);
    return fd;
}
@

<<function [[passive]]>>=
int
passive(void)
{
    int fd;

    /*
     * Ignore doauth==0 on purpose.  Is it useful here?
     */

    procsetname("auth_proxy auth_getkey proto=p9any role=server");
    ai = auth_proxy(0, auth_getkey, "proto=p9any role=server");
    if(ai == nil)
        sysfatal("auth_proxy: %r");
    if(auth_chuid(ai, nil) < 0)
        sysfatal("auth_chuid: %r");
    putenv("service", "import");

    fd = dup(0, -1);
    close(0);
    open("/dev/null", ORDWR);
    close(1);
    open("/dev/null", ORDWR);

    return fd;
}
@

<<function [[usage]]([[(networking/misc/import.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: import [-abcCm] [-A] [-E clear|ssl|tls] "
"[-e 'crypt auth'|clear] [-k keypattern] [-p] host remotefs [mountpoint]\n");
    exits("usage");
}
@

<<function [[filter]]>>=
/* Network on fd1, mount driver on fd0 */
int
filter(int fd, char *cmd, char *host)
{
    int p[2], len, argc;
    char newport[256], buf[256], *s;
    char *argv[16], *file, *pbuf;

    if ((len = read(fd, newport, sizeof newport - 1)) < 0)
        sysfatal("filter: cannot write port; %r");
    newport[len] = '\0';

    if ((s = strchr(newport, '!')) == nil)
        sysfatal("filter: illegally formatted port %s", newport);

    strecpy(buf, buf+sizeof buf, netmkaddr(host, "tcp", "0"));
    pbuf = strrchr(buf, '!');
    strecpy(pbuf, buf+sizeof buf, s);

    if(debug)
        fprint(2, "filter: remote port %s\n", newport);

    argc = tokenize(cmd, argv, nelem(argv)-2);
    if (argc == 0)
        sysfatal("filter: empty command");
    argv[argc++] = "-c";
    argv[argc++] = buf;
    argv[argc] = nil;
    file = argv[0];
    if (s = strrchr(argv[0], '/'))
        argv[0] = s+1;

    if(pipe(p) < 0)
        sysfatal("pipe: %r");

    switch(rfork(RFNOWAIT|RFPROC|RFFDG)) {
    case -1:
        sysfatal("rfork record module: %r");
    case 0:
        dup(p[0], 1);
        dup(p[0], 0);
        close(p[0]);
        close(p[1]);
        exec(file, argv);
        sysfatal("exec record module: %r");
    default:
        close(fd);
        close(p[0]);
    }
    return p[1];
}
@

<<function [[mksecret]]([[(networking/misc/import.c)]])>>=
static void
mksecret(char *t, uchar *f)
{
    sprint(t, "%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux",
        f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9]);
}
@


%-------------------------------------------------------------

<<networking/misc/import.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <libsec.h>

<<enum [[_anon_ (networking/misc/import.c)]]>>

<<global [[encprotos]]>>

<<global [[keyspec]]([[(networking/misc/import.c)]])>>
<<global [[filterp]]>>
<<global [[ealgs]]([[(networking/misc/import.c)]])>>
<<global [[encproto]]>>
<<global [[aan]]>>
<<global [[ai]]>>
<<global [[debug]]([[(networking/misc/import.c)]])>>
<<global [[doauth]]>>
<<global [[timedout]]>>

int	connect(char*, char*, int);
int	passive(void);
int	old9p(int);
void	catcher(void*, char*);
void	sysfatal(char*, ...);
void	usage(void);
int	filter(int, char *, char *);

static void	mksecret(char *, uchar *);

<<function [[procsetname]]([[(networking/misc/import.c)]])>>

<<function [[post]]([[(networking/misc/import.c)]])>>

<<function [[lookup]]>>

<<function [[main]]([[(networking/misc/import.c)]])>>

<<function [[catcher]]([[(networking/misc/import.c)]])>>

<<function [[old9p]]([[(networking/misc/import.c)]])>>

<<function [[connect]]>>

<<function [[passive]]>>

<<function [[usage]]([[(networking/misc/import.c)]])>>

<<function [[filter]]>>

<<function [[mksecret]]([[(networking/misc/import.c)]])>>
@


\subsection*{[[networking/misc/netstat.c]]}

<<global [[out]]>>=
Biobuf	out;
@

<<global [[netroot]]>>=
char	*netroot;
@

<<global [[proto]]([[(networking/misc/netstat.c)]])>>=
char *proto[20];
@

<<global [[nproto]]>>=
int nproto;
@

<<global [[notrans]]>>=
int	notrans;
@

<<function [[usage]]([[(networking/misc/netstat.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-in] [-p proto] [network-dir]\n", argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/misc/netstat.c)]])>>=
void
main(int argc, char *argv[])
{
    int justinterfaces = 0;
    int i, tot, fd;
    Dir *d;
    char buf[128];

    ARGBEGIN{
    case 'i':
        justinterfaces = 1;
        break;
    case 'n':
        notrans = 1;
        break;
    case 'p':
        if(nproto >= nelem(proto))
            sysfatal("too many protos");
        proto[nproto++] = EARGF(usage());
        break;
    default:
        usage();
    }ARGEND;

    netroot = "/net";
    switch(argc){
    case 0:
        break;
    case 1:
        netroot = argv[0];
        break;
    default:
        usage();
    }

    Binit(&out, 1, OWRITE);

    if(justinterfaces){
        pipifc();
        exits(0);
    }

    if(nproto){
        for(i=0; i<nproto; i++)
            nstat(proto[i], pip);
    }else{
        fd = open(netroot, OREAD);
        if(fd < 0)
            sysfatal("open %s: %r", netroot);

        tot = dirreadall(fd, &d);
        for(i=0; i<tot; i++){
            if(strcmp(d[i].name, "ipifc") == 0)
                continue;
            snprint(buf, sizeof buf, "%s/%s/0/local", netroot, d[i].name);
            if(access(buf, 0) >= 0)
                nstat(d[i].name, pip);
        }
    }
    exits(0);
}
@

<<function [[nstat]]>>=
void
nstat(char *net, void (*f)(char*, Dir*))
{
    int fdir, i, tot;
    Dir *dir;
    char buf[128];

    snprint(buf, sizeof buf, "%s/%s", netroot, net);
    fdir = open(buf, OREAD);
    if(fdir < 0)
        return;

    tot = dirreadall(fdir, &dir);
    for(i = 0; i < tot; i++) {
        (*f)(net, &dir[i]);
        Bflush(&out);
    }
    free(dir);
    close(fdir);
}
@

<<function [[getport]]>>=
char*
getport(char *net, char *p)
{
    static char port[10];

    strncpy(port, p, sizeof(port)-1);
    port[sizeof(port)-1] = 0;
    if(notrans || (p = csgetvalue(netroot, "port", p, net, nil)) == nil)
        return port;
    strncpy(port, p, sizeof(port)-1);
    port[sizeof(port)-1] = 0;
    free(p);
    return port;
}
@

<<function [[pip]]>>=
void
pip(char *net, Dir *db)
{
    int n, fd;
    char buf[128], *p;
    char *dname;

    if(strcmp(db->name, "clone") == 0)
        return;
    if(strcmp(db->name, "stats") == 0)
        return;

    snprint(buf, sizeof buf, "%s/%s/%s/status", netroot, net, db->name);
    fd = open(buf, OREAD);
    if(fd < 0)
        return;
    n = read(fd, buf, sizeof(buf));
    close(fd);
    if(n < 0)
        return;
    buf[n] = 0;

    p = strchr(buf, ' ');
    if(p != 0)
        *p = 0;
    p = strrchr(buf, '\n');
    if(p != 0)
        *p = 0;
    Bprint(&out, "%-4s %-4s %-10s %-12s ", net, db->name, db->uid, buf);

    snprint(buf, sizeof buf, "%s/%s/%s/local", netroot, net, db->name);
    fd = open(buf, OREAD);
    if(fd < 0) {
        Bprint(&out, "\n");
        return;
    }
    n = read(fd, buf, sizeof(buf));
    close(fd);
    if(n < 0) {
        Bprint(&out, "\n");
        return;
    }
    buf[n-1] = 0;
    p = strchr(buf, '!');
    if(p == 0) {
        Bprint(&out, "\n");
        return;
    }
    *p = '\0';
    Bprint(&out, "%-10s ", getport(net, p+1));

    snprint(buf, sizeof buf, "%s/%s/%s/remote", netroot, net, db->name);
    fd = open(buf, OREAD);
    if(fd < 0) {
        print("\n");
        return;
    }
    n = read(fd, buf, sizeof(buf));
    close(fd);
    if(n < 0) {
        print("\n");
        return;
    }
    buf[n-1] = 0;
    p = strchr(buf, '!');
    if(p != nil)
        *p++ = '\0';

    if(notrans){
        Bprint(&out, "%-10s %s\n", getport(net, p), buf);
        return;
    }
    dname = csgetvalue(netroot, "ip", buf, "dom", nil);
    if(dname == nil) {
        Bprint(&out, "%-10s %s\n", getport(net, p), buf);
        return;
    }
    Bprint(&out, "%-10s %s\n", getport(net, p), dname);
    Bflush(&out);
    free(dname);
}
@

<<function [[pipifc]]>>=
void
pipifc(void)
{
    Ipifc *ip, *nip;
    Iplifc *lifc;
    char buf[100];
    int l, i;

    fmtinstall('I', eipfmt);
    fmtinstall('M', eipfmt);

    ip = readipifc(netroot, nil, -1);

    l = 7;
    for(nip = ip; nip; nip = nip->next){
        for(lifc = nip->lifc; lifc; lifc = lifc->next){
            i = snprint(buf, sizeof buf, "%I", lifc->ip);
            if(i > l)
                l = i;
            i = snprint(buf, sizeof buf, "%I", lifc->net);
            if(i > l)
                l = i;
        }
    }

    for(nip = ip; nip; nip = nip->next){
        for(lifc = nip->lifc; lifc; lifc = lifc->next)
            Bprint(&out, "%-12s %5d %-*I %5M %-*I %8lud %8lud %8lud %8lud\n",
                nip->dev, nip->mtu, 
                l, lifc->ip, lifc->mask, l, lifc->net,
                nip->pktin, nip->pktout,
                nip->errin, nip->errout);
    }
    Bflush(&out);
}
@


%-------------------------------------------------------------

<<networking/misc/netstat.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ip.h>
#include <ndb.h>

void	pip(char*, Dir*);
void	nstat(char*, void (*)(char*, Dir*));
void	pipifc(void);

<<global [[out]]>>
<<global [[netroot]]>>
<<global [[proto]]([[(networking/misc/netstat.c)]])>>
<<global [[nproto]]>>
<<global [[notrans]]>>

<<function [[usage]]([[(networking/misc/netstat.c)]])>>

<<function [[main]]([[(networking/misc/netstat.c)]])>>

<<function [[nstat]]>>

<<function [[getport]]>>

<<function [[pip]]>>

<<function [[pipifc]]>>
@


\subsection*{[[networking/misc/rx.c]]}

<<global [[eof]]>>=
int	eof;		/* send an eof if true */
@

<<global [[crtonl]]>>=
int	crtonl;		/* convert all received \r to \n */
@

<<global [[returns]]>>=
int	returns;	/* strip \r on reception */
@

<<global [[note]]>>=
char	*note = "die: yankee dog";
@

<<global [[ruser]]>>=
char	*ruser;		/* for BSD authentication */
@

<<global [[key]]>>=
char *key;
@

<<function [[usage]]([[(networking/misc/rx.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-e] [-T] [-r] [-k keypattern] [-l user] net!host command...\n", argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/misc/rx.c)]])>>=
void
main(int argc, char *argv[])
{
    char *host, *addr, *args;
    int fd;

    key = "";
    eof = 1;
    crtonl = 0;
    returns = 1;
    ARGBEGIN{
    case 'T':
        crtonl = 1;
        break;
    case 'r':
        returns = 0;
        break;
    case 'e':
        eof = 0;
        break;
    case 'k':
        key = EARGF(usage());
        break;
    case 'l':
        ruser = EARGF(usage());
        break;
    default:
        usage();
    }ARGEND

    if(argc < 2)
        usage();
    host = argv[0];
    args = buildargs(&argv[1]);

    /* try rexexec p9any then dial again with p9sk2 */
    fd = call(0, host, "rexexec", &addr);
    if(fd >= 0)
        rex(fd, args, "p9any");
    close(fd);
    fd = call(0, host, "rexexec", &addr);
    if(fd >= 0)
        rex(fd, args, "p9sk2");
    close(fd);

    /* if there's an ssh port, try that */
    fd = call("tcp", host, "ssh", &addr);
    if(fd >= 0){
        close(fd);
        sshexec(host, args);
        /* falls through if no ssh */
    }

    /* specific attempts */
    fd = call("tcp", host, "shell", &addr);
    if(fd >= 0)
        tcpexec(fd, addr, args);

    error("can't dial", host);
    exits(0);
}
@

<<function [[call]]([[(networking/misc/rx.c)]])>>=
int
call(char *net, char *host, char *service, char **na)
{
    *na = netmkaddr(host, net, service);
    return dial(*na, 0, 0, 0);
}
@

<<function [[rex]]>>=
void
rex(int fd, char *cmd, char *proto)
{
    char buf[4096];
    int kid, n;
    AuthInfo *ai;

    ai = auth_proxy(fd, auth_getkey, "proto=%s role=client %s", proto, key);
    if(ai == nil){
        if(strcmp(proto, "p9any") == 0)
            return;
        error("auth_proxy", nil);
    }
    write(fd, cmd, strlen(cmd)+1);

    kid = send(fd);
    while((n=read(fd, buf, sizeof buf))>0)
        if(write(1, buf, n)!=n)
            error("write error", 0);
    sleep(250);
    postnote(PNPROC, kid, note);/**/
    exits(0);
}
@

<<function [[tcpexec]]>>=
void
tcpexec(int fd, char *addr, char *cmd)
{
    char *cp, *ep, *u, *ru, buf[4096];
    int kid, n;

    /*
     *  do the ucb authentication and send command
     */
    u = getuser();
    ru = ruser;
    if(ru == nil)
        ru = u;
    if(write(fd, "", 1)<0 || write(fd, u, strlen(u)+1)<0
    || write(fd, ru, strlen(ru)+1)<0 || write(fd, cmd, strlen(cmd)+1)<0){
        close(fd);
        error("can't authenticate to", addr);
    }

    /*
     *  get authentication reply
     */
    if(read(fd, buf, 1) != 1){
        close(fd);
        error("can't authenticate to", addr);
    }
    if(buf[0] != 0){
        while(read(fd, buf, 1) == 1){
            write(2, buf, 1);
            if(buf[0] == '\n')
                break;
        }
        close(fd);
        error("rejected by", addr);
    }

    kid = send(fd);
    while((n=read(fd, buf, sizeof buf))>0){
        if(crtonl) {
            /* convert cr's to nl's */
            for (cp = buf; cp < buf + n; cp++)
                if (*cp == '\r')
                    *cp = '\n';
        }
        else if(!returns){
            /* convert cr's to null's */
            cp = buf;
            ep = buf + n;
            while(cp < ep && (cp = memchr(cp, '\r', ep-cp))){
                memmove(cp, cp+1, ep-cp-1);
                ep--;
                n--;
            }
        }
        if(write(1, buf, n)!=n)
            error("write error", 0);
    }
    sleep(250);
    postnote(PNPROC, kid, note);/**/
    exits(0);
}
@

<<function [[sshexec]]>>=
void
sshexec(char *host, char *cmd)
{
    char *argv[10];
    int n;

    n = 0;
    argv[n++] = "ssh";
    argv[n++] = "-iCm";
    if(!returns)
        argv[n++] = "-r";
    if(ruser){
        argv[n++] = "-l";
        argv[n++] = ruser;
    }
    argv[n++] = host;
    argv[n++] = cmd;
    argv[n] = 0;
    exec("/bin/ssh", argv);
}
@

<<function [[send]]>>=
int
send(int fd)
{
    char buf[4096];
    int n;
    int kid;
    switch(kid = fork()){
    case -1:
        error("fork error", 0);
    case 0:
        break;
    default:
        return kid;
    }
    while((n=read(0, buf, sizeof buf))>0)
        if(write(fd, buf, n)!=n)
            exits("write error");
    if(eof)
        write(fd, buf, 0);

    exits(0);
    return 0;			/* to keep compiler happy */
}
@

<<function [[error]]([[(networking/misc/rx.c)]])>>=
void
error(char *s, char *z)
{
    if(z == 0)
        fprint(2, "%s: %s: %r\n", argv0, s);
    else
        fprint(2, "%s: %s %s: %r\n", argv0, s, z);
    exits(s);
}
@

<<function [[buildargs]]>>=
char *
buildargs(char *argv[])
{
    char *args;
    int m, n;

    args = malloc(1);
    args[0] = '\0';
    n = 0;
    while(*argv){
        m = strlen(*argv) + 1;
        args = realloc(args, n+m +1);
        if(args == 0)
            error("malloc fail", 0);
        args[n] = ' ';	/* smashes old null */
        strcpy(args+n+1, *argv);
        n += m;
        argv++;
    }
    return args;
}
@


%-------------------------------------------------------------

<<networking/misc/rx.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>

<<global [[eof]]>>
<<global [[crtonl]]>>
<<global [[returns]]>>
<<global [[note]]>>
<<global [[ruser]]>>
<<global [[key]]>>

void	rex(int, char*, char*);
void	tcpexec(int, char*, char*);
int	call(char *, char*, char*, char**);
char	*buildargs(char*[]);
int	send(int);
void	error(char*, char*);
void	sshexec(char*, char*);

<<function [[usage]]([[(networking/misc/rx.c)]])>>

<<function [[main]]([[(networking/misc/rx.c)]])>>

<<function [[call]]([[(networking/misc/rx.c)]])>>

<<function [[rex]]>>

<<function [[tcpexec]]>>

<<function [[sshexec]]>>

<<function [[send]]>>

<<function [[error]]([[(networking/misc/rx.c)]])>>

<<function [[buildargs]]>>
@


\section{[[networking/con/]]}

\subsection*{[[networking/con/con.c]]}

<<global [[debug]]([[(networking/con/con.c)]])>>=
int debug;		/* true if debugging */
@

<<global [[ctl]]([[(networking/con/con.c)]])>>=
int ctl = -1;		/* control fd (for break's) */
@

<<global [[raw]]>>=
int raw;		/* true if raw is on */
@

<<global [[consctl]]([[(networking/con/con.c)]])>>=
int consctl = -1;	/* control fd for cons */
@

<<global [[ttypid]]([[(networking/con/con.c)]])>>=
int ttypid;		/* pid's if the 2 processes (used to kill them) */
@

<<global [[outfd]]>>=
int outfd = 1;		/* local output file descriptor */
@

<<global [[cooked]]>>=
int cooked;		/* non-zero forces cooked mode */
@

<<global [[returns]]([[(networking/con/con.c)]])>>=
int returns;		/* non-zero forces carriage returns not to be filtered out */
@

<<global [[crtonl]]([[(networking/con/con.c)]])>>=
int crtonl;			/* non-zero forces carriage returns to be converted to nls coming from net */
@

<<global [[strip]]>>=
int	strip;		/* strip off parity bits */
@

<<global [[firsterr]]>>=
char firsterr[2*ERRMAX];
@

<<global [[transerr]]>>=
char transerr[2*ERRMAX];
@

<<global [[limited]]>>=
int limited;
@

<<global [[remuser]]>>=
char *remuser;		/* for BSD rlogin authentication */
@

<<global [[verbose]]([[(networking/con/con.c)]])>>=
int verbose;
@

<<global [[baud]]>>=
int baud;
@

<<global [[notkbd]]([[(networking/con/con.c)]])>>=
int notkbd;
@

<<global [[nltocr]]>>=
int nltocr;		/* translate kbd nl to cr  and vice versa */
@

<<global [[srv]]([[(networking/con/con.c)]])>>=
static char *srv;
@

<<constant [[MAXMSG]]>>=
#define MAXMSG (2*8192)
@

<<function [[usage]]([[(networking/con/con.c)]])>>=
void
usage(void)
{
    punt("usage: con [-CdnrRsTv] [-b baud] [-l [user]] [-c cmd] [-S svc] "
        "net!host[!service]");
}
@

<<function [[main]]([[(networking/con/con.c)]])>>=
void
main(int argc, char *argv[])
{
    char *dest;
    char *cmd = 0;

    returns = 1;
    ARGBEGIN{
    case 'b':
        baud = atoi(EARGF(usage()));
        break;
    case 'C':
        cooked = 1;
        break;
    case 'c':
        cmd = EARGF(usage());
        break;
    case 'd':
        debug = 1;
        break;
    case 'l':
        limited = 1;
        if(argv[1] != nil && argv[1][0] != '-')
            remuser = EARGF(usage());
        break;
    case 'n':
        notkbd = 1;
        break;
    case 'r':
        returns = 0;
        break;
    case 's':
        strip = 1;
        break;
    case 'S':
        srv = EARGF(usage());
        break;
    case 'R':
        nltocr = 1;
        break;
    case 'T':
        crtonl = 1;
        break;
    case 'v':
        verbose = 1;
        break;
    default:
        usage();
    }ARGEND

    if(argc != 1){
        if(remuser == 0)
            usage();
        dest = remuser;
        remuser = 0;
    } else
        dest = argv[0];
    if(*dest == '/' && strchr(dest, '!') == 0)
        device(dest, cmd);
    else if(limited){
        simple(dest, cmd);	/* doesn't return if dialout succeeds */
        rlogin(dest, cmd);	/* doesn't return if dialout succeeds */
    } else {
        rlogin(dest, cmd);	/* doesn't return if dialout succeeds */
        simple(dest, cmd);	/* doesn't return if dialout succeeds */
    }
    punt(firsterr);
}
@

<<function [[simple]]>>=
/*
 *  just dial and use as a byte stream with remote echo
 */
void
simple(char *dest, char *cmd)
{
    int net;

    net = dodial(dest, 0, 0);
    if(net < 0)
        return;

    if(cmd)
        dosystem(net, cmd);

    if(!cooked)
        rawon();
    stdcon(net);
    exits(0);
}
@

<<function [[rlogin]]>>=
/*
 *  dial, do UCB authentication, use as a byte stream with local echo
 *
 *  return if dial failed
 */
void
rlogin(char *dest, char *cmd)
{
    int net;
    char buf[128];
    char *p;
    char *localuser;

    /* only useful on TCP */
    if(strchr(dest, '!')
    && (strncmp(dest, "tcp!", 4)!=0 && strncmp(dest, "net!", 4)!=0))
        return;

    net = dodial(dest, "tcp", "login");
    if(net < 0)
        return;

    /*
     *  do UCB rlogin authentication
     */
    localuser = getuser();
    if(remuser == 0){
        if(limited)
            remuser = ":";
        else
            remuser = localuser;
    }
    p = getenv("TERM");
    if(p == 0)
        p = "p9";
    if(write(net, "", 1)<0
    || write(net, localuser, strlen(localuser)+1)<0
    || write(net, remuser, strlen(remuser)+1)<0
    || write(net, p, strlen(p)+1)<0){
        close(net);
        punt("BSD authentication failed");
    }
    if(read(net, buf, 1) != 1)
        punt("BSD authentication failed1");
    if(buf[0] != 0){
        fprint(2, "con: remote error: ");
        while(read(net, buf, 1) == 1){
            write(2, buf, 1);
            if(buf[0] == '\n')
                break;
        }
        exits("read");
    }

    if(cmd)
        dosystem(net, cmd);

    if(!cooked)
        rawon();
    nltocr = 1;
    stdcon(net);
    exits(0);
}
@

<<function [[device]]>>=
/*
 *  just open a device and use it as a connection
 */
void
device(char *dest, char *cmd)
{
    int net;
    char cname[128];

    net = open(dest, ORDWR);
    if(net < 0) {
        fprint(2, "con: cannot open %s: %r\n", dest);
        exits("open");
    }
    snprint(cname, sizeof cname, "%sctl", dest);
    ctl = open(cname, ORDWR);
    if (baud > 0) {
        if(ctl >= 0){
            /* set speed and use fifos if available */
            fprint(ctl, "b%d i1", baud);
        }
        else
            fprint(2, "con: cannot open %s: %r\n", cname);
    }

    if(cmd)
        dosystem(net, cmd);

    if(!cooked)
        rawon();
    stdcon(net);
    exits(0);
}
@

<<function [[notifyf]]([[(networking/con/con.c)]])>>=
/*
 *  ignore interrupts
 */
void
notifyf(void *a, char *msg)
{
    USED(a);

    if(strstr(msg, "yankee"))
        noted(NDFLT);
    if(strstr(msg, "closed pipe")
    || strcmp(msg, "interrupt") == 0
    || strcmp(msg, "hangup") == 0)
        noted(NCONT);
    noted(NDFLT);
}
@

<<function [[rawon]]([[(networking/con/con.c)]])>>=
/*
 *  turn keyboard raw mode on
 */
void
rawon(void)
{
    if(debug)
        fprint(2, "rawon\n");
    if(raw)
        return;
    if(consctl < 0)
        consctl = open("/dev/consctl", OWRITE);
    if(consctl < 0){
//		fprint(2, "can't open consctl\n");
        return;
    }
    write(consctl, "rawon", 5);
    raw = 1;
}
@

<<function [[rawoff]]([[(networking/con/con.c)]])>>=
/*
 *  turn keyboard raw mode off
 */
void
rawoff(void)
{
    if(debug)
        fprint(2, "rawoff\n");
    if(raw == 0)
        return;
    if(consctl < 0)
        consctl = open("/dev/consctl", OWRITE);
    if(consctl < 0){
//		fprint(2, "can't open consctl\n");
        return;
    }
    write(consctl, "rawoff", 6);
    raw = 0;
}
@

<<constant [[STDHELP]]([[(networking/con/con.c)]])>>=
/*
 *  control menu
 */
#define STDHELP	"\t(b)reak, (q)uit, (i)nterrupt, toggle printing (r)eturns, (.)continue, (!cmd)\n"
@

<<function [[menu]]([[(networking/con/con.c)]])>>=
int
menu(int net)
{
    char buf[MAXMSG];
    long n;
    int done;
    int wasraw = raw;

    if(wasraw)
        rawoff();

    fprint(2, ">>> ");
    for(done = 0; !done; ){
        n = read(0, buf, sizeof(buf)-1);
        if(n <= 0)
            return -1;
        buf[n] = 0;
        switch(buf[0]){
        case '!':
            print(buf);
            system(net, buf+1);
            print("!\n");
            done = 1;
            break;
        case '.':
            done = 1;
            break;
        case 'q':
            return -1;
        case 'i':
            buf[0] = 0x1c;
            write(net, buf, 1);
            done = 1;
            break;
        case 'b':
            if(ctl >= 0)
                write(ctl, "k", 1);
            done = 1;
            break;
        case 'r':
            returns = 1-returns;
            done = 1;
            break;
        default:
            fprint(2, STDHELP);
            break;
        }
        if(!done)
            fprint(2, ">>> ");
    }

    if(wasraw)
        rawon();
    else
        rawoff();
    return 0;
}
@

<<function [[post]]([[(networking/con/con.c)]])>>=
void
post(char *srv, int fd)
{
    int f;
    char buf[32];

    f = create(srv, OWRITE /* |ORCLOSE */ , 0666);
    if(f < 0)
        sysfatal("create %s: %r", srv);
    snprint(buf, sizeof buf, "%d", fd);
    if(write(f, buf, strlen(buf)) != strlen(buf))
        sysfatal("write %s: %r", srv);
    close(f);
}
@

<<function [[stdcon]]>>=
/*
 *  the real work.  two processes pass bytes back and forth between the
 *  terminal and the network.
 */
void
stdcon(int net)
{
    int netpid;
    int p[2];
    char *svc;

    svc = nil;
    if (srv) {
        if(pipe(p) < 0)
            sysfatal("pipe: %r");
        if (srv[0] != '/')
            svc = smprint("/srv/%s", srv);
        else
            svc = srv;
        post(svc, p[0]);
        close(p[0]);
        dup(p[1], 0);
        dup(p[1], 1);
        /* pipe is now std in & out */
    }
    ttypid = getpid();
    switch(netpid = rfork(RFMEM|RFPROC)){
    case -1:
        perror("con");
        exits("fork");
    case 0:
        notify(notifyf);
        fromnet(net);
        if (svc)
            remove(svc);
        postnote(PNPROC, ttypid, "die yankee dog");
        exits(0);
    default:
        notify(notifyf);
        fromkbd(net);
        if (svc)
            remove(svc);
        if(notkbd)
            for(;;)
                sleep(0);
        postnote(PNPROC, netpid, "die yankee dog");
        exits(0);
    }
}
@

<<function [[fromkbd]]([[(networking/con/con.c)]])>>=
/*
 *  Read the keyboard and write it to the network.  '^\' gets us into
 *  the menu.
 */
void
fromkbd(int net)
{
    long n;
    char buf[MAXMSG];
    char *p, *ep;
    int eofs;

    eofs = 0;
    for(;;){
        n = read(0, buf, sizeof(buf));
        if(n < 0){
            if(wasintr()){
                if(!raw){
                    buf[0] = 0x7f;
                    n = 1;
                } else
                    continue;
            } else
                return;
        }
        if(n == 0){
            if(++eofs > 32)
                return;
        } else
            eofs = 0;
        if(n && memchr(buf, 0x1c, n)){
            if(menu(net) < 0)
                return;
        }else{
            if(!raw && n==0){
                buf[0] = 0x4;
                n = 1;
            }
            if(nltocr){
                ep = buf+n;
                for(p = buf; p < ep; p++)
                    switch(*p){
                    case '\r':
                        *p = '\n';
                        break;
                    case '\n':
                        *p = '\r';
                        break;
                    }
            }
            if(iwrite(net, buf, n) != n)
                return;
        }
    }
}
@

<<function [[fromnet]]([[(networking/con/con.c)]])>>=
/*
 *  Read from the network and write to the screen.
 *  Filter out spurious carriage returns.
 */
void
fromnet(int net)
{
    long n;
    char buf[MAXMSG];
    char *cp, *ep;

    for(;;){
        n = iread(net, buf, sizeof(buf));
        if(n < 0)
            return;
        if(n == 0)
            continue;

        if (strip)
            for (cp=buf; cp<buf+n; cp++)
                *cp &= 0177;

        if(crtonl) {
            /* convert cr's to nl's */
            for (cp = buf; cp < buf + n; cp++)
                if (*cp == '\r')
                    *cp = '\n';
        }
        else if(!returns){
            /* convert cr's to null's */
            cp = buf;
            ep = buf + n;
            while(cp < ep && (cp = memchr(cp, '\r', ep-cp))){
                memmove(cp, cp+1, ep-cp-1);
                ep--;
                n--;
            }
        }

        if(n > 0 && iwrite(outfd, buf, n) != n){
            if(outfd == 1)
                return;
            outfd = 1;
            if(iwrite(1, buf, n) != n)
                return;
        }
    }
}
@

<<function [[dodial]]([[(networking/con/con.c)]])>>=
/*
 *  dial and return a data connection
 */
int
dodial(char *dest, char *net, char *service)
{
    char name[128];
    char devdir[128];
    int data;

    devdir[0] = 0;
    strcpy(name, netmkaddr(dest, net, service));
    data = dial(name, 0, devdir, &ctl);
    if(data < 0){
        seterr(name);
        return -1;
    }
    fprint(2, "connected to %s on %s\n", name, devdir);
    return data;
}
@

<<function [[dosystem]]>>=
void
dosystem(int fd, char *cmd)
{
    char *p;

    p = system(fd, cmd);
    if(p){
        print("con: %s terminated with %s\n", cmd, p);
        exits(p);
    }
}
@

<<function [[system]]([[(networking/con/con.c)]])>>=
/*
 *  run a command with the network connection as standard IO
 */
char *
system(int fd, char *cmd)
{
    int pid;
    int p;
    static Waitmsg msg;
    int pfd[2];
    int n;
    char buf[4096];

    if(pipe(pfd) < 0){
        perror("pipe");
        return "pipe failed";
    }
    outfd = pfd[1];

    close(consctl);
    consctl = -1;
    switch(pid = fork()){
    case -1:
        perror("con");
        return "fork failed";
    case 0:
        close(pfd[1]);
        dup(pfd[0], 0);
        dup(fd, 1);
        close(ctl);
        close(fd);
        close(pfd[0]);
        if(*cmd)
            execl("/bin/rc", "rc", "-c", cmd, nil);
        else
            execl("/bin/rc", "rc", nil);
        perror("con");
        exits("exec");
        break;
    default:
        close(pfd[0]);
        while((n = read(pfd[1], buf, sizeof(buf))) > 0)
            if(write(fd, buf, n) != n)
                break;
        p = waitpid();
        outfd = 1;
        close(pfd[1]);
        if(p < 0 || p != pid)
            return "lost child";
        break;
    }
    return msg.msg;
}
@

<<function [[wasintr]]([[(networking/con/con.c)]])>>=
int
wasintr(void)
{
    return strcmp(syserr(), "interrupted") == 0;
}
@

<<function [[punt]]>>=
void
punt(char *msg)
{
    if(*msg == 0)
        msg = transerr;
    fprint(2, "con: %s\n", msg);
    exits(msg);
}
@

<<function [[syserr]]([[(networking/con/con.c)]])>>=
char*
syserr(void)
{
    static char err[ERRMAX];
    errstr(err, sizeof err);
    return err;
}
@

<<function [[seterr]]>>=
void
seterr(char *addr)
{
    char *se = syserr();

    if(verbose)
        fprint(2, "'%s' calling %s\n", se, addr);
    if(firsterr[0] && (strstr(se, "translate") ||
     strstr(se, "file does not exist") ||
     strstr(se, "unknown address") ||
     strstr(se, "directory entry not found")))
        return;
    strcpy(firsterr, se);
}
@

<<function [[iread]]([[(networking/con/con.c)]])>>=
long
iread(int f, void *a, int n)
{
    long m;

    for(;;){
        m = read(f, a, n);
        if(m >= 0 || !wasintr())
            break;
    }
    return m;
}
@

<<function [[iwrite]]([[(networking/con/con.c)]])>>=
long
iwrite(int f, void *a, int n)
{
    long m;

    m = write(f, a, n);
    if(m < 0 && wasintr())
        return n;
    return m;
}
@


%-------------------------------------------------------------

<<networking/con/con.c>>=
#include <u.h>
#include <libc.h>

<<global [[debug]]([[(networking/con/con.c)]])>>
<<global [[ctl]]([[(networking/con/con.c)]])>>
<<global [[raw]]>>
<<global [[consctl]]([[(networking/con/con.c)]])>>
<<global [[ttypid]]([[(networking/con/con.c)]])>>
<<global [[outfd]]>>
<<global [[cooked]]>>
<<global [[returns]]([[(networking/con/con.c)]])>>
<<global [[crtonl]]([[(networking/con/con.c)]])>>
<<global [[strip]]>>
<<global [[firsterr]]>>
<<global [[transerr]]>>
<<global [[limited]]>>
<<global [[remuser]]>>
<<global [[verbose]]([[(networking/con/con.c)]])>>
<<global [[baud]]>>
<<global [[notkbd]]([[(networking/con/con.c)]])>>
<<global [[nltocr]]>>

<<global [[srv]]([[(networking/con/con.c)]])>>

<<constant [[MAXMSG]]>>

int	dodial(char*, char*, char*);
void	fromkbd(int);
void	fromnet(int);
long	iread(int, void*, int);
long	iwrite(int, void*, int);
int	menu(int);
void	notifyf(void*, char*);
void	pass(int, int, int);
void	rawoff(void);
void	rawon(void);
void	stdcon(int);
char*	system(int, char*);
void	dosystem(int, char*);
int	wasintr(void);
void	punt(char*);
char*	syserr(void);
void	seterr(char*);

/* protocols */
void	device(char*, char*);
void	rlogin(char*, char*);
void	simple(char*, char*);

<<function [[usage]]([[(networking/con/con.c)]])>>

<<function [[main]]([[(networking/con/con.c)]])>>

<<function [[simple]]>>

<<function [[rlogin]]>>

<<function [[device]]>>

<<function [[notifyf]]([[(networking/con/con.c)]])>>

<<function [[rawon]]([[(networking/con/con.c)]])>>

<<function [[rawoff]]([[(networking/con/con.c)]])>>

<<constant [[STDHELP]]([[(networking/con/con.c)]])>>

<<function [[menu]]([[(networking/con/con.c)]])>>

<<function [[post]]([[(networking/con/con.c)]])>>

<<function [[stdcon]]>>

<<function [[fromkbd]]([[(networking/con/con.c)]])>>

<<function [[fromnet]]([[(networking/con/con.c)]])>>

<<function [[dodial]]([[(networking/con/con.c)]])>>

<<function [[dosystem]]>>

<<function [[system]]([[(networking/con/con.c)]])>>

<<function [[wasintr]]([[(networking/con/con.c)]])>>

<<function [[punt]]>>

<<function [[syserr]]([[(networking/con/con.c)]])>>

<<function [[seterr]]>>


<<function [[iread]]([[(networking/con/con.c)]])>>

<<function [[iwrite]]([[(networking/con/con.c)]])>>
@


\subsection*{[[networking/con/hayes.c]]}

<<global [[pulsed]]>>=
int pulsed;
@

<<global [[verbose]]([[(networking/con/hayes.c)]])>>=
int verbose;
@

<<global [[msgbuf]]>>=
char msgbuf[128];		/* last message read */
@

<<enum [[_anon_ (networking/con/hayes.c)]]>>=
enum
{
    Ok,
    Success,
    Failure,
    Noise,
};
@

<<struct [[Msg]]>>=
struct Msg
{
    char	*text;
    int	type;
};
@

<<global [[msgs]]>>=
Msg msgs[] =
{
    { "OK",			Ok, },
    { "NO CARRIER", 	Failure, },
    { "ERROR",		Failure, },
    { "NO DIALTONE",	Failure, },
    { "BUSY",		Failure, },
    { "NO ANSWER",		Failure, },
    { "CONNECT",		Success, },
    { 0,			0 },
};
@

<<function [[usage]]([[(networking/con/hayes.c)]])>>=
void
usage(void)
{
    punt("usage: hayes [-p] telno [device]");
}
@

<<function [[main]]([[(networking/con/hayes.c)]])>>=
void
main(int argc, char **argv)
{
    int data = -1;
    int ctl = -1;
    char *cname;

    ARGBEGIN{
    case 'p':
        pulsed = 1;
        break;
    case 'v':
        verbose = 1;
        break;
    default:
        usage();
    }ARGEND

    switch(argc){
    case 1:
        data = 1;
        break;
    case 2:
        data = open(argv[1], ORDWR);
        if(data < 0){
            fprint(2, "hayes: %r opening %s\n", argv[1]);
            exits("hayes");
        }
        cname = malloc(strlen(argv[1])+4);
        sprint(cname, "%sctl", argv[1]);
        ctl = open(cname, ORDWR);
        free(cname);
        break;
    default:
        usage();
    }
    godial(data, ctl, argv[0]);
    exits(0);
}
@

<<function [[send]]([[(networking/con/hayes.c)]])>>=
int
send(int fd, char *x)
{
    return write(fd, x, strlen(x));
}
@

<<function [[godial]]>>=
void
godial(int data, int ctl, char *number)
{
    char *dialstr;
    int m;
    int baud;

    /* get the modem's attention */
    if(send(data, "\r+++\r") < 0)
        punt("failed write");
    readmsg(data, 2);
    sleep(1000);

    /* initialize */
    if(send(data, "ATZ\r") < 0)
        punt("failed write");
    m = readmsg(data, 2);
    if(m < 0)
        punt("can't get modem's attention");

    /*
     *	Q0 = report result codes
     * 	V1 = full word result codes
     *	W1 = negotiation progress codes enabled
     *	E1 = echo commands
     *	M1 = speaker on until on-line
     */
    if(send(data, "ATQ0V1E1M1\r") < 0)
        punt("failed write");
    m = readmsg(data, 2);
    if(m != Ok)
        punt("can't get modem's attention");
    if(send(data, "ATW1\r") < 0)
        punt("failed write");
    readmsg(data, 2);
    sleep(1000);

    /* godial */
    dialstr = malloc(6+strlen(number));
    sprint(dialstr, "ATD%c%s\r", pulsed ? 'P' : 'T', number);
    if(send(data, dialstr) < 0) {
        free(dialstr);
        punt("failed write");
    }
    free(dialstr);
    m = readmsg(data, 60);
    if(m != Success)
        punt("dial failed: %s", msgbuf);
    baud = getspeed(msgbuf, 9600);
    setspeed(ctl, baud);
    fprint(2, "hayes: connected at %d baud\n", baud);
}
@

<<function [[readmsg]]>>=
/*
 *  read until we see a message or we time out
 */
int
readmsg(int f, int secs)
{
    ulong start;
    char *p;
    int len;
    Dir *d;
    Msg *pp;

    p = msgbuf;
    len = sizeof(msgbuf) - 1;
    for(start = time(0); time(0) <= start+secs;){
        if((d = dirfstat(f)) == nil)
            punt("failed read");
        if(d->length == 0){
            free(d);
            sleep(100);
            continue;
        }
        free(d);
        if(read(f, p, 1) <= 0)
            punt("failed read");
        if(*p == '\n' || *p == '\r' || len == 0){
            *p = 0;
            if(verbose && p != msgbuf)
                fprint(2, "%s\n", msgbuf);
            for(pp = msgs; pp->text; pp++)
                if(strncmp(pp->text, msgbuf, strlen(pp->text))==0)
                    return pp->type;
            start = time(0);
            p = msgbuf;
            len = sizeof(msgbuf) - 1;
            continue;
        }
        len--;
        p++;
    }
    strcpy(msgbuf, "No response from modem");
    return Noise;
}
@

<<function [[getspeed]]>>=
/*
 *  get baud rate from a connect message
 */
int
getspeed(char *msg, int speed)
{
    char *p;
    int s;

    p = msg + sizeof("CONNECT") - 1;
    while(*p == ' ' || *p == '\t')
        p++;
    s = atoi(p);
    if(s <= 0)
        return speed;
    else
        return s;
}
@

<<function [[setspeed]]>>=
/*
 *  set speed and RTS/CTS modem flow control
 */
void
setspeed(int ctl, int baud)
{
    char buf[32];

    if(ctl < 0)
        return;
    sprint(buf, "b%d", baud);
    write(ctl, buf, strlen(buf));
    write(ctl, "m1", 2);
}
@

<<function [[punt]]([[(networking/con/hayes.c)]])>>=
void
punt(char *fmt, ...)
{
    char buf[256];
    va_list arg;
    int n;

    strcpy(buf, "hayes: ");
    va_start(arg, fmt);
    n = vseprint(buf+strlen(buf), buf+sizeof(buf), fmt, arg) - buf;
    va_end(arg);
    buf[n] = '\n';
    write(2, buf, n+1);
    exits("hayes");
}
@


%-------------------------------------------------------------

<<networking/con/hayes.c>>=
#include <u.h>
#include <libc.h>

void setspeed(int, int);
int getspeed(char*, int);
void godial(int, int, char*);
int readmsg(int, int);
void punt(char*, ...);

<<global [[pulsed]]>>
<<global [[verbose]]([[(networking/con/hayes.c)]])>>
<<global [[msgbuf]]>>

<<enum [[_anon_ (networking/con/hayes.c)]]>>

typedef struct Msg	Msg;
<<struct [[Msg]]>>


<<global [[msgs]]>>

<<function [[usage]]([[(networking/con/hayes.c)]])>>

<<function [[main]]([[(networking/con/hayes.c)]])>>

<<function [[send]]([[(networking/con/hayes.c)]])>>

<<function [[godial]]>>

<<function [[readmsg]]>>

<<function [[getspeed]]>>

<<function [[setspeed]]>>


<<function [[punt]]([[(networking/con/hayes.c)]])>>
@


\subsection*{[[networking/con/xmr.c]]}

<<enum [[_anon_ (networking/con/xmr.c)]]>>=
enum {
    Soh=	0x1,
    Eot=	0x4,
    Ack=	0x6,
    Nak=	0x15,
    Cancel=	0x18,
};
@

<<function [[main]]([[(networking/con/xmr.c)]])>>=
void
main(int argc, char **argv)
{
    int fd;
    uchar seqno;
    ulong bytes;

    ARGBEGIN {
    case 'd':
        dfd = 2;
        debug = 1;
        break;
    } ARGEND

    if(argc != 1){
        fprint(2, "usage: xmr filename\n");
        exits("usage");
    }
    fd = open("/dev/consctl", OWRITE);
    if(fd >= 0)
        write(fd, "rawon", 5);
    fd = create(argv[0], ORDWR, 0666);
    if(fd < 0){
        perror("xmr: create");
        exits("create");
    }

    atnotify(notifyf, 1);
    send(Nak);

    /*
     *  keep receiving till the other side gives up
     */
    bytes = 0;
    for(seqno = 1; ; seqno++){
        if(receive(fd, seqno) == -1)
            break;
        bytes += 128;
    }
    fprint(2, "xmr: received %ld bytes\n", bytes);
    exits(0);
}
@

<<function [[send]]([[(networking/con/xmr.c)]])>>=
void
send(int byte)
{
    uchar c;

    c = byte;
    if(write(1, &c, 1) != 1){
        fprint(2, "xmr: hungup\n");
        exits("hangup");
    }
}
@

<<function [[readupto]]>>=
int
readupto(uchar *a, int len)
{
    int n;
    int sofar;

    for(sofar = 0; sofar < len; sofar += n){
        n = read(0, a, len-sofar);
        if(n <= 0){
            send(Nak);
            return sofar;
        }
        if(*a == Eot || *a == Cancel)
            return sofar + n;
        a += n;
    }
    return sofar;

}
@

<<function [[receive]]>>=
int
receive(int fd, uchar seqno)
{
    uchar buf[128+4];
    uchar sum;
    uchar *p;
    int n;
    int tries;
    int have;

    for(have = 0, tries = 0;; tries++){
        if(debug)
            fprint(dfd, "have == %d\n", have);
        if(tries > 10){
            fprint(2, "xmr: timed out\n");
            if(debug)
                close(dfd);
            exits("timeout");
        }

        /* try to gather up a block */
        alarm(15*1000);
        n = readupto(&buf[have], 132-have);
        alarm(0);
        have += n;
        if(have){
            switch(buf[0]){
            case Eot:
                send(Ack);
                return -1;
            case Cancel:
                fprint(2, "xmr: transfer aborted by sender\n");
                exits("cancel");
            }
        }
        if(have != 132)
            continue;

        /* checksum */
        for(p = buf, sum = 0; p < &buf[128+3]; p++)
            sum += *p;

        /* If invalid block, resynchronize */
        if(buf[0] != Soh || buf[2] != (255-buf[1]) || sum != buf[131]){
            if(debug){
                fprint(dfd, "resync %2.2ux %d %d %ux %ux\n", buf[0],
                    buf[1], buf[2], sum, buf[131]);
                write(dfd, (char*)buf+3, 128);
                fprint(dfd, "\n");
            }
            p = memchr(buf+1, Soh, 131);
            if(p){
                have = 132-(p-buf);
                memmove(buf, p, have);
            } else
                have = 0;
            continue;
        }

        /* it's probably a real block, so dump it if there's an error */
        have = 0;

        /* if this is the last block, ack */
        if(buf[1] == seqno-1){
            tries = 0;
            send(Ack);
        }else if(buf[1] == seqno){
            if(debug)
                fprint(dfd, "Ack\n");
            send(Ack);
            if(write(fd, buf+3, 128) != 128){
                fprint(2, "xmr: abort, error writing file\n");
                exits("write");
            }
            return 0;
        } else {
            send(Nak);
        }
    }
}
@

<<function [[notifyf]]([[(networking/con/xmr.c)]])>>=
int
notifyf(void *a, char *msg)
{
    USED(a);
    if(strcmp(msg, "alarm") == 0)
        return 1;
    return 0;
}
@


%-------------------------------------------------------------

<<networking/con/xmr.c>>=
#include <u.h>
#include <libc.h>

<<enum [[_anon_ (networking/con/xmr.c)]]>>

int notifyf(void*, char*);
int readupto(uchar*, int);
int receive(int, uchar);
void send(int);

int debug, dfd;

<<function [[main]]([[(networking/con/xmr.c)]])>>

<<function [[send]]([[(networking/con/xmr.c)]])>>

<<function [[readupto]]>>

<<function [[receive]]>>

<<function [[notifyf]]([[(networking/con/xmr.c)]])>>
@


\subsection*{[[networking/con/xms.c]]}

<<enum [[_anon_ (networking/con/xms.c)]]>>=
enum {
    Soh=	0x1,
    Stx=	0x2,
    Eot=	0x4,
    Ack=	0x6,
    Nak=	0x15,
    Cancel=	0x18,
};
@

<<function [[errorout]]>>=
void
errorout(int ctl, int bytes)
{
    uchar buf[2];

    buf[0] = Cancel;
    write(1, buf, 1);
    fprint(2, "\nxms: gave up after %d bytes\n", bytes);
    write(ctl, "rawoff", 6);
    exits("cancel");
}
@

<<function [[updcrc]]>>=
ushort
updcrc(int c, ushort crc)
{
    int count;

    for (count=8; --count>=0;) {
        if (crc & 0x8000) {
            crc <<= 1;
            crc += (((c<<=1) & 0400)  !=  0);
            crc ^= 0x1021;
        }
        else {
            crc <<= 1;
            crc += (((c<<=1) & 0400)  !=  0);
        }
    }
    return crc;	
}
@

<<function [[main]]([[(networking/con/xms.c)]])>>=
void
main(int argc, char **argv)
{
    uchar c;
    uchar buf[1024+5];
    uchar seqno;
    int fd, ctl;
    long n;
    int sum;
    uchar *p;
    int bytes;
    int crcmode;

    ARGBEGIN{
    case 'd':
        debug = 1;
        break;
    case 'p':
        progress = 1;
        break;
    case '1':
        onek = 1;
        break;
    }ARGEND

    if(argc != 1){
        fprint(2, "usage: xms filename\n");
        exits("usage");
    }
    fd = open(argv[0], OREAD);
    if(fd < 0){
        perror("xms");
        exits("open");
    }

    ctl = open("/dev/consctl", OWRITE);
    if(ctl < 0){
        perror("xms");
        exits("consctl");
    }
    write(ctl, "rawon", 5);

    /* give the other side a 30 seconds to signal ready */
    atnotify(notifyf, 1);
    alarm(30*1000);
    crcmode = 0;
    for(;;){
        if(read(0, &c, 1) != 1){
            fprint(2, "xms: timeout\n");
            exits("timeout");
        }
        c = c & 0x7f;
        if(c == Nak)
            break;
        if(c == 'C') {
            if (debug)
                fprint(2, "crc mode engaged\n");
            crcmode = 1;
            break;
        }
    }
    alarm(0);

    /* send the file in 128/1024 byte chunks */
    for(bytes = 0, seqno = 1; ; bytes += n, seqno++){
        n = read(fd, buf+3, onek ? 1024 : 128);
        if(n < 0)
            exits("read");
        if(n == 0)
            break;
        if(n < (onek ? 1024 : 128))
            memset(&buf[n+3], 0, (onek ? 1024 : 128)-n);
        buf[0] = onek ? Stx : Soh;
        buf[1] = seqno;
        buf[2] = 255 - seqno;

        /* calculate checksum and stuff into last byte */
        if (crcmode) {
            unsigned short crc;
            crc = 0;
            for(p = buf + 3; p < &buf[(onek ? 1024 : 128)+3]; p++)
                crc = updcrc(*p, crc);
            crc = updcrc(0, crc);
            crc = updcrc(0, crc);
            buf[(onek ? 1024 : 128) + 3] = crc >> 8;
            buf[(onek ? 1024 : 128) + 4] = crc;
        }
        else {
            sum = 0;
            for(p = buf + 3; p < &buf[(onek ? 1024 : 128)+3]; p++)
                sum += *p;
            buf[(onek ? 1024 : 128) + 3] = sum;
        }

        if(send(buf, (onek ? 1024 : 128) + 4 + crcmode) < 0)
            errorout(ctl, bytes);
        if (progress && bytes % 10240 == 0)
            fprint(2, "%dK\n", bytes / 1024);
    }

    /* tell other side we're done */
    buf[0] = Eot;
    if(send(buf, 1) < 0)
        errorout(ctl, bytes);

    fprint(2, "xms: %d bytes transmitted\n", bytes);
    write(ctl, "rawoff", 6);
    exits(0);
}
@

<<function [[send]]([[(networking/con/xms.c)]])>>=
/*
 *  send a message till it's acked or we give up
 */
int
send(uchar *buf, int len)
{
    int tries;
    int n;
    uchar c;

    for(tries = 0;; tries++, sleep(2*1000)){
        if(tries == 10)
            return -1;
        if(write(1, buf, len) != len)
            return -1;
        
        alarm(30*1000);
        n = read(0, &c, 1);
        alarm(0);
        if(debug) switch(c){
        case Soh:
            fprint(2, " Soh");
            break;
        case Eot:
            fprint(2, " Eot");
            break;
        case Ack:
            fprint(2, " Ack");
            break;
        case Nak:
            fprint(2, " Nak");
            break;
        case Cancel:
            fprint(2, "\nremote Cancel\n");
            return -1;
        default:
            if(isprint(c))
                fprint(2, "%c", c);
            else
                fprint(2, " \\0%o", c);
        }
        c = c & 0x7f;
        if(n == 1 && c == Ack)
            break;
    }
    return 0;
}
@

<<function [[notifyf]]([[(networking/con/xms.c)]])>>=
int
notifyf(void *a, char *msg)
{
    USED(a);
    if(strcmp(msg, "alarm") == 0)
        return 1;
    return 0;
}
@


%-------------------------------------------------------------

<<networking/con/xms.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<enum [[_anon_ (networking/con/xms.c)]]>>

int send(uchar*, int);
int notifyf(void*, char*);

int debug, progress, onek;

<<function [[errorout]]>>

<<function [[updcrc]]>>

<<function [[main]]([[(networking/con/xms.c)]])>>

<<function [[send]]([[(networking/con/xms.c)]])>>

<<function [[notifyf]]([[(networking/con/xms.c)]])>>
@


\section{[[networking/exportfs/]]}

\subsection*{[[networking/exportfs/exportfs.c]]}

<<constant [[QIDPATH]]>>=
#define QIDPATH	((1LL<<48)-1)
@

<<global [[newqid]]>>=
vlong newqid = 0;
@

<<enum [[_anon_ (networking/exportfs/exportfs.c)]]>>=
enum {
    Encnone,
    Encssl,
    Enctls,
};
@

<<global [[fcalls]]>>=
void (*fcalls[])(Fsrpc*) =
{
    [Tversion]	Xversion,
    [Tauth]	Xauth,
    [Tflush]	Xflush,
    [Tattach]	Xattach,
    [Twalk]		Xwalk,
    [Topen]		slave,
    [Tcreate]	Xcreate,
    [Tclunk]	Xclunk,
    [Tread]		slave,
    [Twrite]	slave,
    [Tremove]	Xremove,
    [Tstat]		Xstat,
    [Twstat]	Xwstat,
};
@

<<global [[filecnt]]>>=
/* accounting and debugging counters */
int	filecnt;
@

<<global [[freecnt]]>>=
int	freecnt;
@

<<global [[qidcnt]]>>=
int	qidcnt;
@

<<global [[qfreecnt]]>>=
int	qfreecnt;
@

<<global [[ncollision]]>>=
int	ncollision;
@

<<global [[netfd]]>>=
int	netfd;				/* initially stdin */
@

<<global [[srvfd]]>>=
int	srvfd = -1;
@

<<global [[nonone]]([[(networking/exportfs/exportfs.c)]])>>=
int	nonone = 1;
@

<<global [[filterp]]([[(networking/exportfs/exportfs.c)]])>>=
char	*filterp;
@

<<global [[ealgs]]([[(networking/exportfs/exportfs.c)]])>>=
char	*ealgs = "rc4_256 sha1";
@

<<global [[aanfilter]]>>=
char	*aanfilter = "/bin/aan";
@

<<global [[encproto]]([[(networking/exportfs/exportfs.c)]])>>=
int	encproto = Encnone;
@

<<global [[readonly]]([[(networking/exportfs/exportfs.c)]])>>=
int	readonly;
@

<<global [[anstring]]>>=
static char *anstring  = "tcp!*!0";
@

<<function [[usage]]([[(networking/exportfs/exportfs.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-adnsR] [-f dbgfile] [-m msize] [-r root] "
        "[-S srvfile] [-e 'crypt hash'] [-P exclusion-file] "
        "[-A announce-string] [-B address]\n", argv0);
    fatal("usage");
}
@

<<function [[noteconn]]>>=
static void
noteconn(int fd)
{
    NetConnInfo *nci;

    nci = getnetconninfo(nil, fd);
    if (nci == nil)
        return;
    netdir = strdup(nci->dir);
    local = strdup(nci->lsys);
    remote = strdup(nci->rsys);
    freenetconninfo(nci);
}
@

<<function [[main]]([[(networking/exportfs/exportfs.c)]])>>=
void
main(int argc, char **argv)
{
    char buf[ERRMAX], ebuf[ERRMAX], *srvfdfile;
    Fsrpc *r;
    int doauth, n, fd;
    char *dbfile, *srv, *na, *nsfile, *keyspec;
    AuthInfo *ai;
    ulong initial;

    dbfile = "/tmp/exportdb";
    srv = nil;
    srvfd = -1;
    srvfdfile = nil;
    na = nil;
    nsfile = nil;
    keyspec = "";
    doauth = 0;

    ai = nil;
    ARGBEGIN{
    case 'a':
        doauth = 1;
        break;

    case 'd':
        dbg++;
        break;

    case 'e':
        ealgs = EARGF(usage());
        if(*ealgs == 0 || strcmp(ealgs, "clear") == 0)
            ealgs = nil;
        break;

    case 'f':
        dbfile = EARGF(usage());
        break;

    case 'k':
        keyspec = EARGF(usage());
        break;

    case 'm':
        messagesize = strtoul(EARGF(usage()), nil, 0);
        break;

    case 'n':
        nonone = 0;
        break;

    case 'r':
        srv = EARGF(usage());
        break;

    case 's':
        srv = "/";
        break;

    case 'A':
        anstring = EARGF(usage());
        break;

    case 'B':
        na = EARGF(usage());
        break;

    case 'F':
        /* accepted but ignored, for backwards compatibility */
        break;

    case 'N':
        nsfile = EARGF(usage());
        break;

    case 'P':
        patternfile = EARGF(usage());
        break;

    case 'R':
        readonly = 1;
        break;

    case 'S':
        if(srvfdfile)
            usage();
        srvfdfile = EARGF(usage());
        break;

    default:
        usage();
    }ARGEND
    USED(argc, argv);

    if(doauth){
        /*
         * We use p9any so we don't have to visit this code again, with the
         * cost that this code is incompatible with the old world, which
         * requires p9sk2. (The two differ in who talks first, so compatibility
         * is awkward.)
         */
        ai = auth_proxy(0, auth_getkey, "proto=p9any role=server %s", keyspec);
        if(ai == nil)
            fatal("auth_proxy: %r");
        if(nonone && strcmp(ai->cuid, "none") == 0)
            fatal("exportfs by none disallowed");
        if(auth_chuid(ai, nsfile) < 0)
            fatal("auth_chuid: %r");
        putenv("service", "exportfs");
    }

    if(srvfdfile){
        if((srvfd = open(srvfdfile, ORDWR)) < 0)
            sysfatal("open '%s': %r", srvfdfile);
    }

    if(na){
        if(srv == nil)
            sysfatal("-B requires -s");

        local = "me";
        remote = na;
        if((fd = dial(netmkaddr(na, 0, "importfs"), 0, 0, 0)) < 0)
            sysfatal("can't dial %s: %r", na);
    
        ai = auth_proxy(fd, auth_getkey, "proto=p9any role=client %s", keyspec);
        if(ai == nil)
            sysfatal("%r: %s", na);

        dup(fd, 0);
        dup(fd, 1);
        close(fd);
    }

    exclusions();

    if(dbg) {
        n = create(dbfile, OWRITE|OTRUNC, 0666);
        dup(n, DFD);
        close(n);
    }

    if(srvfd >= 0 && srv){
        fprint(2, "exportfs: -S cannot be used with -r or -s\n");
        usage();
    }

    DEBUG(DFD, "exportfs: started\n");

    rfork(RFNOTEG);

    if(messagesize == 0){
        messagesize = iounit(netfd);
        if(messagesize == 0)
            messagesize = 8192+IOHDRSZ;
    }

    Workq = emallocz(sizeof(Fsrpc)*Nr_workbufs);
//	for(i=0; i<Nr_workbufs; i++)
//		Workq[i].buf = emallocz(messagesize);
    fhash = emallocz(sizeof(Fid*)*FHASHSIZE);

    fmtinstall('F', fcallfmt);

    /*
     * Get tree to serve from network connection,
     * check we can get there and ack the connection
   */
    if(srvfd != -1) {
        /* do nothing */
    }
    else if(srv) {
        if(chdir(srv) < 0) {
            errstr(ebuf, sizeof ebuf);
            fprint(0, "chdir(\"%s\"): %s\n", srv, ebuf);
            DEBUG(DFD, "chdir(\"%s\"): %s\n", srv, ebuf);
            exits(ebuf);
        }
        DEBUG(DFD, "invoked as server for %s", srv);
        strncpy(buf, srv, sizeof buf);
    }
    else {
        noteconn(netfd);
        buf[0] = 0;
        n = read(0, buf, sizeof(buf)-1);
        if(n < 0) {
            errstr(buf, sizeof buf);
            fprint(0, "read(0): %s\n", buf);
            DEBUG(DFD, "read(0): %s\n", buf);
            exits(buf);
        }
        buf[n] = 0;
        if(chdir(buf) < 0) {
            errstr(ebuf, sizeof ebuf);
            fprint(0, "chdir(%d:\"%s\"): %s\n", n, buf, ebuf);
            DEBUG(DFD, "chdir(%d:\"%s\"): %s\n", n, buf, ebuf);
            exits(ebuf);
        }
    }

    DEBUG(DFD, "\niniting root\n");
    initroot();

    DEBUG(DFD, "exportfs: %s\n", buf);

    if(srv == nil && srvfd == -1 && write(0, "OK", 2) != 2)
        fatal("open ack write");

    if (readn(netfd, &initial, sizeof(ulong)) < sizeof(ulong))
        fatal("can't read initial string: %r\n");

    if (strncmp((char *)&initial, "impo", sizeof(ulong)) == 0) {
        char buf[128], *p, *args[3];

        /* New import.  Read import's parameters... */
        initial = 0;

        p = buf;
        while (p - buf < sizeof buf) {
            if ((n = read(netfd, p, 1)) < 0)
                fatal("can't read impo arguments: %r\n");

            if (n == 0)
                fatal("connection closed while reading arguments\n");

            if (*p == '\n') 
                *p = '\0';
            if (*p++ == '\0')
                break;
        }
        
        if (tokenize(buf, args, nelem(args)) != 2)
            fatal("impo arguments invalid: impo%s...\n", buf);

        if (strcmp(args[0], "aan") == 0)
            filterp = aanfilter;
        else if (strcmp(args[0], "nofilter") != 0)
            fatal("import filter argument unsupported: %s\n", args[0]);

        if (strcmp(args[1], "ssl") == 0)
            encproto = Encssl;
        else if (strcmp(args[1], "tls") == 0)
            encproto = Enctls;
        else if (strcmp(args[1], "clear") != 0)
            fatal("import encryption proto unsupported: %s\n", args[1]);

        if (encproto == Enctls)
            sysfatal("%s: tls has not yet been implemented", argv[0]);
    }

    if (encproto != Encnone && ealgs && ai) {
        uchar key[16];
        uchar digest[SHA1dlen];
        char fromclientsecret[21];
        char fromserversecret[21];
        int i;

        memmove(key+4, ai->secret, ai->nsecret);

        /* exchange random numbers */
        srand(truerand());
        for(i = 0; i < 4; i++)
            key[i+12] = rand();

        if (initial) 
            fatal("Protocol botch: old import\n");
        if(readn(netfd, key, 4) != 4)
            fatal("can't read key part; %r\n");

        if(write(netfd, key+12, 4) != 4)
            fatal("can't write key part; %r\n");

        /* scramble into two secrets */
        sha1(key, sizeof(key), digest, nil);
        mksecret(fromclientsecret, digest);
        mksecret(fromserversecret, digest+10);

        if (filterp)
            netfd = filter(netfd, filterp);

        switch (encproto) {
        case Encssl:
            netfd = pushssl(netfd, ealgs, fromserversecret, 
                        fromclientsecret, nil);
            break;
        case Enctls:
        default:
            fatal("Unsupported encryption protocol\n");
        }

        if(netfd < 0)
            fatal("can't establish ssl connection: %r");
    }
    else if (filterp) {
        if (initial) 
            fatal("Protocol botch: don't know how to deal with this\n");
        netfd = filter(netfd, filterp);
    }

    /*
     * Start serving file requests from the network
     */
    for(;;) {
        r = getsbuf();
        if(r == 0)
            fatal("Out of service buffers");
            
        n = localread9pmsg(netfd, r->buf, messagesize, &initial);
        if(n <= 0)
            fatal(nil);

        if(convM2S(r->buf, n, &r->work) == 0)
            fatal("convM2S format error");

        DEBUG(DFD, "%F\n", &r->work);
        (fcalls[r->work.type])(r);
    }
}
@

<<function [[localread9pmsg]]>>=
/*
 * WARNING: Replace this with the original version as soon as all 
 * _old_ imports have been replaced with negotiating imports.  Also
 * cpu relies on this (which needs to be fixed!) -- pb.
 */
static int
localread9pmsg(int fd, void *abuf, uint n, ulong *initial)
{
    int m, len;
    uchar *buf;

    buf = abuf;

    /* read count */
    assert(BIT32SZ == sizeof(ulong));
    if (*initial) {
        memcpy(buf, initial, BIT32SZ);
        *initial = 0;
    }
    else {
        m = readn(fd, buf, BIT32SZ);
        if(m != BIT32SZ){
            if(m < 0)
                return -1;
            return 0;
        }
    }

    len = GBIT32(buf);
    if(len <= BIT32SZ || len > n){
        werrstr("bad length in 9P2000 message header");
        return -1;
    }
    len -= BIT32SZ;
    m = readn(fd, buf+BIT32SZ, len);
    if(m < len)
        return 0;
    return BIT32SZ+m;
}
@

<<function [[reply]]([[(networking/exportfs/exportfs.c)]])>>=
void
reply(Fcall *r, Fcall *t, char *err)
{
    uchar *data;
    int n;

    t->tag = r->tag;
    t->fid = r->fid;
    if(err) {
        t->type = Rerror;
        t->ename = err;
    }
    else 
        t->type = r->type + 1;

    DEBUG(DFD, "\t%F\n", t);

    data = malloc(messagesize);	/* not mallocz; no need to clear */
    if(data == nil)
        fatal(Enomem);
    n = convS2M(t, data, messagesize);
    if(write(netfd, data, n)!=n)
{syslog(0, "exportfs", "short write: %r");
        fatal("mount write");
}
    free(data);
}
@

<<function [[getfid]]([[(networking/exportfs/exportfs.c)]])>>=
Fid *
getfid(int nr)
{
    Fid *f;

    for(f = fidhash(nr); f; f = f->next)
        if(f->nr == nr)
            return f;

    return 0;
}
@

<<function [[freefid]]>>=
int
freefid(int nr)
{
    Fid *f, **l;
    char buf[128];

    l = &fidhash(nr);
    for(f = *l; f; f = f->next) {
        if(f->nr == nr) {
            if(f->mid) {
                sprint(buf, "/mnt/exportfs/%d", f->mid);
                unmount(0, buf);
                psmap[f->mid] = 0;
            }
            if(f->f) {
                freefile(f->f);
                f->f = nil;
            }
            if(f->dir){
                free(f->dir);
                f->dir = nil;
            }
            *l = f->next;
            f->next = fidfree;
            fidfree = f;
            return 1;
        }
        l = &f->next;
    }

    return 0;	
}
@

<<function [[newfid]]>>=
Fid *
newfid(int nr)
{
    Fid *new, **l;
    int i;

    l = &fidhash(nr);
    for(new = *l; new; new = new->next)
        if(new->nr == nr)
            return 0;

    if(fidfree == 0) {
        fidfree = emallocz(sizeof(Fid) * Fidchunk);

        for(i = 0; i < Fidchunk-1; i++)
            fidfree[i].next = &fidfree[i+1];

        fidfree[Fidchunk-1].next = 0;
    }

    new = fidfree;
    fidfree = new->next;

    memset(new, 0, sizeof(Fid));
    new->next = *l;
    *l = new;
    new->nr = nr;
    new->fid = -1;
    new->mid = 0;

    return new;	
}
@

<<function [[getsbuf]]>>=
Fsrpc *
getsbuf(void)
{
    static int ap;
    int look, rounds;
    Fsrpc *wb;
    int small_instead_of_fast = 1;

    if(small_instead_of_fast)
        ap = 0;	/* so we always start looking at the beginning and reuse buffers */

    for(rounds = 0; rounds < 10; rounds++) {
        for(look = 0; look < Nr_workbufs; look++) {
            if(++ap == Nr_workbufs)
                ap = 0;
            if(Workq[ap].busy == 0)
                break;
        }

        if(look == Nr_workbufs){
            sleep(10 * rounds);
            continue;
        }

        wb = &Workq[ap];
        wb->pid = 0;
        wb->canint = 0;
        wb->flushtag = NOTAG;
        wb->busy = 1;
        if(wb->buf == nil)	/* allocate buffers dynamically to keep size down */
            wb->buf = emallocz(messagesize);
        return wb;
    }
    fatal("No more work buffers");
    return nil;
}
@

<<function [[freefile]]>>=
void
freefile(File *f)
{
    File *parent, *child;

Loop:
    f->ref--;
    if(f->ref > 0)
        return;
    freecnt++;
    if(f->ref < 0) abort();
    DEBUG(DFD, "free %s\n", f->name);
    /* delete from parent */
    parent = f->parent;
    if(parent->child == f)
        parent->child = f->childlist;
    else{
        for(child=parent->child; child->childlist!=f; child=child->childlist)
            if(child->childlist == nil)
                fatal("bad child list");
        child->childlist = f->childlist;
    }
    freeqid(f->qidt);
    free(f->name);
    f->name = nil;
    free(f);
    f = parent;
    if(f != nil)
        goto Loop;
}
@

<<function [[file]]>>=
File *
file(File *parent, char *name)
{
    Dir *dir;
    char *path;
    File *f;

    DEBUG(DFD, "\tfile: 0x%p %s name %s\n", parent, parent->name, name);

    path = makepath(parent, name);
    if(patternfile != nil && excludefile(path)){
        free(path);
        return nil;
    }
    dir = dirstat(path);
    free(path);
    if(dir == nil)
        return nil;

    for(f = parent->child; f; f = f->childlist)
        if(strcmp(name, f->name) == 0)
            break;

    if(f == nil){
        f = emallocz(sizeof(File));
        f->name = estrdup(name);

        f->parent = parent;
        f->childlist = parent->child;
        parent->child = f;
        parent->ref++;
        f->ref = 0;
        filecnt++;
    }
    f->ref++;
    f->qid.type = dir->qid.type;
    f->qid.vers = dir->qid.vers;
    f->qidt = uniqueqid(dir);
    f->qid.path = f->qidt->uniqpath;

    f->inval = 0;

    free(dir);

    return f;
}
@

<<function [[initroot]]>>=
void
initroot(void)
{
    Dir *dir;

    root = emallocz(sizeof(File));
    root->name = estrdup(".");

    dir = dirstat(root->name);
    if(dir == nil)
        fatal("root stat");

    root->ref = 1;
    root->qid.vers = dir->qid.vers;
    root->qidt = uniqueqid(dir);
    root->qid.path = root->qidt->uniqpath;
    root->qid.type = QTDIR;
    free(dir);

    psmpt = emallocz(sizeof(File));
    psmpt->name = estrdup("/");

    dir = dirstat(psmpt->name);
    if(dir == nil)
        return;

    psmpt->ref = 1;
    psmpt->qid.vers = dir->qid.vers;
    psmpt->qidt = uniqueqid(dir);
    psmpt->qid.path = psmpt->qidt->uniqpath;
    free(dir);

    psmpt = file(psmpt, "mnt");
    if(psmpt == 0)
        return;
    psmpt = file(psmpt, "exportfs");
}
@

<<function [[makepath]]>>=
char*
makepath(File *p, char *name)
{
    int i, n;
    char *c, *s, *path, *seg[256];

    seg[0] = name;
    n = strlen(name)+2;
    for(i = 1; i < 256 && p; i++, p = p->parent){
        seg[i] = p->name;
        n += strlen(p->name)+1;
    }
    path = malloc(n);
    if(path == nil)
        fatal("out of memory");
    s = path;

    while(i--) {
        for(c = seg[i]; *c; c++)
            *s++ = *c;
        *s++ = '/';
    }
    while(s[-1] == '/')
        s--;
    *s = '\0';

    return path;
}
@

<<function [[qidhash]]>>=
int
qidhash(vlong path)
{
    int h, n;

    h = 0;
    for(n=0; n<64; n+=Nqidbits){
        h ^= path;
        path >>= Nqidbits;
    }
    return h & (Nqidtab-1);
}
@

<<function [[freeqid]]>>=
void
freeqid(Qidtab *q)
{
    ulong h;
    Qidtab *l;

    q->ref--;
    if(q->ref > 0)
        return;
    qfreecnt++;
    h = qidhash(q->path);
    if(qidtab[h] == q)
        qidtab[h] = q->next;
    else{
        for(l=qidtab[h]; l->next!=q; l=l->next)
            if(l->next == nil)
                fatal("bad qid list");
        l->next = q->next;
    }
    free(q);
}
@

<<function [[qidlookup]]>>=
Qidtab*
qidlookup(Dir *d)
{
    ulong h;
    Qidtab *q;

    h = qidhash(d->qid.path);
    for(q=qidtab[h]; q!=nil; q=q->next)
        if(q->type==d->type && q->dev==d->dev && q->path==d->qid.path)
            return q;
    return nil;
}
@

<<function [[qidexists]]>>=
int
qidexists(vlong path)
{
    int h;
    Qidtab *q;

    for(h=0; h<Nqidtab; h++)
        for(q=qidtab[h]; q!=nil; q=q->next)
            if(q->uniqpath == path)
                return 1;
    return 0;
}
@

<<function [[uniqueqid]]>>=
Qidtab*
uniqueqid(Dir *d)
{
    ulong h;
    vlong path;
    Qidtab *q;

    q = qidlookup(d);
    if(q != nil){
        q->ref++;
        return q;
    }
    path = d->qid.path;
    while(qidexists(path)){
        DEBUG(DFD, "collision on %s\n", d->name);
        /* collision: find a new one */
        ncollision++;
        path &= QIDPATH;
        ++newqid;
        if(newqid >= (1<<16)){
            DEBUG(DFD, "collision wraparound\n");
            newqid = 1;
        }
        path |= newqid<<48;
        DEBUG(DFD, "assign qid %.16llux\n", path);
    }
    q = mallocz(sizeof(Qidtab), 1);
    if(q == nil)
        fatal("no memory for qid table");
    qidcnt++;
    q->ref = 1;
    q->type = d->type;
    q->dev = d->dev;
    q->path = d->qid.path;
    q->uniqpath = path;
    h = qidhash(d->qid.path);
    q->next = qidtab[h];
    qidtab[h] = q;
    return q;
}
@

<<function [[fatal]]([[(networking/exportfs/exportfs.c)]])>>=
void
fatal(char *s, ...)
{
    char buf[ERRMAX];
    va_list arg;
    Proc *m;

    if (s) {
        va_start(arg, s);
        vsnprint(buf, ERRMAX, s, arg);
        va_end(arg);
    }

    /* Clear away the slave children */
    for(m = Proclist; m; m = m->next)
        postnote(PNPROC, m->pid, "kill");

    DEBUG(DFD, "%s\n", buf);
    if (s) 
        sysfatal("%s", buf);	/* caution: buf could contain '%' */
    else
        exits(nil);
}
@

<<function [[emallocz]]>>=
void*
emallocz(uint n)
{
    void *p;

    p = mallocz(n, 1);
    if(p == nil)
        fatal(Enomem);
    return p;
}
@

<<function [[estrdup]]([[(networking/exportfs/exportfs.c)]])>>=
char*
estrdup(char *s)
{
    char *t;

    t = strdup(s);
    if(t == nil)
        fatal(Enomem);
    return t;
}
@

<<function [[filter]]([[(networking/exportfs/exportfs.c)]])>>=
/* Network on fd1, mount driver on fd0 */
int
filter(int fd, char *cmd)
{
    int p[2], lfd, len, nb, argc;
    char newport[128], buf[128], devdir[40], *s, *file, *argv[16];

    /* Get a free port and post it to the client. */
    if (announce(anstring, devdir) < 0)
        sysfatal("filter: Cannot announce %s: %r", anstring);

    snprint(buf, sizeof(buf), "%s/local", devdir);
    buf[sizeof buf - 1] = '\0';
    if ((lfd = open(buf, OREAD)) < 0)
        sysfatal("filter: Cannot open %s: %r", buf);
    if ((len = read(lfd, newport, sizeof newport - 1)) < 0)
        sysfatal("filter: Cannot read %s: %r", buf);
    close(lfd);
    newport[len] = '\0';

    if ((s = strchr(newport, '\n')) != nil)
        *s = '\0';

    if ((nb = write(fd, newport, len)) < 0) 
        sysfatal("getport; cannot write port; %r");
    assert(nb == len);

    argc = tokenize(cmd, argv, nelem(argv)-2);
    if (argc == 0)
        sysfatal("filter: empty command");
    argv[argc++] = buf;
    argv[argc] = nil;
    file = argv[0];
    if (s = strrchr(argv[0], '/'))
        argv[0] = s+1;

    if(pipe(p) < 0)
        fatal("pipe");

    switch(rfork(RFNOWAIT|RFPROC|RFFDG)) {
    case -1:
        fatal("rfork record module");
    case 0:
        if (dup(p[0], 1) < 0)
            fatal("filter: Cannot dup to 1; %r\n");
        if (dup(p[0], 0) < 0)
            fatal("filter: Cannot dup to 0; %r\n");
        close(p[0]);
        close(p[1]);
        exec(file, argv);
        fatal("exec record module");
    default:
        close(fd);
        close(p[0]);
    }
    return p[1];	
}
@

<<function [[mksecret]]([[(networking/exportfs/exportfs.c)]])>>=
static void
mksecret(char *t, uchar *f)
{
    sprint(t, "%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux",
        f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7], f[8], f[9]);
}
@


%-------------------------------------------------------------

<<networking/exportfs/exportfs.c>>=
/*
 * exportfs - Export a plan 9 name space across a network
 */
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <fcall.h>
#include <libsec.h>

#include "exportfs.h"

<<constant [[QIDPATH]]>>
<<global [[newqid]]>>

<<enum [[_anon_ (networking/exportfs/exportfs.c)]]>>

<<global [[fcalls]]>>

<<global [[filecnt]]>>
<<global [[freecnt]]>>
<<global [[qidcnt]]>>
<<global [[qfreecnt]]>>
<<global [[ncollision]]>>

<<global [[netfd]]>>
<<global [[srvfd]]>>
<<global [[nonone]]([[(networking/exportfs/exportfs.c)]])>>
<<global [[filterp]]([[(networking/exportfs/exportfs.c)]])>>
<<global [[ealgs]]([[(networking/exportfs/exportfs.c)]])>>
<<global [[aanfilter]]>>
<<global [[encproto]]([[(networking/exportfs/exportfs.c)]])>>
<<global [[readonly]]([[(networking/exportfs/exportfs.c)]])>>

static void	mksecret(char *, uchar *);
static int localread9pmsg(int, void *, uint, ulong *);
<<global [[anstring]]>>

char *netdir = "", *local = "", *remote = "";

int	filter(int, char *);

<<function [[usage]]([[(networking/exportfs/exportfs.c)]])>>

<<function [[noteconn]]>>

<<function [[main]]([[(networking/exportfs/exportfs.c)]])>>

<<function [[localread9pmsg]]>>
<<function [[reply]]([[(networking/exportfs/exportfs.c)]])>>

<<function [[getfid]]([[(networking/exportfs/exportfs.c)]])>>

<<function [[freefid]]>>

<<function [[newfid]]>>

<<function [[getsbuf]]>>

<<function [[freefile]]>>

<<function [[file]]>>

<<function [[initroot]]>>

<<function [[makepath]]>>

<<function [[qidhash]]>>

<<function [[freeqid]]>>

<<function [[qidlookup]]>>

<<function [[qidexists]]>>

<<function [[uniqueqid]]>>

<<function [[fatal]]([[(networking/exportfs/exportfs.c)]])>>

<<function [[emallocz]]>>

<<function [[estrdup]]([[(networking/exportfs/exportfs.c)]])>>

<<function [[filter]]([[(networking/exportfs/exportfs.c)]])>>

<<function [[mksecret]]([[(networking/exportfs/exportfs.c)]])>>
@


\subsection*{[[networking/exportfs/exportfs.h]]}

<<constant [[DEBUG]]([[(networking/exportfs/exportfs.h)]])>>=
/*
 * exportfs.h - definitions for exporting file server
 */

#define DEBUG		if(dbg)fprint
@

<<constant [[DFD]]>>=
#define DFD		9
@

<<macro [[fidhash]]>>=
#define fidhash(s)	fhash[s%FHASHSIZE]
@

<<struct [[Fsrpc]]>>=
struct Fsrpc
{
    int	busy;		/* Work buffer has pending rpc to service */
    uintptr	pid;		/* Pid of slave process executing the rpc */
    int	canint;		/* Interrupt gate */
    int	flushtag;	/* Tag on which to reply to flush */
    Fcall	work;		/* Plan 9 incoming Fcall */
    uchar	*buf;		/* Data buffer */
};
@

<<struct [[Fid]]([[(networking/exportfs/exportfs.h)]])>>=
struct Fid
{
    int	fid;		/* system fd for i/o */
    File	*f;		/* File attached to this fid */
    int	mode;
    int	nr;		/* fid number */
    int	mid;		/* Mount id */
    Fid	*next;		/* hash link */

    /* for preaddir -- ARRGH! */
    Dir	*dir;		/* buffer for reading directories */
    int	ndir;		/* number of entries in dir */
    int	cdir;		/* number of consumed entries in dir */
    int	gdir;		/* glue index */
    vlong	offset;		/* offset in virtual directory */
};
@

<<struct [[File]]>>=
struct File
{
    char	*name;
    int	ref;
    Qid	qid;
    Qidtab	*qidt;
    int	inval;
    File	*parent;
    File	*child;
    File	*childlist;
};
@

<<struct [[Proc]]>>=
struct Proc
{
    uintptr	pid;
    int	busy;
    Proc	*next;
};
@

<<struct [[Qidtab]]>>=
struct Qidtab
{
    int	ref;
    int	type;
    int	dev;
    vlong	path;
    vlong	uniqpath;
    Qidtab	*next;
};
@

<<enum [[_anon_ (networking/exportfs/exportfs.h)]]>>=
enum
{
    MAXPROC		= 50,
    FHASHSIZE	= 64,
    Nr_workbufs 	= 50,
    Fidchunk	= 1000,
    Npsmpt		= 32,
    Nqidbits		= 5,
    Nqidtab		= (1<<Nqidbits),
};
@

<<global [[Ebadfid]]>>=
char Ebadfid[];
@

<<global [[Enotdir]]([[(networking/exportfs/exportfs.h)]])>>=
char Enotdir[];
@

<<global [[Edupfid]]>>=
char Edupfid[];
@

<<global [[Eopen]]>>=
char Eopen[];
@

<<global [[Exmnt]]>>=
char Exmnt[];
@

<<global [[Enomem]]>>=
char Enomem[];
@

<<global [[Emip]]>>=
char Emip[];
@

<<global [[Enopsmt]]>>=
char Enopsmt[];
@


%-------------------------------------------------------------

<<networking/exportfs/exportfs.h>>=
<<constant [[DEBUG]]([[(networking/exportfs/exportfs.h)]])>>
<<constant [[DFD]]>>
<<macro [[fidhash]]>>

typedef struct Fsrpc Fsrpc;
typedef struct Fid Fid;
typedef struct File File;
typedef struct Proc Proc;
typedef struct Qidtab Qidtab;

<<struct [[Fsrpc]]>>

<<struct [[Fid]]([[(networking/exportfs/exportfs.h)]])>>

<<struct [[File]]>>

<<struct [[Proc]]>>

<<struct [[Qidtab]]>>

<<enum [[_anon_ (networking/exportfs/exportfs.h)]]>>

<<global [[Ebadfid]]>>
<<global [[Enotdir]]([[(networking/exportfs/exportfs.h)]])>>
<<global [[Edupfid]]>>
<<global [[Eopen]]>>
<<global [[Exmnt]]>>
<<global [[Enomem]]>>
<<global [[Emip]]>>
<<global [[Enopsmt]]>>

extern Fsrpc	*Workq;
extern int  	dbg;
extern File	*root;
extern File	*psmpt;
extern Fid	**fhash;
extern Fid	*fidfree;
extern Proc	*Proclist;
extern char	psmap[Npsmpt];
extern Qidtab	*qidtab[Nqidtab];
extern ulong	messagesize;
extern char	Enomem[];
extern int	srvfd;
extern char*	patternfile;

/* File system protocol service procedures */
void Xattach(Fsrpc*);
void Xauth(Fsrpc*);
void Xclunk(Fsrpc*); 
void Xcreate(Fsrpc*);
void Xflush(Fsrpc*); 
void Xnop(Fsrpc*);
void Xremove(Fsrpc*);
void Xstat(Fsrpc*);
void Xversion(Fsrpc*);
void Xwalk(Fsrpc*);
void Xwstat(Fsrpc*);
void slave(Fsrpc*);

void	reply(Fcall*, Fcall*, char*);
Fid 	*getfid(int);
int	freefid(int);
Fid	*newfid(int);
Fsrpc	*getsbuf(void);
void	initroot(void);
void	fatal(char*, ...);
char*	makepath(File*, char*);
File	*file(File*, char*);
void	freefile(File*);
void	slaveopen(Fsrpc*);
void	slaveread(Fsrpc*);
void	slavewrite(Fsrpc*);
void	blockingslave(void);
void	reopen(Fid *f);
void	noteproc(int, char*);
void	flushaction(void*, char*);
void	pushfcall(char*);
Qidtab* uniqueqid(Dir*);
void	freeqid(Qidtab*);
char*	estrdup(char*);
void*	emallocz(uint);
int	readmessage(int, char*, int);
void	exclusions(void);
int	excludefile(char*);
int	preaddir(Fid*, uchar*, int, vlong);
@


\subsection*{[[networking/exportfs/exportsrv.c]]}

<<global [[Ebadfid]]([[(networking/exportfs/exportsrv.c)]])>>=
char Ebadfid[] = "Bad fid";
@

<<global [[Enotdir]]([[(networking/exportfs/exportsrv.c)]])>>=
char Enotdir[] = "Not a directory";
@

<<global [[Edupfid]]([[(networking/exportfs/exportsrv.c)]])>>=
char Edupfid[] = "Fid already in use";
@

<<global [[Eopen]]([[(networking/exportfs/exportsrv.c)]])>>=
char Eopen[] = "Fid already opened";
@

<<global [[Exmnt]]([[(networking/exportfs/exportsrv.c)]])>>=
char Exmnt[] = "Cannot .. past mount point";
@

<<global [[Emip]]([[(networking/exportfs/exportsrv.c)]])>>=
char Emip[] = "Mount in progress";
@

<<global [[Enopsmt]]([[(networking/exportfs/exportsrv.c)]])>>=
char Enopsmt[] = "Out of pseudo mount points";
@

<<global [[Enomem]]([[(networking/exportfs/exportsrv.c)]])>>=
char Enomem[] = "No memory";
@

<<global [[Eversion]]>>=
char Eversion[] = "Bad 9P2000 version";
@

<<global [[Ereadonly]]>>=
char Ereadonly[] = "File system read only";
@

<<global [[messagesize]]>>=
ulong messagesize;
@

<<global [[readonly]]([[(networking/exportfs/exportsrv.c)]])>>=
int readonly;
@

<<function [[Xversion]]>>=
void
Xversion(Fsrpc *t)
{
    Fcall rhdr;

    if(t->work.msize > messagesize)
        t->work.msize = messagesize;
    messagesize = t->work.msize;
    if(strncmp(t->work.version, "9P2000", 6) != 0){
        reply(&t->work, &rhdr, Eversion);
        return;
    }
    rhdr.version = "9P2000";
    rhdr.msize = t->work.msize;
    reply(&t->work, &rhdr, 0);
    t->busy = 0;
}
@

<<function [[Xauth]]>>=
void
Xauth(Fsrpc *t)
{
    Fcall rhdr;

    reply(&t->work, &rhdr, "exportfs: authentication not required");
    t->busy = 0;
}
@

<<function [[Xflush]]>>=
void
Xflush(Fsrpc *t)
{
    Fsrpc *w, *e;
    Fcall rhdr;

    e = &Workq[Nr_workbufs];

    for(w = Workq; w < e; w++) {
        if(w->work.tag == t->work.oldtag) {
            DEBUG(DFD, "\tQ busy %d pid %p can %d\n", w->busy, w->pid, w->canint);
            if(w->busy && w->pid) {
                w->flushtag = t->work.tag;
                DEBUG(DFD, "\tset flushtag %d\n", t->work.tag);
                if(w->canint)
                    postnote(PNPROC, w->pid, "flush");
                t->busy = 0;
                return;
            }
        }
    }

    reply(&t->work, &rhdr, 0);
    DEBUG(DFD, "\tflush reply\n");
    t->busy = 0;
}
@

<<function [[Xattach]]>>=
void
Xattach(Fsrpc *t)
{
    int i, nfd;
    Fcall rhdr;
    Fid *f;
    char buf[128];

    f = newfid(t->work.fid);
    if(f == 0) {
        reply(&t->work, &rhdr, Ebadfid);
        t->busy = 0;
        return;
    }

    if(srvfd >= 0){
        if(psmpt == 0){
        Nomount:
            reply(&t->work, &rhdr, Enopsmt);
            t->busy = 0;
            freefid(t->work.fid);
            return;
        }
        for(i=0; i<Npsmpt; i++)
            if(psmap[i] == 0)
                break;
        if(i >= Npsmpt)
            goto Nomount;
        sprint(buf, "%d", i);
        f->f = file(psmpt, buf);
        if(f->f == nil)
            goto Nomount;
        sprint(buf, "/mnt/exportfs/%d", i);
        nfd = dup(srvfd, -1);
        if(amount(nfd, buf, MREPL|MCREATE, t->work.aname) < 0){
            errstr(buf, sizeof buf);
            reply(&t->work, &rhdr, buf);
            t->busy = 0;
            freefid(t->work.fid);
            close(nfd);
            return;
        }
        psmap[i] = 1;
        f->mid = i;
    }else{
        f->f = root;
        f->f->ref++;
    }

    rhdr.qid = f->f->qid;
    reply(&t->work, &rhdr, 0);
    t->busy = 0;
}
@

<<function [[clonefid]]>>=
Fid*
clonefid(Fid *f, int new)
{
    Fid *n;

    n = newfid(new);
    if(n == 0) {
        n = getfid(new);
        if(n == 0)
            fatal("inconsistent fids");
        if(n->fid >= 0)
            close(n->fid);
        freefid(new);
        n = newfid(new);
        if(n == 0)
            fatal("inconsistent fids2");
    }
    n->f = f->f;
    n->f->ref++;
    return n;
}
@

<<function [[Xwalk]]>>=
void
Xwalk(Fsrpc *t)
{
    char err[ERRMAX], *e;
    Fcall rhdr;
    Fid *f, *nf;
    File *wf;
    int i;

    f = getfid(t->work.fid);
    if(f == 0) {
        reply(&t->work, &rhdr, Ebadfid);
        t->busy = 0;
        return;
    }

    nf = nil;
    if(t->work.newfid != t->work.fid){
        nf = clonefid(f, t->work.newfid);
        f = nf;
    }

    rhdr.nwqid = 0;
    e = nil;
    for(i=0; i<t->work.nwname; i++){
        if(i == MAXWELEM){
            e = "Too many path elements";
            break;
        }

        if(strcmp(t->work.wname[i], "..") == 0) {
            if(f->f->parent == nil) {
                e = Exmnt;
                break;
            }
            wf = f->f->parent;
            wf->ref++;
            goto Accept;
        }
    
        wf = file(f->f, t->work.wname[i]);
        if(wf == 0){
            errstr(err, sizeof err);
            e = err;
            break;
        }
    Accept:
        freefile(f->f);
        rhdr.wqid[rhdr.nwqid++] = wf->qid;
        f->f = wf;
        continue;
    }

    if(nf!=nil && (e!=nil || rhdr.nwqid!=t->work.nwname))
        freefid(t->work.newfid);
    if(rhdr.nwqid > 0)
        e = nil;
    reply(&t->work, &rhdr, e);
    t->busy = 0;
}
@

<<function [[Xclunk]]>>=
void
Xclunk(Fsrpc *t)
{
    Fcall rhdr;
    Fid *f;

    f = getfid(t->work.fid);
    if(f == 0) {
        reply(&t->work, &rhdr, Ebadfid);
        t->busy = 0;
        return;
    }

    if(f->fid >= 0)
        close(f->fid);

    freefid(t->work.fid);
    reply(&t->work, &rhdr, 0);
    t->busy = 0;
}
@

<<function [[Xstat]]>>=
void
Xstat(Fsrpc *t)
{
    char err[ERRMAX], *path;
    Fcall rhdr;
    Fid *f;
    Dir *d;
    int s;
    uchar *statbuf;

    f = getfid(t->work.fid);
    if(f == 0) {
        reply(&t->work, &rhdr, Ebadfid);
        t->busy = 0;
        return;
    }
    if(f->fid >= 0)
        d = dirfstat(f->fid);
    else {
        path = makepath(f->f, "");
        d = dirstat(path);
        free(path);
    }

    if(d == nil) {
        errstr(err, sizeof err);
        reply(&t->work, &rhdr, err);
        t->busy = 0;
        return;
    }

    d->qid.path = f->f->qidt->uniqpath;
    s = sizeD2M(d);
    statbuf = emallocz(s);
    s = convD2M(d, statbuf, s);
    free(d);
    rhdr.nstat = s;
    rhdr.stat = statbuf;
    reply(&t->work, &rhdr, 0);
    free(statbuf);
    t->busy = 0;
}
@

<<function [[getiounit]]>>=
static int
getiounit(int fd)
{
    int n;

    n = iounit(fd);
    if(n > messagesize-IOHDRSZ)
        n = messagesize-IOHDRSZ;
    return n;
}
@

<<function [[Xcreate]]>>=
void
Xcreate(Fsrpc *t)
{
    char err[ERRMAX], *path;
    Fcall rhdr;
    Fid *f;
    File *nf;

    if(readonly) {
        reply(&t->work, &rhdr, Ereadonly);
        t->busy = 0;
        return;
    }
    f = getfid(t->work.fid);
    if(f == 0) {
        reply(&t->work, &rhdr, Ebadfid);
        t->busy = 0;
        return;
    }
    

    path = makepath(f->f, t->work.name);
    f->fid = create(path, t->work.mode, t->work.perm);
    free(path);
    if(f->fid < 0) {
        errstr(err, sizeof err);
        reply(&t->work, &rhdr, err);
        t->busy = 0;
        return;
    }

    nf = file(f->f, t->work.name);
    if(nf == 0) {
        errstr(err, sizeof err);
        reply(&t->work, &rhdr, err);
        t->busy = 0;
        return;
    }

    f->mode = t->work.mode;
    freefile(f->f);
    f->f = nf;
    rhdr.qid = f->f->qid;
    rhdr.iounit = getiounit(f->fid);
    reply(&t->work, &rhdr, 0);
    t->busy = 0;
}
@

<<function [[Xremove]]>>=
void
Xremove(Fsrpc *t)
{
    char err[ERRMAX], *path;
    Fcall rhdr;
    Fid *f;

    if(readonly) {
        reply(&t->work, &rhdr, Ereadonly);
        t->busy = 0;
        return;
    }
    f = getfid(t->work.fid);
    if(f == 0) {
        reply(&t->work, &rhdr, Ebadfid);
        t->busy = 0;
        return;
    }

    path = makepath(f->f, "");
    DEBUG(DFD, "\tremove: %s\n", path);
    if(remove(path) < 0) {
        free(path);
        errstr(err, sizeof err);
        reply(&t->work, &rhdr, err);
        t->busy = 0;
        return;
    }
    free(path);

    f->f->inval = 1;
    if(f->fid >= 0)
        close(f->fid);
    freefid(t->work.fid);

    reply(&t->work, &rhdr, 0);
    t->busy = 0;
}
@

<<function [[Xwstat]]>>=
void
Xwstat(Fsrpc *t)
{
    char err[ERRMAX], *path;
    Fcall rhdr;
    Fid *f;
    int s;
    char *strings;
    Dir d;

    if(readonly) {
        reply(&t->work, &rhdr, Ereadonly);
        t->busy = 0;
        return;
    }
    f = getfid(t->work.fid);
    if(f == 0) {
        reply(&t->work, &rhdr, Ebadfid);
        t->busy = 0;
        return;
    }
    strings = emallocz(t->work.nstat);	/* ample */
    if(convM2D(t->work.stat, t->work.nstat, &d, strings) <= BIT16SZ){
        rerrstr(err, sizeof err);
        reply(&t->work, &rhdr, err);
        t->busy = 0;
        free(strings);
        return;
    }

    if(f->fid >= 0)
        s = dirfwstat(f->fid, &d);
    else {
        path = makepath(f->f, "");
        s = dirwstat(path, &d);
        free(path);
    }
    if(s < 0) {
        rerrstr(err, sizeof err);
        reply(&t->work, &rhdr, err);
    }
    else {
        /* wstat may really be rename */
        if(strcmp(d.name, f->f->name)!=0 && strcmp(d.name, "")!=0){
            free(f->f->name);
            f->f->name = estrdup(d.name);
        }
        reply(&t->work, &rhdr, 0);
    }
    free(strings);
    t->busy = 0;
}
@

<<function [[procsetname]]([[(networking/exportfs/exportsrv.c)]])>>=
/*
 * based on libthread's threadsetname, but drags in less library code.
 * actually just sets the arguments displayed.
 */
void
procsetname(char *fmt, ...)
{
    int fd;
    char *cmdname;
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if (cmdname == nil)
        return;
    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OWRITE)) >= 0){
        write(fd, cmdname, strlen(cmdname)+1);
        close(fd);
    }
    free(cmdname);
}
@

<<function [[slave]]>>=
void
slave(Fsrpc *f)
{
    Proc *p;
    uintptr pid;
    Fcall rhdr;
    static int nproc;

    if(readonly){
        switch(f->work.type){
        case Twrite:
            reply(&f->work, &rhdr, Ereadonly);
            f->busy = 0;
            return;
        case Topen:
           if((f->work.mode&3) == OWRITE || (f->work.mode&OTRUNC)){
                reply(&f->work, &rhdr, Ereadonly);
                f->busy = 0;
                return;
            }
        }
    }
    for(;;) {
        for(p = Proclist; p; p = p->next) {
            if(p->busy == 0) {
                f->pid = p->pid;
                p->busy = 1;
                pid = (uintptr)rendezvous((void*)p->pid, f);
                if(pid != p->pid)
                    fatal("rendezvous sync fail");
                return;
            }	
        }

        if(++nproc > MAXPROC)
            fatal("too many procs");

        pid = rfork(RFPROC|RFMEM);
        switch(pid) {
        case -1:
            fatal("rfork");

        case 0:
            if (local[0] != '\0')
                if (netdir[0] != '\0')
                    procsetname("%s: %s -> %s", netdir, 
                        local, remote);
                else
                    procsetname("%s -> %s", local, remote);
            blockingslave();
            fatal("slave");

        default:
            p = malloc(sizeof(Proc));
            if(p == 0)
                fatal("out of memory");

            p->busy = 0;
            p->pid = pid;
            p->next = Proclist;
            Proclist = p;

            rendezvous((void*)pid, p);
        }
    }
}
@

<<function [[blockingslave]]>>=
void
blockingslave(void)
{
    Fsrpc *p;
    Fcall rhdr;
    Proc *m;
    uintptr pid;

    notify(flushaction);

    pid = getpid();

    m = rendezvous((void*)pid, 0);
    
    for(;;) {
        p = rendezvous((void*)pid, (void*)pid);
        if(p == (void*)~0)			/* Interrupted */
            continue;

        DEBUG(DFD, "\tslave: %p %F b %d p %p\n", pid, &p->work, p->busy, p->pid);
        if(p->flushtag != NOTAG)
            goto flushme;

        switch(p->work.type) {
        case Tread:
            slaveread(p);
            break;

        case Twrite:
            slavewrite(p);
            break;

        case Topen:
            slaveopen(p);
            break;

        default:
            reply(&p->work, &rhdr, "exportfs: slave type error");
        }
        if(p->flushtag != NOTAG) {
flushme:
            p->work.type = Tflush;
            p->work.tag = p->flushtag;
            reply(&p->work, &rhdr, 0);
        }
        p->busy = 0;
        m->busy = 0;
    }
}
@

<<function [[openmount]]>>=
int
openmount(int sfd)
{
    int p[2];
    char *arg[10], fdbuf[20], mbuf[20];

    if(pipe(p) < 0)
        return -1;

    switch(rfork(RFPROC|RFMEM|RFNOWAIT|RFNAMEG|RFFDG)){
    case -1:
        return -1;

    default:
        close(sfd);
        close(p[0]);
        return p[1];

    case 0:
        break;
    }

    close(p[1]);

    arg[0] = "exportfs";
    snprint(fdbuf, sizeof fdbuf, "-S/fd/%d", sfd);
    arg[1] = fdbuf;
    snprint(mbuf, sizeof mbuf, "-m%lud", messagesize-IOHDRSZ);
    arg[2] = mbuf;
    arg[3] = nil;

    close(0);
    close(1);
    dup(p[0], 0);
    dup(p[0], 1);
    exec("/bin/exportfs", arg);
    _exits("whoops: exec failed");	
    return -1;
}
@

<<function [[slaveopen]]>>=
void
slaveopen(Fsrpc *p)
{
    char err[ERRMAX], *path;
    Fcall *work, rhdr;
    Fid *f;
    Dir *d;

    work = &p->work;

    f = getfid(work->fid);
    if(f == 0) {
        reply(work, &rhdr, Ebadfid);
        return;
    }
    if(f->fid >= 0) {
        close(f->fid);
        f->fid = -1;
    }
    
    path = makepath(f->f, "");
    DEBUG(DFD, "\topen: %s %d\n", path, work->mode);

    p->canint = 1;
    if(p->flushtag != NOTAG){
        free(path);
        return;
    }
    /* There is a race here I ignore because there are no locks */
    f->fid = open(path, work->mode);
    free(path);
    p->canint = 0;
    if(f->fid < 0 || (d = dirfstat(f->fid)) == nil) {
    Error:
        errstr(err, sizeof err);
        reply(work, &rhdr, err);
        return;
    }
    f->f->qid = d->qid;
    free(d);
    if(f->f->qid.type & QTMOUNT){	/* fork new exportfs for this */
        f->fid = openmount(f->fid);
        if(f->fid < 0)
            goto Error;
    }

    DEBUG(DFD, "\topen: fd %d\n", f->fid);
    f->mode = work->mode;
    f->offset = 0;
    rhdr.iounit = getiounit(f->fid);
    rhdr.qid = f->f->qid;
    reply(work, &rhdr, 0);
}
@

<<function [[slaveread]]>>=
void
slaveread(Fsrpc *p)
{
    Fid *f;
    int n, r;
    Fcall *work, rhdr;
    char *data, err[ERRMAX];

    work = &p->work;

    f = getfid(work->fid);
    if(f == 0) {
        reply(work, &rhdr, Ebadfid);
        return;
    }

    n = (work->count > messagesize-IOHDRSZ) ? messagesize-IOHDRSZ : work->count;
    p->canint = 1;
    if(p->flushtag != NOTAG)
        return;
    data = malloc(n);
    if(data == nil)
        fatal(Enomem);

    /* can't just call pread, since directories must update the offset */
    if(patternfile != nil && (f->f->qid.type&QTDIR))
        r = preaddir(f, (uchar*)data, n, work->offset);
    else
        r = pread(f->fid, data, n, work->offset);
    p->canint = 0;
    if(r < 0) {
        free(data);
        errstr(err, sizeof err);
        reply(work, &rhdr, err);
        return;
    }

    DEBUG(DFD, "\tread: fd=%d %d bytes\n", f->fid, r);

    rhdr.data = data;
    rhdr.count = r;
    reply(work, &rhdr, 0);
    free(data);
}
@

<<function [[slavewrite]]>>=
void
slavewrite(Fsrpc *p)
{
    char err[ERRMAX];
    Fcall *work, rhdr;
    Fid *f;
    int n;

    work = &p->work;

    f = getfid(work->fid);
    if(f == 0) {
        reply(work, &rhdr, Ebadfid);
        return;
    }

    n = (work->count > messagesize-IOHDRSZ) ? messagesize-IOHDRSZ : work->count;
    p->canint = 1;
    if(p->flushtag != NOTAG)
        return;
    n = pwrite(f->fid, work->data, n, work->offset);
    p->canint = 0;
    if(n < 0) {
        errstr(err, sizeof err);
        reply(work, &rhdr, err);
        return;
    }

    DEBUG(DFD, "\twrite: %d bytes fd=%d\n", n, f->fid);

    rhdr.count = n;
    reply(work, &rhdr, 0);
}
@

<<function [[reopen]]>>=
void
reopen(Fid *f)
{
    USED(f);
    fatal("reopen");
}
@

<<function [[flushaction]]>>=
void
flushaction(void *a, char *cause)
{
    USED(a);
    if(strncmp(cause, "sys:", 4) == 0 && !strstr(cause, "pipe")) {
        fprint(2, "exportsrv: note: %s\n", cause);
        exits("noted");
    }
    if(strncmp(cause, "kill", 4) == 0)
        noted(NDFLT);

    noted(NCONT);
}
@


%-------------------------------------------------------------

<<networking/exportfs/exportsrv.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <fcall.h>

#include "exportfs.h"

extern char *netdir, *local, *remote;

<<global [[Ebadfid]]([[(networking/exportfs/exportsrv.c)]])>>
<<global [[Enotdir]]([[(networking/exportfs/exportsrv.c)]])>>
<<global [[Edupfid]]([[(networking/exportfs/exportsrv.c)]])>>
<<global [[Eopen]]([[(networking/exportfs/exportsrv.c)]])>>
<<global [[Exmnt]]([[(networking/exportfs/exportsrv.c)]])>>
<<global [[Emip]]([[(networking/exportfs/exportsrv.c)]])>>
<<global [[Enopsmt]]([[(networking/exportfs/exportsrv.c)]])>>
<<global [[Enomem]]([[(networking/exportfs/exportsrv.c)]])>>
<<global [[Eversion]]>>
<<global [[Ereadonly]]>>

<<global [[messagesize]]>>
<<global [[readonly]]([[(networking/exportfs/exportsrv.c)]])>>

<<function [[Xversion]]>>

<<function [[Xauth]]>>

<<function [[Xflush]]>>

<<function [[Xattach]]>>

<<function [[clonefid]]>>

<<function [[Xwalk]]>>

<<function [[Xclunk]]>>

<<function [[Xstat]]>>

<<function [[getiounit]]>>

<<function [[Xcreate]]>>

<<function [[Xremove]]>>

<<function [[Xwstat]]>>

<<function [[procsetname]]([[(networking/exportfs/exportsrv.c)]])>>

<<function [[slave]]>>

<<function [[blockingslave]]>>

<<function [[openmount]]>>

<<function [[slaveopen]]>>

<<function [[slaveread]]>>

<<function [[slavewrite]]>>

<<function [[reopen]]>>

<<function [[flushaction]]>>
@


\subsection*{[[networking/exportfs/globals.c]]}

<<global [[Workq]]>>=
Fsrpc	*Workq;
@

<<global [[dbg]]([[(networking/exportfs/globals.c)]])>>=
int  	dbg;
@

<<global [[root]]>>=
File	*root;
@

<<global [[psmpt]]>>=
File	*psmpt;
@

<<global [[fhash]]>>=
Fid	**fhash;
@

<<global [[fidfree]]>>=
Fid	*fidfree;
@

<<global [[Proclist]]>>=
Proc	*Proclist;
@

<<global [[psmap]]>>=
char	psmap[Npsmpt];
@

<<global [[qidtab]]>>=
Qidtab	*qidtab[Nqidtab];
@

<<global [[messagesize]]([[(networking/exportfs/globals.c)]])>>=
ulong	messagesize;
@

<<global [[Enomem]]([[(networking/exportfs/globals.c)]])>>=
char	Enomem[];
@

<<global [[srvfd]]([[(networking/exportfs/globals.c)]])>>=
int	srvfd;
@

<<global [[patternfile]]([[(networking/exportfs/globals.c)]])>>=
char*	patternfile;
@


%-------------------------------------------------------------

<<networking/exportfs/globals.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <fcall.h>
#include <libsec.h>

#include "exportfs.h"

<<global [[Workq]]>>
<<global [[dbg]]([[(networking/exportfs/globals.c)]])>>
<<global [[root]]>>
<<global [[psmpt]]>>
<<global [[fhash]]>>
<<global [[fidfree]]>>
<<global [[Proclist]]>>
<<global [[psmap]]>>
<<global [[qidtab]]>>
<<global [[messagesize]]([[(networking/exportfs/globals.c)]])>>
<<global [[Enomem]]([[(networking/exportfs/globals.c)]])>>
<<global [[srvfd]]([[(networking/exportfs/globals.c)]])>>
<<global [[patternfile]]([[(networking/exportfs/globals.c)]])>>
@


\subsection*{[[networking/exportfs/pattern.c]]}

<<global [[patternfile]]([[(networking/exportfs/pattern.c)]])>>=
char	*patternfile;
@

<<function [[exclusions]]>>=
void
exclusions(void)
{
    Biobuf *f;
    int ni, nmaxi, ne, nmaxe;
    char *line;

    if(patternfile == nil)
        return;

    f = Bopen(patternfile, OREAD);
    if(f == nil)
        fatal("cannot open patternfile");
    ni = 0;
    nmaxi = 100;
    include = malloc(nmaxi*sizeof(*include));
    if(include == nil)
        fatal("out of memory");
    include[0] = nil;
    ne = 0;
    nmaxe = 100;
    exclude = malloc(nmaxe*sizeof(*exclude));
    if(exclude == nil)
        fatal("out of memory");
    exclude[0] = nil;
    while(line = Brdline(f, '\n')){
        line[Blinelen(f) - 1] = 0;
        if(strlen(line) < 2 || line[1] != ' ')
            continue;
        switch(line[0]){
        case '+':
            if(ni+1 >= nmaxi){
                nmaxi = 2*nmaxi;
                include = realloc(include, nmaxi*sizeof(*include));
                if(include == nil)
                    fatal("out of memory");
            }
            DEBUG(DFD, "\tinclude %s\n", line+2);
            include[ni] = regcomp(line+2);
            include[++ni] = nil;
            break;
        case '-':
            if(ne+1 >= nmaxe){
                nmaxe = 2*nmaxe;
                exclude = realloc(exclude, nmaxe*sizeof(*exclude));
                if(exclude == nil)
                    fatal("out of memory");
            }
            DEBUG(DFD, "\texclude %s\n", line+2);
            exclude[ne] = regcomp(line+2);
            exclude[++ne] = nil;
            break;
        default:
            DEBUG(DFD, "ignoring pattern %s\n", line);
            break;
        }
    }
    Bterm(f);
}
@

<<function [[excludefile]]>>=
int
excludefile(char *path)
{
    Reprog **re;
    char *p;

    if(*(path+1) == 0)
        p = "/";
    else
        p = path+1;

    DEBUG(DFD, "checking %s\n", path);
    for(re = include; *re != nil; re++){
        if(regexec(*re, p, nil, 0) != 1){
            DEBUG(DFD, "excluded+ %s\n", path);
            return -1;
        }
    }
    for(re = exclude; *re != nil; re++){
        if(regexec(*re, p, nil, 0) == 1){
            DEBUG(DFD, "excluded- %s\n", path);
            return -1;
        }
    }
    return 0;
}
@

<<function [[preaddir]]>>=
int
preaddir(Fid *f, uchar *data, int n, vlong offset)
{
    int r = 0, m;
    Dir *d;

    DEBUG(DFD, "\tpreaddir n=%d wo=%lld fo=%lld\n", n, offset, f->offset);
    if(offset == 0 && f->offset != 0){
        if(seek(f->fid, 0, 0) != 0)
            return -1;
        f->offset = f->cdir = f->ndir = 0;
        free(f->dir);
        f->dir = nil;
    }else if(offset != f->offset){
        werrstr("can't seek dir %lld to %lld", f->offset, offset);
        return -1;
    }

    while(n > 0){
        if(f->dir == nil){
            f->ndir = dirread(f->fid, &f->dir);
            if(f->ndir < 0)
                return f->ndir;
            if(f->ndir == 0)
                return r;
        }
        d = &f->dir[f->cdir++];
        if(exclude){
            char *p = makepath(f->f, d->name);
            if(excludefile(p)){
                free(p);
                goto skipentry;
            }
            free(p);
        }
        m = convD2M(d, data, n);
        DEBUG(DFD, "\t\tconvD2M %d\n", m);
        if(m <= BIT16SZ){
            DEBUG(DFD, "\t\t\tneeded %d\n", GBIT16(data));
            /* not enough room for full entry; leave for next time */
            f->cdir--;
            return r;
        }else{
            data += m;
            n -= m;
            r += m;
            f->offset += m;
        }
skipentry:	if(f->cdir >= f->ndir){
            f->cdir = f->ndir = 0;
            free(f->dir);
            f->dir = nil;
        }
    }
    return r;
}
@


%-------------------------------------------------------------

<<networking/exportfs/pattern.c>>=
#include <u.h>
#include <libc.h>
#include <fcall.h>
#include <bio.h>
#include <regexp.h>

#include "exportfs.h"

Reprog	**exclude, **include;
<<global [[patternfile]]([[(networking/exportfs/pattern.c)]])>>

<<function [[exclusions]]>>

<<function [[excludefile]]>>

<<function [[preaddir]]>>
@





\section{[[networking/ip/snoopy/]]}

\subsection*{[[networking/ip/snoopy/dat.h]]}

<<macro [[NetS]]([[(networking/ip/snoopy/dat.h)]])>>=
#define NetS(x) ((((uchar*)x)[0]<<8) | ((uchar*)x)[1])
@

<<macro [[Net3]]>>=
#define Net3(x) ((((uchar*)x)[0]<<16) | (((uchar*)x)[1]<<8) | ((uchar*)x)[2])
@

<<macro [[NetL]]([[(networking/ip/snoopy/dat.h)]])>>=
#define NetL(x) ((((uchar*)x)[0]<<24) | (((uchar*)x)[1]<<16) | (((uchar*)x)[2]<<8) | ((uchar*)x)[3])
@

<<struct [[Proto]]([[(networking/ip/snoopy/dat.h)]])>>=
/*
 *  one per protocol module
 */
struct Proto
{
    char*	name;
    void	(*compile)(Filter*);
    int	(*filter)(Filter*, Msg*);
    int	(*seprint)(Msg*);
    Mux*	mux;
    char*	valfmt;
    Field*	field;
    int	(*framer)(int, uchar*, int);
};
@

<<struct [[Mux]]>>=
/*
 *  one per protocol module, pointed to by Proto.mux
 */
struct Mux
{
    char*	name;
    ulong	val;
    Proto*	pr;
};
@

<<struct [[Field]]>>=
/*
 *  a field defining a comparison filter
 */
struct Field
{
    char*	name;
    int	ftype;
    int	subop;
    char*	help;
};
@

<<struct [[Msg]]([[(networking/ip/snoopy/dat.h)]])>>=
/*
 *  the status of the current message walk
 */
struct Msg
{
    uchar	*ps;	/* packet ptr */
    uchar	*pe;	/* packet end */

    char	*p;	/* buffer start */
    char	*e;	/* buffer end */

    int	needroot;	/* pr is root, need to see in expression */
    Proto	*pr;	/* current/next protocol */	
};
@

<<enum [[_anon_ (networking/ip/snoopy/dat.h)]]>>=
enum
{
    Fnum,		/* just a number */
    Fether,		/* ethernet address */
    Fv4ip,		/* v4 ip address */
    Fv6ip,		/* v6 ip address */
    Fba,		/* byte array */
};
@

<<struct [[Filter]]>>=
/*
 *  a node in the filter tree
 */
struct Filter {
    int	op;	/* token type */
    char	*s;	/* string */
    Filter	*l;
    Filter	*r;

    Proto	*pr;	/* next protocol;

    /* protocol specific */
    int	subop;
    ulong	param;
    union {
        ulong	ulv;
        vlong	vlv;
        uchar	a[32];
    };
};
@

<<constant [[YYSTYPE]]>>=
#define YYSTYPE Filterptr
@


%-------------------------------------------------------------

<<networking/ip/snoopy/dat.h>>=
typedef struct Field Field;
typedef struct Filter Filter;
typedef struct Msg Msg;
typedef struct Mux Mux;
typedef struct Proto Proto;

<<macro [[NetS]]([[(networking/ip/snoopy/dat.h)]])>>
<<macro [[Net3]]>>
<<macro [[NetL]]([[(networking/ip/snoopy/dat.h)]])>>

<<struct [[Proto]]([[(networking/ip/snoopy/dat.h)]])>>
extern Proto *protos[];

<<struct [[Mux]]>>

<<struct [[Field]]>>

<<struct [[Msg]]([[(networking/ip/snoopy/dat.h)]])>>

<<enum [[_anon_ (networking/ip/snoopy/dat.h)]]>>

<<struct [[Filter]]>>

extern void	yyinit(char*);
extern int	yyparse(void);

extern Filter*	newfilter(void);
extern void	compile_cmp(char*, Filter*, Field*);
extern void	demux(Mux*, ulong, ulong, Msg*, Proto*);
extern int	defaultframer(int, uchar*, int);

extern int Mflag;
extern int Nflag;
extern int dflag;
extern int Cflag;

typedef Filter *Filterptr;
<<constant [[YYSTYPE]]>>
extern Filter *filter;
@


\subsection*{[[networking/ip/snoopy/main.c]]}

<<global [[Cflag]]>>=
int Cflag;
@

<<global [[pflag]]>>=
int pflag;
@

<<global [[Nflag]]>>=
int Nflag;
@

<<global [[Mflag]]>>=
int Mflag;
@

<<global [[sflag]]>>=
int sflag;
@

<<global [[tiflag]]>>=
int tiflag;
@

<<global [[toflag]]>>=
int toflag;
@

<<global [[prom]]>>=
char *prom = "promiscuous";
@

<<enum [[_anon_ (networking/ip/snoopy/main.c)]]>>=
enum
{
    Pktlen=	64*1024,
    Blen=	16*1024,
};
@

<<global [[filter]]>>=
Filter *filter;
@

<<global [[root]]([[(networking/ip/snoopy/main.c)]])>>=
Proto *root;
@

<<global [[out]]([[(networking/ip/snoopy/main.c)]])>>=
Biobuf out;
@

<<global [[pcap]]>>=
int pcap;
@


<<function [[main]]([[(networking/ip/snoopy/main.c)]])>>=
void
main(int argc, char **argv)
{
    uchar *pkt;
    char *buf, *file, *p, *e;
    int fd, cfd;
    int n;

    Binit(&out, 1, OWRITE);

    fmtinstall('E', eipfmt);
    fmtinstall('V', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('H', encodefmt);
    fmtinstall('F', fcallfmt);

    pkt = malloc(Pktlen+16);
    pkt += 16;
    buf = malloc(Blen);
    e = buf+Blen-1;

    pflag = 1;
    Nflag = 32;
    sflag = 0;

    mkprotograph();

    ARGBEGIN{
    default:
        usage();
    case '?':
        printusage();
        printhelp(ARGF());
        exits(0);
        break;
    case 'M':
        p = EARGF(usage());
        Mflag = atoi(p);
        break;
    case 'N':
        p = EARGF(usage());
        Nflag = atoi(p);
        break;
    case 'f':
        p = EARGF(usage());
        yyinit(p);
        yyparse();
        break;
    case 's':
        sflag = 1;
        break;
    case 'h':
        p = EARGF(usage());
        root = findproto(p);
        if(root == nil)
            sysfatal("unknown protocol: %s", p);
        break;
    case 'd':
        toflag = 1;
        break;
    case 'D':
        toflag = 1;
        pcap = 1;
        break;
    case 't':
        tiflag = 1;
        break;
    case 'C':
        Cflag = 1;
        break;
    case 'p':
        pflag = 0;
        break;
    }ARGEND;

    if(pcap)
        pcaphdr();

    if(argc == 0){
        file = "/net/ether0";
        if(root != nil)
            root = &ether;
    } else
        file = argv[0];

    if((!tiflag) && strstr(file, "ether")){
        if(root == nil)
            root = &ether;
        snprint(buf, Blen, "%s!-1", file);
        fd = dial(buf, 0, 0, &cfd);
        if(fd < 0)
            sysfatal("dialing %s: %r", buf);
        if(pflag && fprint(cfd, prom, strlen(prom)) < 0)
            sysfatal("setting %s", prom);
    } else if((!tiflag) && strstr(file, "ipifc")){
        if(root == nil)
            root = &ip;
        snprint(buf, Blen, "%s/snoop", file);
        fd = open(buf, OREAD);
        if(fd < 0)
            sysfatal("opening %s: %r", buf);
    } else {
        if(root == nil)
            root = &ether;
        fd = open(file, OREAD);
        if(fd < 0)
            sysfatal("opening %s: %r", file);
    }
    filter = compile(filter);

    if(tiflag){
        /* read a trace file */
        for(;;){
            n = read(fd, pkt, 10);
            if(n != 10)
                break;
            pkttime = NetL(pkt+2);
            pkttime = (pkttime<<32) | NetL(pkt+6);
            if(starttime == 0LL)
                starttime = pkttime;
            n = NetS(pkt);
            if(readn(fd, pkt, n) != n)
                break;
            if(filterpkt(filter, pkt, pkt+n, root, 1))
                if(toflag)
                    tracepkt(pkt, n);
                else
                    printpkt(buf, e, pkt, pkt+n);
        }
    } else {
        /* read a real time stream */
        starttime = nsec();
        for(;;){
            n = root->framer(fd, pkt, Pktlen);
            if(n <= 0)
                break;
            pkttime = nsec();
            if(filterpkt(filter, pkt, pkt+n, root, 1))
                if(toflag)
                    tracepkt(pkt, n);
                else
                    printpkt(buf, e, pkt, pkt+n);
        }
    }
}
@
% >> >> >> >>

<<function [[newfilter]]>>=
/* create a new filter node */
Filter*
newfilter(void)
{
    Filter *f;

    f = mallocz(sizeof(*f), 1);
    if(f == nil)
        sysfatal("newfilter: %r");
    return f;
}
@

<<function [[_filterpkt]]>>=
/*
 *  apply filter to packet
 */
int
_filterpkt(Filter *f, Msg *m)
{
    Msg ma;

    if(f == nil)
        return 1;

    switch(f->op){
    case '!':
        return !_filterpkt(f->l, m);
    case LAND:
        ma = *m;
        return _filterpkt(f->l, &ma) && _filterpkt(f->r, m);
    case LOR:
        ma = *m;
        return _filterpkt(f->l, &ma) || _filterpkt(f->r, m);
    case WORD:
        if(m->needroot){
            if(m->pr != f->pr)
                return 0;
            m->needroot = 0;
        }else{
            if(m->pr && (m->pr->filter==nil || !(m->pr->filter)(f, m)))
                return 0;
        }
        if(f->l == nil)
            return 1;
        m->pr = f->pr;
        return _filterpkt(f->l, m);
    }
    sysfatal("internal error: filterpkt op: %d", f->op);
    return 0;
}
@

<<function [[filterpkt]]>>=
int
filterpkt(Filter *f, uchar *ps, uchar *pe, Proto *pr, int needroot)
{
    Msg m;

    if(f == nil)
        return 1;

    m.needroot = needroot;
    m.ps = ps;
    m.pe = pe;
    m.pr = pr;
    return _filterpkt(f, &m);
}
@

<<constant [[PCAP_VERSION_MAJOR]]>>=
/*
 *  from the Unix world
 */
#define PCAP_VERSION_MAJOR 2
@

<<constant [[PCAP_VERSION_MINOR]]>>=
#define PCAP_VERSION_MINOR 4
@

<<constant [[TCPDUMP_MAGIC]]>>=
#define TCPDUMP_MAGIC 0xa1b2c3d4
@

<<struct [[pcap_file_header]]>>=
struct pcap_file_header {
    ulong		magic;
    ushort		version_major;
    ushort		version_minor;
    long		thiszone;    /* gmt to local correction */
    ulong		sigfigs;    /* accuracy of timestamps */
    ulong		snaplen;    /* max length saved portion of each pkt */
    ulong		linktype;   /* data link type (DLT_*) */
};
@

<<struct [[pcap_pkthdr]]>>=
struct pcap_pkthdr {
        uvlong	ts;	/* time stamp */
        ulong	caplen;	/* length of portion present */
        ulong	len;	/* length this packet (off wire) */
};
@

<<function [[pcaphdr]]>>=
/*
 *  pcap trace header 
 */
void
pcaphdr(void)
{
    struct pcap_file_header hdr;

    hdr.magic = TCPDUMP_MAGIC;
    hdr.version_major = PCAP_VERSION_MAJOR;
    hdr.version_minor = PCAP_VERSION_MINOR;
  
    hdr.thiszone = 0;
    hdr.snaplen = 1500;
    hdr.sigfigs = 0;
    hdr.linktype = 1;

    write(1, &hdr, sizeof(hdr));
}
@

<<function [[tracepkt]]>>=
/*
 *  write out a packet trace
 */
void
tracepkt(uchar *ps, int len)
{
    struct pcap_pkthdr *goo;

    if(Mflag && len > Mflag)
        len = Mflag;
    if(pcap){
        goo = (struct pcap_pkthdr*)(ps-16);
        goo->ts = pkttime;
        goo->caplen = len;
        goo->len = len;
        write(1, goo, len+16);
    } else {
        hnputs(ps-10, len);
        hnputl(ps-8, pkttime>>32);
        hnputl(ps-4, pkttime);
        write(1, ps-10, len+10);
    }
}
@

<<function [[printpkt]]>>=
/*
 *  format and print a packet
 */
void
printpkt(char *p, char *e, uchar *ps, uchar *pe)
{
    Msg m;
    ulong dt;

    dt = (pkttime-starttime)/1000000LL;
    m.p = seprint(p, e, "%6.6uld ms ", dt);
    m.ps = ps;
    m.pe = pe;
    m.e = e;
    m.pr = root;
    while(m.p < m.e){
        if(!sflag)
            m.p = seprint(m.p, m.e, "\n\t");
        m.p = seprint(m.p, m.e, "%s(", m.pr->name);
        if((*m.pr->seprint)(&m) < 0){
            m.p = seprint(m.p, m.e, "TOO SHORT");
            m.ps = m.pe;
        }
        m.p = seprint(m.p, m.e, ")");
        if(m.pr == nil || m.ps >= m.pe)
            break;
    }
    *m.p++ = '\n';

    if(write(1, p, m.p - p) < 0)
        sysfatal("stdout: %r");
}
@

<<global [[xprotos]]>>=
Proto **xprotos;
@

<<global [[nprotos]]>>=
int nprotos;
@

<<function [[findproto]]>>=
/* look up a protocol by its name */
Proto*
findproto(char *name)
{
    int i;

    for(i = 0; i < nprotos; i++)
        if(strcmp(xprotos[i]->name, name) == 0)
            return xprotos[i];
    return nil;
}
@

<<function [[addproto]]>>=
/*
 *  add an undefined protocol to protos[]
 */
Proto*
addproto(char *name)
{
    Proto *pr;

    xprotos = realloc(xprotos, (nprotos+1)*sizeof(Proto*));
    pr = malloc(sizeof *pr);
    *pr = dump;
    pr->name = name;
    xprotos[nprotos++] = pr;
    return pr;
}
@

<<function [[mkprotograph]]>>=
/*
 *  build a graph of protocols, this could easily be circular.  This
 *  links together all the multiplexing in the protocol modules.
 */
void
mkprotograph(void)
{
    Proto **l;
    Proto *pr;
    Mux *m;

    /* copy protos into a reallocable area */
    for(nprotos = 0; protos[nprotos] != nil; nprotos++)
        ;
    xprotos = malloc(nprotos*sizeof(Proto*));
    memmove(xprotos, protos, nprotos*sizeof(Proto*));

    for(l = protos; *l != nil; l++){
        pr = *l;
        for(m = pr->mux; m != nil && m->name != nil; m++){
            m->pr = findproto(m->name);
            if(m->pr == nil)
                m->pr = addproto(m->name);
        }
    }
}
@

<<function [[addnode]]([[(networking/ip/snoopy/main.c)]])>>=
/*
 *  add in a protocol node
 */
static Filter*
addnode(Filter *f, Proto *pr)
{
    Filter *nf;
    nf = newfilter();
    nf->pr = pr;
    nf->s = pr->name;
    nf->l = f;
    nf->op = WORD;
    return nf;
}
@

<<function [[_fillin]]>>=
/*
 *  recurse through the protocol graph adding missing nodes
 *  to the filter if we reach the filter's protocol
 */
static Filter*
_fillin(Filter *f, Proto *last, int depth)
{
    Mux *m;
    Filter *nf;

    if(depth-- <= 0)
        return nil;

    for(m = last->mux; m != nil && m->name != nil; m++){
        if(m->pr == nil)
            continue;
        if(f->pr == m->pr)
            return f;
        nf = _fillin(f, m->pr, depth);
        if(nf != nil)
            return addnode(nf, m->pr);
    }
    return nil;
}
@

<<function [[fillin]]>>=
static Filter*
fillin(Filter *f, Proto *last)
{
    int i;
    Filter *nf;

    /* hack to make sure top level node is the root */
    if(last == nil){
        if(f->pr == root)
            return f;
        f = fillin(f, root);
        if(f == nil)
            return nil;
        return addnode(f, root);
    }

    /* breadth first search though the protocol graph */
    nf = f;
    for(i = 1; i < 20; i++){
        nf = _fillin(f, last, i);
        if(nf != nil)
            break;
    }
    return nf;
}
@

<<function [[complete]]>>=
/*
 *  massage tree so that all paths from the root to a leaf
 *  contain a filter node for each header.
 *
 *  also, set f->pr where possible
 */
Filter*
complete(Filter *f, Proto *last)
{
    Proto *pr;

    if(f == nil)
        return f;

    /* do a depth first traversal of the filter tree */
    switch(f->op){
    case '!':
        f->l = complete(f->l, last);
        break;
    case LAND:
    case LOR:
        f->l = complete(f->l, last);
        f->r = complete(f->r, last);
        break;
    case '=':
        break;
    case WORD:
        pr = findproto(f->s);
        f->pr = pr;
        if(pr == nil){
            if(f->l != nil){
                fprint(2, "%s unknown proto, ignoring params\n",
                    f->s);
                f->l = nil;
            }
        } else {
            f->l = complete(f->l, pr);
            f = fillin(f, last);
            if(f == nil)
                sysfatal("internal error: can't get to %s", pr->name);
        }
        break;
    }
    return f;
}
@

<<global [[changed]]>>=
/*
 *  merge common nodes under | and & moving the merged node
 *  above the | or &.
 *
 *  do some constant foldong, e.g. `true & x' becomes x and
 *  'true | x' becomes true.
 */
static int changed;
@

<<function [[_optimize]]>>=
static Filter*
_optimize(Filter *f)
{
    Filter *l;

    if(f == nil)
        return f;

    switch(f->op){
    case '!':
        /* is child also a not */
        if(f->l->op == '!'){
            changed = 1;
            return f->l->l;
        }
        break;
    case LOR:
        /* are two children the same protocol? */
        if(f->l->op != f->r->op || f->r->op != WORD
        || f->l->pr != f->r->pr || f->l->pr == nil)
            break;	/* no optimization */

        changed = 1;

        /* constant folding */
        /* if either child is childless, just return that */
        if(f->l->l == nil)
            return f->l;
        else if(f->r->l == nil)
            return f->r;

        /* move the common node up, thow away one node */
        l = f->l;
        f->l = l->l;
        f->r = f->r->l;
        l->l = f;
        return l;
    case LAND:
        /* are two children the same protocol? */
        if(f->l->op != f->r->op || f->r->op != WORD
        || f->l->pr != f->r->pr || f->l->pr == nil)
            break;	/* no optimization */

        changed = 1;

        /* constant folding */
        /* if either child is childless, ignore it */
        if(f->l->l == nil)
            return f->r;
        else if(f->r->l == nil)
            return f->l;

        /* move the common node up, thow away one node */
        l = f->l;
        f->l = _optimize(l->l);
        f->r = _optimize(f->r->l);
        l->l = f;
        return l;
    }
    f->l = _optimize(f->l);
    f->r = _optimize(f->r);
    return f;
}
@

<<function [[optimize]]>>=
Filter*
optimize(Filter *f)
{
    do{
        changed = 0;
        f = _optimize(f);
    }while(changed);

    return f;
}
@

<<function [[findbogus]]>>=
/*
 *  find any top level nodes that aren't the root
 */
int
findbogus(Filter *f)
{
    int rv;

    if(f->op != WORD){
        rv = findbogus(f->l);
        if(f->r)
            rv |= findbogus(f->r);
        return rv;
    } else if(f->pr != root){
        fprint(2, "bad top-level protocol: %s\n", f->s);
        return 1;
    }
    return 0;
}
@

<<function [[_compile]]>>=
/*
 *  compile the filter
 */
static void
_compile(Filter *f, Proto *last)
{
    if(f == nil)
        return;

    switch(f->op){
    case '!':
        _compile(f->l, last);
        break;
    case LOR:
    case LAND:
        _compile(f->l, last);
        _compile(f->r, last);
        break;
    case WORD:
        if(last != nil){
            if(last->compile == nil)
                sysfatal("unknown %s subprotocol: %s", f->pr->name, f->s);
            (*last->compile)(f);
        }
        if(f->l)
            _compile(f->l, f->pr);
        break;
    case '=':
        if(last == nil)
            sysfatal("internal error: compilewalk: badly formed tree");
        
        if(last->compile == nil)
            sysfatal("unknown %s field: %s", f->pr->name, f->s);
        (*last->compile)(f);
        break;
    default:
        sysfatal("internal error: compilewalk op: %d", f->op);
    }
}
@

<<function [[compile]]>>=
Filter*
compile(Filter *f)
{
    if(f == nil)
        return f;

    /* fill in the missing header filters */
    f = complete(f, nil);

    /* constant folding */
    f = optimize(f);
    if(!toflag)
        printfilter(f, "after optimize");

    /* protocol specific compilations */
    _compile(f, nil);

    /* at this point, the root had better be the root proto */
    if(findbogus(f)){
        fprint(2, "bogus filter\n");
        exits("bad filter");
    }

    return f;
}
@

<<function [[parseba]]>>=
/*
 *  parse a byte array
 */
int
parseba(uchar *to, char *from)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    for(i = 0; i < 16; i++){
        if(*p == 0)
            return -1;
        nip[0] = *p++;
        if(*p == 0)
            return -1;
        nip[1] = *p++;
        nip[2] = 0;
        to[i] = strtoul(nip, 0, 16);
    }
    return i;
}
@

<<function [[compile_cmp]]>>=
/*
 *  compile WORD = WORD, becomes a single node with a subop
 */
void
compile_cmp(char *proto, Filter *f, Field *fld)
{
    uchar x[IPaddrlen];
    char *v;

    if(f->op != '=')
        sysfatal("internal error: compile_cmp %s: not a cmp", proto);

    for(; fld->name != nil; fld++){
        if(strcmp(f->l->s, fld->name) == 0){
            f->op = WORD;
            f->subop = fld->subop;
            switch(fld->ftype){
            case Fnum:
                f->ulv = atoi(f->r->s);
                break;
            case Fether:
                v = csgetvalue(nil, "sys", (char*)f->r->s,
                    "ether", 0);
                if(v){
                    parseether(f->a, v);
                    free(v);
                } else
                    parseether(f->a, f->r->s);
                break;
            case Fv4ip:
                v = csgetvalue(nil, "sys", (char*)f->r->s,
                    "ip", 0);
                if(v){
                    f->ulv = parseip(x, v);
                    free(v);
                }else
                    f->ulv = parseip(x, f->r->s);
                break;
            case Fv6ip:
                v = csgetvalue(nil, "sys", (char*)f->r->s,
                    "ipv6", 0);
                if(v){
                    parseip(f->a, v);
                    free(v);
                }else
                    parseip(f->a, f->r->s);
                break;
            case Fba:
                parseba(f->a, f->r->s);
                break;
            default:
                sysfatal("internal error: compile_cmp %s: %d",
                    proto, fld->ftype);
            }
            f->l = f->r = nil;
            return;
        }
    }
    sysfatal("unknown %s field in: %s = %s", proto, f->l->s, f->r->s);
}
@

<<function [[_pf]]>>=
void
_pf(Filter *f)
{
    char *s;

    if(f == nil)
        return;

    s = nil;
    switch(f->op){
    case '!':
        fprint(2, "!");
        _pf(f->l);
        break;
    case WORD:
        fprint(2, "%s", f->s);
        if(f->l != nil){
            fprint(2, "(");
            _pf(f->l);
            fprint(2, ")");
        }
        break;
    case LAND:
        s = "&&";
        goto print;
    case LOR:
        s = "||";
        goto print;
    case '=':
    print:
        _pf(f->l);
        if(s)
            fprint(2, " %s ", s);
        else
            fprint(2, " %c ", f->op);
        _pf(f->r);
        break;
    default:
        fprint(2, "???");
        break;
    }
}
@

<<function [[printfilter]]>>=
void
printfilter(Filter *f, char *tag)
{
    fprint(2, "%s: ", tag);
    _pf(f);
    fprint(2, "\n");
}
@

<<function [[cat]]>>=
void
cat(void)
{
    char buf[1024];
    int n;
    
    while((n = read(0, buf, sizeof buf)) > 0)
        write(1, buf, n);
}
@

<<global [[fd1]]>>=
static int fd1 = -1;
@

<<function [[startmc]]>>=
void
startmc(void)
{
    int p[2];
    
    if(fd1 == -1)
        fd1 = dup(1, -1);
    
    if(pipe(p) < 0)
        return;
    switch(fork()){
    case -1:
        return;
    default:
        close(p[0]);
        dup(p[1], 1);
        if(p[1] != 1)
            close(p[1]);
        return;
    case 0:
        close(p[1]);
        dup(p[0], 0);
        if(p[0] != 0)
            close(p[0]);
        execl("/bin/mc", "mc", nil);
        cat();
        _exits(0);
    }
}
@

<<function [[stopmc]]>>=
void
stopmc(void)
{
    close(1);
    dup(fd1, 1);
    waitpid();
}
@

<<function [[printhelp]]>>=
void
printhelp(char *name)
{
    int len;
    Proto *pr, **l;
    Mux *m;
    Field *f;
    char fmt[40];
    
    if(name == nil){
        print("protocols:\n");
        startmc();
        for(l=protos; (pr=*l) != nil; l++)
            print("  %s\n", pr->name);
        stopmc();
        return;
    }
    
    pr = findproto(name);
    if(pr == nil){
        print("unknown protocol %s\n", name);
        return;
    }
    
    if(pr->field){
        print("%s's filter attributes:\n", pr->name);
        len = 0;
        for(f=pr->field; f->name; f++)
            if(len < strlen(f->name))
                len = strlen(f->name);
        startmc();
        for(f=pr->field; f->name; f++)
            print("  %-*s - %s\n", len, f->name, f->help);
        stopmc();
    }
    if(pr->mux){
        print("%s's subprotos:\n", pr->name);
        startmc();
        snprint(fmt, sizeof fmt, "  %s %%s\n", pr->valfmt);
        for(m=pr->mux; m->name != nil; m++)
            print(fmt, m->val, m->name);
        stopmc();
    }
}
@

<<function [[demux]]>>=
/*
 *  demultiplex to next prototol header
 */
void
demux(Mux *mx, ulong val1, ulong val2, Msg *m, Proto *def)
{
    m->pr = def;
    for(mx = mx; mx->name != nil; mx++){
        if(val1 == mx->val || val2 == mx->val){
            m->pr = mx->pr;
            break;
        }
    }
}
@

<<function [[defaultframer]]>>=
/*
 *  default framer just assumes the input packet is
 *  a single read
 */
int
defaultframer(int fd, uchar *pkt, int pktlen)
{
    return read(fd, pkt, pktlen);
}
@


%-------------------------------------------------------------

<<networking/ip/snoopy/main.c>>=
/*
 * snoopy - network sniffer
 */
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <fcall.h>
#include <libsec.h>
#include <ndb.h>
#include "dat.h"
#include "protos.h"
#include "y.tab.h"

<<global [[Cflag]]>>
<<global [[pflag]]>>
<<global [[Nflag]]>>
<<global [[Mflag]]>>
<<global [[sflag]]>>
<<global [[tiflag]]>>
<<global [[toflag]]>>

<<global [[prom]]>>

<<enum [[_anon_ (networking/ip/snoopy/main.c)]]>>

<<global [[filter]]>>
<<global [[root]]([[(networking/ip/snoopy/main.c)]])>>
<<global [[out]]([[(networking/ip/snoopy/main.c)]])>>
vlong starttime, pkttime;
<<global [[pcap]]>>

int	filterpkt(Filter *f, uchar *ps, uchar *pe, Proto *pr, int);
void	printpkt(char *p, char *e, uchar *ps, uchar *pe);
void	mkprotograph(void);
Proto*	findproto(char *name);
Filter*	compile(Filter *f);
void	printfilter(Filter *f, char *tag);
void	printhelp(char*);
void	tracepkt(uchar*, int);
void	pcaphdr(void);

<<function [[printusage]]>>

<<function [[usage]]([[(networking/ip/snoopy/main.c)]])>>

<<function [[main]]([[(networking/ip/snoopy/main.c)]])>>

<<function [[newfilter]]>>

<<function [[_filterpkt]]>>
<<function [[filterpkt]]>>

<<constant [[PCAP_VERSION_MAJOR]]>>
<<constant [[PCAP_VERSION_MINOR]]>>
<<constant [[TCPDUMP_MAGIC]]>>

<<struct [[pcap_file_header]]>>

<<struct [[pcap_pkthdr]]>>

<<function [[pcaphdr]]>>

<<function [[tracepkt]]>>

<<function [[printpkt]]>>

<<global [[xprotos]]>>
<<global [[nprotos]]>>

<<function [[findproto]]>>

<<function [[addproto]]>>

<<function [[mkprotograph]]>>

<<function [[addnode]]([[(networking/ip/snoopy/main.c)]])>>

<<function [[_fillin]]>>

<<function [[fillin]]>>

<<function [[complete]]>>

<<global [[changed]]>>

<<function [[_optimize]]>>

<<function [[optimize]]>>

<<function [[findbogus]]>>

<<function [[_compile]]>>

<<function [[compile]]>>

<<function [[parseba]]>>

<<function [[compile_cmp]]>>

<<function [[_pf]]>>

<<function [[printfilter]]>>

<<function [[cat]]>>

<<global [[fd1]]>>
<<function [[startmc]]>>

<<function [[stopmc]]>>

<<function [[printhelp]]>>

<<function [[demux]]>>

<<function [[defaultframer]]>>
@


\subsection*{[[networking/ip/snoopy/ether.c]]}

<<struct [[Hdr]]>>=
struct Hdr {
    uchar	d[6];
    uchar	s[6];
    uchar	type[2];
    char	data[1500];
};
@
% dest, source
% => 1514 size!

<<constant [[ETHERMINTU]]([[(networking/ip/snoopy/ether.c)]])>>=
#define	ETHERMINTU	60	/* minimum transmit size */
@

<<constant [[ETHERMAXTU]]([[(networking/ip/snoopy/ether.c)]])>>=
#define	ETHERMAXTU	1514	/* maximum transmit size */
@


<<constant [[ETHERHDRSIZE]]([[(networking/ip/snoopy/ether.c)]])>>=
#define ETHERHDRSIZE	14	/* size of an ethernet header */
@

<<global [[p_mux]]>>=
static Mux p_mux[] =
{
    {"ip",		0x0800,	} ,
    {"arp",		0x0806,	} ,

    {"rarp",	0x0806,	} ,
    {"ip6", 	0x86dd, } ,
    {"pppoe_disc",	0x8863, },
    {"pppoe_sess",	0x8864, },
    {"eapol",	0x888e, },
    {"aoe",		0x88a2, } ,
    {"cec",		0xbcbc, } ,
    {0}
};
@

<<enum [[_anon_ (networking/ip/snoopy/ether.c)]]>>=
enum
{
    Os,	/* source */
    Od,	/* destination */
    Oa,	/* source or destination */
    Ot,	/* type */
};
@

<<global [[p_fields]]>>=
static Field p_fields[] =
{
    {"s",	Fether,	Os,	"source address",	} ,
    {"d",	Fether,	Od,	"destination address",	} ,
    {"a",	Fether,	Oa,	"source|destination address" } ,
    {"sd",	Fether,	Oa,	"source|destination address" } ,
    {"t",	Fnum,	Ot,	"type" } ,
    {0}
};
@

<<function [[p_compile]]>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(ether.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
    sysfatal("unknown ethernet field or protocol: %s", f->s);
}
@

<<function [[p_filter]]>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < ETHERHDRSIZE)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += ETHERHDRSIZE;

    switch(f->subop){
    case Os:
        return memcmp(h->s, f->a, 6) == 0;
    case Od:
        return memcmp(h->d, f->a, 6) == 0;
    case Oa:
        return memcmp(h->s, f->a, 6) == 0 || memcmp(h->d, f->a, 6) == 0;
    case Ot:
        return NetS(h->type) == f->ulv;
    }
    return 0;
}
@

<<function [[p_seprint]]>>=
static int
p_seprint(Msg *m)
{
    int len;
    uint t;
    Hdr *h;

    len = m->pe - m->ps;
    if(len < ETHERHDRSIZE)
        return -1;

    h = (Hdr*)m->ps;
    m->ps += ETHERHDRSIZE;

    t = NetS(h->type);
    demux(p_mux, t, t, m, &dump);

    m->p = seprint(m->p, m->e, "s=%E d=%E pr=%4.4ux ln=%d", h->s, h->d,
        t, len);
    return 0;
}
@

<<global [[ether]]>>=
Proto ether =
{
    "ether",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%#.4lux",
    p_fields,
    defaultframer
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/ether.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]>>

<<constant [[ETHERMINTU]]([[(networking/ip/snoopy/ether.c)]])>>
<<constant [[ETHERMAXTU]]([[(networking/ip/snoopy/ether.c)]])>>
<<constant [[ETHERHDRSIZE]]([[(networking/ip/snoopy/ether.c)]])>>

<<global [[p_mux]]>>

<<enum [[_anon_ (networking/ip/snoopy/ether.c)]]>>

<<global [[p_fields]]>>

<<function [[p_compile]]>>

<<function [[p_filter]]>>

<<function [[p_seprint]]>>

<<global [[ether]]>>
@


\subsection*{[[networking/ip/snoopy/ip.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/ip.c)]])>>=
struct Hdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* ip->identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* IP source */
    uchar	dst[4];		/* IP destination */
};
@

<<enum [[_anon_ (networking/ip/snoopy/ip.c)]]>>=
enum
{
    IPHDR		= 20,		/* sizeof(Iphdr) */
    IP_VER		= 0x40,		/* Using IP version 4 */
    IP_DF		= 0x4000,	/* Don't fragment */
    IP_MF		= 0x2000,	/* More fragments */
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/ip.c)]])>>=
static Mux p_mux[] =
{
    { "icmp", 1, },
    { "igmp", 2, },
    { "ggp", 3, },
    { "ip", 4, },
    { "st", 5, },
    { "tcp", 6, },
    { "ucl", 7, },
    { "egp", 8, },
    { "igp", 9, },
    { "bbn-rcc-mon", 10, },
    { "nvp-ii", 11, },
    { "pup", 12, },
    { "argus", 13, },
    { "emcon", 14, },
    { "xnet", 15, },
    { "chaos", 16, },
    { "udp", 17, },
    { "mux", 18, },
    { "dcn-meas", 19, },
    { "hmp", 20, },
    { "prm", 21, },
    { "xns-idp", 22, },
    { "trunk-1", 23, },
    { "trunk-2", 24, },
    { "leaf-1", 25, },
    { "leaf-2", 26, },
    { "rdp", 27, },
    { "irtp", 28, },
    { "iso-tp4", 29, },
    { "netblt", 30, },
    { "mfe-nsp", 31, },
    { "merit-inp", 32, },
    { "sep", 33, },
    { "3pc", 34, },
    { "idpr", 35, },
    { "xtp", 36, },
    { "ddp", 37, },
    { "idpr-cmtp", 38, },
    { "tp++", 39, },
    { "il", 40, },
    { "sip", 41, },
    { "sdrp", 42, },
    { "sip-sr", 43, },
    { "sip-frag", 44, },
    { "idrp", 45, },
    { "rsvp", 46, },
    { "gre", 47, },
    { "mhrp", 48, },
    { "bna", 49, },
    { "sipp-esp", 50, },
    { "sipp-ah", 51, },
    { "i-nlsp", 52, },
    { "swipe", 53, },
    { "nhrp", 54, },
    { "any", 61, },
    { "cftp", 62, },
    { "any", 63, },
    { "sat-expak", 64, },
    { "kryptolan", 65, },
    { "rvd", 66, },
    { "ippc", 67, },
    { "any", 68, },
    { "sat-mon", 69, },
    { "visa", 70, },
    { "ipcv", 71, },
    { "cpnx", 72, },
    { "cphb", 73, },
    { "wsn", 74, },
    { "pvp", 75, },
    { "br-sat-mon", 76, },
    { "sun-nd", 77, },
    { "wb-mon", 78, },
    { "wb-expak", 79, },
    { "iso-ip", 80, },
    { "vmtp", 81, },
    { "secure-vmtp", 82, },
    { "vines", 83, },
    { "ttp", 84, },
    { "nsfnet-igp", 85, },
    { "dgp", 86, },
    { "tcf", 87, },
    { "igrp", 88, },
    { "ospf", 89, },
    { "sprite-rpc", 90, },
    { "larp", 91, },
    { "mtp", 92, },
    { "ax.25", 93, },
    { "ipip", 94, },
    { "micp", 95, },
    { "scc-sp", 96, },
    { "etherip", 97, },
    { "encap", 98, },
    { "any", 99, },
    { "gmtp", 100, },
    { "rudp", 254, },
    { 0 }
};
@

<<enum [[_anon_ (networking/ip/snoopy/ip.c)2]]>>=
enum
{
    Os,	/* source */
    Od,	/* destination */
    Osd,	/* source or destination */
    Ot,	/* type */
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/ip.c)]])>>=
static Field p_fields[] =
{
    {"s",	Fv4ip,	Os,	"source address",	} ,
    {"d",	Fv4ip,	Od,	"destination address",	} ,
    {"a",	Fv4ip,	Osd,	"source|destination address",} ,
    {"sd",	Fv4ip,	Osd,	"source|destination address",} ,
    {"t",	Fnum,	Ot,	"sub protocol number",	} ,
    {0}
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/ip.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(ip.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
    sysfatal("unknown ip field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/ip.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < IPHDR)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += (h->vihl & 0xf) << 2;

    switch(f->subop){
    case Os:
        return NetL(h->src) == f->ulv;
    case Od:
        return NetL(h->dst) == f->ulv;
    case Osd:
        return NetL(h->src) == f->ulv || NetL(h->dst) == f->ulv;
    case Ot:
        return h->proto == f->ulv;
    }
    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/ip.c)]])>>=
static int
p_seprint(Msg *m)
{
    int f, len, hl;
    uchar *p;
    Hdr *h;

    if(m->pe - m->ps < IPHDR)
        return -1;
    h = (Hdr*)m->ps;

    /* next protocol, just dump unless this is the first fragment */
    m->pr = &dump;
    f = NetS(h->frag);
    if((f & ~(IP_DF|IP_MF)) == 0)
        demux(p_mux, h->proto, h->proto, m, &dump);

    /* truncate the message if there's extra */
    len = NetS(h->length);
    if(len < m->pe - m->ps)
        m->pe = m->ps + len;

    /* next header */
    hl = (h->vihl  &0xf) << 2;

    m->p = seprint(m->p, m->e, "s=%V d=%V id=%4.4ux frag=%4.4ux ttl=%3d pr=%d ln=%d hl=%d",
        h->src, h->dst, NetS(h->id), NetS(h->frag), h->ttl, h->proto,
        NetS(h->length),
        (h->vihl & 0xf) << 2);

    m->ps += hl;
    p = (uchar *)(h + 1);
    if(p < m->ps){
        m->p = seprint(m->p, m->e, " opts=(");
        while(p < m->ps)
            m->p = seprint(m->p, m->e, "%.2ux", *p++);
        m->p = seprint(m->p, m->e, ")");
    }

    return 0;
}
@

<<global [[ip]]>>=
Proto ip =
{
    "ip",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/ip.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/ip.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/ip.c)]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/ip.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/ip.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/ip.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/ip.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/ip.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/ip.c)]])>>

<<global [[ip]]>>
@


\subsection*{[[networking/ip/snoopy/il.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/il.c)]])>>=
struct Hdr
{
    uchar	sum[2];		/* Checksum including header */
    uchar	len[2];		/* Packet length */
    uchar	type;		/* Packet type */
    uchar	spec;		/* Special */
    uchar	sport[2];	/* Src port */
    uchar	dport[2];	/* Dst port */
    uchar	id[4];		/* Sequence id */
    uchar	ack[4];		/* Acked sequence */
};
@

<<enum [[_anon_ (networking/ip/snoopy/il.c)]]>>=
enum
{
    ILLEN= 18,
};
@

<<enum [[_anon_ (networking/ip/snoopy/il.c)2]]>>=
enum
{
    Os,
    Od,
    Osd,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/il.c)]])>>=
static Field p_fields[] = 
{
    {"s",		Fnum,	Os,	"source port",	} ,
    {"d",		Fnum,	Od,	"dest port",	} ,
    {"a",		Fnum,	Osd,	"source/dest port",	} ,
    {"sd",		Fnum,	Osd,	"source/dest port",	} ,
    {0}
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/il.c)]])>>=
static Mux p_mux[] =
{
    {"ninep",	17007, },	/* exportfs */
    {"ninep",	17008, },	/* 9fs */
    {"ninep",	17005, },	/* ocpu */
    {"ninep",	17010, },	/* ncpu */
    {"ninep",	17013, },	/* cpu */
    {0},
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/il.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(il.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Osd;
            return;
        }
    sysfatal("unknown il field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/il.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < ILLEN)
        return 0;
    h = (Hdr*)m->ps;
    m->ps += ILLEN;

    switch(f->subop){
    case Os:
        return NetS(h->sport) == f->ulv;
    case Od:
        return NetS(h->dport) == f->ulv;
    case Osd:
        return NetS(h->sport) == f->ulv || NetS(h->dport) == f->ulv;
    }
    return 0;
}
@

<<global [[pktnames]]>>=
char *pktnames[] = 
{
    "Sync",	
    "Data",
    "Dataquery",
    "Ack",
    "Query",
    "State",
    "Close"
};
@

<<function [[pkttype]]>>=
static char*
pkttype(int t)
{
    static char b[10];
    
    if(t > 6){
        sprint(b, "%d", t);
        return b;
    }
    return pktnames[t];
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/il.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;
    int dport, sport;

    if(m->pe - m->ps < ILLEN)
        return -1;
    h = (Hdr*)m->ps;
    m->ps += ILLEN;

    dport = NetS(h->dport);
    sport = NetS(h->sport);
    demux(p_mux, sport, dport, m, &dump);

    m->p = seprint(m->p, m->e, "s=%d d=%d t=%s id=%lud ack=%lud spec=%d ck=%4.4ux ln=%d",
            sport, dport, pkttype(h->type),
            (ulong)NetL(h->id), (ulong)NetL(h->ack),
            h->spec,
            NetS(h->sum), NetS(h->len));
    return 0;
}
@

<<global [[il]]>>=
Proto il =
{
    "il",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/il.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/il.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/il.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/il.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/il.c)]])>>

<<global [[p_mux]]([[(networking/ip/snoopy/il.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/il.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/il.c)]])>>

<<global [[pktnames]]>>

<<function [[pkttype]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/il.c)]])>>

<<global [[il]]>>
@


\subsection*{[[networking/ip/snoopy/arp.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/arp.c)]])>>=
struct Hdr
{
    uchar	hrd[2];
    uchar	pro[2];
    uchar	hln;
    uchar	pln;
    uchar	op[2];
    uchar	sha[6];
    uchar	spa[4];
    uchar	tha[6];
    uchar	tpa[4];
};
@

<<enum [[_anon_ (networking/ip/snoopy/arp.c)]]>>=
enum
{
    ARPLEN=	28,
};
@

<<enum [[_anon_ (networking/ip/snoopy/arp.c)2]]>>=
enum
{
    Ospa,
    Otpa,
    Ostpa,
    Osha,
    Otha,
    Ostha,
    Opa,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/arp.c)]])>>=
static Field p_fields[] = 
{
    {"spa",		Fv4ip,	Ospa,	"protocol source",	} ,
    {"tpa",		Fv4ip,	Otpa,	"protocol target",	} ,
    {"a",		Fv4ip,	Ostpa,	"protocol source/target",	} ,
    {"sha",		Fba,	Osha,	"hardware source",	} ,
    {"tha",		Fba,	Otha,	"hardware target",	} ,
    {"ah",	 	Fba,	Ostha,	"hardware source/target",	} ,
    {0}
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/arp.c)]])>>=
static void
p_compile(Filter *f)
{
    if(f->op == '='){
        compile_cmp(arp.name, f, p_fields);
        return;
    }
    sysfatal("unknown arp field: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/arp.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < ARPLEN)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += ARPLEN;

    switch(f->subop){
    case Ospa:
        return h->pln == 4 && NetL(h->spa) == f->ulv;
    case Otpa:
        return h->pln == 4 && NetL(h->tpa) == f->ulv;
    case Ostpa:
        return h->pln == 4 && (NetL(h->tpa) == f->ulv ||
            NetL(h->spa) == f->ulv);
    case Osha:
        return memcmp(h->sha, f->a, h->hln) == 0;
    case Otha:
        return memcmp(h->tha, f->a, h->hln) == 0;
    case Ostha:
        return memcmp(h->sha, f->a, h->hln)==0
            ||memcmp(h->tha, f->a, h->hln)==0;
    }
    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/arp.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < ARPLEN)
        return -1;

    h = (Hdr*)m->ps;
    m->ps += ARPLEN;

    /* no next protocol */
    m->pr = nil;

    m->p = seprint(m->p, m->e, "op=%1d len=%1d/%1d spa=%V sha=%E tpa=%V tha=%E",
            NetS(h->op), h->pln, h->hln,
            h->spa, h->sha, h->tpa, h->tha);
    return 0;
}
@

<<global [[arp]]>>=
Proto arp =
{
    "arp",
    p_compile,
    p_filter,
    p_seprint,
    nil,
    nil,
    p_fields,
    defaultframer,
};
@

<<global [[rarp]]>>=
Proto rarp =
{
    "rarp",
    p_compile,
    p_filter,
    p_seprint,
    nil,
    nil,
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/arp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/arp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/arp.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/arp.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/arp.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/arp.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/arp.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/arp.c)]])>>

<<global [[arp]]>>

<<global [[rarp]]>>
@


\subsection*{[[networking/ip/snoopy/dns.c]]}

<<global [[rrtname]]>>=
/* names of RR types - /sys/src/cmd/ndb/dn.c:/rrtname */
char *rrtname[] =
{
[Ta]		"ip",
[Tns]		"ns",
[Tmd]		"md",
[Tmf]		"mf",
[Tcname]	"cname",
[Tsoa]		"soa",
[Tmb]		"mb",
[Tmg]		"mg",
[Tmr]		"mr",
[Tnull]		"null",
[Twks]		"wks",
[Tptr]		"ptr",
[Thinfo]	"hinfo",
[Tminfo]	"minfo",
[Tmx]		"mx",
[Ttxt]		"txt",
[Trp]		"rp",
[Tafsdb]	"afsdb",
[Tx25]		"x.25",
[Tisdn]		"isdn",
[Trt]		"rt",
[Tnsap]		"nsap",
[Tnsapptr]	"nsap-ptr",
[Tsig]		"sig",
[Tkey]		"key",
[Tpx]		"px",
[Tgpos]		"gpos",
[Taaaa]		"ipv6",
[Tloc]		"loc",
[Tnxt]		"nxt",
[Teid]		"eid",
[Tnimloc]	"nimrod",
[Tsrv]		"srv",
[Tatma]		"atma",
[Tnaptr]	"naptr",
[Tkx]		"kx",
[Tcert]		"cert",
[Ta6]		"a6",
[Tdname]	"dname",
[Tsink]		"sink",
[Topt]		"opt",
[Tapl]		"apl",
[Tds]		"ds",
[Tsshfp]	"sshfp",
[Tipseckey]	"ipseckey",
[Trrsig]	"rrsig",
[Tnsec]		"nsec",
[Tdnskey]	"dnskey",
[Tspf]		"spf",
[Tuinfo]	"uinfo",
[Tuid]		"uid",
[Tgid]		"gid",
[Tunspec]	"unspec",
[Ttkey]		"tkey",
[Ttsig]		"tsig",
[Tixfr]		"ixfr",
[Taxfr]		"axfr",
[Tmailb]	"mailb",
[Tmaila]	"maila",
[Tall]		"all",
        0,
};
@

<<function [[rrtypestr]]>>=
static char*
rrtypestr(int t)
{
    char buf[20];

    if(t >= 0 && t < nelem(rrtname) && rrtname[t])
        return rrtname[t];
    snprint(buf, sizeof buf, "type%d", t);
    return buf;
}
@

<<function [[fmtrr]]>>=
static void
fmtrr(Msg *m, RR **rrp, int quest)
{
    Txt *t;
    RR *rr;

    rr = *rrp;
    if(rr == nil)
        return;
    *rrp = rr->next;

    m->p = seprint(m->p, m->e, "%s name=%s ttl=%lud",
        rrtypestr(rr->type),
        rr->owner->name, rr->ttl);
    if(!quest)
    switch(rr->type){
    default:
        break;
    case Thinfo:
        m->p = seprint(m->p, m->e, " cpu=%s os=%s",
            rr->cpu->name, rr->os->name);
        break;
    case Tcname:
    case Tmb:
    case Tmd:
    case Tmf:
    case Tns:
        m->p = seprint(m->p, m->e, " host=%s", rr->host->name);
        break;
    case Tmg:
    case Tmr:
        m->p = seprint(m->p, m->e, " mb=%s", rr->mb->name);
        break;
    case Tminfo:
        m->p = seprint(m->p, m->e, " rmb=%s", rr->rmb->name);
        m->p = seprint(m->p, m->e, " mb=%s", rr->mb->name);
        break;
    case Tmx:
        m->p = seprint(m->p, m->e, " pref=%lud", rr->pref);
        m->p = seprint(m->p, m->e, " host=%s", rr->host->name);
        break;
    case Ta:
    case Taaaa:
        m->p = seprint(m->p, m->e, " ip=%s", rr->ip->name);
        break;
    case Tptr:
        m->p = seprint(m->p, m->e, " ptr=%s", rr->ptr->name);
        break;
    case Tsoa:
        m->p = seprint(m->p, m->e, " host=%s", rr->host->name);
        m->p = seprint(m->p, m->e, " rmb=%s", rr->rmb->name);
        m->p = seprint(m->p, m->e, " soa.serial=%lud", rr->soa->serial);
        m->p = seprint(m->p, m->e, " soa.refresh=%lud", rr->soa->refresh);
        m->p = seprint(m->p, m->e, " soa.retry=%lud", rr->soa->retry);
        m->p = seprint(m->p, m->e, " soa.expire=%lud", rr->soa->expire);
        m->p = seprint(m->p, m->e, " soa.minttl=%lud", rr->soa->minttl);
        break;
    case Ttxt:
        for(t=rr->txt; t; t=t->next)
            m->p = seprint(m->p, m->e, " txt=%q", t->p);
        break;
    case Tnull:
        m->p = seprint(m->p, m->e, " null=%.*H",
            rr->null->dlen, rr->null->data);
        break;
    case Trp:
        m->p = seprint(m->p, m->e, " rmb=%s", rr->rmb->name);
        m->p = seprint(m->p, m->e, " rp=%s", rr->rp->name);
        break;
    case Tkey:
        m->p = seprint(m->p, m->e, " flags=%d proto=%d alg=%d data=%.*H",
            rr->key->flags, rr->key->proto, rr->key->alg,
            rr->key->dlen, rr->key->data);
        break;
    case Tsig:
        m->p = seprint(m->p, m->e,
" type=%d alg=%d labels=%d ttl=%lud exp=%lud incep=%lud tag=%d signer=%s data=%.*H",
            rr->sig->type, rr->sig->alg, rr->sig->labels,
            rr->sig->ttl, rr->sig->exp, rr->sig->incep, rr->sig->tag,
            rr->sig->signer->name, rr->sig->dlen, rr->sig->data);
        break;
    case Tcert:
        m->p = seprint(m->p, m->e, " type=%d tag=%d alg=%d data=%.*H",
            rr->cert->type, rr->cert->tag, rr->cert->alg,
            rr->cert->dlen, rr->cert->data);
        break;
    }
    rrfree(rr);
}
@

<<global [[dm]]>>=
static DNSmsg dm;
@

<<function [[p_seprint]]([[(networking/ip/snoopy/dns.c)]])>>=
static int
p_seprint(Msg *m)
{
    char *e;

    if((e = convM2DNS(m->ps, m->pe-m->ps, &dm, nil)) != nil){
        m->p = seprint(m->p, m->e, "error: %s", e);
        return 0;
    }
    m->p = seprint(m->p, m->e, "id=%d flags=%#ux", dm.id, dm.flags);
    donext(m);
    return 0;
}
@

<<function [[donext]]>>=
static void
donext(Msg *m)
{
    if(dm.qd)
        m->pr = &dnsqd;
    else if(dm.an)
        m->pr = &dnsan;
    else if(dm.ns)
        m->pr = &dnsns;
    else if(dm.ar)
        m->pr = &dnsar;
    else{
        freealldn();
        memset(&dm, 0, sizeof dm);
        m->pr = nil;
    }
}
@

<<function [[p_seprintqd]]>>=
static int
p_seprintqd(Msg *m)
{
    fmtrr(m, &dm.qd, 1);
    donext(m);
    return 0;
}
@

<<function [[p_seprintan]]>>=
static int
p_seprintan(Msg *m)
{
    fmtrr(m, &dm.an, 0);
    donext(m);
    return 0;
}
@

<<function [[p_seprintns]]>>=
static int
p_seprintns(Msg *m)
{
    fmtrr(m, &dm.ns, 1);
    donext(m);
    return 0;
}
@

<<function [[p_seprintar]]>>=
static int
p_seprintar(Msg *m)
{
    fmtrr(m, &dm.ar, 1);
    donext(m);
    return 0;
}
@

<<global [[dns]]>>=
Proto dns =
{
    "dns",
    nil,
    nil,
    p_seprint,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<global [[dnsqd]]>>=
static Proto dnsqd =
{
    "dns.qd",
    nil,
    nil,
    p_seprintqd,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<global [[dnsan]]>>=
static Proto dnsan =
{
    "dns.an",
    nil,
    nil,
    p_seprintan,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<global [[dnsns]]>>=
static Proto dnsns =
{
    "dns.ns",
    nil,
    nil,
    p_seprintns,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<global [[dnsar]]>>=
static Proto dnsar =
{
    "dns.ar",
    nil,
    nil,
    p_seprintar,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<function [[emalloc]]([[(networking/ip/snoopy/dns.c)]])>>=
void*
emalloc(int n)
{
    void *v;

    v = mallocz(n, 1);
    if(v == nil)
        sysfatal("out of memory");
    return v;
}
@

<<function [[estrdup]]([[(networking/ip/snoopy/dns.c)]])>>=
char*
estrdup(char *s)
{
    s = strdup(s);
    if(s == nil)
        sysfatal("out of memory");
    return s;
}
@

<<global [[alldn]]>>=
DN *alldn;
@

<<function [[dnlookup]]>>=
DN*
dnlookup(char *name, int class, int)
{
    DN *dn;

    dn = emalloc(sizeof *dn);
    dn->name = estrdup(name);
    dn->class = class;
    dn->magic = DNmagic;
    dn->next = alldn;
    alldn = dn;
    return dn;
}
@

<<function [[freealldn]]>>=
void
freealldn(void)
{
    DN *dn;

    while(dn = alldn){
        alldn = dn->next;
        free(dn->name);
        free(dn);
    }
}
@

<<global [[debug]]([[(networking/ip/snoopy/dns.c)]])>>=
int debug;				/* for ndb/dns.h */
@

<<global [[now]]([[(networking/ip/snoopy/dns.c)]])>>=
ulong now = 0;
@

<<function [[dnslog]]>>=
void
dnslog(char *fmt, ...)			/* don't log */
{
    USED(fmt);
}
@

<<function [[rrname]]>>=
/*
 *  convert an integer RR type to it's ascii name
 */
char*
rrname(int type, char *buf, int len)
{
    char *t;

    t = nil;
    if(type >= 0 && type <= Tall)
        t = rrtname[type];
    if(t==nil){
        snprint(buf, len, "%d", type);
        t = buf;
    }
    return t;
}
@

<<function [[rrfreelist]]>>=
/*
 *  free a list of resource records and any related structs
 */
void
rrfreelist(RR *rp)
{
    RR *next;

    for(; rp; rp = next){
        next = rp->next;
        rrfree(rp);
    }
}
@

<<function [[freeserverlist]]>>=
void
freeserverlist(Server *s)
{
    Server *next;

    for(; s != nil; s = next){
        next = s->next;
        free(s);
    }
}
@

<<function [[rralloc]]>>=
/*
 *  allocate a resource record of a given type
 */
RR*
rralloc(int type)
{
    RR *rp;

    rp = emalloc(sizeof(*rp));
    rp->magic = RRmagic;
    rp->pc = getcallerpc(&type);
    rp->type = type;
    setmalloctag(rp, rp->pc);
    switch(type){
    case Tsoa:
        rp->soa = emalloc(sizeof(*rp->soa));
        rp->soa->slaves = nil;
        setmalloctag(rp->soa, rp->pc);
        break;
    case Tsrv:
        rp->srv = emalloc(sizeof(*rp->srv));
        setmalloctag(rp->srv, rp->pc);
        break;
    case Tkey:
        rp->key = emalloc(sizeof(*rp->key));
        setmalloctag(rp->key, rp->pc);
        break;
    case Tcert:
        rp->cert = emalloc(sizeof(*rp->cert));
        setmalloctag(rp->cert, rp->pc);
        break;
    case Tsig:
        rp->sig = emalloc(sizeof(*rp->sig));
        setmalloctag(rp->sig, rp->pc);
        break;
    case Tnull:
        rp->null = emalloc(sizeof(*rp->null));
        setmalloctag(rp->null, rp->pc);
        break;
    }
    rp->ttl = 0;
    rp->expire = 0;
    rp->next = 0;
    return rp;
}
@

<<function [[rrfree]]>>=
/*
 *  free a resource record and any related structs
 */
void
rrfree(RR *rp)
{
    DN *dp;
    RR *nrp;
    Txt *t;

    assert(rp->magic = RRmagic);
    assert(!rp->cached);

    dp = rp->owner;
    if(dp){
        assert(dp->magic == DNmagic);
        for(nrp = dp->rr; nrp; nrp = nrp->next)
            assert(nrp != rp);	/* "rrfree of live rr" */
    }

    switch(rp->type){
    case Tsoa:
        freeserverlist(rp->soa->slaves);
        memset(rp->soa, 0, sizeof *rp->soa);	/* cause trouble */
        free(rp->soa);
        break;
    case Tsrv:
        memset(rp->srv, 0, sizeof *rp->srv);	/* cause trouble */
        free(rp->srv);
        break;
    case Tkey:
        free(rp->key->data);
        memset(rp->key, 0, sizeof *rp->key);	/* cause trouble */
        free(rp->key);
        break;
    case Tcert:
        free(rp->cert->data);
        memset(rp->cert, 0, sizeof *rp->cert);	/* cause trouble */
        free(rp->cert);
        break;
    case Tsig:
        free(rp->sig->data);
        memset(rp->sig, 0, sizeof *rp->sig);	/* cause trouble */
        free(rp->sig);
        break;
    case Tnull:
        free(rp->null->data);
        memset(rp->null, 0, sizeof *rp->null);	/* cause trouble */
        free(rp->null);
        break;
    case Ttxt:
        while(rp->txt != nil){
            t = rp->txt;
            rp->txt = t->next;
            free(t->p);
            memset(t, 0, sizeof *t);	/* cause trouble */
            free(t);
        }
        break;
    }

    rp->magic = ~rp->magic;
    memset(rp, 0, sizeof *rp);		/* cause trouble */
    free(rp);
}
@


%-------------------------------------------------------------

<<networking/ip/snoopy/dns.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"
#include "../../ndb/dns.h"

<<global [[rrtname]]>>
<<function [[rrtypestr]]>>

<<function [[fmtrr]]>>

void freealldn(void);
static Proto dnsqd, dnsan, dnsns, dnsar;

static void donext(Msg*);
<<global [[dm]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/dns.c)]])>>

<<function [[donext]]>>

<<function [[p_seprintqd]]>>

<<function [[p_seprintan]]>>

<<function [[p_seprintns]]>>

<<function [[p_seprintar]]>>

<<global [[dns]]>>

<<global [[dnsqd]]>>

<<global [[dnsan]]>>

<<global [[dnsns]]>>

<<global [[dnsar]]>>


<<function [[emalloc]]([[(networking/ip/snoopy/dns.c)]])>>

<<function [[estrdup]]([[(networking/ip/snoopy/dns.c)]])>>

<<global [[alldn]]>>

<<function [[dnlookup]]>>

<<function [[freealldn]]>>

<<global [[debug]]([[(networking/ip/snoopy/dns.c)]])>>
<<global [[now]]([[(networking/ip/snoopy/dns.c)]])>>

<<function [[dnslog]]>>

/*************************************************
 * Everything below here is copied from /sys/src/cmd/ndb/dn.c
 * without modification and can be recopied to update.
 */

<<function [[rrname]]>>

<<function [[rrfreelist]]>>

<<function [[freeserverlist]]>>

<<function [[rralloc]]>>

<<function [[rrfree]]>>
@


\subsection*{[[networking/ip/snoopy/icmp.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/icmp.c)]])>>=
struct Hdr
{	uchar	type;
    uchar	code;
    uchar	cksum[2];	/* Checksum */
    uchar	data[1];
};
@

<<enum [[_anon_ (networking/ip/snoopy/icmp.c)]]>>=
enum
{
    ICMPLEN=	4,
};
@

<<enum [[_anon_ (networking/ip/snoopy/icmp.c)2]]>>=
enum
{
    Ot,	/* type */
    Op,	/* next protocol */
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/icmp.c)]])>>=
static Field p_fields[] = 
{
    {"t",		Fnum,	Ot,	"type",	} ,
    {0}
};
@

<<enum [[_anon_ (networking/ip/snoopy/icmp.c)3]]>>=
enum
{
    EchoRep=	0,
    Unreachable=	3,
    SrcQuench=	4,
    Redirect=	5,
    EchoReq=	8,
    TimeExceed=	11,
    ParamProb=	12,
    TSreq=		13,
    TSrep=		14,
    InfoReq=	15,
    InfoRep=	16,
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/icmp.c)]])>>=
static Mux p_mux[] =
{
    {"ip",	Unreachable, },
    {"ip",	SrcQuench, },
    {"ip",	Redirect, },
    {"ip",	TimeExceed, },
    {"ip",	ParamProb, },
    {0},
};
@

<<global [[icmpmsg]]>>=
char *icmpmsg[256] =
{
[EchoRep]	"EchoRep",
[Unreachable]	"Unreachable",
[SrcQuench]	"SrcQuench",
[Redirect]	"Redirect",
[EchoReq]	"EchoReq",
[TimeExceed]	"TimeExceed",
[ParamProb]	"ParamProb",
[TSreq]		"TSreq",
[TSrep]		"TSrep",
[InfoReq]	"InfoReq",
[InfoRep]	"InfoRep",
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/icmp.c)]])>>=
static void
p_compile(Filter *f)
{
    if(f->op == '='){
        compile_cmp(icmp.name, f, p_fields);
        return;
    }
    if(strcmp(f->s, "ip") == 0){
        f->pr = p_mux->pr;
        f->subop = Op;
        return;
    }
    sysfatal("unknown icmp field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/icmp.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < ICMPLEN)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += ICMPLEN;

    switch(f->subop){
    case Ot:
        if(h->type == f->ulv)
            return 1;
        break;
    case Op:
        switch(h->type){
        case Unreachable:
        case TimeExceed:
        case SrcQuench:
        case Redirect:
        case ParamProb:
            m->ps += 4;
            return 1;
        }
    }
    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/icmp.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;
    char *tn;
    char *p = m->p;
    char *e = m->e;
    ushort cksum2, cksum;

    h = (Hdr*)m->ps;
    m->ps += ICMPLEN;
    m->pr = &dump;

    if(m->pe - m->ps < ICMPLEN)
        return -1;

    tn = icmpmsg[h->type];
    if(tn == nil)
        p = seprint(p, e, "t=%ud c=%d ck=%4.4ux", h->type,
            h->code, (ushort)NetS(h->cksum));
    else
        p = seprint(p, e, "t=%s c=%d ck=%4.4ux", tn,
            h->code, (ushort)NetS(h->cksum));
    if(Cflag){
        cksum = NetS(h->cksum);
        h->cksum[0] = 0;
        h->cksum[1] = 0;
        cksum2 = ~ptclbsum((uchar*)h, m->pe - m->ps + ICMPLEN) & 0xffff;
        if(cksum != cksum2)
            p = seprint(p,e, " !ck=%4.4ux", cksum2);
    }
    switch(h->type){
    case EchoRep:
    case EchoReq:
        m->ps += 4;
        p = seprint(p, e, " id=%ux seq=%ux",
            NetS(h->data), NetS(h->data+2));
        break;
    case TSreq:
    case TSrep:
        m->ps += 12;
        p = seprint(p, e, " orig=%ud rcv=%ux xmt=%ux",
            NetL(h->data), NetL(h->data+4),
            NetL(h->data+8));
        m->pr = nil;
        break;
    case InfoReq:
    case InfoRep:
        break;
    case Unreachable:
    case TimeExceed:
    case SrcQuench:
        m->ps += 4;
        m->pr = &ip;
        break;
    case Redirect:
        m->ps += 4;
        m->pr = &ip;
        p = seprint(p, e, "gw=%V", h->data);
        break;
    case ParamProb:
        m->ps += 4;
        m->pr = &ip;
        p = seprint(p, e, "ptr=%2.2ux", h->data[0]);
        break;
    }
    m->p = p;
    return 0;
}
@

<<global [[icmp]]>>=
Proto icmp =
{
    "icmp",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/icmp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/icmp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/icmp.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/icmp.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/icmp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/icmp.c)3]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/icmp.c)]])>>

<<global [[icmpmsg]]>>

<<function [[p_compile]]([[(networking/ip/snoopy/icmp.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/icmp.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/icmp.c)]])>>

<<global [[icmp]]>>
@


\subsection*{[[networking/ip/snoopy/tcp.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/tcp.c)]])>>=
struct Hdr
{
    uchar	sport[2];
    uchar	dport[2];
    uchar	seq[4];
    uchar	ack[4];
    uchar	flag[2];
    uchar	win[2];
    uchar	cksum[2];
    uchar	urg[2];
    uchar	opt[1];
};
@

<<struct [[PseudoHdr]]>>=
typedef struct PseudoHdr{
    uchar	src[4];
    uchar	dst[4];
    uchar	zero;
    uchar	proto;
    uchar	length[2];
    uchar	hdrdata[1580];
} PseudoHdr;
@

<<enum [[_anon_ (networking/ip/snoopy/tcp.c)]]>>=
enum
{
    TCPLEN= 20,
};
@

<<enum [[_anon_ (networking/ip/snoopy/tcp.c)2]]>>=
enum
{
    Os,
    Od,
    Osd,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/tcp.c)]])>>=
static Field p_fields[] =
{
    {"s",		Fnum,	Os,	"source port",	} ,
    {"d",		Fnum,	Od,	"dest port",	} ,
    {"a",		Fnum,	Osd,	"source/dest port",	} ,
    {"sd",		Fnum,	Osd,	"source/dest port",	} ,
    {0}
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/tcp.c)]])>>=
static Mux p_mux[] =
{
    {"dns",		53, },
    {"ninep",	17007, },	/* exportfs */
    {"ninep",	564, },		/* 9fs */
    {"ninep",	17005, },	/* ocpu */
    {"ninep",	17010, },	/* ncpu */
    {"ninep",	17013, },	/* cpu */
    {0},
};
@

<<enum [[_anon_ (networking/ip/snoopy/tcp.c)3]]>>=
enum
{
    EOLOPT		= 0,
    NOOPOPT		= 1,
    MSSOPT		= 2,
    MSS_LENGTH	= 4,		/* Mean segment size */
    WSOPT		= 3,
    WS_LENGTH	= 3,		/* Bits to scale window size by */
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/tcp.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(tcp.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Osd;
            return;
        }
    sysfatal("unknown tcp field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/tcp.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < TCPLEN)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += (NetS(h->flag)>>10) & 0x3f;

    switch(f->subop){
    case Os:
        return NetS(h->sport) == f->ulv;
    case Od:
        return NetS(h->dport) == f->ulv;
    case Osd:
        return NetS(h->sport) == f->ulv || NetS(h->dport) == f->ulv;
    }
    return 0;
}
@

<<enum [[_anon_ (networking/ip/snoopy/tcp.c)4]]>>=
enum
{
    URG		= 0x20,		/* Data marked urgent */
    ACK		= 0x10,		/* Aknowledge is valid */
    PSH		= 0x08,		/* Whole data pipe is pushed */
    RST		= 0x04,		/* Reset connection */
    SYN		= 0x02,		/* Pkt. is synchronise */
    FIN		= 0x01,		/* Start close down */
};
@

<<function [[flags]]>>=
static char*
flags(int f)
{
    static char fl[20];
    char *p;

    p = fl;
    if(f & URG)
        *p++ = 'U';
    if(f & ACK)
        *p++ = 'A';
    if(f & PSH)
        *p++ = 'P';
    if(f & RST)
        *p++ = 'R';
    if(f & SYN)
        *p++ = 'S';
    if(f & FIN)
        *p++ = 'F';
    *p = 0;
    return fl;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/tcp.c)]])>>=
static int
p_seprint(Msg *m)
{
    int dport, sport, len, flag, optlen;
    uchar *optr;
    Hdr *h;

    if(m->pe - m->ps < TCPLEN)
        return -1;
    h = (Hdr*)m->ps;

    /* get tcp header length */
    flag = NetS(h->flag);
    len = (flag>>10) & ~3;
    flag &= 0x3ff;
    m->ps += len;

    /* next protocol */
    dport = NetS(h->dport);
    sport = NetS(h->sport);
    demux(p_mux, sport, dport, m, &dump);

    m->p = seprint(m->p, m->e, "s=%d d=%d seq=%lud ack=%lud fl=%s win=%d ck=%4.4ux",
            NetS(h->sport), dport,
            (ulong)NetL(h->seq), (ulong)NetL(h->ack),
            flags(flag), NetS(h->win),
            NetS(h->cksum));

    /* tcp options */
    len -= TCPLEN;
    optr = h->opt;
    while(len > 0) {
        if(*optr == EOLOPT){
            m->p = seprint(m->p, m->e, " opt=EOL");
            break;
        }
        if(*optr == NOOPOPT) {
            m->p = seprint(m->p, m->e, " opt=NOOP");
            len--;
            optr++;
            continue;
        }
        optlen = optr[1];
        if(optlen < 2 || optlen > len)
            break;
        switch(*optr) {
        case MSSOPT:
            m->p = seprint(m->p, m->e, " opt%d=(mss %ud)",
                optlen, nhgets(optr+2));
            break;
        case WSOPT:
            m->p = seprint(m->p, m->e, " opt%d=(wscale %ud)",
                optlen, *(optr+2));
            break;
        default:
            m->p = seprint(m->p, m->e, " opt%d=(%ud %.*H)",
                optlen, *optr, optlen-2, optr+2);
        }
        len -= optlen;
        optr += optlen;
    }
    return 0;
}
@

<<global [[tcp]]>>=
Proto tcp =
{
    "tcp",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/tcp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/tcp.c)]])>>

<<struct [[PseudoHdr]]>>

<<enum [[_anon_ (networking/ip/snoopy/tcp.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/tcp.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/tcp.c)]])>>

<<global [[p_mux]]([[(networking/ip/snoopy/tcp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/tcp.c)3]]>>

<<function [[p_compile]]([[(networking/ip/snoopy/tcp.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/tcp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/tcp.c)4]]>>

<<function [[flags]]>>


<<function [[p_seprint]]([[(networking/ip/snoopy/tcp.c)]])>>

<<global [[tcp]]>>
@


\subsection*{[[networking/ip/snoopy/udp.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/udp.c)]])>>=
struct Hdr
{
    uchar	sport[2];	/* Source port */
    uchar	dport[2];	/* Destination port */
    uchar	len[2];		/* data length */
    uchar	cksum[2];	/* Checksum */
};
@

<<enum [[_anon_ (networking/ip/snoopy/udp.c)]]>>=
enum
{
    UDPLEN=	8,
};
@

<<enum [[_anon_ (networking/ip/snoopy/udp.c)2]]>>=
enum
{
    Os,
    Od,
    Osd,
    Osetport,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/udp.c)]])>>=
static Field p_fields[] = 
{
    {"s",		Fnum,	Os,	"source port",	} ,
    {"d",		Fnum,	Od,	"dest port",	} ,
    {"a",		Fnum,	Osd,	"source/dest port",	} ,
    {"sd",		Fnum,	Osd,	"source/dest port",	} ,
    {0}
};
@

<<constant [[ANYPORT]]>>=
#define ANYPORT ~0UL
@

<<global [[p_mux]]([[(networking/ip/snoopy/udp.c)]])>>=
static Mux p_mux[] =
{
    {"dns",	53, },
    {"bootp",	67, },
    {"ninep",	6346, },	/* tvs */
    {"rtp",		ANYPORT, },
    {"rtcp",	ANYPORT, },
    {0},
};
@

<<global [[defproto]]>>=
/* default next protocol, can be changed by p_filter, reset by p_compile */
static Proto	*defproto = &dump;
@

<<function [[p_compile]]([[(networking/ip/snoopy/udp.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(udp.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Osd;
            return;
        }

    sysfatal("unknown udp field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/udp.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < UDPLEN)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += UDPLEN;

    switch(f->subop){
    case Os:
        return NetS(h->sport) == f->ulv;
    case Od:
        return NetS(h->dport) == f->ulv;
    case Osd:
        if(f->ulv == ANYPORT){
            defproto = f->pr;
            return 1;
        }
        return NetS(h->sport) == f->ulv || NetS(h->dport) == f->ulv;
    }
    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/udp.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;
    int dport, sport;


    if(m->pe - m->ps < UDPLEN)
        return -1;
    h = (Hdr*)m->ps;
    m->ps += UDPLEN;

    /* next protocol */
    sport = NetS(h->sport);
    dport = NetS(h->dport);
    demux(p_mux, sport, dport, m, defproto);
    defproto = &dump;

    m->p = seprint(m->p, m->e, "s=%d d=%d ck=%4.4ux ln=%4d",
            NetS(h->sport), dport,
            NetS(h->cksum), NetS(h->len));
    return 0;
}
@

<<global [[udp]]>>=
Proto udp =
{
    "udp",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/udp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/udp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/udp.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/udp.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/udp.c)]])>>

<<constant [[ANYPORT]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/udp.c)]])>>

<<global [[defproto]]>>

<<function [[p_compile]]([[(networking/ip/snoopy/udp.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/udp.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/udp.c)]])>>

<<global [[udp]]>>
@


\subsection*{[[networking/ip/snoopy/ninep.c]]}

<<function [[p_seprint]]([[(networking/ip/snoopy/ninep.c)]])>>=
static int
p_seprint(Msg *m)
{
    Fcall f;
    char *p;

    memset(&f, 0, sizeof(f));
    f.type = 0;
    f.data = 0;	/* protection for %F */
    if(convM2S(m->ps, m->pe-m->ps, &f)){
        p = m->p;
        m->p = seprint(m->p, m->e, "%F", &f);
        while(p < m->p){
            p = strchr(p, '\n');
            if(p == nil)
                break;
            *p = '\\';
        }
    } else
        dump.seprint(m);
    m->pr = nil;
    return 0;
}
@

<<global [[ninep]]>>=
Proto ninep =
{
    "ninep",
    nil,
    nil,
    p_seprint,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/ninep.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <fcall.h>
#include "dat.h"
#include "protos.h"

<<function [[p_seprint]]([[(networking/ip/snoopy/ninep.c)]])>>

<<global [[ninep]]>>
@


\subsection*{[[networking/ip/snoopy/aoe.c]]}

<<enum [[_anon_ (networking/ip/snoopy/aoe.c)]]>>=
enum{
    Hsize	= 10,
};
@

<<enum [[_anon_ (networking/ip/snoopy/aoe.c)2]]>>=
enum{
    Omajor,
    Ominor,
    Ocmd,
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/aoe.c)]])>>=
static Mux p_mux[] = {
    {"aoeata",	0},
    {"aoecmd",	1},
    {"aoemask",	2},
    {"aoerr",	3},
    {0},
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/aoe.c)]])>>=
static Field p_fields[] =
{
    {"shelf",	Fnum,	Ominor,		"shelf", },
    {"slot",	Fnum,	Omajor,		"slot",	},
    {"cmd",		Fnum,	Ocmd,		"cmd",	},
    {0}
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/aoe.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(aoe.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ocmd;
            return;
        }
    sysfatal("unknown aoe field: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/aoe.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    switch(f->subop){
    case Omajor:
        return NetS(h->major) == f->ulv;
    case Ominor:
        return h->minor == f->ulv;
    case Ocmd:
        return h->cmd == f->ulv;
    }
    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/aoe.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    demux(p_mux, h->cmd, h->cmd, m, &dump);

    m->p = seprint(m->p, m->e, "ver=%d flag=%4b err=%d %d.%d cmd=%ux tag=%ux",
        h->verflags >> 4, h->verflags & 0xf, h->error, NetS(h->major),
        h->minor, h->cmd, NetL(h->tag));
    return 0;
}
@

<<global [[aoe]]>>=
Proto aoe =
{
    "aoe",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/aoe.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct{
    uchar	verflags;
    uchar	error;
    uchar	major[2];
    uchar	minor;
    uchar	cmd;
    uchar	tag[4];
}Hdr;

<<enum [[_anon_ (networking/ip/snoopy/aoe.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/aoe.c)2]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/aoe.c)]])>>

<<global [[p_fields]]([[(networking/ip/snoopy/aoe.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/aoe.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/aoe.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/aoe.c)]])>>

<<global [[aoe]]>>
@


\subsection*{[[networking/ip/snoopy/aoeata.c]]}

<<enum [[_anon_ (networking/ip/snoopy/aoeata.c)]]>>=
enum{
    Hsize	= 10,
};
@

<<enum [[_anon_ (networking/ip/snoopy/aoeata.c)2]]>>=
enum{
    Oaflag,
    Ocmd,
    Ofeat,
    Osectors,
    Olba,

    Ostat,
    Oerr,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/aoeata.c)]])>>=
static Field p_fields[] =
{
    {"aflag",	Fnum,	Oaflag,		"aflag",		},
    {"cmd",		Fnum,	Ocmd,		"command register",	},
    {"feat",	Fnum,	Ofeat,		"features",		},
    {"sectors",	Fnum,	Osectors,	"number of sectors",	},
    {"lba",		Fnum,	Olba,		"lba",			},
    {"stat",	Fnum,	Ostat,		"status",		},
    {"err",		Fnum,	Oerr,		"error",		},
    {0}
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/aoeata.c)]])>>=
static void
p_compile(Filter *f)
{
    if(f->op == '='){
        compile_cmp(aoeata.name, f, p_fields);
        return;
    }
    sysfatal("unknown aoeata field: %s", f->s);
}
@

<<function [[llba]]>>=
uvlong
llba(uchar *c)
{
    uvlong l;

    l = c[0];
    l |= c[1]<<8;
    l |= c[2]<<16;
    l |= c[3]<<24;
    l |= (uvlong)c[4]<<32;
    l |= (uvlong)c[5]<<40;
    return l;
}
@
% >> >> >> >> >> >>

<<function [[p_filter]]([[(networking/ip/snoopy/aoeata.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    switch(f->subop){
    case Oaflag:
        return h->aflag == f->ulv;
    case Ocmd:
        return h->cmd == f->ulv;
    case Ofeat:
        return h->feat == f->ulv;
    case Osectors:
        return h->sectors == f->ulv;
    case Olba:
        return llba(h->lba) == f->vlv;

    /* this is wrong, but we don't have access to the direction here */
    case Ostat:
        return h->cmd == f->ulv;
    case Oerr:
        return h->feat == f->ulv;
    }
    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/aoeata.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    /* no next protocol */
    m->pr = nil;

    m->p = seprint(m->p, m->e, "aflag=%ux errfeat=%ux sectors=%ux cmdstat=%ux lba=%lld",
        h->aflag, h->feat, h->sectors, h->cmd, llba(h->lba));
    return 0;
}
@

<<global [[aoeata]]>>=
Proto aoeata =
{
    "aoeata",
    p_compile,
    p_filter,
    p_seprint,
    nil,
    nil,
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/aoeata.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct{
    uchar	aflag;
    uchar	feat;
    uchar	sectors;
    uchar	cmd;
    uchar	lba[6];
}Hdr;

<<enum [[_anon_ (networking/ip/snoopy/aoeata.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/aoeata.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/aoeata.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/aoeata.c)]])>>

<<function [[llba]]>>

<<function [[p_filter]]([[(networking/ip/snoopy/aoeata.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/aoeata.c)]])>>

<<global [[aoeata]]>>
@


\subsection*{[[networking/ip/snoopy/aoecmd.c]]}

<<enum [[_anon_ (networking/ip/snoopy/aoecmd.c)]]>>=
enum{
    Hsize	= 8,
};
@

<<enum [[_anon_ (networking/ip/snoopy/aoecmd.c)2]]>>=
enum{
    Ocmd,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/aoecmd.c)]])>>=
static Field p_fields[] =
{
    {"cmd",		Fnum,	Ocmd,		"cmd",	},
    {0}
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/aoecmd.c)]])>>=
static void
p_compile(Filter *f)
{
    if(f->op == '='){
        compile_cmp(aoecmd.name, f, p_fields);
        return;
    }
    sysfatal("unknown aoecmd field: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/aoecmd.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    switch(f->subop){
    case Ocmd:
        return (h->ccmd & 0xf) == f->ulv;
    }
    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/aoecmd.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    /* no next protocol */
    m->pr = nil;

    m->p = seprint(m->p, m->e, "bc=%d fw=%.4x sc=%d ver=%d ccmd=%d len=%d cfg=",
        NetS(h->bc), NetS(h->fw), h->sc, h->ccmd >> 4, h->ccmd & 0xf,
        NetS(h->len));
    m->p = seprint(m->p, m->e, "%.*s", NetS(h->len), (char*)m->ps);
    return 0;
}
@

<<global [[aoecmd]]>>=
Proto aoecmd =
{
    "aoecmd",
    p_compile,
    p_filter,
    p_seprint,
    nil,
    nil,
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/aoecmd.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct{
    uchar	bc[2];
    uchar	fw[2];
    uchar	sc;
    uchar	ccmd;
    uchar	len[2];
}Hdr;

<<enum [[_anon_ (networking/ip/snoopy/aoecmd.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/aoecmd.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/aoecmd.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/aoecmd.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/aoecmd.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/aoecmd.c)]])>>

<<global [[aoecmd]]>>
@


\subsection*{[[networking/ip/snoopy/aoemask.c]]}

<<enum [[_anon_ (networking/ip/snoopy/aoemask.c)]]>>=
enum {
    Ocmd,
    Oerr,
    Ocnt,

    Hsize	= 4,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/aoemask.c)]])>>=
static Field p_fields[] =
{
    { "cmd",	Fnum,	Ocmd,	"command", },
    { "err",	Fnum,	Oerr,	"error", },
    { "cnt",	Fnum,	Ocnt,	"count", },
    nil
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/aoemask.c)]])>>=
static Mux p_mux[] = {
    { "aoemd",	0 },
    { "aoemd",	1 },
    nil
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/aoemask.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(aoerr.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ocmd;
            return;
        }
    sysfatal("unknown aoemask field: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/aoemask.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    switch(f->subop){
    case Ocmd:
        return h->cmd == f->ulv;
    case Oerr:
        return h->err == f->ulv;
    case Ocnt:
        return h->cnt == f->ulv;
    }
    return 0;
}
@

<<global [[ctab]]>>=
static char *ctab[] = {
    "read",
    "edit",
};
@

<<global [[etab]]>>=
static char *etab[] = {
    "",
    "bad",
    "full",
};
@

<<function [[p_seprint]]([[(networking/ip/snoopy/aoemask.c)]])>>=
static int
p_seprint(Msg *m)
{
    char *s, *t;
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    demux(p_mux, h->cmd, h->cmd, m, &dump);

    s = "unk";
    if(h->cmd < nelem(ctab))
        s = ctab[h->cmd];
    t = "unk";
    if(h->err < nelem(etab))
        s = etab[h->err];
    m->p = seprint(m->p, m->e, "cmd=%d %s err=%d %s cnt=%d\n",
        h->cmd, s, h->err, t, h->cnt);
    return 0;
}
@

<<global [[aoemask]]>>=
Proto aoemask = {
    "aoemask",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/aoemask.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct {
    uchar	res;
    uchar	cmd;
    uchar	err;
    uchar	cnt;
} Hdr;

<<enum [[_anon_ (networking/ip/snoopy/aoemask.c)]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/aoemask.c)]])>>

<<global [[p_mux]]([[(networking/ip/snoopy/aoemask.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/aoemask.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/aoemask.c)]])>>

<<global [[ctab]]>>

<<global [[etab]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/aoemask.c)]])>>

<<global [[aoemask]]>>
@


\subsection*{[[networking/ip/snoopy/aoemd.c]]}

<<enum [[_anon_ (networking/ip/snoopy/aoemd.c)]]>>=
enum {
    Ocmd,
    Oea,

    Hsize	= 8,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/aoemd.c)]])>>=
static Field p_fields[] = {
    {"cmd",	Fnum,	Ocmd,	"command",	},
    {"ea",	Fnum,	Oea,	"ethernet addr", },
    nil
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/aoemd.c)]])>>=
static void
p_compile(Filter *f)
{
    if(f->op == '='){
        compile_cmp(aoemd.name, f, p_fields);
        return;
    }
    sysfatal("unknown aoemd field: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/aoemd.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    uchar buf[6];
    int i;
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    switch(f->subop){
    case Ocmd:
        return h->cmd == f->ulv;
    case Oea:
        for(i = 0; i < 6; i++)
            buf[i] = f->ulv >> ((5 - i)*8);
        return memcmp(buf, h->ea, 6) == 0;
    }
    return 0;
}
@

<<global [[ctab]]([[(networking/ip/snoopy/aoemd.c)]])>>=
static char *ctab[] = {
    "  ",
    " +",
    " -",
};
@

<<function [[p_seprint]]([[(networking/ip/snoopy/aoemd.c)]])>>=
static int
p_seprint(Msg *m)
{
    char *s;
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    /* no next protocol */
    m->pr = nil;

    s = "unk";
    if(h->cmd < nelem(ctab))
        s = ctab[h->cmd];
    m->p = seprint(m->p, m->e, "cmd=%d%s ea=%E\n", h->cmd, s, h->ea);
    return 0;
}
@

<<global [[aoemd]]>>=
Proto aoemd = {
    "aoemd",
    p_compile,
    p_filter,
    p_seprint,
    nil,
    nil,
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/aoemd.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct {
    uchar	res;
    uchar	cmd;
    uchar	ea[6];
} Hdr;

<<enum [[_anon_ (networking/ip/snoopy/aoemd.c)]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/aoemd.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/aoemd.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/aoemd.c)]])>>

<<global [[ctab]]([[(networking/ip/snoopy/aoemd.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/aoemd.c)]])>>

<<global [[aoemd]]>>
@


\subsection*{[[networking/ip/snoopy/aoerr.c]]}

<<enum [[_anon_ (networking/ip/snoopy/aoerr.c)]]>>=
enum {
    Ocmd,
    Onea,
    Oea,

    Hsize	= 2,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/aoerr.c)]])>>=
static Field p_fields[] = {
    {"cmd",	Fnum,	Ocmd,	"command",	},
    {"nea",	Fnum,	Onea,	"ea count",	},
    {"ea",	Fnum,	Onea,	"ethernet addr", },
    nil
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/aoerr.c)]])>>=
static void
p_compile(Filter *f)
{
    if(f->op == '='){
        compile_cmp(aoerr.name, f, p_fields);
        return;
    }
    sysfatal("unknown aoerr field: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/aoerr.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    uchar buf[6];
    int i;
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    switch(f->subop){
    case Ocmd:
        return h->cmd == f->ulv;
    case Onea:
        return h->nea == f->ulv;
    case Oea:
        if(m->pe - m->ps < 6*h->nea)
            return 0;
        for(i = 0; i < 6; i++)
            buf[i] = f->ulv >> ((5 - i)*8);
        for(i = 0; i < h->nea; i++)
            if(memcmp(m->ps + 6*i, buf, 6) == 0)
                return 1;
        return 0;
    }
    return 0;
}
@

<<global [[ctab]]([[(networking/ip/snoopy/aoerr.c)]])>>=
static char *ctab[] = {
    "read",
    "write",
    "force",
};
@

<<function [[p_seprint]]([[(networking/ip/snoopy/aoerr.c)]])>>=
static int
p_seprint(Msg *m)
{
    char *s;
    int i;
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    /* no next protocol */
    m->pr = nil;

    s = "unk";
    if(h->cmd < nelem(ctab))
        s = ctab[h->cmd];
    m->p = seprint(m->p, m->e, "cmd=%d %s nea=%d", h->cmd, s, h->nea);
    for(i = 0;; i++){
        if(h->nea < i)
            break;
        if(i == 3){
            m->p = seprint(m->p, m->e, " ...");
            break;
        }
        if(m->pe - m->ps < 6*i){
            m->p = seprint(m->p, m->e, " *short*");
            break;
        }
        m->p = seprint(m->p, m->e, " %E", m->pe + 6*i);
    }
    m->p = seprint(m->p, m->e, "\n");
    return 0;
}
@

<<global [[aoerr]]>>=
Proto aoerr = {
    "aoerr",
    p_compile,
    p_filter,
    p_seprint,
    nil,
    nil,
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/aoerr.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct {
    uchar	cmd;
    uchar	nea;
} Hdr;

<<enum [[_anon_ (networking/ip/snoopy/aoerr.c)]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/aoerr.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/aoerr.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/aoerr.c)]])>>

<<global [[ctab]]([[(networking/ip/snoopy/aoerr.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/aoerr.c)]])>>

<<global [[aoerr]]>>
@


\subsection*{[[networking/ip/snoopy/bootp.c]]}

<<enum [[_anon_ (networking/ip/snoopy/bootp.c)]]>>=
enum
{
    OfferTimeout=	60,		/* when an offer times out */
    MaxLease=	60*60,		/* longest lease for dynamic binding */
    MinLease=	15*60,		/* shortest lease for dynamic binding */
    StaticLease=	30*60,		/* lease for static binding */

    IPUDPHDRSIZE=	28,		/* size of an IP plus UDP header */
    MINSUPPORTED=	576,		/* biggest IP message the client must support */

    /* lengths of some bootp fields */
    Maxhwlen=	16,
    Maxfilelen=	128,
    Maxoptlen=	312-4,

    /* bootp types */
    Bootrequest=	1,
    Bootreply= 	2,

    /* bootp flags */
    Fbroadcast=	1<<15,
};
@

<<struct [[Hdr]]([[(networking/ip/snoopy/bootp.c)]])>>=
struct Hdr
{
    uchar	op;			/* opcode */
    uchar	htype;			/* hardware type */
    uchar	hlen;			/* hardware address len */
    uchar	hops;			/* hops */
    uchar	xid[4];			/* a random number */
    uchar	secs[2];		/* elapsed since client started booting */
    uchar	flags[2];
    uchar	ciaddr[IPv4addrlen];	/* client IP address (client tells server) */
    uchar	yiaddr[IPv4addrlen];	/* client IP address (server tells client) */
    uchar	siaddr[IPv4addrlen];	/* server IP address */
    uchar	giaddr[IPv4addrlen];	/* gateway IP address */
    uchar	chaddr[Maxhwlen];	/* client hardware address */
    char	sname[64];		/* server host name (optional) */
    char	file[Maxfilelen];	/* boot file name */
    uchar	optmagic[4];
    uchar	optdata[Maxoptlen];
};
@

<<enum [[_anon_ (networking/ip/snoopy/bootp.c)2]]>>=
enum
{
    Oca,
    Osa,
    Ot,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/bootp.c)]])>>=
static Field p_fields[] = 
{
    {"ca",		Fv4ip,	Oca,	"client IP addr",	} ,
    {"sa",		Fv4ip,	Osa,	"server IP addr",	} ,
    {0}
};
@

<<constant [[plan9opt]]>>=
#define plan9opt ((ulong)(('p'<<24) | ('9'<<16) | (' '<<8) | ' '))
@

<<constant [[genericopt]]>>=
#define genericopt (0x63825363UL)
@

<<global [[p_mux]]([[(networking/ip/snoopy/bootp.c)]])>>=
static Mux p_mux[] =
{
    {"dhcp", 	genericopt,},
    {"plan9bootp",	plan9opt,},
    {"dump",	0,},
    {0}
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/bootp.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(bootp.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
    sysfatal("unknown bootp field: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/bootp.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    h = (Hdr*)m->ps;

    if(m->pe < (uchar*)h->sname)
        return 0;
    m->ps = h->optdata;

    switch(f->subop){
    case Oca:
        return NetL(h->ciaddr) == f->ulv || NetL(h->yiaddr) == f->ulv;
    case Osa:
        return NetL(h->siaddr) == f->ulv;
    case Ot:
        return NetL(h->optmagic) == f->ulv;
    }
    return 0;
}
@

<<function [[op]]>>=
static char*
op(int i)
{
    static char x[20];

    switch(i){
    case Bootrequest:
        return "Req";
    case Bootreply:
        return "Rep";
    default:
        sprint(x, "%d", i);
        return x;
    }
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/bootp.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;
    ulong x;

    h = (Hdr*)m->ps;

    if(m->pe < (uchar*)h->sname)
        return -1;

    /* point past data */
    m->ps = h->optdata;

    /* next protocol */
    m->pr = nil;
    if(m->pe >= (uchar*)h->optdata){
        x = NetL(h->optmagic);
        demux(p_mux, x, x, m, &dump);
    }

    m->p = seprint(m->p, m->e, "t=%s ht=%d hl=%d hp=%d xid=%ux sec=%d fl=%4.4ux ca=%V ya=%V sa=%V ga=%V cha=%E magic=%lux",
        op(h->op), h->htype, h->hlen, h->hops,
        NetL(h->xid), NetS(h->secs), NetS(h->flags),
        h->ciaddr, h->yiaddr, h->siaddr, h->giaddr, h->chaddr,
        (ulong)NetL(h->optmagic));
    if(m->pe > (uchar*)h->sname && *h->sname)
        m->p = seprint(m->p, m->e, " snam=%s", h->sname);
    if(m->pe > (uchar*)h->file && *h->file)
        m->p = seprint(m->p, m->e, " file=%s", h->file);
    return 0;
}
@

<<global [[bootp]]>>=
Proto bootp =
{
    "bootp",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%#.8lux",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/bootp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

<<enum [[_anon_ (networking/ip/snoopy/bootp.c)]]>>

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/bootp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/bootp.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/bootp.c)]])>>

<<constant [[plan9opt]]>>
<<constant [[genericopt]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/bootp.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/bootp.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/bootp.c)]])>>

<<function [[op]]>>


<<function [[p_seprint]]([[(networking/ip/snoopy/bootp.c)]])>>

<<global [[bootp]]>>
@


\subsection*{[[networking/ip/snoopy/cec.c]]}

<<enum [[_anon_ (networking/ip/snoopy/cec.c)]]>>=
enum{
    Hsize	= 4,
};
@

<<enum [[_anon_ (networking/ip/snoopy/cec.c)2]]>>=
enum{
    Otype,
    Oconn,
    Oseq,
    Olen,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/cec.c)]])>>=
static Field p_fields[] =
{
    {"type",	Fnum,	Otype,		"type",	},
    {"conn",	Fnum,	Oconn,		"conn",	},
    {"seq",		Fnum,	Oseq,		"seq",	},
    {"len",		Fnum,	Olen,		"len",	},
    {0}
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/cec.c)]])>>=
static void
p_compile(Filter *f)
{
    if(f->op == '='){
        compile_cmp(aoe.name, f, p_fields);
        return;
    }
    sysfatal("unknown aoe field: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/cec.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    switch(f->subop){
    case Otype:
        return h->type == f->ulv;
    case Oconn:
        return h->conn = f->ulv;
    case Oseq:
        return h->seq = f->ulv;
    case Olen:
        return h->len = f->ulv;
    }
    return 0;
}
@

<<global [[ttab]]>>=
static char* ttab[] = {
    "Tinita",
    "Tinitb",
    "Tinitc",
    "Tdata",
    "Tack",
    "Tdiscover",
    "Toffer",
    "Treset",
};
@

<<function [[p_seprint]]([[(networking/ip/snoopy/cec.c)]])>>=
static int
p_seprint(Msg *m)
{
    char *s, *p, buf[4];
    Hdr *h;

    if(m->pe - m->ps < Hsize)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += Hsize;

    m->pr = nil;

    if(h->type < nelem(ttab))
        s = ttab[h->type];
    else{
        snprint(buf, sizeof buf, "%d", h->type);
        s = buf;
    }

    p = (char*)m->ps;
    m->p = seprint(m->p, m->e, "type=%s conn=%d seq=%d len=%d %.*s",
        s, h->conn, h->seq, h->len,
        (int)utfnlen(p, h->len), p);
    return 0;
}
@

<<global [[cec]]>>=
Proto cec =
{
    "cec",
    p_compile,
    p_filter,
    p_seprint,
    nil,
    nil,
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/cec.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct{
    uchar	type;
    uchar	conn;
    uchar	seq;
    uchar	len;
}Hdr;

<<enum [[_anon_ (networking/ip/snoopy/cec.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/cec.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/cec.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/cec.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/cec.c)]])>>

<<global [[ttab]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/cec.c)]])>>

<<global [[cec]]>>
@


\subsection*{[[networking/ip/snoopy/dhcp.c]]}

<<enum [[_anon_ (networking/ip/snoopy/dhcp.c)]]>>=
enum
{
    Maxoptlen=	312-4,

    /* dhcp types */
    Discover=	1,
    Offer=		2,
    Request=	3,
    Decline=	4,
    Ack=		5,
    Nak=		6,
    Release=	7,
    Inform=		8,

    /* bootp option types */
    OBend=			255,
    OBpad=			0,
    OBmask=			1,
    OBtimeoff=		2,
    OBrouter=		3,
    OBtimeserver=		4,
    OBnameserver=		5,
    OBdnserver=		6,
    OBlogserver=		7,
    OBcookieserver=		8,
    OBlprserver=		9,
    OBimpressserver=	10,
    OBrlserver=		11,
    OBhostname=		12,	/* 0xc0 */
    OBbflen=		13,
    OBdumpfile=		14,
    OBdomainname=		15,
    OBswapserver=		16,	/* 0x10 */
    OBrootpath=		17,
    OBextpath=		18,
    OBipforward=		19,
    OBnonlocal=		20,
    OBpolicyfilter=		21,
    OBmaxdatagram=		22,
    OBttl=			23,
    OBpathtimeout=		24,
    OBpathplateau=		25,
    OBmtu=			26,
    OBsubnetslocal=		27,
    OBbaddr=		28,
    OBdiscovermask=		29,
    OBsupplymask=		30,
    OBdiscoverrouter=	31,
    OBrsserver=		32,	/* 0x20 */
    OBstaticroutes=		33,
    OBtrailerencap=		34,
    OBarptimeout=		35,
    OBetherencap=		36,
    OBtcpttl=		37,
    OBtcpka=		38,
    OBtcpkag=		39,
    OBnisdomain=		40,
    OBniserver=		41,
    OBntpserver=		42,
    OBvendorinfo=		43,	/* 0x2b */
    OBnetbiosns=		44,
    OBnetbiosdds=		45,
    OBnetbiostype=		46,
    OBnetbiosscope=		47,
    OBxfontserver=		48,	/* 0x30 */
    OBxdispmanager=		49,
    OBnisplusdomain=	64,	/* 0x40 */
    OBnisplusserver=	65,
    OBhomeagent=		68,
    OBsmtpserver=		69,
    OBpop3server=		70,
    OBnntpserver=		71,
    OBwwwserver=		72,
    OBfingerserver=		73,
    OBircserver=		74,
    OBstserver=		75,
    OBstdaserver=		76,

    /* dhcp options */
    ODipaddr=		50,	/* 0x32 */
    ODlease=		51,
    ODoverload=		52,
    ODtype=			53,	/* 0x35 */
    ODserverid=		54,	/* 0x36 */
    ODparams=		55,	/* 0x37 */
    ODmessage=		56,
    ODmaxmsg=		57,
    ODrenewaltime=		58,
    ODrebindingtime=	59,
    ODvendorclass=		60,
    ODclientid=		61,	/* 0x3d */
    ODtftpserver=		66,
    ODbootfile=		67,

    /* plan9 vendor info options */
    OP9fsv4=		128,	/* plan9 file servers */
    OP9authv4=		129,	/* plan9 auth servers */
};
@

<<function [[hex]]>>=
/*
 *  convert a byte array to hex
 */
static char
hex(int x)
{
    if(x < 10)
        return x + '0';
    return x - 10 + 'a';
}
@

<<function [[phex]]>>=
static char*
phex(char *p, char *e, char *tag, uchar *o, int n)
{
    p = seprint(p, e, "%s=", tag);

    for(; p+2 < e && n > 0; n--){
        *p++ = hex(*o >> 4);
        *p++ = hex(*o & 0xf);
        o++;
    }
    return p;
}
@

<<function [[pstring]]>>=
static char*
pstring(char *p, char *e, char *tag, uchar *o, int n)
{
    char msg[256];

    if(n > sizeof msg - 1)
        n = sizeof msg - 1;
    memmove(msg, o, n);
    msg[n] = 0;
    return seprint(p, e, "%s=%s", tag, msg);
}
@

<<function [[pint]]>>=
static char*
pint(char *p, char *e, char *tag, uchar *o, int n)
{
    int x;

    x = *(char*)o++;
    for(; n > 1; n--)
        x = x<<8 | *o++;
    return seprint(p, e, "%s=%d", tag, x);
}
@

<<function [[puint]]>>=
static char*
puint(char *p, char *e, char *tag, uchar *o, int n)
{
    uint x;

    x = *o++;
    for(; n > 1; n--)
        x = x<<8 | *o++;
    return seprint(p, e, "%s=%ud", tag, x);
}
@

<<function [[pserver]]>>=
static char*
pserver(char *p, char *e, char *tag, uchar *o, int n)
{
    p = seprint(p, e, "%s=(", tag);
    while(n >= 4){
        p = seprint(p, e, " %V", o);
        n -= 4;
        o += 4;
    }
    p = seprint(p, e, ")");
    return p;
}
@

<<global [[dhcptype]]>>=
static char *dhcptype[256] =
{
[Discover]	"Discover",
[Offer]		"Offer",
[Request]	"Request",
[Decline]	"Decline",
[Ack]		"Ack",
[Nak]		"Nak",
[Release]	"Release",
[Inform]	"Inform",
};
@

<<function [[ptype]]>>=
static char*
ptype(char *p, char *e, uchar val)
{
    char *x;

    x = dhcptype[val];
    if(x != nil)
        return seprint(p, e, "t=%s", x);
    else
        return seprint(p, e, "t=%d", val);
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/dhcp.c)]])>>=
static int
p_seprint(Msg *m)
{
    int i, n, code;
    uchar *o, *ps;
    char *p, *e;
    char msg[64];

    /* no next proto */
    m->pr = nil;

    p = m->p;
    e = m->e;
    ps = m->ps;

    while(ps < m->pe){
        code = *ps++;
        if(code == 255)
            break;
        if(code == 0)
            continue;

        /* ignore anything that's too long */
        n = *ps++;
        o = ps;
        ps += n;
        if(ps > m->pe)
            break;

        switch(code){
        case ODipaddr:	/* requested ip address */
            p = pserver(p, e, "ipaddr", o, n);
            break;
        case ODlease:	/* requested lease time */
            p = pint(p, e, "lease", o, n);
            break;
        case ODtype:
            p = ptype(p, e, *o);
            break;
        case ODserverid:
            p = pserver(p, e, "serverid", o, n);
            break;
        case ODmessage:
            p = pstring(p, e, "message", o, n);
            break;
        case ODmaxmsg:
            p = puint(p, e, "maxmsg", o, n);
            break;
        case ODclientid:
            p = phex(p, e, "clientid", o, n);
            break;
        case ODparams:
            p = seprint(p, e, " requested=(");
            for(i = 0; i < n; i++){
                if(i != 0)
                    p = seprint(p, e, " ");
                p = seprint(p, e, "%ud", o[i]);
            }
            p = seprint(p, e, ")");
            break;
        case ODvendorclass:
            p = pstring(p, e, "vendorclass", o, n);
            break;
        case OBmask:
            p = pserver(p, e, "mask", o, n);
            break;
        case OBtimeoff:
            p = pint(p, e, "timeoff", o, n);
            break;
        case OBrouter:
            p = pserver(p, e, "router", o, n);
            break;
        case OBtimeserver:
            p = pserver(p, e, "timesrv", o, n);
            break;
        case OBnameserver:
            p = pserver(p, e, "namesrv", o, n);
            break;
        case OBdnserver:
            p = pserver(p, e, "dnssrv", o, n);
            break;
        case OBlogserver:
            p = pserver(p, e, "logsrv", o, n);
            break;
        case OBcookieserver:
            p = pserver(p, e, "cookiesrv", o, n);
            break;
        case OBlprserver:
            p = pserver(p, e, "lprsrv", o, n);
            break;
        case OBimpressserver:
            p = pserver(p, e, "impresssrv", o, n);
            break;
        case OBrlserver:
            p = pserver(p, e, "rlsrv", o, n);
            break;
        case OBhostname:
            p = pstring(p, e, "hostname", o, n);
            break;
        case OBbflen:
            break;
        case OBdumpfile:
            p = pstring(p, e, "dumpfile", o, n);
            break;
        case OBdomainname:
            p = pstring(p, e, "domname", o, n);
            break;
        case OBswapserver:
            p = pserver(p, e, "swapsrv", o, n);
            break;
        case OBrootpath:
            p = pstring(p, e, "rootpath", o, n);
            break;
        case OBextpath:
            p = pstring(p, e, "extpath", o, n);
            break;
        case OBipforward:
            p = phex(p, e, "ipforward", o, n);
            break;
        case OBnonlocal:
            p = phex(p, e, "nonlocal", o, n);
            break;
        case OBpolicyfilter:
            p = phex(p, e, "policyfilter", o, n);
            break;
        case OBmaxdatagram:
            p = phex(p, e, "maxdatagram", o, n);
            break;
        case OBttl:
            p = puint(p, e, "ttl", o, n);
            break;
        case OBpathtimeout:
            p = puint(p, e, "pathtimeout", o, n);
            break;
        case OBpathplateau:
            p = phex(p, e, "pathplateau", o, n);
            break;
        case OBmtu:
            p = puint(p, e, "mtu", o, n);
            break;
        case OBsubnetslocal:
            p = pserver(p, e, "subnet", o, n);
            break;
        case OBbaddr:
            p = pserver(p, e, "baddr", o, n);
            break;
        case OBdiscovermask:
            p = pserver(p, e, "discovermsak", o, n);
            break;
        case OBsupplymask:
            p = pserver(p, e, "rousupplymaskter", o, n);
            break;
        case OBdiscoverrouter:
            p = pserver(p, e, "discoverrouter", o, n);
            break;
        case OBrsserver:
            p = pserver(p, e, "rsrouter", o, n);
            break;
        case OBstaticroutes:
            p = phex(p, e, "staticroutes", o, n);
            break;
        case OBtrailerencap:
            p = phex(p, e, "trailerencap", o, n);
            break;
        case OBarptimeout:
            p = puint(p, e, "arptimeout", o, n);
            break;
        case OBetherencap:
            p = phex(p, e, "etherencap", o, n);
            break;
        case OBtcpttl:
            p = puint(p, e, "tcpttl", o, n);
            break;
        case OBtcpka:
            p = puint(p, e, "tcpka", o, n);
            break;
        case OBtcpkag:
            p = phex(p, e, "tcpkag", o, n);
            break;
        case OBnisdomain:
            p = pstring(p, e, "nisdomain", o, n);
            break;
        case OBniserver:
            p = pserver(p, e, "nisrv", o, n);
            break;
        case OBntpserver:
            p = pserver(p, e, "ntpsrv", o, n);
            break;
        case OBvendorinfo:
            p = phex(p, e, "vendorinfo", o, n);
            break;
        case OBnetbiosns:
            p = pserver(p, e, "biosns", o, n);
            break;
        case OBnetbiosdds:
            p = phex(p, e, "biosdds", o, n);
            break;
        case OBnetbiostype:
            p = phex(p, e, "biostype", o, n);
            break;
        case OBnetbiosscope:
            p = phex(p, e, "biosscope", o, n);
            break;
        case OBxfontserver:
            p = pserver(p, e, "fontsrv", o, n);
            break;
        case OBxdispmanager:
            p = pserver(p, e, "xdispmgr", o, n);
            break;
        case OBnisplusdomain:
            p = pstring(p, e, "nisplusdomain", o, n);
            break;
        case OBnisplusserver:
            p = pserver(p, e, "nisplussrv", o, n);
            break;
        case OBhomeagent:
            p = pserver(p, e, "homeagent", o, n);
            break;
        case OBsmtpserver:
            p = pserver(p, e, "smtpsrv", o, n);
            break;
        case OBpop3server:
            p = pserver(p, e, "pop3srv", o, n);
            break;
        case OBnntpserver:
            p = pserver(p, e, "ntpsrv", o, n);
            break;
        case OBwwwserver:
            p = pserver(p, e, "wwwsrv", o, n);
            break;
        case OBfingerserver:
            p = pserver(p, e, "fingersrv", o, n);
            break;
        case OBircserver:
            p = pserver(p, e, "ircsrv", o, n);
            break;
        case OBstserver:
            p = pserver(p, e, "stsrv", o, n);
            break;
        case OBstdaserver:
            p = pserver(p, e, "stdasrv", o, n);
            break;
        case OBend:
            goto out;
        default:
            snprint(msg, sizeof msg, " T%ud", code);
            p = phex(p, e, msg, o, n);
            break;
        }
        if(*ps != OBend)
            p = seprint(p, e, " ");
    }
out:
    m->p = p;
    m->ps = ps;
    return 0;
}
@

<<global [[dhcp]]>>=
Proto dhcp =
{
    "dhcp",
    nil,
    nil,
    p_seprint,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/dhcp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

<<enum [[_anon_ (networking/ip/snoopy/dhcp.c)]]>>

<<function [[hex]]>>
<<function [[phex]]>>

<<function [[pstring]]>>

<<function [[pint]]>>

<<function [[puint]]>>

<<function [[pserver]]>>

<<global [[dhcptype]]>>


<<function [[ptype]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/dhcp.c)]])>>

<<global [[dhcp]]>>
@


\subsection*{[[networking/ip/snoopy/dump.c]]}

<<function [[p_compile]]([[(networking/ip/snoopy/dump.c)]])>>=
static void
p_compile(Filter *)
{
}
@

<<global [[tohex]]>>=
static char tohex[16] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    'a', 'b', 'c', 'd', 'e', 'f'
};
@

<<function [[p_seprint]]([[(networking/ip/snoopy/dump.c)]])>>=
static int
p_seprint(Msg *m)
{
    int c, i, n, isstring;
    uchar *ps = m->ps;
    char *p = m->p;
    char *e = m->e;

    n = m->pe - ps;
    if(n > Nflag)
        n = Nflag;

    isstring = 1;
    for(i = 0; i < n; i++){
        c = ps[i];
        if(!isprint(c) && !isspace(c)){
            isstring = 0;
            break;
        }
    }

    if(isstring){
        for(i = 0; i < n && p+1<e; i++){
            c = ps[i];
            switch(c){
            case '\t':
                *p++ = '\\';
                *p++ = 't';
                break;
            case '\r':
                *p++ = '\\';
                *p++ = 'r';
                break;
            case '\n':
                *p++ = '\\';
                *p++ = 'n';
                break;
            default:
                *p++ = c;
            }
        }
    } else {
        for(i = 0; i < n && p+1<e; i++){
            c = ps[i];
            *p++ = tohex[c>>4];
            *p++ = tohex[c&0xf]; 
        }
    }

    m->pr = nil;
    m->p = p;
    m->ps = ps;

    return 0;
}
@

<<global [[dump]]>>=
Proto dump =
{
    "dump",
    p_compile,
    nil,
    p_seprint,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/dump.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <ctype.h>
#include "dat.h"
#include "protos.h"

<<function [[p_compile]]([[(networking/ip/snoopy/dump.c)]])>>

<<global [[tohex]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/dump.c)]])>>

<<global [[dump]]>>
@


\subsection*{[[networking/ip/snoopy/eap.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/eap.c)]])>>=
struct Hdr
{
    uchar	code;
    uchar	id;
    uchar	len[2];	/* length including this header */

    uchar	tp;	/* optional, only for Request/Response */
};
@

<<enum [[_anon_ (networking/ip/snoopy/eap.c)]]>>=
enum
{
    EAPHDR=	4,	/* sizeof(code)+sizeof(id)+sizeof(len) */
    TPHDR= 1,	/* sizeof(tp) */

    /* eap types */
    Request = 1,
    Response,
    Success,
    Fail,

    /* eap request/response sub-types */
    Identity = 1,		/* Identity */
    Notify,		/* Notification */
    Nak,			/* Nak (Response only) */
    Md5,		/* MD5-challenge */
    Otp,			/* one time password */
    Gtc,			/* generic token card */
    Ttls = 21,		/* tunneled TLS */
    Xpnd = 254,	/* expanded types */
    Xprm,		/* experimental use */
};
@

<<enum [[_anon_ (networking/ip/snoopy/eap.c)2]]>>=
enum
{
    Ot,
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/eap.c)]])>>=
static Mux p_mux[] =
{
    { "eap_identity", Identity, },
    { "eap_notify", Notify, },
    { "eap_nak", Nak, },
    { "eap_md5", Md5, },
    { "eap_otp", Otp, },
    { "eap_gtc", Gtc, },
    { "ttls", Ttls, },
    { "eap_xpnd", Xpnd, },
    { "eap_xprm", Xprm, }, 
    { 0 }
};
@

<<global [[eapsubtype]]>>=
static char *eapsubtype[256] =
{
[Identity]	"Identity",
[Notify]	"Notify",
[Nak]		"Nak",
[Md5]	"Md5",
[Otp]		"Otp",
[Gtc]		"Gtc",
[Ttls]		"Ttls",
[Xpnd]	"Xpnd",
[Xprm]	"Xprm",
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/eap.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
    sysfatal("unknown eap field or type: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/eap.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;
    int len;

    if(f->subop != Ot)
        return 0;

    if(m->pe - m->ps < EAPHDR)
        return -1;

    h = (Hdr*)m->ps;

    /* truncate the message if there's extra */
    /* len includes header */
    len = NetS(h->len);
    if(m->ps+len < m->pe)
        m->pe = m->ps+len;
    else if(m->ps+len > m->pe)
        return -1;
    m->ps += EAPHDR;

    if(h->code != Request && h->code != Response)
        return 0;
    m->ps += TPHDR;

    if(h->tp == f->ulv)
        return 1;

    return 0;
}
@

<<function [[op]]([[(networking/ip/snoopy/eap.c)]])>>=
static char*
op(int i)
{
    static char x[20];

    switch(i){
    case Request:
        return "Request";
    case Response:
        return "Response";
    case Success:
        return "Success";
    case Fail:
        return "Fail";
    default:
        sprint(x, "%1d", i);
        return x;
    }
}
@

<<function [[subop]]>>=
static char*
subop(uchar val)
{
    static char x[20], *p;

    p = eapsubtype[val];
    if(p != nil)
        return p;
    else {
        sprint(x, "%1d", val);
        return x;
    }
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/eap.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;
    int len;
    char *p, *e;

    if(m->pe - m->ps < EAPHDR)
        return -1;

    p = m->p;
    e = m->e;
    h = (Hdr*)m->ps;

    /* resize packet (should already be done by eapol) */
    /* len includes header */
    len = NetS(h->len);
    if(m->ps+len < m->pe)
        m->pe = m->ps+len;
    else if(m->ps+len > m->pe)
        return -1;
    m->ps += EAPHDR;

    p = seprint(p, e, "id=%1d code=%s", h->id, op(h->code));
    switch(h->code) {
    case Request:
    case Response:
        m->ps += TPHDR;
        p = seprint(p, e, " type=%s", subop(h->tp));
        /* special case needed to print eap_notify notification as unicode */
        demux(p_mux, h->tp, h->tp, m, &dump);
        break;
    default:
        demux(p_mux, 0, 0, m, &dump);
        break;
    }
    m->p = seprint(p, e, " len=%1d", len);
    return 0;
}
@

<<function [[p_seprintidentity]]>>=
static int
p_seprintidentity(Msg *m)
{
    char *ps, *pe, *z;
    int len;

    m->pr = nil;
    ps = (char*)m->ps;
    pe = (char*)m->pe;

    /* we would like to do this depending on the 'context':
     *  - one for eap_identity request and
     *  - one for eap_identity response
     * but we've lost the context, or haven't we?
     * so we treat them the same, so we might erroneously
     * print a response as if it was a request. too bad. - axel
     */
    for (z=ps; *z != '\0' && z+1 < pe; z++)
        ;
    if (*z == '\0' && z+1 < pe) {
        m->p = seprint(m->p, m->e, "prompt=(%s)", ps);
        len = pe - (z+1);
        m->p = seprint(m->p, m->e, " options=(%.*s)", len, z+1);
    } else {
        len = pe - ps;
        m->p = seprint(m->p, m->e, "%.*s", len, ps);
    }
    return 0;
}
@

<<global [[eap]]>>=
Proto eap =
{
    "eap",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    nil,
    defaultframer,
};
@

<<global [[eap_identity]]>>=
Proto eap_identity =
{
    "eap_identity",
    p_compile,
    p_filter,
    p_seprintidentity,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/eap.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/eap.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/eap.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/eap.c)2]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/eap.c)]])>>

<<global [[eapsubtype]]>>


<<function [[p_compile]]([[(networking/ip/snoopy/eap.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/eap.c)]])>>

<<function [[op]]([[(networking/ip/snoopy/eap.c)]])>>

<<function [[subop]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/eap.c)]])>>

<<function [[p_seprintidentity]]>>

<<global [[eap]]>>

<<global [[eap_identity]]>>
@


\subsection*{[[networking/ip/snoopy/eap_identity.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/eap_identity.c>>=
/* place holder, this stuff is really in eap.c */
@


\subsection*{[[networking/ip/snoopy/eapol.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/eapol.c)]])>>=
struct Hdr
{
    uchar	vi;		/* version */
    uchar	type;
    uchar	len[2];	/* length of data following this header */
};
@

<<enum [[_anon_ (networking/ip/snoopy/eapol.c)]]>>=
enum
{
    EAPOLHDR=	4,		/* sizeof(Hdr) */

    /* eapol types */
    Eap = 0,
    Start,
    Logoff,
    Key,
    AsfAlert,
};
@

<<enum [[_anon_ (networking/ip/snoopy/eapol.c)2]]>>=
enum
{
    Ot,	/* type */
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/eapol.c)]])>>=
static Mux p_mux[] =
{
    { "eap", Eap, },
    { "eapol_start", Start, },
    { "eapol_logoff", Logoff, },
    { "eapol_key", Key, },
    { "asf_alert", AsfAlert, },
    { 0 }
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/eapol.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
    sysfatal("unknown eapol field or type: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/eapol.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < EAPOLHDR)
        return 0;

    h = (Hdr*)m->ps;

    /* len does not include header */
    m->ps += EAPOLHDR;

    switch(f->subop){
    case Ot:
        return h->type == f->ulv;
    }
    return 0;
}
@

<<function [[op]]([[(networking/ip/snoopy/eapol.c)]])>>=
static char*
op(int i)
{
    static char x[20];

    switch(i){
    case Eap:
        return "Eap";
    case Start:
        return "Start";
    case Logoff:
        return "Logoff";
    case Key:
        return "Key";
    case AsfAlert:
        return "AsfAlert";
    default:
        sprint(x, "%1d", i);
        return x;
    }
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/eapol.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;
    int len;

    if(m->pe - m->ps < EAPOLHDR)
        return -1;

    h = (Hdr*)m->ps;

    /* len does not include header */
    m->ps += EAPOLHDR;

    /* truncate the message if there's extra */
    len = NetS(h->len);
    if(m->ps + len < m->pe)
        m->pe = m->ps + len;
    else if(m->ps+len > m->pe)
        return -1;

    /* next protocol  depending on type*/
    demux(p_mux, h->type, h->type, m, &dump);

    m->p = seprint(m->p, m->e, "type=%s version=%1d datalen=%1d",
            op(h->type), h->vi, len);
    return 0;
}
@

<<global [[eapol]]>>=
Proto eapol =
{
    "eapol",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/eapol.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/eapol.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/eapol.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/eapol.c)2]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/eapol.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/eapol.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/eapol.c)]])>>

<<function [[op]]([[(networking/ip/snoopy/eapol.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/eapol.c)]])>>

<<global [[eapol]]>>
@


\subsection*{[[networking/ip/snoopy/eapol_key.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/eapol_key.c)]])>>=
typedef struct Hdr
{
    uchar	desc;
} Hdr;
@

<<struct [[Rc4KeyDesc]]>>=
typedef struct Rc4KeyDesc
{
    uchar	ln[2];
    uchar	replay[8];
    uchar	iv[16];
    uchar	idx;
    uchar	md[16];
} Rc4KeyDesc;
@

<<enum [[_anon_ (networking/ip/snoopy/eapol_key.c)]]>>=
enum
{
    HDR=	1,		/* sizeof(Hdr) */
    RC4KEYDESC=	43,	/* sizeof(Rc4KeyDesc) */

    DescTpRC4= 1,
};
@

<<enum [[_anon_ (networking/ip/snoopy/eapol_key.c)2]]>>=
enum
{
    Odesc,
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/eapol_key.c)]])>>=
static Mux p_mux[] =
{
    { "rc4keydesc", DescTpRC4, },
    { 0 }
};
@

<<global [[p_muxrc4]]>>=
static Mux p_muxrc4[] =
{
    { "dump", 0, },
    { 0 }
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/eapol_key.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Odesc;
            return;
        }
    sysfatal("unknown eap_key field or type: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/eapol_key.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < HDR)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += HDR;

    switch(f->subop){
    case Odesc:
        return h->desc == f->ulv;
    }
    return 0;
}
@

<<function [[op]]([[(networking/ip/snoopy/eapol_key.c)]])>>=
static char*
op(int i)
{
    static char x[20];

    switch(i){
    case DescTpRC4:
        return "RC4KeyDesc";
    default:
        sprint(x, "%1d", i);
        return x;
    }
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/eapol_key.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < HDR)
        return -1;

    h = (Hdr*)m->ps;
    m->ps += HDR;

    /* next protocol  depending on type*/
    demux(p_mux, h->desc, h->desc, m, &dump);

    m->p = seprint(m->p, m->e, "desc=%s", op(h->desc));
    return 0;
}
@

<<function [[p_seprintrc4]]>>=
static int
p_seprintrc4(Msg *m)
{
    Rc4KeyDesc *h;
    int len;

    if(m->pe - m->ps < RC4KEYDESC)
        return -1;

    h = (Rc4KeyDesc*)m->ps;
    m->ps += RC4KEYDESC;
    m->pr = nil;
    len = m->pe - m->ps;

    m->p = seprint(m->p, m->e, "keylen=%1d replay=%1d iv=%1d idx=%1d md=%1d",
            NetS(h->ln), NetS(h->replay), NetS(h->iv), h->idx, NetS(h->md));
    m->p = seprint(m->p, m->e, " dataln=%d", len);
    if (len > 0)
        m->p = seprint(m->p, m->e, " data=%.*H", len, m->ps);
    return 0;
}
@

<<global [[eapol_key]]>>=
Proto eapol_key =
{
    "eapol_key",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    nil,
    defaultframer,
};
@

<<global [[rc4keydesc]]>>=
Proto rc4keydesc =
{
    "rc4keydesc",
    p_compile,
    nil,
    p_seprintrc4,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/eapol_key.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

<<struct [[Hdr]]([[(networking/ip/snoopy/eapol_key.c)]])>>

<<struct [[Rc4KeyDesc]]>>

<<enum [[_anon_ (networking/ip/snoopy/eapol_key.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/eapol_key.c)2]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/eapol_key.c)]])>>

<<global [[p_muxrc4]]>>

<<function [[p_compile]]([[(networking/ip/snoopy/eapol_key.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/eapol_key.c)]])>>

<<function [[op]]([[(networking/ip/snoopy/eapol_key.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/eapol_key.c)]])>>

<<function [[p_seprintrc4]]>>

<<global [[eapol_key]]>>

<<global [[rc4keydesc]]>>
@


\subsection*{[[networking/ip/snoopy/gre.c]]}

<<enum [[_anon_ (networking/ip/snoopy/gre.c)]]>>=
/* GRE flag bits */
enum {
    GRE_chksum	= (1<<15),
    GRE_routing	= (1<<14),
    GRE_key		= (1<<13),
    GRE_seq		= (1<<12),
    GRE_srcrt		= (1<<11),
    GRE_recur	= (7<<8),
    GRE_ack		= (1<<7),
    GRE_version	= 0x7,
};
@
% >> >> >> >> >> >> >>

<<struct [[Hdr]]([[(networking/ip/snoopy/gre.c)]])>>=
struct Hdr
{
    ushort flags;
    ushort proto;
    uchar version;
    ushort chksum;
    ushort offset;
    ulong key;
    ulong seq;
    ulong route;
    ulong ack;
};
@

<<enum [[_anon_ (networking/ip/snoopy/gre.c)2]]>>=
enum
{
    Oproto,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/gre.c)]])>>=
static Field p_fields[] = 
{
    {"proto",		Fnum,	Oproto,	"encapsulated protocol",	} ,
    {0}
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/gre.c)]])>>=
static Mux p_mux[] =
{
    {"pup",	0x0200, },
    {"xns",	0x0600, },
    {"ip",		0x0800, },
    {"chaos",	0x0804, },
    {"arp",	0x0806, },
    {"frarp",	0x0808, },
    {"vines",	0x0bad, },
    {"vinesecho",	0x0bae, },
    {"vinesloop",	0x0baf, },
    {"ppp",	0x880b, },
    {"llc",	0x007a, },
    {"dot1q",	0x8100, },
    {"eapol",	0x888e, },
    {0},
};
@

<<function [[parthdrlen]]>>=
int
parthdrlen(ushort flags)
{
    return 4 + 
        (flags&GRE_chksum || flags&GRE_routing) ? 4 : 0 +
        flags&GRE_key ? 4 : 0 +
        flags&GRE_seq ? 4 : 0 +
        flags&GRE_ack ? 4 : 0;
}
@

<<function [[parsehdr]]>>=
int
parsehdr(Hdr *h, uchar *s, uchar *e)
{
    uchar *p;
    uchar n;

    if(e - s < 4)
        return -1;

    p = s;

    h->flags = NetS(p);
    p += 2;
    h->proto = NetS(p);
    p += 2;
    h->version = h->flags&GRE_version;

    if(parthdrlen(h->flags) > e - s)
        return -1;

    if(h->flags&(GRE_chksum|GRE_routing)){
        h->chksum = NetS(p);
        p += 2;
        h->offset = NetS(p);
        p += 2;
    }
    if(h->flags&GRE_key){
        h->key = NetL(p);
        p += 4;
    }
    if(h->flags&GRE_seq){
        h->seq = NetL(p);
        p += 4;
    }
    if(h->flags&GRE_ack){
        h->ack = NetL(p);
        p += 4;
    }
    if(h->flags&GRE_routing){
        for(;;){
            if(e - p < 4)
                return -1;
            if((n = p[3]) == 0)
                break;
            p += n;
        }
    }

    return p - s;
}
@

<<function [[p_compile]]([[(networking/ip/snoopy/gre.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(gre.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Oproto;
            return;
        }
    sysfatal("unknown gre field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/gre.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr h;
    int len;

    len = parsehdr(&h, m->ps, m->pe);
    if(len < 0)
        return -1;
    m->ps += len;

    switch(f->subop){
    case Oproto:
        return h.proto == f->ulv;
    }
    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/gre.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr h;
    int len;

    len = parsehdr(&h, m->ps, m->pe);
    if(len < 0)
        return -1;
    m->ps += len;

    demux(p_mux, h.proto, h.proto, m, &dump);

    m->p = seprint(m->p, m->e, "version=%d proto=%#ux flags=%#.4ux", h.version, h.proto, h.flags);
    if(h.flags&GRE_chksum)
        m->p = seprint(m->p, m->e, " checksum=%#.4ux", h.chksum);
    if(h.flags&GRE_key)
        m->p = seprint(m->p, m->e, " key=%#.8ulx", h.key);
    if(h.flags&GRE_seq)
        m->p = seprint(m->p, m->e, " seq=%#.8ulx", h.seq);
    if(h.flags&GRE_ack)
        m->p = seprint(m->p, m->e, " ack=%#.8ulx", h.ack);
    if(h.flags&GRE_routing)
        m->p = seprint(m->p, m->e, " offset=%#ux haverouting", h.offset);
    if(h.version == 0)
        m->p = seprint(m->p, m->e, " recursion=%ud", (h.flags&GRE_recur)>>8);
    
    return 0;
}
@

<<global [[gre]]>>=
Proto gre =
{
    "gre",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%#.4ux",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/gre.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

/*
 GRE version 0 is specified in rfc1701.
 GRE version 0 has been respecified in rfc2784 as a subset of rfc1701.
 GRE version 1, as used by pptp, has been specified in rfc2637.
*/


<<enum [[_anon_ (networking/ip/snoopy/gre.c)]]>>


typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/gre.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/gre.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/gre.c)]])>>

<<global [[p_mux]]([[(networking/ip/snoopy/gre.c)]])>>

<<function [[parthdrlen]]>>

<<function [[parsehdr]]>>

<<function [[p_compile]]([[(networking/ip/snoopy/gre.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/gre.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/gre.c)]])>>

<<global [[gre]]>>
@


\subsection*{[[networking/ip/snoopy/hdlc.c]]}

<<enum [[_anon_ (networking/ip/snoopy/hdlc.c)]]>>=
enum {
    HDLC_frame=	0x7e,
    HDLC_esc=	0x7d,

    /* PPP frame fields */
    PPP_addr=	0xff,
    PPP_ctl=	0x3,
    PPP_initfcs=	0xffff,
    PPP_goodfcs=	0xf0b8,
};
@

<<global [[fcstab]]>>=
/*
 * Calculate FCS - rfc 1331
 */
ushort fcstab[256] =
{
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};
@

<<global [[inbuf]]>>=
static uchar inbuf[16*1024];
@

<<global [[inlen]]>>=
static int inlen;
@

<<global [[p_mux]]([[(networking/ip/snoopy/hdlc.c)]])>>=
static Mux p_mux[] =
{
    {"ppp",		(PPP_addr<<8)|PPP_ctl,	} ,
    {0}
};
@

<<enum [[_anon_ (networking/ip/snoopy/hdlc.c)2]]>>=
enum
{
    Ot = 1
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/hdlc.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
    sysfatal("unknown ethernet field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/hdlc.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    ulong t;

    if(m->pe-m->ps < 2)
        return 0;

    switch(f->subop){
    case Ot:
        t = (m->ps[0]<<8)|m->ps[1];
        if(t != f->ulv)
            return 0;
        break;
    }
    return 1;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/hdlc.c)]])>>=
static int
p_seprint(Msg *m)
{
    ulong t;

    if(m->pe-m->ps < 2)
        return -1;

    t = (m->ps[0]<<8)|m->ps[1];
    m->ps += 2;
    demux(p_mux, t, t, m, &dump);

    return 0;
}
@

<<function [[p_framer]]>>=
static int
p_framer(int fd, uchar *pkt, int pktlen)
{
    ushort fcs;
    uchar *from, *efrom, *to, *eto;
    int n;
    ulong c;

    eto = pkt+pktlen;
    for(;;){
        efrom = memchr(inbuf, HDLC_frame, inlen);
        if(efrom == nil){
            if(inlen >= sizeof(inbuf))
                inlen = 0;
            n = read(fd, inbuf+inlen, sizeof(inbuf)-inlen);
            if(n <= 0)
                break;
            inlen += n;
            continue;
        }

        /* checksum and unescape the frame */
        fcs = PPP_initfcs;
        to = pkt;
        for(from = inbuf; from < efrom;){
            c = *from++;
            if(c == HDLC_esc)
                c = (*from++) ^ 0x20;
            if(to < eto)
                *to++ = c;
            fcs = (fcs >> 8) ^ fcstab[(fcs ^ c) & 0xff];
        }

        /* move down anything that's left */
        inlen -= efrom+1-inbuf;
        memmove(inbuf, efrom+1, inlen);

        /* accept if this is a good packet */
        if(fcs != PPP_goodfcs)
            print("bad frame %ld %2.2ux %2.2ux!\n", to-pkt, pkt[0], pkt[1]);
        else
            return to-pkt;
    }
    return -1;
}
@

<<global [[hdlc]]>>=
Proto hdlc =
{
    "hdlc",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%#.4lux",
    nil,
    p_framer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/hdlc.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

<<enum [[_anon_ (networking/ip/snoopy/hdlc.c)]]>>

<<global [[fcstab]]>>

<<global [[inbuf]]>>
<<global [[inlen]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/hdlc.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/hdlc.c)2]]>>

<<function [[p_compile]]([[(networking/ip/snoopy/hdlc.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/hdlc.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/hdlc.c)]])>>

<<function [[p_framer]]>>

<<global [[hdlc]]>>
@


\subsection*{[[networking/ip/snoopy/icmp6.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/icmp6.c)]])>>=
struct Hdr
{	uchar	type;
    uchar	code;
    uchar	cksum[2];	/* Checksum */
    uchar	data[1];
};
@

<<enum [[_anon_ (networking/ip/snoopy/icmp6.c)]]>>=
enum
{
    ICMP6LEN=	4,
};
@

<<enum [[_anon_ (networking/ip/snoopy/icmp6.c)2]]>>=
enum
{
    Ot,	/* type */
    Op,	/* next protocol */
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/icmp6.c)]])>>=
static Field p_fields[] =
{
    {"t",		Fnum,	Ot,	"type",	} ,
    {0}
};
@

<<enum [[_anon_ (networking/ip/snoopy/icmp6.c)3]]>>=
enum
{
    /* ICMPv6 types */
    EchoReply	= 0,
    UnreachableV6	= 1,
    PacketTooBigV6	= 2,
    TimeExceedV6	= 3,
    ParamProblemV6	= 4,
    Redirect	= 5,
    EchoRequest	= 8,
    TimeExceed	= 11,
    InParmProblem	= 12,
    Timestamp	= 13,
    TimestampReply	= 14,
    InfoRequest	= 15,
    InfoReply	= 16,
    AddrMaskRequest = 17,
    AddrMaskReply   = 18,
    EchoRequestV6	= 128,
    EchoReplyV6	= 129,
    RouterSolicit	= 133,
    RouterAdvert	= 134,
    NbrSolicit	= 135,
    NbrAdvert	= 136,
    RedirectV6	= 137,

    Maxtype6	= 137,
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/icmp6.c)]])>>=
static Mux p_mux[] =
{
    {"ip6",	UnreachableV6, },
    {"ip6",	RedirectV6, },
    {"ip6",	TimeExceedV6, },
    {0},
};
@

<<global [[icmpmsg6]]>>=
char *icmpmsg6[256] =
{
[EchoReply]		"EchoReply",
[UnreachableV6]		"UnreachableV6",
[PacketTooBigV6]	"PacketTooBigV6",
[TimeExceedV6]		"TimeExceedV6",
[Redirect]		"Redirect",
[EchoRequest]		"EchoRequest",
[TimeExceed]		"TimeExceed",
[InParmProblem]		"InParmProblem",
[Timestamp]		"Timestamp",
[TimestampReply]	"TimestampReply",
[InfoRequest]		"InfoRequest",
[InfoReply]		"InfoReply",
[AddrMaskRequest]	"AddrMaskRequest",
[AddrMaskReply]		"AddrMaskReply",
[EchoRequestV6]		"EchoRequestV6",
[EchoReplyV6]		"EchoReplyV6",
[RouterSolicit]		"RouterSolicit",
[RouterAdvert]		"RouterAdvert",
[NbrSolicit]		"NbrSolicit",
[NbrAdvert]		"NbrAdvert",
[RedirectV6]		"RedirectV6",
};
@

<<global [[unreachcode]]([[(networking/ip/snoopy/icmp6.c)]])>>=
static char *unreachcode[] =
{
[0]	"no route to destination",
[1]	"comm with destination administratively prohibited",
[2]	"icmp unreachable: unassigned error code (2)",
[3]	"address unreachable",
[4]	"port unreachable",
[5]	"icmp unreachable: unknown code",
};
@

<<global [[timexcode]]>>=
static char *timexcode[] =
{
[0]	"hop limit exc",
[1]	"reassmbl time exc",
[2]	"icmp time exc: unknown code",
};
@

<<global [[parpcode]]>>=
static char *parpcode[] =
{
[0]	"erroneous header field encountered",
[1]	"unrecognized Next Header type encountered",
[2]	"unrecognized IPv6 option encountered",
[3]	"icmp par prob: unknown code",
};
@

<<enum [[_anon_ (networking/ip/snoopy/icmp6.c)4]]>>=
enum
{
    sll	= 1,
    tll	= 2,
    pref	= 3,
    redir	= 4,
    mtu	= 5,
};
@

<<global [[icmp6opts]]>>=
static char *icmp6opts[256] =
{
[0]	"unknown opt",
[1]	"sll_addr",
[2]	"tll_addr",
[3]	"pref_opt",
[4]	"redirect",
[5]	"mtu_opt",
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/icmp6.c)]])>>=
static void
p_compile(Filter *f)
{
    if(f->op == '='){
        compile_cmp(icmp6.name, f, p_fields);
        return;
    }
    if(strcmp(f->s, "ip6") == 0){
        f->pr = p_mux->pr;
        f->subop = Op;
        return;
    }
    sysfatal("unknown icmp field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/icmp6.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < ICMP6LEN)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += ICMP6LEN;

    switch(f->subop){

    case Ot:
        if(h->type == f->ulv)
            return 1;
        break;
    case Op:
        switch(h->type){
        case UnreachableV6:
        case RedirectV6:
        case TimeExceedV6:
            m->ps += 4;
            return 1;
        }
    }
    return 0;
}
@

<<function [[opt_seprint]]>>=
static char*
opt_seprint(Msg *m)
{
    int otype, osz, pktsz;
    uchar *a;
    char *p = m->p;
    char *e = m->e;
    char *opt;
    char optbuf[12];

    pktsz = m->pe - m->ps;
    a = m->ps;
    while (pktsz > 0) {
        otype = *a;
        opt = icmp6opts[otype];
        if(opt == nil){
            sprint(optbuf, "0x%ux", otype);
            opt = optbuf;
        }
        osz = (*(a+1)) * 8;

        switch (otype) {
        default:
            p = seprint(p, e, "\n	  option=%s ", opt);
            m->pr = &dump;
            return p;

        case sll:
        case tll:
            if (pktsz < osz || osz != 8) {
                p = seprint(p, e, "\n	  option=%s bad size=%d",
                    opt, osz);
                m->pr = &dump;
                return p;
            }
            p = seprint(p, e, "\n	  option=%s maddr=%E", opt, a+2);
            pktsz -= osz;
            a += osz;
            break;

        case pref:
            if ((pktsz < osz) || (osz != 32)) {
                p = seprint(p, e, "\n	  option=%s: bad size=%d",
                    opt, osz);
                m->pr = &dump;
                return p;
            }

            p = seprint(p, e, "\n	  option=%s pref=%I "
                "preflen=%3.3d lflag=%1.1d aflag=%1.1d "
                "unused1=%1.1d validlt=%d preflt=%d unused2=%1.1d",
                opt,
                a+16,
                (int) (*(a+2)),
                (*(a+3) & (1 << 7)) != 0,
                (*(a+3) & (1 << 6)) != 0,
                (*(a+3) & 63) != 0,
                NetL(a+4),
                NetL(a+8),
                NetL(a+12)!=0);

            pktsz -= osz;
            a += osz;
            break;

        case redir:
            if (pktsz < osz) {
                p = seprint(p, e, "\n	  option=%s: bad size=%d",
                    opt, osz);
                m->pr = &dump;
                return p;
            }

            p = seprint(p, e, "\n	  option=%s len %d", opt, osz);
            a += osz;
            m->ps = a;
            return p;

        case mtu:
            if (pktsz < osz || osz != 8) {
                p = seprint(p, e, "\n	  option=%s: bad size=%d",
                    opt, osz);
                m->pr = &dump;
                return p;
            }

            p = seprint(p, e, "\n	  option=%s unused=%1.1d mtu=%d",
                opt, NetL(a+2) != 0, NetL(a+4));
            pktsz -= osz;
            a += osz;
            break;
        }
    }

    m->ps = a;
    return p;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/icmp6.c)]])>>=
static int
p_seprint(Msg *m)
{
    int i;
//	ushort cksum2, cksum;
    char *tn;
    char *p = m->p;
    char *e = m->e;
    uchar *a;
    Hdr *h;

    h = (Hdr*)m->ps;
    m->ps += ICMP6LEN;
    m->pr = &dump;
    a = m->ps;

    if(m->pe - m->ps < ICMP6LEN)
        return -1;

    tn = icmpmsg6[h->type];
    if(tn == nil)
        p = seprint(p, e, "t=%ud c=%d ck=%4.4ux", h->type,
            h->code, (ushort)NetS(h->cksum));
    else
        p = seprint(p, e, "t=%s c=%d ck=%4.4ux", tn,
            h->code, (ushort)NetS(h->cksum));

/*
    if(Cflag){
        cksum = NetS(h->cksum);
        h->cksum[0] = 0;
        h->cksum[1] = 0;
        cksum2 = ~ptclbsum((uchar*)h, m->pe - m->ps + ICMP6LEN) & 0xffff;
        if(cksum != cksum2)
            p = seprint(p,e, " !ck=%4.4ux", cksum2);
    }
 */

    switch(h->type){

    case UnreachableV6:
        m->ps += 4;
        m->pr = &ip6;
        if (h->code >= nelem(unreachcode))
            i = nelem(unreachcode)-1;
        else
            i = h->code;
        p = seprint(p, e, " code=%s unused=%1.1d ", unreachcode[i],
            NetL(a) != 0);
        break;

    case PacketTooBigV6:
        m->ps += 4;
        m->pr = &ip6;
        p = seprint(p, e, " mtu=%4.4d ", NetL(a));
        break;

    case TimeExceedV6:
        m->ps += 4;
        m->pr = &ip6;
        if (h->code >= nelem(timexcode))
            i = nelem(timexcode)-1;
        else
            i = h->code;
        p = seprint(p, e, " code=%s unused=%1.1d ", timexcode[i],
            NetL(a) != 0);
        break;

    case ParamProblemV6:
        m->ps += 4;
        m->pr = &ip6;
        if (h->code > nelem(parpcode))
            i = nelem(parpcode)-1;
        else
            i = h->code;
        p = seprint(p, e, " code=%s ptr=%2.2ux", parpcode[i], h->data[0]);
        break;

    case EchoReplyV6:
    case EchoRequestV6:
        m->ps += 4;
        p = seprint(p, e, " id=%ux seq=%ux",
            NetS(h->data), NetS(h->data+2));
        break;

    case RouterSolicit:
        m->ps += 4;
        m->pr = nil;
        m->p = seprint(p, e, " unused=%1.1d ", NetL(a)!=0);
        p = opt_seprint(m);
        break;

    case RouterAdvert:
        m->ps += 12;
        m->pr = nil;
        m->p = seprint(p, e, " hoplim=%3.3d mflag=%1.1d oflag=%1.1d "
            "unused=%1.1d routerlt=%8.8d reachtime=%d rxmtimer=%d",
            (int) *a,
            (*(a+1) & (1 << 7)) != 0,
            (*(a+1) & (1 << 6)) != 0,
            (*(a+1) & 63) != 0,
            NetS(a+2),
            NetL(a+4),
            NetL(a+8));
        p = opt_seprint(m);
        break;

    case NbrSolicit:
        m->ps += 20;
        m->pr = nil;
        m->p = seprint(p, e, " unused=%1.1d targ %I", NetL(a) != 0, a+4);
        p = opt_seprint(m);
        break;

    case NbrAdvert:
        m->ps += 20;
        m->pr = nil;
        m->p = seprint(p, e, " rflag=%1.1d sflag=%1.1d oflag=%1.1d targ=%I",
            (*a & (1 << 7)) != 0,
            (*a & (1 << 6)) != 0,
            (*a & (1 << 5)) != 0,
            a+4);
        p = opt_seprint(m);
        break;

    case RedirectV6:
        m->ps += 36;
        m->pr = &ip6;
        m->p = seprint(p, e, " unused=%1.1d targ=%I dest=%I",
            NetL(a) != 0, a+4, a+20);
        p = opt_seprint(m);
        break;

    case Timestamp:
    case TimestampReply:
        m->ps += 12;
        p = seprint(p, e, " orig=%ud rcv=%ux xmt=%ux",
            NetL(h->data), NetL(h->data+4), NetL(h->data+8));
        m->pr = nil;
        break;

    case InfoRequest:
    case InfoReply:
        break;

    }
    m->p = p;
    return 0;
}
@

<<global [[icmp6]]>>=
Proto icmp6 =
{
    "icmp6",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/icmp6.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/icmp6.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/icmp6.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/icmp6.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/icmp6.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/icmp6.c)3]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/icmp6.c)]])>>

<<global [[icmpmsg6]]>>

<<global [[unreachcode]]([[(networking/ip/snoopy/icmp6.c)]])>>

<<global [[timexcode]]>>

<<global [[parpcode]]>>
<<enum [[_anon_ (networking/ip/snoopy/icmp6.c)4]]>>

<<global [[icmp6opts]]>>

<<function [[p_compile]]([[(networking/ip/snoopy/icmp6.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/icmp6.c)]])>>

<<function [[opt_seprint]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/icmp6.c)]])>>

<<global [[icmp6]]>>
@


\subsection*{[[networking/ip/snoopy/ip6.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/ip6.c)]])>>=
struct Hdr
{
    uchar	vcf[4];			/* Version and header length */
    uchar	length[2];		/* packet length */
    uchar	proto;			/* Protocol */
    uchar	ttl;			/* Time to live */
    uchar	src[IPaddrlen];		/* IP source */
    uchar	dst[IPaddrlen];		/* IP destination */
};
@

<<enum [[_anon_ (networking/ip/snoopy/ip6.c)]]>>=
enum
{
    IP6HDR		= 40,		/* sizeof(Iphdr) */
    IP_VER		= 0x60,		/* Using IP version 4 */
    HBH_HDR		= 0,
    ROUT_HDR	= 43,
    FRAG_HDR	= 44,
    FRAG_HSZ	= 8, 		/* in bytes */
    DEST_HDR	= 60,
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/ip6.c)]])>>=
static Mux p_mux[] =
{
    { "igmp", 2, },
    { "ggp", 3, },
    { "ip", 4, },
    { "st", 5, },
    { "tcp", 6, },
    { "ucl", 7, },
    { "egp", 8, },
    { "igp", 9, },
    { "bbn-rcc-mon", 10, },
    { "nvp-ii", 11, },
    { "pup", 12, },
    { "argus", 13, },
    { "emcon", 14, },
    { "xnet", 15, },
    { "chaos", 16, },
    { "udp", 17, },
    { "mux", 18, },
    { "dcn-meas", 19, },
    { "hmp", 20, },
    { "prm", 21, },
    { "xns-idp", 22, },
    { "trunk-1", 23, },
    { "trunk-2", 24, },
    { "leaf-1", 25, },
    { "leaf-2", 26, },
    { "rdp", 27, },
    { "irtp", 28, },
    { "iso-tp4", 29, },
    { "netblt", 30, },
    { "mfe-nsp", 31, },
    { "merit-inp", 32, },
    { "sep", 33, },
    { "3pc", 34, },
    { "idpr", 35, },
    { "xtp", 36, },
    { "ddp", 37, },
    { "idpr-cmtp", 38, },
    { "tp++", 39, },
    { "il", 40, },
    { "sip", 41, },
    { "sdrp", 42, },
    { "idrp", 45, },
    { "rsvp", 46, },
    { "gre", 47, },
    { "mhrp", 48, },
    { "bna", 49, },
    { "sipp-esp", 50, },
    { "sipp-ah", 51, },
    { "i-nlsp", 52, },
    { "swipe", 53, },
    { "nhrp", 54, },
    { "icmp6", 58, },
    { "any", 61, },
    { "cftp", 62, },
    { "any", 63, },
    { "sat-expak", 64, },
    { "kryptolan", 65, },
    { "rvd", 66, },
    { "ippc", 67, },
    { "any", 68, },
    { "sat-mon", 69, },
    { "visa", 70, },
    { "ipcv", 71, },
    { "cpnx", 72, },
    { "cphb", 73, },
    { "wsn", 74, },
    { "pvp", 75, },
    { "br-sat-mon", 76, },
    { "sun-nd", 77, },
    { "wb-mon", 78, },
    { "wb-expak", 79, },
    { "iso-ip", 80, },
    { "vmtp", 81, },
    { "secure-vmtp", 82, },
    { "vines", 83, },
    { "ttp", 84, },
    { "nsfnet-igp", 85, },
    { "dgp", 86, },
    { "tcf", 87, },
    { "igrp", 88, },
    { "ospf", 89, },
    { "sprite-rpc", 90, },
    { "larp", 91, },
    { "mtp", 92, },
    { "ax.25", 93, },
    { "ipip", 94, },
    { "micp", 95, },
    { "scc-sp", 96, },
    { "etherip", 97, },
    { "encap", 98, },
    { "any", 99, },
    { "gmtp", 100, },
    { "rudp", 254, },
    { 0 }
};
@

<<enum [[_anon_ (networking/ip/snoopy/ip6.c)2]]>>=
enum
{
    Os,	/* source */
    Od,	/* destination */
    Osd,	/* source or destination */
    Ot,	/* type */
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/ip6.c)]])>>=
static Field p_fields[] =
{
    {"s",	Fv6ip,	Os,	"source address",	} ,
    {"d",	Fv6ip,	Od,	"destination address",	} ,
    {"a",	Fv6ip,	Osd,	"source|destination address",} ,
    {"t",	Fnum,	Ot,	"sub protocol number",	} ,
    {0}
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/ip6.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    if(f->op == '='){
        compile_cmp(ip6.name, f, p_fields);
        return;
    }
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
    sysfatal("unknown ip6 field or protocol: %s", f->s);
}
@

<<function [[v6hdrlen]]>>=
static int
v6hdrlen(Hdr *h)
{
    int plen, len = IP6HDR;
    int pktlen = IP6HDR + NetS(h->length);
    uchar nexthdr = h->proto;
    uchar *pkt = (uchar*) h;

    pkt += len;
    plen = len;

    while (nexthdr == HBH_HDR || nexthdr == ROUT_HDR ||
        nexthdr == FRAG_HDR || nexthdr == DEST_HDR) {
        if (nexthdr == FRAG_HDR)
            len = FRAG_HSZ;
        else
            len = ((int)*(pkt+1) + 1) * 8;

        if (plen + len > pktlen)
            return -1;

        pkt += len;
        nexthdr = *pkt;
        plen += len;
    }
    return plen;
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/ip6.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;
    int hlen;

    if(m->pe - m->ps < IP6HDR)
        return 0;

    h = (Hdr*)m->ps;

    if ((hlen = v6hdrlen(h)) < 0)
        return 0;
    else
        m->ps += hlen;
    switch(f->subop){
    case Os:
        return memcmp(h->src, f->a, IPaddrlen) == 0;
    case Od:
        return memcmp(h->dst, f->a, IPaddrlen) == 0;
    case Osd:
        return memcmp(h->src, f->a, IPaddrlen) == 0 ||
            memcmp(h->dst, f->a, IPaddrlen) == 0;
    case Ot:
        return h->proto == f->ulv;
    }
    return 0;
}
@

<<function [[v6hdr_seprint]]>>=
static int
v6hdr_seprint(Msg *m)
{
    int plen, len = IP6HDR;
    uchar *pkt = m->ps;
    Hdr *h = (Hdr *)pkt;
    int pktlen = IP6HDR + NetS(h->length);
    uchar nexthdr = h->proto;

    pkt += len;
    plen = len;

    while (nexthdr == HBH_HDR || nexthdr == ROUT_HDR ||
        nexthdr == FRAG_HDR || nexthdr == DEST_HDR) {
        switch (nexthdr) {
        case FRAG_HDR:
            m->p = seprint(m->p, m->e, "\n	  xthdr=frag id=%d "
                "offset=%d pr=%d more=%d res1=%d res2=%d",
                NetL(pkt+4), NetS(pkt+2) & ~7, (int)*pkt,
                (int)(*(pkt+3) & 0x1), (int)*(pkt+1),
                (int)(*(pkt+3) & 0x6));
            len = FRAG_HSZ;
            break;

        case HBH_HDR:
        case ROUT_HDR:
        case DEST_HDR:
            len = ((int)*(pkt+1) + 1) * 8;
            break;
        }

        if (plen + len > pktlen) {
            m->p = seprint(m->p, m->e, "bad pkt");
            m->pr = &dump;
            return -1;
        }
        plen += len;
        pkt += len;
        nexthdr = *pkt;
    }

    m->ps = pkt;
    return 1;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/ip6.c)]])>>=
static int
p_seprint(Msg *m)
{
    int len;
    Hdr *h;

    if(m->pe - m->ps < IP6HDR)
        return -1;
    h = (Hdr*)m->ps;

    demux(p_mux, h->proto, h->proto, m, &dump);

    /* truncate the message if there's extra */
    len = NetS(h->length) + IP6HDR;
    if(len < m->pe - m->ps)
        m->pe = m->ps + len;

    m->p = seprint(m->p, m->e, "s=%I d=%I ttl=%3d pr=%d ln=%d",
        h->src, h->dst, h->ttl, h->proto, NetS(h->length));
    v6hdr_seprint(m);
    return 0;
}
@

<<global [[ip6]]>>=
Proto ip6 =
{
    "ip6",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%lud",
    p_fields,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/ip6.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/ip6.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/ip6.c)]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/ip6.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/ip6.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/ip6.c)]])>>

<<function [[p_compile]]([[(networking/ip/snoopy/ip6.c)]])>>

<<function [[v6hdrlen]]>>

<<function [[p_filter]]([[(networking/ip/snoopy/ip6.c)]])>>

<<function [[v6hdr_seprint]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/ip6.c)]])>>

<<global [[ip6]]>>
@


\subsection*{[[networking/ip/snoopy/ospf.c]]}

<<struct [[Ospfpkt]]>>=
struct Ospfpkt
{
    uchar	version;
    uchar	type;
    uchar	length[2];
    uchar	router[4];
    uchar	area[4];
    uchar	sum[2];
    uchar	autype[2];
    uchar	auth[8];
    uchar	data[1];
};
@

<<constant [[OSPF_HDRSIZE]]>>=
#define OSPF_HDRSIZE	24	
@

<<enum [[_anon_ (networking/ip/snoopy/ospf.c)]]>>=
enum
{
    OSPFhello=	1,
    OSPFdd=		2,
    OSPFlsrequest=	3,
    OSPFlsupdate=	4,
    OSPFlsack=	5,
};
@

<<global [[ospftype]]>>=
char *ospftype[] = {
    [OSPFhello]	"hello",
    [OSPFdd]	"data definition",
    [OSPFlsrequest]	"link state request",
    [OSPFlsupdate]	"link state update",
    [OSPFlsack]	"link state ack",
};
@

<<function [[ospfpkttype]]>>=
char*
ospfpkttype(int x)
{
    static char type[16];

    if(x > 0 && x <= OSPFlsack)
        return ospftype[x];
    sprint(type, "type %d", x);
    return type;
}
@

<<function [[ospfauth]]>>=
char*
ospfauth(Ospfpkt *ospf)
{
    static char auth[100];

    switch(ospf->type){
    case 0:
        return "no authentication";
    case 1:
        sprint(auth, "password(%8.8ux %8.8ux)", NetL(ospf->auth),	
            NetL(ospf->auth+4));
        break;
    case 2:
        sprint(auth, "crypto(plen %d id %d dlen %d)", NetS(ospf->auth),	
            ospf->auth[2], ospf->auth[3]);
        break;
    default:
        sprint(auth, "auth%d(%8.8ux %8.8ux)", NetS(ospf->autype), NetL(ospf->auth),	
            NetL(ospf->auth+4));
    }
    return auth;
}
@

<<struct [[Ospfhello]]>>=
struct Ospfhello
{
    uchar	mask[4];
    uchar	interval[2];
    uchar	options;
    uchar	pri;
    uchar	deadint[4];
    uchar	designated[4];
    uchar	bdesignated[4];
    uchar	neighbor[1];
};
@

<<function [[seprintospfhello]]>>=
char*
seprintospfhello(char *p, char *e, void *a)
{
    Ospfhello *h = a;

    return seprint(p, e, "%s(mask %V interval %d opt %ux pri %ux deadt %d designated %V bdesignated %V)",
        ospftype[OSPFhello],
        h->mask, NetS(h->interval), h->options, h->pri,
        NetL(h->deadint), h->designated, h->bdesignated);
}
@

<<enum [[_anon_ (networking/ip/snoopy/ospf.c)2]]>>=
enum
{
    LSARouter=	1,
    LSANetwork=	2,
    LSASummN=	3,
    LSASummR=	4,
    LSAASext=	5
};
@

<<global [[lsatype]]>>=
char *lsatype[] = {
    [LSARouter]	"Router LSA",
    [LSANetwork]	"Network LSA",
    [LSASummN]	"Summary LSA (Network)",
    [LSASummR]	"Summary LSA (Router)",
    [LSAASext]	"LSA AS external",
};
@

<<function [[lsapkttype]]>>=
char*
lsapkttype(int x)
{
    static char type[16];

    if(x > 0 && x <= LSAASext)
        return lsatype[x];
    sprint(type, "type %d", x);
    return type;
}
@

<<struct [[OspfLSAhdr]]>>=
/* data of Ospfpkt point to a 4-uchar value that is the # of LSAs */
struct OspfLSAhdr {
    uchar	lsage[2];
    uchar	options;	/* 0x2=stub area, 0x1=TOS routing capable */

    uchar	lstype;	/* 1=Router-LSAs
                         * 2=Network-LSAs
                         * 3=Summary-LSAs (to network)
                         * 4=Summary-LSAs (to AS boundary routers)
                         * 5=AS-External-LSAs
                         */
    uchar	lsid[4];
    uchar	advtrt[4];

    uchar	lsseqno[4];
    uchar	lscksum[2];
    uchar	lsalen[2];	/* includes the 20 byte lsa header */
};
@

<<struct [[Ospfrt]]>>=
struct Ospfrt {
    uchar	linkid[4];
    uchar	linkdata[4];
    uchar	typ;
    uchar	numtos;
    uchar	metric[2];
    
};
@

<<struct [[OspfrtLSA]]>>=
struct OspfrtLSA {
    struct OspfLSAhdr	hdr;
    uchar			netmask[4];
};
@

<<struct [[OspfntLSA]]>>=
struct OspfntLSA {
    struct OspfLSAhdr	hdr;
    uchar			netmask[4];
    uchar			attrt[4];
};
@

<<struct [[Ospfsumm]]>>=
/* Summary Link State Advertisement info */
struct Ospfsumm {
    uchar	flag;	/* always zero */
    uchar	metric[3];
};
@

<<struct [[OspfsummLSA]]>>=
struct OspfsummLSA {
    struct OspfLSAhdr	hdr;
    uchar			netmask[4];
    struct Ospfsumm		lsa;
};
@

<<struct [[OspfASext]]>>=
/* AS external Link State Advertisement info */
struct OspfASext {
    uchar	flag;	/* external */
    uchar	metric[3];
    uchar	fwdaddr[4];
    uchar	exrttag[4];
};
@

<<struct [[OspfASextLSA]]>>=
struct OspfASextLSA {
    struct OspfLSAhdr	hdr;
    uchar			netmask[4];
    struct OspfASext	lsa;
};
@

<<struct [[OspfLSupdpkt]]>>=
/* OSPF Link State Update Packet */
struct OspfLSupdpkt {
    uchar	lsacnt[4];
    union {
        uchar			hdr[1];
        struct OspfrtLSA	rt[1];
        struct OspfntLSA	nt[1];
        struct OspfsummLSA	sum[1];
        struct OspfASextLSA	as[1];
    };
};
@

<<function [[seprintospflsaheader]]>>=
char*
seprintospflsaheader(char *p, char *e, struct OspfLSAhdr *h)
{
    return seprint(p, e, "age %d opt %ux type %ux lsid %V adv_rt %V seqno %ux c %4.4ux l %d",
        NetS(h->lsage), h->options&0xff, h->lstype,
        h->lsid, h->advtrt, NetL(h->lsseqno), NetS(h->lscksum),
        NetS(h->lsalen));
}
@

<<struct [[OspfDDpkt]]>>=
/* OSPF Database Description Packet */
struct OspfDDpkt {
    uchar	intMTU[2];
    uchar	options;
    uchar	bits;
    uchar	DDseqno[4];
    struct OspfLSAhdr	hdr[1];		/* LSA headers... */
};
@

<<function [[seprintospfdatadesc]]>>=
char*
seprintospfdatadesc(char *p, char *e, void *a, int len)
{
    int nlsa, i;
    struct OspfDDpkt *g;

    g = (struct OspfDDpkt *)a;
    nlsa = len/sizeof(struct OspfLSAhdr);
    for (i=0; i<nlsa; i++) {
        p = seprint(p, e, "lsa%d(", i);
        p = seprintospflsaheader(p, e, &(g->hdr[i]));
        p = seprint(p, e, ")");
    }
    return seprint(p, e, ")");
}
@

<<function [[seprintospflsupdate]]>>=
char*
seprintospflsupdate(char *p, char *e, void *a, int len)
{
    int nlsa, i;
    struct OspfLSupdpkt *g;
    struct OspfLSAhdr *h;

    g = (struct OspfLSupdpkt *)a;
    nlsa = NetL(g->lsacnt);
    h = (struct OspfLSAhdr *)(g->hdr);
    p = seprint(p, e, "%d-%s(", nlsa, ospfpkttype(OSPFlsupdate));

    switch(h->lstype) {
    case LSARouter:
        {
/*			struct OspfrtLSA *h;
 */
        }
        break;
    case LSANetwork:
        {
            struct OspfntLSA *h;

            for (i=0; i<nlsa; i++) {
                h = &(g->nt[i]);
                p = seprint(p, e, "lsa%d(", i);
                p = seprintospflsaheader(p, e, &(h->hdr));
                p = seprint(p, e, " mask %V attrt %V)",
                    h->netmask, h->attrt);
            }
        }
        break;
    case LSASummN:
    case LSASummR:
        {
            struct OspfsummLSA *h;

            for (i=0; i<nlsa; i++) {
                h = &(g->sum[i]);
                p = seprint(p, e, "lsa%d(", i);
                p = seprintospflsaheader(p, e, &(h->hdr));
                p = seprint(p, e, " mask %V met %d)",
                    h->netmask, Net3(h->lsa.metric));
            }
        }
        break;
    case LSAASext:
        {
            struct OspfASextLSA *h;

            for (i=0; i<nlsa; i++) {
                h = &(g->as[i]);
                p = seprint(p, e, " lsa%d(", i);
                p = seprintospflsaheader(p, e, &(h->hdr));
                p = seprint(p, e, " mask %V extflg %1.1ux met %d fwdaddr %V extrtflg %ux)",
                    h->netmask, h->lsa.flag, Net3(h->lsa.metric),
                    h->lsa.fwdaddr, NetL(h->lsa.exrttag));
            }
        }
        break;
    default:
        p = seprint(p, e, "Not an LS update, lstype %d ", h->lstype);
        p = seprint(p, e, " %.*H", len>64?64:len, a);
        break;
    }
    return seprint(p, e, ")");
}
@

<<function [[seprintospflsack]]>>=
char*
seprintospflsack(char *p, char *e, void *a, int len)
{
    int nlsa, i;
    struct OspfLSAhdr *h;

    h = (struct OspfLSAhdr *)a;
    nlsa = len/sizeof(struct OspfLSAhdr);
    p = seprint(p, e, "%d-%s(", nlsa, ospfpkttype(OSPFlsack));
    for (i=0; i<nlsa; i++) {
        p = seprint(p, e, " lsa%d(", i);
        p = seprintospflsaheader(p, e, &(h[i]));
        p = seprint(p, e, ")");
    }
    return seprint(p, e, ")");
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/ospf.c)]])>>=
int
p_seprint(Msg *m)
{
    Ospfpkt *ospf;
    int len, x;
    char *p, *e;

    len = m->pe - m->ps;
    if(len < OSPF_HDRSIZE)
        return -1;
    p = m->p;
    e = m->e;

    /* adjust packet size */
    ospf = (Ospfpkt*)m->ps;
    x = NetS(ospf->length);
    if(x < len)
        return -1;
    x -= OSPF_HDRSIZE;

    p = seprint(p, e, "ver=%d type=%d len=%d r=%V a=%V c=%4.4ux %s ",
        ospf->version, ospf->type, x, 
        ospf->router, ospf->area, NetS(ospf->sum),
        ospfauth(ospf));

    switch (ospf->type) {
    case OSPFhello:
        p = seprintospfhello(p, e, ospf->data);
        break;
    case OSPFdd:
        p = seprintospfdatadesc(p, e, ospf->data, x);
        break;
    case OSPFlsrequest:
        p = seprint(p, e, " %s->", ospfpkttype(ospf->type));
        goto Default;
    case OSPFlsupdate:
        p = seprintospflsupdate(p, e, ospf->data, x);
        break;
    case OSPFlsack:
        p = seprintospflsack(p, e, ospf->data, x);
        break;
    default:
Default:
        p = seprint(p, e, " data=%.*H", x>64?64:x, ospf->data);
    }
    m->p = p;
    m->pr = nil;
    return 0;
}
@

<<global [[ospf]]>>=
Proto ospf =
{
    "ospf",
    nil,
    nil,
    p_seprint,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/ospf.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <libsec.h>
#include "dat.h"
#include "protos.h"

typedef struct Ospfpkt	Ospfpkt;
typedef struct Ospfhello	Ospfhello;

/*
 *  OSPF packets
 */
<<struct [[Ospfpkt]]>>
<<constant [[OSPF_HDRSIZE]]>>

<<enum [[_anon_ (networking/ip/snoopy/ospf.c)]]>>


<<global [[ospftype]]>>

<<function [[ospfpkttype]]>>

<<function [[ospfauth]]>>

<<struct [[Ospfhello]]>>

<<function [[seprintospfhello]]>>

<<enum [[_anon_ (networking/ip/snoopy/ospf.c)2]]>>


<<global [[lsatype]]>>

<<function [[lsapkttype]]>>

/* OSPF Link State Advertisement Header */
/* rfc2178 section 12.1 */
<<struct [[OspfLSAhdr]]>>

<<struct [[Ospfrt]]>>

<<struct [[OspfrtLSA]]>>

<<struct [[OspfntLSA]]>>

<<struct [[Ospfsumm]]>>

<<struct [[OspfsummLSA]]>>

<<struct [[OspfASext]]>>

<<struct [[OspfASextLSA]]>>

<<struct [[OspfLSupdpkt]]>>

<<function [[seprintospflsaheader]]>>

<<struct [[OspfDDpkt]]>>

<<function [[seprintospfdatadesc]]>>

<<function [[seprintospflsupdate]]>>

<<function [[seprintospflsack]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/ospf.c)]])>>

<<global [[ospf]]>>
@


\subsection*{[[networking/ip/snoopy/ppp.c]]}

<<enum [[_anon_ (networking/ip/snoopy/ppp.c)]]>>=
/* PPP stuff */
enum {
    PPP_addr=	0xff,
    PPP_ctl=	0x3,
    PPP_period=	3*1000,	/* period of retransmit process (in ms) */
};
@

<<enum [[_anon_ (networking/ip/snoopy/ppp.c)2]]>>=
/* PPP protocols */
enum {
    PPP_ip=		0x21,		/* internet */
    PPP_vjctcp=	0x2d,		/* compressing van jacobson tcp */
    PPP_vjutcp=	0x2f,		/* uncompressing van jacobson tcp */
    PPP_ml=		0x3d,		/* multi link */
    PPP_comp=	0xfd,		/* compressed packets */
    PPP_ipcp=	0x8021,		/* ip control */
    PPP_ccp=	0x80fd,		/* compression control */
    PPP_passwd=	0xc023,		/* passwd authentication */
    PPP_lcp=	0xc021,		/* link control */
    PPP_lqm=	0xc025,		/* link quality monitoring */
    PPP_chap=	0xc223,		/* challenge/response */
};
@

<<struct [[Lcppkt]]>>=
struct Lcppkt
{
    uchar	code;
    uchar	id;
    uchar	len[2];
    uchar	data[1];
};
@

<<struct [[Lcpopt]]>>=
struct Lcpopt
{
    uchar	type;
    uchar	len;
    uchar	data[1];
};
@

<<enum [[_anon_ (networking/ip/snoopy/ppp.c)3]]>>=
enum
{
    /* LCP codes */
    Lconfreq=	1,
    Lconfack=	2,
    Lconfnak=	3,
    Lconfrej=	4,
    Ltermreq=	5,
    Ltermack=	6,
    Lcoderej=	7,
    Lprotorej=	8,
    Lechoreq=	9,
    Lechoack=	10,
    Ldiscard=	11,
    Lresetreq=	14,	/* for ccp only */
    Lresetack=	15,	/* for ccp only */

    /* Lcp configure options */
    Omtu=		1,
    Octlmap=	2,
    Oauth=		3,
    Oquality=	4,
    Omagic=		5,
    Opc=		7,
    Oac=		8,

    /* authentication protocols */
    APmd5=		5,
    APmschap=	128,

    /* Chap codes */
    Cchallenge=	1,
    Cresponse=	2,
    Csuccess=	3,
    Cfailure=	4,

    /* ipcp configure options */
    Oipaddrs=	1,
    Oipcompress=	2,
    Oipaddr=	3,
    Oipdns=		129,
    Oipwins=	130,
    Oipdns2=	131,
    Oipwins2=	132,
};
@

<<global [[lcpcode]]>>=
char *
lcpcode[] = {
    0,
    "confreq",
    "confack",
    "confnak",
    "confrej",
    "termreq",
    "termack",
    "coderej",
    "protorej",
    "echoreq",
    "echoack",
    "discard",
    "id",
    "timeremain",
    "resetreq",
    "resetack",
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/ppp.c)]])>>=
static Mux p_mux[] =
{
    {"ip",		PPP_ip, },
    {"ppp_vjctcp",	PPP_vjctcp, },
    {"ppp_vjutcp",	PPP_vjutcp, },
    {"ppp_ml",	PPP_ml, },
    {"ppp_comp",	PPP_comp, },
    {"ppp_ipcp",	PPP_ipcp, },
    {"ppp_ccp",	PPP_ccp, },
    {"ppp_passwd",	PPP_passwd, },
    {"ppp_lcp",	PPP_lcp, },
    {"ppp_lqm",	PPP_lqm, },
    {"ppp_chap",	PPP_chap, },
    {0},
};
@

<<enum [[_anon_ (networking/ip/snoopy/ppp.c)4]]>>=
enum
{
    OOproto,
};
@

<<function [[p_compile]]([[(networking/ip/snoopy/ppp.c)]])>>=
static void
p_compile(Filter *f)
{
    Mux *m;

    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = OOproto;
            return;
        }

    sysfatal("unknown ppp field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/ppp.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    int proto;
    int len;

    if(f->subop != OOproto)
        return 0;

    len = m->pe - m->ps;
    if(len < 3)
        return -1;

    if(m->ps[0] == PPP_addr && m->ps[1] == PPP_ctl)
        m->ps += 2;

    proto = *m->ps++;
    if((proto&1) == 0)
        proto = (proto<<8) | *m->ps++;

    if(proto == f->ulv)
        return 1;

    return 0;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/ppp.c)]])>>=
static int
p_seprint(Msg *m)
{
    int proto;
    int len;

    len = m->pe - m->ps;
    if(len < 3)
        return -1;

    if(m->ps[0] == PPP_addr && m->ps[1] == PPP_ctl)
        m->ps += 2;

    proto = *m->ps++;
    if((proto&1) == 0)
        proto = (proto<<8) | *m->ps++;
    
    m->p = seprint(m->p, m->e, "pr=%ud len=%d", proto, len);
    demux(p_mux, proto, proto, m, &dump);

    return 0;
}
@

<<function [[p_seprintchap]]>>=
static int
p_seprintchap(Msg *m)
{
    Lcppkt *lcp;
    char *p, *e;
    int len;

    if(m->pe-m->ps < 4)
        return -1;

    p = m->p;
    e = m->e;
    m->pr = nil;

    /* resize packet */
    lcp = (Lcppkt*)m->ps;
    len = NetS(lcp->len);
    if(m->ps+len < m->pe)
        m->pe = m->ps+len;
    else if(m->ps+len > m->pe)
        return -1;

    p = seprint(p, e, "id=%d code=%d", lcp->id, lcp->code);
    switch(lcp->code) {
    default:
        p = seprint(p, e, " data=%.*H", len>64?64:len, lcp->data);
        break;
    case 1:
    case 2:
        if(lcp->data[0] > len-4){
            p = seprint(p, e, "%.*H", len-4, lcp->data);
        } else {
            p = seprint(p, e, " %s=", lcp->code==1?"challenge ":"response ");
            p = seprint(p, e, "%.*H", lcp->data[0], lcp->data+1);
            p = seprint(p, e, " name=");
            p = seprint(p, e, "%.*H", len-4-lcp->data[0]-1, lcp->data+lcp->data[0]+1);
        }
        break;
    case 3:
    case 4:
        if(len > 64)
            len = 64;
        p = seprint(p, e, " %s=%.*H", lcp->code==3?"success ":"failure",
                len>64?64:len, lcp->data);
        break;
    }
    m->p = seprint(p, e, " len=%d", len);
    return 0;
}
@

<<function [[seprintlcpopt]]>>=
static char*
seprintlcpopt(char *p, char *e, void *a, int len)
{
    Lcpopt *o;
    int proto, x, period;
    uchar *cp, *ecp;

    cp = a;
    ecp = cp+len;

    for(; cp < ecp; cp += o->len){
        o = (Lcpopt*)cp;
        if(cp + o->len > ecp || o->len == 0){
            p = seprint(p, e, " bad-opt-len=%d", o->len);
            return p;
        }

        switch(o->type){
        default:
            p = seprint(p, e, " (type=%d len=%d)", o->type, o->len);
            break;
        case Omtu:
            p = seprint(p, e, " mtu=%d", NetS(o->data));
            break;
        case Octlmap:
            p = seprint(p, e, " ctlmap=%ux", NetL(o->data));
            break;
        case Oauth:
            proto = NetS(o->data);
            switch(proto) {
            default:
                p = seprint(p, e, " auth=%d", proto);
                break;
            case PPP_passwd:
                p = seprint(p, e, " auth=passwd");
                break;
            case PPP_chap:
                p = seprint(p, e, " (auth=chap data=%2.2ux)", o->data[2]);
                break;
            }
            break;
        case Oquality:
            proto = NetS(o->data);
            switch(proto) {
            default:
                p = seprint(p, e, " qproto=%d", proto);
                break;
            case PPP_lqm:
                x = NetL(o->data+2)*10;
                period = (x+(PPP_period-1))/PPP_period;
                p = seprint(p, e, " (qproto=lqm period=%d)", period);
                break;
            }
        case Omagic:
            p = seprint(p, e, " magic=%ux", NetL(o->data));
            break;
        case Opc:
            p = seprint(p, e, " protocol-compress");
            break;
        case Oac:
            p = seprint(p, e, " addr-compress");
            break;
        }
    }
    return p;
}
@

<<function [[p_seprintlcp]]>>=
static int
p_seprintlcp(Msg *m)
{
    Lcppkt *lcp;
    char *p, *e;
    int len;

    if(m->pe-m->ps < 4)
        return -1;

    p = m->p;
    e = m->e;
    m->pr = nil;

    lcp = (Lcppkt*)m->ps;
    len = NetS(lcp->len);
    if(m->ps+len < m->pe)
        m->pe = m->ps+len;
    else if(m->ps+len > m->pe)
        return -1;

    p = seprint(p, e, "id=%d code=%d", lcp->id, lcp->code);
    switch(lcp->code) {
    default:
        p = seprint(p, e, " data=%.*H", len>64?64:len, lcp->data);
        break;
    case Lconfreq:
    case Lconfack:
    case Lconfnak:
    case Lconfrej:
        p = seprint(p, e, "=%s", lcpcode[lcp->code]);
        p = seprintlcpopt(p, e, lcp->data, len-4);
        break;
    case Ltermreq:
    case Ltermack:
    case Lcoderej:
    case Lprotorej:
    case Lechoreq:
    case Lechoack:
    case Ldiscard:
        p = seprint(p, e, "=%s", lcpcode[lcp->code]);
        break;
    }
    m->p = seprint(p, e, " len=%d", len);
    return 0;
}
@

<<function [[seprintipcpopt]]>>=
static char*
seprintipcpopt(char *p, char *e, void *a, int len)
{
    Lcpopt *o;
    uchar *cp, *ecp;

    cp = a;
    ecp = cp+len;

    for(; cp < ecp; cp += o->len){
        o = (Lcpopt*)cp;
        if(cp + o->len > ecp){
            p = seprint(p, e, " bad opt len %ux", o->type);
            return p;
        }

        switch(o->type){
        default:
            p = seprint(p, e, " (type=%d len=%d)", o->type, o->len);
            break;
        case Oipaddrs:	
            p = seprint(p, e, " ipaddrs(deprecated)");
            break;
        case Oipcompress:
            p = seprint(p, e, " ipcompress");
            break;
        case Oipaddr:	
            p = seprint(p, e, " ipaddr=%V", o->data);
            break;
        case Oipdns:	
            p = seprint(p, e, " dnsaddr=%V", o->data);
            break;
        case Oipwins:	
            p = seprint(p, e, " winsaddr=%V", o->data);
            break;
        case Oipdns2:	
            p = seprint(p, e, " dns2addr=%V", o->data);
            break;
        case Oipwins2:	
            p = seprint(p, e, " wins2addr=%V", o->data);
            break;
        }
    }
    return p;
}
@

<<function [[p_seprintipcp]]>>=
static int
p_seprintipcp(Msg *m)
{
    Lcppkt *lcp;
    char *p, *e;
    int len;

    if(m->pe-m->ps < 4)
        return -1;

    p = m->p;
    e = m->e;
    m->pr = nil;

    lcp = (Lcppkt*)m->ps;
    len = NetS(lcp->len);
    if(m->ps+len < m->pe)
        m->pe = m->ps+len;
    else if(m->ps+len > m->pe)
        return -1;
        
    p = seprint(p, e, "id=%d code=%d", lcp->id, lcp->code);
    switch(lcp->code) {
    default:
        p = seprint(p, e, " data=%.*H", len>64?64:len, lcp->data);
        break;
    case Lconfreq:
    case Lconfack:
    case Lconfnak:
    case Lconfrej:
        p = seprint(p, e, "=%s", lcpcode[lcp->code]);
        p = seprintipcpopt(p, e, lcp->data, len-4);
        break;
    case Ltermreq:
    case Ltermack:
        p = seprint(p, e, "=%s", lcpcode[lcp->code]);
        break;
    }
    m->p = seprint(p, e, " len=%d", len);
    return 0;
}
@

<<function [[seprintccpopt]]>>=
static char*
seprintccpopt(char *p, char *e, void *a, int len)
{
    Lcpopt *o;
    uchar *cp, *ecp;

    cp = a;
    ecp = cp+len;

    for(; cp < ecp; cp += o->len){
        o = (Lcpopt*)cp;
        if(cp + o->len > ecp){
            p = seprint(p, e, " bad opt len %ux", o->type);
            return p;
        }
        
        switch(o->type){
        default:
            p = seprint(p, e, " type=%d ", o->type);
            break;
        case 0:
            p = seprint(p, e, " OUI=(%d %.2ux%.2ux%.2ux) ", o->type, 
                o->data[0], o->data[1], o->data[2]);
            break;
        case 17:
            p = seprint(p, e, " Stac-LZS");
            break;
        case 18:
            p = seprint(p, e, " Microsoft-PPC=%ux", NetL(o->data));
            break;
        }
    }
    return p;
}
@

<<function [[p_seprintccp]]>>=
static int
p_seprintccp(Msg *m)
{
    Lcppkt *lcp;
    char *p, *e;
    int len;

    if(m->pe-m->ps < 4)
        return -1;

    p = m->p;
    e = m->e;
    m->pr = nil;

    lcp = (Lcppkt*)m->ps;
    len = NetS(lcp->len);
    if(m->ps+len < m->pe)
        m->pe = m->ps+len;
    else if(m->ps+len > m->pe)
        return -1;
        
    p = seprint(p, e, "id=%d code=%d", lcp->id, lcp->code);
    switch(lcp->code) {
    default:
        p = seprint(p, e, " data=%.*H", len>64?64:len, lcp->data);
        break;
    case Lconfreq:
    case Lconfack:
    case Lconfnak:
    case Lconfrej:
        p = seprint(p, e, "=%s", lcpcode[lcp->code]);
        p = seprintccpopt(p, e, lcp->data, len-4);
        break;
    case Ltermreq:
    case Ltermack:
    case Lresetreq:
    case Lresetack:
        p = seprint(p, e, "=%s", lcpcode[lcp->code]);
        break;
    }
    m->p = seprint(p, e, " len=%d", len);
    
    return 0;
}
@

<<function [[p_seprintcomp]]>>=
static int
p_seprintcomp(Msg *m)
{
    char compflag[5];
    ushort x;
    int i;
    int len;

    len = m->pe-m->ps;
    if(len < 2)
        return -1;

    x = NetS(m->ps);
    m->ps += 2;
    i = 0;
    if(x & (1<<15))
        compflag[i++] = 'r';
    if(x & (1<<14))
        compflag[i++] = 'f';
    if(x & (1<<13))
        compflag[i++] = 'c';
    if(x & (1<<12))
        compflag[i++] = 'e';
    compflag[i] = 0;
    m->p = seprint(m->p, m->e, "flag=%s count=%.3ux", compflag, x&0xfff);
    m->p = seprint(m->p, m->e, " data=%.*H", len>64?64:len, m->ps);
    m->pr = nil;
    return 0;
}
@

<<global [[ppp]]>>=
Proto ppp =
{
    "ppp",
    p_compile,
    p_filter,
    p_seprint,
    p_mux,
    "%#.4lux",
    nil,
    defaultframer,
};
@

<<global [[ppp_ipcp]]>>=
Proto ppp_ipcp =
{
    "ppp_ipcp",
    p_compile,
    p_filter,
    p_seprintipcp,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<global [[ppp_lcp]]>>=
Proto ppp_lcp =
{
    "ppp_lcp",
    p_compile,
    p_filter,
    p_seprintlcp,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<global [[ppp_ccp]]>>=
Proto ppp_ccp =
{
    "ppp_ccp",
    p_compile,
    p_filter,
    p_seprintccp,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<global [[ppp_chap]]>>=
Proto ppp_chap =
{
    "ppp_chap",
    p_compile,
    p_filter,
    p_seprintchap,
    nil,
    nil,
    nil,
    defaultframer,
};
@

<<global [[ppp_comp]]>>=
Proto ppp_comp =
{
    "ppp_comp",
    p_compile,
    p_filter,
    p_seprintcomp,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/ppp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <libsec.h>
#include "dat.h"
#include "protos.h"

<<enum [[_anon_ (networking/ip/snoopy/ppp.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/ppp.c)2]]>>

/* LCP protocol (and IPCP) */


typedef struct Lcppkt	Lcppkt;
<<struct [[Lcppkt]]>>

typedef struct Lcpopt	Lcpopt;
<<struct [[Lcpopt]]>>

<<enum [[_anon_ (networking/ip/snoopy/ppp.c)3]]>>

<<global [[lcpcode]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/ppp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/ppp.c)4]]>>

<<function [[p_compile]]([[(networking/ip/snoopy/ppp.c)]])>>

<<function [[p_filter]]([[(networking/ip/snoopy/ppp.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/ppp.c)]])>>

<<function [[p_seprintchap]]>>

<<function [[seprintlcpopt]]>>


<<function [[p_seprintlcp]]>>

<<function [[seprintipcpopt]]>>

<<function [[p_seprintipcp]]>>

<<function [[seprintccpopt]]>>

<<function [[p_seprintccp]]>>

<<function [[p_seprintcomp]]>>

<<global [[ppp]]>>

<<global [[ppp_ipcp]]>>

<<global [[ppp_lcp]]>>

<<global [[ppp_ccp]]>>

<<global [[ppp_chap]]>>

<<global [[ppp_comp]]>>
@


\subsection*{[[networking/ip/snoopy/ppp_ccp.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/ppp_ccp.c>>=
/* place holder, this stuff is really in ppp.c */
@


\subsection*{[[networking/ip/snoopy/ppp_chap.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/ppp_chap.c>>=
/* place holder, this stuff is really in ppp.c */
@


\subsection*{[[networking/ip/snoopy/ppp_comp.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/ppp_comp.c>>=
/* place holder, this stuff is really in ppp.c */
@


\subsection*{[[networking/ip/snoopy/ppp_ipcp.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/ppp_ipcp.c>>=
/* place holder, this stuff is really in ppp.c */
@


\subsection*{[[networking/ip/snoopy/ppp_lcp.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/ppp_lcp.c>>=
/* place holder, this stuff is really in ppp.c */
@


\subsection*{[[networking/ip/snoopy/pppoe_disc.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/pppoe_disc.c)]])>>=
struct Hdr {
    uchar verstype;
    uchar code;
    uchar sessid[2];
    uchar length[2];	/* of payload */
};
@

<<enum [[_anon_ (networking/ip/snoopy/pppoe_disc.c)]]>>=
enum
{
    HDRSIZE = 1+1+2+2
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/pppoe_disc.c)]])>>=
static Mux p_mux[] =
{
    {"ppp",		0,	} ,
    {0}
};
@

<<enum [[_anon_ (networking/ip/snoopy/pppoe_disc.c)2]]>>=
enum
{
    Overs,
    Otype,
    Ocode,
    Osess,
};
@

<<global [[p_fields]]([[(networking/ip/snoopy/pppoe_disc.c)]])>>=
static Field p_fields[] = 
{
    {"v",	Fnum,	Overs,	"version",	} ,
    {"t",	Fnum,	Otype,	"type",	} ,
    {"c",	Fnum,	Ocode,	"code" } ,
    {"s",	Fnum,	Osess,	"sessid" } ,
    {0}
};
@

<<function [[p_compilesess]]>>=
static void
p_compilesess(Filter *f)
{
//	Mux *m;

    if(f->op == '='){
        compile_cmp(pppoe_sess.name, f, p_fields);
        return;
    }
/*
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
*/
    sysfatal("unknown pppoe field or protocol: %s", f->s);
}
@

<<function [[p_compiledisc]]>>=
static void
p_compiledisc(Filter *f)
{
//	Mux *m;

    if(f->op == '='){
        compile_cmp(pppoe_disc.name, f, p_fields);
        return;
    }
/*
    for(m = p_mux; m->name != nil; m++)
        if(strcmp(f->s, m->name) == 0){
            f->pr = m->pr;
            f->ulv = m->val;
            f->subop = Ot;
            return;
        }
*/
    sysfatal("unknown pppoe field or protocol: %s", f->s);
}
@

<<function [[p_filter]]([[(networking/ip/snoopy/pppoe_disc.c)]])>>=
static int
p_filter(Filter *f, Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < HDRSIZE)
        return 0;

    h = (Hdr*)m->ps;
    m->ps += HDRSIZE;

    switch(f->subop){
    case Overs:
        return (h->verstype>>4) == f->ulv;
    case Otype:
        return (h->verstype&0xF) == f->ulv;
    case Ocode:
        return h->code == f->ulv;
    case Osess:
        return NetS(h->sessid) == f->ulv;
    }
    return 0;
}
@

<<function [[p_seprintdisc]]>>=
/* BUG: print all the discovery types */
static int
p_seprintdisc(Msg *m)
{
    Hdr *h;
    int len;

    len = m->pe - m->ps;
    if(len < HDRSIZE)
        return -1;

    h = (Hdr*)m->ps;
    m->ps += HDRSIZE;

    m->pr = nil;

    m->p = seprint(m->p, m->e, "v=%d t=%d c=0x%x s=0x%ux, len=%d",
        h->verstype>>4, h->verstype&0xF, h->code, NetS(h->sessid), NetS(h->length));

    return 0;
}
@

<<function [[p_seprintsess]]>>=
static int
p_seprintsess(Msg *m)
{
    Hdr *h;
    int len;

    len = m->pe - m->ps;
    if(len < HDRSIZE)
        return -1;

    h = (Hdr*)m->ps;
    m->ps += HDRSIZE;

    /* this will call ppp for me */
    demux(p_mux, 0, 0, m, &dump);

    m->p = seprint(m->p, m->e, "v=%d t=%d c=0x%x s=0x%ux, len=%d",
        h->verstype>>4, h->verstype&0xF, h->code, NetS(h->sessid), NetS(h->length));

    return 0;
}
@

<<global [[pppoe_disc]]>>=
Proto pppoe_disc =
{
    "pppoe_disc",
    p_compiledisc,
    p_filter,
    p_seprintdisc,
    p_mux,
    "%lud",
    p_fields,
    defaultframer
};
@

<<global [[pppoe_sess]]>>=
Proto pppoe_sess =
{
    "pppoe_sess",
    p_compilesess,
    p_filter,
    p_seprintsess,
    p_mux,
    "%lud",
    p_fields,
    defaultframer
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/pppoe_disc.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/pppoe_disc.c)]])>>
<<enum [[_anon_ (networking/ip/snoopy/pppoe_disc.c)]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/pppoe_disc.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/pppoe_disc.c)2]]>>

<<global [[p_fields]]([[(networking/ip/snoopy/pppoe_disc.c)]])>>

<<function [[p_compilesess]]>>
<<function [[p_compiledisc]]>>

<<function [[p_filter]]([[(networking/ip/snoopy/pppoe_disc.c)]])>>

<<function [[p_seprintdisc]]>>

<<function [[p_seprintsess]]>>

<<global [[pppoe_disc]]>>

<<global [[pppoe_sess]]>>

@


\subsection*{[[networking/ip/snoopy/pppoe_sess.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/pppoe_sess.c>>=
/* placeholder; see pppoe_disc.c */
@


\subsection*{[[networking/ip/snoopy/rarp.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/rarp.c>>=
/* place holder, this stuff is really in arp.c */
@


\subsection*{[[networking/ip/snoopy/rc4keydesc.c]]}


%-------------------------------------------------------------

<<networking/ip/snoopy/rc4keydesc.c>>=
/* place holder, this stuff is really in eapol_key.c */
@


\subsection*{[[networking/ip/snoopy/rtcp.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/rtcp.c)]])>>=
struct Hdr {
    uchar	hdr;		/* RTCP header */
    uchar	pt;		/* Packet type */
    uchar	len[2];		/* Report length */
    uchar	ssrc[4];	/* Synchronization source identifier */
    uchar	ntp[8];		/* NTP time stamp */
    uchar	rtp[4];		/* RTP time stamp */
    uchar	pktc[4];	/* Sender's packet count */
    uchar	octc[4];	/* Sender's octet count */
};
@

<<struct [[Report]]>>=
struct Report {
    uchar	ssrc[4];	/* SSRC identifier */
    uchar	lost[4];	/* Fraction + cumu lost */
    uchar	seqhi[4];	/* Highest seq number received */
    uchar	jitter[4];	/* Interarrival jitter */
    uchar	lsr[4];		/* Last SR */
    uchar	dlsr[4];	/* Delay since last SR */
};
@

<<enum [[_anon_ (networking/ip/snoopy/rtcp.c)]]>>=
enum{
    RTCPLEN = 28,		/* Minimum size of an RTCP header */
    REPORTLEN = 24,
};
@

<<function [[p_seprint]]([[(networking/ip/snoopy/rtcp.c)]])>>=
static int
p_seprint(Msg *m)
{
    int rc, i, frac;
    float dlsr;
    Hdr*h;
    Report*r;

    if(m->pe - m->ps < RTCPLEN)
        return -1;

    h = (Hdr*)m->ps;
    if(m->pe - m->ps < (NetS(h->len) + 1) * 4)
        return -1;

    rc = h->hdr & 0x1f;
    m->ps += RTCPLEN;
    m->p = seprint(m->p, m->e, "version=%d rc=%d tp=%d ssrc=%8ux "
        "ntp=%d.%.10ud rtp=%d pktc=%d octc=%d hlen=%d",
        (h->hdr >> 6) & 3, rc, h->pt, NetL(h->ssrc), NetL(h->ntp),
        (uint)NetL(&h->ntp[4]), NetL(h->rtp), NetL(h->pktc),
        NetL(h->octc), (NetS(h->len) + 1) * 4);

    for(i = 0; i < rc; i++){
        r = (Report*)m->ps;
        m->ps += REPORTLEN;

        frac = (int)((r->lost[0] * 100.) / 256.);
        r->lost[0] = 0;
        dlsr = NetL(r->dlsr) / 65536.;

        m->p = seprint(m->p, m->e, "\n\trr(csrc=%8ux frac=%3d%% "
            "cumu=%10d seqhi=%10ud jitter=%10d lsr=%8ux dlsr=%f)",
            NetL(r->ssrc), frac, NetL(r->lost), NetL(r->seqhi),
            NetL(r->jitter), NetL(r->lsr), dlsr);
    }
    m->pr = nil;
    return 0;
}
@

<<global [[rtcp]]>>=
Proto rtcp = {
    "rtcp",
    nil,
    nil,
    p_seprint,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/rtcp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/rtcp.c)]])>>

typedef struct Report Report;
<<struct [[Report]]>>

<<enum [[_anon_ (networking/ip/snoopy/rtcp.c)]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/rtcp.c)]])>>

<<global [[rtcp]]>>
@


\subsection*{[[networking/ip/snoopy/rtp.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/rtp.c)]])>>=
struct Hdr {
    uchar	hdr;		/* RTP header */
    uchar	marker;		/* Payload and marker */
    uchar	seq[2];		/* Sequence number */
    uchar	ts[4];		/* Time stamp */
    uchar	ssrc[4];	/* Synchronization source identifier */
};
@

<<enum [[_anon_ (networking/ip/snoopy/rtp.c)]]>>=
enum{
    RTPLEN = 12,		/* Minimum size of an RTP header */
};
@

<<function [[p_seprint]]([[(networking/ip/snoopy/rtp.c)]])>>=
static int
p_seprint(Msg *m)
{
    int cc, i;
    ushort seq;
    ulong ssrc, ts;
    Hdr*h;

    if(m->pe - m->ps < RTPLEN)
        return -1;

    h = (Hdr*)m->ps;
    cc = h->hdr & 0xf;
    if(m->pe - m->ps < RTPLEN + cc * 4)
        return -1;

    m->ps += RTPLEN;

    seq = NetS(h->seq);
    ts = NetL(h->ts);
    ssrc = NetL(h->ssrc);

    m->p = seprint(m->p, m->e, "version=%d x=%d cc=%d seq=%d ts=%ld ssrc=%ulx",
        (h->hdr >> 6) & 3, (h->hdr >> 4) & 1, cc, seq, ts, ssrc);
    for(i = 0; i < cc; i++){
        m->p = seprint(m->p, m->e, " csrc[%d]=%d", i, NetL(m->ps));
        m->ps += 4;
    }
    m->pr = nil;
    return 0;
}
@

<<global [[rtp]]>>=
Proto rtp = {
    "rtp",
    nil,
    nil,
    p_seprint,
    nil,
    nil,
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/rtp.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/rtp.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/rtp.c)]]>>

<<function [[p_seprint]]([[(networking/ip/snoopy/rtp.c)]])>>

<<global [[rtp]]>>
@


\subsection*{[[networking/ip/snoopy/ttls.c]]}

<<struct [[Hdr]]([[(networking/ip/snoopy/ttls.c)]])>>=
struct Hdr
{
    uchar	flags;
    uchar	ln[4];	/* optional, present if L flag set*/
};
@

<<enum [[_anon_ (networking/ip/snoopy/ttls.c)]]>>=
enum
{
    FLHDR=	1,	/* sizeof(flags) */
    LNHDR=	4,	/* sizeof(ln) */
};
@

<<enum [[_anon_ (networking/ip/snoopy/ttls.c)2]]>>=
enum
{
    FlagL = 1<<7, 
    FlagM = 1<<6,
    FlagS = 1<<5,
    Version = (1<<2)|(1<<1)|(1<<0),
};
@

<<global [[p_mux]]([[(networking/ip/snoopy/ttls.c)]])>>=
static Mux p_mux[] =
{
    { "dump", 0, },
    { 0 }
};
@

<<function [[flags]]([[(networking/ip/snoopy/ttls.c)]])>>=
static char*
flags(int f)
{
    static char fl[20];
    char *p;

    p = fl;
    if(f & FlagS)
        *p++ = 'S';
    if(f & FlagM)
        *p++ = 'M';
    if(f & FlagL)
        *p++ = 'L';
    *p = 0;
    return fl;
}
@

<<function [[p_seprint]]([[(networking/ip/snoopy/ttls.c)]])>>=
static int
p_seprint(Msg *m)
{
    Hdr *h;

    if(m->pe - m->ps < FLHDR)
        return -1;

    h = (Hdr*)m->ps;
    m->ps += FLHDR;

    if (h->flags & FlagL) {
        if(m->pe - m->ps < LNHDR)
            return -1;
        else
            m->ps += LNHDR;
    }

    /* next protocol  depending on type*/
    demux(p_mux, 0, 0, m, &dump);

    m->p = seprint(m->p, m->e, "ver=%1d", h->flags & Version);
    m->p = seprint(m->p, m->e, " fl=%s", flags(h->flags));

    if (h->flags & FlagL)
        m->p = seprint(m->p, m->e, " totallen=%1d", NetL(h->ln));

    /* these are not in the header, just print them for our convenience */
    m->p = seprint(m->p, m->e, " dataln=%1ld", m->pe - m->ps);
    if ((h->flags & (FlagL|FlagS|FlagM)) == 0 && m->ps == m->pe)
        m->p = seprint(m->p, m->e, " ack");

    return 0;
}
@

<<global [[ttls]]>>=
Proto ttls =
{
    "ttls",
    nil,
    nil,
    p_seprint,
    p_mux, /* we need this to get the dump printed */
    "%lud",
    nil,
    defaultframer,
};
@


%-------------------------------------------------------------

<<networking/ip/snoopy/ttls.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dat.h"
#include "protos.h"

typedef struct Hdr	Hdr;
<<struct [[Hdr]]([[(networking/ip/snoopy/ttls.c)]])>>

<<enum [[_anon_ (networking/ip/snoopy/ttls.c)]]>>

<<enum [[_anon_ (networking/ip/snoopy/ttls.c)2]]>>

<<global [[p_mux]]([[(networking/ip/snoopy/ttls.c)]])>>

<<function [[flags]]([[(networking/ip/snoopy/ttls.c)]])>>

<<function [[p_seprint]]([[(networking/ip/snoopy/ttls.c)]])>>

<<global [[ttls]]>>
@


\section{[[networking/ip/]]}

\subsection*{[[networking/ip/rarpd.c]]}

<<struct [[Rarp]]>>=
struct Rarp
{
    uchar	edst[6];
    uchar	esrc[6];
    uchar	type[2];
    uchar	hrd[2];
    uchar	pro[2];
    uchar	hln;
    uchar	pln;
    uchar	op[2];
    uchar	sha[6];
    uchar	spa[4];
    uchar	tha[6];
    uchar	tpa[4];
};
@

<<global [[myip]]([[(networking/ip/rarpd.c)]])>>=
uchar	myip[IPaddrlen];
@

<<global [[myether]]>>=
uchar	myether[6];
@

<<global [[rlog]]>>=
char	rlog[] = "ipboot";
@

<<global [[device]]>>=
char	*device = "ether0";
@

<<global [[debug]]([[(networking/ip/rarpd.c)]])>>=
int	debug;
@

<<global [[db]]>>=
Ndb	*db;
@

<<function [[error]]([[(networking/ip/rarpd.c)]])>>=
void
error(char *s)
{
    syslog(1, rlog, "error %s: %r", s);
    exits(s);
}
@

<<global [[net]]([[(networking/ip/rarpd.c)]])>>=
char net[32];
@

<<function [[usage]]([[(networking/ip/rarpd.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-e device] [-x netmtpt] [-f ndb-file] [-d]\n", argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/rarpd.c)]])>>=
void
main(int argc, char *argv[])
{
    int edata, ectl;
    uchar buf[2048];
    long n;
    Rarp *rp;
    char ebuf[16];
    char ipbuf[64];
    char file[128];
    int arp;
    char *p, *ndbfile;

    ndbfile = nil;
    setnetmtpt(net, sizeof(net), nil);
    ARGBEGIN{
    case 'e':
        p = ARGF();
        if(p == nil)
            usage();
        device = p;
        break;
    case 'd':
        debug = 1;
        break;
    case 'f':
        p = ARGF();
        if(p == nil)
            usage();
        ndbfile = p;
        break;
    case 'x':
        p = ARGF();
        if(p == nil)
            usage();
        setnetmtpt(net, sizeof(net), p);
        break;
    }ARGEND
    USED(argc, argv);

    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('V', eipfmt);

    db = ndbopen(ndbfile);
    if(db == 0)
        error("can't open the database");

    edata = dial(netmkaddr("0x8035", device, 0), 0, 0, &ectl);
    if(edata < 0)
        error("can't open ethernet");

    if(myipaddr(myip, net) < 0)
        error("can't get my ip address");
    sprint(ebuf, "%s/%s", net, device);
    if(myetheraddr(myether, ebuf) < 0)
        error("can't get my ether address");

    snprint(file, sizeof(file), "%s/arp", net);
    if((arp = open(file, ORDWR)) < 0)
        fprint(2, "rarpd: can't open %s\n", file);

    switch(rfork(RFNOTEG|RFPROC|RFFDG)) {
    case -1:
        error("fork");
    case 0:
        break;
    default:
        exits(0);
    }

    for(;;){
        n = read(edata, buf, sizeof(buf));
        if(n <= 0)
            error("reading");
        if(n < sizeof(Rarp)){
            syslog(debug, rlog, "bad packet size %ld", n);
            continue;
        }
        rp = (Rarp*)buf;
        if(rp->op[0]!=0 && rp->op[1]!=3){
            syslog(debug, rlog, "bad op %d %d %E",
                rp->op[1], rp->op[0], rp->esrc);
            continue;
        }

        if(debug)
            syslog(debug, rlog, "rcv se %E si %V te %E ti %V",
                 rp->sha, rp->spa, rp->tha, rp->tpa);

        sprint(ebuf, "%E", rp->tha);
        if(lookup("ether", ebuf, "ip", ipbuf, sizeof ipbuf) == nil){
            syslog(debug, rlog, "client lookup failed: %s", ebuf);
            continue;
        }
        v4parseip(rp->tpa, ipbuf);

        memmove(rp->sha, myether, sizeof(rp->sha));
        v6tov4(rp->spa, myip);

        rp->op[0] = 0;
        rp->op[1] = 4;
        memmove(rp->edst, rp->esrc, sizeof(rp->edst));

        if(debug)
            syslog(debug, rlog, "send se %E si %V te %E ti %V",
                 rp->sha, rp->spa, rp->tha, rp->tpa);

        if(write(edata, buf, 60) != 60)
            error("write failed");

        if(arp < 0)
            continue;
        if(fprint(arp, "add %E %V", rp->esrc, rp->tpa) < 0)
            fprint(2, "can't write arp entry\n");
    }
}
@

<<function [[lookup]]([[(networking/ip/rarpd.c)]])>>=
char*
lookup(char *sattr, char *sval, char *tattr, char *tval, int len)
{
    static Ndb *db;
    char *attrs[1];
    Ndbtuple *t;

    if(db == nil)
        db = ndbopen(0);
    if(db == nil)
        return nil;

    if(sattr == nil)
        sattr = ipattr(sval);

    attrs[0] = tattr;
    t = ndbipinfo(db, sattr, sval, attrs, 1);
    if(t == nil)
        return nil;
    strncpy(tval, t->val, len);
    tval[len-1] = 0;
    ndbfree(t);
    return tval;
}
@


%-------------------------------------------------------------

<<networking/ip/rarpd.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ip.h>
#include <ndb.h>
#include "arp.h"

typedef struct Rarp	Rarp;

<<struct [[Rarp]]>>

<<global [[myip]]([[(networking/ip/rarpd.c)]])>>
<<global [[myether]]>>
<<global [[rlog]]>>
<<global [[device]]>>
<<global [[debug]]([[(networking/ip/rarpd.c)]])>>
<<global [[db]]>>

char*	lookup(char*, char*, char*, char*, int);

<<function [[error]]([[(networking/ip/rarpd.c)]])>>

<<global [[net]]([[(networking/ip/rarpd.c)]])>>

<<function [[usage]]([[(networking/ip/rarpd.c)]])>>

<<function [[main]]([[(networking/ip/rarpd.c)]])>>

<<function [[lookup]]([[(networking/ip/rarpd.c)]])>>
@


\subsection*{[[networking/ip/rlogind.c]]}

<<function [[main]]([[(networking/ip/rlogind.c)]])>>=
void
main(void)
{
    char luser[128], ruser[128], term[128], err[128];

    getstr(0, err, sizeof(err));
    getstr(0, ruser, sizeof(ruser));
    getstr(0, luser, sizeof(luser));
    getstr(0, term, sizeof(term));
    write(0, "", 1);

    if(luser[0] == '\0')
        strncpy(luser, ruser, sizeof luser);
    luser[sizeof luser-1] = '\0';
    syslog(0, "telnet", "rlogind %s", luser);
    execl("/bin/ip/telnetd", "telnetd", "-n", "-u", luser, nil);
    fprint(2, "can't exec con service: %r\n");
    exits("can't exec");
}
@

<<function [[getstr]]>>=
void
getstr(int fd, char *str, int len)
{
    char c;
    int n;

    while(--len > 0){
        n = read(fd, &c, 1);
        if(n < 0)
            return;
        if(n == 0)
            continue;
        *str++ = c;
        if(c == 0)
            break;
    }
    *str = '\0';
}
@


%-------------------------------------------------------------

<<networking/ip/rlogind.c>>=
#include <u.h>
#include <libc.h>

void	getstr(int, char*, int);

<<function [[main]]([[(networking/ip/rlogind.c)]])>>

<<function [[getstr]]>>
@


\section{[[networking/ndb/]]}

\subsection*{[[networking/ndb/convDNS2M.c]]}

<<enum [[_anon_ (networking/ndb/convDNS2M.c)]]>>=
/*
 *  a dictionary of domain names for packing messages
 */
enum
{
    Ndict=	64,
};
@

<<struct [[Dict]]>>=
struct Dict
{
    struct {
        ushort	offset;		/* pointer to packed name in message */
        char	*name;		/* pointer to unpacked name in buf */
    } x[Ndict];
    int	n;		/* size of dictionary */
    uchar	*start;		/* start of packed message */
    char	buf[16*1024];	/* buffer for unpacked names (was 4k) */
    char	*ep;		/* first free char in buf */
};
@

<<macro [[NAME]]>>=
#define NAME(x)		p = pname(p, ep, x, dp)
@

<<macro [[SYMBOL]]>>=
#define SYMBOL(x)	p = psym(p, ep, x)
@

<<macro [[STRING]]>>=
#define STRING(x)	p = pstr(p, ep, x)
@

<<macro [[BYTES]]>>=
#define BYTES(x, n)	p = pbytes(p, ep, x, n)
@

<<macro [[USHORT]]>>=
#define USHORT(x)	p = pushort(p, ep, x)
@

<<macro [[UCHAR]]>>=
#define UCHAR(x)	p = puchar(p, ep, x)
@

<<macro [[ULONG]]>>=
#define ULONG(x)	p = pulong(p, ep, x)
@

<<macro [[V4ADDR]]>>=
#define V4ADDR(x)	p = pv4addr(p, ep, x)
@

<<macro [[V6ADDR]]>>=
#define V6ADDR(x)	p = pv6addr(p, ep, x)
@

<<function [[psym]]>>=
static uchar*
psym(uchar *p, uchar *ep, char *np)
{
    int n;

    n = strlen(np);
    if(n >= Strlen)			/* DNS maximum length string */
        n = Strlen - 1;
    if(ep - p < n+1)		/* see if it fits in the buffer */
        return ep+1;
    *p++ = n;
    memmove(p, np, n);
    return p + n;
}
@

<<function [[pstr]]>>=
static uchar*
pstr(uchar *p, uchar *ep, char *np)
{
    return psym(p, ep, np);
}
@

<<function [[pbytes]]>>=
static uchar*
pbytes(uchar *p, uchar *ep, uchar *np, int n)
{
    if(ep - p < n)
        return ep+1;
    memmove(p, np, n);
    return p + n;
}
@

<<function [[puchar]]>>=
static uchar*
puchar(uchar *p, uchar *ep, int val)
{
    if(ep - p < 1)
        return ep+1;
    *p++ = val;
    return p;
}
@

<<function [[pushort]]>>=
static uchar*
pushort(uchar *p, uchar *ep, int val)
{
    if(ep - p < 2)
        return ep+1;
    *p++ = val>>8;
    *p++ = val;
    return p;
}
@

<<function [[pulong]]>>=
static uchar*
pulong(uchar *p, uchar *ep, int val)
{
    if(ep - p < 4)
        return ep+1;
    *p++ = val>>24;
    *p++ = val>>16;
    *p++ = val>>8;
    *p++ = val;
    return p;
}
@

<<function [[pv4addr]]>>=
static uchar*
pv4addr(uchar *p, uchar *ep, char *name)
{
    uchar ip[IPaddrlen];

    if(ep - p < 4)
        return ep+1;
    parseip(ip, name);
    v6tov4(p, ip);
    return p + 4;
}
@

<<function [[pv6addr]]>>=
static uchar*
pv6addr(uchar *p, uchar *ep, char *name)
{
    if(ep - p < IPaddrlen)
        return ep+1;
    parseip(p, name);
    return p + IPaddrlen;
}
@

<<function [[pname]]>>=
static uchar*
pname(uchar *p, uchar *ep, char *np, Dict *dp)
{
    int i;
    char *cp;
    char *last;		/* last component packed */

    if(strlen(np) >= Domlen) /* make sure we don't exceed DNS limits */
        return ep+1;

    last = 0;
    while(*np){
        /* look through every component in the dictionary for a match */
        for(i = 0; i < dp->n; i++)
            if(strcmp(np, dp->x[i].name) == 0){
                if(ep - p < 2)
                    return ep+1;
                if ((dp->x[i].offset>>8) & 0xc0)
                    dnslog("convDNS2M: offset too big for "
                        "DNS packet format");
                *p++ = dp->x[i].offset>>8 | 0xc0;
                *p++ = dp->x[i].offset;
                return p;
            }

        /* if there's room, enter this name in dictionary */
        if(dp->n < Ndict)
            if(last){
                /* the whole name is already in dp->buf */
                last = strchr(last, '.') + 1;
                dp->x[dp->n].name = last;
                dp->x[dp->n].offset = p - dp->start;
                dp->n++;
            } else {
                /* add to dp->buf */
                i = strlen(np);
                if(dp->ep + i + 1 < &dp->buf[sizeof dp->buf]){
                    strcpy(dp->ep, np);
                    dp->x[dp->n].name = dp->ep;
                    last = dp->ep;
                    dp->x[dp->n].offset = p - dp->start;
                    dp->ep += i + 1;
                    dp->n++;
                }
            }

        /* put next component into message */
        cp = strchr(np, '.');
        if(cp == nil){
            i = strlen(np);
            cp = np + i;	/* point to null terminator */
        } else {
            i = cp - np;
            cp++;		/* point past '.' */
        }
        if(ep-p < i+1)
            return ep+1;
        if (i > Labellen)
            return ep+1;
        *p++ = i;		/* count of chars in label */
        memmove(p, np, i);
        np = cp;
        p += i;
    }

    if(p >= ep)
        return ep+1;
    *p++ = 0;	/* add top level domain */

    return p;
}
@

<<function [[convRR2M]]>>=
static uchar*
convRR2M(RR *rp, uchar *p, uchar *ep, Dict *dp)
{
    uchar *lp, *data;
    int len, ttl;
    Txt *t;

    NAME(rp->owner->name);
    USHORT(rp->type);
    USHORT(rp->owner->class);

    /* egregious overuse of ttl (it's absolute time in the cache) */
    if(rp->db)
        ttl = rp->ttl;
    else
        ttl = rp->ttl - now;
    if(ttl < 0)
        ttl = 0;
    ULONG(ttl);

    lp = p;			/* leave room for the rdata length */
    p += 2;
    data = p;

    if(data >= ep)
        return p+1;

    switch(rp->type){
    case Thinfo:
        SYMBOL(rp->cpu->name);
        SYMBOL(rp->os->name);
        break;
    case Tcname:
    case Tmb:
    case Tmd:
    case Tmf:
    case Tns:
        NAME(rp->host->name);
        break;
    case Tmg:
    case Tmr:
        NAME(rp->mb->name);
        break;
    case Tminfo:
        NAME(rp->rmb->name);
        NAME(rp->mb->name);
        break;
    case Tmx:
        USHORT(rp->pref);
        NAME(rp->host->name);
        break;
    case Ta:
        V4ADDR(rp->ip->name);
        break;
    case Taaaa:
        V6ADDR(rp->ip->name);
        break;
    case Tptr:
        NAME(rp->ptr->name);
        break;
    case Tsoa:
        NAME(rp->host->name);
        NAME(rp->rmb->name);
        ULONG(rp->soa->serial);
        ULONG(rp->soa->refresh);
        ULONG(rp->soa->retry);
        ULONG(rp->soa->expire);
        ULONG(rp->soa->minttl);
        break;
    case Tsrv:
        USHORT(rp->srv->pri);
        USHORT(rp->srv->weight);
        USHORT(rp->port);
        STRING(rp->host->name);	/* rfc2782 sez no name compression */
        break;
    case Ttxt:
        for(t = rp->txt; t != nil; t = t->next)
            STRING(t->p);
        break;
    case Tnull:
        BYTES(rp->null->data, rp->null->dlen);
        break;
    case Trp:
        NAME(rp->rmb->name);
        NAME(rp->rp->name);
        break;
    case Tkey:
        USHORT(rp->key->flags);
        UCHAR(rp->key->proto);
        UCHAR(rp->key->alg);
        BYTES(rp->key->data, rp->key->dlen);
        break;
    case Tsig:
        USHORT(rp->sig->type);
        UCHAR(rp->sig->alg);
        UCHAR(rp->sig->labels);
        ULONG(rp->sig->ttl);
        ULONG(rp->sig->exp);
        ULONG(rp->sig->incep);
        USHORT(rp->sig->tag);
        NAME(rp->sig->signer->name);
        BYTES(rp->sig->data, rp->sig->dlen);
        break;
    case Tcert:
        USHORT(rp->cert->type);
        USHORT(rp->cert->tag);
        UCHAR(rp->cert->alg);
        BYTES(rp->cert->data, rp->cert->dlen);
        break;
    }

    /* stuff in the rdata section length */
    len = p - data;
    *lp++ = len >> 8;
    *lp = len;

    return p;
}
@

<<function [[convQ2M]]>>=
static uchar*
convQ2M(RR *rp, uchar *p, uchar *ep, Dict *dp)
{
    NAME(rp->owner->name);
    USHORT(rp->type);
    USHORT(rp->owner->class);
    return p;
}
@

<<function [[rrloop]]>>=
static uchar*
rrloop(RR *rp, int *countp, uchar *p, uchar *ep, Dict *dp, int quest)
{
    uchar *np;

    *countp = 0;
    for(; rp && p < ep; rp = rp->next){
        if(quest)
            np = convQ2M(rp, p, ep, dp);
        else
            np = convRR2M(rp, p, ep, dp);
        if(np > ep)
            break;
        p = np;
        (*countp)++;
    }
    return p;
}
@

<<function [[convDNS2M]]>>=
/*
 *  convert into a message
 */
int
convDNS2M(DNSmsg *m, uchar *buf, int len)
{
    ulong trunc = 0;
    uchar *p, *ep, *np;
    Dict d;

    d.n = 0;
    d.start = buf;
    d.ep = d.buf;
    memset(buf, 0, len);
    m->qdcount = m->ancount = m->nscount = m->arcount = 0;

    /* first pack in the RR's so we can get real counts */
    p = buf + 12;
    ep = buf + len;
    p = rrloop(m->qd, &m->qdcount, p, ep, &d, 1);
    p = rrloop(m->an, &m->ancount, p, ep, &d, 0);
    p = rrloop(m->ns, &m->nscount, p, ep, &d, 0);
    p = rrloop(m->ar, &m->arcount, p, ep, &d, 0);
    if(p > ep) {
        trunc = Ftrunc;
        dnslog("udp packet full; truncating my reply");
        p = ep;
    }

    /* now pack the rest */
    np = p;
    p = buf;
    ep = buf + len;
    USHORT(m->id);
    USHORT(m->flags | trunc);
    USHORT(m->qdcount);
    USHORT(m->ancount);
    USHORT(m->nscount);
    USHORT(m->arcount);
    USED(p);
    return np - buf;
}
@


%-------------------------------------------------------------

<<networking/ndb/convDNS2M.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dns.h"

<<enum [[_anon_ (networking/ndb/convDNS2M.c)]]>>
typedef struct Dict	Dict;
<<struct [[Dict]]>>

<<macro [[NAME]]>>
<<macro [[SYMBOL]]>>
<<macro [[STRING]]>>
<<macro [[BYTES]]>>
<<macro [[USHORT]]>>
<<macro [[UCHAR]]>>
<<macro [[ULONG]]>>
<<macro [[V4ADDR]]>>
<<macro [[V6ADDR]]>>

<<function [[psym]]>>

<<function [[pstr]]>>

<<function [[pbytes]]>>

<<function [[puchar]]>>

<<function [[pushort]]>>

<<function [[pulong]]>>

<<function [[pv4addr]]>>

<<function [[pv6addr]]>>

<<function [[pname]]>>

<<function [[convRR2M]]>>

<<function [[convQ2M]]>>

<<function [[rrloop]]>>

<<function [[convDNS2M]]>>
@


\subsection*{[[networking/ndb/convM2DNS.c]]}

<<struct [[Scan]]>>=
struct Scan
{
    uchar	*base;		/* input buffer */
    uchar	*p;		/* current position */
    uchar	*ep;		/* byte after the end */

    char	*err;
    char	errbuf[256];	/* hold a formatted error sometimes */
    int	rcode;		/* outgoing response codes (reply flags) */
    int	stop;		/* flag: stop processing */
    int	trunc;		/* flag: input truncated */
};
@

<<function [[errneg]]>>=
static int
errneg(RR *rp, Scan *sp, int actual)
{
    snprint(sp->errbuf, sizeof sp->errbuf, "negative len %d: %R",
        actual, rp);
    sp->err = sp->errbuf;
    return 0;
}
@

<<function [[errtoolong]]>>=
static int
errtoolong(RR *rp, Scan *sp, int remain, int need, char *where)
{
    char *p, *ep;
    char ptype[64];

    p =  sp->errbuf;
    ep = sp->errbuf + sizeof sp->errbuf - 1;
    if (where)
        p = seprint(p, ep, "%s: ", where);
    if (rp)
        p = seprint(p, ep, "type %s RR: ",
            rrname(rp->type, ptype, sizeof ptype));
    p = seprint(p, ep, "%d bytes needed; %d remain", need, remain);
    if (rp)
        p = seprint(p, ep, ": %R", rp);
    /*
     * hack to cope with servers that don't set Ftrunc when they should:
     * if the (udp) packet is full-sized, if must be truncated because
     * it is incomplete.  otherwise, it's just garbled.
     */
    if (sp->ep - sp->base >= Maxudp) {
        sp->trunc = 1;
        seprint(p, ep, " (truncated)");
    }
    if (debug && rp)
        dnslog("malformed rr: %R", rp);
    sp->err = sp->errbuf;
    return 0;
}
@

<<function [[gchar]]>>=
/*
 *  get a ushort/ulong
 */
static ushort
gchar(RR *rp, Scan *sp)
{
    ushort x;

    if(sp->err)
        return 0;
    if(sp->ep - sp->p < 1)
        return errtoolong(rp, sp, sp->ep - sp->p, 1, "gchar");
    x = sp->p[0];
    sp->p += 1;
    return x;
}
@

<<function [[gshort]]>>=
static ushort
gshort(RR *rp, Scan *sp)
{
    ushort x;

    if(sp->err)
        return 0;
    if(sp->ep - sp->p < 2)
        return errtoolong(rp, sp, sp->ep - sp->p, 2, "gshort");
    x = sp->p[0]<<8 | sp->p[1];
    sp->p += 2;
    return x;
}
@

<<function [[glong]]>>=
static ulong
glong(RR *rp, Scan *sp)
{
    ulong x;

    if(sp->err)
        return 0;
    if(sp->ep - sp->p < 4)
        return errtoolong(rp, sp, sp->ep - sp->p, 4, "glong");
    x = sp->p[0]<<24 | sp->p[1]<<16 | sp->p[2]<<8 | sp->p[3];
    sp->p += 4;
    return x;
}
@

<<function [[gv4addr]]>>=
/*
 *  get an ip address
 */
static DN*
gv4addr(RR *rp, Scan *sp)
{
    char addr[32];

    if(sp->err)
        return 0;
    if(sp->ep - sp->p < 4)
        return (DN*)errtoolong(rp, sp, sp->ep - sp->p, 4, "gv4addr");
    snprint(addr, sizeof addr, "%V", sp->p);
    sp->p += 4;

    return dnlookup(addr, Cin, 1);
}
@

<<function [[gv6addr]]>>=
static DN*
gv6addr(RR *rp, Scan *sp)
{
    char addr[64];

    if(sp->err)
        return 0;
    if(sp->ep - sp->p < IPaddrlen)
        return (DN*)errtoolong(rp, sp, sp->ep - sp->p, IPaddrlen,
            "gv6addr");
    snprint(addr, sizeof addr, "%I", sp->p);
    sp->p += IPaddrlen;

    return dnlookup(addr, Cin, 1);
}
@

<<function [[gsym]]>>=
/*
 *  get a string.  make it an internal symbol.
 */
static DN*
gsym(RR *rp, Scan *sp)
{
    int n;
    char sym[Strlen+1];

    if(sp->err)
        return 0;
    n = 0;
    if (sp->p < sp->ep)
        n = *(sp->p++);
    if(sp->ep - sp->p < n)
        return (DN*)errtoolong(rp, sp, sp->ep - sp->p, n, "gsym");

    if(n > Strlen){
        sp->err = "illegal string (symbol)";
        return 0;
    }
    strncpy(sym, (char*)sp->p, n);
    sym[n] = 0;
    if (strlen(sym) != n)
        sp->err = "symbol shorter than declared length";
    sp->p += n;

    return dnlookup(sym, Csym, 1);
}
@

<<function [[gstr]]>>=
/*
 *  get a string.  don't make it an internal symbol.
 */
static Txt*
gstr(RR *rp, Scan *sp)
{
    int n;
    char sym[Strlen+1];
    Txt *t;

    if(sp->err)
        return 0;
    n = 0;
    if (sp->p < sp->ep)
        n = *(sp->p++);
    if(sp->ep - sp->p < n)
        return (Txt*)errtoolong(rp, sp, sp->ep - sp->p, n, "gstr");

    if(n > Strlen){
        sp->err = "illegal string";
        return 0;
    }
    strncpy(sym, (char*)sp->p, n);
    sym[n] = 0;
    if (strlen(sym) != n)
        sp->err = "string shorter than declared length";
    sp->p += n;

    t = emalloc(sizeof(*t));
    t->next = nil;
    t->p = estrdup(sym);
    return t;
}
@

<<function [[gbytes]]>>=
/*
 *  get a sequence of bytes
 */
static int
gbytes(RR *rp, Scan *sp, uchar **p, int n)
{
    *p = nil;			/* i think this is a good idea */
    if(sp->err)
        return 0;
    if(n < 0)
        return errneg(rp, sp, n);
    if(sp->ep - sp->p < n)
        return errtoolong(rp, sp, sp->ep - sp->p, n, "gbytes");
    *p = emalloc(n);
    memmove(*p, sp->p, n);
    sp->p += n;

    return n;
}
@

<<function [[gname]]>>=
/*
 *  get a domain name.  'to' must point to a buffer at least Domlen+1 long.
 */
static char*
gname(char *to, RR *rp, Scan *sp)
{
    int len, off, pointer, n;
    char *tostart, *toend;
    uchar *p;

    tostart = to;
    if(sp->err || sp->stop)
        goto err;
    pointer = 0;
    p = sp->p;
    if (p == nil) {
        dnslog("gname: %R: nil sp->p", rp);
        goto err;
    }
    toend = to + Domlen;
    for(len = 0; *p && p < sp->ep; len += (pointer? 0: n+1)) {
        n = 0;
        switch (*p & 0300) {
        case 0:			/* normal label */
            if (p < sp->ep)
                n = *p++ & 077;		/* pick up length */
            if(len + n < Domlen - 1){
                if(n > toend - to){
                    errtoolong(rp, sp, toend - to, n,
                        "name too long");
                    goto err;
                }
                memmove(to, p, n);
                to += n;
            }
            p += n;
            if(*p){
                if(to >= toend){
                    errtoolong(rp, sp, toend - to, 2,
                     "more name components but no bytes left");
                    goto err;
                }
                *to++ = '.';
            }
            break;
        case 0100:		/* edns extended label type, rfc 2671 */
            /*
             * treat it like an EOF for now; it seems to be at
             * the end of a long tcp reply.
             */
            dnslog("edns label; first byte 0%o = '%c'", *p, *p);
            sp->stop = 1;
            goto err;
        case 0200:		/* reserved */
            sp->err = "reserved-use label present";
            goto err;
        case 0300:		/* pointer to other spot in message */
            if(pointer++ > 10){
                sp->err = "pointer loop";
                goto err;
            }
            off = (p[0] & 077)<<8 | p[1];
            p = sp->base + off;
            if(p >= sp->ep){
                sp->err = "bad pointer";
                goto err;
            }
            n = 0;
            break;
        }
    }
    *to = 0;
    if(pointer)
        sp->p += len + 2;	/* + 2 for pointer */
    else
        sp->p += len + 1;	/* + 1 for the null domain */
    return tostart;
err:
    *tostart = 0;
    return tostart;
}
@

<<function [[mstypehack]]>>=
/*
 * ms windows 2000 seems to get the bytes backward in the type field
 * of ptr records, so return a format error as feedback.
 */
static ushort
mstypehack(Scan *sp, ushort type, char *where)
{
    if ((uchar)type == 0 && (type>>8) != 0) {
        USED(where);
//		dnslog("%s: byte-swapped type field in ptr rr from win2k",
//			where);
        if (sp->rcode == Rok)
            sp->rcode = Rformat;
        type >>= 8;
    }
    return type;
}
@

<<macro [[NAME]]([[(networking/ndb/convM2DNS.c)]])>>=
#define NAME(x)		gname(x, rp, sp)
@

<<macro [[SYMBOL]]([[(networking/ndb/convM2DNS.c)]])>>=
#define SYMBOL(x)	((x) = gsym(rp, sp))
@

<<macro [[STRING]]([[(networking/ndb/convM2DNS.c)]])>>=
#define STRING(x)	((x) = gstr(rp, sp))
@

<<macro [[USHORT]]([[(networking/ndb/convM2DNS.c)]])>>=
#define USHORT(x)	((x) = gshort(rp, sp))
@

<<macro [[ULONG]]([[(networking/ndb/convM2DNS.c)]])>>=
#define ULONG(x)	((x) = glong(rp, sp))
@

<<macro [[UCHAR]]([[(networking/ndb/convM2DNS.c)]])>>=
#define UCHAR(x)	((x) = gchar(rp, sp))
@

<<macro [[V4ADDR]]([[(networking/ndb/convM2DNS.c)]])>>=
#define V4ADDR(x)	((x) = gv4addr(rp, sp))
@

<<macro [[V6ADDR]]([[(networking/ndb/convM2DNS.c)]])>>=
#define V6ADDR(x)	((x) = gv6addr(rp, sp))
@

<<macro [[BYTES]]([[(networking/ndb/convM2DNS.c)]])>>=
#define BYTES(x, y)	((y) = gbytes(rp, sp, &(x), len - (sp->p - data)))
@

<<function [[convM2RR]]>>=
/*
 *  convert the next RR from a message
 */
static RR*
convM2RR(Scan *sp, char *what)
{
    int type, class, len, left;
    char *dn;
    char dname[Domlen+1];
    uchar *data;
    RR *rp;
    Txt *t, **l;

retry:
    rp = nil;
    NAME(dname);
    USHORT(type);
    USHORT(class);

    type = mstypehack(sp, type, "convM2RR");
    rp = rralloc(type);
    rp->owner = dnlookup(dname, class, 1);
    rp->type = type;

    ULONG(rp->ttl);
    rp->ttl += now;
    USHORT(len);			/* length of data following */
    data = sp->p;
    assert(data != nil);
    left = sp->ep - sp->p;

    /*
     * ms windows generates a lot of badly-formatted hints.
     * hints are only advisory, so don't log complaints about them.
     * it also generates answers in which p overshoots ep by exactly
     * one byte; this seems to be harmless, so don't log them either.
     */
    if (len > left &&
       !(strcmp(what, "hints") == 0 ||
         sp->p == sp->ep + 1 && strcmp(what, "answers") == 0))
        errtoolong(rp, sp, left, len, "convM2RR");
    if(sp->err || sp->rcode || sp->stop){
        rrfree(rp);
        return nil;
    }
    /* even if we don't log an error message, truncate length to fit data */
    if (len > left)
        len = left;

    switch(type){
    default:
        /* unknown type, just ignore it */
        sp->p = data + len;
        rrfree(rp);
        goto retry;
    case Thinfo:
        SYMBOL(rp->cpu);
        SYMBOL(rp->os);
        break;
    case Tcname:
    case Tmb:
    case Tmd:
    case Tmf:
    case Tns:
        rp->host = dnlookup(NAME(dname), Cin, 1);
        break;
    case Tmg:
    case Tmr:
        rp->mb  = dnlookup(NAME(dname), Cin, 1);
        break;
    case Tminfo:
        rp->rmb = dnlookup(NAME(dname), Cin, 1);
        rp->mb  = dnlookup(NAME(dname), Cin, 1);
        break;
    case Tmx:
        USHORT(rp->pref);
        dn = NAME(dname);
        rp->host = dnlookup(dn, Cin, 1);
        if(strchr((char *)rp->host, '\n') != nil) {
            dnslog("newline in mx text for %s", dn);
            sp->trunc = 1;		/* try again via tcp */
        }
        break;
    case Ta:
        V4ADDR(rp->ip);
        break;
    case Taaaa:
        V6ADDR(rp->ip);
        break;
    case Tptr:
        rp->ptr = dnlookup(NAME(dname), Cin, 1);
        break;
    case Tsoa:
        rp->host = dnlookup(NAME(dname), Cin, 1);
        rp->rmb  = dnlookup(NAME(dname), Cin, 1);
        ULONG(rp->soa->serial);
        ULONG(rp->soa->refresh);
        ULONG(rp->soa->retry);
        ULONG(rp->soa->expire);
        ULONG(rp->soa->minttl);
        break;
    case Tsrv:
        USHORT(rp->srv->pri);
        USHORT(rp->srv->weight);
        USHORT(rp->port);
        /*
         * rfc2782 sez no name compression but to be
         * backward-compatible with rfc2052, we try to expand the name. 
         * if the length is under 64 bytes, either interpretation is
         * fine; if it's longer, we'll assume it's compressed,
         * as recommended by rfc3597.
         */
        rp->host = dnlookup(NAME(dname), Cin, 1);
        break;
    case Ttxt:
        l = &rp->txt;
        *l = nil;
        while(sp->p - data < len){
            STRING(t);
            *l = t;
            l = &t->next;
        }
        break;
    case Tnull:
        BYTES(rp->null->data, rp->null->dlen);
        break;
    case Trp:
        rp->rmb = dnlookup(NAME(dname), Cin, 1);
        rp->rp  = dnlookup(NAME(dname), Cin, 1);
        break;
    case Tkey:
        USHORT(rp->key->flags);
        UCHAR(rp->key->proto);
        UCHAR(rp->key->alg);
        BYTES(rp->key->data, rp->key->dlen);
        break;
    case Tsig:
        USHORT(rp->sig->type);
        UCHAR(rp->sig->alg);
        UCHAR(rp->sig->labels);
        ULONG(rp->sig->ttl);
        ULONG(rp->sig->exp);
        ULONG(rp->sig->incep);
        USHORT(rp->sig->tag);
        rp->sig->signer = dnlookup(NAME(dname), Cin, 1);
        BYTES(rp->sig->data, rp->sig->dlen);
        break;
    case Tcert:
        USHORT(rp->cert->type);
        USHORT(rp->cert->tag);
        UCHAR(rp->cert->alg);
        BYTES(rp->cert->data, rp->cert->dlen);
        break;
    }
    if(sp->p - data != len) {
        char ptype[64];

        /*
         * ms windows 2000 generates cname queries for reverse lookups
         * with this particular error.  don't bother logging it.
         *
         * server: input error: bad cname RR len (actual 2 != len 0):
         * 235.9.104.135.in-addr.arpa cname
         *	235.9.104.135.in-addr.arpa from 135.104.9.235
         */
        if (type == Tcname && sp->p - data == 2 && len == 0)
            return rp;
        if (len > sp->p - data){
            dnslog("bad %s RR len (%d bytes nominal, %lud actual): %R",
                rrname(type, ptype, sizeof ptype), len,
                sp->p - data, rp);
            rrfree(rp);
            rp = nil;
        }
    }
    // if(rp) dnslog("convM2RR: got %R", rp);
    return rp;
}
@

<<function [[convM2Q]]>>=
/*
 *  convert the next question from a message
 */
static RR*
convM2Q(Scan *sp)
{
    char dname[Domlen+1];
    int type, class;
    RR *rp;

    rp = nil;
    NAME(dname);
    USHORT(type);
    USHORT(class);
    if(sp->err || sp->rcode || sp->stop)
        return nil;

    type = mstypehack(sp, type, "convM2Q");
    rp = rralloc(type);
    rp->owner = dnlookup(dname, class, 1);

    return rp;
}
@

<<function [[rrloop]]([[(networking/ndb/convM2DNS.c)]])>>=
static RR*
rrloop(Scan *sp, char *what, int count, int quest)
{
    int i;
    RR *first, *rp, **l;

    if(sp->err || sp->rcode || sp->stop)
        return nil;
    l = &first;
    first = nil;
    for(i = 0; i < count; i++){
        rp = quest? convM2Q(sp): convM2RR(sp, what);
        if(rp == nil)
            break;
        setmalloctag(rp, getcallerpc(&sp));
        /*
         * it might be better to ignore the bad rr, possibly break out,
         * but return the previous rrs, if any.  that way our callers
         * would know that they had got a response, however ill-formed.
         */
        if(sp->err || sp->rcode || sp->stop){
            rrfree(rp);
            break;
        }
        *l = rp;
        l = &rp->next;
    }
//	if(first)
//		setmalloctag(first, getcallerpc(&sp));
    return first;
}
@

<<function [[convM2DNS]]>>=
/*
 *  convert the next DNS from a message stream.
 *  if there are formatting errors or the like during parsing of the message,
 *  set *codep to the outgoing response code (e.g., Rformat), which will
 *  abort processing and reply immediately with the outgoing response code.
 *
 *  ideally would note if len == Maxudp && query was via UDP, for errtoolong.
 */
char*
convM2DNS(uchar *buf, int len, DNSmsg *m, int *codep)
{
    char *err = nil;
    RR *rp = nil;
    Scan scan;
    Scan *sp;

    assert(len >= 0);
    assert(buf != nil);
    sp = &scan;
    memset(sp, 0, sizeof *sp);
    sp->base = sp->p = buf;
    sp->ep = buf + len;
    sp->err = nil;
    sp->errbuf[0] = '\0';
    sp->rcode = Rok;

    memset(m, 0, sizeof *m);
    USHORT(m->id);
    USHORT(m->flags);
    USHORT(m->qdcount);
    USHORT(m->ancount);
    USHORT(m->nscount);
    USHORT(m->arcount);

    m->qd = rrloop(sp, "questions",	m->qdcount, 1);
    m->an = rrloop(sp, "answers",	m->ancount, 0);
    m->ns = rrloop(sp, "nameservers",m->nscount, 0);
    if (sp->stop)
        sp->err = nil;
    if (sp->err)
        err = strdup(sp->err);		/* live with bad ar's */
    m->ar = rrloop(sp, "hints",	m->arcount, 0);
    if (sp->trunc)
        m->flags |= Ftrunc;
    if (sp->stop)
        sp->rcode = Rok;
    if (codep)
        *codep = sp->rcode;
    return err;
}
@


%-------------------------------------------------------------

<<networking/ndb/convM2DNS.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dns.h"

typedef struct Scan	Scan;
<<struct [[Scan]]>>

<<function [[errneg]]>>

<<function [[errtoolong]]>>

<<function [[gchar]]>>
<<function [[gshort]]>>
<<function [[glong]]>>

<<function [[gv4addr]]>>
<<function [[gv6addr]]>>

<<function [[gsym]]>>

<<function [[gstr]]>>

<<function [[gbytes]]>>

<<function [[gname]]>>

<<function [[mstypehack]]>>

<<macro [[NAME]]([[(networking/ndb/convM2DNS.c)]])>>
<<macro [[SYMBOL]]([[(networking/ndb/convM2DNS.c)]])>>
<<macro [[STRING]]([[(networking/ndb/convM2DNS.c)]])>>
<<macro [[USHORT]]([[(networking/ndb/convM2DNS.c)]])>>
<<macro [[ULONG]]([[(networking/ndb/convM2DNS.c)]])>>
<<macro [[UCHAR]]([[(networking/ndb/convM2DNS.c)]])>>
<<macro [[V4ADDR]]([[(networking/ndb/convM2DNS.c)]])>>
<<macro [[V6ADDR]]([[(networking/ndb/convM2DNS.c)]])>>
<<macro [[BYTES]]([[(networking/ndb/convM2DNS.c)]])>>

<<function [[convM2RR]]>>

<<function [[convM2Q]]>>

<<function [[rrloop]]([[(networking/ndb/convM2DNS.c)]])>>

<<function [[convM2DNS]]>>
@


\subsection*{[[networking/ndb/cs.c]]}

<<enum [[_anon_ (networking/ndb/cs.c)]]>>=
enum
{
    Nreply=			20,
    Maxreply=		256,
    Maxrequest=		128,
    Maxpath=		128,
    Maxfdata=		8192,
    Maxhost=		64,		/* maximum host name size */
    Maxservice=		64,		/* maximum service name size */

    Qdir=			0,
    Qcs=			1,
};
@

<<global [[vers]]>>=
int vers;		/* incremented each clone/attach */
@

<<struct [[Mfile]]>>=
struct Mfile
{
    int		busy;

    char		*user;
    Qid		qid;
    int		fid;

    /*
     *  current request
     */
    char		*net;
    char		*host;
    char		*serv;
    char		*rem;

    /*
     *  result of the last lookup
     */
    Network		*nextnet;
    int		nreply;
    char		*reply[Nreply];
    int		replylen[Nreply];
};
@

<<struct [[Mlist]]>>=
struct Mlist
{
    Mlist	*next;
    Mfile	mf;
};
@

<<struct [[Job]]>>=
/*
 *  active requests
 */
struct Job
{
    Job	*next;
    int	flushed;
    Fcall	request;
    Fcall	reply;
};
@

<<global [[joblock]]>>=
Lock	joblock;
@

<<global [[joblist]]>>=
Job	*joblist;
@

<<global [[mlist]]>>=
Mlist	*mlist;
@

<<global [[mfd]]>>=
int	mfd[2];
@

<<global [[debug]]([[(networking/ndb/cs.c)]])>>=
int	debug;
@

<<global [[ipv6lookups]]>>=
int	ipv6lookups = 1;
@

<<global [[masterjmp]]>>=
jmp_buf	masterjmp;	/* return through here after a slave process has been created */
@

<<global [[isslave]]>>=
int	*isslave;	/* *isslave non-zero means this is a slave process */
@

<<global [[dbfile]]>>=
char	*dbfile;
@

<<global [[dblock]]>>=
Lock	dblock;		/* mutex on database operations */
@

<<global [[netlock]]([[(networking/ndb/cs.c)]])>>=
Lock	netlock;	/* mutex for netinit() */
@

<<global [[logfile]]([[(networking/ndb/cs.c)]])>>=
char	*logfile = "cs";
@

<<global [[paranoiafile]]>>=
char	*paranoiafile = "cs.paranoia";
@

<<global [[mntpt]]>>=
char	mntpt[Maxpath];
@

<<global [[netndb]]>>=
char	netndb[Maxpath];
@

<<struct [[Network]]>>=
struct Network
{
    char		*net;
    Ndbtuple	*(*lookup)(Network*, char*, char*, int);
    char		*(*trans)(Ndbtuple*, Network*, char*, char*, int);
    int		considered;		/* flag: ignored for "net!"? */
    int		fasttimeouthack;	/* flag. was for IL */
    Network		*next;
};
@

<<enum [[_anon_ (networking/ndb/cs.c)2]]>>=
enum
{
    Ntcp = 0,
};
@

<<global [[network]]([[(networking/ndb/cs.c)]])>>=
/*
 *  net doesn't apply to (r)udp, icmp(v6), or telco (for speed).
 */
Network network[] = {
[Ntcp]	{ "tcp",	iplookup,	iptrans,	0 },
    { "udp",	iplookup,	iptrans,	1 },
    { "icmp",	iplookup,	iptrans,	1 },
    { "icmpv6",	iplookup,	iptrans,	1 },
    { "rudp",	iplookup,	iptrans,	1 },
    { "ssh",	iplookup,	iptrans,	1 },
    { "telco",	telcolookup,	telcotrans,	1 },
    { 0 },
};
@

<<global [[ipifclock]]>>=
Lock ipifclock;
@

<<global [[ipifcs]]>>=
Ipifc *ipifcs;
@

<<global [[eaddr]]>>=
char	eaddr[16];		/* ascii ethernet address */
@

<<global [[ipaddr]]>>=
char	ipaddr[64];		/* ascii internet address */
@

<<global [[ipa]]>>=
uchar	ipa[IPaddrlen];		/* binary internet address */
@

<<global [[mysysname]]>>=
char	*mysysname;
@

<<global [[netlist]]>>=
Network *netlist;		/* networks ordered by preference */
@

<<global [[last]]([[(networking/ndb/cs.c)]])>>=
Network *last;
@

<<function [[nstrcpy]]>>=
static void
nstrcpy(char *to, char *from, int len)
{
    strncpy(to, from, len);
    to[len-1] = 0;
}
@

<<function [[usage]]([[(networking/ndb/cs.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-dn] [-f ndb-file] [-x netmtpt]\n", argv0);
    exits("usage");
}
@

<<function [[procsetname]]([[(networking/ndb/cs.c)]])>>=
/*
 * based on libthread's threadsetname, but drags in less library code.
 * actually just sets the arguments displayed.
 */
void
procsetname(char *fmt, ...)
{
    int fd;
    char *cmdname;
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if (cmdname == nil)
        return;
    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OWRITE)) >= 0){
        write(fd, cmdname, strlen(cmdname)+1);
        close(fd);
    }
    free(cmdname);
}
@

<<function [[main]]([[(networking/ndb/cs.c)]])>>=
void
main(int argc, char *argv[])
{
    int justsetname;
    char ext[Maxpath], servefile[Maxpath];

    justsetname = 0;
    setnetmtpt(mntpt, sizeof(mntpt), nil);
    ext[0] = 0;
    ARGBEGIN{
    case '4':
        ipv6lookups = 0;
        break;
    case 'd':
        debug = 1;
        break;
    case 'f':
        dbfile = EARGF(usage());
        break;
    case 'n':
        justsetname = 1;
        break;
    case 'x':
        setnetmtpt(mntpt, sizeof(mntpt), EARGF(usage()));
        setext(ext, sizeof(ext), mntpt);
        break;
    }ARGEND
    USED(argc);
    USED(argv);

    rfork(RFREND|RFNOTEG);

    snprint(servefile, sizeof(servefile), "#s/cs%s", ext);
    snprint(netndb, sizeof(netndb), "%s/ndb", mntpt);
    unmount(servefile, mntpt);
    remove(servefile);

    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('M', eipfmt);
    fmtinstall('F', fcallfmt);

    ndbinit();
    netinit(0);

    if(!justsetname){
        mountinit(servefile, mntpt);
        io();
    }
    exits(0);
}
@

<<function [[setext]]>>=
/*
 *  if a mount point is specified, set the cs extention to be the mount point
 *  with '_'s replacing '/'s
 */
void
setext(char *ext, int n, char *p)
{
    int i, c;

    n--;
    for(i = 0; i < n; i++){
        c = p[i];
        if(c == 0)
            break;
        if(c == '/')
            c = '_';
        ext[i] = c;
    }
    ext[i] = 0;
}
@

<<function [[mountinit]]>>=
void
mountinit(char *service, char *mntpt)
{
    int f;
    int p[2];
    char buf[32];

    if(pipe(p) < 0)
        error("pipe failed");

    /*
     *  make a /srv/cs
     */
    f = create(service, OWRITE|ORCLOSE, 0666);
    if(f < 0)
        error(service);
    snprint(buf, sizeof(buf), "%d", p[1]);
    if(write(f, buf, strlen(buf)) != strlen(buf))
        error("write /srv/cs");

    switch(rfork(RFFDG|RFPROC|RFNAMEG)){
    case 0:
        close(p[1]);
        procsetname("%s", mntpt);
        break;
    case -1:
        error("fork failed\n");
    default:
        /*
         *  put ourselves into the file system
         */
        close(p[0]);
        if(mount(p[1], -1, mntpt, MAFTER, "") < 0)
            error("mount failed\n");
        _exits(0);
    }
    mfd[0] = mfd[1] = p[0];
}
@

<<function [[ndbinit]]>>=
void
ndbinit(void)
{
    db = ndbopen(dbfile);
    if(db == nil)
        error("can't open network database");

    netdb = ndbopen(netndb);
    if(netdb != nil){
        netdb->nohash = 1;
        db = ndbcat(netdb, db);
    }
}
@

<<function [[newfid]]([[(networking/ndb/cs.c)]])>>=
Mfile*
newfid(int fid)
{
    Mlist *f, *ff;
    Mfile *mf;

    ff = 0;
    for(f = mlist; f; f = f->next)
        if(f->mf.busy && f->mf.fid == fid)
            return &f->mf;
        else if(!ff && !f->mf.busy)
            ff = f;
    if(ff == 0){
        ff = emalloc(sizeof *f);
        ff->next = mlist;
        mlist = ff;
    }
    mf = &ff->mf;
    memset(mf, 0, sizeof *mf);
    mf->fid = fid;
    return mf;
}
@

<<function [[newjob]]>>=
Job*
newjob(void)
{
    Job *job;

    job = mallocz(sizeof(Job), 1);
    lock(&joblock);
    job->next = joblist;
    joblist = job;
    job->request.tag = -1;
    unlock(&joblock);
    return job;
}
@

<<function [[freejob]]>>=
void
freejob(Job *job)
{
    Job **l;

    lock(&joblock);
    for(l = &joblist; *l; l = &(*l)->next){
        if((*l) == job){
            *l = job->next;
            free(job);
            break;
        }
    }
    unlock(&joblock);
}
@

<<function [[flushjob]]>>=
void
flushjob(int tag)
{
    Job *job;

    lock(&joblock);
    for(job = joblist; job; job = job->next){
        if(job->request.tag == tag && job->request.type != Tflush){
            job->flushed = 1;
            break;
        }
    }
    unlock(&joblock);
}
@

<<function [[io]]>>=
void
io(void)
{
    long n;
    Mfile *mf;
    int slaveflag;
    uchar mdata[IOHDRSZ + Maxfdata];
    Job *job;

    /*
     *  if we ask dns to fulfill requests,
     *  a slave process is created to wait for replies.  The
     *  master process returns immediately via a longjmp
     *  through 'masterjmp'.
     *
     *  *isslave is a pointer into the call stack to a variable
     *  that tells whether or not the current process is a slave.
     */
    slaveflag = 0;		/* init slave variable */
    isslave = &slaveflag;
    setjmp(masterjmp);

    for(;;){
        n = read9pmsg(mfd[0], mdata, sizeof mdata);
        if(n<=0)
            error("mount read");
        job = newjob();
        if(convM2S(mdata, n, &job->request) != n){
            syslog(1, logfile, "format error %ux %ux %ux %ux %ux",
                mdata[0], mdata[1], mdata[2], mdata[3], mdata[4]);
            freejob(job);
            continue;
        }
        lock(&dblock);
        mf = newfid(job->request.fid);
        if(debug)
            syslog(0, logfile, "%F", &job->request);


        switch(job->request.type){
        default:
            syslog(1, logfile, "unknown request type %d", job->request.type);
            break;
        case Tversion:
            rversion(job);
            break;
        case Tauth:
            rauth(job);
            break;
        case Tflush:
            rflush(job);
            break;
        case Tattach:
            rattach(job, mf);
            break;
        case Twalk:
            rwalk(job, mf);
            break;
        case Topen:
            ropen(job, mf);
            break;
        case Tcreate:
            rcreate(job, mf);
            break;
        case Tread:
            rread(job, mf);
            break;
        case Twrite:
            rwrite(job, mf);
            break;
        case Tclunk:
            rclunk(job, mf);
            break;
        case Tremove:
            rremove(job, mf);
            break;
        case Tstat:
            rstat(job, mf);
            break;
        case Twstat:
            rwstat(job, mf);
            break;
        }
        unlock(&dblock);

        freejob(job);

        /*
         *  slave processes die after replying
         */
        if(*isslave){
            if(debug)
                syslog(0, logfile, "slave death %d", getpid());
            _exits(0);
        }
    }
}
@

<<function [[rversion]]>>=
void
rversion(Job *job)
{
    if(job->request.msize > IOHDRSZ + Maxfdata)
        job->reply.msize = IOHDRSZ + Maxfdata;
    else
        job->reply.msize = job->request.msize;
    if(strncmp(job->request.version, "9P2000", 6) != 0)
        sendmsg(job, "unknown 9P version");
    else{
        job->reply.version = "9P2000";
        sendmsg(job, 0);
    }
}
@

<<function [[rauth]]>>=
void
rauth(Job *job)
{
    sendmsg(job, "cs: authentication not required");
}
@

<<function [[rflush]]>>=
/*
 *  don't flush till all the slaves are done
 */
void
rflush(Job *job)
{
    flushjob(job->request.oldtag);
    sendmsg(job, 0);
}
@

<<function [[rattach]]>>=
void
rattach(Job *job, Mfile *mf)
{
    if(mf->busy == 0){
        mf->busy = 1;
        mf->user = estrdup(job->request.uname);
    }
    mf->qid.vers = vers++;
    mf->qid.type = QTDIR;
    mf->qid.path = 0LL;
    job->reply.qid = mf->qid;
    sendmsg(job, 0);
}
@

<<function [[rwalk]]>>=
char*
rwalk(Job *job, Mfile *mf)
{
    char *err;
    char **elems;
    int nelems;
    int i;
    Mfile *nmf;
    Qid qid;

    err = 0;
    nmf = nil;
    elems = job->request.wname;
    nelems = job->request.nwname;
    job->reply.nwqid = 0;

    if(job->request.newfid != job->request.fid){
        /* clone fid */
        nmf = newfid(job->request.newfid);
        if(nmf->busy){
            nmf = nil;
            err = "clone to used channel";
            goto send;
        }
        *nmf = *mf;
        nmf->user = estrdup(mf->user);
        nmf->fid = job->request.newfid;
        nmf->qid.vers = vers++;
        mf = nmf;
    }
    /* else nmf will be nil */

    qid = mf->qid;
    if(nelems > 0){
        /* walk fid */
        for(i=0; i<nelems && i<MAXWELEM; i++){
            if((qid.type & QTDIR) == 0){
                err = "not a directory";
                break;
            }
            if(strcmp(elems[i], "..") == 0 || strcmp(elems[i], ".") == 0){
                qid.type = QTDIR;
                qid.path = Qdir;
    Found:
                job->reply.wqid[i] = qid;
                job->reply.nwqid++;
                continue;
            }
            if(strcmp(elems[i], "cs") == 0){
                qid.type = QTFILE;
                qid.path = Qcs;
                goto Found;
            }
            err = "file does not exist";
            break;
        }
    }

    send:
    if(nmf != nil && (err!=nil || job->reply.nwqid<nelems)){
        cleanmf(nmf);
        free(nmf->user);
        nmf->user = 0;
        nmf->busy = 0;
        nmf->fid = 0;
    }
    if(err == nil)
        mf->qid = qid;
    sendmsg(job, err);
    return err;
}
@

<<function [[ropen]]>>=
void
ropen(Job *job, Mfile *mf)
{
    int mode;
    char *err;

    err = 0;
    mode = job->request.mode;
    if(mf->qid.type & QTDIR){
        if(mode)
            err = "permission denied";
    }
    job->reply.qid = mf->qid;
    job->reply.iounit = 0;
    sendmsg(job, err);
}
@

<<function [[rcreate]]>>=
void
rcreate(Job *job, Mfile *mf)
{
    USED(mf);
    sendmsg(job, "creation permission denied");
}
@

<<function [[rread]]>>=
void
rread(Job *job, Mfile *mf)
{
    int i, n, cnt;
    long off, toff, clock;
    Dir dir;
    uchar buf[Maxfdata];
    char *err;

    n = 0;
    err = 0;
    off = job->request.offset;
    cnt = job->request.count;
    if(mf->qid.type & QTDIR){
        clock = time(0);
        if(off == 0){
            memset(&dir, 0, sizeof dir);
            dir.name = "cs";
            dir.qid.type = QTFILE;
            dir.qid.vers = vers;
            dir.qid.path = Qcs;
            dir.mode = 0666;
            dir.length = 0;
            dir.uid = mf->user;
            dir.gid = mf->user;
            dir.muid = mf->user;
            dir.atime = clock;	/* wrong */
            dir.mtime = clock;	/* wrong */
            n = convD2M(&dir, buf, sizeof buf);
        }
        job->reply.data = (char*)buf;
    } else {
        for(;;){
            /* look for an answer at the right offset */
            toff = 0;
            for(i = 0; mf->reply[i] && i < mf->nreply; i++){
                n = mf->replylen[i];
                if(off < toff + n)
                    break;
                toff += n;
            }
            if(i < mf->nreply)
                break;		/* got something to return */

            /* try looking up more answers */
            if(lookup(mf) == 0){
                /* no more */
                n = 0;
                goto send;
            }
        }

        /* give back a single reply (or part of one) */
        job->reply.data = mf->reply[i] + (off - toff);
        if(cnt > toff - off + n)
            n = toff - off + n;
        else
            n = cnt;
    }
send:
    job->reply.count = n;
    sendmsg(job, err);
}
@

<<function [[cleanmf]]>>=
void
cleanmf(Mfile *mf)
{
    int i;

    if(mf->net != nil){
        free(mf->net);
        mf->net = nil;
    }
    if(mf->host != nil){
        free(mf->host);
        mf->host = nil;
    }
    if(mf->serv != nil){
        free(mf->serv);
        mf->serv = nil;
    }
    if(mf->rem != nil){
        free(mf->rem);
        mf->rem = nil;
    }
    for(i = 0; i < mf->nreply; i++){
        free(mf->reply[i]);
        mf->reply[i] = nil;
        mf->replylen[i] = 0;
    }
    mf->nreply = 0;
    mf->nextnet = netlist;
}
@

<<function [[rclunk]]>>=
void
rclunk(Job *job, Mfile *mf)
{
    cleanmf(mf);
    free(mf->user);
    mf->user = 0;
    mf->busy = 0;
    mf->fid = 0;
    sendmsg(job, 0);
}
@

<<function [[rremove]]>>=
void
rremove(Job *job, Mfile *mf)
{
    USED(mf);
    sendmsg(job, "remove permission denied");
}
@

<<function [[rstat]]>>=
void
rstat(Job *job, Mfile *mf)
{
    Dir dir;
    uchar buf[IOHDRSZ+Maxfdata];

    memset(&dir, 0, sizeof dir);
    if(mf->qid.type & QTDIR){
        dir.name = ".";
        dir.mode = DMDIR|0555;
    } else {
        dir.name = "cs";
        dir.mode = 0666;
    }
    dir.qid = mf->qid;
    dir.length = 0;
    dir.uid = mf->user;
    dir.gid = mf->user;
    dir.muid = mf->user;
    dir.atime = dir.mtime = time(0);
    job->reply.nstat = convD2M(&dir, buf, sizeof buf);
    job->reply.stat = buf;
    sendmsg(job, 0);
}
@

<<function [[rwstat]]>>=
void
rwstat(Job *job, Mfile *mf)
{
    USED(mf);
    sendmsg(job, "wstat permission denied");
}
@

<<function [[sendmsg]]>>=
void
sendmsg(Job *job, char *err)
{
    int n;
    uchar mdata[IOHDRSZ + Maxfdata];
    char ename[ERRMAX];

    if(err){
        job->reply.type = Rerror;
        snprint(ename, sizeof(ename), "cs: %s", err);
        job->reply.ename = ename;
    }else{
        job->reply.type = job->request.type+1;
    }
    job->reply.tag = job->request.tag;
    n = convS2M(&job->reply, mdata, sizeof mdata);
    if(n == 0){
        syslog(1, logfile, "sendmsg convS2M of %F returns 0", &job->reply);
        abort();
    }
    lock(&joblock);
    if(job->flushed == 0)
        if(write(mfd[1], mdata, n)!=n)
            error("mount write");
    unlock(&joblock);
    if(debug)
        syslog(0, logfile, "%F %d", &job->reply, n);
}
@

<<function [[error]]([[(networking/ndb/cs.c)]])>>=
void
error(char *s)
{
    syslog(1, "cs", "%s: %r", s);
    _exits(0);
}
@

<<function [[isvalidip]]>>=
static int
isvalidip(uchar *ip)
{
    return ipcmp(ip, IPnoaddr) != 0 && ipcmp(ip, v4prefix) != 0;
}
@

<<global [[loopbacknet]]([[(networking/ndb/cs.c)]])>>=
static uchar loopbacknet[IPaddrlen] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,
    127, 0, 0, 0
};
@

<<global [[loopbackmask]]([[(networking/ndb/cs.c)]])>>=
static uchar loopbackmask[IPaddrlen] = {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0xff, 0, 0, 0
};
@

<<function [[readipinterfaces]]>>=
void
readipinterfaces(void)
{
    if(myipaddr(ipa, mntpt) != 0)
        ipmove(ipa, IPnoaddr);
    sprint(ipaddr, "%I", ipa);
    if (debug)
        syslog(0, "dns", "ipaddr is %s\n", ipaddr);
}
@

<<function [[ipid]]>>=
/*
 *  get the system name
 */
void
ipid(void)
{
    uchar addr[6];
    Ndbtuple *t, *tt;
    char *p, *attr;
    Ndbs s;
    int f;
    char buf[Maxpath];

    /* use environment, ether addr, or ipaddr to get system name */
    if(mysysname == 0){
        /*
         *  environment has priority.
         *
         *  on the sgi power the default system name
         *  is the ip address.  ignore that.
         *
         */
        p = getenv("sysname");
        if(p && *p){
            attr = ipattr(p);
            if(strcmp(attr, "ip") != 0)
                mysysname = strdup(p);
        }

        /*
         *  the /net/ndb contains what the network
         *  figured out from DHCP.  use that name if
         *  there is one.
         */
        if(mysysname == 0 && netdb != nil){
            ndbreopen(netdb);
            for(tt = t = ndbparse(netdb); t != nil; t = t->entry){
                if(strcmp(t->attr, "sys") == 0){
                    mysysname = strdup(t->val);
                    break;
                }
            }
            ndbfree(tt);
        }

        /* next network database, ip address, and ether address to find a name */
        if(mysysname == 0){
            t = nil;
            if(isvalidip(ipa))
                free(ndbgetvalue(db, &s, "ip", ipaddr, "sys", &t));
            if(t == nil){
                for(f = 0; f < 3; f++){
                    snprint(buf, sizeof buf, "%s/ether%d", mntpt, f);
                    if(myetheraddr(addr, buf) >= 0){
                        snprint(eaddr, sizeof(eaddr), "%E", addr);
                        free(ndbgetvalue(db, &s, "ether", eaddr, "sys", &t));
                        if(t != nil)
                            break;
                    }
                }
            }
            for(tt = t; tt != nil; tt = tt->entry){
                if(strcmp(tt->attr, "sys") == 0){
                    mysysname = strdup(tt->val);
                    break;
                }
            }
            ndbfree(t);
        }

        /* nothing else worked, use the ip address */
        if(mysysname == 0 && isvalidip(ipa))
            mysysname = strdup(ipaddr);


        /* set /dev/sysname if we now know it */
        if(mysysname){
            f = open("/dev/sysname", OWRITE);
            if(f >= 0){
                write(f, mysysname, strlen(mysysname));
                close(f);
            }
        }
    }
}
@

<<function [[netinit]]>>=
/*
 *  Set up a list of default networks by looking for
 *  /net/^*^/clone.
 */
void
netinit(int background)
{
    char clone[Maxpath];
    Network *np;
    static int working;

    if(background){
        switch(rfork(RFPROC|RFNOTEG|RFMEM|RFNOWAIT)){
        case 0:
            break;
        default:
            return;
        }
        lock(&netlock);
    }

    /* add the mounted networks to the default list */
    for(np = network; np->net; np++){
        if(np->considered)
            continue;
        snprint(clone, sizeof(clone), "%s/%s/clone", mntpt, np->net);
        if(access(clone, AEXIST) < 0)
            continue;
        if(netlist)
            last->next = np;
        else
            netlist = np;
        last = np;
        np->next = 0;
        np->considered = 1;
    }

    /* find out what our ip address is */
    readipinterfaces();

    /* set the system name if we need to, these days ip is all we have */
    ipid();

    if(debug)
        syslog(0, logfile, "mysysname %s eaddr %s ipaddr %s ipa %I\n",
            mysysname?mysysname:"???", eaddr, ipaddr, ipa);

    if(background){
        unlock(&netlock);
        _exits(0);
    }
}
@

<<function [[netadd]]>>=
/*
 *  add networks to the standard list
 */
void
netadd(char *p)
{
    Network *np;
    char *field[12];
    int i, n;

    n = getfields(p, field, 12, 1, " ");
    for(i = 0; i < n; i++){
        for(np = network; np->net; np++){
            if(strcmp(field[i], np->net) != 0)
                continue;
            if(np->considered)
                break;
            if(netlist)
                last->next = np;
            else
                netlist = np;
            last = np;
            np->next = 0;
            np->considered = 1;
        }
    }
}
@

<<function [[lookforproto]]>>=
int
lookforproto(Ndbtuple *t, char *proto)
{
    for(; t != nil; t = t->entry)
        if(strcmp(t->attr, "proto") == 0 && strcmp(t->val, proto) == 0)
            return 1;
    return 0;
}
@

<<function [[lookup]]([[(networking/ndb/cs.c)]])>>=
/*
 *  lookup a request.  the network "net" means we should pick the
 *  best network to get there.
 */
int
lookup(Mfile *mf)
{
    Network *np;
    char *cp;
    Ndbtuple *nt, *t;
    char reply[Maxreply];
    int i, rv;
    int hack;

    /* open up the standard db files */
    if(db == 0)
        ndbinit();
    if(db == 0)
        error("can't open mf->network database\n");

    rv = 0;

    if(mf->net == nil)
        return 0;	/* must have been a genquery */

    if(strcmp(mf->net, "net") == 0){
        /*
         *  go through set of default nets
         */
        for(np = mf->nextnet; np; np = np->next){
            nt = (*np->lookup)(np, mf->host, mf->serv, 1);
            if(nt == nil)
                continue;
            hack = np->fasttimeouthack && !lookforproto(nt, np->net);
            for(t = nt; mf->nreply < Nreply && t; t = t->entry){
                cp = (*np->trans)(t, np, mf->serv, mf->rem, hack);
                if(cp){
                    /* avoid duplicates */
                    for(i = 0; i < mf->nreply; i++)
                        if(strcmp(mf->reply[i], cp) == 0)
                            break;
                    if(i == mf->nreply){
                        /* save the reply */
                        mf->replylen[mf->nreply] = strlen(cp);
                        mf->reply[mf->nreply++] = cp;
                        rv++;
                    }
                }
            }
            ndbfree(nt);
            np = np->next;
            break;
        }
        mf->nextnet = np;
        return rv;
    }

    /*
     *  if not /net, we only get one lookup
     */
    if(mf->nreply != 0)
        return 0;
    /*
     *  look for a specific network
     */
    for(np = netlist; np && np->net != nil; np++){
        if(np->fasttimeouthack)
            continue;
        if(strcmp(np->net, mf->net) == 0)
            break;
    }

    if(np && np->net != nil){
        /*
         *  known network
         */
        nt = (*np->lookup)(np, mf->host, mf->serv, 1);
        for(t = nt; mf->nreply < Nreply && t; t = t->entry){
            cp = (*np->trans)(t, np, mf->serv, mf->rem, 0);
            if(cp){
                mf->replylen[mf->nreply] = strlen(cp);
                mf->reply[mf->nreply++] = cp;
                rv++;
            }
        }
        ndbfree(nt);
        return rv;
    } else {
        /*
         *  not a known network, don't translate host or service
         */
        if(mf->serv)
            snprint(reply, sizeof(reply), "%s/%s/clone %s!%s",
                mntpt, mf->net, mf->host, mf->serv);
        else
            snprint(reply, sizeof(reply), "%s/%s/clone %s",
                mntpt, mf->net, mf->host);
        mf->reply[0] = strdup(reply);
        mf->replylen[0] = strlen(reply);
        mf->nreply = 1;
        return 1;
    }
}
@

<<function [[ipserv]]>>=
/*
 *  translate an ip service name into a port number.  If it's a numeric port
 *  number, look for restricted access.
 *
 *  the service '*' needs no translation.
 */
char*
ipserv(Network *np, char *name, char *buf, int blen)
{
    char *p;
    int alpha = 0;
    int restr = 0;
    char port[10];
    Ndbtuple *t, *nt;
    Ndbs s;

    /* '*' means any service */
    if(strcmp(name, "*")==0){
        strcpy(buf, name);
        return buf;
    }

    /*  see if it's numeric or symbolic */
    port[0] = 0;
    for(p = name; *p; p++){
        if(isdigit(*p))
            {}
        else if(isalpha(*p) || *p == '-' || *p == '$')
            alpha = 1;
        else
            return 0;
    }
    t = nil;
    p = nil;
    if(alpha){
        p = ndbgetvalue(db, &s, np->net, name, "port", &t);
        if(p == nil)
            return 0;
    } else {
        /* look up only for tcp ports < 1024 to get the restricted
         * attribute
         */
        if(atoi(name) < 1024 && strcmp(np->net, "tcp") == 0)
            p = ndbgetvalue(db, &s, "port", name, "port", &t);
        if(p == nil)
            p = strdup(name);
    }

    if(t){
        for(nt = t; nt; nt = nt->entry)
            if(strcmp(nt->attr, "restricted") == 0)
                restr = 1;
        ndbfree(t);
    }
    snprint(buf, blen, "%s%s", p, restr ? "!r" : "");
    free(p);

    return buf;
}
@
%$

<<function [[ipattrlookup]]>>=
/*
 *  lookup an ip attribute
 */
int
ipattrlookup(Ndb *db, char *ipa, char *attr, char *val, int vlen)
{

    Ndbtuple *t, *nt;
    char *alist[2];

    alist[0] = attr;
    t = ndbipinfo(db, "ip", ipa, alist, 1);
    if(t == nil)
        return 0;
    for(nt = t; nt != nil; nt = nt->entry){
        if(strcmp(nt->attr, attr) == 0){
            nstrcpy(val, nt->val, vlen);
            ndbfree(t);
            return 1;
        }
    }

    /* we shouldn't get here */
    ndbfree(t);
    return 0;
}
@

<<function [[iplookup]]>>=
/*
 *  lookup (and translate) an ip destination
 */
Ndbtuple*
iplookup(Network *np, char *host, char *serv, int nolookup)
{
    char *attr, *dnsname;
    Ndbtuple *t, *nt;
    Ndbs s;
    char ts[Maxservice];
    char dollar[Maxhost];
    uchar ip[IPaddrlen];
    uchar net[IPaddrlen];
    uchar tnet[IPaddrlen];
    Ipifc *ifc;
    Iplifc *lifc;

    USED(nolookup);

    /*
     *  start with the service since it's the most likely to fail
     *  and costs the least
     */
    werrstr("can't translate address");
    if(serv==0 || ipserv(np, serv, ts, sizeof ts) == 0){
        werrstr("can't translate service");
        return 0;
    }

    /* for dial strings with no host */
    if(strcmp(host, "*") == 0)
        return ndbnew("ip", "*");

    /*
     *  hack till we go v6 :: = 0.0.0.0
     */
    if(strcmp("::", host) == 0)
        return ndbnew("ip", "*");

    /*
     *  '$' means the rest of the name is an attribute that we
     *  need to search for
     */
    if(*host == '$'){
        if(ipattrlookup(db, ipaddr, host+1, dollar, sizeof dollar))
            host = dollar;
    }

    /*
     *  turn '[ip address]' into just 'ip address'
     */
    if(*host == '[' && host[strlen(host)-1] == ']'){
        host++;
        host[strlen(host)-1] = 0;
    }

    /*
     *  just accept addresses
     */
    attr = ipattr(host);
    if(strcmp(attr, "ip") == 0)
        return ndbnew("ip", host);

    /*
     *  give the domain name server the first opportunity to
     *  resolve domain names.  if that fails try the database.
     */
    t = 0;
    werrstr("can't translate address");
    if(strcmp(attr, "dom") == 0)
        t = dnsiplookup(host, &s);
    if(t == 0)
        free(ndbgetvalue(db, &s, attr, host, "ip", &t));
    if(t == 0){
        dnsname = ndbgetvalue(db, &s, attr, host, "dom", nil);
        if(dnsname){
            t = dnsiplookup(dnsname, &s);
            free(dnsname);
        }
    }
    if(t == 0)
        t = dnsiplookup(host, &s);
    if(t == 0)
        return 0;

    /*
     *  reorder the tuple to have the matched line first and
     *  save that in the request structure.
     */
    t = reorder(t, s.t);

    /*
     * reorder according to our interfaces
     */
    lock(&ipifclock);
    for(ifc = ipifcs; ifc != nil; ifc = ifc->next){
        for(lifc = ifc->lifc; lifc != nil; lifc = lifc->next){
            maskip(lifc->ip, lifc->mask, net);
            for(nt = t; nt; nt = nt->entry){
                if(strcmp(nt->attr, "ip") != 0)
                    continue;
                parseip(ip, nt->val);
                maskip(ip, lifc->mask, tnet);
                if(memcmp(net, tnet, IPaddrlen) == 0){
                    t = reorder(t, nt);
                    unlock(&ipifclock);
                    return t;
                }
            }
        }
    }
    unlock(&ipifclock);

    return t;
}
@

<<function [[iptrans]]>>=
/*
 *  translate an ip address
 */
char*
iptrans(Ndbtuple *t, Network *np, char *serv, char *rem, int hack)
{
    char ts[Maxservice];
    char reply[Maxreply];
    char x[Maxservice];

    if(strcmp(t->attr, "ip") != 0)
        return 0;

    if(serv == 0 || ipserv(np, serv, ts, sizeof ts) == 0){
        werrstr("can't translate service");
        return 0;
    }
    if(rem != nil)
        snprint(x, sizeof(x), "!%s", rem);
    else
        *x = 0;

    if(*t->val == '*')
        snprint(reply, sizeof(reply), "%s/%s/clone %s%s",
            mntpt, np->net, ts, x);
    else
        snprint(reply, sizeof(reply), "%s/%s/clone %s!%s%s%s",
            mntpt, np->net, t->val, ts, x, hack? "!fasttimeout": "");

    return strdup(reply);
}
@

<<function [[telcolookup]]>>=
/*
 *  lookup a telephone number
 */
Ndbtuple*
telcolookup(Network *np, char *host, char *serv, int nolookup)
{
    Ndbtuple *t;
    Ndbs s;

    USED(np, nolookup, serv);

    werrstr("can't translate address");
    free(ndbgetvalue(db, &s, "sys", host, "telco", &t));
    if(t == 0)
        return ndbnew("telco", host);

    return reorder(t, s.t);
}
@

<<function [[telcotrans]]>>=
/*
 *  translate a telephone address
 */
char*
telcotrans(Ndbtuple *t, Network *np, char *serv, char *rem, int)
{
    char reply[Maxreply];
    char x[Maxservice];

    if(strcmp(t->attr, "telco") != 0)
        return 0;

    if(rem != nil)
        snprint(x, sizeof(x), "!%s", rem);
    else
        *x = 0;
    if(serv)
        snprint(reply, sizeof(reply), "%s/%s/clone %s!%s%s", mntpt, np->net,
            t->val, serv, x);
    else
        snprint(reply, sizeof(reply), "%s/%s/clone %s%s", mntpt, np->net,
            t->val, x);
    return strdup(reply);
}
@

<<function [[reorder]]>>=
/*
 *  reorder the tuple to put x's line first in the entry
 */
Ndbtuple*
reorder(Ndbtuple *t, Ndbtuple *x)
{
    Ndbtuple *nt;
    Ndbtuple *line;

    /* find start of this entry's line */
    for(line = x; line->entry == line->line; line = line->line)
        ;
    line = line->line;
    if(line == t)
        return t;	/* already the first line */

    /* remove this line and everything after it from the entry */
    for(nt = t; nt->entry != line; nt = nt->entry)
        ;
    nt->entry = 0;

    /* make that the start of the entry */
    for(nt = line; nt->entry; nt = nt->entry)
        ;
    nt->entry = t;
    return line;
}
@

<<function [[slave]]([[(networking/ndb/cs.c)]])>>=
/*
 *  create a slave process to handle a request to avoid one request blocking
 *  another.  parent returns to job loop.
 */
void
slave(char *host)
{
    if(*isslave)
        return;		/* we're already a slave process */

    switch(rfork(RFPROC|RFNOTEG|RFMEM|RFNOWAIT)){
    case -1:
        break;
    case 0:
        if(debug)
            syslog(0, logfile, "slave %d", getpid());
        procsetname("%s", host);
        *isslave = 1;
        break;
    default:
        longjmp(masterjmp, 1);
    }

}
@

<<function [[dnsip6lookup]]>>=
static Ndbtuple*
dnsip6lookup(char *mntpt, char *buf, Ndbtuple *t)
{
    Ndbtuple *t6, *tt;

    t6 = dnsquery(mntpt, buf, "ipv6");	/* lookup AAAA dns RRs */
    if (t6 == nil)
        return t;

    /* convert ipv6 attr to ip */
    for (tt = t6; tt != nil; tt = tt->entry)
        if (strcmp(tt->attr, "ipv6") == 0)
            strncpy(tt->attr, "ip", sizeof tt->attr - 1);

    if (t == nil)
        return t6;

    /* append t6 list to t list */
    for (tt = t; tt->entry != nil; tt = tt->entry)
        ;
    tt->entry = t6;
    return t;
}
@

<<function [[dnsiplookup]]>>=
/*
 *  call the dns process and have it try to translate a name
 */
Ndbtuple*
dnsiplookup(char *host, Ndbs *s)
{
    char buf[Maxreply];
    Ndbtuple *t;

    unlock(&dblock);

    /* save the name before starting a slave */
    snprint(buf, sizeof(buf), "%s", host);

    slave(host);

    if(strcmp(ipattr(buf), "ip") == 0)
        t = dnsquery(mntpt, buf, "ptr");
    else {
        t = dnsquery(mntpt, buf, "ip");
        /* special case: query ipv6 (AAAA dns RR) too */
        if (ipv6lookups)
            t = dnsip6lookup(mntpt, buf, t);
    }
    s->t = t;

    if(t == nil){
        rerrstr(buf, sizeof buf);
        if(strstr(buf, "exist"))
            werrstr("can't translate address: %s", buf);
        else if(strstr(buf, "dns failure"))
            werrstr("temporary problem: %s", buf);
    }

    lock(&dblock);
    return t;
}
@

<<function [[qmatch]]>>=
int
qmatch(Ndbtuple *t, char **attr, char **val, int n)
{
    int i, found;
    Ndbtuple *nt;

    for(i = 1; i < n; i++){
        found = 0;
        for(nt = t; nt; nt = nt->entry)
            if(strcmp(attr[i], nt->attr) == 0)
                if(strcmp(val[i], "*") == 0
                || strcmp(val[i], nt->val) == 0){
                    found = 1;
                    break;
                }
        if(found == 0)
            break;
    }
    return i == n;
}
@

<<function [[qreply]]>>=
void
qreply(Mfile *mf, Ndbtuple *t)
{
    Ndbtuple *nt;
    String *s;

    s = s_new();
    for(nt = t; mf->nreply < Nreply && nt; nt = nt->entry){
        s_append(s, nt->attr);
        s_append(s, "=");
        s_append(s, nt->val);

        if(nt->line != nt->entry){
            mf->replylen[mf->nreply] = s_len(s);
            mf->reply[mf->nreply++] = strdup(s_to_c(s));
            s_restart(s);
        } else
            s_append(s, " ");
    }
    s_free(s);
}
@

<<enum [[_anon_ (networking/ndb/cs.c)3]]>>=
enum
{
    Maxattr=	32,
};
@

<<function [[genquery]]>>=
/*
 *  generic query lookup.  The query is of one of the following
 *  forms:
 *
 *  attr1=val1 attr2=val2 attr3=val3 ...
 *
 *  returns the matching tuple
 *
 *  ipinfo attr=val attr1 attr2 attr3 ...
 *
 *  is like ipinfo and returns the attr{1-n}
 *  associated with the ip address.
 */
char*
genquery(Mfile *mf, char *query)
{
    int i, n;
    char *p;
    char *attr[Maxattr];
    char *val[Maxattr];
    Ndbtuple *t;
    Ndbs s;

    n = getfields(query, attr, nelem(attr), 1, " ");
    if(n == 0)
        return "bad query";

    if(strcmp(attr[0], "ipinfo") == 0)
        return ipinfoquery(mf, attr, n);

    /* parse pairs */
    for(i = 0; i < n; i++){
        p = strchr(attr[i], '=');
        if(p == 0)
            return "bad query";
        *p++ = 0;
        val[i] = p;
    }

    /* give dns a chance */
    if((strcmp(attr[0], "dom") == 0 || strcmp(attr[0], "ip") == 0) && val[0]){
        t = dnsiplookup(val[0], &s);
        if(t){
            if(qmatch(t, attr, val, n)){
                qreply(mf, t);
                ndbfree(t);
                return 0;
            }
            ndbfree(t);
        }
    }

    /* first pair is always the key.  It can't be a '*' */
    t = ndbsearch(db, &s, attr[0], val[0]);

    /* search is the and of all the pairs */
    while(t){
        if(qmatch(t, attr, val, n)){
            qreply(mf, t);
            ndbfree(t);
            return 0;
        }

        ndbfree(t);
        t = ndbsnext(&s, attr[0], val[0]);
    }

    return "no match";
}
@

<<function [[ipresolve]]>>=
/*
 *  resolve an ip address
 */
static Ndbtuple*
ipresolve(char *attr, char *host)
{
    Ndbtuple *t, *nt, **l;

    t = iplookup(&network[Ntcp], host, "*", 0);
    for(l = &t; *l != nil; ){
        nt = *l;
        if(strcmp(nt->attr, "ip") != 0){
            *l = nt->entry;
            nt->entry = nil;
            ndbfree(nt);
            continue;
        }
        strcpy(nt->attr, attr);
        l = &nt->entry;
    }
    return t;
}
@

<<function [[ipinfoquery]]>>=
char*
ipinfoquery(Mfile *mf, char **list, int n)
{
    int i, nresolve;
    int resolve[Maxattr];
    Ndbtuple *t, *nt, **l;
    char *attr, *val;

    /* skip 'ipinfo' */
    list++; n--;

    if(n < 1)
        return "bad query";

    /* get search attribute=value, or assume ip=myipaddr */
    attr = *list;
    if((val = strchr(attr, '=')) != nil){
        *val++ = 0;
        list++;
        n--;
    }else{
        attr = "ip";
        val = ipaddr;
    }

    if(n < 1)
        return "bad query";

    /*
     *  don't let ndbipinfo resolve the addresses, we're
     *  better at it.
     */
    nresolve = 0;
    for(i = 0; i < n; i++)
        if(*list[i] == '@'){		/* @attr=val ? */
            list[i]++;
            resolve[i] = 1;		/* we'll resolve it */
            nresolve++;
        } else
            resolve[i] = 0;

    t = ndbipinfo(db, attr, val, list, n);
    if(t == nil)
        return "no match";

    if(nresolve != 0){
        for(l = &t; *l != nil;){
            nt = *l;

            /* already an address? */
            if(strcmp(ipattr(nt->val), "ip") == 0){
                l = &(*l)->entry;
                continue;
            }

            /* user wants it resolved? */
            for(i = 0; i < n; i++)
                if(strcmp(list[i], nt->attr) == 0)
                    break;
            if(i >= n || resolve[i] == 0){
                l = &(*l)->entry;
                continue;
            }

            /* resolve address and replace entry */
            *l = ipresolve(nt->attr, nt->val);
            while(*l != nil)
                l = &(*l)->entry;
            *l = nt->entry;

            nt->entry = nil;
            ndbfree(nt);
        }
    }

    /* make it all one line */
    for(nt = t; nt != nil; nt = nt->entry){
        if(nt->entry == nil)
            nt->line = t;
        else
            nt->line = nt->entry;
    }

    qreply(mf, t);

    return nil;
}
@

<<function [[emalloc]]([[(networking/ndb/cs.c)]])>>=
void*
emalloc(int size)
{
    void *x;

    x = malloc(size);
    if(x == nil)
        abort();
    memset(x, 0, size);
    return x;
}
@

<<function [[estrdup]]([[(networking/ndb/cs.c)]])>>=
char*
estrdup(char *s)
{
    int size;
    char *p;

    size = strlen(s)+1;
    p = malloc(size);
    if(p == nil)
        abort();
    memmove(p, s, size);
    return p;
}
@


%-------------------------------------------------------------

<<networking/ndb/cs.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <fcall.h>
#include <bio.h>
#include <ctype.h>
#include <ndb.h>
#include <ip.h>
#include <string.h>

<<enum [[_anon_ (networking/ndb/cs.c)]]>>

typedef struct Mfile	Mfile;
typedef struct Mlist	Mlist;
typedef struct Network	Network;
typedef struct Flushreq	Flushreq;
typedef struct Job	Job;

<<global [[vers]]>>

<<struct [[Mfile]]>>

<<struct [[Mlist]]>>


<<struct [[Job]]>>
<<global [[joblock]]>>
<<global [[joblist]]>>

<<global [[mlist]]>>
<<global [[mfd]]>>
<<global [[debug]]([[(networking/ndb/cs.c)]])>>
int	paranoia;
<<global [[ipv6lookups]]>>
<<global [[masterjmp]]>>
<<global [[isslave]]>>
<<global [[dbfile]]>>
Ndb	*db, *netdb;

void	rversion(Job*);
void	rflush(Job*);
void	rattach(Job*, Mfile*);
char*	rwalk(Job*, Mfile*);
void	ropen(Job*, Mfile*);
void	rcreate(Job*, Mfile*);
void	rread(Job*, Mfile*);
void	rwrite(Job*, Mfile*);
void	rclunk(Job*, Mfile*);
void	rremove(Job*, Mfile*);
void	rstat(Job*, Mfile*);
void	rwstat(Job*, Mfile*);
void	rauth(Job*);
void	sendmsg(Job*, char*);
void	error(char*);
void	mountinit(char*, char*);
void	io(void);
void	ndbinit(void);
void	netinit(int);
void	netadd(char*);
char	*genquery(Mfile*, char*);
char*	ipinfoquery(Mfile*, char**, int);
int	needproto(Network*, Ndbtuple*);
int	lookup(Mfile*);
Ndbtuple*	reorder(Ndbtuple*, Ndbtuple*);
void	ipid(void);
void	readipinterfaces(void);
void*	emalloc(int);
char*	estrdup(char*);
Job*	newjob(void);
void	freejob(Job*);
void	setext(char*, int, char*);
void	cleanmf(Mfile*);

extern void	paralloc(void);

<<global [[dblock]]>>
<<global [[netlock]]([[(networking/ndb/cs.c)]])>>

<<global [[logfile]]([[(networking/ndb/cs.c)]])>>
<<global [[paranoiafile]]>>

<<global [[mntpt]]>>
<<global [[netndb]]>>

/*
 *  Network specific translators
 */
Ndbtuple*	iplookup(Network*, char*, char*, int);
char*		iptrans(Ndbtuple*, Network*, char*, char*, int);
Ndbtuple*	telcolookup(Network*, char*, char*, int);
char*		telcotrans(Ndbtuple*, Network*, char*, char*, int);
Ndbtuple*	dnsiplookup(char*, Ndbs*);

<<struct [[Network]]>>

<<enum [[_anon_ (networking/ndb/cs.c)2]]>>

<<global [[network]]([[(networking/ndb/cs.c)]])>>

<<global [[ipifclock]]>>
<<global [[ipifcs]]>>

<<global [[eaddr]]>>
<<global [[ipaddr]]>>
<<global [[ipa]]>>
<<global [[mysysname]]>>

<<global [[netlist]]>>
<<global [[last]]([[(networking/ndb/cs.c)]])>>

<<function [[nstrcpy]]>>

<<function [[usage]]([[(networking/ndb/cs.c)]])>>

<<function [[procsetname]]([[(networking/ndb/cs.c)]])>>

<<function [[main]]([[(networking/ndb/cs.c)]])>>

<<function [[setext]]>>

<<function [[mountinit]]>>

<<function [[ndbinit]]>>

<<function [[newfid]]([[(networking/ndb/cs.c)]])>>

<<function [[newjob]]>>

<<function [[freejob]]>>

<<function [[flushjob]]>>

<<function [[io]]>>

<<function [[rversion]]>>

<<function [[rauth]]>>

<<function [[rflush]]>>

<<function [[rattach]]>>


<<function [[rwalk]]>>

<<function [[ropen]]>>

<<function [[rcreate]]>>

<<function [[rread]]>>
<<function [[cleanmf]]>>

void
rwrite(Job *job, Mfile *mf)
{
    int cnt, n;
    char *err;
    char *field[4];
    char curerr[64];

    err = 0;
    cnt = job->request.count;
    if(mf->qid.type & QTDIR){
        err = "can't write directory";
        goto send;
    }
    if(cnt >= Maxrequest){
        err = "request too long";
        goto send;
    }
    job->request.data[cnt] = 0;

    /*
     *  toggle debugging
     */
    if(strncmp(job->request.data, "debug", 5)==0){
        debug ^= 1;
        syslog(1, logfile, "debug %d", debug);
        goto send;
    }

    /*
     *  toggle ipv6 lookups
     */
    if(strncmp(job->request.data, "ipv6", 4)==0){
        ipv6lookups ^= 1;
        syslog(1, logfile, "ipv6lookups %d", ipv6lookups);
        goto send;
    }

    /*
     *  toggle debugging
     */
    if(strncmp(job->request.data, "paranoia", 8)==0){
        paranoia ^= 1;
        syslog(1, logfile, "paranoia %d", paranoia);
        goto send;
    }

    /*
     *  add networks to the default list
     */
    if(strncmp(job->request.data, "add ", 4)==0){
        if(job->request.data[cnt-1] == '\n')
            job->request.data[cnt-1] = 0;
        netadd(job->request.data+4);
        readipinterfaces();
        goto send;
    }

    /*
     *  refresh all state
     */
    if(strncmp(job->request.data, "refresh", 7)==0){
        netinit(1);
        goto send;
    }

    /* start transaction with a clean slate */
    cleanmf(mf);

    /*
     *  look for a general query
     */
    if(*job->request.data == '!'){
        err = genquery(mf, job->request.data+1);
        goto send;
    }

    if(debug)
        syslog(0, logfile, "write %s", job->request.data);
    if(paranoia)
        syslog(0, paranoiafile, "write %s by %s", job->request.data, mf->user);

    /*
     *  break up name
     */
    n = getfields(job->request.data, field, 4, 1, "!");
    switch(n){
    case 1:
        mf->net = strdup("net");
        mf->host = strdup(field[0]);
        break;
    case 4:
        mf->rem = strdup(field[3]);
        /* fall through */
    case 3:
        mf->serv = strdup(field[2]);
        /* fall through */
    case 2:
        mf->host = strdup(field[1]);
        mf->net = strdup(field[0]);
        break;
    }

    /*
     *  do the first net worth of lookup
     */
    if(lookup(mf) == 0){
        rerrstr(curerr, sizeof curerr);
        err = curerr;
    }
send:
    job->reply.count = cnt;
    sendmsg(job, err);
}

<<function [[rclunk]]>>

<<function [[rremove]]>>

<<function [[rstat]]>>

<<function [[rwstat]]>>

<<function [[sendmsg]]>>

<<function [[error]]([[(networking/ndb/cs.c)]])>>

<<function [[isvalidip]]>>

<<global [[loopbacknet]]([[(networking/ndb/cs.c)]])>>
<<global [[loopbackmask]]([[(networking/ndb/cs.c)]])>>

<<function [[readipinterfaces]]>>

<<function [[ipid]]>>

<<function [[netinit]]>>

<<function [[netadd]]>>

<<function [[lookforproto]]>>

<<function [[lookup]]([[(networking/ndb/cs.c)]])>>

<<function [[ipserv]]>>

<<function [[ipattrlookup]]>>

<<function [[iplookup]]>>

<<function [[iptrans]]>>

<<function [[telcolookup]]>>

<<function [[telcotrans]]>>

<<function [[reorder]]>>

<<function [[slave]]([[(networking/ndb/cs.c)]])>>

<<function [[dnsip6lookup]]>>

<<function [[dnsiplookup]]>>

<<function [[qmatch]]>>

<<function [[qreply]]>>

<<enum [[_anon_ (networking/ndb/cs.c)3]]>>

<<function [[genquery]]>>

<<function [[ipresolve]]>>

<<function [[ipinfoquery]]>>

<<function [[emalloc]]([[(networking/ndb/cs.c)]])>>

<<function [[estrdup]]([[(networking/ndb/cs.c)]])>>
@


\subsection*{[[networking/ndb/csquery.c]]}

<<global [[server]]>>=
char *server;
@

<<global [[status]]>>=
char *status;
@

<<global [[statusonly]]>>=
int statusonly;
@

<<function [[usage]]([[(networking/ndb/csquery.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: ndb/csquery [/net/cs [addr...]]\n");
    exits("usage");
}
@

<<function [[query]]>>=
void
query(char *addr)
{
    char buf[128];
    int fd, n;

    fd = open(server, ORDWR);
    if(fd < 0)
        sysfatal("cannot open %s: %r", server);
    if(write(fd, addr, strlen(addr)) != strlen(addr)){
        if(!statusonly)
            fprint(2, "translating %s: %r\n", addr);
        status = "errors";
        close(fd);
        return;
    }
    if(!statusonly){
        seek(fd, 0, 0);
        while((n = read(fd, buf, sizeof(buf)-1)) > 0){
            buf[n] = 0;
            print("%s\n", buf);
        }
    }
    close(fd);
}
@

<<function [[main]]([[(networking/ndb/csquery.c)]])>>=
void
main(int argc, char **argv)
{
    char *p;
    int i;
    Biobuf in;

    ARGBEGIN{
    case 's':
        statusonly = 1;
        break;
    default:
        usage();
    }ARGEND

    if(argc > 0)
        server = argv[0];
    else
        server = "/net/cs";

    if(argc > 1){
        for(i=1; i<argc; i++)
            query(argv[i]);
        exits(status);
    }

    Binit(&in, 0, OREAD);
    for(;;){
        print("> ");
        p = Brdline(&in, '\n');
        if(p == 0)
            break;
        p[Blinelen(&in)-1] = 0;
        query(p);
    }
    exits(nil);
}
@


%-------------------------------------------------------------

<<networking/ndb/csquery.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>

<<global [[server]]>>
<<global [[status]]>>
<<global [[statusonly]]>>

<<function [[usage]]([[(networking/ndb/csquery.c)]])>>

<<function [[query]]>>

<<function [[main]]([[(networking/ndb/csquery.c)]])>>
@


\subsection*{[[networking/ndb/dblookup.c]]}

<<enum [[_anon_ (networking/ndb/dblookup.c)]]>>=
enum {
    Nibwidth = 4,
    Nibmask = (1<<Nibwidth) - 1,
    V6maxrevdomdepth = 128 / Nibwidth,	/* bits / bits-per-nibble */

    /*
     * ttl for generated ptr records.  it was zero, which might seem
     * like a good idea, but some dns implementations seem to be
     * confused by a zero ttl, and instead of using the data and then
     * discarding the RR, they conclude that they don't have valid data.
     */
    Ptrttl = 120,
};
@

<<global [[db]]([[(networking/ndb/dblookup.c)]])>>=
static Ndb *db;
@

<<global [[dblock]]([[(networking/ndb/dblookup.c)]])>>=
static Lock	dblock;
@

<<global [[implemented]]>>=
static int	implemented[Tall] =
{
    [Ta]		1,
    [Taaaa]		1,
    [Tcname]	1,
    [Tmx]		1,
    [Tns]		1,
    [Tnull]		1,
    [Tptr]		1,
    [Tsoa]		1,
    [Tsrv]		1,
    [Ttxt]		1,
};
@

<<function [[nstrcpy]]([[(networking/ndb/dblookup.c)]])>>=
static void
nstrcpy(char *to, char *from, int len)
{
    strncpy(to, from, len);
    to[len-1] = 0;
}
@

<<function [[opendatabase]]>>=
int
opendatabase(void)
{
    char netdbnm[256];
    Ndb *xdb, *netdb;

    if (db)
        return 0;

    xdb = ndbopen(dbfile);		/* /lib/ndb */

    snprint(netdbnm, sizeof netdbnm, "%s/ndb", mntpt);
    netdb = ndbopen(netdbnm);	/* /net/ndb */
    if(netdb)
        netdb->nohash = 1;

    db = ndbcat(netdb, xdb);	/* both */
    return db? 0: -1;
}
@

<<function [[dblookup]]>>=
/*
 *  lookup an RR in the network database, look for matches
 *  against both the domain name and the wildcarded domain name.
 *
 *  the lock makes sure only one process can be accessing the data
 *  base at a time.  This is important since there's a lot of
 *  shared state there.
 *
 *  e.g. for x.research.bell-labs.com, first look for a match against
 *       the x.research.bell-labs.com.  If nothing matches,
 *	 try *.research.bell-labs.com.
 */
RR*
dblookup(char *name, int class, int type, int auth, int ttl)
{
    int err;
    char *wild, *cp;
    char buf[256];
    RR *rp, *tp;
    DN *dp, *ndp;

    /* so far only internet lookups are implemented */
    if(class != Cin)
        return 0;

    err = Rname;
    rp = nil;

    if(type == Tall){
        for (type = Ta; type < Tall; type++)
            if(implemented[type]) {
                tp = dblookup(name, class, type, auth, ttl);
                lock(&dnlock);
                rrcat(&rp, tp);
                unlock(&dnlock);
            }
        return rp;
    }

    lock(&dblock);
    dp = dnlookup(name, class, 1);

    if(opendatabase() < 0)
        goto out;
    if(dp->rr)
        err = 0;

    /* first try the given name */
    if(cfg.cachedb)
        rp = rrlookup(dp, type, NOneg);
    else
        rp = dblookup1(name, type, auth, ttl);
    if(rp)
        goto out;

    /* try lower case version */
    for(cp = name; *cp; cp++)
        *cp = tolower(*cp);
    if(cfg.cachedb)
        rp = rrlookup(dp, type, NOneg);
    else
        rp = dblookup1(name, type, auth, ttl);
    if(rp)
        goto out;

    /* walk the domain name trying the wildcard '*' at each position */
    for(wild = strchr(name, '.'); wild; wild = strchr(wild+1, '.')){
        snprint(buf, sizeof buf, "*%s", wild);
        ndp = dnlookup(buf, class, 1);
        if(ndp->rr)
            err = 0;
        if(cfg.cachedb)
            rp = rrlookup(ndp, type, NOneg);
        else
            rp = dblookup1(buf, type, auth, ttl);
        if(rp)
            break;
    }
out:
    /* add owner to uncached records */
    if(rp)
        for(tp = rp; tp; tp = tp->next)
            tp->owner = dp;
    else {
        /*
         * don't call it non-existent if it's not ours
         * (unless we're a resolver).
         */
        if(err == Rname && (!inmyarea(name) || cfg.resolver))
            err = Rserver;
        dp->respcode = err;
    }

    unlock(&dblock);
    return rp;
}
@

<<function [[intval]]>>=
static ulong
intval(Ndbtuple *entry, Ndbtuple *pair, char *attr, ulong def)
{
    Ndbtuple *t = look(entry, pair, attr);

    return (t? strtoul(t->val, 0, 10): def);
}
@

<<function [[dblookup1]]>>=
/*
 *  lookup an RR in the network database
 */
static RR*
dblookup1(char *name, int type, int auth, int ttl)
{
    Ndbtuple *t, *nt;
    RR *rp, *list, **l;
    Ndbs s;
    char dname[Domlen];
    char *attr;
    DN *dp;
    RR *(*f)(Ndbtuple*, Ndbtuple*);
    int found, x;

    dp = nil;
    switch(type){
    case Tptr:
        attr = "ptr";
        f = ptrrr;
        break;
    case Ta:
        attr = "ip";
        f = addrrr;
        break;
    case Taaaa:
        attr = "ipv6";
        f = addrrr;
        break;
    case Tnull:
        attr = "nullrr";
        f = nullrr;
        break;
    case Tns:
        attr = "ns";
        f = nsrr;
        break;
    case Tsoa:
        attr = "soa";
        f = soarr;
        break;
    case Tsrv:
        attr = "srv";
        f = srvrr;
        break;
    case Tmx:
        attr = "mx";
        f = mxrr;
        break;
    case Tcname:
        attr = "cname";
        f = cnamerr;
        break;
    case Taxfr:
    case Tixfr:
        return doaxfr(db, name);
    default:
//		dnslog("dnlookup1(%s) bad type", name);
        return nil;
    }

    /*
     *  find a matching entry in the database
     */
    t = nil;
    free(ndbgetvalue(db, &s, "dom", name, attr, &t));

    /*
     *  hack for local names
     */
    if(t == nil && strchr(name, '.') == nil)
        free(ndbgetvalue(db, &s, "sys", name, attr, &t));
    if(t == nil) {
//		dnslog("dnlookup1(%s) name not found", name);
        return nil;
    }

    /* search whole entry for default domain name */
    strncpy(dname, name, sizeof dname);
    for(nt = t; nt; nt = nt->entry)
        if(strcmp(nt->attr, "dom") == 0){
            nstrcpy(dname, nt->val, sizeof dname);
            break;
        }

    /* ttl is maximum of soa minttl and entry's ttl ala rfc883 */
    x = intval(t, s.t, "ttl", 0);
    if(x > ttl)
        ttl = x;

    /* default ttl is one day */
    if(ttl < 0)
        ttl = DEFTTL;

    /*
     *  The database has 2 levels of precedence; line and entry.
     *  Pairs on the same line bind tighter than pairs in the
     *  same entry, so we search the line first.
     */
    found = 0;
    list = 0;
    l = &list;
    for(nt = s.t;; ){
        if(found == 0 && strcmp(nt->attr, "dom") == 0){
            nstrcpy(dname, nt->val, sizeof dname);
            found = 1;
        }
        if(cistrcmp(attr, nt->attr) == 0){
            rp = (*f)(t, nt);
            rp->auth = auth;
            rp->db = 1;
            if(ttl)
                rp->ttl = ttl;
            if(dp == nil)
                dp = dnlookup(dname, Cin, 1);
            rp->owner = dp;
            *l = rp;
            l = &rp->next;
            nt->ptr = 1;
        }
        nt = nt->line;
        if(nt == s.t)
            break;
    }

    /* search whole entry */
    for(nt = t; nt; nt = nt->entry)
        if(nt->ptr == 0 && cistrcmp(attr, nt->attr) == 0){
            rp = (*f)(t, nt);
            rp->db = 1;
            if(ttl)
                rp->ttl = ttl;
            rp->auth = auth;
            if(dp == nil)
                dp = dnlookup(dname, Cin, 1);
            rp->owner = dp;
            *l = rp;
            l = &rp->next;
        }
    ndbfree(t);

//	dnslog("dnlookup1(%s) -> %#p", name, list);
    return list;
}
@

<<function [[addrrr]]>>=
/*
 *  make various types of resource records from a database entry
 */
static RR*
addrrr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;
    uchar addr[IPaddrlen];

    USED(entry);
    parseip(addr, pair->val);
    if(isv4(addr))
        rp = rralloc(Ta);
    else
        rp = rralloc(Taaaa);
    rp->ip = dnlookup(pair->val, Cin, 1);
    return rp;
}
@

<<function [[nullrr]]>>=
static RR*
nullrr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;

    USED(entry);
    rp = rralloc(Tnull);
    rp->null->data = (uchar*)estrdup(pair->val);
    rp->null->dlen = strlen((char*)rp->null->data);
    return rp;
}
@

<<function [[txtrr]]>>=
/*
 *  txt rr strings are at most 255 bytes long.  one
 *  can represent longer strings by multiple concatenated
 *  <= 255 byte ones.
 */
static RR*
txtrr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;
    Txt *t, **l;
    int i, len, sofar;

    USED(entry);
    rp = rralloc(Ttxt);
    l = &rp->txt;
    rp->txt = nil;
    len = strlen(pair->val);
    sofar = 0;
    while(len > sofar){
        t = emalloc(sizeof(*t));
        t->next = nil;

        i = len-sofar;
        if(i > 255)
            i = 255;

        t->p = emalloc(i+1);
        memmove(t->p, pair->val+sofar, i);
        t->p[i] = 0;
        sofar += i;

        *l = t;
        l = &t->next;
    }
    return rp;
}
@

<<function [[cnamerr]]>>=
static RR*
cnamerr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;

    USED(entry);
    rp = rralloc(Tcname);
    rp->host = dnlookup(pair->val, Cin, 1);
    return rp;
}
@

<<function [[mxrr]]>>=
static RR*
mxrr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;

    rp = rralloc(Tmx);
    rp->host = dnlookup(pair->val, Cin, 1);
    rp->pref = intval(entry, pair, "pref", 1);
    return rp;
}
@

<<function [[nsrr]]>>=
static RR*
nsrr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;
    Ndbtuple *t;

    rp = rralloc(Tns);
    rp->host = dnlookup(pair->val, Cin, 1);
    t = look(entry, pair, "soa");
    if(t && t->val[0] == 0)
        rp->local = 1;
    return rp;
}
@

<<function [[ptrrr]]>>=
static RR*
ptrrr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;

    USED(entry);
    rp = rralloc(Tns);
    rp->ptr = dnlookup(pair->val, Cin, 1);
    return rp;
}
@

<<function [[soarr]]>>=
static RR*
soarr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;
    Ndbtuple *ns, *mb, *t;
    char mailbox[Domlen];
    Ndb *ndb;
    char *p;

    rp = rralloc(Tsoa);
    rp->soa->serial = 1;
    for(ndb = db; ndb; ndb = ndb->next)
        if(ndb->mtime > rp->soa->serial)
            rp->soa->serial = ndb->mtime;

    rp->soa->retry  = intval(entry, pair, "retry", Hour);
    rp->soa->expire = intval(entry, pair, "expire", Day);
    rp->soa->minttl = intval(entry, pair, "ttl", Day);
    rp->soa->refresh = intval(entry, pair, "refresh", Day);
    rp->soa->serial = intval(entry, pair, "serial", rp->soa->serial);

    ns = look(entry, pair, "ns");
    if(ns == nil)
        ns = look(entry, pair, "dom");
    rp->host = dnlookup(ns->val, Cin, 1);

    /* accept all of:
     *  mbox=person
     *  mbox=person@machine.dom
     *  mbox=person.machine.dom
     */
    mb = look(entry, pair, "mbox");
    if(mb == nil)
        mb = look(entry, pair, "mb");
    if(mb)
        if(strchr(mb->val, '.')) {
            p = strchr(mb->val, '@');
            if(p != nil)
                *p = '.';
            rp->rmb = dnlookup(mb->val, Cin, 1);
        } else {
            snprint(mailbox, sizeof mailbox, "%s.%s",
                mb->val, ns->val);
            rp->rmb = dnlookup(mailbox, Cin, 1);
        }
    else {
        snprint(mailbox, sizeof mailbox, "postmaster.%s", ns->val);
        rp->rmb = dnlookup(mailbox, Cin, 1);
    }

    /*
     *  hang dns slaves off of the soa.  this is
     *  for managing the area.
     */
    for(t = entry; t != nil; t = t->entry)
        if(strcmp(t->attr, "dnsslave") == 0)
            addserver(&rp->soa->slaves, t->val);

    return rp;
}
@

<<function [[srvrr]]>>=
static RR*
srvrr(Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;

    rp = rralloc(Tsrv);
    rp->host = dnlookup(pair->val, Cin, 1);
    rp->srv->pri = intval(entry, pair, "pri", 0);
    rp->srv->weight = intval(entry, pair, "weight", 0);
    /* TODO: translate service name to port # */
    rp->port = intval(entry, pair, "port", 0);
    return rp;
}
@

<<function [[look]]>>=
/*
 *  Look for a pair with the given attribute.  look first on the same line,
 *  then in the whole entry.
 */
static Ndbtuple*
look(Ndbtuple *entry, Ndbtuple *line, char *attr)
{
    Ndbtuple *nt;

    /* first look on same line (closer binding) */
    for(nt = line;;){
        if(cistrcmp(attr, nt->attr) == 0)
            return nt;
        nt = nt->line;
        if(nt == line)
            break;
    }
    /* search whole tuple */
    for(nt = entry; nt; nt = nt->entry)
        if(cistrcmp(attr, nt->attr) == 0)
            return nt;
    return 0;
}
@

<<function [[linkrr]]>>=
static RR**
linkrr(RR *rp, DN *dp, RR **l)
{
    rp->owner = dp;
    rp->auth = 1;
    rp->db = 1;
    *l = rp;
    return &rp->next;
}
@

<<function [[doaxfr]]>>=
/* these are answered specially by the tcp version */
static RR*
doaxfr(Ndb *db, char *name)
{
    USED(db, name);
    return 0;
}
@

<<function [[dbfile2area]]>>=
/*
 *  read the all the soa's from the database to determine area's.
 *  this is only used when we're not caching the database.
 */
static void
dbfile2area(Ndb *db)
{
    Ndbtuple *t;

    if(debug)
        dnslog("rereading %s", db->file);
    Bseek(&db->b, 0, 0);
    while(t = ndbparse(db))
        ndbfree(t);
}
@

<<function [[dbpair2cache]]>>=
/*
 *  read the database into the cache
 */
static void
dbpair2cache(DN *dp, Ndbtuple *entry, Ndbtuple *pair)
{
    RR *rp;
    static ulong ord;

    rp = 0;
    if(cistrcmp(pair->attr, "ip") == 0 ||
       cistrcmp(pair->attr, "ipv6") == 0){
        dp->ordinal = ord++;
        rp = addrrr(entry, pair);
    } else 	if(cistrcmp(pair->attr, "ns") == 0)
        rp = nsrr(entry, pair);
    else if(cistrcmp(pair->attr, "soa") == 0) {
        rp = soarr(entry, pair);
        addarea(dp, rp, pair);
    } else if(cistrcmp(pair->attr, "mx") == 0)
        rp = mxrr(entry, pair);
    else if(cistrcmp(pair->attr, "srv") == 0)
        rp = srvrr(entry, pair);
    else if(cistrcmp(pair->attr, "cname") == 0)
        rp = cnamerr(entry, pair);
    else if(cistrcmp(pair->attr, "nullrr") == 0)
        rp = nullrr(entry, pair);
    else if(cistrcmp(pair->attr, "txtrr") == 0)
        rp = txtrr(entry, pair);
    if(rp == nil)
        return;

    rp->owner = dp;
    dnagenever(dp, 1);
    rp->db = 1;
    rp->ttl = intval(entry, pair, "ttl", rp->ttl);
    rrattach(rp, Notauthoritative);
}
@

<<function [[dbtuple2cache]]>>=
static void
dbtuple2cache(Ndbtuple *t)
{
    Ndbtuple *et, *nt;
    DN *dp;

    for(et = t; et; et = et->entry)
        if(strcmp(et->attr, "dom") == 0){
            dp = dnlookup(et->val, Cin, 1);

            /* first same line */
            for(nt = et->line; nt != et; nt = nt->line){
                dbpair2cache(dp, t, nt);
                nt->ptr = 1;
            }

            /* then rest of entry */
            for(nt = t; nt; nt = nt->entry){
                if(nt->ptr == 0)
                    dbpair2cache(dp, t, nt);
                nt->ptr = 0;
            }
        }
}
@

<<function [[dbfile2cache]]>>=
static void
dbfile2cache(Ndb *db)
{
    Ndbtuple *t;

    if(debug)
        dnslog("rereading %s", db->file);
    Bseek(&db->b, 0, 0);
    while(t = ndbparse(db)){
        dbtuple2cache(t);
        ndbfree(t);
    }
}
@

<<function [[loaddomsrvs]]>>=
/* called with dblock held */
static void
loaddomsrvs(void)
{
    Ndbs s;

    if (!cfg.inside || !cfg.straddle || !cfg.serve)
        return;
    if (indoms) {
        ndbfree(indoms);
        ndbfree(innmsrvs);
        ndbfree(outnmsrvs);
        indoms = innmsrvs = outnmsrvs = nil;
    }
    if (db == nil)
        opendatabase();
    free(ndbgetvalue(db, &s, "sys", "inside-dom", "dom", &indoms));
    free(ndbgetvalue(db, &s, "sys", "inside-ns",  "ip",  &innmsrvs));
    free(ndbgetvalue(db, &s, "sys", "outside-ns", "ip",  &outnmsrvs));
    dnslog("[%d] ndb changed: reloaded inside-dom, inside-ns, outside-ns",
        getpid());
}
@

<<function [[db2cache]]>>=
void
db2cache(int doit)
{
    ulong youngest;
    Ndb *ndb;
    Dir *d;
    static ulong lastcheck, lastyoungest;

    /* no faster than once every 2 minutes */
    if(now < lastcheck + 2*Min && !doit)
        return;

    refresh_areas(owned);

    lock(&dblock);

    if(opendatabase() < 0){
        unlock(&dblock);
        return;
    }

    /*
     *  file may be changing as we are reading it, so loop till
     *  mod times are consistent.
     *
     *  we don't use the times in the ndb records because they may
     *  change outside of refreshing our cached knowledge.
     */
    for(;;){
        lastcheck = now;
        youngest = 0;
        for(ndb = db; ndb; ndb = ndb->next)
            /* dirfstat avoids walking the mount table each time */
            if((d = dirfstat(Bfildes(&ndb->b))) != nil ||
               (d = dirstat(ndb->file)) != nil){
                if(d->mtime > youngest)
                    youngest = d->mtime;
                free(d);
            }
        if(!doit && youngest == lastyoungest)
            break;

        /* forget our area definition */
        freearea(&owned);
        freearea(&delegated);

        /* reopen all the files (to get oldest for time stamp) */
        for(ndb = db; ndb; ndb = ndb->next)
            ndbreopen(ndb);

        /* reload straddle-server configuration */
        loaddomsrvs();

        if(cfg.cachedb){
            /* mark all db records as timed out */
            dnagedb();

            /* read in new entries */
            for(ndb = db; ndb; ndb = ndb->next)
                dbfile2cache(ndb);

            /* mark as authoritative anything in our domain */
            dnauthdb();

            /* remove old entries */
            dnageall(1);
        } else
            /* read all the soa's to get database defaults */
            for(ndb = db; ndb; ndb = ndb->next)
                dbfile2area(ndb);

        doit = 0;
        lastyoungest = youngest;
        createptrs();
    }

    unlock(&dblock);
}
@

<<function [[dnforceage]]>>=
void
dnforceage(void)
{
    lock(&dblock);
    dnageall(1);
    unlock(&dblock);
}
@

<<function [[lookupinfo]]>>=
/*
 *  get all my xxx
 *  caller ndbfrees the result
 */
Ndbtuple*
lookupinfo(char *attr)
{
    char buf[64];
    char *a[2];
    Ndbtuple *t;

    snprint(buf, sizeof buf, "%I", ipaddr);
    a[0] = attr;

    lock(&dblock);
    if(opendatabase() < 0){
        unlock(&dblock);
        return nil;
    }
    t = ndbipinfo(db, "ip", buf, a, 1);
    unlock(&dblock);
    return t;
}
@

<<global [[localservers]]>>=
char *localservers =	  "local#dns#servers";
@

<<global [[localserverprefix]]>>=
char *localserverprefix = "local#dns#server";
@

<<function [[baddelegation]]>>=
/*
 *  return non-zero if this is a bad delegation
 */
int
baddelegation(RR *rp, RR *nsrp, uchar *addr)
{
    Ndbtuple *nt;
    static int whined;
    static Ndbtuple *t;

    if(t == nil)
        t = lookupinfo("dom");
    if(t == nil)
        return 0;

    for(; rp; rp = rp->next){
        if(rp->type != Tns)
            continue;

        /* see if delegation is looping */
        if(nsrp)
        if(rp->owner != nsrp->owner)
        if(subsume(rp->owner->name, nsrp->owner->name) &&
           strcmp(nsrp->owner->name, localservers) != 0){
            dnslog("delegation loop %R -> %R from %I",
                nsrp, rp, addr);
            return 1;
        }

        /* see if delegating to us what we don't own */
        for(nt = t; nt != nil; nt = nt->entry)
            if(rp->host && cistrcmp(rp->host->name, nt->val) == 0)
                break;
        if(nt != nil && !inmyarea(rp->owner->name)){
            if (!whined) {
                whined = 1;
                dnslog("bad delegation %R from %I; "
                    "no further logging of them", rp, addr);
            }
            return 1;
        }
    }

    return 0;
}
@

<<function [[myaddr]]>>=
int
myaddr(char *addr)
{
    char *name, *line, *sp;
    char buf[64];
    Biobuf *bp;

    snprint(buf, sizeof buf, "%I", ipaddr);
    if (strcmp(addr, buf) == 0) {
        dnslog("rejecting my ip %s as local dns server", addr);
        return 1;
    }

    name = smprint("%s/ipselftab", mntpt);
    bp = Bopen(name, OREAD);
    free(name);
    if (bp != nil) {
        while ((line = Brdline(bp, '\n')) != nil) {
            line[Blinelen(bp) - 1] = '\0';
            sp = strchr(line, ' ');
            if (sp) {
                *sp = '\0';
                if (strcmp(addr, line) == 0) {
                    dnslog("rejecting my ip %s as local dns server",
                        addr);
                    return 1;
                }
            }
        }
        Bterm(bp);
    }
    return 0;
}
@

<<global [[locdns]]>>=
static char *locdns[20];
@

<<global [[locdnslck]]>>=
static QLock locdnslck;
@

<<function [[addlocaldnsserver]]>>=
static void
addlocaldnsserver(DN *dp, int class, char *ipaddr, int i)
{
    int n;
    DN *nsdp;
    RR *rp;
    char buf[32];
    uchar ip[IPaddrlen];

    /* reject our own ip addresses so we don't query ourselves via udp */
    if (myaddr(ipaddr))
        return;

    qlock(&locdnslck);
    for (n = 0; n < i && n < nelem(locdns) && locdns[n]; n++)
        if (strcmp(locdns[n], ipaddr) == 0) {
            dnslog("rejecting duplicate local dns server ip %s",
                ipaddr);
            qunlock(&locdnslck);
            return;
        }
    if (n < nelem(locdns))
        if (locdns[n] == nil || ++n < nelem(locdns))
            locdns[n] = strdup(ipaddr); /* remember 1st few local ns */
    qunlock(&locdnslck);

    /* ns record for name server, make up an impossible name */
    rp = rralloc(Tns);
    snprint(buf, sizeof buf, "%s%d", localserverprefix, i);
    nsdp = dnlookup(buf, class, 1);
    rp->host = nsdp;
    rp->owner = dp;			/* e.g., local#dns#servers */
    rp->local = 1;
    rp->db = 1;
//	rp->ttl = 10*Min;		/* seems too short */
    rp->ttl = (1UL<<31)-1;
    rrattach(rp, Authoritative);	/* will not attach rrs in my area */

    /* A or AAAA record */
    if (parseip(ip, ipaddr) >= 0 && isv4(ip))
        rp = rralloc(Ta);
    else
        rp = rralloc(Taaaa);
    rp->ip = dnlookup(ipaddr, class, 1);
    rp->owner = nsdp;
    rp->local = 1;
    rp->db = 1;
//	rp->ttl = 10*Min;		/* seems too short */
    rp->ttl = (1UL<<31)-1;
    rrattach(rp, Authoritative);	/* will not attach rrs in my area */

    dnslog("added local dns server %s at %s", buf, ipaddr);
}
@
% >> >> >> >> >>

<<function [[dnsservers]]>>=
/*
 *  return list of dns server addresses to use when
 *  acting just as a resolver.
 */
RR*
dnsservers(int class)
{
    int i, n;
    char *p;
    char *args[5];
    Ndbtuple *t, *nt;
    RR *nsrp;
    DN *dp;

    dp = dnlookup(localservers, class, 1);
    nsrp = rrlookup(dp, Tns, NOneg);
    if(nsrp != nil)
        return nsrp;

    p = getenv("DNSSERVER");		/* list of ip addresses */
    if(p != nil){
        n = tokenize(p, args, nelem(args));
        for(i = 0; i < n; i++)
            addlocaldnsserver(dp, class, args[i], i);
        free(p);
    } else {
        t = lookupinfo("@dns");		/* @dns=ip1 @dns=ip2 ... */
        if(t == nil)
            return nil;
        i = 0;
        for(nt = t; nt != nil; nt = nt->entry){
            addlocaldnsserver(dp, class, nt->val, i);
            i++;
        }
        ndbfree(t);
    }

    return rrlookup(dp, Tns, NOneg);
}
@

<<function [[addlocaldnsdomain]]>>=
static void
addlocaldnsdomain(DN *dp, int class, char *domain)
{
    RR *rp;

    /* ptr record */
    rp = rralloc(Tptr);
    rp->ptr = dnlookup(domain, class, 1);
    rp->owner = dp;
    rp->db = 1;
    rp->ttl = 10*Min;
    rrattach(rp, Authoritative);
}
@

<<function [[domainlist]]>>=
/*
 *  return list of domains to use when resolving names without '.'s
 */
RR*
domainlist(int class)
{
    Ndbtuple *t, *nt;
    RR *rp;
    DN *dp;

    dp = dnlookup("local#dns#domains", class, 1);
    rp = rrlookup(dp, Tptr, NOneg);
    if(rp != nil)
        return rp;

    t = lookupinfo("dnsdomain");
    if(t == nil)
        return nil;
    for(nt = t; nt != nil; nt = nt->entry)
        addlocaldnsdomain(dp, class, nt->val);
    ndbfree(t);

    return rrlookup(dp, Tptr, NOneg);
}
@

<<global [[v4ptrdom]]>>=
char *v4ptrdom = ".in-addr.arpa";
@

<<global [[v6ptrdom]]>>=
char *v6ptrdom = ".ip6.arpa";		/* ip6.int deprecated, rfc 3152 */
@

<<global [[attribs]]>>=
char *attribs[] = {
    "ipmask",
    0
};
@

<<function [[createv4ptrs]]>>=
/*
 *  create ptrs that are in our v4 areas
 */
static void
createv4ptrs(void)
{
    int len, dlen, n;
    char *dom;
    char buf[Domlen+1], ipa[48];
    char *f[40];
    uchar net[IPaddrlen], mask[IPaddrlen];
    Area *s;
    Ndbtuple *t, *nt;

    dlen = strlen(v4ptrdom);
    for(s = owned; s; s = s->next){
        dom = s->soarr->owner->name;
        len = strlen(dom);
        if((len <= dlen || cistrcmp(dom+len-dlen, v4ptrdom) != 0) &&
            cistrcmp(dom, v4ptrdom+1) != 0)
            continue;

        /* get mask and net value */
        strncpy(buf, dom, sizeof buf);
        buf[sizeof buf-1] = 0;
        /* buf contains something like 178.204.in-addr.arpa (n==4) */
        n = getfields(buf, f, nelem(f), 0, ".");
        memset(mask, 0xff, IPaddrlen);
        ipmove(net, v4prefix);
        switch(n){
        case 3:			/* /8 */
            net[IPv4off] = atoi(f[0]);
            mask[IPv4off+1] = 0;
            mask[IPv4off+2] = 0;
            mask[IPv4off+3] = 0;
            break;
        case 4:			/* /16 */
            net[IPv4off] = atoi(f[1]);
            net[IPv4off+1] = atoi(f[0]);
            mask[IPv4off+2] = 0;
            mask[IPv4off+3] = 0;
            break;
        case 5:			/* /24 */
            net[IPv4off] = atoi(f[2]);
            net[IPv4off+1] = atoi(f[1]);
            net[IPv4off+2] = atoi(f[0]);
            mask[IPv4off+3] = 0;
            break;
        case 6:		/* rfc2317: classless in-addr.arpa delegation */
            net[IPv4off] = atoi(f[3]);
            net[IPv4off+1] = atoi(f[2]);
            net[IPv4off+2] = atoi(f[1]);
            net[IPv4off+3] = atoi(f[0]);
            sprint(ipa, "%I", net);
            t = ndbipinfo(db, "ip", ipa, attribs, 1);
            if(t == nil)	/* could be a reverse with no forward */
                continue;
            nt = look(t, t, "ipmask");
            if(nt == nil){		/* we're confused */
                ndbfree(t);
                continue;
            }
            parseipmask(mask, nt->val);
            ndbfree(t);
            n = 5;
            break;
        default:
            continue;
        }

        /*
         * go through all domain entries looking for RR's
         * in this network and create ptrs.
         * +2 for ".in-addr.arpa".
         */
        dnptr(net, mask, dom, Ta, 4+2-n, Ptrttl);
    }
}
@

<<function [[bytes2nibbles]]>>=
/* convert bytes to nibbles, big-endian */
void
bytes2nibbles(uchar *nibbles, uchar *bytes, int nbytes)
{
    while (nbytes-- > 0) {
        *nibbles++ = *bytes >> Nibwidth;
        *nibbles++ = *bytes++ & Nibmask;
    }
}
@

<<function [[nibbles2bytes]]>>=
void
nibbles2bytes(uchar *bytes, uchar *nibbles, int nnibs)
{
    for (; nnibs >= 2; nnibs -= 2) {
        *bytes++ = nibbles[0] << Nibwidth | (nibbles[1]&Nibmask);
        nibbles += 2;
    }
    if (nnibs > 0)
        *bytes = nibbles[0] << Nibwidth;
}
@

<<function [[createv6ptrs]]>>=
/*
 *  create ptrs that are in our v6 areas.  see rfc3596
 */
static void
createv6ptrs(void)
{
    int len, dlen, i, n, pfxnibs;
    char *dom;
    char buf[Domlen+1];
    char *f[40];
    uchar net[IPaddrlen], mask[IPaddrlen];
    uchar nibnet[IPaddrlen*2], nibmask[IPaddrlen*2];
    Area *s;

    dlen = strlen(v6ptrdom);
    for(s = owned; s; s = s->next){
        dom = s->soarr->owner->name;
        len = strlen(dom);
        if((len <= dlen || cistrcmp(dom+len-dlen, v6ptrdom) != 0) &&
            cistrcmp(dom, v6ptrdom+1) != 0)
            continue;

        /* get mask and net value */
        strncpy(buf, dom, sizeof buf);
        buf[sizeof buf-1] = 0;
        /* buf contains something like 2.0.0.2.ip6.arpa (n==6) */
        n = getfields(buf, f, nelem(f), 0, ".");
        pfxnibs = n - 2;		/* 2 for .ip6.arpa */
        if (pfxnibs < 0 || pfxnibs > V6maxrevdomdepth)
            continue;

        memset(net, 0, IPaddrlen);
        memset(mask, 0xff, IPaddrlen);
        bytes2nibbles(nibnet, net, IPaddrlen);
        bytes2nibbles(nibmask, mask, IPaddrlen);

        /* copy prefix of f, in reverse order, to start of net. */
        for (i = 0; i < pfxnibs; i++)
            nibnet[i] = strtol(f[pfxnibs - 1 - i], nil, 16);
        /* zero nibbles of mask after prefix in net */
        memset(nibmask + pfxnibs, 0, V6maxrevdomdepth - pfxnibs);

        nibbles2bytes(net, nibnet, 2*IPaddrlen);
        nibbles2bytes(mask, nibmask, 2*IPaddrlen);

        /*
         * go through all domain entries looking for RR's
         * in this network and create ptrs.
         */
        dnptr(net, mask, dom, Taaaa, V6maxrevdomdepth - pfxnibs, Ptrttl);
    }
}
@

<<function [[createptrs]]>>=
/*
 *  create ptrs that are in our areas
 */
static void
createptrs(void)
{
    createv4ptrs();
    createv6ptrs();
}
@

<<function [[insideaddr]]>>=
/*
 * is this domain (or DOMAIN or Domain or dOMAIN)
 * internal to our organisation (behind our firewall)?
 * only inside straddling servers care, everybody else gets told `yes',
 * so they'll use mntpt for their queries.
 */
int
insideaddr(char *dom)
{
    int domlen, vallen, rv;
    Ndbtuple *t;

    if (!cfg.inside || !cfg.straddle || !cfg.serve)
        return 1;
    if (dom[0] == '\0' || strcmp(dom, ".") == 0)	/* dns root? */
        return 1;			/* hack for initialisation */

    lock(&dblock);
    if (indoms == nil)
        loaddomsrvs();
    if (indoms == nil) {
        unlock(&dblock);
        return 1;  /* no "inside-dom" sys, try inside nameservers */
    }

    rv = 0;
    domlen = strlen(dom);
    for (t = indoms; t != nil; t = t->entry) {
        if (strcmp(t->attr, "dom") != 0)
            continue;
        vallen = strlen(t->val);
        if (cistrcmp(dom, t->val) == 0 ||
            domlen > vallen &&
             cistrcmp(dom + domlen - vallen, t->val) == 0 &&
             dom[domlen - vallen - 1] == '.') {
            rv = 1;
            break;
        }
    }
    unlock(&dblock);
    return rv;
}
@

<<function [[insidens]]>>=
int
insidens(uchar *ip)
{
    uchar ipa[IPaddrlen];
    Ndbtuple *t;

    for (t = innmsrvs; t != nil; t = t->entry)
        if (strcmp(t->attr, "ip") == 0) {
            parseip(ipa, t->val);
            if (memcmp(ipa, ip, sizeof ipa) == 0)
                return 1;
        }
    return 0;
}
@

<<function [[outsidens]]>>=
uchar *
outsidens(int n)
{
    int i;
    Ndbtuple *t;
    static uchar ipa[IPaddrlen];

    i = 0;
    for (t = outnmsrvs; t != nil; t = t->entry)
        if (strcmp(t->attr, "ip") == 0 && i++ == n) {
            parseip(ipa, t->val);
            return ipa;
        }
    return nil;
}
@


%-------------------------------------------------------------

<<networking/ndb/dblookup.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>
#include <ip.h>
#include "dns.h"

<<enum [[_anon_ (networking/ndb/dblookup.c)]]>>

<<global [[db]]([[(networking/ndb/dblookup.c)]])>>
<<global [[dblock]]([[(networking/ndb/dblookup.c)]])>>

static RR*	addrrr(Ndbtuple*, Ndbtuple*);
static RR*	cnamerr(Ndbtuple*, Ndbtuple*);
static void	createptrs(void);
static RR*	dblookup1(char*, int, int, int);
static RR*	doaxfr(Ndb*, char*);
static Ndbtuple*look(Ndbtuple*, Ndbtuple*, char*);
static RR*	mxrr(Ndbtuple*, Ndbtuple*);
static RR*	nsrr(Ndbtuple*, Ndbtuple*);
static RR*	nullrr(Ndbtuple*, Ndbtuple*);
static RR*	ptrrr(Ndbtuple*, Ndbtuple*);
static RR*	soarr(Ndbtuple*, Ndbtuple*);
static RR*	srvrr(Ndbtuple*, Ndbtuple*);
static RR*	txtrr(Ndbtuple*, Ndbtuple*);

<<global [[implemented]]>>

/* straddle server configuration */
static Ndbtuple *indoms, *innmsrvs, *outnmsrvs;

<<function [[nstrcpy]]([[(networking/ndb/dblookup.c)]])>>

<<function [[opendatabase]]>>

<<function [[dblookup]]>>

<<function [[intval]]>>

<<function [[dblookup1]]>>

<<function [[addrrr]]>>
<<function [[nullrr]]>>
<<function [[txtrr]]>>
<<function [[cnamerr]]>>
<<function [[mxrr]]>>
<<function [[nsrr]]>>
<<function [[ptrrr]]>>
<<function [[soarr]]>>

<<function [[srvrr]]>>

<<function [[look]]>>

<<function [[linkrr]]>>

<<function [[doaxfr]]>>


<<function [[dbfile2area]]>>

<<function [[dbpair2cache]]>>
<<function [[dbtuple2cache]]>>
<<function [[dbfile2cache]]>>

<<function [[loaddomsrvs]]>>

<<function [[db2cache]]>>

<<function [[dnforceage]]>>

extern uchar	ipaddr[IPaddrlen];	/* my ip address */

<<function [[lookupinfo]]>>

<<global [[localservers]]>>
<<global [[localserverprefix]]>>

<<function [[baddelegation]]>>

<<function [[myaddr]]>>

<<global [[locdns]]>>
<<global [[locdnslck]]>>

<<function [[addlocaldnsserver]]>>

<<function [[dnsservers]]>>

<<function [[addlocaldnsdomain]]>>

<<function [[domainlist]]>>

<<global [[v4ptrdom]]>>
<<global [[v6ptrdom]]>>

<<global [[attribs]]>>

<<function [[createv4ptrs]]>>

<<function [[bytes2nibbles]]>>

<<function [[nibbles2bytes]]>>

<<function [[createv6ptrs]]>>

<<function [[createptrs]]>>

<<function [[insideaddr]]>>

<<function [[insidens]]>>

<<function [[outsidens]]>>
@


\subsection*{[[networking/ndb/dn.c]]}

<<enum [[_anon_ (networking/ndb/dn.c)]]>>=
/*
 *  this comment used to say `our target is 4000 names cached, this should
 *  be larger on large servers'.  dns at Bell Labs starts off with
 *  about 1780 names.
 *
 *  aging corrupts the cache, so raise the trigger to avoid it.
 */
enum {
    Deftarget	= 1<<30,	/* effectively disable aging */
    Minage		= 1<<30,
    Defagefreq	= 1<<30,	/* age names this often (seconds) */

    /* these settings will trigger frequent aging */
//	Deftarget	= 4000,
//	Minage		=  5*60,
//	Defagefreq	= 15*60,	/* age names this often (seconds) */

    Restartmins	= 0,
//	Restartmins	= 600,
};
@

<<global [[ht]]>>=
/*
 *  Hash table for domain names.  The hash is based only on the
 *  first element of the domain name.
 */
DN *ht[HTLEN];
@

<<global [[dnvars]]>>=
static struct {
    Lock;
    ulong	names;		/* names allocated */
    ulong	oldest;		/* longest we'll leave a name around */
    int	active;
    int	mutex;
    ushort	id;		/* same size as in packet */
} dnvars;
@

<<global [[rrtname]]([[(networking/ndb/dn.c)]])>>=
/* names of RR types */
char *rrtname[] =
{
[Ta]		"ip",
[Tns]		"ns",
[Tmd]		"md",
[Tmf]		"mf",
[Tcname]	"cname",
[Tsoa]		"soa",
[Tmb]		"mb",
[Tmg]		"mg",
[Tmr]		"mr",
[Tnull]		"null",
[Twks]		"wks",
[Tptr]		"ptr",
[Thinfo]	"hinfo",
[Tminfo]	"minfo",
[Tmx]		"mx",
[Ttxt]		"txt",
[Trp]		"rp",
[Tafsdb]	"afsdb",
[Tx25]		"x.25",
[Tisdn]		"isdn",
[Trt]		"rt",
[Tnsap]		"nsap",
[Tnsapptr]	"nsap-ptr",
[Tsig]		"sig",
[Tkey]		"key",
[Tpx]		"px",
[Tgpos]		"gpos",
[Taaaa]		"ipv6",
[Tloc]		"loc",
[Tnxt]		"nxt",
[Teid]		"eid",
[Tnimloc]	"nimrod",
[Tsrv]		"srv",
[Tatma]		"atma",
[Tnaptr]	"naptr",
[Tkx]		"kx",
[Tcert]		"cert",
[Ta6]		"a6",
[Tdname]	"dname",
[Tsink]		"sink",
[Topt]		"opt",
[Tapl]		"apl",
[Tds]		"ds",
[Tsshfp]	"sshfp",
[Tipseckey]	"ipseckey",
[Trrsig]	"rrsig",
[Tnsec]		"nsec",
[Tdnskey]	"dnskey",
[Tspf]		"spf",
[Tuinfo]	"uinfo",
[Tuid]		"uid",
[Tgid]		"gid",
[Tunspec]	"unspec",
[Ttkey]		"tkey",
[Ttsig]		"tsig",
[Tixfr]		"ixfr",
[Taxfr]		"axfr",
[Tmailb]	"mailb",
[Tmaila]	"maila",
[Tall]		"all",
        0,
};
@

<<global [[rname]]>>=
/* names of response codes */
char *rname[Rmask+1] =
{
[Rok]			"ok",
[Rformat]		"format error",
[Rserver]		"server failure",
[Rname]			"bad name",
[Runimplimented]	"unimplemented",
[Rrefused]		"we don't like you",
[Ryxdomain]		"name should not exist",
[Ryxrrset]		"rr set should not exist",
[Rnxrrset]		"rr set should exist",
[Rnotauth]		"not authorative",
[Rnotzone]		"not in zone",
[Rbadvers]		"bad opt version",
/* [Rbadsig]		"bad signature", */
[Rbadkey]		"bad key",
[Rbadtime]		"bad signature time",
[Rbadmode]		"bad mode",
[Rbadname]		"duplicate key name",
[Rbadalg]		"bad algorithm",
};
@

<<global [[nrname]]>>=
unsigned nrname = nelem(rname);
@

<<global [[opname]]>>=
/* names of op codes */
char *opname[] =
{
[Oquery]	"query",
[Oinverse]	"inverse query (retired)",
[Ostatus]	"status",
[Oupdate]	"update",
};
@

<<global [[target]]>>=
ulong target = Deftarget;
@

<<global [[start]]>>=
ulong start;
@

<<global [[dnlock]]>>=
Lock	dnlock;
@

<<global [[agefreq]]>>=
static ulong agefreq = Defagefreq;
@

<<function [[ding]]([[(networking/ndb/dn.c)]])>>=
static void
ding(void*, char *msg)
{
    if(strstr(msg, "alarm") != nil) {
        stats.alarms++;
        noted(NCONT);		/* resume with system call error */
    } else
        noted(NDFLT);		/* die */
}
@

<<function [[dninit]]>>=
void
dninit(void)
{
    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('V', eipfmt);
    fmtinstall('R', rrfmt);
    fmtinstall('Q', rravfmt);
    fmtinstall('H', sencodefmt);

    dnvars.oldest = maxage;
    dnvars.names = 0;
    dnvars.id = truerand();	/* don't start with same id every time */

    notify(ding);
}
@

<<function [[dnhash]]>>=
/*
 *  hash for a domain name
 */
static ulong
dnhash(char *name)
{
    ulong hash;
    uchar *val = (uchar*)name;

    for(hash = 0; *val; val++)
        hash = hash*13 + tolower(*val)-'a';
    return hash % HTLEN;
}
@

<<function [[dnlookup]]([[(networking/ndb/dn.c)]])>>=
/*
 *  lookup a symbol.  if enter is not zero and the name is
 *  not found, create it.
 */
DN*
dnlookup(char *name, int class, int enter)
{
    DN **l;
    DN *dp;

    l = &ht[dnhash(name)];
    lock(&dnlock);
    for(dp = *l; dp; dp = dp->next) {
        assert(dp->magic == DNmagic);
        if(dp->class == class && cistrcmp(dp->name, name) == 0){
            dp->referenced = now;
            unlock(&dnlock);
            return dp;
        }
        l = &dp->next;
    }

    if(!enter){
        unlock(&dnlock);
        return 0;
    }
    dnvars.names++;
    dp = emalloc(sizeof(*dp));
    dp->magic = DNmagic;
    dp->name = estrdup(name);
    assert(dp->name != nil);
    dp->class = class;
    dp->rr = 0;
    dp->referenced = now;
    /* add new DN to tail of the hash list.  *l points to last next ptr. */
    dp->next = nil;
    *l = dp;
    unlock(&dnlock);

    return dp;
}
@

<<function [[rrsame]]>>=
static int
rrsame(RR *rr1, RR *rr2)
{
    return rr1 == rr2 || rr2 && rrequiv(rr1, rr2) &&
        rr1->db == rr2->db && rr1->auth == rr2->auth;
}
@

<<function [[rronlist]]>>=
static int
rronlist(RR *rp, RR *lp)
{
    for(; lp; lp = lp->next)
        if (rrsame(lp, rp))
            return 1;
    return 0;
}
@

<<function [[dnstats]]>>=
/*
 * dump the stats
 */
void
dnstats(char *file)
{
    int i, fd;

    fd = create(file, OWRITE, 0666);
    if(fd < 0)
        return;

    qlock(&stats);
    fprint(fd, "# system %s\n", sysname());
    fprint(fd, "# slave procs high-water mark\t%lud\n", stats.slavehiwat);
    fprint(fd, "# queries received by 9p\t%lud\n", stats.qrecvd9p);
    fprint(fd, "# queries received by udp\t%lud\n", stats.qrecvdudp);
    fprint(fd, "# queries answered from memory\t%lud\n", stats.answinmem);
    fprint(fd, "# queries sent by udp\t%lud\n", stats.qsent);
    for (i = 0; i < nelem(stats.under10ths); i++)
        if (stats.under10ths[i] || i == nelem(stats.under10ths) - 1)
            fprint(fd, "# responses arriving within %.1f s.\t%lud\n",
                (double)(i+1)/10, stats.under10ths[i]);
    fprint(fd, "\n# queries sent & timed-out\t%lud\n", stats.tmout);
    fprint(fd, "# cname queries timed-out\t%lud\n", stats.tmoutcname);
    fprint(fd, "# ipv6  queries timed-out\t%lud\n", stats.tmoutv6);
    fprint(fd, "\n# negative answers received\t%lud\n", stats.negans);
    fprint(fd, "# negative answers w Rserver set\t%lud\n", stats.negserver);
    fprint(fd, "# negative answers w bad delegation\t%lud\n",
        stats.negbaddeleg);
    fprint(fd, "# negative answers w bad delegation & no answers\t%lud\n",
        stats.negbdnoans);
    fprint(fd, "# negative answers w no Rname set\t%lud\n", stats.negnorname);
    fprint(fd, "# negative answers cached\t%lud\n", stats.negcached);
    qunlock(&stats);

    lock(&dnlock);
    fprint(fd, "\n# domain names %lud target %lud\n", dnvars.names, target);
    unlock(&dnlock);
    close(fd);
}
@

<<function [[dndump]]>>=
/*
 *  dump the cache
 */
void
dndump(char *file)
{
    int i, fd;
    DN *dp;
    RR *rp;

    fd = create(file, OWRITE, 0666);
    if(fd < 0)
        return;

    lock(&dnlock);
    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next){
            fprint(fd, "%s\n", dp->name);
            for(rp = dp->rr; rp; rp = rp->next) {
                fprint(fd, "\t%R %c%c %lud/%lud\n",
                    rp, rp->auth? 'A': 'U',
                    rp->db? 'D': 'N', rp->expire, rp->ttl);
                if (rronlist(rp, rp->next))
                    fprint(fd, "*** duplicate:\n");
            }
        }
    unlock(&dnlock);
    close(fd);
}
@

<<function [[dnpurge]]>>=
/*
 *  purge all records
 */
void
dnpurge(void)
{
    DN *dp;
    RR *rp, *srp;
    int i;

    lock(&dnlock);

    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next){
            srp = rp = dp->rr;
            dp->rr = nil;
            for(; rp != nil; rp = rp->next)
                rp->cached = 0;
            rrfreelist(srp);
        }

    unlock(&dnlock);
}
@

<<function [[rrdelhead]]>>=
/*
 *  delete head of *l and free the old head.
 *  call with dnlock held.
 */
static void
rrdelhead(RR **l)
{
    RR *rp;

    if (canlock(&dnlock))
        abort();	/* rrdelhead called with dnlock not held */
    rp = *l;
    if(rp == nil)
        return;
    *l = rp->next;		/* unlink head */
    rp->cached = 0;		/* avoid blowing an assertion in rrfree */
    rrfree(rp);
}
@

<<function [[dnage]]>>=
/*
 *  check the age of resource records, free any that have timed out.
 *  call with dnlock held.
 */
void
dnage(DN *dp)
{
    RR **l;
    RR *rp, *next;
    ulong diff;

    if (canlock(&dnlock))
        abort();	/* dnage called with dnlock not held */
    diff = now - dp->referenced;
    if(diff < Reserved || dp->keep)
        return;

    l = &dp->rr;
    for(rp = dp->rr; rp; rp = next){
        assert(rp->magic == RRmagic && rp->cached);
        next = rp->next;
        if(!rp->db && (rp->expire < now || diff > dnvars.oldest))
            rrdelhead(l); /* rp == *l before; *l == rp->next after */
        else
            l = &rp->next;
    }
}
@

<<macro [[MARK]]>>=
#define MARK(dp)	{ if (dp) (dp)->keep = 1; }
@

<<function [[dnagenever]]>>=
/* mark a domain name and those in its RRs as never to be aged */
void
dnagenever(DN *dp, int dolock)
{
    RR *rp;

    if (dolock)
        lock(&dnlock);

    /* mark all referenced domain names */
    MARK(dp);
    for(rp = dp->rr; rp; rp = rp->next){
        MARK(rp->owner);
        if(rp->negative){
            MARK(rp->negsoaowner);
            continue;
        }
        switch(rp->type){
        case Thinfo:
            MARK(rp->cpu);
            MARK(rp->os);
            break;
        case Ttxt:
            break;
        case Tcname:
        case Tmb:
        case Tmd:
        case Tmf:
        case Tns:
        case Tmx:
        case Tsrv:
            MARK(rp->host);
            break;
        case Tmg:
        case Tmr:
            MARK(rp->mb);
            break;
        case Tminfo:
            MARK(rp->rmb);
            MARK(rp->mb);
            break;
        case Trp:
            MARK(rp->rmb);
            MARK(rp->rp);
            break;
        case Ta:
        case Taaaa:
            MARK(rp->ip);
            break;
        case Tptr:
            MARK(rp->ptr);
            break;
        case Tsoa:
            MARK(rp->host);
            MARK(rp->rmb);
            break;
        }
    }

    if (dolock)
        unlock(&dnlock);
}
@

<<function [[dnageallnever]]>>=
/* mark all current domain names as never to be aged */
void
dnageallnever(void)
{
    int i;
    DN *dp;

    lock(&dnlock);

    /* mark all referenced domain names */
    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next)
            dnagenever(dp, 0);

    unlock(&dnlock);

    dnslog("%ld initial domain names; target is %ld", dnvars.names, target);
    if(dnvars.names >= target)
        dnslog("more initial domain names (%ld) than target (%ld)",
            dnvars.names, target);
}
@

<<macro [[REF]]>>=
#define REF(dp)	{ if (dp) (dp)->refs++; }
@

<<function [[dnageall]]>>=
/*
 *  periodicly sweep for old records and remove unreferenced domain names
 *
 *  only called when all other threads are locked out
 */
void
dnageall(int doit)
{
    DN *dp, **l;
    int i;
    RR *rp;
    static ulong nextage;

    if(dnvars.names < target || (now < nextage && !doit)){
        dnvars.oldest = maxage;
        return;
    }

    if(dnvars.names >= target) {
        dnslog("more names (%lud) than target (%lud)", dnvars.names,
            target);
        dnvars.oldest /= 2;
        if (dnvars.oldest < Minage)
            dnvars.oldest = Minage;		/* don't be silly */
    }
    if (agefreq > dnvars.oldest / 2)
        nextage = now + dnvars.oldest / 2;
    else
        nextage = now + agefreq;

    lock(&dnlock);

    /* time out all old entries (and set refs to 0) */
    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next){
            dp->refs = 0;
            dnage(dp);
        }

    /* mark all referenced domain names */
    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next)
            for(rp = dp->rr; rp; rp = rp->next){
                REF(rp->owner);
                if(rp->negative){
                    REF(rp->negsoaowner);
                    continue;
                }
                switch(rp->type){
                case Thinfo:
                    REF(rp->cpu);
                    REF(rp->os);
                    break;
                case Ttxt:
                    break;
                case Tcname:
                case Tmb:
                case Tmd:
                case Tmf:
                case Tns:
                case Tmx:
                case Tsrv:
                    REF(rp->host);
                    break;
                case Tmg:
                case Tmr:
                    REF(rp->mb);
                    break;
                case Tminfo:
                    REF(rp->rmb);
                    REF(rp->mb);
                    break;
                case Trp:
                    REF(rp->rmb);
                    REF(rp->rp);
                    break;
                case Ta:
                case Taaaa:
                    REF(rp->ip);
                    break;
                case Tptr:
                    REF(rp->ptr);
                    break;
                case Tsoa:
                    REF(rp->host);
                    REF(rp->rmb);
                    break;
                }
            }

    /* sweep and remove unreferenced domain names */
    for(i = 0; i < HTLEN; i++){
        l = &ht[i];
        for(dp = *l; dp; dp = *l){
            if(dp->rr == 0 && dp->refs == 0 && !dp->keep){
                assert(dp->magic == DNmagic);
                *l = dp->next;

                if(dp->name)
                    free(dp->name);
                dp->magic = ~dp->magic;
                dnvars.names--;
                memset(dp, 0, sizeof *dp); /* cause trouble */
                free(dp);

                continue;
            }
            l = &dp->next;
        }
    }

    unlock(&dnlock);
}
@

<<function [[dnagedb]]>>=
/*
 *  timeout all database records (used when rereading db)
 */
void
dnagedb(void)
{
    DN *dp;
    int i;
    RR *rp;

    lock(&dnlock);

    /* time out all database entries */
    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next) {
            dp->keep = 0;
            for(rp = dp->rr; rp; rp = rp->next)
                if(rp->db)
                    rp->expire = 0;
        }

    unlock(&dnlock);
}
@

<<function [[dnauthdb]]>>=
/*
 *  mark all local db records about my area as authoritative,
 *  time out any others
 */
void
dnauthdb(void)
{
    int i;
    ulong minttl;
    Area *area;
    DN *dp;
    RR *rp;

    lock(&dnlock);

    /* time out all database entries */
    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next){
            area = inmyarea(dp->name);
            for(rp = dp->rr; rp; rp = rp->next)
                if(rp->db){
                    if(area){
                        minttl = area->soarr->soa->minttl;
                        if(rp->ttl < minttl)
                            rp->ttl = minttl;
                        rp->auth = 1;
                    }
                    if(rp->expire == 0){
                        rp->db = 0;
                        dp->referenced = now-Reserved-1;
                    }
                }
        }

    unlock(&dnlock);
}
@

<<function [[getactivity]]>>=
/*
 *  keep track of other processes to know if we can
 *  garbage collect.  block while garbage collecting.
 */
int
getactivity(Request *req, int recursive)
{
    int rv;

    if(traceactivity)
        dnslog("get: %d active by pid %d from %p",
            dnvars.active, getpid(), getcallerpc(&req));
    lock(&dnvars);
    /*
     * can't block here if we're already holding one
     * of the dnvars.active (recursive).  will deadlock.
     */
    while(!recursive && dnvars.mutex){
        unlock(&dnvars);
        sleep(100);			/* tune; was 200 */
        lock(&dnvars);
    }
    rv = ++dnvars.active;
    now = time(nil);
    nowns = nsec();
    req->id = ++dnvars.id;
    unlock(&dnvars);

    return rv;
}
@

<<function [[putactivity]]>>=
void
putactivity(int recursive)
{
    static ulong lastclean;

    if(traceactivity)
        dnslog("put: %d active by pid %d",
            dnvars.active, getpid());
    lock(&dnvars);
    dnvars.active--;
    assert(dnvars.active >= 0); /* "dnvars.active %d", dnvars.active */

    /*
     *  clean out old entries and check for new db periodicly
     *  can't block here if being called to let go a "recursive" lock
     *  or we'll deadlock waiting for ourselves to give up the dnvars.active.
     */
    if (recursive || dnvars.mutex ||
        (needrefresh == 0 && dnvars.active > 0)){
        unlock(&dnvars);
        return;
    }

    /* wait till we're alone */
    dnvars.mutex = 1;
    while(dnvars.active > 0){
        unlock(&dnvars);
        sleep(100);		/* tune; was 100 */
        lock(&dnvars);
    }
    unlock(&dnvars);

    db2cache(needrefresh);

    /* if we've been running for long enough, restart */
    if(start == 0)
        start = time(nil);
    if(Restartmins > 0 && time(nil) - start > Restartmins*60){
        dnslog("killing all dns procs for timed restart");
        postnote(PNGROUP, getpid(), "die");
        dnvars.mutex = 0;
        exits("restart");
    }

    dnageall(0);

    /* let others back in */
    lastclean = now;
    needrefresh = 0;
    dnvars.mutex = 0;
}
@

<<function [[rrlistlen]]>>=
int
rrlistlen(RR *rp)
{
    int n;

    n = 0;
    for(; rp; rp = rp->next)
        ++n;
    return n;
}
@

<<function [[rrattach1]]>>=
/*
 *  Attach a single resource record to a domain name (new->owner).
 *	- Avoid duplicates with already present RR's
 *	- Chain all RR's of the same type adjacent to one another
 *	- chain authoritative RR's ahead of non-authoritative ones
 *	- remove any expired RR's
 *  If new is a stale duplicate, rrfree it.
 *  Must be called with dnlock held.
 */
static void
rrattach1(RR *new, int auth)
{
    RR **l;
    RR *rp;
    DN *dp;

    assert(new->magic == RRmagic && !new->cached);

//	dnslog("rrattach1: %s", new->owner->name);
    if(!new->db) {
        /*
         * try not to let responses expire before we
         * can use them to complete this query, by extending
         * past (or nearly past) expiration time.
         */
        new->expire = new->ttl > now + Min? new->ttl: now + 10*Min;
    } else
        new->expire = now + Year;
    dp = new->owner;
    assert(dp->magic == DNmagic);
    new->auth |= auth;
    new->next = 0;

    /*
     *  find first rr of the right type
     */
    l = &dp->rr;
    for(rp = *l; rp; rp = *l){
        assert(rp->magic == RRmagic && rp->cached);
        if(rp->type == new->type)
            break;
        l = &rp->next;
    }

    /*
     *  negative entries replace positive entries
     *  positive entries replace negative entries
     *  newer entries replace older entries with the same fields
     *
     *  look farther ahead than just the next entry when looking
     *  for duplicates; RRs of a given type can have different rdata
     *  fields (e.g. multiple NS servers).
     */
    while ((rp = *l) != nil){
        assert(rp->magic == RRmagic && rp->cached);
        if(rp->type != new->type)
            break;

        if(rp->db == new->db && rp->auth == new->auth){
            /* negative drives out positive and vice versa */
            if(rp->negative != new->negative) {
                /* rp == *l before; *l == rp->next after */
                rrdelhead(l);
                continue;	
            }
            /* all things equal, pick the newer one */
            else if(rp->arg0 == new->arg0 && rp->arg1 == new->arg1){
                /* new drives out old */
                if (new->ttl <= rp->ttl &&
                    new->expire <= rp->expire) {
                    rrfree(new);
                    return;
                }
                /* rp == *l before; *l == rp->next after */
                rrdelhead(l);
                continue;
            }
            /*
             *  Hack for pointer records.  This makes sure
             *  the ordering in the list reflects the ordering
             *  received or read from the database
             */
            else if(rp->type == Tptr &&
                !rp->negative && !new->negative &&
                rp->ptr->ordinal > new->ptr->ordinal)
                break;
        }
        l = &rp->next;
    }

    if (rronlist(new, rp)) {
        /* should not happen; duplicates were processed above */
        dnslog("adding duplicate %R to list of %R; aborting", new, rp);
        abort();
    }
    /*
     *  add to chain
     */
    new->cached = 1;
    new->next = rp;
    *l = new;
}
@

<<function [[rrattach]]>>=
/*
 *  Attach a list of resource records to a domain name.
 *  May rrfree any stale duplicate RRs; dismembers the list.
 *  Upon return, every RR in the list will have been rrfree-d
 *  or attached to its domain name.
 *  See rrattach1 for properties preserved.
 */
void
rrattach(RR *rp, int auth)
{
    RR *next, *tp;
    DN *dp;

    lock(&dnlock);
    for(; rp; rp = next){
        next = rp->next;
        rp->next = nil;
        dp = rp->owner;

//		dnslog("rrattach: %s", rp->owner->name);
        /* avoid any outside spoofing; leave keepers alone */
        if(cfg.cachedb && !rp->db && inmyarea(rp->owner->name)
//		    || dp->keep			/* TODO: make this work */
            )
            rrfree(rp);
        else {
            /* ameliorate the memory leak (someday delete this) */
            if (0 && rrlistlen(dp->rr) > 50 && !dp->keep) {
                dnslog("rrattach(%s): rr list too long; "
                    "freeing it", dp->name);
                tp = dp->rr;
                dp->rr = nil;
                rrfreelist(tp);
            } else
                USED(dp);
            rrattach1(rp, auth);
        }
    }
    unlock(&dnlock);
}
@

<<function [[rrcopy]]>>=
/* should be called with dnlock held */
RR**
rrcopy(RR *rp, RR **last)
{
    Cert *cert;
    Key *key;
    Null *null;
    RR *nrp;
    SOA *soa;
    Sig *sig;
    Txt *t, *nt, **l;

    if (canlock(&dnlock))
        abort();	/* rrcopy called with dnlock not held */
    nrp = rralloc(rp->type);
    setmalloctag(nrp, getcallerpc(&rp));
    switch(rp->type){
    case Ttxt:
        *nrp = *rp;
        l = &nrp->txt;
        *l = nil;
        for(t = rp->txt; t != nil; t = t->next){
            nt = emalloc(sizeof(*nt));
            nt->p = estrdup(t->p);
            nt->next = nil;
            *l = nt;
            l = &nt->next;
        }
        break;
    case Tsoa:
        soa = nrp->soa;
        *nrp = *rp;
        nrp->soa = soa;
        *nrp->soa = *rp->soa;
        nrp->soa->slaves = copyserverlist(rp->soa->slaves);
        break;
    case Tsrv:
        *nrp = *rp;
        nrp->srv = emalloc(sizeof *nrp->srv);
        *nrp->srv = *rp->srv;
        break;
    case Tkey:
        key = nrp->key;
        *nrp = *rp;
        nrp->key = key;
        *key = *rp->key;
        key->data = emalloc(key->dlen);
        memmove(key->data, rp->key->data, rp->key->dlen);
        break;
    case Tsig:
        sig = nrp->sig;
        *nrp = *rp;
        nrp->sig = sig;
        *sig = *rp->sig;
        sig->data = emalloc(sig->dlen);
        memmove(sig->data, rp->sig->data, rp->sig->dlen);
        break;
    case Tcert:
        cert = nrp->cert;
        *nrp = *rp;
        nrp->cert = cert;
        *cert = *rp->cert;
        cert->data = emalloc(cert->dlen);
        memmove(cert->data, rp->cert->data, rp->cert->dlen);
        break;
    case Tnull:
        null = nrp->null;
        *nrp = *rp;
        nrp->null = null;
        *null = *rp->null;
        null->data = emalloc(null->dlen);
        memmove(null->data, rp->null->data, rp->null->dlen);
        break;
    default:
        *nrp = *rp;
        break;
    }
    nrp->cached = 0;
    nrp->next = 0;
    *last = nrp;
    return &nrp->next;
}
@

<<function [[rrlookup]]>>=
/*
 *  lookup a resource record of a particular type and
 *  class attached to a domain name.  Return copies.
 *
 *  Priority ordering is:
 *	db authoritative
 *	not timed out network authoritative
 *	not timed out network unauthoritative
 *	unauthoritative db
 *
 *  if flag NOneg is set, don't return negative cached entries.
 *  return nothing instead.
 */
RR*
rrlookup(DN *dp, int type, int flag)
{
    RR *rp, *first, **last;

    assert(dp->magic == DNmagic);

    first = 0;
    last = &first;
    lock(&dnlock);

    /* try for an authoritative db entry */
    for(rp = dp->rr; rp; rp = rp->next){
        assert(rp->magic == RRmagic && rp->cached);
        if(rp->db)
        if(rp->auth)
        if(tsame(type, rp->type)) {
            last = rrcopy(rp, last);
            // setmalloctag(*last, getcallerpc(&dp));
        }
    }
    if(first)
        goto out;

    /* try for a living authoritative network entry */
    for(rp = dp->rr; rp; rp = rp->next){
        if(!rp->db)
        if(rp->auth)
        if(rp->ttl + 60 > now)
        if(tsame(type, rp->type)){
            if(flag == NOneg && rp->negative)
                goto out;
            last = rrcopy(rp, last);
        }
    }
    if(first)
        goto out;

    /* try for a living unauthoritative network entry */
    for(rp = dp->rr; rp; rp = rp->next){
        if(!rp->db)
        if(rp->ttl + 60 > now)
        if(tsame(type, rp->type)){
            if(flag == NOneg && rp->negative)
                goto out;
            last = rrcopy(rp, last);
        }
    }
    if(first)
        goto out;

    /* try for an unauthoritative db entry */
    for(rp = dp->rr; rp; rp = rp->next){
        if(rp->db)
        if(tsame(type, rp->type))
            last = rrcopy(rp, last);
    }
    if(first)
        goto out;

    /* otherwise, settle for anything we got (except for negative caches) */
    for(rp = dp->rr; rp; rp = rp->next)
        if(tsame(type, rp->type)){
            if(rp->negative)
                goto out;
            last = rrcopy(rp, last);
        }

out:
    unique(first);
    unlock(&dnlock);
//	dnslog("rrlookup(%s) -> %#p\t# in-core only", dp->name, first);
//	if (first)
//		setmalloctag(first, getcallerpc(&dp));
    return first;
}
@

<<function [[rrtype]]>>=
/*
 *  convert an ascii RR type name to its integer representation
 */
int
rrtype(char *atype)
{
    int i;

    for(i = 0; i <= Tall; i++)
        if(rrtname[i] && strcmp(rrtname[i], atype) == 0)
            return i;

    /* make any a synonym for all */
    if(strcmp(atype, "any") == 0)
        return Tall;
    else if(isascii(atype[0]) && isdigit(atype[0]))
        return atoi(atype);
    else
        return -1;
}
@

<<function [[rrsupported]]>>=
/*
 *  return 0 if not a supported rr type
 */
int
rrsupported(int type)
{
    if(type < 0 || type >Tall)
        return 0;
    return rrtname[type] != nil;
}
@

<<function [[tsame]]>>=
/*
 *  compare 2 types
 */
int
tsame(int t1, int t2)
{
    return t1 == t2 || t1 == Tall;
}
@

<<function [[rrcat]]>>=
/*
 *  Add resource records to a list, duplicate them if they are cached
 *  RR's since these are shared.  should be called with dnlock held
 *  to avoid racing down the start chain.
 */
RR*
rrcat(RR **start, RR *rp)
{
    RR *olp, *nlp;
    RR **last;

    if (canlock(&dnlock))
        abort();	/* rrcat called with dnlock not held */
    /* check for duplicates */
    for (olp = *start; 0 && olp; olp = olp->next)
        for (nlp = rp; nlp; nlp = nlp->next)
            if (rrsame(nlp, olp))
                dnslog("rrcat: duplicate RR: %R", nlp);
    USED(olp);

    last = start;
    while(*last != nil)
        last = &(*last)->next;

    *last = rp;
    return *start;
}
@

<<function [[rrremneg]]>>=
/*
 *  remove negative cache rr's from an rr list
 */
RR*
rrremneg(RR **l)
{
    RR **nl, *rp;
    RR *first;

    if (canlock(&dnlock))
        abort();	/* rrremneg called with dnlock not held */
    first = nil;
    nl = &first;
    while(*l != nil){
        rp = *l;
        if(rp->negative){
            *l = rp->next;
            *nl = rp;
            nl = &rp->next;
            *nl = nil;
        } else
            l = &rp->next;
    }

    return first;
}
@

<<function [[rrremtype]]>>=
/*
 *  remove rr's of a particular type from an rr list
 */
RR*
rrremtype(RR **l, int type)
{
    RR *first, *rp;
    RR **nl;

    first = nil;
    nl = &first;
    while(*l != nil){
        rp = *l;
        if(rp->type == type){
            *l = rp->next;
            *nl = rp;
            nl = &rp->next;
            *nl = nil;
        } else
            l = &(*l)->next;
    }

    return first;
}
@

<<function [[dnname]]>>=
static char *
dnname(DN *dn)
{
    return dn? dn->name: "<null>";
}
@

<<function [[rrfmt]]>>=
/*
 *  print conversion for rr records
 */
int
rrfmt(Fmt *f)
{
    int rv;
    char *strp;
    char buf[Domlen];
    Fmt fstr;
    RR *rp;
    Server *s;
    SOA *soa;
    Srv *srv;
    Txt *t;

    fmtstrinit(&fstr);

    rp = va_arg(f->args, RR*);
    if(rp == nil){
        fmtprint(&fstr, "<null>");
        goto out;
    }

    fmtprint(&fstr, "%s %s", dnname(rp->owner),
        rrname(rp->type, buf, sizeof buf));

    if(rp->negative){
        fmtprint(&fstr, "\tnegative - rcode %d", rp->negrcode);
        goto out;
    }

    switch(rp->type){
    case Thinfo:
        fmtprint(&fstr, "\t%s %s", dnname(rp->cpu), dnname(rp->os));
        break;
    case Tcname:
    case Tmb:
    case Tmd:
    case Tmf:
    case Tns:
        fmtprint(&fstr, "\t%s", dnname(rp->host));
        break;
    case Tmg:
    case Tmr:
        fmtprint(&fstr, "\t%s", dnname(rp->mb));
        break;
    case Tminfo:
        fmtprint(&fstr, "\t%s %s", dnname(rp->mb), dnname(rp->rmb));
        break;
    case Tmx:
        fmtprint(&fstr, "\t%lud %s", rp->pref, dnname(rp->host));
        break;
    case Ta:
    case Taaaa:
        fmtprint(&fstr, "\t%s", dnname(rp->ip));
        break;
    case Tptr:
//		fmtprint(&fstr, "\t%s(%lud)", dnname(rp->ptr),
//			rp->ptr? rp->ptr->ordinal: "<null>");
        fmtprint(&fstr, "\t%s", dnname(rp->ptr));
        break;
    case Tsoa:
        soa = rp->soa;
        fmtprint(&fstr, "\t%s %s %lud %lud %lud %lud %lud",
            dnname(rp->host), dnname(rp->rmb),
            (soa? soa->serial: 0),
            (soa? soa->refresh: 0), (soa? soa->retry: 0),
            (soa? soa->expire: 0), (soa? soa->minttl: 0));
        if (soa)
            for(s = soa->slaves; s != nil; s = s->next)
                fmtprint(&fstr, " %s", s->name);
        break;
    case Tsrv:
        srv = rp->srv;
        fmtprint(&fstr, "\t%ud %ud %ud %s",
            (srv? srv->pri: 0), (srv? srv->weight: 0),
            rp->port, dnname(rp->host));
        break;
    case Tnull:
        if (rp->null == nil)
            fmtprint(&fstr, "\t<null>");
        else
            fmtprint(&fstr, "\t%.*H", rp->null->dlen,
                rp->null->data);
        break;
    case Ttxt:
        fmtprint(&fstr, "\t");
        for(t = rp->txt; t != nil; t = t->next)
            fmtprint(&fstr, "%s", t->p);
        break;
    case Trp:
        fmtprint(&fstr, "\t%s %s", dnname(rp->rmb), dnname(rp->rp));
        break;
    case Tkey:
        if (rp->key == nil)
            fmtprint(&fstr, "\t<null> <null> <null>");
        else
            fmtprint(&fstr, "\t%d %d %d", rp->key->flags,
                rp->key->proto, rp->key->alg);
        break;
    case Tsig:
        if (rp->sig == nil)
            fmtprint(&fstr,
           "\t<null> <null> <null> <null> <null> <null> <null> <null>");
        else
            fmtprint(&fstr, "\t%d %d %d %lud %lud %lud %d %s",
                rp->sig->type, rp->sig->alg, rp->sig->labels,
                rp->sig->ttl, rp->sig->exp, rp->sig->incep,
                rp->sig->tag, dnname(rp->sig->signer));
        break;
    case Tcert:
        if (rp->cert == nil)
            fmtprint(&fstr, "\t<null> <null> <null>");
        else
            fmtprint(&fstr, "\t%d %d %d",
                rp->cert->type, rp->cert->tag, rp->cert->alg);
        break;
    }
out:
    strp = fmtstrflush(&fstr);
    rv = fmtstrcpy(f, strp);
    free(strp);
    return rv;
}
@

<<function [[rravfmt]]>>=
/*
 *  print conversion for rr records in attribute value form
 */
int
rravfmt(Fmt *f)
{
    int rv, quote;
    char *strp;
    Fmt fstr;
    RR *rp;
    Server *s;
    SOA *soa;
    Srv *srv;
    Txt *t;

    fmtstrinit(&fstr);

    rp = va_arg(f->args, RR*);
    if(rp == nil){
        fmtprint(&fstr, "<null>");
        goto out;
    }

    if(rp->type == Tptr)
        fmtprint(&fstr, "ptr=%s", dnname(rp->owner));
    else
        fmtprint(&fstr, "dom=%s", dnname(rp->owner));

    switch(rp->type){
    case Thinfo:
        fmtprint(&fstr, " cpu=%s os=%s",
            dnname(rp->cpu), dnname(rp->os));
        break;
    case Tcname:
        fmtprint(&fstr, " cname=%s", dnname(rp->host));
        break;
    case Tmb:
    case Tmd:
    case Tmf:
        fmtprint(&fstr, " mbox=%s", dnname(rp->host));
        break;
    case Tns:
        fmtprint(&fstr,  " ns=%s", dnname(rp->host));
        break;
    case Tmg:
    case Tmr:
        fmtprint(&fstr, " mbox=%s", dnname(rp->mb));
        break;
    case Tminfo:
        fmtprint(&fstr, " mbox=%s mbox=%s",
            dnname(rp->mb), dnname(rp->rmb));
        break;
    case Tmx:
        fmtprint(&fstr, " pref=%lud mx=%s", rp->pref, dnname(rp->host));
        break;
    case Ta:
    case Taaaa:
        fmtprint(&fstr, " ip=%s", dnname(rp->ip));
        break;
    case Tptr:
        fmtprint(&fstr, " dom=%s", dnname(rp->ptr));
        break;
    case Tsoa:
        soa = rp->soa;
        fmtprint(&fstr,
" ns=%s mbox=%s serial=%lud refresh=%lud retry=%lud expire=%lud ttl=%lud",
            dnname(rp->host), dnname(rp->rmb),
            (soa? soa->serial: 0),
            (soa? soa->refresh: 0), (soa? soa->retry: 0),
            (soa? soa->expire: 0), (soa? soa->minttl: 0));
        for(s = soa->slaves; s != nil; s = s->next)
            fmtprint(&fstr, " dnsslave=%s", s->name);
        break;
    case Tsrv:
        srv = rp->srv;
        fmtprint(&fstr, " pri=%ud weight=%ud port=%ud target=%s",
            (srv? srv->pri: 0), (srv? srv->weight: 0),
            rp->port, dnname(rp->host));
        break;
    case Tnull:
        if (rp->null == nil)
            fmtprint(&fstr, " null=<null>");
        else
            fmtprint(&fstr, " null=%.*H", rp->null->dlen,
                rp->null->data);
        break;
    case Ttxt:
        fmtprint(&fstr, " txt=");
        quote = 0;
        for(t = rp->txt; t != nil; t = t->next)
            if(strchr(t->p, ' '))
                quote = 1;
        if(quote)
            fmtprint(&fstr, "\"");
        for(t = rp->txt; t != nil; t = t->next)
            fmtprint(&fstr, "%s", t->p);
        if(quote)
            fmtprint(&fstr, "\"");
        break;
    case Trp:
        fmtprint(&fstr, " rp=%s txt=%s",
            dnname(rp->rmb), dnname(rp->rp));
        break;
    case Tkey:
        if (rp->key == nil)
            fmtprint(&fstr, " flags=<null> proto=<null> alg=<null>");
        else
            fmtprint(&fstr, " flags=%d proto=%d alg=%d",
                rp->key->flags, rp->key->proto, rp->key->alg);
        break;
    case Tsig:
        if (rp->sig == nil)
            fmtprint(&fstr,
" type=<null> alg=<null> labels=<null> ttl=<null> exp=<null> incep=<null> tag=<null> signer=<null>");
        else
            fmtprint(&fstr,
" type=%d alg=%d labels=%d ttl=%lud exp=%lud incep=%lud tag=%d signer=%s",
                rp->sig->type, rp->sig->alg, rp->sig->labels,
                rp->sig->ttl, rp->sig->exp, rp->sig->incep,
                rp->sig->tag, dnname(rp->sig->signer));
        break;
    case Tcert:
        if (rp->cert == nil)
            fmtprint(&fstr, " type=<null> tag=<null> alg=<null>");
        else
            fmtprint(&fstr, " type=%d tag=%d alg=%d",
                rp->cert->type, rp->cert->tag, rp->cert->alg);
        break;
    }
out:
    strp = fmtstrflush(&fstr);
    rv = fmtstrcpy(f, strp);
    free(strp);
    return rv;
}
@

<<function [[warning]]([[(networking/ndb/dn.c)]])>>=
void
warning(char *fmt, ...)
{
    char dnserr[256];
    va_list arg;

    va_start(arg, fmt);
    vseprint(dnserr, dnserr+sizeof(dnserr), fmt, arg);
    va_end(arg);
    syslog(1, logfile, dnserr);		/* on console too */
}
@

<<function [[dnslog]]([[(networking/ndb/dn.c)]])>>=
void
dnslog(char *fmt, ...)
{
    char dnserr[256];
    va_list arg;

    va_start(arg, fmt);
    vseprint(dnserr, dnserr+sizeof(dnserr), fmt, arg);
    va_end(arg);
    syslog(0, logfile, dnserr);
}
@

<<function [[procsetname]]([[(networking/ndb/dn.c)]])>>=
/*
 * based on libthread's threadsetname, but drags in less library code.
 * actually just sets the arguments displayed.
 */
void
procsetname(char *fmt, ...)
{
    int fd;
    char *cmdname;
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if (cmdname == nil)
        return;
    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OWRITE)) >= 0){
        write(fd, cmdname, strlen(cmdname)+1);
        close(fd);
    }
    free(cmdname);
}
@

<<function [[slave]]([[(networking/ndb/dn.c)]])>>=
/*
 *  create a slave process to handle a request to avoid one request blocking
 *  another
 */
void
slave(Request *req)
{
    int ppid, procs;

    if(req->isslave)
        return;		/* we're already a slave process */

    /*
     * These calls to putactivity cannot block.
     * After getactivity(), the current process is counted
     * twice in dnvars.active (one will pass to the child).
     * If putactivity tries to wait for dnvars.active == 0,
     * it will never happen.
     */

    /* limit parallelism */
    procs = getactivity(req, 1);
    if (procs > stats.slavehiwat)
        stats.slavehiwat = procs;
    if(procs > Maxactive){
        if(traceactivity)
            dnslog("[%d] too much activity", getpid());
        putactivity(1);
        return;
    }

    /*
     * parent returns to main loop, child does the work.
     * don't change note group.
     */
    ppid = getpid();
    switch(rfork(RFPROC|RFMEM|RFNOWAIT)){
    case -1:
        putactivity(1);
        break;
    case 0:
        procsetname("request slave of pid %d", ppid);
   if(traceactivity)
            dnslog("[%d] take activity from %d", getpid(), ppid);
        req->isslave = 1;	/* why not `= getpid()'? */
        break;
    default:
        /*
         * this relies on rfork producing separate, initially-identical
         * stacks, thus giving us two copies of `req', one in each
         * process.
         */
        alarm(0);
        longjmp(req->mret, 1);
    }
}
@

<<function [[dncheck]]>>=
/*
 *  chasing down double free's
 */
void
dncheck(void *p, int dolock)
{
    int i;
    DN *dp;
    RR *rp;

    if(p != nil){
        dp = p;
        assert(dp->magic == DNmagic);
    }

    if(!testing)
        return;

    if(dolock)
        lock(&dnlock);
    poolcheck(mainmem);
    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next){
            assert(dp != p);
            assert(dp->magic == DNmagic);
            for(rp = dp->rr; rp; rp = rp->next){
                assert(rp->magic == RRmagic);
                assert(rp->cached);
                assert(rp->owner == dp);
                /* also check for duplicate rrs */
                if (dolock && rronlist(rp, rp->next)) {
                    dnslog("%R duplicates its next chain "
                        "(%R); aborting", rp, rp->next);
                    abort();
                }
            }
        }
    if(dolock)
        unlock(&dnlock);
}
@

<<function [[rrequiv]]>>=
static int
rrequiv(RR *r1, RR *r2)
{
    return r1->owner == r2->owner
        && r1->type == r2->type
        && r1->arg0 == r2->arg0
        && r1->arg1 == r2->arg1;
}
@

<<function [[unique]]>>=
/* called with dnlock held */
void
unique(RR *rp)
{
    RR **l, *nrp;

    for(; rp; rp = rp->next){
        l = &rp->next;
        for(nrp = *l; nrp; nrp = *l)
            if(rrequiv(rp, nrp)){
                *l = nrp->next;
                rrfree(nrp);
            } else
                l = &nrp->next;
    }
}
@

<<function [[subsume]]>>=
/*
 *  true if second domain is subsumed by the first
 */
int
subsume(char *higher, char *lower)
{
    int hn, ln;

    ln = strlen(lower);
    hn = strlen(higher);
    if (ln < hn || cistrcmp(lower + ln - hn, higher) != 0 ||
        ln > hn && hn != 0 && lower[ln - hn - 1] != '.')
        return 0;
    return 1;
}
@

<<function [[randomize]]>>=
/*
 *  randomize the order we return items to provide some
 *  load balancing for servers.
 *
 *  only randomize the first class of entries
 */
RR*
randomize(RR *rp)
{
    RR *first, *last, *x, *base;
    ulong n;

    if(rp == nil || rp->next == nil)
        return rp;

    /* just randomize addresses, mx's and ns's */
    for(x = rp; x; x = x->next)
        if(x->type != Ta && x->type != Taaaa &&
            x->type != Tmx && x->type != Tns)
            return rp;

    base = rp;

    n = rand();
    last = first = nil;
    while(rp != nil){
        /* stop randomizing if we've moved past our class */
        if(base->auth != rp->auth || base->db != rp->db){
            last->next = rp;
            break;
        }

        /* unchain */
        x = rp;
        rp = x->next;
        x->next = nil;

        if(n&1){
            /* add to tail */
            if(last == nil)
                first = x;
            else
                last->next = x;
            last = x;
        } else {
            /* add to head */
            if(last == nil)
                last = x;
            x->next = first;
            first = x;
        }

        /* reroll the dice */
        n >>= 1;
    }

    return first;
}
@

<<function [[sencodefmt]]>>=
static int
sencodefmt(Fmt *f)
{
    int i, len, ilen, rv;
    char *out, *buf;
    uchar *b;
    char obuf[64];		/* rsc optimization */

    if(!(f->flags&FmtPrec) || f->prec < 1)
        goto error;

    b = va_arg(f->args, uchar*);
    if(b == nil)
        goto error;

    /* if it's a printable, go for it */
    len = f->prec;
    for(i = 0; i < len; i++)
        if(!isprint(b[i]))
            break;
    if(i == len){
        if(len >= sizeof obuf)
            len = sizeof(obuf)-1;
        memmove(obuf, b, len);
        obuf[len] = 0;
        fmtstrcpy(f, obuf);
        return 0;
    }

    ilen = f->prec;
    f->prec = 0;
    f->flags &= ~FmtPrec;
    switch(f->r){
    case '<':
        len = (8*ilen+4)/5 + 3;
        break;
    case '[':
        len = (8*ilen+5)/6 + 4;
        break;
    case 'H':
        len = 2*ilen + 1;
        break;
    default:
        goto error;
    }

    if(len > sizeof(obuf)){
        buf = malloc(len);
        if(buf == nil)
            goto error;
    } else
        buf = obuf;

    /* convert */
    out = buf;
    switch(f->r){
    case '<':
        rv = enc32(out, len, b, ilen);
        break;
    case '[':
        rv = enc64(out, len, b, ilen);
        break;
    case 'H':
        rv = enc16(out, len, b, ilen);
        break;
    default:
        rv = -1;
        break;
    }
    if(rv < 0)
        goto error;

    fmtstrcpy(f, buf);
    if(buf != obuf)
        free(buf);
    return 0;

error:
    return fmtstrcpy(f, "<encodefmt>");
}
@

<<function [[emalloc]]([[(networking/ndb/dn.c)]])>>=
void*
emalloc(int size)
{
    char *x;

    x = mallocz(size, 1);
    if(x == nil)
        abort();
    setmalloctag(x, getcallerpc(&size));
    return x;
}
@

<<function [[estrdup]]([[(networking/ndb/dn.c)]])>>=
char*
estrdup(char *s)
{
    int size;
    char *p;

    size = strlen(s)+1;
    p = mallocz(size, 0);
    if(p == nil)
        abort();
    memmove(p, s, size);
    setmalloctag(p, getcallerpc(&s));
    return p;
}
@

<<function [[mkptr]]>>=
/*
 *  create a pointer record
 */
static RR*
mkptr(DN *dp, char *ptr, ulong ttl)
{
    DN *ipdp;
    RR *rp;

    ipdp = dnlookup(ptr, Cin, 1);

    rp = rralloc(Tptr);
    rp->ptr = dp;
    rp->owner = ipdp;
    rp->db = 1;
    if(ttl)
        rp->ttl = ttl;
    return rp;
}
@

<<function [[dnptr]]>>=
/*
 *  look for all ip addresses in this network and make
 *  pointer records for them.
 */
void
dnptr(uchar *net, uchar *mask, char *dom, int forwtype, int subdoms, int ttl)
{
    int i, j, len;
    char *p, *e;
    char ptr[Domlen];
    uchar *ipp;
    uchar ip[IPaddrlen], nnet[IPaddrlen];
    uchar nibip[IPaddrlen*2];
    DN *dp;
    RR *rp, *nrp, *first, **l;

    l = &first;
    first = nil;
    for(i = 0; i < HTLEN; i++)
        for(dp = ht[i]; dp; dp = dp->next)
            for(rp = dp->rr; rp; rp = rp->next){
                if(rp->type != forwtype || rp->negative)
                    continue;
                parseip(ip, rp->ip->name);
                maskip(ip, mask, nnet);
                if(ipcmp(net, nnet) != 0)
                    continue;

                ipp = ip;
                len = IPaddrlen;
                if (forwtype == Taaaa) {
                    bytes2nibbles(nibip, ip, IPaddrlen);
                    ipp = nibip;
                    len = 2*IPaddrlen;
                }

                p = ptr;
                e = ptr+sizeof(ptr);
                for(j = len - 1; j >= len - subdoms; j--)
                    p = seprint(p, e, (forwtype == Ta?
                        "%d.": "%x."), ipp[j]);
                seprint(p, e, "%s", dom);

                nrp = mkptr(dp, ptr, ttl);
                *l = nrp;
                l = &nrp->next;
            }

    for(rp = first; rp != nil; rp = nrp){
        nrp = rp->next;
        rp->next = nil;
        rrattach(rp, Authoritative);
    }
}
@

<<function [[addserver]]>>=
void
addserver(Server **l, char *name)
{
    Server *s;

    while(*l)
        l = &(*l)->next;
    s = malloc(sizeof(Server)+strlen(name)+1);
    if(s == nil)
        return;
    s->name = (char*)(s+1);
    strcpy(s->name, name);
    s->next = nil;
    *l = s;
}
@

<<function [[copyserverlist]]>>=
Server*
copyserverlist(Server *s)
{
    Server *ns;

    for(ns = nil; s != nil; s = s->next)
        addserver(&ns, s->name);
    return ns;
}
@

<<function [[rrname]]([[(networking/ndb/dn.c)]])>>=
/*
 *  convert an integer RR type to it's ascii name
 */
char*
rrname(int type, char *buf, int len)
{
    char *t;

    t = nil;
    if(type >= 0 && type <= Tall)
        t = rrtname[type];
    if(t==nil){
        snprint(buf, len, "%d", type);
        t = buf;
    }
    return t;
}
@

<<function [[rrfreelist]]([[(networking/ndb/dn.c)]])>>=
/*
 *  free a list of resource records and any related structs
 */
void
rrfreelist(RR *rp)
{
    RR *next;

    for(; rp; rp = next){
        next = rp->next;
        rrfree(rp);
    }
}
@

<<function [[freeserverlist]]([[(networking/ndb/dn.c)]])>>=
void
freeserverlist(Server *s)
{
    Server *next;

    for(; s != nil; s = next){
        next = s->next;
        free(s);
    }
}
@

<<function [[rralloc]]([[(networking/ndb/dn.c)]])>>=
/*
 *  allocate a resource record of a given type
 */
RR*
rralloc(int type)
{
    RR *rp;

    rp = emalloc(sizeof(*rp));
    rp->magic = RRmagic;
    rp->pc = getcallerpc(&type);
    rp->type = type;
    if (rp->type != type)
        dnslog("rralloc: bogus type %d", type);
    setmalloctag(rp, rp->pc);
    switch(type){
    case Tsoa:
        rp->soa = emalloc(sizeof(*rp->soa));
        rp->soa->slaves = nil;
        setmalloctag(rp->soa, rp->pc);
        break;
    case Tsrv:
        rp->srv = emalloc(sizeof(*rp->srv));
        setmalloctag(rp->srv, rp->pc);
        break;
    case Tkey:
        rp->key = emalloc(sizeof(*rp->key));
        setmalloctag(rp->key, rp->pc);
        break;
    case Tcert:
        rp->cert = emalloc(sizeof(*rp->cert));
        setmalloctag(rp->cert, rp->pc);
        break;
    case Tsig:
        rp->sig = emalloc(sizeof(*rp->sig));
        setmalloctag(rp->sig, rp->pc);
        break;
    case Tnull:
        rp->null = emalloc(sizeof(*rp->null));
        setmalloctag(rp->null, rp->pc);
        break;
    }
    rp->ttl = 0;
    rp->expire = 0;
    rp->next = 0;
    return rp;
}
@

<<function [[rrfree]]([[(networking/ndb/dn.c)]])>>=
/*
 *  free a resource record and any related structs
 */
void
rrfree(RR *rp)
{
    DN *dp;
    RR *nrp;
    Txt *t;

    assert(rp->magic == RRmagic);
    assert(!rp->cached);

    /* our callers often hold dnlock.  it's needed to examine dp safely. */
    dp = rp->owner;
    if(dp){
        /* if someone else holds dnlock, skip the sanity check. */
        if (canlock(&dnlock)) {
            assert(dp->magic == DNmagic);
            for(nrp = dp->rr; nrp; nrp = nrp->next)
                assert(nrp != rp);   /* "rrfree of live rr" */
            unlock(&dnlock);
        }
    }

    switch(rp->type){
    case Tsoa:
        freeserverlist(rp->soa->slaves);
        memset(rp->soa, 0, sizeof *rp->soa);	/* cause trouble */
        free(rp->soa);
        break;
    case Tsrv:
        memset(rp->srv, 0, sizeof *rp->srv);	/* cause trouble */
        free(rp->srv);
        break;
    case Tkey:
        free(rp->key->data);
        memset(rp->key, 0, sizeof *rp->key);	/* cause trouble */
        free(rp->key);
        break;
    case Tcert:
        free(rp->cert->data);
        memset(rp->cert, 0, sizeof *rp->cert);	/* cause trouble */
        free(rp->cert);
        break;
    case Tsig:
        free(rp->sig->data);
        memset(rp->sig, 0, sizeof *rp->sig);	/* cause trouble */
        free(rp->sig);
        break;
    case Tnull:
        free(rp->null->data);
        memset(rp->null, 0, sizeof *rp->null);	/* cause trouble */
        free(rp->null);
        break;
    case Ttxt:
        while(rp->txt != nil){
            t = rp->txt;
            rp->txt = t->next;
            free(t->p);
            memset(t, 0, sizeof *t);	/* cause trouble */
            free(t);
        }
        break;
    }

    rp->magic = ~rp->magic;
    memset(rp, 0, sizeof *rp);		/* cause trouble */
    free(rp);
}
@


%-------------------------------------------------------------

<<networking/ndb/dn.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <pool.h>
#include <ctype.h>
#include "dns.h"

<<enum [[_anon_ (networking/ndb/dn.c)]]>>

<<global [[ht]]>>

<<global [[dnvars]]>>

<<global [[rrtname]]([[(networking/ndb/dn.c)]])>>

<<global [[rname]]>>
<<global [[nrname]]>>

<<global [[opname]]>>

<<global [[target]]>>
<<global [[start]]>>
<<global [[dnlock]]>>

<<global [[agefreq]]>>

static int rrequiv(RR *r1, RR *r2);
static int sencodefmt(Fmt*);

<<function [[ding]]([[(networking/ndb/dn.c)]])>>

<<function [[dninit]]>>

<<function [[dnhash]]>>

<<function [[dnlookup]]([[(networking/ndb/dn.c)]])>>

<<function [[rrsame]]>>

<<function [[rronlist]]>>

<<function [[dnstats]]>>

<<function [[dndump]]>>

<<function [[dnpurge]]>>

<<function [[rrdelhead]]>>

<<function [[dnage]]>>

<<macro [[MARK]]>>

<<function [[dnagenever]]>>

<<function [[dnageallnever]]>>

<<macro [[REF]]>>

<<function [[dnageall]]>>

<<function [[dnagedb]]>>

<<function [[dnauthdb]]>>

<<function [[getactivity]]>>
<<function [[putactivity]]>>

<<function [[rrlistlen]]>>

<<function [[rrattach1]]>>

<<function [[rrattach]]>>

<<function [[rrcopy]]>>

<<function [[rrlookup]]>>

<<function [[rrtype]]>>

<<function [[rrsupported]]>>

<<function [[tsame]]>>

<<function [[rrcat]]>>

<<function [[rrremneg]]>>

<<function [[rrremtype]]>>

<<function [[dnname]]>>

<<function [[rrfmt]]>>

<<function [[rravfmt]]>>

<<function [[warning]]([[(networking/ndb/dn.c)]])>>

<<function [[dnslog]]([[(networking/ndb/dn.c)]])>>

<<function [[procsetname]]([[(networking/ndb/dn.c)]])>>

<<function [[slave]]([[(networking/ndb/dn.c)]])>>

<<function [[dncheck]]>>

<<function [[rrequiv]]>>

<<function [[unique]]>>

<<function [[subsume]]>>

<<function [[randomize]]>>

<<function [[sencodefmt]]>>

<<function [[emalloc]]([[(networking/ndb/dn.c)]])>>

<<function [[estrdup]]([[(networking/ndb/dn.c)]])>>

<<function [[mkptr]]>>

void	bytes2nibbles(uchar *nibbles, uchar *bytes, int nbytes);

<<function [[dnptr]]>>

<<function [[addserver]]>>

<<function [[copyserverlist]]>>


/* from here down is copied to ip/snoopy/dns.c periodically to update it */

<<function [[rrname]]([[(networking/ndb/dn.c)]])>>

<<function [[rrfreelist]]([[(networking/ndb/dn.c)]])>>

<<function [[freeserverlist]]([[(networking/ndb/dn.c)]])>>

<<function [[rralloc]]([[(networking/ndb/dn.c)]])>>

<<function [[rrfree]]([[(networking/ndb/dn.c)]])>>
@


\subsection*{[[networking/ndb/dnarea.c]]}

<<function [[inmyarea]]>>=
/*
 *  true if a name is in our area
 */
Area*
inmyarea(char *name)
{
    int len;
    Area *s, *d;

    len = strlen(name);
    for(s = owned; s; s = s->next){
        if(s->len > len)
            continue;
        if(cistrcmp(s->soarr->owner->name, name + len - s->len) == 0)
            if(len == s->len || name[len - s->len - 1] == '.')
                break;
    }
    if(s == nil)
        return nil;

    /* name is in area `s' */
    for(d = delegated; d; d = d->next){
        if(d->len > len)
            continue;
        if(cistrcmp(d->soarr->owner->name, name + len - d->len) == 0)
            if(len == d->len || name[len - d->len - 1] == '.')
                return nil; /* name is in a delegated subarea */
    }

    return s;	/* name is in area `s' and not in a delegated subarea */
}
@

<<function [[addarea]]>>=
/*
 *  our area is the part of the domain tree that
 *  we serve
 */
void
addarea(DN *dp, RR *rp, Ndbtuple *t)
{
    Area *s;
    Area **l;

    lock(&dnlock);
    if(t->val[0])
        l = &delegated;
    else
        l = &owned;

    for (s = *l; s != nil; s = s->next)
        if (strcmp(dp->name, s->soarr->owner->name) == 0) {
            unlock(&dnlock);
            return;		/* we've already got one */
        }

    /*
     *  The area contains a copy of the soa rr that created it.
     *  The owner of the the soa rr should stick around as long
     *  as the area does.
     */
    s = emalloc(sizeof(*s));
    s->len = strlen(dp->name);
    rrcopy(rp, &s->soarr);
    s->soarr->owner = dp;
    s->soarr->db = 1;
    s->soarr->ttl = Hour;
    s->neednotify = 1;
    s->needrefresh = 0;

    if (debug)
        dnslog("new area %s %s", dp->name,
            l == &delegated? "delegated": "owned");

    s->next = *l;
    *l = s;
    unlock(&dnlock);
}
@

<<function [[freearea]]>>=
void
freearea(Area **l)
{
    Area *s;

    while(s = *l){
        *l = s->next;
        lock(&dnlock);
        rrfree(s->soarr);
        memset(s, 0, sizeof *s);	/* cause trouble */
        unlock(&dnlock);
        free(s);
    }
}
@

<<function [[refresh_areas]]>>=
/*
 * refresh all areas that need it
 *  this entails running a command 'zonerefreshprogram'.  This could
 *  copy over databases from elsewhere or just do a zone transfer.
 */
void
refresh_areas(Area *s)
{
    int pid;
    Waitmsg *w;

    for(; s != nil; s = s->next){
        if(!s->needrefresh)
            continue;

        if(zonerefreshprogram == nil){
            s->needrefresh = 0;
            continue;
        }

        pid = fork();
        if (pid == -1) {
            sleep(1000);	/* don't fork again immediately */
            continue;
        }
        if (pid == 0){
            execl(zonerefreshprogram, "zonerefresh",
                s->soarr->owner->name, nil);
            exits("exec zonerefresh failed");
        }
        while ((w = wait()) != nil && w->pid != pid)
            free(w);
        if (w && w->pid == pid)
            if(w->msg == nil || *w->msg == '\0')
                s->needrefresh = 0;
        free(w);
    }
}
@


%-------------------------------------------------------------

<<networking/ndb/dnarea.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>
#include <ip.h>
#include "dns.h"

Area *owned, *delegated;

<<function [[inmyarea]]>>

<<function [[addarea]]>>

<<function [[freearea]]>>

<<function [[refresh_areas]]>>
@


\subsection*{[[networking/ndb/dnnotify.c]]}

<<function [[dnnotify]]>>=
/* get a notification from another system of a changed zone */
void
dnnotify(DNSmsg *reqp, DNSmsg *repp, Request *)
{
    RR *tp;
    Area *a;

    /* move one question from reqp to repp */
    memset(repp, 0, sizeof(*repp));
    tp = reqp->qd;
    reqp->qd = tp->next;
    tp->next = 0;
    repp->qd = tp;
    repp->id = reqp->id;
    repp->flags = Fresp  | Onotify | Fauth;

    /* anything to do? */
    if(zonerefreshprogram == nil)
        return;

    /* make sure its the right type */
    if(repp->qd->type != Tsoa)
        return;

    dnslog("notification for %s", repp->qd->owner->name);

    /* is it something we care about? */
    a = inmyarea(repp->qd->owner->name);
    if(a == nil)
        return;

    dnslog("serial old %lud new %lud", a->soarr->soa->serial,
        repp->qd->soa->serial);

    /* do nothing if it didn't change */
    if(a->soarr->soa->serial != repp->qd->soa->serial)
        a->needrefresh = 1;
}
@

<<function [[send_notify]]>>=
/* notify a slave that an area has changed. */
static void
send_notify(char *slave, RR *soa, Request *req)
{
    int i, len, n, reqno, status, fd;
    char *err;
    uchar ibuf[Maxudp+Udphdrsize], obuf[Maxudp+Udphdrsize];
    RR *rp;
    Udphdr *up = (Udphdr*)obuf;
    DNSmsg repmsg;

    /* create the request */
    reqno = rand();
    n = mkreq(soa->owner, Cin, obuf, Fauth | Onotify, reqno);

    /* get an address */
    if(strcmp(ipattr(slave), "ip") == 0) {
        if (parseip(up->raddr, slave) == -1)
            dnslog("bad address %s to notify", slave);
    } else {
        rp = dnresolve(slave, Cin, Ta, req, nil, 0, 1, 1, &status);
        if(rp == nil)
            rp = dnresolve(slave, Cin, Taaaa, req, nil, 0, 1, 1, &status);
        if(rp == nil)
            return;
        parseip(up->raddr, rp->ip->name);
        rrfreelist(rp);		/* was rrfree */
    }

    fd = udpport(nil);
    if(fd < 0)
        return;

    /* send 3 times or until we get anything back */
    n += Udphdrsize;
    for(i = 0; i < 3; i++, freeanswers(&repmsg)){
        dnslog("sending %d byte notify to %s/%I.%d about %s", n, slave,
            up->raddr, nhgets(up->rport), soa->owner->name);
        memset(&repmsg, 0, sizeof repmsg);
        if(write(fd, obuf, n) != n)
            break;
        alarm(2*1000);
        len = read(fd, ibuf, sizeof ibuf);
        alarm(0);
        if(len <= Udphdrsize)
            continue;
        err = convM2DNS(&ibuf[Udphdrsize], len, &repmsg, nil);
        if(err != nil) {
            free(err);
            continue;
        }
        if(repmsg.id == reqno && (repmsg.flags & Omask) == Onotify)
            break;
    }
    if (i < 3)
        freeanswers(&repmsg);
    close(fd);
}
@

<<function [[notify_areas]]>>=
/* send notifies for any updated areas */
static void
notify_areas(Area *a, Request *req)
{
    Server *s;

    for(; a != nil; a = a->next){
        if(!a->neednotify)
            continue;

        /* send notifies to all slaves */
        for(s = a->soarr->soa->slaves; s != nil; s = s->next)
            send_notify(s->name, a->soarr, req);
        a->neednotify = 0;
    }
}
@

<<function [[notifyproc]]>>=
/*
 *  process to notify other servers of changes
 *  (also reads in new databases)
 */
void
notifyproc(void)
{
    Request req;

    switch(rfork(RFPROC|RFNOTEG|RFMEM|RFNOWAIT)){
    case -1:
        return;
    case 0:
        break;
    default:
        return;
    }

    procsetname("notify slaves");
    memset(&req, 0, sizeof req);
    req.isslave = 1;	/* don't fork off subprocesses */

    for(;;){
        getactivity(&req, 0);
        notify_areas(owned, &req);
        putactivity(0);
        sleep(60*1000);
    }
}
@


%-------------------------------------------------------------

<<networking/ndb/dnnotify.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include "dns.h"

<<function [[dnnotify]]>>

<<function [[send_notify]]>>

<<function [[notify_areas]]>>

<<function [[notifyproc]]>>
@


\subsection*{[[networking/ndb/dnresolve.c]]}

<<enum [[_anon_ (networking/ndb/dnresolve.c)]]>>=
enum
{
    Udp, Tcp,

    Answerr=	-1,
    Answnone,

    Maxdest=	24,	/* maximum destinations for a request message */
    Maxoutstanding=	15,	/* max. outstanding queries per domain name */
    Remntretry=	15,	/* min. sec.s between /net.alt remount tries */

    /*
     * these are the old values; we're trying longer timeouts now
     * primarily for the benefit of remote nameservers querying us
     * during times of bad connectivity.
     */
//	Maxtrans=	3,	/* maximum transmissions to a server */
//	Maxretries=	3, /* cname+actual resends: was 32; have pity on user */
//	Maxwaitms=	1000,	/* wait no longer for a remote dns query */
//	Minwaitms=	100,	/* willing to wait for a remote dns query */

    Maxtrans=	5,	/* maximum transmissions to a server */
    Maxretries=	5, /* cname+actual resends: was 32; have pity on user */
    Maxwaitms=	5000,	/* wait no longer for a remote dns query */
    Minwaitms=	500,	/* willing to wait for a remote dns query */

    Destmagic=	0xcafebabe,
    Querymagic=	0xdeadbeef,
};
@

<<enum [[_anon_ (networking/ndb/dnresolve.c)2]]>>=
enum { Hurry, Patient, };
@

<<enum [[_anon_ (networking/ndb/dnresolve.c)3]]>>=
enum { Outns, Inns, };
@

<<struct [[Ipaddr]]>>=
struct Ipaddr {
    Ipaddr *next;
    uchar	ip[IPaddrlen];
};
@

<<struct [[Dest]]>>=
struct Dest
{
    uchar	a[IPaddrlen];	/* ip address */
    DN	*s;		/* name server */
    int	nx;		/* number of transmissions */
    int	code;		/* response code; used to clear dp->respcode */

    ulong	magic;
};
@

<<struct [[Query]]>>=
/*
 * Query has a QLock in it, thus it can't be an automatic
 * variable, since each process would see a separate copy
 * of the lock on its stack.
 */
struct Query {
    DN	*dp;		/* domain */
    ushort	type;		/* and type to look up */
    Request *req;
    RR	*nsrp;		/* name servers to consult */

    /* dest must not be on the stack due to forking in slave() */
    Dest	*dest;		/* array of destinations */
    Dest	*curdest;	/* pointer to next to fill */
    int	ndest;		/* transmit to this many on this round */

    int	udpfd;

    QLock	tcplock;	/* only one tcp call at a time per query */
    int	tcpset;
    int	tcpfd;		/* if Tcp, read replies from here */
    int	tcpctlfd;
    uchar	tcpip[IPaddrlen];

    ulong	magic;
};
@

<<global [[likely]]>>=
/* estimated % probability of such a record existing at all */
int likely[] = {
    [Ta]		95,
    [Taaaa]		10,
    [Tcname]	15,
    [Tmx]		60,
    [Tns]		90,
    [Tnull]		5,
    [Tptr]		35,
    [Tsoa]		90,
    [Tsrv]		60,
    [Ttxt]		15,
    [Tall]		95,
};
@

<<function [[procgetname]]([[(networking/ndb/dnresolve.c)]])>>=
/*
 * reading /proc/pid/args yields either "name args" or "name [display args]",
 * so return only display args, if any.
 */
static char *
procgetname(void)
{
    int fd, n;
    char *lp, *rp;
    char buf[256];

    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OREAD)) < 0)
        return strdup("");
    *buf = '\0';
    n = read(fd, buf, sizeof buf-1);
    close(fd);
    if (n >= 0)
        buf[n] = '\0';
    if ((lp = strchr(buf, '[')) == nil ||
        (rp = strrchr(buf, ']')) == nil)
        return strdup("");
    *rp = '\0';
    return strdup(lp+1);
}
@

<<function [[rrfreelistptr]]>>=
void
rrfreelistptr(RR **rpp)
{
    RR *rp;

    if (rpp == nil || *rpp == nil)
        return;
    rp = *rpp;
    *rpp = nil;	/* update pointer in memory before freeing list */
    rrfreelist(rp);
}
@

<<function [[dnresolve]]>>=
/*
 *  lookup 'type' info for domain name 'name'.  If it doesn't exist, try
 *  looking it up as a canonical name.
 *
 *  this process can be quite slow if time-outs are set too high when querying
 *  nameservers that just don't respond to certain query types.  in that case,
 *  there will be multiple udp retries, multiple nameservers will be queried,
 *  and this will be repeated for a cname query.  the whole thing will be
 *  retried several times until we get an answer or a time-out.
 */
RR*
dnresolve(char *name, int class, int type, Request *req, RR **cn, int depth,
    int recurse, int rooted, int *status)
{
    RR *rp, *nrp, *drp;
    DN *dp;
    int loops;
    char *procname;
    char nname[Domlen];

    if(status)
        *status = 0;

    if(depth > 12)			/* in a recursive loop? */
        return nil;

    procname = procgetname();
    /*
     *  hack for systems that don't have resolve search
     *  lists.  Just look up the simple name in the database.
     */
    if(!rooted && strchr(name, '.') == nil){
        rp = nil;
        drp = domainlist(class);
        for(nrp = drp; rp == nil && nrp != nil; nrp = nrp->next){
            snprint(nname, sizeof nname, "%s.%s", name,
                nrp->ptr->name);
            rp = dnresolve(nname, class, type, req, cn, depth+1,
                recurse, rooted, status);
            lock(&dnlock);
            rrfreelist(rrremneg(&rp));
            unlock(&dnlock);
        }
        if(drp != nil)
            rrfreelist(drp);
        procsetname(procname);
        free(procname);
        return rp;
    }

    /*
     *  try the name directly
     */
    rp = dnresolve1(name, class, type, req, depth, recurse);
    if(rp == nil) {
        /*
         * try it as a canonical name if we weren't told
         * that the name didn't exist
         */
        dp = dnlookup(name, class, 0);
        if(type != Tptr && dp->respcode != Rname)
            for(loops = 0; rp == nil && loops < Maxretries; loops++){
                /* retry cname, then the actual type */
                rp = dnresolve1(name, class, Tcname, req,
                    depth, recurse);
                if(rp == nil)
                    break;

                /* rp->host == nil shouldn't happen, but does */
                if(rp->negative || rp->host == nil){
                    rrfreelist(rp);
                    rp = nil;
                    break;
                }

                name = rp->host->name;
                lock(&dnlock);
                if(cn)
                    rrcat(cn, rp);
                else
                    rrfreelist(rp);
                unlock(&dnlock);

                rp = dnresolve1(name, class, type, req,
                    depth, recurse);
            }

        /* distinction between not found and not good */
        if(rp == nil && status != nil && dp->respcode != Rok)
            *status = dp->respcode;
    }
    procsetname(procname);
    free(procname);
    return randomize(rp);
}
@

<<function [[queryinit]]>>=
static void
queryinit(Query *qp, DN *dp, int type, Request *req)
{
    memset(qp, 0, sizeof *qp);
    qp->udpfd = qp->tcpfd = qp->tcpctlfd = -1;
    qp->dp = dp;
    qp->type = type;
    if (qp->type != type)
        dnslog("queryinit: bogus type %d", type);
    qp->req = req;
    qp->nsrp = nil;
    qp->dest = qp->curdest = nil;
    qp->magic = Querymagic;
}
@

<<function [[queryck]]>>=
static void
queryck(Query *qp)
{
    assert(qp);
    assert(qp->magic == Querymagic);
}
@

<<function [[querydestroy]]>>=
static void
querydestroy(Query *qp)
{
    queryck(qp);
    /* leave udpfd open */
    if (qp->tcpfd > 0)
        close(qp->tcpfd);
    if (qp->tcpctlfd > 0) {
        hangup(qp->tcpctlfd);
        close(qp->tcpctlfd);
    }
    free(qp->dest);
    memset(qp, 0, sizeof *qp);	/* prevent accidents */
    qp->udpfd = qp->tcpfd = qp->tcpctlfd = -1;
}
@

<<function [[destinit]]>>=
static void
destinit(Dest *p)
{
    memset(p, 0, sizeof *p);
    p->magic = Destmagic;
}
@

<<function [[destck]]>>=
static void
destck(Dest *p)
{
    assert(p);
    assert(p->magic == Destmagic);
}
@

<<function [[notestats]]>>=
/*
 * if the response to a query hasn't arrived within 100 ms.,
 * it's unlikely to arrive at all.  after 1 s., it's really unlikely.
 * queries for missing RRs are likely to produce time-outs rather than
 * negative responses, so cname and aaaa queries are likely to time out,
 * thus we don't wait very long for them.
 */
static void
notestats(vlong start, int tmout, int type)
{
    qlock(&stats);
    if (tmout) {
        stats.tmout++;
        if (type == Taaaa)
            stats.tmoutv6++;
        else if (type == Tcname)
            stats.tmoutcname++;
    } else {
        long wait10ths = NS2MS(nsec() - start) / 100;

        if (wait10ths <= 0)
            stats.under10ths[0]++;
        else if (wait10ths >= nelem(stats.under10ths))
            stats.under10ths[nelem(stats.under10ths) - 1]++;
        else
            stats.under10ths[wait10ths]++;
    }
    qunlock(&stats);
}
@

<<function [[noteinmem]]>>=
static void
noteinmem(void)
{
    qlock(&stats);
    stats.answinmem++;
    qunlock(&stats);
}
@

<<function [[netqueryns]]>>=
/* netquery with given name servers, free ns rrs when done */
static int
netqueryns(Query *qp, int depth, RR *nsrp)
{
    int rv;

    qp->nsrp = nsrp;
    rv = netquery(qp, depth);
    lock(&dnlock);
    rrfreelist(nsrp);
    unlock(&dnlock);
    return rv;
}
@

<<function [[issuequery]]>>=
static RR*
issuequery(Query *qp, char *name, int class, int depth, int recurse)
{
    char *cp;
    DN *nsdp;
    RR *rp, *nsrp, *dbnsrp;

    /*
     *  if we're running as just a resolver, query our
     *  designated name servers
     */
    if(cfg.resolver){
        nsrp = randomize(getdnsservers(class));
        if(nsrp != nil)
            if(netqueryns(qp, depth+1, nsrp) > Answnone)
                return rrlookup(qp->dp, qp->type, OKneg);
    }

    /*
   *  walk up the domain name looking for
     *  a name server for the domain.
     */
    for(cp = name; cp; cp = walkup(cp)){
        /*
         *  if this is a local (served by us) domain,
         *  return answer
         */
        dbnsrp = randomize(dblookup(cp, class, Tns, 0, 0));
        if(dbnsrp && dbnsrp->local){
            rp = dblookup(name, class, qp->type, 1, dbnsrp->ttl);
            lock(&dnlock);
            rrfreelist(dbnsrp);
            unlock(&dnlock);
            return rp;
        }

        /*
         *  if recursion isn't set, just accept local
         *  entries
         */
        if(recurse == Dontrecurse){
            if(dbnsrp) {
                lock(&dnlock);
                rrfreelist(dbnsrp);
                unlock(&dnlock);
            }
            continue;
        }

        /* look for ns in cache */
        nsdp = dnlookup(cp, class, 0);
        nsrp = nil;
        if(nsdp)
            nsrp = randomize(rrlookup(nsdp, Tns, NOneg));

        /* if the entry timed out, ignore it */
        if(nsrp && nsrp->ttl < now){
            lock(&dnlock);
            rrfreelistptr(&nsrp);
            unlock(&dnlock);
        }

        if(nsrp){
            lock(&dnlock);
            rrfreelistptr(&dbnsrp);
            unlock(&dnlock);

            /* query the name servers found in cache */
            if(netqueryns(qp, depth+1, nsrp) > Answnone)
                return rrlookup(qp->dp, qp->type, OKneg);
        } else if(dbnsrp)
            /* try the name servers found in db */
            if(netqueryns(qp, depth+1, dbnsrp) > Answnone)
                return rrlookup(qp->dp, qp->type, NOneg);
    }
    return nil;
}
@

<<function [[dnresolve1]]>>=
static RR*
dnresolve1(char *name, int class, int type, Request *req, int depth,
    int recurse)
{
    Area *area;
    DN *dp;
    RR *rp;
    Query *qp;

    if(debug)
        dnslog("[%d] dnresolve1 %s %d %d", getpid(), name, type, class);

    /* only class Cin implemented so far */
    if(class != Cin)
        return nil;

    dp = dnlookup(name, class, 1);

    /*
     *  Try the cache first
     */
    rp = rrlookup(dp, type, OKneg);
    if(rp)
        if(rp->db){
            /* unauthoritative db entries are hints */
            if(rp->auth) {
                noteinmem();
                if(debug)
                    dnslog("[%d] dnresolve1 %s %d %d: auth rr in db",
                        getpid(), name, type, class);
                return rp;
            }
        } else
            /* cached entry must still be valid */
            if(rp->ttl > now)
                /* but Tall entries are special */
                if(type != Tall || rp->query == Tall) {
                    noteinmem();
                    if(debug)
                        dnslog("[%d] dnresolve1 %s %d %d: rr not in db",
                            getpid(), name, type, class);
                    return rp;
                }
    lock(&dnlock);
    rrfreelist(rp);
    unlock(&dnlock);
    rp = nil;		/* accident prevention */
    USED(rp);

    /*
     * try the cache for a canonical name. if found punt
     * since we'll find it during the canonical name search
     * in dnresolve().
     */
    if(type != Tcname){
        rp = rrlookup(dp, Tcname, NOneg);
        lock(&dnlock);
        rrfreelist(rp);
        unlock(&dnlock);
        if(rp){
            if(debug)
                dnslog("[%d] dnresolve1 %s %d %d: rr from rrlookup for non-cname",
                    getpid(), name, type, class);
            return nil;
        }
    }

    /*
     * if the domain name is within an area of ours,
     * we should have found its data in memory by now.
     */
    area = inmyarea(dp->name);
    if (area || strncmp(dp->name, "local#", 6) == 0) {
//		char buf[32];

//		dnslog("%s %s: no data in area %s", dp->name,
//			rrname(type, buf, sizeof buf), area->soarr->owner->name);
        return nil;
    }

    qp = emalloc(sizeof *qp);
    queryinit(qp, dp, type, req);
    rp = issuequery(qp, name, class, depth, recurse);
    querydestroy(qp);
    free(qp);
    if(rp){
        if(debug)
            dnslog("[%d] dnresolve1 %s %d %d: rr from query",
                getpid(), name, type, class);
        return rp;
    }

    /* settle for a non-authoritative answer */
    rp = rrlookup(dp, type, OKneg);
    if(rp){
        if(debug)
            dnslog("[%d] dnresolve1 %s %d %d: rr from rrlookup",
                getpid(), name, type, class);
        return rp;
    }

    /* noone answered.  try the database, we might have a chance. */
    rp = dblookup(name, class, type, 0, 0);
    if (rp) {
        if(debug)
            dnslog("[%d] dnresolve1 %s %d %d: rr from dblookup",
                getpid(), name, type, class);
    }else{
        if(debug)
            dnslog("[%d] dnresolve1 %s %d %d: no rr from dblookup; crapped out",
                getpid(), name, type, class);
    }
    return rp;
}
@

<<function [[walkup]]>>=
/*
 *  walk a domain name one element to the right.
 *  return a pointer to that element.
 *  in other words, return a pointer to the parent domain name.
 */
char*
walkup(char *name)
{
    char *cp;

    cp = strchr(name, '.');
    if(cp)
        return cp+1;
    else if(*name)
        return "";
    else
        return 0;
}
@

<<global [[hmsg]]>>=
/*
 *  Get a udp port for sending requests and reading replies.  Put the port
 *  into "headers" mode.
 */
static char *hmsg = "headers";
@

<<function [[udpport]]>>=
int
udpport(char *mtpt)
{
    int fd, ctl;
    char ds[64], adir[64];

    /* get a udp port */
    snprint(ds, sizeof ds, "%s/udp!*!0", (mtpt? mtpt: "/net"));
    ctl = announce(ds, adir);
    if(ctl < 0){
        /* warning("can't get udp port"); */
        return -1;
    }

    /* turn on header style interface */
    if(write(ctl, hmsg, strlen(hmsg)) != strlen(hmsg)){
        close(ctl);
        warning(hmsg);
        return -1;
    }

    /* grab the data file */
    snprint(ds, sizeof ds, "%s/data", adir);
    fd = open(ds, ORDWR);
    close(ctl);
    if(fd < 0)
        warning("can't open udp port %s: %r", ds);
    return fd;
}
@

<<function [[initdnsmsg]]>>=
void
initdnsmsg(DNSmsg *mp, RR *rp, int flags, ushort reqno)
{
    mp->flags = flags;
    mp->id = reqno;
    mp->qd = rp;
    if(rp != nil)
        mp->qdcount = 1;
}
@

<<function [[newdnsmsg]]>>=
DNSmsg *
newdnsmsg(RR *rp, int flags, ushort reqno)
{
    DNSmsg *mp;

    mp = emalloc(sizeof *mp);
    initdnsmsg(mp, rp, flags, reqno);
    return mp;
}
@

<<function [[mkreq]]>>=
/* generate a DNS UDP query packet */
int
mkreq(DN *dp, int type, uchar *buf, int flags, ushort reqno)
{
    DNSmsg m;
    int len;
    Udphdr *uh = (Udphdr*)buf;
    RR *rp;

    /* stuff port number into output buffer */
    memset(uh, 0, sizeof *uh);
    hnputs(uh->rport, 53);

    /* make request and convert it to output format */
    memset(&m, 0, sizeof m);
    rp = rralloc(type);
    rp->owner = dp;
    initdnsmsg(&m, rp, flags, reqno);
    len = convDNS2M(&m, &buf[Udphdrsize], Maxudp);
    rrfreelistptr(&m.qd);
    memset(&m, 0, sizeof m);		/* cause trouble */
    return len;
}
@

<<function [[freeanswers]]>>=
void
freeanswers(DNSmsg *mp)
{
    lock(&dnlock);
    rrfreelistptr(&mp->qd);
    rrfreelistptr(&mp->an);
    rrfreelistptr(&mp->ns);
    rrfreelistptr(&mp->ar);
    unlock(&dnlock);
    mp->qdcount = mp->ancount = mp->nscount = mp->arcount = 0;
}
@

<<function [[readnet]]>>=
/* timed read of reply.  sets srcip.  ibuf must be 64K to handle tcp answers. */
static int
readnet(Query *qp, int medium, uchar *ibuf, uvlong endms, uchar **replyp,
    uchar *srcip)
{
    int len, fd;
    long ms;
    vlong startns = nsec();
    uchar *reply;
    uchar lenbuf[2];

    len = -1;			/* pessimism */
    ms = endms - NS2MS(startns);
    if (ms <= 0)
        return -1;		/* taking too long */

    reply = ibuf;
    memset(srcip, 0, IPaddrlen);
    alarm(ms);
    if (medium == Udp)
        if (qp->udpfd <= 0)
            dnslog("readnet: qp->udpfd closed");
        else {
            len = read(qp->udpfd, ibuf, Udphdrsize+Maxudpin);
            alarm(0);
            notestats(startns, len < 0, qp->type);
            if (len >= IPaddrlen)
                memmove(srcip, ibuf, IPaddrlen);
            if (len >= Udphdrsize) {
                len   -= Udphdrsize;
                reply += Udphdrsize;
            }
        }
    else {
        if (!qp->tcpset)
            dnslog("readnet: tcp params not set");
        fd = qp->tcpfd;
        if (fd <= 0)
            dnslog("readnet: %s: tcp fd unset for dest %I",
                qp->dp->name, qp->tcpip);
        else if (readn(fd, lenbuf, 2) != 2) {
            dnslog("readnet: short read of 2-byte tcp msg size from %I",
                qp->tcpip);
            /* probably a time-out */
            notestats(startns, 1, qp->type);
        } else {
            len = lenbuf[0]<<8 | lenbuf[1];
            if (readn(fd, ibuf, len) != len) {
                dnslog("readnet: short read of tcp data from %I",
                    qp->tcpip);
                /* probably a time-out */
                notestats(startns, 1, qp->type);
                len = -1;
            }
        }
        memmove(srcip, qp->tcpip, IPaddrlen);
    }
    alarm(0);
    *replyp = reply;
    return len;
}
@

<<function [[readreply]]>>=
/*
 *  read replies to a request and remember the rrs in the answer(s).
 *  ignore any of the wrong type.
 *  wait at most until endms.
 */
static int
readreply(Query *qp, int medium, ushort req, uchar *ibuf, DNSmsg *mp,
    uvlong endms)
{
    int len;
    char *err;
    char tbuf[32];
    uchar *reply;
    uchar srcip[IPaddrlen];
    RR *rp;

    queryck(qp);
    memset(mp, 0, sizeof *mp);
    memset(srcip, 0, sizeof srcip);
    if (0)
        len = -1;
    for (; timems() < endms &&
        (len = readnet(qp, medium, ibuf, endms, &reply, srcip)) >= 0;
        freeanswers(mp)){
        /* convert into internal format  */
        memset(mp, 0, sizeof *mp);
        err = convM2DNS(reply, len, mp, nil);
        if (mp->flags & Ftrunc) {
            free(err);
            freeanswers(mp);
            /* notify our caller to retry the query via tcp. */
            return -1;
        } else if(err){
            dnslog("readreply: %s: input err, len %d: %s: %I",
                qp->dp->name, len, err, srcip);
            free(err);
            continue;
        }
        if(debug)
            logreply(qp->req->id, srcip, mp);

        /* answering the right question? */
        if(mp->id != req)
            dnslog("%d: id %d instead of %d: %I", qp->req->id,
                mp->id, req, srcip);
        else if(mp->qd == 0)
            dnslog("%d: no question RR: %I", qp->req->id, srcip);
        else if(mp->qd->owner != qp->dp)
            dnslog("%d: owner %s instead of %s: %I", qp->req->id,
                mp->qd->owner->name, qp->dp->name, srcip);
        else if(mp->qd->type != qp->type)
            dnslog("%d: qp->type %d instead of %d: %I",
                qp->req->id, mp->qd->type, qp->type, srcip);
        else {
            /* remember what request this is in answer to */
            for(rp = mp->an; rp; rp = rp->next)
                rp->query = qp->type;
            return 0;
        }
    }
    if (timems() >= endms) {
        ;				/* query expired */
    } else if (0) {
        /* this happens routinely when a read times out */
        dnslog("readreply: %s type %s: ns %I read error or eof "
            "(returned %d): %r", qp->dp->name, rrname(qp->type,
            tbuf, sizeof tbuf), srcip, len);
        if (medium == Udp)
            for (rp = qp->nsrp; rp != nil; rp = rp->next)
                if (rp->type == Tns)
                    dnslog("readreply: %s: query sent to "
                        "ns %s", qp->dp->name,
                        rp->host->name);
    }
    return -1;
}
@

<<function [[contains]]>>=
/*
 *	return non-0 if first list includes second list
 */
int
contains(RR *rp1, RR *rp2)
{
    RR *trp1, *trp2;

    for(trp2 = rp2; trp2; trp2 = trp2->next){
        for(trp1 = rp1; trp1; trp1 = trp1->next)
            if(trp1->type == trp2->type)
            if(trp1->host == trp2->host)
            if(trp1->owner == trp2->owner)
                break;
        if(trp1 == nil)
            return 0;
    }
    return 1;
}
@

<<function [[ipisbm]]>>=
/*
 *  return multicast version if any
 */
int
ipisbm(uchar *ip)
{
    if(isv4(ip)){
        if (ip[IPv4off] >= 0xe0 && ip[IPv4off] < 0xf0 ||
            ipcmp(ip, IPv4bcast) == 0)
            return 4;
    } else
        if(ip[0] == 0xff)
            return 6;
    return 0;
}
@

<<function [[serveraddrs]]>>=
/*
 *  Get next server address(es) into qp->dest[nd] and beyond
 */
static int
serveraddrs(Query *qp, int nd, int depth)
{
    RR *rp, *arp, *trp;
    Dest *cur;

    if(nd >= Maxdest)		/* dest array is full? */
        return Maxdest - 1;

    /*
     *  look for a server whose address we already know.
     *  if we find one, mark it so we ignore this on
     *  subsequent passes.
     */
    arp = 0;
    for(rp = qp->nsrp; rp; rp = rp->next){
        assert(rp->magic == RRmagic);
        if(rp->marker)
            continue;
        arp = rrlookup(rp->host, Ta, NOneg);
        if(arp == nil)
            arp = rrlookup(rp->host, Taaaa, NOneg);
        if(arp){
            rp->marker = 1;
            break;
        }
        arp = dblookup(rp->host->name, Cin, Ta, 0, 0);
        if(arp == nil)
            arp = dblookup(rp->host->name, Cin, Taaaa, 0, 0);
        if(arp){
            rp->marker = 1;
            break;
        }
    }

    /*
     *  if the cache and database lookup didn't find any new
     *  server addresses, try resolving one via the network.
     *  Mark any we try to resolve so we don't try a second time.
     */
    if(arp == 0)
        for(rp = qp->nsrp; rp; rp = rp->next){
            if(rp->marker)
                continue;
            rp->marker = 1;

            /*
             *  avoid loops looking up a server under itself
             */
            if(subsume(rp->owner->name, rp->host->name))
                continue;

            arp = dnresolve(rp->host->name, Cin, Ta, qp->req, 0,
                depth+1, Recurse, 1, 0);
            if(arp == nil)
                arp = dnresolve(rp->host->name, Cin, Taaaa,
                    qp->req, 0, depth+1, Recurse, 1, 0);
            lock(&dnlock);
            rrfreelist(rrremneg(&arp));
            unlock(&dnlock);
            if(arp)
                break;
        }

    /* use any addresses that we found */
    for(trp = arp; trp && nd < Maxdest; trp = trp->next){
        cur = &qp->dest[nd];
        parseip(cur->a, trp->ip->name);
        /*
         * straddling servers can reject all nameservers if they are all
         * inside, so be sure to list at least one outside ns at
         * the end of the ns list in /lib/ndb for `dom='.
         */
        if (ipisbm(cur->a) ||
            cfg.straddle && !insideaddr(qp->dp->name) && insidens(cur->a))
            continue;
        cur->nx = 0;
        cur->s = trp->owner;
        cur->code = Rtimeout;
        nd++;
    }
    lock(&dnlock);
    rrfreelist(arp);
    unlock(&dnlock);
    if(nd >= Maxdest)		/* dest array is full? */
        return Maxdest - 1;
    return nd;
}
@

<<function [[cacheneg]]>>=
/*
 *  cache negative responses
 */
static void
cacheneg(DN *dp, int type, int rcode, RR *soarr)
{
    RR *rp;
    DN *soaowner;
    ulong ttl;

    stats.negcached++;

    /* no cache time specified, don't make anything up */
    if(soarr != nil){
        lock(&dnlock);
        if(soarr->next != nil)
            rrfreelistptr(&soarr->next);
        unlock(&dnlock);
        soaowner = soarr->owner;
    } else
        soaowner = nil;

    /* the attach can cause soarr to be freed so mine it now */
    if(soarr != nil && soarr->soa != nil)
        ttl = soarr->soa->minttl+now;
    else
        ttl = 5*Min;

    /* add soa and negative RR to the database */
    rrattach(soarr, Authoritative);

    rp = rralloc(type);
    rp->owner = dp;
    rp->negative = 1;
    rp->negsoaowner = soaowner;
    rp->negrcode = rcode;
    rp->ttl = ttl;
    rrattach(rp, Authoritative);
}
@

<<function [[setdestoutns]]>>=
static int
setdestoutns(Dest *p, int n)
{
    uchar *outns = outsidens(n);

    destck(p);
    destinit(p);
    if (outns == nil) {
        if (n == 0)
            dnslog("[%d] no outside-ns in ndb", getpid());
        return -1;
    }
    memmove(p->a, outns, sizeof p->a);
    p->s = dnlookup("outside-ns-ips", Cin, 1);
    return 0;
}
@

<<function [[mydnsquery]]>>=
/*
 * issue query via UDP or TCP as appropriate.
 * for TCP, returns with qp->tcpip set from udppkt header.
 */
static int
mydnsquery(Query *qp, int medium, uchar *udppkt, int len)
{
    int rv = -1, nfd;
    char *domain;
    char conndir[NETPATHLEN], net[NETPATHLEN];
    uchar belen[2];
    NetConnInfo *nci;

    queryck(qp);
    domain = smprint("%I", udppkt);
    if (myaddr(domain)) {
        dnslog("mydnsquery: trying to send to myself (%s); bzzzt",
            domain);
        free(domain);
        return rv;
    }

    switch (medium) {
    case Udp:
        free(domain);
        nfd = dup(qp->udpfd, -1);
        if (nfd < 0) {
            warning("mydnsquery: qp->udpfd %d: %r", qp->udpfd);
            close(qp->udpfd);	/* ensure it's closed */
            qp->udpfd = -1;		/* poison it */
            return rv;
        }
        close(nfd);

        if (qp->udpfd <= 0)
            dnslog("mydnsquery: qp->udpfd %d closed", qp->udpfd);
        else {
            if (write(qp->udpfd, udppkt, len+Udphdrsize) !=
                len+Udphdrsize)
                warning("sending udp msg: %r");
            else {
                stats.qsent++;
                rv = 0;
            }
        }
        break;
    case Tcp:
        /* send via TCP & keep fd around for reply */
        snprint(net, sizeof net, "%s/tcp",
            (mntpt[0] != '\0'? mntpt: "/net"));
        alarm(10*1000);
        qp->tcpfd = rv = dial(netmkaddr(domain, net, "dns"), nil,
            conndir, &qp->tcpctlfd);
        alarm(0);
        if (qp->tcpfd < 0) {
            dnslog("can't dial tcp!%s!dns: %r", domain);
            free(domain);
            break;
        }
        free(domain);
        nci = getnetconninfo(conndir, qp->tcpfd);
        if (nci) {
            parseip(qp->tcpip, nci->rsys);
            freenetconninfo(nci);
        } else
            dnslog("mydnsquery: getnetconninfo failed");
        qp->tcpset = 1;

        belen[0] = len >> 8;
        belen[1] = len;
        if (write(qp->tcpfd, belen, 2) != 2 ||
            write(qp->tcpfd, udppkt + Udphdrsize, len) != len)
            warning("sending tcp msg: %r");
        break;
    default:
        sysfatal("mydnsquery: bad medium");
    }
    return rv;
}
@

<<function [[xmitquery]]>>=
/*
 * send query to all UDP destinations or one TCP destination,
 * taken from obuf (udp packet) header
 */
static int
xmitquery(Query *qp, int medium, int depth, uchar *obuf, int inns, int len)
{
    int j, n;
    char buf[32];
    Dest *p;

    queryck(qp);
    if(timems() >= qp->req->aborttime)
        return -1;

    /*
     * get a nameserver address if we need one.
     * serveraddrs populates qp->dest.
     */
    p = qp->dest;
    destck(p);
    if (qp->ndest < 0 || qp->ndest > Maxdest) {
        dnslog("qp->ndest %d out of range", qp->ndest);
        abort();
    }
    /*
     * we're to transmit to more destinations than we currently have,
     * so get another.
     */
    if (qp->ndest > qp->curdest - p) {
        j = serveraddrs(qp, qp->curdest - p, depth);
        if (j < 0 || j >= Maxdest) {
            dnslog("serveraddrs() result %d out of range", j);
            abort();
        }
        qp->curdest = &qp->dest[j];
    }
    destck(qp->curdest);

    /* no servers, punt */
    if (qp->ndest == 0)
        if (cfg.straddle && cfg.inside) {
            /* get ips of "outside-ns-ips" */
            qp->curdest = qp->dest;
            for(n = 0; n < Maxdest; n++, qp->curdest++)
                if (setdestoutns(qp->curdest, n) < 0)
                    break;
            if(n == 0)
                dnslog("xmitquery: %s: no outside-ns nameservers",
                    qp->dp->name);
        } else
            /* it's probably just a bogus domain, don't log it */
            return -1;

    /* send to first 'qp->ndest' destinations */
    j = 0;
    if (medium == Tcp) {
        j++;
        queryck(qp);
        assert(qp->dp);
        procsetname("tcp %sside query for %s %s", (inns? "in": "out"),
            qp->dp->name, rrname(qp->type, buf, sizeof buf));
        mydnsquery(qp, medium, obuf, len); /* sets qp->tcpip from obuf */
        if(debug)
            logsend(qp->req->id, depth, qp->tcpip, "", qp->dp->name,
                qp->type);
    } else
        for(; p < &qp->dest[qp->ndest] && p < qp->curdest; p++){
            /* skip destinations we've finished with */
            if(p->nx >= Maxtrans)
                continue;

            j++;

            /* exponential backoff of requests */
            if((1<<p->nx) > qp->ndest)
                continue;

            if(memcmp(p->a, IPnoaddr, sizeof IPnoaddr) == 0)
                continue;		/* mistake */

            procsetname("udp %sside query to %I/%s %s %s",
                (inns? "in": "out"), p->a, p->s->name,
                qp->dp->name, rrname(qp->type, buf, sizeof buf));
            if(debug)
                logsend(qp->req->id, depth, p->a, p->s->name,
                    qp->dp->name, qp->type);

            /* fill in UDP destination addr & send it */
            memmove(obuf, p->a, sizeof p->a);
            mydnsquery(qp, medium, obuf, len);
            p->nx++;
        }
    if(j == 0) {
        return -1;
    }
    return 0;
}
@

<<global [[lckindex]]>>=
static int lckindex[Maxlcks] = {
    0,			/* all others map here */
    Ta,
    Tns,
    Tcname,
    Tsoa,
    Tptr,
    Tmx,
    Ttxt,
    Taaaa,
};
@

<<function [[qtype2lck]]>>=
static int
qtype2lck(int qtype)		/* map query type to querylck index */
{
    int i;

    for (i = 1; i < nelem(lckindex); i++)
        if (lckindex[i] == qtype)
            return i;
    return 0;
}
@

<<function [[isnegrname]]>>=
/* is mp a cachable negative response (with Rname set)? */
static int
isnegrname(DNSmsg *mp)
{
    /* TODO: could add || cfg.justforw to RHS of && */
    return mp->an == nil && (mp->flags & Rmask) == Rname;
}
@

<<function [[procansw]]>>=
/* returns Answerr (-1) on errors, else number of answers, which can be zero. */
static int
procansw(Query *qp, DNSmsg *mp, uchar *srcip, int depth, Dest *p)
{
    int rv;
//	int lcktype;
    char buf[32];
    DN *ndp;
    Query *nqp;
    RR *tp, *soarr;

    if (mp->an == nil)
        stats.negans++;

    /* ignore any error replies */
    if((mp->flags & Rmask) == Rserver){
        stats.negserver++;
        freeanswers(mp);
        if(p != qp->curdest)
            p->code = Rserver;
        return Answerr;
    }

    /* ignore any bad delegations */
    if(mp->ns && baddelegation(mp->ns, qp->nsrp, srcip)){
        stats.negbaddeleg++;
        if(mp->an == nil){
            stats.negbdnoans++;
            freeanswers(mp);
            if(p != qp->curdest)
                p->code = Rserver;
            dnslog(" and no answers");
            return Answerr;
        }
        dnslog(" but has answers; ignoring ns");
        lock(&dnlock);
        rrfreelistptr(&mp->ns);
        unlock(&dnlock);
        mp->nscount = 0;
    }

    /* remove any soa's from the authority section */
    lock(&dnlock);
    soarr = rrremtype(&mp->ns, Tsoa);

    /* incorporate answers */
    unique(mp->an);
    unique(mp->ns);
    unique(mp->ar);
    unlock(&dnlock);

    if(mp->an)
        rrattach(mp->an, (mp->flags & Fauth) != 0);
    if(mp->ar)
        rrattach(mp->ar, Notauthoritative);
    if(mp->ns && !cfg.justforw){
        ndp = mp->ns->owner;
        rrattach(mp->ns, Notauthoritative);
    } else {
        ndp = nil;
        lock(&dnlock);
        rrfreelistptr(&mp->ns);
        unlock(&dnlock);
        mp->nscount = 0;
    }

    /* free the question */
    if(mp->qd) {
        lock(&dnlock);
        rrfreelistptr(&mp->qd);
        unlock(&dnlock);
        mp->qdcount = 0;
    }

    /*
     *  Any reply from an authoritative server,
     *  or a positive reply terminates the search.
     *  A negative response now also terminates the search.
     */
    if(mp->an != nil || (mp->flags & Fauth)){
        if(isnegrname(mp))
            qp->dp->respcode = Rname;
        else
            qp->dp->respcode = Rok;

        /*
         *  cache any negative responses, free soarr.
         *  negative responses need not be authoritative:
         *  they can legitimately come from a cache.
         */
        if( /* (mp->flags & Fauth) && */ mp->an == nil)
            cacheneg(qp->dp, qp->type, (mp->flags & Rmask), soarr);
        else {
            lock(&dnlock);
            rrfreelist(soarr);
            unlock(&dnlock);
        }
        return 1;
    } else if (isnegrname(mp)) {
        qp->dp->respcode = Rname;
        /*
         *  cache negative response.
         *  negative responses need not be authoritative:
         *  they can legitimately come from a cache.
         */
        cacheneg(qp->dp, qp->type, (mp->flags & Rmask), soarr);
        return 1;
    }
    stats.negnorname++;
    lock(&dnlock);
    rrfreelist(soarr);
    unlock(&dnlock);

    /*
     *  if we've been given better name servers, recurse.
     *  if we're a pure resolver, don't recurse, we have
     *  to forward to a fixed set of named servers.
     */
    if(!mp->ns || cfg.resolver && cfg.justforw)
        return Answnone;
    tp = rrlookup(ndp, Tns, NOneg);
    if(contains(qp->nsrp, tp)){
        lock(&dnlock);
        rrfreelist(tp);
        unlock(&dnlock);
        return Answnone;
    }
    procsetname("recursive query for %s %s", qp->dp->name,
        rrname(qp->type, buf, sizeof buf));
    /*
     *  we're called from udpquery, called from
     *  netquery, which current holds qp->dp->querylck,
     *  so release it now and acquire it upon return.
     */
//	lcktype = qtype2lck(qp->type);		/* someday try this again */
//	qunlock(&qp->dp->querylck[lcktype]);

    nqp = emalloc(sizeof *nqp);
    queryinit(nqp, qp->dp, qp->type, qp->req);
    nqp->nsrp = tp;
    rv = netquery(nqp, depth+1);

//	qlock(&qp->dp->querylck[lcktype]);
    rrfreelist(nqp->nsrp);
    querydestroy(nqp);
    free(nqp);
    return rv;
}
@

<<function [[tcpquery]]>>=
/*
 * send a query via tcp to a single address (from ibuf's udp header)
 * and read the answer(s) into mp->an.
 */
static int
tcpquery(Query *qp, DNSmsg *mp, int depth, uchar *ibuf, uchar *obuf, int len,
    ulong waitms, int inns, ushort req)
{
    int rv = 0;
    uvlong endms;

    endms = timems() + waitms;
    if(endms > qp->req->aborttime)
        endms = qp->req->aborttime;

    if (0)
        dnslog("%s: udp reply truncated; retrying query via tcp to %I",
            qp->dp->name, qp->tcpip);

    qlock(&qp->tcplock);
    memmove(obuf, ibuf, IPaddrlen);		/* send back to respondent */
    /* sets qp->tcpip from obuf's udp header */
    if (xmitquery(qp, Tcp, depth, obuf, inns, len) < 0 ||
        readreply(qp, Tcp, req, ibuf, mp, endms) < 0)
        rv = -1;
    if (qp->tcpfd > 0) {
        hangup(qp->tcpctlfd);
        close(qp->tcpctlfd);
        close(qp->tcpfd);
    }
    qp->tcpfd = qp->tcpctlfd = -1;
    qunlock(&qp->tcplock);
    return rv;
}
@

<<function [[queryns]]>>=
/*
 *  query name servers.  fill in obuf with on-the-wire representation of a
 *  DNSmsg derived from qp.  if the name server returns a pointer to another
 *  name server, recurse.
 */
static int
queryns(Query *qp, int depth, uchar *ibuf, uchar *obuf, ulong waitms, int inns)
{
    int ndest, len, replywaits, rv;
    ushort req;
    uvlong endms;
    char buf[12];
    uchar srcip[IPaddrlen];
    Dest *p, *np, *dest;

    /* pack request into a udp message */
    req = rand();
    len = mkreq(qp->dp, qp->type, obuf, Frecurse|Oquery, req);

    /* no server addresses yet */
    queryck(qp);
    dest = emalloc(Maxdest * sizeof *dest);	/* dest can't be on stack */
    for (p = dest; p < dest + Maxdest; p++)
        destinit(p);
    /* this dest array is local to this call of queryns() */
    free(qp->dest);
    qp->curdest = qp->dest = dest;

    /*
     *  transmit udp requests and wait for answers.
     *  at most Maxtrans attempts to each address.
     *  each cycle send one more message than the previous.
     *  retry a query via tcp if its response is truncated.
     */
    for(ndest = 1; ndest < Maxdest; ndest++){
        qp->ndest = ndest;
        qp->tcpset = 0;
        if (xmitquery(qp, Udp, depth, obuf, inns, len) < 0)
            break;

        endms = timems() + waitms;
        if(endms > qp->req->aborttime)
            endms = qp->req->aborttime;

        for(replywaits = 0; replywaits < ndest; replywaits++){
            DNSmsg m;

            procsetname("reading %sside reply from %I: %s %s from %s",
                (inns? "in": "out"), obuf, qp->dp->name,
                rrname(qp->type, buf, sizeof buf), qp->req->from);

            /* read udp answer into m */
            if (readreply(qp, Udp, req, ibuf, &m, endms) >= 0)
                memmove(srcip, ibuf, IPaddrlen);
            else if (!(m.flags & Ftrunc)) {
                freeanswers(&m);
                break;		/* timed out on this dest */
            } else {
                /* whoops, it was truncated! ask again via tcp */
                freeanswers(&m);
                rv = tcpquery(qp, &m, depth, ibuf, obuf, len,
                    waitms, inns, req);  /* answer in m */
                if (rv < 0) {
                    freeanswers(&m);
                    break;		/* failed via tcp too */
                }
                memmove(srcip, qp->tcpip, IPaddrlen);
            }

            /* find responder */
            // dnslog("queryns got reply from %I", srcip);
            for(p = qp->dest; p < qp->curdest; p++)
                if(memcmp(p->a, srcip, sizeof p->a) == 0)
                    break;

            /* remove all addrs of responding server from list */
            for(np = qp->dest; np < qp->curdest; np++)
                if(np->s == p->s)
                    np->nx = Maxtrans;

            /* free or incorporate RRs in m */
            rv = procansw(qp, &m, srcip, depth, p);
            if (rv > Answnone) {
                free(qp->dest);
                qp->dest = qp->curdest = nil; /* prevent accidents */
                return rv;
            }
        }
    }

    /* if all servers returned failure, propagate it */
    qp->dp->respcode = Rserver;
    for(p = dest; p < qp->curdest; p++) {
        destck(p);
        if(p->code != Rserver)
            qp->dp->respcode = Rok;
        p->magic = 0;			/* prevent accidents */
    }

//	if (qp->dp->respcode)
//		dnslog("queryns setting Rserver for %s", qp->dp->name);

    free(qp->dest);
    qp->dest = qp->curdest = nil;		/* prevent accidents */
    return Answnone;
}
@

<<function [[system]]([[(networking/ndb/dnresolve.c)]])>>=
/*
 *  run a command with a supplied fd as standard input
 */
char *
system(int fd, char *cmd)
{
    int pid, p, i;
    static Waitmsg msg;

    if((pid = fork()) == -1)
        sysfatal("fork failed: %r");
    else if(pid == 0){
        dup(fd, 0);
        close(fd);
        for (i = 3; i < 200; i++)
            close(i);		/* don't leak fds */
        execl("/bin/rc", "rc", "-c", cmd, nil);
        sysfatal("exec rc: %r");
    }
    for(p = waitpid(); p >= 0; p = waitpid())
        if(p == pid)
            return msg.msg;
    return "lost child";
}
@

<<function [[weight]]>>=
/* compute wait, weighted by probability of success, with bounds */
static ulong
weight(ulong ms, unsigned pcntprob)
{
    ulong wait;

    wait = (ms * pcntprob) / 100;
    if (wait < Minwaitms)
        wait = Minwaitms;
    if (wait > Maxwaitms)
        wait = Maxwaitms;
    return wait;
}
@

<<function [[udpquery]]>>=
/*
 * in principle we could use a single descriptor for a udp port
 * to send all queries and receive all the answers to them,
 * but we'd have to sort out the answers by dns-query id.
 */
static int
udpquery(Query *qp, char *mntpt, int depth, int patient, int inns)
{
    int fd, rv;
    long now;
    ulong pcntprob;
    uvlong wait, reqtm;
    char *msg;
    uchar *obuf, *ibuf;
    static QLock mntlck;
    static ulong lastmount;

    /* use alloced buffers rather than ones from the stack */
    ibuf = emalloc(64*1024);		/* max. tcp reply size */
    obuf = emalloc(Maxudp+Udphdrsize);

    fd = udpport(mntpt);
    while (fd < 0 && cfg.straddle && strcmp(mntpt, "/net.alt") == 0) {
        /* HACK: remount /net.alt */
        now = time(nil);
        if (now < lastmount + Remntretry)
            sleep(S2MS(lastmount + Remntretry - now));
        qlock(&mntlck);
        fd = udpport(mntpt);	/* try again under lock */
        if (fd < 0) {
            dnslog("[%d] remounting /net.alt", getpid());
            unmount(nil, "/net.alt");

            msg = system(open("/dev/null", ORDWR), "outside");

            lastmount = time(nil);
            if (msg && *msg) {
                dnslog("[%d] can't remount /net.alt: %s",
                    getpid(), msg);
                sleep(10*1000);	/* don't spin remounting */
            } else
                fd = udpport(mntpt);
        }
        qunlock(&mntlck);
    }
    if (fd < 0) {
        dnslog("can't get udpport for %s query of name %s: %r",
            mntpt, qp->dp->name);
        sysfatal("out of udp conversations");	/* we're buggered */
    }

    /*
     * Our QIP servers are busted and respond to AAAA and CNAME queries
     * with (sometimes malformed [too short] packets and) no answers and
     * just NS RRs but not Rname errors.  so make time-to-wait
     * proportional to estimated probability of an RR of that type existing.
     */
    if (qp->type >= nelem(likely))
        pcntprob = 35;			/* unpopular query type */
    else
        pcntprob = likely[qp->type];
    reqtm = (patient? 2 * Maxreqtm: Maxreqtm);
    wait = weight(reqtm / 3, pcntprob);	/* time for one udp query */
    qp->req->aborttime = timems() + 3*wait; /* for all udp queries */

    qp->udpfd = fd;
    rv = queryns(qp, depth, ibuf, obuf, wait, inns);
    close(fd);
    qp->udpfd = -1;

    free(obuf);
    free(ibuf);
    return rv;
}
@

<<function [[netquery]]>>=
/*
 * look up (qp->dp->name, qp->type) rr in dns,
 * using nameservers in qp->nsrp.
 */
static int
netquery(Query *qp, int depth)
{
    int lock, rv, triedin, inname;
    char buf[32];
    RR *rp;
    DN *dp;
    Querylck *qlp;
    static int whined;

    rv = Answnone;			/* pessimism */
    if(depth > 12)			/* in a recursive loop? */
        return Answnone;

    slave(qp->req);
    /*
     * slave might have forked.  if so, the parent process longjmped to
     * req->mret; we're usually the child slave, but if there are too
     * many children already, we're still the same process.
     */

    /*
     * don't lock before call to slave so only children can block.
     * just lock at top-level invocation.
     */
    lock = depth <= 1 && qp->req->isslave;
    dp = qp->dp;		/* ensure that it doesn't change underfoot */
    qlp = nil;
    if(lock) {
        procsetname("query lock wait: %s %s from %s", dp->name,
            rrname(qp->type, buf, sizeof buf), qp->req->from);
        /*
         * don't make concurrent queries for this name.
         * dozens of processes blocking here probably indicates
         * an error in our dns data that causes us to not
         * recognise a zone (area) as one of our own, thus
         * causing us to query other nameservers.
         */
        qlp = &dp->querylck[qtype2lck(qp->type)];
        qlock(qlp);
        if (qlp->Ref.ref > Maxoutstanding) {
            qunlock(qlp);
            if (!whined) {
                whined = 1;
                dnslog("too many outstanding queries for %s;"
                    " dropping this one; no further logging"
                    " of drops", dp->name);
            }
            return 0;
        }
        ++qlp->Ref.ref;
        qunlock(qlp);
    }
    procsetname("netquery: %s", dp->name);

    /* prepare server RR's for incremental lookup */
    for(rp = qp->nsrp; rp; rp = rp->next)
        rp->marker = 0;

    triedin = 0;

    /*
     * normal resolvers and servers will just use mntpt for all addresses,
     * even on the outside.  straddling servers will use mntpt (/net)
     * for inside addresses and /net.alt for outside addresses,
     * thus bypassing other inside nameservers.
     */
    inname = insideaddr(dp->name);
    if (!cfg.straddle || inname) {
        rv = udpquery(qp, mntpt, depth, Hurry, (cfg.inside? Inns: Outns));
        triedin = 1;
    }

    /*
     * if we're still looking, are inside, and have an outside domain,
     * try it on our outside interface, if any.
     */
    if (rv == Answnone && cfg.inside && !inname) {
        if (triedin)
            dnslog(
       "[%d] netquery: internal nameservers failed for %s; trying external",
                getpid(), dp->name);

        /* prepare server RR's for incremental lookup */
        for(rp = qp->nsrp; rp; rp = rp->next)
            rp->marker = 0;

        rv = udpquery(qp, "/net.alt", depth, Patient, Outns);
    }
//	if (rv == Answnone)		/* could ask /net.alt/dns directly */
//		askoutdns(dp, qp->type);

    if(lock && qlp) {
        qlock(qlp);
        assert(qlp->Ref.ref > 0);
        qunlock(qlp);
        decref(qlp);
    }
    return rv;
}
@

<<function [[seerootns]]>>=
int
seerootns(void)
{
    int rv;
    char root[] = "";
    Request req;
    RR *rr;
    Query *qp;

    memset(&req, 0, sizeof req);
    req.isslave = 1;
    req.aborttime = timems() + Maxreqtm;
    req.from = "internal";

    qp = emalloc(sizeof *qp);
    queryinit(qp, dnlookup(root, Cin, 1), Tns, &req);
    qp->nsrp = dblookup(root, Cin, Tns, 0, 0);
    for (rr = qp->nsrp; rr != nil; rr = rr->next)	/* DEBUG */
        dnslog("seerootns query nsrp: %R", rr);

    rv = netquery(qp, 0);		/* lookup ". ns" using qp->nsrp */

    rrfreelist(qp->nsrp);
    querydestroy(qp);
    free(qp);
    return rv;
}
@


%-------------------------------------------------------------

<<networking/ndb/dnresolve.c>>=
/*
 * domain name resolvers, see rfcs 1035 and 1123
 */
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include "dns.h"

typedef struct Dest Dest;
typedef struct Ipaddr Ipaddr;
typedef struct Query Query;

<<enum [[_anon_ (networking/ndb/dnresolve.c)]]>>
<<enum [[_anon_ (networking/ndb/dnresolve.c)2]]>>
<<enum [[_anon_ (networking/ndb/dnresolve.c)3]]>>

<<struct [[Ipaddr]]>>

<<struct [[Dest]]>>

<<struct [[Query]]>>

<<global [[likely]]>>

static RR*	dnresolve1(char*, int, int, Request*, int, int);
static int	netquery(Query *, int);

<<function [[procgetname]]([[(networking/ndb/dnresolve.c)]])>>

<<function [[rrfreelistptr]]>>

<<function [[dnresolve]]>>

<<function [[queryinit]]>>

<<function [[queryck]]>>

<<function [[querydestroy]]>>

<<function [[destinit]]>>

<<function [[destck]]>>

<<function [[notestats]]>>

<<function [[noteinmem]]>>

<<function [[netqueryns]]>>

<<function [[issuequery]]>>

<<function [[dnresolve1]]>>

<<function [[walkup]]>>

<<global [[hmsg]]>>

<<function [[udpport]]>>

<<function [[initdnsmsg]]>>

<<function [[newdnsmsg]]>>

<<function [[mkreq]]>>

<<function [[freeanswers]]>>

<<function [[readnet]]>>

<<function [[readreply]]>>

<<function [[contains]]>>


<<function [[ipisbm]]>>

<<function [[serveraddrs]]>>

<<function [[cacheneg]]>>

<<function [[setdestoutns]]>>

<<function [[mydnsquery]]>>

<<function [[xmitquery]]>>

<<global [[lckindex]]>>

<<function [[qtype2lck]]>>

<<function [[isnegrname]]>>

<<function [[procansw]]>>

<<function [[tcpquery]]>>

<<function [[queryns]]>>

<<function [[system]]([[(networking/ndb/dnresolve.c)]])>>

<<function [[weight]]>>

<<function [[udpquery]]>>

<<function [[netquery]]>>

<<function [[seerootns]]>>
@


\subsection*{[[networking/ndb/dns.c]]}

<<enum [[_anon_ (networking/ndb/dns.c)]]>>=
enum
{
    Maxrequest=		1024,
    Maxreply=		8192,		/* was 512 */
    Maxrrr=			32,		/* was 16 */
    Maxfdata=		8192,

    Defmaxage=		60*60,	/* default domain name max. age */

    Qdir=			0,
    Qdns=			1,
};
@

<<global [[vers]]([[(networking/ndb/dns.c)]])>>=
int vers;		/* incremented each clone/attach */
@

<<global [[stop]]>>=
static volatile int stop;
@

<<struct [[Mfile]]([[(networking/ndb/dns.c)]])>>=
/* holds data to be returned via read of /net/dns, perhaps multiple reads */
struct Mfile
{
    Mfile		*next;		/* next free mfile */
    int		ref;

    char		*user;
    Qid		qid;
    int		fid;

    int		type;		/* reply type */
    char		reply[Maxreply];
    ushort		rr[Maxrrr];	/* offset of rr's */
    ushort		nrr;		/* number of rr's */
};
@

<<struct [[Job]]([[(networking/ndb/dns.c)]])>>=
/*
 *  active local requests
 */
struct Job
{
    Job	*next;
    int	flushed;
    Fcall	request;
    Fcall	reply;
};
@

<<global [[joblock]]([[(networking/ndb/dns.c)]])>>=
Lock	joblock;
@

<<global [[joblist]]([[(networking/ndb/dns.c)]])>>=
Job	*joblist;
@

<<global [[mfalloc]]>>=
struct {
    Lock;
    Mfile	*inuse;		/* active mfile's */
} mfalloc;
@

<<global [[cfg]]>>=
Cfg	cfg;
@

<<global [[debug]]([[(networking/ndb/dns.c)]])>>=
int	debug;
@

<<global [[ipaddr]]([[(networking/ndb/dns.c)]])>>=
uchar	ipaddr[IPaddrlen];	/* my ip address */
@

<<global [[maxage]]>>=
int	maxage = Defmaxage;
@

<<global [[mfd]]([[(networking/ndb/dns.c)]])>>=
int	mfd[2];
@

<<global [[needrefresh]]>>=
int	needrefresh;
@

<<global [[now]]([[(networking/ndb/dns.c)]])>>=
ulong	now;
@

<<global [[nowns]]>>=
vlong	nowns;
@

<<global [[sendnotifies]]>>=
int	sendnotifies;
@

<<global [[testing]]>>=
int	testing;
@

<<global [[trace]]>>=
char	*trace;
@

<<global [[traceactivity]]>>=
int	traceactivity;
@

<<global [[zonerefreshprogram]]>>=
char	*zonerefreshprogram;
@

<<global [[logfile]]([[(networking/ndb/dns.c)]])>>=
char	*logfile = "dns";	/* or "dns.test" */
@

<<global [[dbfile]]([[(networking/ndb/dns.c)]])>>=
char	*dbfile;
@

<<global [[mntpt]]([[(networking/ndb/dns.c)]])>>=
char	mntpt[Maxpath];
@

<<function [[usage]]([[(networking/ndb/dns.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-FnorRst] [-a maxage] [-f ndb-file] [-N target] "
        "[-T forwip] [-x netmtpt] [-z refreshprog]\n", argv0);
    exits("usage");
}
@

<<function [[justremount]]>>=
void
justremount(char *service, char *mntpt)
{
    int f;

    f = open(service, ORDWR);
    if(f < 0)
        abort(); 	/* service */;
    while (mount(f, -1, mntpt, MAFTER, "") < 0) {
        dnslog("dns mount -a on %s failed: %r", mntpt);
        sleep(5000);
    }
}
@

<<function [[main]]([[(networking/ndb/dns.c)]])>>=
void
main(int argc, char *argv[])
{
    int kid, pid;
    char servefile[Maxpath], ext[Maxpath];
    Dir *dir;

    setnetmtpt(mntpt, sizeof mntpt, nil);
    ext[0] = 0;
    ARGBEGIN{
    case 'a':
        maxage = atol(EARGF(usage()));
        if (maxage <= 0)
            maxage = Defmaxage;
        break;
    case 'd':
        debug = 1;
        traceactivity = 1;
        break;
    case 'f':
        dbfile = EARGF(usage());
        break;
    case 'F':
        cfg.justforw = cfg.resolver = 1;
        break;
    case 'n':
        sendnotifies = 1;
        break;
    case 'N':
        target = atol(EARGF(usage()));
        if (target < 1000)
            target = 1000;
        break;
    case 'o':
        cfg.straddle = 1;	/* straddle inside & outside networks */
        break;
    case 'r':
        cfg.resolver = 1;
        break;
    case 'R':
        norecursion = 1;
        break;
    case 's':
        cfg.serve = 1;		/* serve network */
        cfg.cachedb = 1;
        break;
    case 't':
        testing = 1;
        break;
    case 'T':
        addforwtarg(EARGF(usage()));
        break;
    case 'x':
        setnetmtpt(mntpt, sizeof mntpt, EARGF(usage()));
        setext(ext, sizeof ext, mntpt);
        break;
    case 'z':
        zonerefreshprogram = EARGF(usage());
        break;
    default:
        usage();
        break;
    }ARGEND
    if(argc != 0)
        usage();

    if(testing)
        mainmem->flags |= POOL_NOREUSE | POOL_ANTAGONISM;
    mainmem->flags |= POOL_ANTAGONISM;
    rfork(RFREND|RFNOTEG);

    cfg.inside = (*mntpt == '\0' || strcmp(mntpt, "/net") == 0);

    /* start syslog before we fork */
    fmtinstall('F', fcallfmt);
    dninit();
    /* this really shouldn't be fatal */
    if(myipaddr(ipaddr, mntpt) < 0)
        sysfatal("can't read my ip address");
    dnslog("starting %s%sdns %s%s%son %I's %s",
        (cfg.straddle? "straddling ": ""),
        (cfg.cachedb? "caching ": ""),
        (cfg.serve?   "udp server ": ""),
        (cfg.justforw? "forwarding-only ": ""),
        (cfg.resolver? "resolver ": ""), ipaddr, mntpt);

    opendatabase();
    now = time(nil);		/* open time files before we fork */
    nowns = nsec();

    snprint(servefile, sizeof servefile, "#s/dns%s", ext);
    dir = dirstat(servefile);
    if (dir)
        sysfatal("%s exists; another dns instance is running",
            servefile);
    free(dir);

    /* don't unmount here; could deadlock */
//	while (unmount(servefile, mntpt) >= 0)
//		;
    mountinit(servefile, mntpt);	/* forks, parent exits */

    srand(now*getpid());
    db2cache(1);
//	dnageallnever();

    if (cfg.straddle && !seerootns())
        dnslog("straddle server misconfigured; can't resolve root name servers");
    /*
     * fork without sharing heap.
     * parent waits around for child to die, then forks & restarts.
     * child may spawn udp server, notify procs, etc.; when it gets too
     * big or too old, it kills itself and any children.
     *
     * /srv/dns remains open and valid, but /net/dns was only mounted in
     * a child's separate namespace from 9p service, to avoid a deadlock
     * from serving our own namespace, so we must remount it upon restart,
     * in a separate process and namespace.
     */
    for (;;) {
        start = time(nil);
        /* don't unmount here; could deadlock */
//		unmount(servefile, mntpt);
        kid = rfork(RFPROC|RFFDG|RFNOTEG|RFNAMEG);
        switch (kid) {
        case -1:
            sysfatal("fork failed: %r");
        case 0:
            if(cfg.serve)
                dnudpserver(mntpt);
            if(sendnotifies)
                notifyproc();
            io();		/* serve 9p; return implies restart */
            _exits("restart");
        }
        sleep(1000);	/* wait for 9p service to start */
        justremount(servefile, mntpt);
        while ((pid = waitpid()) != kid && pid != -1)
            continue;
        dnslog("restarting");
    }
}
@

<<function [[setext]]([[(networking/ndb/dns.c)]])>>=
/*
 *  if a mount point is specified, set the cs extension to be the mount point
 *  with '_'s replacing '/'s
 */
void
setext(char *ext, int n, char *p)
{
    int i, c;

    n--;
    for(i = 0; i < n; i++){
        c = p[i];
        if(c == 0)
            break;
        if(c == '/')
            c = '_';
        ext[i] = c;
    }
    ext[i] = 0;
}
@

<<function [[mountinit]]([[(networking/ndb/dns.c)]])>>=
void
mountinit(char *service, char *mntpt)
{
    int f;
    int p[2];
    char buf[32];

    if(pipe(p) < 0)
        abort(); /* "pipe failed" */;
    switch(rfork(RFFDG|RFPROC)){
    case 0:			/* child: hang around and (re)start main proc */
        close(p[1]);
        procsetname("%s restarter", mntpt);
        mfd[0] = mfd[1] = p[0];
        break;
    case -1:
        abort(); /* "fork failed\n" */;
    default:		/* parent: make /srv/dns, mount it, exit */
        close(p[0]);

        /*
         *  make a /srv/dns
         */
        f = create(service, 1, 0666);
        if(f < 0)
            abort(); /* service */;
        snprint(buf, sizeof buf, "%d", p[1]);
        if(write(f, buf, strlen(buf)) != strlen(buf))
            abort(); /* "write %s", service */;
        close(f);

        /*
         *  put ourselves into the file system
         *  it's too soon; we need 9p service running.
         */
//		if(mount(p[1], -1, mntpt, MAFTER, "") < 0)
//			dnslog("dns mount -a on %s failed: %r", mntpt);
        close(p[1]);
        _exits(0);
    }
}
@

<<function [[newfid]]([[(networking/ndb/dns.c)]])>>=
Mfile*
newfid(int fid, int needunused)
{
    Mfile *mf;

    lock(&mfalloc);
    for(mf = mfalloc.inuse; mf != nil; mf = mf->next)
        if(mf->fid == fid){
            unlock(&mfalloc);
            if(needunused)
                return nil;
            return mf;
        }
    mf = emalloc(sizeof(*mf));
    mf->fid = fid;
    mf->user = estrdup("dummy");
    mf->next = mfalloc.inuse;
    mfalloc.inuse = mf;
    unlock(&mfalloc);
    return mf;
}
@

<<function [[freefid]]([[(networking/ndb/dns.c)]])>>=
void
freefid(Mfile *mf)
{
    Mfile **l;

    lock(&mfalloc);
    for(l = &mfalloc.inuse; *l != nil; l = &(*l)->next)
        if(*l == mf){
            *l = mf->next;
            if(mf->user)
                free(mf->user);
            memset(mf, 0, sizeof *mf);	/* cause trouble */
            free(mf);
            unlock(&mfalloc);
            return;
        }
    unlock(&mfalloc);
    sysfatal("freeing unused fid");
}
@

<<function [[copyfid]]>>=
Mfile*
copyfid(Mfile *mf, int fid)
{
    Mfile *nmf;

    nmf = newfid(fid, 1);
    if(nmf == nil)
        return nil;
    nmf->fid = fid;
    free(nmf->user);			/* estrdup("dummy") */
    nmf->user = estrdup(mf->user);
    nmf->qid.type = mf->qid.type;
    nmf->qid.path = mf->qid.path;
    nmf->qid.vers = vers++;
    return nmf;
}
@

<<function [[newjob]]([[(networking/ndb/dns.c)]])>>=
Job*
newjob(void)
{
    Job *job;

    job = emalloc(sizeof *job);
    lock(&joblock);
    job->next = joblist;
    joblist = job;
    job->request.tag = -1;
    unlock(&joblock);
    return job;
}
@

<<function [[freejob]]([[(networking/ndb/dns.c)]])>>=
void
freejob(Job *job)
{
    Job **l;

    lock(&joblock);
    for(l = &joblist; *l; l = &(*l)->next)
        if(*l == job){
            *l = job->next;
            memset(job, 0, sizeof *job);	/* cause trouble */
            free(job);
            break;
        }
    unlock(&joblock);
}
@

<<function [[flushjob]]([[(networking/ndb/dns.c)]])>>=
void
flushjob(int tag)
{
    Job *job;

    lock(&joblock);
    for(job = joblist; job; job = job->next)
        if(job->request.tag == tag && job->request.type != Tflush){
            job->flushed = 1;
            break;
        }
    unlock(&joblock);
}
@

<<function [[io]]([[(networking/ndb/dns.c)]])>>=
void
io(void)
{
    volatile long n;
    volatile uchar mdata[IOHDRSZ + Maxfdata];
    Job *volatile job;
    Mfile *volatile mf;
    volatile Request req;

    memset(&req, 0, sizeof req);
    /*
     *  a slave process is sometimes forked to wait for replies from other
     *  servers.  The master process returns immediately via a longjmp
     *  through 'mret'.
     */
    if(setjmp(req.mret))
        putactivity(0);
    req.isslave = 0;
    stop = 0;
    while(!stop){
        procsetname("%d %s/dns Twrites of %d 9p rpcs read; %d alarms",
            stats.qrecvd9p, mntpt, stats.qrecvd9prpc, stats.alarms);
        n = read9pmsg(mfd[0], mdata, sizeof mdata);
        if(n<=0){
            dnslog("error reading 9P from %s: %r", mntpt);
            sleep(2000);	/* don't thrash after read error */
            return;
        }

        stats.qrecvd9prpc++;
        job = newjob();
        if(convM2S(mdata, n, &job->request) != n){
            freejob(job);
            continue;
        }
        mf = newfid(job->request.fid, 0);
        if(debug)
            dnslog("%F", &job->request);

        getactivity(&req, 0);
        req.aborttime = timems() + Maxreqtm;
        req.from = "9p";

        switch(job->request.type){
        default:
            warning("unknown request type %d", job->request.type);
            break;
        case Tversion:
            rversion(job);
            break;
        case Tauth:
            rauth(job);
            break;
        case Tflush:
            rflush(job);
            break;
        case Tattach:
            rattach(job, mf);
            break;
        case Twalk:
            rwalk(job, mf);
            break;
        case Topen:
            ropen(job, mf);
            break;
        case Tcreate:
            rcreate(job, mf);
            break;
        case Tread:
            rread(job, mf);
            break;
        case Twrite:
            /* &req is handed to dnresolve() */
            rwrite(job, mf, &req);
            break;
        case Tclunk:
            rclunk(job, mf);
            break;
        case Tremove:
            rremove(job, mf);
            break;
        case Tstat:
            rstat(job, mf);
            break;
        case Twstat:
            rwstat(job, mf);
            break;
        }

        freejob(job);

        /*
         *  slave processes die after replying
         */
        if(req.isslave){
            putactivity(0);
            _exits(0);
        }

        putactivity(0);
    }
    /* kill any udp server, notifier, etc. processes */
    postnote(PNGROUP, getpid(), "die");
    sleep(1000);
}
@

<<function [[rversion]]([[(networking/ndb/dns.c)]])>>=
void
rversion(Job *job)
{
    if(job->request.msize > IOHDRSZ + Maxfdata)
        job->reply.msize = IOHDRSZ + Maxfdata;
    else
        job->reply.msize = job->request.msize;
    if(strncmp(job->request.version, "9P2000", 6) != 0)
        sendmsg(job, "unknown 9P version");
    else{
        job->reply.version = "9P2000";
        sendmsg(job, 0);
    }
}
@

<<function [[rauth]]([[(networking/ndb/dns.c)]])>>=
void
rauth(Job *job)
{
    sendmsg(job, "dns: authentication not required");
}
@

<<function [[rflush]]([[(networking/ndb/dns.c)]])>>=
/*
 *  don't flush till all the slaves are done
 */
void
rflush(Job *job)
{
    flushjob(job->request.oldtag);
    sendmsg(job, 0);
}
@

<<function [[rattach]]([[(networking/ndb/dns.c)]])>>=
void
rattach(Job *job, Mfile *mf)
{
    if(mf->user != nil)
        free(mf->user);
    mf->user = estrdup(job->request.uname);
    mf->qid.vers = vers++;
    mf->qid.type = QTDIR;
    mf->qid.path = 0LL;
    job->reply.qid = mf->qid;
    sendmsg(job, 0);
}
@

<<function [[rwalk]]([[(networking/ndb/dns.c)]])>>=
char*
rwalk(Job *job, Mfile *mf)
{
    int i, nelems;
    char *err;
    char **elems;
    Mfile *nmf;
    Qid qid;

    err = 0;
    nmf = nil;
    elems  = job->request.wname;
    nelems = job->request.nwname;
    job->reply.nwqid = 0;

    if(job->request.newfid != job->request.fid){
        /* clone fid */
        nmf = copyfid(mf, job->request.newfid);
        if(nmf == nil){
            err = "clone bad newfid";
            goto send;
        }
        mf = nmf;
    }
    /* else nmf will be nil */

    qid = mf->qid;
    if(nelems > 0)
        /* walk fid */
        for(i=0; i<nelems && i<MAXWELEM; i++){
            if((qid.type & QTDIR) == 0){
                err = "not a directory";
                break;
            }
            if (strcmp(elems[i], "..") == 0 ||
                strcmp(elems[i], ".") == 0){
                qid.type = QTDIR;
                qid.path = Qdir;
Found:
                job->reply.wqid[i] = qid;
                job->reply.nwqid++;
                continue;
            }
            if(strcmp(elems[i], "dns") == 0){
                qid.type = QTFILE;
                qid.path = Qdns;
                goto Found;
            }
            err = "file does not exist";
            break;
        }

send:
    if(nmf != nil && (err!=nil || job->reply.nwqid<nelems))
        freefid(nmf);
    if(err == nil)
        mf->qid = qid;
    sendmsg(job, err);
    return err;
}
@

<<function [[ropen]]([[(networking/ndb/dns.c)]])>>=
void
ropen(Job *job, Mfile *mf)
{
    int mode;
    char *err;

    err = 0;
    mode = job->request.mode;
    if(mf->qid.type & QTDIR)
        if(mode)
            err = "permission denied";
    job->reply.qid = mf->qid;
    job->reply.iounit = 0;
    sendmsg(job, err);
}
@

<<function [[rcreate]]([[(networking/ndb/dns.c)]])>>=
void
rcreate(Job *job, Mfile *mf)
{
    USED(mf);
    sendmsg(job, "creation permission denied");
}
@

<<function [[rread]]([[(networking/ndb/dns.c)]])>>=
void
rread(Job *job, Mfile *mf)
{
    int i, n;
    long clock;
    ulong cnt;
    vlong off;
    char *err;
    uchar buf[Maxfdata];
    Dir dir;

    n = 0;
    err = nil;
    off = job->request.offset;
    cnt = job->request.count;
    *buf = '\0';
    job->reply.data = (char*)buf;
    if(mf->qid.type & QTDIR){
        clock = time(nil);
        if(off == 0){
            memset(&dir, 0, sizeof dir);
            dir.name = "dns";
            dir.qid.type = QTFILE;
            dir.qid.vers = vers;
            dir.qid.path = Qdns;
            dir.mode = 0666;
            dir.length = 0;
            dir.uid = dir.gid = dir.muid = mf->user;
            dir.atime = dir.mtime = clock;		/* wrong */
            n = convD2M(&dir, buf, sizeof buf);
        }
    } else if (off < 0)
        err = "negative read offset";
    else {
        /* first offset will always be zero */
        for(i = 1; i <= mf->nrr; i++)
            if(mf->rr[i] > off)
                break;
        if(i <= mf->nrr) {
            if(off + cnt > mf->rr[i])
                n = mf->rr[i] - off;
            else
                n = cnt;
            assert(n >= 0);
            job->reply.data = mf->reply + off;
        }
    }
    job->reply.count = n;
    sendmsg(job, err);
}
@

<<function [[rwrite]]>>=
void
rwrite(Job *job, Mfile *mf, Request *req)
{
    int rooted, wantsav, send;
    ulong cnt;
    char *err, *p, *atype;
    char errbuf[ERRMAX];

    err = nil;
    cnt = job->request.count;
    send = 1;
    if(mf->qid.type & QTDIR)
        err = "can't write directory";
    else if (job->request.offset != 0)
        err = "writing at non-zero offset";
    else if(cnt >= Maxrequest)
        err = "request too long";
    else
        send = 0;
    if (send)
        goto send;

    job->request.data[cnt] = 0;
    if(cnt > 0 && job->request.data[cnt-1] == '\n')
        job->request.data[cnt-1] = 0;

    /*
     *  special commands
     */
//	dnslog("rwrite got: %s", job->request.data);
    send = 1;
    if(strcmp(job->request.data, "age")==0){
        dnslog("dump, age & dump forced");
        dndump("/lib/ndb/dnsdump1");
        dnforceage();
        dndump("/lib/ndb/dnsdump2");
    } else if(strcmp(job->request.data, "debug")==0)
        debug ^= 1;
    else if(strcmp(job->request.data, "dump")==0)
        dndump("/lib/ndb/dnsdump");
    else if(strcmp(job->request.data, "poolcheck")==0)
        poolcheck(mainmem);
    else if(strcmp(job->request.data, "refresh")==0)
        needrefresh = 1;
    else if(strcmp(job->request.data, "restart")==0)
        stop = 1;
    else if(strcmp(job->request.data, "stats")==0)
        dnstats("/lib/ndb/dnsstats");
    else if(strncmp(job->request.data, "target ", 7)==0){
        target = atol(job->request.data + 7);
        dnslog("target set to %ld", target);
    } else
        send = 0;
    if (send)
        goto send;

    /*
     *  kill previous reply
     */
    mf->nrr = 0;
    mf->rr[0] = 0;

    /*
     *  break up request (into a name and a type)
     */
    atype = strchr(job->request.data, ' ');
    if(atype == 0){
        snprint(errbuf, sizeof errbuf, "illegal request %s",
            job->request.data);
        err = errbuf;
        goto send;
    } else
        *atype++ = 0;

    /*
     *  tracing request
     */
    if(strcmp(atype, "trace") == 0){
        if(trace)
            free(trace);
        if(*job->request.data)
            trace = estrdup(job->request.data);
        else
            trace = 0;
        goto send;
    }

    /* normal request: domain [type] */
    stats.qrecvd9p++;
    mf->type = rrtype(atype);
    if(mf->type < 0){
        snprint(errbuf, sizeof errbuf, "unknown type %s", atype);
        err = errbuf;
        goto send;
    }

    p = atype - 2;
    if(p >= job->request.data && *p == '.'){
        rooted = 1;
        *p = 0;
    } else
        rooted = 0;

    p = job->request.data;
    if(*p == '!'){
        wantsav = 1;
        p++;
    } else
        wantsav = 0;

    err = lookupqueryold(job, mf, req, errbuf, p, wantsav, rooted);
send:
    dncheck(0, 1);
    job->reply.count = cnt;
    sendmsg(job, err);
}
@

<<function [[lookupqueryold]]>>=
/*
 * dnsdebug calls
 *	rr = dnresolve(buf, Cin, type, &req, 0, 0, Recurse, rooted, 0);
 * which generates a UDP query, which eventually calls
 *	dnserver(&reqmsg, &repmsg, &req, buf, rcode);
 * which calls
 *	rp = dnresolve(name, Cin, type, req, &mp->an, 0, recurse, 1, 0);
 *
 * but here we just call dnresolve directly.
 */
static char *
lookupqueryold(Job *job, Mfile *mf, Request *req, char *errbuf, char *p,
    int wantsav, int rooted)
{
    int status;
    RR *rp, *neg;

    dncheck(0, 1);
    status = Rok;
    rp = dnresolve(p, Cin, mf->type, req, 0, 0, Recurse, rooted, &status);

    dncheck(0, 1);
    lock(&dnlock);
    neg = rrremneg(&rp);
    if(neg){
        status = neg->negrcode;
        rrfreelist(neg);
    }
    unlock(&dnlock);

    return respond(job, mf, rp, errbuf, status, wantsav);
}
@

<<function [[respond]]>>=
static char *
respond(Job *job, Mfile *mf, RR *rp, char *errbuf, int status, int wantsav)
{
    long n;
    RR *tp;

    if(rp == nil)
        switch(status){
        case Rname:
            return "name does not exist";
        case Rserver:
            return "dns failure";
        case Rok:
        default:
            snprint(errbuf, ERRMAX,
                "resource does not exist; negrcode %d", status);
            return errbuf;
        }

    lock(&joblock);
    if(!job->flushed){
        /* format data to be read later */
        n = 0;
        mf->nrr = 0;
        for(tp = rp; mf->nrr < Maxrrr-1 && n < Maxreply && tp &&
            tsame(mf->type, tp->type); tp = tp->next){
            mf->rr[mf->nrr++] = n;
            if(wantsav)
                n += snprint(mf->reply+n, Maxreply-n, "%Q", tp);
            else
                n += snprint(mf->reply+n, Maxreply-n, "%R", tp);
        }
        mf->rr[mf->nrr] = n;
    }
    unlock(&joblock);
    rrfreelist(rp);
    return nil;
}
@

<<function [[lookupquerynew]]>>=
/* simulate what dnsudpserver does */
static char *
lookupquerynew(Job *job, Mfile *mf, Request *req, char *errbuf, char *p,
    int wantsav, int)
{
    char *err;
    uchar buf[Udphdrsize + Maxudp + 1024];
    DNSmsg *mp;
    DNSmsg repmsg;
    RR *rp;

    dncheck(0, 1);

    memset(&repmsg, 0, sizeof repmsg);
    rp = rralloc(mf->type);
    rp->owner = dnlookup(p, Cin, 1);
    mp = newdnsmsg(rp, Frecurse|Oquery, (ushort)rand());

    dnserver(mp, &repmsg, req, buf, Rok);

    freeanswers(mp);
    err = respond(job, mf, repmsg.an, errbuf, Rok, wantsav);
    repmsg.an = nil;		/* freed above */
    freeanswers(&repmsg);
    return err;
}
@

<<function [[rclunk]]([[(networking/ndb/dns.c)]])>>=
void
rclunk(Job *job, Mfile *mf)
{
    freefid(mf);
    sendmsg(job, 0);
}
@

<<function [[rremove]]([[(networking/ndb/dns.c)]])>>=
void
rremove(Job *job, Mfile *mf)
{
    USED(mf);
    sendmsg(job, "remove permission denied");
}
@

<<function [[rstat]]([[(networking/ndb/dns.c)]])>>=
void
rstat(Job *job, Mfile *mf)
{
    Dir dir;
    uchar buf[IOHDRSZ+Maxfdata];

    memset(&dir, 0, sizeof dir);
    if(mf->qid.type & QTDIR){
        dir.name = ".";
        dir.mode = DMDIR|0555;
    } else {
        dir.name = "dns";
        dir.mode = 0666;
    }
    dir.qid = mf->qid;
    dir.length = 0;
    dir.uid = dir.gid = dir.muid = mf->user;
    dir.atime = dir.mtime = time(nil);
    job->reply.nstat = convD2M(&dir, buf, sizeof buf);
    job->reply.stat = buf;
    sendmsg(job, 0);
}
@

<<function [[rwstat]]([[(networking/ndb/dns.c)]])>>=
void
rwstat(Job *job, Mfile *mf)
{
    USED(mf);
    sendmsg(job, "wstat permission denied");
}
@

<<function [[sendmsg]]([[(networking/ndb/dns.c)]])>>=
void
sendmsg(Job *job, char *err)
{
    int n;
    uchar mdata[IOHDRSZ + Maxfdata];
    char ename[ERRMAX];

    if(err){
        job->reply.type = Rerror;
        snprint(ename, sizeof ename, "dns: %s", err);
        job->reply.ename = ename;
    }else
        job->reply.type = job->request.type+1;
    job->reply.tag = job->request.tag;
    n = convS2M(&job->reply, mdata, sizeof mdata);
    if(n == 0){
        warning("sendmsg convS2M of %F returns 0", &job->reply);
        abort();
    }
    lock(&joblock);
    if(job->flushed == 0)
        if(write(mfd[1], mdata, n)!=n)
            sysfatal("mount write");
    unlock(&joblock);
    if(debug)
        dnslog("%F %d", &job->reply, n);
}
@

<<function [[logreply]]>>=
/*
 *  the following varies between dnsdebug and dns
 */
void
logreply(int id, uchar *addr, DNSmsg *mp)
{
    RR *rp;

    dnslog("%d: rcvd %I flags:%s%s%s%s%s", id, addr,
        mp->flags & Fauth? " auth": "",
        mp->flags & Ftrunc? " trunc": "",
        mp->flags & Frecurse? " rd": "",
        mp->flags & Fcanrec? " ra": "",
        (mp->flags & (Fauth|Rmask)) == (Fauth|Rname)? " nx": "");
    for(rp = mp->qd; rp != nil; rp = rp->next)
        dnslog("%d: rcvd %I qd %s", id, addr, rp->owner->name);
    for(rp = mp->an; rp != nil; rp = rp->next)
        dnslog("%d: rcvd %I an %R", id, addr, rp);
    for(rp = mp->ns; rp != nil; rp = rp->next)
        dnslog("%d: rcvd %I ns %R", id, addr, rp);
    for(rp = mp->ar; rp != nil; rp = rp->next)
        dnslog("%d: rcvd %I ar %R", id, addr, rp);
}
@

<<function [[logsend]]>>=
void
logsend(int id, int subid, uchar *addr, char *sname, char *rname, int type)
{
    char buf[12];

    dnslog("[%d] %d.%d: sending to %I/%s %s %s",
        getpid(), id, subid, addr, sname, rname,
        rrname(type, buf, sizeof buf));
}
@

<<function [[getdnsservers]]>>=
RR*
getdnsservers(int class)
{
    return dnsservers(class);
}
@


%-------------------------------------------------------------

<<networking/ndb/dns.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <fcall.h>
#include <bio.h>
#include <ctype.h>
#include <ip.h>
#include <pool.h>
#include "dns.h"

<<enum [[_anon_ (networking/ndb/dns.c)]]>>

typedef struct Mfile	Mfile;
typedef struct Job	Job;
typedef struct Network	Network;

extern	ulong	start;

<<global [[vers]]([[(networking/ndb/dns.c)]])>>

<<global [[stop]]>>

<<struct [[Mfile]]([[(networking/ndb/dns.c)]])>>

<<struct [[Job]]([[(networking/ndb/dns.c)]])>>
<<global [[joblock]]([[(networking/ndb/dns.c)]])>>
<<global [[joblist]]([[(networking/ndb/dns.c)]])>>

<<global [[mfalloc]]>>

<<global [[cfg]]>>
<<global [[debug]]([[(networking/ndb/dns.c)]])>>
<<global [[ipaddr]]([[(networking/ndb/dns.c)]])>>
<<global [[maxage]]>>
<<global [[mfd]]([[(networking/ndb/dns.c)]])>>
<<global [[needrefresh]]>>
<<global [[now]]([[(networking/ndb/dns.c)]])>>
<<global [[nowns]]>>
<<global [[sendnotifies]]>>
<<global [[testing]]>>
<<global [[trace]]>>
<<global [[traceactivity]]>>
<<global [[zonerefreshprogram]]>>

<<global [[logfile]]([[(networking/ndb/dns.c)]])>>
<<global [[dbfile]]([[(networking/ndb/dns.c)]])>>
<<global [[mntpt]]([[(networking/ndb/dns.c)]])>>

int	addforwtarg(char *);
int	fillreply(Mfile*, int);
void	freejob(Job*);
void	io(void);
void	mountinit(char*, char*);
Job*	newjob(void);
void	rattach(Job*, Mfile*);
void	rauth(Job*);
void	rclunk(Job*, Mfile*);
void	rcreate(Job*, Mfile*);
void	rflush(Job*);
void	ropen(Job*, Mfile*);
void	rread(Job*, Mfile*);
void	rremove(Job*, Mfile*);
void	rstat(Job*, Mfile*);
void	rversion(Job*);
char*	rwalk(Job*, Mfile*);
void	rwrite(Job*, Mfile*, Request*);
void	rwstat(Job*, Mfile*);
void	sendmsg(Job*, char*);
void	setext(char*, int, char*);

static char *lookupqueryold(Job*, Mfile*, Request*, char*, char*, int, int);
static char *lookupquerynew(Job*, Mfile*, Request*, char*, char*, int, int);
static char *respond(Job*, Mfile*, RR*, char*, int, int);

<<function [[usage]]([[(networking/ndb/dns.c)]])>>

<<function [[justremount]]>>

<<function [[main]]([[(networking/ndb/dns.c)]])>>

<<function [[setext]]([[(networking/ndb/dns.c)]])>>

<<function [[mountinit]]([[(networking/ndb/dns.c)]])>>

<<function [[newfid]]([[(networking/ndb/dns.c)]])>>

<<function [[freefid]]([[(networking/ndb/dns.c)]])>>

<<function [[copyfid]]>>

<<function [[newjob]]([[(networking/ndb/dns.c)]])>>

<<function [[freejob]]([[(networking/ndb/dns.c)]])>>

<<function [[flushjob]]([[(networking/ndb/dns.c)]])>>

<<function [[io]]([[(networking/ndb/dns.c)]])>>

<<function [[rversion]]([[(networking/ndb/dns.c)]])>>

<<function [[rauth]]([[(networking/ndb/dns.c)]])>>

<<function [[rflush]]([[(networking/ndb/dns.c)]])>>

<<function [[rattach]]([[(networking/ndb/dns.c)]])>>

<<function [[rwalk]]([[(networking/ndb/dns.c)]])>>

<<function [[ropen]]([[(networking/ndb/dns.c)]])>>

<<function [[rcreate]]([[(networking/ndb/dns.c)]])>>

<<function [[rread]]([[(networking/ndb/dns.c)]])>>

<<function [[rwrite]]>>

<<function [[lookupqueryold]]>>

<<function [[respond]]>>

<<function [[lookupquerynew]]>>

<<function [[rclunk]]([[(networking/ndb/dns.c)]])>>

<<function [[rremove]]([[(networking/ndb/dns.c)]])>>

<<function [[rstat]]([[(networking/ndb/dns.c)]])>>

<<function [[rwstat]]([[(networking/ndb/dns.c)]])>>

<<function [[sendmsg]]([[(networking/ndb/dns.c)]])>>

<<function [[logreply]]>>

<<function [[logsend]]>>

<<function [[getdnsservers]]>>
@


\subsection*{[[networking/ndb/dns.h]]}

<<macro [[NS2MS]]>>=
#define NS2MS(ns) ((ns) / 1000000L)
@

<<macro [[S2MS]]>>=
#define S2MS(s)   ((s)  * 1000LL)
@

<<macro [[timems]]>>=
#define timems()	NS2MS(nsec())
@

<<enum [[_anon_ (networking/ndb/dns.h)]]>>=
enum
{
    /* RR types; see: http://www.iana.org/assignments/dns-parameters */
    Ta=		1,
    Tns=		2,
    Tmd=		3,
    Tmf=		4,
    Tcname=		5,
    Tsoa=		6,
    Tmb=		7,
    Tmg=		8,
    Tmr=		9,
    Tnull=		10,
    Twks=		11,
    Tptr=		12,
    Thinfo=		13,
    Tminfo=		14,
    Tmx=		15,
    Ttxt=		16,
    Trp=		17,
    Tafsdb=		18,
    Tx25=		19,
    Tisdn=		20,
    Trt=		21,
    Tnsap=		22,
    Tnsapptr=	23,
    Tsig=		24,
    Tkey=		25,
    Tpx=		26,
    Tgpos=		27,
    Taaaa=		28,
    Tloc=		29,
    Tnxt=		30,
    Teid=		31,
    Tnimloc=	32,
    Tsrv=		33,
    Tatma=		34,
    Tnaptr=		35,
    Tkx=		36,
    Tcert=		37,
    Ta6=		38,
    Tdname=		39,
    Tsink=		40,
    Topt=		41,
    Tapl=		42,
    Tds=		43,
    Tsshfp=		44,
    Tipseckey=	45,
    Trrsig=		46,
    Tnsec=		47,
    Tdnskey=	48,

    Tspf=		99,
    Tuinfo=		100,
    Tuid=		101,
    Tgid=		102,
    Tunspec=	103,

    /* query types (all RR types are also queries) */
    Ttkey=	249,	/* transaction key */
    Ttsig=	250,	/* transaction signature */
    Tixfr=	251,	/* incremental zone transfer */
    Taxfr=	252,	/* zone transfer */
    Tmailb=	253,	/* { Tmb, Tmg, Tmr } */
    Tmaila= 254,	/* obsolete */
    Tall=	255,	/* all records */

    /* classes */
    Csym=	0,	/* internal symbols */
    Cin=	1,	/* internet */
    Ccs,		/* CSNET (obsolete) */
    Cch,		/* Chaos net */
    Chs,		/* Hesiod (?) */

    /* class queries (all class types are also queries) */
    Call=	255,	/* all classes */

    /* opcodes */
    Oquery=		0<<11,		/* normal query */
    Oinverse=	1<<11,		/* inverse query (retired) */
    Ostatus=	2<<11,		/* status request */
    Onotify=	4<<11,		/* notify slaves of updates */
    Oupdate=	5<<11,
    Omask=		0xf<<11,	/* mask for opcode */

    /* response codes */
    Rok=		0,
    Rformat=	1,	/* format error */
    Rserver=	2,	/* server failure (e.g. no answer from something) */
    Rname=		3,	/* bad name */
    Runimplimented=	4,	/* unimplemented */
    Rrefused=	5,	/* we don't like you */
    Ryxdomain=	6,	/* name exists when it should not */
    Ryxrrset=	7,	/* rr set exists when it should not */
    Rnxrrset=	8,	/* rr set that should exist does not */
    Rnotauth=	9,	/* not authoritative */
    Rnotzone=	10,	/* name not in zone */
    Rbadvers=	16,	/* bad opt version */
/*	Rbadsig=	16, */	/* also tsig signature failure */
    Rbadkey=	17,		/* key not recognized */
    Rbadtime=	18,		/* signature out of time window */
    Rbadmode=	19,		/* bad tkey mode */
    Rbadname=	20,		/* duplicate key name */
    Rbadalg=	21,		/* algorithm not supported */
    Rmask=		0x1f,	/* mask for response */
    Rtimeout=	1<<5,	/* timeout sending (for internal use only) */

    /* bits in flag word (other than opcode and response) */
    Fresp=		1<<15,	/* message is a response */
    Fauth=		1<<10,	/* true if an authoritative response */
    Ftrunc=		1<<9,	/* truncated message */
    Frecurse=	1<<8,	/* request recursion */
    Fcanrec=	1<<7,	/* server can recurse */

    Domlen=		256,	/* max domain name length (with NULL) */
    Labellen=	64,	/* max domain label length (with NULL) */
    Strlen=		256,	/* max string length (with NULL) */

    /* time to live values (in seconds) */
    Min=		60,
    Hour=		60*Min,		/* */
    Day=		24*Hour,	/* Ta, Tmx */
    Week=		7*Day,		/* Tsoa, Tns */
    Year=		52*Week,
    DEFTTL=		Day,

    /* reserved time (can't be timed out earlier) */
    Reserved=	5*Min,

    /* packet sizes */
    Maxudp=		512,	/* maximum bytes per udp message sent */
    Maxudpin=	2048,	/* maximum bytes per udp message rcv'd */

    /* length of domain name hash table */
    HTLEN= 		4*1024,

    Maxpath=	128,	/* size of mntpt */
    Maxlcks=	10,	/* max. query-type locks per domain name */

    RRmagic=	0xdeadbabe,
    DNmagic=	0xa110a110,

    /* parallelism: tune; was 32; allow lots */
    Maxactive=	250,

    /* tune; was 60*1000; keep it short */
    Maxreqtm=	8*1000,	/* max. ms to process a request */

    Notauthoritative = 0,
    Authoritative,
};
@

<<struct [[Request]]([[(networking/ndb/dns.h)]])>>=
/*
 *  a structure to track a request and any slave process handling it
 */
struct Request
{
    int	isslave;	/* pid of slave */
    uvlong	aborttime;	/* time in ms at which we give up */
    jmp_buf	mret;		/* where master jumps to after starting a slave */
    int	id;
    char	*from;		/* who asked us? */
};
@

<<struct [[Querylck]]>>=
struct Querylck
{
    QLock;
//	Rendez;
    Ref;
};
@

<<struct [[DN]]>>=
/*
 *  a domain name
 */
struct DN
{
    DN	*next;		/* hash collision list */
    ulong	magic;
    char	*name;		/* owner */
    RR	*rr;		/* resource records off this name */
    ulong	referenced;	/* time last referenced */
    ulong	lookuptime;	/* last time we tried to get a better value */
    /* refs was `char' but we've seen refs > 120, so go whole hog */
    ulong	refs;		/* for mark and sweep */
    ulong	ordinal;
    ushort	class;		/* RR class */
    uchar	keep;		/* flag: never age this name */
    uchar	respcode;	/* response code */
/* was:	char	nonexistent; /* true if we get an authoritative nx for this domain */
    /* permit only 1 query per (domain name, type) at a time */
    Querylck querylck[Maxlcks];
};
@

<<struct [[Block]]>>=
/*
 *  security info
 */
struct Block
{
    int	dlen;
    uchar	*data;
};
@

<<struct [[Key]]>>=
struct Key
{
    int	flags;
    int	proto;
    int	alg;
    Block;
};
@

<<struct [[Cert]]>>=
struct Cert
{
    int	type;
    int	tag;
    int	alg;
    Block;
};
@

<<struct [[Sig]]>>=
struct Sig
{
    Cert;
    int	labels;
    ulong	ttl;
    ulong	exp;
    ulong	incep;
    DN	*signer;
};
@

<<struct [[Null]]>>=
struct Null
{
    Block;
};
@

<<struct [[Txt]]>>=
/*
 *  text strings
 */
struct Txt
{
    Txt	*next;
    char	*p;
};
@

<<struct [[RR]]>>=
/*
 *  an unpacked resource record
 */
struct RR
{
    RR	*next;
    ulong	magic;
    DN	*owner;		/* domain that owns this resource record */
    uintptr	pc;		/* for tracking memory allocation */
    ulong	ttl;		/* time to live to be passed on */
    ulong	expire;		/* time this entry expires locally */
    ulong	marker;		/* used locally when scanning rrlists */
    ushort	type;		/* RR type */
    ushort	query;		/* query type is in response to */
    uchar	auth;		/* flag: authoritative */
    uchar	db;		/* flag: from database */
    uchar	cached;		/* flag: rr in cache */
    uchar	negative;	/* flag: this is a cached negative response */

    union {			/* discriminated by negative & type */
        DN	*negsoaowner;	/* soa for cached negative response */
        DN	*host;	/* hostname - soa, cname, mb, md, mf, mx, ns, srv */
        DN	*cpu;	/* cpu type - hinfo */
        DN	*mb;	/* mailbox - mg, minfo */
        DN	*ip;	/* ip address - a, aaaa */
        DN	*rp;	/* rp arg - rp */
        uintptr	arg0;	/* arg[01] are compared to find dups in dn.c */
    };
    union {			/* discriminated by negative & type */
        int	negrcode; /* response code for cached negative resp. */
        DN	*rmb;	/* responsible maibox - minfo, soa, rp */
        DN	*ptr;	/* pointer to domain name - ptr */
        DN	*os;	/* operating system - hinfo */
        ulong	pref;	/* preference value - mx */
        ulong	local;	/* ns served from local database - ns */
        ushort	port;	/* - srv */
        uintptr	arg1;	/* arg[01] are compared to find dups in dn.c */
    };
    union {			/* discriminated by type */
        SOA	*soa;	/* soa timers - soa */
        Key	*key;
        Cert	*cert;
        Sig	*sig;
        Null	*null;
        Txt	*txt;
        Srv	*srv;
    };
};
@

<<struct [[Server]]>>=
/*
 *  list of servers
 */
struct Server
{
    Server	*next;
    char	*name;
};
@

<<struct [[SOA]]>>=
/*
 *  timers for a start-of-authority record.  all ulongs are in seconds.
 */
struct SOA
{
    ulong	serial;		/* zone serial # */
    ulong	refresh;	/* zone refresh interval */
    ulong	retry;		/* zone retry interval */
    ulong	expire;		/* time to expiration */
    ulong	minttl;		/* min. time to live for any entry */

    Server	*slaves;	/* slave servers */
};
@

<<struct [[Srv]]>>=
/*
 * srv (service location) record (rfc2782):
 * _service._proto.name ttl class(IN) 'SRV' priority weight port target
 */
struct Srv
{
    ushort	pri;
    ushort	weight;
};
@

<<struct [[Rrlist]]>>=
struct Rrlist
{
    int	count;
    RR	*rrs;
};
@

<<struct [[DNSmsg]]>>=
/*
 *  domain messages
 */
struct DNSmsg
{
    ushort	id;
    int	flags;
    int	qdcount;	/* questions */
    RR 	*qd;
    int	ancount;	/* answers */
    RR	*an;
    int	nscount;	/* name servers */
    RR	*ns;
    int	arcount;	/* hints */
    RR	*ar;
};
@

<<struct [[Area]]>>=
/*
 *  definition of local area for dblookup
 */
struct Area
{
    Area	*next;

    int	len;		/* strlen(area->soarr->owner->name) */
    RR	*soarr;		/* soa defining this area */
    int	neednotify;
    int	needrefresh;
};
@

<<struct [[Cfg]]>>=
struct Cfg {
    int	cachedb;
    int	resolver;
    int	justforw;	/* flag: pure resolver, just forward queries */
    int	serve;		/* flag: serve udp queries */
    int	inside;
    int	straddle;
};
@

<<global [[stats]]>>=
Stats stats;
@

<<enum [[_anon_ (networking/ndb/dns.h)2]]>>=
enum
{
    Recurse,
    Dontrecurse,
    NOneg,
    OKneg,
};
@


%-------------------------------------------------------------

<<networking/ndb/dns.h>>=
#include <thread.h>		/* for Ref */

<<macro [[NS2MS]]>>
<<macro [[S2MS]]>>

<<macro [[timems]]>>

typedef struct Ndbtuple Ndbtuple;

<<enum [[_anon_ (networking/ndb/dns.h)]]>>

typedef struct Area	Area;
typedef struct Block	Block;
typedef struct Cert	Cert;
typedef struct DN	DN;
typedef struct DNSmsg	DNSmsg;
typedef struct Key	Key;
typedef struct Null	Null;
typedef struct RR	RR;
typedef struct Request	Request;
typedef struct SOA	SOA;
typedef struct Server	Server;
typedef struct Sig	Sig;
typedef struct Srv	Srv;
typedef struct Txt	Txt;

<<struct [[Request]]([[(networking/ndb/dns.h)]])>>

typedef struct Querylck Querylck;
<<struct [[Querylck]]>>

<<struct [[DN]]>>

<<struct [[Block]]>>
<<struct [[Key]]>>
<<struct [[Cert]]>>
<<struct [[Sig]]>>
<<struct [[Null]]>>

<<struct [[Txt]]>>

<<struct [[RR]]>>

<<struct [[Server]]>>

<<struct [[SOA]]>>

<<struct [[Srv]]>>

typedef struct Rrlist Rrlist;
<<struct [[Rrlist]]>>

<<struct [[DNSmsg]]>>

<<struct [[Area]]>>

typedef struct Cfg Cfg;
<<struct [[Cfg]]>>

/* (udp) query stats */
typedef struct {
    QLock;
    ulong	slavehiwat;	/* procs */
    ulong	qrecvd9p;	/* query counts */
    ulong	qrecvdudp;
    ulong	qsent;
    ulong	qrecvd9prpc;	/* packet count */
    ulong	alarms;
    /* reply times by count */
    ulong	under10ths[3*10+2];	/* under n*0.1 seconds, n is index */
    ulong	tmout;
    ulong	tmoutcname;
    ulong	tmoutv6;

    ulong	answinmem;	/* answers in memory */
    ulong	negans;		/* negative answers received */
    ulong	negserver;	/* neg ans with Rserver set */
    ulong	negbaddeleg;	/* neg ans with bad delegations */
    ulong	negbdnoans;	/* ⋯ and no answers */
    ulong	negnorname;	/* neg ans with no Rname set */
    ulong	negcached;	/* neg ans cached */
} Stats;

<<global [[stats]]>>

<<enum [[_anon_ (networking/ndb/dns.h)2]]>>

extern Cfg	cfg;
extern char	*dbfile;
extern int	debug;
extern Area	*delegated;
extern char	*logfile;
extern int	maxage;		/* age of oldest entry in cache (secs) */
extern char	mntpt[];
extern int	needrefresh;
extern int	norecursion;
extern ulong	now;		/* time base */
extern vlong	nowns;
extern Area	*owned;
extern int	sendnotifies;
extern ulong	target;
extern int	testing;	/* test cache whenever removing a DN */
extern char	*trace;
extern int	traceactivity;
extern char	*zonerefreshprogram;

#pragma	varargck	type	"R"	RR*
#pragma	varargck	type	"Q"	RR*


/* dn.c */
extern char	*rrtname[];
extern char	*rname[];
extern unsigned	nrname;
extern char	*opname[];
extern Lock	dnlock;

void	abort(); /* char*, ... */;
void	addserver(Server**, char*);
Server*	copyserverlist(Server*);
void	db2cache(int);
void	dnage(DN*);
void	dnageall(int);
void	dnagedb(void);
void	dnageallnever(void);
void	dnagenever(DN *, int);
void	dnauthdb(void);
void	dncheck(void*, int);
void	dndump(char*);
void	dnget(void);
void	dninit(void);
DN*	dnlookup(char*, int, int);
void	dnptr(uchar*, uchar*, char*, int, int, int);
void	dnpurge(void);
void	dnput(void);
void	dnslog(char*, ...);
void	dnstats(char *file);
void*	emalloc(int);
char*	estrdup(char*);
void	freeanswers(DNSmsg *mp);
void	freeserverlist(Server*);
int	getactivity(Request*, int);
Area*	inmyarea(char*);
void	putactivity(int);
RR*	randomize(RR*);
RR*	rralloc(int);
void	rrattach(RR*, int);
int	rravfmt(Fmt*);
RR*	rrcat(RR**, RR*);
RR**	rrcopy(RR*, RR**);
int	rrfmt(Fmt*);
void	rrfree(RR*);
void	rrfreelist(RR*);
RR*	rrlookup(DN*, int, int);
char*	rrname(int, char*, int);
RR*	rrremneg(RR**);
RR*	rrremtype(RR**, int);
int	rrsupported(int);
int	rrtype(char*);
void	slave(Request*);
int	subsume(char*, char*);
int	tsame(int, int);
void	unique(RR*);
void	warning(char*, ...);

/* dnarea.c */
void	refresh_areas(Area*);
void	freearea(Area**);
void	addarea(DN *dp, RR *rp, Ndbtuple *t);

/* dblookup.c */
int	baddelegation(RR*, RR*, uchar*);
RR*	dbinaddr(DN*, int);
RR*	dblookup(char*, int, int, int, int);
void	dnforceage(void);
RR*	dnsservers(int);
RR*	domainlist(int);
int	insideaddr(char *dom);
int	insidens(uchar *ip);
int	myaddr(char *addr);
int	opendatabase(void);
uchar*	outsidens(int);

/* dns.c */
char*	walkup(char*);
RR*	getdnsservers(int);
void	logreply(int, uchar*, DNSmsg*);
void	logsend(int, int, uchar*, char*, char*, int);
void	procsetname(char *fmt, ...);

/* dnresolve.c */
RR*	dnresolve(char*, int, int, Request*, RR**, int, int, int, int*);
int	udpport(char *);
int	mkreq(DN *dp, int type, uchar *buf, int flags, ushort reqno);
int	seerootns(void);
void	initdnsmsg(DNSmsg *mp, RR *rp, int flags, ushort reqno);
DNSmsg*	newdnsmsg(RR *rp, int flags, ushort reqno);

/* dnserver.c */
void	dnserver(DNSmsg*, DNSmsg*, Request*, uchar *, int);
void	dnudpserver(char*);
void	dntcpserver(char*);

/* dnnotify.c */
void	dnnotify(DNSmsg*, DNSmsg*, Request*);
void	notifyproc(void);

/* convDNS2M.c */
int	convDNS2M(DNSmsg*, uchar*, int);

/* convM2DNS.c */
char*	convM2DNS(uchar*, int, DNSmsg*, int*);

#pragma varargck argpos dnslog 1
@


\subsection*{[[networking/ndb/dnsdebug.c]]}

<<enum [[_anon_ (networking/ndb/dnsdebug.c)]]>>=
enum {
    Maxrequest=		128,
};
@

<<global [[cfg]]([[(networking/ndb/dnsdebug.c)]])>>=
Cfg cfg;
@

<<global [[servername]]>>=
static char *servername;
@

<<global [[serverrr]]>>=
static RR *serverrr;
@

<<global [[serveraddrs]]>>=
static RR *serveraddrs;
@

<<global [[dbfile]]([[(networking/ndb/dnsdebug.c)]])>>=
char	*dbfile;
@

<<global [[debug]]([[(networking/ndb/dnsdebug.c)]])>>=
int	debug;
@

<<global [[ipaddr]]([[(networking/ndb/dnsdebug.c)]])>>=
uchar	ipaddr[IPaddrlen];	/* my ip address */
@

<<global [[logfile]]([[(networking/ndb/dnsdebug.c)]])>>=
char	*logfile = "dnsdebug";
@

<<global [[maxage]]([[(networking/ndb/dnsdebug.c)]])>>=
int	maxage  = 60*60;
@

<<global [[mntpt]]([[(networking/ndb/dnsdebug.c)]])>>=
char	mntpt[Maxpath];
@

<<global [[needrefresh]]([[(networking/ndb/dnsdebug.c)]])>>=
int	needrefresh;
@

<<global [[now]]([[(networking/ndb/dnsdebug.c)]])>>=
ulong	now;
@

<<global [[nowns]]([[(networking/ndb/dnsdebug.c)]])>>=
vlong	nowns;
@

<<global [[testing]]([[(networking/ndb/dnsdebug.c)]])>>=
int	testing;
@

<<global [[trace]]([[(networking/ndb/dnsdebug.c)]])>>=
char	*trace;
@

<<global [[traceactivity]]([[(networking/ndb/dnsdebug.c)]])>>=
int	traceactivity;
@

<<global [[zonerefreshprogram]]([[(networking/ndb/dnsdebug.c)]])>>=
char	*zonerefreshprogram;
@

<<function [[usage]]([[(networking/ndb/dnsdebug.c)]])>>=
void
usage(void)
{
    fprint(2, "%s: [-rx] [-f db-file] [[@server] domain [type]]\n", argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/ndb/dnsdebug.c)]])>>=
void
main(int argc, char *argv[])
{
    int n;
    Biobuf in;
    char *p;
    char *f[4];

    strcpy(mntpt, "/net");
    cfg.inside = 1;

    ARGBEGIN{
    case 'f':
        dbfile = EARGF(usage());
        break;
    case 'r':
        cfg.resolver = 1;
        break;
    case 'x':
        dbfile = "/lib/ndb/external";
        strcpy(mntpt, "/net.alt");
        break;
    default:
        usage();
    }ARGEND

    now = time(nil);
    nowns = nsec();
    dninit();
    fmtinstall('R', prettyrrfmt);
    if(myipaddr(ipaddr, mntpt) < 0)
        sysfatal("can't read my ip address");
    opendatabase();

    if(cfg.resolver)
        squirrelserveraddrs();

    debug = 1;

    if(argc > 0){
        docmd(argc, argv);
        exits(0);
    }

    Binit(&in, 0, OREAD);
    for(print("> "); p = Brdline(&in, '\n'); print("> ")){
        p[Blinelen(&in)-1] = 0;
        n = tokenize(p, f, 3);
        if(n>=1) {
            dnpurge();		/* flush the cache */
            docmd(n, f);
        }
    }
    exits(0);
}
@

<<function [[longtime]]>>=
static char*
longtime(long t)
{
    int d, h, m, n;
    static char x[128];

    for(d = 0; t >= 24*60*60; t -= 24*60*60)
        d++;
    for(h = 0; t >= 60*60; t -= 60*60)
        h++;
    for(m = 0; t >= 60; t -= 60)
        m++;
    n = 0;
    if(d)
        n += sprint(x, "%d day ", d);
    if(h)
        n += sprint(x+n, "%d hr ", h);
    if(m)
        n += sprint(x+n, "%d min ", m);
    if(t || n == 0)
        sprint(x+n, "%ld sec", t);
    return x;
}
@

<<function [[prettyrrfmt]]>>=
int
prettyrrfmt(Fmt *f)
{
    RR *rp;
    char buf[3*Domlen];
    char *p, *e;
    Txt *t;

    rp = va_arg(f->args, RR*);
    if(rp == 0){
        strcpy(buf, "<null>");
        goto out;
    }

    p = buf;
    e = buf + sizeof(buf);
    p = seprint(p, e, "%-32.32s %-15.15s %-5.5s", rp->owner->name,
        longtime(rp->db? rp->ttl: (rp->ttl - now)),
        rrname(rp->type, buf, sizeof buf));

    if(rp->negative){
        seprint(p, e, "negative rcode %d", rp->negrcode);
        goto out;
    }

    switch(rp->type){
    case Thinfo:
        seprint(p, e, "\t%s %s", rp->cpu->name, rp->os->name);
        break;
    case Tcname:
    case Tmb:
    case Tmd:
    case Tmf:
    case Tns:
        seprint(p, e, "\t%s", (rp->host? rp->host->name: ""));
        break;
    case Tmg:
    case Tmr:
        seprint(p, e, "\t%s", (rp->mb? rp->mb->name: ""));
        break;
    case Tminfo:
        seprint(p, e, "\t%s %s", (rp->mb? rp->mb->name: ""),
            (rp->rmb? rp->rmb->name: ""));
        break;
    case Tmx:
        seprint(p, e, "\t%lud %s", rp->pref,
            (rp->host? rp->host->name: ""));
        break;
    case Ta:
    case Taaaa:
        seprint(p, e, "\t%s", (rp->ip? rp->ip->name: ""));
        break;
    case Tptr:
        seprint(p, e, "\t%s", (rp->ptr? rp->ptr->name: ""));
        break;
    case Tsoa:
        seprint(p, e, "\t%s %s %lud %lud %lud %lud %lud",
            rp->host->name, rp->rmb->name, rp->soa->serial,
            rp->soa->refresh, rp->soa->retry,
            rp->soa->expire, rp->soa->minttl);
        break;
    case Tsrv:
        seprint(p, e, "\t%ud %ud %ud %s",
            rp->srv->pri, rp->srv->weight, rp->port, rp->host->name);
        break;
    case Tnull:
        seprint(p, e, "\t%.*H", rp->null->dlen, rp->null->data);
        break;
    case Ttxt:
        p = seprint(p, e, "\t");
        for(t = rp->txt; t != nil; t = t->next)
            p = seprint(p, e, "%s", t->p);
        break;
    case Trp:
        seprint(p, e, "\t%s %s", rp->rmb->name, rp->rp->name);
        break;
    case Tkey:
        seprint(p, e, "\t%d %d %d", rp->key->flags, rp->key->proto,
            rp->key->alg);
        break;
    case Tsig:
        seprint(p, e, "\t%d %d %d %lud %lud %lud %d %s",
            rp->sig->type, rp->sig->alg, rp->sig->labels,
            rp->sig->ttl, rp->sig->exp, rp->sig->incep,
            rp->sig->tag, rp->sig->signer->name);
        break;
    case Tcert:
        seprint(p, e, "\t%d %d %d",
            rp->sig->type, rp->sig->tag, rp->sig->alg);
        break;
    }
out:
    return fmtstrcpy(f, buf);
}
@

<<function [[logsection]]>>=
void
logsection(char *flag, RR *rp)
{
    if(rp == nil)
        return;
    print("\t%s%R\n", flag, rp);
    for(rp = rp->next; rp != nil; rp = rp->next)
        print("\t      %R\n", rp);
}
@

<<function [[logreply]]([[(networking/ndb/dnsdebug.c)]])>>=
void
logreply(int id, uchar *addr, DNSmsg *mp)
{
    RR *rp;
    char buf[12], resp[32];

    switch(mp->flags & Rmask){
    case Rok:
        strcpy(resp, "OK");
        break;
    case Rformat:
        strcpy(resp, "Format error");
        break;
    case Rserver:
        strcpy(resp, "Server failed");
        break;
    case Rname:
        strcpy(resp, "Nonexistent");
        break;
    case Runimplimented:
        strcpy(resp, "Unimplemented");
        break;
    case Rrefused:
        strcpy(resp, "Refused");
        break;
    default:
        sprint(resp, "%d", mp->flags & Rmask);
        break;
    }

    print("%d: rcvd %s from %I (%s%s%s%s%s)\n", id, resp, addr,
        mp->flags & Fauth? "authoritative": "",
        mp->flags & Ftrunc? " truncated": "",
        mp->flags & Frecurse? " recurse": "",
        mp->flags & Fcanrec? " can_recurse": "",
        (mp->flags & (Fauth|Rmask)) == (Fauth|Rname)? " nx": "");
    for(rp = mp->qd; rp != nil; rp = rp->next)
        print("\tQ:    %s %s\n", rp->owner->name,
            rrname(rp->type, buf, sizeof buf));
    logsection("Ans:  ", mp->an);
    logsection("Auth: ", mp->ns);
    logsection("Hint: ", mp->ar);
}
@

<<function [[logsend]]([[(networking/ndb/dnsdebug.c)]])>>=
void
logsend(int id, int subid, uchar *addr, char *sname, char *rname, int type)
{
    char buf[12];

    print("%d.%d: sending to %I/%s %s %s\n", id, subid,
        addr, sname, rname, rrname(type, buf, sizeof buf));
}
@

<<function [[getdnsservers]]([[(networking/ndb/dnsdebug.c)]])>>=
RR*
getdnsservers(int class)
{
    RR *rr;

    if(servername == nil)
        return dnsservers(class);

    rr = rralloc(Tns);
    rr->owner = dnlookup("local#dns#servers", class, 1);
    rr->host = dnlookup(servername, class, 1);

    return rr;
}
@

<<function [[squirrelserveraddrs]]>>=
void
squirrelserveraddrs(void)
{
    int v4;
    char *attr;
    RR *rr, *rp, **l;
    Request req;

    /* look up the resolver address first */
    cfg.resolver = 0;
    debug = 0;
    if(serveraddrs)
        rrfreelist(serveraddrs);
    serveraddrs = nil;
    rr = getdnsservers(Cin);
    l = &serveraddrs;
    for(rp = rr; rp != nil; rp = rp->next){
        attr = ipattr(rp->host->name);
        v4 = strcmp(attr, "ip") == 0;
        if(v4 || strcmp(attr, "ipv6") == 0){
            *l = rralloc(v4? Ta: Taaaa);
            (*l)->owner = rp->host;
            (*l)->ip = rp->host;
            l = &(*l)->next;
            continue;
        }
        memset(&req, 0, sizeof req);
        req.isslave = 1;
        req.aborttime = NS2MS(nowns) + Maxreqtm;
        *l = dnresolve(rp->host->name, Cin, Ta, &req, 0, 0, Recurse, 0, 0);
        if(*l == nil)
            *l = dnresolve(rp->host->name, Cin, Taaaa, &req,
                0, 0, Recurse, 0, 0);
        while(*l != nil)
            l = &(*l)->next;
    }
    cfg.resolver = 1;
    debug = 1;
}
@

<<function [[preloadserveraddrs]]>>=
void
preloadserveraddrs(void)
{
    RR *rp, **l, *first;

    l = &first;
    for(rp = serveraddrs; rp != nil; rp = rp->next){
        lock(&dnlock);
        rrcopy(rp, l);
        unlock(&dnlock);
        rrattach(first, Authoritative);
    }
}
@

<<function [[setserver]]>>=
int
setserver(char *server)
{
    if(servername != nil){
        free(servername);
        servername = nil;
        cfg.resolver = 0;
    }
    if(server == nil || *server == 0)
        return 0;
    servername = strdup(server);
    squirrelserveraddrs();
    if(serveraddrs == nil){
        print("can't resolve %s\n", servername);
        cfg.resolver = 0;
    } else
        cfg.resolver = 1;
    return cfg.resolver? 0: -1;
}
@

<<function [[doquery]]>>=
void
doquery(char *name, char *tstr)
{
    int len, type, rooted;
    char *p, *np;
    char buf[1024];
    RR *rr, *rp;
    Request req;

    if(cfg.resolver)
        preloadserveraddrs();

    /* default to an "ip" request if alpha, "ptr" if numeric */
    if(tstr == nil || *tstr == 0)
        if(strcmp(ipattr(name), "ip") == 0)
            tstr = "ptr";
        else
            tstr = "ip";

    /* if name end in '.', remove it */
    len = strlen(name);
    if(len > 0 && name[len-1] == '.'){
        rooted = 1;
        name[len-1] = 0;
    } else
        rooted = 0;

    /* inverse queries may need to be permuted */
    strncpy(buf, name, sizeof buf);
    if(strcmp("ptr", tstr) == 0 && cistrstr(name, ".arpa") == nil){
        /* TODO: reversing v6 addrs is harder */
        for(p = name; *p; p++)
            ;
        *p = '.';
        np = buf;
        len = 0;
        while(p >= name){
            len++;
            p--;
            if(*p == '.'){
                memmove(np, p+1, len);
                np += len;
                len = 0;
            }
        }
        memmove(np, p+1, len);
        np += len;
        strcpy(np, "in-addr.arpa");	/* TODO: ip6.arpa for v6 */
    }

    /* look it up */
    type = rrtype(tstr);
    if(type < 0){
        print("!unknown type %s\n", tstr);
        return;
    }

    memset(&req, 0, sizeof req);
    getactivity(&req, 0);
    req.isslave = 1;
    req.aborttime = NS2MS(nowns) + Maxreqtm;
    rr = dnresolve(buf, Cin, type, &req, 0, 0, Recurse, rooted, 0);
    if(rr){
        print("----------------------------\n");
        for(rp = rr; rp; rp = rp->next)
            print("answer %R\n", rp);
        print("----------------------------\n");
    }
    rrfreelist(rr);

    putactivity(0);
}
@

<<function [[docmd]]>>=
void
docmd(int n, char **f)
{
    int tmpsrv;
    char *name, *type;

    name = type = nil;
    tmpsrv = 0;

    if(*f[0] == '@') {
        if(setserver(f[0]+1) < 0)
            return;

        switch(n){
        case 3:
            type = f[2];
            /* fall through */
        case 2:
            name = f[1];
            tmpsrv = 1;
            break;
        }
    } else
        switch(n){
        case 2:
            type = f[1];
            /* fall through */
        case 1:
            name = f[0];
            break;
        }

    if(name == nil)
        return;

    doquery(name, type);

    if(tmpsrv)
        setserver("");
}
@


%-------------------------------------------------------------

<<networking/ndb/dnsdebug.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <ip.h>
#include <ndb.h>
#include "dns.h"

<<enum [[_anon_ (networking/ndb/dnsdebug.c)]]>>

<<global [[cfg]]([[(networking/ndb/dnsdebug.c)]])>>

<<global [[servername]]>>
<<global [[serverrr]]>>
<<global [[serveraddrs]]>>

<<global [[dbfile]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[debug]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[ipaddr]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[logfile]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[maxage]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[mntpt]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[needrefresh]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[now]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[nowns]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[testing]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[trace]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[traceactivity]]([[(networking/ndb/dnsdebug.c)]])>>
<<global [[zonerefreshprogram]]([[(networking/ndb/dnsdebug.c)]])>>

void	docmd(int, char**);
void	doquery(char*, char*);
void	preloadserveraddrs(void);
int	prettyrrfmt(Fmt*);
int	setserver(char*);
void	squirrelserveraddrs(void);

<<function [[usage]]([[(networking/ndb/dnsdebug.c)]])>>

<<function [[main]]([[(networking/ndb/dnsdebug.c)]])>>

<<function [[longtime]]>>

<<function [[prettyrrfmt]]>>

<<function [[logsection]]>>

<<function [[logreply]]([[(networking/ndb/dnsdebug.c)]])>>

<<function [[logsend]]([[(networking/ndb/dnsdebug.c)]])>>

<<function [[getdnsservers]]([[(networking/ndb/dnsdebug.c)]])>>

<<function [[squirrelserveraddrs]]>>

<<function [[preloadserveraddrs]]>>

<<function [[setserver]]>>

<<function [[doquery]]>>

<<function [[docmd]]>>
@


\subsection*{[[networking/ndb/dnserver.c]]}

<<global [[norecursion]]>>=
/* set in dns.c */
int	norecursion;		/* don't allow recursive requests */
@

<<function [[dnserver]]>>=
/*
 *  answer a dns request
 */
void
dnserver(DNSmsg *reqp, DNSmsg *repp, Request *req, uchar *srcip, int rcode)
{
    int recursionflag;
    char *cp, *errmsg;
    char tname[32];
    DN *nsdp, *dp;
    Area *myarea;
    RR *tp, *neg, *rp;

    dncheck(nil, 1);

    recursionflag = norecursion? 0: Fcanrec;
    memset(repp, 0, sizeof(*repp));
    repp->id = reqp->id;
    repp->flags = Fresp | recursionflag | Oquery;

    /* move one question from reqp to repp */
    tp = reqp->qd;
    reqp->qd = tp->next;
    tp->next = nil;
    repp->qd = tp;

    if (rcode) {
        errmsg = "";
        if (rcode >= 0 && rcode < nrname)
            errmsg = rname[rcode];
        dnslog("server: response code 0%o (%s), req from %I",
            rcode, errmsg, srcip);
        /* provide feedback to clients who send us trash */
        repp->flags = (rcode&Rmask) | Fresp | Fcanrec | Oquery;
        return;
    }
    if(!rrsupported(repp->qd->type)){
        dnslog("server: unsupported request %s from %I",
            rrname(repp->qd->type, tname, sizeof tname), srcip);
        repp->flags = Runimplimented | Fresp | Fcanrec | Oquery;
        return;
    }

    if(repp->qd->owner->class != Cin){
        dnslog("server: unsupported class %d from %I",
            repp->qd->owner->class, srcip);
        repp->flags = Runimplimented | Fresp | Fcanrec | Oquery;
        return;
    }

    myarea = inmyarea(repp->qd->owner->name);
    if(myarea != nil) {
        if(repp->qd->type == Tixfr || repp->qd->type == Taxfr){
            dnslog("server: unsupported xfr request %s for %s from %I",
                rrname(repp->qd->type, tname, sizeof tname),
                repp->qd->owner->name, srcip);
            repp->flags = Runimplimented | Fresp | recursionflag |
                Oquery;
            return;
        }
    } else
        if(norecursion) {
            /* we don't recurse and we're not authoritative */
            repp->flags = Rok | Fresp | Oquery;
            return;
        }

    /*
     *  get the answer if we can, in *repp
     */
    if(reqp->flags & Frecurse)
        neg = doextquery(repp, req, Recurse);
    else
        neg = doextquery(repp, req, Dontrecurse);

    /* authority is transitive */
    if(myarea != nil || (repp->an && repp->an->auth))
        repp->flags |= Fauth;

    /* pass on error codes */
    if(repp->an == nil){
        dp = dnlookup(repp->qd->owner->name, repp->qd->owner->class, 0);
        if(dp->rr == nil)
            if(reqp->flags & Frecurse)
                repp->flags |= dp->respcode | Fauth;
    }

    if(myarea == nil)
        /*
         *  add name server if we know
         */
        for(cp = repp->qd->owner->name; cp; cp = walkup(cp)){
            nsdp = dnlookup(cp, repp->qd->owner->class, 0);
            if(nsdp == nil)
                continue;

            repp->ns = rrlookup(nsdp, Tns, OKneg);
            if(repp->ns){
                /* don't pass on anything we know is wrong */
                if(repp->ns->negative){
                    lock(&dnlock);
                    rp = repp->ns;
                    repp->ns = nil;
                    rrfreelist(rp);
                    unlock(&dnlock);
                }
                break;
            }

            if (strncmp(nsdp->name, "local#", 6) == 0)
                dnslog("returning %s as nameserver", nsdp->name);
            repp->ns = dblookup(cp, repp->qd->owner->class, Tns, 0, 0);
            if(repp->ns)
                break;
        }

    /*
     *  add ip addresses as hints
     */
    if(repp->qd->type != Taxfr && repp->qd->type != Tixfr){
        for(tp = repp->ns; tp; tp = tp->next)
            hint(&repp->ar, tp);
        for(tp = repp->an; tp; tp = tp->next)
            hint(&repp->ar, tp);
    }

    /* hint calls rrlookup which holds dnlock, so don't lock before this. */

    /*
     *  add an soa to the authority section to help client
     *  with negative caching
     */
    if(repp->an == nil)
        if(myarea != nil){
            lock(&dnlock);
            rrcopy(myarea->soarr, &tp);
            rrcat(&repp->ns, tp);
            unlock(&dnlock);
        } else if(neg != nil) {
            if(neg->negsoaowner != nil) {
                tp = rrlookup(neg->negsoaowner, Tsoa, NOneg);
                lock(&dnlock);
                rrcat(&repp->ns, tp);
                unlock(&dnlock);
            }
            repp->flags |= neg->negrcode;
        }

    /*
     *  get rid of duplicates
     */
    lock(&dnlock);
    unique(repp->an);
    unique(repp->ns);
    unique(repp->ar);

    rrfreelist(neg);
    unlock(&dnlock);

    dncheck(nil, 1);
}
@

<<function [[doextquery]]>>=
/*
 *  satisfy a recursive request.  dnlookup will handle cnames.
 */
static RR*
doextquery(DNSmsg *mp, Request *req, int recurse)
{
    ushort type;
    char *name;
    RR *rp, *neg;

    name = mp->qd->owner->name;
    type = mp->qd->type;
    rp = dnresolve(name, Cin, type, req, &mp->an, 0, recurse, 1, 0);

    lock(&dnlock);
    /* don't return soa hints as answers, it's wrong */
    if(rp && rp->db && !rp->auth && rp->type == Tsoa) {
        rrfreelist(rp);
        rp = nil;
    }

    /* don't let negative cached entries escape */
    neg = rrremneg(&rp);
    rrcat(&mp->an, rp);
    unlock(&dnlock);
    return neg;
}
@

<<function [[hint]]>>=
static void
hint(RR **last, RR *rp)
{
    RR *hp;

    switch(rp->type){
    case Tns:
    case Tmx:
    case Tmb:
    case Tmf:
    case Tmd:
        assert(rp->host != nil);
        hp = rrlookup(rp->host, Ta, NOneg);
        if(hp == nil)
            hp = dblookup(rp->host->name, Cin, Ta, 0, 0);
        if(hp == nil)
            hp = rrlookup(rp->host, Taaaa, NOneg);
        if(hp == nil)
            hp = dblookup(rp->host->name, Cin, Taaaa, 0, 0);
        if (hp && hp->owner && hp->owner->name &&
            strncmp(hp->owner->name, "local#", 6) == 0)
            dnslog("returning %s as hint", hp->owner->name);
        lock(&dnlock);
        rrcat(last, hp);
        unlock(&dnlock);
        break;
    }
}
@


%-------------------------------------------------------------

<<networking/ndb/dnserver.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dns.h"

static RR*	doextquery(DNSmsg*, Request*, int);
static void	hint(RR**, RR*);

<<global [[norecursion]]>>

<<function [[dnserver]]>>

<<function [[doextquery]]>>

<<function [[hint]]>>
@


\subsection*{[[networking/ndb/dnsquery.c]]}

<<global [[domount]]>>=
static int domount;
@

<<function [[setup]]([[(networking/ndb/dnsquery.c)]])>>=
static int
setup(int argc, char **argv)
{
    int fd;

    if(argc == 1){
        domount = 0;
        mtpt = argv[0];
    }

    fd = open(dns, ORDWR);
    if(fd < 0){
        if(domount == 0)
            sysfatal("can't open %s: %r", dns);
        fd = open(srv, ORDWR);
        if(fd < 0)
            sysfatal("can't open %s: %r", srv);
        if(mount(fd, -1, mtpt, MBEFORE, "") < 0)
            sysfatal("can't mount(%s, %s): %r", srv, mtpt);
        fd = open(dns, ORDWR);
        if(fd < 0)
            sysfatal("can't open %s: %r", dns);
    }
    return fd;
}
@

<<function [[querydns]]>>=
static void
querydns(int fd, char *line, int n)
{
    char buf[1024];

    seek(fd, 0, 0);
    if(write(fd, line, n) != n) {
        print("!%r\n");
        return;
    }
    seek(fd, 0, 0);
    buf[0] = '\0';
    while((n = read(fd, buf, sizeof(buf))) > 0){
        buf[n] = '\0';
        print("%s\n", buf);
    }
}
@

<<function [[query]]([[(networking/ndb/dnsquery.c)]])>>=
static void
query(int fd)
{
    int n, len;
    char *lp, *p, *np;
    char buf[1024], line[1024];
    Biobuf in;

    Binit(&in, 0, OREAD);
    for(print("> "); lp = Brdline(&in, '\n'); print("> ")){
        n = Blinelen(&in) -1;
        while(isspace(lp[n]))
            lp[n--] = 0;
        n++;
        while(isspace(*lp)){
            lp++;
            n--;
        }
        if(!*lp)
            continue;
        strcpy(line, lp);

        /* default to an "ip" request if alpha, "ptr" if numeric */
        if(strchr(line, ' ') == nil)
            if(strcmp(ipattr(line), "ip") == 0) {
                strcat(line, " ptr");
                n += 4;
            } else {
                strcat(line, " ip");
                n += 3;
            }

        /* inverse queries may need to be permuted */
        if(n > 4 && strcmp(" ptr", &line[n-4]) == 0 &&
            cistrstr(line, ".arpa") == nil){
            /* TODO: reversing v6 addrs is harder */
            for(p = line; *p; p++)
                if(*p == ' '){
                    *p = '.';
                    break;
                }
            np = buf;
            len = 0;
            while(p >= line){
                len++;
                p--;
                if(*p == '.'){
                    memmove(np, p+1, len);
                    np += len;
                    len = 0;
                }
            }
            memmove(np, p+1, len);
            np += len;
            strcpy(np, "in-addr.arpa ptr");	/* TODO: ip6.arpa for v6 */
            strcpy(line, buf);
            n = strlen(line);
        }

        querydns(fd, line, n);
    }
    Bterm(&in);
}
@

<<function [[main]]([[(networking/ndb/dnsquery.c)]])>>=
void
main(int argc, char *argv[])
{
    mtpt = "/net";
    dns = "/net/dns";
    srv = "/srv/dns";
    domount = 1;
    ARGBEGIN {
    case 'x':
        mtpt = "/net.alt";
        dns = "/net.alt/dns";
        srv = "/srv/dns_net.alt";
        break;
    default:
        fprint(2, "usage: %s [-x] [dns-mount-point]\n", argv0);
        exits("usage");
    } ARGEND;

    query(setup(argc, argv));
    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ndb/dnsquery.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <ndb.h>
#include "dns.h"
#include "ip.h"

<<global [[domount]]>>
static char *mtpt, *dns, *srv;

<<function [[setup]]([[(networking/ndb/dnsquery.c)]])>>

<<function [[querydns]]>>

<<function [[query]]([[(networking/ndb/dnsquery.c)]])>>

<<function [[main]]([[(networking/ndb/dnsquery.c)]])>>
@


\subsection*{[[networking/ndb/dnstcp.c]]}

<<global [[cfg]]([[(networking/ndb/dnstcp.c)]])>>=
Cfg cfg;
@

<<global [[caller]]>>=
char	*caller = "";
@

<<global [[dbfile]]([[(networking/ndb/dnstcp.c)]])>>=
char	*dbfile;
@

<<global [[debug]]([[(networking/ndb/dnstcp.c)]])>>=
int	debug;
@

<<global [[ipaddr]]([[(networking/ndb/dnstcp.c)]])>>=
uchar	ipaddr[IPaddrlen];	/* my ip address */
@

<<global [[logfile]]([[(networking/ndb/dnstcp.c)]])>>=
char	*logfile = "dns";
@

<<global [[maxage]]([[(networking/ndb/dnstcp.c)]])>>=
int	maxage = 60*60;
@

<<global [[mntpt]]([[(networking/ndb/dnstcp.c)]])>>=
char	mntpt[Maxpath];
@

<<global [[needrefresh]]([[(networking/ndb/dnstcp.c)]])>>=
int	needrefresh;
@

<<global [[now]]([[(networking/ndb/dnstcp.c)]])>>=
ulong	now;
@

<<global [[nowns]]([[(networking/ndb/dnstcp.c)]])>>=
vlong	nowns;
@

<<global [[testing]]([[(networking/ndb/dnstcp.c)]])>>=
int	testing;
@

<<global [[traceactivity]]([[(networking/ndb/dnstcp.c)]])>>=
int	traceactivity;
@

<<global [[zonerefreshprogram]]([[(networking/ndb/dnstcp.c)]])>>=
char	*zonerefreshprogram;
@

<<function [[usage]]([[(networking/ndb/dnstcp.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-rR] [-f ndb-file] [-x netmtpt] [conndir]\n", argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/ndb/dnstcp.c)]])>>=
void
main(int argc, char *argv[])
{
    volatile int len, rcode;
    volatile char tname[32];
    char *volatile err, *volatile ext = "";
    volatile uchar buf[64*1024], callip[IPaddrlen];
    volatile DNSmsg reqmsg, repmsg;
    volatile Request req;

    alarm(2*60*1000);
    cfg.cachedb = 1;
    ARGBEGIN{
    case 'd':
        debug++;
        break;
    case 'f':
        dbfile = EARGF(usage());
        break;
    case 'r':
        cfg.resolver = 1;
        break;
    case 'R':
        norecursion = 1;
        break;
    case 'x':
        ext = EARGF(usage());
        break;
    default:
        usage();
        break;
    }ARGEND

    if(debug < 2)
        debug = 0;

    if(argc > 0)
        getcaller(argv[0]);

    cfg.inside = 1;
    dninit();

    snprint(mntpt, sizeof mntpt, "/net%s", ext);
    if(myipaddr(ipaddr, mntpt) < 0)
        sysfatal("can't read my ip address");
    dnslog("dnstcp call from %s to %I", caller, ipaddr);
    memset(callip, 0, sizeof callip);
    parseip(callip, caller);

    db2cache(1);

    memset(&req, 0, sizeof req);
    setjmp(req.mret);
    req.isslave = 0;
    procsetname("main loop");

    /* loop on requests */
    for(;; putactivity(0)){
        now = time(nil);
        memset(&repmsg, 0, sizeof repmsg);
        len = readmsg(0, buf, sizeof buf);
        if(len <= 0)
            break;

        getactivity(&req, 0);
        req.aborttime = timems() + S2MS(15*Min);
        rcode = 0;
        memset(&reqmsg, 0, sizeof reqmsg);
        err = convM2DNS(buf, len, &reqmsg, &rcode);
        if(err){
            dnslog("server: input error: %s from %s", err, caller);
            free(err);
            break;
        }
        if (rcode == 0)
            if(reqmsg.qdcount < 1){
                dnslog("server: no questions from %s", caller);
                break;
            } else if(reqmsg.flags & Fresp){
                dnslog("server: reply not request from %s",
                    caller);
                break;
            } else if((reqmsg.flags & Omask) != Oquery){
                dnslog("server: op %d from %s",
                    reqmsg.flags & Omask, caller);
                break;
            }
        if(debug)
            dnslog("[%d] %d: serve (%s) %d %s %s",
                getpid(), req.id, caller,
                reqmsg.id, reqmsg.qd->owner->name,
                rrname(reqmsg.qd->type, tname, sizeof tname));

        /* loop through each question */
        while(reqmsg.qd)
            if(reqmsg.qd->type == Taxfr)
                dnzone(&reqmsg, &repmsg, &req);
            else {
                dnserver(&reqmsg, &repmsg, &req, callip, rcode);
                reply(1, &repmsg, &req);
                rrfreelist(repmsg.qd);
                rrfreelist(repmsg.an);
                rrfreelist(repmsg.ns);
                rrfreelist(repmsg.ar);
            }
        rrfreelist(reqmsg.qd);		/* qd will be nil */
        rrfreelist(reqmsg.an);
        rrfreelist(reqmsg.ns);
        rrfreelist(reqmsg.ar);

        if(req.isslave){
            putactivity(0);
            _exits(0);
        }
    }
    refreshmain(mntpt);
}
@

<<function [[readmsg]]([[(networking/ndb/dnstcp.c)]])>>=
static int
readmsg(int fd, uchar *buf, int max)
{
    int n;
    uchar x[2];

    if(readn(fd, x, 2) != 2)
        return -1;
    n = x[0]<<8 | x[1];
    if(n > max)
        return -1;
    if(readn(fd, buf, n) != n)
        return -1;
    return n;
}
@

<<function [[reply]]([[(networking/ndb/dnstcp.c)]])>>=
static void
reply(int fd, DNSmsg *rep, Request *req)
{
    int len, rv;
    char tname[32];
    uchar buf[64*1024];
    RR *rp;

    if(debug){
        dnslog("%d: reply (%s) %s %s %ux",
            req->id, caller,
            rep->qd->owner->name,
            rrname(rep->qd->type, tname, sizeof tname),
            rep->flags);
        for(rp = rep->an; rp; rp = rp->next)
            dnslog("an %R", rp);
        for(rp = rep->ns; rp; rp = rp->next)
            dnslog("ns %R", rp);
        for(rp = rep->ar; rp; rp = rp->next)
            dnslog("ar %R", rp);
    }


    len = convDNS2M(rep, buf+2, sizeof(buf) - 2);
    buf[0] = len>>8;
    buf[1] = len;
    rv = write(fd, buf, len+2);
    if(rv != len+2){
        dnslog("[%d] sending reply: %d instead of %d", getpid(), rv,
            len+2);
        exits(0);
    }
}
@

<<function [[numelem]]>>=
static int
numelem(char *name)
{
    int i;

    i = 1;
    for(; *name; name++)
        if(*name == '.')
            i++;
    return i;
}
@

<<function [[inzone]]>>=
int
inzone(DN *dp, char *name, int namelen, int depth)
{
    int n;

    if(dp->name == nil)
        return 0;
    if(numelem(dp->name) != depth)
        return 0;
    n = strlen(dp->name);
    if(n < namelen)
        return 0;
    if(strcmp(name, dp->name + n - namelen) != 0)
        return 0;
    if(n > namelen && dp->name[n - namelen - 1] != '.')
        return 0;
    return 1;
}
@

<<function [[dnzone]]>>=
static void
dnzone(DNSmsg *reqp, DNSmsg *repp, Request *req)
{
    DN *dp, *ndp;
    RR r, *rp;
    int h, depth, found, nlen;

    memset(repp, 0, sizeof(*repp));
    repp->id = reqp->id;
    repp->qd = reqp->qd;
    reqp->qd = reqp->qd->next;
    repp->qd->next = 0;
    repp->flags = Fauth | Fresp | Oquery;
    if(!norecursion)
        repp->flags |= Fcanrec;
    dp = repp->qd->owner;

    /* send the soa */
    repp->an = rrlookup(dp, Tsoa, NOneg);
    reply(1, repp, req);
    if(repp->an == 0)
        goto out;
    rrfreelist(repp->an);
    repp->an = nil;

    nlen = strlen(dp->name);

    /* construct a breadth-first search of the name space (hard with a hash) */
    repp->an = &r;
    for(depth = numelem(dp->name); ; depth++){
        found = 0;
        for(h = 0; h < HTLEN; h++)
            for(ndp = ht[h]; ndp; ndp = ndp->next)
                if(inzone(ndp, dp->name, nlen, depth)){
                    for(rp = ndp->rr; rp; rp = rp->next){
                        /*
                         * there shouldn't be negatives,
                         * but just in case.
                         * don't send any soa's,
                         * ns's are enough.
                         */
                        if (rp->negative ||
                            rp->type == Tsoa)
                            continue;
                        r = *rp;
                        r.next = 0;
                        reply(1, repp, req);
                    }
                    found = 1;
                }
        if(!found)
            break;
    }

    /* resend the soa */
    repp->an = rrlookup(dp, Tsoa, NOneg);
    reply(1, repp, req);
    rrfreelist(repp->an);
    repp->an = nil;
out:
    rrfree(repp->qd);
    repp->qd = nil;
}
@

<<function [[getcaller]]>>=
static void
getcaller(char *dir)
{
    int fd, n;
    static char remote[128];

    snprint(remote, sizeof(remote), "%s/remote", dir);
    fd = open(remote, OREAD);
    if(fd < 0)
        return;
    n = read(fd, remote, sizeof remote - 1);
    close(fd);
    if(n <= 0)
        return;
    if(remote[n-1] == '\n')
        n--;
    remote[n] = 0;
    caller = remote;
}
@

<<function [[refreshmain]]>>=
static void
refreshmain(char *net)
{
    int fd;
    char file[128];

    snprint(file, sizeof(file), "%s/dns", net);
    if(debug)
        dnslog("refreshing %s", file);
    fd = open(file, ORDWR);
    if(fd < 0)
        dnslog("can't refresh %s", file);
    else {
        fprint(fd, "refresh");
        close(fd);
    }
}
@

<<function [[logreply]]([[(networking/ndb/dnstcp.c)]])>>=
/*
 *  the following varies between dnsdebug and dns
 */
void
logreply(int id, uchar *addr, DNSmsg *mp)
{
    RR *rp;

    dnslog("%d: rcvd %I flags:%s%s%s%s%s", id, addr,
        mp->flags & Fauth? " auth": "",
        mp->flags & Ftrunc? " trunc": "",
        mp->flags & Frecurse? " rd": "",
        mp->flags & Fcanrec? " ra": "",
        (mp->flags & (Fauth|Rmask)) == (Fauth|Rname)? " nx": "");
    for(rp = mp->qd; rp != nil; rp = rp->next)
        dnslog("%d: rcvd %I qd %s", id, addr, rp->owner->name);
    for(rp = mp->an; rp != nil; rp = rp->next)
        dnslog("%d: rcvd %I an %R", id, addr, rp);
    for(rp = mp->ns; rp != nil; rp = rp->next)
        dnslog("%d: rcvd %I ns %R", id, addr, rp);
    for(rp = mp->ar; rp != nil; rp = rp->next)
        dnslog("%d: rcvd %I ar %R", id, addr, rp);
}
@

<<function [[logsend]]([[(networking/ndb/dnstcp.c)]])>>=
void
logsend(int id, int subid, uchar *addr, char *sname, char *rname, int type)
{
    char buf[12];

    dnslog("%d.%d: sending to %I/%s %s %s",
        id, subid, addr, sname, rname, rrname(type, buf, sizeof buf));
}
@

<<function [[getdnsservers]]([[(networking/ndb/dnstcp.c)]])>>=
RR*
getdnsservers(int class)
{
    return dnsservers(class);
}
@


%-------------------------------------------------------------

<<networking/ndb/dnstcp.c>>=
/*
 * dnstcp - serve dns via tcp
 */
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dns.h"

<<global [[cfg]]([[(networking/ndb/dnstcp.c)]])>>

<<global [[caller]]>>
<<global [[dbfile]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[debug]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[ipaddr]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[logfile]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[maxage]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[mntpt]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[needrefresh]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[now]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[nowns]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[testing]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[traceactivity]]([[(networking/ndb/dnstcp.c)]])>>
<<global [[zonerefreshprogram]]([[(networking/ndb/dnstcp.c)]])>>

static int	readmsg(int, uchar*, int);
static void	reply(int, DNSmsg*, Request*);
static void	dnzone(DNSmsg*, DNSmsg*, Request*);
static void	getcaller(char*);
static void	refreshmain(char*);

<<function [[usage]]([[(networking/ndb/dnstcp.c)]])>>

<<function [[main]]([[(networking/ndb/dnstcp.c)]])>>

<<function [[readmsg]]([[(networking/ndb/dnstcp.c)]])>>

<<function [[reply]]([[(networking/ndb/dnstcp.c)]])>>

/*
 *  Hash table for domain names.  The hash is based only on the
 *  first element of the domain name.
 */
extern DN	*ht[HTLEN];

<<function [[numelem]]>>

<<function [[inzone]]>>

<<function [[dnzone]]>>

<<function [[getcaller]]>>

<<function [[refreshmain]]>>

<<function [[logreply]]([[(networking/ndb/dnstcp.c)]])>>

<<function [[logsend]]([[(networking/ndb/dnstcp.c)]])>>

<<function [[getdnsservers]]([[(networking/ndb/dnstcp.c)]])>>
@


\subsection*{[[networking/ndb/dnudpserver.c]]}

<<enum [[_anon_ (networking/ndb/dnudpserver.c)]]>>=
enum {
    Logqueries = 0,
};
@

<<struct [[Inprogress]]>>=
struct Inprogress
{
    int	inuse;
    Udphdr	uh;
    DN	*owner;
    ushort	type;
    int	id;
};
@

<<global [[inprog]]>>=
Inprogress inprog[Maxactive+2];
@

<<struct [[Forwtarg]]>>=
struct Forwtarg {
    char	*host;
    uchar	addr[IPaddrlen];
    int	fd;
    ulong	lastdial;
};
@

<<global [[forwtarg]]>>=
Forwtarg forwtarg[10];
@

<<global [[currtarg]]>>=
int currtarg;
@

<<global [[hmsg]]([[(networking/ndb/dnudpserver.c)]])>>=
static char *hmsg = "headers";
@

<<function [[clientrxmit]]>>=
/*
 *  record client id and ignore retransmissions.
 *  we're still single thread at this point.
 */
static Inprogress*
clientrxmit(DNSmsg *req, uchar *buf)
{
    Inprogress *p, *empty;
    Udphdr *uh;

    uh = (Udphdr *)buf;
    empty = nil;
    for(p = inprog; p < &inprog[Maxactive]; p++){
        if(p->inuse == 0){
            if(empty == nil)
                empty = p;
            continue;
        }
        if(req->id == p->id && req->qd != nil &&
            req->qd->owner == p->owner && req->qd->type == p->type &&
            memcmp(uh, &p->uh, Udphdrsize) == 0)
            return nil;
    }
    if(empty == nil)
        return nil; /* shouldn't happen: see slave() & Maxactive def'n */
    if(req->qd == nil) {
        dnslog("clientrxmit: nil req->qd");
        return nil;
    }
    empty->id = req->id;
    empty->owner = req->qd->owner;
    empty->type = req->qd->type;
    if (empty->type != req->qd->type)
        dnslog("clientrxmit: bogus req->qd->type %d", req->qd->type);
    memmove(&empty->uh, uh, Udphdrsize);
    empty->inuse = 1;
    return empty;
}
@

<<function [[addforwtarg]]>>=
int
addforwtarg(char *host)
{
    Forwtarg *tp;

    if (currtarg >= nelem(forwtarg)) {
        dnslog("too many forwarding targets");
        return -1;
    }
    tp = forwtarg + currtarg;
    if (parseip(tp->addr, host) < 0) {
        dnslog("can't parse ip %s", host);
        return -1;
    }
    tp->lastdial = time(nil);
    tp->fd = udpport(mntpt);
    if (tp->fd < 0)
        return -1;

    free(tp->host);
    tp->host = estrdup(host);
    currtarg++;
    return 0;
}
@

<<function [[redistrib]]>>=
/*
 * fast forwarding of incoming queries to other dns servers.
 * intended primarily for debugging.
 */
static void
redistrib(uchar *buf, int len)
{
    Forwtarg *tp;
    Udphdr *uh;
    static uchar outpkt[1500];

    assert(len <= sizeof outpkt);
    memmove(outpkt, buf, len);
    uh = (Udphdr *)outpkt;
    for (tp = forwtarg; tp < forwtarg + currtarg; tp++)
        if (tp->fd > 0) {
            memmove(outpkt, tp->addr, sizeof tp->addr);
            hnputs(uh->rport, 53);		/* dns port */
            if (write(tp->fd, outpkt, len) != len) {
                close(tp->fd);
                tp->fd = -1;
            }
        } else if (tp->host && time(nil) - tp->lastdial > 60) {
            tp->lastdial = time(nil);
            tp->fd = udpport(mntpt);
        }
}
@

<<function [[dnudpserver]]>>=
/*
 *  a process to act as a dns server for outside reqeusts
 */
void
dnudpserver(char *mntpt)
{
    volatile int fd, len, op, rcode;
    char *volatile err;
    volatile char tname[32];
    volatile uchar buf[Udphdrsize + Maxudp + 1024];
    volatile DNSmsg reqmsg, repmsg;
    Inprogress *volatile p;
    volatile Request req;
    Udphdr *volatile uh;

    /*
     * fork sharing text, data, and bss with parent.
     * stay in the same note group.
     */
    switch(rfork(RFPROC|RFMEM|RFNOWAIT)){
    case -1:
        break;
    case 0:
        break;
    default:
        return;
    }

    fd = -1;
restart:
    procsetname("udp server announcing");
    if(fd >= 0)
        close(fd);
    while((fd = udpannounce(mntpt)) < 0)
        sleep(5000);

//	procsetname("udp server");
    memset(&req, 0, sizeof req);
    if(setjmp(req.mret))
        putactivity(0);
    req.isslave = 0;
    req.id = 0;
    req.aborttime = 0;

    /* loop on requests */
    for(;; putactivity(0)){
        procsetname("served %d udp; %d alarms",
            stats.qrecvdudp, stats.alarms);
        memset(&repmsg, 0, sizeof repmsg);
        memset(&reqmsg, 0, sizeof reqmsg);

        alarm(60*1000);
        len = read(fd, buf, sizeof buf);
        alarm(0);
        if(len <= Udphdrsize)
            goto restart;

        redistrib(buf, len);

        uh = (Udphdr*)buf;
        len -= Udphdrsize;

        // dnslog("read received UDP from %I to %I",
        //	((Udphdr*)buf)->raddr, ((Udphdr*)buf)->laddr);
        getactivity(&req, 0);
        req.aborttime = timems() + Maxreqtm;
//		req.from = smprint("%I", ((Udphdr*)buf)->raddr);
        req.from = smprint("%I", buf);
        rcode = 0;
        stats.qrecvdudp++;

        err = convM2DNS(&buf[Udphdrsize], len, &reqmsg, &rcode);
        if(err){
            /* first bytes in buf are source IP addr */
            dnslog("server: input error: %s from %I", err, buf);
            free(err);
            goto freereq;
        }
        if (rcode == 0)
            if(reqmsg.qdcount < 1){
                dnslog("server: no questions from %I", buf);
                goto freereq;
            } else if(reqmsg.flags & Fresp){
                dnslog("server: reply not request from %I", buf);
                goto freereq;
            }
        op = reqmsg.flags & Omask;
        if(op != Oquery && op != Onotify){
            dnslog("server: op %d from %I", reqmsg.flags & Omask,
                buf);
            goto freereq;
        }

        if(debug || (trace && subsume(trace, reqmsg.qd->owner->name)))
            dnslog("%d: serve (%I/%d) %d %s %s",
                req.id, buf, uh->rport[0]<<8 | uh->rport[1],
                reqmsg.id, reqmsg.qd->owner->name,
                rrname(reqmsg.qd->type, tname, sizeof tname));

        p = clientrxmit(&reqmsg, buf);
        if(p == nil){
            if(debug)
                dnslog("%d: duplicate", req.id);
            goto freereq;
        }

        if (Logqueries) {
            RR *rr;

            for (rr = reqmsg.qd; rr; rr = rr->next)
                syslog(0, "dnsq", "id %d: (%I/%d) %d %s %s",
                    req.id, buf, uh->rport[0]<<8 |
                    uh->rport[1], reqmsg.id,
                    reqmsg.qd->owner->name,
                    rrname(reqmsg.qd->type, tname,
                    sizeof tname));
        }
        /* loop through each question */
        while(reqmsg.qd){
            memset(&repmsg, 0, sizeof repmsg);
            switch(op){
            case Oquery:
                dnserver(&reqmsg, &repmsg, &req, buf, rcode);
                break;
            case Onotify:
                dnnotify(&reqmsg, &repmsg, &req);
                break;
            }
            /* send reply on fd to address in buf's udp hdr */
            reply(fd, buf, &repmsg, &req);
            freeanswers(&repmsg);
        }

        p->inuse = 0;
freereq:
        free(req.from);
        req.from = nil;
        freeanswers(&reqmsg);
        if(req.isslave){
            putactivity(0);
            _exits(0);
        }
    }
}
@

<<function [[udpannounce]]([[(networking/ndb/dnudpserver.c)]])>>=
/*
 *  announce on well-known dns udp port and set message style interface
 */
static int
udpannounce(char *mntpt)
{
    int data, ctl;
    char dir[64], datafile[64+6];
    static int whined;

    /* get a udp port */
    sprint(datafile, "%s/udp!*!dns", mntpt);
    ctl = announce(datafile, dir);
    if(ctl < 0){
        if(!whined++)
            warning("can't announce on %s", datafile);
        return -1;
    }

    /* turn on header style interface */
    if(write(ctl, hmsg, strlen(hmsg)) != strlen(hmsg))
        abort();			/* hmsg */

    snprint(datafile, sizeof(datafile), "%s/data", dir);
    data = open(datafile, ORDWR);
    if(data < 0){
        close(ctl);
        if(!whined++)
            warning("can't open %s to announce on dns udp port",
                datafile);
        return -1;
    }

    close(ctl);
    return data;
}
@

<<function [[reply]]([[(networking/ndb/dnudpserver.c)]])>>=
static void
reply(int fd, uchar *buf, DNSmsg *rep, Request *reqp)
{
    int len;
    char tname[32];

    if(debug || (trace && subsume(trace, rep->qd->owner->name)))
        dnslog("%d: reply (%I/%d) %d %s %s qd %R an %R ns %R ar %R",
            reqp->id, buf, buf[4]<<8 | buf[5],
            rep->id, rep->qd->owner->name,
            rrname(rep->qd->type, tname, sizeof tname),
            rep->qd, rep->an, rep->ns, rep->ar);

    len = convDNS2M(rep, &buf[Udphdrsize], Maxudp);
    len += Udphdrsize;
    if(write(fd, buf, len) != len)
        dnslog("error sending reply: %r");
}
@


%-------------------------------------------------------------

<<networking/ndb/dnudpserver.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dns.h"

<<enum [[_anon_ (networking/ndb/dnudpserver.c)]]>>

static int	udpannounce(char*);
static void	reply(int, uchar*, DNSmsg*, Request*);

typedef struct Inprogress Inprogress;
<<struct [[Inprogress]]>>
<<global [[inprog]]>>

typedef struct Forwtarg Forwtarg;
<<struct [[Forwtarg]]>>
<<global [[forwtarg]]>>
<<global [[currtarg]]>>

<<global [[hmsg]]([[(networking/ndb/dnudpserver.c)]])>>

<<function [[clientrxmit]]>>

<<function [[addforwtarg]]>>

<<function [[redistrib]]>>

<<function [[dnudpserver]]>>

<<function [[udpannounce]]([[(networking/ndb/dnudpserver.c)]])>>

<<function [[reply]]([[(networking/ndb/dnudpserver.c)]])>>
@


\subsection*{[[networking/ndb/inform.c]]}

<<enum [[_anon_ (networking/ndb/inform.c)]]>>=
enum {
    FQDNMAX	= 255,
};
@

<<global [[errmsgs]]>>=
char *errmsgs[] = {
    [0]  "ok",
    [1]  "request format error",
    [2]  "internal server error",
    [3]  "domain name does not exist",
    [4]  "request not supported",
    [5]  "permission denied",
    [6]  "domain name already exists",
    [7]  "resource record already exists",
    [8]  "resource record does not exist",
    [9]  "server not authoritative",
    [10] "domain name not in zone",
};
@

<<function [[usage]]([[(networking/ndb/inform.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-x netmtpt]\n", argv0);
    exits("usage");
}
@

<<function [[ding]]([[(networking/ndb/inform.c)]])>>=
void
ding(void *, char *msg)
{
    if(strstr(msg, "alarm") != nil)
        noted(NCONT);
    noted(NDFLT);
}
@

<<function [[g16]]>>=
int
g16(uchar **p)
{
    int n;

    n  = *(*p)++ << 8;
    n |= *(*p)++;
    return n;
}
@

<<function [[p16]]>>=
void
p16(uchar **p, int n)
{
    *(*p)++ = n >> 8;
    *(*p)++ = n;
}
@

<<function [[p32]]>>=
void
p32(uchar **p, int n)
{
    *(*p)++ = n >> 24;
    *(*p)++ = n >> 16;
    *(*p)++ = n >> 8;
    *(*p)++ = n;
}
@

<<function [[pmem]]>>=
void
pmem(uchar **p, void *v, int len)
{
    memmove(*p, v, len);
    *p += len;
}
@

<<function [[pname]]([[(networking/ndb/inform.c)]])>>=
void
pname(uchar **p, char *s)
{
    uchar *len;

    while (*s){
        len = (*p)++;
        while(*s && *s != '.')
            *(*p)++ = *s++;
        *len = *p - len - 1;
        if(*s == '.')
            s++;
    }
    *(*p)++ = 0;
}
@

<<function [[main]]([[(networking/ndb/inform.c)]])>>=
void
main(int argc, char *argv[])
{
    int debug, len, fd;
    uint err;
    char *sysname, *dnsdomain, *dom, *inform, *ns, net[32];
    uchar *p, buf[4096], addr[IPv4addrlen], v6addr[IPaddrlen];
    ushort txid;
    Ndb *db;
    Ndbtuple *t, *tt;
    static char *query[] = { "dom", "dnsdomain", "ns", "inform" };

    fmtinstall('I', eipfmt);
    fmtinstall('V', eipfmt);
    setnetmtpt(net, sizeof net, nil);

    debug = 0;
    ns = nil;
    dom = nil;
    inform = nil;
    dnsdomain = nil;
    ARGBEGIN{
    case 'd':
        debug = 1;
        break;
    case 'x':
        setnetmtpt(net, sizeof net, EARGF(usage()));
        break;
    default:
        usage();
    }ARGEND;

    if(argc != 0)
        usage();

    if((sysname = getenv("sysname")) == nil)
        sysfatal("$sysname not set");

    if((db = ndbopen(nil)) == nil)
        sysfatal("can't open ndb: %r");
    tt = ndbipinfo(db, "sys", sysname, query, nelem(query));
    for(t = tt; t; t = t->entry){
        if(strcmp(t->attr, "ns") == 0)
            ns = t->val;
        else if(strcmp(t->attr, "dom") == 0)
            dom = t->val;
        else if(strcmp(t->attr, "dnsdomain") == 0)
            dnsdomain = t->val;
        else if(strcmp(t->attr, "inform") == 0)
            inform = t->val;
    }

    ndbfree(tt);
    ndbclose(db);

    if(inform)
        dom = inform;
    if(!ns)
        sysfatal("no relevant ns=");
    if(!dom)
        sysfatal("no relevant dom=");
    if(!dnsdomain)
        sysfatal("no relevant dnsdomain=");

    myipaddr(v6addr, net);
    memmove(addr, v6addr + IPaddrlen - IPv4addrlen, IPv4addrlen);

    if(debug){
        print("ip=%V\n", addr);
        print("ns=%s\n", ns);
        print("dnsdomain=%s\n", dnsdomain);
        print("dom=%s\n", dom);
    }

    if((fd = dial(netmkaddr(ns, "udp", "dns"), 0, 0, 0)) < 0)
        sysfatal("can't dial %s: %r", ns);

    txid = time(nil) + getpid();

    p = buf;
    p16(&p, txid);		/* ID */
    p16(&p, 5<<11);		/* flags */
    p16(&p, 1);		/* # Zones */
    p16(&p, 0);		/* # prerequisites */
    p16(&p, 2);		/* # updates */
    p16(&p, 0);		/* # additionals */

        pname(&p, dnsdomain);	/* zone */
    p16(&p, Tsoa);		/* zone type */
    p16(&p, Cin);		/* zone class */

    /* delete old name */
        pname(&p, dom);		/* name */
    p16(&p, Ta);		/* type: v4 addr */
    p16(&p, Call);		/* class */
    p32(&p, 0);		/* TTL */
    p16(&p, 0);		/* data len */

    /* add new A record */
    pname(&p, dom);		/* name */
    p16(&p, Ta);		/* type: v4 addr */
    p16(&p, Cin);		/* class */
    p32(&p, 60*60*25);	/* TTL (25 hours) */
    p16(&p, IPv4addrlen);	/* data len */
    pmem(&p, addr, IPv4addrlen);	/* v4 address */

    len = p - buf;
    if(write(fd, buf, len) != len)
        sysfatal("write failed: %r");

    notify(ding);
    alarm(3000);
    do{
        if(read(fd, buf, sizeof buf) < 0)
            sysfatal("timeout");
        p = buf;
    }while(g16(&p) != txid);
    alarm(0);

    close(fd);

    err = g16(&p) & 7;
    if(err != 0 && err != 7)	/* err==7 is just a "yes, I know" warning */
        if(err < nelem(errmsgs))
            sysfatal("%s", errmsgs[err]);
        else
            sysfatal("unknown dns server error %d", err);
    exits(0);
}
@
%$


%-------------------------------------------------------------

<<networking/ndb/inform.c>>=
/* RFC2136 DNS inform - necessary for Win2k3 DNS servers */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>
#include <ip.h>
#include "dns.h"

<<enum [[_anon_ (networking/ndb/inform.c)]]>>

<<global [[errmsgs]]>>

<<function [[usage]]([[(networking/ndb/inform.c)]])>>

<<function [[ding]]([[(networking/ndb/inform.c)]])>>

<<function [[g16]]>>

<<function [[p16]]>>

<<function [[p32]]>>

<<function [[pmem]]>>

<<function [[pname]]([[(networking/ndb/inform.c)]])>>

<<function [[main]]([[(networking/ndb/inform.c)]])>>
@


\subsection*{[[networking/ndb/ipquery.c]]}

<<function [[usage]]([[(networking/ndb/ipquery.c)]])>>=
/*
 *  search the database for matches
 */

void
usage(void)
{
    fprint(2, "usage: ipquery attr value rattribute\n");
    exits("usage");
}
@

<<function [[search]]>>=
void
search(Ndb *db, char *attr, char *val, char **rattr, int nrattr)
{
    Ndbtuple *t, *tt;

    tt = ndbipinfo(db, attr, val, rattr, nrattr);
    for(t = tt; t; t = t->entry)
        print("%s=%s ", t->attr, t->val);
    print("\n");
    ndbfree(tt);
}
@

<<function [[main]]([[(networking/ndb/ipquery.c)]])>>=
void
main(int argc, char **argv)
{
    Ndb *db;
    char *dbfile = 0;

    ARGBEGIN{
    case 'f':
        dbfile = ARGF();
        break;
    }ARGEND;

    if(argc < 3)
        usage();

    db = ndbopen(dbfile);
    if(db == 0){
        fprint(2, "no db files\n");
        exits("no db");
    }
    search(db, argv[0], argv[1], argv+2, argc-2);
    ndbclose(db);

    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ndb/ipquery.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>
#include <ip.h>

<<function [[usage]]([[(networking/ndb/ipquery.c)]])>>

<<function [[search]]>>

<<function [[main]]([[(networking/ndb/ipquery.c)]])>>
@


\subsection*{[[networking/ndb/mkdb.c]]}

<<global [[in]]>>=
Biobuf in;
@

<<global [[out]]([[(networking/ndb/mkdb.c)]])>>=
Biobuf out;
@

<<enum [[_anon_ (networking/ndb/mkdb.c)]]>>=
enum
{
    Empty,
    Sys,
    Dk,
    Ip,
    Domain,
};
@

<<function [[iscomment]]>>=
int
iscomment(char *name)
{
    return *name == '#';
}
@

<<function [[isdk]]>>=
/*
 *  is this a fully specified datakit name?
 */
int
isdk(char *name)
{
    int slash;

    slash = 0;
    for(; *name; name++){
        if(isalnum(*name))
            continue;
        if(*name == '/'){
            slash = 1;
            continue;
        }
        return 0;
    }
    return slash;
}
@

<<function [[isdomain]]>>=
/*
 *  Is this an internet domain name?
 */
int
isdomain(char *name)
{
    int dot = 0;
    int alpha = 0;

    for(; *name; name++){
        if(isalpha(*name) || *name == '-'){
            alpha = 1;
            continue;
        }
        if(*name == '.'){
            dot = 1;
            continue;
        }
        if(isdigit(*name))
            continue;
        return 0;
    }
    return dot && alpha;
}
@

<<function [[isip]]>>=
/*
 *  is this an ip address?
 */
int
isip(char *name)
{
    int dot = 0;

    for(; *name; name++){
        if(*name == '.'){
            dot = 1;
            continue;
        }
        if(isdigit(*name))
            continue;
        return 0;
    }
    return dot;
}
@

<<global [[tup]]>>=
char tup[64][64];
@

<<global [[ttype]]>>=
int ttype[64];
@

<<global [[ntup]]>>=
int ntup;
@

<<function [[tprint]]>>=
void
tprint(void)
{
    int i, tab;
    char *p;

    tab = 0;
    for(i = 0; i < ntup; i++){
        if(ttype[i] == Sys){
            Bprint(&out, "sys = %s\n", tup[i]);
            tab = 1;
            ttype[i] = Empty;
            break;
        }
    }
    for(i = 0; i < ntup; i++){
        if(ttype[i] == Empty)
            continue;
        if(tab)
            Bprint(&out, "\t");
        tab = 1;

        switch(ttype[i]){
        case Domain:
            Bprint(&out, "dom=%s\n", tup[i]);
            break;
        case Ip:
            Bprint(&out, "ip=%s\n", tup[i]);
            break;
        case Dk:
            p = strrchr(tup[i], '/');
            if(p){
                p++;
                if((*p == 'C' || *p == 'R')
                && strncmp(tup[i], "nj/astro/", p-tup[i]) == 0)
                    Bprint(&out, "flavor=console ");
            }
            Bprint(&out, "dk=%s\n", tup[i]);
            break;
        case Sys:
            Bprint(&out, "sys=%s\n", tup[i]);
            break;
        }
    }
}
@

<<constant [[NFIELDS]]>>=
#define NFIELDS 64
@

<<function [[main]]([[(networking/ndb/mkdb.c)]])>>=
/*
 *  make a database file from a merged uucp/inet database
 */
void
main(void)
{
    int n, i, j;
    char *l;
    char *fields[NFIELDS];
    int ftype[NFIELDS];
    int same, match;

    Binit(&in, 0, OREAD);
    Binit(&out, 1, OWRITE);
    ntup = 0;
    while(l = Brdline(&in, '\n')){
        l[Blinelen(&in)-1] = 0;
        n = getfields(l, fields, NFIELDS, 1, " \t");
        same = 0;
        for(i = 0; i < n; i++){
            if(iscomment(fields[i])){
                n = i;
                break;
            }
            if(isdomain(fields[i])){
                ftype[i] = Domain;
                for(j = 0; j < ntup; j++)
                    if(ttype[j] == Domain && strcmp(fields[i], tup[j]) == 0){
                        same = 1;
                        ftype[i] = Empty;
                        break;
                    }
            } else if(isip(fields[i]))
                ftype[i] = Ip;
            else if(isdk(fields[i]))
                ftype[i] = Dk;
            else
                ftype[i] = Sys;
        }
        if(!same && ntup){
            tprint();
            ntup = 0;
        }
        for(i = 0; i < n; i++){
            match = 0;
            for(j = 0; j < ntup; j++){
                if(ftype[i] == ttype[j] && strcmp(fields[i], tup[j]) == 0){
                    match = 1;
                    break;
                }
            }
            if(!match){
                ttype[ntup] = ftype[i];
                strcpy(tup[ntup], fields[i]);
                ntup++;
            }
        }
    }
    if(ntup)
        tprint();
    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ndb/mkdb.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

<<global [[in]]>>
<<global [[out]]([[(networking/ndb/mkdb.c)]])>>

<<enum [[_anon_ (networking/ndb/mkdb.c)]]>>

<<function [[iscomment]]>>

<<function [[isdk]]>>

<<function [[isdomain]]>>

<<function [[isip]]>>

<<global [[tup]]>>
<<global [[ttype]]>>
<<global [[ntup]]>>

<<function [[tprint]]>>

<<constant [[NFIELDS]]>>

<<function [[main]]([[(networking/ndb/mkdb.c)]])>>
@


\subsection*{[[networking/ndb/mkhash.c]]}

<<global [[ht]]([[(networking/ndb/mkhash.c)]])>>=
/*
 *  make the hash table completely in memory and then write as a file
 */

uchar *ht;
@

<<global [[hlen]]>>=
ulong hlen;
@

<<global [[db]]([[(networking/ndb/mkhash.c)]])>>=
Ndb *db;
@

<<global [[nextchain]]>>=
ulong nextchain;
@

<<function [[syserr]]([[(networking/ndb/mkhash.c)]])>>=
char*
syserr(void)
{
    static char buf[ERRMAX];

    errstr(buf, sizeof buf);
    return buf;
}
@

<<function [[enter]]>>=
void
enter(char *val, ulong dboff)
{
    ulong h;
    uchar *last;
    ulong ptr;

    h = ndbhash(val, hlen);
    h *= NDBPLEN;
    last = &ht[h];
    ptr = NDBGETP(last);
    if(ptr == NDBNAP){
        NDBPUTP(dboff, last);
        return;
    }

    if(ptr & NDBCHAIN){
        /* walk the chain to the last entry */
        for(;;){
            ptr &= ~NDBCHAIN;
            last = &ht[ptr+NDBPLEN];
            ptr = NDBGETP(last);
            if(ptr == NDBNAP){
                NDBPUTP(dboff, last);
                return;
            }
            if(!(ptr & NDBCHAIN)){
                NDBPUTP(nextchain|NDBCHAIN, last);
                break;
            }
        }
    } else
        NDBPUTP(nextchain|NDBCHAIN, last);

    /* add a chained entry */
    NDBPUTP(ptr, &ht[nextchain]);
    NDBPUTP(dboff, &ht[nextchain + NDBPLEN]);
    nextchain += 2*NDBPLEN;
}
@

<<global [[nbuf]]>>=
uchar nbuf[16*1024];
@

<<function [[main]]([[(networking/ndb/mkhash.c)]])>>=
void
main(int argc, char **argv)
{
    Ndbtuple *t, *nt;
    int n;
    Dir *d;	
    uchar buf[8];
    char file[128];
    int fd;
    ulong off;
    uchar *p;

    if(argc != 3){
        fprint(2, "usage: mkhash file attribute\n");
        exits("usage");
    }
    db = ndbopen(argv[1]);
    if(db == 0){
        fprint(2, "mkhash: can't open %s\n", argv[1]);
        exits(syserr());
    }

    /* try a bigger than normal buffer */
    Binits(&db->b, Bfildes(&db->b), OREAD, nbuf, sizeof(nbuf));

    /* count entries to calculate hash size */
    n = 0;

    while(nt = ndbparse(db)){
        for(t = nt; t; t = t->entry){
            if(strcmp(t->attr, argv[2]) == 0)
                n++;
        }
        ndbfree(nt);
    }

    /* allocate an array large enough for worst case */
    hlen = 2*n+1;
    n = hlen*NDBPLEN + hlen*2*NDBPLEN;
    ht = mallocz(n, 1);
    if(ht == 0){
        fprint(2, "mkhash: not enough memory\n");
        exits(syserr());
    }
    for(p = ht; p < &ht[n]; p += NDBPLEN)
        NDBPUTP(NDBNAP, p);
    nextchain = hlen*NDBPLEN;

    /* create the in core hash table */
    Bseek(&db->b, 0, 0);
    off = 0;
    while(nt = ndbparse(db)){
        for(t = nt; t; t = t->entry){
            if(strcmp(t->attr, argv[2]) == 0)
                enter(t->val, off);
        }
        ndbfree(nt);
        off = Boffset(&db->b);
    }

    /* create the hash file */
    snprint(file, sizeof(file), "%s.%s", argv[1], argv[2]);
    fd = create(file, ORDWR, 0664);
    if(fd < 0){
        fprint(2, "mkhash: can't create %s\n", file);
        exits(syserr());
    }
    NDBPUTUL(db->mtime, buf);
    NDBPUTUL(hlen, buf+NDBULLEN);
    if(write(fd, buf, NDBHLEN) != NDBHLEN){
        fprint(2, "mkhash: writing %s\n", file);
        exits(syserr());
    }
    if(write(fd, ht, nextchain) != nextchain){
        fprint(2, "mkhash: writing %s\n", file);
        exits(syserr());
    }
    close(fd);

    /* make sure file didn't change while we were making the hash */
    d = dirstat(argv[1]);
    if(d == nil || d->qid.path != db->qid.path
       || d->qid.vers != db->qid.vers){
        fprint(2, "mkhash: %s changed underfoot\n", argv[1]);
        remove(file);
        exits("changed");
    }

    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ndb/mkhash.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>

<<global [[ht]]([[(networking/ndb/mkhash.c)]])>>
<<global [[hlen]]>>
<<global [[db]]([[(networking/ndb/mkhash.c)]])>>
<<global [[nextchain]]>>

<<function [[syserr]]([[(networking/ndb/mkhash.c)]])>>

<<function [[enter]]>>

<<global [[nbuf]]>>

<<function [[main]]([[(networking/ndb/mkhash.c)]])>>
@


\subsection*{[[networking/ndb/mkhosts.c]]}

<<struct [[x]]>>=
typedef struct x
{
    Ndbtuple *t;
    Ndbtuple *it;
    Ndbtuple *nt;
} X;
@

<<global [[x]]>>=
X x[4096];
@

<<global [[nx]]>>=
int nx;
@

<<global [[domname]]>>=
char *domname = "research.att.com";
@

<<global [[domnamlen]]>>=
int domnamlen;
@

<<function [[upper]]>>=
char*
upper(char *x)
{
    char *p;
    int c;

    for(p = x; c = *p; p++)
        *p = toupper(c);
    return x;
}
@

<<function [[printArecord]]>>=
void
printArecord(int fd, X *p)
{
    Ndbtuple *nt;
    char *c;
    char *dom = 0;
    char *curdom = 0;
    int i, cdlen = 0;
    int mxweight = 0;

    if(p->nt) {
        return;
    }
    for(nt=p->t; nt; nt = nt->entry) {
        /* we are only going to handle things in the specified domain */
        c = strchr(nt->val, '.');
        if (c==0 || strcmp(++c, domname)!=0)
            continue;
        i = c - nt->val - 1;
        if(strcmp(nt->attr, "dom") == 0) {
            curdom = nt->val;
            cdlen = i;
            if (dom == 0) {
                dom = curdom;
                fprint(fd, "%-.*s%.*s	IN A	%s\n", i, nt->val, 15-i, "               ", p->it->val);
            } else
                fprint(fd, "%-.*s%.*s	IN CNAME	%s.\n", i, nt->val, 15-i, "               ", dom);
        } else if(strcmp(nt->attr, "mx") == 0) {
            if (curdom != 0)
                fprint(fd, "%-.*s%.*s	MX	%d	%s.\n", cdlen, curdom, 15-cdlen, "               ", mxweight++, nt->val);
        }
    }
}
@

<<function [[printentry]]>>=
void
printentry(int fd, X *p)
{
    Ndbtuple *nt;

    if(p->nt)
        return;
    fprint(fd, "%s	", p->it->val);
    for(nt = p->t; nt; nt = nt->entry)
        if(strcmp(nt->attr, "dom") == 0)
            fprint(fd, " %s", nt->val);
    for(nt = p->t; nt; nt = nt->entry)
        if(strcmp(nt->attr, "sys") == 0)
            fprint(fd, " %s", nt->val);
    fprint(fd, "\n");
}
@

<<function [[printsys]]>>=
void
printsys(int fd, X *p)
{
    Ndbtuple *nt;

    for(nt = p->t; nt; nt = nt->entry)
        if(strcmp(nt->attr, "dom") == 0)
            fprint(fd, "%s\n", nt->val);
}
@

<<function [[printtxt]]>>=
void
printtxt(int fd, X *p)
{
    int i;
    Ndbtuple *nt;

    if(p->nt){
        for(;;){
            i = strlen(p->it->val);
            if(strcmp(p->it->val+i-2, ".0") == 0)
                p->it->val[i-2] = 0;
            else
                break;
        }
        fprint(fd, "\nNET : %s : %s\n", p->it->val, upper(p->nt->val));
        return;
    }
    fprint(fd, "HOST : %s :", p->it->val);
    i = 0;
    for(nt = p->t; nt; nt = nt->entry)
        if(strcmp(nt->attr, "dom") == 0){
            if(i++ == 0)
                fprint(fd, " %s", upper(nt->val));
            else
                fprint(fd, ", %s", upper(nt->val));
        }
    fprint(fd, "\n");
}
@

<<function [[parse]]>>=
void
parse(char *file)
{
    int i;
    Ndb *db;
    Ndbtuple *t, *nt, *tt, *ipnett;
    char *p;

    db = ndbopen(file);
    if(db == 0)
        exits("no database");
    while(t = ndbparse(db)){
        for(nt = t; nt; nt = nt->entry){
            if(strcmp(nt->attr, "ip") == 0)
                break;
            if(strcmp(nt->attr, "flavor") == 0
            && strcmp(nt->val, "console") == 0)
                return;
        }
        if(nt == 0){
            ndbfree(t);
            continue;
        }

        /* dump anything not on our nets */
        ipnett = 0;
        for(tt = t; tt; tt = tt->entry){
            if(strcmp(tt->attr, "ipnet") == 0){
                ipnett = tt;
                break;
            }
            if(strcmp(tt->attr, "dom") == 0){
                i = strlen(tt->val);
                p = tt->val+i-domnamlen;
                if(p >= tt->val && strcmp(p, domname) == 0)
                    break;
            }
        }
        if(tt == 0){
            ndbfree(t);
            continue;
        }

        for(; nt; nt = nt->entry){
            if(strcmp(nt->attr, "ip") != 0)
                continue;
            x[nx].it = nt;
            x[nx].nt = ipnett;
            x[nx++].t = t;
        }
    }
}
@

<<function [[main]]([[(networking/ndb/mkhosts.c)]])>>=
void
main(int argc, char *argv[])
{
    int i, fd;
    char fn[128];

    if (argc>1)
        domname = argv[1];
    domnamlen = strlen(domname);
    if(argc > 2){
        for(i = 2; i < argc; i++)
            parse(argv[i]);
    } else {
        parse("/lib/ndb/local");
        parse("/lib/ndb/friends");
    }
    
//	sprint(fn, "/lib/ndb/hosts.%-.21s", domname);
//	fd = create(fn, OWRITE, 0664);
//	if(fd < 0){
//		fprint(2, "can't create %s: %r\n", fn);
//		exits("boom");
//	}
//	for(i = 0; i < nx; i++)
//		printentry(fd, &x[i]);
//	close(fd);
//

    sprint(fn, "/lib/ndb/db.%-.24s", domname);
    fd = create(fn, OWRITE, 0664);
    if(fd < 0){
        fprint(2, "can't create %s: %r\n", fn);
        exits("boom");
    }
    fprint(fd, "; This file is generated automatically, do not edit!\n");
    for(i = 0; i < nx; i++)
        printArecord(fd, &x[i]);
    close(fd);

    sprint(fn, "/lib/ndb/equiv.%-.21s", domname);
    fd = create(fn, OWRITE, 0664);
    if(fd < 0){
        fprint(2, "can't create %s: %r\n", fn);
        exits("boom");
    }
    for(i = 0; i < nx; i++)
        printsys(fd, &x[i]);
    close(fd);

    sprint(fn, "/lib/ndb/txt.%-.23s", domname);
    fd = create(fn, OWRITE, 0664);
    if(fd < 0){
        fprint(2, "can't create %s: %r\n", fn);
        exits("boom");
    }
    for(i = 0; i < nx; i++)
        printtxt(fd, &x[i]);
    close(fd);

    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ndb/mkhosts.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>
#include <ip.h>

<<struct [[x]]>>

<<global [[x]]>>
<<global [[nx]]>>
<<global [[domname]]>>
<<global [[domnamlen]]>>

<<function [[upper]]>>

<<function [[printArecord]]>>

<<function [[printentry]]>>

<<function [[printsys]]>>

<<function [[printtxt]]>>

<<function [[parse]]>>

<<function [[main]]([[(networking/ndb/mkhosts.c)]])>>
@


\subsection*{[[networking/ndb/query.c]]}

<<global [[bout]]>>=
static Biobuf bout;
@

<<function [[usage]]([[(networking/ndb/query.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: query [-am] [-f ndbfile] attr value "
        "[returned-attr [reps]]\n");
    exits("usage");
}
@

<<function [[prmatch]]>>=
/* print values of nt's attributes matching rattr */
static void
prmatch(Ndbtuple *nt, char *rattr)
{
    for(; nt; nt = nt->entry)
        if (strcmp(nt->attr, rattr) == 0)
            Bprint(&bout, "%s\n", nt->val);
}
@

<<function [[search]]([[(networking/ndb/query.c)]])>>=
void
search(Ndb *db, char *attr, char *val, char *rattr)
{
    char *p;
    Ndbs s;
    Ndbtuple *t, *nt;

    /* first entry with a matching rattr */
    if(rattr && !all){
        p = ndbgetvalue(db, &s, attr, val, rattr, &t);
        if (multiple)
            prmatch(t, rattr);
        else if(p)
            Bprint(&bout, "%s\n", p);
        ndbfree(t);
        free(p);
        return;
    }

    /* all entries with matching rattrs */
    if(rattr) {
        for(t = ndbsearch(db, &s, attr, val); t != nil;
            t = ndbsnext(&s, attr, val)){
            prmatch(t, rattr);
            ndbfree(t);
        }
        return;
    }

    /* all entries */
    for(t = ndbsearch(db, &s, attr, val); t; t = ndbsnext(&s, attr, val)){
        for(nt = t; nt; nt = nt->entry)
            Bprint(&bout, "%s=%s ", nt->attr, nt->val);
        Bprint(&bout, "\n");
        ndbfree(t);
    }
}
@

<<function [[main]]([[(networking/ndb/query.c)]])>>=
void
main(int argc, char **argv)
{
    int reps = 1;
    char *rattr = nil, *dbfile = nil;
    Ndb *db;
    
    ARGBEGIN{
    case 'a':
        all++;
        break;
    case 'm':
        multiple++;
        break;
    case 'f':
        dbfile = EARGF(usage());
        break;
    default:
        usage();
    }ARGEND;

    switch(argc){
    case 4:
        reps = atoi(argv[3]);	/* wtf use is this? */
        /* fall through */
    case 3:
        rattr = argv[2];
        break;
    case 2:
        rattr = nil;
        break;
    default:
        usage();
    }

    if(Binit(&bout, 1, OWRITE) == -1)
        sysfatal("Binit: %r");
    db = ndbopen(dbfile);
    if(db == nil){
        fprint(2, "%s: no db files\n", argv0);
        exits("no db");
    }
    while(reps--)
        search(db, argv[0], argv[1], rattr);
    ndbclose(db);

    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ndb/query.c>>=
/*
 *  search the network database for matches
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>

static int all, multiple;
<<global [[bout]]>>

<<function [[usage]]([[(networking/ndb/query.c)]])>>

<<function [[prmatch]]>>

<<function [[search]]([[(networking/ndb/query.c)]])>>

<<function [[main]]([[(networking/ndb/query.c)]])>>
@

\chapter{Extra Extra}

\section{[[networking/ip/]]}

\subsection*{[[networking/ip/dhcp.h]]}

<<enum [[_anon_ (networking/ip/dhcp.h)]]>>=
/* Dynamic Host Configuration Protocol / BOOTP */
enum
{
    OfferTimeout=	60,		/* when an offer times out */
    MaxLease=	60*60,		/* longest lease for dynamic binding */
    MinLease=	15*60,		/* shortest lease for dynamic binding */
    StaticLease=	30*60,		/* lease for static binding */

    IPUDPHDRSIZE=	28,		/* size of an IP plus UDP header */
    MINSUPPORTED=	576,		/* biggest IP message the client must support */

    /* lengths of some bootp fields */
    Maxhwlen=	16,
    Maxfilelen=	128,
    Maxoptlen=	312-4,

    /* bootp types */
    Bootrequest=	1,
    Bootreply= 	2,

    /* bootp flags */
    Fbroadcast=	1<<15,

    /* dhcp v4 types */
    Discover=	1,
    Offer=		2,
    Request=	3,
    Decline=	4,
    Ack=		5,
    Nak=		6,
    Release=	7,
    Inform=		8,

    /* bootp option types */
    OBend=			255,
    OBpad=			0,
    OBmask=			1,
    OBtimeoff=		2,
    OBrouter=		3,
    OBtimeserver=		4,
    OBnameserver=		5,
    OBdnserver=		6,
    OBlogserver=		7,
    OBcookieserver=		8,
    OBlprserver=		9,
    OBimpressserver=	10,
    OBrlserver=		11,
    OBhostname=		12,	/* 0x0c */
    OBbflen=		13,
    OBdumpfile=		14,
    OBdomainname=		15,
    OBswapserver=		16,	/* 0x10 */
    OBrootpath=		17,
    OBextpath=		18,
    OBipforward=		19,
    OBnonlocal=		20,
    OBpolicyfilter=		21,
    OBmaxdatagram=		22,
    OBttl=			23,
    OBpathtimeout=		24,
    OBpathplateau=		25,
    OBmtu=			26,
    OBsubnetslocal=		27,
    OBbaddr=		28,
    OBdiscovermask=		29,
    OBsupplymask=		30,
    OBdiscoverrouter=	31,
    OBrsserver=		32,	/* 0x20 */
    OBstaticroutes=		33,
    OBtrailerencap=		34,
    OBarptimeout=		35,
    OBetherencap=		36,
    OBtcpttl=		37,
    OBtcpka=		38,
    OBtcpkag=		39,
    OBnisdomain=		40,
    OBniserver=		41,
    OBntpserver=		42,
    OBvendorinfo=		43,	/* 0x2b */
    OBnetbiosns=		44,
    OBnetbiosdds=		45,
    OBnetbiostype=		46,
    OBnetbiosscope=		47,
    OBxfontserver=		48,	/* 0x30 */
    OBxdispmanager=		49,
    OBnisplusdomain=	64,	/* 0x40 */
    OBnisplusserver=	65,
    OBhomeagent=		68,
    OBsmtpserver=		69,
    OBpop3server=		70,
    OBnntpserver=		71,
    OBwwwserver=		72,
    OBfingerserver=		73,
    OBircserver=		74,
    OBstserver=		75,
    OBstdaserver=		76,

    /* dhcp v4 options */
    ODipaddr=		50,	/* 0x32 */
    ODlease=		51,
    ODoverload=		52,
    ODtype=			53,	/* 0x35 */
    ODserverid=		54,	/* 0x36 */
    ODparams=		55,	/* 0x37 */
    ODmessage=		56,
    ODmaxmsg=		57,
    ODrenewaltime=		58,
    ODrebindingtime=	59,
    ODvendorclass=		60,
    ODclientid=		61,	/* 0x3d */
    ODtftpserver=		66,
    ODbootfile=		67,

    ODpxearch=		93,	/* see rfc 4578 */
    ODpxeni=		94,
    ODpxeguid=		97,

    /* plan9 vendor info options, v4 addresses only (deprecated) */
    OP9fsv4=		128,	/* plan9 file servers */
    OP9authv4=		129,	/* plan9 auth servers */

    /* plan9 vendor info options, textual addresses, thus v4 or v6 */
    OP9fs=			130,	/* plan9 file servers */
    OP9auth=		131,	/* plan9 auth servers */
    OP9ipaddr=		132,	/* client's address */
    OP9ipmask=		133,	/* client's subnet mask */
    OP9ipgw=		134,	/* client's gateway */
/*	OP9dns=			135,	/* dns servers */
};
@

<<constant [[Lforever]]>>=
/* a lease that never expires */
#define Lforever	~0UL
@

<<enum [[_anon_ (networking/ip/dhcp.h)2]]>>=
/* dhcp states */
enum {
    Sinit,
    Sselecting,
    Srequesting,
    Sbound,
    Srenewing,
    Srebinding,
};
@

<<struct [[Bootp]]>>=
struct Bootp
{
    /* Udphdr (included because of structure alignment on the alpha) */
    uchar	udphdr[Udphdrsize];

    uchar	op;			/* opcode */
    uchar	htype;			/* hardware type */
    uchar	hlen;			/* hardware address len */
    uchar	hops;			/* hops */
    uchar	xid[4];			/* a random number */
    uchar	secs[2];		/* elapsed since client started booting */
    uchar	flags[2];
    uchar	ciaddr[IPv4addrlen];	/* client IP address (client tells server) */
    uchar	yiaddr[IPv4addrlen];	/* client IP address (server tells client) */
    uchar	siaddr[IPv4addrlen];	/* server IP address */
    uchar	giaddr[IPv4addrlen];	/* gateway IP address */
    uchar	chaddr[Maxhwlen];	/* client hardware address */
    char	sname[64];		/* server host name (optional) */
    char	file[Maxfilelen];	/* boot file name */
    uchar	optmagic[4];
    uchar	optdata[Maxoptlen];
};
@


%-------------------------------------------------------------

<<networking/ip/dhcp.h>>=
<<enum [[_anon_ (networking/ip/dhcp.h)]]>>

<<constant [[Lforever]]>>

<<enum [[_anon_ (networking/ip/dhcp.h)2]]>>

typedef struct Bootp	Bootp;
<<struct [[Bootp]]>>
@


\subsection*{[[networking/ip/dhcpclient.c]]}

<<global [[dhcp]]([[(networking/ip/dhcpclient.c)]])>>=
struct {
    QLock	lk;
    int	state;
    int	fd;
    ulong	xid;
    ulong	starttime;
    char	cid[100];
    char	sname[64];
    uchar	server[IPaddrlen];		/* server IP address */
    uchar	client[IPaddrlen];		/* client IP address */
    uchar	mask[IPaddrlen];		/* client mask */
    ulong	lease;		/* lease time */
    ulong	resend;		/* number of resends for current state */
    ulong	timeout;	/* time to timeout - seconds */
} dhcp;
@

<<global [[net]]([[(networking/ip/dhcpclient.c)]])>>=
char	net[64];
@

<<global [[optmagic]]([[(networking/ip/dhcpclient.c)]])>>=
char optmagic[4] = { 0x63, 0x82, 0x53, 0x63 };
@

<<function [[main]]([[(networking/ip/dhcpclient.c)]])>>=
void
main(int argc, char *argv[])
{
    char *p;

    setnetmtpt(net, sizeof(net), nil);

    ARGBEGIN{
    case 'x':
        p = ARGF();
        if(p == nil)
            usage();
        setnetmtpt(net, sizeof(net), p);
    }ARGEND;

    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('V', eipfmt);

    dhcpinit();

    rfork(RFNOTEG|RFREND);

    thread(timerthread, 0);
    thread(stdinthread, 0);

    qlock(&dhcp.lk);
    dhcp.starttime = time(0);
    dhcp.fd = openlisten(net);
    dhcpsend(Discover);
    dhcp.state = Sselecting;
    dhcp.resend = 0;
    dhcp.timeout = 4;

    while(dhcp.state != Sbound)
        dhcprecv();

    /* allows other clients on this machine */
    close(dhcp.fd);
    dhcp.fd = -1;

    print("ip=%I\n", dhcp.client);
    print("mask=%I\n", dhcp.mask);
    print("end\n");

    /* keep lease alive */
    for(;;) {
//fprint(2, "got lease for %d\n", dhcp.lease);
        qunlock(&dhcp.lk);
        sleep(dhcp.lease*500);	/* wait half of lease time */
        qlock(&dhcp.lk);

//fprint(2, "try renue\n", dhcp.lease);
        dhcp.starttime = time(0);
        dhcp.fd = openlisten(net);
        dhcp.xid = time(0)*getpid();
        dhcpsend(Request);
        dhcp.state = Srenewing;
        dhcp.resend = 0;
        dhcp.timeout = 1;

        while(dhcp.state != Sbound)
            dhcprecv();

        /* allows other clients on this machine */
        close(dhcp.fd);
        dhcp.fd = -1;
    }
}
@

<<function [[usage]]([[(networking/ip/dhcpclient.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-x netextension]\n", argv0);
    exits("usage");
}
@

<<function [[timerthread]]>>=
void
timerthread(void*)
{
    for(;;) {
        sleep(1000);
        qlock(&dhcp.lk);
        if(--dhcp.timeout > 0) {
            qunlock(&dhcp.lk);
            continue;
        }

        switch(dhcp.state) {
        default:
            myfatal("timerthread: unknown state %d", dhcp.state);
        case Sinit:
            break;
        case Sselecting:
            dhcpsend(Discover);
            dhcp.timeout = 4;
            dhcp.resend++;
            if(dhcp.resend>5)
                myfatal("dhcp: giving up: selecting");
            break;
        case Srequesting:
            dhcpsend(Request);
            dhcp.timeout = 4;
            dhcp.resend++;
            if(dhcp.resend>5)
                myfatal("dhcp: giving up: requesting");
            break;
        case Srenewing:
            dhcpsend(Request);
            dhcp.timeout = 1;
            dhcp.resend++;
            if(dhcp.resend>3) {
                dhcp.state = Srebinding;
                dhcp.resend = 0;
            }
            break;
        case Srebinding:
            dhcpsend(Request);
            dhcp.timeout = 4;
            dhcp.resend++;
            if(dhcp.resend>5)
                myfatal("dhcp: giving up: rebinding");
            break;
        case Sbound:
            break;
        }
        qunlock(&dhcp.lk);
    }
}
@

<<function [[stdinthread]]>>=
void
stdinthread(void*)
{
    uchar buf[100];
    int n;

    for(;;) {
        n = read(0, buf, sizeof(buf));
        if(n <= 0)
            break;
    }
    /* shutdown cleanly */
    qlock(&dhcp.lk);
    if(dhcp.client) {
        if(dhcp.fd < 0)
            dhcp.fd = openlisten(net);
        dhcpsend(Release);
    }
    qunlock(&dhcp.lk);

    postnote(PNGROUP, getpid(), "die");
    exits(0);
}
@

<<function [[dhcpinit]]>>=
void
dhcpinit(void)
{
    int fd;

    dhcp.state = Sinit;
    dhcp.timeout = 4;

    fd = open("/dev/random", 0);
    if(fd >= 0) {
        read(fd, &dhcp.xid, sizeof(dhcp.xid));
        close(fd);
    } else
        dhcp.xid = time(0)*getpid();
    srand(dhcp.xid);

    sprint(dhcp.cid, "%s.%d", getenv("sysname"), getpid());
}
@

<<function [[dhcpsend]]([[(networking/ip/dhcpclient.c)]])>>=
void
dhcpsend(int type)
{
    int n;
    uchar *p;
    Bootp bp;
    Udphdr *up;

    memset(&bp, 0, sizeof bp);
    up = (Udphdr*)bp.udphdr;

    hnputs(up->rport, 67);
    bp.op = Bootrequest;
    hnputl(bp.xid, dhcp.xid);
    hnputs(bp.secs, time(0) - dhcp.starttime);
    hnputs(bp.flags, Fbroadcast);		/* reply must be broadcast */
    memmove(bp.optmagic, optmagic, 4);
    p = bp.optdata;
    p = optaddbyte(p, ODtype, type);
    p = optadd(p, ODclientid, dhcp.cid, strlen(dhcp.cid));
    switch(type) {
    default:
        myfatal("dhcpsend: unknown message type: %d", type);
    case Discover:
        ipmove(up->raddr, IPv4bcast);	/* broadcast */
        break;
    case Request:
        if(dhcp.state == Sbound || dhcp.state == Srenewing)
            ipmove(up->raddr, dhcp.server);
        else
            ipmove(up->raddr, IPv4bcast);	/* broadcast */
        p = optaddulong(p, ODlease, dhcp.lease);
        if(dhcp.state == Sselecting || dhcp.state == Srequesting) {
            p = optaddaddr(p, ODipaddr, dhcp.client);	/* mistake?? */
            p = optaddaddr(p, ODserverid, dhcp.server);
        } else
            v6tov4(bp.ciaddr, dhcp.client);
        break;
    case Release:
        ipmove(up->raddr, dhcp.server);
        v6tov4(bp.ciaddr, dhcp.client);
        p = optaddaddr(p, ODipaddr, dhcp.client);
        p = optaddaddr(p, ODserverid, dhcp.server);
        break;
    }

    *p++ = OBend;

    n = p - (uchar*)&bp;

    if(write(dhcp.fd, &bp, n) != n)
        myfatal("dhcpsend: write failed: %r");
}
@

<<function [[dhcprecv]]([[(networking/ip/dhcpclient.c)]])>>=
void
dhcprecv(void)
{
    uchar buf[2000];
    Bootp *bp;
    int n, type;
    ulong lease;
    uchar mask[IPaddrlen];

    qunlock(&dhcp.lk);
    n = read(dhcp.fd, buf, sizeof(buf));
    qlock(&dhcp.lk);

    if(n <= 0)
        myfatal("dhcprecv: bad read: %r");

    bp = parse(buf, n);
    if(bp == 0)
        return;

if(1) {
fprint(2, "recved\n");
bootpdump(buf, n);
}

    type = optgetbyte(bp, ODtype);
    switch(type) {
    default:
        fprint(2, "dhcprecv: unknown type: %d\n", type);
        break;
    case Offer:
        if(dhcp.state != Sselecting)
            break;
        lease = optgetulong(bp, ODlease);
        if(lease == 0)
            myfatal("bad lease");
        if(!optgetaddr(bp, OBmask, mask))
            memset(mask, 0xff, sizeof(mask));
        v4tov6(dhcp.client, bp->yiaddr);
        if(!optgetaddr(bp, ODserverid, dhcp.server)) {
            fprint(2, "dhcprecv: Offer from server with invalid serverid\n");
            break;
        }

        dhcp.lease = lease;
        ipmove(dhcp.mask, mask);
        memmove(dhcp.sname, bp->sname, sizeof(dhcp.sname));
        dhcp.sname[sizeof(dhcp.sname)-1] = 0;

        dhcpsend(Request);
        dhcp.state = Srequesting;
        dhcp.resend = 0;
        dhcp.timeout = 4;
        break;
    case Ack:
        if(dhcp.state != Srequesting)
        if(dhcp.state != Srenewing)
        if(dhcp.state != Srebinding)
            break;
        lease = optgetulong(bp, ODlease);
        if(lease == 0)
            myfatal("bad lease");
        if(!optgetaddr(bp, OBmask, mask))
            memset(mask, 0xff, sizeof(mask));
        v4tov6(dhcp.client, bp->yiaddr);
        dhcp.lease = lease;
        ipmove(dhcp.mask, mask);
        dhcp.state = Sbound;
        break;
    case Nak:
        myfatal("recved nak");
        break;
    }

}
@

<<function [[openlisten]]([[(networking/ip/dhcpclient.c)]])>>=
int
openlisten(char *net)
{
    int n, fd, cfd;
    char data[128], devdir[40];

//	sprint(data, "%s/udp!*!bootpc", net);
    sprint(data, "%s/udp!*!68", net);
    for(n = 0; ; n++) {
        cfd = announce(data, devdir);
        if(cfd >= 0)
            break;
        /* might be another client - wait and try again */
        fprint(2, "dhcpclient: can't announce %s: %r", data);
        sleep(1000);
        if(n > 10)
            myfatal("can't announce: giving up: %r");
    }

    if(fprint(cfd, "headers") < 0)
        myfatal("can't set header mode: %r");

    sprint(data, "%s/data", devdir);
    fd = open(data, ORDWR);
    if(fd < 0)
        myfatal("open %s: %r", data);
    close(cfd);
    return fd;
}
@

<<function [[optadd]]([[(networking/ip/dhcpclient.c)]])>>=
uchar*
optadd(uchar *p, int op, void *d, int n)
{
    p[0] = op;
    p[1] = n;
    memmove(p+2, d, n);
    return p+n+2;
}
@

<<function [[optaddbyte]]([[(networking/ip/dhcpclient.c)]])>>=
uchar*
optaddbyte(uchar *p, int op, int b)
{
    p[0] = op;
    p[1] = 1;
    p[2] = b;
    return p+3;
}
@

<<function [[optaddulong]]([[(networking/ip/dhcpclient.c)]])>>=
uchar*
optaddulong(uchar *p, int op, ulong x)
{
    p[0] = op;
    p[1] = 4;
    hnputl(p+2, x);
    return p+6;
}
@

<<function [[optaddaddr]]([[(networking/ip/dhcpclient.c)]])>>=
uchar *
optaddaddr(uchar *p, int op, uchar *ip)
{
    p[0] = op;
    p[1] = 4;
    v6tov4(p+2, ip);
    return p+6;
}
@

<<function [[optget]]([[(networking/ip/dhcpclient.c)]])>>=
uchar*
optget(Bootp *bp, int op, int n)
{
    int len, code;
    uchar *p;

    p = bp->optdata;
    for(;;) {
        code = *p++;
        if(code == OBpad)
            continue;
        if(code == OBend)
            return 0;
        len = *p++;
        if(code != op) {
            p += len;
            continue;
        }
        if(n && n != len)
            return 0;
        return p;
    }
}
@

<<function [[optgetbyte]]([[(networking/ip/dhcpclient.c)]])>>=
int
optgetbyte(Bootp *bp, int op)
{
    uchar *p;

    p = optget(bp, op, 1);
    if(p == 0)
        return 0;
    return *p;
}
@

<<function [[optgetulong]]([[(networking/ip/dhcpclient.c)]])>>=
ulong
optgetulong(Bootp *bp, int op)
{
    uchar *p;

    p = optget(bp, op, 4);
    if(p == 0)
        return 0;
    return nhgetl(p);
}
@

<<function [[optgetaddr]]([[(networking/ip/dhcpclient.c)]])>>=
int
optgetaddr(Bootp *bp, int op, uchar *ip)
{
    uchar *p;

    p = optget(bp, op, 4);
    if(p == 0)
        return 0;
    v4tov6(ip, p);
    return 1;
}
@

<<function [[parse]]([[(networking/ip/dhcpclient.c)]])>>=
/* make sure packet looks ok */
Bootp *
parse(uchar *p, int n)
{
    int len, code;
    Bootp *bp;

    bp = (Bootp*)p;
    if(n < bp->optmagic - p) {
        fprint(2, "dhcpclient: parse: short bootp packet");
        return 0;
    }

    if(dhcp.xid != nhgetl(bp->xid)) {
        fprint(2, "dhcpclient: parse: bad xid: got %ux expected %lux\n",
            nhgetl(bp->xid), dhcp.xid);
        return 0;
    }

    if(bp->op != Bootreply) {
        fprint(2, "dhcpclient: parse: bad op\n");
        return 0;
    }

    n -= bp->optmagic - p;
    p = bp->optmagic;

    if(n < 4) {
        fprint(2, "dhcpclient: parse: not option data");
        return 0;
    }
    if(memcmp(optmagic, p, 4) != 0) {
        fprint(2, "dhcpclient: parse: bad opt magic %ux %ux %ux %ux\n",
            p[0], p[1], p[2], p[3]);
        return 0;
    }
    p += 4;
    n -= 4;
    while(n>0) {
        code = *p++;
        n--;
        if(code == OBpad)
            continue;
        if(code == OBend)
            return bp;
        if(n == 0) {
            fprint(2, "dhcpclient: parse: bad option: %d", code);
            return 0;
        }
        len = *p++;
        n--;
        if(len > n) {
            fprint(2, "dhcpclient: parse: bad option: %d", code);
            return 0;
        }
        p += len;
        n -= len;
    }

    /* fix up nonstandard packets */
    /* assume there is space */
    *p = OBend;

    return bp;
}
@

<<function [[bootpdump]]>>=
void
bootpdump(uchar *p, int n)
{
    int len, i, code;
    Bootp *bp;
    Udphdr *up;

    bp = (Bootp*)p;
    up = (Udphdr*)bp->udphdr;

    if(n < bp->optmagic - p) {
        fprint(2, "dhcpclient: short bootp packet");
        return;
    }

    fprint(2, "laddr=%I lport=%d raddr=%I rport=%d\n", up->laddr,
        nhgets(up->lport), up->raddr, nhgets(up->rport));
    fprint(2, "op=%d htype=%d hlen=%d hops=%d\n", bp->op, bp->htype,
        bp->hlen, bp->hops);
    fprint(2, "xid=%ux secs=%d flags=%ux\n", nhgetl(bp->xid),
        nhgets(bp->secs), nhgets(bp->flags));
    fprint(2, "ciaddr=%V yiaddr=%V siaddr=%V giaddr=%V\n",
        bp->ciaddr, bp->yiaddr, bp->siaddr, bp->giaddr);
    fprint(2, "chaddr=");
    for(i=0; i<16; i++)
        fprint(2, "%ux ", bp->chaddr[i]);
    fprint(2, "\n");
    fprint(2, "sname=%s\n", bp->sname);
    fprint(2, "file = %s\n", bp->file);

    n -= bp->optmagic - p;
    p = bp->optmagic;

    if(n < 4)
        return;
    if(memcmp(optmagic, p, 4) != 0)
        fprint(2, "dhcpclient: bad opt magic %ux %ux %ux %ux\n",
            p[0], p[1], p[2], p[3]);
    p += 4;
    n -= 4;

    while(n>0) {
        code = *p++;
        n--;
        if(code == OBpad)
            continue;
        if(code == OBend)
            break;
        if(n == 0) {
            fprint(2, " bad option: %d", code);
            return;
        }
        len = *p++;
        n--;
        if(len > n) {
            fprint(2, " bad option: %d", code);
            return;
        }
        switch(code) {
        default:
            fprint(2, "unknown option %d\n", code);
            for(i = 0; i<len; i++)
                fprint(2, "%ux ", p[i]);
        case ODtype:
            fprint(2, "DHCP type %d\n", p[0]);
            break;
        case ODclientid:
            fprint(2, "client id=");
            for(i = 0; i<len; i++)
                fprint(2, "%ux ", p[i]);
            fprint(2, "\n");
            break;
        case ODlease:
            fprint(2, "lease=%d\n", nhgetl(p));
            break;
        case ODserverid:
            fprint(2, "server id=%V\n", p);
            break;
        case OBmask:
            fprint(2, "mask=%V\n", p);
            break;
        case OBrouter:
            fprint(2, "router=%V\n", p);
            break;
        }
        p += len;
        n -= len;
    }
}
@

<<function [[thread]]>>=
ulong
thread(void(*f)(void*), void *a)
{
    int pid;

    pid = rfork(RFNOWAIT|RFMEM|RFPROC);
    if(pid < 0)
        myfatal("rfork failed: %r");
    if(pid != 0)
        return pid;
    (*f)(a);
    return 0;	/* never reaches here */
}
@

<<function [[myfatal]]>>=
void
myfatal(char *fmt, ...)
{
    char buf[1024];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    fprint(2, "%s: %s\n", argv0, buf);
    postnote(PNGROUP, getpid(), "die");
    exits(buf);
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpclient.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "dhcp.h"

void	bootpdump(uchar *p, int n);
void	dhcpinit(void);
void	dhcprecv(void);
void	dhcpsend(int);
void	myfatal(char *fmt, ...);
int	openlisten(char*);
uchar	*optaddaddr(uchar*, int, uchar*);
uchar	*optaddbyte(uchar*, int, int);
uchar	*optadd(uchar*, int, void*, int);
uchar	*optaddulong(uchar*, int, ulong);
uchar	*optget(Bootp*, int, int);
int	optgetaddr(Bootp*, int, uchar*);
int	optgetbyte(Bootp*, int);
ulong	optgetulong(Bootp*, int);
Bootp	*parse(uchar*, int);
void	stdinthread(void*);
ulong	thread(void(*f)(void*), void *a);
void	timerthread(void*);
void	usage(void);

<<global [[dhcp]]([[(networking/ip/dhcpclient.c)]])>>

<<global [[net]]([[(networking/ip/dhcpclient.c)]])>>

<<global [[optmagic]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[main]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[usage]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[timerthread]]>>

<<function [[stdinthread]]>>

<<function [[dhcpinit]]>>

<<function [[dhcpsend]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[dhcprecv]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[openlisten]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[optadd]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[optaddbyte]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[optaddulong]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[optaddaddr]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[optget]]([[(networking/ip/dhcpclient.c)]])>>


<<function [[optgetbyte]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[optgetulong]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[optgetaddr]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[parse]]([[(networking/ip/dhcpclient.c)]])>>

<<function [[bootpdump]]>>

<<function [[thread]]>>

<<function [[myfatal]]>>
@


\section{[[networking/ip/dhcpd/]]}

\subsection*{[[networking/ip/dhcpd/dat.h]]}

<<enum [[_anon_ (networking/ip/dhcpd/dat.h)]]>>=
enum
{
    Maxstr=	256,
};
@

<<struct [[Binding]]>>=
struct Binding
{
    Binding *next;
    uchar	ip[IPaddrlen];

    char	*boundto;	/* id last bound to */
    char	*offeredto;	/* id we've offered this to */

    long	lease;		/* absolute time at which binding expires */
    long	expoffer;	/* absolute time at which offer times out */
    long	offer;		/* lease offered */
    long	lasttouched;	/* time this entry last assigned/unassigned */
    long	lastcomplained;	/* last time we complained about a used but not leased */
    long	tried;		/* last time we tried this entry */

    Qid	q;		/* qid at the last syncbinding */
};
@

<<struct [[Info]]>>=
struct Info
{
    int	indb;			/* true if found in database */
    char	domain[Maxstr];	/* system domain name */
    char	bootf[Maxstr];		/* boot file */
    char	bootf2[Maxstr];	/* alternative boot file */
    uchar	tftp[NDB_IPlen];	/* ip addr of tftp server */
    uchar	tftp2[NDB_IPlen];	/* ip addr of alternate server */
    uchar	ipaddr[NDB_IPlen];	/* ip address of system */
    uchar	ipmask[NDB_IPlen];	/* ip network mask */
    uchar	ipnet[NDB_IPlen];	/* ip network address (ipaddr & ipmask) */
    uchar	etheraddr[6];		/* ethernet address */
    uchar	gwip[NDB_IPlen];	/* gateway ip address */
    uchar	fsip[NDB_IPlen];	/* file system ip address */
    uchar	auip[NDB_IPlen];	/* authentication server ip address */
    char	rootpath[Maxstr];	/* rootfs for diskless nfs clients */
    char	dhcpgroup[Maxstr];
    char	vendor[Maxstr];	/* vendor info */
};
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/dat.h>>=
#include "../dhcp.h"

<<enum [[_anon_ (networking/ip/dhcpd/dat.h)]]>>

typedef struct Binding Binding;
<<struct [[Binding]]>>

typedef struct Info	Info;
<<struct [[Info]]>>


/* from dhcp.c */
extern int	validip(uchar*);
extern void	warning(int, char*, ...);
extern int	minlease;

/* from db.c */
extern char*	tohex(char*, uchar*, int);
extern char*	toid(uchar*, int);
extern void	initbinding(uchar*, int);
extern Binding*	iptobinding(uchar*, int);
extern Binding*	idtobinding(char*, Info*, int);
extern Binding*	idtooffer(char*, Info*);
extern int	commitbinding(Binding*);
extern int	releasebinding(Binding*, char*);
extern int	samenet(uchar *ip, Info *iip);
extern void	mkoffer(Binding*, char*, long);
extern int	syncbinding(Binding*, int);

/* from ndb.c */
extern int	lookup(Bootp*, Info*, Info*);
extern int	lookupip(uchar*, Info*, int);
extern void	lookupname(char*, Ndbtuple*);
extern Iplifc*	findlifc(uchar*);
extern int	forme(uchar*);
extern int	lookupserver(char*, uchar**, Ndbtuple *t);
extern Ndbtuple* lookupinfo(uchar *ipaddr, char **attr, int n);

/* from icmp.c */
extern int	icmpecho(uchar*);

extern char	*binddir;
extern int	debug;
extern char	*blog;
extern Ipifc	*ipifcs;
extern long	now;
extern char	*ndbfile;

@


\subsection*{[[networking/ip/dhcpd/db.c]]}

<<global [[bcache]]>>=
/*
 *  format of a binding entry:
 *	char ipaddr[32];
 *	char id[32];
 *	char hwa[32];
 *	char otime[10];
 */
Binding *bcache;
@

<<global [[bfirst]]>>=
uchar bfirst[IPaddrlen];
@

<<global [[binddir]]>>=
char *binddir = "/lib/ndb/dhcp";
@

<<function [[hex]]([[(networking/ip/dhcpd/db.c)]])>>=
/*
 *  convert a byte array to hex
 */
static char
hex(int x)
{
    if(x < 10)
        return x + '0';
    return x - 10 + 'a';
}
@

<<function [[tohex]]>>=
extern char*
tohex(char *hdr, uchar *p, int len)
{
    char *s, *sp;
    int hlen;

    hlen = strlen(hdr);
    s = malloc(hlen + 2*len + 1);
    sp = s;
    strcpy(sp, hdr);
    sp += hlen;
    for(; len > 0; len--){
        *sp++ = hex(*p>>4);
        *sp++ = hex(*p & 0xf);
        p++;
    }
    *sp = 0;
    return s;
}
@

<<function [[toid]]>>=
/*
 *  convert a client id to a string.  If it's already
 *  ascii, leave it be.  Otherwise, convert it to hex.
 */
extern char*
toid(uchar *p, int n)
{
    int i;
    char *s;

    for(i = 0; i < n; i++)
        if(!isprint(p[i]))
            return tohex("id", p, n);
    s = malloc(n + 1);
    memmove(s, p, n);
    s[n] = 0;
    return s;
}
@

<<function [[incip]]>>=
/*
 *  increment an ip address
 */
static void
incip(uchar *ip)
{
    int i, x;

    for(i = IPaddrlen-1; i >= 0; i--){
        x = ip[i];
        x++;
        ip[i] = x;
        if((x & 0x100) == 0)
            break;
    }
}
@

<<function [[lockopen]]>>=
/*
 *  find a binding for an id or hardware address
 */
static int
lockopen(char *file)
{
    char err[ERRMAX];
    int fd, tries;

    for(tries = 0; tries < 5; tries++){
        fd = open(file, ORDWR);
        if(fd >= 0)
            return fd;
        errstr(err, sizeof err);
        if(strstr(err, "lock")){
            /* wait for other process to let go of lock */
            sleep(250);

            /* try again */
            continue;
        }
        if(strstr(err, "exist")){
            /* no file, create an exclusive access file */
            fd = create(file, ORDWR, DMEXCL|0664);
            if(fd >= 0)
                return fd;
        }
    }
    return -1;
}
@

<<function [[setbinding]]>>=
void
setbinding(Binding *b, char *id, long t)
{
    if(b->boundto)
        free(b->boundto);

    b->boundto = strdup(id);
    b->lease = t;
}
@

<<function [[parsebinding]]>>=
static void
parsebinding(Binding *b, char *buf)
{
    long t;
    char *id, *p;

    /* parse */
    t = atoi(buf);
    id = strchr(buf, '\n');
    if(id){
        *id++ = 0;
        p = strchr(id, '\n');
        if(p)
            *p = 0;
    } else
        id = "";

    /* replace any past info */
    setbinding(b, id, t);
}
@

<<function [[writebinding]]>>=
static int
writebinding(int fd, Binding *b)
{
    Dir *d;

    seek(fd, 0, 0);
    if(fprint(fd, "%ld\n%s\n", b->lease, b->boundto) < 0)
        return -1;
    d = dirfstat(fd);
    if(d == nil)
        return -1;
    b->q.type = d->qid.type;
    b->q.path = d->qid.path;
    b->q.vers = d->qid.vers;
    free(d);
    return 0;
}
@

<<function [[syncbinding]]>>=
/*
 *  synchronize cached binding with file.  the file always wins.
 */
int
syncbinding(Binding *b, int returnfd)
{
    char buf[512];
    int i, fd;
    Dir *d;

    snprint(buf, sizeof(buf), "%s/%I", binddir, b->ip);
    fd = lockopen(buf);
    if(fd < 0){
        /* assume someone else is using it */
        b->lease = time(0) + OfferTimeout;
        return -1;
    }

    /* reread if changed */
    d = dirfstat(fd);
    if(d != nil)	/* BUG? */
    if(d->qid.type != b->q.type || d->qid.path != b->q.path || d->qid.vers != b->q.vers){
        i = read(fd, buf, sizeof(buf)-1);
        if(i < 0)
            i = 0;
        buf[i] = 0;
        parsebinding(b, buf);
        b->lasttouched = d->mtime;
        b->q.path = d->qid.path;
        b->q.vers = d->qid.vers;
    }

    free(d);

    if(returnfd)
        return fd;

    close(fd);
    return 0;
}
@

<<function [[samenet]]>>=
extern int
samenet(uchar *ip, Info *iip)
{
    uchar x[IPaddrlen];

    maskip(iip->ipmask, ip, x);
    return ipcmp(x, iip->ipnet) == 0;
}
@

<<function [[initbinding]]>>=
/*
 *  create a record for each binding
 */
extern void
initbinding(uchar *first, int n)
{
    while(n-- > 0){
        iptobinding(first, 1);
        incip(first);
    }
}
@

<<function [[iptobinding]]>>=
/*
 *  find a binding for a specific ip address
 */
extern Binding*
iptobinding(uchar *ip, int mk)
{
    Binding *b;

    for(b = bcache; b; b = b->next){
        if(ipcmp(b->ip, ip) == 0){
            syncbinding(b, 0);
            return b;
        }
    }

    if(mk == 0)
        return 0;
    b = malloc(sizeof(*b));
    memset(b, 0, sizeof(*b));
    ipmove(b->ip, ip);
    b->next = bcache;
    bcache = b;
    syncbinding(b, 0);
    return b;
}
@

<<function [[lognolease]]>>=
static void
lognolease(Binding *b)
{
    /* renew the old binding, and hope it eventually goes away */
    b->offer = 5*60;
    commitbinding(b);

    /* complain if we haven't in the last 5 minutes */
    if(now - b->lastcomplained < 5*60)
        return;
    syslog(0, blog, "dhcp: lease for %I to %s ended at %ld but still in use\n",
        b->ip, b->boundto != nil ? b->boundto : "?", b->lease);
    b->lastcomplained = now;
}
@

<<function [[idtobinding]]>>=
/*
 *  find a free binding for a hw addr or id on the same network as iip
 */
extern Binding*
idtobinding(char *id, Info *iip, int ping)
{
    Binding *b, *oldest;
    int oldesttime;

    /*
     *  first look for an old binding that matches.  that way
     *  clients will tend to keep the same ip addresses.
     */
    for(b = bcache; b; b = b->next){
        if(b->boundto && strcmp(b->boundto, id) == 0){
            if(!samenet(b->ip, iip))
                continue;

            /* check with the other servers */
            syncbinding(b, 0);
            if(strcmp(b->boundto, id) == 0)
                return b;
        }
    }

    /*
     *  look for oldest binding that we think is unused
     */
    for(;;){
        oldest = nil;
        oldesttime = 0;
        for(b = bcache; b; b = b->next){
            if(b->tried != now)
            if(b->lease < now && b->expoffer < now && samenet(b->ip, iip))
            if(oldest == nil || b->lasttouched < oldesttime){
                /* sync and check again */
                syncbinding(b, 0);
                if(b->lease < now && b->expoffer < now && samenet(b->ip, iip))
                if(oldest == nil || b->lasttouched < oldesttime){
                    oldest = b;
                    oldesttime = b->lasttouched;
                }
            }
        }
        if(oldest == nil)
            break;

        /* make sure noone is still using it */
        oldest->tried = now;
        if(ping == 0 || icmpecho(oldest->ip) == 0)
            return oldest;

        lognolease(oldest);	/* sets lastcomplained */
    }

    /* try all bindings */
    for(b = bcache; b; b = b->next){
        syncbinding(b, 0);
        if(b->tried != now)
        if(b->lease < now && b->expoffer < now && samenet(b->ip, iip)){
            b->tried = now;
            if(ping == 0 || icmpecho(b->ip) == 0)
                return b;

            lognolease(b);
        }
    }

    /* nothing worked, give up */
    return 0;
}
@

<<function [[mkoffer]]>>=
/*
 *  create an offer
 */
extern void
mkoffer(Binding *b, char *id, long leasetime)
{
    if(leasetime <= 0){
        if(b->lease > now + minlease)
            leasetime = b->lease - now;
        else
            leasetime = minlease;
    }
    if(b->offeredto)
        free(b->offeredto);
    b->offeredto = strdup(id);
    b->offer = leasetime;
    b->expoffer = now + OfferTimeout;
}
@

<<function [[idtooffer]]>>=
/*
 *  find an offer for this id
 */
extern Binding*
idtooffer(char *id, Info *iip)
{
    Binding *b;

    /* look for an offer to this id */
    for(b = bcache; b; b = b->next){
        if(b->offeredto && strcmp(b->offeredto, id) == 0 && samenet(b->ip, iip)){
            /* make sure some other system hasn't stolen it */
            syncbinding(b, 0);
            if(b->lease < now
            || (b->boundto && strcmp(b->boundto, b->offeredto) == 0))
                return b;
        }
    }
    return 0;
}
@

<<function [[commitbinding]]>>=
/*
 *  commit a lease, this could fail
 */
extern int
commitbinding(Binding *b)
{
    int fd;
    long now;

    now = time(0);

    if(b->offeredto == 0)
        return -1;
    fd = syncbinding(b, 1);
    if(fd < 0)
        return -1;
    if(b->lease > now && b->boundto && strcmp(b->boundto, b->offeredto) != 0){
        close(fd);
        return -1;
    }
    setbinding(b, b->offeredto, now + b->offer);
    b->lasttouched = now;
    
    if(writebinding(fd, b) < 0){
        close(fd);
        return -1;
    }
    close(fd);
    return 0;
}
@

<<function [[releasebinding]]>>=
/*
 *  commit a lease, this could fail
 */
extern int
releasebinding(Binding *b, char *id)
{
    int fd;
    long now;

    now = time(0);

    fd = syncbinding(b, 1);
    if(fd < 0)
        return -1;
    if(b->lease > now && b->boundto && strcmp(b->boundto, id) != 0){
        close(fd);
        return -1;
    }
    b->lease = 0;
    b->expoffer = 0;
    
    if(writebinding(fd, b) < 0){
        close(fd);
        return -1;
    }
    close(fd);
    return 0;
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/db.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include <ctype.h>
#include "dat.h"

<<global [[bcache]]>>
<<global [[bfirst]]>>
<<global [[binddir]]>>

<<function [[hex]]([[(networking/ip/dhcpd/db.c)]])>>
<<function [[tohex]]>>

<<function [[toid]]>>

<<function [[incip]]>>

<<function [[lockopen]]>>

<<function [[setbinding]]>>

<<function [[parsebinding]]>>

<<function [[writebinding]]>>

<<function [[syncbinding]]>>

<<function [[samenet]]>>

<<function [[initbinding]]>>

<<function [[iptobinding]]>>

<<function [[lognolease]]>>

<<function [[idtobinding]]>>

<<function [[mkoffer]]>>

<<function [[idtooffer]]>>

<<function [[commitbinding]]>>

<<function [[releasebinding]]>>
@


\subsection*{[[networking/ip/dhcpd/dhcpd.c]]}

<<enum [[_anon_ (networking/ip/dhcpd/dhcpd.c)]]>>=
/*
 *	ala rfc2131
 */

enum {
    Maxloglen = 1024,
};
@

<<struct [[Req]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
struct Req
{
    int	fd;			/* for reply */
    Bootp	*bp;
    Udphdr	*up;
    uchar	*e;			/* end of received message */
    uchar	*p;			/* options pointer */
    uchar	*max;			/* max end of reply */

    /* expanded to v6 */
    uchar	ciaddr[IPaddrlen];
    uchar	giaddr[IPaddrlen];

    /* parsed options */
    int	p9request;		/* flag: this is a bootp with plan9 options */
    int	genrequest;		/* flag: this is a bootp with generic options */
    int	dhcptype;		/* dhcp message type */
    int	leasetime;		/* dhcp lease */
    uchar	ip[IPaddrlen];		/* requested address */
    uchar	server[IPaddrlen];	/* server address */
    char	msg[ERRMAX];		/* error message */
    char	vci[32];		/* vendor class id */
    char	*id;			/* client id */
    uchar	requested[32];		/* requested params */
    uchar	vendorclass[32];
    char	cputype[32-3];

    Info	gii;			/* about target network */
    Info	ii;			/* about target system */
    int	staticbinding;

    uchar buf[2*1024];		/* message buffer */
};
@

<<constant [[TFTP]]>>=
#define TFTP "/lib/tftpd"
@

<<global [[blog]]>>=
char	*blog = "ipboot";
@

<<global [[mysysname]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
char	mysysname[64];
@

<<global [[ipifcs]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
Ipifc	*ipifcs;
@

<<global [[debug]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
int	debug;
@

<<global [[nobootp]]>>=
int	nobootp;
@

<<global [[now]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
long	now;
@

<<global [[net]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
char	net[256];
@

<<global [[pptponly]]>>=
int	pptponly;	/* only answer request that came from the pptp server */
@

<<global [[minlease]]>>=
int	minlease = MinLease;
@

<<global [[staticlease]]>>=
int	staticlease = StaticLease;
@

<<global [[start]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
uvlong	start;
@

<<global [[v6opts]]>>=
static int v6opts;
@

<<global [[plan9opt]]>>=
/* option magic */
char plan9opt[4] = { 'p', '9', ' ', ' ' };
@

<<global [[genericopt]]>>=
char genericopt[4] = { 0x63, 0x82, 0x53, 0x63 };
@

<<global [[zeros]]>>=
/* well known addresses */
uchar zeros[Maxhwlen];
@

<<global [[optbuf]]>>=
/* option debug buffer */
char optbuf[1024];
@

<<global [[op]]>>=
char *op;
@

<<global [[oe]]>>=
char *oe = optbuf + sizeof(optbuf);
@

<<global [[optname]]>>=
char *optname[256] =
{
[OBend]			"end",
[OBpad]			"pad",
[OBmask]		"mask",
[OBtimeoff]		"timeoff",
[OBrouter]		"router",
[OBtimeserver]		"time",
[OBnameserver]		"name",
[OBdnserver]		"dns",
[OBlogserver]		"log",
[OBcookieserver]	"cookie",
[OBlprserver]		"lpr",
[OBimpressserver]	"impress",
[OBrlserver]		"rl",
[OBhostname]		"host",
[OBbflen]		"bflen",
[OBdumpfile]		"dumpfile",
[OBdomainname]		"dom",
[OBswapserver]		"swap",
[OBrootpath]		"rootpath",
[OBextpath]		"extpath",
[OBipforward]		"ipforward",
[OBnonlocal]		"nonlocal",
[OBpolicyfilter]	"policyfilter",
[OBmaxdatagram]		"maxdatagram",
[OBttl]			"ttl",
[OBpathtimeout]		"pathtimeout",
[OBpathplateau]		"pathplateau",
[OBmtu]			"mtu",
[OBsubnetslocal]	"subnetslocal",
[OBbaddr]		"baddr",
[OBdiscovermask]	"discovermask",
[OBsupplymask]		"supplymask",
[OBdiscoverrouter]	"discoverrouter",
[OBrsserver]		"rsserver",
[OBstaticroutes]	"staticroutes",
[OBtrailerencap]	"trailerencap",
[OBarptimeout]		"arptimeout",
[OBetherencap]		"etherencap",
[OBtcpttl]		"tcpttl",
[OBtcpka]		"tcpka",
[OBtcpkag]		"tcpkag",
[OBnisdomain]		"nisdomain",
[OBniserver]		"niserver",
[OBntpserver]		"ntpserver",
[OBvendorinfo]		"vendorinfo",
[OBnetbiosns]		"NBns",
[OBnetbiosdds]		"NBdds",
[OBnetbiostype]		"NBtype",
[OBnetbiosscope]	"NBscope",
[OBxfontserver]		"xfont",
[OBxdispmanager]	"xdisp",
[OBnisplusdomain]	"NPdomain",
[OBnisplusserver]	"NP",
[OBhomeagent]		"homeagent",
[OBsmtpserver]		"smtp",
[OBpop3server]		"pop3",
[OBnntpserver]		"nntp",
[OBwwwserver]		"www",
[OBfingerserver]	"finger",
[OBircserver]		"ircserver",
[OBstserver]		"stserver",
[OBstdaserver]		"stdaserver",

/* dhcp options */
[ODipaddr]		"ip",
[ODlease]		"leas",
[ODoverload]		"overload",
[ODtype]		"typ",
[ODserverid]		"sid",
[ODparams]		"params",
[ODmessage]		"message",
[ODmaxmsg]		"maxmsg",
[ODrenewaltime]		"renewaltime",
[ODrebindingtime]	"rebindingtime",
[ODvendorclass]		"vendorclass",
[ODclientid]		"cid",
[ODtftpserver]		"tftpserver",
[ODbootfile]		"bf",
};
@

<<function [[timestamp]]>>=
void
timestamp(char *tag)
{
    uvlong t;

    t = nsec()/1000;
    syslog(0, blog, "%s %lludµs", tag, t - start);
}
@

<<function [[usage]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: dhcp [-dmnprsSZ] [-f directory] [-M minlease] "
        "[-x netmtpt] [-Z staticlease] addr n [addr n] ...\n");
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
void
main(int argc, char **argv)
{
    int i, n, fd;
    uchar ip[IPaddrlen];
    Req r;

    setnetmtpt(net, sizeof net, nil);

    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('V', eipfmt);
    fmtinstall('M', eipfmt);
    ARGBEGIN {
    case '6':
        v6opts = 1;
        break;
    case 'd':
        debug = 1;
        break;
    case 'f':
        ndbfile = EARGF(usage());
        break;
    case 'm':
        mute = 1;
        break;
    case 'M':
        minlease = atoi(EARGF(usage()));
        if(minlease <= 0)
            minlease = MinLease;
        break;
    case 'n':
        nobootp = 1;
        break;
    case 'p':
        pptponly = 1;
        break;
    case 'r':
        mutestat = 1;
        break;
    case 's':
        slowstat = 1;
        break;
    case 'S':
        slowdyn = 1;
        break;
    case 'x':
        setnetmtpt(net, sizeof net, EARGF(usage()));
        break;
    case 'Z':
        staticlease = atoi(EARGF(usage()));
        if(staticlease <= 0)
            staticlease = StaticLease;
        break;
    default:
        usage();
        break;
    } ARGEND;

    while(argc > 1){
        parseip(ip, argv[0]);
        if(!validip(ip))
            usage();
        n = atoi(argv[1]);
        if(n <= 0)
            usage();
        initbinding(ip, n);
        argc -= 2;
        argv += 2;
    }

    /* for debugging */
    for(i = 0; i < 256; i++)
        if(optname[i] == 0)
            optname[i] = smprint("%d", i);

    /* what is my name? */
    strcpy(mysysname, readsysname());

    /* put process in background */
    if(!debug)
    switch(rfork(RFNOTEG|RFPROC|RFFDG)) {
    case -1:
        fatal(1, "fork");
    case 0:
        break;
    default:
        exits(0);
    }

    if (chdir(TFTP) < 0)
        warning(1, "can't change directory to %s", TFTP);
    fd = openlisten(net);

    for(;;){
        memset(&r, 0, sizeof(r));
        r.fd = fd;
        n = readlast(r.fd, r.buf, sizeof(r.buf));
        if(n < Udphdrsize)
            fatal(1, "error reading requests");
        start = nsec()/1000;
        op = optbuf;
        *op = 0;
        proto(&r, n);
        if(r.id != nil)
            free(r.id);
    }
}
@

<<function [[proto]]>>=
void
proto(Req *rp, int n)
{
    uchar relip[IPaddrlen];
    char buf[64];

    now = time(0);

    rp->e = rp->buf + n;
    rp->bp = (Bootp*)rp->buf;
    rp->up = (Udphdr*)rp->buf;
    if (ipcmp(rp->up->laddr, IPv4bcast) == 0)
        ipmove(rp->up->laddr, rp->up->ifcaddr);
    rp->max = rp->buf + Udphdrsize + MINSUPPORTED - IPUDPHDRSIZE;
    rp->p = rp->bp->optdata;
    v4tov6(rp->giaddr, rp->bp->giaddr);
    v4tov6(rp->ciaddr, rp->bp->ciaddr);

    if(pptponly && rp->bp->htype != 0)
        return;

    ipifcs = readipifc(net, ipifcs, -1);
    if(validip(rp->giaddr))
        ipmove(relip, rp->giaddr);
    else if(validip(rp->up->raddr))
        ipmove(relip, rp->up->raddr);
    else
        ipmove(relip, rp->up->laddr);
    if(rp->e < (uchar*)rp->bp->sname){
        warning(0, "packet too short");
        return;
    }
    if(rp->bp->op != Bootrequest){
        warning(0, "not bootrequest");
        return;
    }

    if(rp->e >= rp->bp->optdata){
        if(memcmp(rp->bp->optmagic, plan9opt, sizeof(rp->bp->optmagic)) == 0)
            rp->p9request = 1;
        if(memcmp(rp->bp->optmagic, genericopt, sizeof(rp->bp->optmagic)) == 0) {
            rp->genrequest = 1;
            parseoptions(rp);
        }
    }
    rp->p = rp->bp->optdata;

    /*  If no id is specified, make one from the hardware address
     *  of the target.  We assume all zeros is not a hardware address
     *  which could be a mistake.
     */
    if(rp->id == nil){
        if(rp->bp->hlen > Maxhwlen){
            warning(0, "hlen %d", rp->bp->hlen);
            return;
        }
        if(memcmp(zeros, rp->bp->chaddr, rp->bp->hlen) == 0){
            warning(0, "no chaddr");
            return;
        }
        sprint(buf, "hwa%2.2ux_", rp->bp->htype);
        rp->id = tohex(buf, rp->bp->chaddr, rp->bp->hlen);
    }

    /* info about gateway */
    if(lookupip(relip, &rp->gii, 1) < 0){
        warning(0, "lookupip failed");
        return;
    }

    /* info about target system */
    if(lookup(rp->bp, &rp->ii, &rp->gii) == 0)
        if(rp->ii.indb && rp->ii.dhcpgroup[0] == 0)
            rp->staticbinding = 1;

    if(rp->dhcptype)
        dhcp(rp);
    else
        bootp(rp);
    timestamp("done");
}
@

<<function [[slowdelay]]>>=
static void
slowdelay(Req *rp)
{
    if(slowstat && rp->staticbinding || slowdyn && !rp->staticbinding)
        sleep(2000);
}
@

<<function [[dhcp]]>>=
void
dhcp(Req *rp)
{
    logdhcp(rp);

    switch(rp->dhcptype){
    case Discover:
        slowdelay(rp);
        rcvdiscover(rp);
        break;
    case Request:
        rcvrequest(rp);
        break;
    case Decline:
        rcvdecline(rp);
        break;
    case Release:
        rcvrelease(rp);
        break;
    case Inform:
        rcvinform(rp);
        break;
    }
}
@

<<function [[rcvdiscover]]>>=
void
rcvdiscover(Req *rp)
{
    Binding *b, *nb;

    if(rp->staticbinding){
        sendoffer(rp, rp->ii.ipaddr, (staticlease > minlease? staticlease: minlease));
        return;
    }

    /*
     *  first look for an outstanding offer
     */
    b = idtooffer(rp->id, &rp->gii);

    /*
     * rfc2131 says:
     *   If an address is available, the new address
     *   SHOULD be chosen as follows:
     *
     *      o The client's current address as recorded in the client's current
     *        binding, ELSE
     *
     *      o The client's previous address as recorded in the client's (now
     *        expired or released) binding, if that address is in the server's
     *        pool of available addresses and not already allocated, ELSE
     *
     *      o The address requested in the 'Requested IP Address' option, if that
     *        address is valid and not already allocated, ELSE
     *
     *      o A new address allocated from the server's pool of available
     *        addresses; the address is selected based on the subnet from which
     *        the message was received (if 'giaddr' is 0) or on the address of
     *        the relay agent that forwarded the message ('giaddr' when not 0).
     */
    if(b == nil){
        b = idtobinding(rp->id, &rp->gii, 1);
        if(b && b->boundto && strcmp(b->boundto, rp->id) != 0)
        if(validip(rp->ip) && samenet(rp->ip, &rp->gii)){
            nb = iptobinding(rp->ip, 0);
            if(nb && nb->lease < now)
                b = nb;
        }
    }
    if(b == nil){
        warning(0, "!Discover(%s via %I): no binding %I",
            rp->id, rp->gii.ipaddr, rp->ip);
        return;
    }
    mkoffer(b, rp->id, rp->leasetime);
    sendoffer(rp, b->ip, b->offer);
}
@

<<function [[rcvrequest]]>>=
void
rcvrequest(Req *rp)
{
    Binding *b;

    if(validip(rp->server)){
        /* this is a reply to an offer - SELECTING */

        /* check for hard assignment */
        if(rp->staticbinding){
            if(forme(rp->server))
                sendack(rp, rp->ii.ipaddr,
                    (staticlease > minlease? staticlease:
                    minlease), 1);
            else
                warning(0, "!Request(%s via %I): for server %I not me",
                    rp->id, rp->gii.ipaddr, rp->server);
            return;
        }

        b = idtooffer(rp->id, &rp->gii);

        /* if we don't have an offer, nak */
        if(b == nil){
            warning(0, "!Request(%s via %I): no offer",
                rp->id, rp->gii.ipaddr);
            if(forme(rp->server))
                sendnak(rp, "no offer for you");
            return;
        }

        /* if not for me, retract offer */
        if(!forme(rp->server)){
            b->expoffer = 0;
            warning(0, "!Request(%s via %I): for server %I not me",
                rp->id, rp->gii.ipaddr, rp->server);
            return;
        }

        /*
         *  if the client is confused about what we offered, nak.
         *  client really shouldn't be specifying this when selecting
         */
        if(validip(rp->ip) && ipcmp(rp->ip, b->ip) != 0){
            warning(0, "!Request(%s via %I): requests %I, not %I",
                rp->id, rp->gii.ipaddr, rp->ip, b->ip);
            sendnak(rp, "bad ip address option");
            return;
        }
        if(commitbinding(b) < 0){
            warning(0, "!Request(%s via %I): can't commit %I",
                rp->id, rp->gii.ipaddr, b->ip);
            sendnak(rp, "can't commit binding");
            return;
        }
        sendack(rp, b->ip, b->offer, 1);
    } else if(validip(rp->ip)){
        /*
         *  checking address/net - INIT-REBOOT
         *
         *  This is a rebooting client that remembers its old
         *  address.
         */
        /* check for hard assignment */
        if(rp->staticbinding){
            if(memcmp(rp->ip, rp->ii.ipaddr, IPaddrlen) != 0){
                warning(0, "!Request(%s via %I): %I not valid for %E",
                    rp->id, rp->gii.ipaddr, rp->ip, rp->bp->chaddr);
                sendnak(rp, "not valid");
            }
            sendack(rp, rp->ii.ipaddr, (staticlease > minlease?
                staticlease: minlease), 1);
            return;
        }

        /* make sure the network makes sense */
        if(!samenet(rp->ip, &rp->gii)){
            warning(0, "!Request(%s via %I): bad forward of %I",
                rp->id, rp->gii.ipaddr, rp->ip);
            sendnak(rp, "wrong network");
            return;
        }
        b = iptobinding(rp->ip, 0);
        if(b == nil){
            warning(0, "!Request(%s via %I): no binding for %I",
                rp->id, rp->gii.ipaddr, rp->ip);
            return;
        }
        if(memcmp(rp->ip, b->ip, IPaddrlen) != 0 || now > b->lease){
            warning(0, "!Request(%s via %I): %I not valid",
                rp->id, rp->gii.ipaddr, rp->ip);
            sendnak(rp, "not valid");
            return;
        }
        b->offer = b->lease - now;
        sendack(rp, b->ip, b->offer, 1);
    } else if(validip(rp->ciaddr)){
        /*
         *  checking address - RENEWING or REBINDING
         *
         *  these states are indistinguishable in our action.  The only
         *  difference is how close to lease expiration the client is.
         *  If it is really close, it broadcasts the request hoping that
         *  some server will answer.
         */

        /* check for hard assignment */
        if(rp->staticbinding){
            if(ipcmp(rp->ciaddr, rp->ii.ipaddr) != 0){
                warning(0, "!Request(%s via %I): %I not valid",
                    rp->id, rp->gii.ipaddr, rp->ciaddr);
                sendnak(rp, "not valid");
            }
            sendack(rp, rp->ii.ipaddr, (staticlease > minlease?
                staticlease: minlease), 1);
            return;
        }

        /* make sure the network makes sense */
        if(!samenet(rp->ciaddr, &rp->gii)){
            warning(0, "!Request(%s via %I): bad forward of %I",
                rp->id, rp->gii.ipaddr, rp->ip);
            sendnak(rp, "wrong network");
            return;
        }
        b = iptobinding(rp->ciaddr, 0);
        if(b == nil){
            warning(0, "!Request(%s via %I): no binding for %I",
                rp->id, rp->gii.ipaddr, rp->ciaddr);
            return;
        }
        if(ipcmp(rp->ciaddr, b->ip) != 0){
            warning(0, "!Request(%I via %s): %I not valid",
                rp->id, rp->gii.ipaddr, rp->ciaddr);
            sendnak(rp, "invalid ip address");
            return;
        }
        mkoffer(b, rp->id, rp->leasetime);
        if(commitbinding(b) < 0){
            warning(0, "!Request(%s via %I): can't commit %I",
                rp->id, rp->gii.ipaddr, b->ip);
            sendnak(rp, "can't commit binding");
            return;
        }
        sendack(rp, b->ip, b->offer, 1);
    }
}
@

<<function [[rcvdecline]]>>=
void
rcvdecline(Req *rp)
{
    Binding *b;
    char buf[64];

    if(rp->staticbinding)
        return;

    b = idtooffer(rp->id, &rp->gii);
    if(b == nil){
        warning(0, "!Decline(%s via %I): no binding",
            rp->id, rp->gii.ipaddr);
        return;
    }

    /* mark ip address as in use */
    snprint(buf, sizeof(buf), "declined by %s", rp->id);
    mkoffer(b, buf, 0x7fffffff);
    commitbinding(b);
}
@

<<function [[rcvrelease]]>>=
void
rcvrelease(Req *rp)
{
    Binding *b;

    if(rp->staticbinding)
        return;

    b = idtobinding(rp->id, &rp->gii, 0);
    if(b == nil){
        warning(0, "!Release(%s via %I): no binding",
            rp->id, rp->gii.ipaddr);
        return;
    }
    if(strcmp(rp->id, b->boundto) != 0){
        warning(0, "!Release(%s via %I): invalid release of %I",
            rp->id, rp->gii.ipaddr, rp->ip);
        return;
    }
    warning(0, "Release(%s via %I): releasing %I", b->boundto, rp->gii.ipaddr, b->ip);
    if(releasebinding(b, rp->id) < 0)
        warning(0, "release: couldn't release");
}
@

<<function [[rcvinform]]>>=
void
rcvinform(Req *rp)
{
    Binding *b;

    if(rp->staticbinding){
        sendack(rp, rp->ii.ipaddr, 0, 0);
        return;
    }

    b = iptobinding(rp->ciaddr, 0);
    if(b == nil){
        warning(0, "!Inform(%s via %I): no binding for %I",
            rp->id, rp->gii.ipaddr, rp->ip);
        return;
    }
    sendack(rp, b->ip, 0, 0);
}
@

<<function [[setsiaddr]]>>=
int
setsiaddr(uchar *siaddr, uchar *saddr, uchar *laddr)
{
    if(ipcmp(saddr, IPnoaddr) != 0){
        v6tov4(siaddr, saddr);
        return 0;
    } else {
        v6tov4(siaddr, laddr);
        return 1;
    }
}
@

<<function [[ismuted]]>>=
int
ismuted(Req *rp)
{
    return mute || (mutestat && rp->staticbinding);
}
@

<<function [[sendoffer]]>>=
void
sendoffer(Req *rp, uchar *ip, int offer)
{
    int n;
    ushort flags;
    Bootp *bp;
    Udphdr *up;

    bp = rp->bp;
    up = rp->up;

    /*
     *  set destination
     */
    flags = nhgets(bp->flags);
    if(validip(rp->giaddr)){
        ipmove(up->raddr, rp->giaddr);
        hnputs(up->rport, 67);
    } else if(flags & Fbroadcast){
        ipmove(up->raddr, IPv4bcast);
        hnputs(up->rport, 68);
    } else {
        ipmove(up->raddr, ip);
        if(bp->htype == 1)
            arpenter(up->raddr, bp->chaddr);
        hnputs(up->rport, 68);
    }

    /*
     *  fill in standard bootp part
     */
    bp->op = Bootreply;
    bp->hops = 0;
    hnputs(bp->secs, 0);
    memset(bp->ciaddr, 0, sizeof(bp->ciaddr));
    v6tov4(bp->giaddr, rp->giaddr);
    v6tov4(bp->yiaddr, ip);
    setsiaddr(bp->siaddr, rp->ii.tftp, up->laddr);
    strncpy(bp->sname, mysysname, sizeof(bp->sname));
    strncpy(bp->file, rp->ii.bootf, sizeof(bp->file));

    /*
     *  set options
     */
    byteopt(rp, ODtype, Offer);
    longopt(rp, ODlease, offer);
    addropt(rp, ODserverid, up->laddr);
    miscoptions(rp, ip);
    termopt(rp);

    logdhcpout(rp, "Offer");

    /*
     *  send
     */
    n = rp->p - rp->buf;
    if(!ismuted(rp) && write(rp->fd, rp->buf, n) != n)
        warning(0, "offer: write failed: %r");
}
@

<<function [[sendack]]>>=
void
sendack(Req *rp, uchar *ip, int offer, int sendlease)
{
    int n;
    ushort flags;
    Bootp *bp;
    Udphdr *up;

    bp = rp->bp;
    up = rp->up;

    /*
     *  set destination
     */
    flags = nhgets(bp->flags);
    if(validip(rp->giaddr)){
        ipmove(up->raddr, rp->giaddr);
        hnputs(up->rport, 67);
    } else if(flags & Fbroadcast){
        ipmove(up->raddr, IPv4bcast);
        hnputs(up->rport, 68);
    } else {
        ipmove(up->raddr, ip);
        if(bp->htype == 1)
            arpenter(up->raddr, bp->chaddr);
        hnputs(up->rport, 68);
    }

    /*
     *  fill in standard bootp part
     */
    bp->op = Bootreply;
    bp->hops = 0;
    hnputs(bp->secs, 0);
    v6tov4(bp->giaddr, rp->giaddr);
    v6tov4(bp->yiaddr, ip);
    setsiaddr(bp->siaddr, rp->ii.tftp, up->laddr);
    strncpy(bp->sname, mysysname, sizeof(bp->sname));
    strncpy(bp->file, rp->ii.bootf, sizeof(bp->file));

    /*
     *  set options
     */
    byteopt(rp, ODtype, Ack);
    if(sendlease){
        longopt(rp, ODlease, offer);
    }
    addropt(rp, ODserverid, up->laddr);
    miscoptions(rp, ip);
    termopt(rp);

    logdhcpout(rp, "Ack");

    /*
     *  send
     */
    n = rp->p - rp->buf;
    if(!ismuted(rp) && write(rp->fd, rp->buf, n) != n)
        warning(0, "ack: write failed: %r");
}
@

<<function [[sendnak]]>>=
void
sendnak(Req *rp, char *msg)
{
    int n;
    Bootp *bp;
    Udphdr *up;

    bp = rp->bp;
    up = rp->up;

    /*
     *  set destination (always broadcast)
     */
    if(validip(rp->giaddr)){
        ipmove(up->raddr, rp->giaddr);
        hnputs(up->rport, 67);
    } else {
        ipmove(up->raddr, IPv4bcast);
        hnputs(up->rport, 68);
    }

    /*
     *  fill in standard bootp part
     */
    bp->op = Bootreply;
    bp->hops = 0;
    hnputs(bp->secs, 0);
    v6tov4(bp->giaddr, rp->giaddr);
    memset(bp->ciaddr, 0, sizeof(bp->ciaddr));
    memset(bp->yiaddr, 0, sizeof(bp->yiaddr));
    memset(bp->siaddr, 0, sizeof(bp->siaddr));

    /*
     *  set options
     */
    byteopt(rp, ODtype, Nak);
    addropt(rp, ODserverid, up->laddr);
    if(msg)
        stringopt(rp, ODmessage, msg);
    if(strncmp(rp->id, "id", 2) == 0)
        hexopt(rp, ODclientid, rp->id+2);
    termopt(rp);

    logdhcpout(rp, "Nak");

    /*
     *  send nak
     */
    n = rp->p - rp->buf;
    if(!ismuted(rp) && write(rp->fd, rp->buf, n) != n)
        warning(0, "nak: write failed: %r");
}
@

<<function [[bootp]]>>=
void
bootp(Req *rp)
{
    int n;
    Bootp *bp;
    Udphdr *up;
    ushort flags;
    Iplifc *lifc;
    Info *iip;

    warning(0, "bootp %s %I->%I from %s via %I, file %s",
        rp->genrequest? "generic": (rp->p9request? "p9": ""),
        rp->up->raddr, rp->up->laddr,
        rp->id, rp->gii.ipaddr,
        rp->bp->file);

    if(nobootp)
        return;

    bp = rp->bp;
    up = rp->up;
    iip = &rp->ii;

    if(rp->staticbinding == 0){
        warning(0, "bootp from unknown %s via %I", rp->id, rp->gii.ipaddr);
        return;
    }

    /* ignore if not for us */
    if(*bp->sname){
        if(strcmp(bp->sname, mysysname) != 0){
            bp->sname[20] = 0;
            warning(0, "bootp for server %s", bp->sname);
            return;
        }
    } else
        slowdelay(rp);

    /* ignore if we don't know what file to load */
    if(*bp->file == 0){
        if(rp->genrequest && *iip->bootf2) /* if not plan 9 & have alternate file... */
            strncpy(bp->file, iip->bootf2, sizeof(bp->file));
        else if(*iip->bootf)
            strncpy(bp->file, iip->bootf, sizeof(bp->file));
        else if(*bp->sname) /* if we were asked, respond no matter what */
            bp->file[0] = '\0';
        else {
            warning(0, "no bootfile for %I", iip->ipaddr);
            return;
        }
    }

    /* ignore if the file is unreadable */
    if((!rp->genrequest) && bp->file[0] && access(bp->file, 4) < 0){
        warning(0, "inaccessible bootfile1 %s", bp->file);
        return;
    }

    bp->op = Bootreply;
    v6tov4(bp->yiaddr, iip->ipaddr);
    if(rp->p9request){
        warning(0, "p9bootp: %I", iip->ipaddr);
        memmove(bp->optmagic, plan9opt, 4);
        if(iip->gwip == 0)
            v4tov6(iip->gwip, bp->giaddr);
        rp->p += sprint((char*)rp->p, "%V %I %I %I", iip->ipmask+IPv4off, iip->fsip,
                iip->auip, iip->gwip);
        sprint(optbuf, "%s", (char*)(bp->optmagic));
    } else if(rp->genrequest){
        warning(0, "genericbootp: %I", iip->ipaddr);
        memmove(bp->optmagic, genericopt, 4);
        miscoptions(rp, iip->ipaddr);
        termopt(rp);
    } else if(iip->vendor[0] != 0) {
        warning(0, "bootp vendor field: %s", iip->vendor);
        memset(rp->p, 0, 128-4);
        rp->p += sprint((char*)bp->optmagic, "%s", iip->vendor);
    } else {
        memset(rp->p, 0, 128-4);
        rp->p += 128-4;
    }

    /*
     *  set destination
     */
    flags = nhgets(bp->flags);
    if(validip(rp->giaddr)){
        ipmove(up->raddr, rp->giaddr);
        hnputs(up->rport, 67);
    } else if(flags & Fbroadcast){
        ipmove(up->raddr, IPv4bcast);
        hnputs(up->rport, 68);
    } else {
        v4tov6(up->raddr, bp->yiaddr);
        if(bp->htype == 1)
            arpenter(up->raddr, bp->chaddr);
        hnputs(up->rport, 68);
    }

    /*
     *  select best local address if destination is directly connected
     */
    lifc = findlifc(up->raddr);
    if(lifc)
        ipmove(up->laddr, lifc->ip);

    /*
     *  our identity
     */
    strncpy(bp->sname, mysysname, sizeof(bp->sname));

    /*
     *  set tftp server
     */
    setsiaddr(bp->siaddr, iip->tftp, up->laddr);
    if(rp->genrequest && *iip->bootf2)
        setsiaddr(bp->siaddr, iip->tftp2, up->laddr);

    /*
     * RFC 1048 says that we must pad vendor field with
     * zeros until we have a 64 byte field.
     */
    n = rp->p - rp->bp->optdata;
    if(n < 64-4) {
        memset(rp->p, 0, (64-4)-n);
        rp->p += (64-4)-n;
    }

    /*
     *  send
     */
    n = rp->p - rp->buf;
    if(!ismuted(rp) && write(rp->fd, rp->buf, n) != n)
        warning(0, "bootp: write failed: %r");

    warning(0, "bootp via %I: file %s xid(%ux)flag(%ux)ci(%V)gi(%V)yi(%V)si(%V) %s",
            up->raddr, bp->file, nhgetl(bp->xid), nhgets(bp->flags),
            bp->ciaddr, bp->giaddr, bp->yiaddr, bp->siaddr,
            optbuf);
}
@

<<function [[parseoptions]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
void
parseoptions(Req *rp)
{
    int n, c, code;
    uchar *o, *p;

    p = rp->p;

    while(p < rp->e){
        code = *p++;
        if(code == 255)
            break;
        if(code == 0)
            continue;

        /* ignore anything that's too long */
        n = *p++;
        o = p;
        p += n;
        if(p > rp->e)
            return;

        switch(code){
        case ODipaddr:	/* requested ip address */
            if(n == IPv4addrlen)
                v4tov6(rp->ip, o);
            break;
        case ODlease:	/* requested lease time */
            rp->leasetime = nhgetl(o);
            if(rp->leasetime > MaxLease || rp->leasetime < 0)
                rp->leasetime = MaxLease;
            break;
        case ODtype:
            c = *o;
            if(c < 10 && c > 0)
                rp->dhcptype = c;
            break;
        case ODserverid:
            if(n == IPv4addrlen)
                v4tov6(rp->server, o);
            break;
        case ODmessage:
            if(n > sizeof rp->msg-1)
                n = sizeof rp->msg-1;
            memmove(rp->msg, o, n);
            rp->msg[n] = 0;
            break;
        case ODmaxmsg:
            c = nhgets(o);
            c -= 28;
            c += Udphdrsize;
            if(c > 0)
                rp->max = rp->buf + c;
            break;
        case ODclientid:
            if(n <= 1)
                break;
            rp->id = toid( o, n);
            break;
        case ODparams:
            if(n > sizeof(rp->requested))
                n = sizeof(rp->requested);
            memmove(rp->requested, o, n);
            break;
        case ODvendorclass:
            if(n >= sizeof(rp->vendorclass))
                n = sizeof(rp->vendorclass)-1;
            memmove(rp->vendorclass, o, n);
            rp->vendorclass[n] = 0;
            if(strncmp((char*)rp->vendorclass, "p9-", 3) == 0)
                strcpy(rp->cputype, (char*)rp->vendorclass+3);
            break;
        case OBend:
            return;
        }
    }
}
@

<<function [[remrequested]]>>=
void
remrequested(Req *rp, int opt)
{
    uchar *p;

    p = memchr(rp->requested, opt, sizeof(rp->requested));
    if(p != nil)
        *p = OBpad;
}
@

<<function [[miscoptions]]>>=
void
miscoptions(Req *rp, uchar *ip)
{
    int i, j, na;
    uchar x[2*IPaddrlen], vopts[Maxoptlen];
    uchar *op, *omax;
    uchar *addrs[2];
    char *p;
    char *attr[100], **a;
    Ndbtuple *t;

    addrs[0] = x;
    addrs[1] = x+IPaddrlen;

    /* always supply these */
    maskopt(rp, OBmask, rp->gii.ipmask);
    if(validip(rp->gii.gwip)){
        remrequested(rp, OBrouter);
        addropt(rp, OBrouter, rp->gii.gwip);
    } else if(validip(rp->giaddr)){
        remrequested(rp, OBrouter);
        addropt(rp, OBrouter, rp->giaddr);
    }

    /*
     * OBhostname for the HP4000M switches
     * (this causes NT to log infinite errors - tough shit)
     */
    if(*rp->ii.domain){
        remrequested(rp, OBhostname);
        stringopt(rp, OBhostname, rp->ii.domain);
    }
    if(*rp->ii.rootpath)
        stringopt(rp, OBrootpath, rp->ii.rootpath);

    /* figure out what we need to lookup */
    na = 0;
    a = attr;
    if(*rp->ii.domain == 0)
        a[na++] = "dom";
    for(i = 0; i < sizeof(rp->requested); i++)
        switch(rp->requested[i]){
        case OBrouter:
            a[na++] = "@ipgw";
            break;
        case OBdnserver:
            a[na++] = "@dns";
            break;
        case OBnetbiosns:
            a[na++] = "@wins";
            break;
        case OBsmtpserver:
            a[na++] = "@smtp";
            break;
        case OBpop3server:
            a[na++] = "@pop3";
            break;
        case OBwwwserver:
            a[na++] = "@www";
            break;
        case OBntpserver:
            a[na++] = "@ntp";
            break;
        case OBtimeserver:
            a[na++] = "@time";
            break;
        }
    if(strncmp((char*)rp->vendorclass, "plan9_", 6) == 0
    || strncmp((char*)rp->vendorclass, "p9-", 3) == 0){
        a[na++] = "@fs";
        a[na++] = "@auth";
    }
    t = lookupinfo(ip, a, na);

    /* lookup anything we might be missing */
    if(*rp->ii.domain == 0)
        lookupname(rp->ii.domain, t);

    /* add any requested ones that we know about */
    for(i = 0; i < sizeof(rp->requested); i++)
        switch(rp->requested[i]){
        case OBrouter:
            j = lookupserver("ipgw", addrs, t);
            addrsopt(rp, OBrouter, addrs, j);
            break;
        case OBdnserver:
            j = lookupserver("dns", addrs, t);
            addrsopt(rp, OBdnserver, addrs, j);
            break;
        case OBhostname:
            if(*rp->ii.domain)
                stringopt(rp, OBhostname, rp->ii.domain);
            break;
        case OBdomainname:
            p = strchr(rp->ii.domain, '.');
            if(p)
                stringopt(rp, OBdomainname, p+1);
            break;
        case OBnetbiosns:
            j = lookupserver("wins", addrs, t);
            addrsopt(rp, OBnetbiosns, addrs, j);
            break;
        case OBnetbiostype:
            /* p-node: peer to peer WINS queries */
            byteopt(rp, OBnetbiostype, 0x2);
            break;
        case OBsmtpserver:
            j = lookupserver("smtp", addrs, t);
            addrsopt(rp, OBsmtpserver, addrs, j);
            break;
        case OBpop3server:
            j = lookupserver("pop3", addrs, t);
            addrsopt(rp, OBpop3server, addrs, j);
            break;
        case OBwwwserver:
            j = lookupserver("www", addrs, t);
            addrsopt(rp, OBwwwserver, addrs, j);
            break;
        case OBntpserver:
            j = lookupserver("ntp", addrs, t);
            addrsopt(rp, OBntpserver, addrs, j);
            break;
        case OBtimeserver:
            j = lookupserver("time", addrs, t);
            addrsopt(rp, OBtimeserver, addrs, j);
            break;
        case OBttl:
            byteopt(rp, OBttl, 255);
            break;
        }

    /* add plan9 specific options */
    if(strncmp((char*)rp->vendorclass, "plan9_", 6) == 0
    || strncmp((char*)rp->vendorclass, "p9-", 3) == 0){
        /* point to temporary area */
        op = rp->p;
        omax = rp->max;
        /* stash encoded options in vopts */
        rp->p = vopts;
        rp->max = vopts + sizeof(vopts) - 1;

        /* emit old v4 addresses first to make sure that they fit */
        addrsopt(rp, OP9fsv4, addrs, lookupserver("fs", addrs, t));
        addrsopt(rp, OP9authv4, addrs, lookupserver("auth", addrs, t));

        p9addrsopt(rp, OP9fs, addrs, lookupserver("fs", addrs, t));
        p9addrsopt(rp, OP9auth, addrs, lookupserver("auth", addrs, t));
        p9addrsopt(rp, OP9ipaddr, addrs, lookupserver("ip", addrs, t));
        p9addrsopt(rp, OP9ipmask, addrs, lookupserver("ipmask", addrs, t));
        p9addrsopt(rp, OP9ipgw, addrs, lookupserver("ipgw", addrs, t));

        /* point back to packet, encapsulate vopts into packet */
        j = rp->p - vopts;
        rp->p = op;
        rp->max = omax;
        vectoropt(rp, OBvendorinfo, vopts, j);
    }

    ndbfree(t);
}
@

<<function [[openlisten]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
int
openlisten(char *net)
{
    int fd, cfd;
    char data[128], devdir[40];

    sprint(data, "%s/udp!*!bootp", net);
    cfd = announce(data, devdir);
    if(cfd < 0)
        fatal(1, "can't announce");
    if(fprint(cfd, "headers") < 0)
        fatal(1, "can't set header mode");

    sprint(data, "%s/data", devdir);
    fd = open(data, ORDWR);
    if(fd < 0)
        fatal(1, "open udp data");
    return fd;
}
@

<<function [[fatal]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
void
fatal(int syserr, char *fmt, ...)
{
    char buf[Maxloglen];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    if(syserr)
        syslog(1, blog, "%s: %r", buf);
    else
        syslog(1, blog, "%s", buf);
    exits(buf);
}
@

<<function [[warning]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
void
warning(int syserr, char *fmt, ...)
{
    char buf[Maxloglen];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    if(syserr){
        syslog(0, blog, "%s: %r", buf);
        if(debug)
            fprint(2, "%s: %r\n", buf);
    } else {
        syslog(0, blog, "%s", buf);
        if(debug)
            fprint(2, "%s\n", buf);
    }
}
@

<<function [[readsysname]]>>=
char*
readsysname(void)
{
    static char name[128];
    char *p;
    int n, fd;

    fd = open("/dev/sysname", OREAD);
    if(fd >= 0){
        n = read(fd, name, sizeof(name)-1);
        close(fd);
        if(n > 0){
            name[n] = 0;
            return name;
        }
    }
    p = getenv("sysname");
    if(p == nil || *p == 0)
        return "unknown";
    return p;
}
@

<<function [[validip]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
extern int
validip(uchar *ip)
{
    if(ipcmp(ip, IPnoaddr) == 0)
        return 0;
    if(ipcmp(ip, v4prefix) == 0)
        return 0;
    return 1;
}
@

<<function [[longopt]]>>=
void
longopt(Req *rp, int t, long v)
{
    if(rp->p + 6 > rp->max)
        return;
    *rp->p++ = t;
    *rp->p++ = 4;
    hnputl(rp->p, v);
    rp->p += 4;

    op = seprint(op, oe, "%s(%ld)", optname[t], v);
}
@

<<function [[addropt]]>>=
void
addropt(Req *rp, int t, uchar *ip)
{
    if(rp->p + 6 > rp->max)
        return;
    if (!isv4(ip)) {
        if (debug)
            warning(0, "not a v4 %s server: %I", optname[t], ip);
        return;
    }
    *rp->p++ = t;
    *rp->p++ = 4;
    memmove(rp->p, ip+IPv4off, 4);
    rp->p += 4;

    op = seprint(op, oe, "%s(%I)", optname[t], ip);
}
@

<<function [[maskopt]]>>=
void
maskopt(Req *rp, int t, uchar *ip)
{
    if(rp->p + 6 > rp->max)
        return;
    *rp->p++ = t;
    *rp->p++ = 4;
    memmove(rp->p, ip+IPv4off, 4);
    rp->p += 4;

    op = seprint(op, oe, "%s(%M)", optname[t], ip);
}
@

<<function [[addrsopt]]>>=
void
addrsopt(Req *rp, int t, uchar **ip, int i)
{
    int v4s, n;

    if(i <= 0)
        return;
    if(rp->p + 2 + 4*i > rp->max)
        return;
    v4s = 0;
    for(n = i; n-- > 0; )
        if (isv4(ip[n]))
            v4s++;
    if (v4s <= 0) {
        if (debug)
            warning(0, "no v4 %s servers", optname[t]);
        return;
    }
    *rp->p++ = t;
    *rp->p++ = 4*v4s;
    op = seprint(op, oe, " %s(", optname[t]);
    while(i-- > 0){
        if (!isv4(*ip)) {
            op = seprint(op, oe, " skipping %I ", *ip);
            continue;
        }
        v6tov4(rp->p, *ip);
        rp->p += 4;
        op = seprint(op, oe, "%I", *ip);
        ip++;
        if(i > 0)
            op = seprint(op, oe, " ");
    }
    op = seprint(op, oe, ")");
}
@

<<function [[p9addrsopt]]>>=
void
p9addrsopt(Req *rp, int t, uchar **ip, int i)
{
    char *pkt, *payload;

    if(i <= 0 || !v6opts)
        return;
    pkt = (char *)rp->p;
    *pkt++ = t;			/* option */
    pkt++;				/* fill in payload length below */
    payload = pkt;
    *pkt++ = i;			/* plan 9 address count */
    op = seprint(op, oe, " %s(", optname[t]);
    while(i-- > 0){
        pkt = seprint(pkt, (char *)rp->max, "%I", *ip);
        if ((uchar *)pkt+1 >= rp->max) {
            op = seprint(op, oe, "<out of mem1>)");
            return;
        }
        pkt++;			/* leave NUL as terminator */
        op = seprint(op, oe, "%I", *ip);
        ip++;
        if(i > 0)
            op = seprint(op, oe, " ");
    }
    if ((uchar *)pkt - rp->p > 0377) {
        op = seprint(op, oe, "<out of mem2>)");
        return;
    }
    op = seprint(op, oe, ")");
    rp->p[1] = pkt - payload;	/* payload length */
    rp->p = (uchar *)pkt;
}
@

<<function [[byteopt]]>>=
void
byteopt(Req *rp, int t, uchar v)
{
    if(rp->p + 3 > rp->max)
        return;
    *rp->p++ = t;
    *rp->p++ = 1;
    *rp->p++ = v;

    op = seprint(op, oe, "%s(%d)", optname[t], v);
}
@

<<function [[termopt]]>>=
void
termopt(Req *rp)
{
    if(rp->p + 1 > rp->max)
        return;
    *rp->p++ = OBend;
}
@

<<function [[stringopt]]>>=
void
stringopt(Req *rp, int t, char *str)
{
    int n;

    n = strlen(str);
    if(n > 255)
        n = 255;
    if(rp->p+n+2 > rp->max)
        return;
    *rp->p++ = t;
    *rp->p++ = n;
    memmove(rp->p, str, n);
    rp->p += n;

    op = seprint(op, oe, "%s(%s)", optname[t], str);
}
@

<<function [[vectoropt]]>>=
void
vectoropt(Req *rp, int t, uchar *v, int n)
{
    int i;

    if(n > 255) {
        n = 255;
        op = seprint(op, oe, "vectoropt len %d > 255 ", n);
    }
    if(rp->p+n+2 > rp->max)
        return;
    *rp->p++ = t;
    *rp->p++ = n;
    memmove(rp->p, v, n);
    rp->p += n;

    op = seprint(op, oe, "%s(", optname[t]);
    if(n > 0)
        op = seprint(op, oe, "%ud", v[0]);
    for(i = 1; i < n; i++)
        op = seprint(op, oe, " %ud", v[i]);
    op = seprint(op, oe, ")");
}
@

<<function [[fromhex]]>>=
int
fromhex(int x)
{
    if(x >= '0' && x <= '9')
        return x - '0';
    return x - 'a';
}
@

<<function [[hexopt]]>>=
void
hexopt(Req *rp, int t, char *str)
{
    int n;

    n = strlen(str);
    n /= 2;
    if(n > 255)
        n = 255;
    if(rp->p+n+2 > rp->max)
        return;
    *rp->p++ = t;
    *rp->p++ = n;
    while(n-- > 0){
        *rp->p++ = (fromhex(str[0])<<4)|fromhex(str[1]);
        str += 2;
    }

    op = seprint(op, oe, "%s(%s)", optname[t], str);
}
@

<<function [[arpenter]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
void
arpenter(uchar *ip, uchar *ether)
{
    int f;
    char buf[256];

    sprint(buf, "%s/arp", net);
    f = open(buf, OWRITE);
    if(f < 0){
        syslog(debug, blog, "open %s: %r", buf);
        return;
    }
    fprint(f, "add ether %I %E", ip, ether);
    close(f);
}
@

<<global [[dhcpmsgname]]>>=
char *dhcpmsgname[] =
{
    [Discover]	"Discover",
    [Offer]		"Offer",
    [Request]	"Request",
    [Decline]	"Decline",
    [Ack]		"Ack",
    [Nak]		"Nak",
    [Release]	"Release",
    [Inform]	"Inform",
};
@

<<function [[logdhcp]]>>=
void
logdhcp(Req *rp)
{
    char buf[4096];
    char *p, *e;
    int i;

    p = buf;
    e = buf + sizeof(buf);
    if(rp->dhcptype > 0 && rp->dhcptype <= Inform)
        p = seprint(p, e, "%s(", dhcpmsgname[rp->dhcptype]);
    else
        p = seprint(p, e, "%d(", rp->dhcptype);
    p = seprint(p, e, "%I->%I) xid(%ux)flag(%ux)", rp->up->raddr, rp->up->laddr,
        nhgetl(rp->bp->xid), nhgets(rp->bp->flags));
    if(rp->bp->htype == 1)
        p = seprint(p, e, "ea(%E)", rp->bp->chaddr);
    if(validip(rp->ciaddr))
        p = seprint(p, e, "ci(%I)", rp->ciaddr);
    if(validip(rp->giaddr))
        p = seprint(p, e, "gi(%I)", rp->giaddr);
    if(validip(rp->ip))
        p = seprint(p, e, "ip(%I)", rp->ip);
    if(rp->id != nil)
        p = seprint(p, e, "id(%s)", rp->id);
    if(rp->leasetime)
        p = seprint(p, e, "leas(%d)", rp->leasetime);
    if(validip(rp->server))
        p = seprint(p, e, "sid(%I)", rp->server);
    p = seprint(p, e, "need(");
    for(i = 0; i < sizeof(rp->requested); i++)
        if(rp->requested[i] != 0)
            p = seprint(p, e, "%s ", optname[rp->requested[i]]);
    p = seprint(p, e, ")");

    USED(p);
    syslog(0, blog, "%s", buf);
}
@

<<function [[logdhcpout]]>>=
void
logdhcpout(Req *rp, char *type)
{
    syslog(0, blog, "%s(%I-%I)id(%s)ci(%V)gi(%V)yi(%V)si(%V) %s",
        type, rp->up->laddr, rp->up->raddr, rp->id,
        rp->bp->ciaddr, rp->bp->giaddr, rp->bp->yiaddr, rp->bp->siaddr, optbuf);
}
@

<<function [[ding]]([[(networking/ip/dhcpd/dhcpd.c)]])>>=
/*
 *  if we get behind, it's useless to try answering since the sender
 *  will probably have retransmitted with a differnt sequence number.
 *  So dump all but the last message in the queue.
 */
void
ding(void*, char *msg)
{
    if(strstr(msg, "alarm"))
        noted(NCONT);
    else
        noted(NDFLT);
}
@

<<function [[readlast]]>>=
int
readlast(int fd, uchar *buf, int len)
{
    int lastn, n;

    notify(ding);

    lastn = 0;
    for(;;){
        alarm(20);
        n = read(fd, buf, len);
        alarm(0);
        if(n < 0){
            if(lastn > 0)
                return lastn;
            break;
        }
        lastn = n;
    }
    return read(fd, buf, len);
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/dhcpd.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include "dat.h"

<<enum [[_anon_ (networking/ip/dhcpd/dhcpd.c)]]>>

typedef struct Req Req;
<<struct [[Req]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<constant [[TFTP]]>>

<<global [[blog]]>>
<<global [[mysysname]]([[(networking/ip/dhcpd/dhcpd.c)]])>>
<<global [[ipifcs]]([[(networking/ip/dhcpd/dhcpd.c)]])>>
<<global [[debug]]([[(networking/ip/dhcpd/dhcpd.c)]])>>
<<global [[nobootp]]>>
<<global [[now]]([[(networking/ip/dhcpd/dhcpd.c)]])>>
int	slowstat, slowdyn;
<<global [[net]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<global [[pptponly]]>>
int	mute, mutestat;
<<global [[minlease]]>>
<<global [[staticlease]]>>

<<global [[start]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<global [[v6opts]]>>

<<global [[plan9opt]]>>
<<global [[genericopt]]>>

<<global [[zeros]]>>

<<global [[optbuf]]>>
<<global [[op]]>>
<<global [[oe]]>>

<<global [[optname]]>>

void	addropt(Req*, int, uchar*);
void	addrsopt(Req*, int, uchar**, int);
void	arpenter(uchar*, uchar*);
void	bootp(Req*);
void	byteopt(Req*, int, uchar);
void	dhcp(Req*);
void	fatal(int, char*, ...);
void	hexopt(Req*, int, char*);
void	logdhcp(Req*);
void	logdhcpout(Req *, char *);
void	longopt(Req*, int, long);
void	maskopt(Req*, int, uchar*);
void	miscoptions(Req*, uchar*);
int	openlisten(char *net);
void	p9addrsopt(Req *rp, int t, uchar **ip, int i);
void	parseoptions(Req*);
void	proto(Req*, int);
void	rcvdecline(Req*);
void	rcvdiscover(Req*);
void	rcvinform(Req*);
void	rcvrelease(Req*);
void	rcvrequest(Req*);
int	readlast(int, uchar*, int);
char*	readsysname(void);
void	remrequested(Req*, int);
void	sendack(Req*, uchar*, int, int);
void	sendnak(Req*, char*);
void	sendoffer(Req*, uchar*, int);
void	stringopt(Req*, int, char*);
void	termopt(Req*);
int	validip(uchar*);
void	vectoropt(Req*, int, uchar*, int);
void	warning(int, char*, ...);

<<function [[timestamp]]>>

<<function [[usage]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<function [[main]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<function [[proto]]>>

<<function [[slowdelay]]>>

<<function [[dhcp]]>>

<<function [[rcvdiscover]]>>

<<function [[rcvrequest]]>>

<<function [[rcvdecline]]>>

<<function [[rcvrelease]]>>

<<function [[rcvinform]]>>

<<function [[setsiaddr]]>>

<<function [[ismuted]]>>

<<function [[sendoffer]]>>

<<function [[sendack]]>>

<<function [[sendnak]]>>

<<function [[bootp]]>>

<<function [[parseoptions]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<function [[remrequested]]>>

<<function [[miscoptions]]>>

<<function [[openlisten]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<function [[fatal]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<function [[warning]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<function [[readsysname]]>>

<<function [[validip]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<function [[longopt]]>>

<<function [[addropt]]>>

<<function [[maskopt]]>>

<<function [[addrsopt]]>>

<<function [[p9addrsopt]]>>

<<function [[byteopt]]>>

<<function [[termopt]]>>

<<function [[stringopt]]>>

<<function [[vectoropt]]>>

<<function [[fromhex]]>>

<<function [[hexopt]]>>

<<function [[arpenter]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<global [[dhcpmsgname]]>>

<<function [[logdhcp]]>>

<<function [[logdhcpout]]>>

<<function [[ding]]([[(networking/ip/dhcpd/dhcpd.c)]])>>

<<function [[readlast]]>>
@


\subsection*{[[networking/ip/dhcpd/dhcpleases.c]]}

<<global [[now]]([[(networking/ip/dhcpd/dhcpleases.c)]])>>=
long now;
@

<<global [[blog]]([[(networking/ip/dhcpd/dhcpleases.c)]])>>=
char *blog = "ipboot";
@

<<global [[minlease]]([[(networking/ip/dhcpd/dhcpleases.c)]])>>=
int minlease = MinLease;
@

<<function [[main]]([[(networking/ip/dhcpd/dhcpleases.c)]])>>=
void
main(void)
{
    Dir *all;
    int i, nall, fd;
    Binding b;

    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);
    fmtinstall('V', eipfmt);
    fmtinstall('M', eipfmt);

    fd = open(binddir, OREAD);
    if(fd < 0)
        sysfatal("opening %s: %r", binddir);
    nall = dirreadall(fd, &all);
    if(nall < 0)
        sysfatal("reading %s: %r", binddir);
    close(fd);

    b.boundto = 0;
    b.lease = b.offer = 0;
    now = time(0);
    for(i = 0; i < nall; i++){
        if(parseip(b.ip, all[i].name) == -1 || syncbinding(&b, 0) < 0)
            continue;
        if(b.lease > now)
            print("%I leased by %s until %s", b.ip, b.boundto,
                ctime(b.lease));
    }
    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/dhcpleases.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>
#include <ip.h>
#include <dat.h>

extern	char *binddir;

<<global [[now]]([[(networking/ip/dhcpd/dhcpleases.c)]])>>
<<global [[blog]]([[(networking/ip/dhcpd/dhcpleases.c)]])>>
<<global [[minlease]]([[(networking/ip/dhcpd/dhcpleases.c)]])>>

<<function [[main]]([[(networking/ip/dhcpd/dhcpleases.c)]])>>
@


\subsection*{[[networking/ip/dhcpd/ndb.c]]}

<<global [[db]]([[(networking/ip/dhcpd/ndb.c)]])>>=
static Ndb *db;
@

<<global [[ndbfile]]>>=
char *ndbfile;
@

<<function [[opendb]]>>=
/*
 * open ndbfile as db if not already open.  also check for stale data
 * and reload as needed.
 */
static Ndb *
opendb(void)
{
    static ulong lastcheck;

    /* check no more often than once every minute */
    if(db == nil) {
        db = ndbopen(ndbfile);
        if(db != nil)
            lastcheck = now;
    } else if(now >= lastcheck + 60) {
        if (ndbchanged(db))
            ndbreopen(db);
        lastcheck = now;
    }
    return db;
}
@

<<function [[findlifc]]>>=
Iplifc*
findlifc(uchar *ip)
{
    uchar x[IPaddrlen];
    Ipifc *ifc;
    Iplifc *lifc;

    for(ifc = ipifcs; ifc; ifc = ifc->next){
        for(lifc = ifc->lifc; lifc != nil; lifc = lifc->next){
            if(lifc->net[0] == 0)
                continue;
            maskip(ip, lifc->mask, x);
            if(memcmp(x, lifc->net, IPaddrlen) == 0)
                return lifc;
        }
    }
    return nil;
}
@

<<function [[forme]]>>=
int
forme(uchar *ip)
{
    Ipifc *ifc;
    Iplifc *lifc;

    for(ifc = ipifcs; ifc; ifc = ifc->next){
        for(lifc = ifc->lifc; lifc != nil; lifc = lifc->next)
            if(memcmp(ip, lifc->ip, IPaddrlen) == 0)
                return 1;
    }
    return 0;
}
@

<<global [[noetheraddr]]>>=
uchar noetheraddr[6];
@

<<function [[setipaddr]]>>=
static void
setipaddr(uchar *addr, char *ip)
{
    if(ipcmp(addr, IPnoaddr) == 0)
        parseip(addr, ip);
}
@

<<function [[setipmask]]>>=
static void
setipmask(uchar *mask, char *ip)
{
    if(ipcmp(mask, IPnoaddr) == 0)
        parseipmask(mask, ip);
}
@

<<function [[lookupip]]>>=
/*
 *  do an ipinfo with defaults
 */
int
lookupip(uchar *ipaddr, Info *iip, int gate)
{
    char ip[32];
    Ndbtuple *t, *nt;
    char *attrs[32], **p;

    if(opendb() == nil){
        warning(1, "can't open db");
        return -1;
    }

    p = attrs;
    *p++ = "ip";
    *p++ = "ipmask";
    *p++ = "@ipgw";
    if(!gate){
        *p++ = "bootf";
        *p++ = "bootf2";
        *p++ = "@tftp";
        *p++ = "@tftp2";
        *p++ = "rootpath";
        *p++ = "dhcp";
        *p++ = "vendorclass";
        *p++ = "ether";
        *p++ = "dom";
        *p++ = "@fs";
        *p++ = "@auth";
    }
    *p = 0;

    memset(iip, 0, sizeof(*iip));
    snprint(ip, sizeof(ip), "%I", ipaddr);
    t = ndbipinfo(db, "ip", ip, attrs, p - attrs);
    if(t == nil)
        return -1;
    
    for(nt = t; nt != nil; nt = nt->entry){
        if(strcmp(nt->attr, "ip") == 0)
            setipaddr(iip->ipaddr, nt->val);
        else
        if(strcmp(nt->attr, "ipmask") == 0)
            setipmask(iip->ipmask, nt->val);
        else
        if(strcmp(nt->attr, "fs") == 0)
            setipaddr(iip->fsip, nt->val);
        else
        if(strcmp(nt->attr, "auth") == 0)
            setipaddr(iip->auip, nt->val);
        else
        if(strcmp(nt->attr, "tftp") == 0)
            setipaddr(iip->tftp, nt->val);
        else
        if(strcmp(nt->attr, "tftp2") == 0)
            setipaddr(iip->tftp2, nt->val);
        else
        if(strcmp(nt->attr, "ipgw") == 0)
            setipaddr(iip->gwip, nt->val);
        else
        if(strcmp(nt->attr, "ether") == 0){
            /*
             * this is probably wrong for machines with multiple
             * ethers.  bootp or dhcp requests could come from any
             * of the ethers listed in the ndb entry.
             */
            if(memcmp(iip->etheraddr, noetheraddr, 6) == 0)
                parseether(iip->etheraddr, nt->val);
            iip->indb = 1;
        }
        else
        if(strcmp(nt->attr, "dhcp") == 0){
            if(iip->dhcpgroup[0] == 0)
                strcpy(iip->dhcpgroup, nt->val);
        }
        else
        if(strcmp(nt->attr, "bootf") == 0){
            if(iip->bootf[0] == 0)
                strcpy(iip->bootf, nt->val);
        }
        else
        if(strcmp(nt->attr, "bootf2") == 0){
            if(iip->bootf2[0] == 0)
                strcpy(iip->bootf2, nt->val);
        }
        else
        if(strcmp(nt->attr, "vendor") == 0){
            if(iip->vendor[0] == 0)
                strcpy(iip->vendor, nt->val);
        }
        else
        if(strcmp(nt->attr, "dom") == 0){
            if(iip->domain[0] == 0)
                strcpy(iip->domain, nt->val);
        }
        else
        if(strcmp(nt->attr, "rootpath") == 0){
            if(iip->rootpath[0] == 0)
                strcpy(iip->rootpath, nt->val);
        }
    }
    ndbfree(t);
    maskip(iip->ipaddr, iip->ipmask, iip->ipnet);
    return 0;
}
@

<<global [[zeroes]]>>=
static uchar zeroes[6];
@

<<function [[lookup]]([[(networking/ip/dhcpd/ndb.c)]])>>=
/*
 *  lookup info about a client in the database.  Find an address on the
 *  same net as riip.
 */
int
lookup(Bootp *bp, Info *iip, Info *riip)
{
    Ndbtuple *t, *nt;
    Ndbs s;
    char *hwattr;
    char *hwval, hwbuf[33];
    uchar ciaddr[IPaddrlen];

    if(opendb() == nil){
        warning(1, "can't open db");
        return -1;
    }

    memset(iip, 0, sizeof(*iip));

    /* client knows its address? */
    v4tov6(ciaddr, bp->ciaddr);
    if(validip(ciaddr)){
        if(lookupip(ciaddr, iip, 0) < 0) {
            if (debug)
                warning(0, "don't know %I", ciaddr);
            return -1;	/* don't know anything about it */
        }
        if(!samenet(riip->ipaddr, iip)){
            warning(0, "%I not on %I", ciaddr, riip->ipnet);
            return -1;
        }

        /*
         *  see if this is a masquerade, i.e., if the ether
         *  address doesn't match what we expected it to be.
         */
        if(memcmp(iip->etheraddr, zeroes, 6) != 0)
        if(memcmp(bp->chaddr, iip->etheraddr, 6) != 0)
            warning(0, "ciaddr %I rcvd from %E instead of %E",
                ciaddr, bp->chaddr, iip->etheraddr);

        return 0;
    }

    if(bp->hlen > Maxhwlen)
        return -1;
    switch(bp->htype){
    case 1:
        hwattr = "ether";
        hwval = hwbuf;
        snprint(hwbuf, sizeof(hwbuf), "%E", bp->chaddr);
        break;
    default:
        syslog(0, blog, "not ethernet %E, htype %d, hlen %d",
            bp->chaddr, bp->htype, bp->hlen);
        return -1;
    }

    /*
     *  use hardware address to find an ip address on
     *  same net as riip
     */
    t = ndbsearch(db, &s, hwattr, hwval);
    while(t){
        for(nt = t; nt; nt = nt->entry){
            if(strcmp(nt->attr, "ip") != 0)
                continue;
            parseip(ciaddr, nt->val);
            if(lookupip(ciaddr, iip, 0) < 0)
                continue;
            if(samenet(riip->ipaddr, iip)){
                ndbfree(t);
                return 0;
            }
        }
        ndbfree(t);
        t = ndbsnext(&s, hwattr, hwval);
    }
    return -1;
}
@

<<function [[lookupinfo]]([[(networking/ip/dhcpd/ndb.c)]])>>=
/*
 *  interface to ndbipinfo
 */
Ndbtuple*
lookupinfo(uchar *ipaddr, char **attr, int n)
{
    char ip[32];

    sprint(ip, "%I", ipaddr);
    return ndbipinfo(db, "ip", ip, attr, n);
}
@

<<function [[lookupserver]]>>=
/*
 *  return the ip addresses for a type of server for system ip
 */
int
lookupserver(char *attr, uchar **ipaddrs, Ndbtuple *t)
{
    Ndbtuple *nt;
    int rv = 0;

    for(nt = t; rv < 2 && nt != nil; nt = nt->entry)
        if(strcmp(nt->attr, attr) == 0){
            parseip(ipaddrs[rv], nt->val);
            rv++;
        }
    return rv;
}
@

<<function [[lookupname]]>>=
/*
 *  just lookup the name
 */
void
lookupname(char *val, Ndbtuple *t)
{
    Ndbtuple *nt;

    for(nt = t; nt != nil; nt = nt->entry)
        if(strcmp(nt->attr, "dom") == 0){
            strcpy(val, nt->val);
            break;
        }
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/ndb.c>>=
/*
 *  this currently only works for ethernet bootp's -- presotto
 */
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include "dat.h"

<<global [[db]]([[(networking/ip/dhcpd/ndb.c)]])>>
<<global [[ndbfile]]>>

<<function [[opendb]]>>

<<function [[findlifc]]>>

<<function [[forme]]>>

<<global [[noetheraddr]]>>

<<function [[setipaddr]]>>

<<function [[setipmask]]>>

<<function [[lookupip]]>>

<<global [[zeroes]]>>

<<function [[lookup]]([[(networking/ip/dhcpd/ndb.c)]])>>

<<function [[lookupinfo]]([[(networking/ip/dhcpd/ndb.c)]])>>

<<function [[lookupserver]]>>

<<function [[lookupname]]>>
@


\subsection*{[[networking/ip/dhcpd/ping.c]]}

<<function [[catch]]([[(networking/ip/dhcpd/ping.c)]])>>=
static void
catch(void *a, char *msg)
{
    USED(a);
    if(strstr(msg, "alarm"))
        noted(NCONT);
    else
        noted(NDFLT);
}
@

<<constant [[MSG]]([[(networking/ip/dhcpd/ping.c)]])>>=
#define MSG "dhcp probe"
@

<<function [[icmpecho]]>>=
/*
 *  make sure noone is using the address
 *  TODO: ipv6 ping
 */
int
icmpecho(uchar *a)
{
    int fd, i, n, len, rv;
    ushort sseq, x;
    char buf[512];
    Icmphdr *ip;

    rv = 0;
    if (!isv4(a))
        return 0;
    sprint(buf, "%I", a);
    fd = dial(netmkaddr(buf, "icmp", "1"), 0, 0, 0);
    if(fd < 0){
        return 0;
    }

    sseq = getpid()*time(0);

    ip = (Icmphdr *)(buf + IPV4HDR_LEN);
    notify(catch);
    for(i = 0; i < 3; i++){
        ip->type = EchoRequest;
        ip->code = 0;
        strcpy((char*)ip->data, MSG);
        ip->seq[0] = sseq;
        ip->seq[1] = sseq>>8;
        len = IPV4HDR_LEN + ICMP_HDRSIZE + sizeof(MSG);

        /* send a request */
        if(write(fd, buf, len) < len)
            break;

        /* wait 1/10th second for a reply and try again */
        alarm(100);
        n = read(fd, buf, sizeof(buf));
        alarm(0);
        if(n <= 0)
            continue;

        /* an answer to our echo request? */
        x = (ip->seq[1]<<8) | ip->seq[0];
        if(n >= len && ip->type == EchoReply && x == sseq &&
            strcmp((char*)ip->data, MSG) == 0){
            rv = 1;
            break;
        }
    }
    close(fd);
    return rv;
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/ping.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include "../icmp.h"

<<function [[catch]]([[(networking/ip/dhcpd/ping.c)]])>>

<<constant [[MSG]]([[(networking/ip/dhcpd/ping.c)]])>>

<<function [[icmpecho]]>>
@


\subsection*{[[networking/ip/dhcpd/testlook.c]]}

<<global [[noether]]>>=
static uchar noether[6];
@

<<function [[lookval]]>>=
/*
 *  Look for a pair with the given attribute.  look first on the same line,
 *  then in the whole entry.
 */
static Ndbtuple*
lookval(Ndbtuple *entry, Ndbtuple *line, char *attr, char *to)
{
    Ndbtuple *nt;

    /* first look on same line (closer binding) */
    for(nt = line;;){
        if(strcmp(attr, nt->attr) == 0){
            strncpy(to, nt->val, Ndbvlen);
            return nt;
        }
        nt = nt->line;
        if(nt == line)
            break;
    }
    /* search whole tuple */
    for(nt = entry; nt; nt = nt->entry)
        if(strcmp(attr, nt->attr) == 0){
            strncpy(to, nt->val, Ndbvlen);
            return nt;
        }
    return 0;
}
@

<<function [[lookupip]]([[(networking/ip/dhcpd/testlook.c)]])>>=
/*
 *  lookup an ip address
 */
static uchar*
lookupip(Ndb *db, char *name, uchar *to, Ipinfo *iip)
{
    Ndbtuple *t, *nt;
    char buf[Ndbvlen];
    uchar subnet[IPaddrlen];
    Ndbs s;
    char *attr;

    attr = ipattr(name);
    if(strcmp(attr, "ip") == 0){
        parseip(to, name);
        return to;
    }

    t = ndbgetval(db, &s, attr, name, "ip", buf);
    if(t){
        /* first look for match on same subnet */
        for(nt = t; nt; nt = nt->entry){
            if(strcmp(nt->attr, "ip") != 0)
                continue;
            parseip(to, nt->val);
            maskip(to, iip->ipmask, subnet);
            if(memcmp(subnet, iip->ipnet, sizeof(subnet)) == 0)
                return to;
        }

        /* otherwise, just take what we have */
        ndbfree(t);
        parseip(to, buf);
        return to;
    }
    return 0;
}
@

<<function [[recursesubnet]]>>=
/*
 *  lookup a subnet and fill in anything we can
 */
static void
recursesubnet(Ndb *db, uchar *mask, Ipinfo *iip, char *fs, char *gw, char *au)
{
    Ndbs s;
    Ndbtuple *t;
    uchar submask[IPaddrlen];
    char ip[Ndbvlen];

    memmove(iip->ipmask, mask, 4);
    maskip(iip->ipaddr, iip->ipmask, iip->ipnet);
    sprint(ip, "%I", iip->ipnet);
    t = ndbsearch(db, &s, "ip", ip);
print("%s->", ip);
    if(t){
        /* look for a further subnet */
        if(lookval(t, s.t, "ipmask", ip)){
            parseip(submask, ip);

            /* recurse only if it has changed */
            if(!equivip(submask, mask))
                recursesubnet(db, submask, iip, fs, gw, au);

        }

        /* fill in what we don't have */
        if(gw[0] == 0)
            lookval(t, s.t, "ipgw", gw);
        if(fs[0] == 0)
            lookval(t, s.t, "fs", fs);
        if(au[0] == 0)
            lookval(t, s.t, "auth", au);

        ndbfree(t);
    }
}
@

<<function [[ipinfo]]>>=
/*
 *  find out everything we can about a system from what has been
 *  specified.
 */
int
ipinfo(Ndb *db, char *etherin, char *ipin, char *name, Ipinfo *iip)
{
    Ndbtuple *t;
    Ndbs s;
    char ether[Ndbvlen];
    char ip[Ndbvlen];
    char fsname[Ndbvlen];
    char gwname[Ndbvlen];
    char auname[Ndbvlen];

    memset(iip, 0, sizeof(Ipinfo));
    fsname[0] = 0;
    gwname[0] = 0;
    auname[0] = 0;

    /*
     *  look for a matching entry
     */
    t = 0;
    if(etherin)
        t = ndbgetval(db, &s, "ether", etherin, "ip", ip);
    if(t == 0 && ipin)
        t = ndbsearch(db, &s, "ip", ipin);
    if(t == 0 && name)
        t = ndbgetval(db, &s, ipattr(name), name, "ip", ip);
    if(t){
        /*
         *  copy in addresses and name
         */
        if(lookval(t, s.t, "ip", ip))
            parseip(iip->ipaddr, ip);
        if(lookval(t, s.t, "ether", ether))
            parseether(iip->etheraddr, ether);
        lookval(t, s.t, "dom", iip->domain);

        /*
         *  Look for bootfile, fs, and gateway.
         *  If necessary, search through all entries for
         *  this ip address.
         */
        while(t){
            if(iip->bootf[0] == 0)
                lookval(t, s.t, "bootf", iip->bootf);
            if(fsname[0] == 0)
                lookval(t, s.t, "fs", fsname);
            if(gwname[0] == 0)
                lookval(t, s.t, "ipgw", gwname);
            if(auname[0] == 0)
                lookval(t, s.t, "auth", auname);
            ndbfree(t);
            if(iip->bootf[0] && fsname[0] && gwname[0] && auname[0])
                break;
            t = ndbsnext(&s, "ether", ether);
        }
    } else if(ipin) {
        /*
         *  copy in addresses (all we know)
         */
        parseip(iip->ipaddr, ipin);
        if(etherin)
            parseether(iip->etheraddr, etherin);
    } else
        return -1;

    /*
     *  Look up the client's network and find a subnet mask for it.
     *  Fill in from the subnet (or net) entry anything we can't figure
     *  out from the client record.
     */
    recursesubnet(db, classmask[CLASS(iip->ipaddr)], iip, fsname, gwname, auname);

    /* lookup fs's and gw's ip addresses */
    
    if(fsname[0])
        lookupip(db, fsname, iip->fsip, iip);
    if(gwname[0])
        lookupip(db, gwname, iip->gwip, iip);
    if(auname[0])
        lookupip(db, auname, iip->auip, iip);
    return 0;
}
@

<<function [[main]]([[(networking/ip/dhcpd/testlook.c)]])>>=
void
main(int argc, char **argv)
{
    Ipinfo ii;
    Ndb *db;

    db = ndbopen(0);

    fmtinstall('E', eipconv);
    fmtinstall('I', eipconv);
    if(argc < 2)
        exits(0);
    if(strchr(argv[1], '.')){
        if(ipinfo(db, 0, argv[1], 0, &ii) < 0)
            exits(0);
    } else {
        if(ipinfo(db, argv[1], 0, 0, &ii) < 0)
            exits(0);
    }
    fprint(2, "a %I m %I n %I f %s e %E\n", ii.ipaddr,
        ii.ipmask, ii.ipnet, ii.bootf, ii.etheraddr);
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/testlook.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>

<<global [[noether]]>>

<<function [[lookval]]>>

<<function [[lookupip]]([[(networking/ip/dhcpd/testlook.c)]])>>

<<function [[recursesubnet]]>>
#ifdef foo
<<function [[ipinfo]]>>
#endif
<<function [[main]]([[(networking/ip/dhcpd/testlook.c)]])>>
@


\subsection*{[[networking/ip/dhcpd/testlookup.c]]}

<<global [[noether]]([[(networking/ip/dhcpd/testlookup.c)]])>>=
static uchar noether[6];
@

<<global [[db]]([[(networking/ip/dhcpd/testlookup.c)]])>>=
    Ndb *db;
@

<<function [[recursesubnet]]([[(networking/ip/dhcpd/testlookup.c)]])>>=
static void
recursesubnet(Ndb *db, uchar *addr, uchar *mask, char *attr, char *name, char *name1)
{
    Ndbs s;
    Ndbtuple *t, *nt;
    uchar submask[IPaddrlen], net[IPaddrlen];
    char ip[Ndbvlen];
    int found;

    maskip(addr, mask, net);
    sprint(ip, "%I", net);
    t = ndbsearch(db, &s, "ip", ip);
    if(t == 0)
        return;

    for(nt = t; nt; nt = nt->entry){
        if(strcmp(nt->attr, "ipmask") == 0){
            parseip(submask, nt->val);
            if(memcmp(submask, mask, IPaddrlen) != 0)
                recursesubnet(db, addr, submask, attr, name, name1);
            break;
        }
    }

    if(name[0] == 0){
        found = 0;
        for(nt = t; nt; nt = nt->entry){
            if(strcmp(nt->attr, attr) == 0){
                if(found){
                    strcpy(name, nt->val);
                    name1[0] = 0;
                    found = 1;
                } else {
                    strcpy(name1, nt->val);
                    break;
                }
            }
        }
    }

    ndbfree(t);
}
@

<<function [[getipaddr]]>>=
/*
 *  lookup an ip address
 */
static int
getipaddr(Ndb *db, char *name, uchar *to, Ipinfo *iip)
{
    Ndbtuple *t, *nt;
    char buf[Ndbvlen];
    uchar subnet[IPaddrlen];
    Ndbs s;
    char *attr;

    attr = ipattr(name);
    if(strcmp(attr, "ip") == 0){
        parseip(to, name);
        return 1;
    }

    t = ndbgetval(db, &s, attr, name, "ip", buf);
    if(t){
        /* first look for match on same subnet */
        for(nt = t; nt; nt = nt->entry){
            if(strcmp(nt->attr, "ip") != 0)
                continue;
            parseip(to, nt->val);
            maskip(to, iip->ipmask, subnet);
            if(memcmp(subnet, iip->ipnet, sizeof(subnet)) == 0)
                return 1;
        }

        /* otherwise, just take what we have */
        ndbfree(t);
        parseip(to, buf);
        return 1;
    }
    return 0;
}
@

<<function [[lookupserver]]([[(networking/ip/dhcpd/testlookup.c)]])>>=
/*
 *  return the ip addresses for a type of server for system ip
 */
int
lookupserver(char *attr, uchar ipaddrs[2][IPaddrlen], Ipinfo *iip)
{
    Ndbtuple *t, *nt;
    Ndbs s;
    char ip[32];
    char name[Ndbvlen];
    char name1[Ndbvlen];
    int i;

    name[0] = name1[0] = 0;

    snprint(ip, sizeof(ip), "%I", iip->ipaddr);
    t = ndbsearch(db, &s, "ip", ip);
    while(t){
        for(nt = t; nt; nt = nt->entry){
            if(strcmp(attr, nt->attr) == 0){
                if(*name == 0)
                    strcpy(name, nt->val);
                else {
                    strcpy(name1, nt->val);
                    break;
                }
            }
        }
        if(name[0])
            break;
        t = ndbsnext(&s, "ip", ip);
    }

    if(name[0] == 0)
        recursesubnet(db, iip->ipaddr, classmask[CLASS(iip->ipaddr)], attr, name, name1);

    i = 0;
    if(name[0] && getipaddr(db, name, *ipaddrs, iip) == 1){
        ipaddrs++;
        i++;
    }
    if(name1[0] && getipaddr(db, name1, *ipaddrs, iip) == 1)
        i++;
    return i;
}
@

<<function [[main]]([[(networking/ip/dhcpd/testlookup.c)]])>>=
void
main(int argc, char **argv)
{
    Ipinfo ii;
    uchar addrs[2][IPaddrlen];
    int i, j;

    db = ndbopen(0);

    fmtinstall('E', eipconv);
    fmtinstall('I', eipconv);
    if(argc < 2)
        exits(0);
    if(strchr(argv[1], '.')){
        if(ipinfo(db, 0, argv[1], 0, &ii) < 0)
            exits(0);
    } else {
        if(ipinfo(db, argv[1], 0, 0, &ii) < 0)
            exits(0);
    }
    print("a %I m %I n %I f %s e %E a %I\n", ii.ipaddr,
        ii.ipmask, ii.ipnet, ii.bootf, ii.etheraddr, ii.auip);

    i = lookupserver("auth", addrs, &ii);
    print("lookupserver returns %d\n", i);
    for(j = 0; j < i; j++)
        print("%I\n", addrs[j]);
    i = lookupserver("dns", addrs, &ii);
    print("lookupserver returns %d\n", i);
    for(j = 0; j < i; j++)
        print("%I\n", addrs[j]);
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/testlookup.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>

<<global [[noether]]([[(networking/ip/dhcpd/testlookup.c)]])>>
<<global [[db]]([[(networking/ip/dhcpd/testlookup.c)]])>>

<<function [[recursesubnet]]([[(networking/ip/dhcpd/testlookup.c)]])>>

<<function [[getipaddr]]>>

<<function [[lookupserver]]([[(networking/ip/dhcpd/testlookup.c)]])>>

<<function [[main]]([[(networking/ip/dhcpd/testlookup.c)]])>>
@


\subsection*{[[networking/ip/dhcpd/testping.c]]}

<<global [[blog]]([[(networking/ip/dhcpd/testping.c)]])>>=
char	*blog = "ipboot";
@

<<function [[main]]([[(networking/ip/dhcpd/testping.c)]])>>=
void
main(int argc, char **argv)
{
    fmtinstall('E', eipconv);
    fmtinstall('I', eipconv);

    if(argc < 2)
        exits(0);
    if(icmpecho(argv[1]))
        fprint(2, "%s live\n", argv[1]);
    else
        fprint(2, "%s doesn't answer\n", argv[1]);
}
@


%-------------------------------------------------------------

<<networking/ip/dhcpd/testping.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <bio.h>
#include <ndb.h>
#include "dat.h"

<<global [[blog]]([[(networking/ip/dhcpd/testping.c)]])>>

<<function [[main]]([[(networking/ip/dhcpd/testping.c)]])>>
@


\section{[[networking/ip/]]}

\subsection*{[[networking/ip/ftpd.c]]}

<<enum [[_anon_ (networking/ip/ftpd.c)]]>>=
enum
{
    /* telnet control character */
    Iac=		255,

    /* representation types */
    Tascii=		0,
    Timage=		1,

    /* transmission modes */
    Mstream=	0,
    Mblock=		1,
    Mpage=		2,

    /* file structure */
    Sfile=		0,
    Sblock=		1,
    Scompressed=	2,

    /* read/write buffer size */
    Nbuf=		4096,

    /* maximum ms we'll wait for a command */
    Maxwait=	1000*60*30,		/* inactive for 30 minutes, we hang up */

    Maxerr=		128,
    Maxpath=	512,
};
@

<<struct [[Cmd]]>>=
struct Cmd
{
    char	*name;
    int	(*f)(char*);
    int	needlogin;
};
@

<<global [[cmdtab]]>>=
Cmd cmdtab[] =
{
    { "abor",	abortcmd,	0, },
    { "appe",	appendcmd,	1, },
    { "cdup",	cdupcmd,	1, },
    { "cwd",	cwdcmd,		1, },
    { "dele",	delcmd,		1, },
    { "help",	helpcmd,	0, },
    { "list",	listcmd,	1, },
    { "mdtm",	mdtmcmd,	1, },
    { "mkd",	mkdircmd,	1, },
    { "mode",	modecmd,	0, },
    { "nlst",	namelistcmd,	1, },
    { "noop",	nopcmd,		0, },
    { "pass",	passcmd,	0, },
    { "pasv",	pasvcmd,	1, },
    { "pwd",	pwdcmd,		0, },
    { "port", 	portcmd,	1, },
    { "quit",	quitcmd,	0, },
    { "rest",	restartcmd,	1, },
    { "retr",	retrievecmd,	1, },
    { "rmd",	delcmd,		1, },
    { "rnfr",	rnfrcmd,	1, },
    { "rnto",	rntocmd,	1, },
    { "site", sitecmd, 1, },
    { "size", 	sizecmd,	1, },
    { "stor", 	storecmd,	1, },
    { "stou", 	storeucmd,	1, },
    { "stru",	structcmd,	1, },
    { "syst",	systemcmd,	0, },
    { "type", 	typecmd,	0, },
    { "user",	usercmd,	0, },
    { 0, 0, 0 },
};
@

<<constant [[NONENS]]>>=
#define NONENS "/lib/namespace.ftp"	/* default ns for none */
@

<<global [[user]]([[(networking/ip/ftpd.c)]])>>=
char	user[Maxpath];		/* logged in user */
@

<<global [[curdir]]>>=
char	curdir[Maxpath];	/* current directory path */
@

<<global [[ch]]>>=
Chalstate	*ch;
@

<<global [[loggedin]]>>=
int	loggedin;
@

<<global [[type]]>>=
int	type;			/* transmission type */
@

<<global [[mode]]>>=
int	mode;			/* transmission mode */
@

<<global [[structure]]>>=
int	structure;		/* file structure */
@

<<global [[data]]>>=
char	data[64];		/* data address */
@

<<global [[pid]]>>=
int	pid;			/* transfer process */
@

<<global [[encryption]]>>=
int	encryption;		/* encryption state */
@

<<global [[cputype]]>>=
char	cputype[Maxpath];	/* the environment variable of the same name */
@

<<global [[bindir]]>>=
char	bindir[Maxpath];	/* bin directory for this architecture */
@

<<global [[mailaddr]]>>=
char	mailaddr[Maxpath];
@

<<global [[namespace]]>>=
char	*namespace = NONENS;
@

<<global [[debug]]([[(networking/ip/ftpd.c)]])>>=
int	debug;
@

<<global [[nci]]>>=
NetConnInfo	*nci;
@

<<global [[createperm]]>>=
int	createperm = 0660;
@

<<global [[isnoworld]]>>=
int	isnoworld;
@

<<global [[offset]]>>=
vlong	offset;			/* from restart command */
@

<<global [[id]]>>=
ulong id;
@

<<global [[passive]]>>=
struct Passive
{
    int	inuse;
    char	adir[40];
    int	afd;
    int	port;
    uchar	ipaddr[IPaddrlen];
} passive;
@

<<constant [[FTPLOG]]>>=
#define FTPLOG "ftp"
@

<<function [[logit]]([[(networking/ip/ftpd.c)]])>>=
void
logit(char *fmt, ...)
{
    char buf[8192];
    va_list arg;
    char errstr[128];

    rerrstr(errstr, sizeof errstr);
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    syslog(0, FTPLOG, "%s.%s %s", nci->rsys, nci->rserv, buf);
    werrstr(errstr, sizeof errstr);
}
@

<<function [[usage]]([[(networking/ip/ftpd.c)]])>>=
static void
usage(void)
{
    syslog(0, "ftp", "usage: %s [-aAde] [-n nsfile]", argv0);
    fprint(2, "usage: %s [-aAde] [-n nsfile]\n", argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/ftpd.c)]])>>=
/*
 *  read commands from the control stream and dispatch
 */
void
main(int argc, char **argv)
{
    char *cmd;
    char *arg;
    char *p;
    Cmd *t;
    Biobuf in;
    int i;

    ARGBEGIN{
    case 'a':		/* anonymous OK */
        anon_ok = 1;
        break;
    case 'A':
        anon_ok = 1;
        anon_only = 1;
        break;
    case 'd':
        debug++;
        break;
    case 'e':
        anon_ok = 1;
        anon_everybody = 1;
        break;
    case 'n':
        namespace = EARGF(usage());
        break;
    default:
        usage();
    }ARGEND

    /* open log file before doing a newns */
    syslog(0, FTPLOG, nil);

    /* find out who is calling */
    if(argc < 1)
        nci = getnetconninfo(nil, 0);
    else
        nci = getnetconninfo(argv[argc-1], 0);
    if(nci == nil)
        sysfatal("ftpd needs a network address");

    strcpy(mailaddr, "?");
    id = getpid();

    /* figure out which binaries to bind in later (only for none) */
    arg = getenv("cputype");
    if(arg)
        strecpy(cputype, cputype+sizeof cputype, arg);
    else
        strcpy(cputype, "mips");
    /* shurely /%s/bin */
    snprint(bindir, sizeof(bindir), "/bin/%s/bin", cputype);

    Binit(&in, 0, OREAD);
    reply("220 Plan 9 FTP server ready");
    alarm(Maxwait);
    while(cmd = Brdline(&in, '\n')){
        alarm(0);

        /*
         *  strip out trailing cr's & lf and delimit with null
         */
        i = Blinelen(&in)-1;
        cmd[i] = 0;
        if(debug)
            logit("%s", cmd);
        while(i > 0 && cmd[i-1] == '\r')
            cmd[--i] = 0;

        /*
         *  hack for GatorFTP+, look for a 0x10 used as a delimiter
         */
        p = strchr(cmd, 0x10);
        if(p)
            *p = 0;

        /*
         *  get rid of telnet control sequences (we don't need them)
         */
        while(*cmd && (uchar)*cmd == Iac){
            cmd++;
            if(*cmd)
                cmd++;
        }

        /*
         *  parse the message (command arg)
         */
        arg = strchr(cmd, ' ');
        if(arg){
            *arg++ = 0;
            while(*arg == ' ')
                arg++;
        }

        /*
         *  ignore blank commands
         */
        if(*cmd == 0)
            continue;

        /*
         *  lookup the command and do it
         */
        for(p = cmd; *p; p++)
            *p = tolower(*p);
        for(t = cmdtab; t->name; t++)
            if(strcmp(cmd, t->name) == 0){
                if(t->needlogin && !loggedin)
                    sodoff();
                else if((*t->f)(arg) < 0)
                    exits(0);
                break;
            }
        if(t->f != restartcmd){
            /*
             *  the file offset is set to zero following
             *  all commands except the restart command
             */
            offset = 0;
        }
        if(t->name == 0){
            /*
             *  the OOB bytes preceding an abort from UCB machines
             *  comes out as something unrecognizable instead of
             *  IAC's.  Certainly a Plan 9 bug but I can't find it.
             *  This is a major hack to avoid the problem. -- presotto
             */
            i = strlen(cmd);
            if(i > 4 && strcmp(cmd+i-4, "abor") == 0){
                abortcmd(0);
            } else{
                logit("%s (%s) command not implemented", cmd, arg?arg:"");
                reply("502 %s command not implemented", cmd);
            }
        }
        alarm(Maxwait);
    }
    if(pid)
        postnote(PNPROC, pid, "kill");
}
@

<<function [[reply]]([[(networking/ip/ftpd.c)]])>>=
/*
 *  reply to a command
 */
int
reply(char *fmt, ...)
{
    va_list arg;
    char buf[8192], *s;

    va_start(arg, fmt);
    s = vseprint(buf, buf+sizeof(buf)-3, fmt, arg);
    va_end(arg);
    if(debug){
        *s = 0;
        logit("%s", buf);
    }
    *s++ = '\r';
    *s++ = '\n';
    write(1, buf, s - buf);
    return 0;
}
@

<<function [[sodoff]]>>=
int
sodoff(void)
{
    return reply("530 Sod off, service requires login");
}
@

<<function [[asproc]]>>=
/*
 *  run a command in a separate process
 */
int
asproc(void (*f)(char*, int), char *arg, int arg2)
{
    int i;

    if(pid){
        /* wait for previous command to finish */
        for(;;){
            i = waitpid();
            if(i == pid || i < 0)
                break;
        }
    }

    switch(pid = rfork(RFFDG|RFPROC|RFNOTEG)){
    case -1:
        return reply("450 Out of processes: %r");
    case 0:
        (*f)(arg, arg2);
        exits(0);
    default:
        break;
    }
    return 0;
}
@

<<function [[transfer]]>>=
/*
 * run a command to filter a tail
 */
int
transfer(char *cmd, char *a1, char *a2, char *a3, int image)
{
    int n, dfd, fd, bytes, eofs, pid;
    int pfd[2];
    char buf[Nbuf], *p;
    Waitmsg *w;

    reply("150 Opening data connection for %s (%s)", cmd, data);
    dfd = dialdata();
    if(dfd < 0)
        return reply("425 Error opening data connection: %r");

    if(pipe(pfd) < 0)
        return reply("520 Internal Error: %r");

    bytes = 0;
    switch(pid = rfork(RFFDG|RFPROC|RFNAMEG)){
    case -1:
        return reply("450 Out of processes: %r");
    case 0:
        logit("running %s %s %s %s pid %d",
            cmd, a1?a1:"", a2?a2:"" , a3?a3:"",getpid());
        close(pfd[1]);
        close(dfd);
        dup(pfd[0], 1);
        dup(pfd[0], 2);
        if(isnone){
            fd = open("#s/boot", ORDWR);
            if(fd < 0
            || bind("#/", "/", MAFTER) < 0
            || amount(fd, "/bin", MREPL, "") < 0
            || bind("#c", "/dev", MAFTER) < 0
            || bind(bindir, "/bin", MREPL) < 0)
                exits("building name space");
            close(fd);
        }
        execl(cmd, cmd, a1, a2, a3, nil);
        exits(cmd);
    default:
        close(pfd[0]);
        eofs = 0;
        while((n = read(pfd[1], buf, sizeof buf)) >= 0){
            if(n == 0){
                if(eofs++ > 5)
                    break;
                else
                    continue;
            }
            eofs = 0;
            p = buf;
            if(offset > 0){
                if(n > offset){
                    p = buf+offset;
                    n -= offset;
                    offset = 0;
                } else {
                    offset -= n;
                    continue;
                }
            }
            if(!image)
                n = crlfwrite(dfd, p, n);
            else
                n = write(dfd, p, n);
            if(n < 0){
                postnote(PNPROC, pid, "kill");
                bytes = -1;
                break;
            }
            bytes += n;
        }
        close(pfd[1]);
        close(dfd);
        break;
    }

    /* wait for this command to finish */
    for(;;){
        w = wait();
        if(w == nil || w->pid == pid)
            break;
        free(w);
    }
    if(w != nil && w->msg != nil && w->msg[0] != 0){
        bytes = -1;
        logit("%s", w->msg);
        logit("%s %s %s %s failed %s", cmd, a1?a1:"", a2?a2:"" , a3?a3:"", w->msg);
    }
    free(w);
    reply("226 Transfer complete");
    return bytes;
}
@

<<function [[nopcmd]]>>=
/*
 *  just reply OK
 */
int
nopcmd(char *arg)
{
    USED(arg);
    reply("510 Plan 9 FTP daemon still alive");
    return 0;
}
@

<<function [[loginuser]]>>=
/*
 *  login as user
 */
int
loginuser(char *user, char *nsfile, int gotoslash)
{
    logit("login %s %s %s %s", user, mailaddr, nci->rsys, nsfile);
    if(nsfile != nil && newns(user, nsfile) < 0){
        logit("namespace file %s does not exist", nsfile);
        return reply("530 Not logged in: login out of service");
    }
    getwd(curdir, sizeof(curdir));
    if(gotoslash){
        chdir("/");
        strcpy(curdir, "/");
    }
    putenv("service", "ftp");
    loggedin = 1;
    if(debug == 0)
        reply("230- If you have problems, send mail to 'postmaster'.");
    return reply("230 Logged in");
}
@

<<function [[slowdown]]>>=
static void
slowdown(void)
{
    static ulong pause;

    if (pause) {
        sleep(pause);			/* deter guessers */
        if (pause < (1UL << 20))
            pause *= 2;
    } else
        pause = 1000;
}
@

<<function [[usercmd]]>>=
/*
 *  get a user id, reply with a challenge.  The users 'anonymous'
 *  and 'ftp' are equivalent to 'none'.  The user 'none' requires
 *  no challenge.
 */
int
usercmd(char *name)
{
    slowdown();

    logit("user %s %s", name, nci->rsys);
    if(loggedin)
        return reply("530 Already logged in as %s", user);
    if(name == 0 || *name == 0)
        return reply("530 user command needs user name");
    isnoworld = 0;
    if(*name == ':'){
        debug = 1;
        name++;
    }
    strncpy(user, name, sizeof(user));
    if(debug)
        logit("debugging");
    user[sizeof(user)-1] = 0;
    if(strcmp(user, "anonymous") == 0 || strcmp(user, "ftp") == 0)
        strcpy(user, "none");
    else if(anon_everybody)
        strcpy(user,"none");

    if(strcmp(user, "Administrator") == 0 || strcmp(user, "admin") == 0)
        return reply("530 go away, script kiddie");
    else if(strcmp(user, "*none") == 0){
        if(!anon_ok)
            return reply("530 Not logged in: anonymous disallowed");
        return loginuser("none", namespace, 1);
    }
    else if(strcmp(user, "none") == 0){
        if(!anon_ok)
            return reply("530 Not logged in: anonymous disallowed");
        return reply("331 Send email address as password");
    }
    else if(anon_only)
        return reply("530 Not logged in: anonymous access only");

    isnoworld = noworld(name);
    if(isnoworld)
        return reply("331 OK");

    /* consult the auth server */
    if(ch)
        auth_freechal(ch);
    if((ch = auth_challenge("proto=p9cr role=server user=%q", user)) == nil)
        return reply("421 %r");
    return reply("331 encrypt challenge, %s, as a password", ch->chal);
}
@

<<function [[passcmd]]>>=
/*
 *  get a password, set up user if it works.
 */
int
passcmd(char *response)
{
    char namefile[128];
    AuthInfo *ai;

    if(response == nil)
        response = "";

    if(strcmp(user, "none") == 0 || strcmp(user, "*none") == 0){
        /* for none, accept anything as a password */
        isnone = 1;
        strncpy(mailaddr, response, sizeof(mailaddr)-1);
        return loginuser("none", namespace, 1);
    }

    if(isnoworld){
        /* noworld gets a password in the clear */
        if(login(user, response, "/lib/namespace.noworld") < 0)
            return reply("530 Not logged in");
        createperm = 0664;
        /* login has already setup the namespace */
        return loginuser(user, nil, 0);
    } else {
        /* for everyone else, do challenge response */
        if(ch == nil)
            return reply("531 Send user id before encrypted challenge");
        ch->resp = response;
        ch->nresp = strlen(response);
        ai = auth_response(ch);
        if(ai == nil || auth_chuid(ai, nil) < 0) {
            slowdown();
            return reply("530 Not logged in: %r");
        }
        auth_freechal(ch);
        ch = nil;

        /* if the user has specified a namespace for ftp, use it */
        snprint(namefile, sizeof(namefile), "/usr/%s/lib/namespace.ftp", user);
        strcpy(mailaddr, user);
        createperm = 0660;
        if(access(namefile, 0) == 0)
            return loginuser(user, namefile, 0);
        else
            return loginuser(user, "/lib/namespace", 0);
    }
}
@

<<function [[pwdcmd]]>>=
/*
 *  print working directory
 */
int
pwdcmd(char *arg)
{
    if(arg)
        return reply("550 Pwd takes no argument");
    return reply("257 \"%s\" is the current directory", curdir);
}
@

<<function [[cwdcmd]]>>=
/*
 *  chdir
 */
int
cwdcmd(char *dir)
{
    char *rp;
    char buf[Maxpath];

    /* shell cd semantics */
    if(dir == 0 || *dir == 0){
        if(isnone)
            rp = "/";
        else {
            snprint(buf, sizeof buf, "/usr/%s", user);
            rp = buf;
        }
        if(accessok(rp) == 0)
            rp = nil;
    } else
        rp = abspath(dir);

    if(rp == nil)
        return reply("550 Permission denied");

    if(chdir(rp) < 0)
        return reply("550 Cwd failed: %r");
    strcpy(curdir, rp);
    return reply("250 directory changed to %s", curdir);
}
@

<<function [[cdupcmd]]>>=
/*
 *  chdir ..
 */
int
cdupcmd(char *dp)
{
    USED(dp);
    return cwdcmd("..");
}
@

<<function [[quitcmd]]>>=
int
quitcmd(char *arg)
{
    USED(arg);
    reply("200 Bye");
    if(pid)
        postnote(PNPROC, pid, "kill");
    return -1;
}
@

<<function [[typecmd]]>>=
int
typecmd(char *arg)
{
    int c;
    char *x;

    x = arg;
    if(arg == 0)
        return reply("501 Type command needs arguments");

    while(c = *arg++){
        switch(tolower(c)){
        case 'a':
            type = Tascii;
            break;
        case 'i':
        case 'l':
            type = Timage;
            break;
        case '8':
        case ' ':
        case 'n':
        case 't':
        case 'c':
            break;
        default:
            return reply("501 Unimplemented type %s", x);
        }
    }
    return reply("200 Type %s", type==Tascii ? "Ascii" : "Image");
}
@

<<function [[modecmd]]>>=
int
modecmd(char *arg)
{
    if(arg == 0)
        return reply("501 Mode command needs arguments");
    while(*arg){
        switch(tolower(*arg)){
        case 's':
            mode = Mstream;
            break;
        default:
            return reply("501 Unimplemented mode %c", *arg);
        }
        arg++;
    }
    return reply("200 Stream mode");
}
@

<<function [[structcmd]]>>=
int
structcmd(char *arg)
{
    if(arg == 0)
        return reply("501 Struct command needs arguments");
    for(; *arg; arg++){
        switch(tolower(*arg)){
        case 'f':
            structure = Sfile;
            break;
        default:
            return reply("501 Unimplemented structure %c", *arg);
        }
    }
    return reply("200 File structure");
}
@

<<function [[portcmd]]>>=
int
portcmd(char *arg)
{
    char *field[7];
    int n;

    if(arg == 0)
        return reply("501 Port command needs arguments");
    n = getfields(arg, field, 7, 0, ", ");
    if(n != 6)
        return reply("501 Incorrect port specification");
    snprint(data, sizeof data, "tcp!%.3s.%.3s.%.3s.%.3s!%d", field[0], field[1], field[2],
        field[3], atoi(field[4])*256 + atoi(field[5]));
    return reply("200 Data port is %s", data);
}
@

<<function [[mountnet]]>>=
int
mountnet(void)
{
    int rv;

    rv = 0;

    if(bind("#/", "/", MAFTER) < 0){
        logit("can't bind #/ to /: %r");
        return reply("500 can't bind #/ to /: %r");
    }

    if(bind(nci->spec, "/net", MBEFORE) < 0){
        logit("can't bind %s to /net: %r", nci->spec);
        rv = reply("500 can't bind %s to /net: %r", nci->spec);
        unmount("#/", "/");
    }

    return rv;
}
@

<<function [[unmountnet]]>>=
void
unmountnet(void)
{
    unmount(0, "/net");
    unmount("#/", "/");
}
@

<<function [[pasvcmd]]>>=
int
pasvcmd(char *arg)
{
    NetConnInfo *nnci;
    Passive *p;

    USED(arg);
    p = &passive;

    if(p->inuse){
        close(p->afd);
        p->inuse = 0;
    }

    if(mountnet() < 0)
        return 0;

    p->afd = announce("tcp!*!0", passive.adir);
    if(p->afd < 0){
        unmountnet();
        return reply("500 No free ports");
    }
    nnci = getnetconninfo(p->adir, -1);
    unmountnet();

    /* parse the local address */
    if(debug)
        logit("local sys is %s", nci->lsys);
    parseip(p->ipaddr, nci->lsys);
    if(ipcmp(p->ipaddr, v4prefix) == 0 || ipcmp(p->ipaddr, IPnoaddr) == 0)
        parseip(p->ipaddr, nci->lsys);
    p->port = atoi(nnci->lserv);

    freenetconninfo(nnci);
    p->inuse = 1;

    return reply("227 Entering Passive Mode (%d,%d,%d,%d,%d,%d)",
        p->ipaddr[IPv4off+0], p->ipaddr[IPv4off+1], p->ipaddr[IPv4off+2], p->ipaddr[IPv4off+3],
        p->port>>8, p->port&0xff);
}
@

<<enum [[_anon_ (networking/ip/ftpd.c)2]]>>=
enum
{
    Narg=32,
};
@

<<global [[maxnamelen]]>>=
int maxnamelen;
@

<<global [[col]]>>=
int col;
@

<<function [[mode2asc]]>>=
char*
mode2asc(int m)
{
    static char asc[12];
    char *p;

    strcpy(asc, "----------");
    if(DMDIR & m)
        asc[0] = 'd';
    if(DMAPPEND & m)
        asc[0] = 'a';
    else if(DMEXCL & m)
        asc[3] = 'l';

    for(p = asc+1; p < asc + 10; p += 3, m<<=3){
        if(m & 0400)
            p[0] = 'r';
        if(m & 0200)
            p[1] = 'w';
        if(m & 0100)
            p[2] = 'x';
    }
    return asc;
}
@

<<function [[listfile]]>>=
void
listfile(Biobufhdr *b, char *name, int lflag, char *dname)
{
    char ts[32];
    int n, links, pad;
    long now;
    char *x;
    Dir *d;

    x = abspath(name);
    if(x == nil)
        return;
    d = dirstat(x);
    if(d == nil)
        return;
    if(isnone){
        if(strncmp(x, "/incoming/", sizeof("/incoming/")-1) != 0)
            d->mode &= ~0222;
        d->uid = "none";
        d->gid = "none";
    }

    strcpy(ts, ctime(d->mtime));
    ts[16] = 0;
    now = time(0);
    if(now - d->mtime > 6*30*24*60*60)
        memmove(ts+11, ts+23, 5);
    if(lflag){
        /* Unix style long listing */
        if(DMDIR&d->mode){
            links = 2;
            d->length = 512;
        } else
            links = 1;

        Bprint(b, "%s %3d %-8s %-8s %7lld %s ",
            mode2asc(d->mode), links,
            d->uid, d->gid, d->length, ts+4);
    }
    if(Cflag && maxnamelen < 40){
        n = strlen(name);
        pad = ((col+maxnamelen)/(maxnamelen+1))*(maxnamelen+1);
        if(pad+maxnamelen+1 < 60){
            Bprint(b, "%*s", pad-col+n, name);
            col = pad+n;
        }
        else{
            Bprint(b, "\r\n%s", name);
            col = n;
        }
    }
    else{
        if(dname)
            Bprint(b, "%s/", dname);
        Bprint(b, "%s\r\n", name);
    }
    free(d);
}
@

<<function [[dircomp]]>>=
int
dircomp(void *va, void *vb)
{
    int rv;
    Dir *a, *b;

    a = va;
    b = vb;

    if(tflag)
        rv = b->mtime - a->mtime;
    else
        rv = strcmp(a->name, b->name);
    return (rflag?-1:1)*rv;
}
@

<<function [[listdir]]>>=
void
listdir(char *name, Biobufhdr *b, int lflag, int *printname, Globlist *gl)
{
    Dir *p;
    int fd, n, i, l;
    char *dname;
    uvlong total;

    col = 0;

    fd = open(name, OREAD);
    if(fd < 0){
        Bprint(b, "can't read %s: %r\r\n", name);
        return;
    }
    dname = 0;
    if(*printname){
        if(Rflag || lflag)
            Bprint(b, "\r\n%s:\r\n", name);
        else
            dname = name;
    }
    n = dirreadall(fd, &p);
    close(fd);
    if(Cflag){
        for(i = 0; i < n; i++){
            l = strlen(p[i].name);
            if(l > maxnamelen)
                maxnamelen = l;
        }
    }

    /* Unix style total line */
    if(lflag){
        total = 0;
        for(i = 0; i < n; i++){
            if(p[i].qid.type & QTDIR)
                total += 512;
            else
                total += p[i].length;
        }
        Bprint(b, "total %ulld\r\n", total/512);
    }

    qsort(p, n, sizeof(Dir), dircomp);
    for(i = 0; i < n; i++){
        if(Rflag && (p[i].qid.type & QTDIR)){
            *printname = 1;
            globadd(gl, name, p[i].name);
        }
        listfile(b, p[i].name, lflag, dname);
    }
    free(p);
}
@

<<function [[list]]>>=
void
list(char *arg, int lflag)
{
    Dir *d;
    Globlist *gl;
    Glob *g;
    int dfd, printname;
    int i, n, argc;
    char *alist[Narg];
    char **argv;
    Biobufhdr bh;
    uchar buf[512];
    char *p, *s;

    if(arg == 0)
        arg = "";

    if(debug)
        logit("ls %s (. = %s)", arg, curdir);

    /* process arguments, understand /bin/ls -l option */
    argv = alist;
    argv[0] = "/bin/ls";
    argc = getfields(arg, argv+1, Narg-2, 1, " \t") + 1;
    argv[argc] = 0;
    rflag = 0;
    tflag = 0;
    Rflag = 0;
    Cflag = 0;
    col = 0;
    ARGBEGIN{
    case 'l':
        lflag++;
        break;
    case 'R':
        Rflag++;
        break;
    case 'C':
        Cflag++;
        break;
    case 'r':
        rflag++;
        break;
    case 't':
        tflag++;
        break;
    }ARGEND;
    if(Cflag)
        lflag = 0;

    dfd = dialdata();
    if(dfd < 0){
        reply("425 Error opening data connection:%r");
        return;
    }
    reply("150 Opened data connection (%s)", data);

    Binits(&bh, dfd, OWRITE, buf, sizeof(buf));
    if(argc == 0){
        argc = 1;
        argv = alist;
        argv[0] = ".";
    }

    for(i = 0; i < argc; i++){
        chdir(curdir);
        gl = glob(argv[i]);
        if(gl == nil)
            continue;

        printname = gl->first != nil && gl->first->next != nil;
        maxnamelen = 8;

        if(Cflag)
            for(g = gl->first; g; g = g->next)
                if(g->glob && (n = strlen(s_to_c(g->glob))) > maxnamelen)
                    maxnamelen = n;
        while(s = globiter(gl)){
            if(debug)
                logit("glob %s", s);
            p = abspath(s);
            if(p == nil){
                free(s);
                continue;
            }
            d = dirstat(p);
            if(d == nil){
                free(s);
                continue;
            }
            if(d->qid.type & QTDIR)
                listdir(s, &bh, lflag, &printname, gl);
            else
                listfile(&bh, s, lflag, 0);
            free(s);
            free(d);
        }
        globlistfree(gl);
    }
    if(Cflag)
        Bprint(&bh, "\r\n");
    Bflush(&bh);
    close(dfd);

    reply("226 Transfer complete (list %s)", arg);
}
@

<<function [[namelistcmd]]>>=
int
namelistcmd(char *arg)
{
    return asproc(list, arg, 0);
}
@

<<function [[listcmd]]>>=
int
listcmd(char *arg)
{
    return asproc(list, arg, 1);
}
@

<<function [[oksiteuser]]>>=
/*
 * fuse compatability
 */
int
oksiteuser(void)
{
    char buf[64];
    int fd, n;

    fd = open("#c/user", OREAD);
    if(fd < 0)
        return 1;
    n = read(fd, buf, sizeof buf - 1);
    if(n > 0){
        buf[n] = 0;
        if(strcmp(buf, "none") == 0)
            n = -1;
    }
    close(fd);
    return n > 0;
}
@

<<function [[sitecmd]]>>=
int
sitecmd(char *arg)
{
    char *f[4];
    int nf, r;
    Dir *d;

    if(arg == 0)
        return reply("501 bad site command");
    nf = tokenize(arg, f, nelem(f));
    if(nf != 3 || cistrcmp(f[0], "chmod") != 0)
        return reply("501 bad site command");
    if(!oksiteuser())
        return reply("550 Permission denied");
    d = dirstat(f[2]);
    if(d == nil)
        return reply("501 site chmod: file does not exist");
    d->mode &= ~0777;
    d->mode |= strtoul(f[1], 0, 8) & 0777;
    r = dirwstat(f[2], d);
    free(d);
    if(r < 0)
        return reply("550 Permission denied %r");
    return reply("200 very well, then");
 }
@

<<function [[sizecmd]]>>=
/*
 *  return the size of the file
 */
int
sizecmd(char *arg)
{
    Dir *d;
    int rv;

    if(arg == 0)
        return reply("501 Size command requires pathname");
    arg = abspath(arg);
    d = dirstat(arg);
    if(d == nil)
        return reply("501 %r accessing %s", arg);
    rv = reply("213 %lld", d->length);
    free(d);
    return rv;
}
@

<<function [[mdtmcmd]]>>=
/*
 *  return the modify time of the file
 */
int
mdtmcmd(char *arg)
{
    Dir *d;
    Tm *t;
    int rv;

    if(arg == 0)
        return reply("501 Mdtm command requires pathname");
    if(arg == 0)
        return reply("550 Permission denied");
    d = dirstat(arg);
    if(d == nil)
        return reply("501 %r accessing %s", arg);
    t = gmtime(d->mtime);
    rv = reply("213 %4.4d%2.2d%2.2d%2.2d%2.2d%2.2d",
            t->year+1900, t->mon+1, t->mday,
            t->hour, t->min, t->sec);
    free(d);
    return rv;
}
@

<<function [[restartcmd]]>>=
/*
 *  set an offset to start reading a file from
 *  only lasts for one command
 */
int
restartcmd(char *arg)
{
    if(arg == 0)
        return reply("501 Restart command requires offset");
    offset = atoll(arg);
    if(offset < 0){
        offset = 0;
        return reply("501 Bad offset");
    }

    return reply("350 Restarting at %lld. Send STORE or RETRIEVE", offset);
}
@

<<function [[crlfwrite]]>>=
/*
 *  send a file to the user
 */
int
crlfwrite(int fd, char *p, int n)
{
    char *ep, *np;
    char buf[2*Nbuf];

    for(np = buf, ep = p + n; p < ep; p++){
        if(*p == '\n')
            *np++ = '\r';
        *np++ = *p;
    }
    if(write(fd, buf, np - buf) == np - buf)
        return n;
    else
        return -1;
}
@

<<function [[retrievedir]]>>=
void
retrievedir(char *arg)
{
    int n;
    char *p;
    String *file;

    if(type != Timage){
        reply("550 This file requires type binary/image");
        return;
    }

    file = s_copy(arg);
    p = strrchr(s_to_c(file), '/');
    if(p != s_to_c(file)){
        *p++ = 0;
        chdir(s_to_c(file));
    } else {
        chdir("/");
        p = s_to_c(file)+1;
    }

    n = transfer("/bin/tar", "c", p, 0, 1);
    if(n < 0)
        logit("get %s failed", arg);
    else
        logit("get %s OK %d", arg, n);
    s_free(file);
}
@

<<function [[retrieve]]>>=
void
retrieve(char *arg, int arg2)
{
    int dfd, fd, n, i, bytes;
    Dir *d;
    char buf[Nbuf];
    char *p, *ep;

    USED(arg2);

    p = strchr(arg, '\r');
    if(p){
        logit("cr in file name", arg);
        *p = 0;
    }

    fd = open(arg, OREAD);
    if(fd == -1){
        n = strlen(arg);
        if(n > 4 && strcmp(arg+n-4, ".tar") == 0){
            *(arg+n-4) = 0;
            d = dirstat(arg);
            if(d != nil){
                if(d->qid.type & QTDIR){
                    retrievedir(arg);
                    free(d);
                    return;
                }
                free(d);
            }
        }
        logit("get %s failed", arg);
        reply("550 Error opening %s: %r", arg);
        return;
    }
    if(offset != 0)
        if(seek(fd, offset, 0) < 0){
            reply("550 %s: seek to %lld failed", arg, offset);
            close(fd);
            return;
        }
    d = dirfstat(fd);
    if(d != nil){
        if(d->qid.type & QTDIR){
            reply("550 %s: not a plain file.", arg);
            close(fd);
            free(d);
            return;
        }
        free(d);
    }

    n = read(fd, buf, sizeof(buf));
    if(n < 0){
        logit("get %s failed", arg, mailaddr, nci->rsys);
        reply("550 Error reading %s: %r", arg);
        close(fd);
        return;
    }

    if(type != Timage)
        for(p = buf, ep = &buf[n]; p < ep; p++)
            if(*p & 0x80){
                close(fd);
                reply("550 This file requires type binary/image");
                return;
            }

    reply("150 Opening data connection for %s (%s)", arg, data);
    dfd = dialdata();
    if(dfd < 0){
        reply("425 Error opening data connection:%r");
        close(fd);
        return;
    }

    bytes = 0;
    do {
        switch(type){
        case Timage:
            i = write(dfd, buf, n);
            break;
        default:
            i = crlfwrite(dfd, buf, n);
            break;
        }
        if(i != n){
            close(fd);
            close(dfd);
            logit("get %s %r to data connection after %d", arg, bytes);
            reply("550 Error writing to data connection: %r");
            return;
        }
        bytes += n;
    } while((n = read(fd, buf, sizeof(buf))) > 0);

    if(n < 0)
        logit("get %s %r after %d", arg, bytes);

    close(fd);
    close(dfd);
    reply("226 Transfer complete");
    logit("get %s OK %d", arg, bytes);
}
@

<<function [[retrievecmd]]>>=
int
retrievecmd(char *arg)
{
    if(arg == 0)
        return reply("501 Retrieve command requires an argument");
    arg = abspath(arg);
    if(arg == 0)
        return reply("550 Permission denied");

    return asproc(retrieve, arg, 0);
}
@

<<function [[lfwrite]]>>=
/*
 *  get a file from the user
 */
int
lfwrite(int fd, char *p, int n)
{
    char *ep, *np;
    char buf[Nbuf];

    for(np = buf, ep = p + n; p < ep; p++){
        if(*p != '\r')
            *np++ = *p;
    }
    if(write(fd, buf, np - buf) == np - buf)
        return n;
    else
        return -1;
}
@

<<function [[store]]>>=
void
store(char *arg, int fd)
{
    int dfd, n, i;
    char buf[Nbuf];

    reply("150 Opening data connection for %s (%s)", arg, data);
    dfd = dialdata();
    if(dfd < 0){
        reply("425 Error opening data connection:%r");
        close(fd);
        return;
    }

    while((n = read(dfd, buf, sizeof(buf))) > 0){
        switch(type){
        case Timage:
            i = write(fd, buf, n);
            break;
        default:
            i = lfwrite(fd, buf, n);
            break;
        }
        if(i != n){
            close(fd);
            close(dfd);
            reply("550 Error writing file");
            return;
        }
    }
    close(fd);
    close(dfd);
    logit("put %s OK", arg);
    reply("226 Transfer complete");
}
@

<<function [[storecmd]]>>=
int
storecmd(char *arg)
{
    int fd, rv;

    if(arg == 0)
        return reply("501 Store command requires an argument");
    arg = abspath(arg);
    if(arg == 0)
        return reply("550 Permission denied");
    if(isnone && strncmp(arg, "/incoming/", sizeof("/incoming/")-1))
        return reply("550 Permission denied");
    if(offset){
        fd = open(arg, OWRITE);
        if(fd == -1)
            return reply("550 Error opening %s: %r", arg);
        if(seek(fd, offset, 0) == -1)
            return reply("550 Error seeking %s to %d: %r",
                arg, offset);
    } else {
        fd = create(arg, OWRITE, createperm);
        if(fd == -1)
            return reply("550 Error creating %s: %r", arg);
    }

    rv = asproc(store, arg, fd);
    close(fd);
    return rv;
}
@

<<function [[appendcmd]]>>=
int
appendcmd(char *arg)
{
    int fd, rv;

    if(arg == 0)
        return reply("501 Append command requires an argument");
    if(isnone)
        return reply("550 Permission denied");
    arg = abspath(arg);
    if(arg == 0)
        return reply("550 Error creating %s: Permission denied", arg);
    fd = open(arg, OWRITE);
    if(fd == -1){
        fd = create(arg, OWRITE, createperm);
        if(fd == -1)
            return reply("550 Error creating %s: %r", arg);
    }
    seek(fd, 0, 2);

    rv = asproc(store, arg, fd);
    close(fd);
    return rv;
}
@

<<function [[storeucmd]]>>=
int
storeucmd(char *arg)
{
    int fd, rv;
    char name[Maxpath];

    USED(arg);
    if(isnone)
        return reply("550 Permission denied");
    strncpy(name, "ftpXXXXXXXXXXX", sizeof name);
    mktemp(name);
    fd = create(name, OWRITE, createperm);
    if(fd == -1)
        return reply("550 Error creating %s: %r", name);

    rv = asproc(store, name, fd);
    close(fd);
    return rv;
}
@

<<function [[mkdircmd]]>>=
int
mkdircmd(char *name)
{
    int fd;

    if(name == 0)
        return reply("501 Mkdir command requires an argument");
    if(isnone)
        return reply("550 Permission denied");
    name = abspath(name);
    if(name == 0)
        return reply("550 Permission denied");
    fd = create(name, OREAD, DMDIR|0775);
    if(fd < 0)
        return reply("550 Can't create %s: %r", name);
    close(fd);
    return reply("226 %s created", name);
}
@

<<function [[delcmd]]>>=
int
delcmd(char *name)
{
    if(name == 0)
        return reply("501 Rmdir/delete command requires an argument");
    if(isnone)
        return reply("550 Permission denied");
    name = abspath(name);
    if(name == 0)
        return reply("550 Permission denied");
    if(remove(name) < 0)
        return reply("550 Can't remove %s: %r", name);
    else
        return reply("226 %s removed", name);
}
@

<<function [[abortcmd]]>>=
/*
 *  kill off the last transfer (if the process still exists)
 */
int
abortcmd(char *arg)
{
    USED(arg);

    logit("abort pid %d", pid);
    if(pid){
        if(postnote(PNPROC, pid, "kill") == 0)
            reply("426 Command aborted");
        else
            logit("postnote pid %d %r", pid);
    }
    return reply("226 Abort processed");
}
@

<<function [[systemcmd]]>>=
int
systemcmd(char *arg)
{
    USED(arg);
    return reply("215 UNIX Type: L8 Version: Plan 9");
}
@

<<function [[helpcmd]]>>=
int
helpcmd(char *arg)
{
    int i;
    char buf[80];
    char *p, *e;

    USED(arg);
    reply("214- the following commands are implemented:");
    p = buf;
    e = buf+sizeof buf;
    for(i = 0; cmdtab[i].name; i++){
        if((i%8) == 0){
            reply("214-%s", buf);
            p = buf;
        }
        p = seprint(p, e, " %-5.5s", cmdtab[i].name);
    }
    if(p != buf)
        reply("214-%s", buf);
    reply("214 ");
    return 0;
}
@

<<global [[filepath]]>>=
/*
 *  renaming a file takes two commands
 */
static String *filepath;
@

<<function [[rnfrcmd]]>>=
int
rnfrcmd(char *from)
{
    if(isnone)
        return reply("550 Permission denied");
    if(from == 0)
        return reply("501 Rename command requires an argument");
    from = abspath(from);
    if(from == 0)
        return reply("550 Permission denied");
    if(filepath == nil)
        filepath = s_copy(from);
    else{
        s_reset(filepath);
        s_append(filepath, from);
    }
    return reply("350 Rename %s to ...", s_to_c(filepath));
}
@

<<function [[rntocmd]]>>=
int
rntocmd(char *to)
{
    int r;
    Dir nd;
    char *fp, *tp;

    if(isnone)
        return reply("550 Permission denied");
    if(to == 0)
        return reply("501 Rename command requires an argument");
    to = abspath(to);
    if(to == 0)
        return reply("550 Permission denied");
    if(filepath == nil || *(s_to_c(filepath)) == 0)
        return reply("503 Rnto must be preceeded by an rnfr");

    tp = strrchr(to, '/');
    fp = strrchr(s_to_c(filepath), '/');
    if((tp && fp == 0) || (fp && tp == 0)
    || (fp && tp && (fp-s_to_c(filepath) != tp-to || memcmp(s_to_c(filepath), to, tp-to))))
        return reply("550 Rename can't change directory");
    if(tp)
        to = tp+1;

    nulldir(&nd);
    nd.name = to;
    if(dirwstat(s_to_c(filepath), &nd) < 0)
        r = reply("550 Can't rename %s to %s: %r\n", s_to_c(filepath), to);
    else
        r = reply("250 %s now %s", s_to_c(filepath), to);
    s_reset(filepath);

    return r;
}
@

<<function [[dialdata]]>>=
/*
 *  to dial out we need the network file system in our
 *  name space.
 */
int
dialdata(void)
{
    int fd, cfd;
    char ldir[40];
    char err[Maxerr];

    if(mountnet() < 0)
        return -1;

    if(!passive.inuse){
        fd = dial(data, "20", 0, 0);
        errstr(err, sizeof err);
    } else {
        alarm(5*60*1000);
        cfd = listen(passive.adir, ldir);
        alarm(0);
        errstr(err, sizeof err);
        if(cfd < 0)
            return -1;
        fd = accept(cfd, ldir);
        errstr(err, sizeof err);
        close(cfd);
    }
    if(fd < 0)
        logit("can't dial %s: %s", data, err);

    unmountnet();
    werrstr(err, sizeof err);
    return fd;
}
@

<<function [[postnote]]>>=
int
postnote(int group, int pid, char *note)
{
    char file[128];
    int f, r;

    /*
     * Use #p because /proc may not be in the namespace.
     */
    switch(group) {
    case PNPROC:
        sprint(file, "#p/%d/note", pid);
        break;
    case PNGROUP:
        sprint(file, "#p/%d/notepg", pid);
        break;
    default:
        return -1;
    }

    f = open(file, OWRITE);
    if(f < 0)
        return -1;

    r = strlen(note);
    if(write(f, note, r) != r) {
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@

<<global [[special]]>>=
/*
 *  to circumscribe the accessible files we have to eliminate ..'s
 *  and resolve all names from the root.  We also remove any /bin/rc
 *  special characters to avoid later problems with executed commands.
 */
char *special = "`;| ";
@

<<function [[abspath]]>>=
char*
abspath(char *origpath)
{
    char *p, *sp, *path;
    static String *rpath;

    if(rpath == nil)
        rpath = s_new();
    else
        s_reset(rpath);

    if(origpath == nil)
        s_append(rpath, curdir);
    else{
        if(*origpath != '/'){
            s_append(rpath, curdir);
            s_append(rpath, "/");
        }
        s_append(rpath, origpath);
    }
    path = s_to_c(rpath);

    for(sp = special; *sp; sp++){
        p = strchr(path, *sp);
        if(p)
            *p = 0;
    }

    cleanname(s_to_c(rpath));
    rpath->ptr = rpath->base+strlen(rpath->base);

    if(!accessok(s_to_c(rpath)))
        return nil;

    return s_to_c(rpath);
}
@

<<struct [[Path]]>>=
struct Path {
    Path	*next;
    String	*path;
    int	inuse;
    int	ok;
};
@

<<enum [[_anon_ (networking/ip/ftpd.c)3]]>>=
enum
{
    Maxlevel = 16,
    Maxperlevel= 8,
};
@

<<global [[pathlevel]]>>=
Path *pathlevel[Maxlevel];
@

<<function [[unlinkpath]]>>=
Path*
unlinkpath(char *path, int level)
{
    String *s;
    Path **l, *p;
    int n;

    n = 0;
    for(l = &pathlevel[level]; *l; l = &(*l)->next){
        p = *l;
        /* hit */
        if(strcmp(s_to_c(p->path), path) == 0){
            *l = p->next;
            p->next = nil;
            return p;
        }
        /* reuse */
        if(++n >= Maxperlevel){
            *l = p->next;
            s = p->path;
            s_reset(p->path);
            memset(p, 0, sizeof *p);
            p->path = s_append(s, path);
            return p;
        }
    }

    /* allocate */
    p = mallocz(sizeof *p, 1);
    p->path = s_copy(path);
    return p;
}
@

<<function [[linkpath]]>>=
void
linkpath(Path *p, int level)
{
    p->next = pathlevel[level];
    pathlevel[level] = p;
    p->inuse = 1;
}
@

<<function [[addpath]]>>=
void
addpath(Path *p, int level, int ok)
{
    p->ok = ok;
    p->next = pathlevel[level];
    pathlevel[level] = p;
}
@

<<function [[_accessok]]>>=
int
_accessok(String *s, int level)
{
    Path *p;
    char *cp;
    int lvl, offset;
    static char httplogin[] = "/.httplogin";

    if(level < 0)
        return 1;
    lvl = level;
    if(lvl >= Maxlevel)
        lvl = Maxlevel - 1;

    p = unlinkpath(s_to_c(s), lvl);
    if(p->inuse){
        /* move to front */
        linkpath(p, lvl);
        return p->ok;
    }
    cp = strrchr(s_to_c(s), '/');
    if(cp == nil)
        offset = 0;
    else
        offset = cp - s_to_c(s);
    s_append(s, httplogin);
    if(access(s_to_c(s), AEXIST) == 0){
        addpath(p, lvl, 0);
        return 0;
    }

    /*
     * There's no way to shorten a String without
     * knowing the implementation.
     */
    s->ptr = s->base+offset;
    s_terminate(s);
    addpath(p, lvl, _accessok(s, level-1));

    return p->ok;
}
@

<<function [[accessok]]>>=
/*
 * check for a subdirectory containing .httplogin
 * at each level of the path.
 */
int
accessok(char *path)
{
    int level, r;
    char *p;
    String *npath;

    npath = s_copy(path);
    p = s_to_c(npath)+1;
    for(level = 1; level < Maxlevel; level++){
        p = strchr(p, '/');
        if(p == nil)
            break;
        p++;
    }

    r = _accessok(npath, level-1);
    s_free(npath);

    return r;
}
@


%-------------------------------------------------------------

<<networking/ip/ftpd.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include <ip.h>
#include <libsec.h>
#include <string.h>

#include "glob.h"

<<enum [[_anon_ (networking/ip/ftpd.c)]]>>

int	abortcmd(char*);
int	appendcmd(char*);
int	cdupcmd(char*);
int	cwdcmd(char*);
int	delcmd(char*);
int	helpcmd(char*);
int	listcmd(char*);
int	mdtmcmd(char*);
int	mkdircmd(char*);
int	modecmd(char*);
int	namelistcmd(char*);
int	nopcmd(char*);
int	passcmd(char*);
int	pasvcmd(char*);
int	portcmd(char*);
int	pwdcmd(char*);
int	quitcmd(char*);
int	rnfrcmd(char*);
int	rntocmd(char*);
int	reply(char*, ...);
int	restartcmd(char*);
int	retrievecmd(char*);
int	sitecmd(char*);
int	sizecmd(char*);
int	storecmd(char*);
int	storeucmd(char*);
int	structcmd(char*);
int	systemcmd(char*);
int	typecmd(char*);
int	usercmd(char*);

int	dialdata(void);
char*	abspath(char*);
int	crlfwrite(int, char*, int);
int	sodoff(void);
int	accessok(char*);

typedef struct Cmd	Cmd;
<<struct [[Cmd]]>>

<<global [[cmdtab]]>>

<<constant [[NONENS]]>>

<<global [[user]]([[(networking/ip/ftpd.c)]])>>
<<global [[curdir]]>>
<<global [[ch]]>>
<<global [[loggedin]]>>
<<global [[type]]>>
<<global [[mode]]>>
<<global [[structure]]>>
<<global [[data]]>>
<<global [[pid]]>>
<<global [[encryption]]>>
int	isnone, anon_ok, anon_only, anon_everybody;
<<global [[cputype]]>>
<<global [[bindir]]>>
<<global [[mailaddr]]>>
<<global [[namespace]]>>
<<global [[debug]]([[(networking/ip/ftpd.c)]])>>
<<global [[nci]]>>
<<global [[createperm]]>>
<<global [[isnoworld]]>>
<<global [[offset]]>>

<<global [[id]]>>

typedef struct Passive Passive;
<<global [[passive]]>>

<<constant [[FTPLOG]]>>

<<function [[logit]]([[(networking/ip/ftpd.c)]])>>

<<function [[usage]]([[(networking/ip/ftpd.c)]])>>

<<function [[main]]([[(networking/ip/ftpd.c)]])>>

<<function [[reply]]([[(networking/ip/ftpd.c)]])>>

<<function [[sodoff]]>>

<<function [[asproc]]>>

<<function [[transfer]]>>


<<function [[nopcmd]]>>

<<function [[loginuser]]>>

<<function [[slowdown]]>>

<<function [[usercmd]]>>

<<function [[passcmd]]>>

<<function [[pwdcmd]]>>

<<function [[cwdcmd]]>>

<<function [[cdupcmd]]>>

<<function [[quitcmd]]>>

<<function [[typecmd]]>>

<<function [[modecmd]]>>

<<function [[structcmd]]>>

<<function [[portcmd]]>>

<<function [[mountnet]]>>

<<function [[unmountnet]]>>

<<function [[pasvcmd]]>>

<<enum [[_anon_ (networking/ip/ftpd.c)2]]>>
int Cflag, rflag, tflag, Rflag;
<<global [[maxnamelen]]>>
<<global [[col]]>>

<<function [[mode2asc]]>>
<<function [[listfile]]>>
<<function [[dircomp]]>>
<<function [[listdir]]>>
<<function [[list]]>>
<<function [[namelistcmd]]>>
<<function [[listcmd]]>>

<<function [[oksiteuser]]>>

<<function [[sitecmd]]>>

<<function [[sizecmd]]>>

<<function [[mdtmcmd]]>>

<<function [[restartcmd]]>>

<<function [[crlfwrite]]>>
<<function [[retrievedir]]>>
<<function [[retrieve]]>>
<<function [[retrievecmd]]>>

<<function [[lfwrite]]>>
<<function [[store]]>>
<<function [[storecmd]]>>
<<function [[appendcmd]]>>
<<function [[storeucmd]]>>

<<function [[mkdircmd]]>>

<<function [[delcmd]]>>

<<function [[abortcmd]]>>

<<function [[systemcmd]]>>

<<function [[helpcmd]]>>

<<global [[filepath]]>>

<<function [[rnfrcmd]]>>
<<function [[rntocmd]]>>

<<function [[dialdata]]>>

<<function [[postnote]]>>

<<global [[special]]>>

<<function [[abspath]]>>

typedef struct Path Path;
<<struct [[Path]]>>

<<enum [[_anon_ (networking/ip/ftpd.c)3]]>>

<<global [[pathlevel]]>>

<<function [[unlinkpath]]>>

<<function [[linkpath]]>>

<<function [[addpath]]>>

<<function [[_accessok]]>>

<<function [[accessok]]>>
@


\section{[[networking/ip/ftpfs/]]}

\subsection*{[[networking/ip/ftpfs/file.c]]}

<<enum [[_anon_ (networking/ip/ftpfs/file.c)]]>>=
enum
{
    Chunk=		1024,		/* chunk size for buffered data */
    Nfile=		128,		/* maximum number of cached files */
};
@

<<struct [[File]]([[(networking/ip/ftpfs/file.c)]])>>=
/* a file (with cached data) */
struct File
{
    char	*mem;		/* part of file cached in memory */
    ulong	len;		/* length of cached data */
    long	off;		/* current offset into tpath */
    short	fd;		/* fd to cache file */
    char	inuse;
    char	dirty;
    ulong	atime;		/* time of last access */
    Node	*node;
    char 	*template;
};
@

<<global [[files]]>>=
static File	files[Nfile];
@

<<global [[now]]([[(networking/ip/ftpfs/file.c)]])>>=
static ulong	now;
@

<<global [[ntmp]]>>=
static int	ntmp;
@

<<function [[fileget]]>>=
/*
 *  lookup a file, create one if not found.  if there are no
 *  free files, free the last oldest clean one.
 */
static File*
fileget(Node *node)
{
    File *fp;
    File *oldest;

    fp = node->fp;
    if(fp)
        return fp;

    oldest = 0;
    for(fp = files; fp < &files[Nfile]; fp++){
        if(fp->inuse == 0)
            break;
        if(fp->dirty == 0 && (oldest == 0 || oldest->atime > fp->atime))
            oldest = fp;
    }

    if(fp == &files[Nfile]){
        uncache(oldest->node);
        fp = oldest;
    }
    node->fp = fp;
    fp->node = node;
    fp->atime = now++;
    fp->inuse = 1;
    fp->fd = -1;
    if(fp->mem){
        free(fp->mem);
        fp->mem = nil;
    }
    return fp;
}
@

<<function [[filefree]]>>=
/*
 *  free a cached file
 */
void
filefree(Node *node)
{
    File *fp;

    fp = node->fp;
    if(fp == 0)
        return;

    if(fp->fd > 0){
        ntmp--;
        close(fp->fd);
        remove(fp->template);
        free(fp->template);
        fp->template = 0;
    }
    fp->fd = -1;
    if(fp->mem){
        free(fp->mem);
        fp->mem = nil;
    }
    fp->len = 0;
    fp->inuse = 0;
    fp->dirty = 0;

    node->fp = 0;
}
@

<<function [[fileread]]>>=
/*
 *  satisfy read first from in memory chunk and then from temporary
 *  file.  It's up to the caller to make sure that the file is valid.
 */
int
fileread(Node *node, char *a, long off, int n)
{
    int sofar;
    int i;
    File *fp;

    fp = node->fp;
    if(fp == 0)
        fatal("fileread");

    if(off + n > fp->len)
        n = fp->len - off;

    for(sofar = 0; sofar < n; sofar += i, off += i, a += i){
        if(off >= fp->len)
            return sofar;
        if(off < Chunk){
            i = n;
            if(off + i > Chunk)
                i = Chunk - off;
            memmove(a, fp->mem + off, i);
            continue;
        }
        if(fp->off != off)
            if(seek(fp->fd, off, 0) < 0){
                fp->off = -1;
                return -1;
            }
        i = read(fp->fd, a, n-sofar);
        if(i < 0){
            fp->off = -1;
            return -1;
        }
        if(i == 0)
            break;
        fp->off = off + i;
    }
    return sofar;
}
@

<<function [[uncachedir]]>>=
void
uncachedir(Node *parent, Node *child)
{
    Node *sp;

    if(parent == 0 || parent == child)
        return;
    for(sp = parent->children; sp; sp = sp->sibs)
        if(sp->opens == 0)
        if(sp != child)
        if(sp->fp != nil)
        if(sp->fp->dirty == 0)
        if(sp->fp->fd >= 0){
            filefree(sp);
            UNCACHED(sp);
        }
}
@

<<function [[createtmp]]>>=
static int
createtmp(File *fp)
{
    char template[32];

    strcpy(template, "/tmp/ftpXXXXXXXXXXX");
    mktemp(template);
    if(strcmp(template, "/") == 0){
        fprint(2, "ftpfs can't create tmp file %s: %r\n", template);
        return -1;
    }
    if(ntmp >= 16)
        uncachedir(fp->node->parent, fp->node);

    fp->fd = create(template, ORDWR|ORCLOSE, 0600);
    fp->template = strdup(template);
    fp->off = 0;
    ntmp++;
    return fp->fd;
}
@

<<function [[filewrite]]>>=
/*
 *  write cached data (first Chunk bytes stay in memory)
 */
int
filewrite(Node *node, char *a, long off, int n)
{
    int i, sofar;
    File *fp;

    fp = fileget(node);

    if(fp->mem == nil){
        fp->mem = malloc(Chunk);
        if(fp->mem == nil)
            return seterr("out of memory");
    }

    for(sofar = 0; sofar < n; sofar += i, off += i, a += i){
        if(off < Chunk){
            i = n;
            if(off + i > Chunk)
                i = Chunk - off;
            memmove(fp->mem + off, a, i);
            continue;
        }
        if(fp->fd < 0)
            if(createtmp(fp) < 0)
                return seterr("can't create temp file");
        if(fp->off != off)
            if(seek(fp->fd, off, 0) < 0){
                fp->off = -1;
                return seterr("can't seek temp file");
            }
        i = write(fp->fd, a, n-sofar);
        if(i <= 0){
            fp->off = -1;
            return seterr("can't write temp file");
        }
        fp->off = off + i;
    }

    if(off > fp->len)
        fp->len = off;
    if(off > node->d->length)
        node->d->length = off;
    return sofar;
}
@

<<function [[filedirty]]>>=
/*
 *  mark a file as dirty
 */
void
filedirty(Node *node)
{
    File *fp;

    fp = fileget(node);
    fp->dirty = 1;
}
@

<<function [[fileclean]]>>=
/*
 *  mark a file as clean
 */
void
fileclean(Node *node)
{
    if(node->fp)
        node->fp->dirty = 0;
}
@

<<function [[fileisdirty]]>>=
int
fileisdirty(Node *node)
{
    return node->fp && node->fp->dirty;
}
@


%-------------------------------------------------------------

<<networking/ip/ftpfs/file.c>>=
#include <u.h>
#include <libc.h>
#include <string.h>
#include "ftpfs.h"

<<enum [[_anon_ (networking/ip/ftpfs/file.c)]]>>

<<struct [[File]]([[(networking/ip/ftpfs/file.c)]])>>

<<global [[files]]>>
<<global [[now]]([[(networking/ip/ftpfs/file.c)]])>>
<<global [[ntmp]]>>

<<function [[fileget]]>>

<<function [[filefree]]>>

<<function [[fileread]]>>

<<function [[uncachedir]]>>

<<function [[createtmp]]>>

<<function [[filewrite]]>>

<<function [[filedirty]]>>

<<function [[fileclean]]>>

<<function [[fileisdirty]]>>
@


\subsection*{[[networking/ip/ftpfs/ftpfs.c]]}

<<struct [[Fid]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
struct Fid
{
    int	fid;
    Node	*node;		/* path to remote file */
    int	busy;
    Fid	*next;
    int	open;
};
@

<<global [[fids]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
Fid	*fids;			/* linked list of fids */
@

<<global [[errstring]]>>=
char	errstring[128];		/* error to return */
@

<<global [[mfd]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
int	mfd;			/* fd for 9fs */
@

<<global [[messagesize]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
int	messagesize = 4*1024*IOHDRSZ;
@

<<global [[mdata]]>>=
uchar	mdata[8*1024*IOHDRSZ];
@

<<global [[mbuf]]>>=
uchar	mbuf[8*1024*IOHDRSZ];
@

<<global [[rhdr]]>>=
Fcall	rhdr;
@

<<global [[thdr]]>>=
Fcall	thdr;
@

<<global [[debug]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
int	debug;
@

<<global [[usenlst]]>>=
int	usenlst;
@

<<global [[usetls]]>>=
int	usetls;
@

<<global [[ext]]>>=
char	*ext;
@

<<global [[quiet]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
int	quiet;
@

<<global [[kapid]]>>=
int	kapid = -1;
@

<<global [[dying]]>>=
int	dying;		/* set when any process decides to die */
@

<<global [[dokeepalive]]>>=
int	dokeepalive;
@

<<global [[fcalls]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char 	*(*fcalls[])(Fid*) = {
    [Tflush]	rflush,
    [Tversion]	rversion,
    [Tattach]	rattach,
    [Tauth]		rauth,
    [Twalk]		rwalk,
    [Topen]		ropen,
    [Tcreate]	rcreate,
    [Tread]		rread,
    [Twrite]	rwrite,
    [Tclunk]	rclunk,
    [Tremove]	rremove,
    [Tstat]		rstat,
    [Twstat]	rwstat,
};
@

<<global [[oslist]]>>=
/* these names are matched as prefixes, so VMS must precede VM */
OS oslist[] = {
    { Plan9,	"Plan 9", },
    { Plan9,	"Plan9", },
    { Plan9,	"UNIX Type: L8 Version: Plan 9", },
    { Unix,		"SUN", },
    { Unix,		"UNIX", },
    { VMS,		"VMS", },
    { VM,		"VM", },
    { Tops,		"TOPS", },
    { MVS,		"MVS", },
    { NetWare,	"NetWare", },
    { NetWare,	"NETWARE", },
//	{ OS½,		"OS/2", },
    { TSO,		"TSO", },
    { NT,		"Windows_NT", },	/* DOS like interface */
    { NT,		"WINDOWS_NT", },	/* Unix like interface */
    { Unknown,	0 },
};
@

<<global [[nouid]]>>=
char *nouid = "?uid?";
@

<<macro [[S2P]]>>=
#define S2P(x) (((ulong)(x)) & 0xffffff)
@

<<global [[nosuchfile]]>>=
char *nosuchfile = "file does not exist";
@

<<global [[keyspec]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char *keyspec = "";
@

<<function [[usage]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
void
usage(void)
{
    fprint(2, "ftpfs [-/dqnt] [-a passwd] [-m mountpoint] [-e ext] [-k keyspec] [-o os] [-r root] [net!]address\n");
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
void
main(int argc, char *argv[])
{
    char *mountroot = 0;
    char *mountpoint = "/n/ftp";
    char *cpassword = 0;
    char *cp;
    int p[2];
    OS *o;

    defos = Unix;
    user = strdup(getuser());
    usetls = 0;

    ARGBEGIN {
    case '/':
        mountroot = "/";
        break;
    case 'a':
        cpassword = ARGF();
        break;
    case 'd':
        debug = 1;
        break;
    case 'k':
        keyspec = EARGF(usage());
        break;
    case 'K':
        dokeepalive = 1;
        break;
    case 'm':
        mountpoint = ARGF();
        break;
    case 'n':
        usenlst = 1;
        break;
    case 'e':
        ext = ARGF();
        break;
    case 't':
        usetls = 1;
        break;
    case 'o':
        cp = ARGF();
        for(o = oslist; o->os != Unknown; o++)
            if(strncmp(cp, o->name, strlen(o->name)) == 0){
                defos = o->os;
                break;
            }
        break;
    case 'r':
        mountroot = ARGF();
        break;
    case 'q':
        quiet = 1;
        break;
    } ARGEND
    if(argc != 1)
        usage();

    /* get a pipe to mount and run 9fs on */
    if(pipe(p) < 0)
        fatal("pipe failed: %r");
    mfd = p[0];

    /* initial handshakes with remote side */
    hello(*argv);
    if(cpassword == 0)
        rlogin(*argv, keyspec);
    else
        clogin("anonymous", cpassword);
    preamble(mountroot);

    /* start the 9fs protocol */
    switch(rfork(RFPROC|RFNAMEG|RFENVG|RFFDG|RFNOTEG|RFREND)){
    case -1:
        fatal("fork: %r");
    case 0:
        /* seal off standard input/output */
        close(0);
        open("/dev/null", OREAD);
        close(1);
        open("/dev/null", OWRITE);

        close(p[1]);
        fmtinstall('F', fcallfmt); /* debugging */
        fmtinstall('D', dirfmt); /* expected by %F */
        fmtinstall('M', dirmodefmt); /* expected by %F */
        io();
        quit();
        break;
    default:
        close(p[0]);
        if(mount(p[1], -1, mountpoint, MREPL|MCREATE, "") < 0)
            fatal("mount failed: %r");
    }
    exits(0);
}
@

<<function [[newfid]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
/*
 *  lookup an fid. if not found, create a new one.
 */
Fid *
newfid(int fid)
{
    Fid *f, *ff;

    ff = 0;
    for(f = fids; f; f = f->next){
        if(f->fid == fid){
            if(f->busy)
                return f;
            else{
                ff = f;
                break;
            }
        } else if(!ff && !f->busy)
            ff = f;
    }
    if(ff == 0){
        ff = mallocz(sizeof(*f), 1);
        ff->next = fids;
        fids = ff;
    }
    ff->node = nil;
    ff->fid = fid;
    return ff;
}
@

<<function [[kaproc]]>>=
/*
 *  a process that sends keep alive messages to
 *  keep the server from shutting down the connection
 */
int
kaproc(void)
{
    int pid;

    if(!dokeepalive)
        return -1;

    switch(pid = rfork(RFPROC|RFMEM)){
    case -1:
        return -1;
    case 0:
        break;
    default:
        return pid;
    }

    while(!dying){
        sleep(5000);
        nop();
    }

    _exits(0);
    return -1;
}
@

<<function [[io]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
void
io(void)
{
    char *err, buf[ERRMAX];
    int n;

    kapid = kaproc();

    while(!dying){
        n = read9pmsg(mfd, mdata, messagesize);
        if(n <= 0){
            errstr(buf, sizeof buf);
            if(buf[0]=='\0' || strstr(buf, "hungup"))
                exits("");
            fatal("mount read: %s\n", buf);
        }
        if(convM2S(mdata, n, &thdr) == 0)
            continue;

        if(debug)
            fprint(2, "<-%F\n", &thdr);/**/

        if(!fcalls[thdr.type])
            err = "bad fcall type";
        else
            err = (*fcalls[thdr.type])(newfid(thdr.fid));
        if(err){
            rhdr.type = Rerror;
            rhdr.ename = err;
        }else{
            rhdr.type = thdr.type + 1;
            rhdr.fid = thdr.fid;
        }
        rhdr.tag = thdr.tag;
        if(debug)
            fprint(2, "->%F\n", &rhdr);/**/
        n = convS2M(&rhdr, mdata, messagesize);
        if(write(mfd, mdata, n) != n)
            fatal("mount write");
    }
}
@

<<function [[rnop]]>>=
char*
rnop(Fid *f)
{
    USED(f);
    return 0;
}
@

<<function [[rversion]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char*
rversion(Fid*)
{
    if(thdr.msize > sizeof(mdata))
        rhdr.msize = messagesize;
    else
        rhdr.msize = thdr.msize;
    messagesize = thdr.msize;

    if(strncmp(thdr.version, "9P2000", 6) != 0)
        return "unknown 9P version";
    rhdr.version = "9P2000";
    return nil;
}
@

<<function [[rflush]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char*
rflush(Fid*)
{
    return 0;
}
@

<<function [[rauth]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char*
rauth(Fid*)
{
    return "auth unimplemented";
}
@

<<function [[rattach]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char*
rattach(Fid *f)
{
    f->busy = 1;
    f->node = remroot;
    rhdr.qid = f->node->d->qid;
    return 0;
}
@

<<function [[rwalk]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char*
rwalk(Fid *f)
{
    Node *np;
    Fid *nf;
    char **elems;
    int i, nelems;
    char *err;
    Node *node;

    /* clone fid */
    nf = nil;
    if(thdr.newfid != thdr.fid){
        nf = newfid(thdr.newfid);
        if(nf->busy)
            return "newfid in use";
        nf->busy = 1;
        nf->node = f->node;
        f = nf;
    }

    err = nil;
    elems = thdr.wname;
    nelems = thdr.nwname;
    node = f->node;
    rhdr.nwqid = 0;
    if(nelems > 0){
        /* walk fid */
        for(i=0; i<nelems && i<MAXWELEM; i++){
            if((node->d->qid.type & QTDIR) == 0){
                err = "not a directory";
                break;
            }
            if(strcmp(elems[i], ".") == 0){
   Found:
                rhdr.wqid[i] = node->d->qid;
                rhdr.nwqid++;
                continue;
            }
            if(strcmp(elems[i], "..") == 0){
                node = node->parent;
                goto Found;
            }
            if(strcmp(elems[i], ".flush.ftpfs") == 0){
                /* hack to flush the cache */
                invalidate(node);
                readdir(node);
                goto Found;
            }

            /* some top level names are special */
            if((os == Tops || os == VM || os == VMS) && node == remroot){
                np = newtopsdir(elems[i]);
                if(np){
                    node = np;
                    goto Found;
                } else {
                    err = nosuchfile;
                    break;
                }
            }

            /* everything else */
            node = extendpath(node, s_copy(elems[i]));
            if(ISCACHED(node->parent)){
                /* the cache of the parent is good, believe it */
                if(!ISVALID(node)){
                    err = nosuchfile;
                    break;
                }
                if(node->parent->chdirunknown || (node->d->mode & DMSYML))
                    fixsymbolic(node);
            } else if(!ISVALID(node)){
                /* this isn't a valid node, try cd'ing */
                if(changedir(node) == 0){
                    node->d->qid.type = QTDIR;
                    node->d->mode |= DMDIR;
                }else{
                    node->d->qid.type = QTFILE;
                    node->d->mode &= ~DMDIR;
                }
            }
            goto Found;
        }
        if(i == 0 && err == 0)
            err = "file does not exist";
    }

    /* clunk a newly cloned fid if the walk didn't succeed */
    if(nf != nil && (err != nil || rhdr.nwqid<nelems)){
        nf->busy = 0;
        nf->fid = 0;
    }

    /* if it all worked, point the fid to the enw node */
    if(err == nil)
        f->node = node;

    return err;
}
@

<<function [[ropen]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char *
ropen(Fid *f)
{
    int mode;

    mode = thdr.mode;
    if(f->node->d->qid.type & QTDIR)
        if(mode != OREAD)
            return "permission denied";

    if(mode & OTRUNC){
        uncache(f->node);
        uncache(f->node->parent);
        filedirty(f->node);
    } else {
        /* read the remote file or directory */
        if(!ISCACHED(f->node)){
            filefree(f->node);
            if(f->node->d->qid.type & QTDIR){
                invalidate(f->node);
                if(readdir(f->node) < 0)
                    return nosuchfile;
            } else {
                if(readfile(f->node) < 0)
                    return errstring;
            }
            CACHED(f->node);
        }
    }

    rhdr.qid = f->node->d->qid;
    f->open = 1;
    f->node->opens++;
    return 0;
}
@

<<function [[rcreate]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char*
rcreate(Fid *f)
{
    char *name;

    if((f->node->d->qid.type&QTDIR) == 0)
        return "not a directory";

    name = thdr.name;
    f->node = extendpath(f->node, s_copy(name));
    uncache(f->node);
    if(thdr.perm & DMDIR){
        if(createdir(f->node) < 0)
            return "permission denied";
    } else
        filedirty(f->node);
    invalidate(f->node->parent);
    uncache(f->node->parent);

    rhdr.qid = f->node->d->qid;
    f->open = 1;
    f->node->opens++;
    return 0;
}
@

<<function [[rread]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char*
rread(Fid *f)
{
    long off;
    int n, cnt, rv;
    Node *np;

    rhdr.count = 0;
    off = thdr.offset;
    cnt = thdr.count;
    if(cnt > messagesize-IOHDRSZ)
        cnt = messagesize-IOHDRSZ;

    if(f->node->d->qid.type & QTDIR){
        rv = 0;
        for(np = f->node->children; np != nil; np = np->sibs){
            if(!ISVALID(np))
                continue;
            if(off <= BIT16SZ)
                break;
            n = convD2M(np->d, mbuf, messagesize-IOHDRSZ);
            off -= n;
        }
        for(; rv < cnt && np != nil; np = np->sibs){
            if(!ISVALID(np))
                continue;
            if(np->d->mode & DMSYML)
                fixsymbolic(np);
            n = convD2M(np->d, mbuf + rv, cnt-rv);
            if(n <= BIT16SZ)
                break;
            rv += n;
        }
    } else {
        /* reread file if it's fallen out of the cache */
        if(!ISCACHED(f->node))
            if(readfile(f->node) < 0)
                return errstring;
        CACHED(f->node);
        rv = fileread(f->node, (char*)mbuf, off, cnt);
        if(rv < 0)
            return errstring;
    }

    rhdr.data = (char*)mbuf;
    rhdr.count = rv;
    return 0;
}
@

<<function [[rwrite]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char*
rwrite(Fid *f)
{
    long off;
    int cnt;

    if(f->node->d->qid.type & QTDIR)
        return "directories are not writable";

    rhdr.count = 0;
    off = thdr.offset;
    cnt = thdr.count;
    cnt = filewrite(f->node, thdr.data, off, cnt);
    if(cnt < 0)
        return errstring;
    filedirty(f->node);
    rhdr.count = cnt;
    return 0;
}
@

<<function [[rclunk]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char *
rclunk(Fid *f)
{
    if(fileisdirty(f->node)){
        if(createfile(f->node) < 0)
            fprint(2, "ftpfs: couldn't create %s\n", f->node->d->name);
        fileclean(f->node);
        uncache(f->node);
    }
    if(f->open){
        f->open = 0;
        f->node->opens--;
    }
    f->busy = 0;
    return 0;
}
@

<<function [[rremove]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
/*
 *  remove is an implicit clunk
 */
char *
rremove(Fid *f)
{
    char *e;
    e = nil;
    if(QTDIR & f->node->d->qid.type){
        if(removedir(f->node) < 0)
            e = errstring;
    } else {
        if(removefile(f->node) < 0)
            e = errstring;
    }
    uncache(f->node->parent);
    uncache(f->node);
    if(e == nil)
        INVALID(f->node);
    f->busy = 0;
    return e;
}
@

<<function [[rstat]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char *
rstat(Fid *f)
{
    Node *p;

    p = f->node->parent;
    if(!ISCACHED(p)){
        invalidate(p);
        readdir(p);
        CACHED(p);
    }
    if(!ISVALID(f->node))
        return nosuchfile;
    if(p->chdirunknown)
        fixsymbolic(f->node);
    rhdr.nstat = convD2M(f->node->d, mbuf, messagesize-IOHDRSZ);
    rhdr.stat = mbuf;
    return 0;
}
@

<<function [[rwstat]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
char *
rwstat(Fid *f)
{
    USED(f);
    return "wstat not implemented";
}
@

<<function [[fatal]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
/*
 *  print message and die
 */
void
fatal(char *fmt, ...)
{
    va_list arg;
    char buf[8*1024];

    dying = 1;

    va_start(arg, fmt);
    vseprint(buf, buf + (sizeof(buf)-1) / sizeof(*buf), fmt, arg);
    va_end(arg);

    fprint(2, "ftpfs: %s\n", buf);
    if(kapid > 0)
        postnote(PNGROUP, kapid, "die");
    exits(buf);
}
@

<<function [[safecpy]]>>=
/*
 *  like strncpy but make sure there's a terminating null
 */
void*
safecpy(void *to, void *from, int n)
{
    char *a = ((char*)to) + n - 1;

    strncpy(to, from, n);
    *a = 0;
    return to;
}
@

<<function [[seterr]]([[(networking/ip/ftpfs/ftpfs.c)]])>>=
/*
 *  set the error string
 */
int
seterr(char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    vsnprint(errstring, sizeof errstring, fmt, arg);
    va_end(arg);
    return -1;
}
@

<<function [[newnode]]>>=
/*
 *  create a new node
 */
Node*
newnode(Node *parent, String *name)
{
    Node *np;
    static ulong path;
    Dir d;

    np = mallocz(sizeof(Node), 1);
    if(np == 0)
        fatal("out of memory");

    np->children = 0;
    if(parent){
        np->parent = parent;
        np->sibs = parent->children;
        parent->children = np;
        np->depth = parent->depth + 1;
        d.dev = 0;		/* not stat'd */
    } else {
        /* the root node */
        np->parent = np;
        np->sibs = 0;
        np->depth = 0;
        d.dev = 1;
    }
    np->remname = name;
    d.name = s_to_c(name);
    d.atime = time(0);
    d.mtime = d.atime;
    d.uid = nouid;
    d.gid = nouid;
    d.muid = nouid;
    np->fp = 0;
    d.qid.path = ++path;
    d.qid.vers = 0;
    d.qid.type = QTFILE;
    d.type = 0;
    np->d = reallocdir(&d, 0);

    return np;
}
@

<<function [[extendpath]]>>=
/*
 *  walk one down the local mirror of the remote directory tree
 */
Node*
extendpath(Node *parent, String *elem)
{
    Node *np;

    for(np = parent->children; np; np = np->sibs)
        if(strcmp(s_to_c(np->remname), s_to_c(elem)) == 0){
            s_free(elem);
            return np;
        }

    return newnode(parent, elem);
}
@

<<function [[uncache]]>>=
/*
 *  flush the cached file, write it back if it's dirty
 */
void
uncache(Node *np)
{
    if(fileisdirty(np))
        createfile(np);
    filefree(np);
    UNCACHED(np);
}
@

<<function [[invalidate]]>>=
/*
 *  invalidate all children of a node
 */
void
invalidate(Node *node)
{
    Node *np;

    if(node->opens)
        return;		/* don't invalidate something that's open */

    uncachedir(node, 0);

    /* invalidate children */
    for(np = node->children; np; np = np->sibs){
        if(np->opens)
            continue;	/* don't invalidate something that's open */
        UNCACHED(np);
        invalidate(np);
        np->d->dev = 0;
    }
}
@

<<function [[newtopsdir]]>>=
/*
 *  make a top level tops-20 directory.  They are automaticly valid.
 */
Node*
newtopsdir(char *name)
{
    Node *np;

    np = extendpath(remroot, s_copy(name));
    if(!ISVALID(np)){
        np->d->qid.type = QTDIR;
        np->d->atime = time(0);
        np->d->mtime = np->d->atime;
        np->d->uid = "?uid?";
        np->d->gid = "?uid?";
        np->d->muid = "?uid?";
        np->d->mode = DMDIR|0777;
        np->d->length = 0;
        np->d = reallocdir(np->d, 1);
        
        if(changedir(np) >= 0)
            VALID(np);
    }
    return np;
}
@

<<function [[fixsymbolic]]>>=
/*
 *  figure out if a symbolic link is to a directory or a file
 */
void
fixsymbolic(Node *node)
{
    if(changedir(node) == 0){
        node->d->mode |= DMDIR;
        node->d->qid.type = QTDIR;
    } else
        node->d->qid.type = QTFILE;
    node->d->mode &= ~DMSYML; 
}
@


%-------------------------------------------------------------

<<networking/ip/ftpfs/ftpfs.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <fcall.h>
#include <string.h>
#include "ftpfs.h"

/* an active fid */
typedef struct Fid	Fid;
<<struct [[Fid]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<global [[fids]]([[(networking/ip/ftpfs/ftpfs.c)]])>>
<<global [[errstring]]>>
<<global [[mfd]]([[(networking/ip/ftpfs/ftpfs.c)]])>>
<<global [[messagesize]]([[(networking/ip/ftpfs/ftpfs.c)]])>>
<<global [[mdata]]>>
<<global [[mbuf]]>>
<<global [[rhdr]]>>
<<global [[thdr]]>>
<<global [[debug]]([[(networking/ip/ftpfs/ftpfs.c)]])>>
<<global [[usenlst]]>>
<<global [[usetls]]>>
<<global [[ext]]>>
<<global [[quiet]]([[(networking/ip/ftpfs/ftpfs.c)]])>>
<<global [[kapid]]>>
<<global [[dying]]>>
<<global [[dokeepalive]]>>

char	*rflush(Fid*), *rnop(Fid*), *rversion(Fid*),
    *rattach(Fid*), *rclone(Fid*), *rwalk(Fid*),
    *rclwalk(Fid*), *ropen(Fid*), *rcreate(Fid*),
    *rread(Fid*), *rwrite(Fid*), *rclunk(Fid*),
    *rremove(Fid*), *rstat(Fid*), *rwstat(Fid*),
    *rauth(Fid*);;
void	mountinit(char*);
void	io(void);
int	readpdir(Node*);

<<global [[fcalls]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<global [[oslist]]>>

<<global [[nouid]]>>

<<macro [[S2P]]>>

<<global [[nosuchfile]]>>
<<global [[keyspec]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[usage]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[main]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[newfid]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[kaproc]]>>

<<function [[io]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rnop]]>>

<<function [[rversion]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rflush]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rauth]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rattach]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rwalk]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[ropen]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rcreate]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rread]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rwrite]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rclunk]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rremove]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rstat]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[rwstat]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[fatal]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[safecpy]]>>

<<function [[seterr]]([[(networking/ip/ftpfs/ftpfs.c)]])>>

<<function [[newnode]]>>

<<function [[extendpath]]>>

<<function [[uncache]]>>

<<function [[invalidate]]>>

<<function [[newtopsdir]]>>

<<function [[fixsymbolic]]>>
@


\subsection*{[[networking/ip/ftpfs/ftpfs.h]]}

<<enum [[_anon_ (networking/ip/ftpfs/ftpfs.h)]]>>=
enum
{
    Maxpath=	512,
};
@

<<struct [[Node]]>>=
/* a tree for file path's - this mirrors the directory structure */
struct Node
{
    String	*remname;
    Dir	*d;
    Node	*parent;
    Node	*sibs;
    Node	*children;
    File	*fp;
    short	depth;
    char	chdirunknown;	/* true if QTDIR bit of files in this dir is unknown */
    int	opens;
};
@

<<enum [[_anon_ (networking/ip/ftpfs/ftpfs.h)2]]>>=
/* OS types */
enum
{
    Unix=		1,
    Tops=		2,
    Plan9=		3,
    VM=		4,
    VMS=		5,
    MVS=		6,
    NetWare=	7,
//	OS½=		8,
    TSO=		9,
    NT=		10,
    Unknown=	11,
};
@

<<struct [[OS]]>>=
struct OS
{
    int	os;
    char	*name;
};
@

<<macro [[ISCACHED]]>>=
#define ISCACHED(x) ((x)->d->type)
@

<<macro [[UNCACHED]]>>=
#define UNCACHED(x) (x)->d->type = 0
@

<<macro [[CACHED]]>>=
#define CACHED(x) { (x)->d->type = 1; (x)->d->atime = time(0); }
@

<<macro [[ISOLD]]>>=
#define ISOLD(x) (x)->d->atime + TIMEOUT < time(0)
@

<<macro [[ISVALID]]>>=
#define ISVALID(x) ((x)->d->dev)
@

<<macro [[INVALID]]>>=
#define INVALID(x) (x)->d->dev = 0
@

<<macro [[VALID]]>>=
#define VALID(x) (x)->d->dev = 1
@

<<constant [[TIMEOUT]]>>=
#define TIMEOUT 5*60
@

<<constant [[DMSYML]]>>=
#define DMSYML 0x10000000
@

<<constant [[MAXFDATA]]>>=
#define MAXFDATA 8192
@


%-------------------------------------------------------------

<<networking/ip/ftpfs/ftpfs.h>>=
typedef struct File	File;
typedef struct Node	Node;
typedef struct OS	OS;

#pragma incomplete File

<<enum [[_anon_ (networking/ip/ftpfs/ftpfs.h)]]>>

<<struct [[Node]]>>

<<enum [[_anon_ (networking/ip/ftpfs/ftpfs.h)2]]>>

<<struct [[OS]]>>
extern OS oslist[];

/* temporary files */
void	filefree(Node*);
int	fileread(Node*, char*, long, int);
int	filewrite(Node*, char*, long, int);
void	filedirty(Node*);
void	fileclean(Node*);
int	fileisdirty(Node*);

/* ftp protocol */
void	hello(char*);
void	quit(void);
void	preamble(char*);
void	rlogin(char *, char *);
void	clogin(char *, char *);
void	nop(void);
int	readdir(Node*);
int	createdir(Node*);
int	readfile(Node*);
int	createfile(Node*);
int	changedir(Node*);
int	removefile(Node*);
int	removedir(Node*);

/* misc */
void*	safecpy(void*, void*, int);
void	fatal(char*, ...);
int	seterr(char*, ...);
Node*	extendpath(Node*, String*);
Node*	newnode(Node*, String*);
void	uncache(Node*);
void	invalidate(Node*);
void	uncachedir(Node*, Node*);
Node*	newtopsdir(char*);
void	fixsymbolic(Node*);
Dir*	reallocdir(Dir *d, int dofree);
Dir*	dir_change_name(Dir *d, char *name);
Dir*	dir_change_uid(Dir *d, char *name);
Dir*	dir_change_gid(Dir *d, char *name);
Dir*	dir_change_muid(Dir *d, char *name);

extern Node *remdir;	/* current directory on remote side */
extern Node *remroot;	/* root on remote side */
extern int os;		/* remote os */
extern int debug;	/* non-zero triggers debugging output */
extern int usenlst;
extern char *nosuchfile;
extern char *ext;	/* add to names of non-dir files */
extern int defos;
extern int quiet;
extern char *user;

<<macro [[ISCACHED]]>>
<<macro [[UNCACHED]]>>
<<macro [[CACHED]]>>
<<macro [[ISOLD]]>>
<<macro [[ISVALID]]>>
<<macro [[INVALID]]>>
<<macro [[VALID]]>>
<<constant [[TIMEOUT]]>>
<<constant [[DMSYML]]>>

<<constant [[MAXFDATA]]>>

extern char	net[];		/* network for connections */
@


\subsection*{[[networking/ip/ftpfs/proto.c]]}

<<enum [[_anon_ (networking/ip/ftpfs/proto.c)]]>>=
enum
{
    /* return codes */
    Extra=		1,
    Success=	2,
    Incomplete=	3,
    TempFail=	4,
    PermFail=	5,
    Impossible=	6,
};
@

<<global [[remdir]]>>=
Node	*remdir;		/* current directory on remote machine */
@

<<global [[remroot]]>>=
Node	*remroot;		/* root directory on remote machine */
@

<<global [[ctlfd]]>>=
int	ctlfd;			/* fd for control connection */
@

<<global [[ctlin]]>>=
Biobuf	ctlin;			/* input buffer for control connection */
@

<<global [[stdin]]>>=
Biobuf	stdin;			/* input buffer for standard input */
@

<<global [[dbuf]]>>=
Biobuf	dbuf;			/* buffer for data connection */
@

<<global [[msg]]>>=
char	msg[512];		/* buffer for replies */
@

<<global [[net]]([[(networking/ip/ftpfs/proto.c)]])>>=
char	net[Maxpath];		/* network for connections */
@

<<global [[listenfd]]>>=
int	listenfd;		/* fd to listen on for connections */
@

<<global [[netdir]]([[(networking/ip/ftpfs/proto.c)]])>>=
char	netdir[Maxpath];
@

<<global [[topsdir]]>>=
char	topsdir[64];		/* name of listed directory for TOPS */
@

<<global [[remrootpath]]>>=
String	*remrootpath;	/* path on remote side to remote root */
@

<<global [[user]]([[(networking/ip/ftpfs/proto.c)]])>>=
char	*user;
@

<<global [[nopassive]]>>=
int	nopassive;
@

<<global [[lastsend]]>>=
long	lastsend;
@

<<function [[hello]]>>=
/*
 *  connect to remote server, default network is "tcp/ip"
 */
void
hello(char *dest)
{
    char *p;
    char dir[Maxpath];
    TLSconn conn;

    Binit(&stdin, 0, OREAD);	/* init for later use */

    ctlfd = dial(netmkaddr(dest, "tcp", "ftp"), 0, dir, 0);
    if(ctlfd < 0){
        fprint(2, "can't dial %s: %r\n", dest);
        exits("dialing");
    }
        
    Binit(&ctlin, ctlfd, OREAD);

    /* remember network for the data connections */
    p = strrchr(dir+1, '/');
    if(p == 0)
        fatal("wrong dial(2) linked with ftp");
    *p = 0;
    safecpy(net, dir, sizeof(net));

    /* wait for hello from other side */
    if(getreply(&ctlin, msg, sizeof(msg), 1) != Success)
        fatal("bad hello");
    if(strstr(msg, "Plan 9"))
        os = Plan9;

    if(usetls){
        sendrequest("AUTH", "TLS");
        if(getreply(&ctlin, msg, sizeof(msg), 1) != Success)
            fatal("bad auth tls");

        ctlfd = tlsClient(ctlfd, &conn);
        if(ctlfd < 0)
            fatal("starting tls: %r");
        free(conn.cert);

        Binit(&ctlin, ctlfd, OREAD);

        sendrequest("PBSZ", "0");
        if(getreply(&ctlin, msg, sizeof(msg), 1) != Success)
            fatal("bad pbsz 0");
        sendrequest("PROT", "P");
        if(getreply(&ctlin, msg, sizeof(msg), 1) != Success)
            fatal("bad prot p");
    }
}
@

<<function [[rlogin]]([[(networking/ip/ftpfs/proto.c)]])>>=
/*
 *  login to remote system
 */
void
rlogin(char *rsys, char *keyspec)
{
    char *line;
    char pass[128];
    UserPasswd *up;

    up = nil;
    for(;;){
        if(up == nil && os != Plan9)
            up = auth_getuserpasswd(auth_getkey, "proto=pass server=%s service=ftp %s", rsys, keyspec);
        if(up != nil){
            sendrequest("USER", up->user);
        } else {
            print("User[default = %s]: ", user);
            line = Brdline(&stdin, '\n');
            if(line == 0)
                exits(0);
            line[Blinelen(&stdin)-1] = 0;
            if(*line){
                free(user);
                user = strdup(line);
            }
            sendrequest("USER", user);
        }
        switch(getreply(&ctlin, msg, sizeof(msg), 1)){
        case Success:
            goto out;
        case Incomplete:
            break;
        case TempFail:
        case PermFail:
            continue;
        }

        if(up != nil){
            sendrequest("PASS", up->passwd);
        } else {
            if(getpassword(pass, pass+sizeof(pass)) < 0)
                exits(0);
            sendrequest("PASS", pass);
        }
        if(getreply(&ctlin, msg, sizeof(msg), 1) == Success){
            if(strstr(msg, "Sess#"))
                defos = MVS;
            break;
        }
    }
out:
    if(up != nil){
        memset(up, 0, sizeof(*up));
        free(up);
    }
}
@

<<function [[clogin]]>>=
/*
 *  login to remote system with given user name and password.
 */
void
clogin(char *cuser, char *cpassword)
{
    free(user);
    user = strdup(cuser);
    if (strcmp(user, "anonymous") != 0 &&
        strcmp(user, "ftp") != 0)
        fatal("User must be 'anonymous' or 'ftp'");
    sendrequest("USER", user);
    switch(getreply(&ctlin, msg, sizeof(msg), 1)){
    case Success:
        return;
    case Incomplete:
        break;
    case TempFail:
    case PermFail:
        fatal("login failed");
    }
    if (cpassword == 0)
        fatal("password needed");
    sendrequest("PASS", cpassword);
    if(getreply(&ctlin, msg, sizeof(msg), 1) != Success)
        fatal("password failed");
    if(strstr(msg, "Sess#"))
        defos = MVS;
    return;
}
@

<<function [[preamble]]>>=
/*
 *  find out about the other side.  go to it's root if requested.  set
 *  image mode if a Plan9 system.
 */
void
preamble(char *mountroot)
{
    char *p, *ep;
    int rv;
    OS *o;

    /*
     *  create a root directory mirror
     */
    remroot = newnode(0, s_copy("/"));
    remroot->d->qid.type = QTDIR;
    remroot->d->mode = DMDIR|0777;
    remdir = remroot;

    /*
     *  get system type
     */
    sendrequest("SYST", nil);
    switch(getreply(&ctlin, msg, sizeof(msg), 1)){
    case Success:
        for(o = oslist; o->os != Unknown; o++)
            if(strncmp(msg+4, o->name, strlen(o->name)) == 0)
                break;
        os = o->os;
        if(os == NT)
            os = Unix;
        break;
    default:
        os = defos;
        break;
    }
    if(os == Unknown)
        os = defos;

    remrootpath = s_reset(remrootpath);
    switch(os){
    case NetWare:
              /*
               * Request long, rather than 8.3 filenames,
               * where the Servers & Volume support them.
               */
              sendrequest("SITE LONG", nil);
              getreply(&ctlin, msg, sizeof(msg), 0);
              /* FALL THRU */
    case Unix:
    case Plan9:
        /*
         *  go to the remote root, if asked
         */
        if(mountroot){
            sendrequest("CWD", mountroot);
            getreply(&ctlin, msg, sizeof(msg), 0);
        } else {
            s_append(remrootpath, "/usr/");
            s_append(remrootpath, user);
        }

        /*
         *  get the root directory
         */
        sendrequest("PWD", nil);
        rv = getreply(&ctlin, msg, sizeof(msg), 1);
        if(rv == PermFail){
            sendrequest("XPWD", nil);
            rv = getreply(&ctlin, msg, sizeof(msg), 1);
        }
        if(rv == Success){
            p = strchr(msg, '"');
            if(p){
                p++;
                ep = strchr(p, '"');
                if(ep){
                    *ep = 0;
                    s_append(s_reset(remrootpath), p);
                }
            }
        }

        break;
    case Tops:
    case VM:
        /*
         *  top directory is a figment of our imagination.
         *  make it permanently cached & valid.
         */
        CACHED(remroot);
        VALID(remroot);
        remroot->d->atime = time(0) + 100000;

        /*
         *  no initial directory.  We are in the
         *  imaginary root.
         */
        remdir = newtopsdir("???");
        topsdir[0] = 0;
        if(os == Tops && readdir(remdir) >= 0){
            CACHED(remdir);
            if(*topsdir)
                remdir->remname = s_copy(topsdir);
            VALID(remdir);
        }
        break;
    case VMS:
        /*
         *  top directory is a figment of our imagination.
         *  make it permanently cached & valid.
         */
        CACHED(remroot);
        VALID(remroot);
        remroot->d->atime = time(0) + 100000;

        /*
         *  get current directory
         */
        sendrequest("PWD", nil);
        rv = getreply(&ctlin, msg, sizeof(msg), 1);
        if(rv == PermFail){
            sendrequest("XPWD", nil);
            rv = getreply(&ctlin, msg, sizeof(msg), 1);
        }
        if(rv == Success){
            p = strchr(msg, '"');
            if(p){
                p++;
                ep = strchr(p, '"');
                if(ep){
                    *ep = 0;
                    remroot = remdir = vmsdir(p);
                }
            }
        }
        break;
    case MVS:
        usenlst = 1;
        break;
    }

    if(os == Plan9)
        image();
}
@

<<function [[ascii]]>>=
static void
ascii(void)
{
    sendrequest("TYPE A", nil);
    switch(getreply(&ctlin, msg, sizeof(msg), 0)){
    case Success:
        break;
    default:
        fatal("can't set type to ascii");
    }
}
@

<<function [[image]]>>=
static void
image(void)
{
    sendrequest("TYPE I", nil);
    switch(getreply(&ctlin, msg, sizeof(msg), 0)){
    case Success:
        break;
    default:
        fatal("can't set type to image/binary");
    }
}
@

<<global [[monthchars]]>>=
/*
 *  decode the time fields, return seconds since epoch began
 */
char *monthchars = "janfebmaraprmayjunjulaugsepoctnovdec";
@

<<global [[now]]([[(networking/ip/ftpfs/proto.c)]])>>=
static Tm now;
@

<<function [[cracktime]]>>=
static ulong
cracktime(char *month, char *day, char *yr, char *hms)
{
    Tm tm;
    int i;
    char *p;


    /* default time */
    if(now.year == 0)
        now = *localtime(time(0));
    tm = now;
    tm.yday = 0;

    /* convert ascii month to a number twixt 1 and 12 */
    if(*month >= '0' && *month <= '9'){
        tm.mon = atoi(month) - 1;
        if(tm.mon < 0 || tm.mon > 11)
            tm.mon = 5;
    } else {
        for(p = month; *p; p++)
            *p = tolower(*p);
        for(i = 0; i < 12; i++)
            if(strncmp(&monthchars[i*3], month, 3) == 0){
                tm.mon = i;
                break;
            }
    }

    tm.mday = atoi(day);

    if(hms){
        tm.hour = strtol(hms, &p, 0);
        if(*p == ':'){
            tm.min = strtol(p+1, &p, 0);
            if(*p == ':')
                tm.sec = strtol(p+1, &p, 0);
        }
        if(tolower(*p) == 'p')
            tm.hour += 12;
    }

    if(yr){
        tm.year = atoi(yr);
        if(tm.year >= 1900)
            tm.year -= 1900;
    } else {
        if(tm.mon > now.mon || (tm.mon == now.mon && tm.mday > now.mday+1))
            tm.year--;
    }

    /* convert to epoch seconds */
    return tm2sec(&tm);
}
@

<<function [[crackmode]]>>=
/*
 *  decode a Unix or Plan 9 file mode
 */
static ulong
crackmode(char *p)
{
    ulong flags;
    ulong mode;
    int i;

    flags = 0;
    switch(strlen(p)){
    case 10:	/* unix and new style plan 9 */
        switch(*p){
        case 'l':
            return DMSYML|0777;
        case 'd':
            flags |= DMDIR;
        case 'a':
            flags |= DMAPPEND;
        }
        p++;
        if(p[2] == 'l')
            flags |= DMEXCL;
        break;
    case 11:	/* old style plan 9 */
        switch(*p++){
        case 'd':
            flags |= DMDIR;
            break;
        case 'a':
            flags |= DMAPPEND;
            break;
        }
        if(*p++ == 'l')
            flags |= DMEXCL;
        break;
    default:
        return DMDIR|0777;
    }
    mode = 0;
    for(i = 0; i < 3; i++){
        mode <<= 3;
        if(*p++ == 'r')
            mode |= DMREAD;
        if(*p++ == 'w')
            mode |= DMWRITE;
        if(*p == 'x' || *p == 's' || *p == 'S')
            mode |= DMEXEC;
        p++;
    }
    return mode | flags;
}
@

<<function [[strpunct]]>>=
/*
 *  find first punctuation
 */
char*
strpunct(char *p)
{
    int c;

    for(;c = *p; p++){
        if(ispunct(c))
            return p;
    }
    return 0;
}
@

<<function [[crackdir]]>>=
/*
 *  decode a Unix or Plan 9 directory listing
 */
static Dir*
crackdir(char *p, String **remname)
{
    char *field[15];
    char *dfield[4];
    char *cp;
    String *s;
    int dn, n;
    Dir d, *dp;

    memset(&d, 0, sizeof(d));

    n = getfields(p, field, 15, 1, " \t");
    if(n > 2 && strcmp(field[n-2], "->") == 0)
        n -= 2;
    switch(os){
    case TSO:
        cp = strchr(field[0], '.');
        if(cp){
            *cp++ = 0;
            s = s_copy(cp);
            d.uid = field[0];
        } else {
            s = s_copy(field[0]);
            d.uid = "TSO";
        }
        d.gid = "TSO";
        d.mode = 0666;
        d.length = 0;
        d.atime = 0;
        break;
//	case OS½:
//		s = s_copy(field[n-1]);
//		d.uid = "OS½";
//		d.gid = d.uid;
//		d.mode = 0666;
//		switch(n){
//		case 5:
//			if(strcmp(field[1], "DIR") == 0)
//				d.mode |= DMDIR;
//			d.length = atoll(field[0]);
//			dn = getfields(field[2], dfield, 4, 1, "-");
//			if(dn == 3)
//				d.atime = cracktime(dfield[0], dfield[1], dfield[2], field[3]);
//			break;
//		}
//		break;
    case Tops:
        if(n != 4){ /* tops directory name */
            safecpy(topsdir, field[0], sizeof(topsdir));
            return 0;
        }
        s = s_copy(field[3]);
        d.length = atoll(field[0]);
        d.mode = 0666;
        d.uid = "Tops";
        d.gid = d.uid;
        dn = getfields(field[1], dfield, 4, 1, "-");
        if(dn == 3)
            d.atime = cracktime(dfield[1], dfield[0], dfield[2], field[2]);
        else
            d.atime = time(0);
        break;
    case VM:
        switch(n){
        case 9:
            s = s_copy(field[0]);
            s_append(s, ".");
            s_append(s, field[1]);
            d.length = atoll(field[3]) * atoll(field[4]);
            if(*field[2] == 'F')
                d.mode = 0666;
            else
                d.mode = 0777;
            d.uid = "VM";
            d.gid = d.uid;
            dn = getfields(field[6], dfield, 4, 1, "/-");
            if(dn == 3)
                d.atime = cracktime(dfield[0], dfield[1], dfield[2], field[7]);
            else
                d.atime = time(0);
            break;
        case 1:
            s = s_copy(field[0]);
            d.uid = "VM";
            d.gid = d.uid;
            d.mode = 0777;
            d.atime = 0;
            break;
        default:
            return nil;
        }
        break;
    case VMS:
        switch(n){
        case 6:
            for(cp = field[0]; *cp; cp++)
                *cp = tolower(*cp);
            cp = strchr(field[0], ';');
            if(cp)
                *cp = 0;
            d.mode = 0666;
            cp = field[0] + strlen(field[0]) - 4;
            if(strcmp(cp, ".dir") == 0){
                d.mode |= DMDIR;
                *cp = 0;
            }
            s = s_copy(field[0]);
            d.length = atoll(field[1]) * 512;
            field[4][strlen(field[4])-1] = 0;
            d.uid = field[4]+1;
            d.gid = d.uid;
            dn = getfields(field[2], dfield, 4, 1, "/-");
            if(dn == 3)
                d.atime = cracktime(dfield[1], dfield[0], dfield[2], field[3]);
            else
                d.atime = time(0);
            break;
        default:
            return nil;
        }
        break;
    case NetWare:
        switch(n){
        case 8:		/* New style */
            s = s_copy(field[7]);
            d.uid = field[2];
            d.gid = d.uid;
            d.mode = nw_mode(field[0][0], field[1]);
            d.length = atoll(field[3]);
            if(strchr(field[6], ':'))
                d.atime = cracktime(field[4], field[5], nil, field[6]);
            else
                d.atime = cracktime(field[4], field[5], field[6], nil);
            break;
        case 9:
            s = s_copy(field[8]);
            d.uid = field[2];
            d.gid = d.uid;
            d.mode = 0666;
            if(*field[0] == 'd')
                d.mode |= DMDIR;
            d.length = atoll(field[3]);
            d.atime = cracktime(field[4], field[5], field[6], field[7]);
            break;
        case 1:
            s = s_copy(field[0]);
            d.uid = "none";
            d.gid = d.uid;
            d.mode = 0777;
            d.atime = 0;
            break;
        default:
            return nil;
        }
        break;
    case Unix:
    case Plan9:
    default:
        switch(n){
        case 8:		/* ls -l */
            s = s_copy(field[7]);
            d.uid = field[2];
            d.gid = d.uid;
            d.mode = crackmode(field[0]);
            d.length = atoll(field[3]);
            if(strchr(field[6], ':'))
                d.atime = cracktime(field[4], field[5], 0, field[6]);
            else
                d.atime = cracktime(field[4], field[5], field[6], 0);
            break;
        case 9:		/* ls -lg */
            s = s_copy(field[8]);
            d.uid = field[2];
            d.gid = field[3];
            d.mode = crackmode(field[0]);
            d.length = atoll(field[4]);
            if(strchr(field[7], ':'))
                d.atime = cracktime(field[5], field[6], 0, field[7]);
            else
                d.atime = cracktime(field[5], field[6], field[7], 0);
            break;
        case 10:	/* plan 9 */
            s = s_copy(field[9]);
            d.uid = field[3];
            d.gid = field[4];
            d.mode = crackmode(field[0]);
            d.length = atoll(field[5]);
            if(strchr(field[8], ':'))
                d.atime = cracktime(field[6], field[7], 0, field[8]);
            else
                d.atime = cracktime(field[6], field[7], field[8], 0);
            break;
        case 4:		/* a Windows_NT version */
            s = s_copy(field[3]);
            d.uid = "NT";
            d.gid = d.uid;
            if(strcmp("<DIR>", field[2]) == 0){
                d.length = 0;
                d.mode = DMDIR|0777;
            } else {
                d.mode = 0666;
                d.length = atoll(field[2]);
            }
            dn = getfields(field[0], dfield, 4, 1, "/-");
            if(dn == 3)
                d.atime = cracktime(dfield[0], dfield[1], dfield[2], field[1]);
            break;
        case 1:
            s = s_copy(field[0]);
            d.uid = "none";
            d.gid = d.uid;
            d.mode = 0777;
            d.atime = 0;
            break;
        default:
            return nil;
        }
    }
    d.muid = d.uid;
    d.qid.type = (d.mode & DMDIR) ? QTDIR : QTFILE;
    d.mtime = d.atime;
    if(ext && (d.qid.type & QTDIR) == 0)
        s_append(s, ext);
    d.name = s_to_c(s);

    /* allocate a freeable dir structure */
    dp = reallocdir(&d, 0);
    *remname = s;

    return dp;
}
@

<<function [[readdir]]>>=
/*
 *  read a remote directory
 */
int
readdir(Node *node)
{
    Biobuf *bp;
    char *line;
    Node *np;
    Dir *d;
    long n;
    int tries, x, files;
    static int uselist;
    int usenlist;
    String *remname;

    if(changedir(node) < 0)
        return -1;

    usenlist = 0;
    for(tries = 0; tries < 3; tries++){
        if(usenlist || usenlst)
            x = data(OREAD, &bp, "NLST", nil);
        else if(os == Unix && !uselist)
            x = data(OREAD, &bp, "LIST -l", nil);
        else
            x = data(OREAD, &bp, "LIST", nil);
        switch(x){
        case Extra:
            break;
/*		case TempFail:
            continue;
*/
        default:
            if(os == Unix && uselist == 0){
                uselist = 1;
                continue;
            }
            return seterr(nosuchfile);
        }
        files = 0;
        while(line = Brdline(bp, '\n')){
            n = Blinelen(bp);
            if(debug)
                write(2, line, n);
            if(n > 1 && line[n-2] == '\r')
                n--;
            line[n - 1] = 0;

            d = crackdir(line, &remname);
            if(d == nil)
                continue;
            files++;
            np = extendpath(node, remname);
            d->qid.path = np->d->qid.path;
            d->qid.vers = np->d->qid.vers;
            d->type = np->d->type;
            d->dev = 1;			/* mark node as valid */
            if(os == MVS && node == remroot){
                d->qid.type = QTDIR;
                d->mode |= DMDIR;
            }
            free(np->d);
            np->d = d;
        }
        close(Bfildes(bp));

        switch(getreply(&ctlin, msg, sizeof(msg), 0)){
        case Success:
            if(files == 0 && !usenlst && !usenlist){
                usenlist = 1;
                continue;
            }
            if(files && usenlist)
                usenlst = 1;
            if(usenlst)
                node->chdirunknown = 1;
            return 0;
        case TempFail:
            break;
        default:
            return seterr(nosuchfile);
        }
    }
    return seterr(nosuchfile);
}
@

<<function [[createdir]]>>=
/*
 *  create a remote directory
 */
int
createdir(Node *node)
{
    if(changedir(node->parent) < 0)
        return -1;
    
    sendrequest("MKD", node->d->name);
    if(getreply(&ctlin, msg, sizeof(msg), 0) != Success)
        return -1;
    return 0;
}
@

<<function [[changedir]]>>=
/*
 *  change to a remote directory.
 */
int
changedir(Node *node)
{
    Node *to;
    String *cdpath;

    to = node;
    if(to == remdir)
        return 0;

    /* build an absolute path */
    switch(os){
    case Tops:
    case VM:
        switch(node->depth){
        case 0:
            remdir = node;
            return 0;
        case 1:
            cdpath = s_clone(node->remname);
            break;
        default:
            return seterr(nosuchfile);
        }
        break;
    case VMS:
        switch(node->depth){
        case 0:
            remdir = node;
            return 0;
        default:
            cdpath = s_new();
            vmspath(node, cdpath);
        }
        break;
    case MVS:
        if(node->depth == 0)
            cdpath = s_clone(remrootpath);
        else{
            cdpath = s_new();
            mvspath(node, cdpath);
        }
        break;
    default:
        if(node->depth == 0)
            cdpath = s_clone(remrootpath);
        else{
            cdpath = s_new();
            unixpath(node, cdpath);
        }
        break;
    }

    uncachedir(remdir, 0);

    /*
     *  connect, if we need a password (Incomplete)
     *  act like it worked (best we can do).
     */
    sendrequest("CWD", s_to_c(cdpath));
    s_free(cdpath);
    switch(getreply(&ctlin, msg, sizeof(msg), 0)){
    case Success:
    case Incomplete:
        remdir = node;
        return 0;
    default:
        return seterr(nosuchfile);
    }
}
@

<<function [[readfile1]]>>=
/*
 *  read a remote file
 */
int
readfile1(Node *node)
{
    Biobuf *bp;
    char buf[4*1024];
    long off;
    int n;
    int tries;

    if(changedir(node->parent) < 0)
        return -1;

    for(tries = 0; tries < 4; tries++){
        switch(data(OREAD, &bp, "RETR", s_to_c(node->remname))){
        case Extra:
            break;
        case TempFail:
            continue;
        default:
            return seterr(nosuchfile);
        }
        off = 0;
        while((n = read(Bfildes(bp), buf, sizeof buf)) > 0){
            if(filewrite(node, buf, off, n) != n){
                off = -1;
                break;
            }
            off += n;
        }
        if(off < 0)
            return -1;

        /* make sure a file gets created even for a zero length file */
        if(off == 0)
            filewrite(node, buf, 0, 0);

        close(Bfildes(bp));
        switch(getreply(&ctlin, msg, sizeof(msg), 0)){
        case Success:
            return off;
        case TempFail:
            continue;
        default:
            return seterr(nosuchfile);
        }
    }
    return seterr(nosuchfile);
}
@

<<function [[readfile]]>>=
int
readfile(Node *node)
{
    int rv, inimage;

    switch(os){
    case MVS:
    case Plan9:
    case Tops:
    case TSO:
        inimage = 0;
        break;
    default:
        inimage = 1;
        image();
        break;
    }

    rv = readfile1(node);

    if(inimage)
        ascii();
    return rv;
}
@

<<function [[createfile1]]>>=
/*
 *  write back a file
 */
int
createfile1(Node *node)
{
    Biobuf *bp;
    char buf[4*1024];
    long off;
    int n;

    if(changedir(node->parent) < 0)
        return -1;

    if(data(OWRITE, &bp, "STOR", s_to_c(node->remname)) != Extra)
        return -1;
    for(off = 0; ; off += n){
        n = fileread(node, buf, off, sizeof(buf));
        if(n <= 0)
            break;
        write(Bfildes(bp), buf, n);
    }
    close(Bfildes(bp));
    if(getreply(&ctlin, msg, sizeof(msg), 0) != Success)
        return -1;
    return off;
}
@

<<function [[createfile]]>>=
int
createfile(Node *node)
{
    int rv;

    switch(os){
    case Plan9:
    case Tops:
        break;
    default:
        image();
        break;
    }
    rv = createfile1(node);
    switch(os){
    case Plan9:
    case Tops:
        break;
    default:
        ascii();
        break;
    }
    return rv;
}
@

<<function [[removefile]]>>=
/*
 *  remove a remote file
 */
int
removefile(Node *node)
{
    if(changedir(node->parent) < 0)
        return -1;
    
    sendrequest("DELE", s_to_c(node->remname));
    if(getreply(&ctlin, msg, sizeof(msg), 0) != Success)
        return -1;
    return 0;
}
@

<<function [[removedir]]>>=
/*
 *  remove a remote directory
 */
int
removedir(Node *node)
{
    if(changedir(node->parent) < 0)
        return -1;
    
    sendrequest("RMD", s_to_c(node->remname));
    if(getreply(&ctlin, msg, sizeof(msg), 0) != Success)
        return -1;
    return 0;
}
@

<<function [[quit]]>>=
/*
 *  tell remote that we're exiting and then do it
 */
void
quit(void)
{
    sendrequest("QUIT", nil);
    getreply(&ctlin, msg, sizeof(msg), 0);
    exits(0);
}
@

<<function [[sendrequest]]>>=
/*
 *  send a request
 */
static void
sendrequest(char *a, char *b)
{
    char buf[2*1024];
    int n;

    n = strlen(a)+2+1;
    if(b != nil)
        n += strlen(b)+1;
    if(n >= sizeof(buf))
        fatal("proto request too long");
    strcpy(buf, a);
    if(b != nil){
        strcat(buf, " ");
        strcat(buf, b);
    }
    strcat(buf, "\r\n");
    n = strlen(buf);
    if(write(ctlfd, buf, n) != n)
        fatal("remote side hung up");
    if(debug)
        write(2, buf, n);
    lastsend = time(0);
}
@

<<function [[getreply]]>>=
/*
 *  replies codes are in the range [100, 999] and may contain multiple lines of
 *  continuation.
 */
static int
getreply(Biobuf *bp, char *msg, int len, int printreply)
{
    char *line;
    char *p;
    int rv;
    int i, n;

    while(line = Brdline(bp, '\n')){
        /* add line to message buffer, strip off \r */
        n = Blinelen(bp);
        if(n > 1 && line[n-2] == '\r'){
            n--;
            line[n-1] = '\n';
        }
        if(printreply && !quiet)
            write(1, line, n);
        else if(debug)
            write(2, line, n);
        if(n > len - 1)
            i = len - 1;
        else
            i = n;
        if(i > 0){
            memmove(msg, line, i);
            msg += i;
            len -= i;
            *msg = 0;
        }

        /* stop if not a continuation */
        rv = strtol(line, &p, 10);
        if(rv >= 100 && rv < 600 && p==line+3 && *p != '-')
            return rv/100;

        /* tell user about continuations */
        if(!debug && !quiet && !printreply)
            write(2, line, n);
    }

    fatal("remote side closed connection");
    return 0;
}
@

<<function [[port]]>>=
/*
 *  Announce on a local port and tell its address to the the remote side
 */
static int
port(void)
{
    char buf[256];
    int n, fd;
    char *ptr;
    uchar ipaddr[IPaddrlen];
    int port;

    /* get a channel to listen on, let kernel pick the port number */
    sprint(buf, "%s!*!0", net);
    listenfd = announce(buf, netdir);
    if(listenfd < 0)
        return seterr("can't announce");

    /* get the local address and port number */
    sprint(buf, "%s/local", netdir);
    fd = open(buf, OREAD);
    if(fd < 0)
        return seterr("opening %s: %r", buf);
    n = read(fd, buf, sizeof(buf)-1);
    close(fd);
    if(n <= 0)
        return seterr("opening %s/local: %r", netdir);
    buf[n] = 0;
    ptr = strchr(buf, ' ');
    if(ptr)
        *ptr = 0;
    ptr = strchr(buf, '!')+1;
    port = atoi(ptr);

    memset(ipaddr, 0, IPaddrlen);
    if (*net){
        strcpy(buf, net);
        ptr = strchr(buf +1, '/');
        if (ptr)
            *ptr = 0;
        myipaddr(ipaddr, buf);
    }

    /* tell remote side */
    sprint(buf, "PORT %d,%d,%d,%d,%d,%d", ipaddr[IPv4off+0], ipaddr[IPv4off+1],
        ipaddr[IPv4off+2], ipaddr[IPv4off+3], port>>8, port&0xff);
    sendrequest(buf, nil);
    if(getreply(&ctlin, msg, sizeof(msg), 0) != Success)
        return seterr(msg);
    return 0;
}
@

<<function [[active]]>>=
/*
 *  have server call back for a data connection
 */
static int
active(int mode, Biobuf **bpp, char *cmda, char *cmdb)
{
    int cfd, dfd, rv;
    char newdir[Maxpath];
    char datafile[Maxpath + 6];
    TLSconn conn;

    if(port() < 0)
        return TempFail;

    sendrequest(cmda, cmdb);

    rv = getreply(&ctlin, msg, sizeof(msg), 0);
    if(rv != Extra){
        close(listenfd);
        return rv;
    }

    /* wait for a new call */
    cfd = listen(netdir, newdir);
    if(cfd < 0)
        fatal("waiting for data connection");
    close(listenfd);

    /* open it's data connection and close the control connection */
    sprint(datafile, "%s/data", newdir);
    dfd = open(datafile, ORDWR);
    close(cfd);
    if(dfd < 0)
        fatal("opening data connection");

    if(usetls){
        memset(&conn, 0, sizeof(conn));
        dfd = tlsClient(dfd, &conn);
        if(dfd < 0)
            fatal("starting tls: %r");
        free(conn.cert);
    }

    Binit(&dbuf, dfd, mode);
    *bpp = &dbuf;
    return Extra;
}
@

<<function [[passive]]([[(networking/ip/ftpfs/proto.c)]])>>=
/*
 *  call out for a data connection
 */
static int
passive(int mode, Biobuf **bpp, char *cmda, char *cmdb)
{
    char msg[1024];
    char ds[1024];
    char *f[6];
    char *p;
    int x, fd;
    TLSconn conn;

    if(nopassive)
        return Impossible;

    sendrequest("PASV", nil);
    if(getreply(&ctlin, msg, sizeof(msg), 0) != Success){
        nopassive = 1;
        return Impossible;
    }

    /* get address and port number from reply, this is AI */
    p = strchr(msg, '(');
    if(p == 0){
        for(p = msg+3; *p; p++)
            if(isdigit(*p))
                break;
    } else
        p++;
    if(getfields(p, f, 6, 0, ",") < 6){
        if(debug)
            fprint(2, "passive mode protocol botch: %s\n", msg);
        werrstr("ftp protocol botch");
        nopassive = 1;
        return Impossible;
    }
    snprint(ds, sizeof(ds), "%s!%s.%s.%s.%s!%d", net,
        f[0], f[1], f[2], f[3],
        ((atoi(f[4])&0xff)<<8) + (atoi(f[5])&0xff));

    /* open data connection */
    fd = dial(ds, 0, 0, 0);
    if(fd < 0){
        if(debug)
            fprint(2, "passive mode connect to %s failed: %r\n", ds);
        nopassive = 1;
        return TempFail;
    }

    /* tell remote to send a file */
    sendrequest(cmda, cmdb);
    x = getreply(&ctlin, msg, sizeof(msg), 0);
    if(x != Extra){
        close(fd);
        if(debug)
            fprint(2, "passive mode retrieve failed: %s\n", msg);
        werrstr(msg);
        return x;
    }

    if(usetls){
        memset(&conn, 0, sizeof(conn));
        fd = tlsClient(fd, &conn);
        if(fd < 0)
            fatal("starting tls: %r");
        free(conn.cert);
    }
    Binit(&dbuf, fd, mode);

    *bpp = &dbuf;
    return Extra;
}
@

<<function [[data]]>>=
static int
data(int mode, Biobuf **bpp, char* cmda, char *cmdb)
{
    int x;

    x = passive(mode, bpp, cmda, cmdb);
    if(x != Impossible)
        return x;
    return active(mode, bpp, cmda, cmdb);
}
@

<<function [[nop]]>>=
/*
 *  used for keep alives
 */
void
nop(void)
{
    if(lastsend - time(0) < 15)
        return;
    sendrequest("PWD", nil);
    getreply(&ctlin, msg, sizeof(msg), 0);
}
@

<<function [[vmsextendpath]]>>=
/*
 *  turn a vms spec into a path
 */
static Node*
vmsextendpath(Node *np, char *name)
{
    np = extendpath(np, s_copy(name));
    if(!ISVALID(np)){
        np->d->qid.type = QTDIR;
        np->d->atime = time(0);
        np->d->mtime = np->d->atime;
        strcpy(np->d->uid, "who");
        strcpy(np->d->gid, "cares");
        np->d->mode = DMDIR|0777;
        np->d->length = 0;
        if(changedir(np) >= 0)
            VALID(np);
    }
    return np;
}
@

<<function [[vmsdir]]>>=
static Node*
vmsdir(char *name)
{
    char *cp;
    Node *np;
    char *oname;

    np = remroot;
    cp = strchr(name, '[');
    if(cp)
        strcpy(cp, cp+1);
    cp = strchr(name, ']');
    if(cp)
        *cp = 0;
    oname = name = strdup(name);
    if(name == 0)
        return 0;

    while(cp = strchr(name, '.')){
        *cp = 0;
        np = vmsextendpath(np, name);
        name = cp+1;
    }
    np = vmsextendpath(np, name);

    /*
     *  walk back to first accessible directory
     */
    for(; np->parent != np; np = np->parent)
        if(ISVALID(np)){
            CACHED(np->parent);
            break;
        }

    free(oname);
    return np;
}
@

<<function [[vmspath]]>>=
/*
 *  walk up the tree building a VMS style path
 */
static void
vmspath(Node *node, String *path)
{
    char *p;
    int n;

    if(node->depth == 1){
        p = strchr(s_to_c(node->remname), ':');
        if(p){
            n = p - s_to_c(node->remname) + 1;
            s_nappend(path, s_to_c(node->remname), n);
            s_append(path, "[");
            s_append(path, p+1);
        } else {
            s_append(path, "[");
            s_append(path, s_to_c(node->remname));
        }
        s_append(path, "]");
        return;
    }
    vmspath(node->parent, path);
    s_append(path, ".");
    s_append(path, s_to_c(node->remname));
}
@

<<function [[unixpath]]>>=
/*
 *  walk up the tree building a Unix style path
 */
static void
unixpath(Node *node, String *path)
{
    if(node == node->parent){
        s_append(path, s_to_c(remrootpath));
        return;
    }
    unixpath(node->parent, path);
    if(s_len(path) > 0 && strcmp(s_to_c(path), "/") != 0)
        s_append(path, "/");
    s_append(path, s_to_c(node->remname));
}
@

<<function [[mvspath]]>>=
/*
 *  walk up the tree building a MVS style path
 */
static void
mvspath(Node *node, String *path)
{
    if(node == node->parent){
        s_append(path, s_to_c(remrootpath));
        return;
    }
    mvspath(node->parent, path);
    if(s_len(path) > 0)
        s_append(path, ".");
    s_append(path, s_to_c(node->remname));
}
@

<<function [[getpassword]]>>=
static int
getpassword(char *buf, char *e)
{
    char *p;
    int c;
    int consctl, rv = 0;

    consctl = open("/dev/consctl", OWRITE);
    if(consctl >= 0)
        write(consctl, "rawon", 5);
    print("Password: ");
    e--;
    for(p = buf; p <= e; p++){
        c = Bgetc(&stdin);
        if(c < 0){
            rv = -1;
            goto out;
        }
        if(c == '\n' || c == '\r')
            break;
        *p = c;
    }
    *p = 0;
    print("\n");

out:
    if(consctl >= 0)
        close(consctl);
    return rv;
}
@

<<function [[fromlatin1]]>>=
/*
 *  convert from latin1 to utf
 */
static char*
fromlatin1(char *from)
{
    char *p, *to;
    Rune r;

    if(os == Plan9)
        return nil;

    /* don't convert if we don't have to */
    for(p = from; *p; p++)
        if(*p & 0x80)
            break;
    if(*p == 0)
        return nil;

    to = malloc(3*strlen(from)+2);
    if(to == nil)
        return nil;
    for(p = to; *from; from++){
        r = (*from) & 0xff;
        p += runetochar(p, &r);
    }
    *p = 0;
    return to;
}
@

<<function [[reallocdir]]>>=
Dir*
reallocdir(Dir *d, int dofree)
{
    Dir *dp;
    char *p;
    int nn, ng, nu, nm;
    char *utf;

    if(d->name == nil)
        d->name = "?name?";
    if(d->uid == nil)
        d->uid = "?uid?";
    if(d->gid == nil)
        d->gid = d->uid;
    if(d->muid == nil)
        d->muid = d->uid;
    
    utf = fromlatin1(d->name);
    if(utf != nil)
        d->name = utf;

    nn = strlen(d->name)+1;
    nu = strlen(d->uid)+1;
    ng = strlen(d->gid)+1;
    nm = strlen(d->muid)+1;
    dp = malloc(sizeof(Dir)+nn+nu+ng+nm);
    if(dp == nil){
        if(dofree)
            free(d);
        if(utf != nil)
            free(utf);
        return nil;
    }
    *dp = *d;
    p = (char*)&dp[1];
    strcpy(p, d->name);
    dp->name = p;
    p += nn;
    strcpy(p, d->uid);
    dp->uid = p;
    p += nu;
    strcpy(p, d->gid);
    dp->gid = p;
    p += ng;
    strcpy(p, d->muid);
    dp->muid = p;
    if(dofree)
        free(d);
    if(utf != nil)
        free(utf);
    return dp;
}
@

<<function [[dir_change_name]]>>=
Dir*
dir_change_name(Dir *d, char *name)
{
    if(d->name && strlen(d->name) >= strlen(name)){
        strcpy(d->name, name);
        return d;
    }
    d->name = name;
    return reallocdir(d, 1);
}
@

<<function [[dir_change_uid]]>>=
Dir*
dir_change_uid(Dir *d, char *name)
{
    if(d->uid && strlen(d->uid) >= strlen(name)){
        strcpy(d->name, name);
        return d;
    }
    d->uid = name;
    return reallocdir(d, 1);
}
@

<<function [[dir_change_gid]]>>=
Dir*
dir_change_gid(Dir *d, char *name)
{
    if(d->gid && strlen(d->gid) >= strlen(name)){
        strcpy(d->name, name);
        return d;
    }
    d->gid = name;
    return reallocdir(d, 1);
}
@

<<function [[dir_change_muid]]>>=
Dir*
dir_change_muid(Dir *d, char *name)
{
    if(d->muid && strlen(d->muid) >= strlen(name)){
        strcpy(d->name, name);
        return d;
    }
    d->muid = name;
    return reallocdir(d, 1);
}
@

<<function [[nw_mode]]>>=
static int
nw_mode(char dirlet, char *s)		/* NetWare file mode mapping */
{
    int mode = 0777;

    if(dirlet == 'd')
        mode |= DMDIR;

    if (strlen(s) >= 10 && s[0] != '[' || s[9] != ']')
        return(mode);

    if (s[1] == '-')					/* can't read file */
        mode &= ~0444;
    if (dirlet == 'd' && s[6] == '-')			/* cannot scan dir */
        mode &= ~0444;
    if (s[2] == '-')					/* can't write file */
        mode &= ~0222;
    if (dirlet == 'd' && s[7] == '-' && s[3] == '-')	/* cannot create in, or modify dir */
        mode &= ~0222;

    return(mode);
}
@


%-------------------------------------------------------------

<<networking/ip/ftpfs/proto.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ip.h>
#include <mp.h>
#include <libsec.h>
#include <auth.h>
#include <fcall.h>
#include <ctype.h>
#include <string.h>
#include "ftpfs.h"

<<enum [[_anon_ (networking/ip/ftpfs/proto.c)]]>>

<<global [[remdir]]>>
<<global [[remroot]]>>

<<global [[ctlfd]]>>
<<global [[ctlin]]>>
<<global [[stdin]]>>
<<global [[dbuf]]>>
<<global [[msg]]>>
<<global [[net]]([[(networking/ip/ftpfs/proto.c)]])>>
<<global [[listenfd]]>>
<<global [[netdir]]([[(networking/ip/ftpfs/proto.c)]])>>
int	os, defos;
<<global [[topsdir]]>>
<<global [[remrootpath]]>>
<<global [[user]]([[(networking/ip/ftpfs/proto.c)]])>>
<<global [[nopassive]]>>
<<global [[lastsend]]>>
extern int usetls;

static void	sendrequest(char*, char*);
static int	getreply(Biobuf*, char*, int, int);
static int	active(int, Biobuf**, char*, char*);
static int	passive(int, Biobuf**, char*, char*);
static int	data(int, Biobuf**, char*, char*);
static int	port(void);
static void	ascii(void);
static void	image(void);
static void	unixpath(Node*, String*);
static void	vmspath(Node*, String*);
static void	mvspath(Node*, String*);
static Node*	vmsdir(char*);
static int	getpassword(char*, char*);
static int	nw_mode(char dirlet, char *s);

<<function [[hello]]>>

<<function [[rlogin]]([[(networking/ip/ftpfs/proto.c)]])>>

<<function [[clogin]]>>

<<function [[preamble]]>>

<<function [[ascii]]>>

<<function [[image]]>>

<<global [[monthchars]]>>
<<global [[now]]([[(networking/ip/ftpfs/proto.c)]])>>

<<function [[cracktime]]>>

<<function [[crackmode]]>>

<<function [[strpunct]]>>

<<function [[crackdir]]>>

/*
 *  probe files in a directory to see if they are directories
 */
<<function [[readdir]]>>

<<function [[createdir]]>>

<<function [[changedir]]>>

<<function [[readfile1]]>>

<<function [[readfile]]>>

<<function [[createfile1]]>>

<<function [[createfile]]>>

<<function [[removefile]]>>

<<function [[removedir]]>>

<<function [[quit]]>>

<<function [[sendrequest]]>>

<<function [[getreply]]>>

<<function [[port]]>>

<<function [[active]]>>

<<function [[passive]]([[(networking/ip/ftpfs/proto.c)]])>>

<<function [[data]]>>

<<function [[nop]]>>

<<function [[vmsextendpath]]>>
<<function [[vmsdir]]>>

<<function [[vmspath]]>>

<<function [[unixpath]]>>

<<function [[mvspath]]>>

<<function [[getpassword]]>>

<<function [[fromlatin1]]>>

<<function [[reallocdir]]>>

<<function [[dir_change_name]]>>

<<function [[dir_change_uid]]>>

<<function [[dir_change_gid]]>>

<<function [[dir_change_muid]]>>

<<function [[nw_mode]]>>
@


\section{[[networking/ip/]]}

\subsection*{[[networking/ip/tftpd.c]]}

<<enum [[_anon_ (networking/ip/tftpd.c)]]>>=
enum
{
    Maxpath=	128,
    Maxerr=		256,

    Debug=		0,

    Opsize=		sizeof(short),
    Blksize=	sizeof(short),
    Hdrsize=	Opsize + Blksize,

    Ackerr=		-1,
    Ackok=		0,
    Ackrexmit=	1,

    /* op codes */
    Tftp_READ	= 1,
    Tftp_WRITE	= 2,
    Tftp_DATA	= 3,
    Tftp_ACK	= 4,
    Tftp_ERROR	= 5,
    Tftp_OACK	= 6,		/* option acknowledge */

    Errnotdef	= 0,		/* see textual error instead */
    Errnotfound	= 1,
    Errnoaccess	= 2,
    Errdiskfull	= 3,
    Errbadop	= 4,
    Errbadtid	= 5,
    Errexists	= 6,
    Errnouser	= 7,
    Errbadopt	= 8,		/* really bad option value */

    Defsegsize	= 512,
    Maxsegsize	= 65464,	/* from rfc2348 */

    /*
     * bandt (viaduct) tunnels use smaller mtu than ether's
     * (1400 bytes for tcp mss of 1300 bytes).
     */
    Bandtmtu	= 1400,
    /*
     * maximum size of block's data content, excludes hdrs,
     * notably IP/UDP and TFTP, using worst-case (IPv6) sizes.
     */
    Bandtblksz	= Bandtmtu - 40 - 8,
    Bcavium		= 1432,		/* cavium's u-boot demands this size */
};
@

<<struct [[Opt]]([[(networking/ip/tftpd.c)]])>>=
struct Opt {
    char	*name;
    int	*valp;		/* set to client's value if within bounds */
    int	min;
    int	max;
};
@

<<global [[dbg]]([[(networking/ip/tftpd.c)]])>>=
int 	dbg;
@

<<global [[restricted]]>>=
int	restricted;
@

<<global [[pid]]([[(networking/ip/tftpd.c)]])>>=
int	pid;
@

<<global [[blksize]]>>=
/* options */
int	blksize = Defsegsize;		/* excluding 4-byte header */
@

<<global [[timeout]]>>=
int	timeout = 5;			/* seconds */
@

<<global [[tsize]]>>=
int	tsize;
@

<<global [[option]]([[(networking/ip/tftpd.c)]])>>=
static Opt option[] = {
    "timeout",	&timeout,	1,	255,
    /* see "hack" below */
    "blksize",	&blksize,	8,	Maxsegsize,
    "tsize",	&tsize,		0,	~0UL >> 1,
};
@

<<global [[bigbuf]]>>=
char	bigbuf[32768];
@

<<global [[raddr]]>>=
char	raddr[64];
@

<<global [[dir]]>>=
char	*dir = "/lib/tftpd";
@

<<global [[dirsl]]>>=
char	*dirsl;
@

<<global [[dirsllen]]>>=
int	dirsllen;
@

<<global [[flog]]>>=
char	flog[] = "ipboot";
@

<<global [[net]]([[(networking/ip/tftpd.c)]])>>=
char	net[Maxpath];
@

<<global [[opnames]]>>=
static char *opnames[] = {
[Tftp_READ]	"read",
[Tftp_WRITE]	"write",
[Tftp_DATA]	"data",
[Tftp_ACK]	"ack",
[Tftp_ERROR]	"error",
[Tftp_OACK]	"oack",
};
@

<<function [[usage]]([[(networking/ip/tftpd.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-dr] [-h homedir] [-s svc] [-x netmtpt]\n",
        argv0);
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/tftpd.c)]])>>=
void
main(int argc, char **argv)
{
    char buf[64];
    char adir[64], ldir[64];
    int cfd, lcfd, dfd;
    char *svc = "69";

    setnetmtpt(net, sizeof net, nil);
    ARGBEGIN{
    case 'd':
        dbg++;
        break;
    case 'h':
        dir = EARGF(usage());
        break;
    case 'r':
        restricted = 1;
        break;
    case 's':
        svc = EARGF(usage());
        break;
    case 'x':
        setnetmtpt(net, sizeof net, EARGF(usage()));
        break;
    default:
        usage();
    }ARGEND

    snprint(buf, sizeof buf, "%s/", dir);
    dirsl = strdup(buf);
    dirsllen = strlen(dirsl);

    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);

    /*
     * setuser calls newns, and typical /lib/namespace files contain
     * "cd /usr/$user", so call setuser before chdir.
     */
    setuser();
    if(chdir(dir) < 0)
        sysfatal("can't get to directory %s: %r", dir);

    if(!dbg)
        switch(rfork(RFNOTEG|RFPROC|RFFDG)) {
        case -1:
            sysfatal("fork: %r");
        case 0:
            break;
        default:
            exits(0);
        }

    snprint(buf, sizeof buf, "%s/udp!*!%s", net, svc);
    cfd = announce(buf, adir);
    if (cfd < 0)
        sysfatal("announcing on %s: %r", buf);
    syslog(dbg, flog, "tftpd started on %s dir %s", buf, adir);
//	setuser();
    for(;;) {
        lcfd = listen(adir, ldir);
        if(lcfd < 0)
            sysfatal("listening on %s: %r", adir);

        switch(fork()) {
        case -1:
            sysfatal("fork: %r");
        case 0:
            dfd = accept(lcfd, ldir);
            if(dfd < 0)
     exits(0);
            remoteaddr(ldir, raddr, sizeof(raddr));
            pid = getpid();
            syslog(0, flog, "tftp %d connection from %s dir %s",
                pid, raddr, ldir);
            doserve(dfd);
            exits("done");
            break;
        default:
            close(lcfd);
            continue;
        }
    }
}
@
%$

<<function [[handleopt]]>>=
static Opt *
handleopt(int fd, char *name, char *val)
{
    int n;
    Opt *op;

    for (op = option; op < option + nelem(option); op++)
        if(cistrcmp(name, op->name) == 0) {
            n = strtol(val, nil, 10);
            if (n < op->min || n > op->max) {
                nak(fd, Errbadopt, "option value out of range");
                syslog(dbg, flog, "tftp bad option value from "
                    "client: %s %s", name, val);
                sysfatal("bad option value from client: %s %s",
                    name, val);
            }
            *op->valp = n;
            /* incoming 0 for tsize is uninteresting */
            if(cistrcmp("tsize", op->name) != 0)
                syslog(dbg, flog, "tftpd %d setting %s to client's %d",
                    pid, name, n);
            return op;
        }
    return nil;
}
@

<<function [[filesize]]>>=
static vlong
filesize(char *file)
{
    vlong size;
    Dir *dp;

    dp = dirstat(file);
    if (dp == nil)
        return -1;
    size = dp->length;
    free(dp);
    return size;
}
@

<<function [[emits]]>>=
/* copy word into bp iff it fits before ep, returns bytes to advance bp. */
static int
emits(char *word, char *bp, char *ep)
{
    int len;

    len = strlen(word) + 1;
    if (bp + len >= ep)
        return -1;
    strcpy(bp, word);
    return len;
}
@

<<function [[emitn]]>>=
/* format number into bp iff it fits before ep. */
static int
emitn(vlong n, char *bp, char *ep)
{
    char numb[32];

    snprint(numb, sizeof numb, "%lld", n);
    return emits(numb, bp, ep);
}
@

<<function [[options]]>>=
/*
 * send an OACK packet to respond to options.  bail early with -1 on error.
 * p is the packet containing the options.
 *
 * hack: bandt (viaducts) uses smaller mtu than ether's
 * (1400 bytes for tcp mss of 1300 bytes),
 * so offer at most bandt's mtu minus headers,
 * to avoid failure of pxe booting via viaduct.
 * there's an exception for the cavium's u-boot.
 */
static int
options(int fd, char *buf, int bufsz, char *file, ushort oper, char *p, int dlen)
{
    int nmlen, vallen, olen, nopts;
    vlong size;
    char *val, *bp, *ep;
    Opt *op;

    buf[0] = 0;
    buf[1] = Tftp_OACK;
    bp = buf + Opsize;
    ep = buf + bufsz;
    nopts = 0;
    for (; dlen > 0 && *p != '\0'; p = val + vallen, bp += olen) {
        nmlen = strlen(p) + 1;		/* include NUL */
        if (nmlen > dlen)
            break;
        dlen -= nmlen;
        val = p + nmlen;
        if (dlen <= 0 || *val == '\0')
            break;

        vallen = strlen(val) + 1;
        if (vallen > dlen)
            break;
        dlen -= vallen;

        nopts++;
        olen = 0;
        op = handleopt(fd, p, val);
        if (op == nil)
            continue;

        /* append OACK response to buf */
        nmlen = emits(p, bp, ep);	/* option name */
        if (nmlen < 0)
            return -1;
        bp += nmlen;

        if (oper == Tftp_READ && cistrcmp(p, "tsize") == 0) {
            size = filesize(file);
            if (size == -1) {
                nak(fd, Errnotfound, "no such file");
                syslog(dbg, flog, "tftpd tsize for "
                    "non-existent file %s", file);
                // *op->valp = 0;
                // olen = emits("0", bp, ep);
                return -1;
            }
            *op->valp = size;
            olen = emitn(size, bp, ep);
            syslog(dbg, flog, "tftpd %d %s tsize is %,lld",
                pid, file, size);
        } else if (oper == Tftp_READ && cistrcmp(p, "blksize") == 0 &&
            blksize > Bandtblksz && blksize != Bcavium) {
            *op->valp = blksize = Bandtblksz;
            olen = emitn(blksize, bp, ep);
            syslog(dbg, flog, "tftpd %d overriding blksize to %d",
                pid, blksize);
        } else
            olen = emits(val, bp, ep);  /* use requested value */
    }
    if (nopts == 0)
        return 0;		/* no options actually seen */

    if (write(fd, buf, bp - buf) < bp - buf) {
        syslog(dbg, flog, "tftpd network write error on oack to %s: %r",
            raddr);
        sysfatal("tftpd: network write error: %r");
    }
    if(Debug)
        syslog(dbg, flog, "tftpd oack: options to %s", raddr);
    return nopts;
}
@

<<function [[optlog]]>>=
static void
optlog(char *bytes, char *p, int dlen)
{
    char *bp;

    bp = bytes;
    sprint(bp, "tftpd %d option bytes: ", dlen);
    bp += strlen(bp);
    for (; dlen > 0; dlen--, p++)
        *bp++ = *p? *p: ' ';
    *bp = '\0';
    syslog(dbg, flog, "%s", bytes);
}
@

<<function [[mapname]]>>=
/*
 * replace one occurrence of %[ICE] with ip, cfgpxe name, or ether mac, resp.
 * we can't easily use $ because u-boot has stranger quoting rules than sh.
 */
char *
mapname(char *file)
{
    int nf;
    char *p, *newnm, *cur, *arpf, *ln, *remip, *bang;
    char *fields[4];
    Biobuf *arp;

    p = strchr(file, '%');
    if (p == nil || p[1] == '\0')
        return strdup(file);

    remip = strdup(raddr);
    newnm = mallocz(strlen(file) + Maxpath, 1);
    if (remip == nil || newnm == nil)
        sysfatal("out of memory");

    bang = strchr(remip, '!');
    if (bang)
        *bang = '\0';			/* remove !port */

    memmove(newnm, file, p - file);		/* copy up to % */
    cur = newnm + strlen(newnm);
    switch(p[1]) {
    case 'I':
        strcpy(cur, remip);		/* remote's IP */
        break;
    case 'C':
        strcpy(cur, "/cfg/pxe/");
        cur += strlen(cur);
        /* fall through */
    case 'E':
        /* look up remote's IP in /net/arp to get mac. */
        arpf = smprint("%s/arp", net);
        arp = Bopen(arpf, OREAD);
        free(arpf);
        if (arp == nil)
            break;
        /* read lines looking for remip in 3rd field of 4 */
        while ((ln = Brdline(arp, '\n')) != nil) {
            ln[Blinelen(arp)-1] = 0;
            nf = tokenize(ln, fields, nelem(fields));
            if (nf >= 4 && strcmp(fields[2], remip) == 0) {
                strcpy(cur, fields[3]);
                break;
            }
        }
        Bterm(arp);
        break;
    }
    strcat(newnm, p + 2);			/* tail following %x */
    free(remip);
    return newnm;
}
@
%$

<<function [[doserve]]>>=
void
doserve(int fd)
{
    int dlen, opts;
    char *mode, *p, *file;
    short op;

    dlen = read(fd, bigbuf, sizeof(bigbuf)-1);
    if(dlen < 0)
        sysfatal("listen read: %r");

    bigbuf[dlen] = '\0';
    op = (bigbuf[0]<<8) | bigbuf[1];
    dlen -= Opsize;
    mode = file = bigbuf + Opsize;
    while(*mode != '\0' && dlen--)
        mode++;
    mode++;
    p = mode;
    while(*p && dlen--)
        p++;

    file = mapname(file);	/* we don't free the result; minor leak */

    if(dlen == 0) {
        nak(fd, 0, "bad tftpmode");
        close(fd);
        syslog(dbg, flog, "tftpd %d bad mode %s for file %s from %s",
            pid, mode, file, raddr);
        return;
    }

    if(op != Tftp_READ && op != Tftp_WRITE) {
        nak(fd, Errbadop, "Illegal TFTP operation");
        close(fd);
        syslog(dbg, flog, "tftpd %d bad request %d (%s) %s", pid, op,
            (op < nelem(opnames)? opnames[op]: "gok"), raddr);
        return;
    }

    if(restricted){
        if(file[0] == '#' || strncmp(file, "../", 3) == 0 ||
          strstr(file, "/../") != nil ||
          (file[0] == '/' && strncmp(file, dirsl, dirsllen) != 0)){
            nak(fd, Errnoaccess, "Permission denied");
            close(fd);
            syslog(dbg, flog, "tftpd %d bad request %d from %s file %s",
                pid, op, raddr, file);
            return;
        }
    }

    /*
     * options are supposed to be negotiated, but the cavium board's
     * u-boot really wants us to use a block size of 1432 bytes and won't
     * take `no' for an answer.
     */
    p++;				/* skip NUL after mode */
    dlen--;
    opts = 0;
    if(dlen > 0) {			/* might have options */
        char bytes[32*1024];

        if(Debug)
            optlog(bytes, p, dlen);
        opts = options(fd, bytes, sizeof bytes, file, op, p, dlen);
        if (opts < 0)
            return;
    }
    if(op == Tftp_READ)
        sendfile(fd, file, mode, opts);
    else
        recvfile(fd, file, mode);
}
@

<<function [[catcher]]([[(networking/ip/tftpd.c)]])>>=
void
catcher(void *junk, char *msg)
{
    USED(junk);

    if(strncmp(msg, "exit", 4) == 0)
        noted(NDFLT);
    noted(NCONT);
}
@

<<function [[awaitack]]>>=
static int
awaitack(int net, int block)
{
    int ackblock, al, rxl;
    ushort op;
    uchar ack[1024];

    for(rxl = 0; rxl < 10; rxl++) {
        memset(ack, 0, Hdrsize);
        alarm(1000);
        al = read(net, ack, sizeof(ack));
        alarm(0);
        if(al < 0) {
            if (Debug)
                syslog(dbg, flog, "tftpd %d timed out "
                    "waiting for ack from %s", pid, raddr);
            return Ackrexmit;
        }
        op = ack[0]<<8|ack[1];
        if(op == Tftp_ERROR) {
            if (Debug)
                syslog(dbg, flog, "tftpd %d got error "
                    "waiting for ack from %s", pid, raddr);
            return Ackerr;
        } else if(op != Tftp_ACK) {
            syslog(dbg, flog, "tftpd %d rcvd %s op from %s", pid,
                (op < nelem(opnames)? opnames[op]: "gok"),
                raddr);
            return Ackerr;
        }
        ackblock = ack[2]<<8|ack[3];
        if (Debug)
            syslog(dbg, flog, "tftpd %d read ack of %d bytes "
                "for block %d", pid, al, ackblock);
        if(ackblock == block)
            return Ackok;		/* for block just sent */
        else if(ackblock == block + 1)	/* intel pxe eof bug */
            return Ackok;
        else if(ackblock == 0xffff)
            return Ackrexmit;
        else
            /* ack is for some other block; ignore it, try again */
            syslog(dbg, flog, "tftpd %d expected ack for block %d, "
                "got %d", pid, block, ackblock);
    }
    return Ackrexmit;
}
@

<<function [[sendfile]]>>=
void
sendfile(int net, char *name, char *mode, int opts)
{
    int file, block, ret, rexmit, n, txtry, failed;
    uchar buf[Maxsegsize+Hdrsize];
    char errbuf[Maxerr];

    file = -1;
    failed = 1;
    syslog(dbg, flog, "tftpd %d send file '%s' %s to %s",
        pid, name, mode, raddr);
    name = sunkernel(name);
    if(name == 0){
        nak(net, 0, "not in our database");
        goto error;
    }

    notify(catcher);

    file = open(name, OREAD);
    if(file < 0) {
        errstr(errbuf, sizeof errbuf);
        nak(net, 0, errbuf);
        goto error;
    }
    block = 0;
    rexmit = Ackok;
    n = 0;
    /*
     * if we sent an oack previously, wait for the client's ack or error.
     * if we get no ack for our oack, it could be that we returned
     * a tsize that the client can't handle, or it could be intel
     * pxe just read-with-tsize to get size, couldn't be bothered to
     * ack our oack and has just gone ahead and issued another read.
     */
    if(opts && awaitack(net, 0) != Ackok)
        goto error;

    for(txtry = 0; txtry < timeout;) {
        if(rexmit == Ackok) {
            /* block number wraparound for enormous hogs */
            if (block >= 65536)
                block = 0;
            block++;
            buf[0] = 0;
            buf[1] = Tftp_DATA;
            buf[2] = block>>8;
            buf[3] = block;
            n = read(file, buf+Hdrsize, blksize);
            if(n < 0) {
                errstr(errbuf, sizeof errbuf);
                nak(net, 0, errbuf);
                goto error;
            }
            txtry = 0;
        }
        else {
            syslog(dbg, flog, "tftpd %d rexmit %d %s:%d to %s",
                pid, Hdrsize+n, name, block, raddr);
            txtry++;
        }

        ret = write(net, buf, Hdrsize+n);
        if(ret < Hdrsize+n) {
            syslog(dbg, flog,
                "tftpd network write error on %s to %s: %r",
                name, raddr);
            sysfatal("tftpd: network write error: %r");
        }
        if (Debug)
            syslog(dbg, flog, "tftpd %d sent block %d", pid, block);

        rexmit = awaitack(net, block);
        if (rexmit == Ackerr)
            break;
        if(ret != blksize+Hdrsize && rexmit == Ackok) {
            failed = 0;
            break;
        }
    }
error:
    syslog(dbg, flog, "tftpd %d %s file '%s' %s to %s",
        pid, (failed? "failed to send": "sent"), name, mode, raddr);
    close(net);
    close(file);
}
@

<<function [[recvfile]]>>=
void
recvfile(int net, char *name, char *mode)
{
    ushort op, block, inblock;
    uchar buf[Maxsegsize+8];
    char errbuf[Maxerr];
    int n, ret, file;

    syslog(dbg, flog, "receive file '%s' %s from %s", name, mode, raddr);

    file = create(name, OWRITE, 0666);
    if(file < 0) {
        errstr(errbuf, sizeof errbuf);
        nak(net, 0, errbuf);
        syslog(dbg, flog, "can't create %s: %r", name);
        return;
    }

    block = 0;
    ack(net, block);
    block++;

    for (;;) {
        alarm(15000);
        n = read(net, buf, blksize+8);
        alarm(0);
        if(n < 0) {
            syslog(dbg, flog, "tftpd: network error reading %s: %r",
                name);
            goto error;
        }
        /*
         * NB: not `<='; just a header is legal and happens when
         * file being read is a multiple of segment-size bytes long.
         */
        if(n < Hdrsize) {
            syslog(dbg, flog,
                "tftpd: short read from network, reading %s",
                name);
            goto error;
        }
        op = buf[0]<<8|buf[1];
        if(op == Tftp_ERROR) {
            syslog(dbg, flog, "tftpd: tftp error reading %s", name);
            goto error;
        }

        n -= Hdrsize;
        inblock = buf[2]<<8|buf[3];
        if(op == Tftp_DATA) {
            if(inblock == block) {
                ret = write(file, buf+Hdrsize, n);
                if(ret != n) {
                    errstr(errbuf, sizeof errbuf);
                    nak(net, 0, errbuf);
                    syslog(dbg, flog,
                        "tftpd: error writing %s: %s",
                        name, errbuf);
                    goto error;
                }
                ack(net, block);
                block++;
            } else
                ack(net, 0xffff);	/* tell him to resend */
        }
    }
error:
    close(file);
}
@

<<function [[ack]]>>=
void
ack(int fd, ushort block)
{
    uchar ack[4];
    int n;

    ack[0] = 0;
    ack[1] = Tftp_ACK;
    ack[2] = block>>8;
    ack[3] = block;

    n = write(fd, ack, 4);
    if(n < 4)
        sysfatal("network write: %r");
}
@

<<function [[nak]]>>=
void
nak(int fd, int code, char *msg)
{
    char buf[128];
    int n;

    buf[0] = 0;
    buf[1] = Tftp_ERROR;
    buf[2] = 0;
    buf[3] = code;
    strcpy(buf+4, msg);
    n = strlen(msg) + 4 + 1;
    if(write(fd, buf, n) < n)
        sysfatal("write nak: %r");
}
@

<<function [[setuser]]>>=
void
setuser(void)
{
    int fd;

    fd = open("#c/user", OWRITE);
    if(fd < 0 || write(fd, "none", strlen("none")) < 0)
        sysfatal("can't become none: %r");
    close(fd);
    if(newns("none", nil) < 0)
        sysfatal("can't build namespace: %r");
}
@

<<function [[lookup]]([[(networking/ip/tftpd.c)]])>>=
char*
lookup(char *sattr, char *sval, char *tattr, char *tval, int len)
{
    static Ndb *db;
    char *attrs[1];
    Ndbtuple *t;

    if(db == nil)
        db = ndbopen(0);
    if(db == nil)
        return nil;

    if(sattr == nil)
        sattr = ipattr(sval);

    attrs[0] = tattr;
    t = ndbipinfo(db, sattr, sval, attrs, 1);
    if(t == nil)
        return nil;
    strncpy(tval, t->val, len);
    tval[len-1] = 0;
    ndbfree(t);
    return tval;
}
@

<<function [[sunkernel]]>>=
/*
 *  for sun kernel boots, replace the requested file name with
 *  a one from our database.  If the database doesn't specify a file,
 *  don't answer.
 */
char*
sunkernel(char *name)
{
    ulong addr;
    uchar v4[IPv4addrlen];
    uchar v6[IPaddrlen];
    char buf[256];
    char ipbuf[128];
    char *suffix;

    addr = strtoul(name, &suffix, 16);
    if(suffix-name != 8 || (strcmp(suffix, "") != 0 && strcmp(suffix, ".SUN") != 0))
        return name;

    v4[0] = addr>>24;
    v4[1] = addr>>16;
    v4[2] = addr>>8;
    v4[3] = addr;
    v4tov6(v6, v4);
    sprint(ipbuf, "%I", v6);
    return lookup("ip", ipbuf, "bootf", buf, sizeof buf);
}
@

<<function [[remoteaddr]]>>=
void
remoteaddr(char *dir, char *raddr, int len)
{
    char buf[64];
    int fd, n;

    snprint(buf, sizeof(buf), "%s/remote", dir);
    fd = open(buf, OREAD);
    if(fd < 0){
        snprint(raddr, sizeof(raddr), "unknown");
        return;
    }
    n = read(fd, raddr, len-1);
    close(fd);
    if(n <= 0){
        snprint(raddr, sizeof(raddr), "unknown");
        return;
    }
    if(n > 0)
        n--;
    raddr[n] = 0;
}
@


%-------------------------------------------------------------

<<networking/ip/tftpd.c>>=
/*
 * tftpd - tftp service, see /lib/rfc/rfc783 (now rfc1350 + 234[789])
 */
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <bio.h>
#include <ip.h>
#include <ndb.h>

<<enum [[_anon_ (networking/ip/tftpd.c)]]>>

typedef struct Opt Opt;
<<struct [[Opt]]([[(networking/ip/tftpd.c)]])>>

<<global [[dbg]]([[(networking/ip/tftpd.c)]])>>
<<global [[restricted]]>>
<<global [[pid]]([[(networking/ip/tftpd.c)]])>>

<<global [[blksize]]>>
<<global [[timeout]]>>
<<global [[tsize]]>>
<<global [[option]]([[(networking/ip/tftpd.c)]])>>

void	sendfile(int, char*, char*, int);
void	recvfile(int, char*, char*);
void	nak(int, int, char*);
void	ack(int, ushort);
void	clrcon(void);
void	setuser(void);
char*	sunkernel(char*);
void	remoteaddr(char*, char*, int);
void	doserve(int);

<<global [[bigbuf]]>>
<<global [[raddr]]>>

<<global [[dir]]>>
<<global [[dirsl]]>>
<<global [[dirsllen]]>>
<<global [[flog]]>>
<<global [[net]]([[(networking/ip/tftpd.c)]])>>

<<global [[opnames]]>>

<<function [[usage]]([[(networking/ip/tftpd.c)]])>>

<<function [[main]]([[(networking/ip/tftpd.c)]])>>

<<function [[handleopt]]>>

<<function [[filesize]]>>

<<function [[emits]]>>

<<function [[emitn]]>>

<<function [[options]]>>

<<function [[optlog]]>>

<<function [[mapname]]>>

<<function [[doserve]]>>

<<function [[catcher]]([[(networking/ip/tftpd.c)]])>>

<<function [[awaitack]]>>

<<function [[sendfile]]>>

<<function [[recvfile]]>>

<<function [[ack]]>>

<<function [[nak]]>>

<<function [[setuser]]>>

<<function [[lookup]]([[(networking/ip/tftpd.c)]])>>

<<function [[sunkernel]]>>

<<function [[remoteaddr]]>>
@


\section{[[networking/ip/httpd/]]}

\subsection*{[[networking/ip/httpd/anonymous.c]]}

<<function [[anonymous]]>>=
void
anonymous(HConnect *c)
{
    if(bind(webroot, "/", MREPL) < 0){
        hfail(c, HInternal);
        exits(nil);
    }
    chdir("/");
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/anonymous.c>>=
#include <u.h>
#include <libc.h>
#include "httpd.h"
#include "httpsrv.h"

<<function [[anonymous]]>>
@


\subsection*{[[networking/ip/httpd/authorize.c]]}

<<constant [[UNAUTHED]]>>=
/*
 * these should be done better; see the response codes in /lib/rfc/rfc2616 for
 * more info on what should be included.
 */
#define UNAUTHED	"You are not authorized to see this area.\n"
@

<<function [[authorize]]>>=
/*
 * check for authorization for some parts of the server tree.
 * the user name supplied with the authorization request is ignored;
 * instead, we authenticate as the realm's user.
 *
 * authorization should be done before opening any files so that
 * unauthorized users don't get to validate file names.
 *
 * returns 1 if authorized, 0 if unauthorized, -1 for io failure.
 */
int
authorize(HConnect *c, char *file)
{
    char *p, *p0;
    Hio *hout;
    char *buf;
    int i, n;
    char *t[257];

    p0 = halloc(c, strlen(file)+STRLEN("/.httplogin")+1);
    strcpy(p0, file);
    for(;;){
        p = strrchr(p0, '/');
        if(p == nil)
            return hfail(c, HInternal);
        if(*(p+1) != 0)
            break;

        /* ignore trailing '/'s */
        *p = 0;
    }
    strcpy(p, "/.httplogin");

    buf = readfile(p0);
    if(buf == nil){
        return 1;
    }
    n = tokenize(buf, t, nelem(t));
    
    if(c->head.authuser != nil && c->head.authpass != 0){
        for(i = 1; i+1 < n; i += 2){
            if(strcmp(t[i], c->head.authuser) == 0
            && strcmp(t[i+1], c->head.authpass) == 0){
                free(buf);
                return 1;
            }
        }
    }

    hout = &c->hout;
    hprint(hout, "%s 401 Unauthorized\r\n", hversion);
    hprint(hout, "Server: Plan9\r\n");
    hprint(hout, "Date: %D\r\n", time(nil));
    hprint(hout, "WWW-Authenticate: Basic realm=\"%s\"\r\n", t[0]);
    hprint(hout, "Content-Type: text/html\r\n");
    hprint(hout, "Content-Length: %d\r\n", STRLEN(UNAUTHED));
    if(c->head.closeit)
        hprint(hout, "Connection: close\r\n");
    else if(!http11(c))
        hprint(hout, "Connection: Keep-Alive\r\n");
    hprint(hout, "\r\n");
    if(strcmp(c->req.meth, "HEAD") != 0)
        hprint(hout, "%s", UNAUTHED);
    writelog(c, "Reply: 401 Unauthorized\n");
    free(buf);
    return hflush(hout);
}
@

<<function [[readfile]]([[(networking/ip/httpd/authorize.c)]])>>=
static char*
readfile(char *file)
{
    Dir *d;
    int fd;
    char *buf;
    int n, len;

    fd = open(file, OREAD);
    if(fd < 0)
        return nil;
    d = dirfstat(fd);
    if(d == nil){		/* shouldn't happen */
        close(fd);
        return nil;
    }
    len = d->length;
    free(d);

    buf = malloc(len+1);
    if(buf == 0){
        close(fd);
        return nil;
    }

    n = readn(fd, buf, len);
    close(fd);
    if(n <= 0){
        free(buf);
        return nil;
    }
    buf[n] = '\0';
    return buf;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/authorize.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include "httpd.h"
#include "httpsrv.h"

static char*	readfile(char*);

<<constant [[UNAUTHED]]>>

<<function [[authorize]]>>

<<function [[readfile]]([[(networking/ip/httpd/authorize.c)]])>>
@


\subsection*{[[networking/ip/httpd/classify.c]]}

<<struct [[Country]]>>=
struct Country
{
    char *code;
    char *name;
};
@

<<global [[badc]]>>=
Country badc[] =
{
    {"af", "afghanistan"},
    {"cu", "cuba"},
    {"ir", "iran"},
    {"iq", "iraq"},
    {"ly", "libya"},
    {"kp", "north korea"},
    {"sd", "sudan"},
    {"sy", "syria"},
    { 0, 0 }
};
@

<<global [[goodc]]>>=
Country goodc[] =
{
    // the original, us and canada
    {"us", "united states of america"},
    {"ca", "canada"},
    {"gov", "gov"},
    {"mil", "mil"},

    // the european union
    { "eu",	"european union" },
    { "be",	"belgium" },
    { "de",	"germany" },
    { "fr",	"france" },
    { "it",	"italy" },
    { "lu",	"luxembourg" },
    { "nl",	"netherlands" },
    { "dk",	"denmark" },
    { "ie",	"ireland" },
    { "gb",	"great britain" },
    { "uk",	"united kingdom" },
    { "gr",	"greece" },
    { "es",	"spain" },
    { "pt",	"portugal" },
    { "au",	"australia" },
    { "fi",	"finland" },
    { "se",	"sweden" },

    // the rest
    {"au", "australia"},
    {"no", "norway"},
    {"cz", "czech republic"},
    {"hu", "hungary"},
    {"pl", "poland"},
    {"jp", "japan"},
    {"ch", "switzerland"},
    {"nz", "new zealand"},
    { 0, 0 }
};
@

<<global [[gov]]>>=
char *gov[] =
{
    "gov",
    "gouv",
    "mil",
    "government",
    0,
};
@

<<global [[allc]]>>=
Country allc[] =
{
    { "ad",	"andorra" },
    { "ae",	"united arab emirates" },
    { "af",	"afghanistan" },
    { "ag",	"antigua and barbuda" },
    { "ai",	"anguilla" },
    { "al",	"albania" },
    { "am",	"armenia" },
    { "an",	"netherlands antilles" },
    { "ao",	"angola" },
    { "aq",	"antarctica" },
    { "ar",	"argentina" },
    { "as",	"american samoa" },
    { "at",	"austria" },
    { "au",	"australia" },
    { "aw",	"aruba" },
    { "az",	"azerbaijan" },
    { "ba",	"bosnia and herzegovina" },
    { "bb",	"barbados" },
    { "bd",	"bangladesh" },
    { "be",	"belgium" },
    { "bf",	"burkina faso" },
    { "bg",	"bulgaria" },
    { "bh",	"bahrain" },
    { "bi",	"burundi" },
    { "bj",	"benin" },
    { "bm",	"bermuda" },
    { "bn",	"brunei darussalam" },
    { "bo",	"bolivia" },
    { "br",	"brazil" },
    { "bs",	"bahamas" },
    { "bt",	"bhutan" },
    { "bu",	"burma" },
    { "bv",	"bouvet island" },
    { "bw",	"botswana" },
    { "by",	"belarus" },
    { "bz",	"belize" },
    { "ca",	"canada" },
    { "cc",	"cocos (keeling) islands" },
    { "cf",	"central african republic" },
    { "cg",	"congo" },
    { "ch",	"switzerland" },
    { "ci",	"cote d'ivoire (ivory coast)" },
    { "ck",	"cook islands" },
    { "cl",	"chile" },
    { "cm",	"cameroon" },
    { "cn",	"china" },
    { "co",	"colombia" },
    { "cr",	"costa rica" },
    { "cs",	"czechoslovakia (former)" },
    { "ct",	"canton and enderbury island" },
    { "cu",	"cuba" },
    { "cv",	"cape verde" },
    { "cx",	"christmas island" },
    { "cy",	"cyprus" },
    { "cz",	"czech republic" },
    { "dd",	"german democratic republic" },
    { "de",	"germany" },
    { "dj",	"djibouti" },
    { "dk",	"denmark" },
    { "dm",	"dominica" },
    { "do",	"dominican republic" },
    { "dz",	"algeria" },
    { "ec",	"ecuador" },
    { "ee",	"estonia" },
    { "eg",	"egypt" },
    { "eh",	"western sahara" },
    { "er",	"eritrea" },
    { "es",	"spain" },
    { "et",	"ethiopia" },
    { "eu",	"european union" },
    { "fi",	"finland" },
    { "fj",	"fiji" },
    { "fk",	"falkland islands (malvinas)" },
    { "fm",	"micronesia" },
    { "fo",	"faroe islands" },
    { "fr",	"france" },
    { "fx",	"france, metropolitan" },
    { "ga",	"gabon" },
    { "gb",	"great britain (uk)" },
    { "gd",	"grenada" },
    { "ge",	"georgia" },
    { "gf",	"french guiana" },
    { "gh",	"ghana" },
    { "gi",	"gibraltar" },
    { "gl",	"greenland" },
    { "gm",	"gambia" },
    { "gn",	"guinea" },
    { "gp",	"guadeloupe" },
    { "gq",	"equatorial guinea" },
    { "gr",	"greece" },
    { "gs",	"s. georgia and s. sandwich isls." },
    { "gt",	"guatemala" },
    { "gu",	"guam" },
    { "gw",	"guinea-bissau" },
    { "gy",	"guyana" },
    { "hk",	"hong kong" },
    { "hm",	"heard and mcdonald islands" },
    { "hn",	"honduras" },
    { "hr",	"croatia (hrvatska)" },
    { "ht",	"haiti" },
    { "hu",	"hungary" },
    { "id",	"indonesia" },
    { "ie",	"ireland" },
    { "il",	"israel" },
    { "in",	"india" },
    { "io",	"british indian ocean territory" },
    { "iq",	"iraq" },
    { "ir",	"iran" },
    { "is",	"iceland" },
    { "it",	"italy" },
    { "jm",	"jamaica" },
    { "jo",	"jordan" },
    { "jp",	"japan" },
    { "jt",	"johnston island" },
    { "ke",	"kenya" },
    { "kg",	"kyrgyzstan" },
    { "kh",	"cambodia (democratic kampuchea)" },
    { "ki",	"kiribati" },
    { "km",	"comoros" },
    { "kn",	"saint kitts and nevis" },
    { "kp",	"korea (north)" },
    { "kr",	"korea (south)" },
    { "kw",	"kuwait" },
    { "ky",	"cayman islands" },
    { "kz",	"kazakhstan" },
    { "la",	"laos" },
    { "lb",	"lebanon" },
    { "lc",	"saint lucia" },
    { "li",	"liechtenstein" },
    { "lk",	"sri lanka" },
    { "lr",	"liberia" },
    { "ls",	"lesotho" },
    { "lt",	"lithuania" },
    { "lu",	"luxembourg" },
    { "lv",	"latvia" },
    { "ly",	"libya" },
    { "ma",	"morocco" },
    { "mc",	"monaco" },
    { "md",	"moldova" },
    { "mg",	"madagascar" },
    { "mh",	"marshall islands" },
    { "mi",	"midway islands" },
    { "mk",	"macedonia" },
    { "ml",	"mali" },
    { "mm",	"myanmar" },
    { "mn",	"mongolia" },
    { "mo",	"macau" },
    { "mp",	"northern mariana islands" },
    { "mq",	"martinique" },
    { "mr",	"mauritania" },
    { "ms",	"montserrat" },
    { "mt",	"malta" },
    { "mu",	"mauritius" },
    { "mv",	"maldives" },
    { "mw",	"malawi" },
    { "mx",	"mexico" },
    { "my",	"malaysia" },
    { "mz",	"mozambique" },
    { "na",	"namibia" },
    { "nc",	"new caledonia" },
    { "ne",	"niger" },
    { "nf",	"norfolk island" },
    { "ng",	"nigeria" },
    { "ni",	"nicaragua" },
    { "nl",	"netherlands" },
    { "no",	"norway" },
    { "np",	"nepal" },
    { "nq",	"dronning maud land" },
    { "nr",	"nauru" },
    { "nt",	"neutral zone" },
    { "nu",	"niue" },
    { "nz",	"new zealand (aotearoa)" },
    { "om",	"oman" },
    { "pa",	"panama" },
    { "pc",	"pacific islands" },
    { "pe",	"peru" },
    { "pf",	"french polynesia" },
    { "pg",	"papua new guinea" },
    { "ph",	"philippines" },
    { "pk",	"pakistan" },
    { "pl",	"poland" },
    { "pm",	"st. pierre and miquelon" },
    { "pn",	"pitcairn" },
    { "pr",	"puerto rico" },
    { "pu",	"united states misc. pacific islands" },
    { "pt",	"portugal" },
    { "pw",	"palau" },
    { "py",	"paraguay" },
    { "qa",	"qatar" },
    { "re",	"reunion" },
    { "ro",	"romania" },
    { "ru",	"russian federation" },
    { "rw",	"rwanda" },
    { "sa",	"saudi arabia" },
    { "sb",	"solomon islands" },
    { "sc",	"seychelles" },
    { "sd",	"sudan" },
    { "se",	"sweden" },
    { "sg",	"singapore" },
    { "sh",	"st. helena" },
    { "si",	"slovenia" },
    { "sj",	"svalbard and jan mayen islands" },
    { "sk",	"slovak republic" },
    { "sl",	"sierra leone" },
    { "sm",	"san marino" },
    { "sn",	"senegal" },
    { "so",	"somalia" },
    { "sr",	"suriname" },
    { "st",	"sao tome and principe" },
    { "su",	"ussr (former)" },
    { "sv",	"el salvador" },
    { "sy",	"syria" },
    { "sz",	"swaziland" },
    { "tc",	"turks and caicos islands" },
    { "td",	"chad" },
    { "tf",	"french southern territories" },
    { "tg",	"togo" },
    { "th",	"thailand" },
    { "tj",	"tajikistan" },
    { "tk",	"tokelau" },
    { "tm",	"turkmenistan" },
    { "tn",	"tunisia" },
    { "to",	"tonga" },
    { "tp",	"east timor" },
    { "tr",	"turkey" },
    { "tt",	"trinidad and tobago" },
    { "tv",	"tuvalu" },
    { "tw",	"taiwan" },
    { "tz",	"tanzania" },
    { "ua",	"ukraine" },
    { "ug",	"uganda" },
    { "uk",	"united kingdom" },
    { "um",	"us minor outlying islands" },
    { "us",	"united states" },
    { "uy",	"uruguay" },
    { "uz",	"uzbekistan" },
    { "va",	"vatican city state (holy see)" },
    { "vc",	"saint vincent and the grenadines" },
    { "ve",	"venezuela" },
    { "vg",	"virgin islands (british)" },
    { "vi",	"virgin islands (u.s.)" },
    { "vn",	"viet nam" },
    { "vu",	"vanuatu" },
    { "wf",	"wallis and futuna islands" },
    { "wk",	"wake island" },
    { "ws",	"samoa" },
    { "yd",	"democratic yemen" },
    { "ye",	"yemen" },
    { "yt",	"mayotte" },
    { "yu",	"yugoslavia" },
    { "za",	"south africa" },
    { "zm",	"zambia" },
    { "zr",	"zaire" },
    { "zw",	"zimbabwe" },

    {"gov", "gov"},
    {"mil", "mil"},

    { 0, 0 }
};
@

<<global [[classdebug]]>>=
int classdebug;
@

<<function [[incountries]]>>=
static int
incountries(char *s, Country *cp)
{
    for(; cp->code != 0; cp++)
        if(cistrcmp(s, cp->code) == 0
        || cistrcmp(s, cp->name) == 0)
            return 1;
    return 0;
}
@

<<function [[indomains]]>>=
static int
indomains(char *s, char **dp)
{
    for(; *dp != nil; dp++)
        if(cistrcmp(s, *dp) == 0)
            return 1;

    return 0;
}
@

<<function [[classify]]>>=
int
classify(char *ip, Ndbtuple *t)
{
    int isgov, iscountry, isbadc, isgoodc;
    char dom[256];
    char *df[128];
    Ndbtuple *nt, *x;
    int n;

    isgov = iscountry = isbadc = 0;
    isgoodc = 1;
    
    for(nt = t; nt != nil; nt = nt->entry){
        if(strcmp(nt->attr, "country") == 0){
            iscountry = 1;
            if(incountries(nt->val, badc)){
                if(classdebug)fprint(2, "isbadc\n");
                isbadc = 1;
                isgoodc = 0;
            } else if(!incountries(nt->val, goodc)){
                if(classdebug)fprint(2, "!isgoodc\n");
                isgoodc = 0;
            }
        }

        /* domain names can always hurt, even without forward verification */
        if(strcmp(nt->attr, "dom") == 0){
            strncpy(dom, nt->val, sizeof dom);
            dom[sizeof(dom)-1] = 0;
            n = getfields(dom, df, nelem(df), 0, ".");

            /* a bad country in a domain name is always believed */
            if(incountries(df[n-1], badc)){
                if(classdebug)fprint(2, "isbadc dom\n");
                isbadc = 1;
                isgoodc = 0;
            }

            /* a goverment in a domain name is always believed */
            if(n > 1 && indomains(df[n-2], gov))
                isgov = 1;
        }
    }
    if(iscountry == 0){
        /* did the forward lookup work? */
        for(nt = t; nt != nil; nt = nt->entry){
            if(strcmp(nt->attr, "ip") == 0 && strcmp(nt->val, ip) == 0)
                break;
        }

        /* see if the domain name ends in a country code */
        if(nt != nil && (x = ndbfindattr(t, nt, "dom")) != nil){
            strncpy(dom, x->val, sizeof dom);
            dom[sizeof(dom)-1] = 0;
            n = getfields(dom, df, nelem(df), 0, ".");
            if(incountries(df[n-1], allc))
                iscountry = 1;
        }
    }
    if(iscountry == 0)
        return Cunknown;
    if(isbadc)
        return Cbadc;
    if(!isgoodc && isgov)
        return Cbadgov;
    return Cok;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/classify.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>
#include "whois.h"

typedef struct Country Country;

<<struct [[Country]]>>

<<global [[badc]]>>

<<global [[goodc]]>>

<<global [[gov]]>>

<<global [[allc]]>>

<<global [[classdebug]]>>

<<function [[incountries]]>>

<<function [[indomains]]>>

<<function [[classify]]>>
@


\subsection*{[[networking/ip/httpd/content.c]]}

<<struct [[Suffix]]>>=
struct Suffix 
{
    Suffix	*next;
    char	*suffix;
    char	*generic;
    char	*specific;
    char	*encoding;
};
@

<<global [[suffixes]]>>=
Suffix	*suffixes = nil;
@

<<function [[updateQid]]>>=
int
updateQid(int fd, Qid *q)
{
    Dir *dir;
    Qid dq;

    dir = dirfstat(fd);
    if(dir == nil)
        sysfatal("can't dirfstat");
    dq = dir->qid;
    free(dir);
    if(q->path == dq.path && q->vers == dq.vers && q->type == dq.type)
        return 0;
    *q = dq;
    return 1;
}
@

<<function [[contentinit]]>>=
void
contentinit(void)
{
    static Biobuf *b = nil;
    static Qid qid;
    char *file, *s;
    Suffix *this;

    file = "/sys/lib/mimetype";
    if(b == nil){ /* first time */
        b = Bopen(file, OREAD);
        if(b == nil)
            sysfatal("can't read from %s", file);
    }
    if(updateQid(Bfildes(b), &qid) == 0)
        return;
    Bseek(b, 0, 0);
    while(suffixes!=nil){
        this = suffixes;
        suffixes = suffixes->next;
        free(this->suffix);
        free(this->generic);
        free(this->specific);
        free(this->encoding);
        free(this);
    }

    while((s = Brdline(b, '\n')) != nil){
        s[Blinelen(b) - 1] = 0;
        suffixes = parsesuffix(s, suffixes);
    }
}
@

<<function [[parsesuffix]]>>=
static Suffix*
parsesuffix(char *line, Suffix *suffix)
{
    Suffix *s;
    char *p, *fields[5];
    int i, nf;

    p = strchr(line, '#');
    if(p != nil)
        *p = '\0';
    nf = tokenize(line, fields, 5);
    for(i = 0; i < 4; i++)
        if(i >= nf || fields[i][0] == '-')
            fields[i] = nil;

    if(fields[2] == nil)
        fields[1] = nil;
    if(fields[1] == nil && fields[3] == nil)
        return suffix;
    if(fields[0] == nil)
        return suffix;

    s = ezalloc(sizeof *s);
    s->next = suffix;
    s->suffix = estrdup(fields[0]);
    if(fields[1] != nil){
        s->generic = estrdup(fields[1]);
        s->specific = estrdup(fields[2]);
    }
    if(fields[3] != nil)
        s->encoding = estrdup(fields[3]);
    return s;
}
@

<<function [[uriclass]]>>=
/*
 * classify by file name extensions
 */
HContents
uriclass(HConnect *hc, char *name)
{
    HContents conts;
    Suffix *s;
    HContent *type, *enc;
    char *buf, *p;

    type = nil;
    enc = nil;
    if((p = strrchr(name, '/')) != nil)
        name = p + 1;
    buf = hstrdup(hc, name);
    while((p = strrchr(buf, '.')) != nil){
        for(s = suffixes; s; s = s->next){
            if(strcmp(p, s->suffix) == 0){
                if(s->generic != nil && type == nil)
                    type = hmkcontent(hc, s->generic, s->specific, nil);
                if(s->encoding != nil && enc == nil)
                    enc = hmkcontent(hc, s->encoding, nil, nil);
            }
        }
        *p = 0;
    }
    conts.type = type;
    conts.encoding = enc;
    return conts;
}
@

<<function [[dataclass]]>>=
/*
 * classify by initial contents of file
 */
HContents
dataclass(HConnect *hc, char *buf, int n)
{
    HContents conts;
    Rune r;
    int c, m;

    for(; n > 0; n -= m){
        c = *buf;
        if(c < Runeself){
            if(c < 32 && c != '\n' && c != '\r' && c != '\t' && c != '\v'){
                conts.type = nil;
                conts.encoding = nil;
                return conts;
            }
            m = 1;
        }else{
            m = chartorune(&r, buf);
            if(r == Runeerror){
                conts.type = nil;
                conts.encoding = nil;
                return conts;
            }
        }
        buf += m;
    }
    conts.type = hmkcontent(hc, "text", "plain", nil);
    conts.encoding = nil;
    return conts;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/content.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

typedef struct Suffix	Suffix;
<<struct [[Suffix]]>>

<<global [[suffixes]]>>

static	Suffix*			parsesuffix(char*, Suffix*);
static	char*			skipwhite(char*);
static	HContents		suffixclass(char*);
static	char*			towhite(char*);

<<function [[updateQid]]>>

<<function [[contentinit]]>>

<<function [[parsesuffix]]>>

<<function [[uriclass]]>>

<<function [[dataclass]]>>
@


\subsection*{[[networking/ip/httpd/emem.c]]}

<<function [[ezalloc]]>>=
void*
ezalloc(ulong n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        sysfatal("out of memory");
    memset(p, 0, n);
    return p;
}
@

<<function [[estrdup]]([[(networking/ip/httpd/emem.c)]])>>=
char*
estrdup(char *s)
{
    s = strdup(s);
    if(s == nil)
        sysfatal("out of memory");
    return s;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/emem.c>>=
#include <u.h>
#include <libc.h>
#include "httpd.h"

<<function [[ezalloc]]>>

<<function [[estrdup]]([[(networking/ip/httpd/emem.c)]])>>

@


\subsection*{[[networking/ip/httpd/hints.c]]}

<<enum [[_anon_ (networking/ip/httpd/hints.c)]]>>=
enum{ URLmax = 65536, HINTmax = 20 };
@

<<constant [[RECIPLOG2]]>>=
#define RECIPLOG2 1.44269504089
@

<<global [[urlname]]>>=
char **urlname;				/* array of url strings    1,...,nurl */
@

<<global [[nurl]]>>=
static int nurl;
@

<<global [[urltab]]>>=
static uint urltab[URLmax];		/* hashstr(url)  1,...,nurl */
@

<<global [[urlnext]]>>=
static int urlnext[URLmax];		/* index urltab of next url in chain */
@

<<global [[urlhash]]>>=
static int urlhash[URLmax];		/* initially 0, meaning empty buckets */
@

<<struct [[Hint]]>>=
typedef struct Hint {
    ushort url;
    uchar prob;
} Hint;
@

<<global [[hints]]>>=
Hint *hints[URLmax];
@

<<global [[nhint]]>>=
uchar nhint[URLmax];
@

<<function [[Bfilelen]]>>=
vlong
Bfilelen(void *vb)
{
    Biobuf *b;
    vlong n;

    b = vb;
    n = Bseek(b, 0L, 2);
    Bseek(b, 0L, 0);
    return n;
}
@

<<function [[hashstr]]>>=
static uint 
hashstr(char* key)
{
    /* asu works better than pjw for urls */
    uchar *k = (unsigned char*)key;
    uint h = 0;
    while(*k!=0)
        h = 65599*h + *k++;
        return h;
}
@

<<function [[urllookup]]>>=
static int
urllookup(uint url)
{
    /* returns +index into urltab, else -hash */
    int j, hash;

    hash = 1 + url%(URLmax-1);
    j = urlhash[hash];
    for(;;){
        if(j==0)
            return -hash;
        if(url==urltab[j])
            return j;
        j = urlnext[j];
    }
}
@

<<function [[Bage]]>>=
int
Bage(Biobuf *b)
{
    Dir *dir;
    long mtime;

    dir = dirfstat(Bfildes(b));
    if(dir != nil)
        mtime = dir->mtime;
    else
        mtime = 0;
    free(dir);
    return time(nil) - mtime;
}
@

<<function [[urlinit]]>>=
void
urlinit(void)
{
    static Biobuf *b = nil;
    static vlong filelen = 0;
    vlong newlen;
    char *s, *arena;
    int i, j, n;
    uint url;
    char *file;

    if(filelen < 0)
        return;
    file = "/sys/log/httpd/url";
    if(b == nil){
        b = Bopen(file, OREAD); /* first time */
        if(b == nil){
            syslog(0, HTTPLOG, "no %s, abandon prefetch hints", file);
            filelen = -1;
            return;
        }
    }
    newlen = Bfilelen(b); /* side effect: rewinds b */
    if(newlen == filelen || Bage(b)<300)
        return;
    filelen = newlen;
    if(filelen < 0)
        return;
    if(nurl){ /* free existing tables */
        free(urlname[0]); /* arena */
        memset(urlhash,0,sizeof urlhash);
        memset(urlnext,0,sizeof urlnext);
        nurl = 0;
    }
    if(urlname==nil)
        urlname = (char**)ezalloc(URLmax*sizeof(*urlname));
    arena = (char*)ezalloc(filelen);  /* enough for all the strcpy below */
    i = 1;
    while((s=Brdline(b,'\n'))!=0){
        /* read lines of the form:  999 /url/path */
        n = Blinelen(b) - 1;
        if(n>2 && s[n]=='\n'){
            s[n] = '\0';
        }else{
            sysfatal("missing fields or newline in url-db");
        }
        j = strtoul(s,&s,10);
        while(*s==' ')
            s++;
        if(i++!=j)
            sysfatal("url-db synchronization error");
        url = hashstr(s);
        j = urllookup(url);
        if(j>=0)
            sysfatal("duplicate url");
        j = -j;
        nurl++;
        if(nurl>=URLmax){
            syslog(0, HTTPLOG, "urlinit overflow at %s",s);
            free(urlname[0]); /* arena */
            memset(urlhash,0,sizeof urlhash);
            memset(urlnext,0,sizeof urlnext);
            nurl = 0;
            return;
        }
        urltab[nurl] = url;
        urlnext[nurl] = urlhash[j];
        urlhash[j] = nurl;
        strcpy(arena,s);
        urlname[nurl] = arena;
        arena += strlen(s)+1;
    }
    syslog(0, HTTPLOG, "prefetch-hints url=%d (%.1fMB)", nurl, 1.e-6*(URLmax*sizeof(*urlname)+filelen));
    /* b is held open, because namespace will be chopped */
}
@

<<function [[statsinit]]>>=
void
statsinit(void)
{
    static Biobuf *b = nil;
    static vlong filelen = 0;
    vlong newlen;
    int iq, n, i, nstats = 0;
    uchar *s, buf[3+HINTmax*3];  /* iq, n, (url,prob)... */
    Hint *arena, *h;
    char *file;
    static void *oldarena = nil;

    file = "/sys/log/httpd/pathstat";
    if(b == nil){
        if(filelen == -1)
            return; /* if failed first time */
        b = Bopen(file, OREAD); /* first time */
        if(b == nil){
            syslog(0, HTTPLOG, "no %s, abandon prefetch hints", file);
            filelen = -1;
            return;
        }
    }
    newlen = Bfilelen(b); /* side effect: rewinds b */
    if(newlen == filelen || Bage(b)<300)
        return;
    filelen = newlen;
    if(oldarena){
        free(oldarena);
        memset(nhint,0,sizeof nhint);
    }
    arena = (Hint*)ezalloc((filelen/3)*sizeof(Hint));
    oldarena = arena;
    for(;;){
        i = Bread(b,buf,3);
        if(i<3)
            break;
        nstats++;
        iq = buf[0];
        iq = (iq<<8) | buf[1];
        n = buf[2];
        h = arena;
        arena += n;
        hints[iq] = h;
        nhint[iq] = n;
        if(Bread(b,buf,3*n)!=3*n)
            sysfatal("stats read error");
        for(i=0; i<n; i++){
            s = &buf[3*i];
            h[i].url = (s[0]<<8) | s[1];
            h[i].prob = s[2];
        }
    }
    syslog(0, HTTPLOG, "prefetch-hints stats=%d (%.1fMB)", nstats, 1.e-6*((filelen/3)*sizeof(Hint)));
}
@

<<function [[urlcanon]]>>=
void
urlcanon(char *url)
{
    /* all the changes here can be implemented by rewriting in-place */
    char *p, *q;

    /* remove extraneous '/' in the middle and at the end */
    p = url+1;  /* first char needs no change */
    q = p;
    while(q[0]){
        if(q[0]=='/' && q[-1]=='/'){
            q++;
            continue;
        }
        *p++ = *q++;
    }
    if(q[-1]=='/'){  /* trailing '/' */
        p[-1] = '\0';
    }else{
        p[0] = '\0';
    }

    /* specific to the cm.bell-labs.com web site */
    if(strncmp(url,"/cm/",4)==0){
        if(strchr("cims",url[4]) && strncmp(url+5,"s/who/",6)==0)
            /* strip off /cm/cs */
            memmove(url,url+6,strlen(url+6)+1);
        else if(strncmp(url+4,"ms/what/wavelet",15)==0)
            /* /cm/ms/what */
            memmove(url,url+11,strlen(url+11)+1);
    }
}
@

<<function [[hintprint]]>>=
void
hintprint(HConnect *hc, Hio *hout, char *uri, int thresh, int havej)
{
    int i, j, pr, prefix, fd, siz, havei, newhint = 0, n;
    char *query, *sf, etag[32], *wurl;
    Dir *dir;
    Hint *h, *haveh;

    query = hstrdup(hc, uri);
    urlcanon(query);
    j = urllookup(hashstr(query));
    if(j < 0)
        return;
    query = strrchr(uri,'/');
    if(!query)
        return;  /* can't happen */
    prefix = query-uri+1;  /* = strlen(dirname)+1 */
    h = hints[j];
    for(i=0; i<nhint[j]; i++){
        if(havej > 0 && havej < URLmax){ /* exclude hints client has */
            haveh = hints[havej];
            for(havei=0; havei<nhint[havej]; havei++)
                if( haveh[havei].url == h[i].url)
                    goto continuei;
        }
        sf = urlname[h[i].url];
        pr = h[i].prob;
        if(pr<thresh)
            break;
        n = strlen(webroot) + strlen(sf) + 1;
        wurl = halloc(hc, n);
        strcpy(wurl, webroot);
        strcat(wurl, sf);
        fd = open(wurl, OREAD);
        if(fd<0)
            continue;
        dir = dirfstat(fd);
        if(dir == nil){
            close(fd);
            continue;
        }
        close(fd);
        snprint(etag, sizeof(etag), "\"%lluxv%lux\"", dir->qid.path, dir->qid.vers);
        siz = (int)( log((double)dir->length) * RECIPLOG2 + 0.9999);
        free(dir);
        if(strncmp(uri,sf,prefix)==0 && strchr(sf+prefix,'/')==0 && sf[prefix]!=0)
            sf = sf+prefix;
        hprint(hout, "Fresh: %d,%s,%d,%s\r\n", pr, etag, siz, sf);
        newhint++;
continuei: ;
    }
    if(newhint)
        hprint(hout, "Fresh: have/%d\r\n", j);
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/hints.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

<<enum [[_anon_ (networking/ip/httpd/hints.c)]]>>
<<constant [[RECIPLOG2]]>>

<<global [[urlname]]>>
<<global [[nurl]]>>
<<global [[urltab]]>>
<<global [[urlnext]]>>
<<global [[urlhash]]>>

<<struct [[Hint]]>>
<<global [[hints]]>>
<<global [[nhint]]>>

<<function [[Bfilelen]]>>

<<function [[hashstr]]>>

<<function [[urllookup]]>>

<<function [[Bage]]>>

<<function [[urlinit]]>>

<<function [[statsinit]]>>

<<function [[urlcanon]]>>

<<function [[hintprint]]>>

@


\subsection*{[[networking/ip/httpd/httpd.c]]}

<<enum [[_anon_ (networking/ip/httpd/httpd.c)]]>>=
enum {
    Nbuckets	= 256,
};
@

<<struct [[Strings]]>>=
struct Strings
{
    char	*s1;
    char	*s2;
};
@

<<struct [[System]]>>=
struct System {
    char	*rsys;
    ulong	reqs;
    ulong	first;
    ulong	last;
    System	*next;			/* next in chain */
};
@

<<global [[netdir]]([[(networking/ip/httpd/httpd.c)]])>>=
char	*netdir;
@

<<global [[HTTPLOG]]>>=
char	*HTTPLOG = "httpd/log";
@

<<global [[netdirb]]>>=
static	char		netdirb[256];
@

<<global [[namespace]]([[(networking/ip/httpd/httpd.c)]])>>=
static	char		*namespace;
@

<<global [[syss]]>>=
static	System		syss[Nbuckets];
@

<<global [[certificate]]>>=
uchar *certificate;
@

<<global [[certlen]]>>=
int certlen;
@

<<global [[certchain]]>>=
PEMChain *certchain;	
@

<<function [[usage]]([[(networking/ip/httpd/httpd.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: httpd [-c certificate] [-C CAchain] [-a srvaddress] "
        "[-d domain] [-n namespace] [-w webroot]\n");
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/httpd/httpd.c)]])>>=
void
main(int argc, char **argv)
{
    char *address;

    namespace = nil;
    address = nil;
    hmydomain = nil;
    netdir = "/net";
    fmtinstall('D', hdatefmt);
    fmtinstall('H', httpfmt);
    fmtinstall('U', hurlfmt);
    ARGBEGIN{
    case 'c':
        certificate = readcert(EARGF(usage()), &certlen);
        if(certificate == nil)
            sysfatal("reading certificate: %r");
        break;
    case 'C':
        certchain = readcertchain(EARGF(usage()));
        if (certchain == nil)
            sysfatal("reading certificate chain: %r");
        break;
    case 'n':
        namespace = EARGF(usage());
        break;
    case 'a':
        address = EARGF(usage());
        break;
    case 'd':
        hmydomain = EARGF(usage());
        break;
    case 'w':
        webroot = EARGF(usage());
        break;
    default:
        usage();
        break;
    }ARGEND

    if(argc)
        usage();

    if(namespace == nil)
        namespace = "/lib/namespace.httpd";
    if(address == nil)
        address = "*";
    if(webroot == nil)
        webroot = "/usr/web";
    else{
        cleanname(webroot);
        if(webroot[0] != '/')
            webroot = "/usr/web";
    }

    switch(rfork(RFNOTEG|RFPROC|RFFDG|RFNAMEG)) {
    case -1:
        sysfatal("fork");
    case 0:
        break;
    default:
        exits(nil);
    }

    /*
     * open all files we might need before castrating namespace
     */
    time(nil);
    if(hmydomain == nil)
        hmydomain = sysdom();
    syslog(0, HTTPLOG, nil);
    logall[0] = open("/sys/log/httpd/0", OWRITE);
    logall[1] = open("/sys/log/httpd/1", OWRITE);
    logall[2] = open("/sys/log/httpd/clf", OWRITE);
    redirectinit();
    contentinit();
    urlinit();
    statsinit();

    becomenone(namespace);
    dolisten(netmkaddr(address, "tcp", certificate == nil ? "http" : "https"));
    exits(nil);
}
@

<<function [[becomenone]]>>=
static void
becomenone(char *namespace)
{
    int fd;

    fd = open("#c/user", OWRITE);
    if(fd < 0 || write(fd, "none", strlen("none")) < 0)
        sysfatal("can't become none");
    close(fd);
    if(newns("none", nil) < 0)
        sysfatal("can't build normal namespace");
    if(addns("none", namespace) < 0)
        sysfatal("can't build httpd namespace");
}
@

<<function [[mkconnect]]>>=
static HConnect*
mkconnect(char *scheme, char *port)
{
    HConnect *c;

    c = ezalloc(sizeof(HConnect));
    c->hpos = c->header;
    c->hstop = c->header;
    c->replog = writelog;
    c->scheme = scheme;
    c->port = port;
    return c;
}
@

<<function [[mkhspriv]]>>=
static HSPriv*
mkhspriv(void)
{
    HSPriv *p;

    p = ezalloc(sizeof(HSPriv));
    return p;
}
@

<<function [[hashstr]]([[(networking/ip/httpd/httpd.c)]])>>=
static uint 
hashstr(char* key)
{
    /* asu works better than pjw for urls */
    uchar *k = (unsigned char*)key;
    uint h = 0;

    while(*k!=0)
        h = 65599*h + *k++;
        return h;
}
@

<<function [[hashsys]]>>=
static System *
hashsys(char *rsys)
{
    int notme;
    System *sys;

    sys = syss + hashstr(rsys) % nelem(syss);
    /* if the bucket is empty, just use it, else find or allocate ours */
    if(sys->rsys != nil) {
        /* find match or chain end */
        for(; notme = (strcmp(sys->rsys, rsys) != 0) &&
            sys->next != nil; sys = sys->next)
            ;
        if(notme) {
            sys->next = malloc(sizeof *sys);  /* extend chain */
            sys = sys->next;
        } else
            return sys;
    }
    if(sys != nil) {
        memset(sys, 0, sizeof *sys);
        sys->rsys = strdup(rsys);
    }
    return sys;
}
@

<<function [[isswamped]]>>=
/*
 * be sure to call this at least once per listen in the parent,
 * to update the hash chains.
 * it's okay to call it in the child too, but then sys->reqs only gets
 * updated in the child.
 */
static int
isswamped(char *rsys)
{
    ulong period;
    System *sys = hashsys(rsys);

    if(sys == nil)
        return 0;
    sys->last = time(nil);
    if(sys->first == 0)
        sys->first = sys->last;
    period = sys->first - sys->last;
    return ++sys->reqs > 30 && period > 30 && sys->reqs / period >= 2;
}
@

<<function [[throttle]]>>=
/* must only be called in child */
static void
throttle(int nctl, NetConnInfo *nci, int swamped)
{
    if(swamped || isswamped(nci->rsys)) {		/* shed load */
        syslog(0, HTTPLOG, "overloaded by %s", nci->rsys);
        sleep(30);
        close(nctl);
        exits(nil);
    }
}
@

<<function [[dolisten]]>>=
static void
dolisten(char *address)
{
    HSPriv *hp;
    HConnect *c;
    NetConnInfo *nci;
    char ndir[NETPATHLEN], dir[NETPATHLEN], *p, *scheme;
    int ctl, nctl, data, t, ok, spotchk, swamped;
    TLSconn conn;

    spotchk = 0;
    syslog(0, HTTPLOG, "httpd starting");
    ctl = announce(address, dir);
    if(ctl < 0){
        syslog(0, HTTPLOG, "can't announce on %s: %r", address);
        return;
    }
    strcpy(netdirb, dir);
    p = nil;
    if(netdir[0] == '/'){
        p = strchr(netdirb+1, '/');
        if(p != nil)
            *p = '\0';
    }
    if(p == nil)
        strcpy(netdirb, "/net");
    netdir = netdirb;

    for(;;){

        /*
         *  wait for a call (or an error)
         */
        nctl = listen(dir, ndir);
        if(nctl < 0){
            syslog(0, HTTPLOG, "can't listen on %s: %r", address);
            syslog(0, HTTPLOG, "ctls = %d", ctl);
            return;
        }
        swamped = 0;
        nci = getnetconninfo(ndir, -1);
        if (nci)
            swamped = isswamped(nci->rsys);

        /*
         *  start a process for the service
         */
        switch(rfork(RFFDG|RFPROC|RFNOWAIT|RFNAMEG)){
        case -1:
            close(nctl);
            continue;
        case 0:
            /*
             *  see if we know the service requested
             */
            data = accept(ctl, ndir);
            if(data >= 0 && certificate != nil){
                memset(&conn, 0, sizeof(conn));
                conn.cert = certificate;
                conn.certlen = certlen;
                if (certchain != nil)
                    conn.chain = certchain;
                data = tlsServer(data, &conn);
                scheme = "https";
            }else
                scheme = "http";
            if(data < 0){
                syslog(0, HTTPLOG, "can't open %s/data: %r", ndir);
                exits(nil);
            }
            dup(data, 0);
            dup(data, 1);
            dup(data, 2);
            close(data);
            close(ctl);
            close(nctl);

            if (nci == nil)
                nci = getnetconninfo(ndir, -1);
            c = mkconnect(scheme, nci->lserv);
            hp = mkhspriv();
            hp->remotesys = nci->rsys;
            hp->remoteserv = nci->rserv;
            c->private = hp;

            hinit(&c->hin, 0, Hread);
            hinit(&c->hout, 1, Hwrite);

            /*
             * serve requests until a magic request.
             * later requests have to come quickly.
             * only works for http/1.1 or later.
             */
            for(t = 15*60*1000; ; t = 15*1000){
                throttle(nctl, nci, swamped);
                if(hparsereq(c, t) <= 0)
                    exits(nil);
                ok = doreq(c);

                hflush(&c->hout);

                if(c->head.closeit || ok < 0)
                    exits(nil);

                hreqcleanup(c);
            }
            /* not reached */

        default:
            close(nctl);
            break;
        }

        if(++spotchk > 50){
            spotchk = 0;
            redirectinit();
            contentinit();
            urlinit();
            statsinit();
        }
    }
}
@

<<function [[doreq]]>>=
static int
doreq(HConnect *c)
{
    HSPriv *hp;
    Strings ss;
    char *magic, *uri, *newuri, *origuri, *newpath, *hb;
    char virtualhost[100], logfd0[10], logfd1[10], vers[16];
    int n, nredirect;
    uint flags;

    /*
     * munge uri for magic
     */
    uri = c->req.uri;
    nredirect = 0;
    werrstr("");
top:
    if(++nredirect > 10){
        if(hparseheaders(c, 15*60*1000) < 0)
            exits("failed");
        werrstr("redirection loop");
        return hfail(c, HNotFound, uri);
    }
    ss = stripmagic(c, uri);
    uri = ss.s1;
    origuri = uri;
    magic = ss.s2;
    if(magic)
        goto magic;

    /*
     * Apply redirects.  Do this before reading headers
     * (if possible) so that we can redirect to magic invisibly.
     */
    flags = 0;
    if(origuri[0]=='/' && origuri[1]=='~'){
        n = strlen(origuri) + 4 + UTFmax;
        newpath = halloc(c, n);
        snprint(newpath, n, "/who/%s", origuri+2);
        c->req.uri = newpath;
        newuri = newpath;
    }else if(origuri[0]=='/' && origuri[1]==0){
        /* can't redirect / until we read the headers below */
        newuri = nil;
    }else
        newuri = redirect(c, origuri, &flags);

    if(newuri != nil){
        if(flags & Redirsilent) {
            c->req.uri = uri = newuri;
            logit(c, "%s: silent replacement %s", origuri, uri);
            goto top;
        }
        if(hparseheaders(c, 15*60*1000) < 0)
            exits("failed");
        if(flags & Redirperm) {
            logit(c, "%s: permanently moved to %s", origuri, newuri);
            return hmoved(c, newuri);
        } else if (flags & (Redironly | Redirsubord))
            logit(c, "%s: top-level or many-to-one replacement %s",
                origuri, uri);

        /*
         * try temporary redirect instead of permanent
         */
        if (http11(c))
            return hredirected(c, "307 Temporary Redirect", newuri);
        else
            return hredirected(c, "302 Temporary Redirect", newuri);
    }

    /*
     * for magic we exec a new program and serve no more requests
     */
magic:
    if(magic != nil && strcmp(magic, "httpd") != 0){
        snprint(c->xferbuf, HBufSize, "/bin/ip/httpd/%s", magic);
        snprint(logfd0, sizeof(logfd0), "%d", logall[0]);
        snprint(logfd1, sizeof(logfd1), "%d", logall[1]);
        snprint(vers, sizeof(vers), "HTTP/%d.%d", c->req.vermaj, c->req.vermin);
        hb = hunload(&c->hin);
        if(hb == nil){
            hfail(c, HInternal);
            return -1;
        }
        hp = c->private;
        execl(c->xferbuf, magic, "-d", hmydomain, "-w", webroot,
            "-s", c->scheme, "-p", c->port,
            "-r", hp->remotesys, "-N", netdir, "-b", hb,
            "-L", logfd0, logfd1, "-R", c->header,
            c->req.meth, vers, uri, c->req.search, nil);
        logit(c, "no magic %s uri %s", magic, uri);
        hfail(c, HNotFound, uri);
        return -1;
    }

    /*
     * normal case is just file transfer
     */
    if(hparseheaders(c, 15*60*1000) < 0)
        exits("failed");
    if(origuri[0] == '/' && origuri[1] == 0){	
        snprint(virtualhost, sizeof virtualhost, "http://%s/", c->head.host);
        newuri = redirect(c, virtualhost, nil);
        if(newuri == nil)
            newuri = redirect(c, origuri, nil);
        if(newuri)
            return hmoved(c, newuri);
    }
    if(!http11(c) && !c->head.persist)
        c->head.closeit = 1;
    return send(c);
}
@

<<function [[send]]([[(networking/ip/httpd/httpd.c)]])>>=
static int
send(HConnect *c)
{
    Dir *dir;
    char *w, *w2, *p, *masque;
    int fd, fd1, n, force301, ok;

/*
    if(c->req.search)
        return hfail(c, HNoSearch, c->req.uri);
 */
    if(strcmp(c->req.meth, "GET") != 0 && strcmp(c->req.meth, "HEAD") != 0)
        return hunallowed(c, "GET, HEAD");
    if(c->head.expectother || c->head.expectcont)
        return hfail(c, HExpectFail);

    masque = masquerade(c->head.host);

    /*
     * check for directory/file mismatch with trailing /,
     * and send any redirections.
     */
    n = strlen(webroot) + strlen(masque) + strlen(c->req.uri) +
        STRLEN("/index.html") + STRLEN("/.httplogin") + 1;
    w = halloc(c, n);
    strcpy(w, webroot);
    strcat(w, masque);
    strcat(w, c->req.uri);

    /*
     *  favicon can be overridden by hostname.ico
     */
    if(strcmp(c->req.uri, "/favicon.ico") == 0){
        w2 = halloc(c, n+strlen(c->head.host)+2);
        strcpy(w2, webroot);
        strcat(w2, masque);
        strcat(w2, "/");
        strcat(w2, c->head.host);
        strcat(w2, ".ico");
        if(access(w2, AREAD)==0)
            w = w2;
    }

    /*
     * don't show the contents of .httplogin
     */
    n = strlen(w);
    if(strcmp(w+n-STRLEN(".httplogin"), ".httplogin") == 0)
        return notfound(c, c->req.uri);

    fd = open(w, OREAD);
    if(fd < 0 && strlen(masque)>0 && strncmp(c->req.uri, masque, strlen(masque)) == 0){
        // may be a URI from before virtual hosts;  try again without masque
        strcpy(w, webroot);
        strcat(w, c->req.uri);
        fd = open(w, OREAD);
    }
    if(fd < 0)
        return notfound(c, c->req.uri);
    dir = dirfstat(fd);
    if(dir == nil){
        close(fd);
        return hfail(c, HInternal);
    }
    p = strchr(w, '\0');
    if(dir->mode & DMDIR){
        free(dir);
        if(p > w && p[-1] == '/'){
            strcat(w, "index.html");
            force301 = 0;
        }else{
            strcat(w, "/index.html");
            force301 = 1;
        }
        fd1 = open(w, OREAD);
        if(fd1 < 0){
            close(fd);
            return notfound(c, c->req.uri);
        }
        c->req.uri = w + strlen(webroot) + strlen(masque);
        if(force301 && c->req.vermaj){
            close(fd);
            close(fd1);
            return hmoved(c, c->req.uri);
        }
        close(fd);
        fd = fd1;
        dir = dirfstat(fd);
        if(dir == nil){
            close(fd);
            return hfail(c, HInternal);
        }
    }else if(p > w && p[-1] == '/'){
        free(dir);
        close(fd);
        *strrchr(c->req.uri, '/') = '\0';
        return hmoved(c, c->req.uri);
    }

    ok = authorize(c, w);
    if(ok <= 0){
        free(dir);
        close(fd);
        return ok;
    }

    return sendfd(c, fd, dir, nil, nil);
}
@

<<function [[stripmagic]]>>=
static Strings
stripmagic(HConnect *hc, char *uri)
{
    Strings ss;
    char *newuri, *prog, *s;

    prog = stripprefix("/magic/", uri);
    if(prog == nil){
        ss.s1 = uri;
        ss.s2 = nil;
        return ss;
    }

    s = strchr(prog, '/');
    if(s == nil)
        newuri = "";
    else{
        newuri = hstrdup(hc, s);
        *s = 0;
        s = strrchr(s, '/');
        if(s != nil && s[1] == 0)
            *s = 0;
    }
    ss.s1 = newuri;
    ss.s2 = prog;
    return ss;
}
@

<<function [[stripprefix]]>>=
static char*
stripprefix(char *pre, char *str)
{
    while(*pre)
        if(*str++ != *pre++)
            return nil;
    return str;
}
@

<<function [[notfound]]>>=
/*
 * couldn't open a file
 * figure out why and return and error message
 */
static int
notfound(HConnect *c, char *url)
{
    c->xferbuf[0] = 0;
    rerrstr(c->xferbuf, sizeof c->xferbuf);
    if(strstr(c->xferbuf, "file does not exist") != nil)
        return hfail(c, HNotFound, url);
    if(strstr(c->xferbuf, "permission denied") != nil)
        return hfail(c, HUnauth, url);
    return hfail(c, HNotFound, url);
}
@

<<function [[sysdom]]>>=
static char*
sysdom(void)
{
    char *dn;

    dn = csquery("sys" , sysname(), "dom");
    if(dn == nil)
        dn = "who cares";
    return dn;
}
@

<<function [[csquery]]([[(networking/ip/httpd/httpd.c)]])>>=
/*
 *  query the connection server
 */
static char*
csquery(char *attr, char *val, char *rattr)
{
    char token[64+4];
    char buf[256], *p, *sp;
    int fd, n;

    if(val == nil || val[0] == 0)
        return nil;
    snprint(buf, sizeof(buf), "%s/cs", netdir);
    fd = open(buf, ORDWR);
    if(fd < 0)
        return nil;
    fprint(fd, "!%s=%s", attr, val);
    seek(fd, 0, 0);
    snprint(token, sizeof(token), "%s=", rattr);
    for(;;){
        n = read(fd, buf, sizeof(buf)-1);
        if(n <= 0)
            break;
        buf[n] = 0;
        p = strstr(buf, token);
        if(p != nil && (p == buf || *(p-1) == 0)){
            close(fd);
            sp = strchr(p, ' ');
            if(sp)
                *sp = 0;
            p = strchr(p, '=');
            if(p == nil)
                return nil;
            return estrdup(p+1);
        }
    }
    close(fd);
    return nil;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/httpd.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <mp.h>
#include <libsec.h>
#include "httpd.h"
#include "httpsrv.h"

<<enum [[_anon_ (networking/ip/httpd/httpd.c)]]>>

typedef struct Strings		Strings;
typedef struct System		System;

<<struct [[Strings]]>>
<<struct [[System]]>>

<<global [[netdir]]([[(networking/ip/httpd/httpd.c)]])>>
<<global [[HTTPLOG]]>>

<<global [[netdirb]]>>
<<global [[namespace]]([[(networking/ip/httpd/httpd.c)]])>>
<<global [[syss]]>>

static	void		becomenone(char*);
static	char		*csquery(char*, char*, char*);
static	void		dolisten(char*);
static	int		doreq(HConnect*);
static	int		send(HConnect*);
static	Strings		stripmagic(HConnect*, char*);
static	char*		stripprefix(char*, char*);
static	char*		sysdom(void);
static	int		notfound(HConnect *c, char *url);

<<global [[certificate]]>>
<<global [[certlen]]>>
<<global [[certchain]]>>

<<function [[usage]]([[(networking/ip/httpd/httpd.c)]])>>

<<function [[main]]([[(networking/ip/httpd/httpd.c)]])>>

<<function [[becomenone]]>>

<<function [[mkconnect]]>>

<<function [[mkhspriv]]>>

<<function [[hashstr]]([[(networking/ip/httpd/httpd.c)]])>>

<<function [[hashsys]]>>

<<function [[isswamped]]>>

<<function [[throttle]]>>

<<function [[dolisten]]>>

<<function [[doreq]]>>

<<function [[send]]([[(networking/ip/httpd/httpd.c)]])>>

<<function [[stripmagic]]>>

<<function [[stripprefix]]>>

<<function [[notfound]]>>

<<function [[sysdom]]>>

<<function [[csquery]]([[(networking/ip/httpd/httpd.c)]])>>
@


\subsection*{[[networking/ip/httpd/httpsrv.h]]}

<<enum [[_anon_ (networking/ip/httpd/httpsrv.h)]]>>=
enum
{
    HSTIMEOUT	= 15 * 60 * 1000,

    /* rewrite replacement field modifiers */
    Modsilent	= '@',	/* don't tell the browser about the redirect. */
    Modperm		= '=',	/* generate permanent redirection */
    Modsubord	= '*',	/* map page & all subordinates to same URL */
    Modonly		= '>',	/* match only this page, not subordinates */

    Redirsilent	= 1<<0,
    Redirperm	= 1<<1,
    Redirsubord	= 1<<2,
    Redironly	= 1<<3,
};
@

<<struct [[HSPriv]]>>=
struct HSPriv
{
    char		*remotesys;
    char		*remoteserv;
};
@

<<macro [[STRLEN]]>>=
#define 		STRLEN(s)	(sizeof(s)-1)
@

<<global [[webroot]]>>=
char *webroot;
@


%-------------------------------------------------------------

<<networking/ip/httpd/httpsrv.h>>=
typedef struct HSPriv	HSPriv;

<<enum [[_anon_ (networking/ip/httpd/httpsrv.h)]]>>

<<struct [[HSPriv]]>>

extern	int		logall[3];
extern	char*		HTTPLOG;
extern	char*		webroot;
extern	char*		netdir;

<<macro [[STRLEN]]>>

/* emem.c */
char			*estrdup(char*);
void*			ezalloc(ulong);

/* sendfd.c */
int			authcheck(HConnect *c);
int			checkreq(HConnect *c, HContent *type, HContent *enc, long mtime, char *etag);
int			etagmatch(int, HETag*, char*);
HRange			*fixrange(HRange *h, long length);
int			sendfd(HConnect *c, int fd, Dir *dir, HContent *type, HContent *enc);

/* content.c */
void			contentinit(void);
HContents		dataclass(HConnect *, char*, int);
int			updateQid(int, Qid*);
HContents		uriclass(HConnect *, char*);

/* anonymous.c */
void			anonymous(HConnect*);

/* hint.c */
void			hintprint(HConnect *hc, Hio*, char *, int, int);
void			statsinit(void);
void			urlcanon(char *url);
void			urlinit(void);

/* init.c */
HConnect*		init(int, char**);

vlong			Bfilelen(void*);

/* redirect.c */
void			redirectinit(void);
char*			redirect(HConnect *hc, char*, uint *);
char*			masquerade(char*);
char*			authrealm(HConnect *hc, char *path);
char			*undecorated(char *repl);

/* log.c */
void			logit(HConnect*, char*, ...);
#pragma	varargck	argpos	logit	2
void			writelog(HConnect*, char*, ...);
#pragma	varargck	argpos	writelog	2

/* authorize.c */
int authorize(HConnect*, char*);

<<global [[webroot]]>>
@


\subsection*{[[networking/ip/httpd/imagemap.c]]}

<<struct [[Point]]>>=
struct Point 
{
    int	x;
    int	y;
};
@

<<struct [[OkPoint]]>>=
struct OkPoint 
{
    Point	p;
    int	ok;
};
@

<<struct [[Strings]]([[(networking/ip/httpd/imagemap.c)]])>>=
struct Strings
{
    char	*s1;
    char	*s2;
};
@

<<global [[me]]>>=
static	char *me;
@

<<function [[main]]([[(networking/ip/httpd/imagemap.c)]])>>=
void
main(int argc, char **argv)
{
    HConnect *c;
    Hio *hout;
    char *dest;

    me = "imagemap";
    c = init(argc, argv);
    hout = &c->hout;
    if(hparseheaders(c, HSTIMEOUT) < 0)
        exits("failed");
    anonymous(c);

    if(strcmp(c->req.meth, "GET") != 0 && strcmp(c->req.meth, "HEAD") != 0){
        hunallowed(c, "GET, HEAD");
        exits("unallowed");
    }
    if(c->head.expectother || c->head.expectcont){
        hfail(c, HExpectFail, nil);
        exits("failed");
    }
    dest = translate(c, c->req.uri, c->req.search);

    if(dest == nil){
        if(c->req.vermaj){
            hokheaders(c);
            hprint(hout, "Content-type: text/html\r\n");
            hprint(hout, "\r\n");
        }
        hprint(hout, "<head><title>Nothing Found</title></head><body>\n");
        hprint(hout, "Nothing satisfying your search request could be found.\n</body>\n");
        hflush(hout);
        writelog(c, "Reply: 200 imagemap %ld %ld\n", hout->seek, hout->seek);
        exits(nil);
    }

    if(http11(c) && strcmp(c->req.meth, "POST") == 0)
        hredirected(c, "303 See Other", dest);
    else
        hredirected(c, "302 Found", dest);
    exits(nil);
}
@

<<function [[translate]]>>=
char*
translate(HConnect *c, char *uri, char *search)
{
    Biobuf *b;
    Strings ss;
    OkPoint okp;
    Point p, cen, q, start;
    float close, d;
    char *line, *to, *def, *s, *dst;
    int n, inside, r, ncsa;

    if(search == nil){
        hfail(c, HNoData, me);
        exits("failed");
    }
    okp = pt(search);
    if(!okp.ok){
        hfail(c, HBadSearch, me);
        exits("failed");
    }
    p = okp.p;

    b = Bopen(uri, OREAD);
    if(b == nil){
        hfail(c, HNotFound, uri);
        exits("failed");
    }

    to = nil;
    def = nil;
    dst = nil;
    close = 0.;
    ncsa = 1;
    while(line = Brdline(b, '\n')){
        line[Blinelen(b)-1] = 0;

        ss = getfield(line);
        s = ss.s1;
        line = ss.s2;
        if(ncsa){
            ss = getfield(line);
            dst = ss.s1;
            line = ss.s2;
        }
        if(strcmp(s, "#cern") == 0){
            ncsa = 0;
            continue;
        }
        if(strcmp(s, "rect") == 0){
            ss = getfield(line);
            s = ss.s1;
            line = ss.s2;
            okp = pt(s);
            q = okp.p;
            if(!okp.ok || q.x > p.x || q.y > p.y)
                continue;
            ss = getfield(line);
            s = ss.s1;
            line = ss.s2;
            okp = pt(s);
            q = okp.p;
            if(!okp.ok || q.x < p.x || q.y < p.y)
                continue;
            if(!ncsa){
                ss = getfield(line);
                dst = ss.s1;
            }
            return dst;
        }else if(strcmp(s, "circle") == 0){
            ss = getfield(line);
            s = ss.s1;
            line = ss.s2;
            okp = pt(s);
            cen = okp.p;
            if(!okp.ok)
                continue;
            ss = getfield(line);
            s = ss.s1;
            line = ss.s2;
            if(ncsa){
                okp = pt(s);
                if(!okp.ok)
                    continue;
                if(dist(okp.p, cen) >= dist(p, cen))
                    return dst;
            }else{
                r = strtol(s, nil, 10);
                ss = getfield(line);
                dst = ss.s1;
                d = (float)r * r;
                if(d >= dist(p, cen))
                    return dst;
            }
        }else if(strcmp(s, "poly") == 0){
            ss = getfield(line);
            s = ss.s1;
            line = ss.s2;
            okp = pt(s);
            start = okp.p;
            if(!okp.ok)
                continue;
            inside = 0;
            cen = start;
            for(n = 1; ; n++){
                ss = getfield(line);
                s = ss.s1;
                line = ss.s2;
                okp = pt(s);
                q = okp.p;
                if(!okp.ok)
                    break;
                inside = polytest(inside, p, cen, q);
                cen = q;
            }
            inside = polytest(inside, p, cen, start);
            if(!ncsa)
                dst = s;
            if(n >= 3 && inside)
                return dst;
        }else if(strcmp(s, "point") == 0){
            ss = getfield(line);
            s = ss.s1;
            line = ss.s2;
            okp = pt(s);
            q = okp.p;
            if(!okp.ok)
                continue;
            d = dist(p, q);
            if(!ncsa){
                ss = getfield(line);
                dst = ss.s1;
            }
            if(d == 0.)
                return dst;
            if(close == 0. || d < close){
                close = d;
                to = dst;
            }
        }else if(strcmp(s, "default") == 0){
            if(!ncsa){
                ss = getfield(line);
                dst = ss.s1;
            }
            def = dst;
        }
    }
    if(to == nil)
        to = def;
    return to;
}
@

<<function [[polytest]]>>=
int
polytest(int inside, Point p, Point b, Point a)
{
    Point pa, ba;

    if(b.y>a.y){
        pa=sub(p, a);
        ba=sub(b, a);
    }else{
        pa=sub(p, b);
        ba=sub(a, b);
    }
    if(0<=pa.y && pa.y<ba.y && pa.y*ba.x<=pa.x*ba.y)
        inside = !inside;
    return inside;
}
@

<<function [[sub]]([[(networking/ip/httpd/imagemap.c)]])>>=
Point
sub(Point p, Point q)
{
    p.x -= q.x;
    p.y -= q.y;
    return p;
}
@

<<function [[dist]]>>=
float
dist(Point p, Point q)
{
    p.x -= q.x;
    p.y -= q.y;
    return (float)p.x * p.x + (float)p.y * p.y;
}
@

<<function [[pt]]>>=
OkPoint
pt(char *s)
{
    OkPoint okp;
    Point p;
    char *t, *e;

    if(*s == '(')
        s++;
    t = strchr(s, ')');
    if(t != nil)
        *t = 0;
    p.x = 0;
    p.y = 0;
    t = strchr(s, ',');
    if(t == nil){
        okp.p = p;
        okp.ok = 0;
        return okp;
    }
    e = nil;
    p.x = strtol(s, &e, 10);
    if(e != t){
        okp.p = p;
        okp.ok = 0;
        return okp;
    }
    p.y = strtol(t+1, &e, 10);
    if(e == nil || *e != 0){
        okp.p = p;
        okp.ok = 0;
        return okp;
    }
    okp.p = p;
    okp.ok = 1;
    return okp;
}
@

<<function [[getfield]]>>=
Strings
getfield(char *s)
{
    Strings ss;
    char *f;

    while(*s == '\t' || *s == ' ')
        s++;
    f = s;
    while(*s && *s != '\t' && *s != ' ')
        s++;
    if(*s)
        *s++ = 0;
    ss.s1 = f;
    ss.s2 = s;
    return ss;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/imagemap.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

typedef struct Point	Point;
typedef struct OkPoint	OkPoint;
typedef struct Strings	Strings;

<<struct [[Point]]>>

<<struct [[OkPoint]]>>

<<struct [[Strings]]([[(networking/ip/httpd/imagemap.c)]])>>

<<global [[me]]>>

int		polytest(int, Point, Point, Point);
Strings		getfield(char*);
OkPoint		pt(char*);
char*		translate(HConnect*, char*, char*);
Point		sub(Point, Point);
float		dist(Point, Point);

<<function [[main]]([[(networking/ip/httpd/imagemap.c)]])>>

<<function [[translate]]>>

<<function [[polytest]]>>

<<function [[sub]]([[(networking/ip/httpd/imagemap.c)]])>>

<<function [[dist]]>>

<<function [[pt]]>>

<<function [[getfield]]>>
@


\subsection*{[[networking/ip/httpd/init.c]]}

<<function [[usage]]([[(networking/ip/httpd/init.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: %s [-b inbuf] [-d domain] [-p localport]"
        " [-r remoteip] [-s uri-scheme] [-w webroot]"
        " [-L logfd0 logfd1] [-N netdir] [-R reqline]"
        " method version uri [search]\n", argv0);
    exits("usage");
}
@

<<global [[netdir]]([[(networking/ip/httpd/init.c)]])>>=
char	*netdir;
@

<<global [[webroot]]([[(networking/ip/httpd/init.c)]])>>=
char	*webroot;
@

<<global [[HTTPLOG]]([[(networking/ip/httpd/init.c)]])>>=
char	*HTTPLOG = "httpd/log";
@

<<global [[connect]]>>=
static	HConnect	connect;
@

<<global [[priv]]>>=
static	HSPriv		priv;
@

<<function [[init]]([[(networking/ip/httpd/init.c)]])>>=
HConnect*
init(int argc, char **argv)
{
    char *vs;

    hinit(&connect.hin, 0, Hread);
    hinit(&connect.hout, 1, Hwrite);
    hmydomain = nil;
    connect.replog = writelog;
    connect.scheme = "http";
    connect.port = "80";
    connect.private = &priv;
    priv.remotesys = nil;
    priv.remoteserv = nil;
    fmtinstall('D', hdatefmt);
    fmtinstall('H', httpfmt);
    fmtinstall('U', hurlfmt);
    netdir = "/net";
    ARGBEGIN{
    case 'b':
        hload(&connect.hin, EARGF(usage()));
        break;
    case 'd':
        hmydomain = EARGF(usage());
        break;
    case 'p':
        connect.port = EARGF(usage());
        break;
    case 'r':
        priv.remotesys = EARGF(usage());
        break;
    case 's':
        connect.scheme = EARGF(usage());
        break;
    case 'w':
        webroot = EARGF(usage());
        break;
    case 'L':
        logall[0] = strtol(EARGF(usage()), nil, 10);
        logall[1] = strtol(EARGF(usage()), nil, 10);
        break;
    case 'N':
        netdir = EARGF(usage());
        break;
    case 'R':
        snprint((char*)connect.header, sizeof(connect.header), "%s",
            EARGF(usage()));
        break;
    default:
        usage();
    }ARGEND

    if(priv.remotesys == nil)
        priv.remotesys = "unknown";
    if(priv.remoteserv == nil)
        priv.remoteserv = "unknown";
    if(hmydomain == nil)
        hmydomain = "unknown";
    if(webroot == nil)
        webroot = "/usr/web";

    /*
     * open all files we might need before castrating namespace
     */
    time(nil);
    syslog(0, HTTPLOG, nil);

    if(argc != 4 && argc != 3)
        usage();

    connect.req.meth = argv[0];

    vs = argv[1];
    connect.req.vermaj = 0;
    connect.req.vermin = 9;
    if(strncmp(vs, "HTTP/", 5) == 0){
        vs += 5;
        connect.req.vermaj = strtoul(vs, &vs, 10);
        if(*vs == '.')
            vs++;
        connect.req.vermin = strtoul(vs, &vs, 10);
    }

    connect.req.uri = argv[2];
    connect.req.search = argv[3];
    connect.head.closeit = 1;
    connect.hpos = (uchar*)strchr((char*)connect.header, '\0');
    connect.hstop = connect.hpos;
    connect.reqtime = time(nil);	/* not quite right, but close enough */
    return &connect;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/init.c>>=
#include <u.h>
#include <libc.h>
#include "httpd.h"
#include "httpsrv.h"

<<function [[usage]]([[(networking/ip/httpd/init.c)]])>>

<<global [[netdir]]([[(networking/ip/httpd/init.c)]])>>
<<global [[webroot]]([[(networking/ip/httpd/init.c)]])>>
<<global [[HTTPLOG]]([[(networking/ip/httpd/init.c)]])>>

<<global [[connect]]>>
<<global [[priv]]>>

<<function [[init]]([[(networking/ip/httpd/init.c)]])>>
@


\subsection*{[[networking/ip/httpd/log.c]]}

<<global [[logall]]>>=
int		logall[3];  /* logall[2] is in "Common Log Format" */
@

<<global [[monname]]>>=
static char *
monname[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};
@

<<function [[logit]]([[(networking/ip/httpd/log.c)]])>>=
void
logit(HConnect *c, char *fmt, ...)
{
    char buf[4096];
    va_list arg;
    HSPriv *p;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    p = nil;
    if(c != nil)
        p = c->private;
    if(p != nil && p->remotesys != nil)
        syslog(0, HTTPLOG, "%s %s", p->remotesys, buf);
    else
        syslog(0, HTTPLOG, "%s", buf);
}
@

<<function [[writelog]]>>=
void
writelog(HConnect *c, char *fmt, ...)
{
    HSPriv *p;
    char buf[HBufSize+500], *bufp, *bufe;
    char statuscode[4];
    vlong objectsize;
    ulong now, today;
    int logfd;
    va_list arg;
    Tm *tm;

    if(c == nil)
        return;
    p = c->private;
    bufe = buf + sizeof(buf);
    now = time(nil);
    tm = gmtime(now);
    today = now / (24*60*60);

    /* verbose logfile, for research on web traffic */
    logfd = logall[today & 1];
    if(logfd > 0){
        if(c->hstop == c->header || c->hstop[-1] != '\n')
            *c->hstop = '\n';
        *c->hstop = '\0';
        bufp = seprint(buf, bufe, "==========\n");
        bufp = seprint(bufp, bufe, "LogTime:  %D\n", now);
        bufp = seprint(bufp, bufe, "ConnTime: %D\n", c->reqtime);
        bufp = seprint(bufp, bufe, "RemoteIP: %s\n", p->remotesys);
        bufp = seprint(bufp, bufe, "Port: %s\n", p->remoteserv);
        va_start(arg, fmt);
        bufp = vseprint(bufp, bufe, fmt, arg);
        va_end(arg);
        if(c->req.uri != nil && c->req.uri[0] != 0)
            bufp = seprint(bufp, bufe, "FinalURI: %s\n", c->req.uri);
        bufp = seprint(bufp, bufe, "----------\n%s\n", (char*)c->header);
        write(logfd, buf, bufp-buf);   /* append-only file */
    }

    /* another log, with less information but formatted for common analysis tools */
    if(logall[2] > 0 && strncmp(fmt, "Reply: ", 7) == 0){
        objectsize = 0;
        strecpy(statuscode, statuscode+4, fmt+7);
        if( fmt[7] == '%'){
            va_start(arg, fmt);
            vseprint(statuscode, statuscode+4, fmt+7, arg);
            va_end(arg);
        }else if(
            strcmp(fmt+7, "200 file %lld %lld\n") == 0 ||
            strcmp(fmt+7, "206 partial content %lld %lld\n") == 0 ||
            strcmp(fmt+7, "206 partial content, early termination %lld %lld\n") == 0){
            va_start(arg, fmt);
            objectsize = va_arg(arg, vlong); /* length in sendfd.c */
            USED(objectsize);
            objectsize = va_arg(arg, vlong); /* wrote in sendfd.c */
            va_end(arg);
        }
        bufp = seprint(buf, bufe, "%s - -", p->remotesys);
        bufp = seprint(bufp, bufe, " [%.2d/%s/%d:%.2d:%.2d:%.2d +0000]", tm->mday, monname[tm->mon], tm->year+1900, tm->hour, tm->min, tm->sec);
        if(c->req.uri == nil || c->req.uri[0] == 0){
            bufp = seprint(bufp, bufe, " \"%.*s\"",
                (int)utfnlen((char*)c->header, strcspn((char*)c->header, "\r\n")),
                (char*)c->header);
        }else{
            /* use more canonical form of URI, if available */
            bufp = seprint(bufp, bufe, " \"%s %s HTTP/%d.%d\"", c->req.meth, c->req.uri, c->req.vermaj,  c->req.vermin);
        }
        bufp = seprint(bufp, bufe, " %s %lld\n", statuscode, objectsize);
        write(logall[2], buf, bufp-buf);   /* append-only file */
    }
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/log.c>>=
#include <u.h>
#include <libc.h>
#include "httpd.h"
#include "httpsrv.h"

<<global [[logall]]>>

<<global [[monname]]>>

<<function [[logit]]([[(networking/ip/httpd/log.c)]])>>

<<function [[writelog]]>>
@


\subsection*{[[networking/ip/httpd/man2html.c]]}

<<global [[hout]]>>=
static	Hio		*hout;
@

<<global [[houtb]]>>=
static	Hio		houtb;
@

<<global [[connect]]([[(networking/ip/httpd/man2html.c)]])>>=
static	HConnect	*connect;
@

<<function [[error]]([[(networking/ip/httpd/man2html.c)]])>>=
void
error(char *title, char *fmt, ...)
{
    va_list arg;
    char buf[1024], *out;

    va_start(arg, fmt);
    out = vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    *out = 0;

    hprint(hout, "%s 404 %s\n", hversion, title);
    hprint(hout, "Date: %D\n", time(nil));
    hprint(hout, "Server: Plan9\n");
    hprint(hout, "Content-type: text/html\n");
    hprint(hout, "\n");
    hprint(hout, "<head><title>%s</title></head>\n", title);
    hprint(hout, "<body><h1>%s</h1></body>\n", title);
    hprint(hout, "%s\n", buf);
    hflush(hout);
    writelog(connect, "Reply: 404\nReason: %s\n", title);
    exits(nil);
}
@

<<struct [[Hit]]>>=
struct Hit 
{
    Hit *next;
    char *file;
};
@

<<function [[lookup]]([[(networking/ip/httpd/man2html.c)]])>>=
void
lookup(char *object, int section, Hit **list)
{
    int fd;
    char *p, *f;
    Biobuf b;
    char file[256];
    Hit *h;

    while(*list != nil)
        list = &(*list)->next;

    snprint(file, sizeof(file), "/sys/man/%d/INDEX", section);
    fd = open(file, OREAD);
    if(fd > 0){
        Binit(&b, fd, OREAD);
        for(;;){
            p = Brdline(&b, '\n');
            if(p == nil)
                break;
            p[Blinelen(&b)-1] = 0;
            f = strchr(p, ' ');
            if(f == nil)
                continue;
            *f++ = 0;
            if(strcmp(p, object) == 0){
                h = ezalloc(sizeof *h);
                *list = h;
                h->next = nil;
                snprint(file, sizeof(file), "/%d/%s", section, f);
                h->file = estrdup(file);
                close(fd);
                return;
            }
        }
        close(fd);
    }
    snprint(file, sizeof(file), "/sys/man/%d/%s", section, object);
    if(access(file, 0) == 0){
        h = ezalloc(sizeof *h);
        *list = h;
        h->next = nil;
        h->file = estrdup(file+8);
    }
}
@

<<function [[manindex]]>>=
void
manindex(int sect, int vermaj)
{
    int i;

    if(vermaj){
        hokheaders(connect);
        hprint(hout, "Content-type: text/html\r\n");
        hprint(hout, "\r\n");
    }

    hprint(hout, "<head><title>plan 9 section index");
    if(sect)
        hprint(hout, "(%d)\n", sect);
    hprint(hout, "</title></head><body>\n");
    hprint(hout, "<H6>Section Index");
    if(sect)
        hprint(hout, "(%d)\n", sect);
    hprint(hout, "</H6>\n");

    if(sect)
        hprint(hout, "<p><a href=\"/plan9/man%d.html\">/plan9/man%d.html</a>\n",
            sect, sect);
    else for(i = 1; i < 10; i++)
        hprint(hout, "<p><a href=\"/plan9/man%d.html\">/plan9/man%d.html</a>\n",
            i, i);
    hprint(hout, "</body>\n");
}
@

<<function [[man]]>>=
void
man(char *o, int sect, int vermaj)
{
    int i;
    Hit *list;

    list = nil;

    if(*o == 0){
        manindex(sect, vermaj);
        return;
    }

    if(sect > 0 && sect < 10)
        lookup(o, sect, &list);
    else
        for(i = 1; i < 9; i++)
            lookup(o, i, &list);

    if(list != nil && list->next == nil){
        doconvert(list->file, vermaj);
        return;
    }

    if(vermaj){
        hokheaders(connect);
        hprint(hout, "Content-type: text/html\r\n");
        hprint(hout, "\r\n");
    }

    hprint(hout, "<head><title>plan 9 man %H", o);
    if(sect)
        hprint(hout, "(%d)\n", sect);
    hprint(hout, "</title></head><body>\n");
    hprint(hout, "<H6>Search for %H", o);
    if(sect)
        hprint(hout, "(%d)\n", sect);
    hprint(hout, "</H6>\n");

    for(; list; list = list->next)
        hprint(hout, "<p><a href=\"/magic/man2html%U\">/magic/man2html%H</a>\n",
            list->file, list->file);
    hprint(hout, "</body>\n");
}
@

<<function [[strlwr]]>>=
void
strlwr(char *p)
{
    for(; *p; p++)
        if('A' <= *p && *p <= 'Z')
            *p += 'a'-'A';
}
@

<<function [[redirectto]]>>=
void
redirectto(char *uri)
{
    if(connect){
        hmoved(connect, uri);
        exits(0);
    }else
        hprint(hout, "Your selection moved to <a href=\"%U\"> here</a>.<p></body>\r\n", uri);
}
@

<<function [[searchfor]]>>=
void
searchfor(char *search)
{
    int i, j, n, fd;
    char *p, *sp;
    Biobufhdr *b;
    char *arg[32];

    hprint(hout, "<head><title>plan 9 search for %H</title></head>\n", search);
    hprint(hout, "<body>\n");

    hprint(hout, "<p>This is a keyword search through Plan 9 man pages.\n");
    hprint(hout, "The search is case insensitive; blanks denote \"boolean and\".\n");
    hprint(hout, "<FORM METHOD=\"GET\" ACTION=\"/magic/man2html\">\n");
    hprint(hout, "<INPUT NAME=\"pat\" TYPE=\"text\" SIZE=\"60\">\n");
    hprint(hout, "<INPUT TYPE=\"submit\" VALUE=\"Submit\">\n");
    hprint(hout, "</FORM>\n");

    hprint(hout, "<hr><H6>Search for %H</H6>\n", search);
    n = getfields(search, arg, 32, 1, "+");
    for(i = 0; i < n; i++){
        for(j = i+1; j < n; j++){
            if(strcmp(arg[i], arg[j]) > 0){
                sp = arg[j];
                arg[j] = arg[i];
                arg[i] = sp;
            }
        }
        sp = malloc(strlen(arg[i]) + 2);
        if(sp != nil){
            strcpy(sp+1, arg[i]);
            sp[0] = ' ';
            arg[i] = sp;
        }
    }

    /*
     *  search index till line starts alphabetically < first token
     */
    fd = open("/sys/man/searchindex", OREAD);
    if(fd < 0){
        hprint(hout, "<body>error: No Plan 9 search index\n");
        hprint(hout, "</body>");
        return;
    }
    p = malloc(32*1024);
    if(p == nil){
        close(fd);
        return;
    }
    b = ezalloc(sizeof *b);
    Binits(b, fd, OREAD, (uchar*)p, 32*1024);
    for(;;){
        p = Brdline(b, '\n');
        if(p == nil)
            break;
        p[Blinelen(b)-1] = 0;
        for(i = 0; i < n; i++){
            sp = strstr(p, arg[i]);
            if(sp == nil)
                break;
            p = sp;
        }
        if(i < n)
            continue;
        sp = strrchr(p, '\t');
        if(sp == nil)
            continue;
        sp++;
        hprint(hout, "<p><a href=\"/magic/man2html/%U\">/magic/man2html/%H</a>\n",
            sp, sp);
    }
    hprint(hout, "</body>");

    Bterm(b);
    free(b);
    free(p);
    close(fd);
}
@

<<function [[dosearch]]>>=
/*
 *  find man pages mentioning the search string
 */
void
dosearch(int vermaj, char *search)
{
    int sect;
    char *p;

    if(strncmp(search, "man=", 4) == 0){
        sect = 0;
        search = hurlunesc(connect, search+4);
        p = strchr(search, '&');
        if(p != nil){
            *p++ = 0;
            if(strncmp(p, "sect=", 5) == 0)
                sect = atoi(p+5);
        }
        man(search, sect, vermaj);
        return;
    }

    if(vermaj){
        hokheaders(connect);
        hprint(hout, "Content-type: text/html\r\n");
        hprint(hout, "\r\n");
    }

    if(strncmp(search, "pat=", 4) == 0){
        search = hurlunesc(connect, search+4);
        search = hlower(search);
        searchfor(search);
        return;
    }

    hprint(hout, "<head><title>illegal search</title></head>\n");
    hprint(hout, "<body><p>Illegally formatted Plan 9 man page search</p>\n");
    search = hurlunesc(connect, search);
    hprint(hout, "<body><p>%H</p>\n", search);
    hprint(hout, "</body>");
}
@

<<function [[doconvert]]>>=
/*
 *  convert a man page to html and output
 */
void
doconvert(char *uri, int vermaj)
{
    char *p;
    char file[256];
    char title[256];
    char err[ERRMAX];
    int pfd[2];
    Dir *d;
    Waitmsg *w;
    int x;

    if(strstr(uri, ".."))
        error("bad URI", "man page URI cannot contain ..");
    p = strstr(uri, "/intro");

    if(p == nil){
        while(*uri == '/')
            uri++;
        /* redirect section requests */
        snprint(file, sizeof(file), "/sys/man/%s", uri);
        d = dirstat(file);
        if(d == nil){
            strlwr(file);
            if(dirstat(file) != nil){
                snprint(file, sizeof(file), "/magic/man2html/%s", uri);
                strlwr(file);
                redirectto(file);
            }
            error(uri, "man page not found");
        }
        x = d->qid.type;
        free(d);
        if(x & QTDIR){
            if(*uri == 0 || strcmp(uri, "/") == 0)
                redirectto("/sys/man/index.html");
            else {
                snprint(file, sizeof(file), "/sys/man/%s/INDEX.html",
                    uri+1);
                redirectto(file);
            }
            return;
        }
    } else {
        /* rewrite the name intro */
        *p = 0;
        snprint(file, sizeof(file), "/sys/man/%s/0intro", uri);
        d = dirstat(file);
        free(d);
        if(d == nil)
            error(uri, "man page not found");
    }

    if(vermaj){
        hokheaders(connect);
        hprint(hout, "Content-type: text/html\r\n");
        hprint(hout, "\r\n");
    }
    hflush(hout);

    if(pipe(pfd) < 0)
        error("out of resources", "pipe failed");

    /* troff -manhtml <file> | troff2html -t '' */
    switch(fork()){
    case -1:
        error("out of resources", "fork failed");
    case 0:
        snprint(title, sizeof(title), "Plan 9 %s", file);
        close(0);
        dup(pfd[0], 0);
        close(pfd[0]);
        close(pfd[1]);
        execl("/bin/troff2html", "troff2html", "-t", title, nil);
        errstr(err, sizeof err);
        exits(err);
    }
    switch(fork()){
    case -1:
        error("out of resources", "fork failed");
    case 0:
        snprint(title, sizeof(title), "Plan 9 %s", file);
        close(0);
        close(1);
        dup(pfd[1], 1);
        close(pfd[0]);
        close(pfd[1]);
        execl("/bin/troff", "troff", "-manhtml", file, nil);
        errstr(err, sizeof err);
        exits(err);
    }
    close(pfd[0]);
    close(pfd[1]);

    /* wait for completion */
    for(;;){
        w = wait();
        if(w == nil)
            break;
        if(w->msg[0] != 0)
            print("whoops %s\n", w->msg);
        free(w);
    }
}
@

<<function [[main]]([[(networking/ip/httpd/man2html.c)]])>>=
void
main(int argc, char **argv)
{
    fmtinstall('H', httpfmt);
    fmtinstall('U', hurlfmt);

    if(argc == 2){
        hinit(&houtb, 1, Hwrite);
        hout = &houtb;
        doconvert(argv[1], 0);
        exits(nil);
    }
    close(2);

    connect = init(argc, argv);
    hout = &connect->hout;
    if(hparseheaders(connect, HSTIMEOUT) < 0)
        exits("failed");

    if(strcmp(connect->req.meth, "GET") != 0 && strcmp(connect->req.meth, "HEAD") != 0){
        hunallowed(connect, "GET, HEAD");
        exits("not allowed");
    }
    if(connect->head.expectother || connect->head.expectcont){
        hfail(connect, HExpectFail, nil);
        exits("failed");
    }

    bind("/usr/web/sys/man", "/sys/man", MREPL);

    if(connect->req.search != nil)
        dosearch(connect->req.vermaj, connect->req.search);
    else
        doconvert(connect->req.uri, connect->req.vermaj);
    hflush(hout);
    writelog(connect, "200 man2html %ld %ld\n", hout->seek, hout->seek);
    exits(nil);
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/man2html.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

<<global [[hout]]>>
<<global [[houtb]]>>
<<global [[connect]]([[(networking/ip/httpd/man2html.c)]])>>

void	doconvert(char*, int);

<<function [[error]]([[(networking/ip/httpd/man2html.c)]])>>

typedef struct Hit	Hit;
<<struct [[Hit]]>>

<<function [[lookup]]([[(networking/ip/httpd/man2html.c)]])>>

<<function [[manindex]]>>

<<function [[man]]>>

<<function [[strlwr]]>>

<<function [[redirectto]]>>

<<function [[searchfor]]>>

<<function [[dosearch]]>>

<<function [[doconvert]]>>

<<function [[main]]([[(networking/ip/httpd/man2html.c)]])>>
@


\subsection*{[[networking/ip/httpd/netlib_find.c]]}

<<global [[hout]]([[(networking/ip/httpd/netlib_find.c)]])>>=
Hio *hout;
@

<<struct [[DB]]>>=
struct DB 
{
    int	SELECT;	/* value from search.html */
    char	*log;	/* abbreviation for logfile */
    int	maxhit;	/* maximum number of hits to return */
    char	*file;	/* searchfs database */
    void	(*fmt)(char*,char*); /* convert one record to HTML */
    char	*postlude;	/* trailer text */
};
@

<<global [[db]]([[(networking/ip/httpd/netlib_find.c)]])>>=
DB db[] =
{
 {0, "netlib",	250, "/srv/netlib_DEFAULT", index_fmt,
    "<HR><A HREF=\"/netlib/master\">browse netlib</A></BODY>\r\n"},
 {1, "BibNet",	250, "/srv/netlib_bibnet", bib_fmt,
    "<HR><A HREF=\"/netlib/bibnet\">browse BibNet</A></BODY>\r\n"},
 {2, "compgeom",	250, "/srv/netlib_compgeom", no_fmt, "</BODY>\r\n"},
 {3, "approx",	250, "/srv/netlib_approximation", no_fmt,
    "<HR><A HREF=\"/netlib/a/catalog.html.gz\">hierarchical catalog</A></BODY>\r\n"},
 {4, "siam",	 50, "/srv/netlib_siam-Secret", no_fmt, "</BODY>\r\n"},
 {-1,"",0,"",no_fmt,""}
};
@

<<function [[no_fmt]]>>=
/********** reformat database record as HTML ************/

void /* tr '\015' '\012' ("uncombline") */
no_fmt(char*s,char*e)
{
    /* s = start, e = (one past) end of database record */
    char *p;
    for(p = s; p<e; p++)
        if(*p=='\r'){
            hwrite(hout, s,p-s);
            hprint(hout, "\n");
            s = p+1;
        }
}
@

<<function [[suffix]]>>=
int /* should the filename have .gz appended? */
suffix(char*filename)
{
    int n;
    char *z;

    if(!filename || *filename==0)
        return(0);
    n = strlen(filename);
    if(strncmp(".html",filename+n-5,5)==0)
        return(0);
    z = malloc(n+50);
    if(z == nil)
        return(0);
    strcpy(z,"/netlib/pub/");
    strcat(z,filename);
    strcat(z,".gz");
    if(access(z,4)==0){
        free(z);
        return(1);
    }
    free(z);
    return(0);
}
@

<<function [[index_fmt]]>>=
void /* add HREF to "file:" lines */
index_fmt(char*s,char*e)
{
    char *p, *filename;
    if(strncmp(s,"file",4)==0 && (s[4]==' '||s[4]=='\t')){
        for(filename = s+4; strchr(" \t",*filename); filename++){}
        for(s = filename; *s && strchr("\r\n",*s)==nil; s++){}
        *s++ = '\0';
        if(*s=='\n') s++;
        hprint(hout, "file:   <A HREF=\"/netlib/%s",filename);
        if(suffix(filename))
            hprint(hout, ".gz");
        hprint(hout, "\">%s</A>\r\n",filename);
        for(p = s; p<e; p++)
            if(*p=='\r'){
                hwrite(hout, s,p-s);
                hprint(hout, "\n");
                s = p+1;
            }
    }else if(strncmp(s,"lib",3)==0 && (s[3]==' '||s[3]=='\t')){
        for(filename = s+3; strchr(" \t",*filename); filename++){}
        for(s = filename; *s && strchr("\r\n",*s)==nil; s++){}
        *s++ = '\0';
        if(*s=='\n') s++;
        hprint(hout, "lib:    <A HREF=\"/netlib/%s",filename);
        hprint(hout, "\">%s</A>\r\n",filename);
        for(p = s; p<e; p++)
            if(*p=='\r'){
                hwrite(hout, s,p-s);
                hprint(hout, "\n");
                s = p+1;
            }
    }else{
        no_fmt(s,e);
    }
}
@

<<function [[bib_fmt]]>>=
void /* add HREF to "URL" lines */
bib_fmt(char*s,char*e)
{
    char *p, *filename;
    for(p = s; p<e; p++)
        if(*p=='\r'){
            hwrite(hout, s,p-s);
            hprint(hout, "\n");
            s = p+1;
            if(strncmp(s," URL =",6)==0 &&
                    (filename = strchr(s+6,'"'))!=nil){
                filename++;
                for(s = filename; *s && strchr("\"\r\n",*s)==nil; s++){}
                *s++ = '\0';
                p = s;
                hprint(hout, " URL =<A HREF=\"%s\">%s</A>",
                    filename,filename);
            }
        }
}
@

<<function [[main]]([[(networking/ip/httpd/netlib_find.c)]])>>=
/********** main() calls httpheadget() calls send() ************/

void
main(int argc, char **argv)
{
    HConnect *c;

    c = init(argc, argv);
    hout = &c->hout;
    if(hparseheaders(c, HSTIMEOUT) >= 0)
        send(c);
    exits(nil);
}
@

<<global [[Blist]]>>=
Biobuf Blist;
@

<<function [[init800fs]]>>=
Biobuf*
init800fs(char*name,char*pat)
{
    int fd800fs, n;
    char*search;

    fd800fs = open(name, ORDWR);
    if(fd800fs < 0)
        exits("can't connect to 800fs server");
    if(mount(fd800fs, -1, "/mnt", MREPL, "") < 0)
        exits("can't mount /mnt");
    fd800fs = open("/mnt/search", ORDWR);
    n = strlen("search=")+strlen(pat)+1;
    search = ezalloc(n);
    strcpy(search,"search=");
    strcat(search,pat);
    write(fd800fs,search,n);
    free(search);
    Binit(&Blist, fd800fs,OREAD);
    return(&Blist);
}
@

<<function [[hq]]>>=
static char *
hq(char *text)
{
    int textlen = strlen(text), escapedlen = textlen;
    char *escaped, *s, *w;

    for(s = text; *s; s++)
        if(*s=='<' || *s=='>' || *s=='&')
            escapedlen += 4;
    escaped = ezalloc(escapedlen+1);
    for(s = text, w = escaped; *s; s++){
        if(*s == '<'){
            strcpy(w, "&lt;");
            w += 4;
        }else if(*s == '>'){
            strcpy(w, "&gt;");
            w += 4;
        }else if(*s == '&'){
            strcpy(w, "&amp;");
            w += 5;
        }else{
            *w++ = *s;
        }
    }
    return escaped;
}
@

<<function [[send]]([[(networking/ip/httpd/netlib_find.c)]])>>=
int
send(HConnect *c)
{
    Biobuf*blist;
    int m, n, dbi, nmatch;
    char *pat, *s, *e;
    HSPairs *q;

    if(strcmp(c->req.meth, "GET") != 0 && strcmp(c->req.meth, "HEAD") != 0)
        return hunallowed(c, "GET, HEAD");
    if(c->head.expectother || c->head.expectcont)
        return hfail(c, HExpectFail, nil);
    if(c->req.search == nil || !*c->req.search)
        return hfail(c, HNoData, "netlib_find");
    s = c->req.search;
    while((s = strchr(s, '+')) != nil)
        *s++ = ' ';
    dbi = -1;
    pat = nil;
    for(q = hparsequery(c, hstrdup(c, c->req.search)); q; q = q->next){
        if(strcmp(q->s, "db") == 0){
            m = atoi(q->t);
            for(dbi = 0; m!=db[dbi].SELECT; dbi++)
                if(db[dbi].SELECT<0)
                    exits("unrecognized db");
        }else if(strcmp(q->s, "pat") == 0){
            pat = q->t;
        }
    }
    if(dbi < 0)
        exits("missing db field in query");
    if(pat == nil)
        exits("missing pat field in query");
    logit(c, "netlib_find %s %s", db[dbi].log,pat);

    blist = init800fs(db[dbi].file,pat);

    if(c->req.vermaj){
        hokheaders(c);
        hprint(hout, "Content-type: text/html\r\n");
        hprint(hout, "\r\n");
    }
    if(strcmp(c->req.meth, "HEAD") == 0){
        writelog(c, "Reply: 200 netlib_find 0\n");
        hflush(hout);
        exits(nil);
    }

    hprint(hout, "<HEAD><TITLE>%s/%s</TITLE></HEAD>\r\n<BODY>\r\n",
        db[dbi].log,hq(pat));
    nmatch = 0;

    while(s = Brdline(blist, '\n')){ /* get next database record */
        n = Blinelen(blist);
        e = s+n;
        hprint(hout, "<PRE>");
        (*db[dbi].fmt)(s,e);
        hprint(hout, "</PRE>\r\n");
        if(nmatch++>=db[dbi].maxhit){
            hprint(hout, "<H4>reached limit at %d hits</H4>\n\r",nmatch);
            break;
        }
    }
    if(nmatch==0)
        hprint(hout, "<H4>Nothing Found.</H4>\r\n");
    hprint(hout, db[dbi].postlude);
    hflush(hout);
    writelog(c, "Reply: 200 netlib_find %ld %ld\n", hout->seek, hout->seek);
    return 1;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/netlib_find.c>>=
/* invoked from /netlib/pub/search.html */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

void bib_fmt(char*,char*);
void index_fmt(char*,char*);
void no_fmt(char*,char*);
int send(HConnect*);

<<global [[hout]]([[(networking/ip/httpd/netlib_find.c)]])>>

/********** table of databases ************/

typedef struct DB	DB;
<<struct [[DB]]>>

<<global [[db]]([[(networking/ip/httpd/netlib_find.c)]])>>



<<function [[no_fmt]]>>

<<function [[suffix]]>>

<<function [[index_fmt]]>>

<<function [[bib_fmt]]>>


<<function [[main]]([[(networking/ip/httpd/netlib_find.c)]])>>

<<global [[Blist]]>>

<<function [[init800fs]]>>


<<function [[hq]]>>

<<function [[send]]([[(networking/ip/httpd/netlib_find.c)]])>>
@


\subsection*{[[networking/ip/httpd/netlib_history.c]]}

<<global [[HO]]>>=
Hio *HO;
@

<<global [[diffb]]>>=
int diffb;
@

<<enum [[_anon_ (networking/ip/httpd/netlib_history.c)]]>>=
enum{ DAY = 24*60*60 };
@

<<function [[lastbefore]]>>=
void
lastbefore(ulong t, char *f, char *b)
{
    Tm *tm;
    Dir *dir;
    int try;
    ulong t0, mtime;

    t0 = t;
    for(try=0; try<10; try++) {
        tm = localtime(t);
        t -= DAY;
        sprint(b,"%.4d/%.2d%.2d/netlib/pub/%s",tm->year+1900,tm->mon+1,tm->mday,f);
        dir = dirstat(b);
        if(dir == nil)
            continue;
        mtime = dir->mtime;
        free(dir);
        if(mtime > t0)
            continue;
        return;
    }
    strcpy(b, "filenotfound");
}
@

<<function [[gunzip]]>>=
// mode 0600 file that it couldn't read (because running as none)
void
gunzip(char *f, char *tmp)
{
    int fd = open(tmp, OWRITE);

    if(fd < 0)  // can't happen
        return;
    switch(fork()){
    case 0:
        dup(fd, 1);
        close(fd);
        close(0);
        execl("/bin/gunzip", "gunzip", "-c", f, nil);
        hprint(HO, "can't exec gunzip: %r\n");
        break;
    case -1:
        hprint(HO, "fork failed: %r\n");
    default:
        while(waitpid() != -1)
            ;
        break;
    }
    close(fd);
}
@

<<function [[netlibhistory]]>>=
void
netlibhistory(char *file)
{
    char buf[500], pair[2][500], tmpf[2][30], *f;
    int toggle = 0, started = 0, limit;
    Dir *dir;
    ulong otime, dt;
    int i, fd, tmpcnt;

    if(strncmp(file, "../", 3) == 0 || strstr(file, "/../") ||
        strlen(file) >= sizeof(buf) - strlen("1997/0204/netlib/pub/0"))
        return;
    limit = 50;
    if(diffb){
        limit = 10;
        // create two tmp files for gunzip
        for(i = 0, tmpcnt = 0; i < 2 && tmpcnt < 20; tmpcnt++){
            snprint(tmpf[i], sizeof(tmpf[0]), "/tmp/d%x", tmpcnt);
            if(access(buf, AEXIST) == 0)
                continue;
            fd = create(tmpf[i], OWRITE, 0666);
            if(fd < 0)
                goto done;
            close(fd);
            i++;
        }
    }
    otime = time(0);
    hprint(HO,"<UL>\n");
    while(limit--){
        lastbefore(otime, file, buf);
        dir = dirstat(buf);
        if(dir == nil)
            goto done;
        dt = DAY/2;
        while(otime <= dir->mtime){
            lastbefore(otime-dt, file, buf);
            free(dir);
            dir = dirstat(buf);
            if(dir == nil)
                goto done;
            dt += DAY/2;
        }
        f = pair[toggle];
        strcpy(f, buf);
        if(diffb && strcmp(f+strlen(f)-3, ".gz") == 0){
            gunzip(f, tmpf[toggle]);
            strcpy(f, tmpf[toggle]);
        }
        if(diffb && started){
            hprint(HO, "<PRE>\n");
            hflush(HO);
            switch(fork()){
            case 0:
                execl("/bin/diff", "diff", "-nb",
                    pair[1-toggle], pair[toggle], nil);
                hprint(HO, "can't exec diff: %r\n");
                break;
            case -1:
                hprint(HO, "fork failed: %r\n");
                break;
            default:
                while(waitpid() != -1)
                    ;
                break;
            }
            hprint(HO, "</PRE>\n");
        }
        hprint(HO,"<LI><A HREF=\"/historic/%s\">%s</A> %lld bytes\n",
            buf, 4+asctime(gmtime(dir->mtime)), dir->length);
        if(diffb)
            hprint(HO," <FONT SIZE=-1>(%s)</FONT>\n", pair[toggle]);
        toggle = 1-toggle;
        started = 1;
        otime = dir->mtime;
        free(dir);
    }
    hprint(HO,"<LI>...\n");
done:
    hprint(HO,"</UL>\n");
    if(diffb){
        remove(tmpf[0]);
        remove(tmpf[1]);
    }
}
@

<<function [[send]]([[(networking/ip/httpd/netlib_history.c)]])>>=
int
send(HConnect *c)
{
    char *file, *s;
    HSPairs *q;

    if(strcmp(c->req.meth, "GET") != 0 && strcmp(c->req.meth, "HEAD") != 0)
        return hunallowed(c, "GET, HEAD");
    if(c->head.expectother || c->head.expectcont)
        return hfail(c, HExpectFail, nil);
    if(c->req.search == nil || !*c->req.search)
        return hfail(c, HNoData, "netlib_history");
    s = c->req.search;
    while((s = strchr(s, '+')) != nil)
        *s++ = ' ';
    file = nil;
    for(q = hparsequery(c, hstrdup(c, c->req.search)); q; q = q->next){
        if(strcmp(q->s, "file") == 0)
            file = q->t;
        else if(strcmp(q->s, "diff") == 0)
            diffb = 1;
    }
    if(file == nil)
        return hfail(c, HNoData, "netlib_history missing file field");
    logit(c, "netlib_hist %s%s", file, diffb?" DIFF":"");

    if(c->req.vermaj){
        hokheaders(c);
        hprint(HO, "Content-type: text/html\r\n");
        hprint(HO, "\r\n");
    }
    if(strcmp(c->req.meth, "HEAD") == 0){
        writelog(c, "Reply: 200 netlib_history 0\n");
        hflush(HO);
        exits(nil);
    }

    hprint(HO, "<HEAD><TITLE>%s history</TITLE></HEAD>\n<BODY>\n",file);
    hprint(HO, "<H2>%s history</H2>\n",file);
    hprint(HO, "<I>Netlib's copy of %s was changed\n", file);
    hprint(HO, "on the dates shown.  <BR>Click on the date link\n");
    hprint(HO, "to retrieve the corresponding version.</I>\n");
    if(diffb){
        hprint(HO, "<BR><I>Lines beginning with &lt; are for the\n");
        hprint(HO, "newer of the two versions.</I>\n");
    }

    if(chdir("/usr/web/historic") < 0)
        hprint(HO, "chdir failed: %r\n");
    netlibhistory(file);

    hprint(HO, "<BR><A HREF=\"http://cm.bell-labs.com/who/ehg\">Eric Grosse</A>\n");
    hprint(HO, "</BODY></HTML>\n");
    hflush(HO);
    writelog(c, "Reply: 200 netlib_history %ld %ld\n", HO->seek, HO->seek);
    return 1;
}
@

<<function [[main]]([[(networking/ip/httpd/netlib_history.c)]])>>=
void
main(int argc, char **argv)
{
    HConnect *c;

    c = init(argc, argv);
    HO = &c->hout;
    if(hparseheaders(c, HSTIMEOUT) >= 0)
        send(c);
    exits(nil);
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/netlib_history.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

<<global [[HO]]>>
<<global [[diffb]]>>

<<enum [[_anon_ (networking/ip/httpd/netlib_history.c)]]>>

<<function [[lastbefore]]>>

// create explicit file for diff, which otherwise would create a
<<function [[gunzip]]>>

<<function [[netlibhistory]]>>

<<function [[send]]([[(networking/ip/httpd/netlib_history.c)]])>>

<<function [[main]]([[(networking/ip/httpd/netlib_history.c)]])>>
@


\subsection*{[[networking/ip/httpd/redirect.c]]}

<<enum [[_anon_ (networking/ip/httpd/redirect.c)]]>>=
enum
{
    HASHSIZE = 1019,
};
@

<<struct [[Redir]]>>=
struct Redir
{
    Redir	*next;
    char	*pat;
    char	*repl;
    uint	flags;		/* generated from repl's decorations */
};
@

<<global [[redirtab]]>>=
static Redir *redirtab[HASHSIZE];
@

<<global [[vhosttab]]>>=
static Redir *vhosttab[HASHSIZE];
@

<<global [[emptystring]]>>=
static char emptystring[1];
@

<<global [[decorations]]>>=
/* these two arrays must be kept in sync */
static char decorations[] = { Modsilent, Modperm, Modsubord, Modonly, '\0' };
@

<<global [[redirflags]]>>=
static uint redirflags[] = { Redirsilent, Redirperm, Redirsubord, Redironly, };
@

<<function [[isdecorated]]>>=
/* replacement field decorated with redirection modifiers? */
static int
isdecorated(char *repl)
{
    return strchr(decorations, repl[0]) != nil;
}
@

<<function [[decor2flags]]>>=
static uint
decor2flags(char *repl)
{
    uint flags;
    char *p;

    flags = 0;
    while ((p = strchr(decorations, *repl++)) != nil)
        flags |= redirflags[p - decorations];
    return flags;
}
@

<<function [[undecorated]]>>=
/* return replacement without redirection modifiers */
char *
undecorated(char *repl)
{
    while (isdecorated(repl))
        repl++;
    return repl;
}
@

<<function [[hashasu]]>>=
static int
hashasu(char *key, int n)
{
        ulong h;

    h = 0;
        while(*key != 0)
                h = 65599*h + *(uchar*)key++;
        return h % n;
}
@

<<function [[insert]]>>=
static void
insert(Redir **tab, char *pat, char *repl)
{
    Redir **l;
    Redir *srch;
    ulong hash;

    hash = hashasu(pat, HASHSIZE);
    for(l = &tab[hash]; *l; l = &(*l)->next)
        ;
    *l = srch = ezalloc(sizeof(Redir));
    srch->pat = pat;
    srch->flags = decor2flags(repl);
    srch->repl = undecorated(repl);
    srch->next = 0;
}
@

<<function [[cleartab]]>>=
static void
cleartab(Redir **tab)
{
    Redir *t;
    int i;

    for(i = 0; i < HASHSIZE; i++){
        while((t = tab[i]) != nil){
            tab[i] = t->next;
            free(t->pat);
            free(t->repl);
            free(t);
        }
    }
}
@

<<function [[redirectinit]]>>=
void
redirectinit(void)
{
    static Biobuf *b = nil;
    static Qid qid;
    char *file, *line, *s, *host, *field[3];
    static char pfx[] = "http://";

    file = "/sys/lib/httpd.rewrite";
    if(b != nil){
        if(updateQid(Bfildes(b), &qid) == 0)
            return;
        Bterm(b);
    }
    b = Bopen(file, OREAD);
    if(b == nil)
        sysfatal("can't read from %s", file);
    updateQid(Bfildes(b), &qid);

    cleartab(redirtab);
    cleartab(vhosttab);

    while((line = Brdline(b, '\n')) != nil){
        line[Blinelen(b)-1] = 0;
        s = strchr(line, '#');
        if(s != nil && (s == line || s[-1] == ' ' || s[-1] == '\t'))
            *s = '\0'; 	/* chop comment iff after whitespace */
        if(tokenize(line, field, nelem(field)) == 2){
            if(strncmp(field[0], pfx, STRLEN(pfx)) == 0 &&
               strncmp(undecorated(field[1]), pfx, STRLEN(pfx)) != 0){
                /* url -> filename */
                host = field[0] + STRLEN(pfx);
                s = strrchr(host, '/');
                if(s)
                    *s = 0;  /* chop trailing slash */

                insert(vhosttab, estrdup(host), estrdup(field[1]));
            }else{
                insert(redirtab, estrdup(field[0]), estrdup(field[1]));
            }
        }
    }
    syslog(0, HTTPLOG, "redirectinit pid=%d", getpid());
}
@

<<function [[lookup]]([[(networking/ip/httpd/redirect.c)]])>>=
static Redir*
lookup(Redir **tab, char *pat, int count)
{
    Redir *srch;
    ulong hash;

    hash = hashasu(pat,HASHSIZE);
    for(srch = tab[hash]; srch != nil; srch = srch->next)
        if(strcmp(pat, srch->pat) == 0) {
            /* only exact match wanted? */
            if (!(srch->flags & Redironly) || count == 0)
                return srch;
        }
    return nil;
}
@

<<function [[prevslash]]>>=
static char*
prevslash(char *p, char *s)
{
    while(--s > p)
        if(*s == '/')
            break;
    return s;
}
@

<<function [[redirect]]>>=
/*
 * find the longest match of path against the redirection table,
 * chopping off the rightmost path component until success or
 * there's nothing left.  return a copy of the replacement string
 * concatenated with a slash and the portion of the path *not* matched.
 * So a match of /who/gre/some/stuff.html matched against
 *	/who/gre	http://gremlinsrus.org
 * returns
 *	http://gremlinsrus.org/some/stuff.html
 *
 * further flags: if Redironly, match only the named page and no
 * subordinate ones.  if Redirsubord, map the named patch and any
 * subordinate ones to the same replacement URL.
 */
char*
redirect(HConnect *hc, char *path, uint *flagp)
{
    Redir *redir;
    char *s, *newpath, *repl;
    int c, n, count;

    count = 0;
    for(s = strchr(path, '\0'); s > path; s = prevslash(path, s)){
        c = *s;
        *s = '\0';
        redir = lookup(redirtab, path, count++);
        *s = c;
        if(redir != nil){
            if (flagp)
                *flagp = redir->flags;
            repl = redir->repl;
            if(redir->flags & Redirsubord)
                /* don't append s, all matches map to repl */
                s = "";
            n = strlen(repl) + strlen(s) + 2 + UTFmax;
            newpath = halloc(hc, n);
            snprint(newpath, n, "%s%s", repl, s);
            return newpath;
        }
    }
    return nil;
}
@

<<function [[masquerade]]>>=
/*
 * if host is virtual, return implicit prefix for URI within webroot.
 * if not, return empty string.
 * return value should not be freed by caller.
 */
char*
masquerade(char *host)
{
    Redir *redir;

    redir = lookup(vhosttab, host, 0);
    if(redir == nil)
        return emptystring;
    return redir->repl;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/redirect.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

<<enum [[_anon_ (networking/ip/httpd/redirect.c)]]>>

typedef struct Redir	Redir;
<<struct [[Redir]]>>

<<global [[redirtab]]>>
<<global [[vhosttab]]>>
<<global [[emptystring]]>>
<<global [[decorations]]>>
<<global [[redirflags]]>>

<<function [[isdecorated]]>>

<<function [[decor2flags]]>>

<<function [[undecorated]]>>

<<function [[hashasu]]>>

<<function [[insert]]>>

<<function [[cleartab]]>>

<<function [[redirectinit]]>>

<<function [[lookup]]([[(networking/ip/httpd/redirect.c)]])>>

<<function [[prevslash]]>>

<<function [[redirect]]>>

<<function [[masquerade]]>>
@


\subsection*{[[networking/ip/httpd/save.c]]}

<<enum [[_anon_ (networking/ip/httpd/save.c)]]>>=
enum
{
    MaxLog		= 24*1024,		/* limit on length of any one log request */
    LockSecs	= MaxLog/500,		/* seconds to wait before giving up on opening the data file */
};
@

<<function [[dangerous]]>>=
static int
dangerous(char *s)
{
    if(s == nil)
        return 1;

    /*
     * This check shouldn't be needed;
     * filename folding is already supposed to have happened.
     * But I'm paranoid.
     */
    while(s = strchr(s,'/')){
        if(s[1]=='.' && s[2]=='.')
            return 1;
        s++;
    }
    return 0;
}
@

<<function [[openLocked]]>>=
/*
 * open a file which might be locked.
 * if it is, spin until available
 */
int
openLocked(char *file, int mode)
{
    char buf[ERRMAX];
    int tries, fd;

    for(tries = 0; tries < LockSecs*2; tries++){
        fd = open(file, mode);
        if(fd >= 0)
            return fd;
        errstr(buf, sizeof buf);
        if(strstr(buf, "locked") == nil)
            break;
        sleep(500);
    }
    return -1;
}
@

<<function [[main]]([[(networking/ip/httpd/save.c)]])>>=
void
main(int argc, char **argv)
{
    HConnect *c;
    Dir *dir;
    Hio *hin, *hout;
    char *s, *t, *fn;
    int n, nfn, datafd, htmlfd;

    c = init(argc, argv);

    if(dangerous(c->req.uri)){
        hfail(c, HSyntax);
        exits("failed");
    }

    if(hparseheaders(c, HSTIMEOUT) < 0)
        exits("failed");
    hout = &c->hout;
    if(c->head.expectother){
        hfail(c, HExpectFail, nil);
        exits("failed");
    }
    if(c->head.expectcont){
        hprint(hout, "100 Continue\r\n");
        hprint(hout, "\r\n");
        hflush(hout);
    }

    s = nil;
    if(strcmp(c->req.meth, "POST") == 0){
        hin = hbodypush(&c->hin, c->head.contlen, c->head.transenc);
        if(hin != nil){
            alarm(HSTIMEOUT);
            s = hreadbuf(hin, hin->pos);
            alarm(0);
        }
        if(s == nil){
            hfail(c, HBadReq, nil);
            exits("failed");
        }
        t = strchr(s, '\n');
        if(t != nil)
            *t = '\0';
    }else if(strcmp(c->req.meth, "GET") != 0 && strcmp(c->req.meth, "HEAD") != 0){
        hunallowed(c, "GET, HEAD, PUT");
        exits("unallowed");
    }else
        s = c->req.search;
    if(s == nil){
        hfail(c, HNoData, "save");
        exits("failed");
    }

    if(strlen(s) > MaxLog)
        s[MaxLog] = '\0';
    n = snprint(c->xferbuf, HBufSize, "at %ld %s\n", time(0), s);


    nfn = strlen(c->req.uri) + 64;
    fn = halloc(c, nfn);

    /*
     * open file descriptors & write log line
     */
    snprint(fn, nfn, "/usr/web/save/%s.html", c->req.uri);
    htmlfd = open(fn, OREAD);
    if(htmlfd < 0 || (dir = dirfstat(htmlfd)) == nil){
        hfail(c, HNotFound, c->req.uri);
        exits("failed");
        return;
    }

    snprint(fn, nfn, "/usr/web/save/%s.data", c->req.uri);
    datafd = openLocked(fn, OWRITE);
    if(datafd < 0){
        errstr(c->xferbuf, sizeof c->xferbuf);
        if(strstr(c->xferbuf, "locked") != nil)
            hfail(c, HTempFail, c->req.uri);
        else
            hfail(c, HNotFound, c->req.uri);
        exits("failed");
    }
    seek(datafd, 0, 2);
    write(datafd, c->xferbuf, n);
    close(datafd);

    sendfd(c, htmlfd, dir, hmkcontent(c, "text", "html", nil), nil);

    exits(nil);
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/save.c>>=
/*
 * for GET or POST to /magic/save/foo.
 * add incoming data to foo.data.
 * send foo.html as reply.
 *
 * supports foo.data with "exclusive use" mode to prevent interleaved saves.
 * thus http://cm.bell-labs.com/magic/save/t?args should access:
 * -lrw-rw--w- M 21470 ehg web 1533 May 21 18:19 /usr/web/save/t.data
 * --rw-rw-r-- M 21470 ehg web   73 May 21 18:17 /usr/web/save/t.html
*/
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

<<enum [[_anon_ (networking/ip/httpd/save.c)]]>>

<<function [[dangerous]]>>

<<function [[openLocked]]>>

<<function [[main]]([[(networking/ip/httpd/save.c)]])>>
@


\subsection*{[[networking/ip/httpd/sendfd.c]]}

<<constant [[UNAUTHED]]([[(networking/ip/httpd/sendfd.c)]])>>=
/*
 * these should be done better; see the reponse codes in /lib/rfc/rfc2616 for
 * more info on what should be included.
 */
#define UNAUTHED	"You are not authorized to see this area.\n"
@

<<constant [[NOCONTENT]]>>=
#define NOCONTENT	"No acceptable type of data is available.\n"
@

<<constant [[NOENCODE]]>>=
#define NOENCODE	"No acceptable encoding of the contents is available.\n"
@

<<constant [[UNMATCHED]]>>=
#define UNMATCHED	"The entity requested does not match the existing entity.\n"
@

<<constant [[BADRANGE]]>>=
#define BADRANGE	"No bytes are avaible for the range you requested.\n"
@

<<function [[sendfd]]>>=
/*
 * fd references a file which has been authorized & checked for relocations.
 * send back the headers & its contents.
 * includes checks for conditional requests & ranges.
 */
int
sendfd(HConnect *c, int fd, Dir *dir, HContent *type, HContent *enc)
{
    Qid qid;
    HRange *r;
    HContents conts;
    Hio *hout;
    char *boundary, etag[32];
    long mtime;
    ulong tr;
    int n, nw, multir, ok;
    vlong wrote, length;

    hout = &c->hout;
    length = dir->length;
    mtime = dir->mtime;
    qid = dir->qid;
    free(dir);

    /*
     * figure out the type of file and send headers
     */
    n = -1;
    r = nil;
    multir = 0;
    boundary = nil;
    if(c->req.vermaj){
        if(type == nil && enc == nil){
            conts = uriclass(c, c->req.uri);
            type = conts.type;
            enc = conts.encoding;
            if(type == nil && enc == nil){
                n = read(fd, c->xferbuf, HBufSize-1);
                if(n > 0){
                    c->xferbuf[n] = '\0';
                    conts = dataclass(c, c->xferbuf, n);
                    type = conts.type;
                    enc = conts.encoding;
                }
            }
        }
        if(type == nil)
            type = hmkcontent(c, "application", "octet-stream", nil);

        snprint(etag, sizeof(etag), "\"%lluxv%lux\"", qid.path, qid.vers);
        ok = checkreq(c, type, enc, mtime, etag);
        if(ok <= 0){
            close(fd);
            return ok;
        }

        /*
         * check for if-range requests
         */
        if(c->head.range == nil
        || c->head.ifrangeetag != nil && !etagmatch(1, c->head.ifrangeetag, etag)
        || c->head.ifrangedate != 0 && c->head.ifrangedate != mtime){
            c->head.range = nil;
            c->head.ifrangeetag = nil;
            c->head.ifrangedate = 0;
        }

        if(c->head.range != nil){
            c->head.range = fixrange(c->head.range, length);
            if(c->head.range == nil){
                if(c->head.ifrangeetag == nil && c->head.ifrangedate == 0){
                    hprint(hout, "%s 416 Request range not satisfiable\r\n", hversion);
                    hprint(hout, "Date: %D\r\n", time(nil));
                    hprint(hout, "Server: Plan9\r\n");
                    hprint(hout, "Content-Range: bytes */%lld\r\n", length);
                    hprint(hout, "Content-Length: %d\r\n", STRLEN(BADRANGE));
                    hprint(hout, "Content-Type: text/html\r\n");
                    if(c->head.closeit)
                        hprint(hout, "Connection: close\r\n");
                    else if(!http11(c))
                        hprint(hout, "Connection: Keep-Alive\r\n");
                    hprint(hout, "\r\n");
                    if(strcmp(c->req.meth, "HEAD") != 0)
                        hprint(hout, "%s", BADRANGE);
                    hflush(hout);
                    writelog(c, "Reply: 416 Request range not satisfiable\n");
                    close(fd);
                    return 1;
                }
                c->head.ifrangeetag = nil;
                c->head.ifrangedate = 0;
            }
        }
        if(c->head.range == nil)
            hprint(hout, "%s 200 OK\r\n", hversion);
        else
            hprint(hout, "%s 206 Partial Content\r\n", hversion);

        hprint(hout, "Server: Plan9\r\n");
        hprint(hout, "Date: %D\r\n", time(nil));
        hprint(hout, "ETag: %s\r\n", etag);

        /*
         * can't send some entity headers if partially responding
         * to an if-range: etag request
         */
        r = c->head.range;
        if(r == nil)
            hprint(hout, "Content-Length: %lld\r\n", length);
        else if(r->next == nil){
            hprint(hout, "Content-Range: bytes %ld-%ld/%lld\r\n", r->start, r->stop, length);
            hprint(hout, "Content-Length: %ld\r\n", r->stop - r->start);
        }else{
            multir = 1;
            boundary = hmkmimeboundary(c);
            hprint(hout, "Content-Type: multipart/byteranges; boundary=%s\r\n", boundary);
        }
        if(c->head.ifrangeetag == nil){
            hprint(hout, "Last-Modified: %D\r\n", mtime);
            if(!multir)
                printtype(hout, type, enc);
            if(c->head.fresh_thresh)
                hintprint(c, hout, c->req.uri, c->head.fresh_thresh, c->head.fresh_have);
        }

        if(c->head.closeit)
            hprint(hout, "Connection: close\r\n");
        else if(!http11(c))
            hprint(hout, "Connection: Keep-Alive\r\n");
        hprint(hout, "\r\n");
    }
    if(strcmp(c->req.meth, "HEAD") == 0){
        if(c->head.range == nil)
            writelog(c, "Reply: 200 file 0\n");
        else
            writelog(c, "Reply: 206 file 0\n");
        hflush(hout);
        close(fd);
        return 1;
    }

    /*
     * send the file if it's a normal file
     */
    if(r == nil){
        hflush(hout);

        wrote = 0;
        if(n > 0)
            wrote = write(hout->fd, c->xferbuf, n);
        if(n <= 0 || wrote == n){
            while((n = read(fd, c->xferbuf, HBufSize)) > 0){
                nw = write(hout->fd, c->xferbuf, n);
                if(nw != n){
                    if(nw > 0)
                        wrote += nw;
                    break;
                }
                wrote += nw;
            }
        }
        writelog(c, "Reply: 200 file %lld %lld\n", length, wrote);
        close(fd);
        if(length == wrote)
            return 1;
        return -1;
    }

    /*
     * for multipart/byterange messages,
     * it is not ok for the boundary string to appear within a message part.
     * however, it probably doesn't matter, since there are lengths for every part.
     */
    wrote = 0;
    ok = 1;
    for(; r != nil; r = r->next){
        if(multir){
            hprint(hout, "\r\n--%s\r\n", boundary);
            printtype(hout, type, enc);
            hprint(hout, "Content-Range: bytes %ld-%ld/%lld\r\n", r->start, r->stop, length);
            hprint(hout, "Content-Length: %ld\r\n", r->stop - r->start);
            hprint(hout, "\r\n");
        }
        hflush(hout);

        if(seek(fd, r->start, 0) != r->start){
            ok = -1;
            break;
        }
        for(tr = r->stop - r->start + 1; tr; tr -= n){
            n = tr;
            if(n > HBufSize)
                n = HBufSize;
            if(read(fd, c->xferbuf, n) != n){
                ok = -1;
                goto breakout;
            }
            nw = write(hout->fd, c->xferbuf, n);
            if(nw != n){
                if(nw > 0)
                    wrote += nw;
                ok = -1;
                goto breakout;
            }
            wrote += nw;
        }
    }
breakout:;
    if(r == nil){
        if(multir){
            hprint(hout, "--%s--\r\n", boundary);
            hflush(hout);
        }
        writelog(c, "Reply: 206 partial content %lld %lld\n", length, wrote);
    }else
        writelog(c, "Reply: 206 partial content, early termination %lld %lld\n", length, wrote);
    close(fd);
    return ok;
}
@

<<function [[printtype]]>>=
static void
printtype(Hio *hout, HContent *type, HContent *enc)
{
    hprint(hout, "Content-Type: %s/%s", type->generic, type->specific);
/*
    if(cistrcmp(type->generic, "text") == 0)
        hprint(hout, ";charset=utf-8");
*/
    hprint(hout, "\r\n");
    if(enc != nil)
        hprint(hout, "Content-Encoding: %s\r\n", enc->generic);
}
@

<<function [[etagmatch]]>>=
int
etagmatch(int strong, HETag *tags, char *e)
{
    char *s, *t;

    for(; tags != nil; tags = tags->next){
        if(strong && tags->weak)
            continue;
        s = tags->etag;
        if(s[0] == '*' && s[1] == '\0')
            return 1;

        t = e + 1;
        while(*t != '"'){
            if(*s != *t)
                break;
            s++;
            t++;
        }

        if(*s == '\0' && *t == '"')
            return 1;
    }
    return 0;
}
@

<<function [[acceptcont]]>>=
static char *
acceptcont(char *s, char *e, HContent *ok, char *which)
{
    char *sep;

    if(ok == nil)
        return seprint(s, e, "Your browser accepts any %s.<br>\n", which);
    s = seprint(s, e, "Your browser accepts %s: ", which);
    sep = "";
    for(; ok != nil; ok = ok->next){
        if(ok->specific)
            s = seprint(s, e, "%s%s/%s", sep, ok->generic, ok->specific);
        else
            s = seprint(s, e, "%s%s", sep, ok->generic);
        sep = ", ";
    }
    return seprint(s, e, ".<br>\n");
}
@

<<function [[notaccept]]>>=
/*
 * send back a nice error message if the content is unacceptable
 * to get this message in ie, go to tools, internet options, advanced,
 * and turn off Show Friendly HTTP Error Messages under the Browsing category
 */
static int
notaccept(HConnect *c, HContent *type, HContent *enc, char *which)
{
    Hio *hout;
    char *s, *e;

    hout = &c->hout;
    e = &c->xferbuf[HBufSize];
    s = c->xferbuf;
    s = seprint(s, e, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n");
    s = seprint(s, e, "<html>\n<title>Unacceptable %s</title>\n<body>\n", which);
    s = seprint(s, e, "Your browser will not accept this data, %H, because of its %s.<br>\n", c->req.uri, which);
    s = seprint(s, e, "Its Content-Type is %s/%s", type->generic, type->specific);
    if(enc != nil)
        s = seprint(s, e, ", and Content-Encoding is %s", enc->generic);
    s = seprint(s, e, ".<br>\n\n");

    s = acceptcont(s, e, c->head.oktype, "Content-Type");
    s = acceptcont(s, e, c->head.okencode, "Content-Encoding");
    s = seprint(s, e, "</body>\n</html>\n");

    hprint(hout, "%s 406 Not Acceptable\r\n", hversion);
    hprint(hout, "Server: Plan9\r\n");
    hprint(hout, "Date: %D\r\n", time(nil));
    hprint(hout, "Content-Type: text/html\r\n");
    hprint(hout, "Content-Length: %lud\r\n", s - c->xferbuf);
    if(c->head.closeit)
        hprint(hout, "Connection: close\r\n");
    else if(!http11(c))
        hprint(hout, "Connection: Keep-Alive\r\n");
    hprint(hout, "\r\n");
    if(strcmp(c->req.meth, "HEAD") != 0)
        hwrite(hout, c->xferbuf, s - c->xferbuf);
    writelog(c, "Reply: 406 Not Acceptable\nReason: %s\n", which);
    return hflush(hout);
}
@

<<function [[checkreq]]>>=
/*
 * check time and entity tag conditions.
 */
int
checkreq(HConnect *c, HContent *type, HContent *enc, long mtime, char *etag)
{
    Hio *hout;
    int m;

    hout = &c->hout;
    if(c->req.vermaj >= 1 && c->req.vermin >= 1 && !hcheckcontent(type, c->head.oktype, "Content-Type", 0))
        return notaccept(c, type, enc, "Content-Type");
    if(c->req.vermaj >= 1 && c->req.vermin >= 1 && !hcheckcontent(enc, c->head.okencode, "Content-Encoding", 0))
        return notaccept(c, type, enc, "Content-Encoding");

    /*
     * can use weak match only with get or head;
     * this always uses strong matches
     */
    m = etagmatch(1, c->head.ifnomatch, etag);

    if(m && strcmp(c->req.meth, "GET") != 0 && strcmp(c->req.meth, "HEAD") != 0
    || c->head.ifunmodsince && c->head.ifunmodsince < mtime
    || c->head.ifmatch != nil && !etagmatch(1, c->head.ifmatch, etag)){
        hprint(hout, "%s 412 Precondition Failed\r\n", hversion);
        hprint(hout, "Server: Plan9\r\n");
        hprint(hout, "Date: %D\r\n", time(nil));
        hprint(hout, "Content-Type: text/html\r\n");
        hprint(hout, "Content-Length: %d\r\n", STRLEN(UNMATCHED));
        if(c->head.closeit)
            hprint(hout, "Connection: close\r\n");
        else if(!http11(c))
            hprint(hout, "Connection: Keep-Alive\r\n");
        hprint(hout, "\r\n");
        if(strcmp(c->req.meth, "HEAD") != 0)
            hprint(hout, "%s", UNMATCHED);
        writelog(c, "Reply: 412 Precondition Failed\n");
        return hflush(hout);
    }

    if(c->head.ifmodsince >= mtime
    && (m || c->head.ifnomatch == nil)){
        /*
         * can only send back Date, ETag, Content-Location,
         * Expires, Cache-Control, and Vary entity-headers
         */
        hprint(hout, "%s 304 Not Modified\r\n", hversion);
        hprint(hout, "Server: Plan9\r\n");
        hprint(hout, "Date: %D\r\n", time(nil));
        hprint(hout, "ETag: %s\r\n", etag);
        if(c->head.closeit)
            hprint(hout, "Connection: close\r\n");
        else if(!http11(c))
            hprint(hout, "Connection: Keep-Alive\r\n");
        hprint(hout, "\r\n");
        writelog(c, "Reply: 304 Not Modified\n");
        return hflush(hout);
    }
    return 1;
}
@

<<function [[fixrange]]>>=
/*
 * length is the actual length of the entity requested.
 * discard any range requests which are invalid,
 * ie start after the end, or have stop before start.
 * rewrite suffix requests
 */
HRange*
fixrange(HRange *h, long length)
{
    HRange *r, *rr;

    if(length == 0)
        return nil;

    /*
     * rewrite each range to reflect the actual length of the file
     * toss out any invalid ranges
     */
    rr = nil;
    for(r = h; r != nil; r = r->next){
        if(r->suffix){
            r->start = length - r->stop;
            if(r->start >= length)
                r->start = 0;
            r->stop = length - 1;
            r->suffix = 0;
        }
        if(r->stop >= length)
            r->stop = length - 1;
        if(r->start > r->stop){
            if(rr == nil)
                h = r->next;
            else
                rr->next = r->next;
        }else
            rr = r;
    }

    /*
     * merge consecutive overlapping or abutting ranges
     *
     * not clear from rfc2616 how much merging needs to be done.
     * this code merges only if a range is adjacent to a later starting,
     * over overlapping or abutting range.  this allows a client
     * to request wanted data first, followed by other data.
     * this may be useful then fetching part of a page, then the adjacent regions.
     */
    if(h == nil)
        return h;
    r = h;
    for(;;){
        rr = r->next;
        if(rr == nil)
            break;
        if(r->start <= rr->start && r->stop + 1 >= rr->start){
            if(r->stop < rr->stop)
                r->stop = rr->stop;
            r->next = rr->next;
        }else
            r = rr;
    }
    return h;
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/sendfd.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include "httpd.h"
#include "httpsrv.h"

static	void		printtype(Hio *hout, HContent *type, HContent *enc);

<<constant [[UNAUTHED]]([[(networking/ip/httpd/sendfd.c)]])>>
<<constant [[NOCONTENT]]>>
<<constant [[NOENCODE]]>>
<<constant [[UNMATCHED]]>>
<<constant [[BADRANGE]]>>

<<function [[sendfd]]>>

<<function [[printtype]]>>

<<function [[etagmatch]]>>

<<function [[acceptcont]]>>

<<function [[notaccept]]>>

<<function [[checkreq]]>>

<<function [[fixrange]]>>
@


\subsection*{[[networking/ip/httpd/webls.c]]}

<<global [[hout]]([[(networking/ip/httpd/webls.c)]])>>=
static	Hio		*hout;
@

<<global [[houtb]]([[(networking/ip/httpd/webls.c)]])>>=
static	Hio		houtb;
@

<<global [[connect]]([[(networking/ip/httpd/webls.c)]])>>=
static	HConnect	*connect;
@

<<function [[doctype]]>>=
static void
doctype(void)
{
    hprint(hout, "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n");
    hprint(hout, "    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n");
}
@

<<function [[error]]([[(networking/ip/httpd/webls.c)]])>>=
void
error(char *title, char *fmt, ...)
{
    va_list arg;
    char buf[1024], *out;

    va_start(arg, fmt);
    out = vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    *out = 0;

    hprint(hout, "%s 404 %s\r\n", hversion, title);
    hprint(hout, "Date: %D\r\n", time(nil));
    hprint(hout, "Server: Plan9\r\n");
    hprint(hout, "Content-type: text/html\r\n");
    hprint(hout, "\r\n");
    doctype();
    hprint(hout, "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n");
    hprint(hout, "<head><title>%s</title></head>\n", title);
    hprint(hout, "<body>\n");
    hprint(hout, "<h1>%s</h1>\n", title);
    hprint(hout, "%s\n", buf);
    hprint(hout, "</body>\n");
    hprint(hout, "</html>\n");
    hflush(hout);
    writelog(connect, "Reply: 404\nReason: %s\n", title);
    exits(nil);
}
@

<<function [[getre]]>>=
/*
 * Are we actually allowed to look in here?
 *
 * Rules:
 *	1) If neither allowed nor denied files exist, access is granted.
 *	2) If allowed exists and denied does not, dir *must* be in allowed
 *	   for access to be granted, otherwise, access is denied.
 *	3) If denied exists and allowed does not, dir *must not* be in
 *	   denied for access to be granted, otherwise, access is enied.
 *	4) If both exist, okay if either (a) file is not in denied, or
 *	   (b) in denied and in allowed.  Otherwise, access is denied.
 */
static Reprog *
getre(Biobuf *buf)
{
    Reprog	*re;
    char	*p, *t;
    char	*bbuf;
    int	n;

    if (buf == nil)
        return(nil);
    for ( ; ; free(p)) {
        p = Brdstr(buf, '\n', 0);
        if (p == nil)
            return(nil);
        t = strchr(p, '#');
        if (t != nil)
            *t = '\0';
        t = p + strlen(p);
        while (--t > p && isspace(*t))
            *t = '\0';
        n = strlen(p);
        if (n == 0)
            continue;

        /* root the regular expresssion */
        bbuf = malloc(n+2);
        if(bbuf == nil)
            sysfatal("out of memory");
        bbuf[0] = '^';
        strcpy(bbuf+1, p);
        re = regcomp(bbuf);
        free(bbuf);

        if (re == nil)
            continue;
        free(p);
        return(re);
    }
}
@

<<function [[allowed]]>>=
static int
allowed(char *dir)
{
    Reprog	*re;
    int	okay;
    Resub	match;

    if (strcmp(dir, "..") == 0 || strncmp(dir, "../", 3) == 0)
        return(0);
    if (aio == nil)
        return(0);

    if (aio != nil)
        Bseek(aio, 0, 0);
    if (dio != nil)
        Bseek(dio, 0, 0);

    /* if no deny list, assume everything is denied */
    okay = (dio != nil);

    /* go through denials till we find a match */
    while (okay && (re = getre(dio)) != nil) {
        memset(&match, 0, sizeof(match));
        okay = (regexec(re, dir, &match, 1) != 1);
        free(re);
    }

    /* go through accepts till we have a match */
    if (aio == nil)
        return(okay);
    while (!okay && (re = getre(aio)) != nil) {
        memset(&match, 0, sizeof(match));
        okay = (regexec(re, dir, &match, 1) == 1);
        free(re);
    }
    return(okay);
}
@

<<function [[compar]]>>=
/*
 * Comparison routine for sorting the directory.
 */
static int
compar(Dir *a, Dir *b)
{
    return(strcmp(a->name, b->name));
}
@

<<function [[maxwidths]]>>=
/*
 * These is for formating; how wide are variable-length
 * fields?
 */
static void
maxwidths(Dir *dp, long n)
{
    long	i;
    char	scratch[64];

    for (i = 0; i < n; i++) {
        if (snprint(scratch, sizeof scratch, "%ud", dp[i].dev) > devwidth)
            devwidth = strlen(scratch);
        if (strlen(dp[i].uid) > uidwidth)
            uidwidth = strlen(dp[i].uid);
        if (strlen(dp[i].gid) > gidwidth)
            gidwidth = strlen(dp[i].gid);
        if (snprint(scratch, sizeof scratch, "%lld", dp[i].length) > lenwidth)
            lenwidth = strlen(scratch);
    }
}
@

<<function [[asciitime]]>>=
/*
 * Do an actual directory listing.
 * asciitime is lifted directly out of ls.
 */
char *
asciitime(long l)
{
    ulong clk;
    static char buf[32];
    char *t;

    clk = time(nil);
    t = ctime(l);
    /* 6 months in the past or a day in the future */
    if(l<clk-180L*24*60*60 || clk+24L*60*60<l){
        memmove(buf, t+4, 7);		/* month and day */
        memmove(buf+7, t+23, 5);		/* year */
    }else
        memmove(buf, t+4, 12);		/* skip day of week */
    buf[12] = 0;
    return buf;
}
@

<<function [[dols]]>>=
static void
dols(char *dir)
{
    Dir	*d;
    char	*f, *p,*nm;
    long	i, n;
    int	fd;

    cleanname(dir); //  expands "" to "."; ``dir+1'' access below depends on that
    if (!allowed(dir)) {
        error("Permission denied", "<p>Cannot list directory %s: Access prohibited</p>", dir);
        return;
    }
    fd = open(dir, OREAD);
    if (fd < 0) {
        error("Cannot read directory", "<p>Cannot read directory %s: %r</p>", dir);
        return;
    }
    if (vermaj) {
        hokheaders(connect);
        hprint(hout, "Content-type: text/html\r\n");
        hprint(hout, "\r\n");
    }
    doctype();
    hprint(hout, "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n");
    hprint(hout, "<head><title>Index of %s</title></head>\n", dir);
    hprint(hout, "<body>\n");
    hprint(hout, "<h1>Index of ");
    nm = dir;
    while((p = strchr(nm, '/')) != nil){
        *p = '\0';
        f = (*dir == '\0') ? "/" : dir;
        if (!(*dir == '\0' && *(dir+1) == '\0') && allowed(f))
            hprint(hout, "<a href=\"/magic/webls?dir=%H\">%s/</a>", f, nm);
        else
            hprint(hout, "%s/", nm);
        *p = '/';
        nm = p+1;
    }
    hprint(hout, "%s</h1>\n", nm);
    n = dirreadall(fd, &d);
    close(fd);
    maxwidths(d, n);
    qsort(d, n, sizeof(Dir), (int (*)(void *, void *))compar);
    hprint(hout, "<pre>\n");
    for (i = 0; i < n; i++) {
        f = smprint("%s/%s", dir, d[i].name);
        cleanname(f);
        if (d[i].mode & DMDIR) {
            p = smprint("/magic/webls?dir=%H", f);
            free(f);
            f = p;
        }
        hprint(hout, "%M %C %*ud %-*s %-*s %*lld %s <a href=\"%s\">%s</a>\n",
            d[i].mode, d[i].type,
            devwidth, d[i].dev,
            uidwidth, d[i].uid,
            gidwidth, d[i].gid,
            lenwidth, d[i].length,
            asciitime(d[i].mtime), f, d[i].name);
        free(f);
    }
    f = smprint("%s/..", dir);
    cleanname(f);
    if (strcmp(f, dir) != 0 && allowed(f))
        hprint(hout, "\nGo to <a href=\"/magic/webls?dir=%H\">parent</a> directory\n", f);
    else
        hprint(hout, "\nEnd of directory listing\n");
    free(f);
    hprint(hout, "</pre>\n</body>\n</html>\n");
    hflush(hout);
    free(d);
}
@

<<function [[dosearch]]([[(networking/ip/httpd/webls.c)]])>>=
/*
 * Handle unpacking the request in the URI and
 * invoking the actual handler.
 */
static void
dosearch(char *search)
{
    if (strncmp(search, "dir=", 4) == 0){
        search = hurlunesc(connect, search+4);
        dols(search);
        return;
    }

    /*
     * Otherwise, we've gotten an illegal request.
     * spit out a non-apologetic error.
     */
    search = hurlunesc(connect, search);
    error("Bad directory listing request",
        "<p>Illegal formatted directory listing request:</p>\n"
        "<p>%H</p>", search);
}
@

<<function [[main]]([[(networking/ip/httpd/webls.c)]])>>=
void
main(int argc, char **argv)
{
    fmtinstall('H', httpfmt);
    fmtinstall('U', hurlfmt);
    fmtinstall('M', dirmodefmt);

    aio = Bopen("/sys/lib/webls.allowed", OREAD);
    dio = Bopen("/sys/lib/webls.denied", OREAD);

    if(argc == 2){
        hinit(&houtb, 1, Hwrite);
        hout = &houtb;
        dols(argv[1]);
        exits(nil);
    }
    close(2);

    connect = init(argc, argv);
    hout = &connect->hout;
    vermaj = connect->req.vermaj;
    if(hparseheaders(connect, HSTIMEOUT) < 0)
        exits("failed");

    if(strcmp(connect->req.meth, "GET") != 0 && strcmp(connect->req.meth, "HEAD") != 0){
        hunallowed(connect, "GET, HEAD");
        exits("not allowed");
    }
    if(connect->head.expectother || connect->head.expectcont){
        hfail(connect, HExpectFail, nil);
        exits("failed");
    }

    bind(webroot, "/", MREPL);

    if(connect->req.search != nil)
        dosearch(connect->req.search);
    else
        error("Bad argument", "<p>Need a search argument</p>");
    hflush(hout);
    writelog(connect, "200 webls %ld %ld\n", hout->seek, hout->seek);
    exits(nil);
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/webls.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>
#include <bio.h>
#include <regexp.h>
#include <fcall.h>
#include "httpd.h"
#include "httpsrv.h"

<<global [[hout]]([[(networking/ip/httpd/webls.c)]])>>
<<global [[houtb]]([[(networking/ip/httpd/webls.c)]])>>
<<global [[connect]]([[(networking/ip/httpd/webls.c)]])>>
static	int		vermaj, gidwidth, uidwidth, lenwidth, devwidth;
static	Biobuf		*aio, *dio;

<<function [[doctype]]>>

<<function [[error]]([[(networking/ip/httpd/webls.c)]])>>

<<function [[getre]]>>

<<function [[allowed]]>>

<<function [[compar]]>>

<<function [[maxwidths]]>>

<<function [[asciitime]]>>

<<function [[dols]]>>

<<function [[dosearch]]([[(networking/ip/httpd/webls.c)]])>>

<<function [[main]]([[(networking/ip/httpd/webls.c)]])>>
@


\subsection*{[[networking/ip/httpd/wikipost.c]]}

<<constant [[LOG]]>>=
#define LOG "wiki"
@

<<global [[hc]]>>=
HConnect *hc;
@

<<global [[hp]]>>=
HSPriv *hp;
@

<<function [[_urlunesc]]>>=
/* go from possibly-latin1 url with escapes to utf */
char *
_urlunesc(char *s)
{
    char *t, *v, *u;
    Rune r;
    int c, n;

    /* unescape */
    u = halloc(hc, strlen(s)+1);
    for(t = u; c = *s; s++){
        if(c == '%'){
            n = s[1];
            if(n >= '0' && n <= '9')
                n = n - '0';
            else if(n >= 'A' && n <= 'F')
                n = n - 'A' + 10;
            else if(n >= 'a' && n <= 'f')
                n = n - 'a' + 10;
            else
                break;
            r = n;
            n = s[2];
            if(n >= '0' && n <= '9')
                n = n - '0';
            else if(n >= 'A' && n <= 'F')
                n = n - 'A' + 10;
            else if(n >= 'a' && n <= 'f')
                n = n - 'a' + 10;
            else
                break;
            s += 2;
            c = r*16+n;
        }
        *t++ = c;
    }
    *t = 0;

    /* latin1 heuristic */
    v = halloc(hc, UTFmax*strlen(u) + 1);
    s = u;
    t = v;
    while(*s){
        /* in decoding error, assume latin1 */
        if((n=chartorune(&r, s)) == 1 && r == 0x80)
            r = *s;
        s += n;
        t += runetochar(t, &r);
    }
    *t = 0;

    return v;
}
@

<<enum [[_anon_ (networking/ip/httpd/wikipost.c)]]>>=
enum
{
    MaxLog		= 100*1024,		/* limit on length of any one log request */
};
@

<<function [[dangerous]]([[(networking/ip/httpd/wikipost.c)]])>>=
static int
dangerous(char *s)
{
    if(s == nil)
        return 1;

    /*
     * This check shouldn't be needed;
     * filename folding is already supposed to have happened.
     * But I'm paranoid.
     */
    while(s = strchr(s,'/')){
        if(s[1]=='.' && s[2]=='.')
            return 1;
        s++;
    }
    return 0;
}
@

<<function [[unhttp]]>>=
char*
unhttp(char *s)
{
    char *p, *r, *w;

    if(s == nil)
        return nil;

    for(p=s; *p; p++)
        if(*p=='+')
            *p = ' ';
    s = _urlunesc(s);

    for(r=w=s; *r; r++){
        if(*r != '\r')
            *w++ = *r;
    }
    *w = '\0';
    return s;
}
@

<<function [[mountwiki]]>>=
void
mountwiki(HConnect *c, char *service)
{
    char buf[128];
    int fd;

    /* already in (possibly private) namespace? */
    snprint(buf, sizeof buf, "/mnt/wiki.%s/new", service);
    if (access(buf, AREAD) == 0){
        if (bind(buf, "/mnt/wiki", MREPL) < 0){
            syslog(0, LOG, "%s bind /mnt/wiki failed: %r",
                hp->remotesys);
            hfail(c, HNotFound);
            exits("bind /mnt/wiki failed");
        }
        return;
    }

    /* old way: public wikifs from /srv */
    snprint(buf, sizeof buf, "/srv/wiki.%s", service);
    if((fd = open(buf, ORDWR)) < 0){
        syslog(0, LOG, "%s open %s failed: %r", buf, hp->remotesys);
        hfail(c, HNotFound);
        exits("failed");
    }
    if(mount(fd, -1, "/mnt/wiki", MREPL, "") < 0){
        syslog(0, LOG, "%s mount /mnt/wiki failed: %r", hp->remotesys);
        hfail(c, HNotFound);
        exits("failed");
    }
    close(fd);
}
@

<<function [[dowiki]]>>=
char*
dowiki(HConnect *c, char *title, char *author, char *comment, char *base, ulong version, char *text)
{
    int fd, l, n, err;
    char *p, tmp[256];
int i;

    if((fd = open("/mnt/wiki/new", ORDWR)) < 0){
        syslog(0, LOG, "%s open /mnt/wiki/new failed: %r", hp->remotesys);
        hfail(c, HNotFound);
        exits("failed");
    }

i=0;
    if((i++,fprint(fd, "%s\nD%lud\nA%s (%s)\n", title, version, author, hp->remotesys) < 0)
    || (i++,(comment && comment[0] && fprint(fd, "C%s\n", comment) < 0))
    || (i++,fprint(fd, "\n") < 0)
    || (i++,(text[0] && write(fd, text, strlen(text)) != strlen(text)))){
        syslog(0, LOG, "%s write failed %d %ld fd %d: %r", hp->remotesys, i, strlen(text), fd);
        hfail(c, HInternal);
        exits("failed");
    }

    err = write(fd, "", 0);
    if(err)
        syslog(0, LOG, "%s commit failed %d: %r", hp->remotesys, err);

    seek(fd, 0, 0);
    if((n = read(fd, tmp, sizeof(tmp)-1)) <= 0){
        if(n == 0)
            werrstr("short read");
        syslog(0, LOG, "%s read failed: %r", hp->remotesys);
        hfail(c, HInternal);
        exits("failed");
    }

    tmp[n] = '\0';

    p = halloc(c, l=strlen(base)+strlen(tmp)+40);
    snprint(p, l, "%s/%s/%s.html", base, tmp, err ? "werror" : "index");
    return p;
}
@

<<function [[main]]([[(networking/ip/httpd/wikipost.c)]])>>=
void
main(int argc, char **argv)
{
    Hio *hin, *hout;
    char *s, *t, *p, *f[10];
    char *text, *title, *service, *base, *author, *comment, *url;
    int i, nf;
    ulong version;

    hc = init(argc, argv);
    hp = hc->private;

    if(dangerous(hc->req.uri)){
        hfail(hc, HSyntax);
        exits("failed");
    }

    if(hparseheaders(hc, HSTIMEOUT) < 0)
        exits("failed");
    hout = &hc->hout;
    if(hc->head.expectother){
        hfail(hc, HExpectFail, nil);
        exits("failed");
    }
    if(hc->head.expectcont){
        hprint(hout, "100 Continue\r\n");
        hprint(hout, "\r\n");
        hflush(hout);
    }

    s = nil;
    if(strcmp(hc->req.meth, "POST") == 0){
        hin = hbodypush(&hc->hin, hc->head.contlen, hc->head.transenc);
        if(hin != nil){
            alarm(15*60*1000);
            s = hreadbuf(hin, hin->pos);
            alarm(0);
        }
        if(s == nil){
            hfail(hc, HBadReq, nil);
            exits("failed");
        }
        t = strchr(s, '\n');
        if(t != nil)
            *t = '\0';
    }else{
        hunallowed(hc, "GET, HEAD, PUT");
        exits("unallowed");
    }

    if(s == nil){
        hfail(hc, HNoData, "wiki");
        exits("failed");
    }

    text = nil;
    title = nil;
    service = nil;
    author = "???";
    comment = "";
    base = nil;
    version = ~0;
    nf = getfields(s, f, nelem(f), 1, "&");
    for(i=0; i<nf; i++){
        if((p = strchr(f[i], '=')) == nil)
            continue;
        *p++ = '\0';
        if(strcmp(f[i], "title")==0)
            title = p;
        else if(strcmp(f[i], "version")==0)
            version = strtoul(unhttp(p), 0, 10);
        else if(strcmp(f[i], "text")==0)
            text = p;
        else if(strcmp(f[i], "service")==0)
            service = p;
        else if(strcmp(f[i], "comment")==0)
            comment = p;
        else if(strcmp(f[i], "author")==0)
            author = p;
        else if(strcmp(f[i], "base")==0)
            base = p;
    }

    syslog(0, LOG, "%s post s %s t '%s' v %ld a %s c %s b %s t 0x%p",
        hp->remotesys, service, title, (long)version, author, comment, base, text);

    title = unhttp(title);
    comment = unhttp(comment);
    service = unhttp(service);
    text = unhttp(text);
    author = unhttp(author);
    base = unhttp(base);

    if(title==nil || version==~0 || text==nil || text[0]=='\0' || base == nil 
    || service == nil || strchr(title, '\n') || strchr(comment, '\n')
    || dangerous(service) || strchr(service, '/') || strlen(service)>20){
        syslog(0, LOG, "%s failed dangerous", hp->remotesys);
        hfail(hc, HSyntax);
        exits("failed");
    }

    syslog(0, LOG, "%s post s %s t '%s' v %ld a %s c %s",
        hp->remotesys, service, title, (long)version, author, comment);

    if(strlen(text) > MaxLog)
        text[MaxLog] = '\0';

    mountwiki(hc, service);
    url = dowiki(hc, title, author, comment, base, version, text);
    hredirected(hc, "303 See Other", url);
    exits(nil);
}
@


%-------------------------------------------------------------

<<networking/ip/httpd/wikipost.c>>=
/*
 * Accept new wiki pages or modifications to existing ones via POST method.
 *
 * Talks to the server at /srv/wiki.service.
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "httpd.h"
#include "httpsrv.h"

<<constant [[LOG]]>>

<<global [[hc]]>>
<<global [[hp]]>>


<<function [[_urlunesc]]>>

<<enum [[_anon_ (networking/ip/httpd/wikipost.c)]]>>

<<function [[dangerous]]([[(networking/ip/httpd/wikipost.c)]])>>

<<function [[unhttp]]>>

<<function [[mountwiki]]>>

<<function [[dowiki]]>>


<<function [[main]]([[(networking/ip/httpd/wikipost.c)]])>>
@


\section{[[networking/ip/]]}

\subsection*{[[networking/ip/httpfile.c]]}

<<enum [[_anon_ (networking/ip/httpfile.c)]]>>=
enum
{
    Blocksize = 64*1024,
    Stacksize = 8192,
};
@

<<global [[host]]>>=
char *host;
@

<<global [[file]]>>=
char *file;
@

<<global [[port]]>>=
char *port;
@

<<global [[url]]>>=
char *url;
@

<<global [[get]]>>=
char *get;
@

<<global [[user]]([[(networking/ip/httpfile.c)]])>>=
char *user;
@

<<global [[net]]([[(networking/ip/httpfile.c)]])>>=
char *net = "net";
@

<<global [[size]]>>=
vlong size;
@

<<global [[usetls]]([[(networking/ip/httpfile.c)]])>>=
int usetls;
@

<<global [[debug]]([[(networking/ip/httpfile.c)]])>>=
int debug;
@

<<global [[ncache]]>>=
int ncache;
@

<<global [[mcache]]>>=
int mcache;
@

<<function [[usage]]([[(networking/ip/httpfile.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: httpfile [-Dd] [-c count] [-f file] [-m mtpt] [-s srvname] [-x net] url\n");
    exits("usage");
}
@

<<enum [[_anon_ (networking/ip/httpfile.c)2]]>>=
enum
{
    Qroot,
    Qfile,
};
@

<<macro [[PATH]]>>=
#define PATH(type, n)		((type)|((n)<<8))
@

<<macro [[TYPE]]([[(networking/ip/httpfile.c)]])>>=
#define TYPE(path)			((int)(path) & 0xFF)
@

<<macro [[NUM]]>>=
#define NUM(path)			((uint)(path)>>8)
@

<<global [[reqchan]]>>=
Channel *reqchan;
@

<<global [[httpchan]]>>=
Channel *httpchan;
@

<<global [[finishchan]]>>=
Channel *finishchan;
@

<<global [[time0]]>>=
ulong time0;
@

<<struct [[Block]]([[(networking/ip/httpfile.c)]])>>=
struct Block
{
    uchar *p;
    vlong off;
    vlong len;
    Block *link;
    long lastuse;
    Req *rq;
    Req **erq;
};
@

<<struct [[Blocklist]]>>=
struct Blocklist
{
    Block *first;
    Block **end;
};
@

<<global [[cache]]>>=
Blocklist cache;
@

<<global [[inprogress]]>>=
Blocklist inprogress;
@

<<function [[queuereq]]>>=
void
queuereq(Block *b, Req *r)
{
    if(b->rq==nil)
        b->erq = &b->rq;
    *b->erq = r;
    r->aux = nil;
    b->erq = (Req**)&r->aux;
}
@

<<function [[addblock]]>>=
void
addblock(Blocklist *l, Block *b)
{
    if(debug)
        print("adding: %p %lld\n", b, b->off);

    if(l->first == nil)
        l->end = &l->first;
    *l->end = b;
    b->link = nil;
    l->end = &b->link;
    b->lastuse = time(0);
}
@

<<function [[delreq]]>>=
void
delreq(Block *b, Req *r)
{
    Req **l;

    for(l = &b->rq; *l; l = (Req**)&(*l)->aux){
        if(*l == r){
            *l = r->aux;
            if(*l == nil)
                b->erq = l;
            free(r);
            return;
        }
    }
}
@

<<function [[evictblock]]>>=
void
evictblock(Blocklist *cache)
{
    Block **l, **oldest, *b;

    if(cache->first == nil)
        return;

    oldest = nil;
    for(l=&cache->first; *l; l=&(*l)->link)
        if(oldest == nil || (*oldest)->lastuse > (*l)->lastuse)
            oldest = l;

    b = *oldest;
    *oldest = (*oldest)->link;
    if(*oldest == nil)
        cache->end = oldest;
    free(b->p);
    free(b);
    ncache--;
}
@

<<function [[findblock]]>>=
Block *
findblock(Blocklist *s, vlong off)
{
    Block *b;

    for(b = s->first; b != nil; b = b->link){
        if(b->off <= off && off < b->off + Blocksize){
            if(debug)
                print("found: %lld -> %lld\n", off, b->off);
            b->lastuse = time(0);
            return b;
        }
    }

    return nil;
}
@

<<function [[readfrom]]>>=
void
readfrom(Req *r, Block *b)
{
    int d, n;

    b->lastuse = time(0);

    n = r->ifcall.count;
    d = r->ifcall.offset - b->off;
    if(b->off + d + n > b->off + b->len)
        n = b->len - d;
    if(debug)
        print("Reading from: %p %d %d\n", b->p, d, n);
    memmove(r->ofcall.data, b->p + d, n);
    r->ofcall.count = n;

    respond(r, nil);
}
@

<<function [[hangupclient]]>>=
void
hangupclient(Srv*)
{
    if(debug)
        print("Hangup.\n");

    threadexitsall("done");
}
@

<<function [[dotls]]>>=
int
dotls(int fd)
{
    TLSconn conn;

    if((fd=tlsClient(fd, &conn)) < 0)
        sysfatal("tlsclient: %r");

    if(conn.cert != nil)
        free(conn.cert);

    return fd;
}
@

<<function [[nocr]]>>=
char*
nocr(char *s)
{
    char *r, *w;

    for(r=w=s; *r; r++)
        if(*r != '\r')
            *w++ = *r;
    *w = 0;
    return s;
}
@

<<function [[readhttphdr]]>>=
char*
readhttphdr(Biobuf *netbio, vlong *size)
{
    char *s, *stat;

    stat = nil;
    while((s = Brdstr(netbio, '\n', 1)) != nil && s[0] != '\r'
            && s[0] != '\0'){
        if(stat == nil)
            stat = estrdup9p(s);
        if(strncmp(s, "Content-Length: ", 16) == 0 && size != nil)
            *size = atoll(s + 16);
        free(s);
    }
    if(stat)
        nocr(stat);

    return stat;
}
@

<<function [[dialhttp]]>>=
int
dialhttp(Biobuf *netbio)
{
    int netfd;

    netfd = dial(netmkaddr(host, net, port), 0, 0, 0);
    if(netfd < 0)
        sysfatal("dial: %r");
    if(usetls)
        netfd = dotls(netfd);
    Binit(netbio, netfd, OREAD);

    return netfd;
}
@

<<function [[getrange]]>>=
uchar*
getrange(Block *b)
{
    uchar *data;
    char *status;
    int netfd;
    static Biobuf netbio;

    b->len = Blocksize;
    if(b->off + b->len > size)
        b->len = size - b->off;

    if(debug)
        print("getrange: %lld %lld\n", b->off, b->len);

    netfd = dialhttp(&netbio);

    fprint(netfd, 
        "GET %s HTTP/1.1\r\n"
        "Host: %s\r\n"
        "Accept-Encoding:\r\n"
        "Range: bytes=%lld-%lld\r\n"
        "\r\n",
        get, host, b->off, b->off+b->len);
    Bflush(&netbio);

    status = readhttphdr(&netbio, nil);
    if(status == nil)
        return nil;

    /*
     * Some servers (e.g., www.google.com) return 200 OK
     * when you ask for the entire page in one range.
     */
    if(strstr(status, "206 Partial Content")==nil
    && (b->off!=0 || b->len!=size || strstr(status, "200 OK")==nil)){
        free(status);
        close(netfd);
        werrstr("did not get requested range");
        return nil;
    }
    free(status);

    data = emalloc9p(b->len);
    if(Bread(&netbio, data, b->len) != b->len){
        free(data);
        close(netfd);
        werrstr("not enough bytes read");
        return nil;
    }

    b->p = data;

    close(netfd);
    return data;
}
@

<<function [[httpfilereadproc]]>>=
void
httpfilereadproc(void*)
{
    Block *b;

    threadsetname("httpfilereadproc");

    for(;;){
        b = recvp(httpchan);
        if(b == nil)
            continue;
        if(getrange(b) == nil)
            sysfatal("getrange: %r");
        sendp(finishchan, b);
    }
}
@

<<struct [[Tab]]>>=
struct Tab
{
    char *name;
    ulong mode;
};
@

<<global [[tab]]>>=
Tab tab[] =
{
    "/",		DMDIR|0555,
    nil,		0444,
};
@

<<function [[fillstat]]>>=
static void
fillstat(Dir *d, uvlong path)
{
    Tab *t;

    memset(d, 0, sizeof(*d));
    d->uid = estrdup9p(user);
    d->gid = estrdup9p(user);
    d->qid.path = path;
    d->atime = d->mtime = time0;
    t = &tab[TYPE(path)];
    d->name = estrdup9p(t->name);
    d->length = size;
    d->qid.type = t->mode>>24;
    d->mode = t->mode;
}
@

<<function [[fsattach]]>>=
static void
fsattach(Req *r)
{
    if(r->ifcall.aname && r->ifcall.aname[0]){
        respond(r, "invalid attach specifier");
        return;
    }
    r->fid->qid.path = PATH(Qroot, 0);
    r->fid->qid.type = QTDIR;
    r->fid->qid.vers = 0;
    r->ofcall.qid = r->fid->qid;
    respond(r, nil);
}
@

<<function [[fsstat]]([[(networking/ip/httpfile.c)]])>>=
static void
fsstat(Req *r)
{
    fillstat(&r->d, r->fid->qid.path);
    respond(r, nil);
}
@

<<function [[rootgen]]>>=
static int
rootgen(int i, Dir *d, void*)
{
    i += Qroot + 1;
    if(i <= Qfile){
        fillstat(d, i);
        return 0;
    }
    return -1;
}
@

<<function [[fswalk1]]>>=
static char*
fswalk1(Fid *fid, char *name, Qid *qid)
{
    int i;
    ulong path;

    path = fid->qid.path;
    if(!(fid->qid.type & QTDIR))
        return "walk in non-directory";

    if(strcmp(name, "..") == 0){
        switch(TYPE(path)){
        case Qroot:
            return nil;
        default:
            return "bug in fswalk1";
        }
    }

    i = TYPE(path) + 1;
    while(i < nelem(tab)){
        if(strcmp(name, tab[i].name) == 0){
            qid->path = PATH(i, NUM(path));
            qid->type = tab[i].mode>>24;
            return nil;
        }
        if(tab[i].mode & DMDIR)
            break;
        i++;
    }
    return "directory entry not found";
}
@

<<function [[getfilesize]]>>=
vlong
getfilesize(void)
{
    char *status;
    vlong size;
    int netfd;
    static Biobuf netbio;

    netfd = dialhttp(&netbio);

    fprint(netfd, 
        "HEAD %s HTTP/1.1\r\n"
        "Host: %s\r\n"
        "Accept-Encoding:\r\n"
        "\r\n",
        get, host);

    status = readhttphdr(&netbio, &size);
    if(strstr(status, "200 OK") == nil){
        werrstr("%s", status);
        size = -1;
    }
    free(status);

    close(netfd);
    return size;
}
@

<<function [[fileread]]([[(networking/ip/httpfile.c)]])>>=
void
fileread(Req *r)
{
    Block *b;

    if(r->ifcall.offset > size){
        respond(r, nil);
        return;
    }

    if((b = findblock(&cache, r->ifcall.offset)) != nil){
        readfrom(r, b);
        return;
    }
    if((b = findblock(&inprogress, r->ifcall.offset)) == nil){
        b = emalloc9p(sizeof(Block));
        b->off = r->ifcall.offset - (r->ifcall.offset % Blocksize);
        addblock(&inprogress, b);
        if(inprogress.first == b)
            sendp(httpchan, b);
    }
    queuereq(b, r);
}
@

<<function [[fsopen]]>>=
static void
fsopen(Req *r)
{
    if(r->ifcall.mode != OREAD){
        respond(r, "permission denied");
        return;
    }
    respond(r, nil);
}
@

<<function [[finishthread]]>>=
void
finishthread(void*)
{
    Block *b;
    Req *r, *nextr;

    threadsetname("finishthread");

    for(;;){
        b = recvp(finishchan);
        assert(b == inprogress.first);
        inprogress.first = b->link;
        ncache++;
        if(ncache >= mcache)
            evictblock(&cache);
        addblock(&cache, b);
        for(r=b->rq; r; r=nextr){
            nextr = r->aux;
            readfrom(r, b);
        }
        b->rq = nil;
        if(inprogress.first)
            sendp(httpchan, inprogress.first);
    }
}
@

<<function [[fsnetproc]]>>=
void
fsnetproc(void*)
{
    Req *r;
    Block *b;

    threadcreate(finishthread, nil, 8192);

    threadsetname("fsnetproc");

    for(;;){
        r = recvp(reqchan);
        switch(r->ifcall.type){
        case Tflush:
            b = findblock(&inprogress, r->ifcall.offset);
            delreq(b, r->oldreq);
            respond(r->oldreq, "interrupted");
            respond(r, nil);
            break;
        case Tread:
            fileread(r);
            break;
        default:
            respond(r, "bug in fsthread");
            break;
        }
    }
}
@

<<function [[fsflush]]>>=
static void
fsflush(Req *r)
{
    sendp(reqchan, r);
}
@

<<function [[fsread]]([[(networking/ip/httpfile.c)]])>>=
static void
fsread(Req *r)
{
    char e[ERRMAX];
    ulong path;

    path = r->fid->qid.path;
    switch(TYPE(path)){
    case Qroot:
        dirread9p(r, rootgen, nil);
        respond(r, nil);
        break;
    case Qfile:
        sendp(reqchan, r);
        break;
    default:
        snprint(e, sizeof(e), "bug in fsread path=%lux", path);
        respond(r, e);
        break;
    }
}
@

<<global [[fs]]>>=
Srv fs = 
{
.attach=		fsattach,
.walk1=		fswalk1,
.open=		fsopen,
.read=		fsread,
.stat=		fsstat,
.flush=		fsflush,
.end=		hangupclient,
};
@

<<function [[threadmain]]>>=
void
threadmain(int argc, char **argv)
{
    char *defport, *mtpt, *srvname, *p;

    mtpt = nil;
    srvname = nil;
    ARGBEGIN{
    case 'D':
        chatty9p++;
        break;
    case 'd':
        debug++;
        break;
    case 's':
        srvname = EARGF(usage());
        break;
    case 'm':
        mtpt = EARGF(usage());
        break;
    case 'c':
        mcache = atoi(EARGF(usage()));
        break;
    case 'f':
        file = EARGF(usage());
        break;
    case 'x':
        net = smprint("%s/net", EARGF(usage()));
        break;
    default:
        usage();
    }ARGEND;

    if(srvname == nil && mtpt == nil)
        mtpt = ".";

    if(argc < 1)
        usage();
    if(mcache <= 0)
        mcache = 32;

    time0 = time(0);
    host = url = estrdup9p(argv[0]);

    defport = nil;
    if(!cistrncmp(url, "https://", 8)){
        host += 8;
        usetls = 1;
        defport = "https";
    }else if(!cistrncmp(url, "http://", 7)){
        host += 7;
        defport = "http";
    }else
        sysfatal("unsupported url: %s", url);

    if((p = strchr(host, '/')) != nil){
        get = estrdup9p(p);
        *p = '\0';
    }else
        get = "/";

    port = strchr(host, ':');
    if(port != nil)
        *port++ = '\0';
    else
        port = defport;

    if(file == nil){
        file = strrchr(get, '/')+1;
        if(*file == 0)
            file = "index";
    }

    tab[Qfile].name = file;
    user = getuser();
    size = getfilesize();
    if(size < 0)
        sysfatal("getfilesize: %r");

    reqchan = chancreate(sizeof(Req*), 0);
    httpchan = chancreate(sizeof(Block*), 0);
    finishchan = chancreate(sizeof(Block*), 0);

    procrfork(fsnetproc, nil, Stacksize, RFNAMEG|RFNOTEG);
    procrfork(httpfilereadproc, nil, Stacksize, RFNAMEG|RFNOTEG);

    threadpostmountsrv(&fs, srvname, mtpt, MBEFORE);
    threadexits(0);
}
@


%-------------------------------------------------------------

<<networking/ip/httpfile.c>>=
/* contributed by 20h@r-36.net, September 2005 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ndb.h>
#include <thread.h>
#include <fcall.h>
#include <9p.h>
#include <mp.h>
#include <libsec.h>

<<enum [[_anon_ (networking/ip/httpfile.c)]]>>

<<global [[host]]>>
<<global [[file]]>>
<<global [[port]]>>
<<global [[url]]>>
<<global [[get]]>>
<<global [[user]]([[(networking/ip/httpfile.c)]])>>
<<global [[net]]([[(networking/ip/httpfile.c)]])>>

<<global [[size]]>>
<<global [[usetls]]([[(networking/ip/httpfile.c)]])>>
<<global [[debug]]([[(networking/ip/httpfile.c)]])>>
<<global [[ncache]]>>
<<global [[mcache]]>>

<<function [[usage]]([[(networking/ip/httpfile.c)]])>>

<<enum [[_anon_ (networking/ip/httpfile.c)2]]>>

<<macro [[PATH]]>>
<<macro [[TYPE]]([[(networking/ip/httpfile.c)]])>>
<<macro [[NUM]]>>

<<global [[reqchan]]>>
<<global [[httpchan]]>>
<<global [[finishchan]]>>
<<global [[time0]]>>

typedef struct Block Block;
<<struct [[Block]]([[(networking/ip/httpfile.c)]])>>

typedef struct Blocklist Blocklist;
<<struct [[Blocklist]]>>

<<global [[cache]]>>
<<global [[inprogress]]>>

<<function [[queuereq]]>>

<<function [[addblock]]>>

<<function [[delreq]]>>

<<function [[evictblock]]>>

<<function [[findblock]]>>

<<function [[readfrom]]>>

<<function [[hangupclient]]>>

<<function [[dotls]]>>

<<function [[nocr]]>>

<<function [[readhttphdr]]>>

<<function [[dialhttp]]>>

<<function [[getrange]]>>

<<function [[httpfilereadproc]]>>

typedef struct Tab Tab;
<<struct [[Tab]]>>

<<global [[tab]]>>

<<function [[fillstat]]>>

<<function [[fsattach]]>>

<<function [[fsstat]]([[(networking/ip/httpfile.c)]])>>

<<function [[rootgen]]>>

<<function [[fswalk1]]>>

<<function [[getfilesize]]>>

<<function [[fileread]]([[(networking/ip/httpfile.c)]])>>

<<function [[fsopen]]>>

<<function [[finishthread]]>>

<<function [[fsnetproc]]>>

<<function [[fsflush]]>>

<<function [[fsread]]([[(networking/ip/httpfile.c)]])>>

<<global [[fs]]>>

<<function [[threadmain]]>>
@


\section{[[networking/ip/imap4d/]]}

\subsection*{[[networking/ip/imap4d/auth.c]]}

<<function [[enableForwarding]]>>=
/*
 * hack to allow smtp forwarding.
 * hide the peer IP address under a rock in the ratifier FS.
 */
void
enableForwarding(void)
{
    char buf[64], peer[64], *p;
    static ulong last;
    ulong now;
    int fd;

    if(remote == nil)
        return;

    now = time(0);
    if(now < last + 5*60)
        return;
    last = now;

    fd = open("/srv/ratify", ORDWR);
    if(fd < 0)
        return;
    if(!mount(fd, -1, "/mail/ratify", MBEFORE, "")){
        close(fd);
        return;
    }
    close(fd);

    strncpy(peer, remote, sizeof(peer));
    peer[sizeof(peer) - 1] = '\0';
    p = strchr(peer, '!');
    if(p != nil)
        *p = '\0';

    snprint(buf, sizeof(buf), "/mail/ratify/trusted/%s#32", peer);

    /*
     * if the address is already there and the user owns it,
     * remove it and recreate it to give him a new time quanta.
     */
    if(access(buf, 0) >= 0 && remove(buf) < 0)
        return;

    fd = create(buf, OREAD, 0666);
    if(fd >= 0)
        close(fd);
}
@

<<function [[setupuser]]>>=
void
setupuser(AuthInfo *ai)
{
    Waitmsg *w;
    int pid;

    if(ai){
        strecpy(username, username+sizeof username, ai->cuid);

        if(auth_chuid(ai, nil) < 0)
            bye("user auth failed: %r");
        auth_freeAI(ai);
    }else
        strecpy(username, username+sizeof username, getuser());

    if(newns(username, 0) < 0)
        bye("user login failed: %r");

    /*
     * hack to allow access to outgoing smtp forwarding
     */
    enableForwarding();

    snprint(mboxDir, MboxNameLen, "/mail/box/%s", username);
    if(myChdir(mboxDir) < 0)
        bye("can't open user's mailbox");

    switch(pid = fork()){
    case -1:
        bye("can't initialize mail system");
        break;
    case 0:
        execl("/bin/upas/fs", "upas/fs", "-np", nil);
_exits("rob1");
        _exits(0);
        break;
    default:
        break;
    }
    if((w=wait()) == nil || w->pid != pid || w->msg[0] != '\0')
        bye("can't initialize mail system");
    free(w);
}
@

<<function [[authresp]]>>=
static char*
authresp(void)
{
    char *s, *t;
    int n;

    t = Brdline(&bin, '\n');
    n = Blinelen(&bin);
    if(n < 2)
        return nil;
    n--;
    if(t[n-1] == '\r')
        n--;
    t[n] = '\0';
    if(n == 0 || strcmp(t, "*") == 0)
        return nil;

    s = binalloc(&parseBin, n + 1, 0);
    n = dec64((uchar*)s, n, t, n);
    s[n] = '\0';
    return s;
}
@

<<function [[cramauth]]>>=
/*
 * rfc 2195 cram-md5 authentication
 */
char*
cramauth(void)
{
    AuthInfo *ai;
    Chalstate *cs;
    char *s, *t;
    int n;

    if((cs = auth_challenge("proto=cram role=server")) == nil)
        return "couldn't get cram challenge";

    n = cs->nchal;
    s = binalloc(&parseBin, n * 2, 0);
    n = enc64(s, n * 2, (uchar*)cs->chal, n);
    Bprint(&bout, "+ ");
    Bwrite(&bout, s, n);
    Bprint(&bout, "\r\n");
    if(Bflush(&bout) < 0)
        writeErr();

    s = authresp();
    if(s == nil)
        return "client cancelled authentication";

    t = strchr(s, ' ');
    if(t == nil)
        bye("bad auth response");
    *t++ = '\0';
    strncpy(username, s, UserNameLen);
    username[UserNameLen-1] = '\0';

    cs->user = username;
    cs->resp = t;
    cs->nresp = strlen(t);
    if((ai = auth_response(cs)) == nil)
        return "login failed";
    auth_freechal(cs);
    setupuser(ai);
    return nil;
}
@

<<function [[passLogin]]>>=
AuthInfo*
passLogin(char *user, char *secret)
{
    AuthInfo *ai;
    Chalstate *cs;
    uchar digest[MD5dlen];
    char response[2*MD5dlen+1];
    int i;

    if((cs = auth_challenge("proto=cram role=server")) == nil)
        return nil;

    hmac_md5((uchar*)cs->chal, strlen(cs->chal),
        (uchar*)secret, strlen(secret), digest,
        nil);
    for(i = 0; i < MD5dlen; i++)
        snprint(response + 2*i, sizeof(response) - 2*i, "%2.2ux", digest[i]);

    cs->user = user;
    cs->resp = response;
    cs->nresp = strlen(response);
    ai = auth_response(cs);
    auth_freechal(cs);
    return ai;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/auth.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <libsec.h>
#include <bio.h>
#include "imap4d.h"

<<function [[enableForwarding]]>>

<<function [[setupuser]]>>

<<function [[authresp]]>>

<<function [[cramauth]]>>

<<function [[passLogin]]>>
@


\subsection*{[[networking/ip/imap4d/copy.c]]}

<<function [[copyCheck]]>>=
/*
 * check if the message exists
 */
int
copyCheck(Box *box, Msg *m, int uids, void *v)
{
    int fd;

    USED(box);
    USED(uids);
    USED(v);

    if(m->expunged)
        return 0;
    fd = msgFile(m, "raw");
    if(fd < 0){
        msgDead(m);
        return 0;
    }
    close(fd);
    return 1;
}
@

<<function [[copySave]]>>=
int
copySave(Box *box, Msg *m, int uids, void *vs)
{
    Dir *d;
    Biobuf b;
    vlong length;
    char *head;
    int ok, hfd, bfd, nhead;

    USED(box);
    USED(uids);

    if(m->expunged)
        return 0;

    hfd = msgFile(m, "unixheader");
    if(hfd < 0){
        msgDead(m);
        return 0;
    }
    head = readFile(hfd);
    if(head == nil){
        close(hfd);
        return 0;
    }

    /*
     * clear out the header if it doesn't end in a newline,
     * since it is a runt and the "header" will show up in the raw file.
     */
    nhead = strlen(head);
    if(nhead > 0 && head[nhead-1] != '\n')
        nhead = 0;

    bfd = msgFile(m, "raw");
    close(hfd);
    if(bfd < 0){
        msgDead(m);
        return 0;
    }

    d = dirfstat(bfd);
    if(d == nil){
        close(bfd);
        return 0;
    }
    length = d->length;
    free(d);

    Binit(&b, bfd, OREAD);
    ok = saveMsg(vs, m->info[IDigest], m->flags, head, nhead, &b, length);
    Bterm(&b);
    close(bfd);
    return ok;
}
@

<<function [[appendSave]]>>=
/*
 * first spool the input into a temorary file,
 * and massage the input in the process.
 * then save to real box.
 */
int
appendSave(char *mbox, int flags, char *head, Biobuf *b, long n)
{
    Biobuf btmp;
    int fd, ok;

    fd = imapTmp();
    if(fd < 0)
        return 0;
    Bprint(&bout, "+ Ready for literal data\r\n");
    if(Bflush(&bout) < 0)
        writeErr();
    Binit(&btmp, fd, OWRITE);
    n = appSpool(&btmp, b, n);
    Bterm(&btmp);
    if(n < 0){
        close(fd);
        return 0;
    }

    seek(fd, 0, 0);
    Binit(&btmp, fd, OREAD);
    ok = saveMsg(mbox, nil, flags, head, strlen(head), &btmp, n);
    Bterm(&btmp);
    close(fd);
    return ok;
}
@

<<function [[appSpool]]>>=
/*
 * copy from bin to bout,
 * mapping "\r\n" to "\n" and "\nFrom " to "\n From "
 * return the number of bytes in the mapped file.
 *
 * exactly n bytes must be read from the input,
 * unless an input error occurs.
 */
static long
appSpool(Biobuf *bout, Biobuf *bin, long n)
{
    int i, c;

    c = '\n';
    while(n > 0){
        if(c == '\n' && n >= STRLEN("From ")){
            for(i = 0; i < STRLEN("From "); i++){
                c = Bgetc(bin);
                if(c != "From "[i]){
                    if(c < 0)
                        return -1;
                    Bungetc(bin);
                    break;
                }
                n--;
            }
            if(i == STRLEN("From "))
                Bputc(bout, ' ');
            Bwrite(bout, "From ", i);
        }
        c = Bgetc(bin);
        n--;
        if(c == '\r' && n-- > 0){
            c = Bgetc(bin);
            if(c != '\n')
                Bputc(bout, '\r');
        }
        if(c < 0)
            return -1;
        if(Bputc(bout, c) < 0)
            return -1;
    }
    if(c != '\n')
        Bputc(bout, '\n');
    if(Bflush(bout) < 0)
        return -1;
    return Boffset(bout);
}
@

<<function [[saveMsg]]>>=
static int
saveMsg(char *dst, char *digest, int flags, char *head, int nhead, Biobuf *b, long n)
{
    DigestState *dstate;
    MbLock *ml;
    uchar shadig[SHA1dlen];
    char buf[BufSize + 1], digbuf[NDigest + 1];
    int i, fd, nr, nw, ok;

    ml = mbLock();
    if(ml == nil)
        return 0;
    fd = openLocked(mboxDir, dst, OWRITE);
    if(fd < 0){
        mbUnlock(ml);
        return 0;
    }
    seek(fd, 0, 2);

    dstate = nil;
    if(digest == nil)
        dstate = sha1(nil, 0, nil, nil);
    if(!saveb(fd, dstate, head, nhead, nhead)){
        if(dstate != nil)
            sha1(nil, 0, shadig, dstate);
        mbUnlock(ml);
        close(fd);
        return 0;
    }
    ok = 1;
    if(n == 0)
        ok = saveb(fd, dstate, "\n", 0, 1);
    while(n > 0){
        nr = n;
        if(nr > BufSize)
            nr = BufSize;
        nr = Bread(b, buf, nr);
        if(nr <= 0){
            saveb(fd, dstate, "\n\n", 0, 2);
            ok = 0;
            break;
        }
        n -= nr;
        nw = nr;
        if(n == 0){
            if(buf[nw - 1] != '\n')
                buf[nw++] = '\n';
            buf[nw++] = '\n';
        }
        if(!saveb(fd, dstate, buf, nr, nw)){
            ok = 0;
            break;
        }
        mbLockRefresh(ml);
    }
    close(fd);

    if(dstate != nil){
        digest = digbuf;
        sha1(nil, 0, shadig, dstate);
        for(i = 0; i < SHA1dlen; i++)
            snprint(digest+2*i, NDigest+1-2*i, "%2.2ux", shadig[i]);
    }
    if(ok){
        fd = cdOpen(mboxDir, impName(dst), OWRITE);
        if(fd < 0)
            fd = emptyImp(dst);
        if(fd >= 0){
            seek(fd, 0, 2);
            wrImpFlags(buf, flags, 1);
            fprint(fd, "%.*s %.*lud %s\n", NDigest, digest, NUid, 0UL, buf);
            close(fd);
        }
    }
    mbUnlock(ml);
    return 1;
}
@

<<function [[saveb]]>>=
static int
saveb(int fd, DigestState *dstate, char *buf, int nr, int nw)
{
    if(dstate != nil)
        sha1((uchar*)buf, nr, nil, dstate);
    if(write(fd, buf, nw) != nw)
        return 0;
    return 1;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/copy.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include <libsec.h>
#include "imap4d.h"

static int	saveMsg(char *dst, char *digest, int flags, char *head, int nhead, Biobuf *b, long n);
static int	saveb(int fd, DigestState *dstate, char *buf, int nr, int nw);
static long	appSpool(Biobuf *bout, Biobuf *bin, long n);

<<function [[copyCheck]]>>

<<function [[copySave]]>>

<<function [[appendSave]]>>

<<function [[appSpool]]>>

<<function [[saveMsg]]>>

<<function [[saveb]]>>
@


\subsection*{[[networking/ip/imap4d/csquery.c]]}

<<function [[csquery]]([[(networking/ip/imap4d/csquery.c)]])>>=
/*
 *  query the connection server
 */
char*
csquery(char *attr, char *val, char *rattr)
{
    char token[64+4];
    char buf[256], *p, *sp;
    int fd, n;

    if(val == nil || val[0] == 0)
        return nil;
    fd = open("/net/cs", ORDWR);
    if(fd < 0)
        return nil;
    fprint(fd, "!%s=%s", attr, val);
    seek(fd, 0, 0);
    snprint(token, sizeof(token), "%s=", rattr);
    for(;;){
        n = read(fd, buf, sizeof(buf)-1);
        if(n <= 0)
            break;
        buf[n] = 0;
        p = strstr(buf, token);
        if(p != nil && (p == buf || *(p-1) == 0)){
            close(fd);
            sp = strchr(p, ' ');
            if(sp)
                *sp = 0;
            p = strchr(p, '=');
            if(p == nil)
                return nil;
            return strdup(p+1);
        }
    }
    close(fd);
    return nil;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/csquery.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<function [[csquery]]([[(networking/ip/imap4d/csquery.c)]])>>
@


\subsection*{[[networking/ip/imap4d/date.c]]}

<<global [[wdayname]]>>=
char *
wdayname[7] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};
@

<<global [[monname]]([[(networking/ip/imap4d/date.c)]])>>=
char *
monname[12] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};
@

<<function [[rfc822date]]>>=
int
rfc822date(char *s, int n, Tm *tm)
{
    char *plus;
    int m;

    plus = "+";
    if(tm->tzoff < 0)
        plus = "";
    m = 0;
    if(0 <= tm->wday && tm->wday < 7){
        m = snprint(s, n, "%s, ", wdayname[tm->wday]);
        if(m < 0)
            return m;
    }
    return snprint(s+m, n-m, "%.2d %s %.4d %.2d:%.2d:%.2d %s%.4d",
        tm->mday, monname[tm->mon], tm->year+1900, tm->hour, tm->min, tm->sec,
        plus, (tm->tzoff/3600)*100 + (tm->tzoff/60)%60);
}
@

<<function [[imap4date]]>>=
int
imap4date(char *s, int n, Tm *tm)
{
    char *plus;

    plus = "+";
    if(tm->tzoff < 0)
        plus = "";
    return snprint(s, n, "%2d-%s-%.4d %2.2d:%2.2d:%2.2d %s%4.4d",
        tm->mday, monname[tm->mon], tm->year+1900, tm->hour, tm->min, tm->sec, plus, (tm->tzoff/3600)*100 + (tm->tzoff/60)%60);
}
@

<<function [[imap4Date]]>>=
int
imap4Date(Tm *tm, char *date)
{
    char *flds[4];

    if(getfields(date, flds, 3, 0, "-") != 3)
        return 0;

    tm->mday = strtol(flds[0], nil, 10);
    tm->mon = dateindex(flds[1], monname, 12);
    tm->year = strtol(flds[2], nil, 10) - 1900;
    return 1;
}
@

<<function [[imap4DateTime]]>>=
/*
 * parse imap4 dates
 */
ulong
imap4DateTime(char *date)
{
    Tm tm;
    char *flds[4], *sflds[4];
    ulong t;

    if(getfields(date, flds, 4, 0, " ") != 3)
        return ~0;

    if(!imap4Date(&tm, flds[0]))
        return ~0;

    if(getfields(flds[1], sflds, 3, 0, ":") != 3)
        return ~0;

    tm.hour = strtol(sflds[0], nil, 10);
    tm.min = strtol(sflds[1], nil, 10);
    tm.sec = strtol(sflds[2], nil, 10);

    strcpy(tm.zone, "GMT");
    tm.yday = 0;
    t = tm2sec(&tm);
    zone2tm(&tm, flds[2]);
    t -= tm.tzoff;
    return t;
}
@

<<function [[date2tm]]>>=
/*
 * parse dates of formats
 * [Wkd[,]] DD Mon YYYY HH:MM:SS zone
 * [Wkd] Mon ( D|DD) HH:MM:SS zone YYYY
 * plus anything similar
 * return nil for a failure
 */
Tm*
date2tm(Tm *tm, char *date)
{
    Tm gmt, *atm;
    char *flds[7], *s, dstr[64];
    int n;

    /*
     * default date is Thu Jan  1 00:00:00 GMT 1970
     */
    tm->wday = 4;
    tm->mday = 1;
    tm->mon = 1;
    tm->hour = 0;
    tm->min = 0;
    tm->sec = 0;
    tm->year = 70;
    strcpy(tm->zone, "GMT");
    tm->tzoff = 0;

    strncpy(dstr, date, sizeof(dstr));
    dstr[sizeof(dstr)-1] = '\0';
    n = tokenize(dstr, flds, 7);
    if(n != 6 && n != 5)
        return nil;

    if(n == 5){
        for(n = 5; n >= 1; n--)
            flds[n] = flds[n - 1];
        n = 5;
    }else{
        /*
         * Wday[,]
         */
        s = strchr(flds[0], ',');
        if(s != nil)
            *s = '\0';
        tm->wday = dateindex(flds[0], wdayname, 7);
        if(tm->wday < 0)
            return nil;
    }

    /*
     * check for the two major formats:
     * Month first or day first
     */
    tm->mon = dateindex(flds[1], monname, 12);
    if(tm->mon >= 0){
        tm->mday = strtoul(flds[2], nil, 10);
        time2tm(tm, flds[3]);
        zone2tm(tm, flds[4]);
        tm->year = strtoul(flds[5], nil, 10);
        if(strlen(flds[5]) > 2)
            tm->year -= 1900;
    }else{
        tm->mday = strtoul(flds[1], nil, 10);
        tm->mon = dateindex(flds[2], monname, 12);
        tm->year = strtoul(flds[3], nil, 10);
        if(strlen(flds[3]) > 2)
            tm->year -= 1900;
        time2tm(tm, flds[4]);
        zone2tm(tm, flds[5]);
    }

    if(n == 5){
        gmt = *tm;
        strncpy(gmt.zone, "", 4);
        gmt.tzoff = 0;
        atm = gmtime(tm2sec(&gmt));
        tm->wday = atm->wday;
    }else{
        /*
         * Wday[,]
         */
        s = strchr(flds[0], ',');
        if(s != nil)
            *s = '\0';
        tm->wday = dateindex(flds[0], wdayname, 7);
        if(tm->wday < 0)
            return nil;
    }
    return tm;
}
@

<<global [[zones]]>>=
/*
 * zone	: [A-Za-z][A-Za-z][A-Za-z]	some time zone names
 *	| [A-IK-Z]			military time; rfc1123 says the rfc822 spec is wrong.
 *	| "UT"				universal time
 *	| [+-][0-9][0-9][0-9][0-9]
 * zones is the rfc-822 list of time zone names
 */
static NamedInt zones[] =
{
    {"A",	-1 * 3600},
    {"B",	-2 * 3600},
    {"C",	-3 * 3600},
    {"CDT", -5 * 3600},
    {"CST", -6 * 3600},
    {"D",	-4 * 3600},
    {"E",	-5 * 3600},
    {"EDT", -4 * 3600},
    {"EST", -5 * 3600},
    {"F",	-6 * 3600},
    {"G",	-7 * 3600},
    {"GMT", 0},
    {"H",	-8 * 3600},
    {"I",	-9 * 3600},
    {"K",	-10 * 3600},
    {"L",	-11 * 3600},
    {"M",	-12 * 3600},
    {"MDT", -6 * 3600},
    {"MST", -7 * 3600},
    {"N",	+1 * 3600},
    {"O",	+2 * 3600},
    {"P",	+3 * 3600},
    {"PDT", -7 * 3600},
    {"PST", -8 * 3600},
    {"Q",	+4 * 3600},
    {"R",	+5 * 3600},
    {"S",	+6 * 3600},
    {"T",	+7 * 3600},
    {"U",	+8 * 3600},
    {"UT",	0},
    {"V",	+9 * 3600},
    {"W",	+10 * 3600},
    {"X",	+11 * 3600},
    {"Y",	+12 * 3600},
    {"Z",	0},
    {nil,	0}
};
@

<<function [[zone2tm]]>>=
static void
zone2tm(Tm *tm, char *s)
{
    Tm aux, *atm;
    int i;

    if(*s == '+' || *s == '-'){
        i = strtol(s, &s, 10);
        tm->tzoff = (i / 100) * 3600 + i % 100;
        strncpy(tm->zone, "", 4);
        return;
    }

    /*
     * look it up in the standard rfc822 table
     */
    strncpy(tm->zone, s, 3);
    tm->zone[3] = '\0';
    tm->tzoff = 0;
    for(i = 0; zones[i].name != nil; i++){
        if(cistrcmp(zones[i].name, s) == 0){
            tm->tzoff = zones[i].v;
            return;
        }
    }

    /*
     * one last try: look it up in the current local timezone
     * probe a couple of times to get daylight/standard time change.
     */
    aux = *tm;
    memset(aux.zone, 0, 4);
    aux.hour--;
    for(i = 0; i < 2; i++){
        atm = localtime(tm2sec(&aux));
        if(cistrcmp(tm->zone, atm->zone) == 0){
            tm->tzoff = atm->tzoff;
            return;
        }
        aux.hour++;
    }

    strncpy(tm->zone, "GMT", 4);
    tm->tzoff = 0;
}
@

<<function [[time2tm]]>>=
/*
 * hh[:mm[:ss]]
 */
static void
time2tm(Tm *tm, char *s)
{
    tm->hour = strtoul(s, &s, 10);
    if(*s++ != ':')
        return;
    tm->min = strtoul(s, &s, 10);
    if(*s++ != ':')
        return;
    tm->sec = strtoul(s, &s, 10);
}
@

<<function [[dateindex]]>>=
static int
dateindex(char *d, char **tab, int n)
{
    int i;

    for(i = 0; i < n; i++)
        if(cistrcmp(d, tab[i]) == 0)
            return i;
    return -1;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/date.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<global [[wdayname]]>>

<<global [[monname]]([[(networking/ip/imap4d/date.c)]])>>

static void	time2tm(Tm *tm, char *s);
static void	zone2tm(Tm *tm, char *s);
static int	dateindex(char *d, char **tab, int n);

<<function [[rfc822date]]>>

<<function [[imap4date]]>>

<<function [[imap4Date]]>>

<<function [[imap4DateTime]]>>

<<function [[date2tm]]>>

<<global [[zones]]>>

<<function [[zone2tm]]>>

<<function [[time2tm]]>>

<<function [[dateindex]]>>
@


\subsection*{[[networking/ip/imap4d/debug.c]]}

<<function [[debuglog]]>>=
void
debuglog(char *fmt, ...)
{
    va_list arg;
    static int logfd;

    if(debug == 0)
        return;
    if(logfd == 0)
        logfd = open("/sys/log/imap4d", OWRITE);
    if(logfd > 0){
        va_start(arg, fmt);
        fprint(logfd, "%s: ", username);
        vfprint(logfd, fmt, arg);
        va_end(arg);
    }
}
@

<<function [[boxVerify]]>>=
void
boxVerify(Box *box)
{
    Msg *m;
    ulong seq, uid, recent;

    if(box == nil)
        return;
    recent = 0;
    seq = 0;
    uid = 0;
    for(m = box->msgs; m != nil; m = m->next){
        if(m->seq == 0)
            fprint(2, "m->seq == 0: m->seq=%lud\n", m->seq);
        else if(m->seq <= seq)
            fprint(2, "m->seq=%lud out of order: last=%lud\n", m->seq, seq);
        seq = m->seq;

        if(m->uid == 0)
            fprint(2, "m->uid == 0: m->seq=%lud\n", m->seq);
        else if(m->uid <= uid)
            fprint(2, "m->uid=%lud out of order: last=%lud\n", m->uid, uid);
        uid = m->uid;

        if(m->flags & MRecent)
            recent++;
    }
    if(seq != box->max)
        fprint(2, "max=%lud, should be %lud\n", box->max, seq);
    if(uid >= box->uidnext)
        fprint(2, "uidnext=%lud, maxuid=%lud\n", box->uidnext, uid);
    if(recent != box->recent)
        fprint(2, "recent=%lud, should be %lud\n", box->recent, recent);
}
@

<<function [[openfiles]]>>=
void
openfiles(void)
{
    Dir *d;
    int i;

    for(i = 0; i < 20; i++){
        d = dirfstat(i);
        if(d != nil){
            fprint(2, "fd[%d]='%s' type=%c dev=%d user='%s group='%s'\n", i, d->name, d->type, d->dev, d->uid, d->gid);
            free(d);
        }
    }
}
@

<<function [[ls]]>>=
void
ls(char *file)
{
    Dir *d;
    int fd, i, nd;

    fd = open(file, OREAD);
    if(fd < 0)
        return;

    /*
     * read box to find all messages
     * each one has a directory, and is in numerical order
     */
    d = dirfstat(fd);
    if(d == nil){
        close(fd);
        return;
    }
    if(!(d->mode & DMDIR)){
        fprint(2, "file %s\n", file);
        free(d);
        close(fd);
        return;
    }
    free(d);
    while((nd = dirread(fd, &d)) > 0){
        for(i = 0; i < nd; i++){
            fprint(2, "%s/%s %c\n", file, d[i].name, "-d"[(d[i].mode & DMDIR) == DMDIR]);
        }
        free(d);
    }
    close(fd);
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/debug.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <bio.h>
#include "imap4d.h"

<<function [[debuglog]]>>

<<function [[boxVerify]]>>

<<function [[openfiles]]>>

<<function [[ls]]>>
@


\subsection*{[[networking/ip/imap4d/fetch.c]]}

<<global [[fetchPartNames]]>>=
char *fetchPartNames[FPMax] =
{
    "",
    "HEADER",
    "HEADER.FIELDS",
    "HEADER.FIELDS.NOT",
    "MIME",
    "TEXT",
};
@

<<function [[fetchSeen]]>>=
/*
 * implicitly set the \seen flag.  done in a separate pass
 * so the .imp file doesn't need to be open while the
 * messages are sent to the client.
 */
int
fetchSeen(Box *box, Msg *m, int uids, void *vf)
{
    Fetch *f;

    USED(uids);

    if(m->expunged)
        return uids;
    for(f = vf; f != nil; f = f->next){
        switch(f->op){
        case FRfc822:
        case FRfc822Text:
        case FBodySect:
            msgSeen(box, m);
            goto breakout;
        }
    }
breakout:

    return 1;
}
@

<<function [[fetchMsg]]>>=
/*
 * fetch messages
 *
 * imap4 body[] requestes get translated to upas/fs files as follows
 *	body[id.header] == id/rawheader file + extra \r\n
 *	body[id.text] == id/rawbody
 *	body[id.mime] == id/mimeheader + extra \r\n
 *	body[id] === body[id.header] + body[id.text]
*/
int
fetchMsg(Box *, Msg *m, int uids, void *vf)
{
    Tm tm;
    Fetch *f;
    char *sep;
    int todo;

    if(m->expunged)
        return uids;

    todo = 0;
    for(f = vf; f != nil; f = f->next){
        switch(f->op){
        case FFlags:
            todo = 1;
            break;
        case FUid:
            todo = 1;
            break;
        case FInternalDate:
        case FEnvelope:
        case FRfc822:
        case FRfc822Head:
        case FRfc822Size:
        case FRfc822Text:
        case FBodySect:
        case FBodyPeek:
        case FBody:
        case FBodyStruct:
            todo = 1;
            if(!msgStruct(m, 1)){
                msgDead(m);
                return uids;
            }
            break;
        default:
            bye("bad implementation of fetch");
            return 0;
        }
    }

    if(m->expunged)
        return uids;
    if(!todo)
        return 1;

    /*
     * note: it is allowed to send back the responses one at a time
     * rather than all together.  this is exploited to send flags elsewhere.
     */
    Bprint(&bout, "* %lud FETCH (", m->seq);
    sep = "";
    if(uids){
        Bprint(&bout, "UID %lud", m->uid);
        sep = " ";
    }
    for(f = vf; f != nil; f = f->next){
        switch(f->op){
        default:
            bye("bad implementation of fetch");
            break;
        case FFlags:
            Bprint(&bout, "%sFLAGS (", sep);
            writeFlags(&bout, m, 1);
            Bprint(&bout, ")");
            break;
        case FUid:
            if(uids)
                continue;
            Bprint(&bout, "%sUID %lud", sep, m->uid);
            break;
        case FEnvelope:
            Bprint(&bout, "%sENVELOPE ", sep);
            fetchEnvelope(m);
            break;
        case FInternalDate:
            Bprint(&bout, "%sINTERNALDATE ", sep);
            Bimapdate(&bout, date2tm(&tm, m->unixDate));
            break;
        case FBody:
            Bprint(&bout, "%sBODY ", sep);
            fetchBodyStruct(m, &m->head, 0);
            break;
        case FBodyStruct:
            Bprint(&bout, "%sBODYSTRUCTURE ", sep);
            fetchBodyStruct(m, &m->head, 1);
            break;
        case FRfc822Size:
            Bprint(&bout, "%sRFC822.SIZE %lud", sep, msgSize(m));
            break;
        case FRfc822:
            f->part = FPAll;
            Bprint(&bout, "%sRFC822", sep);
            fetchBody(m, f);
            break;
        case FRfc822Head:
            f->part = FPHead;
            Bprint(&bout, "%sRFC822.HEADER", sep);
            fetchBody(m, f);
            break;
        case FRfc822Text:
            f->part = FPText;
            Bprint(&bout, "%sRFC822.TEXT", sep);
            fetchBody(m, f);
            break;
        case FBodySect:
        case FBodyPeek:
            Bprint(&bout, "%sBODY", sep);
            fetchBody(fetchSect(m, f), f);
            break;
        }
        sep = " ";
    }
    Bprint(&bout, ")\r\n");

    return 1;
}
@

<<function [[fetchSect]]>>=
/*
 * print out section, part, headers;
 * find and return message section
 */
Msg *
fetchSect(Msg *m, Fetch *f)
{
    Bputc(&bout, '[');
    BNList(&bout, f->sect, ".");
    if(f->part != FPAll){
        if(f->sect != nil)
            Bputc(&bout, '.');
        Bprint(&bout, "%s", fetchPartNames[f->part]);
        if(f->hdrs != nil){
            Bprint(&bout, " (");
            BSList(&bout, f->hdrs, " ");
            Bputc(&bout, ')');
        }
    }
    Bprint(&bout, "]");
    return findMsgSect(m, f->sect);
}
@

<<function [[fetchBody]]>>=
/*
 * actually return the body pieces
 */
void
fetchBody(Msg *m, Fetch *f)
{
    Pair p;
    char *s, *t, *e, buf[BufSize + 2];
    ulong n, start, stop, pos;
    int fd, nn;

    if(m == nil){
        fetchBodyStr(f, "", 0);
        return;
    }
    switch(f->part){
    case FPHeadFields:
    case FPHeadFieldsNot:
        n = m->head.size + 3;
        s = emalloc(n);
        n = selectFields(s, n, m->head.buf, f->hdrs, f->part == FPHeadFields);
        fetchBodyStr(f, s, n);
        free(s);
        return;
    case FPHead:
        fetchBodyStr(f, m->head.buf, m->head.size);
        return;
    case FPMime:
        fetchBodyStr(f, m->mime.buf, m->mime.size);
        return;
    case FPAll:
        fd = msgFile(m, "rawbody");
        if(fd < 0){
            msgDead(m);
            fetchBodyStr(f, "", 0);
            return;
        }
        p = fetchBodyPart(f, msgSize(m));
        start = p.start;
        if(start < m->head.size){
            stop = p.stop;
            if(stop > m->head.size)
                stop = m->head.size;
            Bwrite(&bout, &m->head.buf[start], stop - start);
            start = 0;
            stop = p.stop;
            if(stop <= m->head.size){
                close(fd);
                return;
            }
        }else
            start -= m->head.size;
        stop = p.stop - m->head.size;
        break;
    case FPText:
        fd = msgFile(m, "rawbody");
        if(fd < 0){
            msgDead(m);
            fetchBodyStr(f, "", 0);
            return;
        }
        p = fetchBodyPart(f, m->size);
        start = p.start;
        stop = p.stop;
        break;
    default:
        fetchBodyStr(f, "", 0);
        return;
    }

    /*
     * read in each block, convert \n without \r to \r\n.
     * this means partial fetch requires fetching everything
     * through stop, since we don't know how many \r's will be added
     */
    buf[0] = ' ';
    for(pos = 0; pos < stop; ){
        n = BufSize;
        if(n > stop - pos)
            n = stop - pos;
        n = read(fd, &buf[1], n);
        if(n <= 0){
            fetchBodyFill(stop - pos);
            break;
        }
        e = &buf[n + 1];
        *e = '\0';
        for(s = &buf[1]; s < e && pos < stop; s = t + 1){
            t = memchr(s, '\n', e - s);
            if(t == nil)
                t = e;
            n = t - s;
            if(pos < start){
                if(pos + n <= start){
                    s = t;
                    pos += n;
                }else{
                    s += start - pos;
                    pos = start;
                }
                n = t - s;
            }
            nn = n;
            if(pos + nn > stop)
                nn = stop - pos;
            if(Bwrite(&bout, s, nn) != nn)
                writeErr();
            pos += n;
            if(*t == '\n'){
                if(t[-1] != '\r'){
                    if(pos >= start && pos < stop)
                        Bputc(&bout, '\r');
                    pos++;
                }
                if(pos >= start && pos < stop)
                    Bputc(&bout, '\n');
                pos++;
            }
        }
        buf[0] = e[-1];
    }
    close(fd);
}
@

<<function [[fetchBodyPart]]>>=
/*
 * resolve the actual bounds of any partial fetch,
 * and print out the bounds & size of string returned
 */
Pair
fetchBodyPart(Fetch *f, ulong size)
{
    Pair p;
    ulong start, stop;

    start = 0;
    stop = size;
    if(f->partial){
        start = f->start;
        if(start > size)
            start = size;
        stop = start + f->size;
        if(stop > size)
            stop = size;
        Bprint(&bout, "<%lud>", start);
    }
    Bprint(&bout, " {%lud}\r\n", stop - start);
    p.start = start;
    p.stop = stop;
    return p;
}
@

<<function [[fetchBodyFill]]>>=
/*
 * something went wrong fetching data
 * produce fill bytes for what we've committed to produce
 */
void
fetchBodyFill(ulong n)
{
    while(n-- > 0)
        if(Bputc(&bout, ' ') < 0)
            writeErr();
}
@

<<function [[fetchBodyStr]]>>=
/*
 * return a simple string
 */
void
fetchBodyStr(Fetch *f, char *buf, ulong size)
{
    Pair p;

    p = fetchBodyPart(f, size);
    Bwrite(&bout, &buf[p.start], p.stop-p.start);
}
@

<<function [[printnlist]]>>=
char*
printnlist(NList *sect)
{
    static char buf[100];
    char *p;

    for(p= buf; sect; sect=sect->next){
        p += sprint(p, "%ld", sect->n);
        if(sect->next)
            *p++ = '.';
    }
    *p = '\0';
    return buf;
}
@

<<function [[findMsgSect]]>>=
/*
 * find the numbered sub-part of the message
 */
Msg*
findMsgSect(Msg *m, NList *sect)
{
    ulong id;

    for(; sect != nil; sect = sect->next){
        id = sect->n;
//#ifdef HACK
//		/* HACK to solve extra level of structure not visible from upas/fs  */
//		if(m->kids == 0 && id == 1 && sect->next == nil){
//			if(m->mime.type->s && strcmp(m->mime.type->s, "message")==0)
//			if(m->mime.type->t && strcmp(m->mime.type->t, "rfc822")==0)
//			if(m->head.type->s && strcmp(m->head.type->s, "text")==0)
//			if(m->head.type->t && strcmp(m->head.type->t, "plain")==0)
//				break;
//		}
//		/* end of HACK */
//#endif HACK
        for(m = m->kids; m != nil; m = m->next)
            if(m->id == id)
                break;
        if(m == nil)
            return nil;
    }
    return m;
}
@

<<function [[fetchEnvelope]]>>=
void
fetchEnvelope(Msg *m)
{
    Tm tm;

    Bputc(&bout, '(');
    Brfc822date(&bout, date2tm(&tm, m->info[IDate]));
    Bputc(&bout, ' ');
    Bimapstr(&bout, m->info[ISubject]);
    Bputc(&bout, ' ');
    Bimapaddr(&bout, m->from);
    Bputc(&bout, ' ');
    Bimapaddr(&bout, m->sender);
    Bputc(&bout, ' ');
    Bimapaddr(&bout, m->replyTo);
    Bputc(&bout, ' ');
    Bimapaddr(&bout, m->to);
    Bputc(&bout, ' ');
    Bimapaddr(&bout, m->cc);
    Bputc(&bout, ' ');
    Bimapaddr(&bout, m->bcc);
    Bputc(&bout, ' ');
    Bimapstr(&bout, m->info[IInReplyTo]);
    Bputc(&bout, ' ');
    Bimapstr(&bout, m->info[IMessageId]);
    Bputc(&bout, ')');
}
@

<<function [[fetchBodyStruct]]>>=
void
fetchBodyStruct(Msg *m, Header *h, int extensions)
{
    Msg *k;
    ulong len;

    if(msgIsMulti(h)){
        Bputc(&bout, '(');
        for(k = m->kids; k != nil; k = k->next)
            fetchBodyStruct(k, &k->mime, extensions);

        Bputc(&bout, ' ');
        Bimapstr(&bout, h->type->t);

        if(extensions){
            Bputc(&bout, ' ');
            BimapMimeParams(&bout, h->type->next);
            fetchStructExt(h);
        }

        Bputc(&bout, ')');
        return;
    }

    Bputc(&bout, '(');
    if(h->type != nil){
        Bimapstr(&bout, h->type->s);
        Bputc(&bout, ' ');
        Bimapstr(&bout, h->type->t);
        Bputc(&bout, ' ');
        BimapMimeParams(&bout, h->type->next);
    }else
        Bprint(&bout, "\"text\" \"plain\" NIL");

    Bputc(&bout, ' ');
    if(h->id != nil)
        Bimapstr(&bout, h->id->s);
    else
        Bprint(&bout, "NIL");

    Bputc(&bout, ' ');
    if(h->description != nil)
        Bimapstr(&bout, h->description->s);
    else
        Bprint(&bout, "NIL");

    Bputc(&bout, ' ');
    if(h->encoding != nil)
        Bimapstr(&bout, h->encoding->s);
    else
        Bprint(&bout, "NIL");

    /*
     * this is so strange: return lengths for a body[text] response,
     * except in the case of a multipart message, when return lengths for a body[] response
     */
    len = m->size;
    if(h == &m->mime)
        len += m->head.size;
    Bprint(&bout, " %lud", len);

    len = m->lines;
    if(h == &m->mime)
        len += m->head.lines;

    if(h->type == nil || cistrcmp(h->type->s, "text") == 0){
        Bprint(&bout, " %lud", len);
    }else if(msgIsRfc822(h)){
        Bputc(&bout, ' ');
        k = m;
        if(h != &m->mime)
            k = m->kids;
        if(k == nil)
            Bprint(&bout, "(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) (\"text\" \"plain\" NIL NIL NIL NIL 0 0) 0");
        else{
            fetchEnvelope(k);
            Bputc(&bout, ' ');
            fetchBodyStruct(k, &k->head, extensions);
            Bprint(&bout, " %lud", len);
        }
    }

    if(extensions){
        Bputc(&bout, ' ');

        /*
         * don't have the md5 laying around,
         * since the header & body have added newlines.
         */
        Bprint(&bout, "NIL");

        fetchStructExt(h);
    }
    Bputc(&bout, ')');
}
@

<<function [[fetchStructExt]]>>=
/*
 * common part of bodystructure extensions
 */
void
fetchStructExt(Header *h)
{
    Bputc(&bout, ' ');
    if(h->disposition != nil){
        Bputc(&bout, '(');
        Bimapstr(&bout, h->disposition->s);
        Bputc(&bout, ' ');
        BimapMimeParams(&bout, h->disposition->next);
        Bputc(&bout, ')');
    }else
        Bprint(&bout, "NIL");
    Bputc(&bout, ' ');
    if(h->language != nil){
        if(h->language->next != nil)
            BimapMimeParams(&bout, h->language->next);
        else
            Bimapstr(&bout, h->language->s);
    }else
        Bprint(&bout, "NIL");
}
@

<<function [[BimapMimeParams]]>>=
int
BimapMimeParams(Biobuf *b, MimeHdr *mh)
{
    char *sep;
    int n;

    if(mh == nil)
        return Bprint(b, "NIL");

    n = Bputc(b, '(');

    sep = "";
    for(; mh != nil; mh = mh->next){
        n += Bprint(b, sep);
        n += Bimapstr(b, mh->s);
        n += Bputc(b, ' ');
        n += Bimapstr(b, mh->t);
        sep = " ";
    }

    n += Bputc(b, ')');
    return n;
}
@

<<function [[Bimapaddr]]>>=
/*
 * print a list of addresses;
 * each address is printed as '(' personalName AtDomainList mboxName hostName ')'
 * the AtDomainList is always NIL
 */
int
Bimapaddr(Biobuf *b, MAddr *a)
{
    char *host, *sep;
    int n;

    if(a == nil)
        return Bprint(b, "NIL");

    n = Bputc(b, '(');
    sep = "";
    for(; a != nil; a = a->next){
        n += Bprint(b, "%s(", sep);
        n += Bimapstr(b, a->personal);
        n += Bprint(b," NIL ");
        n += Bimapstr(b, a->box);
        n += Bputc(b, ' ');

        /*
         * can't send NIL as hostName, since that is code for a group
         */
        host = a->host;
        if(host == nil)
            host = "";
        n += Bimapstr(b, host);

        n += Bputc(b, ')');
        sep = " ";
    }
    n += Bputc(b, ')');
    return n;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/fetch.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<global [[fetchPartNames]]>>

<<function [[fetchSeen]]>>

<<function [[fetchMsg]]>>

<<function [[fetchSect]]>>

<<function [[fetchBody]]>>

<<function [[fetchBodyPart]]>>

<<function [[fetchBodyFill]]>>

<<function [[fetchBodyStr]]>>

<<function [[printnlist]]>>

<<function [[findMsgSect]]>>

<<function [[fetchEnvelope]]>>

<<function [[fetchBodyStruct]]>>

<<function [[fetchStructExt]]>>

<<function [[BimapMimeParams]]>>

<<function [[Bimapaddr]]>>
@


\subsection*{[[networking/ip/imap4d/fns.h]]}

<<macro [[MK]]>>=
#define	MK(t)		((t*)emalloc(sizeof(t)))
@

<<macro [[MKZ]]>>=
#define	MKZ(t)		((t*)ezmalloc(sizeof(t)))
@

<<macro [[MKN]]>>=
#define	MKN(t,n)	((t*)emalloc((n)*sizeof(t)))
@

<<macro [[MKNZ]]>>=
#define	MKNZ(t,n)	((t*)ezmalloc((n)*sizeof(t)))
@

<<macro [[MKNA]]>>=
#define	MKNA(t,at,n)	((t*)emalloc(sizeof(t) + (n)*sizeof(at)))
@

<<macro [[STRLEN]]([[(networking/ip/imap4d/fns.h)]])>>=
#define STRLEN(cs)	(sizeof(cs)-1)
@


%-------------------------------------------------------------

<<networking/ip/imap4d/fns.h>>=
/*
 * sorted by 4,/^$/|sort -bd +1
 */
int	fqid(int fd, Qid *qid);
int	BNList(Biobuf *b, NList *nl, char *sep);
int	BSList(Biobuf *b, SList *sl, char *sep);
int	BimapMimeParams(Biobuf *b, MimeHdr *mh);
int	Bimapaddr(Biobuf *b, MAddr *a);
int	Bimapdate(Biobuf *b, Tm *tm);
int	Bimapstr(Biobuf *b, char *s);
int	Brfc822date(Biobuf *b, Tm *tm);
int	appendSave(char *mbox, int flags, char *head, Biobuf *b, long n);
void	bye(char *fmt, ...);
int	cdCreate(char *dir, char *file, int mode, ulong perm);
int	cdExists(char *dir, char *file);
Dir	*cdDirstat(char *dir, char *file);
int	cdDirwstat(char *dir, char *file, Dir *d);
int	cdOpen(char *dir, char *file, int mode);
int	cdRemove(char *dir, char *file);
MbLock	*checkBox(Box *box, int imped);
int	ciisprefix(char *pre, char *s);
int	cistrcmp(char*, char*);
int	cistrncmp(char*, char*, int);
char	*cistrstr(char *s, char *sub);
void	closeBox(Box *box, int opened);
void	closeImp(Box *box, MbLock *ml);
int	copyBox(char *from, char *to, int doremove);
int	copyCheck(Box *box, Msg *m, int uids, void *v);
int	copySave(Box *box, Msg *m, int uids, void *vs);
char	*cramauth(void);
int	createBox(char *mbox, int dir);
Tm	*date2tm(Tm *tm, char *date);
int	decmutf7(char *out, int nout, char *in);
int	deleteMsgs(Box *box);
void	debuglog(char *fmt, ...);
void	*emalloc(ulong);
int	emptyImp(char *mbox);
void	enableForwarding(void);
int	encmutf7(char *out, int nout, char *in);
void	*erealloc(void*, ulong);
char	*estrdup(char*);
int	expungeMsgs(Box *box, int send);
void	*ezmalloc(ulong);
void	fetchBodyFill(ulong n);
void	fetchBody(Msg *m, Fetch *f);
Pair	fetchBodyPart(Fetch *f, ulong size);
void	fetchBodyStr(Fetch *f, char *buf, ulong size);
void	fetchBodyStruct(Msg *m, Header *h, int extensions);
void	fetchEnvelope(Msg *m);
int	fetchMsg(Box *box, Msg *m, int uids, void *fetch);
Msg	*fetchSect(Msg *m, Fetch *f);
int	fetchSeen(Box *box, Msg *m, int uids, void *vf);
void	fetchStructExt(Header *h);
Msg	*findMsgSect(Msg *m, NList *sect);
int	forMsgs(Box *box, MsgSet *ms, ulong max, int uids, int (*f)(Box*, Msg*, int, void*), void *rock);
void	freeMsg(Msg *m);
ulong	imap4DateTime(char *date);
int	imap4Date(Tm *tm, char *date);
int	imap4date(char *s, int n, Tm *tm);
int	imapTmp(void);
char	*impName(char *name);
int	infoIsNil(char *s);
int	isdotdot(char*);
int	isprefix(char *pre, char *s);
int	issuffix(char *suf, char *s);
int	listBoxes(char *cmd, char *ref, char *pat);
char	*loginauth(void);
int	lsubBoxes(char *cmd, char *ref, char *pat);
char	*maddrStr(MAddr *a);
ulong	mapFlag(char *name);
ulong	mapInt(NamedInt *map, char *name);
void	mbLockRefresh(MbLock *ml);
int	mbLocked(void);
MbLock	*mbLock(void);
void	mbUnlock(MbLock *ml);
char	*mboxName(char*);
Fetch	*mkFetch(int op, Fetch *next);
NList	*mkNList(ulong n, NList *next);
SList	*mkSList(char *s, SList *next);
Store	*mkStore(int sign, int op, int flags);
int	moveBox(char *from, char *to);
void	msgDead(Msg *m);
int	msgFile(Msg *m, char *f);
int	msgInfo(Msg *m);
int	msgIsMulti(Header *h);
int	msgIsRfc822(Header *h);
int	msgSeen(Box *box, Msg *m);
ulong	msgSize(Msg *m);
int	msgStruct(Msg *m, int top);
char	*mutf7str(char*);
int	myChdir(char *dir);
int	okMbox(char *mbox);
Box	*openBox(char *name, char *fsname, int writable);
int	openLocked(char *dir, char *file, int mode);
void	parseErr(char *msg);
AuthInfo	*passLogin(char*, char*);
char	*readFile(int fd);
void	resetCurDir(void);
Fetch	*revFetch(Fetch *f);
NList	*revNList(NList *s);
SList	*revSList(SList *s);
int	rfc822date(char *s, int n, Tm *tm);
int	searchMsg(Msg *m, Search *s);
long	selectFields(char *dst, long n, char *hdr, SList *fields, int matches);
void	sendFlags(Box *box, int uids);
void	setFlags(Box *box, Msg *m, int f);
void	setupuser(AuthInfo*);
int	storeMsg(Box *box, Msg *m, int uids, void *fetch);
char	*strmutf7(char*);
void	strrev(char *s, char *e);
int	subscribe(char *mbox, int how);
void	wrImpFlags(char *buf, int flags, int killRecent);
void	writeErr(void);
void	writeFlags(Biobuf *b, Msg *m, int recentOk);

#pragma	varargck argpos	bye		1
#pragma	varargck argpos	debuglog	1

<<macro [[MK]]>>
<<macro [[MKZ]]>>
<<macro [[MKN]]>>
<<macro [[MKNZ]]>>
<<macro [[MKNA]]>>

<<macro [[STRLEN]]([[(networking/ip/imap4d/fns.h)]])>>
@
%$


\subsection*{[[networking/ip/imap4d/folder.c]]}

<<global [[mLock]]>>=
static	MbLock	mLock =
{
    .fd = -1
};
@

<<global [[curDir]]>>=
static char curDir[MboxNameLen];
@

<<function [[resetCurDir]]>>=
void
resetCurDir(void)
{
    curDir[0] = '\0';
}
@

<<function [[myChdir]]>>=
int
myChdir(char *dir)
{
    if(strcmp(dir, curDir) == 0)
        return 0;
    if(dir[0] != '/' || strlen(dir) > MboxNameLen)
        return -1;
    strcpy(curDir, dir);
    if(chdir(dir) < 0){
        werrstr("mychdir failed: %r");
        return -1;
    }
    return 0;
}
@

<<function [[cdCreate]]>>=
int
cdCreate(char *dir, char *file, int mode, ulong perm)
{
    if(myChdir(dir) < 0)
        return -1;
    return create(file, mode, perm);
}
@

<<function [[cdDirstat]]>>=
Dir*
cdDirstat(char *dir, char *file)
{
    if(myChdir(dir) < 0)
        return nil;
    return dirstat(file);
}
@

<<function [[cdExists]]>>=
int
cdExists(char *dir, char *file)
{
    Dir *d;

    d = cdDirstat(dir, file);
    if(d == nil)
        return 0;
    free(d);
    return 1;
}
@

<<function [[cdDirwstat]]>>=
int
cdDirwstat(char *dir, char *file, Dir *d)
{
    if(myChdir(dir) < 0)
        return -1;
    return dirwstat(file, d);
}
@

<<function [[cdOpen]]>>=
int
cdOpen(char *dir, char *file, int mode)
{
    if(myChdir(dir) < 0)
        return -1;
    return open(file, mode);
}
@

<<function [[cdRemove]]>>=
int
cdRemove(char *dir, char *file)
{
    if(myChdir(dir) < 0)
        return -1;
    return remove(file);
}
@

<<function [[mbLock]]>>=
/*
 * open the one true mail lock file
 */
MbLock*
mbLock(void)
{
    int i;

    if(mLock.fd >= 0)
        bye("mail lock deadlock");
    for(i = 0; i < 5; i++){
        mLock.fd = openLocked(mboxDir, "L.mbox", OREAD);
        if(mLock.fd >= 0)
            return &mLock;
        sleep(1000);
    }
    return nil;
}
@

<<function [[mbUnlock]]>>=
void
mbUnlock(MbLock *ml)
{
    if(ml != &mLock)
        bye("bad mail unlock");
    if(ml->fd < 0)
        bye("mail unlock when not locked");
    close(ml->fd);
    ml->fd = -1;
}
@

<<function [[mbLockRefresh]]>>=
void
mbLockRefresh(MbLock *ml)
{
    char buf[1];

    seek(ml->fd, 0, 0);
    read(ml->fd, buf, 1);
}
@

<<function [[mbLocked]]>>=
int
mbLocked(void)
{
    return mLock.fd >= 0;
}
@

<<function [[impName]]>>=
char*
impName(char *name)
{
    char *s;
    int n;

    if(cistrcmp(name, "inbox") == 0)
        if(access("msgs", AEXIST) == 0)
            name = "msgs";
        else
            name = "mbox";
    n = strlen(name) + STRLEN(".imp") + 1;
    s = binalloc(&parseBin, n, 0);
    if(s == nil)
        return nil;
    snprint(s, n, "%s.imp", name);
    return s;
}
@

<<function [[mboxName]]>>=
/*
 * massage the mailbox name into something valid
 * eliminates all .', and ..',s, redundatant and trailing /'s.
 */
char *
mboxName(char *s)
{
    char *ss;

    ss = mutf7str(s);
    if(ss == nil)
        return nil;
    cleanname(ss);
    return ss;
}
@

<<function [[strmutf7]]>>=
char *
strmutf7(char *s)
{
    char *m;
    int n;

    n = strlen(s) * MUtf7Max + 1;
    m = binalloc(&parseBin, n, 0);
    if(m == nil)
        return nil;
    if(encmutf7(m, n, s) < 0)
        return nil;
    return m;
}
@

<<function [[mutf7str]]>>=
char *
mutf7str(char *s)
{
    char *m;
    int n;

    /*
     * n = strlen(s) * UTFmax / (2.67) + 1
     * UTFMax / 2.67 == 3 / (8/3) == 9 / 8
     */
    n = strlen(s);
    n = (n * 9 + 7) / 8 + 1;
    m = binalloc(&parseBin, n, 0);
    if(m == nil)
        return nil;
    if(decmutf7(m, n, s) < 0)
        return nil;
    return m;
}
@

<<function [[splitr]]>>=
void
splitr(char *s, int c, char **left, char **right)
{
    char *d;
    int n;

    n = strlen(s);
    d = binalloc(&parseBin, n + 1, 0);
    if(d == nil)
        parseErr("out of memory");
    strcpy(d, s);
    s = strrchr(d, c);
    if(s != nil){
        *left = d;
        *s++ = '\0';
        *right = s;
    }else{
        *right = d;
        *left = d + n;
    }
}
@

<<function [[createBox]]>>=
/*
 * create the mailbox and all intermediate components
 * a trailing / implies the new mailbox is a directory;
 * otherwise, it's a file.
 *
 * return with the file open for write, or directory open for read.
 */
int
createBox(char *mbox, int dir)
{
    char *m;
    int fd;

    fd = -1;
    for(m = mbox; *m; m++){
        if(*m == '/'){
            *m = '\0';
            if(access(mbox, AEXIST) < 0){
                if(fd >= 0)
                    close(fd);
                fd = cdCreate(mboxDir, mbox, OREAD, DMDIR|0775);
                if(fd < 0)
                    return -1;
            }
            *m = '/';
        }
    }
    if(dir)
        fd = cdCreate(mboxDir, mbox, OREAD, DMDIR|0775);
    else
        fd = cdCreate(mboxDir, mbox, OWRITE, 0664);
    return fd;
}
@

<<function [[moveBox]]>>=
/*
 * move one mail folder to another
 * destination mailbox doesn't exist.
 * the source folder may be a directory or a mailbox,
 * and may be in the same directory as the destination,
 * or a completely different directory.
 */
int
moveBox(char *from, char *to)
{
    Dir *d;
    char *fd, *fe, *td, *te, *fimp;

    splitr(from, '/', &fd, &fe);
    splitr(to, '/', &td, &te);

    /*
     * in the same directory: try rename
     */
    d = cdDirstat(mboxDir, from);
    if(d == nil)
        return 0;
    if(strcmp(fd, td) == 0){
        nulldir(d);
        d->name = te;
        if(cdDirwstat(mboxDir, from, d) >= 0){
            fimp = impName(from);
            d->name = impName(te);
            cdDirwstat(mboxDir, fimp, d);
            free(d);
            return 1;
        }
    }

    /*
     * directory copy is too hard for now
     */
    if(d->mode & DMDIR)
        return 0;
    free(d);

    return copyBox(from, to, 1);
}
@

<<function [[copyBox]]>>=
/*
 * copy the contents of one mailbox to another
 * either truncates or removes the source box if it succeeds.
 */
int
copyBox(char *from, char *to, int doremove)
{
    MbLock *ml;
    char *fimp, *timp;
    int ffd, tfd, ok;

    if(cistrcmp(from, "inbox") == 0)
        if(access("msgs", AEXIST) == 0)
            from = "msgs";
        else
            from = "mbox";

    ml = mbLock();
    if(ml == nil)
        return 0;
    ffd = openLocked(mboxDir, from, OREAD);
    if(ffd < 0){
        mbUnlock(ml);
        return 0;
    }
    tfd = createBox(to, 0);
    if(tfd < 0){
        mbUnlock(ml);
        close(ffd);
        return 0;
    }

    ok = copyData(ffd, tfd, ml);
    close(ffd);
    close(tfd);
    if(!ok){
        mbUnlock(ml);
        return 0;
    }

    fimp = impName(from);
    timp = impName(to);
    if(fimp != nil && timp != nil){
        ffd = cdOpen(mboxDir, fimp, OREAD);
        if(ffd >= 0){
            tfd = cdCreate(mboxDir, timp, OWRITE, 0664);
            if(tfd >= 0){
                copyData(ffd, tfd, ml);
                close(tfd);
            }
            close(ffd);
        }
    }
    cdRemove(mboxDir, fimp);
    if(doremove)
        cdRemove(mboxDir, from);
    else
        close(cdOpen(mboxDir, from, OWRITE|OTRUNC));
    mbUnlock(ml);
    return 1;
}
@

<<function [[copyData]]>>=
/*
 * copies while holding the mail lock,
 * then tries to copy permissions and group ownership
 */
static int
copyData(int ffd, int tfd, MbLock *ml)
{
    Dir *fd, td;
    char buf[BufSize];
    int n;

    for(;;){
        n = read(ffd, buf, BufSize);
        if(n <= 0){
            if(n < 0)
                return 0;
            break;
        }
        if(write(tfd, buf, n) != n)
            return 0;
        mbLockRefresh(ml);
    }
    fd = dirfstat(ffd);
    if(fd != nil){
        nulldir(&td);
        td.mode = fd->mode;
        if(dirfwstat(tfd, &td) >= 0){
            nulldir(&td);
            td.gid = fd->gid;
            dirfwstat(tfd, &td);
        }
    }
    return 1;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/folder.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

static	int	copyData(int ffd, int tfd, MbLock *ml);
<<global [[mLock]]>>

<<global [[curDir]]>>

<<function [[resetCurDir]]>>

<<function [[myChdir]]>>

<<function [[cdCreate]]>>

<<function [[cdDirstat]]>>

<<function [[cdExists]]>>

<<function [[cdDirwstat]]>>

<<function [[cdOpen]]>>

<<function [[cdRemove]]>>

<<function [[mbLock]]>>

<<function [[mbUnlock]]>>

<<function [[mbLockRefresh]]>>

<<function [[mbLocked]]>>

<<function [[impName]]>>

<<function [[mboxName]]>>

<<function [[strmutf7]]>>

<<function [[mutf7str]]>>

<<function [[splitr]]>>

<<function [[createBox]]>>

<<function [[moveBox]]>>

<<function [[copyBox]]>>

<<function [[copyData]]>>
@


\subsection*{[[networking/ip/imap4d/imap4d.c]]}

<<enum [[_anon_ (networking/ip/imap4d/imap4d.c)]]>>=
enum
{
    UlongMax	= 4294967295,
};
@

<<struct [[ParseCmd]]>>=
struct ParseCmd
{
    char	*name;
    void	(*f)(char *tg, char *cmd);
};
@

<<global [[SNonAuthed]]>>=
static	ParseCmd	SNonAuthed[] =
{
    {"capability",		capabilityCmd},
    {"logout",		logoutCmd},
    {"x-exit",		logoutCmd},
    {"noop",		noopCmd},

    {"login",		loginCmd},
    {"authenticate",	authenticateCmd},

    nil
};
@

<<global [[SAuthed]]>>=
static	ParseCmd	SAuthed[] =
{
    {"capability",		capabilityCmd},
    {"logout",		logoutCmd},
    {"x-exit",		logoutCmd},
    {"noop",		noopCmd},

    {"append",		appendCmd},
    {"create",		createCmd},
    {"delete",		deleteCmd},
    {"examine",		selectCmd},
    {"select",		selectCmd},
    {"idle",		idleCmd},
    {"list",		listCmd},
    {"lsub",		listCmd},
    {"namespace",		namespaceCmd},
    {"rename",		renameCmd},
    {"status",		statusCmd},
    {"subscribe",		subscribeCmd},
    {"unsubscribe",		unsubscribeCmd},

    nil
};
@

<<global [[SSelected]]>>=
static	ParseCmd	SSelected[] =
{
    {"capability",		capabilityCmd},
    {"logout",		logoutCmd},
    {"x-exit",		logoutCmd},
    {"noop",		noopCmd},

    {"append",		appendCmd},
    {"create",		createCmd},
    {"delete",		deleteCmd},
    {"examine",		selectCmd},
    {"select",		selectCmd},
    {"idle",		idleCmd},
    {"list",		listCmd},
    {"lsub",		listCmd},
    {"namespace",		namespaceCmd},
    {"rename",		renameCmd},
    {"status",		statusCmd},
    {"subscribe",		subscribeCmd},
    {"unsubscribe",		unsubscribeCmd},

    {"check",		noopCmd},
    {"close",		closeCmd},
    {"copy",		copyCmd},
    {"expunge",		expungeCmd},
    {"fetch",		fetchCmd},
    {"search",		searchCmd},
    {"store",		storeCmd},
    {"uid",			uidCmd},

    nil
};
@

<<global [[atomStop]]>>=
static	char		*atomStop = "(){%*\"\\";
@

<<global [[chal]]>>=
static	Chalstate	*chal;
@

<<global [[chaled]]>>=
static	int		chaled;
@

<<global [[imapState]]>>=
static	ParseCmd	*imapState;
@

<<global [[parseJmp]]>>=
static	jmp_buf		parseJmp;
@

<<global [[parseMsg]]>>=
static	char		*parseMsg;
@

<<global [[allowPass]]>>=
static	int		allowPass;
@

<<global [[allowCR]]>>=
static	int		allowCR;
@

<<global [[exiting]]>>=
static	int		exiting;
@

<<global [[imaplock]]>>=
static	QLock		imaplock;
@

<<global [[idlepid]]>>=
static	int		idlepid = -1;
@

<<global [[bout]]([[(networking/ip/imap4d/imap4d.c)]])>>=
Biobuf	bout;
@

<<global [[bin]]>>=
Biobuf	bin;
@

<<global [[username]]>>=
char	username[UserNameLen];
@

<<global [[mboxDir]]>>=
char	mboxDir[MboxNameLen];
@

<<global [[servername]]([[(networking/ip/imap4d/imap4d.c)]])>>=
char	*servername;
@

<<global [[site]]>>=
char	*site;
@

<<global [[remote]]>>=
char	*remote;
@

<<global [[selected]]>>=
Box	*selected;
@

<<global [[parseBin]]>>=
Bin	*parseBin;
@

<<global [[debug]]([[(networking/ip/imap4d/imap4d.c)]])>>=
int	debug;
@

<<function [[main]]([[(networking/ip/imap4d/imap4d.c)]])>>=
void
main(int argc, char *argv[])
{
    char *s, *t;
    int preauth, n;

    Binit(&bin, 0, OREAD);
    Binit(&bout, 1, OWRITE);

    preauth = 0;
    allowPass = 0;
    allowCR = 0;
    ARGBEGIN{
    case 'a':
        preauth = 1;
        break;
    case 'd':
        site = ARGF();
        break;
    case 'c':
        allowCR = 1;
        break;
    case 'p':
        allowPass = 1;
        break;
    case 'r':
        remote = ARGF();
        break;
    case 's':
        servername = ARGF();
        break;
    case 'v':
        debug = 1;
        debuglog("imap4d debugging enabled\n");
        break;
    default:
        fprint(2, "usage: ip/imap4d [-acpv] [-d site] [-r remotehost] [-s servername]\n");
        bye("usage");
        break;
    }ARGEND

    if(allowPass && allowCR){
        fprint(2, "%s: -c and -p are mutually exclusive\n", argv0);
        bye("usage");
    }

    if(preauth)
        setupuser(nil);

    if(servername == nil){
        servername = csquery("sys", sysname(), "dom");
        if(servername == nil)
            servername = sysname();
        if(servername == nil){
            fprint(2, "ip/imap4d can't find server name: %r\n");
            bye("can't find system name");
        }
    }
    if(site == nil){
        t = getenv("site");
        if(t == nil)
            site = servername;
        else{
            n = strlen(t);
            s = strchr(servername, '.');
            if(s == nil)
                s = servername;
            else
                s++;
            n += strlen(s) + 2;
            site = emalloc(n);
            snprint(site, n, "%s.%s", t, s);
        }
    }

    rfork(RFNOTEG|RFREND);

    atnotify(catcher, 1);
    qlock(&imaplock);
    atexit(cleaner);
    imap4(preauth);
}
@

<<function [[imap4]]>>=
static void
imap4(int preauth)
{
    char *volatile tg;
    char *volatile cmd;
    ParseCmd *st;

    if(preauth){
        Bprint(&bout, "* preauth %s IMAP4rev1 server ready user %s authenticated\r\n", servername, username);
        imapState = SAuthed;
    }else{
        Bprint(&bout, "* OK %s IMAP4rev1 server ready\r\n", servername);
        imapState = SNonAuthed;
    }
    if(Bflush(&bout) < 0)
        writeErr();

    chaled = 0;

    tg = nil;
    cmd = nil;
    if(setjmp(parseJmp)){
        if(tg == nil)
            Bprint(&bout, "* bad empty command line: %s\r\n", parseMsg);
        else if(cmd == nil)
            Bprint(&bout, "%s BAD no command: %s\r\n", tg, parseMsg);
        else
            Bprint(&bout, "%s BAD %s %s\r\n", tg, cmd, parseMsg);
        clearcmd();
        if(Bflush(&bout) < 0)
            writeErr();
        binfree(&parseBin);
    }
    for(;;){
        if(mbLocked())
            bye("internal error: mailbox lock held");
        tg = nil;
        cmd = nil;
        tg = tag();
        mustBe(' ');
        cmd = atom();

        /*
         * note: outlook express is broken: it requires echoing the
         * command as part of matching response
         */
        for(st = imapState; st->name != nil; st++){
            if(cistrcmp(cmd, st->name) == 0){
                (*st->f)(tg, cmd);
                break;
            }
        }
        if(st->name == nil){
            clearcmd();
            Bprint(&bout, "%s BAD %s illegal command\r\n", tg, cmd);
        }

        if(Bflush(&bout) < 0)
            writeErr();
        binfree(&parseBin);
    }
}
@

<<function [[bye]]>>=
void
bye(char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    Bprint(&bout, "* bye ");
    Bvprint(&bout, fmt, arg);
    Bprint(&bout, "\r\n");
    Bflush(&bout);
exits("rob2");
    exits(0);
}
@

<<function [[parseErr]]>>=
void
parseErr(char *msg)
{
    parseMsg = msg;
    longjmp(parseJmp, 1);
}
@

<<function [[writeErr]]>>=
/*
 * an error occured while writing to the client
 */
void
writeErr(void)
{
    cleaner();
    _exits("connection closed");
}
@

<<function [[catcher]]([[(networking/ip/imap4d/imap4d.c)]])>>=
static int
catcher(void *v, char *msg)
{
    USED(v);
    if(strstr(msg, "closed pipe") != nil)
        return 1;
    return 0;
}
@

<<function [[cleaner]]>>=
/*
 * wipes out the idleCmd backgroung process if it is around.
 * this can only be called if the current proc has qlocked imaplock.
 * it must be the last piece of imap4d code executed.
 */
static void
cleaner(void)
{
    int i;

    if(idlepid < 0)
        return;
    exiting = 1;
    close(0);
    close(1);
    close(2);

    /*
     * the other proc is either stuck in a read, a sleep,
     * or is trying to lock imap4lock.
     * get him out of it so he can exit cleanly
     */
    qunlock(&imaplock);
    for(i = 0; i < 4; i++)
        postnote(PNGROUP, getpid(), "die");
}
@

<<function [[status]]>>=
/*
 * send any pending status updates to the client
 * careful: shouldn't exit, because called by idle polling proc
 *
 * can't always send pending info
 * in particular, can't send expunge info
 * in response to a fetch, store, or search command.
 * 
 * rfc2060 5.2:	server must send mailbox size updates
 * rfc2060 5.2:	server may send flag updates
 * rfc2060 5.5:	servers prohibited from sending expunge while fetch, store, search in progress
 * rfc2060 7:	in selected state, server checks mailbox for new messages as part of every command
 * 		sends untagged EXISTS and RECENT respsonses reflecting new size of the mailbox
 * 		should also send appropriate untagged FETCH and EXPUNGE messages if another agent
 * 		changes the state of any message flags or expunges any messages
 * rfc2060 7.4.1	expunge server response must not be sent when no command is in progress,
 * 		nor while responding to a fetch, stort, or search command (uid versions are ok)
 * 		command only "in progress" after entirely parsed.
 *
 * strategy for third party deletion of messages or of a mailbox
 *
 * deletion of a selected mailbox => act like all message are expunged
 *	not strictly allowed by rfc2180, but close to method 3.2.
 *
 * renaming same as deletion
 *
 * copy
 *	reject iff a deleted message is in the request
 *
 * search, store, fetch operations on expunged messages
 *	ignore the expunged messages
 *	return tagged no if referenced
 */
static void
status(int expungeable, int uids)
{
    int tell;

    if(!selected)
        return;
    tell = 0;
    if(expungeable)
        tell = expungeMsgs(selected, 1);
    if(selected->sendFlags)
        sendFlags(selected, uids);
    if(tell || selected->toldMax != selected->max){
        Bprint(&bout, "* %lud EXISTS\r\n", selected->max);
        selected->toldMax = selected->max;
    }
    if(tell || selected->toldRecent != selected->recent){
        Bprint(&bout, "* %lud RECENT\r\n", selected->recent);
        selected->toldRecent = selected->recent;
    }
    if(tell)
        closeImp(selected, checkBox(selected, 1));
}
@

<<function [[check]]>>=
/*
 * careful: can't exit, because called by idle polling proc
 */
static void
check(void)
{
    if(!selected)
        return;
    checkBox(selected, 0);
    status(1, 0);
}
@

<<function [[appendCmd]]>>=
static void
appendCmd(char *tg, char *cmd)
{
    char *mbox, head[128];
    ulong t, n, now;
    int flags, ok;

    mustBe(' ');
    mbox = astring();
    mustBe(' ');
    flags = 0;
    if(peekc() == '('){
        flags = flagList();
        mustBe(' ');
    }
    now = time(nil);
    if(peekc() == '"'){
        t = imap4DateTime(quoted());
        if(t == ~0)
            parseErr("illegal date format");
        mustBe(' ');
        if(t > now)
            t = now;
    }else
        t = now;
    n = litlen();

    mbox = mboxName(mbox);
    if(mbox == nil || !okMbox(mbox)){
        check();
        Bprint(&bout, "%s NO %s bad mailbox\r\n", tg, cmd);
        return;
    }
    if(!cdExists(mboxDir, mbox)){
        check();
        Bprint(&bout, "%s NO [TRYCREATE] %s mailbox does not exist\r\n", tg, cmd);
        return;
    }

    snprint(head, sizeof(head), "From %s %s", username, ctime(t));
    ok = appendSave(mbox, flags, head, &bin, n);
    crnl();
    check();
    if(ok)
        Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
    else
        Bprint(&bout, "%s NO %s message save failed\r\n", tg, cmd);
}
@

<<function [[authenticateCmd]]>>=
static void
authenticateCmd(char *tg, char *cmd)
{
    char *s, *t;

    mustBe(' ');
    s = atom();
    crnl();
    auth_freechal(chal);
    chal = nil;
    if(cistrcmp(s, "cram-md5") == 0){
        t = cramauth();
        if(t == nil){
            Bprint(&bout, "%s OK %s\r\n", tg, cmd);
            imapState = SAuthed;
        }else
            Bprint(&bout, "%s NO %s failed %s\r\n", tg, cmd, t);
    }else
        Bprint(&bout, "%s NO %s unsupported authentication protocol\r\n", tg, cmd);
}
@

<<function [[capabilityCmd]]>>=
static void
capabilityCmd(char *tg, char *cmd)
{
    crnl();
    check();
// nslocum's capabilities
//	Bprint(&bout, "* CAPABILITY IMAP4 IMAP4REV1 NAMESPACE IDLE SCAN SORT MAILBOX-REFERRALS LOGIN-REFERRALS AUTH=LOGIN THREAD=ORDEREDSUBJECT\r\n");
    Bprint(&bout, "* CAPABILITY IMAP4REV1 IDLE NAMESPACE AUTH=CRAM-MD5\r\n");
    Bprint(&bout, "%s OK %s\r\n", tg, cmd);
}
@

<<function [[closeCmd]]>>=
static void
closeCmd(char *tg, char *cmd)
{
    crnl();
    imapState = SAuthed;
    closeBox(selected, 1);
    selected = nil;
    Bprint(&bout, "%s OK %s mailbox closed, now in authenticated state\r\n", tg, cmd);
}
@

<<function [[copyCmd]]>>=
/*
 * note: message id's are before any pending expunges
 */
static void
copyCmd(char *tg, char *cmd)
{
    copyUCmd(tg, cmd, 0);
}
@

<<function [[copyUCmd]]>>=
static void
copyUCmd(char *tg, char *cmd, int uids)
{
    MsgSet *ms;
    char *uid, *mbox;
    ulong max;
    int ok;

    mustBe(' ');
    ms = msgSet(uids);
    mustBe(' ');
    mbox = astring();
    crnl();

    uid = "";
    if(uids)
        uid = "uid ";

    mbox = mboxName(mbox);
    if(mbox == nil || !okMbox(mbox)){
        status(1, uids);
        Bprint(&bout, "%s NO %s%s bad mailbox\r\n", tg, uid, cmd);
        return;
    }
    if(cistrcmp(mbox, "inbox") == 0)
        mbox = "mbox";
    if(!cdExists(mboxDir, mbox)){
        check();
        Bprint(&bout, "%s NO [TRYCREATE] %s mailbox does not exist\r\n", tg, cmd);
        return;
    }

    max = selected->max;
    checkBox(selected, 0);
    ok = forMsgs(selected, ms, max, uids, copyCheck, nil);
    if(ok)
        ok = forMsgs(selected, ms, max, uids, copySave, mbox);

    status(1, uids);
    if(ok)
        Bprint(&bout, "%s OK %s%s completed\r\n", tg, uid, cmd);
    else
        Bprint(&bout, "%s NO %s%s failed\r\n", tg, uid, cmd);
}
@

<<function [[createCmd]]>>=
static void
createCmd(char *tg, char *cmd)
{
    char *mbox, *m;
    int fd, slash;

    mustBe(' ');
    mbox = astring();
    crnl();
    check();

    m = strchr(mbox, '\0');
    slash = m != mbox && m[-1] == '/';
    mbox = mboxName(mbox);
    if(mbox == nil || !okMbox(mbox)){
        Bprint(&bout, "%s NO %s bad mailbox\r\n", tg, cmd);
        return;
    }
    if(cistrcmp(mbox, "inbox") == 0){
        Bprint(&bout, "%s NO %s cannot remotely create INBOX\r\n", tg, cmd);
        return;
    }
    if(access(mbox, AEXIST) >= 0){
        Bprint(&bout, "%s NO %s mailbox already exists\r\n", tg, cmd);
        return;
    }

    fd = createBox(mbox, slash);
    close(fd);
    if(fd < 0)
        Bprint(&bout, "%s NO %s cannot create mailbox %s\r\n", tg, cmd, mbox);
    else
        Bprint(&bout, "%s OK %s %s completed\r\n", tg, mbox, cmd);
}
@

<<function [[deleteCmd]]>>=
static void
deleteCmd(char *tg, char *cmd)
{
    char *mbox, *imp;

    mustBe(' ');
    mbox = astring();
    crnl();
    check();

    mbox = mboxName(mbox);
    if(mbox == nil || !okMbox(mbox)){
        Bprint(&bout, "%s NO %s bad mailbox\r\n", tg, cmd);
        return;
    }

    imp = impName(mbox);
    if(cistrcmp(mbox, "inbox") == 0
    || imp != nil && cdRemove(mboxDir, imp) < 0 && cdExists(mboxDir, imp)
    || cdRemove(mboxDir, mbox) < 0)
        Bprint(&bout, "%s NO %s cannot delete mailbox %s\r\n", tg, cmd, mbox);
    else
        Bprint(&bout, "%s OK %s %s completed\r\n", tg, mbox, cmd);
}
@

<<function [[expungeCmd]]>>=
static void
expungeCmd(char *tg, char *cmd)
{
    int ok;

    crnl();
    ok = deleteMsgs(selected);
    check();
    if(ok)
        Bprint(&bout, "%s OK %s messages erased\r\n", tg, cmd);
    else
        Bprint(&bout, "%s NO %s some messages not expunged\r\n", tg, cmd);
}
@

<<function [[fetchCmd]]>>=
static void
fetchCmd(char *tg, char *cmd)
{
    fetchUCmd(tg, cmd, 0);
}
@

<<function [[fetchUCmd]]>>=
static void
fetchUCmd(char *tg, char *cmd, int uids)
{
    Fetch *f;
    MsgSet *ms;
    MbLock *ml;
    char *uid;
    ulong max;
    int ok;

    mustBe(' ');
    ms = msgSet(uids);
    mustBe(' ');
    f = fetchWhat();
    crnl();
    uid = "";
    if(uids)
        uid = "uid ";
    max = selected->max;
    ml = checkBox(selected, 1);
    if(ml != nil)
        forMsgs(selected, ms, max, uids, fetchSeen, f);
    closeImp(selected, ml);
    ok = ml != nil && forMsgs(selected, ms, max, uids, fetchMsg, f);
    status(uids, uids);
    if(ok)
        Bprint(&bout, "%s OK %s%s completed\r\n", tg, uid, cmd);
    else
        Bprint(&bout, "%s NO %s%s failed\r\n", tg, uid, cmd);
}
@

<<function [[idleCmd]]>>=
static void
idleCmd(char *tg, char *cmd)
{
    int c, pid;

    crnl();
    Bprint(&bout, "+ idling, waiting for done\r\n");
    if(Bflush(&bout) < 0)
        writeErr();

    if(idlepid < 0){
        pid = rfork(RFPROC|RFMEM|RFNOWAIT);
        if(pid == 0){
            for(;;){
                qlock(&imaplock);
                if(exiting)
                    break;

                /*
                 * parent may have changed curDir, but it doesn't change our .
                 */
                resetCurDir();

                check();
                if(Bflush(&bout) < 0)
                    writeErr();
                qunlock(&imaplock);
                sleep(15*1000);
                enableForwarding();
            }
_exits("rob3");
            _exits(0);
        }
        idlepid = pid;
    }

    qunlock(&imaplock);

    /*
     * clear out the next line, which is supposed to contain (case-insensitive)
     * done\n
     * this is special code since it has to dance with the idle polling proc
     * and handle exiting correctly.
     */
    for(;;){
        c = getc();
        if(c < 0){
            qlock(&imaplock);
            if(!exiting)
                cleaner();
_exits("rob4");
            _exits(0);
        }
        if(c == '\n')
            break;
    }

    qlock(&imaplock);
    if(exiting)
{_exits("rob5");
        _exits(0);
}

    /*
     * child may have changed curDir, but it doesn't change our .
     */
    resetCurDir();

    check();
    Bprint(&bout, "%s OK %s terminated\r\n", tg, cmd);
}
@

<<function [[listCmd]]>>=
static void
listCmd(char *tg, char *cmd)
{
    char *s, *t, *ss, *ref, *mbox;
    int n;

    mustBe(' ');
    s = astring();
    mustBe(' ');
    t = listmbox();
    crnl();
    check();
    ref = mutf7str(s);
    mbox = mutf7str(t);
    if(ref == nil || mbox == nil){
        Bprint(&bout, "%s BAD %s mailbox name not in modified utf-7\r\n", tg, cmd);
        return;
    }

    /*
     * special request for hierarchy delimiter and root name
     * root name appears to be name up to and including any delimiter,
     * or the empty string, if there is no delimiter.
     *
     * this must change if the # namespace convention is supported.
     */
    if(*mbox == '\0'){
        s = strchr(ref, '/');
        if(s == nil)
            ref = "";
        else
            s[1] = '\0';
        Bprint(&bout, "* %s (\\Noselect) \"/\" \"%s\"\r\n", cmd, ref);
        Bprint(&bout, "%s OK %s\r\n", tg, cmd);
        return;
    }


    /*
     * massage the listing name:
     * clean up the components individually,
     * then rip off componenets from the ref to
     * take care of leading ..'s in the mbox.
     *
     * the cleanup can wipe out * followed by a ..
     * tough luck if such a stupid pattern is given.
     */
    cleanname(mbox);
    if(strcmp(mbox, ".") == 0)
        *mbox = '\0';
    if(mbox[0] == '/')
        *ref = '\0';
    else if(*ref != '\0'){
        cleanname(ref);
        if(strcmp(ref, ".") == 0)
            *ref = '\0';
    }else
        *ref = '\0';
    while(*ref && isdotdot(mbox)){
        s = strrchr(ref, '/');
        if(s == nil)
            s = ref;
        if(isdotdot(s))
            break;
        *s = '\0';
        mbox += 2;
        if(*mbox == '/')
            mbox++;
    }
    if(*ref == '\0'){
        s = mbox;
        ss = s;
    }else{
        n = strlen(ref) + strlen(mbox) + 2;
        t = binalloc(&parseBin, n, 0);
        if(t == nil)
            parseErr("out of memory");
        snprint(t, n, "%s/%s", ref, mbox);
        s = t;
        ss = s + strlen(ref);
    }

    /*
     * only allow activity in /mail/box
     */
    if(s[0] == '/' || isdotdot(s)){
        Bprint(&bout, "%s NO illegal mailbox pattern\r\n", tg);
        return;
    }

    if(cistrcmp(cmd, "lsub") == 0)
        lsubBoxes(cmd, s, ss);
    else
        listBoxes(cmd, s, ss);
    Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
}
@

<<function [[passCR]]>>=
static char*
passCR(char*u, char*p)
{
    static char Ebadch[] = "can't get challenge";
    static char nchall[64];
    static char response[64];
    static Chalstate *ch = nil;
    AuthInfo *ai;

again:
    if (ch == nil){
        if(!(ch = auth_challenge("proto=p9cr role=server user=%q", u)))
            return Ebadch;
        snprint(nchall, 64, " encrypt challenge: %s", ch->chal);
        return nchall;
    } else {
        strncpy(response, p, 64);
        ch->resp = response;
        ch->nresp = strlen(response);
        ai = auth_response(ch);
        auth_freechal(ch);
        ch = nil;
        if (ai == nil)
            goto again;
        setupuser(ai);
        return nil;
    }
        
}
@

<<function [[loginCmd]]>>=
static void
loginCmd(char *tg, char *cmd)
{
    char *s, *t;
    AuthInfo *ai;
    char*r;
    mustBe(' ');
    s = astring();	/* uid */
    mustBe(' ');
    t = astring();	/* password */
    crnl();
    if(allowCR){
        if ((r = passCR(s, t)) == nil){
            Bprint(&bout, "%s OK %s succeeded\r\n", tg, cmd);
            imapState = SAuthed;
        } else {
            Bprint(&bout, "* NO [ALERT] %s\r\n", r);
            Bprint(&bout, "%s NO %s succeeded\r\n", tg, cmd);
        }
        return;
    }
    else if(allowPass){
        if(ai = passLogin(s, t)){
            setupuser(ai);
            Bprint(&bout, "%s OK %s succeeded\r\n", tg, cmd);
            imapState = SAuthed;
        }else
            Bprint(&bout, "%s NO %s failed check\r\n", tg, cmd);
        return;
    }
    Bprint(&bout, "%s NO %s plaintext passwords disallowed\r\n", tg, cmd);
}
@

<<function [[logoutCmd]]>>=
/*
 * logout or x-exit, which doesn't expunge the mailbox
 */
static void
logoutCmd(char *tg, char *cmd)
{
    crnl();

    if(cmd[0] != 'x' && selected){
        closeBox(selected, 1);
        selected = nil;
    }
    Bprint(&bout, "* bye\r\n");
    Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
exits("rob6");
    exits(0);
}
@

<<function [[namespaceCmd]]>>=
static void
namespaceCmd(char *tg, char *cmd)
{
    crnl();
    check();

    /*
     * personal, other users, shared namespaces
     * send back nil or descriptions of (prefix heirarchy-delim) for each case
     */
    Bprint(&bout, "* NAMESPACE ((\"\" \"/\")) nil nil\r\n");
    Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
}
@

<<function [[noopCmd]]>>=
static void
noopCmd(char *tg, char *cmd)
{
    crnl();
    check();
    Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
    enableForwarding();
}
@

<<function [[renameCmd]]>>=
/*
 * this is only a partial implementation
 * should copy files to other directories,
 * and copy & truncate inbox
 */
static void
renameCmd(char *tg, char *cmd)
{
    char *from, *to;
    int ok;

    mustBe(' ');
    from = astring();
    mustBe(' ');
    to = astring();
    crnl();
    check();

    to = mboxName(to);
    if(to == nil || !okMbox(to) || cistrcmp(to, "inbox") == 0){
        Bprint(&bout, "%s NO %s bad mailbox destination name\r\n", tg, cmd);
        return;
    }
    if(access(to, AEXIST) >= 0){
        Bprint(&bout, "%s NO %s mailbox already exists\r\n", tg, cmd);
        return;
    }
    from = mboxName(from);
    if(from == nil || !okMbox(from)){
        Bprint(&bout, "%s NO %s bad mailbox destination name\r\n", tg, cmd);
        return;
    }
    if(cistrcmp(from, "inbox") == 0)
        ok = copyBox(from, to, 0);
    else
        ok = moveBox(from, to);

    if(ok)
        Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
    else
        Bprint(&bout, "%s NO %s failed\r\n", tg, cmd);
}
@

<<function [[searchCmd]]>>=
static void
searchCmd(char *tg, char *cmd)
{
    searchUCmd(tg, cmd, 0);
}
@

<<function [[searchUCmd]]>>=
static void
searchUCmd(char *tg, char *cmd, int uids)
{
    Search rock;
    Msg *m;
    char *uid;
    ulong id;

    mustBe(' ');
    rock.next = nil;
    searchKeys(1, &rock);
    crnl();
    uid = "";
    if(uids)
        uid = "uid ";
    if(rock.next != nil && rock.next->key == SKCharset){
        if(cistrstr(rock.next->s, "utf-8") != 0
        && cistrcmp(rock.next->s, "us-ascii") != 0){
            Bprint(&bout, "%s NO [BADCHARSET] (\"US-ASCII\" \"UTF-8\") %s%s failed\r\n", tg, uid, cmd);
            checkBox(selected, 0);
            status(uids, uids);
            return;
        }
        rock.next = rock.next->next;
    }
    Bprint(&bout, "* search");
    for(m = selected->msgs; m != nil; m = m->next)
        m->matched = searchMsg(m, rock.next);
    for(m = selected->msgs; m != nil; m = m->next){
        if(m->matched){
            if(uids)
                id = m->uid;
            else
                id = m->seq;
            Bprint(&bout, " %lud", id);
        }
    }
    Bprint(&bout, "\r\n");
    checkBox(selected, 0);
    status(uids, uids);
    Bprint(&bout, "%s OK %s%s completed\r\n", tg, uid, cmd);
}
@

<<function [[selectCmd]]>>=
static void
selectCmd(char *tg, char *cmd)
{
    Msg *m;
    char *s, *mbox;

    mustBe(' ');
    mbox = astring();
    crnl();

    if(selected){
        imapState = SAuthed;
        closeBox(selected, 1);
        selected = nil;
    }

    mbox = mboxName(mbox);
    if(mbox == nil || !okMbox(mbox)){
        Bprint(&bout, "%s NO %s bad mailbox\r\n", tg, cmd);
        return;
    }

    selected = openBox(mbox, "imap", cistrcmp(cmd, "select") == 0);
    if(selected == nil){
        Bprint(&bout, "%s NO %s can't open mailbox %s: %r\r\n", tg, cmd, mbox);
        return;
    }

    imapState = SSelected;

    Bprint(&bout, "* FLAGS (\\Seen \\Answered \\Flagged \\Deleted \\Draft)\r\n");
    Bprint(&bout, "* %lud EXISTS\r\n", selected->max);
    selected->toldMax = selected->max;
    Bprint(&bout, "* %lud RECENT\r\n", selected->recent);
    selected->toldRecent = selected->recent;
    for(m = selected->msgs; m != nil; m = m->next){
        if(!m->expunged && (m->flags & MSeen) != MSeen){
            Bprint(&bout, "* OK [UNSEEN %ld]\r\n", m->seq);
            break;
        }
    }
    Bprint(&bout, "* OK [PERMANENTFLAGS (\\Seen \\Answered \\Flagged \\Draft \\Deleted)]\r\n");
    Bprint(&bout, "* OK [UIDNEXT %ld]\r\n", selected->uidnext);
    Bprint(&bout, "* OK [UIDVALIDITY %ld]\r\n", selected->uidvalidity);
    s = "READ-ONLY";
    if(selected->writable)
        s = "READ-WRITE";
    Bprint(&bout, "%s OK [%s] %s %s completed\r\n", tg, s, cmd, mbox);
}
@

<<global [[statusItems]]>>=
static NamedInt	statusItems[] =
{
    {"MESSAGES",	SMessages},
    {"RECENT",	SRecent},
    {"UIDNEXT",	SUidNext},
    {"UIDVALIDITY",	SUidValidity},
    {"UNSEEN",	SUnseen},
    {nil,		0}
};
@

<<function [[statusCmd]]>>=
static void
statusCmd(char *tg, char *cmd)
{
    Box *box;
    Msg *m;
    char *s, *mbox;
    ulong v;
    int si, i;

    mustBe(' ');
    mbox = astring();
    mustBe(' ');
    mustBe('(');
    si = 0;
    for(;;){
        s = atom();
        i = mapInt(statusItems, s);
        if(i == 0)
            parseErr("illegal status item");
        si |= i;
        if(peekc() == ')')
            break;
        mustBe(' ');
    }
    mustBe(')');
    crnl();

    mbox = mboxName(mbox);
    if(mbox == nil || !okMbox(mbox)){
        check();
        Bprint(&bout, "%s NO %s bad mailbox\r\n", tg, cmd);
        return;
    }

    box = openBox(mbox, "status", 1);
    if(box == nil){
        check();
        Bprint(&bout, "%s NO [TRYCREATE] %s can't open mailbox %s: %r\r\n", tg, cmd, mbox);
        return;
    }

    Bprint(&bout, "* STATUS %s (", mbox);
    s = "";
    for(i = 0; statusItems[i].name != nil; i++){
        if(si & statusItems[i].v){
            v = 0;
            switch(statusItems[i].v){
            case SMessages:
                v = box->max;
                break;
            case SRecent:
                v = box->recent;
                break;
            case SUidNext:
                v = box->uidnext;
                break;
            case SUidValidity:
                v = box->uidvalidity;
                break;
            case SUnseen:
                v = 0;
                for(m = box->msgs; m != nil; m = m->next)
                    if((m->flags & MSeen) != MSeen)
                        v++;
                break;
            default:
                Bprint(&bout, ")");
                bye("internal error: status item not implemented");
                break;
            }
            Bprint(&bout, "%s%s %lud", s, statusItems[i].name, v);
            s = " ";
        }
    }
    Bprint(&bout, ")\r\n");
    closeBox(box, 1);

    check();
    Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
}
@

<<function [[storeCmd]]>>=
static void
storeCmd(char *tg, char *cmd)
{
    storeUCmd(tg, cmd, 0);
}
@

<<function [[storeUCmd]]>>=
static void
storeUCmd(char *tg, char *cmd, int uids)
{
    Store *st;
    MsgSet *ms;
    MbLock *ml;
    char *uid;
    ulong max;
    int ok;

    mustBe(' ');
    ms = msgSet(uids);
    mustBe(' ');
    st = storeWhat();
    crnl();
    uid = "";
    if(uids)
        uid = "uid ";
    max = selected->max;
    ml = checkBox(selected, 1);
    ok = ml != nil && forMsgs(selected, ms, max, uids, storeMsg, st);
    closeImp(selected, ml);
    status(uids, uids);
    if(ok)
        Bprint(&bout, "%s OK %s%s completed\r\n", tg, uid, cmd);
    else
        Bprint(&bout, "%s NO %s%s failed\r\n", tg, uid, cmd);
}
@

<<function [[subscribeCmd]]>>=
/*
 * minimal implementation of subscribe
 * all folders are automatically subscribed,
 * and can't be unsubscribed
 */
static void
subscribeCmd(char *tg, char *cmd)
{
    Box *box;
    char *mbox;
    int ok;

    mustBe(' ');
    mbox = astring();
    crnl();
    check();
    mbox = mboxName(mbox);
    ok = 0;
    if(mbox != nil && okMbox(mbox)){
        box = openBox(mbox, "subscribe", 0);
        if(box != nil){
            ok = subscribe(mbox, 's');
            closeBox(box, 1);
        }
    }
    if(!ok)
        Bprint(&bout, "%s NO %s bad mailbox\r\n", tg, cmd);
    else
        Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
}
@

<<function [[uidCmd]]>>=
static void
uidCmd(char *tg, char *cmd)
{
    char *sub;

    mustBe(' ');
    sub = atom();
    if(cistrcmp(sub, "copy") == 0)
        copyUCmd(tg, sub, 1);
    else if(cistrcmp(sub, "fetch") == 0)
        fetchUCmd(tg, sub, 1);
    else if(cistrcmp(sub, "search") == 0)
        searchUCmd(tg, sub, 1);
    else if(cistrcmp(sub, "store") == 0)
        storeUCmd(tg, sub, 1);
    else{
        clearcmd();
        Bprint(&bout, "%s BAD %s illegal uid command %s\r\n", tg, cmd, sub);
    }
}
@

<<function [[unsubscribeCmd]]>>=
static void
unsubscribeCmd(char *tg, char *cmd)
{
    char *mbox;

    mustBe(' ');
    mbox = astring();
    crnl();
    check();
    mbox = mboxName(mbox);
    if(mbox == nil || !okMbox(mbox) || !subscribe(mbox, 'u'))
        Bprint(&bout, "%s NO %s can't unsubscribe\r\n", tg, cmd);
    else
        Bprint(&bout, "%s OK %s completed\r\n", tg, cmd);
}
@

<<function [[badsyn]]>>=
static void
badsyn(void)
{
    parseErr("bad syntax");
}
@

<<function [[clearcmd]]>>=
static void
clearcmd(void)
{
    int c;

    for(;;){
        c = getc();
        if(c < 0)
            bye("end of input");
        if(c == '\n')
            return;
    }
}
@

<<function [[crnl]]>>=
static void
crnl(void)
{
    int c;

    c = getc();
    if(c == '\n')
        return;
    if(c != '\r' || getc() != '\n')
        badsyn();
}
@

<<function [[mustBe]]>>=
static void
mustBe(int c)
{
    if(getc() != c){
        ungetc();
        badsyn();
    }
}
@

<<function [[flagList]]>>=
/*
 * flaglist	: '(' ')' | '(' flags ')'
 */
static int
flagList(void)
{
    int f;

    mustBe('(');
    f = 0;
    if(peekc() != ')')
        f = flags();

    mustBe(')');
    return f;
}
@

<<function [[flags]]([[(networking/ip/imap4d/imap4d.c)]])>>=
/*
 * flags	: flag | flags ' ' flag
 * flag		: '\' atom | atom
 */
static int
flags(void)
{
    int ff, flags;
    char *s;
    int c;

    flags = 0;
    for(;;){
        c = peekc();
        if(c == '\\'){
            mustBe('\\');
            s = atomString(atomStop, "\\");
        }else if(strchr(atomStop, c) != nil)
            s = atom();
        else
            break;
        ff = mapFlag(s);
        if(ff == 0)
            parseErr("flag not supported");
        flags |= ff;
        if(peekc() != ' ')
            break;
        mustBe(' ');
    }
    if(flags == 0)
        parseErr("no flags given");
    return flags;
}
@

<<function [[storeWhat]]>>=
/*
 * storeWhat	: osign 'FLAGS' ' ' storeflags
 *		| osign 'FLAGS.SILENT' ' ' storeflags
 * osign	:
 *		| '+' | '-'
 * storeflags	: flagList | flags
 */
static Store*
storeWhat(void)
{
    int f;
    char *s;
    int c, w;

    c = peekc();
    if(c == '+' || c == '-')
        mustBe(c);
    else
        c = 0;
    s = atom();
    w = 0;
    if(cistrcmp(s, "flags") == 0)
        w = STFlags;
    else if(cistrcmp(s, "flags.silent") == 0)
        w = STFlagsSilent;
    else
        parseErr("illegal store attribute");
    mustBe(' ');
    if(peekc() == '(')
        f = flagList();
    else
        f = flags();
    return mkStore(c, w, f);
}
@

<<global [[fetchAtom]]>>=
/*
 * fetchWhat	: "ALL" | "FULL" | "FAST" | fetchAtt | '(' fetchAtts ')'
 * fetchAtts	: fetchAtt | fetchAtts ' ' fetchAtt
 */
static char *fetchAtom	= "(){}%*\"\\[]";
@

<<function [[fetchWhat]]>>=
static Fetch*
fetchWhat(void)
{
    Fetch *f;
    char *s;

    if(peekc() == '('){
        getc();
        f = nil;
        for(;;){
            s = atomString(fetchAtom, "");
            f = fetchAtt(s, f);
            if(peekc() == ')')
                break;
            mustBe(' ');
        }
        getc();
        return revFetch(f);
    }

    s = atomString(fetchAtom, "");
    if(cistrcmp(s, "all") == 0)
        f = mkFetch(FFlags, mkFetch(FInternalDate, mkFetch(FRfc822Size, mkFetch(FEnvelope, nil))));
    else if(cistrcmp(s, "fast") == 0)
        f = mkFetch(FFlags, mkFetch(FInternalDate, mkFetch(FRfc822Size, nil)));
    else if(cistrcmp(s, "full") == 0)
        f = mkFetch(FFlags, mkFetch(FInternalDate, mkFetch(FRfc822Size, mkFetch(FEnvelope, mkFetch(FBody, nil)))));
    else
        f = fetchAtt(s, nil);
    return f;
}
@

<<function [[fetchAtt]]>>=
/*
 * fetchAtt	: "ENVELOPE" | "FLAGS" | "INTERNALDATE"
 *		| "RFC822" | "RFC822.HEADER" | "RFC822.SIZE" | "RFC822.TEXT"
 *		| "BODYSTRUCTURE"
 *		| "UID"
 *		| "BODY"
 *		| "BODY" bodysubs
 *		| "BODY.PEEK" bodysubs
 * bodysubs	: sect
 *		| sect '<' number '.' nz-number '>'
 * sect		: '[' sectSpec ']'
 * sectSpec	: sectMsgText
 *		| sectPart
 *		| sectPart '.' sectText
 * sectPart	: nz-number
 *		| sectPart '.' nz-number
 */
static Fetch*
fetchAtt(char *s, Fetch *f)
{
    NList *sect;
    int c;

    if(cistrcmp(s, "envelope") == 0)
        return mkFetch(FEnvelope, f);
    if(cistrcmp(s, "flags") == 0)
        return mkFetch(FFlags, f);
    if(cistrcmp(s, "internaldate") == 0)
        return mkFetch(FInternalDate, f);
    if(cistrcmp(s, "RFC822") == 0)
        return mkFetch(FRfc822, f);
    if(cistrcmp(s, "RFC822.header") == 0)
        return mkFetch(FRfc822Head, f);
    if(cistrcmp(s, "RFC822.size") == 0)
        return mkFetch(FRfc822Size, f);
    if(cistrcmp(s, "RFC822.text") == 0)
        return mkFetch(FRfc822Text, f);
    if(cistrcmp(s, "bodystructure") == 0)
        return mkFetch(FBodyStruct, f);
    if(cistrcmp(s, "uid") == 0)
        return mkFetch(FUid, f);

    if(cistrcmp(s, "body") == 0){
        if(peekc() != '[')
            return mkFetch(FBody, f);
        f = mkFetch(FBodySect, f);
    }else if(cistrcmp(s, "body.peek") == 0)
        f = mkFetch(FBodyPeek, f);
    else
        parseErr("illegal fetch attribute");

    mustBe('[');
    c = peekc();
    if(c >= '1' && c <= '9'){
        sect = mkNList(number(1), nil);
        while(peekc() == '.'){
            getc();
            c = peekc();
            if(c >= '1' && c <= '9'){
                sect = mkNList(number(1), sect);
            }else{
                break;
            }
        }
        f->sect = revNList(sect);
    }
    if(peekc() != ']')
        sectText(f, f->sect != nil);
    mustBe(']');

    if(peekc() != '<')
        return f;

    f->partial = 1;
    mustBe('<');
    f->start = number(0);
    mustBe('.');
    f->size = number(1);
    mustBe('>');
    return f;
}
@

<<function [[sectText]]>>=
/*
 * sectText	: sectMsgText | "MIME"
 * sectMsgText	: "HEADER"
 *		| "TEXT"
 *		| "HEADER.FIELDS" ' ' hdrList
 *		| "HEADER.FIELDS.NOT" ' ' hdrList
 * hdrList	: '(' hdrs ')'
 * hdrs:	: astring
 *		| hdrs ' ' astring
 */
static void
sectText(Fetch *f, int mimeOk)
{
    SList *h;
    char *s;

    s = atomString(fetchAtom, "");
    if(cistrcmp(s, "header") == 0){
        f->part = FPHead;
        return;
    }
    if(cistrcmp(s, "text") == 0){
        f->part = FPText;
        return;
    }
    if(mimeOk && cistrcmp(s, "mime") == 0){
        f->part = FPMime;
        return;
    }
    if(cistrcmp(s, "header.fields") == 0)
        f->part = FPHeadFields;
    else if(cistrcmp(s, "header.fields.not") == 0)
        f->part = FPHeadFieldsNot;
    else
        parseErr("illegal fetch section text");
    mustBe(' ');
    mustBe('(');
    h = nil;
    for(;;){
        h = mkSList(astring(), h);
        if(peekc() == ')')
            break;
        mustBe(' ');
    }
    mustBe(')');
    f->hdrs = revSList(h);
}
@

<<global [[searchMap]]>>=
/*
 * searchWhat	: "CHARSET" ' ' astring searchkeys | searchkeys
 * searchkeys	: searchkey | searchkeys ' ' searchkey
 * searchkey	: "ALL" | "ANSWERED" | "DELETED" | "FLAGGED" | "NEW" | "OLD" | "RECENT"
 *		| "SEEN" | "UNANSWERED" | "UNDELETED" | "UNFLAGGED" | "DRAFT" | "UNDRAFT"
 *		| astrkey ' ' astring
 *		| datekey ' ' date
 *		| "KEYWORD" ' ' flag | "UNKEYWORD" flag
 *		| "LARGER" ' ' number | "SMALLER" ' ' number
 * 		| "HEADER" astring ' ' astring
 *		| set | "UID" ' ' set
 *		| "NOT" ' ' searchkey
 *		| "OR" ' ' searchkey ' ' searchkey
 *		| '(' searchkeys ')'
 * astrkey	: "BCC" | "BODY" | "CC" | "FROM" | "SUBJECT" | "TEXT" | "TO"
 * datekey	: "BEFORE" | "ON" | "SINCE" | "SENTBEFORE" | "SENTON" | "SENTSINCE"
 */
static NamedInt searchMap[] =
{
    {"ALL",		SKAll},
    {"ANSWERED",	SKAnswered},
    {"DELETED",	SKDeleted},
    {"FLAGGED",	SKFlagged},
    {"NEW",		SKNew},
    {"OLD",		SKOld},
    {"RECENT",	SKRecent},
    {"SEEN",	SKSeen},
    {"UNANSWERED",	SKUnanswered},
    {"UNDELETED",	SKUndeleted},
    {"UNFLAGGED",	SKUnflagged},
    {"DRAFT",	SKDraft},
    {"UNDRAFT",	SKUndraft},
    {"UNSEEN",	SKUnseen},
    {nil,		0}
};
@

<<global [[searchMapStr]]>>=
static NamedInt searchMapStr[] =
{
    {"CHARSET",	SKCharset},
    {"BCC",		SKBcc},
    {"BODY",	SKBody},
    {"CC",		SKCc},
    {"FROM",	SKFrom},
    {"SUBJECT",	SKSubject},
    {"TEXT",	SKText},
    {"TO",		SKTo},
    {nil,		0}
};
@

<<global [[searchMapDate]]>>=
static NamedInt searchMapDate[] =
{
    {"BEFORE",	SKBefore},
    {"ON",		SKOn},
    {"SINCE",	SKSince},
    {"SENTBEFORE",	SKSentBefore},
    {"SENTON",	SKSentOn},
    {"SENTSINCE",	SKSentSince},
    {nil,		0}
};
@

<<global [[searchMapFlag]]>>=
static NamedInt searchMapFlag[] =
{
    {"KEYWORD",	SKKeyword},
    {"UNKEYWORD",	SKUnkeyword},
    {nil,		0}
};
@

<<global [[searchMapNum]]>>=
static NamedInt searchMapNum[] =
{
    {"SMALLER",	SKSmaller},
    {"LARGER",	SKLarger},
    {nil,		0}
};
@

<<function [[searchKeys]]>>=
static Search*
searchKeys(int first, Search *tail)
{
    Search *s;

    for(;;){
        if(peekc() == '('){
            getc();
            tail = searchKeys(0, tail);
            mustBe(')');
        }else{
            s = searchKey(first);
            tail->next = s;
            tail = s;
        }
        first = 0;
        if(peekc() != ' ')
            break;
        getc();
    }
    return tail;
}
@

<<function [[searchKey]]>>=
static Search*
searchKey(int first)
{
    Search *sr, rock;
    Tm tm;
    char *a;
    int i, c;

    sr = binalloc(&parseBin, sizeof(Search), 1);
    if(sr == nil)
        parseErr("out of memory");

    c = peekc();
    if(c >= '0' && c <= '9'){
        sr->key = SKSet;
        sr->set = msgSet(0);
        return sr;
    }

    a = atom();
    if(i = mapInt(searchMap, a))
        sr->key = i;
    else if(i = mapInt(searchMapStr, a)){
        if(!first && i == SKCharset)
            parseErr("illegal search key");
        sr->key = i;
        mustBe(' ');
        sr->s = astring();
    }else if(i = mapInt(searchMapDate, a)){
        sr->key = i;
        mustBe(' ');
        c = peekc();
        if(c == '"')
            getc();
        a = atom();
        if(!imap4Date(&tm, a))
            parseErr("bad date format");
        sr->year = tm.year;
        sr->mon = tm.mon;
        sr->mday = tm.mday;
        if(c == '"')
            mustBe('"');
    }else if(i = mapInt(searchMapFlag, a)){
        sr->key = i;
        mustBe(' ');
        c = peekc();
        if(c == '\\'){
            mustBe('\\');
            a = atomString(atomStop, "\\");
        }else
            a = atom();
        i = mapFlag(a);
        if(i == 0)
            parseErr("flag not supported");
        sr->num = i;
    }else if(i = mapInt(searchMapNum, a)){
        sr->key = i;
        mustBe(' ');
        sr->num = number(0);
    }else if(cistrcmp(a, "HEADER") == 0){
        sr->key = SKHeader;
        mustBe(' ');
        sr->hdr = astring();
        mustBe(' ');
        sr->s = astring();
    }else if(cistrcmp(a, "UID") == 0){
        sr->key = SKUid;
        mustBe(' ');
        sr->set = msgSet(0);
    }else if(cistrcmp(a, "NOT") == 0){
        sr->key = SKNot;
        mustBe(' ');
        rock.next = nil;
        searchKeys(0, &rock);
        sr->left = rock.next;
    }else if(cistrcmp(a, "OR") == 0){
        sr->key = SKOr;
        mustBe(' ');
        rock.next = nil;
        searchKeys(0, &rock);
        sr->left = rock.next;
        mustBe(' ');
        rock.next = nil;
        searchKeys(0, &rock);
        sr->right = rock.next;
    }else
        parseErr("illegal search key");
    return sr;
}
@

<<function [[msgSet]]>>=
/*
 * set	: seqno
 *	| seqno ':' seqno
 *	| set ',' set
 * seqno: nz-number
 *	| '*'
 *
 */
static MsgSet*
msgSet(int uids)
{
    MsgSet head, *last, *ms;
    ulong from, to;

    last = &head;
    head.next = nil;
    for(;;){
        from = uids ? uidNo() : seqNo();
        to = from;
        if(peekc() == ':'){
            getc();
            to = uids ? uidNo() : seqNo();
        }
        ms = binalloc(&parseBin, sizeof(MsgSet), 0);
        if(ms == nil)
            parseErr("out of memory");
        ms->from = from;
        ms->to = to;
        ms->next = nil;
        last->next = ms;
        last = ms;
        if(peekc() != ',')
            break;
        getc();
    }
    return head.next;
}
@

<<function [[seqNo]]>>=
static ulong
seqNo(void)
{
    if(peekc() == '*'){
        getc();
        return ~0UL;
    }
    return number(1);
}
@

<<function [[uidNo]]>>=
static ulong
uidNo(void)
{
    if(peekc() == '*'){
        getc();
        return ~0UL;
    }
    return number(0);
}
@

<<function [[atom]]>>=
/*
 * 7 bit, non-ctl chars, no (){%*"\
 * NIL is special case for nstring or parenlist
 */
static char *
atom(void)
{
    return atomString(atomStop, "");
}
@

<<function [[tag]]>>=
/*
 * like an atom, but no +
 */
static char *
tag(void)
{
    return atomString("+(){%*\"\\", "");
}
@

<<function [[listmbox]]>>=
/*
 * string or atom allowing %*
 */
static char *
listmbox(void)
{
    int c;

    c = peekc();
    if(c == '{')
        return literal();
    if(c == '"')
        return quoted();
    return atomString("(){\"\\", "");
}
@

<<function [[astring]]>>=
/*
 * string or atom
 */
static char *
astring(void)
{
    int c;

    c = peekc();
    if(c == '{')
        return literal();
    if(c == '"')
        return quoted();
    return atom();
}
@

<<function [[atomString]]>>=
/*
 * 7 bit, non-ctl chars, none from exception list
 */
static char *
atomString(char *disallowed, char *initial)
{
    char *s;
    int c, ns, as;

    ns = strlen(initial);
    s = binalloc(&parseBin, ns + StrAlloc, 0);
    if(s == nil)
        parseErr("out of memory");
    strcpy(s, initial);
    as = ns + StrAlloc;
    for(;;){
        c = getc();
        if(c <= ' ' || c >= 0x7f || strchr(disallowed, c) != nil){
            ungetc();
            break;
        }
        s[ns++] = c;
        if(ns >= as){
            s = bingrow(&parseBin, s, as, as + StrAlloc, 0);
            if(s == nil)
                parseErr("out of memory");
            as += StrAlloc;
        }
    }
    if(ns == 0)
        badsyn();
    s[ns] = '\0';
    return s;
}
@

<<function [[quoted]]>>=
/*
 * quoted: '"' chars* '"'
 * chars:	1-128 except \r and \n
 */
static char *
quoted(void)
{
    char *s;
    int c, ns, as;

    mustBe('"');
    s = binalloc(&parseBin, StrAlloc, 0);
    if(s == nil)
        parseErr("out of memory");
    as = StrAlloc;
    ns = 0;
    for(;;){
        c = getc();
        if(c == '"')
            break;
        if(c < 1 || c > 0x7f || c == '\r' || c == '\n')
            badsyn();
        if(c == '\\'){
            c = getc();
            if(c != '\\' && c != '"')
                badsyn();
        }
        s[ns++] = c;
        if(ns >= as){
            s = bingrow(&parseBin, s, as, as + StrAlloc, 0);
            if(s == nil)
                parseErr("out of memory");
            as += StrAlloc;
        }
    }
    s[ns] = '\0';
    return s;
}
@

<<function [[litlen]]>>=
/*
 * litlen: {number}\r\n
 */
static ulong
litlen(void)
{
    ulong v;

    mustBe('{');
    v = number(0);
    mustBe('}');
    crnl();
    return v;
}
@

<<function [[literal]]>>=
/*
 * literal: litlen data<0:litlen>
 */
static char *
literal(void)
{
    char *s;
    ulong v;

    v = litlen();
    s = binalloc(&parseBin, v+1, 0);
    if(s == nil)
        parseErr("out of memory");
    Bprint(&bout, "+ Ready for literal data\r\n");
    if(Bflush(&bout) < 0)
        writeErr();
    if(v != 0 && Bread(&bin, s, v) != v)
        badsyn();
    s[v] = '\0';
    return s;
}
@

<<function [[number]]>>=
/*
 * digits; number is 32 bits
 */
static ulong
number(int nonzero)
{
    ulong v;
    int c, first;

    v = 0;
    first = 1;
    for(;;){
        c = getc();
        if(c < '0' || c > '9'){
            ungetc();
            if(first)
                badsyn();
            break;
        }
        if(nonzero && first && c == '0')
            badsyn();
        c -= '0';
        first = 0;
        if(v > UlongMax/10 || v == UlongMax/10 && c > UlongMax%10)
            parseErr("number out of range\r\n");
        v = v * 10 + c;
    }
    return v;
}
@

<<function [[getc]]>>=
static int
getc(void)
{
    return Bgetc(&bin);
}
@

<<function [[ungetc]]>>=
static void
ungetc(void)
{
    Bungetc(&bin);
}
@

<<function [[peekc]]>>=
static int
peekc(void)
{
    int c;

    c = Bgetc(&bin);
    Bungetc(&bin);
    return c;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/imap4d.c>>=
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <bio.h>
#include "imap4d.h"

/*
 * these should be in libraries
 */
char	*csquery(char *attr, char *val, char *rattr);

/*
 * /lib/rfc/rfc2060 imap4rev1
 * /lib/rfc/rfc2683 is implementation advice
 * /lib/rfc/rfc2342 is namespace capability
 * /lib/rfc/rfc2222 is security protocols
 * /lib/rfc/rfc1731 is security protocols
 * /lib/rfc/rfc2221 is LOGIN-REFERRALS
 * /lib/rfc/rfc2193 is MAILBOX-REFERRALS
 * /lib/rfc/rfc2177 is IDLE capability
 * /lib/rfc/rfc2195 is CRAM-MD5 authentication
 * /lib/rfc/rfc2088 is LITERAL+ capability
 * /lib/rfc/rfc1760 is S/Key authentication
 *
 * outlook uses "Secure Password Authentication" aka ntlm authentication
 *
 * capabilities from nslocum
 * CAPABILITY IMAP4 IMAP4REV1 NAMESPACE IDLE SCAN SORT MAILBOX-REFERRALS LOGIN-REFERRALS AUTH=LOGIN THREAD=ORDEREDSUBJECT
 */

typedef struct	ParseCmd	ParseCmd;

<<enum [[_anon_ (networking/ip/imap4d/imap4d.c)]]>>

<<struct [[ParseCmd]]>>

static	void	appendCmd(char *tg, char *cmd);
static	void	authenticateCmd(char *tg, char *cmd);
static	void	capabilityCmd(char *tg, char *cmd);
static	void	closeCmd(char *tg, char *cmd);
static	void	copyCmd(char *tg, char *cmd);
static	void	createCmd(char *tg, char *cmd);
static	void	deleteCmd(char *tg, char *cmd);
static	void	expungeCmd(char *tg, char *cmd);
static	void	fetchCmd(char *tg, char *cmd);
static	void	idleCmd(char *tg, char *cmd);
static	void	listCmd(char *tg, char *cmd);
static	void	loginCmd(char *tg, char *cmd);
static	void	logoutCmd(char *tg, char *cmd);
static	void	namespaceCmd(char *tg, char *cmd);
static	void	noopCmd(char *tg, char *cmd);
static	void	renameCmd(char *tg, char *cmd);
static	void	searchCmd(char *tg, char *cmd);
static	void	selectCmd(char *tg, char *cmd);
static	void	statusCmd(char *tg, char *cmd);
static	void	storeCmd(char *tg, char *cmd);
static	void	subscribeCmd(char *tg, char *cmd);
static	void	uidCmd(char *tg, char *cmd);
static	void	unsubscribeCmd(char *tg, char *cmd);

static	void	copyUCmd(char *tg, char *cmd, int uids);
static	void	fetchUCmd(char *tg, char *cmd, int uids);
static	void	searchUCmd(char *tg, char *cmd, int uids);
static	void	storeUCmd(char *tg, char *cmd, int uids);

static	void	imap4(int);
static	void	status(int expungeable, int uids);
static	void	cleaner(void);
static	void	check(void);
static	int	catcher(void*, char*);

static	Search	*searchKey(int first);
static	Search	*searchKeys(int first, Search *tail);
static	char	*astring(void);
static	char	*atomString(char *disallowed, char *initial);
static	char	*atom(void);
static	void	badsyn(void);
static	void	clearcmd(void);
static	char	*command(void);
static	void	crnl(void);
static	Fetch	*fetchAtt(char *s, Fetch *f);
static	Fetch	*fetchWhat(void);
static	int	flagList(void);
static	int	flags(void);
static	int	getc(void);
static	char	*listmbox(void);
static	char	*literal(void);
static	ulong	litlen(void);
static	MsgSet	*msgSet(int);
static	void	mustBe(int c);
static	ulong	number(int nonzero);
static	int	peekc(void);
static	char	*quoted(void);
static	void	sectText(Fetch *f, int mimeOk);
static	ulong	seqNo(void);
static	Store	*storeWhat(void);
static	char	*tag(void);
static	ulong	uidNo(void);
static	void	ungetc(void);

<<global [[SNonAuthed]]>>

<<global [[SAuthed]]>>

<<global [[SSelected]]>>

<<global [[atomStop]]>>
<<global [[chal]]>>
<<global [[chaled]]>>
<<global [[imapState]]>>
<<global [[parseJmp]]>>
<<global [[parseMsg]]>>
<<global [[allowPass]]>>
<<global [[allowCR]]>>
<<global [[exiting]]>>
<<global [[imaplock]]>>
<<global [[idlepid]]>>

<<global [[bout]]([[(networking/ip/imap4d/imap4d.c)]])>>
<<global [[bin]]>>
<<global [[username]]>>
<<global [[mboxDir]]>>
<<global [[servername]]([[(networking/ip/imap4d/imap4d.c)]])>>
<<global [[site]]>>
<<global [[remote]]>>
<<global [[selected]]>>
<<global [[parseBin]]>>
<<global [[debug]]([[(networking/ip/imap4d/imap4d.c)]])>>

<<function [[main]]([[(networking/ip/imap4d/imap4d.c)]])>>

<<function [[imap4]]>>

<<function [[bye]]>>

<<function [[parseErr]]>>

<<function [[writeErr]]>>

<<function [[catcher]]([[(networking/ip/imap4d/imap4d.c)]])>>

<<function [[cleaner]]>>

<<function [[status]]>>

<<function [[check]]>>

<<function [[appendCmd]]>>

<<function [[authenticateCmd]]>>

<<function [[capabilityCmd]]>>

<<function [[closeCmd]]>>

<<function [[copyCmd]]>>

<<function [[copyUCmd]]>>

<<function [[createCmd]]>>

<<function [[deleteCmd]]>>

<<function [[expungeCmd]]>>

<<function [[fetchCmd]]>>

<<function [[fetchUCmd]]>>

<<function [[idleCmd]]>>

<<function [[listCmd]]>>

<<function [[passCR]]>>

<<function [[loginCmd]]>>

<<function [[logoutCmd]]>>

<<function [[namespaceCmd]]>>

<<function [[noopCmd]]>>

<<function [[renameCmd]]>>

<<function [[searchCmd]]>>

<<function [[searchUCmd]]>>

<<function [[selectCmd]]>>

<<global [[statusItems]]>>

<<function [[statusCmd]]>>

<<function [[storeCmd]]>>

<<function [[storeUCmd]]>>

<<function [[subscribeCmd]]>>

<<function [[uidCmd]]>>

<<function [[unsubscribeCmd]]>>

<<function [[badsyn]]>>

<<function [[clearcmd]]>>

<<function [[crnl]]>>

<<function [[mustBe]]>>

<<function [[flagList]]>>

<<function [[flags]]([[(networking/ip/imap4d/imap4d.c)]])>>

<<function [[storeWhat]]>>

<<global [[fetchAtom]]>>
<<function [[fetchWhat]]>>

<<function [[fetchAtt]]>>

<<function [[sectText]]>>

<<global [[searchMap]]>>

<<global [[searchMapStr]]>>

<<global [[searchMapDate]]>>

<<global [[searchMapFlag]]>>

<<global [[searchMapNum]]>>

<<function [[searchKeys]]>>

<<function [[searchKey]]>>

<<function [[msgSet]]>>

<<function [[seqNo]]>>

<<function [[uidNo]]>>

<<function [[atom]]>>

<<function [[tag]]>>

<<function [[listmbox]]>>

<<function [[astring]]>>

<<function [[atomString]]>>

<<function [[quoted]]>>

<<function [[litlen]]>>

<<function [[literal]]>>

<<function [[number]]>>

<<function [[getc]]>>

<<function [[ungetc]]>>

<<function [[peekc]]>>

@


\subsection*{[[networking/ip/imap4d/imap4d.h]]}

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)]]>>=
enum
{
    StrAlloc	= 32,		/* characters allocated at a time */
    BufSize		= 8*1024,	/* size of transfer block */
    NDigest		= 40,		/* length of digest string */
    NUid		= 10,		/* length of .imp uid string */
    NFlags		= 8,		/* length of .imp flag string */
    LockSecs	= 5 * 60,	/* seconds to wait for acquiring a locked file */
    MboxNameLen	= 256,		/* max. length of upas/fs mbox name */
    MsgNameLen	= 32,		/* max. length of a file in a upas/fs mbox */
    UserNameLen	= 64,		/* max. length of user's name */

    MUtf7Max	= 6,		/* max length for a modified utf7 character: &bbbb- */

    /*
     * message flags
     */
    MSeen		= 1 << 0,
    MAnswered	= 1 << 1,
    MFlagged	= 1 << 2,
    MDeleted	= 1 << 3,
    MDraft		= 1 << 4,
    MRecent		= 1 << 5,

    /*
     * message bogus flags
     */
    NotBogus	= 0,	/* the message is displayable */
    BogusHeader	= 1,	/* the header had bad characters */
    BogusBody	= 2,	/* the body had bad characters */
    BogusTried	= 4,	/* attempted to open the fake message */
};
@

<<struct [[Box]]>>=
struct Box
{
    char	*name;		/* path name of mailbox */
    char	*fs;		/* fs name of mailbox */
    char	*fsDir;		/* /mail/fs/box->fs */
    char	*imp;		/* path name of .imp file */
    uchar	writable;	/* can write back messages? */
    uchar	dirtyImp;	/* .imp file needs to be written? */
    uchar	sendFlags;	/* need flags update */
    Qid	qid;		/* qid of fs mailbox */
    Qid	impQid;		/* qid of .imp when last synched */
    long	mtime;		/* file mtime when last read */
    ulong	max;		/* maximum msgs->seq, same as number of messages */
    ulong	toldMax;	/* last value sent to client */
    ulong	recent;		/* number of recently received messaged */
    ulong	toldRecent;	/* last value sent to client */
    ulong	uidnext;	/* next uid value assigned to a message */
    ulong	uidvalidity;	/* uid of mailbox */
    Msg	*msgs;
};
@

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)2]]>>=
/*
 * fields of Msg->info
 */
enum
{
    /*
     * read from upasfs
     */
    IFrom,
    ITo,
    ICc,
    IReplyTo,
    IUnixDate,
    ISubject,
    IType,
    IDisposition,
    IFilename,
    IDigest,
    IBcc,
    IInReplyTo,	/* aka internal date */
    IDate,
    ISender,
    IMessageId,
    ILines,		/* number of lines of raw body */

    IMax
};
@

<<struct [[Header]]>>=
struct Header
{
    char	*buf;		/* header, including terminating \r\n */
    ulong	size;		/* strlen(buf) */
    ulong	lines;		/* number of \n characters in buf */

    /*
     * pre-parsed mime headers
     */
    MimeHdr	*type;		/* content-type */
    MimeHdr	*id;		/* content-id */
    MimeHdr	*description;	/* content-description */
    MimeHdr	*encoding;	/* content-transfer-encoding */
    MimeHdr	*md5;		/* content-md5 */
    MimeHdr	*disposition;	/* content-disposition */
    MimeHdr	*language;	/* content-language */
};
@

<<struct [[Msg]]([[(networking/ip/imap4d/imap4d.h)]])>>=
struct Msg
{
    Msg	*next;
    Msg	*prev;
    Msg	*kids;
    Msg	*parent;
    char	*fsDir;		/* box->fsDir of enclosing message */
    Header	head;		/* message header */
    Header	mime;		/* mime header from enclosing multipart spec */
    int	flags;
    uchar	sendFlags;	/* flags value needs to be sent to client */
    uchar	expunged;	/* message actually expunged, but not yet reported to client */
    uchar	matched;	/* search succeeded? */
    uchar	bogus;		/* implies the message is invalid, ie contains nulls; see flags above */
    ulong	uid;		/* imap unique identifier */
    ulong	seq;		/* position in box; 1 is oldest */
    ulong	id;		/* number of message directory in upas/fs */
    char	*fs;		/* name of message directory */
    char	*efs;		/* pointer after / in fs; enough space for file name */

    ulong	size;		/* size of fs/rawbody, in bytes, with \r added before \n */
    ulong	lines;		/* number of lines in rawbody */

    char	*iBuf;
    char	*info[IMax];	/* all info about message */

    char	*unixDate;
    MAddr	*unixFrom;

    MAddr	*to;		/* parsed out address lines */
    MAddr	*from;
    MAddr	*replyTo;
    MAddr	*sender;
    MAddr	*cc;
    MAddr	*bcc;
};
@

<<struct [[MAddr]]>>=
/*
 * pre-parsed header lines
 */
struct MAddr
{
    char	*personal;
    char	*box;
    char	*host;
    MAddr	*next;
};
@

<<struct [[MimeHdr]]>>=
struct MimeHdr
{
    char	*s;
    char	*t;
    MimeHdr	*next;
};
@

<<struct [[NamedInt]]>>=
/*
 * mapping of integer & names
 */
struct NamedInt
{
    char	*name;
    int	v;
};
@

<<struct [[MbLock]]>>=
/*
 * lock for all mail file operations
 */
struct MbLock
{
    int	fd;
};
@

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)3]]>>=
/*
 * parse tree for fetch command
 */
enum
{
    FEnvelope,
    FFlags,
    FInternalDate,
    FRfc822,
    FRfc822Head,
    FRfc822Size,
    FRfc822Text,
    FBodyStruct,
    FUid,
    FBody,			/* BODY */
    FBodySect,		/* BODY [...] */
    FBodyPeek,

    FMax
};
@

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)4]]>>=
enum
{
    FPAll,
    FPHead,
    FPHeadFields,
    FPHeadFieldsNot,
    FPMime,
    FPText,

    FPMax
};
@

<<struct [[Fetch]]>>=
struct Fetch
{
    uchar	op;		/* F.* operator */
    uchar	part;		/* FP.* subpart for body[] & body.peek[]*/
    uchar	partial;	/* partial fetch? */
    long	start;		/* partial fetch amounts */
    long	size;
    NList	*sect;
    SList	*hdrs;
    Fetch	*next;
};
@

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)5]]>>=
/*
 * status items
 */
enum{
    SMessages	= 1 << 0,
    SRecent		= 1 << 1,
    SUidNext	= 1 << 2,
    SUidValidity	= 1 << 3,
    SUnseen		= 1 << 4,
};
@

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)6]]>>=
/*
 * parse tree for store command
 */
enum
{
    STFlags,
    STFlagsSilent,

    STMax
};
@

<<struct [[Store]]>>=
struct Store
{
    uchar	sign;
    uchar	op;
    int	flags;
};
@

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)7]]>>=
/*
 * parse tree for search command
 */
enum
{
    SKNone,

    SKCharset,

    SKAll,
    SKAnswered,
    SKBcc,
    SKBefore,
    SKBody,
    SKCc,
    SKDeleted,
    SKDraft,
    SKFlagged,
    SKFrom,
    SKHeader,
    SKKeyword,
    SKLarger,
    SKNew,
    SKNot,
    SKOld,
    SKOn,
    SKOr,
    SKRecent,
    SKSeen,
    SKSentBefore,
    SKSentOn,
    SKSentSince,
    SKSet,
    SKSince,
    SKSmaller,
    SKSubject,
    SKText,
    SKTo,
    SKUid,
    SKUnanswered,
    SKUndeleted,
    SKUndraft,
    SKUnflagged,
    SKUnkeyword,
    SKUnseen,

    SKMax
};
@

<<struct [[Search]]>>=
struct Search
{
    int	key;
    char	*s;
    char	*hdr;
    ulong	num;
    int	year;
    int	mon;
    int	mday;
    MsgSet	*set;
    Search	*left;
    Search	*right;
    Search	*next;
};
@

<<struct [[NList]]>>=
struct NList
{
    ulong	n;
    NList	*next;
};
@

<<struct [[SList]]>>=
struct SList
{
    char	*s;
    SList	*next;
};
@

<<struct [[MsgSet]]>>=
struct MsgSet
{
    ulong	from;
    ulong	to;
    MsgSet	*next;
};
@

<<struct [[Pair]]>>=
struct Pair
{
    ulong	start;
    ulong	stop;
};
@


%-------------------------------------------------------------

<<networking/ip/imap4d/imap4d.h>>=
/*
 * mailbox and message representations
 *
 * these structures are allocated with emalloc and must be explicitly freed
 */
typedef struct Box	Box;
typedef struct Header	Header;
typedef struct MAddr	MAddr;
typedef struct MbLock	MbLock;
typedef struct MimeHdr	MimeHdr;
typedef struct Msg	Msg;
typedef struct NamedInt	NamedInt;
typedef struct Pair	Pair;

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)]]>>

<<struct [[Box]]>>

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)2]]>>

<<struct [[Header]]>>

<<struct [[Msg]]([[(networking/ip/imap4d/imap4d.h)]])>>

<<struct [[MAddr]]>>

<<struct [[MimeHdr]]>>

<<struct [[NamedInt]]>>

<<struct [[MbLock]]>>

/*
 * parse nodes for imap4rev1 protocol
 *
 * important: all of these items are allocated
 * in one can, so they can be tossed out at the same time.
 * this allows leakless parse error recovery by simply tossing the can away.
 * however, it means these structures cannot be mixed with the mailbox structures
 */

typedef struct Fetch	Fetch;
typedef struct NList	NList;
typedef struct SList	SList;
typedef struct MsgSet	MsgSet;
typedef struct Store	Store;
typedef struct Search	Search;

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)3]]>>

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)4]]>>

<<struct [[Fetch]]>>

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)5]]>>

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)6]]>>

<<struct [[Store]]>>

<<enum [[_anon_ (networking/ip/imap4d/imap4d.h)7]]>>

<<struct [[Search]]>>

<<struct [[NList]]>>

<<struct [[SList]]>>

<<struct [[MsgSet]]>>

<<struct [[Pair]]>>

#include "bin.h"

extern	Bin	*parseBin;
extern	Biobuf	bout;
extern	Biobuf	bin;
extern	char	username[UserNameLen];
extern	char	mboxDir[MboxNameLen];
extern	char	*fetchPartNames[FPMax];
extern	char	*site;
extern	char	*remote;
extern	int	debug;

#include "fns.h"
@


\subsection*{[[networking/ip/imap4d/list.c]]}

<<constant [[SUBSCRIBED]]>>=
#define SUBSCRIBED	"imap.subscribed"
@

<<function [[listMtime]]>>=
static long
listMtime(char *file)
{
    Dir *d;
    long mtime;

    d = cdDirstat(mboxDir, file);
    if(d == nil)
        return 0;
    mtime = d->mtime;
    free(d);
    return mtime;
}
@

<<function [[lsubBoxes]]>>=
/*
 * check for subscribed mailboxes
 * each line is either a comment starting with #
 * or is a subscribed mailbox name
 */
int
lsubBoxes(char *cmd, char *ref, char *pat)
{
    MbLock *mb;
    Dir *d;
    Biobuf bin;
    char *s;
    long mtime;
    int fd, ok, isdir;

    mb = mbLock();
    if(mb == nil)
        return 0;
    fd = cdOpen(mboxDir, SUBSCRIBED, OREAD);
    if(fd < 0)
        fd = mkSubscribed();
    if(fd < 0){
        mbUnlock(mb);
        return 0;
    }
    ok = 0;
    Binit(&bin, fd, OREAD);
    while(s = Brdline(&bin, '\n')){
        s[Blinelen(&bin) - 1] = '\0';
        if(s[0] == '#')
            continue;
        isdir = 1;
        if(cistrcmp(s, "INBOX") == 0){
            if(access("msgs", AEXIST) == 0)
                mtime = listMtime("msgs");
            else
                mtime = listMtime("mbox");
            isdir = 0;
        }else{
            d = cdDirstat(mboxDir, s);
            if(d != nil){
                mtime = d->mtime;
                if(!(d->mode & DMDIR))
                    isdir = 0;
                free(d);
            }else
                mtime = 0;
        }
        ok |= checkMatch(cmd, ref, pat, s, mtime, isdir);
    }
    Bterm(&bin);
    close(fd);
    mbUnlock(mb);
    return ok;
}
@

<<function [[mkSubscribed]]>>=
static int
mkSubscribed(void)
{
    int fd;

    fd = cdCreate(mboxDir, SUBSCRIBED, ORDWR, 0664);
    if(fd < 0)
        return -1;
    fprint(fd, "#imap4 subscription list\nINBOX\n");
    seek(fd, 0, 0);
    return fd;
}
@

<<function [[subscribe]]>>=
/*
 * either subscribe or unsubscribe to a mailbox
 */
int
subscribe(char *mbox, int how)
{
    MbLock *mb;
    char *s, *in, *ein;
    int fd, tfd, ok, nmbox;

    if(cistrcmp(mbox, "inbox") == 0)
        mbox = "INBOX";
    mb = mbLock();
    if(mb == nil)
        return 0;
    fd = cdOpen(mboxDir, SUBSCRIBED, ORDWR);
    if(fd < 0)
        fd = mkSubscribed();
    if(fd < 0){
        mbUnlock(mb);
        return 0;
    }
    in = readFile(fd);
    if(in == nil){
        mbUnlock(mb);
        return 0;
    }
    nmbox = strlen(mbox);
    s = strstr(in, mbox);
    while(s != nil && (s != in && s[-1] != '\n' || s[nmbox] != '\n'))
        s = strstr(s+1, mbox);
    ok = 0;
    if(how == 's' && s == nil){
        if(fprint(fd, "%s\n", mbox) > 0)
            ok = 1;
    }else if(how == 'u' && s != nil){
        ein = strchr(s, '\0');
        memmove(s, &s[nmbox+1], ein - &s[nmbox+1]);
        ein -= nmbox+1;
        tfd = cdOpen(mboxDir, SUBSCRIBED, OWRITE|OTRUNC);
        if(tfd >= 0 && seek(fd, 0, 0) >= 0 && write(fd, in, ein-in) == ein-in)
            ok = 1;
        if(tfd > 0)
            close(tfd);
    }else
        ok = 1;
    close(fd);
    mbUnlock(mb);
    return ok;
}
@

<<function [[listBoxes]]>>=
/*
 * stupidly complicated so that % doesn't read entire directory structure
 * yet * works
 * note: in most places, inbox is case-insensitive,
 * but here INBOX is checked for a case-sensitve match.
 */
int
listBoxes(char *cmd, char *ref, char *pat)
{
    int ok;

    ok = checkMatch(cmd, ref, pat, "INBOX", listMtime("mbox"), 0);
    return ok | listMatch(cmd, ref, pat, ref, pat);
}
@

<<function [[listMatch]]>>=
/*
 * look for all messages which may match the pattern
 * punt when a * is reached
 */
static int
listMatch(char *cmd, char *ref, char *pat, char *mbox, char *mm)
{
    Dir *dir, *dirs;
    char *mdir, *m, *mb, *wc;
    long mode;
    int c, i, nmb, nmdir, nd, ok, fd;

    mdir = nil;
    for(m = mm; c = *m; m++){
        if(c == '%' || c == '*'){
            if(mdir == nil){
                fd = cdOpen(mboxDir, ".", OREAD);
                if(fd < 0)
                    return 0;
                mbox = "";
                nmdir = 0;
            }else{
                *mdir = '\0';
                fd = cdOpen(mboxDir, mbox, OREAD);
                *mdir = '/';
                nmdir = mdir - mbox + 1;
                if(fd < 0)
                    return 0;
                dir = dirfstat(fd);
                if(dir == nil){
                    close(fd);
                    return 0;
                }
                mode = dir->mode;
                free(dir);
                if(!(mode & DMDIR))
                    break;
            }
            wc = m;
            for(; c = *m; m++)
                if(c == '/')
                    break;
            nmb = nmdir + strlen(m) + MboxNameLen + 3;
            mb = emalloc(nmb);
            strncpy(mb, mbox, nmdir);
            ok = 0;
            while((nd = dirread(fd, &dirs)) > 0){
                for(i = 0; i < nd; i++){
                    if(strcmp(mbox, "") == 0 &&
                        !okMbox(dirs[i].name))
                        continue;
                    /* Safety: ignore message dirs */
                    if(strstr(dirs[i].name, "mails") != 0 ||
                       strcmp(dirs[i].name, "out") == 0 ||
                       strcmp(dirs[i].name, "obox") == 0 ||
                       strcmp(dirs[i].name, "ombox") == 0)
                        continue;
                    if(strcmp(dirs[i].name, "msgs") == 0)
                        dirs[i].mode &= ~DMDIR;
                    if(*wc == '*' && dirs[i].mode & DMDIR &&
                        mayMatch(mm, dirs[i].name, 1)){
                        snprint(mb+nmdir, nmb-nmdir,
                            "%s", dirs[i].name);
                        ok |= listAll(cmd, ref, pat, mb,
                            dirs[i].mtime);
                    }else if(mayMatch(mm, dirs[i].name, 0)){
                        snprint(mb+nmdir, nmb-nmdir,
                            "%s%s", dirs[i].name, m);
                        if(*m == '\0')
                            ok |= checkMatch(cmd,
                                ref, pat, mb,
                                dirs[i].mtime,
                                dirs[i].mode &
                                DMDIR);
                        else if(dirs[i].mode & DMDIR)
                            ok |= listMatch(cmd,
                                ref, pat, mb, mb
                                + nmdir + strlen(
                                dirs[i].name));
                    }
                }
                free(dirs);
            }
            close(fd);
            free(mb);
            return ok;
        }
        if(c == '/'){
            mdir = m;
            mm = m + 1;
        }
    }
    m = mbox;
    if(*mbox == '\0')
        m = ".";
    dir = cdDirstat(mboxDir, m);
    if(dir == nil)
        return 0;
    ok = checkMatch(cmd, ref, pat, mbox, dir->mtime, (dir->mode & DMDIR) == DMDIR);
    free(dir);
    return ok;
}
@

<<function [[listAll]]>>=
/*
 * too hard: recursively list all files rooted at mbox,
 * and list checkMatch figure it out
 */
static int
listAll(char *cmd, char *ref, char *pat, char *mbox, long mtime)
{
    Dir *dirs;
    char *mb;
    int i, nmb, nd, ok, fd;

    ok = checkMatch(cmd, ref, pat, mbox, mtime, 1);
    fd = cdOpen(mboxDir, mbox, OREAD);
    if(fd < 0)
        return ok;

    nmb = strlen(mbox) + MboxNameLen + 2;
    mb = emalloc(nmb);
    while((nd = dirread(fd, &dirs)) > 0){
        for(i = 0; i < nd; i++){
            snprint(mb, nmb, "%s/%s", mbox, dirs[i].name);
            /* safety: do not recurr */
            if(0 && dirs[i].mode & DMDIR)
                ok |= listAll(cmd, ref, pat, mb, dirs[i].mtime);
            else
                ok |= checkMatch(cmd, ref, pat, mb, dirs[i].mtime, 0);
        }
        free(dirs);
    }
    close(fd);
    free(mb);
    return ok;
}
@

<<function [[mayMatch]]>>=
static int
mayMatch(char *pat, char *name, int star)
{
    Rune r;
    int i, n;

    for(; *pat && *pat != '/'; pat += n){
        r = *(uchar*)pat;
        if(r < Runeself)
            n = 1;
        else
            n = chartorune(&r, pat);

        if(r == '*' || r == '%'){
            pat += n;
            if(r == '*' && star || *pat == '\0' || *pat == '/')
                return 1;
            while(*name){
                if(mayMatch(pat, name, star))
                    return 1;
                name += chartorune(&r, name);
            }
            return 0;
        }
        for(i = 0; i < n; i++)
            if(name[i] != pat[i])
                return 0;
        name += n;
    }
    if(*name == '\0')
        return 1;
    return 0;
}
@

<<function [[checkMatch]]>>=
/*
 * mbox is a mailbox name which might match pat.
 * verify the match
 * generates response
 */
static int
checkMatch(char *cmd, char *ref, char *pat, char *mbox, long mtime, int isdir)
{
    char *s, *flags;

    if(!matches(ref, pat, mbox) || !okMbox(mbox))
        return 0;
    if(strcmp(mbox, ".") == 0)
        mbox = "";

    if(isdir)
        flags = "(\\Noselect)";
    else{
        s = impName(mbox);
        if(s != nil && listMtime(s) < mtime)
            flags = "(\\Noinferiors \\Marked)";
        else
            flags = "(\\Noinferiors)";
    }

    s = strmutf7(mbox);
    if(s != nil)
        Bprint(&bout, "* %s %s \"/\" \"%s\"\r\n", cmd, flags, s);
    return 1;
}
@

<<function [[matches]]>>=
static int
matches(char *ref, char *pat, char *name)
{
    Rune r;
    int i, n;

    while(ref != pat)
        if(*name++ != *ref++)
            return 0;
    for(; *pat; pat += n){
        r = *(uchar*)pat;
        if(r < Runeself)
            n = 1;
        else
            n = chartorune(&r, pat);

        if(r == '*'){
            pat += n;
            if(*pat == '\0')
                return 1;
            while(*name){
                if(matches(pat, pat, name))
                    return 1;
                name += chartorune(&r, name);
            }
            return 0;
        }
        if(r == '%'){
            pat += n;
            while(*name && *name != '/'){
                if(matches(pat, pat, name))
                    return 1;
                name += chartorune(&r, name);
            }
            pat -= n;
            continue;
        }
        for(i = 0; i < n; i++)
            if(name[i] != pat[i])
                return 0;
        name += n;
    }
    if(*name == '\0')
        return 1;
    return 0;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/list.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<constant [[SUBSCRIBED]]>>

static int	matches(char *ref, char *pat, char *name);
static int	mayMatch(char *pat, char *name, int star);
static int	checkMatch(char *cmd, char *ref, char *pat, char *mbox, long mtime, int isdir);
static int	listAll(char *cmd, char *ref, char *pat, char *mbox, long mtime);
static int	listMatch(char *cmd, char *ref, char *pat, char *mbox, char *mm);
static int	mkSubscribed(void);

<<function [[listMtime]]>>

<<function [[lsubBoxes]]>>

<<function [[mkSubscribed]]>>

<<function [[subscribe]]>>

<<function [[listBoxes]]>>

<<function [[listMatch]]>>

<<function [[listAll]]>>

<<function [[mayMatch]]>>

<<function [[checkMatch]]>>

<<function [[matches]]>>
@


\subsection*{[[networking/ip/imap4d/mbox.c]]}

<<global [[flagChars]]>>=
static NamedInt	flagChars[NFlags] =
{
    {"s",	MSeen},
    {"a",	MAnswered},
    {"f",	MFlagged},
    {"D",	MDeleted},
    {"d",	MDraft},
    {"r",	MRecent},
};
@

<<global [[fsCtl]]>>=
static	int	fsCtl = -1;
@

<<function [[openBox]]>>=
/*
 * strategy:
 * every mailbox file has an associated .imp file
 * which maps upas/fs message digests to uids & message flags.
 *
 * the .imp files are locked by /mail/fs/usename/L.mbox.
 * whenever the flags can be modified, the lock file
 * should be opened, thereby locking the uid & flag state.
 * for example, whenever new uids are assigned to messages,
 * and whenever flags are changed internally, the lock file
 * should be open and locked.  this means the file must be
 * opened during store command, and when changing the \seen
 * flag for the fetch command.
 *
 * if no .imp file exists, a null one must be created before
 * assigning uids.
 *
 * the .imp file has the following format
 * imp		: "imap internal mailbox description\n"
 * 			uidvalidity " " uidnext "\n"
 *			messageLines
 *
 * messageLines	:
 *		| messageLines digest " " uid " " flags "\n"
 *
 * uid, uidnext, and uidvalidity are 32 bit decimal numbers
 * printed right justified in a field NUid characters long.
 * the 0 uid implies that no uid has been assigned to the message,
 * but the flags are valid. note that message lines are in mailbox
 * order, except possibly for 0 uid messages.
 *
 * digest is an ascii hex string NDigest characters long.
 *
 * flags has a character for each of NFlag flag fields.
 * if the flag is clear, it is represented by a "-".
 * set flags are represented as a unique single ascii character.
 * the currently assigned flags are, in order:
 *	MSeen		s
 *	MAnswered	a
 *	MFlagged	f
 *	MDeleted	D
 *	MDraft		d
 */
Box*
openBox(char *name, char *fsname, int writable)
{
    Box *box;
    MbLock *ml;
    int n, new;

    if(cistrcmp(name, "inbox") == 0)
        if(access("msgs", AEXIST) == 0)
            name = "msgs";
        else
            name = "mbox";
    fsInit();
    debuglog("imap4d open %s %s\n", name, fsname);

    if(fprint(fsCtl, "open '/mail/box/%s/%s' %s", username, name, fsname) < 0){
//ZZZ
        char err[ERRMAX];

        rerrstr(err, sizeof err);
        if(strstr(err, "file does not exist") == nil)
            fprint(2,
        "imap4d at %lud: upas/fs open %s/%s as %s failed: '%s' %s",
            time(nil), username, name, fsname, err,
            ctime(time(nil)));  /* NB: ctime result ends with \n */
        fprint(fsCtl, "close %s", fsname);
        return nil;
    }

    /*
     * read box to find all messages
     * each one has a directory, and is in numerical order
     */
    box = MKZ(Box);
    box->writable = writable;

    n = strlen(name) + 1;
    box->name = emalloc(n);
    strcpy(box->name, name);

    n += STRLEN(".imp");
    box->imp = emalloc(n);
    snprint(box->imp, n, "%s.imp", name);

    n = strlen(fsname) + 1;
    box->fs = emalloc(n);
    strcpy(box->fs, fsname);

    n = STRLEN("/mail/fs/") + strlen(fsname) + 1;
    box->fsDir = emalloc(n);
    snprint(box->fsDir, n, "/mail/fs/%s", fsname);

    box->uidnext = 1;
    new = readBox(box);
    if(new >= 0){
        ml = openImp(box, new);
        if(ml != nil){
            closeImp(box, ml);
            return box;
        }
    }
    closeBox(box, 0);
    return nil;
}
@

<<function [[checkBox]]>>=
/*
 * check mailbox
 * returns fd of open .imp file if imped.
 * otherwise, return value is insignificant
 *
 * careful: called by idle polling proc
 */
MbLock*
checkBox(Box *box, int imped)
{
    MbLock *ml;
    Dir *d;
    int new;

    if(box == nil)
        return nil;

    /*
     * if stat fails, mailbox must be gone
     */
    d = cdDirstat(box->fsDir, ".");
    if(d == nil){
        mboxGone(box);
        return nil;
    }
    new = 0;
    if(box->qid.path != d->qid.path || box->qid.vers != d->qid.vers
    || box->mtime != d->mtime){
        new = readBox(box);
        if(new < 0){
            free(d);
            return nil;
        }
    }
    free(d);
    ml = openImp(box, new);
    if(ml == nil)
        box->writable = 0;
    else if(!imped){
        closeImp(box, ml);
        ml = nil;
    }
    return ml;
}
@

<<function [[mboxGone]]>>=
/*
 * mailbox is unreachable, so mark all messages expunged
 * clean up .imp files as well.
 */
static void
mboxGone(Box *box)
{
    Msg *m;

    if(cdExists(mboxDir, box->name) < 0)
        cdRemove(mboxDir, box->imp);
    for(m = box->msgs; m != nil; m = m->next)
        m->expunged = 1;
    box->writable = 0;
}
@

<<function [[readBox]]>>=
/*
 * read messages in the mailbox
 * mark message that no longer exist as expunged
 * returns -1 for failure, 0 if no new messages, 1 if new messages.
 */
static int
readBox(Box *box)
{
    Msg *msgs, *m, *last;
    Dir *d;
    char *s;
    long max, id;
    int i, nd, fd, new;

    fd = cdOpen(box->fsDir, ".", OREAD);
    if(fd < 0){
        syslog(0, "mail",
            "imap4d at %lud: upas/fs stat of %s/%s aka %s failed: %r",
            time(nil), username, box->name, box->fsDir);
        mboxGone(box);
        return -1;
    }

    /*
     * read box to find all messages
     * each one has a directory, and is in numerical order
     */
    d = dirfstat(fd);
    if(d == nil){
        close(fd);
        return -1;
    }
    box->mtime = d->mtime;
    box->qid = d->qid;
    last = nil;
    msgs = box->msgs;
    max = 0;
    new = 0;
    free(d);
    while((nd = dirread(fd, &d)) > 0){
        for(i = 0; i < nd; i++){
            s = d[i].name;
            id = strtol(s, &s, 10);
            if(id <= max || *s != '\0'
            || (d[i].mode & DMDIR) != DMDIR)
                continue;

            max = id;

            while(msgs != nil){
                last = msgs;
                msgs = msgs->next;
                if(last->id == id)
                    goto continueDir;
                last->expunged = 1;
            }

            new = 1;
            m = MKZ(Msg);
            m->id = id;
            m->fsDir = box->fsDir;
            m->fs = emalloc(2 * (MsgNameLen + 1));
            m->efs = seprint(m->fs, m->fs + (MsgNameLen + 1), "%lud/", id);
            m->size = ~0UL;
            m->lines = ~0UL;
            m->prev = last;
            m->flags = MRecent;
            if(!msgInfo(m))
                freeMsg(m);
            else{
                if(last == nil)
                    box->msgs = m;
                else
                    last->next = m;
                last = m;
            }
    continueDir:;
        }
        free(d);
    }
    close(fd);
    for(; msgs != nil; msgs = msgs->next)
        msgs->expunged = 1;

    /*
     * make up the imap message sequence numbers
     */
    id = 1;
    for(m = box->msgs; m != nil; m = m->next){
        if(m->seq && m->seq != id)
            bye("internal error assigning message numbers");
        m->seq = id++;
    }
    box->max = id - 1;

    return new;
}
@

<<constant [[IMPMAGIC]]>>=
/*
 * read in the .imp file, or make one if it doesn't exist.
 * make sure all flags and uids are consistent.
 * return the mailbox lock.
 */
#define IMPMAGIC	"imap internal mailbox description\n"
@

<<function [[openImp]]>>=
static MbLock*
openImp(Box *box, int new)
{
    Qid qid;
    Biobuf b;
    MbLock *ml;
    int fd;
//ZZZZ
    int once;

    ml = mbLock();
    if(ml == nil)
        return nil;
    fd = cdOpen(mboxDir, box->imp, OREAD);
    once = 0;
ZZZhack:
    if(fd < 0 || fqid(fd, &qid) < 0){
        if(fd < 0){
            char buf[ERRMAX];

            errstr(buf, sizeof buf);
            if(cistrstr(buf, "does not exist") == nil)
                fprint(2, "imap4d at %lud: imp open failed: %s\n", time(nil), buf);
            if(!once && cistrstr(buf, "locked") != nil){
                once = 1;
                fprint(2, "imap4d at %lud: imp %s/%s %s locked when it shouldn't be; spinning\n", time(nil), username, box->name, box->imp);
                fd = openLocked(mboxDir, box->imp, OREAD);
                goto ZZZhack;
            }
        }
        if(fd >= 0)
            close(fd);
        fd = createImp(box, &qid);
        if(fd < 0){
            mbUnlock(ml);
            return nil;
        }
        box->dirtyImp = 1;
        if(box->uidvalidity == 0)
            box->uidvalidity = box->mtime;
        box->impQid = qid;
        new = 1;
    }else if(qid.path != box->impQid.path || qid.vers != box->impQid.vers){
        Binit(&b, fd, OREAD);
        if(!parseImp(&b, box)){
            box->dirtyImp = 1;
            if(box->uidvalidity == 0)
                box->uidvalidity = box->mtime;
        }
        Bterm(&b);
        box->impQid = qid;
        new = 1;
    }
    if(new)
        boxFlags(box);
    close(fd);
    return ml;
}
@

<<function [[closeImp]]>>=
/*
 * close the .imp file, after writing out any changes
 */
void
closeImp(Box *box, MbLock *ml)
{
    Msg *m;
    Qid qid;
    Biobuf b;
    char buf[NFlags+1];
    int fd;

    if(ml == nil)
        return;
    if(!box->dirtyImp){
        mbUnlock(ml);
        return;
    }

    fd = cdCreate(mboxDir, box->imp, OWRITE, 0664);
    if(fd < 0){
        mbUnlock(ml);
        return;
    }
    Binit(&b, fd, OWRITE);

    box->dirtyImp = 0;
    Bprint(&b, "%s", IMPMAGIC);
    Bprint(&b, "%.*lud %.*lud\n", NUid, box->uidvalidity, NUid, box->uidnext);
    for(m = box->msgs; m != nil; m = m->next){
        if(m->expunged)
            continue;
        wrImpFlags(buf, m->flags, strcmp(box->fs, "imap") == 0);
        Bprint(&b, "%.*s %.*lud %s\n", NDigest, m->info[IDigest], NUid, m->uid, buf);
    }
    Bterm(&b);

    if(fqid(fd, &qid) >= 0)
        box->impQid = qid;
    close(fd);
    mbUnlock(ml);
}
@

<<function [[wrImpFlags]]>>=
void
wrImpFlags(char *buf, int flags, int killRecent)
{
    int i;

    for(i = 0; i < NFlags; i++){
        if((flags & flagChars[i].v)
        && (flagChars[i].v != MRecent || !killRecent))
            buf[i] = flagChars[i].name[0];
        else
            buf[i] = '-';
    }
    buf[i] = '\0';
}
@

<<function [[emptyImp]]>>=
int
emptyImp(char *mbox)
{
    Dir *d;
    long mode;
    int fd;

    fd = cdCreate(mboxDir, impName(mbox), OWRITE, 0664);
    if(fd < 0)
        return -1;
    d = cdDirstat(mboxDir, mbox);
    if(d == nil){
        close(fd);
        return -1;
    }
    fprint(fd, "%s%.*lud %.*lud\n", IMPMAGIC, NUid, d->mtime, NUid, 1UL);
    mode = d->mode & 0777;
    nulldir(d);
    d->mode = mode;
    dirfwstat(fd, d);
    free(d);
    return fd;
}
@

<<function [[createImp]]>>=
/*
 * try to match permissions with mbox
 */
static int
createImp(Box *box, Qid *qid)
{
    Dir *d;
    long mode;
    int fd;

    fd = cdCreate(mboxDir, box->imp, OREAD, 0664);
    if(fd < 0)
        return -1;
    d = cdDirstat(mboxDir, box->name);
    if(d != nil){
        mode = d->mode & 0777;
        nulldir(d);
        d->mode = mode;
        dirfwstat(fd, d);
        free(d);
    }
    if(fqid(fd, qid) < 0){
        close(fd);
        return -1;
    }

    return fd;
}
@

<<function [[parseImp]]>>=
/*
 * read or re-read a .imp file.
 * this is tricky:
 *	messages can be deleted by another agent
 *	we might still have a Msg for an expunged message,
 *		because we haven't told the client yet.
 *	we can have a Msg without a .imp entry.
 *	flag information is added at the end of the .imp by copy & append
 *	there can be duplicate messages (same digests).
 *
 * look up existing messages based on uid.
 * look up new messages based on in order digest matching.
 *
 * note: in the face of duplicate messages, one of which is deleted,
 * two active servers may decide different ones are valid, and so return
 * different uids for the messages.  this situation will stablize when the servers exit.
 */
static int
parseImp(Biobuf *b, Box *box)
{
    Msg *m, *mm;
    char *s, *t, *toks[3];
    ulong uid, u;
    int match, n;

    m = box->msgs;
    s = Brdline(b, '\n');
    if(s == nil || Blinelen(b) != STRLEN(IMPMAGIC)
    || strncmp(s, IMPMAGIC, STRLEN(IMPMAGIC)) != 0)
        return 0;

    s = Brdline(b, '\n');
    if(s == nil || Blinelen(b) != 2*NUid + 2)
        return 0;
    s[2*NUid + 1] = '\0';
    u = strtoul(s, &t, 10);
    if(u != box->uidvalidity && box->uidvalidity != 0)
        return 0;
    box->uidvalidity = u;
    if(*t != ' ' || t != s + NUid)
        return 0;
    t++;
    u = strtoul(t, &t, 10);
    if(box->uidnext > u)
        return 0;
    box->uidnext = u;
    if(t != s + 2*NUid+1 || box->uidnext == 0)
        return 0;

    uid = ~0;
    while(m != nil){
        s = Brdline(b, '\n');
        if(s == nil)
            break;
        n = Blinelen(b) - 1;
        if(n != NDigest + NUid + NFlags + 2
        || s[NDigest] != ' ' || s[NDigest + NUid + 1] != ' ')
            return 0;
        toks[0] = s;
        s[NDigest] = '\0';
        toks[1] = s + NDigest + 1;
        s[NDigest + NUid + 1] = '\0';
        toks[2] = s + NDigest + NUid + 2;
        s[n] = '\0';
        t = toks[1];
        u = strtoul(t, &t, 10);
        if(*t != '\0' || uid != ~0 && (uid >= u && u || u && !uid))
            return 0;
        uid = u;

        /*
         * zero uid => added by append or copy, only flags valid
         * can only match messages without uids, but this message
         * may not be the next one, and may have been deleted.
         */
        if(!uid){
            for(; m != nil && m->uid; m = m->next)
                ;
            for(mm = m; mm != nil; mm = mm->next){
                if(mm->info[IDigest] != nil &&
                    strcmp(mm->info[IDigest], toks[0]) == 0){
                    if(!mm->uid)
                        mm->flags = 0;
                    if(!impFlags(box, mm, toks[2]))
                        return 0;
                    m = mm->next;
                    break;
                }
            }
            continue;
        }

        /*
         * ignore expunged messages,
         * and messages already assigned uids which don't match this uid.
         * such messages must have been deleted by another imap server,
         * which updated the mailbox and .imp file since we read the mailbox,
         * or because upas/fs got confused by consecutive duplicate messages,
         * the first of which was deleted by another imap server.
         */
        for(; m != nil && (m->expunged || m->uid && m->uid < uid); m = m->next)
            ;
        if(m == nil)
            break;

        /*
         * only check for digest match on the next message,
         * since it comes before all other messages, and therefore
         * must be in the .imp file if they should be.
         */
        match = m->info[IDigest] != nil &&
            strcmp(m->info[IDigest], toks[0]) == 0;
        if(uid && (m->uid == uid || !m->uid && match)){
            if(!match)
                bye("inconsistent uid");

            /*
             * wipe out recent flag if some other server saw this new message.
             * it will be read from the .imp file if is really should be set,
             * ie the message was only seen by a status command.
             */
            if(!m->uid)
                m->flags = 0;

            if(!impFlags(box, m, toks[2]))
                return 0;
            m->uid = uid;
            m = m->next;
        }
    }
    return 1;
}
@

<<function [[impFlags]]>>=
/*
 * parse .imp flags
 */
static int
impFlags(Box *box, Msg *m, char *flags)
{
    int i, f;

    f = 0;
    for(i = 0; i < NFlags; i++){
        if(flags[i] == '-')
            continue;
        if(flags[i] != flagChars[i].name[0])
            return 0;
        f |= flagChars[i].v;
    }

    /*
     * recent flags are set until the first time message's box is selected or examined.
     * it may be stored in the file as a side effect of a status or subscribe command;
     * if so, clear it out.
     */
    if((f & MRecent) && strcmp(box->fs, "imap") == 0)
        box->dirtyImp = 1;
    f |= m->flags & MRecent;

    /*
     * all old messages with changed flags should be reported to the client
     */
    if(m->uid && m->flags != f){
        box->sendFlags = 1;
        m->sendFlags = 1;
    }
    m->flags = f;
    return 1;
}
@

<<function [[boxFlags]]>>=
/*
 * assign uids to any new messages
 * which aren't already in the .imp file.
 * sum up totals for flag values.
 */
static void
boxFlags(Box *box)
{
    Msg *m;

    box->recent = 0;
    for(m = box->msgs; m != nil; m = m->next){
        if(m->uid == 0){
            box->dirtyImp = 1;
            box->uidnext = uidRenumber(m, box->uidnext, 0);
        }
        if(m->flags & MRecent)
            box->recent++;
    }
}
@

<<function [[uidRenumber]]>>=
static ulong
uidRenumber(Msg *m, ulong uid, int force)
{
    for(; m != nil; m = m->next){
        if(!force && m->uid != 0)
            bye("uid renumbering with a valid uid");
        m->uid = uid++;
    }
    return uid;
}
@

<<function [[closeBox]]>>=
void
closeBox(Box *box, int opened)
{
    Msg *m, *next;

    /*
     * make sure to leave the mailbox directory so upas/fs can close the mailbox
     */
    myChdir(mboxDir);

    if(box->writable){
        deleteMsgs(box);
        if(expungeMsgs(box, 0))
            closeImp(box, checkBox(box, 1));
    }

    if(fprint(fsCtl, "close %s", box->fs) < 0 && opened)
        bye("can't talk to mail server");
    for(m = box->msgs; m != nil; m = next){
        next = m->next;
        freeMsg(m);
    }
    free(box->name);
    free(box->fs);
    free(box->fsDir);
    free(box->imp);
    free(box);
}
@

<<function [[deleteMsgs]]>>=
int
deleteMsgs(Box *box)
{
    Msg *m;
    char buf[BufSize], *p, *start;
    int ok;

    if(!box->writable)
        return 0;

    /*
     * first pass: delete messages; gang the writes together for speed.
     */
    ok = 1;
    start = seprint(buf, buf + sizeof(buf), "delete %s", box->fs);
    p = start;
    for(m = box->msgs; m != nil; m = m->next){
        if((m->flags & MDeleted) && !m->expunged){
            m->expunged = 1;
            p = seprint(p, buf + sizeof(buf), " %lud", m->id);
            if(p + 32 >= buf + sizeof(buf)){
                if(write(fsCtl, buf, p - buf) < 0)
                    bye("can't talk to mail server");
                p = start;
            }
        }
    }
    if(p != start && write(fsCtl, buf, p - buf) < 0)
        bye("can't talk to mail server");

    return ok;
}
@

<<function [[expungeMsgs]]>>=
/*
 * second pass: remove the message structure,
 * and renumber message sequence numbers.
 * update messages counts in mailbox.
 * returns true if anything changed.
 */
int
expungeMsgs(Box *box, int send)
{
    Msg *m, *next, *last;
    ulong n;

    n = 0;
    last = nil;
    for(m = box->msgs; m != nil; m = next){
        m->seq -= n;
        next = m->next;
        if(m->expunged){
            if(send)
                Bprint(&bout, "* %lud expunge\r\n", m->seq);
            if(m->flags & MRecent)
                box->recent--;
            n++;
            if(last == nil)
                box->msgs = next;
            else
                last->next = next;
            freeMsg(m);
        }else
            last = m;
    }
    if(n){
        box->max -= n;
        box->dirtyImp = 1;
    }
    return n;
}
@

<<function [[fsInit]]>>=
static void
fsInit(void)
{
    if(fsCtl >= 0)
        return;
    fsCtl = open("/mail/fs/ctl", ORDWR);
    if(fsCtl < 0)
        bye("can't open mail file system");
    if(fprint(fsCtl, "close mbox") < 0)
        bye("can't initialize mail file system");
}
@

<<global [[stoplist]]>>=
static char *stoplist[] =
{
    "mbox",
    "pipeto",
    "forward",
    "names",
    "pipefrom",
    "headers",
    "imap.ok",
    0
};
@

<<enum [[_anon_ (networking/ip/imap4d/mbox.c)]]>>=
enum {
    Maxokbytes	= 4096,
    Maxfolders	= Maxokbytes / 4,
};
@

<<global [[folders]]>>=
static char *folders[Maxfolders];
@

<<global [[folderbuff]]>>=
static char *folderbuff;
@

<<function [[readokfolders]]>>=
static void
readokfolders(void)
{
    int fd, nr;

    fd = open("imap.ok", OREAD);
    if(fd < 0)
        return;
    folderbuff = malloc(Maxokbytes);
    if(folderbuff == nil) {
        close(fd);
        return;
    }
    nr = read(fd, folderbuff, Maxokbytes-1);	/* once is ok */
    close(fd);
    if(nr < 0){
        free(folderbuff);
        folderbuff = nil;
        return;
    }
    folderbuff[nr] = 0;
    tokenize(folderbuff, folders, nelem(folders));
}
@

<<function [[okMbox]]>>=
/*
 * reject bad mailboxes based on mailbox name
 */
int
okMbox(char *path)
{
    char *name;
    int i;

    if(folderbuff == nil && access("imap.ok", AREAD) == 0)
        readokfolders();
    name = strrchr(path, '/');
    if(name == nil)
        name = path;
    else
        name++;
    if(folderbuff != nil){
        for(i = 0; i < nelem(folders) && folders[i] != nil; i++)
            if(cistrcmp(folders[i], name) == 0)
                return 1;
        return 0;
    }
    if(strlen(name) + STRLEN(".imp") >= MboxNameLen)
        return 0;
    for(i = 0; stoplist[i]; i++)
        if(strcmp(name, stoplist[i]) == 0)
            return 0;
    if(isprefix("L.", name) || isprefix("imap-tmp.", name)
    || issuffix(".imp", name)
    || strcmp("imap.subscribed", name) == 0
    || isdotdot(name) || name[0] == '/')
        return 0;
    return 1;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/mbox.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<global [[flagChars]]>>

<<global [[fsCtl]]>>

static	void	boxFlags(Box *box);
static	int	createImp(Box *box, Qid *qid);
static	void	fsInit(void);
static	void	mboxGone(Box *box);
static	MbLock	*openImp(Box *box, int new);
static	int	parseImp(Biobuf *b, Box *box);
static	int	readBox(Box *box);
static	ulong	uidRenumber(Msg *m, ulong uid, int force);
static	int	impFlags(Box *box, Msg *m, char *flags);

<<function [[openBox]]>>

<<function [[checkBox]]>>

<<function [[mboxGone]]>>

<<function [[readBox]]>>

<<constant [[IMPMAGIC]]>>
<<function [[openImp]]>>

<<function [[closeImp]]>>

<<function [[wrImpFlags]]>>

<<function [[emptyImp]]>>

<<function [[createImp]]>>

<<function [[parseImp]]>>

<<function [[impFlags]]>>

<<function [[boxFlags]]>>

<<function [[uidRenumber]]>>

<<function [[closeBox]]>>

<<function [[deleteMsgs]]>>

<<function [[expungeMsgs]]>>

<<function [[fsInit]]>>

<<global [[stoplist]]>>

<<enum [[_anon_ (networking/ip/imap4d/mbox.c)]]>>

<<global [[folders]]>>
<<global [[folderbuff]]>>

<<function [[readokfolders]]>>

<<function [[okMbox]]>>
@


\subsection*{[[networking/ip/imap4d/msg.c]]}

<<global [[bogusBody]]>>=
static char bogusBody[] = 
    "This message contains null characters, so it cannot be displayed correctly.\r\n"
    "Most likely you were sent a bogus message or a binary file.\r\n"
    "\r\n"
    "Each of the following attachments has a different version of the message.\r\n"
    "The first is inlined with all non-printable characters stripped.\r\n"
    "The second contains the message as it was stored in your mailbox.\r\n"
    "The third has the initial header stripped.\r\n";
@

<<global [[bogusMimeText]]>>=
static char bogusMimeText[] =
    "Content-Disposition: inline\r\n"
    "Content-Type: text/plain; charset=\"US-ASCII\"\r\n"
    "Content-Transfer-Encoding: 7bit\r\n";
@

<<global [[bogusMimeBinary]]>>=
static char bogusMimeBinary[] =
    "Content-Disposition: attachment\r\n"
    "Content-Type: application/octet-stream\r\n"
    "Content-Transfer-Encoding: base64\r\n";
@

<<global [[headFieldStop]]>>=
/*
 * stop list for header fields
 */
static char	*headFieldStop = ":";
@

<<global [[mimeTokenStop]]>>=
static char	*mimeTokenStop = "()<>@,;:\\\"/[]?=";
@

<<global [[headAtomStop]]>>=
static char	*headAtomStop = "()<>@,;:\\\".[]";
@

<<global [[headStr]]>>=
static uchar	*headStr;
@

<<global [[lastWhite]]>>=
static uchar	*lastWhite;
@

<<function [[selectFields]]>>=
long
selectFields(char *dst, long n, char *hdr, SList *fields, int matches)
{
    SList *f;
    uchar *start;
    char *s;
    long m, nf;

    headStr = (uchar*)hdr;
    m = 0;
    for(;;){
        start = headStr;
        s = headAtom(headFieldStop);
        if(s == nil)
            break;
        headSkip();
        for(f = fields; f != nil; f = f->next){
            if(cistrcmp(s, f->s) == !matches){
                nf = headStr - start;
                if(m + nf > n)
                    return 0;
                memmove(&dst[m], start, nf);
                m += nf;
            }
        }
        free(s);
    }
    if(m + 3 > n)
        return 0;
    dst[m++] = '\r';
    dst[m++] = '\n';
    dst[m] = '\0';
    return m;
}
@

<<function [[freeMsg]]>>=
void
freeMsg(Msg *m)
{
    Msg *k, *last;

    free(m->iBuf);
    freeMAddr(m->to);
    if(m->replyTo != m->from)
        freeMAddr(m->replyTo);
    if(m->sender != m->from)
        freeMAddr(m->sender);
    if(m->from != m->unixFrom)
        freeMAddr(m->from);
    freeMAddr(m->unixFrom);
    freeMAddr(m->cc);
    freeMAddr(m->bcc);
    free(m->unixDate);
    cleanupHeader(&m->head);
    cleanupHeader(&m->mime);
    for(k = m->kids; k != nil; ){
        last = k;
        k = k->next;
        freeMsg(last);
    }
    free(m->fs);
    free(m);
}
@

<<function [[msgSize]]>>=
ulong
msgSize(Msg *m)
{
    return m->head.size + m->size;
}
@

<<function [[infoIsNil]]>>=
int
infoIsNil(char *s)
{
    return s == nil || s[0] == '\0';
}
@

<<function [[maddrStr]]>>=
char*
maddrStr(MAddr *a)
{
    char *host, *addr;
    int n;

    host = a->host;
    if(host == nil)
        host = "";
    n = strlen(a->box) + strlen(host) + 2;
    if(a->personal != nil)
        n += strlen(a->personal) + 3;
    addr = emalloc(n);
    if(a->personal != nil)
        snprint(addr, n, "%s <%s@%s>", a->personal, a->box, host);
    else
        snprint(addr, n, "%s@%s", a->box, host);
    return addr;
}
@

<<function [[msgFile]]>>=
/*
 * return actual name of f in m's fs directory
 * this is special cased when opening m/rawbody, m/mimeheader, or m/rawheader,
 * if the message was corrupted.  in that case,
 * a temporary file is made to hold the base64 encoding of m/raw.
 */
int
msgFile(Msg *m, char *f)
{
    Msg *parent, *p;
    Dir d;
    Tm tm;
    char buf[64], nbuf[2];
    uchar dbuf[64];
    int i, n, fd, fd1, fd2;

    if(!m->bogus
    || strcmp(f, "") != 0 && strcmp(f, "rawbody") != 0
    && strcmp(f, "rawheader") != 0 && strcmp(f, "mimeheader") != 0
    && strcmp(f, "info") != 0 && strcmp(f, "unixheader") != 0){
        if(strlen(f) > MsgNameLen)
            bye("internal error: msgFile name too long");
        strcpy(m->efs, f);
        return cdOpen(m->fsDir, m->fs, OREAD);
    }

    /*
     * walk up the stupid runt message parts for non-multipart messages
     */
    parent = m->parent;
    if(parent != nil && parent->parent != nil){
        m = parent;
        parent = m->parent;
    }
    p = m;
    if(parent != nil)
        p = parent;

    if(strcmp(f, "info") == 0 || strcmp(f, "unixheader") == 0){
        strcpy(p->efs, f);
        return cdOpen(p->fsDir, p->fs, OREAD);
    }

    fd = imapTmp();
    if(fd < 0)
        return -1;

    /*
     * craft the message parts for bogus messages
     */
    if(strcmp(f, "") == 0){
        /*
         * make a fake directory for each kid
         * all we care about is the name
         */
        if(parent == nil){
            nulldir(&d);
            d.mode = DMDIR|0600;
            d.qid.type = QTDIR;
            d.name = nbuf;
            nbuf[1] = '\0';
            for(i = '1'; i <= '4'; i++){
                nbuf[0] = i;
                n = convD2M(&d, dbuf, sizeof(dbuf));
                if(n <= BIT16SZ)
                    fprint(2, "bad convD2M %d\n", n);
                write(fd, dbuf, n);
            }
        }
    }else if(strcmp(f, "mimeheader") == 0){
        if(parent != nil){
            switch(m->id){
            case 1:
            case 2:
                fprint(fd, "%s", bogusMimeText);
                break;
            case 3:
            case 4:
                fprint(fd, "%s", bogusMimeBinary);
                break;
            }
        }
    }else if(strcmp(f, "rawheader") == 0){
        if(parent == nil){
            date2tm(&tm, m->unixDate);
            rfc822date(buf, sizeof(buf), &tm);
            fprint(fd,
                "Date: %s\r\n"
                "From: imap4 daemon <%s@%s>\r\n"
                "To: <%s@%s>\r\n"
                "Subject: This message was illegal or corrupted\r\n"
                "MIME-Version: 1.0\r\n"
                "Content-Type: multipart/mixed;\r\n\tboundary=\"upas-%s\"\r\n",
                    buf, username, site, username, site, m->info[IDigest]);
        }
    }else if(strcmp(f, "rawbody") == 0){
        fd1 = msgFile(p, "raw");
        strcpy(p->efs, "rawbody");
        fd2 = cdOpen(p->fsDir, p->fs, OREAD);
        if(fd1 < 0 || fd2 < 0){
            close(fd);
            close(fd1);
            close(fd2);
            return -1;
        }
        if(parent == nil){
            fprint(fd,
                "This is a multi-part message in MIME format.\r\n"
                "--upas-%s\r\n"
                "%s"
                "\r\n"
                "%s"
                "\r\n",
                    m->info[IDigest], bogusMimeText, bogusBody);

            fprint(fd,
                "--upas-%s\r\n"
                "%s"
                "\r\n",
                    m->info[IDigest], bogusMimeText);
            bodystrip(fd1, fd);

            fprint(fd,
                "--upas-%s\r\n"
                "%s"
                "\r\n",
                    m->info[IDigest], bogusMimeBinary);
            seek(fd1, 0, 0);
            body64(fd1, fd);

            fprint(fd,
                "--upas-%s\r\n"
                "%s"
                "\r\n",
                    m->info[IDigest], bogusMimeBinary);
            body64(fd2, fd);

            fprint(fd, "--upas-%s--\r\n", m->info[IDigest]);
        }else{
            switch(m->id){
            case 1:
                fprint(fd, "%s", bogusBody);
                break;
            case 2:
                bodystrip(fd1, fd);
                break;
            case 3:
                body64(fd1, fd);
                break;
            case 4:
                body64(fd2, fd);
                break;
            }
        }
        close(fd1);
        close(fd2);
    }
    seek(fd, 0, 0);
    return fd;
}
@

<<function [[msgIsMulti]]>>=
int
msgIsMulti(Header *h)
{
    return h->type != nil && cistrcmp("multipart", h->type->s) == 0;
}
@

<<function [[msgIsRfc822]]>>=
int
msgIsRfc822(Header *h)
{
    return h->type != nil && cistrcmp("message", h->type->s) == 0 && cistrcmp("rfc822", h->type->t) == 0;
}
@

<<function [[msgDead]]>>=
/*
 * check if a message has been deleted by someone else
 */
void
msgDead(Msg *m)
{
    if(m->expunged)
        return;
    *m->efs = '\0';
    if(!cdExists(m->fsDir, m->fs))
        m->expunged = 1;
}
@

<<function [[msgInfo]]>>=
/*
 * make sure the message has valid associated info
 * used for ISubject, IDigest, IInReplyTo, IMessageId.
 */
int
msgInfo(Msg *m)
{
    char *s;
    int i;

    if(m->info[0] != nil)
        return 1;

    i = msgReadFile(m, "info", &m->iBuf);
    if(i < 0)
        return 0;

    s = m->iBuf;
    for(i = 0; i < IMax; i++){
        m->info[i] = s;
        s = strchr(s, '\n');
        if(s == nil)
            break;
        *s++ = '\0';
    }
    for(; i < IMax; i++)
        m->info[i] = nil;

    for(i = 0; i < IMax; i++)
        if(infoIsNil(m->info[i]))
            m->info[i] = nil;

    return 1;
}
@

<<function [[msgStruct]]>>=
/*
 * make sure the message has valid mime structure
 * and sub-messages
 */
int
msgStruct(Msg *m, int top)
{
    Msg *k, head, *last;
    Dir *d;
    char *s;
    ulong max, id;
    int i, nd, fd, ns;

    if(m->kids != nil)
        return 1;

    if(m->expunged
    || !msgInfo(m)
    || !msgUnix(m, top)
    || !msgBodySize(m)
    || !msgHeader(m, &m->mime, "mimeheader")
    || (top || msgIsRfc822(&m->mime) || msgIsMulti(&m->mime)) && !msgHeader(m, &m->head, "rawheader")){
        if(top && m->bogus && !(m->bogus & BogusTried)){
            m->bogus |= BogusTried;
            return msgStruct(m, top);
        }
        msgDead(m);
        return 0;
    }

    /*
     * if a message has no kids, it has a kid which is just the body of the real message
     */
    if(!msgIsMulti(&m->head) && !msgIsMulti(&m->mime) && !msgIsRfc822(&m->head) && !msgIsRfc822(&m->mime)){
        k = MKZ(Msg);
        k->id = 1;
        k->fsDir = m->fsDir;
        k->bogus = m->bogus;
        k->parent = m->parent;
        ns = m->efs - m->fs;
        k->fs = emalloc(ns + (MsgNameLen + 1));
        memmove(k->fs, m->fs, ns);
        k->efs = k->fs + ns;
        *k->efs = '\0';
        k->size = m->size;
        m->kids = k;
        return 1;
    }

    /*
     * read in all child messages messages
     */
    fd = msgFile(m, "");
    if(fd < 0){
        msgDead(m);
        return 0;
    }

    max = 0;
    head.next = nil;
    last = &head;
    while((nd = dirread(fd, &d)) > 0){
        for(i = 0; i < nd; i++){
            s = d[i].name;
            id = strtol(s, &s, 10);
            if(id <= max || *s != '\0'
            || (d[i].mode & DMDIR) != DMDIR)
                continue;

            max = id;

            k = MKZ(Msg);
            k->id = id;
            k->fsDir = m->fsDir;
            k->bogus = m->bogus;
            k->parent = m;
            ns = strlen(m->fs);
            k->fs = emalloc(ns + 2 * (MsgNameLen + 1));
            k->efs = seprint(k->fs, k->fs + ns + (MsgNameLen + 1), "%s%lud/", m->fs, id);
            k->prev = last;
            k->size = ~0UL;
            k->lines = ~0UL;
            last->next = k;
            last = k;
        }
    }
    close(fd);
    m->kids = head.next;

    /*
     * if kids fail, just whack them
     */
    top = top && (msgIsRfc822(&m->head) || msgIsMulti(&m->head));
    for(k = m->kids; k != nil; k = k->next){
        if(!msgStruct(k, top)){
            for(k = m->kids; k != nil; ){
                last = k;
                k = k->next;
                freeMsg(last);
            }
            m->kids = nil;
            break;
        }
    }
    return 1;
}
@

<<function [[msgReadFile]]>>=
static long
msgReadFile(Msg *m, char *file, char **ss)
{
    Dir *d;
    char *s, buf[BufSize];
    vlong length;
    long n, nn;
    int fd;

    fd = msgFile(m, file);
    if(fd < 0){
        msgDead(m);
        return -1;
    }

    n = read(fd, buf, BufSize);
    if(n < BufSize){
        close(fd);
        if(n < 0){
            *ss = nil;
            return -1;
        }
        s = emalloc(n + 1);
        memmove(s, buf, n);
        s[n] = '\0';
        *ss = s;
        return n;
    }

    d = dirfstat(fd);
    if(d == nil){
        close(fd);
        return -1;
    }
    length = d->length;
    free(d);
    nn = length;
    s = emalloc(nn + 1);
    memmove(s, buf, n);
    if(nn > n)
        nn = readn(fd, s+n, nn-n) + n;
    close(fd);
    if(nn != length){
        free(s);
        return -1;
    }
    s[nn] = '\0';
    *ss = s;
    return nn;
}
@

<<function [[freeMAddr]]>>=
static void
freeMAddr(MAddr *a)
{
    MAddr *p;

    while(a != nil){
        p = a;
        a = a->next;
        free(p->personal);
        free(p->box);
        free(p->host);
        free(p);
    }
}
@

<<function [[msgBogus]]>>=
/*
 * the message is corrupted or illegal.
 * reset message fields.  msgStruct will reparse the message,
 * relying on msgFile to make up corrected body parts.
 */
static int
msgBogus(Msg *m, int flags)
{
    if(!(m->bogus & flags))
        m->bogus |= flags;
    m->lines = ~0;
    free(m->head.buf);
    free(m->mime.buf);
    memset(&m->head, 0, sizeof(Header));
    memset(&m->mime, 0, sizeof(Header));
    return 0;
}
@

<<function [[enc64x18]]>>=
/*
 *  stolen from upas/marshal; base64 encodes from one fd to another.
 *
 *  the size of buf is very important to enc64.  Anything other than
 *  a multiple of 3 will cause enc64 to output a termination sequence.
 *  To ensure that a full buf corresponds to a multiple of complete lines,
 *  we make buf a multiple of 3*18 since that's how many enc64 sticks on
 *  a single line.  This avoids short lines in the output which is pleasing
 *  but not necessary.
 */
static int
enc64x18(char *out, int lim, uchar *in, int n)
{
    int m, mm, nn;

    nn = 0;
    for(; n > 0; n -= m){
        m = 18 * 3;
        if(m > n)
            m = n;
        mm = enc64(out, lim - nn, in, m);
        in += m;
        out += mm;
        *out++ = '\r';
        *out++ = '\n';
        nn += mm + 2;
    }
    return nn;
}
@

<<function [[body64]]>>=
static void
body64(int in, int out)
{
    uchar buf[3*18*54];
    char obuf[3*18*54*2];
    int m, n;

    for(;;){
        n = read(in, buf, sizeof(buf));
        if(n < 0)
            return;
        if(n == 0)
            break;
        m = enc64x18(obuf, sizeof(obuf), buf, n);
        if(write(out, obuf, m) < 0)
            return;
    }
}
@

<<function [[bodystrip]]>>=
/*
 * strip all non-printable characters from a file
 */
static void
bodystrip(int in, int out)
{
    uchar buf[3*18*54];
    int m, n, i, c;

    for(;;){
        n = read(in, buf, sizeof(buf));
        if(n < 0)
            return;
        if(n == 0)
            break;
        m = 0;
        for(i = 0; i < n; i++){
            c = buf[i];
            if(c > 0x1f && c < 0x7f		/* normal characters */
            || c >= 0x9 && c <= 0xd)	/* \t, \n, vertical tab, form feed, \r */
                buf[m++] = c;
        }

        if(m && write(out, buf, m) < 0)
            return;
    }
}
@

<<function [[msgBodySize]]>>=
/*
 * read in the message body to count \n without a preceding \r
 */
static int
msgBodySize(Msg *m)
{
    Dir *d;
    char buf[BufSize + 2], *s, *se;
    vlong length;
    ulong size, lines, bad;
    int n, fd, c;

    if(m->lines != ~0UL)
        return 1;
    fd = msgFile(m, "rawbody");
    if(fd < 0)
        return 0;
    d = dirfstat(fd);
    if(d == nil){
        close(fd);
        return 0;
    }
    length = d->length;
    free(d);

    size = 0;
    lines = 0;
    bad = 0;
    buf[0] = ' ';
    for(;;){
        n = read(fd, &buf[1], BufSize);
        if(n <= 0)
            break;
        size += n;
        se = &buf[n + 1];
        for(s = &buf[1]; s < se; s++){
            c = *s;
            if(c == '\0'){
                close(fd);
                return msgBogus(m, BogusBody);
            }
            if(c != '\n')
                continue;
            if(s[-1] != '\r')
                bad++;
            lines++;
        }
        buf[0] = buf[n];
    }
    if(size != length)
        bye("bad length reading rawbody");
    size += bad;
    m->size = size;
    m->lines = lines;
    close(fd);
    return 1;
}
@

<<function [[msgUnix]]>>=
/*
 * retrieve information from the unixheader file
 */
static int
msgUnix(Msg *m, int top)
{
    Tm tm;
    char *s, *ss;

    if(m->unixDate != nil)
        return 1;

    if(!top){
bogus:
        m->unixDate = estrdup("");
        m->unixFrom = unixFrom(nil);
        return 1;
    }

    if(msgReadFile(m, "unixheader", &ss) < 0)
        return 0;
    s = ss;
    s = strchr(s, ' ');
    if(s == nil){
        free(ss);
        goto bogus;
    }
    s++;
    m->unixFrom = unixFrom(s);
    s = (char*)headStr;
    if(date2tm(&tm, s) == nil)
        s = m->info[IUnixDate];
    if(s == nil){
        free(ss);
        goto bogus;
    }
    m->unixDate = estrdup(s);
    free(ss);
    return 1;
}
@

<<function [[unixFrom]]>>=
/*
 * parse the address in the unix header
 * last line of defence, so must return something
 */
static MAddr *
unixFrom(char *s)
{
    MAddr *a;
    char *e, *t;

    if(s == nil)
        return nil;
    headStr = (uchar*)s;
    t = emalloc(strlen(s) + 2);
    e = headAddrSpec(t, nil);
    if(e == nil)
        a = nil;
    else{
        if(*e != '\0')
            *e++ = '\0';
        else
            e = site;
        a = MKZ(MAddr);

        a->box = estrdup(t);
        a->host = estrdup(e);
    }
    free(t);
    return a;
}
@

<<function [[msgHeader]]>>=
/*
 * read in the entire header,
 * and parse out any existing mime headers
 */
static int
msgHeader(Msg *m, Header *h, char *file)
{
    char *s, *ss, *t, *te;
    ulong lines, n, nn;
    long ns;
    int dated, c;

    if(h->buf != nil)
        return 1;

    ns = msgReadFile(m, file, &ss);
    if(ns < 0)
        return 0;
    s = ss;
    n = ns;

    /*
     * count lines ending with \n and \r\n
     * add an extra line at the end, since upas/fs headers
     * don't have a terminating \r\n
     */
    lines = 1;
    te = s + ns;
    for(t = s; t < te; t++){
        c = *t;
        if(c == '\0')
            return msgBogus(m, BogusHeader);
        if(c != '\n')
            continue;
        if(t == s || t[-1] != '\r')
            n++;
        lines++;
    }
    if(t > s && t[-1] != '\n'){
        if(t[-1] != '\r')
            n++;
        n++;
    }
    n += 2;
    h->buf = emalloc(n + 1);
    h->size = n;
    h->lines = lines;

    /*
     * make sure all headers end in \r\n
     */
    nn = 0;
    for(t = s; t < te; t++){
        c = *t;
        if(c == '\n'){
            if(!nn || h->buf[nn - 1] != '\r')
                h->buf[nn++] = '\r';
            lines++;
        }
        h->buf[nn++] = c;
    }
    if(nn && h->buf[nn-1] != '\n'){
        if(h->buf[nn-1] != '\r')
            h->buf[nn++] = '\r';
        h->buf[nn++] = '\n';
    }
    h->buf[nn++] = '\r';
    h->buf[nn++] = '\n';
    h->buf[nn] = '\0';
    if(nn != n)
        bye("misconverted header %ld %ld", nn, n);
    free(s);

    /*
     * and parse some mime headers
     */
    headStr = (uchar*)h->buf;
    dated = 0;
    while(s = headAtom(headFieldStop)){
        if(cistrcmp(s, "content-type") == 0)
            mimeType(h);
        else if(cistrcmp(s, "content-transfer-encoding") == 0)
            mimeEncoding(h);
        else if(cistrcmp(s, "content-id") == 0)
            mimeId(h);
        else if(cistrcmp(s, "content-description") == 0)
            mimeDescription(h);
        else if(cistrcmp(s, "content-disposition") == 0)
            mimeDisposition(h);
        else if(cistrcmp(s, "content-md5") == 0)
            mimeMd5(h);
        else if(cistrcmp(s, "content-language") == 0)
            mimeLanguage(h);
        else if(h == &m->head && cistrcmp(s, "from") == 0)
            m->from = headMAddr(m->from);
        else if(h == &m->head && cistrcmp(s, "to") == 0)
            m->to = headMAddr(m->to);
        else if(h == &m->head && cistrcmp(s, "reply-to") == 0)
            m->replyTo = headMAddr(m->replyTo);
        else if(h == &m->head && cistrcmp(s, "sender") == 0)
            m->sender = headMAddr(m->sender);
        else if(h == &m->head && cistrcmp(s, "cc") == 0)
            m->cc = headMAddr(m->cc);
        else if(h == &m->head && cistrcmp(s, "bcc") == 0)
            m->bcc = headMAddr(m->bcc);
        else if(h == &m->head && cistrcmp(s, "date") == 0)
            dated = 1;
        headSkip();
        free(s);
    }

    if(h == &m->head){
        if(m->from == nil){
            m->from = m->unixFrom;
            if(m->from != nil){
                s = maddrStr(m->from);
                msgAddHead(m, "From", s);
                free(s);
            }
        }
        if(m->sender == nil)
            m->sender = m->from;
        if(m->replyTo == nil)
            m->replyTo = m->from;

        if(infoIsNil(m->info[IDate]))
            m->info[IDate] = m->unixDate;
        if(!dated && m->from != nil)
            msgAddDate(m);
    }
    return 1;
}
@

<<function [[msgAddHead]]>>=
/*
 * prepend head: body to the cached header
 */
static void
msgAddHead(Msg *m, char *head, char *body)
{
    char *s;
    long size, n;

    n = strlen(head) + strlen(body) + 4;
    size = m->head.size + n;
    s = emalloc(size + 1);
    snprint(s, size + 1, "%s: %s\r\n%s", head, body, m->head.buf);
    free(m->head.buf);
    m->head.buf = s;
    m->head.size = size;
    m->head.lines++;
}
@

<<function [[msgAddDate]]>>=
static void
msgAddDate(Msg *m)
{
    Tm tm;
    char buf[64];

    /* don't bother if we don't have a date */
    if(infoIsNil(m->info[IDate]))
        return;

    date2tm(&tm, m->info[IDate]);
    rfc822date(buf, sizeof(buf), &tm);
    msgAddHead(m, "Date", buf);
}
@

<<function [[mkMimeHdr]]>>=
static MimeHdr*
mkMimeHdr(char *s, char *t, MimeHdr *next)
{
    MimeHdr *mh;

    mh = MK(MimeHdr);
    mh->s = s;
    mh->t = t;
    mh->next = next;
    return mh;
}
@

<<function [[freeMimeHdr]]>>=
static void
freeMimeHdr(MimeHdr *mh)
{
    MimeHdr *last;

    while(mh != nil){
        last = mh;
        mh = mh->next;
        free(last->s);
        free(last->t);
        free(last);
    }
}
@

<<function [[cleanupHeader]]>>=
static void
cleanupHeader(Header *h)
{
    freeMimeHdr(h->type);
    freeMimeHdr(h->id);
    freeMimeHdr(h->description);
    freeMimeHdr(h->encoding);
    freeMimeHdr(h->md5);
    freeMimeHdr(h->disposition);
    freeMimeHdr(h->language);
}
@

<<function [[mimeType]]>>=
/*
 * type		: 'content-type' ':' token '/' token params
 */
static void
mimeType(Header *h)
{
    char *s, *t;

    if(headChar(1) != ':')
        return;
    s = headAtom(mimeTokenStop);
    if(s == nil || headChar(1) != '/'){
        free(s);
        return;
    }
    t = headAtom(mimeTokenStop);
    if(t == nil){
        free(s);
        return;
    }
    h->type = mkMimeHdr(s, t, mimeParams());
}
@

<<function [[mimeParams]]>>=
/*
 * params	:
 *		| params ';' token '=' token
 * 		| params ';' token '=' quoted-str
 */
static MimeHdr*
mimeParams(void)
{
    MimeHdr head, *last;
    char *s, *t;

    head.next = nil;
    last = &head;
    for(;;){
        if(headChar(1) != ';')
            break;
        s = headAtom(mimeTokenStop);
        if(s == nil || headChar(1) != '='){
            free(s);
            break;
        }
        if(headChar(0) == '"'){
            t = headQuoted('"', '"');
            stripQuotes(t);
        }else
            t = headAtom(mimeTokenStop);
        if(t == nil){
            free(s);
            break;
        }
        last->next = mkMimeHdr(s, t, nil);
        last = last->next;
    }
    return head.next;
}
@

<<function [[mimeEncoding]]>>=
/*
 * encoding	: 'content-transfer-encoding' ':' token
 */
static void
mimeEncoding(Header *h)
{
    char *s;

    if(headChar(1) != ':')
        return;
    s = headAtom(mimeTokenStop);
    if(s == nil)
        return;
    h->encoding = mkMimeHdr(s, nil, nil);
}
@

<<function [[headMAddr]]>>=
/*
 * mailaddr	: ':' addresses
 */
static MAddr*
headMAddr(MAddr *old)
{
    MAddr *a;

    if(headChar(1) != ':')
        return old;

    if(headChar(0) == '\n')
        return old;

    a = headAddresses();
    if(a == nil)
        return old;

    freeMAddr(old);
    return a;
}
@

<<function [[headAddresses]]>>=
/*
 * addresses	: address | addresses ',' address
 */
static MAddr*
headAddresses(void)
{
    MAddr *addr, *tail, *a;

    addr = headAddress();
    if(addr == nil)
        return nil;
    tail = addr;
    while(headChar(0) == ','){
        headChar(1);
        a = headAddress();
        if(a == nil){
            freeMAddr(addr);
            return nil;
        }
        tail->next = a;
        tail = a;
    }
    return addr;
}
@

<<function [[headAddress]]>>=
/*
 * address	: mailbox | group
 * group	: phrase ':' mboxes ';' | phrase ':' ';'
 * mailbox	: addr-spec
 *		| optphrase '<' addr-spec '>'
 *		| optphrase '<' route ':' addr-spec '>'
 * optphrase	: | phrase
 * route	: '@' domain
 *		| route ',' '@' domain
 * personal names are the phrase before '<',
 * or a comment before or after a simple addr-spec
 */
static MAddr*
headAddress(void)
{
    MAddr *addr;
    uchar *hs;
    char *s, *e, *w, *personal;
    int c;

    s = emalloc(strlen((char*)headStr) + 2);
    e = s;
    personal = headSkipWhite(1);
    c = headChar(0);
    if(c == '<')
        w = nil;
    else{
        w = headWord();
        c = headChar(0);
    }
    if(c == '.' || c == '@' || c == ',' || c == '\n' || c == '\0'){
        lastWhite = headStr;
        e = headAddrSpec(s, w);
        if(personal == nil){
            hs = headStr;
            headStr = lastWhite;
            personal = headSkipWhite(1);
            headStr = hs;
        }
    }else{
        if(c != '<' || w != nil){
            free(personal);
            if(!headPhrase(e, w)){
                free(s);
                return nil;
            }

            /*
             * ignore addresses with groups,
             * so the only thing left if <
             */
            c = headChar(1);
            if(c != '<'){
                free(s);
                return nil;
            }
            personal = estrdup(s);
        }else
            headChar(1);

        /*
         * after this point, we need to free personal before returning.
         * set e to nil to everything afterwards fails.
         *
         * ignore routes, they are useless, and heavily discouraged in rfc1123.
         * imap4 reports them up to, but not including, the terminating :
         */
        e = s;
        c = headChar(0);
        if(c == '@'){
            for(;;){
                c = headChar(1);
                if(c != '@'){
                    e = nil;
                    break;
                }
                headDomain(e);
                c = headChar(1);
                if(c != ','){
                    e = s;
                    break;
                }
            }
            if(c != ':')
                e = nil;
        }

        if(e != nil)
            e = headAddrSpec(s, nil);
        if(headChar(1) != '>')
            e = nil;
    }

    /*
     * e points to @host, or nil if an error occured
     */
    if(e == nil){
        free(personal);
        addr = nil;
    }else{
        if(*e != '\0')
            *e++ = '\0';
        else
            e = site;
        addr = MKZ(MAddr);

        addr->personal = personal;
        addr->box = estrdup(s);
        addr->host = estrdup(e);
    }
    free(s);
    return addr;
}
@

<<function [[headPhrase]]>>=
/*
 * phrase	: word
 *		| phrase word
 * w is the optional initial word of the phrase
 * returns the end of the phrase, or nil if a failure occured
 */
static char*
headPhrase(char *e, char *w)
{
    int c;

    for(;;){
        if(w == nil){
            w = headWord();
            if(w == nil)
                return nil;
        }
        if(w[0] == '"')
            stripQuotes(w);
        strcpy(e, w);
        free(w);
        w = nil;
        e = strchr(e, '\0');
        c = headChar(0);
        if(c <= ' ' || strchr(headAtomStop, c) != nil && c != '"')
            break;
        *e++ = ' ';
        *e = '\0';
    }
    return e;
}
@

<<function [[headAddrSpec]]>>=
/*
 * addr-spec	: local-part '@' domain
 *		| local-part			extension to allow ! and local names
 * local-part	: word
 *		| local-part '.' word
 *
 * if no '@' is present, rewrite d!e!f!u as @d,@e:u@f,
 * where d, e, f are valid domain components.
 * the @d,@e: is ignored, since routes are ignored.
 * perhaps they should be rewritten as e!f!u@d, but that is inconsistent with upas.
 *
 * returns a pointer to '@', the end if none, or nil if there was an error
 */
static char*
headAddrSpec(char *e, char *w)
{
    char *s, *at, *b, *bang, *dom;
    int c;

    s = e;
    for(;;){
        if(w == nil){
            w = headWord();
            if(w == nil)
                return nil;
        }
        strcpy(e, w);
        free(w);
        w = nil;
        e = strchr(e, '\0');
        lastWhite = headStr;
        c = headChar(0);
        if(c != '.')
            break;
        headChar(1);
        *e++ = '.';
        *e = '\0';
    }

    if(c != '@'){
        /*
         * extenstion: allow name without domain
         * check for domain!xxx
         */
        bang = domBang(s);
        if(bang == nil)
            return e;

        /*
         * if dom1!dom2!xxx, ignore dom1!
         */
        dom = s;
        for(; b = domBang(bang + 1); bang = b)
            dom = bang + 1;

        /*
         * convert dom!mbox into mbox@dom
         */
        *bang = '@';
        strrev(dom, bang);
        strrev(bang+1, e);
        strrev(dom, e);
        bang = &dom[e - bang - 1];
        if(dom > s){
            bang -= dom - s;
            for(e = s; *e = *dom; e++)
                dom++;
        }

        /*
         * eliminate a trailing '.'
         */
        if(e[-1] == '.')
            e[-1] = '\0';
        return bang;
    }
    headChar(1);

    at = e;
    *e++ = '@';
    *e = '\0';
    if(!headDomain(e))
        return nil;
    return at;
}
@

<<function [[domBang]]>>=
/*
 * find the ! in domain!rest, where domain must have at least
 * one internal '.'
 */
static char*
domBang(char *s)
{
    int dot, c;

    dot = 0;
    for(; c = *s; s++){
        if(c == '!'){
            if(!dot || dot == 1 && s[-1] == '.' || s[1] == '\0')
                return nil;
            return s;
        }
        if(c == '"')
            break;
        if(c == '.')
            dot++;
    }
    return nil;
}
@

<<function [[headDomain]]>>=
/*
 * domain	: sub-domain
 *		| domain '.' sub-domain
 * returns the end of the domain, or nil if a failure occured
 */
static char*
headDomain(char *e)
{
    char *w;

    for(;;){
        w = headSubDomain();
        if(w == nil)
            return nil;
        strcpy(e, w);
        free(w);
        e = strchr(e, '\0');
        lastWhite = headStr;
        if(headChar(0) != '.')
            break;
        headChar(1);
        *e++ = '.';
        *e = '\0';
    }
    return e;
}
@

<<function [[mimeId]]>>=
/*
 * id		: 'content-id' ':' msg-id
 * msg-id	: '<' addr-spec '>'
 */
static void
mimeId(Header *h)
{
    char *s, *e, *w;

    if(headChar(1) != ':')
        return;
    if(headChar(1) != '<')
        return;

    s = emalloc(strlen((char*)headStr) + 3);
    e = s;
    *e++ = '<';
    e = headAddrSpec(e, nil);
    if(e == nil || headChar(1) != '>'){
        free(s);
        return;
    }
    e = strchr(e, '\0');
    *e++ = '>';
    e[0] = '\0';
    w = strdup(s);
    free(s);
    h->id = mkMimeHdr(w, nil, nil);
}
@

<<function [[mimeDescription]]>>=
/*
 * description	: 'content-description' ':' *text
 */
static void
mimeDescription(Header *h)
{
    if(headChar(1) != ':')
        return;
    headSkipWhite(0);
    h->description = mkMimeHdr(headText(), nil, nil);
}
@

<<function [[mimeDisposition]]>>=
/*
 * disposition	: 'content-disposition' ':' token params
 */
static void
mimeDisposition(Header *h)
{
    char *s;

    if(headChar(1) != ':')
        return;
    s = headAtom(mimeTokenStop);
    if(s == nil)
        return;
    h->disposition = mkMimeHdr(s, nil, mimeParams());
}
@

<<function [[mimeMd5]]>>=
/*
 * md5		: 'content-md5' ':' token
 */
static void
mimeMd5(Header *h)
{
    char *s;

    if(headChar(1) != ':')
        return;
    s = headAtom(mimeTokenStop);
    if(s == nil)
        return;
    h->md5 = mkMimeHdr(s, nil, nil);
}
@

<<function [[mimeLanguage]]>>=
/*
 * language	: 'content-language' ':' langs
 * langs	: token
 *		| langs commas token
 * commas	: ','
 *		| commas ','
 */
static void
mimeLanguage(Header *h)
{
    MimeHdr head, *last;
    char *s;

    head.next = nil;
    last = &head;
    for(;;){
        s = headAtom(mimeTokenStop);
        if(s == nil)
            break;
        last->next = mkMimeHdr(s, nil, nil);
        last = last->next;
        while(headChar(0) != ',')
            headChar(1);
    }
    h->language = head.next;
}
@

<<function [[headAtom]]>>=
/*
 * token	: 1*<char 33-255, except "()<>@,;:\\\"/[]?=" aka mimeTokenStop>
 * atom		: 1*<chars 33-255, except "()<>@,;:\\\".[]" aka headAtomStop>
 * note this allows 8 bit characters, which occur in utf.
 */
static char*
headAtom(char *disallowed)
{
    char *s;
    int c, ns, as;

    headSkipWhite(0);

    s = emalloc(StrAlloc);
    as = StrAlloc;
    ns = 0;
    for(;;){
        c = *headStr++;
        if(c <= ' ' || strchr(disallowed, c) != nil){
            headStr--;
            break;
        }
        s[ns++] = c;
        if(ns >= as){
            as += StrAlloc;
            s = erealloc(s, as);
        }
    }
    if(ns == 0){
        free(s);
        return 0;
    }
    s[ns] = '\0';
    return s;
}
@

<<function [[headSubDomain]]>>=
/*
 * sub-domain	: atom | domain-lit
 */
static char *
headSubDomain(void)
{
    if(headChar(0) == '[')
        return headQuoted('[', ']');
    return headAtom(headAtomStop);
}
@

<<function [[headWord]]>>=
/*
 * word	: atom | quoted-str
 */
static char *
headWord(void)
{
    if(headChar(0) == '"')
        return headQuoted('"', '"');
    return headAtom(headAtomStop);
}
@

<<function [[stripQuotes]]>>=
/*
 * q is a quoted string.  remove enclosing " and and \ escapes
 */
static void
stripQuotes(char *q)
{
    char *s;
    int c;

    if(q == nil)
        return;
    s = q++;
    while(c = *q++){
        if(c == '\\'){
            c = *q++;
            if(!c)
                return;
        }
        *s++ = c;
    }
    s[-1] = '\0';
}
@

<<function [[headQuoted]]>>=
/*
 * quoted-str	: '"' *(any char but '"\\\r', or '\' any char, or linear-white-space) '"'
 * domain-lit	: '[' *(any char but '[]\\\r', or '\' any char, or linear-white-space) ']'
 */
static char *
headQuoted(int start, int stop)
{
    char *s;
    int c, ns, as;

    if(headChar(1) != start)
        return nil;
    s = emalloc(StrAlloc);
    as = StrAlloc;
    ns = 0;
    s[ns++] = start;
    for(;;){
        c = *headStr;
        if(c == stop){
            headStr++;
            break;
        }
        if(c == '\0'){
            free(s);
            return nil;
        }
        if(c == '\r'){
            headStr++;
            continue;
        }
        if(c == '\n'){
            headStr++;
            while(*headStr == ' ' || *headStr == '\t' || *headStr == '\r' || *headStr == '\n')
                headStr++;
            c = ' ';
        }else if(c == '\\'){
            headStr++;
            s[ns++] = c;
            c = *headStr;
            if(c == '\0'){
                free(s);
                return nil;
            }
            headStr++;
        }else
            headStr++;
        s[ns++] = c;
        if(ns + 1 >= as){	/* leave room for \c or "0 */
            as += StrAlloc;
            s = erealloc(s, as);
        }
    }
    s[ns++] = stop;
    s[ns] = '\0';
    return s;
}
@

<<function [[headText]]>>=
/*
 * headText	: contents of rest of header line
 */
static char *
headText(void)
{
    uchar *v;
    char *s;

    v = headStr;
    headToEnd();
    s = emalloc(headStr - v + 1);
    memmove(s, v, headStr - v);
    s[headStr - v] = '\0';
    return s;
}
@

<<function [[headSkipWhite]]>>=
/*
 * white space is ' ' '\t' or nested comments.
 * skip white space.
 * if com and a comment is seen,
 * return it's contents and stop processing white space.
 */
static char*
headSkipWhite(int com)
{
    char *s;
    int c, incom, as, ns;

    s = nil;
    as = StrAlloc;
    ns = 0;
    if(com)
        s = emalloc(StrAlloc);
    incom = 0;
    for(; c = *headStr; headStr++){
        switch(c){
        case ' ':
        case '\t':
        case '\r':
            c = ' ';
            break;
        case '\n':
            c = headStr[1];
            if(c != ' ' && c != '\t')
                goto breakout;
            c = ' ';
            break;
        case '\\':
            if(com && incom)
                s[ns++] = c;
            c = headStr[1];
            if(c == '\0')
                goto breakout;
            headStr++;
            break;
        case '(':
            incom++;
            if(incom == 1)
                continue;
            break;
        case ')':
            incom--;
            if(com && !incom){
                s[ns] = '\0';
                return s;
            }
            break;
        default:
            if(!incom)
                goto breakout;
            break;
        }
        if(com && incom && (c != ' ' || ns > 0 && s[ns-1] != ' ')){
            s[ns++] = c;
            if(ns + 1 >= as){	/* leave room for \c or 0 */
                as += StrAlloc;
                s = erealloc(s, as);
            }
        }
    }
breakout:;
    free(s);
    return nil;
}
@

<<function [[headChar]]>>=
/*
 * return the next non-white character
 */
static int
headChar(int eat)
{
    int c;

    headSkipWhite(0);
    c = *headStr;
    if(eat && c != '\0' && c != '\n')
        headStr++;
    return c;
}
@

<<function [[headToEnd]]>>=
static void
headToEnd(void)
{
    uchar *s;
    int c;

    for(;;){
        s = headStr;
        c = *s++;
        while(c == '\r')
            c = *s++;
        if(c == '\n'){
            c = *s++;
            if(c != ' ' && c != '\t')
                return;
        }
        if(c == '\0')
            return;
        headStr = s;
    }
}
@

<<function [[headSkip]]>>=
static void
headSkip(void)
{
    int c;

    while(c = *headStr){
        headStr++;
        if(c == '\n'){
            c = *headStr;
            if(c == ' ' || c == '\t')
                continue;
            return;
        }
    }
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/msg.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <libsec.h>
#include <auth.h>
#include <fcall.h>
#include "imap4d.h"

static void	body64(int in, int out);
static void	bodystrip(int in, int out);
static void	cleanupHeader(Header *h);
static char	*domBang(char *s);
static void	freeMAddr(MAddr *a);
static void	freeMimeHdr(MimeHdr *mh);
static char	*headAddrSpec(char *e, char *w);
static MAddr	*headAddresses(void);
static MAddr	*headAddress(void);
static char	*headAtom(char *disallowed);
static int	headChar(int eat);
static char	*headDomain(char *e);
static MAddr	*headMAddr(MAddr *old);
static char	*headPhrase(char *e, char *w);
static char	*headQuoted(int start, int stop);
static char	*headSkipWhite(int);
static void	headSkip(void);
static char	*headSubDomain(void);
static char	*headText(void);
static void	headToEnd(void);
static char	*headWord(void);
static void	mimeDescription(Header *h);
static void	mimeDisposition(Header *h);
static void	mimeEncoding(Header *h);
static void	mimeId(Header *h);
static void	mimeLanguage(Header *h);
static void	mimeMd5(Header *h);
static MimeHdr	*mimeParams(void);
static void	mimeType(Header *h);
static MimeHdr	*mkMimeHdr(char *s, char *t, MimeHdr *next);
static void	msgAddDate(Msg *m);
static void	msgAddHead(Msg *m, char *head, char *body);
static int	msgBodySize(Msg *m);
static int	msgHeader(Msg *m, Header *h, char *file);
static long	msgReadFile(Msg *m, char *file, char **ss);
static int	msgUnix(Msg *m, int top);
static void	stripQuotes(char *q);
static MAddr	*unixFrom(char *s);


<<global [[bogusBody]]>>

<<global [[bogusMimeText]]>>

<<global [[bogusMimeBinary]]>>

<<global [[headFieldStop]]>>
<<global [[mimeTokenStop]]>>
<<global [[headAtomStop]]>>
<<global [[headStr]]>>
<<global [[lastWhite]]>>

<<function [[selectFields]]>>

<<function [[freeMsg]]>>

<<function [[msgSize]]>>

<<function [[infoIsNil]]>>

<<function [[maddrStr]]>>

<<function [[msgFile]]>>

<<function [[msgIsMulti]]>>

<<function [[msgIsRfc822]]>>

<<function [[msgDead]]>>

<<function [[msgInfo]]>>

<<function [[msgStruct]]>>

<<function [[msgReadFile]]>>

<<function [[freeMAddr]]>>

<<function [[msgBogus]]>>

<<function [[enc64x18]]>>

<<function [[body64]]>>

<<function [[bodystrip]]>>

<<function [[msgBodySize]]>>

<<function [[msgUnix]]>>

<<function [[unixFrom]]>>

<<function [[msgHeader]]>>

<<function [[msgAddHead]]>>

<<function [[msgAddDate]]>>

<<function [[mkMimeHdr]]>>

<<function [[freeMimeHdr]]>>

<<function [[cleanupHeader]]>>

/*
 * parser for rfc822 & mime header fields
 */

<<function [[mimeType]]>>

<<function [[mimeParams]]>>

<<function [[mimeEncoding]]>>

<<function [[headMAddr]]>>

<<function [[headAddresses]]>>

<<function [[headAddress]]>>

<<function [[headPhrase]]>>

<<function [[headAddrSpec]]>>

<<function [[domBang]]>>

<<function [[headDomain]]>>

<<function [[mimeId]]>>

<<function [[mimeDescription]]>>

<<function [[mimeDisposition]]>>

<<function [[mimeMd5]]>>

<<function [[mimeLanguage]]>>

<<function [[headAtom]]>>

<<function [[headSubDomain]]>>

<<function [[headWord]]>>

<<function [[stripQuotes]]>>

<<function [[headQuoted]]>>

<<function [[headText]]>>

<<function [[headSkipWhite]]>>

<<function [[headChar]]>>

<<function [[headToEnd]]>>

<<function [[headSkip]]>>
@


\subsection*{[[networking/ip/imap4d/mutf7.c]]}

<<global [[mt64d]]>>=
/*
 * modified utf-7, as per imap4 spec
 * like utf-7, but substitues , for / in base 64,
 * does not allow escaped ascii characters.
 *
 * /lib/rfc/rfc2152 is utf-7
 * /lib/rfc/rfc1642 is obsolete utf-7
 *
 * test sequences from rfc1642
 *	'A≢Α.'		'A&ImIDkQ-.'
 *	'Hi Mom ☺!"	'Hi Mom &Jjo-!'
 *	'日本語'		'&ZeVnLIqe-'
 */

static uchar mt64d[256];
@

<<global [[mt64e]]>>=
static char mt64e[64];
@

<<function [[initm64]]>>=
static void
initm64(void)
{
    int c, i;

    memset(mt64d, 255, 256);
    memset(mt64e, '=', 64);
    i = 0;
    for(c = 'A'; c <= 'Z'; c++){
        mt64e[i] = c;
        mt64d[c] = i++;
    }
    for(c = 'a'; c <= 'z'; c++){
        mt64e[i] = c;
        mt64d[c] = i++;
    }
    for(c = '0'; c <= '9'; c++){
        mt64e[i] = c;
        mt64d[c] = i++;
    }
    mt64e[i] = '+';
    mt64d['+'] = i++;
    mt64e[i] = ',';
    mt64d[','] = i;
}
@

<<function [[encmutf7]]>>=
int
encmutf7(char *out, int lim, char *in)
{
    Rune rr;
    ulong r, b;
    char *start = out;
    char *e = out + lim;
    int nb;

    if(mt64e[0] == 0)
        initm64();
    for(;;){
        r = *(uchar*)in;

        if(r < ' ' || r >= Runeself){
            if(r == '\0')
                break;
            if(out + 1 >= e)
                return -1;
            *out++ = '&';
            b = 0;
            nb = 0;
            for(;;){
                in += chartorune(&rr, in);
                r = rr;
                if(r == '\0' || r >= ' ' && r < Runeself)
                    break;
                b = (b << 16) | r;
                for(nb += 16; nb >= 6; nb -= 6){
                    if(out + 1 >= e)
                        return -1;
                    *out++ = mt64e[(b>>(nb-6))&0x3f];
                }
            }
            for(; nb >= 6; nb -= 6){
                if(out + 1 >= e)
                    return -1;
                *out++ = mt64e[(b>>(nb-6))&0x3f];
            }
            if(nb){
                if(out + 1 >= e)
                    return -1;
                *out++ = mt64e[(b<<(6-nb))&0x3f];
            }

            if(out + 1 >= e)
                return -1;
            *out++ = '-';
            if(r == '\0')
                break;
        }else
            in++;
        if(out + 1 >= e)
            return -1;
        *out = r;
        out++;
        if(r == '&')
            *out++ = '-';
    }

    if(out >= e)
        return -1;
    *out = '\0';
    return out - start;
}
@

<<function [[decmutf7]]>>=
int
decmutf7(char *out, int lim, char *in)
{
    Rune rr;
    char *start = out;
    char *e = out + lim;
    int c, b, nb;

    if(mt64e[0] == 0)
        initm64();
    for(;;){
        c = *in;

        if(c < ' ' || c >= Runeself){
            if(c == '\0')
                break;
            return -1;
        }
        if(c != '&'){
            if(out + 1 >= e)
                return -1;
            *out++ = c;
            in++;
            continue;
        }
        in++;
        if(*in == '-'){
            if(out + 1 >= e)
                return -1;
            *out++ = '&';
            in++;
            continue;
        }

        b = 0;
        nb = 0;
        while((c = *in++) != '-'){
            c = mt64d[c];
            if(c >= 64)
                return -1;
            b = (b << 6) | c;
            nb += 6;
            if(nb >= 16){
                rr = b >> (nb - 16);
                nb -= 16;
                if(out + UTFmax + 1 >= e && out + runelen(rr) + 1 >= e)
                    return -1;
                out += runetochar(out, &rr);
            }
        }
        if(b & ((1 << nb) - 1))
            return -1;
    }

    if(out >= e)
        return -1;
    *out = '\0';
    return out - start;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/mutf7.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<global [[mt64d]]>>
<<global [[mt64e]]>>

<<function [[initm64]]>>

<<function [[encmutf7]]>>

<<function [[decmutf7]]>>
@


\subsection*{[[networking/ip/imap4d/nodes.c]]}

<<function [[forMsgs]]>>=
/*
 * iterated over all of the items in the message set.
 * errors are accumulated, but processing continues.
 * if uids, then ignore non-existent messages.
 * otherwise, that's an error
 */
int
forMsgs(Box *box, MsgSet *ms, ulong max, int uids, int (*f)(Box*, Msg*, int, void*), void *rock)
{
    Msg *m;
    ulong id;
    int ok, rok;

    ok = 1;
    for(; ms != nil; ms = ms->next){
        id = ms->from;
        rok = 0;
        for(m = box->msgs; m != nil && m->seq <= max; m = m->next){
            if(!uids && m->seq > id
            || uids && m->uid > ms->to)
                break;
            if(!uids && m->seq == id
            || uids && m->uid >= id){
                if(!(*f)(box, m, uids, rock))
                    ok = 0;
                if(uids)
                    id = m->uid;
                if(id >= ms->to){
                    rok = 1;
                    break;
                }
                if(ms->to == ~0UL)
                    rok = 1;
                id++;
            }
        }
        if(!uids && !rok)
            ok = 0;
    }
    return ok;
}
@

<<function [[mkStore]]>>=
Store *
mkStore(int sign, int op, int flags)
{
    Store *st;

    st = binalloc(&parseBin, sizeof(Store), 1);
    if(st == nil)
        parseErr("out of memory");
    st->sign = sign;
    st->op = op;
    st->flags = flags;
    return st;
}
@

<<function [[mkFetch]]>>=
Fetch *
mkFetch(int op, Fetch *next)
{
    Fetch *f;

    f = binalloc(&parseBin, sizeof(Fetch), 1);
    if(f == nil)
        parseErr("out of memory");
    f->op = op;
    f->next = next;
    return f;
}
@

<<function [[revFetch]]>>=
Fetch*
revFetch(Fetch *f)
{
    Fetch *last, *next;

    last = nil;
    for(; f != nil; f = next){
        next = f->next;
        f->next = last;
        last = f;
    }
    return last;
}
@

<<function [[mkNList]]>>=
NList*
mkNList(ulong n, NList *next)
{
    NList *nl;

    nl = binalloc(&parseBin, sizeof(NList), 0);
    if(nl == nil)
        parseErr("out of memory");
    nl->n = n;
    nl->next = next;
    return nl;
}
@

<<function [[revNList]]>>=
NList*
revNList(NList *nl)
{
    NList *last, *next;

    last = nil;
    for(; nl != nil; nl = next){
        next = nl->next;
        nl->next = last;
        last = nl;
    }
    return last;
}
@

<<function [[mkSList]]>>=
SList*
mkSList(char *s, SList *next)
{
    SList *sl;

    sl = binalloc(&parseBin, sizeof(SList), 0);
    if(sl == nil)
        parseErr("out of memory");
    sl->s = s;
    sl->next = next;
    return sl;
}
@

<<function [[revSList]]>>=
SList*
revSList(SList *sl)
{
    SList *last, *next;

    last = nil;
    for(; sl != nil; sl = next){
        next = sl->next;
        sl->next = last;
        last = sl;
    }
    return last;
}
@

<<function [[BNList]]>>=
int
BNList(Biobuf *b, NList *nl, char *sep)
{
    char *s;
    int n;

    s = "";
    n = 0;
    for(; nl != nil; nl = nl->next){
        n += Bprint(b, "%s%lud", s, nl->n);
        s = sep;
    }
    return n;
}
@

<<function [[BSList]]>>=
int
BSList(Biobuf *b, SList *sl, char *sep)
{
    char *s;
    int n;

    s = "";
    n = 0;
    for(; sl != nil; sl = sl->next){
        n += Bprint(b, "%s", s);
        n += Bimapstr(b, sl->s);
        s = sep;
    }
    return n;
}
@

<<function [[Bimapdate]]>>=
int
Bimapdate(Biobuf *b, Tm *tm)
{
    char buf[64];

    if(tm == nil)
        tm = localtime(time(nil));
    imap4date(buf, sizeof(buf), tm);
    return Bimapstr(b, buf);
}
@

<<function [[Brfc822date]]>>=
int
Brfc822date(Biobuf *b, Tm *tm)
{
    char buf[64];

    if(tm == nil)
        tm = localtime(time(nil));
    rfc822date(buf, sizeof(buf), tm);
    return Bimapstr(b, buf);
}
@

<<function [[Bimapstr]]>>=
int
Bimapstr(Biobuf *b, char *s)
{
    char *t;
    int c;

    if(s == nil)
        return Bprint(b, "NIL");
    for(t = s; ; t++){
        c = *t;
        if(c == '\0')
            return Bprint(b, "\"%s\"", s);
        if(t - s > 64 || c >= 0x7f || strchr("\"\\\r\n", c) != nil)
            break;
    }
    return Bprint(b, "{%lud}\r\n%s", strlen(s), s);
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/nodes.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<function [[forMsgs]]>>

<<function [[mkStore]]>>

<<function [[mkFetch]]>>

<<function [[revFetch]]>>

<<function [[mkNList]]>>

<<function [[revNList]]>>

<<function [[mkSList]]>>

<<function [[revSList]]>>

<<function [[BNList]]>>

<<function [[BSList]]>>

<<function [[Bimapdate]]>>

<<function [[Brfc822date]]>>

<<function [[Bimapstr]]>>
@


\subsection*{[[networking/ip/imap4d/search.c]]}

<<function [[searchMsg]]>>=
/*
 * free to exit, parseErr, since called before starting any client reply
 *
 * the header and envelope searches should convert mime character set escapes.
 */
int
searchMsg(Msg *m, Search *s)
{
    MsgSet *ms;
    int ok;

    if(!msgStruct(m, 1) || m->expunged)
        return 0;
    for(ok = 1; ok && s != nil; s = s->next){
        switch(s->key){
        default:
            ok = 0;
            break;
        case SKNot:
            ok = !searchMsg(m, s->left);
            break;
        case SKOr:
            ok = searchMsg(m, s->left) || searchMsg(m, s->right);
            break;
        case SKAll:
            ok = 1;
            break;
        case SKAnswered:
            ok = (m->flags & MAnswered) == MAnswered;
            break;
        case SKDeleted:
            ok = (m->flags & MDeleted) == MDeleted;
            break;
        case SKDraft:
            ok = (m->flags & MDraft) == MDraft;
            break;
        case SKFlagged:
            ok = (m->flags & MFlagged) == MFlagged;
            break;
        case SKKeyword:
            ok = (m->flags & s->num) == s->num;
            break;
        case SKNew:
            ok = (m->flags & (MRecent|MSeen)) == MRecent;
            break;
        case SKOld:
            ok = (m->flags & MRecent) != MRecent;
            break;
        case SKRecent:
            ok = (m->flags & MRecent) == MRecent;
            break;
        case SKSeen:
            ok = (m->flags & MSeen) == MSeen;
            break;
        case SKUnanswered:
            ok = (m->flags & MAnswered) != MAnswered;
            break;
        case SKUndeleted:
            ok = (m->flags & MDeleted) != MDeleted;
            break;
        case SKUndraft:
            ok = (m->flags & MDraft) != MDraft;
            break;
        case SKUnflagged:
            ok = (m->flags & MFlagged) != MFlagged;
            break;
        case SKUnkeyword:
            ok = (m->flags & s->num) != s->num;
            break;
        case SKUnseen:
            ok = (m->flags & MSeen) != MSeen;
            break;

        case SKLarger:
            ok = msgSize(m) > s->num;
            break;
        case SKSmaller:
            ok = msgSize(m) < s->num;
            break;

        case SKBcc:
            ok = addrSearch(m->bcc, s->s);
            break;
        case SKCc:
            ok = addrSearch(m->cc, s->s);
            break;
        case SKFrom:
            ok = addrSearch(m->from, s->s);
            break;
        case SKTo:
            ok = addrSearch(m->to, s->s);
            break;
        case SKSubject:
            ok = 0;
            if(m->info[ISubject])
                ok = cistrstr(m->info[ISubject], s->s) != nil;
            break;

        case SKBefore:
            ok = dateCmp(m->unixDate, s) < 0;
            break;
        case SKOn:
            ok = dateCmp(m->unixDate, s) == 0;
            break;
        case SKSince:
            ok = dateCmp(m->unixDate, s) > 0;
            break;
        case SKSentBefore:
            ok = dateCmp(m->info[IDate], s) < 0;
            break;
        case SKSentOn:
            ok = dateCmp(m->info[IDate], s) == 0;
            break;
        case SKSentSince:
            ok = dateCmp(m->info[IDate], s) > 0;
            break;

        case SKUid:
        case SKSet:
            for(ms = s->set; ms != nil; ms = ms->next)
                if(s->key == SKUid && m->uid >= ms->from && m->uid <= ms->to
                || s->key == SKSet && m->seq >= ms->from && m->seq <= ms->to)
                    break;
            ok = ms != nil;
            break;

        case SKHeader:
            ok = headerSearch(m, s->hdr, s->s);
            break;

        case SKBody:
        case SKText:
            if(s->key == SKText && cistrstr(m->head.buf, s->s)){
                ok = 1;
                break;
            }
            ok = fileSearch(m, "body", s->s);
            break;
        }
    }
    return ok;
}
@

<<function [[fileSearch]]>>=
static int
fileSearch(Msg *m, char *file, char *pat)
{
    char buf[BufSize + 1];
    int n, nbuf, npat, fd, ok;

    npat = strlen(pat);
    if(npat >= BufSize / 2)
        return 0;

    fd = msgFile(m, file);
    if(fd < 0)
        return 0;
    ok = 0;
    nbuf = 0;
    for(;;){
        n = read(fd, &buf[nbuf], BufSize - nbuf);
        if(n <= 0)
            break;
        nbuf += n;
        buf[nbuf] = '\0';
        if(cistrstr(buf, pat) != nil){
            ok = 1;
            break;
        }
        if(nbuf > npat){
            memmove(buf, &buf[nbuf - npat], npat);
            nbuf = npat;
        }
    }
    close(fd);
    return ok;
}
@

<<function [[headerSearch]]>>=
static int
headerSearch(Msg *m, char *hdr, char *pat)
{
    SList hdrs;
    char *s, *t;
    int ok, n;

    n = m->head.size + 3;
    s = emalloc(n);
    hdrs.next = nil;
    hdrs.s = hdr;
    ok = 0;
    if(selectFields(s, n, m->head.buf, &hdrs, 1) > 0){
        t = strchr(s, ':');
        if(t != nil && cistrstr(t+1, pat) != nil)
            ok = 1;
    }
    free(s);
    return ok;
}
@

<<function [[addrSearch]]>>=
static int
addrSearch(MAddr *a, char *s)
{
    char *ok, *addr;

    for(; a != nil; a = a->next){
        addr = maddrStr(a);
        ok = cistrstr(addr, s);
        free(addr);
        if(ok != nil)
            return 1;
    }
    return 0;
}
@

<<function [[dateCmp]]>>=
static int
dateCmp(char *date, Search *s)
{
    Tm tm;

    date2tm(&tm, date);
    if(tm.year < s->year)
        return -1;
    if(tm.year > s->year)
        return 1;
    if(tm.mon < s->mon)
        return -1;
    if(tm.mon > s->mon)
        return 1;
    if(tm.mday < s->mday)
        return -1;
    if(tm.mday > s->mday)
        return 1;
    return 0;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/search.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

static int	dateCmp(char *date, Search *s);
static int	addrSearch(MAddr *a, char *s);
static int	fileSearch(Msg *m, char *file, char *pat);
static int	headerSearch(Msg *m, char *hdr, char *pat);

<<function [[searchMsg]]>>

<<function [[fileSearch]]>>

<<function [[headerSearch]]>>

<<function [[addrSearch]]>>

<<function [[dateCmp]]>>
@


\subsection*{[[networking/ip/imap4d/store.c]]}

<<global [[flagMap]]>>=
static NamedInt	flagMap[] =
{
    {"\\Seen",	MSeen},
    {"\\Answered",	MAnswered},
    {"\\Flagged",	MFlagged},
    {"\\Deleted",	MDeleted},
    {"\\Draft",	MDraft},
    {"\\Recent",	MRecent},
    {nil,		0}
};
@

<<function [[storeMsg]]>>=
int
storeMsg(Box *box, Msg *m, int uids, void *vst)
{
    Store *st;
    int f, flags;

    USED(uids);

    if(m->expunged)
        return uids;

    st = vst;
    flags = st->flags;

    f = m->flags;
    if(st->sign == '+')
        f |= flags;
    else if(st->sign == '-')
        f &= ~flags;
    else
        f = flags;

    /*
     * not allowed to change the recent flag
     */
    f = (f & ~MRecent) | (m->flags & MRecent);
    setFlags(box, m, f);

    if(st->op != STFlagsSilent){
        m->sendFlags = 1;
        box->sendFlags = 1;
    }

    return 1;
}
@

<<function [[setFlags]]>>=
/*
 * update flags & global flag counts in box
 */
void
setFlags(Box *box, Msg *m, int f)
{
    if(f == m->flags)
        return;

    box->dirtyImp = 1;
    if((f & MRecent) != (m->flags & MRecent)){
        if(f & MRecent)
            box->recent++;
        else
            box->recent--;
    }
    m->flags = f;
}
@

<<function [[sendFlags]]>>=
void
sendFlags(Box *box, int uids)
{
    Msg *m;

    if(!box->sendFlags)
        return;

    box->sendFlags = 0;
    for(m = box->msgs; m != nil; m = m->next){
        if(!m->expunged && m->sendFlags){
            Bprint(&bout, "* %lud FETCH (", m->seq);
            if(uids)
                Bprint(&bout, "uid %lud ", m->uid);
            Bprint(&bout, "FLAGS (");
            writeFlags(&bout, m, 1);
            Bprint(&bout, "))\r\n");
            m->sendFlags = 0;
        }
    }
}
@

<<function [[writeFlags]]>>=
void
writeFlags(Biobuf *b, Msg *m, int recentOk)
{
    char *sep;
    int f;

    sep = "";
    for(f = 0; flagMap[f].name != nil; f++){
        if((m->flags & flagMap[f].v)
        && (flagMap[f].v != MRecent || recentOk)){
            Bprint(b, "%s%s", sep, flagMap[f].name);
            sep = " ";
        }
    }
}
@

<<function [[msgSeen]]>>=
int
msgSeen(Box *box, Msg *m)
{
    if(m->flags & MSeen)
        return 0;
    m->flags |= MSeen;
    box->sendFlags = 1;
    m->sendFlags = 1;
    box->dirtyImp = 1;
    return 1;
}
@

<<function [[mapFlag]]>>=
ulong
mapFlag(char *name)
{
    return mapInt(flagMap, name);
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/store.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<global [[flagMap]]>>

<<function [[storeMsg]]>>

<<function [[setFlags]]>>

<<function [[sendFlags]]>>

<<function [[writeFlags]]>>

<<function [[msgSeen]]>>

<<function [[mapFlag]]>>
@


\subsection*{[[networking/ip/imap4d/utils.c]]}

<<function [[strrev]]>>=
/*
 * reverse string [s:e) in place
 */
void
strrev(char *s, char *e)
{
    int c;

    while(--e > s){
        c = *s;
        *s++ = *e;
        *e = c;
    }
}
@

<<function [[isdotdot]]>>=
int
isdotdot(char *s)
{
    return s[0] == '.' && s[1] == '.' && (s[2] == '/' || s[2] == '\0');
}
@

<<function [[issuffix]]>>=
int
issuffix(char *suf, char *s)
{
    int n;

    n = strlen(s) - strlen(suf);
    if(n < 0)
        return 0;
    return strcmp(s + n, suf) == 0;
}
@

<<function [[isprefix]]>>=
int
isprefix(char *pre, char *s)
{
    return strncmp(pre, s, strlen(pre)) == 0;
}
@

<<function [[ciisprefix]]>>=
int
ciisprefix(char *pre, char *s)
{
    return cistrncmp(pre, s, strlen(pre)) == 0;
}
@

<<function [[readFile]]>>=
char*
readFile(int fd)
{
    Dir *d;
    long length;
    char *s;

    d = dirfstat(fd);
    if(d == nil)
        return nil;
    length = d->length;
    free(d);
    s = binalloc(&parseBin, length + 1, 0);
    if(s == nil || read(fd, s, length) != length)
        return nil;
    s[length] = '\0';
    return s;
}
@

<<function [[imapTmp]]>>=
/*
 * create the imap tmp file.
 * it just happens that we don't need multiple temporary files.
 */
int
imapTmp(void)
{
    char buf[ERRMAX], name[MboxNameLen];
    int tries, fd;

    snprint(name, sizeof(name), "/mail/box/%s/mbox.tmp.imp", username);
    for(tries = 0; tries < LockSecs*2; tries++){
        fd = create(name, ORDWR|ORCLOSE|OCEXEC, DMEXCL|0600);
        if(fd >= 0)
            return fd;
        errstr(buf, sizeof buf);
        if(cistrstr(buf, "locked") == nil)
            break;
        sleep(500);
    }
    return -1;
}
@

<<function [[openLocked]]([[(networking/ip/imap4d/utils.c)]])>>=
/*
 * open a file which might be locked.
 * if it is, spin until available
 */
int
openLocked(char *dir, char *file, int mode)
{
    char buf[ERRMAX];
    int tries, fd;

    for(tries = 0; tries < LockSecs*2; tries++){
        fd = cdOpen(dir, file, mode);
        if(fd >= 0)
            return fd;
        errstr(buf, sizeof buf);
        if(cistrstr(buf, "locked") == nil)
            break;
        sleep(500);
    }
    return -1;
}
@

<<function [[fqid]]>>=
int
fqid(int fd, Qid *qid)
{
    Dir *d;

    d = dirfstat(fd);
    if(d == nil)
        return -1;
    *qid = d->qid;
    free(d);
    return 0;
}
@

<<function [[mapInt]]>>=
ulong
mapInt(NamedInt *map, char *name)
{
    int i;

    for(i = 0; map[i].name != nil; i++)
        if(cistrcmp(map[i].name, name) == 0)
            break;
    return map[i].v;
}
@

<<function [[estrdup]]([[(networking/ip/imap4d/utils.c)]])>>=
char*
estrdup(char *s)
{
    char *t;

    t = emalloc(strlen(s) + 1);
    strcpy(t, s);
    return t;
}
@

<<function [[emalloc]]([[(networking/ip/imap4d/utils.c)]])>>=
void*
emalloc(ulong n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        bye("server out of memory");
    setmalloctag(p, getcallerpc(&n));
    return p;
}
@

<<function [[ezmalloc]]>>=
void*
ezmalloc(ulong n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        bye("server out of memory");
    setmalloctag(p, getcallerpc(&n));
    memset(p, 0, n);
    return p;
}
@

<<function [[erealloc]]([[(networking/ip/imap4d/utils.c)]])>>=
void*
erealloc(void *p, ulong n)
{
    p = realloc(p, n);
    if(p == nil)
        bye("server out of memory");
    setrealloctag(p, getcallerpc(&p));
    return p;
}
@


%-------------------------------------------------------------

<<networking/ip/imap4d/utils.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <auth.h>
#include "imap4d.h"

<<function [[strrev]]>>

<<function [[isdotdot]]>>

<<function [[issuffix]]>>

<<function [[isprefix]]>>

<<function [[ciisprefix]]>>

<<function [[readFile]]>>

<<function [[imapTmp]]>>

<<function [[openLocked]]([[(networking/ip/imap4d/utils.c)]])>>

<<function [[fqid]]>>

<<function [[mapInt]]>>

<<function [[estrdup]]([[(networking/ip/imap4d/utils.c)]])>>

<<function [[emalloc]]([[(networking/ip/imap4d/utils.c)]])>>

<<function [[ezmalloc]]>>

<<function [[erealloc]]([[(networking/ip/imap4d/utils.c)]])>>
@


\section{[[networking/ip/ppp/]]}

\subsection*{[[networking/ip/ppp/block.c]]}

<<enum [[_anon_ (networking/ip/ppp/block.c)]]>>=
enum
{
    PAD	= 128,
    NLIST	= (1<<5),
    BPOW	= 10,
};
@

<<struct [[Barena]]>>=
struct Barena
{
    QLock;
    Block*	list[NLIST];
};
@

<<global [[area]]>>=
static Barena area;
@

<<enum [[_anon_ (networking/ip/ppp/block.c)2]]>>=
/*
 *  allocation tracing
 */
enum
{
    Npc=	64,
};
@

<<struct [[Arefent]]>>=
struct Arefent
{
    uint	pc;
    uint	n;
};
@

<<struct [[Aref]]>>=
struct  Aref
{
    Arefent	tab[Npc];
    QLock;
};
@

<<global [[arefblock]]>>=
Aref arefblock;
@

<<function [[concat]]>>=
/*
 *  concatenate a list of blocks into a single one and make sure
 *  the result is at least min uchars
 */
Block*
concat(Block *bp)
{
    int len;
    Block *nb, *f;

    nb = allocb(blen(bp));
    for(f = bp; f; f = f->next) {
        len = BLEN(f);
        memmove(nb->wptr, f->rptr, len);
        nb->wptr += len;
    }
    freeb(bp);
    return nb;
}
@

<<function [[blen]]>>=
int
blen(Block *bp)
{
    int len;

    len = 0;
    while(bp) {
        len += BLEN(bp);
        bp = bp->next;
    }
    return len;
}
@

<<function [[pullup]]>>=
Block *
pullup(Block *bp, int n)
{
    int i;
    Block *nbp;

    /*
     *  this should almost always be true, the rest it
     *  just for to avoid every caller checking.
     */
    if(BLEN(bp) >= n)
        return bp;

    /*
     *  if not enough room in the first block,
     *  add another to the front of the list.
     */
    if(bp->lim - bp->rptr < n){
        nbp = allocb(n);
        nbp->next = bp;
        bp = nbp;
    }

    /*
     *  copy uchars from the trailing blocks into the first
     */
    n -= BLEN(bp);
    while(nbp = bp->next){
        i = BLEN(nbp);
        if(i >= n) {
            memmove(bp->wptr, nbp->rptr, n);
            bp->wptr += n;
            nbp->rptr += n;
            return bp;
        }
        else {
            memmove(bp->wptr, nbp->rptr, i);
            bp->wptr += i;
            bp->next = nbp->next;
            nbp->next = nil;
            freeb(nbp);
            n -= i;
        }
    }
    freeb(bp);
    return nil;
}
@

<<function [[padb]]>>=
/*
 *  Pad a block to the front with n uchars.  This is used to add protocol
 *  headers to the front of blocks.
 */
Block*
padb(Block *bp, int n)
{
    Block *nbp;

    if(bp->rptr-bp->base >= n) {
        bp->rptr -= n;
        return bp;
    }
    else {
        /* fprint(2, "padb: required %d PAD %d\n", n, PAD) = malloc(sizeof(*required %d PAD %d\n", n, PAD))); */
        nbp = allocb(n);
        nbp->wptr = nbp->lim;
        nbp->rptr = nbp->wptr - n;
        nbp->next = bp;
        return nbp;
    }
} 
@

<<function [[btrim]]>>=
Block *
btrim(Block *bp, int offset, int len)
{
    ulong l;
    Block *nb, *startb;

    if(blen(bp) < offset+len) {
        freeb(bp);
        return nil;
    }

    while((l = BLEN(bp)) < offset) {
        offset -= l;
        nb = bp->next;
        bp->next = nil;
        freeb(bp);
        bp = nb;
    }

    startb = bp;
    bp->rptr += offset;

    while((l = BLEN(bp)) < len) {
        len -= l;
        bp = bp->next;
    }

    bp->wptr -= (BLEN(bp) - len);
    bp->flags |= S_DELIM;

    if(bp->next) {
        freeb(bp->next);
        bp->next = nil;
    }

    return startb;
}
@

<<function [[copyb]]>>=
Block*
copyb(Block *bp, int count)
{
    int l;
    Block *nb, *head, **p;

    p = &head;
    head = nil;
    while(bp != nil && count != 0) {
        l = BLEN(bp);
        if(count < l)
            l = count;
        nb = allocb(l);
        memmove(nb->wptr, bp->rptr, l);
        nb->wptr += l;
        count -= l;
        nb->flags = bp->flags;
        *p = nb;
        p = &nb->next;
        bp = bp->next;
    }
    if(count) {
        nb = allocb(count);
        memset(nb->wptr, 0, count);
        nb->wptr += count;
        nb->flags |= S_DELIM;
        *p = nb;
    }
    if(blen(head) == 0)
        fprint(2, "copyb: zero length\n");

    return head;
}
@

<<function [[pullb]]>>=
int
pullb(Block **bph, int count)
{
    Block *bp;
    int n, uchars;

    uchars = 0;
    if(bph == nil)
        return 0;

    while(*bph != nil && count != 0) {
        bp = *bph;
        n = BLEN(bp);
        if(count < n)
            n = count;
        uchars += n;
        count -= n;
        bp->rptr += n;
        if(BLEN(bp) == 0) {
            *bph = bp->next;
            bp->next = nil;
            freeb(bp);
        }
    }
    return uchars;
}
@

<<function [[callerpc]]>>=
/*
 *  handy routines for keeping track of allocations
 */
static ulong
callerpc(void *a)
{
    return ((ulong*)a)[-1];
}
@

<<function [[aref]]>>=
static void
aref(Aref *ap, ulong pc)
{
    Arefent *a, *e;

    e = &ap->tab[Npc-1];
    qlock(ap);
    for(a = ap->tab; a < e; a++)
        if(a->pc == pc || a->pc == 0)
            break;
    a->pc = pc;
    a->n++;
    qunlock(ap);
}
@

<<function [[aunref]]>>=
static void
aunref(Aref *ap, ulong pc)
{
    Arefent *a, *e;

    e = &ap->tab[Npc-1];
    qlock(ap);
    for(a = ap->tab; a < e; a++)
        if(a->pc == pc || a->pc == 0)
            break;
    a->n--;
    qunlock(ap);
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/block.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <auth.h>
#include "ppp.h"

<<enum [[_anon_ (networking/ip/ppp/block.c)]]>>

typedef struct Barena Barena;
<<struct [[Barena]]>>
<<global [[area]]>>

#define ADEBUG if(0)


<<enum [[_anon_ (networking/ip/ppp/block.c)2]]>>
typedef struct Arefent Arefent;
<<struct [[Arefent]]>>
typedef struct Aref Aref;
<<struct [[Aref]]>>
<<global [[arefblock]]>>

static ulong	callerpc(void*);
static void	aref(Aref*, ulong);
static void	aunref(Aref*, ulong);

Block*
allocb(int len)
{
    int sz;
    Block *bp, **l;

    len += PAD;
    sz = (len>>BPOW)&(NLIST-1);
    
    qlock(&area);
    l = &area.list[sz];
    for(bp = *l; bp; bp = bp->flist) {
        if(bp->bsz >= len) {
            *l = bp->flist;
            qunlock(&area);

            bp->next = nil;
            bp->list = nil;
            bp->flist = nil;
            bp->base = (uchar*)bp+sizeof(Block);
            bp->rptr = bp->base+PAD;
            bp->wptr = bp->rptr;
            bp->lim  = bp->base+bp->bsz;
            bp->flow = nil;
            bp->flags= 0;
            ADEBUG {
                bp->pc = callerpc(&len);
                aref(&arefblock, bp->pc);
            }
            return bp;
        }
        l = &bp->flist;
    }

    qunlock(&area);

    bp = mallocz(sizeof(Block)+len, 1);

    bp->bsz  = len;
    bp->base = (uchar*)bp+sizeof(Block);
    bp->rptr = bp->base+PAD;
    bp->wptr = bp->rptr;
    bp->lim  = bp->base+len;
    ADEBUG {
        bp->pc = callerpc(&len);
        aref(&arefblock, bp->pc);
    }
    return bp;
}

void
freeb(Block *bp)
{
    int sz;
    Block **l, *next;

    qlock(&area);
    while(bp) {
        sz = (bp->bsz>>BPOW)&(NLIST-1);

        l = &area.list[sz];
        bp->flist = *l;
        *l = bp;

        next = bp->next;

        /* to catch use after free */
        bp->rptr = (uchar*)0xdeadbabe;
        bp->wptr = (uchar*)0xdeadbabe;
        bp->next = (Block*)0xdeadbabe;
        bp->list = (Block*)0xdeadbabe;

        ADEBUG aunref(&arefblock, bp->pc);

        bp = next;
    }
    qunlock(&area);
}

<<function [[concat]]>>

<<function [[blen]]>>

<<function [[pullup]]>>

<<function [[padb]]>>

<<function [[btrim]]>>

<<function [[copyb]]>>

<<function [[pullb]]>>

<<function [[callerpc]]>>
<<function [[aref]]>>
<<function [[aunref]]>>
@


\subsection*{[[networking/ip/ppp/compress.c]]}

<<struct [[Iphdr]]([[(networking/ip/ppp/compress.c)]])>>=
struct Iphdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    ulong	src;		/* Ip source (uchar ordering unimportant) */
    ulong	dst;		/* Ip destination (uchar ordering unimportant) */
};
@

<<struct [[Tcphdr]]>>=
struct Tcphdr
{
    ulong	ports;		/* defined as a ulong to make comparisons easier */
    uchar	seq[4];
    uchar	ack[4];
    uchar	flag[2];
    uchar	win[2];
    uchar	cksum[2];
    uchar	urg[2];
};
@

<<struct [[Ilhdr]]([[(networking/ip/ppp/compress.c)]])>>=
struct Ilhdr
{
    uchar	sum[2];	/* Checksum including header */
    uchar	len[2];	/* Packet length */
    uchar	type;		/* Packet type */
    uchar	spec;		/* Special */
    uchar	src[2];	/* Src port */
    uchar	dst[2];	/* Dst port */
    uchar	id[4];	/* Sequence id */
    uchar	ack[4];	/* Acked sequence */
};
@

<<enum [[_anon_ (networking/ip/ppp/compress.c)]]>>=
enum
{
    URG		= 0x20,		/* Data marked urgent */
    ACK		= 0x10,		/* Aknowledge is valid */
    PSH		= 0x08,		/* Whole data pipe is pushed */
    RST		= 0x04,		/* Reset connection */
    SYN		= 0x02,		/* Pkt. is synchronise */
    FIN		= 0x01,		/* Start close down */

    IP_DF		= 0x4000,	/* Don't fragment */

    IP_TCPPROTO	= 6,
    IP_ILPROTO	= 40,
    IL_IPHDR	= 20,
};
@

<<struct [[Hdr]]([[(networking/ip/ppp/compress.c)]])>>=
struct Hdr
{
    uchar	buf[128];
    Iphdr	*ip;
    Tcphdr	*tcp;
    int	len;
};
@

<<struct [[Tcpc]]>>=
struct Tcpc
{
    uchar	lastrecv;
    uchar	lastxmit;
    uchar	basexmit;
    uchar	err;
    uchar	compressid;
    Hdr	t[MAX_STATES];
    Hdr	r[MAX_STATES];
};
@

<<enum [[_anon_ (networking/ip/ppp/compress.c)2]]>>=
enum
{	/* flag bits for what changed in a packet */
    NEW_U=(1<<0),	/* tcp only */
    NEW_W=(1<<1),	/* tcp only */
    NEW_A=(1<<2),	/* il tcp */
    NEW_S=(1<<3),	/* tcp only */
    NEW_P=(1<<4),	/* tcp only */
    NEW_I=(1<<5),	/* il tcp */
    NEW_C=(1<<6),	/* il tcp */
    NEW_T=(1<<7),	/* il only */
    TCP_PUSH_BIT	= 0x10,
};
@

<<constant [[SPECIAL_I]]>>=
/* reserved, special-case values of above for tcp */
#define SPECIAL_I (NEW_S|NEW_W|NEW_U)		/* echoed interactive traffic */
@

<<constant [[SPECIAL_D]]>>=
#define SPECIAL_D (NEW_S|NEW_A|NEW_W|NEW_U)	/* unidirectional data */
@

<<constant [[SPECIALS_MASK]]>>=
#define SPECIALS_MASK (NEW_S|NEW_A|NEW_W|NEW_U)
@

<<function [[encode]]>>=
int
encode(void *p, ulong n)
{
    uchar	*cp;

    cp = p;
    if(n >= 256 || n == 0) {
        *cp++ = 0;
        cp[0] = n >> 8;
        cp[1] = n;
        return 3;
    }
    *cp = n;
    return 1;
}
@

<<macro [[DECODEL]]>>=
#define DECODEL(f) { \
    if (*cp == 0) {\
        hnputl(f, nhgetl(f) + ((cp[1] << 8) | cp[2])); \
        cp += 3; \
    } else { \
        hnputl(f, nhgetl(f) + (ulong)*cp++); \
    } \
}
@

<<macro [[DECODES]]>>=
#define DECODES(f) { \
    if (*cp == 0) {\
        hnputs(f, nhgets(f) + ((cp[1] << 8) | cp[2])); \
        cp += 3; \
    } else { \
        hnputs(f, nhgets(f) + (ulong)*cp++); \
    } \
}
@

<<function [[tcpcompress]]>>=
Block*
tcpcompress(Tcpc *comp, Block *b, int *protop)
{
    Iphdr	*ip;		/* current packet */
    Tcphdr	*tcp;		/* current pkt */
    ulong 	iplen, tcplen, hlen;	/* header length in uchars */
    ulong 	deltaS, deltaA;	/* general purpose temporaries */
    ulong 	changes;	/* change mask */
    uchar 	new_seq[16];	/* changes from last to current */
    uchar 	*cp;
    Hdr	*h;		/* last packet */
    int 	i, j;

    /*
     * Bail if this is not a compressible TCP/IP packet
     */
    ip = (Iphdr*)b->rptr;
    iplen = (ip->vihl & 0xf) << 2;
    tcp = (Tcphdr*)(b->rptr + iplen);
    tcplen = (tcp->flag[0] & 0xf0) >> 2;
    hlen = iplen + tcplen;
    if((tcp->flag[1] & (SYN|FIN|RST|ACK)) != ACK){
        *protop = Pip;
        return b;		/* connection control */
    }

    /*
     * Packet is compressible, look for a connection
     */
    changes = 0;
    cp = new_seq;
    j = comp->lastxmit;
    h = &comp->t[j];
    if(ip->src != h->ip->src || ip->dst != h->ip->dst
    || tcp->ports != h->tcp->ports) {
        for(i = 0; i < MAX_STATES; ++i) {
            j = (comp->basexmit + i) % MAX_STATES;
            h = &comp->t[j];
            if(ip->src == h->ip->src && ip->dst == h->ip->dst
            && tcp->ports == h->tcp->ports)
                goto found;
        }

        /* no connection, reuse the oldest */
        if(i == MAX_STATES) {
            j = comp->basexmit;
            j = (j + MAX_STATES - 1) % MAX_STATES;
            comp->basexmit = j;
            h = &comp->t[j];
            goto rescue;
        }
    }
found:

    /*
     * Make sure that only what we expect to change changed. 
     */
    if(ip->vihl  != h->ip->vihl || ip->tos   != h->ip->tos ||
       ip->ttl   != h->ip->ttl  || ip->proto != h->ip->proto)
        goto rescue;	/* headers changed */
    if(iplen != sizeof(Iphdr) && memcmp(ip+1, h->ip+1, iplen - sizeof(Iphdr)))
        goto rescue;	/* ip options changed */
    if(tcplen != sizeof(Tcphdr) && memcmp(tcp+1, h->tcp+1, tcplen - sizeof(Tcphdr)))
        goto rescue;	/* tcp options changed */

    if(tcp->flag[1] & URG) {
        cp += encode(cp, nhgets(tcp->urg));
        changes |= NEW_U;
    } else if(memcmp(tcp->urg, h->tcp->urg, sizeof(tcp->urg)) != 0)
        goto rescue;
    if(deltaS = nhgets(tcp->win) - nhgets(h->tcp->win)) {
        cp += encode(cp, deltaS);
        changes |= NEW_W;
    }
    if(deltaA = nhgetl(tcp->ack) - nhgetl(h->tcp->ack)) {
        if(deltaA > 0xffff)
            goto rescue;
        cp += encode(cp, deltaA);
        changes |= NEW_A;
    }
    if(deltaS = nhgetl(tcp->seq) - nhgetl(h->tcp->seq)) {
        if (deltaS > 0xffff)
            goto rescue;
        cp += encode(cp, deltaS);
        changes |= NEW_S;
    }

    /*
     * Look for the special-case encodings.
     */
    switch(changes) {
    case 0:
        /*
         * Nothing changed. If this packet contains data and the last
         * one didn't, this is probably a data packet following an
         * ack (normal on an interactive connection) and we send it
         * compressed. Otherwise it's probably a retransmit,
         * retransmitted ack or window probe.  Send it uncompressed
         * in case the other side missed the compressed version.
         */
        if(nhgets(ip->length) == nhgets(h->ip->length) ||
           nhgets(h->ip->length) != hlen)
            goto rescue;
        break;
    case SPECIAL_I:
    case SPECIAL_D:
        /*
         * Actual changes match one of our special case encodings --
         * send packet uncompressed.
         */
        goto rescue;
    case NEW_S | NEW_A:
        if (deltaS == deltaA &&
            deltaS == nhgets(h->ip->length) - hlen) {
            /* special case for echoed terminal traffic */
            changes = SPECIAL_I;
            cp = new_seq;
        }
        break;
    case NEW_S:
        if (deltaS == nhgets(h->ip->length) - hlen) {
            /* special case for data xfer */
            changes = SPECIAL_D;
            cp = new_seq;
        }
        break;
    }
    deltaS = nhgets(ip->id) - nhgets(h->ip->id);
    if(deltaS != 1) {
        cp += encode(cp, deltaS);
        changes |= NEW_I;
    }
    if (tcp->flag[1] & PSH)
        changes |= TCP_PUSH_BIT;
    /*
     * Grab the cksum before we overwrite it below. Then update our
     * state with this packet's header.
     */
    deltaA = nhgets(tcp->cksum);
    memmove(h->buf, b->rptr, hlen);
    h->len = hlen;
    h->tcp = (Tcphdr*)(h->buf + iplen);

    /*
     * We want to use the original packet as our compressed packet. (cp -
     * new_seq) is the number of uchars we need for compressed sequence
     * numbers. In addition we need one uchar for the change mask, one
     * for the connection id and two for the tcp checksum. So, (cp -
     * new_seq) + 4 uchars of header are needed. hlen is how many uchars
     * of the original packet to toss so subtract the two to get the new
     * packet size. The temporaries are gross -egs.
     */
    deltaS = cp - new_seq;
    cp = b->rptr;
    if(comp->lastxmit != j || comp->compressid == 0) {
        comp->lastxmit = j;
        hlen -= deltaS + 4;
        cp += hlen;
        *cp++ = (changes | NEW_C);
        *cp++ = j;
    } else {
        hlen -= deltaS + 3;
        cp += hlen;
        *cp++ = changes;
    }
    b->rptr += hlen;
    hnputs(cp, deltaA);
    cp += 2;
    memmove(cp, new_seq, deltaS);
    *protop = Pvjctcp;
    return b;

rescue:
    /*
     * Update connection state & send uncompressed packet
     */
    memmove(h->buf, b->rptr, hlen);
    h->tcp = (Tcphdr*)(h->buf + iplen);
    h->len = hlen;
    ip->proto = j;
    comp->lastxmit = j;
    *protop = Pvjutcp;
    return b;
}
@

<<function [[compress_init]]>>=
Tcpc*
compress_init(Tcpc *c)
{
    int i;
    Hdr *h;

    if(c == nil)
        c = malloc(sizeof(Tcpc));

    memset(c, 0, sizeof(*c));
    for(i = 0; i < MAX_STATES; i++){
        h = &c->t[i];
        h->ip = (Iphdr*)h->buf;
        h->tcp = (Tcphdr*)(h->buf + 20);
        h->len = 40;
        h = &c->r[i];
        h->ip = (Iphdr*)h->buf;
        h->tcp = (Tcphdr*)(h->buf + 20);
        h->len = 40;
    }

    return c;
}
@

<<function [[compress]]>>=
Block*
compress(Tcpc *tcp, Block *b, int *protop)
{
    Iphdr		*ip;

    /*
     * Bail if this is not a compressible IP packet
     */
    ip = (Iphdr*)b->rptr;
    if((nhgets(ip->frag) & 0x3fff) != 0){
        *protop = Pip;
        return b;
    }

    switch(ip->proto) {
    case IP_TCPPROTO:
        return tcpcompress(tcp, b, protop);
    default:
        *protop = Pip;
        return b;
    }
}
@

<<function [[compress_negotiate]]>>=
int
compress_negotiate(Tcpc *tcp, uchar *data)
{
    if(data[0] != MAX_STATES - 1)
        return -1;
    tcp->compressid = data[1];
    return 0;
}
@

<<function [[compress_error]]>>=
/* called by ppp when there was a bad frame received */
void
compress_error(Tcpc *tcp)
{
    tcp->err = 1;
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/compress.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <auth.h>
#include "ppp.h"

typedef struct Iphdr Iphdr;
<<struct [[Iphdr]]([[(networking/ip/ppp/compress.c)]])>>

typedef struct Tcphdr Tcphdr;
<<struct [[Tcphdr]]>>

typedef struct Ilhdr Ilhdr;
<<struct [[Ilhdr]]([[(networking/ip/ppp/compress.c)]])>>

<<enum [[_anon_ (networking/ip/ppp/compress.c)]]>>

typedef struct Hdr Hdr;
<<struct [[Hdr]]([[(networking/ip/ppp/compress.c)]])>>

typedef struct Tcpc Tcpc;
<<struct [[Tcpc]]>>

<<enum [[_anon_ (networking/ip/ppp/compress.c)2]]>>

<<constant [[SPECIAL_I]]>>
<<constant [[SPECIAL_D]]>>
<<constant [[SPECIALS_MASK]]>>

<<function [[encode]]>>

<<macro [[DECODEL]]>>
<<macro [[DECODES]]>>

<<function [[tcpcompress]]>>

Block*
tcpuncompress(Tcpc *comp, Block *b, int type)
{
    uchar	*cp, changes;
    int	i;
    int	iplen, len;
    Iphdr	*ip;
    Tcphdr	*tcp;
    Hdr	*h;

    if(type == Pvjutcp) {
        /*
         *  Locate the saved state for this connection. If the state
         *  index is legal, clear the 'discard' flag.
         */
        ip = (Iphdr*)b->rptr;
        if(ip->proto >= MAX_STATES)
            goto rescue;
        iplen = (ip->vihl & 0xf) << 2;
        tcp = (Tcphdr*)(b->rptr + iplen);
        comp->lastrecv = ip->proto;
        len = iplen + ((tcp->flag[0] & 0xf0) >> 2);
        comp->err = 0;
        /*
         * Restore the IP protocol field then save a copy of this
         * packet header. The checksum is zeroed in the copy so we
         * don't have to zero it each time we process a compressed
         * packet.
         */
        ip->proto = IP_TCPPROTO;
        h = &comp->r[comp->lastrecv];
        memmove(h->buf, b->rptr, len);
        h->tcp = (Tcphdr*)(h->buf + iplen);
        h->len = len;
        h->ip->cksum[0] = h->ip->cksum[1] = 0;
        return b;
    }

    cp = b->rptr;
    changes = *cp++;
    if(changes & NEW_C) {
        /*
         * Make sure the state index is in range, then grab the
         * state. If we have a good state index, clear the 'discard'
         * flag.
         */
        if(*cp >= MAX_STATES)
            goto rescue;
        comp->err = 0;
        comp->lastrecv = *cp++;
    } else {
        /*
         * This packet has no state index. If we've had a
         * line error since the last time we got an explicit state
         * index, we have to toss the packet.
         */
        if(comp->err != 0){
            freeb(b);
            return nil;
        }
    }

    /*
     * Find the state then fill in the TCP checksum and PUSH bit.
     */
    h = &comp->r[comp->lastrecv];
    ip = h->ip;
    tcp = h->tcp;
    len = h->len;
    memmove(tcp->cksum, cp, sizeof tcp->cksum);
    cp += 2;
    if(changes & TCP_PUSH_BIT)
        tcp->flag[1] |= PSH;
    else
        tcp->flag[1] &= ~PSH;
    /*
     * Fix up the state's ack, seq, urg and win fields based on the
     * changemask.
     */
    switch (changes & SPECIALS_MASK) {
    case SPECIAL_I:
        i = nhgets(ip->length) - len;
        hnputl(tcp->ack, nhgetl(tcp->ack) + i);
        hnputl(tcp->seq, nhgetl(tcp->seq) + i);
        break;

    case SPECIAL_D:
        hnputl(tcp->seq, nhgetl(tcp->seq) + nhgets(ip->length) - len);
        break;

    default:
        if(changes & NEW_U) {
            tcp->flag[1] |= URG;
            if(*cp == 0){
                hnputs(tcp->urg, nhgets(cp+1));
                cp += 3;
            }else
                hnputs(tcp->urg, *cp++);
        } else
            tcp->flag[1] &= ~URG;
        if(changes & NEW_W)
            DECODES(tcp->win)
        if(changes & NEW_A)
            DECODEL(tcp->ack)
        if(changes & NEW_S)
            DECODEL(tcp->seq)
        break;
    }

    /* Update the IP ID */
    if(changes & NEW_I)
        DECODES(ip->id)
    else
        hnputs(ip->id, nhgets(ip->id) + 1);

    /*
     *  At this point, cp points to the first uchar of data in the packet.
     *  Back up cp by the TCP/IP header length to make room for the
     *  reconstructed header.
     *  We assume the packet we were handed has enough space to prepend
     *  up to 128 uchars of header.
     */
    b->rptr = cp;
    if(b->rptr - b->base < len){
        b = padb(b, len);
        b = pullup(b, blen(b));
    } else
        b->rptr -= len;
    hnputs(ip->length, BLEN(b));
    memmove(b->rptr, ip, len);
    
    /* recompute the ip header checksum */
    ip = (Iphdr*)b->rptr;
    ip->cksum[0] = ip->cksum[1] = 0;
    hnputs(ip->cksum, ipcsum(b->rptr));

    return b;

rescue:
    netlog("ppp: vj: Bad Packet!\n");
    comp->err = 1;
    freeb(b);
    return nil;
}

<<function [[compress_init]]>>

<<function [[compress]]>>

<<function [[compress_negotiate]]>>

<<function [[compress_error]]>>
@


\subsection*{[[networking/ip/ppp/ipaux.c]]}

<<global [[endian]]([[(networking/ip/ppp/ipaux.c)]])>>=
static	ushort	endian	= 1;
@

<<global [[aendian]]([[(networking/ip/ppp/ipaux.c)]])>>=
static	uchar*	aendian	= (uchar*)&endian;
@

<<constant [[LITTLE]]([[(networking/ip/ppp/ipaux.c)]])>>=
#define	LITTLE	*aendian
@

<<function [[ptclbsum]]([[(networking/ip/ppp/ipaux.c)]])>>=
ushort
ptclbsum(uchar *addr, int len)
{
    ulong losum, hisum, mdsum, x;
    ulong t1, t2;

    losum = 0;
    hisum = 0;
    mdsum = 0;

    x = 0;
    if((uintptr)addr & 1) {
        if(len) {
            hisum += addr[0];
            len--;
            addr++;
        }
        x = 1;
    }
    while(len >= 16) {
        t1 = *(ushort*)(addr+0);
        t2 = *(ushort*)(addr+2);	mdsum += t1;
        t1 = *(ushort*)(addr+4);	mdsum += t2;
        t2 = *(ushort*)(addr+6);	mdsum += t1;
        t1 = *(ushort*)(addr+8);	mdsum += t2;
        t2 = *(ushort*)(addr+10);	mdsum += t1;
        t1 = *(ushort*)(addr+12);	mdsum += t2;
        t2 = *(ushort*)(addr+14);	mdsum += t1;
        mdsum += t2;
        len -= 16;
        addr += 16;
    }
    while(len >= 2) {
        mdsum += *(ushort*)addr;
        len -= 2;
        addr += 2;
    }
    if(x) {
        if(len)
            losum += addr[0];
        if(LITTLE)
            losum += mdsum;
        else
            hisum += mdsum;
    } else {
        if(len)
            hisum += addr[0];
        if(LITTLE)
            hisum += mdsum;
        else
            losum += mdsum;
    }

    losum += hisum >> 8;
    losum += (hisum & 0xff) << 8;
    while(hisum = losum>>16)
        losum = hisum + (losum & 0xffff);

    return losum & 0xffff;
}
@

<<function [[ptclcsum]]([[(networking/ip/ppp/ipaux.c)]])>>=
ushort
ptclcsum(Block *bp, int offset, int len)
{
    uchar *addr;
    ulong losum, hisum;
    ushort csum;
    int odd, blen, x;

    /* Correct to front of data area */
    while(bp != nil && offset && offset >= BLEN(bp)) {
        offset -= BLEN(bp);
        bp = bp->next;
    }
    if(bp == nil)
        return 0;

    addr = bp->rptr + offset;
    blen = BLEN(bp) - offset;

    if(bp->next == nil) {
        if(blen < len)
            len = blen;
        return ~ptclbsum(addr, len) & 0xffff;
    }

    losum = 0;
    hisum = 0;

    odd = 0;
    while(len) {
        x = blen;
        if(len < x)
            x = len;

        csum = ptclbsum(addr, x);
        if(odd)
            hisum += csum;
        else
            losum += csum;
        odd = (odd+x) & 1;
        len -= x;

        bp = bp->next;
        if(bp == nil)
            break;
        blen = BLEN(bp);
        addr = bp->rptr;
    }

    losum += hisum>>8;
    losum += (hisum&0xff)<<8;
    while((csum = losum>>16) != 0)
        losum = csum + (losum & 0xffff);

    return ~losum & 0xffff;
}
@

<<function [[ipcsum]]([[(networking/ip/ppp/ipaux.c)]])>>=
ushort
ipcsum(uchar *addr)
{
    int len;
    ulong sum;

    sum = 0;
    len = (addr[0]&0xf)<<2;

    while(len > 0) {
        sum += (addr[0]<<8) | addr[1] ;
        len -= 2;
        addr += 2;
    }

    sum = (sum & 0xffff) + (sum >> 16);
    sum = (sum & 0xffff) + (sum >> 16);

    return (sum^0xffff);
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/ipaux.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <auth.h>
#include "ppp.h"

<<global [[endian]]([[(networking/ip/ppp/ipaux.c)]])>>
<<global [[aendian]]([[(networking/ip/ppp/ipaux.c)]])>>
<<constant [[LITTLE]]([[(networking/ip/ppp/ipaux.c)]])>>

<<function [[ptclbsum]]([[(networking/ip/ppp/ipaux.c)]])>>

<<function [[ptclcsum]]([[(networking/ip/ppp/ipaux.c)]])>>

<<function [[ipcsum]]([[(networking/ip/ppp/ipaux.c)]])>>
@


\subsection*{[[networking/ip/ppp/mppc.c]]}

<<enum [[_anon_ (networking/ip/ppp/mppc.c)]]>>=
enum {
    HistorySize=	8*1024,
    Cminmatch	= 3,		/* sintest match possible */
    Chshift		= 4,		/* nice compromise between space & time */
    Cnhash		= 1<<(Chshift*Cminmatch),
    HMASK		= Cnhash-1,
};
@

<<struct [[Carena]]>>=
struct Carena
{
    uchar	*pos;			/* current place, also amount of history filled */
    uchar	buf[HistorySize];
};
@

<<struct [[Cstate]]>>=
struct Cstate
{
    QLock;
    int	count;
    int	reset;		/* compressor has been reset */
    int	front;		/* move to begining of history */
    ulong	sreg;		/* output shift reg */
    int	bits;		/* number of bits in sreg */
    Block	*b; 		/* output block */

    /*
     * state for hashing compressor
     */
    Carena	arenas[2];
    Carena	*hist;
    Carena	*ohist;
    ulong	hash[Cnhash];
    int	h;
    ulong	me;
    ulong	split;

    int	encrypt;
    uchar	startkey[16];
    uchar	key[16];
    RC4state rc4key;
};
@

<<struct [[Uncstate]]>>=
struct Uncstate
{
    int	count;	 	/* packet count - detects missing packets */
    int	resetid;	/* id of reset requests */
    uchar	his[HistorySize];
    int	indx;		/* current indx in history */
    int	size;		/* current history size */
    uchar	startkey[16];
    uchar	key[16];
    RC4state rc4key;
};
@

<<enum [[_anon_ (networking/ip/ppp/mppc.c)2]]>>=
/* packet flags */
enum {
    Preset=		(1<<15),	/* reset history */
    Pfront=		(1<<14),	/* move packet to front of history */
    Pcompress=	(1<<13),	/* packet is compressed */
    Pencrypt=	(1<<12),	/* packet is encrypted */
};
@

<<enum [[_anon_ (networking/ip/ppp/mppc.c)3]]>>=
enum {
    Lit7,		/* seven bit literal */
    Lit8,		/* eight bit literal */
    Off6,		/* six bit offset */
    Off8,		/* eight bit offset */
    Off13,		/* thirteen bit offset */
};
@

<<global [[decode]]>>=
/* decode first four bits */
int decode[16] = {
    Lit7,	
    Lit7,
    Lit7,
    Lit7,
    Lit7,
    Lit7,
    Lit7,
    Lit7,
    Lit8,
    Lit8,	
    Lit8,
    Lit8,	
    Off13,
    Off13,
    Off8,
    Off6,
};
@

<<global [[cmppc]]>>=
Comptype cmppc = {
    compinit,
    comp,
    compresetreq,
    compfini
};
@

<<global [[uncmppc]]>>=
Uncomptype uncmppc = {
    uncinit,
    uncomp,
    uncresetack,
    uncfini
};
@

<<function [[compinit]]>>=
static void *
compinit(PPP *ppp)
{
    Cstate *cs;

    cs = mallocz(sizeof(Cstate), 1);
    cs->hist = &cs->arenas[0];
    cs->ohist = &cs->arenas[1];
    compreset(cs);
    /*
     * make reset clear the hash table
     */
    cs->me = ~0;
    compreset(cs);

    cs->reset = 0;

    if(ppp->sendencrypted) {
        cs->encrypt = 1;
        memmove(cs->startkey, ppp->key, 16);
        memmove(cs->key, ppp->key, 16);
        setkey(cs->key, cs->startkey);
        setupRC4state(&cs->rc4key, cs->key, 16);
    }

    return cs;
}
@

<<function [[compfini]]>>=
static void
compfini(void *as)
{
    Cstate *cs;

    cs = as;
    free(cs);
}
@

<<function [[comp]]>>=
static Block*
comp(PPP *ppp, ushort proto, Block *b, int *protop)
{
    Cstate *s;
    int n, n2;
    ushort count;

    s = ppp->cstate;
    *protop = 0;

    qlock(s);

    /* put protocol into b */
    b->rptr -= 2;
    if(b->rptr < b->base)
        sysfatal("mppc: not enough header in block");
    b->rptr[0] = proto>>8;
    b->rptr[1] = proto;

    n = BLEN(b);
    s->bits = 0;
    s->b = allocb(n*9/8+20);
    s->b->wptr += 2;	/* leave room for mppc header */

    comp2(s, b->rptr, n);
        
    /* flush sreg */
    if(s->bits)
        *s->b->wptr++ = s->sreg<<(8-s->bits);
    if(s->b->wptr > s->b->lim)
        sysfatal("mppc: comp: output block overflowed");

    n2 = BLEN(s->b);

    if(n2 > n-2 && !s->encrypt) {
        /* expened and not excrypting so send as a regular packet */
//netlog("mppc: comp: expanded\n"); 
        compreset(s);
        freeb(s->b);
        b->rptr += 2;
        qunlock(s);
        *protop = proto;
        return b;
    }

    count = s->count++;
    s->count &= 0xfff;
    if(s->front)
        count |= Pfront;
    if(s->reset)
        count |= Preset;
    s->reset = 0;
    s->front = 0;

    if(n2 > n) {
//netlog("mppc: comp: expanded\n"); 
        freeb(s->b);
        /* make room for count */
        compreset(s);
        b->rptr -= 2;
    } else {
        freeb(b);
        b = s->b;
        count |= Pcompress;
    }
    s->b = nil;

    if(s->encrypt) {
        count |= Pencrypt;
        if((count&0xff) == 0xff) {
//netlog("mppc: comp: changing key\n"); 
            setkey(s->key, s->startkey);
            setupRC4state(&s->rc4key, s->key, 16);
            rc4(&s->rc4key, s->key, 16);
            setupRC4state(&s->rc4key, s->key, 16);
        } else if(count&Preset)
            setupRC4state(&s->rc4key, s->key, 16);
        rc4(&s->rc4key, b->rptr+2, BLEN(b)-2);
//netlog("mppc: encrypt %ux\n", count);
    }

    b->rptr[0] = count>>8;
    b->rptr[1] = count;
    
    qunlock(s);

    *protop = Pcdata;
    return b;
}
@

<<function [[compresetreq]]>>=
static Block *
compresetreq(void *as, Block *b)
{
    Cstate *cs;

    cs = as;
netlog("mppc: comp: reset request\n");
    qlock(cs);
    compreset(cs);
    qunlock(cs);

    freeb(b);

    return nil;
}
@

<<function [[comp2]]>>=
static void
comp2(Cstate *cs, uchar *p, int n)
{
    Carena *hist, *ohist;
    ulong *hash, me, split, you, last;
    uchar *s, *t, *et, *buf, *obuf, *pos, *opos;
    int i, h, m;

    /*
     * check for wrap
     */
    if(cs->me + n < cs->me)
        compreset(cs);

    if(cs->hist->pos + n > cs->hist->buf + HistorySize)
        compfront(cs);

    hist = cs->hist;
    ohist = cs->ohist;

    hash = cs->hash;
    me = cs->me;
    split = cs->split;

    memmove(hist->pos, p, n);
    p = hist->pos;
    hist->pos = pos = p + n;

    m = Cminmatch;
    if(m > n)
        m = n;
    h = cs->h;
    for(i = 0; i < m; i++) {
        h = (((h)<<Chshift) ^ p[i]) & HMASK;
        last = me + (i - (Cminmatch-1));
        if(last >= split && last != me)
            hash[h] = last;
    }

    buf = hist->buf - split;
    obuf = ohist->buf + HistorySize - split;
    opos = ohist->pos;
    while(p < pos) {
        you = hash[h];
        if(you < split) {
            if(me - you >= HistorySize)
                t = opos;
            else
                t = obuf + you;
            et = opos;
        } else {
            t = buf + you;
            et = pos;
        }
        m = pos - p;
        if(m < et - t)
            et = t + m;
        for(s = p; t < et; t++) {
            if(*s != *t)
                break;
            s++;
        }
        m = s - p;
        if(m < Cminmatch) {
            complit(cs, *p);
            s = p + 1;
        } else
            compcopy(cs, me - you, m);

        for(; p != s; p++) {
            if(p + Cminmatch <= pos) {
                hash[h] = me;
                if(p + Cminmatch < pos)
                    h = (((h)<<Chshift) ^ p[Cminmatch]) & HMASK;
            }
            me++;
        }
    }

    cs->h = h;
    cs->me = me;
}
@

<<function [[compfront]]>>=
static void
compfront(Cstate *cs)
{
    Carena *th;

    cs->front = 1;

    th = cs->ohist;
    cs->ohist = cs->hist;
    cs->hist = th;
    cs->hist->pos = cs->hist->buf;
    cs->h = 0;
    cs->me = cs->split + HistorySize;
    cs->split = cs->me;
}
@

<<function [[compreset]]>>=
static void
compreset(Cstate *cs)
{
    ulong me;

    cs->reset = 1;

    me = cs->me;
    if(me + 2 * HistorySize < me){
        me = 0;
        memset(cs->hash, 0, sizeof(cs->hash));
    }
    cs->me = me + 2 * HistorySize;
    cs->split = cs->me;
    cs->hist->pos = cs->hist->buf;
    cs->ohist->pos = cs->ohist->buf;
}
@

<<function [[complit]]>>=
static void
complit(Cstate *s, int c)
{
    if(c&0x80)
        compout(s, 0x100|(c&0x7f), 9);
    else
        compout(s, c, 8);
}
@

<<function [[compcopy]]>>=
static void
compcopy(Cstate *s, int off, int len)
{
    int i;
    ulong mask;

    if(off<64)
        compout(s, 0x3c0|off, 10);
    else if(off<320)
        compout(s, 0xe00|(off-64), 12);
    else
        compout(s, 0xc000|(off-320), 16);
    if(len < 3)
        sysfatal("compcopy: bad len: %d", len);
    if(len == 3)
        compout(s, 0, 1);
    else {
        for(i=3; (1<<i) <= len; i++)
            ;
        mask = (1<<(i-1))-1;
        compout(s, (((1<<(i-2))-1)<<i) | len&mask, (i-1)<<1);
    }
}
@

<<function [[compout]]>>=
static void
compout(Cstate *s, ulong data, int bits)
{
    ulong sreg;

    sreg = s->sreg;
    sreg <<= bits;
    sreg |= data;
    bits += s->bits;
    while(bits >= 8) {
        *s->b->wptr++ = sreg>>(bits-8);
        bits -= 8;
    }
    s->sreg = sreg;
    s->bits = bits;
}
@

<<function [[printkey]]>>=
void
printkey(uchar *key)
{
    char buf[200], *p;
    int i;

    p = buf;
    for(i=0; i<16; i++)
        p += sprint(p, "%.2ux ", key[i]);
//netlog("key = %s\n", buf);
}
@

<<function [[uncinit]]>>=
static	void *
uncinit(PPP *ppp)
{
    Uncstate *s;

    s = mallocz(sizeof(Uncstate), 1);

    s->count = 0xfff;	/* count of non existant last packet */
    memmove(s->startkey, ppp->key, 16);
    memmove(s->key, ppp->key, 16);
    setkey(s->key, s->startkey);
    setupRC4state(&s->rc4key, s->key, 16);

    return s;
}
@

<<function [[uncomp]]>>=
static	Block*
uncomp(PPP *ppp, Block *b, int *protop, Block **r)
{
    Uncstate *s;
    ushort proto;
    ushort count;
    Lcpmsg *m;

    *r = nil;
    *protop = 0;
    s = ppp->uncstate;
    if(BLEN(b) < 2){
        syslog(0, "ppp", ": mppc: short packet\n");
        freeb(b);
        return nil;
    }
    count = nhgets(b->rptr);
    b->rptr += 2;

    b = uncomp2(s, b, count);

    if(b == nil) {
//netlog("ppp: mppc: reset request\n");
        /* return reset request packet */
        *r = alloclcp(Lresetreq, s->resetid++, 4, &m);
        hnputs(m->len, 4);
        *protop = 0;
        return nil;
    }

    if(BLEN(b) < 2){
        syslog(0, "ppp", ": mppc: short packet\n");
        freeb(b);
        *protop = 0;
        return nil;
    }
    proto = nhgets(b->rptr);
    b->rptr += 2;

/*
    if(proto == 0x21)
        if(!ipcheck(b->rptr, BLEN(b)))
            hischeck(s);
*/

    *protop = proto;
    return b;
}
@

<<global [[maxoff]]>>=
int	maxoff;
@

<<function [[uncomp2]]>>=
static	Block*
uncomp2(Uncstate *s, Block *b, ushort count)
{
    int ecount, n, bits, off, len, ones;
    ulong sreg;
    int t;
    uchar *p, c, *hp, *hs, *he, *hq;

    if(count&Preset) {
//netlog("mppc reset\n");
        s->indx = 0;
        s->size = 0;
        setupRC4state(&s->rc4key, s->key, 16);
    } else {
        ecount = (s->count+1)&0xfff;
        if((count&0xfff) != ecount) {
netlog("******* bad count - got %ux expected %ux\n", count&0xfff, ecount);
            freeb(b);
            return nil;
        }
        if(count&Pfront) {
            s->indx = 0;
/*			netlog("ppp: mppc: frount flag set\n"); */
        }
    }

    /* update key */
    n = (((count+1)>>8)&0xf) - (((s->count+1)>>8)&0xf);
    if(n < 0)
        n += 16;
//netlog("mppc count = %ux oldcount %ux n = %d\n", count, s->count, n);
    if(n < 0 || n > 1) {
        syslog(0, "ppp", ": mppc bad count %ux, %ux", count, s->count);
        freeb(b);
        return nil;
    }
    if(n == 1) {
        setkey(s->key, s->startkey);
        setupRC4state(&s->rc4key, s->key, 16);
        rc4(&s->rc4key, s->key, 16);
        setupRC4state(&s->rc4key, s->key, 16);
    }
    
    s->count = count;

    n = BLEN(b);
    p = b->rptr;
    if(count & Pencrypt) {
//netlog("mppc unencrypt count = %ux\n", count);
        rc4(&s->rc4key, p, n);
    }

    if(!(count & Pcompress)) {
//netlog("uncompress blen = %d\n", BLEN(b));
        return  b;
    }

    bits = 0;
    sreg = 0;
    hs = s->his;		/* history start */
    hp = hs+s->indx;	/* write pointer in history */
    he = hs+sizeof(s->his);	/* hsitory end */
    for(;;) {
        if(bits<4) {
            if(n==0) goto Done;
            NEXTBYTE;
        }
        t = decode[(sreg>>(bits-4))&0xf];
        switch(t) {
        default:
            sysfatal("mppc: bad decode!");
        case Lit7:
            bits -= 1;
            if(bits<7) {
                if(n==0) goto Done;
                NEXTBYTE;
            }
            c = (sreg>>(bits-7))&0x7f;
            bits -= 7;
            if(hp >= he) goto His;
            *hp++ = c;
/* netlog("\tlit7 %.2ux\n", c); */
            continue;
        case Lit8:
            bits -= 2;
            if(bits<7) {
                if(n==0) goto Eof;
                NEXTBYTE;
            }
            c = 0x80 | ((sreg>>(bits-7))&0x7f);
            bits -= 7;
            if(hp >= he) goto His;
            *hp++ = c;
/* netlog("\tlit8 %.2ux\n", c); */
            continue;
        case Off6:
            bits -= 4;
            if(bits<6) {
                if(n==0) goto Eof;
                NEXTBYTE;
            }
            off = (sreg>>(bits-6))&0x3f;
            bits -= 6;
            break;
        case Off8:
            bits -= 4;
            if(bits<8) {
                if(n==0) goto Eof;
                NEXTBYTE;
            }
            off = ((sreg>>(bits-8))&0xff)+64;
            bits -= 8;
            break;
        case Off13:
            bits -= 3;
            while(bits<13) {
                if(n==0) goto Eof;
                NEXTBYTE;
            }
            off = ((sreg>>(bits-13))&0x1fff)+320;
            bits -= 13;
/* netlog("\toff=%d bits = %d sreg = %ux t = %x\n", off, bits, sreg, t); */
            break;
        }
        for(ones=0;;ones++) {
            if(bits == 0) {
                if(n==0) goto Eof;
                NEXTBYTE;
            }
            bits--;
            if(!(sreg&(1<<bits)))
                break;
        }
        if(ones>11) {
netlog("ppp: mppc: bad length %d\n", ones);
            freeb(b);
            return nil;
        }
        if(ones == 0) {
            len = 3;
        } else {
            ones++;
            while(bits<ones) {
                if(n==0) goto Eof;
                NEXTBYTE;
            }
            len = (1<<ones) | ((sreg>>(bits-ones))&((1<<ones)-1));
            bits -= ones;
        }

        hq = hp-off;
        if(hq < hs) {
            hq += sizeof(s->his);
            if(hq-hs+len > s->size) 
                goto His;
        }
        if(hp+len > he) goto His;
        while(len) {
            *hp++ = *hq++;
            len--;
        }
    }
Done:
    freeb(b);

    /* build up return block */
    hq = hs+s->indx;
    len = hp-hq;
    b = allocb(len);
    memmove(b->wptr, hq, len);
    b->wptr += len;
netlog("ppp: mppc: len %d bits = %d n=%d\n", len, bits, n);
    
    s->indx += len;
    if(s->indx > s->size)
        s->size = s->indx;
    
    return b;
Eof:
netlog("*****unexpected end of data\n");
    freeb(b);
    return nil;
His:
netlog("*****bad history\n");
    freeb(b);
    return nil;
}
@

<<function [[uncresetack]]>>=
static	void
uncresetack(void*, Block*)
{
}
@

<<function [[uncfini]]>>=
static	void
uncfini(void *as)
{
    Uncstate *s;
    
    s = as;	
    free(s);
}
@

<<function [[setkey]]>>=
static void
setkey(uchar *key, uchar *startkey)
{
    uchar pad[40];
    SHAstate *s;
    uchar digest[SHA1dlen];

    s = sha1(startkey, 16, nil, nil);
    memset(pad, 0, 40);
    sha1(pad, 40, nil, s);
    sha1(key, 16, nil, s);
    memset(pad, 0xf2, 40);
    sha1(pad, 40, digest, s);
    memmove(key, digest, 16);
}
@

<<struct [[Iphdr]]([[(networking/ip/ppp/mppc.c)]])>>=
struct Iphdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* Ip source */
    uchar	dst[4];		/* Ip destination */
};
@

<<enum [[_anon_ (networking/ip/ppp/mppc.c)4]]>>=
enum
{
    QMAX		= 64*1024-1,
    IP_TCPPROTO	= 6,
    TCP_IPLEN	= 8,
    TCP_PHDRSIZE	= 12,
    TCP_HDRSIZE	= 20,
    TCP_PKT		= TCP_IPLEN+TCP_PHDRSIZE,
};
@

<<enum [[_anon_ (networking/ip/ppp/mppc.c)5]]>>=
enum
{
    UDP_PHDRSIZE	= 12,
    UDP_HDRSIZE	= 20,
    UDP_IPHDR	= 8,
    IP_UDPPROTO	= 17,
    UDP_USEAD	= 12,
    UDP_RELSIZE	= 16,

    Udprxms		= 200,
    Udptickms	= 100,
    Udpmaxxmit	= 10,
};
@

<<struct [[UDPhdr]]>>=
struct UDPhdr
{
    /* ip header */
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	Unused;	
    uchar	udpproto;	/* Protocol */
    uchar	udpplen[2];	/* Header plus data length */
    uchar	udpsrc[4];	/* Ip source */
    uchar	udpdst[4];	/* Ip destination */

    /* udp header */
    uchar	udpsport[2];	/* Source port */
    uchar	udpdport[2];	/* Destination port */
    uchar	udplen[2];	/* data length */
    uchar	udpcksum[2];	/* Checksum */
};
@

<<struct [[TCPhdr]]>>=
struct TCPhdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	Unused;
    uchar	proto;
    uchar	tcplen[2];
    uchar	tcpsrc[4];
    uchar	tcpdst[4];
    uchar	tcpsport[2];
    uchar	tcpdport[2];
    uchar	tcpseq[4];
    uchar	tcpack[4];
    uchar	tcpflag[2];
    uchar	tcpwin[2];
    uchar	tcpcksum[2];
    uchar	tcpurg[2];
    /* Options segment */
    uchar	tcpopt[2];
    uchar	tcpmss[2];
};
@

<<function [[hischeck]]>>=
static void
hischeck(Uncstate *s)
{
    uchar *p;
    Iphdr *iph;
    int len;

    p = s->his;

netlog("***** history check\n");
    while(p < s->his+s->size) {
        if(p[0] != 0 || p[1] != 0x21) {
netlog("***** unknown protocol\n");
            return;
        }
        p += 2;
netlog("off = %ld ", p-s->his);
        iph = (Iphdr*)p;
        len = nhgets(iph->length);
        ipcheck(p, len);
        p += len;
    }
}
@

<<function [[ipcheck]]>>=
static int
ipcheck(uchar *p, int len)
{
    Iphdr *iph;
    TCPhdr *tcph;
    ushort length;
    UDPhdr *uh;
    Block *bp;
    ushort cksum;
    int good;

    bp = allocb(len);
    memmove(bp->wptr, p, len);
    bp->wptr += len;

    good = 1;

    iph = (Iphdr *)(bp->rptr);
/* netlog("ppp: mppc: ipcheck %I %I len %d proto %d\n", iph->src, iph->dst, BLEN(bp), iph->proto); */

    if(len != nhgets(iph->length)) {
        netlog("***** bad length! %d %d\n", len, nhgets(iph->length));
        good = 0;
    }

    cksum = ipcsum(&iph->vihl);
    if(cksum) {
        netlog("***** IP proto cksum!!! %I %ux\n", iph->src, cksum);
        good = 0;
    }

    switch(iph->proto) {
    default:
        break;
    case IP_TCPPROTO:

        tcph = (TCPhdr*)(bp->rptr);

        length = nhgets(tcph->length);

        tcph->Unused = 0;
        hnputs(tcph->tcplen, length-TCP_PKT);
        cksum = ptclcsum(bp, TCP_IPLEN, length-TCP_IPLEN);
        if(cksum) {
            netlog("***** bad tcp proto cksum %ux!!!\n", cksum);
            good = 0;
        }
        break;
    case IP_UDPPROTO:
        uh = (UDPhdr*)(bp->rptr);

        /* Put back pseudo header for checksum */
        uh->Unused = 0;
        len = nhgets(uh->udplen);
        hnputs(uh->udpplen, len);

        if(nhgets(uh->udpcksum)) {
            cksum = ptclcsum(bp, UDP_IPHDR, len+UDP_PHDRSIZE);
            if(cksum) {
                netlog("***** udp: proto cksum!!! %I %ux\n", uh->udpsrc, cksum);
                good = 0;
            }
        }
        break;
    }
    freeb(bp);
    return good;
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/mppc.c>>=
#include <u.h>
#include <libc.h>
#include <libsec.h>
#include <ip.h>
#include <auth.h>
#include "ppp.h"

<<enum [[_anon_ (networking/ip/ppp/mppc.c)]]>>

typedef struct Carena Carena;
<<struct [[Carena]]>>

typedef struct Cstate Cstate;
<<struct [[Cstate]]>>

typedef struct Uncstate Uncstate;
<<struct [[Uncstate]]>>

<<enum [[_anon_ (networking/ip/ppp/mppc.c)2]]>>

<<enum [[_anon_ (networking/ip/ppp/mppc.c)3]]>>

<<global [[decode]]>>
    

static	void		*compinit(PPP*);
static	Block*		comp(PPP*, ushort, Block*, int*);
static	void		comp2(Cstate*, uchar*, int);
static	Block		*compresetreq(void*, Block*);
static	void		compfini(void*);
static	void		complit(Cstate*, int);
static	void		compcopy(Cstate*, int, int);
static	void		compout(Cstate*, ulong, int);
static	void		compfront(Cstate*);
static	void		hashcheck(Cstate*);
static	void		compreset(Cstate*);
static	int		hashit(uchar*);


static	void		*uncinit(PPP*);
static	Block*		uncomp(PPP*, Block*, int *protop, Block**);
static	Block		*uncomp2(Uncstate *s, Block*, ushort);
static	void		uncfini(void*);
static	void		uncresetack(void*, Block*);
static  int		ipcheck(uchar*, int);
static  void		hischeck(Uncstate*);

static	void		setkey(uchar *key, uchar *startkey);

<<global [[cmppc]]>>

<<global [[uncmppc]]>>

<<function [[compinit]]>>

<<function [[compfini]]>>


<<function [[comp]]>>

<<function [[compresetreq]]>>

<<function [[comp2]]>>

<<function [[compfront]]>>

<<function [[compreset]]>>

<<function [[complit]]>>

<<function [[compcopy]]>>

<<function [[compout]]>>

<<function [[printkey]]>>

<<function [[uncinit]]>>

<<function [[uncomp]]>>

#define NEXTBYTE	sreg = (sreg<<8) | *p++; n--; bits += 8
<<global [[maxoff]]>>
    
<<function [[uncomp2]]>>

<<function [[uncresetack]]>>

<<function [[uncfini]]>>

<<function [[setkey]]>>


/* code to check if IP packet looks good */

typedef struct Iphdr Iphdr;
<<struct [[Iphdr]]([[(networking/ip/ppp/mppc.c)]])>>

<<enum [[_anon_ (networking/ip/ppp/mppc.c)4]]>>

<<enum [[_anon_ (networking/ip/ppp/mppc.c)5]]>>

typedef struct UDPhdr UDPhdr;
<<struct [[UDPhdr]]>>

typedef struct TCPhdr TCPhdr;
<<struct [[TCPhdr]]>>

<<function [[hischeck]]>>


<<function [[ipcheck]]>>
@


\subsection*{[[networking/ip/ppp/ppp.c]]}

<<constant [[PATH]]>>=
#define PATH 128
@

<<global [[baud]]([[(networking/ip/ppp/ppp.c)]])>>=
static	int	baud;
@

<<global [[nocompress]]>>=
static	int	nocompress;
@

<<global [[pppframing]]>>=
static 	int	pppframing = 1;
@

<<global [[noipcompress]]>>=
static	int	noipcompress;
@

<<global [[server]]([[(networking/ip/ppp/ppp.c)]])>>=
static	int	server;
@

<<global [[noauth]]>>=
static	int noauth;
@

<<global [[nip]]([[(networking/ip/ppp/ppp.c)]])>>=
static	int	nip;		/* number of ip interfaces */
@

<<global [[dying]]([[(networking/ip/ppp/ppp.c)]])>>=
static	int	dying;		/* flag to signal to all threads its time to go */
@

<<global [[primary]]>>=
static	int	primary;	/* this is the primary IP interface */
@

<<global [[chatfile]]>>=
static	char	*chatfile;
@

<<global [[debug]]([[(networking/ip/ppp/ppp.c)]])>>=
int	debug;
@

<<global [[LOG]]>>=
char*	LOG = "ppp";
@

<<global [[keyspec]]([[(networking/ip/ppp/ppp.c)]])>>=
char*	keyspec = "";
@

<<enum [[_anon_ (networking/ip/ppp/ppp.c)]]>>=
enum
{
    Rmagic=	0x12345
};
@

<<global [[fcstab]]([[(networking/ip/ppp/ppp.c)]])>>=
/*
 * Calculate FCS - rfc 1331
 */
ushort fcstab[256] =
{
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};
@

<<global [[snames]]>>=
static char *snames[] =
{
    "Sclosed",
    "Sclosing",
    "Sreqsent",
    "Sackrcvd",
    "Sacksent",
    "Sopened",
};
@

<<function [[pppopen]]>>=
void
pppopen(PPP *ppp, int mediain, int mediaout, char *net,
    Ipaddr ipaddr, Ipaddr remip,
    int mtu, int framing)
{
    ppp->ipfd = -1;
    ppp->ipcfd = -1;
    invalidate(ppp->remote);
    invalidate(ppp->local);
    invalidate(ppp->curremote);
    invalidate(ppp->curlocal);
    invalidate(ppp->dns[0]);
    invalidate(ppp->dns[1]);
    invalidate(ppp->wins[0]);
    invalidate(ppp->wins[1]);

    ppp->mediain = mediain;
    ppp->mediaout = mediaout;
    if(validv4(remip)){
        ipmove(ppp->remote, remip);
        ppp->remotefrozen = 1;
    }
    if(validv4(ipaddr)){
        ipmove(ppp->local, ipaddr);
        ppp->localfrozen = 1;
    }
    ppp->mtu = Defmtu;
    ppp->mru = mtu;
    ppp->framing = framing;
    ppp->net = net;

    init(ppp);
    switch(rfork(RFPROC|RFMEM|RFNOWAIT)){
    case -1:
        sysfatal("forking mediainproc");
    case 0:
        mediainproc(ppp);
        terminate(ppp, 1);
        _exits(0);
    }
}
@

<<function [[init]]([[(networking/ip/ppp/ppp.c)]])>>=
static void
init(PPP* ppp)
{
    if(ppp->inbuf == nil){
        ppp->inbuf = allocb(4096);
        if(ppp->inbuf == nil)
            abort();

        ppp->outbuf = allocb(4096);
        if(ppp->outbuf == nil)
            abort();

        ppp->lcp = mallocz(sizeof(*ppp->lcp), 1);
        if(ppp->lcp == nil)
            abort();
        ppp->lcp->proto = Plcp;
        ppp->lcp->state = Sclosed;

        ppp->ccp = mallocz(sizeof(*ppp->ccp), 1);
        if(ppp->ccp == nil)
            abort();
        ppp->ccp->proto = Pccp;
        ppp->ccp->state = Sclosed;

        ppp->ipcp = mallocz(sizeof(*ppp->ipcp), 1);
        if(ppp->ipcp == nil)
            abort();
        ppp->ipcp->proto = Pipcp;
        ppp->ipcp->state = Sclosed;

        ppp->chap = mallocz(sizeof(*ppp->chap), 1);
        if(ppp->chap == nil)
            abort();
        ppp->chap->proto = APmschap;
        ppp->chap->state = Cunauth;
        auth_freechal(ppp->chap->cs);
        ppp->chap->cs = nil;

        switch(rfork(RFPROC|RFMEM|RFNOWAIT)){
        case -1:
            sysfatal("forking ppptimer");
        case 0:
            ppptimer(ppp);
            _exits(0);
        }
    }

    ppp->ctcp = compress_init(ppp->ctcp);
    pinit(ppp, ppp->lcp);
    setphase(ppp, Plink);
}
@

<<function [[setphase]]>>=
static void
setphase(PPP *ppp, int phase)
{
    int oldphase;

    oldphase = ppp->phase;

    ppp->phase = phase;
    switch(phase){
    default:
        sysfatal("ppp: unknown phase %d", phase);
    case Pdead:
        /* restart or exit? */
        pinit(ppp, ppp->lcp);
        setphase(ppp, Plink);
        break;
    case Plink:
        /* link down */
        switch(oldphase) {
        case Pauth:
            auth_freechal(ppp->chap->cs);
            ppp->chap->cs = nil;
            ppp->chap->state = Cunauth;
            break;
        case Pnet:
            auth_freechal(ppp->chap->cs);
            ppp->chap->cs = nil;
            ppp->chap->state = Cunauth;
            newstate(ppp, ppp->ccp, Sclosed);
            newstate(ppp, ppp->ipcp, Sclosed);
        }
        break;
    case Pauth:
        if(server)
            chapinit(ppp);
        else if(ppp->chap->proto == APpasswd)
            papinit(ppp);
        else
            setphase(ppp, Pnet);
        break;
    case Pnet:
        pinit(ppp, ppp->ccp);
        pinit(ppp, ppp->ipcp);
        break;
    case Pterm:
        /* what? */
        break;
    }
}
@

<<function [[pinit]]>>=
static void
pinit(PPP *ppp, Pstate *p)
{
    p->timeout = 0;

    switch(p->proto){
    case Plcp:
        ppp->magic = truerand();
        ppp->xctlmap = 0xffffffff;
        ppp->period = 0;
        p->optmask = 0xffffffff;
        if(!server)
            p->optmask &=  ~(Fauth|Fmtu);
        ppp->rctlmap = 0;
        ppp->ipcp->state = Sclosed;
        ppp->ipcp->optmask = 0xffffffff;

        p->echotimeout = 0;

        /* quality goo */
        ppp->timeout = 0;
        memset(&ppp->in, 0, sizeof(ppp->in));
        memset(&ppp->out, 0, sizeof(ppp->out));
        memset(&ppp->pin, 0, sizeof(ppp->pin));
        memset(&ppp->pout, 0, sizeof(ppp->pout));
        memset(&ppp->sin, 0, sizeof(ppp->sin));
        break;
    case Pccp:
        if(nocompress)
            p->optmask = 0;
        else
            p->optmask = Fcmppc;

        if(ppp->ctype != nil)
            (*ppp->ctype->fini)(ppp->cstate);
        ppp->ctype = nil;
        ppp->ctries = 0;
        ppp->cstate = nil;

        if(ppp->unctype)
            (*ppp->unctype->fini)(ppp->uncstate);
        ppp->unctype = nil;
        ppp->uncstate = nil;
        break;
    case Pipcp:
        p->optmask = 0xffffffff;
        ppp->ctcp = compress_init(ppp->ctcp);
        break;
    }
    p->confid = p->rcvdconfid = -1;
    config(ppp, p, 1);
    newstate(ppp, p, Sreqsent);
}
@

<<function [[newstate]]>>=
/*
 *  change protocol to a new state.
 */
static void
newstate(PPP *ppp, Pstate *p, int state)
{
    char *err;

    netlog("ppp: %ux %s->%s ctlmap %lux/%lux flags %lux mtu %ld mru %ld\n",
        p->proto, snames[p->state], snames[state], ppp->rctlmap,
        ppp->xctlmap, p->flags,
        ppp->mtu, ppp->mru);
    syslog(0, "ppp", "%ux %s->%s ctlmap %lux/%lux flags %lux mtu %ld mru %ld",
        p->proto, snames[p->state], snames[state], ppp->rctlmap,
        ppp->xctlmap, p->flags,
        ppp->mtu, ppp->mru);

    if(p->proto == Plcp) {
        if(state == Sopened)
            setphase(ppp, noauth? Pnet : Pauth);
        else if(state == Sclosed)
            setphase(ppp, Pdead);
        else if(p->state == Sopened)
            setphase(ppp, Plink);
    }

    if(p->proto == Pccp && state == Sopened) {
        if(ppp->unctype)
            (*ppp->unctype->fini)(ppp->uncstate);
        ppp->unctype = nil;
        ppp->uncstate = nil;
        if(p->optmask & Fcmppc) {
            ppp->unctype = &uncmppc;
            ppp->uncstate = (*uncmppc.init)(ppp);
        }
        if(p->optmask & Fcthwack){
            ppp->unctype = &uncthwack;
            ppp->uncstate = (*uncthwack.init)(ppp);
        }
    }

    if(p->proto == Pipcp && state == Sopened) {
        if(server && !noauth && ppp->chap->state != Cauthok)
            abort();

        err = ipopen(ppp);
        if(err != nil)
            sysfatal("%s", err);
    }

    p->state = state;
}
@

<<function [[getframe]]>>=
/* returns (protocol, information) */
static Block*
getframe(PPP *ppp, int *protop)
{
    uchar *p, *from, *to;
    int n, len, proto;
    ulong c;
    ushort fcs;
    Block *buf, *b;

    *protop = 0;
    if(ppp->framing == 0) {
        /* assume data is already framed */
        b = allocb(2000);
        len = b->lim - b->wptr;
        n = read(ppp->mediain, b->wptr, len);
   dmppkt("RX", b->wptr, n);
        if(n <= 0 || n == len){
            freeb(b);

            return nil;
        }
        b->wptr += n;

        /* should probably copy to another block if small */

        if(pppframing && b->rptr[0] == PPP_addr && b->rptr[1] == PPP_ctl)
            b->rptr += 2;
        proto = *b->rptr++;
        if((proto & 0x1) == 0)
            proto = (proto<<8) | *b->rptr++;

        if(b->rptr >= b->wptr){
            freeb(b);
            return nil;
        }

        ppp->in.uchars += n;
        ppp->in.packets++;
        *protop = proto;
        netlog("getframe 0x%x\n", proto);
        return b;
    }

    buf = ppp->inbuf;
    for(;;){
        /* read till we hit a frame uchar or run out of room */
        for(p = buf->rptr; buf->wptr < buf->lim;){
            for(; p < buf->wptr; p++)
                if(*p == HDLC_frame)
                    break;
            if(p != buf->wptr)
                break;

            len = buf->lim - buf->wptr;
            n = read(ppp->mediain, buf->wptr, len);
            if(n <= 0){
                syslog(0, LOG, "medium read returns %d: %r", n);
                buf->wptr = buf->rptr;
                return nil;
            }
    dmppkt("RX", buf->wptr, n);
            buf->wptr += n;
        }

        /* copy into block, undoing escapes, and caculating fcs */
        fcs = PPP_initfcs;
        b = allocb(p - buf->rptr);
        to = b->wptr;
        for(from = buf->rptr; from != p;){
            c = *from++;
            if(c == HDLC_esc){
                if(from == p)
                    break;
                c = *from++ ^ 0x20;
            } else if((c < 0x20) && (ppp->rctlmap & (1 << c)))
                continue;
            *to++ = c;
            fcs = (fcs >> 8) ^ fcstab[(fcs ^ c) & 0xff];
        }

        /* copy down what's left in buffer */
        p++;
        memmove(buf->rptr, p, buf->wptr - p);
        n = p - buf->rptr;
        buf->wptr -= n;
        b->wptr = to - 2;

        /* return to caller if checksum matches */
        if(fcs == PPP_goodfcs){
            if(b->rptr[0] == PPP_addr && b->rptr[1] == PPP_ctl)
                b->rptr += 2;
            proto = *b->rptr++;
            if((proto & 0x1) == 0)
                proto = (proto<<8) | *b->rptr++;
            if(b->rptr < b->wptr){
                ppp->in.uchars += n;
                ppp->in.packets++;
                *protop = proto;
                netlog("getframe 0x%x\n", proto);
                return b;
            }
        } else if(BLEN(b) > 0){
            if(ppp->ctcp)
                compress_error(ppp->ctcp);
            ppp->in.discards++;
            netlog("ppp: discard len %ld/%ld cksum %ux (%ux %ux %ux %ux)\n",
                BLEN(b), BLEN(buf), fcs, b->rptr[0],
                b->rptr[1], b->rptr[2], b->rptr[3]);
        }

        freeb(b);
    }
}
@

<<function [[putframe]]>>=
/* send a PPP frame */
static int
putframe(PPP *ppp, int proto, Block *b)
{
    Block *buf;
    uchar *to, *from;
    ushort fcs;
    ulong ctlmap;
    uchar c;
    Block *bp;

    ppp->out.packets++;

    if(proto == Plcp)
        ctlmap = 0xffffffff;
    else
        ctlmap = ppp->xctlmap;

    /* make sure we have head room */
    if(b->rptr - b->base < 4){
        b = padb(b, 4);
        b->rptr += 4;
    }

    netlog("ppp: putframe 0x%ux %ld\n", proto, b->wptr-b->rptr);

    /* add in the protocol and address, we'd better have left room */
    from = b->rptr;
    *--from = proto;
    if(!(ppp->lcp->flags&Fpc) || proto > 0x100 || proto == Plcp)
        *--from = proto>>8;
    if(pppframing && (!(ppp->lcp->flags&Fac) || proto == Plcp)){
        *--from = PPP_ctl;
        *--from = PPP_addr;
    }

    qlock(&ppp->outlock);
    buf = ppp->outbuf;

    if(ppp->framing == 0) {
        to = buf->rptr;
        for(bp = b; bp; bp = bp->next){
            if(bp != b)
                from = bp->rptr;
            memmove(to, from, bp->wptr-from);
            to += bp->wptr-from;
        }
    } else {
        /* escape and checksum the body */
        fcs = PPP_initfcs;
        to = buf->rptr;
    
        /* add frame marker */
        *to++ = HDLC_frame;

        for(bp = b; bp; bp = bp->next){
            if(bp != b)
                from = bp->rptr;
            for(; from < bp->wptr; from++){
                c = *from;
                if(c == HDLC_frame || c == HDLC_esc
                   || (c < 0x20 && ((1<<c) & ctlmap))){
                    *to++ = HDLC_esc;
                    *to++ = c ^ 0x20;
                } else 
                    *to++ = c;
                fcs = (fcs >> 8) ^ fcstab[(fcs ^ c) & 0xff];
            }
        }

        /* add on and escape the checksum */
        fcs = ~fcs;
        c = fcs;
        if(c == HDLC_frame || c == HDLC_esc
           || (c < 0x20 && ((1<<c) & ctlmap))){
            *to++ = HDLC_esc;
            *to++ = c ^ 0x20;
        } else 
            *to++ = c;
        c = fcs>>8;
        if(c == HDLC_frame || c == HDLC_esc
           || (c < 0x20 && ((1<<c) & ctlmap))){
            *to++ = HDLC_esc;
            *to++ = c ^ 0x20;
        } else 
            *to++ = c;
    
        /* add frame marker */
        *to++ = HDLC_frame;
    }

    /* send */
    buf->wptr = to;
  dmppkt("TX", buf->rptr, BLEN(buf));
    if(write(ppp->mediaout, buf->rptr, BLEN(buf)) < 0){
        qunlock(&ppp->outlock);
        return -1;
    }
    ppp->out.uchars += BLEN(buf);

    qunlock(&ppp->outlock);
    return 0;
}
@

<<function [[alloclcp]]>>=
Block*
alloclcp(int code, int id, int len, Lcpmsg **mp)
{
    Block *b;
    Lcpmsg *m;

    /*
     *  leave room for header
     */
    b = allocb(len);

    m = (Lcpmsg*)b->wptr;
    m->code = code;
    m->id = id;
    b->wptr += 4;

    *mp = m;
    return b;
}
@

<<function [[putlo]]>>=
static void
putlo(Block *b, int type, ulong val)
{
    *b->wptr++ = type;
    *b->wptr++ = 6;
    hnputl(b->wptr, val);
    b->wptr += 4;
}
@

<<function [[putv4o]]>>=
static void
putv4o(Block *b, int type, Ipaddr val)
{
    *b->wptr++ = type;
    *b->wptr++ = 6;
    v6tov4(b->wptr, val);
    b->wptr += 4;
}
@

<<function [[putso]]>>=
static void
putso(Block *b, int type, ulong val)
{
    *b->wptr++ = type;
    *b->wptr++ = 4;
    hnputs(b->wptr, val);
    b->wptr += 2;
}
@

<<function [[puto]]>>=
static void
puto(Block *b, int type)
{
    *b->wptr++ = type;
    *b->wptr++ = 2;
}
@

<<function [[config]]>>=
/*
 *  send configuration request
 */
static void
config(PPP *ppp, Pstate *p, int newid)
{
    Block *b;
    Lcpmsg *m;
    int id;

    if(newid){
        id = p->id++;
        p->confid = id;
        p->timeout = Timeout;
    } else
        id = p->confid;
    b = alloclcp(Lconfreq, id, 256, &m);
    USED(m);

    switch(p->proto){
    case Plcp:
        if(p->optmask & Fctlmap)
            putlo(b, Octlmap, 0);	/* we don't want anything escaped */
        if(p->optmask & Fmagic)
            putlo(b, Omagic, ppp->magic);
        if(p->optmask & Fmtu)
            putso(b, Omtu, ppp->mru);
        if(p->optmask & Fauth) {
            *b->wptr++ = Oauth;
            *b->wptr++ = 5;
            hnputs(b->wptr, Pchap);
            b->wptr += 2;
            *b->wptr++ = ppp->chap->proto;
        }
        if(p->optmask & Fpc)
            puto(b, Opc);
        if(p->optmask & Fac)
            puto(b, Oac);
        break;
    case Pccp:
        if(p->optmask & Fcthwack)
            puto(b, Octhwack);
        else if(p->optmask & Fcmppc) {
            *b->wptr++ = Ocmppc;
            *b->wptr++ = 6;
            *b->wptr++ = 0;
            *b->wptr++ = 0;
            *b->wptr++ = 0;
            *b->wptr++ = 0x41;
        }
        break;
    case Pipcp:
        if(p->optmask & Fipaddr)
{syslog(0, "ppp", "requesting %I", ppp->local);
            putv4o(b, Oipaddr, ppp->local);
}
        if(primary && (p->optmask & Fipdns))
            putv4o(b, Oipdns, ppp->dns[0]);
        if(primary && (p->optmask & Fipdns2))
            putv4o(b, Oipdns2, ppp->dns[1]);
        if(primary && (p->optmask & Fipwins))
            putv4o(b, Oipwins, ppp->wins[0]);
        if(primary && (p->optmask & Fipwins2))
            putv4o(b, Oipwins2, ppp->wins[1]);
        /*
         * don't ask for header compression while data compression is still pending.
         * perhaps we should restart ipcp negotiation if compression negotiation fails.
         */
        if(!noipcompress && !ppp->ccp->optmask && (p->optmask & Fipcompress)) {
            *b->wptr++ = Oipcompress;
            *b->wptr++ = 6;
            hnputs(b->wptr, Pvjctcp);
            b->wptr += 2;
            *b->wptr++ = MAX_STATES-1;
            *b->wptr++ = 1;
        }
        break;
    }
    hnputs(m->len, BLEN(b));
    printopts(p, b, 1);
    putframe(ppp, p->proto, b);
    freeb(b);
}
@

<<function [[getipinfo]]>>=
static void
getipinfo(PPP *ppp)
{
    char *av[3];
    int ndns, nwins;
    char ip[64];
    Ndbtuple *t, *nt;

    if(!validv4(ppp->local))
        return;

    av[0] = "dns";
    av[1] = "wins";
    sprint(ip, "%I", ppp->local);
    t = csipinfo(ppp->net, "ip", ip, av, 2);
    ndns = nwins = 0;
    for(nt = t; nt != nil; nt = nt->entry){
        if(strcmp(nt->attr, "dns") == 0){
            if(ndns < 2)
                parseip(ppp->dns[ndns++], nt->val);
        } else if(strcmp(nt->attr, "wins") == 0){
            if(nwins < 2)
                parseip(ppp->wins[nwins++], nt->val);
        }
    }
    if(t != nil)
        ndbfree(t);
}
@

<<function [[getopts]]>>=
/*
 *  parse configuration request, sends an ack or reject packet
 *
 *	returns:	-1 if request was syntacticly incorrect
 *			 0 if packet was accepted
 *			 1 if packet was rejected
 */
static int
getopts(PPP *ppp, Pstate *p, Block *b)
{
    Lcpmsg *m, *repm;	
    Lcpopt *o;
    uchar *cp, *ap;
    ulong rejecting, nacking, flags, proto, chapproto;
    ulong mtu, ctlmap, period;
    ulong x;
    Block *repb;
    Comptype *ctype;
    Ipaddr ipaddr;

    rejecting = 0;
    nacking = 0;
    flags = 0;

    /* defaults */
    invalidate(ipaddr);
    mtu = ppp->mtu;
    ctlmap = 0xffffffff;
    period = 0;
    ctype = nil;
    chapproto = 0;

    m = (Lcpmsg*)b->rptr;
    repb = alloclcp(Lconfack, m->id, BLEN(b), &repm);

    /* copy options into ack packet */
    memmove(repm->data, m->data, b->wptr - m->data);
    repb->wptr += b->wptr - m->data;

    /* look for options we don't recognize or like */
    for(cp = m->data; cp < b->wptr; cp += o->len){
        o = (Lcpopt*)cp;
        if(cp + o->len > b->wptr || o->len==0){
            freeb(repb);
            netlog("ppp: bad option length %ux\n", o->type);
            return -1;
        }

        switch(p->proto){
        case Plcp:
            switch(o->type){
            case Oac:
                flags |= Fac;
                continue;
            case Opc:
                flags |= Fpc;
                continue;
            case Omtu:
                mtu = nhgets(o->data);
                continue;
            case Omagic:
                if(ppp->magic == nhgetl(o->data))
                    netlog("ppp: possible loop\n");
                continue;
            case Octlmap:
                ctlmap = nhgetl(o->data);
                continue;
            case Oquality:
                proto = nhgets(o->data);
                if(proto != Plqm)
                    break;
                x = nhgetl(o->data+2)*10;
                period = (x+Period-1)/Period;
                continue;
            case Oauth:
                proto = nhgets(o->data);
                if(proto == Ppasswd && !server){
                    chapproto = APpasswd;
                    continue;
                }
                if(proto != Pchap)
                    break;
                if(o->data[2] != APmd5 && o->data[2] != APmschap)
                    break;
                chapproto = o->data[2];
                continue;
            }
            break;
        case Pccp:
            if(nocompress)
                break;
            switch(o->type){
            case Octhwack:
                break;
            /*
                if(o->len == 2){
                    ctype = &cthwack;
                    continue;
                }
                if(!nacking){
                    nacking = 1;
                    repb->wptr = repm->data;
                    repm->code = Lconfnak;
                }
                puto(repb, Octhwack);
                continue;
            */
            case Ocmppc:
                x = nhgetl(o->data);

                // hack for Mac
                // if(x == 0)
                //	continue;

                /* stop ppp loops */
                if((x&0x41) == 0 || ppp->ctries++ > 5) {
                    /*
                     * turn off requests as well - I don't think this
                     * is needed in the standard
                     */
                    p->optmask &= ~Fcmppc;
                    break;
                }
                if(rejecting)
                    continue;
                if(x & 1) {
                    ctype = &cmppc;
                    ppp->sendencrypted = (o->data[3]&0x40) == 0x40;
                    continue;
                }
                if(!nacking){
                    nacking = 1;
                    repb->wptr = repm->data;
                    repm->code = Lconfnak;
                }
                *repb->wptr++ = Ocmppc;
                *repb->wptr++ = 6;
                *repb->wptr++ = 0;
                *repb->wptr++ = 0;
                *repb->wptr++ = 0;
                *repb->wptr++ = 0x41;
                continue;
            }
            break;
        case Pipcp:
            switch(o->type){
            case Oipaddr:	
                v4tov6(ipaddr, o->data);
                if(!validv4(ppp->remote))
                    continue;
                if(!validv4(ipaddr) && !rejecting){
                    /* other side requesting an address */
                    if(!nacking){
                        nacking = 1;
                        repb->wptr = repm->data;
                        repm->code = Lconfnak;
                    }
                    putv4o(repb, Oipaddr, ppp->remote);
                }
                continue;
            case Oipdns:
                ap = ppp->dns[0];
                goto ipinfo;
            case Oipdns2:	
                ap = ppp->dns[1];
                goto ipinfo;
            case Oipwins:	
                ap = ppp->wins[0];
                goto ipinfo;
            case Oipwins2:
                ap = ppp->wins[1];
                goto ipinfo;
            ipinfo:
                if(!validv4(ap))
                    getipinfo(ppp);
                if(!validv4(ap))
                    break;
                v4tov6(ipaddr, o->data);
                if(!validv4(ipaddr) && !rejecting){
                    /* other side requesting an address */
                    if(!nacking){
                        nacking = 1;
                        repb->wptr = repm->data;
                        repm->code = Lconfnak;
                    }
                    putv4o(repb, o->type, ap);
                }
                continue;
            case Oipcompress:
                /*
                 * don't compress tcp header if we've negotiated data compression.
                 * tcp header compression has very poor performance if there is an error.
                 */
                proto = nhgets(o->data);
                if(noipcompress || proto != Pvjctcp || ppp->ctype != nil)
                    break;
                if(compress_negotiate(ppp->ctcp, o->data+2) < 0)
                    break;
                flags |= Fipcompress;
                continue;
            }
            break;
        }

        /* come here if option is not recognized */
        if(!rejecting){
            rejecting = 1;
            repb->wptr = repm->data;
            repm->code = Lconfrej;
        }
        netlog("ppp: bad %ux option %d\n", p->proto, o->type);
        memmove(repb->wptr, o, o->len);
        repb->wptr += o->len;
    }

    /* permanent changes only after we know that we liked the packet */
    if(!rejecting && !nacking){
        switch(p->proto){
        case Plcp:
            ppp->period = period;
            ppp->xctlmap = ctlmap;
            if(mtu > Maxmtu)
                mtu = Maxmtu;
            if(mtu < Minmtu)
                mtu = Minmtu;
            ppp->mtu = mtu;
            if(chapproto)
                ppp->chap->proto = chapproto;
            
            break;
        case Pccp:
            if(ppp->ctype != nil){
                (*ppp->ctype->fini)(ppp->cstate);
                ppp->cstate = nil;
            }
            ppp->ctype = ctype;
            if(ctype)
                ppp->cstate = (*ctype->init)(ppp);
            break;
        case Pipcp:
            if(validv4(ipaddr) && ppp->remotefrozen == 0)
     ipmove(ppp->remote, ipaddr);
            break;
        }
        p->flags = flags;
    }

    hnputs(repm->len, BLEN(repb));
    printopts(p, repb, 1);
    putframe(ppp, p->proto, repb);
    freeb(repb);

    return rejecting || nacking;
}
@

<<function [[dmppkt]]>>=
static void
dmppkt(char *s, uchar *a, int na)
{
    int i;

    if (debug < 3)
        return;

    fprint(2, "%s", s);
    for(i = 0; i < na; i++)
        fprint(2, " %.2ux", a[i]);
    fprint(2, "\n");
}
@

<<function [[dropoption]]>>=
static void
dropoption(Pstate *p, Lcpopt *o)
{
    unsigned n = o->type;

    switch(n){
    case Oipaddr:
        break;
    case Oipdns:
        p->optmask &= ~Fipdns;
        break;
    case Oipwins:
        p->optmask &= ~Fipwins;
        break;
    case Oipdns2:
        p->optmask &= ~Fipdns2;
        break;
    case Oipwins2:
        p->optmask &= ~Fipwins2;
        break;
    default:
        if(o->type < 8*sizeof(p->optmask))
            p->optmask &= ~(1<<o->type);
        break;
    }
}
@

<<function [[rejopts]]>>=
/*
 *  parse configuration rejection, just stop sending anything that they
 *  don't like (except for ipcp address nak).
 */
static void
rejopts(PPP *ppp, Pstate *p, Block *b, int code)
{
    Lcpmsg *m;
    Lcpopt *o;
    uchar newip[IPaddrlen];

    /* just give up trying what the other side doesn't like */
    m = (Lcpmsg*)b->rptr;
    for(b->rptr = m->data; b->rptr < b->wptr; b->rptr += o->len){
        o = (Lcpopt*)b->rptr;
        if(b->rptr + o->len > b->wptr){
            netlog("ppp: bad roption length %ux\n", o->type);
            return;
        }

        if(code == Lconfrej){
            dropoption(p, o);
            netlog("ppp: %ux rejecting %d\n",
                    p->proto, o->type);
            continue;
        }

        switch(p->proto){
        case Plcp:
            switch(o->type){
            case Octlmap:
                ppp->rctlmap = nhgetl(o->data);
                break;
            case Oauth:
                /* don't allow client to request no auth */
                /* could try different auth protocol here */
                fprint(2, "ppp: can not reject CHAP\n");
                exits("ppp: CHAP");
                break;
            default:
                if(o->type < 8*sizeof(p->optmask))
                    p->optmask &= ~(1<<o->type);
                break;
            };
            break;
        case Pccp:
            switch(o->type){
            default:
                dropoption(p, o);
                break;
            }
            break;
        case Pipcp:
            switch(o->type){
            case Oipaddr:
syslog(0, "ppp", "rejected addr %I with %V", ppp->local, o->data);
                /* if we're a server, don't let other end change our addr */
                if(ppp->localfrozen){
                    dropoption(p, o);
                    break;
                }

                /* accept whatever server tells us */
                if(!validv4(ppp->local)){
                    v4tov6(ppp->local, o->data);
                    dropoption(p, o);
                    break;
                }

                /* if he didn't like our addr, ask for a generic one */
                v4tov6(newip, o->data);
                if(!validv4(newip)){
                    invalidate(ppp->local);
                    break;
                }

                /* if he gives us something different, use it anyways */
                v4tov6(ppp->local, o->data);
                dropoption(p, o);
                break;
            case Oipdns:
                if (!validv4(ppp->dns[0])){
                    v4tov6(ppp->dns[0], o->data);
                    dropoption(p, o);
                    break;
                }
                v4tov6(newip, o->data);
                if(!validv4(newip)){
                    invalidate(ppp->dns[0]);
                    break;
                }
                v4tov6(ppp->dns[0], o->data);
                dropoption(p, o);
                break;
            case Oipwins:
                if (!validv4(ppp->wins[0])){
                    v4tov6(ppp->wins[0], o->data);
                    dropoption(p, o);
                    break;
                }
                v4tov6(newip, o->data);
                if(!validv4(newip)){
                    invalidate(ppp->wins[0]);
                    break;
                }
                v4tov6(ppp->wins[0], o->data);
                dropoption(p, o);
                break;
            case Oipdns2:
                if (!validv4(ppp->dns[1])){
                    v4tov6(ppp->dns[1], o->data);
                    dropoption(p, o);
                    break;
                }
                v4tov6(newip, o->data);
                if(!validv4(newip)){
                    invalidate(ppp->dns[1]);
                    break;
                }
                v4tov6(ppp->dns[1], o->data);
                dropoption(p, o);
                break;
            case Oipwins2:
                if (!validv4(ppp->wins[1])){
                    v4tov6(ppp->wins[1], o->data);
                    dropoption(p, o);
                    break;
                }
                v4tov6(newip, o->data);
                if(!validv4(newip)){
                    invalidate(ppp->wins[1]);
                    break;
                }
                v4tov6(ppp->wins[1], o->data);
                dropoption(p, o);
                break;
            default:
                dropoption(p, o);
                break;
            }
            break;
        }
    }
}
@

<<function [[rcv]]>>=
/*
 *  put a messages through the lcp or ipcp state machine.  They are
 *  very similar.
 */
static void
rcv(PPP *ppp, Pstate *p, Block *b)
{
    ulong len;
    int err;
    Lcpmsg *m;
    int proto;

    if(BLEN(b) < 4){
        netlog("ppp: short lcp message\n");
        freeb(b);
        return;
    }
    m = (Lcpmsg*)b->rptr;
    len = nhgets(m->len);
    if(BLEN(b) < len){
        netlog("ppp: short lcp message\n");
        freeb(b);
        return;
    }

    netlog("ppp: %ux rcv %d len %ld id %d/%d/%d\n",
        p->proto, m->code, len, m->id, p->confid, p->id);

    if(p->proto != Plcp && ppp->lcp->state != Sopened){
        netlog("ppp: non-lcp with lcp not open\n");
        freeb(b);
        return;
    }

    qlock(ppp);
    switch(m->code){
    case Lconfreq:
        printopts(p, b, 0);
        err = getopts(ppp, p, b);
        if(err < 0)
            break;

        if(m->id == p->rcvdconfid)
            break;			/* don't change state for duplicates */

        switch(p->state){
        case Sackrcvd:
            if(err)
                break;
            newstate(ppp, p, Sopened);
            break;
        case Sclosed:
        case Sopened:
            config(ppp, p, 1);
            if(err == 0)
                newstate(ppp, p, Sacksent);
            else
                newstate(ppp, p, Sreqsent);
            break;
        case Sreqsent:
        case Sacksent:
            if(err == 0)
                newstate(ppp, p, Sacksent);
            else
                newstate(ppp, p, Sreqsent);
            break;
        }
        break;
    case Lconfack:
        if(p->confid != m->id){
            /* ignore if it isn't the message we're sending */
            netlog("ppp: dropping confack\n");
            break;
        }
        p->confid = -1;		/* ignore duplicates */
        p->id++;		/* avoid sending duplicates */

        netlog("ppp: recv confack\n");
        switch(p->state){
        case Sopened:
        case Sackrcvd:
            config(ppp, p, 1);
            newstate(ppp, p, Sreqsent);
            break;
        case Sreqsent:
            newstate(ppp, p, Sackrcvd);
            break;
        case Sacksent:
            newstate(ppp, p, Sopened);
            break;
        }
        break;
    case Lconfrej:
    case Lconfnak:
        if(p->confid != m->id) {
            /* ignore if it isn't the message we're sending */
            netlog("ppp: dropping confrej or confnak\n");
            break;
        }
        p->confid = -1;		/* ignore duplicates */
        p->id++;		/* avoid sending duplicates */

        switch(p->state){
        case Sopened:
        case Sackrcvd:
            config(ppp, p, 1);
            newstate(ppp, p, Sreqsent);
            break;
        case Sreqsent:
        case Sacksent:
            printopts(p, b, 0);
            rejopts(ppp, p, b, m->code);
            config(ppp, p, 1);
            break;
        }
        break;
    case Ltermreq:
        m->code = Ltermack;
        putframe(ppp, p->proto, b);

        switch(p->state){
        case Sackrcvd:
        case Sacksent:
            newstate(ppp, p, Sreqsent);
            break;
        case Sopened:
            newstate(ppp, p, Sclosing);
            break;
        }
        break;
    case Ltermack:
        if(p->termid != m->id)	/* ignore if it isn't the message we're sending */
            break;

        if(p->proto == Plcp)
            ppp->ipcp->state = Sclosed;
        switch(p->state){
        case Sclosing:
            newstate(ppp, p, Sclosed);
            break;
        case Sackrcvd:
            newstate(ppp, p, Sreqsent);
            break;
        case Sopened:
            config(ppp, p, 0);
            newstate(ppp, p, Sreqsent);
            break;
        }
        break;
    case Lcoderej:
        //newstate(ppp, p, Sclosed);
        syslog(0, LOG, "code reject %d\n", m->data[0]);
        break;
    case Lprotorej:
        proto = nhgets(m->data);
        netlog("ppp: proto reject %ux\n", proto);
        if(proto == Pccp)
            newstate(ppp, ppp->ccp, Sclosed);
        break;
    case Lechoreq:
        if(BLEN(b) < 8){
            netlog("ppp: short lcp echo request\n");
            freeb(b);
            return;
        }
        m->code = Lechoack;
        hnputl(m->data, ppp->magic);
        putframe(ppp, p->proto, b);
        break;
    case Lechoack:
        p->echoack = 1;
        break;
    case Ldiscard:
        /* nothing to do */
        break;
    case Lresetreq:
        if(p->proto != Pccp)
            break;
        ppp->stat.compreset++;
        if(ppp->ctype != nil)
            b = (*ppp->ctype->resetreq)(ppp->cstate, b);
        if(b != nil) {
            m = (Lcpmsg*)b->rptr;
            m->code = Lresetack;
            putframe(ppp, p->proto, b);
        }
        break;
    case Lresetack:
        if(p->proto != Pccp)
            break;
        if(ppp->unctype != nil)
            (*ppp->unctype->resetack)(ppp->uncstate, b);
        break;
    }

    qunlock(ppp);
    freeb(b);
}
@

<<function [[ptimer]]>>=
/*
 *  timer for protocol state machine
 */
static void
ptimer(PPP *ppp, Pstate *p)
{
    if(p->state == Sopened || p->state == Sclosed)
        return;

    p->timeout--;
    switch(p->state){
    case Sclosing:
        sendtermreq(ppp, p);
        break;
    case Sreqsent:
    case Sacksent:
        if(p->timeout <= 0)
            newstate(ppp, p, Sclosed);
        else {
            config(ppp, p, 0);
        }
        break;
    case Sackrcvd:
        if(p->timeout <= 0)
            newstate(ppp, p, Sclosed);
        else {
            config(ppp, p, 0);
            newstate(ppp, p, Sreqsent);
        }
        break;
    }
}
@

<<function [[authtimer]]>>=
/* paptimer -- pap timer event handler
 *
 * If PAP authorization hasn't come through, resend an authreqst.  If
 * the maximum number of requests have been sent (~ 30 seconds), give
 * up.
 *
 */
static void
authtimer(PPP* ppp)
{
    if(ppp->chap->proto != APpasswd)
        return;

    if(ppp->chap->id < 21)
        putpaprequest(ppp);
    else {
        terminate(ppp, 0);
        netlog("ppp: pap timed out--not authorized\n");
    }
}
@

<<function [[ppptimer]]>>=
/*
 *  timer for ppp
 */
static void
ppptimer(PPP *ppp)
{
    while(!dying){
        sleep(Period);
        qlock(ppp);

        netlog("ppp: ppptimer\n");
        ptimer(ppp, ppp->lcp);
        if(ppp->lcp->state == Sopened) {
            switch(ppp->phase){
            case Pnet:
                ptimer(ppp, ppp->ccp);
                ptimer(ppp, ppp->ipcp);
                break;
            case Pauth:
                authtimer(ppp);
                break;
            }
        }

        /* link quality measurement */
        if(ppp->period && --(ppp->timeout) <= 0){
            ppp->timeout = ppp->period;
            putlqm(ppp);
        }

        qunlock(ppp);
    }
}
@

<<function [[setdefroute]]>>=
static void
setdefroute(char *net, Ipaddr gate)
{
    int fd;
    char path[128];

    snprint(path, sizeof path, "%s/iproute", net);
    fd = open(path, ORDWR);
    if(fd < 0)
        return;
    fprint(fd, "add 0 0 %I", gate);
    close(fd);
}
@

<<enum [[_anon_ (networking/ip/ppp/ppp.c)2]]>>=
enum
{
    Mofd=	32,
};
@

<<global [[old]]>>=
struct
{
    Lock;

    int	fd[Mofd];
    int	cfd[Mofd];
    int	n;
} old;
@

<<function [[ipopen]]([[(networking/ip/ppp/ppp.c)]])>>=
static char*
ipopen(PPP *ppp)
{
    static int ipinprocpid;
    int n, cfd, fd;
    char path[128];
    char buf[128];

    if(ipinprocpid <= 0){
        snprint(path, sizeof path, "%s/ipifc/clone", ppp->net);
        cfd = open(path, ORDWR);
        if(cfd < 0)
            return "can't open ip interface";

        n = read(cfd, buf, sizeof(buf) - 1);
        if(n <= 0){
            close(cfd);
            return "can't open ip interface";
        }
        buf[n] = 0;

        netlog("ppp: setting up IP interface local %I remote %I (valid %d)\n",
            ppp->local, ppp->remote, validv4(ppp->remote));
        if(!validv4(ppp->remote))
            ipmove(ppp->remote, ppp->local);

        snprint(path, sizeof path, "%s/ipifc/%s/data", ppp->net, buf);
        fd = open(path, ORDWR);
        if(fd < 0){
            close(cfd);
            return "can't open ip interface";
        }

        if(fprint(cfd, "bind pkt") < 0)
            return "binding pkt to ip interface";
        if(fprint(cfd, "add %I 255.255.255.255 %I %lud proxy", ppp->local,
            ppp->remote, ppp->mtu-10) < 0){
            close(cfd);
            return "can't set addresses";
        }
        if(primary)
            setdefroute(ppp->net, ppp->remote);
        ppp->ipfd = fd;
        ppp->ipcfd = cfd;

        /* signal main() that ip is configured */
        rendezvous((void*)Rmagic, 0);

        switch(ipinprocpid = rfork(RFPROC|RFMEM|RFNOWAIT)){
        case -1:
            sysfatal("forking ipinproc");
        case 0:
            ipinproc(ppp);
            terminate(ppp, 1);
            _exits(0);
        }
    } else {
        /* we may have changed addresses */
        if(ipcmp(ppp->local, ppp->curlocal) != 0 ||
           ipcmp(ppp->remote, ppp->curremote) != 0){
            snprint(buf, sizeof buf, "remove %I 255.255.255.255 %I",
                ppp->curlocal, ppp->curremote);
            if(fprint(ppp->ipcfd, "%s", buf) < 0)
                syslog(0, "ppp", "can't %s: %r", buf);
            snprint(buf, sizeof buf, "add %I 255.255.255.255 %I %lud proxy",
                ppp->local, ppp->remote, ppp->mtu-10);
            if(fprint(ppp->ipcfd, "%s", buf) < 0)
                syslog(0, "ppp", "can't %s: %r", buf);
        }
        syslog(0, "ppp", "%I/%I -> %I/%I", ppp->curlocal, ppp->curremote,
           ppp->local, ppp->remote);
    }
    ipmove(ppp->curlocal, ppp->local);
    ipmove(ppp->curremote, ppp->remote);

    return nil;
}
@

<<function [[pppread]]>>=
/* return next input IP packet */
Block*
pppread(PPP *ppp)
{
    Block *b, *reply;
    int proto, len;
    Lcpmsg *m;

    while(!dying){
        b = getframe(ppp, &proto);
        if(b == nil)
            return nil;

Again:
        switch(proto){
        case Plcp:
            rcv(ppp, ppp->lcp, b);
            break;
        case Pccp:
            rcv(ppp, ppp->ccp, b);
            break;
        case Pipcp:
            rcv(ppp, ppp->ipcp, b);
            break;
        case Pip:
            if(ppp->ipcp->state == Sopened)
                return b;
            netlog("ppp: IP recved: link not up\n");
            freeb(b);
            break;
        case Plqm:
            getlqm(ppp, b);
            break;
        case Pchap:
            getchap(ppp, b);
            break;
        case Ppasswd:
            getpap(ppp, b);
            break;
        case Pvjctcp:
        case Pvjutcp:
            if(ppp->ipcp->state != Sopened){
                netlog("ppp: VJ tcp recved: link not up\n");
                freeb(b);
                break;
            }
            ppp->stat.vjin++;
            b = tcpuncompress(ppp->ctcp, b, proto);
            if(b != nil)
                return b;
            ppp->stat.vjfail++;
            break;
        case Pcdata:
            ppp->stat.uncomp++;
            if(ppp->ccp->state != Sopened){
                netlog("ppp: compressed data recved: link not up\n");
                freeb(b);
                break;
            }
            if(ppp->unctype == nil) {
                netlog("ppp: compressed data recved: no compression\n");
                freeb(b);
                break;
            }
            len = BLEN(b);
            b = (*ppp->unctype->uncompress)(ppp, b, &proto, &reply);
            if(reply != nil){
                /* send resetreq */
                ppp->stat.uncompreset++;
                putframe(ppp, Pccp, reply);
                freeb(reply);
            }
            if(b == nil)
                break;
            ppp->stat.uncompin += len;
            ppp->stat.uncompout += BLEN(b);
/* netlog("ppp: uncompressed frame %ux %d %d (%d uchars)\n", proto, b->rptr[0], b->rptr[1], BLEN(b)); /* */
            goto Again;	
        default:
            syslog(0, LOG, "unknown proto %ux", proto);
            if(ppp->lcp->state == Sopened){
                /* reject the protocol */
                b->rptr -= 6;
                m = (Lcpmsg*)b->rptr;
                m->code = Lprotorej;
                m->id = ++ppp->lcp->id;
                hnputs(m->data, proto);
                hnputs(m->len, BLEN(b));
                putframe(ppp, Plcp, b);
            }
            freeb(b);
            break;
        }
    }
    return nil;
}
@

<<function [[pppwrite]]>>=
/* transmit an IP packet */
int
pppwrite(PPP *ppp, Block *b)
{
    int proto;
    int len;

    qlock(ppp);
    /* can't send ip packets till we're established */
    if(ppp->ipcp->state != Sopened) {
        qunlock(ppp);
        syslog(0, LOG, "IP write: link not up");
        len = blen(b);
        freeb(b);
        return len;
    }

    proto = Pip;
    ppp->stat.ipsend++;

    if(ppp->ipcp->flags & Fipcompress){
        b = compress(ppp->ctcp, b, &proto);
        if(b == nil){
            qunlock(ppp);
            return 0;
        }
        if(proto != Pip)
            ppp->stat.vjout++;
    }

    if(ppp->ctype != nil) {
        len = blen(b);
        b = (*ppp->ctype->compress)(ppp, proto, b, &proto);
        if(proto == Pcdata) {
            ppp->stat.comp++;
            ppp->stat.compin += len;
            ppp->stat.compout += blen(b);
        }
    } 

    if(putframe(ppp, proto, b) < 0) {
        qunlock(ppp);
        freeb(b);
        return -1;
    }
    qunlock(ppp);

    len = blen(b);
    freeb(b);
    return len;
}
@

<<function [[terminate]]>>=
static void
terminate(PPP *ppp, int kill)
{
    close(ppp->ipfd);
    ppp->ipfd = -1;
    close(ppp->ipcfd);
    ppp->ipcfd = -1;
    close(ppp->mediain);
    close(ppp->mediaout);
    ppp->mediain = -1;
    ppp->mediaout = -1;
    dying = 1;

    if(kill)
        postnote(PNGROUP, getpid(), "die");
}
@

<<struct [[Iphdr]]([[(networking/ip/ppp/ppp.c)]])>>=
struct Iphdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* Ip source (uchar ordering unimportant) */
    uchar	dst[4];		/* Ip destination (uchar ordering unimportant) */
};
@

<<function [[ipinproc]]>>=
static void
ipinproc(PPP *ppp)
{
    Block *b;
    int m, n;
    Iphdr *ip;

    while(!dying){

        b = allocb(Buflen);
        n = read(ppp->ipfd, b->wptr, b->lim-b->wptr);
        if(n < 0)
            break;

        /* trim packet if there's padding (e.g. from ether) */
        ip = (Iphdr*)b->rptr;
        m = nhgets(ip->length);
        if(m < n && m > 0)
            n = m;
        b->wptr += n;

        if(pppwrite(ppp, b) < 0)
            break;
    }
}
@

<<function [[catchdie]]>>=
static void
catchdie(void*, char *msg)
{
    if(strstr(msg, "die") != nil)
        noted(NCONT);
    else
        noted(NDFLT);
}
@

<<function [[hexdump]]>>=
static void
hexdump(uchar *a, int na)
{
    int i;
    char buf[80];

    fprint(2, "dump %p %d\n", a, na);
    buf[0] = '\0';
    for(i=0; i<na; i++){
        sprint(buf+strlen(buf), " %.2ux", a[i]);
        if(i%16 == 7)
            sprint(buf+strlen(buf), " --");
        if(i%16==15){
            sprint(buf+strlen(buf), "\n");
            write(2, buf, strlen(buf));
            buf[0] = '\0';
        }
    }
    if(i%16){
        sprint(buf+strlen(buf), "\n");
        write(2, buf, strlen(buf));
    }
}
@

<<function [[mediainproc]]>>=
static void
mediainproc(PPP *ppp)
{
    Block *b;
    Ipaddr remote;

    notify(catchdie);
    while(!dying){
        b = pppread(ppp);
        if(b == nil){
            syslog(0, LOG, "pppread return nil");
            break;
        }
        ppp->stat.iprecv++;
        if(ppp->ipcp->state != Sopened) {
            ppp->stat.iprecvnotup++;
            freeb(b);
            continue;
        }

        if(server) {
            v4tov6(remote, b->rptr+12);
            if(ipcmp(remote, ppp->remote) != 0) {
                ppp->stat.iprecvbadsrc++;
                freeb(b);
                continue;
            }
        }
        if(debug > 1){
            netlog("ip write pkt %p %d\n", b->rptr, blen(b));
            hexdump(b->rptr, blen(b));
        }
        if(write(ppp->ipfd, b->rptr, blen(b)) < 0) {
            syslog(0, LOG, "error writing to pktifc");
            freeb(b);
            break;
        }

        freeb(b);
    }

    netlog(": remote=%I: ppp shutting down\n", ppp->remote);
    syslog(0, LOG, ": remote=%I: ppp shutting down", ppp->remote);
    syslog(0, LOG, "\t\tppp send = %lud/%lud recv= %lud/%lud",
        ppp->out.packets, ppp->out.uchars,
        ppp->in.packets, ppp->in.uchars);
    syslog(0, LOG, "\t\tip send=%lud", ppp->stat.ipsend);
    syslog(0, LOG, "\t\tip recv=%lud notup=%lud badsrc=%lud",
        ppp->stat.iprecv, ppp->stat.iprecvnotup, ppp->stat.iprecvbadsrc);
    syslog(0, LOG, "\t\tcompress=%lud in=%lud out=%lud reset=%lud",
        ppp->stat.comp, ppp->stat.compin, ppp->stat.compout, ppp->stat.compreset);
    syslog(0, LOG, "\t\tuncompress=%lud in=%lud out=%lud reset=%lud",
        ppp->stat.uncomp, ppp->stat.uncompin, ppp->stat.uncompout,
        ppp->stat.uncompreset);
    syslog(0, LOG, "\t\tvjin=%lud vjout=%lud vjfail=%lud", 
        ppp->stat.vjin, ppp->stat.vjout, ppp->stat.vjfail);
}
@

<<function [[getlqm]]>>=
/*
 *  link quality management
 */
static void
getlqm(PPP *ppp, Block *b)
{
    Qualpkt *p;

    p = (Qualpkt*)b->rptr;
    if(BLEN(b) == sizeof(Qualpkt)){
        ppp->in.reports++;
        ppp->pout.reports = nhgetl(p->peeroutreports);
        ppp->pout.packets = nhgetl(p->peeroutpackets);
        ppp->pout.uchars = nhgetl(p->peeroutuchars);
        ppp->pin.reports = nhgetl(p->peerinreports);
        ppp->pin.packets = nhgetl(p->peerinpackets);
        ppp->pin.discards = nhgetl(p->peerindiscards);
        ppp->pin.errors = nhgetl(p->peerinerrors);
        ppp->pin.uchars = nhgetl(p->peerinuchars);

        /* save our numbers at time of reception */
        memmove(&ppp->sin, &ppp->in, sizeof(Qualstats));

    }
    freeb(b);
    if(ppp->period == 0)
        putlqm(ppp);

}
@

<<function [[putlqm]]>>=
static void
putlqm(PPP *ppp)
{
    Qualpkt *p;
    Block *b;

    b = allocb(sizeof(Qualpkt));
    b->wptr += sizeof(Qualpkt);
    p = (Qualpkt*)b->rptr;
    hnputl(p->magic, 0);

    /* heresay (what he last told us) */
    hnputl(p->lastoutreports, ppp->pout.reports);
    hnputl(p->lastoutpackets, ppp->pout.packets);
    hnputl(p->lastoutuchars, ppp->pout.uchars);

    /* our numbers at time of last reception */
    hnputl(p->peerinreports, ppp->sin.reports);
    hnputl(p->peerinpackets, ppp->sin.packets);
    hnputl(p->peerindiscards, ppp->sin.discards);
    hnputl(p->peerinerrors, ppp->sin.errors);
    hnputl(p->peerinuchars, ppp->sin.uchars);

    /* our numbers now */
    hnputl(p->peeroutreports, ppp->out.reports+1);
    hnputl(p->peeroutpackets, ppp->out.packets+1);
    hnputl(p->peeroutuchars, ppp->out.uchars+53/*hack*/);

    putframe(ppp, Plqm, b);
    freeb(b);
    ppp->out.reports++;
}
@

<<function [[chapinit]]>>=
/*
 * init challenge response dialog
 */
static void
chapinit(PPP *ppp)
{
    Block *b;
    Lcpmsg *m;
    Chap *c;
    int len;
    char *aproto;

    getauth(ppp);

    c = ppp->chap;
    c->id++;

    switch(c->proto){
    default:
        abort();
    case APmd5:
        aproto = "chap";
        break;
    case APmschap:
        aproto = "mschap";
        break;
    }
    if((c->cs = auth_challenge("proto=%q role=server", aproto)) == nil)
        sysfatal("auth_challenge: %r");
    syslog(0, LOG, ": remote=%I: sending %d byte challenge", ppp->remote, c->cs->nchal);
    len = 4 + 1 + c->cs->nchal + strlen(ppp->chapname);
    b = alloclcp(Cchallenge, c->id, len, &m);

    *b->wptr++ = c->cs->nchal;
    memmove(b->wptr, c->cs->chal, c->cs->nchal);
    b->wptr += c->cs->nchal;
    memmove(b->wptr, ppp->chapname, strlen(ppp->chapname));
    b->wptr += strlen(ppp->chapname);
    hnputs(m->len, len);
    putframe(ppp, Pchap, b);
    freeb(b);

    c->state = Cchalsent;
}
@

<<enum [[_anon_ (networking/ip/ppp/ppp.c)3]]>>=
/*
 * BUG factotum should do this
 */
enum {
    MShashlen = 16,
    MSresplen = 24,
    MSchallen = 8,
};
@

<<function [[desencrypt]]>>=
void
desencrypt(uchar data[8], uchar key[7])
{
    ulong ekey[32];

    key_setup(key, ekey);
    block_cipher(ekey, data, 0);
}
@

<<function [[nthash]]>>=
void
nthash(uchar hash[MShashlen], char *passwd)
{
    uchar buf[512];
    int i;
    
    for(i=0; *passwd && i<sizeof(buf); passwd++) {
        buf[i++] = *passwd;
        buf[i++] = 0;
    }
    memset(hash, 0, 16);
    md4(buf, i, hash, 0);
}
@

<<function [[mschalresp]]>>=
void
mschalresp(uchar resp[MSresplen], uchar hash[MShashlen], uchar chal[MSchallen])
{
    int i;
    uchar buf[21];
    
    memset(buf, 0, sizeof(buf));
    memcpy(buf, hash, MShashlen);

    for(i=0; i<3; i++) {
        memmove(resp+i*MSchallen, chal, MSchallen);
        desencrypt(resp+i*MSchallen, buf+i*7);
    }
}
@

<<function [[getchap]]>>=
static void
getchap(PPP *ppp, Block *b)
{
    AuthInfo *ai;
    Lcpmsg *m;
    int len, vlen, i, id, n, nresp;
    char md5buf[512], code;
    Chap *c;
    Chapreply cr;
    MSchapreply mscr;
    char uid[PATH];
    uchar digest[16], *p, *resp, sdigest[SHA1dlen];
    uchar mshash[MShashlen], mshash2[MShashlen];
    DigestState *s;
    uchar msresp[2*MSresplen+1];

    m = (Lcpmsg*)b->rptr;
    len = nhgets(m->len);
    if(BLEN(b) < len){
        syslog(0, LOG, "short chap message");
        freeb(b);
        return;
    }

    qlock(ppp);

    switch(m->code){
    case Cchallenge:
        getauth(ppp);

        vlen = m->data[0];
        if(vlen > len - 5) {
            netlog("PPP: chap: bad challenge len\n");
            break;
        }

        id = m->id;
        switch(ppp->chap->proto){
        default:
            abort();
        case APmd5:
            md5buf[0] = m->id;
            strcpy(md5buf+1, ppp->secret);
            n = strlen(ppp->secret) + 1;
            memmove(md5buf+n, m->data+1, vlen);
            n += vlen;
            md5((uchar*)md5buf, n, digest, nil);
            resp = digest;
            nresp = 16;
            break;
        case APmschap:
            nthash(mshash, ppp->secret);
            memset(msresp, 0, sizeof msresp);
            mschalresp(msresp+MSresplen, mshash, m->data+1);
            resp = msresp;
            nresp = sizeof msresp;
            nthash(mshash, ppp->secret);
            md4(mshash, 16, mshash2, 0);
            s = sha1(mshash2, 16, 0, 0);
            sha1(mshash2, 16, 0, s);
            sha1(m->data+1, 8, sdigest, s);
            memmove(ppp->key, sdigest, 16);
            break;
        }
        len = 4 + 1 + nresp + strlen(ppp->chapname);
        freeb(b);
        b = alloclcp(Cresponse, id, len, &m);
        *b->wptr++ = nresp;
        memmove(b->wptr, resp, nresp);
        b->wptr += nresp;
        memmove(b->wptr, ppp->chapname, strlen(ppp->chapname));
        b->wptr += strlen(ppp->chapname);
        hnputs(m->len, len);
        netlog("PPP: sending response len %d\n", len);
        putframe(ppp, Pchap, b);
        break;
    case Cresponse:
        c = ppp->chap;
        vlen = m->data[0];
        if(m->id != c->id) {
            netlog("PPP: chap: bad response id\n");
            break;
        }
        switch(c->proto) {
        default:
            sysfatal("unknown chap protocol: %d", c->proto);
        case APmd5:
            if(vlen > len - 5 || vlen != 16) {
                netlog("PPP: chap: bad response len\n");
                break;
            }

            cr.id = m->id;
            memmove(cr.resp, m->data+1, 16);
            memset(uid, 0, sizeof(uid));
            n = len-5-vlen;
            if(n >= PATH)
                n = PATH-1;
            memmove(uid, m->data+1+vlen, n);
            c->cs->user = uid;
            c->cs->resp = &cr;
            c->cs->nresp = sizeof cr;
            break;
        case APmschap:
            if(vlen > len - 5 || vlen != 49) {
                netlog("PPP: chap: bad response len\n");
                break;
            }
            memset(&mscr, 0, sizeof(mscr));
            memmove(mscr.LMresp, m->data+1, 24);
            memmove(mscr.NTresp, m->data+24+1, 24);
            n = len-5-vlen;
            p = m->data+1+vlen;
            /* remove domain name */
            for(i=0; i<n; i++) {
                if(p[i] == '\\') {
                    p += i+1;
                    n -= i+1;
                    break;
                }
            }
            if(n >= PATH)
                n = PATH-1;
            memset(uid, 0, sizeof(uid));
            memmove(uid, p, n);
            c->cs->user = uid;
            c->cs->resp = &mscr;
            c->cs->nresp = sizeof mscr;
            break;
        } 

        syslog(0, LOG, ": remote=%I vlen %d proto %d response user %s nresp %d", ppp->remote, vlen, c->proto, c->cs->user, c->cs->nresp);
        if((ai = auth_response(c->cs)) == nil || auth_chuid(ai, nil) < 0){
            c->state = Cunauth;
            code = Cfailure;
            syslog(0, LOG, ": remote=%I: auth failed: %r, uid=%s", ppp->remote, uid);
        }else{
            c->state = Cauthok;
            code = Csuccess;
            syslog(0, LOG, ": remote=%I: auth ok: uid=%s nsecret=%d", ppp->remote, uid, ai->nsecret);
            if(c->proto == APmschap){
                if(ai->nsecret != sizeof(ppp->key))
                    sysfatal("could not get the encryption key");
                memmove(ppp->key, ai->secret, sizeof(ppp->key));
            }
        }
        auth_freeAI(ai);
        auth_freechal(c->cs);
        c->cs = nil;
        freeb(b);

        /* send reply */
        len = 4;
        b = alloclcp(code, c->id, len, &m);
        hnputs(m->len, len);
        putframe(ppp, Pchap, b);

        if(c->state == Cauthok) {
            setphase(ppp, Pnet);
        } else {
            /* restart chapp negotiation */
            chapinit(ppp);
        }
        
        break;
    case Csuccess:
        netlog("ppp: chap succeeded\n");
        break;
    case Cfailure:
        netlog("ppp: chap failed\n");
        break;
    default:
        syslog(0, LOG, "chap code %d?\n", m->code);
        break;
    }
    qunlock(ppp);
    freeb(b);
}
@

<<function [[putpaprequest]]>>=
static void
putpaprequest(PPP *ppp)
{
    Block *b;
    Lcpmsg *m;
    Chap *c;
    int len, nlen, slen;

    getauth(ppp);

    c = ppp->chap;
    c->id++;
    netlog("PPP: pap: send authreq %d %s %s\n", c->id, ppp->chapname, "****");

    nlen = strlen(ppp->chapname);
    slen = strlen(ppp->secret);
    len = 4 + 1 + nlen + 1 + slen;
    b = alloclcp(Pauthreq, c->id, len, &m);

    *b->wptr++ = nlen;
    memmove(b->wptr, ppp->chapname, nlen);
    b->wptr += nlen;
    *b->wptr++ = slen;
    memmove(b->wptr, ppp->secret, slen);
    b->wptr += slen;
    hnputs(m->len, len);

    putframe(ppp, Ppasswd, b);
    freeb(b);
}
@

<<function [[papinit]]>>=
static void
papinit(PPP *ppp)
{
    ppp->chap->id = 0;
    putpaprequest(ppp);
}
@

<<function [[getpap]]>>=
static void
getpap(PPP *ppp, Block *b)
{
    Lcpmsg *m;
    int len;

    m = (Lcpmsg*)b->rptr;
    len = 4;
    if(BLEN(b) < 4 || BLEN(b) < (len = nhgets(m->len))){
        syslog(0, LOG, "short pap message (%ld < %d)", BLEN(b), len);
        freeb(b);
        return;
    }
    if(len < sizeof(Lcpmsg))
        m->data[0] = 0;

    qlock(ppp);
    switch(m->code){
    case Pauthreq:
        netlog("PPP: pap auth request, not supported\n");
        break;
    case Pauthack:
        if(ppp->phase == Pauth
        && ppp->chap->proto == APpasswd
        && m->id <= ppp-> chap->id){
            netlog("PPP: pap succeeded\n");
            setphase(ppp, Pnet);
        }
        break;
    case Pauthnak:
        if(ppp->phase == Pauth
        && ppp->chap->proto == APpasswd
        && m->id <= ppp-> chap->id){
            netlog("PPP: pap failed (%d:%.*s)\n",
                m->data[0], m->data[0], (char*)m->data+1);
            terminate(ppp, 0);
        }
        break;
    default:
        netlog("PPP: unknown pap messsage %d\n", m->code);
    }
    qunlock(ppp);
    freeb(b);
}
@

<<function [[printopts]]>>=
static void
printopts(Pstate *p, Block *b, int send)
{
    Lcpmsg *m;	
    Lcpopt *o;
    int proto, x, period;
    uchar *cp;
    char *code, *dir;

    m = (Lcpmsg*)b->rptr;
    switch(m->code) {
    default: code = "<unknown>"; break;
    case Lconfreq: code = "confrequest"; break;
    case Lconfack: code = "confack"; break;
    case Lconfnak: code = "confnak"; break;
    case Lconfrej: code = "confreject"; break;
    }

    if(send)
        dir = "send";
    else
        dir = "recv";

    netlog("ppp: %s %s: id=%d\n", dir, code, m->id);

    for(cp = m->data; cp < b->wptr; cp += o->len){
        o = (Lcpopt*)cp;
        if(cp + o->len > b->wptr){
            netlog("\tbad option length %ux\n", o->type);
            return;
        }

        switch(p->proto){
        case Plcp:
            switch(o->type){
            default:
                netlog("\tunknown %d len=%d\n", o->type, o->len);
                break;
            case Omtu:
                netlog("\tmtu = %d\n", nhgets(o->data));
                break;
            case Octlmap:
                netlog("\tctlmap = %ux\n", nhgetl(o->data));
                break;
            case Oauth:
                netlog("\tauth = %ux", nhgetl(o->data));
                proto = nhgets(o->data);
                switch(proto) {
                default:
                    netlog("unknown auth proto %d\n", proto);
                    break;
                case Ppasswd:
                    netlog("password\n");
                    break;
                case Pchap:
                    netlog("chap %ux\n", o->data[2]);
                    break;
                }
                break;
            case Oquality:
                proto = nhgets(o->data);
                switch(proto) {
                default:
                    netlog("\tunknown quality proto %d\n", proto);
                    break;
                case Plqm:
                    x = nhgetl(o->data+2)*10;
                    period = (x+Period-1)/Period;
                    netlog("\tlqm period = %d\n", period);
                    break;
                }
            case Omagic:
                netlog("\tmagic = %ux\n", nhgetl(o->data));
                break;
            case Opc:
                netlog("\tprotocol compress\n");
                break;
            case Oac:
                netlog("\taddr compress\n");
                break;
            }
            break;
        case Pccp:
            switch(o->type){
            default:
                netlog("\tunknown %d len=%d\n", o->type, o->len);
                break;
            case Ocoui:	
                netlog("\tOUI\n");
                break;
            case Ocstac:
                netlog("\tstac LZS\n");
                break;
            case Ocmppc:	
                netlog("\tMicrosoft PPC len=%d %ux\n", o->len, nhgetl(o->data));
                break;
            case Octhwack:	
                netlog("\tThwack\n");
                break;
            }
            break;
        case Pecp:
            switch(o->type){
            default:
                netlog("\tunknown %d len=%d\n", o->type, o->len);
                break;
            case Oeoui:	
                netlog("\tOUI\n");
                break;
            case Oedese:
                netlog("\tDES\n");
                break;
            }
            break;
        case Pipcp:
            switch(o->type){
            default:
                netlog("\tunknown %d len=%d\n", o->type, o->len);
                break;
            case Oipaddrs:	
                netlog("\tip addrs - deprecated\n");
                break;
            case Oipcompress:
                netlog("\tip compress\n");
                break;
            case Oipaddr:	
                netlog("\tip addr %V\n", o->data);
                break;
            case Oipdns:	
                netlog("\tdns addr %V\n", o->data);
                break;
            case Oipwins:	
                netlog("\twins addr %V\n", o->data);
                break;
            case Oipdns2:	
                netlog("\tdns2 addr %V\n", o->data);
                break;
            case Oipwins2:	
                netlog("\twins2 addr %V\n", o->data);
                break;
            }
            break;
        }
    }
}
@

<<function [[sendtermreq]]>>=
static void
sendtermreq(PPP *ppp, Pstate *p)
{
    Block *b;
    Lcpmsg *m;

    p->termid = ++(p->id);
    b = alloclcp(Ltermreq, p->termid, 4, &m);
    hnputs(m->len, 4);
    putframe(ppp, p->proto, b);
    freeb(b);
    newstate(ppp, p, Sclosing);
}
@

<<function [[sendechoreq]]>>=
static void
sendechoreq(PPP *ppp, Pstate *p)
{
    Block *b;
    Lcpmsg *m;

    p->termid = ++(p->id);
    b = alloclcp(Lechoreq, p->id, 4, &m);
    hnputs(m->len, 4);
    putframe(ppp, p->proto, b);
    freeb(b);
}
@

<<enum [[_anon_ (networking/ip/ppp/ppp.c)4]]>>=
enum
{
    CtrlD	= 0x4,
    CtrlE	= 0x5,
    CtrlO	= 0xf,
    Cr	= 13,
    View	= 0x80,
};
@

<<global [[conndone]]>>=
int conndone;
@

<<function [[xfer]]>>=
static void
xfer(int fd)
{
    int i, n;
    uchar xbuf[128];

    for(;;) {
        n = read(fd, xbuf, sizeof(xbuf));
        if(n < 0)
            break;
        if(conndone)
            break;
        for(i = 0; i < n; i++)
            if(xbuf[i] == Cr)
                xbuf[i] = ' ';
        write(1, xbuf, n);
    }
    close(fd);
}
@

<<function [[readcr]]>>=
static int
readcr(int fd, char *buf, int nbuf)
{
    char c;
    int n, tot;

    tot = 0;
    while((n=read(fd, &c, 1)) == 1){
        if(c == '\n'){
            buf[tot] = 0;
            return tot;
        }
        buf[tot++] = c;
        if(tot == nbuf)
            sysfatal("line too long in readcr");
    }
    return n;
}
@

<<function [[connect]]([[(networking/ip/ppp/ppp.c)]])>>=
static void
connect(int fd, int cfd)
{
    int n, ctl;
    char xbuf[128];

    if (chatfile) {
        int chatfd, lineno, nb;
        char *buf, *p, *s, response[128];
        Dir *dir;

        if ((chatfd = open(chatfile, OREAD)) < 0)
            sysfatal("cannot open %s: %r", chatfile);

        if ((dir = dirfstat(chatfd)) == nil)
            sysfatal("cannot fstat %s: %r",chatfile);

        buf = (char *)malloc(dir->length + 1);
        assert(buf);

        if ((nb = read(chatfd, buf, dir->length)) < 0)
            sysfatal("cannot read chatfile %s: %r", chatfile);
        assert(nb == dir->length);
        buf[dir->length] = '\0';
        free(dir);
        close(chatfd);

        p = buf;
        lineno = 0;
        for(;;) {
            char *_args[3];

            if ((s = strchr(p, '\n')) == nil)
                break;
            *s++ = '\0';
        
            lineno++;

            if (*p == '#') {
                p = s; 
                continue;
            }

            if (tokenize(p, _args, 3) != 2)
                sysfatal("invalid line %d (line expected: 'send' 'expect')", 
                        lineno);

            if (debug)
                print("sending %s, expecting %s\n", _args[0], _args[1]);

            if(strlen(_args[0])){
                nb = fprint(fd, "%s\r", _args[0]);
                assert(nb > 0);
            }

            if (strlen(_args[1]) > 0) {
                if ((nb = readcr(fd, response, sizeof response-1)) < 0)
                    sysfatal("cannot read response from: %r");

                if (debug)
                    print("response %s\n", response);

                if (nb == 0)
                    sysfatal("eof on input?");

                if (cistrstr(response, _args[1]) == nil)
                    sysfatal("expected %s, got %s", _args[1], response);
            }
            p = s;
        }
        free(buf);
        return;
    }

    print("Connect to file system now, type ctrl-d when done.\n");
    print("...(Use the view or down arrow key to send a break)\n");
    print("...(Use ctrl-e to set even parity or ctrl-o for odd)\n");

    ctl = open("/dev/consctl", OWRITE);
    if(ctl < 0)
        sysfatal("opening consctl");
    fprint(ctl, "rawon");

    fd = dup(fd, -1);
    conndone = 0;
    switch(rfork(RFPROC|RFMEM|RFNOWAIT)){
    case -1:
        sysfatal("forking xfer");
    case 0:
        xfer(fd);
        _exits(nil);
    }

    for(;;){
        read(0, xbuf, 1);
        switch(xbuf[0]&0xff) {
        case CtrlD:	/* done */
            conndone = 1;
            close(ctl);
            print("\n");
            return;
        case CtrlE:	/* set even parity */
            fprint(cfd, "pe");
            break;
        case CtrlO:	/* set odd parity */
            fprint(cfd, "po");
            break;
        case View:	/* send a break */
            fprint(cfd, "k500");
            break;
        default:
            n = write(fd, xbuf, 1);
            if(n < 0) {
                errstr(xbuf, sizeof(xbuf));
                conndone = 1;
                close(ctl);
                print("[remote write error (%s)]\n", xbuf);
                return;
            }
        }
    }
}
@

<<global [[interactive]]>>=
int interactive;
@

<<function [[usage]]([[(networking/ip/ppp/ppp.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: ppp [-CPSacdfu] [-b baud] [-k keyspec] [-m mtu] "
        "[-M chatfile] [-p dev] [-x netmntpt] [-t modemcmd] "
        "[local-addr [remote-addr]]\n");
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/ppp/ppp.c)]])>>=
void
main(int argc, char **argv)
{
    int mtu, baud, framing, user, mediain, mediaout, cfd;
    Ipaddr ipaddr, remip;
    char *dev, *modemcmd;
    char net[128];
    PPP *ppp;
    char buf[128];

    rfork(RFREND|RFNOTEG|RFNAMEG);

    fmtinstall('I', eipfmt);
    fmtinstall('V', eipfmt);
    fmtinstall('E', eipfmt);

    dev = nil;

    invalidate(ipaddr);
    invalidate(remip);

    mtu = Defmtu;
    baud = 0;
    framing = 0;
    setnetmtpt(net, sizeof(net), nil);
    user = 0;
    modemcmd = nil;

    ARGBEGIN{
    case 'a':
        noauth = 1;
        break;
    case 'b':
        baud = atoi(EARGF(usage()));
        if(baud < 0)
            baud = 0;
        break;
    case 'c':
        nocompress = 1;
        break;
    case 'C':
        noipcompress = 1;
        break;
    case 'd':
        debug++;
        break;
    case 'f':
        framing = 1;
        break;
    case 'F':
        pppframing = 0;
        break;
    case 'k':
        keyspec = EARGF(usage());
        break;
    case 'm':
        mtu = atoi(EARGF(usage()));
        if(mtu < Minmtu)
            mtu = Minmtu;
        if(mtu > Maxmtu)
            mtu = Maxmtu;
        break;
    case 'M':
        chatfile = EARGF(usage());
        break;
    case 'p':
        dev = EARGF(usage());
        break;
    case 'P':
        primary = 1;
        break;
    case 'S':
        server = 1;
        break;
    case 't':
        modemcmd = EARGF(usage());
        break;
    case 'u':
        user = 1;
        break;
    case 'x':
        setnetmtpt(net, sizeof net, EARGF(usage()));
        break;
    default:
        fprint(2, "unknown option %c\n", ARGC());
        usage();
    }ARGEND;

    switch(argc){
    case 2:
        if (parseip(remip, argv[1]) == -1)
            sysfatal("bad remote ip %s", argv[1]);
    case 1:
        if (parseip(ipaddr, argv[0]) == -1)
            sysfatal("bad ip %s", argv[0]);
    case 0:
        break;
    default:
        usage();
    }

    nip = nipifcs(net);
    if(nip == 0 && !server)
        primary = 1;

    if(dev != nil){
        mediain = open(dev, ORDWR);
        if(mediain < 0){
            if(strchr(dev, '!')){
                if((mediain = dial(dev, 0, 0, &cfd)) == -1){
                    fprint(2, "ppp: couldn't dial %s: %r\n", dev);
                    exits(dev);
                }
            } else {
                fprint(2, "ppp: couldn't open %s\n", dev);
                exits(dev);
            }
        } else {
            snprint(buf, sizeof buf, "%sctl", dev);
            cfd = open(buf, ORDWR);
        }
        if(cfd > 0){
            if(baud)
                fprint(cfd, "b%d", baud);
            fprint(cfd, "m1");	/* cts/rts flow control (and fifo's) on */
            fprint(cfd, "q64000");	/* increase q size to 64k */
            fprint(cfd, "n1");	/* nonblocking writes on */
            fprint(cfd, "r1");	/* rts on */
            fprint(cfd, "d1");	/* dtr on */
            fprint(cfd, "c1");	/* dcdhup on */
            if(user || chatfile)
                connect(mediain, cfd);
            close(cfd);
        } else {
            if(user || chatfile)
                connect(mediain, -1);
        }
        mediaout = mediain;
    } else {
        mediain = open("/fd/0", OREAD);
        if(mediain < 0){
            fprint(2, "ppp: couldn't open /fd/0\n");
            exits("/fd/0");
        }
        mediaout = open("/fd/1", OWRITE);
        if(mediaout < 0){
            fprint(2, "ppp: couldn't open /fd/0\n");
            exits("/fd/1");
        }
    }

    if(modemcmd != nil && mediaout >= 0)
        fprint(mediaout, "%s\r", modemcmd);

    ppp = mallocz(sizeof(*ppp), 1);
    pppopen(ppp, mediain, mediaout, net, ipaddr, remip, mtu, framing);

    /* wait until ip is configured */
    rendezvous((void*)Rmagic, 0);

    if(primary){
        /* create a /net/ndb entry */
        putndb(ppp, net);
    }

    exits(0);
}
@

<<function [[netlog]]([[(networking/ip/ppp/ppp.c)]])>>=
void
netlog(char *fmt, ...)
{
    va_list arg;
    char *m;
    static long start;
    long now;

    if(debug == 0)
        return;

    now = time(0);
    if(start == 0)
        start = now;

    va_start(arg, fmt);
    m = vsmprint(fmt, arg);
    fprint(2, "%ld %s", now-start, m);
    free(m);
    va_end(arg);
}
@

<<function [[validv4]]>>=
/*
 *  return non-zero if this is a valid v4 address
 */
static int
validv4(Ipaddr addr)
{
    return memcmp(addr, v4prefix, IPv4off) == 0 && memcmp(addr, v4prefix, IPaddrlen) != 0;
}
@

<<function [[invalidate]]([[(networking/ip/ppp/ppp.c)]])>>=
static void
invalidate(Ipaddr addr)
{
    ipmove(addr, IPnoaddr);
}
@

<<function [[nipifcs]]([[(networking/ip/ppp/ppp.c)]])>>=
/*
 *  return number of networks
 */
static int
nipifcs(char *net)
{
    static Ipifc *ifc;
    Ipifc *nifc;
    Iplifc *lifc;
    int n;

    n = 0;
    ifc = readipifc(net, ifc, -1);
    for(nifc = ifc; nifc != nil; nifc = nifc->next)
        for(lifc = ifc->lifc; lifc != nil; lifc = lifc->next)
            n++;
    return n;
}
@

<<function [[putndb]]([[(networking/ip/ppp/ppp.c)]])>>=
/*
 *   make an ndb entry and put it into /net/ndb for the servers to see
 */
static void
putndb(PPP *ppp, char *net)
{
    char buf[1024];
    char file[64];
    char *p, *e;
    int fd;

    e = buf + sizeof(buf);
    p = buf;
    p = seprint(p, e, "ip=%I ipmask=255.255.255.255 ipgw=%I\n", ppp->local,
            ppp->remote);
    if(validv4(ppp->dns[0]))
        p = seprint(p, e, "\tdns=%I\n", ppp->dns[0]);
    if(validv4(ppp->dns[1]))
        p = seprint(p, e, "\tdns=%I\n", ppp->dns[1]);
    if(validv4(ppp->wins[0]))
        p = seprint(p, e, "\twins=%I\n", ppp->wins[0]);
    if(validv4(ppp->wins[1]))
        p = seprint(p, e, "\twins=%I\n", ppp->wins[1]);
    seprint(file, file+sizeof file, "%s/ndb", net);
    fd = open(file, OWRITE);
    if(fd < 0)
        return;
    write(fd, buf, p-buf);
    close(fd);
    seprint(file, file+sizeof file, "%s/cs", net);
    fd = open(file, OWRITE);
    write(fd, "refresh", 7);
    close(fd);
    seprint(file, file+sizeof file, "%s/dns", net);
    fd = open(file, OWRITE);
    write(fd, "refresh", 7);
    close(fd);
}
@

<<function [[getauth]]>>=
static void
getauth(PPP *ppp)
{
    UserPasswd *up;

    if(*ppp->chapname)
        return;

    up = auth_getuserpasswd(auth_getkey,"proto=pass service=ppp %s", keyspec);
    if(up != nil){
        strcpy(ppp->chapname, up->user);
        strcpy(ppp->secret, up->passwd);
    }		
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/ppp.c>>=
/*
 * ppp - point-to-point protocol, rfc1331
 */
#include <u.h>
#include <libc.h>
#include <auth.h>
#include <bio.h>
#include <ip.h>
#include <libsec.h>
#include <ndb.h>
#include "ppp.h"

<<constant [[PATH]]>>

<<global [[baud]]([[(networking/ip/ppp/ppp.c)]])>>
<<global [[nocompress]]>>
<<global [[pppframing]]>>
<<global [[noipcompress]]>>
<<global [[server]]([[(networking/ip/ppp/ppp.c)]])>>
<<global [[noauth]]>>
<<global [[nip]]([[(networking/ip/ppp/ppp.c)]])>>
<<global [[dying]]([[(networking/ip/ppp/ppp.c)]])>>
<<global [[primary]]>>
<<global [[chatfile]]>>

<<global [[debug]]([[(networking/ip/ppp/ppp.c)]])>>
<<global [[LOG]]>>
<<global [[keyspec]]([[(networking/ip/ppp/ppp.c)]])>>

<<enum [[_anon_ (networking/ip/ppp/ppp.c)]]>>

<<global [[fcstab]]([[(networking/ip/ppp/ppp.c)]])>>

<<global [[snames]]>>

static	void		authtimer(PPP*);
static	void		chapinit(PPP*);
static	void		config(PPP*, Pstate*, int);
static	uchar*		escapeuchar(PPP*, ulong, uchar*, ushort*);
static	void		getchap(PPP*, Block*);
static	Block*		getframe(PPP*, int*);
static	void		getlqm(PPP*, Block*);
static	int		getopts(PPP*, Pstate*, Block*);
static	void		getpap(PPP*, Block*);
static	void		init(PPP*);
static	void		invalidate(Ipaddr);
static	void		ipinproc(PPP*);
static	char*		ipopen(PPP*);
static	void		mediainproc(PPP*);
static	void		newstate(PPP*, Pstate*, int);
static	int		nipifcs(char*);
static	void		papinit(PPP*);
static	void		pinit(PPP*, Pstate*);
static	void		ppptimer(PPP*);
static	void		printopts(Pstate*, Block*, int);
static	void		ptimer(PPP*, Pstate*);
static	int		putframe(PPP*, int, Block*);
static	void		putlqm(PPP*);
static	void		putndb(PPP*, char*);
static	void		putpaprequest(PPP*);
static	void		rcv(PPP*, Pstate*, Block*);
static	void		rejopts(PPP*, Pstate*, Block*, int);
static	void		sendechoreq(PPP*, Pstate*);
static	void		sendtermreq(PPP*, Pstate*);
static	void		setphase(PPP*, int);
static	void		terminate(PPP*, int);
static	int		validv4(Ipaddr);
static  void		dmppkt(char *s, uchar *a, int na);
static	void		getauth(PPP*);

<<function [[pppopen]]>>

<<function [[init]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[setphase]]>>

<<function [[pinit]]>>

<<function [[newstate]]>>

<<function [[getframe]]>>

<<function [[putframe]]>>

<<function [[alloclcp]]>>


<<function [[putlo]]>>

<<function [[putv4o]]>>

<<function [[putso]]>>

<<function [[puto]]>>

<<function [[config]]>>

<<function [[getipinfo]]>>

<<function [[getopts]]>>
<<function [[dmppkt]]>>

<<function [[dropoption]]>>

<<function [[rejopts]]>>


<<function [[rcv]]>>

<<function [[ptimer]]>>

<<function [[authtimer]]>>


<<function [[ppptimer]]>>

<<function [[setdefroute]]>>

<<enum [[_anon_ (networking/ip/ppp/ppp.c)2]]>>
<<global [[old]]>>

<<function [[ipopen]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[pppread]]>>

<<function [[pppwrite]]>>

<<function [[terminate]]>>

typedef struct Iphdr Iphdr;
<<struct [[Iphdr]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[ipinproc]]>>

<<function [[catchdie]]>>

<<function [[hexdump]]>>

<<function [[mediainproc]]>>

<<function [[getlqm]]>>

<<function [[putlqm]]>>

<<function [[chapinit]]>>

<<enum [[_anon_ (networking/ip/ppp/ppp.c)3]]>>

<<function [[desencrypt]]>>

<<function [[nthash]]>>

<<function [[mschalresp]]>>

/*
 *  challenge response dialog
 */
extern	int	_asrdresp(int, uchar*, int);

<<function [[getchap]]>>

<<function [[putpaprequest]]>>

<<function [[papinit]]>>

<<function [[getpap]]>>

<<function [[printopts]]>>

<<function [[sendtermreq]]>>

<<function [[sendechoreq]]>>

<<enum [[_anon_ (networking/ip/ppp/ppp.c)4]]>>

<<global [[conndone]]>>

<<function [[xfer]]>>

<<function [[readcr]]>>

<<function [[connect]]([[(networking/ip/ppp/ppp.c)]])>>

<<global [[interactive]]>>

<<function [[usage]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[main]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[netlog]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[validv4]]>>

<<function [[invalidate]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[nipifcs]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[putndb]]([[(networking/ip/ppp/ppp.c)]])>>

<<function [[getauth]]>>
@


\subsection*{[[networking/ip/ppp/ppp.h]]}

<<struct [[Block]]([[(networking/ip/ppp/ppp.h)]])>>=
/*
 *  data blocks
 */
struct Block
{
    Block	*next;
    Block	*flist;
    Block	*list;			/* chain of block lists */
    uchar	*rptr;			/* first unconsumed uchar */
    uchar	*wptr;			/* first empty uchar */
    uchar	*lim;			/* 1 past the end of the buffer */
    uchar	*base;			/* start of the buffer */
    uchar	flags;
    void	*flow;
    ulong	pc;
    ulong	bsz;
};
@

<<macro [[BLEN]]>>=
#define BLEN(b)	((b)->wptr-(b)->rptr)
@

<<enum [[_anon_ (networking/ip/ppp/ppp.h)]]>>=
enum
{
    /* block flags */
    S_DELIM 	= (1<<0),
    S_HANGUP	= (1<<1),
    S_RHANGUP	= (1<<2),

    /* queue states */
    QHUNGUP		= (1<<0),
    QFLOW		= (1<<1),	/* queue is flow controlled */
};
@

<<enum [[_anon_ (networking/ip/ppp/ppp.h)2]]>>=
enum {
    HDLC_frame=	0x7e,
    HDLC_esc=	0x7d,

    /* PPP frame fields */
    PPP_addr=	0xff,
    PPP_ctl=	0x3,
    PPP_initfcs=	0xffff,
    PPP_goodfcs=	0xf0b8,

    /* PPP phases */
    Pdead=		0,	
    Plink,				/* doing LCP */
    Pauth,				/* doing chap */
    Pnet,				/* doing IPCP, CCP */
    Pterm,				/* closing down */

    /* PPP protocol types */
    Pip=		0x21,		/* ip v4 */
    Pipv6=		0x57,		/* ip v6 */
    Pvjctcp=	0x2d,		/* compressing van jacobson tcp */
    Pvjutcp=	0x2f,		/* uncompressing van jacobson tcp */
    Pcdata=		0xfd,		/* compressed datagram */
    Pipcp=		0x8021,		/* ip control */
    Pecp=		0x8053,		/* encryption control */
    Pccp=		0x80fd,		/* compressed datagram control */
    Plcp=		0xc021,		/* link control */
    Ppasswd=	0xc023,		/* passwd authentication */
    Plqm=		0xc025,		/* link quality monitoring */
    Pchap=		0xc223,		/* challenge/response */

    /* LCP codes */
    Lconfreq=	1,
    Lconfack=	2,
    Lconfnak=	3,
    Lconfrej=	4,
    Ltermreq=	5,
    Ltermack=	6,
    Lcoderej=	7,
    Lprotorej=	8,
    Lechoreq=	9,
    Lechoack=	10,
    Ldiscard=	11,
    Lresetreq=	14,
    Lresetack=	15,

    /* Lcp configure options */
    Omtu=		1,
    Octlmap=	2,
    Oauth=		3,
    Oquality=	4,
    Omagic=		5,
    Opc=		7,
    Oac=		8,

    /* authentication protocols */
    APmd5=		5,
    APmschap=	128,
    APpasswd=	Ppasswd,		/* use Pap, not Chap */

    /* lcp flags */
    Fmtu=		1<<Omtu,
    Fctlmap=	1<<Octlmap,
    Fauth=		1<<Oauth,
    Fquality=	1<<Oquality,
    Fmagic=		1<<Omagic,
    Fpc=		1<<Opc,
    Fac=		1<<Oac,

    /* Chap codes */
    Cchallenge=	1,
    Cresponse=	2,
    Csuccess=	3,
    Cfailure=	4,

    /* Pap codes */
    Pauthreq=	1,
    Pauthack=	2,
    Pauthnak=	3,

    /* Chap state */
    Cunauth=	0,
    Cchalsent,
    Cauthfail,
    Cauthok,

    /* link states */
    Sclosed=	0,
    Sclosing,
    Sreqsent,
    Sackrcvd,
    Sacksent,
    Sopened,

    /* ccp configure options */
    Ocoui=		0,	/* proprietary compression */
    Ocstac=		17,	/* stac electronics LZS */
    Ocmppc=		18,	/* microsoft ppc */
    Octhwack=	31,	/* thwack; unofficial */

    /* ccp flags */
    Fcoui=		1<<Ocoui,
    Fcstac=		1<<Ocstac,
    Fcmppc=		1<<Ocmppc,
    Fcthwack=	1<<Octhwack,

    /* ecp configure options */
    Oeoui=		0,	/* proprietary compression */
    Oedese=		1,	/* DES */

    /* ecp flags */
    Feoui=		1<<Oeoui,
    Fedese=		1<<Oedese,

    /* ipcp configure options */
    Oipaddrs=	1,
    Oipcompress=	2,
    Oipaddr=	3,
    Oipdns=		129,
    Oipwins=	130,
    Oipdns2=	131,
    Oipwins2=	132,

    /* ipcp flags */
    Fipaddrs=	1<<Oipaddrs,
    Fipcompress=	1<<Oipcompress,
    Fipaddr=	1<<Oipaddr,
    Fipdns=		1<<8, 	// Oipdns,
    Fipwins=	1<<9,	// Oipwins,
    Fipdns2=	1<<10,	// Oipdns2,
    Fipwins2=	1<<11,	// Oipwins2,

    Period=		5*1000,	/* period of retransmit process (in ms) */
    Timeout=	20,	/* xmit timeout (in Periods) */
    Buflen=		4096,

    MAX_STATES=	16,		/* van jacobson compression states */
    Defmtu=		1450,		/* default that we will ask for */
    Minmtu=		128,		/* minimum that we will accept */
    Maxmtu=		2000,		/* maximum that we will accept */
};
@

<<struct [[Pstate]]>>=
struct Pstate
{
    int	proto;		/* protocol type */
    int	timeout;	/* for current state */
    int	rxtimeout;	/* for current retransmit */
    ulong	flags;		/* options received */
    uchar	id;		/* id of current message */
    uchar	confid;		/* id of current config message */
    uchar	termid;		/* id of current termination message */
    uchar	rcvdconfid;	/* id of last conf message received */
    uchar	state;		/* PPP link state */
    ulong	optmask;	/* which options to request */
    int	echoack;	/* recieved echo ack */
    int	echotimeout;	/* echo timeout */
};
@

<<struct [[Chap]]>>=
/* server chap state */
struct Chap
{
    int	proto;		/* chap proto */
    int	state;		/* chap state */
    uchar	id;		/* id of current message */
    int	timeout;	/* for current state */
    Chalstate *cs;
};
@

<<struct [[Qualstats]]>>=
struct Qualstats
{
    ulong	reports;
    ulong	packets;
    ulong	uchars;
    ulong	discards;
    ulong	errors;
};
@

<<struct [[Comptype]]>>=
struct Comptype
{
    void*		(*init)(PPP*);
    Block*		(*compress)(PPP*, ushort, Block*, int*);
    Block*		(*resetreq)(void*, Block*);
    void		(*fini)(void*);
};
@

<<struct [[Uncomptype]]>>=
struct Uncomptype
{
    void*		(*init)(PPP*);
    Block*		(*uncompress)(PPP*, Block*, int*, Block**);
    void		(*resetack)(void*, Block*);
    void		(*fini)(void*);
};
@

<<struct [[PPP]]>>=
struct PPP
{
    QLock;

    int		ipfd;		/* fd to ip stack */
    int		ipcfd;		/* fd to control channel of ip stack */
    int		mediain;	/* fd to media */
    int		mediaout;	/* fd to media */
    char		*net;		/* ip stack to use */
    int		framing;	/* non-zero to use framing characters */
    Ipaddr		local;
    Ipaddr		curlocal;
    int		localfrozen;
    Ipaddr		remote;
    Ipaddr		curremote;
    int		remotefrozen;

    Ipaddr		dns[2];		/* dns servers */
    Ipaddr		wins[2];	/* wins servers */

    Block*		inbuf;		/* input buffer */
    Block*		outbuf;		/* output buffer */
    QLock		outlock;	/*  and its lock */
    ulong		magic;		/* magic number to detect loop backs */
    ulong		rctlmap;	/* map of chars to ignore in rcvr */
    ulong		xctlmap;	/* map of chars to excape in xmit */
    int		phase;		/* PPP phase */
    Pstate*		lcp;		/* lcp state */
    Pstate*		ccp;		/* ccp state */
    Pstate*		ipcp;		/* ipcp state */
    Chap*		chap;		/* chap state */
    Tcpc*		ctcp;		/* tcp compression state */
    ulong		mtu;		/* maximum xmit size */
    ulong		mru;		/* maximum recv size */

    /* data compression */
    int		ctries;		/* number of negotiation tries */
    Comptype	*ctype;		/* compression virtual table */
    void		*cstate;	/* compression state */
    Uncomptype	*unctype;	/* uncompression virtual table */
    void		*uncstate;	/* uncompression state */
    
    /* encryption key */
    uchar		key[16];
    int		sendencrypted;

    /* authentication */
    char		secret[256];	/* md5 key */
    char		chapname[256];	/* chap system name */

    /* link quality monitoring */
    int		period;	/* lqm period */
    int		timeout; /* time to next lqm packet */
    Qualstats	in;	/* local */
    Qualstats	out;
    Qualstats	pin;	/* peer */
    Qualstats	pout;
    Qualstats	sin;	/* saved */

    struct {
        ulong	ipsend;
        ulong	iprecv;
        ulong	iprecvbadsrc;
        ulong	iprecvnotup;
        ulong	comp;
        ulong	compin;
        ulong	compout;
        ulong	compreset;
        ulong	uncomp;
        ulong	uncompin;
        ulong	uncompout;
        ulong	uncompreset;
        ulong	vjin;
        ulong	vjout;
        ulong	vjfail;
    } stat;
};
@

<<struct [[Lcpmsg]]>>=
struct Lcpmsg
{
    uchar	code;
    uchar	id;
    uchar	len[2];
    uchar	data[1];
};
@

<<struct [[Lcpopt]]([[(networking/ip/ppp/ppp.h)]])>>=
struct Lcpopt
{
    uchar	type;
    uchar	len;
    uchar	data[1];
};
@

<<struct [[Qualpkt]]>>=
struct Qualpkt
{
    uchar	magic[4];

    uchar	lastoutreports[4];
    uchar	lastoutpackets[4];
    uchar	lastoutuchars[4];
    uchar	peerinreports[4];
    uchar	peerinpackets[4];
    uchar	peerindiscards[4];
    uchar	peerinerrors[4];
    uchar	peerinuchars[4];
    uchar	peeroutreports[4];
    uchar	peeroutpackets[4];
    uchar	peeroutuchars[4];
};
@


%-------------------------------------------------------------

<<networking/ip/ppp/ppp.h>>=
typedef struct Tcpc Tcpc;
typedef struct Pstate Pstate;
typedef struct Chap Chap;
typedef struct Qualstats Qualstats;
typedef struct Comptype Comptype;
typedef struct Uncomptype Uncomptype;
typedef struct PPP PPP;
typedef struct Lcpmsg Lcpmsg;
typedef struct Lcpopt Lcpopt;
typedef struct Qualpkt Qualpkt;
typedef struct Block Block;

typedef uchar Ipaddr[IPaddrlen];	

#pragma incomplete Tcpc

<<struct [[Block]]([[(networking/ip/ppp/ppp.h)]])>>
<<macro [[BLEN]]>>

<<enum [[_anon_ (networking/ip/ppp/ppp.h)]]>>

Block*	allocb(int);
void	freeb(Block*);
Block*	concat(Block*);
int	blen(Block*);
Block*	pullup(Block*, int);
Block*	padb(Block*, int);
Block*	btrim(Block*, int, int);
Block*	copyb(Block*, int);
int	pullb(Block**, int);

<<enum [[_anon_ (networking/ip/ppp/ppp.h)2]]>>


<<struct [[Pstate]]>>

<<struct [[Chap]]>>

<<struct [[Qualstats]]>>

<<struct [[Comptype]]>>

<<struct [[Uncomptype]]>>

<<struct [[PPP]]>>

extern Block*	pppread(PPP*);
extern int	pppwrite(PPP*, Block*);
extern void	pppopen(PPP*, int, int, char*, Ipaddr, Ipaddr, int, int);

<<struct [[Lcpmsg]]>>

<<struct [[Lcpopt]]([[(networking/ip/ppp/ppp.h)]])>>

<<struct [[Qualpkt]]>>

extern Block*	compress(Tcpc*, Block*, int*);
extern void	compress_error(Tcpc*);
extern Tcpc*	compress_init(Tcpc*);
extern int	compress_negotiate(Tcpc*, uchar*);
extern Block*	tcpcompress(Tcpc*, Block*, int*);
extern Block*	tcpuncompress(Tcpc*, Block*, int);
extern Block*	alloclcp(int, int, int, Lcpmsg**);
extern ushort	ptclcsum(Block*, int, int);
extern ushort	ptclbsum(uchar*, int);
extern ushort	ipcsum(uchar*);

extern	Comptype	cmppc;
extern	Uncomptype	uncmppc;

extern	Comptype	cthwack;
extern	Uncomptype	uncthwack;

extern void	netlog(char*, ...);
#pragma	varargck	argpos	netlog	1

extern char	*LOG;
@


\subsection*{[[networking/ip/ppp/testppp.c]]}

<<global [[debug]]([[(networking/ip/ppp/testppp.c)]])>>=
int	debug;
@

<<global [[errrate]]>>=
long	errrate;
@

<<global [[droprate]]>>=
long	droprate;
@

<<global [[framing]]>>=
int	framing;
@

<<global [[nocompress]]([[(networking/ip/ppp/testppp.c)]])>>=
int	nocompress;
@

<<global [[noipcompress]]([[(networking/ip/ppp/testppp.c)]])>>=
int	noipcompress;
@

<<global [[ppp]]([[(networking/ip/ppp/testppp.c)]])>>=
char	*ppp = "8.out";
@

<<global [[mtu]]>>=
char	*mtu;
@

<<function [[pppopen]]([[(networking/ip/ppp/testppp.c)]])>>=
void
pppopen(int fd, char *net, char *local, char *remote)
{
    char *argv[16];
    int argc;

    switch(fork()){
    case -1:
        fprint(2, "testppp: can't fork: %r\n");
        exits(0);
    case 0:
        return;
    default:
        break;
    }

    dup(fd, 0);
    dup(fd, 1);

    argc = 0;
    argv[argc++] = ppp;
    if(debug)
        argv[argc++] = "-d";
    if(framing)
        argv[argc++] = "-f";
    if(nocompress)
        argv[argc++] = "-c";
    if(noipcompress)
        argv[argc++] = "-C";
    if(mtu){
        argv[argc++] = "-m";
        argv[argc++] = mtu;
    }
    argv[argc++] = "-x";
    argv[argc++] = net;
    if(local){
        argv[argc++] = local;
        if(remote)
            argv[argc++] = remote;
    }
    argv[argc] = 0;
    exec(ppp, argv);
}
@

<<function [[printbuf]]>>=
void
printbuf(uchar *p, int n)
{
    int i;
    uchar *e;
    char buf[32*5];

    if(n > 32)
        n = 32;
    
    i = 0;
    for(e = p + n; p < e; p++){
        if(isprint(*p))
            i += sprint(buf+i, "%c ", *p);
        else
            i += sprint(buf+i, "%2.2ux ", *p);
    }
    fprint(2, "%s\n", buf);
}
@

<<function [[xfer]]([[(networking/ip/ppp/testppp.c)]])>>=
void
xfer(int from, int to)
{
    uchar buf[4096];
    int i, n, modified, ok, total, errs, dropped;

    if(fork() == 0)
        return;

    total = ok = errs = dropped = 0;
    for(;;){
        n = read(from, buf, sizeof(buf));
        if(n <= 0){
            fprint(2, "%d -> %d EOF\n", from, to);
            exits(0);
        }
        modified = 0;
        if(errrate){
            for(i = 0; i < n; i++){
                if(lnrand(errrate) == 0){
                    buf[i] ^= 0xff;
                    modified = 1;
                }
            }
        }
        if(droprate && lnrand(droprate) == 0){
            fprint(2, "!!!!!!!!!!!!!!%d -> %d dropped %d (%d/%d)\n", from, to, ok, dropped, total);
            ok = 0;
            dropped++;
            total++;
            continue;
        }
        if(modified){
            fprint(2, "!!!!!!!!!!!!!!%d -> %d %d (%d/%d)\n", from, to, ok, errs, total);
            ok = 0;
            errs++;
        } else
            ok++;
        total++;
        if(debug > 1){
            fprint(2, "%d -> %d (%d)", from, to, n);
            printbuf(buf, n);
        }
        n = write(to, buf, n);
        if(n < 0){
            fprint(2, "%d -> %d write err\n", from, to);
            exits(0);
        }
    }
}
@

<<function [[usage]]([[(networking/ip/ppp/testppp.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: testppp [-cCDf] [-e errrate] [-d droprate] [-m mtu] [-p ppp]\n");
    exits("usage");
}
@

<<function [[main]]([[(networking/ip/ppp/testppp.c)]])>>=
void
main(int argc, char **argv)
{
    char *s;
    int pfd1[2];
    int pfd2[2];

    errrate = 0;
    droprate = 0;
    ARGBEGIN{
    case 'c':
        nocompress = 1;
        break;
    case 'C':
        noipcompress = 1;
        break;
    case 'd':
        s = ARGF();
        if(s)
            droprate = strtol(s, nil, 0);
        break;
    case 'D':
        debug++;
        break;
    case 'e':
        s = ARGF();
        if(s)
            errrate = strtol(s, nil, 0);
        break;
    case 'f':
        framing = 1;
        break;
    case 'm':
        mtu = ARGF();
        break;
    case 'p':
        ppp = ARGF();
        if(ppp == nil)
            usage();
        break;
    default:
        usage();
        break;
    }ARGEND
    if(argc)
        usage();

    pipe(pfd1);
    pipe(pfd2);

    bind("#I2", "/net.alt2", MCREATE);
    bind("#I1", "/net.alt", MCREATE);
    pppopen(pfd1[0], "/net.alt2", "135.104.99.1", "135.104.99.2");
    pppopen(pfd2[0], "/net.alt", 0, 0);

    close(pfd1[0]);
    close(pfd2[0]);

    xfer(pfd1[1], pfd2[1]);
    xfer(pfd2[1], pfd1[1]);
    exits(0);
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/testppp.c>>=
#include <u.h>
#include <libc.h>
#include <ctype.h>

<<global [[debug]]([[(networking/ip/ppp/testppp.c)]])>>
<<global [[errrate]]>>
<<global [[droprate]]>>
<<global [[framing]]>>
<<global [[nocompress]]([[(networking/ip/ppp/testppp.c)]])>>
<<global [[noipcompress]]([[(networking/ip/ppp/testppp.c)]])>>
<<global [[ppp]]([[(networking/ip/ppp/testppp.c)]])>>
<<global [[mtu]]>>

<<function [[pppopen]]([[(networking/ip/ppp/testppp.c)]])>>

<<function [[printbuf]]>>

<<function [[xfer]]([[(networking/ip/ppp/testppp.c)]])>>

<<function [[usage]]([[(networking/ip/ppp/testppp.c)]])>>

<<function [[main]]([[(networking/ip/ppp/testppp.c)]])>>

@


\subsection*{[[networking/ip/ppp/thw.c]]}

<<struct [[Cstate]]([[(networking/ip/ppp/thw.c)]])>>=
struct Cstate
{
    ulong		seq;
    Thwack		th;
    ulong		stats[ThwStats];
};
@

<<struct [[Uncstate]]([[(networking/ip/ppp/thw.c)]])>>=
struct Uncstate
{
    QLock		ackl;			/* lock for acks sent back to compressor */
    int		doack;			/* send an ack? */
    int		badpacks;		/* bad packets seen in a row */
    ulong		ackseq;			/* packets to ack */
    int		ackmask;

    int		active;			/* 0 => waiting for resetack */
    int		resetid;		/* id of most recent reset */
    Unthwack	ut;
};
@

<<enum [[_anon_ (networking/ip/ppp/thw.c)]]>>=
enum
{
    ThwAcked	= 1UL << 23,
    ThwCompMask	= 3UL << 21,
    ThwCompressed	= 0UL << 21,
    ThwUncomp	= 1UL << 21,
    ThwUncompAdd	= 2UL << 21,		/* uncompressed, but add to decompression buffer */
    ThwSeqMask	= 0x0fffff,
    ThwSmallPack	= 96,
};
@

<<global [[cthwack]]>>=
Comptype cthwack = {
    compinit,
    comp,
    compresetreq,
    compfini
};
@

<<global [[uncthwack]]>>=
Uncomptype uncthwack = {
    uncinit,
    uncomp,
    uncresetack,
    uncfini
};
@

<<function [[compinit]]([[(networking/ip/ppp/thw.c)]])>>=
static void *
compinit(PPP *)
{
    Cstate *cs;

    cs = mallocz(sizeof(Cstate), 1);
    thwackinit(&cs->th);
    return cs;
}
@

<<function [[compfini]]([[(networking/ip/ppp/thw.c)]])>>=
static void
compfini(void *as)
{
    Cstate *cs;

    cs = as;
    thwackcleanup(&cs->th);
    free(cs);
}
@

<<function [[compresetreq]]([[(networking/ip/ppp/thw.c)]])>>=
static Block *
compresetreq(void *as, Block *b)
{
    Cstate *cs;
    Lcpmsg *m;
    int id;

    cs = as;
    m = (Lcpmsg*)b->rptr;
    id = m->id;

    thwackinit(&cs->th);

    freeb(b);

    netlog("thwack resetreq id=%d \n", id);

    b = alloclcp(Lresetack, id, 4, &m);
    hnputs(m->len, 4);

    return b;
}
@

<<function [[comp]]([[(networking/ip/ppp/thw.c)]])>>=
static Block*
comp(PPP *ppp, ushort proto, Block *b, int *protop)
{
    Uncstate *uncs;
    Cstate *cs;
    Block *bb;
    ulong seq, acked;
    int n, nn, mustadd;

    cs = ppp->cstate;
    *protop = 0;

    /* put ack and protocol into b */
    n = BLEN(b);
    if(b->rptr - (2+4) < b->base)
        sysfatal("thwack: not enough header in block");
    acked = 0;
    if(ppp->unctype == &uncthwack){
        uncs = ppp->uncstate;
        qlock(&uncs->ackl);
        if(uncs->doack){
            uncs->doack = 0;
            b->rptr -= 4;
            b->rptr[0] = uncs->ackseq >> 16;
            b->rptr[1] = uncs->ackseq >> 8;
            b->rptr[2] = uncs->ackseq;
            b->rptr[3] = uncs->ackmask;
            acked = ThwAcked;
        }
        qunlock(&uncs->ackl);
    }
    if(proto > 0xff){
        b->rptr -= 2;
        b->rptr[0] = proto >> 8;
        b->rptr[1] = proto;
    }else{
        b->rptr--;
        b->rptr[0] = proto;
    }

    bb = allocb(BLEN(b) + 3);

    seq = cs->seq;
    if(n <= 3){
        mustadd = 0;
        nn = -1;
    }else{
        mustadd = n < ThwSmallPack;
        nn = thwack(&cs->th, mustadd, bb->wptr + 3, n - 3, b, seq, cs->stats);
    }
    if(nn < 0 && !mustadd){
        if(!acked || BLEN(b) + 1 > ppp->mtu){
            freeb(bb);
            if(acked)
                b->rptr += 4;
            if(proto > 0xff)
                b->rptr += 2;
            else
                b->rptr++;
            *protop = proto;
            return b;
        }
        bb->wptr[0] = (ThwUncomp | ThwAcked) >> 16;

        memmove(bb->wptr + 1, b->rptr, BLEN(b));

        bb->wptr += BLEN(b) + 1;
        freeb(b);
    }else{
        cs->seq = (seq + 1) & ThwSeqMask;
        if(nn < 0){
            nn = BLEN(b);
            memmove(bb->wptr + 3, b->rptr, nn);
            seq |= ThwUncompAdd;
        }else
            seq |= ThwCompressed;
        seq |= acked;
        bb->wptr[0] = seq>>16;
        bb->wptr[1] = seq>>8;
        bb->wptr[2] = seq;

        bb->wptr += nn + 3;
    }

    *protop = Pcdata;
    return bb;
}
@

<<function [[uncinit]]([[(networking/ip/ppp/thw.c)]])>>=
static	void *
uncinit(PPP *)
{
    Uncstate *s;

    s = mallocz(sizeof(Uncstate), 1);

    s->active = 1;

    unthwackinit(&s->ut);

    return s;
}
@

<<function [[uncfini]]([[(networking/ip/ppp/thw.c)]])>>=
static	void
uncfini(void *as)
{
    free(as);
}
@

<<function [[uncresetack]]([[(networking/ip/ppp/thw.c)]])>>=
static	void
uncresetack(void *as, Block *b)
{
    Uncstate *s;
    Lcpmsg *m;

    s = as;
    m = (Lcpmsg*)b->rptr;

    /*
     * rfc 1962 says we must reset every message
     * we don't since we may have acked some messages
     * which the compressor will use in the future.
     */
    netlog("unthwack resetack id=%d resetid=%d active=%d\n", m->id, s->resetid, s->active);
    if(m->id == (uchar)s->resetid && !s->active){
        s->active = 1;
        unthwackinit(&s->ut);
    }
}
@

<<function [[uncomp]]([[(networking/ip/ppp/thw.c)]])>>=
static	Block*
uncomp(PPP *ppp, Block *bb, int *protop, Block **reply)
{
    Lcpmsg *m;
    Cstate *cs;
    Uncstate *uncs;
    Block *b, *r;
    ulong seq, mseq;
    ushort proto;
    uchar mask;
    int n;

    *reply = nil;
    *protop = 0;
    uncs = ppp->uncstate;

    if(BLEN(bb) < 4){
        syslog(0, "ppp", ": thwack: short packet\n");
        freeb(bb);
        return nil;
    }

    if(!uncs->active){
        netlog("unthwack: inactive, killing packet\n");
        freeb(bb);
        r = alloclcp(Lresetreq, uncs->resetid, 4, &m);
        hnputs(m->len, 4);
        *reply = r;
        return nil;
    }

    seq = bb->rptr[0] << 16;
    if((seq & ThwCompMask) == ThwUncomp){
        bb->rptr++;
        b = bb;
    }else{
        seq |= (bb->rptr[1]<<8) | bb->rptr[2];
        bb->rptr += 3;
        if((seq & ThwCompMask) == ThwCompressed){
            b = allocb(ThwMaxBlock);
            n = unthwack(&uncs->ut, b->wptr, ThwMaxBlock, bb->rptr, BLEN(bb), seq & ThwSeqMask);
            freeb(bb);
            if(n < 2){
                syslog(0, "ppp", ": unthwack: short or corrupted packet %d seq=%ld\n", n, seq);
                netlog("unthwack: short or corrupted packet n=%d seq=%ld: %s\n", n, seq, uncs->ut.err);
                freeb(b);

                r = alloclcp(Lresetreq, ++uncs->resetid, 4, &m);
                hnputs(m->len, 4);
                *reply = r;
                uncs->active = 0;
                return nil;
            }
            b->wptr += n;
        }else{
            unthwackadd(&uncs->ut, bb->rptr, BLEN(bb), seq & ThwSeqMask);
            b = bb;
        }

        /*
         * update ack state
         */
        mseq = unthwackstate(&uncs->ut, &mask);
        qlock(&uncs->ackl);
        uncs->ackseq = mseq;
        uncs->ackmask = mask;
        uncs->doack = 1;
        qunlock(&uncs->ackl);
    }

    /*
     * grab the compressed protocol field
     */
    proto = *b->rptr++;
    if((proto & 1) == 0)
        proto = (proto << 8) | *b->rptr++;
    *protop = proto;

    /*
     * decode the ack, and forward to compressor
     */
    if(seq & ThwAcked){
        if(ppp->ctype == &cthwack){
            cs = ppp->cstate;
            mseq = (b->rptr[0]<<16) | (b->rptr[1]<<8) | b->rptr[2];
            mask = b->rptr[3];
            thwackack(&cs->th, mseq, mask);
        }
        b->rptr += 4;
    }
    return b;
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/thw.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <auth.h>
#include "ppp.h"
#include "thwack.h"

typedef struct Cstate Cstate;
<<struct [[Cstate]]([[(networking/ip/ppp/thw.c)]])>>

typedef struct Uncstate Uncstate;
<<struct [[Uncstate]]([[(networking/ip/ppp/thw.c)]])>>

<<enum [[_anon_ (networking/ip/ppp/thw.c)]]>>

static	void		*compinit(PPP*);
static	Block*		comp(PPP*, ushort, Block*, int*);
static	Block		*compresetreq(void*, Block*);
static	void		compcompack(void*, Block*);
static	void		compfini(void*);

static	void		*uncinit(PPP*);
static	Block*		uncomp(PPP*, Block*, int *protop, Block**);
static	void		uncfini(void*);
static	void		uncresetack(void*, Block*);

<<global [[cthwack]]>>

<<global [[uncthwack]]>>

<<function [[compinit]]([[(networking/ip/ppp/thw.c)]])>>

<<function [[compfini]]([[(networking/ip/ppp/thw.c)]])>>


<<function [[compresetreq]]([[(networking/ip/ppp/thw.c)]])>>

<<function [[comp]]([[(networking/ip/ppp/thw.c)]])>>

<<function [[uncinit]]([[(networking/ip/ppp/thw.c)]])>>

<<function [[uncfini]]([[(networking/ip/ppp/thw.c)]])>>

<<function [[uncresetack]]([[(networking/ip/ppp/thw.c)]])>>

<<function [[uncomp]]([[(networking/ip/ppp/thw.c)]])>>
@


\subsection*{[[networking/ip/ppp/thwack.c]]}

<<enum [[_anon_ (networking/ip/ppp/thwack.c)]]>>=
enum
{
    MaxFastLen	= 9,
    BigLenCode	= 0x1f4,	/* minimum code for large lenth encoding */
    BigLenBits	= 9,
    BigLenBase	= 4		/* starting items to encode for big lens */
};
@

<<enum [[_anon_ (networking/ip/ppp/thwack.c)2]]>>=
enum
{
    StatBytes,
    StatOutBytes,
    StatLits,
    StatMatches,
    StatOffBits,
    StatLenBits,

    StatDelay,
    StatHist,

    MaxStat
};
@

<<struct [[Huff]]>>=
struct Huff
{
    short	bits;				/* length of the code */
    ulong	encode;				/* the code */
};
@

<<global [[lentab]]>>=
static	Huff	lentab[MaxFastLen] =
{
    {2,	0x2},		/* 10 */
    {3,	0x6},		/* 110 */
    {5,	0x1c},		/* 11100 */
    {5,	0x1d},		/* 11101 */
    {6,	0x3c},		/* 111100 */
    {7,	0x7a},		/* 1111010 */
    {7,	0x7b},		/* 1111011 */
    {8,	0xf8},		/* 11111000 */
    {8,	0xf9},		/* 11111001 */
};
@

<<function [[thwackinit]]>>=
void
thwackinit(Thwack *tw)
{
    int i;

    qlock(&tw->acklock);
    tw->slot = 0;
    memset(tw->hash, 0, sizeof(tw->hash));
    memset(tw->blocks, 0, sizeof(tw->blocks));
    for(i = 0; i < EWinBlocks; i++){
        tw->blocks[i].hash = tw->hash[i];
        if(tw->data[i] != nil){
            freeb(tw->data[i]);
            tw->data[i] = nil;
        }
    }
    qunlock(&tw->acklock);
}
@

<<function [[thwackcleanup]]>>=
void
thwackcleanup(Thwack *tw)
{
    int i;

    qlock(&tw->acklock);
    for(i = 0; i < EWinBlocks; i++){
        if(tw->data[i] != nil){
            freeb(tw->data[i]);
            tw->data[i] = nil;
        }
    }
    qunlock(&tw->acklock);
}
@

<<function [[thwackack]]>>=
/*
 * acknowledgement for block seq & nearby preds
 */
void
thwackack(Thwack *tw, ulong seq, ulong mask)
{
    int slot, b;

    qlock(&tw->acklock);
    slot = tw->slot;
    for(;;){
        slot--;
        if(slot < 0)
            slot += EWinBlocks;
        if(slot == tw->slot)
            break;
        if(tw->blocks[slot].seq != seq)
            continue;

        tw->blocks[slot].acked = 1;

        if(mask == 0)
            break;
        do{
            b = mask & 1;
            seq--;
            mask >>= 1;
        }while(!b);
    }
    qunlock(&tw->acklock);
}
@

<<function [[thwmatch]]>>=
/*
 * find a string in the dictionary
 */
static int
thwmatch(ThwBlock *b, ThwBlock *eblocks, uchar **ss, uchar *esrc, ulong h)
{
    int then, toff, w, ok;
    uchar *s, *t;

    s = *ss;
    if(esrc < s + MinMatch)
        return 0;

    toff = 0;
    for(; b < eblocks; b++){
        then = b->hash[(h ^ b->seq) & HashMask];
        toff += b->maxoff;
        w = (ushort)(then - b->begin);

        if(w >= b->maxoff)
            continue;


        /*
         * don't need to check for the end because
         * 1) s too close check above
         * 2) entries too close not added to hash tables
         */
        t = w + b->data;
        if(s[0] != t[0] || s[1] != t[1] || s[2] != t[2])
            continue;
        ok = b->edata - t;
        if(esrc - s > ok)
            esrc = s + ok;

        t += 3;
        for(s += 3; s < esrc; s++){
            if(*s != *t)
                break;
            t++;
        }
        *ss = s;
        return toff - w;
    }
    return 0;
}
@

<<macro [[hashit]]>>=
/*
#define hashit(c)	(((ulong)(c) * 0x6b43a9) >> (24 - HashLog))
*/
#define hashit(c)	((((ulong)(c) & 0xffffff) * 0x6b43a9b5) >> (32 - HashLog))
@

<<function [[thwack]]>>=
/*
 * lz77 compression with single lookup in a hash table for each block
 */
int
thwack(Thwack *tw, int mustadd, uchar *dst, int ndst, Block *bsrc, ulong seq, ulong stats[ThwStats])
{
    ThwBlock *eblocks, *b, blocks[CompBlocks];
    uchar *s, *ss, *sss, *esrc, *half, *twdst, *twdmax;
    ulong cont, cseq, bseq, cmask, code, twbits;
    int n, now, toff, lithist, h, len, slot, bits, use, twnbits, lits, matches, offbits, lenbits, nhist;

    n = BLEN(bsrc);
    if(n > ThwMaxBlock || n < MinMatch)
        return -1;

    twdst = dst;
    twdmax = dst + ndst;

    /*
     * add source to the coding window
     * there is always enough space
     */
    qlock(&tw->acklock);
    slot = tw->slot;
    b = &tw->blocks[slot];
    b->seq = seq;
    b->acked = 0;
    now = b->begin + b->maxoff;
    if(tw->data[slot] != nil){
        freeb(tw->data[slot]);
        tw->data[slot] = nil;
    }
    s = bsrc->rptr;
    b->data = s;
    b->edata = s + n;
    b->begin = now;
    b->maxoff = n;

    /*
     * set up the history blocks
     */
    cseq = seq;
    cmask = 0;
    *blocks = *b;
    b = blocks;
    b->maxoff = 0;
    b++;
    nhist = 0;
    while(b < blocks + CompBlocks){
        slot--;
        if(slot < 0)
            slot += EWinBlocks;
        if(slot == tw->slot)
            break;
        if(tw->data[slot] == nil || !tw->blocks[slot].acked)
            continue;
        bseq = tw->blocks[slot].seq;
        if(cseq == seq){
            if(seq - bseq >= MaxSeqStart)
                break;
            cseq = bseq;
        }else if(cseq - bseq > MaxSeqMask)
            break;
        else
            cmask |= 1 << (cseq - bseq - 1);
        *b = tw->blocks[slot];
        nhist += b->maxoff;
        b++;
    }
    qunlock(&tw->acklock);
    eblocks = b;
    *twdst++ = seq - cseq;
    *twdst++ = cmask;

    cont = (s[0] << 16) | (s[1] << 8) | s[2];

    esrc = s + n;
    half = s + (n >> 1);
    twnbits = 0;
    twbits = 0;
    lits = 0;
    matches = 0;
    offbits = 0;
    lenbits = 0;
    lithist = ~0;
    while(s < esrc){
        h = hashit(cont);

        sss = s;
        toff = thwmatch(blocks, eblocks, &sss, esrc, h);
        ss = sss;

        len = ss - s;
        for(; twnbits >= 8; twnbits -= 8){
            if(twdst < twdmax)
                *twdst++ = twbits >> (twnbits - 8);
            else if(!mustadd)
                return -1;
        }
        if(len < MinMatch){
            toff = *s;
            lithist = (lithist << 1) | (toff < 32) | (toff > 127);
            if(lithist & 0x1e){
                twbits = (twbits << 9) | toff;
                twnbits += 9;
            }else if(lithist & 1){
                toff = (toff + 64) & 0xff;
                if(toff < 96){
                    twbits = (twbits << 10) | toff;
                    twnbits += 10;
                }else{
                    twbits = (twbits << 11) | toff;
                    twnbits += 11;
                }
            }else{
                twbits = (twbits << 8) | toff;
                twnbits += 8;
            }
            lits++;
            blocks->maxoff++;

            /*
             * speed hack
             * check for compression progress, bail if none achieved
             */
            if(s > half){
                if(!mustadd && 4 * blocks->maxoff < 5 * lits)
                    return -1;
                half = esrc;
            }

            if(s + MinMatch <= esrc){
                blocks->hash[(h ^ blocks->seq) & HashMask] = now;
                if(s + MinMatch < esrc)
                    cont = (cont << 8) | s[MinMatch];
            }
            now++;
            s++;
            continue;
        }

        blocks->maxoff += len;
        matches++;

        /*
         * length of match
         */
        len -= MinMatch;
        if(len < MaxFastLen){
            bits = lentab[len].bits;
            twbits = (twbits << bits) | lentab[len].encode;
            twnbits += bits;
            lenbits += bits;
        }else{
            code = BigLenCode;
            bits = BigLenBits;
            use = BigLenBase;
            len -= MaxFastLen;
            while(len >= use){
                len -= use;
                code = (code + use) << 1;
                use <<= (bits & 1) ^ 1;
                bits++;
            }
            twbits = (twbits << bits) | (code + len);
            twnbits += bits;
            lenbits += bits;

            for(; twnbits >= 8; twnbits -= 8){
                if(twdst < twdmax)
                    *twdst++ = twbits >> (twnbits - 8);
                else if(!mustadd)
                    return -1;
            }
        }

        /*
         * offset in history
         */
        toff--;
        for(bits = OffBase; toff >= (1 << bits); bits++)
            ;
        if(bits < MaxOff+OffBase-1){
            twbits = (twbits << 3) | (bits - OffBase);
            if(bits != OffBase)
                bits--;
            twnbits += bits + 3;
            offbits += bits + 3;
        }else{
            twbits = (twbits << 4) | 0xe | (bits - (MaxOff+OffBase-1));
            bits--;
            twnbits += bits + 4;
            offbits += bits + 4;
        }
        twbits = (twbits << bits) | toff & ((1 << bits) - 1);

        for(; s != ss; s++){
            if(s + MinMatch <= esrc){
                h = hashit(cont);
                blocks->hash[(h ^ blocks->seq) & HashMask] = now;
                if(s + MinMatch < esrc)
                    cont = (cont << 8) | s[MinMatch];
            }
            now++;
        }
    }

    if(twnbits & 7){
        twbits <<= 8 - (twnbits & 7);
        twnbits += 8 - (twnbits & 7);
    }
    for(; twnbits >= 8; twnbits -= 8){
        if(twdst < twdmax)
            *twdst++ = twbits >> (twnbits - 8);
        else if(!mustadd)
            return -1;
    }

    if(twdst >= twdmax && !mustadd)
        return -1;

    qlock(&tw->acklock);
    tw->data[tw->slot] = bsrc;
    tw->slot++;
    if(tw->slot >= EWinBlocks)
        tw->slot = 0;
    qunlock(&tw->acklock);

    if(twdst >= twdmax)
        return -1;

    stats[StatBytes] += blocks->maxoff;
    stats[StatLits] += lits;
    stats[StatMatches] += matches;
    stats[StatOffBits] += offbits;
    stats[StatLenBits] += lenbits;
    stats[StatDelay] = stats[StatDelay]*7/8 + dst[0];
    stats[StatHist] = stats[StatHist]*7/8 + nhist;
    stats[StatOutBytes] += twdst - dst;

    return twdst - dst;
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/thwack.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <auth.h>
#include "ppp.h"
#include "thwack.h"

typedef struct Huff	Huff;

<<enum [[_anon_ (networking/ip/ppp/thwack.c)]]>>

<<enum [[_anon_ (networking/ip/ppp/thwack.c)2]]>>

<<struct [[Huff]]>>

<<global [[lentab]]>>

<<function [[thwackinit]]>>

<<function [[thwackcleanup]]>>

<<function [[thwackack]]>>

<<function [[thwmatch]]>>

/*
 * knuth vol. 3 multiplicative hashing
 * each byte x chosen according to rules
 * 1/4 < x < 3/10, 1/3 x < < 3/7, 4/7 < x < 2/3, 7/10 < x < 3/4
 * with reasonable spread between the bytes & their complements
 *
 * the 3 byte value appears to be as almost good as the 4 byte value,
 * and might be faster on some machines
 */
<<macro [[hashit]]>>

<<function [[thwack]]>>
@


\subsection*{[[networking/ip/ppp/thwack.h]]}

<<enum [[_anon_ (networking/ip/ppp/thwack.h)]]>>=
enum
{
    ThwStats	= 8,
    ThwErrLen	= 64,		/* max length of error message from thwack or unthwack */
    ThwMaxBlock	= 1600,		/* max size of compressible block */

    HashLog		= 12,
    HashSize	= 1<<HashLog,
    HashMask	= HashSize - 1,

    MinMatch	= 3,		/* shortest match possible */

    MaxOff		= 8,
    OffBase		= 6,

    MinDecode	= 8,		/* minimum bits to decode a match or lit; >= 8 */

    CompBlocks	= 10,		/* max blocks used to encode data */
    EWinBlocks	= 64,		/* blocks held in encoder window */
    DWinBlocks	= EWinBlocks,	/* blocks held in decoder window */

    MaxSeqMask	= 8,		/* number of bits in coding block mask */
    MaxSeqStart	= 256		/* max offset of initial coding block */
};
@

<<struct [[ThwBlock]]>>=
struct ThwBlock
{
    ulong	seq;			/* sequence number for this data */
    uchar	acked;			/* ok to use this block; the decoder has it */
    ushort	begin;			/* time of first byte in hash */
    uchar	*edata;			/* last byte of valid data */
    ushort	maxoff;			/* time of last valid hash entry */
    ushort	*hash;
    uchar	*data;
};
@

<<struct [[Thwack]]>>=
struct Thwack
{
    QLock		acklock;	/* locks slot, blocks[].(acked|seq) */
    int		slot;		/* next block to use */
    ThwBlock	blocks[EWinBlocks];
    ushort		hash[EWinBlocks][HashSize];
    Block		*data[EWinBlocks];
};
@

<<struct [[UnthwBlock]]>>=
struct UnthwBlock
{
    ulong	seq;			/* sequence number for this data */
    ushort	maxoff;			/* valid data in each block */
    uchar	*data;
};
@

<<struct [[Unthwack]]>>=
struct Unthwack
{
    int		slot;		/* next block to use */
    char		err[ThwErrLen];
    UnthwBlock	blocks[DWinBlocks];
    uchar		data[DWinBlocks][ThwMaxBlock];
};
@


%-------------------------------------------------------------

<<networking/ip/ppp/thwack.h>>=
typedef struct Thwack		Thwack;
typedef struct Unthwack		Unthwack;
typedef struct ThwBlock		ThwBlock;
typedef struct UnthwBlock	UnthwBlock;

<<enum [[_anon_ (networking/ip/ppp/thwack.h)]]>>

<<struct [[ThwBlock]]>>

<<struct [[Thwack]]>>

<<struct [[UnthwBlock]]>>

<<struct [[Unthwack]]>>

void	thwackinit(Thwack*);
void	thwackcleanup(Thwack *tw);
void	unthwackinit(Unthwack*);
int	thwack(Thwack*, int mustadd, uchar *dst, int ndst, Block *bsrc, ulong seq, ulong stats[ThwStats]);
void	thwackack(Thwack*, ulong seq, ulong mask);
int	unthwack(Unthwack*, uchar *dst, int ndst, uchar *src, int nsrc, ulong seq);
ulong	unthwackstate(Unthwack *ut, uchar *mask);
int	unthwackadd(Unthwack *ut, uchar *src, int nsrc, ulong seq);
@


\subsection*{[[networking/ip/ppp/unthwack.c]]}

<<enum [[_anon_ (networking/ip/ppp/unthwack.c)]]>>=
enum
{
    DMaxFastLen	= 7,
    DBigLenCode	= 0x3c,		/* minimum code for large lenth encoding */
    DBigLenBits	= 6,
    DBigLenBase	= 1		/* starting items to encode for big lens */
};
@

<<global [[lenval]]>>=
static uchar lenval[1 << (DBigLenBits - 1)] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4,
    5,
    6,
    255,
    255
};
@

<<global [[lenbits]]>>=
static uchar lenbits[] =
{
    0, 0, 0,
    2, 3, 5, 5,
};
@

<<global [[offbits]]>>=
static uchar offbits[16] =
{
    5, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 12, 13
};
@

<<global [[offbase]]>>=
static ushort offbase[16] =
{
    0, 0x20,
    0x40, 0x60,
    0x80, 0xc0,
    0x100, 0x180,
    0x200, 0x300,
    0x400, 0x600,
    0x800, 0xc00,
    0x1000,
    0x2000
};
@

<<function [[unthwackinit]]>>=
void
unthwackinit(Unthwack *ut)
{
    int i;

    memset(ut, 0, sizeof *ut);
    for(i = 0; i < DWinBlocks; i++)
        ut->blocks[i].data = ut->data[i];
}
@

<<function [[unthwackstate]]>>=
ulong
unthwackstate(Unthwack *ut, uchar *mask)
{
    ulong bseq, seq;
    int slot, m;

    seq = ~0UL;
    m = 0;
    slot = ut->slot;
    for(;;){
        slot--;
        if(slot < 0)
            slot += DWinBlocks;
        if(slot == ut->slot)
            break;
        if(ut->blocks[slot].maxoff == 0)
            continue;
        bseq = ut->blocks[slot].seq;
        if(seq == ~0UL)
            seq = bseq;
        else if(seq - bseq > MaxSeqMask)
            break;
        else
            m |= 1 << (seq - bseq - 1);
    }
    *mask = m;
    return seq;
}
@

<<function [[unthwackinsert]]>>=
/*
 * insert this block in it's correct sequence number order.
 * replace the oldest block, which is always pointed to by ut->slot.
 * the encoder doesn't use a history at wraparound,
 * so don't worry about that case.
 */
static int
unthwackinsert(Unthwack *ut, int len, ulong seq)
{
    uchar *d;
    int slot, tslot;

    tslot = ut->slot;
    for(;;){
        slot = tslot - 1;
        if(slot < 0)
            slot += DWinBlocks;
        if(ut->blocks[slot].seq <= seq || ut->blocks[slot].maxoff == 0)
            break;
        d = ut->blocks[tslot].data;
        ut->blocks[tslot] = ut->blocks[slot];
        ut->blocks[slot].data = d;
        tslot = slot;
    }
    ut->blocks[tslot].seq = seq;
    ut->blocks[tslot].maxoff = len;

    ut->slot++;
    if(ut->slot >= DWinBlocks)
        ut->slot = 0;

    ut->blocks[ut->slot].seq = ~0UL;
    ut->blocks[ut->slot].maxoff = 0;

    return tslot;
}
@

<<function [[unthwackadd]]>>=
int
unthwackadd(Unthwack *ut, uchar *src, int nsrc, ulong seq)
{
    int tslot;

    if(nsrc > ThwMaxBlock)
        return -1;

    tslot = unthwackinsert(ut, nsrc, seq);
    if(tslot < 0)
        return -1;
    
    memmove(ut->blocks[tslot].data, src, nsrc);

    return nsrc;
}
@

<<function [[unthwack]]>>=
int
unthwack(Unthwack *ut, uchar *dst, int ndst, uchar *src, int nsrc, ulong seq)
{
    UnthwBlock blocks[CompBlocks], *b, *eblocks;
    uchar *s, *d, *dmax, *smax, lit;
    ulong cmask, cseq, bseq, utbits;
    int i, off, len, bits, slot, use, code, utnbits, overbits, lithist;

    if(nsrc < 4 || nsrc > ThwMaxBlock){
        snprint(ut->err, ThwErrLen, "block too small or large");
        return -1;
    }

    slot = ut->slot;
    b = blocks;
    *b = ut->blocks[slot];
    d = b->data;
    dmax = d + ndst;

    /*
     * set up the history blocks
     */
    cseq = seq - src[0];
    cmask = src[1];
    b++;
    while(cseq != seq && b < blocks + CompBlocks){
        slot--;
        if(slot < 0)
            slot += DWinBlocks;
        if(slot == ut->slot)
            break;
        bseq = ut->blocks[slot].seq;
        if(bseq == cseq){
            *b = ut->blocks[slot];
            b++;
            if(cmask == 0){
                cseq = seq;
                break;
            }
            do{
                bits = cmask & 1;
                cseq--;
                cmask >>= 1;
            }while(!bits);
        }
    }
    eblocks = b;
    if(cseq != seq){
        snprint(ut->err, ThwErrLen, "blocks dropped: seq=%ld cseq=%ld %d cmask=%#lx %#x\n", seq, cseq, src[0], cmask, src[1]);
        return -2;
    }

    smax = src + nsrc;
    src += 2;
    utnbits = 0;
    utbits = 0;
    overbits = 0;
    lithist = ~0;
    while(src < smax || utnbits - overbits >= MinDecode){
        while(utnbits <= 24){
            utbits <<= 8;
            if(src < smax)
                utbits |= *src++;
            else
                overbits += 8;
            utnbits += 8;
        }

        /*
         * literal
         */
        len = lenval[(utbits >> (utnbits - 5)) & 0x1f];
        if(len == 0){
            if(lithist & 0xf){
                utnbits -= 9;
                lit = (utbits >> utnbits) & 0xff;
                lit &= 255;
            }else{
                utnbits -= 8;
                lit = (utbits >> utnbits) & 0x7f;
                if(lit < 32){
                    if(lit < 24){
                        utnbits -= 2;
                        lit = (lit << 2) | ((utbits >> utnbits) & 3);
                    }else{
                        utnbits -= 3;
                        lit = (lit << 3) | ((utbits >> utnbits) & 7);
                    }
                    lit = (lit - 64) & 0xff;
                }
            }
            if(d >= dmax){
                snprint(ut->err, ThwErrLen, "too much output");
                return -1;
            }
            *d++ = lit;
            lithist = (lithist << 1) | (lit < 32) | (lit > 127);
            blocks->maxoff++;
            continue;
        }

        /*
         * length
         */
        if(len < 255)
            utnbits -= lenbits[len];
        else{
            utnbits -= DBigLenBits;
            code = ((utbits >> utnbits) & ((1 << DBigLenBits) - 1)) - DBigLenCode;
            len = DMaxFastLen;
            use = DBigLenBase;
            bits = (DBigLenBits & 1) ^ 1;
            while(code >= use){
                len += use;
                code -= use;
                code <<= 1;
                utnbits--;
                if(utnbits < 0){
                    snprint(ut->err, ThwErrLen, "len out of range");
                    return -1;
                }
                code |= (utbits >> utnbits) & 1;
                use <<= bits;
                bits ^= 1;
            }
            len += code;

            while(utnbits <= 24){
                utbits <<= 8;
                if(src < smax)
                    utbits |= *src++;
                else
                    overbits += 8;
                utnbits += 8;
            }
        }

        /*
         * offset
         */
        utnbits -= 4;
        bits = (utbits >> utnbits) & 0xf;
        off = offbase[bits];
        bits = offbits[bits];

        utnbits -= bits;
        off |= (utbits >> utnbits) & ((1 << bits) - 1);
        off++;

        b = blocks;
        while(off > b->maxoff){
            off -= b->maxoff;
            b++;
            if(b >= eblocks){
                snprint(ut->err, ThwErrLen, "offset out of range");
                return -1;
            }
        }
        if(d + len > dmax
        || b != blocks && len > off){
            snprint(ut->err, ThwErrLen, "len out of range");
            return -1;
        }
        s = b->data + b->maxoff - off;
        blocks->maxoff += len;

        for(i = 0; i < len; i++)
            d[i] = s[i];
        d += len;
    }
    if(utnbits < overbits){
        snprint(ut->err, ThwErrLen, "compressed data overrun");
        return -1;
    }

    len = d - blocks->data;
    memmove(dst, blocks->data, len);

    unthwackinsert(ut, len, seq);

    return len;
}
@


%-------------------------------------------------------------

<<networking/ip/ppp/unthwack.c>>=
#include <u.h>
#include <libc.h>
#include <ip.h>
#include <auth.h>
#include "ppp.h"
#include "thwack.h"

<<enum [[_anon_ (networking/ip/ppp/unthwack.c)]]>>

<<global [[lenval]]>>

<<global [[lenbits]]>>

<<global [[offbits]]>>

<<global [[offbase]]>>

<<function [[unthwackinit]]>>

<<function [[unthwackstate]]>>

<<function [[unthwackinsert]]>>

<<function [[unthwackadd]]>>

<<function [[unthwack]]>>
@


\section{[[networking/ip/]]}

\subsection*{[[networking/ip/pppoe.c]]}

<<global [[alarmed]]>>=
int alarmed;
@

<<global [[debug]]([[(networking/ip/pppoe.c)]])>>=
int debug;
@

<<global [[sessid]]>>=
int sessid;
@

<<global [[keyspec]]([[(networking/ip/pppoe.c)]])>>=
char *keyspec;
@

<<global [[primary]]([[(networking/ip/pppoe.c)]])>>=
int primary;
@

<<global [[pppnetmtpt]]>>=
char *pppnetmtpt;
@

<<global [[acname]]>>=
char *acname;
@

<<global [[pppname]]>>=
char *pppname = "/bin/ip/ppp";
@

<<global [[srvname]]([[(networking/ip/pppoe.c)]])>>=
char *srvname = "";
@

<<global [[wantac]]>>=
char *wantac;
@

<<global [[cookie]]>>=
uchar *cookie;
@

<<global [[cookielen]]>>=
int cookielen;
@

<<global [[etherdst]]>>=
uchar etherdst[6];
@

<<global [[mtu]]([[(networking/ip/pppoe.c)]])>>=
int mtu = 1492;
@

<<function [[usage]]([[(networking/ip/pppoe.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: pppoe [-Pd] [-A acname] [-S srvname] [-k keyspec] [-m mtu] [-x pppnet] [ether0]\n");
    exits("usage");
}
@

<<function [[catchalarm]]>>=
int
catchalarm(void *a, char *msg)
{
    USED(a);

    if(strstr(msg, "alarm")){
        alarmed = 1;
        return 1;
    }
    if(debug)
        fprint(2, "note rcved: %s\n", msg);
    return 0;
}
@

<<function [[main]]([[(networking/ip/pppoe.c)]])>>=
void
main(int argc, char **argv)
{
    int fd;
    char *dev;

    ARGBEGIN{
    case 'A':
        wantac = EARGF(usage());
        break;
    case 'P':
        primary = 1;
        break;
    case 'S':
        srvname = EARGF(usage());
        break;
    case 'd':
        debug++;
        break;
    case 'm':
        mtu = atoi(EARGF(usage()));
        break;
    case 'k':
        keyspec = EARGF(usage());
        break;
    case 'x':
        pppnetmtpt = EARGF(usage());
        break;
    default:
        usage();
    }ARGEND

    switch(argc){
    default:
        usage();
    case 0:
        dev = "ether0";
        break;
    case 1:
        dev = argv[0];
        break;
    }

    fmtinstall('E', eipfmt);

    atnotify(catchalarm, 1);
    fd = pppoe(dev);
    execppp(fd);
}
@

<<struct [[Etherhdr]]([[(networking/ip/pppoe.c)]])>>=
struct Etherhdr {
    uchar dst[6];
    uchar src[6];
    uchar type[2];
};
@

<<enum [[_anon_ (networking/ip/pppoe.c)]]>>=
enum {
    EtherHdrSz = 6+6+2,
    EtherMintu = 60,

    EtherPppoeDiscovery = 0x8863,
    EtherPppoeSession = 0x8864,
};
@

<<global [[etherbcast]]>>=
uchar etherbcast[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
@

<<function [[etherhdr]]>>=
int
etherhdr(uchar *pkt, uchar *dst, int type)
{
    Etherhdr *eh;

    eh = (Etherhdr*)pkt;
    memmove(eh->dst, dst, sizeof(eh->dst));
    hnputs(eh->type, type);
    return EtherHdrSz;
}
@

<<struct [[Pppoehdr]]>>=
struct Pppoehdr {
    uchar verstype;
    uchar code;
    uchar sessid[2];
    uchar length[2];	/* of payload */
};
@

<<enum [[_anon_ (networking/ip/pppoe.c)2]]>>=
enum {
    PppoeHdrSz = 1+1+2+2,
    Hdr = EtherHdrSz+PppoeHdrSz,
};
@

<<enum [[_anon_ (networking/ip/pppoe.c)3]]>>=
enum {
    VersType = 0x11,

    /* Discovery codes */
    CodeDiscInit = 0x09,	/* discovery init */
    CodeDiscOffer = 0x07,	/* discovery offer */
    CodeDiscReq = 0x19,	/* discovery request */
    CodeDiscSess = 0x65,	/* session confirmation */

    /* Session codes */
    CodeSession = 0x00,
};
@

<<function [[pppoehdr]]>>=
int
pppoehdr(uchar *pkt, int code, int sessid)
{
    Pppoehdr *ph;

    ph = (Pppoehdr*)pkt;
    ph->verstype = VersType;
    ph->code = code;
    hnputs(ph->sessid, sessid);
    return PppoeHdrSz;
}
@

<<struct [[Taghdr]]>>=
struct Taghdr {
    uchar type[2];
    uchar length[2];	/* of value */
};
@

<<enum [[_anon_ (networking/ip/pppoe.c)4]]>>=
enum {
    TagEnd = 0x0000,		/* end of tag list */
    TagSrvName = 0x0101,	/* service name */
    TagAcName = 0x0102,	/* access concentrator name */
    TagHostUniq = 0x0103,	/* nonce */
    TagAcCookie = 0x0104,	/* a.c. cookie */
    TagVendSpec = 0x0105,	/* vendor specific */
    TagRelaySessId = 0x0110,	/* relay session id */
    TagSrvNameErr = 0x0201,	/* service name error (ascii) */
    TagAcSysErr = 0x0202,	/* a.c. system error */
};
@

<<function [[tag]]([[(networking/ip/pppoe.c)]])>>=
int
tag(uchar *pkt, int type, void *value, int nvalue)
{
    Taghdr *h;

    h = (Taghdr*)pkt;
    hnputs(h->type, type);
    hnputs(h->length, nvalue);
    memmove(pkt+4, value, nvalue);
    return 4+nvalue;
}
@

<<function [[padi]]>>=
/* PPPoE Active Discovery Initiation */
int
padi(uchar *pkt)
{
    int sz, tagoff;
    uchar *length;

    sz = 0;
    sz += etherhdr(pkt+sz, etherbcast, EtherPppoeDiscovery);
    sz += pppoehdr(pkt+sz, CodeDiscInit, 0x0000);
    length = pkt+sz-2;
    tagoff = sz;
    sz += tag(pkt+sz, TagSrvName, srvname, strlen(srvname));
    hnputs(length, sz-tagoff);
    return sz;
}
@

<<function [[padr]]>>=
/* PPPoE Active Discovery Request */
int
padr(uchar *pkt)
{
    int sz, tagoff;
    uchar *length;

    sz = 0;
    sz += etherhdr(pkt+sz, etherdst, EtherPppoeDiscovery);
    sz += pppoehdr(pkt+sz, CodeDiscReq, 0x0000);
    length = pkt+sz-2;
    tagoff = sz;
    sz += tag(pkt+sz, TagSrvName, srvname, strlen(srvname));
    sz += tag(pkt+sz, TagAcName, acname, strlen(acname));
    if(cookie)
        sz += tag(pkt+sz, TagAcCookie, cookie, cookielen);
    hnputs(length, sz-tagoff);
    return sz;
}
@

<<function [[ewrite]]>>=
void
ewrite(int fd, void *buf, int nbuf)
{
    char e[ERRMAX], path[64];

    if(write(fd, buf, nbuf) != nbuf){
        rerrstr(e, sizeof e);
        strcpy(path, "unknown");
        fd2path(fd, path, sizeof path);
        sysfatal("write %d to %s: %s", nbuf, path, e);
    }
}
@

<<function [[emalloc]]([[(networking/ip/pppoe.c)]])>>=
void*
emalloc(long n)
{
    void *v;

    v = malloc(n);
    if(v == nil)
        sysfatal("out of memory");
    return v;
}
@

<<function [[aread]]>>=
int
aread(int timeout, int fd, void *buf, int nbuf)
{
    int n;

    alarmed = 0;
    alarm(timeout);
    n = read(fd, buf, nbuf);
    alarm(0);
    if(alarmed)
        return -1;
    if(n < 0)
        sysfatal("read: %r");
    if(n == 0)
        sysfatal("short read");
    return n;
}
@

<<function [[pktread]]>>=
int
pktread(int timeout, int fd, void *buf, int nbuf, int (*want)(uchar*))
{
    int n, t2;
    n = -1;
    for(t2=timeout; t2<16000; t2*=2){
        while((n = aread(t2, fd, buf, nbuf)) > 0){
            if(malformed(buf, n, EtherPppoeDiscovery)){
                if(debug)
                    fprint(2, "dropping pkt: %r\n");
                continue;
            }
            if(debug)
                dumppkt(buf);
            if(!want(buf)){
                if(debug)
                    fprint(2, "dropping unwanted pkt: %r\n");
                continue;
            }
            break;
        }
        if(n > 0)
            break;
    }
    return n;
}
@

<<function [[bad]]>>=
int
bad(char *reason)
{
    werrstr(reason);
    return 0;
}
@

<<function [[copy]]>>=
void*
copy(uchar *s, int len)
{
    uchar *v;

    v = emalloc(len+1);
    memmove(v, s, len);
    v[len] = '\0';
    return v;
}
@

<<function [[clearstate]]>>=
void
clearstate(void)
{
    sessid = -1;
    free(acname);
    acname = nil;
    free(cookie);
    cookie = nil;
}
@

<<function [[wantoffer]]>>=
int
wantoffer(uchar *pkt)
{
    int i, len;
    uchar *s;
    Etherhdr *eh;
    Pppoehdr *ph;

    eh = (Etherhdr*)pkt;
    ph = (Pppoehdr*)(pkt+EtherHdrSz);

    if(ph->code != CodeDiscOffer)
        return bad("not an offer");
    if(nhgets(ph->sessid) != 0x0000)
        return bad("bad session id");

    for(i=0;; i++){
        if((s = findtag(pkt, TagSrvName, &len, i)) == nil)
            return bad("no matching service name");
        if(len == strlen(srvname) && memcmp(s, srvname, len) == 0)
            break;
    }

    if((s = findtag(pkt, TagAcName, &len, 0)) == nil)
        return bad("no ac name");
    acname = copy(s, len);
    if(wantac && strcmp(acname, wantac) != 0){
        free(acname);
        return bad("wrong ac name");
    }

    if(s = findtag(pkt, TagAcCookie, &len, 0)){
        cookie = copy(s, len);
        cookielen = len;
    }
    memmove(etherdst, eh->src, sizeof etherdst);
    return 1;
}
@

<<function [[wantsession]]>>=
int
wantsession(uchar *pkt)
{
    int len;
    uchar *s;
    Pppoehdr *ph;

    ph = (Pppoehdr*)(pkt+EtherHdrSz);

    if(ph->code != CodeDiscSess)
        return bad("not a session confirmation");
    if(nhgets(ph->sessid) == 0x0000)
        return bad("bad session id");
    if(findtag(pkt, TagSrvName, &len, 0) == nil)
        return bad("no service name");
    if(findtag(pkt, TagSrvNameErr, &len, 0))
        return bad("service name error");
    if(findtag(pkt, TagAcSysErr, &len, 0))
        return bad("ac system error");

    /*
     * rsc said: ``if there is no -S option given, the current code
     * waits for an offer with service name == "".
     * that's silly.  it should take the first one it gets.''
     */
    if(srvname[0] != '\0') {
        if((s = findtag(pkt, TagSrvName, &len, 0)) == nil)
            return bad("no matching service name");
        if(len != strlen(srvname) || memcmp(s, srvname, len) != 0)
            return bad("no matching service name");
    }
    sessid = nhgets(ph->sessid);
    return 1;
}
@

<<function [[pppoe]]>>=
int
pppoe(char *ether)
{
    char buf[64];
    uchar pkt[1520];
    int dfd, p[2], n, sfd, sz, timeout;
    Pppoehdr *ph;

    ph = (Pppoehdr*)(pkt+EtherHdrSz);
    snprint(buf, sizeof buf, "%s!%d", ether, EtherPppoeDiscovery);
    if((dfd = dial(buf, nil, nil, nil)) < 0)
        sysfatal("dial %s: %r", buf);

    snprint(buf, sizeof buf, "%s!%d", ether, EtherPppoeSession);
    if((sfd = dial(buf, nil, nil, nil)) < 0)
        sysfatal("dial %s: %r", buf);

    for(timeout=250; timeout<16000; timeout*=2){
        clearstate();
        memset(pkt, 0, sizeof pkt);
        sz = padi(pkt);
        if(debug)
            dumppkt(pkt);
        if(sz < EtherMintu)
            sz = EtherMintu;
        ewrite(dfd, pkt, sz);

        if(pktread(timeout, dfd, pkt, sizeof pkt, wantoffer) < 0)
            continue;

        memset(pkt, 0, sizeof pkt);
        sz = padr(pkt);
        if(debug)
            dumppkt(pkt);
        if(sz < EtherMintu)
            sz = EtherMintu;
        ewrite(dfd, pkt, sz);

        if(pktread(timeout, dfd, pkt, sizeof pkt, wantsession) < 0)
            continue;

        break;
    }
    if(sessid < 0)
        sysfatal("could not establish session");

    rfork(RFNOTEG);
    if(pipe(p) < 0)
        sysfatal("pipe: %r");

    switch(fork()){
    case -1:
        sysfatal("fork: %r");
    default:
        break;
    case 0:
        close(p[1]);
        while((n = read(p[0], pkt+Hdr, sizeof pkt-Hdr)) > 0){
            etherhdr(pkt, etherdst, EtherPppoeSession);
            pppoehdr(pkt+EtherHdrSz, 0x00, sessid);
            hnputs(pkt+Hdr-2, n);
            sz = Hdr+n;
            if(debug > 1){
                dumppkt(pkt);
                hexdump(pkt, sz);
            }
            if(sz < EtherMintu)
                sz = EtherMintu;
            if(write(sfd, pkt, sz) < 0){
                if(debug)
                    fprint(2, "write to ether failed: %r");
                _exits(nil);
            }
        }
        _exits(nil);
    }

    switch(fork()){
    case -1:
        sysfatal("fork: %r");
    default:
        break;
    case 0:
        close(p[1]);
        while((n = read(sfd, pkt, sizeof pkt)) > 0){
            if(malformed(pkt, n, EtherPppoeSession)
            || ph->code != 0x00 || nhgets(ph->sessid) != sessid){
                if(debug)
                    fprint(2, "malformed session pkt: %r\n");
                if(debug)
                    dumppkt(pkt);
                continue;
            }
            if(write(p[0], pkt+Hdr, nhgets(ph->length)) < 0){
                if(debug)
                    fprint(2, "write to ppp failed: %r\n");
                _exits(nil);
            }
        }
        _exits(nil);
    }
    close(p[0]);
    return p[1];
}
@

<<function [[execppp]]>>=
void
execppp(int fd)
{
    char *argv[16];
    int argc;
    char smtu[10];

    argc = 0;
    argv[argc++] = pppname;
    snprint(smtu, sizeof(smtu), "-m%d", mtu);
    argv[argc++] = smtu;
    argv[argc++] = "-F";
    if(debug)
        argv[argc++] = "-d";
    if(primary)
        argv[argc++] = "-P";
    if(pppnetmtpt){
        argv[argc++] = "-x";
        argv[argc++] = pppnetmtpt;
    }
    if(keyspec){
        argv[argc++] = "-k";
        argv[argc++] = keyspec;
    }
    argv[argc] = nil;

    dup(fd, 0);
    dup(fd, 1);
    exec(pppname, argv);
    sysfatal("exec: %r");
}
@

<<function [[findtag]]>>=
uchar*
findtag(uchar *pkt, int tagtype, int *plen, int skip)
{
    int len, sz, totlen;
    uchar *tagdat, *v;
    Etherhdr *eh;
    Pppoehdr *ph;
    Taghdr *t;

    eh = (Etherhdr*)pkt;
    ph = (Pppoehdr*)(pkt+EtherHdrSz);
    tagdat = pkt+Hdr;

    if(nhgets(eh->type) != EtherPppoeDiscovery)
        return nil;
    totlen = nhgets(ph->length);

    sz = 0;
    while(sz+4 <= totlen){
        t = (Taghdr*)(tagdat+sz);
        v = tagdat+sz+4;
        len = nhgets(t->length);
        if(sz+4+len > totlen)
            break;
        if(nhgets(t->type) == tagtype && skip-- == 0){
            *plen = len;
            return v;
        }
        sz += 2+2+len;
    }
    return nil;	
}
@

<<function [[dumptags]]>>=
void
dumptags(uchar *tagdat, int ntagdat)
{
    int i,len, sz;
    uchar *v;
    Taghdr *t;

    sz = 0;
    while(sz+4 <= ntagdat){
        t = (Taghdr*)(tagdat+sz);
        v = tagdat+sz+2+2;
        len = nhgets(t->length);
        if(sz+4+len > ntagdat)
            break;
        fprint(2, "\t0x%x %d: ", nhgets(t->type), len);
        switch(nhgets(t->type)){
        case TagEnd:
            fprint(2, "end of tag list\n");
            break;
        case TagSrvName:
            fprint(2, "service '%.*s'\n", len, (char*)v);
            break;
        case TagAcName:
            fprint(2, "ac '%.*s'\n", len, (char*)v);
            break;
        case TagHostUniq:
            fprint(2, "nonce ");
        Hex:
            for(i=0; i<len; i++)
                fprint(2, "%.2ux", v[i]);
            fprint(2, "\n");
            break;
        case TagAcCookie:
            fprint(2, "ac cookie ");
            goto Hex;
        case TagVendSpec:
            fprint(2, "vend spec ");
            goto Hex;
        case TagRelaySessId:
            fprint(2, "relay ");
            goto Hex;
        case TagSrvNameErr:
            fprint(2, "srverr '%.*s'\n", len, (char*)v);
            break;
        case TagAcSysErr:
            fprint(2, "syserr '%.*s'\n", len, (char*)v);
            break;
        }
        sz += 2+2+len;
    }
    if(sz != ntagdat)
        fprint(2, "warning: only dumped %d of %d bytes\n", sz, ntagdat);
}
@

<<function [[dumppkt]]>>=
void
dumppkt(uchar *pkt)
{
    int et;
    Etherhdr *eh;
    Pppoehdr *ph;

    eh = (Etherhdr*)pkt;
    ph = (Pppoehdr*)(pkt+EtherHdrSz);
    et = nhgets(eh->type);

    fprint(2, "%E -> %E type 0x%x\n", 
        eh->src, eh->dst, et);
    switch(et){
    case EtherPppoeDiscovery:
    case EtherPppoeSession:
        fprint(2, "\tvers %d type %d code 0x%x sessid 0x%x length %d\n",
            ph->verstype>>4, ph->verstype&15,
            ph->code, nhgets(ph->sessid), nhgets(ph->length));
        if(et == EtherPppoeDiscovery)
            dumptags(pkt+Hdr, nhgets(ph->length));
    }
}
@

<<function [[malformed]]>>=
int
malformed(uchar *pkt, int n, int wantet)
{
    int et;
    Etherhdr *eh;
    Pppoehdr *ph;

    eh = (Etherhdr*)pkt;
    ph = (Pppoehdr*)(pkt+EtherHdrSz);

    if(n < Hdr || n < Hdr+nhgets(ph->length)){
        werrstr("packet too short %d != %d", n, Hdr+nhgets(ph->length));
        return 1;
    }

    et = nhgets(eh->type);
    if(et != wantet){
        werrstr("wrong ethernet packet type 0x%x != 0x%x", et, wantet);
        return 1;
    }

    return 0;
}
@

<<function [[hexdump]]([[(networking/ip/pppoe.c)]])>>=
void
hexdump(uchar *a, int na)
{
    int i;
    char buf[80];

    buf[0] = '\0';
    for(i=0; i<na; i++){
        sprint(buf+strlen(buf), " %.2ux", a[i]);
        if(i%16 == 7)
            sprint(buf+strlen(buf), " --");
        if(i%16==15){
            sprint(buf+strlen(buf), "\n");
            write(2, buf, strlen(buf));
            buf[0] = 0;
        }
    }
    if(i%16){
        sprint(buf+strlen(buf), "\n");
        write(2, buf, strlen(buf));
    }
}
@


%-------------------------------------------------------------

<<networking/ip/pppoe.c>>=
/*
 * User-level PPP over Ethernet (PPPoE) client.
 * See RFC 2516
 */

#include <u.h>
#include <libc.h>
#include <ip.h>

void dumppkt(uchar*);
uchar *findtag(uchar*, int, int*, int);
void hexdump(uchar*, int);
int malformed(uchar*, int, int);
int pppoe(char*);
void execppp(int);

<<global [[alarmed]]>>
<<global [[debug]]([[(networking/ip/pppoe.c)]])>>
<<global [[sessid]]>>
<<global [[keyspec]]([[(networking/ip/pppoe.c)]])>>
<<global [[primary]]([[(networking/ip/pppoe.c)]])>>
<<global [[pppnetmtpt]]>>
<<global [[acname]]>>
<<global [[pppname]]>>
<<global [[srvname]]([[(networking/ip/pppoe.c)]])>>
<<global [[wantac]]>>
<<global [[cookie]]>>
<<global [[cookielen]]>>
<<global [[etherdst]]>>
<<global [[mtu]]([[(networking/ip/pppoe.c)]])>>

<<function [[usage]]([[(networking/ip/pppoe.c)]])>>

<<function [[catchalarm]]>>

<<function [[main]]([[(networking/ip/pppoe.c)]])>>

typedef struct Etherhdr Etherhdr;
<<struct [[Etherhdr]]([[(networking/ip/pppoe.c)]])>>

<<enum [[_anon_ (networking/ip/pppoe.c)]]>>

<<global [[etherbcast]]>>

<<function [[etherhdr]]>>

typedef struct Pppoehdr Pppoehdr;
<<struct [[Pppoehdr]]>>

<<enum [[_anon_ (networking/ip/pppoe.c)2]]>>

<<enum [[_anon_ (networking/ip/pppoe.c)3]]>>

<<function [[pppoehdr]]>>

typedef struct Taghdr Taghdr;
<<struct [[Taghdr]]>>

<<enum [[_anon_ (networking/ip/pppoe.c)4]]>>

<<function [[tag]]([[(networking/ip/pppoe.c)]])>>

<<function [[padi]]>>

<<function [[padr]]>>

<<function [[ewrite]]>>

<<function [[emalloc]]([[(networking/ip/pppoe.c)]])>>

<<function [[aread]]>>

<<function [[pktread]]>>

<<function [[bad]]>>

<<function [[copy]]>>

<<function [[clearstate]]>>

<<function [[wantoffer]]>>

<<function [[wantsession]]>>

<<function [[pppoe]]>>

<<function [[execppp]]>>

<<function [[findtag]]>>

<<function [[dumptags]]>>

<<function [[dumppkt]]>>

<<function [[malformed]]>>

<<function [[hexdump]]([[(networking/ip/pppoe.c)]])>>
@


\subsection*{[[networking/ip/pptp.c]]}

<<global [[ack]]>>=
int	ack;
@

<<global [[alarmed]]([[(networking/ip/pptp.c)]])>>=
int	alarmed;
@

<<global [[ctlechotime]]>>=
int	ctlechotime;
@

<<global [[ctlfd]]([[(networking/ip/pptp.c)]])>>=
int	ctlfd;
@

<<global [[ctlrcvtime]]>>=
int	ctlrcvtime;
@

<<global [[debug]]([[(networking/ip/pptp.c)]])>>=
int	debug;
@

<<global [[grefd]]>>=
int	grefd;
@

<<global [[localip]]>>=
uchar localip[IPaddrlen];
@

<<global [[localwin]]>>=
int	localwin;
@

<<global [[keyspec]]([[(networking/ip/pptp.c)]])>>=
char	*keyspec;
@

<<global [[now]]([[(networking/ip/pptp.c)]])>>=
int	now;
@

<<global [[pppnetmntpt]]>>=
char	*pppnetmntpt;
@

<<global [[pid]]([[(networking/ip/pptp.c)]])>>=
int	pid;
@

<<global [[pidchan]]>>=
Channel *pidchan;
@

<<global [[pppfd]]>>=
int	pppfd;
@

<<global [[primary]]([[(networking/ip/pptp.c)]])>>=
int	primary;
@

<<global [[rack]]>>=
int	rack;
@

<<global [[rdchan]]>>=
Channel	*rdchan;
@

<<global [[rdexpect]]>>=
int	rdexpect;
@

<<global [[remid]]>>=
int	remid;
@

<<global [[remoteip]]>>=
uchar remoteip[IPaddrlen];
@

<<global [[remwin]]>>=
int	remwin;
@

<<global [[rseq]]>>=
int	rseq;
@

<<global [[seq]]>>=
int	seq;
@

<<global [[tcpdir]]>>=
char	tcpdir[40];
@

<<global [[tickchan]]>>=
Channel *tickchan;
@

<<global [[topppfd]]>>=
int	topppfd;
@

<<function [[usage]]([[(networking/ip/pptp.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: ip/pptp [-Pd] [-k keyspec] [-x pppnetmntpt] [-w window] server\n");
    exits("usage");
}
@

<<function [[threadmain]]([[(networking/ip/pptp.c)]])>>=
void
threadmain(int argc, char **argv)
{
    int fd;

    ARGBEGIN{
    case 'P':
        primary = 1;
        break;
    case 'd':
        debug++;
        break;
    case 'k':
        keyspec = EARGF(usage());
        break;
    case 'w':
        localwin = atoi(EARGF(usage()));
        break;
    case 'x':
        pppnetmntpt = EARGF(usage());
        break;
    default:
        usage();
    }ARGEND

    if(argc != 1)
        usage();

    fmtinstall('E', eipfmt);
    fmtinstall('I', eipfmt);

    rfork(RFNOTEG);
    atnotify(catchalarm, 1);
    fd = pptp(argv[0]);
    pushppp(fd);
    exits(nil);
}
@

<<function [[catchalarm]]([[(networking/ip/pptp.c)]])>>=
int
catchalarm(void *a, char *msg)
{
    USED(a);

    if(strstr(msg, "alarm")){
        alarmed = 1;
        return 1;
    }
    if(debug)
        fprint(2, "note rcved: %s\n", msg);
    return 0;
}
@

<<enum [[_anon_ (networking/ip/pptp.c)]]>>=
enum {
    Stack	= 8192,

    PptpProto	= 0x0100,

    Magic	= 0x1a2b3c4d,
    Window	= 16,		/* default window size */
    Timeout	= 60,		/* timeout in seconds for control channel */
    Pktsize = 2000,		/* maximum packet size */
    Tick	= 500,		/* tick length in milliseconds */
    Sendtimeout = 4,	/* in ticks */

    Servertimeout = 5*60*1000/Tick,
    Echointerval = 60*1000/Tick,
};
@

<<enum [[_anon_ (networking/ip/pptp.c)2]]>>=
enum {
    Syncframe	= 0x1,
    Asyncframe	= 0x2,
    Analog		= 0x1,
    Digital		= 0x2,
    Version		= 0x100,
};
@

<<enum [[_anon_ (networking/ip/pptp.c)3]]>>=
enum {
    Tstart		= 1,
    Rstart		= 2,
    Tstop		= 3,
    Rstop		= 4,
    Techo		= 5,
    Recho		= 6,
    Tcallout	= 7,
    Rcallout	= 8,
    Tcallreq	= 9,
    Rcallreq	= 10,
    Acallcon	= 11,
    Tcallclear	= 12,
    Acalldis	= 13,
    Awaninfo	= 14,
    Alinkinfo	= 15,
};
@

<<function [[recho]]>>=
void
recho(uchar *in)
{
    uchar out[20];

    if(nhgets(in) < 16)
        return;

    memset(out, 0, sizeof out);
    hnputs(out, sizeof out);
    hnputs(out+2, 1);
    hnputl(out+4, Magic);
    hnputs(out+8, Recho);
    memmove(out+12, in+12, 4);
    out[16] = 1;

    ewrite(ctlfd, out, sizeof out);
}
@

<<function [[sendecho]]>>=
void
sendecho(void)
{
    uchar out[16];

    ctlechotime = now;	
    memset(out, 0, sizeof out);
    hnputs(out, sizeof out);
    hnputs(out+2, 1);
    hnputl(out+4, Magic);
    hnputs(out+8, Techo);

    ewrite(ctlfd, out, sizeof out);
}
@

<<function [[pptpctlproc]]>>=
void
pptpctlproc(void*)
{
    uchar pkt[1600], *p;
    int len;

    for(;;){
        if(readn(ctlfd, pkt, 2) != 2)
            myfatal("pptpread: %r");
        len = nhgets(pkt);
        if(len < 12 || len+2 >= sizeof pkt)
            myfatal("pptpread: bad length %d", len);
        if(readn(ctlfd, pkt+2, len-2) != len-2)
            myfatal("pptpread: %r");
        if(nhgetl(pkt+4) != Magic)
            myfatal("pptpread bad magic");
        if(nhgets(pkt+2) != 1)
            myfatal("pptpread bad message type");
        if(debug)
            dumpctlpkt(pkt);
        ctlrcvtime = now;

        switch(nhgets(pkt+8)){
        case Tstart:
        case Tstop:
        case Tcallout:
        case Tcallreq:
        case Tcallclear:
        case Acallcon:
        case Acalldis:
        case Awaninfo:
            myfatal("unexpected msg type %d", nhgets(pkt+8));
        case Techo:
            recho(pkt);
            break;
        case Recho:
            break;
        case Rstart:
        case Rstop:
        case Rcallout:
        case Rcallreq:
            if(rdexpect != nhgets(pkt+8))
                continue;
            p = emalloc(len);
            memmove(p, pkt, len);
            sendp(rdchan, p);
            break;
        case Alinkinfo:
            myfatal("cannot change ppp params on the fly");
        }
    }
}
@

<<enum [[_anon_ (networking/ip/pptp.c)4]]>>=
enum {
    Seqnum = 0x1000,
    Acknum = 0x0080,

    GrePPP = 0x880B,
};
@

<<function [[grereadproc]]>>=
void
grereadproc(void*)
{
    int datoff, flags, len, n, pass;
    uchar pkt[1600];
    uchar src[IPaddrlen], dst[IPaddrlen];

    rfork(RFFDG);
    close(pppfd);
    sendul(pidchan, getpid());

    while((n = read(grefd, pkt, sizeof pkt)) > 0){
        if(n == sizeof pkt)
            myfatal("gre pkt buffer too small");
        if(n < 16){
            if(debug)
                fprint(2, "small pkt len %d ignored\n", n);
            continue;
        }
        v4tov6(src, pkt);
        v4tov6(dst, pkt+4);
        if(ipcmp(src, remoteip) != 0 || ipcmp(dst, localip) != 0)
            myfatal("%I: gre read bad address src=%I dst=%I",
                remoteip, src, dst);
        if(nhgets(pkt+10) != GrePPP)
            myfatal("%I: gre read bad protocol 0x%x",
                remoteip, nhgets(pkt+10));

        flags = nhgets(pkt+8);
        if((flags&0xEF7F) != 0x2001){
            if(debug)
                fprint(2, "bad flags in gre hdr 0x%x\n", flags);
            continue;
        }
        datoff = 8+8;
        pass = 0;
        len = nhgets(pkt+8+4);
        if(len > n-datoff){
            fprint(2, "bad payload length %d > %d\n",
                len, n-datoff);
            continue;
        }
        if(flags&Seqnum)
            datoff += 4;
        if(flags&Acknum){
            recordack(nhgetl(pkt+datoff));
            datoff += 4;
        }
        if(flags&Seqnum)
            pass = schedack(nhgetl(pkt+8+8), pkt+datoff, len);
        if(debug)
            fprint(2, "got gre callid %d len %d flag 0x%x pass %d seq %d rseq %d\n", nhgets(pkt+8+6),
                len, flags, pass, nhgetl(pkt+8+8), rseq);
    }
    threadexits(nil);
}
@

<<function [[pppreadproc]]>>=
void
pppreadproc(void*)
{
    int n, myrseq;
    uchar pkt[1600];
    enum {
        Hdr = 8+16,
    };

    rfork(RFFDG);
    close(pppfd);
    sendul(pidchan, getpid());

    while((n = read(topppfd, pkt+Hdr, sizeof pkt-Hdr)) > 0){
        if(n == sizeof pkt-Hdr)
            myfatal("ppp pkt buffer too small");
        v6tov4(pkt+0, localip);
        v6tov4(pkt+4, remoteip);
        hnputs(pkt+8, 0x2001 | Seqnum | Acknum);
        hnputs(pkt+10, GrePPP);
        hnputs(pkt+12, n);
        hnputs(pkt+14, remid);
        hnputl(pkt+16, ++seq);
        myrseq = rseq;
        hnputl(pkt+20, myrseq);
        rack = myrseq;
        if(debug)
            fprint(2, "wrote gre callid %d len %d flag 0x%x seq %d rseq %d\n", nhgets(pkt+8+6),
                n, nhgets(pkt+8), nhgetl(pkt+16), nhgetl(pkt+20));
        if(write(grefd, pkt, n+Hdr) != n+Hdr)
            myfatal("gre write: %r");
        waitacks();
    }
    threadexits(nil);
}
@

<<function [[sendack]]([[(networking/ip/pptp.c)]])>>=
void
sendack(void)
{
    int myrseq;
    uchar pkt[20];

    v6tov4(pkt+0, localip);
    v6tov4(pkt+4, remoteip);
    hnputs(pkt+8, 0x2001 | Acknum);
    hnputs(pkt+10, GrePPP);
    hnputs(pkt+12, 0);
    hnputs(pkt+14, remid);
    myrseq = rseq;
    rack = myrseq;
    hnputs(pkt+16, myrseq);

    if(write(grefd, pkt, sizeof pkt) != sizeof pkt)
        myfatal("gre write: %r");
}
@

<<function [[schedack]]>>=
int
schedack(int n, uchar *dat, int len)
{
    static uchar sdat[1600];
    static int srseq, slen;

    if(n-rseq <= 0){
        fprint(2, "skipping pkt %d len %d, have %d\n", n, len, rseq);
        return 0;
    }

    /* missed one pkt, maybe a swap happened, save pkt */
    if(n==rseq+2){
        memmove(sdat, dat, len);
        slen = len;
        srseq = n;
        return 0;
    }

    if(n-rseq > 1){
        if(slen && srseq == n-1){	
            fprint(2, "reswapped pkts %d and %d\n", srseq, n);
            write(topppfd, sdat, slen);
            slen = 0;
        }else
            fprint(2, "missed pkts %d-%d, got %d len %d\n", rseq+1, n-1, n, len);
    }
    write(topppfd, dat, len);
    rseq = n;

    /* send ack if we haven't recently */
    if((int)(rseq-rack) > (localwin>>1))
        sendack();

    return 1;
}
@

<<function [[gretimeoutproc]]>>=
void
gretimeoutproc(void*)
{
    for(;;){
        sleep(Tick);
        now++;
        nbsendul(tickchan, now);
        if(now - ctlrcvtime > Servertimeout)
            myfatal("server timeout");
        if(now - ctlechotime > Echointerval)
            sendecho();
    }
}
@

<<function [[recordack]]>>=
void
recordack(int n)
{
    ack = n;
}
@

<<function [[waitacks]]>>=
void
waitacks(void)
{
/*
    int start;

    start = now;
    while(seq-ack > remwin && now-start < Sendtimeout){
        print("seq %d ack %d remwin %d now %d start %d\n",
            seq, ack, remwin, now, start);
        recvul(tickchan);
    }
*/
}
@

<<function [[tstart]]>>=
void
tstart(void)
{
    char *name;
    uchar pkt[200], *rpkt;

    memset(pkt, 0, sizeof pkt);

    hnputs(pkt+0, 156);
    hnputs(pkt+2, 1);
    hnputl(pkt+4, Magic);
    hnputs(pkt+8, Tstart);
    hnputs(pkt+12, PptpProto);
    hnputl(pkt+16, 1);
    hnputl(pkt+20, 1);
    hnputs(pkt+24, 1);
    name = sysname();
    if(name == nil)
        name = "gnot";
    strcpy((char*)pkt+28, name);
    strcpy((char*)pkt+92, "plan 9");

    if(debug)
        dumpctlpkt(pkt);

    rdexpect = Rstart;
    ewrite(ctlfd, pkt, 156);

    rpkt = recvp(rdchan);
    if(rpkt == nil)
        myfatal("recvp: %r");
    if(nhgets(rpkt) != 156)
        myfatal("Rstart wrong length %d != 156", nhgets(rpkt));
    if(rpkt[14] != 1)
        myfatal("Rstart error %d", rpkt[15]);
    free(rpkt);
}
@

<<function [[tcallout]]>>=
void
tcallout(void)
{
    uchar pkt[200], *rpkt;

    pid = getpid();

    memset(pkt, 0, sizeof pkt);
    hnputs(pkt+0, 168);
    hnputs(pkt+2, 1);
    hnputl(pkt+4, Magic);
    hnputs(pkt+8, Tcallout);

    hnputl(pkt+16, 56000);
    hnputl(pkt+20, 768000);
    hnputl(pkt+24, 3);
    hnputl(pkt+28, 3);
    if(localwin == 0)
        localwin = Window;
    hnputs(pkt+32, localwin);

    if(debug)
        dumpctlpkt(pkt);

    rdexpect = Rcallout;
    ewrite(ctlfd, pkt, 168);

    rpkt = recvp(rdchan);
    if(rpkt == nil)
        myfatal("recvp: %r");
    if(nhgets(rpkt) != 32)
        myfatal("Rcallreq wrong length %d != 32", nhgets(rpkt));
    if(rpkt[16] != 1)
        myfatal("Rcallreq error %d", rpkt[17]);
    remid = nhgets(pkt+12);
    remwin = nhgets(pkt+24);
    free(rpkt);
}
@

<<function [[pptp]]>>=
/*
void
tcallreq(void)
{
    uchar pkt[200], *rpkt;

    pid = getpid();

    memset(pkt, 0, sizeof pkt);
    hnputs(pkt+0, 220);
    hnputs(pkt+2, 1);
    hnputl(pkt+4, Magic);
    hnputs(pkt+8, Tcallreq);

    if(debug)
        dumpctlpkt(pkt);

    rdexpect = Rcallreq;
    ewrite(ctlfd, pkt, 220);

    rpkt = recvp(rdchan);
    if(rpkt == nil)
        myfatal("recvp: %r");
    if(nhgets(rpkt) != 24)
        myfatal("Rcallreq wrong length %d != 24", nhgets(rpkt));
    if(rpkt[16] != 1)
        myfatal("Rcallreq error %d", rpkt[17]);
    remid = nhgets(pkt+12);
    remwin = nhgets(pkt+18);
    free(rpkt);
}

void
acallcon(void)
{
    uchar pkt[200];

    memset(pkt, 0, sizeof pkt);
    hnputs(pkt+0, 28);
    hnputs(pkt+2, 1);
    hnputl(pkt+4, Magic);
    hnputs(pkt+8, Acallcon);
    hnputs(pkt+12, remid);
    if(localwin == 0)
        localwin = Window;
    hnputs(pkt+20, localwin);
    hnputl(pkt+24, 1);

    if(debug)
        dumpctlpkt(pkt);

    ewrite(ctlfd, pkt, 28);
}
*/

int
pptp(char *addr)
{
    int p[2];
    char greaddr[128];

    addr = netmkaddr(addr, "net", "pptp");
    ctlfd = dial(addr, nil, tcpdir, nil);
    if(ctlfd < 0)
        myfatal("dial %s: %r", addr);
  getaddrs();

    rdchan = chancreate(sizeof(void*), 0);
    proccreate(pptpctlproc, nil, Stack);

    tstart();
    tcallout();

    if(pipe(p) < 0)
        myfatal("pipe: %r");

    pppfd = p[0];
    topppfd = p[1];

    strcpy(greaddr, tcpdir);
    *strrchr(greaddr, '/') = '\0';
    sprint(strrchr(greaddr, '/')+1, "gre!%I!%d", remoteip, GrePPP);

    print("local %I remote %I gre %s remid %d remwin %d\n",
        localip, remoteip, greaddr, remid, remwin);

    grefd = dial(greaddr, nil, nil, nil);
    if(grefd < 0)
        myfatal("dial gre: %r");

    tickchan = chancreate(sizeof(int), 0);
    proccreate(gretimeoutproc, nil, Stack);

    pidchan = chancreate(sizeof(int), 0);
    proccreate(grereadproc, nil, Stack);
    recvul(pidchan);
    proccreate(pppreadproc, nil, Stack);
    recvul(pidchan);

    close(topppfd);
    return pppfd;
}
@

<<function [[pushppp]]>>=
void
pushppp(int fd)
{
    char *argv[16];
    int argc;

    argc = 0;
    argv[argc++] = "/bin/ip/ppp";
    argv[argc++] = "-C";
    argv[argc++] = "-m1450";
    if(debug)
        argv[argc++] = "-d";
    if(primary)
        argv[argc++] = "-P";
    if(pppnetmntpt){
        argv[argc++] = "-x";
        argv[argc++] = pppnetmntpt;
    }
    if(keyspec){
        argv[argc++] = "-k";
        argv[argc++] = keyspec;
    }
    argv[argc] = nil;

    switch(fork()){
    case -1:
        myfatal("fork: %r");
    default:
        return;
    case 0:
        dup(fd, 0);
        dup(fd, 1);
        exec(argv[0], argv);
        myfatal("exec: %r");
    }
}
@

<<function [[aread]]([[(networking/ip/pptp.c)]])>>=
int
aread(int timeout, int fd, void *buf, int nbuf)
{
    int n;

    alarmed = 0;
    alarm(timeout);
    n = read(fd, buf, nbuf);
    alarm(0);
    if(alarmed)
        return -1;
    if(n < 0)
        myfatal("read: %r");
    if(n == 0)
        myfatal("short read");
    return n;
}
@

<<function [[ewrite]]([[(networking/ip/pptp.c)]])>>=
void
ewrite(int fd, void *buf, int nbuf)
{
    char e[ERRMAX], path[64];

    if(write(fd, buf, nbuf) != nbuf){
        rerrstr(e, sizeof e);
        strcpy(path, "unknown");
        fd2path(fd, path, sizeof path);
        myfatal("write %d to %s: %s", nbuf, path, e);
    }
}
@

<<function [[emalloc]]([[(networking/ip/pptp.c)]])>>=
void*
emalloc(long n)
{
    void *v;

    v = malloc(n);
    if(v == nil)
        myfatal("out of memory");
    return v;
}
@

<<function [[thread]]([[(networking/ip/pptp.c)]])>>=
int
thread(void(*f)(void*), void *a)
{
    int pid;
    pid=rfork(RFNOWAIT|RFMEM|RFPROC);
    if(pid < 0)
        myfatal("rfork: %r");
    if(pid != 0)
        return pid;
    (*f)(a);
    _exits(nil);
    return 0; // never reaches here
}
@

<<function [[dumpctlpkt]]>>=
void
dumpctlpkt(uchar *pkt)
{
    fprint(2, "pkt len %d mtype %d cookie 0x%.8ux type %d\n",
        nhgets(pkt), nhgets(pkt+2),
        nhgetl(pkt+4), nhgets(pkt+8));

    switch(nhgets(pkt+8)){
    default:
        fprint(2, "\tunknown type\n");
        break;
    case Tstart:
        fprint(2, "\tTstart proto %d framing %d bearer %d maxchan %d firmware %d\n",
            nhgets(pkt+12), nhgetl(pkt+16),
            nhgetl(pkt+20), nhgets(pkt+24),
            nhgets(pkt+26));
        fprint(2, "\thost %.64s\n", (char*)pkt+28);
        fprint(2, "\tvendor %.64s\n", (char*)pkt+92);
        break;
    case Rstart:
        fprint(2, "\tRstart proto %d res %d err %d framing %d bearer %d maxchan %d firmware %d\n",
            nhgets(pkt+12), pkt[14], pkt[15],
            nhgetl(pkt+16),
            nhgetl(pkt+20), nhgets(pkt+24),
            nhgets(pkt+26));
        fprint(2, "\thost %.64s\n", (char*)pkt+28);
        fprint(2, "\tvendor %.64s\n", (char*)pkt+92);
        break;

    case Tstop:
        fprint(2, "\tTstop reason %d\n", pkt[12]);
        break;

    case Rstop:
        fprint(2, "\tRstop res %d err %d\n", pkt[12], pkt[13]);
        break;

    case Techo:
        fprint(2, "\tTecho id %.8ux\n", nhgetl(pkt+12));
        break;

    case Recho:
        fprint(2, "\tRecho id %.8ux res %d err %d\n", nhgetl(pkt+12), pkt[16], pkt[17]);
        break;

    case Tcallout:
        fprint(2, "\tTcallout id %d serno %d bps %d-%d\n",
            nhgets(pkt+12), nhgets(pkt+14),
            nhgetl(pkt+16), nhgetl(pkt+20));
        fprint(2, "\tbearer 0x%x framing 0x%x recvwin %d delay %d\n",
            nhgetl(pkt+24), nhgetl(pkt+28),
            nhgets(pkt+32), nhgets(pkt+34));
        fprint(2, "\tphone len %d num %.64s\n", 
            nhgets(pkt+36), (char*)pkt+40);
        fprint(2, "\tsubaddr %.64s\n", (char*)pkt+104);
        break;

    case Rcallout:
        fprint(2, "\tRcallout id %d peerid %d res %d err %d cause %d\n",
            nhgets(pkt+12), nhgets(pkt+14),
            pkt[16], pkt[17], nhgets(pkt+18));
        fprint(2, "\tconnect %d recvwin %d delay %d chan 0x%.8ux\n",
            nhgetl(pkt+20), nhgets(pkt+24),
            nhgets(pkt+26), nhgetl(pkt+28));
        break;

    case Tcallreq:
        fprint(2, "\tTcallreq id %d serno %d bearer 0x%x id 0x%x\n",
            nhgets(pkt+12), nhgets(pkt+14),
            nhgetl(pkt+16), nhgetl(pkt+20));
        fprint(2, "\tdialed len %d num %.64s\n",
            nhgets(pkt+24), (char*)pkt+28);
        fprint(2, "\tdialing len %d num %.64s\n",
            nhgets(pkt+26), (char*)pkt+92);
        fprint(2, "\tsubaddr %.64s\n", (char*)pkt+156);
        break;

    case Rcallreq:
        fprint(2, "\tRcallout id %d peerid %d res %d err %d recvwin %d delay %d\n",
            nhgets(pkt+12), nhgets(pkt+14),
            pkt[16], pkt[17], nhgets(pkt+18),
            nhgets(pkt+20));
        break;

    case Acallcon:
        fprint(2, "\tAcallcon peerid %d connect %d recvwin %d delay %d framing 0x%x\n",
            nhgets(pkt+12), nhgetl(pkt+16),
            nhgets(pkt+20), nhgets(pkt+22),
            nhgetl(pkt+24));
        break;

    case Tcallclear:
        fprint(2, "\tTcallclear callid %d\n",
            nhgets(pkt+12));
        break;

    case Acalldis:
        fprint(2, "\tAcalldis callid %d res %d err %d cause %d\n",
            nhgets(pkt+12), pkt[14], pkt[15],
            nhgets(pkt+16));
        fprint(2, "\tstats %.128s\n", (char*)pkt+20);
        break;

    case Awaninfo:
        fprint(2, "\tAwaninfo peerid %d\n", nhgets(pkt+12));
        fprint(2, "\tcrc errors %d\n", nhgetl(pkt+16));
        fprint(2, "\tframe errors %d\n", nhgetl(pkt+20));
        fprint(2, "\thardware overruns %d\n", nhgetl(pkt+24));
        fprint(2, "\tbuffer overruns %d\n", nhgetl(pkt+28));
        fprint(2, "\ttime-out errors %d\n", nhgetl(pkt+32));
        fprint(2, "\talignment errors %d\n", nhgetl(pkt+36));
        break;

    case Alinkinfo:
        fprint(2, "\tAlinkinfo peerid %d sendaccm 0x%ux recvaccm 0x%ux\n",
            nhgets(pkt+12), nhgetl(pkt+16),
            nhgetl(pkt+20));
        break;
    }
}
@

<<function [[getaddrs]]>>=
void
getaddrs(void)
{
    char buf[128];
    int fd, n;

    sprint(buf, "%s/local", tcpdir);
    if((fd = open(buf, OREAD)) < 0)
        myfatal("could not open %s: %r", buf);
    if((n = read(fd, buf, sizeof(buf))) < 0)
        myfatal("could not read %s: %r", buf);
    buf[n] = 0;
    parseip(localip, buf);
    close(fd);

    sprint(buf, "%s/remote", tcpdir);
    if((fd = open(buf, OREAD)) < 0)
        myfatal("could not open %s: %r", buf);
    if((n = read(fd, buf, sizeof(buf))) < 0)
        myfatal("could not read %s: %r", buf);
    buf[n] = 0;
    parseip(remoteip, buf);
    close(fd);
}
@

<<function [[myfatal]]([[(networking/ip/pptp.c)]])>>=
void
myfatal(char *fmt, ...)
{
    char sbuf[512];
    va_list arg;
    uchar buf[16];

    memset(buf, 0, sizeof(buf));
    hnputs(buf+0, sizeof(buf));	/* length */
    hnputs(buf+2, 1);		/* message type */
    hnputl(buf+4, Magic);		/* magic */
    hnputs(buf+8, Tstop);		/* op */
    buf[12] = 3;			/* local shutdown */
    write(ctlfd, buf, sizeof(buf));

    va_start(arg, fmt);
    vseprint(sbuf, sbuf+sizeof(sbuf), fmt, arg);
    va_end(arg);

    fprint(2, "fatal: %s\n", sbuf);
    threadexitsall(nil);
}
@


%-------------------------------------------------------------

<<networking/ip/pptp.c>>=
/*
 * Point-to-point Tunneling Protocol (PPTP)
 * See RFC 2637, pptpd.c
 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ip.h>
#include <thread.h>

<<global [[ack]]>>
<<global [[alarmed]]([[(networking/ip/pptp.c)]])>>
<<global [[ctlechotime]]>>
<<global [[ctlfd]]([[(networking/ip/pptp.c)]])>>
<<global [[ctlrcvtime]]>>
<<global [[debug]]([[(networking/ip/pptp.c)]])>>
<<global [[grefd]]>>
<<global [[localip]]>>
<<global [[localwin]]>>
<<global [[keyspec]]([[(networking/ip/pptp.c)]])>>
<<global [[now]]([[(networking/ip/pptp.c)]])>>
<<global [[pppnetmntpt]]>>
<<global [[pid]]([[(networking/ip/pptp.c)]])>>
<<global [[pidchan]]>>
<<global [[pppfd]]>>
<<global [[primary]]([[(networking/ip/pptp.c)]])>>
<<global [[rack]]>>
<<global [[rdchan]]>>
<<global [[rdexpect]]>>
<<global [[remid]]>>
<<global [[remoteip]]>>
<<global [[remwin]]>>
<<global [[rseq]]>>
<<global [[seq]]>>
<<global [[tcpdir]]>>
<<global [[tickchan]]>>
<<global [[topppfd]]>>

int	aread(int, int, void*, int);
int	catchalarm(void*, char*);
void	dumpctlpkt(uchar*);
void	getaddrs(void);
void	*emalloc(long);
void	ewrite(int, void*, int);
void	myfatal(char*, ...);
#pragma varargck argpos myfatal 1
int	pptp(char*);
void	pushppp(int);
void	recordack(int);
int	schedack(int, uchar*, int);
void	waitacks(void);

<<function [[usage]]([[(networking/ip/pptp.c)]])>>

<<function [[threadmain]]([[(networking/ip/pptp.c)]])>>

<<function [[catchalarm]]([[(networking/ip/pptp.c)]])>>

<<enum [[_anon_ (networking/ip/pptp.c)]]>>

<<enum [[_anon_ (networking/ip/pptp.c)2]]>>

<<enum [[_anon_ (networking/ip/pptp.c)3]]>>

<<function [[recho]]>>

<<function [[sendecho]]>>

<<function [[pptpctlproc]]>>

<<enum [[_anon_ (networking/ip/pptp.c)4]]>>

<<function [[grereadproc]]>>

<<function [[pppreadproc]]>>

<<function [[sendack]]([[(networking/ip/pptp.c)]])>>

<<function [[schedack]]>>

<<function [[gretimeoutproc]]>>

<<function [[recordack]]>>

<<function [[waitacks]]>>

<<function [[tstart]]>>

<<function [[tcallout]]>>

<<function [[pptp]]>>
    
<<function [[pushppp]]>>

<<function [[aread]]([[(networking/ip/pptp.c)]])>>

<<function [[ewrite]]([[(networking/ip/pptp.c)]])>>

<<function [[emalloc]]([[(networking/ip/pptp.c)]])>>

<<function [[thread]]([[(networking/ip/pptp.c)]])>>

<<function [[dumpctlpkt]]>>

<<function [[getaddrs]]>>

<<function [[myfatal]]([[(networking/ip/pptp.c)]])>>
@


\subsection*{[[networking/ip/pptpd.c]]}

<<constant [[LOG]]([[(networking/ip/pptpd.c)]])>>=
#define	LOG	"pptpd"
@

<<enum [[_anon_ (networking/ip/pptpd.c)]]>>=
enum {
    Magic	= 0x1a2b3c4d,
    Nhash	= 17,
    Nchan	= 10,		/* maximum number of channels */
    Window	= 8,		/* default window size */
    Timeout	= 60,		/* timeout in seconds for control channel */
    Pktsize = 2000,		/* maximum packet size */
    Tick	= 500,		/* tick length in milliseconds */
    Sendtimeout = 4,	/* in ticks */
};
@

<<enum [[_anon_ (networking/ip/pptpd.c)2]]>>=
enum {
    Syncframe	= 0x1,
    Asyncframe	= 0x2,
    Analog		= 0x1,
    Digital		= 0x2,
    Version		= 0x100,
};
@

<<enum [[_anon_ (networking/ip/pptpd.c)3]]>>=
enum {
    Tstart		= 1,
    Rstart		= 2,
    Tstop		= 3,
    Rstop		= 4,
    Techo		= 5,
    Recho		= 6,
    Tcallout	= 7,
    Rcallout	= 8,
    Tcallreq	= 9,
    Rcallreq	= 10,
    Acallcon	= 11,
    Tcallclear	= 12,
    Acalldis	= 13,
    Awaninfo	= 14,
    Alinkinfo	= 15,
};
@

<<struct [[Event]]>>=
struct Event {
    QLock;
    QLock waitlk;
    int	wait;
    int ready;
};
@

<<struct [[Call]]>>=
struct Call {
    int	ref;
    QLock	lk;
    int	id;
    int	serial;
    int	pppfd;

    int	closed;

    int	pac;	/* server is acting as a PAC */

    int	recvwindow;	/* recv windows */
    int	sendwindow;	/* send windows */
    int	delay;

    int	sendaccm;
    int	recvaccm;

    uint	seq;		/* current seq number - for send */
    uint	ack;		/* current acked mesg - for send */
    uint	rseq;		/* highest recv seq number for in order packet  */
    uint	rack;		/* highest ack sent */

    Event	eack;		/* recved ack - for send */
    ulong	tick;

    uchar	remoteip[IPaddrlen];	/* remote ip address */
    int	dhcpfd[2];	/* pipe to dhcpclient */

    /* error stats */
    struct {
        int	crc;
        int	frame;
        int	hardware;
        int	overrun;
        int	timeout;
        int	align;
    } err;

    struct {
        int	send;
        int	sendack;
        int	recv;
        int	recvack;
        int	dropped;
        int	missing;
        int	sendwait;
        int	sendtimeout;
    } stat;

    Call	*next;
};
@

<<global [[srv]]([[(networking/ip/pptpd.c)]])>>=
struct {
    QLock	lk;
    int	start;
    int	grefd;
    int	grecfd;
    uchar	local[IPaddrlen];
    uchar	remote[IPaddrlen];
    char	*tcpdir;
    uchar	ipaddr[IPaddrlen];		/* starting ip addresss to allocate */

    int	recvwindow;

    char	*pppdir;
    char	*pppexec;

    double	rcvtime;	/* time at which last request was received */
    int	echoid;		/* id of last echo request */

    Call	*hash[Nhash];
} srv;
@

<<enum [[_anon_ (networking/ip/pptpd.c)4]]>>=
/* GRE flag bits */
enum {
    GRE_chksum	= (1<<15),
    GRE_routing	= (1<<14),
    GRE_key		= (1<<13),
    GRE_seq		= (1<<12),
    GRE_srcrt	= (1<<11),
    GRE_recur	= (7<<8),
    GRE_ack		= (1<<7),
    GRE_ver		= 0x7,
};
@

<<enum [[_anon_ (networking/ip/pptpd.c)5]]>>=
/* GRE protocols */
enum {
    GRE_ppp		= 0x880b,
};
@

<<global [[debug]]([[(networking/ip/pptpd.c)]])>>=
int	debug;
@

<<global [[drop]]>>=
double	drop;
@

<<macro [[PSHORT]]>>=
#define	PSHORT(p, v)		((p)[0]=((v)>>8), (p)[1]=(v))
@

<<macro [[PLONG]]>>=
#define	PLONG(p, v)		(PSHORT(p, (v)>>16), PSHORT(p+2, (v)))
@

<<macro [[PSTRING]]>>=
#define	PSTRING(d,s,n)		strncpy((char*)(d), s, n)
@

<<macro [[GSHORT]]>>=
#define	GSHORT(p)		(((p)[0]<<8) | ((p)[1]<<0))
@

<<macro [[GLONG]]>>=
#define	GLONG(p)		((GSHORT((p))<<16) | ((GSHORT((p)+2))<<0))
@

<<macro [[GSTRING]]>>=
#define	GSTRING(d,s,n)		strncpy(d, (char*)(s), n), d[(n)-1] = 0
@

<<function [[usage]]([[(networking/ip/pptpd.c)]])>>=
void
usage(void)
{
    fprint(2, "usage: pptpd [-dD] [-p ppp-net] [-w window] tcpdir\n");
    exits("usage");
}
@

<<function [[serve]]>>=
void
serve(void)
{
    uchar buf[2000], *p;
    int n, n2, len;
    int magic;
    int op, type;

    n = 0;
    for(;;) {
        n2 = read(0, buf+n, sizeof(buf)-n);
        if(n2 < 0)
            myfatal("bad read on ctl channel: %r");
        if(n2 == 0)
            break;
        n += n2;
        p = buf;
        for(;;) {
            if(n < 12)
                break;

            qlock(&srv.lk);
            srv.rcvtime = realtime();
            qunlock(&srv.lk);

            len = GSHORT(p);
            type = GSHORT(p+2);
            magic = GLONG(p+4);
            op = GSHORT(p+8);
            if(magic != Magic)
                myfatal("bad magic number: got %x", magic);
            if(type != 1)
                myfatal("bad message type: %d", type);
            switch(op) {
            default:
                myfatal("unknown control op: %d", op);
            case Tstart:		/* start-control-connection-request */
                n2 = sstart(p, n);
                break;
            case Tstop:
                n2 = sstop(p, n);
                if(n2 > 0)
                    return;
                break;
            case Techo:
                n2 = secho(p, n);
                break;
            case Tcallout:
                n2 = scallout(p, n);
                break;
            case Tcallreq:
                n2 = scallreq(p, n);
                break;
            case Acallcon:
                n2 = scallcon(p, n);
                break;
            case Tcallclear:
                n2 = scallclear(p, n);
                break;
            case Acalldis:
                n2 = scalldis(p, n);
                break;
            case Awaninfo:
                n2 = swaninfo(p, n);
                break;
            case Alinkinfo:
                n2 = slinkinfo(p, n);
                break;
            }	
            if(n2 == 0)
                break;
            if(n2 != len)
                myfatal("op=%d: bad length: got %d expected %d", op, len, n2);
            n -= n2;
            p += n2;
            
        }

        /* move down partial message */
        if(p != buf && n != 0)
            memmove(buf, p, n);
    }

}
@

<<function [[scallreq]]>>=
int
scallreq(uchar *p, int n)
{
    USED(p);
    USED(n);

    myfatal("callreq: not done yet");
    return 0;
}
@

<<function [[scallcon]]>>=
int
scallcon(uchar *p, int n)
{
    USED(p);
    USED(n);

    myfatal("callcon: not done yet");
    return 0;
}
@

<<function [[callalloc]]>>=
Call*
callalloc(int id)
{
    uint h;
    Call *c;
    char buf[300], *argv[30], local[20], remote[20], **p;
    int fd, pfd[2], n;

    h = id%Nhash;

    qlock(&srv.lk);
    for(c=srv.hash[h]; c; c=c->next)
        if(c->id == id)
            myfatal("callalloc: duplicate id: %d", id);
    c = emallocz(sizeof(Call));
    c->ref = 1;
    c->id = id;
    c->sendaccm = ~0;
    c->recvaccm = ~0;

    if(!ipaddralloc(c))
        myfatal("callalloc: could not alloc remote ip address");

    if(pipe(pfd) < 0)
        myfatal("callalloc: pipe failed: %r");

    sprint(buf, "%s/ipifc/clone", srv.pppdir);
    fd = open(buf, OWRITE);
    if(fd < 0)
        myfatal("callalloc: could not open %s: %r", buf);

    n = sprint(buf, "iprouting");
    if(write(fd, buf, n) < n)
        myfatal("callalloc: write to ifc failed: %r");
    close(fd);

    p = argv;
    *p++ = srv.pppexec;
    *p++ = "-SC";
    *p++ = "-x";
    *p++ = srv.pppdir;
    if(debug)
        *p++ = "-d";
    sprint(local, "%I", srv.ipaddr);
    *p++ = local;
    sprint(remote, "%I", c->remoteip);
    *p++ = remote;
    *p = 0;

    proc(argv, pfd[0], pfd[0], 2);

    close(pfd[0]);

    c->pppfd = pfd[1];

    c->next = srv.hash[h];
    srv.hash[h] = c;

    qunlock(&srv.lk);

    c->ref++;
    thread(pppread, c);
    c->ref++;
    thread(gretimeout, c);

    syslog(0, LOG, ": src=%I: call started: id=%d: remote ip=%I", srv.remote, id, c->remoteip);

    return c;
}
@

<<function [[callclose]]>>=
void
callclose(Call *c)
{
    Call *oc;
    int id;
    uint h;

    syslog(0, LOG, ": src=%I: call closed: id=%d: send=%d sendack=%d recv=%d recvack=%d dropped=%d missing=%d sendwait=%d sendtimeout=%d",
        srv.remote, c->id, c->stat.send, c->stat.sendack, c->stat.recv, c->stat.recvack,
        c->stat.dropped, c->stat.missing, c->stat.sendwait, c->stat.sendtimeout);

    qlock(&srv.lk);
    if(c->closed) {
        qunlock(&srv.lk);
        return;
    }
    c->closed = 1;

    close(c->dhcpfd[0]);
    close(c->dhcpfd[1]);
    close(c->pppfd);
    c->pppfd = -1;

    h = c->id%Nhash;
    id = c->id;
    for(c=srv.hash[h],oc=0; c; oc=c,c=c->next)
        if(c->id == id)
            break;
    if(oc == 0)
        srv.hash[h] = c->next;
    else
        oc->next = c->next;
    c->next = 0;
    qunlock(&srv.lk);

    callfree(c);
}
@

<<function [[calllookup]]>>=
Call*
calllookup(int id)
{
    uint h;
    Call *c;

    h = id%Nhash;

    qlock(&srv.lk);
    for(c=srv.hash[h]; c; c=c->next)
        if(c->id == id)
            break;
    if(c != 0)
        c->ref++;
    qunlock(&srv.lk);

    return c;
}
@

<<function [[srvinit]]>>=
void
srvinit(void)
{
    char buf[100];
    int fd, n;

    sprint(buf, "%s/local", srv.tcpdir);
    if((fd = open(buf, OREAD)) < 0)
        myfatal("could not open %s: %r", buf);
    if((n = read(fd, buf, sizeof(buf))) < 0)
        myfatal("could not read %s: %r", buf);
    buf[n] = 0;
    parseip(srv.local, buf);
    close(fd);

    sprint(buf, "%s/remote", srv.tcpdir);
    if((fd = open(buf, OREAD)) < 0)
        myfatal("could not open %s: %r", buf);
    if((n = read(fd, buf, sizeof(buf))) < 0)
        myfatal("could not read %s: %r", buf);
    buf[n] = 0;
    parseip(srv.remote, buf);
    close(fd);

    if(srv.pppdir == 0)
        srv.pppdir = "/net";

    if(srv.pppexec == 0)
        srv.pppexec = "/bin/ip/ppp";

    if(myipaddr(srv.ipaddr, srv.pppdir) < 0)
        myfatal("could not read local ip addr: %r");
    if(srv.recvwindow == 0)
        srv.recvwindow = Window;
}
@

<<function [[gretimeout]]>>=
void
gretimeout(void *a)
{
    Call *c;

    c = a;

    while(!c->closed) {
        sleep(Tick);
        qlock(&c->lk);
        c->tick++;
        qunlock(&c->lk);
        esignal(&c->eack);
    }
    callfree(c);
    exits(0);
}
@

<<function [[timeoutthread]]>>=
void
timeoutthread(void*)
{
    for(;;) {
        sleep(30*1000);

        qlock(&srv.lk);
        if(realtime() - srv.rcvtime > 5*60)
            myfatal("server timedout");
        qunlock(&srv.lk);
    }
}
@

<<function [[argatoi]]>>=
int
argatoi(char *p)
{
    char *q;
    int i;

    if(p == 0)
        usage();

    i = strtol(p, &q, 0);
    if(q == p)
        usage();
    return i;
}
@

<<function [[dhcpclientwatch]]>>=
void
dhcpclientwatch(void *a)
{
    Call *c = a;
    uchar buf[1];

    for(;;) {
        if(read(c->dhcpfd[0], buf, sizeof(buf)) <= 0)
            break;
    }
    if(!c->closed)
        myfatal("dhcpclient terminated");
    callfree(c);
    exits(0);
}
@

<<function [[ipaddralloc]]>>=
int
ipaddralloc(Call *c)
{
    int pfd[2][2];
    char *argv[4], *p;
    Biobuf bio;

    argv[0] = "/bin/ip/dhcpclient";
    argv[1] = "-x";
    argv[2] = srv.pppdir;
    argv[3] = 0;

    if(pipe(pfd[0])<0)
        myfatal("ipaddralloc: pipe failed: %r");
    if(pipe(pfd[1])<0)
        myfatal("ipaddralloc: pipe failed: %r");

    if(proc(argv, pfd[0][0], pfd[1][1], 2) < 0)
        myfatal("ipaddralloc: proc failed: %r");

    close(pfd[0][0]);
    close(pfd[1][1]);
    c->dhcpfd[0] = pfd[1][0];
    c->dhcpfd[1] = pfd[0][1];

    Binit(&bio, pfd[1][0], OREAD);
    for(;;) {
        p = Brdline(&bio, '\n');
        if(p == 0)
            break;
        if(strncmp(p, "ip=", 3) == 0) {
            p += 3;
            parseip(c->remoteip, p);
        } else if(strncmp(p, "end\n", 4) == 0)
            break;
    }

    Bterm(&bio);

    c->ref++;

    thread(dhcpclientwatch, c);

    return ipcmp(c->remoteip, IPnoaddr) != 0;
}
@

<<function [[esignal]]>>=
void
esignal(Event *e)
{	
    qlock(e);
    if(e->wait == 0) {
        e->ready = 1;
        qunlock(e);
        return;
    }
    assert(e->ready == 0);
    e->wait = 0;
    rendezvous(e, (void*)1);
    qunlock(e);
}
@

<<function [[ewait]]>>=
void
ewait(Event *e)
{
    qlock(&e->waitlk);
    qlock(e);
    assert(e->wait == 0);
    if(e->ready) {
        e->ready = 0;
    } else {	
        e->wait = 1;
        qunlock(e);
        rendezvous(e, (void*)2);
        qlock(e);
    }
    qunlock(e);
    qunlock(&e->waitlk);
}
@

<<function [[thread]]([[(networking/ip/pptpd.c)]])>>=
ulong
thread(void(*f)(void*), void *a)
{
    int pid;
    pid=rfork(RFNOWAIT|RFMEM|RFPROC);
    if(pid < 0)
        myfatal("rfork failed: %r");
    if(pid != 0)
        return pid;
    (*f)(a);
    return 0; // never reaches here
}
@

<<function [[realtime]]>>=
double
realtime(void)
{
    long times(long*);

    return times(0) / 1000.0;
}
@

<<function [[emallocz]]([[(networking/ip/pptpd.c)]])>>=
void *
emallocz(int size)
{
    void *p;
    p = malloc(size);
    if(p == 0)
        myfatal("malloc failed: %r");
    memset(p, 0, size);
    return p;
}
@

<<function [[fdclose]]>>=
static void
fdclose(void)
{
    int fd, n, i;
    Dir *d, *p;

    if((fd = open("#d", OREAD)) < 0)
        return;

    n = dirreadall(fd, &d);
    for(p = d; n > 0; n--, p++) {
        i = atoi(p->name);
        if(i > 2)
            close(i);
    }
    free(d);
}
@

<<function [[proc]]>>=
int
proc(char **argv, int fd0, int fd1, int fd2)
{
    int r, flag;
    char *arg0, file[200];

    arg0 = argv[0];

    strcpy(file, arg0);

    if(access(file, 1) < 0) {
        if(strncmp(arg0, "/", 1)==0
        || strncmp(arg0, "#", 1)==0
        || strncmp(arg0, "./", 2)==0
        || strncmp(arg0, "../", 3)==0)
            return 0;
        sprint(file, "/bin/%s", arg0);
        if(access(file, 1) < 0)
            return 0;
    }

    flag = RFPROC|RFFDG|RFENVG|RFNOWAIT;
    if((r = rfork(flag)) != 0) {
        if(r < 0)
            return 0;
        return r;
    }

    if(fd0 != 0) {
        if(fd1 == 0)
            fd1 = dup(0, -1);
        if(fd2 == 0)
            fd2 = dup(0, -1);
        close(0);
        if(fd0 >= 0)
            dup(fd0, 0);
    }

    if(fd1 != 1) {
        if(fd2 == 1)
            fd2 = dup(1, -1);
        close(1);
        if(fd1 >= 0)
            dup(fd1, 1);
    }

    if(fd2 != 2) {
        close(2);
        if(fd2 >= 0)
            dup(fd2, 2);
    }

    fdclose();

    exec(file, argv);
    myfatal("proc: exec failed: %r");
    return 0;
}
@


%-------------------------------------------------------------

<<networking/ip/pptpd.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ip.h>

<<constant [[LOG]]([[(networking/ip/pptpd.c)]])>>

typedef struct Call	Call;
typedef struct Event Event;

#define	SDB	if(debug) fprint(2, 
#define EDB	);

<<enum [[_anon_ (networking/ip/pptpd.c)]]>>

<<enum [[_anon_ (networking/ip/pptpd.c)2]]>>

<<enum [[_anon_ (networking/ip/pptpd.c)3]]>>


<<struct [[Event]]>>

<<struct [[Call]]>>

<<global [[srv]]([[(networking/ip/pptpd.c)]])>>

<<enum [[_anon_ (networking/ip/pptpd.c)4]]>>

<<enum [[_anon_ (networking/ip/pptpd.c)5]]>>

<<global [[debug]]([[(networking/ip/pptpd.c)]])>>
<<global [[drop]]>>

void	myfatal(char *fmt, ...);

<<macro [[PSHORT]]>>
<<macro [[PLONG]]>>
<<macro [[PSTRING]]>>
<<macro [[GSHORT]]>>
<<macro [[GLONG]]>>
<<macro [[GSTRING]]>>

void	serve(void);

int	sstart(uchar*, int);
int	sstop(uchar*, int);
int	secho(uchar*, int);
int	scallout(uchar*, int);
int	scallreq(uchar*, int);
int	scallcon(uchar*, int);
int	scallclear(uchar*, int);
int	scalldis(uchar*, int);
int	swaninfo(uchar*, int);
int	slinkinfo(uchar*, int);

Call	*callalloc(int id);
void	callclose(Call*);
void	callfree(Call*);
Call	*calllookup(int id);

void	gretimeout(void*);
void	pppread(void*);

void	srvinit(void);
void	greinit(void);
void	greread(void*);
void	greack(Call *c);

void	timeoutthread(void*);

int	argatoi(char *p);
void	usage(void);
int	ipaddralloc(Call *c);

void	*emallocz(int size);
void	esignal(Event *e);
void	ewait(Event *e);
int	proc(char **argv, int fd0, int fd1, int fd2);
double	realtime(void);
ulong	thread(void(*f)(void*), void *a);

void
main(int argc, char *argv[])
{
    ARGBEGIN{
    case 'd': debug++; break;
    case 'p': srv.pppdir = ARGF(); break;
    case 'P': srv.pppexec = ARGF(); break;
    case 'w': srv.recvwindow = argatoi(ARGF()); break;
    case 'D': drop = atof(ARGF()); break;
    default:
        usage();
    }ARGEND

    fmtinstall('I', eipfmt);
    fmtinstall('E', eipfmt);
    fmtinstall('V', eipfmt);
    fmtinstall('M', eipfmt);

    rfork(RFNOTEG|RFREND);

    if(argc != 1)
        usage();

    srv.tcpdir = argv[0];

    srvinit();

    syslog(0, LOG, ": src=%I: pptp started: %d", srv.remote, getpid());

    SDB  "\n\n\n%I: pptp started\n", srv.remote EDB

    greinit();

    thread(timeoutthread, 0);

    serve();

    syslog(0, LOG, ": src=%I: server exits", srv.remote);

    exits(0);
}

<<function [[usage]]([[(networking/ip/pptpd.c)]])>>

<<function [[serve]]>>

int
sstart(uchar *p, int n)
{
    int ver, frame, bearer, maxchan, firm;
    char host[64], vendor[64], *sysname;
    uchar buf[156];

    if(n < 156)
        return 0;
    ver = GSHORT(p+12);
    frame = GLONG(p+16);
    bearer = GLONG(p+20);
    maxchan = GSHORT(p+24);
    firm = GSHORT(p+26);
    GSTRING(host, p+28, 64);
    GSTRING(vendor, p+92, 64);

    SDB "%I: start ver = %x f = %d b = %d maxchan = %d firm = %d host = %s vendor = %s\n",
        srv.remote, ver, frame, bearer, maxchan, firm, host, vendor EDB

    if(ver != Version)
        myfatal("bad version: got %x expected %x", ver, Version);

    if(srv.start)
        myfatal("multiple start messages");

    srv.start = 1;

    sysname = getenv("sysname");
    if(sysname == 0)
        strcpy(host, "gnot");
    else
        strncpy(host, sysname, 64);
    free(sysname);

    memset(buf, 0, sizeof(buf));

    PSHORT(buf+0, sizeof(buf));	/* length */
    PSHORT(buf+2, 1);		/* message type */
    PLONG(buf+4, Magic);		/* magic */
    PSHORT(buf+8, Rstart);		/* op */
    PSHORT(buf+12, Version);	/* version */
    buf[14] = 1;			/* result = ok */
    PLONG(buf+16, Syncframe|Asyncframe);	/* frameing */
    PLONG(buf+20, Digital|Analog);	/* berear capabilities */
    PSHORT(buf+24, Nchan);		/* max channels */
    PSHORT(buf+26, 1);		/* driver version */
    PSTRING(buf+28, host, 64);	/* host name */
    PSTRING(buf+92, "plan 9", 64);	/* vendor */

    if(write(1, buf, sizeof(buf)) < sizeof(buf))
        myfatal("write failed: %r");

    return 156;
}

int
sstop(uchar *p, int n)
{
    int reason;
    uchar buf[16];

    if(n < 16)
        return 0;
    reason = p[12];
    
    SDB "%I: stop %d\n", srv.remote, reason EDB

    memset(buf, 0, sizeof(buf));
    PSHORT(buf+0, sizeof(buf));	/* length */
    PSHORT(buf+2, 1);		/* message type */
    PLONG(buf+4, Magic);		/* magic */
    PSHORT(buf+8, Rstop);		/* op */
    buf[12] = 1;			/* ok */

    if(write(1, buf, sizeof(buf)) < sizeof(buf))
        myfatal("write failed: %r");

    return 16;
}

int
secho(uchar *p, int n)
{
    int id;
    uchar buf[20];

    if(n < 16)
        return 0;
    id = GLONG(p+12);
    
    SDB "%I: echo %d\n", srv.remote, id EDB

    memset(buf, 0, sizeof(buf));
    PSHORT(buf+0, sizeof(buf));	/* length */
    PSHORT(buf+2, 1);		/* message type */
    PLONG(buf+4, Magic);		/* magic */
    PSHORT(buf+8, Recho);		/* op */
    PLONG(buf+12, id);		/* id */
    p[16] = 1;			/* ok */

    if(write(1, buf, sizeof(buf)) < sizeof(buf))
        myfatal("write failed: %r");

    return 16;
}

int
scallout(uchar *p, int n)
{
    int id, serial;
    int minbps, maxbps, bearer, frame;
    int window, delay;
    int nphone;
    char phone[64], sub[64], buf[32];
    Call *c;

    if(n < 168)
        return 0;

    if(!srv.start)
        myfatal("%I: did not recieve start message", srv.remote);
    
    id = GSHORT(p+12);
    serial = GSHORT(p+14);
    minbps = GLONG(p+16);
    maxbps = GLONG(p+20);
    bearer = GLONG(p+24);
    frame = GLONG(p+28);
    window = GSHORT(p+32);
    delay = GSHORT(p+34);
    nphone = GSHORT(p+36);
    GSTRING(phone, p+40, 64);
    GSTRING(sub, p+104, 64);

    SDB "%I: callout id = %d serial = %d bps=[%d,%d] b=%x f=%x win = %d delay = %d np=%d phone=%s sub=%s\n",
        srv.remote, id, serial, minbps, maxbps, bearer, frame, window, delay, nphone, phone, sub EDB

    c = callalloc(id);
    c->sendwindow = window;
    c->delay = delay;
    c->pac = 1;
    c->recvwindow = srv.recvwindow;

    memset(buf, 0, sizeof(buf));
    PSHORT(buf+0, sizeof(buf));	/* length */
    PSHORT(buf+2, 1);		/* message type */
    PLONG(buf+4, Magic);		/* magic */
    PSHORT(buf+8, Rcallout);	/* op */
    PSHORT(buf+12, id);		/* call id */
    PSHORT(buf+14, id);		/* peer id */
    buf[16] = 1;			/* ok */
    PLONG(buf+20, 10000000);	/* speed */
    PSHORT(buf+24, c->recvwindow);	/* window size */
    PSHORT(buf+26, 0);		/* delay */
    PLONG(buf+28, 0);		/* channel id */
    
    if(write(1, buf, sizeof(buf)) < sizeof(buf))
        myfatal("write failed: %r");

    return 168;
}

<<function [[scallreq]]>>

<<function [[scallcon]]>>

int
scallclear(uchar *p, int n)
{
    Call *c;
    int id;
    uchar buf[148];

    if(n < 16)
        return 0;
    id = GSHORT(p+12);
    
    SDB "%I: callclear id=%d\n", srv.remote, id EDB
    
    if(c = calllookup(id)) {
        callclose(c);
        callfree(c);
    }

    memset(buf, 0, sizeof(buf));
    PSHORT(buf+0, sizeof(buf));	/* length */
    PSHORT(buf+2, 1);		/* message type */
    PLONG(buf+4, Magic);		/* magic */
    PSHORT(buf+8, Acalldis);	/* op */
    PSHORT(buf+12, id);		/* id */
    buf[14] = 3;			/* reply to callclear */

    if(write(1, buf, sizeof(buf)) < sizeof(buf))
        myfatal("write failed: %r");

    return 16;
}

int
scalldis(uchar *p, int n)
{
    Call *c;
    int id, res;

    if(n < 148)
        return 0;
    id = GSHORT(p+12);
    res = p[14];

    SDB "%I: calldis id=%d res=%d\n", srv.remote, id, res EDB

    if(c = calllookup(id)) {
        callclose(c);
        callfree(c);
    }

    return 148;
}

int
swaninfo(uchar *p, int n)
{
    Call *c;
    int id;

    if(n < 40)
        return 0;
    
    id = GSHORT(p+12);
    SDB "%I: waninfo id = %d\n", srv.remote, id EDB
    
    c = calllookup(id);
    if(c != 0) {
        c->err.crc = GLONG(p+16);
        c->err.frame = GLONG(p+20);
        c->err.hardware = GLONG(p+24);
        c->err.overrun = GLONG(p+28);
        c->err.timeout = GLONG(p+32);
        c->err.align = GLONG(p+36);

        callfree(c);
    }

    
    return 40;
}

int
slinkinfo(uchar *p, int n)
{
    Call *c;
    int id;
    int sendaccm, recvaccm;

    if(n < 24)
        return 0;
    id = GSHORT(p+12);
    sendaccm = GLONG(p+16);
    recvaccm = GLONG(p+20);

    SDB "%I: linkinfo id=%d saccm=%ux raccm=%ux\n", srv.remote, id, sendaccm, recvaccm EDB

    if(c = calllookup(id)) {
        c->sendaccm = sendaccm;
        c->recvaccm = recvaccm;

        callfree(c);
    }
    
    return 24;
}

<<function [[callalloc]]>>

<<function [[callclose]]>>

void
callfree(Call *c)
{	
    int ref;
    
    qlock(&srv.lk);
    ref = --c->ref;
    qunlock(&srv.lk);
    if(ref > 0)
        return;
    
    /* already unhooked from hash list - see callclose */
    assert(c->closed == 1);
    assert(ref == 0);
    assert(c->next == 0);

SDB "call free\n" EDB	
    free(c);
}

<<function [[calllookup]]>>


<<function [[srvinit]]>>

void
greinit(void)
{
    char addr[100], *p;
    int fd, cfd;

    SDB "srv.tcpdir = %s\n", srv.tcpdir EDB
    strcpy(addr, srv.tcpdir);
    p = strrchr(addr, '/');
    if(p == 0)
        myfatal("bad tcp dir: %s", srv.tcpdir);
    *p = 0;
    p = strrchr(addr, '/');
    if(p == 0)
        myfatal("bad tcp dir: %s", srv.tcpdir);
    sprint(p, "/gre!%I!34827", srv.remote);

    SDB "addr = %s\n", addr EDB

    fd = dial(addr, 0, 0, &cfd);

    if(fd < 0)
        myfatal("%I: dial %s failed: %r", srv.remote, addr);

    srv.grefd = fd;
    srv.grecfd = cfd;

    thread(greread, 0);
}

void
greread(void *)
{
    uchar buf[Pktsize], *p;
    int n, i;
    int flag, prot, len, callid;
    uchar src[IPaddrlen], dst[IPaddrlen];
    uint rseq, ack;
    Call *c;
    static double t, last;

    for(;;) {
        n = read(srv.grefd, buf, sizeof(buf));
        if(n < 0)
            myfatal("%I: bad read on gre: %r", srv.remote);
        if(n == sizeof(buf))
            myfatal("%I: gre read: buf too small", srv.remote);

        p = buf;
        v4tov6(src, p);
        v4tov6(dst, p+4);
        flag = GSHORT(p+8);
        prot = GSHORT(p+10);
        p += 12; n -= 12;

        if(ipcmp(src, srv.remote) != 0 || ipcmp(dst, srv.local) != 0)
            myfatal("%I: gre read bad address src=%I dst=%I", srv.remote, src, dst);

        if(prot != GRE_ppp)
            myfatal("%I: gre read gave bad protocol", srv.remote);

        if(flag & (GRE_chksum|GRE_routing)){
            p += 4; n -= 4;
        }

        if(!(flag&GRE_key))
            myfatal("%I: gre packet does not contain a key: f=%ux",
                srv.remote, flag);

        len = GSHORT(p);
        callid = GSHORT(p+2);
        p += 4; n -= 4;

        c = calllookup(callid);
        if(c == 0) {
            SDB "%I: unknown callid: %d\n", srv.remote, callid EDB
            continue;
        }

        qlock(&c->lk);

        c->stat.recv++;

        if(flag&GRE_seq) {
            rseq = GLONG(p);
            p += 4; n -= 4;
        } else
            rseq = c->rseq;

        if(flag&GRE_ack){
            ack = GLONG(p);
            p += 4; n -= 4;
        } else
            ack = c->ack;

        /* skip routing if present */
        if(flag&GRE_routing) {
            while((i=p[3]) != 0) {
                n -= i;
                p += i;
            }
        }

        if(len > n)
            myfatal("%I: bad len in gre packet", srv.remote);

        if((int)(ack-c->ack) > 0) {
            c->ack = ack;
            esignal(&c->eack);
        }

        if(debug)
            t = realtime();

        if(len == 0) {
            /* ack packet */
            c->stat.recvack++;

SDB "%I: %.3f (%.3f): gre %d: recv ack a=%ux n=%d flag=%ux\n", srv.remote, t, t-last,
    c->id, ack, n, flag EDB

        } else {

SDB "%I: %.3f (%.3f): gre %d: recv s=%ux a=%ux len=%d\n", srv.remote, t, t-last,
    c->id, rseq, ack, len EDB

            /*
             * the following handles the case of a single pair of packets
             * received out of order
             */
            n = rseq-c->rseq;
            if(n > 0 && (drop == 0. || frand() > drop)) {
                c->stat.missing += n-1;
                /* current packet */
                write(c->pppfd, p, len);
            } else {
                /* out of sequence - drop on the floor */
                c->stat.dropped++;

SDB "%I: %.3f: gre %d: recv out of order or dup packet: seq=%ux len=%d\n",
srv.remote, realtime(), c->id, rseq, len EDB

            }
        }

        if((int)(rseq-c->rseq) > 0)
            c->rseq = rseq;

        if(debug)
            last=t;

        /* open up client window */
        if((int)(c->rseq-c->rack) > (c->recvwindow>>1))
            greack(c);

        qunlock(&c->lk);


        callfree(c);
    }
}

void
greack(Call *c)
{
    uchar buf[20];

    c->stat.sendack++;

SDB "%I: %.3f: gre %d: send ack %ux\n", srv.remote, realtime(), c->id, c->rseq EDB

    v6tov4(buf+0, srv.local);		/* source */
    v6tov4(buf+4, srv.remote);		/* source */
    PSHORT(buf+8, GRE_key|GRE_ack|1);
    PSHORT(buf+10, GRE_ppp);
    PSHORT(buf+12, 0);
    PSHORT(buf+14, c->id);
    PLONG(buf+16, c->rseq);

    write(srv.grefd, buf, sizeof(buf));

    c->rack = c->rseq;

}

<<function [[gretimeout]]>>


void
pppread(void *a)
{
    Call *c;
    uchar buf[2000], *p;
    int n;
    ulong tick;

    c = a;
    for(;;) {
        p = buf+24;
        n = read(c->pppfd, p, sizeof(buf)-24);
        if(n <= 0)
            break;
        
        qlock(&c->lk);

        /* add gre header */
        c->seq++;
        tick = c->tick;

        while(c->seq-c->ack>c->sendwindow && c->tick-tick<Sendtimeout && !c->closed) {
            c->stat.sendwait++;
SDB "window full seq = %d ack = %ux window = %ux\n", c->seq, c->ack, c->sendwindow EDB
            qunlock(&c->lk);
            ewait(&c->eack);
            qlock(&c->lk);
        }
        
        if(c->tick-tick >= Sendtimeout) {
            c->stat.sendtimeout++;
SDB "send timeout = %d ack = %ux window = %ux\n", c->seq, c->ack, c->sendwindow EDB
        }

        v6tov4(buf+0, srv.local);		/* source */
        v6tov4(buf+4, srv.remote);		/* source */
        PSHORT(buf+8, GRE_key|GRE_seq|GRE_ack|1);
        PSHORT(buf+10, GRE_ppp);
        PSHORT(buf+12, n);
        PSHORT(buf+14, c->id);
        PLONG(buf+16, c->seq);
        PLONG(buf+20, c->rseq);

        c->stat.send++;
        c->rack = c->rseq;

SDB "%I: %.3f: gre %d: send s=%ux a=%ux len=%d\n", srv.remote, realtime(),
    c->id,  c->seq, c->rseq, n EDB

        if(drop == 0. || frand() > drop)
            if(write(srv.grefd, buf, n+24)<n+24)
                myfatal("pppread: write failed: %r");

        qunlock(&c->lk);
    }

    SDB "pppread exit: %d\n", c->id);
    
    callfree(c);
    exits(0);
}

<<function [[timeoutthread]]>>


/* use syslog() rather than fprint(2, ...) */
void
myfatal(char *fmt, ...)
{
    char sbuf[512];
    va_list arg;
    uchar buf[16];

    /* NT don't seem to like us just going away */
    memset(buf, 0, sizeof(buf));
    PSHORT(buf+0, sizeof(buf));	/* length */
    PSHORT(buf+2, 1);		/* message type */
    PLONG(buf+4, Magic);		/* magic */
    PSHORT(buf+8, Tstop);		/* op */
    buf[12] = 3;			/* local shutdown */

    write(1, buf, sizeof(buf));

    va_start(arg, fmt);
    vseprint(sbuf, sbuf+sizeof(sbuf), fmt, arg);
    va_end(arg);

    SDB "%I: fatal: %s\n", srv.remote, sbuf EDB
    syslog(0, LOG, ": src=%I: fatal: %s", srv.remote, sbuf);

    close(0);
    close(1);
    close(srv.grefd);
    close(srv.grecfd);

    postnote(PNGROUP, getpid(), "die");
    exits(sbuf);
}

<<function [[argatoi]]>>

<<function [[dhcpclientwatch]]>>

<<function [[ipaddralloc]]>>


<<function [[esignal]]>>

<<function [[ewait]]>>

<<function [[thread]]([[(networking/ip/pptpd.c)]])>>

<<function [[realtime]]>>

<<function [[emallocz]]([[(networking/ip/pptpd.c)]])>>

<<function [[fdclose]]>>

<<function [[proc]]>>

@


\section{[[kernel/network/ip/]]}

\subsection*{[[kernel/network/ip/icmp6.c]]}

<<enum [[_anon_ (kernel/network/ip/icmp6.c)]]>>=
enum
{
    InMsgs6,
    InErrors6,
    OutMsgs6,
    CsumErrs6,
    LenErrs6,
    HlenErrs6,
    HoplimErrs6,
    IcmpCodeErrs6,
    TargetErrs6,
    OptlenErrs6,
    AddrmxpErrs6,
    RouterAddrErrs6,

    Nstats6,
};
@

<<enum [[_anon_ (kernel/network/ip/icmp6.c)2]]>>=
enum {
    ICMP_USEAD6 = 40,
};
@

<<enum [[_anon_ (kernel/network/ip/icmp6.c)3]]>>=
enum {
    Oflag   = 1<<5,
    Sflag   = 1<<6,
    Rflag   = 1<<7,
};
@

<<enum [[_anon_ (kernel/network/ip/icmp6.c)4]]>>=
enum {
    /* ICMPv6 types */
    EchoReply   = 0,
    UnreachableV6   = 1,
    PacketTooBigV6  = 2,
    TimeExceedV6    = 3,
    SrcQuench   = 4,
    ParamProblemV6  = 4,
    Redirect    = 5,
    EchoRequest = 8,
    TimeExceed  = 11,
    InParmProblem   = 12,
    Timestamp   = 13,
    TimestampReply  = 14,
    InfoRequest = 15,
    InfoReply   = 16,
    AddrMaskRequest = 17,
    AddrMaskReply   = 18,
    EchoRequestV6   = 128,
    EchoReplyV6 = 129,
    RouterSolicit   = 133,
    RouterAdvert    = 134,
    NbrSolicit  = 135,
    NbrAdvert   = 136,
    RedirectV6  = 137,

    Maxtype6    = 137,
};
@

<<struct [[IPICMP]]>>=
struct IPICMP {
    ICMPHDR;
    uchar   payload[];
};
@

<<constant [[IPICMPSZ]]>>=
#define IPICMPSZ offsetof(IPICMP, payload[0])
@

<<struct [[NdiscC]]>>=
// used though NDISCSZ macro below
struct NdiscC {
    ICMPHDR;
    uchar   target[IPaddrlen];
    uchar   payload[];
};
@

<<constant [[NDISCSZ]]>>=
#define NDISCSZ offsetof(NdiscC, payload[0])
@

<<struct [[Ndpkt]]>>=
struct Ndpkt {
    ICMPHDR;
    uchar   target[IPaddrlen];
    uchar   otype;
    uchar   olen;       /* length in units of 8 octets(incl type, code),
                 * 1 for IEEE 802 addresses */
    uchar   lnaddr[6];  /* link-layer address */
    uchar   payload[];
};
@

<<constant [[NDPKTSZ]]>>=
#define NDPKTSZ offsetof(Ndpkt, payload[0])
@

<<struct [[Icmppriv6]]>>=
typedef struct Icmppriv6
{
    ulong   stats[Nstats6];

    /* message counts */
    ulong   in[Maxtype6+1];
    ulong   out[Maxtype6+1];
} Icmppriv6;
@

<<struct [[Icmpcb6]]>>=
typedef struct Icmpcb6
{
    QLock;
    uchar   headers;
} Icmpcb6;
@

<<global [[icmpnames6]]>>=
char *icmpnames6[Maxtype6+1] =
{
[EchoReply]     "EchoReply",
[UnreachableV6]     "UnreachableV6",
[PacketTooBigV6]    "PacketTooBigV6",
[TimeExceedV6]      "TimeExceedV6",
[SrcQuench]     "SrcQuench",
[Redirect]      "Redirect",
[EchoRequest]       "EchoRequest",
[TimeExceed]        "TimeExceed",
[InParmProblem]     "InParmProblem",
[Timestamp]     "Timestamp",
[TimestampReply]    "TimestampReply",
[InfoRequest]       "InfoRequest",
[InfoReply]     "InfoReply",
[AddrMaskRequest]   "AddrMaskRequest",
[AddrMaskReply]     "AddrMaskReply",
[EchoRequestV6]     "EchoRequestV6",
[EchoReplyV6]       "EchoReplyV6",
[RouterSolicit]     "RouterSolicit",
[RouterAdvert]      "RouterAdvert",
[NbrSolicit]        "NbrSolicit",
[NbrAdvert]     "NbrAdvert",
[RedirectV6]        "RedirectV6",
};
@

<<global [[statnames6]]>>=
static char *statnames6[Nstats6] =
{
[InMsgs6]   "InMsgs",
[InErrors6] "InErrors",
[OutMsgs6]  "OutMsgs",
[CsumErrs6] "CsumErrs",
[LenErrs6]  "LenErrs",
[HlenErrs6] "HlenErrs",
[HoplimErrs6]   "HoplimErrs",
[IcmpCodeErrs6] "IcmpCodeErrs",
[TargetErrs6]   "TargetErrs",
[OptlenErrs6]   "OptlenErrs",
[AddrmxpErrs6]  "AddrmxpErrs",
[RouterAddrErrs6]   "RouterAddrErrs",
};
@

<<global [[unreachcode]]([[(kernel/network/ip/icmp6.c)]])>>=
static char *unreachcode[] =
{
[Icmp6_no_route]    "no route to destination",
[Icmp6_ad_prohib]   "comm with destination administratively prohibited",
[Icmp6_out_src_scope]   "beyond scope of source address",
[Icmp6_adr_unreach] "address unreachable",
[Icmp6_port_unreach]    "port unreachable",
[Icmp6_gress_src_fail]  "source address failed ingress/egress policy",
[Icmp6_rej_route]   "reject route to destination",
[Icmp6_unknown]     "icmp unreachable: unknown code",
};
@

<<function [[icmpcreate6]]>>=
static void
icmpcreate6(Conv *c)
{
    c->rq = qopen(64*1024, Qmsg, 0, c);
    c->wq = qbypass(icmpkick6, c);
}
@

<<function [[set_cksum]]>>=
static void
set_cksum(Block *bp)
{
    IPICMP *p = (IPICMP *)(bp->rp);

    hnputl(p->vcf, 0);      /* borrow IP header as pseudoheader */
    hnputs(p->ploadlen, blocklen(bp) - IP6HDR);
    p->proto = 0;
    p->ttl = ICMPv6;    /* ttl gets set later */
    hnputs(p->cksum, 0);
    hnputs(p->cksum, ptclcsum(bp, 0, blocklen(bp)));
    p->proto = ICMPv6;
}
@

<<function [[newIPICMP]]>>=
static Block *
newIPICMP(int packetlen)
{
    Block *nbp;

    nbp = allocb(packetlen);
    nbp->wp += packetlen;
    memset(nbp->rp, 0, packetlen);
    return nbp;
}
@

<<function [[icmpadvise6]]>>=
void
icmpadvise6(Proto *icmp, Block *bp, char *msg)
{
    ushort recid;
    Conv **c, *s;
    IPICMP *p;

    p = (IPICMP *)bp->rp;
    recid = nhgets(p->icmpid);

    for(c = icmp->conv; *c; c++) {
        s = *c;
        if(s->lport == recid && ipcmp(s->raddr, p->dst) == 0){
            qhangup(s->rq, msg);
            qhangup(s->wq, msg);
            break;
        }
    }
    freeblist(bp);
}
@

<<function [[icmpkick6]]>>=
static void
icmpkick6(void *x, Block *bp)
{
    uchar laddr[IPaddrlen], raddr[IPaddrlen];
    Conv *c = x;
    IPICMP *p;
    Icmppriv6 *ipriv = c->p->priv;
    Icmpcb6 *icb = (Icmpcb6*)c->ptcl;

    if(bp == nil)
        return;

    if(icb->headers==6) {
        /* get user specified addresses */
        bp = pullupblock(bp, ICMP_USEAD6);
        if(bp == nil)
            return;
        bp->rp += 8;
        ipmove(laddr, bp->rp);
        bp->rp += IPaddrlen;
        ipmove(raddr, bp->rp);
        bp->rp += IPaddrlen;
        bp = padblock(bp, IP6HDR);
    }

    if(blocklen(bp) < IPICMPSZ){
        freeblist(bp);
        return;
    }
    p = (IPICMP *)(bp->rp);
    if(icb->headers == 6) {
        ipmove(p->dst, raddr);
        ipmove(p->src, laddr);
    } else {
        ipmove(p->dst, c->raddr);
        ipmove(p->src, c->laddr);
        hnputs(p->icmpid, c->lport);
    }

    set_cksum(bp);
    p->vcf[0] = 0x06 << 4;
    if(p->type <= Maxtype6)
        ipriv->out[p->type]++;
    ipoput6(c->p->f, bp, 0, c->ttl, c->tos, nil);
}
@

<<function [[icmpctl6]]>>=
char*
icmpctl6(Conv *c, char **argv, int argc)
{
    Icmpcb6 *icb;

    icb = (Icmpcb6*) c->ptcl;
    if(argc==1 && strcmp(argv[0], "headers")==0) {
        icb->headers = 6;
        return nil;
    }
    return "unknown control request";
}
@

<<function [[goticmpkt6]]>>=
static void
goticmpkt6(Proto *icmp, Block *bp, int muxkey)
{
    ushort recid;
    uchar *addr;
    Conv **c, *s;
    IPICMP *p = (IPICMP *)bp->rp;

    if(muxkey == 0) {
        recid = nhgets(p->icmpid);
        addr = p->src;
    } else {
        recid = muxkey;
        addr = p->dst;
    }

    for(c = icmp->conv; *c; c++){
        s = *c;
        if(s->lport == recid && ipcmp(s->raddr, addr) == 0){
            bp = concatblock(bp);
            if(bp != nil)
                qpass(s->rq, bp);
            return;
        }
    }

    freeblist(bp);
}
@

<<function [[mkechoreply6]]>>=
static Block *
mkechoreply6(Block *bp, Ipifc *ifc)
{
    uchar addr[IPaddrlen];
    IPICMP *p = (IPICMP *)(bp->rp);

    ipmove(addr, p->src);
    if(!isv6mcast(p->dst))
        ipmove(p->src, p->dst);
    else if (!ipv6anylocal(ifc, p->src))
        return nil;
    ipmove(p->dst, addr);
    p->type = EchoReplyV6;
    set_cksum(bp);
    return bp;
}
@

<<function [[icmpns]]>>=
/*
 * sends out an ICMPv6 neighbor solicitation
 *  suni == SRC_UNSPEC or SRC_UNI,
 *  tuni == TARG_MULTI => multicast for address resolution,
 *  and tuni == TARG_UNI => neighbor reachability.
 */
extern void
icmpns(Fs *f, uchar* src, int suni, uchar* targ, int tuni, uchar* mac)
{
    Block *nbp;
    Ndpkt *np;
    Proto *icmp = f->t2p[ICMPv6];
    Icmppriv6 *ipriv = icmp->priv;

    nbp = newIPICMP(NDPKTSZ);
    np = (Ndpkt*) nbp->rp;

    if(suni == SRC_UNSPEC)
        memmove(np->src, v6Unspecified, IPaddrlen);
    else
        memmove(np->src, src, IPaddrlen);

    if(tuni == TARG_UNI)
        memmove(np->dst, targ, IPaddrlen);
    else
        ipv62smcast(np->dst, targ);

    np->type = NbrSolicit;
    np->code = 0;
    memmove(np->target, targ, IPaddrlen);
    if(suni != SRC_UNSPEC) {
        np->otype = SRC_LLADDR;
        np->olen = 1;       /* 1+1+6 = 8 = 1 8-octet */
        memmove(np->lnaddr, mac, sizeof(np->lnaddr));
    } else
        nbp->wp -= NDPKTSZ - NDISCSZ;

    set_cksum(nbp);
    np = (Ndpkt*)nbp->rp;
    np->ttl = HOP_LIMIT;
    np->vcf[0] = 0x06 << 4;
    ipriv->out[NbrSolicit]++;
    netlog(f, Logicmp, "sending neighbor solicitation %I\n", targ);
    ipoput6(f, nbp, 0, MAXTTL, DFLTTOS, nil);
}
@

<<function [[icmpna]]>>=
/*
 * sends out an ICMPv6 neighbor advertisement. pktflags == RSO flags.
 */
extern void
icmpna(Fs *f, uchar* src, uchar* dst, uchar* targ, uchar* mac, uchar flags)
{
    Block *nbp;
    Ndpkt *np;
    Proto *icmp = f->t2p[ICMPv6];
    Icmppriv6 *ipriv = icmp->priv;

    nbp = newIPICMP(NDPKTSZ);
    np = (Ndpkt*)nbp->rp;

    memmove(np->src, src, IPaddrlen);
    memmove(np->dst, dst, IPaddrlen);

    np->type = NbrAdvert;
    np->code = 0;
    np->icmpid[0] = flags;
    memmove(np->target, targ, IPaddrlen);

    np->otype = TARGET_LLADDR;
    np->olen = 1;
    memmove(np->lnaddr, mac, sizeof(np->lnaddr));

    set_cksum(nbp);
    np = (Ndpkt*) nbp->rp;
    np->ttl = HOP_LIMIT;
    np->vcf[0] = 0x06 << 4;
    ipriv->out[NbrAdvert]++;
    netlog(f, Logicmp, "sending neighbor advertisement %I\n", src);
    ipoput6(f, nbp, 0, MAXTTL, DFLTTOS, nil);
}
@

<<function [[icmphostunr]]>>=
extern void
icmphostunr(Fs *f, Ipifc *ifc, Block *bp, int code, int free)
{
    int osz = BLEN(bp);
    int sz = MIN(IPICMPSZ + osz, v6MINTU);
    Block *nbp;
    IPICMP *np;
    Ip6hdr *p;
    Proto *icmp = f->t2p[ICMPv6];
    Icmppriv6 *ipriv = icmp->priv;

    p = (Ip6hdr *)bp->rp;

    if(isv6mcast(p->src))
        goto clean;

    nbp = newIPICMP(sz);
    np = (IPICMP *)nbp->rp;

    rlock(ifc);
    if(ipv6anylocal(ifc, np->src))
        netlog(f, Logicmp, "send icmphostunr -> src %I dst %I\n",
            p->src, p->dst);
    else {
        netlog(f, Logicmp, "icmphostunr fail -> src %I dst %I\n",
            p->src, p->dst);
        freeblist(nbp);
        if(free)
            goto clean;
        else
            return;
    }

    memmove(np->dst, p->src, IPaddrlen);
    np->type = UnreachableV6;
    np->code = code;
    memmove(nbp->rp + IPICMPSZ, bp->rp, sz - IPICMPSZ);
    set_cksum(nbp);
    np->ttl = HOP_LIMIT;
    np->vcf[0] = 0x06 << 4;
    ipriv->out[UnreachableV6]++;

    if(free)
        ipiput6(f, ifc, nbp);
    else {
        ipoput6(f, nbp, 0, MAXTTL, DFLTTOS, nil);
        return;
    }

clean:
    runlock(ifc);
    freeblist(bp);
}
@

<<function [[icmpttlexceeded6]]>>=
extern void
icmpttlexceeded6(Fs *f, Ipifc *ifc, Block *bp)
{
    int osz = BLEN(bp);
    int sz = MIN(IPICMPSZ + osz, v6MINTU);
    Block *nbp;
    IPICMP *np;
    Ip6hdr *p;
    Proto *icmp = f->t2p[ICMPv6];
    Icmppriv6 *ipriv = icmp->priv;

    p = (Ip6hdr *)bp->rp;

    if(isv6mcast(p->src))
        return;

    nbp = newIPICMP(sz);
    np = (IPICMP *) nbp->rp;

    if(ipv6anylocal(ifc, np->src))
        netlog(f, Logicmp, "send icmpttlexceeded6 -> src %I dst %I\n",
            p->src, p->dst);
    else {
        netlog(f, Logicmp, "icmpttlexceeded6 fail -> src %I dst %I\n",
            p->src, p->dst);
        return;
    }

    memmove(np->dst, p->src, IPaddrlen);
    np->type = TimeExceedV6;
    np->code = 0;
    memmove(nbp->rp + IPICMPSZ, bp->rp, sz - IPICMPSZ);
    set_cksum(nbp);
    np->ttl = HOP_LIMIT;
    np->vcf[0] = 0x06 << 4;
    ipriv->out[TimeExceedV6]++;
    ipoput6(f, nbp, 0, MAXTTL, DFLTTOS, nil);
}
@

<<function [[icmppkttoobig6]]>>=
extern void
icmppkttoobig6(Fs *f, Ipifc *ifc, Block *bp)
{
    int osz = BLEN(bp);
    int sz = MIN(IPICMPSZ + osz, v6MINTU);
    Block *nbp;
    IPICMP *np;
    Ip6hdr *p;
    Proto *icmp = f->t2p[ICMPv6];
    Icmppriv6 *ipriv = icmp->priv;

    p = (Ip6hdr *)bp->rp;

    if(isv6mcast(p->src))
        return;

    nbp = newIPICMP(sz);
    np = (IPICMP *)nbp->rp;

    if(ipv6anylocal(ifc, np->src))
        netlog(f, Logicmp, "send icmppkttoobig6 -> src %I dst %I\n",
            p->src, p->dst);
    else {
        netlog(f, Logicmp, "icmppkttoobig6 fail -> src %I dst %I\n",
            p->src, p->dst);
        return;
    }

    memmove(np->dst, p->src, IPaddrlen);
    np->type = PacketTooBigV6;
    np->code = 0;
    hnputl(np->icmpid, ifc->maxtu - ifc->m->hsize);
    memmove(nbp->rp + IPICMPSZ, bp->rp, sz - IPICMPSZ);
    set_cksum(nbp);
    np->ttl = HOP_LIMIT;
    np->vcf[0] = 0x06 << 4;
    ipriv->out[PacketTooBigV6]++;
    ipoput6(f, nbp, 0, MAXTTL, DFLTTOS, nil);
}
@

<<function [[valid]]>>=
/*
 * RFC 2461, pages 39-40, pages 57-58.
 */
static int
valid(Proto *icmp, Ipifc *ifc, Block *bp, Icmppriv6 *ipriv)
{
    int sz, osz, unsp, n, ttl, iplen;
    int pktsz = BLEN(bp);
    uchar *packet = bp->rp;
    IPICMP *p = (IPICMP *) packet;
    Ndpkt *np;

    USED(ifc);
    n = blocklen(bp);
    if(n < IPICMPSZ) {
        ipriv->stats[HlenErrs6]++;
        netlog(icmp->f, Logicmp, "icmp hlen %d\n", n);
        goto err;
    }

    iplen = nhgets(p->ploadlen);
    if(iplen > n - IP6HDR) {
        ipriv->stats[LenErrs6]++;
        netlog(icmp->f, Logicmp, "icmp length %d\n", iplen);
        goto err;
    }

    /* Rather than construct explicit pseudoheader, overwrite IPv6 header */
    if(p->proto != ICMPv6) {
        /* This code assumes no extension headers!!! */
        netlog(icmp->f, Logicmp, "icmp error: extension header\n");
        goto err;
    }
    memset(packet, 0, 4);
    ttl = p->ttl;
    p->ttl = p->proto;
    p->proto = 0;
    if(ptclcsum(bp, 0, iplen + IP6HDR)) {
        ipriv->stats[CsumErrs6]++;
        netlog(icmp->f, Logicmp, "icmp checksum error\n");
        goto err;
    }
    p->proto = p->ttl;
    p->ttl = ttl;

    /* additional tests for some pkt types */
    if (p->type == NbrSolicit   || p->type == NbrAdvert ||
        p->type == RouterAdvert || p->type == RouterSolicit ||
        p->type == RedirectV6) {
        if(p->ttl != HOP_LIMIT) {
            ipriv->stats[HoplimErrs6]++;
            goto err;
        }
        if(p->code != 0) {
            ipriv->stats[IcmpCodeErrs6]++;
            goto err;
        }

        switch (p->type) {
        case NbrSolicit:
        case NbrAdvert:
            np = (Ndpkt*) p;
            if(isv6mcast(np->target)) {
                ipriv->stats[TargetErrs6]++;
                goto err;
            }
            if(optexsts(np) && np->olen == 0) {
                ipriv->stats[OptlenErrs6]++;
                goto err;
            }

            if (p->type == NbrSolicit &&
                ipcmp(np->src, v6Unspecified) == 0)
                if(!issmcast(np->dst) || optexsts(np)) {
                    ipriv->stats[AddrmxpErrs6]++;
                    goto err;
                }

            if(p->type == NbrAdvert)
                if(isv6mcast(np->dst) &&
                    (nhgets(np->icmpid) & Sflag)){
                    ipriv->stats[AddrmxpErrs6]++;
                    goto err;
                }
            break;

        case RouterAdvert:
            if(pktsz - IP6HDR < 16) {
                ipriv->stats[HlenErrs6]++;
                goto err;
            }
            if(!islinklocal(p->src)) {
                ipriv->stats[RouterAddrErrs6]++;
                goto err;
            }
            sz = IPICMPSZ + 8;
            while (sz+1 < pktsz) {
                osz = packet[sz+1];
                if(osz <= 0) {
                    ipriv->stats[OptlenErrs6]++;
                    goto err;
                }
                sz += 8*osz;
            }
            break;

        case RouterSolicit:
            if(pktsz - IP6HDR < 8) {
                ipriv->stats[HlenErrs6]++;
                goto err;
            }
            unsp = (ipcmp(p->src, v6Unspecified) == 0);
            sz = IPICMPSZ + 8;
            while (sz+1 < pktsz) {
                osz = packet[sz+1];
                if(osz <= 0 ||
                    (unsp && packet[sz] == SRC_LLADDR)) {
                    ipriv->stats[OptlenErrs6]++;
                    goto err;
                }
                sz += 8*osz;
            }
            break;

        case RedirectV6:
            /* to be filled in */
            break;

        default:
            goto err;
        }
    }
    return 1;
err:
    ipriv->stats[InErrors6]++;
    return 0;
}
@

<<function [[targettype]]>>=
static int
targettype(Fs *f, Ipifc *ifc, uchar *target)
{
    Iplifc *lifc;
    int t;

    rlock(ifc);
    if(ipproxyifc(f, ifc, target)) {
        runlock(ifc);
        return Tuniproxy;
    }

    for(lifc = ifc->lifc; lifc; lifc = lifc->next)
        if(ipcmp(lifc->local, target) == 0) {
            t = (lifc->tentative)? Tunitent: Tunirany;
            runlock(ifc);
            return t;
        }

    runlock(ifc);
    return 0;
}
@

<<function [[icmpiput6]]>>=
static void
icmpiput6(Proto *icmp, Ipifc *ipifc, Block *bp)
{
    int refresh = 1;
    char *msg, m2[128];
    uchar pktflags;
    uchar *packet = bp->rp;
    uchar lsrc[IPaddrlen];
    Block *r;
    IPICMP *p = (IPICMP *)packet;
    Icmppriv6 *ipriv = icmp->priv;
    Iplifc *lifc;
    Ndpkt* np;
    Proto *pr;

    if(!valid(icmp, ipifc, bp, ipriv) || p->type > Maxtype6)
        goto raise;

    ipriv->in[p->type]++;

    switch(p->type) {
    case EchoRequestV6:
        r = mkechoreply6(bp, ipifc);
        if(r == nil)
            goto raise;
        ipriv->out[EchoReply]++;
        ipoput6(icmp->f, r, 0, MAXTTL, DFLTTOS, nil);
        break;

    case UnreachableV6:
        if(p->code >= nelem(unreachcode))
            msg = unreachcode[Icmp6_unknown];
        else
            msg = unreachcode[p->code];

        bp->rp += IPICMPSZ;
        if(blocklen(bp) < 8){
            ipriv->stats[LenErrs6]++;
            goto raise;
        }
        p = (IPICMP *)bp->rp;
        pr = Fsrcvpcolx(icmp->f, p->proto);
        if(pr != nil && pr->advise != nil) {
            (*pr->advise)(pr, bp, msg);
            return;
        }

        bp->rp -= IPICMPSZ;
        goticmpkt6(icmp, bp, 0);
        break;

    case TimeExceedV6:
        if(p->code == 0){
            snprint(m2, sizeof m2, "ttl exceeded at %I", p->src);

            bp->rp += IPICMPSZ;
            if(blocklen(bp) < 8){
                ipriv->stats[LenErrs6]++;
                goto raise;
            }
            p = (IPICMP *)bp->rp;
            pr = Fsrcvpcolx(icmp->f, p->proto);
            if(pr && pr->advise) {
                (*pr->advise)(pr, bp, m2);
                return;
            }
            bp->rp -= IPICMPSZ;
        }

        goticmpkt6(icmp, bp, 0);
        break;

    case RouterAdvert:
    case RouterSolicit:
        /* using lsrc as a temp, munge hdr for goticmp6 */
        if (0) {
            memmove(lsrc, p->src, IPaddrlen);
            memmove(p->src, p->dst, IPaddrlen);
            memmove(p->dst, lsrc, IPaddrlen);
        }
        goticmpkt6(icmp, bp, p->type);
        break;

    case NbrSolicit:
        np = (Ndpkt*) p;
        pktflags = 0;
        switch (targettype(icmp->f, ipifc, np->target)) {
        case Tunirany:
            pktflags |= Oflag;
            /* fall through */

        case Tuniproxy:
            if(ipcmp(np->src, v6Unspecified) != 0) {
                arpenter(icmp->f, V6, np->src, np->lnaddr,
                    8*np->olen-2, 0);
                pktflags |= Sflag;
            }
            if(ipv6local(ipifc, lsrc))
                icmpna(icmp->f, lsrc,
                    (ipcmp(np->src, v6Unspecified) == 0?
                        v6allnodesL: np->src),
                    np->target, ipifc->mac, pktflags);
            else
                freeblist(bp);
            break;

        case Tunitent:
            /* not clear what needs to be done. send up
             * an icmp mesg saying don't use this address? */
        default:
            freeblist(bp);
        }
        break;

    case NbrAdvert:
        np = (Ndpkt*) p;

        /*
         * if the target address matches one of the local interface
         * addresses and the local interface address has tentative bit
         * set, insert into ARP table. this is so the duplicate address
         * detection part of ipconfig can discover duplication through
         * the arp table.
         */
        lifc = iplocalonifc(ipifc, np->target);
        if(lifc && lifc->tentative)
            refresh = 0;
        arpenter(icmp->f, V6, np->target, np->lnaddr, 8*np->olen-2,
            refresh);
        freeblist(bp);
        break;

    case PacketTooBigV6:
    default:
        goticmpkt6(icmp, bp, 0);
        break;
    }
    return;
raise:
    freeblist(bp);
}
@

<<function [[icmpstats6]]>>=
int
icmpstats6(Proto *icmp6, char *buf, int len)
{
    Icmppriv6 *priv;
    char *p, *e;
    int i;

    priv = icmp6->priv;
    p = buf;
    e = p+len;
    for(i = 0; i < Nstats6; i++)
        p = seprint(p, e, "%s: %lud\n", statnames6[i], priv->stats[i]);
    for(i = 0; i <= Maxtype6; i++)
        if(icmpnames6[i])
            p = seprint(p, e, "%s: %lud %lud\n", icmpnames6[i],
                priv->in[i], priv->out[i]);
/*      else
            p = seprint(p, e, "%d: %lud %lud\n", i, priv->in[i],
                priv->out[i]);
 */
    return p - buf;
}
@

<<function [[icmp6init]]>>=
void
icmp6init(Fs *fs)
{
    Proto *icmp6 = smalloc(sizeof(Proto));

    icmp6->priv = smalloc(sizeof(Icmppriv6));
    icmp6->name = "icmpv6";
    icmp6->connect = icmpconnect;
    icmp6->announce = icmpannounce;
    icmp6->state = icmpstate;
    icmp6->create = icmpcreate6;
    icmp6->close = icmpclose;
    icmp6->rcv = icmpiput6;
    icmp6->stats = icmpstats6;
    icmp6->ctl = icmpctl6;
    icmp6->advise = icmpadvise6;
    icmp6->gc = nil;
    icmp6->ipproto = ICMPv6;
    icmp6->nc = 16;
    icmp6->ptclsize = sizeof(Icmpcb6);

    Fsproto(fs, icmp6);
}
@


%-------------------------------------------------------------

<<kernel/network/ip/icmp6.c>>=
/*
 * Internet Control Message Protocol for IPv6
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "../port/error.h"
#include "ip.h"
#include "ipv6.h"

<<enum [[_anon_ (kernel/network/ip/icmp6.c)]]>>

<<enum [[_anon_ (kernel/network/ip/icmp6.c)2]]>>

<<enum [[_anon_ (kernel/network/ip/icmp6.c)3]]>>

<<enum [[_anon_ (kernel/network/ip/icmp6.c)4]]>>

/* on-the-wire packet formats */
typedef struct IPICMP IPICMP;
typedef struct Ndpkt Ndpkt;
typedef struct NdiscC NdiscC;

/* we do this to avoid possible struct padding  */
#define ICMPHDR \
    IPV6HDR; \
    uchar   type; \
    uchar   code; \
    uchar   cksum[2]; \
    uchar   icmpid[2]; \
    uchar   seq[2]

<<struct [[IPICMP]]>>

<<constant [[IPICMPSZ]]>>

<<struct [[NdiscC]]>>

<<constant [[NDISCSZ]]>>

<<struct [[Ndpkt]]>>

<<constant [[NDPKTSZ]]>>

<<struct [[Icmppriv6]]>>

<<struct [[Icmpcb6]]>>

<<global [[icmpnames6]]>>

<<global [[statnames6]]>>

<<global [[unreachcode]]([[(kernel/network/ip/icmp6.c)]])>>

static void icmpkick6(void *x, Block *bp);

<<function [[icmpcreate6]]>>

<<function [[set_cksum]]>>

<<function [[newIPICMP]]>>

<<function [[icmpadvise6]]>>

<<function [[icmpkick6]]>>

<<function [[icmpctl6]]>>

<<function [[goticmpkt6]]>>

<<function [[mkechoreply6]]>>

<<function [[icmpns]]>>

<<function [[icmpna]]>>

<<function [[icmphostunr]]>>

<<function [[icmpttlexceeded6]]>>

<<function [[icmppkttoobig6]]>>

<<function [[valid]]>>

<<function [[targettype]]>>

<<function [[icmpiput6]]>>

<<function [[icmpstats6]]>>


/* import from icmp.c */
extern int  icmpstate(Conv *c, char *state, int n);
extern char*    icmpannounce(Conv *c, char **argv, int argc);
extern char*    icmpconnect(Conv *c, char **argv, int argc);
extern void icmpclose(Conv *c);

<<function [[icmp6init]]>>
@


\subsection*{[[kernel/network/ip/ipv6.c]]}

<<enum [[_anon_ (kernel/network/ip/ipv6.c)]]>>=
enum
{
    IP6FHDR     = 8,        /* sizeof(Fraghdr6) */
};
@

<<macro [[IPV6CLASS]]>>=
#define IPV6CLASS(hdr)  (((hdr)->vcf[0]&0x0F)<<2 | ((hdr)->vcf[1]&0xF0)>>2)
@

<<macro [[BLKIPVER]]([[(kernel/network/ip/ipv6.c)]])>>=
#define BLKIPVER(xp)    (((Ip6hdr*)((xp)->rp))->vcf[0] & 0xF0)
@

<<macro [[BKFG]]([[(kernel/network/ip/ipv6.c)]])>>=
/*
 * This sleazy macro is stolen shamelessly from ip.c, see comment there.
 */
#define BKFG(xp)    ((Ipfrag*)((xp)->base))
@

<<function [[ipoput6]]>>=
int
ipoput6(Fs *f, Block *bp, int gating, int ttl, int tos, Conv *c)
{
    int medialen, len, chunk, uflen, flen, seglen, lid, offset, fragoff;
    int morefrags, blklen, rv = 0, tentative;
    uchar *gate, nexthdr;
    Block *xp, *nb;
    Fraghdr6 fraghdr;
    IP *ip;
    Ip6hdr *eh;
    Ipifc *ifc;
    Route *r, *sr;

    ip = f->ip;

    /* Fill out the ip header */
    eh = (Ip6hdr*)(bp->rp);

    ip->stats[OutRequests]++;

    /* Number of uchars in data and ip header to write */
    len = blocklen(bp);

    tentative = iptentative(f, eh->src);
    if(tentative){
        netlog(f, Logip, "reject tx of packet with tentative src address %I\n",
            eh->src);
        goto free;
    }

    if(gating){
        chunk = nhgets(eh->ploadlen);
        if(chunk > len){
            ip->stats[OutDiscards]++;
            netlog(f, Logip, "short gated packet\n");
            goto free;
        }
        if(chunk + IP6HDR < len)
            len = chunk + IP6HDR;
    }

    if(len >= IP_MAX){
        ip->stats[OutDiscards]++;
        netlog(f, Logip, "exceeded ip max size %I\n", eh->dst);
        goto free;
    }

    r = v6lookup(f, eh->dst, c);
    if(r == nil){
//      print("no route for %I, src %I free\n", eh->dst, eh->src);
        ip->stats[OutNoRoutes]++;
        netlog(f, Logip, "no interface %I\n", eh->dst);
        rv = -1;
        goto free;
    }

    ifc = r->ifc;
    if(r->type & (Rifc|Runi))
        gate = eh->dst;
    else if(r->type & (Rbcast|Rmulti)) {
        gate = eh->dst;
        sr = v6lookup(f, eh->src, nil);
        if(sr && (sr->type & Runi))
            ifc = sr->ifc;
    }
    else
        gate = r->v6.gate;

    if(!gating)
        eh->vcf[0] = IP_VER6;
    eh->ttl = ttl;
    if(!gating) {
        eh->vcf[0] |= tos >> 4;
        eh->vcf[1]  = tos << 4;
    }

    if(!canrlock(ifc))
        goto free;

    if(waserror()){
        runlock(ifc);
        nexterror();
    }

    if(ifc->m == nil)
        goto raise;

    /* If we dont need to fragment just send it */
    medialen = ifc->maxtu - ifc->m->hsize;
    if(len <= medialen) {
        hnputs(eh->ploadlen, len - IP6HDR);
        ifc->m->bwrite(ifc, bp, V6, gate);
        runlock(ifc);
        poperror();
        return 0;
    }

    if(gating && ifc->reassemble <= 0) {
        /*
         * v6 intermediate nodes are not supposed to fragment pkts;
         * we fragment if ifc->reassemble is turned on; an exception
         * needed for nat.
         */
        ip->stats[OutDiscards]++;
        icmppkttoobig6(f, ifc, bp);
        netlog(f, Logip, "%I: gated pkts not fragmented\n", eh->dst);
        goto raise;
    }

    /* start v6 fragmentation */
    uflen = unfraglen(bp, &nexthdr, 1);
    if(uflen > medialen) {
        ip->stats[FragFails]++;
        ip->stats[OutDiscards]++;
        netlog(f, Logip, "%I: unfragmentable part too big\n", eh->dst);
        goto raise;
    }

    flen = len - uflen;
    seglen = (medialen - (uflen + IP6FHDR)) & ~7;
    if(seglen < 8) {
        ip->stats[FragFails]++;
        ip->stats[OutDiscards]++;
        netlog(f, Logip, "%I: seglen < 8\n", eh->dst);
        goto raise;
    }

    lid = incref(&ip->id6);
    fraghdr.nexthdr = nexthdr;
    fraghdr.res = 0;
    hnputl(fraghdr.id, lid);

    xp = bp;
    offset = uflen;
    while (xp && offset && offset >= BLEN(xp)) {
        offset -= BLEN(xp);
        xp = xp->next;
    }
    xp->rp += offset;

    fragoff = 0;
    morefrags = 1;

    for(; fragoff < flen; fragoff += seglen) {
        nb = allocb(uflen + IP6FHDR + seglen);

        if(fragoff + seglen >= flen) {
            seglen = flen - fragoff;
            morefrags = 0;
        }

        hnputs(eh->ploadlen, seglen+IP6FHDR);
        memmove(nb->wp, eh, uflen);
        nb->wp += uflen;

        hnputs(fraghdr.offsetRM, fragoff); /* last 3 bits must be 0 */
        fraghdr.offsetRM[1] |= morefrags;
        memmove(nb->wp, &fraghdr, IP6FHDR);
        nb->wp += IP6FHDR;

        /* Copy data */
        chunk = seglen;
        while (chunk) {
            if(!xp) {
                ip->stats[OutDiscards]++;
                ip->stats[FragFails]++;
                freeblist(nb);
                netlog(f, Logip, "!xp: chunk in v6%d\n", chunk);
                goto raise;
            }
            blklen = chunk;
            if(BLEN(xp) < chunk)
                blklen = BLEN(xp);
            memmove(nb->wp, xp->rp, blklen);

            nb->wp += blklen;
            xp->rp += blklen;
            chunk -= blklen;
            if(xp->rp == xp->wp)
                xp = xp->next;
        }

        ifc->m->bwrite(ifc, nb, V6, gate);
        ip->stats[FragCreates]++;
    }
    ip->stats[FragOKs]++;

raise:
    runlock(ifc);
    poperror();
free:
    freeblist(bp);
    return rv;
}
@

<<function [[ipiput6]]>>=
void
ipiput6(Fs *f, Ipifc *ifc, Block *bp)
{
    int hl, hop, tos, notforme, tentative;
    uchar proto;
    uchar v6dst[IPaddrlen];
    IP *ip;
    Ip6hdr *h;
    Proto *p;
    Route *r, *sr;

    ip = f->ip;
    ip->stats[InReceives]++;

    /*
     *  Ensure we have all the header info in the first
     *  block.  Make life easier for other protocols by
     *  collecting up to the first 64 bytes in the first block.
     */
    if(BLEN(bp) < 64) {
        hl = blocklen(bp);
        if(hl < IP6HDR)
            hl = IP6HDR;
        if(hl > 64)
            hl = 64;
        bp = pullupblock(bp, hl);
        if(bp == nil)
            return;
    }

    h = (Ip6hdr *)bp->rp;

    memmove(&v6dst[0], &h->dst[0], IPaddrlen);
    notforme = ipforme(f, v6dst) == 0;
    tentative = iptentative(f, v6dst);

    if(tentative && h->proto != ICMPv6) {
        print("ipv6 tentative addr %I, drop\n", v6dst);
        freeblist(bp);
        return;
    }

    /* Check header version */
    if(BLKIPVER(bp) != IP_VER6) {
        ip->stats[InHdrErrors]++;
        netlog(f, Logip, "ip: bad version %ux\n", (h->vcf[0]&0xF0)>>2);
        freeblist(bp);
        return;
    }

    /* route */
    if(notforme) {
        if(!ip->iprouting){
            freeblist(bp);
            return;
        }

        /* don't forward to link-local destinations */
        if(islinklocal(h->dst) ||
           (isv6mcast(h->dst) && (h->dst[1]&0xF) <= Link_local_scop)){
            ip->stats[OutDiscards]++;
            freeblist(bp);
            return;
        }

        /* don't forward to source's network */
        sr = v6lookup(f, h->src, nil);
        r  = v6lookup(f, h->dst, nil);

        if(r == nil || sr == r){
            ip->stats[OutDiscards]++;
            freeblist(bp);
            return;
        }

        /* don't forward if packet has timed out */
        hop = h->ttl;
        if(hop < 1) {
            ip->stats[InHdrErrors]++;
            icmpttlexceeded6(f, ifc, bp);
            freeblist(bp);
            return;
        }

        /* process headers & reassemble if the interface expects it */
        bp = procxtns(ip, bp, r->ifc->reassemble);
        if(bp == nil)
            return;

        ip->stats[ForwDatagrams]++;
        h = (Ip6hdr *)bp->rp;
        tos = IPV6CLASS(h);
        hop = h->ttl;
        ipoput6(f, bp, 1, hop-1, tos, nil);
        return;
    }

    /* reassemble & process headers if needed */
    bp = procxtns(ip, bp, 1);
    if(bp == nil)
        return;

    h = (Ip6hdr *) (bp->rp);
    proto = h->proto;
    p = Fsrcvpcol(f, proto);
    if(p && p->rcv) {
        ip->stats[InDelivers]++;
        (*p->rcv)(p, ifc, bp);
        return;
    }

    ip->stats[InDiscards]++;
    ip->stats[InUnknownProtos]++;
    freeblist(bp);
}
@

<<function [[ipfragfree6]]>>=
/*
 * ipfragfree6 - copied from ipfragfree4 - assume hold fraglock6
 */
void
ipfragfree6(IP *ip, Fragment6 *frag)
{
    Fragment6 *fl, **l;

    if(frag->blist)
        freeblist(frag->blist);

    memset(frag->src, 0, IPaddrlen);
    frag->id = 0;
    frag->blist = nil;

    l = &ip->flisthead6;
    for(fl = *l; fl; fl = fl->next) {
        if(fl == frag) {
            *l = frag->next;
            break;
        }
        l = &fl->next;
    }

    frag->next = ip->fragfree6;
    ip->fragfree6 = frag;
}
@

<<function [[ipfragallo6]]>>=
/*
 * ipfragallo6 - copied from ipfragalloc4
 */
Fragment6*
ipfragallo6(IP *ip)
{
    Fragment6 *f;

    while(ip->fragfree6 == nil) {
        /* free last entry on fraglist */
        for(f = ip->flisthead6; f->next; f = f->next)
            ;
        ipfragfree6(ip, f);
    }
    f = ip->fragfree6;
    ip->fragfree6 = f->next;
    f->next = ip->flisthead6;
    ip->flisthead6 = f;
    f->age = NOW + 30000;

    return f;
}
@

<<function [[procxtns]]>>=
static Block*
procxtns(IP *ip, Block *bp, int doreasm)
{
    int offset;
    uchar proto;
    Ip6hdr *h;

    h = (Ip6hdr *)bp->rp;
    offset = unfraglen(bp, &proto, 0);

    if(proto == FH && doreasm != 0) {
        bp = ip6reassemble(ip, offset, bp, h);
        if(bp == nil)
            return nil;
        offset = unfraglen(bp, &proto, 0);
    }

    if(proto == DOH || offset > IP6HDR)
        bp = procopts(bp);
    return bp;
}
@

<<function [[unfraglen]]>>=
/*
 * returns length of "Unfragmentable part", i.e., sum of lengths of ipv6 hdr,
 * hop-by-hop & routing headers if present; *nexthdr is set to nexthdr value
 * of the last header in the "Unfragmentable part"; if setfh != 0, nexthdr
 * field of the last header in the "Unfragmentable part" is set to FH.
 */
int
unfraglen(Block *bp, uchar *nexthdr, int setfh)
{
    uchar *p, *q;
    int ufl, hs;

    p = bp->rp;
    q = p+6;   /* proto, = p+sizeof(Ip6hdr.vcf)+sizeof(Ip6hdr.ploadlen) */
    *nexthdr = *q;
    ufl = IP6HDR;
    p += ufl;

    while (*nexthdr == HBH || *nexthdr == RH) {
        *nexthdr = *p;
        hs = ((int)*(p+1) + 1) * 8;
        ufl += hs;
        q = p;
        p += hs;
    }

    if(*nexthdr == FH)
        *q = *p;
    if(setfh)
        *q = FH;
    return ufl;
}
@

<<function [[procopts]]>>=
Block*
procopts(Block *bp)
{
    return bp;
}
@

<<function [[ip6reassemble]]>>=
Block*
ip6reassemble(IP* ip, int uflen, Block* bp, Ip6hdr* ih)
{
    int fend, offset, ovlap, len, fragsize, pktposn;
    uint id;
    uchar src[IPaddrlen], dst[IPaddrlen];
    Block *bl, **l, *last, *prev;
    Fraghdr6 *fraghdr;
    Fragment6 *f, *fnext;

    fraghdr = (Fraghdr6 *)(bp->rp + uflen);
    memmove(src, ih->src, IPaddrlen);
    memmove(dst, ih->dst, IPaddrlen);
    id = nhgetl(fraghdr->id);
    offset = nhgets(fraghdr->offsetRM) & ~7;

    /*
     *  block lists are too hard, pullupblock into a single block
     */
    if(bp->next){
        bp = pullupblock(bp, blocklen(bp));
        ih = (Ip6hdr *)bp->rp;
    }

    qlock(&ip->fraglock6);

    /*
     *  find a reassembly queue for this fragment
     */
    for(f = ip->flisthead6; f; f = fnext){
        fnext = f->next;
        if(ipcmp(f->src, src)==0 && ipcmp(f->dst, dst)==0 && f->id == id)
            break;
        if(f->age < NOW){
            ip->stats[ReasmTimeout]++;
            ipfragfree6(ip, f);
        }
    }

    /*
     *  if this isn't a fragmented packet, accept it
     *  and get rid of any fragments that might go
     *  with it.
     */
    if(nhgets(fraghdr->offsetRM) == 0) {    /* 1st frag is also last */
        if(f) {
            ipfragfree6(ip, f);
            ip->stats[ReasmFails]++;
        }
        qunlock(&ip->fraglock6);
        return bp;
    }

    if(bp->base+IPFRAGSZ >= bp->rp){
        bp = padblock(bp, IPFRAGSZ);
        bp->rp += IPFRAGSZ;
    }

    BKFG(bp)->foff = offset;
    BKFG(bp)->flen = nhgets(ih->ploadlen) + IP6HDR - uflen - IP6FHDR;

    /* First fragment allocates a reassembly queue */
    if(f == nil) {
        f = ipfragallo6(ip);
        f->id = id;
        memmove(f->src, src, IPaddrlen);
        memmove(f->dst, dst, IPaddrlen);

        f->blist = bp;

        qunlock(&ip->fraglock6);
        ip->stats[ReasmReqds]++;
        return nil;
    }

    /*
     *  find the new fragment's position in the queue
     */
    prev = nil;
    l = &f->blist;
    bl = f->blist;
    while(bl != nil && BKFG(bp)->foff > BKFG(bl)->foff) {
        prev = bl;
        l = &bl->next;
        bl = bl->next;
    }

    /* Check overlap of a previous fragment - trim away as necessary */
    if(prev) {
        ovlap = BKFG(prev)->foff + BKFG(prev)->flen - BKFG(bp)->foff;
        if(ovlap > 0) {
            if(ovlap >= BKFG(bp)->flen) {
                freeblist(bp);
                qunlock(&ip->fraglock6);
                return nil;
            }
            BKFG(prev)->flen -= ovlap;
        }
    }

    /* Link onto assembly queue */
    bp->next = *l;
    *l = bp;

    /* Check to see if succeeding segments overlap */
    if(bp->next) {
        l = &bp->next;
        fend = BKFG(bp)->foff + BKFG(bp)->flen;

        /* Take completely covered segments out */
        while(*l) {
            ovlap = fend - BKFG(*l)->foff;
            if(ovlap <= 0)
                break;
            if(ovlap < BKFG(*l)->flen) {
                BKFG(*l)->flen -= ovlap;
                BKFG(*l)->foff += ovlap;
                /* move up ih hdrs */
                memmove((*l)->rp + ovlap, (*l)->rp, uflen);
                (*l)->rp += ovlap;
                break;
            }
            last = (*l)->next;
            (*l)->next = nil;
            freeblist(*l);
            *l = last;
        }
    }

    /*
     *  look for a complete packet.  if we get to a fragment
     *  with the trailing bit of fraghdr->offsetRM[1] set, we're done.
     */
    pktposn = 0;
    for(bl = f->blist; bl && BKFG(bl)->foff == pktposn; bl = bl->next) {
        fraghdr = (Fraghdr6 *)(bl->rp + uflen);
        if((fraghdr->offsetRM[1] & 1) == 0) {
            bl = f->blist;

            /* get rid of frag header in first fragment */
            memmove(bl->rp + IP6FHDR, bl->rp, uflen);
            bl->rp += IP6FHDR;
            len = nhgets(((Ip6hdr*)bl->rp)->ploadlen) - IP6FHDR;
            bl->wp = bl->rp + len + IP6HDR;
            /*
             * Pullup all the fragment headers and
             * return a complete packet
             */
            for(bl = bl->next; bl; bl = bl->next) {
                fragsize = BKFG(bl)->flen;
                len += fragsize;
                bl->rp += uflen + IP6FHDR;
                bl->wp = bl->rp + fragsize;
            }

            bl = f->blist;
            f->blist = nil;
            ipfragfree6(ip, f);
            ih = (Ip6hdr*)bl->rp;
            hnputs(ih->ploadlen, len);
            qunlock(&ip->fraglock6);
            ip->stats[ReasmOKs]++;
            return bl;
        }
        pktposn += BKFG(bl)->flen;
    }
    qunlock(&ip->fraglock6);
    return nil;
}
@


%-------------------------------------------------------------

<<kernel/network/ip/ipv6.c>>=
#include    "u.h"
#include    "../port/lib.h"
#include    "mem.h"
#include    "dat.h"
#include    "fns.h"
#include    "../port/error.h"

#include    "ip.h"
#include    "ipv6.h"

<<enum [[_anon_ (kernel/network/ip/ipv6.c)]]>>

<<macro [[IPV6CLASS]]>>
<<macro [[BLKIPVER]]([[(kernel/network/ip/ipv6.c)]])>>
<<macro [[BKFG]]([[(kernel/network/ip/ipv6.c)]])>>

Block*      ip6reassemble(IP*, int, Block*, Ip6hdr*);
Fragment6*  ipfragallo6(IP*);
void        ipfragfree6(IP*, Fragment6*);
Block*      procopts(Block *bp);
static Block*   procxtns(IP *ip, Block *bp, int doreasm);
int     unfraglen(Block *bp, uchar *nexthdr, int setfh);

<<function [[ipoput6]]>>

<<function [[ipiput6]]>>

<<function [[ipfragfree6]]>>

<<function [[ipfragallo6]]>>

<<function [[procxtns]]>>

<<function [[unfraglen]]>>

<<function [[procopts]]>>

<<function [[ip6reassemble]]>>
@


\subsection*{[[kernel/network/ip/ipv6.h]]}

<<macro [[isv6mcast]]>>=
/*
 * Internet Protocol Version 6
 *
 * rfc2460 defines the protocol, rfc2461 neighbour discovery, and
 * rfc2462 address autoconfiguration.  rfc4443 defines ICMP; was rfc2463.
 * rfc4291 defines the address architecture (including prefices), was rfc3513.
 * rfc4007 defines the scoped address architecture.
 *
 * global unicast is anything but unspecified (::), loopback (::1),
 * multicast (ff00::/8), and link-local unicast (fe80::/10).
 *
 * site-local (fec0::/10) is now deprecated, originally by rfc3879.
 *
 * Unique Local IPv6 Unicast Addresses are defined by rfc4193.
 * prefix is fc00::/7, scope is global, routing is limited to roughly a site.
 */
#define isv6mcast(addr)   ((addr)[0] == 0xff)
@

<<macro [[islinklocal]]>>=
#define islinklocal(addr) ((addr)[0] == 0xfe && ((addr)[1] & 0xc0) == 0x80)
@

<<macro [[optexsts]]>>=
#define optexsts(np)  (nhgets((np)->ploadlen) > 24)
@

<<macro [[issmcast]]>>=
#define issmcast(addr)  (memcmp((addr), v6solicitednode, 13) == 0)
@

<<enum [[_anon_ (kernel/network/ip/ipv6.h)]]>>=
enum {        /* Header Types */
  HBH   = 0,  /* hop-by-hop multicast routing protocol */
  ICMP    = 1,
  IGMP    = 2,
  GGP   = 3,
  IPINIP    = 4,
  ST    = 5,
  TCP   = 6,
  UDP   = 17,
  ISO_TP4   = 29,
  RH    = 43,
  FH    = 44,
  IDRP    = 45,
  RSVP    = 46,
  AH    = 51,
  ESP   = 52,
  ICMPv6    = 58,
  NNH   = 59,
  DOH   = 60,
  ISO_IP    = 80,
  IGRP    = 88,
  OSPF    = 89,

  Maxhdrtype  = 256,
};
@

<<enum [[_anon_ (kernel/network/ip/ipv6.h)2]]>>=
enum {
  /* multicast flags and scopes */

//  Well_known_flg  = 0,
//  Transient_flg = 1,

//  Interface_local_scop = 1,
  Link_local_scop = 2,
//  Site_local_scop = 5,
//  Org_local_scop  = 8,
  Global_scop = 14,

  /* various prefix lengths */
  SOLN_PREF_LEN = 13,

  /* icmpv6 unreachability codes */
  Icmp6_no_route    = 0,
  Icmp6_ad_prohib   = 1,
  Icmp6_out_src_scope = 2,
  Icmp6_adr_unreach = 3,
  Icmp6_port_unreach  = 4,
  Icmp6_gress_src_fail  = 5,
  Icmp6_rej_route   = 6,
  Icmp6_unknown   = 7,  /* our own invention for internal use */

  /* various flags & constants */
  v6MINTU   = 1280,
  HOP_LIMIT = 255,
  IP6HDR    = 40,   /* sizeof(Ip6hdr) = 8 + 2*16 */

  /* option types */

  /* neighbour discovery */
  SRC_LLADDR  = 1,
  TARGET_LLADDR = 2,
  PREFIX_INFO = 3,
  REDIR_HEADER  = 4,
  MTU_OPTION  = 5,
  /* new since rfc2461; see iana.org/assignments/icmpv6-parameters */
  V6nd_home = 8,
  V6nd_srcaddrs = 9,    /* rfc3122 */
  V6nd_ip   = 17,
  /* /lib/rfc/drafts/draft-jeong-dnsop-ipv6-dns-discovery-12.txt */
  V6nd_rdns = 25,
  /* plan 9 extensions */
  V6nd_9fs  = 250,
  V6nd_9auth  = 251,

  SRC_UNSPEC  = 0,
  SRC_UNI   = 1,
  TARG_UNI  = 2,
  TARG_MULTI  = 3,

  Tunitent  = 1,
  Tuniproxy = 2,
  Tunirany  = 3,

  /* Node constants */
  MAX_MULTICAST_SOLICIT = 3,
  RETRANS_TIMER   = 1000,
};
@

<<struct [[Ip6hdr]]([[(kernel/network/ip/ipv6.h)]])>>=
struct  Ip6hdr {
  IPV6HDR;
  uchar payload[];
};
@

<<struct [[Fraghdr6]]>>=
//};

struct  Fraghdr6 {
  uchar nexthdr;
  uchar res;
  uchar offsetRM[2];  /* Offset, Res, M flag */
  uchar id[4];
};
@


%-------------------------------------------------------------

<<kernel/network/ip/ipv6.h>>=
<<macro [[isv6mcast]]>>
<<macro [[islinklocal]]>>

<<macro [[optexsts]]>>
<<macro [[issmcast]]>>

<<enum [[_anon_ (kernel/network/ip/ipv6.h)]]>>

<<enum [[_anon_ (kernel/network/ip/ipv6.h)2]]>>

typedef struct Ip6hdr Ip6hdr;
typedef struct Opthdr Opthdr;
typedef struct Routinghdr Routinghdr;
typedef struct Fraghdr6 Fraghdr6;

/* we do this in case there's padding at the end of Ip6hdr */
#define IPV6HDR \
  uchar vcf[4];   /* version:4, traffic class:8, flow label:20 */\
  uchar ploadlen[2];  /* payload length: packet length - 40 */ \
  uchar proto;    /* next header type */ \
  uchar ttl;    /* hop limit */ \
  uchar src[IPaddrlen]; \
  uchar dst[IPaddrlen]

<<struct [[Ip6hdr]]([[(kernel/network/ip/ipv6.h)]])>>

//struct  Opthdr {    /* unused */
//  uchar nexthdr;
//  uchar len;
//};

/*
 * Beware routing header type 0 (loose source routing); see
 * http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf.
 * Type 1 is unused.  Type 2 is for MIPv6 (mobile IPv6) filtering
 * against type 0 header.
 */
//struct  Routinghdr {    /* unused */
//  uchar nexthdr;
//  uchar len;
//  uchar rtetype;
//  uchar segrem;
<<struct [[Fraghdr6]]>>

extern uchar v6allnodesN[IPaddrlen];
extern uchar v6allnodesL[IPaddrlen];
//extern uchar v6allroutersN[IPaddrlen];
//extern uchar v6allroutersL[IPaddrlen];
extern uchar v6allnodesNmask[IPaddrlen];
extern uchar v6allnodesLmask[IPaddrlen];
extern uchar v6solicitednode[IPaddrlen];
//extern uchar v6solicitednodemask[IPaddrlen];
extern uchar v6Unspecified[IPaddrlen];
extern uchar v6loopback[IPaddrlen];
//extern uchar v6loopbackmask[IPaddrlen];
extern uchar v6linklocal[IPaddrlen];
//extern uchar v6linklocalmask[IPaddrlen];
//extern uchar v6multicast[IPaddrlen];
//extern uchar v6multicastmask[IPaddrlen];

extern int v6llpreflen;
//extern int v6mcpreflen;
//extern int v6snpreflen;
//extern int v6aNpreflen;
//extern int v6aLpreflen;

extern int ReTransTimer;

void ipv62smcast(uchar *, uchar *);
void icmpns(Fs *f, uchar* src, int suni, uchar* targ, int tuni, uchar* mac);
//void icmpna(Fs *f, uchar* src, uchar* dst, uchar* targ, uchar* mac, uchar flags);
void icmpttlexceeded6(Fs *f, Ipifc *ifc, Block *bp);
void icmppkttoobig6(Fs *f, Ipifc *ifc, Block *bp);
void icmphostunr(Fs *f, Ipifc *ifc, Block *bp, int code, int free);
@


\section{[[networking/ip/ipconfig/]]}

\subsection*{[[networking/ip/ipconfig/ipv6.c]]}

<<constant [[RALOG]]>>=
#define RALOG "v6routeradv"
@

<<macro [[NetS]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
#define NetS(x) (((uchar*)x)[0]<< 8 | ((uchar*)x)[1])
@

<<macro [[NetL]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
#define NetL(x) (((uchar*)x)[0]<<24 | ((uchar*)x)[1]<<16 | \
         ((uchar*)x)[2]<< 8 | ((uchar*)x)[3])
@

<<enum [[_anon_ (networking/ip/ipconfig/ipv6.c)]]>>=
enum {
    ICMP6LEN=	4,
};
@

<<struct [[Hdr]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
struct Hdr			/* ICMP v4 & v6 header */
{
    uchar	type;
    uchar	code;
    uchar	cksum[2];	/* Checksum */
    uchar	data[];
};
@

<<global [[icmpmsg6]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
char *icmpmsg6[Maxtype6+1] =
{
[EchoReply]		"EchoReply",
[UnreachableV6]		"UnreachableV6",
[PacketTooBigV6]	"PacketTooBigV6",
[TimeExceedV6]		"TimeExceedV6",
[Redirect]		"Redirect",
[EchoRequest]		"EchoRequest",
[TimeExceed]		"TimeExceed",
[InParmProblem]		"InParmProblem",
[Timestamp]		"Timestamp",
[TimestampReply]	"TimestampReply",
[InfoRequest]		"InfoRequest",
[InfoReply]		"InfoReply",
[AddrMaskRequest]	"AddrMaskRequest",
[AddrMaskReply]		"AddrMaskReply",
[EchoRequestV6]		"EchoRequestV6",
[EchoReplyV6]		"EchoReplyV6",
[RouterSolicit]		"RouterSolicit",
[RouterAdvert]		"RouterAdvert",
[NbrSolicit]		"NbrSolicit",
[NbrAdvert]		"NbrAdvert",
[RedirectV6]		"RedirectV6",
};
@

<<global [[icmp6opts]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
static char *icmp6opts[] =
{
[0]			"unknown option",
[V6nd_srclladdr]	"srcll_addr",
[V6nd_targlladdr]	"targll_addr",
[V6nd_pfxinfo]		"prefix",
[V6nd_redirhdr]		"redirect",
[V6nd_mtu]		"mtu",
[V6nd_home]		"home",
[V6nd_srcaddrs]		"src_addrs",
[V6nd_ip]		"ip",
[V6nd_rdns]		"rdns",
[V6nd_9fs]		"9fs",
[V6nd_9auth]		"9auth",
};
@

<<global [[v6allroutersL]]>>=
uchar v6allroutersL[IPaddrlen] = {
    0xff, 0x02, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0x02
};
@

<<global [[v6allnodesL]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
uchar v6allnodesL[IPaddrlen] = {
    0xff, 0x02, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0x01
};
@

<<global [[v6Unspecified]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
uchar v6Unspecified[IPaddrlen] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global [[v6loopback]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
uchar v6loopback[IPaddrlen] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 1
};
@

<<global [[v6glunicast]]>>=
uchar v6glunicast[IPaddrlen] = {
    0x08, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global [[v6linklocal]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
uchar v6linklocal[IPaddrlen] = {
    0xfe, 0x80, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<global [[v6solpfx]]>>=
uchar v6solpfx[IPaddrlen] = {
    0xff, 0x02, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 1,
    /* last 3 bytes filled with low-order bytes of addr being solicited */
    0xff, 0, 0, 0,
};
@

<<global [[v6defmask]]>>=
uchar v6defmask[IPaddrlen] = {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff,
    0, 0, 0, 0,
    0, 0, 0, 0
};
@

<<enum [[_anon_ (networking/ip/ipconfig/ipv6.c)2]]>>=
enum
{
    Vadd,
    Vremove,
    Vunbind,
    Vaddpref6,
    Vra6,
};
@

<<function [[ralog]]>>=
static void
ralog(char *fmt, ...)
{
    char msg[512];
    va_list arg;

    va_start(arg, fmt);
    vseprint(msg, msg+sizeof msg, fmt, arg);
    va_end(arg);
    syslog(debug, RALOG, msg);
}
@

<<function [[ea2lla]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
extern void
ea2lla(uchar *lla, uchar *ea)
{
    assert(IPaddrlen == 16);
    memset(lla, 0, IPaddrlen);
    lla[0]  = 0xFE;
    lla[1]  = 0x80;
    lla[8]  = ea[0] | 0x2;
    lla[9]  = ea[1];
    lla[10] = ea[2];
    lla[11] = 0xFF;
    lla[12] = 0xFE;
    lla[13] = ea[3];
    lla[14] = ea[4];
    lla[15] = ea[5];
}
@

<<function [[ipv62smcast]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
extern void
ipv62smcast(uchar *smcast, uchar *a)
{
    assert(IPaddrlen == 16);
    memset(smcast, 0, IPaddrlen);
    smcast[0]  = 0xFF;
    smcast[1]  = 0x02;
    smcast[11] = 0x1;
    smcast[12] = 0xFF;
    smcast[13] = a[13];
    smcast[14] = a[14];
    smcast[15] = a[15];
}
@

<<function [[v6paraminit]]>>=
void
v6paraminit(Conf *cf)
{
    cf->sendra = cf->recvra = 0;
    cf->mflag = 0;
    cf->oflag = 0;
    cf->maxraint = Maxv6initraintvl;
    cf->minraint = Maxv6initraintvl / 4;
    cf->linkmtu = 1500;
    cf->reachtime = V6reachabletime;
    cf->rxmitra = V6retranstimer;
    cf->ttl = MAXTTL;

    cf->routerlt = 0;

    cf->prefixlen = 64;
    cf->onlink = 0;
    cf->autoflag = 0;
    cf->validlt = cf->preflt = ~0L;
}
@

<<function [[optname]]>>=
static char *
optname(unsigned opt)
{
    static char buf[32];

    if (opt >= nelem(icmp6opts) || icmp6opts[opt] == nil) {
        snprint(buf, sizeof buf, "unknown option %d", opt);
        return buf;
    } else
        return icmp6opts[opt];
}
@

<<function [[opt_seprint]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
static char*
opt_seprint(uchar *ps, uchar *pe, char *sps, char *spe)
{
    int otype, osz, pktsz;
    uchar *a;
    char *p = sps, *e = spe;

    a = ps;
    for (pktsz = pe - ps; pktsz > 0; pktsz -= osz) {
        otype = a[0];
        osz = a[1] * 8;

        switch (otype) {
        default:
            return seprint(p, e, " option=%s ", optname(otype));
        case V6nd_srclladdr:
        case V6nd_targlladdr:
            if (pktsz < osz || osz != 8)
                return seprint(p, e, " option=%s bad size=%d",
                    optname(otype), osz);
            p = seprint(p, e, " option=%s maddr=%E", optname(otype),
                a+2);
            break;
        case V6nd_pfxinfo:
            if (pktsz < osz || osz != 32)
                return seprint(p, e, " option=%s: bad size=%d",
                    optname(otype), osz);

            p = seprint(p, e, " option=%s pref=%I preflen=%3.3d"
                " lflag=%1.1d aflag=%1.1d unused1=%1.1d"
                " validlt=%ud preflt=%ud unused2=%1.1d",
                optname(otype), a+16, (int)(*(a+2)),
                (*(a+3) & (1 << 7)) != 0,
                (*(a+3) & (1 << 6)) != 0,
                (*(a+3) & 63) != 0,
                NetL(a+4), NetL(a+8), NetL(a+12)!=0);
            break;
        }
        a += osz;
    }
    return p;
}
@

<<function [[pkt2str]]>>=
static void
pkt2str(uchar *ps, uchar *pe, char *sps, char *spe)
{
    int pktlen;
    char *tn, *p, *e;
    uchar *a;
    Hdr *h;

    h = (Hdr*)ps;
    a = ps + 4;
    p = sps;
    e = spe;

    pktlen = pe - ps;
    if(pktlen < ICMP6LEN) {
        seprint(sps, spe, "short pkt");
        return;
    }

    tn = icmpmsg6[h->type];
    if(tn == nil)
        p = seprint(p, e, "t=%ud c=%d ck=%4.4ux", h->type,
            h->code, (ushort)NetS(h->cksum));
    else
        p = seprint(p, e, "t=%s c=%d ck=%4.4ux", tn,
            h->code, (ushort)NetS(h->cksum));

    switch(h->type){
    case RouterSolicit:
        ps += 8;
        p = seprint(p, e, " unused=%1.1d ", NetL(a)!=0);
        opt_seprint(ps, pe, p, e);
        break;
    case RouterAdvert:
        ps += 16;
        p = seprint(p, e, " hoplim=%3.3d mflag=%1.1d oflag=%1.1d"
            " unused=%1.1d routerlt=%d reachtime=%d rxmtimer=%d",
            a[0],
            (*(a+1) & (1 << 7)) != 0,
            (*(a+1) & (1 << 6)) != 0,
            (*(a+1) & 63) != 0,
            NetS(a+2), NetL(a+4), NetL(a+8));
        opt_seprint(ps, pe, p, e);
        break;
    default:
        seprint(p, e, " unexpected icmp6 pkt type");
        break;
    }
}
@

<<function [[catch]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
static void
catch(void *a, char *msg)
{
    USED(a);
    if(strstr(msg, "alarm"))
        noted(NCONT);
    else
        noted(NDFLT);
}
@

<<function [[procsetname]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
/*
 * based on libthread's threadsetname, but drags in less library code.
 * actually just sets the arguments displayed.
 */
void
procsetname(char *fmt, ...)
{
    int fd;
    char *cmdname;
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    cmdname = vsmprint(fmt, arg);
    va_end(arg);
    if (cmdname == nil)
        return;
    snprint(buf, sizeof buf, "#p/%d/args", getpid());
    if((fd = open(buf, OWRITE)) >= 0){
        write(fd, cmdname, strlen(cmdname)+1);
        close(fd);
    }
    free(cmdname);
}
@

<<function [[dialicmp]]>>=
int
dialicmp(uchar *dst, int dport, int *ctlfd)
{
    int fd, cfd, n, m;
    char cmsg[100], name[128], connind[40];
    char hdrs[] = "headers";

    snprint(name, sizeof name, "%s/icmpv6/clone", conf.mpoint);
    cfd = open(name, ORDWR);
    if(cfd < 0)
        sysfatal("dialicmp: can't open %s: %r", name);

    n = snprint(cmsg, sizeof cmsg, "connect %I!%d!r %d", dst, dport, dport);
    m = write(cfd, cmsg, n);
    if (m < n)
        sysfatal("dialicmp: can't write %s to %s: %r", cmsg, name);

    seek(cfd, 0, 0);
    n = read(cfd, connind, sizeof connind);
    if (n < 0)
        connind[0] = 0;
    else if (n < sizeof connind)
        connind[n] = 0;
    else
        connind[sizeof connind - 1] = 0;

    snprint(name, sizeof name, "%s/icmpv6/%s/data", conf.mpoint, connind);
    fd = open(name, ORDWR);
    if(fd < 0)
        sysfatal("dialicmp: can't open %s: %r", name);

    n = sizeof hdrs - 1;
    if(write(cfd, hdrs, n) < n)
        sysfatal("dialicmp: can't write `%s' to %s: %r", hdrs, name);
    *ctlfd = cfd;
    return fd;
}
@

<<function [[ip6cfg]]>>=
/* add ipv6 addr to an interface */
int
ip6cfg(int autoconf)
{
    int dupfound = 0, n;
    char *p;
    char buf[256];
    uchar ethaddr[6];
    Biobuf *bp;

    if (autoconf) {			/* create link-local addr */
        if (myetheraddr(ethaddr, conf.dev) < 0)
            sysfatal("myetheraddr w/ %s failed: %r", conf.dev);
        ea2lla(conf.laddr, ethaddr);
    }

    if (dupl_disc)
        n = sprint(buf, "try");
    else
        n = sprint(buf, "add");

    n += snprint(buf+n, sizeof buf-n, " %I", conf.laddr);
    if(!validip(conf.mask))
        ipmove(conf.mask, v6defmask);
    n += snprint(buf+n, sizeof buf-n, " %M", conf.mask);
    if(validip(conf.raddr)){
        n += snprint(buf+n, sizeof buf-n, " %I", conf.raddr);
        if(conf.mtu != 0)
            n += snprint(buf+n, sizeof buf-n, " %d", conf.mtu);
    }

    if(write(conf.cfd, buf, n) < 0){
        warning("write(%s): %r", buf);
        return -1;
    }

    if (!dupl_disc)
        return 0;

    sleep(3000);

    /* read arp table, look for addr duplication */
    snprint(buf, sizeof buf, "%s/arp", conf.mpoint);
    bp = Bopen(buf, OREAD);
    if (bp == 0) {
        warning("couldn't open %s: %r", buf);
        return -1;
    }

    snprint(buf, sizeof buf, "%I", conf.laddr);
    while(p = Brdline(bp, '\n')){
        p[Blinelen(bp)-1] = 0;
        if(cistrstr(p, buf) != 0) {
            warning("found dup entry in arp cache");
            dupfound = 1;
            break;
        }
    }
    Bterm(bp);

    if (dupfound)
        doremove();
    else {
        n = sprint(buf, "add %I %M", conf.laddr, conf.mask);
        if(validip(conf.raddr)){
            n += snprint(buf+n, sizeof buf-n, " %I", conf.raddr);
            if(conf.mtu != 0)
                n += snprint(buf+n, sizeof buf-n, " %d",
                    conf.mtu);
        }
        write(conf.cfd, buf, n);
    }
    return 0;
}
@

<<function [[recvra6on]]>>=
static int
recvra6on(char *net, int conn)
{
    Ipifc* ifc;

    ifc = readipifc(net, nil, conn);
    if (ifc == nil)
        return 0;
    else if (ifc->sendra6 > 0)
        return IsRouter;
    else if (ifc->recvra6 > 0)
        return IsHostRecv;
    else
        return IsHostNoRecv;
}
@

<<function [[sendrs]]>>=
/* send icmpv6 router solicitation to multicast address for all routers */
static void
sendrs(int fd)
{
    Routersol *rs;
    uchar buff[sizeof *rs];

    memset(buff, 0, sizeof buff);
    rs = (Routersol *)buff;
    memmove(rs->dst, v6allroutersL, IPaddrlen);
    memmove(rs->src, v6Unspecified, IPaddrlen);
    rs->type = ICMP6_RS;

    if(write(fd, rs, sizeof buff) < sizeof buff)
        ralog("sendrs: write failed, pkt size %d", sizeof buff);
    else
        ralog("sendrs: sent solicitation to %I from %I on %s",
            rs->dst, rs->src, conf.dev);
}
@

<<function [[recvrarouter]]>>=
/*
 * a router receiving a router adv from another
 * router calls this; it is basically supposed to
 * log the information in the ra and raise a flag
 * if any parameter value is different from its configured values.
 *
 * doing nothing for now since I don't know where to log this yet.
 */
static void
recvrarouter(uchar buf[], int pktlen)
{
    USED(buf, pktlen);
    ralog("i am a router and got a router advert");
}
@

<<function [[ewrite]]([[(networking/ip/ipconfig/ipv6.c)]])>>=
/* host receiving a router advertisement calls this */

static void
ewrite(int fd, char *str)
{
    int n;

    n = strlen(str);
    if (write(fd, str, n) != n)
        ralog("write(%s) failed: %r", str);
}
@

<<function [[issuebasera6]]>>=
static void
issuebasera6(Conf *cf)
{
    char *cfg;

    cfg = smprint("ra6 mflag %d oflag %d reachtime %d rxmitra %d "
        "ttl %d routerlt %d",
        cf->mflag, cf->oflag, cf->reachtime, cf->rxmitra,
        cf->ttl, cf->routerlt);
    ewrite(cf->cfd, cfg);
    free(cfg);
}
@

<<function [[issuerara6]]>>=
static void
issuerara6(Conf *cf)
{
    char *cfg;

    cfg = smprint("ra6 sendra %d recvra %d maxraint %d minraint %d "
        "linkmtu %d",
        cf->sendra, cf->recvra, cf->maxraint, cf->minraint,
        cf->linkmtu);
    ewrite(cf->cfd, cfg);
    free(cfg);
}
@

<<function [[issueadd6]]>>=
static void
issueadd6(Conf *cf)
{
    char *cfg;

    cfg = smprint("add6 %I %d %d %d %lud %lud", cf->v6pref, cf->prefixlen,
        cf->onlink, cf->autoflag, cf->validlt, cf->preflt);
    ewrite(cf->cfd, cfg);
    free(cfg);
}
@

<<function [[recvrahost]]>>=
static void
recvrahost(uchar buf[], int pktlen)
{
    int arpfd, m, n;
    char abuf[100];
    uchar optype;
    Lladdropt *llao;
    Mtuopt *mtuo;
    Prefixopt *prfo;
    Routeradv *ra;
    static int first = 1;

    ra = (Routeradv*)buf;
//	memmove(conf.v6gaddr, ra->src, IPaddrlen);
    conf.ttl = ra->cttl;
    conf.mflag = (MFMASK & ra->mor);
    conf.oflag = (OCMASK & ra->mor);
    conf.routerlt =  nhgets(ra->routerlt);
    conf.reachtime = nhgetl(ra->rchbltime);
    conf.rxmitra =   nhgetl(ra->rxmtimer);

//	issueadd6(&conf);		/* for conf.v6gaddr? */
    if (fprint(conf.cfd, "ra6 recvra 1") < 0)
        ralog("write(ra6 recvra 1) failed: %r");
    issuebasera6(&conf);

    m = sizeof *ra;
    while (pktlen - m > 0) {
        optype = buf[m];
        switch (optype) {
        case V6nd_srclladdr:
            llao = (Lladdropt *)&buf[m];
            m += 8 * buf[m+1];
            if (llao->len != 1) {
                ralog("recvrahost: illegal len (%d) for source "
                    "link layer address option", llao->len);
                return;
            }
            if (!ISIPV6LINKLOCAL(ra->src)) {
                ralog("recvrahost: non-link-local src addr for "
                    "router adv %I", ra->src);
                return;
            }

            snprint(abuf, sizeof abuf, "%s/arp", conf.mpoint);
            arpfd = open(abuf, OWRITE);
            if (arpfd < 0) {
                ralog("recvrahost: couldn't open %s to write: %r",
                    abuf);
                return;
            }

            n = snprint(abuf, sizeof abuf, "add ether %I %E",
                ra->src, llao->lladdr);
            if (write(arpfd, abuf, n) < n)
                ralog("recvrahost: couldn't write to %s/arp",
                    conf.mpoint);
            close(arpfd);
            break;
        case V6nd_targlladdr:
        case V6nd_redirhdr:
            m += 8 * buf[m+1];
            ralog("ignoring unexpected option type `%s' in Routeradv",
                optname(optype));
            break;
        case V6nd_mtu:
            mtuo = (Mtuopt*)&buf[m];
            m += 8 * mtuo->len;
            conf.linkmtu = nhgetl(mtuo->mtu);
            break;
        case V6nd_pfxinfo:
            prfo = (Prefixopt*)&buf[m];
            m += 8 * prfo->len;
            if (prfo->len != 4) {
                ralog("illegal len (%d) for prefix option",
                    prfo->len);
                return;
            }
            memmove(conf.v6pref, prfo->pref, IPaddrlen);
            conf.prefixlen = prfo->plen;
            conf.onlink =   ((prfo->lar & OLMASK) != 0);
            conf.autoflag = ((prfo->lar & AFMASK) != 0);
            conf.validlt = nhgetl(prfo->validlt);
            conf.preflt =  nhgetl(prfo->preflt);
            issueadd6(&conf);
            if (first) {
                first = 0;
                ralog("got initial RA from %I on %s; pfx %I",
                    ra->src, conf.dev, prfo->pref);
            }
            break;
        default:
            if (debug)
                ralog("ignoring optype %d in Routeradv from %I",
                    optype, ra->src);
            /* fall through */
        case V6nd_srcaddrs:
            /* netsbd sends this, so quietly ignore it for now */
            m += 8 * buf[m+1];
            break;
        }
    }
}
@

<<function [[recvra6]]>>=
/*
 * daemon to receive router advertisements from routers
 */
void
recvra6(void)
{
    int fd, cfd, n, sendrscnt, sleepfor;
    uchar buf[4096];

    /* TODO: why not v6allroutersL? */
    fd = dialicmp(v6allnodesL, ICMP6_RA, &cfd);
    if (fd < 0)
        sysfatal("can't open icmp_ra connection: %r");

    notify(catch);
    sendrscnt = Maxv6rss;

    switch(rfork(RFPROC|RFMEM|RFFDG|RFNOWAIT|RFNOTEG)){
    case -1:
        sysfatal("can't fork: %r");
    default:
        return;
    case 0:
        break;
    }

    procsetname("recvra6 on %s", conf.dev);
    ralog("recvra6 on %s", conf.dev);
    sleepfor = jitter();
    for (;;) {
        /*
         * We only get 3 (Maxv6rss) tries, so make sure we
         * wait long enough to be certain that at least one RA
         * will be transmitted.
         */
        if (sleepfor < 7000)
            sleepfor = 7000;
        alarm(sleepfor);
        n = read(fd, buf, sizeof buf);
        alarm(0);
        if (n <= 0) {
            if (sendrscnt > 0) {
                sendrscnt--;
                if (recvra6on(conf.mpoint, myifc) == IsHostRecv)
                    sendrs(fd);
                sleepfor = V6rsintvl + nrand(100);
            }
            if (sendrscnt == 0) {
                sendrscnt--;
                sleepfor = 0;
                ralog("recvra6: no router advs after %d sols on %s",
                    Maxv6rss, conf.dev);
            }
            continue;
        }

        sleepfor = 0;
        sendrscnt = -1;		/* got at least initial ra; no whining */
        switch (recvra6on(conf.mpoint, myifc)) {
        case IsRouter:
            recvrarouter(buf, n);
            break;
        case IsHostRecv:
            recvrahost(buf, n);
            break;
        case IsHostNoRecv:
            ralog("recvra6: recvra off, quitting on %s", conf.dev);
            close(fd);
            exits(0);
        default:
            ralog("recvra6: unable to read router status on %s",
                conf.dev);
            break;
        }
    }
}
@

<<function [[recvrs]]>>=
/*
 * return -1 -- error, reading/writing some file,
 *         0 -- no arp table updates
 *         1 -- successful arp table update
 */
int
recvrs(uchar *buf, int pktlen, uchar *sol)
{
    int n, optsz, arpfd;
    char abuf[256];
    Routersol *rs;
    Lladdropt *llao;

    rs = (Routersol *)buf;
    n = sizeof *rs;
    optsz = pktlen - n;
    pkt2str(buf, buf+pktlen, abuf, abuf+nelem(abuf));

    if (optsz != sizeof *llao)
        return 0;
    if (buf[n] != V6nd_srclladdr || 8*buf[n+1] != sizeof *llao) {
        ralog("rs opt err %s", abuf);
        return -1;
    }

    ralog("rs recv %s", abuf);

    if (memcmp(rs->src, v6Unspecified, IPaddrlen) == 0)
        return 0;

    snprint(abuf, sizeof abuf, "%s/arp", conf.mpoint);
    arpfd = open(abuf, OWRITE);
    if (arpfd < 0) {
        ralog("recvrs: can't open %s/arp to write: %r", conf.mpoint);
        return -1;
    }

    llao = (Lladdropt *)buf[n];
    n = snprint(abuf, sizeof abuf, "add ether %I %E", rs->src, llao->lladdr);
    if (write(arpfd, abuf, n) < n) {
        ralog("recvrs: can't write to %s/arp: %r", conf.mpoint);
        close(arpfd);
        return -1;
    }

    memmove(sol, rs->src, IPaddrlen);
    close(arpfd);
    return 1;
}
@

<<function [[sendra]]>>=
void
sendra(int fd, uchar *dst, int rlt)
{
    int pktsz, preflen;
    char abuf[1024], tmp[40];
    uchar buf[1024], macaddr[6], src[IPaddrlen];
    Ipifc *ifc = nil;
    Iplifc *lifc, *nlifc;
    Lladdropt *llao;
    Prefixopt *prfo;
    Routeradv *ra;

    memset(buf, 0, sizeof buf);
    ra = (Routeradv *)buf;

    myetheraddr(macaddr, conf.dev);
    ea2lla(src, macaddr);
    memmove(ra->src, src, IPaddrlen);
    memmove(ra->dst, dst, IPaddrlen);
    ra->type = ICMP6_RA;
    ra->cttl = conf.ttl;

    if (conf.mflag > 0)
        ra->mor |= MFMASK;
    if (conf.oflag > 0)
        ra->mor |= OCMASK;
    if (rlt > 0)
        hnputs(ra->routerlt, conf.routerlt);
    else
        hnputs(ra->routerlt, 0);
    hnputl(ra->rchbltime, conf.reachtime);
    hnputl(ra->rxmtimer, conf.rxmitra);

    pktsz = sizeof *ra;

    /* include all global unicast prefixes on interface in prefix options */
    ifc = readipifc(conf.mpoint, ifc, myifc);
    for (lifc = (ifc? ifc->lifc: nil); lifc; lifc = nlifc) {
        nlifc = lifc->next;
        prfo = (Prefixopt *)(buf + pktsz);
        /* global unicast address? */
        if (!ISIPV6LINKLOCAL(lifc->ip) && !ISIPV6MCAST(lifc->ip) &&
            memcmp(lifc->ip, IPnoaddr, IPaddrlen) != 0 &&
            memcmp(lifc->ip, v6loopback, IPaddrlen) != 0 &&
            !isv4(lifc->ip)) {
            memmove(prfo->pref, lifc->net, IPaddrlen);

            /* hack to find prefix length */
            snprint(tmp, sizeof tmp, "%M", lifc->mask);
            preflen = atoi(&tmp[1]);
            prfo->plen = preflen & 0xff;
            if (prfo->plen == 0)
                continue;

            prfo->type = V6nd_pfxinfo;
            prfo->len = 4;
            prfo->lar = AFMASK;
            hnputl(prfo->validlt, lifc->validlt);
            hnputl(prfo->preflt, lifc->preflt);
            pktsz += sizeof *prfo;
        }
    }
    /*
     * include link layer address (mac address for now) in
     * link layer address option
     */
    llao = (Lladdropt *)(buf + pktsz);
    llao->type = V6nd_srclladdr;
    llao->len = 1;
    memmove(llao->lladdr, macaddr, sizeof macaddr);
    pktsz += sizeof *llao;

    pkt2str(buf+40, buf+pktsz, abuf, abuf+1024);
    if(write(fd, buf, pktsz) < pktsz)
        ralog("sendra fail %s: %r", abuf);
    else if (debug)
        ralog("sendra succ %s", abuf);
}
@

<<function [[sendra6]]>>=
/*
 * daemon to send router advertisements to hosts
 */
void
sendra6(void)
{
    int fd, cfd, n, dstknown = 0, sendracnt, sleepfor, nquitmsgs;
    long lastra, now;
    uchar buf[4096], dst[IPaddrlen];
    Ipifc *ifc = nil;

    fd = dialicmp(v6allnodesL, ICMP6_RS, &cfd);
    if (fd < 0)
        sysfatal("can't open icmp_rs connection: %r");

    notify(catch);
    sendracnt = Maxv6initras;
    nquitmsgs = Maxv6finalras;

    switch(rfork(RFPROC|RFMEM|RFFDG|RFNOWAIT|RFNOTEG)){
    case -1:
        sysfatal("can't fork: %r");
    default:
        return;
    case 0:
        break;
    }

    procsetname("sendra6 on %s", conf.dev);
    ralog("sendra6 on %s", conf.dev);
    sleepfor = jitter();
    for (;;) {
        lastra = time(0);
        if (sleepfor < 0)
            sleepfor = 0;
        alarm(sleepfor);
        n = read(fd, buf, sizeof buf);
        alarm(0);

        ifc = readipifc(conf.mpoint, ifc, myifc);
        if (ifc == nil) {
            ralog("sendra6: can't read router params on %s",
                conf.mpoint);
            continue;
        }

        if (ifc->sendra6 <= 0)
            if (nquitmsgs > 0) {
                sendra(fd, v6allnodesL, 0);
                nquitmsgs--;
                sleepfor = Minv6interradelay + jitter();
                continue;
            } else {
                ralog("sendra6: sendra off, quitting on %s",
                    conf.dev);
                exits(0);
            }

        nquitmsgs = Maxv6finalras;

        if (n <= 0) {			/* no RS */
            if (sendracnt > 0)
                sendracnt--;
        } else {			/* respond to RS */
            dstknown = recvrs(buf, n, dst);
            now = time(0);

            if (now - lastra < Minv6interradelay) {
                /* too close, skip */
                sleepfor = lastra + Minv6interradelay +
                    jitter() - now;
                continue;
            }
            sleep(jitter());
        }
        sleepfor = randint(ifc->rp.minraint, ifc->rp.maxraint);
        if (dstknown > 0)
            sendra(fd, dst, 1);
        else
            sendra(fd, v6allnodesL, 1);
    }
}
@

<<function [[startra6]]>>=
void
startra6(void)
{
    static char routeon[] = "iprouting 1";

    if (conf.recvra > 0)
        recvra6();

    if (conf.sendra > 0) {
        if (write(conf.cfd, routeon, sizeof routeon - 1) < 0) {
            warning("write (iprouting 1) failed: %r");
            return;
        }
        sendra6();
        if (conf.recvra <= 0)
            recvra6();
    }
}
@

<<function [[doipv6]]>>=
void
doipv6(int what)
{
    nip = nipifcs(conf.mpoint);
    if(!noconfig){
        lookforip(conf.mpoint);
        controldevice();
        binddevice();
    }

    switch (what) {
    default:
        sysfatal("unknown IPv6 verb");
    case Vaddpref6:
        issueadd6(&conf);
        break;
    case Vra6:
        issuebasera6(&conf);
        issuerara6(&conf);
        dolog = 1;
        startra6();
        break;
    }
}
@


%-------------------------------------------------------------

<<networking/ip/ipconfig/ipv6.c>>=
/*
 * ipconfig for IPv6
 *	RS means Router Solicitation
 *	RA means Router Advertisement
 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ip.h>
#include "ipconfig.h"
#include "../icmp.h"

#pragma varargck argpos ralog 1

<<constant [[RALOG]]>>

<<macro [[NetS]]([[(networking/ip/ipconfig/ipv6.c)]])>>
<<macro [[NetL]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<enum [[_anon_ (networking/ip/ipconfig/ipv6.c)]]>>

typedef struct Hdr Hdr;
<<struct [[Hdr]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<global [[icmpmsg6]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<global [[icmp6opts]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<global [[v6allroutersL]]>>

<<global [[v6allnodesL]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<global [[v6Unspecified]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<global [[v6loopback]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<global [[v6glunicast]]>>

<<global [[v6linklocal]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<global [[v6solpfx]]>>

<<global [[v6defmask]]>>

<<enum [[_anon_ (networking/ip/ipconfig/ipv6.c)2]]>>

<<function [[ralog]]>>

<<function [[ea2lla]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<function [[ipv62smcast]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<function [[v6paraminit]]>>

<<function [[optname]]>>

<<function [[opt_seprint]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<function [[pkt2str]]>>

<<function [[catch]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<function [[procsetname]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<function [[dialicmp]]>>

<<function [[ip6cfg]]>>

<<function [[recvra6on]]>>

<<function [[sendrs]]>>

<<function [[recvrarouter]]>>

<<function [[ewrite]]([[(networking/ip/ipconfig/ipv6.c)]])>>

<<function [[issuebasera6]]>>

<<function [[issuerara6]]>>

<<function [[issueadd6]]>>

<<function [[recvrahost]]>>

<<function [[recvra6]]>>

<<function [[recvrs]]>>

<<function [[sendra]]>>

<<function [[sendra6]]>>

<<function [[startra6]]>>

<<function [[doipv6]]>>
@


