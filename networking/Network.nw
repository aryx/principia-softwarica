\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - untangled all those features, arp, multicast, with those big structures
%   that were hard to understand
% - use cv not c for conversation, less confusing with channel
% - use Idle, not 0 when can

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand networking:
% - TODO ether, ip, ppp, udp, tcp, actually I didn't know 
%   that much about network
% - TODO does not need much to configure initially; can do things manually
%   without ipconfig and actually you need to do very few things

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - SEMI  understand main(), LP split main, improve TOC
% - SEMI  understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for ?

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Network Stack [[/net/]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Dave Presotto and Phil Winterbottom\\
% more?
}


\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a network stack.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item XINU
\item Linux
\item FreeBSD
% have strong reputation
\end{itemize}

%meh:
%http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/

\section{Getting started}


\section{Requirements}

% Tannenbaum computer networks book?
% Computer networks, a top-down approach?
% tcp/ip ...?


%Intro to computer networks (free, but maybe not that good)
%http://intronetworks.cs.luc.edu/

% "The organization of networks in plan9".ps
% il.ps
% ip(8?)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Network principles}

% local (mac) address, ethernet, ARP discovery, local area network
% old: ipx?

% packets! and actually whole idea of network abstraction is to
% provide what seems like an arbitrary length or even continuous stream
% of data on top of this fixed packet. A bit similar to file and fs
% which are on top of disk blocks.

\section{Internetworking principles}

% ip, inter network, routing, gateway
% (packets become really useful there because big sharing)

\section{Network stack principles}

% ip stack goal is to multiplex access to network device?
% and to provide different encoding protocols?

\section{[[/net]] services}

% In plan9 every kernel service is implemented as a file server.
% Everything is a file. So a connexion to a remote machine is
% a file in plan9 (in unix it's a socket, which is a kind of file,
% it has a fd, and can even be on the fs sometimes).
% In unix configure the file/socket via ioctl. In plan9 it's
% via the fs and via a control file. /net/<proto>/<conv>/ctl

% see 'network plan9'.ps

% /net/ether0/addr
% /net/ipfc/clone
% /net/arp
% /net/iproute

% maybe can put early the 
%    echo 'bind ether /net/ether0' > /net/ipifc/x/ctl
% and then 
%    echo 'add 10.0.0.15' > /net/ipifc/x/ctl

% /net/<proto>/<conv>/ for the most part.

%todo: then how initiate connexion manually? using just the shell!
% echo 'connect ???' > /net/udp/clone ? then cat /net/udp/x/data ?
% and somewhere echo in udp?
% can emulate named pipe?


\section{[[ping]], [[traceroute]], etc}

\section{Code organization}

% include/ip.h
% lib_networking/libip/
% kernel/network/, devip, devether, udp.c, tpc.c, and etherigbe.c
% networking/...

\section{Software architecture}

% physical (e.g. ethernet), kernel (devip+ether), lib(dial), apps (e.g. telnetd)
% and on the other side
% physical (e.g. ethernet), kernel (devip+ether), lib(listen), apps (e.g. telnet)

% client/server but in the end really something reading from a file
% and something writing to the file. In essence network comm is
% like reading/writing to a file, except the file represent a connection
% to somewhere else, not a local file.

% link-layer: ethernet, (arp, ... aoe)
% network-layer: ip (routing, icmp?)
% transport-layer: (udp, tcp, il, ... )
% "applications" protocol (dhcp, dns, telnetd, http, imap, ...)
% actual applications (telnet, ping, ...)

% encapsulation each time

% Proto vs Fs vs Ipifc vs Netif

% OO like interface, with class and methods, and some private
% fields.

% f = fs
% cv = conversation
% c = channel (TODO or conversation sometimes, but we should rename it)
% p = protocol

\section{Trace of a ping}

\section{Trace of a network write}

%\section{Trace of an RPC}

%###############################################################################

\chapter{Core Data Structures}

\section{IP address}

% universal (later we will see URL, even more general)
% inter-network

%less: typedef uchar ippart ? typedef uchar* ip? 
% and actually apparently an array of 16 elt (to cover ipv4 and ipv6)

<<constant IPaddrlen>>=
IPaddrlen=	16,
@
% 16 bytes IP(v6) address


\subsection{IPv4 vs IPv6}

<<global v4prefix>>=
/*
 *  prefix of all v4 addresses
 */
uchar v4prefix[IPaddrlen] = {
    // first 12
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,

    // rest are ipv4 numbers
    0, 0, 0, 0
};
@

<<constant IPv4addrlen>>=
IPv4addrlen=	4,
@

<<constant IPv4off>>=
IPv4off=	12,
@

<<function isv4>>=
bool
isv4(uchar *ip)
{
    return memcmp(ip, v4prefix, IPv4off) == 0;
}
@
% first 12 must be identical to v4prefix

<<function v4tov6>>=
/*
 *  the following routines are unrolled with no memset's to speed
 *  up the usual case
 */
void
v4tov6(uchar *v6, uchar *v4)
{
    v6[0] = 0;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v6[5] = 0;
    v6[6] = 0;
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    v6[10] = 0xff;
    v6[11] = 0xff;
    v6[12] = v4[0];
    v6[13] = v4[1];
    v6[14] = v4[2];
    v6[15] = v4[3];
}
@

\subsection{Class}

<<macro CLASS>>=
#define CLASS(p) ((*(uchar*)(p))>>6)
@
% ?? first 2 bits of first number in IP?

\subsection{Mask}

<<function defmask>>=
uchar*
defmask(uchar *ip)
{
    if(isv4(ip))
        return classmask[ip[IPv4off]>>6];
    <<[[defmask()]] if ipv6>>
}
@
%less: why not use CLASS? instead of >>6 above?

<<global classmask>>=
static uchar classmask[4][16] = {
    // class 0
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0x00,0x00,0x00, // 255.0.0.0
    // class 1
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0x00,0x00,0x00, // 255.0.0.0
    // class 2
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0xff,0x00,0x00, // 255.255.0.0
    // class 3
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0xff,0xff,0x00, // 255.255.255.0
};
@
% class use 2 bits, so 4 entries
% 255.255.etc
% use IPADDRLen instead of 16?


<<function maskip>>=
void
maskip(uchar *from, uchar *mask, uchar *to)
{
    int i;

    for(i = 0; i < IPaddrlen; i++)
        to[i] = from[i] & mask[i];
}
@

\section{IP Interface, [[Ipifc]]}

% /net/ipifc/...

% this will associate an IP (logical address) to a 
% physical device (physical address)


\subsection{User side}

% how used by programmer? readipifc()?
% hmm but not that useful in practice no? or because dial uses that?
% Need that to know who you are ... like hostname?

% /net/ipifc/x/stats?
% in ip.h
<<struct Ipifc (user)>>=
/* actual interface */
struct Ipifc
{
    /* per ip interface */
    int	index;			/* number of interface in ipifc dir */
    char	dev[64];
    int	mtu;
    // list<ref_own<Iplifc> (next = Iplifc.next)
    Iplifc	*lifc;

    <<[[Ipifc(user)]] stat fields>>
    <<[[Ipifc(user)]] ipv6 fields>>

    //Extra
    <<[[Ipifc(user)]] extra fields>>
};
@
% echo 'bind ether /net/ether0' > /net/ipifc/x/ctl

% what is inside dev[64]? /net/ether0

<<[[Ipifc(user)]] stat fields>>=
ulong	pktin;
ulong	pktout;
ulong	errin;
ulong	errout;
@


<<[[Ipifc(user)]] extra fields>>=
Ipifc	*next;
@
% readipifc can return the list of all interfaces



<<struct Iplifc (user)>>=
/* local address */
struct Iplifc
{
    /* per address on the ip interface */
    uchar	ip[IPaddrlen];
    uchar	mask[IPaddrlen];
    uchar	net[IPaddrlen];		/* ip & mask */

    <<[[Iplifc(user)]] other fields>>

    // Extra
    <<[[Iplifc(user)]] extra fields>>
};
@
% finally an ip!
%less: local? or logical?
% echo 'add localip' > /net/ipicf/x/ctl

% can have multiple IP connected to same device? what for?

<<[[Iplifc(user)]] extra fields>>=
// list<ref_own<Iplifc>>, head = Ipifc.lifc
Iplifc	*next;
@

%XXX
<<[[Iplifc(user)]] other fields>>=
ulong	preflt;			/* preferred lifetime */
ulong	validlt;		/* valid lifetime */
@

\subsection{Kernel side}

%todo: who points to that in the kernel? actually there is no single
% ipifc global in the kernel because a machine can have multiple ips
% (e.g. a bridge), and so the user access the one he wants via
% /net/ipifc/.
%todo: OK but when go to /net/tcp/clone, get which interface??

<<struct Ipifc (kernel)>>=
struct Ipifc
{
  char  dev[64];  /* device we're attached to */

  int maxtu;    /* Maximum transfer unit */
  int mintu;    /* Minumum tranfer unit */
  int mbps;   /* megabits per second */

  Medium  *m;   /* Media pointer */
  void  *arg;   /* medium specific */
  uchar mac[MAClen];  /* MAC address */

  // list<ref_own<Iplifc>>, next = Iplifc.next
  Iplifc  *lifc;    /* logical interfaces on this physical one */

  <<[[Ipifc(kernel)]] stat fields>>
  <<[[Ipifc(kernel)]] ipv6 fields>>
  <<[[Ipifc(kernel)]] other fields>>

  //Extra
  RWlock;

};
@

% what is inside dev[64]? /net/ether0

<<[[Ipifc(kernel)]] stat fields>>=
ulong in, out;  /* message statistics */
ulong inerr, outerr;  /* ... */
@

<<[[Ipifc(kernel)]] other fields>>=
Conv  *conv;    /* link to its conversation structure */
@
% will see later, but in ipifcadd can do  f = ifc->conv->p->f;



%XXX
<<[[Ipifc(kernel)]] other fields>>=
bool reassemble; /* reassemble IP packets before forwarding */

/* these are used so that we can unbind on the fly */
Lock  idlock;
uchar ifcid;    /* incremented each 'bind/unbind/add/remove' */
int ref;    /* number of proc's using this ipifc */
Rendez  wait;   /* where unbinder waits for ref == 0 */
int unbinding;
@

%XXX routing fields?
<<[[Ipifc(kernel)]] other fields>>=
Routerparams rp;  /* router parameters as in RFC 2461, pp.40â€”43.
        used only if node is router */
@






<<struct Iplifc (kernel)>>=
/* logical interface associated with a physical one */
struct Iplifc
{
  uchar local[IPaddrlen];
  uchar mask[IPaddrlen];
  uchar net[IPaddrlen];

  uchar remote[IPaddrlen];

  <<[[Iplifc(kernel)]] other fields>>

  // Extra
  <<[[Iplifc(kernel)]] extra fields>>
};
@
% local = ip?
% remote??

<<[[Iplifc(kernel)]] extra fields>>=
// list<ref_own<Iplifc>>, head = Ipifc.lifc
Iplifc  *next;
@



%XXX
<<[[Iplifc(kernel)]] extra fields>>=
Iplink  *link;    /* addresses linked to this lifc */
@

%XXX
<<[[Iplifc(kernel)]] other fields>>=
uchar tentative;  /* =1 => v6 dup disc on, =0 => confirmed unique */
uchar onlink;   /* =1 => onlink, =0 offlink. */
uchar autoflag; /* v6 autonomous flag */
long  validlt;  /* v6 valid lifetime */
long  preflt;   /* v6 preferred lifetime */
long  origint;  /* time when addr was added */
@

\section{Link [[Medium]], and [[media]]}

% e.g. for ethernet
% see later: null, loopback, packet

% see that it's pointed by Ipifc above

<<struct Medium (kernel)>>=
struct Medium
{
  char  *name;

  int hsize;    /* medium header size */
  int mintu;    /* default min mtu */
  int maxtu;    /* default max mtu */
  int maclen;   /* mac address length  */
 
  // the methods
  void  (*bind)(Ipifc*, int, char**);
  void  (*unbind)(Ipifc*);

  void  (*bwrite)(Ipifc *ifc, Block *b, int version, uchar *ip);
  /* process packets written to 'data' */
  void  (*pktin)(Fs *f, Ipifc *ifc, Block *bp);

  <<[[Medium(kernel)]] multicast methods>>
  <<[[Medium(kernel)]] other methods>>
  <<[[Medium(kernel)]] other fields>>

};
@
% char**? array of string? to pass parameters to bind? e.g. path
% in 'bind ether /net/ether0' ?

%todo: bwrite!! that's where you write the data???
% and pktin is to read?

%% ipwrite (Ctl case) -> bindctlmsg -> ipifcbind -> <> 
%     (as m->find <- ipfindmedium <- media[i] <- ???)
% void  (*bind)(Ipifc*, int, char**);


<<global media>>=
Medium *media[Maxmedia] = { 0 };
@
<<constant Maxmedia>>=
Maxmedia    = 32,
@

% ?? -> <>  ? qemu.c links() and ethermediumlink?
<<function addipmedium>>=
/*
 *  link in a new medium
 */
void
addipmedium(Medium *med)
{
    int i;

    for(i = 0; i < nelem(media)-1; i++)
        if(media[i] == nil){
            media[i] = med;
            break;
        }
}
@
% no warning if overflow?
%less: boilerplate code, should have a generic function for that




%XXX
<<[[Medium(kernel)]] other fields>>=
bool unbindonclose;  /* if non-zero, unbind on last close */
@


%XXX
<<[[Medium(kernel)]] other methods>>=
/* routes for router boards */
void  (*addroute)(Ipifc *ifc, int, uchar*, uchar*, uchar*, int);
void  (*remroute)(Ipifc *ifc, int, uchar*, uchar*);
void  (*flushroutes)(Ipifc *ifc);

/* address resolution */
void  (*ares)(Fs*, int, uchar*, uchar*, int, int);  /* resolve */
void  (*areg)(Ipifc*, uchar*);      /* register */

/* v6 address generation */
void  (*pref2addr)(uchar *pref, uchar *ea);
@

%\subsection{Ethernet medium}

%\subsection{Null medium}


\section{[[/net]] filesystem}


\subsection{[[Fs]]}
% rename? Slashnetfs?
% file system. For /net/ essentially

<<struct Fs (kernel)>>=
/*
 *  one per IP protocol stack
 */
struct Fs
{
  // array<option<ref_own<Proto>>>, size is Fs.np
  Proto*  p[Maxproto+1];    /* list of supported protocols */
  int np;

  IP  *ip;

  <<[[Fs(kernel)]] arp fields>>
  <<[[Fs(kernel)]] routing fields>>
  <<[[Fs(kernel)]] ndb fields>>
  <<[[Fs(kernel)]] logging fields>>
  <<[[Fs(kernel)]] ipv6 fields>>
  <<[[Fs(kernel)]] other fields>>
 
  // Extra
  RWlock;
  <<[[Fs(kernel)]] extra fields>>
};
@
% >> >> >>
% why +1? because don't use first entry? because QID trick?

%TODO: where is the info about ipifc? about the medium?

<<constant Maxproto>>=
Maxproto= 20,
@


%XXX
<<[[Fs(kernel)]] routing fields>>=
Route *v4root[1<<Lroot];  /* v4 routing forest */
Route *queue;     /* used as temp when reinjecting routes */
@
% >> >> 


%XXX
<<[[Fs(kernel)]] other fields>>=
Proto*  ipmux;      /* kludge for finding an ip multiplexor */
@




\subsection{[[ipfs]]}

<<global ipfs>>=
Fs  *ipfs[Nfs]; /* attached fs's */
@

<<constant Nfs>>=
Nfs=        128,
@
% Nb filesystem (not network file system)
% in practice will have only one IP stack/fs, so Fs.dev will be 0
% (so not sure you need such a big number ...)

<<[[Fs(kernel)]] extra fields>>=
int dev; // idx in ipfs
@

<<global fslock>>=
QLock   fslock;
@
% to access ipfs?

\subsection{[[IP]]}

%todo: rename, bad name
<<struct IP (kernel)>>=
/* an instance of IP */
struct IP
{
  Fragment4*  flisthead4;
  Fragment4*  fragfree4;

  <<[[IP(kernel)]] stat fields>>
  <<[[IP(kernel)]] routing fields>>

  <<[[IP(kernel)]] ipv6 fields>>

  // Extra
  QLock   fraglock4;
  Ref   id4;
};
@

<<struct Fragment4>>=
struct Fragment4
{
  Block*  blist;

  ulong   src;
  ulong   dst;
  ushort  id;
  ulong   age;

  // Extra
  Fragment4*  next;
};
@
% ulong for src and dst?

%XXX
<<[[IP(kernel)]] routing fields>>=
bool iprouting;  /* true if we route like a gateway */
@

%XXX
<<[[IP(kernel)]] stat fields>>=
uvlong    stats[Nipstats];
@


\subsection{[[Proto]]cols}

% /net/<proto>/

<<struct Proto (kernel)>>=
/*
 *  one per multiplexed protocol
 */
struct Proto
{
  char*   name;   /* protocol name */

  <<[[Proto(kernel)]] methods>>

  // growing_array<option<ref_own<Proto>>>, size = Proto.nc
  Conv    **conv;   /* array of conversations */
  int   nc;   /* number of conversations */
  int   ac; // number of opened conversations

  <<[[Proto(kernel)]] priv fields>>
  <<[[Proto(kernel)]] other fields>>

  // Extra
  QLock;
  <<[[Proto(kernel)]] extra fields>>
};
@



<<[[Proto(kernel)]] extra fields>>=
// ref<Fs>, reverse of Fs.p[this.x]
Fs    *f;   /* file system this proto is part of */
// index in Fs.p[]
int   x;    /* protocol index */
@
% (x is useful when building qid)
% so get access to its ip stack via f so can access the method of the
% ip stack and medium!


% Actually  /net/ipifc/ will be a protocol itself! with a clone
% and then with a conversation. Very general scheme.

<<[[Proto(kernel)]] other fields>>=
Qid   qid;    /* qid for protocol directory */
@
% need that?


<<[[Proto(kernel)]] priv fields>>=
void    *priv;
@



<<[[Proto(kernel)]] methods>>=
<<[[Proto(kernel)]] protocol methods>>
<<[[Proto(kernel)]] conversation ctl methods>>
<<[[Proto(kernel)]] conversation inspection methods>>
<<[[Proto(kernel)]] conversation methods>>
@


% sysopen(/net/<proto>/clone) -> ... -> ipopen -> Fsprotoclone -> <>
<<[[Proto(kernel)]] protocol methods>>=
void    (*create)(Conv*);
@
% take the conversation created, so can adjust its structure.
% kinda of a ctor


%syswrite("bind ...", /net/<proto>/<conv>/ctl) -> ... -> ipwrite -> ... -> <>
<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*bind)(Conv*, char**, int);
@
%less: method only for ipifc?


<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*connect)(Conv*, char**, int);
char*   (*announce)(Conv*, char**, int);
@

<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*ctl)(Conv*, char**, int);
@
% if protocol specific ctl message, call this general handler,
% e.g. when do 'add ...' for /net/ipifc/x/ctl


%XXX
<<[[Proto(kernel)]] conversation methods>>=
void    (*close)(Conv*);
void    (*rcv)(Proto*, Ipifc*, Block*);
void    (*advise)(Proto*, Block*, char*);
int   (*inuse)(Conv*);
@
%XXX

%XXX
<<[[Proto(kernel)]] other fields>>=
ushort    nextrport;
@

\subsection{[[Conv]]ersations}

% /net/<proto>/<conv>/

% A bit like a Channel (accessed indirectly via Chan->dev)
<<struct Conv (kernel)>>=
/*
 *  one per conversation directory
 */
struct Conv
{

  uchar laddr[IPaddrlen]; /* local IP address */
  uchar raddr[IPaddrlen]; /* remote IP address */

  ushort  lport;      /* local port number */
  ushort  rport;      /* remote port number */

  uchar ipversion;

  char  *owner;     /* protections */
  int perm;

  // enum<state>
  int state;

  <<[[Conv(kernel)]] queue fields>>
  <<[[Conv(kernel)]] routing fields>>
  <<[[Conv(kernel)]] multicast fields>>
  <<[[Conv(kernel)]] snoop fields>>
  <<[[Conv(kernel)]] priv fields>>
  <<[[Conv(kernel)]] other fields>>

  // Extra
  QLock;
  <<[[Conv(kernel)]] extra fields>>
};
@
% ip + port = is enough to establish a connexion
% need ip + port in general
% ipA!portA <-> ipB!portB

% but actually Conv is general and (ab)used also for ipifc.
% It's an overlay over channel with network related information.


<<[[Conv(kernel)]] extra fields>>=
// ref<Proto> reverse of Proto.conv[this.x]
Proto*  p;
// index in Proto.conv[]
int x;      /* conversation index */
@
% (x is useful when building qid)
% so can get "class" via p so can access the method of the protocol from
% a Conv



<<enum _anon_ (kernel/network/ip/ip.h)2>>=
enum state
{
  Idle=   0,

  Announcing= 1,
  Announced=  2,

  Connecting= 3,
  Connected=  4,
};
@


<<[[Conv(kernel)]] queue fields>>=
Queue*  eq;     /* returned error packets */
@
% setup in Fsprotoclone generically

<<[[Conv(kernel)]] queue fields>>=
Queue*  rq;     /* queued data waiting to be read */
Queue*  wq;     /* queued data waiting to be written */
@
% setup in each create() method of each Proto


<<[[Proto(kernel)]] priv fields>>=
int   ptclsize; /* size of per protocol ctl block */
@
<<[[Conv(kernel)]] priv fields>>=
void* ptcl;     /* protocol specific stuff */
@
% e.g. Ipifc ! when have a conversation with /net/ipifc/x/ctl






<<[[Conv(kernel)]] other fields>>=
int inuse;      /* opens of listen/data/ctl */
@
% set to 1 in clone, incremented after each additional open




%XXX
<<[[Conv(kernel)]] routing fields>>=
Route *r;     /* last route used */
ulong rgen;     /* routetable generation for *r */
@

%XXX
<<[[Conv(kernel)]] other fields>>=
uint  ttl;      /* max time to live */
uint  tos;      /* type of service */
@

%XXX
<<[[Conv(kernel)]] other fields>>=
int length;
@
%XXX
<<[[Conv(kernel)]] other fields>>=
bool restricted;   /* remote port is restricted */
bool ignoreadvice;   /* don't terminate connection on icmp errors */

int maxfragsize;    /* If set, used for fragmentation */

/* udp specific */
int headers;    /* data src/dst headers in udp */
int reliable;   /* true if reliable udp */

Conv* incall;     /* calls waiting to be listened for */
Conv* next;

QLock car;
Rendez  cr;
char  cerr[ERRMAX];

QLock listenq;
Rendez  listenr;
@



\subsection{Chan Qid, [[PROTO()]], [[CONV()], [[QID()]]]}

% In the end everything is a file in plan9, so connexion/sockets
% will be channel with a qid in /net/.
% Have a qid scheme to encode the type of channel.

<<enum qid (kernel/network/ip/devip.c)>>=
enum
{
    Qtopdir=    1,      /* top level directory */

    Qtopbase,
    Qarp=       Qtopbase,
    Qiproute,
    <<[[Qid]] toplevel extra cases>>

    Qprotodir,          /* directory for a protocol */
    Qprotobase,
    Qclone=     Qprotobase,
    <<[[Qid]] protocol extra cases>>

    Qconvdir,           /* directory for a conversation */
    Qconvbase,
    Qctl=       Qconvbase,
    Qdata,
    <<[[Qid]] conversation extra cases>>
};
@

%FIGURE: qid with different bits for different parts
% 5 bits for type, 12 bits for conversation, 8 bits for proto
% => 25 bits

%many of those chans will really behave like a socket.


<<enum misc (kernel/network/ip/devip.c)>>=
enum
{
    Logtype=    5,
    Masktype=   (1<<Logtype)-1,

    Logconv=    12,
    Maskconv=   (1<<Logconv)-1,
    Shiftconv=  Logtype,

    Logproto=   8,
    Maskproto=  (1<<Logproto)-1,
    Shiftproto= Logtype + Logconv,

    <<constant Nfs>>
};
@
% >> >> >> >>


% given a channel qid we can quickly identify its "property" that
% is where it comes from. For instance the channel qid of /net/tcp/0/...
% will be a certain integer and we can access to its protocol with
% PROTO() and its conversation with CONV(), and final "type" with TYPE

% ctor
<<macro QID>>=
#define QID(p, cv, y)    ( ((p)<<(Shiftproto)) | ((cv)<<Shiftconv) | (y) )
@
% >> >>

% in ip3gen()
%    cv = ipfs[c->dev]->p[PROTO(c->qid)]->conv[CONV(c->qid)];

% with Chan.dev        => access Fs     (ipfs[c->dev])
% with PROTO(Chan.qid) => access Proto  (...) 
% with CONV(Chan.qid)  => Access Conv   (...)



% getters
<<macro PROTO>>=
#define PROTO(x)    ( (((ulong)(x).path) >> Shiftproto) & Maskproto )
@
% /net/x (tcp, udp, etc)
<<macro CONV>>=
#define CONV(x)     ( (((ulong)(x).path) >> Shiftconv) & Maskconv )
@
% /net/.../x

<<macro TYPE>>=
#define TYPE(x)     ( ((ulong)(x).path) & Masktype )
@
% /net/.../.../x (ctl, data, etc)

% in ipattach()
%    mkqid(&c->qid, QID(0, 0, Qtopdir), 0, QTDIR);
% so means entries 0 are not used in Proto and Conv?



%XXX
<<[[Qid]] conversation extra cases>>=
Qerr,
Qlisten,
@





\section{[[/net/ether]] filesystem}

\subsection{[[Netfile]]}

<<struct Netfile>>=
/*
 *  one per multiplexed connection
 */
struct Netfile
{
  QLock;

  int inuse;
  ulong mode;
  char  owner[KNAMELEN];

  int type;     /* multiplexor type */
  int prom;     /* promiscuous mode */
  int scan;     /* base station scanning interval */
  int bridge;     /* bridge mode */
  int headersonly;    /* headers only - no data */
  uchar maddr[8];   /* bitmask of multicast addresses requested */
  int nmaddr;     /* number of multicast addresses */

  Queue *in;      /* input buffer */
};
@

\subsection{[[Netif]]}

<<struct Netif (kernel)>>=
/*
 *  a network interface
 */
struct Netif
{
  QLock;

  /* multiplexing */
  char  name[KNAMELEN];   /* for top level directory */
  int nfile;      /* max number of Netfiles */

  Netfile **f;

  /* about net */
  int limit;      /* flow control */
  int alen;     /* address length */
  int mbps;     /* megabits per sec */
  int link;     /* link status */
  int minmtu;
  int   maxmtu;
  int mtu;
  uchar addr[Nmaxaddr];
  uchar bcast[Nmaxaddr];


  int prom;     /* number of promiscuous opens */
  int scan;     /* number of base station scanners */
  int all;      /* number of -1 multiplexors */

  /* statistics */
  int misses;
  uvlong  inpackets;
  uvlong  outpackets;
  int crcs;   /* input crc errors */
  int oerrs;    /* output errors */
  int frames;   /* framing errors */
  int overflows;  /* packet overflows */
  int buffs;    /* buffering errors */
  int soverflows; /* software overflow */

  /* routines for touching the hardware */
  void  *arg;

  void  (*promiscuous)(void*, int);
  int (*hwmtu)(void*, int); /* get/set mtu */
  void  (*scanbs)(void*, uint); /* scan for base stations */

  <<[[Netif(kernel)]] multicast fields>>
  <<[[Netif(kernel)]] multicast methods>>
};
@







\chapter{Initialization}

\section{Kernel side}

\subsection{Mounting the ip device}

% see kernel init
% bind #I /net
%  bind_safe("#I", "/net", MREPL); // devip

% (not /dev)
% => /net/... especially /net/ipifc/, /net/arp, /net/iproute

% ??? sysbind?? -> <> (as attach <- ipdevtab.attach <- toplevel)
<<function ipattach>>=
static Chan*
ipattach(char* spec)
{
    Chan *c;
    int dev;

    dev = atoi(spec);
    if(dev >= Nfs)
        error("bad specification");

    // initialize ip stack
    ipgetfs(dev);

    c = devattach('I', spec);
    mkqid(&c->qid, QID(0, 0, Qtopdir), 0, QTDIR);
    c->dev = dev;
    c->aux = newipaux(up->user, "none");

    return c;
}
@
% spec? can have multiple network stack?

% will allocate a Fs, will allocate IP fragments,
% will initialize arp, protocols, and then return
% a channel handle that one can use to access Fs services.

% remember 
% - c->aux = private data stored in the channel.
% - c->dev = extra index information

<<function ipgetfs>>=
static Fs*
ipgetfs(int dev)
{
    extern void (*ipprotoinit[])(Fs*);
    Fs *f;
    int i;

    if(dev >= Nfs)
        return nil;

    qlock(&fslock);
    if(ipfs[dev] == nil){
        f = smalloc(sizeof(Fs));

        ip_init(f);
        arpinit(f);
        netloginit(f);
        for(i = 0; ipprotoinit[i]; i++)
            ipprotoinit[i](f);

        f->dev = dev;
        ipfs[dev] = f;
    }
    qunlock(&fslock);

    return ipfs[dev];
}
@

<<struct IPaux>>=
/*
 *  Hanging off every ip channel's ->aux is the following structure.
 *  It maintains the state used by devip and iproute.
 */
struct IPaux
{
  char  *owner;   /* the user that did the attach */
  char  tag[4];
};
@
%todo: tag?? "none" at the beginning?
%less: why put that in the channel? why not in the conv? because need
% faster access?

<<macro ATTACHER>>=
#define ATTACHER(c) (((IPaux*)((c)->aux))->owner)
@
% c is a chan

% ipattach -> <>
<<function newipaux>>=
IPaux*
newipaux(char *owner, char *tag)
{
    IPaux *a;
    int n;

    a = smalloc(sizeof(IPaux));

    kstrdup(&a->owner, owner);
    memset(a->tag, ' ', sizeof(a->tag));
    n = strlen(tag);
    if(n > sizeof(a->tag))
        n = sizeof(a->tag);
    memmove(a->tag, tag, n);

    return a;
}
@

\subsubsection{[[ip_init()]]}

% ipattach -> ipgetfs -> <>
<<function ip_init>>=
void
ip_init(Fs *f)
{
    IP *ip;

    ip = smalloc(sizeof(IP));
    initfrag(ip, 100);
    f->ip = ip;

    <<[[ip_init()]] ipv6 init>>
}
@

<<function initfrag>>=
void
initfrag(IP *ip, int size)
{
    Fragment4 *fq4, *eq4;
    <<[[initfrag()]] locals>>

    ip->fragfree4 = (Fragment4*)malloc(sizeof(Fragment4) * size);
    if(ip->fragfree4 == nil)
        panic("initfrag");

    eq4 = &ip->fragfree4[size];
    for(fq4 = ip->fragfree4; fq4 < eq4; fq4++)
        fq4->next = fq4+1;

    ip->fragfree4[size-1].next = nil;

    <<[[initfrag()]] ipv6 init fragfree6>>
}
@
% 100 packets
%less: boilerplate, classic list of used/free things

\subsubsection{[[arpinit()]]}
% will see later

\subsubsection{[[netloginit()]]}
% see in appendix

\subsubsection{[[ipprotoinit()]]}
% each specifics

% in qemu.c because of qemu.conf:
%void (*ipprotoinit[])(Fs*) = {
%	tcpinit,
%	udpinit,
%	ipifcinit,
%	icmpinit,
%	icmp6init,
%	ilinit,
%	nil,
%};


\subsection{Mounting the ethernet device}

% see kernel init
% bind #l -a /net
%  bind_safe("#l0", "/net", MAFTER); // ether (and dev 0)

% => /net/ether0
% => /net/ether0/addr to get MAC address

% actually populated with many things already, 0/, 1/, 2/ with
% different x/type values

% /net/ether0/stats  give you also your mac address at the very end

% ??? sysbind?? -> <> (as attach <- etherdevtab?.attach <- toplevel)
<<function etherattach>>=
Chan*
etherattach(char* spec)
{
    ulong ctlrno;
    char *p;
    Chan *chan;

    ctlrno = 0;
    if(spec && *spec){
        ctlrno = strtoul(spec, &p, 0);
        if((ctlrno == 0 && p == spec) || *p || (ctlrno >= MaxEther))
            error(Ebadarg);
    }
    if(etherxx[ctlrno] == nil)
        error(Enodev);

    chan = devattach('l', spec);
    if(waserror()){
        chanfree(chan);
        nexterror();
    }
    chan->dev = ctlrno;
    if(etherxx[ctlrno]->attach)
        etherxx[ctlrno]->attach(etherxx[ctlrno]);
    poperror();
    return chan;
}
@
% #l0 => spec = 0

\section{User side}

\subsection{Connect manually}

% open /net/<protocol>/clone

\subsection{[[dial()]]}

% dial uses connection server which introduces extra complexity







\chapter{User/Kernel Bridge}

% Will see how dispatch commands from user to kernel, via /net,
% and how the kernel then dispatch internally the command to the right
% protocol, to the right method, to the right medium.

\section{IP device}

<<global ipdevtab>>=
Dev ipdevtab = {
    .dc       =    'I',
    .name     =    "ip",

    .attach   =    ipattach,
    .walk     =    ipwalk,
    .open     =    ipopen,
    .close    =    ipclose,
    .read     =    ipread,
    .write    =    ipwrite,
    .stat     =    ipstat,
    .wstat    =    ipwstat,
               
    .reset    =    ipreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .create   =    ipcreate,
    .bread    =    ipbread,
    .bwrite   =    ipbwrite,
    .remove   =    ipremove,
};
@

\subsection{[[/net]] hierarchy and [[ipwalk()]]}}

<<function ipwalk>>=
static Walkqid*
ipwalk(Chan* c, Chan *nc, char **name, int nname)
{
    IPaux *a = c->aux;
    Walkqid* w;

    w = devwalk(c, nc, name, nname, nil, 0, ipgen);

    if(w != nil && w->clone != nil)
        w->clone->aux = newipaux(a->owner, a->tag);

    return w;
}
@
% first chan created in ipattach will have a correct aux.
% ipwalk =~ readdir

% Walkqid =~ Dirtab? so will call ipgen to fill entries
% in Dirtab.

% ipwalk -> devwalk <- <> (as xx <- ipwalk)
<<function ipgen>>=
static int
ipgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    Fs *f;
    Qid q;
    Conv *cv;

    f = ipfs[c->dev];

    switch(TYPE(c->qid)) {
    <<[[ipgen()]] switch TYPE qid cases>>
    }
    return -1;
}
@
% -1 means no more entries?

% ipgen means generate Dir entries or property for this qid.


\subsubsection{[[/net/]]}

% remember s is an integer to get the xth entry in the directory, 
% or -1  (DEVDOTDOT). How knows when to stop? what is the max value
% of s? see above, -1!
<<[[ipgen()]] switch TYPE qid cases>>=
case Qtopdir:
    if(s == DEVDOTDOT){
        mkqid(&q, QID(0, 0, Qtopdir), 0, QTDIR);
        snprint(up->genbuf, sizeof up->genbuf, "#I%lud", c->dev);
        devdir(c, q, up->genbuf, 0, network, 0555, dp);
        return 1;
    }
    if(s < f->np) {
        if(f->p[s]->connect == nil)
            return 0;   /* protocol with no user interface */
        mkqid(&q, QID(s, 0, Qprotodir), 0, QTDIR);
        devdir(c, q, f->p[s]->name, 0, network, 0555, dp);
        return 1;
    }
    s -= f->np;
    return ip1gen(c, s+Qtopbase, dp);
@
% first topdir, then protodir, then regular file in topdir

<<global network>>=
static char network[] = "network";
@
% for owner?


\subsubsection{[[/net/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qarp:
case Qlog:
case Qiproute:
case Qipselftab:
case Qbootp:
case Qndb:
    return ip1gen(c, TYPE(c->qid), dp);
@

<<function ip1gen>>=
static int
ip1gen(Chan *c, int i, Dir *dp)
{
    Qid q;
    char *p;
    int prot;
    int len = 0;
    Fs *f;
    extern ulong    kerndate;

    f = ipfs[c->dev];

    prot = 0666;
    mkqid(&q, QID(0, 0, i), 0, QTFILE);
    switch(i) {
    <<[[ip1gen()]] switch TYPE qid cases>>
    default:
        return -1;
    }
    devdir(c, q, p, len, network, prot, dp);
    <<[[ipgen()]] if Qndb, adjust mtime>>
    return 1;
}
@





\subsubsection{[[/net/proto/]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qprotodir:
    if(s == DEVDOTDOT){
        mkqid(&q, QID(0, 0, Qtopdir), 0, QTDIR);
        snprint(up->genbuf, sizeof up->genbuf, "#I%lud", c->dev);
        devdir(c, q, up->genbuf, 0, network, 0555, dp);
        return 1;
    }
    if(s < f->p[PROTO(c->qid)]->ac) {
        cv = f->p[PROTO(c->qid)]->conv[s];
        snprint(up->genbuf, sizeof up->genbuf, "%d", s);
        mkqid(&q, QID(PROTO(c->qid), s, Qconvdir), 0, QTDIR);
        devdir(c, q, up->genbuf, 0, cv->owner, 0555, dp);
        return 1;
    }
    s -= f->p[PROTO(c->qid)]->ac;
    return ip2gen(c, s+Qprotobase, dp);
@
% conversation number is stable?? if open 2, close first, then
% will get a hole? the directory seems very dynamic, so if you didn't
% open a connexion with a previous conv number, you will get something
% different?


\subsubsection{[[/net/proto/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qclone:
case Qstats:
    return ip2gen(c, TYPE(c->qid), dp);
@

<<function ip2gen>>=
static int
ip2gen(Chan *c, int i, Dir *dp)
{
    Qid q;

    switch(i) {
    case Qclone:
        mkqid(&q, QID(PROTO(c->qid), 0, Qclone), 0, QTFILE);
        devdir(c, q, "clone", 0, network, 0666, dp);
        return 1;
    case Qstats:
        mkqid(&q, QID(PROTO(c->qid), 0, Qstats), 0, QTFILE);
        devdir(c, q, "stats", 0, network, 0444, dp);
        return 1;
    }
    return -1;
}
@

\subsubsection{[[/net/proto/conv/]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qconvdir:
    if(s == DEVDOTDOT){
        s = PROTO(c->qid);
        mkqid(&q, QID(s, 0, Qprotodir), 0, QTDIR);
        devdir(c, q, f->p[s]->name, 0, network, 0555, dp);
        return 1;
    }
    return ip3gen(c, s+Qconvbase, dp);
@


\subsubsection{[[/net/proto/conv/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
case Qlisten:
case Qlocal:
case Qremote:
case Qstatus:
case Qsnoop:
    return ip3gen(c, TYPE(c->qid), dp);
@

<<function ip3gen>>=
static int
ip3gen(Chan *c, int i, Dir *dp)
{
    Qid q;
    Conv *cv;
    char *p;

    cv = ipfs[c->dev]->p[PROTO(c->qid)]->conv[CONV(c->qid)];

    if(cv->owner == nil)
        kstrdup(&cv->owner, eve);

    mkqid(&q, QID(PROTO(c->qid), CONV(c->qid), i), 0, QTFILE);

    switch(i) {
    <<[[ip3gen()]] switch TYPE qid cases>>
    default:
        return -1;
    }
    devdir(c, q, p, 0, cv->owner, 0444, dp);
    return 1;
}
@

<<[[ip3gen()]] switch TYPE qid cases>>=
case Qctl:
    devdir(c, q, "ctl", 0, cv->owner, cv->perm, dp);
    return 1;
case Qdata:
    devdir(c, q, "data", qlen(cv->rq), cv->owner, cv->perm, dp);
    return 1;
@



%XXX
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qerr:
    devdir(c, q, "err", qlen(cv->eq), cv->owner, cv->perm, dp);
    return 1;
@
%XXX
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qlisten:
    devdir(c, q, "listen", 0, cv->owner, cv->perm, dp);
    return 1;
@


\subsection{Dispatch functions, [[ipxxx()]]}

\subsubsection{[[ipopen()]]}

<<global m2p>>=
static int m2p[] = {
    [OREAD]     4,
    [OWRITE]    2,
    [ORDWR]     6
};
@

<<function ipopen>>=
static Chan*
ipopen(Chan* c, int omode)
{
    Fs *f;
    int perm;
    Proto *p;
    Conv *cv, *nc;

    perm = m2p[omode&3];

    f = ipfs[c->dev];

    switch(TYPE(c->qid)) {
    <<[[ipopen()]] switch TYPE qid cases>>
    default:
        break;
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    return c;
}
@


<<[[ipopen()]] switch TYPE qid cases>>=
case Qtopdir:
case Qprotodir:
case Qconvdir:

case Qbootp:
case Qipselftab:

case Qstatus:
case Qremote:
case Qlocal:
case Qstats:
    if(omode != OREAD)
        error(Eperm);
    break;
@




% lots of noise, but mostly check perm and increment inuse
<<[[ipopen()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
    p = f->p[PROTO(c->qid)];
    qlock(p);
    cv = p->conv[CONV(c->qid)];
    qlock(cv);
    if(waserror()) {
        qunlock(cv);
        qunlock(p);
        nexterror();
    }
    if((perm & (cv->perm>>6)) != perm) {
        if(strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if((perm & cv->perm) != perm)
            error(Eperm);

    }
    cv->inuse++;
    if(cv->inuse == 1){
        kstrdup(&cv->owner, ATTACHER(c));
        cv->perm = 0660;
    }
    qunlock(cv);
    qunlock(p);
    poperror();
    break;
@




%XXX
<<[[ipopen()]] switch TYPE qid cases>>=
case Qlisten:
    cv = f->p[PROTO(c->qid)]->conv[CONV(c->qid)];
    if((perm & (cv->perm>>6)) != perm) {
        if(strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if((perm & cv->perm) != perm)
            error(Eperm);

    }

    if(cv->state != Announced)
        error("not announced");

    if(waserror()){
        closeconv(cv);
        nexterror();
    }
    qlock(cv);
    cv->inuse++;
    qunlock(cv);

    nc = nil;
    while(nc == nil) {
        /* give up if we got a hangup */
        if(qisclosed(cv->rq))
            error("listen hungup");

        qlock(&cv->listenq);
        if(waserror()) {
            qunlock(&cv->listenq);
            nexterror();
        }

        /* wait for a connect */
        sleep(&cv->listenr, incoming, cv);

        qlock(cv);
        nc = cv->incall;
        if(nc != nil){
            cv->incall = nc->next;
            mkqid(&c->qid, QID(PROTO(c->qid), nc->x, Qctl), 0, QTFILE);
            kstrdup(&cv->owner, ATTACHER(c));
        }
        qunlock(cv);

        qunlock(&cv->listenq);
        poperror();
    }
    closeconv(cv);
    poperror();
    break;
@

\subsubsection{[[ipclose()]]}

<<function ipclose>>=
static void
ipclose(Chan* c)
{
    Fs *f;

    f = ipfs[c->dev];
    switch(TYPE(c->qid)) {
    <<[[ipclose()]] switch TYPE qid cases>>
    default:
        break;
    }
    free(((IPaux*)c->aux)->owner);
    free(c->aux);
}
@

<<[[ipclose()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
    if(c->flag & COPEN)
        closeconv(f->p[PROTO(c->qid)]->conv[CONV(c->qid)]);
    break;
@


<<function closeconv>>=
void
closeconv(Conv *cv)
{
    Conv *nc;
    Ipmulti *mp;

    qlock(cv);

    if(--cv->inuse > 0) {
        qunlock(cv);
        return;
    }

    /* close all incoming calls since no listen will ever happen */
    for(nc = cv->incall; nc; nc = cv->incall){
        cv->incall = nc->next;
        closeconv(nc);
    }
    cv->incall = nil;

    kstrdup(&cv->owner, network);
    cv->perm = 0660;

    while((mp = cv->multi) != nil)
        ipifcremmulti(cv, mp->ma, mp->ia);

    cv->r = nil;
    cv->rgen = 0;
    cv->p->close(cv);
    cv->state = Idle;
    qunlock(cv);
}
@


\subsubsection{[[ipread()]]}

<<function ipread>>=
static long
ipread(Chan *ch, void *a, long n, vlong off)
{
    Fs *f;
    Proto *x;
    Conv *cv;
    char *buf, *p;
    long rv;
    ulong offset = off;

    f = ipfs[ch->dev];

    p = a;
    switch(TYPE(ch->qid)) {
    <<[[ipread()]] switch TYPE qid cases>>
    default:
        error(Eperm);

    }
}
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qtopdir:
case Qprotodir:
case Qconvdir:
    return devdirread(ch, a, n, 0, 0, ipgen);
@




%XXX
<<[[ipread()]] switch TYPE qid cases>>=
case Qerr:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->eq, a, n);
@


\subsubsection{[[ipwrite()]]}


<<function ipwrite>>=
static long
ipwrite(Chan* ch, void *v, long n, vlong off)
{
    Conv *cv;
    Proto *x;
    char *p;
    Cmdbuf *cb;
    uchar ia[IPaddrlen], ma[IPaddrlen];
    Fs *f;
    char *a;
    ulong offset = off;

    a = v;
    f = ipfs[ch->dev];

    switch(TYPE(ch->qid)){
    <<[[ipwrite()]] switch TYPE qid cases>>
    default:
        error(Eperm);
    }
    return n;
}
@



\subsection{[[/net/x/clone]]}

<<[[ipopen()]] switch TYPE qid cases>>=
case Qclone:
    p = f->p[PROTO(c->qid)];

    qlock(p);
    if(waserror()){
        qunlock(p);
        nexterror();
    }

    cv = Fsprotoclone(p, ATTACHER(c));

    qunlock(p);
    poperror();
    if(cv == nil) {
        error(Enodev);
        break;
    }
    mkqid(&c->qid, QID(p->x, cv->x, Qctl), 0, QTFILE);
    break;
@
% Qctl !! redirect to Qctl of newly created /net/<proto>/<conv>/ dir
% with a newly conversation created in Fs->p[x]->conv[x] with
% the queue created

%TODO: LP split, EASY
<<function Fsprotoclone>>=
/*
 *  called with protocol locked
 */
Conv*
Fsprotoclone(Proto *p, char *user)
{
    Conv *cv, **pp, **ep;

retry:
    cv = nil;
    ep = &p->conv[p->nc];
    for(pp = p->conv; pp < ep; pp++) {
        cv = *pp;
        if(cv == nil){
            cv = malloc(sizeof(Conv));
            if(cv == nil)
                error(Enomem);
            qlock(cv);
            cv->p = p;
            cv->x = pp - p->conv;
            if(p->ptclsize != 0){
                cv->ptcl = malloc(p->ptclsize);
                if(cv->ptcl == nil) {
                    free(cv);
                    error(Enomem);
                }
            }
            *pp = cv;
            p->ac++;
            cv->eq = qopen(1024, Qmsg, 0, 0);

            // !! Protocol dispatch !!! will create extra queues
            (*p->create)(cv);

            break;
        }
        if(canqlock(cv)){
            /*
             *  make sure both processes and protocol
             *  are done with this Conv
             */
            if(cv->inuse == 0 && (p->inuse == nil || (*p->inuse)(cv) == 0))
                break;

            qunlock(cv);
        }
    }

    if(pp >= ep) {
        if(p->gc)
            print("Fsprotoclone: garbage collecting Convs\n");
        if(p->gc != nil && (*p->gc)(p))
            goto retry;
        /* debugging: do we ever get here? */
        if (cpuserver)
            panic("Fsprotoclone: all conversations in use");
        return nil;
    }

    cv->inuse = 1;
    kstrdup(&cv->owner, user);
    cv->perm = 0660;
    cv->state = Idle;
    ipmove(cv->laddr, IPnoaddr);
    ipmove(cv->raddr, IPnoaddr);
    cv->r = nil;
    cv->rgen = 0;
    cv->lport = 0;
    cv->rport = 0;
    cv->restricted = 0;
    cv->maxfragsize = 0;
    cv->ttl = MAXTTL;
    qreopen(cv->rq);
    qreopen(cv->wq);
    qreopen(cv->eq);

    qunlock(cv);
    return cv;
}
@

\subsubsection{Finding a free entry}

\subsubsection{Garbage collecting}

<<[[Proto(kernel)]] protocol methods>>=
int   (*gc)(Proto*);  /* returns true if any conversations are freed */
@

\subsection{[[/net/x/y/ctl]]}

<<[[ipread()]] switch TYPE qid cases>>=
case Qctl:
    buf = smalloc(16);
    snprint(buf, 16, "%lud", CONV(ch->qid));
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@
% that's how you get your /x/


<<[[ipwrite()]] switch TYPE qid cases>>=
case Qctl:
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    cb = parsecmd(a, n);

    qlock(cv);
    if(waserror()) {
        qunlock(cv);
        free(cb);
        nexterror();
    }
    if(cb->nf < 1)
        error("short control request");

    if(strcmp(cb->f[0], "connect") == 0)
        connectctlmsg(x, cv, cb);
    else if(strcmp(cb->f[0], "announce") == 0)
        announcectlmsg(x, cv, cb);

    else if(strcmp(cb->f[0], "bind") == 0)
        bindctlmsg(x, cv, cb);

    else if(strcmp(cb->f[0], "ttl") == 0)
        ttlctlmsg(cv, cb);
    else if(strcmp(cb->f[0], "tos") == 0)
        tosctlmsg(cv, cb);
    else if(strcmp(cb->f[0], "ignoreadvice") == 0)
        cv->ignoreadvice = true;
    else if(strcmp(cb->f[0], "addmulti") == 0){
        if(cb->nf < 2)
            error("addmulti needs interface address");
        if(cb->nf == 2){
            if(!ipismulticast(cv->raddr))
                error("addmulti for a non multicast address");
            if (parseip(ia, cb->f[1]) == -1)
                error(Ebadip);
            ipifcaddmulti(cv, cv->raddr, ia);
        } else {
            if (parseip(ia, cb->f[1]) == -1 ||
                parseip(ma, cb->f[2]) == -1)
                error(Ebadip);
            if(!ipismulticast(ma))
                error("addmulti for a non multicast address");
            ipifcaddmulti(cv, ma, ia);
        }
    } else if(strcmp(cb->f[0], "remmulti") == 0){
        if(cb->nf < 2)
            error("remmulti needs interface address");
        if(!ipismulticast(cv->raddr))
            error("remmulti for a non multicast address");
        if (parseip(ia, cb->f[1]) == -1)
            error(Ebadip);
        ipifcremmulti(cv, cv->raddr, ia);
    } else if(strcmp(cb->f[0], "maxfragsize") == 0){
        if(cb->nf < 2)
            error("maxfragsize needs size");

        cv->maxfragsize = (int)strtol(cb->f[1], nil, 0);

    } 
    else if(x->ctl != nil) {
        // Protocol dispatch
        p = x->ctl(cv, cb->f, cb->nf);
        if(p != nil)
            error(p);
    } else
        error("unknown control request");
    qunlock(cv);
    free(cb);
    poperror();
    break;
@

\subsubsection{Bind}

% ipwrite (Qctl case) -> <>
<<function bindctlmsg>>=
static void
bindctlmsg(Proto *x, Conv *cv, Cmdbuf *cb)
{
    char *p;

    if(x->bind == nil)
        p = Fsstdbind(cv, cb->f, cb->nf);
    else
        // Protocol dispatch
        p = x->bind(cv, cb->f, cb->nf);
    if(p != nil)
        error(p);
}
@

% default method
<<function Fsstdbind>>=
/*
 *  called by protocol bind routine to set addresses
 */
char*
Fsstdbind(Conv* cv, char* argv[], int argc)
{
    switch(argc){
    default:
        break;
    case 2:
        return setladdrport(cv, argv[1], 0);
    }
    return "bad args to bind";
}
@

\subsubsection{Connect}

<<function connectctlmsg>>=
static void
connectctlmsg(Proto *x, Conv *c, Cmdbuf *cb)
{
    char *p;

    if(c->state != Idle)
        error(Econinuse);

    c->state = Connecting;
    c->cerr[0] = '\0';

    if(x->connect == nil)
        error("connect not supported");
    // Protocol dispatch
    p = x->connect(c, cb->f, cb->nf);

    if(p != nil)
        error(p);

    qunlock(c);
    if(waserror()){
        qlock(c);
        nexterror();
    }
    sleep(&c->cr, connected, c);
    qlock(c);
    poperror();

    if(c->cerr[0] != '\0')
        error(c->cerr);
}
@

% lots of those connect method will then call Fssconnect and Fssconnected

% udpconnect | ... -> <>
<<function Fsstdconnect>>=
/*
 *  called by protocol connect routine to set addresses
 */
char*
Fsstdconnect(Conv *c, char *argv[], int argc)
{
    char *p;

    switch(argc) {
    default:
        return "bad args to connect";
    case 2:
        p = setraddrport(c, argv[1]);
        if(p != nil)
            return p;
        setladdr(c);
        p = setlport(c);
        if (p != nil)
            return p;
        break;
    case 3:
        p = setraddrport(c, argv[1]);
        if(p != nil)
            return p;
        p = setladdrport(c, argv[2], 0);
        if(p != nil)
            return p;
    }

    if( (memcmp(c->raddr, v4prefix, IPv4off) == 0 &&
        memcmp(c->laddr, v4prefix, IPv4off) == 0)
        || ipcmp(c->raddr, IPnoaddr) == 0)
        c->ipversion = V4;
    else
        c->ipversion = V6;

    return nil;
}
@


<<function Fsconnected>>=
int
Fsconnected(Conv* c, char* msg)
{
    if(msg != nil && *msg != '\0')
        strncpy(c->cerr, msg, ERRMAX-1);

    switch(c->state){
    case Connecting:
        c->state = Connected;
        break;
    }
    <<[[Fsconnected()]] switch state cases>>

    wakeup(&c->cr);
    return 0;
}
@


\subsubsection{Announce}

<<function announcectlmsg>>=
static void
announcectlmsg(Proto *x, Conv *c, Cmdbuf *cb)
{
    char *p;

    if(c->state != Idle)
        error(Econinuse);

    c->state = Announcing;
    c->cerr[0] = '\0';

    if(x->announce == nil)
        error("announce not supported");
    // Protocol dispatch
    p = x->announce(c, cb->f, cb->nf);

    if(p != nil)
        error(p);

    qunlock(c);
    if(waserror()){
        qlock(c);
        nexterror();
    }
    sleep(&c->cr, announced, c);
    qlock(c);
    poperror();

    if(c->cerr[0] != '\0')
        error(c->cerr);
}
@

% lots of those announce method will then call Fsstdannounce and Fsannounced

% udpannounce | ... -> <>
<<function Fsstdannounce>>=
/*
 *  called by protocol announce routine to set addresses
 */
char*
Fsstdannounce(Conv* c, char* argv[], int argc)
{
    memset(c->raddr, 0, sizeof(c->raddr));
    c->rport = 0;
    switch(argc){
    default:
        break;
    case 2:
        return setladdrport(c, argv[1], 1);
    }
    return "bad args to announce";
}
@

<<[[Fsconnected()]] switch state cases>>=
case Announcing:
    c->state = Announced;
    break;
@    


\subsection{[[/net/x/y/data]]}

<<[[ipread()]] switch TYPE qid cases>>=
case Qdata:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->rq, a, n);
@

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qdata:
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];

    if(cv->wq == nil)
        error(Eperm);

    qwrite(cv->wq, a, n);
    break;
@

\subsection{Other files}

\subsubsection{[[/net/x/stats]]}

<<[[Qid]] protocol extra cases>>=
Qstats,
@

<<[[Proto(kernel)]] protocol methods>>=
int   (*stats)(Proto*, char*, int);
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qstats:
    x = f->p[PROTO(ch->qid)];
    if(x->stats == nil)
        error("stats not implemented");
    buf = smalloc(Statelen);

    // Protocol dispatch
    (*x->stats)(x, buf, Statelen);

    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

\subsubsection{[[/net/x/y/status]]}

<<[[Qid]] conversation extra cases>>=
Qstatus,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qstatus:
    p = "status";
    break;
@

<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*state)(Conv*, char*, int);
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qstatus:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];

    // Protocol dispatch
    (*x->state)(cv, buf, Statelen-2);

    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@


\subsubsection{[[/net/x/y/local]], [[/net/x/y/remote]]}

<<[[Qid]] conversation extra cases>>=
Qlocal,
Qremote,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qlocal:
    p = "local";
    break;
case Qremote:
    p = "remote";
    break;
@

<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*local)(Conv*, char*, int);
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qlocal:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    if(x->local == nil) {
        snprint(buf, Statelen, "%I!%d\n", cv->laddr, cv->lport);
    } else {
        // Protocol dispatch
        (*x->local)(cv, buf, Statelen-2);
    }
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@



<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*remote)(Conv*, char*, int);
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qremote:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    if(x->remote == nil) {
        snprint(buf, Statelen, "%I!%d\n", cv->raddr, cv->rport);
    } else {
        // Protocol dispatch
        (*x->remote)(cv, buf, Statelen-2);
    }
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

\section{Ethernet device}


<<global etherdevtab>>=
Dev etherdevtab = {
    .dc       =    'l',
    .name     =    "ether",

    .attach   =    etherattach,
    .walk     =    etherwalk,
    .open     =    etheropen,
    .close    =    etherclose,
    .read     =    etherread,
    .write    =    etherwrite,
    .stat     =    etherstat,
    .wstat    =    etherwstat,
               
    .reset    =    etherreset,
    .init     =    devinit,
    .shutdown =    ethershutdown,
    .create   =    ethercreate,
    .bread    =    etherbread,
    .bwrite   =    etherbwrite,
    .remove   =    devremove,
};
@


\section{Ethernet medium}

% before IP? kinda more low level (but less general)
% called a medium?

% there are other physical device, but we'll focus on this one,
% most common

% physical 48bits address.

<<global ethermedium (kernel)>>=
Medium ethermedium =
{
    .name=      "ether",

    .hsize=     14,
    .mintu=     60,
    .maxtu=     1514,
    .maclen=    6,

    .bind=      etherbind,
    .unbind=    etherunbind,
    .bwrite=    etherbwrite,

    .addmulti=  etheraddmulti,
    .remmulti=  etherremmulti,
    .ares=      arpenter,
    .areg=      sendgarp,
    .pref2addr= etherpref2addr,
};
@
% maxtu = 1500 + 14 for header
% maclen = 6 = 48 bits


<<global etherbroadcast>>=
static uchar etherbroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
@




\section{Streams}

% like bidirectional pipes. Producer/consumer like pipes, but
% bidirectional.






\chapter{Configuration}

\section{[[/net/ipifc/]] protocol}

% use the protocol scheme to configure.
%alt: some special file in /net/ like /net/medium, /net/ip

\subsection{Protocol initialisation}

% ipattach -> ipgetfs -> <> (as ipprotoinit[i] <- ipprotoinit[x] = <> <- qemu.c)
<<function ipifcinit>>=
void
ipifcinit(Fs *f)
{
    Proto *ipifc;

    ipifc = smalloc(sizeof(Proto));

    ipifc->name = "ipifc";
    ipifc->create = ipifccreate;
    ipifc->bind = ipifcbind;
 
    ipifc->connect = ipifcconnect;
    ipifc->announce = nil;
    ipifc->close = ipifcclose;
    ipifc->rcv = nil;
    ipifc->ctl = ipifcctl;
    ipifc->advise = nil;
    ipifc->inuse = ipifcinuse;

    ipifc->local = ipifclocal;
    ipifc->state = ipifcstate;
    ipifc->stats = ipifcstats;

    ipifc->ipproto = -1;

    ipifc->nc = Maxmedia;
    ipifc->ptclsize = sizeof(Ipifc);

    <<[[ipifcinit()]] modify f>>

    Fsproto(f, ipifc);
}
@
%less: make it a global with intializer?
%less: no remote method?
%alt: why not do via global? why smalloc? to not pay memory if don't use
% the network? meh.

%    ipifc->nc = Maxmedia;
% max conversation


<<function Fsproto>>=
int
Fsproto(Fs *f, Proto *p)
{
    if(f->np >= Maxproto)
        return -1;

    p->f = f;

    <<[[Fsproto()]] adjust f->t2p>>

    p->qid.type = QTDIR;
    p->qid.path = QID(f->np, 0, Qprotodir);
    p->conv = malloc(sizeof(Conv*) * (p->nc+1));
    if(p->conv == nil)
        panic("Fsproto");

    p->nextrport = 600;

    p->x = f->np;
    f->p[f->np++] = p;

    return 0;
}
@

<<[[Fsproto()]] adjust f->t2p>>=
if(p->ipproto > 0){
    if(f->t2p[p->ipproto] != nil)
        return -1;
    f->t2p[p->ipproto] = p;
}
@

<<[[Fs(kernel)]] other fields>>=
// map<enum<protocol_type>, ref<Proto>>
Proto*  t2p[256];   /* vector of all protocols */
@
<<[[Proto(kernel)]] other fields>>=
// enum<protocol_type>
int   ipproto;  /* ip protocol type */
@




<<[[ipifcinit()]] modify f>>=
f->ipifc = ipifc;   /* hack for ipifcremroute, findipifc, ... */
@
%XXX
<<[[Fs(kernel)]] other fields>>=
Proto*  ipifc;      /* kludge for ipifcremroute & ipifcaddroute */
@
% hack? or fundamental? but not that it's a Proto, not an Ipifc.


%XXX
<<[[ipifcinit()]] modify f>>=
f->self = smalloc(sizeof(Ipselftab));   /* hack for ipforme */
@
%XXX
<<[[Fs(kernel)]] other fields>>=
Ipselftab *self;
@

\subsection{[[/net/ipifc/clone]]}

%// sysopen(/net/ipifc/clone) -> ... -> ipopen -> Fsprotoclone -> <>
%  (as x->create <- ...)
<<function ipifccreate>>=
/*
 *  called when a new ipifc structure is created
 */
static void
ipifccreate(Conv *cv)
{
    Ipifc *ifc;

    cv->rq = qopen(QMAX, 0, 0, 0);
    cv->sq = qopen(QMAX, 0, 0, 0);
    cv->wq = qopen(QMAX, Qkick, ipifckick, cv);

    ifc = (Ipifc*)cv->ptcl;
    ifc->m = nil;

    ifc->conv = cv;
    ifc->unbinding = 0;
    ifc->reassemble = 0;
}
@
% Ipifc has been smalloc generically by Fsprotoclone()
% no medium yet!


% ip/ipconfig open this file and keeps it open forever

\subsection{Binding medium, [[/net/ipifc/x/ctl bind]]}

% ipwrite (Qctl case) -> bindctlmsg -> <> (as x->bind <- ipprotoinit[i] <- qmemu.c)
% bind ether /net/ether0
<<function ipifcbind>>=
/*
 *  attach a device (or pkt driver) to the interface.
 *  called with cv locked
 */
static char*
ipifcbind(Conv *cv, char **argv, int argc)
{
    Ipifc *ifc;
    Medium *m;

    if(argc < 2)
        return Ebadarg;

    ifc = (Ipifc*)cv->ptcl;

    /* bind the device to the interface */
    m = ipfindmedium(argv[1]);
    if(m == nil)
        return "unknown interface type";

    wlock(ifc);
    if(ifc->m != nil){
        wunlock(ifc);
        return "interface already bound";
    }
    if(waserror()){
        wunlock(ifc);
        nexterror();
    }

    // This time Medium dispatch
    /* do medium specific binding */
    (*m->bind)(ifc, argc, argv);

    /* set the bound device name */
    if(argc > 2)
        strncpy(ifc->dev, argv[2], sizeof(ifc->dev));
    else
        snprint(ifc->dev, sizeof ifc->dev, "%s%d", m->name, cv->x);
    ifc->dev[sizeof(ifc->dev)-1] = 0;

    /* set up parameters */
    ifc->m = m;

    ifc->mintu = ifc->m->mintu;
    ifc->maxtu = ifc->m->maxtu;
    if(ifc->m->unbindonclose == false)
        ifc->conv->inuse++;

    ifc->rp.mflag = 0;      /* default not managed */
    ifc->rp.oflag = 0;
    ifc->rp.maxraint = 600000;  /* millisecs */
    ifc->rp.minraint = 200000;
    ifc->rp.linkmtu = 0;        /* no mtu sent */
    ifc->rp.reachtime = 0;
    ifc->rp.rxmitra = 0;
    ifc->rp.ttl = MAXTTL;
    ifc->rp.routerlt = 3 * ifc->rp.maxraint;

    /* any ancillary structures (like routes) no longer pertain */
    ifc->ifcid++;

    /* reopen all the queues closed by a previous unbind */
    qreopen(cv->rq);
    qreopen(cv->eq);
    qreopen(cv->sq);

    wunlock(ifc);
    poperror();

    return nil;
}
@

<<function ipfindmedium>>=
/*
 *  find the medium with this name
 */
Medium*
ipfindmedium(char *name)
{
    Medium **mp;

    for(mp = media; *mp != nil; mp++)
        if(strcmp((*mp)->name, name) == 0)
            break;
    return *mp;
}
@
% use global media

\subsection{[[/net/ipifc/x/ctl]]}

% ... -> ipwrite (Qctl case) -> <>
%  (as x->bind <- ...) because not a generic msg
<<function ipifcctl>>=
/*
 *  non-standard control messages.
 *  called with cv->car locked.
 */
static char*
ipifcctl(Conv* cv, char** argv, int argc)
{
    Ipifc *ifc;
    int i;

    ifc = (Ipifc*)cv->ptcl;
    if(strcmp(argv[0], "add") == 0)
        return ipifcadd(ifc, argv, argc, 0, nil);

    else if(strcmp(argv[0], "try") == 0)
        return ipifcadd(ifc, argv, argc, 1, nil);
    else if(strcmp(argv[0], "remove") == 0)
        return ipifcrem(ifc, argv, argc);
    else if(strcmp(argv[0], "unbind") == 0)
        return ipifcunbind(ifc);
    else if(strcmp(argv[0], "joinmulti") == 0)
        return ipifcjoinmulti(ifc, argv, argc);
    else if(strcmp(argv[0], "leavemulti") == 0)
        return ipifcleavemulti(ifc, argv, argc);
    else if(strcmp(argv[0], "mtu") == 0)
        return ipifcsetmtu(ifc, argv, argc);
    else if(strcmp(argv[0], "reassemble") == 0){
        ifc->reassemble = 1;
        return nil;
    }
    else if(strcmp(argv[0], "iprouting") == 0){
        i = 1;
        if(argc > 1)
            i = atoi(argv[1]);
        iprouting(cv->p->f, i);
        return nil;
    }
    else if(strcmp(argv[0], "add6") == 0)
        return ipifcadd6(ifc, argv, argc);
    else if(strcmp(argv[0], "ra6") == 0)
        return ipifcra6(ifc, argv, argc);
    return "unsupported ctl";
}
@



\subsection{Adding IP, [[/net/ipifc/x/ctl add]]}


<<function ipifcadd>>=
/*
 *  add an address to an interface.
 */
char*
ipifcadd(Ipifc *ifc, char **argv, int argc, bool tentative, Iplifc *lifcp)
{
    int i, mtu, sendnbrdisc = 0;
    int type;
    uchar ip[IPaddrlen];
    uchar mask[IPaddrlen];
    uchar rem[IPaddrlen];
    uchar bcast[IPaddrlen];
    uchar net[IPaddrlen];
    Iplifc *lifc, **l;
    Fs *f;

    if(ifc->m == nil)
        return "ipifc not yet bound to device";

    f = ifc->conv->p->f;

    type = Rifc;
    memset(ip, 0, IPaddrlen);
    memset(mask, 0, IPaddrlen);
    memset(rem, 0, IPaddrlen);

    switch(argc){
    case 6:
        if(strcmp(argv[5], "proxy") == 0)
            type |= Rproxy;
        /* fall through */
    case 5:
        mtu = strtoul(argv[4], 0, 0);
        if(mtu >= ifc->m->mintu && mtu <= ifc->m->maxtu)
            ifc->maxtu = mtu;
        /* fall through */
    case 4:
        if (parseip(ip, argv[1]) == -1 || parseip(rem, argv[3]) == -1)
            return Ebadip;
        parseipmask(mask, argv[2]);
        maskip(rem, mask, net);
        break;
    case 3:
        if (parseip(ip, argv[1]) == -1)
            return Ebadip;
        parseipmask(mask, argv[2]);
        maskip(ip, mask, rem);
        maskip(rem, mask, net);
        break;
    case 2:
        if (parseip(ip, argv[1]) == -1)
            return Ebadip;
        memmove(mask, defmask(ip), IPaddrlen);
        maskip(ip, mask, rem);
        maskip(rem, mask, net);
        break;
    default:
        return Ebadarg;
    }

    if(isv4(ip))
        tentative = false;

    wlock(ifc);

    /* ignore if this is already a local address for this ifc */
    for(lifc = ifc->lifc; lifc; lifc = lifc->next) {
        if(ipcmp(lifc->local, ip) == 0) {
            if(lifc->tentative != tentative)
                lifc->tentative = tentative;
            if(lifcp) {
                lifc->onlink = lifcp->onlink;
                lifc->autoflag = lifcp->autoflag;
                lifc->validlt = lifcp->validlt;
                lifc->preflt = lifcp->preflt;
                lifc->origint = lifcp->origint;
            }
            goto out;
        }
    }

    /* add the address to the list of logical ifc's for this ifc */
    lifc = smalloc(sizeof(Iplifc));

    ipmove(lifc->local, ip);
    ipmove(lifc->mask, mask);
    ipmove(lifc->remote, rem);
    ipmove(lifc->net, net);
    lifc->tentative = tentative;

    if(lifcp) {
        lifc->onlink = lifcp->onlink;
        lifc->autoflag = lifcp->autoflag;
        lifc->validlt = lifcp->validlt;
        lifc->preflt = lifcp->preflt;
        lifc->origint = lifcp->origint;
    } else {        /* default values */
        lifc->onlink = lifc->autoflag = 1;
        lifc->validlt = lifc->preflt = ~0L;
        lifc->origint = NOW / 1000;
    }
    lifc->next = nil;

    for(l = &ifc->lifc; *l; l = &(*l)->next)
        ;
    *l = lifc;

    /* check for point-to-point interface */
    if(ipcmp(ip, v6loopback)) /* skip v6 loopback, it's a special address */
    if(ipcmp(mask, IPallbits) == 0)
        type |= Rptpt;

    /* add local routes */
    if(isv4(ip))
        v4addroute(f, tifc, rem+IPv4off, mask+IPv4off, rem+IPv4off, type);
    else
        v6addroute(f, tifc, rem, mask, rem, type);

    addselfcache(f, ifc, lifc, ip, Runi);

    if((type & (Rproxy|Rptpt)) == (Rproxy|Rptpt)){
        ipifcregisterproxy(f, ifc, rem);
        goto out;
    }

    if(isv4(ip) || ipcmp(ip, IPnoaddr) == 0) {
        /* add subnet directed broadcast address to the self cache */
        for(i = 0; i < IPaddrlen; i++)
            bcast[i] = (ip[i] & mask[i]) | ~mask[i];
        addselfcache(f, ifc, lifc, bcast, Rbcast);

        /* add subnet directed network address to the self cache */
        for(i = 0; i < IPaddrlen; i++)
            bcast[i] = (ip[i] & mask[i]) & mask[i];
        addselfcache(f, ifc, lifc, bcast, Rbcast);

        /* add network directed broadcast address to the self cache */
        memmove(mask, defmask(ip), IPaddrlen);
        for(i = 0; i < IPaddrlen; i++)
            bcast[i] = (ip[i] & mask[i]) | ~mask[i];
        addselfcache(f, ifc, lifc, bcast, Rbcast);

        /* add network directed network address to the self cache */
        memmove(mask, defmask(ip), IPaddrlen);
        for(i = 0; i < IPaddrlen; i++)
            bcast[i] = (ip[i] & mask[i]) & mask[i];
        addselfcache(f, ifc, lifc, bcast, Rbcast);

        addselfcache(f, ifc, lifc, IPv4bcast, Rbcast);
    }
    else {
        if(ipcmp(ip, v6loopback) == 0) {
            /* add node-local mcast address */
            addselfcache(f, ifc, lifc, v6allnodesN, Rmulti);

            /* add route for all node multicast */
            v6addroute(f, tifc, v6allnodesN, v6allnodesNmask,
                v6allnodesN, Rmulti);
        }

        /* add all nodes multicast address */
        addselfcache(f, ifc, lifc, v6allnodesL, Rmulti);

        /* add route for all nodes multicast */
        v6addroute(f, tifc, v6allnodesL, v6allnodesLmask, v6allnodesL,
            Rmulti);

        /* add solicited-node multicast address */
        ipv62smcast(bcast, ip);
        addselfcache(f, ifc, lifc, bcast, Rmulti);

        sendnbrdisc = 1;
    }

    /* register the address on this network for address resolution */
    if(isv4(ip) && ifc->m->areg != nil)
        (*ifc->m->areg)(ifc, ip);

out:
    wunlock(ifc);
    if(tentative && sendnbrdisc)
        icmpns(f, 0, SRC_UNSPEC, ip, TARG_MULTI, ifc->mac);
    return nil;
}
@




\section{Binding ethernet medium}

% not really initialisation, more configuration, so better moved
% here, because harder to explain before.

%linux: ifconfig eth0 ...

% open /net/ipifc/clone and start configure things.
%  echo 'bind ether /net/ether0' > /net/ipifc/0/ctl
%  echo 'add 10.0.2.15' > /net/ipifc/0/ctl
% (but how I guessed my ip? ipconfig use dhcp?)

% or use program:
% $ ip/ipconfig
% => /net/ipifc/0/... now contains an interface! connected to ethernet
%    /net/ipifc/0/status is nice
% => /net/arp now contains entries
% => /net/iproute now contains entries

% Have seen the first part with bind of Ipifc Protocol.
% Now will see the bind of the ethernet medium.


\subsection{[[etherbind()]]}

% ??? -> <>
%   (as x->bind <- ...)
<<function etherbind>>=
/*
 *  called to bind an IP ifc to an ethernet device
 *  called with ifc wlock'd
 */
static void
etherbind(Ipifc *ifc, int argc, char **argv)
{
    Chan *mchan4, *cchan4, *achan, *mchan6, *cchan6, *schan;
    char addr[Maxpath]; //char addr[2*KNAMELEN];
    char dir[Maxpath];  //char dir[2*KNAMELEN];
    char *buf;
    int n;
    char *ptr;
    Etherrock *er;

    if(argc < 2)
        error(Ebadarg);

    mchan4 = cchan4 = achan = mchan6 = cchan6 = nil;
    buf = nil;
    if(waserror()){
        if(mchan4 != nil)
            cclose(mchan4);
        if(cchan4 != nil)
            cclose(cchan4);
        if(achan != nil)
            cclose(achan);
        if(mchan6 != nil)
            cclose(mchan6);
        if(cchan6 != nil)
            cclose(cchan6);
        if(buf != nil)
            free(buf);
        nexterror();
    }

    /*
     *  open ipv4 conversation
     *
     *  the dial will fail if the type is already open on
     *  this device.
     */
    snprint(addr, sizeof(addr), "%s!0x800", argv[2]);   /* ETIP4 */
    mchan4 = chandial(addr, nil, dir, &cchan4);

    /*
     *  make it non-blocking
     */
    devtab[cchan4->type]->write(cchan4, nbmsg, strlen(nbmsg), 0);

    /*
     *  get mac address and speed
     */
    snprint(addr, sizeof(addr), "%s/stats", argv[2]);
    buf = smalloc(512);
    schan = namec(addr, Aopen, OREAD, 0);
    if(waserror()){
        cclose(schan);
        nexterror();
    }
    n = devtab[schan->type]->read(schan, buf, 511, 0);
    cclose(schan);
    poperror();
    buf[n] = 0;

    ptr = strstr(buf, "addr: ");
    if(!ptr)
        error(Eio);
    ptr += 6;
    parsemac(ifc->mac, ptr, 6);

    ptr = strstr(buf, "mbps: ");
    if(ptr){
        ptr += 6;
        ifc->mbps = atoi(ptr);
    } else
        ifc->mbps = 100;

    /*
     *  open arp conversation
     */
    snprint(addr, sizeof(addr), "%s!0x806", argv[2]);   /* ETARP */
    achan = chandial(addr, nil, nil, nil);

    /*
     *  open ipv6 conversation
     *
     *  the dial will fail if the type is already open on
     *  this device.
     */
    snprint(addr, sizeof(addr), "%s!0x86DD", argv[2]);  /* ETIP6 */
    mchan6 = chandial(addr, nil, dir, &cchan6);

    /*
     *  make it non-blocking
     */
    devtab[cchan6->type]->write(cchan6, nbmsg, strlen(nbmsg), 0);

    er = smalloc(sizeof(*er));
    er->mchan4 = mchan4;
    er->cchan4 = cchan4;
    er->achan = achan;
    er->mchan6 = mchan6;
    er->cchan6 = cchan6;
    er->f = ifc->conv->p->f;
    ifc->arg = er;

    free(buf);
    poperror();

    kproc("etherread4", etherread4, ifc);
    kproc("recvarpproc", recvarpproc, ifc);
    kproc("etherread6", etherread6, ifc);
}
@

\subsection{[[chandial()]]}


\chapter{IP}


\section{IP addresses}

\subsection{Parsing}

%ex: ip address 10.0.0.2
<<function v4parseip>>=
char*
v4parseip(uchar *to, char *from)
{
    int i;
    char *p;

    p = from;
    for(i = 0; i < 4 && *p; i++){
        to[i] = strtoul(p, &p, 0);
        if(*p == '.')
            p++;
    }
    switch(CLASS(to)){
    case 0:	/* class A - 1 uchar net */
    case 1:
        if(i == 3){
            to[3] = to[2];
            to[2] = to[1];
            to[1] = 0;
        } else if (i == 2){
            to[3] = to[1];
            to[1] = 0;
        }
        break;
    case 2:	/* class B - 2 uchar net */
        if(i == 3){
            to[3] = to[2];
            to[2] = 0;
        }
        break;
    }
    return p;
}
@

<<function parseip>>=
/*
 * `from' may contain an address followed by other characters,
 * at least in /boot, so we permit whitespace (and more) after the address.
 * we do ensure that "delete" cannot be parsed as "de::".
 *
 * some callers don't check the return value for errors, so
 * set `to' to something distinctive in the case of a parse error.
 */
vlong
parseip(uchar *to, char *from)
{
    int i, elipsis = 0;
    bool v4 = true;
    ulong x;
    char *p, *op;

    memset(to, 0, IPaddrlen);
    p = from;
    for(i = 0; i < IPaddrlen && ipcharok(*p); i+=2){
        op = p;
        x = strtoul(p, &p, 16);
        if((*p == '.' && i <= IPaddrlen-4) || (*p == '\0' && i == 0)){
            /* ends with v4 */
            p = v4parseip(to+i, op);
            i += 4;
            break;
        }

        /* v6: at most 4 hex digits, followed by colon or delim */
        if(x != (ushort)x || *p != ':' && !delimchar(*p)) {
            memset(to, 0, IPaddrlen);
            return -1;			/* parse error */
        }
        to[i] = x>>8;
        to[i+1] = x;
        if(*p == ':'){
            v4 = false;
            if(*++p == ':'){	/* :: is elided zero short(s) */
                if (elipsis) {
                    memset(to, 0, IPaddrlen);
                    return -1;	/* second :: */
                }
                elipsis = i+2;
                p++;
            }
        } else if (p == op)		/* strtoul made no progress? */
            break;
    }
    if (p == from || !delimchar(*p)) {
        memset(to, 0, IPaddrlen);
        return -1;				/* parse error */
    }
    if(i < IPaddrlen){
        memmove(&to[elipsis+IPaddrlen-i], &to[elipsis], i-elipsis);
        memset(&to[elipsis], 0, IPaddrlen-i);
    }

    if(v4){
        to[10] = to[11] = 0xff;
        return nhgetl(to + IPv4off);
    } else
        return 6;
}
@

\subsection{Comparisons}

<<macro ipcmp>>=
#define	ipcmp(x, y) memcmp(x, y, IPaddrlen)
@

<<macro ipmove>>=
#define	ipmove(x, y) memmove(x, y, IPaddrlen)
@

<<function equivip4>>=
bool
equivip4(uchar *a, uchar *b)
{
    int i;

    for(i = 0; i < 4; i++)
        if(a[i] != b[i])
            return false;
    return true;
}
@
%less: diff with ipcmp? used?


\section{IP header}

<<struct Ip4hdr>>=
/* on the wire packet header */
struct Ip4hdr
{
  uchar vihl;   /* Version and header length */
  uchar tos;    /* Type of service */
  uchar length[2];  /* packet length */
  uchar id[2];    /* ip->identification */
  uchar frag[2];  /* Fragment information */
  uchar ttl;        /* Time to live */
  uchar proto;    /* Protocol */
  uchar cksum[2]; /* Header checksum */
  uchar src[4];   /* IP source */
  uchar dst[4];   /* IP destination */
};
@



\chapter{IP Interface}

\section{Parsing}

<<function readipifc>>=
Ipifc*
readipifc(char *net, Ipifc *ifc, int index)
{
    int fd, i, n;
    Dir *dir;
    char directory[128];
    char buf[128];
    Ipifc **l;

    _freeifc(ifc);

    l = &ifc;
    ifc = nil;

    if(net == nil)
        net = "/net";
    snprint(directory, sizeof(directory), "%s/ipifc", net);

    if(index >= 0){
        snprint(buf, sizeof(buf), "%s/%d/status", directory, index);
        _readipifc(buf, l, index);
    } else {
        fd = open(directory, OREAD);
        if(fd < 0)
            return nil;
        n = dirreadall(fd, &dir);
        close(fd);

        for(i = 0; i < n; i++){
            if(strcmp(dir[i].name, "clone") == 0)
                continue;
            if(strcmp(dir[i].name, "stats") == 0)
                continue;
            snprint(buf, sizeof(buf), "%s/%s/status", directory, dir[i].name);
            l = _readipifc(buf, l, atoi(dir[i].name));
        }
        free(dir);
    }

    return ifc;
}
@


<<function _readipifc>>=
static Ipifc**
_readipifc(char *file, Ipifc **l, int index)
{
    int i, n, fd, lines;
    char buf[4*1024];
    char *line[32];
    char *f[64];
    Ipifc *ifc, **l0;
    Iplifc *lifc, **ll;

    /* read the file */
    fd = open(file, OREAD);
    if(fd < 0)
        return l;
    n = 0;
    while((i = read(fd, buf+n, sizeof(buf)-1-n)) > 0 && n < sizeof(buf) - 1)
        n += i;
    buf[n] = 0;
    close(fd);

    //if(strncmp(buf, "device", 6) != 0)
    //    return _readoldipifc(buf, l, index);

    /* ignore ifcs with no associated device */
    if(strncmp(buf+6, "  ", 2) == 0)
        return l;
    /* allocate new interface */
    *l = ifc = mallocz(sizeof(Ipifc), 1);
    if(ifc == nil)
        return l;
    l0 = l;
    l = &ifc->next;
    ifc->index = index;

    lines = getfields(buf, line, nelem(line), 1, "\n");

    /* pick off device specific info(first line) */
    n = tokenize(line[0], f, nelem(f));
    if(n%2 != 0)
        goto lose;
    strncpy(ifc->dev, findfield("device", f, n), sizeof(ifc->dev));
    ifc->dev[sizeof(ifc->dev)-1] = 0;
    if(ifc->dev[0] == 0){
lose:
        free(ifc);
        *l0 = nil;
        return l;
    }
    ifc->mtu          = strtoul(findfield("maxtu", f, n), nil, 10);
    ifc->sendra6      = atoi(findfield("sendra", f, n));
    ifc->recvra6      = atoi(findfield("recvra", f, n));
    ifc->rp.mflag     = atoi(findfield("mflag", f, n));
    ifc->rp.oflag     = atoi(findfield("oflag", f, n));
    ifc->rp.maxraint  = atoi(findfield("maxraint", f, n));
    ifc->rp.minraint  = atoi(findfield("minraint", f, n));
    ifc->rp.linkmtu   = atoi(findfield("linkmtu", f, n));
    ifc->rp.reachtime = atoi(findfield("reachtime", f, n));
    ifc->rp.rxmitra   = atoi(findfield("rxmitra", f, n));
    ifc->rp.ttl       = atoi(findfield("ttl", f, n));
    ifc->rp.routerlt  = atoi(findfield("routerlt", f, n));
    ifc->pktin        = strtoul(findfield("pktin", f, n), nil, 10);
    ifc->pktout       = strtoul(findfield("pktout", f, n), nil, 10);
    ifc->errin        = strtoul(findfield("errin", f, n), nil, 10);
    ifc->errout       = strtoul(findfield("errout", f, n), nil, 10);

    /* now read the addresses */
    ll = &ifc->lifc;
    for(i = 1; i < lines; i++){
        n = tokenize(line[i], f, nelem(f));
        if(n < 5)
            break;

        /* allocate new local address */
        *ll = lifc = mallocz(sizeof(Iplifc), 1);
        ll = &lifc->next;

        parseip(lifc->ip, f[0]);
        parseipmask(lifc->mask, f[1]);
        parseip(lifc->net, f[2]);

        lifc->validlt = strtoul(f[3], nil, 10);
        lifc->preflt = strtoul(f[4], nil, 10);
    }

    return l;
}
@


<<function _freeifc>>=
static void
_freeifc(Ipifc *ifc)
{
    Ipifc *next;
    Iplifc *lnext, *lifc;

    if(ifc == nil)
        return;
    for(; ifc; ifc = next){
        next = ifc->next;
        for(lifc = ifc->lifc; lifc; lifc = lnext){
            lnext = lifc->next;
            free(lifc);
        }
        free(ifc);
    }
}
@

<<function findfield>>=
static char*
findfield(char *name, char **f, int n)
{
    int i;

    for(i = 0; i < n-1; i++)
        if(strcmp(f[i], name) == 0)
            return f[i+1];
    return "";
}
@

%<<function _readoldipifc>>=
%static Ipifc**
%_readoldipifc(char *buf, Ipifc **l, int index)
%{
%    char *f[200];
%    int i, n;
%    Ipifc *ifc;
%    Iplifc *lifc, **ll;
%
%    /* allocate new interface */
%    *l = ifc = mallocz(sizeof(Ipifc), 1);
%    if(ifc == nil)
%        return l;
%    l = &ifc->next;
%    ifc->index = index;
%
%    n = tokenize(buf, f, nelem(f));
%    if(n < 2)
%        return l;
%
%    strncpy(ifc->dev, f[0], sizeof ifc->dev);
%    ifc->dev[sizeof(ifc->dev) - 1] = 0;
%    ifc->mtu = strtoul(f[1], nil, 10);
%
%    ll = &ifc->lifc;
%    for(i = 2; n-i >= 7; i += 7){
%        /* allocate new local address */
%        *ll = lifc = mallocz(sizeof(Iplifc), 1);
%        ll = &lifc->next;
%
%        parseip(lifc->ip, f[i]);
%        parseipmask(lifc->mask, f[i+1]);
%        parseip(lifc->net, f[i+2]);
%        ifc->pktin = strtoul(f[i+3], nil, 10);
%        ifc->pktout = strtoul(f[i+4], nil, 10);
%        ifc->errin = strtoul(f[i+5], nil, 10);
%        ifc->errout = strtoul(f[i+6], nil, 10);
%    }
%    return l;
%}
%@


\section{[[/net/x/ipifc]]}

<<function myipaddr>>=
/* find first ip addr that isn't the friggin loopback address
 * unless there are no others 
 */
int
myipaddr(uchar *ip, char *net)
{
    Ipifc *nifc;
    Iplifc *lifc;
    static Ipifc *ifc;
    uchar mynet[IPaddrlen];

    ifc = readipifc(net, ifc, -1);
    for(nifc = ifc; nifc; nifc = nifc->next)
        for(lifc = nifc->lifc; lifc; lifc = lifc->next){
            maskip(lifc->ip, loopbackmask, mynet);
            if(ipcmp(mynet, loopbacknet) == 0){
                continue;
            }
            if(ipcmp(lifc->ip, IPnoaddr) != 0){
                ipmove(ip, lifc->ip);
                return 0;
            }
        }
    ipmove(ip, IPnoaddr);
    return -1;
}
@

\chapter{Ethernet}

% ethernet = CSMA-CD (carrier sense multiple access - collision detection)
% with smart binary exponential backoff with random variation when have
% collision.

% ethernet address on top of (CS)MA.





%todo: mv later what is below?

<<global etherxx (kernel)>>=
static Ether *etherxx[MaxEther];
@
<<constant MaxEther>>=
MaxEther  = 48,
@

<<struct Ether (kernel)>>=
struct Ether {
  ISAConf;      /* hardware info */

  int ctlrno;
  int tbdf;     /* type+busno+devno+funcno */
  uchar ea[Eaddrlen];

  void  (*attach)(Ether*);  /* filled in by reset routine */
  void  (*detach)(Ether*);
  void  (*transmit)(Ether*);
  void  (*interrupt)(Ureg*, void*);
  long  (*ifstat)(Ether*, void*, long, ulong);
  long  (*ctl)(Ether*, void*, long); /* custom ctl messages */
  void  (*power)(Ether*, int);  /* power on/off */
  void  (*shutdown)(Ether*);  /* shutdown hardware before reboot */
  void  *ctlr;

  Queue*  oq;

  Netif;
};
@
% in 386 because ISAConf?


\section{Ethernet addresses}

\subsection{Parsing}

%ex: mac address f8:ed:a5:74:92:a1
% strtoul? uchar because ip are 4 integers between 0 and 255
<<function parseether>>=
errorneg1
parseether(uchar *to, char *from)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    for(i = 0; i < 6; i++){
        if(*p == '\0')
            return ERROR_NEG1;
        nip[0] = *p++;
        if(*p == '\0')
            return ERROR_NEG1;
        nip[1] = *p++;
        nip[2] = '\0';
        to[i] = strtoul(nip, 0, 16);
        if(*p == ':')
            p++;
    }
    return OK_0;
}
@

\subsection{[[/net/x/addr]]}

<<function myetheraddr>>=
errorneg1
myetheraddr(uchar *to, char *dev)
{
    int n, fd;
    char buf[256];

    if(*dev == '/')
        sprint(buf, "%s/addr", dev);
    else
        sprint(buf, "/net/%s/addr", dev);

    fd = open(buf, OREAD);
    if(fd < 0)
        return ERROR_NEG1;

    n = read(fd, buf, sizeof buf -1 );
    close(fd);
    if(n <= 0)
        return ERROR_NEG1;
    buf[n] = '\0';

    parseether(to, buf);
    return OK_0;
}
@

\section{Ethernet header}

<<struct Etherhdr>>=
struct Etherhdr
{
    uchar   d[6];
    uchar   s[6];
    uchar   t[2];
};
@
% ethermedium.c

\section{Ethernet packet}

<<struct Etherpkt>>=
struct Etherpkt
{
  uchar d[Eaddrlen];
  uchar s[Eaddrlen];
  uchar type[2];

  uchar data[1500];
};
@
% netif.h


\chapter{ARP}

<<[[Fs(kernel)]] arp fields>>=
Arp *arp;
@


<<struct Arp>>=
/*
 *  one per Fs
 */
struct Arp
{
    Arpent  *rxmt;
    Proc    *rxmitp;    /* neib sol re-transmit proc */

    Rendez  rxmtq;
    Block   *dropf, *dropl;

    Arpent  *hash[NHASH];
    Arpent  cache[NCACHE];

    // Extra
    QLock;
    <<[[Arp]] extra fields>>

};
@

<<[[Arp]] extra fields>>=
// ref<Fs>, reverse of Fs.arp
Fs  *f;
@


<<struct Arpent>>=
struct Arpent
{
  uchar ip[IPaddrlen];
  uchar mac[MAClen];

  Medium  *type;      /* media type */

  Block*  hold;
  Block*  last;
  uint  ctime;      /* time entry was created or refreshed */
  uint  utime;      /* time entry was last used */
  uchar state;
  Arpent  *nextrxt;   /* re-transmit chain */
  uint  rtime;      /* time for next retransmission */
  uchar rxtsrem;
  uchar ifcid;      /* must match ifc->id */

  // Extra
  Arpent* hash;
  Ipifc *ifc;
};
@

\section{Initialisation}

% ipattach -> ipgetfs -> <>
<<function arpinit>>=
void
arpinit(Fs *f)
{
    f->arp = smalloc(sizeof(Arp));
    f->arp->f = f;
    f->arp->rxmt = nil;
    f->arp->dropf = f->arp->dropl = nil;
    kproc("rxmitproc", rxmitproc, f->arp);
}
@

<<function rxmitproc>>=
static void
rxmitproc(void *v)
{
    Arp *arp = v;
    long wakeupat;

    arp->rxmitp = up;
    //print("arp rxmitproc started\n");
    if(waserror()){
        arp->rxmitp = 0;
        pexit("hangup", 1);
    }
    for(;;){
        wakeupat = rxmitsols(arp);
        if(wakeupat == 0)
            sleep(&arp->rxmtq, rxready, v);
        else if(wakeupat > ReTransTimer/4)
            tsleep(&arp->rxmtq, returnfalse, 0, wakeupat);
    }
}
@


\section{[[/net/arp]]}

% See Qarp def in enum qid.

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qarp:
    p = "arp";
    prot = 0664;
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qarp:
    return arpread(f->arp, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qarp:
    return arpwrite(f, a, n);
@

<<[[ipopen()]] switch TYPE qid cases>>=
case Qarp:
case Qiproute:
    if(omode != OREAD && !iseve())
        error(Eperm);
    break;
@


\chapter{Routes}

% ARP allows local routing
% /net/iproute allows inter-network routing, find gateway

\section{[[/net/ipselftab]]}

<<[[Qid]] toplevel extra cases>>=
Qipselftab,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qipselftab:
    p = "ipselftab";
    prot = 0444;
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qipselftab:
    return ipselftabread(f, a, offset, n);
@

\section{[[/net/iproutes]]}

% See Qiproute def in enum qid.

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qiproute:
    p = "iproute";
    prot = 0664;
    break;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qiproute:
    return routeread(f, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qiproute:
    return routewrite(f, ch, a, n);
@


\chapter{UDP}
% Unreliable, Unordered :)

% when do ip/ipconfig then can see that 4 InDatagrams and 2 OutDatagrams
% and 2 ports :)

\section{Protocol initialisation}

% ipattach -> ipgetfs -> <> (as ipprotoinit[i] <- ...)
<<function udpinit>>=
void
udpinit(Fs *fs)
{
    Proto *udp;

    udp = smalloc(sizeof(Proto));
    udp->priv = smalloc(sizeof(Udppriv));

    udp->name = "udp";
    udp->create = udpcreate;

    udp->connect = udpconnect;
    udp->announce = udpannounce;
    udp->ctl = udpctl;

    udp->close = udpclose;
    udp->rcv = udpiput;
    udp->advise = udpadvise;

    udp->state = udpstate;
    udp->stats = udpstats;

    udp->ipproto = IP_UDPPROTO;

    udp->nc = Nchans;
    udp->ptclsize = sizeof(Udpcb);

    Fsproto(fs, udp);
}
@
%less: make it a global with intializer?

\section{Protocol data structures}

\subsection{[[Udppriv]]}

% protocol priv
<<struct Udppriv>>=
struct Udppriv
{
    Ipht        ht;

    <<[[Udppriv]] stat fields>>
};
@


\subsection{[[Udpcb]]}

% conversation priv

<<struct Udpcb>>=
struct Udpcb
{
    QLock;
    <<[[Idpcb]] other fields>>
};
@

\subsection{Statistics}

% C-s one of this field and you'll understand what does what :)
% which is why it can be useful to present early.
%less: or present with /net/udp/stats later?

<<[[Udppriv]] stat fields>>=
/* MIB counters */
Udpstats    ustats;
/* non-MIB stats */
ulong       csumerr;        /* checksum errors */
ulong       lenerr;         /* short packet */
@
%MIB?

<<struct Udpstats>>=
struct Udpstats
{
    uvlong  udpInDatagrams;
    ulong   udpNoPorts;
    ulong   udpInErrors;
    uvlong  udpOutDatagrams;
};
@



\section{Protocol header}

<<struct Udp4hdr>>=
struct Udp4hdr
{
    /* ip header */
    uchar   vihl;       /* Version and header length */
    uchar   tos;        /* Type of service */
    uchar   length[2];  /* packet length */
    uchar   id[2];      /* Identification */
    uchar   frag[2];    /* Fragment information */
    uchar   Unused;

    uchar   udpproto;   /* Protocol */
    uchar   udpplen[2]; /* Header plus data length */
    uchar   udpsrc[IPv4addrlen];    /* Ip source */
    uchar   udpdst[IPv4addrlen];    /* Ip destination */

    /* udp header */
    uchar   udpsport[2];    /* Source port */
    uchar   udpdport[2];    /* Destination port */
    uchar   udplen[2];  /* data length */
    uchar   udpcksum[2];    /* Checksum */
};
@
% do not change the order here :)


<<struct Udphdr>>=
struct Udphdr
{
    uchar	raddr[IPaddrlen];	/* V6 remote address */
    uchar	laddr[IPaddrlen];	/* V6 local address */
    uchar	ifcaddr[IPaddrlen];	/* V6 ifc addr msg was received on */

    uchar	rport[2];		/* remote port */
    uchar	lport[2];		/* local port */
};
@
% do not change the order here :)

\section{[[/net/tcp/clone]]}

<<function udpcreate>>=
static void
udpcreate(Conv *cv)
{
    cv->rq = qopen(128*1024, Qmsg, 0, 0);
    cv->wq = qbypass(udpkick, cv);
}
@

\section{[[/net/tcp/ctl]]}

\subsection{Connect}

<<function udpconnect>>=
static char*
udpconnect(Conv *c, char **argv, int argc)
{
    char *e;
    Udppriv *upriv;

    upriv = c->p->priv;
    e = Fsstdconnect(c, argv, argc);
    Fsconnected(c, e);
    if(e != nil)
        return e;

    iphtadd(&upriv->ht, c);
    return nil;
}
@

\subsection{Announce}

<<function udpannounce>>=
static char*
udpannounce(Conv *c, char** argv, int argc)
{
    char *e;
    Udppriv *upriv;

    upriv = c->p->priv;
    e = Fsstdannounce(c, argv, argc);
    if(e != nil)
        return e;
    Fsconnected(c, nil);
    iphtadd(&upriv->ht, c);

    return nil;
}
@

\subsection{Other}

% need that? remove?

<<[[Idpcb]] other fields>>=
uchar   headers;
@

<<function udpctl>>=
char*
udpctl(Conv *c, char **f, int n)
{
    Udpcb *ucb;

    ucb = (Udpcb*)c->ptcl;
    if(n == 1){
        if(strcmp(f[0], "headers") == 0){
            ucb->headers = 7;   /* new headers format */
            return nil;
        }
    }
    return "unknown control request";
}
@

\section{IO}

\subsection{kick}

<<function udpkick>>=
void
udpkick(void *x, Block *bp)
{
    Conv *c = x;
    Udp4hdr *uh4;
    Udp6hdr *uh6;
    ushort rport;
    uchar laddr[IPaddrlen], raddr[IPaddrlen];
    Udpcb *ucb;
    int dlen, ptcllen;
    Udppriv *upriv;
    Fs *f;
    int version;
    Conv *rc;

    upriv = c->p->priv;
    f = c->p->f;

//  netlog(c->p->f, Logudp, "udp: kick\n"); /* frequent and uninteresting */
    if(bp == nil)
        return;

    ucb = (Udpcb*)c->ptcl;
    switch(ucb->headers) {
    case 7:
        /* get user specified addresses */
        bp = pullupblock(bp, UDP_USEAD7);
        if(bp == nil)
            return;
        ipmove(raddr, bp->rp);
        bp->rp += IPaddrlen;
        ipmove(laddr, bp->rp);
        bp->rp += IPaddrlen;
        /* pick interface closest to dest */
        if(ipforme(f, laddr) != Runi)
            findlocalip(f, laddr, raddr);
        bp->rp += IPaddrlen;        /* Ignore ifc address */
        rport = nhgets(bp->rp);
        bp->rp += 2+2;          /* Ignore local port */
        break;
    default:
        rport = 0;
        break;
    }

    if(ucb->headers) {
        if(memcmp(laddr, v4prefix, IPv4off) == 0
        || ipcmp(laddr, IPnoaddr) == 0)
            version = 4;
        else
            version = 6;
    } else {
        if( (memcmp(c->raddr, v4prefix, IPv4off) == 0 &&
            memcmp(c->laddr, v4prefix, IPv4off) == 0)
            || ipcmp(c->raddr, IPnoaddr) == 0)
            version = 4;
        else
            version = 6;
    }

    dlen = blocklen(bp);

    /* fill in pseudo header and compute checksum */
    switch(version){
    case V4:
        bp = padblock(bp, UDP4_IPHDR_SZ+UDP_UDPHDR_SZ);
        if(bp == nil)
            return;

        uh4 = (Udp4hdr *)(bp->rp);
        ptcllen = dlen + UDP_UDPHDR_SZ;
        uh4->Unused = 0;
        uh4->udpproto = IP_UDPPROTO;
        uh4->frag[0] = 0;
        uh4->frag[1] = 0;
        hnputs(uh4->udpplen, ptcllen);
        if(ucb->headers) {
            v6tov4(uh4->udpdst, raddr);
            hnputs(uh4->udpdport, rport);
            v6tov4(uh4->udpsrc, laddr);
            rc = nil;
        } else {
            v6tov4(uh4->udpdst, c->raddr);
            hnputs(uh4->udpdport, c->rport);
            if(ipcmp(c->laddr, IPnoaddr) == 0)
                findlocalip(f, c->laddr, c->raddr);
            v6tov4(uh4->udpsrc, c->laddr);
            rc = c;
        }
        hnputs(uh4->udpsport, c->lport);
        hnputs(uh4->udplen, ptcllen);
        uh4->udpcksum[0] = 0;
        uh4->udpcksum[1] = 0;
        hnputs(uh4->udpcksum,
               ptclcsum(bp, UDP4_PHDR_OFF, dlen+UDP_UDPHDR_SZ+UDP4_PHDR_SZ));
        uh4->vihl = IP_VER4;
        ipoput4(f, bp, 0, c->ttl, c->tos, rc);
        break;

    case V6:
        bp = padblock(bp, UDP6_IPHDR_SZ+UDP_UDPHDR_SZ);
        if(bp == nil)
            return;

        /*
         * using the v6 ip header to create pseudo header
         * first then reset it to the normal ip header
         */
        uh6 = (Udp6hdr *)(bp->rp);
        memset(uh6, 0, 8);
        ptcllen = dlen + UDP_UDPHDR_SZ;
        hnputl(uh6->viclfl, ptcllen);
        uh6->hoplimit = IP_UDPPROTO;
        if(ucb->headers) {
            ipmove(uh6->udpdst, raddr);
            hnputs(uh6->udpdport, rport);
            ipmove(uh6->udpsrc, laddr);
            rc = nil;
        } else {
            ipmove(uh6->udpdst, c->raddr);
            hnputs(uh6->udpdport, c->rport);
            if(ipcmp(c->laddr, IPnoaddr) == 0)
                findlocalip(f, c->laddr, c->raddr);
            ipmove(uh6->udpsrc, c->laddr);
            rc = c;
        }
        hnputs(uh6->udpsport, c->lport);
        hnputs(uh6->udplen, ptcllen);
        uh6->udpcksum[0] = 0;
        uh6->udpcksum[1] = 0;
        hnputs(uh6->udpcksum,
               ptclcsum(bp, UDP6_PHDR_OFF, dlen+UDP_UDPHDR_SZ+UDP6_PHDR_SZ));
        memset(uh6, 0, 8);
        uh6->viclfl[0] = IP_VER6;
        hnputs(uh6->len, ptcllen);
        uh6->nextheader = IP_UDPPROTO;
        ipoput6(f, bp, 0, c->ttl, c->tos, rc);
        break;

    default:
        panic("udpkick: version %d", version);
    }
    upriv->ustats.udpOutDatagrams++;
}
@

\subsection{iput}

\section{Other files}

\subsection{[[/net/tcp/stats]]}

<<function udpstats>>=
int
udpstats(Proto *udp, char *buf, int len)
{
    Udppriv *upriv;

    upriv = udp->priv;
    return snprint(buf, len, "InDatagrams: %llud\nNoPorts: %lud\n"
        "InErrors: %lud\nOutDatagrams: %llud\n",
        upriv->ustats.udpInDatagrams,
        upriv->ustats.udpNoPorts,
        upriv->ustats.udpInErrors,
        upriv->ustats.udpOutDatagrams);
}
@

\subsection{[[/net/tcp/x/status]]}

<<function udpstate>>=
static int
udpstate(Conv *cv, char *state, int n)
{
    return snprint(state, n, "%s qin %d qout %d\n",
        cv->inuse ? "Open" : "Closed",
        cv->rq ? qlen(cv->rq) : 0,
        cv->wq ? qlen(cv->wq) : 0
    );
}
@

\chapter{IL}

%was in 9legacy since it has been deleted of recent plan9

<<function ilinit>>=
void
ilinit(Fs *f)
{
    Proto *il;

    inittimescale();

    il = smalloc(sizeof(Proto));
    il->priv = smalloc(sizeof(Ilpriv));

    il->name = "il";
    il->connect = ilconnect;
    il->announce = ilannounce;
    il->state = ilstate;
    il->create = ilcreate;
    il->close = ilclose;
    il->rcv = iliput;
    il->ctl = nil;
    il->advise = iladvise;
    il->stats = ilxstats;
    il->inuse = ilinuse;
    il->gc = nil;
    il->ipproto = IP_ILPROTO;
    il->nc = scalednconv();
    il->ptclsize = sizeof(Ilcb);
    Fsproto(f, il);
}
@

<<enum _anon_ (kernel/network/ip/il.c)>>=
enum				/* Connection state */
{
    Ilclosed,
    Ilsyncer,
    Ilsyncee,
    Ilestablished,
    Illistening,
    Ilclosing,
    Ilopening,		/* only for file server */
};
@
% look nice, simple

<<global ilstates>>=
char	*ilstates[] = 
{ 
    "Closed",
    "Syncer",
    "Syncee",
    "Established",
    "Listen",
    "Closing",
    "Opening",		/* only for file server */
};
@


<<struct Ilhdr>>=
struct Ilhdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* Ip source */
    uchar	dst[4];		/* Ip destination */
    uchar	ilsum[2];	/* Checksum including header */
    uchar	illen[2];	/* Packet length */
    uchar	iltype;		/* Packet type */
    uchar	ilspec;		/* Special */
    uchar	ilsrc[2];	/* Src port */
    uchar	ildst[2];	/* Dst port */
    uchar	ilid[4];	/* Sequence id */
    uchar	ilack[4];	/* Acked sequence */
};
@



\chapter{TCP}

<<function tcpinit>>=
void
tcpinit(Fs *fs)
{
    Proto *tcp;
    Tcppriv *tpriv;

    tcp = smalloc(sizeof(Proto));
    tpriv = tcp->priv = smalloc(sizeof(Tcppriv));
    tcp->name = "tcp";
    tcp->connect = tcpconnect;
    tcp->announce = tcpannounce;
    tcp->ctl = tcpctl;
    tcp->state = tcpstate;
    tcp->create = tcpcreate;
    tcp->close = tcpclose;
    tcp->rcv = tcpiput;
    tcp->advise = tcpadvise;
    tcp->stats = tcpstats;
    tcp->inuse = tcpinuse;
    tcp->gc = tcpgc;
    tcp->ipproto = IP_TCPPROTO;
    tcp->nc = scalednconv();
    tcp->ptclsize = sizeof(Tcpctl);
    tpriv->stats[MaxConn] = tcp->nc;

    Fsproto(fs, tcp);
}
@

\chapter{9P}

\chapter{RPC}

\chapter{Network File System}
% the logical conclusion for all of that.


% con and exportfs
% NFS like?

\chapter{Security}

\section{Denial of service}
% hogport? in tcp? tcpporthogdefense

\chapter{Debugging Support}
% the stats? to see the packet loss?

% snoopy? 

\chapter{Profiling Support}
% the stats? to see the packet loss?

\chapter{Advanced Topics}

\section{IPv6}

\section{Network database, [[ndb]]}

<<[[Fs(kernel)]] ndb fields>>=
char  ndb[1024];    /* an ndb entry for this interface */
int ndbvers;
long  ndbmtime;
@

\subsection{[[/net/ndb]]}

<<[[Qid]] toplevel extra cases>>=
Qndb,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qndb:
    p = "ndb";
    len = strlen(f->ndb);
    q.vers = f->ndbvers;
    break;
@
<<[[ipgen()]] if Qndb, adjust mtime>>=
if(i == Qndb && f->ndbmtime > kerndate)
    dp->mtime = f->ndbmtime;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qndb:
    if(omode & (OWRITE|OTRUNC) && !iseve())
        error(Eperm);
    if((omode & (OWRITE|OTRUNC)) == (OWRITE|OTRUNC))
        f->ndb[0] = 0;
    break;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qndb:
    return readstr(offset, a, n, f->ndb);
@

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qndb:
    return ndbwrite(f, a, offset, n);
    break;
@


\section{Connection Server}
% abstract away different address schemes

\section{Packet filter}
% /net/ipmux

\section{Sniffing}

% promiscuous mode for ethernet, get all packets even those
% which don't have your MAC as a recipient

\section{Loopback medium}

% echo 'bind loopback' > /net/ipifc/x/ctl

<<global loopbackmedium>>=
Medium loopbackmedium =
{
    .name=      "loopback",

    .hsize=     0,
    .mintu=     0,
    .maxtu=     Maxtu,
    .maclen=    0,

    .bind=      loopbackbind,
    .unbind=    loopbackunbind,
    .bwrite=    loopbackbwrite,
};
@
% maclen 0 ?? no header?

<<enum _anon_ (kernel/network/ip/loopbackmedium.c)>>=
enum
{
    Maxtu=  16*1024,
};
@

<<function loopbackmediumlink>>=
void
loopbackmediumlink(void)
{
    addipmedium(&loopbackmedium);
}
@

% private Ipifc data, ifc->arg
<<struct LB>>=
struct LB
{
    Queue   *q;
    Fs  *f;
    Proc    *readp;
};
@

<<function loopbackbind>>=
static void
loopbackbind(Ipifc *ifc, int, char**)
{
    LB *lb;

    lb = smalloc(sizeof(LB));
    lb->f = ifc->conv->p->f;
    lb->q = qopen(1024*1024, Qmsg, nil, nil);
    ifc->arg = lb;
    ifc->mbps = 1000;

    kproc("loopbackread", loopbackread, ifc);

}
@


<<function loopbackunbind>>=
static void
loopbackunbind(Ipifc *ifc)
{
    LB *lb = ifc->arg;

    if(lb->readp)
        postnote(lb->readp, 1, "unbind", 0);

    /* wait for reader to die */
    while(lb->readp != nil)
        tsleep(&up->sleepr, returnfalse, 0, 300);

    /* clean up */
    qfree(lb->q);
    free(lb);
}
@

% a kproc
<<function loopbackread>>=
static void
loopbackread(void *a)
{
    Ipifc *ifc;
    Block *bp;
    LB *lb;

    ifc = a;
    lb = ifc->arg;
    lb->readp = up; /* hide identity under a rock for unbind */
    if(waserror()){
        lb->readp = 0;
        pexit("hangup", 1);
    }
    for(;;){
        bp = qbread(lb->q, Maxtu);
        if(bp == nil)
            continue;
        ifc->in++;
        if(!canrlock(ifc)){
            freeb(bp);
            continue;
        }
        if(waserror()){
            runlock(ifc);
            nexterror();
        }
        if(ifc->lifc == nil)
            freeb(bp);
        else
            ipiput4(lb->f, ifc, bp);
        runlock(ifc);
        poperror();
    }
}
@
% ipiput4!


<<function loopbackbwrite>>=
static void
loopbackbwrite(Ipifc *ifc, Block *bp, int, uchar*)
{
    LB *lb;

    lb = ifc->arg;
    if(qpass(lb->q, bp) < 0)
        ifc->outerr++;
    ifc->out++;
}
@

\section{Multicast}

<<[[Medium(kernel)]] multicast methods>>=
/* for arming interfaces to receive multicast */
void  (*addmulti)(Ipifc *ifc, uchar *a, uchar *ia);
void  (*remmulti)(Ipifc *ifc, uchar *a, uchar *ia);

/* for routing multicast groups */
void  (*joinmulti)(Ipifc *ifc, uchar *a, uchar *ia);
void  (*leavemulti)(Ipifc *ifc, uchar *a, uchar *ia);
@

<<[[Conv(kernel)]] multicast fields>>=
Ipmulti *multi;     /* multicast bindings for this interface */
@

<<[[Netif(kernel)]] multicast fields>>=
Netaddr *maddr;     /* known multicast addresses */
int nmaddr;     /* number of known multicast addresses */
Netaddr *mhash[Nmhash];   /* hash table of multicast addresses */
@

<<[[Netif(kernel)]] multicast methods>>=
void  (*multicast)(void*, uchar*, int);
@

\section{Bootp}

\subsection{[[/net/bootp]]}

<<[[Qid]] toplevel extra cases>>=
Qbootp,
@
<<[[ip1gen()]] switch TYPE qid cases>>=
case Qbootp:
    p = "bootp";
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qbootp:
    return bootpread(a, offset, n);
@


\chapter{Conclusion}

\appendix

\chapter{Debugging}

\section{Dumpers}

\subsection{Addresses}
% or masks

<<function eipfmt>>=
int
eipfmt(Fmt *f)
{
    char buf[5*8];
    static char *efmt = "%.2ux%.2ux%.2ux%.2ux%.2ux%.2ux"; // ethernet
    static char *ifmt = "%d.%d.%d.%d"; // internet, v4
    uchar *p;
    uchar ip[16];
    ulong *lp;
    ushort s;
    int i, j, n, eln, eli;

    switch(f->r) {
    case 'E':		/* Ethernet address */
        p = va_arg(f->args, uchar*);
        snprint(buf, sizeof buf, efmt, p[0], p[1], p[2], p[3], p[4], p[5]);
        return fmtstrcpy(f, buf);

    case 'I':		/* Ip address */
        p = va_arg(f->args, uchar*);
common:
        if(memcmp(p, v4prefix, 12) == 0){
            snprint(buf, sizeof buf, ifmt, p[12], p[13], p[14], p[15]);
            return fmtstrcpy(f, buf);
        }

        /* find longest elision */
        eln = eli = -1;
        for(i = 0; i < 16; i += 2){
            for(j = i; j < 16; j += 2)
                if(p[j] != 0 || p[j+1] != 0)
                    break;
            if(j > i && j - i > eln){
                eli = i;
                eln = j - i;
            }
        }

        /* print with possible elision */
        n = 0;
        for(i = 0; i < 16; i += 2){
            if(i == eli){
                n += sprint(buf+n, "::");
                i += eln;
                if(i >= 16)
                    break;
            } else if(i != 0)
                n += sprint(buf+n, ":");
            s = (p[i]<<8) + p[i+1];
            n += sprint(buf+n, "%ux", s);
        }
        return fmtstrcpy(f, buf);

    case 'i':		/* v6 address as 4 longs */
        lp = va_arg(f->args, ulong*);
        for(i = 0; i < 4; i++)
            hnputl(ip+4*i, *lp++);
        p = ip;
        goto common;

    case 'V':		/* v4 ip address */
        p = va_arg(f->args, uchar*);
        snprint(buf, sizeof buf, ifmt, p[0], p[1], p[2], p[3]);
        return fmtstrcpy(f, buf);

    case 'M':		/* ip mask */
        p = va_arg(f->args, uchar*);

        /* look for a prefix mask */
        for(i = 0; i < 16; i++)
            if(p[i] != 0xff)
                break;
        if(i < 16){
            if((prefixvals[p[i]] & Isprefix) == 0)
                goto common;
            for(j = i+1; j < 16; j++)
                if(p[j] != 0)
                    goto common;
            n = 8*i + (prefixvals[p[i]] & ~Isprefix);
        } else
            n = 8*16;

        /* got one, use /xx format */
        snprint(buf, sizeof buf, "/%d", n);
        return fmtstrcpy(f, buf);
    }
    return fmtstrcpy(f, "(eipfmt)");
}
@

\subsection{IP interface}

<<function main>>=
void
main(void)
{
    Ipifc *ifc, *list;
    Iplifc *lifc;
    int i;

    fmtinstall('I', eipfmt);
    fmtinstall('M', eipfmt);

    list = readipifc("/net", nil, -1);
    for(ifc = list; ifc; ifc = ifc->next){
        print("ipifc %s %d\n", ifc->dev, ifc->mtu);
        for(lifc = ifc->lifc; lifc; lifc = lifc->next)
            print("\t%I %M %I\n", lifc->ip, lifc->mask, lifc->net);
    }
}
@

\section{[[/net/log]]}

<<[[Fs(kernel)]] logging fields>>=
Netlog  *alog;
@

<<enum _anon_ (kernel/network/ip/netlog.c)>>=
enum {
    Nlog        = 16*1024,
};
@

<<struct Netlog>>=
/*
 *  action log
 */
struct Netlog {
    Lock;
    int opens;
    char*   buf;
    char    *end;
    char    *rptr;
    int len;

    int logmask;            /* mask of things to debug */
    uchar   iponly[IPaddrlen];      /* ip address to print debugging for */
    int iponlyset;

    QLock;
    Rendez;
};
@



% ipattach -> ... -> <>
<<function netloginit>>=
void
netloginit(Fs *f)
{
    f->alog = smalloc(sizeof(Netlog));
}
@

<<[[Qid]] toplevel extra cases>>=
Qlog,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qlog:
    p = "log";
    break;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qlog:
    netlogopen(f);
    break;
@
<<[[ipclose()]] switch TYPE qid cases>>=
case Qlog:
    if(c->flag & COPEN)
        netlogclose(f);
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qlog:
    return netlogread(f, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qlog:
    netlogctl(f, a, n);
    return n;
@


<<function netlogopen>>=
void
netlogopen(Fs *f)
{
    lock(f->alog);
    if(waserror()){
        unlock(f->alog);
        nexterror();
    }
    if(f->alog->opens == 0){
        if(f->alog->buf == nil)
            f->alog->buf = malloc(Nlog);
        if(f->alog->buf == nil)
            error(Enomem);
        f->alog->rptr = f->alog->buf;
        f->alog->end = f->alog->buf + Nlog;
    }
    f->alog->opens++;
    unlock(f->alog);
    poperror();
}
@


<<function netlogread>>=
long
netlogread(Fs *f, void *a, ulong, long n)
{
    int i, d;
    char *p, *rptr;

    qlock(f->alog);
    if(waserror()){
        qunlock(f->alog);
        nexterror();
    }

    for(;;){
        lock(f->alog);
        if(f->alog->len){
            if(n > f->alog->len)
                n = f->alog->len;
            d = 0;
            rptr = f->alog->rptr;
            f->alog->rptr += n;
            if(f->alog->rptr >= f->alog->end){
                d = f->alog->rptr - f->alog->end;
                f->alog->rptr = f->alog->buf + d;
            }
            f->alog->len -= n;
            unlock(f->alog);

            i = n-d;
            p = a;
            memmove(p, rptr, i);
            memmove(p+i, f->alog->buf, d);
            break;
        }
        else
            unlock(f->alog);

        sleep(f->alog, netlogready, f);
    }

    qunlock(f->alog);
    poperror();

    return n;
}
@


<<function netlogctl>>=
void
netlogctl(Fs *f, char* s, int n)
{
    int i, set;
    Netlogflag *fp;
    Cmdbuf *cb;
    Cmdtab *ct;

    cb = parsecmd(s, n);
    if(waserror()){
        free(cb);
        nexterror();
    }

    if(cb->nf < 2)
        error(Ebadnetctl);

    ct = lookupcmd(cb, routecmd, nelem(routecmd));

    SET(set);

    switch(ct->index){
    case CMset:
        set = 1;
        break;

    case CMclear:
        set = 0;
        break;

    case CMonly:
        parseip(f->alog->iponly, cb->f[1]);
        if(ipcmp(f->alog->iponly, IPnoaddr) == 0)
            f->alog->iponlyset = 0;
        else
            f->alog->iponlyset = 1;
        free(cb);
        poperror();
        return;

    default:
        cmderror(cb, "unknown netlog control message");
    }

    for(i = 1; i < cb->nf; i++){
        for(fp = flags; fp->name; fp++)
            if(strcmp(fp->name, cb->f[i]) == 0)
                break;
        if(fp->name == nil)
            continue;
        if(set)
            f->alog->logmask |= fp->mask;
        else
            f->alog->logmask &= ~fp->mask;
    }

    free(cb);
    poperror();
}
@

\section{[[/bin/snoopy]]}
% useful only to debug network stack? or could be considered
% a Debugging Support chapter?

\subsection{/net/ipifc/x/snoop}

<<[[Qid]] conversation extra cases>>=
Qsnoop,
@

<<[[Conv(kernel)]] snoop fields>>=
Ref snoopers;   /* number of processes with snoop open */
Queue*  sq;     /* snooping queue */
@
% those fields are valid only for /net/ipifc/x/snoop?


<<[[ip3gen()]] switch TYPE qid cases>>=
case Qsnoop:
    if(strcmp(cv->p->name, "ipifc") != 0)
        return -1;
    devdir(c, q, "snoop", qlen(cv->sq), cv->owner, 0400, dp);
    return 1;
@
% size = stop queue?

<<[[ipread()]] switch TYPE qid cases>>=
case Qsnoop:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->sq, a, n);
@


<<[[ipopen()]] switch TYPE qid cases>>=
case Qsnoop:
    if(omode != OREAD)
        error(Eperm);
    p = f->p[PROTO(c->qid)];
    cv = p->conv[CONV(c->qid)];
    if(strcmp(ATTACHER(c), cv->owner) != 0 && !iseve())
        error(Eperm);
    incref(&cv->snoopers);
    break;
@
<<[[ipclose()]] switch TYPE qid cases>>=
case Qsnoop:
    if(c->flag & COPEN)
        decref(&f->p[PROTO(c->qid)]->conv[CONV(c->qid)]->snoopers);
    break;
@




\subsection{[[/bin/snoopy]]}


<<function printusage>>=
void
printusage(void)
{
    fprint(2, "usage: %s [-CDdpst] [-N n] [-f filter] [-h first-header] path\n", argv0);
    fprint(2, "  for protocol help: %s -? [proto]\n", argv0);
}
@

<<function usage (networking/ip/snoopy/main.c)>>=
void
usage(void)
{
    printusage();
    exits("usage");
}
@


\section{[[/net/x/stats]]}

% /net/ipifc/stats
% /net/icmp/stats
% /net/tcp/stats

\chapter{Profiling}

% /net/x/stats? hmm it's more for user than for programmer of the
% network stack itself, but yes it can be useful too.

\chapter{Error Managment}

\chapter{Ethernet Intel Pro/1000 Driver}

\chapter{Libc}

\section{Globbing}

% a few things have a format accepting "*"

\chapter{Extra Mediums}

\section{Null medium}

<<global nullmedium>>=
Medium nullmedium =
{
    .name=      "null",

    .bind=      nullbind,
    .unbind=    nullunbind,
    .bwrite=    nullbwrite,
};
@

<<function nullbind>>=
static void
nullbind(Ipifc*, int, char**)
{
    error("cannot bind null device");
}
@

<<function nullunbind>>=
static void
nullunbind(Ipifc*)
{
}
@

<<function nullbwrite>>=
static void
nullbwrite(Ipifc*, Block*, int, uchar*)
{
    error("nullbwrite");
}
@

<<function nullmediumlink>>=
void
nullmediumlink(void)
{
    addipmedium(&nullmedium);
}
@

\section{Point to point serial line}

\section{Token ring}
% alternative to ethernet


\chapter{Extra Protocols}

\section{ICMP}
% for ping

\section{RUDP}

\section{GRE}

\section{ESP}

\section{Datakit and URP}


\chapter{Extra Code}

\ifallcode
#include "Network_extra.nw"
#include "Network_v6.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

