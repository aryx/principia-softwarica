\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - untangled all those features, multicast, broadcast, with those big
%    structures that were hard to understand.
% - use cv not c for conversation, less confusing with channel, use err
%   not p, use err not s, ...
% - use Idle, not 0 when can, use V4 not 4,
% - removed deadcode: /net/bootp,  Ipifc fields (unbinding, idlock, ...),
%   Conv (length, car, headers, reliable, ...)
% - TODO introduce ipv4, ipaddr typedefs?

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand networking:
% - TODO ether, ip, udp, tcp, actually I didn't know 
%   that much about network
% - realize that having 2 ip interfaces is essential, not a feature, because
%   for internetworking to work you need gateways that connect 2 separate
%   network, and so this machine will have 2 interfaces
% - TODO does not need much to configure initially; can do things manually
%   without ipconfig and actually you need to do very few things
% - TODO ping, I never understood how it worked, and also
%   why it does not work right now under plan9! I can't ping www.google.com
%   IP
% - TODO ppp?


%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - SEMI  understand main(), LP split main, improve TOC
% - SEMI  understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for ?

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Network Stack [[/net/]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Dave Presotto and Phil Winterbottom\\
% more?
}


\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a network stack.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item XINU
\item Linux
\item FreeBSD
% FreeBSD have strong reputation regarding its network stack
\item Minix
\end{itemize}

%meh:
%http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/

\section{Getting started}


\section{Requirements}

% Tannenbaum computer networks book?
% Computer networks, a top-down approach?
% tcp/ip ...?
%ref: "packet communication" from the same collection that lion's book


%Intro to computer networks (free, but maybe not that good)
%http://intronetworks.cs.luc.edu/

% "The organization of networks in plan9".ps
% il.ps
% ip(8?)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Network principles}

% local (mac) address, ethernet, local area network
%  write to all, snoop and take when for your (mac) address
% old: ipx?

% packets! and actually whole idea of network abstraction is to
% provide what seems like an arbitrary length or even continuous stream
% of data on top of this fixed packet. A bit similar to file and fs
% which are on top of disk blocks.

% need packets for ethernet as you write to everybody on the "backbone",
% and need fairness.


\section{Internetworking principles}

% ip universal address, inter network, routing, gateway, multiple interfaces
% (packets become really useful there because big sharing)

% gateways are really important, and so is having multiple IPs.

% tcp: because route can be complex, and can use different routes,
% so can arrive in different order, so need protocol, ack, retransmit,
% reorder, etc. Tricky.

\section{Network stack principles}

% ip stack goal is to multiplex access to network device?
% and then to demultiplex when receive (by address, by protocol)
% and to provide different encoding protocols providing different
% kinds of services

\section{[[/net]] services}

% In plan9 every kernel service is implemented as a file server.
% Everything is a file. So a connexion to a remote machine is
% a file in plan9 (in unix it's a socket, which is a kind of file,
% it has a fd, and can even be on the fs sometimes).
% In unix configure the file/socket via ioctl. In plan9 it's
% via the fs and via a control file. /net/<proto>/<conv>/ctl

% see 'network plan9'.ps

% /net/ether0/addr
% /net/ipfc/clone and then /net/ipfc/x/ctl
% /net/arp
% /net/iproute

% maybe can put early the 
%    echo 'bind ether /net/ether0' > /net/ipifc/x/ctl
% and then 
%    echo 'add 10.0.0.15' > /net/ipifc/x/ctl
% enough? need also to write arp no? and a few routes?

% /net/<proto>/<conv>/ for the most part.

%todo: then how initiate connexion manually? using just the shell!
% echo 'connect ???' > /net/udp/clone ? then cat /net/udp/x/data ?
% and somewhere echo in udp?
% can emulate named pipe?

% then when have a gateway, will have 2 ifc, 2 mediums, 2 ips


%note: The network ip stack is served as a file server in plan9, and
% so it can be mounted too on another machine. But what's the point?
% If can mount it on another machine that means that machine has
% a network capacity, so why it would need another ip stack? Because
% for configuration purpose? can have a workstation with basic network
% and then import another ip stack that has a more complex configuration!

\section{[[ping]], [[traceroute]], etc}

\section{Code organization}

% include/ip.h
% lib_networking/libip/
% kernel/network/, devip, devether, udp.c, tpc.c, and etherigbe.c
% networking/...

\section{Software architecture}

% physical (e.g. ethernet), kernel (devip+ether), lib(dial), apps (e.g. telnetd)
% and on the other side
% physical (e.g. ethernet), kernel (devip+ether), lib(listen), apps (e.g. telnet)

% client/server but in the end really something reading from a file
% and something writing to the file. In essence network comm is
% like reading/writing to a file, except the file represent a connection
% to somewhere else, not a local file.

% link-layer: ethernet, (arp, ... aoe)
% network-layer: ip (routing, icmp?)
% transport-layer: (udp, tcp, il, ... )
% "applications" protocol (dhcp, dns, telnetd, http, imap, ...)
% actual applications (telnet, ping, ftp, ...)

% encapsulation each time, more headers each time.

% packet vs frame vs stream

% Proto vs Fs vs Ipifc vs Netif

% OO like interface, with class and methods, and some private
% fields.

% f = /net fs
% cv = conversation
% c = channel (TODO or conversation sometimes, but we should rename them)
% p = protocol (TODO or err sometimes, but we should rename them)
% err = error string

\section{Trace of a ping}

\section{Trace of a network write}

\section{Trace of a network read}

%\section{Trace of an RPC}

%###############################################################################

\chapter{Core Data Structures}

\section{Universal identifier, IP addresses}
% machine identifier

% universal 
%note: (later in HTTP section we will see URL, even more general)
% inter-network

%less: typedef uchar ippart ? 
% typedef uchar[16] ip? typedef uchar[4] ipv4
% cast automatically to uchar* ?

<<constant IPv4addrlen>>=
IPv4addrlen=	4,
@
% this will be used for the IP address in the actual header and frame formats


<<constant IPaddrlen>>=
IPaddrlen=	16,
@
% this is used internally to store addresses, to be the more general.
% 16 bytes IP(v6) address
% ex of address? facebook adress? 2a03:2880:2110:df07:face:b00c:0:1:



\subsection{IPv4 vs IPv6}

<<global v4prefix>>=
/*
 *  prefix of all v4 addresses
 */
uchar v4prefix[IPaddrlen] = {
    // first 12
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,

    // rest are ipv4 numbers
    0, 0, 0, 0
};
@

<<constant IPv4off>>=
IPv4off=	12,
@

<<function isv4>>=
bool
isv4(uchar *ip)
{
    return memcmp(ip, v4prefix, IPv4off) == 0;
}
@
% first 12 must be identical to v4prefix

<<function v4tov6>>=
/*
 *  the following routines are unrolled with no memset's to speed
 *  up the usual case
 */
void
v4tov6(uchar *v6, uchar *v4)
{
    v6[0] = 0;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v6[5] = 0;
    v6[6] = 0;
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    v6[10] = 0xff;
    v6[11] = 0xff;
    v6[12] = v4[0];
    v6[13] = v4[1];
    v6[14] = v4[2];
    v6[15] = v4[3];
}
@

<<function v6tov4>>=
errorneg1
v6tov4(uchar *v4, uchar *v6)
{
    if(v6[0] == 0
    && v6[1] == 0
    && v6[2] == 0
    && v6[3] == 0
    && v6[4] == 0
    && v6[5] == 0
    && v6[6] == 0
    && v6[7] == 0
    && v6[8] == 0
    && v6[9] == 0
    && v6[10] == 0xff
    && v6[11] == 0xff)
    {
        v4[0] = v6[12];
        v4[1] = v6[13];
        v4[2] = v6[14];
        v4[3] = v6[15];
        return OK_0;
    } else {
        memset(v4, 0, 4);
        if(memcmp(v6, IPnoaddr, IPaddrlen) == 0)
            return OK_0;
        return ERROR_NEG1;
    }
}
@
% used in code setting up the header, by passing the
% pointer to the address in the header as first argument
% and the cv->laddr or cv->raddr as second argument.

\subsection{Class and network identifier}

% "conceptually an internet address is a pair (netid, hostid)
% where netid identifies a network, and hostid identifies a host
% on that network" xinu book

% tricky encoding, ip address can refer to network, convention
% to never use 0, so 10.0.2.0 means the network

<<macro CLASS>>=
#define CLASS(p) ((*(uchar*)(p))>>6)
@
% ?? first 2 bits of first number in IP?

\subsection{Network mask}

% return ipv6
<<function defmask>>=
uchar*
defmask(uchar *ip)
{
    if(isv4(ip))
        return classmask[ip[IPv4off]>>6];
    <<[[defmask()]] if ipv6>>
}
@
%less: why not use CLASS? instead of >>6 above?

<<global classmask>>=
static uchar classmask[4][16] = {
    // class A
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0x00,0x00,0x00, // 255.0.0.0
    // class A
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0x00,0x00,0x00, // 255.0.0.0
    // class B
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0xff,0x00,0x00, // 255.255.0.0
    // class C
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0xff,0xff,0x00, // 255.255.255.0
};
@
% class use 2 bits, so 4 entries, (but 00 and 01 are for class A)
% 255.255.etc
% use IPADDRLen instead of 16?
%less: could do nested { }, [0] = { }, [1] = { } ...


<<function maskip>>=
void
maskip(uchar *from, uchar *mask, uchar *to)
{
    int i;

    for(i = 0; i < IPaddrlen; i++)
        to[i] = from[i] & mask[i];
}
@

% netid = ip & mask.


\subsection{Other operations}
%Reset, move, comparison

% used a lot to reset an address
<<global IPnoaddr>>=
uchar IPnoaddr[IPaddrlen];
@
%    ipmove(cv->laddr, IPnoaddr);

<<macro ipmove (kernel/network/ip/ip.h)>>=
#define ipmove(x, y) memmove(x, y, IPaddrlen)
@

<<macro ipcmp (kernel/network/ip/ip.h)>>=
#define ipcmp(x, y) ( (x)[IPaddrlen-1] != (y)[IPaddrlen-1] || memcmp(x, y, IPaddrlen) )
@
% first part is opti? fastest path is last elt of address is different?




%\subsection{Forme} ?

\section{IP Interfaces, [[Ipifc]]}
% 's', for gateways

% /net/ipifc/...

% this will associate an IP (logical address) to a 
% physical device (physical address)


\subsection{User side}

% how used by programmer? readipifc()?
% hmm but not that useful in practice no? or because dial uses that?
% Need that to know who you are ... like hostname?

% /net/ipifc/x/stats?
% in ip.h
<<struct Ipifc (user)>>=
/* actual interface */
struct Ipifc
{
    /* per ip interface */

    char	dev[64]; // e.g. "/net/ether0"
    int	mtu;
    // list<ref_own<Iplifc> (next = Iplifc.next)
    Iplifc	*lifc;

    <<[[Ipifc(user)]] stat fields>>
    <<[[Ipifc(user)]] ipv6 fields>>

    //Extra
    <<[[Ipifc(user)]] extra fields>>
};
@
% echo 'bind ether /net/ether0' > /net/ipifc/x/ctl
% what is inside dev[64]? /net/ether0

<<[[Ipifc(user)]] stat fields>>=
ulong	pktin;
ulong	pktout;
ulong	errin;
ulong	errout;
@


<<[[Ipifc(user)]] extra fields>>=
Ipifc	*next;
@
% readipifc can return the list of all interfaces.
% We will need this for gateways which have multiple interfaces, multiple IPs
% connecting two separate networks.

<<[[Ipifc(user)]] extra fields>>=
int	index;			/* number of interface in ipifc dir */
@


<<struct Iplifc (user)>>=
/* local address */
struct Iplifc
{
    /* per address on the ip interface */
    uchar	ip[IPaddrlen];
    uchar	mask[IPaddrlen];
    uchar	net[IPaddrlen];		/* ip & mask */

    <<[[Iplifc(user)]] ipv6 fields>>

    // Extra
    <<[[Iplifc(user)]] extra fields>>
};
@
% finally an IP! our IP
%less: local? or logical?
% echo 'add <localip>' > /net/ipicf/x/ctl

%less: can have multiple IP connected to same device? what for?
<<[[Iplifc(user)]] extra fields>>=
// list<ref_own<Iplifc>>, head = Ipifc.lifc
Iplifc	*next;
@


\subsection{Kernel side}

%todo: who points to that in the kernel? actually there is no single
% ipifc global in the kernel because a machine can have multiple ips
% (e.g. a gateway), and so the user access the one he wants via
% /net/ipifc/ and the ipifc is part of a route.
% in Route there is a Ipifc! returned via v4lookup()
%todo: OK but when go to /net/tcp/clone, get which interface??

% in fact gateways are essential to the internet, they are the one
% that makes possible to have intern-networking, so having
% multiple interface and multiple IPs is not a nice feature to have,
% it's essential. One can't provide a network stack without support
% for gateways.

<<struct Ipifc (kernel)>>=
struct Ipifc
{
  char  dev[64];  /* device we're attached to */

  Medium  *m;   /* Media pointer */
  uchar mac[MAClen];  /* MAC address */
  void  *arg;   /* medium specific */

  int maxtu;    /* Maximum transfer unit */
  int mintu;    /* Minumum tranfer unit */
  int mbps;   /* megabits per second */

  // list<ref_own<Iplifc>>, next = Iplifc.next
  Iplifc  *lifc;    /* logical interfaces on this physical one */

  <<[[Ipifc(kernel)]] stat fields>>
  <<[[Ipifc(kernel)]] routing fields>>
  <<[[Ipifc(kernel)]] ipv6 fields>>
  <<[[Ipifc(kernel)]] other fields>>

  //Extra
  RWlock;

};
@
%less: have a priv field for medium arg private pointer?


<<[[Ipifc(kernel)]] stat fields>>=
/* message statistics */
ulong in;
ulong out;  
ulong inerr;
ulong outerr;
@

<<[[Ipifc(kernel)]] other fields>>=
Conv  *conv;    /* link to its conversation structure */
@
% /net/ipfc/x/...
% will see later, but in ipifcadd can then do  f = ifc->conv->p->f;



%dead:  <<[[Ipifc(kernel)]] other fields>>=
% bool unbinding;
%/* these are used so that we can unbind on the fly */
% Lock  idlock;
% int ref;    /* number of proc's using this ipifc */
% Rendez  wait;   /* where unbinder waits for ref == 0 */







<<struct Iplifc (kernel)>>=
/* logical interface associated with a physical one */
struct Iplifc
{
  uchar local[IPaddrlen];
  uchar mask[IPaddrlen];
  uchar net[IPaddrlen]; // local & mask?

  uchar remote[IPaddrlen]; // ??

  <<[[Iplifc(kernel)]] ipv6 fields>>

  // Extra
  <<[[Iplifc(kernel)]] extra fields>>
};
@
% local = ip?
% remote??

<<[[Iplifc(kernel)]] extra fields>>=
// list<ref_own<Iplifc>>, head = Ipifc.lifc
Iplifc  *next;
@



%XXX
<<[[Iplifc(kernel)]] extra fields>>=
Iplink  *link;    /* addresses linked to this lifc */
@



\section{Physical link [[Medium]], and [[media]]}

% e.g. for ethernet
% see later: null, loopback, packet

% see that it's pointed by Ipifc above

<<struct Medium (kernel)>>=
struct Medium
{
  char  *name;

  int hsize;    /* medium header size */
  int mintu;    /* default min mtu */
  int maxtu;    /* default max mtu */

  int maclen;   /* mac address length  */

  <<[[Medium(kernel)]] methods>>

  <<[[Medium(kernel)]] other fields>>

};
@
% char**? array of string? to pass parameters to bind? e.g. path
% in 'bind ether /net/ether0' ?

%bwrite!! that's where you write the data! note that pass just ip,
% no port here, we are at IP layer. Has to be scheduled as can have
% many processes wanting to write to the medium
%pktin!! that's where you read packets from the network, which has to
% be routed to the right place, how?? Has to be decomposed and dispatched
% so need a global map of ip+port info.

%% ipwrite (Ctl case) -> bindctlmsg -> ipifcbind -> <> 
%     (as m->find <- ipfindmedium <- media[i] <- ???)
% void  (*bind)(Ipifc*, int, char**);


<<[[Medium(kernel)]] methods>>=
<<[[Medium(kernel)]] binding methods>>
<<[[Medium(kernel)]] io methods>>
<<[[Medium(kernel)]] address resolution methods>>
<<[[Medium(kernel)]] route methods>>
<<[[Medium(kernel)]] multicast methods>>
<<[[Medium(kernel)]] ipv6 methods>>
@

<<[[Medium(kernel)]] binding methods>>=
void  (*bind)(Ipifc*, int, char**);
void  (*unbind)(Ipifc*);
@

<<[[Medium(kernel)]] io methods>>=
// write packets on the physical network
void  (*bwrite)(Ipifc *ifc, Block *b, int version, uchar *ip);
/* process packets written to 'data' */
void  (*pktin)(Fs *f, Ipifc *ifc, Block *bp);
@

<<global media>>=
Medium *media[Maxmedia] = { 0 };
@
<<constant Maxmedia>>=
Maxmedia    = 32,
@

% ?? -> <>  ? qemu.c links() and ethermediumlink?
<<function addipmedium>>=
/*
 *  link in a new medium
 */
void
addipmedium(Medium *med)
{
    int i;

    for(i = 0; i < nelem(media)-1; i++)
        if(media[i] == nil){
            media[i] = med;
            break;
        }
}
@
% no warning if overflow?
%less: boilerplate code, should have a generic function for that




%\subsection{Ethernet medium}

%\subsection{Null medium}


\section{[[/net]] filesystem}


\subsection{[[Fs]]}
% rename? Slashnetfs?
% file system. For /net/ essentially

<<struct Fs (kernel)>>=
/*
 *  one per IP protocol stack
 */
struct Fs
{
  // array<option<ref_own<Proto>>>, size is Fs.np
  Proto*  p[Maxproto+1];    /* list of supported protocols */
  int np;

  IP  *ip;

  <<[[Fs(kernel)]] arp fields>>
  <<[[Fs(kernel)]] routing fields>>
  <<[[Fs(kernel)]] ndb fields>>
  <<[[Fs(kernel)]] logging fields>>
  <<[[Fs(kernel)]] ipv6 fields>>
  <<[[Fs(kernel)]] other fields>>
 
  // Extra
  RWlock;
  <<[[Fs(kernel)]] extra fields>>
};
@
% >> >> >>
% why +1? because don't use first entry? because QID trick?

%TODO: where is the info about ipifc? about the medium?

<<constant Maxproto>>=
Maxproto= 20,
@







\subsection{[[ipfs]]}

<<global ipfs>>=
Fs  *ipfs[Nfs]; /* attached fs's */
@

<<constant Nfs>>=
Nfs=        128,
@
% Nb filesystem (not network file system)
% in practice will have only one IP stack/fs, so Fs.dev will be 0
%less: (so not sure you need such a big number ...)
%todo: when need to have multiple protocol stack?

<<[[Fs(kernel)]] extra fields>>=
int dev; // idx in ipfs
@

<<global fslock>>=
QLock   fslock;
@
% to access ipfs?

\subsection{[[IP]]}

%todo: rename, bad name
<<struct IP (kernel)>>=
/* an instance of IP */
struct IP
{
  Fragment4*  flisthead4;
  Fragment4*  fragfree4;

  Ref   id4;

  <<[[IP(kernel)]] stat fields>>
  <<[[IP(kernel)]] routing fields>>
  <<[[IP(kernel)]] ipv6 fields>>

  // Extra
  QLock   fraglock4;
};
@
% id4 will be IP packet identifier, incremented each time
% (why need an id??)

% Fragments because idea of IP is to have packets, and so if
% one tried to send too big data, it's splitted in multiple
% packets, and the IP stack will then reassemble them
% (but this is different from TCP, because here it's done
% in one hop, so it's reliable. No reordering needed, the fragments
% will arrive in order).

<<struct Fragment4>>=
struct Fragment4
{
  Block*  blist;

  ulong   src;
  ulong   dst;

  ushort  id;
  ulong   age;

  // Extra
  Fragment4*  next;
};
@
% ulong for src and dst? ports? fragment number?


<<[[IP(kernel)]] stat fields>>=
// map<enum<mib_two_counters>, uvlong>
uvlong    stats[Nipstats];
@

%https://tools.ietf.org/html/rfc4293
<<enum _anon_ (kernel/network/ip/ip.h)3>>=
/* MIB II counters */
enum mib_two_counters
{
  Forwarding,
  DefaultTTL,

  InReceives,

  InHdrErrors,
  InAddrErrors,
  ForwDatagrams,
  InUnknownProtos,

  // In stats
  InDiscards,
  InDelivers,

  // Out stats
  OutRequests,
  OutDiscards,
  OutNoRoutes,

  ReasmTimeout,
  ReasmReqds,
  ReasmOKs,
  ReasmFails,

  // Out fragments
  FragOKs,
  FragFails,
  FragCreates,

  Nipstats,
};
@
% can C-s those things to find interesting places
%less: reorder, show important one

<<global statnames>>=
static char *statnames[] =
{
[Forwarding]    "Forwarding",
[DefaultTTL]    "DefaultTTL",
[InReceives]    "InReceives",
[InHdrErrors]   "InHdrErrors",
[InAddrErrors]  "InAddrErrors",
[ForwDatagrams] "ForwDatagrams",
[InUnknownProtos]   "InUnknownProtos",

[InDiscards]    "InDiscards",
[InDelivers]    "InDelivers",

[OutRequests]   "OutRequests",
[OutDiscards]   "OutDiscards",
[OutNoRoutes]   "OutNoRoutes",

[ReasmTimeout]  "ReasmTimeout",
[ReasmReqds]    "ReasmReqds",
[ReasmOKs]  "ReasmOKs",
[ReasmFails]    "ReasmFails",

[FragOKs]   "FragOKs",
[FragFails] "FragFails",
[FragCreates]   "FragCreates",
};
@




\subsection{[[Proto]]cols}

% /net/<proto>/

<<struct Proto (kernel)>>=
/*
 *  one per multiplexed protocol
 */
struct Proto
{
  char*   name;   /* protocol name */ // e.g. "udp", "tcp", etc

  <<[[Proto(kernel)]] methods>>

  // growing_array<option<ref_own<Proto>>>, size = Proto.nc
  Conv    **conv;   /* array of conversations */
  int   nc;   /* number of conversations */
  int   ac; // number of opened conversations

  <<[[Proto(kernel)]] priv fields>>
  <<[[Proto(kernel)]] other fields>>

  // Extra
  QLock;
  <<[[Proto(kernel)]] extra fields>>
};
@



<<[[Proto(kernel)]] extra fields>>=
// ref<Fs>, reverse of Fs.p[this.x]
Fs    *f;   /* file system this proto is part of */
// index in Fs.p[]
int   x;    /* protocol index */
@
% (x is useful when building qid)
% so get access to its ip stack via f so can access the method of the
% ip stack and medium!


% Actually  /net/ipifc/ will be a protocol itself! with a clone
% and then with a conversation. Very general scheme.

<<[[Proto(kernel)]] other fields>>=
Qid   qid;    /* qid for protocol directory */
@
% need that?


<<[[Proto(kernel)]] priv fields>>=
void    *priv;
@



<<[[Proto(kernel)]] methods>>=
<<[[Proto(kernel)]] protocol methods>>
<<[[Proto(kernel)]] conversation ctl methods>>
<<[[Proto(kernel)]] conversation inspection methods>>
<<[[Proto(kernel)]] conversation methods>>
@


% sysopen(/net/<proto>/clone) -> ... -> ipopen -> Fsprotoclone -> <>
<<[[Proto(kernel)]] protocol methods>>=
void    (*create)(Conv*);
@
% Take the conversation created, so can adjust its structure.
% Kinda of a ctor. Create() will setup a callback (xxxkick) on the
% writing queue which will add the header before the data to send.
% So create is kinda a (*send) method too.
% void xxxkick(Conv *cv, Block *bp)

% ipclose -> closeconv -> <>
<<[[Proto(kernel)]] protocol methods>>=
void    (*close)(Conv*);
@

% ??? -> ipiput4 -> <>
<<[[Proto(kernel)]] conversation methods>>=
void    (*rcv)(Proto*, Ipifc*, Block*);
@

%syswrite("connect", /net/<proto>/<conv>/ctl) -> ... -> ipwrite -> ... -> <>
<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*connect)(Conv*, char**, int);
char*   (*announce)(Conv*, char**, int);
@
<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*ctl)(Conv*, char**, int);
@
% if protocol specific ctl message, call this general handler,
% e.g. when do 'add ...' for /net/ipifc/x/ctl

%syswrite("bind ...", /net/<proto>/<conv>/ctl) -> ... -> ipwrite -> ... -> <>
<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*bind)(Conv*, char**, int);
@
%less: method only for ipifc?


% will introduce other methods later.


\subsection{[[Conv]]ersations}

% /net/<proto>/<conv>/

% A bit like a Channel (accessed indirectly via Chan->dev, ipfs and the qid)
% Big structure ... a bit like Proc for Kernel.nw, central structure.
<<struct Conv (kernel)>>=
/*
 *  one per conversation directory
 */
struct Conv
{

  uchar laddr[IPaddrlen]; /* local IP address */
  uchar raddr[IPaddrlen]; /* remote IP address */

  ushort  lport;      /* local port number */
  ushort  rport;      /* remote port number */

  char  *owner;     /* protections */
  int perm;

  // enum<conversation_state>
  int state;

  <<[[Conv(kernel)]] queue fields>>
  <<[[Conv(kernel)]] listen fields>>
  <<[[Conv(kernel)]] routing fields>>
  <<[[Conv(kernel)]] multicast fields>>
  <<[[Conv(kernel)]] snoop fields>>
  <<[[Conv(kernel)]] priv fields>>
  <<[[Conv(kernel)]] udp fields>>
  <<[[Conv(kernel)]] error fields>>
  <<[[Conv(kernel)]] other fields>>
  <<[[Conv(kernel)]] ipv6 fields>>

  // Extra
  QLock;
  <<[[Conv(kernel)]] extra fields>>
};
@
% ip + port = is enough to establish a connexion
% need ip + port in general
% ipA!portA <-> ipB!portB



% but actually Conv is general and (ab)used also for ipifc.
% It's an overlay over channel with network related information.


<<[[Conv(kernel)]] extra fields>>=
// ref<Proto> reverse of Proto.conv[this.x]
Proto*  p;
// index in Proto.conv[]
int x;      /* conversation index */
@
% (x is useful when building qid)
% so can get "class" via p so can access the method of the protocol from
% a Conv


<<enum _anon_ (kernel/network/ip/ip.h)2>>=
enum conversation_state
{
  Idle=   0,

  Announcing= 1,
  Announced=  2,

  Connecting= 3,
  Connected=  4,
};
@


<<[[Conv(kernel)]] queue fields>>=
Queue*  rq;     /* queued data waiting to be read */
Queue*  wq;     /* queued data waiting to be written */
@
% setup in each create() method of each Proto
% will be accessed via /net/x/y/data

% conversation are two ways? can read and write in /net/x/y/data?


<<[[Conv(kernel)]] queue fields>>=
Queue*  eq;     /* returned error packets */
@
% setup in Fsprotoclone generically
<<[[Conv(kernel)]] error fields>>=
char  cerr[ERRMAX];
@


<<[[Conv(kernel)]] other fields>>=
Rendez  cr;
@
% e.g. when connect, need to sleep until someone connects
% with you (via an announce), so will sleep on that.

<<[[Conv(kernel)]] priv fields>>=
void* ptcl;     /* protocol specific stuff */
@
% e.g. Ipifc ! when have a conversation with /net/ipifc/x/ctl
<<[[Proto(kernel)]] priv fields>>=
int   ptclsize; /* size of per protocol ctl block */
@



<<[[Conv(kernel)]] other fields>>=
int inuse;      /* opens of listen/data/ctl */
@
% set to 1 in clone, incremented after each additional open




%dead
%<<[[Conv(kernel)]] other fields>>=
%int length;
%QLock car;
%@




\subsection{Chan Qid, [[PROTO()]], [[CONV()]], [[QID()]]}

% In the end everything is a file in plan9, so connexion/sockets
% will be channel with a qid in /net/.
% Have a qid scheme to encode the type of channel.

<<enum qid (kernel/network/ip/devip.c)>>=
enum
{
    Qtopdir=    1,      /* top level directory */

    Qtopbase,
    Qarp=       Qtopbase,
    Qiproute,
    <<[[Qid]] toplevel extra cases>>

    Qprotodir,          /* directory for a protocol */
    Qprotobase,
    Qclone=     Qprotobase,
    <<[[Qid]] protocol extra cases>>

    Qconvdir,           /* directory for a conversation */
    Qconvbase,
    Qctl=       Qconvbase,
    Qdata,
    <<[[Qid]] conversation extra cases>>
    <<[[Qid]] conversation extra cases, last entry>>
};
@

%FIGURE: qid with different bits for different parts
% 5 bits for type, 12 bits for conversation, 8 bits for proto
% => 25 bits

%many of those chans will really behave like a socket.


<<enum misc (kernel/network/ip/devip.c)>>=
enum
{
    Logtype=    5,
    Masktype=   (1<<Logtype)-1,

    Logconv=    12,
    Maskconv=   (1<<Logconv)-1,
    Shiftconv=  Logtype,

    Logproto=   8,
    Maskproto=  (1<<Logproto)-1,
    Shiftproto= Logtype + Logconv,

    <<constant Nfs>>
};
@
% >> >> >> >>


% given a channel qid we can quickly identify its "property" that
% is where it comes from. For instance the channel qid of /net/tcp/0/...
% will be a certain integer and we can access to its protocol with
% PROTO() and its conversation with CONV(), and final "type" with TYPE

% ctor
<<macro QID>>=
#define QID(p, cv, y)    ( ((p)<<(Shiftproto)) | ((cv)<<Shiftconv) | (y) )
@
% >> >>

% in ip3gen()
%    cv = ipfs[c->dev]->p[PROTO(c->qid)]->conv[CONV(c->qid)];

% with Chan.dev        => access Fs     (ipfs[c->dev])
% with PROTO(Chan.qid) => access Proto  (...) 
% with CONV(Chan.qid)  => Access Conv   (...)



% getters
<<macro PROTO>>=
#define PROTO(x)    ( (((ulong)(x).path) >> Shiftproto) & Maskproto )
@
% /net/x (tcp, udp, etc)
<<macro CONV>>=
#define CONV(x)     ( (((ulong)(x).path) >> Shiftconv) & Maskconv )
@
% /net/.../x

<<macro TYPE>>=
#define TYPE(x)     ( ((ulong)(x).path) & Masktype )
@
% /net/.../.../x (ctl, data, etc)

% in ipattach()
%    mkqid(&c->qid, QID(0, 0, Qtopdir), 0, QTDIR);
% so means entries 0 are not used in Proto and Conv?








\section{[[/net/ether]] filesystem}

\subsection{[[Netif]]}

<<struct Netif (kernel)>>=
/*
 *  a network interface
 */
struct Netif
{
  /* multiplexing */
  char  name[KNAMELEN];   /* for top level directory */

  // growing_array?<option<ref_own<Netfile>>>
  Netfile **f;
  int nfile;      /* max number of Netfiles */

  /* about net */
  int limit;      /* flow control */
  int alen;     /* address length */
  int mbps;     /* megabits per sec */
  int link;     /* link status */

  int minmtu;
  int maxmtu;
  int mtu;
  uchar addr[Nmaxaddr];
  uchar bcast[Nmaxaddr];


  int prom;     /* number of promiscuous opens */
  int scan;     /* number of base station scanners */
  int all;      /* number of -1 multiplexors */

  /* statistics */
  int misses;
  uvlong  inpackets;
  uvlong  outpackets;
  int crcs;   /* input crc errors */
  int oerrs;    /* output errors */
  int frames;   /* framing errors */
  int overflows;  /* packet overflows */
  int buffs;    /* buffering errors */
  int soverflows; /* software overflow */

  /* routines for touching the hardware */
  void  *arg;

  void  (*promiscuous)(void*, int);
  int (*hwmtu)(void*, int); /* get/set mtu */
  void  (*scanbs)(void*, uint); /* scan for base stations */

  <<[[Netif(kernel)]] multicast fields>>
  <<[[Netif(kernel)]] multicast methods>>

  // Extra
  QLock;

};
@

\subsection{[[Netfile]]}

<<struct Netfile>>=
/*
 *  one per multiplexed connection
 */
struct Netfile
{
  QLock;

  int inuse;
  ulong mode;
  char  owner[KNAMELEN];

  int type;     /* multiplexor type */
  int prom;     /* promiscuous mode */
  int scan;     /* base station scanning interval */
  int bridge;     /* bridge mode */
  int headersonly;    /* headers only - no data */
  uchar maddr[8];   /* bitmask of multicast addresses requested */
  int nmaddr;     /* number of multicast addresses */

  Queue *in;      /* input buffer */

  // Extra
};
@

\section{IP header}

<<struct Ip4hdr>>=
/* on the wire packet header */
struct Ip4hdr
{
  uchar vihl;   /* Version and header length */
  uchar tos;    /* Type of service */
  uchar length[2];  /* packet length */
  uchar id[2];    /* ip->identification */
  uchar frag[2];  /* Fragment information */
  uchar ttl;        /* Time to live */

  // enum<protocol_type>
  uchar proto;    /* Protocol */

  uchar cksum[2]; /* Header checksum */

  uchar src[4];   /* IP source */
  uchar dst[4];   /* IP destination */
};
@
% Do not change the order here!
% id will be IP.id4, incremented in ipoput
% use byte not int, to avoid byte order issues

<<[[Fs(kernel)]] other fields>>=
// map<enum<protocol_type>, ref<Proto>>
Proto*  t2p[256];   /* vector of all protocols */
@
<<[[Proto(kernel)]] other fields>>=
// enum<protocol_type>
int   ipproto;  /* ip protocol type */
@


% so when will receive a packet, we will know to which
% protocol to dispatch.
% It means also you can't have more than 256 Protocols!

\section{Addresses hashtable, [[Ipht]]}
% it's actually (IP|star * port|star)

% another link with Conv!

% used in Udppriv, Ilpriv, presented later when
% a protocol needs to remember the set of open connexions
% and the ip of those connexions so when a packet arrive
% from somewhere, we can know which conversation is associated
% with this connexion.

<<struct Ipht>>=
/*
 *  hash table for 2 ip addresses + 2 ports
 */
struct Ipht
{
  // hash<ipconvhash, ref<Conv>>, next = Iphash.next
  Iphash  *tab[Nipht];

  // Extra
  Lock;
};
@

<<constant Nipht>>=
Nipht=    521,  /* convenient prime */
@

<<struct Iphash>>=
struct Iphash
{
  Conv  *c;
  // enum<matchtype>
  int match;

  // Extra
  Iphash  *next;
};
@
% Conv connexion!

<<enum matchtype>>=
enum matchtype {
  IPmatchexact= 0,  /* match on 4 tuple */

  IPmatchany,   /* *!* */
  IPmatchport,    /* *!port */
  IPmatchaddr,    /* addr!* */
  IPmatchpa,    /* addr!port */
};
@



<<function iphash>>=
/*
 *  hashing tcp, udp, ... connections
 */
ulong
iphash(uchar *sa, ushort sp, uchar *da, ushort dp)
{
    return ((sa[IPaddrlen-1]<<24) ^ (sp << 16) ^ (da[IPaddrlen-1]<<8) ^ dp ) 
      % Nipht; // pad's first network bugfix :)
}
@
% >> >> >>
%bug: was Nhash instead of Nipht :)


% if you want to connect, then need to give exact address and port
% if you announce, then you can give regexps
<<function iphtadd>>=
void
iphtadd(Ipht *ht, Conv *c)
{
    ulong hv;
    Iphash *h;

    hv = iphash(c->raddr, c->rport, c->laddr, c->lport);
    h = smalloc(sizeof(Iphash));
    if(ipcmp(c->raddr, IPnoaddr) != 0)
        h->match = IPmatchexact;
    else {
        if(ipcmp(c->laddr, IPnoaddr) != 0){
            if(c->lport == 0)
                h->match = IPmatchaddr;
            else
                h->match = IPmatchpa;
        } else {
            if(c->lport == 0)
                h->match = IPmatchany;
            else
                h->match = IPmatchport;
        }
    }
    h->c = c;

    lock(ht);
    h->next = ht->tab[hv];
    ht->tab[hv] = h;
    unlock(ht);
}
@

<<function iphtrem>>=
void
iphtrem(Ipht *ht, Conv *c)
{
    ulong hv;
    Iphash **l, *h;

    hv = iphash(c->raddr, c->rport, c->laddr, c->lport);
    lock(ht);
    for(l = &ht->tab[hv]; (*l) != nil; l = &(*l)->next)
        if((*l)->c == c){
            h = *l;
            (*l) = h->next;
            free(h);
            break;
        }
    unlock(ht);
}
@

<<function iphtlook>>=
/* look for a matching conversation with the following precedence
 *  connected && raddr,rport,laddr,lport
 *  announced && laddr,lport
 *  announced && *,lport
 *  announced && laddr,*
 *  announced && *,*
 */
Conv*
iphtlook(Ipht *ht, uchar *sa, ushort sp, uchar *da, ushort dp)
{
    ulong hv;
    Iphash *h;
    Conv *c;

    /* exact 4 pair match (connection) */
    hv = iphash(sa, sp, da, dp);
    lock(ht);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchexact) {
          c = h->c;
          if(sp == c->rport && dp == c->lport
             && ipcmp(sa, c->raddr) == 0 && ipcmp(da, c->laddr) == 0){
              unlock(ht);
              return c;
          }
        }
    }

    /* match local address and port */
    hv = iphash(IPnoaddr, 0, da, dp);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchpa) {
          c = h->c;
          if(dp == c->lport && ipcmp(da, c->laddr) == 0){
              unlock(ht);
              return c;
          }
       }
    }

    /* match just port */
    hv = iphash(IPnoaddr, 0, IPnoaddr, dp);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchport) {
          c = h->c;
          if(dp == c->lport){
              unlock(ht);
              return c;
          }
        }
    }

    /* match local address */
    hv = iphash(IPnoaddr, 0, da, 0);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchaddr) {
          c = h->c;
          if(ipcmp(da, c->laddr) == 0){
              unlock(ht);
              return c;
          }
        }
    }

    /* look for something that matches anything */
    hv = iphash(IPnoaddr, 0, IPnoaddr, 0);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchany) {
          c = h->c;
          unlock(ht);
          return c;
        }
    }
    unlock(ht);
    return nil;
}
@




\section{Route}

<<[[Conv(kernel)]] routing fields>>=
Route *r;     /* last route used */
@

% this is the link with ipifc! From a conv you get an IP
% and via vlookup4 you get a Route which is then linked to an ipifc!
% From there you can then send or receive the data to/from the medium

<<struct Route (kernel)>>=
struct Route
{
  RouteTree;

  union {
    V4route v4;
    <<[[Route]] ipv6 route union case>>
  };

};
@

<<struct V4route>>=
struct V4route
{
  ulong address;
  ulong endaddress;
  uchar gate[IPv4addrlen];
};
@
% ulong address? ip32 bit in host format?
% gateway! then need using ARP to get from ip gateway to MAC gateway!



<<struct RouteTree (kernel)>>=
struct  RouteTree
{
  // bitset<enum<route_type> >
  uchar type;

  Ipifc *ifc; // !!!

  <<[[Routetree]] other fields>>

  // Extra
  Route*  right;
  Route*  left;
  Route*  mid;

};
@
% those are Route*, not RouteTree
%todo: why not move those fields in the Route instead?
% anyway it's an inlined structure but it would be clearer I think

%XXX
<<[[Routetree]] other fields>>=
  uchar depth;
  char  tag[4];
  int ref;
@


<<enum _anon_ (kernel/network/ip/ip.h)6>>=
enum route_type
{
  /* type bits */
  Rv4=    (1<<0),   /* this is a version 4 route */
  Rifc=   (1<<1),   /* this route is a directly connected interface */
  Rptpt=    (1<<2),   /* this route is a pt to pt interface */

  Runi=   (1<<3),   /* a unicast self address */

  Rbcast=   (1<<4),   /* a broadcast self address */
  Rmulti=   (1<<5),   /* a multicast self address */

  Rproxy=   (1<<6),   /* this route should be proxied */
};
@
% >> >> >> >> >> >> >>
% will see this different type in advanced section. The simplest one
% for now is Runi
%less: reorder? put Runi first?




% in ipoput4:
%    r = v4lookup(f, eh->dst, c);
%    ifc = r->ifc !!


%XXX
<<[[Conv(kernel)]] routing fields>>=
ulong rgen;     /* routetable generation for *r */
@

%XXX
<<[[Fs(kernel)]] routing fields>>=
Route *v4root[1<<Lroot];  /* v4 routing forest */
@
% >> >> 
%XXX
<<[[Fs(kernel)]] routing fields>>=
Route *queue;     /* used as temp when reinjecting routes */
@


<<[[Ipifc(kernel)]] routing fields>>=
Routerparams rp;  /* router parameters as in RFC 2461, pp.40â€”43.
        used only if node is router */
@



\section{Blocks}

% DS of the kernel

<<macro BLKIPVER>>=
#define BLKIPVER(xp)    (((Ip4hdr*)((xp)->rp))->vihl&0xF0)
@


<<macro BLKIP>>=
#define BLKIP(xp)   ((Ip4hdr*)((xp)->rp))
@



\chapter{Initialization}

\section{Kernel side}

\subsection{Mounting the ip device}

% see kernel init
% bind #I /net
%  bind_safe("#I", "/net", MREPL); // devip

% (not /dev)
% => /net/... especially /net/ipifc/, /net/arp, /net/iproute

% ??? sysbind?? -> <> (as attach <- ipdevtab.attach <- toplevel)
<<function ipattach>>=
static Chan*
ipattach(char* spec)
{
    Chan *c;
    int dev;

    dev = atoi(spec);
    if(dev >= Nfs)
        error("bad specification");

    // initialize ip stack
    ipgetfs(dev);

    c = devattach('I', spec);
    mkqid(&c->qid, QID(0, 0, Qtopdir), 0, QTDIR);
    c->dev = dev;
    c->aux = newipaux(up->user, "none");

    return c;
}
@
% spec? can have multiple network stack?

% will allocate a Fs, will allocate IP fragments,
% will initialize arp, protocols, and then return
% a channel handle that one can use to access Fs services.

% remember 
% - c->aux = private data stored in the channel.
% - c->dev = extra index information

<<function ipgetfs>>=
static Fs*
ipgetfs(int dev)
{
    extern void (*ipprotoinit[])(Fs*);
    Fs *f;
    int i;

    if(dev >= Nfs)
        return nil;

    qlock(&fslock);
    if(ipfs[dev] == nil){
        f = smalloc(sizeof(Fs));

        ip_init(f);
        arpinit(f);
        netloginit(f);
        for(i = 0; ipprotoinit[i]; i++)
            ipprotoinit[i](f);

        f->dev = dev;
        ipfs[dev] = f;
    }
    qunlock(&fslock);

    return ipfs[dev];
}
@

<<struct IPaux>>=
/*
 *  Hanging off every ip channel's ->aux is the following structure.
 *  It maintains the state used by devip and iproute.
 */
struct IPaux
{
  char  *owner;   /* the user that did the attach */
  char  tag[4];
};
@
%todo: tag?? "none" at the beginning?
%less: why put that in the channel? why not in the conv? because need
% faster access?

<<macro ATTACHER>>=
#define ATTACHER(c) (((IPaux*)((c)->aux))->owner)
@
% c is a chan

% ipattach -> <>
<<function newipaux>>=
IPaux*
newipaux(char *owner, char *tag)
{
    IPaux *a;
    int n;

    a = smalloc(sizeof(IPaux));

    kstrdup(&a->owner, owner);
    memset(a->tag, ' ', sizeof(a->tag));
    n = strlen(tag);
    if(n > sizeof(a->tag))
        n = sizeof(a->tag);
    memmove(a->tag, tag, n);

    return a;
}
@

\subsubsection{[[ip_init()]]}

% ipattach -> ipgetfs -> <>
<<function ip_init>>=
void
ip_init(Fs *f)
{
    IP *ip;

    ip = smalloc(sizeof(IP));
    initfrag(ip, 100);
    f->ip = ip;

    <<[[ip_init()]] ipv6 init>>
}
@

<<function initfrag>>=
void
initfrag(IP *ip, int size)
{
    Fragment4 *fq4, *eq4;
    <<[[initfrag()]] locals>>

    ip->fragfree4 = (Fragment4*)malloc(sizeof(Fragment4) * size);
    if(ip->fragfree4 == nil)
        panic("initfrag");

    eq4 = &ip->fragfree4[size];
    for(fq4 = ip->fragfree4; fq4 < eq4; fq4++)
        fq4->next = fq4+1;
    ip->fragfree4[size-1].next = nil;

    <<[[initfrag()]] ipv6 init fragfree6>>
}
@
% 100 packets? 100 fragments?
%less: boilerplate, classic list of used/free things

\subsubsection{[[arpinit()]]}
% will see later

\subsubsection{[[netloginit()]]}
% see in appendix

\subsubsection{[[ipprotoinit()]]}
% each specifics

% in qemu.c because of qemu.conf:
%void (*ipprotoinit[])(Fs*) = {
%	tcpinit,
%	udpinit,
%	ipifcinit,
%	icmpinit,
%	icmp6init,
%	ilinit,
%	nil,
%};


\subsection{Mounting the ethernet device}

% see kernel init
% bind #l -a /net
%  bind_safe("#l0", "/net", MAFTER); // ether (and dev 0)

% => /net/ether0
% => /net/ether0/addr to get MAC address

% actually populated with many things already, 0/, 1/, 2/ with
% different x/type values

% /net/ether0/stats  give you also your mac address at the very end

% ??? sysbind?? -> <> (as attach <- etherdevtab?.attach <- toplevel)
<<function etherattach>>=
Chan*
etherattach(char* spec)
{
    ulong ctlrno;
    char *p;
    Chan *chan;

    ctlrno = 0;
    if(spec && *spec){
        ctlrno = strtoul(spec, &p, 0);
        if((ctlrno == 0 && p == spec) || *p || (ctlrno >= MaxEther))
            error(Ebadarg);
    }
    if(etherxx[ctlrno] == nil)
        error(Enodev);

    chan = devattach('l', spec);
    if(waserror()){
        chanfree(chan);
        nexterror();
    }
    chan->dev = ctlrno;
    if(etherxx[ctlrno]->attach)
        etherxx[ctlrno]->attach(etherxx[ctlrno]);
    poperror();
    return chan;
}
@
% #l0 => spec = 0

\section{User side}

\subsection{Connect manually}

% open /net/<protocol>/clone

\subsection{[[dial()]]}

% dial uses connection server which introduces extra complexity







\chapter{User/Kernel Bridge}

% Will see how dispatch commands from user to kernel, via /net,
% and how the kernel then dispatch internally the command to the right
% protocol, to the right method, to the right medium.

\section{IP device}

<<global ipdevtab>>=
Dev ipdevtab = {
    .dc       =    'I',
    .name     =    "ip",

    .attach   =    ipattach,
    .walk     =    ipwalk,
    .open     =    ipopen,
    .close    =    ipclose,
    .read     =    ipread,
    .write    =    ipwrite,
    .stat     =    ipstat,
    .wstat    =    ipwstat,
               
    .create   =    ipcreate,
    .remove   =    ipremove,
    .bread    =    ipbread,
    .bwrite   =    ipbwrite,
    .reset    =    ipreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
};
@

<<function ipcreate>>=
static void
ipcreate(Chan*, char*, int, ulong)
{
    error(Eperm);
}
@

<<function ipremove>>=
static void
ipremove(Chan*)
{
    error(Eperm);
}
@


\subsection{[[/net]] hierarchy and [[ipwalk()]]}

<<function ipwalk>>=
static Walkqid*
ipwalk(Chan* c, Chan *nc, char **name, int nname)
{
    IPaux *a = c->aux;
    Walkqid* w;

    w = devwalk(c, nc, name, nname, nil, 0, ipgen);

    if(w != nil && w->clone != nil)
        w->clone->aux = newipaux(a->owner, a->tag);

    return w;
}
@
% first chan created in ipattach will have a correct aux.
% ipwalk =~ readdir

% Walkqid =~ Dirtab? so will call ipgen to fill entries
% in Dirtab.

% ipwalk -> devwalk <- <> (as xx <- ipwalk)
% return -1, 0, 1 for devwalk to know what to do
<<function ipgen>>=
static int
ipgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    Fs *f;
    Qid q;
    Conv *cv;

    f = ipfs[c->dev];

    switch(TYPE(c->qid)) {
    <<[[ipgen()]] switch TYPE qid cases>>
    }
    return -1;
}
@
% -1 means no more entries? you can stop to call me to get another
% entry (s is incremented each time)

% ipgen means generate Dir entries or property for this qid.


\subsubsection{[[/net/]]}

% remember s is an integer to get the xth entry in the directory, 
% or -1  (DEVDOTDOT). How knows when to stop? what is the max value
% of s? see above, -1!
<<[[ipgen()]] switch TYPE qid cases>>=
case Qtopdir:
    if(s == DEVDOTDOT){
        mkqid(&q, QID(0, 0, Qtopdir), 0, QTDIR);
        snprint(up->genbuf, sizeof up->genbuf, "#I%lud", c->dev);
        devdir(c, q, up->genbuf, 0, network, 0555, dp);
        return 1;
    }
    if(s < f->np) {
        if(f->p[s]->connect == nil)
            return 0;   /* protocol with no user interface */
        mkqid(&q, QID(s, 0, Qprotodir), 0, QTDIR);
        devdir(c, q, f->p[s]->name, 0, network, 0555, dp);
        return 1;
    }
    s -= f->np;
    return ip1gen(c, s+Qtopbase, dp);
@
% first topdir, then protodir, then regular file in topdir

<<global network>>=
static char network[] = "network";
@
% for owner?


\subsubsection{[[/net/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qarp:
case Qlog:
case Qiproute:
case Qipselftab:
case Qndb:
    return ip1gen(c, TYPE(c->qid), dp);
@
%case Qbootp:

<<function ip1gen>>=
static int
ip1gen(Chan *c, int i, Dir *dp)
{
    Qid q;
    char *p;
    int prot;
    int len = 0;
    Fs *f;
    extern ulong    kerndate;

    f = ipfs[c->dev];

    prot = 0666;
    mkqid(&q, QID(0, 0, i), 0, QTFILE);
    switch(i) {
    <<[[ip1gen()]] switch TYPE qid cases>>
    default:
        return -1;
    }
    devdir(c, q, p, len, network, prot, dp);
    <<[[ipgen()]] if Qndb, adjust mtime>>
    return 1;
}
@





\subsubsection{[[/net/proto/]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qprotodir:
    if(s == DEVDOTDOT){
        mkqid(&q, QID(0, 0, Qtopdir), 0, QTDIR);
        snprint(up->genbuf, sizeof up->genbuf, "#I%lud", c->dev);
        devdir(c, q, up->genbuf, 0, network, 0555, dp);
        return 1;
    }
    if(s < f->p[PROTO(c->qid)]->ac) {
        cv = f->p[PROTO(c->qid)]->conv[s];
        snprint(up->genbuf, sizeof up->genbuf, "%d", s);
        mkqid(&q, QID(PROTO(c->qid), s, Qconvdir), 0, QTDIR);
        devdir(c, q, up->genbuf, 0, cv->owner, 0555, dp);
        return 1;
    }
    s -= f->p[PROTO(c->qid)]->ac;
    return ip2gen(c, s+Qprotobase, dp);
@
% conversation number is stable?? if open 2, close first, then
% will get a hole? the directory seems very dynamic, so if you didn't
% open a connexion with a previous conv number, you will get something
% different?


\subsubsection{[[/net/proto/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qclone:
case Qstats:
    return ip2gen(c, TYPE(c->qid), dp);
@

<<function ip2gen>>=
static int
ip2gen(Chan *c, int i, Dir *dp)
{
    Qid q;

    switch(i) {
    case Qclone:
        mkqid(&q, QID(PROTO(c->qid), 0, Qclone), 0, QTFILE);
        devdir(c, q, "clone", 0, network, 0666, dp);
        return 1;
    case Qstats:
        mkqid(&q, QID(PROTO(c->qid), 0, Qstats), 0, QTFILE);
        devdir(c, q, "stats", 0, network, 0444, dp);
        return 1;
    }
    return -1;
}
@

\subsubsection{[[/net/proto/conv/]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qconvdir:
    if(s == DEVDOTDOT){
        s = PROTO(c->qid);
        mkqid(&q, QID(s, 0, Qprotodir), 0, QTDIR);
        devdir(c, q, f->p[s]->name, 0, network, 0555, dp);
        return 1;
    }
    return ip3gen(c, s+Qconvbase, dp);
@


\subsubsection{[[/net/proto/conv/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
case Qlisten:
case Qlocal:
case Qremote:
case Qstatus:
case Qsnoop:
    return ip3gen(c, TYPE(c->qid), dp);
@

<<function ip3gen>>=
static int
ip3gen(Chan *c, int i, Dir *dp)
{
    Qid q;
    Conv *cv;
    char *p;

    cv = ipfs[c->dev]->p[PROTO(c->qid)]->conv[CONV(c->qid)];

    if(cv->owner == nil)
        kstrdup(&cv->owner, eve);

    mkqid(&q, QID(PROTO(c->qid), CONV(c->qid), i), 0, QTFILE);

    switch(i) {
    <<[[ip3gen()]] switch TYPE qid cases>>
    default:
        return -1;
    }
    devdir(c, q, p, 0, cv->owner, 0444, dp);
    return 1;
}
@

<<[[ip3gen()]] switch TYPE qid cases>>=
case Qctl:
    devdir(c, q, "ctl", 0, cv->owner, cv->perm, dp);
    return 1;
case Qdata:
    devdir(c, q, "data", qlen(cv->rq), cv->owner, cv->perm, dp);
    return 1;
@





\subsection{Dispatch functions, [[ipxxx()]]}

\subsubsection{[[ipopen()]]}

<<global m2p>>=
static int m2p[] = {
    [OREAD]     4,
    [OWRITE]    2,
    [ORDWR]     6
};
@
% ???

<<function ipopen>>=
static Chan*
ipopen(Chan* c, int omode)
{
    Fs *f;
    int perm;
    Proto *p;
    Conv *cv, *nc;

    perm = m2p[omode&3];

    f = ipfs[c->dev];

    switch(TYPE(c->qid)) {
    <<[[ipopen()]] switch TYPE qid cases>>
    default:
        break;
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    return c;
}
@


<<[[ipopen()]] switch TYPE qid cases>>=
case Qtopdir:
case Qprotodir:
case Qconvdir:

case Qipselftab:

case Qstatus:
case Qlocal:
case Qremote:
case Qstats:
    if(omode != OREAD)
        error(Eperm);
    break;
@
%case Qbootp:




% lots of noise, but mostly check perm and increment inuse
<<[[ipopen()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
    p = f->p[PROTO(c->qid)];
    qlock(p);
    cv = p->conv[CONV(c->qid)];
    qlock(cv);
    if(waserror()) {
        qunlock(cv);
        qunlock(p);
        nexterror();
    }
    if((perm & (cv->perm>>6)) != perm) {
        if(strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if((perm & cv->perm) != perm)
            error(Eperm);

    }
    cv->inuse++;
    if(cv->inuse == 1){
        kstrdup(&cv->owner, ATTACHER(c));
        cv->perm = 0660;
    }
    qunlock(cv);
    qunlock(p);
    poperror();
    break;
@



\subsubsection{[[ipclose()]]}

<<function ipclose>>=
static void
ipclose(Chan* c)
{
    Fs *f;

    f = ipfs[c->dev];
    switch(TYPE(c->qid)) {
    <<[[ipclose()]] switch TYPE qid cases>>
    default:
        break;
    }
    free(((IPaux*)c->aux)->owner);
    free(c->aux);
}
@

<<[[ipclose()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
    if(c->flag & COPEN)
        closeconv(f->p[PROTO(c->qid)]->conv[CONV(c->qid)]);
    break;
@


<<function closeconv>>=
void
closeconv(Conv *cv)
{
    Conv *nc;
    Ipmulti *mp;

    qlock(cv);

    if(--cv->inuse > 0) {
        qunlock(cv);
        return;
    }

    <<[[closeconv()]] close incoming calls>>

    kstrdup(&cv->owner, network);
    cv->perm = 0660;

    <<[[closeconv()]] if multi, call ipifcremmulti>>

    cv->r = nil;
    cv->rgen = 0;

    // Protocol dispatch
    cv->p->close(cv);

    cv->state = Idle;

    qunlock(cv);
}
@




\subsubsection{[[ipread()]]}

<<function ipread>>=
static long
ipread(Chan *ch, void *a, long n, vlong off)
{
    Fs *f;
    Proto *x;
    Conv *cv;
    char *buf, *p;
    long rv;
    ulong offset = off;

    f = ipfs[ch->dev];

    p = a;
    switch(TYPE(ch->qid)) {
    <<[[ipread()]] switch TYPE qid cases>>
    default:
        error(Eperm);

    }
}
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qtopdir:
case Qprotodir:
case Qconvdir:
    return devdirread(ch, a, n, 0, 0, ipgen);
@



\subsubsection{[[ipwrite()]]}


<<function ipwrite>>=
static long
ipwrite(Chan* ch, void *v, long n, vlong off)
{
    Conv *cv;
    Proto *x;
    char *p;
    Cmdbuf *cb;
    uchar ia[IPaddrlen], ma[IPaddrlen];
    Fs *f;
    char *a;
    ulong offset = off;

    a = v;
    f = ipfs[ch->dev];

    switch(TYPE(ch->qid)){
    <<[[ipwrite()]] switch TYPE qid cases>>
    default:
        error(Eperm);
    }
    return n;
}
@



\subsection{[[/net/x/clone]]}

<<[[ipopen()]] switch TYPE qid cases>>=
case Qclone:
    p = f->p[PROTO(c->qid)];

    qlock(p);
    if(waserror()){
        qunlock(p);
        nexterror();
    }

    cv = Fsprotoclone(p, ATTACHER(c));

    qunlock(p);
    poperror();
    if(cv == nil) {
        error(Enodev);
        break;
    }
    mkqid(&c->qid, QID(p->x, cv->x, Qctl), 0, QTFILE);
    break;
@
% Qctl !! redirect to Qctl of newly created /net/<proto>/<conv>/ dir
% with a newly conversation created in Fs->p[x]->conv[x] with
% the queue created

<<function Fsprotoclone>>=
/*
 *  called with protocol locked
 */
Conv*
Fsprotoclone(Proto *p, char *user)
{
    Conv *cv, **pp, **ep;

retry:
    cv = nil;
    <<[[Fsprotoclone()]] finding an available conversation in the protocol>>
    <<[[Fsprotoclone()]] if no more available conv, garbage collect and retry>>

    cv->inuse = 1;
    kstrdup(&cv->owner, user);
    cv->perm = 0660;
    cv->state = Idle;
    ipmove(cv->laddr, IPnoaddr);
    ipmove(cv->raddr, IPnoaddr);
    cv->lport = 0;
    cv->rport = 0;

    cv->r = nil;
    cv->rgen = 0;

    cv->restricted = false;
    cv->maxfragsize = 0;
    cv->ttl = MAXTTL;

    qreopen(cv->rq);
    qreopen(cv->wq);
    qreopen(cv->eq);

    qunlock(cv);
    return cv;
}
@

\subsubsection{Finding a free entry}

<<[[Fsprotoclone()]] finding an available conversation in the protocol>>=
ep = &p->conv[p->nc];
for(pp = p->conv; pp < ep; pp++) {
    cv = *pp;
    // found an unallocated entry in the array
    if(cv == nil){
        cv = malloc(sizeof(Conv));
        if(cv == nil)
            error(Enomem);
        qlock(cv);

        cv->p = p;
        cv->x = pp - p->conv;
        if(p->ptclsize != 0){
            cv->ptcl = malloc(p->ptclsize);
            if(cv->ptcl == nil) {
                free(cv);
                error(Enomem);
            }
        }
        *pp = cv;
        p->ac++;
        cv->eq = qopen(1024, Qmsg, 0, 0);

        // !! Protocol dispatch !!! will create extra queues
        (*p->create)(cv);

        break;
    }
    <<[[Fsprotoclone()]] if found an unused entry>>
}
@

\subsubsection{Reuse an unused entry}

<<[[Fsprotoclone()]] if found an unused entry>>=
if(canqlock(cv)){
    /*
     *  make sure both processes and protocol
     *  are done with this Conv
     */
    if(cv->inuse == 0 && (p->inuse == nil || 
        // Protocol dispatch
        (*p->inuse)(cv) == false)
      )
        break;

    qunlock(cv);
}
@
% can reuse an existing conv that was allocated, but need to make
% sure noone is using it (and if you can't lock it, then for sure
% it means it was in use

<<[[Proto(kernel)]] conversation methods>>=
bool   (*inuse)(Conv*);
@


\subsubsection{Garbage collecting}

<<[[Fsprotoclone()]] if no more available conv, garbage collect and retry>>=
if(pp >= ep) {
    if(p->gc)
        print("Fsprotoclone: garbage collecting Convs\n");
    if(p->gc != nil &&
        // Protocol dispatch
        (*p->gc)(p)
       )
        goto retry;

    /* debugging: do we ever get here? */
    if (cpuserver)
        panic("Fsprotoclone: all conversations in use");
    return nil;
}
@

<<[[Proto(kernel)]] protocol methods>>=
int   (*gc)(Proto*);  /* returns true if any conversations are freed */
@

\subsection{[[/net/x/y/ctl]]}

<<[[ipread()]] switch TYPE qid cases>>=
case Qctl:
    buf = smalloc(16);
    snprint(buf, 16, "%lud", CONV(ch->qid));
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@
% that's how you get your /x/


<<[[ipwrite()]] switch TYPE qid cases>>=
case Qctl:
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    cb = parsecmd(a, n);

    qlock(cv);
    if(waserror()) {
        qunlock(cv);
        free(cb);
        nexterror();
    }
    if(cb->nf < 1)
        error("short control request");

    <<[[ipwrite()]] Qctl case, if connect string>>
    <<[[ipwrite()]] Qctl case, else if announce string>>
    <<[[ipwrite()]] Qctl case, else if other string>>
    else if(x->ctl != nil) {
        // Protocol dispatch
        p = x->ctl(cv, cb->f, cb->nf);
        if(p != nil)
            error(p);
    } else
        error("unknown control request");
    qunlock(cv);
    free(cb);
    poperror();
    break;
@

\subsubsection{Connect}

<<[[ipwrite()]] Qctl case, if connect string>>=
if(strcmp(cb->f[0], "connect") == 0)
    connectctlmsg(x, cv, cb);
@

<<function connectctlmsg>>=
static void
connectctlmsg(Proto *p, Conv *c, Cmdbuf *cb)
{
    char *err;

    if(c->state != Idle)
        error(Econinuse);

    c->state = Connecting;
    c->cerr[0] = '\0';

    if(p->connect == nil)
        error("connect not supported");
    // Protocol dispatch
    err = p->connect(c, cb->f, cb->nf);

    if(err != nil)
        error(err);

    qunlock(c);
    if(waserror()){
        qlock(c);
        nexterror();
    }
    sleep(&c->cr, connected, c);
    qlock(c);
    poperror();

    if(c->cerr[0] != '\0')
        error(c->cerr);
}
@

<<function connected>>=
/*
 *  initiate connection and sleep till its set up
 */
static bool
connected(void* a)
{
    return ((Conv*)a)->state == Connected;
}
@



% lots of those connect methods will then call Fssconnect and Fssconnected

% udpconnect | ... -> <>
<<function Fsstdconnect>>=
/*
 *  called by protocol connect routine to set addresses
 */
char*
Fsstdconnect(Conv *c, char *argv[], int argc)
{
    char *err;

    switch(argc) {
    default:
        return "bad args to connect";
    case 2:
        err = setraddrport(c, argv[1]);
        if(err != nil)
            return err;
        setladdr(c);
        err = setlport(c);
        if (err != nil)
            return err;
        break;
    case 3:
        err = setraddrport(c, argv[1]);
        if(err != nil)
            return err;
        err = setladdrport(c, argv[2], 0);
        if(err != nil)
            return err;
    }

    <<[[Fsstdconnect()]] set ipversion field to V4 or V6>>

    return nil;
}
@


<<function Fsconnected>>=
int
Fsconnected(Conv* c, char* msg)
{
    if(msg != nil && *msg != '\0')
        strncpy(c->cerr, msg, ERRMAX-1);

    switch(c->state){
    case Connecting:
        c->state = Connected;
        break;
    <<[[Fsconnected()]] switch state cases>>
    }
    wakeup(&c->cr);
    return 0;
}
@


\subsubsection{Announce}

<<[[ipwrite()]] Qctl case, else if announce string>>=
else if(strcmp(cb->f[0], "announce") == 0)
    announcectlmsg(x, cv, cb);
@

<<function announcectlmsg>>=
static void
announcectlmsg(Proto *p, Conv *c, Cmdbuf *cb)
{
    char *err;

    if(c->state != Idle)
        error(Econinuse);

    c->state = Announcing;
    c->cerr[0] = '\0';

    if(p->announce == nil)
        error("announce not supported");
    // Protocol dispatch
    err = p->announce(c, cb->f, cb->nf);

    if(err != nil)
        error(err);

    qunlock(c);
    if(waserror()){
        qlock(c);
        nexterror();
    }
    sleep(&c->cr, announced, c);
    qlock(c);
    poperror();

    if(c->cerr[0] != '\0')
        error(c->cerr);
}
@

<<function announced>>=
/*
 *  initiate announcement and sleep till its set up
 */
static bool
announced(void* a)
{
    return ((Conv*)a)->state == Announced;
}
@

% lots of those announce method will then call Fsstdannounce and Fsannounced

% udpannounce | ... -> <>
<<function Fsstdannounce>>=
/*
 *  called by protocol announce routine to set addresses
 */
char*
Fsstdannounce(Conv* c, char* argv[], int argc)
{
    memset(c->raddr, 0, sizeof(c->raddr));
    c->rport = 0;
    switch(argc){
    default:
        break;
    case 2:
        return setladdrport(c, argv[1], 1);
    }
    return "bad args to announce";
}
@

<<[[Fsconnected()]] switch state cases>>=
case Announcing:
    c->state = Announced;
    break;
@    

\subsubsection{Port settings}

% port fields?
<<[[Conv(kernel)]] other fields>>=
bool restricted;   /* remote port is restricted */
@
<<[[Proto(kernel)]] other fields>>=
ushort    nextrport;
@
% when look for fresh new port, where to start from, but who allocates
% new ports? not the user?



<<function setlport>>=
/*
 *  pick a local port and set it
 */
char *
setlport(Conv* c)
{
    Proto *p;
    int i, port;

    p = c->p;
    qlock(p);
    if(c->restricted){
        /* Restricted ports cycle between 600 and 1024. */
        for(i=0; i<1024-600; i++){
            if(p->nextrport >= 1024 || p->nextrport < 600)
                p->nextrport = 600;
            port = p->nextrport++;
            if(!lportinuse(p, port))
                goto chosen;
        }
    }else{
        /*
         * Unrestricted ports are chosen randomly
         * between 2^15 and 2^16.  There are at most
         * 4*Nchan = 4096 ports in use at any given time,
         * so even in the worst case, a random probe has a
         * 1 - 4096/2^15 = 87% chance of success.
         * If 64 successive probes fail, there is a bug somewhere
         * (or a once in 10^58 event has happened, but that's
         * less likely than a venti collision).
         */
        for(i=0; i<64; i++){
            port = (1<<15) + nrand(1<<15);
            if(!lportinuse(p, port))
                goto chosen;
        }
    }
    qunlock(p);
    /*
     * debugging: let's see if we ever get this.
     * if we do (and we're a cpu server), we might as well restart
     * since we're now unable to service new connections.
     */
    panic("setlport: out of ports");
    return "no ports available";

chosen:
    c->lport = port;
    qunlock(p);
    return nil;
}
@
% >> >> 


<<function setladdrport>>=
/*
 *  set a local address and port from a string of the form
 *  [address!]port[!r]
 */
char*
setladdrport(Conv* c, char* str, int announcing)
{
    char *p;
    char *rv;
    ushort lport;
    uchar addr[IPaddrlen];

    /*
     *  ignore restricted part if it exists.  it's
     *  meaningless on local ports.
     */
    p = strchr(str, '!');
    if(p != nil){
        *p++ = 0;
        if(strcmp(p, "r") == 0)
            p = nil;
    }

    c->lport = 0;
    if(p == nil){
        if(announcing)
            ipmove(c->laddr, IPnoaddr);
        else
            setladdr(c);
        p = str;
    } else {
        if(strcmp(str, "*") == 0)
            ipmove(c->laddr, IPnoaddr);
        else {
            if(parseip(addr, str) == -1)
                return Ebadip;
            if(ipforme(c->p->f, addr))
                ipmove(c->laddr, addr);
            else
                return "not a local IP address";
        }
    }

    /* one process can get all connections */
    if(announcing && strcmp(p, "*") == 0){
        if(!iseve())
            error(Eperm);
        return setluniqueport(c, 0);
    }

    lport = atoi(p);
    if(lport <= 0)
        rv = setlport(c);
    else
        rv = setluniqueport(c, lport);
    return rv;
}
@

<<function setraddrport>>=
static char*
setraddrport(Conv* c, char* str)
{
    char *p;

    p = strchr(str, '!');
    if(p == nil)
        return "malformed address";
    *p++ = 0;
    if (parseip(c->raddr, str) == -1)
        return Ebadip;
    c->rport = atoi(p);
    p = strchr(p, '!');
    if(p){
        if(strstr(p, "!r") != nil)
            c->restricted = true;
    }
    return nil;
}
@


\subsubsection{Bind}

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "bind") == 0)
    bindctlmsg(x, cv, cb);
@

% ipwrite (Qctl case) -> <>
<<function bindctlmsg>>=
static void
bindctlmsg(Proto *x, Conv *cv, Cmdbuf *cb)
{
    char *p;

    if(x->bind == nil)
        p = Fsstdbind(cv, cb->f, cb->nf);
    else
        // Protocol dispatch
        p = x->bind(cv, cb->f, cb->nf);
    if(p != nil)
        error(p);
}
@

% default method
<<function Fsstdbind>>=
/*
 *  called by protocol bind routine to set addresses
 */
char*
Fsstdbind(Conv* cv, char* argv[], int argc)
{
    switch(argc){
    default:
        break;
    case 2:
        return setladdrport(cv, argv[1], 0);
    }
    return "bad args to bind";
}
@

\subsection{[[/net/x/y/data]]}

<<[[ipread()]] switch TYPE qid cases>>=
case Qdata:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->rq, a, n);
@
% read on rq

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qdata:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    if(cv->wq == nil)
        error(Eperm);
    qwrite(cv->wq, a, n);
    break;
@
% write on wq

\subsection{[[/net/x/y/err]]}

<<[[Qid]] conversation extra cases>>=
Qerr,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qerr:
    devdir(c, q, "err", qlen(cv->eq), cv->owner, cv->perm, dp);
    return 1;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qerr:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->eq, a, n);
@
% read only

\subsection{[[/net/x/y/listen]]}
% ?????


<<[[Qid]] conversation extra cases>>=
Qlisten,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qlisten:
    devdir(c, q, "listen", 0, cv->owner, cv->perm, dp);
    return 1;
@

<<[[ipopen()]] switch TYPE qid cases>>=
case Qlisten:
    cv = f->p[PROTO(c->qid)]->conv[CONV(c->qid)];
    if((perm & (cv->perm>>6)) != perm) {
        if(strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if((perm & cv->perm) != perm)
            error(Eperm);

    }

    if(cv->state != Announced)
        error("not announced");

    if(waserror()){
        closeconv(cv);
        nexterror();
    }
    qlock(cv);
    cv->inuse++;
    qunlock(cv);

    nc = nil;
    while(nc == nil) {
        /* give up if we got a hangup */
        if(qisclosed(cv->rq))
            error("listen hungup");

        qlock(&cv->listenq);
        if(waserror()) {
            qunlock(&cv->listenq);
            nexterror();
        }

        /* wait for a connect */
        sleep(&cv->listenr, incoming, cv);

        qlock(cv);
        nc = cv->incall;
        if(nc != nil){
            cv->incall = nc->next;
            mkqid(&c->qid, QID(PROTO(c->qid), nc->x, Qctl), 0, QTFILE);
            kstrdup(&cv->owner, ATTACHER(c));
        }
        qunlock(cv);

        qunlock(&cv->listenq);
        poperror();
    }
    closeconv(cv);
    poperror();
    break;
@

<<[[Conv(kernel)]] listen fields>>=
Conv* incall;     /* calls waiting to be listened for */
Conv* next;
QLock listenq;
Rendez  listenr;
@


<<[[closeconv()]] close incoming calls>>=
/* close all incoming calls since no listen will ever happen */
for(nc = cv->incall; nc; nc = cv->incall){
    cv->incall = nc->next;
    closeconv(nc);
}
cv->incall = nil;
@


\subsection{Other files}

\subsubsection{[[/net/x/stats]]}

<<[[Qid]] protocol extra cases>>=
Qstats,
@

<<[[Proto(kernel)]] protocol methods>>=
int   (*stats)(Proto*, char*, int);
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qstats:
    x = f->p[PROTO(ch->qid)];
    if(x->stats == nil)
        error("stats not implemented");
    buf = smalloc(Statelen);

    // Protocol dispatch
    (*x->stats)(x, buf, Statelen);

    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

<<constant Statelen>>=
    Statelen=   32*1024,
@

\subsubsection{[[/net/x/y/status]]}

<<[[Qid]] conversation extra cases>>=
Qstatus,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qstatus:
    p = "status";
    break;
@

<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*state)(Conv*, char*, int);
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qstatus:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];

    // Protocol dispatch
    (*x->state)(cv, buf, Statelen-2);

    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@
% -2? why?

\subsubsection{[[/net/x/y/local]], [[/net/x/y/remote]]}

<<[[Qid]] conversation extra cases>>=
Qlocal,
Qremote,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qlocal:
    p = "local";
    break;
case Qremote:
    p = "remote";
    break;
@

<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*local)(Conv*, char*, int);
@

% cv->laddr
<<[[ipread()]] switch TYPE qid cases>>=
case Qlocal:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    if(x->local == nil) {
        snprint(buf, Statelen, "%I!%d\n", cv->laddr, cv->lport);
    } else {
        // Protocol dispatch
        (*x->local)(cv, buf, Statelen-2);
    }
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@



<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*remote)(Conv*, char*, int);
@

% cv->raddr
<<[[ipread()]] switch TYPE qid cases>>=
case Qremote:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    if(x->remote == nil) {
        snprint(buf, Statelen, "%I!%d\n", cv->raddr, cv->rport);
    } else {
        // Protocol dispatch
        (*x->remote)(cv, buf, Statelen-2);
    }
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

\section{Ethernet device}


<<global etherdevtab>>=
Dev etherdevtab = {
    .dc       =    'l',
    .name     =    "ether",

    .attach   =    etherattach,
    .walk     =    etherwalk,
    .open     =    etheropen,
    .close    =    etherclose,
    .read     =    etherread,
    .write    =    etherwrite,
    .stat     =    etherstat,
    .wstat    =    etherwstat,
               
    .reset    =    etherreset,
    .init     =    devinit,
    .shutdown =    ethershutdown,
    .create   =    ethercreate,
    .bread    =    etherbread,
    .bwrite   =    etherbwrite,
    .remove   =    devremove,
};
@


\section{Ethernet medium}

% before IP? kinda more low level (but less general)
% called a medium?

% there are other physical device, but we'll focus on this one,
% most common

% physical 48bits address.

<<global ethermedium (kernel)>>=
Medium ethermedium =
{
    .name=      "ether",

    .hsize=     14,
    .mintu=     60,
    .maxtu=     1514,
    .maclen=    6,

    .bind=      etherbind,
    .unbind=    etherunbind,
    .bwrite=    etherbwrite,

    .addmulti=  etheraddmulti,
    .remmulti=  etherremmulti,
    .ares=      arpenter,
    .areg=      sendgarp,

    .pref2addr= etherpref2addr,
};
@
% maxtu = 1500 + 14 for header
% maclen = 6 = 48 bits


<<global etherbroadcast>>=
static uchar etherbroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
@




%\section{Streams}

% like bidirectional pipes. Producer/consumer like pipes, but
% bidirectional.






\chapter{Configuration}

\section{[[/net/ipifc/]] protocol}

% (ab)use the protocol scheme to also configure.
%alt: some special file in /net/ like /net/medium, /net/ip

\subsection{Protocol initialisation}

% ipattach -> ipgetfs -> <> (as ipprotoinit[i] <- ipprotoinit[x] = <> <- qemu.c)
<<function ipifcinit>>=
void
ipifcinit(Fs *f)
{
    Proto *ipifc;

    ipifc = smalloc(sizeof(Proto));

    ipifc->name = "ipifc";
    ipifc->create = ipifccreate;
    ipifc->close = ipifcclose;

    ipifc->bind = ipifcbind;
    ipifc->connect = ipifcconnect;
    ipifc->announce = nil;
    ipifc->ctl = ipifcctl;

    ipifc->rcv = nil;
    ipifc->advise = nil;
    ipifc->inuse = ipifcinuse;

    ipifc->local = ipifclocal;
    ipifc->state = ipifcstate;
    ipifc->stats = ipifcstats;

    ipifc->ipproto = -1;

    ipifc->nc = Maxmedia;
    ipifc->ptclsize = sizeof(Ipifc);

    <<[[ipifcinit()]] modify f>>

    Fsproto(f, ipifc);
}
@
%less: make it a global with intializer?
%less: no remote method?
%alt: why not do via global? why smalloc? to not pay memory if don't use
% the network? meh.

%    ipifc->nc = Maxmedia;
% max conversation

% ipproto = -1 cos fake protocol, we will not receive any packet
% from the ethernet to be directed to this protocol (which is why
% also rcv is nil)

<<function Fsproto>>=
int
Fsproto(Fs *f, Proto *p)
{
    if(f->np >= Maxproto)
        return -1;

    p->f = f;

    <<[[Fsproto()]] adjust f->t2p>>

    p->qid.type = QTDIR;
    p->qid.path = QID(f->np, 0, Qprotodir);
    p->conv = malloc(sizeof(Conv*) * (p->nc+1));
    if(p->conv == nil)
        panic("Fsproto");

    p->nextrport = 600;

    p->x = f->np;
    f->p[f->np++] = p;

    return 0;
}
@
%nextrport = next receive port?

<<[[Fsproto()]] adjust f->t2p>>=
if(p->ipproto > 0){
    if(f->t2p[p->ipproto] != nil)
        return -1;
    f->t2p[p->ipproto] = p;
}
@
% so given an ip package just received, can look at proto field
% and dispatch to the right protocol!




%XXX
<<[[ipifcinit()]] modify f>>=
f->ipifc = ipifc;   /* hack for ipifcremroute, findipifc, ... */
@
%XXX
<<[[Fs(kernel)]] other fields>>=
Proto*  ipifc;      /* kludge for ipifcremroute & ipifcaddroute */
@
% hack? or fundamental? but not that it's a Proto, not an Ipifc.


%XXX
<<[[ipifcinit()]] modify f>>=
f->self = smalloc(sizeof(Ipselftab));   /* hack for ipforme */
@
%XXX
<<[[Fs(kernel)]] other fields>>=
Ipselftab *self;
@

\subsection{[[/net/ipifc/clone]]}

%// sysopen(/net/ipifc/clone) -> ... -> ipopen -> Fsprotoclone -> <>
%  (as x->create <- ...)
<<function ipifccreate>>=
/*
 *  called when a new ipifc structure is created
 */
static void
ipifccreate(Conv *cv)
{
    Ipifc *ifc;

    cv->rq = qopen(QMAX, 0, 0, 0);
    cv->wq = qopen(QMAX, Qkick, ipifckick, cv);

    cv->sq = qopen(QMAX, 0, 0, 0);

    ifc = (Ipifc*)cv->ptcl;
    ifc->m = nil;

    ifc->conv = cv;
    ifc->reassemble = false;
}
@
% Ipifc has been smalloc generically by Fsprotoclone()
% no medium yet!
%dead:    ifc->unbinding = false;


% ip/ipconfig open this file and keeps it open forever

\subsection{Binding medium, [[/net/ipifc/x/ctl bind]]}

% ipwrite (Qctl case) -> bindctlmsg -> <> (as x->bind <- ipprotoinit[i] <- qmemu.c)
% bind ether /net/ether0
<<function ipifcbind>>=
/*
 *  attach a device (or pkt driver) to the interface.
 *  called with cv locked
 */
static char*
ipifcbind(Conv *cv, char **argv, int argc)
{
    Ipifc *ifc;
    Medium *m;

    if(argc < 2)
        return Ebadarg;

    ifc = (Ipifc*)cv->ptcl;

    /* bind the device to the interface */
    m = ipfindmedium(argv[1]);
    if(m == nil)
        return "unknown interface type";

    wlock(ifc);
    if(ifc->m != nil){
        wunlock(ifc);
        return "interface already bound";
    }
    if(waserror()){
        wunlock(ifc);
        nexterror();
    }

    // This time Medium dispatch
    /* do medium specific binding */
    (*m->bind)(ifc, argc, argv);

    /* set the bound device name */
    if(argc > 2)
        strncpy(ifc->dev, argv[2], sizeof(ifc->dev));
    else
        snprint(ifc->dev, sizeof ifc->dev, "%s%d", m->name, cv->x);
    ifc->dev[sizeof(ifc->dev)-1] = 0;

    /* set up parameters */
    ifc->m = m;

    ifc->mintu = ifc->m->mintu;
    ifc->maxtu = ifc->m->maxtu;
    if(ifc->m->unbindonclose == false)
        ifc->conv->inuse++;

    ifc->rp.mflag = 0;      /* default not managed */
    ifc->rp.oflag = 0;
    ifc->rp.maxraint = 600000;  /* millisecs */
    ifc->rp.minraint = 200000;
    ifc->rp.linkmtu = 0;        /* no mtu sent */
    ifc->rp.reachtime = 0;
    ifc->rp.rxmitra = 0;
    ifc->rp.ttl = MAXTTL;
    ifc->rp.routerlt = 3 * ifc->rp.maxraint;

    /* any ancillary structures (like routes) no longer pertain */
    ifc->ifcid++;

    /* reopen all the queues closed by a previous unbind */
    qreopen(cv->rq);
    qreopen(cv->eq);
    qreopen(cv->sq);

    wunlock(ifc);
    poperror();

    return nil;
}
@

% why need ifcid? because ifc may have changed! it may have been
% binded to something else
<<[[Routetree]] other fields>>=
uchar ifcid;    /* must match ifc->id */
@

<<[[Ipifc(kernel)]] other fields>>=
uchar ifcid;    /* incremented each 'bind/unbind/add/remove' */
@


<<function ipfindmedium>>=
/*
 *  find the medium with this name
 */
Medium*
ipfindmedium(char *name)
{
    Medium **mp;

    for(mp = media; *mp != nil; mp++)
        if(strcmp((*mp)->name, name) == 0)
            break;
    return *mp;
}
@
% use global media

\subsection{[[/net/ipifc/x/ctl]]}

% ... -> ipwrite (Qctl case) -> <>
%  (as x->bind <- ...) because not a generic msg
<<function ipifcctl>>=
/*
 *  non-standard control messages.
 *  called with cv->car locked.
 */
static char*
ipifcctl(Conv* cv, char** argv, int argc)
{
    Ipifc *ifc;
    int i;

    ifc = (Ipifc*)cv->ptcl;
    <<[[ipifcctl()]] if add string>>
    <<[[ipifcctl()]] else if other string>>

    return "unsupported ctl";
}
@






\subsection{Adding an IP, [[/net/ipifc/x/ctl add]]}

<<[[ipifcctl()]] if add string>>=
if(strcmp(argv[0], "add") == 0)
    return ipifcadd(ifc, argv, argc, false, nil);
@

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "try") == 0)
    return ipifcadd(ifc, argv, argc, true, nil);
@

<<function ipifcadd>>=
/*
 *  add an address to an interface.
 */
char*
ipifcadd(Ipifc *ifc, char **argv, int argc, bool tentative, Iplifc *lifcp)
{
    int i;
    int mtu;
    // enum<route_type>
    int type;
    uchar ip[IPaddrlen];
    uchar mask[IPaddrlen];
    uchar net[IPaddrlen]; // ip & mask
    uchar rem[IPaddrlen];
    Iplifc *lifc, **l;
    Fs *f;

    <<[[ipifcadd()]] locals>>

    if(ifc->m == nil)
        return "ipifc not yet bound to device";

    f = ifc->conv->p->f;

    type = Rifc;
    memset(ip, 0, IPaddrlen);
    memset(mask, 0, IPaddrlen);
    memset(rem, 0, IPaddrlen);

    switch(argc){
    <<[[ipifcadd()]] switch argc, proxy case, and fall through>>
    <<[[ipifcadd()]] switch argc, mtu setting case, and fall through>>
    // add <ip> <mask> <rem>
    case 4:
        if (parseip(ip, argv[1]) == -1 || parseip(rem, argv[3]) == -1)
            return Ebadip;
        parseipmask(mask, argv[2]);
        maskip(rem, mask, net);
        break;
    // add <ip> <mask>
    case 3:
        if (parseip(ip, argv[1]) == -1)
            return Ebadip;
        parseipmask(mask, argv[2]);
        maskip(ip, mask, rem);
        maskip(rem, mask, net);
        break;
    // simplest case, add <ip>
    case 2:
        if (parseip(ip, argv[1]) == -1)
            return Ebadip;
        memmove(mask, defmask(ip), IPaddrlen);
        maskip(ip, mask, rem);
        maskip(rem, mask, net);
        break;
    default:
        return Ebadarg;
    }

    if(isv4(ip))
        tentative = false;

    wlock(ifc);

    /* ignore if this is already a local address for this ifc */
    for(lifc = ifc->lifc; lifc; lifc = lifc->next) {
        if(ipcmp(lifc->local, ip) == 0) {
            if(lifc->tentative != tentative)
                lifc->tentative = tentative;
            if(lifcp) {
                lifc->onlink = lifcp->onlink;
                lifc->autoflag = lifcp->autoflag;

                lifc->validlt = lifcp->validlt;
                lifc->preflt = lifcp->preflt;
                lifc->origint = lifcp->origint;
            }
            goto out;
        }
    }

    /* add the address to the list of logical ifc's for this ifc */
    lifc = smalloc(sizeof(Iplifc));

    ipmove(lifc->local, ip);
    ipmove(lifc->mask, mask);
    ipmove(lifc->remote, rem);
    ipmove(lifc->net, net);
    lifc->tentative = tentative;

    if(lifcp) {
        lifc->onlink = lifcp->onlink;
        lifc->autoflag = lifcp->autoflag;

        lifc->validlt = lifcp->validlt;
        lifc->preflt = lifcp->preflt;
        lifc->origint = lifcp->origint;
    } else {        /* default values */
        lifc->onlink = lifc->autoflag = 1;
        lifc->validlt = lifc->preflt = ~0L;
        lifc->origint = NOW / 1000;
    }
    // add_tail(lifc, ifc->lifc)
    lifc->next = nil;
    for(l = &ifc->lifc; *l; l = &(*l)->next)
        ;
    *l = lifc;

    <<[[ipifcadd()]] check for point to point interface>>

    /* add local routes */
    if(isv4(ip))
        v4addroute(f, tifc, rem+IPv4off, mask+IPv4off, rem+IPv4off, type);
    <<[[ipifcadd()]] add route if ipv6 case>>

    addselfcache(f, ifc, lifc, ip, Runi);

    <<[[ipifcadd()]] register proxy if point to point interface or proxy>>

    if(isv4(ip) || ipcmp(ip, IPnoaddr) == 0) {
        <<[[ipifcadd()]] add broadcast addresses to self cache>>
    }
    else {
        <<[[ipifcadd()]] add multicast addresses to self cache>>
    }

    /* register the address on this network for address resolution */
    if(isv4(ip) && ifc->m->areg != nil)
        // Medium dispatch
        (*ifc->m->areg)(ifc, ip);

out:
    wunlock(ifc);
    <<[[ipifcadd()]] if tentative and broacast>>
    return nil;
}
@


<<global tifc>>=
static char tifc[] = "ifc ";
@


\section{IP Interface, user side}

\subsection{Parsing}

<<function readipifc>>=
Ipifc*
readipifc(char *net, Ipifc *ifc, int index)
{
    int fd, i, n;
    Dir *dir;
    char directory[128];
    char buf[128];
    Ipifc **l;

    _freeifc(ifc);

    l = &ifc;
    ifc = nil;

    if(net == nil)
        net = "/net";
    snprint(directory, sizeof(directory), "%s/ipifc", net);

    if(index >= 0){
        snprint(buf, sizeof(buf), "%s/%d/status", directory, index);
        _readipifc(buf, l, index);
    } else {
        fd = open(directory, OREAD);
        if(fd < 0)
            return nil;
        n = dirreadall(fd, &dir);
        close(fd);

        for(i = 0; i < n; i++){
            if(strcmp(dir[i].name, "clone") == 0)
                continue;
            if(strcmp(dir[i].name, "stats") == 0)
                continue;
            snprint(buf, sizeof(buf), "%s/%s/status", directory, dir[i].name);
            l = _readipifc(buf, l, atoi(dir[i].name));
        }
        free(dir);
    }

    return ifc;
}
@


<<function _readipifc>>=
static Ipifc**
_readipifc(char *file, Ipifc **l, int index)
{
    int i, n, fd, lines;
    char buf[4*1024];
    char *line[32];
    char *f[64];
    Ipifc *ifc, **l0;
    Iplifc *lifc, **ll;

    /* read the file */
    fd = open(file, OREAD);
    if(fd < 0)
        return l;
    n = 0;
    while((i = read(fd, buf+n, sizeof(buf)-1-n)) > 0 && n < sizeof(buf) - 1)
        n += i;
    buf[n] = 0;
    close(fd);

    //if(strncmp(buf, "device", 6) != 0)
    //    return _readoldipifc(buf, l, index);

    /* ignore ifcs with no associated device */
    if(strncmp(buf+6, "  ", 2) == 0)
        return l;
    /* allocate new interface */
    *l = ifc = mallocz(sizeof(Ipifc), 1);
    if(ifc == nil)
        return l;
    l0 = l;
    l = &ifc->next;
    ifc->index = index;

    lines = getfields(buf, line, nelem(line), 1, "\n");

    /* pick off device specific info(first line) */
    n = tokenize(line[0], f, nelem(f));
    if(n%2 != 0)
        goto lose;
    strncpy(ifc->dev, findfield("device", f, n), sizeof(ifc->dev));
    ifc->dev[sizeof(ifc->dev)-1] = 0;
    if(ifc->dev[0] == 0){
lose:
        free(ifc);
        *l0 = nil;
        return l;
    }
    ifc->mtu          = strtoul(findfield("maxtu", f, n), nil, 10);
    ifc->sendra6      = atoi(findfield("sendra", f, n));
    ifc->recvra6      = atoi(findfield("recvra", f, n));
    ifc->rp.mflag     = atoi(findfield("mflag", f, n));
    ifc->rp.oflag     = atoi(findfield("oflag", f, n));
    ifc->rp.maxraint  = atoi(findfield("maxraint", f, n));
    ifc->rp.minraint  = atoi(findfield("minraint", f, n));
    ifc->rp.linkmtu   = atoi(findfield("linkmtu", f, n));
    ifc->rp.reachtime = atoi(findfield("reachtime", f, n));
    ifc->rp.rxmitra   = atoi(findfield("rxmitra", f, n));
    ifc->rp.ttl       = atoi(findfield("ttl", f, n));
    ifc->rp.routerlt  = atoi(findfield("routerlt", f, n));
    ifc->pktin        = strtoul(findfield("pktin", f, n), nil, 10);
    ifc->pktout       = strtoul(findfield("pktout", f, n), nil, 10);
    ifc->errin        = strtoul(findfield("errin", f, n), nil, 10);
    ifc->errout       = strtoul(findfield("errout", f, n), nil, 10);

    /* now read the addresses */
    ll = &ifc->lifc;
    for(i = 1; i < lines; i++){
        n = tokenize(line[i], f, nelem(f));
        if(n < 5)
            break;

        /* allocate new local address */
        *ll = lifc = mallocz(sizeof(Iplifc), 1);
        ll = &lifc->next;

        parseip(lifc->ip, f[0]);
        parseipmask(lifc->mask, f[1]);
        parseip(lifc->net, f[2]);

        lifc->validlt = strtoul(f[3], nil, 10);
        lifc->preflt = strtoul(f[4], nil, 10);
    }

    return l;
}
@


<<function _freeifc>>=
static void
_freeifc(Ipifc *ifc)
{
    Ipifc *next;
    Iplifc *lnext, *lifc;

    if(ifc == nil)
        return;
    for(; ifc; ifc = next){
        next = ifc->next;
        for(lifc = ifc->lifc; lifc; lifc = lnext){
            lnext = lifc->next;
            free(lifc);
        }
        free(ifc);
    }
}
@

<<function findfield>>=
static char*
findfield(char *name, char **f, int n)
{
    int i;

    for(i = 0; i < n-1; i++)
        if(strcmp(f[i], name) == 0)
            return f[i+1];
    return "";
}
@

%<<function _readoldipifc>>=
%static Ipifc**
%_readoldipifc(char *buf, Ipifc **l, int index)
%{
%    char *f[200];
%    int i, n;
%    Ipifc *ifc;
%    Iplifc *lifc, **ll;
%
%    /* allocate new interface */
%    *l = ifc = mallocz(sizeof(Ipifc), 1);
%    if(ifc == nil)
%        return l;
%    l = &ifc->next;
%    ifc->index = index;
%
%    n = tokenize(buf, f, nelem(f));
%    if(n < 2)
%        return l;
%
%    strncpy(ifc->dev, f[0], sizeof ifc->dev);
%    ifc->dev[sizeof(ifc->dev) - 1] = 0;
%    ifc->mtu = strtoul(f[1], nil, 10);
%
%    ll = &ifc->lifc;
%    for(i = 2; n-i >= 7; i += 7){
%        /* allocate new local address */
%        *ll = lifc = mallocz(sizeof(Iplifc), 1);
%        ll = &lifc->next;
%
%        parseip(lifc->ip, f[i]);
%        parseipmask(lifc->mask, f[i+1]);
%        parseip(lifc->net, f[i+2]);
%        ifc->pktin = strtoul(f[i+3], nil, 10);
%        ifc->pktout = strtoul(f[i+4], nil, 10);
%        ifc->errin = strtoul(f[i+5], nil, 10);
%        ifc->errout = strtoul(f[i+6], nil, 10);
%    }
%    return l;
%}
%@


\subsection{[[/net/ipifc/x]]}

<<function myipaddr>>=
/* find first ip addr that isn't the friggin loopback address
 * unless there are no others 
 */
int
myipaddr(uchar *ip, char *net)
{
    Ipifc *nifc;
    Iplifc *lifc;
    static Ipifc *ifc;
    uchar mynet[IPaddrlen];

    ifc = readipifc(net, ifc, -1);
    for(nifc = ifc; nifc; nifc = nifc->next)
        for(lifc = nifc->lifc; lifc; lifc = lifc->next){
            maskip(lifc->ip, loopbackmask, mynet);
            if(ipcmp(mynet, loopbacknet) == 0){
                continue;
            }
            if(ipcmp(lifc->ip, IPnoaddr) != 0){
                ipmove(ip, lifc->ip);
                return 0;
            }
        }
    ipmove(ip, IPnoaddr);
    return -1;
}
@

\subsection{[[/net/ipifc/stats]]}

<<function ipifcstats>>=
int
ipifcstats(Proto *ipifc, char *buf, int len)
{
    return ipstats(ipifc->f, buf, len);
}
@

<<function ipstats>>=
int
ipstats(Fs *f, char *buf, int len)
{
    IP *ip;
    char *p, *e;
    int i;

    ip = f->ip;
    ip->stats[DefaultTTL] = MAXTTL;

    p = buf;
    e = p+len;
    for(i = 0; i < Nipstats; i++)
        p = seprint(p, e, "%s: %llud\n", statnames[i], ip->stats[i]);
    return p - buf;
}
@


\section{Binding ethernet medium}

% not really initialisation, more configuration, so better moved
% here, because harder to explain before.

%linux: ifconfig eth0 ...

% open /net/ipifc/clone and start configure things.
%  echo 'bind ether /net/ether0' > /net/ipifc/0/ctl
%  echo 'add 10.0.2.15' > /net/ipifc/0/ctl
% (but how I guessed my ip? ipconfig use dhcp?)

% or use program:
% $ ip/ipconfig
% => /net/ipifc/0/... now contains an interface! connected to ethernet
%    /net/ipifc/0/status is nice
% => /net/arp now contains entries
% => /net/iproute now contains entries

% Have seen the first part with bind of Ipifc Protocol.
% Now will see the bind of the ethernet medium.


\subsection{[[etherbind()]]}

% ??? -> <>
%   (as x->bind <- ...)
<<function etherbind>>=
/*
 *  called to bind an IP ifc to an ethernet device
 *  called with ifc wlock'd
 */
static void
etherbind(Ipifc *ifc, int argc, char **argv)
{
    Chan *mchan4, *cchan4, *achan, *mchan6, *cchan6, *schan;
    char addr[Maxpath]; //char addr[2*KNAMELEN];
    char dir[Maxpath];  //char dir[2*KNAMELEN];
    char *buf;
    int n;
    char *ptr;
    Etherrock *er;

    if(argc < 2)
        error(Ebadarg);

    mchan4 = cchan4 = achan = mchan6 = cchan6 = nil;
    buf = nil;
    if(waserror()){
        if(mchan4 != nil)
            cclose(mchan4);
        if(cchan4 != nil)
            cclose(cchan4);
        if(achan != nil)
            cclose(achan);
        if(mchan6 != nil)
            cclose(mchan6);
        if(cchan6 != nil)
            cclose(cchan6);
        if(buf != nil)
            free(buf);
        nexterror();
    }

    /*
     *  open ipv4 conversation
     *
     *  the dial will fail if the type is already open on
     *  this device.
     */
    snprint(addr, sizeof(addr), "%s!0x800", argv[2]);   /* ETIP4 */
    mchan4 = chandial(addr, nil, dir, &cchan4);

    /*
     *  make it non-blocking
     */
    devtab[cchan4->type]->write(cchan4, nbmsg, strlen(nbmsg), 0);

    /*
     *  get mac address and speed
     */
    snprint(addr, sizeof(addr), "%s/stats", argv[2]);
    buf = smalloc(512);
    schan = namec(addr, Aopen, OREAD, 0);
    if(waserror()){
        cclose(schan);
        nexterror();
    }
    n = devtab[schan->type]->read(schan, buf, 511, 0);
    cclose(schan);
    poperror();
    buf[n] = 0;

    ptr = strstr(buf, "addr: ");
    if(!ptr)
        error(Eio);
    ptr += 6;
    parsemac(ifc->mac, ptr, 6);

    ptr = strstr(buf, "mbps: ");
    if(ptr){
        ptr += 6;
        ifc->mbps = atoi(ptr);
    } else
        ifc->mbps = 100;

    /*
     *  open arp conversation
     */
    snprint(addr, sizeof(addr), "%s!0x806", argv[2]);   /* ETARP */
    achan = chandial(addr, nil, nil, nil);

    /*
     *  open ipv6 conversation
     *
     *  the dial will fail if the type is already open on
     *  this device.
     */
    snprint(addr, sizeof(addr), "%s!0x86DD", argv[2]);  /* ETIP6 */
    mchan6 = chandial(addr, nil, dir, &cchan6);

    /*
     *  make it non-blocking
     */
    devtab[cchan6->type]->write(cchan6, nbmsg, strlen(nbmsg), 0);

    er = smalloc(sizeof(*er));
    er->mchan4 = mchan4;
    er->cchan4 = cchan4;
    er->achan = achan;
    er->mchan6 = mchan6;
    er->cchan6 = cchan6;
    er->f = ifc->conv->p->f;
    ifc->arg = er;

    free(buf);
    poperror();

    kproc("etherread4", etherread4, ifc);
    kproc("recvarpproc", recvarpproc, ifc);
    kproc("etherread6", etherread6, ifc);
}
@

\subsection{[[chandial()]]}

\section{Routes}


\section{Advanced configurations}

\subsection{Routing}
% quite important, for gateways?

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "iprouting") == 0){
    i = 1;
    if(argc > 1)
        i = atoi(argv[1]);
    iprouting(cv->p->f, i);
    return nil;
}
@

<<function iprouting>>=
void
iprouting(Fs *f, bool on)
{
    f->ip->iprouting = on;
    if(f->ip->iprouting == false)
        f->ip->stats[Forwarding] = 2;
    else
        f->ip->stats[Forwarding] = 1;
}
@

\subsection{MTU}

<<[[ipifcadd()]] switch argc, mtu setting case, and fall through>>=
// add <ip> <mask> <rem> <mtu>
case 5:
    mtu = strtoul(argv[4], 0, 0);
    if(mtu >= ifc->m->mintu && mtu <= ifc->m->maxtu)
        ifc->maxtu = mtu;
    /* fall through */
@


<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "mtu") == 0)
    return ipifcsetmtu(ifc, argv, argc);
@

<<function ipifcsetmtu>>=
/*
 *  change an interface's mtu
 */
char*
ipifcsetmtu(Ipifc *ifc, char **argv, int argc)
{
    int mtu;

    if(argc < 2 || ifc->m == nil)
        return Ebadarg;
    mtu = strtoul(argv[1], 0, 0);
    if(mtu < ifc->m->mintu || mtu > ifc->m->maxtu)
        return Ebadarg;
    ifc->maxtu = mtu;
    return nil;
}
@


\subsection{TOS}

<<[[Conv(kernel)]] other fields>>=
uint  tos;      /* type of service */
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "tos") == 0)
    tosctlmsg(cv, cb);
@

<<function tosctlmsg>>=
static void
tosctlmsg(Conv *c, Cmdbuf *cb)
{
    if(cb->nf < 2)
        c->tos = 0;
    else
        c->tos = atoi(cb->f[1]);
}
@

\subsection{TTL}

<<[[Conv(kernel)]] other fields>>=
uint  ttl;      /* max time to live */
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "ttl") == 0)
    ttlctlmsg(cv, cb);
@

<<function ttlctlmsg>>=
static void
ttlctlmsg(Conv *c, Cmdbuf *cb)
{
    if(cb->nf < 2)
        c->ttl = MAXTTL;
    else
        c->ttl = atoi(cb->f[1]);
}
@

<<constant MAXTTL>>=
MAXTTL=   255,
@

\subsection{Unbind on close}

<<[[Medium(kernel)]] other fields>>=
bool unbindonclose;  /* if non-zero, unbind on last close */
@

<<function ipifcclose>>=
/*
 *  called after last close of ipifc data or ctl
 *  called with c locked, we must unlock
 */
static void
ipifcclose(Conv *c)
{
    Ipifc *ifc;
    Medium *m;

    ifc = (Ipifc*)c->ptcl;
    m = ifc->m;
    if(m && m->unbindonclose)
        ipifcunbind(ifc);
}
@

\subsection{Dynamic interface, removing, unbinding, etc}

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "remove") == 0)
    return ipifcrem(ifc, argv, argc);
@

%less: comment not valid anymore? car not a conv field anymore
<<function ipifcrem>>=
/*
 *  remove an address from an interface.
 *  called with c->car locked
 */
char*
ipifcrem(Ipifc *ifc, char **argv, int argc)
{
    char *rv;
    uchar ip[IPaddrlen], mask[IPaddrlen], rem[IPaddrlen];
    Iplifc *lifc;

    if(argc < 3)
        return Ebadarg;

    if (parseip(ip, argv[1]) == -1)
        return Ebadip;
    parseipmask(mask, argv[2]);
    if(argc < 4)
        maskip(ip, mask, rem);
    else
        if (parseip(rem, argv[3]) == -1)
            return Ebadip;

    wlock(ifc);

    /*
     *  find address on this interface and remove from chain.
     *  for pt to pt we actually specify the remote address as the
     *  addresss to remove.
     */
    for(lifc = ifc->lifc; lifc != nil; lifc = lifc->next) {
        if (memcmp(ip, lifc->local, IPaddrlen) == 0
        && memcmp(mask, lifc->mask, IPaddrlen) == 0
        && memcmp(rem, lifc->remote, IPaddrlen) == 0)
            break;
    }

    rv = ipifcremlifc(ifc, lifc);
    wunlock(ifc);
    return rv;
}
@




<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "unbind") == 0)
    return ipifcunbind(ifc);
@

<<function ipifcunbind>>=
/*
 *  detach a device from an interface, close the interface
 *  called with ifc->conv closed
 */
static char*
ipifcunbind(Ipifc *ifc)
{
    char *err;

    if(waserror()){
        wunlock(ifc);
        nexterror();
    }
    wlock(ifc);

    /* dissociate routes */
    if(ifc->m != nil && ifc->m->unbindonclose == false)
        ifc->conv->inuse--;
    ifc->ifcid++;

    /* disassociate logical interfaces (before zeroing ifc->arg) */
    while(ifc->lifc){
        err = ipifcremlifc(ifc, ifc->lifc);
        /*
         * note: err non-zero means lifc not found,
         * which can't happen in this case.
         */
        if(err)
            error(err);
    }

    /* disassociate device */
    if(ifc->m && ifc->m->unbind)
        (*ifc->m->unbind)(ifc);
    memset(ifc->dev, 0, sizeof(ifc->dev));
    ifc->arg = nil;
    ifc->reassemble = 0;

    /* close queues to stop queuing of packets */
    qclose(ifc->conv->rq);
    qclose(ifc->conv->wq);
    qclose(ifc->conv->sq);

    ifc->m = nil;
    wunlock(ifc);
    poperror();
    return nil;
}
@






\chapter{Internetwork Transport, IP}

% RFC 79, Internet Protocol

\section{IP addresses}

\subsection{Parsing}

%ex: ip address 10.0.0.2
<<function v4parseip>>=
char*
v4parseip(uchar *to, char *from)
{
    int i;
    char *p;

    p = from;
    for(i = 0; i < 4 && *p; i++){
        to[i] = strtoul(p, &p, 0);
        if(*p == '.')
            p++;
    }
    switch(CLASS(to)){
    case 0:	/* class A - 1 uchar net */
    case 1:
        if(i == 3){
            to[3] = to[2];
            to[2] = to[1];
            to[1] = 0;
        } else if (i == 2){
            to[3] = to[1];
            to[1] = 0;
        }
        break;
    case 2:	/* class B - 2 uchar net */
        if(i == 3){
            to[3] = to[2];
            to[2] = 0;
        }
        break;
    }
    return p;
}
@

<<function parseip>>=
/*
 * `from' may contain an address followed by other characters,
 * at least in /boot, so we permit whitespace (and more) after the address.
 * we do ensure that "delete" cannot be parsed as "de::".
 *
 * some callers don't check the return value for errors, so
 * set `to' to something distinctive in the case of a parse error.
 */
vlong
parseip(uchar *to, char *from)
{
    int i, elipsis = 0;
    bool v4 = true;
    ulong x;
    char *p, *op;

    memset(to, 0, IPaddrlen);
    p = from;
    for(i = 0; i < IPaddrlen && ipcharok(*p); i+=2){
        op = p;
        x = strtoul(p, &p, 16);
        if((*p == '.' && i <= IPaddrlen-4) || (*p == '\0' && i == 0)){
            /* ends with v4 */
            p = v4parseip(to+i, op);
            i += 4;
            break;
        }

        /* v6: at most 4 hex digits, followed by colon or delim */
        if(x != (ushort)x || *p != ':' && !delimchar(*p)) {
            memset(to, 0, IPaddrlen);
            return -1;			/* parse error */
        }
        to[i] = x>>8;
        to[i+1] = x;
        if(*p == ':'){
            v4 = false;
            if(*++p == ':'){	/* :: is elided zero short(s) */
                if (elipsis) {
                    memset(to, 0, IPaddrlen);
                    return -1;	/* second :: */
                }
                elipsis = i+2;
                p++;
            }
        } else if (p == op)		/* strtoul made no progress? */
            break;
    }
    if (p == from || !delimchar(*p)) {
        memset(to, 0, IPaddrlen);
        return -1;				/* parse error */
    }
    if(i < IPaddrlen){
        memmove(&to[elipsis+IPaddrlen-i], &to[elipsis], i-elipsis);
        memset(&to[elipsis], 0, IPaddrlen-i);
    }

    if(v4){
        to[10] = to[11] = 0xff;
        return nhgetl(to + IPv4off);
    } else
        return 6;
}
@

\subsection{Comparisons}

<<macro ipcmp>>=
#define	ipcmp(x, y) memcmp(x, y, IPaddrlen)
@

<<macro ipmove>>=
#define	ipmove(x, y) memmove(x, y, IPaddrlen)
@

<<function equivip4>>=
bool
equivip4(uchar *a, uchar *b)
{
    int i;

    for(i = 0; i < 4; i++)
        if(a[i] != b[i])
            return false;
    return true;
}
@
%less: diff with ipcmp? used?


\section{IP header}

% now in core DS

\subsection{Byte ordering}

% Network standard byte order

% put the nhgets, hngets here


\subsection{Checksum}

% fault tolerance! important

<<function ptclcsum>>=
ushort
ptclcsum(Block *bp, int offset, int len)
{
    uchar *addr;
    ulong losum, hisum;
    ushort csum;
    int odd, blocklen, x;

    /* Correct to front of data area */
    while(bp != nil && offset && offset >= BLEN(bp)) {
        offset -= BLEN(bp);
        bp = bp->next;
    }
    if(bp == nil)
        return 0;

    addr = bp->rp + offset;
    blocklen = BLEN(bp) - offset;

    if(bp->next == nil) {
        if(blocklen < len)
            len = blocklen;
        return ~ptclbsum(addr, len) & 0xffff;
    }

    losum = 0;
    hisum = 0;

    odd = 0;
    while(len) {
        x = blocklen;
        if(len < x)
            x = len;

        csum = ptclbsum(addr, x);
        if(odd)
            hisum += csum;
        else
            losum += csum;
        odd = (odd+x) & 1;
        len -= x;

        bp = bp->next;
        if(bp == nil)
            break;
        blocklen = BLEN(bp);
        addr = bp->rp;
    }

    losum += hisum>>8;
    losum += (hisum&0xff)<<8;
    while((csum = losum>>16) != 0)
        losum = csum + (losum & 0xffff);

    return ~losum & 0xffff;
}
@


<<function ipcsum>>=
ushort
ipcsum(uchar *addr)
{
    int len;
    ulong sum;

    sum = 0;
    len = (addr[0]&0xf)<<2;

    while(len > 0) {
        sum += addr[0]<<8 | addr[1] ;
        len -= 2;
        addr += 2;
    }

    sum = (sum & 0xffff) + (sum >> 16);
    sum = (sum & 0xffff) + (sum >> 16);

    return (sum^0xffff);
}
@

\section{IO}

\subsection{Writing, [[ipoput4()]]}
% IP out-put v4

% syswrite(..., /net/x/y/data) -> udpkick | ... -> <>
% assume bp has already an IP header with many fields already set (e.g. dst)
<<function ipoput4>>=
int
ipoput4(Fs *f, Block *bp, bool gating, int ttl, int tos, Conv *c)
{
    IP *ip;
    Ip4hdr *eh;
    Ipifc *ifc;
    Route *r, *sr;
    uchar *gate;
    int len, medialen;
    int rv = OK_0;

    <<[[ipoput4()]] locals>>

    ip = f->ip;

    /* Fill out the ip header */
    eh = (Ip4hdr*)(bp->rp);

    ip->stats[OutRequests]++;

    /* Number of uchars in data and ip header to write */
    len = blocklen(bp);

    <<[[ipoput4()]] if gating>>

    <<[[ipoput4()]] error if too big packet of length len>>

    // Finding the route for the destination!
    r = v4lookup(f, eh->dst, c);
    <<[[ipoput4()]] error if no route r>>

    ifc = r->ifc;
    <<[[ipoput4()]] set gate according to type of route>>

    if(!gating) {
        eh->vihl = IP_VER4|IP_HLEN4;
        eh->tos = tos;
    }
    eh->ttl = ttl;

    <<[[ipoput4()]] rlock ifc, goto free if cant>>
    <<[[ipoput4()]] error if no medium attached to interface ifc>>

    /* If we dont need to fragment just send it */
    <<[[ipoput4()]] if manual fragmentation setting>>
    else
        medialen = ifc->maxtu - ifc->m->hsize;

    <<[[ipoput4()]] if no need to fragment, write simply to medium and return>>
    <<[[ipoput4()]] else, need to fragment>>

raise:
    runlock(ifc);
    poperror();
free:
    freeblist(bp);
    return rv;
}
@


\subsubsection{Header constants}

<<constant IP_VER4>>=
IP_VER4=  0x40,
@
<<constant IP_HLEN4>>=
IP_HLEN4= 5,    /* v4: Header length in words */
@

\subsubsection{Finding the gateway}

<<[[ipoput4()]] set gate according to type of route>>=
if(r->type & (Rifc|Runi))
    gate = eh->dst;
else
<<[[ipoput4()]] adjust gate and ifc if broadcast or multicast case>>
else
    gate = r->v4.gate;
@

\subsubsection{Small send}

% setting id field, increment id4

<<[[ipoput4()]] if no need to fragment, write simply to medium and return>>=
if(len <= medialen) {
    if(!gating)
        hnputs(eh->id, incref(&ip->id4));
    hnputs(eh->length, len);
    // no fragment
    if(!gating){
        eh->frag[0] = 0;
        eh->frag[1] = 0;
    }
    eh->cksum[0] = 0;
    eh->cksum[1] = 0;
    hnputs(eh->cksum, ipcsum(&eh->vihl));
    assert(bp->next == nil);

    // Medium dispatch
    ifc->m->bwrite(ifc, bp, V4, gate);

    runlock(ifc);
    poperror();
    return OK_0;
}
@

\subsubsection{Fragmentation}

% Note that different from TCP packeting and reliable
% reordering. Here it's a packet to send through an hardware medium,
% e.g ethernet, it's reliable, there is no long distance. You fragment
% the packet to go to the gateway and the gateway will reassemble it
% and maybe refragment if it's medium also has a limited capacity.
% The order is always correct.

<<[[ipoput4()]] locals>>=
Ip4hdr *feh;
ulong fragoff;
Block *xp, *nb;
int lid, seglen, chunk, dlen, blklen, offset;
@

<<[[ipoput4()]] else, need to fragment>>=

if(eh->frag[0] & (IP_DF>>8)){
    if (!gating) 
      print("%V: DF set\n", eh->dst);
    ip->stats[FragFails]++;
    ip->stats[OutDiscards]++;
    icmpcantfrag(f, bp, medialen);
    netlog(f, Logip, "%V: eh->frag[0] & (IP_DF>>8)\n", eh->dst);
    goto raise;
}

seglen = (medialen - IP4HDR) & ~7;
if(seglen < 8){
    ip->stats[FragFails]++;
    ip->stats[OutDiscards]++;
    netlog(f, Logip, "%V seglen < 8\n", eh->dst);
    goto raise;
}

dlen = len - IP4HDR;
xp = bp;
if(gating)
    lid = nhgets(eh->id);
else
    lid = incref(&ip->id4);

offset = IP4HDR;
while(xp != nil && offset && offset >= BLEN(xp)) {
    offset -= BLEN(xp);
    xp = xp->next;
}
xp->rp += offset;

if(gating)
    fragoff = nhgets(eh->frag)<<3;
else
    fragoff = 0;
dlen += fragoff;

for(; fragoff < dlen; fragoff += seglen) {
    nb = allocb(IP4HDR+seglen);
    feh = (Ip4hdr*)(nb->rp);

    memmove(nb->wp, eh, IP4HDR);
    nb->wp += IP4HDR;

    if((fragoff + seglen) >= dlen) {
        seglen = dlen - fragoff;
        hnputs(feh->frag, fragoff>>3);
    }
    else
        hnputs(feh->frag, (fragoff>>3)|IP_MF);

    hnputs(feh->length, seglen + IP4HDR);
    hnputs(feh->id, lid);

    /* Copy up the data area */
    chunk = seglen;
    while(chunk) {
        if(!xp) {
            ip->stats[OutDiscards]++;
            ip->stats[FragFails]++;
            freeblist(nb);
            netlog(f, Logip, "!xp: chunk %d\n", chunk);
            goto raise;
        }
        blklen = chunk;
        if(BLEN(xp) < chunk)
            blklen = BLEN(xp);
        memmove(nb->wp, xp->rp, blklen);
        nb->wp += blklen;
        xp->rp += blklen;
        chunk -= blklen;
        if(xp->rp == xp->wp)
            xp = xp->next;
    }

    feh->cksum[0] = 0;
    feh->cksum[1] = 0;
    hnputs(feh->cksum, ipcsum(&feh->vihl));

    // Medium dispatch, send this fragment
    ifc->m->bwrite(ifc, nb, V4, gate);

    ip->stats[FragCreates]++;
}
ip->stats[FragOKs]++;
@


\subsubsection{Error managment}

<<constant IP_MAX>>=
IP_MAX=   64*1024,  /* Max. Internet packet size, v4 & v6 */
@

<<[[ipoput4()]] error if too big packet of length len>>=
if(len >= IP_MAX){
    ip->stats[OutDiscards]++;
    netlog(f, Logip, "exceeded ip max size %V\n", eh->dst);
    goto free;
}
@

<<[[ipoput4()]] error if no route r>>=
if(r == nil){
    ip->stats[OutNoRoutes]++;
    netlog(f, Logip, "no interface %V\n", eh->dst);
    rv = -1;
    goto free;
}
@

<<[[ipoput4()]] error if no medium attached to interface ifc>>=
if(ifc->m == nil)
    goto raise;
@

<<[[ipoput4()]] rlock ifc, goto free if cant>>=
if(!canrlock(ifc))
    goto free;
if(waserror()){
    runlock(ifc);
    nexterror();
}
@

\subsection{Reading, [[ipiput4()]]}

% here you don't know what is the destination conversation! As opposed to
% ipoput, here there is not yet any associated Conv.
% This function actually do dispatch the packet to the right protocol,
% which then will possibly dispatch to the right conversation (or create
% a new one) 

% loopbackread | network interrupt?? -> <>
<<function ipiput4>>=
void
ipiput4(Fs *f, Ipifc *ifc, Block *bp)
{
    IP *ip;
    Ip4hdr *h;
    uchar v6dst[IPaddrlen];
    // enum<protocol_type>
    int proto;
    Proto *p;
    bool notforme;
    <<[[ipiput4()]] locals>>

    <<[[ipiput4()]] call ipiput6 if block is not ipv4>>

    ip = f->ip;
    ip->stats[InReceives]++;

    <<[[ipiput4()]] ensure we have all the header in the first block>>

    h = (Ip4hdr*)(bp->rp);

    <<[[ipiput4()]] check header checksum>>

    v4tov6(v6dst, h->dst);
    notforme = ipforme(f, v6dst) == 0;

    <<[[ipiput4()]] check header length and version>>

    <<[[ipiput4()]] if notforme>>
    // else have a ipforme

    <<[[ipiput4()]] possibly defragment and reassemble>>

    /* don't let any frag info go up the stack */
    h->frag[0] = 0;
    h->frag[1] = 0;

    proto = h->proto;
    p = Fsrcvpcol(f, proto);

    if(p != nil && p->rcv != nil) {
        ip->stats[InDelivers]++;

        // Protocol dispatch
        (*p->rcv)(p, ifc, bp);
        return;
    }

    ip->stats[InDiscards]++;
    ip->stats[InUnknownProtos]++;
    freeblist(bp);
}
@

\subsubsection{Checks}

<<[[ipiput4()]] check header checksum>>=
/* dump anything that whose header doesn't checksum */
if((bp->flag & Bipck) == 0 && ipcsum(&h->vihl)) {
    ip->stats[InHdrErrors]++;
    netlog(f, Logip, "ip: checksum error %V\n", h->src);
    freeblist(bp);
    return;
}
@

<<[[ipiput4()]] locals>>=
int hl;
int olen;
uchar *dp;
@

<<[[ipiput4()]] check header length and version>>=
/* Check header length and version */
if((h->vihl&0x0F) != IP_HLEN4) {
    hl = (h->vihl&0xF)<<2;
    if(hl < (IP_HLEN4<<2)) {
        ip->stats[InHdrErrors]++;
        netlog(f, Logip, "ip: %V bad hivl %ux\n", h->src, h->vihl);
        freeblist(bp);
        return;
    }
    /* If this is not routed strip off the options */
    if(notforme == false) {
        olen = nhgets(h->length);
        dp = bp->rp + (hl - (IP_HLEN4<<2));
        memmove(dp, h, IP_HLEN4<<2);
        bp->rp = dp;
        h = (Ip4hdr*)(bp->rp);
        h->vihl = (IP_VER4|IP_HLEN4);
        hnputs(h->length, olen-hl+(IP_HLEN4<<2));
    }
}
@

\subsubsection{Protocol dispatching}
% protocol demultiplexing

<<function Fsrcvpcol>>=
Proto*
Fsrcvpcol(Fs* f, uchar proto)
{
   return f->t2p[proto];
}
@
%dead?
%    <<[[Fsrcvpcol()]] if ipmux>>
%    else

\subsubsection{Small receive}

\subsubsection{Defragmentation}

<<[[ipiput4()]] locals>>=
ushort frag;
@

<<[[ipiput4()]] possibly defragment and reassemble>>=
frag = nhgets(h->frag);
if(frag) {
    h->tos = 0;
    if(frag & IP_MF)
        h->tos = 1;
    bp = ip4reassemble(ip, frag, bp, h);
    if(bp == nil)
        return;
    h = (Ip4hdr*)(bp->rp);
}
@

<<function ip4reassemble>>=
Block*
ip4reassemble(IP *ip, int offset, Block *bp, Ip4hdr *ih)
{
    int fend;
    ushort id;
    Fragment4 *f, *fnext;
    ulong src, dst;
    Block *bl, **l, *last, *prev;
    int ovlap, len, fragsize, pktposn;

    src = nhgetl(ih->src);
    dst = nhgetl(ih->dst);
    id = nhgets(ih->id);

    /*
     *  block lists are too hard, pullupblock into a single block
     */
    if(bp->next){
        bp = pullupblock(bp, blocklen(bp));
        ih = (Ip4hdr*)(bp->rp);
    }

    qlock(&ip->fraglock4);

    /*
     *  find a reassembly queue for this fragment
     */
    for(f = ip->flisthead4; f; f = fnext){
        fnext = f->next;    /* because ipfragfree4 changes the list */
        if(f->src == src && f->dst == dst && f->id == id)
            break;
        if(f->age < NOW){
            ip->stats[ReasmTimeout]++;
            ipfragfree4(ip, f);
        }
    }

    /*
     *  if this isn't a fragmented packet, accept it
     *  and get rid of any fragments that might go
     *  with it.
     */
    if(!ih->tos && (offset & ~(IP_MF|IP_DF)) == 0) {
        if(f != nil) {
            ipfragfree4(ip, f);
            ip->stats[ReasmFails]++;
        }
        qunlock(&ip->fraglock4);
        return bp;
    }

    if(bp->base+IPFRAGSZ >= bp->rp){
        bp = padblock(bp, IPFRAGSZ);
        bp->rp += IPFRAGSZ;
    }

    BKFG(bp)->foff = offset<<3;
    BKFG(bp)->flen = nhgets(ih->length)-IP4HDR;

    /* First fragment allocates a reassembly queue */
    if(f == nil) {
        f = ipfragallo4(ip);
        f->id = id;
        f->src = src;
        f->dst = dst;

        f->blist = bp;

        qunlock(&ip->fraglock4);
        ip->stats[ReasmReqds]++;
        return nil;
    }

    /*
     *  find the new fragment's position in the queue
     */
    prev = nil;
    l = &f->blist;
    bl = f->blist;
    while(bl != nil && BKFG(bp)->foff > BKFG(bl)->foff) {
        prev = bl;
        l = &bl->next;
        bl = bl->next;
    }

    /* Check overlap of a previous fragment - trim away as necessary */
    if(prev) {
        ovlap = BKFG(prev)->foff + BKFG(prev)->flen - BKFG(bp)->foff;
        if(ovlap > 0) {
            if(ovlap >= BKFG(bp)->flen) {
                freeblist(bp);
                qunlock(&ip->fraglock4);
                return nil;
            }
            BKFG(prev)->flen -= ovlap;
        }
    }

    /* Link onto assembly queue */
    bp->next = *l;
    *l = bp;

    /* Check to see if succeeding segments overlap */
    if(bp->next) {
        l = &bp->next;
        fend = BKFG(bp)->foff + BKFG(bp)->flen;
        /* Take completely covered segments out */
        while(*l) {
            ovlap = fend - BKFG(*l)->foff;
            if(ovlap <= 0)
                break;
            if(ovlap < BKFG(*l)->flen) {
                BKFG(*l)->flen -= ovlap;
                BKFG(*l)->foff += ovlap;
                /* move up ih hdrs */
                memmove((*l)->rp + ovlap, (*l)->rp, IP4HDR);
                (*l)->rp += ovlap;
                break;
            }
            last = (*l)->next;
            (*l)->next = nil;
            freeblist(*l);
            *l = last;
        }
    }

    /*
     *  look for a complete packet.  if we get to a fragment
     *  without IP_MF set, we're done.
     */
    pktposn = 0;
    for(bl = f->blist; bl; bl = bl->next) {
        if(BKFG(bl)->foff != pktposn)
            break;
        if((BLKIP(bl)->frag[0]&(IP_MF>>8)) == 0) {
            bl = f->blist;
            len = nhgets(BLKIP(bl)->length);
            bl->wp = bl->rp + len;

            /* Pullup all the fragment headers and
             * return a complete packet
             */
            for(bl = bl->next; bl; bl = bl->next) {
                fragsize = BKFG(bl)->flen;
                len += fragsize;
                bl->rp += IP4HDR;
                bl->wp = bl->rp + fragsize;
            }

            bl = f->blist;
            f->blist = nil;
            ipfragfree4(ip, f);
            ih = BLKIP(bl);
            hnputs(ih->length, len);
            qunlock(&ip->fraglock4);
            ip->stats[ReasmOKs]++;
            return bl;
        }
        pktposn += BKFG(bl)->flen;
    }
    qunlock(&ip->fraglock4);
    return nil;
}
@


\subsubsection{Error managment}

\subsubsection{Misc}

<<[[ipiput4()]] ensure we have all the header in the first block>>=
/*
 *  Ensure we have all the header info in the first
 *  block.  Make life easier for other protocols by
 *  collecting up to the first 64 bytes in the first block.
 */
if(BLEN(bp) < 64) {
    hl = blocklen(bp);
    if(hl < IP4HDR)
        hl = IP4HDR;
    if(hl > 64)
        hl = 64;
    bp = pullupblock(bp, hl);
    if(bp == nil)
        return;
}
@

\section{Fragments}

<<function ipfragfree4>>=
/*
 * ipfragfree4 - Free a list of fragments - assume hold fraglock4
 */
void
ipfragfree4(IP *ip, Fragment4 *frag)
{
    Fragment4 *fl, **l;

    if(frag->blist)
        freeblist(frag->blist);

    frag->src = 0;
    frag->id = 0;
    frag->blist = nil;

    l = &ip->flisthead4;
    for(fl = *l; fl; fl = fl->next) {
        if(fl == frag) {
            *l = frag->next;
            break;
        }
        l = &fl->next;
    }

    frag->next = ip->fragfree4;
    ip->fragfree4 = frag;

}
@

<<function ipfragallo4>>=
/*
 * ipfragallo4 - allocate a reassembly queue - assume hold fraglock4
 */
Fragment4 *
ipfragallo4(IP *ip)
{
    Fragment4 *f;

    while(ip->fragfree4 == nil) {
        /* free last entry on fraglist */
        for(f = ip->flisthead4; f->next; f = f->next)
            ;
        ipfragfree4(ip, f);
    }
    f = ip->fragfree4;
    ip->fragfree4 = f->next;
    f->next = ip->flisthead4;
    ip->flisthead4 = f;
    f->age = NOW + 30000;

    return f;
}
@



\section{Advanced features}

\subsection{Gating}

<<[[ipoput4()]] if gating>>=
if(gating){
    chunk = nhgets(eh->length);
    if(chunk > len){
        ip->stats[OutDiscards]++;
        netlog(f, Logip, "short gated packet\n");
        goto free;
    }
    if(chunk < len)
        len = chunk;
}
@

\subsection{Manual fragmentation setting}

<<[[ipoput4()]] if manual fragmentation setting>>=
if(c && c->maxfragsize && c->maxfragsize < ifc->maxtu)
    medialen = c->maxfragsize - ifc->m->hsize;
@

<<[[Conv(kernel)]] other fields>>=
// option<int>, None = 0
int maxfragsize;    /* If set, used for fragmentation */
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "maxfragsize") == 0){
    if(cb->nf < 2)
        error("maxfragsize needs size");

    cv->maxfragsize = (int)strtol(cb->f[1], nil, 0);

} 
@

% no framentation IP_DF here

\subsection{Routing}
% Router?

<<[[ipiput4()]] locals>>=
int hop, tos;
Route *r;
Conv conv;
@

<<[[ipiput4()]] if notforme>>=
    /* route */
    if(notforme) {
        if(!ip->iprouting){
            freeblist(bp);
            return;
        }

        /* don't forward to source's network */
        memset(&conv, 0, sizeof conv);
        conv.r = nil;
        r = v4lookup(f, h->dst, &conv);
        if(r == nil || r->ifc == ifc){
            ip->stats[OutDiscards]++;
            freeblist(bp);
            return;
        }

        /* don't forward if packet has timed out */
        hop = h->ttl;
        if(hop < 1) {
            ip->stats[InHdrErrors]++;
            icmpttlexceeded(f, ifc->lifc->local, bp);
            freeblist(bp);
            return;
        }

        /* reassemble if the interface expects it */
        if(r->ifc == nil) panic("nil route rfc");
        if(r->ifc->reassemble){
            frag = nhgets(h->frag);
            if(frag) {
                h->tos = 0;
                if(frag & IP_MF)
                    h->tos = 1;
                bp = ip4reassemble(ip, frag, bp, h);
                if(bp == nil)
                    return;
                h = (Ip4hdr*)(bp->rp);
            }
        }

        ip->stats[ForwDatagrams]++;
        tos = h->tos;
        hop = h->ttl;

        ipoput4(f, bp, true, hop - 1, tos, &conv);

        return;
    }
@

<<[[IP(kernel)]] routing fields>>=
bool iprouting;  /* true if we route like a gateway */
@

\subsection{Reassembling}

<<[[Ipifc(kernel)]] other fields>>=
bool reassemble; /* reassemble IP packets before forwarding */
@

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "reassemble") == 0){
    ifc->reassemble = true;
    return nil;
}
@


%\subsection{IP multiplexer}

%<<[[Fs(kernel)]] other fields>>=
%Proto*  ipmux;      /* kludge for finding an ip multiplexor */
%@
%
%<<[[Fsrcvpcol()]] if ipmux>>=
%if(f->ipmux)
%    return f->ipmux;
%@
%dead? seems not used



\chapter{Physical Transport, Ethernet}

% ethernet = CSMA-CD (carrier sense multiple access - collision detection)
% with smart binary exponential backoff with random variation when have
% collision.

% ethernet address on top of (CS)MA.





%todo: mv later what is below?

<<global etherxx (kernel)>>=
static Ether *etherxx[MaxEther];
@
<<constant MaxEther>>=
MaxEther  = 48,
@

<<struct Ether (kernel)>>=
struct Ether {
  ISAConf;      /* hardware info */

  int ctlrno;
  int tbdf;     /* type+busno+devno+funcno */
  uchar ea[Eaddrlen];

  void  (*attach)(Ether*);  /* filled in by reset routine */
  void  (*detach)(Ether*);
  void  (*transmit)(Ether*);
  void  (*interrupt)(Ureg*, void*);
  long  (*ifstat)(Ether*, void*, long, ulong);
  long  (*ctl)(Ether*, void*, long); /* custom ctl messages */
  void  (*power)(Ether*, int);  /* power on/off */
  void  (*shutdown)(Ether*);  /* shutdown hardware before reboot */
  void  *ctlr;

  Queue*  oq;

  Netif;
};
@
% in 386 because ISAConf?


\section{Ethernet addresses}

\subsection{Parsing}

%ex: mac address f8:ed:a5:74:92:a1
% strtoul? uchar because ip are 4 integers between 0 and 255
<<function parseether>>=
errorneg1
parseether(uchar *to, char *from)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    for(i = 0; i < 6; i++){
        if(*p == '\0')
            return ERROR_NEG1;
        nip[0] = *p++;
        if(*p == '\0')
            return ERROR_NEG1;
        nip[1] = *p++;
        nip[2] = '\0';
        to[i] = strtoul(nip, 0, 16);
        if(*p == ':')
            p++;
    }
    return OK_0;
}
@

\subsection{[[/net/etherx/addr]]}

<<function myetheraddr>>=
errorneg1
myetheraddr(uchar *to, char *dev)
{
    int n, fd;
    char buf[256];

    if(*dev == '/')
        sprint(buf, "%s/addr", dev);
    else
        sprint(buf, "/net/%s/addr", dev);

    fd = open(buf, OREAD);
    if(fd < 0)
        return ERROR_NEG1;

    n = read(fd, buf, sizeof buf -1 );
    close(fd);
    if(n <= 0)
        return ERROR_NEG1;
    buf[n] = '\0';

    parseether(to, buf);
    return OK_0;
}
@

\section{Ethernet header}

<<struct Etherhdr>>=
struct Etherhdr
{
    uchar   d[6];
    uchar   s[6];
    uchar   t[2];
};
@
%typedef byte etheraddr[6]

% ethermedium.c

\section{Ethernet packet}

<<struct Etherpkt>>=
struct Etherpkt
{
  uchar d[Eaddrlen];
  uchar s[Eaddrlen];
  uchar type[2];

  uchar data[1500];
};
@
% netif.h


\chapter{Finding Machines Locally, ARP}

%XXX
<<[[Medium(kernel)]] address resolution methods>>=
/* address resolution */
void  (*ares)(Fs*, int, uchar*, uchar*, int, int);  /* resolve */
void  (*areg)(Ipifc*, uchar*);      /* register */
@


<<[[Fs(kernel)]] arp fields>>=
Arp *arp;
@


<<struct Arp>>=
/*
 *  one per Fs
 */
struct Arp
{
    Arpent  *rxmt;
    Proc    *rxmitp;    /* neib sol re-transmit proc */

    Rendez  rxmtq;
    Block   *dropf, *dropl;

    Arpent  *hash[NHASH];
    Arpent  cache[NCACHE];

    // Extra
    QLock;
    <<[[Arp]] extra fields>>

};
@

<<[[Arp]] extra fields>>=
// ref<Fs>, reverse of Fs.arp
Fs  *f;
@


<<struct Arpent>>=
struct Arpent
{
  uchar ip[IPaddrlen];
  uchar mac[MAClen];

  Medium  *type;      /* media type */

  Block*  hold;
  Block*  last;
  uint  ctime;      /* time entry was created or refreshed */
  uint  utime;      /* time entry was last used */
  uchar state;
  Arpent  *nextrxt;   /* re-transmit chain */
  uint  rtime;      /* time for next retransmission */
  uchar rxtsrem;

  uchar ifcid;      /* must match ifc->id */

  // Extra
  Arpent* hash;
  Ipifc *ifc;
};
@

\section{Initialisation}

% ipattach -> ipgetfs -> <>
<<function arpinit>>=
void
arpinit(Fs *f)
{
    f->arp = smalloc(sizeof(Arp));
    f->arp->f = f;
    f->arp->rxmt = nil;
    f->arp->dropf = f->arp->dropl = nil;
    kproc("rxmitproc", rxmitproc, f->arp);
}
@

<<function rxmitproc>>=
static void
rxmitproc(void *v)
{
    Arp *arp = v;
    long wakeupat;

    arp->rxmitp = up;
    //print("arp rxmitproc started\n");
    if(waserror()){
        arp->rxmitp = 0;
        pexit("hangup", 1);
    }
    for(;;){
        wakeupat = rxmitsols(arp);
        if(wakeupat == 0)
            sleep(&arp->rxmtq, rxready, v);
        else if(wakeupat > ReTransTimer/4)
            tsleep(&arp->rxmtq, returnfalse, 0, wakeupat);
    }
}
@


\section{[[/net/arp]]}

% See Qarp def in enum qid.

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qarp:
    p = "arp";
    prot = 0664;
    break;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qarp:
case Qiproute:
    if(omode != OREAD && !iseve())
        error(Eperm);
    break;
@

\subsection{Reading}

<<[[ipread()]] switch TYPE qid cases>>=
case Qarp:
    return arpread(f->arp, a, offset, n);
@

<<function arpread>>=
int
arpread(Arp *arp, char *p, ulong offset, int len)
{
    Arpent *a;
    int n;
    char mac[2*MAClen+1];

    if(offset % Alinelen)
        return 0;

    offset = offset/Alinelen;
    len = len/Alinelen;

    n = 0;
    for(a = arp->cache; len > 0 && a < &arp->cache[NCACHE]; a++){
        if(a->state == 0)
            continue;
        if(offset > 0){
            offset--;
            continue;
        }
        len--;
        qlock(arp);
        convmac(mac, &mac[sizeof mac], a->mac, a->type->maclen);
        n += snprint(p+n, Alinelen+1, aformat, a->type->name,
            arpstate[a->state], a->ip, mac);    /* +1 for NUL */
        qunlock(arp);
    }

    return n;
}
@

\subsection{Writing}

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qarp:
    return arpwrite(f, a, n);
@

<<function arpwrite>>=
int
arpwrite(Fs *fs, char *s, int len)
{
    int n;
    Route *r;
    Arp *arp;
    Block *bp;
    Arpent *a, *fl, **l;
    Medium *m;
    char *f[4], buf[256];
    uchar ip[IPaddrlen], mac[MAClen];

    arp = fs->arp;

    if(len == 0)
        error(Ebadarp);
    if(len >= sizeof(buf))
        len = sizeof(buf)-1;
    strncpy(buf, s, len);
    buf[len] = 0;
    if(len > 0 && buf[len-1] == '\n')
        buf[len-1] = 0;

    n = getfields(buf, f, 4, 1, " ");
    if(strcmp(f[0], "flush") == 0){
        qlock(arp);
        for(a = arp->cache; a < &arp->cache[NCACHE]; a++){
            memset(a->ip, 0, sizeof(a->ip));
            memset(a->mac, 0, sizeof(a->mac));
            a->hash = nil;
            a->state = 0;
            a->utime = 0;
            while(a->hold != nil){
                bp = a->hold->list;
                freeblist(a->hold);
                a->hold = bp;
            }
        }
        memset(arp->hash, 0, sizeof(arp->hash));
        /* clear all pkts on these lists (rxmt, dropf/l) */
        arp->rxmt = nil;
        arp->dropf = nil;
        arp->dropl = nil;
        qunlock(arp);
    } else if(strcmp(f[0], "add") == 0){
        switch(n){
        default:
            error(Ebadarg);
        case 3:
            if (parseip(ip, f[1]) == -1)
                error(Ebadip);
            if(isv4(ip))
                r = v4lookup(fs, ip+IPv4off, nil);
            else
                r = v6lookup(fs, ip, nil);
            if(r == nil)
                error("Destination unreachable");
            m = r->ifc->m;
            n = parsemac(mac, f[2], m->maclen);
            break;
        case 4:
            m = ipfindmedium(f[1]);
            if(m == nil)
                error(Ebadarp);
            if (parseip(ip, f[2]) == -1)
                error(Ebadip);
            n = parsemac(mac, f[3], m->maclen);
            break;
        }

        if(m->ares == nil)
            error(Ebadarp);

        m->ares(fs, V6, ip, mac, n, 0);
    } else if(strcmp(f[0], "del") == 0){
        if(n != 2)
            error(Ebadarg);

        if (parseip(ip, f[1]) == -1)
            error(Ebadip);
        qlock(arp);

        l = &arp->hash[haship(ip)];
        for(a = *l; a; a = a->hash){
            if(memcmp(ip, a->ip, sizeof(a->ip)) == 0){
                *l = a->hash;
                break;
            }
            l = &a->hash;
        }

        if(a){
            /* take out of re-transmit chain */
            l = &arp->rxmt;
            for(fl = *l; fl; fl = fl->nextrxt){
                if(fl == a){
                    *l = a->nextrxt;
                    break;
                }
                l = &fl->nextrxt;
            }

            a->nextrxt = nil;
            a->hash = nil;
            a->hold = nil;
            a->last = nil;
            a->ifc = nil;
            memset(a->ip, 0, sizeof(a->ip));
            memset(a->mac, 0, sizeof(a->mac));
        }
        qunlock(arp);
    } else
        error(Ebadarp);

    return len;
}
@



\chapter{Finding Machines Globally, Routes}

%XXX
<<[[Medium(kernel)]] route methods>>=
/* routes for router boards */
void  (*addroute)(Ipifc *ifc, int, uchar*, uchar*, uchar*, int);
void  (*remroute)(Ipifc *ifc, int, uchar*, uchar*);
void  (*flushroutes)(Ipifc *ifc);
@

% ARP allows local routing
% /net/iproute allows inter-network routing, find gateway


<<function v4lookup>>=
Route*
v4lookup(Fs *f, uchar *a, Conv *c)
{
    Route *p, *q;
    ulong la;
    uchar gate[IPaddrlen];
    Ipifc *ifc;

    if(c != nil && c->r != nil && c->r->ifc != nil && c->rgen == v4routegeneration)
        return c->r;

    la = nhgetl(a);
    q = nil;
    for(p=f->v4root[V4H(la)]; p;)
        if(la >= p->v4.address) {
            if(la <= p->v4.endaddress) {
                q = p;
                p = p->mid;
            } else
                p = p->right;
        } else
            p = p->left;

    if(q && (q->ifc == nil || q->ifcid != q->ifc->ifcid)){
        if(q->type & Rifc) {
            hnputl(gate+IPv4off, q->v4.address);
            memmove(gate, v4prefix, IPv4off);
        } else
            v4tov6(gate, q->v4.gate);
        ifc = findipifc(f, gate, q->type);
        if(ifc == nil)
            return nil;
        q->ifc = ifc;
        q->ifcid = ifc->ifcid;
    }

    if(c != nil){
        c->r = q;
        c->rgen = v4routegeneration;
    }

    return q;
}
@



\section{[[/net/ipselftab]]}

<<[[Qid]] toplevel extra cases>>=
Qipselftab,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qipselftab:
    p = "ipselftab";
    prot = 0444;
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qipselftab:
    return ipselftabread(f, a, offset, n);
@

<<function ipselftabread>>=
long
ipselftabread(Fs *f, char *cp, ulong offset, int n)
{
    int i, m, nifc, off;
    Ipself *p;
    Iplink *link;
    char state[8];

    m = 0;
    off = offset;
    qlock(f->self);
    for(i = 0; i < NHASH && m < n; i++){
        for(p = f->self->hash[i]; p != nil && m < n; p = p->next){
            nifc = 0;
            for(link = p->link; link; link = link->selflink)
                nifc++;
            routetype(p->type, state);
            m += snprint(cp + m, n - m, stformat, p->a, nifc, state);
            if(off > 0){
                off -= m;
                m = 0;
            }
        }
    }
    qunlock(f->self);
    return m;
}
@


\section{[[/net/iproutes]]}

% See Qiproute def in enum qid.

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qiproute:
    p = "iproute";
    prot = 0664;
    break;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qiproute:
    return routeread(f, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qiproute:
    return routewrite(f, ch, a, n);
@

\subsection{Reading}

<<function routeread>>=
long
routeread(Fs *f, char *p, ulong offset, int n)
{
    Routewalk rw;

    rw.p = p;
    rw.e = p+n;
    rw.o = -offset;
    rw.walk = sprintroute;

    ipwalkroutes(f, &rw);

    return rw.p - p;
}
@

<<function sprintroute>>=
/*
 *  this code is not in rr to reduce stack size
 */
static void
sprintroute(Route *r, Routewalk *rw)
{
    int nifc, n;
    char t[5], *iname, ifbuf[5];
    uchar addr[IPaddrlen], mask[IPaddrlen], gate[IPaddrlen];
    char *p;

    convroute(r, addr, mask, gate, t, &nifc);
    iname = "-";
    if(nifc != -1) {
        iname = ifbuf;
        snprint(ifbuf, sizeof ifbuf, "%d", nifc);
    }
    p = seprint(rw->p, rw->e, rformat, addr, mask, gate, t, r->tag, iname);
    if(rw->o < 0){
        n = p - rw->p;
        if(n > -rw->o){
            memmove(rw->p, rw->p-rw->o, n+rw->o);
            rw->p = p + rw->o;
        }
        rw->o += n;
    } else
        rw->p = p;
}
@



<<function ipwalkroutes>>=
void
ipwalkroutes(Fs *f, Routewalk *rw)
{
    rlock(&routelock);
    if(rw->e > rw->p) {
        for(rw->h = 0; rw->h < nelem(f->v4root); rw->h++)
            if(rr(f->v4root[rw->h], rw) == 0)
                break;
    }
    if(rw->e > rw->p) {
        for(rw->h = 0; rw->h < nelem(f->v6root); rw->h++)
            if(rr(f->v6root[rw->h], rw) == 0)
                break;
    }
    runlock(&routelock);
}
@

<<function rr>>=
/*
 *  recurse descending tree, applying the function in Routewalk
 */
static int
rr(Route *r, Routewalk *rw)
{
    int h;

    if(rw->e <= rw->p)
        return 0;
    if(r == nil)
        return 1;

    if(rr(r->left, rw) == 0)
        return 0;

    if(r->type & Rv4)
        h = V4H(r->v4.address);
    <<[[rr()]] else if ipv6 address>>

    if(h == rw->h)
        rw->walk(r, rw);

    if(rr(r->mid, rw) == 0)
        return 0;

    return rr(r->right, rw);
}
@


\subsection{Writing}

<<function routewrite>>=
long
routewrite(Fs *f, Chan *c, char *p, int n)
{
    int h, changed;
    char *tag;
    Cmdbuf *cb;
    uchar addr[IPaddrlen];
    uchar mask[IPaddrlen];
    uchar gate[IPaddrlen];
    IPaux *a, *na;
    Route *q;

    cb = parsecmd(p, n);
    if(waserror()){
        free(cb);
        nexterror();
    }

    if(strcmp(cb->f[0], "flush") == 0){
        tag = cb->f[1];
        for(h = 0; h < nelem(f->v4root); h++)
            for(changed = 1; changed;){
                wlock(&routelock);
                changed = routeflush(f, f->v4root[h], tag);
                wunlock(&routelock);
            }
        for(h = 0; h < nelem(f->v6root); h++)
            for(changed = 1; changed;){
                wlock(&routelock);
                changed = routeflush(f, f->v6root[h], tag);
                wunlock(&routelock);
            }
    } else if(strcmp(cb->f[0], "remove") == 0){
        if(cb->nf < 3)
            error(Ebadarg);
        if (parseip(addr, cb->f[1]) == -1)
            error(Ebadip);
        parseipmask(mask, cb->f[2]);
        if(memcmp(addr, v4prefix, IPv4off) == 0)
            v4delroute(f, addr+IPv4off, mask+IPv4off, 1);
        else
            v6delroute(f, addr, mask, 1);
    } else if(strcmp(cb->f[0], "add") == 0){
        if(cb->nf < 4)
            error(Ebadarg);
        if(parseip(addr, cb->f[1]) == -1 ||
            parseip(gate, cb->f[3]) == -1)
            error(Ebadip);
        parseipmask(mask, cb->f[2]);
        tag = "none";
        if(c != nil){
            a = c->aux;
            tag = a->tag;
        }
        if(memcmp(addr, v4prefix, IPv4off) == 0)
            v4addroute(f, tag, addr+IPv4off, mask+IPv4off, gate+IPv4off, 0);
        else
            v6addroute(f, tag, addr, mask, gate, 0);
    } else if(strcmp(cb->f[0], "tag") == 0) {
        if(cb->nf < 2)
            error(Ebadarg);

        a = c->aux;
        na = newipaux(a->owner, cb->f[1]);
        c->aux = na;
        free(a);
    } else if(strcmp(cb->f[0], "route") == 0) {
        if(cb->nf < 2)
            error(Ebadarg);
        if (parseip(addr, cb->f[1]) == -1)
            error(Ebadip);

        q = iproute(f, addr);
        print("%I: ", addr);
        if(q == nil)
            print("no route\n");
        else
            printroute(q);
    }

    poperror();
    free(cb);
    return n;
}
@


\chapter{Basic Communication, UDP}
% U for Unreliable, Unordered :)
% Transmission?

%RFC 768 User Datagram Protocol

% when do ip/ipconfig then can see that 4 InDatagrams and 2 OutDatagrams
% and 2 ports :)

% Essentially IP + port if you look at UDP headers and the difference with
% just the IP header

\section{Protocol initialisation}

% ipattach -> ipgetfs -> <> (as ipprotoinit[i] <- ...)
<<function udpinit>>=
void
udpinit(Fs *fs)
{
    Proto *udp;

    udp = smalloc(sizeof(Proto));
    udp->priv = smalloc(sizeof(Udppriv));

    udp->name = "udp";
    udp->create = udpcreate;
    udp->close = udpclose;

    udp->connect = udpconnect;
    udp->announce = udpannounce;
    udp->ctl = udpctl;

    udp->rcv = udpiput;

    udp->state = udpstate;
    udp->stats = udpstats;

    udp->advise = udpadvise;

    udp->ipproto = IP_UDPPROTO;

    udp->nc = Nchans;
    udp->ptclsize = sizeof(Udpcb);

    Fsproto(fs, udp);
}
@
%less: make it a global with intializer?
% no ->inuse! because UDP is not a connected protocol? because
% it's stateless?

<<constant IP_UDPPROTO>>=
IP_UDPPROTO = 17,
@

<<constant Nchans>>=
Nchans=   1024,
@
% kernel/.../ip.h

\section{Protocol data structures}

\subsection{[[Udppriv]]}

% protocol priv
<<struct Udppriv>>=
struct Udppriv
{
    // hash<(ipaddr * port) , ref<Conv>>
    Ipht        ht;

    <<[[Udppriv]] stat fields>>
};
@
%todo: Ipht? Ip hash table? for the Conv dispatch?

\subsection{Statistics}

% C-s one of this field and you'll understand what does what :)
% which is why it can be useful to present early.
%less: or present with /net/udp/stats later?

<<[[Udppriv]] stat fields>>=
/* MIB counters */
Udpstats    ustats;
/* non-MIB stats */
ulong       csumerr;        /* checksum errors */
ulong       lenerr;         /* short packet */
@
%MIB?

<<struct Udpstats>>=
/* MIB II counters */
struct Udpstats
{
    uvlong  udpInDatagrams;
    ulong   udpNoPorts;
    ulong   udpInErrors;
    uvlong  udpOutDatagrams;
};
@



\section{Protocol header}

<<struct Udp4hdr>>=
struct Udp4hdr
{
    /* ip header */
    uchar   vihl;       /* Version and header length */
    uchar   tos;        /* Type of service */
    uchar   length[2];  /* packet length */
    uchar   id[2];      /* Identification */
    uchar   frag[2];    /* Fragment information */
    uchar   Unused; // ttl

    uchar   udpproto;   /* Protocol */
    uchar   udpplen[2]; /* Header plus data length */
    uchar   udpsrc[IPv4addrlen];    /* Ip source */
    uchar   udpdst[IPv4addrlen];    /* Ip destination */

    /* udp header */
    uchar   udpsport[2];    /* Source port */
    uchar   udpdport[2];    /* Destination port */
    uchar   udplen[2];  /* data length */
    uchar   udpcksum[2];    /* Checksum */
};
@
% do not change the order here :)
% essential IP header + port info.
% why another checksum? because the other is the header checksum!
% here we want a checksum of the data.
%less: why do not use the IpHeader; anonymous field to factorize
% structure definitions? also better see what is udp specific then.

<<constant UDP4_IPHDR_SZ>>=
UDP4_IPHDR_SZ = 20,
@
%less: could factorize and have a IPHDR_SZ?

<<constant UDP_UDPHDR_SZ>>=
UDP_UDPHDR_SZ   = 8,
@

<<constant UDP4_PHDR_OFF>>=
UDP4_PHDR_OFF = 8,
@
% can be different than UDP_UDPHDR_SZ?

<<constant UDP4_PHDR_SZ>>=
UDP4_PHDR_SZ = 12,
@
% diff with UDP_UDPHDR_SZ?




<<struct Udphdr (user)>>=
struct Udphdr
{
    uchar	raddr[IPaddrlen];	/* V6 remote address */
    uchar	laddr[IPaddrlen];	/* V6 local address */
    uchar	ifcaddr[IPaddrlen];	/* V6 ifc addr msg was received on */

    uchar	rport[2];		/* remote port */
    uchar	lport[2];		/* local port */
};
@
% do not change the order here :)
%dead? who uses that?

\section{[[/net/tcp/clone]]}

<<function udpcreate>>=
static void
udpcreate(Conv *cv)
{
    cv->rq = qopen(128*1024, Qmsg, 0, 0);
    cv->wq = qbypass(udpkick, cv);
}
@
% the wq will be accessed via /net/x/y/data

% ipclose -> closeconv -> <> (as x->close)
<<function udpclose>>=
static void
udpclose(Conv *c)
{
    Udpcb *ucb;
    Udppriv *upriv;

    upriv = c->p->priv;
    iphtrem(&upriv->ht, c);

    c->state = Idle;
    qclose(c->rq);
    qclose(c->wq);
    qclose(c->eq);
    ipmove(c->laddr, IPnoaddr);
    ipmove(c->raddr, IPnoaddr);
    c->lport = 0;
    c->rport = 0;

    ucb = (Udpcb*)c->ptcl;
    ucb->headers = 0;
}
@

\section{[[/net/tcp/x/ctl]]}

\subsection{Connect}

<<function udpconnect>>=
static char*
udpconnect(Conv *c, char **argv, int argc)
{
    char *err;
    Udppriv *upriv;

    upriv = c->p->priv;

    err = Fsstdconnect(c, argv, argc);
    Fsconnected(c, err);
    if(err != nil)
        return err;

    iphtadd(&upriv->ht, c);
    return nil;
}
@

\subsection{Announce}

<<function udpannounce>>=
static char*
udpannounce(Conv *c, char** argv, int argc)
{
    char *err;
    Udppriv *upriv;

    upriv = c->p->priv;

    err = Fsstdannounce(c, argv, argc);
    if(err != nil)
        return err;
    Fsconnected(c, nil);

    iphtadd(&upriv->ht, c);

    return nil;
}
@


\section{IO}

\subsection{Writing, [[udpkick()]]}


% ??? -> <> (as x->??   <- udpcreate <- ...)
<<function udpkick>>=
void
udpkick(void *x, Block *bp)
{
    Conv *c = x;
    Conv *rc;
    Udp4hdr *uh4;
    Udppriv *upriv;
    int dlen, ptcllen;
    Fs *f;
    int version;
    <<[[udpkick()]] locals>>

    upriv = c->p->priv;
    f = c->p->f;

//  netlog(c->p->f, Logudp, "udp: kick\n"); /* frequent and uninteresting */
    if(bp == nil)
        return;

    <<[[udpkick()]] special headers processing>>
    <<[[udpkick()]] set version to V4 or V6>>

    dlen = blocklen(bp);

    /* fill in pseudo header and compute checksum */
    switch(version){
    case V4:
        bp = padblock(bp, UDP4_IPHDR_SZ+UDP_UDPHDR_SZ);
        if(bp == nil)
            return;

        uh4 = (Udp4hdr *)(bp->rp);
        ptcllen = dlen + UDP_UDPHDR_SZ;
        uh4->Unused = 0;
        uh4->udpproto = IP_UDPPROTO;
        uh4->frag[0] = 0;
        uh4->frag[1] = 0;
        hnputs(uh4->udpplen, ptcllen);
        <<[[udpkick()]] if special headers>>
        else {
            v6tov4(uh4->udpdst, c->raddr);
            hnputs(uh4->udpdport, c->rport);
            if(ipcmp(c->laddr, IPnoaddr) == 0)
                findlocalip(f, c->laddr, c->raddr);
            v6tov4(uh4->udpsrc, c->laddr);
            rc = c;
        }
        hnputs(uh4->udpsport, c->lport);
        hnputs(uh4->udplen, ptcllen);

        uh4->udpcksum[0] = 0;
        uh4->udpcksum[1] = 0;
        hnputs(uh4->udpcksum,
               ptclcsum(bp, UDP4_PHDR_OFF, dlen+UDP_UDPHDR_SZ+UDP4_PHDR_SZ));
        uh4->vihl = IP_VER4;

        // Let's go, let's send the data
        ipoput4(f, bp, false, c->ttl, c->tos, rc);

        break;

    <<[[udpkick()]] switch version ipv6 case>>

    default:
        panic("udpkick: version %d", version);
    }
    upriv->ustats.udpOutDatagrams++;
}
@

% lots of hnputs

\subsection{Reading, [[udpiput()]]}
% read, iput

%TODO LP split
% -> <> (as x->rcv)
<<function udpiput>>=
void
udpiput(Proto *udp, Ipifc *ifc, Block *bp)
{
    Udppriv *upriv;
    Fs *f;
    Udp4hdr *uh4;
    int version;
    uchar raddr[IPaddrlen], laddr[IPaddrlen];
    ushort rport, lport;
    Conv *c;
    Udpcb *ucb;
    int len;
    <<[[udpiput()]] locals>>
    uchar *p;

    upriv = udp->priv;
    upriv->ustats.udpInDatagrams++;
    f = udp->f;
    uh4 = (Udp4hdr*)(bp->rp);
    <<[[udpiput()]] set version to V4 or V6>>

    <<[[udpiput()]] checking checksum and setting rxxx, lxxx>>

    qlock(udp);

    // find the corresponding conversation
    c = iphtlook(&upriv->ht, raddr, rport, laddr, lport);
    <<[[udpiput()]] if no conversation found>>

    ucb = (Udpcb*)c->ptcl;

    if(c->state == Announced){
        if(ucb->headers == 0){
            /* create a new conversation */
            <<[[udpiput()]] new conv to create, adjust laddr if not Runi>>
            c = Fsnewcall(c, raddr, rport, laddr, lport, version);
            if(c == nil){
                qunlock(udp);
                freeblist(bp);
                return;
            }
            // port may have changed?
            iphtadd(&upriv->ht, c);
            ucb = (Udpcb*)c->ptcl;
        }
    }

    qlock(c);
    qunlock(udp);


    <<[[udpiput()]] trim the packet, adjust bp removing header>>

    netlog(f, Logudpmsg, "udp: %I.%d -> %I.%d l %d\n", raddr, rport,
           laddr, lport, len);

    <<[[udpiput()]] if special headers>>

    if(bp->next)
        bp = concatblock(bp);

    <<[[udpiput()]] if reading queue is full>>

    qpass(c->rq, bp);
    qunlock(c);

}
@
% pass to reading queue of conversation! if not full, otherwise have to drop

% lots of hngets

\subsubsection{New conversation}

<<function Fsnewcall>>=
/*
 *  called with protocol locked
 */
Conv*
Fsnewcall(Conv *c, uchar *raddr, ushort rport, uchar *laddr, ushort lport, uchar version)
{
    Conv *nc;
    Conv **l;
    int i;

    qlock(c);
    i = 0;
    for(l = &c->incall; *l; l = &(*l)->next)
        i++;
    if(i >= Maxincall) {
        static bool beenhere;

        qunlock(c);
        if (!beenhere) {
            beenhere = true;
            print("Fsnewcall: incall queue full (%d) on port %d\n",
                i, c->lport);
        }
        return nil;
    }

    /* find a free conversation */
    nc = Fsprotoclone(c->p, network);
    if(nc == nil) {
        qunlock(c);
        return nil;
    }
    ipmove(nc->raddr, raddr);
    nc->rport = rport;
    ipmove(nc->laddr, laddr);
    nc->lport = lport;

    nc->next = nil;
    *l = nc;

    nc->state = Connected;
    nc->ipversion = version;

    qunlock(c);

    wakeup(&c->listenr);

    return nc;
}
@


\subsubsection{Checks}

<<[[udpiput()]] locals>>=
int ottl, olen;
@

<<[[udpiput()]] checking checksum and setting rxxx, lxxx>>=
/* Put back pseudo header for checksum
 * (remember old values for icmpnoconv()) */
switch(version) {
case V4:
    ottl = uh4->Unused;
    uh4->Unused = 0;
    len = nhgets(uh4->udplen);
    olen = nhgets(uh4->udpplen);
    hnputs(uh4->udpplen, len);

    v4tov6(raddr, uh4->udpsrc);
    v4tov6(laddr, uh4->udpdst);
    lport = nhgets(uh4->udpdport);
    rport = nhgets(uh4->udpsport);

    if(nhgets(uh4->udpcksum)) {
        if(ptclcsum(bp, UDP4_PHDR_OFF, len+UDP4_PHDR_SZ)) {
            upriv->ustats.udpInErrors++;
            netlog(f, Logudp, "udp: checksum error %I\n", raddr);
            DPRINT("udp: checksum error %I\n", raddr);
            freeblist(bp);
            return;
        }
    }
    uh4->Unused = ottl;
    hnputs(uh4->udpplen, olen);
    break;

<<[[udpiput()]] checking checksum ipv6 case>>

default:
    panic("udpiput: version %d", version);
    return; /* to avoid a warning */
}
@

\subsubsection{Trim the packet}

<<[[udpiput()]] trim the packet, adjust bp removing header>>=
/*
 * Trim the packet down to data size
 */
len -= UDP_UDPHDR_SZ;
switch(version){
case V4:
    bp = trimblock(bp, UDP4_IPHDR_SZ+UDP_UDPHDR_SZ, len);
    break;
<<[[udpiput()]] trim the packet, ipv6 case>>
default:
    bp = nil;
    panic("udpiput4: version %d", version);
}
if(bp == nil){
    qunlock(c);
    netlog(f, Logudp, "udp: len err %I.%d -> %I.%d\n", raddr, rport,
           laddr, lport);
    upriv->lenerr++;
    return;
}
@

\subsubsection{Error managment}

<<[[udpiput()]] if no conversation found>>=
if(c == nil){
    /* no conversation found */
    upriv->ustats.udpNoPorts++;
    qunlock(udp);
    netlog(f, Logudp, "udp: no conv %I!%d -> %I!%d\n", raddr, rport,
           laddr, lport);

    switch(version){
    case V4:
        icmpnoconv(f, bp);
        break;
     <<[[udpiput()]] no conversation found, ipv6 case>>
    default:
        panic("udpiput2: version %d", version);
    }

    freeblist(bp);
    return;
}
@

<<[[udpiput()]] if reading queue is full>>=
if(qfull(c->rq)){
    qunlock(c);
    netlog(f, Logudp, "udp: qfull %I.%d -> %I.%d\n", raddr, rport,
           laddr, lport);
    freeblist(bp);
    return;
}
@

\section{Other files}

\subsection{[[/net/tcp/stats]]}

<<function udpstats>>=
int
udpstats(Proto *udp, char *buf, int len)
{
    Udppriv *upriv;

    upriv = udp->priv;
    return snprint(buf, len, "InDatagrams: %llud\nNoPorts: %lud\n"
        "InErrors: %lud\nOutDatagrams: %llud\n",
        upriv->ustats.udpInDatagrams,
        upriv->ustats.udpNoPorts,
        upriv->ustats.udpInErrors,
        upriv->ustats.udpOutDatagrams);
}
@

\subsection{[[/net/tcp/x/status]]}

<<function udpstate>>=
static int
udpstate(Conv *cv, char *state, int n)
{
    return snprint(state, n, "%s qin %d qout %d\n",
        cv->inuse ? "Open" : "Closed",
        cv->rq ? qlen(cv->rq) : 0,
        cv->wq ? qlen(cv->wq) : 0
    );
}
@

\section{Advanced features}

\subsection{Ignore advice}


<<[[Conv(kernel)]] udp fields>>=
bool ignoreadvice;   /* don't terminate connection on icmp errors */
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "ignoreadvice") == 0)
    cv->ignoreadvice = true;
@

\subsection{Not regular forme}

<<[[udpiput()]] new conv to create, adjust laddr if not Runi>>=
if(ipforme(f, laddr) != Runi) {
    switch(version){
    case V4:
        v4tov6(laddr, ifc->lifc->local);
        break;
    <<[[udpiput()]] new conv to create, ipv6 case>>
    default:
        panic("udpiput3: version %d", version);
    }
}
@

\subsection{User level UDP headers}
% need that? remove? for debugging?
% udpecho.c uses that

%\subsection{[[Udpcb]]}
% conversation priv

<<struct Udpcb>>=
struct Udpcb
{
    QLock;
    <<[[Idpcb]] other fields>>
};
@
%todo: need QLock really?


<<[[Idpcb]] other fields>>=
uchar   headers;
@

%<<[[Conv(kernel)]] other fields>>=
%/* udp specific */
%int headers;    /* data src/dst headers in udp */
%int reliable;   /* true if reliable udp */
%@
% dead, replaced by private field


<<function udpctl>>=
char*
udpctl(Conv *c, char **f, int n)
{
    Udpcb *ucb;

    ucb = (Udpcb*)c->ptcl;
    if(n == 1){
        if(strcmp(f[0], "headers") == 0){
            ucb->headers = 7;   /* new headers format */
            return nil;
        }
    }
    return "unknown control request";
}
@

<<constant UDP_USEAD7>>=
UDP_USEAD7  = 52,
@

<<[[udpkick()]] locals>>=
Udpcb *ucb;
uchar laddr[IPaddrlen];
uchar raddr[IPaddrlen];
ushort rport;
@

<<[[udpkick()]] special headers processing>>=
ucb = (Udpcb*)c->ptcl;
switch(ucb->headers) {
case 7:
    /* get user specified addresses */
    bp = pullupblock(bp, UDP_USEAD7);
    if(bp == nil)
        return;
    ipmove(raddr, bp->rp);
    bp->rp += IPaddrlen;
    ipmove(laddr, bp->rp);
    bp->rp += IPaddrlen;

    /* pick interface closest to dest */
    if(ipforme(f, laddr) != Runi)
        findlocalip(f, laddr, raddr);
    bp->rp += IPaddrlen;        /* Ignore ifc address */
    rport = nhgets(bp->rp);
    bp->rp += 2+2;          /* Ignore local port */
    break;
default:
    rport = 0;
    break;
}
@


<<[[udpkick()]] if special headers>>=
if(ucb->headers) {
    v6tov4(uh4->udpdst, raddr);
    hnputs(uh4->udpdport, rport);
    v6tov4(uh4->udpsrc, laddr);
    rc = nil;
} 
@


<<[[udpiput()]] if special headers>>=
switch(ucb->headers){
case 7:
    /* pass the src address */
    bp = padblock(bp, UDP_USEAD7);
    p = bp->rp;
    ipmove(p, raddr); p += IPaddrlen;
    ipmove(p, laddr); p += IPaddrlen;
    ipmove(p, ifc->lifc->local); p += IPaddrlen;
    hnputs(p, rport); p += 2;
    hnputs(p, lport);
    break;
}
@

\chapter{Reliable Communication, IL}

% For Internet Link

% see il.ps

%was in 9legacy since it has been deleted of recent plan9

\section{Protocol initialisation}

<<function ilinit>>=
void
ilinit(Fs *f)
{
    Proto *il;

    inittimescale();

    il = smalloc(sizeof(Proto));
    il->priv = smalloc(sizeof(Ilpriv));

    il->name = "il";
    il->create = ilcreate;
    il->close = ilclose;

    il->connect = ilconnect;
    il->announce = ilannounce;
    il->ctl = nil;

    il->rcv = iliput;

    il->state = ilstate;
    il->stats = ilxstats;

    il->inuse = ilinuse;
    il->advise = iladvise;

    il->gc = nil;
    il->ipproto = IP_ILPROTO;

    il->nc = scalednconv();
    il->ptclsize = sizeof(Ilcb);

    Fsproto(f, il);
}
@

<<constant IP_ILPROTO>>=
IP_ILPROTO	= 40,
@

% as opposed to UDP we will need to do some adjustments based on
% time feedback on how long a packet ack, congestion, etc.
<<function inittimescale>>=
/* calculate scale constants that converts fast ticks to ms (more or less) */
static void
inittimescale(void)
{
    uvlong hz;

    fastticks(&hz);
    if(hz > 1000){
        scalediv = hz/1000;
        scalemul = 1;
    } else {
        scalediv = 1;
        scalemul = 1000/hz;
    }
}
@

<<global scalexxx>>=
static	ulong	scalediv, scalemul;
@


<<function scalednconv>>=
ulong
scalednconv(void)
{
    if(cpuserver && conf.npage*BY2PG >= 128*MB)
        return Nchans*4;
    return Nchans;
}
@

\section{Protocol data structures}

\subsection{IL state}

% look nice, simple
<<enum _anon_ (kernel/network/ip/il.c)>>=
enum il_state				/* Connection state */
{
    Ilclosed,

    Ilsyncer,
    Ilsyncee,
    Ilestablished,
    Illistening,
    Ilclosing,

    Ilopening,		/* only for file server */
};
@
%note: il.ps does not have Illistening but 
%note: il.ps does not have Ilopening

<<global ilstates>>=
char	*ilstates[] = 
{ 
    "Closed",
    "Syncer",
    "Syncee",
    "Established",
    "Listen",
    "Closing",
    "Opening",		/* only for file server */
};
@

% ... -> Fsprotoclone -> <>
<<function ilinuse>>=
static int
ilinuse(Conv *c)
{
    Ilcb *ic;

    ic = (Ilcb*)(c->ptcl);
    return ic->state != Ilclosed;

}
@
% there is a state now, and even if the inuse is at zero, the
% conversation may still be in use and must be propery shutdown

\subsection{IL control packet type}

<<enum _anon_ (kernel/network/ip/il.c)2>>=
enum				/* Packet types */
{
    Ilsync,
    Ildata,
    Ildataquery,
    Ilack,
    Ilquery,
    Ilstate,
    Ilclose,
};
@

<<global iltype>>=
char	*iltype[] = 
{	
    "sync",
    "data",
    "dataquery",
    "ack",
    "query",
    "state",
    "close" 
};
@

\subsection{[[Ilcb]]}
% private to conv

% TODO: LP split!
<<struct Ilcb>>=
struct Ilcb			/* Control block */
{
    // enum<il_state>
    int	state;		/* Connection state */

    Conv	*conv;

    QLock	ackq;		/* Unacknowledged queue */
    Block	*unacked;
    Block	*unackedtail;
    ulong	unackedbytes;
    QLock	outo;		/* Out of order packet queue */
    Block	*outoforder;
    ulong	next;		/* Id of next to send */
    ulong	recvd;		/* Last packet received */
    ulong	acksent;	/* Last packet acked */
    ulong	start;		/* Local start id */
    ulong	rstart;		/* Remote start id */
    int	window;		/* Maximum receive window */
    int	rxquery;	/* number of queries on this connection */
    int	rxtot;		/* number of retransmits on this connection */
    int	rexmit;		/* number of retransmits of *unacked */
    ulong	qt[Nqt+1];	/* state table for query messages */
    int	qtx;		/* ... index into qt */

    /* if set, fasttimeout causes a connection request to terminate after 4*Iltickms */
    int	fasttimeout;

    /* timers */
    ulong	lastxmit;	/* time of last xmit */
    ulong	lastrecv;	/* time of last recv */
    ulong	timeout;	/* retransmission time for *unacked */
    ulong	acktime;	/* time to send next ack */
    ulong	querytime;	/* time to send next query */

    /* adaptive measurements */
    int	delay;		/* Average of the fixed rtt delay */
    int	rate;		/* Average uchar rate */
    int	mdev;		/* Mean deviation of rtt */
    int	maxrtt;		/* largest rtt seen */
    ulong	rttack;		/* The ack we are waiting for */
    int	rttlen;		/* Length of rttack packet */
    uvlong	rttstart;	/* Time we issued rttack packet */
};
@



\subsection{[[Ilpriv]]}
% private to protocol

<<struct Ilpriv>>=
struct Ilpriv
{
    Ipht	ht;

    ulong	dup;
    ulong	dupb;

    <<[[Ilpriv]] stat fields>>

    /* keeping track of the ack kproc */
    int	ackprocstarted;
    QLock	apl;
};
@

\subsection{Statistics}

<<[[Ilpriv]] stat fields>>=
ulong	csumerr;		/* checksum errors */
ulong	hlenerr;		/* header length error */
ulong	lenerr;			/* short packet */
ulong	order;			/* out of order */
ulong	rexmit;			/* retransmissions */
@

<<[[Ilpriv]] stat fields>>=
// map<enum<il_stat>, uvlong>
uvlong	stats[Nstats];
@

<<enum _anon_ (kernel/network/ip/il.c)6>>=
enum il_stat
{
    InMsgs,
    OutMsgs,
    CsumErrs,		/* checksum errors */
    HlenErrs,		/* header length error */
    LenErrs,		/* short packet */
    OutOfOrder,		/* out of order */
    Retrans,		/* retransmissions */
    DupMsg,
    DupBytes,
    DroppedMsgs,

    Nstats,
};
@

<<global statnames (kernel/network/ip/il.c)>>=
static char *statnames[] =
{
[InMsgs]	"InMsgs",
[OutMsgs]	"OutMsgs",
[CsumErrs]	"CsumErrs",
[HlenErrs]	"HlenErr",
[LenErrs]	"LenErrs",
[OutOfOrder]	"OutOfOrder",
[Retrans]	"Retrans",
[DupMsg]	"DupMsg",
[DupBytes]	"DupBytes",
[DroppedMsgs]	"DroppedMsgs",
};
@


\section{Protocol header}

<<struct Ilhdr>>=
struct Ilhdr
{
    /* ip header */
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */

    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* Ip source */
    uchar	dst[4];		/* Ip destination */

    /* IL header */
    uchar	ilsum[2];	/* Checksum including header */
    uchar	illen[2];	/* Packet length */
    uchar	iltype;		/* Packet type */
    uchar	ilspec;		/* Special */
    uchar	ilsrc[2];	/* Src port */
    uchar	ildst[2];	/* Dst port */
    uchar	ilid[4];	/* Sequence id */
    uchar	ilack[4];	/* Acked sequence */
};
@
% do not change the order!

<<constant IL_xxxSIZE>>=
IL_IPSIZE 	= 20,
IL_HDRSIZE	= 18,	
@

\section{[[/net/il/clone]]}

<<function ilcreate>>=
static void
ilcreate(Conv *c)
{
    c->rq = qopen(Maxrq, 0, 0, c);
    c->wq = qbypass(ilkick, c);
}
@

<<constant Maxrq(IL)>>=
Maxrq		= 64*1024,
@

% see also inuse() above, related to clone

\section{[[/net/il/x/ctl]]}

<<enum mode (kernel/network/ip/il.c)>>=
enum mode {
    IL_LISTEN	= 0,
    IL_CONNECT	= 1,
};
@

\subsection{Connect}

<<function ilconnect>>=
static char*
ilconnect(Conv *c, char **argv, int argc)
{
    char *err;
    char *p;
    bool fast = false;

    <<[[ilconnect()]] set fast>>

    err = Fsstdconnect(c, argv, argc);
    if(err != nil)
        return err;
    return ilstart(c, IL_CONNECT, fast);
}
@



\subsection{Announce}

<<function ilannounce>>=
/* called with c locked */
static char*
ilannounce(Conv *c, char **argv, int argc)
{
    char *err;

    err = Fsstdannounce(c, argv, argc);
    if(err != nil)
        return err;
    err = ilstart(c, IL_LISTEN, false);
    if(err != nil)
        return err;
    Fsconnected(c, nil);

    return nil;
}
@


\section{IO}

\subsection{Writing, [[ilkick()]]}

<<function ilkick>>=
void
ilkick(void *x, Block *bp)
{
    Conv *c = x;
    Ilhdr *ih;
    Ilcb *ic;
    int dlen;
    ulong id, ack;
    Fs *f;
    Ilpriv *priv;

    f = c->p->f;
    priv = c->p->priv;
    ic = (Ilcb*)c->ptcl;

    if(bp == nil)
        return;

    switch(ic->state) {
    case Ilclosed:
    case Illistening:
    case Ilclosing:
        freeblist(bp);
        qhangup(c->rq, nil);
        return;
    }

    dlen = blocklen(bp);

    /* Make space to fit il & ip */
    bp = padblock(bp, IL_IPSIZE+IL_HDRSIZE);
    ih = (Ilhdr *)(bp->rp);
    ih->vihl = IP_VER4;

    /* Ip fields */
    ih->frag[0] = 0;
    ih->frag[1] = 0;
    v6tov4(ih->dst, c->raddr);
    v6tov4(ih->src, c->laddr);
    ih->proto = IP_ILPROTO;

    /* Il fields */
    hnputs(ih->illen, dlen+IL_HDRSIZE);
    hnputs(ih->ilsrc, c->lport);
    hnputs(ih->ildst, c->rport);

    qlock(&ic->ackq);
    id = ic->next++;
    hnputl(ih->ilid, id);
    ack = ic->recvd;
    hnputl(ih->ilack, ack);
    ic->acksent = ack;
    ic->acktime = NOW + AckDelay;
    ih->iltype = Ildata;
    ih->ilspec = 0;
    ih->ilsum[0] = 0;
    ih->ilsum[1] = 0;

    /* Checksum of ilheader plus data (not ip & no pseudo header) */
    if(ilcksum)
        hnputs(ih->ilsum, ptclcsum(bp, IL_IPSIZE, dlen+IL_HDRSIZE));

    ilackq(ic, bp);

    qunlock(&ic->ackq);

    /* Start the round trip timer for this packet if the timer is free */
    if(ic->rttack == 0) {
        ic->rttack = id;
        ic->rttstart = fastticks(nil);
        ic->rttlen = dlen + IL_IPSIZE + IL_HDRSIZE;
    }

    if(later(NOW, ic->timeout, nil))
        ilsettimeout(ic);

    // Let's go, let's send the data
    ipoput4(f, bp, false, c->ttl, c->tos, c);

    priv->stats[OutMsgs]++;
}
@

\subsection{Reading, [[iliput()]]}

<<function iliput>>=
void
iliput(Proto *il, Ipifc*, Block *bp)
{
    char *st;
    Ilcb *ic;
    Ilhdr *ih;
    uchar raddr[IPaddrlen];
    uchar laddr[IPaddrlen];
    ushort sp, dp, csum;
    int plen, illen;
    Conv *new, *s;
    Ilpriv *ipriv;

    ipriv = il->priv;

    ih = (Ilhdr *)bp->rp;
    plen = blocklen(bp);
    if(plen < IL_IPSIZE+IL_HDRSIZE){
        //netlog(il->f, Logil, "il: hlenerr\n");
        ipriv->stats[HlenErrs]++;
        goto raise;
    }

    illen = nhgets(ih->illen);
    if(illen+IL_IPSIZE > plen){
        //netlog(il->f, Logil, "il: lenerr\n");
        ipriv->stats[LenErrs]++;
        goto raise;
    }

    sp = nhgets(ih->ildst);
    dp = nhgets(ih->ilsrc);
    v4tov6(raddr, ih->src);
    v4tov6(laddr, ih->dst);

    if((csum = ptclcsum(bp, IL_IPSIZE, illen)) != 0) {
        if(ih->iltype > Ilclose)
            st = "?";
        else
            st = iltype[ih->iltype];
        ipriv->stats[CsumErrs]++;
        //netlog(il->f, Logil, "il: cksum %ux %s, pkt(%ux id %ud ack %I/%d->%d)\n",
//			csum, st, nhgetl(ih->ilid), nhgetl(ih->ilack), raddr, sp, dp);
        goto raise;
    }

    qlock(il);
    s = iphtlook(&ipriv->ht, raddr, dp, laddr, sp);
    if(s == nil){
        if(ih->iltype == Ilsync)
            ilreject(il->f, ih);		/* no listener */
        qunlock(il);
        goto raise;
    }

    ic = (Ilcb*)s->ptcl;
    if(ic->state == Illistening){
        if(ih->iltype != Ilsync){
            qunlock(il);
            if(ih->iltype > Ilclose)
                st = "?";
            else
                st = iltype[ih->iltype];
            ilreject(il->f, ih);		/* no channel and not sync */
            //netlog(il->f, Logil, "il: no channel, pkt(%s id %ud ack %ud %I/%ud->%ud)\n",
//				st, nhgetl(ih->ilid), nhgetl(ih->ilack), raddr, sp, dp); 
            goto raise;
        }

        new = Fsnewcall(s, raddr, dp, laddr, sp, V4);
        if(new == nil){
            qunlock(il);
            //netlog(il->f, Logil, "il: bad newcall %I/%ud->%ud\n", raddr, sp, dp);
            ilsendctl(s, ih, Ilclose, 0, nhgetl(ih->ilid), 0);
            goto raise;
        }
        s = new;

        ic = (Ilcb*)s->ptcl;
    
        ic->conv = s;
        ic->state = Ilsyncee;
        ilcbinit(ic);
        ic->rstart = nhgetl(ih->ilid);
        iphtadd(&ipriv->ht, s);
    }

    qlock(s);
    qunlock(il);
    if(waserror()){
        qunlock(s);
        nexterror();
    }

    ilprocess(s, ih, bp);

    qunlock(s);
    poperror();
    return;
raise:
    freeblist(bp);
}
@


\section{State machine}

% two-way handshake

\subsection{[[ilsendctl()]]}

<<function ilsendctl>>=
void
ilsendctl(Conv *ipc, Ilhdr *inih, int type, ulong id, ulong ack, int ilspec)
{
    Ilhdr *ih;
    Ilcb *ic;
    Block *bp;
    int ttl, tos;

    bp = allocb(IL_IPSIZE+IL_HDRSIZE);
    bp->wp += IL_IPSIZE+IL_HDRSIZE;

    ih = (Ilhdr *)(bp->rp);
    ih->vihl = IP_VER4;

    /* Ip fields */
    ih->proto = IP_ILPROTO;
    hnputs(ih->illen, IL_HDRSIZE);
    ih->frag[0] = 0;
    ih->frag[1] = 0;
    if(inih) {
        hnputl(ih->dst, nhgetl(inih->src));
        hnputl(ih->src, nhgetl(inih->dst));
        hnputs(ih->ilsrc, nhgets(inih->ildst));
        hnputs(ih->ildst, nhgets(inih->ilsrc));
        hnputl(ih->ilid, nhgetl(inih->ilack));
        hnputl(ih->ilack, nhgetl(inih->ilid));
        ttl = MAXTTL;
        tos = DFLTTOS;
    }
    else {
        v6tov4(ih->dst, ipc->raddr);
        v6tov4(ih->src, ipc->laddr);
        hnputs(ih->ilsrc, ipc->lport);
        hnputs(ih->ildst, ipc->rport);
        hnputl(ih->ilid, id);
        hnputl(ih->ilack, ack);
        ic = (Ilcb*)ipc->ptcl;
        ic->acksent = ack;
        ic->acktime = NOW;
        ttl = ipc->ttl;
        tos = ipc->tos;
    }
    ih->iltype = type;
    ih->ilspec = ilspec;
    ih->ilsum[0] = 0;
    ih->ilsum[1] = 0;

    if(ilcksum)
        hnputs(ih->ilsum, ptclcsum(bp, IL_IPSIZE, IL_HDRSIZE));

if(ipc==nil)
    panic("ipc is nil caller is %#p", getcallerpc(&ipc));
if(ipc->p==nil)
    panic("ipc->p is nil");

    //netlog(ipc->p->f, Logilmsg, "ctl(%s id %d ack %d %d->%d)\n",
    //		iltype[ih->iltype], nhgetl(ih->ilid), nhgetl(ih->ilack), 
    //		nhgets(ih->ilsrc), nhgets(ih->ildst));

    ipoput4(ipc->p->f, bp, false, ttl, tos, ipc);
}
@
% ipc for conv ??


\subsection{[[ilprocess()]]}

<<function ilprocess>>=
/* DEBUG */
void
ilprocess(Conv *s, Ilhdr *h, Block *bp)
{
    Ilcb *ic;

    ic = (Ilcb*)s->ptcl;

    USED(ic);
    //netlog(s->p->f, Logilmsg, "%11s rcv %lud/%lud snt %lud/%lud pkt(%s id %d ack %ud %ud->%ud) ",
//		ilstates[ic->state],  ic->rstart, ic->recvd, ic->start, 
//		ic->next, iltype[h->iltype], nhgetl(h->ilid), 
//		nhgetl(h->ilack), nhgets(h->ilsrc), nhgets(h->ildst));

    _ilprocess(s, h, bp);

    //netlog(s->p->f, Logilmsg, "%11s rcv %lud snt %lud\n", ilstates[ic->state], ic->recvd, ic->next);
}
@


<<function _ilprocess>>=
void
_ilprocess(Conv *s, Ilhdr *h, Block *bp)
{
    Ilcb *ic;
    ulong id, ack;
    Ilpriv *priv;

    id = nhgetl(h->ilid);
    ack = nhgetl(h->ilack);

    ic = (Ilcb*)s->ptcl;

    ic->lastrecv = NOW;
    ic->querytime = NOW + QueryTime;
    priv = s->p->priv;
    priv->stats[InMsgs]++;

    switch(ic->state) {
    default:
        //netlog(s->p->f, Logil, "il: unknown state %d\n", ic->state);
    case Ilclosed:
        freeblist(bp);
        break;
    case Ilsyncer:
        switch(h->iltype) {
        default:
            break;
        case Ilsync:
            if(ack != ic->start)
                ilhangup(s, "connection rejected");
            else {
                ic->recvd = id;
                ic->rstart = id;
                ilsendctl(s, nil, Ilack, ic->next, ic->recvd, 0);
                ic->state = Ilestablished;
                ic->fasttimeout = 0;
                ic->rexmit = 0;
                Fsconnected(s, nil);
                ilpullup(s);
            }
            break;
        case Ilclose:
            if(ack == ic->start)
                ilhangup(s, "connection rejected");
            break;
        }
        freeblist(bp);
        break;
    case Ilsyncee:
        switch(h->iltype) {
        default:
            break;
        case Ilsync:
            if(id != ic->rstart || ack != 0){
                illocalclose(s);
            } else {
                ic->recvd = id;
                ilsendctl(s, nil, Ilsync, ic->start, ic->recvd, 0);
            }
            break;
        case Ilack:
            if(ack == ic->start) {
                ic->state = Ilestablished;
                ic->fasttimeout = 0;
                ic->rexmit = 0;
                ilpullup(s);
            }
            break;
        case Ildata:
            if(ack == ic->start) {
                ic->state = Ilestablished;
                ic->fasttimeout = 0;
                ic->rexmit = 0;
                goto established;
            }
            break;
        case Ilclose:
            if(ack == ic->start)
                ilhangup(s, "remote close");
            break;
        }
        freeblist(bp);
        break;
    case Ilestablished:
    established:
        switch(h->iltype) {
        case Ilsync:
            if(id != ic->rstart)
                ilhangup(s, "remote close");
            else
                ilsendctl(s, nil, Ilack, ic->next, ic->rstart, 0);
            freeblist(bp);	
            break;
        case Ildata:
            /*
             * avoid consuming all the mount rpc buffers in the
             * system.  if the input queue is too long, drop this
             * packet.
             */
            if (s->rq && qlen(s->rq) >= Maxrq) {
                priv->stats[DroppedMsgs]++;
                freeblist(bp);
                break;
            }

            ilackto(ic, ack, bp);
            iloutoforder(s, h, bp);
            ilpullup(s);
            break;
        case Ildataquery:
            ilackto(ic, ack, bp);
            iloutoforder(s, h, bp);
            ilpullup(s);
            ilsendctl(s, nil, Ilstate, ic->next, ic->recvd, h->ilspec);
            break;
        case Ilack:
            ilackto(ic, ack, bp);
            freeblist(bp);
            break;
        case Ilquery:
            ilackto(ic, ack, bp);
            ilsendctl(s, nil, Ilstate, ic->next, ic->recvd, h->ilspec);
            freeblist(bp);
            break;
        case Ilstate:
            if(ack >= ic->rttack)
                ic->rttack = 0;
            ilackto(ic, ack, bp);
            if(h->ilspec > Nqt)
                h->ilspec = 0;
            if(ic->qt[h->ilspec] > ack){
                ilrexmit(ic);
                ilsettimeout(ic);
            }
            freeblist(bp);
            break;
        case Ilclose:
            freeblist(bp);
            if(ack < ic->start || ack > ic->next) 
                break;
            ic->recvd = id;
            ilsendctl(s, nil, Ilclose, ic->next, ic->recvd, 0);
            ic->state = Ilclosing;
            ilsettimeout(ic);
            ilfreeq(ic);
            break;
        }
        break;
    case Illistening:
        freeblist(bp);
        break;
    case Ilclosing:
        switch(h->iltype) {
        case Ilclose:
            ic->recvd = id;
            ilsendctl(s, nil, Ilclose, ic->next, ic->recvd, 0);
            if(ack == ic->next)
                ilhangup(s, nil);
            break;
        default:
            break;
        }
        freeblist(bp);
        break;
    }
}
@


\subsection{Start}
% Closed

% (ilconnect | ilannounce) -> <>
<<function ilstart>>=
char*
ilstart(Conv *c, int type, bool fasttimeout)
{
    Ilcb *ic;
    Ilpriv *ipriv;
    char kpname[KNAMELEN];

    ipriv = c->p->priv;

    if(ipriv->ackprocstarted == 0){
        qlock(&ipriv->apl);
        if(ipriv->ackprocstarted == 0){
            sprint(kpname, "#I%dilack", c->p->f->dev);
            kproc(kpname, ilackproc, c->p);
            ipriv->ackprocstarted = 1;
        }
        qunlock(&ipriv->apl);
    }

    ic = (Ilcb*)c->ptcl;
    ic->conv = c;

    if(ic->state != Ilclosed)
        return nil;

    ilcbinit(ic);

    if(fasttimeout){
        /* timeout if we can't connect quickly */
        ic->fasttimeout = 1;
        ic->timeout = NOW+Iltickms;
        ic->rexmit = MaxRexmit - 4;
    };

    switch(type) {
    case IL_CONNECT:
        ic->state = Ilsyncer;
        iphtadd(&ipriv->ht, c);
        ilsendctl(c, nil, Ilsync, ic->start, ic->recvd, 0);
        break;
    case IL_LISTEN:
        ic->state = Illistening;
        iphtadd(&ipriv->ht, c);
        break;
    default:
        //netlog(c->p->f, Logil, "il: start: type %d\n", type);
        break;
    }

    return nil;
}
@



<<function ilcbinit>>=
void
ilcbinit(Ilcb *ic)
{
    ic->start = nrand(0x1000000);
    ic->next = ic->start+1;
    ic->recvd = 0;
    ic->window = Defaultwin;
    ic->unackedbytes = 0;
    ic->unacked = nil;
    ic->outoforder = nil;
    ic->rexmit = 0;
    ic->rxtot = 0;
    ic->rxquery = 0;
    ic->qtx = 1;
    ic->fasttimeout = 0;

    /* timers */
    ic->delay = DefRtt<<LogAGain;
    ic->mdev = DefRtt<<LogDGain;
    ic->rate = DefByteRate<<LogAGain;
    ic->querytime = NOW + QueryTime;
    ic->lastrecv = NOW;	/* or we'll timeout right away */
    ilsettimeout(ic);
}
@
% >> >> >>

\subsection{Close}
% Closing

% ipclose -> closeconv -> <>
<<function ilclose>>=
static void
ilclose(Conv *c)
{
    Ilcb *ic;

    ic = (Ilcb*)c->ptcl;

    qclose(c->rq);
    qclose(c->wq);
    qclose(c->eq);

    switch(ic->state) {
    case Ilclosing:
    case Ilclosed:
        break;
    case Ilsyncer:
    case Ilsyncee:
    case Ilestablished:
        ic->state = Ilclosing;
        ilsettimeout(ic);
        ilsendctl(c, nil, Ilclose, ic->next, ic->recvd, 0);
        break;
    case Illistening:
        illocalclose(c);
        break;
    }
    ilfreeq(ic);
}
@

<<function illocalclose>>=
void
illocalclose(Conv *c)
{
    Ilcb *ic;
    Ilpriv *ipriv;

    ipriv = c->p->priv;
    ic = (Ilcb*)c->ptcl;
    ic->state = Ilclosed;
    iphtrem(&ipriv->ht, c);
    ipmove(c->laddr, IPnoaddr);
    c->lport = 0;
}
@

\subsection{Syncer}

\subsection{Syncee}

\subsection{Establised}

\section{Features}

%\subsection{Delimiters preservation} ??
% apparently TCP does not have this

\subsection{Reliable datagram service}
% via chcksum?

<<global ilcksum>>=
bool 	ilcksum = true;
@
% note that the ip checksum is on its header, here its on its
% data.

\subsection{In sequence delivery}

\subsection{Retransmission of lost messages}

\subsection{Out-of-order messages saving}

\subsection{Adaptive timeouts}

\subsection{Keep-alive}
% to counter denial of service?

\section{Other files}

\subsection{[[/net/il/stats]]}

<<function ilxstats>>=
int
ilxstats(Proto *il, char *buf, int len)
{
    Ilpriv *priv;
    char *p, *e;
    int i;

    priv = il->priv;
    p = buf;
    e = p+len;
    for(i = 0; i < Nstats; i++)
        p = seprint(p, e, "%s: %llud\n", statnames[i], priv->stats[i]);
    return p - buf;
}
@

\subsection{[[/net/il/x/status]]}

<<function ilstate>>=
static int
ilstate(Conv *c, char *state, int n)
{
    Ilcb *ic;

    ic = (Ilcb*)(c->ptcl);
    return snprint(state, n, "%s qin %d qout %d del %5.5d Br %5.5d md %5.5d una %5.5lud rex %5.5d rxq %5.5d max %5.5d\n",
        ilstates[ic->state],
        c->rq ? qlen(c->rq) : 0,
        c->wq ? qlen(c->wq) : 0,
        ic->delay>>LogAGain, ic->rate>>LogAGain, ic->mdev>>LogDGain,
        ic->unackedbytes, ic->rxtot, ic->rxquery, ic->maxrtt);
}
@

\section{Advanced features}

\subsection{Fast timeout}

<<[[ilconnect()]] set fast>>=
/* huge hack to quickly try an il connection */
if(argc > 1){
    p = strstr(argv[1], "!fasttimeout");
    if(p != nil){
        *p = '\0';
        fast = true;
    }
}
@

\subsection{Special extension}
% ilspec field


\chapter{Standard Reliable Communication, TCP}

% RFC 793, Transmission Control Protocol

<<function tcpinit>>=
void
tcpinit(Fs *fs)
{
    Proto *tcp;
    Tcppriv *tpriv;

    tcp = smalloc(sizeof(Proto));
    tpriv = tcp->priv = smalloc(sizeof(Tcppriv));

    tcp->name = "tcp";
    tcp->connect = tcpconnect;
    tcp->announce = tcpannounce;
    tcp->ctl = tcpctl;
    tcp->state = tcpstate;
    tcp->create = tcpcreate;
    tcp->close = tcpclose;
    tcp->rcv = tcpiput;
    tcp->advise = tcpadvise;
    tcp->stats = tcpstats;
    tcp->inuse = tcpinuse;
    tcp->gc = tcpgc;

    tcp->ipproto = IP_TCPPROTO;
    tcp->nc = scalednconv();
    tcp->ptclsize = sizeof(Tcpctl);
    tpriv->stats[MaxConn] = tcp->nc;

    Fsproto(fs, tcp);
}
@

\chapter{Applications}

\section{Remote shell, Telnet}
% works on top of TCP?

\section{Remote file access, TFTP}

\chapter{Remote Procedure Call, 9P}

\chapter{Network File System, exportfs}
% the logical conclusion for all of that.


% con and exportfs
% NFS like?

\chapter{Name Resolution, DNS}

\chapter{Security}

\section{Denial of service}
% hogport? in tcp? tcpporthogdefense

\chapter{Debugging Support}
% the stats? to see the packet loss?

% snoopy? 

\chapter{Profiling Support}
% the stats? to see the packet loss?

\chapter{Advanced Topics}

\section{IPv6}

% See Network_v6.nw

\section{Broadcast}

% convention is that address has all 1s


<<[[ipoput4()]] adjust gate and ifc if broadcast or multicast case>>=
if(r->type & (Rbcast|Rmulti)) {
    gate = eh->dst;
    sr = v4lookup(f, eh->src, nil);
    if(sr != nil && (sr->type & Runi))
        ifc = sr->ifc;
}
@

<<[[ipifcadd()]] locals>>=
uchar bcast[IPaddrlen];
@

<<[[ipifcadd()]] add broadcast addresses to self cache>>=
/* add subnet directed broadcast address to the self cache */
for(i = 0; i < IPaddrlen; i++)
    bcast[i] = (ip[i] & mask[i]) | ~mask[i];
addselfcache(f, ifc, lifc, bcast, Rbcast);

/* add subnet directed network address to the self cache */
for(i = 0; i < IPaddrlen; i++)
    bcast[i] = (ip[i] & mask[i]) & mask[i];
addselfcache(f, ifc, lifc, bcast, Rbcast);

/* add network directed broadcast address to the self cache */
memmove(mask, defmask(ip), IPaddrlen);
for(i = 0; i < IPaddrlen; i++)
    bcast[i] = (ip[i] & mask[i]) | ~mask[i];
addselfcache(f, ifc, lifc, bcast, Rbcast);

/* add network directed network address to the self cache */
memmove(mask, defmask(ip), IPaddrlen);
for(i = 0; i < IPaddrlen; i++)
    bcast[i] = (ip[i] & mask[i]) & mask[i];
addselfcache(f, ifc, lifc, bcast, Rbcast);

addselfcache(f, ifc, lifc, IPv4bcast, Rbcast);
@

\section{Multicast}

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "addmulti") == 0){
    if(cb->nf < 2)
        error("addmulti needs interface address");
    if(cb->nf == 2){
        if(!ipismulticast(cv->raddr))
            error("addmulti for a non multicast address");
        if (parseip(ia, cb->f[1]) == -1)
            error(Ebadip);
        ipifcaddmulti(cv, cv->raddr, ia);
    } else {
        if (parseip(ia, cb->f[1]) == -1 ||
            parseip(ma, cb->f[2]) == -1)
            error(Ebadip);
        if(!ipismulticast(ma))
            error("addmulti for a non multicast address");
        ipifcaddmulti(cv, ma, ia);
    }
} 
@
<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "remmulti") == 0){
    if(cb->nf < 2)
        error("remmulti needs interface address");
    if(!ipismulticast(cv->raddr))
        error("remmulti for a non multicast address");
    if (parseip(ia, cb->f[1]) == -1)
        error(Ebadip);
    ipifcremmulti(cv, cv->raddr, ia);
}
@

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "joinmulti") == 0)
    return ipifcjoinmulti(ifc, argv, argc);
@
<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "leavemulti") == 0)
    return ipifcleavemulti(ifc, argv, argc);
@


<<[[Medium(kernel)]] multicast methods>>=
/* for arming interfaces to receive multicast */
void  (*addmulti)(Ipifc *ifc, uchar *a, uchar *ia);
void  (*remmulti)(Ipifc *ifc, uchar *a, uchar *ia);

/* for routing multicast groups */
void  (*joinmulti)(Ipifc *ifc, uchar *a, uchar *ia);
void  (*leavemulti)(Ipifc *ifc, uchar *a, uchar *ia);
@

<<[[Conv(kernel)]] multicast fields>>=
Ipmulti *multi;     /* multicast bindings for this interface */
@

<<[[closeconv()]] if multi, call ipifcremmulti>>=
while((mp = cv->multi) != nil)
    ipifcremmulti(cv, mp->ma, mp->ia);
@

<<[[Netif(kernel)]] multicast fields>>=
Netaddr *maddr;     /* known multicast addresses */
int nmaddr;     /* number of known multicast addresses */
Netaddr *mhash[Nmhash];   /* hash table of multicast addresses */
@

<<[[Netif(kernel)]] multicast methods>>=
void  (*multicast)(void*, uchar*, int);
@


<<[[ipifcadd()]] add multicast addresses to self cache>>=
if(ipcmp(ip, v6loopback) == 0) {
    /* add node-local mcast address */
    addselfcache(f, ifc, lifc, v6allnodesN, Rmulti);

    /* add route for all node multicast */
    v6addroute(f, tifc, v6allnodesN, v6allnodesNmask,
        v6allnodesN, Rmulti);
}

/* add all nodes multicast address */
addselfcache(f, ifc, lifc, v6allnodesL, Rmulti);

/* add route for all nodes multicast */
v6addroute(f, tifc, v6allnodesL, v6allnodesLmask, v6allnodesL,
    Rmulti);

/* add solicited-node multicast address */
ipv62smcast(bcast, ip);
addselfcache(f, ifc, lifc, bcast, Rmulti);

sendnbrdisc = true;
@

<<[[ipifcadd()]] locals>>=
bool sendnbrdisc = false;
@

<<[[ipifcadd()]] if tentative and broacast>>=
if(tentative && sendnbrdisc)
    icmpns(f, 0, SRC_UNSPEC, ip, TARG_MULTI, ifc->mac);
@

\section{Network database, [[ndb]]}
%less: or mv in advanced features of Name resolution chapter?

<<[[Fs(kernel)]] ndb fields>>=
char  ndb[1024];    /* an ndb entry for this interface */
int ndbvers;
long  ndbmtime;
@

\subsection{[[/net/ndb]]}

<<[[Qid]] toplevel extra cases>>=
Qndb,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qndb:
    p = "ndb";
    len = strlen(f->ndb);
    q.vers = f->ndbvers;
    break;
@
<<[[ipgen()]] if Qndb, adjust mtime>>=
if(i == Qndb && f->ndbmtime > kerndate)
    dp->mtime = f->ndbmtime;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qndb:
    if(omode & (OWRITE|OTRUNC) && !iseve())
        error(Eperm);
    if((omode & (OWRITE|OTRUNC)) == (OWRITE|OTRUNC))
        f->ndb[0] = 0;
    break;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qndb:
    return readstr(offset, a, n, f->ndb);
@

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qndb:
    return ndbwrite(f, a, offset, n);
    break;
@


\section{Connection Server}
% abstract away different address schemes

\section{Sniffing}

% promiscuous mode for ethernet, get all packets even those
% which don't have your MAC as a recipient

\section{Point to point interface}

<<[[ipifcadd()]] check for point to point interface>>=
/* check for point-to-point interface */
if(ipcmp(ip, v6loopback)) /* skip v6 loopback, it's a special address */
if(ipcmp(mask, IPallbits) == 0)
    type |= Rptpt;
@

<<[[ipifcadd()]] register proxy if point to point interface or proxy>>=
if((type & (Rproxy|Rptpt)) == (Rproxy|Rptpt)){
    ipifcregisterproxy(f, ifc, rem);
    goto out;
}
@

\section{Proxy}

<<[[ipifcadd()]] switch argc, proxy case, and fall through>>=
// add <ip> <mask> <rem> <mtu> proxy
case 6:
    if(strcmp(argv[5], "proxy") == 0)
        type |= Rproxy;
    /* fall through */
@



%\section{Packet filter}
% /net/ipmux

%\section{Bootp}

%\subsection{[[/net/bootp]]}
%% dead?
%
%<<[[Qid]] toplevel extra cases>>=
%Qbootp,
%@
%<<[[ip1gen()]] switch TYPE qid cases>>=
%case Qbootp:
%    p = "bootp";
%    break;
%@
%<<[[ipread()]] switch TYPE qid cases>>=
%case Qbootp:
%    return bootpread(a, offset, n);
%@
%
%<<function bootpread>>=
%int
%bootpread(char*, ulong, int)
%{
%    return  0;
%}
%@
%%I removed entirely inferno.c


\chapter{Conclusion}











\appendix

\chapter{Debugging}

\section{Dumpers}

\subsection{Addresses}
% or masks

<<function eipfmt>>=
int
eipfmt(Fmt *f)
{
    char buf[5*8];
    static char *efmt = "%.2ux%.2ux%.2ux%.2ux%.2ux%.2ux"; // ethernet
    static char *ifmt = "%d.%d.%d.%d"; // internet, v4
    uchar *p;
    uchar ip[16];
    ulong *lp;
    ushort s;
    int i, j, n, eln, eli;

    switch(f->r) {
    case 'E':		/* Ethernet address */
        p = va_arg(f->args, uchar*);
        snprint(buf, sizeof buf, efmt, p[0], p[1], p[2], p[3], p[4], p[5]);
        return fmtstrcpy(f, buf);

    case 'I':		/* Ip address */
        p = va_arg(f->args, uchar*);
common:
        if(memcmp(p, v4prefix, 12) == 0){
            snprint(buf, sizeof buf, ifmt, p[12], p[13], p[14], p[15]);
            return fmtstrcpy(f, buf);
        }

        /* find longest elision */
        eln = eli = -1;
        for(i = 0; i < 16; i += 2){
            for(j = i; j < 16; j += 2)
                if(p[j] != 0 || p[j+1] != 0)
                    break;
            if(j > i && j - i > eln){
                eli = i;
                eln = j - i;
            }
        }

        /* print with possible elision */
        n = 0;
        for(i = 0; i < 16; i += 2){
            if(i == eli){
                n += sprint(buf+n, "::");
                i += eln;
                if(i >= 16)
                    break;
            } else if(i != 0)
                n += sprint(buf+n, ":");
            s = (p[i]<<8) + p[i+1];
            n += sprint(buf+n, "%ux", s);
        }
        return fmtstrcpy(f, buf);

    case 'i':		/* v6 address as 4 longs */
        lp = va_arg(f->args, ulong*);
        for(i = 0; i < 4; i++)
            hnputl(ip+4*i, *lp++);
        p = ip;
        goto common;

    case 'V':		/* v4 ip address */
        p = va_arg(f->args, uchar*);
        snprint(buf, sizeof buf, ifmt, p[0], p[1], p[2], p[3]);
        return fmtstrcpy(f, buf);

    case 'M':		/* ip mask */
        p = va_arg(f->args, uchar*);

        /* look for a prefix mask */
        for(i = 0; i < 16; i++)
            if(p[i] != 0xff)
                break;
        if(i < 16){
            if((prefixvals[p[i]] & Isprefix) == 0)
                goto common;
            for(j = i+1; j < 16; j++)
                if(p[j] != 0)
                    goto common;
            n = 8*i + (prefixvals[p[i]] & ~Isprefix);
        } else
            n = 8*16;

        /* got one, use /xx format */
        snprint(buf, sizeof buf, "/%d", n);
        return fmtstrcpy(f, buf);
    }
    return fmtstrcpy(f, "(eipfmt)");
}
@

\subsection{IP interface}

<<function main>>=
void
main(void)
{
    Ipifc *ifc, *list;
    Iplifc *lifc;
    int i;

    fmtinstall('I', eipfmt);
    fmtinstall('M', eipfmt);

    list = readipifc("/net", nil, -1);
    for(ifc = list; ifc; ifc = ifc->next){
        print("ipifc %s %d\n", ifc->dev, ifc->mtu);
        for(lifc = ifc->lifc; lifc; lifc = lifc->next)
            print("\t%I %M %I\n", lifc->ip, lifc->mask, lifc->net);
    }
}
@

\section{[[/net/log]]}

\subsection{[[Netlog]]}

<<struct Netlog>>=
/*
 *  action log
 */
struct Netlog {
    int opens;

    // array<char> of size Nlog
    char*   buf;
    int len;

    char    *rptr;
    char    *end;


    int logmask;            /* mask of things to debug */
    uchar   iponly[IPaddrlen];      /* ip address to print debugging for */
    int iponlyset;

    // Extra
    Lock;
    QLock;
    Rendez;
};
@

<<enum _anon_ (kernel/network/ip/netlog.c)>>=
enum {
    Nlog        = 16*1024,
};
@


<<[[Fs(kernel)]] logging fields>>=
Netlog  *alog;
@

% ipattach -> ... -> <>
<<function netloginit>>=
void
netloginit(Fs *f)
{
    f->alog = smalloc(sizeof(Netlog));
}
@

\subsection{[[/net/log]]}

<<[[Qid]] toplevel extra cases>>=
Qlog,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qlog:
    p = "log";
    break;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qlog:
    netlogopen(f);
    break;
@
<<[[ipclose()]] switch TYPE qid cases>>=
case Qlog:
    if(c->flag & COPEN)
        netlogclose(f);
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qlog:
    return netlogread(f, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qlog:
    netlogctl(f, a, n);
    return n;
@

\subsection{Opening}

<<function netlogopen>>=
void
netlogopen(Fs *f)
{
    lock(f->alog);
    if(waserror()){
        unlock(f->alog);
        nexterror();
    }
    if(f->alog->opens == 0){
        if(f->alog->buf == nil)
            f->alog->buf = malloc(Nlog);
        if(f->alog->buf == nil)
            error(Enomem);
        f->alog->rptr = f->alog->buf;
        f->alog->end = f->alog->buf + Nlog;
    }
    f->alog->opens++;
    unlock(f->alog);
    poperror();
}
@

\subsection{Reading}

<<function netlogread>>=
long
netlogread(Fs *f, void *a, ulong, long n)
{
    int i, d;
    char *p, *rptr;

    qlock(f->alog);
    if(waserror()){
        qunlock(f->alog);
        nexterror();
    }

    for(;;){
        lock(f->alog);
        if(f->alog->len){
            if(n > f->alog->len)
                n = f->alog->len;
            d = 0;
            rptr = f->alog->rptr;
            f->alog->rptr += n;
            if(f->alog->rptr >= f->alog->end){
                d = f->alog->rptr - f->alog->end;
                f->alog->rptr = f->alog->buf + d;
            }
            f->alog->len -= n;
            unlock(f->alog);

            i = n-d;
            p = a;
            memmove(p, rptr, i);
            memmove(p+i, f->alog->buf, d);
            break;
        }
        else
            unlock(f->alog);

        sleep(f->alog, netlogready, f);
    }

    qunlock(f->alog);
    poperror();

    return n;
}
@

<<function netlogready>>=
static bool
netlogready(void *a)
{
    Fs *f = a;

    return f->alog->len;
}
@


\subsection{Control}

<<enum _anon_ (kernel/network/ip/netlog.c)2>>=
enum
{
    CMset,
    CMclear,
    CMonly,
};
@

<<global routecmd>>=
static
Cmdtab routecmd[] = {
    CMset,      "set",      0,
    CMclear,    "clear",    0,
    CMonly,     "only",     0,
};
@



<<function netlogctl>>=
void
netlogctl(Fs *f, char* s, int n)
{
    int i, set;
    Netlogflag *fp;
    Cmdbuf *cb;
    Cmdtab *ct;

    cb = parsecmd(s, n);
    if(waserror()){
        free(cb);
        nexterror();
    }

    if(cb->nf < 2)
        error(Ebadnetctl);

    ct = lookupcmd(cb, routecmd, nelem(routecmd));

    SET(set);

    switch(ct->index){
    case CMset:
        set = 1;
        break;

    case CMclear:
        set = 0;
        break;

    case CMonly:
        parseip(f->alog->iponly, cb->f[1]);
        if(ipcmp(f->alog->iponly, IPnoaddr) == 0)
            f->alog->iponlyset = 0;
        else
            f->alog->iponlyset = 1;
        free(cb);
        poperror();
        return;

    default:
        cmderror(cb, "unknown netlog control message");
    }

    for(i = 1; i < cb->nf; i++){
        for(fp = flags; fp->name; fp++)
            if(strcmp(fp->name, cb->f[i]) == 0)
                break;
        if(fp->name == nil)
            continue;
        if(set)
            f->alog->logmask |= fp->mask;
        else
            f->alog->logmask &= ~fp->mask;
    }

    free(cb);
    poperror();
}
@

\section{[[/bin/snoopy]]}
% useful only to debug network stack? or could be considered
% a Debugging Support chapter?

\subsection{[[/net/ipifc/x/snoop]]}

<<[[Qid]] conversation extra cases, last entry>>=
Qsnoop,
@
% has to be the last, because will do -1 below

<<[[Conv(kernel)]] snoop fields>>=
Ref snoopers;   /* number of processes with snoop open */
Queue*  sq;     /* snooping queue */
@
% those fields are valid only for /net/ipifc/x/snoop, a bit a waste.
%todo: who initialize sq?



<<[[ip3gen()]] switch TYPE qid cases>>=
case Qsnoop:
    if(strcmp(cv->p->name, "ipifc") != 0)
        return -1;
    devdir(c, q, "snoop", qlen(cv->sq), cv->owner, 0400, dp);
    return 1;
@
% only for ipifc protocol
% size = stop queue?

<<[[ipopen()]] switch TYPE qid cases>>=
case Qsnoop:
    if(omode != OREAD)
        error(Eperm);
    p = f->p[PROTO(c->qid)];
    cv = p->conv[CONV(c->qid)];
    if(strcmp(ATTACHER(c), cv->owner) != 0 && !iseve())
        error(Eperm);
    incref(&cv->snoopers);
    break;
@
<<[[ipclose()]] switch TYPE qid cases>>=
case Qsnoop:
    if(c->flag & COPEN)
        decref(&f->p[PROTO(c->qid)]->conv[CONV(c->qid)]->snoopers);
    break;
@


<<[[ipread()]] switch TYPE qid cases>>=
case Qsnoop:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->sq, a, n);
@






\subsection{[[/bin/snoopy]]}


<<function printusage>>=
void
printusage(void)
{
    fprint(2, "usage: %s [-CDdpst] [-N n] [-f filter] [-h first-header] path\n", argv0);
    fprint(2, "  for protocol help: %s -? [proto]\n", argv0);
}
@

<<function usage (networking/ip/snoopy/main.c)>>=
void
usage(void)
{
    printusage();
    exits("usage");
}
@



\chapter{Profiling}


\section{[[/net/x/stats]]}

% /net/x/stats? hmm it's more for user than for programmer of the
% network stack itself, but yes it can be useful too.

% /net/ipifc/stats
% /net/icmp/stats
% /net/tcp/stats


\chapter{Error Managment}

% have seen already all those err, most protocol methods return
% a char* which is an error string or nil.

\chapter{Ethernet Intel Pro/1000 Driver}
% like I did in Graphics.nw and the VGA driver

\chapter{Libc}

\section{Globbing}

% a few things have a format accepting "*"


\chapter{Extra Mediums}

\section{Null medium}

<<global nullmedium>>=
Medium nullmedium =
{
    .name=      "null",

    .bind=      nullbind,
    .unbind=    nullunbind,

    .bwrite=    nullbwrite,
};
@
% no pktin?

<<function nullbind>>=
static void
nullbind(Ipifc*, int, char**)
{
    error("cannot bind null device");
}
@

<<function nullunbind>>=
static void
nullunbind(Ipifc*)
{
}
@

<<function nullbwrite>>=
static void
nullbwrite(Ipifc*, Block*, int, uchar*)
{
    error("nullbwrite");
}
@

% in qemu.c
<<function nullmediumlink>>=
void
nullmediumlink(void)
{
    addipmedium(&nullmedium);
}
@

\section{Loopback medium}
% mv in advanced topics? more important than the other?

% echo 'bind loopback' > /net/ipifc/x/ctl

% can be useful to create kinda of named pipes but using
% ip protocol stack? to help debug things?

<<global loopbackmedium>>=
Medium loopbackmedium =
{
    .name=      "loopback",

    .hsize=     0,
    .mintu=     0,
    .maxtu=     Maxtu,
    .maclen=    0,

    .bind=      loopbackbind,
    .unbind=    loopbackunbind,
    .bwrite=    loopbackbwrite,
};
@
% maclen 0 ? no need, it can reach only this machine.
% no header? again, no dest so no need any header.

<<enum _anon_ (kernel/network/ip/loopbackmedium.c)>>=
enum
{
    Maxtu=  16*1024,
};
@

<<function loopbackmediumlink>>=
void
loopbackmediumlink(void)
{
    addipmedium(&loopbackmedium);
}
@

% private Ipifc data, ifc->arg
<<struct LB>>=
struct LB
{
    Queue   *q;
    Fs  *f;
    Proc    *readp;
};
@

<<function loopbackbind>>=
static void
loopbackbind(Ipifc *ifc, int, char**)
{
    LB *lb;

    lb = smalloc(sizeof(LB));
    lb->f = ifc->conv->p->f;
    lb->q = qopen(1024*1024, Qmsg, nil, nil);
    ifc->arg = lb;
    ifc->mbps = 1000;

    kproc("loopbackread", loopbackread, ifc);

}
@


<<function loopbackunbind>>=
static void
loopbackunbind(Ipifc *ifc)
{
    LB *lb = ifc->arg;

    if(lb->readp)
        postnote(lb->readp, 1, "unbind", 0);

    /* wait for reader to die */
    while(lb->readp != nil)
        tsleep(&up->sleepr, returnfalse, 0, 300);

    /* clean up */
    qfree(lb->q);
    free(lb);
}
@

% a kproc
<<function loopbackread>>=
static void
loopbackread(void *a)
{
    Ipifc *ifc;
    Block *bp;
    LB *lb;

    ifc = a;
    lb = ifc->arg;
    lb->readp = up; /* hide identity under a rock for unbind */
    if(waserror()){
        lb->readp = 0;
        pexit("hangup", 1);
    }
    for(;;){
        bp = qbread(lb->q, Maxtu);
        if(bp == nil)
            continue;
        ifc->in++;
        if(!canrlock(ifc)){
            freeb(bp);
            continue;
        }
        if(waserror()){
            runlock(ifc);
            nexterror();
        }
        if(ifc->lifc == nil)
            freeb(bp);
        else
            ipiput4(lb->f, ifc, bp);
        runlock(ifc);
        poperror();
    }
}
@
% ipiput4!


<<function loopbackbwrite>>=
static void
loopbackbwrite(Ipifc *ifc, Block *bp, int, uchar*)
{
    LB *lb;

    lb = ifc->arg;
    if(qpass(lb->q, bp) < 0)
        ifc->outerr++;
    ifc->out++;
}
@


\section{Point to point serial line}
% PPP?

\section{Token ring}
% alternative to ethernet


\chapter{Extra Protocols}

\section{ICMP}
% for ping

% put before? in Advanced topics? more important than other protocols?
% A Meta protocol?

<<[[Proto(kernel)]] conversation methods>>=
void    (*advise)(Proto*, Block*, char*);
@

\section{RUDP}

\section{GRE}

\section{ESP}

\section{Datakit and URP}


\chapter{Extra Applications}

\section{Remote login, rlogin}

\section{Serving files, FTP}
% works on top of tcp again?

\section{Serving documents, HTTP}

\section{Serving mails, SMTP}
% this one has actually many subprotocols ... hmmm

\section{Serving news, NNTP}

\chapter{Extra Code}

\ifallcode

#include "Network_extra.nw"
#include "Network_v6.nw"

\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
