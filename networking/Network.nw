\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand networking:
% - TODO ether, ip, ppp, udp, tcp, actually I didn't know 
%   that much about network
% - TODO does not need much to configure initially; can do things manually
%   without ipconfig and actually you need to do very few things

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - SEMI  understand main(), LP split main, improve TOC
% - SEMI  understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for ?

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Plan9 Networking [[/net/]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Dave Presotto and Phil Winterbottom\\
% more?
}


\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a network stack.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item XINU
\item Linux
\item FreeBSD
% have strong reputation
\end{itemize}

%TODO: use IL instead? code dispo in 9legacy?

%http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/

\section{Getting started}


\section{Requirements}

%Intro to computer networks (free, but maybe not that good)
%http://intronetworks.cs.luc.edu/

% "The organization of networks in plan9".ps
% il.ps

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Network principles}

% local (mac) address, ethernet, ARP discovery, local area network

% packets! and actually whole idea of network abstraction is to
% provide what seems like an arbitrary length or even continuous stream
% of data on top of this fixed packet. A bit similar to file and fs
% which are on top of disk blocks.


\section{Internetworking principles}

% ip, inter network, routing, gateway
% (packets become really useful there because big sharing)

\section{[[/net]] services}

% see 'network plan9'.ps

% /net/ether0/addr
% /net/ipfc/clone
% /net/arp
% /net/iproute

% maybe can put early the 
%    echo 'bind ether /net/ether0' > /net/ipifc/x/ctl
% and then 
%    echo 'add 10.0.0.15' > /net/ipifc/x/ctl

%todo: then how initiate connextion manually? using just the shell?

% /net/<proto>/<conv>/ for the most part.

\section{[[ping]], [[traceroute]], etc}

\section{Code organization}

% include/ip.h
% lib_networking/libip/
% kernel/network/, devip, devether, udp.c, tpc.c, and etherigbe.c
% networking/...

\section{Software architecture}

% physical (e.g. ethernet), kernel (devip+ether), lib(dial), apps (e.g. telnetd)
% and on the other side
% physical (e.g. ethernet), kernel (devip+ether), lib(listen), apps (e.g. telnet)

% client/server but in the end really something reading from a file
% and something writing to the file. In essence network comm is
% like reading/writing to a file, except the file represent a connection
% to somewhere else, not a local file.

% link-layer: ethernet, (arp, ip, ... aoe)
% network-layer: ip (routing)
% transport-layer: (udp, tcp, icmp, il, ... )
% "applications" protocol (dhcp, dns, telnetd, http, imap, ...)
% actual applications (telnet, ping, ...)

% encapsulation each time


% Proto vs Fs vs Ipifc vs Netif

\section{Trace of a ping}

%###############################################################################

\chapter{Core Data Structures}

\section{IP address}

% universal
% inter-network

%less: typedef uchar ippart ? typedef uchar* ip? 
% and actually apparently an array of 16 elt (to cover ipv4 and ipv6)

<<constant IPaddrlen>>=
IPaddrlen=	16,
@
% 16 bytes IP(v6) address


\subsection{IPv4 vs IPv6}

<<global v4prefix>>=
/*
 *  prefix of all v4 addresses
 */
uchar v4prefix[IPaddrlen] = {
    // first 12
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,

    // rest are ipv4 numbers
    0, 0, 0, 0
};
@

<<constant IPv4addrlen>>=
IPv4addrlen=	4,
@

<<constant IPv4off>>=
IPv4off=	12,
@

<<function isv4>>=
bool
isv4(uchar *ip)
{
    return memcmp(ip, v4prefix, IPv4off) == 0;
}
@
% first 12 must be identical to v4prefix

<<function v4tov6>>=
/*
 *  the following routines are unrolled with no memset's to speed
 *  up the usual case
 */
void
v4tov6(uchar *v6, uchar *v4)
{
    v6[0] = 0;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = 0;
    v6[4] = 0;
    v6[5] = 0;
    v6[6] = 0;
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    v6[10] = 0xff;
    v6[11] = 0xff;
    v6[12] = v4[0];
    v6[13] = v4[1];
    v6[14] = v4[2];
    v6[15] = v4[3];
}
@

\subsection{Class}

<<macro CLASS>>=
#define CLASS(p) ((*(uchar*)(p))>>6)
@
% ?? first 2 bits of first number in IP?

\subsection{Mask}

<<function defmask>>=
uchar*
defmask(uchar *ip)
{
    if(isv4(ip))
        return classmask[ip[IPv4off]>>6];
    <<[[defmask()]] if ipv6>>
}
@
%less: why not use CLASS? instead of >>6 above?

<<global classmask>>=
static uchar classmask[4][16] = {
    // class 0
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0x00,0x00,0x00, // 255.0.0.0
    // class 1
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0x00,0x00,0x00, // 255.0.0.0
    // class 2
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0xff,0x00,0x00, // 255.255.0.0
    // class 3
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0xff,0xff,0x00, // 255.255.255.0
};
@
% class use 2 bits, so 4 entries
% 255.255.etc
% use IPADDRLen instead of 16?


<<function maskip>>=
void
maskip(uchar *from, uchar *mask, uchar *to)
{
    int i;

    for(i = 0; i < IPaddrlen; i++)
        to[i] = from[i] & mask[i];
}
@

\section{IP Interface, [[Ipifc]]}

% /net/ipifc/...

% this will associate an IP (logical address) to a 
% physical device (physical address)


\subsection{User side}

% how used by programmer? readipifc()?
% hmm but not that useful in practice no? or because dial uses that?
% Need that to know who you are ... like hostname.

% /net/ipifc/x/stats?
% in ip.h
<<struct Ipifc (user)>>=
/* actual interface */
struct Ipifc
{
    /* per ip interface */
    int	index;			/* number of interface in ipifc dir */
    char	dev[64];
    int	mtu;
    // list<ref_own<Iplifc> (next = Iplifc.next)
    Iplifc	*lifc;

    <<[[Ipifc(user)]] stat fields>>
    <<[[Ipifc(user)]] ipv6 fields>>

    //Extra
    <<[[Ipifc(user)]] extra fields>>
};
@
% echo 'bind ether path' > /net/ipifc/x/ctl

%less: what is inside dev[64]?

<<[[Ipifc(user)]] stat fields>>=
ulong	pktin;
ulong	pktout;
ulong	errin;
ulong	errout;
@


<<[[Ipifc(user)]] extra fields>>=
Ipifc	*next;
@
% readipifc can return the list of all interfaces



<<struct Iplifc (user)>>=
/* local address */
struct Iplifc
{
    /* per address on the ip interface */
    uchar	ip[IPaddrlen];
    uchar	mask[IPaddrlen];
    uchar	net[IPaddrlen];		/* ip & mask */

    <<[[Iplifc(user)]] other fields>>

    // Extra
    <<[[Iplifc(user)]] extra fields>>
};
@
% finally an ip!
%less: local? or logical?
% echo 'add localip' > /net/ipicf/x/ctl

% can have multiple IP connected to same device? what for?

<<[[Iplifc(user)]] extra fields>>=
// list<ref_own<Iplifc>>, head = Ipifc.lifc
Iplifc	*next;
@

%XXX
<<[[Iplifc(user)]] other fields>>=
ulong	preflt;			/* preferred lifetime */
ulong	validlt;		/* valid lifetime */
@

\subsection{Kernel side}

% who points to that in the kernel? actually there is no single
% ipifc global in the kernel because a machine can have multiple ips
% (e.g. a bridge), and so the user access the one he wants via
% /net/ipifc/.
% OK but when go to /net/tcp/clone, get which interface??

<<struct Ipifc (kernel)>>=
struct Ipifc
{
  char  dev[64];  /* device we're attached to */

  int maxtu;    /* Maximum transfer unit */
  int mintu;    /* Minumum tranfer unit */
  int mbps;   /* megabits per second */

  Medium  *m;   /* Media pointer */
  void  *arg;   /* medium specific */
  uchar mac[MAClen];  /* MAC address */

  // list<ref_own<Iplifc>>, next = Iplifc.next
  Iplifc  *lifc;    /* logical interfaces on this physical one */

  <<[[Ipifc(kernel)]] stat fields>>
  <<[[Ipifc(kernel)]] ipv6 fields>>
  <<[[Ipifc(kernel)]] other fields>>

  //Extra
  RWlock;

};
@

<<[[Ipifc(kernel)]] stat fields>>=
ulong in, out;  /* message statistics */
ulong inerr, outerr;  /* ... */
@

<<[[Ipifc(kernel)]] other fields>>=
Conv  *conv;    /* link to its conversation structure */
@
% will see later



%XXX
<<[[Ipifc(kernel)]] other fields>>=
bool reassemble; /* reassemble IP packets before forwarding */

/* these are used so that we can unbind on the fly */
Lock  idlock;
uchar ifcid;    /* incremented each 'bind/unbind/add/remove' */
int ref;    /* number of proc's using this ipifc */
Rendez  wait;   /* where unbinder waits for ref == 0 */
int unbinding;
@

%XXX routing fields?
<<[[Ipifc(kernel)]] other fields>>=
Routerparams rp;  /* router parameters as in RFC 2461, pp.40â€”43.
        used only if node is router */
@


<<struct Iplifc (kernel)>>=
/* logical interface associated with a physical one */
struct Iplifc
{
  uchar local[IPaddrlen];
  uchar mask[IPaddrlen];
  uchar net[IPaddrlen];

  uchar remote[IPaddrlen];

  <<[[Iplifc(kernel)]] other fields>>

  // Extra
  <<[[Iplifc(kernel)]] extra fields>>
};
@
% local = ip?
% remote??

<<[[Iplifc(kernel)]] extra fields>>=
// list<ref_own<Iplifc>>, head = Ipifc.lifc
Iplifc  *next;
@

%XXX
<<[[Iplifc(kernel)]] extra fields>>=
Iplink  *link;    /* addresses linked to this lifc */
@

%XXX
<<[[Iplifc(kernel)]] other fields>>=
uchar tentative;  /* =1 => v6 dup disc on, =0 => confirmed unique */
uchar onlink;   /* =1 => onlink, =0 offlink. */
uchar autoflag; /* v6 autonomous flag */
long  validlt;  /* v6 valid lifetime */
long  preflt;   /* v6 preferred lifetime */
long  origint;  /* time when addr was added */
@

\section{Link [[Medium]], and [[media]]}

% ethernet, 
% see later: null, loopback, packet

% pointed by Ipifc

<<struct Medium (kernel)>>=
struct Medium
{
  char  *name;

  int hsize;    /* medium header size */
  int mintu;    /* default min mtu */
  int maxtu;    /* default max mtu */
  int maclen;   /* mac address length  */
 
  // the methods
  void  (*bind)(Ipifc*, int, char**);
  void  (*unbind)(Ipifc*);

  void  (*bwrite)(Ipifc *ifc, Block *b, int version, uchar *ip);

  <<[[Medium(kernel)]] multicast methods>>
  <<[[Medium(kernel)]] other methods>>
  <<[[Medium(kernel)]] other fields>>

};
@

% ipwrite (Ctl case) -> bindctlmsg -> ipifcbind <> 
%  (as m->find <- ipfindmedium <- media[i] <- ???)
% bind

<<global media>>=
Medium *media[Maxmedia] = { 0 };
@
<<constant Maxmedia>>=
Maxmedia    = 32,
@

% ?? -> <>  ? qemu.c links() and ethermediumlink?
<<function addipmedium>>=
/*
 *  link in a new medium
 */
void
addipmedium(Medium *med)
{
    int i;

    for(i = 0; i < nelem(media)-1; i++)
        if(media[i] == nil){
            media[i] = med;
            break;
        }
}
@





%XXX
<<[[Medium(kernel)]] other fields>>=
bool unbindonclose;  /* if non-zero, unbind on last close */
@


%XXX
<<[[Medium(kernel)]] other methods>>=
/* process packets written to 'data' */
void  (*pktin)(Fs *f, Ipifc *ifc, Block *bp);

/* routes for router boards */
void  (*addroute)(Ipifc *ifc, int, uchar*, uchar*, uchar*, int);
void  (*remroute)(Ipifc *ifc, int, uchar*, uchar*);
void  (*flushroutes)(Ipifc *ifc);

/* address resolution */
void  (*ares)(Fs*, int, uchar*, uchar*, int, int);  /* resolve */
void  (*areg)(Ipifc*, uchar*);      /* register */

/* v6 address generation */
void  (*pref2addr)(uchar *pref, uchar *ea);
@

%\subsection{Ethernet medium}

%\subsection{Null medium}


\section{[[/net]] filesystem}


\subsection{[[Fs]]}
% rename? Slashnetfs?
% file system. For /net/ essentially

<<struct Fs (kernel)>>=
/*
 *  one per IP protocol stack
 */
struct Fs
{
  // array<option<ref_own<Proto>>>, size is Fs.np
  Proto*  p[Maxproto+1];    /* list of supported protocols */
  int np;

  IP  *ip;

  <<[[Fs(kernel)]] arp fields>>
  <<[[Fs(kernel)]] routing fields>>
  <<[[Fs(kernel)]] ndb fields>>
  <<[[Fs(kernel)]] logging fields>>
  <<[[Fs(kernel)]] ipv6 fields>>
  <<[[Fs(kernel)]] other fields>>
 
  // Extra
  RWlock;
  <<[[Fs(kernel)]] extra fields>>
};
@
% >> >> >>


<<constant Maxproto>>=
Maxproto= 20,
@


%XXX
<<[[Fs(kernel)]] routing fields>>=
Route *v4root[1<<Lroot];  /* v4 routing forest */
Route *queue;     /* used as temp when reinjecting routes */
@
% >> >> 


%XXX
<<[[Fs(kernel)]] other fields>>=
Proto*  t2p[256];   /* vector of all protocols */

Proto*  ipmux;      /* kludge for finding an ip multiplexor */
@


\subsection{[[ipfs]]}

<<global ipfs>>=
Fs  *ipfs[Nfs]; /* attached fs's */
@

<<constant Nfs>>=
Nfs=        128,
@
% Nb filesystem (not network file system)
% in practice will have only one IP stack/fs, so Fs.dev will be 0

<<[[Fs(kernel)]] extra fields>>=
int dev; // idx in ipfs
@

<<global fslock>>=
QLock   fslock;
@

\subsection{[[IP]]}

%todo: rename, bad name
<<struct IP (kernel)>>=
/* an instance of IP */
struct IP
{
  Fragment4*  flisthead4;
  Fragment4*  fragfree4;

  <<[[IP(kernel)]] stat fields>>
  <<[[IP(kernel)]] routing fields>>

  <<[[IP(kernel)]] ipv6 fields>>

  // Extra
  QLock   fraglock4;
  Ref   id4;
};
@

<<struct Fragment4>>=
struct Fragment4
{
  Block*  blist;

  ulong   src;
  ulong   dst;
  ushort  id;
  ulong   age;

  // Extra
  Fragment4*  next;
};
@
% ulong for src and dst?

<<[[IP(kernel)]] routing fields>>=
bool iprouting;  /* true if we route like a gateway */
@

<<[[IP(kernel)]] stat fields>>=
uvlong    stats[Nipstats];
@


\section{[[Proto]]cols}

% /net/<proto>/

<<struct Proto (kernel)>>=
/*
 *  one per multiplexed protocol
 */
struct Proto
{
  char*   name;   /* protocol name */

  <<[[Proto(kernel)]] methods>>

  // growing_array<option<ref_own<Proto>>>, size = Proto.nc
  Conv    **conv;   /* array of conversations */
  int   nc;   /* number of conversations */
  int   ac; // number of opened conversations

  <<[[Proto(kernel)]] other fields>>

  void    *priv;

  // Extra
  QLock;
  <<[[Proto(kernel)]] extra fields>>
};
@

<<[[Proto(kernel)]] extra fields>>=
// ref<Fs>, reverse of Fs.p[this.x]
Fs    *f;   /* file system this proto is part of */
// index in Fs.p[]
int   x;    /* protocol index */
@
% x is useful when building qid

% Actually  /net/ipifc/ will be a protocol itself! with a clone
% and then with a conversation. Very general scheme.



%XXX
<<[[Proto(kernel)]] other fields>>=
int   ipproto;  /* ip protocol type */

ushort    nextrport;
@

<<[[Proto(kernel)]] other fields>>=
Qid   qid;    /* qid for protocol directory */
@
% why need that?


%XXX
<<[[Proto(kernel)]] methods>>=
// sysopen(/net/x/clone) -> ... -> ipopen -> Fsprotoclone -> <>
void    (*create)(Conv*);
// syswrite("bind ...", /net/x/y/ctl) -> ... -> ipwrite -> ... -> <>
char*   (*bind)(Conv*, char**, int);

char*   (*connect)(Conv*, char**, int);
char*   (*announce)(Conv*, char**, int);
int   (*state)(Conv*, char*, int);
void    (*close)(Conv*);
void    (*rcv)(Proto*, Ipifc*, Block*);
char*   (*ctl)(Conv*, char**, int);
void    (*advise)(Proto*, Block*, char*);
int   (*stats)(Proto*, char*, int);
int   (*local)(Conv*, char*, int);
int   (*remote)(Conv*, char*, int);
int   (*inuse)(Conv*);
int   (*gc)(Proto*);  /* returns true if any conversations are freed */
@

\section{[[Conv]]ersations}

% /net/<proto>/<conv>/

% very general. (ab)used also for ipifc

% conversation

<<struct Conv (kernel)>>=
/*
 *  one per conversation directory
 */
struct Conv
{

  uchar laddr[IPaddrlen]; /* local IP address */
  uchar raddr[IPaddrlen]; /* remote IP address */

  ushort  lport;      /* local port number */
  ushort  rport;      /* remote port number */

  uchar ipversion;

  char  *owner;     /* protections */
  int perm;

  <<[[Conv(kernel)]] queue fields>>
  <<[[Conv(kernel)]] routing fields>>
  <<[[Conv(kernel)]] multicast fields>>
  <<[[Conv(kernel)]] snoop fields>>
  <<[[Conv(kernel)]] other fields>>

  // Extra
  QLock;
  <<[[Conv(kernel)]] extra fields>>
};
@

<<[[Conv(kernel)]] extra fields>>=
// ref<Proto> reverse of Proto.conv[this.x]
Proto*  p;
// index in Proto.conv[]
int x;      /* conversation index */
@
% x is useful when building qid



<<[[Conv(kernel)]] queue fields>>=
Queue*  eq;     /* returned error packets */
@
% setup in Fsprotoclone generically

<<[[Conv(kernel)]] queue fields>>=
Queue*  rq;     /* queued data waiting to be read */
Queue*  wq;     /* queued data waiting to be written */
@
% setup in each create() method of each Proto


<<[[Proto(kernel)]] other fields>>=
int   ptclsize; /* size of per protocol ctl block */
@
<<[[Conv(kernel)]] other fields>>=
void* ptcl;     /* protocol specific stuff */
@
% e.g. Ipifc ! when have a conversation with /net/ipifc/x/ctl






<<[[Conv(kernel)]] other fields>>=
int inuse;      /* opens of listen/data/ctl */
@


%XXX
<<[[Conv(kernel)]] routing fields>>=
Route *r;     /* last route used */
ulong rgen;     /* routetable generation for *r */
@

%XXX
<<[[Conv(kernel)]] other fields>>=
int restricted;   /* remote port is restricted */
uint  ttl;      /* max time to live */
uint  tos;      /* type of service */
bool ignoreadvice;   /* don't terminate connection on icmp errors */

int length;
int state;

int maxfragsize;    /* If set, used for fragmentation */

/* udp specific */
int headers;    /* data src/dst headers in udp */
int reliable;   /* true if reliable udp */

Conv* incall;     /* calls waiting to be listened for */
Conv* next;

QLock car;
Rendez  cr;
char  cerr[ERRMAX];

QLock listenq;
Rendez  listenr;
@



\section{Chan Qid, [[PROTO()]], [[CONV()], [[QID()]]]}


<<enum qid (kernel/network/ip/devip.c)>>=
enum
{
    Qtopdir=    1,      /* top level directory */

    Qtopbase,
    Qarp=       Qtopbase,
    Qiproute,
    <<[[Qid]] toplevel extra cases>>

    Qprotodir,          /* directory for a protocol */
    Qprotobase,
    Qclone=     Qprotobase,
    <<[[Qid]] protocol extra cases>>

    Qconvdir,           /* directory for a conversation */
    Qconvbase,
    Qctl=       Qconvbase,
    Qdata,
    <<[[Qid]] conversation extra cases>>
};
@

%FIGURE: qid with different bits for different parts
% 5 bits for type, 12 bits for conversation, 8 bits for proto
% => 25 bits

%many of those qids will really behave like a socket.


<<enum misc (kernel/network/ip/devip.c)>>=
enum
{
    Logtype=    5,
    Masktype=   (1<<Logtype)-1,

    Logconv=    12,
    Maskconv=   (1<<Logconv)-1,
    Shiftconv=  Logtype,

    Logproto=   8,
    Maskproto=  (1<<Logproto)-1,
    Shiftproto= Logtype + Logconv,

    <<constant Nfs>>
};
@
% >> >> >> >>


% given a channel qid we can quickly identify its "property" that
% is where it comes from. For instance the channel qid of /net/tcp/0/...
% will be a certain integer and we can access to its protocol with
% PROTO() and its conversation with CONV(), and final "type" with TYPE

% ctor
<<macro QID>>=
#define QID(p, c, y)    ( ((p)<<(Shiftproto)) | ((c)<<Shiftconv) | (y) )
@
% >> >>

% with Chan.dev        => access Fs     (ipfs[c->dev])
% with PROTO(Chan.qid) => access Proto  (...) 
% with CONV(Chan.qid)  => Access Conv   (...)

% in ip3gen()
%    cv = ipfs[c->dev]->p[PROTO(c->qid)]->conv[CONV(c->qid)];


% getters
<<macro PROTO>>=
#define PROTO(x)    ( (((ulong)(x).path) >> Shiftproto) & Maskproto )
@
% /net/x (tcp, udp, etc)
<<macro CONV>>=
#define CONV(x)     ( (((ulong)(x).path) >> Shiftconv) & Maskconv )
@
% /net/.../x

<<macro TYPE>>=
#define TYPE(x)     ( ((ulong)(x).path) & Masktype )
@
% /net/.../.../x (ctl, data, etc)

% in ipattach()
%    mkqid(&c->qid, QID(0, 0, Qtopdir), 0, QTDIR);
% so means entries 0 are not used in Proto and Conv?



%XXX
<<[[Qid]] protocol extra cases>>=
Qstats,
@

<<[[Qid]] conversation extra cases>>=
Qerr,
Qlisten,
Qlocal,
Qremote,
Qstatus,
@



\section{XXX}

\section{[[/net/ether]] filesystem}

\subsection{[[Netfile]]}

<<struct Netfile>>=
/*
 *  one per multiplexed connection
 */
struct Netfile
{
  QLock;

  int inuse;
  ulong mode;
  char  owner[KNAMELEN];

  int type;     /* multiplexor type */
  int prom;     /* promiscuous mode */
  int scan;     /* base station scanning interval */
  int bridge;     /* bridge mode */
  int headersonly;    /* headers only - no data */
  uchar maddr[8];   /* bitmask of multicast addresses requested */
  int nmaddr;     /* number of multicast addresses */

  Queue *in;      /* input buffer */
};
@

\subsection{[[Netif]]}

<<struct Netif (kernel)>>=
/*
 *  a network interface
 */
struct Netif
{
  QLock;

  /* multiplexing */
  char  name[KNAMELEN];   /* for top level directory */
  int nfile;      /* max number of Netfiles */
  Netfile **f;

  /* about net */
  int limit;      /* flow control */
  int alen;     /* address length */
  int mbps;     /* megabits per sec */
  int link;     /* link status */
  int minmtu;
  int   maxmtu;
  int mtu;
  uchar addr[Nmaxaddr];
  uchar bcast[Nmaxaddr];


  int prom;     /* number of promiscuous opens */
  int scan;     /* number of base station scanners */
  int all;      /* number of -1 multiplexors */

  /* statistics */
  int misses;
  uvlong  inpackets;
  uvlong  outpackets;
  int crcs;   /* input crc errors */
  int oerrs;    /* output errors */
  int frames;   /* framing errors */
  int overflows;  /* packet overflows */
  int buffs;    /* buffering errors */
  int soverflows; /* software overflow */

  /* routines for touching the hardware */
  void  *arg;

  void  (*promiscuous)(void*, int);
  int (*hwmtu)(void*, int); /* get/set mtu */
  void  (*scanbs)(void*, uint); /* scan for base stations */

  <<[[Netif(kernel)]] multicast fields>>
  <<[[Netif(kernel)]] multicast methods>>
};
@

\section{Routing table}

% ARP allows local routing
% /net/iproute allows inter-network routing, find gateway

\section{Connexion}

% ip + port = is enough to establish a connexion

\subsection{Ports}

% need ip + port in general

21`% ipA!portA <-> ipB!portB











\chapter{Initialization}

\section{Kernel side}

\subsection{Mounting the ip device}

% see kernel init
% bind #I /net
%  bind_safe("#I", "/net", MREPL); // devip

% (not /dev)
% => /net/... especially /net/ipifc/, /net/arp, /net/iproute

% ??? sysbind?? -> <> (as attach <- ipdevtab.attach <- toplevel)
<<function ipattach>>=
static Chan*
ipattach(char* spec)
{
    Chan *c;
    int dev;

    dev = atoi(spec);
    if(dev >= Nfs)
        error("bad specification");

    // initialize ip stack
    ipgetfs(dev);

    c = devattach('I', spec);
    mkqid(&c->qid, QID(0, 0, Qtopdir), 0, QTDIR);
    c->dev = dev;
    c->aux = newipaux(up->user, "none");

    return c;
}
@
% spec? can have multiple network stack?

% will allocate a Fs, will allocate IP fragments,
% will initialize arp, protocols, and then return
% a channel handle that one can use to access Fs services.

% remember 
% - c->aux = private data stored in the channel.
% - c->dev = extra index information

<<function ipgetfs>>=
static Fs*
ipgetfs(int dev)
{
    extern void (*ipprotoinit[])(Fs*);
    Fs *f;
    int i;

    if(dev >= Nfs)
        return nil;

    qlock(&fslock);
    if(ipfs[dev] == nil){
        f = smalloc(sizeof(Fs));

        ip_init(f);
        arpinit(f);
        netloginit(f);
        for(i = 0; ipprotoinit[i]; i++)
            ipprotoinit[i](f);

        f->dev = dev;
        ipfs[dev] = f;
    }
    qunlock(&fslock);

    return ipfs[dev];
}
@

<<struct IPaux>>=
/*
 *  Hanging off every ip channel's ->aux is the following structure.
 *  It maintains the state used by devip and iproute.
 */
struct IPaux
{
  char  *owner;   /* the user that did the attach */
  char  tag[4];
};
@

<<macro ATTACHER>>=
#define ATTACHER(c) (((IPaux*)((c)->aux))->owner)
@


% ipattach -> <>
<<function newipaux>>=
IPaux*
newipaux(char *owner, char *tag)
{
    IPaux *a;
    int n;

    a = smalloc(sizeof(IPaux));
    kstrdup(&a->owner, owner);
    memset(a->tag, ' ', sizeof(a->tag));
    n = strlen(tag);
    if(n > sizeof(a->tag))
        n = sizeof(a->tag);
    memmove(a->tag, tag, n);
    return a;
}
@

\subsubsection{[[ip_init()]]}

% ipattach -> ipgetfs -> <>
<<function ip_init>>=
void
ip_init(Fs *f)
{
    IP *ip;

    ip = smalloc(sizeof(IP));
    initfrag(ip, 100);
    f->ip = ip;

    <<[[ip_init()]] ipv6 init>>
}
@

<<function initfrag>>=
void
initfrag(IP *ip, int size)
{
    Fragment4 *fq4, *eq4;
    <<[[initfrag()]] locals>>

    ip->fragfree4 = (Fragment4*)malloc(sizeof(Fragment4) * size);
    if(ip->fragfree4 == nil)
        panic("initfrag");

    eq4 = &ip->fragfree4[size];
    for(fq4 = ip->fragfree4; fq4 < eq4; fq4++)
        fq4->next = fq4+1;

    ip->fragfree4[size-1].next = nil;

    <<[[initfrag()]] ipv6 init fragfree6>>
}
@
% 100 packets

\subsubsection{[[arpinit()]]}
% will see later


<<function arpinit>>=
void
arpinit(Fs *f)
{
    f->arp = smalloc(sizeof(Arp));
    f->arp->f = f;
    f->arp->rxmt = nil;
    f->arp->dropf = f->arp->dropl = nil;
    kproc("rxmitproc", rxmitproc, f->arp);
}
@

<<function rxmitproc>>=
static void
rxmitproc(void *v)
{
    Arp *arp = v;
    long wakeupat;

    arp->rxmitp = up;
    //print("arp rxmitproc started\n");
    if(waserror()){
        arp->rxmitp = 0;
        pexit("hangup", 1);
    }
    for(;;){
        wakeupat = rxmitsols(arp);
        if(wakeupat == 0)
            sleep(&arp->rxmtq, rxready, v);
        else if(wakeupat > ReTransTimer/4)
            tsleep(&arp->rxmtq, returnfalse, 0, wakeupat);
    }
}
@

\subsubsection{[[netloginit()]]}
% see in appendix

\subsubsection{[[ipprotoinit()]]}
% each specifics

% in qemu.c because of qemu.conf:
%void (*ipprotoinit[])(Fs*) = {
%	tcpinit,
%	udpinit,
%	ipifcinit,
%	icmpinit,
%	icmp6init,
%	ilinit,
%	nil,
%};


\subsection{Mounting the ethernet device}

% see kernel init
% bind #l -a /net
%  bind_safe("#l0", "/net", MAFTER); // ether (and dev 0)

% => /net/ether0
% => /net/ether0/addr to get MAC address

% actually populated with many things already, 0/, 1/, 2/ with
% different x/type values

% /net/ether0/stats  give you also your mac address at the very end


<<function etherattach>>=
Chan*
etherattach(char* spec)
{
    ulong ctlrno;
    char *p;
    Chan *chan;

    ctlrno = 0;
    if(spec && *spec){
        ctlrno = strtoul(spec, &p, 0);
        if((ctlrno == 0 && p == spec) || *p || (ctlrno >= MaxEther))
            error(Ebadarg);
    }
    if(etherxx[ctlrno] == nil)
        error(Enodev);

    chan = devattach('l', spec);
    if(waserror()){
        chanfree(chan);
        nexterror();
    }
    chan->dev = ctlrno;
    if(etherxx[ctlrno]->attach)
        etherxx[ctlrno]->attach(etherxx[ctlrno]);
    poperror();
    return chan;
}
@
% #l0 => spec = 0

\subsection{Connecting ip to ethernet}
% not really initialisation, more configuration, so could be moved
% later, and in fact harder to explain now.

%linux: ifconfig eth0 ...

% open /net/ipifc/clone and start configure things.
%  echo 'bind ether /net/ether0' > /net/ipifc/0/ctl
%  echo 'add 10.0.2.15' > /net/ipifc/0/ctl
% (but how I guessed my ip? ipconfig use dhcp?)

% or use program:
% $ ip/ipconfig
% => /net/ipifc/0/... now contains an interface! connected to ethernet
%    /net/ipifc/0/status is nice
% => /net/arp now contains entries
% => /net/iproute now contains entries

\section{User side}

\subsection{Connect manually}

% open /net/<protocol>/clone

\subsection{[[dial()]]}

% dial uses connection server which introduces extra complexity







\chapter{User/Kernel Bridge}

\section{IP device}

<<global ipdevtab>>=
Dev ipdevtab = {
    .dc       =    'I',
    .name     =    "ip",

    .attach   =    ipattach,
    .walk     =    ipwalk,
    .open     =    ipopen,
    .close    =    ipclose,
    .read     =    ipread,
    .write    =    ipwrite,
    .stat     =    ipstat,
    .wstat    =    ipwstat,
               
    .reset    =    ipreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
    .create   =    ipcreate,
    .bread    =    ipbread,
    .bwrite   =    ipbwrite,
    .remove   =    ipremove,
};
@

\subsection{[[/net]] hierarchy and [[ipwalk()]]}}

<<function ipwalk>>=
static Walkqid*
ipwalk(Chan* c, Chan *nc, char **name, int nname)
{
    IPaux *a = c->aux;
    Walkqid* w;

    w = devwalk(c, nc, name, nname, nil, 0, ipgen);

    if(w != nil && w->clone != nil)
        w->clone->aux = newipaux(a->owner, a->tag);

    return w;
}
@
% =~ readdir

% devwalk <- <> (as xx <- ipwalk)
<<function ipgen>>=
static int
ipgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    Fs *f;
    Qid q;
    Conv *cv;

    f = ipfs[c->dev];

    switch(TYPE(c->qid)) {
    <<[[ipgen()]] switch TYPE qid cases>>
    }
    return -1;
}
@
% -1 means no more entries



\subsubsection{[[/net/]]}

% remember s is an integer to get the xth entry in the directory, 
% or -1  (DEVDOTDOT). How knows when to stop? what is the max value
% of s? see above, -1 when switch does not match anything?
<<[[ipgen()]] switch TYPE qid cases>>=
case Qtopdir:
    if(s == DEVDOTDOT){
        mkqid(&q, QID(0, 0, Qtopdir), 0, QTDIR);
        snprint(up->genbuf, sizeof up->genbuf, "#I%lud", c->dev);
        devdir(c, q, up->genbuf, 0, network, 0555, dp);
        return 1;
    }
    if(s < f->np) {
        if(f->p[s]->connect == nil)
            return 0;   /* protocol with no user interface */
        mkqid(&q, QID(s, 0, Qprotodir), 0, QTDIR);
        devdir(c, q, f->p[s]->name, 0, network, 0555, dp);
        return 1;
    }
    s -= f->np;
    return ip1gen(c, s+Qtopbase, dp);
@

<<global network>>=
static char network[] = "network";
@


\subsubsection{[[/net/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qarp:
case Qlog:
case Qiproute:
case Qipselftab:
case Qbootp:
case Qndb:
    return ip1gen(c, TYPE(c->qid), dp);
@

<<function ip1gen>>=
static int
ip1gen(Chan *c, int i, Dir *dp)
{
    Qid q;
    char *p;
    int prot;
    int len = 0;
    Fs *f;
    extern ulong    kerndate;

    f = ipfs[c->dev];

    prot = 0666;
    mkqid(&q, QID(0, 0, i), 0, QTFILE);
    switch(i) {
    <<[[ip1gen()]] switch TYPE qid cases>>
    default:
        return -1;
    }
    devdir(c, q, p, len, network, prot, dp);
    <<[[ipgen()]] if Qndb, adjust mtime>>
    return 1;
}
@





\subsubsection{[[/net/proto/]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qprotodir:
    if(s == DEVDOTDOT){
        mkqid(&q, QID(0, 0, Qtopdir), 0, QTDIR);
        snprint(up->genbuf, sizeof up->genbuf, "#I%lud", c->dev);
        devdir(c, q, up->genbuf, 0, network, 0555, dp);
        return 1;
    }
    if(s < f->p[PROTO(c->qid)]->ac) {
        cv = f->p[PROTO(c->qid)]->conv[s];
        snprint(up->genbuf, sizeof up->genbuf, "%d", s);
        mkqid(&q, QID(PROTO(c->qid), s, Qconvdir), 0, QTDIR);
        devdir(c, q, up->genbuf, 0, cv->owner, 0555, dp);
        return 1;
    }
    s -= f->p[PROTO(c->qid)]->ac;
    return ip2gen(c, s+Qprotobase, dp);
@


\subsubsection{[[/net/proto/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qclone:
case Qstats:
    return ip2gen(c, TYPE(c->qid), dp);
@

<<function ip2gen>>=
static int
ip2gen(Chan *c, int i, Dir *dp)
{
    Qid q;

    switch(i) {
    case Qclone:
        mkqid(&q, QID(PROTO(c->qid), 0, Qclone), 0, QTFILE);
        devdir(c, q, "clone", 0, network, 0666, dp);
        return 1;
    case Qstats:
        mkqid(&q, QID(PROTO(c->qid), 0, Qstats), 0, QTFILE);
        devdir(c, q, "stats", 0, network, 0444, dp);
        return 1;
    }
    return -1;
}
@

\subsubsection{[[/net/proto/conv/]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qconvdir:
    if(s == DEVDOTDOT){
        s = PROTO(c->qid);
        mkqid(&q, QID(s, 0, Qprotodir), 0, QTDIR);
        devdir(c, q, f->p[s]->name, 0, network, 0555, dp);
        return 1;
    }
    return ip3gen(c, s+Qconvbase, dp);
@


\subsubsection{[[/net/proto/conv/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
case Qlisten:
case Qlocal:
case Qremote:
case Qstatus:
case Qsnoop:
    return ip3gen(c, TYPE(c->qid), dp);
@

<<function ip3gen>>=
static int
ip3gen(Chan *c, int i, Dir *dp)
{
    Qid q;
    Conv *cv;
    char *p;

    cv = ipfs[c->dev]->p[PROTO(c->qid)]->conv[CONV(c->qid)];

    if(cv->owner == nil)
        kstrdup(&cv->owner, eve);

    mkqid(&q, QID(PROTO(c->qid), CONV(c->qid), i), 0, QTFILE);

    switch(i) {
    <<[[ip3gen()]] switch TYPE qid cases>>
    default:
        return -1;
    }
    devdir(c, q, p, 0, cv->owner, 0444, dp);
    return 1;
}
@

<<[[ip3gen()]] switch TYPE qid cases>>=
case Qctl:
    devdir(c, q, "ctl", 0, cv->owner, cv->perm, dp);
    return 1;
case Qdata:
    devdir(c, q, "data", qlen(cv->rq), cv->owner, cv->perm, dp);
    return 1;
@

%XXX
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qerr:
    devdir(c, q, "err", qlen(cv->eq), cv->owner, cv->perm, dp);
    return 1;
@

<<[[ip3gen()]] switch TYPE qid cases>>=
case Qlisten:
    devdir(c, q, "listen", 0, cv->owner, cv->perm, dp);
    return 1;
@

<<[[ip3gen()]] switch TYPE qid cases>>=
case Qlocal:
    p = "local";
    break;
case Qremote:
    p = "remote";
    break;
@


<<[[ip3gen()]] switch TYPE qid cases>>=
case Qstatus:
    p = "status";
    break;
@


\subsection{[[ipopen()]]}

<<global m2p>>=
static int m2p[] = {
    [OREAD]     4,
    [OWRITE]    2,
    [ORDWR]     6
};
@

<<function ipopen>>=
static Chan*
ipopen(Chan* c, int omode)
{
    Fs *f;
    int perm;
    Proto *p;
    Conv *cv, *nc;

    perm = m2p[omode&3];

    f = ipfs[c->dev];

    switch(TYPE(c->qid)) {
    <<[[ipopen()]] switch TYPE qid cases>>
    default:
        break;
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    return c;
}
@


<<[[ipopen()]] switch TYPE qid cases>>=
case Qtopdir:
case Qprotodir:
case Qconvdir:

case Qbootp:
case Qipselftab:

case Qstatus:
case Qremote:
case Qlocal:
case Qstats:
    if(omode != OREAD)
        error(Eperm);
    break;
@







%XXX
<<[[ipopen()]] switch TYPE qid cases>>=
case Qlisten:
    cv = f->p[PROTO(c->qid)]->conv[CONV(c->qid)];
    if((perm & (cv->perm>>6)) != perm) {
        if(strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if((perm & cv->perm) != perm)
            error(Eperm);

    }

    if(cv->state != Announced)
        error("not announced");

    if(waserror()){
        closeconv(cv);
        nexterror();
    }
    qlock(cv);
    cv->inuse++;
    qunlock(cv);

    nc = nil;
    while(nc == nil) {
        /* give up if we got a hangup */
        if(qisclosed(cv->rq))
            error("listen hungup");

        qlock(&cv->listenq);
        if(waserror()) {
            qunlock(&cv->listenq);
            nexterror();
        }

        /* wait for a connect */
        sleep(&cv->listenr, incoming, cv);

        qlock(cv);
        nc = cv->incall;
        if(nc != nil){
            cv->incall = nc->next;
            mkqid(&c->qid, QID(PROTO(c->qid), nc->x, Qctl), 0, QTFILE);
            kstrdup(&cv->owner, ATTACHER(c));
        }
        qunlock(cv);

        qunlock(&cv->listenq);
        poperror();
    }
    closeconv(cv);
    poperror();
    break;
@

\subsection{[[ipread()]]}

<<function ipread>>=
static long
ipread(Chan *ch, void *a, long n, vlong off)
{
    Fs *f;
    Proto *x;
    Conv *c;
    char *buf, *p;
    long rv;
    ulong offset = off;

    f = ipfs[ch->dev];

    p = a;
    switch(TYPE(ch->qid)) {
    <<[[ipread()]] switch TYPE qid cases>>
    default:
        error(Eperm);

    }
}
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qtopdir:
case Qprotodir:
case Qconvdir:
    return devdirread(ch, a, n, 0, 0, ipgen);
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qctl:
    buf = smalloc(16);
    snprint(buf, 16, "%lud", CONV(ch->qid));
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@
% that's how you get your /x/

<<[[ipread()]] switch TYPE qid cases>>=
case Qdata:
    c = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(c->rq, a, n);
@






<<[[ipread()]] switch TYPE qid cases>>=
case Qremote:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    c = x->conv[CONV(ch->qid)];
    if(x->remote == nil) {
        snprint(buf, Statelen, "%I!%d\n", c->raddr, c->rport);
    } else {
        // Protocol dispatch
        (*x->remote)(c, buf, Statelen-2);
    }
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qlocal:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    c = x->conv[CONV(ch->qid)];
    if(x->local == nil) {
        snprint(buf, Statelen, "%I!%d\n", c->laddr, c->lport);
    } else {
        // Protocol dispatch
        (*x->local)(c, buf, Statelen-2);
    }
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qstatus:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    c = x->conv[CONV(ch->qid)];

    // Protocol dispatch
    (*x->state)(c, buf, Statelen-2);

    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@




<<[[ipread()]] switch TYPE qid cases>>=
case Qerr:
    c = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(c->eq, a, n);
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qstats:
    x = f->p[PROTO(ch->qid)];
    if(x->stats == nil)
        error("stats not implemented");
    buf = smalloc(Statelen);

    // Protocol dispatch
    (*x->stats)(x, buf, Statelen);

    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

\subsection{[[ipwrite()]]}


<<function ipwrite>>=
static long
ipwrite(Chan* ch, void *v, long n, vlong off)
{
    Conv *c;
    Proto *x;
    char *p;
    Cmdbuf *cb;
    uchar ia[IPaddrlen], ma[IPaddrlen];
    Fs *f;
    char *a;
    ulong offset = off;

    a = v;
    f = ipfs[ch->dev];

    switch(TYPE(ch->qid)){
    <<[[ipwrite()]] switch TYPE qid cases>>
    default:
        error(Eperm);
    }
    return n;
}
@

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qdata:
    x = f->p[PROTO(ch->qid)];
    c = x->conv[CONV(ch->qid)];

    if(c->wq == nil)
        error(Eperm);

    qwrite(c->wq, a, n);
    break;
@


\subsection{[[/net/x/clone]]}

<<[[ipopen()]] switch TYPE qid cases>>=
case Qclone:
    p = f->p[PROTO(c->qid)];

    qlock(p);
    if(waserror()){
        qunlock(p);
        nexterror();
    }

    cv = Fsprotoclone(p, ATTACHER(c));

    qunlock(p);
    poperror();
    if(cv == nil) {
        error(Enodev);
        break;
    }
    mkqid(&c->qid, QID(p->x, cv->x, Qctl), 0, QTFILE);
    break;
@
% Qctl !! redirect to Qctl of newly created /net/<proto>/<conv>/ dir
% with a newly conversation created in Fs->p[x]->conv[x] with
% the queue created


<<function Fsprotoclone>>=
/*
 *  called with protocol locked
 */
Conv*
Fsprotoclone(Proto *p, char *user)
{
    Conv *c, **pp, **ep;

retry:
    c = nil;
    ep = &p->conv[p->nc];
    for(pp = p->conv; pp < ep; pp++) {
        c = *pp;
        if(c == nil){
            c = malloc(sizeof(Conv));
            if(c == nil)
                error(Enomem);
            qlock(c);
            c->p = p;
            c->x = pp - p->conv;
            if(p->ptclsize != 0){
                c->ptcl = malloc(p->ptclsize);
                if(c->ptcl == nil) {
                    free(c);
                    error(Enomem);
                }
            }
            *pp = c;
            p->ac++;
            c->eq = qopen(1024, Qmsg, 0, 0);

            // !! Protocol dispatch !!! will create extra queues
            (*p->create)(c);

            break;
        }
        if(canqlock(c)){
            /*
             *  make sure both processes and protocol
             *  are done with this Conv
             */
            if(c->inuse == 0 && (p->inuse == nil || (*p->inuse)(c) == 0))
                break;

            qunlock(c);
        }
    }

    if(pp >= ep) {
        if(p->gc)
            print("Fsprotoclone: garbage collecting Convs\n");
        if(p->gc != nil && (*p->gc)(p))
            goto retry;
        /* debugging: do we ever get here? */
        if (cpuserver)
            panic("Fsprotoclone: all conversations in use");
        return nil;
    }

    c->inuse = 1;
    kstrdup(&c->owner, user);
    c->perm = 0660;
    c->state = Idle;
    ipmove(c->laddr, IPnoaddr);
    ipmove(c->raddr, IPnoaddr);
    c->r = nil;
    c->rgen = 0;
    c->lport = 0;
    c->rport = 0;
    c->restricted = 0;
    c->maxfragsize = 0;
    c->ttl = MAXTTL;
    qreopen(c->rq);
    qreopen(c->wq);
    qreopen(c->eq);

    qunlock(c);
    return c;
}
@

\subsection{[[/net/x/y/ctl]]}

<<[[ipopen()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
    p = f->p[PROTO(c->qid)];
    qlock(p);
    cv = p->conv[CONV(c->qid)];
    qlock(cv);
    if(waserror()) {
        qunlock(cv);
        qunlock(p);
        nexterror();
    }
    if((perm & (cv->perm>>6)) != perm) {
        if(strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if((perm & cv->perm) != perm)
            error(Eperm);

    }
    cv->inuse++;
    if(cv->inuse == 1){
        kstrdup(&cv->owner, ATTACHER(c));
        cv->perm = 0660;
    }
    qunlock(cv);
    qunlock(p);
    poperror();
    break;
@



<<[[ipwrite()]] switch TYPE qid cases>>=
case Qctl:
    x = f->p[PROTO(ch->qid)];
    c = x->conv[CONV(ch->qid)];
    cb = parsecmd(a, n);

    qlock(c);
    if(waserror()) {
        qunlock(c);
        free(cb);
        nexterror();
    }
    if(cb->nf < 1)
        error("short control request");

    if(strcmp(cb->f[0], "connect") == 0)
        connectctlmsg(x, c, cb);
    else if(strcmp(cb->f[0], "announce") == 0)
        announcectlmsg(x, c, cb);
    else if(strcmp(cb->f[0], "bind") == 0)
        bindctlmsg(x, c, cb);
    else if(strcmp(cb->f[0], "ttl") == 0)
        ttlctlmsg(c, cb);
    else if(strcmp(cb->f[0], "tos") == 0)
        tosctlmsg(c, cb);
    else if(strcmp(cb->f[0], "ignoreadvice") == 0)
        c->ignoreadvice = true;
    else if(strcmp(cb->f[0], "addmulti") == 0){
        if(cb->nf < 2)
            error("addmulti needs interface address");
        if(cb->nf == 2){
            if(!ipismulticast(c->raddr))
                error("addmulti for a non multicast address");
            if (parseip(ia, cb->f[1]) == -1)
                error(Ebadip);
            ipifcaddmulti(c, c->raddr, ia);
        } else {
            if (parseip(ia, cb->f[1]) == -1 ||
                parseip(ma, cb->f[2]) == -1)
                error(Ebadip);
            if(!ipismulticast(ma))
                error("addmulti for a non multicast address");
            ipifcaddmulti(c, ma, ia);
        }
    } else if(strcmp(cb->f[0], "remmulti") == 0){
        if(cb->nf < 2)
            error("remmulti needs interface address");
        if(!ipismulticast(c->raddr))
            error("remmulti for a non multicast address");
        if (parseip(ia, cb->f[1]) == -1)
            error(Ebadip);
        ipifcremmulti(c, c->raddr, ia);
    } else if(strcmp(cb->f[0], "maxfragsize") == 0){
        if(cb->nf < 2)
            error("maxfragsize needs size");

        c->maxfragsize = (int)strtol(cb->f[1], nil, 0);

    } 
    else if(x->ctl != nil) {
        // Protocol dispatch
        p = x->ctl(c, cb->f, cb->nf);
        if(p != nil)
            error(p);
    } else
        error("unknown control request");
    qunlock(c);
    free(cb);
    poperror();
@


\subsection{[[/net/x/y/ctl bind]]}

% ipwrite (Qctl case) -> <>
<<function bindctlmsg>>=
static void
bindctlmsg(Proto *x, Conv *c, Cmdbuf *cb)
{
    char *p;

    if(x->bind == nil)
        p = Fsstdbind(c, cb->f, cb->nf);
    else
        // Protocol dispatch
        p = x->bind(c, cb->f, cb->nf);
    if(p != nil)
        error(p);
}
@


\section{[[/net/ipifc/]] protocol}

\subsection{Protocol initialisation}

% ipattach -> ipgetfs -> <> (as ipprotoinit[i] <- ipprotoinit[x] = <> <- qemu.c)
<<function ipifcinit>>=
void
ipifcinit(Fs *f)
{
    Proto *ipifc;

    ipifc = smalloc(sizeof(Proto));

    ipifc->name = "ipifc";
    ipifc->connect = ipifcconnect;
    ipifc->announce = nil;
    ipifc->bind = ipifcbind;

    ipifc->state = ipifcstate;
    ipifc->create = ipifccreate;
    ipifc->close = ipifcclose;
    ipifc->rcv = nil;
    ipifc->ctl = ipifcctl;
    ipifc->advise = nil;
    ipifc->stats = ipifcstats;
    ipifc->inuse = ipifcinuse;
    ipifc->local = ipifclocal;

    ipifc->ipproto = -1;
    ipifc->nc = Maxmedia;
    ipifc->ptclsize = sizeof(Ipifc);

    f->ipifc = ipifc;   /* hack for ipifcremroute, findipifc, ... */
    f->self = smalloc(sizeof(Ipselftab));   /* hack for ipforme */

    Fsproto(f, ipifc);
}
@

<<[[Fs(kernel)]] other fields>>=
Proto*  ipifc;      /* kludge for ipifcremroute & ipifcaddroute */
@

<<[[Fs(kernel)]] other fields>>=
Ipselftab *self;
@



<<function Fsproto>>=
int
Fsproto(Fs *f, Proto *p)
{
    if(f->np >= Maxproto)
        return -1;

    p->f = f;

    if(p->ipproto > 0){
        if(f->t2p[p->ipproto] != nil)
            return -1;
        f->t2p[p->ipproto] = p;
    }

    p->qid.type = QTDIR;
    p->qid.path = QID(f->np, 0, Qprotodir);
    p->conv = malloc(sizeof(Conv*)*(p->nc+1));
    if(p->conv == nil)
        panic("Fsproto");

    p->x = f->np;
    p->nextrport = 600;
    f->p[f->np++] = p;

    return 0;
}
@



\subsection{[[/net/ipifc/clone]]}

%// sysopen(/net/ipifc/clone) -> ... -> ipopen -> Fsprotoclone -> <>
%  (as x->bind <- ...)
<<function ipifccreate>>=
/*
 *  called when a new ipifc structure is created
 */
static void
ipifccreate(Conv *c)
{
    Ipifc *ifc;

    c->rq = qopen(QMAX, 0, 0, 0);
    c->sq = qopen(QMAX, 0, 0, 0);
    c->wq = qopen(QMAX, Qkick, ipifckick, c);

    ifc = (Ipifc*)c->ptcl;
    ifc->conv = c;
    ifc->unbinding = 0;
    ifc->m = nil;
    ifc->reassemble = 0;
}
@

\subsection{[[/net/ipifc/x/ctl bind]]}

% ipwrite (Qctl case) -> bindctlmsg -> <> (as x->bind <- ipprotoinit[i] <- qmemu.c)
<<function ipifcbind>>=
/*
 *  attach a device (or pkt driver) to the interface.
 *  called with c locked
 */
static char*
ipifcbind(Conv *c, char **argv, int argc)
{
    Ipifc *ifc;
    Medium *m;

    if(argc < 2)
        return Ebadarg;

    ifc = (Ipifc*)c->ptcl;

    /* bind the device to the interface */
    m = ipfindmedium(argv[1]);
    if(m == nil)
        return "unknown interface type";

    wlock(ifc);
    if(ifc->m != nil){
        wunlock(ifc);
        return "interface already bound";
    }
    if(waserror()){
        wunlock(ifc);
        nexterror();
    }

    /* do medium specific binding */
    (*m->bind)(ifc, argc, argv);

    /* set the bound device name */
    if(argc > 2)
        strncpy(ifc->dev, argv[2], sizeof(ifc->dev));
    else
        snprint(ifc->dev, sizeof ifc->dev, "%s%d", m->name, c->x);
    ifc->dev[sizeof(ifc->dev)-1] = 0;

    /* set up parameters */
    ifc->m = m;
    ifc->mintu = ifc->m->mintu;
    ifc->maxtu = ifc->m->maxtu;
    if(ifc->m->unbindonclose == false)
        ifc->conv->inuse++;
    ifc->rp.mflag = 0;      /* default not managed */
    ifc->rp.oflag = 0;
    ifc->rp.maxraint = 600000;  /* millisecs */
    ifc->rp.minraint = 200000;
    ifc->rp.linkmtu = 0;        /* no mtu sent */
    ifc->rp.reachtime = 0;
    ifc->rp.rxmitra = 0;
    ifc->rp.ttl = MAXTTL;
    ifc->rp.routerlt = 3 * ifc->rp.maxraint;

    /* any ancillary structures (like routes) no longer pertain */
    ifc->ifcid++;

    /* reopen all the queues closed by a previous unbind */
    qreopen(c->rq);
    qreopen(c->eq);
    qreopen(c->sq);

    wunlock(ifc);
    poperror();

    return nil;
}
@

<<function ipfindmedium>>=
/*
 *  find the medium with this name
 */
Medium*
ipfindmedium(char *name)
{
    Medium **mp;

    for(mp = media; *mp != nil; mp++)
        if(strcmp((*mp)->name, name) == 0)
            break;
    return *mp;
}
@
% use global media


\subsection{[[/net/ipifc/x/add add]]}


% ... -> ipwrite (Qctl case) -> <>
%  (as x->bind <- ...)
<<function ipifcctl>>=
/*
 *  non-standard control messages.
 *  called with c->car locked.
 */
static char*
ipifcctl(Conv* c, char** argv, int argc)
{
    Ipifc *ifc;
    int i;

    ifc = (Ipifc*)c->ptcl;
    if(strcmp(argv[0], "add") == 0)
        return ipifcadd(ifc, argv, argc, 0, nil);

    else if(strcmp(argv[0], "try") == 0)
        return ipifcadd(ifc, argv, argc, 1, nil);
    else if(strcmp(argv[0], "remove") == 0)
        return ipifcrem(ifc, argv, argc);
    else if(strcmp(argv[0], "unbind") == 0)
        return ipifcunbind(ifc);
    else if(strcmp(argv[0], "joinmulti") == 0)
        return ipifcjoinmulti(ifc, argv, argc);
    else if(strcmp(argv[0], "leavemulti") == 0)
        return ipifcleavemulti(ifc, argv, argc);
    else if(strcmp(argv[0], "mtu") == 0)
        return ipifcsetmtu(ifc, argv, argc);
    else if(strcmp(argv[0], "reassemble") == 0){
        ifc->reassemble = 1;
        return nil;
    }
    else if(strcmp(argv[0], "iprouting") == 0){
        i = 1;
        if(argc > 1)
            i = atoi(argv[1]);
        iprouting(c->p->f, i);
        return nil;
    }
    else if(strcmp(argv[0], "add6") == 0)
        return ipifcadd6(ifc, argv, argc);
    else if(strcmp(argv[0], "ra6") == 0)
        return ipifcra6(ifc, argv, argc);
    return "unsupported ctl";
}
@


<<function ipifcadd>>=
/*
 *  add an address to an interface.
 */
char*
ipifcadd(Ipifc *ifc, char **argv, int argc, int tentative, Iplifc *lifcp)
{
    int i, type, mtu, sendnbrdisc = 0;
    uchar ip[IPaddrlen], mask[IPaddrlen], rem[IPaddrlen];
    uchar bcast[IPaddrlen], net[IPaddrlen];
    Iplifc *lifc, **l;
    Fs *f;

    if(ifc->m == nil)
        return "ipifc not yet bound to device";

    f = ifc->conv->p->f;

    type = Rifc;
    memset(ip, 0, IPaddrlen);
    memset(mask, 0, IPaddrlen);
    memset(rem, 0, IPaddrlen);
    switch(argc){
    case 6:
        if(strcmp(argv[5], "proxy") == 0)
            type |= Rproxy;
        /* fall through */
    case 5:
        mtu = strtoul(argv[4], 0, 0);
        if(mtu >= ifc->m->mintu && mtu <= ifc->m->maxtu)
            ifc->maxtu = mtu;
        /* fall through */
    case 4:
        if (parseip(ip, argv[1]) == -1 || parseip(rem, argv[3]) == -1)
            return Ebadip;
        parseipmask(mask, argv[2]);
        maskip(rem, mask, net);
        break;
    case 3:
        if (parseip(ip, argv[1]) == -1)
            return Ebadip;
        parseipmask(mask, argv[2]);
        maskip(ip, mask, rem);
        maskip(rem, mask, net);
        break;
    case 2:
        if (parseip(ip, argv[1]) == -1)
            return Ebadip;
        memmove(mask, defmask(ip), IPaddrlen);
        maskip(ip, mask, rem);
        maskip(rem, mask, net);
        break;
    default:
        return Ebadarg;
    }
    if(isv4(ip))
        tentative = 0;
    wlock(ifc);

    /* ignore if this is already a local address for this ifc */
    for(lifc = ifc->lifc; lifc; lifc = lifc->next) {
        if(ipcmp(lifc->local, ip) == 0) {
            if(lifc->tentative != tentative)
                lifc->tentative = tentative;
            if(lifcp) {
                lifc->onlink = lifcp->onlink;
                lifc->autoflag = lifcp->autoflag;
                lifc->validlt = lifcp->validlt;
                lifc->preflt = lifcp->preflt;
                lifc->origint = lifcp->origint;
            }
            goto out;
        }
    }

    /* add the address to the list of logical ifc's for this ifc */
    lifc = smalloc(sizeof(Iplifc));
    ipmove(lifc->local, ip);
    ipmove(lifc->mask, mask);
    ipmove(lifc->remote, rem);
    ipmove(lifc->net, net);
    lifc->tentative = tentative;
    if(lifcp) {
        lifc->onlink = lifcp->onlink;
        lifc->autoflag = lifcp->autoflag;
        lifc->validlt = lifcp->validlt;
        lifc->preflt = lifcp->preflt;
        lifc->origint = lifcp->origint;
    } else {        /* default values */
        lifc->onlink = lifc->autoflag = 1;
        lifc->validlt = lifc->preflt = ~0L;
        lifc->origint = NOW / 1000;
    }
    lifc->next = nil;

    for(l = &ifc->lifc; *l; l = &(*l)->next)
        ;
    *l = lifc;

    /* check for point-to-point interface */
    if(ipcmp(ip, v6loopback)) /* skip v6 loopback, it's a special address */
    if(ipcmp(mask, IPallbits) == 0)
        type |= Rptpt;

    /* add local routes */
    if(isv4(ip))
        v4addroute(f, tifc, rem+IPv4off, mask+IPv4off, rem+IPv4off, type);
    else
        v6addroute(f, tifc, rem, mask, rem, type);

    addselfcache(f, ifc, lifc, ip, Runi);

    if((type & (Rproxy|Rptpt)) == (Rproxy|Rptpt)){
        ipifcregisterproxy(f, ifc, rem);
        goto out;
    }

    if(isv4(ip) || ipcmp(ip, IPnoaddr) == 0) {
        /* add subnet directed broadcast address to the self cache */
        for(i = 0; i < IPaddrlen; i++)
            bcast[i] = (ip[i] & mask[i]) | ~mask[i];
        addselfcache(f, ifc, lifc, bcast, Rbcast);

        /* add subnet directed network address to the self cache */
        for(i = 0; i < IPaddrlen; i++)
            bcast[i] = (ip[i] & mask[i]) & mask[i];
        addselfcache(f, ifc, lifc, bcast, Rbcast);

        /* add network directed broadcast address to the self cache */
        memmove(mask, defmask(ip), IPaddrlen);
        for(i = 0; i < IPaddrlen; i++)
            bcast[i] = (ip[i] & mask[i]) | ~mask[i];
        addselfcache(f, ifc, lifc, bcast, Rbcast);

        /* add network directed network address to the self cache */
        memmove(mask, defmask(ip), IPaddrlen);
        for(i = 0; i < IPaddrlen; i++)
            bcast[i] = (ip[i] & mask[i]) & mask[i];
        addselfcache(f, ifc, lifc, bcast, Rbcast);

        addselfcache(f, ifc, lifc, IPv4bcast, Rbcast);
    }
    else {
        if(ipcmp(ip, v6loopback) == 0) {
            /* add node-local mcast address */
            addselfcache(f, ifc, lifc, v6allnodesN, Rmulti);

            /* add route for all node multicast */
            v6addroute(f, tifc, v6allnodesN, v6allnodesNmask,
                v6allnodesN, Rmulti);
        }

        /* add all nodes multicast address */
        addselfcache(f, ifc, lifc, v6allnodesL, Rmulti);

        /* add route for all nodes multicast */
        v6addroute(f, tifc, v6allnodesL, v6allnodesLmask, v6allnodesL,
            Rmulti);

        /* add solicited-node multicast address */
        ipv62smcast(bcast, ip);
        addselfcache(f, ifc, lifc, bcast, Rmulti);

        sendnbrdisc = 1;
    }

    /* register the address on this network for address resolution */
    if(isv4(ip) && ifc->m->areg != nil)
        (*ifc->m->areg)(ifc, ip);

out:
    wunlock(ifc);
    if(tentative && sendnbrdisc)
        icmpns(f, 0, SRC_UNSPEC, ip, TARG_MULTI, ifc->mac);
    return nil;
}
@



\section{Ethernet medium}

% before IP? kinda more low level (but less general)
% called a medium?

% there are other physical device, but we'll focus on this one,
% most common

% physical 48bits address.

<<global ethermedium (kernel)>>=
Medium ethermedium =
{
    .name=      "ether",

    .hsize=     14,
    .mintu=     60,
    .maxtu=     1514,
    .maclen=    6,

    .bind=      etherbind,
    .unbind=    etherunbind,
    .bwrite=    etherbwrite,

    .addmulti=  etheraddmulti,
    .remmulti=  etherremmulti,
    .ares=      arpenter,
    .areg=      sendgarp,
    .pref2addr= etherpref2addr,
};
@
% maxtu = 1500 + 14 for header
% maclen = 6 = 48 bits


<<global etherbroadcast>>=
static uchar etherbroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
@




\section{Ethernet device}



<<global etherdevtab>>=
Dev etherdevtab = {
    .dc       =    'l',
    .name     =    "ether",

    .attach   =    etherattach,
    .walk     =    etherwalk,
    .open     =    etheropen,
    .close    =    etherclose,
    .read     =    etherread,
    .write    =    etherwrite,
    .stat     =    etherstat,
    .wstat    =    etherwstat,
               
    .reset    =    etherreset,
    .init     =    devinit,
    .shutdown =    ethershutdown,
    .create   =    ethercreate,
    .bread    =    etherbread,
    .bwrite   =    etherbwrite,
    .remove   =    devremove,
};
@


\section{Streams}

% like bidirectional pipes. Producer/consumer like pipes, but
% bidirectional.







\chapter{IP}


\section{IP addresses}

\subsection{Parsing}

%ex: ip address 10.0.0.2
<<function v4parseip>>=
char*
v4parseip(uchar *to, char *from)
{
    int i;
    char *p;

    p = from;
    for(i = 0; i < 4 && *p; i++){
        to[i] = strtoul(p, &p, 0);
        if(*p == '.')
            p++;
    }
    switch(CLASS(to)){
    case 0:	/* class A - 1 uchar net */
    case 1:
        if(i == 3){
            to[3] = to[2];
            to[2] = to[1];
            to[1] = 0;
        } else if (i == 2){
            to[3] = to[1];
            to[1] = 0;
        }
        break;
    case 2:	/* class B - 2 uchar net */
        if(i == 3){
            to[3] = to[2];
            to[2] = 0;
        }
        break;
    }
    return p;
}
@

<<function parseip>>=
/*
 * `from' may contain an address followed by other characters,
 * at least in /boot, so we permit whitespace (and more) after the address.
 * we do ensure that "delete" cannot be parsed as "de::".
 *
 * some callers don't check the return value for errors, so
 * set `to' to something distinctive in the case of a parse error.
 */
vlong
parseip(uchar *to, char *from)
{
    int i, elipsis = 0;
    bool v4 = true;
    ulong x;
    char *p, *op;

    memset(to, 0, IPaddrlen);
    p = from;
    for(i = 0; i < IPaddrlen && ipcharok(*p); i+=2){
        op = p;
        x = strtoul(p, &p, 16);
        if((*p == '.' && i <= IPaddrlen-4) || (*p == '\0' && i == 0)){
            /* ends with v4 */
            p = v4parseip(to+i, op);
            i += 4;
            break;
        }

        /* v6: at most 4 hex digits, followed by colon or delim */
        if(x != (ushort)x || *p != ':' && !delimchar(*p)) {
            memset(to, 0, IPaddrlen);
            return -1;			/* parse error */
        }
        to[i] = x>>8;
        to[i+1] = x;
        if(*p == ':'){
            v4 = false;
            if(*++p == ':'){	/* :: is elided zero short(s) */
                if (elipsis) {
                    memset(to, 0, IPaddrlen);
                    return -1;	/* second :: */
                }
                elipsis = i+2;
                p++;
            }
        } else if (p == op)		/* strtoul made no progress? */
            break;
    }
    if (p == from || !delimchar(*p)) {
        memset(to, 0, IPaddrlen);
        return -1;				/* parse error */
    }
    if(i < IPaddrlen){
        memmove(&to[elipsis+IPaddrlen-i], &to[elipsis], i-elipsis);
        memset(&to[elipsis], 0, IPaddrlen-i);
    }

    if(v4){
        to[10] = to[11] = 0xff;
        return nhgetl(to + IPv4off);
    } else
        return 6;
}
@

\subsection{Comparisons}

<<macro ipcmp>>=
#define	ipcmp(x, y) memcmp(x, y, IPaddrlen)
@

<<macro ipmove>>=
#define	ipmove(x, y) memmove(x, y, IPaddrlen)
@

<<function equivip4>>=
bool
equivip4(uchar *a, uchar *b)
{
    int i;

    for(i = 0; i < 4; i++)
        if(a[i] != b[i])
            return false;
    return true;
}
@
%less: diff with ipcmp? used?


\section{IP header}

<<struct Ip4hdr>>=
/* on the wire packet header */
struct Ip4hdr
{
  uchar vihl;   /* Version and header length */
  uchar tos;    /* Type of service */
  uchar length[2];  /* packet length */
  uchar id[2];    /* ip->identification */
  uchar frag[2];  /* Fragment information */
  uchar ttl;        /* Time to live */
  uchar proto;    /* Protocol */
  uchar cksum[2]; /* Header checksum */
  uchar src[4];   /* IP source */
  uchar dst[4];   /* IP destination */
};
@



\chapter{IP Interface}

\section{Parsing}

<<function readipifc>>=
Ipifc*
readipifc(char *net, Ipifc *ifc, int index)
{
    int fd, i, n;
    Dir *dir;
    char directory[128];
    char buf[128];
    Ipifc **l;

    _freeifc(ifc);

    l = &ifc;
    ifc = nil;

    if(net == nil)
        net = "/net";
    snprint(directory, sizeof(directory), "%s/ipifc", net);

    if(index >= 0){
        snprint(buf, sizeof(buf), "%s/%d/status", directory, index);
        _readipifc(buf, l, index);
    } else {
        fd = open(directory, OREAD);
        if(fd < 0)
            return nil;
        n = dirreadall(fd, &dir);
        close(fd);

        for(i = 0; i < n; i++){
            if(strcmp(dir[i].name, "clone") == 0)
                continue;
            if(strcmp(dir[i].name, "stats") == 0)
                continue;
            snprint(buf, sizeof(buf), "%s/%s/status", directory, dir[i].name);
            l = _readipifc(buf, l, atoi(dir[i].name));
        }
        free(dir);
    }

    return ifc;
}
@


<<function _readipifc>>=
static Ipifc**
_readipifc(char *file, Ipifc **l, int index)
{
    int i, n, fd, lines;
    char buf[4*1024];
    char *line[32];
    char *f[64];
    Ipifc *ifc, **l0;
    Iplifc *lifc, **ll;

    /* read the file */
    fd = open(file, OREAD);
    if(fd < 0)
        return l;
    n = 0;
    while((i = read(fd, buf+n, sizeof(buf)-1-n)) > 0 && n < sizeof(buf) - 1)
        n += i;
    buf[n] = 0;
    close(fd);

    //if(strncmp(buf, "device", 6) != 0)
    //    return _readoldipifc(buf, l, index);

    /* ignore ifcs with no associated device */
    if(strncmp(buf+6, "  ", 2) == 0)
        return l;
    /* allocate new interface */
    *l = ifc = mallocz(sizeof(Ipifc), 1);
    if(ifc == nil)
        return l;
    l0 = l;
    l = &ifc->next;
    ifc->index = index;

    lines = getfields(buf, line, nelem(line), 1, "\n");

    /* pick off device specific info(first line) */
    n = tokenize(line[0], f, nelem(f));
    if(n%2 != 0)
        goto lose;
    strncpy(ifc->dev, findfield("device", f, n), sizeof(ifc->dev));
    ifc->dev[sizeof(ifc->dev)-1] = 0;
    if(ifc->dev[0] == 0){
lose:
        free(ifc);
        *l0 = nil;
        return l;
    }
    ifc->mtu          = strtoul(findfield("maxtu", f, n), nil, 10);
    ifc->sendra6      = atoi(findfield("sendra", f, n));
    ifc->recvra6      = atoi(findfield("recvra", f, n));
    ifc->rp.mflag     = atoi(findfield("mflag", f, n));
    ifc->rp.oflag     = atoi(findfield("oflag", f, n));
    ifc->rp.maxraint  = atoi(findfield("maxraint", f, n));
    ifc->rp.minraint  = atoi(findfield("minraint", f, n));
    ifc->rp.linkmtu   = atoi(findfield("linkmtu", f, n));
    ifc->rp.reachtime = atoi(findfield("reachtime", f, n));
    ifc->rp.rxmitra   = atoi(findfield("rxmitra", f, n));
    ifc->rp.ttl       = atoi(findfield("ttl", f, n));
    ifc->rp.routerlt  = atoi(findfield("routerlt", f, n));
    ifc->pktin        = strtoul(findfield("pktin", f, n), nil, 10);
    ifc->pktout       = strtoul(findfield("pktout", f, n), nil, 10);
    ifc->errin        = strtoul(findfield("errin", f, n), nil, 10);
    ifc->errout       = strtoul(findfield("errout", f, n), nil, 10);

    /* now read the addresses */
    ll = &ifc->lifc;
    for(i = 1; i < lines; i++){
        n = tokenize(line[i], f, nelem(f));
        if(n < 5)
            break;

        /* allocate new local address */
        *ll = lifc = mallocz(sizeof(Iplifc), 1);
        ll = &lifc->next;

        parseip(lifc->ip, f[0]);
        parseipmask(lifc->mask, f[1]);
        parseip(lifc->net, f[2]);

        lifc->validlt = strtoul(f[3], nil, 10);
        lifc->preflt = strtoul(f[4], nil, 10);
    }

    return l;
}
@


<<function _freeifc>>=
static void
_freeifc(Ipifc *ifc)
{
    Ipifc *next;
    Iplifc *lnext, *lifc;

    if(ifc == nil)
        return;
    for(; ifc; ifc = next){
        next = ifc->next;
        for(lifc = ifc->lifc; lifc; lifc = lnext){
            lnext = lifc->next;
            free(lifc);
        }
        free(ifc);
    }
}
@

<<function findfield>>=
static char*
findfield(char *name, char **f, int n)
{
    int i;

    for(i = 0; i < n-1; i++)
        if(strcmp(f[i], name) == 0)
            return f[i+1];
    return "";
}
@

%<<function _readoldipifc>>=
%static Ipifc**
%_readoldipifc(char *buf, Ipifc **l, int index)
%{
%    char *f[200];
%    int i, n;
%    Ipifc *ifc;
%    Iplifc *lifc, **ll;
%
%    /* allocate new interface */
%    *l = ifc = mallocz(sizeof(Ipifc), 1);
%    if(ifc == nil)
%        return l;
%    l = &ifc->next;
%    ifc->index = index;
%
%    n = tokenize(buf, f, nelem(f));
%    if(n < 2)
%        return l;
%
%    strncpy(ifc->dev, f[0], sizeof ifc->dev);
%    ifc->dev[sizeof(ifc->dev) - 1] = 0;
%    ifc->mtu = strtoul(f[1], nil, 10);
%
%    ll = &ifc->lifc;
%    for(i = 2; n-i >= 7; i += 7){
%        /* allocate new local address */
%        *ll = lifc = mallocz(sizeof(Iplifc), 1);
%        ll = &lifc->next;
%
%        parseip(lifc->ip, f[i]);
%        parseipmask(lifc->mask, f[i+1]);
%        parseip(lifc->net, f[i+2]);
%        ifc->pktin = strtoul(f[i+3], nil, 10);
%        ifc->pktout = strtoul(f[i+4], nil, 10);
%        ifc->errin = strtoul(f[i+5], nil, 10);
%        ifc->errout = strtoul(f[i+6], nil, 10);
%    }
%    return l;
%}
%@


\section{[[/net/x/ipifc]]}

<<function myipaddr>>=
/* find first ip addr that isn't the friggin loopback address
 * unless there are no others 
 */
int
myipaddr(uchar *ip, char *net)
{
    Ipifc *nifc;
    Iplifc *lifc;
    static Ipifc *ifc;
    uchar mynet[IPaddrlen];

    ifc = readipifc(net, ifc, -1);
    for(nifc = ifc; nifc; nifc = nifc->next)
        for(lifc = nifc->lifc; lifc; lifc = lifc->next){
            maskip(lifc->ip, loopbackmask, mynet);
            if(ipcmp(mynet, loopbacknet) == 0){
                continue;
            }
            if(ipcmp(lifc->ip, IPnoaddr) != 0){
                ipmove(ip, lifc->ip);
                return 0;
            }
        }
    ipmove(ip, IPnoaddr);
    return -1;
}
@

\chapter{Ethernet}

% ethernet = CSMA-CD (carrier sense multiple access - collision detection)
% with smart binary exponential backoff with random variation when have
% collision.

% ethernet address on top of (CS)MA.





%todo: mv later what is below?

<<global etherxx (kernel)>>=
static Ether *etherxx[MaxEther];
@
<<constant MaxEther>>=
MaxEther  = 48,
@

<<struct Ether (kernel)>>=
struct Ether {
  ISAConf;      /* hardware info */

  int ctlrno;
  int tbdf;     /* type+busno+devno+funcno */
  uchar ea[Eaddrlen];

  void  (*attach)(Ether*);  /* filled in by reset routine */
  void  (*detach)(Ether*);
  void  (*transmit)(Ether*);
  void  (*interrupt)(Ureg*, void*);
  long  (*ifstat)(Ether*, void*, long, ulong);
  long  (*ctl)(Ether*, void*, long); /* custom ctl messages */
  void  (*power)(Ether*, int);  /* power on/off */
  void  (*shutdown)(Ether*);  /* shutdown hardware before reboot */
  void  *ctlr;

  Queue*  oq;

  Netif;
};
@
% in 386 because ISAConf?


\section{Ethernet addresses}

\subsection{Parsing}

%ex: mac address f8:ed:a5:74:92:a1
% strtoul? uchar because ip are 4 integers between 0 and 255
<<function parseether>>=
errorneg1
parseether(uchar *to, char *from)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    for(i = 0; i < 6; i++){
        if(*p == '\0')
            return ERROR_NEG1;
        nip[0] = *p++;
        if(*p == '\0')
            return ERROR_NEG1;
        nip[1] = *p++;
        nip[2] = '\0';
        to[i] = strtoul(nip, 0, 16);
        if(*p == ':')
            p++;
    }
    return OK_0;
}
@

\subsection{[[/net/x/addr]]}

<<function myetheraddr>>=
errorneg1
myetheraddr(uchar *to, char *dev)
{
    int n, fd;
    char buf[256];

    if(*dev == '/')
        sprint(buf, "%s/addr", dev);
    else
        sprint(buf, "/net/%s/addr", dev);

    fd = open(buf, OREAD);
    if(fd < 0)
        return ERROR_NEG1;

    n = read(fd, buf, sizeof buf -1 );
    close(fd);
    if(n <= 0)
        return ERROR_NEG1;
    buf[n] = '\0';

    parseether(to, buf);
    return OK_0;
}
@

\section{Ethernet header}

<<struct Etherhdr>>=
struct Etherhdr
{
    uchar   d[6];
    uchar   s[6];
    uchar   t[2];
};
@
% ethermedium.c

\section{Ethernet packet}

<<struct Etherpkt>>=
struct Etherpkt
{
  uchar d[Eaddrlen];
  uchar s[Eaddrlen];
  uchar type[2];

  uchar data[1500];
};
@
% netif.h


\chapter{ARP}

<<[[Fs(kernel)]] arp fields>>=
Arp *arp;
@


<<struct Arp>>=
/*
 *  one per Fs
 */
struct Arp
{
    Arpent  *rxmt;
    Proc    *rxmitp;    /* neib sol re-transmit proc */

    Rendez  rxmtq;
    Block   *dropf, *dropl;

    Arpent  *hash[NHASH];
    Arpent  cache[NCACHE];

    // Extra
    QLock;
    <<[[Arp]] extra fields>>

};
@

<<[[Arp]] extra fields>>=
// ref<Fs>, reverse of Fs.arp
Fs  *f;
@


<<struct Arpent>>=
struct Arpent
{
  uchar ip[IPaddrlen];
  uchar mac[MAClen];

  Medium  *type;      /* media type */

  Block*  hold;
  Block*  last;
  uint  ctime;      /* time entry was created or refreshed */
  uint  utime;      /* time entry was last used */
  uchar state;
  Arpent  *nextrxt;   /* re-transmit chain */
  uint  rtime;      /* time for next retransmission */
  uchar rxtsrem;
  uchar ifcid;      /* must match ifc->id */

  // Extra
  Arpent* hash;
  Ipifc *ifc;
};
@


\section{[[/net/arp]]}

% See Qarp def in enum qid.

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qarp:
    p = "arp";
    prot = 0664;
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qarp:
    return arpread(f->arp, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qarp:
    return arpwrite(f, a, n);
@

<<[[ipopen()]] switch TYPE qid cases>>=
case Qarp:
case Qiproute:
    if(omode != OREAD && !iseve())
        error(Eperm);
    break;
@


\chapter{Routes}

\section{[[/net/ipselftab]]}

<<[[Qid]] toplevel extra cases>>=
Qipselftab,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qipselftab:
    p = "ipselftab";
    prot = 0444;
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qipselftab:
    return ipselftabread(f, a, offset, n);
@

\section{[[/net/iproutes]]}

% See Qiproute def in enum qid.

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qiproute:
    p = "iproute";
    prot = 0664;
    break;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qiproute:
    return routeread(f, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qiproute:
    return routewrite(f, ch, a, n);
@


\chapter{UDP}
% Unreliable, Unordered

<<struct Udphdr>>=
struct Udphdr
{
    uchar	raddr[IPaddrlen];	/* V6 remote address */
    uchar	laddr[IPaddrlen];	/* V6 local address */
    uchar	ifcaddr[IPaddrlen];	/* V6 ifc addr msg was received on */

    uchar	rport[2];		/* remote port */
    uchar	lport[2];		/* local port */
};
@



<<function udpinit>>=
void
udpinit(Fs *fs)
{
    Proto *udp;

    udp = smalloc(sizeof(Proto));
    udp->priv = smalloc(sizeof(Udppriv));

    udp->name = "udp";
    udp->connect = udpconnect;
    udp->announce = udpannounce;
    udp->ctl = udpctl;
    udp->state = udpstate;
    udp->create = udpcreate;
    udp->close = udpclose;
    udp->rcv = udpiput;
    udp->advise = udpadvise;
    udp->stats = udpstats;
    udp->ipproto = IP_UDPPROTO;
    udp->nc = Nchans;
    udp->ptclsize = sizeof(Udpcb);

    Fsproto(fs, udp);
}
@

<<struct Udp4hdr>>=
struct Udp4hdr
{
    /* ip header */
    uchar   vihl;       /* Version and header length */
    uchar   tos;        /* Type of service */
    uchar   length[2];  /* packet length */
    uchar   id[2];      /* Identification */
    uchar   frag[2];    /* Fragment information */
    uchar   Unused;
    uchar   udpproto;   /* Protocol */
    uchar   udpplen[2]; /* Header plus data length */
    uchar   udpsrc[IPv4addrlen];    /* Ip source */
    uchar   udpdst[IPv4addrlen];    /* Ip destination */

    /* udp header */
    uchar   udpsport[2];    /* Source port */
    uchar   udpdport[2];    /* Destination port */
    uchar   udplen[2];  /* data length */
    uchar   udpcksum[2];    /* Checksum */
};
@


\chapter{IL}

<<function ilinit>>=
void
ilinit(Fs *f)
{
    Proto *il;

    inittimescale();

    il = smalloc(sizeof(Proto));
    il->priv = smalloc(sizeof(Ilpriv));

    il->name = "il";
    il->connect = ilconnect;
    il->announce = ilannounce;
    il->state = ilstate;
    il->create = ilcreate;
    il->close = ilclose;
    il->rcv = iliput;
    il->ctl = nil;
    il->advise = iladvise;
    il->stats = ilxstats;
    il->inuse = ilinuse;
    il->gc = nil;
    il->ipproto = IP_ILPROTO;
    il->nc = scalednconv();
    il->ptclsize = sizeof(Ilcb);
    Fsproto(f, il);
}
@

<<enum _anon_ (kernel/network/ip/il.c)>>=
enum				/* Connection state */
{
    Ilclosed,
    Ilsyncer,
    Ilsyncee,
    Ilestablished,
    Illistening,
    Ilclosing,
    Ilopening,		/* only for file server */
};
@
% look nice, simple

<<global ilstates>>=
char	*ilstates[] = 
{ 
    "Closed",
    "Syncer",
    "Syncee",
    "Established",
    "Listen",
    "Closing",
    "Opening",		/* only for file server */
};
@


<<struct Ilhdr>>=
struct Ilhdr
{
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */
    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* Ip source */
    uchar	dst[4];		/* Ip destination */
    uchar	ilsum[2];	/* Checksum including header */
    uchar	illen[2];	/* Packet length */
    uchar	iltype;		/* Packet type */
    uchar	ilspec;		/* Special */
    uchar	ilsrc[2];	/* Src port */
    uchar	ildst[2];	/* Dst port */
    uchar	ilid[4];	/* Sequence id */
    uchar	ilack[4];	/* Acked sequence */
};
@



\chapter{TCP}

<<function tcpinit>>=
void
tcpinit(Fs *fs)
{
    Proto *tcp;
    Tcppriv *tpriv;

    tcp = smalloc(sizeof(Proto));
    tpriv = tcp->priv = smalloc(sizeof(Tcppriv));
    tcp->name = "tcp";
    tcp->connect = tcpconnect;
    tcp->announce = tcpannounce;
    tcp->ctl = tcpctl;
    tcp->state = tcpstate;
    tcp->create = tcpcreate;
    tcp->close = tcpclose;
    tcp->rcv = tcpiput;
    tcp->advise = tcpadvise;
    tcp->stats = tcpstats;
    tcp->inuse = tcpinuse;
    tcp->gc = tcpgc;
    tcp->ipproto = IP_TCPPROTO;
    tcp->nc = scalednconv();
    tcp->ptclsize = sizeof(Tcpctl);
    tpriv->stats[MaxConn] = tcp->nc;

    Fsproto(fs, tcp);
}
@

\chapter{9P}

\chapter{RPC}

\chapter{Network File System}
% the logical conclusion for all of that.


% con and exportfs
% NFS like?

\chapter{Security}

\section{Denial of service}
% hogport? in tcp? tcpporthogdefense

\chapter{Debugging Support}
% the stats? to see the packet loss?

% snoopy? 

\chapter{Profiling Support}
% the stats? to see the packet loss?

\chapter{Advanced Topics}

\section{IPv6}

\section{Network database, [[ndb]]}

<<[[Fs(kernel)]] ndb fields>>=
char  ndb[1024];    /* an ndb entry for this interface */
int ndbvers;
long  ndbmtime;
@

\subsection{[[/net/ndb]]}

<<[[Qid]] toplevel extra cases>>=
Qndb,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qndb:
    p = "ndb";
    len = strlen(f->ndb);
    q.vers = f->ndbvers;
    break;
@
<<[[ipgen()]] if Qndb, adjust mtime>>=
if(i == Qndb && f->ndbmtime > kerndate)
    dp->mtime = f->ndbmtime;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qndb:
    if(omode & (OWRITE|OTRUNC) && !iseve())
        error(Eperm);
    if((omode & (OWRITE|OTRUNC)) == (OWRITE|OTRUNC))
        f->ndb[0] = 0;
    break;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qndb:
    return readstr(offset, a, n, f->ndb);
@

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qndb:
    return ndbwrite(f, a, offset, n);
    break;
@


\section{Connection Server}
% abstract away different address schemes

\section{Packet filter}
% /net/ipmux

\section{Sniffing}

% promiscuous mode for ethernet, get all packets even those
% which don't have your MAC as a recipient

\section{Loopback medium}

% echo 'bind loopback' > /net/ipifc/x/ctl

<<global loopbackmedium>>=
Medium loopbackmedium =
{
    .name=      "loopback",

    .hsize=     0,
    .mintu=     0,
    .maxtu=     Maxtu,
    .maclen=    0,

    .bind=      loopbackbind,
    .unbind=    loopbackunbind,
    .bwrite=    loopbackbwrite,
};
@
% maclen 0 ?? no header?

<<enum _anon_ (kernel/network/ip/loopbackmedium.c)>>=
enum
{
    Maxtu=  16*1024,
};
@

<<function loopbackmediumlink>>=
void
loopbackmediumlink(void)
{
    addipmedium(&loopbackmedium);
}
@

% private Ipifc data, ifc->arg
<<struct LB>>=
struct LB
{
    Queue   *q;
    Fs  *f;
    Proc    *readp;
};
@

<<function loopbackbind>>=
static void
loopbackbind(Ipifc *ifc, int, char**)
{
    LB *lb;

    lb = smalloc(sizeof(LB));
    lb->f = ifc->conv->p->f;
    lb->q = qopen(1024*1024, Qmsg, nil, nil);
    ifc->arg = lb;
    ifc->mbps = 1000;

    kproc("loopbackread", loopbackread, ifc);

}
@


<<function loopbackunbind>>=
static void
loopbackunbind(Ipifc *ifc)
{
    LB *lb = ifc->arg;

    if(lb->readp)
        postnote(lb->readp, 1, "unbind", 0);

    /* wait for reader to die */
    while(lb->readp != nil)
        tsleep(&up->sleepr, returnfalse, 0, 300);

    /* clean up */
    qfree(lb->q);
    free(lb);
}
@

% a kproc
<<function loopbackread>>=
static void
loopbackread(void *a)
{
    Ipifc *ifc;
    Block *bp;
    LB *lb;

    ifc = a;
    lb = ifc->arg;
    lb->readp = up; /* hide identity under a rock for unbind */
    if(waserror()){
        lb->readp = 0;
        pexit("hangup", 1);
    }
    for(;;){
        bp = qbread(lb->q, Maxtu);
        if(bp == nil)
            continue;
        ifc->in++;
        if(!canrlock(ifc)){
            freeb(bp);
            continue;
        }
        if(waserror()){
            runlock(ifc);
            nexterror();
        }
        if(ifc->lifc == nil)
            freeb(bp);
        else
            ipiput4(lb->f, ifc, bp);
        runlock(ifc);
        poperror();
    }
}
@
% ipiput4!


<<function loopbackbwrite>>=
static void
loopbackbwrite(Ipifc *ifc, Block *bp, int, uchar*)
{
    LB *lb;

    lb = ifc->arg;
    if(qpass(lb->q, bp) < 0)
        ifc->outerr++;
    ifc->out++;
}
@

\section{Multicast}

<<[[Medium(kernel)]] multicast methods>>=
/* for arming interfaces to receive multicast */
void  (*addmulti)(Ipifc *ifc, uchar *a, uchar *ia);
void  (*remmulti)(Ipifc *ifc, uchar *a, uchar *ia);

/* for routing multicast groups */
void  (*joinmulti)(Ipifc *ifc, uchar *a, uchar *ia);
void  (*leavemulti)(Ipifc *ifc, uchar *a, uchar *ia);
@

<<[[Conv(kernel)]] multicast fields>>=
Ipmulti *multi;     /* multicast bindings for this interface */
@

<<[[Netif(kernel)]] multicast fields>>=
Netaddr *maddr;     /* known multicast addresses */
int nmaddr;     /* number of known multicast addresses */
Netaddr *mhash[Nmhash];   /* hash table of multicast addresses */
@

<<[[Netif(kernel)]] multicast methods>>=
void  (*multicast)(void*, uchar*, int);
@

\section{Bootp}

\subsection{[[/net/bootp]]}

<<[[Qid]] toplevel extra cases>>=
Qbootp,
@
<<[[ip1gen()]] switch TYPE qid cases>>=
case Qbootp:
    p = "bootp";
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qbootp:
    return bootpread(a, offset, n);
@


\chapter{Conclusion}

\appendix

\chapter{Debugging}

\section{Dumpers}

\subsection{Addresses}
% or masks

<<function eipfmt>>=
int
eipfmt(Fmt *f)
{
    char buf[5*8];
    static char *efmt = "%.2ux%.2ux%.2ux%.2ux%.2ux%.2ux"; // ethernet
    static char *ifmt = "%d.%d.%d.%d"; // internet, v4
    uchar *p;
    uchar ip[16];
    ulong *lp;
    ushort s;
    int i, j, n, eln, eli;

    switch(f->r) {
    case 'E':		/* Ethernet address */
        p = va_arg(f->args, uchar*);
        snprint(buf, sizeof buf, efmt, p[0], p[1], p[2], p[3], p[4], p[5]);
        return fmtstrcpy(f, buf);

    case 'I':		/* Ip address */
        p = va_arg(f->args, uchar*);
common:
        if(memcmp(p, v4prefix, 12) == 0){
            snprint(buf, sizeof buf, ifmt, p[12], p[13], p[14], p[15]);
            return fmtstrcpy(f, buf);
        }

        /* find longest elision */
        eln = eli = -1;
        for(i = 0; i < 16; i += 2){
            for(j = i; j < 16; j += 2)
                if(p[j] != 0 || p[j+1] != 0)
                    break;
            if(j > i && j - i > eln){
                eli = i;
                eln = j - i;
            }
        }

        /* print with possible elision */
        n = 0;
        for(i = 0; i < 16; i += 2){
            if(i == eli){
                n += sprint(buf+n, "::");
                i += eln;
                if(i >= 16)
                    break;
            } else if(i != 0)
                n += sprint(buf+n, ":");
            s = (p[i]<<8) + p[i+1];
            n += sprint(buf+n, "%ux", s);
        }
        return fmtstrcpy(f, buf);

    case 'i':		/* v6 address as 4 longs */
        lp = va_arg(f->args, ulong*);
        for(i = 0; i < 4; i++)
            hnputl(ip+4*i, *lp++);
        p = ip;
        goto common;

    case 'V':		/* v4 ip address */
        p = va_arg(f->args, uchar*);
        snprint(buf, sizeof buf, ifmt, p[0], p[1], p[2], p[3]);
        return fmtstrcpy(f, buf);

    case 'M':		/* ip mask */
        p = va_arg(f->args, uchar*);

        /* look for a prefix mask */
        for(i = 0; i < 16; i++)
            if(p[i] != 0xff)
                break;
        if(i < 16){
            if((prefixvals[p[i]] & Isprefix) == 0)
                goto common;
            for(j = i+1; j < 16; j++)
                if(p[j] != 0)
                    goto common;
            n = 8*i + (prefixvals[p[i]] & ~Isprefix);
        } else
            n = 8*16;

        /* got one, use /xx format */
        snprint(buf, sizeof buf, "/%d", n);
        return fmtstrcpy(f, buf);
    }
    return fmtstrcpy(f, "(eipfmt)");
}
@

\subsection{IP interface}

<<function main>>=
void
main(void)
{
    Ipifc *ifc, *list;
    Iplifc *lifc;
    int i;

    fmtinstall('I', eipfmt);
    fmtinstall('M', eipfmt);

    list = readipifc("/net", nil, -1);
    for(ifc = list; ifc; ifc = ifc->next){
        print("ipifc %s %d\n", ifc->dev, ifc->mtu);
        for(lifc = ifc->lifc; lifc; lifc = lifc->next)
            print("\t%I %M %I\n", lifc->ip, lifc->mask, lifc->net);
    }
}
@

\section{[[/net/log]]}

<<[[Fs(kernel)]] logging fields>>=
Netlog  *alog;
@

<<enum _anon_ (kernel/network/ip/netlog.c)>>=
enum {
    Nlog        = 16*1024,
};
@

<<struct Netlog>>=
/*
 *  action log
 */
struct Netlog {
    Lock;
    int opens;
    char*   buf;
    char    *end;
    char    *rptr;
    int len;

    int logmask;            /* mask of things to debug */
    uchar   iponly[IPaddrlen];      /* ip address to print debugging for */
    int iponlyset;

    QLock;
    Rendez;
};
@



% ipattach -> ... -> <>
<<function netloginit>>=
void
netloginit(Fs *f)
{
    f->alog = smalloc(sizeof(Netlog));
}
@

<<[[Qid]] toplevel extra cases>>=
Qlog,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qlog:
    p = "log";
    break;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qlog:
    netlogopen(f);
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qlog:
    return netlogread(f, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qlog:
    netlogctl(f, a, n);
    return n;
@


<<function netlogopen>>=
void
netlogopen(Fs *f)
{
    lock(f->alog);
    if(waserror()){
        unlock(f->alog);
        nexterror();
    }
    if(f->alog->opens == 0){
        if(f->alog->buf == nil)
            f->alog->buf = malloc(Nlog);
        if(f->alog->buf == nil)
            error(Enomem);
        f->alog->rptr = f->alog->buf;
        f->alog->end = f->alog->buf + Nlog;
    }
    f->alog->opens++;
    unlock(f->alog);
    poperror();
}
@


<<function netlogread>>=
long
netlogread(Fs *f, void *a, ulong, long n)
{
    int i, d;
    char *p, *rptr;

    qlock(f->alog);
    if(waserror()){
        qunlock(f->alog);
        nexterror();
    }

    for(;;){
        lock(f->alog);
        if(f->alog->len){
            if(n > f->alog->len)
                n = f->alog->len;
            d = 0;
            rptr = f->alog->rptr;
            f->alog->rptr += n;
            if(f->alog->rptr >= f->alog->end){
                d = f->alog->rptr - f->alog->end;
                f->alog->rptr = f->alog->buf + d;
            }
            f->alog->len -= n;
            unlock(f->alog);

            i = n-d;
            p = a;
            memmove(p, rptr, i);
            memmove(p+i, f->alog->buf, d);
            break;
        }
        else
            unlock(f->alog);

        sleep(f->alog, netlogready, f);
    }

    qunlock(f->alog);
    poperror();

    return n;
}
@


<<function netlogctl>>=
void
netlogctl(Fs *f, char* s, int n)
{
    int i, set;
    Netlogflag *fp;
    Cmdbuf *cb;
    Cmdtab *ct;

    cb = parsecmd(s, n);
    if(waserror()){
        free(cb);
        nexterror();
    }

    if(cb->nf < 2)
        error(Ebadnetctl);

    ct = lookupcmd(cb, routecmd, nelem(routecmd));

    SET(set);

    switch(ct->index){
    case CMset:
        set = 1;
        break;

    case CMclear:
        set = 0;
        break;

    case CMonly:
        parseip(f->alog->iponly, cb->f[1]);
        if(ipcmp(f->alog->iponly, IPnoaddr) == 0)
            f->alog->iponlyset = 0;
        else
            f->alog->iponlyset = 1;
        free(cb);
        poperror();
        return;

    default:
        cmderror(cb, "unknown netlog control message");
    }

    for(i = 1; i < cb->nf; i++){
        for(fp = flags; fp->name; fp++)
            if(strcmp(fp->name, cb->f[i]) == 0)
                break;
        if(fp->name == nil)
            continue;
        if(set)
            f->alog->logmask |= fp->mask;
        else
            f->alog->logmask &= ~fp->mask;
    }

    free(cb);
    poperror();
}
@

\section{[[/bin/snoopy]]}
% useful only to debug network stack? or could be considered
% a Debugging Support chapter?

\subsection{/net/ipifc/x/snoop}

<<[[Qid]] conversation extra cases>>=
Qsnoop,
@

<<[[Conv(kernel)]] snoop fields>>=
Ref snoopers;   /* number of processes with snoop open */
Queue*  sq;     /* snooping queue */
@
% those fields are valid only for /net/ipifc/x/snoop?


<<[[ip3gen()]] switch TYPE qid cases>>=
case Qsnoop:
    if(strcmp(cv->p->name, "ipifc") != 0)
        return -1;
    devdir(c, q, "snoop", qlen(cv->sq), cv->owner, 0400, dp);
    return 1;
@
% size = stop queue?

<<[[ipread()]] switch TYPE qid cases>>=
case Qsnoop:
    c = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(c->sq, a, n);
@


<<[[ipopen()]] switch TYPE qid cases>>=
case Qsnoop:
    if(omode != OREAD)
        error(Eperm);
    p = f->p[PROTO(c->qid)];
    cv = p->conv[CONV(c->qid)];
    if(strcmp(ATTACHER(c), cv->owner) != 0 && !iseve())
        error(Eperm);
    incref(&cv->snoopers);
    break;
@




\subsection{[[/bin/snoopy]]}


<<function printusage>>=
void
printusage(void)
{
    fprint(2, "usage: %s [-CDdpst] [-N n] [-f filter] [-h first-header] path\n", argv0);
    fprint(2, "  for protocol help: %s -? [proto]\n", argv0);
}
@

<<function usage (networking/ip/snoopy/main.c)>>=
void
usage(void)
{
    printusage();
    exits("usage");
}
@


\section{[[/net/x/stats]]}

% /net/ipifc/stats
% /net/icmp/stats
% /net/tcp/stats

\chapter{Profiling}

% /net/x/stats? hmm it's more for user than for programmer of the
% network stack itself, but yes it can be useful too.

\chapter{Error Managment}

\chapter{Ethernet Intel Pro/1000 Driver}

\chapter{Libc}

\section{Globbing}

% a few things have a format accepting "*"

\chapter{Other Medium}

\section{Null medium}

<<global nullmedium>>=
Medium nullmedium =
{
    .name=      "null",

    .bind=      nullbind,
    .unbind=    nullunbind,
    .bwrite=    nullbwrite,
};
@

<<function nullbind>>=
static void
nullbind(Ipifc*, int, char**)
{
    error("cannot bind null device");
}
@

<<function nullunbind>>=
static void
nullunbind(Ipifc*)
{
}
@

<<function nullbwrite>>=
static void
nullbwrite(Ipifc*, Block*, int, uchar*)
{
    error("nullbwrite");
}
@

<<function nullmediumlink>>=
void
nullmediumlink(void)
{
    addipmedium(&nullmedium);
}
@

\section{Point to point serial line}

\section{Token ring}
% alternative to ethernet


\chapter{Other Protocols}

\section{ICMP}
% for ping

\section{RUDP}

\section{GRE}

\section{ESP}

\section{Datakit and URP}


\chapter{Extra Code}

\ifallcode
#include "Network_extra.nw"
#include "Network_v6.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

