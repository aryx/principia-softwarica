\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - untangled all those features, routing, gateway, forwarding, multicast, 
%    broadcast, with those big structures that were hard to understand.
% - use cv not c for conversation, less confusing with channel, use err
%   not p, use err not s, ...
% - use Idle, not 0 when can, use V4 not 4,
% - removed deadcode: /net/bootp,  Ipifc fields (unbinding, idlock, ...),
%   Conv (length, car, headers, reliable, ...), Proto (qid)
% - TODO introduce ipv4, ipaddr typedefs?

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand networking:
% - TODO ether, ip, udp, tcp, actually I didn't know 
%   that much about network
% - realize that having two ip interfaces is essential, not a feature, because
%   for internetworking to work you need gateways that connect two separate
%   networks, and so this machine will have two interfaces
% - TODO does not need much to configure initially; can do things manually
%   without ipconfig and actually you need to do very few things
% - TODO ping, I never understood how it worked (but does not work under qemu)
% - TODO ppp?


%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - SEMI  understand main(), LP split main, improve TOC
% - SEMI  understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for ?

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Network Stack [[/net/]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Dave Presotto and Phil Winterbottom\\
% more?
}


\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a network stack.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item XINU
\item Linux
\item FreeBSD
% FreeBSD have strong reputation regarding its network stack
\item Minix
\end{itemize}

%meh:
%http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/

\section{Getting started}


\section{Requirements}

% Tannenbaum computer networks book?
% Computer networks, a top-down approach?
% tcp/ip ...?
%ref: "packet communication" from the same collection that lion's book
%Intro to computer networks (free, but maybe not that good)
%   http://intronetworks.cs.luc.edu/

% "The organization of networks in plan9".ps
% il.ps
% ip(8?)

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Network principles}

% local (mac) address, ethernet, local area network
%  write to all, snoop and take when for your (mac) address
% old: ipx?

% Frame.
% packets! and actually whole idea of network abstraction is to
% provide what seems like an arbitrary length or even continuous stream
% of data on top of this fixed packet. A bit similar to file and fs
% which are on top of disk blocks.

% need packets for ethernet as you write to everybody on the "backbone",
% and need fairness.


\section{Internetworking principles}

% ip universal address, inter network, routing, gateway, multiple interfaces
% (packets become really useful there because big sharing).
% gateways are really important, and so is having multiple IPs.

% general datagram and specific fragments, 
% to abstract away from particular physical link constraints.

% tcp: because route can be complex, and can use different routes,
% so can arrive in different order, so need protocol, ack, retransmit,
% reorder, etc. Tricky.

\section{Network stack principles}

% ip stack goal is to multiplex access to network device?
% and then to demultiplex when receive (by address, by protocol)
% and to provide different encoding protocols providing different
% kinds of services.

% A bit similar to memory, where have physical memory but abstracted
% away with virtual memory. In the same way with network have
% physical address and local area network but build on top of that
% virtual address and a virtual global network.

\section{[[/net]] services}

% In plan9 every kernel service is implemented as a file server.
% Everything is a file. So a connexion to a remote machine is
% a file in plan9 (in unix it's a socket, which is a kind of file,
% it has a fd, and can even be on the fs sometimes).
% In unix configure the file/socket via ioctl. In plan9 it's
% via the fs and via a control file. /net/<proto>/<conv>/ctl

% see 'network plan9'.ps

% /net/ether0/addr
% /net/ipfc/clone and then /net/ipfc/x/ctl
% /net/arp
% /net/iproute

% maybe can put early the 
%    echo 'bind ether /net/ether0' > /net/ipifc/x/ctl
% and then 
%    echo 'add 10.0.0.15' > /net/ipifc/x/ctl
% enough? need also to write arp no? and a few routes?

% ether0 means first ethernet controller, like in linux ifcfg0

% see http://wiki.qemu.org/Documentation/Networking
% for the configuration when running plan9 under qemu,
% ip = 10.0.2.15, gw = 10.0.2.2, dns = 10.0.2.3
% note that ping will not work under qemu! but tcp/udp will.


% /net/<proto>/<conv>/ for the most part.

%todo: then how initiate connexion manually? using just the shell!
% echo 'connect ???' > /net/udp/clone ? then cat /net/udp/x/data ?
% and somewhere echo in udp?
% can emulate named pipe?

% then when have a gateway, will have 2 ifc, 2 mediums, 2 ips


%note: The network ip stack is served as a file server in plan9, and
% so it can be mounted too on another machine. But what's the point?
% If can mount it on another machine that means that machine has
% a network capacity, so why it would need another ip stack? Because
% for configuration purpose? can have a workstation with basic network
% and then import another ip stack that has a more complex configuration!

\section{[[ping]], [[traceroute]], etc}

\section{Code organization}

% include/ip.h
% lib_networking/libip/
% kernel/network/, devip, devether, udp.c, tpc.c, and ether2000.c, etherigbe.c
% networking/...

\section{Software architecture}

% physical (e.g. ethernet), kernel (devip+ether), lib(dial), apps (e.g. telnetd)
% and on the other side
% physical (e.g. ethernet), kernel (devip+ether), lib(listen), apps (e.g. telnet)

% client/server but in the end really something reading from a file
% and something writing to the file. In essence network comm is
% like reading/writing to a file, except the file represent a connection
% to somewhere else, not a local file.

% link-layer: ethernet, (arp, ... aoe)
% network-layer: ip (routing, icmp?)
% transport-layer: (udp, tcp, il, ... )
% "applications" protocol (dhcp, dns, telnetd, http, imap, ...)
% actual applications (telnet, ping, ftp, ...)

% encapsulation each time, more headers each time.

% packet (network) vs frame (ethernet) vs datagram and fragments (ip) 
% vs continuous stream (user)

% Proto vs Fs vs Ipifc vs Netif

% OO like interface, with class and methods, and some private
% fields.

% f = /net fs
% cv = conversation
% c = channel (TODO or conversation sometimes, but we should rename them)
% p = protocol (TODO or err sometimes, but we should rename them)
% err = error string

\section{Trace of a ping}

\section{Trace of a network write}

\section{Trace of a network read}

%\section{Trace of an RPC}

%###############################################################################

\chapter{Core Data Structures}

\section{Universal identifier, IP addresses}
% machine identifier

% universal 
%note: (later in HTTP section we will see URL, even more general)
% inter-network

%less: typedef uchar ippart ? 
% typedef uchar[16] ip? typedef uchar[4] ipv4
% cast automatically to uchar* ?

<<constant IPv4addrlen>>=
IPv4addrlen=	4,
@
% this will be used for the IP address in the actual header and frame formats


<<constant IPaddrlen>>=
IPaddrlen=	16,
@
% this is used internally to store addresses, to be the more general.
% 16 bytes IP(v6) address
% ex of address? facebook address? 2a03:2880:2110:df07:face:b00c:0:1:


\subsection{IPv4 vs IPv6}

<<global v4prefix>>=
/*
 *  prefix of all v4 addresses
 */
uchar v4prefix[IPaddrlen] = {
    // first 12
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,

    // rest are ipv4 numbers
    0, 0, 0, 0
};
@

<<constant IPv4off>>=
IPv4off=	12,
@

<<function isv4>>=
bool
isv4(uchar *ip)
{
    return memcmp(ip, v4prefix, IPv4off) == 0;
}
@
% first 12 must be identical to v4prefix

<<function v4tov6>>=
/*
 *  the following routines are unrolled with no memset's to speed
 *  up the usual case
 */
void
v4tov6(uchar *v6, uchar *v4)
{
    v6[0] = 0; v6[1] = 0; v6[2] = 0; v6[3] = 0;
    v6[4] = 0; v6[5] = 0; v6[6] = 0; v6[7] = 0;
    v6[8] = 0; v6[9] = 0; v6[10] = 0xff; v6[11] = 0xff;

    v6[12] = v4[0];
    v6[13] = v4[1];
    v6[14] = v4[2];
    v6[15] = v4[3];
}
@

<<function v6tov4>>=
errorneg1
v6tov4(uchar *v4, uchar *v6)
{
    if(v6[0] == 0 && v6[1] == 0 && v6[2] == 0 && v6[3] == 0
    && v6[4] == 0 && v6[5] == 0 && v6[6] == 0 && v6[7] == 0
    && v6[8] == 0 && v6[9] == 0 && v6[10] == 0xff && v6[11] == 0xff)
    {
        v4[0] = v6[12];
        v4[1] = v6[13];
        v4[2] = v6[14];
        v4[3] = v6[15];
        return OK_0;
    }
    <<[[v6tov4()]] else if ipv6 address>>
}
@
% used in code setting up the header, by passing the
% pointer to the address in the header as first argument
% and the cv->laddr or cv->raddr as second argument.

\subsection{Network class and network identifier}

% "conceptually an internet address is a pair (netid, hostid)
% where netid identifies a network, and hostid identifies a host
% on that network" xinu book

% tricky encoding, ip address can refer to network, convention
% to never use 0, so 10.0.2.0 means the network

<<macro CLASS>>=
#define CLASS(p) ((*(uchar*)(p))>>6)
@
% ?? first 2 bits of first number in IP?

\subsection{Network mask}

% return ipv6
<<function defmask>>=
uchar*
defmask(uchar *ip)
{
    if(isv4(ip))
        return classmask[ip[IPv4off]>>6];
    <<[[defmask()]] if ipv6>>
}
@
%less: why not use CLASS? instead of >>6 above?

<<global classmask>>=
static uchar classmask[4][16] = {
    // class A
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0x00,0x00,0x00, // 255.0.0.0
    // class A
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0x00,0x00,0x00, // 255.0.0.0
    // class B
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0xff,0x00,0x00, // 255.255.0.0
    // class C
    0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  0xff,0xff,0xff,0xff,  
    0xff,0xff,0xff,0x00, // 255.255.255.0
};
@
% class use 2 bits, so 4 entries, (but 00 and 01 are for class A)
% 255.255.etc
% use IPADDRLen instead of 16?
%less: could do nested { }, [0] = { }, [1] = { } ...


<<function maskip>>=
void
maskip(uchar *from, uchar *mask, uchar *to)
{
    int i;

    for(i = 0; i < IPaddrlen; i++)
        to[i] = from[i] & mask[i];
}
@

% netid = ip & mask.

\subsection{Network byte order}
% not only related to IP address, but don't know where
% to put this section and can be opportunity to define ip_long;
% that will be used later for the Route DS.

% nhxxx network to host, hn host to network

% ulong vs uchar[4]
%todo: another typedef?   iph;  ip_ulong;  

\subsection{Other address operations}
%reset, move, comparison

% used a lot to reset an address
<<global IPnoaddr>>=
uchar IPnoaddr[IPaddrlen];
@
<<macro ipmove (kernel/network/ip/ip.h)>>=
#define ipmove(x, y) memmove(x, y, IPaddrlen)
@
%    ipmove(cv->laddr, IPnoaddr);

<<macro ipcmp (kernel/network/ip/ip.h)>>=
#define ipcmp(x, y) ( (x)[IPaddrlen-1] != (y)[IPaddrlen-1] || memcmp(x, y, IPaddrlen) )
@
% first part is opti? fastest path is last elt of address is different?




%\subsection{Forme} ?
% ipforme()?

\section{IP Interfaces, [[Ipifc]]}
% 's', for gateways

% /net/ipifc/...

% this will associate an IP (logical address) to a 
% physical device (physical address)


\subsection{User side}

% how used by programmer? readipifc()?
% hmm but not that useful in practice no? or because dial uses that?
% Need that to know who you are ... like hostname?

% in include/ip.h
<<struct Ipifc (user)>>=
/* actual interface */
struct Ipifc
{
    /* per ip interface */

    char	dev[64]; // e.g. "/net/ether0"
    int	mtu;
    // list<ref_own<Iplifc> (next = Iplifc.next)
    Iplifc	*lifc;

    <<[[Ipifc(user)]] stat fields>>
    <<[[Ipifc(user)]] ipv6 fields>>

    //Extra
    <<[[Ipifc(user)]] extra fields>>
};
@
% echo 'bind ether /net/ether0' > /net/ipifc/x/ctl
% what is inside dev[64]? /net/ether0
% mtu of physical connected network device

<<[[Ipifc(user)]] stat fields>>=
ulong	pktin;
ulong	pktout;
ulong	errin;
ulong	errout;
@


<<[[Ipifc(user)]] extra fields>>=
Ipifc	*next;
@
% readipifc can return the list of all interfaces.
% We will need this for gateways which have multiple interfaces, multiple IPs
% connecting two separate networks.

<<[[Ipifc(user)]] extra fields>>=
int	index;			/* number of interface in ipifc dir */
@


% local or logical
<<struct Iplifc (user)>>=
/* local address */
struct Iplifc
{
    /* per address on the ip interface */
    uchar	ip[IPaddrlen];
    uchar	mask[IPaddrlen];
    uchar	net[IPaddrlen];		/* ip & mask */

    <<[[Iplifc(user)]] ipv6 fields>>

    // Extra
    <<[[Iplifc(user)]] extra fields>>
};
@
% finally an IP! our IP
% echo 'add <localip>' > /net/ipicf/x/ctl

%less: can have multiple IP connected to same device? what for?
<<[[Iplifc(user)]] extra fields>>=
// list<ref_own<Iplifc>>, head = Ipifc.lifc
Iplifc	*next;
@


\subsection{Kernel side}

%todo: who points to that in the kernel? actually there is no single
% ipifc global in the kernel because a machine can have multiple ips
% (e.g. a gateway), and so the user access the one he wants via
% /net/ipifc/ and the ipifc is part of a route.
% in Route there is a Ipifc! returned via v4lookup()
%todo: OK but when go to /net/tcp/clone, get which interface??

% in fact gateways are essential to the internet, they are the one
% that makes possible to have intern-networking, so having
% multiple interface and multiple IPs is not a nice feature to have,
% it's essential. One can't provide a network stack without support
% for gateways.

<<struct Ipifc (kernel)>>=
struct Ipifc
{
  char  dev[64];  /* device we're attached to */

  Medium  *m;   /* Media pointer */
  uchar mac[MAClen];  /* MAC address */
  void  *arg;   /* medium specific */

  int maxtu;    /* Maximum transfer unit */
  int mintu;    /* Minumum tranfer unit */
  int mbps;   /* megabits per second */

  // list<ref_own<Iplifc>>, next = Iplifc.next
  Iplifc  *lifc;    /* logical interfaces on this physical one */

  <<[[Ipifc(kernel)]] stat fields>>
  <<[[Ipifc(kernel)]] routing fields>>

  <<[[Ipifc(kernel)]] other fields>>
  <<[[Ipifc(kernel)]] ipv6 fields>>

  //Extra
  RWlock;

};
@
%less: have a priv field for medium arg private pointer?


<<[[Ipifc(kernel)]] stat fields>>=
/* message statistics */
ulong in;
ulong out;  
ulong inerr;
ulong outerr;
@

<<[[Ipifc(kernel)]] other fields>>=
Conv  *conv;    /* link to its conversation structure */
@
% /net/ipfc/x/...
% will see later, but in ipifcadd can then do  f = ifc->conv->p->f;



%dead: 
% <<[[Ipifc(kernel)]] other fields>>=
% bool unbinding;
%/* these are used so that we can unbind on the fly */
% Lock  idlock;
% int ref;    /* number of proc's using this ipifc */
% Rendez  wait;   /* where unbinder waits for ref == 0 */







<<struct Iplifc (kernel)>>=
/* logical interface associated with a physical one */
struct Iplifc
{
  uchar local[IPaddrlen];
  uchar mask[IPaddrlen];
  uchar net[IPaddrlen]; // local & mask?

  uchar remote[IPaddrlen]; // ??

  <<[[Iplifc(kernel)]] ipv6 fields>>

  // Extra
  <<[[Iplifc(kernel)]] extra fields>>
};
@
% local = ip?
% remote?? rename to gateway?

<<[[Iplifc(kernel)]] extra fields>>=
// list<ref_own<Iplifc>>, head = Ipifc.lifc
Iplifc  *next;
@





\section{Physical link}

% e.g. for ethernet
% see later: null, loopback, packet


\subsection{[[Medium]]}
% general interface

% see that it's pointed by Ipifc above

<<struct Medium (kernel)>>=
struct Medium
{
  char  *name;

  int hsize;    /* medium header size */
  int maclen;   /* mac address length  */

  int mintu;    /* default min mtu */
  int maxtu;    /* default max mtu */

  <<[[Medium(kernel)]] methods>>

  <<[[Medium(kernel)]] other fields>>

};
@

<<[[Medium(kernel)]] methods>>=
<<[[Medium(kernel)]] binding methods>>
<<[[Medium(kernel)]] io methods>>
<<[[Medium(kernel)]] address resolution methods>>
<<[[Medium(kernel)]] route methods>>
<<[[Medium(kernel)]] multicast methods>>

<<[[Medium(kernel)]] ipv6 methods>>
@

%% ipwrite (Ctl case) -> bindctlmsg -> ipifcbind -> <>  (for bind)
%     (as m->bind <- ipfindmedium <- media[i] <- ???)
<<[[Medium(kernel)]] binding methods>>=
void  (*bind)(Ipifc*, int, char**);
void  (*unbind)(Ipifc*);
@
% char**? array of string? to pass parameters to bind? e.g. path
% in 'bind ether /net/ether0' ?
% this will call findipmedium that will explore for instance
% all medium and media, and ethernetmedium which in turn
% will explore all ethernet controllers in etherxx.

<<[[Medium(kernel)]] io methods>>=
// write packets on the physical network
void  (*bwrite)(Ipifc *ifc, Block *b, int version, uchar *ip);
@

%bwrite!! that's where you write the data! note that pass just ip,
% no port here, we are at IP layer. Has to be scheduled as can have
% many processes wanting to write to the medium

%XXX
<<[[Medium(kernel)]] io methods>>=
/* process packets written to 'data' */
void  (*pktin)(Fs *f, Ipifc *ifc, Block *bp);
@
%pktin!! that's where you read packets from the network, which has to
% be routed to the right place, how?? Has to be decomposed and dispatched
% so need a global map of ip+port info.
% I don't think so, it's when someone write to /net/ipifc/x/data
% which I don't know what it means



\subsection{[[media]]}

<<global media>>=
Medium *media[Maxmedia] = { 0 };
@
<<constant Maxmedia>>=
Maxmedia    = 32,
@

% ?? -> <>  ? qemu.c links() and ethermediumlink?
<<function addipmedium>>=
/*
 *  link in a new medium
 */
void
addipmedium(Medium *med)
{
    int i;

    for(i = 0; i < nelem(media)-1; i++)
        if(media[i] == nil){
            media[i] = med;
            break;
        }
}
@
% no warning if overflow?
%less: boilerplate code, should have a generic function for that


\subsection{Ethernet medium}

% before IP? kinda more low level (but less general)

% there are other physical device/medium, but we'll focus on this one,
% most common

<<constant Eaddrlen>>=
Eaddrlen= 6,
@
% physical 48bits address.

% will be added to media[] in?
<<global ethermedium (kernel)>>=
Medium ethermedium =
{
    .name=      "ether",

    .hsize=     14,
    .mintu=     60,
    .maxtu=     1514,
    .maclen=    6,

    .bind=      etherbind,
    .unbind=    etherunbind,

    .bwrite=    etherbwrite,

    .ares=      arpenter,
    .areg=      sendgarp,

    .addmulti=  etheraddmulti,
    .remmulti=  etherremmulti,

    .pref2addr= etherpref2addr,
};
@
% maxtu = 1500 + 14 for header
% maclen = 6 = 48 bits
%TODO: no pktin??? 


<<global etherbroadcast>>=
static uchar etherbroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
@

%todo: mv later what is below?

\subsection{[[Ether]]net controller and [[etherxx]]}

<<global etherxx (kernel)>>=
static Ether *etherxx[MaxEther];
@
<<constant MaxEther>>=
MaxEther  = 48,
@

%XXX
<<struct Ether (kernel)>>=
struct Ether {

  uchar ea[Eaddrlen];

  <<[[Ether]] methods>>

  <<[[Ether]] priv fields>>
  <<[[Ether]] other fields>>

  Queue*  oq;

  ISAConf;      /* hardware info */
  Netif;

  // Extra
  <<[[Ether]] extra fields>>
};
@
% in 386 because ISAConf?
% Netif later

<<[[Ether]] extra fields>>=
int ctlrno;
@
% index in etherxx?

% e.g. Dp8390 structure
<<[[Ether]] priv fields>>=
void  *ctlr;
@

%XXX
<<[[Ether]] other fields>>=
int tbdf;     /* type+busno+devno+funcno */
@


<<[[Ether]] methods>>=
<<[[ether]] mounting methods>>
<<[[ether]] io methods>>
<<[[ether]] other methods>>
@

<<[[ether]] mounting methods>>=
void  (*attach)(Ether*);  /* filled in by reset routine */
void  (*detach)(Ether*);
@

% but where is the data to transmit? in a global?
<<[[ether]] io methods>>=
void  (*transmit)(Ether*);
void  (*interrupt)(Ureg*, void*);
@



%XXX
<<[[ether]] other methods>>=
long  (*ifstat)(Ether*, void*, long, ulong);
long  (*ctl)(Ether*, void*, long); /* custom ctl messages */
void  (*power)(Ether*, int);  /* power on/off */
void  (*shutdown)(Ether*);  /* shutdown hardware before reboot */
@

%\subsection{Null medium}


\section{[[/net]] filesystem}

\subsection{[[Fs]] and [[ipfs]]}
% rename? Slashnetfs?

<<struct Fs (kernel)>>=
/*
 *  one per IP protocol stack
 */
struct Fs
{
  IP  *ip;

  // array<option<ref_own<Proto>>>, size is Fs.np
  Proto*  p[Maxproto+1];    /* list of supported protocols */
  int np;

  <<[[Fs(kernel)]] arp fields>>
  <<[[Fs(kernel)]] routing fields>>
  <<[[Fs(kernel)]] ndb fields>>
  <<[[Fs(kernel)]] logging fields>>

  <<[[Fs(kernel)]] other fields>>
  <<[[Fs(kernel)]] ipv6 fields>>
 
  // Extra
  RWlock;
  <<[[Fs(kernel)]] extra fields>>
};
@
% >> >> >>
% why +1? because don't use first entry? because QID trick?

%TODO: where is the info about ipifc? about the medium?

<<constant Maxproto>>=
Maxproto= 20,
@



%\subsection{[[ipfs]]}

<<global ipfs>>=
Fs  *ipfs[Nfs]; /* attached fs's */
@

<<constant Nfs>>=
Nfs=        128,
@
% Nb filesystem (not network file system)
% in practice will have only one IP stack/fs, so Fs.dev will be 0
%less: (so not sure you need such a big number ...)
%todo: when need to have multiple protocol stack?

<<[[Fs(kernel)]] extra fields>>=
int dev; // idx in ipfs
@

<<global fslock>>=
QLock   fslock;
@
% to access ipfs?



<<[[Fs(kernel)]] routing fields>>=
Proto*  ipifc;      /* kludge for ipifcremroute & ipifcaddroute */
@
%note: it's a Proto, not an Ipifc. But then can get the ipifc
% by look at the conversations in this Proto and the priv
% field of those conversation.
% I put in 'routing' category because it is.
% it's not really a kludge/hack, it's fundamental. It's
% for findipifc().
% At some point given an IP you will need in v4lookup() to find the
%  gateway and so which ipifc
% to connect this ip, to find the route, and so you'll need
% to look at the IP in the lifc of an ifc.




\subsection{[[IP]] fragments and IP statistics}
%todo: rename, bad name, ip_fragments?

% Fragments because idea of IP is to have packets, and so if
% one tried to send too big data, it's splitted in multiple
% packets, and the IP stack will then reassemble them
% (but this is different from TCP, because here it's done
% in one hop, so it's reliable. No reordering needed, the fragments
% will arrive in order).
% So IP abstract away physical capacity. You just have to care
% about a standard Datagram maximum size, and IP will do the rest.

<<struct IP (kernel)>>=
/* an instance of IP */
struct IP
{
  Fragment4*  flisthead4;
  Fragment4*  fragfree4;
  Ref   id4;

  <<[[IP(kernel)]] stat fields>>
  <<[[IP(kernel)]] routing fields>>

  <<[[IP(kernel)]] ipv6 fields>>

  // Extra
  QLock   fraglock4;
};
@
% id4 will be IP packet identifier, incremented each time
% (why need an id??)


<<struct Fragment4>>=
struct Fragment4
{
  Block*  blist;

  ulong   src;
  ulong   dst;

  ushort  id;
  ulong   age;

  // Extra
  Fragment4*  next;
};
@
%todo: ulong for src and dst? ports? fragment number? adress in iphost
% format? ip_ulong;


<<[[IP(kernel)]] stat fields>>=
// map<enum<mib_two_counters>, uvlong>
uvlong    stats[Nipstats];
@

%https://tools.ietf.org/html/rfc4293
<<enum _anon_ (kernel/network/ip/ip.h)3>>=
/* MIB II counters */
enum mib_two_counters
{
  Forwarding,
  DefaultTTL,

  InReceives,

  InHdrErrors,
  InAddrErrors,
  ForwDatagrams,
  InUnknownProtos,

  // In stats
  InDiscards,
  InDelivers,

  // Out stats
  OutRequests,
  OutDiscards,
  OutNoRoutes,

  ReasmTimeout,
  ReasmReqds,
  ReasmOKs,
  ReasmFails,

  // Out fragments
  FragOKs,
  FragFails,
  FragCreates,

  Nipstats,
};
@
% can C-s those things to find interesting places
%less: reorder, show important one

<<global statnames>>=
static char *statnames[] =
{
[Forwarding]    "Forwarding",
[DefaultTTL]    "DefaultTTL",
[InReceives]    "InReceives",
[InHdrErrors]   "InHdrErrors",
[InAddrErrors]  "InAddrErrors",
[ForwDatagrams] "ForwDatagrams",
[InUnknownProtos]   "InUnknownProtos",

[InDiscards]    "InDiscards",
[InDelivers]    "InDelivers",

[OutRequests]   "OutRequests",
[OutDiscards]   "OutDiscards",
[OutNoRoutes]   "OutNoRoutes",

[ReasmTimeout]  "ReasmTimeout",
[ReasmReqds]    "ReasmReqds",
[ReasmOKs]  "ReasmOKs",
[ReasmFails]    "ReasmFails",

[FragOKs]   "FragOKs",
[FragFails] "FragFails",
[FragCreates]   "FragCreates",
};
@




\subsection{[[Proto]]cols}

% /net/<proto>/

<<struct Proto (kernel)>>=
/*
 *  one per multiplexed protocol
 */
struct Proto
{
  char*   name;   /* protocol name */ // e.g. "udp", "tcp", etc

  <<[[Proto(kernel)]] methods>>

  // growing_array<option<ref_own<Proto>>>, size = Proto.nc
  Conv    **conv;   /* array of conversations */
  int   nc;   /* number of conversations */
  int   ac; // number of opened conversations

  <<[[Proto(kernel)]] priv fields>>
  <<[[Proto(kernel)]] other fields>>

  // Extra
  QLock;
  <<[[Proto(kernel)]] extra fields>>
};
@



<<[[Proto(kernel)]] extra fields>>=
// ref<Fs>, reverse of Fs.p[this.x]
Fs    *f;   /* file system this proto is part of */
// index in Fs.p[]
int   x;    /* protocol index */
@
% (x is useful when building qid)
% so get access to its ip stack via f so can access the method of the
% ip stack and medium!


% Actually  /net/ipifc/ will be a protocol itself! with a clone
% and then with a conversation. Very general scheme.

%dead:
%<<[[Proto(kernel)]] other fields>>=
%Qid   qid;    /* qid for protocol directory */
%@
% who need that?


<<[[Proto(kernel)]] priv fields>>=
void    *priv;
@
% quite important, Udppriv, Ilpriv


<<[[Proto(kernel)]] methods>>=
<<[[Proto(kernel)]] protocol methods>>
<<[[Proto(kernel)]] conversation ctl methods>>
<<[[Proto(kernel)]] conversation inspection methods>>
<<[[Proto(kernel)]] conversation methods>>
@


% sysopen(/net/<proto>/clone) -> ... -> ipopen -> Fsprotoclone -> <>
% ipclose -> closeconv -> <>
<<[[Proto(kernel)]] protocol methods>>=
void    (*create)(Conv*);
void    (*close)(Conv*);
@
% Take the conversation created, so can adjust its structure.
% Kinda of a ctor. Create() will setup a callback (xxxkick) on the
% writing queue which will add the header before the data to send.
% So create is kinda a (*send) method too.
% void xxxkick(Conv *cv, Block *bp)


% ??? -> ipiput4 -> <>
<<[[Proto(kernel)]] conversation methods>>=
void    (*rcv)(Proto*, Ipifc*, Block*);
@
% no send? this is for dispatching to the right conversation
% but in sending we know the conversation associated with the channel,
% so the sending is actually associated with create() which sets
% the xxxkick functions.

%syswrite("connect", /net/<proto>/<conv>/ctl) -> ... -> ipwrite -> ... -> <>
<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*connect)(Conv*, char**, int);
char*   (*announce)(Conv*, char**, int);
@
<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*ctl)(Conv*, char**, int);
@
% if protocol specific ctl message, call this general handler,
% e.g. when do 'add ...' for /net/ipifc/x/ctl

%syswrite("bind ...", /net/<proto>/<conv>/ctl) -> ... -> ipwrite -> ... -> <>
<<[[Proto(kernel)]] conversation ctl methods>>=
char*   (*bind)(Conv*, char**, int);
@
%less: method only for ipifc?


% will introduce also some other methods later.


\subsection{[[Conv]]ersations}

% /net/<proto>/<conv>/

% A bit like a Channel (accessed indirectly via Chan->dev, ipfs and the qid)
% Big structure ... a bit like Proc for Kernel.nw, central structure.
<<struct Conv (kernel)>>=
/*
 *  one per conversation directory
 */
struct Conv
{

  uchar laddr[IPaddrlen]; /* local IP address */
  uchar raddr[IPaddrlen]; /* remote IP address */

  ushort  lport;      /* local port number */
  ushort  rport;      /* remote port number */

  char  *owner;     /* protections */
  int perm;

  // enum<conversation_state>
  int state;

  <<[[Conv(kernel)]] queue fields>>
  <<[[Conv(kernel)]] listen fields>>
  <<[[Conv(kernel)]] routing fields>>
  <<[[Conv(kernel)]] multicast fields>>
  <<[[Conv(kernel)]] udp fields>>

  <<[[Conv(kernel)]] synchronisation fields>>
  <<[[Conv(kernel)]] priv fields>>
  <<[[Conv(kernel)]] snoop fields>>
  <<[[Conv(kernel)]] error fields>>

  <<[[Conv(kernel)]] other fields>>
  <<[[Conv(kernel)]] ipv6 fields>>

  // Extra
  QLock;
  <<[[Conv(kernel)]] extra fields>>
};
@
% ip + port = is enough to establish a connexion
% need ip + port in general
% ipA!portA <-> ipB!portB


% but actually Conv is general and (ab)used also for ipifc.
% It's essentially an overlay over Channel with network related information.


<<[[Conv(kernel)]] extra fields>>=
// ref<Proto> reverse of Proto.conv[this.x]
Proto*  p;
// index in Proto.conv[]
int x;      /* conversation index */
@
% (x is useful when building qid)
% so can get "class" via p so can access the method of the protocol from
% a Conv


<<enum conversation_state>>=
enum conversation_state
{
  Idle=   0,

  Announcing= 1,
  Announced=  2,

  Connecting= 3,
  Connected=  4,
};
@


<<[[Conv(kernel)]] queue fields>>=
Queue*  rq;     /* queued data waiting to be read */
Queue*  wq;     /* queued data waiting to be written */
@
% setup in each create() method of each Proto
% will be accessed via /net/x/y/data, in read or write
% conversation are two ways, can read and write in /net/x/y/data, full duplex


<<[[Conv(kernel)]] queue fields>>=
Queue*  eq;     /* returned error packets */
@
% setup in Fsprotoclone generically
<<[[Conv(kernel)]] error fields>>=
char  cerr[ERRMAX];
@


<<[[Conv(kernel)]] synchronisation fields>>=
Rendez  cr;
@
% e.g. when connect, need to sleep until someone connects
% with you (via an announce), so will sleep on that.

<<[[Conv(kernel)]] priv fields>>=
void* ptcl;     /* protocol specific stuff */
@
% e.g. Ipifc ! when have a conversation with /net/ipifc/x/ctl
<<[[Proto(kernel)]] priv fields>>=
int   ptclsize; /* size of per protocol ctl block */
@



<<[[Conv(kernel)]] other fields>>=
int inuse;      /* opens of listen/data/ctl */
@
% set to 1 in clone, incremented after each additional open


%dead:
%<<[[Conv(kernel)]] other fields>>=
%int length;
%QLock car;
%@




\subsection{Chan Qid, [[PROTO()]], [[CONV()]], [[QID()]]}

% In the end everything is a file in plan9, so connexion/sockets
% will be channel with a qid in /net/.
% Have a qid scheme to encode the type of channel.

<<enum qid (kernel/network/ip/devip.c)>>=
enum
{
    Qtopdir=    1,      /* top level directory */

    Qtopbase,
    Qarp=       Qtopbase,
    Qiproute,
    <<[[Qid]] toplevel extra cases>>

    Qprotodir,          /* directory for a protocol */
    Qprotobase,
    Qclone=     Qprotobase,
    <<[[Qid]] protocol extra cases>>

    Qconvdir,           /* directory for a conversation */
    Qconvbase,
    Qctl=       Qconvbase,
    Qdata,
    <<[[Qid]] conversation extra cases>>
    <<[[Qid]] conversation extra cases, last entry>>
};
@

%FIGURE: qid with different bits for different parts
% 5 bits for type, 12 bits for conversation, 8 bits for proto
% => 25 bits

%many of those chans will really behave like a socket.


<<enum misc (kernel/network/ip/devip.c)>>=
enum
{
    Logtype=    5,
    Masktype=   (1<<Logtype)-1,

    Logconv=    12,
    Maskconv=   (1<<Logconv)-1,
    Shiftconv=  Logtype,

    Logproto=   8,
    Maskproto=  (1<<Logproto)-1,
    Shiftproto= Logtype + Logconv,

    <<constant Nfs>>
};
@
% >> >> >> >>


% given a channel qid we can quickly identify its "property" that
% is where it comes from. For instance the channel qid of /net/tcp/0/...
% will be a certain integer and we can access to its protocol with
% PROTO() and its conversation with CONV(), and final "type" with TYPE

% ctor
<<macro QID>>=
#define QID(p, cv, y)    ( ((p)<<(Shiftproto)) | ((cv)<<Shiftconv) | (y) )
@
% >> >>

% in ip3gen()
%    cv = ipfs[c->dev]->p[PROTO(c->qid)]->conv[CONV(c->qid)];

% with Chan.dev        => access Fs     (ipfs[c->dev])
% with PROTO(Chan.qid) => access Proto  (...) 
% with CONV(Chan.qid)  => Access Conv   (...)



% getters
<<macro PROTO>>=
#define PROTO(x)    ( (((ulong)(x).path) >> Shiftproto) & Maskproto )
@
% /net/x (tcp, udp, etc)
<<macro CONV>>=
#define CONV(x)     ( (((ulong)(x).path) >> Shiftconv) & Maskconv )
@
% /net/.../x

<<macro TYPE>>=
#define TYPE(x)     ( ((ulong)(x).path) & Masktype )
@
% /net/.../.../x (ctl, data, etc)

% in ipattach()
%    mkqid(&c->qid, QID(0, 0, Qtopdir), 0, QTDIR);
% so means entries 0 are not used in Proto and Conv?








\section{[[/net/ether]] filesystem}

\subsection{[[Netif]]}

<<struct Netif (kernel)>>=
/*
 *  a network interface
 */
struct Netif
{
  /* multiplexing */
  char  name[KNAMELEN];   /* for top level directory */

  // growing_array?<option<ref_own<Netfile>>>
  Netfile **f;
  int nfile;      /* max number of Netfiles */

  /* about net */
  int limit;      /* flow control */
  int alen;     /* address length */
  int mbps;     /* megabits per sec */
  int link;     /* link status */

  int minmtu;
  int maxmtu;
  int mtu;
  uchar addr[Nmaxaddr];
  uchar bcast[Nmaxaddr];


  int prom;     /* number of promiscuous opens */
  int scan;     /* number of base station scanners */
  int all;      /* number of -1 multiplexors */

  /* statistics */
  int misses;
  uvlong  inpackets;
  uvlong  outpackets;
  int crcs;   /* input crc errors */
  int oerrs;    /* output errors */
  int frames;   /* framing errors */
  int overflows;  /* packet overflows */
  int buffs;    /* buffering errors */
  int soverflows; /* software overflow */

  /* routines for touching the hardware */
  void  *arg;

  <<[[Netif(kernel)]] methods>>

  // Extra
  QLock;

};
@

<<[[Netif(kernel)]] methods>>=
void  (*promiscuous)(void*, int);
int (*hwmtu)(void*, int); /* get/set mtu */
void  (*scanbs)(void*, uint); /* scan for base stations */

<<[[Netif(kernel)]] multicast fields>>
<<[[Netif(kernel)]] multicast methods>>
@

\subsection{[[Netfile]]}

<<struct Netfile>>=
/*
 *  one per multiplexed connection
 */
struct Netfile
{
  QLock;

  int inuse;
  ulong mode;
  char  owner[KNAMELEN];

  int type;     /* multiplexor type */
  int prom;     /* promiscuous mode */
  int scan;     /* base station scanning interval */
  int bridge;     /* bridge mode */
  int headersonly;    /* headers only - no data */
  uchar maddr[8];   /* bitmask of multicast addresses requested */
  int nmaddr;     /* number of multicast addresses */

  Queue *in;      /* input buffer */

  // Extra
};
@

\section{IP header}

<<struct Ip4hdr>>=
/* on the wire packet header */
struct Ip4hdr
{
  uchar vihl;   /* Version and header length */
  uchar tos;    /* Type of service */
  uchar length[2];  /* packet length */
  uchar id[2];    /* ip->identification */
  uchar frag[2];  /* Fragment information */
  uchar ttl;        /* Time to live */

  // enum<protocol_type>
  uchar proto;    /* Protocol */

  uchar cksum[2]; /* Header checksum */

  uchar src[4];   /* IP source */
  uchar dst[4];   /* IP destination */
};
@
% Do not change the order here!
% id will be IP.id4, incremented in ipoput
% use uchar/byte not int or short, probably to avoid byte order issues.

<<[[Fs(kernel)]] other fields>>=
// map<enum<protocol_type>, ref<Proto>>
Proto*  t2p[256];   /* vector of all protocols */
@
<<[[Proto(kernel)]] other fields>>=
// enum<protocol_type>
int   ipproto;  /* ip protocol type */
@

% so when will receive a packet, we will know to which
% protocol to dispatch.
% It means also you can't have more than 256 (toplevel) Protocols!

\section{Addresses hashtable, [[Ipht]]}
% it's actually (IP|star * port|star)

% another link with Conv!

% used in Udppriv, Ilpriv, presented later when
% a protocol needs to remember the set of open connexions
% and the ip of those connexions so when a packet arrive
% from somewhere, we can know which conversation is associated
% with this connexion.

<<struct Ipht>>=
/*
 *  hash table for 2 ip addresses + 2 ports
 */
struct Ipht
{
  // hash<ipconvhash, ref<Conv>>, next = Iphash.next
  Iphash  *tab[Nipht];

  // Extra
  Lock;
};
@

<<constant Nipht>>=
Nipht=    521,  /* convenient prime */
@

<<struct Iphash>>=
struct Iphash
{
  Conv  *c;
  // enum<matchtype>
  int match;

  // Extra
  Iphash  *next;
};
@
% Conv connexion!

<<enum matchtype>>=
enum matchtype {
  IPmatchexact= 0,  /* match on 4 tuple */

  IPmatchany,   /* *!* */
  IPmatchport,    /* *!port */
  IPmatchaddr,    /* addr!* */
  IPmatchpa,    /* addr!port */
};
@



<<function iphash>>=
/*
 *  hashing tcp, udp, ... connections
 */
ulong
iphash(uchar *sa, ushort sp, uchar *da, ushort dp)
{
    return ((sa[IPaddrlen-1]<<24) ^ (sp << 16) ^ (da[IPaddrlen-1]<<8) ^ dp ) 
      % Nipht; // pad's first network bugfix :)
}
@
% >> >> >>
%bug: was Nhash instead of Nipht :)


% if you want to connect, then need to give exact address and port
% if you announce, then you can give regexps
<<function iphtadd>>=
void
iphtadd(Ipht *ht, Conv *c)
{
    ulong hv;
    Iphash *h;

    hv = iphash(c->raddr, c->rport, c->laddr, c->lport);
    h = smalloc(sizeof(Iphash));
    if(ipcmp(c->raddr, IPnoaddr) != 0)
        h->match = IPmatchexact;
    else {
        if(ipcmp(c->laddr, IPnoaddr) != 0){
            if(c->lport == 0)
                h->match = IPmatchaddr;
            else
                h->match = IPmatchpa;
        } else {
            if(c->lport == 0)
                h->match = IPmatchany;
            else
                h->match = IPmatchport;
        }
    }
    h->c = c;

    lock(ht);
    // add_hash(h, ht)
    h->next = ht->tab[hv];
    ht->tab[hv] = h;
    unlock(ht);
}
@

<<function iphtrem>>=
void
iphtrem(Ipht *ht, Conv *c)
{
    ulong hv;
    Iphash **l, *h;

    hv = iphash(c->raddr, c->rport, c->laddr, c->lport);
    lock(ht);
    // del_hash(hv, ht)
    for(l = &ht->tab[hv]; (*l) != nil; l = &(*l)->next)
        if((*l)->c == c){
            h = *l;
            (*l) = h->next;
            free(h);
            break;
        }
    unlock(ht);
}
@

<<function iphtlook>>=
/* look for a matching conversation with the following precedence
 *  connected && raddr,rport,laddr,lport
 *  announced && laddr,lport
 *  announced && *,lport
 *  announced && laddr,*
 *  announced && *,*
 */
Conv*
iphtlook(Ipht *ht, uchar *sa, ushort sp, uchar *da, ushort dp)
{
    ulong hv;
    Iphash *h;
    Conv *c;

    /* exact 4 pair match (connection) */
    hv = iphash(sa, sp, da, dp);
    lock(ht);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchexact) {
          c = h->c;
          if(sp == c->rport && dp == c->lport
             && ipcmp(sa, c->raddr) == 0 && ipcmp(da, c->laddr) == 0){
              unlock(ht);
              return c;
          }
        }
    }

    /* match local address and port */
    hv = iphash(IPnoaddr, 0, da, dp);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchpa) {
          c = h->c;
          if(dp == c->lport && ipcmp(da, c->laddr) == 0){
              unlock(ht);
              return c;
          }
       }
    }

    /* match just port */
    hv = iphash(IPnoaddr, 0, IPnoaddr, dp);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchport) {
          c = h->c;
          if(dp == c->lport){
              unlock(ht);
              return c;
          }
        }
    }

    /* match local address */
    hv = iphash(IPnoaddr, 0, da, 0);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchaddr) {
          c = h->c;
          if(ipcmp(da, c->laddr) == 0){
              unlock(ht);
              return c;
          }
        }
    }

    /* look for something that matches anything */
    hv = iphash(IPnoaddr, 0, IPnoaddr, 0);
    for(h = ht->tab[hv]; h != nil; h = h->next){
        if(h->match == IPmatchany) {
          c = h->c;
          unlock(ht);
          return c;
        }
    }
    unlock(ht);
    return nil;
}
@




\section{Routes}

\subsection{Single [[Route]]}

<<[[Conv(kernel)]] routing fields>>=
Route *r;     /* last route used */
@
%XXX
<<[[Conv(kernel)]] routing fields>>=
ulong rgen;     /* routetable generation for *r */
@
% when things change

% rename? v4rgen?
<<global v4routegeneration>>=
static ulong v4routegeneration;
@
% incremented in many methods

% this is the link with ipifc! From a conv you get a destination IP
% and via vlookup4 you get a Route which is then linked to an ipifc!
% From there you can then send or receive the data to/from the medium.

<<struct Route (kernel)>>=
struct Route
{
  RouteTree;

  union {
    V4route v4;
    <<[[Route]] ipv6 route union case>>
  };

};
@
%NOTE: if change the order and put RouteTree after the union
% then ip/ipconfig generates a kernel oops. 
% It's because allocroute() does this weird alloc to optimize things.
% By default a malloc(sizeof(Route)) will waste the space of v6addr.




<<struct V4route>>=
struct V4route
{
  ulong address;
  ulong endaddress;

  uchar gate[IPv4addrlen];
};
@
%todo: rename address to startaddress;
% ulong address? ip32 bit in host format.
% range of address managed by this gateway. Use ip_ilong here
% because we will need to compare the asked ip to this range

% gateway! then need using ARP to get from ip gateway to MAC gateway!



<<struct RouteTree (kernel)>>=
struct  RouteTree
{
  // bitset<enum<route_type> >
  uchar type;

  Ipifc *ifc; // !!!

  <<[[Routetree]] other fields>>

  // Extra
  Route*  right;
  Route*  left;
  Route*  mid;

};
@
% note that those are Route*, not RouteTree

% in ipoput4:
%    r = v4lookup(f, eh->dst, c);
%    ifc = r->ifc !!


% routes are linked together so we can gc them when an interface
% is changed or the topology changed in which case we need to invalidate
% the routes out there?



% for debugging? to know which kind of rout it is? e.g. "ifc"
<<[[Routetree]] other fields>>=
char  tag[4];
@

%XXX
<<[[Routetree]] other fields>>=
int ref;
@
% can have multiple reference to this route? when returned in v4lookup?


<<enum _anon_ (kernel/network/ip/ip.h)6>>=
enum route_type
{
  /* type bits */
  Rv4=    (1<<0),   /* this is a version 4 route */

  Rifc=   (1<<1),   /* this route is a directly connected interface */
  Rptpt=    (1<<2),   /* this route is a pt to pt interface */

  Runi=   (1<<3),   /* a unicast self address */

  Rbcast=   (1<<4),   /* a broadcast self address */
  Rmulti=   (1<<5),   /* a multicast self address */

  Rproxy=   (1<<6),   /* this route should be proxied */
};
@
% >> >> >> >> >> >> >>
% will see this different type in advanced section. The simplest one
% for now is Runi
%todo: reorder? put Runi first?
%todo: aspectize? not a DARPA format, so we can change it no?



%XXX
<<[[Ipifc(kernel)]] routing fields>>=
Routerparams rp;  /* router parameters as in RFC 2461, pp.40—43.
        used only if node is router */
@


\subsection{Routing forest}


<<[[Fs(kernel)]] routing fields>>=
// hash<ip, ref<Route>> where hash function is V4H
Route *v4root[1<<Lroot];  /* v4 routing forest */
@
% >>

<<constant Lroot>>=
/* 2^Lroot trees in the root table */
Lroot=    10,
@


\section{Blocks}

% DS of the kernel

<<macro BLKIPVER>>=
#define BLKIPVER(xp)    (((Ip4hdr*)((xp)->rp))->vihl&0xF0)
@


<<macro BLKIP>>=
#define BLKIP(xp)   ((Ip4hdr*)((xp)->rp))
@



\chapter{Initialization}

\section{Kernel side}

\subsection{Mounting the ip device}

% see kernel init.c, but can do that manually too after the boot.
% bind #I /net
%  bind_safe("#I", "/net", MREPL); // devip
% (not /dev)
% => /net/... especially /net/ipifc/, /net/arp, /net/iproute

% ??? sysbind?? -> <> (as attach <- ipdevtab.attach <- toplevel)
<<function ipattach>>=
static Chan*
ipattach(char* spec)
{
    Chan *c;
    int dev;

    dev = atoi(spec);
    if(dev >= Nfs)
        error("bad specification");

    // initialize ip stack
    ipgetfs(dev);

    c = devattach('I', spec);
    mkqid(&c->qid, QID(0, 0, Qtopdir), 0, QTDIR);
    c->dev = dev;
    c->aux = newipaux(up->user, "none");

    return c;
}
@
% spec? can have multiple network stack?
% Qtopdir!

% will allocate a Fs, will allocate IP fragments,
% will initialize arp, protocols, and then return
% a channel handle that one can use to access Fs services.

% remember 
% - c->aux = private data stored in the channel
%   (but the conv is also extra channel data, but stored elsewhere)
% - c->dev = extra index information

<<function ipgetfs>>=
static Fs*
ipgetfs(int dev)
{
    extern void (*ipprotoinit[])(Fs*);
    Fs *f;
    int i;

    if(dev >= Nfs)
        return nil;

    qlock(&fslock);
    if(ipfs[dev] == nil){
        f = smalloc(sizeof(Fs));

        ip_init(f);
        arpinit(f);
        netloginit(f);
        for(i = 0; ipprotoinit[i]; i++)
            ipprotoinit[i](f);

        f->dev = dev;
        ipfs[dev] = f;
    }
    qunlock(&fslock);

    return ipfs[dev];
}
@

<<struct IPaux>>=
/*
 *  Hanging off every ip channel's ->aux is the following structure.
 *  It maintains the state used by devip and iproute.
 */
struct IPaux
{
  char  *owner;   /* the user that did the attach */
  char  tag[4];
};
@
%todo: tag?? "none" at the beginning?
%less: why put that in the channel? why not in the conv? because need
% faster access?

<<macro ATTACHER>>=
#define ATTACHER(c) (((IPaux*)((c)->aux))->owner)
@
% c is a chan

% ipattach -> <>
<<function newipaux>>=
IPaux*
newipaux(char *owner, char *tag)
{
    IPaux *a;
    int n;

    a = smalloc(sizeof(IPaux));

    kstrdup(&a->owner, owner);
    memset(a->tag, ' ', sizeof(a->tag));
    n = strlen(tag);
    if(n > sizeof(a->tag))
        n = sizeof(a->tag);
    memmove(a->tag, tag, n);

    return a;
}
@

\subsubsection{[[ip_init()]]}

% ipattach -> ipgetfs -> <>
<<function ip_init>>=
void
ip_init(Fs *f)
{
    IP *ip;

    ip = smalloc(sizeof(IP));
    initfrag(ip, 100);
    f->ip = ip;

    <<[[ip_init()]] ipv6 init>>
}
@

<<function initfrag>>=
void
initfrag(IP *ip, int size)
{
    Fragment4 *fq4, *eq4;
    <<[[initfrag()]] locals>>

    ip->fragfree4 = (Fragment4*)malloc(sizeof(Fragment4) * size);
    if(ip->fragfree4 == nil)
        panic("initfrag");

    eq4 = &ip->fragfree4[size];
    for(fq4 = ip->fragfree4; fq4 < eq4; fq4++)
        fq4->next = fq4+1;
    ip->fragfree4[size-1].next = nil;

    <<[[initfrag()]] ipv6 init fragfree6>>
}
@
% 100 packets? 100 fragments?
%less: boilerplate, classic list of used/free things

\subsubsection{[[arpinit()]]}
% will see later

\subsubsection{[[netloginit()]]}
% see in appendix

\subsubsection{[[ipprotoinit()]]}
% each specifics

% in qemu.c because of qemu.conf:
%void (*ipprotoinit[])(Fs*) = {
%	tcpinit,
%	udpinit,
%	ipifcinit,
%	icmpinit,
%	icmp6init,
%	ilinit,
%	nil,
%};


\subsection{Mounting the ethernet device}

% see kernel init.c
% bind #l -a /net
%  bind_safe("#l0", "/net", MAFTER); // ether (and dev 0)

% => /net/ether0
% => /net/ether0/addr to get MAC address

% actually populated with many things already, 0/, 1/, 2/ with
% different x/type values

% /net/ether0/stats  give you also your mac address at the very end

% will mount multiple devices for gateways.

% ??? sysbind?? -> <> (as attach <- etherdevtab?.attach <- toplevel)
<<function etherattach>>=
Chan*
etherattach(char* spec)
{
    ulong ctlrno;
    char *p;
    Chan *chan;

    ctlrno = 0;
    if(spec && *spec){
        ctlrno = strtoul(spec, &p, 0);
        if((ctlrno == 0 && p == spec) || *p || (ctlrno >= MaxEther))
            error(Ebadarg);
    }
    if(etherxx[ctlrno] == nil)
        error(Enodev);

    chan = devattach('l', spec);
    if(waserror()){
        chanfree(chan);
        nexterror();
    }
    chan->dev = ctlrno;
    if(etherxx[ctlrno]->attach)
        // Ethernet controller dispatch
        etherxx[ctlrno]->attach(etherxx[ctlrno]);

    poperror();
    return chan;
}
@
% #l0 => spec = 0

% the attach method

\section{User side}

\subsection{Connect manually}

% open /net/<protocol>/clone

\subsection{[[dial()]]}

% dial uses connection server which introduces extra complexity







\chapter{User/Kernel Bridge}

% Will see how dispatch commands from user to kernel, via /net,
% and how the kernel then dispatch internally the command to the right
% protocol, to the right method, to the right medium.

\section{IP device}

<<global ipdevtab>>=
Dev ipdevtab = {
    .dc       =    'I',
    .name     =    "ip",

    .attach   =    ipattach,
    .walk     =    ipwalk,
    .open     =    ipopen,
    .close    =    ipclose,
    .read     =    ipread,
    .write    =    ipwrite,
    .stat     =    ipstat,
    .wstat    =    ipwstat,
               
    .create   =    ipcreate,
    .remove   =    ipremove,
    .bread    =    ipbread,
    .bwrite   =    ipbwrite,
    .reset    =    ipreset,
    .init     =    devinit,
    .shutdown =    devshutdown,
};
@

% can't create any files there
<<function ipcreate>>=
static void
ipcreate(Chan*, char*, int, ulong)
{
    error(Eperm);
}
@

<<function ipremove>>=
static void
ipremove(Chan*)
{
    error(Eperm);
}
@


\subsection{[[/net]] hierarchy and [[ipwalk()]]}

<<function ipwalk>>=
static Walkqid*
ipwalk(Chan* c, Chan *nc, char **name, int nname)
{
    IPaux *a = c->aux;
    Walkqid* w;

    w = devwalk(c, nc, name, nname, nil, 0, ipgen);

    if(w != nil && w->clone != nil)
        w->clone->aux = newipaux(a->owner, a->tag);

    return w;
}
@
% first chan created in ipattach will have a correct aux.
% ipwalk =~ readdir

% Walkqid =~ Dirtab? so will call ipgen to fill entries
% in Dirtab.

% ipwalk -> devwalk <- <> (as xx <- ipwalk)
% return -1, 0, 1 for devwalk to know what to do
<<function ipgen>>=
static int
ipgen(Chan *c, char*, Dirtab*, int, int s, Dir *dp)
{
    Fs *f;
    Qid q;
    Conv *cv;

    f = ipfs[c->dev];
    switch(TYPE(c->qid)) {
    <<[[ipgen()]] switch TYPE qid cases>>
    }
    return -1;
}
@
% -1 means no more entries? you can stop to call me to get another
% entry (s is incremented each time)

% ipgen means generate Dir entries or property for this qid.


\subsubsection{[[/net/]]}

% remember s is an integer to get the xth entry in the directory, 
% or -1  (DEVDOTDOT). How knows when to stop? what is the max value
% of s? see above, -1!
%todo: rename 's' to i or something
<<[[ipgen()]] switch TYPE qid cases>>=
case Qtopdir:
    if(s == DEVDOTDOT){
        mkqid(&q, QID(0, 0, Qtopdir), 0, QTDIR);
        snprint(up->genbuf, sizeof up->genbuf, "#I%lud", c->dev);
        devdir(c, q, up->genbuf, 0, network, 0555, dp);
        return 1;
    }
    if(s < f->np) {
        if(f->p[s]->connect == nil)
            return 0;   /* protocol with no user interface */
        mkqid(&q, QID(s, 0, Qprotodir), 0, QTDIR);
        devdir(c, q, f->p[s]->name, 0, network, 0555, dp);
        return 1;
    }
    s -= f->np;
    return ip1gen(c, Qtopbase+s, dp);
@
% first topdir, then protodir, then regular file in topdir

<<global network>>=
static char network[] = "network";
@
% for owner?


\subsubsection{[[/net/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qarp:
case Qiproute:
case Qipselftab:
case Qndb:
case Qlog:
    return ip1gen(c, TYPE(c->qid), dp);
@
%case Qbootp:

<<function ip1gen>>=
static int
ip1gen(Chan *c, int i, Dir *dp)
{
    Fs *f;
    Qid q;
    int prot;
    int len = 0;
    char *p;
    <<[[ip1gen()]] locals>>

    f = ipfs[c->dev];
    prot = 0666;
    mkqid(&q, QID(0, 0, i), 0, QTFILE);
    switch(i) {
    <<[[ip1gen()]] switch TYPE qid cases>>
    default:
        return -1;
    }
    devdir(c, q, p, len, network, prot, dp);
    <<[[ipgen()]] if Qndb, adjust mtime>>
    return 1;
}
@





\subsubsection{[[/net/proto/]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qprotodir:
    if(s == DEVDOTDOT){
        mkqid(&q, QID(0, 0, Qtopdir), 0, QTDIR);
        snprint(up->genbuf, sizeof up->genbuf, "#I%lud", c->dev);
        devdir(c, q, up->genbuf, 0, network, 0555, dp);
        return 1;
    }
    if(s < f->p[PROTO(c->qid)]->ac) {
        cv = f->p[PROTO(c->qid)]->conv[s];
        snprint(up->genbuf, sizeof up->genbuf, "%d", s);
        mkqid(&q, QID(PROTO(c->qid), s, Qconvdir), 0, QTDIR);
        devdir(c, q, up->genbuf, 0, cv->owner, 0555, dp);
        return 1;
    }
    s -= f->p[PROTO(c->qid)]->ac;
    return ip2gen(c, s+Qprotobase, dp);
@
% conversation number is stable?? if open 2, close first, then
% will get a hole? the directory seems very dynamic, so if you didn't
% open a connexion with a previous conv number, you will get something
% different?


\subsubsection{[[/net/proto/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qclone:
case Qstats:
    return ip2gen(c, TYPE(c->qid), dp);
@

<<function ip2gen>>=
static int
ip2gen(Chan *c, int i, Dir *dp)
{
    Qid q;

    switch(i) {
    case Qclone:
        mkqid(&q, QID(PROTO(c->qid), 0, Qclone), 0, QTFILE);
        devdir(c, q, "clone", 0, network, 0666, dp);
        return 1;
    case Qstats:
        mkqid(&q, QID(PROTO(c->qid), 0, Qstats), 0, QTFILE);
        devdir(c, q, "stats", 0, network, 0444, dp);
        return 1;
    }
    return -1;
}
@
% 0 used for the toplevel entries, each conversation then starts at 1

\subsubsection{[[/net/proto/conv/]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qconvdir:
    if(s == DEVDOTDOT){
        s = PROTO(c->qid);
        mkqid(&q, QID(s, 0, Qprotodir), 0, QTDIR);
        devdir(c, q, f->p[s]->name, 0, network, 0555, dp);
        return 1;
    }
    return ip3gen(c, s+Qconvbase, dp);
@


\subsubsection{[[/net/proto/conv/xxx]]}

<<[[ipgen()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
case Qlisten:
case Qlocal:
case Qremote:
case Qstatus:
case Qsnoop:
    return ip3gen(c, TYPE(c->qid), dp);
@

<<function ip3gen>>=
static int
ip3gen(Chan *c, int i, Dir *dp)
{
    Qid q;
    Conv *cv;
    char *p;

    cv = ipfs[c->dev]->p[PROTO(c->qid)]->conv[CONV(c->qid)];
    if(cv->owner == nil)
        kstrdup(&cv->owner, eve);
    mkqid(&q, QID(PROTO(c->qid), CONV(c->qid), i), 0, QTFILE);
    switch(i) {
    <<[[ip3gen()]] switch TYPE qid cases>>
    default:
        return -1;
    }
    devdir(c, q, p, 0, cv->owner, 0444, dp);
    return 1;
}
@

<<[[ip3gen()]] switch TYPE qid cases>>=
case Qctl:
    devdir(c, q, "ctl", 0, cv->owner, cv->perm, dp);
    return 1;
case Qdata:
    devdir(c, q, "data", qlen(cv->rq), cv->owner, cv->perm, dp);
    return 1;
@





\subsection{Dispatch functions, [[ipxxx()]]}

\subsubsection{[[ipopen()]]}

<<global m2p>>=
static int m2p[] = {
    [OREAD]     4,
    [OWRITE]    2,
    [ORDWR]     6
};
@
% ???

<<function ipopen>>=
static Chan*
ipopen(Chan* c, int omode)
{
    Fs *f;
    int perm;
    Proto *p;
    Conv *cv, *nc;

    f = ipfs[c->dev];
    perm = m2p[omode&3];
    switch(TYPE(c->qid)) {
    <<[[ipopen()]] switch TYPE qid cases>>
    default:
        break;
    }
    c->mode = openmode(omode);
    c->flag |= COPEN;
    c->offset = 0;
    return c;
}
@


<<[[ipopen()]] switch TYPE qid cases>>=
case Qtopdir:
case Qprotodir:
case Qconvdir:

case Qipselftab:

case Qstatus:
case Qlocal:
case Qremote:
case Qstats:
    if(omode != OREAD)
        error(Eperm);
    break;
@
%dead: case Qbootp:




% lots of noise, but mostly check perm and increment inuse
<<[[ipopen()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
    p = f->p[PROTO(c->qid)];
    qlock(p);
    cv = p->conv[CONV(c->qid)];
    qlock(cv);
    if(waserror()) {
        qunlock(cv);
        qunlock(p);
        nexterror();
    }
    if((perm & (cv->perm>>6)) != perm) {
        if(strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if((perm & cv->perm) != perm)
            error(Eperm);

    }
    cv->inuse++;
    if(cv->inuse == 1){
        kstrdup(&cv->owner, ATTACHER(c));
        cv->perm = 0660;
    }
    qunlock(cv);
    qunlock(p);
    poperror();
    break;
@



\subsubsection{[[ipclose()]]}

<<function ipclose>>=
static void
ipclose(Chan* c)
{
    Fs *f;

    f = ipfs[c->dev];
    switch(TYPE(c->qid)) {
    <<[[ipclose()]] switch TYPE qid cases>>
    default:
        break;
    }
    free(((IPaux*)c->aux)->owner);
    free(c->aux);
}
@

<<[[ipclose()]] switch TYPE qid cases>>=
case Qctl:
case Qdata:
case Qerr:
    if(c->flag & COPEN)
        closeconv(f->p[PROTO(c->qid)]->conv[CONV(c->qid)]);
    break;
@


<<function closeconv>>=
void
closeconv(Conv *cv)
{
    Conv *nc;
    <<[[closeconv()]] locals>>

    qlock(cv);

    if(--cv->inuse > 0) {
        qunlock(cv);
        return;
    }
    <<[[closeconv()]] close incoming calls>>

    kstrdup(&cv->owner, network);
    cv->perm = 0660;
    <<[[closeconv()]] if multi, call ipifcremmulti>>
    cv->r = nil;
    cv->rgen = 0;
    // Protocol dispatch
    cv->p->close(cv);
    cv->state = Idle;

    qunlock(cv);
}
@




\subsubsection{[[ipread()]]}

<<function ipread>>=
static long
ipread(Chan *ch, void *a, long n, vlong off)
{
    Fs *f;
    Proto *x;
    Conv *cv;
    char *buf, *p;
    long rv;
    ulong offset = off;

    f = ipfs[ch->dev];
    p = a;
    switch(TYPE(ch->qid)) {
    <<[[ipread()]] switch TYPE qid cases>>
    default:
        error(Eperm);

    }
}
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qtopdir:
case Qprotodir:
case Qconvdir:
    return devdirread(ch, a, n, 0, 0, ipgen);
@



\subsubsection{[[ipwrite()]]}


<<function ipwrite>>=
static long
ipwrite(Chan* ch, void *v, long n, vlong off)
{
    Fs *f;
    Proto *x;
    Conv *cv;
    char *p; // err?
    Cmdbuf *cb;
    char *a;
    ulong offset = off;
    <<[[ipwrite()]] locals>>

    f = ipfs[ch->dev];
    a = v;
    switch(TYPE(ch->qid)){
    <<[[ipwrite()]] switch TYPE qid cases>>
    default:
        error(Eperm);
    }
    return n;
}
@



\subsection{[[/net/x/clone]]}

<<[[ipopen()]] switch TYPE qid cases>>=
case Qclone:
    p = f->p[PROTO(c->qid)];

    qlock(p);
    if(waserror()){
        qunlock(p);
        nexterror();
    }

    cv = Fsprotoclone(p, ATTACHER(c));

    qunlock(p);
    poperror();
    if(cv == nil) {
        error(Enodev);
        break;
    }
    mkqid(&c->qid, QID(p->x, cv->x, Qctl), 0, QTFILE);
    break;
@
% Qctl !! redirect to Qctl of newly created /net/<proto>/<conv>/ dir
% with a newly conversation created in Fs->p[x]->conv[x] with
% the queue created

<<function Fsprotoclone>>=
/*
 *  called with protocol locked
 */
Conv*
Fsprotoclone(Proto *p, char *user)
{
    Conv *cv, **pp, **ep;

retry:
    cv = nil;
    <<[[Fsprotoclone()]] finding an available conversation in the protocol>>
    <<[[Fsprotoclone()]] if no more available conv, garbage collect and retry>>

    cv->inuse = 1;

    kstrdup(&cv->owner, user);
    cv->perm = 0660;

    cv->state = Idle;

    ipmove(cv->laddr, IPnoaddr);
    ipmove(cv->raddr, IPnoaddr);
    cv->lport = 0;
    cv->rport = 0;

    cv->r = nil;
    cv->rgen = 0;

    cv->restricted = false;
    cv->maxfragsize = 0;
    cv->ttl = MAXTTL;

    qreopen(cv->rq);
    qreopen(cv->wq);
    qreopen(cv->eq);

    qunlock(cv);
    return cv;
}
@

\subsubsection{Finding a free entry}

<<[[Fsprotoclone()]] finding an available conversation in the protocol>>=
ep = &p->conv[p->nc];
for(pp = p->conv; pp < ep; pp++) {
    cv = *pp;
    // found an unallocated entry in the array
    if(cv == nil){
        cv = malloc(sizeof(Conv));
        if(cv == nil)
            error(Enomem);
        qlock(cv);

        cv->p = p;
        cv->x = pp - p->conv;
        if(p->ptclsize != 0){
            cv->ptcl = malloc(p->ptclsize);
            if(cv->ptcl == nil) {
                free(cv);
                error(Enomem);
            }
        }
        *pp = cv;
        p->ac++;
        cv->eq = qopen(1024, Qmsg, 0, 0);

        // !! Protocol dispatch !!! will create extra queues
        (*p->create)(cv);

        break;
    }
    <<[[Fsprotoclone()]] if found an unused entry>>
}
@

\subsubsection{Reuse an unused entry}

<<[[Fsprotoclone()]] if found an unused entry>>=
if(canqlock(cv)){
    /*
     *  make sure both processes and protocol
     *  are done with this Conv
     */
    if(cv->inuse == 0 && (p->inuse == nil || 
        // Protocol dispatch
        (*p->inuse)(cv) == false)
      )
        break;

    qunlock(cv);
}
@
% can reuse an existing conv that was allocated, but need to make
% sure noone is using it (and if you can't lock it, then for sure
% it means it was in use

<<[[Proto(kernel)]] conversation methods>>=
bool   (*inuse)(Conv*);
@


\subsubsection{Garbage collecting}

<<[[Fsprotoclone()]] if no more available conv, garbage collect and retry>>=
if(pp >= ep) {
    if(p->gc)
        print("Fsprotoclone: garbage collecting Convs\n");
    if(p->gc != nil &&
        // Protocol dispatch
        (*p->gc)(p)
       )
        goto retry;

    /* debugging: do we ever get here? */
    if (cpuserver)
        panic("Fsprotoclone: all conversations in use");
    return nil;
}
@

<<[[Proto(kernel)]] protocol methods>>=
int   (*gc)(Proto*);  /* returns true if any conversations are freed */
@

\subsection{[[/net/x/y/ctl]]}

<<[[ipread()]] switch TYPE qid cases>>=
case Qctl:
    buf = smalloc(16);
    snprint(buf, 16, "%lud", CONV(ch->qid));
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@
% that's how you get your /x/ !!


<<[[ipwrite()]] switch TYPE qid cases>>=
case Qctl:
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    cb = parsecmd(a, n);

    qlock(cv);
    if(waserror()) {
        qunlock(cv);
        free(cb);
        nexterror();
    }
    if(cb->nf < 1)
        error("short control request");

    <<[[ipwrite()]] Qctl case, if connect string>>
    <<[[ipwrite()]] Qctl case, else if announce string>>
    <<[[ipwrite()]] Qctl case, else if other string>>
    else if(x->ctl != nil) {
        // Protocol dispatch
        p = x->ctl(cv, cb->f, cb->nf);
        if(p != nil)
            error(p);
    } else
        error("unknown control request");
    qunlock(cv);
    free(cb);
    poperror();
    break;
@

\subsubsection{Connect}

<<[[ipwrite()]] Qctl case, if connect string>>=
if(strcmp(cb->f[0], "connect") == 0)
    connectctlmsg(x, cv, cb);
@

<<function connectctlmsg>>=
static void
connectctlmsg(Proto *p, Conv *c, Cmdbuf *cb)
{
    char *err;

    if(c->state != Idle)
        error(Econinuse);

    c->state = Connecting;
    c->cerr[0] = '\0';

    if(p->connect == nil)
        error("connect not supported");
    // Protocol dispatch
    err = p->connect(c, cb->f, cb->nf);
    if(err != nil)
        error(err);

    qunlock(c);
    if(waserror()){
        qlock(c);
        nexterror();
    }
    sleep(&c->cr, connected, c);
    qlock(c);
    poperror();

    if(c->cerr[0] != '\0')
        error(c->cerr);
}
@
% sleeping on cr!
% need to unlock before sleeping

<<function connected>>=
/*
 *  initiate connection and sleep till its set up
 */
static bool
connected(void* a)
{
    return ((Conv*)a)->state == Connected;
}
@



% lots of those connect() methods will then call Fssconnect and Fssconnected

% udpconnect | ... -> <>
<<function Fsstdconnect>>=
/*
 *  called by protocol connect routine to set addresses
 */
char*
Fsstdconnect(Conv *c, char *argv[], int argc)
{
    char *err;

    switch(argc) {
    case 2:
        err = setraddrport(c, argv[1]);
        if(err != nil)
            return err;
        setladdr(c);
        err = setlport(c);
        if (err != nil)
            return err;
        break;
    case 3:
        err = setraddrport(c, argv[1]);
        if(err != nil)
            return err;
        err = setladdrport(c, argv[2], 0);
        if(err != nil)
            return err;
    default:
        return "bad args to connect";
    }

    <<[[Fsstdconnect()]] set ipversion field to V4 or V6>>

    return nil;
}
@

% ?? udpconnect | ... -> <>
<<function Fsconnected>>=
int
Fsconnected(Conv* c, char* msg)
{
    if(msg != nil && *msg != '\0')
        strncpy(c->cerr, msg, ERRMAX-1);

    switch(c->state){
    case Connecting:
        c->state = Connected;
        break;
    <<[[Fsconnected()]] switch state cases>>
    }
    wakeup(&c->cr);
    return 0;
}
@
% wakeup! someone connected


\subsubsection{Announce}

<<[[ipwrite()]] Qctl case, else if announce string>>=
else if(strcmp(cb->f[0], "announce") == 0)
    announcectlmsg(x, cv, cb);
@

<<function announcectlmsg>>=
static void
announcectlmsg(Proto *p, Conv *c, Cmdbuf *cb)
{
    char *err;

    if(c->state != Idle)
        error(Econinuse);

    c->state = Announcing;
    c->cerr[0] = '\0';

    if(p->announce == nil)
        error("announce not supported");
    // Protocol dispatch
    err = p->announce(c, cb->f, cb->nf);

    if(err != nil)
        error(err);

    qunlock(c);
    if(waserror()){
        qlock(c);
        nexterror();
    }
    sleep(&c->cr, announced, c);
    qlock(c);
    poperror();

    if(c->cerr[0] != '\0')
        error(c->cerr);
}
@
% sleeping again!

<<function announced>>=
/*
 *  initiate announcement and sleep till its set up
 */
static bool
announced(void* a)
{
    return ((Conv*)a)->state == Announced;
}
@

% lots of those announce method will then call Fsstdannounce and Fsannounced

% udpannounce | ... -> <>
<<function Fsstdannounce>>=
/*
 *  called by protocol announce routine to set addresses
 */
char*
Fsstdannounce(Conv* c, char* argv[], int argc)
{
    memset(c->raddr, 0, sizeof(c->raddr));
    c->rport = 0;
    switch(argc){
    default:
        break;
    case 2:
        return setladdrport(c, argv[1], 1);
    }
    return "bad args to announce";
}
@

<<[[Fsconnected()]] switch state cases>>=
case Announcing:
    c->state = Announced;
    break;
@    

\subsubsection{Port settings}

% port fields?
<<[[Conv(kernel)]] other fields>>=
bool restricted;   /* remote port is restricted */
@
<<[[Proto(kernel)]] other fields>>=
ushort    nextrport;
@
% when look for fresh new port, where to start from, but who allocates
% new ports? not the user?



<<function setlport>>=
/*
 *  pick a local port and set it
 */
char *
setlport(Conv* c)
{
    Proto *p;
    int i, port;

    p = c->p;
    qlock(p);
    if(c->restricted){
        /* Restricted ports cycle between 600 and 1024. */
        for(i=0; i<1024-600; i++){
            if(p->nextrport >= 1024 || p->nextrport < 600)
                p->nextrport = 600;
            port = p->nextrport++;
            if(!lportinuse(p, port))
                goto chosen;
        }
    }else{
        /*
         * Unrestricted ports are chosen randomly
         * between 2^15 and 2^16.  There are at most
         * 4*Nchan = 4096 ports in use at any given time,
         * so even in the worst case, a random probe has a
         * 1 - 4096/2^15 = 87% chance of success.
         * If 64 successive probes fail, there is a bug somewhere
         * (or a once in 10^58 event has happened, but that's
         * less likely than a venti collision).
         */
        for(i=0; i<64; i++){
            port = (1<<15) + nrand(1<<15);
            if(!lportinuse(p, port))
                goto chosen;
        }
    }
    qunlock(p);
    /*
     * debugging: let's see if we ever get this.
     * if we do (and we're a cpu server), we might as well restart
     * since we're now unable to service new connections.
     */
    panic("setlport: out of ports");
    return "no ports available";

chosen:
    c->lport = port;
    qunlock(p);
    return nil;
}
@
% >> >> 


<<function setladdrport>>=
/*
 *  set a local address and port from a string of the form
 *  [address!]port[!r]
 */
char*
setladdrport(Conv* c, char* str, int announcing)
{
    char *p;
    char *rv;
    ushort lport;
    uchar addr[IPaddrlen];

    /*
     *  ignore restricted part if it exists.  it's
     *  meaningless on local ports.
     */
    p = strchr(str, '!');
    if(p != nil){
        *p++ = 0;
        if(strcmp(p, "r") == 0)
            p = nil;
    }

    c->lport = 0;
    if(p == nil){
        if(announcing)
            ipmove(c->laddr, IPnoaddr);
        else
            setladdr(c);
        p = str;
    } else {
        if(strcmp(str, "*") == 0)
            ipmove(c->laddr, IPnoaddr);
        else {
            if(parseip(addr, str) == -1)
                return Ebadip;
            if(ipforme(c->p->f, addr))
                ipmove(c->laddr, addr);
            else
                return "not a local IP address";
        }
    }

    /* one process can get all connections */
    if(announcing && strcmp(p, "*") == 0){
        if(!iseve())
            error(Eperm);
        return setluniqueport(c, 0);
    }

    lport = atoi(p);
    if(lport <= 0)
        rv = setlport(c);
    else
        rv = setluniqueport(c, lport);
    return rv;
}
@

<<function setraddrport>>=
static char*
setraddrport(Conv* c, char* str)
{
    char *p;

    p = strchr(str, '!');
    if(p == nil)
        return "malformed address";
    *p++ = 0;
    if (parseip(c->raddr, str) == -1)
        return Ebadip;
    c->rport = atoi(p);
    p = strchr(p, '!');
    if(p){
        if(strstr(p, "!r") != nil)
            c->restricted = true;
    }
    return nil;
}
@


\subsubsection{Bind}

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "bind") == 0)
    bindctlmsg(x, cv, cb);
@

% ipwrite (Qctl case) -> <>
<<function bindctlmsg>>=
static void
bindctlmsg(Proto *x, Conv *cv, Cmdbuf *cb)
{
    char *p;

    if(x->bind == nil)
        p = Fsstdbind(cv, cb->f, cb->nf);
    else
        // Protocol dispatch
        p = x->bind(cv, cb->f, cb->nf);
    if(p != nil)
        error(p);
}
@

% default method
<<function Fsstdbind>>=
/*
 *  called by protocol bind routine to set addresses
 */
char*
Fsstdbind(Conv* cv, char* argv[], int argc)
{
    switch(argc){
    default:
        break;
    case 2:
        return setladdrport(cv, argv[1], 0);
    }
    return "bad args to bind";
}
@

\subsection{[[/net/x/y/data]]}

<<[[ipread()]] switch TYPE qid cases>>=
case Qdata:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->rq, a, n);
@
% read on rq

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qdata:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    if(cv->wq == nil)
        error(Eperm);
    qwrite(cv->wq, a, n);
    break;
@
% write on wq

\subsection{[[/net/x/y/err]]}

<<[[Qid]] conversation extra cases>>=
Qerr,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qerr:
    devdir(c, q, "err", qlen(cv->eq), cv->owner, cv->perm, dp);
    return 1;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qerr:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->eq, a, n);
@
% read only

\subsection{[[/net/x/y/listen]]}
% ?????


<<[[Qid]] conversation extra cases>>=
Qlisten,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qlisten:
    devdir(c, q, "listen", 0, cv->owner, cv->perm, dp);
    return 1;
@

<<[[ipopen()]] switch TYPE qid cases>>=
case Qlisten:
    cv = f->p[PROTO(c->qid)]->conv[CONV(c->qid)];
    if((perm & (cv->perm>>6)) != perm) {
        if(strcmp(ATTACHER(c), cv->owner) != 0)
            error(Eperm);
        if((perm & cv->perm) != perm)
            error(Eperm);

    }

    if(cv->state != Announced)
        error("not announced");

    if(waserror()){
        closeconv(cv);
        nexterror();
    }
    qlock(cv);
    cv->inuse++;
    qunlock(cv);

    nc = nil;
    while(nc == nil) {
        /* give up if we got a hangup */
        if(qisclosed(cv->rq))
            error("listen hungup");

        qlock(&cv->listenq);
        if(waserror()) {
            qunlock(&cv->listenq);
            nexterror();
        }

        /* wait for a connect */
        sleep(&cv->listenr, incoming, cv);

        qlock(cv);
        nc = cv->incall;
        if(nc != nil){
            cv->incall = nc->next;
            mkqid(&c->qid, QID(PROTO(c->qid), nc->x, Qctl), 0, QTFILE);
            kstrdup(&cv->owner, ATTACHER(c));
        }
        qunlock(cv);

        qunlock(&cv->listenq);
        poperror();
    }
    closeconv(cv);
    poperror();
    break;
@

<<[[Conv(kernel)]] listen fields>>=
Conv* incall;     /* calls waiting to be listened for */
Conv* next;
QLock listenq;
Rendez  listenr;
@


<<[[closeconv()]] close incoming calls>>=
/* close all incoming calls since no listen will ever happen */
for(nc = cv->incall; nc; nc = cv->incall){
    cv->incall = nc->next;
    closeconv(nc);
}
cv->incall = nil;
@


\subsection{Other files}

\subsubsection{[[/net/x/stats]]}

<<[[Qid]] protocol extra cases>>=
Qstats,
@

<<[[Proto(kernel)]] protocol methods>>=
int   (*stats)(Proto*, char*, int);
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qstats:
    x = f->p[PROTO(ch->qid)];
    if(x->stats == nil)
        error("stats not implemented");
    buf = smalloc(Statelen);

    // Protocol dispatch
    (*x->stats)(x, buf, Statelen);

    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

<<constant Statelen>>=
    Statelen=   32*1024,
@

\subsubsection{[[/net/x/y/status]]}

<<[[Qid]] conversation extra cases>>=
Qstatus,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qstatus:
    p = "status";
    break;
@

<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*state)(Conv*, char*, int);
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qstatus:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];

    // Protocol dispatch
    (*x->state)(cv, buf, Statelen-2);

    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@
% -2? why?

\subsubsection{[[/net/x/y/local]], [[/net/x/y/remote]]}

<<[[Qid]] conversation extra cases>>=
Qlocal,
Qremote,
@
<<[[ip3gen()]] switch TYPE qid cases>>=
case Qlocal:
    p = "local";
    break;
case Qremote:
    p = "remote";
    break;
@

<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*local)(Conv*, char*, int);
@

% cv->laddr
<<[[ipread()]] switch TYPE qid cases>>=
case Qlocal:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    if(x->local == nil) {
        snprint(buf, Statelen, "%I!%d\n", cv->laddr, cv->lport);
    } else {
        // Protocol dispatch
        (*x->local)(cv, buf, Statelen-2);
    }
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@



<<[[Proto(kernel)]] conversation inspection methods>>=
int   (*remote)(Conv*, char*, int);
@

% cv->raddr
<<[[ipread()]] switch TYPE qid cases>>=
case Qremote:
    buf = smalloc(Statelen);
    x = f->p[PROTO(ch->qid)];
    cv = x->conv[CONV(ch->qid)];
    if(x->remote == nil) {
        snprint(buf, Statelen, "%I!%d\n", cv->raddr, cv->rport);
    } else {
        // Protocol dispatch
        (*x->remote)(cv, buf, Statelen-2);
    }
    rv = readstr(offset, p, n, buf);
    free(buf);
    return rv;
@

\section{Ethernet device}


<<global etherdevtab>>=
Dev etherdevtab = {
    .dc       =    'l',
    .name     =    "ether",

    .attach   =    etherattach,
    .walk     =    etherwalk,
    .open     =    etheropen,
    .close    =    etherclose,
    .read     =    etherread,
    .write    =    etherwrite,
    .stat     =    etherstat,
    .wstat    =    etherwstat,
               
    .reset    =    etherreset,
    .init     =    devinit,
    .shutdown =    ethershutdown,
    .create   =    ethercreate,
    .bread    =    etherbread,
    .bwrite   =    etherbwrite,
    .remove   =    devremove,
};
@

\subsection{[[/net/etherx]] hierarchy and [[etherwalk()]]}



%\section{Streams}

% like bidirectional pipes. Producer/consumer like pipes, but
% bidirectional.






\chapter{Configuration}

\section{[[/net/ipifc/]] protocol}

% (ab)use the protocol scheme to also configure.
%alt: some special file in /net/ like /net/medium, /net/ip

\subsection{Protocol initialisation}

% ipattach -> ipgetfs -> <> (as ipprotoinit[i] <- ipprotoinit[x] = <> <- qemu.c)
<<function ipifcinit>>=
void
ipifcinit(Fs *f)
{
    Proto *ipifc;

    ipifc = smalloc(sizeof(Proto));

    ipifc->name = "ipifc";
    ipifc->create = ipifccreate;
    ipifc->close = ipifcclose;

    ipifc->bind = ipifcbind;
    ipifc->connect = ipifcconnect;
    ipifc->announce = nil;
    ipifc->ctl = ipifcctl;

    ipifc->rcv = nil;
    ipifc->advise = nil;
    ipifc->inuse = ipifcinuse;

    ipifc->local = ipifclocal;
    ipifc->state = ipifcstate;
    ipifc->stats = ipifcstats;

    ipifc->ipproto = -1;

    ipifc->nc = Maxmedia;
    ipifc->ptclsize = sizeof(Ipifc);

    <<[[ipifcinit()]] modify f>>

    Fsproto(f, ipifc);
}
@
%less: make it a global with intializer?
%note: no remote method, we abuse the protocol here.
%alt: why not do via global? why smalloc? to not pay memory if don't use
% the network? meh.

%    ipifc->nc = Maxmedia;
% max conversation

% ipproto = -1 cos fake protocol, we will not receive any packet
% from the ethernet to be directed to this protocol (which is why
% also rcv is nil)

<<function Fsproto>>=
int
Fsproto(Fs *f, Proto *p)
{
    if(f->np >= Maxproto)
        return -1;

    p->f = f;

    <<[[Fsproto()]] adjust f->t2p>>

    p->conv = malloc(sizeof(Conv*) * (p->nc+1));
    if(p->conv == nil)
        panic("Fsproto");

    p->nextrport = 600;

    p->x = f->np;
    f->p[f->np++] = p;

    return 0;
}
@
%nextrport = next receive port?
%dead:
%    p->qid.type = QTDIR;
%    p->qid.path = QID(f->np, 0, Qprotodir);

<<[[Fsproto()]] adjust f->t2p>>=
if(p->ipproto > 0){
    if(f->t2p[p->ipproto] != nil)
        return -1;
    f->t2p[p->ipproto] = p;
}
@
% so given an ip package just received, can look at proto field
% and dispatch to the right protocol!



<<[[ipifcinit()]] modify f>>=
f->ipifc = ipifc;   /* hack for ipifcremroute, findipifc, ... */
@
% It's not an hack! it's fundamental, so in v4lookup() we
% can call findipifc and from an Fs get the good Ipifc
% (which then contain the right medium to reach the right gateway)




\subsection{[[/net/ipifc/clone]]}

%// sysopen(/net/ipifc/clone) -> ... -> ipopen -> Fsprotoclone -> <>
%  (as x->create <- ...)
<<function ipifccreate>>=
/*
 *  called when a new ipifc structure is created
 */
static void
ipifccreate(Conv *cv)
{
    Ipifc *ifc;

    cv->rq = qopen(QMAX, 0, 0, 0);
    cv->wq = qopen(QMAX, Qkick, ipifckick, cv);

    cv->sq = qopen(QMAX, 0, 0, 0);

    ifc = (Ipifc*)cv->ptcl;
    ifc->m = nil;

    ifc->conv = cv;
    ifc->reassemble = false;
}
@
% Ipifc has been smalloc generically by Fsprotoclone()
% no medium yet!
%dead:    ifc->unbinding = false;

% ip/ipconfig open this file and keeps it open forever

\subsection{Binding medium, [[/net/ipifc/x/ctl bind]]}

% ipwrite (Qctl case) -> bindctlmsg -> <> (as x->bind <- ipprotoinit[i] <- qmemu.c)
% bind ether /net/ether0
<<function ipifcbind>>=
/*
 *  attach a device (or pkt driver) to the interface.
 *  called with cv locked
 */
static char*
ipifcbind(Conv *cv, char **argv, int argc)
{
    Ipifc *ifc;
    Medium *m;

    if(argc < 2)
        return Ebadarg;

    ifc = (Ipifc*)cv->ptcl;

    /* bind the device to the interface */
    m = ipfindmedium(argv[1]);
    if(m == nil)
        return "unknown interface type";

    wlock(ifc);
    if(ifc->m != nil){
        wunlock(ifc);
        return "interface already bound";
    }
    if(waserror()){
        wunlock(ifc);
        nexterror();
    }

    // This time Medium dispatch
    /* do medium specific binding */
    (*m->bind)(ifc, argc, argv);

    /* set the bound device name */
    if(argc > 2)
        strncpy(ifc->dev, argv[2], sizeof(ifc->dev));
    else
        snprint(ifc->dev, sizeof ifc->dev, "%s%d", m->name, cv->x);
    ifc->dev[sizeof(ifc->dev)-1] = 0;

    /* set up parameters */
    ifc->m = m;

    ifc->mintu = ifc->m->mintu;
    ifc->maxtu = ifc->m->maxtu;
    if(ifc->m->unbindonclose == false)
        ifc->conv->inuse++;

    ifc->rp.mflag = 0;      /* default not managed */
    ifc->rp.oflag = 0;
    ifc->rp.maxraint = 600000;  /* millisecs */
    ifc->rp.minraint = 200000;
    ifc->rp.linkmtu = 0;        /* no mtu sent */
    ifc->rp.reachtime = 0;
    ifc->rp.rxmitra = 0;
    ifc->rp.ttl = MAXTTL;
    ifc->rp.routerlt = 3 * ifc->rp.maxraint;

    /* any ancillary structures (like routes) no longer pertain */
    ifc->ifcid++;

    /* reopen all the queues closed by a previous unbind */
    qreopen(cv->rq);
    qreopen(cv->eq);
    qreopen(cv->sq);

    wunlock(ifc);
    poperror();

    return nil;
}
@

%less: rename to generation field?
<<[[Ipifc(kernel)]] other fields>>=
uchar ifcid;    /* incremented each 'bind/unbind/add/remove' */
@
% a bit like process, when get a ref to a Proc, need also ensure
% it was the proc with a certain id that you were associated to

% why need ifcid? because ifc may have changed! it may have been
% binded to something else
<<[[Routetree]] other fields>>=
uchar ifcid;    /* must match ifc->id */
@



<<function ipfindmedium>>=
/*
 *  find the medium with this name
 */
Medium*
ipfindmedium(char *name)
{
    Medium **mp;

    for(mp = media; *mp != nil; mp++)
        if(strcmp((*mp)->name, name) == 0)
            break;
    return *mp;
}
@
% use global media

\subsection{[[/net/ipifc/x/ctl]]}

% ... -> ipwrite (Qctl case) -> <>
%  (as x->bind <- ...) because not a generic msg
<<function ipifcctl>>=
/*
 *  non-standard control messages.
 *  called with cv->car locked.
 */
static char*
ipifcctl(Conv* cv, char** argv, int argc)
{
    Ipifc *ifc;
    int i;

    ifc = (Ipifc*)cv->ptcl;
    <<[[ipifcctl()]] if add string>>
    <<[[ipifcctl()]] else if other string>>

    return "unsupported ctl";
}
@






\subsection{Adding an IP, [[/net/ipifc/x/ctl add]]}

<<[[ipifcctl()]] if add string>>=
if(strcmp(argv[0], "add") == 0)
    return ipifcadd(ifc, argv, argc, false, nil);
@

% tentative is for ipv6 stuff
<<function ipifcadd>>=
/*
 *  add an address to an interface.
 */
char*
ipifcadd(Ipifc *ifc, char **argv, int argc, bool tentative, Iplifc *lifcp)
{
    int i;
    int mtu;
    // enum<route_type>
    int type;
    uchar ip[IPaddrlen];
    uchar mask[IPaddrlen];
    uchar net[IPaddrlen]; // ip & mask
    uchar rem[IPaddrlen];
    Iplifc *lifc, **l;
    Fs *f;

    <<[[ipifcadd()]] locals>>

    if(ifc->m == nil)
        return "ipifc not yet bound to device";

    f = ifc->conv->p->f;

    type = Rifc;
    memset(ip, 0, IPaddrlen);
    memset(mask, 0, IPaddrlen);
    memset(rem, 0, IPaddrlen);

    switch(argc){
    <<[[ipifcadd()]] switch argc, proxy case, and fall through>>
    <<[[ipifcadd()]] switch argc, mtu setting case, and fall through>>
    <<[[ipifcadd()]] switch argc cases, setting ip, mask, net, rem>>
    default:
        return Ebadarg;
    }

    <<[[ipifcadd()]] set tentative for ipv6>>
    wlock(ifc);
    <<[[ipifcadd()]] check if already a local address for this ifc>>

    /* add the address to the list of logical ifc's for this ifc */
    lifc = smalloc(sizeof(Iplifc));
    ipmove(lifc->local, ip);
    ipmove(lifc->mask, mask);
    ipmove(lifc->remote, rem);
    ipmove(lifc->net, net);
    <<[[ipifcadd()]] set ipv6 fields for lifc>>
    // add_tail(lifc, ifc->lifc)
    lifc->next = nil;
    for(l = &ifc->lifc; *l; l = &(*l)->next)
        ;
    *l = lifc;

    <<[[ipifcadd()]] check for point to point interface>>

    /* add local routes */
    if(isv4(ip))
        v4addroute(f, tifc, rem+IPv4off, mask+IPv4off, rem+IPv4off, type);
    <<[[ipifcadd()]] add route if ipv6 case>>

    addselfcache(f, ifc, lifc, ip, Runi);

    <<[[ipifcadd()]] register proxy if point to point interface or proxy>>

    if(isv4(ip) || ipcmp(ip, IPnoaddr) == 0) {
        <<[[ipifcadd()]] add broadcast addresses to self cache>>
    }
    <<[[ipifcadd()]] if ipv6 add multicast addresses to self cache>>

    /* register the address on this network for address resolution */
    if(isv4(ip) && ifc->m->areg != nil)
        // Medium dispatch
        (*ifc->m->areg)(ifc, ip);

out:
    wunlock(ifc);
    <<[[ipifcadd()]] if ipv6 tentative and broacast>>
    return nil;
}
@

%todo: <rem> is remote for gateway?
<<[[ipifcadd()]] switch argc cases, setting ip, mask, net, rem>>=
// add <ip> <mask> <rem>
case 4:
    if (parseip(ip, argv[1]) == -1 || parseip(rem, argv[3]) == -1)
        return Ebadip;
    parseipmask(mask, argv[2]);
    maskip(rem, mask, net);
    break;
// add <ip> <mask>
case 3:
    if (parseip(ip, argv[1]) == -1)
        return Ebadip;
    parseipmask(mask, argv[2]);
    maskip(ip, mask, rem);
    maskip(rem, mask, net);
    break;
// simplest case, add <ip>
case 2:
    if (parseip(ip, argv[1]) == -1)
        return Ebadip;
    memmove(mask, defmask(ip), IPaddrlen);
    maskip(ip, mask, rem);
    maskip(rem, mask, net);
    break;
@

<<global tifc>>=
static char tifc[] = "ifc ";
@
% tag


<<[[ipifcadd()]] check if already a local address for this ifc>>=
/* ignore if this is already a local address for this ifc */
for(lifc = ifc->lifc; lifc; lifc = lifc->next) {
    if(ipcmp(lifc->local, ip) == 0) {
        <<[[ipifcadd()]] when already local address for ifc, copy ipv6 fields>>
        goto out;
    }
}
@


\section{IP Interface, user side}

\subsection{Parsing}

<<function readipifc>>=
Ipifc*
readipifc(char *net, Ipifc *ifc, int index)
{
    int fd, i, n;
    Dir *dir;
    char directory[128];
    char buf[128];
    Ipifc **l;

    _freeifc(ifc);

    l = &ifc;
    ifc = nil;

    if(net == nil)
        net = "/net";
    snprint(directory, sizeof(directory), "%s/ipifc", net);

    if(index >= 0){
        snprint(buf, sizeof(buf), "%s/%d/status", directory, index);
        _readipifc(buf, l, index);
    } else {
        fd = open(directory, OREAD);
        if(fd < 0)
            return nil;
        n = dirreadall(fd, &dir);
        close(fd);

        for(i = 0; i < n; i++){
            if(strcmp(dir[i].name, "clone") == 0)
                continue;
            if(strcmp(dir[i].name, "stats") == 0)
                continue;
            snprint(buf, sizeof(buf), "%s/%s/status", directory, dir[i].name);
            l = _readipifc(buf, l, atoi(dir[i].name));
        }
        free(dir);
    }

    return ifc;
}
@


<<function _readipifc>>=
static Ipifc**
_readipifc(char *file, Ipifc **l, int index)
{
    int i, n, fd, lines;
    char buf[4*1024];
    char *line[32];
    char *f[64];
    Ipifc *ifc, **l0;
    Iplifc *lifc, **ll;

    /* read the file */
    fd = open(file, OREAD);
    if(fd < 0)
        return l;
    n = 0;
    while((i = read(fd, buf+n, sizeof(buf)-1-n)) > 0 && n < sizeof(buf) - 1)
        n += i;
    buf[n] = 0;
    close(fd);

    //if(strncmp(buf, "device", 6) != 0)
    //    return _readoldipifc(buf, l, index);

    /* ignore ifcs with no associated device */
    if(strncmp(buf+6, "  ", 2) == 0)
        return l;
    /* allocate new interface */
    *l = ifc = mallocz(sizeof(Ipifc), 1);
    if(ifc == nil)
        return l;
    l0 = l;
    l = &ifc->next;
    ifc->index = index;

    lines = getfields(buf, line, nelem(line), 1, "\n");

    /* pick off device specific info(first line) */
    n = tokenize(line[0], f, nelem(f));
    if(n%2 != 0)
        goto lose;
    strncpy(ifc->dev, findfield("device", f, n), sizeof(ifc->dev));
    ifc->dev[sizeof(ifc->dev)-1] = 0;
    if(ifc->dev[0] == 0){
lose:
        free(ifc);
        *l0 = nil;
        return l;
    }
    ifc->mtu          = strtoul(findfield("maxtu", f, n), nil, 10);
    ifc->sendra6      = atoi(findfield("sendra", f, n));
    ifc->recvra6      = atoi(findfield("recvra", f, n));
    ifc->rp.mflag     = atoi(findfield("mflag", f, n));
    ifc->rp.oflag     = atoi(findfield("oflag", f, n));
    ifc->rp.maxraint  = atoi(findfield("maxraint", f, n));
    ifc->rp.minraint  = atoi(findfield("minraint", f, n));
    ifc->rp.linkmtu   = atoi(findfield("linkmtu", f, n));
    ifc->rp.reachtime = atoi(findfield("reachtime", f, n));
    ifc->rp.rxmitra   = atoi(findfield("rxmitra", f, n));
    ifc->rp.ttl       = atoi(findfield("ttl", f, n));
    ifc->rp.routerlt  = atoi(findfield("routerlt", f, n));
    ifc->pktin        = strtoul(findfield("pktin", f, n), nil, 10);
    ifc->pktout       = strtoul(findfield("pktout", f, n), nil, 10);
    ifc->errin        = strtoul(findfield("errin", f, n), nil, 10);
    ifc->errout       = strtoul(findfield("errout", f, n), nil, 10);

    /* now read the addresses */
    ll = &ifc->lifc;
    for(i = 1; i < lines; i++){
        n = tokenize(line[i], f, nelem(f));
        if(n < 5)
            break;

        /* allocate new local address */
        *ll = lifc = mallocz(sizeof(Iplifc), 1);
        ll = &lifc->next;

        parseip(lifc->ip, f[0]);
        parseipmask(lifc->mask, f[1]);
        parseip(lifc->net, f[2]);

        lifc->validlt = strtoul(f[3], nil, 10);
        lifc->preflt = strtoul(f[4], nil, 10);
    }

    return l;
}
@


<<function _freeifc>>=
static void
_freeifc(Ipifc *ifc)
{
    Ipifc *next;
    Iplifc *lnext, *lifc;

    if(ifc == nil)
        return;
    for(; ifc; ifc = next){
        next = ifc->next;
        for(lifc = ifc->lifc; lifc; lifc = lnext){
            lnext = lifc->next;
            free(lifc);
        }
        free(ifc);
    }
}
@

<<function findfield>>=
static char*
findfield(char *name, char **f, int n)
{
    int i;

    for(i = 0; i < n-1; i++)
        if(strcmp(f[i], name) == 0)
            return f[i+1];
    return "";
}
@

%<<function _readoldipifc>>=
%static Ipifc**
%_readoldipifc(char *buf, Ipifc **l, int index)
%{
%    char *f[200];
%    int i, n;
%    Ipifc *ifc;
%    Iplifc *lifc, **ll;
%
%    /* allocate new interface */
%    *l = ifc = mallocz(sizeof(Ipifc), 1);
%    if(ifc == nil)
%        return l;
%    l = &ifc->next;
%    ifc->index = index;
%
%    n = tokenize(buf, f, nelem(f));
%    if(n < 2)
%        return l;
%
%    strncpy(ifc->dev, f[0], sizeof ifc->dev);
%    ifc->dev[sizeof(ifc->dev) - 1] = 0;
%    ifc->mtu = strtoul(f[1], nil, 10);
%
%    ll = &ifc->lifc;
%    for(i = 2; n-i >= 7; i += 7){
%        /* allocate new local address */
%        *ll = lifc = mallocz(sizeof(Iplifc), 1);
%        ll = &lifc->next;
%
%        parseip(lifc->ip, f[i]);
%        parseipmask(lifc->mask, f[i+1]);
%        parseip(lifc->net, f[i+2]);
%        ifc->pktin = strtoul(f[i+3], nil, 10);
%        ifc->pktout = strtoul(f[i+4], nil, 10);
%        ifc->errin = strtoul(f[i+5], nil, 10);
%        ifc->errout = strtoul(f[i+6], nil, 10);
%    }
%    return l;
%}
%@


\subsection{[[/net/ipifc/x]]}

<<function myipaddr>>=
/* find first ip addr that isn't the friggin loopback address
 * unless there are no others 
 */
int
myipaddr(uchar *ip, char *net)
{
    Ipifc *nifc;
    Iplifc *lifc;
    static Ipifc *ifc;
    uchar mynet[IPaddrlen];

    ifc = readipifc(net, ifc, -1);
    for(nifc = ifc; nifc; nifc = nifc->next)
        for(lifc = nifc->lifc; lifc; lifc = lifc->next){
            maskip(lifc->ip, loopbackmask, mynet);
            if(ipcmp(mynet, loopbacknet) == 0){
                continue;
            }
            if(ipcmp(lifc->ip, IPnoaddr) != 0){
                ipmove(ip, lifc->ip);
                return 0;
            }
        }
    ipmove(ip, IPnoaddr);
    return -1;
}
@

\subsection{[[/net/ipifc/stats]]}

<<function ipifcstats>>=
int
ipifcstats(Proto *ipifc, char *buf, int len)
{
    return ipstats(ipifc->f, buf, len);
}
@

<<function ipstats>>=
int
ipstats(Fs *f, char *buf, int len)
{
    IP *ip;
    char *p, *e;
    int i;

    ip = f->ip;
    ip->stats[DefaultTTL] = MAXTTL;

    p = buf;
    e = p+len;
    for(i = 0; i < Nipstats; i++)
        p = seprint(p, e, "%s: %llud\n", statnames[i], ip->stats[i]);
    return p - buf;
}
@


\section{Binding ethernet medium}

% not really initialisation, more configuration, so better moved
% here, because harder to explain before.

%linux: ifconfig eth0 ...

% open /net/ipifc/clone and start configure things.
%  echo 'bind ether /net/ether0' > /net/ipifc/0/ctl
%  echo 'add 10.0.2.15' > /net/ipifc/0/ctl
% (but how I guessed my ip? ipconfig use dhcp?)

% or use program:
% $ ip/ipconfig
% => /net/ipifc/0/... now contains an interface! connected to ethernet
%    /net/ipifc/0/status is nice
% => /net/arp now contains entries
% => /net/iproute now contains entries

% Have seen the first part with bind of Ipifc Protocol.
% Now will see the bind of the ethernet medium.


\subsection{[[etherbind()]]}

% ??? -> <>
%   (as x->bind <- ...)
<<function etherbind>>=
/*
 *  called to bind an IP ifc to an ethernet device
 *  called with ifc wlock'd
 */
static void
etherbind(Ipifc *ifc, int argc, char **argv)
{
    Chan *mchan4, *cchan4, *achan, *mchan6, *cchan6, *schan;
    char addr[Maxpath]; //char addr[2*KNAMELEN];
    char dir[Maxpath];  //char dir[2*KNAMELEN];
    char *buf;
    int n;
    char *ptr;
    Etherrock *er;

    if(argc < 2)
        error(Ebadarg);

    mchan4 = cchan4 = achan = mchan6 = cchan6 = nil;
    buf = nil;
    if(waserror()){
        if(mchan4 != nil)
            cclose(mchan4);
        if(cchan4 != nil)
            cclose(cchan4);
        if(achan != nil)
            cclose(achan);
        if(mchan6 != nil)
            cclose(mchan6);
        if(cchan6 != nil)
            cclose(cchan6);
        if(buf != nil)
            free(buf);
        nexterror();
    }

    /*
     *  open ipv4 conversation
     *
     *  the dial will fail if the type is already open on
     *  this device.
     */
    snprint(addr, sizeof(addr), "%s!0x800", argv[2]);   /* ETIP4 */
    mchan4 = chandial(addr, nil, dir, &cchan4);

    /*
     *  make it non-blocking
     */
    devtab[cchan4->type]->write(cchan4, nbmsg, strlen(nbmsg), 0);

    /*
     *  get mac address and speed
     */
    snprint(addr, sizeof(addr), "%s/stats", argv[2]);
    buf = smalloc(512);
    schan = namec(addr, Aopen, OREAD, 0);
    if(waserror()){
        cclose(schan);
        nexterror();
    }
    n = devtab[schan->type]->read(schan, buf, 511, 0);
    cclose(schan);
    poperror();
    buf[n] = 0;

    ptr = strstr(buf, "addr: ");
    if(!ptr)
        error(Eio);
    ptr += 6;
    parsemac(ifc->mac, ptr, 6);

    ptr = strstr(buf, "mbps: ");
    if(ptr){
        ptr += 6;
        ifc->mbps = atoi(ptr);
    } else
        ifc->mbps = 100;

    /*
     *  open arp conversation
     */
    snprint(addr, sizeof(addr), "%s!0x806", argv[2]);   /* ETARP */
    achan = chandial(addr, nil, nil, nil);

    /*
     *  open ipv6 conversation
     *
     *  the dial will fail if the type is already open on
     *  this device.
     */
    snprint(addr, sizeof(addr), "%s!0x86DD", argv[2]);  /* ETIP6 */
    mchan6 = chandial(addr, nil, dir, &cchan6);

    /*
     *  make it non-blocking
     */
    devtab[cchan6->type]->write(cchan6, nbmsg, strlen(nbmsg), 0);

    er = smalloc(sizeof(*er));
    er->mchan4 = mchan4;
    er->cchan4 = cchan4;
    er->achan = achan;
    er->mchan6 = mchan6;
    er->cchan6 = cchan6;
    er->f = ifc->conv->p->f;
    ifc->arg = er;

    free(buf);
    poperror();

    kproc("etherread4", etherread4, ifc);
    kproc("recvarpproc", recvarpproc, ifc);
    kproc("etherread6", etherread6, ifc);
}
@

\subsection{[[chandial()]]}

\section{Setting up routes}

% have seen in ipifcadd() the call to v4addroute and
% the call to the areg method for the associated medium
% as well as the registration of ip in the self cache.

% will explain more about Route in Route chapter.

\section{Advanced configurations}

\subsection{IP Routing}
% quite important, for gateways?

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "iprouting") == 0){
    i = 1;
    if(argc > 1)
        i = atoi(argv[1]);
    iprouting(cv->p->f, i);
    return nil;
}
@

<<function iprouting>>=
void
iprouting(Fs *f, bool on)
{
    f->ip->iprouting = on;
    if(f->ip->iprouting == false)
        f->ip->stats[Forwarding] = 2;
    else
        f->ip->stats[Forwarding] = 1;
}
@

\subsection{MTU}

<<[[ipifcadd()]] switch argc, mtu setting case, and fall through>>=
// add <ip> <mask> <rem> <mtu>
case 5:
    mtu = strtoul(argv[4], 0, 0);
    if(mtu >= ifc->m->mintu && mtu <= ifc->m->maxtu)
        ifc->maxtu = mtu;
    /* fall through */
@


<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "mtu") == 0)
    return ipifcsetmtu(ifc, argv, argc);
@

<<function ipifcsetmtu>>=
/*
 *  change an interface's mtu
 */
char*
ipifcsetmtu(Ipifc *ifc, char **argv, int argc)
{
    int mtu;

    if(argc < 2 || ifc->m == nil)
        return Ebadarg;
    mtu = strtoul(argv[1], 0, 0);
    if(mtu < ifc->m->mintu || mtu > ifc->m->maxtu)
        return Ebadarg;
    ifc->maxtu = mtu;
    return nil;
}
@


\subsection{TOS}

<<[[Conv(kernel)]] other fields>>=
uint  tos;      /* type of service */
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "tos") == 0)
    tosctlmsg(cv, cb);
@

<<function tosctlmsg>>=
static void
tosctlmsg(Conv *c, Cmdbuf *cb)
{
    if(cb->nf < 2)
        c->tos = 0;
    else
        c->tos = atoi(cb->f[1]);
}
@

\subsection{TTL}

<<[[Conv(kernel)]] other fields>>=
uint  ttl;      /* max time to live */
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "ttl") == 0)
    ttlctlmsg(cv, cb);
@

<<function ttlctlmsg>>=
static void
ttlctlmsg(Conv *c, Cmdbuf *cb)
{
    if(cb->nf < 2)
        c->ttl = MAXTTL;
    else
        c->ttl = atoi(cb->f[1]);
}
@

<<constant MAXTTL>>=
MAXTTL=   255,
@

\subsection{Dynamic interface, removing, unbinding, etc}

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "remove") == 0)
    return ipifcrem(ifc, argv, argc);
@

%less: comment not valid anymore? car not a conv field anymore
<<function ipifcrem>>=
/*
 *  remove an address from an interface.
 *  called with c->car locked
 */
char*
ipifcrem(Ipifc *ifc, char **argv, int argc)
{
    char *rv;
    uchar ip[IPaddrlen], mask[IPaddrlen], rem[IPaddrlen];
    Iplifc *lifc;

    if(argc < 3)
        return Ebadarg;

    if (parseip(ip, argv[1]) == -1)
        return Ebadip;
    parseipmask(mask, argv[2]);
    if(argc < 4)
        maskip(ip, mask, rem);
    else
        if (parseip(rem, argv[3]) == -1)
            return Ebadip;

    wlock(ifc);

    /*
     *  find address on this interface and remove from chain.
     *  for pt to pt we actually specify the remote address as the
     *  addresss to remove.
     */
    for(lifc = ifc->lifc; lifc != nil; lifc = lifc->next) {
        if (memcmp(ip, lifc->local, IPaddrlen) == 0
        && memcmp(mask, lifc->mask, IPaddrlen) == 0
        && memcmp(rem, lifc->remote, IPaddrlen) == 0)
            break;
    }

    rv = ipifcremlifc(ifc, lifc);
    wunlock(ifc);
    return rv;
}
@

<<function ipifcremlifc>>=
/*
 *  remove a logical interface from an ifc
 *  always called with ifc wlock'd
 */
static char*
ipifcremlifc(Ipifc *ifc, Iplifc *lifc)
{
    Iplifc **l;
    Fs *f;

    f = ifc->conv->p->f;

    /*
     *  find address on this interface and remove from chain.
     *  for pt to pt we actually specify the remote address as the
     *  addresss to remove.
     */
    for(l = &ifc->lifc; *l != nil && *l != lifc; l = &(*l)->next)
        ;
    if(*l == nil)
        return "address not on this interface";
    *l = lifc->next;

    /* disassociate any addresses */
    while(lifc->link)
        remselfcache(f, ifc, lifc, lifc->link->self->a);

    /* remove the route for this logical interface */
    if(isv4(lifc->local))
        v4delroute(f, lifc->remote+IPv4off, lifc->mask+IPv4off, 1);
    <<[[ipifcremlifc()]] if ipv6 local>>

    free(lifc);
    return nil;
}
@





<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "unbind") == 0)
    return ipifcunbind(ifc);
@

<<function ipifcunbind>>=
/*
 *  detach a device from an interface, close the interface
 *  called with ifc->conv closed
 */
static char*
ipifcunbind(Ipifc *ifc)
{
    char *err;

    if(waserror()){
        wunlock(ifc);
        nexterror();
    }
    wlock(ifc);

    /* dissociate routes */
    if(ifc->m != nil && ifc->m->unbindonclose == false)
        ifc->conv->inuse--;
    ifc->ifcid++;

    /* disassociate logical interfaces (before zeroing ifc->arg) */
    while(ifc->lifc){
        err = ipifcremlifc(ifc, ifc->lifc);
        /*
         * note: err non-zero means lifc not found,
         * which can't happen in this case.
         */
        if(err)
            error(err);
    }

    /* disassociate device */
    if(ifc->m && ifc->m->unbind)
        (*ifc->m->unbind)(ifc);
    memset(ifc->dev, 0, sizeof(ifc->dev));
    ifc->arg = nil;
    ifc->reassemble = false;

    /* close queues to stop queuing of packets */
    qclose(ifc->conv->rq);
    qclose(ifc->conv->wq);
    qclose(ifc->conv->sq);

    ifc->m = nil;
    wunlock(ifc);
    poperror();
    return nil;
}
@






\subsection{Unbind on close}

<<[[Medium(kernel)]] other fields>>=
bool unbindonclose;  /* if non-zero, unbind on last close */
@

<<function ipifcclose>>=
/*
 *  called after last close of ipifc data or ctl
 *  called with c locked, we must unlock
 */
static void
ipifcclose(Conv *c)
{
    Ipifc *ifc;
    Medium *m;

    ifc = (Ipifc*)c->ptcl;
    m = ifc->m;
    if(m && m->unbindonclose)
        ipifcunbind(ifc);
}
@


\chapter{Internetwork Transport, IP}

% RFC 79, Internet Protocol

\section{IP addresses}

\subsection{Parsing}

%ex: ip address 10.0.0.2
<<function v4parseip>>=
char*
v4parseip(uchar *to, char *from)
{
    int i;
    char *p;

    p = from;
    for(i = 0; i < 4 && *p; i++){
        to[i] = strtoul(p, &p, 0);
        if(*p == '.')
            p++;
    }
    switch(CLASS(to)){
    case 0:	/* class A - 1 uchar net */
    case 1:
        if(i == 3){
            to[3] = to[2];
            to[2] = to[1];
            to[1] = 0;
        } else if (i == 2){
            to[3] = to[1];
            to[1] = 0;
        }
        break;
    case 2:	/* class B - 2 uchar net */
        if(i == 3){
            to[3] = to[2];
            to[2] = 0;
        }
        break;
    }
    return p;
}
@

<<function parseip>>=
/*
 * `from' may contain an address followed by other characters,
 * at least in /boot, so we permit whitespace (and more) after the address.
 * we do ensure that "delete" cannot be parsed as "de::".
 *
 * some callers don't check the return value for errors, so
 * set `to' to something distinctive in the case of a parse error.
 */
vlong
parseip(uchar *to, char *from)
{
    int i, elipsis = 0;
    bool v4 = true;
    ulong x;
    char *p, *op;

    memset(to, 0, IPaddrlen);
    p = from;
    for(i = 0; i < IPaddrlen && ipcharok(*p); i+=2){
        op = p;
        x = strtoul(p, &p, 16);
        if((*p == '.' && i <= IPaddrlen-4) || (*p == '\0' && i == 0)){
            /* ends with v4 */
            p = v4parseip(to+i, op);
            i += 4;
            break;
        }

        /* v6: at most 4 hex digits, followed by colon or delim */
        if(x != (ushort)x || *p != ':' && !delimchar(*p)) {
            memset(to, 0, IPaddrlen);
            return -1;			/* parse error */
        }
        to[i] = x>>8;
        to[i+1] = x;
        if(*p == ':'){
            v4 = false;
            if(*++p == ':'){	/* :: is elided zero short(s) */
                if (elipsis) {
                    memset(to, 0, IPaddrlen);
                    return -1;	/* second :: */
                }
                elipsis = i+2;
                p++;
            }
        } else if (p == op)		/* strtoul made no progress? */
            break;
    }
    if (p == from || !delimchar(*p)) {
        memset(to, 0, IPaddrlen);
        return -1;				/* parse error */
    }
    if(i < IPaddrlen){
        memmove(&to[elipsis+IPaddrlen-i], &to[elipsis], i-elipsis);
        memset(&to[elipsis], 0, IPaddrlen-i);
    }

    if(v4){
        to[10] = to[11] = 0xff;
        return nhgetl(to + IPv4off);
    } else
        return 6;
}
@

\subsection{Comparisons}

<<macro ipcmp>>=
#define	ipcmp(x, y) memcmp(x, y, IPaddrlen)
@

<<macro ipmove>>=
#define	ipmove(x, y) memmove(x, y, IPaddrlen)
@

<<function equivip4>>=
bool
equivip4(uchar *a, uchar *b)
{
    int i;

    for(i = 0; i < 4; i++)
        if(a[i] != b[i])
            return false;
    return true;
}
@
%less: diff with ipcmp? used?


\section{IP header}

% now in core DS

\subsection{Byte ordering}
% Network standard byte order

% put the nhgets, hngets here

% (nh|hn)(get|put)(l|s)
% nh = network to host
% hn = host to network
% l = long
% s = short


\subsection{Checksum}

% fault tolerance! important

<<function ptclcsum>>=
ushort
ptclcsum(Block *bp, int offset, int len)
{
    uchar *addr;
    ulong losum, hisum;
    ushort csum;
    int odd, blocklen, x;

    /* Correct to front of data area */
    while(bp != nil && offset && offset >= BLEN(bp)) {
        offset -= BLEN(bp);
        bp = bp->next;
    }
    if(bp == nil)
        return 0;

    addr = bp->rp + offset;
    blocklen = BLEN(bp) - offset;

    if(bp->next == nil) {
        if(blocklen < len)
            len = blocklen;
        return ~ptclbsum(addr, len) & 0xffff;
    }

    losum = 0;
    hisum = 0;

    odd = 0;
    while(len) {
        x = blocklen;
        if(len < x)
            x = len;

        csum = ptclbsum(addr, x);
        if(odd)
            hisum += csum;
        else
            losum += csum;
        odd = (odd+x) & 1;
        len -= x;

        bp = bp->next;
        if(bp == nil)
            break;
        blocklen = BLEN(bp);
        addr = bp->rp;
    }

    losum += hisum>>8;
    losum += (hisum&0xff)<<8;
    while((csum = losum>>16) != 0)
        losum = csum + (losum & 0xffff);

    return ~losum & 0xffff;
}
@


<<function ipcsum>>=
ushort
ipcsum(uchar *addr)
{
    int len;
    ulong sum;

    sum = 0;
    len = (addr[0]&0xf)<<2;

    while(len > 0) {
        sum += addr[0]<<8 | addr[1] ;
        len -= 2;
        addr += 2;
    }

    sum = (sum & 0xffff) + (sum >> 16);
    sum = (sum & 0xffff) + (sum >> 16);

    return (sum^0xffff);
}
@

\section{IP Fragments}

<<function ipfragfree4>>=
/*
 * ipfragfree4 - Free a list of fragments - assume hold fraglock4
 */
void
ipfragfree4(IP *ip, Fragment4 *frag)
{
    Fragment4 *fl, **l;

    if(frag->blist)
        freeblist(frag->blist);

    frag->src = 0;
    frag->id = 0;
    frag->blist = nil;

    l = &ip->flisthead4;
    for(fl = *l; fl; fl = fl->next) {
        if(fl == frag) {
            *l = frag->next;
            break;
        }
        l = &fl->next;
    }

    frag->next = ip->fragfree4;
    ip->fragfree4 = frag;

}
@

<<function ipfragallo4>>=
/*
 * ipfragallo4 - allocate a reassembly queue - assume hold fraglock4
 */
Fragment4 *
ipfragallo4(IP *ip)
{
    Fragment4 *f;

    while(ip->fragfree4 == nil) {
        /* free last entry on fraglist */
        for(f = ip->flisthead4; f->next; f = f->next)
            ;
        ipfragfree4(ip, f);
    }
    f = ip->fragfree4;
    ip->fragfree4 = f->next;
    f->next = ip->flisthead4;
    ip->flisthead4 = f;
    f->age = NOW + 30000;

    return f;
}
@



\section{IO}

\subsection{Writing, [[ipoput4()]]}
% IP out-put v4

% syswrite(..., /net/x/y/data) -> udpkick | ... -> <>
% assume bp has already an IP header with many fields already set (e.g. dst)
<<function ipoput4>>=
int
ipoput4(Fs *f, Block *bp, bool gating, int ttl, int tos, Conv *c)
{
    IP *ip;
    Ip4hdr *eh;
    Ipifc *ifc;
    Route *r, *sr;
    uchar *gate;
    int len, medialen;
    int rv = OK_0;

    <<[[ipoput4()]] locals>>

    ip = f->ip;

    /* Fill out the ip header */
    eh = (Ip4hdr*)(bp->rp);

    ip->stats[OutRequests]++;

    /* Number of uchars in data and ip header to write */
    len = blocklen(bp);

    <<[[ipoput4()]] if gating>>

    <<[[ipoput4()]] error if too big packet of length len>>

    // Finding the route for the destination!
    r = v4lookup(f, eh->dst, c);
    <<[[ipoput4()]] error if no route r>>

    ifc = r->ifc;
    <<[[ipoput4()]] set gate according to type of route>>

    if(!gating) {
        eh->vihl = IP_VER4|IP_HLEN4;
        eh->tos = tos;
    }
    eh->ttl = ttl;

    <<[[ipoput4()]] rlock ifc, goto free if cant>>
    <<[[ipoput4()]] error if no medium attached to interface ifc>>

    /* If we dont need to fragment just send it */
    <<[[ipoput4()]] if manual fragmentation setting>>
    else
        medialen = ifc->maxtu - ifc->m->hsize;

    <<[[ipoput4()]] if no need to fragment, write simply to medium and return>>
    <<[[ipoput4()]] else, need to fragment>>

raise:
    runlock(ifc);
    poperror();
free:
    freeblist(bp);
    return rv;
}
@


\subsubsection{Header constants}

<<constant IP_VER4>>=
IP_VER4=  0x40,
@
<<constant IP_HLEN4>>=
IP_HLEN4= 5,    /* v4: Header length in words */
@

\subsubsection{Finding the gateway}

<<[[ipoput4()]] set gate according to type of route>>=
if(r->type & (Rifc|Runi))
    gate = eh->dst;
else
<<[[ipoput4()]] adjust gate and ifc if broadcast or multicast case>>
else
    gate = r->v4.gate;
@

\subsubsection{Small send}

% setting id field, increment id4

<<[[ipoput4()]] if no need to fragment, write simply to medium and return>>=
if(len <= medialen) {
    if(!gating)
        hnputs(eh->id, incref(&ip->id4));
    hnputs(eh->length, len);
    // no fragment
    if(!gating){
        eh->frag[0] = 0;
        eh->frag[1] = 0;
    }
    eh->cksum[0] = 0;
    eh->cksum[1] = 0;
    hnputs(eh->cksum, ipcsum(&eh->vihl));
    assert(bp->next == nil);

    // Medium dispatch
    ifc->m->bwrite(ifc, bp, V4, gate);

    runlock(ifc);
    poperror();
    return OK_0;
}
@

\subsubsection{Fragmentation}

% Note that different from TCP packeting and reliable
% reordering. Here it's a packet to send through an hardware medium,
% e.g ethernet, it's reliable, there is no long distance. You fragment
% the packet to go to the gateway and the gateway will reassemble it
% and maybe refragment if it's medium also has a limited capacity.
% The order is always correct.

<<[[ipoput4()]] locals>>=
Ip4hdr *feh;
ulong fragoff;
Block *xp, *nb;
int lid, seglen, chunk, dlen, blklen, offset;
@

<<[[ipoput4()]] else, need to fragment>>=

if(eh->frag[0] & (IP_DF>>8)){
    if (!gating) 
      print("%V: DF set\n", eh->dst);
    ip->stats[FragFails]++;
    ip->stats[OutDiscards]++;
    icmpcantfrag(f, bp, medialen);
    netlog(f, Logip, "%V: eh->frag[0] & (IP_DF>>8)\n", eh->dst);
    goto raise;
}

seglen = (medialen - IP4HDR) & ~7;
if(seglen < 8){
    ip->stats[FragFails]++;
    ip->stats[OutDiscards]++;
    netlog(f, Logip, "%V seglen < 8\n", eh->dst);
    goto raise;
}

dlen = len - IP4HDR;
xp = bp;
if(gating)
    lid = nhgets(eh->id);
else
    lid = incref(&ip->id4);

offset = IP4HDR;
while(xp != nil && offset && offset >= BLEN(xp)) {
    offset -= BLEN(xp);
    xp = xp->next;
}
xp->rp += offset;

if(gating)
    fragoff = nhgets(eh->frag)<<3;
else
    fragoff = 0;
dlen += fragoff;

for(; fragoff < dlen; fragoff += seglen) {
    nb = allocb(IP4HDR+seglen);
    feh = (Ip4hdr*)(nb->rp);

    memmove(nb->wp, eh, IP4HDR);
    nb->wp += IP4HDR;

    if((fragoff + seglen) >= dlen) {
        seglen = dlen - fragoff;
        hnputs(feh->frag, fragoff>>3);
    }
    else
        hnputs(feh->frag, (fragoff>>3)|IP_MF);

    hnputs(feh->length, seglen + IP4HDR);
    hnputs(feh->id, lid);

    /* Copy up the data area */
    chunk = seglen;
    while(chunk) {
        if(!xp) {
            ip->stats[OutDiscards]++;
            ip->stats[FragFails]++;
            freeblist(nb);
            netlog(f, Logip, "!xp: chunk %d\n", chunk);
            goto raise;
        }
        blklen = chunk;
        if(BLEN(xp) < chunk)
            blklen = BLEN(xp);
        memmove(nb->wp, xp->rp, blklen);
        nb->wp += blklen;
        xp->rp += blklen;
        chunk -= blklen;
        if(xp->rp == xp->wp)
            xp = xp->next;
    }

    feh->cksum[0] = 0;
    feh->cksum[1] = 0;
    hnputs(feh->cksum, ipcsum(&feh->vihl));

    // Medium dispatch, send this fragment
    ifc->m->bwrite(ifc, nb, V4, gate);

    ip->stats[FragCreates]++;
}
ip->stats[FragOKs]++;
@


\subsubsection{Error managment}

<<constant IP_MAX>>=
IP_MAX=   64*1024,  /* Max. Internet packet size, v4 & v6 */
@

<<[[ipoput4()]] error if too big packet of length len>>=
if(len >= IP_MAX){
    ip->stats[OutDiscards]++;
    netlog(f, Logip, "exceeded ip max size %V\n", eh->dst);
    goto free;
}
@

<<[[ipoput4()]] error if no route r>>=
if(r == nil){
    ip->stats[OutNoRoutes]++;
    netlog(f, Logip, "no interface %V\n", eh->dst);
    rv = -1;
    goto free;
}
@

<<[[ipoput4()]] error if no medium attached to interface ifc>>=
if(ifc->m == nil)
    goto raise;
@

<<[[ipoput4()]] rlock ifc, goto free if cant>>=
if(!canrlock(ifc))
    goto free;
if(waserror()){
    runlock(ifc);
    nexterror();
}
@

\subsection{Reading, [[ipiput4()]]}

% here you don't know what is the destination conversation! As opposed to
% ipoput, here there is not yet any associated Conv.
% This function actually do dispatch the packet to the right protocol,
% which then will possibly dispatch to the right conversation (or create
% a new one) 

% loopbackread | network interrupt?? -> <>
<<function ipiput4>>=
void
ipiput4(Fs *f, Ipifc *ifc, Block *bp)
{
    IP *ip;
    Ip4hdr *h;
    uchar v6dst[IPaddrlen];
    // enum<protocol_type>
    int proto;
    Proto *p;
    bool notforme;
    <<[[ipiput4()]] locals>>

    <<[[ipiput4()]] call ipiput6 if block is not ipv4>>

    ip = f->ip;
    ip->stats[InReceives]++;

    <<[[ipiput4()]] ensure we have all the header in the first block>>

    h = (Ip4hdr*)(bp->rp);

    <<[[ipiput4()]] check header checksum>>

    v4tov6(v6dst, h->dst);
    notforme = ipforme(f, v6dst) == 0;

    <<[[ipiput4()]] check header length and version>>

    <<[[ipiput4()]] if notforme>>
    // else have a ipforme

    <<[[ipiput4()]] possibly defragment and reassemble>>

    /* don't let any frag info go up the stack */
    h->frag[0] = 0;
    h->frag[1] = 0;

    proto = h->proto;
    p = Fsrcvpcol(f, proto);

    if(p != nil && p->rcv != nil) {
        ip->stats[InDelivers]++;

        // Protocol dispatch
        (*p->rcv)(p, ifc, bp);
        return;
    }

    ip->stats[InDiscards]++;
    ip->stats[InUnknownProtos]++;
    freeblist(bp);
}
@

\subsubsection{Checks}

<<[[ipiput4()]] check header checksum>>=
/* dump anything that whose header doesn't checksum */
if((bp->flag & Bipck) == 0 && ipcsum(&h->vihl)) {
    ip->stats[InHdrErrors]++;
    netlog(f, Logip, "ip: checksum error %V\n", h->src);
    freeblist(bp);
    return;
}
@

<<[[ipiput4()]] locals>>=
int hl;
int olen;
uchar *dp;
@

<<[[ipiput4()]] check header length and version>>=
/* Check header length and version */
if((h->vihl&0x0F) != IP_HLEN4) {
    hl = (h->vihl&0xF)<<2;
    if(hl < (IP_HLEN4<<2)) {
        ip->stats[InHdrErrors]++;
        netlog(f, Logip, "ip: %V bad hivl %ux\n", h->src, h->vihl);
        freeblist(bp);
        return;
    }
    /* If this is not routed strip off the options */
    if(notforme == false) {
        olen = nhgets(h->length);
        dp = bp->rp + (hl - (IP_HLEN4<<2));
        memmove(dp, h, IP_HLEN4<<2);
        bp->rp = dp;
        h = (Ip4hdr*)(bp->rp);
        h->vihl = (IP_VER4|IP_HLEN4);
        hnputs(h->length, olen-hl+(IP_HLEN4<<2));
    }
}
@

\subsubsection{Protocol dispatching}
% protocol demultiplexing

<<function Fsrcvpcol>>=
Proto*
Fsrcvpcol(Fs* f, uchar proto)
{
   return f->t2p[proto];
}
@
%dead?
%    <<[[Fsrcvpcol()]] if ipmux>>
%    else

\subsubsection{Small receive}

\subsubsection{Reassembling}
% defragmentation

<<[[ipiput4()]] locals>>=
ushort frag;
@

<<[[ipiput4()]] possibly defragment and reassemble>>=
frag = nhgets(h->frag);
if(frag) {
    h->tos = 0;
    if(frag & IP_MF)
        h->tos = 1;
    bp = ip4reassemble(ip, frag, bp, h);
    if(bp == nil)
        return;
    h = (Ip4hdr*)(bp->rp);
}
@

<<function ip4reassemble>>=
Block*
ip4reassemble(IP *ip, int offset, Block *bp, Ip4hdr *ih)
{
    int fend;
    ushort id;
    Fragment4 *f, *fnext;
    ulong src, dst;
    Block *bl, **l, *last, *prev;
    int ovlap, len, fragsize, pktposn;

    src = nhgetl(ih->src);
    dst = nhgetl(ih->dst);
    id = nhgets(ih->id);

    /*
     *  block lists are too hard, pullupblock into a single block
     */
    if(bp->next){
        bp = pullupblock(bp, blocklen(bp));
        ih = (Ip4hdr*)(bp->rp);
    }

    qlock(&ip->fraglock4);

    /*
     *  find a reassembly queue for this fragment
     */
    for(f = ip->flisthead4; f; f = fnext){
        fnext = f->next;    /* because ipfragfree4 changes the list */
        if(f->src == src && f->dst == dst && f->id == id)
            break;
        if(f->age < NOW){
            ip->stats[ReasmTimeout]++;
            ipfragfree4(ip, f);
        }
    }

    /*
     *  if this isn't a fragmented packet, accept it
     *  and get rid of any fragments that might go
     *  with it.
     */
    if(!ih->tos && (offset & ~(IP_MF|IP_DF)) == 0) {
        if(f != nil) {
            ipfragfree4(ip, f);
            ip->stats[ReasmFails]++;
        }
        qunlock(&ip->fraglock4);
        return bp;
    }

    if(bp->base+IPFRAGSZ >= bp->rp){
        bp = padblock(bp, IPFRAGSZ);
        bp->rp += IPFRAGSZ;
    }

    BKFG(bp)->foff = offset<<3;
    BKFG(bp)->flen = nhgets(ih->length)-IP4HDR;

    /* First fragment allocates a reassembly queue */
    if(f == nil) {
        f = ipfragallo4(ip);
        f->id = id;
        f->src = src;
        f->dst = dst;

        f->blist = bp;

        qunlock(&ip->fraglock4);
        ip->stats[ReasmReqds]++;
        return nil;
    }

    /*
     *  find the new fragment's position in the queue
     */
    prev = nil;
    l = &f->blist;
    bl = f->blist;
    while(bl != nil && BKFG(bp)->foff > BKFG(bl)->foff) {
        prev = bl;
        l = &bl->next;
        bl = bl->next;
    }

    /* Check overlap of a previous fragment - trim away as necessary */
    if(prev) {
        ovlap = BKFG(prev)->foff + BKFG(prev)->flen - BKFG(bp)->foff;
        if(ovlap > 0) {
            if(ovlap >= BKFG(bp)->flen) {
                freeblist(bp);
                qunlock(&ip->fraglock4);
                return nil;
            }
            BKFG(prev)->flen -= ovlap;
        }
    }

    /* Link onto assembly queue */
    bp->next = *l;
    *l = bp;

    /* Check to see if succeeding segments overlap */
    if(bp->next) {
        l = &bp->next;
        fend = BKFG(bp)->foff + BKFG(bp)->flen;
        /* Take completely covered segments out */
        while(*l) {
            ovlap = fend - BKFG(*l)->foff;
            if(ovlap <= 0)
                break;
            if(ovlap < BKFG(*l)->flen) {
                BKFG(*l)->flen -= ovlap;
                BKFG(*l)->foff += ovlap;
                /* move up ih hdrs */
                memmove((*l)->rp + ovlap, (*l)->rp, IP4HDR);
                (*l)->rp += ovlap;
                break;
            }
            last = (*l)->next;
            (*l)->next = nil;
            freeblist(*l);
            *l = last;
        }
    }

    /*
     *  look for a complete packet.  if we get to a fragment
     *  without IP_MF set, we're done.
     */
    pktposn = 0;
    for(bl = f->blist; bl; bl = bl->next) {
        if(BKFG(bl)->foff != pktposn)
            break;
        if((BLKIP(bl)->frag[0]&(IP_MF>>8)) == 0) {
            bl = f->blist;
            len = nhgets(BLKIP(bl)->length);
            bl->wp = bl->rp + len;

            /* Pullup all the fragment headers and
             * return a complete packet
             */
            for(bl = bl->next; bl; bl = bl->next) {
                fragsize = BKFG(bl)->flen;
                len += fragsize;
                bl->rp += IP4HDR;
                bl->wp = bl->rp + fragsize;
            }

            bl = f->blist;
            f->blist = nil;
            ipfragfree4(ip, f);
            ih = BLKIP(bl);
            hnputs(ih->length, len);
            qunlock(&ip->fraglock4);
            ip->stats[ReasmOKs]++;
            return bl;
        }
        pktposn += BKFG(bl)->flen;
    }
    qunlock(&ip->fraglock4);
    return nil;
}
@


\subsubsection{Error managment}

\subsubsection{Misc}

<<[[ipiput4()]] ensure we have all the header in the first block>>=
/*
 *  Ensure we have all the header info in the first
 *  block.  Make life easier for other protocols by
 *  collecting up to the first 64 bytes in the first block.
 */
if(BLEN(bp) < 64) {
    hl = blocklen(bp);
    if(hl < IP4HDR)
        hl = IP4HDR;
    if(hl > 64)
        hl = 64;
    bp = pullupblock(bp, hl);
    if(bp == nil)
        return;
}
@

\section{Advanced features}

\subsection{Gating}

<<[[ipoput4()]] if gating>>=
if(gating){
    chunk = nhgets(eh->length);
    if(chunk > len){
        ip->stats[OutDiscards]++;
        netlog(f, Logip, "short gated packet\n");
        goto free;
    }
    if(chunk < len)
        len = chunk;
}
@

\subsection{Manual fragmentation setting}

<<[[ipoput4()]] if manual fragmentation setting>>=
if(c && c->maxfragsize && c->maxfragsize < ifc->maxtu)
    medialen = c->maxfragsize - ifc->m->hsize;
@

<<[[Conv(kernel)]] other fields>>=
// option<int>, None = 0
int maxfragsize;    /* If set, used for fragmentation */
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "maxfragsize") == 0){
    if(cb->nf < 2)
        error("maxfragsize needs size");

    cv->maxfragsize = (int)strtol(cb->f[1], nil, 0);

} 
@

% no framentation IP_DF here

\subsection{Routing}
% Router?

<<[[ipiput4()]] locals>>=
int hop, tos;
Route *r;
Conv conv;
@

<<[[ipiput4()]] if notforme>>=
    /* route */
    if(notforme) {
        if(!ip->iprouting){
            freeblist(bp);
            return;
        }

        /* don't forward to source's network */
        memset(&conv, 0, sizeof conv);
        conv.r = nil;
        r = v4lookup(f, h->dst, &conv);
        if(r == nil || r->ifc == ifc){
            ip->stats[OutDiscards]++;
            freeblist(bp);
            return;
        }

        /* don't forward if packet has timed out */
        hop = h->ttl;
        if(hop < 1) {
            ip->stats[InHdrErrors]++;
            icmpttlexceeded(f, ifc->lifc->local, bp);
            freeblist(bp);
            return;
        }

        /* reassemble if the interface expects it */
        if(r->ifc == nil) panic("nil route rfc");
        if(r->ifc->reassemble){
            frag = nhgets(h->frag);
            if(frag) {
                h->tos = 0;
                if(frag & IP_MF)
                    h->tos = 1;
                bp = ip4reassemble(ip, frag, bp, h);
                if(bp == nil)
                    return;
                h = (Ip4hdr*)(bp->rp);
            }
        }

        ip->stats[ForwDatagrams]++;
        tos = h->tos;
        hop = h->ttl;

        ipoput4(f, bp, true, hop - 1, tos, &conv);

        return;
    }
@

<<[[IP(kernel)]] routing fields>>=
bool iprouting;  /* true if we route like a gateway */
@

\subsection{Reassembling}

<<[[Ipifc(kernel)]] other fields>>=
bool reassemble; /* reassemble IP packets before forwarding */
@

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "reassemble") == 0){
    ifc->reassemble = true;
    return nil;
}
@


%\subsection{IP multiplexer}

%dead:
%<<[[Fs(kernel)]] other fields>>=
%Proto*  ipmux;      /* kludge for finding an ip multiplexor */
%@
%
%<<[[Fsrcvpcol()]] if ipmux>>=
%if(f->ipmux)
%    return f->ipmux;
%@



\chapter{Physical Transport, Ethernet}

% ethernet = CSMA-CD (carrier sense multiple access - collision detection)
% with smart binary exponential backoff with random variation when have
% collision.

% ethernet address on top of (CS)MA.




\section{Ethernet addresses}

\subsection{Parsing}

%ex: mac address f8:ed:a5:74:92:a1
% strtoul? uchar because ip are 4 integers between 0 and 255
<<function parseether>>=
errorneg1
parseether(uchar *to, char *from)
{
    char nip[4];
    char *p;
    int i;

    p = from;
    for(i = 0; i < 6; i++){
        if(*p == '\0')
            return ERROR_NEG1;
        nip[0] = *p++;
        if(*p == '\0')
            return ERROR_NEG1;
        nip[1] = *p++;
        nip[2] = '\0';
        to[i] = strtoul(nip, 0, 16);
        if(*p == ':')
            p++;
    }
    return OK_0;
}
@

\subsection{[[/net/etherx/addr]]}

<<function myetheraddr>>=
errorneg1
myetheraddr(uchar *to, char *dev)
{
    int n, fd;
    char buf[256];

    if(*dev == '/')
        sprint(buf, "%s/addr", dev);
    else
        sprint(buf, "/net/%s/addr", dev);

    fd = open(buf, OREAD);
    if(fd < 0)
        return ERROR_NEG1;

    n = read(fd, buf, sizeof buf -1 );
    close(fd);
    if(n <= 0)
        return ERROR_NEG1;
    buf[n] = '\0';

    parseether(to, buf);
    return OK_0;
}
@

\section{Ethernet header}

<<struct Etherhdr>>=
struct Etherhdr
{
    uchar   d[6];
    uchar   s[6];
    uchar   t[2];
};
@
%typedef byte etheraddr[6]

% ethermedium.c

\section{Ethernet packet}

<<struct Etherpkt>>=
struct Etherpkt
{
  uchar d[Eaddrlen];
  uchar s[Eaddrlen];
  uchar type[2];

  uchar data[1500];
};
@
% netif.h

\section{IO}

\subsection{Writing}

\subsection{Reading}

\section{Advanced features}


\chapter{Finding Machines Locally, ARP}

%XXX
<<[[Medium(kernel)]] address resolution methods>>=
/* address resolution */
void  (*ares)(Fs*, int, uchar*, uchar*, int, int);  /* resolve */
void  (*areg)(Ipifc*, uchar*);      /* register */
@


<<[[Fs(kernel)]] arp fields>>=
Arp *arp;
@


<<struct Arp>>=
/*
 *  one per Fs
 */
struct Arp
{
    Arpent  *rxmt;
    Proc    *rxmitp;    /* neib sol re-transmit proc */

    Rendez  rxmtq;
    Block   *dropf, *dropl;

    Arpent  *hash[NHASH];
    Arpent  cache[NCACHE];

    // Extra
    QLock;
    <<[[Arp]] extra fields>>

};
@

<<[[Arp]] extra fields>>=
// ref<Fs>, reverse of Fs.arp
Fs  *f;
@


<<struct Arpent>>=
struct Arpent
{
  uchar ip[IPaddrlen];
  uchar mac[MAClen];

  Medium  *type;      /* media type */

  Block*  hold;
  Block*  last;
  uint  ctime;      /* time entry was created or refreshed */
  uint  utime;      /* time entry was last used */
  uchar state;
  Arpent  *nextrxt;   /* re-transmit chain */
  uint  rtime;      /* time for next retransmission */
  uchar rxtsrem;

  Ipifc *ifc;
  uchar ifcid;      /* must match ifc->id */

  // Extra
  Arpent* hash;
};
@

\section{Initialisation}

% ipattach -> ipgetfs -> <>
<<function arpinit>>=
void
arpinit(Fs *f)
{
    f->arp = smalloc(sizeof(Arp));
    f->arp->f = f;
    f->arp->rxmt = nil;
    f->arp->dropf = f->arp->dropl = nil;
    kproc("rxmitproc", rxmitproc, f->arp);
}
@

<<function rxmitproc>>=
static void
rxmitproc(void *v)
{
    Arp *arp = v;
    long wakeupat;

    arp->rxmitp = up;
    //print("arp rxmitproc started\n");
    if(waserror()){
        arp->rxmitp = 0;
        pexit("hangup", 1);
    }
    for(;;){
        wakeupat = rxmitsols(arp);
        if(wakeupat == 0)
            sleep(&arp->rxmtq, rxready, v);
        else if(wakeupat > ReTransTimer/4)
            tsleep(&arp->rxmtq, returnfalse, 0, wakeupat);
    }
}
@


\section{[[/net/arp]]}

% See Qarp def in enum qid.

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qarp:
    p = "arp";
    prot = 0664;
    break;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qarp:
case Qiproute:
    if(omode != OREAD && !iseve())
        error(Eperm);
    break;
@

\subsection{Reading}

<<[[ipread()]] switch TYPE qid cases>>=
case Qarp:
    return arpread(f->arp, a, offset, n);
@

<<function arpread>>=
int
arpread(Arp *arp, char *p, ulong offset, int len)
{
    Arpent *a;
    int n;
    char mac[2*MAClen+1];

    if(offset % Alinelen)
        return 0;

    offset = offset/Alinelen;
    len = len/Alinelen;

    n = 0;
    for(a = arp->cache; len > 0 && a < &arp->cache[NCACHE]; a++){
        if(a->state == 0)
            continue;
        if(offset > 0){
            offset--;
            continue;
        }
        len--;
        qlock(arp);
        convmac(mac, &mac[sizeof mac], a->mac, a->type->maclen);
        n += snprint(p+n, Alinelen+1, aformat, a->type->name,
            arpstate[a->state], a->ip, mac);    /* +1 for NUL */
        qunlock(arp);
    }

    return n;
}
@

\subsection{Writing}

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qarp:
    return arpwrite(f, a, n);
@

<<function arpwrite>>=
int
arpwrite(Fs *fs, char *s, int len)
{
    int n;
    Route *r;
    Arp *arp;
    Block *bp;
    Arpent *a, *fl, **l;
    Medium *m;
    char *f[4], buf[256];
    uchar ip[IPaddrlen], mac[MAClen];

    arp = fs->arp;

    if(len == 0)
        error(Ebadarp);
    if(len >= sizeof(buf))
        len = sizeof(buf)-1;
    strncpy(buf, s, len);
    buf[len] = 0;
    if(len > 0 && buf[len-1] == '\n')
        buf[len-1] = 0;

    n = getfields(buf, f, 4, 1, " ");
    if(strcmp(f[0], "flush") == 0){
        qlock(arp);
        for(a = arp->cache; a < &arp->cache[NCACHE]; a++){
            memset(a->ip, 0, sizeof(a->ip));
            memset(a->mac, 0, sizeof(a->mac));
            a->hash = nil;
            a->state = 0;
            a->utime = 0;
            while(a->hold != nil){
                bp = a->hold->list;
                freeblist(a->hold);
                a->hold = bp;
            }
        }
        memset(arp->hash, 0, sizeof(arp->hash));
        /* clear all pkts on these lists (rxmt, dropf/l) */
        arp->rxmt = nil;
        arp->dropf = nil;
        arp->dropl = nil;
        qunlock(arp);
    } else if(strcmp(f[0], "add") == 0){
        switch(n){
        default:
            error(Ebadarg);
        case 3:
            if (parseip(ip, f[1]) == -1)
                error(Ebadip);
            if(isv4(ip))
                r = v4lookup(fs, ip+IPv4off, nil);
            else
                r = v6lookup(fs, ip, nil);
            if(r == nil)
                error("Destination unreachable");
            m = r->ifc->m;
            n = parsemac(mac, f[2], m->maclen);
            break;
        case 4:
            m = ipfindmedium(f[1]);
            if(m == nil)
                error(Ebadarp);
            if (parseip(ip, f[2]) == -1)
                error(Ebadip);
            n = parsemac(mac, f[3], m->maclen);
            break;
        }

        if(m->ares == nil)
            error(Ebadarp);

        m->ares(fs, V6, ip, mac, n, 0);
    } else if(strcmp(f[0], "del") == 0){
        if(n != 2)
            error(Ebadarg);

        if (parseip(ip, f[1]) == -1)
            error(Ebadip);
        qlock(arp);

        l = &arp->hash[haship(ip)];
        for(a = *l; a; a = a->hash){
            if(memcmp(ip, a->ip, sizeof(a->ip)) == 0){
                *l = a->hash;
                break;
            }
            l = &a->hash;
        }

        if(a){
            /* take out of re-transmit chain */
            l = &arp->rxmt;
            for(fl = *l; fl; fl = fl->nextrxt){
                if(fl == a){
                    *l = a->nextrxt;
                    break;
                }
                l = &fl->nextrxt;
            }

            a->nextrxt = nil;
            a->hash = nil;
            a->hold = nil;
            a->last = nil;
            a->ifc = nil;
            memset(a->ip, 0, sizeof(a->ip));
            memset(a->mac, 0, sizeof(a->mac));
        }
        qunlock(arp);
    } else
        error(Ebadarp);

    return len;
}
@



\chapter{Finding Machines Globally, Routes}


% ARP allows local routing
% /net/iproute allows inter-network routing, find gateway

% Have seen already the Route DS in Core DS chapter
% and the v4root forest in Fs.

\section{[[v4lookup()]]}

% ipoput4 | ... -> <>
% a is a ipv4!
<<function v4lookup>>=
Route*
v4lookup(Fs *f, uchar *a, Conv *c)
{
    Route *p, *q;
    ulong la;
    <<[[v4lookup()]] locals>>

    <<[[v4lookup()]] return cached route if still valid route>>

    la = nhgetl(a);
    q = nil;
    <<[[v4lookup()]] ternary search for route q for la in route forest>>
    <<[[v4lookup()]] make sure route q has an up to date ifc>>

    if(c != nil){
        c->r = q;
        c->rgen = v4routegeneration;
    }

    return q;
}
@
% maybe will return nil

<<[[v4lookup()]] ternary search for route q for la in route forest>>=
for(p=f->v4root[V4H(la)]; p;)
    if(la >= p->v4.address) {
        if(la <= p->v4.endaddress) {
            q = p;
            p = p->mid;
        } else
            p = p->right;
    } else
        p = p->left;
@

<<macro V4H>>=
#define V4H(a)  ((a&0x07ffffff)>>(32-Lroot-5))
@
% ??? Lroot = 10, so why the -5?


%todo: ok so what happen if ip really out of range of current network?
% no entry then? how find one?
% the basic routes added in ipifcadd are enough?


<<[[v4lookup()]] return cached route if still valid route>>=
if(c != nil && c->r != nil && c->r->ifc != nil && c->rgen == v4routegeneration)
    return c->r;
@



<<[[v4lookup()]] locals>>=
uchar gate[IPaddrlen];
Ipifc *ifc;
@
<<[[v4lookup()]] make sure route q has an up to date ifc>>=
if(q && (q->ifc == nil || q->ifcid != q->ifc->ifcid)){
    if(q->type & Rifc) {
        hnputl(gate+IPv4off, q->v4.address);
        memmove(gate, v4prefix, IPv4off);
    } else
        v4tov6(gate, q->v4.gate);

    ifc = findipifc(f, gate, q->type);
    if(ifc == nil)
        return nil;
    q->ifc = ifc;
    q->ifcid = ifc->ifcid;
}
@
% in v4addroute actually you do very little, you don't set
% ifcid and ifc so this path will be triggered for each first
% v4lookup

\section{[[findipifc()]]}

<<function findipifc>>=
/*
 *  find the ifc on same net as the remote system.  If none,
 *  return nil.
 */
Ipifc*
findipifc(Fs *f, uchar *remote, int type)
{
    Ipifc *ifc, *x;
    Iplifc *lifc;
    Conv **cp, **e;
    uchar gnet[IPaddrlen], xmask[IPaddrlen];

    x = nil;
    memset(xmask, 0, IPaddrlen);

    /* find most specific match */
    e = &f->ipifc->conv[f->ipifc->nc];
    for(cp = f->ipifc->conv; cp < e; cp++){
        if(*cp == nil)
            continue;
        ifc = (Ipifc*)(*cp)->ptcl;
        for(lifc = ifc->lifc; lifc; lifc = lifc->next){
            maskip(remote, lifc->mask, gnet);
            if(ipcmp(gnet, lifc->net) == 0){
                if(x == nil || ipcmp(lifc->mask, xmask) > 0){
                    x = ifc;
                    ipmove(xmask, lifc->mask);
                }
            }
        }
    }
    if(x != nil)
        return x;

    <<[[findipifc()]] if broadcast or multicast route>>
    return nil;
}
@

\section{Adding routes, [[v4addroute()]]}

% in ipifcadd()
%        v4addroute(f, tifc, rem+IPv4off, mask+IPv4off, rem+IPv4off, type);

% ipifcadd (type = Rifc) | routewrite | ... -> <>
% pass an ip and a gateway, but really we use 'a' only for a range
<<function v4addroute>>=
void
v4addroute(Fs *f, char *tag, uchar *a, uchar *mask, uchar *gate, int type)
{
    Route *p;
    ulong m;
    ulong sa; // start address
    ulong ea; // end address
    int h, eh;

    m = nhgetl(mask);
    sa = nhgetl(a) & m;
    ea = sa | ~m;

    eh = V4H(ea);
    for(h=V4H(sa); h<=eh; h++) {
        p = allocroute(Rv4 | type);
        p->v4.address = sa;
        p->v4.endaddress = ea;
        memmove(p->v4.gate, gate, sizeof(p->v4.gate));
        memmove(p->tag, tag, sizeof(p->tag));

        wlock(&routelock);
        addnode(f, &f->v4root[h], p);
        <<[[v4addroute()]] if f has a route queue>>
        wunlock(&routelock);
    }
    v4routegeneration++;

    ipifcaddroute(f, Rv4, a, mask, gate, type);
}
@

<<global routelock>>=
static RWlock   routelock;
@
% protects?



\section{Broadcast routes}

\section{Route managment}

<<global v4freelist>>=
/* these are used for all instances of IP */
static Route*   v4freelist;
@
% who initializes this? put = nil?

\subsection{Allocation}

<<function allocroute>>=
static Route*
allocroute(int type)
{
    Route *r;
    int n;
    Route **l;

    if(type & Rv4){
        n = sizeof(RouteTree) + sizeof(V4route);
        l = &v4freelist;
    }
    <<[[allocroute()]] if ipv6 route>>

    r = *l;
    if(r != nil){
        *l = r->mid;
    } else {
        r = malloc(n);
        if(r == nil)
            panic("out of routing nodes");
    }
    memset(r, 0, n);

    r->type = type;
    r->ifc = nil;
    r->ref = 1;

    return r;
}
@
% tricky malloc here! optimisation, but makes a few things more
% complicated

\subsection{Free}

<<function freeroute>>=
static void
freeroute(Route *r)
{
    Route **l;

    r->left = nil;
    r->right = nil;
    if(r->type & Rv4)
        l = &v4freelist;
    <<[[freeroute()]] if ipv6 route>>
    r->mid = *l;
    *l = r;
}
@

\subsection{Insertion}

<<enum _anon_ (kernel/network/ip/iproute.c)>>=
/*
 *  compare 2 v4 or v6 ranges
 */
enum
{
    Rpreceeds,
    Rfollows,
    Requals,
    Rcontains,
    Rcontained,
};
@

<<function rangecompare>>=
static int
rangecompare(Route *a, Route *b)
{
    if(a->type & Rv4){
        if(a->v4.endaddress < b->v4.address)
            return Rpreceeds;

        if(a->v4.address > b->v4.endaddress)
            return Rfollows;

        if(a->v4.address <= b->v4.address
        && a->v4.endaddress >= b->v4.endaddress){

            if(a->v4.address == b->v4.address
            && a->v4.endaddress == b->v4.endaddress)
                return Requals;
            return Rcontains;
        }
        return Rcontained;
    }
    <<[[rangecompare()]] if ipv6 routes>>
}
@


<<function addnode>>=
/*
 *  add a new node to the tree
 */
static void
addnode(Fs *f, Route **cur, Route *new)
{
    Route *p;

    p = *cur;
    if(p == 0) {
        *cur = new;
        new->depth = 1;
        return;
    }

    switch(rangecompare(new, p)){
    case Rpreceeds:
        addnode(f, &p->left, new);
        break;
    case Rfollows:
        addnode(f, &p->right, new);
        break;
    case Rcontains:
        /*
         *  if new node is superset
         *  of tree node,
         *  replace tree node and
         *  queue tree node to be
         *  merged into root.
         */
        *cur = new;
        new->depth = 1;
        addqueue(&f->queue, p);
        break;
    case Requals:
        /*
         *  supercede the old entry if the old one isn't
         *  a local interface.
         */
        if((p->type & Rifc) == 0){
            p->type = new->type;
            p->ifcid = -1;
            copygate(p, new);
        } else if(new->type & Rifc)
            p->ref++;
        freeroute(new);
        break;
    case Rcontained:
        addnode(f, &p->mid, new);
        break;
    }

    balancetree(cur);
}
@

<<function copygate>>=
static void
copygate(Route *old, Route *new)
{
    if(new->type & Rv4)
        memmove(old->v4.gate, new->v4.gate, IPv4addrlen);
    else
        memmove(old->v6.gate, new->v6.gate, IPaddrlen);
}
@


<<[[v4addroute()]] if f has a route queue>>=
while(p = f->queue) {
    f->queue = p->mid;
    walkadd(f, &f->v4root[h], p->left);
    freeroute(p);
}
@

<<[[Fs(kernel)]] routing fields>>=
Route *queue;     /* used as temp when reinjecting routes */
@

<<function walkadd>>=
/*
 *  walk down a tree adding nodes back in
 */
static void
walkadd(Fs *f, Route **root, Route *p)
{
    Route *l, *r;

    l = p->left;
    r = p->right;
    p->left = 0;
    p->right = 0;
    addnode(f, root, p);
    if(l)
        walkadd(f, root, l);
    if(r)
        walkadd(f, root, r);
}
@


<<function addqueue>>=
static void
addqueue(Route **q, Route *r)
{
    Route *l;

    if(r == nil)
        return;

    l = allocroute(r->type);
    l->mid = *q;
    *q = l;
    l->left = r;
}
@


\subsection{Balancing}

<<[[Routetree]] other fields>>=
uchar depth;
@

<<function balancetree>>=
/*
 *  balance the tree at the current node
 */
static void
balancetree(Route **cur)
{
    Route *p, *l, *r;
    int dl, dr;

    /*
     * if left and right are
     * too out of balance,
     * rotate tree node
     */
    p = *cur;
    dl = 0; if(l = p->left) dl = l->depth;
    dr = 0; if(r = p->right) dr = r->depth;

    if(dl > dr+1) {
        p->left = l->right;
        l->right = p;
        *cur = l;
        calcd(p);
        calcd(l);
    } else
    if(dr > dl+1) {
        p->right = r->left;
        r->left = p;
        *cur = r;
        calcd(p);
        calcd(r);
    } else
        calcd(p);
}
@

<<function calcd>>=
/*
 *  calculate depth
 */
static void
calcd(Route *p)
{
    Route *q;
    int d;

    if(p) {
        d = 0;
        q = p->left;
        if(q)
            d = q->depth;
        q = p->right;
        if(q && q->depth > d)
            d = q->depth;
        q = p->mid;
        if(q && q->depth > d)
            d = q->depth;
        p->depth = d+1;
    }
}
@




\section{[[/net/iproutes]]}

% See Qiproute def in enum qid.

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qiproute:
    p = "iproute";
    prot = 0664;
    break;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qiproute:
    return routeread(f, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qiproute:
    return routewrite(f, ch, a, n);
@

\subsection{Reading}

<<function routeread>>=
long
routeread(Fs *f, char *p, ulong offset, int n)
{
    Routewalk rw;

    rw.p = p;
    rw.e = p+n;
    rw.o = -offset;
    rw.walk = sprintroute;

    ipwalkroutes(f, &rw);

    return rw.p - p;
}
@

<<global rformat>>=
static char *rformat = "%-15I %-4M %-15I %4.4s %4.4s %3s\n";
@

<<function sprintroute>>=
/*
 *  this code is not in rr to reduce stack size
 */
static void
sprintroute(Route *r, Routewalk *rw)
{
    int nifc, n;
    char t[5], *iname, ifbuf[5];
    uchar addr[IPaddrlen], mask[IPaddrlen], gate[IPaddrlen];
    char *p;

    convroute(r, addr, mask, gate, t, &nifc);
    iname = "-";
    if(nifc != -1) {
        iname = ifbuf;
        snprint(ifbuf, sizeof ifbuf, "%d", nifc);
    }
    p = seprint(rw->p, rw->e, rformat, addr, mask, gate, t, r->tag, iname);
    if(rw->o < 0){
        n = p - rw->p;
        if(n > -rw->o){
            memmove(rw->p, rw->p-rw->o, n+rw->o);
            rw->p = p + rw->o;
        }
        rw->o += n;
    } else
        rw->p = p;
}
@

<<function convroute>>=
void
convroute(Route *r, uchar *addr, uchar *mask, uchar *gate, char *t, int *nifc)
{
    int i;

    if(r->type & Rv4){
        memmove(addr, v4prefix, IPv4off);
        hnputl(addr+IPv4off, r->v4.address);
        memset(mask, 0xff, IPv4off);
        hnputl(mask+IPv4off, ~(r->v4.endaddress ^ r->v4.address));
        memmove(gate, v4prefix, IPv4off);
        memmove(gate+IPv4off, r->v4.gate, IPv4addrlen);
    } else {
        for(i = 0; i < IPllen; i++){
            hnputl(addr + 4*i, r->v6.address[i]);
            hnputl(mask + 4*i, ~(r->v6.endaddress[i] ^ r->v6.address[i]));
        }
        memmove(gate, r->v6.gate, IPaddrlen);
    }

    routetype(r->type, t);

    if(r->ifc)
        *nifc = r->ifc->conv->x;
    else
        *nifc = -1;
}
@

<<function routetype>>=
void
routetype(int type, char *p)
{
    memset(p, ' ', 4);
    p[4] = 0;
    if(type & Rv4)
        *p++ = '4';
    else
        *p++ = '6';
    if(type & Rifc)
        *p++ = 'i';
    if(type & Runi)
        *p++ = 'u';
    else if(type & Rbcast)
        *p++ = 'b';
    else if(type & Rmulti)
        *p++ = 'm';
    if(type & Rptpt)
        *p = 'p';
}
@




<<function ipwalkroutes>>=
void
ipwalkroutes(Fs *f, Routewalk *rw)
{
    rlock(&routelock);
    if(rw->e > rw->p) {
        for(rw->h = 0; rw->h < nelem(f->v4root); rw->h++)
            if(rr(f->v4root[rw->h], rw) == 0)
                break;
    }
    if(rw->e > rw->p) {
        for(rw->h = 0; rw->h < nelem(f->v6root); rw->h++)
            if(rr(f->v6root[rw->h], rw) == 0)
                break;
    }
    runlock(&routelock);
}
@

<<function rr>>=
/*
 *  recurse descending tree, applying the function in Routewalk
 */
static int
rr(Route *r, Routewalk *rw)
{
    int h;

    if(rw->e <= rw->p)
        return 0;
    if(r == nil)
        return 1;

    if(rr(r->left, rw) == 0)
        return 0;

    if(r->type & Rv4)
        h = V4H(r->v4.address);
    <<[[rr()]] else if ipv6 address>>

    if(h == rw->h)
        rw->walk(r, rw);

    if(rr(r->mid, rw) == 0)
        return 0;

    return rr(r->right, rw);
}
@


\subsection{Writing}

<<function routewrite>>=
long
routewrite(Fs *f, Chan *c, char *p, int n)
{
    int h, changed;
    char *tag;
    Cmdbuf *cb;
    uchar addr[IPaddrlen];
    uchar mask[IPaddrlen];
    uchar gate[IPaddrlen];
    IPaux *a, *na;
    Route *q;

    cb = parsecmd(p, n);
    if(waserror()){
        free(cb);
        nexterror();
    }

    if(strcmp(cb->f[0], "flush") == 0){
        tag = cb->f[1];
        for(h = 0; h < nelem(f->v4root); h++)
            for(changed = 1; changed;){
                wlock(&routelock);
                changed = routeflush(f, f->v4root[h], tag);
                wunlock(&routelock);
            }
        for(h = 0; h < nelem(f->v6root); h++)
            for(changed = 1; changed;){
                wlock(&routelock);
                changed = routeflush(f, f->v6root[h], tag);
                wunlock(&routelock);
            }
    } else if(strcmp(cb->f[0], "remove") == 0){
        if(cb->nf < 3)
            error(Ebadarg);
        if (parseip(addr, cb->f[1]) == -1)
            error(Ebadip);
        parseipmask(mask, cb->f[2]);
        if(memcmp(addr, v4prefix, IPv4off) == 0)
            v4delroute(f, addr+IPv4off, mask+IPv4off, 1);
        else
            v6delroute(f, addr, mask, 1);
    } else if(strcmp(cb->f[0], "add") == 0){
        if(cb->nf < 4)
            error(Ebadarg);
        if(parseip(addr, cb->f[1]) == -1 ||
            parseip(gate, cb->f[3]) == -1)
            error(Ebadip);
        parseipmask(mask, cb->f[2]);
        tag = "none";
        if(c != nil){
            a = c->aux;
            tag = a->tag;
        }
        if(memcmp(addr, v4prefix, IPv4off) == 0)
            v4addroute(f, tag, addr+IPv4off, mask+IPv4off, gate+IPv4off, 0);
        else
            v6addroute(f, tag, addr, mask, gate, 0);
    } else if(strcmp(cb->f[0], "tag") == 0) {
        if(cb->nf < 2)
            error(Ebadarg);

        a = c->aux;
        na = newipaux(a->owner, cb->f[1]);
        c->aux = na;
        free(a);
    } else if(strcmp(cb->f[0], "route") == 0) {
        if(cb->nf < 2)
            error(Ebadarg);
        if (parseip(addr, cb->f[1]) == -1)
            error(Ebadip);

        q = iproute(f, addr);
        print("%I: ", addr);
        if(q == nil)
            print("no route\n");
        else
            printroute(q);
    }

    poperror();
    free(cb);
    return n;
}
@

<<function iproute>>=
Route *
iproute(Fs *fs, uchar *ip)
{
    if(isv4(ip))
        return v4lookup(fs, ip+IPv4off, nil);
    else
        return v6lookup(fs, ip, nil);
}
@


<<function printroute>>=
static void
printroute(Route *r)
{
    int nifc;
    char t[5], *iname, ifbuf[5];
    uchar addr[IPaddrlen], mask[IPaddrlen], gate[IPaddrlen];

    convroute(r, addr, mask, gate, t, &nifc);
    iname = "-";
    if(nifc != -1) {
        iname = ifbuf;
        snprint(ifbuf, sizeof ifbuf, "%d", nifc);
    }
    print(rformat, addr, mask, gate, t, r->tag, iname);
}
@


\section{Self cache}
% needed? opti? put in advanced features?

% who uses that???

<<[[Fs(kernel)]] other fields>>=
Ipselftab *self;
@

<<[[Iplifc(kernel)]] extra fields>>=
Iplink  *link;    /* addresses linked to this lifc */
@


% ??? -> <>
<<function ipforme>>=
/*
 *  returns
 *  0       - no match
 *  Runi
 *  Rbcast
 *  Rmcast
 */
int
ipforme(Fs *f, uchar *addr)
{
    Ipself *p;

    p = f->self->hash[hashipa(addr)];
    for(; p; p = p->next){
        if(ipcmp(addr, p->a) == 0)
            return p->type;
    }

    /* hack to say accept anything */
    if(f->self->acceptall)
        return Runi;
    return 0;
}
@



\subsection{Data structures}

<<struct Ipselftab>>=
struct Ipselftab
{
    int inited;
    bool acceptall;  /* true if an interface has the null address */

    Ipself  *hash[NHASH];   /* hash chains */

    // Extra
    QLock;

};
@
<<[[ipifcinit()]] modify f>>=
f->self = smalloc(sizeof(Ipselftab));   /* hack for ipforme */
@


<<struct Ipself>>=
/*
 *  cache of local addresses (addresses we answer to)
 */
struct Ipself
{
    uchar   type;       /* type of address */
    uchar   a[IPaddrlen];

    ulong   expire;

    //Extra
    int ref;
    Ipself  *hnext;     /* next address in the hash table */
    Iplink  *link;      /* binding twixt Ipself and Ipifc */
    Ipself  *next;      /* free list */
};
@

<<struct Iplink>>=
/* binding twixt Ipself and Iplifc */
struct Iplink
{
  ulong expire;

  Ipself  *self;
  Iplifc  *lifc;

  // Extra
  int ref;
  Iplink  *next;    /* free list */
  Iplink  *selflink;  /* next link for this local address */
  Iplink  *lifclink;  /* next link for this ifc */
};
@



\subsection{Adding IPs}

<<function addselfcache>>=
/*
 *  add to self routing cache
 *  called with c->car locked
 */
static void
addselfcache(Fs *f, Ipifc *ifc, Iplifc *lifc, uchar *a, int type)
{
    Ipself *p;
    Iplink *lp;
    int h;

    qlock(f->self);

    /* see if the address already exists */
    h = hashipa(a);
    for(p = f->self->hash[h]; p; p = p->next)
        if(memcmp(a, p->a, IPaddrlen) == 0)
            break;

    /* allocate a local address and add to hash chain */
    if(p == nil){
        p = smalloc(sizeof(*p));
        ipmove(p->a, a);
        p->type = type;
        p->next = f->self->hash[h];
        f->self->hash[h] = p;

        /* if the null address, accept all packets */
        if(ipcmp(a, v4prefix) == 0 || ipcmp(a, IPnoaddr) == 0)
            f->self->acceptall = true;
    }

    /* look for a link for this lifc */
    for(lp = p->link; lp; lp = lp->selflink)
        if(lp->lifc == lifc)
            break;

    /* allocate a lifc-to-local link and link to both */
    if(lp == nil){
        lp = smalloc(sizeof(*lp));
        lp->ref = 1;
        lp->lifc = lifc;
        lp->self = p;
        lp->selflink = p->link;
        p->link = lp;
        lp->lifclink = lifc->link;
        lifc->link = lp;

        /* add to routing table */
        if(isv4(a))
            v4addroute(f, tifc, a+IPv4off, IPallbits+IPv4off,
                a+IPv4off, type);
        else
            v6addroute(f, tifc, a, IPallbits, a, type);

        if((type & Rmulti) && ifc->m->addmulti != nil)
            (*ifc->m->addmulti)(ifc, a, lifc->local);
    } else
        lp->ref++;

    qunlock(f->self);
}
@

<<macro hashipa>>=
/* quick hash for ip addresses */
#define hashipa(a) ( ( ((a)[IPaddrlen-2]<<8) | (a)[IPaddrlen-1] )%NHASH )
@

\subsection{Removing IPs}

<<function remselfcache>>=
/*
 *  Decrement reference for this address on this link.
 *  Unlink from selftab if this is the last ref.
 *  called with c->car locked
 */
static void
remselfcache(Fs *f, Ipifc *ifc, Iplifc *lifc, uchar *a)
{
    Ipself *p, **l;
    Iplink *link, **l_self, **l_lifc;

    qlock(f->self);

    /* find the unique selftab entry */
    l = &f->self->hash[hashipa(a)];
    for(p = *l; p; p = *l){
        if(ipcmp(p->a, a) == 0)
            break;
        l = &p->next;
    }

    if(p == nil)
        goto out;

    /*
     *  walk down links from an ifc looking for one
     *  that matches the selftab entry
     */
    l_lifc = &lifc->link;
    for(link = *l_lifc; link; link = *l_lifc){
        if(link->self == p)
            break;
        l_lifc = &link->lifclink;
    }

    if(link == nil)
        goto out;

    /*
     *  walk down the links from the selftab looking for
     *  the one we just found
     */
    l_self = &p->link;
    for(link = *l_self; link; link = *l_self){
        if(link == *l_lifc)
            break;
        l_self = &link->selflink;
    }

    if(link == nil)
        panic("remselfcache");

    if(--(link->ref) != 0)
        goto out;

    if((p->type & Rmulti) && ifc->m->remmulti != nil)
        (*ifc->m->remmulti)(ifc, a, lifc->local);

    /* ref == 0, remove from both chains and free the link */
    *l_lifc = link->lifclink;
    *l_self = link->selflink;
    iplinkfree(link);

    if(p->link != nil)
        goto out;

    /* remove from routing table */
    if(isv4(a))
        v4delroute(f, a+IPv4off, IPallbits+IPv4off, 1);
    else
        v6delroute(f, a, IPallbits, 1);

    /* no more links, remove from hash and free */
    *l = p->next;
    ipselffree(p);

    /* if IPnoaddr, forget */
    if(ipcmp(a, v4prefix) == 0 || ipcmp(a, IPnoaddr) == 0)
        f->self->acceptall = false;

out:
    qunlock(f->self);
}
@

\subsection{[[/net/ipselftab]]}

<<[[Qid]] toplevel extra cases>>=
Qipselftab,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qipselftab:
    p = "ipselftab";
    prot = 0444;
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qipselftab:
    return ipselftabread(f, a, offset, n);
@

<<function ipselftabread>>=
long
ipselftabread(Fs *f, char *cp, ulong offset, int n)
{
    int i, m, nifc, off;
    Ipself *p;
    Iplink *link;
    char state[8];

    m = 0;
    off = offset;
    qlock(f->self);
    for(i = 0; i < NHASH && m < n; i++){
        for(p = f->self->hash[i]; p != nil && m < n; p = p->next){
            nifc = 0;
            for(link = p->link; link; link = link->selflink)
                nifc++;
            routetype(p->type, state);
            m += snprint(cp + m, n - m, stformat, p->a, nifc, state);
            if(off > 0){
                off -= m;
                m = 0;
            }
        }
    }
    qunlock(f->self);
    return m;
}
@

\section{Advanced features}

\subsection{Removing routes}

% ipifcremxxx -> <>
<<function v4delroute>>=
void
v4delroute(Fs *f, uchar *a, uchar *mask, bool dolock)
{
    Route **r, *p;
    Route rt;
    int h, eh;
    ulong m;

    m = nhgetl(mask);
    rt.v4.address = nhgetl(a) & m;
    rt.v4.endaddress = rt.v4.address | ~m;
    rt.type = Rv4;

    eh = V4H(rt.v4.endaddress);
    for(h=V4H(rt.v4.address); h<=eh; h++) {
        if(dolock)
            wlock(&routelock);
        r = looknode(&f->v4root[h], &rt);
        if(r) {
            p = *r;
            if(--(p->ref) == 0){
                *r = 0;
                addqueue(&f->queue, p->left);
                addqueue(&f->queue, p->mid);
                addqueue(&f->queue, p->right);
                freeroute(p);
                while(p = f->queue) {
                    f->queue = p->mid;
                    walkadd(f, &f->v4root[h], p->left);
                    freeroute(p);
                }
            }
        }
        if(dolock)
            wunlock(&routelock);
    }
    v4routegeneration++;

    ipifcremroute(f, Rv4, a, mask);
}
@


<<function looknode>>=
Route**
looknode(Route **cur, Route *r)
{
    Route *p;

    for(;;){
        p = *cur;
        if(p == 0)
            return 0;

        switch(rangecompare(r, p)){
        case Rcontains:
            return 0;
        case Rpreceeds:
            cur = &p->left;
            break;
        case Rfollows:
            cur = &p->right;
            break;
        case Rcontained:
            cur = &p->mid;
            break;
        case Requals:
            return cur;
        }
    }
}
@


\subsection{Flushing routes}

<<function routeflush>>=
/*
 *  recurse until one route is deleted
 *    returns 0 if nothing is deleted, 1 otherwise
 */
int
routeflush(Fs *f, Route *r, char *tag)
{
    if(r == nil)
        return 0;
    if(routeflush(f, r->mid, tag))
        return 1;
    if(routeflush(f, r->left, tag))
        return 1;
    if(routeflush(f, r->right, tag))
        return 1;
    if((r->type & Rifc) == 0){
        if(tag == nil || strncmp(tag, r->tag, sizeof(r->tag)) == 0){
            delroute(f, r, 0);
            return 1;
        }
    }
    return 0;
}
@


<<function delroute>>=
/*
 *  this code is not in routeflush to reduce stack size
 */
void
delroute(Fs *f, Route *r, int dolock)
{
    uchar addr[IPaddrlen];
    uchar mask[IPaddrlen];
    uchar gate[IPaddrlen];
    char t[5];
    int nifc;

    convroute(r, addr, mask, gate, t, &nifc);
    if(r->type & Rv4)
        v4delroute(f, addr+IPv4off, mask+IPv4off, dolock);
    else
        v6delroute(f, addr, mask, dolock);
}
@

\subsection{Router boards}

<<[[Medium(kernel)]] route methods>>=
/* routes for router boards */
void  (*addroute)(Ipifc *ifc, int, uchar*, uchar*, uchar*, int);
void  (*remroute)(Ipifc *ifc, int, uchar*, uchar*);
@
%dead: void  (*flushroutes)(Ipifc *ifc);

% v4addroute -> <>
<<function ipifcaddroute>>=
/*
 * distribute routes to active interfaces like the
 * TRIP linecards
 */
void
ipifcaddroute(Fs *f, int vers, uchar *addr, uchar *mask, uchar *gate, int type)
{
    Medium *m;
    Conv **cp, **e;
    Ipifc *ifc;

    e = &f->ipifc->conv[f->ipifc->nc];
    for(cp = f->ipifc->conv; cp < e; cp++){
        if(*cp != nil) {
            ifc = (Ipifc*)(*cp)->ptcl;
            m = ifc->m;
            if(m && m->addroute)
                m->addroute(ifc, vers, addr, mask, gate, type);
        }
    }
}
@

% v4delroute -> <>
<<function ipifcremroute>>=
void
ipifcremroute(Fs *f, int vers, uchar *addr, uchar *mask)
{
    Medium *m;
    Conv **cp, **e;
    Ipifc *ifc;

    e = &f->ipifc->conv[f->ipifc->nc];
    for(cp = f->ipifc->conv; cp < e; cp++){
        if(*cp != nil) {
            ifc = (Ipifc*)(*cp)->ptcl;
            m = ifc->m;
            if(m && m->remroute)
                m->remroute(ifc, vers, addr, mask);
        }
    }
}
@



\chapter{Basic Communication, UDP}
% U for Unreliable, Unordered :)
% Transmission?

%RFC 768 User Datagram Protocol

% when do ip/ipconfig then can see that 4 InDatagrams and 2 OutDatagrams
% and 2 ports :)

% Essentially IP + port if you look at UDP headers and the difference with
% just the IP header

\section{Protocol initialisation}

% ipattach -> ipgetfs -> <> (as ipprotoinit[i] <- ...)
<<function udpinit>>=
void
udpinit(Fs *fs)
{
    Proto *udp;

    udp = smalloc(sizeof(Proto));
    udp->priv = smalloc(sizeof(Udppriv));

    udp->name = "udp";
    udp->create = udpcreate;
    udp->close = udpclose;

    udp->connect = udpconnect;
    udp->announce = udpannounce;
    udp->ctl = udpctl;

    udp->rcv = udpiput;

    udp->state = udpstate;
    udp->stats = udpstats;

    udp->advise = udpadvise;

    udp->ipproto = IP_UDPPROTO;

    udp->nc = Nchans;
    udp->ptclsize = sizeof(Udpcb);

    Fsproto(fs, udp);
}
@
%less: make it a global with intializer?
% no ->inuse! because UDP is not a connected protocol? because
% it's stateless?

<<constant IP_UDPPROTO>>=
IP_UDPPROTO = 17,
@

<<constant Nchans>>=
Nchans=   1024,
@
% kernel/.../ip.h

\section{Protocol data structures}

\subsection{[[Udppriv]]}

% protocol priv
<<struct Udppriv>>=
struct Udppriv
{
    // hash<(ipaddr * port) , ref<Conv>>
    Ipht        ht;

    <<[[Udppriv]] stat fields>>
};
@
%todo: Ipht? Ip hash table? for the Conv dispatch?

\subsection{Statistics}

% C-s one of this field and you'll understand what does what :)
% which is why it can be useful to present early.
%less: or present with /net/udp/stats later?

<<[[Udppriv]] stat fields>>=
/* MIB counters */
Udpstats    ustats;
/* non-MIB stats */
ulong       csumerr;        /* checksum errors */
ulong       lenerr;         /* short packet */
@
%MIB?

<<struct Udpstats>>=
/* MIB II counters */
struct Udpstats
{
    uvlong  udpInDatagrams;
    ulong   udpNoPorts;
    ulong   udpInErrors;
    uvlong  udpOutDatagrams;
};
@



\section{Protocol header}

<<struct Udp4hdr>>=
struct Udp4hdr
{
    /* ip header */
    uchar   vihl;       /* Version and header length */
    uchar   tos;        /* Type of service */
    uchar   length[2];  /* packet length */
    uchar   id[2];      /* Identification */
    uchar   frag[2];    /* Fragment information */
    uchar   Unused; // ttl

    uchar   udpproto;   /* Protocol */
    uchar   udpplen[2]; /* Header plus data length */
    uchar   udpsrc[IPv4addrlen];    /* Ip source */
    uchar   udpdst[IPv4addrlen];    /* Ip destination */

    /* udp header */
    uchar   udpsport[2];    /* Source port */
    uchar   udpdport[2];    /* Destination port */
    uchar   udplen[2];  /* data length */
    uchar   udpcksum[2];    /* Checksum */
};
@
% do not change the order here :)
% essential IP header + port info.
% why another checksum? because the other is the header checksum!
% here we want a checksum of the data.
%less: why do not use the IpHeader; anonymous field to factorize
% structure definitions? also better see what is udp specific then.

<<constant UDP4_IPHDR_SZ>>=
UDP4_IPHDR_SZ = 20,
@
%less: could factorize and have a IPHDR_SZ?

<<constant UDP_UDPHDR_SZ>>=
UDP_UDPHDR_SZ   = 8,
@

<<constant UDP4_PHDR_OFF>>=
UDP4_PHDR_OFF = 8,
@
% can be different than UDP_UDPHDR_SZ?

<<constant UDP4_PHDR_SZ>>=
UDP4_PHDR_SZ = 12,
@
% diff with UDP_UDPHDR_SZ?




<<struct Udphdr (user)>>=
struct Udphdr
{
    uchar	raddr[IPaddrlen];	/* V6 remote address */
    uchar	laddr[IPaddrlen];	/* V6 local address */
    uchar	ifcaddr[IPaddrlen];	/* V6 ifc addr msg was received on */

    uchar	rport[2];		/* remote port */
    uchar	lport[2];		/* local port */
};
@
% do not change the order here :)
%dead? who uses that?

\section{[[/net/tcp/clone]]}

<<function udpcreate>>=
static void
udpcreate(Conv *cv)
{
    cv->rq = qopen(128*1024, Qmsg, 0, 0);
    cv->wq = qbypass(udpkick, cv);
}
@
% the wq will be accessed via /net/x/y/data

% ipclose -> closeconv -> <> (as x->close)
<<function udpclose>>=
static void
udpclose(Conv *c)
{
    Udpcb *ucb;
    Udppriv *upriv;

    upriv = c->p->priv;
    iphtrem(&upriv->ht, c);

    c->state = Idle;
    qclose(c->rq);
    qclose(c->wq);
    qclose(c->eq);
    ipmove(c->laddr, IPnoaddr);
    ipmove(c->raddr, IPnoaddr);
    c->lport = 0;
    c->rport = 0;

    ucb = (Udpcb*)c->ptcl;
    ucb->headers = 0;
}
@

\section{[[/net/tcp/x/ctl]]}

\subsection{Connect}

<<function udpconnect>>=
static char*
udpconnect(Conv *c, char **argv, int argc)
{
    char *err;
    Udppriv *upriv;

    upriv = c->p->priv;

    err = Fsstdconnect(c, argv, argc);
    Fsconnected(c, err);
    if(err != nil)
        return err;

    iphtadd(&upriv->ht, c);
    return nil;
}
@

\subsection{Announce}

<<function udpannounce>>=
static char*
udpannounce(Conv *c, char** argv, int argc)
{
    char *err;
    Udppriv *upriv;

    upriv = c->p->priv;

    err = Fsstdannounce(c, argv, argc);
    if(err != nil)
        return err;
    Fsconnected(c, nil);

    iphtadd(&upriv->ht, c);

    return nil;
}
@


\section{IO}

\subsection{Writing, [[udpkick()]]}


% ??? -> <> (as x->??   <- udpcreate <- ...)
<<function udpkick>>=
void
udpkick(void *x, Block *bp)
{
    Conv *c = x;
    Conv *rc;
    Udp4hdr *uh4;
    Udppriv *upriv;
    int dlen, ptcllen;
    Fs *f;
    int version;
    <<[[udpkick()]] locals>>

    upriv = c->p->priv;
    f = c->p->f;

//  netlog(c->p->f, Logudp, "udp: kick\n"); /* frequent and uninteresting */
    if(bp == nil)
        return;

    <<[[udpkick()]] special headers processing>>
    <<[[udpkick()]] set version to V4 or V6>>

    dlen = blocklen(bp);

    /* fill in pseudo header and compute checksum */
    switch(version){
    case V4:
        bp = padblock(bp, UDP4_IPHDR_SZ+UDP_UDPHDR_SZ);
        if(bp == nil)
            return;

        uh4 = (Udp4hdr *)(bp->rp);
        ptcllen = dlen + UDP_UDPHDR_SZ;
        uh4->Unused = 0;
        uh4->udpproto = IP_UDPPROTO;
        uh4->frag[0] = 0;
        uh4->frag[1] = 0;
        hnputs(uh4->udpplen, ptcllen);
        <<[[udpkick()]] if special headers>>
        else {
            v6tov4(uh4->udpdst, c->raddr);
            hnputs(uh4->udpdport, c->rport);
            if(ipcmp(c->laddr, IPnoaddr) == 0)
                findlocalip(f, c->laddr, c->raddr);
            v6tov4(uh4->udpsrc, c->laddr);
            rc = c;
        }
        hnputs(uh4->udpsport, c->lport);
        hnputs(uh4->udplen, ptcllen);

        uh4->udpcksum[0] = 0;
        uh4->udpcksum[1] = 0;
        hnputs(uh4->udpcksum,
               ptclcsum(bp, UDP4_PHDR_OFF, dlen+UDP_UDPHDR_SZ+UDP4_PHDR_SZ));
        uh4->vihl = IP_VER4;

        // Let's go, let's send the data
        ipoput4(f, bp, false, c->ttl, c->tos, rc);

        break;

    <<[[udpkick()]] switch version ipv6 case>>

    default:
        panic("udpkick: version %d", version);
    }
    upriv->ustats.udpOutDatagrams++;
}
@

% lots of hnputs

\subsection{Reading, [[udpiput()]]}
% read, iput

%TODO LP split
% -> <> (as x->rcv)
<<function udpiput>>=
void
udpiput(Proto *udp, Ipifc *ifc, Block *bp)
{
    Udppriv *upriv;
    Fs *f;
    Udp4hdr *uh4;
    int version;
    uchar raddr[IPaddrlen], laddr[IPaddrlen];
    ushort rport, lport;
    Conv *c;
    Udpcb *ucb;
    int len;
    <<[[udpiput()]] locals>>
    uchar *p;

    upriv = udp->priv;
    upriv->ustats.udpInDatagrams++;
    f = udp->f;
    uh4 = (Udp4hdr*)(bp->rp);
    <<[[udpiput()]] set version to V4 or V6>>

    <<[[udpiput()]] checking checksum and setting rxxx, lxxx>>

    qlock(udp);

    // find the corresponding conversation
    c = iphtlook(&upriv->ht, raddr, rport, laddr, lport);
    <<[[udpiput()]] if no conversation found>>

    ucb = (Udpcb*)c->ptcl;

    if(c->state == Announced){
        if(ucb->headers == 0){
            /* create a new conversation */
            <<[[udpiput()]] new conv to create, adjust laddr if not Runi>>
            c = Fsnewcall(c, raddr, rport, laddr, lport, version);
            if(c == nil){
                qunlock(udp);
                freeblist(bp);
                return;
            }
            // port may have changed?
            iphtadd(&upriv->ht, c);
            ucb = (Udpcb*)c->ptcl;
        }
    }

    qlock(c);
    qunlock(udp);


    <<[[udpiput()]] trim the packet, adjust bp removing header>>

    netlog(f, Logudpmsg, "udp: %I.%d -> %I.%d l %d\n", raddr, rport,
           laddr, lport, len);

    <<[[udpiput()]] if special headers>>

    if(bp->next)
        bp = concatblock(bp);

    <<[[udpiput()]] if reading queue is full>>

    qpass(c->rq, bp);
    qunlock(c);

}
@
% pass to reading queue of conversation! if not full, otherwise have to drop

% lots of hngets

\subsubsection{New conversation}

<<function Fsnewcall>>=
/*
 *  called with protocol locked
 */
Conv*
Fsnewcall(Conv *c, uchar *raddr, ushort rport, uchar *laddr, ushort lport, uchar version)
{
    Conv *nc;
    Conv **l;
    int i;

    qlock(c);
    i = 0;
    for(l = &c->incall; *l; l = &(*l)->next)
        i++;
    if(i >= Maxincall) {
        static bool beenhere;

        qunlock(c);
        if (!beenhere) {
            beenhere = true;
            print("Fsnewcall: incall queue full (%d) on port %d\n",
                i, c->lport);
        }
        return nil;
    }

    /* find a free conversation */
    nc = Fsprotoclone(c->p, network);
    if(nc == nil) {
        qunlock(c);
        return nil;
    }
    ipmove(nc->raddr, raddr);
    nc->rport = rport;
    ipmove(nc->laddr, laddr);
    nc->lport = lport;

    nc->next = nil;
    *l = nc;

    nc->state = Connected;
    nc->ipversion = version;

    qunlock(c);

    wakeup(&c->listenr);

    return nc;
}
@


\subsubsection{Checks}

<<[[udpiput()]] locals>>=
int ottl, olen;
@

<<[[udpiput()]] checking checksum and setting rxxx, lxxx>>=
/* Put back pseudo header for checksum
 * (remember old values for icmpnoconv()) */
switch(version) {
case V4:
    ottl = uh4->Unused;
    uh4->Unused = 0;
    len = nhgets(uh4->udplen);
    olen = nhgets(uh4->udpplen);
    hnputs(uh4->udpplen, len);

    v4tov6(raddr, uh4->udpsrc);
    v4tov6(laddr, uh4->udpdst);
    lport = nhgets(uh4->udpdport);
    rport = nhgets(uh4->udpsport);

    if(nhgets(uh4->udpcksum)) {
        if(ptclcsum(bp, UDP4_PHDR_OFF, len+UDP4_PHDR_SZ)) {
            upriv->ustats.udpInErrors++;
            netlog(f, Logudp, "udp: checksum error %I\n", raddr);
            DPRINT("udp: checksum error %I\n", raddr);
            freeblist(bp);
            return;
        }
    }
    uh4->Unused = ottl;
    hnputs(uh4->udpplen, olen);
    break;

<<[[udpiput()]] checking checksum ipv6 case>>

default:
    panic("udpiput: version %d", version);
    return; /* to avoid a warning */
}
@

\subsubsection{Trim the packet}

<<[[udpiput()]] trim the packet, adjust bp removing header>>=
/*
 * Trim the packet down to data size
 */
len -= UDP_UDPHDR_SZ;
switch(version){
case V4:
    bp = trimblock(bp, UDP4_IPHDR_SZ+UDP_UDPHDR_SZ, len);
    break;
<<[[udpiput()]] trim the packet, ipv6 case>>
default:
    bp = nil;
    panic("udpiput4: version %d", version);
}
if(bp == nil){
    qunlock(c);
    netlog(f, Logudp, "udp: len err %I.%d -> %I.%d\n", raddr, rport,
           laddr, lport);
    upriv->lenerr++;
    return;
}
@

\subsubsection{Error managment}

<<[[udpiput()]] if no conversation found>>=
if(c == nil){
    /* no conversation found */
    upriv->ustats.udpNoPorts++;
    qunlock(udp);
    netlog(f, Logudp, "udp: no conv %I!%d -> %I!%d\n", raddr, rport,
           laddr, lport);

    switch(version){
    case V4:
        icmpnoconv(f, bp);
        break;
     <<[[udpiput()]] no conversation found, ipv6 case>>
    default:
        panic("udpiput2: version %d", version);
    }

    freeblist(bp);
    return;
}
@

<<[[udpiput()]] if reading queue is full>>=
if(qfull(c->rq)){
    qunlock(c);
    netlog(f, Logudp, "udp: qfull %I.%d -> %I.%d\n", raddr, rport,
           laddr, lport);
    freeblist(bp);
    return;
}
@

\section{Other files}

\subsection{[[/net/tcp/stats]]}

<<function udpstats>>=
int
udpstats(Proto *udp, char *buf, int len)
{
    Udppriv *upriv;

    upriv = udp->priv;
    return snprint(buf, len, "InDatagrams: %llud\nNoPorts: %lud\n"
        "InErrors: %lud\nOutDatagrams: %llud\n",
        upriv->ustats.udpInDatagrams,
        upriv->ustats.udpNoPorts,
        upriv->ustats.udpInErrors,
        upriv->ustats.udpOutDatagrams);
}
@

\subsection{[[/net/tcp/x/status]]}

<<function udpstate>>=
static int
udpstate(Conv *cv, char *state, int n)
{
    return snprint(state, n, "%s qin %d qout %d\n",
        cv->inuse ? "Open" : "Closed",
        cv->rq ? qlen(cv->rq) : 0,
        cv->wq ? qlen(cv->wq) : 0
    );
}
@

\section{Advanced features}

\subsection{Ignore advice}


<<[[Conv(kernel)]] udp fields>>=
bool ignoreadvice;   /* don't terminate connection on icmp errors */
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "ignoreadvice") == 0)
    cv->ignoreadvice = true;
@

\subsection{Not regular forme}

<<[[udpiput()]] new conv to create, adjust laddr if not Runi>>=
if(ipforme(f, laddr) != Runi) {
    switch(version){
    case V4:
        v4tov6(laddr, ifc->lifc->local);
        break;
    <<[[udpiput()]] new conv to create, ipv6 case>>
    default:
        panic("udpiput3: version %d", version);
    }
}
@

\subsection{User level UDP headers}
% need that? remove? for debugging?
% udpecho.c uses that

%\subsection{[[Udpcb]]}
% conversation priv

<<struct Udpcb>>=
struct Udpcb
{
    QLock;
    <<[[Idpcb]] other fields>>
};
@
%todo: need QLock really?


<<[[Idpcb]] other fields>>=
uchar   headers;
@

%dead: replaced by private field in Udppriv
%<<[[Conv(kernel)]] other fields>>=
%/* udp specific */
%int headers;    /* data src/dst headers in udp */
%int reliable;   /* true if reliable udp */
%@


<<function udpctl>>=
char*
udpctl(Conv *c, char **f, int n)
{
    Udpcb *ucb;

    ucb = (Udpcb*)c->ptcl;
    if(n == 1){
        if(strcmp(f[0], "headers") == 0){
            ucb->headers = 7;   /* new headers format */
            return nil;
        }
    }
    return "unknown control request";
}
@

<<constant UDP_USEAD7>>=
UDP_USEAD7  = 52,
@

<<[[udpkick()]] locals>>=
Udpcb *ucb;
uchar laddr[IPaddrlen];
uchar raddr[IPaddrlen];
ushort rport;
@

<<[[udpkick()]] special headers processing>>=
ucb = (Udpcb*)c->ptcl;
switch(ucb->headers) {
case 7:
    /* get user specified addresses */
    bp = pullupblock(bp, UDP_USEAD7);
    if(bp == nil)
        return;
    ipmove(raddr, bp->rp);
    bp->rp += IPaddrlen;
    ipmove(laddr, bp->rp);
    bp->rp += IPaddrlen;

    /* pick interface closest to dest */
    if(ipforme(f, laddr) != Runi)
        findlocalip(f, laddr, raddr);
    bp->rp += IPaddrlen;        /* Ignore ifc address */
    rport = nhgets(bp->rp);
    bp->rp += 2+2;          /* Ignore local port */
    break;
default:
    rport = 0;
    break;
}
@


<<[[udpkick()]] if special headers>>=
if(ucb->headers) {
    v6tov4(uh4->udpdst, raddr);
    hnputs(uh4->udpdport, rport);
    v6tov4(uh4->udpsrc, laddr);
    rc = nil;
} 
@


<<[[udpiput()]] if special headers>>=
switch(ucb->headers){
case 7:
    /* pass the src address */
    bp = padblock(bp, UDP_USEAD7);
    p = bp->rp;
    ipmove(p, raddr); p += IPaddrlen;
    ipmove(p, laddr); p += IPaddrlen;
    ipmove(p, ifc->lifc->local); p += IPaddrlen;
    hnputs(p, rport); p += 2;
    hnputs(p, lport);
    break;
}
@

\chapter{Reliable Communication, IL}

% For Internet Link

% see il.ps

%was in 9legacy since it has been deleted of recent plan9

\section{Protocol initialisation}

<<function ilinit>>=
void
ilinit(Fs *f)
{
    Proto *il;

    inittimescale();

    il = smalloc(sizeof(Proto));
    il->priv = smalloc(sizeof(Ilpriv));

    il->name = "il";
    il->create = ilcreate;
    il->close = ilclose;

    il->connect = ilconnect;
    il->announce = ilannounce;
    il->ctl = nil;

    il->rcv = iliput;

    il->state = ilstate;
    il->stats = ilxstats;

    il->inuse = ilinuse;
    il->advise = iladvise;

    il->gc = nil;
    il->ipproto = IP_ILPROTO;

    il->nc = scalednconv();
    il->ptclsize = sizeof(Ilcb);

    Fsproto(f, il);
}
@

<<constant IP_ILPROTO>>=
IP_ILPROTO	= 40,
@

% as opposed to UDP we will need to do some adjustments based on
% time feedback on how long a packet ack, congestion, etc.
<<function inittimescale>>=
/* calculate scale constants that converts fast ticks to ms (more or less) */
static void
inittimescale(void)
{
    uvlong hz;

    fastticks(&hz);
    if(hz > 1000){
        scalediv = hz/1000;
        scalemul = 1;
    } else {
        scalediv = 1;
        scalemul = 1000/hz;
    }
}
@

<<global scalexxx>>=
static	ulong	scalediv, scalemul;
@


<<function scalednconv>>=
ulong
scalednconv(void)
{
    if(cpuserver && conf.npage*BY2PG >= 128*MB)
        return Nchans*4;
    return Nchans;
}
@

\section{Protocol data structures}

\subsection{IL state}

% look nice, simple
<<enum _anon_ (kernel/network/ip/il.c)>>=
enum il_state				/* Connection state */
{
    Ilclosed,

    Ilsyncer,
    Ilsyncee,
    Ilestablished,
    Illistening,
    Ilclosing,

    Ilopening,		/* only for file server */
};
@
%note: il.ps does not have Illistening but 
%note: il.ps does not have Ilopening

<<global ilstates>>=
char	*ilstates[] = 
{ 
    "Closed",
    "Syncer",
    "Syncee",
    "Established",
    "Listen",
    "Closing",
    "Opening",		/* only for file server */
};
@

% ... -> Fsprotoclone -> <>
<<function ilinuse>>=
static int
ilinuse(Conv *c)
{
    Ilcb *ic;

    ic = (Ilcb*)(c->ptcl);
    return ic->state != Ilclosed;

}
@
% there is a state now, and even if the inuse is at zero, the
% conversation may still be in use and must be propery shutdown

\subsection{IL control packet type}

<<enum _anon_ (kernel/network/ip/il.c)2>>=
enum				/* Packet types */
{
    Ilsync,
    Ildata,
    Ildataquery,
    Ilack,
    Ilquery,
    Ilstate,
    Ilclose,
};
@

<<global iltype>>=
char	*iltype[] = 
{	
    "sync",
    "data",
    "dataquery",
    "ack",
    "query",
    "state",
    "close" 
};
@

\subsection{[[Ilcb]]}
% private to conv

% TODO: LP split!
<<struct Ilcb>>=
struct Ilcb			/* Control block */
{
    // enum<il_state>
    int	state;		/* Connection state */

    Conv	*conv;

    QLock	ackq;		/* Unacknowledged queue */
    Block	*unacked;
    Block	*unackedtail;
    ulong	unackedbytes;
    QLock	outo;		/* Out of order packet queue */
    Block	*outoforder;
    ulong	next;		/* Id of next to send */
    ulong	recvd;		/* Last packet received */
    ulong	acksent;	/* Last packet acked */
    ulong	start;		/* Local start id */
    ulong	rstart;		/* Remote start id */
    int	window;		/* Maximum receive window */
    int	rxquery;	/* number of queries on this connection */
    int	rxtot;		/* number of retransmits on this connection */
    int	rexmit;		/* number of retransmits of *unacked */
    ulong	qt[Nqt+1];	/* state table for query messages */
    int	qtx;		/* ... index into qt */

    /* if set, fasttimeout causes a connection request to terminate after 4*Iltickms */
    int	fasttimeout;

    /* timers */
    ulong	lastxmit;	/* time of last xmit */
    ulong	lastrecv;	/* time of last recv */
    ulong	timeout;	/* retransmission time for *unacked */
    ulong	acktime;	/* time to send next ack */
    ulong	querytime;	/* time to send next query */

    /* adaptive measurements */
    int	delay;		/* Average of the fixed rtt delay */
    int	rate;		/* Average uchar rate */
    int	mdev;		/* Mean deviation of rtt */
    int	maxrtt;		/* largest rtt seen */
    ulong	rttack;		/* The ack we are waiting for */
    int	rttlen;		/* Length of rttack packet */
    uvlong	rttstart;	/* Time we issued rttack packet */
};
@



\subsection{[[Ilpriv]]}
% private to protocol

<<struct Ilpriv>>=
struct Ilpriv
{
    Ipht	ht;

    ulong	dup;
    ulong	dupb;

    <<[[Ilpriv]] stat fields>>

    /* keeping track of the ack kproc */
    int	ackprocstarted;
    QLock	apl;
};
@

\subsection{Statistics}

<<[[Ilpriv]] stat fields>>=
ulong	csumerr;		/* checksum errors */
ulong	hlenerr;		/* header length error */
ulong	lenerr;			/* short packet */
ulong	order;			/* out of order */
ulong	rexmit;			/* retransmissions */
@

<<[[Ilpriv]] stat fields>>=
// map<enum<il_stat>, uvlong>
uvlong	stats[Nstats];
@

<<enum _anon_ (kernel/network/ip/il.c)6>>=
enum il_stat
{
    InMsgs,
    OutMsgs,
    CsumErrs,		/* checksum errors */
    HlenErrs,		/* header length error */
    LenErrs,		/* short packet */
    OutOfOrder,		/* out of order */
    Retrans,		/* retransmissions */
    DupMsg,
    DupBytes,
    DroppedMsgs,

    Nstats,
};
@

<<global statnames (kernel/network/ip/il.c)>>=
static char *statnames[] =
{
[InMsgs]	"InMsgs",
[OutMsgs]	"OutMsgs",
[CsumErrs]	"CsumErrs",
[HlenErrs]	"HlenErr",
[LenErrs]	"LenErrs",
[OutOfOrder]	"OutOfOrder",
[Retrans]	"Retrans",
[DupMsg]	"DupMsg",
[DupBytes]	"DupBytes",
[DroppedMsgs]	"DroppedMsgs",
};
@


\section{Protocol header}

<<struct Ilhdr>>=
struct Ilhdr
{
    /* ip header */
    uchar	vihl;		/* Version and header length */
    uchar	tos;		/* Type of service */
    uchar	length[2];	/* packet length */
    uchar	id[2];		/* Identification */
    uchar	frag[2];	/* Fragment information */
    uchar	ttl;		/* Time to live */

    uchar	proto;		/* Protocol */
    uchar	cksum[2];	/* Header checksum */
    uchar	src[4];		/* Ip source */
    uchar	dst[4];		/* Ip destination */

    /* IL header */
    uchar	ilsum[2];	/* Checksum including header */
    uchar	illen[2];	/* Packet length */
    uchar	iltype;		/* Packet type */
    uchar	ilspec;		/* Special */
    uchar	ilsrc[2];	/* Src port */
    uchar	ildst[2];	/* Dst port */
    uchar	ilid[4];	/* Sequence id */
    uchar	ilack[4];	/* Acked sequence */
};
@
% do not change the order!

<<constant IL_xxxSIZE>>=
IL_IPSIZE 	= 20,
IL_HDRSIZE	= 18,	
@

\section{[[/net/il/clone]]}

<<function ilcreate>>=
static void
ilcreate(Conv *c)
{
    c->rq = qopen(Maxrq, 0, 0, c);
    c->wq = qbypass(ilkick, c);
}
@

<<constant Maxrq(IL)>>=
Maxrq		= 64*1024,
@

% see also inuse() above, related to clone

\section{[[/net/il/x/ctl]]}

<<enum mode (kernel/network/ip/il.c)>>=
enum mode {
    IL_LISTEN	= 0,
    IL_CONNECT	= 1,
};
@

\subsection{Connect}

<<function ilconnect>>=
static char*
ilconnect(Conv *c, char **argv, int argc)
{
    char *err;
    char *p;
    bool fast = false;

    <<[[ilconnect()]] set fast>>

    err = Fsstdconnect(c, argv, argc);
    if(err != nil)
        return err;
    return ilstart(c, IL_CONNECT, fast);
}
@



\subsection{Announce}

<<function ilannounce>>=
/* called with c locked */
static char*
ilannounce(Conv *c, char **argv, int argc)
{
    char *err;

    err = Fsstdannounce(c, argv, argc);
    if(err != nil)
        return err;
    err = ilstart(c, IL_LISTEN, false);
    if(err != nil)
        return err;
    Fsconnected(c, nil);

    return nil;
}
@


\section{IO}

\subsection{Writing, [[ilkick()]]}

<<function ilkick>>=
void
ilkick(void *x, Block *bp)
{
    Conv *c = x;
    Ilhdr *ih;
    Ilcb *ic;
    int dlen;
    ulong id, ack;
    Fs *f;
    Ilpriv *priv;

    f = c->p->f;
    priv = c->p->priv;
    ic = (Ilcb*)c->ptcl;

    if(bp == nil)
        return;

    switch(ic->state) {
    case Ilclosed:
    case Illistening:
    case Ilclosing:
        freeblist(bp);
        qhangup(c->rq, nil);
        return;
    }

    dlen = blocklen(bp);

    /* Make space to fit il & ip */
    bp = padblock(bp, IL_IPSIZE+IL_HDRSIZE);
    ih = (Ilhdr *)(bp->rp);
    ih->vihl = IP_VER4;

    /* Ip fields */
    ih->frag[0] = 0;
    ih->frag[1] = 0;
    v6tov4(ih->dst, c->raddr);
    v6tov4(ih->src, c->laddr);
    ih->proto = IP_ILPROTO;

    /* Il fields */
    hnputs(ih->illen, dlen+IL_HDRSIZE);
    hnputs(ih->ilsrc, c->lport);
    hnputs(ih->ildst, c->rport);

    qlock(&ic->ackq);
    id = ic->next++;
    hnputl(ih->ilid, id);
    ack = ic->recvd;
    hnputl(ih->ilack, ack);
    ic->acksent = ack;
    ic->acktime = NOW + AckDelay;
    ih->iltype = Ildata;
    ih->ilspec = 0;
    ih->ilsum[0] = 0;
    ih->ilsum[1] = 0;

    /* Checksum of ilheader plus data (not ip & no pseudo header) */
    if(ilcksum)
        hnputs(ih->ilsum, ptclcsum(bp, IL_IPSIZE, dlen+IL_HDRSIZE));

    ilackq(ic, bp);

    qunlock(&ic->ackq);

    /* Start the round trip timer for this packet if the timer is free */
    if(ic->rttack == 0) {
        ic->rttack = id;
        ic->rttstart = fastticks(nil);
        ic->rttlen = dlen + IL_IPSIZE + IL_HDRSIZE;
    }

    if(later(NOW, ic->timeout, nil))
        ilsettimeout(ic);

    // Let's go, let's send the data
    ipoput4(f, bp, false, c->ttl, c->tos, c);

    priv->stats[OutMsgs]++;
}
@

\subsection{Reading, [[iliput()]]}

<<function iliput>>=
void
iliput(Proto *il, Ipifc*, Block *bp)
{
    char *st;
    Ilcb *ic;
    Ilhdr *ih;
    uchar raddr[IPaddrlen];
    uchar laddr[IPaddrlen];
    ushort sp, dp, csum;
    int plen, illen;
    Conv *new, *s;
    Ilpriv *ipriv;

    ipriv = il->priv;

    ih = (Ilhdr *)bp->rp;
    plen = blocklen(bp);
    if(plen < IL_IPSIZE+IL_HDRSIZE){
        //netlog(il->f, Logil, "il: hlenerr\n");
        ipriv->stats[HlenErrs]++;
        goto raise;
    }

    illen = nhgets(ih->illen);
    if(illen+IL_IPSIZE > plen){
        //netlog(il->f, Logil, "il: lenerr\n");
        ipriv->stats[LenErrs]++;
        goto raise;
    }

    sp = nhgets(ih->ildst);
    dp = nhgets(ih->ilsrc);
    v4tov6(raddr, ih->src);
    v4tov6(laddr, ih->dst);

    if((csum = ptclcsum(bp, IL_IPSIZE, illen)) != 0) {
        if(ih->iltype > Ilclose)
            st = "?";
        else
            st = iltype[ih->iltype];
        ipriv->stats[CsumErrs]++;
        //netlog(il->f, Logil, "il: cksum %ux %s, pkt(%ux id %ud ack %I/%d->%d)\n",
//			csum, st, nhgetl(ih->ilid), nhgetl(ih->ilack), raddr, sp, dp);
        goto raise;
    }

    qlock(il);
    s = iphtlook(&ipriv->ht, raddr, dp, laddr, sp);
    if(s == nil){
        if(ih->iltype == Ilsync)
            ilreject(il->f, ih);		/* no listener */
        qunlock(il);
        goto raise;
    }

    ic = (Ilcb*)s->ptcl;
    if(ic->state == Illistening){
        if(ih->iltype != Ilsync){
            qunlock(il);
            if(ih->iltype > Ilclose)
                st = "?";
            else
                st = iltype[ih->iltype];
            ilreject(il->f, ih);		/* no channel and not sync */
            //netlog(il->f, Logil, "il: no channel, pkt(%s id %ud ack %ud %I/%ud->%ud)\n",
//				st, nhgetl(ih->ilid), nhgetl(ih->ilack), raddr, sp, dp); 
            goto raise;
        }

        new = Fsnewcall(s, raddr, dp, laddr, sp, V4);
        if(new == nil){
            qunlock(il);
            //netlog(il->f, Logil, "il: bad newcall %I/%ud->%ud\n", raddr, sp, dp);
            ilsendctl(s, ih, Ilclose, 0, nhgetl(ih->ilid), 0);
            goto raise;
        }
        s = new;

        ic = (Ilcb*)s->ptcl;
    
        ic->conv = s;
        ic->state = Ilsyncee;
        ilcbinit(ic);
        ic->rstart = nhgetl(ih->ilid);
        iphtadd(&ipriv->ht, s);
    }

    qlock(s);
    qunlock(il);
    if(waserror()){
        qunlock(s);
        nexterror();
    }

    ilprocess(s, ih, bp);

    qunlock(s);
    poperror();
    return;
raise:
    freeblist(bp);
}
@


\section{State machine}

% two-way handshake

\subsection{[[ilsendctl()]]}

<<function ilsendctl>>=
void
ilsendctl(Conv *ipc, Ilhdr *inih, int type, ulong id, ulong ack, int ilspec)
{
    Ilhdr *ih;
    Ilcb *ic;
    Block *bp;
    int ttl, tos;

    bp = allocb(IL_IPSIZE+IL_HDRSIZE);
    bp->wp += IL_IPSIZE+IL_HDRSIZE;

    ih = (Ilhdr *)(bp->rp);
    ih->vihl = IP_VER4;

    /* Ip fields */
    ih->proto = IP_ILPROTO;
    hnputs(ih->illen, IL_HDRSIZE);
    ih->frag[0] = 0;
    ih->frag[1] = 0;
    if(inih) {
        hnputl(ih->dst, nhgetl(inih->src));
        hnputl(ih->src, nhgetl(inih->dst));
        hnputs(ih->ilsrc, nhgets(inih->ildst));
        hnputs(ih->ildst, nhgets(inih->ilsrc));
        hnputl(ih->ilid, nhgetl(inih->ilack));
        hnputl(ih->ilack, nhgetl(inih->ilid));
        ttl = MAXTTL;
        tos = DFLTTOS;
    }
    else {
        v6tov4(ih->dst, ipc->raddr);
        v6tov4(ih->src, ipc->laddr);
        hnputs(ih->ilsrc, ipc->lport);
        hnputs(ih->ildst, ipc->rport);
        hnputl(ih->ilid, id);
        hnputl(ih->ilack, ack);
        ic = (Ilcb*)ipc->ptcl;
        ic->acksent = ack;
        ic->acktime = NOW;
        ttl = ipc->ttl;
        tos = ipc->tos;
    }
    ih->iltype = type;
    ih->ilspec = ilspec;
    ih->ilsum[0] = 0;
    ih->ilsum[1] = 0;

    if(ilcksum)
        hnputs(ih->ilsum, ptclcsum(bp, IL_IPSIZE, IL_HDRSIZE));

if(ipc==nil)
    panic("ipc is nil caller is %#p", getcallerpc(&ipc));
if(ipc->p==nil)
    panic("ipc->p is nil");

    //netlog(ipc->p->f, Logilmsg, "ctl(%s id %d ack %d %d->%d)\n",
    //		iltype[ih->iltype], nhgetl(ih->ilid), nhgetl(ih->ilack), 
    //		nhgets(ih->ilsrc), nhgets(ih->ildst));

    ipoput4(ipc->p->f, bp, false, ttl, tos, ipc);
}
@
% ipc for conv ??


\subsection{[[ilprocess()]]}

<<function ilprocess>>=
/* DEBUG */
void
ilprocess(Conv *s, Ilhdr *h, Block *bp)
{
    Ilcb *ic;

    ic = (Ilcb*)s->ptcl;

    USED(ic);
    //netlog(s->p->f, Logilmsg, "%11s rcv %lud/%lud snt %lud/%lud pkt(%s id %d ack %ud %ud->%ud) ",
//		ilstates[ic->state],  ic->rstart, ic->recvd, ic->start, 
//		ic->next, iltype[h->iltype], nhgetl(h->ilid), 
//		nhgetl(h->ilack), nhgets(h->ilsrc), nhgets(h->ildst));

    _ilprocess(s, h, bp);

    //netlog(s->p->f, Logilmsg, "%11s rcv %lud snt %lud\n", ilstates[ic->state], ic->recvd, ic->next);
}
@


<<function _ilprocess>>=
void
_ilprocess(Conv *s, Ilhdr *h, Block *bp)
{
    Ilcb *ic;
    ulong id, ack;
    Ilpriv *priv;

    id = nhgetl(h->ilid);
    ack = nhgetl(h->ilack);

    ic = (Ilcb*)s->ptcl;

    ic->lastrecv = NOW;
    ic->querytime = NOW + QueryTime;
    priv = s->p->priv;
    priv->stats[InMsgs]++;

    switch(ic->state) {
    default:
        //netlog(s->p->f, Logil, "il: unknown state %d\n", ic->state);
    case Ilclosed:
        freeblist(bp);
        break;
    case Ilsyncer:
        switch(h->iltype) {
        default:
            break;
        case Ilsync:
            if(ack != ic->start)
                ilhangup(s, "connection rejected");
            else {
                ic->recvd = id;
                ic->rstart = id;
                ilsendctl(s, nil, Ilack, ic->next, ic->recvd, 0);
                ic->state = Ilestablished;
                ic->fasttimeout = 0;
                ic->rexmit = 0;
                Fsconnected(s, nil);
                ilpullup(s);
            }
            break;
        case Ilclose:
            if(ack == ic->start)
                ilhangup(s, "connection rejected");
            break;
        }
        freeblist(bp);
        break;
    case Ilsyncee:
        switch(h->iltype) {
        default:
            break;
        case Ilsync:
            if(id != ic->rstart || ack != 0){
                illocalclose(s);
            } else {
                ic->recvd = id;
                ilsendctl(s, nil, Ilsync, ic->start, ic->recvd, 0);
            }
            break;
        case Ilack:
            if(ack == ic->start) {
                ic->state = Ilestablished;
                ic->fasttimeout = 0;
                ic->rexmit = 0;
                ilpullup(s);
            }
            break;
        case Ildata:
            if(ack == ic->start) {
                ic->state = Ilestablished;
                ic->fasttimeout = 0;
                ic->rexmit = 0;
                goto established;
            }
            break;
        case Ilclose:
            if(ack == ic->start)
                ilhangup(s, "remote close");
            break;
        }
        freeblist(bp);
        break;
    case Ilestablished:
    established:
        switch(h->iltype) {
        case Ilsync:
            if(id != ic->rstart)
                ilhangup(s, "remote close");
            else
                ilsendctl(s, nil, Ilack, ic->next, ic->rstart, 0);
            freeblist(bp);	
            break;
        case Ildata:
            /*
             * avoid consuming all the mount rpc buffers in the
             * system.  if the input queue is too long, drop this
             * packet.
             */
            if (s->rq && qlen(s->rq) >= Maxrq) {
                priv->stats[DroppedMsgs]++;
                freeblist(bp);
                break;
            }

            ilackto(ic, ack, bp);
            iloutoforder(s, h, bp);
            ilpullup(s);
            break;
        case Ildataquery:
            ilackto(ic, ack, bp);
            iloutoforder(s, h, bp);
            ilpullup(s);
            ilsendctl(s, nil, Ilstate, ic->next, ic->recvd, h->ilspec);
            break;
        case Ilack:
            ilackto(ic, ack, bp);
            freeblist(bp);
            break;
        case Ilquery:
            ilackto(ic, ack, bp);
            ilsendctl(s, nil, Ilstate, ic->next, ic->recvd, h->ilspec);
            freeblist(bp);
            break;
        case Ilstate:
            if(ack >= ic->rttack)
                ic->rttack = 0;
            ilackto(ic, ack, bp);
            if(h->ilspec > Nqt)
                h->ilspec = 0;
            if(ic->qt[h->ilspec] > ack){
                ilrexmit(ic);
                ilsettimeout(ic);
            }
            freeblist(bp);
            break;
        case Ilclose:
            freeblist(bp);
            if(ack < ic->start || ack > ic->next) 
                break;
            ic->recvd = id;
            ilsendctl(s, nil, Ilclose, ic->next, ic->recvd, 0);
            ic->state = Ilclosing;
            ilsettimeout(ic);
            ilfreeq(ic);
            break;
        }
        break;
    case Illistening:
        freeblist(bp);
        break;
    case Ilclosing:
        switch(h->iltype) {
        case Ilclose:
            ic->recvd = id;
            ilsendctl(s, nil, Ilclose, ic->next, ic->recvd, 0);
            if(ack == ic->next)
                ilhangup(s, nil);
            break;
        default:
            break;
        }
        freeblist(bp);
        break;
    }
}
@


\subsection{Start}
% Closed

% (ilconnect | ilannounce) -> <>
<<function ilstart>>=
char*
ilstart(Conv *c, int type, bool fasttimeout)
{
    Ilcb *ic;
    Ilpriv *ipriv;
    char kpname[KNAMELEN];

    ipriv = c->p->priv;

    if(ipriv->ackprocstarted == 0){
        qlock(&ipriv->apl);
        if(ipriv->ackprocstarted == 0){
            sprint(kpname, "#I%dilack", c->p->f->dev);
            kproc(kpname, ilackproc, c->p);
            ipriv->ackprocstarted = 1;
        }
        qunlock(&ipriv->apl);
    }

    ic = (Ilcb*)c->ptcl;
    ic->conv = c;

    if(ic->state != Ilclosed)
        return nil;

    ilcbinit(ic);

    if(fasttimeout){
        /* timeout if we can't connect quickly */
        ic->fasttimeout = 1;
        ic->timeout = NOW+Iltickms;
        ic->rexmit = MaxRexmit - 4;
    };

    switch(type) {
    case IL_CONNECT:
        ic->state = Ilsyncer;
        iphtadd(&ipriv->ht, c);
        ilsendctl(c, nil, Ilsync, ic->start, ic->recvd, 0);
        break;
    case IL_LISTEN:
        ic->state = Illistening;
        iphtadd(&ipriv->ht, c);
        break;
    default:
        //netlog(c->p->f, Logil, "il: start: type %d\n", type);
        break;
    }

    return nil;
}
@



<<function ilcbinit>>=
void
ilcbinit(Ilcb *ic)
{
    ic->start = nrand(0x1000000);
    ic->next = ic->start+1;
    ic->recvd = 0;
    ic->window = Defaultwin;
    ic->unackedbytes = 0;
    ic->unacked = nil;
    ic->outoforder = nil;
    ic->rexmit = 0;
    ic->rxtot = 0;
    ic->rxquery = 0;
    ic->qtx = 1;
    ic->fasttimeout = 0;

    /* timers */
    ic->delay = DefRtt<<LogAGain;
    ic->mdev = DefRtt<<LogDGain;
    ic->rate = DefByteRate<<LogAGain;
    ic->querytime = NOW + QueryTime;
    ic->lastrecv = NOW;	/* or we'll timeout right away */
    ilsettimeout(ic);
}
@
% >> >> >>

\subsection{Close}
% Closing

% ipclose -> closeconv -> <>
<<function ilclose>>=
static void
ilclose(Conv *c)
{
    Ilcb *ic;

    ic = (Ilcb*)c->ptcl;

    qclose(c->rq);
    qclose(c->wq);
    qclose(c->eq);

    switch(ic->state) {
    case Ilclosing:
    case Ilclosed:
        break;
    case Ilsyncer:
    case Ilsyncee:
    case Ilestablished:
        ic->state = Ilclosing;
        ilsettimeout(ic);
        ilsendctl(c, nil, Ilclose, ic->next, ic->recvd, 0);
        break;
    case Illistening:
        illocalclose(c);
        break;
    }
    ilfreeq(ic);
}
@

<<function illocalclose>>=
void
illocalclose(Conv *c)
{
    Ilcb *ic;
    Ilpriv *ipriv;

    ipriv = c->p->priv;
    ic = (Ilcb*)c->ptcl;
    ic->state = Ilclosed;
    iphtrem(&ipriv->ht, c);
    ipmove(c->laddr, IPnoaddr);
    c->lport = 0;
}
@

\subsection{Syncer}

\subsection{Syncee}

\subsection{Establised}

\section{Features}

%\subsection{Delimiters preservation} ??
% apparently TCP does not have this

\subsection{Reliable datagram service}
% via chcksum?

<<global ilcksum>>=
bool 	ilcksum = true;
@
% note that the ip checksum is on its header, here its on its
% data.

\subsection{In sequence delivery}

\subsection{Retransmission of lost messages}

\subsection{Out-of-order messages saving}

\subsection{Adaptive timeouts}

\subsection{Keep-alive}
% to counter denial of service?

\section{Other files}

\subsection{[[/net/il/stats]]}

<<function ilxstats>>=
int
ilxstats(Proto *il, char *buf, int len)
{
    Ilpriv *priv;
    char *p, *e;
    int i;

    priv = il->priv;
    p = buf;
    e = p+len;
    for(i = 0; i < Nstats; i++)
        p = seprint(p, e, "%s: %llud\n", statnames[i], priv->stats[i]);
    return p - buf;
}
@

\subsection{[[/net/il/x/status]]}

<<function ilstate>>=
static int
ilstate(Conv *c, char *state, int n)
{
    Ilcb *ic;

    ic = (Ilcb*)(c->ptcl);
    return snprint(state, n, "%s qin %d qout %d del %5.5d Br %5.5d md %5.5d una %5.5lud rex %5.5d rxq %5.5d max %5.5d\n",
        ilstates[ic->state],
        c->rq ? qlen(c->rq) : 0,
        c->wq ? qlen(c->wq) : 0,
        ic->delay>>LogAGain, ic->rate>>LogAGain, ic->mdev>>LogDGain,
        ic->unackedbytes, ic->rxtot, ic->rxquery, ic->maxrtt);
}
@

\section{Advanced features}

\subsection{Fast timeout}

<<[[ilconnect()]] set fast>>=
/* huge hack to quickly try an il connection */
if(argc > 1){
    p = strstr(argv[1], "!fasttimeout");
    if(p != nil){
        *p = '\0';
        fast = true;
    }
}
@

\subsection{Special extension}
% ilspec field


\chapter{Standard Reliable Communication, TCP}

% RFC 793, Transmission Control Protocol

<<function tcpinit>>=
void
tcpinit(Fs *fs)
{
    Proto *tcp;
    Tcppriv *tpriv;

    tcp = smalloc(sizeof(Proto));
    tpriv = tcp->priv = smalloc(sizeof(Tcppriv));

    tcp->name = "tcp";
    tcp->connect = tcpconnect;
    tcp->announce = tcpannounce;
    tcp->ctl = tcpctl;
    tcp->state = tcpstate;
    tcp->create = tcpcreate;
    tcp->close = tcpclose;
    tcp->rcv = tcpiput;
    tcp->advise = tcpadvise;
    tcp->stats = tcpstats;
    tcp->inuse = tcpinuse;
    tcp->gc = tcpgc;

    tcp->ipproto = IP_TCPPROTO;
    tcp->nc = scalednconv();
    tcp->ptclsize = sizeof(Tcpctl);
    tpriv->stats[MaxConn] = tcp->nc;

    Fsproto(fs, tcp);
}
@

\chapter{Applications}

\section{Remote shell, Telnet}
% works on top of TCP?

\section{Remote file access, TFTP}

\chapter{Remote Procedure Call, 9P}

\chapter{Network File System, exportfs}
% the logical conclusion for all of that.


% con and exportfs
% NFS like?

\chapter{Name Resolution, DNS}

\chapter{Security}

\section{Denial of service}
% hogport? in tcp? tcpporthogdefense

\chapter{Debugging Support}
% the stats? to see the packet loss?

% snoopy? 

\chapter{Profiling Support}
% the stats? to see the packet loss?

\chapter{Advanced Topics}

\section{IPv6}

% See Network_v6.nw

\section{Broadcast}
% convention is that address has all 1s


<<[[ipoput4()]] adjust gate and ifc if broadcast or multicast case>>=
if(r->type & (Rbcast|Rmulti)) {
    gate = eh->dst;
    sr = v4lookup(f, eh->src, nil);
    if(sr != nil && (sr->type & Runi))
        ifc = sr->ifc;
}
@

<<[[findipifc()]] if broadcast or multicast route>>=
/* for now for broadcast and multicast, just use first interface */
if(type & (Rbcast|Rmulti)){
    for(cp = f->ipifc->conv; cp < e; cp++){
        if(*cp == 0)
            continue;
        ifc = (Ipifc*)(*cp)->ptcl;
        if(ifc->lifc != nil)
            return ifc;
    }
}
@


<<[[ipifcadd()]] locals>>=
uchar bcast[IPaddrlen];
@

<<[[ipifcadd()]] add broadcast addresses to self cache>>=
/* add subnet directed broadcast address to the self cache */
for(i = 0; i < IPaddrlen; i++)
    bcast[i] = (ip[i] & mask[i]) | ~mask[i];
addselfcache(f, ifc, lifc, bcast, Rbcast);

/* add subnet directed network address to the self cache */
for(i = 0; i < IPaddrlen; i++)
    bcast[i] = (ip[i] & mask[i]) & mask[i];
addselfcache(f, ifc, lifc, bcast, Rbcast);

/* add network directed broadcast address to the self cache */
memmove(mask, defmask(ip), IPaddrlen);
for(i = 0; i < IPaddrlen; i++)
    bcast[i] = (ip[i] & mask[i]) | ~mask[i];
addselfcache(f, ifc, lifc, bcast, Rbcast);

/* add network directed network address to the self cache */
memmove(mask, defmask(ip), IPaddrlen);
for(i = 0; i < IPaddrlen; i++)
    bcast[i] = (ip[i] & mask[i]) & mask[i];
addselfcache(f, ifc, lifc, bcast, Rbcast);

addselfcache(f, ifc, lifc, IPv4bcast, Rbcast);
@


<<global IPv4bcast>>=
/*
 *  well known IP addresses
 */
uchar IPv4bcast[IPaddrlen] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0xff, 0xff,

    0xff, 0xff, 0xff, 0xff
};
@



\section{Multicast}

<<[[ipwrite()]] locals>>=
uchar ia[IPaddrlen], ma[IPaddrlen];
@

<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "addmulti") == 0){
    if(cb->nf < 2)
        error("addmulti needs interface address");
    if(cb->nf == 2){
        if(!ipismulticast(cv->raddr))
            error("addmulti for a non multicast address");
        if (parseip(ia, cb->f[1]) == -1)
            error(Ebadip);
        ipifcaddmulti(cv, cv->raddr, ia);
    } else {
        if (parseip(ia, cb->f[1]) == -1 ||
            parseip(ma, cb->f[2]) == -1)
            error(Ebadip);
        if(!ipismulticast(ma))
            error("addmulti for a non multicast address");
        ipifcaddmulti(cv, ma, ia);
    }
} 
@
<<[[ipwrite()]] Qctl case, else if other string>>=
else if(strcmp(cb->f[0], "remmulti") == 0){
    if(cb->nf < 2)
        error("remmulti needs interface address");
    if(!ipismulticast(cv->raddr))
        error("remmulti for a non multicast address");
    if (parseip(ia, cb->f[1]) == -1)
        error(Ebadip);
    ipifcremmulti(cv, cv->raddr, ia);
}
@

<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "joinmulti") == 0)
    return ipifcjoinmulti(ifc, argv, argc);
@
<<[[ipifcctl()]] else if other string>>=
else if(strcmp(argv[0], "leavemulti") == 0)
    return ipifcleavemulti(ifc, argv, argc);
@


<<[[Medium(kernel)]] multicast methods>>=
/* for arming interfaces to receive multicast */
void  (*addmulti)(Ipifc *ifc, uchar *a, uchar *ia);
void  (*remmulti)(Ipifc *ifc, uchar *a, uchar *ia);

/* for routing multicast groups */
void  (*joinmulti)(Ipifc *ifc, uchar *a, uchar *ia);
void  (*leavemulti)(Ipifc *ifc, uchar *a, uchar *ia);
@

<<[[Conv(kernel)]] multicast fields>>=
Ipmulti *multi;     /* multicast bindings for this interface */
@

<<[[closeconv()]] locals>>=
Ipmulti *mp;
@
<<[[closeconv()]] if multi, call ipifcremmulti>>=
while((mp = cv->multi) != nil)
    ipifcremmulti(cv, mp->ma, mp->ia);
@

<<[[Netif(kernel)]] multicast fields>>=
Netaddr *maddr;     /* known multicast addresses */
int nmaddr;     /* number of known multicast addresses */
Netaddr *mhash[Nmhash];   /* hash table of multicast addresses */
@

<<[[Netif(kernel)]] multicast methods>>=
void  (*multicast)(void*, uchar*, int);
@





\section{Network database, [[ndb]]}
%less: or mv in advanced features of Name resolution chapter?

<<[[Fs(kernel)]] ndb fields>>=
char  ndb[1024];    /* an ndb entry for this interface */
int ndbvers;
long  ndbmtime;
@

\subsection{[[/net/ndb]]}

<<[[Qid]] toplevel extra cases>>=
Qndb,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qndb:
    p = "ndb";
    len = strlen(f->ndb);
    q.vers = f->ndbvers;
    break;
@

<<[[ip1gen()]] locals>>=
extern ulong    kerndate;
@

<<[[ipgen()]] if Qndb, adjust mtime>>=
if(i == Qndb && f->ndbmtime > kerndate)
    dp->mtime = f->ndbmtime;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qndb:
    if(omode & (OWRITE|OTRUNC) && !iseve())
        error(Eperm);
    if((omode & (OWRITE|OTRUNC)) == (OWRITE|OTRUNC))
        f->ndb[0] = 0;
    break;
@

<<[[ipread()]] switch TYPE qid cases>>=
case Qndb:
    return readstr(offset, a, n, f->ndb);
@

<<[[ipwrite()]] switch TYPE qid cases>>=
case Qndb:
    return ndbwrite(f, a, offset, n);
    break;
@


\section{Connection Server}
% abstract away different address schemes

\section{Sniffing}

% promiscuous mode for ethernet, get all packets even those
% which don't have your MAC as a recipient

\section{Point to point interface}

<<[[ipifcadd()]] check for point to point interface>>=
/* check for point-to-point interface */
if(ipcmp(ip, v6loopback)) /* skip v6 loopback, it's a special address */
if(ipcmp(mask, IPallbits) == 0)
    type |= Rptpt;
@

<<[[ipifcadd()]] register proxy if point to point interface or proxy>>=
if((type & (Rproxy|Rptpt)) == (Rproxy|Rptpt)){
    ipifcregisterproxy(f, ifc, rem);
    goto out;
}
@

\section{Proxy}

<<[[ipifcadd()]] switch argc, proxy case, and fall through>>=
// add <ip> <mask> <rem> <mtu> proxy
case 6:
    if(strcmp(argv[5], "proxy") == 0)
        type |= Rproxy;
    /* fall through */
@

\section{Wifi}

\section{VLAN}

\section{VPN}

%\section{Packet filter}
% /net/ipmux

%\section{Bootp}

%\subsection{[[/net/bootp]]}
%dead:
%
%<<[[Qid]] toplevel extra cases>>=
%Qbootp,
%@
%<<[[ip1gen()]] switch TYPE qid cases>>=
%case Qbootp:
%    p = "bootp";
%    break;
%@
%<<[[ipread()]] switch TYPE qid cases>>=
%case Qbootp:
%    return bootpread(a, offset, n);
%@
%
%<<function bootpread>>=
%int
%bootpread(char*, ulong, int)
%{
%    return  0;
%}
%@
%%I removed entirely inferno.c


\chapter{Conclusion}











\appendix

\chapter{Debugging}

\section{Dumpers}

\subsection{Addresses}
% or masks

<<function eipfmt>>=
int
eipfmt(Fmt *f)
{
    char buf[5*8];
    static char *efmt = "%.2ux%.2ux%.2ux%.2ux%.2ux%.2ux"; // ethernet
    static char *ifmt = "%d.%d.%d.%d"; // internet, v4
    uchar *p;
    uchar ip[16];
    ulong *lp;
    ushort s;
    int i, j, n, eln, eli;

    switch(f->r) {
    case 'E':		/* Ethernet address */
        p = va_arg(f->args, uchar*);
        snprint(buf, sizeof buf, efmt, p[0], p[1], p[2], p[3], p[4], p[5]);
        return fmtstrcpy(f, buf);

    case 'I':		/* Ip address */
        p = va_arg(f->args, uchar*);
common:
        if(memcmp(p, v4prefix, 12) == 0){
            snprint(buf, sizeof buf, ifmt, p[12], p[13], p[14], p[15]);
            return fmtstrcpy(f, buf);
        }

        /* find longest elision */
        eln = eli = -1;
        for(i = 0; i < 16; i += 2){
            for(j = i; j < 16; j += 2)
                if(p[j] != 0 || p[j+1] != 0)
                    break;
            if(j > i && j - i > eln){
                eli = i;
                eln = j - i;
            }
        }

        /* print with possible elision */
        n = 0;
        for(i = 0; i < 16; i += 2){
            if(i == eli){
                n += sprint(buf+n, "::");
                i += eln;
                if(i >= 16)
                    break;
            } else if(i != 0)
                n += sprint(buf+n, ":");
            s = (p[i]<<8) + p[i+1];
            n += sprint(buf+n, "%ux", s);
        }
        return fmtstrcpy(f, buf);

    case 'i':		/* v6 address as 4 longs */
        lp = va_arg(f->args, ulong*);
        for(i = 0; i < 4; i++)
            hnputl(ip+4*i, *lp++);
        p = ip;
        goto common;

    case 'V':		/* v4 ip address */
        p = va_arg(f->args, uchar*);
        snprint(buf, sizeof buf, ifmt, p[0], p[1], p[2], p[3]);
        return fmtstrcpy(f, buf);

    case 'M':		/* ip mask */
        p = va_arg(f->args, uchar*);

        /* look for a prefix mask */
        for(i = 0; i < 16; i++)
            if(p[i] != 0xff)
                break;
        if(i < 16){
            if((prefixvals[p[i]] & Isprefix) == 0)
                goto common;
            for(j = i+1; j < 16; j++)
                if(p[j] != 0)
                    goto common;
            n = 8*i + (prefixvals[p[i]] & ~Isprefix);
        } else
            n = 8*16;

        /* got one, use /xx format */
        snprint(buf, sizeof buf, "/%d", n);
        return fmtstrcpy(f, buf);
    }
    return fmtstrcpy(f, "(eipfmt)");
}
@

\subsection{IP interface}

<<function main>>=
void
main(void)
{
    Ipifc *ifc, *list;
    Iplifc *lifc;
    int i;

    fmtinstall('I', eipfmt);
    fmtinstall('M', eipfmt);

    list = readipifc("/net", nil, -1);
    for(ifc = list; ifc; ifc = ifc->next){
        print("ipifc %s %d\n", ifc->dev, ifc->mtu);
        for(lifc = ifc->lifc; lifc; lifc = lifc->next)
            print("\t%I %M %I\n", lifc->ip, lifc->mask, lifc->net);
    }
}
@

\section{[[/net/log]]}

\subsection{[[Netlog]]}

<<struct Netlog>>=
/*
 *  action log
 */
struct Netlog {
    int opens;

    // array<char> of size Nlog
    char*   buf;
    int len;

    char    *rptr;
    char    *end;


    int logmask;            /* mask of things to debug */
    uchar   iponly[IPaddrlen];      /* ip address to print debugging for */
    int iponlyset;

    // Extra
    Lock;
    QLock;
    Rendez;
};
@

<<enum _anon_ (kernel/network/ip/netlog.c)>>=
enum {
    Nlog        = 16*1024,
};
@


<<[[Fs(kernel)]] logging fields>>=
Netlog  *alog;
@

% ipattach -> ... -> <>
<<function netloginit>>=
void
netloginit(Fs *f)
{
    f->alog = smalloc(sizeof(Netlog));
}
@

\subsection{[[/net/log]]}

<<[[Qid]] toplevel extra cases>>=
Qlog,
@

<<[[ip1gen()]] switch TYPE qid cases>>=
case Qlog:
    p = "log";
    break;
@
<<[[ipopen()]] switch TYPE qid cases>>=
case Qlog:
    netlogopen(f);
    break;
@
<<[[ipclose()]] switch TYPE qid cases>>=
case Qlog:
    if(c->flag & COPEN)
        netlogclose(f);
    break;
@
<<[[ipread()]] switch TYPE qid cases>>=
case Qlog:
    return netlogread(f, a, offset, n);
@
<<[[ipwrite()]] switch TYPE qid cases>>=
case Qlog:
    netlogctl(f, a, n);
    return n;
@

\subsection{Opening}

<<function netlogopen>>=
void
netlogopen(Fs *f)
{
    lock(f->alog);
    if(waserror()){
        unlock(f->alog);
        nexterror();
    }
    if(f->alog->opens == 0){
        if(f->alog->buf == nil)
            f->alog->buf = malloc(Nlog);
        if(f->alog->buf == nil)
            error(Enomem);
        f->alog->rptr = f->alog->buf;
        f->alog->end = f->alog->buf + Nlog;
    }
    f->alog->opens++;
    unlock(f->alog);
    poperror();
}
@

\subsection{Reading}

<<function netlogread>>=
long
netlogread(Fs *f, void *a, ulong, long n)
{
    int i, d;
    char *p, *rptr;

    qlock(f->alog);
    if(waserror()){
        qunlock(f->alog);
        nexterror();
    }

    for(;;){
        lock(f->alog);
        if(f->alog->len){
            if(n > f->alog->len)
                n = f->alog->len;
            d = 0;
            rptr = f->alog->rptr;
            f->alog->rptr += n;
            if(f->alog->rptr >= f->alog->end){
                d = f->alog->rptr - f->alog->end;
                f->alog->rptr = f->alog->buf + d;
            }
            f->alog->len -= n;
            unlock(f->alog);

            i = n-d;
            p = a;
            memmove(p, rptr, i);
            memmove(p+i, f->alog->buf, d);
            break;
        }
        else
            unlock(f->alog);

        sleep(f->alog, netlogready, f);
    }

    qunlock(f->alog);
    poperror();

    return n;
}
@

<<function netlogready>>=
static bool
netlogready(void *a)
{
    Fs *f = a;

    return f->alog->len;
}
@


\subsection{Control}

<<enum _anon_ (kernel/network/ip/netlog.c)2>>=
enum
{
    CMset,
    CMclear,
    CMonly,
};
@

<<global routecmd>>=
static
Cmdtab routecmd[] = {
    CMset,      "set",      0,
    CMclear,    "clear",    0,
    CMonly,     "only",     0,
};
@



<<function netlogctl>>=
void
netlogctl(Fs *f, char* s, int n)
{
    int i, set;
    Netlogflag *fp;
    Cmdbuf *cb;
    Cmdtab *ct;

    cb = parsecmd(s, n);
    if(waserror()){
        free(cb);
        nexterror();
    }

    if(cb->nf < 2)
        error(Ebadnetctl);

    ct = lookupcmd(cb, routecmd, nelem(routecmd));

    SET(set);

    switch(ct->index){
    case CMset:
        set = 1;
        break;

    case CMclear:
        set = 0;
        break;

    case CMonly:
        parseip(f->alog->iponly, cb->f[1]);
        if(ipcmp(f->alog->iponly, IPnoaddr) == 0)
            f->alog->iponlyset = 0;
        else
            f->alog->iponlyset = 1;
        free(cb);
        poperror();
        return;

    default:
        cmderror(cb, "unknown netlog control message");
    }

    for(i = 1; i < cb->nf; i++){
        for(fp = flags; fp->name; fp++)
            if(strcmp(fp->name, cb->f[i]) == 0)
                break;
        if(fp->name == nil)
            continue;
        if(set)
            f->alog->logmask |= fp->mask;
        else
            f->alog->logmask &= ~fp->mask;
    }

    free(cb);
    poperror();
}
@

\section{[[/bin/snoopy]]}
% useful only to debug network stack? or could be considered
% a Debugging Support chapter?

\subsection{[[/net/ipifc/x/snoop]]}

<<[[Qid]] conversation extra cases, last entry>>=
Qsnoop,
@
% has to be the last, because will do -1 below

<<[[Conv(kernel)]] snoop fields>>=
Ref snoopers;   /* number of processes with snoop open */
Queue*  sq;     /* snooping queue */
@
% those fields are valid only for /net/ipifc/x/snoop, a bit a waste.
%todo: who initialize sq?



<<[[ip3gen()]] switch TYPE qid cases>>=
case Qsnoop:
    if(strcmp(cv->p->name, "ipifc") != 0)
        return -1;
    devdir(c, q, "snoop", qlen(cv->sq), cv->owner, 0400, dp);
    return 1;
@
% only for ipifc protocol
% size = stop queue?

<<[[ipopen()]] switch TYPE qid cases>>=
case Qsnoop:
    if(omode != OREAD)
        error(Eperm);
    p = f->p[PROTO(c->qid)];
    cv = p->conv[CONV(c->qid)];
    if(strcmp(ATTACHER(c), cv->owner) != 0 && !iseve())
        error(Eperm);
    incref(&cv->snoopers);
    break;
@
<<[[ipclose()]] switch TYPE qid cases>>=
case Qsnoop:
    if(c->flag & COPEN)
        decref(&f->p[PROTO(c->qid)]->conv[CONV(c->qid)]->snoopers);
    break;
@


<<[[ipread()]] switch TYPE qid cases>>=
case Qsnoop:
    cv = f->p[PROTO(ch->qid)]->conv[CONV(ch->qid)];
    return qread(cv->sq, a, n);
@






\subsection{[[/bin/snoopy]]}


<<function printusage>>=
void
printusage(void)
{
    fprint(2, "usage: %s [-CDdpst] [-N n] [-f filter] [-h first-header] path\n", argv0);
    fprint(2, "  for protocol help: %s -? [proto]\n", argv0);
}
@

<<function usage (networking/ip/snoopy/main.c)>>=
void
usage(void)
{
    printusage();
    exits("usage");
}
@



\chapter{Profiling}


\section{[[/net/x/stats]]}

% /net/x/stats? hmm it's more for user than for programmer of the
% network stack itself, but yes it can be useful too.

% /net/ipifc/stats
% /net/icmp/stats
% /net/tcp/stats


\chapter{Error Managment}

% have seen already all those err, most protocol methods return
% a char* which is an error string or nil.

\chapter{Ethernet NE2000 Driver}
% like I did in Graphics.nw and the VGA driver
% with again a classic device, the NE2000! (I even got it, like for the cirrus)
% alt: Intel Pro/1000  but far bigger

\section{Data structures}

\subsection{Ethernet [[Dp8390]] controller}

% priv field Ether.ctrl
<<struct Dp8390>>=
/*
 * Ctlr for the boards using the National Semiconductor DP8390
 * and SMC 83C90 Network Interface Controller.
 * Common code is in ether8390.c.
 */
struct Dp8390 {
    ulong	port;			/* I/O address of 8390 */
    ulong	data;			/* I/O data port if no shared memory */

    uchar	width;			/* data transfer width in bytes */
    bool	ram;			/* true if card has shared memory */
    uchar	dummyrr;		/* do dummy remote read */

    uchar	nxtpkt;			/* receive: software bndry */
    uchar	pstart;
    uchar	pstop;

    int	txbusy;			/* transmit */
    uchar	tstart;			/* 8390 ring addresses */

    <<[[Dp8390]] multicast fields>>

    // Extra
    Lock;
};
@


\section{Initialisation}

% qemu.c -> <>
<<function ether2000link>>=
void
ether2000link(void)
{
    addethercard("NE2000", ne2000reset);
}
@

% ??? -> <> (as ?? <- addethercard(..., <>) <- ether2000link)
<<function ne2000reset>>=
static errorneg1
ne2000reset(Ether* edev)
{
    ushort buf[16];
    ulong port;
    Dp8390 *dp8390;
    int i;
    uchar ea[Eaddrlen];

    if(edev->port == 0)
        ne2000pnp(edev);
    if(edev->port == 0)
        return ERROR_NEG1;

    /*
     * Set up the software configuration.
     * Use defaults for irq, mem and size
     * if not specified.
     * Must have a port, no more default.
     */
    if(edev->irq == 0)
        edev->irq = 2;
    if(edev->mem == 0)
        edev->mem = 0x4000;
    if(edev->size == 0)
        edev->size = 16*1024;
    port = edev->port;

    if(ioalloc(edev->port, 0x20, 0, "ne2000") < 0)
        return ERROR_NEG1;

    edev->ctlr = malloc(sizeof(Dp8390));
    dp8390 = edev->ctlr;
    if(dp8390 == nil)
        error(Enomem);

    dp8390->width = 2;
    dp8390->ram = false;

    dp8390->port = port;
    dp8390->data = port+Data;

    dp8390->tstart = HOWMANY(edev->mem, Dp8390BufSz);
    dp8390->pstart = dp8390->tstart + HOWMANY(sizeof(Etherpkt), Dp8390BufSz);
    dp8390->pstop = dp8390->tstart + HOWMANY(edev->size, Dp8390BufSz);

    dp8390->dummyrr = 1;
    for(i = 0; i < edev->nopt; i++){
        if(strcmp(edev->opt[i], "nodummyrr"))
            continue;
        dp8390->dummyrr = 0;
        break;
    }

    /*
     * Reset the board. This is done by doing a read
     * followed by a write to the Reset address.
     */
    buf[0] = inb(port+Reset);
    delay(2);
    outb(port+Reset, buf[0]);
    delay(2);
    
    /*
     * Init the (possible) chip, then use the (possible)
     * chip to read the (possible) PROM for ethernet address
     * and a marker byte.
     * Could just look at the DP8390 command register after
     * initialisation has been tried, but that wouldn't be
     * enough, there are other ethernet boards which could
     * match.
     * Parallels has buf[0x0E] == 0x00 whereas real hardware
     * usually has 0x57.
     */

    // will fill in the Ether callbacks
    dp8390reset(edev);

    memset(buf, 0, sizeof(buf));
    dp8390read(dp8390, buf, 0, sizeof(buf));
    i = buf[0x0E] & 0xFF;
    if((i != 0x00 && i != 0x57) || (buf[0x0F] & 0xFF) != 0x57){
        iofree(edev->port);
        free(edev->ctlr);
        return ERROR_NEG1;
    }

    /*
     * Stupid machine. Shorts were asked for,
     * shorts were delivered, although the PROM is a byte array.
     * Set the ethernet address.
     */
    memset(ea, 0, Eaddrlen);
    if(memcmp(ea, edev->ea, Eaddrlen) == 0){
        for(i = 0; i < sizeof(edev->ea); i++)
            edev->ea[i] = buf[i];
    }
    dp8390setea(edev);

    return OK_0;
}
@

<<function dp8390read>>=
void*
dp8390read(Dp8390* ctlr, void* to, ulong from, ulong len)
{
    void *v;

    ilock(ctlr);
    v = _dp8390read(ctlr, to, from, len);
    iunlock(ctlr);

    return v;
}
@


<<function dp8390reset>>=
int
dp8390reset(Ether* ether)
{
    Dp8390 *ctlr;

    ctlr = ether->ctlr;

    /*
     * This is the initialisation procedure described
     * as 'mandatory' in the datasheet, with references
     * to the 3C503 technical reference manual.
     */ 
    disable(ctlr);
    if(ctlr->width != 1)
        regw(ctlr, Dcr, Ft4WORD|Ls|Wts);
    else
        regw(ctlr, Dcr, Ft4WORD|Ls);

    regw(ctlr, Rbcr0, 0);
    regw(ctlr, Rbcr1, 0);

    regw(ctlr, Tcr, LpbkNIC);
    regw(ctlr, Rcr, Mon);

    /*
     * Init the ring hardware and software ring pointers.
     * Can't initialise ethernet address as it may not be
     * known yet.
     */
    ringinit(ctlr);
    regw(ctlr, Tpsr, ctlr->tstart);

    /*
     * Clear any pending interrupts and mask then all off.
     */
    regw(ctlr, Isr, 0xFF);
    regw(ctlr, Imr, 0);

    /*
     * Leave the chip initialised,
     * but in monitor mode.
     */
    regw(ctlr, Cr, Page0|RdABORT|Sta);



    /*
     * Set up the software configuration.
     */
    ether->attach = attach;
    ether->shutdown = shutdown;

    ether->transmit = transmit;
    ether->interrupt = interrupt;
    ether->ifstat = 0;

    ether->promiscuous = promiscuous;
    ether->multicast = multicast;
    ether->arg = ether;

    return 0;
}
@

<<function ringinit>>=
static void
ringinit(Dp8390* ctlr)
{
    regw(ctlr, Pstart, ctlr->pstart);
    regw(ctlr, Pstop, ctlr->pstop);
    regw(ctlr, Bnry, ctlr->pstop-1);

    regw(ctlr, Cr, Page1|RdABORT|Stp);
    regw(ctlr, Curr, ctlr->pstart);
    regw(ctlr, Cr, Page0|RdABORT|Stp);

    ctlr->nxtpkt = ctlr->pstart;
}
@


<<function dp8390setea>>=
void
dp8390setea(Ether* ether)
{
    int i;
    uchar cr;
    Dp8390 *ctlr;

    ctlr = ether->ctlr;

    /*
     * Set the ethernet address into the chip.
     * Take care to restore the command register
     * afterwards. Don't care about multicast
     * addresses as multicast is never enabled
     * (currently).
     */
    ilock(ctlr);
    cr = regr(ctlr, Cr) & ~Txp;
    regw(ctlr, Cr, Page1|(~(Ps1|Ps0) & cr));
    for(i = 0; i < Eaddrlen; i++)
        regw(ctlr, Par0+i, ether->ea[i]);
    regw(ctlr, Cr, cr);
    iunlock(ctlr);
}
@


<<function disable>>=
static void
disable(Dp8390* ctlr)
{
    int timo;

    /*
     * Stop the chip. Set the Stp bit and wait for the chip
     * to finish whatever was on its tiny mind before it sets
     * the Rst bit.
     * The timeout is needed because there may not be a real
     * chip there if this is called when probing for a device
     * at boot.
     */
    regw(ctlr, Cr, Page0|RdABORT|Stp);
    regw(ctlr, Rbcr0, 0);
    regw(ctlr, Rbcr1, 0);
    for(timo = 10000; (regr(ctlr, Isr) & Rst) == 0 && timo; timo--)
            ;
}
@

<<function shutdown>>=
static void
shutdown(Ether *ether)
{
    Dp8390 *ctlr;

    ctlr = ether->ctlr;
    disable(ctlr);
}
@



\section{Mounting}

<<function attach>>=
static void
attach(Ether* ether)
{
    Dp8390 *ctlr;
    uchar r;

    ctlr = ether->ctlr;

    /*
     * Enable the chip for transmit/receive.
     * The init routine leaves the chip in monitor
     * mode. Clear the missed-packet counter, it
     * increments while in monitor mode.
     * Sometimes there's an interrupt pending at this
     * point but there's nothing in the Isr, so
     * any pending interrupts are cleared and the
     * mask of acceptable interrupts is enabled here.
     */
    r = Ab;
    if(ether->prom)
        r |= Pro;
    if(ether->nmaddr)
        r |= Am;
    ilock(ctlr);
    regw(ctlr, Isr, 0xFF);
    regw(ctlr, Imr, Cnt|Ovw|Txe|Rxe|Ptx|Prx);
    regw(ctlr, Rcr, r);
    r = regr(ctlr, Ref2);
    regw(ctlr, Tcr, LpbkNORMAL);
    iunlock(ctlr);
    USED(r);
}
@


\section{IO}

<<macro regw>>=
#define regw(c, r, v)	outb((c)->port+(r), (v))
@

<<macro regr>>=
/*
 * x86-specific code.
 */
#define regr(c, r)	inb((c)->port+(r))
@

\subsection{Writing}

<<function transmit (kernel/network/386/ether8390.c)>>=
static void
transmit(Ether* ether)
{
    Dp8390 *ctlr;

    ctlr = ether->ctlr;

    ilock(ctlr);
    txstart(ether);
    iunlock(ctlr);
}
@

<<function txstart>>=
static void
txstart(Ether* ether)
{
    int len;
    Dp8390 *ctlr;
    Block *bp;
    uchar minpkt[ETHERMINTU], *rp;

    ctlr = ether->ctlr;

    /*
     * This routine is called both from the top level and from interrupt
     * level and expects to be called with ctlr already locked.
     */
    if(ctlr->txbusy)
        return;
    bp = qget(ether->oq);
    if(bp == nil)
        return;

    /*
     * Make sure the packet is of minimum length;
     * copy it to the card's memory by the appropriate means;
     * start the transmission.
     */
    len = BLEN(bp);
    rp = bp->rp;
    if(len < ETHERMINTU){
        rp = minpkt;
        memmove(rp, bp->rp, len);
        memset(rp+len, 0, ETHERMINTU-len);
        len = ETHERMINTU;
    }

    if(ctlr->ram)
        memmove((void*)(ether->mem+ctlr->tstart*Dp8390BufSz), rp, len);
    else
        dp8390write(ctlr, ctlr->tstart*Dp8390BufSz, rp, len);
    freeb(bp);

    regw(ctlr, Tbcr0, len & 0xFF);
    regw(ctlr, Tbcr1, (len>>8) & 0xFF);
    regw(ctlr, Cr, Page0|RdABORT|Txp|Sta);

    ether->outpackets++;
    ctlr->txbusy = 1;
}
@

<<function dp8390write>>=
static void*
dp8390write(Dp8390* ctlr, ulong to, void* from, ulong len)
{
    ulong crda;
    uchar cr;
    int timo, width;

top:
    /*
     * Write some data to offset 'to' in the card's memory
     * using the DP8390 remote DMA facility, reading it at
     * 'from' in main memory, via the I/O data port.
     */
    cr = regr(ctlr, Cr) & ~Txp;
    regw(ctlr, Cr, Page0|RdABORT|Sta);
    regw(ctlr, Isr, Rdc);

    len = ROUNDUP(len, ctlr->width);

    /*
     * Set up the remote DMA address and count.
     * This is straight from the DP8390[12D] datasheet,
     * hence the initial set up for read.
     * Assumption here that the A7000 EtherV card will
     * never need a dummyrr.
     */
    if(ctlr->dummyrr && (ctlr->width == 1 || ctlr->width == 2)){
        if(ctlr->width == 2)
            width = 1;
        else
            width = 0;
        crda = to-1-width;
        regw(ctlr, Rbcr0, (len+1+width) & 0xFF);
        regw(ctlr, Rbcr1, ((len+1+width)>>8) & 0xFF);
        regw(ctlr, Rsar0, crda & 0xFF);
        regw(ctlr, Rsar1, (crda>>8) & 0xFF);
        regw(ctlr, Cr, Page0|RdREAD|Sta);
    
        for(timo=0;; timo++){
            if(timo > 10000){
                print("ether8390: dummyrr timeout; assuming nodummyrr\n");
                ctlr->dummyrr = 0;
                goto top;
            }
            crda = regr(ctlr, Crda0);
            crda |= regr(ctlr, Crda1)<<8;
            if(crda == to){
                /*
                 * Start the remote DMA write and make sure
                 * the registers are correct.
                 */
                regw(ctlr, Cr, Page0|RdWRITE|Sta);
    
                crda = regr(ctlr, Crda0);
                crda |= regr(ctlr, Crda1)<<8;
                if(crda != to)
                    panic("crda write %lud to %lud\n", crda, to);
    
                break;
            }
        }
    }
    else{
        regw(ctlr, Rsar0, to & 0xFF);
        regw(ctlr, Rsar1, (to>>8) & 0xFF);
        regw(ctlr, Rbcr0, len & 0xFF);
        regw(ctlr, Rbcr1, (len>>8) & 0xFF);
        regw(ctlr, Cr, Page0|RdWRITE|Sta);
    }

    /*
     * Pump the data into the I/O port
     * then wait for the remote DMA to finish.
     */
    rdwrite(ctlr, from, len);
    for(timo = 10000; (regr(ctlr, Isr) & Rdc) == 0 && timo; timo--)
            ;

    regw(ctlr, Isr, Rdc);
    regw(ctlr, Cr, cr);

    return (void*)to;
}
@

<<function rdwrite>>=
static void
rdwrite(Dp8390* ctlr, void* from, int len)
{
    switch(ctlr->width){
    default:
        panic("dp8390 rdwrite: width %d\n", ctlr->width);
        break;

    case 2:
        outss(ctlr->data, from, len/2);
        break;

    case 1:
        outsb(ctlr->data, from, len);
        break;
    }
}
@




\subsection{Reading}

<<function interrupt (kernel/network/386/ether8390.c)>>=
static void
interrupt(Ureg*, void* arg)
{
    Ether *ether;
    Dp8390 *ctlr;
    uchar isr, r;

    ether = arg;
    ctlr = ether->ctlr;

    /*
     * While there is something of interest,
     * clear all the interrupts and process.
     */
    ilock(ctlr);
    regw(ctlr, Imr, 0x00);
    while(isr = (regr(ctlr, Isr) & (Cnt|Ovw|Txe|Rxe|Ptx|Prx))){
        if(isr & Ovw){
            overflow(ether);
            regw(ctlr, Isr, Ovw);
            ether->overflows++;
        }

        /*
         * Packets have been received.
         * Take a spin round the ring.
         */
        if(isr & (Rxe|Prx)){
            receive(ether);
            regw(ctlr, Isr, Rxe|Prx);
        }

        /*
         * A packet completed transmission, successfully or
         * not. Start transmission on the next buffered packet,
         * and wake the output routine.
         */
        if(isr & (Txe|Ptx)){
            r = regr(ctlr, Tsr);
            if((isr & Txe) && (r & (Cdh|Fu|Crs|Abt))){
                print("dp8390: Tsr %#2.2ux", r);
                ether->oerrs++;
            }

            regw(ctlr, Isr, Txe|Ptx);

            if(isr & Ptx)
                ether->outpackets++;
            ctlr->txbusy = 0;
            txstart(ether);
        }

        if(isr & Cnt){
            ether->frames += regr(ctlr, Ref0);
            ether->crcs += regr(ctlr, Ref1);
            ether->buffs += regr(ctlr, Ref2);
            regw(ctlr, Isr, Cnt);
        }
    }
    regw(ctlr, Imr, Cnt|Ovw|Txe|Rxe|Ptx|Prx);
    iunlock(ctlr);
}
@

<<function receive (kernel/network/386/ether8390.c)>>=
static void
receive(Ether* ether)
{
    Dp8390 *ctlr;
    uchar curr, *p;
    Hdr hdr;
    ulong count, data, len;
    Block *bp;

    ctlr = ether->ctlr;
    for(curr = getcurr(ctlr); ctlr->nxtpkt != curr; curr = getcurr(ctlr)){
        data = ctlr->nxtpkt*Dp8390BufSz;
        if(ctlr->ram)
            memmove(&hdr, (void*)(ether->mem+data), sizeof(Hdr));
        else
            _dp8390read(ctlr, &hdr, data, sizeof(Hdr));

        /*
         * Don't believe the upper byte count, work it
         * out from the software next-page pointer and
         * the current next-page pointer.
         */
        if(hdr.next > ctlr->nxtpkt)
            len = hdr.next - ctlr->nxtpkt - 1;
        else
            len = (ctlr->pstop-ctlr->nxtpkt) + (hdr.next-ctlr->pstart) - 1;
        if(hdr.len0 > (Dp8390BufSz-sizeof(Hdr)))
            len--;

        len = ((len<<8)|hdr.len0)-4;

        /*
         * Chip is badly scrogged, reinitialise the ring.
         */
        if(hdr.next < ctlr->pstart || hdr.next >= ctlr->pstop
          || len < 60 || len > sizeof(Etherpkt)){
            print("dp8390: H%2.2ux+%2.2ux+%2.2ux+%2.2ux,%lud\n",
                hdr.status, hdr.next, hdr.len0, hdr.len1, len);
            regw(ctlr, Cr, Page0|RdABORT|Stp);
            ringinit(ctlr);
            regw(ctlr, Cr, Page0|RdABORT|Sta);

            return;
        }

        /*
         * If it's a good packet read it in to the software buffer.
         * If the packet wraps round the hardware ring, read it in
         * two pieces.
         */
        if((hdr.status & (Fo|Fae|Crce|Prxok)) == Prxok && (bp = iallocb(len))){
            p = bp->rp;
            bp->wp = p+len;
            data += sizeof(Hdr);

            if((data+len) >= ctlr->pstop*Dp8390BufSz){
                count = ctlr->pstop*Dp8390BufSz - data;
                if(ctlr->ram)
                    memmove(p, (void*)(ether->mem+data), count);
                else
                    _dp8390read(ctlr, p, data, count);
                p += count;
                data = ctlr->pstart*Dp8390BufSz;
                len -= count;
            }
            if(len){
                if(ctlr->ram)
                    memmove(p, (void*)(ether->mem+data), len);
                else
                    _dp8390read(ctlr, p, data, len);
            }

            /*
             * Copy the packet to whoever wants it.
             */
            etheriq(ether, bp, 1);
        }

        /*
         * Finished with this packet, update the
         * hardware and software ring pointers.
         */
        ctlr->nxtpkt = hdr.next;

        hdr.next--;
        if(hdr.next < ctlr->pstart)
            hdr.next = ctlr->pstop-1;
        regw(ctlr, Bnry, hdr.next);
    }
}
@
% >> >>

<<function getcurr>>=
static uchar
getcurr(Dp8390* ctlr)
{
    uchar cr, curr;

    cr = regr(ctlr, Cr) & ~Txp;
    regw(ctlr, Cr, Page1|(~(Ps1|Ps0) & cr));
    curr = regr(ctlr, Curr);
    regw(ctlr, Cr, cr);

    return curr;
}
@


<<function _dp8390read>>=
static void*
_dp8390read(Dp8390* ctlr, void* to, ulong from, ulong len)
{
    uchar cr;
    int timo;

    /*
     * Read some data at offset 'from' in the card's memory
     * using the DP8390 remote DMA facility, and place it at
     * 'to' in main memory, via the I/O data port.
     */
    cr = regr(ctlr, Cr) & ~Txp;
    regw(ctlr, Cr, Page0|RdABORT|Sta);
    regw(ctlr, Isr, Rdc);

    /*
     * Set up the remote DMA address and count.
     */
    len = ROUNDUP(len, ctlr->width);
    regw(ctlr, Rbcr0, len & 0xFF);
    regw(ctlr, Rbcr1, (len>>8) & 0xFF);
    regw(ctlr, Rsar0, from & 0xFF);
    regw(ctlr, Rsar1, (from>>8) & 0xFF);

    /*
     * Start the remote DMA read and suck the data
     * out of the I/O port.
     */
    regw(ctlr, Cr, Page0|RdREAD|Sta);
    rdread(ctlr, to, len);

    /*
     * Wait for the remote DMA to complete. The timeout
     * is necessary because this routine may be called on
     * a non-existent chip during initialisation and, due
     * to the miracles of the bus, it's possible to get this
     * far and still be talking to a slot full of nothing.
     */
    for(timo = 10000; (regr(ctlr, Isr) & Rdc) == 0 && timo; timo--)
            ;

    regw(ctlr, Isr, Rdc);
    regw(ctlr, Cr, cr);

    return to;
}
@



<<function overflow>>=
static void
overflow(Ether *ether)
{
    Dp8390 *ctlr;
    uchar txp;
    int resend;

    ctlr = ether->ctlr;

    /*
     * The following procedure is taken from the DP8390[12D] datasheet,
     * it seems pretty adamant that this is what has to be done.
     */
    txp = regr(ctlr, Cr) & Txp;
    regw(ctlr, Cr, Page0|RdABORT|Stp);
    delay(2);
    regw(ctlr, Rbcr0, 0);
    regw(ctlr, Rbcr1, 0);

    resend = 0;
    if(txp && (regr(ctlr, Isr) & (Txe|Ptx)) == 0)
        resend = 1;

    regw(ctlr, Tcr, LpbkNIC);
    regw(ctlr, Cr, Page0|RdABORT|Sta);
    receive(ether);
    regw(ctlr, Isr, Ovw);
    regw(ctlr, Tcr, LpbkNORMAL);

    if(resend)
        regw(ctlr, Cr, Page0|RdABORT|Txp|Sta);
}
@


\section{Advanced features}

\subsection{Multicast}

<<[[Dp8390]] multicast fields>>=
uchar	mar[8];			/* shadow multicast address registers */
int	mref[64];		/* reference counts for multicast groups */
@

<<global reverse>>=
static uchar reverse[64];
@

<<function multicast>>=
static void
multicast(void* arg, uchar *addr, int on)
{
    Ether *ether;
    Dp8390 *ctlr;
    int i;
    ulong h;

    ether = arg;
    ctlr = ether->ctlr;
    if(reverse[1] == 0){
        for(i = 0; i < 64; i++)
            reverse[i] = ((i&1)<<5) | ((i&2)<<3) | ((i&4)<<1)
                   | ((i&8)>>1) | ((i&16)>>3) | ((i&32)>>5);
    }

    /*
     *  change filter bits
     */
    h = ethercrc(addr, 6);
    ilock(ctlr);
    setbit(ctlr, reverse[h&0x3f], on);
    setfilter(ether, ctlr);
    iunlock(ctlr);
}
@

<<global allmar>>=
static uchar allmar[8] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
@

<<function setbit>>=
static void
setbit(Dp8390 *ctlr, int bit, int on)
{
    int i, h;

    i = bit/8;
    h = bit%8;
    if(on){
        if(++(ctlr->mref[bit]) == 1)
            ctlr->mar[i] |= 1<<h;
    } else {
        if(--(ctlr->mref[bit]) <= 0){
            ctlr->mref[bit] = 0;
            ctlr->mar[i] &= ~(1<<h);
        }
    }
}
@


<<function setfilter>>=
static void
setfilter(Ether *ether, Dp8390 *ctlr)
{
    uchar r, cr;
    int i;
    uchar *mar;

    r = Ab;
    mar = 0;
    if(ether->prom){
        r |= Pro|Am;
        mar = allmar;
    } else if(ether->nmaddr){
        r |= Am;
        mar = ctlr->mar;
    }
    if(mar){
        cr = regr(ctlr, Cr) & ~Txp;
        regw(ctlr, Cr, Page1|(~(Ps1|Ps0) & cr));
        for(i = 0; i < 8; i++)
            regw(ctlr, Mar0+i, *(mar++));
        regw(ctlr, Cr, cr);
    }
    regw(ctlr, Rcr, r);
}
@

\subsection{Promiscuous mode}

<<function promiscuous>>=
static void
promiscuous(void *arg, int )
{
    Ether *ether;
    Dp8390 *ctlr;

    ether = arg;
    ctlr = ether->ctlr;

    ilock(ctlr);
    setfilter(ether, ctlr);
    iunlock(ctlr);
}
@

\subsection{Power managment}

\subsection{Plug and play}

<<struct Ctlr (kernel/network/386/ether2000.c)>>=
struct Ctlr {
    Pcidev*	pcidev;
    Ctlr*	next;
    int	active;
};
@

<<global ctlrhead (kernel/network/386/ether2000.c)>>=
static Ctlr* ctlrhead;
@

<<global ctlrtail (kernel/network/386/ether2000.c)>>=
static Ctlr* ctlrtail;
@


<<function ne2000pnp>>=
static void
ne2000pnp(Ether* edev)
{
    int i, id;
    Pcidev *p;
    Ctlr *ctlr;

    /*
     * Make a list of all ethernet controllers
     * if not already done.
     */
    if(ctlrhead == nil){
        p = nil;
        while(p = pcimatch(p, 0, 0)){
            if(p->ccrb != 0x02 || p->ccru != 0)
                continue;
            ctlr = malloc(sizeof(Ctlr));
            if(ctlr == nil)
                error(Enomem);
            ctlr->pcidev = p;

            if(ctlrhead != nil)
                ctlrtail->next = ctlr;
            else
                ctlrhead = ctlr;
            ctlrtail = ctlr;
        }
    }

    /*
     * Is it a card with an unrecognised vid+did?
     * Normally a search is made through all the found controllers
     * for one which matches any of the known vid+did pairs.
     * If a vid+did pair is specified a search is made for that
     * specific controller only.
     */
    id = 0;
    for(i = 0; i < edev->nopt; i++){
        if(cistrncmp(edev->opt[i], "id=", 3) == 0)
            id = strtol(&edev->opt[i][3], nil, 0);
    }

    if(id != 0)
        ne2000match(edev, id);
    else for(i = 0; ne2000pci[i].name; i++){
        if(ne2000match(edev, ne2000pci[i].id) != nil)
            break;
    }
}
@

<<global ne2000pci>>=
static struct {
    char*	name;
    int	id;
} ne2000pci[] = {
    { "Realtek 8029",	(0x8029<<16)|0x10EC, },
    { "Winbond 89C940",	(0x0940<<16)|0x1050, },
    { nil },
};
@


<<function ne2000match>>=
static Ctlr*
ne2000match(Ether* edev, int id)
{
    int port;
    Pcidev *p;
    Ctlr *ctlr;

    /*
     * Any adapter matches if no edev->port is supplied,
     * otherwise the ports must match.
     */
    for(ctlr = ctlrhead; ctlr != nil; ctlr = ctlr->next){
        if(ctlr->active)
            continue;
        p = ctlr->pcidev;
        if(((p->did<<16)|p->vid) != id)
            continue;
        port = p->mem[0].bar & ~0x01;
        if(edev->port != 0 && edev->port != port)
            continue;

        /*
         * It suffices to fill these in,
         * the rest is gleaned from the card.
         */
        edev->port = port;
        edev->irq = p->intl;

        ctlr->active = 1;

        return ctlr;
    }

    return nil;
}
@


\chapter{Libc}

\section{Globbing}

% a few things have a format accepting "*"


\chapter{Extra Mediums}

\section{Null medium}

<<global nullmedium>>=
Medium nullmedium =
{
    .name=      "null",

    .bind=      nullbind,
    .unbind=    nullunbind,

    .bwrite=    nullbwrite,
};
@
% no pktin?

<<function nullbind>>=
static void
nullbind(Ipifc*, int, char**)
{
    error("cannot bind null device");
}
@

<<function nullunbind>>=
static void
nullunbind(Ipifc*)
{
}
@

<<function nullbwrite>>=
static void
nullbwrite(Ipifc*, Block*, int, uchar*)
{
    error("nullbwrite");
}
@

% in qemu.c
<<function nullmediumlink>>=
void
nullmediumlink(void)
{
    addipmedium(&nullmedium);
}
@

\section{Loopback medium}
% mv in advanced topics? more important than the other?

% echo 'bind loopback' > /net/ipifc/x/ctl

% can be useful to create kinda of named pipes but using
% ip protocol stack? to help debug things?

<<global loopbackmedium>>=
Medium loopbackmedium =
{
    .name=      "loopback",

    .hsize=     0,
    .mintu=     0,
    .maxtu=     Maxtu,
    .maclen=    0,

    .bind=      loopbackbind,
    .unbind=    loopbackunbind,
    .bwrite=    loopbackbwrite,
};
@
% maclen 0 ? no need, it can reach only this machine.
% no header? again, no dest so no need any header.

<<enum _anon_ (kernel/network/ip/loopbackmedium.c)>>=
enum
{
    Maxtu=  16*1024,
};
@

<<function loopbackmediumlink>>=
void
loopbackmediumlink(void)
{
    addipmedium(&loopbackmedium);
}
@

% private Ipifc data, ifc->arg
<<struct LB>>=
struct LB
{
    Queue   *q;
    Fs  *f;
    Proc    *readp;
};
@

<<function loopbackbind>>=
static void
loopbackbind(Ipifc *ifc, int, char**)
{
    LB *lb;

    lb = smalloc(sizeof(LB));
    lb->f = ifc->conv->p->f;
    lb->q = qopen(1024*1024, Qmsg, nil, nil);
    ifc->arg = lb;
    ifc->mbps = 1000;

    kproc("loopbackread", loopbackread, ifc);

}
@


<<function loopbackunbind>>=
static void
loopbackunbind(Ipifc *ifc)
{
    LB *lb = ifc->arg;

    if(lb->readp)
        postnote(lb->readp, 1, "unbind", 0);

    /* wait for reader to die */
    while(lb->readp != nil)
        tsleep(&up->sleepr, returnfalse, 0, 300);

    /* clean up */
    qfree(lb->q);
    free(lb);
}
@

% a kproc
<<function loopbackread>>=
static void
loopbackread(void *a)
{
    Ipifc *ifc;
    Block *bp;
    LB *lb;

    ifc = a;
    lb = ifc->arg;
    lb->readp = up; /* hide identity under a rock for unbind */
    if(waserror()){
        lb->readp = 0;
        pexit("hangup", 1);
    }
    for(;;){
        bp = qbread(lb->q, Maxtu);
        if(bp == nil)
            continue;
        ifc->in++;
        if(!canrlock(ifc)){
            freeb(bp);
            continue;
        }
        if(waserror()){
            runlock(ifc);
            nexterror();
        }
        if(ifc->lifc == nil)
            freeb(bp);
        else
            ipiput4(lb->f, ifc, bp);
        runlock(ifc);
        poperror();
    }
}
@
% ipiput4!


<<function loopbackbwrite>>=
static void
loopbackbwrite(Ipifc *ifc, Block *bp, int, uchar*)
{
    LB *lb;

    lb = ifc->arg;
    if(qpass(lb->q, bp) < 0)
        ifc->outerr++;
    ifc->out++;
}
@


\section{Point to point serial line}
% PPP?

\section{Token ring}
% alternative to ethernet


\chapter{Extra Protocols}

\section{ICMP}
% for ping

% put before? in Advanced topics? more important than other protocols?
% A Meta protocol?

<<[[Proto(kernel)]] conversation methods>>=
void    (*advise)(Proto*, Block*, char*);
@

\section{RUDP}

\section{GRE}

\section{ESP}

\section{Datakit and URP}


\chapter{Extra Applications}

\section{Remote login, rlogin}

\section{Serving files, FTP}
% works on top of tcp again?

\section{Serving documents, HTTP}

\section{Serving mails, SMTP}
% this one has actually many subprotocols ... hmmm

\section{Serving news, NNTP}

\chapter{Extra Code}

\ifallcode

#include "Network_extra.nw"
#include "Network_v6.nw"
#include "Network_apps.nw"

\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
MTU
TTL
TOS
IP
UDP
TCP
IL
IFC
ICMP
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
