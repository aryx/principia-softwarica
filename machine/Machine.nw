\documentclass[12pt]{report}
%12pt, twocolumn, landscape

%last:
% - QEMU internals: https://airbus-seclab.github.io/qemu_blog/
% - RiscV in Racket: http://guillaume.baierouge.fr/2021/04/23/simulating-digital-circuits-in-racket/a-risc-v-core-in-racket/index.html

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosetrue % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - reorg itab, simplified armclass(), see more repetitions, more
%   logical order, less undef "classes", introduced enum Opcode
% - deadcode: struct Mul, Imul

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduced globals.c, utils.c,
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand machine/emulator/simulator:
% - SEMI a bit the difference between a simulator and emulator
% - TODO how works overflow? carry.
% - bit shift logic vs arith, and why no need for SLA
% - 2 complement and what a nice invention it is
% - signed/unsigned and MOV vs MOVB vs MOBBU
% - stack for function calls and what a nice invention it is

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

\input{../docs/latex/Config}
\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../docs/latex/syncweb}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------

\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for:
%  - Extra (decls (func, extern, forward), pragmas), 
%  - if(trace)

%\setcounter{tocdepth}{1}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The ARM Emulator [[5i]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
???
}

\maketitle 
\n Machine in title? not really machine emulator, more processor emulator
\l Plan9 in title? could be a subtitle. 
\l user-level in subtitle?

%\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
%\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {processor emulator}.

\section{Motivations}

Why a processor emulator? 
Because I think you are a better programmer if
you fully understand how things work under the hood,
and the {processor} is really at the bottom of what is under the hood.
\n machine/computer/hardware/architecture/processor/cpu  emulator/simulator?
\n processor is more precise and accurate than machine for 5i

Every other books in \principia will describe programs
that ultimately runs on a concrete machine. For the
assembler and linker, I will even describe programs that 
generate {binary codes} for a specific architecture (the ARM).
\n actually in plan9 the assembler does not generate ARM code, 
\n (but it still generates binary code specific to a machine)
It is thus useful, especially to understand the
assembler, linker, and also compiler, 
\n especially in plan9 where the arch specific stuff is spread in those 3 things
to have somewhere the full description of the 
{instruction set} of an architecture (ISA): 
its binary format, {mnemonic names}, and also semantics.
%
In fact, the hardware can also be seen as a kind of software: a processor
is an {interpreter} for a low-level language, and so
it is also {\em softwarica} material. The binary format
of some instructions and their semantics can be described 
simply by explaining the code of an interpreter: a processor emulator.
\l concrete machine, virtual machine.

Here are a few questions I hope this book will answer:
\begin{itemize}

\item What is the list of all processor instructions?
What can a typical computer do?

\item What are the most important instructions? How
can they be used to implement higher level constructs?
%tags: c-target

\item Which instruction allows to enter in kernel mode?

\item How instructions are encoded? What is the binary format?

\item How is handled overflow? What are the differences between 
the logic shift-right and arithmetic shift-right operations?
%http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/

\item How does an ARM machine compare to a Turing machine? To a Von Newman
machine?

\end{itemize}
\l lacking: hard interrupts, boot process, virtual memory, io, rings
\l How input/output with external devices is handled?
\l will learn a bit about kernel, syscall calling conventions, syscall semantic

\section{The \plan ARM emulator: [[5i]]}

\l ISA spec vs simulator vs emulator
I will not describe in this book a processor in the form of
a program of an hardware description language (e.g., VHDL),
which operates at the granularity of logic gates 
(e.g., [[or]], [[and]], [[nand]]).
%
For such an approach I recommend the great 
book {\em The Elements of Computing Systems}~\cite{tecs} 
and its companion website \url{http://www.nand2tetris.org}.
%
Instead, I will present the source code of an {\em emulator}
written in the high-level language C, which allows us to describe
a relatively complex processor and its machine language in a book
of a reasonable size.
\l Of course disadvantage ... self-reference looping issue
An emulator can be viewed as an executable specification\footnote{
This program will be useful also for testing purpose when I will
describe in other books the assembler, linker, and compiler.
}
of a machine.

I will explain in this book the code of the ARM emulator
[[5i]]\footnote{\url{http://plan9.bell-labs.com/magic/man2html/1/vi},
which despite its name covers also [[5i]]}
which is about 4400 lines of code (LOC).
\n see make loc (or cm -test_loc)
[[5i]] emulates the execution of an ARM binary in a \plan environment.
\n from man page.
The [[5]] comes from the \plan convention to name architecture
with a number or single letter (0 is MIPS, 5 is ARM, 8 is x86, etc),
and the [[i]] probably means interpreter.
\l or instruction

I chose the ARM architecture over the x86 architecture
because even if x86 is the processor of most
desktop machines today, ARM has a far simpler architecture.
\n actually there is no 8i :) It's not that bad according to 
\n torvalds: http://yarchive.net/comp/linux/x86.html but still.
Indeed, {RISC} (Reduced Instruction Set Computer) machines such as an ARM, as
their name suggest, have a smaller set of instructions
than {CISC} (Complex Instruction Set Computer) machines such as an x86,
and have also simpler instructions.
%
The code of an ARM emulator is thus smaller and simpler to describe, while
still conveying in my opinion the essence of all processors.

I chose ARM over MIPS, because even if the MIPS is a RISC machine
probably simpler than the ARM, 
\l LOC vi=?
there is not much remaining MIPS machines around.
%
The ARM on the other hand is very much alive;
it is the most popular processor in phones today. It is also the
processor of the extremely cheap 
Raspberry Pi\furl{https://www.raspberrypi.org/} 
machine, a machine used by many electronic hobbyist. This also
makes ARM a great candidate for our teaching purpose.

Note that [[5i]] is not a complete processor simulator though.
\l user-level emulator, like apout, like Wine
It emulates all the basic instructions, and so is
a good reference for the ARM ISA, but it does not emulate
low-level things such as 
hardware interrupts, 
device interactions (IO),
coprocessor instructions, 
kernel and user modes, or 
the booting process.
%
The only system instruction partially handled is the software
\l privileged instruction?
interrupt, and it is emulated by mimicing the semantics of 
the \plan system calls\footnote{
As a side effect, this book also helps to understand the kernel,
especially its API and the semantic of a few important
system calls such as [[sysbrk()]].
}.
\l as the emulator emulates the kernel/user boundary.
[[5i]] can run simple \plan programs compiled for the ARM, but
\l user-level programs, need just cpu, memory, and access to system calls
it can not run a kernel.
%
However, I think [[5i]] is a good compromise for our educational purpose.


Note also that describing a C program, and not a VHDL program, 
has a few disadvantages. Indeed, to emulate for instance
the [[AND]] ARM instruction, I will show C code such as:

<<instruction interpreter simplified snippet>>=
case AND_INSTRUCTION: 
  register3 = register1 & register2;
  ...
  break
@

This code uses the C binary [[&]] operator.
I am cheating in some sense, just like when someone describes the
code of a Lisp interpreter written in Lisp; it does
not help to understand fully how Lisp is implemented,
for instance, to understand how a garbage collector works. 
%
In our case, using C does not
help to understand how certain operations work at the bit level,
how for instance a 32 bits adder, or multiplier, or 
multiplexer works\footnote{Again I recommend~\cite{tecs} for that.}.
Is is still useful though to get an overview of
the fundamental capabilities and features offered
by most computers and to better understand the ARM ISA.
\l Actually it also helps to see capabilities/features of operating systems
\l as emulate/proxy OS API.

\section{Other emulators}

Here are a few emulators that I considered for this book, but
which I ultimately discarded:
\begin{itemize}

\item SPIM\furl{http://pages.cs.wisc.edu/~larus/spim.html}
is a MIPS processor emulator. It is one of
the first emulator written for educational purposes. 
It is partially described in an appendix of the classic architecture
book {\em Computer Organization and Design: The Hardware/Software Interface}~\cite{patterson}.
However, as I mentioned it earlier, MIPS is unfortunately a dying machine.
\l (ARM mostly a MIPS anyway),
Moreover, SPIM does not execute {\em binary} MIPS programs;
instead, it interprets {\em assembly} MIPS programs. This hybrid
approach would then force me to describe the SPIM assembly scanner
and parser, instead of focusing on the binary format of instructions,
which is in my opinion an important thing to understand for \principia.
Finally, the 15~000 LOC of SPIM are bigger than the 4200 LOC of [[5i]].
\t actually might be less than 15000, dont count y.tab.c and parser_yacc.c


\item QEMU\furl{http://www.qemu.org}
is a popular and fast emulator supporting many architectures,
including ARM and x86.
%
Instead of the simple interpretation approach used by [[5i]],
QEMU uses {dynamic binary translation}, which improves a lot its performance.
%
QEMU emulates everything (system instructions, faults, devices, etc), 
and so can run entire kernels.
In fact, I suggest you to use QEMU to experiment with \plan.
However, the codebase of QEMU is very large: more than 1.2 million LOC
in total.
Even its [[hw/arm]] subdirectory is already more than 25~000 LOC.
\n qemu itself: 1113677 LOC (big but interesting opti; could be nice to port to 5i)

\item MAME\furl{http://www.mame.net/}
\n which has merged back MESS http://www.mess.org/
is a popular emulator for 
arcade machines (e.g., R-type, Pong),
consoles (e.g., Atari 2600, Nes, Gameboy, NeoGeo), 
calculators (e.g., ti85), and 
vintage computers (e.g., Alto, z80, Atari ST, Amiga). 
It is used mainly to play old video games (programmed for old machines)
on modern computers. 
It supports hundreds of such machines and can run thousands of video games. 
But this generality has a price; its codebase is very big,
almost 5 millions LOC.
\n LOC: 4922087
It would be too hard to describe this emulator in a book, 
even if I would focus just on one specific machine.


\item Hack\furl{http://www.nand2tetris.org/05.php}
\l http://www.nand2tetris.org/tutorials/PDF/CPU%20Emulator%20Tutorial.pdf
is a very simple machine described in~\cite{tecs}
\n full machine, has keyboard and graphic screen
and used for educational purpose. 
Its emulator consists of 7000 LOC. 
It also comes with a very nice debugger of 6000 LOC.
\n LOC hack/: 7853
\n LOC hackGUI: 6728
Hack is a great resource to learn about architecture and to understand how
a simple processor works. However, the processor is too restricted and 
arguably too simple for \principia. 
Moreover, the Hack machine does not exist for real,
and programmers have written very few tools for it.
For instance, there is neither a C compiler targeting this architecture
nor a real operating system for it.
\l it has a toy kernel though, but it's more like an exokernel (a lib)
\l graphics capability? could run rio if there was a C compiler? maybe
\l the Hack debugger shows the status of the keyboard and a screen (256x512)

\item MMIX\furl{http://www-cs-faculty.stanford.edu/~uno/mmix.html}
and its ancestor MIX
are computers designed by Donald Knuth
and used in his classic book series
{\em The Art of Computer Programming}~\cite{the-art}.
Donald Knuth also wrote A book using literate programming
explaining the full code of an MMIX emulator~\cite{mmixware}
\n actually mmixware reached 1.0 not a long time ago, in 2014
(including a description of the processor pipeline, the floating point
unit, tje assembler).
\n actually quite complex archi I think
Howoever, similar to Hack, there are very programs for this machine. 
For instance, Donald Knuth in his books assumes the presence of an operating
system called NNIX, but nobody has ever written it.
\n actually knuth asked for someone to write it for a long time on his homepage
\l their interpreter mixal? MDK? dead? or just for MIX and not updated to MMIX?

\end{itemize}
\l lots of other emulators, see the comment in the .tex
%industry:
% - vmware
% - parallel
% - virtualbox
%other:
% - gnu sim, see binutils/sim!, 22K LOC, including an ARM emulator
% - wine, also user-level emulator, at syscall boundaries
% - gxemul http://en.wikipedia.org/wiki/GXemul
% - Gb, 9front/games/gb? gameboy emulator?
% - gameboy documented in a nice blog 
%   http://blog.rekawek.eu/2017/02/09/coffee-gb/ 
% - Nes, https://medium.com/@fogleman/i-made-an-nes-emulator-here-s-what-i-learned-about-the-original-nintendo-2e078c9b28fe#.mz5d8694q
% - http://www.unicorn-engine.org/ based on qemu but extended to be more
%   like a framework one can use to create specialized tools (e.g. usercorn)
%   and also far smaller (just focus on CPU emulation)
%mini:
% - tiny8086, 760 LOC!
% - https://github.com/gto76/comp-cpp, 4bit educational computer, 7 ISA
% - recc one page cpu http://recc.robertelder.org/op-cpu.txt
% - http://emulator101.com/ space invader on a 8080, fully explained
% - https://github.com/trillek-team/computer-toolkit (for space game)
%   TR3200 machine ???
% - https://hackaday.io/project/18491-worlds-first-32-bit-homebrew-cpu
% - emulator and gui in common lisp http://stevelosh.com/blog/2016/12/chip8-cpu/
% - https://github.com/xem/minix86
% - plan9front has many emulators under sys/src/cmd/games/
% - chip from scratch
%   http://sam.zeloof.xyz/category/semiconductor/?fbclid=IwAR2jHQbhP7hrwMI2VyXEUum_LV3zlLw90dgQO0ETZZYB1ogKFrNum88lNyk
%education:
% - Cuneiform tables of 2015, one page virtual machine, very very nice
%   also handle display and keyboard (From VPRI institute of Alan Kay)
%   15 instructions only (control, memory, arith, screen/keyboard)
% - Little Man Computer, 1965 educational machine
%   https://en.wikipedia.org/wiki/Little_man_computer
% - YAMS and buenos
% - the new edition of the oberon book has a new CPU emulator I think,
%   specified in FPGA some said
% - Spocketnes, nice, rust!
% - http://www.homebrewcpu.com/, full stack too, LCC, minix 2, tcp/ip, etc
% - pep/8 simulator (mentioned in cs illuminated book)
% - pretty simple, pretty similar:
%   http://www.felixangell.com/virtual-machine-in-c/
% - http://courses.missouristate.edu/KenVollmar/MARS/
%   java IDE for mips assembly programming
% - http://www.cs.colby.edu/djskrien/CPUSim/ with GUI, assembler
%   (some papers from 1994 and before in sigcse about it)
%browser-based:
% - ARM in js http://biged.github.io/arm-js/arm-js.html
% - https://github.com/levskaya/jslinux-deobfuscated
% - https://github.com/s-macke/jor1k for openrisc
% - list of many emulators: https://github.com/BigEd/jsemu
%arm:
% - https://salmanarif.bitbucket.io/visual/ another ARM emulator with
%   visualizer
% - http://armsim.cs.uvic.ca/, includes also an assembleur and linker,
%   coded in C#, for education
% - visual ARM simulator, see the chip and the wires!
%   http://blog.visual6502.org/2015/11/the-visual-arm1.html
%   http://visual6502.org/sim/varm/armgl.html
%   http://www.righto.com/2015/12/reverse-engineering-arm1-ancestor-of.html
% - also for education: http://salmanarif.bitbucket.org/visual/index.html
% - gen simulator, maybe backend of VisUAL, support ARMv5
%   https://github.com/cornell-brg/pydgin but looks big too
% - harm? significantly shorter in haskell? does not look like shorter ...
% - ARMv7 emulator in rust: https://github.com/vnd/rarm
% - git://github.com/travisg/armemu.git 
%history:
% - Computer History Simulation Project e.g. for pdp11 to run unix v1
%   http://simh.trailing-edge.com/ 
% - https://github.com/c3x04/Unix-1st-Edition-jun72/tree/master/tools/apout
%   same spirit than 5i, simulate at syscalls level
%research/recent:
% - risc-V simulator? (spike?) riscv.org, actually a QEMU module too
%   https://github.com/riscv/riscv-isa-sim LOC?
%   a javascript one that boots linux: http://riscv.org/angel/
% - mill architecture? seems a bit a one-man-only effort
% - a disassembly framework: http://www.capstone-engine.org/
% - spec of ARMv8 https://www.cl.cam.ac.uk/~pes20/popl16-armv8/top.pdf
% - webassembly machine
%   http://webassembly.org/docs/semantics/
% - http://bellard.org/riscvemu/ by bellard, probably cleaner than qemu
%misc:

% real hardware tutorial? make your own x86 board
%  - http://blog.lse.epita.fr/articles/77-lsepc-intro.html
%  - https://internalregister.github.io/2019/03/14/Homebrew-Console.html
%  - 8 bit computer from scratch, with electric components:
%    https://eater.net/

% 50 years of computer architecture by David Patterson
% https://www.youtube.com/watch?v=1FtEGIp3a_M&feature=youtu.be&t=1m49s

% other machines:
% - RISC-V
% - tiny computer by thacker for Alan Kay

\section{Getting started}

To play with [[5i]], you will first need to install
the \plan fork used in \principia. See \urlprincipia.
Once installed, you can test [[5i]] under \plan with:

\begin{verbatim}
[1] $ cd /tests/5a/
[2] $ 5a helloa.s
[3] $ 5l helloa.5 -o helloa
[4] $ 5i helloa
[5] 5i> :c
[6] hello world
[7] exists(end)
[8] stopped at #1068 _main+48
[9] $
\end{verbatim}

The commands in lines 2 and 3 respectively assembles and links
the very simple [[helloa.s]] hello-world ARM assembly program
(or cross-assemble and cross-link if you are on a non-ARM host machine).
Line 4 runs the emulator on the ARM binary program [[helloa]].
%
[[5i]] has an interface similar to a debugger,
and so the input command [[:c]] entered after the [[5i>]] {prompt}
is used to tell the emulator
to [[c]]ontinue the execution of the emulated program [[helloa]].
[[5i]] then {interprets} the program, 
which outputs [[hello world]] at line 6.
 [[5i]] then outputs a few debugging
information at lines 7 and 8 before exiting.

\section{Requirements}

%dup: Assembler.nw
Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it. 
\l Can read Compiler.pdf :) but a bit self reference.

Note also that this book is not an introduction to computer architecture.
I assume you already have a basic understanding of
how a processor works, and so that you are familiar with concepts such as
{registers}, 
{memory addressing modes}, 
{interrupts}, etc. 
I assume you already know most of the theory; this book is here to
cover the practice.
See~\cite{tannenbaum-archi, patterson} instead
for excellent introductions to computer architecture.
\n http://www.quora.com/What-is-a-good-book-to-learn-computer-architecture

It is not necessary to know the ARM architecture to understand this book.
In fact, this book can be used as an introduction to the ARM processor.
%
However, I highly recommend to print the excellent 
colorful ARM reference card
\url{http://re-eject.gbadev.org/files/armref.pdf}.
\l note that Intel syntax!!
It will help you to visually understand the binary format of the
ARM instructions. This card is especially helpful
to understand the code that does many bit manipulations to generate
the different parts an ARM instruction.
\l Full spec is ARM pdf manual but I didn't use them though.


\l Help to understand Kernel.nw, especially for chapter X
\l vi and db man page, especially for chapter Y

\l a few other resources, see the comment in this .tex
%http://emulator101.com/
% "writing an emulator is a great way to learn how a CPU works"
%http://stackoverflow.com/questions/448673/how-do-emulators-work-and-how-are-they-written/448689#448689

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of [[5i]],
\t who?
who wrote in some sense most of this book.




\chapter{Overview}

\section{Computer principles}
\n machine/computer/processor

\n machine vs computer vs hardware vs architecture vs processor vs cpu
\n  vs hypervisor vs virtualizer (when run on same archi)

% machine is processor, memory, input/output devices such
% as keyboard, mouse, screen.
% (see Principia.nw appendix)

\subsection{Von Newmann architecture}

% stored program concept origin:
%http://sydney.edu.au/engineering/it/research/tr/tr274.pdf

% bits = binary digits (coined by Claude Shanon)
% http://www.nature.com/nature/journal/v547/n7662/full/547159a.html

% Stored-program concept. Universal computer, interpreter, for very simple
% machine language.  

% What goes in processor? in this machine language?
% (like universal turing machine reading 7-tuple on tape and interpreting)

% arithmetic. 
% jumps. 
% memory read/write. 
% IO.

% memory access (load/store archi on ARM) (Imem)
% add/sub/mul in hardware! sometimes also div! (Iarith)
% branching (Ibranch), most basic one can do, jmp
% interrupt for external device (avoid attente active) (Isyscall)
% floating optional (Ifloat?)

\subsection{Instruction format}

\subsection{Hardware versus software}

% in hardware because? Well cos related to hardware, e.g.
% for devices (keyboard, mouse, screen, but also of course memory).
% Also for basic computation like arithmetic 
% and conditional/jmp (stored program)
%
% in hardware also because in soft could be too slow
% and generic enough that in hardware make sense, e.g. floating point.
% but actually also 32bits arithmetics. Also .P .W and MOVM
% cos used respectively by compiler (stack operation) and kernel
% (save all registers in stack)
%
% from http://danluu.com/new-cpu-features/
% "... boxes that do arithmetic, logic, bit twiddling and shifting, and loading
%  and storing things in memory."
%

\subsection{IO}

% If just memory, boring. Need effects too! visible effects! Output 
% And need interactive, Input.

% Memory mapped IO or special IO instruction.

\subsection{Interrupts}

% interrupts are also important. interrupt table. external world.

\subsection{Virtual memory}

% virtual memory hardware support (can be as simple as TLB and interrupt)
%  for memory isolation, and lots of other stuff

% often associated to another hardware extension
% protection support (kernel vs user mode). See Principia.nw appendix.
% (and faults, and so interrupt)

% Also here have the hard vs soft issue. Can have minimal hardware
% support for virtual memory, just TLB. Or more done in hardware
% as in x86 which does take care of follow the tables.

%related: debugging hardware support (by abusing virtual memory trap general
%  mechanism again)

\subsection{Endianess}

% format and endianess: little endian = least significant bytes
% in the smallest address
%

%\subsection{Advanced}

% recently: 
% - vector computation (SIMD)
% - graphics processing unit (GPU)
% - virtualization
% - security hardware support?
% see also 'what's new in CPUs since the 80s, and how it affect programmers'
% from http://danluu.com/new-cpu-features/
%
% vs turing machine? add() in turing machine? well turing assume math builtin.
% mini interpreter in machine is a kind of universal turing machine:
% it take in its memory/tape a program M and runs it


\section{Emulator principles}
\l emulator vs simulator?

% emulator can cheat more? And indeed 5i cheats a bit as it emulates the OS.

% =~ interpreter.


\section{[[5i]] interfaces}

\subsection{Command-line interface}

\subsection{Debugger interface}

\begin{verbatim}

% actually provides a debugger interface a la 'db'
%
% so 5i 5.out, then at prompt type   ":c"
% to continue (that is run the program)
%
% also good to do $t :c
% so have a trace with all the instructions!! cool to debug
%
% $r to dump the registers
%
%How when get a pagefault display the current instruction?
%
%$q to exit
%
%? vs /
%main ?i
%exit ?iii
%
%can do
%$t to get trace of instruction (very useful)
%:s to step
%and then just RET to repeat the last cmd

\end{verbatim}

\section{[[helloworld]]}

% show actual instructions this time, with concrete values

\section{Input binary executable}
% special here, emulator like qemu take disk image,
% and boot process.

\begin{verbatim}

 a.out (unix/plan9) header, and then ARM.

 for a compiled helloworld.c, there are actually lots
 of instructions involved, print is complicated, _main vs main,
 and probably other stuff. Could be good to have a 
 simplified helloworld.s first where do very little.


TODO: have a disassembler? could be interesting to show
 some example of binary and what Assembly it corresponds too.
 libmach does that no?

TODO: could also show some assembly and show the binary
 For instance can see AB that does the +8 implicitly.
 so if want to jump to next instruction there will be actually
 a -4 in the value of AB.

\end{verbatim}

\section{The ARM architecture}

%https://en.wikipedia.org/wiki/ARM_architecture#Instruction_set

% see arm-opcode.svg in this directory?

\begin{verbatim}

ARM ISA format
see ARM wikipedia page!
endianess: actually bi-endian, but little endian by default, 
 hence va[0] | va[1] >> 8, etc

 a few weird stuff:
  - conditional execution format to compensate for lack of branch
    prediction, see wikipedia euclid example
  - no CALL/RET? do via B or BL (could also do ADD PC I think)

 lots of symetries and repetitions, see instruction format section

 raspberry = ARMv6? 

section{C}
 refresher on bit manip?
 w&1< <7, x& ~(BYPG-1), 31< <7, x> >25 & 0xf, etc

http://blogs.msdn.com/b/ntdebugging/archive/2013/11/22/understanding-arm-assembly-part-1.aspx

 ex of assembly? how put 1 into register1?

\end{verbatim}

\section{Code organization}

<<basic includes>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

#include "arm.h"
@
% need mach.h in most of those files???

\begin{verbatim}

arm.h: DS, forward decl (a dat.h + fns.h)

 mach.h for very little I think, could probably remove it of most files

utilities:
utils.c:
globals.c:

hardware:
mem.c:
icache.c: instruction cache (nop)
syscall.c: supported syscalls emulation (just proxy)

debugger stuff:
bpt.c: breakpoints
symbols.c:
cmd.c:
stats.c:

main stuff:
run.c
5i.c

\end{verbatim}

\section{Software architecture}

\begin{verbatim}

 Use libmach a bit: crackhdr(), symbol map.
 But archi is so simple that no need parsing: just read ulong (instruction)
 so 4 bytes from the file.
 Then decompose instruction and dispatch.

 I think some of the algo like dpex(), arm_class, really emulate
 the algorithm of the machine itself. The code is factorized.
 it's not just a giant switch for each opcode, things in the ARM
 are better structured, with some repetition.

 note that no deps to 5.out.h here, it's the final binary format,
 not the plan9 object ARM format.


 machine language, binary format of instruction,
 opcode, operands, semantic. interpreter.

\end{verbatim}

\section{Book structure}

%###############################################################################


\chapter{Core Data Structures}

\section{[[Instruction]] and [[Opcode]]}

The ARM uses fixed-length instructions of 4 bytes:

<<typedef instruction>>=
typedef ulong instruction;
@
\n so simpler than x86
\l hmmm should use u32 then no?

An ARM instruction is composed of an {opcode} and a few {operands}.

% machine language = set of operations with opcodes and operands!
<<enum [[opcode]]>>=
enum opcode {
    // -----------------------------------------
    // Arithmetic and logic opcodes
    // -----------------------------------------
    <<arith/logic opcodes>>
    // -----------------------------------------
    // Memory MOV opcodes
    // -----------------------------------------
    <<memory opcodes>>
    // -----------------------------------------
    // Control flow opcodes
    // -----------------------------------------
    <<branching opcodes>>
    // -----------------------------------------
    // Syscall opcodes
    // -----------------------------------------
    <<syscall opcodes>>

    // for opcodes not handled by 5i
    OUNDEF   = 89
};
@
% OXXX sligthly different from AXXX from 5.out.h because here really 
% concrete instructions. Here some of the order matters.
% Actually not exactly real opcode value like in the machine, but close to it
% (but in the machine the opcode is spreaded though different bits, the
% three class bits but also more).

% note: no DIV! no really MOV, more load and store.
% what about the MOV in arith? seems redundant with load/store no?
% ADC, SBC, RSC are not implemented in 5i, not used by 5a/5c/5l ?
% MCR not implemented, very low level stuff used only by kernel
%  is not implemented

%note: I used to call it class_kind, but it was a bad name, it's really
% more an opcode. In contains also category of opcodes that are used
% as starting index for a range of actual opcodes.

% compiler: meta: you'll see many of those instructions used
% in this file :) bitshift, or, goto, syscall! :)

% old range:
% ARITH0: 0-15   16
% ARITH1: 17-31  16
% ARITH2: 32-47  16
% ARITH3: 48-63  16
% MUL:    64-65  2
% SWAP:   66-67  2
% MEM2:   68-71  4
% MEM1:   72-79  8
% BLOC:   80-81  2
% BRANCH: 82-83  2
% SYSCALL:84     1
% UNDEF:  85-87  3
% MULL:   88-91  4
% UNDEF:  92     1

% but I removed intermediate UNDEF and could move MULL closer to MUL

% new range:
% ARITH0: 0-15   16
% ARITH1: 16-31  16
% ARITH2: 32-47  16
% ARITH3: 48-63  16
% MUL:    64-65  2
% MULL:   66-69  4
% SWAP:   70-71  2
% MEM2:   72-75  4
% MEM1:   76-83  8
% BLOC:   84-85  2
% BRANCH: 86-87  2
% SYSCALL:88     1
% UNDEF:  89     1


% conventions: B, BU, W, H


<<enum [[ixxx]]>>=
enum opcode_category
{
    Iarith,
    Imem,
    Ibranch,
    Isyscall,
    Imisc,
};
@
% big categories (for profiler)
% I for Instruction?
% vi/ has Iload Istore instead of Imem, and also Ireg and Ifloat
%pad: I've added Imisc for undef.

\section{[[Inst]] and [[itab]]}

% rename?
<<struct [[Inst]]>>=
struct Inst
{
    void 	(*func)(instruction);
    char*	name;
    // enum<opcode_category>
    int	type;

    <<[[Inst]] profiling fields>>
};
@
% mini instruction interpreter, big categories, "sub-interpreter"?

<<global [[itab]]>>=
//map<enum<opcode>, Inst>
Inst itab[] =
{
  <<[[itab]] elements>>
  { 0 }
};
@
% contain an array of instruction pointer ... something translating
% an actual instruction into something we can execute.

<<[[itab]] elements>>=
[OUNDEF] =  { &undef,		"UNDEF", Imisc},
@

%ex (and the evolutions I did on this array):
%  { Imul,	"MUL",	Iarith }, /* 64 */
%  [64] =  { Imul,	"MUL",	Iarith },
%  [CMUL] =  { Imul,	"MUL",	Iarith },
%  [OMUL] =  { Imul,	"MUL",	Iarith },

\section{[[Registers]] and [[reg]]}

% could factorize with arm/ureg.h
<<struct [[Registers]]>>=
struct Registers
{
    long	r[16];
    <<[[Registers]] other fields>>
};
@

<<global [[reg]]>>=
Registers reg;
@
% core state of the machine! the value of its registers.

% 16 registers, R0 to R15, with some are special, e.g. PC = R15
% R0 is kinda like the equivalent of AX on x86
% R15 is 1020 in general, because first page and after a.out header.

<<enum [[regxxx]]>>=
enum
{
    REGARG	= 0,
    REGRET	= 0,

    REGSP	= 13,
    REGLINK	= 14,
    REGPC	= 15,
};
@
% so do reg.r[REGPC] to modify PC, see below
% also in 5.out.h
% REGARG/REGRET are plan9 conventions, independent of ARM,
% but because we emulate syscalls we need to understand the API.




\section{[[Segment]] and [[memory]]}

% part OS emulation now, because when exec the kernel
% setup some memory segments.
<<enum [[segment_kind]]>>=
enum segment_kind
{
    Text,
    Data,
    Bss,
    Stack,

    Nseg,
};
@
%old: Stack used to be first, but more logical in this order

<<struct [[Memory]]>>=
struct Memory
{
    //map<enum<segment_kind>, Segment>
    Segment	seg[Nseg];
};
@
% so model is process virtual memory, not machine physical memory with
% 0 to 4GB, and page tables, and so on. 5i is limited.

<<global [[memory]]>>=
Memory memory;
@
% other state of the machine, except more state of the process
% viewed from the kernel rather than the machine

<<struct [[Segment]]>>=
struct Segment
{
    // enum<segment_kind>
    short	type;

    uintptr	base;
    uintptr	end;

    //array<option<array_4096<byte>>> page table
    byte**	table; // the data

    // for the Text and Data segments the bytes are in the file
    ulong	fileoff;
    ulong	fileend;

    <<[[Segment]] profiling fields>>
};
@
% for Text and Data the content is actually in the disk binary, hence
% filexxx











\chapter{[[main()]]}

%input: file => fdt => biobuf bi => bin
%output: bo => bout

<<global [[file]]>>=
char*	file = "5.out";
@
%less: has to be a global too? used by initstk but could be
% passed as a parameter.

% fdt binary. Has to be a global? used in page_of_vaddr() for lazy Text access
<<global [[text]]>>=
fdt text;
@


% in 5i.c
<<global [[bxxx]]>>=
Biobuf	bi, bo;
@
%note: was bp, but I renamed bo
%less: has to be globals? could be locals of main?

% in globals.c
<<global [[bixxx]]>>=
Biobuf *bin, *bout;
@
% point to bi, bo (was bp);
%old: was bioout, but more consistent to use bout


<<function [[main]]>>=
//@Scheck: entry point!
void main(int argc, char **argv)
{

    argc--;
    argv++;

    bout = &bo;
    bin = &bi;
    Binit(bout, STDOUT, OWRITE);
    Binit(bin, STDIN, OREAD);

    <<[[main()]] tlb initialisation>>

    if(argc)
        file = argv[0];
    argc--;
    argv++;

    text = open(file, OREAD);
    if(text < 0)
        fatal(true, "open text '%s'", file);

    Bprint(bout, "5i\n");

    inithdr(text);
    initmemory();
    initstk(argc, argv);

    cmd();
}
@
%me: better do initmemory() here instead of doing it in initstk()


% stuff from mach.h:
%  - mach
%  - machdata
%  - Fhdr!!
%  - Symbol!!
%  - Map!
%  - crackhdr()!! (will set global mach accordingly?)
%  - syminit()
%  - loadmap()

\section{[[inithdr()]]}

% from mach.h
%less: could mv as a local in main() instead of this global?
% and  pass fhdr as a parameter to initstk and initmemory
<<global [[fhdr]]>>=
Fhdr	fhdr;
@


<<function [[inithdr]]>>=
void
inithdr(fdt fd)
{
    <<[[inithdr()]] locals>>

    seek(fd, 0, SEEK__START);
    if (!crackhdr(fd, &fhdr))
        fatal(false, "read text header");

    if(fhdr.type != FARM )
        fatal(false, "bad magic number: %d %d", fhdr.type, FARM);

    <<[[inithdr()]] symmap initialisation>>
    <<[[inithdr()]] mach initialisation>>

}
@


% need that below?
\t adv topics? after all useful only when use as debugger?

<<global [[symmap]]>>=
Map *symmap;		
@
% need that?

<<[[inithdr()]] symmap initialisation>>=
if (syminit(fd, &fhdr) < 0)
    fatal(false, "%r\n");

symmap = loadmap(symmap, fd, &fhdr);
@

<<[[inithdr()]] locals>>=
Symbol s;
// from libmach.a
extern Machdata armmach;
@
% need machdata = &armmach? what for?

<<[[inithdr()]] mach initialisation>>=
//???
if (mach->sbreg && lookup(0, mach->sbreg, &s))
    mach->sb = s.value;
machdata = &armmach;
@

\section{[[initmemory()]]}
% =~ kernel loader

% different from boot process here! 5i is special

<<enum [[_anon_ (machine/5i/arm.h)]]7>>=
enum
{
    /* Plan9 Kernel constants */
    BY2PG		= 4096,
    BY2WD		= 4,

    UTZERO		= 0x1000,
    STACKTOP	= 0x80000000,
    STACKSIZE	= 0x10000,

    <<constant [[PROFGRAN]]>>
    <<constant [[Sbit]]>>
    <<constant [[SIGNBIT]]>>
};
@
% >> >>
% UTZERO unused ... normal?
% less: could lp split more

% TODO macro round with (x+BY2PG -1) & (BY2PG - 1)?

%dead:
%    FP_U		= 3,
%    FP_L		= 1,
%    FP_G		= 2,
%    FP_E		= 0,
%    FP_CBIT		= 1<<23,





%less: could use ROUNDUP()
%less: t -> endpg_text, d -> endpg_data, b -> endpg_bss
<<function [[initmemory]]>>=
void
initmemory(void)
{
    uintptr t, d, b, bssend;
    <<[[initmemory()]] locals>>

    t = (fhdr.txtaddr+fhdr.txtsz+(BY2PG-1)) & ~(BY2PG-1);
    d = (t + fhdr.datsz + (BY2PG-1)) & ~(BY2PG-1);
    bssend = t + fhdr.datsz + fhdr.bsssz;
    b = (bssend + (BY2PG-1)) & ~(BY2PG-1);

    <<[[initmemory()]] Text segment initilisation>>
    <<[[initmemory()]] Data segment initilisation>>
    <<[[initmemory()]] Bss segment initilisation>>
    <<[[initmemory()]] Stack segment initilisation>>

    reg.r[REGPC] = fhdr.entry;
}
@
% note that bssend does not start at round page, not needed! can
% just follow directly data
%old: was called initmap()

<<[[initmemory()]] locals>>=
Segment *s;
@

<<[[initmemory()]] Text segment initilisation>>=
s = &memory.seg[Text];
s->type = Text;
s->base = fhdr.txtaddr - fhdr.hdrsz;
s->end = t;
s->fileoff = fhdr.txtoff - fhdr.hdrsz;
s->fileend = s->fileoff + fhdr.txtsz;
s->table = emalloc(((s->end - s->base)/BY2PG) * sizeof(byte*));
@

<<global [[textbase]]>>=
uintptr	textbase;
@
%less: who else use that? iprofile(), ifetch()

<<[[initmemory()]] Text segment initilisation>>=
textbase = s->base;
@


<<[[initmemory()]] Data segment initilisation>>=
s = &memory.seg[Data];
s->type = Data;
s->base = t;
s->end = t+(d-t);
s->fileoff = fhdr.datoff;
s->fileend = s->fileoff + fhdr.datsz;
s->table = emalloc(((s->end - s->base)/BY2PG)*sizeof(byte*));
@
%less: t+d-t ?? why not just d :) just for symetry with s->base
% that uses t?

<<global [[datasize]]>>=
int	datasize;
@
%less: who use that? sysbrk()

<<[[initmemory()]] Data segment initilisation>>=
datasize = fhdr.datsz;
@


<<[[initmemory()]] Bss segment initilisation>>=
s = &memory.seg[Bss];
s->type = Bss;
s->base = d;
s->end = d+(b-d);
s->table = emalloc(((s->end - s->base)/BY2PG) * sizeof(byte*));
@
% this can be extended by brk()!
%less: d+b-d ??


<<[[initmemory()]] Stack segment initilisation>>=
s = &memory.seg[Stack];
s->type = Stack;
s->base = STACKTOP-STACKSIZE;
s->end = STACKTOP;
s->table = emalloc(((s->end - s->base)/BY2PG) * sizeof(byte*));
@
% this can't be extended :(

\section{[[initstk()]]}

<<function [[initstk]]>>=
void
initstk(int argc, char *argv[])
{
    ulong size;
    ulong sp, ap, tos;
    int i;
    char *p;

    tos = STACKTOP - sizeof(Tos)*2;	/* we'll assume twice the host's is big enough */
    sp = tos;
    for (i = 0; i < sizeof(Tos)*2; i++)
        putmem_b(tos + i, 0);

    /*
     * pid is second word from end of tos and needs to be set for nsec().
     * we know arm is a 32-bit cpu, so we'll assume knowledge of the Tos
     * struct for now, and use our pid.
     */
    putmem_w(tos + 4*4 + 2*sizeof(ulong) + 3*sizeof(uvlong), getpid());

    /* Build exec stack */
    size = strlen(file)+1+BY2WD+BY2WD+BY2WD;	
    for(i = 0; i < argc; i++)
        size += strlen(argv[i])+BY2WD+1;

    sp -= size;
    sp &= ~7;

    reg.r[0] = tos;
    reg.r[REGSP] = sp;
    reg.r[1] = STACKTOP-4;	/* Plan 9 profiling clock (why & why in R1?) */

    /* Push argc */
    putmem_w(sp, argc+1);
    sp += BY2WD;

    /* Compute sizeof(argv) and push argv[0] */
    ap = sp+((argc+1)*BY2WD)+BY2WD;
    putmem_w(sp, ap);
    sp += BY2WD;
    
    /* Build argv[0] string into stack */
    for(p = file; *p; p++)
        putmem_b(ap++, *p);

    putmem_b(ap++, '\0');

    /* Loop through pushing the arguments */
    for(i = 0; i < argc; i++) {
        putmem_w(sp, ap);
        sp += BY2WD;
        for(p = argv[i]; *p; p++)
            putmem_b(ap++, *p);
        putmem_b(ap++, '\0');
    }
    /* Null terminate argv */
    putmem_w(sp, 0);

}
@
% putmem_xxx see later

\section{[[cmd()]]}

% pointer or actually the instruction? PC! dot = reg.r[REGPC]
<<global [[dot]]>>=
uintptr dot;
@
% why dot? db legacy? remind of "." in filesystem to say "current place"?

<<[[cmd()]] locals>>=
char *p;
@
% will contain the input string command

% most of actual code is in debugger section
<<function [[cmd]]>>=
void
cmd(void)
{
    <<[[cmd()]] locals>>

    dot = reg.r[REGPC];

    <<[[cmd()]] initialisation>>

    for(;;) {
        Bflush(bout);
        <<[[cmd()]] read and parse command and address from user input>>

        switch(*p) {
        <<[[cmd()]] command cases>>
        default:
            Bprint(bout, "?\n");
            break;
        }
    }
}
@


<<[[cmd()]] command cases>>=
case ':':
    colon(addr, p+1);
    break;
@


% most of the code again is in debugger section
% here we will not use 'addr' at all.
% colon is for flow control, restart, continue, next, etc
<<function [[colon]]>>=
void
colon(char *addr, char *cp)
{
    <<[[colon()]] locals>>

    cp = nextc(cp);

    switch(*cp) {
    <<[[colon()]] command which return cases>>
    /* These fall through to print the stopped address */
    <<[[colon()]] command cases>>
    default:
        Bprint(bout, "?\n");
        return;
    }

    dot = reg.r[REGPC];

    Bprint(bout, "%s at #%lux ", atbpt? "breakpoint": "stopped", dot);
    <<[[colon()]] print current instruction>>
    Bprint(bout, "\n");
}
@

<<[[colon()]] command cases>>=
case 'c':
    count = 0;
    atbpt = false;
    run();
    break;
@


\chapter{Instruction Interpreter}

\section{Instruction binary format}

% see refcard ARM, with color codes so can see repetitive patterns.

% 4 bytes fixed-length instructions (simple)
% - 4bits COND for everything (pink), see conditional execution section below
% - 3bits for opcode "class", and then more bits, variable length, 
%   a bit complex for more opcodes (orange and yellow), 
% - 4 bits registers, 0, 1, 2, 3, 4 times (Rn, Rd, Rs, Rm), so up to 16 bits,
%    or offsets (blue, green)
% - special config bits here and there (purple)

% ARM ISA has lots of symetries. lots of repetition.
% the code below extract this commonalities along different
% axes:
%  - operand styles (r/r/r  vs i/r/r vs ...) "addressing mode"
%     arm_class()
%  - arithmetic opcode (AND vs ADD vs OR ...)
%     dpex()
%  - shift
%     shift()
%  - S bit, etc
%     adhoc ifs

% rd, rs, rm, rn? dest? src? m?? n??

\section{[[run()]]}

% often set to 0 and because of do while(--count) will actually go in
% negative value!. They should use MAX_INT instead of 0. cleaner.
<<global [[count]]>>=
int count;
@



% Those registers could be outside reg, in another DS; they
% are not visible registers. But maybe inside the processor
% there are those kinds of registers hidden, especially ir
% (but probably not ip). So maybe make sense to keep them in regs.
%todo: but maybe still better to rename them, intern_ar! will then
% be easier also to grep for them and see if they are used outside run()
%are those fields used outside run()? could be locals then no?
%  - ip is used outside run() mostly for reg->ip.name
%    so could have a global instead like instr_name
%  - instr_opcode is used in itrace(), and in undef()
%  - ar is used in itrace()
<<[[Registers]] other fields>>=
uintptr		ar;    // reg.r[REGPC]

instruction	instr;    // ifetch(reg.ar)
//enum<opcode>
int			instr_opcode; // arm_class(reg.instr)
Inst*		ip;    // &itab[reg.instr_opcode]
@
%note: I renamed class to instr_opcode now that we consider more this an
% opcode. I also renamed ir to instr.



% main -> cmd -> colon -> <> -> armclass!!
<<function [[run]]>>=
void
run(void)
{
    bool execute;

    do {
        reg.ar = reg.r[REGPC];
        reg.instr = ifetch(reg.ar);

        reg.instr_opcode = arm_class(reg.instr);
        reg.ip = &itab[reg.instr_opcode];

        <<[[run()]] set reg.cond>>
        <<[[run()]] switch [[reg.compare_op]] to set [[execute]]>>

        if(execute) {
            <<[[run()]] profile current instruction class>>
            // !!the dispatch!!
            (*reg.ip->func)(reg.instr);

        }
        else
          if(trace) itrace("%s%s IGNORED",reg.ip->name, cond[reg.instr_cond]);

        reg.r[REGPC] += 4; // simple archi with fixed-length instruction :)

        <<[[run()]] check for breakpoints>>
    } while(--count);
}
@
% what about jumps? always REGPC+=4? yes because if jmp then
% the interpreter actually does some -=4 to compensate back at many
% places (hmm a bit ugly, maybe simpler to put this +=4 in the few
% Ixxx we have anyway).

% should switch to mips model with Iexec()?

% will describe conditional execution now.
% then ifetch() really read disk, seek binary, and get 4 bytes.
% will describe later. and the will describe arm_class().


\section{[[arm_class()]]}

% those 3 bits are mostly for operand style big categories (r/r/r, i/r/r, etc)
% copy paste from libmach/5db.c, but simplified as don't need
% to handle debugging instructions or anything not handled in itab > 92
<<function [[arm_class]]>>=
int
arm_class(instruction w)
{
    // between 0 and 7
    int class;
    // enum<opcode>
    int op;
    <<[[arm_class()]] locals>>
   
    class = (w >> 25) & 0x7;
    switch(class) {
    <<[[arm_class()]] class cases>>
    default:	  
        op = OUNDEF;
        break;
    }
    return op;
}
@
%less: rename? opcode_of_instruction?
% (48+24+4+4+2+2+4+4)
%case 6:	/* vfp load / store */ ; // go to default now
% I used to have only int op; for local, but better to split
% and have "class", and x




%\section{Instructions simulation}

\section{Arithmetic and logic}

% always same pattern: extract components from opcode (e.g.
% special opcode for special register in instruction), shift, and,
% and then perform operation on registers, memory, or internal registers.


\subsection{Opcode extraction}
% at least for the first time we see that we can have a named
% section about it, to repeat what was done in the arm_class section


<<arith/logic opcodes>>=
OAND = 0,
OEOR = 1, 
OSUB = 2, 
ORSB = 3, 
OADD = 4, 
OADC = 5, 
OSBC = 6, 
ORSC = 7, 
OTST = 8, 
OTEQ = 9,
OCMP = 10,
OCMN = 11,
OORR = 12,
OMOV = 13,
OBIC = 14,
OMVN = 15,
@
% order matters here! the same than in the machine!
%// AND, ORR, EOR,    BIC
%// ADD, SUB,   RSB, ADC, SBC, RSC
%// TST, TEQ, CMP,    CMN
%// MOV,    MVN



<<[[arm_class()]] locals>>=
int x;
@

<<[[arm_class()]] class cases>>=
case 0:	/* data processing r,r,r */
    x = ((w >> 4) & 0xf);
    <<[[arm_class()]] class 0, if x is 0x9>>
    <<[[arm_class()]] class 0, if x has 0x9 bits>>
    // else

    // the opcode! OAND/OADD/...
    op = (w >> 21) & 0xf;

    <<[[arm_class()]] class 0, adjust op for operands mode>>
    break;
@
%note: now use different locals for the different kinds of 'op' (class, and x)
% 31 << 7 means take all the bits from 7 to 11, the shift#
% >> >> >> >> >> >>




<<arith/logic opcodes>>=
OMUL    = 64,
OMULA   = 65,
@

% class 0 is bad name, maybe opcode_25_27? and op then is opcode_4_7
<<[[arm_class()]] class 0, if x is 0x9>>=
/* mul, swp, mull */
if(x == 0x9) {
    op = CMUL;
    <<[[arm_class()]] class 0, when x == 0x9, if bit 24 set>>
    <<[[arm_class()]] class 0, when x == 0x9, if bit 23 set>>
    if(w & (1<<21))
        op++;		/* mla */
    break;
}
@
% >> >> >>

<<arith/logic opcodes>>=
CMUL    = 64,
@




<<[[arm_class()]] class 0, adjust op for operands mode>>=
if(w & (1<<4))
  op += CARITH2;
else
 if((w & (31<<7)) || (w & (1<<5)))
  op += CARITH1;
// else op += CARITH0
@
% >> >> >>
% 31<<7 means any shift#, and second part is op right
\t  but matters op right? if shift# is 0, then shiftop has no effect no?

<<arith/logic opcodes>>=
CARITH0 = 0,  // r,r,r
CARITH1 = 16, // r<>#, r, r
CARITH2 = 32, // r<>r, r, r
@
\t what about I, R, R ??? CARITH3!! class 1

\subsection{Multiplication}
\l how fast multiplication in hardware?

<<[[itab]] elements>>=
[OMUL]    =  { Imul,	"MUL",	Iarith },
[OMULA]   =  { Imula,	"MULA",	Iarith },	
@


% pretty simple :)
<<function [[Imul]]>>=
void
Imul(instruction inst)
{
    int rs, rd, rm;

    rd = (inst>>16) & 0xf;
    rs = (inst>>8) & 0xf;
    rm = inst & 0xf;

    if(rd == REGPC || rs == REGPC || rm == REGPC || rd == rm)
        undef(inst);

    reg.r[rd] = reg.r[rm]*reg.r[rs];

    <<[[Imul()]] trace>>
}
@
% no need to r[REGPC]-=4 here, REGPC can not be rd, because
% does not make sense to jump to some code that is the result
% of a multiplication


% maybe show example of trace at least once? and talk about $t
\ifallcode
<<[[Imul()]] trace>>=
if(trace)
    itrace("%s%s\tR%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.instr_cond], rs, rm, rd,
        reg.r[rd]);
@
\fi

% multiply and accumulate
<<function [[Imula]]>>=
void
Imula(instruction inst)
{
    int rs, rd, rm, rn;

    rd = (inst>>16) & 0xf;
    rn = (inst>>12) & 0xf;
    rs = (inst>>8) & 0xf;
    rm = inst & 0xf;

    if(rd == REGPC || rn == REGPC || rs == REGPC || rm == REGPC || rd == rm)
        undef(inst);

    reg.r[rd] = reg.r[rm]*reg.r[rs] + reg.r[rn];

    <<[[Imula()]] trace>>
}
@
% convenient for pointer arithmetic, usually have a basis, and then
% an index multiplied by sizeof entry

\ifallcode
<<[[Imula()]] trace>>=
if(trace)
    itrace("%s%s\tR%d,R%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.instr_cond], rs, rm, rn, rd,
        reg.r[rd]);
@
\fi


\subsection{[[Idp()]] and [[dpex()]]}

<<[[itab]] elements>>=
//r,r,r
[OAND] =  { Idp0,		"AND",	Iarith },	
[OEOR] =  { Idp0,		"EOR",	Iarith },	
[OSUB] =  { Idp0,		"SUB",	Iarith },	
[ORSB] =  { Idp0,		"RSB",	Iarith },	
[OADD] =  { Idp0,		"ADD",	Iarith },	
[OADC] =  { Idp0,		"ADC",	Iarith },	
[OSBC] =  { Idp0,		"SBC",	Iarith },	
[ORSC] =  { Idp0,		"RSC",	Iarith },	
[OTST] =  { Idp0,		"TST",	Iarith },	
[OTEQ] =  { Idp0,		"TEQ",	Iarith },	
[OCMP] =  { Idp0,		"CMP",	Iarith },	
[OCMN] =  { Idp0,		"CMN",	Iarith },	
[OORR] =  { Idp0,		"ORR",	Iarith },	
[OMOV] =  { Idp0,		"MOV",	Iarith },	
[OBIC] =  { Idp0,		"BIC",	Iarith },	
[OMVN] =  { Idp0,		"MVN",	Iarith },	
@
% was +CARITH0 but now present CARITH0 later

% meh, dp? data processing? vague, everything is data processing
<<function [[Idp0]]>>=
/*
 * data processing instruction R,R,R
 */
void
Idp0(instruction inst)
{
    int rn, rd, rm;
    long o1, o2;

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    rm = inst & 0xf;

    o1 = reg.r[rn];
    <<adjust o1 if rn is REGPC>>
    o2 = reg.r[rm];
    <<adjust o2 if rm is REGPC>>

    dpex(inst, o1, o2, rd);

    <<[[Idp0()]] trace>>
    <<[[Idpx()]] compensate REGPC>>
}
@
% -4 because will be incremented back in run()

<<adjust o1 if rn is REGPC>>=
if(rn == REGPC)
    o1 += 8;
@
<<adjust o2 if rm is REGPC>>=
if(rm == REGPC)
    o2 += 8;
@

<<[[Idpx()]] compensate REGPC>>=
if(rd == REGPC)
    reg.r[rd] -= 4;
@

\ifallcode
<<[[Idp0()]] trace>>=
if(trace)
    itrace("%s%s\tR%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.instr_cond],
        rm, rn, rd,
        reg.r[rd]);
@
\fi



% dpex? means?
% note local cbit != reg.cbit
<<function [[dpex]]>>=
void
dpex(instruction inst, long o1, long o2, int rd)
{
    bool cbit = false;

    switch((inst>>21) & 0xf) {
    <<[[dpex()]] switch arith/logic opcode cases>>
    }
    <<[[dpex()]] if Sbit>>
}
@
% >>
% mov in arith? seems redundant with load/store no?

\subsection{Boolean logic}

<<[[dpex()]] switch arith/logic opcode cases>>=
case  OAND:
    reg.r[rd] = o1 & o2;
    cbit = true;
    break;
case OORR:
    reg.r[rd] = o1 | o2;
    cbit = true;
    break;
case OEOR:
    reg.r[rd] = o1 ^ o2;
    cbit = true;
    break;
@


<<[[dpex()]] switch arith/logic opcode cases>>=
case OBIC:
    reg.r[rd] = o1 & ~o2;
    cbit = true;
    break;
@
% cheat a bit :) use & to explain OAND

\subsection{[[S]] bit}

<<constant [[Sbit]]>>=
Sbit		= 1<<20,
@
% >>
% Set condition code, set flags. (How read flags?)

% only for code that break, so can factorize a few things,
%less: but maybe with LP could just copy paste, so flow
% less complicated?
<<[[dpex()]] if Sbit>>=
if(inst & Sbit) {
    if(cbit)
        reg.cbit = reg.cout;
    reg.cc1 = reg.r[rd];
    reg.cc2 = 0;
    reg.compare_op = CCcmp;
}
@


<<[[Registers]] other fields>>=
int	cbit; // carry bit?
int	cout;
@
% cout is set by shift

\t but forgot implement instructions reading the flags? MRS?, MSR?

\subsection{Addition and overflow}
% carry? overflow?

% concepts: carry, overflow, signed/unsigned, complement 2 notations
% with booleans, no sign/unsigned notion,
% with addition neither, because ADD using complement 2 notation
% works for both signed or unsigned integer. BUT the
% sign vs unsigned matters when consider overflow? because
% in one case the result could be zero because added 10 to -10,
% but in the other case -10 is actually a huge number and we can
% have an overflow that we want to indicate to the user.

<<[[dpex()]] switch arith/logic opcode cases>>=
case OADD:
    <<[[dpex()]] if calltree, when add operation>>
    reg.r[rd] = o1 + o2;

    if(inst & Sbit) {
        if((XCAST(o1) + XCAST(o2)) & (1LL << 32))
            reg.cbit = true;
        else
            reg.cbit = false;
        reg.cc1 = o2;
        reg.cc2 = -o1;
        reg.compare_op = CCcmp;
    }
    return;
@
% >> >>
\n could factorize with reg.cbit = bool(XCAST(...))

\t how detect overflow? what is the operation to test overflow?
\t  ADD R1, R2, R3   and then?? B??? or need ADD.S ?

<<macro [[XCAST]]>>=
#define XCAST(a) (uvlong)(ulong)a
@
% first cast ulong because usually register are long[16],
% and then uvlong cast to promote to 64 bits so at least
% can compute if overflow



\subsection{[[shift()]]}

<<[[itab]] elements>>=
// r<>#, r, r
[OAND +CARITH1] =  { Idp1,		"AND",	Iarith },	
[OEOR +CARITH1] =  { Idp1,		"EOR",	Iarith },	
[OSUB +CARITH1] =  { Idp1,		"SUB",	Iarith },	
[ORSB +CARITH1] =  { Idp1,		"RSB",	Iarith },	
[OADD +CARITH1] =  { Idp1,		"ADD",	Iarith },	
[OADC +CARITH1] =  { Idp1,		"ADC",	Iarith },	
[OSBC +CARITH1] =  { Idp1,		"SBC",	Iarith },	
[ORSC +CARITH1] =  { Idp1,		"RSC",	Iarith },	
[OTST +CARITH1] =  { Idp1,		"TST",	Iarith },	
[OTEQ +CARITH1] =  { Idp1,		"TEQ",	Iarith },	
[OCMP +CARITH1] =  { Idp1,		"CMP",	Iarith },	
[OCMN +CARITH1] =  { Idp1,		"CMN",	Iarith },	
[OORR +CARITH1] =  { Idp1,		"ORR",	Iarith },	
[OMOV +CARITH1] =  { Idp1,		"MOV",	Iarith },	
[OBIC +CARITH1] =  { Idp1,		"BIC",	Iarith },	
[OMVN +CARITH1] =  { Idp1,		"MVN",	Iarith },	
@

<<function [[Idp1]]>>=
/*
 * data processing instruction (R<>#),R,R
 */
void
Idp1(instruction inst)
{
    int rn, rd, rm, st, sc;
    long o1, o2;

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    rm = inst & 0xf;
    st = (inst>>5) & 0x3;
    sc = (inst>>7) & 0x1f;

    o1 = reg.r[rn];
    <<adjust o1 if rn is REGPC>>
    o2 = reg.r[rm];
    <<adjust o2 if rm is REGPC>>

    o2 = shift(o2, st, sc, false);
    dpex(inst, o1, o2, rd);

    <<[[Idp1()]] trace>>
    <<[[Idpx()]] compensate REGPC>>
}
@

\ifallcode
<<[[Idp1()]] trace>>=
if(trace)
    itrace("%s%s\tR%d%s%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.instr_cond], rm, shtype[st], sc, rn, rd,
        reg.r[rd]);
@
\fi

<<[[itab]] elements>>=
// r<>r, r, r
[OAND +CARITH2] =  { Idp2,		"AND",	Iarith },	
[OEOR +CARITH2] =  { Idp2,		"EOR",	Iarith },	
[OSUB +CARITH2] =  { Idp2,		"SUB",	Iarith },	
[ORSB +CARITH2] =  { Idp2,		"RSB",	Iarith },	
[OADD +CARITH2] =  { Idp2,		"ADD",	Iarith },	
[OADC +CARITH2] =  { Idp2,		"ADC",	Iarith },	
[OSBC +CARITH2] =  { Idp2,		"SBC",	Iarith },	
[ORSC +CARITH2] =  { Idp2,		"RSC",	Iarith },	
[OTST +CARITH2] =  { Idp2,		"TST",	Iarith },	
[OTEQ +CARITH2] =  { Idp2,		"TEQ",	Iarith },	
[OCMP +CARITH2] =  { Idp2,		"CMP",	Iarith },	
[OCMN +CARITH2] =  { Idp2,		"CMN",	Iarith },	
[OORR +CARITH2] =  { Idp2,		"ORR",	Iarith },	
[OMOV +CARITH2] =  { Idp2,		"MOV",	Iarith },	
[OBIC +CARITH2] =  { Idp2,		"BIC",	Iarith },	
[OMVN +CARITH2] =  { Idp2,		"MVN",	Iarith },	
@

<<function [[Idp2]]>>=
/*
 * data processing instruction (R<>R),R,R
 */
void
Idp2(instruction inst)
{
    int rn, rd, rm, rs, st;
    long o1, o2, o3;

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    rm = inst & 0xf;
    st = (inst>>5) & 0x3;
    rs = (inst>>8) & 0xf;

    o1 = reg.r[rn];
    <<adjust o1 if rn is REGPC>>
    o2 = reg.r[rm];
    <<adjust o2 if rm is REGPC>>
    o3 = reg.r[rs];
    <<adjust o3 if rs is REGPC>>

    o2 = shift(o2, st, o3, true);
    dpex(inst, o1, o2, rd);

    <<[[Idp2()]] trace>>
    <<[[Idpx()]] compensate REGPC>>
}
@

<<adjust o3 if rs is REGPC>>=
if(rs == REGPC)
    o3 += 8;
@

\ifallcode
<<[[Idp2()]] trace>>=
if(trace)
    itrace("%s%s\tR%d%sR%d=%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.instr_cond], rm, shtype[st], rs, o3, rn, rd,
        reg.r[rd]);
@
\fi


% shift(rm, op, rs or #, true if rs)
<<function [[shift]]>>=
long
shift(long v, int st, int sc, bool isreg)
{
    <<[[shift()]] if sc is 0>>
    else {
        switch(st) {
        case 0:	/* logical left */
            reg.cout = (v >> (32 - sc)) & 1;
            v = v << sc;
            break;
        case 1:	/* logical right */
            reg.cout = (v >> (sc - 1)) & 1;
            v = (ulong)v >> sc;
            break;
        case 2:	/* arith right */
            if(sc >= 32) {
                reg.cout = (v >> 31) & 1;
                if(reg.cout)
                    v = 0xFFFFFFFF;
                else
                    v = 0;
            }
            else {
                reg.cout = (v >> (sc - 1)) & 1;
                v = (long)v >> sc;
            }
            break;
        case 3:	/* rotate right */
            reg.cout = (v >> (sc - 1)) & 1;
            v = (v << (32-sc)) 
                 | 
                ((ulong)v >> sc);
            break;
        }
    }
    return v;
}
@

\t why no arith left? why so many more xx right? See Assembler.

% ???
<<[[shift()]] if sc is 0>>=
if(sc == 0) {
    switch(st) {
    case 0:	/* logical left */
        reg.cout = reg.cbit;
        break;
    case 1:	/* logical right */
        reg.cout = (v >> 31) & 1;
        break;
    case 2:	/* arith right */
        reg.cout = reg.cbit;
        break;
    case 3:	/* rotate right */
        if(isreg) {
            reg.cout = reg.cbit;
        }
        else {
            reg.cout = v & 1;
            v = ((ulong)v >> 1) | (reg.cbit << 31);
        }
    }
}
@
% >>

\subsection{Immediate values}
% Small immediate values?
% Useful opti. Without it for things like x = x + 1
% would require more ? STORE?

%http://alisdair.mcdiarmid.org/arm-immediate-value-encoding/

<<[[arm_class()]] class cases>>=
case 1:	/* data processing i,r,r */
 op = CARITH3 + ((w >> 21) & 0xf);
 break;
@
%48

<<arith/logic opcodes>>=
CARITH3 = 48, // i,r,r
@
%TODO? could be outside the enum opcode? as a set of #define?
% after all it's useful really only in the parsing of instructions.

<<[[itab]] elements>>=
//i,r,r
[OAND +CARITH3] =  { Idp3,		"AND",	Iarith },	
[OEOR +CARITH3] =  { Idp3,		"EOR",	Iarith },	
[OSUB +CARITH3] =  { Idp3,		"SUB",	Iarith },	
[ORSB +CARITH3] =  { Idp3,		"RSB",	Iarith },	
[OADD +CARITH3] =  { Idp3,		"ADD",	Iarith },	
[OADC +CARITH3] =  { Idp3,		"ADC",	Iarith },	
[OSBC +CARITH3] =  { Idp3,		"SBC",	Iarith },	
[ORSC +CARITH3] =  { Idp3,		"RSC",	Iarith },	
[OTST +CARITH3] =  { Idp3,		"TST",	Iarith },	
[OTEQ +CARITH3] =  { Idp3,		"TEQ",	Iarith },	
[OCMP +CARITH3] =  { Idp3,		"CMP",	Iarith },	
[OCMN +CARITH3] =  { Idp3,		"CMN",	Iarith },	
[OORR +CARITH3] =  { Idp3,		"ORR",	Iarith },	
[OMOV +CARITH3] =  { Idp3,		"MOV",	Iarith },	
[OBIC +CARITH3] =  { Idp3,		"BIC",	Iarith },	
[OMVN +CARITH3] =  { Idp3,		"MVN",	Iarith },	
@


<<function [[Idp3]]>>=
/*
 * data processing instruction #<>#,R,R
 */
void
Idp3(instruction inst)
{
    int rn, rd, sc;
    long o1, o2;

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    o1 = reg.r[rn];
    <<adjust o1 if rn is REGPC>>

    o2 = inst & 0xff;
    sc = (inst>>7) & 0x1e;
    o2 = (o2 >> sc) | (o2 << (32 - sc)); // rotate

    dpex(inst, o1, o2, rd);

    <<[[Idp3()]] trace>>
    <<[[Idpx()]] compensate REGPC>>
}
@
% >>
% normally it's inst >> 8, but then by doing >> 7 you multiply by 2
% which is perfect. then 0x1e is 30.

\ifallcode
<<[[Idp3()]] trace>>=
if(trace)
    itrace("%s%s\t#%x,R%d,R%d =#%x",
        reg.ip->name, cond[reg.instr_cond], o2, rn, rd,
        reg.r[rd]);
@
\fi


%todo: do an enum SH_LEFT | SH_RIGHT


% so ADD $0, PC, LINK;  will save in REGLINK PC + 8!

\subsection{64 bits target (signed/unsigned) multiplication}
\l adv topics?
% not really 64 bits multiplication,
% more 32 bits multiply but can store 64 bit result!

% (v)long multiplication, 64 bits
<<arith/logic opcodes>>=
OMULLU  = 66,
OMULALU = 67,
OMULL   = 68,
OMULAL  = 69,
@

<<[[arm_class()]] class 0, when x == 0x9, if bit 23 set>>=
if(w & (1<<23)) {	/* mullu */
    op = CMUL+2;
    if(w & (1<<22))	/* mull */
        op = CMUL+4;
}
@
% >> >> >>

<<[[itab]] elements>>=
[OMULLU]  =  { Imull,	"MULLU",	Iarith },
[OMULALU] =  { Imull,	"MULALU",	Iarith },
[OMULL]   =  { Imull,	"MULL",		Iarith },
[OMULAL]  =  { Imull,	"MULAL",	Iarith },
@


% less simple, signed long multiply? so need XCAST because signed?
<<function [[Imull]]>>=
void
Imull(instruction inst)
{
    vlong v;
    int rs, rd, rm, rn;

    rd = (inst>>16) & 0xf;
    rn = (inst>>12) & 0xf;
    rs = (inst>>8) & 0xf;
    rm = inst & 0xf;

    if(rd == REGPC || rn == REGPC || rs == REGPC || rm == REGPC
      || rd == rm || rn == rm || rd == rn
      )
        undef(inst);

    if(inst & (1<<22)){ // mull
        v = (vlong)reg.r[rm] * (vlong)reg.r[rs];
        if(inst & (1 << 21)) // mull and accumulate
            v += reg.r[rn];
    }else{ // mullu
        v = XCAST(reg.r[rm]) * XCAST(reg.r[rs]);
        if(inst & (1 << 21)) // mullu and accumulate
            v += (ulong)reg.r[rn];
    }
    reg.r[rd] = v >> 32;
    reg.r[rn] = v;

    <<[[Imull()]] trace>>
}
@
% >> >>


\ifallcode
<<[[Imull()]] trace>>=
if(trace)
    itrace("%s%s\tR%d,R%d,(R%d,R%d) =#%llx",
        reg.ip->name, cond[reg.instr_cond], rs, rm, rn, rd,
        v);
@
\fi




\subsection{Misc instructions}

% ifallcode?

<<[[dpex()]] switch arith/logic opcode cases>>=
case OCMN:
    if(inst & Sbit) { // not always true?
        reg.cc1 = o1;
        reg.cc2 = -o2;
        reg.compare_op = CCcmp;
    }
    return;
@

<<[[dpex()]] switch arith/logic opcode cases>>=
case  ORSB:
    reg.r[rd] = o2 - o1;
    if(inst & Sbit) {
        reg.cc1 = o2;
        reg.cc2 = o1;
        reg.compare_op = CCcmp;
    }
    return;
@

<<[[dpex()]] switch arith/logic opcode cases>>=
case  OADC:
case  OSBC:
case  ORSC:
    undef(inst);
@
% not used in 5l/5c anyway


<<[[dpex()]] switch arith/logic opcode cases>>=
case OMOV:
    reg.r[rd] = o2;
    cbit = true;
    break;
case OMVN:
    reg.r[rd] = ~o2;
    cbit = true;
    break;
@
\t useful to set register. actually used in 5l.


\section{Memory}

% conventions: B, BU, W, H

\subsection{Opcode extraction}

<<memory opcodes>>=
OLDW    = 70,
OLDB    = 71,
OSTW    = 72,
OSTB    = 73,
@

<<[[arm_class()]] class cases>>=
case 2:	/* load/store byte/word i(r) */
 //                            OxxB?              OSTx?
 op = CMEM_BASIS + CMEM0 + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
 break;
@
%48+24

<<[[arm_class()]] class cases>>=
case 3:	/* load/store byte/word (r)(r) */
 //                            OxxB?              OSTx?
 op = CMEM_BASIS + CMEM1 + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
 break;
@
%(48+24+4)

<<memory opcodes>>=
CMEM_BASIS = 70,
CMEM0 = 0, // i(r)
CMEM1 = 4, // (r),(r)
CMEM2 = 8, // byte signed or half word
@


<<memory opcodes>>=
OLDH    = 78,
OLDBU   = 79,
OSTH    = 80,
OSTBU   = 81,
@

<<[[arm_class()]] class 0, if x has 0x9 bits>>=
if((x & 0x9) == 0x9) {		/* ld/st byte/half s/u */
     //                          OxxBU?               OSTx?
     op = CMEM_BASIS + CMEM2 + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
     break;
}
@



<<memory opcodes>>=
OSWPW = 82,
OSWPBU = 83,
@


<<[[arm_class()]] class 0, when x == 0x9, if bit 24 set>>=
if(w & (1<<24)) {
    op = OSWPW;
    if(w & (1<<22))
         op = OSWPBU;
    break;
}
@
% >> >>


\subsection{Memory swap}

% not that useful, but ensured to be atomic so used to implement _tas!!
% indeed when multi processor need to sync, they share something, memory
% but each have independent register, so way to sync is via swap.
% Here single processor, so emulation not very interesting.

<<[[itab]] elements>>=
[OSWPW] =   { Iswap,		"SWPW",	Imem },
[OSWPBU] =  { Iswap,		"SWPBU",Imem },
@

<<function [[Iswap]]>>=
void
Iswap(instruction inst)
{
    int rn, rd, rm;
    ulong address, value;
    bool bbit;

    bbit = inst & (1<<22); // BU?

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    rm = (inst>>0) & 0xf;

    address = reg.r[rn];
    if(bbit) {
        value = getmem_b(address);
        putmem_b(address, reg.r[rm]);
    } else {
        value = getmem_w(address);
        putmem_w(address, reg.r[rm]);
    }
    reg.r[rd] = value;

    <<[[Iswap()]] trace>>
}
@



\ifallcode
<<[[Iswap()]] trace>>=
if(trace) {
    char *bw, *dotc;

    bw = bbit? "B" : "";
    dotc = cond[reg.instr_cond];

    itrace("SWP%s%s\t#%x(R%d),R%d #%lux=#%x",
        bw, dotc,
        rn, rd,
        address, value);
}
@
\fi
%old:
%    bw = "";
%    if(bbit)
%        bw = "B";




\subsection{Load/store}

<<[[itab]] elements>>=
// load/store w/ub i,r
[OLDW +CMEM0] =  { Imem1,		"MOVW",	Imem },
[OLDB +CMEM0] =  { Imem1,		"MOVB",	Imem },
[OSTW +CMEM0] =  { Imem1,		"MOVW",	Imem },
[OSTB +CMEM0] =  { Imem1,		"MOVB",	Imem },
@

<<[[itab]] elements>>=
// load/store r,r
[OLDW +CMEM1] =  { Imem1,		"MOVW",	Imem },
[OLDB +CMEM1] =  { Imem1,		"MOVB",	Imem },
[OSTW +CMEM1] =  { Imem1,		"MOVW",	Imem },
[OSTB +CMEM1] =  { Imem1,		"MOVB",	Imem },
@

<<function [[Imem1]]>>=
/*
 * load/store word/byte
 */
void
Imem1(instruction inst)
{
    int rn, rd, off, rm, sc, st;
    ulong address, value;
    bool prebit, ubit, bbit, wbit, lbit, bit25;

    bit25 = inst & (1<<25); // rm or I?
    prebit = inst & (1<<24); // Pre indexing?
    ubit = inst & (1<<23); // Up offset?
    bbit = inst & (1<<22); // Byte or Word?
    wbit = inst & (1<<21); // Write back address in rn?
    lbit = inst & (1<<20); // LDR or STR?

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;

    SET(st);
    SET(sc);
    SET(rm);

    if(bit25) {
        // rm<>I(...)
        rm = inst & 0xf;
        st = (inst>>5) & 0x3;
        sc = (inst>>7) & 0x1f;
        off = reg.r[rm];
        if(rm == REGPC)
            off += 8;
        off = shift(off, st, sc, false);
    } else {
        // I(...)
        off = inst & 0xfff;
    }

    if(!ubit)
        off = -off;
    if(rn == REGPC)
        off += 8;

    address = reg.r[rn];
    if(prebit)
        address += off;

    if(lbit) {
        // LDR
        if(bbit)
            value = getmem_b(address);
        else
            value = getmem_w(address);
        if(rd == REGPC)
            value -= 4;
        reg.r[rd] = value;
    } else {
        // STR
        value = reg.r[rd];
        if(rd == REGPC)
            value -= 4;
        if(bbit)
            putmem_b(address, value);
        else
            putmem_w(address, value);
    }
    if(!prebit || wbit)
        reg.r[rn] += off;

    <<[[Imem1()]] trace>>
}
@
% >> >> >>
%old: I introduced bool for the xxbit
% I renamed pbit to prebit as just p is ambiguous (pre or post?)
% and changed the double negation 
%    if(!(prebit && !wbit))
%        reg.r[rn] += off;

% see Assembler. 
% MOVW.P #4(R13), R15, for RET  .P = post indexing (and implicit write)
% TEXT foo, $8 ->  MOVW.W	R14,-12(R13)

% useful to have push/pop in one instruction in hardware!

\ifallcode
<<[[Imem1()]] trace>>=
if(trace) {
    char *bw, *dotp, *dotc;

    bw = bbit ? "BU" : "W";
    dotp = prebit? "" : ".P";
    dotc = cond[reg.instr_cond];

    if(lbit) {
        // LDR
        if(!bit25)
            itrace("MOV%s%s%s\t#%x(R%d),R%d #%lux=#%x",
                bw, dotp, dotc,
                off, rn, rd,
                address, value);
        else
            itrace("MOV%s%s%s\t(R%d%s%d)(R%d),R%d  #%lux=#%x",
                bw, dotp, dotc,
                rm, shtype[st], sc, rn, rd,
                address, value);
    } else {
        // STR
        if(!bit25)
            itrace("MOV%s%s%s\tR%d,#%x(R%d) #%lux=#%x",
                bw, dotp, dotc,
                rd, off, rn,
                address, value);
        else
            itrace("MOV%s%s%s\tR%d,(R%d%s%d)(R%d) #%lux=#%x",
                bw, dotp, dotc,
                rd, rm, shtype[st], sc, rn,
                address, value);
    }
}
@
\fi
%old: 
%    bw = "W";
%    if(bbit)
%        bw = "BU";
%    dotp = "";
%    if(!pbit)
%        dotp = ".P";



\t adv topics? after all it is an ARMv4 only stuff according to 5l
<<[[itab]] elements>>=
// load/store h/sb
[OLDH]  =  { Imem2,		"MOV",	Imem },
[OLDBU] =  { Imem2,		"MOV",	Imem },
[OSTH]  =  { Imem2,		"MOV",	Imem },
[OSTBU] =  { Imem2,		"MOV",	Imem },
@

<<function [[Imem2]]>>=
/*
 * load/store unsigned byte/half word
 */
void
Imem2(instruction inst)
{
    int rn, rd, off, rm;
    ulong address, value;
    bool prebit, ubit, hbit, sbit, wbit, lbit, bit22;

    prebit = inst & (1<<24); // Pre indexing?
    ubit = inst & (1<<23); // Up offset?
    bit22 = inst & (1<<22);
    wbit = inst & (1<<21); // Write back address in rn
    lbit = inst & (1<<20); // LDR or STR?

    sbit = inst & (1<<6); // Signed?
    hbit = inst & (1<<5); // Half word or byte?

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;

    SET(rm);
    if(bit22) {
        // I(...)
        off = ((inst>>4) & 0xf0) | (inst & 0xf);
    } else {
        // rm(...)
        rm = inst & 0xf;
        off = reg.r[rm];
        if(rm == REGPC)
            off += 8;
    }
    if(!ubit)
        off = -off;
    if(rn == REGPC)
        off += 8;

    address = reg.r[rn];
    if(prebit)
        address += off;

    if(lbit) {
        // LDR
        if(hbit) {
            value = getmem_h(address);
            if(sbit && (value & 0x8000))
                value |= 0xffff0000;
        } else {
            value = getmem_b(address);
            if(value & 0x80)
                value |= 0xffffff00;
        }
        if(rd == REGPC)
            value -= 4;
        reg.r[rd] = value;
    } else {
        // STR
        value = reg.r[rd];
        if(rd == REGPC)
            value -= 4;
        if(hbit) {
            putmem_h(address, value);
        } else {
            putmem_b(address, value);
        }
    }
    if(!prebit || wbit)
        reg.r[rn] += off;

    <<[[Imem2()]] trace>>
}
@
% >> >> >> >>
%old: same stuff that for Imem1, bool, prebit, and removed double negation


\ifallcode
<<[[Imem2()]] trace>>=
if(trace) {
    char *hb, *dotp, *dotc;

    hb = hbit? "H" : "B";
    dotp = prebit? "" : ".P";
    dotc = cond[reg.instr_cond];

    if(lbit) {
        if(bit22)
            itrace("MOV%s%s%s\t#%x(R%d),R%d #%lux=#%x",
                hb, dotp, dotc,
                off, rn, rd,
                address, value);
        else
            itrace("MOV%s%s%s\t(R%d)(R%d),R%d  #%lux=#%x",
                hb, dotp, dotc,
                rm, rn, rd,
                address, value);
    } else {
        if(bit22)
            itrace("MOV%s%s%s\tR%d,#%x(R%d) #%lux=#%x",
                hb, dotp, dotc,
                rd, off, rn,
                address, value);
        else
            itrace("MOV%s%s%s\tR%d,(R%d)(R%d) #%lux=#%x",
                hb, dotp, dotc,
                rd, rm, rn,
                address, value);
    }
}
@
\fi
%old:
%    hb = "B";
%    if(hbit)
%        hb = "H";
%    dotp = "";
%    if(!pbit)
%        dotp = ".P";




\subsection{Multi registers load/store}
\l advanced topic? like I did in Assembler.nw?

<<memory opcodes>>=
OLDM = 84,
OSTM = 85,
@


<<[[arm_class()]] class cases>>=
case 4:	/* block data transfer (r)(r) */
 op = CBLOC + ((w >> 20) & 0x1);
 break;
@
%48+24+4+4

<<memory opcodes>>=
CBLOC   = 84,
@

<<[[itab]] elements>>=
// block move r,r
[OLDM] =  { Ilsm,		"LDM",	Imem },
[OSTM] =  { Ilsm,		"STM",	Imem },
@

<<function [[Ilsm]]>>=
void
Ilsm(instruction inst)
{
    bool prebit, ubit, sbit, wbit, lbit;
    int i, rn, reglist;
    ulong address, predelta, postdelta;

    prebit = (inst>>24) & 0x1;
    ubit = (inst>>23) & 0x1;
    sbit = (inst>>22) & 0x1;
    wbit = (inst>>21) & 0x1;
    lbit = (inst>>20) & 0x1;
    rn =   (inst>>16) & 0xf;
    reglist = inst & 0xffff;

    if(reglist & 0x8000)
        undef(reg.instr);
    if(sbit)
        undef(reg.instr);

    address = reg.r[rn];

    if(prebit) {
        predelta = 4;
        postdelta = 0;
    } else {
        predelta = 0;
        postdelta = 4;
    }
    if(ubit) {
        for (i = 0; i < 16; ++i) {
            if(!(reglist & (1 << i)))
                continue;
            address += predelta;
            if(lbit)
                reg.r[i] = getmem_w(address);
            else
                putmem_w(address, reg.r[i]);
            address += postdelta;
        }
    } else {
        for (i = 15; 0 <= i; --i) {
            if(!(reglist & (1 << i)))
                continue;
            address -= predelta;
            if(lbit)
                reg.r[i] = getmem_w(address);
            else
                putmem_w(address, reg.r[i]);
            address -= postdelta;
        }
    }
    if(wbit) {
        reg.r[rn] = address;
    }

    <<[[Ilsm()]] trace>>
}
@
% >> >> 
%old: char -> bool

\ifallcode
<<[[Ilsm()]] trace>>=
if(trace) {
    itrace("%s.%c%c\tR%d=%lux%s, <%lux>",
        (lbit ? "LDM" : "STM"), (ubit ? 'I' : 'D'), (prebit ? 'B' : 'A'),
        rn, reg.r[rn], (wbit ? "!" : ""), reglist);
}
@
\fi

\section{Control flow}

\subsection{Opcode extraction}

<<branching opcodes>>=
OB = 86,
OBL = 87,
@

<<[[arm_class()]] class cases>>=
case 5:	/* branch / branch link */
 op = CBRANCH + ((w >> 24) & 0x1);
 break;
@
%(48+24+4+4+2)

<<branching opcodes>>=
CBRANCH = 86,
@

\subsection{Simple branching}

<<[[itab]] elements>>=
// branch
[OB]  =  { Ib,	"B",	Ibranch },
@


<<function [[Ib]]>>=
void
Ib(instruction inst)
{
    long v;

    v = inst & 0xffffff; // 24 bits
    v = reg.r[REGPC] + (v << 2) + 8;
    <<[[Ib()]] trace>>
    reg.r[REGPC] = v - 4;
}
@
%old: v << 8 >> 6
% why +8? because when jmp usually it's not the current instruction,
% nor the next instruction, so make sense to by default jump to +8
% why -4? to compensate back for +=4 in run()
% why << 8 and then >> 6
% why << 2? because jump are anyway to code and so 4 bytes boundaries

% note that there is no conditional branch instruction like
% JNE, JEQ, etc, because B is using the generic conditional execution
% feature of ARM, so most branch will be like B.EQ and many of then
% will be IGNORED.

\ifallcode
<<[[Ib()]] trace>>=
if(trace)
    itrace("B%s\t#%lux", cond[reg.instr_cond], v);
@
\fi


\subsection{Branch and link}

<<[[itab]] elements>>=
[OBL] =  { Ibl,	"BL",	Ibranch },
@

<<function [[Ibl]]>>=
void
Ibl(instruction inst)
{
    long v;
    Symbol s;

    v = inst & 0xffffff;
    v = reg.r[REGPC] + (v << 2) + 8;
    <<[[Ibl()]] trace>>
    <<[[Ibl()]] if calltree>>
    reg.r[REGLINK] = reg.r[REGPC] + 4;
    reg.r[REGPC] = v - 4;
}
@
% >>
%old: v << 8 >> 6
% Branch and Link, so kinda call. The callee needs to save.
% REGLINK then in the stack if one wants to have multiple BL.
% For leaves, no need stack, if want RET, just have to mov reglink, regpc.

% +4 to save the next instruction, so RET comes back after the current
% instruction (after the BL). -4 to compensate.

\ifallcode
<<[[Ibl()]] trace>>=
if(trace)
    itrace("BL%s\t#%lux", cond[reg.instr_cond], v);
@
\fi


\subsection{Comparisons}

<<[[dpex()]] switch arith/logic opcode cases>>=
case OSUB:
    reg.r[rd] = o1 - o2;
    // Fallthrough
case OCMP:
    if(inst & Sbit) {
        reg.cc1 = o1;
        reg.cc2 = o2;
        reg.compare_op = CCcmp;
    }
    return;
@
% Sbit always set for comparison stuff, so inst & Sbit
%  useful only for the OSUB fallthrough above.

<<[[dpex()]] switch arith/logic opcode cases>>=
case  OTST:
    if(inst & Sbit) {
        reg.cc1 = o1;
        reg.cc2 = o2;
        reg.compare_op = CCtst;
    }
    return;
case  OTEQ:
    if(inst & Sbit) { // not always true?
        reg.cc1 = o1;
        reg.cc2 = o2;
        reg.compare_op = CCteq;
    }
    return;
@



\subsection{ARM Conditional execution}
% see later?? when talk about Branch? hmm but need also for CMP

% see ARM wikipedia page.
% Useful because have a very simple branching instruction.
% They generalize in some sense for all instructions, not just
% branching.
% apply also to other instructions like ADD.

% also trick to compensate for lack of branch prediction

<<[[Registers]] other fields>>=
// actually only 4 bits (16 possibilities)
int	instr_cond;
@
%note: I renamed from cond to instr_cond so easier to see that
% this is derived from the instruction, unlike compare_op below
% which is derived from runtime

<<[[run()]] set reg.cond>>=
reg.instr_cond = (reg.instr>>28) & 0xf;
@
% so this is part of the opcode, the user program decides this

<<[[Registers]] other fields>>=
// enum<compare_op>
int	compare_op;
@
% this is part of the processor runtime, it is modified by the execution 
% set to zero originally? some instruction will set compare_op? CMP?

<<enum [[compare_op]]>>=
enum compare_op
{
    CCcmp, 
    CCtst,
    CCteq,
};
@


<<[[run()]] switch [[reg.compare_op]] to set [[execute]]>>=
switch(reg.compare_op) {
case CCcmp:
    execute = runcmp(); // use reg.instr_cond
    break;
case CCteq:
    execute = runteq();
    break;
case CCtst:
    execute = runtst();
    break;
default:
    Bprint(bout, "unimplemented compare operation %x\n",
        reg.compare_op);
    return;
}
@

% rename intern_cc1, intern_cc2?
<<[[Registers]] other fields>>=
long	cc1;
long	cc2;
@


<<function [[runcmp]]>>=
bool
runcmp(void)
{
    switch(reg.instr_cond) {
    case 0x0:	/* eq */	return (reg.cc1 == reg.cc2);
    case 0x1:	/* ne */	return (reg.cc1 != reg.cc2);
    case 0x2:	/* hs */	return ((ulong)reg.cc1 >= (ulong)reg.cc2);
    case 0x3:	/* lo */	return ((ulong)reg.cc1 < (ulong)reg.cc2);
    case 0x4:	/* mi */	return (reg.cc1 - reg.cc2 < 0);
    case 0x5:	/* pl */	return (reg.cc1 - reg.cc2 >= 0);
    case 0x8:	/* hi */	return ((ulong)reg.cc1 > (ulong)reg.cc2);
    case 0x9:	/* ls */	return ((ulong)reg.cc1 <= (ulong)reg.cc2);
    case 0xa:	/* ge */	return (reg.cc1 >= reg.cc2);
    case 0xb:	/* lt */	return (reg.cc1 < reg.cc2);
    case 0xc:	/* gt */	return (reg.cc1 > reg.cc2);
    case 0xd:	/* le */	return (reg.cc1 <= reg.cc2);

    case 0xe:	/* al */	return true;
    case 0xf:	/* nv */	return false;
    default:
        Bprint(bout, "unimplemented condition prefix %x (%ld %ld)\n",
            reg.instr_cond, reg.cc1, reg.cc2);
        undef(reg.instr);
        return false;
    }
}
@

<<constant [[SIGNBIT]]>>=
SIGNBIT		= 0x80000000,
@

<<function [[runteq]]>>=
bool
runteq(void)
{
    long res = reg.cc1 ^ reg.cc2;

    switch(reg.instr_cond) {
    case 0x0:	/* eq */	return res == 0;
    case 0x1:	/* ne */	return res != 0;
    case 0x4:	/* mi */	return (res & SIGNBIT) != 0;
    case 0x5:	/* pl */	return (res & SIGNBIT) == 0;
    case 0xe:	/* al */	return true;
    case 0xf:	/* nv */	return false;
    default:
        Bprint(bout, "unimplemented condition prefix %x (%ld %ld)\n",
            reg.instr_cond, reg.cc1, reg.cc2);
        undef(reg.instr);
        return false;
    }
}
@

<<function [[runtst]]>>=
bool
runtst(void)
{
    long res = reg.cc1 & reg.cc2;

    switch(reg.instr_cond) {
    case 0x0:	/* eq */	return res == 0;
    case 0x1:	/* ne */	return res != 0;
    case 0x4:	/* mi */	return (res & SIGNBIT) != 0;
    case 0x5:	/* pl */	return (res & SIGNBIT) == 0;
    case 0xe:	/* al */	return true;
    case 0xf:	/* nv */	return false;
    default:
        Bprint(bout, "unimplemented condition prefix %x (%ld %ld)\n",
            reg.instr_cond, reg.cc1, reg.cc2);
        undef(reg.instr);
        return false;
    }
}
@

%\section{IO}
% keyboard and display emulation? no, done via software interrupt

\section{Software interrupt}
% software interrupt aka syscall
% see chapter

<<syscall opcodes>>=
OSWI = 88,
@
%// was called OSYSCALL but SWI is more consistent with Assembler.nw

<<[[arm_class()]] class cases>>=
case 7:	/* coprocessor crap */ // and syscall
 if((w >> 25) & 0x1)
   op = OSWI;
 else
   op = OUNDEF; // coprocessor stuff not handled
 break;
@
% op = (48+24+4+4+2+2) + ((w >> 3) & 0x2) + ((w >> 20) & 0x1);
% should assert bit 25 is 1

<<[[itab]] elements>>=
[OSWI] =  { Ssyscall,		"SWI",	Isyscall },
@

% no RFE here, because RFE should never be used in application code.
% Only system code could contain RFE, but we emulate completely
% system code.

\section{Unimplemented instructions}

% - MCR, and other very low level stuff
% - ADC/... transfer to undef
% - RFE see above











\chapter{Memory}

% we proxy memory ourselves, so virtual mem address correspond
% to process mem address got via malloc (see Segment.table).
% so dotlb() is really just to gather profiling information.
% the translation info is in Segment.table

% this is enough for running user process. But if wanted
% to make a real similator, where run OS on it, then
% it would not work. We will need to implement the logic
% of page faults, device interrupts, etc.
% see also Syscalls chapter.

\section{[[page_of_vaddr()]]}

<<function [[page_of_vaddr]]>>=
void*
page_of_vaddr(uintptr addr)
{
    Segment *s, *es;
    int off, foff, l, n;
    byte **p, *a;

    <<[[page_of_vaddr()]] TLB handling>>

    es = &memory.seg[Nseg];
    for(s = memory.seg; s < es; s++) {
        if(addr >= s->base && addr < s->end) {
            s->refs++;
            off = (addr - s->base)/BY2PG;
            p = &s->table[off];

            if(*p)
                return *p;

            // else page fault! no allocated memory there yet
            s->rss++;

            switch(s->type) {
            <<[[page_of_vaddr()]] page fault, switch segment type cases>>
            default:
                fatal(false, "page_of_vaddr");
            }
        }
    }
    // reach here if didn't find any segment with relevant range
    Bprint(bout, "User TLB miss vaddr 0x%.8lux\n", addr);
    Bflush(bout);
    longjmp(errjmp, 0);
    return nil;		/*to stop compiler whining*/
}
@
%old: was called vaddr

\section{Page faults}

% demand loading

<<[[page_of_vaddr()]] page fault, switch segment type cases>>=
case Text:
    *p = emalloc(BY2PG);
    if(seek(text, s->fileoff+(off*BY2PG), 0) < 0)
        fatal(true, "page_of_vaddr text seek");
    if(read(text, *p, BY2PG) < 0)
        fatal(true, "page_of_vaddr text read");
    return *p;
@

<<[[page_of_vaddr()]] page fault, switch segment type cases>>=
case Data:
    *p = emalloc(BY2PG);
    foff = s->fileoff+(off*BY2PG);
    if(seek(text, foff, 0) < 0)
        fatal(true, "page_of_vaddr text seek");
    n = read(text, *p, BY2PG);
    if(n < 0)
        fatal(true, "page_of_vaddr text read");
    if(foff + n > s->fileend) {
        l = BY2PG - (s->fileend-foff);
        a = *p+(s->fileend-foff);
        memset(a, 0, l);
    }
    return *p;
@

<<[[page_of_vaddr()]] page fault, switch segment type cases>>=
case Bss:
case Stack:
    *p = emalloc(BY2PG);
    return *p;
@

% zeroed!! cos emalloc does memset(, 0, )

\section{[[Tlb]]}

% just to gather stats, which is useful
% so 5i can also be a very special kind of profiler.

<<struct [[Tlb]]>>=
struct Tlb
{
    bool	on;			/* Being updated */
    int		tlbsize;		/* Number of entries */
    // all pointers in array are at page granularity
    uintptr	tlbent[Nmaxtlb];	/* Virtual address tags */

    int	hit;			/* Number of successful tag matches */
    int	miss;			/* Number of failed tag matches */
};		
@

<<constant [[Nmaxtlb]]>>=
#define Nmaxtlb 64
@

<<global [[tlb]]>>=
Tlb tlb;
@

<<[[main()]] tlb initialisation>>=
tlb.on = true;
tlb.tlbsize = 24;
@


<<[[page_of_vaddr()]] TLB handling>>=
if(tlb.on)
    dotlb(addr);
@

% just for stats
<<function [[dotlb]]>>=
void
dotlb(uintptr vaddr)
{
    ulong *l, *e;

    vaddr &= ~(BY2PG-1);

    e = &tlb.tlbent[tlb.tlbsize];
    for(l = tlb.tlbent; l < e; l++)
        if(*l == vaddr) {
            tlb.hit++;
            return;
        }

    tlb.miss++;
    tlb.tlbent[lnrand(tlb.tlbsize)] = vaddr;
}
@


\section{[[ifetch()]]}

<<function [[ifetch]]>>=
instruction
ifetch(uintptr addr)
{
    byte *va;

    if(addr&3) {
        Bprint(bout, "Address error (I-fetch) vaddr %.8lux\n", addr);
        longjmp(errjmp, 0);
    }

    <<[[ifetch()]] instruction cache handling>>
    iprof[(addr-textbase)/PROFGRAN]++;

    va = page_of_vaddr(addr); // get page
    va += addr&(BY2PG-1); // restore offset in page

    return va[3]<<24 | va[2]<<16 | va[1]<<8 | va[0];
}
@
% >> >> >>

\section{The instruction cache}

% again, can be useful for 5i to acts as a kind of profiler

<<struct [[Icache]]>>=
struct Icache
{
    bool	on;			/* Turned on */

    int		linesize;		/* Line size in bytes */
    int		stall;			/* Cache stalls */
    int*	lines;			/* Tag array */
    int*	(*hash)(ulong);	/* Hash function */
    char*	hashtext;		/* What the function looks like */
};
@

<<global [[icache]]>>=
Icache icache;
@

<<[[ifetch()]] instruction cache handling>>=
if(icache.on)
    updateicache(addr);
@

% no icache in ARM? vs vi/?
<<function [[updateicache]]>>=
void
updateicache(uintptr addr)
{
    USED(addr);
}
@


\section{[[getmem_xxx()]]}

% bytes
% half-word
% word
% vlong

<<function [[getmem_b]]>>=
byte
getmem_b(uintptr addr)
{
    byte *va;

    <<[[getmem_x()]] if membpt>>

    va = page_of_vaddr(addr);
    va += addr&(BY2PG-1);
    return va[0];
}
@

<<function [[getmem_h]]>>=
ushort
getmem_h(uintptr addr)
{
    byte *va;
    ulong w;

    if(addr&1) {
        w = getmem_h(addr & ~1);
        while(addr & 1) {
            w = (w>>8) | (w<<8);
            addr--;
        }
        return w;
    }
    <<[[getmem_x()]] if membpt>>

    va = page_of_vaddr(addr);
    va += addr&(BY2PG-1);

    return va[1]<<8 | va[0];
}
@
% >> >>
% if 2 bytes, then could be at page frontier, so have to take care
% but if 2 bytes aligned then safe

<<function [[getmem_w]]>>=
ulong
getmem_w(uintptr addr)
{
    byte *va;
    ulong w;

    if(addr&3) {
        w = getmem_w(addr & ~3);
        while(addr & 3) {
            w = (w>>8) | (w<<24);
            addr--;
        }
        return w;
    }
    <<[[getmem_x()]] if membpt>>

    va = page_of_vaddr(addr);
    va += addr&(BY2PG-1);

    return va[3]<<24 | va[2]<<16 | va[1]<<8 | va[0];
}
@
% >> >> >> >>
% similar, if 4 bytes aligned then simple because pages are
% 4096 so 4 bytes aligned too.



<<function [[getmem_v]]>>=
uvlong
getmem_v(uintptr addr)
{
    return ((uvlong)getmem_w(addr+4) << 32) | getmem_w(addr);
}
@
% >>


% ??? seems used only by debugger and format
<<function [[getmem_2]]>>=
ulong
getmem_2(uintptr addr)
{
    ulong val;
    int i;

    val = 0;
    for(i = 0; i < 2; i++)
        val = (val>>8) | (getmem_b(addr++)<<16);
    return val;
}
@
% >>

<<function [[getmem_4]]>>=
ulong
getmem_4(uintptr addr)
{
    ulong val;
    int i;

    val = 0;
    for(i = 0; i < 4; i++)
        val = (val>>8) | (getmem_b(addr++)<<24);
    return val;
}
@
% >>

% see also memio() in Syscall chapter

\section{[[putmem_xxx()]]}

<<function [[putmem_b]]>>=
void
putmem_b(uintptr addr, byte data)
{
    byte *va;

    va = page_of_vaddr(addr);
    va += addr&(BY2PG-1);
    va[0] = data;

    <<[[putmem_x()]] if membpt>>
}
@

% the putmem_xxx do not accept unaligned addr as opposed to the
% getmem_xxx

<<function [[putmem_h]]>>=
void
putmem_h(uintptr addr, ushort data)
{
    byte *va;

    if(addr&1) {
        Bprint(bout, "Address error (Store) vaddr %.8lux\n", addr);
        longjmp(errjmp, 0);
    }

    va = page_of_vaddr(addr);
    va += addr&(BY2PG-1);

    va[1] = data>>8;
    va[0] = data;

    <<[[putmem_x()]] if membpt>>
}
@
% >> >>

<<function [[putmem_w]]>>=
void
putmem_w(uintptr addr, ulong data)
{
    byte *va;

    if(addr&3) {
        Bprint(bout, "Address error (Store) vaddr %.8lux\n", addr);
        longjmp(errjmp, 0);
    }

    va = page_of_vaddr(addr);
    va += addr&(BY2PG-1);

    va[3] = data>>24;
    va[2] = data>>16;
    va[1] = data>>8;
    va[0] = data;

    <<[[putmem_x()]] if membpt>>
}
@


<<function [[putmem_v]]>>=
void
putmem_v(uintptr addr, uvlong data)
{
    putmem_w(addr, data);	/* two stages, to catch brkchk */
    putmem_w(addr+4, data>>32);
}
@





\chapter{Syscalls Emulation}

% emulation/proxy at syscall level.
% Qemu is at hardware device level
% other stuff are at libc level.
% 5i is at syscall level (so it does not have also to
% emulate lots of stuff like MCR,MRC, etc)

% #include "/sys/src/libc/9syscall/sys.h"



<<global [[systab]]>>=
void	(*systab[])(void) =
{
    [NOP]		sysnop,

    [RFORK]		sysrfork,
    [EXEC]		sysexec,
    [EXITS]		sysexits,
    [AWAIT]		sysawait,

    [BRK]		sysbrk,

    [OPEN]		sysopen,
    [CLOSE]		sysclose,
    [PREAD]		syspread,
    [PWRITE]	syspwrite,
    [SEEK]		sysseek,

    [CREATE]	syscreate,
    [REMOVE]	sysremove,
    [CHDIR]		syschdir,
    [FD2PATH]	sysfd2path,
    [STAT]		sysstat,
    [FSTAT]		sysfstat,
    [WSTAT]		syswstat,
    [FWSTAT]	sysfwstat,

    [BIND]		sysbind,
    [MOUNT]		sysmount,
    [UNMOUNT]	sysunmount,

    [SLEEP]		syssleep,
    [ALARM]		sysalarm,

    [PIPE]		syspipe,
    [NOTIFY]	sysnotify,
    [NOTED]		sysnoted,

    [SEGATTACH]	syssegattach,
    [SEGDETACH]	syssegdetach,
    [SEGFREE]	syssegfree,
    [SEGFLUSH]	syssegflush,
    [SEGBRK]	syssegbrk,

    [RENDEZVOUS]	sysrendezvous,

    [DUP]		sysdup,
    [FVERSION]	sysfversion,
    [FAUTH]		sysfauth,

    [ERRSTR]	syserrstr,
};
@
% miss 
%#define	SEMACQUIRE	33
%#define	SEMRELEASE	34
%#define	TSEMACQUIRE	35


\ifallcode
<<global [[sysctab]]>>=
char*	sysctab[] =
{
    [NOP]		"Nop",
    [BIND]		"Bind",
    [CHDIR]		"Chdir",
    [CLOSE]		"Close",
    [DUP]		"Dup",
    [ALARM]		"Alarm",
    [EXEC]		"Exec",
    [EXITS]		"Exits",
    [FAUTH]		"Fauth",
    [SEGBRK]	"Segbrk",
    [MOUNT]		"Mount",
    [OPEN]		"Open",
    [SLEEP]		"Sleep",
    [RFORK]		"Rfork",
    [PIPE]		"Pipe",
    [CREATE]	"Create",
    [FD2PATH]	"Fd2path",
    [BRK]		"Brk",
    [REMOVE]	"Remove",
    [NOTIFY]	"Notify",
    [NOTED]		"Noted",
    [SEGATTACH]		"Segattach",
    [SEGDETACH]		"Segdetach",
    [SEGFREE]		"Segfree",
    [SEGFLUSH]		"Segflush",
    [RENDEZVOUS]	"Rendezvous",
    [UNMOUNT]		"Unmount",
    [SEEK]		"Seek",
    [FVERSION]	"Fversion",
    [ERRSTR]	"Errstr",
    [STAT]		"Stat",
    [FSTAT]		"Fstat",
    [WSTAT]		"Wstat",
    [FWSTAT]	"Fwstat",
    [PREAD]		"Pread",
    [PWRITE]	"Pwrite",
    [AWAIT]		"Await",
};
@
\fi

% itab[CSYSCALL].instr = <>
<<function [[Ssyscall]]>>=
void
Ssyscall(instruction _unused)
{
    int call;
    USED(_unused);

    call = reg.r[REGARG];

    if(call < 0 || call >= nelem(systab) || systab[call] == nil) {
        Bprint(bout, "bad system call %d (%#ux)\n", call, call);
        dumpreg();
        Bflush(bout);
        return;
    }

    if(trace)
        itrace("SWI\t%s", sysctab[call]);

    // dispatch!
    (*systab[call])();

    Bflush(bout);
}
@







%\chapter{IO}
\section{[[memio()]]}
% to read/write array of bytes, with special handling for strings sometimes
% not sure why the function is called IO, should be mem_array

<<enum [[memxxx]]>>=
// for memio()
enum
{
    MemRead,
    MemReadstring,
    MemWrite,
};
@

% syserrstr | sysbind | sysfd2path | ... -> <>
<<function [[memio]]>>=
char *
memio(char *mb, uintptr mem, int size, int dir)
{
    int i;
    char *buf, c;

    if(mb == nil)
        mb = emalloc(size);

    buf = mb;
    switch(dir) {
    case MemRead:
        while(size--)
            *mb++ = getmem_b(mem++);
        break;
    case MemReadstring:
        for(;;) {
            if(size-- == 0) {
                Bprint(bout, "memio: user/kernel copy too long for arm\n");
                longjmp(errjmp, 0);
            }
            c = getmem_b(mem++);
            *mb++ = c;
            if(c == '\0')
                break;
        }
        break;
    case MemWrite:
        for(i = 0; i < size; i++)
            putmem_b(mem++, *mb++);
        break;
    default:
        fatal(false, "memio");
    }
    return buf;
}
@

\section{Nop and errstr syscalls}

<<function [[sysnop]]>>=
void
sysnop(void)
{
    Bprint(bout, "nop system call %s\n", sysctab[reg.r[1]]);
    <<[[sysnop]] strace>>
}
@
% used to have    exits(0);
% but sysnop used to be sysr1() but I changed that to nop, and nop
% should not exit()
% was called sysr1, which is why it was printing reg.r[1] probably.

<<global [[errbuf]]>>=
char 	errbuf[ERRMAX];
@

<<function [[syserrstr]]>>=
void
syserrstr(void)
{
    ulong str;
    int n;

    str = getmem_w(reg.r[REGSP]+4);
    n = getmem_w(reg.r[REGSP]+8);
    if(sysdbg)
        itrace("errstr(0x%lux, 0x%lux)", str, n);

    if(n > strlen(errbuf)+1)
        n = strlen(errbuf)+1;
    memio(errbuf, str, n, MemWrite);
    strcpy(errbuf, "no error");
    reg.r[REGRET] = n;
    
}
@

\section{Memory syscalls}

<<function [[sysbrk]]>>=
void
sysbrk(void)
{
    ulong addr, osize, nsize;
    Segment *s;

    addr = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("brk(0x%lux)", addr);

    reg.r[REGRET] = -1;
    if(addr < memory.seg[Data].base+datasize) {
        strcpy(errbuf, "address below segment");
        return;
    }
    if(addr > memory.seg[Stack].base) {
        strcpy(errbuf, "segment too big");
        return;
    }
    s = &memory.seg[Bss];
    if(addr > s->end) {
        osize = ((s->end-s->base)/BY2PG)*sizeof(byte*);
        addr = ((addr)+(BY2PG-1))&~(BY2PG-1);
        s->end = addr;
        nsize = ((s->end-s->base)/BY2PG)*sizeof(byte*);
        s->table = erealloc(s->table, osize, nsize);
    }	

    reg.r[REGRET] = 0;	
}
@


\section{File and IO syscalls}

<<function [[sysopen]]>>=
void
sysopen(void)
{
    char file[1024];
    int n;
    ulong mode, name;

    name = getmem_w(reg.r[REGSP]+4);
    mode = getmem_w(reg.r[REGSP]+8);
    memio(file, name, sizeof(file), MemReadstring);
    
    n = open(file, mode);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);

    if(sysdbg)
        itrace("open(0x%lux='%s', 0x%lux) = %d", name, file, mode, n);

    reg.r[REGRET] = n;
};
@

<<function [[sysclose]]>>=
void
sysclose(void)
{
    int n;
    ulong fd;

    fd = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("close(%d)", fd);

    n = close(fd);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    reg.r[REGRET] = n;
}
@


<<function [[sysread]]>>=
void
sysread(vlong offset)
{
    int fd;
    ulong size, a;
    char *buf, *p;
    int n, cnt, c;

    fd = getmem_w(reg.r[REGSP]+4);
    a = getmem_w(reg.r[REGSP]+8);
    size = getmem_w(reg.r[REGSP]+12);

    buf = emalloc(size);
    if(fd == 0) {
        print("\nstdin>>");
        p = buf;
        n = 0;
        cnt = size;
        while(cnt) {
            c = Bgetc(bin);
            if(c <= 0)
                break;
            *p++ = c;
            n++;
            cnt--;
            if(c == '\n')
                break;
        }
    }
    else
        n = pread(fd, buf, size, offset);

    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    else
        memio(buf, a, n, MemWrite);

    if(sysdbg)
        itrace("read(%d, 0x%lux, %d, 0x%llx) = %d", fd, a, size, offset, n);

    free(buf);
    reg.r[REGRET] = n;
}
@

<<function [[syspread]]>>=
void
syspread(void)
{
    sysread(getmem_v(reg.r[REGSP]+16));
}
@

<<function [[sysseek]]>>=
void
sysseek(void)
{
    int fd;
    ulong mode;
    ulong retp;
    vlong v;

    retp = getmem_w(reg.r[REGSP]+4);
    fd = getmem_w(reg.r[REGSP]+8);
    v = getmem_v(reg.r[REGSP]+16);
    mode = getmem_w(reg.r[REGSP]+20);
    if(sysdbg)
        itrace("seek(%d, %lld, %d)", fd, v, mode);

    v = seek(fd, v, mode);
    if(v < 0)
        errstr(errbuf, sizeof errbuf);	

    putmem_v(retp, v);
}
@


<<function [[syswrite]]>>=
void
syswrite(vlong offset)
{
    int fd;
    ulong size, a;
    char *buf;
    int n;

    fd = getmem_w(reg.r[REGSP]+4);
    a = getmem_w(reg.r[REGSP]+8);
    size = getmem_w(reg.r[REGSP]+12);

    Bflush(bout);
    buf = memio(0, a, size, MemRead);
    n = pwrite(fd, buf, size, offset);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);	

    if(sysdbg)
        itrace("write(%d, %lux, %d, 0x%llx) = %d", fd, a, size, offset, n);

    free(buf);

    reg.r[REGRET] = n;
}
@

<<function [[syspwrite]]>>=
void
syspwrite(void)
{
    syswrite(getmem_v(reg.r[REGSP]+16));
}
@



<<function [[sysstat]]>>=
void
sysstat(void)
{
    char nambuf[1024];
    byte buf[STATMAX];
    ulong edir, name;
    int n;

    name = getmem_w(reg.r[REGSP]+4);
    edir = getmem_w(reg.r[REGSP]+8);
    n = getmem_w(reg.r[REGSP]+12);
    memio(nambuf, name, sizeof(nambuf), MemReadstring);
    if(sysdbg)
        itrace("stat(0x%lux='%s', 0x%lux, 0x%lux)", name, nambuf, edir, n);
    if(n > sizeof buf)
        errstr(errbuf, sizeof errbuf);
    else{	
        n = stat(nambuf, buf, n);
        if(n < 0)
            errstr(errbuf, sizeof errbuf);
        else
            memio((char*)buf, edir, n, MemWrite);
    }
    reg.r[REGRET] = n;
}
@

<<function [[sysfstat]]>>=
void
sysfstat(void)
{
    byte buf[STATMAX];
    ulong edir;
    int n, fd;

    fd = getmem_w(reg.r[REGSP]+4);
    edir = getmem_w(reg.r[REGSP]+8);
    n = getmem_w(reg.r[REGSP]+12);
    if(sysdbg)
        itrace("fstat(%d, 0x%lux, 0x%lux)", fd, edir, n);

    reg.r[REGRET] = -1;
    if(n > sizeof buf){
        strcpy(errbuf, "stat buffer too big");
        return;
    }
    n = fstat(fd, buf, n);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    else
        memio((char*)buf, edir, n, MemWrite);
    reg.r[REGRET] = n;
}
@


\section{Directory syscalls}

<<function [[syscreate]]>>=
void
syscreate(void)
{
    char file[1024];
    int n;
    ulong mode, name, perm;

    name = getmem_w(reg.r[REGSP]+4);
    mode = getmem_w(reg.r[REGSP]+8);
    perm = getmem_w(reg.r[REGSP]+12);
    memio(file, name, sizeof(file), MemReadstring);
    if(sysdbg)
        itrace("create(0x%lux='%s', 0x%lux, 0x%lux)", name, file, mode, perm);
    
    n = create(file, mode, perm);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);

    reg.r[REGRET] = n;
}
@

<<function [[sysremove]]>>=
void
sysremove(void)
{
    char nambuf[1024];
    ulong name;
    int n;

    name = getmem_w(reg.r[REGSP]+4);
    memio(nambuf, name, sizeof(nambuf), MemReadstring);
    if(sysdbg)
        itrace("remove(0x%lux='%s')", name, nambuf);

    n = remove(nambuf);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    reg.r[REGRET] = n;
}
@



<<function [[sysfd2path]]>>=
void
sysfd2path(void)
{
    int n;
    uint fd;
    ulong str;
    char buf[1024];

    fd = getmem_w(reg.r[REGSP]+4);
    str = getmem_w(reg.r[REGSP]+8);
    n = getmem_w(reg.r[REGSP]+12);
    if(sysdbg)
        itrace("fd2path(0x%lux, 0x%lux, 0x%lux)", fd, str, n);
    reg.r[1] = -1;
    if(n > sizeof buf){
        strcpy(errbuf, "buffer too big");
        return;
    }
    n = fd2path(fd, buf, sizeof buf);
    if(n < 0)
        errstr(buf, sizeof buf);
    else
        memio(errbuf, str, n, MemWrite);
    reg.r[REGRET] = n;
    
}
@

<<function [[syschdir]]>>=
void
syschdir(void)
{ 
    char file[1024];
    int n;
    ulong name;

    name = getmem_w(reg.r[REGSP]+4);
    memio(file, name, sizeof(file), MemReadstring);
    if(sysdbg)
        itrace("chdir(0x%lux='%s', 0x%lux)", name, file);
    
    n = chdir(file);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);

    reg.r[REGRET] = n;
}
@


\section{Namespace syscalls}


<<function [[sysbind]]>>=
void
sysbind(void)
{ 
    ulong pname, pold, flags;
    char name[1024], old[1024];
    int n;

    pname = getmem_w(reg.r[REGSP]+4);
    pold = getmem_w(reg.r[REGSP]+8);
    flags = getmem_w(reg.r[REGSP]+12);
    memio(name, pname, sizeof(name), MemReadstring);
    memio(old, pold, sizeof(old), MemReadstring);
    if(sysdbg)
        itrace("bind(0x%lux='%s', 0x%lux='%s', 0x%lux)", name, name, old, old, flags);

    n = bind(name, old, flags);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);

    reg.r[REGRET] = n;
}
@

\section{Misc syscalls}

<<function [[sysdup]]>>=
void
sysdup(void)
{
    int oldfd, newfd;
    int n;

    oldfd = getmem_w(reg.r[REGSP]+4);
    newfd = getmem_w(reg.r[REGSP]+8);
    if(sysdbg)
        itrace("dup(%d, %d)", oldfd, newfd);

    n = dup(oldfd, newfd);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    reg.r[REGRET] = n;
}
@

<<constant [[OERRLEN]]>>=
#define	OERRLEN	64	/* compatibility; used in _stat etc. */
@

<<function [[sysexits]]>>=
void
sysexits(void)
{
    char buf[OERRLEN];
    ulong str;

    str = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("exits(0x%lux)", str);

    // single step to give opportunity to inspect before exit
    count = 1;
    if(str != 0) {
        memio(buf, str, sizeof buf, MemRead);
        Bprint(bout, "exits(%s)\n", buf);
    }
    else
        Bprint(bout, "exits(0)\n");
}
@


<<function [[syssleep]]>>=
void
syssleep(void)
{
    ulong len;
    int n;

    len = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("sleep(%d)", len);

    n = sleep(len);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);	

    reg.r[REGRET] = n;
}
@


<<function [[syspipe]]>>=
void
syspipe(void)
{
    int n, p[2];
    ulong fd;

    fd = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("pipe(%lux)", fd);

    n = pipe(p);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    else {
        putmem_w(fd, p[0]);
        putmem_w(fd+4, p[1]);
    }
    reg.r[REGRET] = n;
}
@



% why global? could be local of sysnotify
<<global [[nofunc]]>>=
ulong	nofunc;
@

<<function [[sysnotify]]>>=
void
sysnotify(void)
{
    nofunc = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("notify(0x%lux)\n", nofunc);

    reg.r[REGRET] = 0;
}
@

\section{Unsupported syscalls}

% could also just have a generic undef_syscall
% so don't need all those duplicated code below

<<function [[sysrfork]]>>=
void
sysrfork(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[sysexec]]>>=
void
sysexec(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@


<<function [[sysawait]]>>=
void
sysawait(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@



<<function [[syswstat]]>>=
void
syswstat(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[sysfwstat]]>>=
void
sysfwstat(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@



<<function [[sysnoted]]>>=
void
sysnoted(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[syssegattach]]>>=
void
syssegattach(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[syssegdetach]]>>=
void
syssegdetach(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[syssegfree]]>>=
void
syssegfree(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[syssegflush]]>>=
void
syssegflush(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[syssegbrk]]>>=
void
syssegbrk(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@


<<function [[sysrendezvous]]>>=
void
sysrendezvous(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@


<<function [[sysmount]]>>=
void
sysmount(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[sysunmount]]>>=
void
sysunmount(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@


<<function [[sysalarm]]>>=
void
sysalarm(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[sysfauth]]>>=
void
sysfauth(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function [[sysfversion]]>>=
void
sysfversion(void)
{
    Bprint(bout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@




\chapter{Debugger}

\section{Overview}

% interface? special symbols prefix of command (: $ etc)
% then special char (c b), then sometimes some value arguments

<<[[cmd()]] locals>>=
static char *cmdlet = ":$?/=>"; //$
@
% special symbol for easy parsing, choose something not taken
% for symbols or digits


% buf: characters typed in debugger by user until \n
% lastcmd: if you type enter you repeat last command (so can do next and then
%  just enter, enter, etc)

<<[[cmd()]] locals>>=
char buf[128];
char addr[128];
@

<<[[cmd()]] locals>>=
char lastcmd[128];
@

<<[[cmd()]] locals>>=
char *a, *cp, *gotint;
int n, i;
@


<<[[cmd()]] read and parse command and address from user input>>=
p = buf;
n = 0;

for(;;) {
    i = Bgetc(bin);
    if(i < 0)
        exits(0);
    *p++ = i;
    n++;
    if(i == '\n')
        break;
}

if(buf[0] == '\n')
    strcpy(buf, lastcmd);
else {
    buf[n-1] = '\0';
    strcpy(lastcmd, buf);
}

p = buf;
a = addr;
for(;;) {
    p = nextc(p);
    if(*p == '\0' || strchr(cmdlet, *p))
        break;
    *a++ = *p++;
}
*a = '\0';

cmdcount = 1;
cp = strchr(addr, ',');
if(cp != nil) {
    if(cp[1] == '#')
        cmdcount = strtoul(cp+2, &gotint, 16);
    else
        cmdcount = strtoul(cp+1, &gotint, 0);
    *cp = '\0';
}
@

% skip spaces essentially and terminate string
<<function [[nextc]]>>=
char*
nextc(char *p)
{
    while(*p && (*p == ' ' || *p == '\t') && *p != '\n')
        p++;

    if(*p == '\n')
        *p = '\0';

    return p;
}
@





<<[[cmd()]] command cases>>=
case '$': //$
    dollar(p+1);
    break;
@
<<[[cmd()]] command cases>>=
case '/':
case '?':
    dot = expr(addr);
    for(i = 0; i < cmdcount; i++)
        quesie(p+1);
    break;
@
<<[[cmd()]] command cases>>=
case '=':
    eval(addr, p+1);
    break;
@
<<[[cmd()]] command cases>>=
case '>':
    setreg(addr, p+1);
    break;
@


\section{Interface}

<<global [[fmt]]>>=
char	fmt = 'X';
@

<<global [[width]]>>=
int	width = 60;
@

<<global [[inc]]>>=
int	inc;
@

<<function [[reset]]>>=
void
reset(void)
{
    int i, l, m;
    Segment *s;
    Breakpoint *b;

    memset(&reg, 0, sizeof(Registers));

    for(i = 0; i > Nseg; i++) {
        s = &memory.seg[i];
        l = ((s->end-s->base)/BY2PG)*sizeof(byte*);
        for(m = 0; m < l; m++)
            if(s->table[m])
                free(s->table[m]);
        free(s->table);
    }
    free(iprof);
    memset(&memory, 0, sizeof(memory));

    for(b = bplist; b; b = b->next)
        b->done = b->count;
}
@



<<function [[numsym]]>>=
char*
numsym(char *addr, ulong *val)
{
    char tsym[128], *t;
    static char *delim = "`'<>/\\@*|-~+-/=?\n";
    Symbol s;
    char c;

    t = tsym;
    while(c = *addr) {
        if(strchr(delim, c))
            break;
        *t++ = c;
        addr++;
    }
    t[0] = '\0';

    if(strcmp(tsym, ".") == 0) {
        *val = dot;
        return addr;
    }

    if(lookup(0, tsym, &s))
        *val = s.value;
    else {
        if(tsym[0] == '#')
            *val = strtoul(tsym+1, 0, 16);
        else
            *val = strtoul(tsym, 0, 0);
    }
    return addr;
}
@

<<function [[expr]]>>=
ulong
expr(char *addr)
{
    ulong t, t2;
    char op;

    if(*addr == '\0')
        return dot;

    addr = numsym(addr, &t);

    if(*addr == '\0')
        return t;

    addr = nextc(addr);
    op = *addr++;
    numsym(addr, &t2);
    switch(op) {
    default:
        Bprint(bout, "expr syntax\n");
        return 0;
    case '+':
        t += t2;
        break;
    case '-':
        t -= t2;
        break;
    case '%':
        t /= t2;
        break;
    case '&':
        t &= t2;
        break;
    case '|':
        t |= t2;
        break;
    }

    return t;
}
@

<<function [[buildargv]]>>=
int
buildargv(char *str, char **args, int max)
{
    int na = 0;

    while (na < max) {
        while((*str == ' ' || *str == '\t' || *str == '\n') && *str != '\0')
            str++;

        if(*str == '\0')
            return na;

        args[na++] = str;
        while(!(*str == ' ' || *str == '\t'|| *str == '\n') && *str != '\0')
            str++;

        if(*str == '\n')
            *str = '\0';

        if(*str == '\0')
            break;

        *str++ = '\0';
    }
    return na;
}
@

\subsection{Inspecting: [[$]]} %$
% to dump information

<<function [[dollar]]>>=
void
dollar(char *cp)
{
    cp = nextc(cp);

    switch(*cp) {
    case 'c':
        stktrace(*cp);
        break;

    case 'C':
        stktrace(*cp);
        break;
        
    case 'b':
        dobplist();
        break;

    case 'r':
        dumpreg();
        break;

    case 'R':
        dumpreg();

    case 'f':
        dumpfreg();
        break;

    case 'F':
        dumpdreg();
        break;

    case 'q':
        exits(0);
        break;

    case 'Q':
        isum();
        tlbsum();
        segsum();
        break;

    case 't':
        cp++;
        switch(*cp) {
        case '\0':
            trace = true;
            break;
        case '0':
            trace = false;
            sysdbg = false;
            calltree = false;
            break;
        case 's':
            sysdbg = true;
            break;
        case 'i':
            trace = true;
            break;
        <<[[dollar()]] t cases>>
        default:
            Bprint(bout, "$t[0sic]\n"); //$
            break;
        }
        break;

    case 'i':
        cp++;
        switch(*cp) {
        default:
            Bprint(bout, "$i[itsa]\n"); //$
            break;
        case 'i':
            isum();
            break;
        case 't':
            tlbsum();
            break;
        case 's':
            segsum();
            break;
        case 'a':
            isum();
            tlbsum();
            segsum();
            iprofile();
            break;
        case 'p':
            iprofile();
            break;
        }
    default:
        Bprint(bout, "?\n");
        break;

    }
}
@
% there was a bug I think in the string to help, it was :t[sic]
% instead of $t[sic]


\subsection{Controlling: [[:]]}
% to alter execution


<<[[colon()]] locals>>=
char tbuf[512];
@

<<[[colon()]] print current instruction>>=
symoff(tbuf, sizeof(tbuf), dot, CTEXT);
Bprint(bout, tbuf);
if(fmt == 'z')
    printsource(dot);
@





<<[[colon()]] command which return cases>>=
case 'b':
    breakpoint(addr, cp+1);
    return;
@
<<[[colon()]] command which return cases>>=
case 'd':
    delbpt(addr);
    return;
@


<<[[colon()]] locals>>=
int argc;
char *argv[100];
@

<<[[colon()]] command cases>>=
case 'r':
    reset();
    argc = buildargv(cp+1, argv, 100);
    initstk(argc, argv);
    count = 0;
    atbpt = false;
    run();
    break;
@

<<[[colon()]] command cases>>=
case 's':
    cp = nextc(cp+1);
    count = 0;
    if(*cp)
        count = strtoul(cp, 0, 0);
    if(count == 0)
        count = 1;
    atbpt = false;
    run();
    break;
@

\section{Format}

<<function [[pfmt]]>>=
int
pfmt(char fmt, int mem, ulong val)
{
    int c, i;
    Symbol s;
    char *p, ch, str[1024];

    c = 0;
    switch(fmt) {
    case 'o':
        c = Bprint(bout, "%-4lo ", mem? (ushort)getmem_2(dot): val);
        inc = 2;
        break;

    case 'O':
        c = Bprint(bout, "%-8lo ", mem? getmem_4(dot): val);
        inc = 4;
        break;

    case 'q':
        c = Bprint(bout, "%-4lo ", mem? (short)getmem_2(dot): val);
        inc = 2;
        break;

    case 'Q':
        c = Bprint(bout, "%-8lo ", mem? (long)getmem_4(dot): val);
        inc = 4;
        break;

    case 'd':
        c = Bprint(bout, "%-5ld ", mem? (short)getmem_2(dot): val);
        inc = 2;
        break;


    case 'D':
        c = Bprint(bout, "%-8ld ", mem? (long)getmem_4(dot): val);
        inc = 4;
        break;

    case 'x':
        c = Bprint(bout, "#%-4lux ", mem? (long)getmem_2(dot): val);
        inc = 2;
        break;

    case 'X':
        c = Bprint(bout, "#%-8lux ", mem? (long)getmem_4(dot): val);
        inc = 4;
        break;

    case 'u':
        c = Bprint(bout, "%-5ld ", mem? (ushort)getmem_2(dot): val);
        inc = 2;
        break;

    case 'U':
        c = Bprint(bout, "%-8ld ", mem? (ulong)getmem_4(dot): val);
        inc = 4;
        break;

    case 'b':
        c = Bprint(bout, "%-3ld ", mem? getmem_b(dot): val);
        inc = 1;
        break;

    case 'c':
        c = Bprint(bout, "%c ", (int)(mem? getmem_b(dot): val));
        inc = 1;
        break;

    case 'C':
        ch = mem? getmem_b(dot): val;
        if(isprint(ch))
            c = Bprint(bout, "%c ", ch);
        else
            c = Bprint(bout, "\\x%.2x ", ch);
        inc = 1;
        break;

    case 's':
        i = 0;
        while(ch = getmem_b(dot+i))
            str[i++] = ch;
        str[i] = '\0';
        dot += i;
        c = Bprint(bout, "%s", str);
        inc = 0;
        break;

    case 'S':
        i = 0;
        while(ch = getmem_b(dot+i))
            str[i++] = ch;
        str[i] = '\0';
        dot += i;
        for(p = str; *p; p++)
            if(isprint(*p))
                c += Bprint(bout, "%c", *p);
            else
                c += Bprint(bout, "\\x%.2ux", *p);
        inc = 0;
        break;

    case 'Y':
        p = ctime(mem? getmem_b(dot): val);
        p[30] = '\0';
        c = Bprint(bout, "%s", p);
        inc = 4;
        break;

    case 'a':
        symoff(str, sizeof(str), dot, CTEXT);
        c = Bprint(bout, str);
        inc = 0;
        break;

    case 'e':
        for(i = 0; globalsym(&s, i); i++)
            Bprint(bout, "%-15s #%lux\n", s.name,	getmem_4(s.value));
        inc = 0;
        break;

    case 'I':
    case 'i':
        inc = machdata->das(symmap, dot, fmt, str, sizeof(str));
        if(inc < 0) {
            Bprint(bout, "5i: %r\n");
            return 0;
        }
        c = Bprint(bout, "\t%s", str);
        break;

    case 'n':
        c = width+1;
        inc = 0;
        break;

    case '-':
        c = 0;
        inc = -1;
        break;

    case '+':
        c = 0;
        inc = 1;
        break;

    case '^':
        c = 0;
        if(inc > 0)
            inc = -inc;
        break;

    case 'z':
        if(findsym(dot, CTEXT, &s))
            Bprint(bout, "  %s() ", s.name);
        printsource(dot);
        inc = 0;
        break;

    default:
        Bprint(bout, "bad modifier\n");
        return 0;
    }
    return c;
}
@

<<function [[eval]]>>=
void
eval(char *addr, char *p)
{
    ulong val;

    val = expr(addr);
    p = nextc(p);
    if(*p == '\0') {
        p[0] = fmt;
        p[1] = '\0';
    }
    pfmt(*p, 0, val);
    Bprint(bout, "\n");
}
@

<<function [[quesie]]>>=
void
quesie(char *p)
{
    int c, count, i;
    char tbuf[512];

    c = 0;
    symoff(tbuf, sizeof(tbuf), dot, CTEXT);
    Bprint(bout, "%s?\t", tbuf);

    while(*p) {
        p = nextc(p);
        if(*p == '"') {
            for(p++; *p && *p != '"'; p++) {
                Bputc(bout, *p);
                c++;
            }
            if(*p)
                p++;
            continue;
        }
        count = 0;
        while(*p >= '0' && *p <= '9')
            count = count*10 + (*p++ - '0');
        if(count == 0)
            count = 1;
        p = nextc(p);
        if(*p == '\0') {
            p[0] = fmt;
            p[1] = '\0';
        }
        for(i = 0; i < count; i++) {
            c += pfmt(*p, 1, 0);
            dot += inc;
            if(c > width) {
                Bprint(bout, "\n");
                symoff(tbuf, sizeof(tbuf), dot, CTEXT);
                Bprint(bout, "%s?\t", tbuf);
                c = 0;
            }
        }
        fmt = *p++;
        p = nextc(p);
    }
    Bprint(bout, "\n");
}
@


<<function [[setreg]]>>=
void
setreg(char *addr, char *cp)
{
    int rn;

    dot = expr(addr);
    cp = nextc(cp);
    if(strcmp(cp, "pc") == 0) {
        reg.r[REGPC] = dot;
        return;
    }
    if(strcmp(cp, "sp") == 0) {
        reg.r[REGSP] = dot;
        return;
    }
    if(*cp++ == 'r') {
        rn = strtoul(cp, 0, 10);
        if(rn > 0 && rn < 16) {
            reg.r[rn] = dot;
            return;
        }
    }
    Bprint(bout, "bad register\n");
}
@




\section{Dumpers}

%\subsection{Registers}

<<function [[dumpreg]]>>=
void
dumpreg(void)
{
    int i;

    Bprint(bout, "PC  #%-8lux SP  #%-8lux \n",
                reg.r[REGPC], reg.r[REGSP]);

    for(i = 0; i < 16; i++) {
        if((i%4) == 0 && i != 0)
            Bprint(bout, "\n");
        Bprint(bout, "R%-2d #%-8lux ", i, reg.r[i]);
    }
    Bprint(bout, "\n");
}
@

<<function [[dumpfreg]]>>=
void
dumpfreg(void)
{
}
@

<<function [[dumpdreg]]>>=
void
dumpdreg(void)
{
}
@

%\subsection{Strack trace}

\section{Traces}

%$t[0sic]

\subsection{Syscalls trace}

% strace like
<<global [[sysdbg]]>>=
bool sysdbg;
@

<<[[sysnop]] strace>>=
if(sysdbg)
    itrace("nop()");
@

% and then use itrace() in each sys_xxx
 
\subsection{Stack trace}
% could be in dumpers section

<<constant [[STRINGSZ]]>>=
#define	STRINGSZ	128
@

<<function [[printsource]]>>=
/*
 *	print the value of dot as file:line
 */
void
printsource(long dot)
{
    char str[STRINGSZ];

    if (fileline(str, STRINGSZ, dot))
        Bprint(bout, "%s", str);
}
@

<<function [[printlocals]]>>=
void
printlocals(Symbol *fn, ulong fp)
{
    int i;
    Symbol s;

    s = *fn;
    for (i = 0; localsym(&s, i); i++) {
        if (s.class != CAUTO)
            continue;
        Bprint(bout, "\t%s=#%lux\n", s.name, getmem_4(fp-s.value));
    }
}
@

<<function [[printparams]]>>=
void
printparams(Symbol *fn, ulong fp)
{
    int i;
    Symbol s;
    int first;

    fp += mach->szreg;			/* skip saved pc */
    s = *fn;
    for (first = i = 0; localsym(&s, i); i++) {
        if (s.class != CPARAM)
            continue;
        if (first++)
            Bprint(bout, ", ");
        Bprint(bout, "%s=#%lux", s.name, getmem_4(fp+s.value));
    }
    Bprint(bout, ") ");
}
@

<<constant [[STARTSYM]]>>=
#define STARTSYM	"_main"
@

<<constant [[FRAMENAME]]>>=
#define	FRAMENAME	".frame"
@

<<function [[stktrace]]>>=
void
stktrace(int modif)
{
    ulong pc, sp;
    Symbol s, f;
    int i;
    char buf[512];

    pc = reg.r[REGPC];
    sp = reg.r[REGSP];
    i = 0;
    while (findsym(pc, CTEXT, &s)) {
        if(strcmp(STARTSYM, s.name) == 0) {
            Bprint(bout, "%s() at #%llux\n", s.name, s.value);
            break;
        }
        if (pc == s.value)	/* at first instruction */
            f.value = 0;
        else if (findlocal(&s, FRAMENAME, &f) == 0)
            break;
        if (s.type == 'L' || s.type == 'l' || pc <= s.value+4)
            pc = reg.r[REGLINK];
        else pc = getmem_4(sp);
        sp += f.value;
        Bprint(bout, "%s(", s.name);
        printparams(&s, sp);
        printsource(s.value);
        Bprint(bout, " called from ");
        symoff(buf, sizeof(buf), pc-8, CTEXT);
        Bprint(bout, buf);
        printsource(pc-8);
        Bprint(bout, "\n");
        if(modif == 'C')
            printlocals(&s, sp);
        if(++i > 40){
            Bprint(bout, "(trace truncated)\n");
            break;
        }
    }
}
@


\subsection{Call tree trace}

<<global [[calltree]]>>=
bool calltree;
@

% $tc => trace calltree
<<[[dollar()]] t cases>>=
case 'c':
    calltree = true;
    break;
@

<<[[dpex()]] if calltree, when add operation>>=
if(calltree && rd == REGPC && o2 == 0) {
    Symbol s;

    findsym(o1 + o2, CTEXT, &s);
    Bprint(bout, "%8lux return to %lux %s r0=%lux\n",
                reg.r[REGPC], o1 + o2, s.name, reg.r[REGRET]);
}
@
% there is no RET operation?
% o2 == 0 so why the o1 + o2?? because that's the spirit of this opcode
% anyway, so just to be consistent?

% branch and link
<<[[Ibl()]] if calltree>>=
if(calltree) {
    findsym(v, CTEXT, &s);
    Bprint(bout, "%8lux %s(", reg.r[REGPC], s.name);
    printparams(&s, reg.r[REGSP]);
    Bprint(bout, "from ");
    printsource(reg.r[REGPC]);
    Bputc(bout, '\n');
}
@

\section{Breakpoints}

<<enum [[breakpoint_kind]]>>=
enum breakpoint_kind
{
    Instruction		= 1,

    Read		= 2,
    Write		= 4,
    Access		= Read|Write,

    Equal		= 4|8,
};
@

<<struct [[Breakpoint]]>>=
struct Breakpoint
{
    //enum<breakpoint_kind>
    int		type;		/* Instruction/Read/Access/Write/Equal */

    uintptr	addr;		/* Place at address */
    int		count;		/* To execute count times or value */
    int		done;		/* How many times passed through */

    // Extra
    <<[[Breakpoint]] extra fields>>
};
@


<<global [[bplist]]>>=
// list<Breakpoint> (next = Breakpoint.next)
Breakpoint *bplist;
@

<<[[Breakpoint]] extra fields>>=
Breakpoint*	next;		/* Link to next one */
@





<<global [[atbpt]]>>=
bool atbpt;
@
% when stopped somewhere because of a breakpoint (and not because
% stopped because of count when to 0 or other stuff)




% stdin:$b -> <>
<<function [[dobplist]]>>=
void
dobplist(void)
{
    Breakpoint *b;
    char buf[512];

    for(b = bplist; b; b = b->next) {
        switch(b->type) {
        case Instruction:
            Bprint(bout, "0x%lux,%d:b %d done, at ", b->addr, b->count, b->done);
            symoff(buf, sizeof(buf), b->addr, CTEXT);
            Bprint(bout, buf);
            break;

        case Access:
            Bprint(bout, "0x%lux,%d:ba %d done, at ", b->addr, b->count, b->done);
            symoff(buf, sizeof(buf), b->addr, CDATA);
            Bprint(bout, buf);
            break;

        case Read:
            Bprint(bout, "0x%lux,%d:br %d done, at ", b->addr, b->count, b->done);
            symoff(buf, sizeof(buf), b->addr, CDATA);
            Bprint(bout, buf);
            break;

        case Write:
            Bprint(bout, "0x%lux,%d:bw %d done, at ", b->addr, b->count, b->done);
            symoff(buf, sizeof(buf), b->addr, CDATA);
            Bprint(bout, buf);
            break;

        case Equal:
            Bprint(bout, "0x%lux,%d:be at ", b->addr, b->count);
            symoff(buf, sizeof(buf), b->addr, CDATA);
            Bprint(bout, buf);
            break;
        }
        Bprint(bout, "\n");
    }
}
@

<<function [[breakpoint]]>>=
void
breakpoint(char *addr, char *cp)
{
    Breakpoint *b;
    int type;

    cp = nextc(cp);
    type = Instruction;

    switch(*cp) {
    case 'r':
        membpt++;
        type = Read;
        break;
    case 'a':
        membpt++;
        type = Access;
        break;
    case 'w':
        membpt++;
        type = Write;
        break;
    case 'e':
        membpt++;
        type = Equal;
        break;
    }
    b = emalloc(sizeof(Breakpoint));
    b->addr = expr(addr);
    b->type = type;
    b->count = cmdcount;
    b->done = cmdcount;

    b->next = bplist;
    bplist = b;
}
@

<<function [[delbpt]]>>=
void
delbpt(char *addr)
{
    Breakpoint *b, **l;
    ulong baddr;

    baddr = expr(addr);
    l = &bplist;
    for(b = *l; b; b = b->next) {
        if(b->addr == baddr) {
            if(b->type != Instruction)
                membpt++;
            *l = b->next;
            free(b);
            return;
        }
        l = &b->next;	
    }

    Bprint(bout, "no breakpoint\n");
}
@

<<function [[brkchk]]>>=
void
brkchk(ulong addr, int type)
{
    Breakpoint *b;

    for(b = bplist; b; b = b->next) {
        if(b->addr == addr && (b->type&type)) {
            if(b->type == Equal && getmem_4(addr) == b->count) {
                count = 1;
                atbpt = true;
                return;
            }
            if(--b->done == 0) {
                b->done = b->count;
                count = 1;
                atbpt = true;
                return;
            }
        }
    }	
}
@



\subsection{Code breakpoint}

<<[[run()]] check for breakpoints>>=
if(bplist)
    brkchk(reg.r[REGPC], Instruction);
@

\subsection{Memory breakpoint}
% nice!

<<global [[membpt]]>>=
bool membpt;
@
% memory breakpoint (watchpoint?)
% who set it to false?? seems always ++

<<[[getmem_x()]] if membpt>>=
if(membpt)
    brkchk(addr, Read);
@

<<[[putmem_x()]] if membpt>>=
if(membpt)
    brkchk(addr, Write);
@

\chapter{Profiler}

<<[[Inst]] profiling fields>>=
// profiling info
int	count;
int	taken;
int	useddelay;
@

<<[[run()]] profile current instruction class>>=
// profiling
reg.ip->count++;
@

<<function [[Percent]]>>=
#define Percent(num, max)	((max)?((num)*100)/(max):0)
@

<<global [[iprof]]>>=
ulong *iprof;
@

<<constant [[PROFGRAN]]>>=
PROFGRAN	= 4,
@

<<[[initmemory()]] Text segment initilisation>>=
<<[[initmemory()]] iprof allocation>>
@

<<[[initmemory()]] iprof allocation>>=
iprof = emalloc(((s->end - s->base)/PROFGRAN)*sizeof(long));
@



<<global [[tables]]>>=
Inst *tables[] = { itab, 0 };
@




<<global [[cmdcount]]>>=
int cmdcount;
@

<<global [[nopcount]]>>=
int nopcount;
@


<<function [[isum]]>>=
void
isum(void)
{
    Inst *i;
    int total, mems, arith, branch;
    int useddelay, taken, syscall;
    int pct, j;

    total = 0;
    mems = 0;
    arith = 0;
    branch = 0;
    useddelay = 0;
    taken = 0;
    syscall = 0;

    /* Compute the total so we can have percentages */
    for(i = itab; i->func; i++)
        if(i->name && i->count)
            total += i->count;

    Bprint(bout, "\nInstruction summary.\n\n");

    for(j = 0; tables[j]; j++) {
        for(i = tables[j]; i->func; i++) {
            if(i->name) {
                /* This is gross */
                if(i->count == 0)
                    continue;
                pct = Percent(i->count, total);
                if(pct != 0)
                    Bprint(bout, "%-8ud %3d%% %s\n",
                        i->count, Percent(i->count,
                        total), i->name);
                else
                    Bprint(bout, "%-8ud      %s\n",
                        i->count, i->name);


                switch(i->type) {
                case Imem:
                    mems += i->count;
                    break;
                case Iarith:
                    arith += i->count;
                    break;
                case Ibranch:
                    branch += i->count;
                    taken += i->taken;
                    useddelay += i->useddelay;
                    break;
                case Isyscall:
                    syscall += i->count;
                    break;
                default:
                    fatal(false, "isum bad stype %d\n", i->type);
                }
        
            }
        }
    }

    Bprint(bout, "\n%-8ud      Memory cycles\n", mems+total);	
    Bprint(bout, "%-8ud %3d%% Instruction cycles\n",
            total, Percent(total, mems+total));
    Bprint(bout, "%-8ud %3d%% Data cycles\n\n",
            mems, Percent(mems, mems+total));	

    Bprint(bout, "%-8ud %3d%% Arithmetic\n",
            arith, Percent(arith, total));

    Bprint(bout, "%-8ud %3d%% System calls\n",
            syscall, Percent(syscall, total));

    Bprint(bout, "%-8ud %3d%% Branches\n",
            branch, Percent(branch, total));

    Bprint(bout, "   %-8ud %3d%% Branches taken\n",
            taken, Percent(taken, branch));

    Bprint(bout, "   %-8ud %3d%% Delay slots\n",
            useddelay, Percent(useddelay, branch));

    Bprint(bout, "   %-8ud %3d%% Unused delay slots\n", 
            branch-useddelay, Percent(branch-useddelay, branch));

    Bprint(bout, "%-8ud %3d%% Program total delay slots\n",
            nopcount, Percent(nopcount, total));
}
@

<<function [[tlbsum]]>>=
void
tlbsum(void)
{
    if(tlb.on == false)
        return;

    Bprint(bout, "\n\nTlb summary\n");

    Bprint(bout, "\n%-8d User entries\n", tlb.tlbsize);
    Bprint(bout, "%-8d Accesses\n", tlb.hit+tlb.miss);
    Bprint(bout, "%-8d Tlb hits\n", tlb.hit);
    Bprint(bout, "%-8d Tlb misses\n", tlb.miss);
    Bprint(bout, "%7d%% Hit rate\n", Percent(tlb.hit, tlb.hit+tlb.miss));
}
@

<<global [[stype]]>>=
char *stype[] = { "Stack", "Text", "Data", "Bss" };
@

% profiling
<<[[Segment]] profiling fields>>=
int	rss;
int	refs;
@


<<function [[segsum]]>>=
void
segsum(void)
{
    Segment *s;
    int i;

    Bprint(bout, "\n\nMemory Summary\n\n");
    Bprint(bout, "      Base     End      Resident References\n");
    for(i = 0; i < Nseg; i++) {
        s = &memory.seg[i];
        Bprint(bout, "%-5s %.8lux %.8lux %-8d %-8d\n",
                stype[i], s->base, s->end, s->rss*BY2PG, s->refs);
    }
}
@

<<struct [[Prof]]>>=
struct Prof
{
    Symbol	s;
    long	count;
};
@

<<global [[aprof]]>>=
// can't use prof, conflict with libc.h prof()
Prof	aprof[5000];
@

<<function [[profcmp]]>>=
int
profcmp(void *va, void *vb)
{
    Prof *a, *b;

    a = va;
    b = vb;
    return b->count - a->count;
}
@

<<function [[iprofile]]>>=
void
iprofile(void)
{
    Prof *p, *n;
    int i, b, e;
    ulong total;

    i = 0;
    p = aprof;
    if(textsym(&p->s, i) == 0)
        return;
    i++;
    for(;;) {
        n = p+1;
        if(textsym(&n->s, i) == 0)
            break;
        b = (p->s.value-textbase)/PROFGRAN;
        e = (n->s.value-textbase)/PROFGRAN;
        while(b < e)
            p->count += iprof[b++];
        i++;
        p = n;
    }

    qsort(prof, i, sizeof(Prof), profcmp);

    total = 0;
    for(b = 0; b < i; b++)
        total += aprof[b].count;

    Bprint(bout, "  cycles     %% symbol          file\n");
    for(b = 0; b < i; b++) {
        if(aprof[b].count == 0)
            continue;

        Bprint(bout, "%8ld %3ld.%ld %-15s ",
            aprof[b].count,
            100*aprof[b].count/total,
            (1000*aprof[b].count/total)%10,
            aprof[b].s.name);

        printsource(aprof[b].s.value);
        Bputc(bout, '\n');
    }
    memset(prof, 0, sizeof(Prof)*i);
}
@




\chapter{Advanced Topics}

% see also http://danluu.com/new-cpu-features/

\section{System instructions}

% MCR, MRC, see bcm/l.s

\section{Coprocessor instructions}

% coprocessor is a general term for things offloaded to something else?
% like interrupt controller is considered a coprocessor?

% STC, LDC (store coproc, load coproc)

% CDP

\section{Float instructions}

% see vi/ ? ARM has no float? it has maybe but 5i/ didn't
% handle it, there is some opcode at class 7 about coprocessor though.

%http://www.righto.com/2018/08/inside-die-of-intels-8087-coprocessor.html

%http://www.arm.com/products/processors/technologies/vector-floating-point.php

% float instr actually use coprocessor instructions

\section{Signals}

<<[[cmd()]] initialisation>>=
notify(catcher);
@

<<function [[catcher]]>>=
void
catcher(void *a, char *msg)
{
    static int hit = 0;

    hit++;
    if(hit > 5)
        exits(0);
    USED(a);
    if(strcmp(msg, "interrupt") != 0)
        noted(NDFLT);

    count = 1;
    print("5i\n");
    noted(NCONT);
}
@

\section{Optimisations}
% JIT? like in QEMU?

%\section{Other}
% atomic instructions
% transactional memory

\chapter{Conclusion}


% next book, assembler, linker, compiler.
% kernel too. Also debugger and profiler.


%real-world: ARMv8 now. See hennessy and patterson latest book.
% they switch to ARMv8 because simpler than ARMv7 (and v6).
% no conditional exec, big PC-relative branching, etc.
% ARMv8 manual is 5400 pages though ... but they restrict themselves
% to a subset (called LEGv8) which is small.



\appendix

\chapter{Debugging}
% the emulator itself, to debug it! debug the debugger!

<<global [[trace]]>>=
bool trace;
@
% in many places, if(trace) ...

<<function [[itrace]]>>=
void
itrace(char *fmt, ...)
{
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);

    Bprint(bout, "%8lux %.8lux %2d %s\n", 
                     reg.ar, reg.instr, reg.instr_opcode, buf);	
    Bflush(bout);
}
@
%note: didn't have the bflush at the end, but I think better to flush here


<<global [[shtype]]>>=
static	char*	shtype[4] =
{
    "<<",
    ">>",
    "->",
    "@>",
};
@

<<global [[cond]]>>=
static	char*	cond[16] =
{
    ".EQ",	".NE",	".HS",	".LO",
    ".MI",	".PL",	".VS",	".VC",
    ".HI",	".LS",	".GE",	".LT",
    ".GT",	".LE",	"",	".NO",
};
@


%\chapter{Profiling}
% the emulator itself, to optimize it!


\chapter{Error Management}

<<function [[fatal]]>>=
void
fatal(bool syserr, char *fmt, ...)
{
    char buf[ERRMAX], *s;
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);

    s = "5i: %s\n";
    if(syserr)
        s = "5i: %s: %r\n";
    fprint(STDERR, s, buf);
    exits(buf);
}
@

<<global [[errjmp]]>>=
jmp_buf errjmp;
@

<<[[cmd()]] initialisation>>=
setjmp(errjmp);
@

% run -> itab[...].func (itab[...].func = <>)
<<function [[undef]]>>=
void
undef(instruction inst)
{
    Bprint(bout, "undefined instruction trap pc #%lux inst %.8lux op %d\n",
        reg.r[REGPC], inst, reg.instr_opcode);
    longjmp(errjmp, 0);
}
@


\chapter{Utilities}

\section{Memory Management}

% e for error_malloc?
<<function [[emalloc]]>>=
void *
emalloc(ulong size)
{
    void *a;

    a = malloc(size);
    if(a == nil)
        fatal(false, "no memory");

    memset(a, 0, size); //!!
    return a;
}
@

<<function [[erealloc]]>>=
void *
erealloc(void *a, ulong oldsize, ulong size)
{
    void *n;

    n = malloc(size);
    if(n == nil)
        fatal(false, "no memory");
    memset(n, 0, size);
    if(size > oldsize)
        size = oldsize;
    memmove(n, a, size);
    return n;
}
@



\chapter{Extra Code}

#include "Machine_extra.nw"


%\chapter{Changelog}
%\label{sec:changelog}

\chapter*{Glossary}
\label{sec:glossary}
\addcontentsline{toc}{chapter}{Glossary}

\begin{verbatim}
RISC = Reduced Instruction Set Computer
CISC = Complex Instruction Set Computer
ARM  = Akorn Risc Machines
ISA  = Instruction Set Architecture
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%TODO: should index the instructions here,
% so someone reading assembler or linker book
% can quickly see the semantic of the operation
% but looking at its interpreter code.

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
