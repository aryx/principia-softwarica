\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - reorg itab, simplified armclass(), see more repetitions, more
%   logical order, less undef "classes", introduced class_kind enum

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand machine:

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - SEMI understand main(), LP split main, improve TOC
% - SEMI understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Plan9 ARM Simulator [[5i]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a simulator.
% aka emulator
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% present 5i, ARM simulator.
% multiple purpose: in the end hardware is a kind of software, so softwarica
% material (it's a kind of interpreter).
% understanding ISA is also useful for assembler/compiler/linker
% (especially since in plan9 the archi specific stuff is distributed
% in those 3 things). Here is a form of executable spec!

% why 5i vs vi? because ARM is alive! raspberry! all phones!
% (but better vi/? it had float)
% why 5i vs 8i? there is no 8i :) x86 too ugly! 
% (well it's not that bad actually according to 
% torvalds: http://yarchive.net/comp/linux/x86.html)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item spim
% but dead archi, and ARM mostly a MIPS
\item spocketnes
\item qemu
% big (but interesting opti that would be nice to port to 5i)
\end{itemize}

% harm? significantly shorter in haskell?

%http://stackoverflow.com/questions/448673/how-do-emulators-work-and-how-are-they-written/448689#448689

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Machine principles}

% principle = in hardware because? Well cos related to hardware, e.g.
% for devices (keyboard, mouse, screen, but also of course memory).
% Also for basic computation like arithmetic (how turing machine handle?),
% and conditional/jmp.
% in hardware also because in soft could be too slow
% and generic enough that in hardware make sense, e.g. floating point.

% memory access (load/store archi on ARM) (Imem)
% add/sub/mul in hardware! sometimes also div! (Iarith)
% branching (Ibranch)
% interrupt for external device (avoid attente active) (Isyscall)
% floating optional (Ifloat?)

% virtual memory hardware support (can be as simple as TLB and interrupt)
%  for memory isolation, and lots of other stuff
% debugging hardware support (by abusing virtual memory trap general
%  mechanism again)

% recently: 
% - vector computation (SIMD), graphics processing math
% - security hardware support?

% vs turing machine? add() in turing machine?

\section{Simulator principles}
% simulator vs emulator? emulator can cheat more?

% =~ interpreter.

\section{[[5i]] services}

% actually provides a debugger interface a la 'db'

% so 5i 5.out, then at prompt type   ":c"
% to continue (that is run the program)

% also good to do $t :c
% so have a trace with all the instructions

\section{Input binary executable}

% a.out header, and then ARM

% for a compiled helloworld.c, there are actually lots
% of instructions involved, print is complicated, _main vs main,
% and probably other stuff. Could be good to have a 
% simplified helloworld.s first where do very little.

\section{ARM}

%ARM ISA format

% see ARM wikipedia page!

% a few weird stuff:
%  - conditional execution format to compensate for lack of branch
%    prediction, see wikipedia euclid example
%  - no CALL/RET? do via ADD PC ? or MOV PC?

% lots of symetrics and repetitions, see instruction format section

\section{Code organization}

%arm.h: DS, forward decl (a dat.h + fns.h)

<<basic includes>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

#include "arm.h"
@

%utilities:
%utils.c:
%globals.c:

%hardware:
%mem.c:
%icache.c: instruction cache (nop)
%syscall.c: supported syscalls emulation (just proxy)

%debugger stuff:
%bpt.c: breakpoints
%symbols.c:
%cmd.c:
%stats.c:

%main stuff:
%run.c
%5i.c

\section{Architecture overview}

% Use libmach a bit: crackhdr(), symbol map.
% But archi is so simple that no need parsing: just read ulong (instruction)
% so 4 bytes from the file.
% Then decompose instruction and dispatch.

% I think some of the algo like dpex(), arm_class, really emulate
% the algorithm of the machine itself. The code is factorized.
% it's not just a giant switch for each opcode, things in the ARM
% are better structured, with some repetition.

% note that no deps to 5.out.h here, it's the final binary format,
% not the plan9 object ARM format.

%###############################################################################

\chapter{Core Data Structures}

\section{[[Inst]] and [[itab]]}

<<typedef instruction>>=
typedef ulong instruction;
@
% 4 bytes fixed-length instructions (easier)

<<enum ixxx>>=
enum ixxx
{
    Iarith,
    Imem,
    Ibranch,
    Isyscall,
};
@
% big categories (for profiler)

% rename?
<<struct Inst>>=
struct Inst
{
    void 	(*func)(instruction);
    char*	name;
    // enum<ixxx>
    int	type;

    <<[[Inst]] profiling fields>>
};
@
% mini instruction interpreter, big categories, "sub-interpreter"?

% similarity with 5.out.h enum<opcode_kind>
% TODO? LP split where keep only Imul?
<<global itab>>=
Inst itab[] =
{
  <<[[itab]] elements>>
  { 0 }
};
@

%ex: [64] =  { Imul,	"MUL",	Iarith },

\section{[[Registers]] and [[reg]]}

% 16 registers, R0 to R15, with some are special, e.g. PC = R15
% R0 is kinda like the equivalent of AX on x86

<<enum regxxx>>=
enum
{
    REGARG	= 0,
    REGRET	= 0,
    REGPC	= 15,
    REGLINK	= 14,
    REGSP	= 13,
};
@
% so do reg.r[REGPC] to modify PC, see below
% also in 5.out.h

% could factorize with arm/ureg.h
<<struct Registers>>=
struct Registers
{
    long	r[16];
    <<[[Registers]] other fields>>
};
@

<<global reg>>=
Registers reg;
@







%XXX
<<[[Registers]] other fields>>=
int	cbit; // carry bit?
int	cout;
@


\section{[[Segment]] and [[memory]]}

% part OS emulation now, because when exec the kernel
% setup some memory segments
<<enum segment_kind>>=
enum segment_kind
{
    Stack,
    Text,
    Data,
    Bss,

    Nseg,
};
@

<<struct Segment>>=
struct Segment
{
    // enum<segment_kind>
    short	type;

    uintptr	base;
    uintptr	end;

    ulong	fileoff;
    ulong	fileend;

    byte**	table; // the data

    <<[[Segment]] profiling fields>>
};
@
% for Text and Data the content is actually in the disk binary, hence
% filexxx


<<struct Memory>>=
struct Memory
{
    //map<enum<segment_kind>, Segment>
    Segment	seg[Nseg];
};
@

<<global memory>>=
Memory memory;
@









\chapter{[[main()]]}

%input: file => fdt => biobuf bi => bin
%output: bp => bioout

<<global file>>=
char*	file = "5.out";
@

% fdt binary. Has to be a global? used in vaddr() for lazy Text access
<<global text>>=
fdt text;
@



<<global bxxx>>=
Biobuf	bi, bp;
@

<<global bioout>>=
Biobuf *bioout;
@
% point to bp

<<global bin>>=
Biobuf *bin;
@
% point to bi


<<function main>>=
//@Scheck: entry point!
void main(int argc, char **argv)
{

    argc--;
    argv++;

    bioout = &bp;
    bin = &bi;
    Binit(bioout, STDOUT, OWRITE);
    Binit(bin, STDIN, OREAD);

    tlb.on = true;
    tlb.tlbsize = 24;

    if(argc)
        file = argv[0];
    argc--;
    argv++;

    text = open(file, OREAD);
    if(text < 0)
        fatal(1, "open text '%s'", file);

    Bprint(bioout, "5i\n");

    inithdr(text);
    initmap();
    initstk(argc, argv);

    cmd();
}
@
%me: better do initmap() here instead of doing it in initstk()


% stuff from mach.h:
%  - mach
%  - machdata
%  - Fhdr!!
%  - Symbol!!
%  - Map!
%  - crackhdr()!! (will set global mach accordingly?)
%  - syminit()
%  - loadmap()

\section{[[inithdr()]]}

% from mach.h
% could mv as a local in main() instead of this global?
<<global fhdr>>=
Fhdr	fhdr;
@

<<global symmap>>=
Map *symmap;		
@

<<function inithdr>>=
void
inithdr(fdt fd)
{
    Symbol s;

    // from libmach.a
    extern Machdata armmach;

    seek(fd, 0, 0);
    if (!crackhdr(fd, &fhdr))
        fatal(0, "read text header");

    if(fhdr.type != FARM )
        fatal(0, "bad magic number: %d %d", fhdr.type, FARM);

    if (syminit(fd, &fhdr) < 0)
        fatal(0, "%r\n");

    symmap = loadmap(symmap, fd, &fhdr);

    if (mach->sbreg && lookup(0, mach->sbreg, &s))
        mach->sb = s.value;
    machdata = &armmach;
}
@
% need machdata = &armmach? what for?

\section{[[initmap()]]}

<<enum _anon_ (machine/5i/arm.h)7>>=
/* Plan9 Kernel constants */
enum
{
    BY2PG		= 4096,
    BY2WD		= 4,

    UTZERO		= 0x1000,
    STACKTOP	= 0x80000000,
    STACKSIZE	= 0x10000,

    <<constant PROFGRAN>>
    <<constant Sbit>>
    <<constant SIGNBIT>>
};
@
% >> >>

%dead:
%    FP_U		= 3,
%    FP_L		= 1,
%    FP_G		= 2,
%    FP_E		= 0,
%    FP_CBIT		= 1<<23,



<<global datasize>>=
int	datasize;
@
% who use that?

<<global textbase>>=
uintptr	textbase;
@
% who else use that?



% could pass fhdr as a parameter instead of using global
% could use ROUNDUP()
<<function initmap>>=
void
initmap(void)
{
    uintptr t, d, b, bssend;
    Segment *s;

    t = (fhdr.txtaddr+fhdr.txtsz+(BY2PG-1)) & ~(BY2PG-1);
    d = (t + fhdr.datsz + (BY2PG-1)) & ~(BY2PG-1);
    bssend = t + fhdr.datsz + fhdr.bsssz;
    b = (bssend + (BY2PG-1)) & ~(BY2PG-1);

    s = &memory.seg[Text];
    s->type = Text;
    s->base = fhdr.txtaddr - fhdr.hdrsz;
    s->end = t;
    s->fileoff = fhdr.txtoff - fhdr.hdrsz;
    s->fileend = s->fileoff + fhdr.txtsz;
    s->table = emalloc(((s->end - s->base)/BY2PG)*sizeof(byte*));
    textbase = s->base;

    <<[[initmap()]] iprof allocation>>

    s = &memory.seg[Data];
    s->type = Data;
    s->base = t;
    s->end = t+(d-t);
    s->fileoff = fhdr.datoff;
    s->fileend = s->fileoff + fhdr.datsz;
    s->table = emalloc(((s->end - s->base)/BY2PG)*sizeof(byte*));
    datasize = fhdr.datsz;

    s = &memory.seg[Bss];
    s->type = Bss;
    s->base = d;
    s->end = d+(b-d);
    s->table = emalloc(((s->end - s->base)/BY2PG)*sizeof(byte*));

    s = &memory.seg[Stack];
    s->type = Stack;
    s->base = STACKTOP-STACKSIZE;
    s->end = STACKTOP;
    s->table = emalloc(((s->end - s->base)/BY2PG)*sizeof(byte*));

    reg.r[REGPC] = fhdr.entry;
}
@

\section{[[initstk()]]}

<<function initstk>>=
void
initstk(int argc, char *argv[])
{
    ulong size;
    ulong sp, ap, tos;
    int i;
    char *p;

    tos = STACKTOP - sizeof(Tos)*2;	/* we'll assume twice the host's is big enough */
    sp = tos;
    for (i = 0; i < sizeof(Tos)*2; i++)
        putmem_b(tos + i, 0);

    /*
     * pid is second word from end of tos and needs to be set for nsec().
     * we know arm is a 32-bit cpu, so we'll assume knowledge of the Tos
     * struct for now, and use our pid.
     */
    putmem_w(tos + 4*4 + 2*sizeof(ulong) + 3*sizeof(uvlong), getpid());

    /* Build exec stack */
    size = strlen(file)+1+BY2WD+BY2WD+BY2WD;	
    for(i = 0; i < argc; i++)
        size += strlen(argv[i])+BY2WD+1;

    sp -= size;
    sp &= ~7;

    reg.r[0] = tos;
    reg.r[REGSP] = sp;
    reg.r[1] = STACKTOP-4;	/* Plan 9 profiling clock (why & why in R1?) */

    /* Push argc */
    putmem_w(sp, argc+1);
    sp += BY2WD;

    /* Compute sizeof(argv) and push argv[0] */
    ap = sp+((argc+1)*BY2WD)+BY2WD;
    putmem_w(sp, ap);
    sp += BY2WD;
    
    /* Build argv[0] string into stack */
    for(p = file; *p; p++)
        putmem_b(ap++, *p);

    putmem_b(ap++, '\0');

    /* Loop through pushing the arguments */
    for(i = 0; i < argc; i++) {
        putmem_w(sp, ap);
        sp += BY2WD;
        for(p = argv[i]; *p; p++)
            putmem_b(ap++, *p);
        putmem_b(ap++, '\0');
    }
    /* Null terminate argv */
    putmem_w(sp, 0);

}
@


\section{[[cmd()]]}

% pointer or actually the instruction? PC! dot = reg.r[REGPC]
<<global dot>>=
uintptr dot;
@

<<[[cmd()]] locals>>=
char *p;
@


% most of actual code is in debugger section
<<function cmd>>=
void
cmd(void)
{
    <<[[cmd()]] locals>>

    dot = reg.r[REGPC];

    <<[[cmd()]] initialisation>>

    for(;;) {
        Bflush(bioout);
        <<[[cmd()]] read and parse command and address from user input>>

        switch(*p) {
        <<[[cmd()]] command cases>>
        default:
            Bprint(bioout, "?\n");
            break;
        }
    }
}
@


<<[[cmd()]] command cases>>=
case ':':
    colon(addr, p+1);
    break;
@


% most of the code again is in debugger section
% here we will not use 'addr' at all.
% colon is for flow control, restart, continue, next, etc
<<function colon>>=
void
colon(char *addr, char *cp)
{
    <<[[colon()]] locals>>

    cp = nextc(cp);

    switch(*cp) {
    <<[[colon()]] command which return cases>>
    /* These fall through to print the stopped address */
    <<[[colon()]] command cases>>
    default:
        Bprint(bioout, "?\n");
        return;
    }

    dot = reg.r[REGPC];
    Bprint(bioout, "%s at #%lux ", atbpt? "breakpoint": "stopped", dot);

    <<[[colon()]] print current instruction>>
    Bprint(bioout, "\n");
}
@

<<[[colon()]] command cases>>=
case 'c':
    count = 0;
    atbpt = false;
    run();
    break;
@


\chapter{Instruction Interpreter}

\section{Instruction format}

% see refcard ARM, with color codes so can see repetitive patterns.

% 4 bytes fixed-length instructions (simple)
% - 4bits COND for everything (pink), see conditional execution section below
% - 3bits for opcode "class", and then more bits, variable length, 
%   a bit complex for more opcodes (orange and yellow), 
% - 4 bits registers, 0, 1, 2, 3, 4 times (Rn, Rd, Rs, Rm), so up to 16 bits,
%    or offsets (blue, green)
% - special config bits here and there (purple)

% ARM ISA has lots of symetries. lots of repetition.
% the code below extract this commonalities along different
% axes:
%  - operand styles (r/r/r  vs i/r/r vs ...) "addressing mode"
%     arm_class()
%  - arithmetic opcode (AND vs ADD vs OR ...)
%     dpex()
%  - shift
%     shift()
%  - S bit, etc
%     adhoc ifs


% old range:
% ARITH0: 0-15   16
% ARITH1: 17-31  16
% ARITH2: 32-47  16
% ARITH3: 48-63  16
% MUL:    64-65  2
% SWAP:   66-67  2
% MEM2:   68-71  4
% MEM1:   72-79  8
% BLOC:   80-81  2
% BRANCH: 82-83  2
% SYSCALL:84     1
% UNDEF:  85-87  3
% MULL:   88-91  4
% UNDEF:  92     1

% but remove intermediate UNDEF
% can move MULL closer to MUL

% new range:
% ARITH0: 0-15   16
% ARITH1: 16-31  16
% ARITH2: 32-47  16
% ARITH3: 48-63  16
% MUL:    64-65  2
% MULL:   66-69  4
% SWAP:   70-71  2
% MEM2:   72-75  4
% MEM1:   76-83  8
% BLOC:   84-85  2
% BRANCH: 86-87  2
% SYSCALL:88     1
% UNDEF:  89     1

<<enum class_kind>>=
enum class_kind {
    CARITH0 = 0,  // r,r,r
    CARITH1 = 16, // r<>r, r, r
    CARITH2 = 32, // r<>#, r, r
    CARITH3 = 48, // i,r,r
    CMUL    = 64,

    CSWAP   = 70,
    CMEM    = 72,
    CBLOC   = 84,

    CBRANCH = 86,
    CSYSCALL = 88,

    CUNDEF   = 89
};
@
% no DIV

\section{[[run()]]}

% often set to 0 and because of do while(--count) will actually go in
% negative value!. They should use MAX_INT instead of 0. cleaner.
<<global count>>=
int count;
@



% Those registers could be outside reg, in another DS; they
% are not visible registers. But maybe inside the processor
% there are those kinds of registers hidden, especially ir
% (but probably not ip). So maybe make sense to keep them in regs.
% (but maybe still better to rename them, intern_ar)
<<[[Registers]] other fields>>=
uintptr		ar;    // reg.r[REGPC]
instruction	ir;    // ifetch(reg.ar)

int			class; // arm_class(reg.ir)
Inst*		ip;    // &itab[reg.class]
@
% used outside run()? could be locals then no?
%  - ip is used outside run() mostly for reg->ip.name
%    so could have a global instead like instr_name
%  - class is used in itrace(), and in undef
% rename opcode_ir, opcode_class, opcode_cond?


% main -> cmd -> colon -> <> -> armclass!!
<<function run>>=
void
run(void)
{
    bool execute;

    do {
        if(trace) Bflush(bioout);

        reg.ar = reg.r[REGPC];
        reg.ir = ifetch(reg.ar);

        reg.class = arm_class(reg.ir);
        reg.ip = &itab[reg.class];

        <<[[run()]] set reg.cond>>
        <<[[run()]] switch reg.compare_op to set execute>>

        if(execute) {
            <<[[run()]] profile current instruction class>>
            // !!the dispatch!!
            (*reg.ip->func)(reg.ir);

        }
        else
          if(trace) itrace("%s%s IGNORED",reg.ip->name, cond[reg.cond]);

        reg.r[REGPC] += 4; // simple archi with fixed-length instruction :)

        <<[[run()]] check for breakpoints>>
    } while(--count);
}
@
% what about jumps? always REGPC+=4? yes because if jmp then
% the interpreter actually does some -=4 to compensate back at many
% places (hmm a bit ugly)

% should switch to mips model with Iexec()?

% will describe conditional execution now.
% then ifetch() really read disk, seek binary, and get 4 bytes.
% will describe later. and the will describe arm_class().

\section{Conditional execution}
% see ARM wikipedia page
% trick to compensate for lack of branch prediction

<<[[Registers]] other fields>>=
// 4 bits, 16 possibilities
int	cond;
@
% rename opcode_cond?

<<[[run()]] set reg.cond>>=
reg.cond = (reg.ir>>28) & 0xf;
@
% so this is part of the opcode, the user program decides this

<<[[Registers]] other fields>>=
// enum<compare_op>
int	compare_op;
@
% this is part of the processor runtime, it is modified by the execution 
% set to zero originally? some instruction will set compare_op? CMP?


<<enum compare_op>>=
enum compare_op
{
    CCcmp, 
    CCtst,
    CCteq,
};
@


<<[[run()]] switch reg.compare_op to set execute>>=
switch(reg.compare_op) {
case CCcmp:
    execute = runcmp(); // use reg.cond
    break;
case CCteq:
    execute = runteq();
    break;
case CCtst:
    execute = runtst();
    break;
default:
    Bprint(bioout, "unimplemented compare operation %x\n",
        reg.compare_op);
    return;
}
@

% rename intern_cc1, intern_cc2?
<<[[Registers]] other fields>>=
long	cc1;
long	cc2;
@


<<function runcmp>>=
bool
runcmp(void)
{
    switch(reg.cond) {
    case 0x0:	/* eq */	return (reg.cc1 == reg.cc2);
    case 0x1:	/* ne */	return (reg.cc1 != reg.cc2);
    case 0x2:	/* hs */	return ((ulong)reg.cc1 >= (ulong)reg.cc2);
    case 0x3:	/* lo */	return ((ulong)reg.cc1 < (ulong)reg.cc2);
    case 0x4:	/* mi */	return (reg.cc1 - reg.cc2 < 0);
    case 0x5:	/* pl */	return (reg.cc1 - reg.cc2 >= 0);
    case 0x8:	/* hi */	return ((ulong)reg.cc1 > (ulong)reg.cc2);
    case 0x9:	/* ls */	return ((ulong)reg.cc1 <= (ulong)reg.cc2);
    case 0xa:	/* ge */	return (reg.cc1 >= reg.cc2);
    case 0xb:	/* lt */	return (reg.cc1 < reg.cc2);
    case 0xc:	/* gt */	return (reg.cc1 > reg.cc2);
    case 0xd:	/* le */	return (reg.cc1 <= reg.cc2);

    case 0xe:	/* al */	return true;
    case 0xf:	/* nv */	return false;
    default:
        Bprint(bioout, "unimplemented condition prefix %x (%ld %ld)\n",
            reg.cond, reg.cc1, reg.cc2);
        undef(reg.ir);
        return false;
    }
}
@

<<constant SIGNBIT>>=
SIGNBIT		= 0x80000000,
@

<<function runteq>>=
bool
runteq(void)
{
    long res = reg.cc1 ^ reg.cc2;

    switch(reg.cond) {
    case 0x0:	/* eq */	return res == 0;
    case 0x1:	/* ne */	return res != 0;
    case 0x4:	/* mi */	return (res & SIGNBIT) != 0;
    case 0x5:	/* pl */	return (res & SIGNBIT) == 0;
    case 0xe:	/* al */	return true;
    case 0xf:	/* nv */	return false;
    default:
        Bprint(bioout, "unimplemented condition prefix %x (%ld %ld)\n",
            reg.cond, reg.cc1, reg.cc2);
        undef(reg.ir);
        return false;
    }
}
@

<<function runtst>>=
bool
runtst(void)
{
    long res = reg.cc1 & reg.cc2;

    switch(reg.cond) {
    case 0x0:	/* eq */	return res == 0;
    case 0x1:	/* ne */	return res != 0;
    case 0x4:	/* mi */	return (res & SIGNBIT) != 0;
    case 0x5:	/* pl */	return (res & SIGNBIT) == 0;
    case 0xe:	/* al */	return true;
    case 0xf:	/* nv */	return false;
    default:
        Bprint(bioout, "unimplemented condition prefix %x (%ld %ld)\n",
            reg.cond, reg.cc1, reg.cc2);
        undef(reg.ir);
        return false;
    }
}
@

\section{[[arm_class()]]}

% mostly for operand style big categories (r/r/r, i/r/r, etc)
% copy paste from libmach/5db.c, but simplified as don't need
% to handle debugging instructions or anything not handled in itab > 92
<<function arm_class>>=
int
arm_class(instruction w)
{
    int op;
   
    op = (w >> 25) & 0x7;
    switch(op) {
    <<[[arm_class()]] op cases>>
    default:	  
        op = CUNDEF;
        break;
    }
    return op;
}
@
% (48+24+4+4+2+2+4+4)
%case 6:	/* vfp load / store */ ; // go to default now

<<[[itab]] elements>>=
[CUNDEF] =  { undef,		"undef"  },
@











\section{Instructions simulation}

% always same pattern: extract components from opcode (e.g.
% special opcode for special register in instruction), shift, and,
% and then perform operation on registers, memory, or internal registers.

\subsection{Arithmetic}

<<[[arm_class()]] op cases>>=
case 0:	/* data processing r,r,r */
    op = ((w >> 4) & 0xf);
    <<[[arm_class()]] class 0, if op is 0x9>>
    <<[[arm_class()]] class 0, if op has 0x9 bits>>
   
    op = (w >> 21) & 0xf;

    if(w & (1<<4))
      op += CARITH2;
    else
     if((w & (31<<7)) || (w & (1<<5)))
      op += CARITH1;
    // else op += CARITH0
    break;
@
% 31 << 7 means take all the bits from 7 to 11, the shift#
% >> >> >> >> >> >>



<<[[arm_class()]] class 0, if op is 0x9>>=
/* mul, swp, mull */
if(op == 0x9) {
    op = CMUL;
    <<[[arm_class()]] class 0, when op == 0x9, if 24 bit set>>
    if(w & (1<<23)) {	/* mullu */
        op = CMUL+2;
        if(w & (1<<22))	/* mull */
            op = CMUL+4;
    }
    if(w & (1<<21))
        op++;		/* mla */
    break;
}
@
% >> >> >>


%\subsection{Multiplication}

<<[[itab]] elements>>=
[CMUL+0] =  { Imul,		"MUL",	Iarith },
[CMUL+1] =  { Imula,	"MULA",	Iarith },	
[CMUL+2] =  { Imull,	"MULLU",	Iarith },
[CMUL+3] =  { Imull,	"MULALU",	Iarith },
[CMUL+4] =  { Imull,	"MULL",		Iarith  },
[CMUL+5] =  { Imull,	"MULAL",	Iarith  },
@

% pretty simple :)
<<function Imul>>=
void
Imul(instruction inst)
{
    int rs, rd, rm;

    rd = (inst>>16) & 0xf;
    rs = (inst>>8) & 0xf;
    rm = inst & 0xf;

    if(rd == REGPC || rs == REGPC || rm == REGPC || rd == rm)
        undef(inst);

    reg.r[rd] = reg.r[rm]*reg.r[rs];

    <<[[Imul()]] trace>>
}
@
% no need to r[REGPC]-=4 here, REGPC can not be rd, because
% does not make sense to jump to some code that is the result
% of a multiplication


\ifallcode
<<[[Imul()]] trace>>=
if(trace)
    itrace("%s%s\tR%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.cond], rs, rm, rd,
        reg.r[rd]);
@
\fi

% multiply and accumulate
<<function Imula>>=
void
Imula(instruction inst)
{
    int rs, rd, rm, rn;

    rd = (inst>>16) & 0xf;
    rn = (inst>>12) & 0xf;
    rs = (inst>>8) & 0xf;
    rm = inst & 0xf;

    if(rd == REGPC || rn == REGPC || rs == REGPC || rm == REGPC || rd == rm)
        undef(inst);

    reg.r[rd] = reg.r[rm]*reg.r[rs] + reg.r[rn];

    <<[[Imula()]] trace>>
}
@

\ifallcode
<<[[Imula()]] trace>>=
if(trace)
    itrace("%s%s\tR%d,R%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.cond], rs, rm, rn, rd,
        reg.r[rd]);
@
\fi



% less simple, signed long multiply?
<<function Imull>>=
void
Imull(instruction inst)
{
    vlong v;
    int rs, rd, rm, rn;

    rd = (inst>>16) & 0xf;
    rn = (inst>>12) & 0xf;
    rs = (inst>>8) & 0xf;
    rm = inst & 0xf;

    if(rd == REGPC || rn == REGPC || rs == REGPC || rm == REGPC
      || rd == rm || rn == rm || rd == rn
      )
        undef(inst);

    if(inst & (1<<22)){
        v = (vlong)reg.r[rm] * (vlong)reg.r[rs];
        if(inst & (1 << 21))
            v += reg.r[rn];
    }else{
        v = XCAST(reg.r[rm]) * XCAST(reg.r[rs]);
        if(inst & (1 << 21))
            v += (ulong)reg.r[rn];
    }
    reg.r[rd] = v >> 32;
    reg.r[rn] = v;

    <<[[Imull()]] trace>>
}
@
% >> >>

\ifallcode
<<[[Imull()]] trace>>=
if(trace)
    itrace("%s%s\tR%d,R%d,(R%d,R%d) =#%llx",
        reg.ip->name, cond[reg.cond], rs, rm, rn, rd,
        v);
@
\fi




%\subsection{}

<<[[itab]] elements>>=
//r,r,r
[CARITH0+ 0] =  { Idp0,		"AND",	Iarith },	
[CARITH0+ 1] =  { Idp0,		"EOR",	Iarith },	
[CARITH0+ 2] =  { Idp0,		"SUB",	Iarith },	
[CARITH0+ 3] =  { Idp0,		"RSB",	Iarith },	
[CARITH0+ 4] =  { Idp0,		"ADD",	Iarith },	
[CARITH0+ 5] =  { Idp0,		"ADC",	Iarith },	
[CARITH0+ 6] =  { Idp0,		"SBC",	Iarith },	
[CARITH0+ 7] =  { Idp0,		"RSC",	Iarith },	
[CARITH0+ 8] =  { Idp0,		"TST",	Iarith },	
[CARITH0+ 9] =  { Idp0,		"TEQ",	Iarith },	
[CARITH0+10] =  { Idp0,		"CMP",	Iarith },	
[CARITH0+11] =  { Idp0,		"CMN",	Iarith },	
[CARITH0+12] =  { Idp0,		"ORR",	Iarith },	
[CARITH0+13] =  { Idp0,		"MOV",	Iarith },	
[CARITH0+14] =  { Idp0,		"BIC",	Iarith },	
[CARITH0+15] =  { Idp0,		"MVN",	Iarith },	
@


% meh, dp? data processing? vague, everything is data processing
<<function Idp0>>=
/*
 * data processing instruction R,R,R
 */
void
Idp0(instruction inst)
{
    int rn, rd, rm;
    long o1, o2;

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    rm = inst & 0xf;

    o1 = reg.r[rn];
    if(rn == REGPC)
        o1 += 8;

    o2 = reg.r[rm];
    if(rm == REGPC)
        o2 += 8;

    dpex(inst, o1, o2, rd);

    <<[[Idp0()]] trace>>
    <<[[Idpx()]] compensate REGPC>>
}
@
% -4 because will be incremented back in run()

<<[[Idpx()]] compensate REGPC>>=
if(rd == REGPC)
    reg.r[rd] -= 4;
@

\ifallcode
<<[[Idp0()]] trace>>=
if(trace)
    itrace("%s%s\tR%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.cond],
        rm, rn, rd,
        reg.r[rd]);
@
\fi


<<[[itab]] elements>>=
[CARITH1+ 0] =  { Idp1,		"AND",	Iarith },	
[CARITH1+ 1] =  { Idp1,		"EOR",	Iarith },	
[CARITH1+ 2] =  { Idp1,		"SUB",	Iarith },	
[CARITH1+ 3] =  { Idp1,		"RSB",	Iarith },	
[CARITH1+ 4] =  { Idp1,		"ADD",	Iarith },	
[CARITH1+ 5] =  { Idp1,		"ADC",	Iarith },	
[CARITH1+ 6] =  { Idp1,		"SBC",	Iarith },	
[CARITH1+ 7] =  { Idp1,		"RSC",	Iarith },	
[CARITH1+ 8] =  { Idp1,		"TST",	Iarith },	
[CARITH1+ 9] =  { Idp1,		"TEQ",	Iarith },	
[CARITH1+10] =  { Idp1,		"CMP",	Iarith },	
[CARITH1+11] =  { Idp1,		"CMN",	Iarith },	
[CARITH1+12] =  { Idp1,		"ORR",	Iarith },	
[CARITH1+13] =  { Idp1,		"MOV",	Iarith },	
[CARITH1+14] =  { Idp1,		"BIC",	Iarith },	
[CARITH1+15] =  { Idp1,		"MVN",	Iarith },	
@

<<function Idp1>>=
/*
 * data processing instruction (R<>#),R,R
 */
void
Idp1(instruction inst)
{
    int rn, rd, rm, st, sc;
    long o1, o2;

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    rm = inst & 0xf;
    st = (inst>>5) & 0x3;
    sc = (inst>>7) & 0x1f;

    o1 = reg.r[rn];
    if(rn == REGPC)
        o1 += 8;

    o2 = reg.r[rm];
    if(rm == REGPC)
        o2 += 8;

    o2 = shift(o2, st, sc, false);

    dpex(inst, o1, o2, rd);

    <<[[Idp1()]] trace>>
    <<[[Idpx()]] compensate REGPC>>
}
@

<<[[Idp1()]] trace>>=
if(trace)
    itrace("%s%s\tR%d%s%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.cond], rm, shtype[st], sc, rn, rd,
        reg.r[rd]);
@


<<[[itab]] elements>>=
[CARITH2+ 0] =  { Idp2,		"AND",	Iarith },	
[CARITH2+ 1] =  { Idp2,		"EOR",	Iarith },	
[CARITH2+ 2] =  { Idp2,		"SUB",	Iarith },	
[CARITH2+ 3] =  { Idp2,		"RSB",	Iarith },	
[CARITH2+ 4] =  { Idp2,		"ADD",	Iarith },	
[CARITH2+ 5] =  { Idp2,		"ADC",	Iarith },	
[CARITH2+ 6] =  { Idp2,		"SBC",	Iarith },	
[CARITH2+ 7] =  { Idp2,		"RSC",	Iarith },	
[CARITH2+ 8] =  { Idp2,		"TST",	Iarith },	
[CARITH2+ 9] =  { Idp2,		"TEQ",	Iarith },	
[CARITH2+10] =  { Idp2,		"CMP",	Iarith },	
[CARITH2+11] =  { Idp2,		"CMN",	Iarith },	
[CARITH2+12] =  { Idp2,		"ORR",	Iarith },	
[CARITH2+13] =  { Idp2,		"MOV",	Iarith },	
[CARITH2+14] =  { Idp2,		"BIC",	Iarith },	
[CARITH2+15] =  { Idp2,		"MVN",	Iarith },	
@

<<function Idp2>>=
/*
 * data processing instruction (R<>R),R,R
 */
void
Idp2(instruction inst)
{
    int rn, rd, rm, rs, st;
    long o1, o2, o3;

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    rm = inst & 0xf;
    st = (inst>>5) & 0x3;
    rs = (inst>>8) & 0xf;

    o1 = reg.r[rn];
    if(rn == REGPC)
        o1 += 8;

    o2 = reg.r[rm];
    if(rm == REGPC)
        o2 += 8;

    o3 = reg.r[rs];
    if(rs == REGPC)
        o3 += 8;

    o2 = shift(o2, st, o3, true);

    dpex(inst, o1, o2, rd);

    <<[[Idp2()]] trace>>
    <<[[Idpx()]] compensate REGPC>>
}
@

\ifallcode
<<[[Idp2()]] trace>>=
if(trace)
    itrace("%s%s\tR%d%sR%d=%d,R%d,R%d =#%x",
        reg.ip->name, cond[reg.cond], rm, shtype[st], rs, o3, rn, rd,
        reg.r[rd]);
@
\fi



<<[[arm_class()]] op cases>>=
case 1:	/* data processing i,r,r */
 op = CARITH3 + ((w >> 21) & 0xf);
 break;
@
%48

<<[[itab]] elements>>=
//i,r,r
[CARITH3+ 0] =  { Idp3,		"AND",	Iarith },	
[CARITH3+ 1] =  { Idp3,		"EOR",	Iarith },	
[CARITH3+ 2] =  { Idp3,		"SUB",	Iarith },	
[CARITH3+ 3] =  { Idp3,		"RSB",	Iarith },	
[CARITH3+ 4] =  { Idp3,		"ADD",	Iarith },	
[CARITH3+ 5] =  { Idp3,		"ADC",	Iarith },	
[CARITH3+ 6] =  { Idp3,		"SBC",	Iarith },	
[CARITH3+ 7] =  { Idp3,		"RSC",	Iarith },	
[CARITH3+ 8] =  { Idp3,		"TST",	Iarith },	
[CARITH3+ 9] =  { Idp3,		"TEQ",	Iarith },	
[CARITH3+10] =  { Idp3,		"CMP",	Iarith },	
[CARITH3+11] =  { Idp3,		"CMN",	Iarith },	
[CARITH3+12] =  { Idp3,		"ORR",	Iarith },	
[CARITH3+13] =  { Idp3,		"MOV",	Iarith },	
[CARITH3+14] =  { Idp3,		"BIC",	Iarith },	
[CARITH3+15] =  { Idp3,		"MVN",	Iarith },	
@


<<function Idp3>>=
/*
 * data processing instruction #<>#,R,R
 */
void
Idp3(instruction inst)
{
    int rn, rd, sc;
    long o1, o2;

    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    o1 = reg.r[rn];
    if(rn == REGPC)
        o1 += 8;

    o2 = inst & 0xff;
    sc = (inst>>7) & 0x1e;
    o2 = (o2 >> sc) | (o2 << (32 - sc));

    dpex(inst, o1, o2, rd);

    <<[[Idp3()]] trace>>
    <<[[Idpx()]] compensate REGPC>>
}
@
% >>

\ifallcode
<<[[Idp3()]] trace>>=
if(trace)
    itrace("%s%s\t#%x,R%d,R%d =#%x",
        reg.ip->name, cond[reg.cond], o2, rn, rd,
        reg.r[rd]);
@
\fi



<<constant Sbit>>=
Sbit		= 1<<20,
@
% >>

% dpex?
<<function dpex>>=
void
dpex(instruction inst, long o1, long o2, int rd)
{
    bool cbit;

    cbit = false;

    switch((inst>>21) & 0xf) {
    case  0:	/* and */
        reg.r[rd] = o1 & o2;
        cbit = true;
        break;
    case  1:	/* eor */
        reg.r[rd] = o1 ^ o2;
        cbit = true;
        break;

    case  2:	/* sub */
        reg.r[rd] = o1 - o2;
        // Fallthrough
    case 10:	/* cmp */
        if(inst & Sbit) {
            reg.cc1 = o1;
            reg.cc2 = o2;
            reg.compare_op = CCcmp;
        }
        return;

    case  3:	/* rsb */
        reg.r[rd] = o2 - o1;
        if(inst & Sbit) {
            reg.cc1 = o2;
            reg.cc2 = o1;
            reg.compare_op = CCcmp;
        }
        return;
    case  4:	/* add */
        <<[[dpex()]] if calltree, when add operation>>
        reg.r[rd] = o1 + o2;
        if(inst & Sbit) {
            if((XCAST(o1) + XCAST(o2)) & (1LL << 32))
                reg.cbit = true;
            else
                reg.cbit = false;
            reg.cc1 = o2;
            reg.cc2 = -o1;
            reg.compare_op = CCcmp;
        }
        return;

    case  5:	/* adc */
    case  6:	/* sbc */
    case  7:	/* rsc */
        undef(inst);

    case  8:	/* tst */
        if(inst & Sbit) {
            reg.cc1 = o1;
            reg.cc2 = o2;
            reg.compare_op = CCtst;
        }
        return;
    case  9:	/* teq */
        if(inst & Sbit) { // not always true?
            reg.cc1 = o1;
            reg.cc2 = o2;
            reg.compare_op = CCteq;
        }
        return;
    case 11:	/* cmn */
        if(inst & Sbit) { // not always true?
            reg.cc1 = o1;
            reg.cc2 = -o2;
            reg.compare_op = CCcmp;
        }
        return;

    case 12:	/* orr */
        reg.r[rd] = o1 | o2;
        cbit = true;
        break;
    case 13:	/* mov */
        reg.r[rd] = o2;
        cbit = true;
        break;
    case 14:	/* bic */
        reg.r[rd] = o1 & ~o2;
        cbit = true;
        break;
    case 15:	/* mvn */
        reg.r[rd] = ~o2;
        cbit = true;
        break;
    }

    if(inst & Sbit) {
        if(cbit)
            reg.cbit = reg.cout;
        reg.cc1 = reg.r[rd];
        reg.cc2 = 0;
        reg.compare_op = CCcmp;
    }
}
@
% >>




% shift(rm, op, rs or #, true if rs)
<<function shift>>=
long
shift(long v, int st, int sc, bool isreg)
{
    if(sc == 0) {
        switch(st) {
        case 0:	/* logical left */
            reg.cout = reg.cbit;
            break;
        case 1:	/* logical right */
            reg.cout = (v >> 31) & 1;
            break;
        case 2:	/* arith right */
            reg.cout = reg.cbit;
            break;
        case 3:	/* rotate right */
            if(isreg) {
                reg.cout = reg.cbit;
            }
            else {
                reg.cout = v & 1;
                v = ((ulong)v >> 1) | (reg.cbit << 31);
            }
        }
    }
    else {
        switch(st) {
        case 0:	/* logical left */
            reg.cout = (v >> (32 - sc)) & 1;
            v = v << sc;
            break;
        case 1:	/* logical right */
            reg.cout = (v >> (sc - 1)) & 1;
            v = (ulong)v >> sc;
            break;
        case 2:	/* arith right */
            if(sc >= 32) {
                reg.cout = (v >> 31) & 1;
                if(reg.cout)
                    v = 0xFFFFFFFF;
                else
                    v = 0;
            }
            else {
                reg.cout = (v >> (sc - 1)) & 1;
                v = (long)v >> sc;
            }
            break;
        case 3:	/* rotate right */
            reg.cout = (v >> (sc - 1)) & 1;
            v = (v << (32-sc)) | ((ulong)v >> sc);
            break;
        }
    }
    return v;
}
@







\subsection{Memory}

<<[[arm_class()]] class 0, when op == 0x9, if 24 bit set>>=
if(w & (1<<24)) {
    op = CSWAP;
    if(w & (1<<22))
         op++;	/* swpb */
    break;
}
@
% >> >>

<<[[itab]] elements>>=
[CSWAP+0] =  { Iswap,		"SWPW",	Imem },
[CSWAP+1] =  { Iswap,		"SWPBU",Imem },
@

<<function Iswap>>=
void
Iswap(instruction inst)
{
    int rn, rd, rm;
    ulong address, value, bbit;

    bbit = inst & (1<<22);
    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;
    rm = (inst>>0) & 0xf;

    address = reg.r[rn];
    if(bbit) {
        value = getmem_b(address);
        putmem_b(address, reg.r[rm]);
    } else {
        value = getmem_w(address);
        putmem_w(address, reg.r[rm]);
    }
    reg.r[rd] = value;

    <<[[Iswap()]] trace>>
}
@

\ifallcode
<<[[Iswap()]] trace>>=
if(trace) {
    char *bw, *dotc;

    bw = "";
    if(bbit)
        bw = "B";
    dotc = cond[reg.cond];

    itrace("SWP%s%s\t#%x(R%d),R%d #%lux=#%x",
        bw, dotc,
        rn, rd,
        address, value);
}
@
\fi


<<[[arm_class()]] class 0, if op has 0x9 bits>>=
if((op & 0x9) == 0x9) {		/* ld/st byte/half s/u */
     op = CMEM + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
     break;
}
@


<<[[itab]] elements>>=
// load/store h/sb
[CMEM+0] =  { Imem2,		"MOV",	Imem },
[CMEM+1] =  { Imem2,		"MOV",	Imem },
[CMEM+2] =  { Imem2,		"MOV",	Imem },
[CMEM+3] =  { Imem2,		"MOV",	Imem },
@

<<function Imem2>>=
/*
 * load/store unsigned byte/half word
 */
void
Imem2(instruction inst)
{
    int rn, rd, off, rm;
    ulong address, value, pbit, ubit, hbit, sbit, wbit, lbit, bit22;

    pbit = inst & (1<<24);
    ubit = inst & (1<<23);
    bit22 = inst & (1<<22);
    wbit = inst & (1<<21);
    lbit = inst & (1<<20);
    sbit = inst & (1<<6);
    hbit = inst & (1<<5);
    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;

    SET(rm);
    if(bit22) {
        off = ((inst>>4) & 0xf0) | (inst & 0xf);
    } else {
        rm = inst & 0xf;
        off = reg.r[rm];
        if(rm == REGPC)
            off += 8;
    }
    if(!ubit)
        off = -off;
    if(rn == REGPC)
        off += 8;

    address = reg.r[rn];
    if(pbit)
        address += off;

    if(lbit) {
        if(hbit) {
            value = getmem_h(address);
            if(sbit && (value & 0x8000))
                value |= 0xffff0000;
        } else {
            value = getmem_b(address);
            if(value & 0x80)
                value |= 0xffffff00;
        }
        if(rd == REGPC)
            value -= 4;
        reg.r[rd] = value;
    } else {
        value = reg.r[rd];
        if(rd == REGPC)
            value -= 4;
        if(hbit) {
            putmem_h(address, value);
        } else {
            putmem_b(address, value);
        }
    }
    if(!(pbit && !wbit))
        reg.r[rn] += off;

    <<[[Imem2()]] trace>>
}
@
% >> >> >> >>

\ifallcode
<<[[Imem2()]] trace>>=
if(trace) {
    char *hb, *dotp, *dotc;

    hb = "B";
    if(hbit)
        hb = "H";
    dotp = "";
    if(!pbit)
        dotp = ".P";
    dotc = cond[reg.cond];

    if(lbit) {
        if(bit22)
            itrace("MOV%s%s%s\t#%x(R%d),R%d #%lux=#%x",
                hb, dotp, dotc,
                off, rn, rd,
                address, value);
        else
            itrace("MOV%s%s%s\t(R%d)(R%d),R%d  #%lux=#%x",
                hb, dotp, dotc,
                rm, rn, rd,
                address, value);
    } else {
        if(bit22)
            itrace("MOV%s%s%s\tR%d,#%x(R%d) #%lux=#%x",
                hb, dotp, dotc,
                rd, off, rn,
                address, value);
        else
            itrace("MOV%s%s%s\tR%d,(R%d)(R%d) #%lux=#%x",
                hb, dotp, dotc,
                rd, rm, rn,
                address, value);
    }
}
@
\fi



<<[[arm_class()]] op cases>>=
case 2:	/* load/store byte/word i(r) */
 op = CMEM+4 + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
 break;
@
%48+24




<<[[itab]] elements>>=
// load/store w/ub i,r
[CMEM+4+0] =  { Imem1,		"MOVW",	Imem },
[CMEM+4+1] =  { Imem1,		"MOVB",	Imem },
[CMEM+4+2] =  { Imem1,		"MOVW",	Imem },
[CMEM+4+3] =  { Imem1,		"MOVB",	Imem },
@

<<[[arm_class()]] op cases>>=
case 3:	/* load/store byte/word (r)(r) */
 op = CMEM+8 + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
 break;
@
%(48+24+4)

<<[[itab]] elements>>=
// load/store r,r
[CMEM+8+0] =  { Imem1,		"MOVW",	Imem },
[CMEM+8+1] =  { Imem1,		"MOVB",	Imem },
[CMEM+8+2] =  { Imem1,		"MOVW",	Imem },
[CMEM+8+3] =  { Imem1,		"MOVB",	Imem },
@

<<function Imem1>>=
/*
 * load/store word/byte
 */
void
Imem1(instruction inst)
{
    int rn, rd, off, rm, sc, st;
    ulong address, value, pbit, ubit, bbit, wbit, lbit, bit25;

    bit25 = inst & (1<<25);
    pbit = inst & (1<<24);
    ubit = inst & (1<<23);
    bbit = inst & (1<<22);
    wbit = inst & (1<<21);
    lbit = inst & (1<<20);
    rn = (inst>>16) & 0xf;
    rd = (inst>>12) & 0xf;

    SET(st);
    SET(sc);
    SET(rm);
    if(bit25) {
        rm = inst & 0xf;
        st = (inst>>5) & 0x3;
        sc = (inst>>7) & 0x1f;
        off = reg.r[rm];
        if(rm == REGPC)
            off += 8;
        off = shift(off, st, sc, false);
    } else {
        off = inst & 0xfff;
    }
    if(!ubit)
        off = -off;
    if(rn == REGPC)
        off += 8;

    address = reg.r[rn];
    if(pbit)
        address += off;

    if(lbit) {
        if(bbit)
            value = getmem_b(address);
        else
            value = getmem_w(address);
        if(rd == REGPC)
            value -= 4;
        reg.r[rd] = value;
    } else {
        value = reg.r[rd];
        if(rd == REGPC)
            value -= 4;
        if(bbit)
            putmem_b(address, value);
        else
            putmem_w(address, value);
    }
    if(!(pbit && !wbit))
        reg.r[rn] += off;

    <<[[Imem1()]] trace>>
}
@
% >> >> >>

\ifallcode
<<[[Imem1()]] trace>>=
if(trace) {
    char *bw, *dotp, *dotc;

    bw = "W";
    if(bbit)
        bw = "BU";
    dotp = "";
    if(!pbit)
        dotp = ".P";
    dotc = cond[reg.cond];

    if(lbit) {
        if(!bit25)
            itrace("MOV%s%s%s\t#%x(R%d),R%d #%lux=#%x",
                bw, dotp, dotc,
                off, rn, rd,
                address, value);
        else
            itrace("MOV%s%s%s\t(R%d%s%d)(R%d),R%d  #%lux=#%x",
                bw, dotp, dotc,
                rm, shtype[st], sc, rn, rd,
                address, value);
    } else {
        if(!bit25)
            itrace("MOV%s%s%s\tR%d,#%x(R%d) #%lux=#%x",
                bw, dotp, dotc,
                rd, off, rn,
                address, value);
        else
            itrace("MOV%s%s%s\tR%d,(R%d%s%d)(R%d) #%lux=#%x",
                bw, dotp, dotc,
                rd, rm, shtype[st], sc, rn,
                address, value);
    }
}
@
\fi




<<[[arm_class()]] op cases>>=
case 4:	/* block data transfer (r)(r) */
 op = CBLOC + ((w >> 20) & 0x1);
 break;
@
%48+24+4+4

<<[[itab]] elements>>=
// block move r,r
[CBLOC+0] =  { Ilsm,		"LDM",	Imem },
[CBLOC+1] =  { Ilsm,		"STM",	Imem },
@

<<function Ilsm>>=
void
Ilsm(instruction inst)
{
    char pbit, ubit, sbit, wbit, lbit;
    int i, rn, reglist;
    ulong address, predelta, postdelta;

    pbit = (inst>>24) & 0x1;
    ubit = (inst>>23) & 0x1;
    sbit = (inst>>22) & 0x1;
    wbit = (inst>>21) & 0x1;
    lbit = (inst>>20) & 0x1;
    rn =   (inst>>16) & 0xf;
    reglist = inst & 0xffff;

    if(reglist & 0x8000)
        undef(reg.ir);
    if(sbit)
        undef(reg.ir);

    address = reg.r[rn];

    if(pbit) {
        predelta = 4;
        postdelta = 0;
    } else {
        predelta = 0;
        postdelta = 4;
    }
    if(ubit) {
        for (i = 0; i < 16; ++i) {
            if(!(reglist & (1 << i)))
                continue;
            address += predelta;
            if(lbit)
                reg.r[i] = getmem_w(address);
            else
                putmem_w(address, reg.r[i]);
            address += postdelta;
        }
    } else {
        for (i = 15; 0 <= i; --i) {
            if(!(reglist & (1 << i)))
                continue;
            address -= predelta;
            if(lbit)
                reg.r[i] = getmem_w(address);
            else
                putmem_w(address, reg.r[i]);
            address -= postdelta;
        }
    }
    if(wbit) {
        reg.r[rn] = address;
    }

    <<[[Ilsm()]] trace>>
}
@
% >> >> 

\ifallcode
<<[[Ilsm()]] trace>>=
if(trace) {
    itrace("%s.%c%c\tR%d=%lux%s, <%lux>",
        (lbit ? "LDM" : "STM"), (ubit ? 'I' : 'D'), (pbit ? 'B' : 'A'),
        rn, reg.r[rn], (wbit ? "!" : ""), reglist);
}
@
\fi

\subsection{Branch}

<<[[arm_class()]] op cases>>=
case 5:	/* branch / branch link */
 op = CBRANCH + ((w >> 24) & 0x1);
 break;
@
%(48+24+4+4+2)

<<[[itab]] elements>>=
// branch
[CBRANCH+0] =  { Ib,	"B",	Ibranch },
[CBRANCH+1] =  { Ibl,	"BL",	Ibranch },
@

<<function Ib>>=
void
Ib(instruction inst)
{
    long v;

    v = inst & 0xffffff; // 24 bits
    v = reg.r[REGPC] + 8 + ((v << 8) >> 6);
    <<[[Ib()]] trace>>
    reg.r[REGPC] = v - 4;
}
@
% why +8?
% -4 to compensate back for +=4 in run()

% note that there is no conditional branch instruction like
% JNE, JEQ, etc, because B is using the generic conditional execution
% feature of ARM, so most branch will be like B.EQ and many of then
% will be IGNORED.

<<[[Ib()]] trace>>=
if(trace)
    itrace("B%s\t#%lux", cond[reg.cond], v);
@

<<function Ibl>>=
void
Ibl(instruction inst)
{
    long v;
    Symbol s;

    v = inst & 0xffffff;
    v = reg.r[REGPC] + 8 + ((v << 8) >> 6);
    <<[[Ibl()]] trace>>
    <<[[Ibl()]] if calltree>>
    reg.r[REGLINK] = reg.r[REGPC] + 4;
    reg.r[REGPC] = v - 4;
}
@
% Branch and Link, so kinda call, just for leaves, no need stack
% if want RET, just have to mov reglink, regpc

<<[[Ibl()]] trace>>=
if(trace)
    itrace("BL%s\t#%lux", cond[reg.cond], v);
@

\subsection{Syscall}
% see chapter

<<[[arm_class()]] op cases>>=
case 7:	/* coprocessor crap */ // and syscall
 if((w >> 25) & 0x1)
   op = CSYSCALL;
 else
   op = CUNDEF; // coprocessor stuff not handled
 break;
@
% op = (48+24+4+4+2+2) + ((w >> 3) & 0x2) + ((w >> 20) & 0x1);
% should assert bit 25 is 1

<<[[itab]] elements>>=
// co processor
[CSYSCALL] =  { Ssyscall,		"SWI",	Isyscall },
@

\chapter{Memory}

\section{[[vaddr()]] and the TLB}

<<function vaddr>>=
void*
vaddr(uintptr addr)
{
    Segment *s, *es;
    int off, foff, l, n;
    byte **p, *a;

    if(tlb.on)
        dotlb(addr);

    es = &memory.seg[Nseg];
    for(s = memory.seg; s < es; s++) {
        if(addr >= s->base && addr < s->end) {
            s->refs++;
            off = (addr-s->base)/BY2PG;
            p = &s->table[off];
            if(*p)
                return *p;

            s->rss++;

            switch(s->type) {
            case Text:
                *p = emalloc(BY2PG);
                if(seek(text, s->fileoff+(off*BY2PG), 0) < 0)
                    fatal(1, "vaddr text seek");
                if(read(text, *p, BY2PG) < 0)
                    fatal(1, "vaddr text read");
                return *p;
            case Data:
                *p = emalloc(BY2PG);
                foff = s->fileoff+(off*BY2PG);
                if(seek(text, foff, 0) < 0)
                    fatal(1, "vaddr text seek");
                n = read(text, *p, BY2PG);
                if(n < 0)
                    fatal(1, "vaddr text read");
                if(foff + n > s->fileend) {
                    l = BY2PG - (s->fileend-foff);
                    a = *p+(s->fileend-foff);
                    memset(a, 0, l);
                }
                return *p;
            case Bss:
            case Stack:
                *p = emalloc(BY2PG);
                return *p;
            default:
                fatal(0, "vaddr");
            }
        }
    }
    Bprint(bioout, "User TLB miss vaddr 0x%.8lux\n", addr);
    longjmp(errjmp, 0);
    return nil;		/*to stop compiler whining*/
}
@



<<struct Tlb>>=
struct Tlb
{
    bool	on;			/* Being updated */
    int		tlbsize;		/* Number of entries */
    uintptr	tlbent[Nmaxtlb];	/* Virtual address tags */

    int	hit;			/* Number of successful tag matches */
    int	miss;			/* Number of failed tag matches */
};		
@

<<constant Nmaxtlb>>=
#define Nmaxtlb 64
@

<<global tlb>>=
Tlb tlb;
@

<<function dotlb>>=
void
dotlb(uintptr vaddr)
{
    ulong *l, *e;

    vaddr &= ~(BY2PG-1);

    e = &tlb.tlbent[tlb.tlbsize];
    for(l = tlb.tlbent; l < e; l++)
        if(*l == vaddr) {
            tlb.hit++;
            return;
        }

    tlb.miss++;
    tlb.tlbent[lnrand(tlb.tlbsize)] = vaddr;
}
@


\section{[[ifetch()]] and the instruction cache}

<<function ifetch>>=
instruction
ifetch(uintptr addr)
{
    byte *va;

    if(addr&3) {
        Bprint(bioout, "Address error (I-fetch) vaddr %.8lux\n", addr);
        longjmp(errjmp, 0);
    }

    if(icache.on)
        updateicache(addr);
    iprof[(addr-textbase)/PROFGRAN]++;

    va = vaddr(addr);
    va += addr&(BY2PG-1);

    return va[3]<<24 | va[2]<<16 | va[1]<<8 | va[0];
}
@
% >> >> >>


<<struct Icache>>=
struct Icache
{
    bool	on;			/* Turned on */

    int	linesize;		/* Line size in bytes */
    int	stall;			/* Cache stalls */
    int*	lines;			/* Tag array */
    int*	(*hash)(ulong);		/* Hash function */
    char*	hashtext;		/* What the function looks like */
};
@

<<global icache>>=
Icache icache;
@

<<function updateicache>>=
void
updateicache(uintptr addr)
{
    USED(addr);
}
@


\section{[[getmem_xxx()]]}

<<function getmem_4>>=
ulong
getmem_4(uintptr addr)
{
    ulong val;
    int i;

    val = 0;
    for(i = 0; i < 4; i++)
        val = (val>>8) | (getmem_b(addr++)<<24);
    return val;
}
@
% >>

<<function getmem_2>>=
ulong
getmem_2(uintptr addr)
{
    ulong val;
    int i;

    val = 0;
    for(i = 0; i < 2; i++)
        val = (val>>8) | (getmem_b(addr++)<<16);
    return val;
}
@
% >>

<<function getmem_w>>=
ulong
getmem_w(uintptr addr)
{
    byte *va;
    ulong w;

    if(addr&3) {
        w = getmem_w(addr & ~3);
        while(addr & 3) {
            w = (w>>8) | (w<<24);
            addr--;
        }
        return w;
    }
    <<[[getmem_x()]] if membpt>>

    va = vaddr(addr);
    va += addr&(BY2PG-1);

    return va[3]<<24 | va[2]<<16 | va[1]<<8 | va[0];
}
@
% >> >> >> >>

<<function getmem_h>>=
ushort
getmem_h(uintptr addr)
{
    byte *va;
    ulong w;

    if(addr&1) {
        w = getmem_h(addr & ~1);
        while(addr & 1) {
            w = (w>>8) | (w<<8);
            addr--;
        }
        return w;
    }
    <<[[getmem_x()]] if membpt>>

    va = vaddr(addr);
    va += addr&(BY2PG-1);

    return va[1]<<8 | va[0];
}
@
% >> >>


<<function getmem_b>>=
byte
getmem_b(uintptr addr)
{
    byte *va;

    <<[[getmem_x()]] if membpt>>

    va = vaddr(addr);
    va += addr&(BY2PG-1);
    return va[0];
}
@

<<function getmem_v>>=
uvlong
getmem_v(uintptr addr)
{
    return ((uvlong)getmem_w(addr+4) << 32) | getmem_w(addr);
}
@
% >>

\section{[[putmem_xxx()]]}

<<function putmem_h>>=
void
putmem_h(uintptr addr, ushort data)
{
    byte *va;

    if(addr&1) {
        Bprint(bioout, "Address error (Store) vaddr %.8lux\n", addr);
        longjmp(errjmp, 0);
    }

    va = vaddr(addr);
    va += addr&(BY2PG-1);

    va[1] = data>>8;
    va[0] = data;

    <<[[putmem_x()]] if membpt>>
}
@
% >> >>

<<function putmem_w>>=
void
putmem_w(uintptr addr, ulong data)
{
    byte *va;

    if(addr&3) {
        Bprint(bioout, "Address error (Store) vaddr %.8lux\n", addr);
        longjmp(errjmp, 0);
    }

    va = vaddr(addr);
    va += addr&(BY2PG-1);

    va[3] = data>>24;
    va[2] = data>>16;
    va[1] = data>>8;
    va[0] = data;

    <<[[putmem_x()]] if membpt>>
}
@

<<function putmem_b>>=
void
putmem_b(uintptr addr, byte data)
{
    byte *va;

    va = vaddr(addr);
    va += addr&(BY2PG-1);
    va[0] = data;

    <<[[putmem_x()]] if membpt>>
}
@

<<function putmem_v>>=
void
putmem_v(uintptr addr, uvlong data)
{
    putmem_w(addr, data);	/* two stages, to catch brkchk */
    putmem_w(addr+4, data>>32);
}
@





\chapter{Syscalls}

<<constant OERRLEN>>=
#define	OERRLEN	64	/* compatibility; used in _stat etc. */
@

<<global errbuf>>=
char 	errbuf[ERRMAX];
@

<<global nofunc>>=
ulong	nofunc;
@

% #include "/sys/src/libc/9syscall/sys.h"

<<global sysctab>>=
char*	sysctab[] =
{
    [NOP]		"Running",
    [BIND]		"Bind",
    [CHDIR]		"Chdir",
    [CLOSE]		"Close",
    [DUP]		"Dup",
    [ALARM]		"Alarm",
    [EXEC]		"Exec",
    [EXITS]		"Exits",
    [FAUTH]		"Fauth",
    [SEGBRK]	"Segbrk",
    [MOUNT]		"Mount",
    [OPEN]		"Open",
    [SLEEP]		"Sleep",
    [RFORK]		"Rfork",
    [PIPE]		"Pipe",
    [CREATE]	"Create",
    [FD2PATH]	"Fd2path",
    [BRK]		"Brk",
    [REMOVE]	"Remove",
    [NOTIFY]	"Notify",
    [NOTED]		"Noted",
    [SEGATTACH]		"Segattach",
    [SEGDETACH]		"Segdetach",
    [SEGFREE]		"Segfree",
    [SEGFLUSH]		"Segflush",
    [RENDEZVOUS]	"Rendezvous",
    [UNMOUNT]		"Unmount",
    [SEEK]		"Seek",
    [FVERSION]	"Fversion",
    [ERRSTR]	"Errstr",
    [STAT]		"Stat",
    [FSTAT]		"Fstat",
    [WSTAT]		"Wstat",
    [FWSTAT]	"Fwstat",
    [PREAD]		"Pread",
    [PWRITE]	"Pwrite",
    [AWAIT]		"Await",
};
@


<<global systab>>=
void	(*systab[])(void) =
{
    [NOP]		sysnop,
    [BIND]		sysbind,
    [CHDIR]		syschdir,
    [CLOSE]		sysclose,
    [DUP]		sysdup,
    [ALARM]		sysalarm,
    [EXEC]		sysexec,
    [EXITS]		sysexits,
    [FAUTH]		sysfauth,
    [SEGBRK]	syssegbrk,
    [MOUNT]		sysmount,
    [OPEN]		sysopen,
    [SLEEP]		syssleep,
    [RFORK]		sysrfork,
    [PIPE]		syspipe,
    [CREATE]	syscreate,
    [FD2PATH]	sysfd2path,
    [BRK]		sysbrk,
    [REMOVE]	sysremove,
    [NOTIFY]	sysnotify,
    [NOTED]		sysnoted,
    [SEGATTACH]		syssegattach,
    [SEGDETACH]		syssegdetach,
    [SEGFREE]		syssegfree,
    [SEGFLUSH]		syssegflush,
    [RENDEZVOUS]	sysrendezvous,
    [UNMOUNT]		sysunmount,
    [SEEK]		sysseek,
    [FVERSION]	sysfversion,
    [ERRSTR]	syserrstr,
    [STAT]		sysstat,
    [FSTAT]		sysfstat,
    [WSTAT]		syswstat,
    [FWSTAT]	sysfwstat,
    [PREAD]		syspread,
    [PWRITE]	syspwrite,
    [AWAIT]		sysawait,
};
@

<<function Ssyscall>>=
void
Ssyscall(instruction _unused)
{
    int call;
    USED(_unused);

    call = reg.r[REGARG];
    if(call < 0 || call >= nelem(systab) || systab[call] == nil) {
        Bprint(bioout, "bad system call %d (%#ux)\n", call, call);
        dumpreg();
        Bflush(bioout);
        return;
    }

    if(trace)
        itrace("SWI\t%s", sysctab[call]);
    // dispatch!
    (*systab[call])();
    Bflush(bioout);
}
@

%\chapter{IO}
\section{[[memio()]]}
% to read/write array of bytes, with special handling for strings sometimes
% not sure why the function is called IO, should be mem_array

<<enum memxxx>>=
enum
{
    MemRead,
    MemReadstring,
    MemWrite,
};
@

% syserrstr | sysbind | sysfd2path | ... -> <>
<<function memio>>=
char *
memio(char *mb, uintptr mem, int size, int dir)
{
    int i;
    char *buf, c;

    if(mb == nil)
        mb = emalloc(size);

    buf = mb;
    switch(dir) {
    case MemRead:
        while(size--)
            *mb++ = getmem_b(mem++);
        break;
    case MemReadstring:
        for(;;) {
            if(size-- == 0) {
                Bprint(bioout, "memio: user/kernel copy too long for arm\n");
                longjmp(errjmp, 0);
            }
            c = getmem_b(mem++);
            *mb++ = c;
            if(c == '\0')
                break;
        }
        break;
    case MemWrite:
        for(i = 0; i < size; i++)
            putmem_b(mem++, *mb++);
        break;
    default:
        fatal(0, "memio");
    }
    return buf;
}
@

\section{Supported syscalls}

<<function sysnop>>=
void
sysnop(void)
{
    Bprint(bioout, "nop system call %s\n", sysctab[reg.r[1]]);
    <<[[sysnop]] strace>>
}
@
% used to have    exits(0);
% but sysnop used to be sysr1 but I changed that to nop, and nop
% should not exit

<<function syserrstr>>=
void
syserrstr(void)
{
    ulong str;
    int n;

    str = getmem_w(reg.r[REGSP]+4);
    n = getmem_w(reg.r[REGSP]+8);
    if(sysdbg)
        itrace("errstr(0x%lux, 0x%lux)", str, n);

    if(n > strlen(errbuf)+1)
        n = strlen(errbuf)+1;
    memio(errbuf, str, n, MemWrite);
    strcpy(errbuf, "no error");
    reg.r[REGRET] = n;
    
}
@

<<function sysbind>>=
void
sysbind(void)
{ 
    ulong pname, pold, flags;
    char name[1024], old[1024];
    int n;

    pname = getmem_w(reg.r[REGSP]+4);
    pold = getmem_w(reg.r[REGSP]+8);
    flags = getmem_w(reg.r[REGSP]+12);
    memio(name, pname, sizeof(name), MemReadstring);
    memio(old, pold, sizeof(old), MemReadstring);
    if(sysdbg)
        itrace("bind(0x%lux='%s', 0x%lux='%s', 0x%lux)", name, name, old, old, flags);

    n = bind(name, old, flags);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);

    reg.r[REGRET] = n;
}
@

<<function sysfd2path>>=
void
sysfd2path(void)
{
    int n;
    uint fd;
    ulong str;
    char buf[1024];

    fd = getmem_w(reg.r[REGSP]+4);
    str = getmem_w(reg.r[REGSP]+8);
    n = getmem_w(reg.r[REGSP]+12);
    if(sysdbg)
        itrace("fd2path(0x%lux, 0x%lux, 0x%lux)", fd, str, n);
    reg.r[1] = -1;
    if(n > sizeof buf){
        strcpy(errbuf, "buffer too big");
        return;
    }
    n = fd2path(fd, buf, sizeof buf);
    if(n < 0)
        errstr(buf, sizeof buf);
    else
        memio(errbuf, str, n, MemWrite);
    reg.r[REGRET] = n;
    
}
@

<<function syschdir>>=
void
syschdir(void)
{ 
    char file[1024];
    int n;
    ulong name;

    name = getmem_w(reg.r[REGSP]+4);
    memio(file, name, sizeof(file), MemReadstring);
    if(sysdbg)
        itrace("chdir(0x%lux='%s', 0x%lux)", name, file);
    
    n = chdir(file);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);

    reg.r[REGRET] = n;
}
@

<<function sysclose>>=
void
sysclose(void)
{
    int n;
    ulong fd;

    fd = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("close(%d)", fd);

    n = close(fd);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    reg.r[REGRET] = n;
}
@

<<function sysdup>>=
void
sysdup(void)
{
    int oldfd, newfd;
    int n;

    oldfd = getmem_w(reg.r[REGSP]+4);
    newfd = getmem_w(reg.r[REGSP]+8);
    if(sysdbg)
        itrace("dup(%d, %d)", oldfd, newfd);

    n = dup(oldfd, newfd);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    reg.r[REGRET] = n;
}
@

<<function sysexits>>=
void
sysexits(void)
{
    char buf[OERRLEN];
    ulong str;

    str = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("exits(0x%lux)", str);

    // single step to give opportunity to inspect before exit
    count = 1;
    if(str != 0) {
        memio(buf, str, sizeof buf, MemRead);
        Bprint(bioout, "exits(%s)\n", buf);
    }
    else
        Bprint(bioout, "exits(0)\n");
}
@

<<function sysopen>>=
void
sysopen(void)
{
    char file[1024];
    int n;
    ulong mode, name;

    name = getmem_w(reg.r[REGSP]+4);
    mode = getmem_w(reg.r[REGSP]+8);
    memio(file, name, sizeof(file), MemReadstring);
    
    n = open(file, mode);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);

    if(sysdbg)
        itrace("open(0x%lux='%s', 0x%lux) = %d", name, file, mode, n);

    reg.r[REGRET] = n;
};
@

<<function sysread>>=
void
sysread(vlong offset)
{
    int fd;
    ulong size, a;
    char *buf, *p;
    int n, cnt, c;

    fd = getmem_w(reg.r[REGSP]+4);
    a = getmem_w(reg.r[REGSP]+8);
    size = getmem_w(reg.r[REGSP]+12);

    buf = emalloc(size);
    if(fd == 0) {
        print("\nstdin>>");
        p = buf;
        n = 0;
        cnt = size;
        while(cnt) {
            c = Bgetc(bin);
            if(c <= 0)
                break;
            *p++ = c;
            n++;
            cnt--;
            if(c == '\n')
                break;
        }
    }
    else
        n = pread(fd, buf, size, offset);

    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    else
        memio(buf, a, n, MemWrite);

    if(sysdbg)
        itrace("read(%d, 0x%lux, %d, 0x%llx) = %d", fd, a, size, offset, n);

    free(buf);
    reg.r[REGRET] = n;
}
@

<<function syspread>>=
void
syspread(void)
{
    sysread(getmem_v(reg.r[REGSP]+16));
}
@

<<function sysseek>>=
void
sysseek(void)
{
    int fd;
    ulong mode;
    ulong retp;
    vlong v;

    retp = getmem_w(reg.r[REGSP]+4);
    fd = getmem_w(reg.r[REGSP]+8);
    v = getmem_v(reg.r[REGSP]+16);
    mode = getmem_w(reg.r[REGSP]+20);
    if(sysdbg)
        itrace("seek(%d, %lld, %d)", fd, v, mode);

    v = seek(fd, v, mode);
    if(v < 0)
        errstr(errbuf, sizeof errbuf);	

    putmem_v(retp, v);
}
@

<<function syssleep>>=
void
syssleep(void)
{
    ulong len;
    int n;

    len = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("sleep(%d)", len);

    n = sleep(len);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);	

    reg.r[REGRET] = n;
}
@

<<function sysstat>>=
void
sysstat(void)
{
    char nambuf[1024];
    byte buf[STATMAX];
    ulong edir, name;
    int n;

    name = getmem_w(reg.r[REGSP]+4);
    edir = getmem_w(reg.r[REGSP]+8);
    n = getmem_w(reg.r[REGSP]+12);
    memio(nambuf, name, sizeof(nambuf), MemReadstring);
    if(sysdbg)
        itrace("stat(0x%lux='%s', 0x%lux, 0x%lux)", name, nambuf, edir, n);
    if(n > sizeof buf)
        errstr(errbuf, sizeof errbuf);
    else{	
        n = stat(nambuf, buf, n);
        if(n < 0)
            errstr(errbuf, sizeof errbuf);
        else
            memio((char*)buf, edir, n, MemWrite);
    }
    reg.r[REGRET] = n;
}
@

<<function sysfstat>>=
void
sysfstat(void)
{
    byte buf[STATMAX];
    ulong edir;
    int n, fd;

    fd = getmem_w(reg.r[REGSP]+4);
    edir = getmem_w(reg.r[REGSP]+8);
    n = getmem_w(reg.r[REGSP]+12);
    if(sysdbg)
        itrace("fstat(%d, 0x%lux, 0x%lux)", fd, edir, n);

    reg.r[REGRET] = -1;
    if(n > sizeof buf){
        strcpy(errbuf, "stat buffer too big");
        return;
    }
    n = fstat(fd, buf, n);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    else
        memio((char*)buf, edir, n, MemWrite);
    reg.r[REGRET] = n;
}
@

<<function syswrite>>=
void
syswrite(vlong offset)
{
    int fd;
    ulong size, a;
    char *buf;
    int n;

    fd = getmem_w(reg.r[REGSP]+4);
    a = getmem_w(reg.r[REGSP]+8);
    size = getmem_w(reg.r[REGSP]+12);

    Bflush(bioout);
    buf = memio(0, a, size, MemRead);
    n = pwrite(fd, buf, size, offset);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);	

    if(sysdbg)
        itrace("write(%d, %lux, %d, 0x%llx) = %d", fd, a, size, offset, n);

    free(buf);

    reg.r[REGRET] = n;
}
@

<<function syspwrite>>=
void
syspwrite(void)
{
    syswrite(getmem_v(reg.r[REGSP]+16));
}
@

<<function syspipe>>=
void
syspipe(void)
{
    int n, p[2];
    ulong fd;

    fd = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("pipe(%lux)", fd);

    n = pipe(p);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    else {
        putmem_w(fd, p[0]);
        putmem_w(fd+4, p[1]);
    }
    reg.r[REGRET] = n;
}
@

<<function syscreate>>=
void
syscreate(void)
{
    char file[1024];
    int n;
    ulong mode, name, perm;

    name = getmem_w(reg.r[REGSP]+4);
    mode = getmem_w(reg.r[REGSP]+8);
    perm = getmem_w(reg.r[REGSP]+12);
    memio(file, name, sizeof(file), MemReadstring);
    if(sysdbg)
        itrace("create(0x%lux='%s', 0x%lux, 0x%lux)", name, file, mode, perm);
    
    n = create(file, mode, perm);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);

    reg.r[REGRET] = n;
}
@

<<function sysbrk>>=
void
sysbrk(void)
{
    ulong addr, osize, nsize;
    Segment *s;

    addr = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("brk(0x%lux)", addr);

    reg.r[REGRET] = -1;
    if(addr < memory.seg[Data].base+datasize) {
        strcpy(errbuf, "address below segment");
        return;
    }
    if(addr > memory.seg[Stack].base) {
        strcpy(errbuf, "segment too big");
        return;
    }
    s = &memory.seg[Bss];
    if(addr > s->end) {
        osize = ((s->end-s->base)/BY2PG)*sizeof(byte*);
        addr = ((addr)+(BY2PG-1))&~(BY2PG-1);
        s->end = addr;
        nsize = ((s->end-s->base)/BY2PG)*sizeof(byte*);
        s->table = erealloc(s->table, osize, nsize);
    }	

    reg.r[REGRET] = 0;	
}
@

<<function sysremove>>=
void
sysremove(void)
{
    char nambuf[1024];
    ulong name;
    int n;

    name = getmem_w(reg.r[REGSP]+4);
    memio(nambuf, name, sizeof(nambuf), MemReadstring);
    if(sysdbg)
        itrace("remove(0x%lux='%s')", name, nambuf);

    n = remove(nambuf);
    if(n < 0)
        errstr(errbuf, sizeof errbuf);
    reg.r[REGRET] = n;
}
@

<<function sysnotify>>=
void
sysnotify(void)
{
    nofunc = getmem_w(reg.r[REGSP]+4);
    if(sysdbg)
        itrace("notify(0x%lux)\n", nofunc);

    reg.r[REGRET] = 0;
}
@

\section{Unsupported syscalls}

% could also just have a generic undef_syscall
% so don't need all those duplicated code below

<<function sysrfork>>=
void
sysrfork(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function sysexec>>=
void
sysexec(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@



<<function sysawait>>=
void
sysawait(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@



<<function syswstat>>=
void
syswstat(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function sysfwstat>>=
void
sysfwstat(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@



<<function sysnoted>>=
void
sysnoted(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function syssegattach>>=
void
syssegattach(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function syssegdetach>>=
void
syssegdetach(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function syssegfree>>=
void
syssegfree(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function syssegflush>>=
void
syssegflush(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function syssegbrk>>=
void
syssegbrk(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@


<<function sysrendezvous>>=
void
sysrendezvous(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@


<<function sysmount>>=
void
sysmount(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function sysunmount>>=
void
sysunmount(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@


<<function sysalarm>>=
void
sysalarm(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function sysfauth>>=
void
sysfauth(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@

<<function sysfversion>>=
void
sysfversion(void)
{
    Bprint(bioout, "No system call %s\n", sysctab[reg.r[REGARG]]);
    exits(0);
}
@




\chapter{Debugger}

\section{Overview}

% interface? special symbols prefix of command (: $ etc)
% then special char (c b), then sometimes some value arguments

<<[[cmd()]] locals>>=
static char *cmdlet = ":$?/=>"; //$
@
% special symbol for easy parsing, choose something not taken
% for symbols or digits


% buf: characters typed in debugger by user until \n
% lastcmd: if you type enter you repeat last command (so can do next and then
%  just enter, enter, etc)

<<[[cmd()]] locals>>=
char buf[128];
char addr[128];
@

<<[[cmd()]] locals>>=
char lastcmd[128];
@

<<[[cmd()]] locals>>=
char *a, *cp, *gotint;
int n, i;
@


<<[[cmd()]] read and parse command and address from user input>>=
p = buf;
n = 0;

for(;;) {
    i = Bgetc(bin);
    if(i < 0)
        exits(0);
    *p++ = i;
    n++;
    if(i == '\n')
        break;
}

if(buf[0] == '\n')
    strcpy(buf, lastcmd);
else {
    buf[n-1] = '\0';
    strcpy(lastcmd, buf);
}

p = buf;
a = addr;
for(;;) {
    p = nextc(p);
    if(*p == '\0' || strchr(cmdlet, *p))
        break;
    *a++ = *p++;
}
*a = '\0';

cmdcount = 1;
cp = strchr(addr, ',');
if(cp != nil) {
    if(cp[1] == '#')
        cmdcount = strtoul(cp+2, &gotint, 16);
    else
        cmdcount = strtoul(cp+1, &gotint, 0);
    *cp = '\0';
}
@

% skip spaces essentially and terminate string
<<function nextc>>=
char*
nextc(char *p)
{
    while(*p && (*p == ' ' || *p == '\t') && *p != '\n')
        p++;

    if(*p == '\n')
        *p = '\0';

    return p;
}
@





<<[[cmd()]] command cases>>=
case '$': //$
    dollar(p+1);
    break;
@
<<[[cmd()]] command cases>>=
case '/':
case '?':
    dot = expr(addr);
    for(i = 0; i < cmdcount; i++)
        quesie(p+1);
    break;
@
<<[[cmd()]] command cases>>=
case '=':
    eval(addr, p+1);
    break;
@
<<[[cmd()]] command cases>>=
case '>':
    setreg(addr, p+1);
    break;
@


\section{Interface}

<<global fmt>>=
char	fmt = 'X';
@

<<global width>>=
int	width = 60;
@

<<global inc>>=
int	inc;
@

<<function reset>>=
void
reset(void)
{
    int i, l, m;
    Segment *s;
    Breakpoint *b;

    memset(&reg, 0, sizeof(Registers));

    for(i = 0; i > Nseg; i++) {
        s = &memory.seg[i];
        l = ((s->end-s->base)/BY2PG)*sizeof(byte*);
        for(m = 0; m < l; m++)
            if(s->table[m])
                free(s->table[m]);
        free(s->table);
    }
    free(iprof);
    memset(&memory, 0, sizeof(memory));

    for(b = bplist; b; b = b->next)
        b->done = b->count;
}
@



<<function numsym>>=
char*
numsym(char *addr, ulong *val)
{
    char tsym[128], *t;
    static char *delim = "`'<>/\\@*|-~+-/=?\n";
    Symbol s;
    char c;

    t = tsym;
    while(c = *addr) {
        if(strchr(delim, c))
            break;
        *t++ = c;
        addr++;
    }
    t[0] = '\0';

    if(strcmp(tsym, ".") == 0) {
        *val = dot;
        return addr;
    }

    if(lookup(0, tsym, &s))
        *val = s.value;
    else {
        if(tsym[0] == '#')
            *val = strtoul(tsym+1, 0, 16);
        else
            *val = strtoul(tsym, 0, 0);
    }
    return addr;
}
@

<<function expr>>=
ulong
expr(char *addr)
{
    ulong t, t2;
    char op;

    if(*addr == '\0')
        return dot;

    addr = numsym(addr, &t);

    if(*addr == '\0')
        return t;

    addr = nextc(addr);
    op = *addr++;
    numsym(addr, &t2);
    switch(op) {
    default:
        Bprint(bioout, "expr syntax\n");
        return 0;
    case '+':
        t += t2;
        break;
    case '-':
        t -= t2;
        break;
    case '%':
        t /= t2;
        break;
    case '&':
        t &= t2;
        break;
    case '|':
        t |= t2;
        break;
    }

    return t;
}
@

<<function buildargv>>=
int
buildargv(char *str, char **args, int max)
{
    int na = 0;

    while (na < max) {
        while((*str == ' ' || *str == '\t' || *str == '\n') && *str != '\0')
            str++;

        if(*str == '\0')
            return na;

        args[na++] = str;
        while(!(*str == ' ' || *str == '\t'|| *str == '\n') && *str != '\0')
            str++;

        if(*str == '\n')
            *str = '\0';

        if(*str == '\0')
            break;

        *str++ = '\0';
    }
    return na;
}
@

\subsection{[[$]]} %$

<<function dollar>>=
void
dollar(char *cp)
{
    cp = nextc(cp);

    switch(*cp) {
    case 'c':
        stktrace(*cp);
        break;

    case 'C':
        stktrace(*cp);
        break;
        
    case 'b':
        dobplist();
        break;

    case 'r':
        dumpreg();
        break;

    case 'R':
        dumpreg();

    case 'f':
        dumpfreg();
        break;

    case 'F':
        dumpdreg();
        break;

    case 'q':
        exits(0);
        break;

    case 'Q':
        isum();
        tlbsum();
        segsum();
        break;

    case 't':
        cp++;
        switch(*cp) {
        case '\0':
            trace = true;
            break;
        case '0':
            trace = false;
            sysdbg = false;
            calltree = false;
            break;
        case 's':
            sysdbg = true;
            break;
        case 'i':
            trace = true;
            break;
        <<[[dollar()]] t cases>>
        default:
            Bprint(bioout, "$t[0sic]\n"); //$
            break;
        }
        break;

    case 'i':
        cp++;
        switch(*cp) {
        default:
            Bprint(bioout, "$i[itsa]\n"); //$
            break;
        case 'i':
            isum();
            break;
        case 't':
            tlbsum();
            break;
        case 's':
            segsum();
            break;
        case 'a':
            isum();
            tlbsum();
            segsum();
            iprofile();
            break;
        case 'p':
            iprofile();
            break;
        }
    default:
        Bprint(bioout, "?\n");
        break;

    }
}
@
% there was a bug I think in the string to help, it was :t[sic]
% instead of $t[sic]


\subsection{[[:]]}


<<[[colon()]] locals>>=
char tbuf[512];
@

<<[[colon()]] print current instruction>>=
symoff(tbuf, sizeof(tbuf), dot, CTEXT);
Bprint(bioout, tbuf);
if(fmt == 'z')
    printsource(dot);
@





<<[[colon()]] command which return cases>>=
case 'b':
    breakpoint(addr, cp+1);
    return;
@
<<[[colon()]] command which return cases>>=
case 'd':
    delbpt(addr);
    return;
@


<<[[colon()]] locals>>=
int argc;
char *argv[100];
@

<<[[colon()]] command cases>>=
case 'r':
    reset();
    argc = buildargv(cp+1, argv, 100);
    initstk(argc, argv);
    count = 0;
    atbpt = false;
    run();
    break;
@

<<[[colon()]] command cases>>=
case 's':
    cp = nextc(cp+1);
    count = 0;
    if(*cp)
        count = strtoul(cp, 0, 0);
    if(count == 0)
        count = 1;
    atbpt = false;
    run();
    break;
@

\section{Format}

<<function pfmt>>=
int
pfmt(char fmt, int mem, ulong val)
{
    int c, i;
    Symbol s;
    char *p, ch, str[1024];

    c = 0;
    switch(fmt) {
    case 'o':
        c = Bprint(bioout, "%-4lo ", mem? (ushort)getmem_2(dot): val);
        inc = 2;
        break;

    case 'O':
        c = Bprint(bioout, "%-8lo ", mem? getmem_4(dot): val);
        inc = 4;
        break;

    case 'q':
        c = Bprint(bioout, "%-4lo ", mem? (short)getmem_2(dot): val);
        inc = 2;
        break;

    case 'Q':
        c = Bprint(bioout, "%-8lo ", mem? (long)getmem_4(dot): val);
        inc = 4;
        break;

    case 'd':
        c = Bprint(bioout, "%-5ld ", mem? (short)getmem_2(dot): val);
        inc = 2;
        break;


    case 'D':
        c = Bprint(bioout, "%-8ld ", mem? (long)getmem_4(dot): val);
        inc = 4;
        break;

    case 'x':
        c = Bprint(bioout, "#%-4lux ", mem? (long)getmem_2(dot): val);
        inc = 2;
        break;

    case 'X':
        c = Bprint(bioout, "#%-8lux ", mem? (long)getmem_4(dot): val);
        inc = 4;
        break;

    case 'u':
        c = Bprint(bioout, "%-5ld ", mem? (ushort)getmem_2(dot): val);
        inc = 2;
        break;

    case 'U':
        c = Bprint(bioout, "%-8ld ", mem? (ulong)getmem_4(dot): val);
        inc = 4;
        break;

    case 'b':
        c = Bprint(bioout, "%-3ld ", mem? getmem_b(dot): val);
        inc = 1;
        break;

    case 'c':
        c = Bprint(bioout, "%c ", (int)(mem? getmem_b(dot): val));
        inc = 1;
        break;

    case 'C':
        ch = mem? getmem_b(dot): val;
        if(isprint(ch))
            c = Bprint(bioout, "%c ", ch);
        else
            c = Bprint(bioout, "\\x%.2x ", ch);
        inc = 1;
        break;

    case 's':
        i = 0;
        while(ch = getmem_b(dot+i))
            str[i++] = ch;
        str[i] = '\0';
        dot += i;
        c = Bprint(bioout, "%s", str);
        inc = 0;
        break;

    case 'S':
        i = 0;
        while(ch = getmem_b(dot+i))
            str[i++] = ch;
        str[i] = '\0';
        dot += i;
        for(p = str; *p; p++)
            if(isprint(*p))
                c += Bprint(bioout, "%c", *p);
            else
                c += Bprint(bioout, "\\x%.2ux", *p);
        inc = 0;
        break;

    case 'Y':
        p = ctime(mem? getmem_b(dot): val);
        p[30] = '\0';
        c = Bprint(bioout, "%s", p);
        inc = 4;
        break;

    case 'a':
        symoff(str, sizeof(str), dot, CTEXT);
        c = Bprint(bioout, str);
        inc = 0;
        break;

    case 'e':
        for(i = 0; globalsym(&s, i); i++)
            Bprint(bioout, "%-15s #%lux\n", s.name,	getmem_4(s.value));
        inc = 0;
        break;

    case 'I':
    case 'i':
        inc = machdata->das(symmap, dot, fmt, str, sizeof(str));
        if(inc < 0) {
            Bprint(bioout, "5i: %r\n");
            return 0;
        }
        c = Bprint(bioout, "\t%s", str);
        break;

    case 'n':
        c = width+1;
        inc = 0;
        break;

    case '-':
        c = 0;
        inc = -1;
        break;

    case '+':
        c = 0;
        inc = 1;
        break;

    case '^':
        c = 0;
        if(inc > 0)
            inc = -inc;
        break;

    case 'z':
        if(findsym(dot, CTEXT, &s))
            Bprint(bioout, "  %s() ", s.name);
        printsource(dot);
        inc = 0;
        break;

    default:
        Bprint(bioout, "bad modifier\n");
        return 0;
    }
    return c;
}
@

<<function eval>>=
void
eval(char *addr, char *p)
{
    ulong val;

    val = expr(addr);
    p = nextc(p);
    if(*p == '\0') {
        p[0] = fmt;
        p[1] = '\0';
    }
    pfmt(*p, 0, val);
    Bprint(bioout, "\n");
}
@

<<function quesie>>=
void
quesie(char *p)
{
    int c, count, i;
    char tbuf[512];

    c = 0;
    symoff(tbuf, sizeof(tbuf), dot, CTEXT);
    Bprint(bioout, "%s?\t", tbuf);

    while(*p) {
        p = nextc(p);
        if(*p == '"') {
            for(p++; *p && *p != '"'; p++) {
                Bputc(bioout, *p);
                c++;
            }
            if(*p)
                p++;
            continue;
        }
        count = 0;
        while(*p >= '0' && *p <= '9')
            count = count*10 + (*p++ - '0');
        if(count == 0)
            count = 1;
        p = nextc(p);
        if(*p == '\0') {
            p[0] = fmt;
            p[1] = '\0';
        }
        for(i = 0; i < count; i++) {
            c += pfmt(*p, 1, 0);
            dot += inc;
            if(c > width) {
                Bprint(bioout, "\n");
                symoff(tbuf, sizeof(tbuf), dot, CTEXT);
                Bprint(bioout, "%s?\t", tbuf);
                c = 0;
            }
        }
        fmt = *p++;
        p = nextc(p);
    }
    Bprint(bioout, "\n");
}
@


<<function setreg>>=
void
setreg(char *addr, char *cp)
{
    int rn;

    dot = expr(addr);
    cp = nextc(cp);
    if(strcmp(cp, "pc") == 0) {
        reg.r[REGPC] = dot;
        return;
    }
    if(strcmp(cp, "sp") == 0) {
        reg.r[REGSP] = dot;
        return;
    }
    if(*cp++ == 'r') {
        rn = strtoul(cp, 0, 10);
        if(rn > 0 && rn < 16) {
            reg.r[rn] = dot;
            return;
        }
    }
    Bprint(bioout, "bad register\n");
}
@




\section{Dumpers}

%\subsection{Registers}

<<function dumpreg>>=
void
dumpreg(void)
{
    int i;

    Bprint(bioout, "PC  #%-8lux SP  #%-8lux \n",
                reg.r[REGPC], reg.r[REGSP]);

    for(i = 0; i < 16; i++) {
        if((i%4) == 0 && i != 0)
            Bprint(bioout, "\n");
        Bprint(bioout, "R%-2d #%-8lux ", i, reg.r[i]);
    }
    Bprint(bioout, "\n");
}
@

<<function dumpfreg>>=
void
dumpfreg(void)
{
}
@

<<function dumpdreg>>=
void
dumpdreg(void)
{
}
@

%\subsection{Strack trace}

\section{Traces}

%$t[0sic]

\subsection{Syscalls trace}

% strace like
<<global sysdbg>>=
bool sysdbg;
@

<<[[sysnop]] strace>>=
if(sysdbg)
    itrace("nop()");
@

% and then use itrace() in each sys_xxx
 
\subsection{Stack trace}
% could be in dumpers section

<<constant STRINGSZ>>=
#define	STRINGSZ	128
@

<<function printsource>>=
/*
 *	print the value of dot as file:line
 */
void
printsource(long dot)
{
    char str[STRINGSZ];

    if (fileline(str, STRINGSZ, dot))
        Bprint(bioout, "%s", str);
}
@

<<function printlocals>>=
void
printlocals(Symbol *fn, ulong fp)
{
    int i;
    Symbol s;

    s = *fn;
    for (i = 0; localsym(&s, i); i++) {
        if (s.class != CAUTO)
            continue;
        Bprint(bioout, "\t%s=#%lux\n", s.name, getmem_4(fp-s.value));
    }
}
@

<<function printparams>>=
void
printparams(Symbol *fn, ulong fp)
{
    int i;
    Symbol s;
    int first;

    fp += mach->szreg;			/* skip saved pc */
    s = *fn;
    for (first = i = 0; localsym(&s, i); i++) {
        if (s.class != CPARAM)
            continue;
        if (first++)
            Bprint(bioout, ", ");
        Bprint(bioout, "%s=#%lux", s.name, getmem_4(fp+s.value));
    }
    Bprint(bioout, ") ");
}
@

<<constant STARTSYM>>=
#define STARTSYM	"_main"
@

<<constant FRAMENAME>>=
#define	FRAMENAME	".frame"
@

<<function stktrace>>=
void
stktrace(int modif)
{
    ulong pc, sp;
    Symbol s, f;
    int i;
    char buf[512];

    pc = reg.r[REGPC];
    sp = reg.r[REGSP];
    i = 0;
    while (findsym(pc, CTEXT, &s)) {
        if(strcmp(STARTSYM, s.name) == 0) {
            Bprint(bioout, "%s() at #%llux\n", s.name, s.value);
            break;
        }
        if (pc == s.value)	/* at first instruction */
            f.value = 0;
        else if (findlocal(&s, FRAMENAME, &f) == 0)
            break;
        if (s.type == 'L' || s.type == 'l' || pc <= s.value+4)
            pc = reg.r[REGLINK];
        else pc = getmem_4(sp);
        sp += f.value;
        Bprint(bioout, "%s(", s.name);
        printparams(&s, sp);
        printsource(s.value);
        Bprint(bioout, " called from ");
        symoff(buf, sizeof(buf), pc-8, CTEXT);
        Bprint(bioout, buf);
        printsource(pc-8);
        Bprint(bioout, "\n");
        if(modif == 'C')
            printlocals(&s, sp);
        if(++i > 40){
            Bprint(bioout, "(trace truncated)\n");
            break;
        }
    }
}
@


\subsection{Call tree trace}

<<global calltree>>=
bool calltree;
@

% $tc => trace calltree
<<[[dollar()]] t cases>>=
case 'c':
    calltree = true;
    break;
@

<<[[dpex()]] if calltree, when add operation>>=
if(calltree && rd == REGPC && o2 == 0) {
    Symbol s;

    findsym(o1 + o2, CTEXT, &s);
    Bprint(bioout, "%8lux return to %lux %s r0=%lux\n",
                reg.r[REGPC], o1 + o2, s.name, reg.r[REGRET]);
}
@
% there is no RET operation?
% o2 == 0 so why the o1 + o2?? because that's the spirit of this opcode
% anyway, so just to be consistent

% branch and link
<<[[Ibl()]] if calltree>>=
if(calltree) {
    findsym(v, CTEXT, &s);
    Bprint(bioout, "%8lux %s(", reg.r[REGPC], s.name);
    printparams(&s, reg.r[REGSP]);
    Bprint(bioout, "from ");
    printsource(reg.r[REGPC]);
    Bputc(bioout, '\n');
}
@

\section{Breakpoints}

<<enum breakpoint_kind>>=
enum breakpoint_kind
{
    Instruction		= 1,

    Read		= 2,
    Write		= 4,
    Access		= Read|Write,

    Equal		= 4|8,
};
@

<<struct Breakpoint>>=
struct Breakpoint
{
    //enum<breakpoint_kind>
    int		type;		/* Instruction/Read/Access/Write/Equal */

    uintptr	addr;		/* Place at address */
    int		count;		/* To execute count times or value */
    int		done;		/* How many times passed through */

    // Extra
    <<[[Breakpoint]] extra fields>>
};
@


<<global bplist>>=
// list<Breakpoint> (next = Breakpoint.next)
Breakpoint *bplist;
@

<<[[Breakpoint]] extra fields>>=
Breakpoint*	next;		/* Link to next one */
@





<<global atbpt>>=
bool atbpt;
@
% when stopped somewhere because of a breakpoint (and not because
% stopped because of count when to 0 or other stuff)




% stdin:$b -> <>
<<function dobplist>>=
void
dobplist(void)
{
    Breakpoint *b;
    char buf[512];

    for(b = bplist; b; b = b->next) {
        switch(b->type) {
        case Instruction:
            Bprint(bioout, "0x%lux,%d:b %d done, at ", b->addr, b->count, b->done);
            symoff(buf, sizeof(buf), b->addr, CTEXT);
            Bprint(bioout, buf);
            break;

        case Access:
            Bprint(bioout, "0x%lux,%d:ba %d done, at ", b->addr, b->count, b->done);
            symoff(buf, sizeof(buf), b->addr, CDATA);
            Bprint(bioout, buf);
            break;

        case Read:
            Bprint(bioout, "0x%lux,%d:br %d done, at ", b->addr, b->count, b->done);
            symoff(buf, sizeof(buf), b->addr, CDATA);
            Bprint(bioout, buf);
            break;

        case Write:
            Bprint(bioout, "0x%lux,%d:bw %d done, at ", b->addr, b->count, b->done);
            symoff(buf, sizeof(buf), b->addr, CDATA);
            Bprint(bioout, buf);
            break;

        case Equal:
            Bprint(bioout, "0x%lux,%d:be at ", b->addr, b->count);
            symoff(buf, sizeof(buf), b->addr, CDATA);
            Bprint(bioout, buf);
            break;
        }
        Bprint(bioout, "\n");
    }
}
@

<<function breakpoint>>=
void
breakpoint(char *addr, char *cp)
{
    Breakpoint *b;
    int type;

    cp = nextc(cp);
    type = Instruction;

    switch(*cp) {
    case 'r':
        membpt++;
        type = Read;
        break;
    case 'a':
        membpt++;
        type = Access;
        break;
    case 'w':
        membpt++;
        type = Write;
        break;
    case 'e':
        membpt++;
        type = Equal;
        break;
    }
    b = emalloc(sizeof(Breakpoint));
    b->addr = expr(addr);
    b->type = type;
    b->count = cmdcount;
    b->done = cmdcount;

    b->next = bplist;
    bplist = b;
}
@

<<function delbpt>>=
void
delbpt(char *addr)
{
    Breakpoint *b, **l;
    ulong baddr;

    baddr = expr(addr);
    l = &bplist;
    for(b = *l; b; b = b->next) {
        if(b->addr == baddr) {
            if(b->type != Instruction)
                membpt++;
            *l = b->next;
            free(b);
            return;
        }
        l = &b->next;	
    }

    Bprint(bioout, "no breakpoint\n");
}
@

<<function brkchk>>=
void
brkchk(ulong addr, int type)
{
    Breakpoint *b;

    for(b = bplist; b; b = b->next) {
        if(b->addr == addr && (b->type&type)) {
            if(b->type == Equal && getmem_4(addr) == b->count) {
                count = 1;
                atbpt = true;
                return;
            }
            if(--b->done == 0) {
                b->done = b->count;
                count = 1;
                atbpt = true;
                return;
            }
        }
    }	
}
@



\subsection{Code breakpoint}

<<[[run()]] check for breakpoints>>=
if(bplist)
    brkchk(reg.r[REGPC], Instruction);
@

\subsection{Memory breakpoint}

<<global membpt>>=
bool membpt;
@
% memory breakpoint (watchpoint?)
% who set it to false?? seems always ++

<<[[getmem_x()]] if membpt>>=
if(membpt)
    brkchk(addr, Read);
@

<<[[putmem_x()]] if membpt>>=
if(membpt)
    brkchk(addr, Write);
@

\chapter{Profiler}

<<[[Inst]] profiling fields>>=
// profiling info
int	count;
int	taken;
int	useddelay;
@

<<[[run()]] profile current instruction class>>=
// profiling
reg.ip->count++;
@

<<function Percent>>=
#define Percent(num, max)	((max)?((num)*100)/(max):0)
@

<<global iprof>>=
ulong *iprof;
@

<<constant PROFGRAN>>=
PROFGRAN	= 4,
@

<<[[initmap()]] iprof allocation>>=
iprof = emalloc(((s->end - s->base)/PROFGRAN)*sizeof(long));
@



<<global tables>>=
Inst *tables[] = { itab, 0 };
@




<<global cmdcount>>=
int cmdcount;
@

<<global nopcount>>=
int nopcount;
@


<<function isum>>=
void
isum(void)
{
    Inst *i;
    int total, mems, arith, branch;
    int useddelay, taken, syscall;
    int pct, j;

    total = 0;
    mems = 0;
    arith = 0;
    branch = 0;
    useddelay = 0;
    taken = 0;
    syscall = 0;

    /* Compute the total so we can have percentages */
    for(i = itab; i->func; i++)
        if(i->name && i->count)
            total += i->count;

    Bprint(bioout, "\nInstruction summary.\n\n");

    for(j = 0; tables[j]; j++) {
        for(i = tables[j]; i->func; i++) {
            if(i->name) {
                /* This is gross */
                if(i->count == 0)
                    continue;
                pct = Percent(i->count, total);
                if(pct != 0)
                    Bprint(bioout, "%-8ud %3d%% %s\n",
                        i->count, Percent(i->count,
                        total), i->name);
                else
                    Bprint(bioout, "%-8ud      %s\n",
                        i->count, i->name);


                switch(i->type) {
                case Imem:
                    mems += i->count;
                    break;
                case Iarith:
                    arith += i->count;
                    break;
                case Ibranch:
                    branch += i->count;
                    taken += i->taken;
                    useddelay += i->useddelay;
                    break;
                case Isyscall:
                    syscall += i->count;
                    break;
                default:
                    fatal(0, "isum bad stype %d\n", i->type);
                }
        
            }
        }
    }

    Bprint(bioout, "\n%-8ud      Memory cycles\n", mems+total);	
    Bprint(bioout, "%-8ud %3d%% Instruction cycles\n",
            total, Percent(total, mems+total));
    Bprint(bioout, "%-8ud %3d%% Data cycles\n\n",
            mems, Percent(mems, mems+total));	

    Bprint(bioout, "%-8ud %3d%% Arithmetic\n",
            arith, Percent(arith, total));

    Bprint(bioout, "%-8ud %3d%% System calls\n",
            syscall, Percent(syscall, total));

    Bprint(bioout, "%-8ud %3d%% Branches\n",
            branch, Percent(branch, total));

    Bprint(bioout, "   %-8ud %3d%% Branches taken\n",
            taken, Percent(taken, branch));

    Bprint(bioout, "   %-8ud %3d%% Delay slots\n",
            useddelay, Percent(useddelay, branch));

    Bprint(bioout, "   %-8ud %3d%% Unused delay slots\n", 
            branch-useddelay, Percent(branch-useddelay, branch));

    Bprint(bioout, "%-8ud %3d%% Program total delay slots\n",
            nopcount, Percent(nopcount, total));
}
@

<<function tlbsum>>=
void
tlbsum(void)
{
    if(tlb.on == false)
        return;

    Bprint(bioout, "\n\nTlb summary\n");

    Bprint(bioout, "\n%-8d User entries\n", tlb.tlbsize);
    Bprint(bioout, "%-8d Accesses\n", tlb.hit+tlb.miss);
    Bprint(bioout, "%-8d Tlb hits\n", tlb.hit);
    Bprint(bioout, "%-8d Tlb misses\n", tlb.miss);
    Bprint(bioout, "%7d%% Hit rate\n", Percent(tlb.hit, tlb.hit+tlb.miss));
}
@

<<global stype>>=
char *stype[] = { "Stack", "Text", "Data", "Bss" };
@

% profiling
<<[[Segment]] profiling fields>>=
int	rss;
int	refs;
@


<<function segsum>>=
void
segsum(void)
{
    Segment *s;
    int i;

    Bprint(bioout, "\n\nMemory Summary\n\n");
    Bprint(bioout, "      Base     End      Resident References\n");
    for(i = 0; i < Nseg; i++) {
        s = &memory.seg[i];
        Bprint(bioout, "%-5s %.8lux %.8lux %-8d %-8d\n",
                stype[i], s->base, s->end, s->rss*BY2PG, s->refs);
    }
}
@

<<struct Prof>>=
struct Prof
{
    Symbol	s;
    long	count;
};
@

<<global aprof>>=
// can't use prof, conflict with libc.h prof()
Prof	aprof[5000];
@

<<function profcmp>>=
int
profcmp(void *va, void *vb)
{
    Prof *a, *b;

    a = va;
    b = vb;
    return b->count - a->count;
}
@

<<function iprofile>>=
void
iprofile(void)
{
    Prof *p, *n;
    int i, b, e;
    ulong total;

    i = 0;
    p = aprof;
    if(textsym(&p->s, i) == 0)
        return;
    i++;
    for(;;) {
        n = p+1;
        if(textsym(&n->s, i) == 0)
            break;
        b = (p->s.value-textbase)/PROFGRAN;
        e = (n->s.value-textbase)/PROFGRAN;
        while(b < e)
            p->count += iprof[b++];
        i++;
        p = n;
    }

    qsort(prof, i, sizeof(Prof), profcmp);

    total = 0;
    for(b = 0; b < i; b++)
        total += aprof[b].count;

    Bprint(bioout, "  cycles     %% symbol          file\n");
    for(b = 0; b < i; b++) {
        if(aprof[b].count == 0)
            continue;

        Bprint(bioout, "%8ld %3ld.%ld %-15s ",
            aprof[b].count,
            100*aprof[b].count/total,
            (1000*aprof[b].count/total)%10,
            aprof[b].s.name);

        printsource(aprof[b].s.value);
        Bputc(bioout, '\n');
    }
    memset(prof, 0, sizeof(Prof)*i);
}
@




\chapter{Advanced Topics}

\section{Signals}

<<[[cmd()]] initialisation>>=
notify(catcher);
@

<<function catcher>>=
void
catcher(void *a, char *msg)
{
    static int hit = 0;

    hit++;
    if(hit > 5)
        exits(0);
    USED(a);
    if(strcmp(msg, "interrupt") != 0)
        noted(NDFLT);

    count = 1;
    print("5i\n");
    noted(NCONT);
}
@

\section{Optimisations}
% JIT? like in QEMU?

\chapter{Conclusion}









\appendix

\chapter{Debugging}
% the emulator itself, to debug it! debug the debugger!

<<global trace>>=
bool trace;
@
% in many places, if(trace) ...

<<function itrace>>=
void
itrace(char *fmt, ...)
{
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(bioout, "%8lux %.8lux %2d %s\n", reg.ar, reg.ir, reg.class, buf);	
}
@


<<global shtype>>=
static	char*	shtype[4] =
{
    "<<",
    ">>",
    "->",
    "@>",
};
@

<<global cond>>=
static	char*	cond[16] =
{
    ".EQ",	".NE",	".HS",	".LO",
    ".MI",	".PL",	".VS",	".VC",
    ".HI",	".LS",	".GE",	".LT",
    ".GT",	".LE",	"",	".NO",
};
@


%\chapter{Profiling}
% the emulator itself, to optimize it!


\chapter{Error Managment}

<<function fatal>>=
void
fatal(bool syserr, char *fmt, ...)
{
    char buf[ERRMAX], *s;
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    s = "5i: %s\n";
    if(syserr)
        s = "5i: %s: %r\n";
    fprint(STDERR, s, buf);
    exits(buf);
}
@

<<global errjmp>>=
jmp_buf errjmp;
@

<<[[cmd()]] initialisation>>=
setjmp(errjmp);
@

% run -> itab[...].func (itab[...].func = <>)
<<function undef>>=
void
undef(instruction inst)
{
    Bprint(bioout, "undefined instruction trap pc #%lux inst %.8lux class %d\n",
        reg.r[REGPC], inst, reg.class);
    longjmp(errjmp, 0);
}
@


\chapter{Libc}

\section{Memory Managment}

<<function emalloc>>=
void *
emalloc(ulong size)
{
    void *a;

    a = malloc(size);
    if(a == nil)
        fatal(0, "no memory");

    memset(a, 0, size);
    return a;
}
@

<<function erealloc>>=
void *
erealloc(void *a, ulong oldsize, ulong size)
{
    void *n;

    n = malloc(size);
    if(n == nil)
        fatal(0, "no memory");
    memset(n, 0, size);
    if(size > oldsize)
        size = oldsize;
    memmove(n, a, size);
    return n;
}
@



\chapter{Extra Code}

\ifallcode
#include "Machine_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
