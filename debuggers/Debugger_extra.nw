%TODO: acid/dbg.y!

\section{[[db/]]}

\subsection*{[[db/defs.h]]}

%<<constant STDIN>>=
%//#define	STDIN	0
%@
%
%<<constant STDOUT>>=
%//#define	STDOUT	1
%@

<<constant TRUE>>=
#define	TRUE	(-1)
@
%todo: replace by true, false
<<constant FALSE>>=
#define	FALSE	0
@

%<<constant BADREG>>=
%#define	BADREG	(-1)
%@


%-------------------------------------------------------------

<<db/defs.h>>=
/*
 * adb - common definitions
 * something of a grab-bag
 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

#include <mach.h>

<<type ADDR>>
<<type WORD>>

typedef struct bkpt	BKPT;

<<constant HUGEINT>>

<<constant MAXOFF>>
<<constant INCDIR>>
<<constant DBNAME>>
<<constant CMD_VERBS>>

<<constant MAXPOS>>
<<constant MAXLIN>>
<<constant ARB>>
<<constant MAXCOM>>
<<constant MAXARG>>
<<constant LINSIZ>>
<<constant MAXSYM>>

<<constant EOR>>
<<constant SPC>>
<<constant TB>>

<<constant TRUE>>
<<constant FALSE>>

/*
 * run modes
 */
<<constant SINGLE>>
<<constant CONTIN>>

/*
 * breakpoints
 */
<<constant BKPTCLR>>
<<constant BKPTSET>>
<<constant BKPTSKIP>>
<<constant BKPTTMP>>

<<struct bkpt>>

/*
 * common globals
 */

extern	ADDR	dot;
extern	int	dotinc;
extern ADDR	ditto;

extern	int	adrflg;
extern	WORD	adrval;

extern	int	cntflg;
extern	WORD	cntval;
extern	WORD	loopcnt;

extern	uvlong	expv;

extern	ADDR	maxoff;

extern	int	pid;
extern	char	*corfil, *symfil;
extern	int	fcor, fsym;
extern	Map	*cormap, *symmap, *dotmap;
extern	int	pcsactive;
extern	int	ending;
extern	bool	mkfault;

extern	BKPT	*bkpthead;

extern	int	lastc, peekc;

<<constant NNOTE>>
extern	int	nnote;
extern	char	note[NNOTE][ERRMAX];

extern	int	xargc;

extern	bool	wtflag;
extern	bool	kflag;

// new decl, was in main.c before
extern char *errmsg;
extern jmp_buf env;

@

%dead:
%extern	ADDR	localval;
%extern	ADDR	maxfile;
%extern	ADDR	maxstor;
%extern	bool	regdirty;


\subsection*{[[db/fns.h]]}


%-------------------------------------------------------------

<<db/fns.h>>=
void		acommand(int);
void		attachprocess(void);
void		bkput(BKPT*, int);
void		bpwait(void);
int		charpos(void);
void		chkerr(void);
void		clrinp(void);
void		cmdmap(Map*);
void		cmdsrc(int, Map*);
void		cmdwrite(int, Map*);
int		command(char*, int);
int		convdig(int);
void		ctrace(int);
WORD		defval(WORD);
void		delbp(void);
void		done(void);
int		dprint(char*, ...);
Map*		dumbmap(int);
void		endline(void);
void		endpcs(void);
int		eol(int);
void		error(char*);
void		errors(char*, char*);
void		execbkpt(BKPT*, int);
char*		exform(int, int, char*, Map*, int, int);
int		expr(int);
void		flush(void);
void		flushbuf(void);
char*		getfname(void);
void		getformat(char*);
int		getnum(int (*)(void));
void		grab(void);
void		iclose(int, int);
ADDR		inkdot(int);
int		isfileref(void);
int		item(int);
void		killpcs(void);
void		kmsys(void);
void		main(int, char**);
int		mapimage(void);
void		newline(void);
int		nextchar(void);
void		notes(void);
void		oclose(void);
void		outputinit(void);
void		printc(int);
void		printesc(int);
void		printlocals(Symbol *, ADDR);
void		printmap(char*, Map*);
void		printparams(Symbol *, ADDR);
void		printpc(void);
void		printregs(int);
void		prints(char*);
void		printsource(ADDR);
void		printsym(void);
void		printsyscall(void);
void		printtrace(int);
int		quotchar(void);
int		rdc(void);
int		readchar(void);
void		readsym(char*);
void		redirin(int, char*);
void		redirout(char*);
void		readfname(char *);
void		reread(void);
char*		regname(int);
uvlong		rget(Map*, char*);
Reglist*	rname(char*);
void		rput(Map*, char*, vlong);
int		runpcs(int, int);
void		runrun(int);
void		runstep(uvlong, int);
BKPT*		scanbkpt(ADDR adr);
void		scanform(long, int, char*, Map*, int);
void		setbp(void);
void		setcor(void);
void		setsym(void);
void		setup(void);
void		setvec(void);
void		shell(void);
void		startpcs(void);
void		subpcs(int);
int		symchar(int);
int		term(int);
void		ungrab(void);
int		valpr(long, int);

#pragma	varargck	argpos	dprint	1
#pragma	varargck	type	"t"	void
@


\subsection*{[[db/utils.c]]}


%-------------------------------------------------------------

<<db/utils.c>>=
#include "defs.h"
#include "fns.h"

<<function error>>

<<function errors>>
@


\subsection*{[[db/globals.c]]}


%-------------------------------------------------------------

<<db/globals.c>>=
#include "defs.h"

<<global wtflag>>
<<global kflag>>

<<global mkfault>>
<<global maxoff>>

<<global errmsg>>
<<global env>>

<<global symmap>>
<<global cormap>>

<<global ending>>
<<global pid>>
<<global nnote>>
<<global note>>
<<global bkpthead>>

<<global dot>>
<<global dotinc>>
<<global ditto>>

<<global adrval>>
<<global adrflg>>

<<global cntval>>
<<global cntflg>>

<<global expv>>

<<global pcsactive>>


<<global xargc>>

@


\subsection*{[[db/output.c]]}




<<function printc>>=
void
printc(int c)
{
    dprint("%c", c);
}
@

<<function prints>>=
void
prints(char *s)
{
    dprint("%s",s);
}
@


<<function flushbuf>>=
void
flushbuf(void)
{
  if (printcol != 0)
        printc(EOR);
}
@


<<function newline>>=
void
newline(void)
{
    printc(EOR);
}
@

<<constant MAXIFD>>=
#define	MAXIFD	5
@

<<global istack>>=
struct {
    int	fd;
    int	r9;
} istack[MAXIFD];
@

<<global ifiledepth>>=
int	ifiledepth;
@

<<function iclose>>=
void
iclose(int stack, int err)
{
    if (err) {
        if (infile) {
            close(infile);
            infile=STDIN;
        }
        while (--ifiledepth >= 0)
            if (istack[ifiledepth].fd)
                close(istack[ifiledepth].fd);
        ifiledepth = 0;
    } else if (stack == 0) {
        if (infile) {
            close(infile);
            infile=STDIN;
        }
    } else if (stack > 0) {
        if (ifiledepth >= MAXIFD)
            error("$<< nested too deeply");
        istack[ifiledepth].fd = infile;
        ifiledepth++;
        infile = STDIN;
    } else {
        if (infile) {
            close(infile); 
            infile=STDIN;
        }
        if (ifiledepth > 0) {
            infile = istack[--ifiledepth].fd;
        }
    }
}
@
%$

% how can have multiple input file?


<<function redirout>>=
void
redirout(char *file)
{
    int fd;

    if (file == 0){
        oclose();
        return;
    }
    flushbuf();
    if ((fd = open(file, 1)) >= 0)
        seek(fd, 0L, 2);
    else if ((fd = create(file, 1, 0666)) < 0)
        error("cannot create");
    Bterm(&stdout);
    Binit(&stdout, fd, OWRITE);
}
@

<<function endline>>=
void
endline(void)
{

    if (printcol >= maxpos)
        newline();
}
@

<<constant MAXPOS>>=
#define MAXPOS	80
@
<<[[printtrace()]] switch modif cases>>=
case 'w':
    maxpos=(adrflg?adrval:MAXPOS);
    break;
@
% 100 $w

<<global maxpos>>=
int	maxpos = MAXPOS;
@




<<function flush>>=
void
flush(void)
{
    Bflush(&stdout);
}
@



%-------------------------------------------------------------

<<db/output.c>>=
/*
 *
 *	debugger
 *
 */

#include "defs.h"
#include "fns.h"

<<global printcol>>
<<global infile>>
<<global maxpos>>

<<global stdout>>

<<function printc>>

<<function tconv>>

<<function flushbuf>>

<<function prints>>

<<function newline>>

<<constant MAXIFD>>
<<global istack>>
<<global ifiledepth>>

<<function iclose>>

<<function oclose>>

<<function redirout>>

<<function endline>>

<<function flush>>

<<function dprint>>

<<function outputinit>>
@


\subsection*{[[db/input.c]]}


<<function nextchar>>=
int
nextchar(void)
{
    if (eol(rdc())) {
        reread();
        return 0;
    }
    return lastc;
}
@

<<function quotchar>>=
int
quotchar(void)
{
    if (readchar()=='\\')
        return(readchar());
    else if (lastc=='\'')
        return 0;
    else
        return lastc;
}
@


<<function isfileref>>=
/*
 *	check if the input line if of the form:
 *		<filename>:<digits><verb> ...
 *
 *	we handle this case specially because we have to look ahead
 *	at the token after the colon to decide if it is a file reference
 *	or a colon-command with a symbol name prefix. 
 */

int
isfileref(void)
{
    Rune *cp;

    for (cp = lp-1; *cp && !strchr(CMD_VERBS, *cp); cp++)
        if (*cp == '\\' && cp[1])	/* escape next char */
            cp++;
    if (*cp && cp > lp-1) {
        while (*cp == ' ' || *cp == '\t')
            cp++;
        if (*cp++ == ':') {
            while (*cp == ' ' || *cp == '\t')
                cp++;
            if (isdigit(*cp))
                return 1;
        }
    }
    return 0;
}
@



%-------------------------------------------------------------

<<db/input.c>>=
/*
 *
 *	debugger
 *
 */

#include "defs.h"
#include "fns.h"

extern	int	infile;

<<global line>>
<<global lp>>
<<global peekc>>
<<global lastc>>
<<global eof>>

/* input routines */

<<function eol>>

<<function rdc>>

<<function reread>>

<<function clrinp>>

<<function readrune>>

<<function readchar>>

<<function nextchar>>

<<function quotchar>>

<<function getformat>>

<<function isfileref>>
@


\subsection*{[[db/setup.c]]}




%-------------------------------------------------------------

<<db/setup.c>>=

/*
 * init routines
 */
#include "defs.h"
#include "fns.h"

<<global symfil>>
<<global corfil>>

<<global dotmap>>

<<global fsym>>
<<global fcor>>
<<global fhdr (db/setup.c)>>

static int getfile(char*, int, int);

<<function setsym>>

<<function setcor>>

extern Mach mi386;
extern Machdata i386mach;

<<function dumbmap>>

<<function cmdmap>>

<<function getfile>>

<<function kmsys>>

<<function attachprocess>>
@


\subsection*{[[db/format.c]]}



<<function printesc>>=
void
printesc(int c)
{
    static char hex[] = "0123456789abcdef";

    if (c < SPC || c >= 0177)
        dprint("\\x%c%c", hex[(c&0xF0)>>4], hex[c&0xF]);
    else
        printc(c);
}
@



%-------------------------------------------------------------

<<db/format.c>>=
/*
 *
 *	debugger
 *
 */

#include "defs.h"
#include "fns.h"

<<function scanform>>

<<function exform>>

<<function printesc>>

<<function inkdot>>
@


\subsection*{[[db/regs.c]]}

<<function rname>>=
/*
 * translate a name to a magic register offset
 */
Reglist*
rname(char *name)
{
    Reglist *rp;

    for (rp = mach->reglist; rp->rname; rp++)
        if (strcmp(name, rp->rname) == 0)
            return rp;
    return 0;
}
@

<<function getreg>>=
static uvlong
getreg(Map *map, Reglist *rp)
{
    uvlong v;
    ulong w;
    ushort s;
    int ret;

    v = 0;
    ret = 0;
    switch (rp->rformat)
    {
    case 'x':
        ret = get2(map, rp->roffs, &s);
        v = s;
        break;
    case 'f':
    case 'X':
        ret = get4(map, rp->roffs, &w);
        v = w;
        break;
    case 'F':
    case 'W':
    case 'Y':
        ret = get8(map, rp->roffs, &v);
        break;
    default:
        werrstr("can't retrieve register %s", rp->rname);
        error("%r");
    }
    if (ret < 0) {
        werrstr("Register %s: %r", rp->rname);
        error("%r");
    }
    return v;
}
@

<<function rget>>=
uvlong
rget(Map *map, char *name)
{
    Reglist *rp;

    rp = rname(name);
    if (!rp)
        error("invalid register name");
    return getreg(map, rp);
}
@

<<function rput>>=
void
rput(Map *map, char *name, vlong v)
{
    Reglist *rp;
    int ret;

    rp = rname(name);
    if (!rp)
        error("invalid register name");
    if (rp->rflags & RRDONLY)
        error("register is read-only");
    switch (rp->rformat)
    {
    case 'x':
        ret = put2(map, rp->roffs, (ushort) v);
        break;
    case 'X':
    case 'f':
    case 'F':
        ret = put4(map, rp->roffs, (long) v);
        break;
    case 'Y':
        ret = put8(map, rp->roffs, v);
        break;
    default:
        ret = -1;
    }
    if (ret < 0)
        error("can't write register");
}
@



%-------------------------------------------------------------

<<db/regs.c>>=
/*
 * code to keep track of registers
 */

#include "defs.h"
#include "fns.h"

<<function rname>>

<<function getreg>>

<<function rget>>

<<function rput>>
<<function printregs>>
@


\subsection*{[[db/expr.c]]}

<<function ascval>>=
static WORD
ascval(void)
{
    Rune r;

    if (readchar() == 0)
        return (0);
    r = lastc;
    while(quotchar())	/*discard chars to ending quote */
        ;
    return((WORD) r);
}
@

<<struct fpin_union>>=
union fpin_union {
        WORD w;
        float f;
};
@

<<function fpin>>=
/*
 * read a floating point number
 * the result must fit in a WORD
 */

static WORD
fpin(char *buf)
{
  union fpin_union x;

    x.f = atof(buf);
    return (x.w);
}
@



<<constant MAXBASE>>=
#define	MAXBASE	16
@

<<constant MAXLIN>>=
#define MAXLIN	128
@

<<function getnum>>=
/* service routines for expression reading */
int
getnum(int (*rdf)(void))
{
    char *cp;
    int base, d;
    bool fpnum;
    char num[MAXLIN];

    base = 0;
    fpnum = FALSE;
    if (lastc == '#') {
        base = 16;
        (*rdf)();
    }
    if (convdig(lastc) >= MAXBASE)
        return (0);
    if (lastc == '0')
        switch ((*rdf)()) {
        case 'x':
        case 'X':
            base = 16;
            (*rdf)();
            break;

        case 't':
        case 'T':
            base = 10;
            (*rdf)();
            break;

        case 'o':
        case 'O':
            base = 8;
            (*rdf)();
            break;
        default:
            if (base == 0)
                base = 8;
            break;
        }
    if (base == 0)
        base = 10;
    expv = 0;
    for (cp = num, *cp = lastc; ;(*rdf)()) {
        if ((d = convdig(lastc)) < base) {
            expv *= base;
            expv += d;
            *cp++ = lastc;
        }
        else if (lastc == '.') {
            fpnum = TRUE;
            *cp++ = lastc;
        } else {
            reread();
            break;
        }
    }
    if (fpnum)
        expv = fpin(num);
    return (1);
}
@

<<constant MAXSYM>>=
#define	MAXSYM	255
@

<<function readsym>>=
void
readsym(char *isymbol)
{
    char	*p;
    Rune r;

    p = isymbol;
    do {
        if (p < &isymbol[MAXSYM-UTFmax-1]){
            r = lastc;
            p += runetochar(p, &r);
        }
        readchar();
    } while (symchar(1));
    *p = 0;
}
@

<<function readfname>>=
void
readfname(char *filename)
{
    char	*p;
    Rune	c;

    /* snarf chars until un-escaped char in terminal char set */
    p = filename;
    do {
        if ((c = lastc) != '\\' && p < &filename[MAXSYM-UTFmax-1])
            p += runetochar(p, &c);
        readchar();
    } while (c == '\\' || strchr(CMD_VERBS, lastc) == 0);
    *p = 0;
    reread();
}
@

<<function convdig>>=
int
convdig(int c)
{
    if (isdigit(c))
        return(c-'0');
    else if (!isxdigit(c))
        return(MAXBASE);
    else if (isupper(c))
        return(c-'A'+10);
    else
        return(c-'a'+10);
}
@

<<function symchar>>=
int
symchar(int dig)
{
    if (lastc=='\\') {
        readchar();
        return(TRUE);
    }
    return(isalpha(lastc) || lastc>0x80 || lastc=='_' || dig && isdigit(lastc));
}
@

<<function round>>=
static long
round(long a, long b)
{
    long w;

    w = (a/b)*b;
    if (a!=w)
        w += b;
    return(w);
}
@


%-------------------------------------------------------------

<<db/expr.c>>=
/*
 *
 *	debugger
 *
 */

#include "defs.h"
#include "fns.h"

static long	round(long, long);

extern	ADDR	ditto;

<<function ascval>>

<<struct fpin_union>>

<<function fpin>>

<<function defval>>

<<function expr>>

<<function term>>

<<function item>>

<<constant MAXBASE>>

<<function getnum>>

<<function readsym>>

<<function readfname>>

<<function convdig>>

<<function symchar>>

<<function round>>
@


\subsection*{[[db/trcrun.c]]}








<<function loadnote>>=
/*
 * reload the note buffer
 */
void
loadnote(void)
{
    int i;
    char err[ERRMAX];

    setpcs();
    for(i=0; i<nnote; i++){
        if(write(notefd, note[i], strlen(note[i])) < 0){
            errstr(err, sizeof err);
            if(strcmp(err, "interrupted") != 0)
                endpcs();
            errors("can't write note file", err);
        }
    }
    nnote = 0;
}
@

<<function notes>>=
void
notes(void)
{
    int n;

    if(nnote == 0)
        return;
    dprint("notes:\n");
    for(n=0; n<nnote; n++)
        dprint("%d:\t%s\n", n, note[n]);
}
@

<<function killpcs>>=
void
killpcs(void)
{
    msgpcs("kill");
}
@



<<constant MAXARG>>=
#define MAXARG	32
@


<<global procname>>=
char	procname[100];
@


<<function runstep>>=
void
runstep(uvlong loc, int keepnote)
{
    int nfoll;
    uvlong foll[3];
    BKPT bkpt[3];
    int i;

    if(machdata->foll == 0){
        dprint("stepping unimplemented; assuming not a branch\n");
        nfoll = 1;
        foll[0] = loc+mach->pcquant;
    }else {
        nfoll = machdata->foll(cormap, loc, rget, foll);
        if (nfoll < 0)
            error("%r");
    }
    memset(bkpt, 0, sizeof bkpt);
    for(i=0; i<nfoll; i++){
        if(foll[i] == loc)
            error("can't single step: next instruction is dot");
        bkpt[i].loc = foll[i];
        bkput(&bkpt[i], 1);
    }
    runrun(keepnote);
    for(i=0; i<nfoll; i++)
        bkput(&bkpt[i], 0);
}
@


<<function runrun>>=
void
runrun(int keepnote)
{
    int on;

    on = nnote;
    unloadnote();
    if(on != nnote){
        notes();
        error("not running: new notes pending");
    }
    if(keepnote)
        loadnote();
    else
        nnote = 0;
    flush();
    msgpcs("startstop");
    bpwait();
}
@

<<function bkput>>=
void
bkput(BKPT *bp, int install)
{
    char buf[256];
    ADDR loc;
    int ret;

    errstr(buf, sizeof buf);
    if(machdata->bpfix)
        loc = (*machdata->bpfix)(bp->loc);
    else
        loc = bp->loc;
    if(install){
        ret = get1(cormap, loc, bp->save, machdata->bpsize);
        if (ret > 0)
            ret = put1(cormap, loc, machdata->bpinst, machdata->bpsize);
    }else
        ret = put1(cormap, loc, bp->save, machdata->bpsize);
    if(ret < 0){
        sprint(buf, "can't set breakpoint at %#llux: %r", bp->loc);
        print(buf);
        read(0, buf, 100);
    }
}
@


%-------------------------------------------------------------

<<db/trcrun.c>>=
/*
 * functions for running the debugged process
 */

#include "defs.h"
#include "fns.h"


<<global child>>
<<global msgfd>>
<<global notefd>>
<<global pcspid>>


<<function setpcs>>

<<function msgpcs>>

<<function unloadnote>>

<<function loadnote>>

<<function notes>>

<<function killpcs>>

<<function grab>>

<<function ungrab>>

<<function doexec>>

<<global procname>>

<<function startpcs>>

<<function runstep>>

<<function bpwait>>

<<function runrun>>

<<function bkput>>
@


\subsection*{[[db/print.c]]}

<<constant INCDIR>>=
#define	INCDIR	"/usr/lib/adb"
@

<<global Ipath>>=
char	*Ipath = INCDIR;
@
%$



<<function getfname>>=
char *
getfname(void)
{
    static char fname[ARB];
    char *p;

    if (rdc() == EOR) {
        reread();
        return (0);
    }
    p = fname;
    do {
        *p++ = lastc;
        if (p >= &fname[ARB-1])
            error("filename too long");
    } while (rdc() != EOR);
    *p = 0;
    reread();
    return (fname);
}
@


<<function redirin>>=
void
redirin(int stack, char *file)
{
    char *pfile;

    if (file == 0) {
        iclose(-1, 0);
        return;
    }
    iclose(stack, 0);
    if ((infile = open(file, 0)) < 0) {
        pfile = smprint("%s/%s", Ipath, file);
        infile = open(pfile, 0);
        free(pfile);
        if(infile < 0) {
            infile = STDIN;
            error("cannot open");
        }
    }
}
@



<<constant STRINGSZ>>=
#define	STRINGSZ	128
@

<<function printsource>>=
/*
 *	print the value of dot as file:line
 */
void
printsource(ADDR dot)
{
    char str[STRINGSZ];

    if (fileline(str, STRINGSZ, dot))
        dprint("%s", str);
}
@

<<function printpc>>=
void
printpc(void)
{
    char buf[512];

    dot = rget(cormap, mach->pc);
    if(dot){
        printsource((long)dot);
        printc(' ');
        symoff(buf, sizeof(buf), (long)dot, CTEXT);
        dprint("%s/", buf);
        if (machdata->das(cormap, dot, 'i', buf, sizeof(buf)) < 0)
            error("%r");
        dprint("%16t%s\n", buf);
    }
}
@


<<function printparams>>=
void
printparams(Symbol *fn, ADDR fp)
{
    int i;
    Symbol s;
    ulong w;
    int first = 0;

    fp += mach->szaddr;			/* skip saved pc */
    s = *fn;
    for (i = 0; localsym(&s, i); i++) {
        if (s.class != CPARAM)
            continue;
        if (first++)
            dprint(", ");
        if (get4(cormap, fp+s.value, &w) > 0)
            dprint("%s=%#lux", s.name, w);
    }
}
@


%-------------------------------------------------------------

<<db/print.c>>=
/*
 *
 *	debugger
 *
 */
#include "defs.h"
#include "fns.h"

extern	int	infile;
extern	int	outfile;
extern	int	maxpos;

/* general printing routines ($) */

<<global Ipath>>
<<global tracetype>>
static void	printfp(Map*, int);

<<function ptrace>>

<<function printtrace>>

<<function getfname>>

<<function printfp>>

<<function redirin>>

<<function printmap>>

<<function printsym>>

<<constant STRINGSZ>>

<<function printsource>>

<<function printpc>>

<<function printlocals>>

<<function printparams>>
@
%$


\subsection*{[[db/command.c]]}

<<global BADEQ>>=
char	BADEQ[] = "unexpected `='";
@

<<global executing>>=
bool	executing;
@


<<global loopcnt>>=
WORD loopcnt;
@





<<function regname>>=
/*
 * collect a register name; return register offset
 * this is not what i'd call a good division of labour
 */

char *
regname(int regnam)
{
    static char buf[64];
    char *p;
    int c;

    p = buf;
    *p++ = regnam;
    while (isalnum(c = readchar())) {
        if (p >= buf+sizeof(buf)-1)
            error("register name too long");
        *p++ = c;
    }
    *p = 0;
    reread();
    return (buf);
}
@

<<function shell>>=
/*
 * shell escape
 */

void
shell(void)
{
    int	rc, unixpid;
    char *argp = (char*)lp;

    while (lastc!=EOR)
        rdc();
    if ((unixpid=fork())==0) {
        *lp=0;
        execl("/bin/rc", "rc", "-c", argp, nil);
        exits("execl");				/* botch */
    } else if (unixpid == -1) {
        error("cannot fork");
    } else {
        mkfault = 0;
        while ((rc = waitpid()) != unixpid){
            if(rc == -1 && mkfault){
                mkfault = 0;
                continue;
            }
            break;
        }
        prints("!"); 
        reread();
    }
}
@


%-------------------------------------------------------------

<<db/command.c>>=
/*
 *
 *	debugger
 *
 */

#include "defs.h"
#include "fns.h"

<<global BADEQ>>

<<global executing>>
extern	Rune	*lp;

<<global eqformat>>
<<global stformat>>


<<global loopcnt>>

<<function command>>

<<function acommand>>

<<function cmdsrc>>

<<global badwrite>>

<<function cmdwrite>>

<<function regname>>

<<function shell>>
@


\subsection*{[[db/runpcs.c]]}





<<function execbkpt>>=
/*
 * skip over a breakpoint:
 * remove breakpoints, then single step
 * so we can put it back
 */
void
execbkpt(BKPT *bk, int keepnote)
{
    runstep(bk->loc, keepnote);
    bk->flag = BKPTSET;
}
@


<<function delbp>>=
/*
 * remove all breakpoints from the process' address space
 */

void
delbp(void)
{
    BKPT *bk;

    if (bpin == FALSE || pid == 0)
        return;
    for (bk = bkpthead; bk; bk = bk->nxtbkpt)
        if (bk->flag != BKPTCLR)
            bkput(bk, 0);
    bpin = FALSE;
}
@

<<function setbp>>=
/*
 * install all the breakpoints
 */

void
setbp(void)
{
    BKPT *bk;

    if (bpin == TRUE || pid == 0)
        return;
    for (bk = bkpthead; bk; bk = bk->nxtbkpt)
        if (bk->flag != BKPTCLR)
            bkput(bk, 1);
    bpin = TRUE;
}
@


%-------------------------------------------------------------

<<db/runpcs.c>>=
/*
 *
 *	debugger
 *
 */

#include "defs.h"
#include "fns.h"


<<global bpin>>


<<function runpcs>>

<<function endpcs>>

<<function setup>>

<<function execbkpt>>

<<function scanbkpt>>

<<function delbp>>

<<function setbp>>
@


\subsection*{[[db/pcs.c]]}



%-------------------------------------------------------------

<<db/pcs.c>>=
/*
 *
 *	debugger
 *
 */

#include "defs.h"
#include "fns.h"

<<global NOPCS>>

<<function subpcs>>
@


\subsection*{[[db/main.c]]}

<<global exitflg>>=
bool	exitflg;
@




<<function fault>>=
/*
 * An interrupt occurred;
 * seek to the end of the current file
 * and remember that there was a fault.
 */
void
fault(void *a, char *s)
{
    USED(a);
    if(strncmp(s, "interrupt", 9) == 0){
        seek(infile, 0L, 2);
        mkfault++;
        noted(NCONT);
    }
    noted(NDFLT);
}
@


%-------------------------------------------------------------

<<db/main.c>>=
/*
 * db - main command loop and error/interrupt handling
 */
#include "defs.h"
#include "fns.h"


extern	bool	executing;
extern	int	infile;
<<global exitflg>>
extern	int	eof;

int	alldigs(char*);
void	fault(void*, char*);

extern	char	*Ipath;
extern jmp_buf env;
extern char *errmsg;

<<function main (db/main.c)>>

<<function alldigs>>

<<function done>>


<<function fault>>
@















\section{[[tracers/]]}

\subsection*{[[tracers/ktrace.c]]}

<<global fhdr>>=
static	Fhdr	fhdr;
@

<<global interactive>>=
static	int	interactive = 0;
@

<<constant FRAMENAME>>=
#define	FRAMENAME	".frame"
@

<<function usage>>=
static void
usage(void)
{
    fprint(2, "usage: ktrace [-i] kernel pc sp [link]\n");
    exits("usage");
}
@

<<function printaddr>>=
static void
printaddr(char *addr, uvlong pc)
{
    int i;
    char *p;

    /*
     * reformat the following.
     *
     * foo+1a1 -> src(foo+0x1a1);
     * 10101010 -> src(0x10101010);
     */

    if(strlen(addr) == 8 && strchr(addr, '+') == nil){
        for(i=0; i<8; i++)
            if(!isxdigit(addr[i]))
                break;
        if(i == 8){
            print("src(%#.8llux); // 0x%s\n", pc, addr);
            return;
        }
    }

    if(p=strchr(addr, '+')){
        *p++ = 0;
        print("src(%#.8llux); // %s+0x%s\n", pc, addr, p);
    }else
        print("src(%#.8llux); // %s\n", pc, addr);
}
@

<<global fmt>>=
static void (*fmt)(char*, uvlong) = printaddr;
@

<<function main>>=
void
main(int argc, char *argv[])
{
    int (*t)(uvlong, uvlong, uvlong);
    uvlong pc, sp, link;
    int fd;

    ARGBEGIN{
    case 'i':
        interactive = 1;
        break;
    default:
        usage();
    }ARGEND

    link = 0;
    t = rtrace;
    switch(argc){
    case 4:
        t = rtrace;
        link = strtoull(argv[3], 0, 16);
        break;
    case 3:
        break;
    default:
        usage();
    }
    pc = strtoull(argv[1], 0, 16);
    sp = strtoull(argv[2], 0, 16);
    if(!interactive)
        readstack();

    fd = open(argv[0], OREAD);
    if(fd < 0)
        fatal("can't open %s: %r", argv[0]);
    inithdr(fd);
    switch(fhdr.magic){
    case I_MAGIC:	/* intel 386 */
        t = i386trace;
        break;
    case E_MAGIC:	/* arm 7-something */
        t = rtrace;
        break;
    default:
        fprint(2, "%s: warning: can't tell what type of stack %s uses; assuming it's %s\n",
            argv0, argv[0], argc == 4 ? "risc" : "cisc");
        break;
    }
    (*t)(pc, sp, link);
    exits(0);
}
@

<<function inithdr>>=
static void
inithdr(int fd)
{
    seek(fd, 0, 0);
    if(!crackhdr(fd, &fhdr))
        fatal("read text header");

    if(syminit(fd, &fhdr) < 0)
        fatal("%r\n");
}
@

<<function rtrace>>=
// for MIPS and ARM
static int
rtrace(uvlong pc, uvlong sp, uvlong link)
{
    Symbol s, f;
    char buf[128];
    uvlong oldpc;
    int i;

    i = 0;
    while(findsym(pc, CTEXT, &s)) {
        if(pc == s.value)	/* at first instruction */
            f.value = 0;
        else if(findlocal(&s, FRAMENAME, &f) == 0)
            break;

        symoff(buf, sizeof buf, pc, CANY);
        fmt(buf, pc);

        oldpc = pc;
        if(s.type == 'L' || s.type == 'l' || pc <= s.value+mach->pcquant){
            if(link == 0)
                fprint(2, "%s: need to supply a valid link register\n", argv0);
            pc = link;
        }else{
            pc = getval(sp);
            if(pc == 0)
                break;
        }

        if(pc == 0 || (pc == oldpc && f.value == 0))
            break;

        sp += f.value;

        if(++i > 40)
            break;
    }
    return i;
}
@

<<function i386trace>>=
static int
i386trace(uvlong pc, uvlong sp, uvlong link)
{
    int i;
    uvlong osp;
    Symbol s, f;
    char buf[128];

    USED(link);
    i = 0;
    osp = 0;
    while(findsym(pc, CTEXT, &s)) {

        symoff(buf, sizeof buf, pc, CANY);
        fmt(buf, pc);

        if(pc != s.value) {	/* not at first instruction */
            if(findlocal(&s, FRAMENAME, &f) == 0)
                break;
            sp += f.value-mach->szaddr;
        }else if(strcmp(s.name, "forkret") == 0){
            print("//passing interrupt frame; last pc found at sp=%#llux\n", osp);
            sp +=  15 * mach->szaddr;		/* pop interrupt frame */
        }

        pc = getval(sp);
        if(pc == 0 && strcmp(s.name, "forkret") == 0){
            sp += 3 * mach->szaddr;			/* pop iret eip, cs, eflags */
            print("//guessing call through invalid pointer, try again at sp=%#llux\n", sp);
            s.name = "";
            pc = getval(sp);
        }
        if(pc == 0) {
            print("//didn't find pc at sp=%#llux, last pc found at sp=%#llux\n", sp, osp);
            break;
        }
        osp = sp;

        sp += mach->szaddr;
        if(strcmp(s.name, "forkret") == 0)
            sp += 2 * mach->szaddr;			/* pop iret cs, eflags */

        if(++i > 40)
            break;
    }
    return i;
}
@

<<global naddr>>=
int naddr;
@

<<global addr>>=
uvlong addr[1024];
@

<<global val>>=
uvlong val[1024];
@

<<function putval>>=
static void
putval(uvlong a, uvlong v)
{
    if(naddr < nelem(addr)){
        addr[naddr] = a;
        val[naddr] = v;
        naddr++;
    }
}
@

<<function readstack>>=
static void
readstack(void)
{
    Biobuf b;
    char *p;
    char *f[64];
    int nf, i;

    Binit(&b, 0, OREAD);
    while(p=Brdline(&b, '\n')){
        p[Blinelen(&b)-1] = 0;
        nf = tokenize(p, f, nelem(f));
        for(i=0; i<nf; i++){
            if(p=strchr(f[i], '=')){
                *p++ = 0;
                putval(strtoull(f[i], 0, 16), strtoull(p, 0, 16));
            }
        }
    }
}
@

<<function getval>>=
static uvlong
getval(uvlong a)
{
    char buf[256];
    int i, n;
    uvlong r;

    if(interactive){
        print("// data at %#8.8llux? ", a);
        n = read(0, buf, sizeof(buf)-1);
        if(n <= 0)
            return 0;
        buf[n] = '\0';
        r = strtoull(buf, 0, 16);
    }else{
        r = 0;
        for(i=0; i<naddr; i++)
            if(addr[i] == a)
                r = val[i];
    }

    return r;
}
@

<<function fatal>>=
static void
fatal(char *fmt, ...)
{
    char buf[4096];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    fprint(2, "ktrace: %s\n", buf);
    exits(buf);
}
@


%-------------------------------------------------------------

<<tracers/ktrace.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>

#include <mach.h>

// ktrace - interpret kernel stack dumps

static	int	rtrace(uvlong, uvlong, uvlong);
static	int	i386trace(uvlong, uvlong, uvlong);

static	uvlong	getval(uvlong);
static	void	inithdr(int);
static	void	fatal(char*, ...);
static	void	readstack(void);

<<global fhdr>>
<<global interactive>>

<<constant FRAMENAME>>

<<function usage>>

<<function printaddr>>

<<global fmt>>

<<function main>>

<<function inithdr>>

<<function rtrace>>

<<function i386trace>>

<<global naddr>>
<<global addr>>
<<global val>>

<<function putval>>

<<function readstack>>

<<function getval>>

<<function fatal>>
@


\subsection*{[[tracers/strace.c]]}

<<enum _anon_>>=
enum {
    Stacksize	= 8*1024,
    Bufsize		= 8*1024,
};
@

<<global out>>=
Channel *out;
@

<<global quit>>=
Channel *quit;
@

<<global forkc>>=
Channel *forkc;
@

<<global nread>>=
int nread = 0;
@

<<struct Str>>=
struct Str {
    char	*buf;
    int	len;
};
@

<<function die>>=
void
die(char *s)
{
    fprint(2, "%s\n", s);
    exits(s);
}
@

<<function cwrite>>=
void
cwrite(int fd, char *path, char *cmd, int len)
{
    werrstr("");
    if (write(fd, cmd, len) < len) {
        fprint(2, "cwrite: %s: failed writing %d bytes: %r\n",
            path, len);
        sendp(quit, nil);
        threadexits(nil);
    }
}
@

<<function newstr>>=
Str *
newstr(void)
{
    Str *s;

    s = mallocz(sizeof(Str) + Bufsize, 1);
    if (s == nil)
        sysfatal("malloc");
    s->buf = (char *)&s[1];
    return s;
}
@

<<function reader>>=
void
reader(void *v)
{
    int cfd, tfd, forking = 0, exiting, pid, newpid;
    char *ctl, *truss;
    Str *s;
    static char start[] = "start";
    static char waitstop[] = "waitstop";

    pid = (int)(uintptr)v;

    ctl = smprint("/proc/%d/ctl", pid);
    if ((cfd = open(ctl, OWRITE)) < 0)
        die(smprint("%s: %r", ctl));

    truss = smprint("/proc/%d/syscall", pid);
    if ((tfd = open(truss, OREAD)) < 0)
        die(smprint("%s: %r", truss));

    /* child was stopped by hang msg earlier */
    cwrite(cfd, ctl, waitstop, sizeof waitstop - 1);
    // useful? if it was stopped, then why need waitstop?
    // because the fork() has been done but maybe the child
    // has not yet reached the exec() and got actually stopped!

    cwrite(cfd, ctl, "startsyscall", 12);
    s = newstr();
    exiting = 0;
    while((s->len = pread(tfd, s->buf, Bufsize - 1, 0)) >= 0){
        if (forking && s->buf[1] == '=' && s->buf[3] != '-') {
            forking = 0;
            newpid = strtol(&s->buf[3], 0, 0);
            sendp(forkc, (void*)newpid);
            procrfork(reader, (void*)newpid, Stacksize, 0);
        }

        /*
         * There are three tests here and they (I hope) guarantee
         * no false positives.
         */
        if (strstr(s->buf, " Rfork") != nil) {
            char *a[8];
            char *rf;

            rf = strdup(s->buf);
           if (tokenize(rf, a, 8) == 5 &&
                strtoul(a[4], 0, 16) & RFPROC)
                forking = 1;
            free(rf);
        } else if (strstr(s->buf, " Exits") != nil)
            exiting = 1;

        sendp(out, s);	/* print line from /proc/$child/syscall */
        if (exiting) {
            s = newstr();
            strcpy(s->buf, "\n");
            sendp(out, s);
            break;
        }

        /* flush syscall trace buffer */
        cwrite(cfd, ctl, "startsyscall", 12);
        s = newstr();
    }

    sendp(quit, nil);
    threadexitsall(nil);
}
@
%$

<<function writer>>=
void
writer(void *)
{
    int newpid;
    Str *s;

    // TODO use better initializer?
    Alt a[4];

    a[0].op = CHANRCV;
    a[0].c = quit;
    a[0].v = nil;

    a[1].op = CHANRCV;
    a[1].c = out;
    a[1].v = &s;

    a[2].op = CHANRCV;
    a[2].c = forkc;
    a[2].v = &newpid;

    a[3].op = CHANEND;

    for(;;)
        switch(alt(a)){
        case 0:			/* quit */
            nread--;
            if(nread <= 0)
                goto done;
            break;
        case 1:			/* out */
            /* it's a nice null terminated thing */
            fprint(2, "%s", s->buf);
            free(s);
            break;
        case 2:			/* forkc */
            // procrfork(reader, (void*)newpid, Stacksize, 0);
            nread++;
            break;
        }
done:
    exits(nil);
}
@

<<function usage (tracers/strace.c)>>=
void
usage(void)
{
    fprint(2, "Usage: strace [-c cmd [arg...]] | [pid]\n");
    exits("usage");
}
@

<<function hang>>=
void
hang(void)
{
    int me;
    char *myctl;
    static char hang[] = "hang";

    myctl = smprint("/proc/%d/ctl", getpid());
    me = open(myctl, OWRITE);
    if (me < 0)
        sysfatal("can't open %s: %r", myctl);
    cwrite(me, myctl, hang, sizeof hang - 1);
    close(me);
    free(myctl);
}
@

<<function threadmain>>=
void
threadmain(int argc, char **argv)
{
    int pid;
    char *cmd = nil;
    char **args = nil;

    /*
     * don't bother with fancy arg processing, because it picks up options
     * for the command you are starting.  Just check for -c as argv[1]
     * and then take it from there.
     */
    if (argc < 2)
        usage();
    while (argv[1][0] == '-') {
        switch(argv[1][1]) {
        case 'c':
            if (argc < 3)
                usage();
            cmd = strdup(argv[2]);
            args = &argv[2];
            break;
        default:
            usage();
        }
        ++argv;
        --argc;
    }

    /* run a command? */
    if(cmd) {
        pid = fork();
        if (pid < 0)
            sysfatal("fork failed: %r");
        if(pid == 0) {
            hang();
            exec(cmd, args);
            if(cmd[0] != '/')
                exec(smprint("/bin/%s", cmd), args);
            sysfatal("exec %s failed: %r", cmd);
        }
    } else {
        if(argc != 2)
            usage();
        pid = atoi(argv[1]);
        //TODO? send a 'stop' to its ctl file?
    }

    out   = chancreate(sizeof(char*), 0);
    quit  = chancreate(sizeof(char*), 0);
    forkc = chancreate(sizeof(ulong *), 0);
    nread++;
    procrfork(writer, nil, Stacksize, 0);
    reader((void*)pid);
}
@


%-------------------------------------------------------------

<<tracers/strace.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <thread.h>

// System calls tracer

// was called ratrace, maybe in hommage to Ed Wood "Rat Race" movie
// but most people knows better 'strace'

<<enum _anon_>>

<<global out>>
<<global quit>>
<<global forkc>>
<<global nread>>

typedef struct Str Str;
<<struct Str>>

<<function die>>

<<function cwrite>>

<<function newstr>>

<<function reader>>

<<function writer>>

<<function usage (tracers/strace.c)>>

<<function hang>>

<<function threadmain>>
@





\section{[[acid/]]}

\subsection*{[[acid/acid.h]]}

<<enum _anon_ (acid/acid.h)>>=
/* acid.h */
enum
{
    Eof		= -1,
    Strsize		= 4096,
    Hashsize	= 128,
    Maxarg		= 512,
    NFD		= 100,
    Maxproc		= 50,
    Maxval		= 10,
    Mempergc	= 1024*1024,
};
@

<<macro expr>>=
#define expr(n, r) do{(r)->comt=0; (*expop[(n)->op])(n, r);}while(0)
@

<<enum _anon_ (acid/acid.h)2>>=
enum
{
    TINT,
    TFLOAT,
    TSTRING,
    TLIST,
    TCODE,
};
@

<<struct Type>>=
struct Type
{
    Type*	next;
    int	offset;
    char	fmt;
    char	depth;
    Lsym*	type;
    Lsym*	tag;
    Lsym*	base;
};
@

<<struct Frtype>>=
struct Frtype
{
    Lsym*	var;
    Type*	type;
    Frtype*	next;
};
@

<<struct Ptab>>=
struct Ptab
{
    int	pid;
    int	ctl;
};
@

<<struct Rplace>>=
struct Rplace
{
    jmp_buf	rlab;
    Node*	stak;
    Node*	val;
    Lsym*	local;
    Lsym**	tail;
};
@

<<struct Gc>>=
struct Gc
{
    char	gcmark;
    Gc*	gclink;
};
@

<<struct Store>>=
struct Store
{
    char	fmt;
    Type*	comt;
    union {
        vlong	ival;
        double	fval;
        String*	string;
        List*	l;
        Node*	cc;
    };
};
@

<<struct List>>=
struct List
{
    Gc;
    List*	next;
    char	type;
    Store;
};
@

<<struct Value>>=
struct Value
{
    char	set;
    char	type;
    Store;
    Value*	pop;
    Lsym*	scope;
    Rplace*	ret;
};
@

<<struct Lsym>>=
struct Lsym
{
    char*	name;
    int	lexval;
    Lsym*	hash;
    Value*	v;
    Type*	lt;
    Node*	proc;
    Frtype*	local;
    void	(*builtin)(Node*, Node*);
};
@

<<struct Node>>=
struct Node
{
    Gc;
    char	op;
    char	type;
    Node*	left;
    Node*	right;
    Lsym*	sym;
    int	builtin;
    Store;
};
@

<<constant ZN>>=
#define ZN	(Node*)0
@

<<struct StringAcid>>=
struct StringAcid
{
    Gc;
    char	*string;
    int	len;
};
@

<<enum _anon_ (acid/acid.h)3>>=
enum
{
    ONAME,
    OCONST,
    OMUL,
    ODIV,
    OMOD,
    OADD,
    OSUB,
    ORSH,
    OLSH,
    OLT,
    OGT,
    OLEQ,
    OGEQ,
    OEQ,
    ONEQ,
    OLAND,
    OXOR,
    OLOR,
    OCAND,
    OCOR,
    OASGN,
    OINDM,
    OEDEC,
    OEINC,
    OPINC,
    OPDEC,
    ONOT,
    OIF,
    ODO,
    OLIST,
    OCALL,
    OCTRUCT,
    OWHILE,
    OELSE,
    OHEAD,
    OTAIL,
    OAPPEND,
    ORET,
    OINDEX,
    OINDC,
    ODOT,
    OLOCAL,
    OFRAME,
    OCOMPLEX,
    ODELETE,
    OCAST,
    OFMT,
    OEVAL,
    OWHAT,
};
@


%-------------------------------------------------------------

<<acid/acid.h>>=
<<enum _anon_ (acid/acid.h)>>

#pragma varargck type "L"	void

typedef struct Node	Node;
typedef struct StringAcid	String;
typedef struct Lsym	Lsym;
typedef struct List	List;
typedef struct Store	Store;
typedef struct Gc	Gc;
typedef struct Strc	Strc;
typedef struct Rplace	Rplace;
typedef struct Ptab	Ptab;
typedef struct Value	Value;
typedef struct Type	Type;
typedef struct Frtype	Frtype;

extern int	kernel;
extern int	remote;
extern int	text;
extern int	silent;
extern Fhdr	fhdr;
extern int	line;
extern Biobuf*	bout;
extern Biobuf*	io[32];
extern int	iop;
extern char	symbol[Strsize];
extern int	interactive;
extern int	na;
extern int	wtflag;
extern Map*	cormap;
extern Map*	symmap;
extern Lsym*	hash[Hashsize];
extern long	dogc;
extern Rplace*	ret;
extern char*	aout;
extern int	gotint;
extern Gc*	gcl;
extern int	stacked;
extern jmp_buf	err;
extern Node*	prnt;
extern List*	tracelist;
extern int	initialising;
extern int	quiet;

extern void	(*expop[])(Node*, Node*);
<<macro expr>>
extern int	fmtsize(Value *v) ;

<<enum _anon_ (acid/acid.h)2>>

<<struct Type>>

<<struct Frtype>>

<<struct Ptab>>

extern Ptab	ptab[Maxproc];

<<struct Rplace>>

<<struct Gc>>

<<struct Store>>

<<struct List>>

<<struct Value>>

<<struct Lsym>>

<<struct Node>>
<<constant ZN>>

<<struct StringAcid>>

List*	addlist(List*, List*);
List*	al(int);
Node*	an(int, Node*, Node*);
void	append(Node*, Node*, Node*);
int	fbool(Node*);
void	build(Node*);
void	call(char*, Node*, Node*, Node*, Node*);
void	catcher(void*, char*);
void	checkqid(int, int);
void	cmd(void);
Node*	con(vlong);
List*	construct(Node*);
void	ctrace(int);
void	decl(Node*);
void	defcomplex(Node*, Node*);
void	deinstall(int);
void	delete(List*, int n, Node*);
void	dostop(int);
Lsym*	enter(char*, int);
void	error(char*, ...);
void	execute(Node*);
void	fatal(char*, ...);
void	flatten(Node**, Node*);
void	gc(void);
char*	getstatus(int);
void*	gmalloc(long);
void	indir(Map*, uvlong, char, Node*);
void	installbuiltin(void);
void	kinit(void);
int	Lfmt(Fmt*);
int	listcmp(List*, List*);
int	listlen(List*);
List*	listvar(char*, vlong);
void	loadmodule(char*);
void	loadvars(void);
Lsym*	look(char*);
void	ltag(char*);
void	marklist(List*);
Lsym*	mkvar(char*);
void	msg(int, char*);
void	notes(int);
int	nproc(char**);
void	nthelem(List*, int, Node*);
int	numsym(char);
void	odot(Node*, Node*);
void	pcode(Node*, int);
void	pexpr(Node*);
int	popio(void);
void	pstr(String*);
void	pushfile(char*);
void	pushstr(Node*);
void	readtext(char*);
void	restartio(void);
uvlong	rget(Map*, char*);
String	*runenode(Rune*);
int	scmp(String*, String*);
void	sproc(int);
String*	stradd(String*, String*);
String*	straddrune(String*, Rune);
String*	strnode(char*);
String*	strnodlen(char*, int);
char*	system(void);
void	trlist(Map*, uvlong, uvlong, Symbol*);
void	unwind(void);
void	userinit(void);
void	varreg(void);
void	varsym(void);
Waitmsg*	waitfor(int);
void	whatis(Lsym*);
void	windir(Map*, Node*, Node*, Node*);
void	yyerror(char*, ...);
int	yylex(void);
int	yyparse(void);

<<enum _anon_ (acid/acid.h)3>>
@


\subsection*{[[acid/globals.c]]}

<<global kernel>>=
int	kernel;
@

<<global remote>>=
int	remote;
@

<<global text>>=
int	text;
@

<<global silent>>=
int	silent;
@

<<global fhdr (acid/globals.c)>>=
Fhdr	fhdr;
@

<<global line (acid/globals.c)>>=
int	line;
@

<<global bout>>=
Biobuf*	bout;
@

<<global io>>=
Biobuf*	io[32];
@

<<global iop>>=
int	iop;
@

<<global symbol>>=
char	symbol[Strsize];
@

<<global interactive (acid/globals.c)>>=
int	interactive;
@

<<global na>>=
int	na;
@

<<global wtflag (acid/globals.c)>>=
int	wtflag;
@

<<global cormap (acid/globals.c)>>=
Map*	cormap;
@

<<global symmap (acid/globals.c)>>=
Map*	symmap;
@

<<global hash>>=
Lsym*	hash[Hashsize];
@

<<global dogc>>=
long	dogc;
@

<<global ret>>=
Rplace*	ret;
@

<<global aout>>=
char*	aout;
@

<<global gotint>>=
int	gotint;
@

<<global gcl>>=
Gc*	gcl;
@

<<global stacked>>=
int	stacked;
@

<<global err>>=
jmp_buf	err;
@

<<global prnt>>=
Node*	prnt;
@

<<global tracelist>>=
List*	tracelist;
@

<<global initialising>>=
int	initialising;
@

<<global quiet>>=
int	quiet;
@

<<global ptab>>=
Ptab	ptab[Maxproc];
@


%-------------------------------------------------------------

<<acid/globals.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>
#include "acid.h"

<<global kernel>>
<<global remote>>
<<global text>>
<<global silent>>
<<global fhdr (acid/globals.c)>>
<<global line (acid/globals.c)>>
<<global bout>>
<<global io>>
<<global iop>>
<<global symbol>>
<<global interactive (acid/globals.c)>>
<<global na>>
<<global wtflag (acid/globals.c)>>
<<global cormap (acid/globals.c)>>
<<global symmap (acid/globals.c)>>
<<global hash>>
<<global dogc>>
<<global ret>>
<<global aout>>
<<global gotint>>
<<global gcl>>
<<global stacked>>
<<global err>>
<<global prnt>>
<<global tracelist>>
<<global initialising>>
<<global quiet>>

<<global ptab>>
@


\subsection*{[[acid/lex.c]]}

<<global keywds>>=
struct keywd
{
    char	*name;
    int	terminal;
}
keywds[] =
{
    "do",		Tdo,
    "if",		Tif,
    "then",		Tthen,
    "else",		Telse,
    "while",	Twhile,
    "loop",		Tloop,
    "head",		Thead,
    "tail",		Ttail,
    "append",	Tappend,
    "defn",		Tfn,
    "return",	Tret,
    "local",	Tlocal,
    "aggr",		Tcomplex,
    "union",	Tcomplex,
    "adt",		Tcomplex,
    "complex",	Tcomplex,
    "delete",	Tdelete,
    "whatis",	Twhat,
    "eval",		Teval,
    "builtin",	Tbuiltin,
    0,		0
};
@

<<global cmap>>=
char cmap[256] =
{
    ['0']	'\0'+1,
    ['n']	'\n'+1,
    ['r']	'\r'+1,
    ['t']	'\t'+1,
    ['b']	'\b'+1,
    ['f']	'\f'+1,
    ['a']	'\a'+1,
    ['v']	'\v'+1,
    ['\\']	'\\'+1,
    ['"']	'"'+1,
};
@

<<function kinit>>=
void
kinit(void)
{
    int i;
    
    for(i = 0; keywds[i].name; i++) 
        enter(keywds[i].name, keywds[i].terminal);
}
@

<<struct IOstack>>=
struct IOstack
{
    char	*name;
    int	line;
    char	*text;
    char	*ip;
    Biobuf	*fin;
    IOstack	*prev;
};
@

<<global lexio>>=
IOstack *lexio;
@

<<function pushfile>>=
void
pushfile(char *file)
{
    Biobuf *b;
    IOstack *io;

    if(file)
        b = Bopen(file, OREAD);
    else{
        b = Bopen("/fd/0", OREAD);
        file = "<stdin>";
    }

    if(b == 0)
        error("pushfile: %s: %r", file);

    io = malloc(sizeof(IOstack));
    if(io == 0)
        fatal("no memory");
    io->name = strdup(file);
    if(io->name == 0)
        fatal("no memory");
    io->line = line;
    line = 1;
    io->text = 0;
    io->fin = b;
    io->prev = lexio;
    lexio = io;
}
@

<<function pushstr>>=
void
pushstr(Node *s)
{
    IOstack *io;

    io = malloc(sizeof(IOstack));
    if(io == 0)
        fatal("no memory");
    io->line = line;
    line = 1;
    io->name = strdup("<string>");
    if(io->name == 0)
        fatal("no memory");
    io->line = line;
    line = 1;
    io->text = strdup(s->string->string);
    if(io->text == 0)
        fatal("no memory");
    io->ip = io->text;
    io->fin = 0;
    io->prev = lexio;
    lexio = io;
}
@

<<function restartio>>=
void
restartio(void)
{
    Bflush(lexio->fin);
    Binit(lexio->fin, 0, OREAD);
}
@

<<function popio>>=
int
popio(void)
{
    IOstack *s;

    if(lexio == 0)
        return 0;

    if(lexio->prev == 0){
        if(lexio->fin)
            restartio();
        return 0;
    }

    if(lexio->fin)
        Bterm(lexio->fin);
    else
        free(lexio->text);
    free(lexio->name);
    line = lexio->line;
    s = lexio;
    lexio = s->prev;
    free(s);
    return 1;
}
@

<<function Lfmt>>=
int
Lfmt(Fmt *f)
{
    int i;
    char buf[1024];
    IOstack *e;

    e = lexio;
    if(e) {
        i = snprint(buf, sizeof(buf), "%s:%d", e->name, line);
        while(e->prev) {
            e = e->prev;
            if(initialising && e->prev == 0)
                break;
            i += snprint(buf+i, sizeof(buf)-i, " [%s:%d]", e->name, e->line);
        }
    } else
        snprint(buf, sizeof(buf),  "no file:0");
    fmtstrcpy(f, buf);
    return 0;
}
@

<<function unlexc>>=
void
unlexc(int s)
{
    if(s == '\n')
        line--;

    if(lexio->fin)
        Bungetc(lexio->fin);
    else
        lexio->ip--;
}
@

<<function lexc>>=
int
lexc(void)
{
    int c;

    if(lexio->fin) {
        c = Bgetc(lexio->fin);
        if(gotint)
            error("interrupt");
        return c;
    }

    c = *lexio->ip++;
    if(c == 0)
        return -1;
    return c;
}
@

<<function escchar>>=
int
escchar(char c)
{
    int n;
    char buf[Strsize];

    if(c >= '0' && c <= '9') {
        n = 1;
        buf[0] = c;
        for(;;) {
            c = lexc();
            if(c == Eof)
                error("%d: <eof> in escape sequence", line);
            if(strchr("0123456789xX", c) == 0) {
                unlexc(c);
                break;
            }
            if(n >= Strsize)
                error("string escape too long");
            buf[n++] = c;
        }
        buf[n] = '\0';
        return strtol(buf, 0, 0);
    }

    n = cmap[c];
    if(n == 0)
        return c;
    return n-1;
}
@

<<function eatstring>>=
void
eatstring(void)
{
    int esc, c, cnt;
    char buf[Strsize];

    esc = 0;
    for(cnt = 0;;) {
        c = lexc();
        switch(c) {
        case Eof:
            error("%d: <eof> in string constant", line);

        case '\n':
            error("newline in string constant");
            goto done;

        case '\\':
            if(esc)
                goto Default;
            esc = 1;
            break;

        case '"':
            if(esc == 0)
                goto done;

            /* Fall through */
        default:
        Default:
            if(esc) {
                c = escchar(c);
                esc = 0;
            }
            buf[cnt++] = c;
            break;
        }
        if(cnt >= Strsize)
            error("string token too long");
    }
done:
    buf[cnt] = '\0';
    yylval.string = strnode(buf);
}
@

<<function eatnl>>=
void
eatnl(void)
{
    int c;

    line++;
    for(;;) {
        c = lexc();
        if(c == Eof)
            error("eof in comment");
        if(c == '\n')
            return;
    }
}
@

<<function yylex>>=
int
yylex(void)
{
    int c;
    extern char vfmt[];

loop:
    Bflush(bout);
    c = lexc();
    switch(c) {
    case Eof:
        if(gotint) {
            gotint = 0;
            stacked = 0;
            Bprint(bout, "\nacid: ");
            goto loop;
        }
        return Eof;

    case '"':
        eatstring();
        return Tstring;

    case ' ':
    case '\t':
        goto loop;

    case '\n':
        line++;
        if(interactive == 0)
            goto loop;
        if(stacked) {
            print("\t");
            goto loop;
        }
        return ';';

    case '.':
        c = lexc();
        unlexc(c);
        if(isdigit(c))
            return numsym('.');

        return '.';
 
    case '(':
    case ')':
    case '[':
    case ']':
    case ';':
    case ':':
    case ',':
    case '~':
    case '?':
    case '*':
    case '@':
    case '^':
    case '%':
        return c;
    case '{':
        stacked++;
        return c;
    case '}':
        stacked--;
        return c;

    case '\\':
        c = lexc();
        if(strchr(vfmt, c) == 0) {
            unlexc(c);
            return '\\';
        }
        yylval.ival = c;
        return Tfmt;

    case '!':
        c = lexc();
        if(c == '=')
            return Tneq;
        unlexc(c);
        return '!';

    case '+':
        c = lexc();
        if(c == '+')
            return Tinc;
        unlexc(c);
        return '+';

    case '/':
        c = lexc();
        if(c == '/') {
            eatnl();
            goto loop;
        }
        unlexc(c);
        return '/';

    case '\'':
        c = lexc();
        if(c == '\\')
            yylval.ival = escchar(lexc());
        else
            yylval.ival = c;
        c = lexc();
        if(c != '\'') {
            error("missing '");
            unlexc(c);
        }
        return Tconst;

    case '&':
        c = lexc();
        if(c == '&')
            return Tandand;
        unlexc(c);
        return '&';

    case '=':
        c = lexc();
        if(c == '=')
            return Teq;
        unlexc(c);
        return '=';

    case '|':
        c = lexc();
        if(c == '|')
            return Toror;
        unlexc(c);
        return '|';

    case '<':
        c = lexc();
        if(c == '=')
            return Tleq;
        if(c == '<')
            return Tlsh;
        unlexc(c);
        return '<';

    case '>':
        c = lexc();
        if(c == '=')
            return Tgeq;
        if(c == '>')
            return Trsh;
        unlexc(c);
        return '>';

    case '-':
        c = lexc();

        if(c == '>')
            return Tindir;

        if(c == '-')
            return Tdec;
        unlexc(c);
        return '-';

    default:
        return numsym(c);
    }
}
@

<<function numsym>>=
int
numsym(char first)
{
    int c, isbin, isfloat, ishex;
    char *sel, *p;
    Lsym *s;

    symbol[0] = first;
    p = symbol;

    ishex = 0;
    isbin = 0;
    isfloat = 0;
    if(first == '.')
        isfloat = 1;

    if(isdigit(*p++) || isfloat) {
        for(;;) {
            c = lexc();
            if(c < 0)
                error("%d: <eof> eating symbols", line);

            if(c == '\n')
                line++;
            sel = "01234567890.xb";
            if(ishex)
                sel = "01234567890abcdefABCDEF";
            else if(isbin)
                sel = "01";
            else if(isfloat)
                sel = "01234567890eE-+";

            if(strchr(sel, c) == 0) {
                unlexc(c);
                break;
            }
            if(c == '.')
                isfloat = 1;
            if(!isbin && c == 'x')
                ishex = 1;
            if(!ishex && c == 'b')
                isbin = 1;
            *p++ = c;
        }
        *p = '\0';
        if(isfloat) {
            yylval.fval = atof(symbol);
            return Tfconst;
        }

        if(isbin)
            yylval.ival = strtoull(symbol+2, 0, 2);
        else
            yylval.ival = strtoull(symbol, 0, 0);
        return Tconst;
    }

    for(;;) {
        c = lexc();
        if(c < 0)
            error("%d <eof> eating symbols", line);
        if(c == '\n')
            line++;
        if(c != '_' && c != '$' && c <= '~' && !isalnum(c)) {	/* checking against ~ lets UTF names through */
            unlexc(c);
            break;
        }
        *p++ = c;
    }

    *p = '\0';

    s = look(symbol);
    if(s == 0)
        s = enter(symbol, Tid);

    yylval.sym = s;
    return s->lexval;
}
@
%$

<<function enter>>=
Lsym*
enter(char *name, int t)
{
    Lsym *s;
    uint h;
    char *p;
    Value *v;

    h = 0;
    for(p = name; *p; p++)
        h = h*3 + *p;
    h %= Hashsize;

    s = gmalloc(sizeof(Lsym));
    memset(s, 0, sizeof(Lsym));
    s->name = strdup(name);

    s->hash = hash[h];
    hash[h] = s;
    s->lexval = t;

    v = gmalloc(sizeof(Value));
    s->v = v;

    v->fmt = 'X';
    v->type = TINT;
    memset(v, 0, sizeof(Value));

    return s;
}
@

<<function look>>=
Lsym*
look(char *name)
{
    Lsym *s;
    uint h;
    char *p;

    h = 0;
    for(p = name; *p; p++)
        h = h*3 + *p;
    h %= Hashsize;

    for(s = hash[h]; s; s = s->hash)
        if(strcmp(name, s->name) == 0)
            return s;
    return 0;
}
@

<<function mkvar>>=
Lsym*
mkvar(char *s)
{
    Lsym *l;

    l = look(s);
    if(l == 0)
        l = enter(s, Tid);
    return l;
}
@


%-------------------------------------------------------------

<<acid/lex.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include "acid.h"
#include "y.tab.h"

<<global keywds>>

<<global cmap>>

<<function kinit>>

typedef struct IOstack IOstack;
<<struct IOstack>>
<<global lexio>>

<<function pushfile>>

<<function pushstr>>

<<function restartio>>

<<function popio>>

<<function Lfmt>>

<<function unlexc>>

<<function lexc>>

<<function escchar>>

<<function eatstring>>

<<function eatnl>>

<<function yylex>>

<<function numsym>>

<<function enter>>

<<function look>>

<<function mkvar>>
@


\subsection*{[[acid/main.c]]}

<<global bioout>>=
static Biobuf	bioout;
@

<<global prog>>=
static char	prog[128];
@

<<global lm>>=
static char*	lm[16];
@

<<global nlm>>=
static int	nlm;
@

<<global mtype>>=
static char*	mtype;
@

<<function usage (acid/main.c)>>=
void
usage(void)
{
    fprint(2, "usage: acid [-kqw] [-l library] [-m machine] [pid] [file]\n");
    exits("usage");
}
@

<<function main (acid/main.c)>>=
void
main(int argc, char *argv[])
{
    Lsym *l;
    Node *n;
    char *s;
    int pid, i;

    argv0 = argv[0];
    pid = 0;
    aout = "8.out";
    quiet = 1;

    mtype = 0;
    ARGBEGIN{
    case 'm':
        mtype = ARGF();
        break;
    case 'w':
        wtflag = 1;
        break;
    case 'l':
        s = ARGF();
        if(s == 0)
            usage();
        lm[nlm++] = s;
        break;
    case 'k':
        kernel++;
        break;
    case 'q':
        quiet = 0;
        break;
    case 'r':
        pid = 1;
        remote++;
        kernel++;
        break;
    default:
        usage();
    }ARGEND

    if(argc > 0) {
        if(remote)
            aout = argv[0];
        else
        if(isnumeric(argv[0])) {
            pid = strtol(argv[0], 0, 0);
            snprint(prog, sizeof(prog), "/proc/%d/text", pid);
            aout = prog;
            if(argc > 1)
                aout = argv[1];
            else if(kernel)
                aout = system();
        }
        else {
            if(kernel) {
                fprint(2, "acid: -k requires a pid\n");
                usage();
            }
            aout = argv[0];
        }
    } else
    if(remote)
        aout = "/mips/9ch";

    fmtinstall('x', xfmt);
    fmtinstall('L', Lfmt);
    Binit(&bioout, 1, OWRITE);
    bout = &bioout;

    kinit();
    initialising = 1;
    pushfile(0);
    loadvars();
    installbuiltin();

    if(mtype && machbyname(mtype) == 0)
        print("unknown machine %s", mtype);

    if (attachfiles(aout, pid) < 0)
        varreg();		/* use default register set on error */

    loadmodule("/sys/lib/acid/port");
    loadmoduleobjtype();

    for(i = 0; i < nlm; i++) {
        if(access(lm[i], AREAD) >= 0)
            loadmodule(lm[i]);
        else {
            s = smprint("/sys/lib/acid/%s", lm[i]);
            loadmodule(s);
            free(s);
        }
    }

    userinit();
    varsym();

    l = look("acidmap");
    if(l && l->proc) {
        n = an(ONAME, ZN, ZN);
        n->sym = l;
        n = an(OCALL, n, ZN);
        execute(n);
    }

    interactive = 1;
    initialising = 0;
    line = 1;

    notify(catcher);

    for(;;) {
        if(setjmp(err)) {
            Binit(&bioout, 1, OWRITE);
            unwind();
        }
        stacked = 0;

        Bprint(bout, "acid: ");

        if(yyparse() != 1)
            die();
        restartio();

        unwind();
    }
    /* not reached */
}
@

<<function attachfiles>>=
static int
attachfiles(char *aout, int pid)
{
    interactive = 0;
    if(setjmp(err))
        return -1;

    if(aout) {				/* executable given */
        if(wtflag)
            text = open(aout, ORDWR);
        else
            text = open(aout, OREAD);

        if(text < 0)
            error("%s: can't open %s: %r\n", argv0, aout);
        readtext(aout);
    }
    if(pid)					/* pid given */
        sproc(pid);
    return 0;
}
@

<<function die (acid/main.c)>>=
void
die(void)
{
    Lsym *s;
    List *f;

    Bprint(bout, "\n");

    s = look("proclist");
    if(s && s->v->type == TLIST) {
        for(f = s->v->l; f; f = f->next)
            Bprint(bout, "echo kill > /proc/%d/ctl\n", (int)f->ival);
    }
    exits(0);
}
@

<<function loadmoduleobjtype>>=
void
loadmoduleobjtype(void)
{
    char *buf;

    buf = smprint("/sys/lib/acid/%s", mach->name);
    loadmodule(buf);
    free(buf);
}
@

<<function userinit>>=
void
userinit(void)
{
    Lsym *l;
    Node *n;
    char *buf, *p;

    p = getenv("home");
    if(p != 0) {
        buf = smprint("%s/lib/acid", p);
        silent = 1;
        loadmodule(buf);
        free(buf);
    }

    interactive = 0;
    if(setjmp(err)) {
        unwind();
        return;
    }
    l = look("acidinit");
    if(l && l->proc) {
        n = an(ONAME, ZN, ZN);
        n->sym = l;
        n = an(OCALL, n, ZN);
        execute(n);
    }
}
@

<<function loadmodule>>=
void
loadmodule(char *s)
{
    interactive = 0;
    if(setjmp(err)) {
        unwind();
        return;
    }
    pushfile(s);
    silent = 0;
    yyparse();
    popio();
    return;
}
@

<<function readtext>>=
void
readtext(char *s)
{
    Dir *d;
    Lsym *l;
    Value *v;
    uvlong length;
    Symbol sym;
    extern Machdata armmach;

    if(mtype != 0){
        symmap = newmap(0, 1);
        if(symmap == 0)
            print("%s: (error) loadmap: cannot make symbol map\n", argv0);
        length = 1<<24;
        d = dirfstat(text);
        if(d != nil){
            length = d->length;
            free(d);
        }
        setmap(symmap, text, 0, length, 0, "binary");
        return;
    }

    machdata = &armmach;

    if(!crackhdr(text, &fhdr)) {
        print("can't decode file header\n");
        return;
    }

    symmap = loadmap(0, text, &fhdr);
    if(symmap == 0)
        print("%s: (error) loadmap: cannot make symbol map\n", argv0);

    if(syminit(text, &fhdr) < 0) {
        print("%s: (error) syminit: %r\n", argv0);
        return;
    }
    print("%s:%s\n", s, fhdr.name);

    if(mach->sbreg && lookup(0, mach->sbreg, &sym)) {
        mach->sb = sym.value;
        l = enter("SB", Tid);
        l->v->fmt = 'X';
        l->v->ival = mach->sb;
        l->v->type = TINT;
        l->v->set = 1;
    }

    l = mkvar("objtype");
    v = l->v;
    v->fmt = 's';
    v->set = 1;
    v->string = strnode(mach->name);
    v->type = TSTRING;

    l = mkvar("textfile");
    v = l->v;
    v->fmt = 's';
    v->set = 1;
    v->string = strnode(s);
    v->type = TSTRING;

    machbytype(fhdr.type);
    varreg();
}
@

<<function an>>=
Node*
an(int op, Node *l, Node *r)
{
    Node *n;

    n = gmalloc(sizeof(Node));
    memset(n, 0, sizeof(Node));
    n->gclink = gcl;
    gcl = n;
    n->op = op;
    n->left = l;
    n->right = r;
    return n;
}
@

<<function al>>=
List*
al(int t)
{
    List *l;

    l = gmalloc(sizeof(List));
    memset(l, 0, sizeof(List));
    l->type = t;
    l->gclink = gcl;
    gcl = l;
    return l;
}
@

<<function con>>=
Node*
con(vlong v)
{
    Node *n;

    n = an(OCONST, ZN, ZN);
    n->ival = v;
    n->fmt = 'W';
    n->type = TINT;
    return n;
}
@

<<function fatal (acid/main.c)>>=
void
fatal(char *fmt, ...)
{
    char buf[128];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    fprint(2, "%s: %L (fatal problem) %s\n", argv0, buf);
    exits(buf);
}
@

<<function yyerror>>=
void
yyerror(char *fmt, ...)
{
    char buf[128];
    va_list arg;

    if(strcmp(fmt, "syntax error") == 0) {
        yyerror("syntax error, near symbol '%s'", symbol);
        return;
    }
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%L: %s\n", buf);
}
@

<<function marktree>>=
void
marktree(Node *n)
{

    if(n == 0)
        return;

    marktree(n->left);
    marktree(n->right);

    n->gcmark = 1;
    if(n->op != OCONST)
        return;

    switch(n->type) {
    case TSTRING:
        n->string->gcmark = 1;
        break;
    case TLIST:
        marklist(n->l);
        break;
    case TCODE:
        marktree(n->cc);
        break;
    }
}
@

<<function marklist>>=
void
marklist(List *l)
{
    while(l) {
        l->gcmark = 1;
        switch(l->type) {
        case TSTRING:
            l->string->gcmark = 1;
            break;
        case TLIST:
            marklist(l->l);
            break;
        case TCODE:
            marktree(l->cc);
            break;
        }
        l = l->next;
    }
}
@

<<function gc>>=
void
gc(void)
{
    int i;
    Lsym *f;
    Value *v;
    Gc *m, **p, *next;

    if(dogc < Mempergc)
        return;
    dogc = 0;

    /* Mark */
    for(m = gcl; m; m = m->gclink)
        m->gcmark = 0;

    /* Scan */
    for(i = 0; i < Hashsize; i++) {
        for(f = hash[i]; f; f = f->hash) {
            marktree(f->proc);
            if(f->lexval != Tid)
                continue;
            for(v = f->v; v; v = v->pop) {
                switch(v->type) {
                case TSTRING:
                    v->string->gcmark = 1;
                    break;
                case TLIST:
                    marklist(v->l);
                    break;
                case TCODE:
                    marktree(v->cc);
                    break;
                }
            }
        }
    }

    /* Free */
    p = &gcl;
    for(m = gcl; m; m = next) {
        next = m->gclink;
        if(m->gcmark == 0) {
            *p = next;
            free(m);	/* Sleazy reliance on my malloc */
        }
        else
            p = &m->gclink;
    }
}
@

<<function gmalloc>>=
void*
gmalloc(long l)
{
    void *p;

    dogc += l;
    p = malloc(l);
    if(p == 0)
        fatal("out of memory");
    return p;
}
@

<<function checkqid>>=
void
checkqid(int f1, int pid)
{
    int fd;
    Dir *d1, *d2;
    char buf[128];

    if(kernel)
        return;

    d1 = dirfstat(f1);
    if(d1 == nil){
        print("checkqid: (qid not checked) dirfstat: %r\n");
        return;
    }

    snprint(buf, sizeof(buf), "/proc/%d/text", pid);
    fd = open(buf, OREAD);
    if(fd < 0 || (d2 = dirfstat(fd)) == nil){
        print("checkqid: (qid not checked) dirstat %s: %r\n", buf);
        free(d1);
        if(fd >= 0)
            close(fd);
        return;
    }

    close(fd);

    if(d1->qid.path != d2->qid.path || d1->qid.vers != d2->qid.vers || d1->qid.type != d2->qid.type){
        print("path %llux %llux vers %lud %lud type %d %d\n",
            d1->qid.path, d2->qid.path, d1->qid.vers, d2->qid.vers, d1->qid.type, d2->qid.type);
        print("warning: image does not match text for pid %d\n", pid);
    }
    free(d1);
    free(d2);
}
@

<<function catcher>>=
void
catcher(void *junk, char *s)
{
    USED(junk);

    if(strstr(s, "interrupt")) {
        gotint = 1;
        noted(NCONT);
    }
    noted(NDFLT);
}
@

<<function system>>=
char*
system(void)
{
    char *cpu, *p, *q;
    static char *kernel;

    cpu = getenv("cputype");
    if(cpu == 0) {
        cpu = "mips";
        print("$cputype not set; assuming %s\n", cpu);
    }
    p = getenv("terminal");
    if(p == 0 || (p=strchr(p, ' ')) == 0 || p[1] == ' ' || p[1] == 0) {
        p = "ch";
        print("missing or bad $terminal; assuming %s\n", p);
    }
    else{
        p++;
        q = strchr(p, ' ');
        if(q)
            *q = 0;
    }

    if(kernel != nil)
        free(kernel);
    kernel = smprint("/%s/9%s", cpu, p);

    return kernel;
}
@

<<function isnumeric>>=
int
isnumeric(char *s)
{
    while(*s) {
        if(*s < '0' || *s > '9')
            return 0;
        s++;
    }
    return 1;
}
@

<<function xfmt>>=
int
xfmt(Fmt *f)
{
    f->flags ^= FmtSharp;
    return _ifmt(f);
}
@


%-------------------------------------------------------------

<<acid/main.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>
#include "acid.h"
#include "y.tab.h"

extern int _ifmt(Fmt*);

<<global bioout>>
<<global prog>>
<<global lm>>
<<global nlm>>
<<global mtype>>

static	int attachfiles(char*, int);
int	xfmt(Fmt*);
int	isnumeric(char*);
void	die(void);
void	loadmoduleobjtype(void);

<<function usage (acid/main.c)>>

<<function main (acid/main.c)>>

<<function attachfiles>>

<<function die (acid/main.c)>>

<<function loadmoduleobjtype>>

<<function userinit>>

<<function loadmodule>>

<<function readtext>>

<<function an>>

<<function al>>

<<function con>>

<<function fatal (acid/main.c)>>

<<function yyerror>>

<<function marktree>>

<<function marklist>>

<<function gc>>

<<function gmalloc>>

<<function checkqid>>

<<function catcher>>

<<function system>>

<<function isnumeric>>

<<function xfmt>>
@


\subsection*{[[acid/util.c]]}

<<global syren>>=
static int syren;
@

<<function unique>>=
Lsym*
unique(char *buf, Sym *s)
{
    Lsym *l;
    int i, renamed;

    renamed = 0;
    strcpy(buf, s->name);
    for(;;) {
        l = look(buf);
        if(l == 0 || (l->lexval == Tid && l->v->set == 0))
            break;

        if(syren == 0 && !quiet) {
            print("Symbol renames:\n");
            syren = 1;
        }
        i = strlen(buf)+1;
        memmove(buf+1, buf, i);
        buf[0] = '$';
        renamed++;
        if(renamed > 5 && !quiet) {
            print("Too many renames; must be X source!\n");
            break;
        }
    }
    if(renamed && !quiet)
        print("\t%s=%s %c/%llux\n", s->name, buf, s->type, s->value);
    if(l == 0)
        l = enter(buf, Tid);
    return l;	
}
@

<<function varsym>>=
void
varsym(void)
{
    int i;
    Sym *s;
    long n;
    Lsym *l;
    uvlong v;
    char buf[1024];
    List *list, **tail, *l2, *tl;

    tail = &l2;
    l2 = 0;

    symbase(&n);
    for(i = 0; i < n; i++) {
        s = getsym(i);
        switch(s->type) {
        case 'T':
        case 'L':
        case 'D':
        case 'B':
        case 'b':
        case 'd':
        case 'l':
        case 't':
            if(s->name[0] == '.')
                continue;

            v = s->value;
            tl = al(TLIST);
            *tail = tl;
            tail = &tl->next;

            l = unique(buf, s);

            l->v->set = 1;
            l->v->type = TINT;
            l->v->ival = v;
            if(l->v->comt == 0)
                l->v->fmt = 'X';

            /* Enter as list of { name, type, value } */
            list = al(TSTRING);
            tl->l = list;
            list->string = strnode(buf);
            list->fmt = 's';
            list->next = al(TINT);
            list = list->next;
            list->fmt = 'c';
            list->ival = s->type;
            list->next = al(TINT);
            list = list->next;
            list->fmt = 'X';
            list->ival = v;

        }
    }
    l = mkvar("symbols");
    l->v->set = 1;
    l->v->type = TLIST;
    l->v->l = l2;
    if(l2 == 0)
        print("no symbol information\n");
}
@
%$

<<function varreg>>=
void
varreg(void)
{
    Lsym *l;
    Value *v;
    Reglist *r;
    List **tail, *li;

    l = mkvar("registers");
    v = l->v;
    v->set = 1;
    v->type = TLIST;
    v->l = 0;
    tail = &v->l;

    for(r = mach->reglist; r->rname; r++) {
        l = mkvar(r->rname);
        v = l->v;
        v->set = 1;
        v->ival = r->roffs;
        v->fmt = r->rformat;
        v->type = TINT;

        li = al(TSTRING);
        li->string = strnode(r->rname);
        li->fmt = 's';
        *tail = li;
        tail = &li->next;
    }

    if(machdata == 0)
        return;

    l = mkvar("bpinst");	/* Breakpoint text */
    v = l->v;
    v->type = TSTRING;
    v->fmt = 's';
    v->set = 1;
    v->string = gmalloc(sizeof(String));
    v->string->len = machdata->bpsize;
    v->string->string = gmalloc(machdata->bpsize);
    memmove(v->string->string, machdata->bpinst, machdata->bpsize);
}
@

<<function loadvars>>=
void
loadvars(void)
{
    Lsym *l;
    Value *v;

    l =  mkvar("proc");
    v = l->v;
    v->type = TINT;
    v->fmt = 'X';
    v->set = 1;
    v->ival = 0;

    l = mkvar("pid");		/* Current process */
    v = l->v;
    v->type = TINT;
    v->fmt = 'D';
    v->set = 1;
    v->ival = 0;

    mkvar("notes");			/* Pending notes */

    l = mkvar("proclist");		/* Attached processes */
    l->v->type = TLIST;
}
@

<<function rget (acid/util.c)>>=
uvlong
rget(Map *map, char *reg)
{
    Lsym *s;
    ulong x;
    uvlong v;
    int ret;

    s = look(reg);
    if(s == 0)
        fatal("rget: %s\n", reg);

    switch(s->v->fmt){
    default:
        ret = get4(map, s->v->ival, &x);
        v = x;
        break;
    case 'V':
    case 'W':
    case 'Y':
    case 'Z':
        ret = get8(map, s->v->ival, &v);
        break;
    }
    if(ret < 0)
        error("can't get register %s: %r\n", reg);
    return v;
}
@

<<function strnodlen>>=
String*
strnodlen(char *name, int len)
{
    String *s;

    s = gmalloc(sizeof(String)+len+1);
    s->string = (char*)s+sizeof(String);
    s->len = len;
    if(name != 0)
        memmove(s->string, name, len);
    s->string[len] = '\0';

    s->gclink = gcl;
    gcl = s;

    return s;
}
@

<<function strnode>>=
String*
strnode(char *name)
{
    return strnodlen(name, strlen(name));
}
@

<<function runenode>>=
String*
runenode(Rune *name)
{
    int len;
    Rune *p;
    String *s;

    p = name;
    for(len = 0; *p; p++)
        len++;

    len++;
    len *= sizeof(Rune);
    s = gmalloc(sizeof(String)+len);
    s->string = (char*)s+sizeof(String);
    s->len = len;
    memmove(s->string, name, len);

    s->gclink = gcl;
    gcl = s;

    return s;
}
@

<<function stradd>>=
String*
stradd(String *l, String *r)
{
    int len;
    String *s;

    len = l->len+r->len;
    s = gmalloc(sizeof(String)+len+1);
    s->gclink = gcl;
    gcl = s;
    s->len = len;
    s->string = (char*)s+sizeof(String);
    memmove(s->string, l->string, l->len);
    memmove(s->string+l->len, r->string, r->len);
    s->string[s->len] = 0;
    return s;
}
@

<<function straddrune>>=
String*
straddrune(String *l, Rune r)
{
    int len;
    String *s;

    len = l->len+runelen(r);
    s = gmalloc(sizeof(String)+len+1);
    s->gclink = gcl;
    gcl = s;
    s->len = len;
    s->string = (char*)s+sizeof(String);
    memmove(s->string, l->string, l->len);
    runetochar(s->string+l->len, &r);
    s->string[s->len] = 0;
    return s;
}
@

<<function scmp>>=
int
scmp(String *sr, String *sl)
{
    if(sr->len != sl->len)
        return 0;

    if(memcmp(sr->string, sl->string, sl->len))
        return 0;

    return 1;
}
@


%-------------------------------------------------------------

<<acid/util.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include "acid.h"
#include "y.tab.h"

<<global syren>>

<<function unique>>

<<function varsym>>

<<function varreg>>

<<function loadvars>>

<<function rget (acid/util.c)>>

<<function strnodlen>>

<<function strnode>>

<<function runenode>>

<<function stradd>>

<<function straddrune>>

<<function scmp>>
@


\subsection*{[[acid/exec.c]]}

<<function error (acid/exec.c)>>=
void
error(char *fmt, ...)
{
    int i;
    char buf[2048];
    va_list arg;

    /* Unstack io channels */
    if(iop != 0) {
        for(i = 1; i < iop; i++)
            Bterm(io[i]);
        bout = io[0];
        iop = 0;
    }

    ret = 0;
    gotint = 0;
    Bflush(bout);
    if(silent)
        silent = 0;
    else {
        va_start(arg, fmt);
        vseprint(buf, buf+sizeof(buf), fmt, arg);
        va_end(arg);
        fprint(2, "%L: (error) %s\n", buf);
    }
    while(popio())
        ;
    interactive = 1;
    longjmp(err, 1);
}
@

<<function unwind>>=
void
unwind(void)
{
    int i;
    Lsym *s;
    Value *v;

    for(i = 0; i < Hashsize; i++) {
        for(s = hash[i]; s; s = s->hash) {
            while(s->v->pop) {
                v = s->v->pop;
                free(s->v);
                s->v = v;
            }
        }
    }
}
@

<<function execute>>=
void
execute(Node *n)
{
    Value *v;
    Lsym *sl;
    Node *l, *r;
    vlong i, s, e;
    Node res, xx;
    static int stmnt;

    gc();
    if(gotint)
        error("interrupted");

    if(n == 0)
        return;

    if(stmnt++ > 5000) {
        Bflush(bout);
        stmnt = 0;
    }

    l = n->left;
    r = n->right;

    switch(n->op) {
    default:
        expr(n, &res);
        if(ret || (res.type == TLIST && res.l == 0 && n->op != OADD))
            break;
        prnt->right = &res;
        expr(prnt, &xx);
        break;
    case OASGN:
    case OCALL:
        expr(n, &res);
        break;
    case OCOMPLEX:
        decl(n);
        break;
    case OLOCAL:
        for(n = n->left; n; n = n->left) {
            if(ret == 0)
                error("local not in function");
            sl = n->sym;
            if(sl->v->ret == ret)
                error("%s declared twice", sl->name);
            v = gmalloc(sizeof(Value));
            v->ret = ret;
            v->pop = sl->v;
            sl->v = v;
            v->scope = 0;
            *(ret->tail) = sl;
            ret->tail = &v->scope;
            v->set = 0;
        }
        break;
    case ORET:
        if(ret == 0)
            error("return not in function");
        expr(n->left, ret->val);
        longjmp(ret->rlab, 1);
    case OLIST:
        execute(n->left);
        execute(n->right);
        break;
    case OIF:
        expr(l, &res);
        if(r && r->op == OELSE) {
            if(fbool(&res))
                execute(r->left);
            else
                execute(r->right);
        }
        else if(fbool(&res))
            execute(r);
        break;
    case OWHILE:
        for(;;) {
            expr(l, &res);
            if(!fbool(&res))
                break;
            execute(r);
        }
        break;
    case ODO:
        expr(l->left, &res);
        if(res.type != TINT)
            error("loop must have integer start");
        s = res.ival;
        expr(l->right, &res);
        if(res.type != TINT)
            error("loop must have integer end");
        e = res.ival;
        for(i = s; i <= e; i++)
            execute(r);
        break;
    }
}
@

<<function fbool>>=
int
fbool(Node *n)
{
    int true = 0;

    if(n->op != OCONST)
        fatal("fbool: not const");

    switch(n->type) {
    case TINT:
        if(n->ival != 0)
            true = 1;
        break;
    case TFLOAT:
        if(n->fval != 0.0)
            true = 1;
        break;
    case TSTRING:
        if(n->string->len)
            true = 1;
        break;
    case TLIST:
        if(n->l)
            true = 1;
        break;
    }
    return true;
}
@

<<function convflt>>=
void
convflt(Node *r, char *flt)
{
    char c;

    c = flt[0];
    if(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
        r->type = TSTRING;
        r->fmt = 's';
        r->string = strnode(flt);
    }
    else {
        r->type = TFLOAT;
        r->fval = atof(flt);
    }
}
@

<<function indir>>=
void
indir(Map *m, uvlong addr, char fmt, Node *r)
{
    int i;
    ulong lval;
    uvlong uvval;
    int ret;
    uchar cval;
    ushort sval;
    char buf[512], reg[12];

    r->op = OCONST;
    r->fmt = fmt;
    switch(fmt) {
    default:
        error("bad pointer format '%c' for *", fmt);
    case 'c':
    case 'C':
    case 'b':
        r->type = TINT;
        ret = get1(m, addr, &cval, 1);
        if (ret < 0)
            error("indir: %r");
        r->ival = cval;
        break;
    case 'x':
    case 'd':
    case 'u':
    case 'o':
    case 'q':
    case 'r':
        r->type = TINT;
        ret = get2(m, addr, &sval);
        if (ret < 0)
            error("indir: %r");
        r->ival = sval;
        break;
    case 'a':
    case 'A':
    case 'W':
        r->type = TINT;
        ret = geta(m, addr, &uvval);
        if (ret < 0)
            error("indir: %r");
        r->ival = uvval;
        break;
    case 'B':
    case 'X':
    case 'D':
    case 'U':
    case 'O':
    case 'Q':
        r->type = TINT;
        ret = get4(m, addr, &lval);
        if (ret < 0)
            error("indir: %r");
        r->ival = lval;
        break;
    case 'V':
    case 'Y':
    case 'Z':
        r->type = TINT;
        ret = get8(m, addr, &uvval);
        if (ret < 0)
            error("indir: %r");
        r->ival = uvval;
        break;
    case 's':
        r->type = TSTRING;
        for(i = 0; i < sizeof(buf)-1; i++) {
            ret = get1(m, addr, (uchar*)&buf[i], 1);
            if (ret < 0)
                error("indir: %r");
            addr++;
            if(buf[i] == '\0')
                break;
        }
        buf[i] = 0;
        if(i == 0)
            strcpy(buf, "(null)");
        r->string = strnode(buf);
        break;
    case 'R':
        r->type = TSTRING;
        for(i = 0; i < sizeof(buf)-2; i += 2) {
            ret = get1(m, addr, (uchar*)&buf[i], 2);
            if (ret < 0)
                error("indir: %r");
            addr += 2;
            if(buf[i] == 0 && buf[i+1] == 0)
                break;
        }
        buf[i++] = 0;
        buf[i] = 0;
        r->string = runenode((Rune*)buf);
        break;
    case 'i':
    case 'I':
        if ((*machdata->das)(m, addr, fmt, buf, sizeof(buf)) < 0)
            error("indir: %r");
        r->type = TSTRING;
        r->fmt = 's';
        r->string = strnode(buf);
        break;
    case 'f':
        ret = get1(m, addr, (uchar*)buf, mach->szfloat);
        if (ret < 0)
            error("indir: %r");
        machdata->sftos(buf, sizeof(buf), (void*) buf);
        convflt(r, buf);
        break;
    case 'g':
        ret = get1(m, addr, (uchar*)buf, mach->szfloat);
        if (ret < 0)
            error("indir: %r");
        machdata->sftos(buf, sizeof(buf), (void*) buf);
        r->type = TSTRING;
        r->string = strnode(buf);
        break;
    case 'F':
        ret = get1(m, addr, (uchar*)buf, mach->szdouble);
        if (ret < 0)
            error("indir: %r");
        machdata->dftos(buf, sizeof(buf), (void*) buf);
        convflt(r, buf);
        break;
    case '3':	/* little endian ieee 80 with hole in bytes 8&9 */
        ret = get1(m, addr, (uchar*)reg, 10);
        if (ret < 0)
            error("indir: %r");
        memmove(reg+10, reg+8, 2);	/* open hole */
        memset(reg+8, 0, 2);		/* fill it */
        leieee80ftos(buf, sizeof(buf), reg);
        convflt(r, buf);
        break;
    case '8':	/* big-endian ieee 80 */
        ret = get1(m, addr, (uchar*)reg, 10);
        if (ret < 0)
            error("indir: %r");
        beieee80ftos(buf, sizeof(buf), reg);
        convflt(r, buf);
        break;
    case 'G':
        ret = get1(m, addr, (uchar*)buf, mach->szdouble);
        if (ret < 0)
            error("indir: %r");
        machdata->dftos(buf, sizeof(buf), (void*) buf);
        r->type = TSTRING;
        r->string = strnode(buf);
        break;
    }
}
@

<<function windir>>=
void
windir(Map *m, Node *addr, Node *rval, Node *r)
{
    uchar cval;
    ushort sval;
    long lval;
    Node res, aes;
    int ret;

    if(m == 0)
        error("no map for */@=");

    expr(rval, &res);
    expr(addr, &aes);

    if(aes.type != TINT)
        error("bad type lhs of @/*");

    if(m != cormap && wtflag == 0)
        error("not in write mode");

    r->type = res.type;
    r->fmt = res.fmt;
    r->Store = res.Store;

    switch(res.fmt) {
    default:
        error("bad pointer format '%c' for */@=", res.fmt);
    case 'c':
    case 'C':
    case 'b':
        cval = res.ival;
        ret = put1(m, aes.ival, &cval, 1);
        break;
    case 'r':
    case 'x':
    case 'd':
    case 'u':
    case 'o':
        sval = res.ival;
        ret = put2(m, aes.ival, sval);
        r->ival = sval;
        break;
    case 'a':
    case 'A':
    case 'W':
        ret = puta(m, aes.ival, res.ival);
        break;
    case 'B':
    case 'X':
    case 'D':
    case 'U':
    case 'O':
        lval = res.ival;
        ret = put4(m, aes.ival, lval);
        break;
    case 'V':
    case 'Y':
    case 'Z':
        ret = put8(m, aes.ival, res.ival);
        break;
    case 's':
    case 'R':
        ret = put1(m, aes.ival, (uchar*)res.string->string, res.string->len);
        break;
    }
    if (ret < 0)
        error("windir: %r");
}
@

<<function call>>=
void
call(char *fn, Node *parameters, Node *local, Node *body, Node *retexp)
{
    int np, i;
    Rplace rlab;
    Node *n, res;
    Value *v, *f;
    Lsym *s, *next;
    Node *avp[Maxarg], *ava[Maxarg];

    rlab.local = 0;

    na = 0;
    flatten(avp, parameters);
    np = na;
    na = 0;
    flatten(ava, local);
    if(np != na) {
        if(np < na)
            error("%s: too few arguments", fn);
        error("%s: too many arguments", fn);
    }

    rlab.tail = &rlab.local;

    ret = &rlab;
    for(i = 0; i < np; i++) {
        n = ava[i];
        switch(n->op) {
        default:
            error("%s: %d formal not a name", fn, i);
        case ONAME:
            expr(avp[i], &res);
            s = n->sym;
            break;
        case OINDM:
            res.cc = avp[i];
            res.type = TCODE;
            res.comt = 0;
            if(n->left->op != ONAME)
                error("%s: %d formal not a name", fn, i);
            s = n->left->sym;
            break;
        }
        if(s->v->ret == ret)
            error("%s already declared at this scope", s->name);

        v = gmalloc(sizeof(Value));
        v->ret = ret;
        v->pop = s->v;
        s->v = v;
        v->scope = 0;
        *(rlab.tail) = s;
        rlab.tail = &v->scope;

        v->Store = res.Store;
        v->type = res.type;
        v->set = 1;
    }

    ret->val = retexp;
    if(setjmp(rlab.rlab) == 0)
        execute(body);

    for(s = rlab.local; s; s = next) {
        f = s->v;
        next = f->scope;
        s->v = f->pop;
        free(f);
    }
}
@


%-------------------------------------------------------------

<<acid/exec.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include "acid.h"

<<function error (acid/exec.c)>>

<<function unwind>>

<<function execute>>

<<function fbool>>

<<function convflt>>

<<function indir>>

<<function windir>>

<<function call>>
@


\subsection*{[[acid/proc.c]]}

<<function nocore>>=
void
nocore(void)
{
    int i;

    if(cormap == 0)
        return;

    for (i = 0; i < cormap->nsegs; i++)
        if (cormap->seg[i].inuse && cormap->seg[i].fd >= 0)
            close(cormap->seg[i].fd);
    free(cormap);
    cormap = 0;
}
@

<<function sproc>>=
void
sproc(int pid)
{
    Lsym *s;
    char buf[64];
    int i, fcor;

    if(symmap == 0)
        error("no map");

    snprint(buf, sizeof(buf), "/proc/%d/mem", pid);
    fcor = open(buf, ORDWR);
    if(fcor < 0)
        error("setproc: open %s: %r", buf);

    checkqid(symmap->seg[0].fd, pid);

    s = look("pid");
    s->v->ival = pid;

    nocore();
    cormap = attachproc(pid, kernel, fcor, &fhdr);
    if (cormap == 0)
        error("setproc: can't make coremap: %r");
    i = findseg(cormap, "text");
    if (i > 0)
        cormap->seg[i].name = "*text";
    i = findseg(cormap, "data");
    if (i > 0)
        cormap->seg[i].name = "*data";
    install(pid);
}
@

<<function nproc>>=
int
nproc(char **argv)
{
    char buf[128];
    int pid, i, fd;

    pid = fork();
    switch(pid) {
    case -1:
        error("new: fork %r");
    case 0:
        rfork(RFNAMEG|RFNOTEG);

        snprint(buf, sizeof(buf), "/proc/%d/ctl", getpid());
        fd = open(buf, ORDWR);
        if(fd < 0)
            fatal("new: open %s: %r", buf);
        write(fd, "hang", 4);
        close(fd);

        close(0);
        close(1);
        close(2);
        for(i = 3; i < NFD; i++)
            close(i);

        open("/dev/cons", OREAD);
        open("/dev/cons", OWRITE);
        open("/dev/cons", OWRITE);
        exec(argv[0], argv);
        fatal("new: exec %s: %r");
    default:
        install(pid);
        msg(pid, "waitstop");
        notes(pid);
        sproc(pid);
        dostop(pid);
        break;
    }

    return pid;
}
@

<<function notes (acid/proc.c)>>=
void
notes(int pid)
{
    Lsym *s;
    Value *v;
    int i, fd;
    char buf[128];
    List *l, **tail;

    s = look("notes");
    if(s == 0)
        return;
    v = s->v;

    snprint(buf, sizeof(buf), "/proc/%d/note", pid);
    fd = open(buf, OREAD);
    if(fd < 0)
        error("pid=%d: open note: %r", pid);

    v->set = 1;
    v->type = TLIST;
    v->l = 0;
    tail = &v->l;
    for(;;) {
        i = read(fd, buf, sizeof(buf));
        if(i <= 0)
            break;
        buf[i] = '\0';
        l = al(TSTRING);
        l->string = strnode(buf);
        l->fmt = 's';
        *tail = l;
        tail = &l->next;
    }
    close(fd);
}
@

<<function dostop>>=
void
dostop(int pid)
{
    Lsym *s;
    Node *np, *p;

    s = look("stopped");
    if(s && s->proc) {
        np = an(ONAME, ZN, ZN);
        np->sym = s;
        np->fmt = 'D';
        np->type = TINT;
        p = con(pid);
        p->fmt = 'D';
        np = an(OCALL, np, p);
        execute(np);
    }
}
@

<<function install>>=
static void
install(int pid)
{
    Lsym *s;
    List *l;
    char buf[128];
    int i, fd, new, p;

    new = -1;
    for(i = 0; i < Maxproc; i++) {
        p = ptab[i].pid;
        if(p == pid)
            return;
        if(p == 0 && new == -1)
            new = i;
    }
    if(new == -1)
        error("no free process slots");

    snprint(buf, sizeof(buf), "/proc/%d/ctl", pid);
    fd = open(buf, OWRITE);
    if(fd < 0)
        error("pid=%d: open ctl: %r", pid);
    ptab[new].pid = pid;
    ptab[new].ctl = fd;

    s = look("proclist");
    l = al(TINT);
    l->fmt = 'D';
    l->ival = pid;
    l->next = s->v->l;
    s->v->l = l;
    s->v->set = 1;
}
@

<<function deinstall>>=
void
deinstall(int pid)
{
    int i;
    Lsym *s;
    List *f, **d;

    for(i = 0; i < Maxproc; i++) {
        if(ptab[i].pid == pid) {
            close(ptab[i].ctl);
            ptab[i].pid = 0;
            s = look("proclist");
            d = &s->v->l;
            for(f = *d; f; f = f->next) {
                if(f->ival == pid) {
                    *d = f->next;
                    break;
                }
            }
            s = look("pid");
            if(s->v->ival == pid)
                s->v->ival = 0;
            return;
        }
    }
}
@

<<function msg>>=
void
msg(int pid, char *msg)
{
    int i;
    int l;
    char err[ERRMAX];

    for(i = 0; i < Maxproc; i++) {
        if(ptab[i].pid == pid) {
            l = strlen(msg);
            if(write(ptab[i].ctl, msg, l) != l) {
                errstr(err, sizeof err);
                if(strcmp(err, "process exited") == 0)
                    deinstall(pid);
                error("msg: pid=%d %s: %s", pid, msg, err);
            }
            return;
        }
    }
    error("msg: pid=%d: not found for %s", pid, msg);
}
@

<<function getstatus>>=
char *
getstatus(int pid)
{
    int fd, n;
    char *argv[16], buf[64];
    static char status[128];

    snprint(buf, sizeof(buf), "/proc/%d/status", pid);
    fd = open(buf, OREAD);
    if(fd < 0)
        error("open %s: %r", buf);

    n = read(fd, status, sizeof(status)-1);
    close(fd);
    if(n <= 0)
        error("read %s: %r", buf);
    status[n] = '\0';

    if(tokenize(status, argv, nelem(argv)-1) < 3)
        error("tokenize %s: %r", buf);

    return argv[2];
}
@

<<function waitfor>>=
Waitmsg*
waitfor(int pid)
{
    Waitmsg *w;

    for(;;) {
        if((w = wait()) == nil)
            error("wait %r");
        if(w->pid == pid)
            return w;
        free(w);
    }
}
@


%-------------------------------------------------------------

<<acid/proc.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include "acid.h"
#include "y.tab.h"

static void install(int);

<<function nocore>>

<<function sproc>>

<<function nproc>>

<<function notes (acid/proc.c)>>

<<function dostop>>

<<function install>>

<<function deinstall>>

<<function msg>>

<<function getstatus>>

<<function waitfor>>
@


\subsection*{[[acid/list.c]]}

<<global tail>>=
static List **tail;
@

<<function construct>>=
List*
construct(Node *l)
{
    List *lh, **save;

    save = tail;
    lh = 0;
    tail = &lh;
    build(l);
    tail = save;

    return lh;
}
@

<<function listlen>>=
int
listlen(List *l)
{
    int len;

    len = 0;
    while(l) {
        len++;
        l = l->next;
    }
    return len;
}
@

<<function build>>=
void
build(Node *n)
{
    List *l;
    Node res;

    if(n == 0)
        return;

    switch(n->op) {
    case OLIST:
        build(n->left);
        build(n->right);
        return;
    default:
        expr(n, &res);
        l = al(res.type);
        l->Store = res.Store;
        *tail = l;
        tail = &l->next;	
    }
}
@

<<function addlist>>=
List*
addlist(List *l, List *r)
{
    List *f;

    if(l == 0)
        return r;

    for(f = l; f->next; f = f->next)
        ;
    f->next = r;

    return l;
}
@

<<function append>>=
void
append(Node *r, Node *list, Node *val)
{
    List *l, *f;

    l = al(val->type);
    l->Store = val->Store;
    l->next = 0;

    r->op = OCONST;
    r->type = TLIST;

    if(list->l == 0) {
        list->l = l;
        r->l = l;
        return;
    }
    for(f = list->l; f->next; f = f->next)
        ;
    f->next = l;
    r->l = list->l;
}
@

<<function listcmp>>=
int
listcmp(List *l, List *r)
{
    if(l == r)
        return 1;

    while(l) {
        if(r == 0)
            return 0;
        if(l->type != r->type)
            return 0;
        switch(l->type) {
        case TINT:
            if(l->ival != r->ival)
                return 0;
            break;
        case TFLOAT:
            if(l->fval != r->fval)
                return 0;
            break;
        case TSTRING:
            if(scmp(l->string, r->string) == 0)
                return 0;
            break;
        case TLIST:
            if(listcmp(l->l, r->l) == 0)
                return 0;
            break;
        }
        l = l->next;
        r = r->next;
    }
    if(l != r)
        return 0;
    return 1;
}
@

<<function nthelem>>=
void
nthelem(List *l, int n, Node *res)
{
    if(n < 0)
        error("negative index in []");

    while(l && n--)
        l = l->next;

    res->op = OCONST;
    if(l == 0) {
        res->type = TLIST;
        res->l = 0;
        return;
    }
    res->type = l->type;
    res->Store = l->Store;
}
@

<<function delete>>=
void
delete(List *l, int n, Node *res)
{
    List **tl;

    if(n < 0)
        error("negative index in delete");

    res->op = OCONST;
    res->type = TLIST;
    res->l = l;

    for(tl = &res->l; l && n--; l = l->next)
        tl = &l->next;

    if(l == 0)
        error("element beyond end of list");
    *tl = l->next;
}
@

<<function listvar>>=
List*
listvar(char *s, vlong v)
{
    List *l, *tl;

    tl = al(TLIST);

    l = al(TSTRING);
    tl->l = l;
    l->fmt = 's';
    l->string = strnode(s);
    l->next = al(TINT);
    l = l->next;
    l->fmt = 'X';
    l->ival = v;

    return tl;
}
@

<<function listlocals>>=
static List*
listlocals(Map *map, Symbol *fn, uvlong fp)
{
    int i;
    uvlong val;
    Symbol s;
    List **tail, *l2;

    l2 = 0;
    tail = &l2;
    s = *fn;

    for(i = 0; localsym(&s, i); i++) {
        if(s.class != CAUTO)
            continue;
        if(s.name[0] == '.')
            continue;

        if(geta(map, fp-s.value, &val) > 0) {
            *tail = listvar(s.name, val);
            tail = &(*tail)->next;
        }
    }
    return l2;
}
@

<<function listparams>>=
static List*
listparams(Map *map, Symbol *fn, uvlong fp)
{
    int i;
    Symbol s;
    uvlong v;
    List **tail, *l2;

    l2 = 0;
    tail = &l2;
    fp += mach->szaddr;			/* skip saved pc */
    s = *fn;
    for(i = 0; localsym(&s, i); i++) {
        if (s.class != CPARAM)
            continue;

        if(geta(map, fp+s.value, &v) > 0) {
            *tail = listvar(s.name, v);
            tail = &(*tail)->next;
        }
    }
    return l2;
}
@

<<function trlist>>=
void
trlist(Map *map, uvlong pc, uvlong sp, Symbol *sym)
{
    List *q, *l;

    static List **tail;

    if (tracelist == 0) {		/* first time */
        tracelist = al(TLIST);
        tail = &tracelist;
    }

    q = al(TLIST);
    *tail = q;
    tail = &q->next;

    l = al(TINT);			/* Function address */
    q->l = l;
    l->ival = sym->value;
    l->fmt = 'X';

    l->next = al(TINT);		/* called from address */
    l = l->next;
    l->ival = pc;
    l->fmt = 'Y';

    l->next = al(TLIST);		/* make list of params */
    l = l->next;
    l->l = listparams(map, sym, sp);

    l->next = al(TLIST);		/* make list of locals */
    l = l->next;
    l->l = listlocals(map, sym, sp);
}
@


%-------------------------------------------------------------

<<acid/list.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include "acid.h"

<<global tail>>

<<function construct>>

<<function listlen>>

<<function build>>

<<function addlist>>

<<function append>>

<<function listcmp>>

<<function nthelem>>

<<function delete>>

<<function listvar>>

<<function listlocals>>

<<function listparams>>

<<function trlist>>
@


\subsection*{[[acid/dot.c]]}

<<function srch>>=
Type*
srch(Type *t, char *s)
{
    Type *f;

    f = 0;
    while(t) {
        if(strcmp(t->tag->name, s) == 0) {
            if(f == 0 || t->depth < f->depth)
                f = t;
        }
        t = t->next;
    }
    return f;
}
@

<<function odot>>=
void
odot(Node *n, Node *r)
{
    char *s;
    Type *t;
    Node res;
    uvlong addr;

    s = n->sym->name;
    if(s == 0)
        fatal("dodot: no tag");

    expr(n->left, &res);
    if(res.comt == 0)
        error("no type specified for (expr).%s", s);

    if(res.type != TINT)
        error("pointer must be integer for (expr).%s", s);

    t = srch(res.comt, s);
    if(t == 0)
        error("no tag for (expr).%s", s);

    /* Propagate types */
    if(t->type) 
        r->comt = t->type->lt;
    
    addr = res.ival+t->offset;
    if(t->fmt == 'a') {
        r->op = OCONST;
        r->fmt = 'a';
        r->type = TINT;
        r->ival = addr;
    }
    else 
        indir(cormap, addr, t->fmt, r);

}
@

<<global tail (acid/dot.c)>>=
static Type **tail;
@

<<global base>>=
static Lsym *base;
@

<<function buildtype>>=
void
buildtype(Node *m, int d)
{
    Type *t;

    if(m == ZN)
        return;

    switch(m->op) {
    case OLIST:
        buildtype(m->left, d);		
        buildtype(m->right, d);
        break;

    case OCTRUCT:
        buildtype(m->left, d+1);
        break;
    default:
        t = malloc(sizeof(Type));
        t->next = 0;
        t->depth = d;
        t->tag = m->sym;
        t->base = base;
        t->offset = m->ival;
        if(m->left) {
            t->type = m->left->sym;
            t->fmt = 'a';			
        }
        else {
            t->type = 0;
            if(m->right)
                t->type = m->right->sym;
            t->fmt = m->fmt;
        }

        *tail = t;
        tail = &t->next;
    }			
}
@

<<function defcomplex>>=
void
defcomplex(Node *tn, Node *m)
{
    tail = &tn->sym->lt;
    base = tn->sym;
    buildtype(m, 0);
}
@

<<function decl>>=
void
decl(Node *n)
{
    Node *l;
    Value *v;
    Frtype *f;
    Lsym *type;

    type = n->sym;
    if(type->lt == 0)
        error("%s is not a complex type", type->name);

    l = n->left;
    if(l->op == ONAME) {
        v = l->sym->v;
        v->comt = type->lt;
        v->fmt = 'a';
        return;
    }

    /*
     * Frame declaration
     */
    for(f = l->sym->local; f; f = f->next) {
        if(f->var == l->left->sym) {
            f->type = n->sym->lt;
            return;
        }
    }
    f = malloc(sizeof(Frtype));
    if(f == 0)
        fatal("out of memory");

    f->type = type->lt;

    f->var = l->left->sym;
    f->next = l->sym->local;
    l->sym->local = f;
}
@


%-------------------------------------------------------------

<<acid/dot.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include "acid.h"

<<function srch>>

<<function odot>>

<<global tail (acid/dot.c)>>
<<global base>>

<<function buildtype>>

<<function defcomplex>>

<<function decl>>
@


\subsection*{[[acid/print.c]]}

<<global binop>>=
static char *binop[] =
{
    [OMUL]	"*",
    [ODIV]	"/",
    [OMOD]	"%",
    [OADD]	"+",
    [OSUB]	"-",
    [ORSH]	">>",
    [OLSH]	"<<",
    [OLT]	"<",
    [OGT]	">",
    [OLEQ]	"<=",
    [OGEQ]	">=",
    [OEQ]	"==",
    [ONEQ]	"!=",
    [OLAND]	"&",
    [OXOR]	"^",
    [OLOR]	"|",
    [OCAND]	"&&",
    [OCOR]	"||",
    [OASGN]	" = ",
};
@

<<global tabs>>=
static char *tabs = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";
@

<<global typenames>>=
char *typenames[] =
{
    [TINT]		"integer",
    [TFLOAT]	"float",
    [TSTRING]	"string",
    [TLIST]		"list",
    [TCODE]		"code",
};
@

<<function cmp>>=
int
cmp(void *va, void *vb)
{
    char **a = va;
    char **b = vb;

    return strcmp(*a, *b);
}
@

<<function fundefs>>=
void
fundefs(void)
{
    Lsym *l;
    char **vec;
    int i, j, n, max, col, f, g, s;

    max = 0;
    f = 0;
    g = 100;
    vec = malloc(sizeof(char*)*g);
    if(vec == 0)
        fatal("out of memory");

    for(i = 0; i < Hashsize; i++) {
        for(l = hash[i]; l; l = l->hash) {
            if(l->proc == 0 && l->builtin == 0)
                continue;
            n = strlen(l->name);
            if(n > max)
                max = n;
            if(f >= g) {
                g *= 2;
                vec = realloc(vec, sizeof(char*)*g);
                if(vec == 0)
                    fatal("out of memory");
            }
            vec[f++] = l->name;
        }
    }
        qsort(vec, f, sizeof(char*), cmp);
    max++;
    col = 60/max;
    s = (f+col-1)/col;

    for(i = 0; i < s; i++) {
        for(j = i; j < f; j += s)
            Bprint(bout, "%-*s", max, vec[j]);
        Bprint(bout, "\n");
    }
}
@

<<function whatis>>=
void
whatis(Lsym *l)
{
    int t;
    int def;
    Type *ti;

    if(l == 0) {
        fundefs();
        return;
    }

    def = 0;
    if(l->v->set) {
        t = l->v->type;
        Bprint(bout, "%s variable", typenames[t]);
        if(t == TINT || t == TFLOAT)
            Bprint(bout, " format %c", l->v->fmt);
        if(l->v->comt)
            Bprint(bout, " complex %s", l->v->comt->base->name);
        Bputc(bout, '\n');
        def = 1;
    }
    if(l->lt) {
        Bprint(bout, "complex %s {\n", l->name);
        for(ti = l->lt; ti; ti = ti->next) {
            if(ti->type) {
                if(ti->fmt == 'a') {
                    Bprint(bout, "\t%s %d %s;\n",
                    ti->type->name, ti->offset,
                    ti->tag->name);
                }
                else {
                    Bprint(bout, "\t'%c' %s %d %s;\n",
                    ti->fmt, ti->type->name, ti->offset,
                    ti->tag->name);
                }
            }
            else
                Bprint(bout, "\t'%c' %d %s;\n",
                ti->fmt, ti->offset, ti->tag->name);
        }
        Bprint(bout, "};\n");
        def = 1;
    }
    if(l->proc) {
        Bprint(bout, "defn %s(", l->name);
        pexpr(l->proc->left);
        Bprint(bout, ") {\n");
        pcode(l->proc->right, 1);
        Bprint(bout, "}\n");
        def = 1;
    }
    if(l->builtin) {
        Bprint(bout, "builtin function\n");
        def = 1;
    }
    if(def == 0)
        Bprint(bout, "%s is undefined\n", l->name);
}
@

<<function slist>>=
void
slist(Node *n, int d)
{
    if(n == 0)
        return;
    if(n->op == OLIST)
        Bprint(bout, "%.*s{\n", d-1, tabs);
    pcode(n, d);
    if(n->op == OLIST)
        Bprint(bout, "%.*s}\n", d-1, tabs);
}
@

<<function pcode>>=
void
pcode(Node *n, int d)
{
    Node *r, *l;

    if(n == 0)
        return;

    r = n->right;
    l = n->left;

    switch(n->op) {
    default:
        Bprint(bout, "%.*s", d, tabs);
        pexpr(n);
        Bprint(bout, ";\n");
        break;
    case OLIST:
        pcode(n->left, d);
        pcode(n->right, d);
        break;
    case OLOCAL:
        Bprint(bout, "%.*slocal", d, tabs);
        while(l) {
            Bprint(bout, " %s", l->sym->name);
            l = l->left;
            if(l == 0)
                Bprint(bout, ";\n");
            else
                Bprint(bout, ",");
        }
        break;
    case OCOMPLEX:
        Bprint(bout, "%.*scomplex %s %s;\n", d, tabs, n->sym->name, l->sym->name);
        break;
    case OIF:
        Bprint(bout, "%.*sif ", d, tabs);
        pexpr(l);
        d++;
        Bprint(bout, " then\n");
        if(r && r->op == OELSE) {
            slist(r->left, d);
            Bprint(bout, "%.*selse\n", d-1, tabs);
            slist(r->right, d);
        }
        else
            slist(r, d);
        break;
    case OWHILE:
        Bprint(bout, "%.*swhile ", d, tabs);
        pexpr(l);
        d++;
        Bprint(bout, " do\n");
        slist(r, d);
        break;
    case ORET:
        Bprint(bout, "%.*sreturn ", d, tabs);
        pexpr(l);
        Bprint(bout, ";\n");
        break;
    case ODO:
        Bprint(bout, "%.*sloop ", d, tabs);
        pexpr(l->left);
        Bprint(bout, ", ");
        pexpr(l->right);
        Bprint(bout, " do\n");
        slist(r, d+1);
    }
}
@

<<function pexpr>>=
void
pexpr(Node *n)
{
    Node *r, *l;

    if(n == 0)
        return;

    r = n->right;
    l = n->left;

    switch(n->op) {
    case ONAME:
        Bprint(bout, "%s", n->sym->name);
        break;
    case OCONST:
        switch(n->type) {
        case TINT:
            Bprint(bout, "%lld", n->ival);
            break;
        case TFLOAT:
            Bprint(bout, "%g", n->fval);
            break;
        case TSTRING:
            pstr(n->string);
            break;
        case TLIST:
            break;
        }
        break;
    case OMUL:
    case ODIV:
    case OMOD:
    case OADD:
    case OSUB:
    case ORSH:
    case OLSH:
    case OLT:
    case OGT:
    case OLEQ:
    case OGEQ:
    case OEQ:
    case ONEQ:
    case OLAND:
    case OXOR:
    case OLOR:
    case OCAND:
    case OCOR:
        Bputc(bout, '(');
        pexpr(l);
        Bprint(bout, binop[n->op]);
        pexpr(r);
        Bputc(bout, ')');
        break;
    case OASGN:
        pexpr(l);
        Bprint(bout, binop[n->op]);
        pexpr(r);
        break;
    case OINDM:
        Bprint(bout, "*");
        pexpr(l);
        break;
    case OEDEC:
        Bprint(bout, "--");
        pexpr(l);
        break;
    case OEINC:
        Bprint(bout, "++");
        pexpr(l);
        break;
    case OPINC:
        pexpr(l);
        Bprint(bout, "++");
        break;
    case OPDEC:
        pexpr(l);
        Bprint(bout, "--");
        break;
    case ONOT:
        Bprint(bout, "!");
        pexpr(l);
        break;
    case OLIST:
        pexpr(l);
        if(r) {
            Bprint(bout, ",");
            pexpr(r);
        }
        break;
    case OCALL:
        pexpr(l);
        Bprint(bout, "(");
        pexpr(r);
        Bprint(bout, ")");
        break;
    case OCTRUCT:
        Bprint(bout, "{");
        pexpr(l);
        Bprint(bout, "}");
        break;
    case OHEAD:
        Bprint(bout, "head ");
        pexpr(l);
        break;
    case OTAIL:
        Bprint(bout, "tail ");
        pexpr(l);
        break;
    case OAPPEND:
        Bprint(bout, "append ");
        pexpr(l);
        Bprint(bout, ",");
        pexpr(r);
        break;
    case ODELETE:
        Bprint(bout, "delete ");
        pexpr(l);
        Bprint(bout, ",");
        pexpr(r);
        break;
    case ORET:
        Bprint(bout, "return ");
        pexpr(l);
        break;
    case OINDEX:
        pexpr(l);
        Bprint(bout, "[");
        pexpr(r);
        Bprint(bout, "]");
        break;
    case OINDC:
        Bprint(bout, "@");
        pexpr(l);
        break;
    case ODOT:
        pexpr(l);
        Bprint(bout, ".%s", n->sym->name);
        break;
    case OFRAME:
        Bprint(bout, "%s:%s", n->sym->name, l->sym->name);
        break;
    case OCAST:
        Bprint(bout, "(%s)", n->sym->name);
        pexpr(l);
        break;
    case OFMT:
        pexpr(l);
        Bprint(bout, "\\%c", (int)r->ival);
        break;
    case OEVAL:
        Bprint(bout, "eval ");
        pexpr(l);
        break;
    case OWHAT:
        Bprint(bout, "whatis");
        if(n->sym)
            Bprint(bout, " %s", n->sym->name);
        break;
    }
}
@

<<function pstr>>=
void
pstr(String *s)
{
    int i, c;

    Bputc(bout, '"');
    for(i = 0; i < s->len; i++) {
        c = s->string[i];
        switch(c) {
        case '\0':
            c = '0';
            break;
        case '\n':
            c = 'n';
            break;
        case '\r':
            c = 'r';
            break;
        case '\t':
            c = 't';
            break;
        case '\b':
            c = 'b';
            break;
        case '\f':
            c = 'f';
            break;
        case '\a':
            c = 'a';
            break;
        case '\v':
            c = 'v';
            break;
        case '\\':
            c = '\\';
            break;
        case '"':
            c = '"';
            break;
        default:
            Bputc(bout, c);
            continue;
        }
        Bputc(bout, '\\');
        Bputc(bout, c);
    }
    Bputc(bout, '"');
}
@


%-------------------------------------------------------------

<<acid/print.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include "acid.h"

<<global binop>>

<<global tabs>>
<<global typenames>>

<<function cmp>>

<<function fundefs>>

<<function whatis>>

<<function slist>>

<<function pcode>>

<<function pexpr>>

<<function pstr>>
@


\subsection*{[[acid/expr.c]]}

<<global fsize>>=
static int fsize[] =
{
    ['A'] 4,
    ['B'] 4,
    ['C'] 1,
    ['D'] 4,
    ['F'] 8,
    ['G'] 8,
    ['O'] 4,
    ['Q'] 4,
    ['R'] 4,
    ['S'] 4,
    ['U'] 4,
    ['V'] 8,
    ['W'] 8,
    ['X'] 4,
    ['Y'] 8,
    ['Z'] 8,
    ['a'] 4,
    ['b'] 1,
    ['c'] 1,
    ['d'] 2,
    ['f'] 4,
    ['g'] 4,
    ['o'] 2,
    ['q'] 2,
    ['r'] 2,
    ['s'] 4,
    ['u'] 2,
    ['x'] 2,
    ['3'] 10,
    ['8'] 10,
};
@

<<function fmtsize>>=
int
fmtsize(Value *v)
{
    int ret;

    switch(v->fmt) {
    default:
        return  fsize[v->fmt];
    case 'i':
    case 'I':
        if(v->type != TINT || machdata == 0)
            error("no size for i fmt pointer ++/--");
        ret = (*machdata->instsize)(cormap, v->ival);
        if(ret < 0) {
            ret = (*machdata->instsize)(symmap, v->ival);
            if(ret < 0)
                error("%r");
        }
        return ret;
    }
}
@

<<function chklval>>=
void
chklval(Node *lp)
{
    if(lp->op != ONAME)
        error("need l-value");
}
@

<<function olist>>=
void
olist(Node *n, Node *res)
{
    expr(n->left, res);
    expr(n->right, res);
}
@

<<function oeval>>=
void
oeval(Node *n, Node *res)
{
    expr(n->left, res);
    if(res->type != TCODE)
        error("bad type for eval");
    expr(res->cc, res);
}
@

<<function ocast>>=
void
ocast(Node *n, Node *res)
{
    if(n->sym->lt == 0)
        error("%s is not a complex type", n->sym->name);

    expr(n->left, res);
    res->comt = n->sym->lt;
    res->fmt = 'a';
}
@

<<function oindm>>=
void
oindm(Node *n, Node *res)
{
    Map *m;
    Node l;

    m = cormap;
    if(m == 0)
        m = symmap;
    expr(n->left, &l);
    if(l.type != TINT)
        error("bad type for *");
    if(m == 0)
        error("no map for *");
    indir(m, l.ival, l.fmt, res);
    res->comt = l.comt;
}
@

<<function oindc>>=
void
oindc(Node *n, Node *res)
{
    Map *m;
    Node l;

    m = symmap;
    if(m == 0)
        m = cormap;
    expr(n->left, &l);
    if(l.type != TINT)
        error("bad type for @");
    if(m == 0)
        error("no map for @");
    indir(m, l.ival, l.fmt, res);
    res->comt = l.comt;
}
@

<<function oframe>>=
void
oframe(Node *n, Node *res)
{
    char *p;
    Node *lp;
    uvlong ival;
    Frtype *f;

    p = n->sym->name;
    while(*p && *p == '$')
        p++;
    lp = n->left;
    if(localaddr(cormap, p, lp->sym->name, &ival, rget) < 0)
        error("colon: %r");

    res->ival = ival;
    res->op = OCONST;
    res->fmt = 'X';
    res->type = TINT;

    /* Try and set comt */
    for(f = n->sym->local; f; f = f->next) {
        if(f->var == lp->sym) {
            res->comt = f->type;
            res->fmt = 'a';
            break;
        }
    }
}
@
%$

<<function oindex>>=
void
oindex(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);

    if(r.type != TINT)
        error("bad type for []");

    switch(l.type) {
    default:
        error("lhs[] has bad type");
    case TINT:
        indir(cormap, l.ival+(r.ival*fsize[l.fmt]), l.fmt, res);
        res->comt = l.comt;
        res->fmt = l.fmt;
        break;
    case TLIST:
        nthelem(l.l, r.ival, res);
        break;
    case TSTRING:
        res->ival = 0;
        if(r.ival >= 0 && r.ival < l.string->len) {
            int xx8;	/* to get around bug in vc */
            xx8 = r.ival;
            res->ival = l.string->string[xx8];
        }
        res->op = OCONST;
        res->type = TINT;
        res->fmt = 'c';
        break;
    }
}
@

<<function oappend>>=
void
oappend(Node *n, Node *res)
{
    Value *v;
    Node r, l;
    int  empty;

    expr(n->left, &l);
    expr(n->right, &r);
    if(l.type != TLIST)
        error("must append to list");
    empty = (l.l == nil && (n->left->op == ONAME));
    append(res, &l, &r);
    if(empty) {
        v = n->left->sym->v;
        v->type = res->type;
        v->Store = res->Store;
        v->comt = res->comt;
    }
}
@

<<function odelete>>=
void
odelete(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    if(l.type != TLIST)
        error("must delete from list");
    if(r.type != TINT)
        error("delete index must be integer");

    delete(l.l, r.ival, res);
}
@

<<function ohead>>=
void
ohead(Node *n, Node *res)
{
    Node l;

    expr(n->left, &l);
    if(l.type != TLIST)
        error("head needs list");
    res->op = OCONST;
    if(l.l) {
        res->type = l.l->type;
        res->Store = l.l->Store;
    }
    else {
        res->type = TLIST;
        res->l = 0;
    }
}
@

<<function otail>>=
void
otail(Node *n, Node *res)
{
    Node l;

    expr(n->left, &l);
    if(l.type != TLIST)
        error("tail needs list");
    res->op = OCONST;
    res->type = TLIST;
    if(l.l)
        res->l = l.l->next;
    else
        res->l = 0;
}
@

<<function oconst>>=
void
oconst(Node *n, Node *res)
{
    res->op = OCONST;
    res->type = n->type;
    res->Store = n->Store;
    res->comt = n->comt;
}
@

<<function oname>>=
void
oname(Node *n, Node *res)
{
    Value *v;

    v = n->sym->v;
    if(v->set == 0)
        error("%s used but not set", n->sym->name);
    res->op = OCONST;
    res->type = v->type;
    res->Store = v->Store;
    res->comt = v->comt;
}
@

<<function octruct>>=
void
octruct(Node *n, Node *res)
{
    res->op = OCONST;
    res->type = TLIST;
    res->l = construct(n->left);
}
@

<<function oasgn>>=
void
oasgn(Node *n, Node *res)
{
    Node *lp, r;
    Value *v;

    lp = n->left;
    switch(lp->op) {
    case OINDM:
        windir(cormap, lp->left, n->right, res);
        break;
    case OINDC:
        windir(symmap, lp->left, n->right, res);
        break;
    default:
        chklval(lp);
        v = lp->sym->v;
        expr(n->right, &r);
        v->set = 1;
        v->type = r.type;
        v->Store = r.Store;
        res->op = OCONST;
        res->type = v->type;
        res->Store = v->Store;
        res->comt = v->comt;
    }
}
@

<<function oadd>>=
void
oadd(Node *n, Node *res)
{
    Node l, r;

    if(n->right == nil){		/* unary + */
        expr(n->left, res);
        return;
    }
    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TFLOAT;
    switch(l.type) {
    default:
        error("bad lhs type +");
    case TINT:
        switch(r.type) {
        case TINT:
            res->type = TINT;
            res->ival = l.ival+r.ival;
            break;
        case TFLOAT:
            res->fval = l.ival+r.fval;
            break;
        default:
            error("bad rhs type +");
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->fval = l.fval+r.ival;
            break;
        case TFLOAT:
            res->fval = l.fval+r.fval;
            break;
        default:
            error("bad rhs type +");
        }
        break;
    case TSTRING:
        if(r.type == TSTRING) {
            res->type = TSTRING;
            res->fmt = 's';
            res->string = stradd(l.string, r.string); 
            break;
        }
        if(r.type == TINT) {
            res->type = TSTRING;
            res->fmt = 's';
            res->string = straddrune(l.string, r.ival);
            break;
        }
        error("bad rhs for +");
    case TLIST:
        res->type = TLIST;
        switch(r.type) {
        case TLIST:
            res->l = addlist(l.l, r.l);
            break;
        default:
            r.left = 0;
            r.right = 0;
            res->l = addlist(l.l, construct(&r));
            break;
        }
    }
}
@

<<function osub>>=
void
osub(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TFLOAT;
    switch(l.type) {
    default:
        error("bad lhs type -");
    case TINT:
        switch(r.type) {
        case TINT:
            res->type = TINT;
            res->ival = l.ival-r.ival;
            break;
        case TFLOAT:
            res->fval = l.ival-r.fval;
            break;
        default:
            error("bad rhs type -");
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->fval = l.fval-r.ival;
            break;
        case TFLOAT:
            res->fval = l.fval-r.fval;
            break;
        default:
            error("bad rhs type -");
        }
        break;
    }
}
@

<<function omul>>=
void
omul(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TFLOAT;
    switch(l.type) {
    default:
        error("bad lhs type *");
    case TINT:
        switch(r.type) {
        case TINT:
            res->type = TINT;
            res->ival = l.ival*r.ival;
            break;
        case TFLOAT:
            res->fval = l.ival*r.fval;
            break;
        default:
            error("bad rhs type *");
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->fval = l.fval*r.ival;
            break;
        case TFLOAT:
            res->fval = l.fval*r.fval;
            break;
        default:
            error("bad rhs type *");
        }
        break;
    }
}
@

<<function odiv>>=
void
odiv(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TFLOAT;
    switch(l.type) {
    default:
        error("bad lhs type /");
    case TINT:
        switch(r.type) {
        case TINT:
            res->type = TINT;
            if(r.ival == 0)
                error("zero divide");
            res->ival = l.ival/r.ival;
            break;
        case TFLOAT:
            if(r.fval == 0)
                error("zero divide");
            res->fval = l.ival/r.fval;
            break;
        default:
            error("bad rhs type /");
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->fval = l.fval/r.ival;
            break;
        case TFLOAT:
            res->fval = l.fval/r.fval;
            break;
        default:
            error("bad rhs type /");
        }
        break;
    }
}
@

<<function omod>>=
void
omod(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TINT;
    if(l.type != TINT || r.type != TINT)
        error("bad expr type %");
    res->ival = l.ival%r.ival;
}
@

<<function olsh>>=
void
olsh(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TINT;
    if(l.type != TINT || r.type != TINT)
        error("bad expr type <<");
    res->ival = l.ival<<r.ival;
}
@

<<function orsh>>=
void
orsh(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TINT;
    if(l.type != TINT || r.type != TINT)
        error("bad expr type >>");
    res->ival = (uvlong)l.ival>>r.ival;
}
@

<<function olt>>=
void
olt(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);

    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TINT;
    switch(l.type) {
    default:
        error("bad lhs type <");
    case TINT:
        switch(r.type) {
        case TINT:
            res->ival = l.ival < r.ival;
            break;
        case TFLOAT:
            res->ival = l.ival < r.fval;
            break;
        default:
            error("bad rhs type <");
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->ival = l.fval < r.ival;
            break;
        case TFLOAT:
            res->ival = l.fval < r.fval;
            break;
        default:
            error("bad rhs type <");
        }
        break;
    }
}
@

<<function ogt>>=
void
ogt(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = 'D';
    res->op = OCONST;
    res->type = TINT;
    switch(l.type) {
    default:
        error("bad lhs type >");
    case TINT:
        switch(r.type) {
        case TINT:
            res->ival = l.ival > r.ival;
            break;
        case TFLOAT:
            res->ival = l.ival > r.fval;
            break;
        default:
            error("bad rhs type >");
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->ival = l.fval > r.ival;
            break;
        case TFLOAT:
            res->ival = l.fval > r.fval;
            break;
        default:
            error("bad rhs type >");
        }
        break;
    }
}
@

<<function oleq>>=
void
oleq(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = 'D';
    res->op = OCONST;
    res->type = TINT;
    switch(l.type) {
    default:
        error("bad expr type <=");
    case TINT:
        switch(r.type) {
        case TINT:
            res->ival = l.ival <= r.ival;
            break;
        case TFLOAT:
            res->ival = l.ival <= r.fval;
            break;
        default:
            error("bad expr type <=");
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->ival = l.fval <= r.ival;
            break;
        case TFLOAT:
            res->ival = l.fval <= r.fval;
            break;
        default:
            error("bad expr type <=");
        }
        break;
    }
}
@

<<function ogeq>>=
void
ogeq(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = 'D';
    res->op = OCONST;
    res->type = TINT;
    switch(l.type) {
    default:
        error("bad lhs type >=");
    case TINT:
        switch(r.type) {
        case TINT:
            res->ival = l.ival >= r.ival;
            break;
        case TFLOAT:
            res->ival = l.ival >= r.fval;
            break;
        default:
            error("bad rhs type >=");
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->ival = l.fval >= r.ival;
            break;
        case TFLOAT:
            res->ival = l.fval >= r.fval;
            break;
        default:
            error("bad rhs type >=");
        }
        break;
    }
}
@

<<function oeq>>=
void
oeq(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = 'D';
    res->op = OCONST;
    res->type = TINT;
    res->ival = 0;
    switch(l.type) {
    default:
        break;
    case TINT:
        switch(r.type) {
        case TINT:
            res->ival = l.ival == r.ival;
            break;
        case TFLOAT:
            res->ival = l.ival == r.fval;
            break;
        default:
            break;
        }
        break;
    case TFLOAT:
        switch(r.type) {
        case TINT:
            res->ival = l.fval == r.ival;
            break;
        case TFLOAT:
            res->ival = l.fval == r.fval;
            break;
        default:
            break;
        }
        break;
    case TSTRING:
        if(r.type == TSTRING) {
            res->ival = scmp(r.string, l.string);
            break;
        }
        break;
    case TLIST:
        if(r.type == TLIST) {
            res->ival = listcmp(l.l, r.l);
            break;
        }
        break;
    }
    if(n->op == ONEQ)
        res->ival = !res->ival;
}
@

<<function oland>>=
void
oland(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TINT;
    if(l.type != TINT || r.type != TINT)
        error("bad expr type &");
    res->ival = l.ival&r.ival;
}
@

<<function oxor>>=
void
oxor(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TINT;
    if(l.type != TINT || r.type != TINT)
        error("bad expr type ^");
    res->ival = l.ival^r.ival;
}
@

<<function olor>>=
void
olor(Node *n, Node *res)
{
    Node l, r;

    expr(n->left, &l);
    expr(n->right, &r);
    res->fmt = l.fmt;
    res->op = OCONST;
    res->type = TINT;
    if(l.type != TINT || r.type != TINT)
        error("bad expr type |");
    res->ival = l.ival|r.ival;
}
@

<<function ocand>>=
void
ocand(Node *n, Node *res)
{
    Node l, r;

    res->op = OCONST;
    res->type = TINT;
    res->ival = 0;
    res->fmt = 'D';
    expr(n->left, &l);
    if(fbool(&l) == 0)
        return;
    expr(n->right, &r);
    if(fbool(&r) == 0)
        return;
    res->ival = 1;
}
@

<<function onot>>=
void
onot(Node *n, Node *res)
{
    Node l;

    res->op = OCONST;
    res->type = TINT;
    res->ival = 0;
    expr(n->left, &l);
    res->fmt = l.fmt;
    if(fbool(&l) == 0)
        res->ival = 1;
}
@

<<function ocor>>=
void
ocor(Node *n, Node *res)
{
    Node l, r;

    res->op = OCONST;
    res->type = TINT;
    res->ival = 0;
    res->fmt = 'D';
    expr(n->left, &l);
    if(fbool(&l)) {
        res->ival = 1;
        return;
    }
    expr(n->right, &r);
    if(fbool(&r)) {
        res->ival = 1;
        return;
    }
}
@

<<function oeinc>>=
void
oeinc(Node *n, Node *res)
{
    Value *v;

    chklval(n->left);
    v = n->left->sym->v;
    res->op = OCONST;
    res->type = v->type;
    switch(v->type) {
    case TINT:
        if(n->op == OEDEC)
            v->ival -= fmtsize(v);
        else
            v->ival += fmtsize(v);
        break;			
    case TFLOAT:
        if(n->op == OEDEC)
            v->fval--;
        else
            v->fval++;
        break;
    default:
        error("bad type for pre --/++");
    }
    res->Store = v->Store;
}
@

<<function opinc>>=
void
opinc(Node *n, Node *res)
{
    Value *v;

    chklval(n->left);
    v = n->left->sym->v;
    res->op = OCONST;
    res->type = v->type;
    res->Store = v->Store;
    switch(v->type) {
    case TINT:
        if(n->op == OPDEC)
            v->ival -= fmtsize(v);
        else
            v->ival += fmtsize(v);
        break;			
    case TFLOAT:
        if(n->op == OPDEC)
            v->fval--;
        else
            v->fval++;
        break;
    default:
        error("bad type for post --/++");
    }
}
@

<<function ocall>>=
void
ocall(Node *n, Node *res)
{
    Lsym *s;
    Rplace *rsav;

    res->op = OCONST;		/* Default return value */
    res->type = TLIST;
    res->l = 0;

    chklval(n->left);
    s = n->left->sym;

    if(n->builtin && !s->builtin){
        error("no builtin %s", s->name);
        return;
    }
    if(s->builtin && (n->builtin || s->proc == 0)) {
        (*s->builtin)(res, n->right);
        return;
    }
    if(s->proc == 0)
        error("no function %s", s->name);

    rsav = ret;
    call(s->name, n->right, s->proc->left, s->proc->right, res);
    ret = rsav;
}
@

<<function ofmt>>=
void
ofmt(Node *n, Node *res)
{
    expr(n->left, res);
    res->fmt = n->right->ival;
}
@

<<function owhat>>=
void
owhat(Node *n, Node *res)
{
    res->op = OCONST;		/* Default return value */
    res->type = TLIST;
    res->l = 0;
    whatis(n->sym);
}
@

<<global expop>>=
void (*expop[])(Node*, Node*) =
{
    [ONAME]		oname,
    [OCONST]	oconst,
    [OMUL]		omul,
    [ODIV]		odiv,
    [OMOD]		omod,
    [OADD]		oadd,
    [OSUB]		osub,
    [ORSH]		orsh,
    [OLSH]		olsh,
    [OLT]		olt,
    [OGT]		ogt,
    [OLEQ]		oleq,
    [OGEQ]		ogeq,
    [OEQ]		oeq,
    [ONEQ]		oeq,
    [OLAND]		oland,
    [OXOR]		oxor,
    [OLOR]		olor,
    [OCAND]		ocand,
    [OCOR]		ocor,
    [OASGN]		oasgn,
    [OINDM]		oindm,
    [OEDEC]		oeinc,
    [OEINC]		oeinc,
    [OPINC]		opinc,
    [OPDEC]		opinc,
    [ONOT]		onot,
    [OIF]		0,
    [ODO]		0,
    [OLIST]		olist,
    [OCALL]		ocall,
    [OCTRUCT]	octruct,
    [OWHILE]	0,
    [OELSE]		0,
    [OHEAD]		ohead,
    [OTAIL]		otail,
    [OAPPEND]	oappend,
    [ORET]		0,
    [OINDEX]	oindex,
    [OINDC]		oindc,
    [ODOT]		odot,
    [OLOCAL]	0,
    [OFRAME]	oframe,
    [OCOMPLEX]	0,
    [ODELETE]	odelete,
    [OCAST]		ocast,
    [OFMT]		ofmt,
    [OEVAL]		oeval,
    [OWHAT]		owhat,
};
@


%-------------------------------------------------------------

<<acid/expr.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include "acid.h"

<<global fsize>>

<<function fmtsize>>

<<function chklval>>

<<function olist>>

<<function oeval>>

<<function ocast>>

<<function oindm>>

<<function oindc>>

<<function oframe>>

<<function oindex>>

<<function oappend>>

<<function odelete>>

<<function ohead>>

<<function otail>>

<<function oconst>>

<<function oname>>

<<function octruct>>

<<function oasgn>>

<<function oadd>>

<<function osub>>

<<function omul>>

<<function odiv>>

<<function omod>>

<<function olsh>>

<<function orsh>>

<<function olt>>

<<function ogt>>

<<function oleq>>

<<function ogeq>>

<<function oeq>>


<<function oland>>

<<function oxor>>

<<function olor>>

<<function ocand>>

<<function onot>>

<<function ocor>>

<<function oeinc>>

<<function opinc>>

<<function ocall>>

<<function ofmt>>

<<function owhat>>

<<global expop>>
@


\subsection*{[[acid/builtin.c]]}

<<global tab>>=
struct Btab
{
    char	*name;
    void	(*fn)(Node*, Node*);
} tab[] =
{
    "atof",		cvtatof,
    "atoi",		cvtatoi,
    "error",	doerror,
    "file",		getfile,
    "readfile",	readfile,
    "access",	doaccess,
    "filepc",	filepc,
    "fnbound",	funcbound,
    "fmt",		fmt,
    "follow",	follow,
    "itoa",		cvtitoa,
    "kill",		kill,
    "match",	match,
    "newproc",	newproc,
    "pcfile",	pcfile,
    "pcline",	pcline,
    "print",	bprint,
    "printto",	printto,
    "rc",		rc,
    "reason",	reason,
    "setproc",	setproc,
    "start",	start,
    "startstop",	startstop,
    "status",	status,
    "stop",		stop,
    "strace",	strace,
    "sysr1",	dosysr1,
    "waitstop",	waitstop,
    "map",		map,
    "interpret",	interpret,
    "include",	include,
    "regexp",	regexp,
    "fmtof",	fmtof,
    "fmtsize",	dofmtsize,
    0
};
@

<<global vfmt>>=
char vfmt[] = "aBbcCdDfFgGiIoOqQrRsSuUVWxXYZ38";
@

<<function mkprint>>=
void
mkprint(Lsym *s)
{
    prnt = malloc(sizeof(Node));
    memset(prnt, 0, sizeof(Node));
    prnt->op = OCALL;
    prnt->left = malloc(sizeof(Node));
    memset(prnt->left, 0, sizeof(Node));
    prnt->left->sym = s;
}
@

<<function installbuiltin>>=
void
installbuiltin(void)
{
    Btab *b;
    Lsym *s;

    b = tab;
    while(b->name) {
        s = look(b->name);
        if(s == 0)
            s = enter(b->name, Tid);

        s->builtin = b->fn;
        if(b->fn == bprint)
            mkprint(s);
        b++;
    }
}
@

<<function dosysr1>>=
void
dosysr1(Node *r, Node*)
{
    extern int sysnop(void);
    
    r->op = OCONST;
    r->type = TINT;
    r->fmt = 'D';
//    r->ival = sysr1();
//pad: now it's sysnop
    r->ival = nop();
}
@

<<function match>>=
void
match(Node *r, Node *args)
{
    int i;
    List *f;
    Node *av[Maxarg];
    Node resi, resl;

    na = 0;
    flatten(av, args);
    if(na != 2)
        error("match(obj, list): arg count");

    expr(av[1], &resl);
    if(resl.type != TLIST)
        error("match(obj, list): need list");
    expr(av[0], &resi);

    r->op = OCONST;
    r->type = TINT;
    r->fmt = 'D';
    r->ival = -1;

    i = 0;
    for(f = resl.l; f; f = f->next) {
        if(resi.type == f->type) {
            switch(resi.type) {
            case TINT:
                if(resi.ival == f->ival) {
                    r->ival = i;
                    return;
                }
                break;
            case TFLOAT:
                if(resi.fval == f->fval) {
                    r->ival = i;
                    return;
                }
                break;
            case TSTRING:
                if(scmp(resi.string, f->string)) {
                    r->ival = i;
                    return;
                }
                break;
            case TLIST:
                error("match(obj, list): not defined for list");
            }
        }
        i++;
    }
}
@

<<function newproc>>=
void
newproc(Node *r, Node *args)
{
    int i;
    Node res;
    char *p, *e;
    char *argv[Maxarg], buf[Strsize];

    i = 1;
    argv[0] = aout;

    if(args) {
        expr(args, &res);
        if(res.type != TSTRING)
            error("newproc(): arg not string");
        if(res.string->len >= sizeof(buf))
            error("newproc(): too many arguments");
        memmove(buf, res.string->string, res.string->len);
        buf[res.string->len] = '\0';
        p = buf;
        e = buf+res.string->len;
        for(;;) {
            while(p < e && (*p == '\t' || *p == ' '))
                *p++ = '\0';
            if(p >= e)
                break;
            argv[i++] = p;
            if(i >= Maxarg)
                error("newproc: too many arguments");
            while(p < e && *p != '\t' && *p != ' ')
                p++;
        }
    }
    argv[i] = 0;
    r->op = OCONST;
    r->type = TINT;
    r->fmt = 'D';
    r->ival = nproc(argv);
}
@

<<function startstop>>=
void
startstop(Node *r, Node *args)
{
    Node res;

    USED(r);
    if(args == 0)
        error("startstop(pid): no pid");
    expr(args, &res);
    if(res.type != TINT)
        error("startstop(pid): arg type");

    msg(res.ival, "startstop");
    notes(res.ival);
    dostop(res.ival);
}
@

<<function waitstop>>=
void
waitstop(Node *r, Node *args)
{
    Node res;

    USED(r);
    if(args == 0)
        error("waitstop(pid): no pid");
    expr(args, &res);
    if(res.type != TINT)
        error("waitstop(pid): arg type");

    Bflush(bout);
    msg(res.ival, "waitstop");
    notes(res.ival);
    dostop(res.ival);
}
@

<<function start>>=
void
start(Node *r, Node *args)
{
    Node res;

    USED(r);
    if(args == 0)
        error("start(pid): no pid");
    expr(args, &res);
    if(res.type != TINT)
        error("start(pid): arg type");

    msg(res.ival, "start");
}
@

<<function stop>>=
void
stop(Node *r, Node *args)
{
    Node res;

    USED(r);
    if(args == 0)
        error("stop(pid): no pid");
    expr(args, &res);
    if(res.type != TINT)
        error("stop(pid): arg type");

    Bflush(bout);
    msg(res.ival, "stop");
    notes(res.ival);
    dostop(res.ival);
}
@

<<function kill>>=
void
kill(Node *r, Node *args)
{
    Node res;

    USED(r);
    if(args == 0)
        error("kill(pid): no pid");
    expr(args, &res);
    if(res.type != TINT)
        error("kill(pid): arg type");

    msg(res.ival, "kill");
    deinstall(res.ival);
}
@

<<function status>>=
void
status(Node *r, Node *args)
{
    Node res;
    char *p;

    USED(r);
    if(args == 0)
        error("status(pid): no pid");
    expr(args, &res);
    if(res.type != TINT)
        error("status(pid): arg type");

    p = getstatus(res.ival);
    r->string = strnode(p);
    r->op = OCONST;
    r->fmt = 's';
    r->type = TSTRING;
}
@

<<function reason>>=
void
reason(Node *r, Node *args)
{
    Node res;

    if(args == 0)
        error("reason(cause): no cause");
    expr(args, &res);
    if(res.type != TINT)
        error("reason(cause): arg type");

    r->op = OCONST;
    r->type = TSTRING;
    r->fmt = 's';
    r->string = strnode((*machdata->excep)(cormap, rget));
}
@

<<function follow>>=
void
follow(Node *r, Node *args)
{
    int n, i;
    Node res;
    uvlong f[10];
    List **tail, *l;

    if(args == 0)
        error("follow(addr): no addr");
    expr(args, &res);
    if(res.type != TINT)
        error("follow(addr): arg type");

    n = (*machdata->foll)(cormap, res.ival, rget, f);
    if (n < 0)
        error("follow(addr): %r");
    tail = &r->l;
    for(i = 0; i < n; i++) {
        l = al(TINT);
        l->ival = f[i];
        l->fmt = 'X';
        *tail = l;
        tail = &l->next;
    }
}
@

<<function funcbound>>=
void
funcbound(Node *r, Node *args)
{
    int n;
    Node res;
    uvlong bounds[2];
    List *l;

    if(args == 0)
        error("fnbound(addr): no addr");
    expr(args, &res);
    if(res.type != TINT)
        error("fnbound(addr): arg type");

    n = fnbound(res.ival, bounds);
    if (n != 0) {
        r->l = al(TINT);
        l = r->l;
        l->ival = bounds[0];
        l->fmt = 'X';
        l->next = al(TINT);
        l = l->next;
        l->ival = bounds[1];
        l->fmt = 'X';
    }
}
@

<<function setproc>>=
void
setproc(Node *r, Node *args)
{
    Node res;

    USED(r);
    if(args == 0)
        error("setproc(pid): no pid");
    expr(args, &res);
    if(res.type != TINT)
        error("setproc(pid): arg type");

    sproc(res.ival);
}
@

<<function filepc>>=
void
filepc(Node *r, Node *args)
{
    Node res;
    char *p, c;

    if(args == 0)
        error("filepc(filename:line): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("filepc(filename:line): arg type");

    p = strchr(res.string->string, ':');
    if(p == 0)
        error("filepc(filename:line): bad arg format");

    c = *p;
    *p++ = '\0';
    r->ival = file2pc(res.string->string, strtol(p, 0, 0));
    p[-1] = c;
    if(r->ival == ~0)
        error("filepc(filename:line): can't find address");

    r->op = OCONST;
    r->type = TINT;
    r->fmt = 'V';
}
@

<<function interpret>>=
void
interpret(Node *r, Node *args)
{
    Node res;
    int isave;

    if(args == 0)
        error("interpret(string): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("interpret(string): arg type");

    pushstr(&res);

    isave = interactive;
    interactive = 0;
    r->ival = yyparse();
    interactive = isave;
    popio();
    r->op = OCONST;
    r->type = TINT;
    r->fmt = 'D';
}
@

<<function include>>=
void
include(Node *r, Node *args)
{
    Node res;
    int isave;

    if(args == 0)
        error("include(string): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("include(string): arg type");

    pushfile(res.string->string);

    isave = interactive;
    interactive = 0;
    r->ival = yyparse();
    interactive = isave;
    popio();
    r->op = OCONST;
    r->type = TINT;
    r->fmt = 'D';
}
@

<<function rc>>=
void
rc(Node *r, Node *args)
{
    Node res;
    int pid;
    char *p, *q, *argv[4];
    Waitmsg *w;

    USED(r);
    if(args == 0)
        error("error(string): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("error(string): arg type");

    argv[0] = "/bin/rc";
    argv[1] = "-c";
    argv[2] = res.string->string;
    argv[3] = 0;

    pid = fork();
    switch(pid) {
    case -1:
        error("fork %r");
    case 0:
        exec("/bin/rc", argv);
        exits(0);
    default:
        w = waitfor(pid);
        break;
    }
    p = w->msg;
    q = strrchr(p, ':');
    if (q)
        p = q+1;

    r->op = OCONST;
    r->type = TSTRING;
    r->string = strnode(p);
    free(w);
    r->fmt = 's';
}
@

<<function doerror>>=
void
doerror(Node *r, Node *args)
{
    Node res;

    USED(r);
    if(args == 0)
        error("error(string): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("error(string): arg type");

    error(res.string->string);
}
@

<<function doaccess>>=
void
doaccess(Node *r, Node *args)
{
    Node res;

    if(args == 0)
        error("access(filename): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("access(filename): arg type");

    r->op = OCONST;
    r->type = TINT;
    r->ival = 0;		
    if(access(res.string->string, 4) == 0)
        r->ival = 1;
}
@

<<function readfile>>=
void
readfile(Node *r, Node *args)
{
    Node res;
    int n, fd;
    char *buf;
    Dir *db;

    if(args == 0)
        error("readfile(filename): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("readfile(filename): arg type");

    fd = open(res.string->string, OREAD);
    if(fd < 0)
        return;

    db = dirfstat(fd);
    if(db == nil || db->length == 0)
        n = 8192;
    else
        n = db->length;
    free(db);

    buf = malloc(n);
    n = read(fd, buf, n);

    if(n > 0) {
        r->op = OCONST;
        r->type = TSTRING;
        r->string = strnodlen(buf, n);
        r->fmt = 's';
    }
    free(buf);
    close(fd);
}
@

<<function getfile (acid/builtin.c)>>=
void
getfile(Node *r, Node *args)
{
    int n;
    char *p;
    Node res;
    String *s;
    Biobuf *bp;
    List **l, *new;

    if(args == 0)
        error("file(filename): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("file(filename): arg type");

    r->op = OCONST;
    r->type = TLIST;
    r->l = 0;

    p = res.string->string;
    bp = Bopen(p, OREAD);
    if(bp == 0)
        return;

    l = &r->l;
    for(;;) {
        p = Brdline(bp, '\n');
        n = Blinelen(bp);
        if(p == 0) {
            if(n == 0)
                break;
            s = strnodlen(0, n);
            Bread(bp, s->string, n);
        }
        else
            s = strnodlen(p, n-1);

        new = al(TSTRING);
        new->string = s;
        new->fmt = 's';
        *l = new;
        l = &new->next;
    }
    Bterm(bp);
}
@

<<function cvtatof>>=
void
cvtatof(Node *r, Node *args)
{
    Node res;

    if(args == 0)
        error("atof(string): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("atof(string): arg type");

    r->op = OCONST;
    r->type = TFLOAT;
    r->fval = atof(res.string->string);
    r->fmt = 'f';
}
@

<<function cvtatoi>>=
void
cvtatoi(Node *r, Node *args)
{
    Node res;

    if(args == 0)
        error("atoi(string): arg count");
    expr(args, &res);
    if(res.type != TSTRING)
        error("atoi(string): arg type");

    r->op = OCONST;
    r->type = TINT;
    r->ival = strtoull(res.string->string, 0, 0);
    r->fmt = 'V';
}
@

<<global fmtflags>>=
static char *fmtflags = "-0123456789. #,u";
@

<<global fmtverbs>>=
static char *fmtverbs = "bdox";
@

<<function acidfmt>>=
static int
acidfmt(char *fmt, char *buf, int blen)
{
    char *r, *w, *e;
    
    w = buf;
    e = buf+blen;
    for(r=fmt; *r; r++){
        if(w >= e)
            return -1;
        if(*r != '%'){
            *w++ = *r;
            continue;
        }
        if(*r == '%'){
            *w++ = *r++;
            if(*r == '%'){
                if(w >= e)
                    return -1;
                *w++ = *r;
                continue;
            }
            while(*r && strchr(fmtflags, *r)){
                if(w >= e)
                    return -1;
                *w++ = *r++;
            }
            if(*r == 0 || strchr(fmtverbs, *r) == nil)
                return -1;
            if(w+3 > e)
                return -1;
            *w++ = 'l';
            *w++ = 'l';
            *w++ = *r;
        }
    }
    if(w >= e)
        return -1;
    *w = 0;

    return 0;
}
@

<<function cvtitoa>>=
void
cvtitoa(Node *r, Node *args)
{
    Node res;
    Node *av[Maxarg];
    vlong ival;
    char buf[128], fmt[32];

    if(args == 0)
err:
        error("itoa(number [, fmt]): arg count");
    na = 0;
    flatten(av, args);
    if(na == 0 || na > 2)
        goto err;
    expr(av[0], &res);
    if(res.type != TINT)
        error("itoa(number [, fmt]): arg type");
    ival = res.ival;
    strncpy(fmt, "%lld", sizeof(fmt));
    if(na == 2){
        expr(av[1], &res);
        if(res.type != TSTRING)
            error("itoa(number [, fmt]): fmt type");
        if(acidfmt(res.string->string, fmt, sizeof(buf)))
            error("itoa(number [, fmt]): malformed fmt");
    }

    snprint(buf, sizeof(buf), fmt, ival);
    r->op = OCONST;
    r->type = TSTRING;
    r->string = strnode(buf);
    r->fmt = 's';
}
@

<<function mapent>>=
List*
mapent(Map *m)
{
    int i;
    List *l, *n, **t, *h;

    h = 0;
    t = &h;
    for(i = 0; i < m->nsegs; i++) {
        if(m->seg[i].inuse == 0)
            continue;
        l = al(TSTRING);
        n = al(TLIST);
        n->l = l;
        *t = n;
        t = &n->next;
        l->string = strnode(m->seg[i].name);
        l->fmt = 's';
        l->next = al(TINT);
        l = l->next;
        l->ival = m->seg[i].b;
        l->fmt = 'W';
        l->next = al(TINT);
        l = l->next;
        l->ival = m->seg[i].e;
        l->fmt = 'W';
        l->next = al(TINT);
        l = l->next;
        l->ival = m->seg[i].f;
        l->fmt = 'W';
    }
    return h;
}
@

<<function map>>=
void
map(Node *r, Node *args)
{
    int i;
    Map *m;
    List *l;
    char *ent;
    Node *av[Maxarg], res;

    na = 0;
    flatten(av, args);

    if(na != 0) {
        expr(av[0], &res);
        if(res.type != TLIST)
            error("map(list): map needs a list");
        if(listlen(res.l) != 4)
            error("map(list): list must have 4 entries");

        l = res.l;
        if(l->type != TSTRING)
            error("map name must be a string");
        ent = l->string->string;
        m = symmap;
        i = findseg(m, ent);
        if(i < 0) {
            m = cormap;
            i = findseg(m, ent);
        }
        if(i < 0)
            error("%s is not a map entry", ent);	
        l = l->next;
        if(l->type != TINT)
            error("map entry not int");
        m->seg[i].b = l->ival;
        if (strcmp(ent, "text") == 0)
            textseg(l->ival, &fhdr);
        l = l->next;
        if(l->type != TINT)
            error("map entry not int");
        m->seg[i].e = l->ival;
        l = l->next;
        if(l->type != TINT)
            error("map entry not int");
        m->seg[i].f = l->ival;
    }

    r->type = TLIST;
    r->l = 0;
    if(symmap)
        r->l = mapent(symmap);
    if(cormap) {
        if(r->l == 0)
            r->l = mapent(cormap);
        else {
            for(l = r->l; l->next; l = l->next)
                ;
            l->next = mapent(cormap);
        }
    }
}
@

<<function flatten>>=
void 
flatten(Node **av, Node *n)
{
    if(n == 0)
        return;

    switch(n->op) {
    case OLIST:
        flatten(av, n->left);
        flatten(av, n->right);
        break;
    default:
        av[na++] = n;
        if(na >= Maxarg)
            error("too many function arguments");
        break;
    }
}
@

<<function strace>>=
void
strace(Node *r, Node *args)
{
    Node *av[Maxarg], *n, res;
    uvlong pc, sp;

    na = 0;
    flatten(av, args);
    if(na != 3)
        error("strace(pc, sp, link): arg count");

    n = av[0];
    expr(n, &res);
    if(res.type != TINT)
        error("strace(pc, sp, link): pc bad type");
    pc = res.ival;

    n = av[1];
    expr(n, &res);
    if(res.type != TINT)
        error("strace(pc, sp, link): sp bad type");
    sp = res.ival;

    n = av[2];
    expr(n, &res);
    if(res.type != TINT)
        error("strace(pc, sp, link): link bad type");

    tracelist = 0;
    if ((*machdata->ctrace)(cormap, pc, sp, res.ival, trlist) <= 0)
        error("no stack frame: %r");
    r->type = TLIST;
    r->l = tracelist;
}
@

<<function regerror>>=
void
regerror(char *msg)
{
    error(msg);
}
@

<<function regexp>>=
void
regexp(Node *r, Node *args)
{
    Node res;
    Reprog *rp;
    Node *av[Maxarg];

    na = 0;
    flatten(av, args);
    if(na != 2)
        error("regexp(pattern, string): arg count");
    expr(av[0], &res);
    if(res.type != TSTRING)
        error("regexp(pattern, string): pattern must be string");
    rp = regcomp(res.string->string);
    if(rp == 0)
        return;

    expr(av[1], &res);
    if(res.type != TSTRING)
        error("regexp(pattern, string): bad string");

    r->fmt = 'D';
    r->type = TINT;
    r->ival = regexec(rp, res.string->string, 0, 0);
    free(rp);
}
@

<<function fmt>>=
void
fmt(Node *r, Node *args)
{
    Node res;
    Node *av[Maxarg];

    na = 0;
    flatten(av, args);
    if(na != 2)
        error("fmt(obj, fmt): arg count");
    expr(av[1], &res);
    if(res.type != TINT || strchr(vfmt, res.ival) == 0)
        error("fmt(obj, fmt): bad format '%c'", (char)res.ival);
    expr(av[0], r);
    r->fmt = res.ival;
}
@

<<function patom>>=
void
patom(char type, Store *res)
{
    int i;
    char buf[512];
    extern char *typenames[];

    switch(res->fmt) {
    case 'c':
        Bprint(bout, "%c", (int)res->ival);
        break;
    case 'C':
        if(res->ival < ' ' || res->ival >= 0x7f)
            Bprint(bout, "%3d", (int)res->ival&0xff);
        else
            Bprint(bout, "%3c", (int)res->ival);
        break;
    case 'r':
        Bprint(bout, "%C", (int)res->ival);
        break;
    case 'B':
        memset(buf, '0', 34);
        buf[1] = 'b';
        for(i = 0; i < 32; i++) {
            if(res->ival & (1<<i))
                buf[33-i] = '1';
        }
        buf[35] = '\0';
        Bprint(bout, "%s", buf);
        break;
    case 'b':
        Bprint(bout, "%.2x", (int)res->ival&0xff);
        break;
    case 'X':
        Bprint(bout, "%.8lux", (ulong)res->ival);
        break;
    case 'x':
        Bprint(bout, "%.4lux", (ulong)res->ival&0xffff);
        break;
    case 'D':
        Bprint(bout, "%d", (int)res->ival);
        break;
    case 'd':
        Bprint(bout, "%d", (ushort)res->ival);
        break;
    case 'u':
        Bprint(bout, "%d", (int)res->ival&0xffff);
        break;
    case 'U':
        Bprint(bout, "%lud", (ulong)res->ival);
        break;
    case 'Z':
        Bprint(bout, "%llud", res->ival);
        break;
    case 'V':
        Bprint(bout, "%lld", res->ival);
        break;
    case 'W':
        Bprint(bout, "%.8llux", res->ival);
        break;
    case 'Y':
        Bprint(bout, "%.16llux", res->ival);
        break;
    case 'o':
        Bprint(bout, "0%.11uo", (int)res->ival&0xffff);
        break;
    case 'O':
        Bprint(bout, "0%.6uo", (int)res->ival);
        break;
    case 'q':
        Bprint(bout, "0%.11o", (short)(res->ival&0xffff));
        break;
    case 'Q':
        Bprint(bout, "0%.6o", (int)res->ival);
        break;
    case 'f':
    case 'F':
    case '3':
    case '8':
        if(type != TFLOAT)
            Bprint(bout, "*%c<%s>*", res->fmt, typenames[type]);
        else
            Bprint(bout, "%g", res->fval);
        break;
    case 's':
    case 'g':
    case 'G':
        if(type != TSTRING)
            Bprint(bout, "*%c<%s>*", res->fmt, typenames[type]);
        else
            Bwrite(bout, res->string->string, res->string->len);
        break;
    case 'R':
        if(type != TSTRING)
            Bprint(bout, "*%c<%s>*", res->fmt, typenames[type]);
        else
            Bprint(bout, "%S", (Rune*)res->string->string);
        break;
    case 'a':
    case 'A':
        symoff(buf, sizeof(buf), res->ival, CANY);
        Bprint(bout, "%s", buf);
        break;
    case 'I':
    case 'i':
        if(type != TINT)
            Bprint(bout, "*%c<%s>*", res->fmt, typenames[type]);
        else {
            if (symmap == nil || (*machdata->das)(symmap, res->ival, res->fmt, buf, sizeof(buf)) < 0)
                Bprint(bout, "no instruction");
            else
                Bprint(bout, "%s", buf);
        }
        break;
    }
}
@

<<function blprint>>=
void
blprint(List *l)
{
    Bprint(bout, "{");
    while(l) {
        switch(l->type) {
        default:
            patom(l->type, &l->Store);
            break;
        case TSTRING:
            Bputc(bout, '"');
            patom(l->type, &l->Store);
            Bputc(bout, '"');
            break;
        case TLIST:
            blprint(l->l);
            break;
        case TCODE:
            pcode(l->cc, 0);
            break;
        }
        l = l->next;
        if(l)
            Bprint(bout, ", ");
    }
    Bprint(bout, "}");
}
@

<<function comx>>=
int
comx(Node res)
{
    Lsym *sl;
    Node *n, xx;

    if(res.fmt != 'a' && res.fmt != 'A')
        return 0;

    if(res.comt == 0 || res.comt->base == 0)
        return 0;

    sl = res.comt->base;
    if(sl->proc) {
        res.left = ZN;
        res.right = ZN;
        n = an(ONAME, ZN, ZN);
        n->sym = sl;
        n = an(OCALL, n, &res);
            n->left->sym = sl;
        expr(n, &xx);
        return 1;
    }
    print("(%s)", sl->name);
    return 0;
}
@

<<function bprint>>=
void
bprint(Node *r, Node *args)
{
    int i, nas;
    Node res, *av[Maxarg];

    USED(r);
    na = 0;
    flatten(av, args);
    nas = na;
    for(i = 0; i < nas; i++) {
        expr(av[i], &res);
        switch(res.type) {
        default:
            if(comx(res))
                break;
            patom(res.type, &res.Store);
            break;
        case TCODE:
            pcode(res.cc, 0);
            break;
        case TLIST:
            blprint(res.l);
            break;
        }
    }
    if(ret == 0)
        Bputc(bout, '\n');
}
@

<<function printto>>=
void
printto(Node *r, Node *args)
{
    int fd;
    Biobuf *b;
    int i, nas;
    Node res, *av[Maxarg];

    USED(r);
    na = 0;
    flatten(av, args);
    nas = na;

    expr(av[0], &res);
    if(res.type != TSTRING)
        error("printto(string, ...): need string");

    fd = create(res.string->string, OWRITE, 0666);
    if(fd < 0)
        fd = open(res.string->string, OWRITE);
    if(fd < 0)
        error("printto: open %s: %r", res.string->string);

    b = gmalloc(sizeof(Biobuf));
    Binit(b, fd, OWRITE);

    Bflush(bout);
    io[iop++] = bout;
    bout = b;

    for(i = 1; i < nas; i++) {
        expr(av[i], &res);
        switch(res.type) {
        default:
            if(comx(res))
                break;
            patom(res.type, &res.Store);
            break;
        case TLIST:
            blprint(res.l);
            break;
        }
    }
    if(ret == 0)
        Bputc(bout, '\n');

    Bterm(b);
    close(fd);
    free(b);
    bout = io[--iop];
}
@

<<function pcfile>>=
void
pcfile(Node *r, Node *args)
{
    Node res;
    char *p, buf[128];

    if(args == 0)
        error("pcfile(addr): arg count");
    expr(args, &res);
    if(res.type != TINT)
        error("pcfile(addr): arg type");

    r->type = TSTRING;
    r->fmt = 's';
    if(fileline(buf, sizeof(buf), res.ival) == 0) {
        r->string = strnode("?file?");
        return;
    }
    p = strrchr(buf, ':');
    if(p == 0)
        error("pcfile(addr): funny file %s", buf);
    *p = '\0';
    r->string = strnode(buf);	
}
@

<<function pcline>>=
void
pcline(Node *r, Node *args)
{
    Node res;
    char *p, buf[128];

    if(args == 0)
        error("pcline(addr): arg count");
    expr(args, &res);
    if(res.type != TINT)
        error("pcline(addr): arg type");

    r->type = TINT;
    r->fmt = 'D';
    if(fileline(buf, sizeof(buf), res.ival) == 0) {
        r->ival = 0;
        return;
    }

    p = strrchr(buf, ':');
    if(p == 0)
        error("pcline(addr): funny file %s", buf);
    r->ival = strtol(p+1, 0, 0);	
}
@

<<function fmtof>>=
void fmtof(Node *r, Node *args)
{
    Node *av[Maxarg];
    Node res;

    na = 0;
    flatten(av, args);
    if(na < 1)
        error("fmtof(obj): no argument");
    if(na > 1)
        error("fmtof(obj): too many arguments") ;
    expr(av[0], &res);

    r->op = OCONST;
    r->type = TINT ;
    r->ival = res.fmt ;
    r->fmt = 'c';
}
@

<<function dofmtsize>>=
void dofmtsize(Node *r, Node *args)
{
    Node *av[Maxarg];
    Node res;
    Store * s ;
    Value v ;

    na = 0;
    flatten(av, args);
    if(na < 1)
        error("fmtsize(obj): no argument");
    if(na > 1)
        error("fmtsize(obj): too many arguments") ;
    expr(av[0], &res);

    v.type = res.type ;
    s = &v.Store ;
    *s = res ;

    r->op = OCONST;
    r->type = TINT ;
    r->ival = fmtsize(&v) ;
    r->fmt = 'D';
}
@


%-------------------------------------------------------------

<<acid/builtin.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ctype.h>
#include <mach.h>
#include <regexp.h>
#include "acid.h"
#include "y.tab.h"

void	cvtatof(Node*, Node*);
void	cvtatoi(Node*, Node*);
void	cvtitoa(Node*, Node*);
void	bprint(Node*, Node*);
void	funcbound(Node*, Node*);
void	printto(Node*, Node*);
void	getfile(Node*, Node*);
void	fmt(Node*, Node*);
void	pcfile(Node*, Node*);
void	pcline(Node*, Node*);
void	setproc(Node*, Node*);
void	strace(Node*, Node*);
void	follow(Node*, Node*);
void	reason(Node*, Node*);
void	newproc(Node*, Node*);
void	startstop(Node*, Node*);
void	match(Node*, Node*);
void	status(Node*, Node*);
void	kill(Node*,Node*);
void	waitstop(Node*, Node*);
void	stop(Node*, Node*);
void	start(Node*, Node*);
void	filepc(Node*, Node*);
void	doerror(Node*, Node*);
void	rc(Node*, Node*);
void	doaccess(Node*, Node*);
void	map(Node*, Node*);
void	readfile(Node*, Node*);
void	interpret(Node*, Node*);
void	include(Node*, Node*);
void	regexp(Node*, Node*);
void	dosysr1(Node*, Node*);
void	fmtof(Node*, Node*) ;
void	dofmtsize(Node*, Node*) ;

typedef struct Btab Btab;
<<global tab>>

<<global vfmt>>

<<function mkprint>>

<<function installbuiltin>>

<<function dosysr1>>

<<function match>>

<<function newproc>>

<<function startstop>>

<<function waitstop>>

<<function start>>

<<function stop>>

<<function kill>>

<<function status>>

<<function reason>>

<<function follow>>

<<function funcbound>>

<<function setproc>>

<<function filepc>>

<<function interpret>>

<<function include>>

<<function rc>>

<<function doerror>>

<<function doaccess>>

<<function readfile>>

<<function getfile (acid/builtin.c)>>

<<function cvtatof>>

<<function cvtatoi>>

<<global fmtflags>>
<<global fmtverbs>>

<<function acidfmt>>

<<function cvtitoa>>

<<function mapent>>

<<function map>>

<<function flatten>>

<<function strace>>

<<function regerror>>

<<function regexp>>

<<function fmt>>

<<function patom>>

<<function blprint>>

<<function comx>>

<<function bprint>>

<<function printto>>

<<function pcfile>>

<<function pcline>>

<<function fmtof>>

<<function dofmtsize>>
@


