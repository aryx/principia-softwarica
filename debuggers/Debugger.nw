\documentclass[12pt]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - removed deadcode (BADREG, maxfile, regdirty, exitflg)

%thx to codemap/codegraph:

%thx to this manual, better understand debuggers:
% - SEMI need a /proc/x/ctl to control/resume an external process
%   with the right set of messages and synchronisation mechanisms
% - SEMI need a /proc/x/mem, reflection, including ublock to inspect registers
% - SEMI how breakpoint can be fast? via trap abuse, thx to virtual 
%   memory and page fault again!
% - TODO all the symbols are in the text file


%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the file before
% - SEMI nullify, boolify, typeify,    scheckify
% - SEMI aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

\input{../docs/latex/Config}
\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../docs/latex/syncweb}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for ?

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Debuggers and Tracers
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Phil Winterbottom
}

\maketitle 


%\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
%\twocolumn


\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a {debugger} and {tracer}.
Why? Because we think you are a better programmer if
you fully understand how things work under the hood, and
debuggers and traces are some of the best tools to understand how things
work.

\section{\plan [[db]] and [[strace]]}

% We gonna present db (and maybe acid) and strace (actually was called
% ratrace). Small programs. Elegant. Simple.

\section{Other debuggers}

Here are a few debuggers that were considered for this book but
which were ultimately discarded:
\begin{itemize}

%history:
% db? thompson?
% adb? by bourne

\item gdb
% and BFD. which =~ libmach
% dwarf debugging format?

\item lldb
% other debugging format?

\item valgrind

\item ocamldebug
% good, time travel, but first need to understand simpler debugger I think

\item Linux strace
% also Linux uprobe to trace user-level functions!
%http://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html

\item Solaris dtrace
% Very complete, very advanced, entire books on it
\end{itemize}

% other:
% - godebug, apparently done via source code transformation
% - gotracer https://golang.org/cmd/trace/
% - trace-based debugger, a la mireille ducasse

%http://backtrace.io/blog/blog/2016/08/11/debugger-internals/
%http://blog.0x972.info/?d=2014/11/13/10/40/50-how-does-a-debugger-work
%https://www.hackerschool.com/blog/5-learning-c-with-gdb
%http://undo.io/resources/presentations/cppcon-2015-greg-law-give-me-15-minutes-ill-change/
%http://majantali.net/2016/10/how-breakpoints-are-set/
%http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1
%http://blog.tartanllama.xyz/c++/2017/03/24/writing-a-linux-debugger-breakpoints/

%TODO, add lpize?
% - mach.h, many helper functions to access the binary/object file
% - snap/?
% - cc/acid.c?


% a few tags used in this file
% - gdb: for equivalent command in gdb
% - langc: for things coming later with C support

\section{Getting started}

\section{Requirements}

% docs/man/3/proc
% docs/man/2/debugger

% one single book? "How Debuggers Work"?
% Also book on GDB, but really user manual

% Partly Kernel.nw and its "Debugging Support" chapter

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}


\chapter{Overview}

\section{Tracer principles}

% First technique to debug, printf! A classic
%less: add ref with codes are work that mention a lot the only use of printf
% for debugging.
%logging is good, see partial trace of execution. Traces are good.

% strace does automatic logging without any printf, based on syscalls;
% a good boundary, a good granularity. 
% There is also now 'ltrace'.

% Good first way to debug issues, to get more insight on what's going on.
% Simple, and very effective at finding many bugs, like
% no more space in /tmp. Especially when people don't check
% return error code, at least see the call to create a file in /tmp

\section{[[strace]] services}

% strace <cmd>
% stace <pid> ?

\section{Debugger principles}

% Prgram to control another program.
% Naive = interpreter, cf Machine.nw. Full control, but very very slow.
% => need hardware (and kernel) debugging support! so fast!

% simple: external child process that you can control (thx to kernel
% features) modify the code in memory at the breakpoint address given
% by the user to generate a fault => when execute and reach breakpoint
% we will be given back the hand. => efficient!
% less: Can use same trick for watchpoint? when access some memory area?
% hmm but then has to invalidate the whole page? so some false positives.

% Debugging process, debugged process.

% For some advanced inspection features the debugger needs metadata, 
% generated by the assembler, the compiler, and the linker. Symbol tables.
% See "Debugging Support" chapters in Assembler.nw, Compiler.nw,
% Linker.nw We will recall the essential things below.

% But without any medata the debugger can already do a lot if again
% the kernel provide good introspection feature on the debugged
% children process. The registers values, the memory state.

% Another good support from the kernel is the Broken state
% in Kernel.nw. It's convenient because when segfault,
% got the core dump, but actually under plan9 the process is put
% in a Broken state and can be debugged by
%  db <pid>
% Awesome (remember efuns.byte crashes).


\section{[[db]] services}

% see also Machine.nw, which has a similar interface.

<<[[main()]] print usage and exit (db)>>=
fprint(2, "Usage: db [-kw] [-m machine] [-I dir] ([symfile]|[pid])\n");
exits("usage");
@
%pad: I added the | between symfile and pid
% (can also have db <file> <pid> but not really necessary)

% db <file>
% db <pid>
%note: I thought there was a  -c, but it's just that if non alldigits argv[0]
% then it's assumed to be a program

% then for command input language, see below

\section{A simple debugging session}
%[[hello.core]] ?

% command language syntax: [addr] [,count] [command]
% notion of 'dot', current address.
%ugly: a bit crude language, they could use lex and yacc to provide
% something better (actually acid does that)

<<constant [[CMD_VERBS]]>>=
#define CMD_VERBS	"?/=>!$: \t"
@
%$


% > main
% =>  main() /tests/8c/helloc.c:5
% (now dot is main)
% > ?   
% => SUBL $4, SP,  (? is for textfile)
% > /   
% => ( / is for memfile)

% ?i => print using instruction format
% ?iii ?3i => print 3 next instructions from dot

% can also do  main ?i,  combining [addr] and [command]

% symbols are ultimately translated into pure address, so then
% everything is an address (ADDR).

% RET => increment dot
 
% $m => show address maps (text and data spec)
%  (a bit more complete once the program is actually running)
% $b => show breakpoints
% $c => stacktrace
% $C => stacktrace with parameters values! and locals! awesome! like in Perl!
%  ex:
%  caml_main(argv=...) /home/pad/../main.c called from main+f (/home/pad/...)
%    caml_main.raise_buf/ 0x1
%    caml_main.pos/ 0x0
%    caml_main.trail/ 0x4cf2c
%    ...
%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)
% $r => dump registers
% $q => exit

% :r => run
% :c => continue
% main :b => breakpoint main (can check with $b after)

%todo: ??? dump value of a global:   global /, or *global /


% Many commands are either in lowercase or uppercase form,
% where uppercase form is usually one providing more services,
% and is often a source-level services for C.
% So often lowercase = assembly level, uppercase = C level.
% ex: $c vs $C, :s vs :S 

%TODO
%*** show at least the code of
%some instructions generating a segfault!
%create a simple segfault.c test file
%and a session where can find and debug the bug

\section{[[acid]] services}

%related: python scripts to extend GDB so better display STL vectors
% and so on?

\section{Code organization}

%-------------
%for db:
%-------------

%defs.h: DS, globals decls
%fns.h: functions decls
%globals.c: globals
%utils.c: ??

%command.c
%expr.c
%format.c

%input.c
%output.c

%print.c

%regs.c: rget(), rput()

%pcs.c
%runpcs.c
%setup.c
%trcrun.c

%main.c: entry point

%-------------
%for libmach:
%-------------

\section{Software architecture}

% Debugging process, debugged process.

% Debugging process control debugged process via /proc/x/ctl!
% access (and modify) its data via /proc/x/mem and /proc/x/text
% Also support from libmach for generic symbols access, disassembler, 
% register modification, even memory modification through Map.
% To map addresses back to symbolic names.

% FIGURE: state diagram with different messages in /proc/x/ctl
% start, waitstop, hang, etc and who writes to them and when.

% cooperation! 5a, 5c. object file symbol table, executable symbol table.
% line/file information.

% name conventions:

\section{Book structure}

%###############################################################################

\chapter{Kernel Support}
% Context

\section{Memory access: [[/proc/x/mem]]}
% Interprocess memory access?
% or reflection?

% segments, text, data, and ublock. Map everything, including kernel
% per-process space.
% "data" is actually for everything, static data, bss, stack.

% ublock = register and process state.

% to a lesser extent /proc/x/text is also useful, but the symfile is 
% good enough and /proc/x/mem is a superset of /proc/x/text I think.


\section{Process control: [[/proc/x/ctl]]}

% useful for strace too.

% Offer also synchronisation mechanism, writing of debugging
% process can be blocked until the debugged process reach certain
% state. Useful.

% "hang" (after exec)
% "waitstop" (until debugged reaches hang and go in Stopped state), atomic

% "start"
% "stop"

% "startstop", atomic

\section{Breakpoint faulting instruction}

% machdata->bpinst

\section{User level fault handling: [[/proc/x/note]]}
% Hmm actually need less than, just provide a way to understand
% why the debugged process entered the Stopped state.

\section{Core dumps and broken processes}

% when process crashes, it's still around, and can just run
% ps; db <pid> to start inspect! really useful.

\chapter{Core Data Structures}

\section{Executable format: [[Fhdr]]}
% generic

<<struct [[Fhdr]]>>=
/*
 *	Common a.out header describing all architectures
 */
struct Fhdr
{
    char	*name;		/* identifier of executable */

    // enum<executable_type>
    byte	type;		/* file type - see codes above */

    byte	hdrsz;		/* header size */
    byte	_magic;		/* _MAGIC() magic */
    byte	spare;

    long	magic;		/* magic number */

    uvlong	txtaddr;	/* text address */
    vlong	txtoff;		/* start of text in file */
    uvlong	dataddr;	/* start of data segment */
    vlong	datoff;		/* offset to data seg in file */
    vlong	symoff;		/* offset of symbol table in file */

    uvlong	entry;		/* entry point */

    vlong	sppcoff;	/* offset of sp-pc table in file */
    vlong	lnpcoff;	/* offset of line number-pc table in file */

    long	txtsz;		/* text size */
    long	datsz;		/* size of data seg */
    long	bsssz;		/* size of bss */

    long	symsz;		/* size of symbol table */
    long	sppcsz;		/* size of sp-pc table */ // unused
    long	lnpcsz;		/* size of line number-pc table */

};
@
% use uvlong to encompass 32 and 64 architecture.

<<enum [[executable_type]]>>=
/* types of executables */
enum executable_type 
{
    FNONE = 0,		/* unidentified */

    FI386,			/* 8.out */
    FI386B,			/* I386 bootable */
    FARM,			/* 5.out */
    FARMB,			/* ARM bootable */
};
@

%    FMIPS,			/* v.out */
%    FMIPSB,			/* mips bootable */
%    FSPARC,			/* k.out */
%    FSPARCB,		/* Sparc bootable */
%    F68020,			/* 2.out */
%    F68020B,		/* 68020 bootable */
%    FNEXTB,			/* Next bootable */
%    FI960,			/* retired */
%    FI960B,			/* retired */
%    F3210,			/* retired */
%    FMIPS2BE,		/* 4.out */
%    F29000,			/* retired */
%    FPOWER,			/* q.out */
%    FPOWERB,		/* power pc bootable */
%    FMIPS2LE,		/* 0.out */
%    FALPHA,			/* retired */
%    FALPHAB,		/* retired DEC Alpha bootable */
%    FMIPSLE,		/* 3k little endian */
%    FSPARC64,		/* retired */
%    FAMD64,			/* 6.out */
%    FAMD64B,		/* 6.out bootable */
%    FPOWER64,		/* 9.out */
%    FPOWER64B,		/* 9.out bootable */
%    FARM64,			/* arm64 */
%    FARM64B,		/* arm64 bootable */


\section{[[Mach]] and [[mach]]}

% put1? get1? 
% rput? rget? register put/get
% geta? get address


<<struct [[Mach]]>>=
/*
 *	Machine-dependent data is stored in two structures:
 *		Mach  - miscellaneous general parameters
 *		Machdata - jump vector of service functions used by debuggers
 *
 *	Mach is defined in ?.c and set in executable.c
 *
 *	Machdata is defined in ?db.c
 *		and set in the debugger startup.
 */
struct Mach{
    char	*name;
    // enum<machine_type>
    int	mtype;			/* machine type code */

    Reglist *reglist;		/* register set */
    long	regsize;		/* sizeof registers in bytes */
    long	fpregsize;		/* sizeof fp registers in bytes */

    char	*pc;			/* pc name */
    char	*sp;			/* sp name */
    char	*link;			/* link register name */
    char	*sbreg;			/* static base register name */
    uvlong	sb;			/* static base register value */

    int	pgsize;			/* page size */
    uvlong	kbase;			/* kernel base address */
    uvlong	ktmask;			/* ktzero = kbase & ~ktmask */
    uvlong	utop;			/* user stack top */

    int	pcquant;		/* quantization of pc */

    int	szaddr;			/* sizeof(void*) */
    int	szreg;			/* sizeof(register) */
    int	szfloat;		/* sizeof(float) */
    int	szdouble;		/* sizeof(double) */
};
@

<<enum [[machine_type]]>>=
/* machine types */
enum machine_type 
{
    MI386,
    MARM,
};
@
%    MMIPS,			
%    MSPARC,
%    M68020,
%    MI960,			/* retired */
%    M3210,			/* retired */
%    MMIPS2,
%    NMIPS2,
%    M29000,			/* retired */
%    MPOWER,
%    MALPHA,			/* retired */
%    NMIPS,
%    MSPARC64,		/* retired */
%    MAMD64,
%    MPOWER64,
%    MARM64,


<<struct [[Reglist]]>>=
/*
 *	machine register description
 */
struct Reglist {
    char	*rname;		/* register name */

    short	roffs;		/* offset in u-block */

    // bitset<enum<register_flag>>
    char	rflags;		/* INTEGER/FLOAT, WRITABLE */
    char	rformat;	/* print format: 'x', 'X', 'f', '8', '3', 'Y', 'W' */
};
@

<<enum [[register_flag]]>>=
enum {					/* bits in rflags field */
    RINT	= (0<<0),
    RFLT	= (1<<0),

    RRDONLY	= (1<<1),
};
@

<<global [[mach]]>>=
Mach	*mach = &mi386;			/* Global current machine table */
@


\section{[[Machdata]] and [[machdata]]}

%machdata->bpinst ! the instruction generating a sys: breakpoint


<<struct [[Machdata]]>>=
struct	Machdata {		/* Machine-dependent debugger support */
    uchar	bpinst[4];			/* break point instr. */
    short	bpsize;				/* size of break point instr. */

    ushort	(*swab)(ushort);		/* ushort to local byte order */
    ulong	(*swal)(ulong);			/* ulong to local byte order */
    uvlong	(*swav)(uvlong);		/* uvlong to local byte order */

    int	(*ctrace)(Map*, uvlong, uvlong, uvlong, Tracer); /* C traceback */
    uvlong	(*findframe)(Map*, uvlong, uvlong, uvlong, uvlong);/* frame finder */
    char*	(*excep)(Map*, Rgetter);	/* last exception */
    ulong	(*bpfix)(uvlong);		/* breakpoint fixup */

    int	(*sftos)(char*, int, void*);	/* single precision float */
    int	(*dftos)(char*, int, void*);	/* double precision float */

    int	(*foll)(Map*, uvlong, Rgetter, uvlong*);/* follow set */

    int	(*das)(Map*, uvlong, char, char*, int);	/* symbolic disassembly */
    int	(*hexinst)(Map*, uvlong, char*, int); 	/* hex disassembly */
    int	(*instsize)(Map*, uvlong);	/* instruction size */
};
@

\section{[[Map]]}

% cormap, symmap, dotmap

<<struct [[Map]]>>=
/*
 * 	Structure to map a segment to a position in a file
 */
struct Map {
    int	nsegs;			/* number of segments */
    struct segment {		/* per-segment map */
        char	*name;		/* the segment name */
        int	fd;		/* file descriptor */

        bool	inuse;		/* in use - not in use */
        bool	cache;		/* should cache reads? */

        uvlong	b;		/* base */
        uvlong	e;		/* end */
        vlong	f;		/* offset within file */

    } seg[1];			/* actually n of these */
};
@


\section{[[Symbol]]}

<<struct [[Symbol]]>>=
/*
 *	Internal structure describing a symbol table entry
 */
struct Symbol {
    void 	*handle;		/* used internally - owning func */
    struct {
        char	*name;
        vlong	value;		/* address or stack offset */
        char	type;		/* as in a.out.h */
        char	class;		/* as above */
        int	index;		/* in findlocal, globalsym, textsym */
    };
};
@

<<enum [[symbol_type]]>>=
/* symbol table classes */
enum symbol_type
{
    CNONE  = 0,	

    CAUTO,
    CPARAM,
    CSTAB,
    CTEXT,
    CDATA,

    CANY,			/* to look for any class */
};
@
%CSTAB?

\section{[[/proc/x/text]] and [[symmap]]}

<<global [[symmap]]>>=
// was in setup.c
Map	*symmap;
@
% derived from text

% will be accessed via symmap


\section{[[/proc/x/mem]] and [[cormap]]}

<<global [[cormap]]>>=
Map	*cormap;
@
% derived from heap and stack?

% will be accessed via cormap, will set stuff there
% to generate some fault (and so some notes)
% via put1(), will also get stuff via get1(), rget(), etc.

\section{[[/proc/x/ctl]], [[msgfd]], and [[msgpcs()]]}

<<global [[msgfd]]>>=
fdt msgfd = -1;
@
% /proc/x/ctl

<<global [[pcspid]]>>=
int pcspid = -1;
@
% memoized

% msgpcs | ?? -> <>
<<function [[setpcs]]>>=
void
setpcs(void)
{
    char buf[128];

    if(pid && pid != pcspid){
        if(msgfd >= 0){
            close(msgfd);
            msgfd = -1;
        }
        <<[[setpcs()]] close previous notefd if changed process>>

        pcspid = -1;

        sprint(buf, "/proc/%d/ctl", pid);
        msgfd = open(buf, OWRITE);
        if(msgfd < 0)
            error("can't open control file");

        <<[[setpcs()]] open notefd for new process>>

        pcspid = pid;
    }
}
@

% for error =~ exn via setjmp, see Error managment

% ???? -> <>
<<function [[msgpcs]]>>=
void
msgpcs(char *msg)
{
    int ret;
    <<[[msgpcs()]] locals>>

    setpcs();
    //dprint("--> %d: %s\n", pcspid, msg);
    ret = write(msgfd, msg, strlen(msg));
    <<[[msgpcs()]] error managment>>
}
@
%todo: have a -d  where the dprint is not in comment

<<[[msgpcs()]] locals>>=
char err[ERRMAX];
@
<<[[msgpcs()]] error managment>>=
if(ret < 0 && !ending){
    errstr(err, sizeof err);
    if(strcmp(err, "interrupted") != 0)
        endpcs();
    errors("can't write control file", err);
}
@

\section{[[Addr]] and [[dot]]}

<<type [[ADDR]]>>=
typedef uvlong ADDR;
@
%less: uvlong so portable to 32 and 64 bits archi?

<<global [[dot]]>>=
// was in command.c
ADDR	dot;
@
% see also adrflg

\section{[[cntval]]}

<<type [[WORD]]>>=
typedef ulong WORD;
@

<<global [[cntval]]>>=
WORD cntval;
@
% see also ctnflag

\section{[[Bkpt]] and [[bkpthead]]}

<<struct [[bkpt]]>>=
struct bkpt {
    // address to break on
    ADDR	loc;
    // enum<breakpoint_kind>
    int	flag;

    // original code at the breapoint
    byte save[4];

    <<[[Bkpt]] other fields>>

    // Extra
    <<[[Bkpt]] extra fields>>
};
@

<<constant [[BKPTCLR]]>>=
#define	BKPTCLR	0	/* not a real breakpoint */
@
%todo: enum? enum breakpoint_kind

<<constant [[BKPTSET]]>>=
#define BKPTSET	1	/* real, ready to trap */
@
<<constant [[BKPTSKIP]]>>=
#define BKPTSKIP 2	/* real, skip over it next time */
@
<<constant [[BKPTTMP]]>>=
#define	BKPTTMP	3	/* temporary; clear when it happens */
@



<<global [[bkpthead]]>>=
// list<BKPT>, next = BKPT.next
BKPT *bkpthead;
@

<<[[Bkpt]] extra fields>>=
// list<ref_own<BKPT>, head = bkpthead
BKPT	*nxtbkpt;
@



%XXX
<<[[Bkpt]] other fields>>=
int	count;
int	initcnt;
@

\section{[[/proc/x/note]], [[notefd]], and [[notes]]}

<<global [[notefd]]>>=
fdt notefd = -1;
@
% /proc/x/note


<<[[setpcs()]] close previous notefd if changed process>>=
if(notefd >= 0){
    close(notefd);
    notefd = -1;
}
@

<<[[setpcs()]] open notefd for new process>>=
sprint(buf, "/proc/%d/note", pid);
notefd = open(buf, ORDWR);
if(notefd < 0)
    error("can't open note file");
@

<<global [[note]]>>=
// array<option<ref_own<string>>, actual number of elts used = nnote
char note[NNOTE][ERRMAX];
@
<<constant [[NNOTE]]>>=
#define	NNOTE 10
@
<<global [[nnote]]>>=
int nnote;
@






\chapter{[[main()]]}

<<global [[symfil]]>>=
char	*symfil = nil;
@
% program to be debugged, containing symbol information, for text and data
% or /proc/x/text
% (global so can be used by printmap())

<<global [[corfil]]>>=
char	*corfil = nil;
@
% memory, for the heap and stack, and also process state registers and more!
% will be /proc/xxx/mem
% (global so can be used by printmap())


<<global [[infile]]>>=
int	infile = STDIN;
@
% input to the debugger


<<function main (db/main.c)>>=
void
main(int argc, char **argv)
{
    <<[[main()]] locals (db)>>

    outputinit();

    ARGBEGIN{
    <<[[main()]] command line processing (db)>>
    }ARGEND

    if (argc > 0 && !alldigs(argv[0])) {
        symfil = argv[0];
        argv++;
        argc--;
    }
    <<[[main()]] if pid argument, attach to existing process>>
    else if (argc > 0) {
        <<[[main()]] print usage and exit (db)>>
    }
 
   if (!symfil)
        symfil = "8.out";

    <<[[main()]] initialization before repl (db)>>

    // repl loop
    for (;;) {
        // clear output
        flushbuf();

        <<[[main()]] in loop, handle errmsg (db)>>
        <<[[main()]] in loop, handle mkfault (db)>>

        // clear input
        clrinp();

        // go to next non whitespace char
        rdc();
        reread();
        <<[[main()]] in loop, if eof (db)>>

        command(nil, 0);

        reread();
        if (rdc() != '\n')
            error("newline expected");
    }
}
@
%dead: exitflg is never set to true anyway
%        exitflg = false; //was before command()

<<function [[alldigs]]>>=
bool
alldigs(char *s)
{
    while(*s){
        if(*s<'0' || '9'<*s)
            return false;
        s++;
    }
    return true;
}
@

% repl = read eval print loop, classic interpreter term.

<<[[main()]] initialization before repl (db)>>=
<<[[main()]] call notify>>
<<[[main()]] call setsym>>
<<[[main()]] set dotmap>>
<<[[main()]] print binary architecture>>
<<[[main()]] setjmp>>
<<[[main()]] just before repl>>
@



<<[[main()]] print binary architecture>>=
<<[[main()]] if db -m and unknown machine>>
dprint("%s binary\n", mach->name);
@
% setsym() will set mach via machbytype() (or machbyname() when db -mxxx)


<<global [[env]]>>=
jmp_buf env;
@
% poor's man exn via setjmp.
% See error managment appendix. Provide a way to go back
% to main command loop (e.g. in error())

<<[[main()]] setjmp>>=
if(setjmp(env) == 0){
    <<[[main()]] if setjmp == 0 and corfil>>
}
setjmp(env);
@
% == 0 when first call, but further longjmp will not go there.

%todo: why 2 setjmp? because we want to do the corfil only once?
% but then just do it before ...


\section{Process attachment: [[pid]]}

% alternative is to run the program, which will be done with :r
% which should then set pid


<<global [[pid]]>>=
int pid;
@
% = 0;

<<[[main()]] locals (db)>>=
char b1[100];
char b2[100];
@


<<[[main()]] if pid argument, attach to existing process>>=
if(argc==1 && alldigs(argv[0])){

    pid = atoi(argv[0]);
    pcsactive = false;
    if (!symfil) {
        <<[[main()]] when pid argument, if kflag>>
        else
            sprint(b1, "/proc/%s/text", argv[0]);
        symfil = b1;
    }
    sprint(b2, "/proc/%s/mem", argv[0]);
    corfil = b2;
}
@

<<global [[pcsactive]]>>=
// was in trcrun.c
bool pcsactive = false;
@
% process control? s = ?
% we do things lazily, this will be set on demand when executing (:r)
% in setup() or when continuing (:c) or halting/unhalting I think.

\section{Text file: [[setsym()]]}

<<[[main()]] call setsym>>=
setsym();
@
% setsym to find symbols.


<<global fhdr (db/setup.c)>>=
static Fhdr fhdr;
@

<<global [[fsym]]>>=
fdt fsym;
@
% why need that to be a global? for printmap, attachprocess


% main -> <>
<<function setsym (db)>>=
void
setsym(void)
{
    int ret;
    <<[[setsym()]] locals>>

    fsym = getfile(symfil, 1, wtflag);
    <<[[setsym()]] error managment on fsym>>
    ret = crackhdr(fsym, &fhdr);
    if (ret) {
        machbytype(fhdr.type);
        symmap = loadmap(symmap, fsym, &fhdr);
        <<[[setsym()]] error managment on symmap>>
        ret = syminit(fsym, &fhdr);
        <<[[setsym()]] error managment on syminit>>

        <<[[setsym()]] if mach has sbreg>>
    }
    <<[[setsym()]] error managment on crackhdr>>
}
@
% crachhdr()
% machbytype() !
% syminit()!

<<[[setsym()]] error managment on fsym>>=
if(fsym < 0) {
    symmap = dumbmap(-1);
    return;
}
@
<<[[setsym()]] error managment on symmap>>=
if (symmap == nil)
    symmap = dumbmap(fsym);
@
<<[[setsym()]] error managment on crackhdr>>=
else
    symmap = dumbmap(fsym);
@
<<[[setsym()]] error managment on syminit>>=
if (ret < 0)
    dprint("%r\n");
@


<<function [[dumbmap]]>>=
Map *
dumbmap(fdt fd)
{
    Map *dumb;


    dumb = newmap(0, 1);
    setmap(dumb, fd, 0, 0xffffffff, 0, "data");
    if (!mach) 			/* default machine = 386 */
        mach = &mi386;
    if (!machdata)
        machdata = &i386mach;
    return dumb;
}
@




<<[[setsym()]] locals>>=
Symbol s;
@
<<[[setsym()]] if mach has sbreg>>=
if (mach->sbreg && lookup(0, mach->sbreg, &s))
    mach->sb = s.value;
@





<<global [[wtflag]]>>=
// was in main.c
int wtflag = OREAD;
@
%OREAD = 0



% return fdt or -1
<<function [[getfile]]>>=
static fdt
getfile(char *filnam, int cnt, int omode)
{
    fdt f;

    if (filnam == nil)
        return ERROR_NEG1;

    if (strcmp(filnam, "-") == 0)
        return STDIN;
    f = open(filnam, omode|OCEXEC);

    <<[[getfile()]] error managment>>
    return f;
}
@

<<[[getfile()]] error managment>>=
if(f < 0 && omode == ORDWR){
    f = open(filnam, OREAD|OCEXEC);
    if(f >= 0)
        dprint("%s open read-only\n", filnam);
}
<<[[getfile()]] if wtflag>>
if (f < 0) {
    dprint("cannot open `%s': %r\n", filnam);
    return ERROR_NEG1;
}
@




\section{Memory file: [[setcor()]]}
% Core memory file

<<[[main()]] if setjmp == 0 and corfil>>=
if (corfil) {
    setcor();	/* could get error */
    dprint("%s\n", machdata->excep(cormap, rget));
    printpc();
}
@
% excep?

<<global [[fcor]]>>=
fdt fcor;
@


% main (when corfil) | attachprocess | bpwait (<- startpcs) -> <>
<<function [[setcor]]>>=
void
setcor(void)
{
    int i;

    <<[[setcor()]] free previous cormap>>
    fcor = getfile(corfil, 2, ORDWR);
    <<[[setcor()]] error managment getfile>>
    if(pid > 0) {	/* provide addressability to executing process */
        cormap = attachproc(pid, kflag, fcor, &fhdr);
        <<[[setcor()]] error managment cormap>>
    } else {
        cormap = newmap(cormap, 2);
        <<[[setcor()]] error managment cormap>>
        setmap(cormap, fcor, fhdr.txtaddr, fhdr.txtaddr+fhdr.txtsz, fhdr.txtaddr, "text");
        setmap(cormap, fcor, fhdr.dataddr, 0xffffffff, fhdr.dataddr, "data");
    }
    kmsys();
    return;
}
@
% attachproc in libmach
% newmap, setmap


<<[[setcor()]] free previous cormap>>=
if (cormap) {
    for (i = 0; i < cormap->nsegs; i++)
        if (cormap->seg[i].inuse)
            close(cormap->seg[i].fd);
}
@

<<[[setcor()]] error managment getfile>>=
if (fcor <= 0) {
    if (cormap)
        free(cormap);
    cormap = dumbmap(-1);
    return;
}
@
<<[[setcor()]] error managment cormap>>=
if (!cormap)
    cormap = dumbmap(-1);
@

\section{Output: [[outputinit()]], [[dprint()]] and [[stdout]]}

<<global [[stdout]]>>=
Biobuf	stdout;
@

<<function [[outputinit]]>>=
void
outputinit(void)
{
    Binit(&stdout, 1, OWRITE);
    fmtinstall('t', tconv);
}
@
% %t ??
% closed in oclose() (<- errors)

<<function [[tconv]]>>=
/* was move to next f1-sized tab stop; now just print a tab */
int
tconv(Fmt *f)
{
    return fmtstrcpy(f, "\t");
}
@
%less: legacy code? could just replace all %t by \t?


<<function [[dprint]]>>=
int
dprint(char *fmt, ...)
{
    char buf[4096];
    va_list arg;
    int n;
    <<[[dprint()]] locals>>

    <<[[dprint()]] return if mkfault>>

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof buf, fmt, arg) - buf;
    va_end(arg);

    //Bprint(&stdout, "[%s]", fmt);
    Bwrite(&stdout, buf, n);

    <<[[dprint()]] maintain printcol>>
    return n;
}
@

<<function [[printc]]>>=
void
printc(int c)
{
    dprint("%c", c);
}
@
<<function [[prints]]>>=
void
prints(char *s)
{
    dprint("%s",s);
}
@






<<global [[printcol]]>>=
int	printcol = 0;
@
<<[[dprint()]] locals>>=
char *p;
Rune r;
int w;
@
<<[[dprint()]] maintain printcol>>=
for(p=buf; *p; p+=w){
    w = chartorune(&r, p);
    if(r == '\n')
        printcol = 0;
    else
        printcol++;
}
@



<<function [[flushbuf]]>>=
void
flushbuf(void)
{
  if (printcol != 0)
        printc(EOR);
}
@
% see EOR below

<<function [[flush]]>>=
void
flush(void)
{
    Bflush(&stdout);
}
@


\section{Input: [[clrinp()]], [[rdc()]], [[reread()]]}

<<constant [[EOR]]>>=
#define EOR	'\n'
@
% End Of ? Return?

<<constant [[SPC]]>>=
#define SPC	' '
@

<<constant [[TB]]>>=
#define TB	'\t'
@

<<global [[lp]]>>=
Rune	*lp;
@
% line pointer, buffer usually set to line read on STDIN
% (but can be temporarily altered to get commands from a string
% or from a file)


% poor's man command lexing

<<global [[peekc]]>>=
int	peekc;
@
%todo: change type to Rune?

<<global [[lastc]]>>=
int lastc = EOR;
@
%todo: change type to Rune?
%ugly all those globals

% but many deep commands consumes input, e.g. doexec(),
% so the parsing is really spread, as each command has its
% own mini language




<<function [[clrinp]]>>=
void
clrinp(void)
{
    flush();
    lp = nil;
    peekc = 0;
}
@


<<function [[rdc]]>>=
int
rdc(void)
{
    do {
        readchar();
    } while (lastc==SPC || lastc==TB);
    return lastc;
}
@
% ugly use of global, why readchar() does not return a char instead?
% kinda of lexing also here. 
%less: rename? read_next_non_white_space_char()
% often do rdc(); reread() to position yourself to next non whitespace char
% so that the next readchar() is a character you want to dispatch on.


<<function [[reread]]>>=
void
reread(void)
{
    peekc = lastc;
}
@
% went too far, need to yyback(1)


\section{Interpreter: [[command()]]}

% have seen the repl loop before, so the 'l' and
% the initializations for the 'r' and 'p', here
% we see the 'rep'

% [addr] [,count] [?/=:$ command]

% main (in forloop) -> <>
% often buf is nil and defcom is 0, and don't care about return value
<<function [[command]]>>=
/* command decoding */
int
command(char *buf, int defcom)
{
    <<[[command()]] locals (db)>>

    <<[[command()]] initializations (db)>>

    do {
        <<[[command()]] parse possibly address, set dot>>
        <<[[command()]] parse possibly count, set cntval>>
        <<[[command()]] parse possibly command, set lastcom>>

        switch(lastcom) {
        <<[[command()]] switch lastcom cases>>
        default: 
            error("bad command");
        }
        flushbuf();
    } while (rdc()==';');

    <<[[command()]] finalizations (db)>>

    <<[[command()]] return (db)>>
}
@
%$
%Why returning something? main does not look at its return value anyway.
%Why take buf in parameter? calls to command() with a buf?
%We will see later! there is a command(bkpt->comm, ':')

<<[[command()]] locals (db)>>=
static char lastcom = '=';
@
% so if no command, then use lastcom, so newline will repeat last command.

<<[[command()]] locals (db)>>=
static char savecom = '=';
@

\subsection{Addresses}

<<global [[adrflg]]>>=
bool	adrflg;
@

<<global [[adrval]]>>=
// was in command.c
WORD	adrval;
@


<<[[command()]] parse possibly address, set dot>>=
adrflg=expr(0);		/* first address */
if (adrflg){
    dot=expv;
    ditto=expv;
}
adrval=dot;
@
% no reread() if(!adrflg) ?


\subsection{Counts}

<<global [[cntflg]]>>=
bool	cntflg;
@

% see cntval in core DS chapter.

<<[[command()]] parse possibly count, set cntval>>=
if (rdc()==',' && expr(0)) {	/* count */
    cntflg=TRUE;
    cntval=expv;
} else {
    cntflg=FALSE;
    cntval=1;
    reread();
}
@


\subsection{Commands}

% see CMD_VERBS, single character command

<<[[command()]] parse possibly command, set lastcom>>=
if (!eol(rdc()))
    lastcom=lastc;		/* command */
else {
    if (adrflg==false)
        dot=inkdot(dotinc);
    lastcom=defcom;
    reread();
}
@
% will see dotinc later.

%we will see later a command(bkpt->comm, ':')

<<[[command()]] initializations (db)>>=
if (defcom == 0)
    defcom = lastcom;
@



<<function [[eol]]>>=
bool
eol(int c)
{
    return(c==EOR || c==';');
}
@
% lexing too

<<function [[inkdot]]>>=
ADDR
inkdot(int incr)
{
    ADDR	newdot;

    newdot = dot+incr;
    <<[[inkdot()]] error managment>>
    return newdot;
}
@

<<[[inkdot()]] error managment>>=
if ((incr >= 0 && newdot < dot)
||  (incr < 0 && newdot > dot))
    error("address wraparound");
@

\section{Exit: [[done()]]}

<<global [[eof]]>>=
bool	eof;
@
% who sets that? in readchar(), when C-d

<<[[main()]] in loop, if eof (db)>>=
if (eof) {
    if (infile == STDIN)
        done(); // will exits()
    <<[[main()]] in loop, if eof, and if infile was not STDIN>>
}
@

<<function [[done]]>>=
void
done(void)
{
    if (pid)
        endpcs();
    exits(nil);
}
@

%dead: was never set to true anyway
%<<global exitflg>>=
%bool	exitflg;
%@
%    exits(exitflg? "error": nil);


\chapter{[[libmach/]]}

% a bit reverse of linker. linker actually does not use libmach/,
% but the debugger/profiler/emulator do.

% read .o (objects), read .out (binaries)

\section{[[Fhdr]] and [[crackhdr()]]}

<<function [[crackhdr]]>>=
int
crackhdr(int fd, Fhdr *fp)
{
    ExecTable *mp;
    ExecHdr d;
    int nb, ret;
    ulong magic;

    fp->type = FNONE;
    nb = read(fd, (char *)&d.e, sizeof(d.e));
    if (nb <= 0)
        return 0;

    ret = 0;
    magic = beswal(d.e.magic);		/* big-endian */
    for (mp = exectab; mp->magic; mp++) {
        if (nb < mp->hsize)
            continue;

        /*
         * The magic number has morphed into something
         * with fields (the straw was DYN_MAGIC) so now
         * a flag is needed in Fhdr to distinguish _MAGIC()
         * magic numbers from foreign magic numbers.
         *
         * This code is creaking a bit and if it has to
         * be modified/extended much more it's probably
         * time to step back and redo it all.
         */
        if(mp->_magic){
            if(mp->magic != (magic & ~DYN_MAGIC))
                continue;

//            if(mp->magic == V_MAGIC)
//                mp = couldbe4k(mp);

            if ((magic & DYN_MAGIC) && mp->dlmname != nil)
                fp->name = mp->dlmname;
            else
                fp->name = mp->name;
        }
        else{
            if(mp->magic != magic)
                continue;
            fp->name = mp->name;
        }
        fp->type = mp->type;
        fp->hdrsz = mp->hsize;		/* will be zero on bootables */
        fp->_magic = mp->_magic;
        fp->magic = magic;

        mach = mp->mach;
        if(mp->swal != nil)
            hswal(&d, sizeof(d.e)/sizeof(ulong), mp->swal);
        ret = mp->hparse(fd, fp, &d);
        seek(fd, mp->hsize, 0);		/* seek to end of header */
        break;
    }
    if(mp->magic == 0)
        werrstr("unknown header type");
    return ret;
}
@


\section{ARM}

\section{[[Map]], [[syminit()]], and [[loadmap()]]}

\section{[[machdata]]}

\section{Symbol table}

\chapter{Command Input}

% See CMD_VERBS, crude input command language

% modifies peekc, lastc, lp

<<function [[readchar]]>>=
int
readchar(void)
{
    Rune *p;

    if (eof) {
        lastc='\0';
    } else if (peekc) {
        lastc = peekc;
        peekc = 0;
    } else {
        <<[[readchar()]] if lp is nil read a line and set lp>>
        lastc = *lp;
        if (lastc != '\0')
            lp++;
    }
    return lastc;
}
@
% have seen eof global before. will be set below.

<<global [[line]]>>=
Rune	line[LINSIZ];
@
<<constant [[LINSIZ]]>>=
#define LINSIZ	4096
@

<<[[readchar()]] if lp is nil read a line and set lp>>=
if (lp==nil) {
    for (p = line; p < &line[LINSIZ-1]; p++) {
        eof = (readrune(infile, p) <= 0);
        <<[[readchar()]] if mkfault>>
        if (eof) {
            p--;
            break;
        }
        if (*p == EOR) {
            if (p <= line)
                break;
            if (p[-1] != '\\')
                break;
            p -= 2;
        }
    }
    p[1] = '\0';
    lp = line;
}
@
% eof global actually set here!
% clrinp() will set back lp to nil
% can do \newline to enter multi line commands

<<function [[readrune]]>>=
int
readrune(int fd, Rune *r)
{
    char buf[UTFmax+1];
    int i;

    for(i=0; i<UTFmax && !fullrune(buf, i); i++)
        if(read(fd, buf+i, 1) <= 0)
            return -1; // EOF
    buf[i] = '\0';
    chartorune(r, buf);
    return 1;
}
@


% command (for $ case) -> <>
<<function [[nextchar]]>>=
int
nextchar(void)
{
    if (eol(rdc())) {
        reread();
        return 0;
    }
    return lastc;
}
@

\chapter{Command Parsing}

<<global [[expv]]>>=
// was in expr.c
uvlong	expv;
@

\section{[[expr()]]}

<<function [[expr]]>>=
bool
expr(int a)
{	/* term | term dyadic expr |  */
    bool	rc;
    WORD	lhs;

    rdc();
    reread();

    rc=term(a);
    while (rc) {
        lhs = expv;
        switch ((int)readchar()) {

        case '+':
            term(a|1);
            expv += lhs;
            break;

        case '-':
            term(a|1);
            expv = lhs - expv;
            break;

        case '#':
            term(a|1);
            expv = round(lhs,expv);
            break;

        case '*':
            term(a|1);
            expv *= lhs;
            break;

        case '%':
            term(a|1);
            if(expv != 0)
                expv = lhs/expv;
            else{
                if(lhs)
                    expv = 1;
                else
                    expv = 0;
            }
            break;

        case '&':
            term(a|1);
            expv &= lhs;
            break;

        case '|':
            term(a|1);
            expv |= lhs;
            break;

        case ')':
            if ((a&2)==0)
                error("unexpected `)'");

        default:
            reread();
            return rc;
        }
    }
    return rc;
}
@
% while(rc)?? when this finishes?

\section{[[term()]]}

% *xxx!! inspect value in memory

<<function [[term]]>>=
bool
term(int a)
{	/* item | monadic item | (expr) | */
    ADDR e;

    switch ((int)readchar()) {

    case '*':
        term(a|1);
        if (geta(cormap, expv, &e) < 0)
            error("%r");
        expv = e;
        return true;

    case '@':
        term(a|1);
        if (geta(symmap, expv, &e) < 0)
            error("%r");
        expv = e;
        return true;

    case '-':
        term(a|1);
        expv = -expv;
        return true;

    case '~':
        term(a|1);
        expv = ~expv;
        return true;

    case '(':
        expr(2);
        if (readchar()!=')')
            error("syntax error: `)' expected");
        return true;

    default:
        reread();
        return item(a);
    }
}
@

\section{[[item()]]}

<<function [[item]]>>=
bool
item(int a)
{	/* name [ . local ] | number | . | ^  | <register | 'x | | */
    char	*base;
    char	savc;
    uvlong e;
    Symbol s;
    char gsym[MAXSYM], lsym[MAXSYM];

    readchar();

    if (isfileref()) {
        readfname(gsym);
        rdc();			/* skip white space */
        if (lastc == ':') {	/* it better be */
            rdc();		/* skip white space */
            if (!getnum(readchar))
                error("bad number");
            if (expv == 0)
                expv = 1;	/* file begins at line 1 */
            expv = file2pc(gsym, expv);
            if (expv == -1)
                error("%r");
            return true;
        }
        error("bad file location");
    } else if (symchar(0)) {	
        readsym(gsym);
        if (lastc=='.') {
            readchar();	/* ugh */
            if (lastc == '.') {
                lsym[0] = '.';
                readchar();
                readsym(lsym+1);
            } else if (symchar(0)) {
                readsym(lsym);
            } else
                lsym[0] = 0;
            if (localaddr(cormap, gsym, lsym, &e, rget) < 0)
                error("%r");
            expv = e;
        }
        else {
            if (lookup(0, gsym, &s) == 0)
                error("symbol not found");
            expv = s.value;
        }
        reread();
    } else if (getnum(readchar)) {
        ;
    } else if (lastc=='.') {	
        readchar();
        if (!symchar(0) && lastc != '.') {
            expv = dot;
        } else {
            if (findsym(rget(cormap, mach->pc), CTEXT, &s) == 0)
                error("no current function");
            if (lastc == '.') {
                lsym[0] = '.';
                readchar();
                readsym(lsym+1);
            } else
                readsym(lsym);
            if (localaddr(cormap, s.name, lsym, &e, rget) < 0)
                error("%r");
            expv = e;
        }	
        reread();
    } else if (lastc=='"') {
        expv=ditto;
    } else if (lastc=='+') {
        expv=inkdot(dotinc);
    } else if (lastc=='^') {
        expv=inkdot(-dotinc);
    } else if (lastc=='<') {
        savc=rdc();
        base = regname(savc);
        expv = rget(cormap, base);
    }
    else if (lastc=='\'')
        expv = ascval();
    else if (a)
        error("address expected");
    else {
        reread();
        return false;
    }
    return true;
}
@

<<global [[ditto]]>>=
ADDR	ditto;
@
%??

\chapter{Commands}


\section{Dumper commands: [[$]]}%$
% actually it's also setters command for some of them, like $m

<<[[command()]] switch lastcom cases>>=
case '$':
    lastcom=savecom;
    printtrace(nextchar()); 
    break;
@
%$
% to not save $ as the lastcom

<<function [[printtrace]]>>=
void
printtrace(int modif)
{
    <<[[printtrace()]] locals>>

    if (cntflg==FALSE)
        cntval = -1;

    switch (modif) {
    <<[[printtrace()]] switch modif cases>>
    default:
        error("bad `$' command");
    }

}
@
%$

%XXX
<<[[printtrace()]] locals>>=
int i;
ulong w;
BKPT *bk;
Symbol s;
int stack;
char *fname;
char buf[512];
@

\subsection{Current process: [[$?]]}
%$

<<[[printtrace()]] switch modif cases>>=
case 0:
case '?':
    if (pid)
        dprint("pid = %d\n",pid);
    else
        prints("no process\n");
    flushbuf();
@
% when have 0? when C-d in input of db?


\subsection{Address maps: [[$m]]}
%$

% start easy

<<[[printtrace()]] switch modif cases>>=
case 'm':
    printmap("? map", symmap);
    printmap("/ map", cormap);
    break;
@

<<function [[printmap]]>>=
void
printmap(char *s, Map *map)
{
    int i;

    if (!map)
        return;
    if (map == symmap)
        dprint("%s%12t`%s'\n", s, fsym < 0 ? "-" : symfil);
    else if (map == cormap)
        dprint("%s%12t`%s'\n", s, fcor < 0 ? "-" : corfil);
    else
        dprint("%s\n", s);

    for (i = 0; i < map->nsegs; i++) {
        if (map->seg[i].inuse)
            dprint("%s%8t%-16#llux %-16#llux %-16#llux\n",
                map->seg[i].name, 
                map->seg[i].b,
                map->seg[i].e, 
                map->seg[i].f);
    }
}
@

\subsection{Symbols: [[$S]] and [[$e]]}
%$

<<[[printtrace()]] switch modif cases>>=
case 'S':
    printsym();
    break;
@

% getsym is in libmach? set when machbytype on symfile?

<<function [[printsym]]>>=
/*
 *	dump the raw symbol table
 */
void
printsym(void)
{
    int i;
    Sym *sp;

    for (i = 0; sp = getsym(i); i++) {
        switch(sp->type) {
        case 't':
        case 'l':
            dprint("%16#llux t %s\n", sp->value, sp->name);
            break;
        case 'T':
        case 'L':
            dprint("%16#llux T %s\n", sp->value, sp->name);
            break;
        case 'D':
        case 'd':
        case 'B':
        case 'b':
        case 'a':
        case 'p':
        case 'm':
            dprint("%16#llux %c %s\n", sp->value, sp->type, sp->name);
            break;
        default:
            break;
        }
    }
}
@
%less: default: print error message?

<<[[printtrace()]] switch modif cases>>=
/*print externals*/
case 'e':
    for (i = 0; globalsym(&s, i); i++) {
        if (get4(cormap, s.value, &w) > 0)
            dprint("%s/%12t%#lux\n", s.name, w);
    }
    break;
@


\subsection{Stack traces: [[$c]]}
%$

<<[[printtrace()]] locals>>=
uvlong pc, sp, link;
@

<<global [[tracetype]]>>=
static	int	tracetype;
@
% why need static? can't be local of printtrace? no because
% use by ptrace callback
%ocaml: closure!

<<[[printtrace()]] switch modif cases>>=
case 'c':
case 'C':
    tracetype = modif;
    if (machdata->ctrace) {
        if (adrflg) {
            /*
             * trace from jmpbuf for multi-threaded code.
             * assume sp and pc are in adjacent locations
             * and mach->szaddr in size.
             */
            if (geta(cormap, adrval, &sp) < 0 ||
                geta(cormap, adrval+mach->szaddr, &pc) < 0)
                    error("%r");
        } else {
            sp = rget(cormap, mach->sp);
            pc = rget(cormap, mach->pc);
        }
        if(mach->link)
            link = rget(cormap, mach->link);
        else
            link = 0;
        if (machdata->ctrace(cormap, pc, sp, link, ptrace) <= 0)
            error("no stack frame");
    }
    break;
@

% ??? -> <> (as x <- machdata->ctrace(..., <>) <- printtrace)
<<function [[ptrace]]>>=
/*
 *	callback on stack trace
 */
static void
ptrace(Map *map, uvlong pc, uvlong sp, Symbol *sym)
{
    char buf[512];

    USED(map);
    dprint("%s(", sym->name);
    printparams(sym, sp);
    dprint(") ");
    printsource(sym->value);
    dprint(" called from ");
    symoff(buf, 512, pc, CTEXT);
    dprint("%s ", buf);
    printsource(pc);
    dprint("\n");

    if(tracetype == 'C')
        printlocals(sym, sp);
}
@



\subsection{Registers: [[$r]] and [[$f]]}
%$

<<[[printtrace()]] switch modif cases>>=
case 'r':
case 'R':
    printregs(modif);
    return;
@


<<function [[printregs]]>>=
/*
 * print the registers
 */
void
printregs(int c)
{
    Reglist *rp;
    int i;
    uvlong v;

    for (i = 1, rp = mach->reglist; rp->rname; rp++, i++) {
        if ((rp->rflags & RFLT)) {
            if (c != 'R')
                continue;
            if (rp->rformat == '8' || rp->rformat == '3')
                continue;
        }
        v = getreg(cormap, rp);
        if(rp->rformat == 'Y')
            dprint("%-8s %-20#llux", rp->rname, v);
        else
            dprint("%-8s %-12#lux", rp->rname, (ulong)v);
        if ((i % 3) == 0) {
            dprint("\n");
            i = 0;
        }
    }
    if (i != 1)
        dprint("\n");
    dprint ("%s\n", machdata->excep(cormap, rget));
    printpc();
}
@


<<[[printtrace()]] switch modif cases>>=
case 'f':
case 'F':
    printfp(cormap, modif);
    return;
@

<<function [[printfp]]>>=
static void
printfp(Map *map, int modif)
{
    Reglist *rp;
    int i;
    int ret;
    char buf[512];

    for (i = 0, rp = mach->reglist; rp->rname; rp += ret) {
        ret = 1;
        if (!(rp->rflags & RFLT))
            continue;
        ret = fpformat(map, rp, buf, sizeof(buf), modif);
        if (ret < 0) {
            werrstr("Register %s: %r", rp->rname);
            error("%r");
        }
            /* double column print */
        if (i&0x01)
            dprint("%40t%-8s%-12s\n", rp->rname, buf);
        else
            dprint("\t%-8s%-12s", rp->rname, buf);
        i++;
    }
}
@



\subsection{Quitting: [[$q]]}
%$

%ugly: weird to be in a formatting commands
<<[[printtrace()]] switch modif cases>>=
case 'q':
case 'Q':
    done();
@


\subsection{XXX}


<<[[printtrace()]] switch modif cases>>=
case 'a':
    attachprocess();
    break;
@
% will use addr specificied before as a pid.   <pid> $a

<<function [[attachprocess]]>>=
void
attachprocess(void)
{
    char buf[100];
    Dir *sym, *mem;
    int fd;

    if (!adrflg) {
        dprint("used pid$a\n");
        return;
    }
    sym = dirfstat(fsym);
    sprint(buf, "/proc/%lud/mem", adrval);
    corfil = buf;
    setcor();
    sprint(buf, "/proc/%lud/text", adrval);
    fd = open(buf, OREAD);
    <<[[attachprocess()]] error managment>>
    if (fd >= 0)
        close(fd);
}
@
%$
% used pid$a ??? what is this error msg?


<<[[attachprocess()]] error managment>>=
mem = nil;
if (sym==nil || fd < 0 || (mem=dirfstat(fd))==nil
             || sym->qid.path != mem->qid.path)
    dprint("warning: text images may be inconsistent\n");
free(sym);
free(mem);
@


<<constant [[MAXOFF]]>>=
#define	MAXOFF	0x1000000
@
<<global [[maxoff]]>>=
ADDR maxoff = MAXOFF;
@
<<[[printtrace()]] switch modif cases>>=
case 's':
    maxoff=(adrflg?adrval:MAXOFF);
    break;
@
% ???


<<[[printtrace()]] switch modif cases>>=
case 'M':
    fname = getfname();
    if (machbyname(fname) == 0)
        dprint("unknown name\n");;
    break;
@

\section{Inspecting commands, [[?/=]]}
% and modifying

<<[[command()]] switch lastcom cases>>=
case '?':
case '/':
case '=':
    savecom = lastcom;
    acommand(lastcom);
    break;
@
% savecom is for what? it's actually used when have a '$'
% to not consider it as the saved last command.
%less: rename save_last_acom?

<<function [[acommand]]>>=
/*
 * [/?][wml]
 */
void
acommand(int pc)
{
    bool eqcom;
    Map *map;
    char *fmt;
    char buf[512];

    if (pc == '=') {
        eqcom = true;
        fmt = eqformat;
        map = dotmap;
    } else {
        eqcom = false;
        fmt = stformat;
        if (pc == '/')
            map = cormap;
        else
            map = symmap;
    }
    if (!map) {
        snprint(buf, sizeof(buf), "no map for %c", pc);
        error(buf);
    }

    switch (rdc()) {
    <<[[acommand()]] switch optional command suffix character>>
    default:
        reread();
        getformat(fmt);
        scanform(cntval, !eqcom, fmt, map, eqcom);
    }
}
@
%less: could rewrite using switch(pc) I think; duplicate instr but cleaner

\subsection{Formats}

<<constant [[ARB]]>>=
#define	ARB	512
@

<<global [[eqformat]]>>=
char	eqformat[ARB] = "z";
@

<<global [[stformat]]>>=
char	stformat[ARB] = "zMi";
@


<<global [[dotmap]]>>=
Map	*dotmap;
@
% so can have general mechanism in expr that works for =,
% with a fake Map?
<<[[main()]] set dotmap>>=
dotmap = dumbmap(-1);
@


<<function [[getformat]]>>=
void
getformat(char *deformat)
{
    char *fptr;
    bool	quote;
    Rune r;

    fptr=deformat;
    quote=FALSE;
    while ((quote ? readchar()!=EOR : !eol(readchar()))){
        r = lastc;
        fptr += runetochar(fptr, &r);
        if (lastc == '"')
            quote = ~quote;
    }
    lp--;
    if (fptr!=deformat)
        *fptr = '\0';
}
@
% lp-- ??? get back in lp?


<<function [[scanform]]>>=
void
scanform(long icount, int prt, char *ifp, Map *map, int literal)
{
    char	*fp;
    char	c;
    int	fcount;
    ADDR	savdot;
    bool firstpass = true;

    while (icount) {
        fp=ifp;
        savdot=dot;

        /*now loop over format*/
        while (*fp) {
            if (!isdigit(*fp))
                fcount = 1;
            else {
                fcount = 0;
                while (isdigit(c = *fp++)) {
                    fcount *= 10;
                    fcount += c-'0';
                }
                fp--;
            }
            if (*fp==0)
                break;
            fp=exform(fcount,prt,fp,map,literal,firstpass);
            firstpass = false;
        }
        dotinc=dot-savdot;
        dot=savdot;
        if (--icount)
            dot=inkdot(dotinc);
    }
}
@


<<function [[exform]]>>=
char *
exform(int fcount, int prt, char *ifp, Map *map, int literal, bool firstpass)
{
    /* execute single format item `fcount' times
     * sets `dotinc' and moves `dot'
     * returns address of next format item
     */
    uvlong	v;
    ulong	w;
    ADDR	savdot;
    char	*fp;
    char	c, modifier;
    int	i;
    ushort sh, *sp;
    uchar ch, *cp;
    Symbol s;
    char buf[512];
    extern int printcol;

    fp = 0;
    while (fcount > 0) {
        fp = ifp;
        c = *fp;
        modifier = *fp++;
        if (firstpass) {
            firstpass = false;
            if (!literal  && (c == 'i' || c == 'I' || c == 'M')
                    && (dot & (mach->pcquant-1))) {
                dprint("warning: instruction not aligned");
                printc('\n');
            }
            if (prt && modifier != 'a' && modifier != 'A') {
                symoff(buf, 512, dot, CANY);
                dprint("%s%c%16t", buf, map==symmap? '?':'/');
            }
        }
        if (printcol==0 && modifier != 'a' && modifier != 'A')
            dprint("\t\t");

        switch(modifier) {
        <<[[exform()]] switch modifier cases>>
        default:
            error("bad modifier");
        }

        if (map->seg[0].fd >= 0)
            dot=inkdot(dotinc);
        fcount--;
        endline();
    }

    return fp;
}
@


<<function [[endline]]>>=
void
endline(void)
{

    if (printcol >= maxpos)
        newline();
}
@

<<constant [[MAXPOS]]>>=
#define MAXPOS	80
@
<<global [[maxpos]]>>=
int	maxpos = MAXPOS;
@

<<[[printtrace()]] switch modif cases>>=
case 'w':
    maxpos=(adrflg?adrval:MAXPOS);
    break;
@
% 100 $w



\subsection{Instruction disassembling: [[?i]]}

%real-world: objdump --disassemble, llvm-mc --disassemble?

<<[[exform()]] switch modifier cases>>=
case 'I':
case 'i':
    i = machdata->das(map, dot, modifier, buf, sizeof(buf));
    if (i < 0)
        error("%r");
    dotinc = i;
    dprint("%s\n", buf);
    break;
@

<<global [[dotinc]]>>=
int	dotinc;
@

\subsection{Registers}



\subsection{XXX}

<<[[exform()]] switch modifier cases>>=
case SPC:
case TB:
    dotinc = 0;
    break;
@

<<[[exform()]] switch modifier cases>>=
case 't':
case 'T':
    dprint("%*t", fcount);
    dotinc = 0;
    return(fp);
@
<<[[exform()]] switch modifier cases>>=
case 'a':
    symoff(buf, sizeof(buf), dot, CANY);
    dprint("%s%c%16t", buf, map==symmap? '?':'/');
    dotinc = 0;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'A':
    dprint("%#llux%10t", dot);
    dotinc = 0;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'p':
    if (get4(map, dot, &w) < 0)
        error("%r");
    symoff(buf, sizeof(buf), w, CANY);
    dprint("%s%16t", buf);
    dotinc = mach->szaddr;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'u':
case 'd':
case 'x':
case 'o':
case 'q':
    if (literal)
        sh = (ushort) dot;
    else if (get2(map, dot, &sh) < 0)
        error("%r");
    w = sh;
    dotinc = 2;
    if (c == 'u')
        dprint("%-8lud", w);
    else if (c == 'x')
        dprint("%-8#lux", w);
    else if (c == 'd')
        dprint("%-8ld", w);
    else if (c == 'o')
        dprint("%-8#luo", w);
    else if (c == 'q')
        dprint("%-8#lo", w);
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'U':
case 'D':
case 'X':
case 'O':
case 'Q':
    if (literal)
        w = (long) dot;
    else if (get4(map, dot, &w) < 0)
        error("%r");
    dotinc = 4;
    if (c == 'U')
        dprint("%-16lud", w);
    else if (c == 'X')
        dprint("%-16#lux", w);
    else if (c == 'D')
        dprint("%-16ld", w);
    else if (c == 'O')
        dprint("%-#16luo", w);
    else if (c == 'Q')
        dprint("%-#16lo", w);
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'Z':
case 'V':
case 'Y':
    if (literal)
        v = dot;
    else if (get8(map, dot, &v) < 0)
        error("%r");
    dotinc = 8;
    if (c == 'Y')
        dprint("%-20#llux", v);
    else if (c == 'V')
        dprint("%-20lld", v);
    else if (c == 'Z')
        dprint("%-20llud", v);
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'B':
case 'b':
case 'c':
case 'C':
    if (literal)
        ch = (uchar) dot;
    else if (get1(map, dot, &ch, 1)  < 0)
        error("%r");
    if (modifier == 'C')
        printesc(ch);
    else if (modifier == 'B' || modifier == 'b')
        dprint("%-8#lux", (long) ch);
    else
        printc(ch);
    dotinc = 1;
    break;
@

<<function [[printesc]]>>=
void
printesc(int c)
{
    static char hex[] = "0123456789abcdef";

    if (c < SPC || c >= 0177)
        dprint("\\x%c%c", hex[(c&0xF0)>>4], hex[c&0xF]);
    else
        printc(c);
}
@


<<[[exform()]] switch modifier cases>>=
case 'r':
    if (literal)
        sh = (ushort) dot;
    else if (get2(map, dot, &sh) < 0)
        error("%r");
    dprint("%C", sh);
    dotinc = 2;
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'R':
    if (literal) {
        sp = (ushort*) &dot;
        dprint("%C%C", sp[0], sp[1]);
        endline();
        dotinc = 4;
        break;
    }
    savdot=dot;
    while ((i = get2(map, dot, &sh) > 0) && sh) {
        dot=inkdot(2);
        dprint("%C", sh);
        endline();
    }
    if (i < 0)
        error("%r");
    dotinc = dot-savdot+2;
    dot=savdot;
    break;
@

<<[[exform()]] switch modifier cases>>=
case 's':
    if (literal) {
        cp = (uchar*) &dot;
        for (i = 0; i < 4; i++)
            buf[i] = cp[i];
        buf[i] = 0;
        dprint("%s", buf);
        endline();
        dotinc = 4;
        break;
    }
    savdot = dot;
    for(;;){
        i = 0;
        do{
            if (get1(map, dot, (uchar*)&buf[i], 1) < 0)
                error("%r");
            dot = inkdot(1);
            i++;
        }while(!fullrune(buf, i));
        if(buf[0] == 0)
            break;
        buf[i] = 0;
        dprint("%s", buf);
        endline();
    }
    dotinc = dot-savdot+1;
    dot = savdot;
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'S':
    if (literal) {
        cp = (uchar*) &dot;
        for (i = 0; i < 4; i++)
            printesc(cp[i]);
        endline();
        dotinc = 4;
        break;
    }
    savdot=dot;
    while ((i = get1(map, dot, &ch, 1) > 0) && ch) {
        dot=inkdot(1);
        printesc(ch);
        endline();
    }
    if (i < 0)
        error("%r");
    dotinc = dot-savdot+1;
    dot=savdot;
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'M':
    i = machdata->hexinst(map, dot, buf, sizeof(buf));
    if (i < 0)
        error("%r");
    dotinc = i;
    dprint("%s", buf);
    if (*fp) {
        dotinc = 0;
        dprint("%48t");
    } else
        dprint("\n");
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'f':
    /* BUG: 'f' and 'F' assume szdouble is sizeof(vlong) in the literal case */
    if (literal) {
        v = machdata->swav(dot);
        memmove(buf, &v, mach->szfloat);
    }else if (get1(map, dot, (uchar*)buf, mach->szfloat) < 0)
        error("%r");
    machdata->sftos(buf, sizeof(buf), (void*) buf);
    dprint("%s\n", buf);
    dotinc = mach->szfloat;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'F':
    /* BUG: 'f' and 'F' assume szdouble is sizeof(vlong) in the literal case */
    if (literal) {
        v = machdata->swav(dot);
        memmove(buf, &v, mach->szdouble);
    }else if (get1(map, dot, (uchar*)buf, mach->szdouble) < 0)
        error("%r");
    machdata->dftos(buf, sizeof(buf), (void*) buf);
    dprint("%s\n", buf);
    dotinc = mach->szdouble;
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'n':
case 'N':
    printc('\n');
    dotinc=0;
    break;
@

<<[[exform()]] switch modifier cases>>=
case '"':
    dotinc=0;
    while (*fp != '"' && *fp)
        printc(*fp++);
    if (*fp)
        fp++;
    break;
@

<<[[exform()]] switch modifier cases>>=
case '^':
    dot=inkdot(-dotinc*fcount);
    return(fp);
@
<<[[exform()]] switch modifier cases>>=
case '+':
    dot=inkdot((WORD)fcount);
    return(fp);
@
<<[[exform()]] switch modifier cases>>=
case '-':
    dot=inkdot(-(WORD)fcount);
    return(fp);
@

<<[[exform()]] switch modifier cases>>=
case 'z':
    if (findsym(dot, CTEXT, &s))
        dprint("%s() ", s.name);
    printsource(dot);
    printc(EOR);
    return fp;

@




%XXX
<<[[acommand()]] switch optional command suffix character>>=
case 'm':
    if (eqcom)
        error(BADEQ); 
    cmdmap(map);
    break;
@

<<function [[cmdmap]]>>=
/*
 * set up maps for a direct process image (/proc)
 */

void
cmdmap(Map *map)
{
    int i;
    char name[MAXSYM];

    extern char lastc;

    rdc();
    readsym(name);
    i = findseg(map, name);
    if (i < 0)	/* not found */
        error("Invalid map name");

    if (expr(0)) {
        if (strcmp(name, "text") == 0)
            textseg(expv, &fhdr);
        map->seg[i].b = expv;
    } else
        error("Invalid base address"); 
    if (expr(0))
        map->seg[i].e = expv;
    else
        error("Invalid end address"); 
    if (expr(0))
        map->seg[i].f = expv; 
    else
        error("Invalid file offset"); 
    if (rdc()=='?' && map == cormap) {
        if (fcor)
            close(fcor);
        fcor=fsym;
        corfil=symfil;
        cormap = symmap;
    } else if (lastc == '/' && map == symmap) {
        if (fsym)
            close(fsym);
        fsym=fcor;
        symfil=corfil;
        symmap=cormap;
    } else
        reread();
}
@




<<[[acommand()]] switch optional command suffix character>>=
case 'L':
case 'l':
    if (eqcom)
        error(BADEQ); 
    cmdsrc(lastc, map);
    break;

@

<<function [[cmdsrc]]>>=
void
cmdsrc(int c, Map *map)
{
    ulong w;
    long locval, locmsk;
    ADDR savdot;
    ushort sh;
    char buf[512];
    int ret;

    if (c == 'L')
        dotinc = 4;
    else
        dotinc = 2;
    savdot=dot;
    expr(1); 
    locval=expv;
    if (expr(0))
        locmsk=expv; 
    else
        locmsk = ~0;
    if (c == 'L')
        while ((ret = get4(map, dot, &w)) > 0 &&  (w&locmsk) != locval)
            dot = inkdot(dotinc);
    else
        while ((ret = get2(map, dot, &sh)) > 0 && (sh&locmsk) != locval)
            dot = inkdot(dotinc);
    if (ret < 0) { 
        dot=savdot; 
        error("%r");
    }
    symoff(buf, 512, dot, CANY);
    dprint(buf);
}
@





<<[[acommand()]] switch optional command suffix character>>=
case 'W':
case 'w':
    if (eqcom)
        error(BADEQ); 
    cmdwrite(lastc, map);
    break;
@


<<global [[badwrite]]>>=
static char badwrite[] = "can't write process memory or text image";
@

<<function [[cmdwrite]]>>=
void
cmdwrite(int wcom, Map *map)
{
    ADDR savdot;
    char *format;
    int pass;

    if (wcom == 'w')
        format = "x";
    else
        format = "X";
    expr(1);
    pass = 0;
    do {
        pass++;  
        savdot=dot;
        exform(1, 1, format, map, 0, pass);
        dot=savdot;
        if (wcom == 'W') {
            if (put4(map, dot, expv) <= 0)
                error(badwrite);
        } else {
            if (put2(map, dot, expv) <= 0)
                error(badwrite);
        }
        savdot=dot;
        dprint("=%8t"); 
        exform(1, 0, format, map, 0, pass);
        newline();
    } while (expr(0));
    dot=savdot;
}
@

<<function [[newline]]>>=
void
newline(void)
{
    printc(EOR);
}
@
%less: inline

\section{Sub process control commands, [[:]]}%$

<<[[command()]] switch lastcom cases>>=
case ':':
    if (!executing) { 
        executing=TRUE;
        subpcs(nextchar());
        executing=FALSE;
        lastcom=savecom;
    }
    break;
@
% when can have executing at false here?

<<global [[executing]]>>=
bool	executing;
@

<<[[main()]] just before repl>>=
if (executing)
    delbp();
executing = FALSE;
@
% can arrive here when an error occured somewhere in which
% case we longjmp back and executing has not been set back to FALSE
% and so we need to clean things up.


<<function [[subpcs]]>>=
/* sub process control */

void
subpcs(int modif)
{
    // enum<runmode>
    int	runmode = SINGLE;
    bool keepnote = false;
    int	check;
    int	n;
    int r = 0;
    long line, curr;
    BKPT *bk;
    char *comptr;

    loopcnt=cntval;

    switch (modif) {
    <<[[subpcs()]] switch modif cases>>
    default:
        error("bad `:' command");
    }

    if (loopcnt>0) {
        dprint("%s: running\n", symfil);
        flush();
        r = runpcs(runmode, keepnote);
    }
    if (r)
        dprint("breakpoint%16t");
    else
        dprint("stopped at%16t");

Return:
    delbp();
    printpc();
    notes();
}
@

<<global [[loopcnt]]>>=
WORD loopcnt;
@
% why need global? because used in runpcs too

\subsection{[[printpc()]]}

% subpbcs | main (when corfile) -> <>
<<function [[printpc]]>>=
void
printpc(void)
{
    char buf[512];

    dot = rget(cormap, mach->pc);
    if(dot){
        printsource((long)dot);
        printc(' ');
        symoff(buf, sizeof(buf), (long)dot, CTEXT);
        dprint("%s/", buf);
        if (machdata->das(cormap, dot, 'i', buf, sizeof(buf)) < 0)
            error("%r");
        dprint("%16t%s\n", buf);
    }
}
@

<<constant [[STRINGSZ]]>>=
#define	STRINGSZ	128
@

<<function [[printsource]]>>=
/*
 *	print the value of dot as file:line
 */
void
printsource(ADDR dot)
{
    char str[STRINGSZ];

    if (fileline(str, STRINGSZ, dot))
        dprint("%s", str);
}
@
% fileline in libmach()
% C location or assembly location.


\subsection{Runmodes}

<<constant [[SINGLE]]>>=
#define	SINGLE	1
@
%todo: enum? enum runmode

<<constant [[CONTIN]]>>=
#define	CONTIN	2
@
% next breakpoint

\subsection{[[runpcs()]]}

% subpcs -> <>
<<function [[runpcs]]>>=
/* service routines for sub process control */
int
runpcs(int runmode, bool keepnote)
{
    int rc = 0; // runcount
    BKPT *bkpt;

    if (adrflg)
        rput(cormap, mach->pc, dot);
    dot = rget(cormap, mach->pc);
    flush();

    while (loopcnt-- > 0) {
        if(loopcnt != 0)
            printpc();
        if (runmode == SINGLE) {
            <<[[runpcs()]] in SINGLE mode, clean breakpoint if at dot>>
            runstep(dot, keepnote);
        } else {
            if ((bkpt = scanbkpt(rget(cormap, mach->pc))) != nil) {
                execbkpt(bkpt, keepnote);
                keepnote = false;
            }
            setbp();
            runrun(keepnote);
        }
        keepnote = false;
        delbp();
        dot = rget(cormap, mach->pc);

        /* real note? */
        if (nnote > 0) {
            keepnote = true;
            rc = 0;
            continue;
        }
        bkpt = scanbkpt(dot);
        if(bkpt == nil){
            keepnote = false;
            rc = 0;
            continue;
        }
        /* breakpoint */
        if (bkpt->flag == BKPTTMP)
            bkpt->flag = BKPTCLR;
        else if (bkpt->flag == BKPTSKIP) {
            execbkpt(bkpt, keepnote);
            keepnote = false;
            loopcnt++;	/* we didn't really stop */
            continue;
        }
        else {
            bkpt->flag = BKPTSKIP;
            --bkpt->count;
            if ((bkpt->comm[0] == EOR || command(bkpt->comm, ':') != 0)
                && bkpt->count != 0) {
                execbkpt(bkpt, keepnote);
                keepnote = false;
                loopcnt++;
                continue;
            }
            bkpt->count = bkpt->initcnt;
        }
        rc = 1;
    }
    return rc;
}
@

<<[[command()]] return (db)>>=
if(adrflg)
    return dot;
return 1;
@


<<[[runpcs()]] in SINGLE mode, clean breakpoint if at dot>>=
bkpt = scanbkpt(dot);
if (bkpt) {
    switch(bkpt->flag){
    case BKPTTMP:
        bkpt->flag = BKPTCLR;
        break;
    case BKPTSKIP:
        bkpt->flag = BKPTSET;
        break;
    }
}
@





\subsection{Running: [[:r]]}

<<[[subpcs()]] switch modif cases>>=
/* run program */
case 'r': 
case 'R':
    endpcs();
    setup();
    runmode = CONTIN;
    break;
@

\subsubsection{[[setup()]] and [[startpcs()]]}

% subpcs (when :r) -> <>
<<function [[setup]]>>=
/*
 * start up the program to be debugged in a child
 */
void
setup(void)
{

    nnote = 0;
    startpcs();
    pcsactive = true;
    bpin = FALSE;
}
@
% break point not installed yet, will be in setbp

% setup | ??? -> <>
<<function [[startpcs]]>>=
void
startpcs(void)
{
    pid = fork();
    // child
    if (pid == 0) {
        pid = getpid();
        msgpcs("hang");
        doexec();
        exits(nil); // reachable?
    }
    // parent
    if (pid == -1)
        error("can't fork");
    child++;
    sprint(procname, "/proc/%d/mem", pid);
    corfil = procname;
    msgpcs("waitstop");

    // will call setcor()
    bpwait();

    if (adrflg)
        rput(cormap, mach->pc, adrval);

    while (rdc() != EOR)
        ;
    reread();
}
@

<<global [[procname]]>>=
static char	procname[100];
@
%pad: I added the static at least.
%need global (static) because corfile points to it and outlive startpcs


<<function [[bpwait]]>>=
void
bpwait(void)
{
    setcor();
    unloadnote();
}
@


<<global [[child]]>>=
int child;
@

\subsubsection{[[doexec()]]}

<<constant [[MAXARG]]>>=
#define MAXARG	32
@

<<function [[doexec]]>>=
void
doexec(void)
{
    char *argl[MAXARG];
    char args[LINSIZ];
    char *p;
    char **ap;
    char *thisarg;

    ap = argl;
    p = args;
    // argv[0] is the command itself
    *ap++ = symfil;

    <<[[doexec()]] adjust argl if extra arguments>>
    *ap = '\0';

    exec(symfil, argl);
    perror(symfil);
}
@


% hmm but fork, so share stdin for the command?

<<[[doexec()]] adjust argl if extra arguments>>=
for (rdc(); lastc != EOR;) {
    thisarg = p;
    if (lastc == '<' || lastc == '>') {
        *p++ = lastc;
        rdc();
    }
    while (lastc != EOR && lastc != SPC && lastc != TB) {
        *p++ = lastc;
        readchar();
    }
    if (lastc == SPC || lastc == TB)
        rdc();
    *p++ = 0;
    if (*thisarg == '<') {
        close(0);
        if (open(&thisarg[1], OREAD) < 0) {
            print("%s: cannot open\n", &thisarg[1]);
            _exits(0);
        }
    }
    else if (*thisarg == '>') {
        close(1);
        if (create(&thisarg[1], OWRITE, 0666) < 0) {
            print("%s: cannot create\n", &thisarg[1]);
            _exits(0);
        }
    }
    else
        *ap++ = thisarg;
}
@

\subsubsection{[[runrun()]]}

<<function [[runrun]]>>=
void
runrun(bool keepnote)
{
    <<[[runrun()]] notes managment>>

    flush();
    msgpcs("startstop");
    bpwait();
}
@


<<[[runrun()]] notes managment>>=
int on = nnote;

unloadnote();
if(on != nnote){
    notes();
    error("not running: new notes pending");
}
if(keepnote)
    loadnote();
else
    nnote = 0;
@


\subsection{Stepping: [[:s]]}
%gdb: stepi

<<[[subpcs()]] switch modif cases>>=
/* single step */
case 's': 
    if (pid == 0) {
        setup();
        loopcnt--;
    }
    runmode=SINGLE;
    keepnote=defval(true);
    break;
@

<<function [[defval]]>>=
WORD
defval(WORD w)
{
    if (expr(0))
        return (expv);
    else
        return (w);
}
@

% runpcs (when SINGLE) -> <>
<<function [[runstep]]>>=
void
runstep(uvlong loc, bool keepnote)
{
    int nfoll;
    uvlong foll[3];
    BKPT bkpt[3];
    int i;

    if(machdata->foll == 0){
        dprint("stepping unimplemented; assuming not a branch\n");
        nfoll = 1;
        foll[0] = loc+mach->pcquant;
    }else {
        nfoll = machdata->foll(cormap, loc, rget, foll);
        if (nfoll < 0)
            error("%r");
    }
    memset(bkpt, 0, sizeof bkpt);
    for(i=0; i<nfoll; i++){
        if(foll[i] == loc)
            error("can't single step: next instruction is dot");
        bkpt[i].loc = foll[i];
        bkput(&bkpt[i], true);
    }

    runrun(keepnote);
    for(i=0; i<nfoll; i++)
        bkput(&bkpt[i], false);
}
@
% single step call runrun in the end

\subsection{Killing: [[:k]]}


<<global [[NOPCS]]>>=
char	NOPCS[] = "no process";
@

<<[[subpcs()]] switch modif cases>>=
/* exit */
case 'k' :
case 'K':
    if (pid == 0)
        error(NOPCS);
    dprint("%d: killed", pid);
    pcsactive = true;	/* force 'kill' ctl */
    endpcs();
    return;
@


<<global [[ending]]>>=
// was in runpcs.c
bool ending;
@

<<function [[endpcs]]>>=
/*
 * finish the process off;
 * kill if still running
 */
void
endpcs(void)
{
    BKPT *bk;

    if(ending)
        return;
    ending = true;
    if (pid) {
        if(pcsactive){
            killpcs();
            pcsactive = false;
        }
        pid=0;
        nnote=0;
        for (bk=bkpthead; bk; bk = bk->nxtbkpt)
            if (bk->flag == BKPTTMP)
                bk->flag = BKPTCLR;
            else if (bk->flag != BKPTCLR)
                bk->flag = BKPTSET;
    }
    bpin = FALSE;
    ending = false;
}
@

<<function [[killpcs]]>>=
void
killpcs(void)
{
    msgpcs("kill");
}
@



<<global [[bpin]]>>=
bool bpin;
@
% shared with delbp()
% breakpoint in, a bit like pcsactive, we do things lazily
% so it's not yet in, but will be in once setbp() has been called




\subsection{Halting: [[:h]]}
% happens when we attach to a process and we want to stop it.

<<[[subpcs()]] switch modif cases>>=
/* halt the current process */
case 'h':	
    <<[[subpcs()]] halting case, if addr 0 specified>>
    else {
        grab();
        dprint("stopped at%16t");
        goto Return;
    }
    return;
@
% %t???

<<function [[grab]]>>=
void
grab(void)
{
    flush();
    msgpcs("stop");
    bpwait();
}
@



<<[[subpcs()]] halting case, if addr 0 specified>>=
if (adrflg && adrval == 0) {
    if (pid == 0)
        error(NOPCS);
    ungrab();
}
@



\subsection{Unhalting: [[:x]]}

<<[[subpcs()]] switch modif cases>>=
/* continue executing the current process */
case 'x':	
    if (pid == 0)
        error(NOPCS);
    ungrab();
    return;
@

<<function [[ungrab]]>>=
void
ungrab(void)
{
    msgpcs("start");
}
@
%less: delete? inline the code?

\section{Breakpoints}

<<function [[scanbkpt]]>>=
/*
 * find the breakpoint at adr, if any
 */
BKPT*
scanbkpt(ADDR adr)
{
    BKPT *bk;

    for (bk = bkpthead; bk; bk = bk->nxtbkpt)
        if (bk->flag != BKPTCLR && bk->loc == adr)
            break;
    return bk;
}
@


\subsection{Inspecting breakpoints: [[$b]]}
%$

<<[[printtrace()]] switch modif cases>>=
/*print breakpoints*/
case 'b':
case 'B':
    for (bk=bkpthead; bk; bk=bk->nxtbkpt)
        if (bk->flag) {
            symoff(buf, 512, (WORD)bk->loc, CTEXT);
            dprint(buf);
            if (bk->count != 1)
                dprint(",%d", bk->count);
            dprint(":%c %s", 
                     bk->flag == BKPTTMP ? 'B' : 'b', 
                     bk->comm);
        }
    break;
@
% symoff use a global?

\subsection{Setting breakpoints: [[:b]]}

<<[[subpcs()]] switch modif cases>>=
/* set breakpoint */
case 'b': 
case 'B':
    if (bk=scanbkpt(dot))
        bk->flag=BKPTCLR;

    <<[[subpcs()]] breakpoint case, find unused breakpoint bk or allocate one>>

    bk->loc = dot;
    bk->flag = modif == 'b' ? BKPTSET : BKPTTMP;
    bk->initcnt = bk->count = cntval;

    <<[[subpcs()]] breakpoint case, set optional breakpoint command>>
@




<<[[subpcs()]] breakpoint case, find unused breakpoint bk or allocate one>>=
for (bk=bkpthead; bk; bk=bk->nxtbkpt)
    if (bk->flag == BKPTCLR)
        break;
if (bk==nil) {
    bk = (BKPT *)malloc(sizeof(*bk));
    if (bk == nil)
        error("too many breakpoints");
    bk->nxtbkpt=bkpthead;
    bkpthead=bk;
}
@




\subsection{Deleting breakpoints: [[:d]]}

<<[[subpcs()]] switch modif cases>>=
/* delete breakpoint */
case 'd': 
case 'D':
    if ((bk=scanbkpt(dot)) == 0)
        error("no breakpoint set");
    bk->flag=BKPTCLR;
    return;
@

\subsection{Continuing execution: [[:c]]}

<<[[subpcs()]] switch modif cases>>=
/* continue with optional note */
case 'c': 
case 'C': 
    if (pid==0)
        error(NOPCS);
    runmode=CONTIN;
    keepnote=defval(1);
    break;
@





\subsection{Installing breakpoints}

<<function [[setbp]]>>=
/*
 * install all the breakpoints
 */

void
setbp(void)
{
    BKPT *bk;

    if (bpin == TRUE || pid == 0)
        return;
    for (bk = bkpthead; bk; bk = bk->nxtbkpt)
        if (bk->flag != BKPTCLR)
            bkput(bk, true);
    bpin = TRUE;
}
@

%machdata->bpinst ! the instruction generating a sys: breakpoint
<<function [[bkput]]>>=
void
bkput(BKPT *bp, bool install)
{
    char buf[256];
    ADDR loc;
    int ret;

    errstr(buf, sizeof buf);
    if(machdata->bpfix)
        loc = (*machdata->bpfix)(bp->loc);
    else
        loc = bp->loc;

    if(install){
        ret = get1(cormap, loc, bp->save, machdata->bpsize);
        if (ret > 0)
            ret = put1(cormap, loc, machdata->bpinst, machdata->bpsize);
    }else
        ret = put1(cormap, loc, bp->save, machdata->bpsize);

    if(ret < 0){
        sprint(buf, "can't set breakpoint at %#llux: %r", bp->loc);
        print(buf);
        read(0, buf, 100);
    }
}
@

\subsection{Uninstalling breakpoints}

% ??? -> <>
<<function [[delbp]]>>=
/*
 * remove all breakpoints from the process' address space
 */

void
delbp(void)
{
    BKPT *bk;

    if (bpin == FALSE || pid == 0)
        return;
    for (bk = bkpthead; bk; bk = bk->nxtbkpt)
        if (bk->flag != BKPTCLR)
            bkput(bk, false);
    bpin = FALSE;
}
@

\subsection{Executing breakpoints}

<<function [[execbkpt]]>>=
/*
 * skip over a breakpoint:
 * remove breakpoints, then single step
 * so we can put it back
 */
void
execbkpt(BKPT *bk, int keepnote)
{
    runstep(bk->loc, keepnote);
    bk->flag = BKPTSET;
}
@

\subsection{Breakpoints and notes}

%\subsection{Advanced breakpoints}
% see in advanced topics now



\section{Other commands}


<<[[command()]] locals (db)>>=
char	*reg;
char	savc;
@
% need to be called savc?

<<[[command()]] switch lastcom cases>>=
case '>':
    lastcom = savecom; 
    savc=rdc();
    if (reg=regname(savc))
        rput(cormap, reg, dot);
    else	
        error("bad variable");
    break;
@


\chapter{Metadata Generation}

\section{Assembler}

\section{Compiler}

\section{Linker}

\chapter{Source level C Debugging}
% C support

\section{Stepping: [[:S]]}

<<[[subpcs()]] switch modif cases>>=
case 'S':
    if (pid == 0) {
        setup();
        loopcnt--;
    }
    keepnote=defval(true);

    line = pc2line(rget(cormap, mach->pc));
    n = loopcnt;
    dprint("%s: running\n", symfil);
    flush();
    for (loopcnt = 1; n > 0; loopcnt = 1) {
        r = runpcs(SINGLE, keepnote);
        curr = pc2line(dot);
        if (line != curr) {	/* on a new line of c */
            line = curr;
            n--;
        }
    }
    loopcnt = 0;
    break;
@

%pc2line also in libmach?


\section{Stack traces: [[$S]]}
%$


<<function [[printparams]]>>=
void
printparams(Symbol *fn, ADDR fp)
{
    int i;
    Symbol s;
    ulong w;
    int first = 0;

    fp += mach->szaddr;			/* skip saved pc */
    s = *fn;
    for (i = 0; localsym(&s, i); i++) {
        if (s.class != CPARAM)
            continue;
        if (first++)
            dprint(", ");
        if (get4(cormap, fp+s.value, &w) > 0)
            dprint("%s=%#lux", s.name, w);
    }
}
@



% ... -> ptrace -> <>
<<function [[printlocals]]>>=
void
printlocals(Symbol *fn, ADDR fp)
{
    int i;
    ulong w;
    Symbol s;

    s = *fn;
    for (i = 0; localsym(&s, i); i++) {
        if (s.class != CAUTO)
            continue;
        if (get4(cormap, fp-s.value, &w) > 0)
            dprint("%8t%s.%s/%10t%#lux\n", fn->name, s.name, w);
        else
            dprint("%8t%s.%s/%10t?\n", fn->name, s.name);
    }
}
@

\chapter{[[/bin/strace]]}

% good to see first? allow to understand /proc/x/ctl?
% things that will be needed later.
% maybe not

\chapter{[[acid]]}

%pad: to please syncweb -to_tex checker
\ifallcode
<<acid/y.tab.h>>=
@
\fi

\chapter{Advanced Features}

\section{Conditional breakpoints}

<<constant [[MAXCOM]]>>=
#define MAXCOM	64
@
<<[[Bkpt]] other fields>>=
char	comm[MAXCOM];
@


<<constant HUGEINT (db)>>=
#define	HUGEINT	0x7fffffff	/* enormous WORD */
@

<<[[subpcs()]] breakpoint case, set optional breakpoint command>>=
check=MAXCOM-1;
comptr=bk->comm;

rdc();
reread();

do {
    *comptr++ = readchar();
} while (check-- && lastc!=EOR);
*comptr='\0';
if(bk->comm[0] != EOR && cntflg == FALSE)
    bk->initcnt = bk->count = HUGEINT;
reread();
if (check)
    return;
error("bkpt command too long");
@



%\subsection{Non stdin debugging commands}

% dead code? who calls command with a buf? when have advanced breakpoints!

<<[[command()]] initializations (db)>>=
if (buf) {
    if (*buf==EOR)
        return FALSE;
    clrinp();
    lp=(Rune*)buf;
}
@
% modify lp! so all next readchar will work on this new line.

<<[[command()]] locals (db)>>=
Rune*   savlp = lp;
char	savlc = lastc;
char	savpc = peekc;
@

<<[[command()]] finalizations (db)>>=
if (buf == nil)
    reread();
else {
    clrinp();
    lp=savlp;
    lastc = savlc;
    peekc = savpc;
}
@


\section{Input file debugging commands}
% meh

% hmm, why input stuff in output.c???
<<constant [[MAXIFD]]>>=
#define	MAXIFD	5
@

<<global [[istack]]>>=
struct {
    int	fd;
    int	r9;
} istack[MAXIFD];
@

<<global [[ifiledepth]]>>=
int	ifiledepth;
@

<<function [[iclose]]>>=
void
iclose(int stack, int err)
{
    if (err) {
        if (infile) {
            close(infile);
            infile=STDIN;
        }
        while (--ifiledepth >= 0)
            if (istack[ifiledepth].fd)
                close(istack[ifiledepth].fd);
        ifiledepth = 0;
    } else if (stack == 0) {
        if (infile) {
            close(infile);
            infile=STDIN;
        }
    } else if (stack > 0) {
        if (ifiledepth >= MAXIFD)
            error("$<< nested too deeply");
        istack[ifiledepth].fd = infile;
        ifiledepth++;
        infile = STDIN;
    } else {
        if (infile) {
            close(infile); 
            infile=STDIN;
        }
        if (ifiledepth > 0) {
            infile = istack[--ifiledepth].fd;
        }
    }
}
@
%$

% how can have multiple input file?


<<function [[redirout]]>>=
void
redirout(char *file)
{
    int fd;

    if (file == 0){
        oclose();
        return;
    }
    flushbuf();
    if ((fd = open(file, 1)) >= 0)
        seek(fd, 0L, 2);
    else if ((fd = create(file, 1, 0666)) < 0)
        error("cannot create");
    Bterm(&stdout);
    Binit(&stdout, fd, OWRITE);
}
@




<<[[printtrace()]] switch modif cases>>=
case '<':
    if (cntval == 0) {
        while (readchar() != EOR)
            ;
        reread();
        break;
    }
    if (rdc() == '<')
        stack = 1;
    else {
        stack = 0;
        reread();
    }
    fname = getfname();
    redirin(stack, fname);
    break;
@
<<[[printtrace()]] switch modif cases>>=
case '>':
    fname = getfname();
    redirout(fname);
    break;
@





<<[[main()]] locals (db)>>=
char *s;
@
<<[[main()]] command line processing (db)>>=
case 'I':
    s = ARGF();
    if(s == 0)
        dprint("missing -I argument\n");
    else
        Ipath = s;
    break;
@



<<[[main()]] in loop, if eof, and if infile was not STDIN>>=
iclose(-1, 0);
eof = false;
longjmp(env, 1);
@

% if set eof back to false, when do longjmp we will go
% back before the for(;;) and so loop forever? no because
% infile will have changed

\section{Formatted output}

<<[[command()]] switch lastcom cases>>=
case '\0':
    prints(DBNAME);
    break;
@
%$
% how can have this? when eof? but then have if(eof) before no?

<<constant [[DBNAME]]>>=
#define	DBNAME	"db\n"
@

\section{Shell output}

<<[[command()]] switch lastcom cases>>=
case '!':
    lastcom=savecom;
    shell(); 
    break;
@

<<function [[shell]]>>=
/*
 * shell escape
 */

void
shell(void)
{
    int	rc, unixpid;
    char *argp = (char*)lp;

    while (lastc!=EOR)
        rdc();
    if ((unixpid=fork())==0) {
        *lp=0;
        execl("/bin/rc", "rc", "-c", argp, nil);
        exits("execl");				/* botch */
    } else if (unixpid == -1) {
        error("cannot fork");
    } else {
        mkfault = 0;
        while ((rc = waitpid()) != unixpid){
            if(rc == -1 && mkfault){
                mkfault = 0;
                continue;
            }
            break;
        }
        prints("!"); 
        reread();
    }
}
@

\section{[[db -w]]}
% ???

<<[[main()]] command line processing (db)>>=
case 'w':
    wtflag = ORDWR;		/* suitable for open() */
    break;
@

<<[[getfile()]] if wtflag>>=
if (f < 0 && xargc > cnt && wtflag)
     f = create(filnam, 1, 0666);
@

<<global [[xargc]]>>=
int xargc;		/* bullshit */
@

<<[[main()]] initialization before repl (db)>>=
xargc = argc;
@

\chapter{Advanced Topics}

\section{Time travel}
% checkpoints

\section{Cross machine debugging}

% import /proc !! beautiful. Power of 9p and libmach.

\section{Cross architecture debugging: [[db -m]]}

<<[[main()]] locals (db)>>=
char *name = nil;
@

<<[[main()]] command line processing (db)>>=
case 'm':
    name = ARGF();
    if(name == nil)
        dprint("missing -m argument\n");
    break;
@

<<[[main()]] if db -m and unknown machine>>=
if (name && machbyname(name) == 0)
        dprint ("unknown machine %s", name);
@

\section{Kernel debugging}
% have a special chapter for Kernel debugging, with ktrace too?

%http://ddeville.me/2015/08/kernel-debugging-with-lldb-and-vmware-fusion/

\subsection{[[/bin/ktrace]]}

\subsection{[[db -k]]}

<<global [[kflag]]>>=
bool kflag;
@
% used also as argument to attachproc()

<<[[main()]] command line processing (db)>>=
case 'k':
    kflag = true;
    break;
@

<<[[main()]] locals (db)>>=
char *cpu, *p, *q;
@

<<[[main()]] when pid argument, if kflag>>=
if(kflag){
    cpu = getenv("cputype");
    if(cpu == nil){
        cpu = "386";
        dprint("$cputype not set; assuming %s\n", cpu);
    }
    p = getenv("terminal");
    if(p==nil || (p=strchr(p, ' '))==0 || p[1]==' ' || p[1]==0){
        strcpy(b1, "/386/9pc");
        dprint("missing or bad $terminal; assuming %s\n", b1);
    }else{
        p++;
        q = strchr(p, ' ');
        if(q)
            *q = '\0';
        sprint(b1, "/%s/9%s", cpu, p);
    
    }
}
@
% b1 then flows into symfile


<<[[printtrace()]] switch modif cases>>=
case 'k':
    kmsys();
    break;
@


% kernel stuff? mv in kernel debugging chapter?
% setcor | printtrace (when $r) -> <>
<<function [[kmsys]]>>=
void
kmsys(void)
{
    int i;

    i = findseg(symmap, "text");
    if (i >= 0) {
        symmap->seg[i].b = symmap->seg[i].b & ~mach->ktmask;
        symmap->seg[i].e = ~0;
    }

    i = findseg(symmap, "data");
    if (i >= 0) {
        symmap->seg[i].b |= mach->kbase;
        symmap->seg[i].e |= mach->kbase;
    }
}
@


\section{Signals and notes}

\subsection{Debugger notes}

<<[[main()]] call notify>>=
notify(fault);
@

<<function [[fault]]>>=
/*
 * An interrupt occurred;
 * seek to the end of the current file
 * and remember that there was a fault.
 */
void
fault(void *a, char *s)
{
    USED(a);
    if(strncmp(s, "interrupt", 9) == 0){
        seek(infile, 0L, 2);
        mkfault++;
        noted(NCONT);
    }
    noted(NDFLT);
}
@

<<global [[mkfault]]>>=
bool mkfault;
@
%dead? when set to true?

<<[[main()]] in loop, handle mkfault (db)>>=
if (mkfault) {
    mkfault=0;
    printc('\n');
    prints(DBNAME);
}
@

<<[[dprint()]] return if mkfault>>=
if(mkfault)
    return -1;
@

<<[[readchar()]] if mkfault>>=
if (mkfault) {
    eof = 0;
    error(nil);
}
@



\subsection{Debugged notes}


<<function [[loadnote]]>>=
/*
 * reload the note buffer
 */
void
loadnote(void)
{
    int i;
    char err[ERRMAX];

    setpcs();
    for(i=0; i<nnote; i++){
        if(write(notefd, note[i], strlen(note[i])) < 0){
            errstr(err, sizeof err);
            if(strcmp(err, "interrupted") != 0)
                endpcs();
            errors("can't write note file", err);
        }
    }
    nnote = 0;
}
@

<<function [[notes]]>>=
void
notes(void)
{
    int n;

    if(nnote == 0)
        return;
    dprint("notes:\n");
    for(n=0; n<nnote; n++)
        dprint("%d:\t%s\n", n, note[n]);
}
@


% ((grab | startpcs ) -> bpwait) | ??? -> <>
<<function [[unloadnote]]>>=
/*
 * empty the note buffer and toss pending breakpoint notes
 */
void
unloadnote(void)
{
    char err[ERRMAX];

    setpcs();
    for(; nnote<NNOTE; nnote++){
        switch(read(notefd, note[nnote], sizeof note[nnote])){
        case -1:
            errstr(err, sizeof err);
            if(strcmp(err, "interrupted") != 0)
                endpcs();
            errors("can't read note file", err);
        case 0:
            return;
        }

        note[nnote][ERRMAX-1] = '\0';
        if(strncmp(note[nnote], "sys: breakpoint", 15) == 0)
            --nnote;
    }
}
@
% breakpoint fault!!!
% 15 because strlen of the "sys: breakpoint", hmm, ugly 

\subsection{[[:n]]}

<<[[subpcs()]] switch modif cases>>=
/* deal with notes */
case 'n':	
    if (pid==0)
        error(NOPCS);
    n=defval(-1);
    if(n>=0 && n<nnote){
        nnote--;
        memmove(note[n], note[n+1], (nnote-n)*sizeof(note[0]));
    }
    notes();
    return;
@


\chapter{Conclusion}

% snoopy, tracer/debugger for networking issues!

\appendix

\chapter{Debugging}
% debugging the debugger :)

%less: have a -v where have more dprint(), e.g. in msgpcs()



\chapter{Error Management}

% poor's man exn via setjmp.

%        if (syminit(fsym, &fhdr) < 0)
%            dprint("%r\n");
% lots of error(%r), what is this %r ?? from errstr? in libc.h?

<<function [[error]]>>=
/*
 * An error occurred; save the message for later printing,
 * close open files, and reset to main command loop.
 */
void
error(char *n)
{
    errmsg = n;
    iclose(0, 1);
    oclose();
    flush();
    delbp();
    ending = 0;

    longjmp(env, 1);
}
@

<<function [[errors]]>>=
void
errors(char *m, char *n)
{
    static char buf[128];

    sprint(buf, "%s: %s", m, n);
    error(buf);
}
@




<<global [[errmsg]]>>=
// was static in main.c
char *errmsg;
@

<<[[main()]] in loop, handle errmsg (db)>>=
if (errmsg) {
    dprint(errmsg);
    printc('\n');
    errmsg = nil;
}
@
%dead:    exitflg = false;




<<function [[oclose]]>>=
void
oclose(void)
{
    flushbuf();
    Bterm(&stdout);
    Binit(&stdout, 1, OWRITE);
}
@


\chapter{Libc}

\chapter{Extra Code}

#include "Debugger_extra.nw"

\ifallcode
#include "Debugger_x86.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}

\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

