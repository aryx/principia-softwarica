\documentclass[twocolumn]{report}
%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - removed deadcode (BADREG, maxfile, regdirty)

%thx to codemap/codegraph:

%thx to this manual, better understand debuggers:
% - SEMI how can be fast? via trap abuse? thx to virtual memory and page
%   fault again!

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the file before
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Plan9 Tracers and Debuggers
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Phil Winterbottom
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a debugger and tracer.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present strace (actually was called ratrace), db (and maybe acid).
% Small programs.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item gdb
% dwarf debugging format?
\item Linux strace
\item Solaris dtrace
\item valgrind
\end{itemize}

%http://blog.0x972.info/?d=2014/11/13/10/40/50-how-does-a-debugger-work

%https://www.hackerschool.com/blog/5-learning-c-with-gdb

% TODO: snap/, to lpize and include


%Need also mach.h, many helper functions to access the binary/object file

% see also cc/acid.c



\section{Getting started}

\section{Requirements}

% docs/man/2/debugger

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Debugger principles}

% naive = interpreter, cf Machine.nw, but very very slow.
% => hardware debugging support! so fast!

% simple: modify the code in memory at the breakpoint address given
% by user to generate a fault => when execute and reach breakpoint
% we will be given back the hand. => efficient!
% less: Can use same trick for watchpoint? when access some memory area?
% hmm but then has to invalidate the whole page? so some false positives.

% for debugger to work it needs metadata, generated by
% the assembler, the compiler, and the linker.
% See "Debugging Support" chapters in Assembler.nw, Compiler.nw,
% Linker.nw We will recall the essential things below.

% It also needs support from the kernel. See the Broken state
% in Kernel.nw. But it's very convenient because when segfault,
% got the core dump, actually under plan9 the process is put
% in a Broken state and can be debugged by
%  db <pid>
% Awesome (remember efuns.byte crashes)



\section{[[strace]] services}

% strace <cmd>

% simple, and very effective at finding many bugs, like
% no more space in /tmp. Especially when people don't check
% return error code, at least see the call to create a file in /tmp

\section{[[db]] services}

% see also Machine.nw, which has a similar interface.

<<[[main()]] print usage and exit (db)>>=
fprint(2, "Usage: db [-kw] [-m machine] [-I dir] [symfile] [pid|cmd]\n");
exits("usage");
@
%pad: I added the |cmd

% db <cmd>
% db <pid>
% I thought there was a  -c, but it's just that if non alldigits argv[0]
% then it's assumed to be a program

% then [addr] [,count] [command]

% > main
% =>  main() /tests/8c/helloc.c:5
% (now dot is main)
% > ?   
% => SUBL $4, SP,  (? is for textfile)
% > /   
% => ( / is for memfile)

% ?i => print using instruction format
% ?iii ?3i => print 3 next instructions from dot

% RET => increment dot
 
% $m => show address maps (text and data spec)
% $b => show breakpoints
% $c => stacktrace
% $C => stacktrace with parameters values! and locals! awesome! like in Perl!
%  ex:
%  caml_main(argv=...) /home/pad/../main.c called from main+f (/home/pad/...)
%    caml_main.raise_buf/ 0x1
%    caml_main.pos/ 0x0
%    caml_main.trail/ 0x4cf2c
%    ...
%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)
% $r => dump registers
% $q => exit

% :r => run
% :c => continue
% main :b => breakpoint main (can check with $b after)

%todo: ??? dump value of a global

<<constant CMD_VERBS>>=
#define CMD_VERBS	"?/=>!$: \t"
@
%$

% many commands are either in lowercase or uppercase form,
% where uppercase form is usually one providing more services,
% e.g. specific to C.
% So lowercase = assembly level, uppercase = C level.
% ex: $c vs $C, :s vs :S 

\section{Code organization}

\section{Software architecture}

% Control child debugged process via /proc/x/ctl! 
% access data via /proc/x/text and /proc/x/mem
% Also support from libmach for generic symbols access, disassembler, etc.

% FIGURE: state diagram with different messages in /proc/x/ctl
% start, waitstop, hang, etc and who writes to them and when

%###############################################################################

\chapter{Core Data Structures}

\section{[[/proc/x/text]]}

\section{[[/proc/x/mem]]}

\section{[[/proc/x/ctl]], [[msgfd]] and [[msgpcs()]]}

<<global msgfd>>=
fdt msgfd = -1;
@
% /proc/x/ctl

<<global notefd>>=
fdt notefd = -1;
@
% /proc/x/note


<<global pcspid>>=
int pcspid = -1;
@



<<function msgpcs>>=
void
msgpcs(char *msg)
{
    char err[ERRMAX];

    setpcs();
    if(write(msgfd, msg, strlen(msg)) < 0 && !ending){
        errstr(err, sizeof err);
        if(strcmp(err, "interrupted") != 0)
            endpcs();
        errors("can't write control file", err);
    }
}
@



<<function setpcs>>=
void
setpcs(void)
{
    char buf[128];

    if(pid && pid != pcspid){
        if(msgfd >= 0){
            close(msgfd);
            msgfd = -1;
        }
        if(notefd >= 0){
            close(notefd);
            notefd = -1;
        }
        pcspid = -1;

        sprint(buf, "/proc/%d/ctl", pid);
        msgfd = open(buf, OWRITE);
        if(msgfd < 0)
            error("can't open control file");

        sprint(buf, "/proc/%d/note", pid);
        notefd = open(buf, ORDWR);
        if(notefd < 0)
            error("can't open note file");

        pcspid = pid;
    }
}
@


\section{[[Mach]] and [[mach]]}


\section{[[Map]], [[symap]], [[cormap]], [[dotmap]]}

% cormap, symmap, dotmap

<<global symmap>>=
// was in setup.c
Map	*symmap;
@
% derived from text

<<global cormap>>=
Map	*cormap;
@
% derived from heap and stack?

<<global dotmap>>=
Map	*dotmap;
@
% ???


\section{[[Addr]] and [[dot]]}

<<type ADDR>>=
typedef uvlong ADDR;
@

<<global dot>>=
// was in command.c
ADDR	dot;
@
% see also adrflg

\section{[[cntval]]}

<<type WORD>>=
typedef ulong WORD;
@

<<global cntval>>=
WORD cntval;
@
% see also ctnflag

\section{[[Bkpt]] and [[bkpthead]]}

<<struct bkpt>>=
struct bkpt {
    // address/symbol to break on
    ADDR	loc;
    // enum<breakpoint_kind>
    int	flag;

    <<[[Bkpt]] other fields>>

    // Extra
    <<[[Bkpt]] extra fields>>
};
@

<<constant BKPTCLR>>=
#define	BKPTCLR	0	/* not a real breakpoint */
@
%todo: enum? enum breakpoint_kind

<<constant BKPTSET>>=
#define BKPTSET	1	/* real, ready to trap */
@
<<constant BKPTSKIP>>=
#define BKPTSKIP 2	/* real, skip over it next time */
@
<<constant BKPTTMP>>=
#define	BKPTTMP	3	/* temporary; clear when it happens */
@



<<global bkpthead>>=
// list<BKPT>, next = BKPT.next
BKPT *bkpthead;
@

<<[[Bkpt]] extra fields>>=
// list<ref_own<BKPT>, head = bkpthead
BKPT	*nxtbkpt;
@



%XXX
<<[[Bkpt]] other fields>>=
uchar	save[4];

int	count;
int	initcnt;
@




\chapter{[[main()]]}

<<global symfil>>=
char	*symfil = nil;
@
% program to be debugged, containing symbol information, for text and data
% or /proc/x/text
% global so can be used by printmap()

<<global corfil>>=
char	*corfil = nil;
@
% memory, for the heap and stack, will be /proc/xxx/mem?
% global so can be used by printmap()


<<global infile>>=
int	infile = STDIN;
@
% input to the debugger


<<function main (db/main.c)>>=
void
main(int argc, char **argv)
{
    <<[[main()]] locals (db)>>

    outputinit();

    ARGBEGIN{
    <<[[main()]] command line processing (db)>>
    }ARGEND

    if (argc > 0 && !alldigs(argv[0])) {
        symfil = argv[0];
        argv++;
        argc--;
    }
    <<[[main()]] if pid argument, attach to existing process>>
    else if (argc > 0) {
        <<[[main()]] print usage and exit (db)>>
    }
    if (!symfil)
        symfil = "8.out";

    <<[[main()]] initialization before repl (db)>>

    for (;;) {
        // clear output
        flushbuf();

        <<[[main()]] in loop, handle errmsg (db)>>
        <<[[main()]] in loop, handle mkfault (db)>>

        // clear input
        clrinp();

        // go to next non whitespace char
        rdc();
        reread();

        <<[[main()]] in loop, if eof (db)>>

        exitflg = false;
        command(nil, 0);

        reread();
        if (rdc() != '\n')
            error("newline expected");
    }
}
@
%dead? exitflg is never set to true anyway

<<function alldigs>>=
bool
alldigs(char *s)
{
    while(*s){
        if(*s<'0' || '9'<*s)
            return false;
        s++;
    }
    return true;
}
@


<<[[main()]] initialization before repl (db)>>=
<<[[main()]] call notify>>
<<[[main()]] call setsym>>
<<[[main()]] set dotmap>>
<<[[main()]] print binary architecture>>
<<[[main()]] setjmp>>
<<[[main()]] just before repl>>
@

<<[[main()]] print binary architecture>>=
<<[[main()]] if db -m and unknown machine>>
dprint("%s binary\n", mach->name);
@
% setsym() will set mach via machbytype() (or machbyname() when db -mxxx)



\section{Process attachment}

% alternative is to run the program, which will be done with :r
% which should then set pid


<<global pid>>=
int pid;
@
% = 0;

<<[[main()]] locals (db)>>=
char b1[100];
char b2[100];
@


<<[[main()]] if pid argument, attach to existing process>>=
if(argc==1 && alldigs(argv[0])){

    pid = atoi(argv[0]);
    pcsactive = false;
    if (!symfil) {
        <<[[main()]] when pid argument, if kflag>>
        else
            sprint(b1, "/proc/%s/text", argv[0]);
        symfil = b1;
    }
    sprint(b2, "/proc/%s/mem", argv[0]);
    corfil = b2;
}
@

<<global pcsactive>>=
// was in trcrun.c
bool pcsactive = false;
@
% process control? s = ?

\section{Text file, [[setsym()]]}

<<[[main()]] call setsym>>=
setsym();
@



<<global fhdr (db/setup.c)>>=
static Fhdr fhdr;
@

<<global fsym>>=
fdt fsym;
@
% why need that to be a global?




% main -> <>
<<function setsym>>=
void
setsym(void)
{
    Symbol s;

    if((fsym = getfile(symfil, 1, wtflag)) < 0) {
        symmap = dumbmap(-1);
        return;
    }
    if (crackhdr(fsym, &fhdr)) {
        machbytype(fhdr.type);
        symmap = loadmap(symmap, fsym, &fhdr);
        if (symmap == nil)
            symmap = dumbmap(fsym);
        if (syminit(fsym, &fhdr) < 0)
            dprint("%r\n");
        if (mach->sbreg && lookup(0, mach->sbreg, &s))
            mach->sb = s.value;
    }
    else
        symmap = dumbmap(fsym);
}
@

<<global wtflag>>=
// was in main.c
int wtflag = OREAD;
@
%OREAD = 0



% return fdt or -1
<<function getfile>>=
static fdt
getfile(char *filnam, int cnt, int omode)
{
    fdt f;

    if (filnam == nil)
        return ERROR_NEG1;

    if (strcmp(filnam, "-") == 0)
        return STDIN;
    f = open(filnam, omode|OCEXEC);

    <<[[getfile()]] error managment>>
    return f;
}
@

<<[[getfile()]] error managment>>=
if(f < 0 && omode == ORDWR){
    f = open(filnam, OREAD|OCEXEC);
    if(f >= 0)
        dprint("%s open read-only\n", filnam);
}
<<[[getfile()]] if wtflag>>
if (f < 0) {
    dprint("cannot open `%s': %r\n", filnam);
    return ERROR_NEG1;
}
@



<<function dumbmap>>=
Map *
dumbmap(fdt fd)
{
    Map *dumb;


    dumb = newmap(0, 1);
    setmap(dumb, fd, 0, 0xffffffff, 0, "data");
    if (!mach) 			/* default machine = 386 */
        mach = &mi386;
    if (!machdata)
        machdata = &i386mach;
    return dumb;
}
@

\section{Core memory file, [[setcor()]]}

<<[[main()]] setjmp>>=
if(setjmp(env) == 0){
    if (corfil) {
        setcor();	/* could get error */
        dprint("%s\n", machdata->excep(cormap, rget));
        printpc();
    }
}
setjmp(env);
@


<<global fcor>>=
fdt fcor;
@


% main (when corfile) | attachprocess | bpwait (<- startpcs) -> <>
<<function setcor>>=
void
setcor(void)
{
    int i;

    if (cormap) {
        for (i = 0; i < cormap->nsegs; i++)
            if (cormap->seg[i].inuse)
                close(cormap->seg[i].fd);
    }

    fcor = getfile(corfil, 2, ORDWR);
    if (fcor <= 0) {
        if (cormap)
            free(cormap);
        cormap = dumbmap(-1);
        return;
    }
    if(pid > 0) {	/* provide addressability to executing process */
        cormap = attachproc(pid, kflag, fcor, &fhdr);
        if (!cormap)
            cormap = dumbmap(-1);
    } else {
        cormap = newmap(cormap, 2);
        if (!cormap)
            cormap = dumbmap(-1);
        setmap(cormap, fcor, fhdr.txtaddr, fhdr.txtaddr+fhdr.txtsz, fhdr.txtaddr, "text");
        setmap(cormap, fcor, fhdr.dataddr, 0xffffffff, fhdr.dataddr, "data");
    }
    kmsys();
    return;
}
@

% kernel stuff?
<<function kmsys>>=
void
kmsys(void)
{
    int i;

    i = findseg(symmap, "text");
    if (i >= 0) {
        symmap->seg[i].b = symmap->seg[i].b & ~mach->ktmask;
        symmap->seg[i].e = ~0;
    }

    i = findseg(symmap, "data");
    if (i >= 0) {
        symmap->seg[i].b |= mach->kbase;
        symmap->seg[i].e |= mach->kbase;
    }
}
@



\section{Output, [[outputinit()]], [[dprint()]] and [[stdout]]}

<<global stdout>>=
Biobuf	stdout;
@

<<function outputinit>>=
void
outputinit(void)
{
    Binit(&stdout, 1, OWRITE);
    fmtinstall('t', tconv);
}
@
% %t ??

% closed in oclose <- errors

<<function tconv>>=
/* was move to next f1-sized tab stop; now just print a tab */
int
tconv(Fmt *f)
{
    return fmtstrcpy(f, "\t");
}
@
% ???


<<function dprint>>=
int
dprint(char *fmt, ...)
{
    int n, w;
    char *p;
    char buf[4096];
    Rune r;
    va_list arg;

    <<[[dprint()]] return if mkfault>>

    va_start(arg, fmt);
    n = vseprint(buf, buf+sizeof buf, fmt, arg) - buf;
    va_end(arg);

    //Bprint(&stdout, "[%s]", fmt);
    Bwrite(&stdout, buf, n);

    <<[[dprint()]] maintain printcol>>
    return n;
}
@




<<global printcol>>=
int	printcol = 0;
@

<<[[dprint()]] maintain printcol>>=
for(p=buf; *p; p+=w){
    w = chartorune(&r, p);
    if(r == '\n')
        printcol = 0;
    else
        printcol++;
}
@

\section{Input, [[clrinp()]], [[rdc()]], [[reread()]]}

<<constant EOR>>=
#define EOR	'\n'
@
% End Of ? Return?

<<constant SPC>>=
#define SPC	' '
@

<<constant TB>>=
#define TB	'\t'
@



% poor's man command lexing

<<global peekc>>=
int	peekc;
@
%todo: change type to Rune?

<<global lastc>>=
int lastc = EOR;
@
%todo: change type to Rune?
%ugly all those globals

% but many deep commands consumes input, e.g. doexec(),





<<global lp>>=
Rune	*lp;
@
% ?? l? p?


<<function clrinp>>=
void
clrinp(void)
{
    flush();
    lp = nil;
    peekc = 0;
}
@


<<function rdc>>=
int
rdc(void)
{
    do {
        readchar();
    } while (lastc==SPC || lastc==TB);
    return lastc;
}
@
% ugly use of global, why readchar does not return a char instead?
% kinda of lexing also here. 
%less: rename? read_next_non_white_space_char()
% often do rdc(); reread() to position yourself to next non whitespace char
% so that the next readchar() is a character you want to dispatch on.


<<function reread>>=
void
reread(void)
{
    peekc = lastc;
}
@



\section{Interpreter, [[command()]]}

% [addr] [,count] [?/=:$ command]

<<function command>>=
/* command decoding */
int
command(char *buf, int defcom)
{
    <<[[command()]] locals (db)>>

    <<[[command()]] initializations (db)>>

    do {
        <<[[command()]] parse possibly first address, set dot>>
        <<[[command()]] parse possibly count, set cntval>>

        <<[[command()]] parse command, set lastcom>>
        switch(lastcom) {
        <<[[command()]] switch lastcom cases>>
        default: 
            error("bad command");
        }
        flushbuf();
    } while (rdc()==';');

    <<[[command()]] finalizations (db)>>
}
@
%$



<<[[command()]] parse possibly count, set cntval>>=
if (rdc()==',' && expr(0)) {	/* count */
    cntflg=TRUE;
    cntval=expv;
} else {
    cntflg=FALSE;
    cntval=1;
    reread();
}
@
<<global cntflg>>=
bool	cntflg;
@


\subsection{XXX}


<<[[command()]] locals (db)>>=
static char lastcom = '=';
@







<<[[command()]] initializations (db)>>=
if (defcom == 0)
    defcom = lastcom;
if (buf) {
    if (*buf==EOR)
        return FALSE;
    clrinp();
    lp=(Rune*)buf;
}
@



<<[[command()]] locals (db)>>=
Rune*   savlp = lp;
char	savlc = lastc;
char	savpc = peekc;
@

<<[[command()]] finalizations (db)>>=
if (buf == nil)
    reread();
else {
    clrinp();
    lp=savlp;
    lastc = savlc;
    peekc = savpc;
}

if(adrflg)
    return dot;
return 1;
@

<<[[command()]] locals (db)>>=
char	*reg;
char	savc;
static char savecom = '=';
@








<<[[command()]] parse command, set lastcom>>=
if (!eol(rdc()))
    lastcom=lastc;		/* command */
else {
    if (adrflg==false)
        dot=inkdot(dotinc);
    reread();
    lastcom=defcom;
}
@

<<function inkdot>>=
ADDR
inkdot(int incr)
{
    ADDR	newdot;

    newdot=dot+incr;
    if ((incr >= 0 && newdot < dot)
    ||  (incr < 0 && newdot > dot))
        error("address wraparound");
    return newdot;
}
@



<<function eol>>=
bool
eol(int c)
{
    return(c==EOR || c==';');
}
@
% lexing too

\section{Exit, [[done()]]}

<<global eof>>=
bool	eof;
@

<<[[main()]] in loop, if eof (db)>>=
if (eof) {
    if (infile == STDIN)
        done();
    iclose(-1, 0);
    eof = false;

    longjmp(env, 1);
}
@

<<function done>>=
void
done(void)
{
    if (pid)
        endpcs();
    exits(exitflg? "error": nil);
}
@


\section{XXX}


<<global mkfault>>=
bool mkfault;
@
%dead? when set to true?

<<[[main()]] in loop, handle mkfault (db)>>=
if (mkfault) {
    mkfault=0;
    printc('\n');
    prints(DBNAME);
}
@

<<[[dprint()]] return if mkfault>>=
if(mkfault)
    return -1;
@



<<[[main()]] call notify>>=
notify(fault);
@


<<[[main()]] set dotmap>>=
dotmap = dumbmap(-1);
@




<<[[main()]] just before repl>>=
if (executing)
    delbp();
executing = FALSE;
@







<<[[main()]] locals (db)>>=
char *s;
@
<<[[main()]] command line processing (db)>>=
case 'I':
    s = ARGF();
    if(s == 0)
        dprint("missing -I argument\n");
    else
        Ipath = s;
    break;
@





\chapter{Lexing}

% See CMD_VERBS, crude input command language

% modifies peekc, lastc, lp

<<global line>>=
Rune	line[LINSIZ];
@
<<constant LINSIZ>>=
#define LINSIZ	4096
@


<<function readchar>>=
int
readchar(void)
{
    Rune *p;

    if (eof)
        lastc='\0';
    else if (peekc) {
        lastc = peekc;
        peekc = 0;
    }
    else {
        if (lp==nil) {
            for (p = line; p < &line[LINSIZ-1]; p++) {
                eof = readrune(infile, p) <= 0;
                if (mkfault) {
                    eof = 0;
                    error(nil);
                }
                if (eof) {
                    p--;
                    break;
                }
                if (*p == EOR) {
                    if (p <= line)
                        break;
                    if (p[-1] != '\\')
                        break;
                    p -= 2;
                }
            }
            p[1] = '\0';
            lp = line;
        }
        if ((lastc = *lp) != 0)
            lp++;
    }
    return lastc;
}
@

<<function readrune>>=
int
readrune(int fd, Rune *r)
{
    char buf[UTFmax+1];
    int i;

    for(i=0; i<UTFmax && !fullrune(buf, i); i++)
        if(read(fd, buf+i, 1) <= 0)
            return -1;
    buf[i] = '\0';
    chartorune(r, buf);
    return 1;
}
@

\chapter{Parsing}

<<global expv>>=
// was in expr.c
uvlong	expv;
@


<<function expr>>=
int
expr(int a)
{	/* term | term dyadic expr |  */
    int	rc;
    WORD	lhs;

    rdc();
    reread();

    rc=term(a);
    while (rc) {
        lhs = expv;
        switch ((int)readchar()) {

        case '+':
            term(a|1);
            expv += lhs;
            break;

        case '-':
            term(a|1);
            expv = lhs - expv;
            break;

        case '#':
            term(a|1);
            expv = round(lhs,expv);
            break;

        case '*':
            term(a|1);
            expv *= lhs;
            break;

        case '%':
            term(a|1);
            if(expv != 0)
                expv = lhs/expv;
            else{
                if(lhs)
                    expv = 1;
                else
                    expv = 0;
            }
            break;

        case '&':
            term(a|1);
            expv &= lhs;
            break;

        case '|':
            term(a|1);
            expv |= lhs;
            break;

        case ')':
            if ((a&2)==0)
                error("unexpected `)'");

        default:
            reread();
            return rc;
        }
    }
    return rc;
}
@

<<function term>>=
int
term(int a)
{	/* item | monadic item | (expr) | */
    ADDR e;

    switch ((int)readchar()) {

    case '*':
        term(a|1);
        if (geta(cormap, expv, &e) < 0)
            error("%r");
        expv = e;
        return 1;

    case '@':
        term(a|1);
        if (geta(symmap, expv, &e) < 0)
            error("%r");
        expv = e;
        return 1;

    case '-':
        term(a|1);
        expv = -expv;
        return 1;

    case '~':
        term(a|1);
        expv = ~expv;
        return 1;

    case '(':
        expr(2);
        if (readchar()!=')')
            error("syntax error: `)' expected");
        return 1;

    default:
        reread();
        return item(a);
    }
}
@

<<function item>>=
int
item(int a)
{	/* name [ . local ] | number | . | ^  | <register | 'x | | */
    char	*base;
    char	savc;
    uvlong e;
    Symbol s;
    char gsym[MAXSYM], lsym[MAXSYM];

    readchar();
    if (isfileref()) {
        readfname(gsym);
        rdc();			/* skip white space */
        if (lastc == ':') {	/* it better be */
            rdc();		/* skip white space */
            if (!getnum(readchar))
                error("bad number");
            if (expv == 0)
                expv = 1;	/* file begins at line 1 */
            expv = file2pc(gsym, expv);
            if (expv == -1)
                error("%r");
            return 1;
        }
        error("bad file location");
    } else if (symchar(0)) {	
        readsym(gsym);
        if (lastc=='.') {
            readchar();	/* ugh */
            if (lastc == '.') {
                lsym[0] = '.';
                readchar();
                readsym(lsym+1);
            } else if (symchar(0)) {
                readsym(lsym);
            } else
                lsym[0] = 0;
            if (localaddr(cormap, gsym, lsym, &e, rget) < 0)
                error("%r");
            expv = e;
        }
        else {
            if (lookup(0, gsym, &s) == 0)
                error("symbol not found");
            expv = s.value;
        }
        reread();
    } else if (getnum(readchar)) {
        ;
    } else if (lastc=='.') {	
        readchar();
        if (!symchar(0) && lastc != '.') {
            expv = dot;
        } else {
            if (findsym(rget(cormap, mach->pc), CTEXT, &s) == 0)
                error("no current function");
            if (lastc == '.') {
                lsym[0] = '.';
                readchar();
                readsym(lsym+1);
            } else
                readsym(lsym);
            if (localaddr(cormap, s.name, lsym, &e, rget) < 0)
                error("%r");
            expv = e;
        }	
        reread();
    } else if (lastc=='"') {
        expv=ditto;
    } else if (lastc=='+') {
        expv=inkdot(dotinc);
    } else if (lastc=='^') {
        expv=inkdot(-dotinc);
    } else if (lastc=='<') {
        savc=rdc();
        base = regname(savc);
        expv = rget(cormap, base);
    }
    else if (lastc=='\'')
        expv = ascval();
    else if (a)
        error("address expected");
    else {	
        reread();
        return(0);
    }
    return(1);
}
@

\chapter{Addresses}

<<global adrflg>>=
bool	adrflg;
@

<<global adrval>>=
// was in command.c
WORD	adrval;
@


<<[[command()]] parse possibly first address, set dot>>=
adrflg=expr(0);		/* first address */
if (adrflg){
    dot=expv;
    ditto=expv;
}
adrval=dot;
@

<<global ditto>>=
ADDR	ditto;
@

\section{Symbolic addresses}


\chapter{Commands}

\section{Formatting commands, [[?/=]]}

<<[[command()]] switch lastcom cases>>=
case '?':
case '/':
case '=':
    savecom = lastcom;
    acommand(lastcom);
    break;
@

<<function acommand>>=
/*
 * [/?][wml]
 */
void
acommand(int pc)
{
    bool eqcom;
    Map *map;
    char *fmt;
    char buf[512];

    if (pc == '=') {
        eqcom = true;
        fmt = eqformat;
        map = dotmap;
    } else {
        eqcom = false;
        fmt = stformat;
        if (pc == '/')
            map = cormap;
        else
            map = symmap;
    }
    if (!map) {
        snprint(buf, sizeof(buf), "no map for %c", pc);
        error(buf);
    }

    switch (rdc()) {
    <<[[acommand()]] switch optional command suffix character>>
    default:
        reread();
        getformat(fmt);
        scanform(cntval, !eqcom, fmt, map, eqcom);
    }
}
@


<<constant ARB>>=
#define	ARB	512
@

<<global eqformat>>=
char	eqformat[ARB] = "z";
@

<<global stformat>>=
char	stformat[ARB] = "zMi";
@



<<function getformat>>=
void
getformat(char *deformat)
{
    char *fptr;
    bool	quote;
    Rune r;

    fptr=deformat;
    quote=FALSE;
    while ((quote ? readchar()!=EOR : !eol(readchar()))){
        r = lastc;
        fptr += runetochar(fptr, &r);
        if (lastc == '"')
            quote = ~quote;
    }
    lp--;
    if (fptr!=deformat)
        *fptr = '\0';
}
@
% lp-- ???


<<function scanform>>=
void
scanform(long icount, int prt, char *ifp, Map *map, int literal)
{
    char	*fp;
    char	c;
    int	fcount;
    ADDR	savdot;
    bool firstpass = true;

    while (icount) {
        fp=ifp;
        savdot=dot;

        /*now loop over format*/
        while (*fp) {
            if (!isdigit(*fp))
                fcount = 1;
            else {
                fcount = 0;
                while (isdigit(c = *fp++)) {
                    fcount *= 10;
                    fcount += c-'0';
                }
                fp--;
            }
            if (*fp==0)
                break;
            fp=exform(fcount,prt,fp,map,literal,firstpass);
            firstpass = false;
        }
        dotinc=dot-savdot;
        dot=savdot;
        if (--icount)
            dot=inkdot(dotinc);
    }
}
@


<<function exform>>=
char *
exform(int fcount, int prt, char *ifp, Map *map, int literal, bool firstpass)
{
    /* execute single format item `fcount' times
     * sets `dotinc' and moves `dot'
     * returns address of next format item
     */
    uvlong	v;
    ulong	w;
    ADDR	savdot;
    char	*fp;
    char	c, modifier;
    int	i;
    ushort sh, *sp;
    uchar ch, *cp;
    Symbol s;
    char buf[512];
    extern int printcol;

    fp = 0;
    while (fcount > 0) {
        fp = ifp;
        c = *fp;
        modifier = *fp++;
        if (firstpass) {
            firstpass = false;
            if (!literal  && (c == 'i' || c == 'I' || c == 'M')
                    && (dot & (mach->pcquant-1))) {
                dprint("warning: instruction not aligned");
                printc('\n');
            }
            if (prt && modifier != 'a' && modifier != 'A') {
                symoff(buf, 512, dot, CANY);
                dprint("%s%c%16t", buf, map==symmap? '?':'/');
            }
        }
        if (printcol==0 && modifier != 'a' && modifier != 'A')
            dprint("\t\t");

        switch(modifier) {
        <<[[exform()]] switch modifier cases>>
        default:
            error("bad modifier");
        }

        if (map->seg[0].fd >= 0)
            dot=inkdot(dotinc);
        fcount--;
        endline();
    }

    return fp;
}
@

\subsection{Disassembling, [[?i]]}

<<[[exform()]] switch modifier cases>>=
case 'I':
case 'i':
    i = machdata->das(map, dot, modifier, buf, sizeof(buf));
    if (i < 0)
        error("%r");
    dotinc = i;
    dprint("%s\n", buf);
    break;
@

<<global dotinc>>=
int	dotinc;
@


\subsection{XXX}

<<[[exform()]] switch modifier cases>>=
case SPC:
case TB:
    dotinc = 0;
    break;
@

<<[[exform()]] switch modifier cases>>=
case 't':
case 'T':
    dprint("%*t", fcount);
    dotinc = 0;
    return(fp);
@
<<[[exform()]] switch modifier cases>>=
case 'a':
    symoff(buf, sizeof(buf), dot, CANY);
    dprint("%s%c%16t", buf, map==symmap? '?':'/');
    dotinc = 0;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'A':
    dprint("%#llux%10t", dot);
    dotinc = 0;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'p':
    if (get4(map, dot, &w) < 0)
        error("%r");
    symoff(buf, sizeof(buf), w, CANY);
    dprint("%s%16t", buf);
    dotinc = mach->szaddr;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'u':
case 'd':
case 'x':
case 'o':
case 'q':
    if (literal)
        sh = (ushort) dot;
    else if (get2(map, dot, &sh) < 0)
        error("%r");
    w = sh;
    dotinc = 2;
    if (c == 'u')
        dprint("%-8lud", w);
    else if (c == 'x')
        dprint("%-8#lux", w);
    else if (c == 'd')
        dprint("%-8ld", w);
    else if (c == 'o')
        dprint("%-8#luo", w);
    else if (c == 'q')
        dprint("%-8#lo", w);
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'U':
case 'D':
case 'X':
case 'O':
case 'Q':
    if (literal)
        w = (long) dot;
    else if (get4(map, dot, &w) < 0)
        error("%r");
    dotinc = 4;
    if (c == 'U')
        dprint("%-16lud", w);
    else if (c == 'X')
        dprint("%-16#lux", w);
    else if (c == 'D')
        dprint("%-16ld", w);
    else if (c == 'O')
        dprint("%-#16luo", w);
    else if (c == 'Q')
        dprint("%-#16lo", w);
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'Z':
case 'V':
case 'Y':
    if (literal)
        v = dot;
    else if (get8(map, dot, &v) < 0)
        error("%r");
    dotinc = 8;
    if (c == 'Y')
        dprint("%-20#llux", v);
    else if (c == 'V')
        dprint("%-20lld", v);
    else if (c == 'Z')
        dprint("%-20llud", v);
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'B':
case 'b':
case 'c':
case 'C':
    if (literal)
        ch = (uchar) dot;
    else if (get1(map, dot, &ch, 1)  < 0)
        error("%r");
    if (modifier == 'C')
        printesc(ch);
    else if (modifier == 'B' || modifier == 'b')
        dprint("%-8#lux", (long) ch);
    else
        printc(ch);
    dotinc = 1;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'r':
    if (literal)
        sh = (ushort) dot;
    else if (get2(map, dot, &sh) < 0)
        error("%r");
    dprint("%C", sh);
    dotinc = 2;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'R':
    if (literal) {
        sp = (ushort*) &dot;
        dprint("%C%C", sp[0], sp[1]);
        endline();
        dotinc = 4;
        break;
    }
    savdot=dot;
    while ((i = get2(map, dot, &sh) > 0) && sh) {
        dot=inkdot(2);
        dprint("%C", sh);
        endline();
    }
    if (i < 0)
        error("%r");
    dotinc = dot-savdot+2;
    dot=savdot;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 's':
    if (literal) {
        cp = (uchar*) &dot;
        for (i = 0; i < 4; i++)
            buf[i] = cp[i];
        buf[i] = 0;
        dprint("%s", buf);
        endline();
        dotinc = 4;
        break;
    }
    savdot = dot;
    for(;;){
        i = 0;
        do{
            if (get1(map, dot, (uchar*)&buf[i], 1) < 0)
                error("%r");
            dot = inkdot(1);
            i++;
        }while(!fullrune(buf, i));
        if(buf[0] == 0)
            break;
        buf[i] = 0;
        dprint("%s", buf);
        endline();
    }
    dotinc = dot-savdot+1;
    dot = savdot;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'S':
    if (literal) {
        cp = (uchar*) &dot;
        for (i = 0; i < 4; i++)
            printesc(cp[i]);
        endline();
        dotinc = 4;
        break;
    }
    savdot=dot;
    while ((i = get1(map, dot, &ch, 1) > 0) && ch) {
        dot=inkdot(1);
        printesc(ch);
        endline();
    }
    if (i < 0)
        error("%r");
    dotinc = dot-savdot+1;
    dot=savdot;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'M':
    i = machdata->hexinst(map, dot, buf, sizeof(buf));
    if (i < 0)
        error("%r");
    dotinc = i;
    dprint("%s", buf);
    if (*fp) {
        dotinc = 0;
        dprint("%48t");
    } else
        dprint("\n");
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'f':
    /* BUG: 'f' and 'F' assume szdouble is sizeof(vlong) in the literal case */
    if (literal) {
        v = machdata->swav(dot);
        memmove(buf, &v, mach->szfloat);
    }else if (get1(map, dot, (uchar*)buf, mach->szfloat) < 0)
        error("%r");
    machdata->sftos(buf, sizeof(buf), (void*) buf);
    dprint("%s\n", buf);
    dotinc = mach->szfloat;
    break;
@
<<[[exform()]] switch modifier cases>>=
case 'F':
    /* BUG: 'f' and 'F' assume szdouble is sizeof(vlong) in the literal case */
    if (literal) {
        v = machdata->swav(dot);
        memmove(buf, &v, mach->szdouble);
    }else if (get1(map, dot, (uchar*)buf, mach->szdouble) < 0)
        error("%r");
    machdata->dftos(buf, sizeof(buf), (void*) buf);
    dprint("%s\n", buf);
    dotinc = mach->szdouble;
    break;
@

<<[[exform()]] switch modifier cases>>=
case 'n':
case 'N':
    printc('\n');
    dotinc=0;
    break;
@
<<[[exform()]] switch modifier cases>>=
case '"':
    dotinc=0;
    while (*fp != '"' && *fp)
        printc(*fp++);
    if (*fp)
        fp++;
    break;
@
<<[[exform()]] switch modifier cases>>=
case '^':
    dot=inkdot(-dotinc*fcount);
    return(fp);
@
<<[[exform()]] switch modifier cases>>=
case '+':
    dot=inkdot((WORD)fcount);
    return(fp);
@
<<[[exform()]] switch modifier cases>>=
case '-':
    dot=inkdot(-(WORD)fcount);
    return(fp);
@
<<[[exform()]] switch modifier cases>>=
case 'z':
    if (findsym(dot, CTEXT, &s))
        dprint("%s() ", s.name);
    printsource(dot);
    printc(EOR);
    return fp;

@




%XXX
<<[[acommand()]] switch optional command suffix character>>=
case 'm':
    if (eqcom)
        error(BADEQ); 
    cmdmap(map);
    break;
@

<<function cmdmap>>=
/*
 * set up maps for a direct process image (/proc)
 */

void
cmdmap(Map *map)
{
    int i;
    char name[MAXSYM];

    extern char lastc;

    rdc();
    readsym(name);
    i = findseg(map, name);
    if (i < 0)	/* not found */
        error("Invalid map name");

    if (expr(0)) {
        if (strcmp(name, "text") == 0)
            textseg(expv, &fhdr);
        map->seg[i].b = expv;
    } else
        error("Invalid base address"); 
    if (expr(0))
        map->seg[i].e = expv;
    else
        error("Invalid end address"); 
    if (expr(0))
        map->seg[i].f = expv; 
    else
        error("Invalid file offset"); 
    if (rdc()=='?' && map == cormap) {
        if (fcor)
            close(fcor);
        fcor=fsym;
        corfil=symfil;
        cormap = symmap;
    } else if (lastc == '/' && map == symmap) {
        if (fsym)
            close(fsym);
        fsym=fcor;
        symfil=corfil;
        symmap=cormap;
    } else
        reread();
}
@




<<[[acommand()]] switch optional command suffix character>>=
case 'L':
case 'l':
    if (eqcom)
        error(BADEQ); 
    cmdsrc(lastc, map);
    break;

@

<<function cmdsrc>>=
void
cmdsrc(int c, Map *map)
{
    ulong w;
    long locval, locmsk;
    ADDR savdot;
    ushort sh;
    char buf[512];
    int ret;

    if (c == 'L')
        dotinc = 4;
    else
        dotinc = 2;
    savdot=dot;
    expr(1); 
    locval=expv;
    if (expr(0))
        locmsk=expv; 
    else
        locmsk = ~0;
    if (c == 'L')
        while ((ret = get4(map, dot, &w)) > 0 &&  (w&locmsk) != locval)
            dot = inkdot(dotinc);
    else
        while ((ret = get2(map, dot, &sh)) > 0 && (sh&locmsk) != locval)
            dot = inkdot(dotinc);
    if (ret < 0) { 
        dot=savdot; 
        error("%r");
    }
    symoff(buf, 512, dot, CANY);
    dprint(buf);
}
@


<<[[acommand()]] switch optional command suffix character>>=
case 'W':
case 'w':
    if (eqcom)
        error(BADEQ); 
    cmdwrite(lastc, map);
    break;
@


<<global badwrite>>=
static char badwrite[] = "can't write process memory or text image";
@

<<function cmdwrite>>=
void
cmdwrite(int wcom, Map *map)
{
    ADDR savdot;
    char *format;
    int pass;

    if (wcom == 'w')
        format = "x";
    else
        format = "X";
    expr(1);
    pass = 0;
    do {
        pass++;  
        savdot=dot;
        exform(1, 1, format, map, 0, pass);
        dot=savdot;
        if (wcom == 'W') {
            if (put4(map, dot, expv) <= 0)
                error(badwrite);
        } else {
            if (put2(map, dot, expv) <= 0)
                error(badwrite);
        }
        savdot=dot;
        dprint("=%8t"); 
        exform(1, 0, format, map, 0, pass);
        newline();
    } while (expr(0));
    dot=savdot;
}
@


\section{Dumper commands, [[$]]}%$
% actually it's also setters command for some of them, like $m

<<[[command()]] switch lastcom cases>>=
case '$':
    lastcom=savecom;
    printtrace(nextchar()); 
    break;
@
%$

<<function printtrace>>=
void
printtrace(int modif)
{
    <<[[printtrace()]] locals>>
    int i;
    ulong w;
    BKPT *bk;
    Symbol s;
    int stack;
    char *fname;
    char buf[512];

    if (cntflg==FALSE)
        cntval = -1;

    switch (modif) {
    <<[[printtrace()]] switch modif cases>>
    default:
        error("bad `$' command");
    }

}
@
%$

\subsection{Address maps, [[$m]]}
%$

% start easy

<<[[printtrace()]] switch modif cases>>=
case 'm':
    printmap("? map", symmap);
    printmap("/ map", cormap);
    break;
@

<<function printmap>>=
void
printmap(char *s, Map *map)
{
    int i;

    if (!map)
        return;
    if (map == symmap)
        dprint("%s%12t`%s'\n", s, fsym < 0 ? "-" : symfil);
    else if (map == cormap)
        dprint("%s%12t`%s'\n", s, fcor < 0 ? "-" : corfil);
    else
        dprint("%s\n", s);

    for (i = 0; i < map->nsegs; i++) {
        if (map->seg[i].inuse)
            dprint("%s%8t%-16#llux %-16#llux %-16#llux\n",
                map->seg[i].name, 
                map->seg[i].b,
                map->seg[i].e, 
                map->seg[i].f);
    }
}
@

\subsection{Symbols, [[$S]] and [[$e]]}
%$


<<[[printtrace()]] switch modif cases>>=
case 'S':
    printsym();
    break;
@

% getsym is in libmach? set when machbytype on symfile?

<<function printsym>>=
/*
 *	dump the raw symbol table
 */
void
printsym(void)
{
    int i;
    Sym *sp;

    for (i = 0; sp = getsym(i); i++) {
        switch(sp->type) {
        case 't':
        case 'l':
            dprint("%16#llux t %s\n", sp->value, sp->name);
            break;
        case 'T':
        case 'L':
            dprint("%16#llux T %s\n", sp->value, sp->name);
            break;
        case 'D':
        case 'd':
        case 'B':
        case 'b':
        case 'a':
        case 'p':
        case 'm':
            dprint("%16#llux %c %s\n", sp->value, sp->type, sp->name);
            break;
        default:
            break;
        }
    }
}
@


<<[[printtrace()]] switch modif cases>>=
/*print externals*/
case 'e':
    for (i = 0; globalsym(&s, i); i++) {
        if (get4(cormap, s.value, &w) > 0)
            dprint("%s/%12t%#lux\n", s.name, w);
    }
    break;
@


\subsection{Current process, [[$?]]}
%$

<<[[printtrace()]] switch modif cases>>=
case 0:
case '?':
    if (pid)
        dprint("pid = %d\n",pid);
    else
        prints("no process\n");
    flushbuf();
@
% when have 0? when C-d in input of db?


\subsection{Stack traces, [[$c]]}
%$

<<[[printtrace()]] locals>>=
uvlong pc, sp, link;
@

<<global tracetype>>=
static	int	tracetype;
@
% why need static? can't be local of printtrace? no because
% use by ptrace callback
%ocaml: closure!

<<[[printtrace()]] switch modif cases>>=
case 'c':
case 'C':
    tracetype = modif;
    if (machdata->ctrace) {
        if (adrflg) {
            /*
             * trace from jmpbuf for multi-threaded code.
             * assume sp and pc are in adjacent locations
             * and mach->szaddr in size.
             */
            if (geta(cormap, adrval, &sp) < 0 ||
                geta(cormap, adrval+mach->szaddr, &pc) < 0)
                    error("%r");
        } else {
            sp = rget(cormap, mach->sp);
            pc = rget(cormap, mach->pc);
        }
        if(mach->link)
            link = rget(cormap, mach->link);
        else
            link = 0;
        if (machdata->ctrace(cormap, pc, sp, link, ptrace) <= 0)
            error("no stack frame");
    }
    break;
@

% ??? -> <> (as x <- machdata->ctrace(..., <>) <- printtrace)
<<function ptrace>>=
/*
 *	callback on stack trace
 */
static void
ptrace(Map *map, uvlong pc, uvlong sp, Symbol *sym)
{
    char buf[512];

    USED(map);
    dprint("%s(", sym->name);
    printparams(sym, sp);
    dprint(") ");
    printsource(sym->value);
    dprint(" called from ");
    symoff(buf, 512, pc, CTEXT);
    dprint("%s ", buf);
    printsource(pc);
    dprint("\n");

    if(tracetype == 'C')
        printlocals(sym, sp);
}
@


<<function printlocals>>=
void
printlocals(Symbol *fn, ADDR fp)
{
    int i;
    ulong w;
    Symbol s;

    s = *fn;
    for (i = 0; localsym(&s, i); i++) {
        if (s.class != CAUTO)
            continue;
        if (get4(cormap, fp-s.value, &w) > 0)
            dprint("%8t%s.%s/%10t%#lux\n", fn->name, s.name, w);
        else
            dprint("%8t%s.%s/%10t?\n", fn->name, s.name);
    }
}
@

\subsection{Registers, [[$r]] and [[$f]]}
%$

<<[[printtrace()]] switch modif cases>>=
case 'r':
case 'R':
    printregs(modif);
    return;
@


<<function printregs>>=
/*
 * print the registers
 */
void
printregs(int c)
{
    Reglist *rp;
    int i;
    uvlong v;

    for (i = 1, rp = mach->reglist; rp->rname; rp++, i++) {
        if ((rp->rflags & RFLT)) {
            if (c != 'R')
                continue;
            if (rp->rformat == '8' || rp->rformat == '3')
                continue;
        }
        v = getreg(cormap, rp);
        if(rp->rformat == 'Y')
            dprint("%-8s %-20#llux", rp->rname, v);
        else
            dprint("%-8s %-12#lux", rp->rname, (ulong)v);
        if ((i % 3) == 0) {
            dprint("\n");
            i = 0;
        }
    }
    if (i != 1)
        dprint("\n");
    dprint ("%s\n", machdata->excep(cormap, rget));
    printpc();
}
@


<<[[printtrace()]] switch modif cases>>=
case 'f':
case 'F':
    printfp(cormap, modif);
    return;
@

<<function printfp>>=
static void
printfp(Map *map, int modif)
{
    Reglist *rp;
    int i;
    int ret;
    char buf[512];

    for (i = 0, rp = mach->reglist; rp->rname; rp += ret) {
        ret = 1;
        if (!(rp->rflags&RFLT))
            continue;
        ret = fpformat(map, rp, buf, sizeof(buf), modif);
        if (ret < 0) {
            werrstr("Register %s: %r", rp->rname);
            error("%r");
        }
            /* double column print */
        if (i&0x01)
            dprint("%40t%-8s%-12s\n", rp->rname, buf);
        else
            dprint("\t%-8s%-12s", rp->rname, buf);
        i++;
    }
}
@



\subsection{Quitting, [[$q]]}
%$

%ugly: weird to be in a formatting commands
<<[[printtrace()]] switch modif cases>>=
case 'q':
case 'Q':
    done();
@


\subsection{XXX}

<<[[printtrace()]] switch modif cases>>=
case '<':
    if (cntval == 0) {
        while (readchar() != EOR)
            ;
        reread();
        break;
    }
    if (rdc() == '<')
        stack = 1;
    else {
        stack = 0;
        reread();
    }
    fname = getfname();
    redirin(stack, fname);
    break;
@
<<[[printtrace()]] switch modif cases>>=
case '>':
    fname = getfname();
    redirout(fname);
    break;
@

<<[[printtrace()]] switch modif cases>>=
case 'a':
    attachprocess();
    break;
@
<<function attachprocess>>=
void
attachprocess(void)
{
    char buf[100];
    Dir *sym, *mem;
    int fd;

    if (!adrflg) {
        dprint("used pid$a\n");
        return;
    }
    sym = dirfstat(fsym);
    sprint(buf, "/proc/%lud/mem", adrval);
    corfil = buf;
    setcor();
    sprint(buf, "/proc/%lud/text", adrval);
    fd = open(buf, OREAD);
    mem = nil;
    if (sym==nil || fd < 0 || (mem=dirfstat(fd))==nil
                || sym->qid.path != mem->qid.path)
        dprint("warning: text images may be inconsistent\n");
    free(sym);
    free(mem);
    if (fd >= 0)
        close(fd);
}
@
%$


<<[[printtrace()]] switch modif cases>>=
case 'k':
    kmsys();
    break;
@



<<constant MAXOFF>>=
#define	MAXOFF	0x1000000
@
<<global maxoff>>=
ADDR maxoff = MAXOFF;
@
<<[[printtrace()]] switch modif cases>>=
case 's':
    maxoff=(adrflg?adrval:MAXOFF);
    break;
@



<<[[printtrace()]] switch modif cases>>=
case 'M':
    fname = getfname();
    if (machbyname(fname) == 0)
        dprint("unknown name\n");;
    break;
@

\section{Sub process control commands, [[:]]}%$

<<[[command()]] switch lastcom cases>>=
case ':':
    if (!executing) { 
        executing=TRUE;
        subpcs(nextchar());
        executing=FALSE;
        lastcom=savecom;
    }
    break;
@
% when can have executing at false here?

<<function subpcs>>=
/* sub process control */

void
subpcs(int modif)
{
    // enum<runmode>
    int	runmode = SINGLE;
    int	check;
    bool keepnote = false;
    int	n;
    int r = 0;
    long line, curr;
    BKPT *bk;
    char *comptr;

    loopcnt=cntval;

    switch (modif) {
    <<[[subpcs()]] switch modif cases>>
    default:
        error("bad `:' command");
    }

    if (loopcnt>0) {
        dprint("%s: running\n", symfil);
        flush();
        r = runpcs(runmode, keepnote);
    }
    if (r)
        dprint("breakpoint%16t");
    else
        dprint("stopped at%16t");

Return:
    delbp();
    printpc();
    notes();
}
@



\subsection{Runmodes}

<<constant SINGLE>>=
#define	SINGLE	1
@
%todo: enum? enum runmode

<<constant CONTIN>>=
#define	CONTIN	2
@
% next breakpoint

\subsection{[[runpcs()]]}

<<function runpcs>>=
/* service routines for sub process control */

int
runpcs(int runmode, bool keepnote)
{
    int rc; // runcount
    BKPT *bkpt;

    rc = 0;
    if (adrflg)
        rput(cormap, mach->pc, dot);
    dot = rget(cormap, mach->pc);
    flush();

    while (loopcnt-- > 0) {
        if(loopcnt != 0)
            printpc();
        if (runmode == SINGLE) {
            bkpt = scanbkpt(dot);
            if (bkpt) {
                switch(bkpt->flag){
                case BKPTTMP:
                    bkpt->flag = BKPTCLR;
                    break;
                case BKPTSKIP:
                    bkpt->flag = BKPTSET;
                    break;
                }
            }
            runstep(dot, keepnote);
        } else {
            if ((bkpt = scanbkpt(rget(cormap, mach->pc))) != 0) {
                execbkpt(bkpt, keepnote);
                keepnote = false;
            }
            setbp();
            runrun(keepnote);
        }
        keepnote = false;
        delbp();
        dot = rget(cormap, mach->pc);

        /* real note? */
        if (nnote > 0) {
            keepnote = true;
            rc = 0;
            continue;
        }
        bkpt = scanbkpt(dot);
        if(bkpt == 0){
            keepnote = false;
            rc = 0;
            continue;
        }
        /* breakpoint */
        if (bkpt->flag == BKPTTMP)
            bkpt->flag = BKPTCLR;
        else if (bkpt->flag == BKPTSKIP) {
            execbkpt(bkpt, keepnote);
            keepnote = false;
            loopcnt++;	/* we didn't really stop */
            continue;
        }
        else {
            bkpt->flag = BKPTSKIP;
            --bkpt->count;
            if ((bkpt->comm[0] == EOR || command(bkpt->comm, ':') != 0)
            &&  bkpt->count != 0) {
                execbkpt(bkpt, keepnote);
                keepnote = false;
                loopcnt++;
                continue;
            }
            bkpt->count = bkpt->initcnt;
        }
        rc = 1;
    }
    return rc;
}
@



\subsection{Running, [[:r]]}

<<[[subpcs()]] switch modif cases>>=
/* run program */
case 'r': 
case 'R':
    endpcs();
    setup();
    runmode = CONTIN;
    break;
@


<<function setup>>=
/*
 * start up the program to be debugged in a child
 */
void
setup(void)
{

    nnote = 0;
    startpcs();
    bpin = FALSE;
    pcsactive = true;
}
@

<<function startpcs>>=
void
startpcs(void)
{
    pid = fork();
    // child
    if (pid == 0) {
        pid = getpid();
        msgpcs("hang");
        doexec();
        exits(nil);
    }
    // parent
    if (pid == -1)
        error("can't fork");
    child++;
    sprint(procname, "/proc/%d/mem", pid);
    corfil = procname;
    msgpcs("waitstop");

    // will call setcor()
    bpwait();
    if (adrflg)
        rput(cormap, mach->pc, adrval);

    while (rdc() != EOR)
        ;
    reread();
}
@

<<function bpwait>>=
void
bpwait(void)
{
    setcor();
    unloadnote();
}
@


<<global child>>=
int child;
@


<<function doexec>>=
void
doexec(void)
{
    char *argl[MAXARG];
    char args[LINSIZ];
    char *p;
    char **ap;
    char *thisarg;

    ap = argl;
    p = args;
    // argv[0] is the command itself
    *ap++ = symfil;

    <<[[doexec()]] adjust argl if extra arguments>>
    *ap = '\0';

    exec(symfil, argl);
    perror(symfil);
}
@


% hmm but fork, so share stdin for the command?

<<[[doexec()]] adjust argl if extra arguments>>=
for (rdc(); lastc != EOR;) {
    thisarg = p;
    if (lastc == '<' || lastc == '>') {
        *p++ = lastc;
        rdc();
    }
    while (lastc != EOR && lastc != SPC && lastc != TB) {
        *p++ = lastc;
        readchar();
    }
    if (lastc == SPC || lastc == TB)
        rdc();
    *p++ = 0;
    if (*thisarg == '<') {
        close(0);
        if (open(&thisarg[1], OREAD) < 0) {
            print("%s: cannot open\n", &thisarg[1]);
            _exits(0);
        }
    }
    else if (*thisarg == '>') {
        close(1);
        if (create(&thisarg[1], OWRITE, 0666) < 0) {
            print("%s: cannot create\n", &thisarg[1]);
            _exits(0);
        }
    }
    else
        *ap++ = thisarg;
}
@



\subsection{Stepping, [[:s]]}

<<[[subpcs()]] switch modif cases>>=
/* single step */
case 's': 
    if (pid == 0) {
        setup();
        loopcnt--;
    }
    runmode=SINGLE;
    keepnote=defval(true);
    break;
@

<<function defval>>=
WORD
defval(WORD w)
{
    if (expr(0))
        return (expv);
    else
        return (w);
}
@



<<[[subpcs()]] switch modif cases>>=
case 'S':
    if (pid == 0) {
        setup();
        loopcnt--;
    }
    keepnote=defval(true);

    line = pc2line(rget(cormap, mach->pc));
    n = loopcnt;
    dprint("%s: running\n", symfil);
    flush();
    for (loopcnt = 1; n > 0; loopcnt = 1) {
        r = runpcs(SINGLE, keepnote);
        curr = pc2line(dot);
        if (line != curr) {	/* on a new line of c */
            line = curr;
            n--;
        }
    }
    loopcnt = 0;
    break;
@

%pc2line also in libmach?


\subsection{Killing, [[:k]]}


<<global NOPCS>>=
char	NOPCS[] = "no process";
@

<<[[subpcs()]] switch modif cases>>=
/* exit */
case 'k' :
case 'K':
    if (pid == 0)
        error(NOPCS);
    dprint("%d: killed", pid);
    pcsactive = true;	/* force 'kill' ctl */
    endpcs();
    return;
@


<<global ending>>=
// was in runpcs.c
bool ending;
@

<<function endpcs>>=
/*
 * finish the process off;
 * kill if still running
 */
void
endpcs(void)
{
    BKPT *bk;

    if(ending)
        return;
    ending = true;
    if (pid) {
        if(pcsactive){
            killpcs();
            pcsactive = false;
        }
        pid=0;
        nnote=0;
        for (bk=bkpthead; bk; bk = bk->nxtbkpt)
            if (bk->flag == BKPTTMP)
                bk->flag = BKPTCLR;
            else if (bk->flag != BKPTCLR)
                bk->flag = BKPTSET;
    }
    bpin = FALSE;
    ending = false;
}
@

<<global bpin>>=
bool bpin;
@
% shared with delbp()




\subsection{Halting, [[:h]]}
% happens when we attach to a process and we want to stop it.

<<[[subpcs()]] switch modif cases>>=
/* halt the current process */
case 'h':	
    if (adrflg && adrval == 0) {
        if (pid == 0)
            error(NOPCS);
        ungrab();
    }
    else {
        grab();
        dprint("stopped at%16t");
        goto Return;
    }
    return;
@
% %t???

<<function grab>>=
void
grab(void)
{
    flush();
    msgpcs("stop");
    bpwait();
}
@







\subsection{Unhalting, [[:x]]}

<<[[subpcs()]] switch modif cases>>=
/* continue executing the current process */
case 'x':	
    if (pid == 0)
        error(NOPCS);
    ungrab();
    return;
@

<<function ungrab>>=
void
ungrab(void)
{
    msgpcs("start");
}
@
%less: delete? inline the code?

\section{Breakpoints}

<<function scanbkpt>>=
/*
 * find the breakpoint at adr, if any
 */
BKPT*
scanbkpt(ADDR adr)
{
    BKPT *bk;

    for (bk = bkpthead; bk; bk = bk->nxtbkpt)
        if (bk->flag != BKPTCLR && bk->loc == adr)
            break;
    return bk;
}
@


\subsection{Inspecting breakpoints, [[$b]]}
%$

<<[[printtrace()]] switch modif cases>>=
/*print breakpoints*/
case 'b':
case 'B':
    for (bk=bkpthead; bk; bk=bk->nxtbkpt)
        if (bk->flag) {
            symoff(buf, 512, (WORD)bk->loc, CTEXT);
            dprint(buf);
            if (bk->count != 1)
                dprint(",%d", bk->count);
            dprint(":%c %s", 
                     bk->flag == BKPTTMP ? 'B' : 'b', 
                     bk->comm);
        }
    break;
@
% symoff use a global?

\subsection{Setting breakpoints, [[:b]]}

<<[[subpcs()]] switch modif cases>>=
/* set breakpoint */
case 'b': 
case 'B':
    if (bk=scanbkpt(dot))
        bk->flag=BKPTCLR;

    <<[[subpcs()]] breakpoint case, find unused breakpoint bk or allocate one>>

    bk->loc = dot;
    bk->flag = modif == 'b' ? BKPTSET : BKPTTMP;
    bk->initcnt = bk->count = cntval;

    <<[[subpcs()]] breakpoint case, set optional breakpoint command>>
@




<<[[subpcs()]] breakpoint case, find unused breakpoint bk or allocate one>>=
for (bk=bkpthead; bk; bk=bk->nxtbkpt)
    if (bk->flag == BKPTCLR)
        break;
if (bk==nil) {
    bk = (BKPT *)malloc(sizeof(*bk));
    if (bk == nil)
        error("too many breakpoints");
    bk->nxtbkpt=bkpthead;
    bkpthead=bk;
}
@




\subsection{Deleting breakpoints, [[:d]]}

<<[[subpcs()]] switch modif cases>>=
/* delete breakpoint */
case 'd': 
case 'D':
    if ((bk=scanbkpt(dot)) == 0)
        error("no breakpoint set");
    bk->flag=BKPTCLR;
    return;
@

\subsection{Continuing execution, [[:c]]}

<<[[subpcs()]] switch modif cases>>=
/* continue with optional note */
case 'c': 
case 'C': 
    if (pid==0)
        error(NOPCS);
    runmode=CONTIN;
    keepnote=defval(1);
    break;
@

\subsection{Advanced breakpoints}

<<constant MAXCOM>>=
#define MAXCOM	64
@
<<[[Bkpt]] other fields>>=
char	comm[MAXCOM];
@


<<constant HUGEINT>>=
#define	HUGEINT	0x7fffffff	/* enormous WORD */
@

<<[[subpcs()]] breakpoint case, set optional breakpoint command>>=
check=MAXCOM-1;
comptr=bk->comm;

rdc();
reread();

do {
    *comptr++ = readchar();
} while (check-- && lastc!=EOR);
*comptr='\0';
if(bk->comm[0] != EOR && cntflg == FALSE)
    bk->initcnt = bk->count = HUGEINT;
reread();
if (check)
    return;
error("bkpt command too long");
@



\section{Other commands}

<<[[command()]] switch lastcom cases>>=
case '>':
    lastcom = savecom; 
    savc=rdc();
    if (reg=regname(savc))
        rput(cormap, reg, dot);
    else	
        error("bad variable");
    break;
@

<<[[command()]] switch lastcom cases>>=
case '!':
    lastcom=savecom;
    shell(); 
    break;
@



<<[[command()]] switch lastcom cases>>=
case '\0':
    prints(DBNAME);
    break;

@
%$
% how can have this?

<<constant DBNAME>>=
#define	DBNAME	"db\n"
@


\chapter{Metadata Generation}

\section{Assembler}

\section{Compiler}

\section{Linker}

\chapter{Kernel Support}

\section{Core dumps and broken processes}

% when process crashes, it's still around, and can just run
% ps; db <pid> to start inspect! really useful.

\chapter{Advanced Features}

\section{[[db -w]]}

<<[[main()]] command line processing (db)>>=
case 'w':
    wtflag = ORDWR;		/* suitable for open() */
    break;
@

<<[[getfile()]] if wtflag>>=
if (f < 0 && xargc > cnt && wtflag)
     f = create(filnam, 1, 0666);
@

<<global xargc>>=
int xargc;		/* bullshit */
@

<<[[main()]] initialization before repl (db)>>=
xargc = argc;
@

\section{Signals and notes}

<<global nnote>>=
int nnote;
@

<<global note>>=
char note[NNOTE][ERRMAX];
@
<<constant NNOTE>>=
#define	NNOTE 10
@


% ((grab | startpcs ) bpwait) | ??? -> <>
<<function unloadnote>>=
/*
 * empty the note buffer and toss pending breakpoint notes
 */
void
unloadnote(void)
{
    char err[ERRMAX];

    setpcs();
    for(; nnote<NNOTE; nnote++){
        switch(read(notefd, note[nnote], sizeof note[nnote])){
        case -1:
            errstr(err, sizeof err);
            if(strcmp(err, "interrupted") != 0)
                endpcs();
            errors("can't read note file", err);
        case 0:
            return;
        }
        note[nnote][ERRMAX-1] = '\0';
        if(strncmp(note[nnote], "sys: breakpoint", 15) == 0)
            --nnote;
    }
}
@


\subsection{[[:n]]}

<<[[subpcs()]] switch modif cases>>=
/* deal with notes */
case 'n':	
    if (pid==0)
        error(NOPCS);
    n=defval(-1);
    if(n>=0 && n<nnote){
        nnote--;
        memmove(note[n], note[n+1], (nnote-n)*sizeof(note[0]));
    }
    notes();
    return;
@

\chapter{Advanced Topics}

\section{Cross architecture debugging, [[db -m]]}

<<[[main()]] locals (db)>>=
char *name = nil;
@

<<[[main()]] command line processing (db)>>=
case 'm':
    name = ARGF();
    if(name == nil)
        dprint("missing -m argument\n");
    break;
@

<<[[main()]] if db -m and unknown machine>>=
if (name && machbyname(name) == 0)
        dprint ("unknown machine %s", name);
@

\section{Kernel debugging, [[db -k]]}
% have a special chapter for Kernel debugging, with ktrace too?

<<global kflag>>=
bool kflag;
@

<<[[main()]] command line processing (db)>>=
case 'k':
    kflag = true;
    break;
@

<<[[main()]] locals (db)>>=
char *cpu, *p, *q;
@

<<[[main()]] when pid argument, if kflag>>=
if(kflag){
    cpu = getenv("cputype");
    if(cpu == nil){
        cpu = "386";
        dprint("$cputype not set; assuming %s\n", cpu);
    }
    p = getenv("terminal");
    if(p==nil || (p=strchr(p, ' '))==0 || p[1]==' ' || p[1]==0){
        strcpy(b1, "/386/9pc");
        dprint("missing or bad $terminal; assuming %s\n", b1);
    }else{
        p++;
        q = strchr(p, ' ');
        if(q)
            *q = '\0';
        sprint(b1, "/%s/9%s", cpu, p);
    
    }
}
@
% b1 then flows into symfile


\chapter{Conclusion}


\appendix

\chapter{Debugging}
% debugging the debugger



\chapter{Error Managment}

<<global env>>=
jmp_buf env;
@



%        if (syminit(fsym, &fhdr) < 0)
%            dprint("%r\n");
% lots of error(%r)

<<global errmsg>>=
// was static in main.c
char *errmsg;
@

<<[[main()]] in loop, handle errmsg (db)>>=
if (errmsg) {
    dprint(errmsg);
    printc('\n');
    errmsg = nil;
    exitflg = false;
}
@


<<function error>>=
/*
 * An error occurred; save the message for later printing,
 * close open files, and reset to main command loop.
 */
void
error(char *n)
{
    errmsg = n;
    iclose(0, 1);
    oclose();
    flush();
    delbp();
    ending = 0;
    longjmp(env, 1);
}
@

<<function errors>>=
void
errors(char *m, char *n)
{
    static char buf[128];

    sprint(buf, "%s: %s", m, n);
    error(buf);
}
@

<<function oclose>>=
void
oclose(void)
{
    flushbuf();
    Bterm(&stdout);
    Binit(&stdout, 1, OWRITE);
}
@


\chapter{Libc}

\chapter{Extra Code}

\ifallcode
#include "Debugger_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

