\documentclass[twocolumn]{report}
%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph:

%thx to this manual, better understand debuggers:
% - SEMI how can be fast? via trap abuse? thx to virtual memory and page
%   fault again!

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the file before
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Plan9 Tracers and Debuggers
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Phil Winterbottom
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a debugger and tracer.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present strace (actually was called ratrace), db (and maybe acid).
% Small programs.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item gdb
% dwarf debugging format?
\item Linux strace
\item Solaris dtrace
\item valgrind
\end{itemize}

%http://blog.0x972.info/?d=2014/11/13/10/40/50-how-does-a-debugger-work

%https://www.hackerschool.com/blog/5-learning-c-with-gdb

% TODO: snap/, to lpize and include


%Need also mach.h, many helper functions to access the binary/object file

% see also cc/acid.c



\section{Getting started}

\section{Requirements}

% docs/man/2/debugger

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Debugger principles}

% naive = interpreter, cf Machine.nw, but very very slow.
% => hardware debugging support! so fast!

% simple: modify the code in memory at the breakpoint address given
% by user to generate a fault => when execute and reach breakpoint
% we will be given back the hand. => efficient!
% less: Can use same trick for watchpoint? when access some memory area?
% hmm but then has to invalidate the whole page? so some false positives.

% for debugger to work it needs metadata, generated by
% the assembler, the compiler, and the linker.
% See "Debugging Support" chapters in Assembler.nw, Compiler.nw,
% Linker.nw We will recall the essential things below.

% It also needs support from the kernel. See the Broken state
% in Kernel.nw. But it's very convenient because when segfault,
% got the core dump, actually under plan9 the process is put
% in a Broken state and can be debugged by
%  db <pid>
% Awesome (remember efuns.byte crashes)



\section{[[strace]] services}

% strace <cmd>

% simple, and very effective at finding many bugs, like
% no more space in /tmp. Especially when people don't check
% return error code, at least see the call to create a file in /tmp

\section{[[db]] services}

% see also Machine.nw, which has a similar interface.

<<[[main()]] print usage and exit (db)>>=
fprint(2, "Usage: db [-kw] [-m machine] [-I dir] [symfile] [pid]\n");
exits("usage");
@

% db -c <cmd>
% db <pid>

% > main
% =>  main() /tests/8c/helloc.c:5
% (now dot is main)
% > ?   
% => SUBL $4, SP,  (? is for textfile)
% > /   
% => ( / is for memfile)

% ?i => print using instruction format
% ?iii ?3i => print 3 next instructions from dot

% RET => increment dot
 
% $m => show address maps (text and data spec)
% $b => show breakpoints
% $c => stacktrace
% $C => stacktrace with parameters values! and locals! awesome! like in Perl!
%  ex:
%  caml_main(argv=...) /home/pad/../main.c called from main+f (/home/pad/...)
%    caml_main.raise_buf/ 0x1
%    caml_main.pos/ 0x0
%    caml_main.trail/ 0x4cf2c
%    ...
%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)
% $r => dump registers
% $q => exit

% :r => run
% :c => continue
% :bmain => breakpoint main (can check with $b after)

%todo: ??? dump value of a global

\section{Code organization}

\section{Software architecture}

%###############################################################################

\chapter{Core Data Structures}

\section{[[/proc/x/text]]}

\section{[[/proc/x/mem]]}

\section{[[Map]]}

\section{[[Bkpt]]}

<<struct bkpt>>=
struct bkpt {
    ADDR	loc;

    uchar	save[4];
    int	count;
    int	initcnt;
    int	flag;
    char	comm[MAXCOM];

    BKPT	*nxtbkpt;
};
@

\chapter{[[main()]]}

<<global symfil>>=
char	*symfil = nil;
@
% program to be debugged, containing symbol information, for text and data
% or /proc/x/text

<<global corfil>>=
char	*corfil = nil;
@
% memory, for the heap and stack, will be /proc/xxx/mem?


<<global infile>>=
int	infile = STDIN;
@
% input to the debugger


<<function main (db/main.c)>>=
void
main(int argc, char **argv)
{
    <<[[main()]] locals (db)>>

    outputinit();

    ARGBEGIN{
    <<[[main()]] command line processing (db)>>
    }ARGEND

    if (argc > 0 && !alldigs(argv[0])) {
        symfil = argv[0];
        argv++;
        argc--;
    }
    <<[[main()]] if pid argument, attach to existing process>>
    else if (argc > 0) {
        <<[[main()]] print usage and exit (db)>>
    }
    if (!symfil)
        symfil = "8.out";

    <<[[main()]] initialization before repl (db)>>

    for (;;) {
        // clear output
        flushbuf();

        <<[[main()]] in loop, handle errmsg (db)>>
        <<[[main()]] in loop, handle mkfault (db)>>

        // clear input
        clrinp();

        rdc();
        reread();

        <<[[main()]] in loop, if eof (db)>>

        exitflg = false;
        command(nil, 0);

        reread();
        if (rdc() != '\n')
            error("newline expected");
    }
}
@
%dead? exitflg is never set to true anyway

\section{[[outputinit()]] and [[stdout]]}

<<global stdout>>=
Biobuf	stdout;
@

<<function outputinit>>=
void
outputinit(void)
{
    Binit(&stdout, 1, OWRITE);
    fmtinstall('t', tconv);
}
@
% %t ??

<<function tconv>>=
/* was move to next f1-sized tab stop; now just print a tab */
int
tconv(Fmt *f)
{
    return fmtstrcpy(f, "\t");
}
@
% ???

\section{[[setsym()]] and [[symmap]]}

<<global symmap>>=
// was in setup.c
Map	*symmap;
@
% derived from text

<<global cormap>>=
Map	*cormap;
@
% derived from heap and stack?

<<global dotmap>>=
Map	*dotmap;
@
% ???


<<global fhdr (db/setup.c)>>=
static Fhdr fhdr;
@


<<global fsym>>=
fdt fsym;
@
% why need that to be a global?

<<function setsym>>=
void
setsym(void)
{
    Symbol s;

    if((fsym = getfile(symfil, 1, wtflag)) < 0) {
        symmap = dumbmap(-1);
        return;
    }
    if (crackhdr(fsym, &fhdr)) {
        machbytype(fhdr.type);
        symmap = loadmap(symmap, fsym, &fhdr);
        if (symmap == nil)
            symmap = dumbmap(fsym);
        if (syminit(fsym, &fhdr) < 0)
            dprint("%r\n");
        if (mach->sbreg && lookup(0, mach->sbreg, &s))
            mach->sb = s.value;
    }
    else
        symmap = dumbmap(fsym);
}
@

% return fdt or -1
<<function getfile>>=
static fdt
getfile(char *filnam, int cnt, int omode)
{
    fdt f;

    if (filnam == nil)
        return ERROR_NEG1;
    if (strcmp(filnam, "-") == 0)
        return STDIN;
    f = open(filnam, omode|OCEXEC);
    if(f < 0 && omode == ORDWR){
        f = open(filnam, OREAD|OCEXEC);
        if(f >= 0)
            dprint("%s open read-only\n", filnam);
    }
    if (f < 0 && xargc > cnt)
        if (wtflag)
            f = create(filnam, 1, 0666);
    if (f < 0) {
        dprint("cannot open `%s': %r\n", filnam);
        return ERROR_NEG1;
    }
    return f;
}
@

<<function dumbmap>>=
Map *
dumbmap(fdt fd)
{
    Map *dumb;


    dumb = newmap(0, 1);
    setmap(dumb, fd, 0, 0xffffffff, 0, "data");
    if (!mach) 			/* default machine = 386 */
        mach = &mi386;
    if (!machdata)
        machdata = &i386mach;
    return dumb;
}
@


\section{[[clrinp()]], [[rdc()]], [[reread()]]}

% poor's man command lexing

<<global peekc>>=
int	peekc;
@

<<global lastc>>=
int lastc = EOR;
@


<<constant EOR>>=
#define EOR	'\n'
@
% End Of ? Return?

<<constant SPC>>=
#define SPC	' '
@

<<constant TB>>=
#define TB	'\t'
@





<<global lp>>=
Rune	*lp;
@
% ??


<<function clrinp>>=
void
clrinp(void)
{
    flush();
    lp = nil;
    peekc = 0;
}
@


<<function rdc>>=
int
rdc(void)
{
    do {
        readchar();
    } while (lastc==SPC || lastc==TB);
    return lastc;
}
@
% ugly use of global, why readchar does not return a char instead?


<<function reread>>=
void
reread(void)
{
    peekc = lastc;
}
@



\section{[[command()]]}

% [addr] [, count] ?/=:$ command

<<function command>>=
/* command decoding */
int
command(char *buf, int defcom)
{
    <<[[command()]] locals (db)>>

    <<[[command()]] initializations (db)>>

    do {
        <<[[command()]] parse possibly first address, set dot>>
        <<[[command()]] parse possibly count, set cntval>>

        <<[[command()]] parse command, set lastcom>>
        switch(lastcom) {
        <<[[command()]] switch lastcom cases>>
        default: 
            error("bad command");
        }
        flushbuf();
    } while (rdc()==';');

    <<[[command()]] finalizations (db)>>
}
@
%$

<<global dot>>=
// was in command.c
ADDR	dot;
@

<<global cntval>>=
WORD cntval;
@


<<[[command()]] locals (db)>>=
static char lastcom = '=';
@







<<[[command()]] initializations (db)>>=
if (defcom == 0)
    defcom = lastcom;
if (buf) {
    if (*buf==EOR)
        return FALSE;
    clrinp();
    lp=(Rune*)buf;
}
@



<<[[command()]] locals (db)>>=
Rune*   savlp = lp;
char	savlc = lastc;
char	savpc = peekc;
@

<<[[command()]] finalizations (db)>>=
if (buf == nil)
    reread();
else {
    clrinp();
    lp=savlp;
    lastc = savlc;
    peekc = savpc;
}

if(adrflg)
    return dot;
return 1;
@

<<[[command()]] locals (db)>>=
char	*reg;
char	savc;
static char savecom = '=';
@








<<[[command()]] parse command, set lastcom>>=
if (!eol(rdc()))
    lastcom=lastc;		/* command */
else {
    if (adrflg==0)
        dot=inkdot(dotinc);
    reread();
    lastcom=defcom;
}
@

<<function eol>>=
bool
eol(int c)
{
    return(c==EOR || c==';');
}
@


\section{[[done()]]}

<<global eof>>=
bool	eof;
@

<<[[main()]] in loop, if eof (db)>>=
if (eof) {
    if (infile == STDIN)
        done();
    iclose(-1, 0);
    eof = false;

    longjmp(env, 1);
}
@

<<function done>>=
void
done(void)
{
    if (pid)
        endpcs();
    exits(exitflg? "error": nil);
}
@


\section{XXX}


<<[[main()]] in loop, handle mkfault (db)>>=
if (mkfault) {
    mkfault=0;
    printc('\n');
    prints(DBNAME);
}
@

<<[[main()]] initialization before repl (db)>>=
xargc = argc;
notify(fault);

setsym();
dotmap = dumbmap(-1);
if (name && machbyname(name) == 0)
        dprint ("unknown machine %s", name);
dprint("%s binary\n", mach->name);

if(setjmp(env) == 0){
    if (corfil) {
        setcor();	/* could get error */
        dprint("%s\n", machdata->excep(cormap, rget));
        printpc();
    }
}

setjmp(env);
if (executing)
    delbp();
executing = FALSE;
@


<<[[main()]] locals (db)>>=
char *s;
char *name = nil;
@


<<[[main()]] command line processing (db)>>=
case 'w':
    wtflag = ORDWR;		/* suitable for open() */
    break;
@
<<[[main()]] command line processing (db)>>=
case 'I':
    s = ARGF();
    if(s == 0)
        dprint("missing -I argument\n");
    else
        Ipath = s;
    break;
@
<<[[main()]] command line processing (db)>>=
case 'm':
    name = ARGF();
    if(name == 0)
        dprint("missing -m argument\n");
    break;
@

<<function alldigs>>=
bool
alldigs(char *s)
{
    while(*s){
        if(*s<'0' || '9'<*s)
            return false;
        s++;
    }
    return true;
}
@

\section{Process attachment}

<<[[main()]] locals (db)>>=
char b1[100];
char b2[100];
@


<<[[main()]] if pid argument, attach to existing process>>=
if(argc==1 && alldigs(argv[0])){

    pid = atoi(argv[0]);
    pcsactive = 0;
    if (!symfil) {
        <<[[main()]] when pid argument, if kflag>>
        else
            sprint(b1, "/proc/%s/text", argv[0]);
        symfil = b1;
    }
    sprint(b2, "/proc/%s/mem", argv[0]);
    corfil = b2;
}
@


\chapter{Input}

% modifies peekc, lastc, lp

<<global line>>=
Rune	line[LINSIZ];
@
<<constant LINSIZ>>=
#define LINSIZ	4096
@


<<function readchar>>=
int
readchar(void)
{
    Rune *p;

    if (eof)
        lastc='\0';
    else if (peekc) {
        lastc = peekc;
        peekc = 0;
    }
    else {
        if (lp==nil) {
            for (p = line; p < &line[LINSIZ-1]; p++) {
                eof = readrune(infile, p) <= 0;
                if (mkfault) {
                    eof = 0;
                    error(nil);
                }
                if (eof) {
                    p--;
                    break;
                }
                if (*p == EOR) {
                    if (p <= line)
                        break;
                    if (p[-1] != '\\')
                        break;
                    p -= 2;
                }
            }
            p[1] = '\0';
            lp = line;
        }
        if ((lastc = *lp) != 0)
            lp++;
    }
    return lastc;
}
@

<<function readrune>>=
int
readrune(int fd, Rune *r)
{
    char buf[UTFmax+1];
    int i;

    for(i=0; i<UTFmax && !fullrune(buf, i); i++)
        if(read(fd, buf+i, 1) <= 0)
            return -1;
    buf[i] = '\0';
    chartorune(r, buf);
    return 1;
}
@

\chapter{Parsing}

<<global expv>>=
// was in expr.c
uvlong	expv;
@


<<function expr>>=
int
expr(int a)
{	/* term | term dyadic expr |  */
    int	rc;
    WORD	lhs;

    rdc();
    reread();

    rc=term(a);
    while (rc) {
        lhs = expv;
        switch ((int)readchar()) {

        case '+':
            term(a|1);
            expv += lhs;
            break;

        case '-':
            term(a|1);
            expv = lhs - expv;
            break;

        case '#':
            term(a|1);
            expv = round(lhs,expv);
            break;

        case '*':
            term(a|1);
            expv *= lhs;
            break;

        case '%':
            term(a|1);
            if(expv != 0)
                expv = lhs/expv;
            else{
                if(lhs)
                    expv = 1;
                else
                    expv = 0;
            }
            break;

        case '&':
            term(a|1);
            expv &= lhs;
            break;

        case '|':
            term(a|1);
            expv |= lhs;
            break;

        case ')':
            if ((a&2)==0)
                error("unexpected `)'");

        default:
            reread();
            return rc;
        }
    }
    return rc;
}
@

<<function term>>=
int
term(int a)
{	/* item | monadic item | (expr) | */
    ADDR e;

    switch ((int)readchar()) {

    case '*':
        term(a|1);
        if (geta(cormap, expv, &e) < 0)
            error("%r");
        expv = e;
        return 1;

    case '@':
        term(a|1);
        if (geta(symmap, expv, &e) < 0)
            error("%r");
        expv = e;
        return 1;

    case '-':
        term(a|1);
        expv = -expv;
        return 1;

    case '~':
        term(a|1);
        expv = ~expv;
        return 1;

    case '(':
        expr(2);
        if (readchar()!=')')
            error("syntax error: `)' expected");
        return 1;

    default:
        reread();
        return item(a);
    }
}
@

<<function item>>=
int
item(int a)
{	/* name [ . local ] | number | . | ^  | <register | 'x | | */
    char	*base;
    char	savc;
    uvlong e;
    Symbol s;
    char gsym[MAXSYM], lsym[MAXSYM];

    readchar();
    if (isfileref()) {
        readfname(gsym);
        rdc();			/* skip white space */
        if (lastc == ':') {	/* it better be */
            rdc();		/* skip white space */
            if (!getnum(readchar))
                error("bad number");
            if (expv == 0)
                expv = 1;	/* file begins at line 1 */
            expv = file2pc(gsym, expv);
            if (expv == -1)
                error("%r");
            return 1;
        }
        error("bad file location");
    } else if (symchar(0)) {	
        readsym(gsym);
        if (lastc=='.') {
            readchar();	/* ugh */
            if (lastc == '.') {
                lsym[0] = '.';
                readchar();
                readsym(lsym+1);
            } else if (symchar(0)) {
                readsym(lsym);
            } else
                lsym[0] = 0;
            if (localaddr(cormap, gsym, lsym, &e, rget) < 0)
                error("%r");
            expv = e;
        }
        else {
            if (lookup(0, gsym, &s) == 0)
                error("symbol not found");
            expv = s.value;
        }
        reread();
    } else if (getnum(readchar)) {
        ;
    } else if (lastc=='.') {	
        readchar();
        if (!symchar(0) && lastc != '.') {
            expv = dot;
        } else {
            if (findsym(rget(cormap, mach->pc), CTEXT, &s) == 0)
                error("no current function");
            if (lastc == '.') {
                lsym[0] = '.';
                readchar();
                readsym(lsym+1);
            } else
                readsym(lsym);
            if (localaddr(cormap, s.name, lsym, &e, rget) < 0)
                error("%r");
            expv = e;
        }	
        reread();
    } else if (lastc=='"') {
        expv=ditto;
    } else if (lastc=='+') {
        expv=inkdot(dotinc);
    } else if (lastc=='^') {
        expv=inkdot(-dotinc);
    } else if (lastc=='<') {
        savc=rdc();
        base = regname(savc);
        expv = rget(cormap, base);
    }
    else if (lastc=='\'')
        expv = ascval();
    else if (a)
        error("address expected");
    else {	
        reread();
        return(0);
    }
    return(1);
}
@


\chapter{Output}

\chapter{Commands}

\section{Inspection commands, [[?/]]}

<<[[command()]] switch lastcom cases>>=
case '?':
case '/':
case '=':
    savecom = lastcom;
    acommand(lastcom);
    break;
@

<<function acommand>>=
/*
 * [/?][wml]
 */

void
acommand(int pc)
{
    bool eqcom;
    Map *map;
    char *fmt;
    char buf[512];

    if (pc == '=') {
        eqcom = true;
        fmt = eqformat;
        map = dotmap;
    } else {
        eqcom = false;
        fmt = stformat;
        if (pc == '/')
            map = cormap;
        else
            map = symmap;
    }
    if (!map) {
        snprint(buf, sizeof(buf), "no map for %c", pc);
        error(buf);
    }

    switch (rdc()) {
    <<[[acommand()]] switch optional command suffix character>>
    default:
        reread();
        getformat(fmt);
        scanform(cntval, !eqcom, fmt, map, eqcom);
    }
}
@

<<function getformat>>=
void
getformat(char *deformat)
{
    char *fptr;
    bool	quote;
    Rune r;

    fptr=deformat;
    quote=FALSE;
    while ((quote ? readchar()!=EOR : !eol(readchar()))){
        r = lastc;
        fptr += runetochar(fptr, &r);
        if (lastc == '"')
            quote = ~quote;
    }
    lp--;
    if (fptr!=deformat)
        *fptr = '\0';
}
@


<<function scanform>>=
void
scanform(long icount, int prt, char *ifp, Map *map, int literal)
{
    char	*fp;
    char	c;
    int	fcount;
    ADDR	savdot;
    bool firstpass = true;

    while (icount) {
        fp=ifp;
        savdot=dot;

        /*now loop over format*/
        while (*fp) {
            if (!isdigit(*fp))
                fcount = 1;
            else {
                fcount = 0;
                while (isdigit(c = *fp++)) {
                    fcount *= 10;
                    fcount += c-'0';
                }
                fp--;
            }
            if (*fp==0)
                break;
            fp=exform(fcount,prt,fp,map,literal,firstpass);
            firstpass = false;
        }
        dotinc=dot-savdot;
        dot=savdot;
        if (--icount)
            dot=inkdot(dotinc);
    }
}
@


<<function exform>>=
char *
exform(int fcount, int prt, char *ifp, Map *map, int literal, bool firstpass)
{
    /* execute single format item `fcount' times
     * sets `dotinc' and moves `dot'
     * returns address of next format item
     */
    uvlong	v;
    ulong	w;
    ADDR	savdot;
    char	*fp;
    char	c, modifier;
    int	i;
    ushort sh, *sp;
    uchar ch, *cp;
    Symbol s;
    char buf[512];
    extern int printcol;

    fp = 0;
    while (fcount > 0) {
        fp = ifp;
        c = *fp;
        modifier = *fp++;
        if (firstpass) {
            firstpass = false;
            if (!literal  && (c == 'i' || c == 'I' || c == 'M')
                    && (dot & (mach->pcquant-1))) {
                dprint("warning: instruction not aligned");
                printc('\n');
            }
            if (prt && modifier != 'a' && modifier != 'A') {
                symoff(buf, 512, dot, CANY);
                dprint("%s%c%16t", buf, map==symmap? '?':'/');
            }
        }
        if (printcol==0 && modifier != 'a' && modifier != 'A')
            dprint("\t\t");

        switch(modifier) {
        <<[[exform()]] switch modifier cases>>
        default:
            error("bad modifier");
        }

        if (map->seg[0].fd >= 0)
            dot=inkdot(dotinc);
        fcount--;
        endline();
    }

    return fp;
}
@


<<[[exform()]] switch modifier cases>>=
case SPC:
case TB:
    dotinc = 0;
    break;

case 't':
case 'T':
    dprint("%*t", fcount);
    dotinc = 0;
    return(fp);

case 'a':
    symoff(buf, sizeof(buf), dot, CANY);
    dprint("%s%c%16t", buf, map==symmap? '?':'/');
    dotinc = 0;
    break;

case 'A':
    dprint("%#llux%10t", dot);
    dotinc = 0;
    break;

case 'p':
    if (get4(map, dot, &w) < 0)
        error("%r");
    symoff(buf, sizeof(buf), w, CANY);
    dprint("%s%16t", buf);
    dotinc = mach->szaddr;
    break;

case 'u':
case 'd':
case 'x':
case 'o':
case 'q':
    if (literal)
        sh = (ushort) dot;
    else if (get2(map, dot, &sh) < 0)
        error("%r");
    w = sh;
    dotinc = 2;
    if (c == 'u')
        dprint("%-8lud", w);
    else if (c == 'x')
        dprint("%-8#lux", w);
    else if (c == 'd')
        dprint("%-8ld", w);
    else if (c == 'o')
        dprint("%-8#luo", w);
    else if (c == 'q')
        dprint("%-8#lo", w);
    break;

case 'U':
case 'D':
case 'X':
case 'O':
case 'Q':
    if (literal)
        w = (long) dot;
    else if (get4(map, dot, &w) < 0)
        error("%r");
    dotinc = 4;
    if (c == 'U')
        dprint("%-16lud", w);
    else if (c == 'X')
        dprint("%-16#lux", w);
    else if (c == 'D')
        dprint("%-16ld", w);
    else if (c == 'O')
        dprint("%-#16luo", w);
    else if (c == 'Q')
        dprint("%-#16lo", w);
    break;
case 'Z':
case 'V':
case 'Y':
    if (literal)
        v = dot;
    else if (get8(map, dot, &v) < 0)
        error("%r");
    dotinc = 8;
    if (c == 'Y')
        dprint("%-20#llux", v);
    else if (c == 'V')
        dprint("%-20lld", v);
    else if (c == 'Z')
        dprint("%-20llud", v);
    break;
case 'B':
case 'b':
case 'c':
case 'C':
    if (literal)
        ch = (uchar) dot;
    else if (get1(map, dot, &ch, 1)  < 0)
        error("%r");
    if (modifier == 'C')
        printesc(ch);
    else if (modifier == 'B' || modifier == 'b')
        dprint("%-8#lux", (long) ch);
    else
        printc(ch);
    dotinc = 1;
    break;

case 'r':
    if (literal)
        sh = (ushort) dot;
    else if (get2(map, dot, &sh) < 0)
        error("%r");
    dprint("%C", sh);
    dotinc = 2;
    break;

case 'R':
    if (literal) {
        sp = (ushort*) &dot;
        dprint("%C%C", sp[0], sp[1]);
        endline();
        dotinc = 4;
        break;
    }
    savdot=dot;
    while ((i = get2(map, dot, &sh) > 0) && sh) {
        dot=inkdot(2);
        dprint("%C", sh);
        endline();
    }
    if (i < 0)
        error("%r");
    dotinc = dot-savdot+2;
    dot=savdot;
    break;

case 's':
    if (literal) {
        cp = (uchar*) &dot;
        for (i = 0; i < 4; i++)
            buf[i] = cp[i];
        buf[i] = 0;
        dprint("%s", buf);
        endline();
        dotinc = 4;
        break;
    }
    savdot = dot;
    for(;;){
        i = 0;
        do{
            if (get1(map, dot, (uchar*)&buf[i], 1) < 0)
                error("%r");
            dot = inkdot(1);
            i++;
        }while(!fullrune(buf, i));
        if(buf[0] == 0)
            break;
        buf[i] = 0;
        dprint("%s", buf);
        endline();
    }
    dotinc = dot-savdot+1;
    dot = savdot;
    break;

case 'S':
    if (literal) {
        cp = (uchar*) &dot;
        for (i = 0; i < 4; i++)
            printesc(cp[i]);
        endline();
        dotinc = 4;
        break;
    }
    savdot=dot;
    while ((i = get1(map, dot, &ch, 1) > 0) && ch) {
        dot=inkdot(1);
        printesc(ch);
        endline();
    }
    if (i < 0)
        error("%r");
    dotinc = dot-savdot+1;
    dot=savdot;
    break;


case 'I':
case 'i':
    i = machdata->das(map, dot, modifier, buf, sizeof(buf));
    if (i < 0)
        error("%r");
    dotinc = i;
    dprint("%s\n", buf);
    break;

case 'M':
    i = machdata->hexinst(map, dot, buf, sizeof(buf));
    if (i < 0)
        error("%r");
    dotinc = i;
    dprint("%s", buf);
    if (*fp) {
        dotinc = 0;
        dprint("%48t");
    } else
        dprint("\n");
    break;

case 'f':
    /* BUG: 'f' and 'F' assume szdouble is sizeof(vlong) in the literal case */
    if (literal) {
        v = machdata->swav(dot);
        memmove(buf, &v, mach->szfloat);
    }else if (get1(map, dot, (uchar*)buf, mach->szfloat) < 0)
        error("%r");
    machdata->sftos(buf, sizeof(buf), (void*) buf);
    dprint("%s\n", buf);
    dotinc = mach->szfloat;
    break;

case 'F':
    /* BUG: 'f' and 'F' assume szdouble is sizeof(vlong) in the literal case */
    if (literal) {
        v = machdata->swav(dot);
        memmove(buf, &v, mach->szdouble);
    }else if (get1(map, dot, (uchar*)buf, mach->szdouble) < 0)
        error("%r");
    machdata->dftos(buf, sizeof(buf), (void*) buf);
    dprint("%s\n", buf);
    dotinc = mach->szdouble;
    break;

case 'n':
case 'N':
    printc('\n');
    dotinc=0;
    break;

case '"':
    dotinc=0;
    while (*fp != '"' && *fp)
        printc(*fp++);
    if (*fp)
        fp++;
    break;

case '^':
    dot=inkdot(-dotinc*fcount);
    return(fp);

case '+':
    dot=inkdot((WORD)fcount);
    return(fp);

case '-':
    dot=inkdot(-(WORD)fcount);
    return(fp);

case 'z':
    if (findsym(dot, CTEXT, &s))
        dprint("%s() ", s.name);
    printsource(dot);
    printc(EOR);
    return fp;

@




%XXX
<<[[acommand()]] switch optional command suffix character>>=
case 'm':
    if (eqcom)
        error(BADEQ); 
    cmdmap(map);
    break;

case 'L':
case 'l':
    if (eqcom)
        error(BADEQ); 
    cmdsrc(lastc, map);
    break;

case 'W':
case 'w':
    if (eqcom)
        error(BADEQ); 
    cmdwrite(lastc, map);
    break;
@


\section{Dumper commands, [[$]]}%$

<<[[command()]] switch lastcom cases>>=
case '$':
    lastcom=savecom;
    printtrace(nextchar()); 
    break;
@
%$

<<function printtrace>>=
void
printtrace(int modif)
{
    int i;
    uvlong pc, sp, link;
    ulong w;
    BKPT *bk;
    Symbol s;
    int stack;
    char *fname;
    char buf[512];

    if (cntflg==FALSE)
        cntval = -1;

    switch (modif) {
    <<[[printtrace()]] switch modif cases>>
    default:
        error("bad `$' command");
    }

}
@
%$


<<[[printtrace()]] switch modif cases>>=
case '<':
    if (cntval == 0) {
        while (readchar() != EOR)
            ;
        reread();
        break;
    }
    if (rdc() == '<')
        stack = 1;
    else {
        stack = 0;
        reread();
    }
    fname = getfname();
    redirin(stack, fname);
    break;

case '>':
    fname = getfname();
    redirout(fname);
    break;

case 'a':
    attachprocess();
    break;

case 'k':
    kmsys();
    break;

case 'q':
case 'Q':
    done();

case 'w':
    maxpos=(adrflg?adrval:MAXPOS);
    break;

case 'S':
    printsym();
    break;

case 's':
    maxoff=(adrflg?adrval:MAXOFF);
    break;

case 'm':
    printmap("? map", symmap);
    printmap("/ map", cormap);
    break;

case 0:
case '?':
    if (pid)
        dprint("pid = %d\n",pid);
    else
        prints("no process\n");
    flushbuf();

case 'r':
case 'R':
    printregs(modif);
    return;

case 'f':
case 'F':
    printfp(cormap, modif);
    return;

case 'c':
case 'C':
    tracetype = modif;
    if (machdata->ctrace) {
        if (adrflg) {
            /*
             * trace from jmpbuf for multi-threaded code.
             * assume sp and pc are in adjacent locations
             * and mach->szaddr in size.
             */
            if (geta(cormap, adrval, &sp) < 0 ||
                geta(cormap, adrval+mach->szaddr, &pc) < 0)
                    error("%r");
        } else {
            sp = rget(cormap, mach->sp);
            pc = rget(cormap, mach->pc);
        }
        if(mach->link)
            link = rget(cormap, mach->link);
        else
            link = 0;
        if (machdata->ctrace(cormap, pc, sp, link, ptrace) <= 0)
            error("no stack frame");
    }
    break;

    /*print externals*/
case 'e':
    for (i = 0; globalsym(&s, i); i++) {
        if (get4(cormap, s.value, &w) > 0)
            dprint("%s/%12t%#lux\n", s.name, w);
    }
    break;

    /*print breakpoints*/
case 'b':
case 'B':
    for (bk=bkpthead; bk; bk=bk->nxtbkpt)
        if (bk->flag) {
            symoff(buf, 512, (WORD)bk->loc, CTEXT);
            dprint(buf);
            if (bk->count != 1)
                dprint(",%d", bk->count);
            dprint(":%c %s", bk->flag == BKPTTMP ? 'B' : 'b', bk->comm);
        }
    break;

case 'M':
    fname = getfname();
    if (machbyname(fname) == 0)
        dprint("unknown name\n");;
    break;
@

\section{Sub process control commands, [[:]]}%$

<<[[command()]] switch lastcom cases>>=
case ':':
    if (!executing) { 
        executing=TRUE;
        subpcs(nextchar());
        executing=FALSE;
        lastcom=savecom;
    }
    break;
@
% when can have executing at false here?

<<function subpcs>>=
/* sub process control */

void
subpcs(int modif)
{
    int	check;
    int	runmode;
    int	keepnote;
    int	n, r;
    long line, curr;
    BKPT *bk;
    char *comptr;

    runmode=SINGLE;
    r = 0;
    keepnote=0;
    loopcnt=cntval;

    switch (modif) {
    <<[[subpcs()]] switch modif cases>>
    default:
        error("bad `:' command");
    }

    if (loopcnt>0) {
        dprint("%s: running\n", symfil);
        flush();
        r = runpcs(runmode,keepnote);
    }
    if (r)
        dprint("breakpoint%16t");
    else
        dprint("stopped at%16t");
Return:
    delbp();
    printpc();
    notes();
}
@


<<[[subpcs()]] switch modif cases>>=
/* delete breakpoint */
case 'd': 
case 'D':
    if ((bk=scanbkpt(dot)) == 0)
        error("no breakpoint set");
    bk->flag=BKPTCLR;
    return;

/* set breakpoint */
case 'b': 
case 'B':
    if (bk=scanbkpt(dot))
        bk->flag=BKPTCLR;
    for (bk=bkpthead; bk; bk=bk->nxtbkpt)
        if (bk->flag == BKPTCLR)
            break;
    if (bk==0) {
        bk = (BKPT *)malloc(sizeof(*bk));
        if (bk == 0)
            error("too many breakpoints");
        bk->nxtbkpt=bkpthead;
        bkpthead=bk;
    }
    bk->loc = dot;
    bk->initcnt = bk->count = cntval;
    bk->flag = modif == 'b' ? BKPTSET : BKPTTMP;
    check=MAXCOM-1;
    comptr=bk->comm;
    rdc();
    reread();
    do {
        *comptr++ = readchar();
    } while (check-- && lastc!=EOR);
    *comptr=0;
    if(bk->comm[0] != EOR && cntflg == FALSE)
        bk->initcnt = bk->count = HUGEINT;
    reread();
    if (check)
        return;
    error("bkpt command too long");

/* exit */
case 'k' :
case 'K':
    if (pid == 0)
        error(NOPCS);
    dprint("%d: killed", pid);
    pcsactive = 1;	/* force 'kill' ctl */
    endpcs();
    return;

/* run program */
case 'r': 
case 'R':
    endpcs();
    setup();
    runmode = CONTIN;
    break;

/* single step */
case 's': 
    if (pid == 0) {
        setup();
        loopcnt--;
    }
    runmode=SINGLE;
    keepnote=defval(1);
    break;
case 'S':
    if (pid == 0) {
        setup();
        loopcnt--;
    }
    keepnote=defval(1);
    line = pc2line(rget(cormap, mach->pc));
    n = loopcnt;
    dprint("%s: running\n", symfil);
    flush();
    for (loopcnt = 1; n > 0; loopcnt = 1) {
        r = runpcs(SINGLE, keepnote);
        curr = pc2line(dot);
        if (line != curr) {	/* on a new line of c */
            line = curr;
            n--;
        }
    }
    loopcnt = 0;
    break;

/* continue with optional note */
case 'c': 
case 'C': 
    if (pid==0)
        error(NOPCS);
    runmode=CONTIN;
    keepnote=defval(1);
    break;

/* deal with notes */
case 'n':	
    if (pid==0)
        error(NOPCS);
    n=defval(-1);
    if(n>=0 && n<nnote){
        nnote--;
        memmove(note[n], note[n+1], (nnote-n)*sizeof(note[0]));
    }
    notes();
    return;

/* halt the current process */
case 'h':	
    if (adrflg && adrval == 0) {
        if (pid == 0)
            error(NOPCS);
        ungrab();
    }
    else {
        grab();
        dprint("stopped at%16t");
        goto Return;
    }
    return;

/* continue executing the current process */
case 'x':	
    if (pid == 0)
        error(NOPCS);
    ungrab();
    return;
@

\section{Breakpoints}

\section{Addresses}

<<global adrflg>>=
int	adrflg;
@

<<global adrval>>=
// was in command.c
WORD	adrval;
@


<<[[command()]] parse possibly first address, set dot>>=
adrflg=expr(0);		/* first address */
if (adrflg){
    dot=expv;
    ditto=expv;
}
adrval=dot;
@

\section{Counts}

<<[[command()]] parse possibly count, set cntval>>=
if (rdc()==',' && expr(0)) {	/* count */
    cntflg=TRUE;
    cntval=expv;
} else {
    cntflg=FALSE;
    cntval=1;
    reread();
}
@

\section{Other commands}

<<[[command()]] switch lastcom cases>>=
case '>':
    lastcom = savecom; 
    savc=rdc();
    if (reg=regname(savc))
        rput(cormap, reg, dot);
    else	
        error("bad variable");
    break;
@

<<[[command()]] switch lastcom cases>>=
case '!':
    lastcom=savecom;
    shell(); 
    break;
@



<<[[command()]] switch lastcom cases>>=
case '\0':
    prints(DBNAME);
    break;

@
%$
% how can have this?



\chapter{Metadata Generation}

\section{Assembler}

\section{Compiler}

\section{Linker}

\chapter{Kernel Support}

\section{Core dumps and broken processes}

% when process crashes, it's still around, and can just run
% ps; db <pid> to start inspect! really useful.

\chapter{Advanced Topics}

\section{Kernel debugging}

<<global kflag>>=
bool kflag;
@

<<[[main()]] command line processing (db)>>=
case 'k':
    kflag = true;
    break;
@

<<[[main()]] locals (db)>>=
char *cpu, *p, *q;
@

<<[[main()]] when pid argument, if kflag>>=
if(kflag){
    cpu = getenv("cputype");
    if(cpu == nil){
        cpu = "386";
        dprint("$cputype not set; assuming %s\n", cpu);
    }
    p = getenv("terminal");
    if(p==nil || (p=strchr(p, ' '))==0 || p[1]==' ' || p[1]==0){
        strcpy(b1, "/386/9pc");
        dprint("missing or bad $terminal; assuming %s\n", b1);
    }else{
        p++;
        q = strchr(p, ' ');
        if(q)
            *q = '\0';
        sprint(b1, "/%s/9%s", cpu, p);
    
    }
}
@


\chapter{Conclusion}


\appendix

\chapter{Debugging}
% debugging the debugger

<<global errmsg>>=
// was static in main.c
char *errmsg;
@

<<[[main()]] in loop, handle errmsg (db)>>=
if (errmsg) {
    dprint(errmsg);
    printc('\n');
    errmsg = nil;
    exitflg = false;
}
@


<<function error>>=
/*
 * An error occurred; save the message for later printing,
 * close open files, and reset to main command loop.
 */
void
error(char *n)
{
    errmsg = n;
    iclose(0, 1);
    oclose();
    flush();
    delbp();
    ending = 0;
    longjmp(env, 1);
}
@

<<function errors>>=
void
errors(char *m, char *n)
{
    static char buf[128];

    sprint(buf, "%s: %s", m, n);
    error(buf);
}
@


\chapter{Error Managment}


%        if (syminit(fsym, &fhdr) < 0)
%            dprint("%r\n");
% lots of error(%r)

\chapter{Libc}

\chapter{Extra Code}

\ifallcode
#include "Debugger_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

