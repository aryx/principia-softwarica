Already seen some important languages and technologies:
 - assembly and its assembler
 - C and its compiler
 - scheme and its interpreter
We also covered lots of programming language features already.

Now will do ML, that has lots in comment with scheme (gc, closures).
So why? because first we'll see functional in a compilation context.
Moreover we will also add significant features: strong typing, type inference,
 ADTs, typeclasses.

Then we will do prolog.

So then we will have seen major paradigms:
 - low-level
 - imperative
 - functional
 - logic

Will do oo via scheme extension maybe, and typeclasses also offers
most of the benefits.

Each language we presented was a reasonable increment (not too small,
not too large), and the final product (ML) allow to rewrite concisely
previous parts!





Remaining:
 - concurrency
 - distribution
 - constraints
 - ...?
=> See Oz? or do erlang? or elixir?
