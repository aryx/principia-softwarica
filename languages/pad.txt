Already seen some important languages and technologies:
 - assembly and its assembler
 - C and its compiler
 - scheme and its interpreter
We also covered lots of programming language features already.

Now will do ML, that has a lot in common with scheme (gc, closures).
Why? because first we'll see a functional language in a 
compilation context (not interpreter like s9).
Moreover we will also add significant features: strong typing, type inference,
ADTs, typeclasses.

Then we will do prolog.

At this point we will have seen major paradigms:
 - low-level
 - imperative
 - functional
 - logic

We will do oo via scheme extension maybe, and typeclasses also offers
most of the benefits.

Each language we presented was a reasonable increment (not too small,
not too large), and the final product (ML) allow to rewrite concisely
previous parts!



Remaining:
 - concurrency
 - distribution
 - constraints
 - ...?
=> See Oz? or do erlang? or elixir?
