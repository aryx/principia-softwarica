We have already seen some important languages and technologies:
 - assembly and its assembler and linker
 - C and its compiler
 - scheme and its interpreter
This covers lots of programming language features already.

Now we will see ML, that has a lot in common with scheme (gc, closures).
Why? because first we'll see a functional language in a 
compilation context (not interpreter like s9).
Moreover we will also add significant features: strong typing, type inference,
algebraic data types, pattern matching, typeclasses.

Then we will do prolog.

At that point we will have seen all major paradigms:
 - low-level
 - imperative
 - functional
 - logic

We will cover object oriented programming via a scheme extension maybe.
Note that type classes offer lots of the benefits of OO.

Each language we presented was a reasonable increment (not too small,
not too large), and the final product (ML) allows to rewrite concisely
previous parts!


Remaining:
 - concurrency
 - distribution
 - constraints
 - reactive
 - ...?
=> See Oz? or erlang? or elixir?

less: could be put in ../compilers/ instead?
