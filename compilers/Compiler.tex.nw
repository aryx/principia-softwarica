\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   saw cc/pgen.c depends on gc.h! so not same category than cc/bits.c => cc2/
%   (harder to understand non layered code)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)
% - use scheck to remove deadcode useless export, or mv as forward decl
%   (harder to understand big interface files)
% - see duplication between cc.h and aa.h

%thx to this manual, better understand compilers:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * SEMI [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog to see what flows into fields
% - TODO nullify, boolify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 C Compiler
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a C compiler.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present 8c, aka kencc, from ken thompson!

% some cons though: no IL ... very imperative ... harder case to defend
% than for the other software (8a, 8l, kernel, rio)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item tiger
% not real, not C, but more educatif and better written for teaching purpose
% (actually can refer to govereau book?)
\item lcc 
%maybe better actually, but already a book on it
% also use a grammar? or handwritten?
\item compcert
% harder to understand coq :)
\item tinycc, fbcc
\item gcc
%big
\item clang
%cleaner but still very big
% nice single binary that can cross compile for multiple targets, nice
% interface (cleaner than 8c, 5c, vc, etc, interfaces are better!)
\end{itemize}

% TODO bench 8c vs gcc and clang on benchmarks!

\section{Getting started}

\section{Requirements}

% how works a compiler. Dragon book. Appel. Or other books.

%``the compiler assumes you've know your Aho and Ullmann either by'
%reading them or by working with them.''
% - charles forsith on 9fans

% comp.ps, 8c man pages, etc

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

% ken :)
% mireille ducasse, marie jo pedrono
% Aho, appel

\chapter{Overview}

\section{Compiler principles}

% from high level to low level (asm). 
% expression like x+y*z decomposed into multi mov, add, etc. Fortran!
% same for data, complex decomposed into smaller bytes, with symbolic names
%  for subparts, e.g. fields.
% statements, more structured forms than jmp.
% types! type checking!

% innovation of C vs fortran/pascal/algol? simpler?

\section{[[8c]] services}

% see all the flags, put here main flags

\section{[[helloworld.c]]}

\section{Input C language}

% mostly ANSI C. a few extension
% see K&R book

\section{Output object format}

% assembly x86 object code. Not really machine code, and not asm
% (even though can get asm via 8c -S)

% put code for helloworld.c? (at least put an arithmetic expression?)

\section{x86}

\section{Code organization}

% use a lot 386/8.out.h
% and actually stuff defined in 8.out.h are used
% exclusively by 8c e.g. enum misc3 with REGRET, REGTMP, etc

% cc.h (vs gc.h (not garbage collector, g for? nongeneric? hmmm))
% no lex (handcrafted lex.c), yacc (cc.y, y.tab.h, y.tab.c)
%  (why no lex? to avoid bootstrapping issues?)
%  mac.c = macro (included cpp)
% globals.c, utils.c, compat.c

% sub.c = subroutines, helpers to build ast (and more?)

% bits.c, 
% pickle.c

% acid.c = debugger support

% dpchk.c? pragma related? dpchk? check something? directive pragma check?

% com.c = compile (not comment), com64 for 64 bits stuff (for vlong)
%  dcl.c = declarations (dodecl, xdecl, adecl, markdcl/revertdcl, etc)
%  funct.c = ?? seems related to typestr
%  swt.c = switch? (pswt = portable part of switch handling)
%   (but then why outcode, outhist is in this file? TODO move it elsewhere!)
%  scon.c =  ? constants expr? s?

% -----------

% gc.h (g??)
% globals2.c
% list.c = fmt.c (TODO rename)
% machcap.c, omachcap.c = machine capability (attempt to have interface)

% txt.c?
% xxxgen = sgen? cgen? (pgen.c = portable part of gen? sgen? cgen?)
% mul.c, div.c = optimized code for div/mul
% peep.c = peep optimizer, on assembly!
% reg.c = register, on assembly!

% a few conventions? see glossary!

\section{Architecture overview}

% see lex.c#main()! have command line flags in comment

% lexer -> preprocessor -> parser -> ast -> visit and gen
% with optimisations done?
% no IL? register allocator? peep optimizer?
% vs tiger book?

% main -> compile -> yyparse -> yylex -> macxxx
%                            -> codgen (portable) -> gen

% ast level opti, assembly level opti

% "the compiler works by a series of tree
% transformations, informed by attributes
% attached to each node, representing
% types, notional costs, addressability,
% and other ... stuff.
% - charles forsith on 9fans

%###############################################################################

\chapter{Core Data Structures}

\section{Abstract syntax tree, [[Node]] and [[Type]]}

% vs what I have in ast_c.ml?

\subsection{[[Node]]}
% = expr + stmt + type defs + decl + func def?

% todo: LP reorg, purely internal to cc, not marshalled, so safe to reorder
% (as opposed to 8a)
<<enum node_kind>>=
enum node_kind
{
    OXXX,

    OADD,
    OADDR,
    OAND,
    OANDAND,

    OARRAY, // used for array decl and designator initializer array

    OAS,
    OASI,
    OASADD,
    OASAND,
    OASASHL,
    OASASHR,
    OASDIV,
    OASHL,
    OASHR,
    OASLDIV,
    OASLMOD,
    OASLMUL,
    OASLSHR,
    OASMOD,
    OASMUL,
    OASOR,
    OASSUB,
    OASXOR,

    OBIT,
    OBREAK,
    OCASE, // for default too, in which case Node.left is null
    OCAST,
    OCOMMA,
    OCOND,
    OCONST,
    OCONTINUE,
    ODIV,

    ODOT,

    ODOTDOT,
    ODWHILE,
    OENUM,
    OEQ,
    OFOR,

    OFUNC, // used for calls but also proto decls :(

    OGE,
    OGOTO,
    OGT,
    OHI,
    OHS,
    OIF,
    OIND,
    OINDREG,
    OINIT,
    OLABEL,

    OLDIV,
    OLE,
    OLIST, // of stmts, labels, sometimes also used for pairs, triples, etc
    OLMOD,
    OLMUL,
    OLO,
    OLS,
    OLSHR,
    OLT,

    OMOD,
    OMUL,

    ONAME,

    ONE,
    ONOT,
    OOR,
    OOROR,

    OPOSTDEC,
    OPOSTINC,
    OPREDEC,
    OPREINC,

    OPROTO,

    OREGISTER, // after parsing only?

    ORETURN,
    OSET,
    OSIGN,
    OSIZE,
    OSTRING,
    OLSTRING,
    OSTRUCT,
    OSUB,
    OSWITCH,
    OUNION,
    OUSED,
    OWHILE,

    OXOR,
    ONEG,

    OCOM,

    OPOS,

    OELEM, // field designator

    OTST,		/* used in some compilers */
    OINDEX,
    OFAS,
    OREGPAIR,
    OEXREG,

    OEND
};
@

% ONAME, ODOT, OELEM => use FNconv

% char -> byte? or actually char sometimes when use '+' ?
% hmm get some warnings though when do that, but maybe should fix those 
% warnings anyway
<<struct Node>>=
struct	Node
{
    // enum<node_kind>
    char	op;

    // option<ref_own<Node>>
    Node*	left;
    // option<ref_own<Node>>
    Node*	right;

    // for OCONST?
    // could be put in a union
    vlong	vconst;		/* non fp const */ // abused in switch?
    double	fconst;		/* fp constant */

    char*	cstring;	/* character string */ // also used for ints
    TRune*	rstring;	/* rune string */

    long	lineno;

    <<[[Node]] other fields>>
};
@
% see also prtree() in debugging section to dump the ast

% left/right used for many things, for left/right branch in e.g.
% arithmetic trees (a+b), but also for linked list (e.g. OLIST) with
% double chaining

<<constant Z>>=
#define	Z	((Node*)nil)
@




% important field! typechecking! set in parsing when can
% (e.g. for cast where have type, for return where have also spec)
<<[[Node]] other fields>>=
Type*	type;
@
% so it's more than an AST actually, have semantic info attached to it
% by other phases

% inline of type->etype? char->byte?
<<[[Node]] other fields>>=
// enum<type_kind>, inline of Node.type->etype?
char	etype;
@


% storage class
<<enum cxxx>>=
enum
{
    CXXX, // nothing specified

    CAUTO,
    CEXTERN,
    CGLOBL,
    CSTATIC,

    CLOCAL,

    CTYPEDEF,
    CTYPESTR,

    CPARAM,
    CSELEM,
    CLABEL,

    CEXREG, // extern register, kencc ext (used in kernel for mips)

    NCTYPES,
};
@
% CSTATIC vs TSTATIC vs BSTATIC
% see also cnames[] in debugging section



% for nodes that are decl? which is?
<<[[Node]] other fields>>=
// enum<cxxx>
char	class;
@


% when the node involves a symbol (entity used, field access, ONAME ODOT)
% (and should have mutual reciproque?)
<<[[Node]] other fields>>=
Sym*	sym; 
@
% see Sym later












% int -> char ... for op, hmmm
<<function new>>=
Node*
new(int t, Node *l, Node *r)
{
    Node *n;

    n = alloc(sizeof(Node));
    n->op = t;
    n->left = l;
    n->right = r;

    if(l && t != OGOTO)
        n->lineno = l->lineno;
    else if(r)
        n->lineno = r->lineno;
    else
        n->lineno = lineno;

    newflag = true;
    return n;
}
@

<<global lineno>>=
long	lineno;
@


<<global nearln>>=
long	nearln;
@

<<function new1>>=
Node*
new1(int o, Node *l, Node *r)
{
    Node *n;

    n = new(o, l, r);
    n->lineno = nearln;
    return n;
}
@





%TODO archi independent  part for code generation, ex nod1.reg?

<<[[Node]] other fields>>=
void*	label;

long	pc;
int	reg;
long	xoffset;


// (ab)used as bool for marker of label def (true) vs use (false),
// FNX special value, register allocation value, etc
char	complex; 

char	scale;
@




\subsection{[[Type]]}

% split? hmm but would not work with enum<bxxx> then, ugly but
% because of the way they handle type/qualifier/storage they all
% have to be in the same enum (ugly)
<<enum type_kind>>=
enum type_kind
{
    TXXX,

    // type cases
    TCHAR,
    TUCHAR,
    TSHORT,
    TUSHORT,
    TINT,
    TUINT,
    TLONG,
    TULONG,
    TVLONG,
    TUVLONG,
    TFLOAT,
    TDOUBLE,

    TIND,
    TFUNC,
    TARRAY,
    TVOID,
    TSTRUCT,
    TUNION,
    TENUM,

    TDOT, // ??
    NTYPE,

    // storage class cases
    TAUTO	= NTYPE,

    TEXTERN,
    TSTATIC,
    TTYPEDEF, // ugly, not really a storage class
    TTYPESTR,
    TREGISTER,

    // qualifier cases
    TCONSTNT,
    TVOLATILE,

    // other cases
    TUNSIGNED,
    TSIGNED,

    // ????
    TFILE,
    TOLD,

    NALLTYPES,

    /* adapt size of Rune to target system's size */
    TRUNE = sizeof(TRune)==4? TUINT: TUSHORT,
};
@
% see also qnames[] for debugging




% see also enum bxxx which is used only in grammar I think,
% and seems to be a 64 bits bitset of the types above

% char -> byte? but get some warnings (but we should fix that too)
<<struct Type>>=
struct	Type
{
    // enum<type_kind>  (the type cases only?)
    char	etype;

    // option<ref_own<Type>, e.g. for '*int' have TIND -link-> TINT
    Type*	link;

    // ??
    Type*	down;

    long	lineno;

    <<[[Type]] other fields>>
};
@
%link is empty at first for structure tag forward decl, but set when
% have the actual structure def fields
% contain storage class info too? and qualifier too?

% for TFUNC, how is the return and how are the parameters? via link and
% down?

% gxxx for 'garbage' but should be renamed qualifier
<<enum gxxx>>=
enum gxxx
{
    GXXX		= 0,
    GCONSTNT	= 1<<0,
    GVOLATILE	= 1<<1,

    NGTYPES		= 1<<2,
    GINCOMPLETE	= 1<<2,
};
@
% >> >> >> >>
% see also gnames in debugging section




%// garbage? rename qualifier?
<<[[Type]] other fields>>=
char	garb;
@

<<[[Node]] other fields>>=
// enum<gxxx>
char	garb;
@


% storage class is not there! should be in Decl instead?


% when type involves a symbol, e.g. for tags in struct/union/enum
<<[[Type]] other fields>>=
Sym*	sym;
@



<<constant T>>=
#define	T	((Type*)nil)
@

% constructor
<<function typ>>=
Type*
typ(int et, Type *d)
{
    Type *t;

    t = alloc(sizeof(Type));
    t->etype = et;
    t->link = d;
    t->down = T;
    t->garb = 0;
    t->sym = S;

    t->width = ewidth[et];
    t->offset = 0;
    t->shift = 0;
    t->nbits = 0;

    return t;
}
@
% see Size section for ewidth, LP split!

<<function copytyp>>=
Type*
copytyp(Type *t)
{
    Type *nt;

    nt = typ(TXXX, T); // could just do alloc(sizeof(Type))
    *nt = *t;
    return nt;
}
@


<<global types>>=
Type*	types[NTYPE];
@


<<[[cinit()]] types initialization>>=
types[TXXX] = T;

types[TCHAR] = typ(TCHAR, T);
types[TUCHAR] = typ(TUCHAR, T);
types[TSHORT] = typ(TSHORT, T);
types[TUSHORT] = typ(TUSHORT, T);
types[TINT] = typ(TINT, T);
types[TUINT] = typ(TUINT, T);
types[TLONG] = typ(TLONG, T);
types[TULONG] = typ(TULONG, T);
types[TVLONG] = typ(TVLONG, T);
types[TUVLONG] = typ(TUVLONG, T);
types[TFLOAT] = typ(TFLOAT, T);
types[TDOUBLE] = typ(TDOUBLE, T);
types[TVOID] = typ(TVOID, T);
types[TENUM] = typ(TENUM, T);
types[TFUNC] = typ(TFUNC, types[TINT]);
types[TIND] = typ(TIND, types[TVOID]);
@


<<global tfield>>=
Type*	tfield;
@
% and init code in cinit or tinit

<<global tufield>>=
Type*	tufield;
@



% see also typexxx set in Typechecking section


<<function sametype>>=
bool
sametype(Type *t1, Type *t2)
{

    if(t1 == t2)
        return true;
    return rsametype(t1, t2, 5, 1);
}
@

% n = depth? so equal modulo a certain depth?? hmmm
<<function rsametype>>=
bool
rsametype(Type *t1, Type *t2, int n, int f)
{
    int et;

    n--;
    for(;;) {
        if(t1 == t2)
            return true;
        if(t1 == T || t2 == T)
            return false;
        if(n <= 0)
            return true;
        et = t1->etype;
        if(et != t2->etype)
            return false;

        if(et == TFUNC) {
            if(!rsametype(t1->link, t2->link, n, 0))
                return false;
            t1 = t1->down;
            t2 = t2->down;
            while(t1 != T && t2 != T) {
                if(t1->etype == TOLD) {
                    t1 = t1->down;
                    continue;
                }
                if(t2->etype == TOLD) {
                    t2 = t2->down;
                    continue;
                }
                while(t1 != T || t2 != T) {
                    if(!rsametype(t1, t2, n, 0))
                        return false;
                    t1 = t1->down;
                    t2 = t2->down;
                }
                break;
            }
            return true;
        }
        if(et == TARRAY)
            if(t1->width != t2->width && t1->width != 0 && t2->width != 0)
                return false;
        if(typesu[et]) {
            if(t1->link == T)
                snap(t1);
            if(t2->link == T)
                snap(t2);
            if(t1 != t2 && t1->link == T && t2->link == T){
                /* structs with missing or different tag names aren't considered equal */
                if(t1->tag == nil || t2->tag == nil ||
                   strcmp(t1->tag->name, t2->tag->name) != 0)
                    return false;
            }
            t1 = t1->link;
            t2 = t2->link;
            for(;;) {
                if(t1 == t2)
                    return true;
                if(!rsametype(t1, t2, n, 0))
                    return false;
                t1 = t1->down;
                t2 = t2->down;
            }
        }
        t1 = t1->link;
        t2 = t2->link;
        if((f || !debug['V']) && et == TIND) {
            if(t1 != T && t1->etype == TVOID)
                return true;
            if(t2 != T && t2->etype == TVOID)
                return true;
        }
    }
}
@

<<function snap>>=
void
snap(Type *t)
{
    if(typesu[t->etype])
    if(t->link == T && t->tag && t->tag->suetag) {
        t->link = t->tag->suetag->link;
        t->width = t->tag->suetag->width;
    }
}
@

%-------------------



<<[[Type]] other fields>>=
long	width; // ewidth[Type.etype]

long	offset;
schar	shift;
char	nbits;
@

%-------------------

<<[[Type]] other fields>>=
Funct*	funct;
@

<<struct Funct>>=
struct	Funct
{
    Sym*	sym[OEND];
    Sym*	castto[NTYPE];
    Sym*	castfr[NTYPE];
};
@

<<function isfunct>>=
int
isfunct(Node *n)
{
    Type *t, *t1;
    Funct *f;
    Node *l;
    Sym *s;
    int o;

    o = n->op;
    if(n->left == Z)
        goto no;
    t = n->left->type;
    if(t == T)
        goto no;
    f = t->funct;

    switch(o) {
    case OAS:	// put cast on rhs
    case OASI:
    case OASADD:
    case OASAND:
    case OASASHL:
    case OASASHR:
    case OASDIV:
    case OASLDIV:
    case OASLMOD:
    case OASLMUL:
    case OASLSHR:
    case OASMOD:
    case OASMUL:
    case OASOR:
    case OASSUB:
    case OASXOR:
        if(n->right == Z)
            goto no;
        t1 = n->right->type;
        if(t1 == T)
            goto no;
        if(t1->funct == f)
            break;

        l = new(OXXX, Z, Z);
        *l = *n->right;

        n->right->left = l;
        n->right->right = Z;
        n->right->type = t;
        n->right->op = OCAST;

        if(!isfunct(n->right))
            prtree(n, "isfunc !");
        break;

    case OCAST:	// t f(T) or T f(t)
        t1 = n->type;
        if(t1 == T)
            goto no;
        if(f != nil) {
            s = f->castfr[t1->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        f = t1->funct;
        if(f != nil) {
            s = f->castto[t->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        goto no;
    }

    if(f == nil)
        goto no;
    s = f->sym[o];
    if(s == S)
        goto no;

    /*
     * the answer is yes,
     * now we rewrite the node
     * and give diagnostics
     */
    switch(o) {
    default:
        diag(n, "isfunct op missing %O\n", o);
        goto bad;

    case OADD:	// T f(T, T)
    case OAND:
    case OASHL:
    case OASHR:
    case ODIV:
    case OLDIV:
    case OLMOD:
    case OLMUL:
    case OLSHR:
    case OMOD:
    case OMUL:
    case OOR:
    case OSUB:
    case OXOR:

    case OEQ:	// int f(T, T)
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLE:
    case OLO:
    case OLS:
    case OLT:
    case ONE:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, n->left, n->right);
        break;

    case OAS:	// structure copies done by the compiler
    case OASI:
        goto no;

    case OASADD:	// T f(T*, T)
    case OASAND:
    case OASASHL:
    case OASASHR:
    case OASDIV:
    case OASLDIV:
    case OASLMOD:
    case OASLMUL:
    case OASLSHR:
    case OASMOD:
    case OASMUL:
    case OASOR:
    case OASSUB:
    case OASXOR:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, new(OADDR, n->left, Z), n->right);
        break;

    case OPOS:	// T f(T)
    case ONEG:
    case ONOT:
    case OCOM:
        n->right = n->left;
        break;


    }

build:
    l = new(ONAME, Z, Z);
    l->sym = s;
    l->type = s->type;
    l->etype = s->type->etype;
    l->xoffset = s->offset;
    l->class = s->class;
    tcomo(l, 0);

    n->op = OFUNC;
    n->left = l;
    n->type = l->type->link;
    if(tcompat(n, T, l->type, tfunct))
        goto bad;
    if(tcoma(n->left, n->right, l->type->down, 1))
        goto bad;
    return 1;

no:
    return 0;

bad:
    diag(n, "cant rewrite typestr for op %O\n", o);
    prtree(n, "isfunct");
    n->type = T;
    return 1;
}
@



\section{Symbol table, [[Sym]] and [[hash]]}
% similar to Assembler. Diffs?
% another symbol table!

<<struct Sym>>=
struct	Sym
{
    // for? keywords? locals? parameters? struct/union? all names? fields?
    // macros
    char	*name;

    long	varlineno;

    <<[[Sym]] other fields>>

    // Extra
    <<[[Sym]] extra fields>>
};
@


<<constant NHASH>>=
#define	NHASH		1024
@

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@

<<constant S>>=
#define	S	((Sym*)nil)
@





<<constant NSYMB>>=
#define	NSYMB		1500
@

<<global symb>>=
char	symb[NSYMB];
@


<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    ulong h;
    char *p;
    int c, n;

    h = 0;
    for(p=symb; *p;) {
        h = h * 3;
        h += *p++;
    }
    n = (p - symb) + 1;
    if((long)h < 0)
        h = ~h;
    h %= NHASH;

    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(strcmp(s->name, symb) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(n);
    memmove(s->name, symb, n);

    strcpy(s->name, symb);
    s->link = hash[h];
    hash[h] = s;
    syminit(s);

    return s;
}
@


<<[[Sym]] other fields>>=
Type*	type;
// enum<cxxx>?
char	class;
@
% similar to Node.type Decl.type, and now Sym.type

<<[[Sym]] other fields>>=
ushort	block;
@
% see also Decl.block


% for cpp macro
<<[[Sym]] other fields>>=
char*	macro;
@

% see also later suetag for tag.
% how handle namespace? can have struct x x;
% it can be the same symbol, but in a struct context we will use
% Sym.suetag, in other context Sym.type!
% same for Sym.sueblock vs Sym.block

<<function syminit>>=
void
syminit(Sym *s)
{
    s->lexical = LNAME;
    s->block = 0;
    s->offset = 0;

    s->type = T;
    s->suetag = T;

    s->class = CXXX;
    s->aused = false;
    s->sig = SIGNONE;
}
@

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@














%???
<<[[Sym]] other fields>>=
long	offset;

vlong	vconst;
double	fconst;

ushort	lexical;

char	sym;
@


\section{Nested scope, [[Decl]]}

% block, nested language

<<enum dxxx>>=
enum dxxx
{
    DMARK,

    DAUTO,
    DSUE, // struct/union/enum?
    DLABEL,
};
@
% DAUTO, TAUTO, LAUTO, CAUTO, hmmm

% for? 
% - labels
% locals? func?, params? typedefs? all entities?
<<struct Decl>>=
struct	Decl
{
    Sym*	sym;

    // enum<dxxx>
    short	val;

    Type*	type;
    // enum<cxxx> storage class
    char	class;

    long	varlineno;

    <<[[Decl]] other fields>>

    // Extra fields
    <<[[Decl]] extra fields>>
};
@


% stack because nested scopes
<<global dclstack>>=
// list<ref_own<Decl>> (next = Decl.link)
Decl*	dclstack;
@
% but should have a list of list?
% ugly but do ia via DMARK

<<[[Decl]] extra fields>>=
// list<ref_own<Decl> of dclstack
Decl*	link;
@

<<constant D>>=
#define	D	((Decl*)nil)
@

<<function push>>=
Decl*
push(void)
{
    Decl *d;

    d = alloc(sizeof(Decl));
    d->link = dclstack;
    dclstack = d;
    return d;
}
@


% save old value of a symbol, will be restored by revertdcl
<<function push1>>=
Decl*
push1(Sym *s)
{
    Decl *d;

    d = push();
    d->sym = s;
    d->val = DAUTO;
    d->type = s->type;
    d->class = s->class;
    d->offset = s->offset;
    d->block = s->block;
    d->varlineno = s->varlineno;
    d->aused = s->aused;
    return d;
}
@



% nested language! block number, to allow multiple blocks to use
% similar local names
<<[[Decl]] other fields>>=
ushort	block;
@
% where does dealloc things? e.g. end of functions all labels
% attached to Sym of that name should be freed



% ????
<<[[Decl]] other fields>>=
long	offset;
@






% for statements, but also for structs

<<global blockno>>=
int	blockno;
@

<<global autobn>>=
int	autobn;
@

%autoffset?

<<function markdcl>>=
//@Scheck: used by cc.y
void markdcl(void)
{
    Decl *d;

    blockno++;

    d = push();

    d->val = DMARK;
    d->offset = autoffset;
    d->block = autobn;

    autobn = blockno;
}
@

% means end of scope so need to revert the decl of all local
% entities? why return a node?
% related: dodecl()?
<<function revertdcl>>=
//@Scheck: used by cc.y
Node* revertdcl(void)
{
    Decl *d;
    Sym *s;
    Node *n, *n1;

    n = Z;
    for(;;) {
        d = dclstack;
        if(d == D) {
            diag(Z, "pop off dcl stack");
            break;
        }
        dclstack = d->link;

        s = d->sym;
        switch(d->val) {
        case DMARK:
            autoffset = d->offset;
            autobn = d->block;
            return n;

        case DAUTO:
            if(debug['d'])
                print("revert1 \"%s\"\n", s->name);

            // TODO LP split!
            if(s->aused == false) {
                nearln = s->varlineno;
                if(s->class == CAUTO)
                    warn(Z, "auto declared and not used: %s", s->name);
                if(s->class == CPARAM)
                    warn(Z, "param declared and not used: %s", s->name);
            }

            if(s->type && (s->type->garb & GVOLATILE)) {
                n1 = new(ONAME, Z, Z);
                n1->sym = s;
                n1->type = s->type;
                n1->etype = TVOID;
                if(n1->type != T)
                    n1->etype = n1->type->etype;
                n1->xoffset = s->offset;
                n1->class = s->class;

                n1 = new(OADDR, n1, Z);
                n1 = new(OUSED, n1, Z);
                if(n == Z)
                    n = n1;
                else
                    n = new(OLIST, n1, n);
            }

            // restore
            s->type = d->type;
            s->class = d->class;
            s->offset = d->offset;
            s->block = d->block;
            s->varlineno = d->varlineno;
            s->aused = d->aused;

            break;

        case DSUE:
            if(debug['d'])
                print("revert2 \"%s\"\n", s->name);

            s->suetag = d->type;
            s->sueblock = d->block;

            break;

        case DLABEL:
            if(debug['d'])
                print("revert3 \"%s\"\n", s->name);

            if(s->label && s->label->addable == 0)
                warn(s->label, "label declared and not used \"%s\"", s->name);
            s->label = Z;
            break;
        }
    }
    return n;
}
@

\section{[[Token]]}

<<union yacc>>=
%union  {
    Sym*    sym;
    vlong   vval;
    double  dval;
    struct
    {
        char*   s;
        long    l;
    } sval;

   <<[[union yacc]] other fields>>
}
@

% from cc.y
<<token declarations>>=
%token  <sym>   LNAME LTYPE
%token  <vval>  LCONST LLCONST LUCONST LULCONST LVLCONST LUVLCONST
%token  <dval>  LFCONST LDCONST
%token  <sval>  LSTRING LLSTRING
@

<<token declarations>>=
%token  LAUTO LBREAK LCASE LCHAR LCONTINUE LDEFAULT LDO
%token  LDOUBLE LELSE LEXTERN LFLOAT LFOR LGOTO
%token  LIF LINT LLONG LREGISTER LRETURN LSHORT LSIZEOF LUSED
%token  LSTATIC LSTRUCT LSWITCH LTYPEDEF LTYPESTR LUNION LUNSIGNED
%token  LWHILE LVOID LENUM LSIGNED LCONSTNT LVOLATILE LSET LSIGNOF
%token  LRESTRICT LINLINE
@

% LXXX  Lexer XXX? Lexeme XXX?
% so have LDOUBLE and TDOUBLE


% seems used by sub.c simpleg()
<<[[union yacc]] other fields>>=
long    lval;
@


\section{Assembly output, [[Prog]] and [[p]]}

% see also opcode and operand_kind in Assembler.tex.nw
% (and Aconv, Rconv, Dconv, ... in this file)

% see also enum misc3 of 8.out.h with REGARG, REGRET, REGSP, REGTMP

<<struct Prog>>=
struct	Prog
{
    // enum<opcode>, from 8.out.h
    short	as;

    Adr	from;
    Adr	to;

    long	lineno;

    // Extra
    <<[[Prog]] extra fields>>
};
@

<<[[Prog]] extra fields>>=
Prog*	link;
@

<<constant P>>=
#define	P	((Prog*)nil)
@


<<struct Adr>>=
struct	Adr
{
    long	offset;
    double	dval;
    char	sval[NSNAME];
    Sym*	sym;

    uchar	type;
    uchar	index;
    uchar	etype;
    uchar	scale;	/* doubles as width in DATA op */
};
@

<<constant A>>=
#define	A	((Adr*)nil)
@


<<global zprog>>=
Prog	zprog;
@


<<global pc>>=
long	pc;
@

% current? see nextpc()?
<<global p>>=
Prog*	p;
@

<<global firstp>>=
Prog*	firstp;
@

<<global lastp>>=
Prog*	lastp;
@


<<function nextpc>>=
void
nextpc(void)
{

    p = alloc(sizeof(Prog));
    *p = zprog;
    p->lineno = nearln;
    pc++;

    if(firstp == P) {
        firstp = p;
        lastp = p;
        return;
    }
    lastp->link = p;
    lastp = p;
}
@

\chapter{[[main()]]}

<<global thechar>>=
int	thechar;
@

<<global thestring>>=
char*	thestring;
@



<<global outfile>>=
char*	outfile;
@

% not put here: -g (in cgen()) -G (in gen())

<<function main>>=
/*
 * known debug flags
 *	-a		acid declaration output
 *	-A		!B
 *	-B		non ANSI
 *	-d		print declarations
 *	-D name		define
 *	-F		format specification check
 *	-i		print initialization
 *	-I path		include
 *	-l		generate little-endian code
 *	-L		print every NAME symbol
 *	-M		constant multiplication
 *	-m		print add/sub/mul trees
 *	-n		print acid to file (%.c=%.acid) (with -a or -aa)
 *	-o file		output file
 *	-p		use standard cpp ANSI preprocessor (not on windows)
 *	-r		print registerization
 *	-s		print structure offsets (with -a or -aa)
 *	-S		print assembly
 *	-t		print type trees
 *	-V		enable void* conversion warnings
 *	-v		verbose printing
 *	-w		print warnings
 *	-X		abort on error
 *	-.		Inhibit search for includes in source directory
 */

//@Scheck: not dead, entry point :)
void main(int argc, char *argv[])
{
    char **defs, **np, *p;
    int nproc, nout, status, i, c, ndef, maxdef;

    memset(debug, 0, sizeof(debug));

    tinit();
    cinit();
    ginit();
    arginit();

    profileflg = true;	/* #pragma can turn it off */
    tufield = simplet((1L<<tfield->etype) | BUNSIGNED);
    maxdef = 0;
    ndef = 0;
    outfile = nil;
    defs = nil;
    setinclude(".");

    ARGBEGIN {
    case 'o':
        outfile = ARGF();
        break;

    case 'D':
        p = ARGF();
        if(p) {
            // realloc, growing array
            if(ndef >= maxdef){
                maxdef += 50;
                np = alloc(maxdef * sizeof *np);
                if(defs != nil)
                    memmove(np, defs, (maxdef - 50) * sizeof *np);
                defs = np;
            }
            defs[ndef++] = p;
            dodefine(p);
        }
        break;

    case 'I':
        p = ARGF();
        if(p)
            setinclude(p);
        break;

    case 'l':			/* for little-endian mips */
        if(thechar != 'v'){
            print("can only use -l with vc");
            errorexit();
        }
        thechar = '0';
        thestring = "spim";
        break;

    default:
        c = ARGC();
        if(c >= 0 && c < sizeof(debug))
            debug[c]++;
        break;


    } ARGEND

    if(argc < 1 && outfile == nil) {
        print("usage: %cc [-options] files\n", thechar);
        errorexit();
    }

    if(argc > 1) {
        nproc = 1;
        /*
         * if we're writing acid to standard output, don't compile
         * concurrently, to avoid interleaving output.
         */
        if(((!debug['a'] && !debug['Z']) || debug['n']) &&
            (p = getenv("NPROC")) != nil)
            nproc = atol(p);	/* */
        c = 0;
        nout = 0;
        for(;;) {
            while(nout < nproc && argc > 0) {
                i = fork();
                if(i < 0) {
                    i = mywait(&status);
                    if(i < 0) {
                        print("cannot create a process\n");
                        errorexit();
                    }
                    if(status)
                        c++;
                    nout--;
                    continue;
                }
                if(i == 0) {
                    fprint(2, "%s:\n", *argv);
                    if (compile(*argv, defs, ndef))
                        errorexit();
                    exits(0);
                }
                nout++;
                argc--;
                argv++;
            }
            i = mywait(&status);
            if(i < 0) {
                if(c)
                    errorexit();
                exits(0);
            }
            if(status)
                c++;
            nout--;
        }
    }

    if(argc == 0)
        c = compile("stdin", defs, ndef);
    else
        c = compile(argv[0], defs, ndef);

    if(c)
        errorexit();
    exits(0);
}
@

<<global outbuf>>=
Biobuf	outbuf;
@

<<global diagbuf>>=
Biobuf	diagbuf;
@



<<function compile>>=
int
compile(char *file, char **defs, int ndef)
{
    char ofile[400], incfile[20];
    char *p, **av, opt[256];
    int i, c, fd[2];
    static int first = 1;

    strcpy(ofile, file);
    p = utfrrune(ofile, pathchar());
    if(p) {
        *p++ = 0;
        if(!debug['.'])
            include[0] = strdup(ofile);
    } else
        p = ofile;

    if(outfile == nil) {
        outfile = p;
        if(outfile) {
            if(p = utfrrune(outfile, '.'))
                if(p[1] == 'c' && p[2] == 0)
                    p[0] = 0;
            p = utfrune(outfile, 0);
            if(debug['a'] && debug['n'])
                strcat(p, ".acid");
            else if(debug['Z'] && debug['n'])
                strcat(p, "_pickle.c");
            else {
                p[0] = '.';
                p[1] = thechar;
                p[2] = 0;
            }
        } else
            outfile = "/dev/null";
    }

    if(p = getenv("INCLUDE")) {
        setinclude(p);
    } else {
        if(systemtype(Plan9)) {
            sprint(incfile, "/%s/include", thestring);
            setinclude(strdup(incfile));
            setinclude("/sys/include");
        }
    }
    if (first)
        Binit(&diagbuf, 1, OWRITE);
    /*
     * if we're writing acid to standard output, don't keep scratching
     * outbuf.
     */
    if((debug['a'] || debug['Z']) && !debug['n']) {
        if (first) {
            outfile = nil;
            Binit(&outbuf, dup(1, -1), OWRITE);
            dup(2, 1);
        }
    } else {
        c = mycreat(outfile, 0664);
        if(c < 0) {
            diag(Z, "cannot open %s - %r", outfile);
            outfile = nil;
            errorexit();
        }
        Binit(&outbuf, c, OWRITE);
    }
    newio();
    first = 0;

    <<[[compile()]] use ANSI preprocessor>>
    else {
        if(strcmp(file, "stdin") == 0)
            newfile(file, 0);
        else
            newfile(file, -1);
    }
    yyparse();
    if(!debug['a'] && !debug['Z'])
        gclean();
    return nerrors;
}
@

% main -> compile -> yyparse -> yylex -> macxxx
%                            -> codgen (portable) -> gen






<<function cinit>>=
void
cinit(void)
{
    Sym *s;
    int i;
    Type *t;

    nerrors = 0;
    lineno = 1;
    iostack = I;
    iofree = I;
    peekc = IGN;
    nhunk = 0;

    <<[[cinit()]] types initialization>>

    for(i=0; i<NHASH; i++)
        hash[i] = S;
    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        s->lexical = itab[i].lexical;
        if(itab[i].type != 0)
            s->type = types[itab[i].type];
    }

    blockno = 0;
    autobn = 0;
    autoffset = 0;

    t = typ(TARRAY, types[TCHAR]);
    t->width = 0;
    symstring = slookup(".string");
    symstring->class = CSTATIC;
    symstring->type = t;

    t = typ(TARRAY, types[TCHAR]);
    t->width = 0;

    nodproto = new(OPROTO, Z, Z);
    dclstack = D;

    pathname = allocn(pathname, 0, 100);
    if(getwd(pathname, 99) == 0) {
        pathname = allocn(pathname, 100, 900);
        if(getwd(pathname, 999) == 0)
            strcpy(pathname, "/???");
    }
    <<[[cinit()]] fmtinstall>>
}
@


\chapter{Input}
% similar to Assembler, could reuse

% lineno in Node section

<<global peekc>>=
int	peekc;
@

<<constant EOF>>=
#define	EOF	(-1)
@

<<constant IGN>>=
#define	IGN	(-2)
@

\section{Files managment}

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

<<struct Io>>=
struct	Io
{
    char	b[BUFSIZ];

    short	f;

    char*	p;
    short	c;

    Io*	link;
};
@

<<global iostack>>=
Io*	iostack;
@

<<global iofree>>=
Io*	iofree;
@

<<global ionext>>=
Io*	ionext;
@

<<constant I>>=
#define	I	((Io*)nil)
@


<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        i = alloc(sizeof(*i));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@

<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    if(debug['e'])
        print("%L: %s\n", lineno, s);

    i = ionext;
    i->link = iostack;
    iostack = i;
    i->f = f;
    if(f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%cc: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

\section{Buffer managment}

<<struct Fi>>=
struct Fi
{
    char*	p;
    int	c;
};
@

<<global fi>>=
struct Fi fi;
@

<<function GETC>>=
#define	GETC()	((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff))
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0] & 0xff;

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++ & 0xff;
}
@

\chapter{Lexing}

% why not using lex? why handwritten?

\section{[[yylex()]]}

<<constant ESC>>=
#define	ESC	(Runemask+1)		/* Rune flag: a literal byte */
@


<<function yylex>>=
//@Scheck: not dead, called by yyparse
long yylex(void)
{
    vlong vv;
    long c, c1, t;
    char *cp;
    Rune rune;
    Sym *s;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c >= Runeself) {
        /*
         * extension --
         *	all multibyte runes are alpha
         */
        cp = symb;
        goto talph;
    }
    if(isspace(c)) {
        if(c == '\n')
            lineno++;
        goto l0;
    }
    if(isalpha(c)) {
        cp = symb;
        if(c != 'L')
            goto talph;
        *cp++ = c;
        c = GETC();
        if(c == '\'') {
            /* L'x' */
            c = escchar('\'', 1, 0);
            if(c == EOF)
                c = '\'';
            c1 = escchar('\'', 1, 0);
            if(c1 != EOF) {
                yyerror("missing '");
                peekc = c1;
            }
            yylval.vval = convvtox(c, TRUNE);
            return LUCONST;
        }
        if(c == '"') {
            goto caselq;
        }
        goto talph;
    }
    if(isdigit(c))
        goto tnum;
    switch(c)
    {

    case EOF:
        peekc = EOF;
        return -1;

    case '_':
        cp = symb;
        goto talph;

    case '#':
        domacro();
        goto l0;

    case '.':
        c1 = GETC();
        if(isdigit(c1)) {
            cp = symb;
            *cp++ = c;
            c = c1;
            c1 = 0;
            goto casedot;
        }
        break;

    case '"':
        strcpy(symb, "\"<string>\"");
        cp = alloc(0);
        c1 = 0;

        /* "..." */
        for(;;) {
            c = escchar('"', 0, 1);
            if(c == EOF)
                break;
            if(c & ESC) {
                cp = allocn(cp, c1, 1);
                cp[c1++] = c;
            } else {
                rune = c;
                c = runelen(rune);
                cp = allocn(cp, c1, c);
                runetochar(cp+c1, &rune);
                c1 += c;
            }
        }
        yylval.sval.l = c1;
        do {
            cp = allocn(cp, c1, 1);
            cp[c1++] = 0;
        } while(c1 & MAXALIGN);
        yylval.sval.s = cp;
        return LSTRING;

    caselq:
        /* L"..." */
        strcpy(symb, "\"L<string>\"");
        cp = alloc(0);
        c1 = 0;
        for(;;) {
            c = escchar('"', 1, 0);
            if(c == EOF)
                break;
            cp = allocn(cp, c1, sizeof(TRune));
            *(TRune*)(cp + c1) = c;
            c1 += sizeof(TRune);
        }
        yylval.sval.l = c1;
        do {
            cp = allocn(cp, c1, sizeof(TRune));
            *(TRune*)(cp + c1) = 0;
            c1 += sizeof(TRune);
        } while(c1 & MAXALIGN);
        yylval.sval.s = cp;
        return LLSTRING;

    case '\'':
        /* '.' */
        c = escchar('\'', 0, 0);
        if(c == EOF)
            c = '\'';
        c1 = escchar('\'', 0, 0);
        if(c1 != EOF) {
            yyerror("missing '");
            peekc = c1;
        }
        vv = c;
        yylval.vval = convvtox(vv, TUCHAR);
        if(yylval.vval != vv)
            yyerror("overflow in character constant: 0x%lx", c);
        else
        if(c & 0x80){
            nearln = lineno;
            warn(Z, "sign-extended character constant");
        }
        yylval.vval = convvtox(vv, TCHAR);
        return LCONST;

    case '/':
        c1 = GETC();
        if(c1 == '*') {
            for(;;) {
                c = getr();
                while(c == '*') {
                    c = getr();
                    if(c == '/')
                        goto l0;
                }
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '/') {
            for(;;) {
                c = getr();
                if(c == '\n')
                    goto l0;
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '=')
            return LDVE;
        break;

    case '*':
        c1 = GETC();
        if(c1 == '=')
            return LMLE;
        break;

    case '%':
        c1 = GETC();
        if(c1 == '=')
            return LMDE;
        break;

    case '+':
        c1 = GETC();
        if(c1 == '+')
            return LPP;
        if(c1 == '=')
            return LPE;
        break;

    case '-':
        c1 = GETC();
        if(c1 == '-')
            return LMM;
        if(c1 == '=')
            return LME;
        if(c1 == '>')
            return LMG;
        break;

    case '>':
        c1 = GETC();
        if(c1 == '>') {
            c = LRSH;
            c1 = GETC();
            if(c1 == '=')
                return LRSHE;
            break;
        }
        if(c1 == '=')
            return LGE;
        break;

    case '<':
        c1 = GETC();
        if(c1 == '<') {
            c = LLSH;
            c1 = GETC();
            if(c1 == '=')
                return LLSHE;
            break;
        }
        if(c1 == '=')
            return LLE;
        break;

    case '=':
        c1 = GETC();
        if(c1 == '=')
            return LEQ;
        break;

    case '!':
        c1 = GETC();
        if(c1 == '=')
            return LNE;
        break;

    case '&':
        c1 = GETC();
        if(c1 == '&')
            return LANDAND;
        if(c1 == '=')
            return LANDE;
        break;

    case '|':
        c1 = GETC();
        if(c1 == '|')
            return LOROR;
        if(c1 == '=')
            return LORE;
        break;

    case '^':
        c1 = GETC();
        if(c1 == '=')
            return LXORE;
        break;

    default:
        return c;
    }
    peekc = c1;
    return c;

talph:
    /*
     * cp is set to symb and some
     * prefix has been stored
     */
    for(;;) {
        if(c >= Runeself) {
            for(c1=0;;) {
                cp[c1++] = c;
                if(fullrune(cp, c1))
                    break;
                c = GETC();
            }
            cp += c1;
            c = GETC();
            continue;
        }
        if(!isalnum(c) && c != '_')
            break;
        *cp++ = c;
        c = GETC();
    }
    *cp = 0;
    if(debug['L'])
        print("%L: %s\n", lineno, symb);
    peekc = c;
    s = lookup();
    if(s->macro) {
        newio();
        cp = ionext->b;
        macexpand(s, cp);
        pushio();
        ionext->link = iostack;
        iostack = ionext;
        fi.p = cp;
        fi.c = strlen(cp);
        if(peekc != IGN) {
            cp[fi.c++] = peekc;
            cp[fi.c] = 0;
            peekc = IGN;
        }
        goto l0;
    }
    yylval.sym = s;
    if(s->class == CTYPEDEF || s->class == CTYPESTR)
        return LTYPE;
    return s->lexical;

tnum:
    c1 = 0;
    cp = symb;
    if(c != '0') {
        c1 |= Numdec;
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            goto dc;
        }
    }
    *cp++ = c;
    c = GETC();
    if(c == 'x' || c == 'X')
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            if(c >= 'a' && c <= 'f')
                continue;
            if(c >= 'A' && c <= 'F')
                continue;
            if(cp == symb+2)
                yyerror("malformed hex constant");
            goto ncu;
        }
    if(c < '0' || c > '7')
        goto dc;
    for(;;) {
        if(c >= '0' && c <= '7') {
            *cp++ = c;
            c = GETC();
            continue;
        }
        goto ncu;
    }

dc:
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;

ncu:
    if((c == 'U' || c == 'u') && !(c1 & Numuns)) {
        c = GETC();
        c1 |= Numuns;
        goto ncu;
    }
    if((c == 'L' || c == 'l') && !(c1 & Numvlong)) {
        c = GETC();
        if(c1 & Numlong)
            c1 |= Numvlong;
        c1 |= Numlong;
        goto ncu;
    }
    *cp = 0;
    peekc = c;
    if(mpatov(symb, &yylval.vval))
        yyerror("overflow in constant");

    vv = yylval.vval;
    if(c1 & Numvlong) {
        if((c1 & Numuns) || convvtox(vv, TVLONG) < 0) {
            c = LUVLCONST;
            t = TUVLONG;
            goto nret;
        }
        c = LVLCONST;
        t = TVLONG;
        goto nret;
    }
    if(c1 & Numlong) {
        if((c1 & Numuns) || convvtox(vv, TLONG) < 0) {
            c = LULCONST;
            t = TULONG;
            goto nret;
        }
        c = LLCONST;
        t = TLONG;
        goto nret;
    }
    if((c1 & Numuns) || convvtox(vv, TINT) < 0) {
        c = LUCONST;
        t = TUINT;
        goto nret;
    }
    c = LCONST;
    t = TINT;
    goto nret;

nret:
    yylval.vval = convvtox(vv, t);
    if(yylval.vval != vv){
        nearln = lineno;
        warn(Z, "truncated constant: %T %s", types[t], symb);
    }
    return c;

casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c != 'e' && c != 'E')
        goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    if(!isdigit(c))
        yyerror("malformed fp constant exponent");
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    if(c == 'L' || c == 'l') {
        c = GETC();
        c1 |= Numlong;
    } else
    if(c == 'F' || c == 'f') {
        c = GETC();
        c1 |= Numflt;
    }
    *cp = 0;
    peekc = c;
    yylval.dval = strtod(symb, nil);
    if(isInf(yylval.dval, 1) || isInf(yylval.dval, -1)) {
        yyerror("overflow in float constant");
        yylval.dval = 0;
    }
    if(c1 & Numflt)
        return LFCONST;
    return LDCONST;
}
@

\section{Comments}

\section{Keywords and identifiers}

<<global itab>>=
struct
{
    char	*name;
    ushort	lexical;
    // option<enum<Type>>
    ushort	type;
} itab[] =
{
    "auto",		LAUTO,		0,
    "break",		LBREAK,		0,
    "case",		LCASE,		0,
    "char",		LCHAR,		TCHAR,
    "const",		LCONSTNT,	0,
    "continue",		LCONTINUE,	0,
    "default",		LDEFAULT,	0,
    "do",		LDO,		0,
    "double",		LDOUBLE,	TDOUBLE,
    "else",		LELSE,		0,
    "enum",		LENUM,		0,
    "extern",		LEXTERN,	0,
    "float",		LFLOAT,		TFLOAT,
    "for",		LFOR,		0,
    "goto",		LGOTO,		0,
    "if",		LIF,		0,
    "inline",		LINLINE,	0,
    "int",		LINT,		TINT,
    "long",		LLONG,		TLONG,
    "register",		LREGISTER,	0,
    "restrict",		LRESTRICT,	0,
    "return",		LRETURN,	0,
    "SET",		LSET,		0,
    "short",		LSHORT,		TSHORT,
    "signed",		LSIGNED,	0,
    "signof",		LSIGNOF,	0,
    "sizeof",		LSIZEOF,	0,
    "static",		LSTATIC,	0,
    "struct",		LSTRUCT,	0,
    "switch",		LSWITCH,	0,
    "typedef",		LTYPEDEF,	0,
    "typestr",		LTYPESTR,	0,
    "union",		LUNION,		0,
    "unsigned",		LUNSIGNED,	0,
    "USED",		LUSED,		0,
    "void",		LVOID,		TVOID,
    "volatile",		LVOLATILE,	0,
    "while",		LWHILE,		0,
    0
};
@

% extension: SET/USED

\section{Typedef trick}

%LTYPE!!

% typestr?

\section{Numbers}

<<enum numxxx>>=
enum numxxx
{
    Numdec		= 1<<0,
    Numlong		= 1<<1,
    Numuns		= 1<<2,
    Numvlong	= 1<<3,
    Numflt		= 1<<4,
};
@

<<function mpatov>>=
/*
 * convert a string, s, to vlong in *v
 * return conversion overflow.
 * required syntax is [0[x]]d*
 */
int
mpatov(char *s, vlong *v)
{
    vlong n, nn;
    int c;

    n = 0;
    c = *s;
    if(c == '0')
        goto oct;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            nn = n*10 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

oct:
    s++;
    c = *s;
    if(c == 'x' || c == 'X')
        goto hex;
    while(c = *s++) {
        if(c >= '0' || c <= '7')
            nn = n*8 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

hex:
    s++;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            c += 0-'0';
        else
        if(c >= 'a' && c <= 'f')
            c += 10-'a';
        else
        if(c >= 'A' && c <= 'F')
            c += 10-'A';
        else
            goto bad;
        nn = n*16 + c;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
out:
    *v = n;
    return 0;

bad:
    *v = ~0;
    return 1;
}
@


\subsection{Decimals}

\subsection{Floats}

\section{Characters}

\section{Escaping characters}

<<function escchar>>=
long
escchar(long e, int longflg, bool escflg)
{
    long c, l;
    int i;

loop:
    c = getr();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            c = EOF;
        return c;
    }
    c = getr();
    if(c == 'x') {
        /*
         * note this is not ansi,
         * supposed to only accept 2 hex
         */
        i = 2;
        if(longflg)
            i = 6;
        l = 0;
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '9') {
                l = l*16 + c-'0';
                continue;
            }
            if(c >= 'a' && c <= 'f') {
                l = l*16 + c-'a' + 10;
                continue;
            }
            if(c >= 'A' && c <= 'F') {
                l = l*16 + c-'A' + 10;
                continue;
            }
            unget(c);
            break;
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    if(c >= '0' && c <= '7') {
        /*
         * note this is not ansi,
         * supposed to only accept 3 oct
         */
        i = 2;
        if(longflg)
            i = 8;
        l = c - '0';
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                continue;
            }
            unget(c);
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return '\a';
    case 'v':	return '\v';
    }
    return c;
}
@


<<function getr>>=
long
getr(void)
{
    int c, i;
    char str[UTFmax+1];
    Rune rune;


    c = getc();
    if(c < Runeself)
        return c;
    i = 0;
    str[i++] = c;

loop:
    c = getc();
    str[i++] = c;
    if(!fullrune(str, i))
        goto loop;
    c = chartorune(&rune, str);
    if(rune == Runeerror && c == 1) {
        nearln = lineno;
        diag(Z, "illegal rune in string");
        for(c=0; c<i; c++)
            print(" %.2x", *(uchar*)(str+c));
        print("\n");
    }
    return rune;
}
@

\section{Strings}



\section{[[getc()]], [[unget()]], [[getnsc()]]}

<<function getc>>=
int
getc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@

<<function unget>>=
void
unget(int c)
{

    peekc = c;
    if(c == '\n')
        lineno--;
}
@

<<function getnsc>>=
int
getnsc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    for(;;) {
        if(c >= Runeself || !isspace(c))
            return c;
        if(c == '\n') {
            lineno++;
            return c;
        }
        c = GETC();
    }
}
@


\section{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@
% 4 = sizeof Rune?

\section{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

\chapter{Preprocessing}

<<constant CPP>>=
#define	CPP	"/bin/cpp"
@

<<[[compile()]] use ANSI preprocessor>>=
/* Use an ANSI preprocessor */
if(debug['p']) {
    if(myaccess(file) < 0) {
        diag(Z, "%s does not exist", file);
        errorexit();
    }
    if(pipe(fd) < 0) {
        diag(Z, "pipe failed");
        errorexit();
    }
    switch(fork()) {
    case -1:
        diag(Z, "fork failed");
        errorexit();

    case 0:
        close(fd[0]);
        dup(fd[1], 1);
        close(fd[1]);
        av = alloc((3 + ndef + ninclude + 2) * sizeof *av);
        av[0] = CPP;
        i = 1;
        if(debug['.'])
            av[i++] = strdup("-.");
        /* 1999 ANSI C requires recognising // comments */
        av[i++] = strdup("-+");
        for(c = 0; c < ndef; c++) {
            sprint(opt, "-D%s", defs[c]);
            av[i++] = strdup(opt);
        }
        for(c = 0; c < ninclude; c++) {
            sprint(opt, "-I%s", include[c]);
            av[i++] = strdup(opt);
        }
        if(strcmp(file, "stdin") != 0)
            av[i++] = file;
        av[i] = 0;
        if(debug['p'] > 1) {
            for(c = 0; c < i; c++)
                fprint(2, "%s ", av[c]);
            fprint(2, "\n");
        }

        exec(av[0], av);
        fprint(2, "can't exec C preprocessor %s: %r\n", CPP);
        errorexit();

    default:
        close(fd[1]);
        newfile(file, fd[0]);
        break;
    }
}
@


% builtin preprocessor integrated with lexer (benefit? faster? no fork?)
% see also 8c -p

% dupe with Assembler.tex.nw, should try to factorize at some point

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",	nil,	/* macif(2) */

    "line",	maclin,
    "define",	macdef,
    "include",	macinc,
    "undef",	macund,

    "pragma",	macprag,
    "endif",	macend,
    0
};
@

% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really

<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]] and [[-I]]}

\subsection{Include path}

% was using fixed array in assembler
<<global include>>=
char**	include;
@

<<global ninclude>>=
int	ninclude;
@

<<global maxinclude>>=
int	maxinclude;
@


<<function setinclude>>=
void
setinclude(char *p)
{
    int i;
    char *e, **np;

    while(*p != 0) {
        e = strchr(p, ' ');
        if(e != 0)
            *e = '\0';

        for(i=0; i < ninclude; i++)
            if(strcmp(p, include[i]) == 0)
                break;

        if(i >= ninclude){
            if(i >= maxinclude){
                maxinclude += 20;
                np = alloc(maxinclude * sizeof *np);
                if(include != nil)
                    memmove(np, include, (maxinclude - 20) * sizeof *np);
                include = np;
            }
            include[ninclude++] = p;
        }

        if(e == 0)
            break;
        p = e+1;
    }
}
@

\subsection{Tracing}

<<struct Hist>>=
struct	Hist
{
    char*	name;

    long	line;
    long	offset;

    Hist*	link;
};
@

<<constant H>>=
#define	H	((Hist*)nil)
@

<<global hist>>=
Hist*	hist;
@

<<global ehist>>=
Hist*	ehist;
@

<<global newflag>>=
bool	newflag;
@


<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    /*
     * overwrite the last #line directive if
     * no alloc has happened since the last one
     */
    if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
        if(f && ehist->name && strcmp(f, ehist->name) == 0) {
            ehist->line = lineno;
            ehist->offset = offset;
            return;
        }
    <<[[linehist()]] debug>>

    newflag = false;

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@

\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@


% LP split, and factorize code with gethunk
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]] and [[-D]]}

\subsection{[[-D]]}

% no Dlist here, instead pass the defs to compile()

<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;

    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@

% LP split macro field of Sym


\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

%<<[[yylex()]] if macro symbol>>=

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);

    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro()
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0) {
        c0 = getnsc();
        if(c0 != '"') {
            c = c0;
            if(c0 != '<')
                goto bad;
            c0 = '>';
        }
        for(hp = symb;;) {
            c = getc();
            if(c == c0)
                break;
            if(c == '\n')
                goto bad;
            *hp++ = c;
        }
        *hp = '\0';
        c = getcom();
        if(c != '\n')
            goto bad;
    
        /*
         * put pragma-line in as a funny history 
         */
        c = strlen(symb) + 1;
        while(c & 3)
            c++;
    
        while(nhunk < c)
            gethunk();
        hp = hunk;
        memcpy(hunk, symb, c);
        nhunk -= c;
        hunk += c;
    
        h = alloc(sizeof(Hist));
        h->name = hp;
        h->line = lineno;
        h->offset = -1;

        h->link = H;
        if(ehist == H) {
            hist = h;
            ehist = h;
            return;
        }
        ehist->link = h;
        ehist = h;

        return;

bad:
        unget(c);
        yyerror("syntax in #pragma lib");
        macend();

    } else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded except #pragma lib, so
% I removed it (could have aslo simplified by calling prag_do_nothing()).
% is it because code was shared with cc? or because it's in aa/
% and other archi do different things?
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

% useful for code generator, to report error to original file, not generated
% code, e.g. for lex&yacc

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@



\chapter{Parsing}

\section{Overview}

% I assume you understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.tex.nw :) )
%(compared to ocamlyacc can have actions in the middle, and they count
% as indexable elements for the $xxx ($1, $2, etc))

<<cc/cc.y>>=
%{
#include "cc.h"
%}
<<union yacc>>
<<token declarations>>
<<priority and associativity declarations>>
<<type declarations>>
%%
<<grammar>>
%%
@

% have seen Token declarations in Core Data structures chapter already.

% do not LP split, order matters!
<<priority and associativity declarations>>=
%left   ';'
%left   ','
%right  '=' LPE LME LMLE LDVE LMDE LRSHE LLSHE LANDE LXORE LORE
%right  '?' ':'
%left   LOROR
%left   LANDAND
%left   '|'
%left   '^'
%left   '&'
%left   LEQ LNE
%left   '<' '>' LLE LGE
%left   LLSH LRSH
%left   '+' '-'
%left   '*' '/' '%'
%right  LMM LPP LMG '.' '[' '('
@


<<[[union yacc]] other fields>>=
Node*   node;
@

% see Node also in Core data structure section, with Z, left/right, new(), etc

<<type declarations>>=
%type   <node>  zarglist arglist zcexpr
%type   <node>  name block stmnt cexpr expr xuexpr pexpr
%type   <node>  zelist elist adecl slist uexpr string lstring
%type   <node>  xdecor xdecor2 labels label ulstmnt
%type   <node>  adlist edecor tag qual qlist
%type   <node>  abdecor abdecor1 abdecor2 abdecor3
%type   <node>  zexpr lexpr init ilist forexpr
@

% in what follows a few conventions: 
% zxxx means zero or more e.g. zctlist means list of ctl 0 or more

% note that all terminal chars like ')' are acutally Node* too
% so can pass them to warn() to get accurate error location

<<grammar>>=
prog:
  /* empty */
|   prog xdecl

<<declarator rules>>
<<statements rules>>
<<expressions rules>>
<<initializers rules>>
<<types rules>>
<<names rules>>

<<extra grammar rules>>
<<ebnf grammar rules>>
@



<<constant YYMAXDEPTH>>=
//@Scheck: used in t.tab.c probably
#define YYMAXDEPTH	1500
@

\section{Declarations and definitions, part one}

<<declarator rules>>=
<<external declarator rules>>
<<automatic declarator rules>>
<<parameter declarator rules>>
<<abstract declarator rules>>
<<structure element declarator rules>>
@

<<external declarator rules>>=
/*
 * external declarator
 */
xdecl:
    zctlist ';'          { dodecl(xdecl, lastclass, lasttype, Z); }
|   zctlist xdlist ';'
<<xdecl function definition case>>
@

% do that because C sucks? but my parser_c.mly was also complicated
% when it come to declaration handling
<<global lastclass>>=
// enum<cxxx>
//@Scheck: y.tab.c
char	lastclass;
@

<<global lasttype>>=
//@Scheck: y.tab.c
Type*	lasttype;
@

% dodecl() modify especially this global.
% hmm why Type* and not Decl*? rename lastdcltype?
<<global lastdcl>>=
Type*	lastdcl;
@



\section{Function definition}


<<global firstdcl>>=
Decl*	firstdcl;
@


%rename thisfntype?
<<global thisfn>>=
Type*	thisfn;
@



<<xdecl function definition case>>=
|   zctlist xdecor
    {
        lastdcl = T;
        firstarg = S;
        dodecl(xdecl, lastclass, lasttype, $2);
        if(lastdcl == T || lastdcl->etype != TFUNC) {
            diag($2, "not a function");
            lastdcl = types[TFUNC];
        }
        thisfn = lastdcl;
        markdcl();
        firstdcl = dclstack;
        argmark($2, 0);
    }
    pdecl
    {
        argmark($2, 1);
    }
    block
    {
        Node *n;

        n = revertdcl();
        if(n)
            $6 = new(OLIST, n, $6);

        if(!debug['a'] && !debug['Z'])
            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!
    }
@

% markdcl(), revertdcl(), see next section

\subsection{Parameters}

<<global firstarg>>=
Sym*	firstarg;
@

<<global firstargtype>>=
Type*	firstargtype;
@

% ?
<<global autoffset>>=
long	autoffset;
@

% ?
<<global stkoff>>=
long	stkoff;
@


% pass is 0 or 1
<<function argmark>>=
//@Scheck: not dead, used by cc.y
void argmark(Node *n, int pass)
{
    Type *t;

    autoffset = align(0, thisfn->link, Aarg0);
    stkoff = 0;
    for(; n->left != Z; n = n->left) {
        if(n->op != OFUNC || n->left->op != ONAME)
            continue;
        walkparam(n->right, pass);
        if(pass != 0 && anyproto(n->right) == OLDPROTO) {
            t = typ(TFUNC, n->left->sym->type->link);
            t->down = typ(TOLD, T);
            t->down->down = ofnproto(n->right);
            tmerge(t, n->left->sym);
            n->left->sym->type = t;
        }
        break;
    }
    autoffset = 0;
    stkoff = 0;
}
@

<<function tmerge>>=
void
tmerge(Type *t1, Sym *s)
{
    Type *ta, *tb, *t2;

    t2 = s->type;
/*print("merge	%T; %T\n", t1, t2);/**/
    for(;;) {
        if(t1 == T || t2 == T || t1 == t2)
            break;
        if(t1->etype != t2->etype)
            break;
        switch(t1->etype) {
        case TFUNC:
            ta = t1->down;
            tb = t2->down;
            if(ta == T) {
                t1->down = tb;
                break;
            }
            if(tb == T)
                break;
            while(ta != T && tb != T) {
                if(ta == tb)
                    break;
                /* ignore old-style flag */
                if(ta->etype == TOLD) {
                    ta = ta->down;
                    continue;
                }
                if(tb->etype == TOLD) {
                    tb = tb->down;
                    continue;
                }
                /* checking terminated by ... */
                if(ta->etype == TDOT && tb->etype == TDOT) {
                    ta = T;
                    tb = T;
                    break;
                }
                if(!sametype(ta, tb))
                    break;
                ta = ta->down;
                tb = tb->down;
            }
            if(ta != tb)
                diag(Z, "function inconsistently declared: %s", s->name);

            /* take new-style over old-style */
            ta = t1->down;
            tb = t2->down;
            if(ta != T && ta->etype == TOLD)
                if(tb != T && tb->etype != TOLD)
                    t1->down = tb;
            break;

        case TARRAY:
            /* should we check array size change? */
            if(t2->width > t1->width)
                t1->width = t2->width;
            break;

        case TUNION:
        case TSTRUCT:
            return;
        }
        t1 = t1->link;
        t2 = t2->link;
    }
}
@

<<function ofnproto>>=
Type*
ofnproto(Node *n)
{
    Type *tl, *tr, *t;

    if(n == Z)
        return T;
    switch(n->op) {
    case OLIST:
        tl = ofnproto(n->left);
        tr = ofnproto(n->right);
        if(tl == T)
            return tr;
        tl->down = tr;
        return tl;

    case ONAME:
        t = copytyp(n->sym->type);
        t->down = T;
        return t;
    }
    return T;
}
@

% TODO enum with bitset 1<<0, 1<<1
<<constant ANSIPROTO>>=
#define	ANSIPROTO	1
@

<<constant OLDPROTO>>=
#define	OLDPROTO	2
@





<<function fnproto>>=
Type*
fnproto(Node *n)
{
    int r;

    r = anyproto(n->right);
    if(r == 0 || (r & OLDPROTO)) {
        if(r & ANSIPROTO)
            diag(n, "mixed ansi/old function declaration: %F", n->left);
        return T;
    }
    return fnproto1(n->right);
}
@

<<function anyproto>>=
int
anyproto(Node *n)
{
    int r;

    r = 0;

loop:
    if(n == Z)
        return r;
    switch(n->op) {
    case OLIST:
        r |= anyproto(n->left);
        n = n->right;
        goto loop;

    case ODOTDOT:
    case OPROTO:
        return r | ANSIPROTO;
    }
    return r | OLDPROTO;
}
@

<<function fnproto1>>=
Type*
fnproto1(Node *n)
{
    Type *t;

    if(n == Z)
        return T;
    switch(n->op) {
    case OLIST:
        t = fnproto1(n->left);
        if(t != T)
            t->down = fnproto1(n->right);
        return t;

    case OPROTO:
        lastdcl = T;
        dodecl(NODECL, CXXX, n->type, n->left);
        t = typ(TXXX, T);
        if(lastdcl != T)
            *t = *paramconv(lastdcl, 1);
        return t;

    case ONAME:
        diag(n, "incomplete argument prototype");
        return typ(TINT, T);

    case ODOTDOT:
        return typ(TDOT, T);
    }
    diag(n, "unknown op in fnproto");
    return T;
}
@


<<function paramconv>>=
Type*
paramconv(Type *t, int f)
{

    switch(t->etype) {
    case TARRAY:
        t = typ(TIND, t->link);
        t->width = types[TIND]->width;
        break;

    case TFUNC:
        t = typ(TIND, t);
        t->width = types[TIND]->width;
        break;

    case TFLOAT:
        if(!f)
            t = types[TDOUBLE];
        break;

    case TCHAR:
    case TSHORT:
        if(!f)
            t = types[TINT];
        break;

    case TUCHAR:
    case TUSHORT:
        if(!f)
            t = types[TUINT];
        break;
    }
    return t;
}
@



<<function walkparam>>=
void
walkparam(Node *n, int pass)
{
    Sym *s;
    Node *n1;

    if(n != Z && n->op == OPROTO && n->left == Z && n->type == types[TVOID])
        return;

loop:
    if(n == Z)
        return;
    switch(n->op) {
    default:
        diag(n, "argument not a name/prototype: %O", n->op);
        break;

    case OLIST:
        walkparam(n->left, pass);
        n = n->right;
        goto loop;

    case OPROTO:
        for(n1 = n; n1 != Z; n1=n1->left)
            if(n1->op == ONAME) {
                if(pass == 0) {
                    s = n1->sym;
                    push1(s);
                    s->offset = -1;
                    break;
                }
                dodecl(pdecl, CPARAM, n->type, n->left);
                break;
            }
        if(n1)
            break;
        if(pass == 0) {
            /*
             * extension:
             *	allow no name in argument declaration
            diag(Z, "no name in argument declaration");
             */
            break;
        }
        dodecl(NODECL, CPARAM, n->type, n->left);
        pdecl(CPARAM, lastdcl, S);
        break;

    case ODOTDOT:
        break;
    
    case ONAME:
        s = n->sym;
        if(pass == 0) {
            push1(s);
            s->offset = -1;
            break;
        }
        if(s->offset != -1) {
            if(autoffset == 0) {
                firstarg = s;
                firstargtype = s->type;
            }
            autoffset = align(autoffset, s->type, Aarg1);
            s->offset = autoffset;
            autoffset = align(autoffset, s->type, Aarg2);
        } else
            dodecl(pdecl, CXXX, types[TINT], n);
        break;
    }
}
@



% TODO remove? old style decl?
<<parameter declarator rules>>=
/*
 * parameter declarator
 */
pdecl:
  /* empty */
|   pdecl ctlist pdlist ';'

pdlist:
    xdecor              { dodecl(pdecl, lastclass, lasttype, $1); }
|   pdlist ',' pdlist
@
%$
% this is old style? pre-ansi?


<<function pdecl>>=
void
pdecl(int c, Type *t, Sym *s)
{
    if(s && s->offset != -1) {
        diag(Z, "not a parameter: %s", s->name);
        return;
    }
    t = paramconv(t, c==CPARAM);
    if(c == CXXX)
        c = CPARAM;
    if(c != CPARAM) {
        diag(Z, "parameter cannot have class: %s", s->name);
        c = CPARAM;
    }
    if(typesu[t->etype] && t->width <= 0)
        diag(Z, "incomplete structure: %s", t->tag->name);
    adecl(c, t, s);
}
@





% called arg ... hmmm ... should be renamed zparamlist
<<parameter declarator rules>>=
zarglist:
  /* empty */   { $$ = Z; }
|   arglist     { $$ = invert($1); }


arglist:
    name
|   tlist abdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
|   tlist xdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
|   '.' '.' '.'          { $$ = new(ODOTDOT, Z, Z); }
|   arglist ',' arglist  { $$ = new(OLIST, $1, $3); }
@
%$



\section{Statements}

% block, labels, stmts

% seen 'block' for func def, block is a list of stmnt
<<statements rules>>=
block:
 '{' slist '}'
    {
        $$ = invert($2);
        if($$ == Z)
            $$ = new(OLIST, Z, Z);
    }

slist:
  /* empty */      { $$ = Z;    }
|   slist adecl    { $$ = new(OLIST, $1, $2); }
|   slist stmnt    { $$ = new(OLIST, $1, $2); }
@
%$


% can have labels before stmts
<<statements rules>>=
stmnt:
    ulstmnt
|   labels ulstmnt { $$ = new(OLIST, $1, $2); }
|   error ';'      { $$ = Z; }
@

% ul = no label? unlabeled?
<<statements rules>>=
<<ulstmnt rule>>
@

<<ulstmnt rule>>=
ulstmnt:
    zcexpr ';'
@

<<ebnf grammar rules>>=
labels:
    label
|   labels label  { $$ = new(OLIST, $1, $2); }
@

<<statements rules>>=
<<label rule>>
@

\subsection{Blocks}

<<ulstmnt rule>>=
|   {
        markdcl();
    }
    block
    {
        $$ = revertdcl();
        if($$)
            $$ = new(OLIST, $$, $2);
        else
            $$ = $2;
    }
@
% will explain later revertdcl() in Declaration section
% originally in comment //  if($2 != Z) $$ = new(OLIST, $2, $$);



\subsection{Conditionals}

<<ulstmnt rule>>=
|   LIF '(' cexpr ')' stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, Z));
        if($5 == Z)
            warn($3, "empty if body");
    }
|   LIF '(' cexpr ')' stmnt LELSE stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, $7));
        if($5 == Z)
            warn($3, "empty if body");
        if($7 == Z)
            warn($3, "empty else body");
    }
@
%$

% cexpr means  comma expr

\subsection{Switch}

<<ulstmnt rule>>=
|   LSWITCH '(' cexpr ')' stmnt
    {
        // generate (0:int - (0:int - x))
        // which will force the usual arithmetic conversions
        // (and will later be simplified by later transformations)

        $$ = new(OCONST, Z, Z);
        $$->vconst = 0;
        $$->type = types[TINT];
        $3 = new(OSUB, $$, $3);

        $$ = new(OCONST, Z, Z);
        $$->vconst = 0;
        $$->type = types[TINT];
        $3 = new(OSUB, $$, $3);

        $$ = new(OSWITCH, $3, $5);
    }
@
% I originally thought there was a copy paste bug above,
% and even rob pike though to, but it turned out it's not a bug :)

% note that 'labels' with an 's' before, so can have case 1: case 2: ...

<<label rule>>=
label:
    LCASE expr ':'  { $$ = new(OCASE, $2, Z); }
|   LDEFAULT ':'    { $$ = new(OCASE, Z, Z); }
@
%$

\subsection{Control flow jumps}

<<ulstmnt rule>>=
|   LRETURN zcexpr ';'
    {
        $$ = new(ORETURN, $2, Z);
        $$->type = thisfn->link;
    }
|   LBREAK ';'     { $$ = new(OBREAK, Z, Z); }
|   LCONTINUE ';'  { $$ = new(OCONTINUE, Z, Z); }
@
%$


\subsection{Loops}

<<ulstmnt rule>>=
|   { 
        markdcl(); 
    } 
    LFOR '(' forexpr ';' zcexpr ';' zcexpr ')' stmnt
    {
        $$ = revertdcl();
        if($$){
            if($4)
                $4 = new(OLIST, $$, $4);
            else
                $4 = $$;
        }
        $$ = new(OFOR, new(OLIST, $6, new(OLIST, $4, $8)), $10);
    }
|   LWHILE '(' cexpr ')' stmnt          { $$ = new(OWHILE, $3, $5); }
|   LDO stmnt LWHILE '(' cexpr ')' ';'  { $$ = new(ODWHILE, $5, $2); }
@

% C extension for(int i; ... ?) hence the markdcl? for scope?
<<statements rules>>=
forexpr:
    zcexpr
|   ctlist adlist { $$ = $2; }
@
%$

\subsection{Labels and goto}

<<label rule>>=
|   LNAME ':'       { $$ = new(OLABEL, dcllabel($1, true), Z); }
@
%$

<<ulstmnt rule>>=
|   LGOTO ltag ';' { $$ = new(OGOTO, dcllabel($2, false), Z); }
@
%$


<<[[Sym]] other fields>>=
Node*	label;
@

% flag is true for label definition context, false for use (e.g. in goto)
% TODO cleanup abuse of complex/addable, do like in scheck field for used
<<function dcllabel>>=
//@Scheck: used by cc.y
Node* dcllabel(Sym *s, bool f)
{
    Decl *d, d1;
    Node *n;

    n = s->label;
    if(n != Z) {
        if(f) {
            if(n->complex)
                diag(Z, "label reused: %s", s->name);
            n->complex = true;	// declared
        } else
            n->addable = true;	// used
        return n;
    }

    d = push();
    d->sym = s;
    d->val = DLABEL;

    dclstack = d->link;

    d1 = *firstdcl;
    *firstdcl = *d;
    *d = d1;

    firstdcl->link = d;
    firstdcl = d;

    n = new(OXXX, Z, Z);
    n->sym = s;
    n->complex = f;
    n->addable = !f;

    s->label = n;

    if(debug['d'])
        dbgdecl(s);
    return n;
}
@

\section{Expressions}

% e.g. in array def context, can have an int or nothing, TODO rename zlexpr?
<<expressions rules>>=
zexpr:
  /* empty */ { $$ = Z; }
|   lexpr
@

<<expressions rules>>=
lexpr:
    expr
    {
        $$ = new(OCAST, $1, Z);
        $$->type = types[TLONG];
    }
@
%$

<<expressions rules>>=
cexpr:
    expr
|   cexpr ',' cexpr { $$ = new(OCOMMA, $1, $3); }
@
%$
% cexpr = comma expr


<<ebnf grammar rules>>=
zcexpr:
  /* empty */ { $$ = Z; }
|   cexpr
@


\subsection{Binary expressions}

<<expressions rules>>=
expr:
    xuexpr

|   expr '*' expr { $$ = new(OMUL, $1, $3); }
|   expr '/' expr { $$ = new(ODIV, $1, $3); }
|   expr '%' expr { $$ = new(OMOD, $1, $3); }
|   expr '+' expr { $$ = new(OADD, $1, $3); }
|   expr '-' expr { $$ = new(OSUB, $1, $3); }
|   expr LRSH expr { $$ = new(OASHR, $1, $3); }
|   expr LLSH expr { $$ = new(OASHL, $1, $3); }
|   expr '<' expr  { $$ = new(OLT, $1, $3); }
|   expr '>' expr  { $$ = new(OGT, $1, $3); }
|   expr LLE expr  { $$ = new(OLE, $1, $3); }
|   expr LGE expr  { $$ = new(OGE, $1, $3); }
|   expr LEQ expr  { $$ = new(OEQ, $1, $3); }
|   expr LNE expr  { $$ = new(ONE, $1, $3); }
|   expr '&' expr  { $$ = new(OAND, $1, $3); }
|   expr '^' expr  { $$ = new(OXOR, $1, $3); }
|   expr '|' expr  { $$ = new(OOR, $1, $3); }
|   expr LANDAND expr { $$ = new(OANDAND, $1, $3); }
|   expr LOROR expr   { $$ = new(OOROR, $1, $3); }

|   expr '?' cexpr ':' expr { $$ = new(OCOND, $1, new(OLIST, $3, $5)); }

|   expr '=' expr  { $$ = new(OAS, $1, $3); }
|   expr LPE expr  { $$ = new(OASADD, $1, $3); }
|   expr LME expr  { $$ = new(OASSUB, $1, $3); }
|   expr LMLE expr { $$ = new(OASMUL, $1, $3); }
|   expr LDVE expr { $$ = new(OASDIV, $1, $3); }
|   expr LMDE expr { $$ = new(OASMOD, $1, $3); }
|   expr LLSHE expr { $$ = new(OASASHL, $1, $3); }
|   expr LRSHE expr { $$ = new(OASASHR, $1, $3); }
|   expr LANDE expr { $$ = new(OASAND, $1, $3); }
|   expr LXORE expr { $$ = new(OASXOR, $1, $3); }
|   expr LORE expr  { $$ = new(OASOR, $1, $3); }
@
%$

\subsection{Cast}

<<expressions rules>>=
xuexpr:
    uexpr
|   '(' tlist abdecor ')' xuexpr
    {
        $$ = new(OCAST, $5, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcl;
        $$->xcast = true;
    }
<<xuexpr other cases>>
@
%$

% extended unary expr? = cast expr

<<[[Node]] other fields>>=
bool 	xcast;
@

% kenccext and gccext, struct constructor
<<xuexpr other cases>>=
|   '(' tlist abdecor ')' '{' ilist '}' /* extension */
    {
        $$ = new(OSTRUCT, $6, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcl;
    }
@
%$


\subsection{Unary expressions}

% unary expr
<<expressions rules>>=
uexpr:
    pexpr

|   '*' xuexpr { $$ = new(OIND, $2, Z); }
|   '&' xuexpr { $$ = new(OADDR, $2, Z); }

|   '+' xuexpr { $$ = new(OPOS, $2, Z); }
|   '-' xuexpr { $$ = new(ONEG, $2, Z); }
|   '!' xuexpr { $$ = new(ONOT, $2, Z); }
|   '~' xuexpr { $$ = new(OCOM, $2, Z); }
|   LPP xuexpr { $$ = new(OPREINC, $2, Z); }
|   LMM xuexpr { $$ = new(OPREDEC, $2, Z); }

|   LSIZEOF uexpr { $$ = new(OSIZE, $2, Z); }
|   LSIGNOF uexpr { $$ = new(OSIGN, $2, Z); }
@
% signof?

\subsection{Primary expressions}

<<expressions rules>>=
<<pexpr rule>>
@

% primary expr
<<pexpr rule>>=
pexpr:
    '(' cexpr ')' { $$ = $2; }
@
%$

<<pexpr rule>>=
|   LSIZEOF '(' tlist abdecor ')'
    {
        $$ = new(OSIZE, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcl;
    }
|   LSIGNOF '(' tlist abdecor ')'
    {
        $$ = new(OSIGN, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcl;
    }
@
%$
% again sizeof but this time not uexpr, but types!

% funcall!
<<pexpr rule>>=
|   pexpr '(' zelist ')'
    {
        $$ = new(OFUNC, $1, Z);
        if($1->op == ONAME)
          if($1->type == T)
            dodecl(xdecl, CXXX, types[TINT], $$);
        $$->right = invert($3);
    }
@
% no forward decl of entity name, so assumes return an int?
% TODO should warn instead about undeclared symbol? cleaner!

<<ebnf grammar rules>>=
zelist:
  /* empty */ { $$ = Z; }
|   elist
@


<<expressions rules>>=
elist:
    expr
|   elist ',' elist { $$ = new(OLIST, $1, $3); }
@
% elist really? should be expr no? or have a %left for ',' ?

% unsugar x[y] as *(x+y) :)
<<pexpr rule>>=
|   pexpr '[' cexpr ']' { $$ = new(OIND, new(OADD, $1, $3), Z); }
@

% unsugar x->y as (*x).y
<<pexpr rule>>=
|   pexpr '.' ltag
    {
        $$ = new(ODOT, $1, Z);
        $$->sym = $3;
    }
|   pexpr LMG ltag
    {
        $$ = new(ODOT, new(OIND, $1, Z), Z);
        $$->sym = $3;
    }
@

<<pexpr rule>>=
|   pexpr LPP { $$ = new(OPOSTINC, $1, Z); }
|   pexpr LMM { $$ = new(OPOSTDEC, $1, Z); }
@

\subsection{Entities}

<<pexpr rule>>=
|   name
@

% use (def of entities use 'tag' instead, in xdecor2, not 'name')
<<names rules>>=
name:
    LNAME
    {
        $$ = new(ONAME, Z, Z);
        if($1->class == CLOCAL)
            $1 = mkstatic($1);
        $$->sym = $1;
        $$->type = $1->type;

        $$->etype = TVOID;
        if($$->type != T)
            $$->etype = $$->type->etype;

        $$->xoffset = $1->offset;
        $$->class = $1->class;

        $1->aused = true;
    }
@
% similar to tag rule

% rename mkstatic_if_local?
% rename locals in global symbol table so have unique name with the block
<<function mkstatic>>=
Sym*
mkstatic(Sym *s)
{
    Sym *s1;

    if(s->class != CLOCAL)
        return s;

    snprint(symb, NSYMB, "%s$%d", s->name, s->block);
    s1 = lookup();

    if(s1->class != CSTATIC) {
        s1->type = s->type;
        s1->offset = s->offset;
        s1->block = s->block;
        s1->class = CSTATIC;
    }
    return s1;
}
@

\subsection{Numeric Constants}

<<pexpr rule>>=
|   LCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@

<<pexpr rule>>=
|   LUCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LULCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TULONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LUVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$

<<pexpr rule>>=
|   LFCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TFLOAT];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
|   LDCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TDOUBLE];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$

\subsection{String constants}
% char constant? unsugard in yylex?

<<pexpr rule>>=
|   string
|   lstring
@

<<expressions rules>>=
string:
    LSTRING
    {
        $$ = new(OSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TCHAR]);
        $$->etype = TARRAY;
        $$->type->width = $1.l + 1;
        $$->cstring = $1.s;
        $$->sym = symstring;
        $$->class = CSTATIC;
    }
|   string LSTRING
    {
        char *s;
        int n;

        n = $1->type->width - 1;
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->cstring, n);
        memcpy(s+n, $2.s, $2.l);
        s[n+$2.l] = '\0';

        $$ = $1;
        $$->type->width += $2.l;
        $$->cstring = s;
    }
@

% unicode
<<expressions rules>>=
lstring:
    LLSTRING
    {
        $$ = new(OLSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TRUNE]);
        $$->etype = TARRAY;
        $$->type->width = $1.l + sizeof(TRune);
        $$->rstring = (TRune*)$1.s;
        $$->sym = symstring;
        $$->class = CSTATIC;
    }
|   lstring LLSTRING
    {
        char *s;
        int n;

        n = $1->type->width - sizeof(TRune);
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->rstring, n);
        memcpy(s+n, $2.s, $2.l);
        *(TRune*)(s+n+$2.l) = 0;

        $$ = $1;
        $$->type->width += $2.l;
        $$->rstring = (TRune*)s;
    }
@


\section{Initializers}

% in decl?:
%    '=' init
%    {
%        doinit($1->sym, $1->type, 0L, $4);
%    }

<<initializers rules>>=
init:
    expr
|   '{' ilist '}' { $$ = new(OINIT, invert($2), Z); }

ilist:
    qlist
|   init
|   qlist init { $$ = new(OLIST, $1, $2); }

qlist:
    init ','
|   qlist init ','  { $$ = new(OLIST, $1, $2); }
|   qual
|   qlist qual      { $$ = new(OLIST, $1, $2); }

qual:
    '[' lexpr ']' { $$ = new(OARRAY, $2, Z); }
|   '.' ltag
    {
        $$ = new(OELEM, Z, Z);
        $$->sym = $2;
    }
|   qual '='
@
%$
% alternate syntax qual =


% in decl?:
%    '=' init
%    {
%        doinit($1->sym, $1->type, 0L, $4);
%    }

<<global initlist>>=
Node*	initlist;
@

<<function doinit>>=
Node*
doinit(Sym *s, Type *t, long o, Node *a)
{
    Node *n;

    if(t == T)
        return Z;
    if(s->class == CEXTERN) {
        s->class = CGLOBL;
        if(debug['d'])
            dbgdecl(s);
    }
    if(debug['i']) {
        print("t = %T; o = %ld; n = %s\n", t, o, s->name);
        prtree(a, "doinit value");
    }


    n = initlist;
    if(a->op == OINIT)
        a = a->left;
    initlist = a;

    a = init1(s, t, o, 0);
    if(initlist != Z)
        diag(initlist, "more initializers than structure: %s",
            s->name);
    initlist = n;

    return a;
}
@


% could be made a static local of init1?
<<global nodcast>>=
Node*	nodcast;
@


<<function init1>>=
Node*
init1(Sym *s, Type *t, long o, int exflag)
{
    Node *a, *l, *r, nod;
    Type *t1;
    long e, w, so, mw;

    a = peekinit();
    if(a == Z)
        return Z;

    if(debug['i']) {
        print("t = %T; o = %ld; n = %s\n", t, o, s->name);
        prtree(a, "init1 value");
    }

    if(exflag && a->op == OINIT)
        return doinit(s, t, o, nextinit());

    switch(t->etype) {
    default:
        diag(Z, "unknown type in initialization: %T to: %s", t, s->name);
        return Z;

    case TCHAR:
    case TUCHAR:
    case TINT:
    case TUINT:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
    case TIND:
    single:
        if(a->op == OARRAY || a->op == OELEM)
            return Z;

        a = nextinit();
        if(a == Z)
            return Z;

        if(t->nbits)
            diag(Z, "cannot initialize bitfields");
        if(s->class == CAUTO) {
            l = new(ONAME, Z, Z);
            l->sym = s;
            l->type = t;
            l->etype = TVOID;
            if(s->type)
                l->etype = s->type->etype;
            l->xoffset = s->offset + o;
            l->class = s->class;

            l = new(OASI, l, a);
            return l;
        }

        complex(a);
        if(a->type == T)
            return Z;

        if(a->op == OCONST) {
            if(vconst(a) && t->etype == TIND && a->type && a->type->etype != TIND){
                diag(a, "initialize pointer to an integer: %s", s->name);
                return Z;
            }
            if(!sametype(a->type, t)) {
                /* hoop jumping to save malloc */
                if(nodcast == Z)
                    nodcast = new(OCAST, Z, Z);
                nod = *nodcast;
                nod.left = a;
                nod.type = t;
                nod.lineno = a->lineno;
                complex(&nod);
                if(nod.type)
                    *a = nod;
            }
            if(a->op != OCONST) {
                diag(a, "initializer is not a constant: %s",
                    s->name);
                return Z;
            }
            if(vconst(a) == 0)
                return Z;
            goto gext;
        }
        if(t->etype == TIND) {
            while(a->op == OCAST) {
                warn(a, "CAST in initialization ignored");
                a = a->left;
            }
            if(!sametype(t, a->type)) {
                diag(a, "initialization of incompatible pointers: %s\n%T and %T",
                    s->name, t, a->type);
            }
            if(a->op == OADDR)
                a = a->left;
            goto gext;
        }

        while(a->op == OCAST)
            a = a->left;
        if(a->op == OADDR) {
            warn(a, "initialize pointer to an integer: %s", s->name);
            a = a->left;
            goto gext;
        }
        diag(a, "initializer is not a constant: %s", s->name);
        return Z;

    gext:
        gextern(s, a, o, t->width);

        return Z;

    case TARRAY:
        w = t->link->width;
        if(a->op == OSTRING || a->op == OLSTRING)
        if(typei[t->link->etype]) {
            /*
             * get rid of null if sizes match exactly
             */
            a = nextinit();
            mw = t->width/w;
            so = a->type->width/a->type->link->width;
            if(mw && so > mw) {
                if(so != mw+1)
                    diag(a, "string initialization larger than array");
                a->type->width -= a->type->link->width;
            }

            /*
             * arrange strings to be expanded
             * inside OINIT braces.
             */
            a = new(OUSED, a, Z);
            return doinit(s, t, o, a);
        }

        mw = -w;
        l = Z;
        for(e=0;;) {
            /*
             * peek ahead for element initializer
             */
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM && t->link->etype != TSTRUCT)
                break;
            if(a->op == OARRAY) {
                if(e && exflag)
                    break;
                a = nextinit();
                r = a->left;
                complex(r);
                if(r->op != OCONST) {
                    diag(r, "initializer subscript must be constant");
                    return Z;
                }
                e = r->vconst;
                if(t->width != 0)
                    if(e < 0 || e*w >= t->width) {
                        diag(a, "initialization index out of range: %ld", e);
                        continue;
                    }
            }

            so = e*w;
            if(so > mw)
                mw = so;
            if(t->width != 0)
                if(mw >= t->width)
                    break;
            r = init1(s, t->link, o+so, 1);
            l = newlist(l, r);
            e++;
        }
        if(t->width == 0)
            t->width = mw+w;
        return l;

    case TUNION:
    case TSTRUCT:
        /*
         * peek ahead to find type of rhs.
         * if its a structure, then treat
         * this element as a variable
         * rather than an aggregate.
         */
        if(isstruct(a, t))
            goto single;

        if(t->width <= 0) {
            diag(Z, "incomplete structure: %s", s->name);
            return Z;
        }
        l = Z;

    again:
        for(t1 = t->link; t1 != T; t1 = t1->down) {
            if(a->op == OARRAY && t1->etype != TARRAY)
                break;
            if(a->op == OELEM) {
                if(t1->sym != a->sym)
                    continue;
                nextinit();
            }
            r = init1(s, t1, o+t1->offset, 1);
            l = newlist(l, r);
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM)
                goto again;
        }
        if(a && a->op == OELEM)
            diag(a, "structure element not found %F", a);
        return l;
    }
}
@

<<function newlist>>=
Node*
newlist(Node *l, Node *r)
{
    if(r == Z)
        return l;
    if(l == Z)
        return r;
    return new(OLIST, l, r);
}
@

<<function isstruct>>=
int
isstruct(Node *a, Type *t)
{
    Node *n;

    switch(a->op) {
    case ODOTDOT:
        n = a->left;
        if(n && n->type && sametype(n->type, t))
            return 1;
    case OSTRING:
    case OLSTRING:
    case OCONST:
    case OINIT:
    case OELEM:
        return 0;
    }

    n = new(ODOTDOT, Z, Z);
    *n = *a;

    /*
     * ODOTDOT is a flag for tcom
     * a second tcom will not be performed
     */
    a->op = ODOTDOT;
    a->left = n;
    a->right = Z;

    if(tcom(n))
        return 0;

    if(sametype(n->type, t))
        return 1;
    return 0;
}
@

<<function peekinit>>=
/*
 * get next major operator,
 * dont advance initlist.
 */
Node*
peekinit(void)
{
    Node *a;

    a = initlist;

loop:
    if(a == Z)
        return a;
    if(a->op == OLIST) {
        a = a->left;
        goto loop;
    }
    return a;
}
@

<<function nextinit>>=
/*
 * consume and return next element on
 * initlist. expand strings.
 */
Node*
nextinit(void)
{
    Node *a, *b, *n;

    a = initlist;
    n = Z;

    if(a == Z)
        return a;
    if(a->op == OLIST) {
        n = a->right;
        a = a->left;
    }
    if(a->op == OUSED) {
        a = a->left;
        b = new(OCONST, Z, Z);
        b->type = a->type->link;
        if(a->op == OSTRING) {
            b->vconst = convvtox(*a->cstring, TCHAR);
            a->cstring++;
        }
        if(a->op == OLSTRING) {
            b->vconst = convvtox(*a->rstring, TRUNE);
            a->rstring++;
        }
        a->type->width -= b->type->width;
        if(a->type->width <= 0)
            initlist = n;
        return b;
    }
    initlist = n;
    return a;
}
@

\section{Types and storage classes}

% bitset, because need to aggregate keywords to form the final thing.
% to transform from 'unsigned char' -> TUCHAR?
% pre: Txxx must have less than 64 cases? 1L => long => long enum
<<enum bxxx>>=
enum bxxx
{
    BCHAR		= 1L<<TCHAR,
    BUCHAR		= 1L<<TUCHAR,
    BSHORT		= 1L<<TSHORT,
    BUSHORT		= 1L<<TUSHORT,
    BINT		= 1L<<TINT,
    BUINT		= 1L<<TUINT,
    BLONG		= 1L<<TLONG,
    BULONG		= 1L<<TULONG,
    BVLONG		= 1L<<TVLONG,
    BUVLONG		= 1L<<TUVLONG,
    BFLOAT		= 1L<<TFLOAT,
    BDOUBLE		= 1L<<TDOUBLE,

    BIND		= 1L<<TIND,
    BFUNC		= 1L<<TFUNC,
    BARRAY		= 1L<<TARRAY,
    BVOID		= 1L<<TVOID,
    BSTRUCT		= 1L<<TSTRUCT,
    BUNION		= 1L<<TUNION,
    BENUM		= 1L<<TENUM,

    BFILE		= 1L<<TFILE,
    BDOT		= 1L<<TDOT,

    BCONSTNT	= 1L<<TCONSTNT,
    BVOLATILE	= 1L<<TVOLATILE,

    BUNSIGNED	= 1L<<TUNSIGNED,
    BSIGNED		= 1L<<TSIGNED,

    BAUTO		= 1L<<TAUTO,
    BEXTERN		= 1L<<TEXTERN,
    BSTATIC		= 1L<<TSTATIC,

    BTYPEDEF	= 1L<<TTYPEDEF,
    BTYPESTR	= 1L<<TTYPESTR,
    BREGISTER	= 1L<<TREGISTER,


    BINTEGER	= BCHAR|BUCHAR|BSHORT|BUSHORT|BINT|BUINT|
                BLONG|BULONG|BVLONG|BUVLONG,
    BNUMBER		= BINTEGER|BFLOAT|BDOUBLE,

/* these can be overloaded with complex types */

    BCLASS		= BAUTO|BEXTERN|BSTATIC|BTYPEDEF|BTYPESTR|BREGISTER,
    BGARB		= BCONSTNT|BVOLATILE,
};
@

% see also enum<cxxx> and enum<type_kind>


% bitset<enum<bxxx> > actually
<<type declarations>>=
%type   <lval>  tname cname gname
@

<<types rules>>=
tname:  /* type words */
    LCHAR     { $$ = BCHAR; }
|   LSHORT    { $$ = BSHORT; }
|   LINT      { $$ = BINT; }
|   LLONG     { $$ = BLONG; }
|   LSIGNED   { $$ = BSIGNED; }
|   LUNSIGNED { $$ = BUNSIGNED; }
|   LFLOAT    { $$ = BFLOAT; }
|   LDOUBLE   { $$ = BDOUBLE; }
|   LVOID     { $$ = BVOID; }
@

<<types rules>>=
cname:  /* class words */
    LAUTO     { $$ = BAUTO; }
|   LSTATIC   { $$ = BSTATIC; }
|   LEXTERN   { $$ = BEXTERN; }
|   LTYPEDEF  { $$ = BTYPEDEF; }
|   LTYPESTR  { $$ = BTYPESTR; }
|   LREGISTER { $$ = BREGISTER; }
|   LINLINE   { $$ = 0; }
@

% garbage?
<<types rules>>=
gname:  /* garbage words */
    LCONSTNT  { $$ = BCONSTNT; }
|   LVOLATILE { $$ = BVOLATILE; }
|   LRESTRICT { $$ = 0; }
@


<<type declarations>>=
%type   <lval>   gcname   gctname
@

<<names rules>>=
gctname:
    tname
|   gname
|   cname

gcname:
    gname
|   cname
@



% type and class
<<[[union yacc]] other fields>>=
struct
{
    Type*   t;
    // enum<cxxx>
    byte   c;
} tycl;
@

<<[[union yacc]] other fields>>=
Type*   type;
@


<<type declarations>>=
%type   <tycl>  types
@


<<types rules>>=
<<types rule>>
@

% sizeof, cast, context
<<extra grammar rules>>=
tlist:
    types
    {
        $$ = $1.t;
        if($1.c != CXXX)
            diag(Z, "illegal combination of class 4: %s", cnames[$1.c]);
    }
@
% do not allow to specify storage class
% (hmmm could have done via grammar?)

<<type declarations>>=
%type   <type> tlist
@


\subsection{Simple types}

<<types rule>>=
types:
   tname
    {
        $$.t = simplet($1);
        $$.c = CXXX;
    }
@
%$


<<types rule>>=
|   gcnlist
    {
        $$.t = simplet($1);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   tname gctnlist
    {
        $$.t = simplet(typebitor($1, $2));
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
    }
|   gcnlist tname
    {
        $$.t = simplet($2);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   gcnlist tname gctnlist
    {
        $$.t = simplet(typebitor($2, $3));
        $$.c = simplec($1|$3);
        $$.t = garbt($$.t, $1|$3);
    }
@

<<function typebitor>>=
//@Scheck: used by cc.y
long typebitor(long a, long b)
{
    long c;

    c = a | b;
    if(a & b)
        if((a & b) == BLONG)
            c |= BVLONG;		/* long long => vlong */
        else
            warn(Z, "once is enough: %Q", a & b);
    return c;
}
@


<<type declarations>>=
%type   <lval>  gctnlist gcnlist zgnlist
@

<<types rules>>=
gctnlist:
    gctname
|   gctnlist gctname { $$ = typebitor($1, $2); }

zgnlist:
 /* empty */       { $$ = 0; }
|   zgnlist gname  { $$ = typebitor($1, $2); }

gcnlist:
    gcname
|   gcnlist gcname { $$ = typebitor($1, $2); }
@




<<function simplet>>=
Type*
simplet(long b)
{

    b &= ~BCLASS & ~BGARB;
    switch(b) {
    case BCHAR:
    case BCHAR|BSIGNED:
        return types[TCHAR];

    case BCHAR|BUNSIGNED:
        return types[TUCHAR];

    case BSHORT:
    case BSHORT|BINT:
    case BSHORT|BSIGNED:
    case BSHORT|BINT|BSIGNED:
        return types[TSHORT];

    case BUNSIGNED|BSHORT:
    case BUNSIGNED|BSHORT|BINT:
        return types[TUSHORT];

    case 0:
    case BINT:
    case BINT|BSIGNED:
    case BSIGNED:
        return types[TINT];

    case BUNSIGNED:
    case BUNSIGNED|BINT:
        return types[TUINT];

    case BLONG:
    case BLONG|BINT:
    case BLONG|BSIGNED:
    case BLONG|BINT|BSIGNED:
        return types[TLONG];

    case BUNSIGNED|BLONG:
    case BUNSIGNED|BLONG|BINT:
        return types[TULONG];

    case BVLONG|BLONG:
    case BVLONG|BLONG|BINT:
    case BVLONG|BLONG|BSIGNED:
    case BVLONG|BLONG|BINT|BSIGNED:
        return types[TVLONG];

    case BVLONG|BLONG|BUNSIGNED:
    case BVLONG|BLONG|BINT|BUNSIGNED:
        return types[TUVLONG];

    case BFLOAT:
        return types[TFLOAT];

    case BDOUBLE:
    case BDOUBLE|BLONG:
    case BFLOAT|BLONG:
        return types[TDOUBLE];

    case BVOID:
        return types[TVOID];
    }

    diag(Z, "illegal combination of types %Q", b);
    return types[TINT];
}
@


<<function simplec>>=
//@Scheck: used by cc.y
int simplec(long b)
{

    b &= BCLASS;
    switch(b) {
    case 0:
    case BREGISTER:
        return CXXX;
    case BAUTO:
    case BAUTO|BREGISTER:
        return CAUTO;
    case BEXTERN:
        return CEXTERN;
    case BEXTERN|BREGISTER:
        return CEXREG;
    case BSTATIC:
        return CSTATIC;
    case BTYPEDEF:
        return CTYPEDEF;
    case BTYPESTR:
        return CTYPESTR;
    }
    diag(Z, "illegal combination of classes %Q", b);
    return CXXX;
}
@


<<function garbt>>=
//@Scheck: used by cc.y
Type* garbt(Type *t, long b)
{
    Type *t1;

    if(b & BGARB) {
        t1 = copytyp(t);
        t1->garb = simpleg(b);
        return t1;
    }
    return t;
}
@

<<function simpleg>>=
int
simpleg(long b)
{

    b &= BGARB;
    switch(b) {
    case BCONSTNT:
        return GCONSTNT;
    case BVOLATILE:
        return GVOLATILE;
    case BVOLATILE|BCONSTNT:
        return GCONSTNT|GVOLATILE;
    }
    return GXXX;
}
@

\subsection{Complex types}

<<types rule>>=
|  complex
    {
        $$.t = $1;
        $$.c = CXXX;
    }
|  complex gctnlist
    {
        $$.t = $1;
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
        if($2 & ~BCLASS & ~BGARB)
            diag(Z, "duplicate types given: %T and %Q", $1, $2);
    }
|   gcnlist complex zgnlist
    {
        $$.t = $2;
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1|$3);
    }
@
%$

<<types rules>>=
<<complex rule>>
@

<<type declarations>>=
%type   <type>  complex
@

\subsection{Typedefs}

% uses
<<complex rule>>=
complex:
    LTYPE { $$ = tcopy($1->type); }
@
%$

<<function tcopy>>=
/*
 * make a copy of a typedef
 * the problem is to split out incomplete
 * arrays so that it is in the variable
 * rather than the typedef.
 */
Type*
tcopy(Type *t)
{
    Type *tl, *tx;
    int et;

    if(t == T)
        return t;
    et = t->etype;
    if(typesu[et])
        return t;
    tl = tcopy(t->link);
    if(tl != t->link ||
      (et == TARRAY && t->width == 0)) {
        tx = copytyp(t);
        tx->link = tl;
        return tx;
    }
    return t;
}
@


% defs ?



\subsection{Structures and unions}

<<type declarations>>=
%type   <sym>   ltag
@

%use
<<complex rule>>=
|   LSTRUCT ltag
    {
        dotag($2, TSTRUCT, 0);
        $$ = $2->suetag;
    }
|   LUNION ltag
    {
        dotag($2, TUNION, 0);
        $$ = $2->suetag;
    }
@

% when the name refers to a tag, lookup its final def
% sue? structure union enum?
<<[[Sym]] other fields>>=
Type*	suetag;
@
% rename sue_tag_type?

<<[[Type]] other fields>>=
Sym*	tag;
@
% mutual ref


% depth of struct
<<[[Sym]] other fields>>=
ushort	sueblock;
@

% LP split bn != 0
<<function dotag>>=
//@Scheck: used by cc.y
Type* dotag(Sym *s, int et, int bn)
{
    Decl *d;

    if(bn != 0 && bn != s->sueblock) {
        d = push();
        d->sym = s;
        d->val = DSUE;
        d->type = s->suetag;
        d->block = s->sueblock;
        s->suetag = T;
    }

    if(s->suetag == T) {
        s->suetag = typ(et, T);
        s->sueblock = autobn;
    }
    if(s->suetag->etype != et)
        diag(Z, "tag used for more than one type: %s",
            s->name);

    if(s->suetag->tag == S)
        s->suetag->tag = s;
    return s->suetag;
}
@


<<names rules>>=
tag:
    ltag
    {
        $$ = new(ONAME, Z, Z);
        $$->sym = $1;

        $$->type = $1->type;
        $$->etype = TVOID;
        if($$->type != T)
            $$->etype = $$->type->etype;

        $$->xoffset = $1->offset;
        $$->class = $1->class;
    }
@
% similar to name rule

<<names rules>>=
ltag:
    LNAME
|   LTYPE
@


% defs
<<complex rule>>=
|   LSTRUCT ltag
    {
        dotag($2, TSTRUCT, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        sualign($$);
    }
|   LUNION ltag
    {
        dotag($2, TUNION, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        sualign($$);
    }
@
%$

% sualign() explained later in code gen chapter, alignment section


<<global taggen>>=
//@Scheck: used by cc.y
int	taggen;
@

% anon defs
<<complex rule>>=
|   LSTRUCT sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TSTRUCT, autobn);
        $$->link = $2;
        sualign($$);
    }
|   LUNION sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TUNION, autobn);
        $$->link = $2;
        sualign($$);
    }
@





<<type declarations>>=
%type   <type> sbody
@

<<[[union yacc]] other fields>>=
struct
{
    Type*   t1;
    Type*   t2;
    Type*   t3;
    uchar   c;
} tyty;
@

<<global strf>>=
Type*	strf;
@

<<global strl>>=
Type*	strl;
@

<<global firstbit>>=
long	firstbit;
@

<<global lastbit>>=
long	lastbit;
@

<<types rule>>=
sbody:
    '{'
    {
        $<tyty>$.t1 = strf;
        $<tyty>$.t2 = strl;
        $<tyty>$.t3 = lasttype;
        $<tyty>$.c = lastclass;
        strf = T;
        strl = T;
        lastbit = 0;
        firstbit = 1;
        lastclass = CXXX;
        lasttype = T;
    }
    edecl 
    '}'
    {
        $$ = strf;
        strf = $<tyty>2.t1;
        strl = $<tyty>2.t2;
        lasttype = $<tyty>2.t3;
        lastclass = $<tyty>2.c;
    }

@
%$




<<structure element declarator rules>>=
/*
 * structure element declarator
 */
edecl:
    tlist
    {
        lasttype = $1;
    }
    zedlist ';'
|   edecl tlist
    {
        lasttype = $2;
    }
    zedlist ';'

zedlist:                    /* extension */
 /* empty */
    {
        lastfield = 0;
        edecl(CXXX, lasttype, S);
    }
|   edlist

edlist:
    edecor            { dodecl(edecl, CXXX, lasttype, $1); }
|   edlist ',' edlist

edecor:
    xdecor
    {
        lastbit = 0;
        firstbit = 1;
    }
|   tag ':' lexpr   { $$ = new(OBIT, $1, $3); }
|   ':' lexpr       { $$ = new(OBIT, Z, $2); }
@
%$

<<global lastfield>>=
long	lastfield;
@


<<function edecl>>=
//@Scheck: used by cc.y
void edecl(int c, Type *t, Sym *s)
{
    Type *t1;

    if(s == S) {
        if(!typesu[t->etype])
            diag(Z, "unnamed structure element must be struct/union");
        if(c != CXXX)
            diag(Z, "unnamed structure element cannot have class");
    } else
        if(c != CXXX)
            diag(Z, "structure element cannot have class: %s", s->name);
    t1 = t;
    t = copytyp(t1);
    t->sym = s;
    t->down = T;
    if(lastfield) {
        t->shift = lastbit - lastfield;
        t->nbits = lastfield;
        if(firstbit)
            t->shift = -t->shift;
        if(typeu[t->etype])
            t->etype = tufield->etype;
        else
            t->etype = tfield->etype;
    }
    if(strf == T)
        strf = t;
    else
        strl->down = t;
    strl = t;
}
@


\subsection{Enum}

<<struct En>>=
struct En
{
    Type*	tenum;		/* type of entire enum */

    Type*	cenum;		/* type of current enum run */

    vlong	lastenum;	/* value of current enum */
    double	floatenum;	/* value of current enum */ // for floats enums
};
@
% vlong! so can have 64 bitsets

<<global en>>=
struct En en;
@


% same dotag than for struct/union, cos same namespace
<<complex rule>>=
|   LENUM ltag
    {
        dotag($2, TENUM, 0);
        $$ = $2->suetag;
        if($$->link == T)
            $$->link = types[TINT];
        $$ = $$->link;
    }
|   LENUM ltag
    {
        dotag($2, TENUM, autobn);
    }
    '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum 
     '}'
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        if(en.tenum == T) {
            diag(Z, "enum type ambiguous: %s", $2->name);
            en.tenum = types[TINT];
        }
        $$->link = en.tenum;
        $$ = en.tenum;
    }
|   LENUM '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum '}'
    {
        $$ = en.tenum;
    }
@

<<types rules>>=
enum:
    LNAME           { doenum($1, Z); }
|   LNAME '=' expr  { doenum($1, $3); }
|   enum ','
|   enum ',' enum
@
%$



% ref to type of enum for each constants symbols of the enum?
<<[[Sym]] other fields>>=
// ref<Type>
Type*	tenum;
@


% n = optional expression for the value of the enum constant
<<function doenum>>=
//@Scheck: used by cc.y
void doenum(Sym *s, Node *n)
{

    if(n) {
        complex(n);
        if(n->op != OCONST) {
            diag(n, "enum not a constant: %s", s->name);
            return;
        }
        en.cenum = n->type;
        en.tenum = maxtype(en.cenum, en.tenum);

        if(!typefd[en.cenum->etype])
            en.lastenum = n->vconst;
        else
            en.floatenum = n->fconst;
    }
    if(dclstack)
        push1(s);
    xdecl(CXXX, types[TENUM], s);

    if(en.cenum == T) {
        en.tenum = types[TINT];
        en.cenum = types[TINT];
        en.lastenum = 0;
    }
    s->tenum = en.cenum;

    if(!typefd[s->tenum->etype]) {
        s->vconst = convvtox(en.lastenum, s->tenum->etype);
        en.lastenum++;
    } else {
        s->fconst = en.floatenum;
        en.floatenum++;
    }

    if(debug['d'])
        dbgdecl(s);
    acidvar(s);
}
@

<<function maxtype>>=
/*
 * this routine is very suspect.
 * ansi requires the enum type to
 * be represented as an 'int'
 * this means that 0x81234567
 * would be illegal. this routine
 * makes signed and unsigned go
 * to unsigned.
 */
Type*
maxtype(Type *t1, Type *t2)
{

    if(t1 == T)
        return t2;
    if(t2 == T)
        return t1;
    if(t1->etype > t2->etype)
        return t1;
    return t2;
}
@


\section{Declarations and definitions, part two}

<<constant NODECL>>=
#define	NODECL	((void(*)(int, Type*, Sym*))nil)
@

<<function dodecl>>=
Node*
dodecl(void (*f)(int,Type*,Sym*), int c, Type *t, Node *n)
{
    Sym *s;
    Node *n1;
    long v;

    nearln = lineno;
    lastfield = 0;

loop:
    if(n != Z)
    switch(n->op) {
    default:
        diag(n, "unknown declarator: %O", n->op);
        break;

    case OARRAY:
        t = typ(TARRAY, t);
        t->width = 0;
        n1 = n->right;
        n = n->left;
        if(n1 != Z) {
            complex(n1);
            v = -1;
            if(n1->op == OCONST)
                v = n1->vconst;
            if(v <= 0) {
                diag(n, "array size must be a positive constant");
                v = 1;
            }
            t->width = v * t->link->width;
        }
        goto loop;

    case OIND:
        t = typ(TIND, t);
        t->garb = n->garb;
        n = n->left;
        goto loop;

    case OFUNC:
        t = typ(TFUNC, t);
        t->down = fnproto(n);
        n = n->left;
        goto loop;

    case OBIT:
        n1 = n->right;
        complex(n1);
        lastfield = -1;
        if(n1->op == OCONST)
            lastfield = n1->vconst;
        if(lastfield < 0) {
            diag(n, "field width must be non-negative constant");
            lastfield = 1;
        }
        if(lastfield == 0) {
            lastbit = 0;
            firstbit = 1;
            if(n->left != Z) {
                diag(n, "zero width named field");
                lastfield = 1;
            }
        }
        if(!typei[t->etype]) {
            diag(n, "field type must be int-like");
            t = types[TINT];
            lastfield = 1;
        }
        if(lastfield > tfield->width*8) {
            diag(n, "field width larger than field unit");
            lastfield = 1;
        }
        lastbit += lastfield;
        if(lastbit > tfield->width*8) {
            lastbit = lastfield;
            firstbit = 1;
        }
        n = n->left;
        goto loop;

    case ONAME:
        if(f == NODECL)
            break;
        s = n->sym;
        (*f)(c, t, s);
        if(s->class == CLOCAL)
            s = mkstatic(s);
        firstbit = 0;
        n->sym = s;
        n->type = s->type;
        n->xoffset = s->offset;
        n->class = s->class;
        n->etype = TVOID;
        if(n->type != T)
            n->etype = n->type->etype;
        if(debug['d'])
            dbgdecl(s);
        acidvar(s);
        s->varlineno = lineno;
        break;
    }

    lastdcl = t;
    return n;
}
@



<<function xdecl>>=
void
xdecl(int c, Type *t, Sym *s)
{
    long o;

    o = 0;
    switch(c) {
    case CEXREG:
        o = exreg(t);
        if(o == 0)
            c = CEXTERN;
        if(s->class == CGLOBL)
            c = CGLOBL;
        break;

    case CEXTERN:
        if(s->class == CGLOBL)
            c = CGLOBL;
        break;

    case CXXX:
        c = CGLOBL;
        if(s->class == CEXTERN)
            s->class = CGLOBL;
        break;

    case CAUTO:
        diag(Z, "overspecified class: %s %s %s", s->name, cnames[c], cnames[s->class]);
        c = CEXTERN;
        break;

    case CTYPESTR:
        if(!typesuv[t->etype]) {
            diag(Z, "typestr must be struct/union: %s", s->name);
            break;
        }
        dclfunct(t, s);
        break;
    }

    if(s->class == CSTATIC)
        if(c == CEXTERN || c == CGLOBL) {
            warn(Z, "overspecified class: %s %s %s", s->name, cnames[c], cnames[s->class]);
            c = CSTATIC;
        }
    if(s->type != T)
        if(s->class != c || !sametype(t, s->type) || t->etype == TENUM) {
            diag(Z, "external redeclaration of: %s", s->name);
            Bprint(&diagbuf, "	%s %T %L\n", cnames[c], t, nearln);
            Bprint(&diagbuf, "	%s %T %L\n", cnames[s->class], s->type, s->varlineno);
        }
    tmerge(t, s);
    s->type = t;
    s->class = c;
    s->block = 0;
    s->offset = o;
}
@





\subsection{External declarator}

<<external declarator rules>>=
xdlist:
    xdecor  { dodecl(xdecl, lastclass, lasttype, $1); }
|   xdecor
    {
        $1 = dodecl(xdecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        doinit($1->sym, $1->type, 0L, $4);
    }
|   xdlist ',' xdlist

xdecor:
    xdecor2
|   '*' zgnlist xdecor
    {
        $$ = new(OIND, $3, Z);
        $$->garb = simpleg($2);
    }

xdecor2:
    tag
|   '(' xdecor ')'             { $$ = $2;   }
|   xdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
|   xdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }
@
%$

<<ebnf grammar rules>>=
zctlist:
 /* empty */
    {
        lastclass = CXXX;
        lasttype = types[TINT];
    }
|   ctlist
@

<<extra grammar rules>>=
ctlist:
    types
    {
        lasttype = $1.t;
        lastclass = $1.c;
    }
@
% it's not really types, it's types_and_storage really

\subsection{Automatic declarator}

<<automatic declarator rules>>=
/*
 * automatic declarator
 */
adecl:
    ctlist ';'        { $$ = dodecl(adecl, lastclass, lasttype, Z); }
|   ctlist adlist ';' { $$ = $2; }

adlist:
    xdecor
    {
        dodecl(adecl, lastclass, lasttype, $1);
        $$ = Z;
    }
|   xdecor
    {
        $1 = dodecl(adecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        long w;

        w = $1->sym->type->width;
        $$ = doinit($1->sym, $1->type, 0L, $4);
        $$ = contig($1->sym, $$, w);
    }
|   adlist ',' adlist
    {
        $$ = $1;
        if($3 != Z) {
            $$ = $3;
            if($1 != Z)
                $$ = new(OLIST, $1, $3);
        }
    }
@
%$


<<function adecl>>=
void
adecl(int c, Type *t, Sym *s)
{

    if(c == CSTATIC)
        c = CLOCAL;
    if(t->etype == TFUNC) {
        if(c == CXXX)
            c = CEXTERN;
        if(c == CLOCAL)
            c = CSTATIC;
        if(c == CAUTO || c == CEXREG)
            diag(Z, "function cannot be %s %s", cnames[c], s->name);
    }
    if(c == CXXX)
        c = CAUTO;
    if(s) {
        if(s->class == CSTATIC)
            if(c == CEXTERN || c == CGLOBL) {
                warn(Z, "just say static: %s", s->name);
                c = CSTATIC;
            }
        if(s->class == CAUTO || s->class == CPARAM || s->class == CLOCAL)
        if(s->block == autobn)
            diag(Z, "auto redeclaration of: %s", s->name);
        if(c != CPARAM)
            push1(s);
        s->block = autobn;
        s->offset = 0;
        s->type = t;
        s->class = c;
        s->aused = 0;
    }
    switch(c) {
    case CAUTO:
        autoffset = align(autoffset, t, Aaut3);
        stkoff = maxround(stkoff, autoffset);
        s->offset = -autoffset;
        break;

    case CPARAM:
        if(autoffset == 0) {
            firstarg = s;
            firstargtype = t;
        }
        autoffset = align(autoffset, t, Aarg1);
        if(s)
            s->offset = autoffset;
        autoffset = align(autoffset, t, Aarg2);
        break;
    }
}
@



<<function contig>>=
//@Scheck: used by cc.y
Node* contig(Sym *s, Node *n, long v)
{
    Node *p, *r, *q, *m;
    long w;
    Type *zt;

    if(debug['i']) {
        print("contig v = %ld; s = %s\n", v, s->name);
        prtree(n, "doinit value");
    }

    if(n == Z)
        goto no;
    w = s->type->width;

    /*
     * nightmare: an automatic array whose size
     * increases when it is initialized
     */
    if(v != w) {
        if(v != 0)
            diag(n, "automatic adjustable array: %s", s->name);
        v = s->offset;
        autoffset = align(autoffset, s->type, Aaut3);
        s->offset = -autoffset;
        stkoff = maxround(stkoff, autoffset);
        symadjust(s, n, v - s->offset);
    }
    if(w <= ewidth[TIND])
        goto no;
    if(n->op == OAS)
        diag(Z, "oops in contig");
/*ZZZ this appears incorrect
need to check if the list completely covers the data.
if not, bail
 */
    if(n->op == OLIST)
        goto no;
    if(n->op == OASI)
        if(n->left->type)
        if(n->left->type->width == w)
            goto no;
    while(w & (ewidth[TIND]-1))
        w++;
/*
 * insert the following code, where long becomes vlong if pointers are fat
 *
    *(long**)&X = (long*)((char*)X + sizeof(X));
    do {
        *(long**)&X -= 1;
        **(long**)&X = 0;
    } while(*(long**)&X);
 */

    for(q=n; q->op != ONAME; q=q->left)
        ;

    zt = ewidth[TIND] > ewidth[TLONG]? types[TVLONG]: types[TLONG];

    p = new(ONAME, Z, Z);
    *p = *q;
    p->type = typ(TIND, zt);
    p->xoffset = s->offset;

    r = new(ONAME, Z, Z);
    *r = *p;
    r = new(OPOSTDEC, r, Z);

    q = new(ONAME, Z, Z);
    *q = *p;
    q = new(OIND, q, Z);

    m = new(OCONST, Z, Z);
    m->vconst = 0;
    m->type = zt;

    q = new(OAS, q, m);

    r = new(OLIST, r, q);

    q = new(ONAME, Z, Z);
    *q = *p;
    r = new(ODWHILE, q, r);

    q = new(ONAME, Z, Z);
    *q = *p;
    q->type = q->type->link;
    q->xoffset += w;
    q = new(OADDR, q, 0);

    q = new(OASI, p, q);
    r = new(OLIST, q, r);

    n = new(OLIST, r, n);

no:
    return n;
}
@


<<function symadjust>>=
void
symadjust(Sym *s, Node *n, long del)
{

    switch(n->op) {
    default:
        if(n->left)
            symadjust(s, n->left, del);
        if(n->right)
            symadjust(s, n->right, del);
        return;

    case ONAME:
        if(n->sym == s)
            n->xoffset -= del;
        return;

    case OCONST:
    case OSTRING:
    case OLSTRING:
    case OINDREG:
    case OREGISTER:
        return;
    }
}
@


\subsection{Abstract declarator}

<<abstract declarator rules>>=
/*
 * abstract declarator
 */
abdecor:
  /* empty */ { $$ = Z; }
|   abdecor1

abdecor1:
    '*' zgnlist
    {
        $$ = new(OIND, (Z), Z);
        $$->garb = simpleg($2);
    }
|   '*' zgnlist abdecor1
    {
        $$ = new(OIND, $3, Z);
        $$->garb = simpleg($2);
    }
|   abdecor2

abdecor2:
    abdecor3
|   abdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
|   abdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }

abdecor3:
    '(' ')'           { $$ = new(OFUNC, Z, Z); }
|   '[' zexpr ']'     { $$ = new(OARRAY, Z, $2); }
|   '(' abdecor1 ')'  { $$ = $2; }
@
%$




\section{Helpers}

% invert in place
<<function invert>>=
Node*
invert(Node *n)
{
    Node *i;

    if(n == Z || n->op != OLIST)
        return n;
    i = n;
    for(n = n->left; n != Z; n = n->left) {
        if(n->op != OLIST)
            break;
        i->left = n->right;
        n->right = i;
        i = n;
    }
    i->left = n;
    return i;
}
@


\chapter{Checking}

\section{Overview}

% - symbol resolution (use/def matching correctly), lookup failure
%   with scoping rules
% - typechecking rules
% - lint rules (e.g. unused local, unused param, and dead code?)

% a few warn() seen before, 
%  - in revertdcl: unused vars, unused labels, 
%  - in lexer: sign-extended char? truncated constant?
%  - in grammar: empty body of if
%  - in ast builder helper: CAST in initialization ignored?? 
%    initialize pointer to an integer?
%    duplicated keywords for storage or qualifier or type
%    overspecified class? just say static?

% a few later:
%  - div by zero in evconst()

\section{Printing warnings, [[8c -w]], [[8c -W]]}

% 8c -w
% 8c -W give full verbose diagnostic

<<function warn>>=
void
warn(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    if(debug['w'] || debug['W']) {
        va_start(arg, fmt);
        vseprint(buf, buf+sizeof(buf), fmt, arg);
        va_end(arg);

        if(debug['W']) {
            diag(n, "%s", buf);
            return;
        }

        Bprint(&diagbuf, "warning: %L %s\n", (n==Z)? nearln : n->lineno, buf);

        if(n != Z)
          if(debug['v'])
            prtree(n, "warning");
    }
}
@

<<function fatal>>=
void
fatal(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
      if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    errorexit();
}
@

\section{Symbol resolution}
% done in parsing, as C force to forward decl everything
% (and actual linking is done in linker to find inconsistencies)

\section{Scoping}

% see Decl section and markdcl and revertdecl

\section{Typechecking}

\subsection{Overview}

% and scoping and symbol resolution?

% remember type field in Node

% balancing = make each type match for operands, so int+long => long+long
% and so imply some form of promotion




% complex? compile lexical? called by?
<<function complex>>=
void
complex(Node *n)
{

    if(n == Z)
        return;

    nearln = n->lineno;

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "pre complex");

    if(tcom(n))
        return;



    //if(debug['y'] || true)
    comma(n);

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "t complex");

    ccom(n);

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "c complex");

    acom(n);

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "a complex");

    xcom(n);

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "x complex");
}
@



\subsection{Type helpers}


<<global typei>>=
char	typei[NTYPE];
@

<<global typeiinit>>=
int	typeiinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TVLONG, TUVLONG, -1,
};
@


<<global typeu>>=
char	typeu[NTYPE];
@

<<global typeuinit>>=
int	typeuinit[] =
{
    TUCHAR, TUSHORT, TUINT, TULONG, TUVLONG, TIND, -1,
};
@



<<global typeilp>>=
char	typeilp[NTYPE];
@

<<global typeilpinit>>=
int	typeilpinit[] =
{
    TINT, TUINT, TLONG, TULONG, TIND, -1
};
@



<<global typechlpfd>>=
char	typechlpfd[NTYPE];
@

<<global typechlpfdinit>>=
int	typechlpfdinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TFLOAT, TDOUBLE, TIND, -1,
};
@





<<global typec>>=
char	typec[NTYPE];
@

<<global typecinit>>=
int	typecinit[] =
{
    TCHAR, TUCHAR, -1
};
@



<<global typeh>>=
char	typeh[NTYPE];
@

<<global typehinit>>=
int	typehinit[] =
{
    TSHORT, TUSHORT, -1,
};
@




<<global typeil>>=
char	typeil[NTYPE];
@

<<global typeilinit>>=
int	typeilinit[] =
{
    TINT, TUINT, TLONG, TULONG, -1,
};
@



<<global typev>>=
char	typev[NTYPE];
@

<<global typevinit>>=
int	typevinit[] =
{
    TVLONG,	TUVLONG, -1,
};
@





<<global typefd>>=
char	typefd[NTYPE];
@

<<global typefdinit>>=
int	typefdinit[] =
{
    TFLOAT, TDOUBLE, -1,
};
@



<<global typeaf>>=
char	typeaf[NTYPE];
@

<<global typeafinit>>=
int	typeafinit[] =
{
    TFUNC, TARRAY, -1,
};
@




<<global typesu>>=
char	typesu[NTYPE];
@

<<global typesuinit>>=
int	typesuinit[] =
{
    TSTRUCT, TUNION, -1,
};
@





% set of type supported for switch argument
% todo use array of bool instead
<<global typeswitch>>=
// set<txxx>
char*	typeswitch;
@

<<global typeword>>=
// set<txxx>
char*	typeword;
@

% set of complex types
<<global typecmplx>>=
// set<txxx>
char*	typecmplx;
@

%    /* 32-bit defaults */
%    typeword = typechlp;
%    typeswitch = typechl;
%    typecmplx = typesuv;



<<global typechl>>=
char	typechl[NTYPE];
@

<<global typechlv>>=
char	typechlv[NTYPE];
@

<<global typechlvp>>=
char typechlvp[NTYPE];
@

<<global typechlinit>>=
int	typechlinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, -1,
};
@






<<global typechlp>>=
char	typechlp[NTYPE];
@

<<global typechlpinit>>=
int	typechlpinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TIND, -1,
};
@
% added TIND!




<<global typesuv>>=
// bool
char	typesuv[NTYPE];
@

<<global typesuvinit>>=
int	typesuvinit[] =
{
    TVLONG, TUVLONG, TSTRUCT, TUNION, -1,
};
@




<<function tinit>>=
void
tinit(void)
{
    int *ip;
    Init *p;

    for(p=thashinit; p->code >= 0; p++) {
        urk("thash", nelem(thash), p->code);
        thash[p->code] = p->value;
    }
    for(p=bnamesinit; p->code >= 0; p++) {
        urk("bnames", nelem(bnames), p->code);
        bnames[p->code] = p->s;
    }
    for(p=tnamesinit; p->code >= 0; p++) {
        urk("tnames", nelem(tnames), p->code);
        tnames[p->code] = p->s;
    }
    for(p=gnamesinit; p->code >= 0; p++) {
        urk("gnames", nelem(gnames), p->code);
        gnames[p->code] = p->s;
    }
    for(p=qnamesinit; p->code >= 0; p++) {
        urk("qnames", nelem(qnames), p->code);
        qnames[p->code] = p->s;
    }
    for(p=cnamesinit; p->code >= 0; p++) {
        urk("cnames", nelem(cnames), p->code);
        cnames[p->code] = p->s;
    }
    for(p=onamesinit; p->code >= 0; p++) {
        urk("onames", nelem(onames), p->code);
        onames[p->code] = p->s;
    }
    for(ip=typeiinit; *ip>=0; ip++) {
        urk("typei", nelem(typei), *ip);
        typei[*ip] = 1;
    }
    for(ip=typeuinit; *ip>=0; ip++) {
        urk("typeu", nelem(typeu), *ip);
        typeu[*ip] = 1;
    }
    for(ip=typesuvinit; *ip>=0; ip++) {
        urk("typesuv", nelem(typesuv), *ip);
        typesuv[*ip] = true;
    }
    for(ip=typeilpinit; *ip>=0; ip++) {
        urk("typeilp", nelem(typeilp), *ip);
        typeilp[*ip] = 1;
    }
    for(ip=typechlinit; *ip>=0; ip++) {
        urk("typechl", nelem(typechl), *ip);
        typechl[*ip] = 1;
        typechlv[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typechlpinit; *ip>=0; ip++) {
        urk("typechlp", nelem(typechlp), *ip);
        typechlp[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typechlpfdinit; *ip>=0; ip++) {
        urk("typechlpfd", nelem(typechlpfd), *ip);
        typechlpfd[*ip] = 1;
    }
    for(ip=typecinit; *ip>=0; ip++) {
        urk("typec", nelem(typec), *ip);
        typec[*ip] = 1;
    }
    for(ip=typehinit; *ip>=0; ip++) {
        urk("typeh", nelem(typeh), *ip);
        typeh[*ip] = 1;
    }
    for(ip=typeilinit; *ip>=0; ip++) {
        urk("typeil", nelem(typeil), *ip);
        typeil[*ip] = 1;
    }
    for(ip=typevinit; *ip>=0; ip++) {
        urk("typev", nelem(typev), *ip);
        typev[*ip] = 1;
        typechlv[*ip] = 1;
        typechlvp[*ip] = 1;
    }
    for(ip=typefdinit; *ip>=0; ip++) {
        urk("typefd", nelem(typefd), *ip);
        typefd[*ip] = 1;
    }
    for(ip=typeafinit; *ip>=0; ip++) {
        urk("typeaf", nelem(typeaf), *ip);
        typeaf[*ip] = 1;
    }
    for(ip=typesuinit; *ip >= 0; ip++) {
        urk("typesu", nelem(typesu), *ip);
        typesu[*ip] = 1;
    }


    for(p=tasigninit; p->code >= 0; p++) {
        urk("tasign", nelem(tasign), p->code);
        tasign[p->code] = p->value;
    }
    for(p=tasaddinit; p->code >= 0; p++) {
        urk("tasadd", nelem(tasadd), p->code);
        tasadd[p->code] = p->value;
    }
    for(p=tcastinit; p->code >= 0; p++) {
        urk("tcast", nelem(tcast), p->code);
        tcast[p->code] = p->value;
    }
    for(p=taddinit; p->code >= 0; p++) {
        urk("tadd", nelem(tadd), p->code);
        tadd[p->code] = p->value;
    }
    for(p=tsubinit; p->code >= 0; p++) {
        urk("tsub", nelem(tsub), p->code);
        tsub[p->code] = p->value;
    }
    for(p=tmulinit; p->code >= 0; p++) {
        urk("tmul", nelem(tmul), p->code);
        tmul[p->code] = p->value;
    }
    for(p=tandinit; p->code >= 0; p++) {
        urk("tand", nelem(tand), p->code);
        tand[p->code] = p->value;
    }
    for(p=trelinit; p->code >= 0; p++) {
        urk("trel", nelem(trel), p->code);
        trel[p->code] = p->value;
    }
    
    /* 32-bit defaults */
    typeword = typechlp;
    typeswitch = typechl;
    typecmplx = typesuv;
}
@

<<function urk>>=
void
urk(char *name, int max, int i)
{
    if(i >= max) {
        fprint(2, "bad tinit: %s %d>=%d\n", name, i, max);
        exits("init");
    }
}
@

\subsection{Type compatibility}

<<function stcompat>>=
bool
stcompat(Node *n, Type *t1, Type *t2, long ttab[])
{
    int i;
    ulong b;

    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1L << i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ttab[i]) {
        if(ttab == tasign)
            if(b == BSTRUCT || b == BUNION)
                if(!sametype(t1, t2))
                    return true;
        if(n->op != OCAST)
          if(b == BIND && i == TIND)
                if(!sametype(t1, t2))
                    return true;
        return false;
    }
    return true;
}
@

<<function tcompat>>=
bool
tcompat(Node *n, Type *t1, Type *t2, long ttab[])
{

    if(stcompat(n, t1, t2, ttab)) {
        if(t1 == T)
            diag(n, "incompatible type: \"%T\" for op \"%O\"",
                t2, n->op);
        else
            diag(n, "incompatible types: \"%T\" and \"%T\" for op \"%O\"",
                t1, t2, n->op);
        return true;
    }
    return false;
}
@



% passed to tcompat
<<global tasign>>=
long	tasign[NTYPE];
@

<<global tasigninit>>=
Init	tasigninit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BIND,		0,
    TSTRUCT,	BSTRUCT,	0,
    TUNION,		BUNION,		0,
    -1,		0,		0,
};
@

<<global tasadd>>=
long	tasadd[NTYPE];
@

<<global tasaddinit>>=
Init	tasaddinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

<<global tcast>>=
long	tcast[NTYPE];
@

<<global tcastinit>>=
Init	tcastinit[] =
{
    TCHAR,		BNUMBER|BIND|BVOID,	0,
    TUCHAR,		BNUMBER|BIND|BVOID,	0,
    TSHORT,		BNUMBER|BIND|BVOID,	0,
    TUSHORT,	BNUMBER|BIND|BVOID,	0,
    TINT,		BNUMBER|BIND|BVOID,	0,
    TUINT,		BNUMBER|BIND|BVOID,	0,
    TLONG,		BNUMBER|BIND|BVOID,	0,
    TULONG,		BNUMBER|BIND|BVOID,	0,
    TVLONG,		BNUMBER|BIND|BVOID,	0,
    TUVLONG,	BNUMBER|BIND|BVOID,	0,
    TFLOAT,		BNUMBER|BVOID,		0,
    TDOUBLE,	BNUMBER|BVOID,		0,
    TIND,		BINTEGER|BIND|BVOID,	0,
    TVOID,		BVOID,			0,
    TSTRUCT,	BSTRUCT|BVOID,		0,
    TUNION,		BUNION|BVOID,		0,
    -1,		0,			0,
};
@

<<global tadd>>=
long	tadd[NTYPE];
@

<<global taddinit>>=
Init	taddinit[] =
{
    TCHAR,		BNUMBER|BIND,	0,
    TUCHAR,		BNUMBER|BIND,	0,
    TSHORT,		BNUMBER|BIND,	0,
    TUSHORT,	BNUMBER|BIND,	0,
    TINT,		BNUMBER|BIND,	0,
    TUINT,		BNUMBER|BIND,	0,
    TLONG,		BNUMBER|BIND,	0,
    TULONG,		BNUMBER|BIND,	0,
    TVLONG,		BNUMBER|BIND,	0,
    TUVLONG,	BNUMBER|BIND,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER,	0,
    -1,		0,		0,
};
@

<<global tsub>>=
long	tsub[NTYPE];
@

<<global tsubinit>>=
Init	tsubinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BINTEGER|BIND,	0,
    -1,		0,		0,
};
@

<<global tmul>>=
long	tmul[NTYPE];
@

<<global tmulinit>>=
Init	tmulinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    -1,		0,		0,
};
@

<<global tand>>=
long	tand[NTYPE];
@

<<global tandinit>>=
Init	tandinit[] =
{
    TCHAR,		BINTEGER,	0,
    TUCHAR,		BINTEGER,	0,
    TSHORT,		BINTEGER,	0,
    TUSHORT,	BINTEGER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BINTEGER,	0,
    TULONG,		BINTEGER,	0,
    TVLONG,		BINTEGER,	0,
    TUVLONG,	BINTEGER,	0,
    -1,		0,		0,
};
@

<<global trel>>=
long	trel[NTYPE];
@

<<global trelinit>>=
Init	trelinit[] =
{
    TCHAR,		BNUMBER,	0,
    TUCHAR,		BNUMBER,	0,
    TSHORT,		BNUMBER,	0,
    TUSHORT,	BNUMBER,	0,
    TINT,		BNUMBER,	0,
    TUINT,		BNUMBER,	0,
    TLONG,		BNUMBER,	0,
    TULONG,		BNUMBER,	0,
    TVLONG,		BNUMBER,	0,
    TUVLONG,	BNUMBER,	0,
    TFLOAT,		BNUMBER,	0,
    TDOUBLE,	BNUMBER,	0,
    TIND,		BIND,		0,
    -1,		0,		0,
};
@

<<global tfunct>>=
long	tfunct[1] =
{
    BFUNC,
};
@

<<global tindir>>=
long	tindir[1] =
{
    BIND,
};
@

<<global tdot>>=
long	tdot[1] =
{
    BSTRUCT|BUNION,
};
@

<<global tnot>>=
long	tnot[1] =
{
    BNUMBER|BIND,
};
@

<<global targ>>=
long	targ[1] =
{
    BNUMBER|BIND|BSTRUCT|BUNION,
};
@



\subsection{[[tcom()]]}
% cc/com.c

<<[[Node]] other fields>>=
// used as a bool to mark lvalues.
// (ab)used as bool for marker of use of labels.
// (ab)used by xcom to assign ``addressibility''.
char	addable;
@

% for context in tcomo?
<<enum _anon_ (cc/com.c)>>=
enum
{
    ADDROF	= 1<<0,
    CASTOF	= 1<<1,
    ADDROP	= 1<<2,
};
@
% evaluate types means type checking and making cast explicits
% lvalue vs rvalue: https://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf)
% (thx charles forsith)

% true means error
<<function tcom>>=
/*
 * evaluate types
 * evaluate lvalues (addable == 1)
 */
bool
tcom(Node *n)
{

    return tcomo(n, ADDROF);
}
@

% true means error
% f = context?
<<function tcomo>>=
bool
tcomo(Node *n, int f)
{
    Node *l, *r;
    Type *t;
    int o;
    static TRune zer;

    if(n == Z) {
        diag(Z, "Z in tcom");
        errorexit();
    }
    n->addable = 0;
    l = n->left;
    r = n->right;

    switch(n->op) {
    case ODOTDOT:
        /*
         * tcom has already been called on this subtree
         */
        *n = *n->left;
        if(n->type == T)
            goto bad;
        break;

    case OCAST:
        if(n->type == T)
            break;
        if(n->type->width == types[TLONG]->width) {
            if(tcomo(l, ADDROF|CASTOF))
                goto bad;
        } else
            if(tcom(l))
                goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, n->type, tcast))
            goto bad;
        break;

    case ORETURN:
        if(l == Z) {
            if(n->type->etype != TVOID)
                warn(n, "null return of a typed function");
            break;
        }
        if(tcom(l))
            goto bad;
        typeext(n->type, l);
        if(tcompat(n, n->type, l->type, tasign))
            break;
        constas(n, n->type, l->type);
        if(!sametype(n->type, l->type)) {
            l = new1(OCAST, l, Z);
            l->type = n->type;
            n->left = l;
        }
        break;

    case OASI:	/* same as as, but no test for const */
        n->op = OAS;
        o = tcom(l);
        if(o | tcom(r))
            goto bad;

        typeext(l->type, r);
        if(tlvalue(l) || tcompat(n, l->type, r->type, tasign))
            goto bad;
        if(!sametype(l->type, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = l->type;
            n->right = r;
        }
        n->type = l->type;
        break;

    case OAS:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext(l->type, r);
        if(tcompat(n, l->type, r->type, tasign))
            goto bad;
        constas(n, l->type, r->type);
        if(!sametype(l->type, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = l->type;
            n->right = r;
        }
        n->type = l->type;
        break;

    case OASADD:
    case OASSUB:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        if(tcompat(n, l->type, r->type, tasadd))
            goto bad;
        constas(n, l->type, r->type);
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        break;

    case OASMUL:
    case OASLMUL:
    case OASDIV:
    case OASLDIV:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        if(tcompat(n, l->type, r->type, tmul))
            goto bad;
        constas(n, l->type, r->type);
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        if(typeu[n->type->etype]) {
            if(n->op == OASDIV)
                n->op = OASLDIV;
            if(n->op == OASMUL)
                n->op = OASLMUL;
        }
        break;

    case OASLSHR:
    case OASASHR:
    case OASASHL:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        n->type = l->type;
        n->right = new1(OCAST, r, Z);
        n->right->type = types[TINT];
        if(typeu[n->type->etype]) {
            if(n->op == OASASHR)
                n->op = OASLSHR;
        }
        break;

    case OASMOD:
    case OASLMOD:
    case OASOR:
    case OASAND:
    case OASXOR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        if(typeu[n->type->etype]) {
            if(n->op == OASMOD)
                n->op = OASLMOD;
        }
        break;

    case OPREINC:
    case OPREDEC:
    case OPOSTINC:
    case OPOSTDEC:
        if(tcom(l))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, types[TINT], tadd))
            goto bad;
        n->type = l->type;
        if(n->type->etype == TIND)
        if(n->type->link->width < 1) {
            snap(n->type->link);
            if(n->type->link->width < 1)
                diag(n, "inc/dec of a void pointer");
        }
        break;

    case OEQ:
    case ONE:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        typeext(l->type, r);
        typeext(r->type, l);
        if(tcompat(n, l->type, r->type, trel))
            goto bad;
        arith(n, 0);
        n->type = types[TINT];
        break;

    case OLT:
    case OGE:
    case OGT:
    case OLE:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        typeext1(r->type, l);
        if(tcompat(n, l->type, r->type, trel))
            goto bad;
        arith(n, 0);
        if(typeu[n->type->etype])
            n->op = logrel[relindex(n->op)];
        n->type = types[TINT];
        break;

    case OCOND:
        o = tcom(l);
        o |= tcom(r->left);
        if(o | tcom(r->right))
            goto bad;
        if(r->right->type->etype == TIND && vconst(r->left) == 0) {
            r->left->type = r->right->type;
            r->left->vconst = 0;
        }
        if(r->left->type->etype == TIND && vconst(r->right) == 0) {
            r->right->type = r->left->type;
            r->right->vconst = 0;
        }
        if(sametype(r->right->type, r->left->type)) {
            r->type = r->right->type;
            n->type = r->type;
            break;
        }
        if(tcompat(r, r->left->type, r->right->type, trel))
            goto bad;
        arith(r, 0);
        n->type = r->type;
        break;

    case OADD:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tadd))
            goto bad;
        arith(n, 1);
        break;

    case OSUB:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tsub))
            goto bad;
        arith(n, 1);
        break;

    case OMUL:
    case OLMUL:
    case ODIV:
    case OLDIV:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tmul))
            goto bad;
        arith(n, 1);
        if(typeu[n->type->etype]) {
            if(n->op == ODIV)
                n->op = OLDIV;
            if(n->op == OMUL)
                n->op = OLMUL;
        }
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        n->right = Z;
        arith(n, 1);
        n->right = new1(OCAST, r, Z);
        n->right->type = types[TINT];
        if(typeu[n->type->etype])
            if(n->op == OASHR)
                n->op = OLSHR;
        break;

    case OAND:
    case OOR:
    case OXOR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        arith(n, 1);
        break;

    case OMOD:
    case OLMOD:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        arith(n, 1);
        if(typeu[n->type->etype])
            n->op = OLMOD;
        break;

    case OPOS:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        r = l;
        l = new(OCONST, Z, Z);
        l->vconst = 0;
        l->type = types[TINT];
        n->op = OADD;
        n->right = r;
        n->left = l;

        if(tcom(l))
            goto bad;
        if(tcompat(n, l->type, r->type, tsub))
            goto bad;
        arith(n, 1);
        break;

    case ONEG:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        if(!machcap(n)) {
            r = l;
            l = new(OCONST, Z, Z);
            l->vconst = 0;
            l->type = types[TINT];
            n->op = OSUB;
            n->right = r;
            n->left = l;

            if(tcom(l))
                goto bad;
            if(tcompat(n, l->type, r->type, tsub))
                goto bad;
        }
        arith(n, 1);
        break;

    case OCOM:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        if(!machcap(n)) {
            r = l;
            l = new(OCONST, Z, Z);
            l->vconst = -1;
            l->type = types[TINT];
            n->op = OXOR;
            n->right = r;
            n->left = l;

            if(tcom(l))
                goto bad;
            if(tcompat(n, l->type, r->type, tand))
                goto bad;
        }
        arith(n, 1);
        break;

    case ONOT:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, T, l->type, tnot))
            goto bad;
        n->type = types[TINT];
        break;

    case OANDAND:
    case OOROR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tcompat(n, T, l->type, tnot) |
           tcompat(n, T, r->type, tnot))
            goto bad;
        n->type = types[TINT];
        break;

    case OCOMMA:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        n->type = r->type;
        break;


    case OSIGN:	/* extension signof(type) returns a hash */
        if(l != Z) {
            if(l->op != OSTRING && l->op != OLSTRING)
                if(tcomo(l, 0))
                    goto bad;
            if(l->op == OBIT) {
                diag(n, "signof bitfield");
                goto bad;
            }
            n->type = l->type;
        }
        if(n->type == T)
            goto bad;
        if(n->type->width < 0) {
            diag(n, "signof undefined type");
            goto bad;
        }
        n->op = OCONST;
        n->left = Z;
        n->right = Z;
        n->vconst = convvtox(signature(n->type), TULONG);
        n->type = types[TULONG];
        break;

    case OSIZE:
        if(l != Z) {
            if(l->op != OSTRING && l->op != OLSTRING)
                if(tcomo(l, 0))
                    goto bad;
            if(l->op == OBIT) {
                diag(n, "sizeof bitfield");
                goto bad;
            }
            n->type = l->type;
        }
        if(n->type == T)
            goto bad;
        if(n->type->width <= 0) {
            diag(n, "sizeof undefined type");
            goto bad;
        }
        if(n->type->etype == TFUNC) {
            diag(n, "sizeof function");
            goto bad;
        }
        n->op = OCONST;
        n->left = Z;
        n->right = Z;
        n->vconst = convvtox(n->type->width, TINT);
        n->type = types[TINT];
        break;

    case OFUNC:
        o = tcomo(l, 0);
        if(o)
            goto bad;
        if(l->type->etype == TIND && l->type->link->etype == TFUNC) {
            l = new1(OIND, l, Z);
            l->type = l->left->type->link;
            n->left = l;
        }
        if(tcompat(n, T, l->type, tfunct))
            goto bad;
        if(o | tcoma(l, r, l->type->down, 1))
            goto bad;
        n->type = l->type->link;
        if(!debug['B'])
            if(l->type->down == T || l->type->down->etype == TOLD) {
                nerrors--;
                diag(n, "function args not checked: %F", l);
            }
        dpcheck(n);
        break;

    case ONAME:
        if(n->type == T) {
            diag(n, "name not declared: %F", n);
            goto bad;
        }
        if(n->type->etype == TENUM) {
            n->op = OCONST;
            n->type = n->sym->tenum;
            if(!typefd[n->type->etype])
                n->vconst = n->sym->vconst;
            else
                n->fconst = n->sym->fconst;
            break;
        }
        n->addable = 1;
        if(n->class == CEXREG) {
            n->op = OREGISTER;
            if(thechar == '8')
                n->op = OEXREG;
            n->reg = n->sym->offset;
            n->xoffset = 0;
            break;
        }
        break;

    case OLSTRING:
        if(n->type->link != types[TRUNE]) {
            o = outstring(0, 0);
            while(o & 3) {
                outlstring(&zer, sizeof(TRune));
                o = outlstring(0, 0);
            }
        }
        n->op = ONAME;
        n->xoffset = outlstring(n->rstring, n->type->width);
        n->addable = 1;
        break;

    case OSTRING:
        if(n->type->link != types[TCHAR]) {
            o = outstring(0, 0);
            while(o & 3) {
                outstring("", 1);
                o = outstring(0, 0);
            }
        }
        n->op = ONAME;
        n->xoffset = outstring(n->cstring, n->type->width);
        n->addable = 1;
        break;

    case OCONST:
        break;

    case ODOT:
        if(tcom(l))
            goto bad;
        if(tcompat(n, T, l->type, tdot))
            goto bad;
        if(tcomd(n))
            goto bad;
        break;

    case OADDR:
        if(tcomo(l, ADDROP))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(l->type->nbits) {
            diag(n, "address of a bit field");
            goto bad;
        }
        if(l->op == OREGISTER) {
            diag(n, "address of a register");
            goto bad;
        }
        n->type = typ(TIND, l->type);
        n->type->width = types[TIND]->width;
        break;

    case OIND:
        if(tcom(l))
            goto bad;
        if(tcompat(n, T, l->type, tindir))
            goto bad;
        n->type = l->type->link;
        n->addable = 1;
        break;

    case OSTRUCT:
        if(tcomx(n))
            goto bad;
        break;

    default:
        diag(n, "unknown op in type complex: %O", n->op);
        goto bad;

    }


    t = n->type;
    if(t == T)
        goto bad;
    if(t->width < 0) {
        snap(t);
        if(t->width < 0) {
            if(typesu[t->etype] && t->tag)
                diag(n, "structure not fully declared %s", t->tag->name);
            else
                diag(n, "structure not fully declared");
            goto bad;
        }
    }
    if(typeaf[t->etype]) {
        if(f & ADDROF)
            goto addaddr;
        if(f & ADDROP)
            warn(n, "address of array/func ignored");
    }
    return false;

addaddr:
    if(tlvalue(n))
        goto bad;
    l = new1(OXXX, Z, Z);
    *l = *n;
    n->op = OADDR;
    if(l->type->etype == TARRAY)
        l->type = l->type->link;
    n->left = l;
    n->right = Z;
    n->addable = 0;
    n->type = typ(TIND, l->type);
    n->type->width = types[TIND]->width;
    return false;

bad:
    n->type = T;
    return true;
}
@


<<function mixedasop>>=
int
mixedasop(Type *l, Type *r)
{
    return !typefd[l->etype] && typefd[r->etype];
}
@


% usually called via if(tlvalue(x)) goto bad;
<<function tlvalue>>=
bool
tlvalue(Node *n)
{

    if(!n->addable) {
        diag(n, "not an l-value");
        return true;
    }
    return false;
}
@


<<function vconst>>=
int
vconst(Node *n)
{
    int i;

    if(n == Z)
        goto no;
    if(n->op != OCONST)
        goto no;
    if(n->type == T)
        goto no;
    switch(n->type->etype)
    {
    case TFLOAT:
    case TDOUBLE:
        i = 100;
        if(n->fconst > i || n->fconst < -i)
            goto no;
        i = n->fconst;
        if(i != n->fconst)
            goto no;
        return i;

    case TVLONG:
    case TUVLONG:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;

    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TINT:
    case TUINT:
    case TLONG:
    case TULONG:
    case TIND:
        i = n->vconst;
        if(i != n->vconst)
            goto no;
        return i;
    }
no:
    return -159;	/* first uninteresting constant */
}
@




<<function constas>>=
void
constas(Node *n, Type *il, Type *ir)
{
    Type *l, *r;

    l = il;
    r = ir;

    if(l == T)
        return;
    if(l->garb & GCONSTNT) {
        warn(n, "assignment to a constant type (%T)", il);
        return;
    }
    if(r == T)
        return;
    for(;;) {
        if(l->etype != TIND || r->etype != TIND)
            break;
        l = l->link;
        r = r->link;
        if(l == T || r == T)
            break;
        if(r->garb & GCONSTNT)
            if(!(l->garb & GCONSTNT)) {
                warn(n, "assignment of a constant pointer type (%T)", ir);
                break;
            }
    }
}
@






<<global nodproto>>=
Node*	nodproto;
@

<<function tcoma>>=
int
tcoma(Node *l, Node *n, Type *t, int f)
{
    Node *n1;
    int o;

    if(t != T)
    if(t->etype == TOLD || t->etype == TDOT)	/* .../old in prototype */
        t = T;
    if(n == Z) {
        if(t != T && !sametype(t, types[TVOID])) {
            diag(n, "not enough function arguments: %F", l);
            return 1;
        }
        return 0;
    }
    if(n->op == OLIST) {
        o = tcoma(l, n->left, t, 0);
        if(t != T) {
            t = t->down;
            if(t == T)
                t = types[TVOID];
        }
        return o | tcoma(l, n->right, t, 1);
    }
    if(f && t != T)
        tcoma(l, Z, t->down, 0);
    if(tcom(n) || tcompat(n, T, n->type, targ))
        return 1;
    if(sametype(t, types[TVOID])) {
        diag(n, "too many function arguments: %F", l);
        return 1;
    }
    if(t != T) {
        typeext(t, n);
        if(stcompat(nodproto, t, n->type, tasign)) {
            diag(l, "argument prototype mismatch \"%T\" for \"%T\": %F",
                n->type, t, l);
            return 1;
        }
        switch(t->etype) {
        case TCHAR:
        case TSHORT:
            t = types[TINT];
            break;

        case TUCHAR:
        case TUSHORT:
            t = types[TUINT];
            break;
        }
    } else
    switch(n->type->etype)
    {
    case TCHAR:
    case TSHORT:
        t = types[TINT];
        break;

    case TUCHAR:
    case TUSHORT:
        t = types[TUINT];
        break;

    case TFLOAT:
        t = types[TDOUBLE];
    }
    if(t != T && !sametype(t, n->type)) {
        n1 = new1(OXXX, Z, Z);
        *n1 = *n;
        n->op = OCAST;
        n->left = n1;
        n->right = Z;
        n->type = t;
        n->addable = 0;
    }
    return 0;
}
@





% tcom ODOT
<<function tcomd>>=
int
tcomd(Node *n)
{
    Type *t;
    long o;

    o = 0;
    t = dotsearch(n->sym, n->left->type->link, n, &o);
    if(t == T) {
        diag(n, "not a member of struct/union: %F", n);
        return 1;
    }
    makedot(n, t, o);
    return 0;
}
@

<<function dotsearch>>=
Type*
dotsearch(Sym *s, Type *t, Node *n, long *off)
{
    Type *t1, *xt, *rt;

    xt = T;

    /*
     * look it up by name
     */
    for(t1 = t; t1 != T; t1 = t1->down)
        if(t1->sym == s) {
            if(xt != T)
                goto ambig;
            xt = t1;
        }

    /*
     * look it up by type
     */
    if(s->class == CTYPEDEF || s->class == CTYPESTR)
        for(t1 = t; t1 != T; t1 = t1->down)
            if(t1->sym == S && typesu[t1->etype])
                if(sametype(s->type, t1)) {
                    if(xt != T)
                        goto ambig;
                    xt = t1;
                }
    if(xt != T) {
        *off = xt->offset;
        return xt;
    }

    /*
     * look it up in unnamed substructures
     */
    for(t1 = t; t1 != T; t1 = t1->down)
        if(t1->sym == S && typesu[t1->etype]){
            rt = dotsearch(s, t1->link, n, off);
            if(rt != T) {
                if(xt != T)
                    goto ambig;
                xt = rt;
                *off += t1->offset;
            }
        }
    return xt;

ambig:
    diag(n, "ambiguous structure element: %s", s->name);
    return xt;
}
@


<<function makedot>>=
void
makedot(Node *n, Type *t, long o)
{
    Node *n1, *n2;

    if(t->nbits) {
        n1 = new(OXXX, Z, Z);
        *n1 = *n;
        n->op = OBIT;
        n->left = n1;
        n->right = Z;
        n->type = t;
        n->addable = n1->left->addable;
        n = n1;
    }
    n->addable = n->left->addable;
    if(n->addable == 0) {
        n1 = new1(OCONST, Z, Z);
        n1->vconst = o;
        n1->type = types[TLONG];
        n->right = n1;
        n->type = t;
        return;
    }
    n->left->type = t;
    if(o == 0) {
        *n = *n->left;
        return;
    }
    n->type = t;
    n1 = new1(OCONST, Z, Z);
    n1->vconst = o;
    t = typ(TIND, t);
    t->width = types[TIND]->width;
    n1->type = t;

    n2 = new1(OADDR, n->left, Z);
    n2->type = t;

    n1 = new1(OADD, n1, n2);
    n1->type = t;

    n->op = OIND;
    n->left = n1;
    n->right = Z;
}
@






% structure
<<function tcomx>>=
int
tcomx(Node *n)
{
    Type *t;
    Node *l, *r, **ar, **al;
    int e;

    e = 0;
    if(n->type->etype != TSTRUCT) {
        diag(n, "constructor must be a structure");
        return 1;
    }
    l = invert(n->left);
    n->left = l;
    al = &n->left;
    for(t = n->type->link; t != T; t = t->down) {
        if(l == Z) {
            diag(n, "constructor list too short");
            return 1;
        }
        if(l->op == OLIST) {
            r = l->left;
            ar = &l->left;
            al = &l->right;
            l = l->right;
        } else {
            r = l;
            ar = al;
            l = Z;
        }
        if(tcom(r))
            e++;
        typeext(t, r);
        if(tcompat(n, t, r->type, tasign))
            e++;
        constas(n, t, r->type);
        if(!e && !sametype(t, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = t;
            *ar = r;
        }
    }
    if(l != Z) {
        diag(n, "constructor list too long");
        return 1;
    }
    return e;
}
@


\subsection{Arithmetic conversions}

<<function arith>>=
/*
 * "the usual arithmetic conversions are performed"
 */
void
arith(Node *n, int f)
{
    Type *t1, *t2;
    int i, j, k;
    Node *n1;
    long w;

    t1 = n->left->type;
    if(n->right == Z)
        t2 = t1;
    else
        t2 = n->right->type;
    i = TXXX;
    if(t1 != T)
        i = t1->etype;
    j = TXXX;
    if(t2 != T)
        j = t2->etype;

    k = tab[i][j];

    if(k == TIND) {
        if(i == TIND)
            n->type = t1;
        else
        if(j == TIND)
            n->type = t2;
    } else {
        /* convert up to at least int */
        if(f == 1)
        while(k < TINT)
            k += 2;
        n->type = types[k];
    }
    if(n->op == OSUB)
    if(i == TIND && j == TIND) {
        w = n->right->type->link->width;
        if(w < 1 || n->left->type->link == T || n->left->type->link->width < 1)
            goto bad;
        n->type = types[ewidth[TIND] <= ewidth[TLONG]? TLONG: TVLONG];
        if(1 && ewidth[TIND] > ewidth[TLONG]){
            n1 = new1(OXXX, Z, Z);
            *n1 = *n;
            n->op = OCAST;
            n->left = n1;
            n->right = Z;
            n->type = types[TLONG];
        }
        if(w > 1) {
            n1 = new1(OXXX, Z, Z);
            *n1 = *n;
            n->op = ODIV;
            n->left = n1;
            n1 = new1(OCONST, Z, Z);
            n1->vconst = w;
            n1->type = n->type;
            n->right = n1;
            w = vlog(n1);
            if(w >= 0) {
                n->op = OASHR;
                n1->vconst = w;
            }
        }
        return;
    }
    if(!sametype(n->type, n->left->type)) {
        n->left = new1(OCAST, n->left, Z);
        n->left->type = n->type;
        if(n->type->etype == TIND) {
            w = n->type->link->width;
            if(w < 1) {
                snap(n->type->link);
                w = n->type->link->width;
                if(w < 1)
                    goto bad;
            }
            if(w > 1) {
                n1 = new1(OCONST, Z, Z);
                n1->vconst = w;
                n1->type = n->type;
                n->left = new1(OMUL, n->left, n1);
                n->left->type = n->type;
            }
        }
    }
    if(n->right != Z)
    if(!sametype(n->type, n->right->type)) {
        n->right = new1(OCAST, n->right, Z);
        n->right->type = n->type;
        if(n->type->etype == TIND) {
            w = n->type->link->width;
            if(w < 1) {
                snap(n->type->link);
                w = n->type->link->width;
                if(w < 1)
                    goto bad;
            }
            if(w != 1) {
                n1 = new1(OCONST, Z, Z);
                n1->vconst = w;
                n1->type = n->type;
                n->right = new1(OMUL, n->right, n1);
                n->right->type = n->type;
            }
        }
    }
    return;
bad:
    diag(n, "pointer addition not fully declared: %T", n->type->link);
}
@




<<global tab>>=
char	tab[NTYPE][NTYPE] =
{
/*TXXX*/	{ 0,
        },

/*TCHAR*/	{ 0,	TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUCHAR*/	{ 0,	TUCHAR, TUCHAR, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TSHORT*/	{ 0,	TSHORT, TUSHORT, TSHORT, TUSHORT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUSHORT*/	{ 0,	TUSHORT, TUSHORT, TUSHORT, TUSHORT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TINT*/	{ 0,	TINT, TUINT, TINT, TUINT, TINT, TUINT, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUINT*/	{ 0,	TUINT, TUINT, TUINT, TUINT, TUINT, TUINT, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TLONG*/	{ 0,	TLONG, TULONG, TLONG, TULONG, TLONG, TULONG, TLONG,
            TULONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TULONG*/	{ 0,	TULONG, TULONG, TULONG, TULONG, TULONG, TULONG, TULONG,
            TULONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TVLONG*/	{ 0,	TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG, TUVLONG, TVLONG,
            TUVLONG, TVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TUVLONG*/	{ 0,	TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG, TUVLONG,
            TUVLONG, TUVLONG, TUVLONG, TFLOAT, TDOUBLE, TIND,
        },
/*TFLOAT*/	{ 0,	TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT, TFLOAT,
            TFLOAT, TFLOAT, TFLOAT, TFLOAT, TDOUBLE, TIND,
        },
/*TDOUBLE*/	{ 0,	TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE, TDOUBLE,
            TDOUBLE, TDOUBLE, TDOUBLE, TFLOAT, TDOUBLE, TIND,
        },
/*TIND*/	{ 0,	TIND, TIND, TIND, TIND, TIND, TIND, TIND,
             TIND, TIND, TIND, TIND, TIND, TIND,
        },
};
@


\subsection{C Extensions}

<<function dotoffset>>=
long
dotoffset(Type *st, Type *lt, Node *n)
{
    Type *t;
    Sym *g;
    long o, o1;

    o = -1;
    /*
     * first try matching at the top level
     * for matching tag names
     */
    g = st->tag;
    if(g != S)
        for(t=lt->link; t!=T; t=t->down)
            if(t->sym == S)
                if(g == t->tag) {
                    if(o >= 0)
                        goto ambig;
                    o = t->offset;
                }
    if(o >= 0)
        return o;

    /*
     * second try matching at the top level
     * for similar types
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
            if(sametype(st, t)) {
                if(o >= 0)
                    goto ambig;
                o = t->offset;
            }
    if(o >= 0)
        return o;

    /*
     * last try matching sub-levels
     */
    for(t=lt->link; t!=T; t=t->down)
        if(t->sym == S)
        if(typesu[t->etype]) {
            o1 = dotoffset(st, t, n);
            if(o1 >= 0) {
                if(o >= 0)
                    goto ambig;
                o = o1 + t->offset;
            }
        }
    return o;

ambig:
    diag(n, "ambiguous unnamed structure element");
    return o;
}
@


<<function typeext1>>=
void
typeext1(Type *st, Node *l)
{
    if(st->etype == TFLOAT && allfloat(l, 0))
        allfloat(l, 1);
}
@

<<function typeext>>=
void
typeext(Type *st, Node *l)
{
    Type *lt;
    Node *n1, *n2;
    long o;

    lt = l->type;
    if(lt == T)
        return;
    if(st->etype == TIND && vconst(l) == 0) {
        l->type = st;
        l->vconst = 0;
        return;
    }
    typeext1(st, l);

    /*
     * extension of C
     * if assign of struct containing unnamed sub-struct
     * to type of sub-struct, insert the DOT.
     * if assign of *struct containing unnamed substruct
     * to type of *sub-struct, insert the add-offset
     */
    if(typesu[st->etype] && typesu[lt->etype]) {
        o = dotoffset(st, lt, l);
        if(o >= 0) {
            n1 = new1(OXXX, Z, Z);
            *n1 = *l;
            l->op = ODOT;
            l->left = n1;
            l->right = Z;
            makedot(l, st, o);
        }
        return;
    }
    if(st->etype == TIND && typesu[st->link->etype])
    if(lt->etype == TIND && typesu[lt->link->etype]) {
        o = dotoffset(st->link, lt->link, l);
        if(o >= 0) {
            l->type = st;
            if(o == 0)
                return;
            n1 = new1(OXXX, Z, Z);
            *n1 = *l;
            n2 = new1(OCONST, Z, Z);
            n2->vconst = o;
            n2->type = st;
            l->op = OADD;
            l->left = n1;
            l->right = n2;
        }
        return;
    }
}
@

\section{Lint checks}

% 8c -V enable void* conversion warnings
% 8c -w print warnings

<<[[Sym]] other fields>>=
bool	aused;
@

<<[[Decl]] other fields>>=
bool	aused;
@

% hmmm but correct? handle well the different namespace?
% what if struct and local with same name?

\subsection{[[SET/USED]]}

<<ulstmnt rule>>=
|   LUSED '(' zelist ')' ';' { $$ = new(OUSED, $3, Z); }
|   LSET '(' zelist ')' ';'  { $$ = new(OSET, $3, Z); }
@


% called by gen() (statement code generator) 
<<function usedset>>=
void
usedset(Node *n, int o)
{
    if(n->op == OLIST) {
        usedset(n->left, o);
        usedset(n->right, o);
        return;
    }

    complex(n);

    switch(n->op) {
    case OADDR:	/* volatile */
        gins(ANOP, n, Z);
        break;
    case ONAME:
        if(o == OSET)
            gins(ANOP, Z, n);
        else
            gins(ANOP, n, Z);
        break;
    }
}
@

\subsection{Unreachable code}

<<function deadhead>>=
/*
 * return true if it is impossible to jump into the middle of n.
 */
static int
deadhead(Node *n, int caseok)
{
loop:
    if(n == Z)
        return true;
    switch(n->op) {
    case OLIST:
        if(!deadhead(n->left, caseok))
            return false;
    rloop:
        n = n->right;
        goto loop;

    case ORETURN:
        break;

    case OLABEL:
        return false;

    case OGOTO:
        break;

    case OCASE:
        if(!caseok)
            return false;
        goto rloop;

    case OSWITCH:
        return deadhead(n->right, 1);

    case OWHILE:
    case ODWHILE:
        goto rloop;

    case OFOR:
        goto rloop;

    case OCONTINUE:
        break;

    case OBREAK:
        break;

    case OIF:
        return deadhead(n->right->left, caseok) && deadhead(n->right->right, caseok);

    case OSET:
    case OUSED:
        break;
    }
    return true;
}
@

<<function deadheads>>=
bool
deadheads(Node *c)
{
    return deadhead(c->left, 0) && deadhead(c->right, 0);
}
@

\chapter{Assembly Generation}
% hmm better name than code generation? Assembly generation?

% what does gpseudo, etc?

\section{Overview}

% intermediate language? RTL? seems not :(
% maybe lcc is cleaner

% gbranch, gmove, mostly archi independent interface.
%  cc2/pgen.c include gc.h where all archi define some archi independent
%  stuff like ATEXT, ANOP, etc
% gins seems more archi independent

% nextpc()?
% gxxx = generate Prog (=~ assembly code)
% but in mostly portable way!

%x86!
% target language = Adr, Prog, as, etc, like in Linker and assembler
% outcode, like in Assembler?


% remember in cc.y for function definition case:
%        if(!debug['a'] && !debug['Z'])
%            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!

% codgen (func) -> gen (statement) 
%                     -> cgen (expr?) x86 specific

\section{Functions, [[codgen()]]}

<<global cursafe>>=
long	cursafe;
@

<<global curarg>>=
long	curarg;
@

<<global maxargsafe>>=
long	maxargsafe;
@

<<global hasdoubled>>=
int	hasdoubled;
@




% not set anywhere?
<<global nodret>>=
Node*	nodret;
@





%REGARG from 8.out.h = -1 => no register for first argument,
% everything in the stack. AX is used for return though

% cc2/pgen.c  n = node of the blocks OLIST, nn = node of the ident ONAME
<<function codgen>>=
//@Scheck: used by cc.y
void codgen(Node *n, Node *nn)
{
    Prog *sp;
    Node *n1, nod, nod1;

    cursafe = 0;
    curarg = 0;
    maxargsafe = 0;
    hasdoubled = 0;

    /*
     * isolate name
     */
    for(n1 = nn;; n1 = n1->left) {
        if(n1 == Z) {
            diag(nn, "cant find function name");
            return;
        }
        if(n1->op == ONAME)
            break;
    }
    nearln = nn->lineno;
    gpseudo(ATEXT, n1->sym, nodconst(stkoff));
    sp = p;

    if(typecmplx[thisfn->link->etype]) {
        if(nodret == nil) {
            nodret = new(ONAME, Z, Z);
            nodret->sym = slookup(".ret");
            nodret->class = CPARAM;
            nodret->type = types[TIND];
            nodret->etype = TIND;
            nodret = new(OIND, nodret, Z);
        }
        n1 = nodret->left;
        if(n1->type == T || n1->type->link != thisfn->link) {
            n1->type = typ(TIND, thisfn->link);
            n1->etype = n1->type->etype;
            nodret = new(OIND, n1, Z);
            complex(nodret);
        }
    }

    /*
     * isolate first argument
     */
    if(REGARG >= 0) {	
        if(typecmplx[thisfn->link->etype]) {
            nod1 = *nodret->left;
            nodreg(&nod, &nod1, REGARG);
            gmove(&nod, &nod1);
        } else
        if(firstarg && typeword[firstargtype->etype]) {
            nod1 = znode;
            nod1.op = ONAME;
            nod1.sym = firstarg;
            nod1.type = firstargtype;
            nod1.class = CPARAM;
            nod1.xoffset = align(0, firstargtype, Aarg1);
            nod1.etype = firstargtype->etype;
            xcom(&nod1);
            nodreg(&nod, &nod1, REGARG);
            gmove(&nod, &nod1);
        }
    }

    canreach = true;
    warnreach = true;

    gen(n);

    if(canreach && thisfn->link->etype != TVOID){
        if(debug['B'])
            warn(Z, "no return at end of function: %s", n1->sym->name);
        else
            diag(Z, "no return at end of function: %s", n1->sym->name);
    }

    noretval(3);

    gbranch(ORETURN);

    if(!debug['N'] || debug['R'] || debug['P'])
        regopt(sp);
    
    if(thechar=='6' || thechar=='7' || thechar=='9' || hasdoubled)	/* [sic] */
        maxargsafe = round(maxargsafe, 8);
    sp->to.offset += maxargsafe;
}
@


% 8c/sgen.c
<<function noretval>>=
void
noretval(int n)
{

    if(n & 1) {
        gins(ANOP, Z, Z);
        p->to.type = REGRET;
    }
    if(n & 2) {
        gins(ANOP, Z, Z);
        p->to.type = FREGRET;
    }
    if((n&3) == 3)
    if(thisfn && thisfn->link && typefd[thisfn->link->etype])
        gins(AFLDZ, Z, Z);
}
@

\section{Statements, [[gen()]]}

<<global canreach>>=
bool	canreach;
@

<<global warnreach>>=
bool	warnreach;
@

% turn into a static local?
<<global ncontin>>=
int	ncontin;
@

% seems dead, never set to true or valid in other archi?
<<global newvlongcode>>=
bool	newvlongcode;
@


% cc2/pgen.c
<<function gen>>=
void
gen(Node *n)
{
    Node *l, nod, rn;
    Prog *sp, *spc, *spb;
    Case *cn;
    long sbc, scc;
    int snbreak, sncontin;
    int f, o, oldreach;

loop:
    if(n == Z)
        return;
    nearln = n->lineno;
    o = n->op;
    if(debug['G'])
        if(o != OLIST)
            print("%L %O\n", nearln, o);

    if(!canreach) {
        switch(o) {
        case OLABEL:
        case OCASE:
        case OLIST:
        case OCOMMA:
        case OBREAK:
        case OFOR:
        case OWHILE:
        case ODWHILE:
            /* all handled specially - see switch body below */
            break;
        default:
            if(warnreach) {
                warn(n, "unreachable code %O", o);
                warnreach = 0;
            }
        }
    }

    switch(o) {

    default:
        complex(n);
        cgen(n, Z);
        break;

    case OLIST:
    case OCOMMA:
        gen(n->left);

    rloop:
        n = n->right;
        goto loop;

    case ORETURN:
        canreach = false;
        warnreach = !suppress;
        complex(n);
        if(n->type == T)
            break;
        l = uncomma(n->left);
        if(l == Z) {
            noretval(3);
            gbranch(ORETURN);
            break;
        }
        if(typecmplx[n->type->etype]) {
            nod = znode;
            nod.op = OAS;
            nod.left = nodret;
            nod.right = l;
            nod.type = n->type;
            nod.complex = l->complex;
            cgen(&nod, Z);
            noretval(3);
            gbranch(ORETURN);
            break;
        }
        if(newvlongcode && !typefd[n->type->etype]){
            regret(&rn, n);
            regfree(&rn);
            nod = znode;
            nod.op = OAS;
            nod.left = &rn;
            nod.right = l;
            nod.type = n->type;
            nod.complex = l->complex;
            cgen(&nod, Z);
            noretval(2);
            gbranch(ORETURN);
            break;
        }
        regret(&nod, n);
        cgen(l, &nod);
        regfree(&nod);
        if(typefd[n->type->etype])
            noretval(1);
        else
            noretval(2);
        gbranch(ORETURN);
        break;

    case OLABEL:
        canreach = true;
        l = n->left;
        if(l) {
            l->pc = pc;
            if(l->label)
                patch(l->label, pc);
        }
        gbranch(OGOTO);	/* prevent self reference in reg */
        patch(p, pc);
        goto rloop;

    case OGOTO:
        canreach = false;
        warnreach = !suppress;
        n = n->left;
        if(n == Z)
            return;
        if(n->complex == 0) {
            diag(Z, "label undefined: %s", n->sym->name);
            return;
        }
        if(suppress)
            return;
        gbranch(OGOTO);
        if(n->pc) {
            patch(p, n->pc);
            return;
        }
        if(n->label)
            patch(n->label, pc-1);
        n->label = p;
        return;

    case OCASE:
        canreach = true;
        l = n->left;
        if(cases == C)
            diag(n, "case/default outside a switch");
        if(l == Z) {
            casf();
            cases->val = 0;
            cases->def = 1;
            cases->label = pc;
            cases->isv = 0;
            goto rloop;
        }
        complex(l);
        if(l->type == T)
            goto rloop;
        if(l->op != OCONST || !typeswitch[l->type->etype]) {
            diag(n, "case expression must be integer constant");
            goto rloop;
        }
        casf();
        cases->val = l->vconst;
        cases->def = 0;
        cases->label = pc;
        cases->isv = typev[l->type->etype];
        goto rloop;

    case OSWITCH:
        l = n->left;
        complex(l);
        if(l->type == T)
            break;
        if(!typeswitch[l->type->etype]) {
            diag(n, "switch expression must be integer");
            break;
        }

        gbranch(OGOTO);		/* entry */
        sp = p;

        cn = cases;
        cases = C;
        casf();

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        gbranch(OGOTO);
        spb = p;

        gen(n->right);		/* body */
        if(canreach){
            gbranch(OGOTO);
            patch(p, breakpc);
            nbreak++;
        }

        patch(sp, pc);
        regalloc(&nod, l, Z);
        /* always signed */
        if(typev[l->type->etype])
            nod.type = types[TVLONG];
        else
            nod.type = types[TLONG];
        cgen(l, &nod);
        doswit(&nod);
        regfree(&nod);
        patch(spb, pc);

        cases = cn;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == false)
            warnreach = !suppress;
        nbreak = snbreak;
        break;

    case OWHILE:
    case ODWHILE:
        l = n->left;
        gbranch(OGOTO);		/* entry */
        sp = p;

        scc = continpc;
        continpc = pc;
        gbranch(OGOTO);
        spc = p;

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        gbranch(OGOTO);
        spb = p;

        patch(spc, pc);
        if(n->op == OWHILE)
            patch(sp, pc);
        bcomplex(l, Z);		/* test */
        patch(p, breakpc);
        if(l->op != OCONST || vconst(l) == 0)
            nbreak++;

        if(n->op == ODWHILE)
            patch(sp, pc);
        gen(n->right);		/* body */
        gbranch(OGOTO);
        patch(p, continpc);

        patch(spb, pc);
        continpc = scc;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == false)
            warnreach = !suppress;
        nbreak = snbreak;
        break;

    case OFOR:
        l = n->left;
        if(!canreach && l->right->left && warnreach) {
            warn(n, "unreachable code FOR");
            warnreach = 0;
        }
        gen(l->right->left);	/* init */
        gbranch(OGOTO);		/* entry */
        sp = p;

        /* 
         * if there are no incoming labels in the 
         * body and the top's not reachable, warn
         */
        if(!canreach && warnreach && deadheads(n)) {
            warn(n, "unreachable code %O", o);
            warnreach = 0;
        }

        scc = continpc;
        continpc = pc;
        gbranch(OGOTO);
        spc = p;

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        sncontin = ncontin;
        ncontin = 0;
        gbranch(OGOTO);
        spb = p;

        patch(spc, pc);
        gen(l->right->right);	/* inc */
        patch(sp, pc);	
        if(l->left != Z) {	/* test */
            bcomplex(l->left, Z);
            patch(p, breakpc);
            if(l->left->op != OCONST || vconst(l->left) == 0)
                nbreak++;
        }
        canreach = true;
        gen(n->right);		/* body */
        if(canreach){
            gbranch(OGOTO);
            patch(p, continpc);
            ncontin++;
        }
        if(!ncontin && l->right->right && warnreach) {
            warn(l->right->right, "unreachable FOR inc");
            warnreach = 0;
        }

        patch(spb, pc);
        continpc = scc;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == false)
            warnreach = !suppress;
        nbreak = snbreak;
        ncontin = sncontin;
        break;

    case OCONTINUE:
        if(continpc < 0) {
            diag(n, "continue not in a loop");
            break;
        }
        gbranch(OGOTO);
        patch(p, continpc);
        ncontin++;
        canreach = false;
        warnreach = !suppress;
        break;

    case OBREAK:
        if(breakpc < 0) {
            diag(n, "break not in a loop");
            break;
        }
        /*
         * Don't complain about unreachable break statements.
         * There are breaks hidden in yacc's output and some people
         * write return; break; in their switch statements out of habit.
         * However, don't confuse the analysis by inserting an 
         * unreachable reference to breakpc either.
         */
        if(!canreach)
            break;
        gbranch(OGOTO);
        patch(p, breakpc);
        nbreak++;
        canreach = false;
        warnreach = !suppress;
        break;

    case OIF:
        l = n->left;
        if(bcomplex(l, n->right)) {
            if(typefd[l->type->etype])
                f = !l->fconst;
            else
                f = !l->vconst;
            if(debug['c'])
                print("%L const if %s\n", nearln, f ? "false" : "true");
            if(f) {
                canreach = true;
                supgen(n->right->left);
                oldreach = canreach;
                canreach = true;
                gen(n->right->right);
                /*
                 * treat constant ifs as regular ifs for 
                 * reachability warnings.
                 */
                if(!canreach && oldreach && debug['w'] < 2)
                    warnreach = 0;
            }
            else {
                canreach = true;
                gen(n->right->left);
                oldreach = canreach;
                canreach = true;
                supgen(n->right->right);
                /*
                 * treat constant ifs as regular ifs for 
                 * reachability warnings.
                 */
                if(!oldreach && canreach && debug['w'] < 2)
                    warnreach = 0;
                canreach = oldreach;
            }
        }
        else {
            sp = p;
            canreach = true;
            if(n->right->left != Z)
                gen(n->right->left);
            oldreach = canreach;
            canreach = true;
            if(n->right->right != Z) {
                gbranch(OGOTO);
                patch(sp, pc);
                sp = p;
                gen(n->right->right);
            }
            patch(sp, pc);
            canreach = canreach || oldreach;
            if(canreach == false)
                warnreach = !suppress;
        }
        break;

    case OSET:
    case OUSED:
        usedset(n->left, o);
        break;
    }
}
@

<<function supgen>>=
void
supgen(Node *n)
{
    int owarn;
    long opc;
    Prog *olastp;

    if(n == Z)
        return;

    suppress++;
    owarn = warnreach;
    warnreach = 0;
    opc = pc;
    olastp = lastp;

    gen(n);

    lastp = olastp;
    pc = opc;
    olastp->link = nil;
    suppress--;
    warnreach = owarn;
}
@


\subsection{Switch}

% C1, Case are in 8c/
% the code below is in cc2/pswt.c


<<struct Case>>=
struct	Case
{
    vlong	val;
    long	label;
    char	def;
    char 	isv;

    Case*	link;
};
@

<<constant C>>=
#define	C	((Case*)nil)
@

<<struct C1>>=
struct	C1
{
    vlong	val;
    long	label;
};
@

<<global cases>>=
Case*	cases;
@


<<function swcmp>>=
int
swcmp(const void *a1, const void *a2)
{
    C1 *p1, *p2;

    p1 = (C1*)a1;
    p2 = (C1*)a2;
    if(p1->val < p2->val)
        return -1;
    return p1->val > p2->val;
}
@

<<function doswit>>=
void
doswit(Node *n)
{
    Case *c;
    C1 *q, *iq, *iqh, *iql;
    long def, nc, i, j, isv, nh;
    Prog *hsb;
    Node *vr[2];
    int dup;

    def = 0;
    nc = 0;
    isv = 0;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def) {
            if(def)
                diag(n, "more than one default in switch");
            def = c->label;
            continue;
        }
        isv |= c->isv;
        nc++;
    }
    if(typev[n->type->etype])
        isv = 1;
    else if(isv){
        warn(n, "32-bit switch expression with 64-bit case constant");
        isv = 0;
    }

    iq = alloc(nc*sizeof(C1));
    q = iq;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def)
            continue;
        if(c->isv && !isv)
            continue;	/* can never match */
        q->label = c->label;
        if(isv)
            q->val = c->val;
        else
            q->val = (long)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
        q++;
    }
    qsort(iq, nc, sizeof(C1), swcmp);

    if(debug['K'])
     for(i=0; i<nc; i++)
        print("case %2ld: = %.8llux\n", i, (vlong)iq[i].val);
 
   dup = 0;
    for(i=0; i<nc-1; i++)
        if(iq[i].val == iq[i+1].val) {
            diag(n, "duplicate cases in switch %lld", (vlong)iq[i].val);
            dup = 1;
        }
    if(dup)
        return;
    if(def == 0) {
        def = breakpc;
        nbreak++;
    }
    if(!isv || ewidth[TIND] > ewidth[TLONG] || n->op == OREGISTER) {
        swit1(iq, nc, def, n);
        return;
    }

    /*
     * 64-bit case on 32-bit machine:
     * switch on high-order words, and
     * in each of those, switch on low-order words
     */
    if(n->op != OREGPAIR)
        fatal(n, "internal: expected register pair");
    if(thechar == '8'){	/* TO DO: need an enquiry function */
        vr[0] = n->left;	/* low */
        vr[1] = n->right;	/* high */
    }else{
        vr[0] = n->right;
        vr[1] = n->left;
    }
    vr[0]->type = types[TLONG];
    vr[1]->type = types[TLONG];
    gbranch(OGOTO);
    hsb = p;
    iqh = alloc(nc*sizeof(C1));
    iql = alloc(nc*sizeof(C1));
    nh = 0;
    for(i=0; i<nc;){
        iqh[nh].val = iq[i].val >> 32;
        q = iql;
        /* iq is sorted, so equal top halves are adjacent */
        for(j = i; j < nc; j++){
            if((iq[j].val>>32) != iqh[nh].val)
                break;
            q->val = (long)iq[j].val;
            q->label = iq[j].label;
            q++;
        }
        qsort(iql,  q-iql, sizeof(C1), swcmp);
                //if(0){for(int k=0; k<(q-iql); k++)print("nh=%ld k=%d h=%#llux l=%#llux lab=%ld\n", nh, k, (vlong)iqh[nh].val,  (vlong)iql[k].val, iql[k].label);}
        iqh[nh].label = pc;
        nh++;
        swit1(iql, q-iql, def, vr[0]);
        i = j;
    }
    patch(hsb, pc);
        //if(0){for(int k=0; k<nh; k++)print("k*=%d h=%#llux lab=%ld\n", k, (vlong)iqh[k].val,  iqh[k].label);}
    swit1(iqh, nh, def, vr[1]);
}
@

<<function casf>>=
void
casf(void)
{
    Case *c;

    c = alloc(sizeof(*c));
    c->link = cases;
    cases = c;
}
@

\section{[[cgen()]]}

% this in cc/pswt.c but should be in a cc/pcgen.c
<<function nullwarn>>=
void
nullwarn(Node *l, Node *r)
{
    warn(Z, "result of operation not used");
    if(l != Z)
        cgen(l, Z);
    if(r != Z)
        cgen(r, Z);
}
@



% 8c/cgen.c
% was in comment before the func?? /* ,x/^(print|prtree)\(/i/\/\/ */
<<function cgen>>=
void
cgen(Node *n, Node *nn)
{
    Node *l, *r, *t;
    Prog *p1;
    Node nod, nod1, nod2, nod3, nod4;
    int o, hardleft;
    long v, curs;
    vlong c;

    if(debug['g']) {
        prtree(nn, "cgen lhs");
        prtree(n, "cgen");
    }

    if(n == Z || n->type == T)
        return;
    if(typesuv[n->type->etype]) {
        sugen(n, nn, n->type->width);
        return;
    }
    l = n->left;
    r = n->right;
    o = n->op;
// Go's version does the following, but it's the wrong place: doesn't allow assignment
//	if(o == OEXREG || nn != Z && nn->op == OEXREG) {
//		gmove(n, nn);
//		return;
//	}

    if(n->addable >= INDEXED) {
        if(nn == Z) {
            switch(o) {
            default:
                nullwarn(Z, Z);
                break;
            case OINDEX:
                nullwarn(l, r);
                break;
            }
            return;
        }
        gmove(n, nn);
        return;
    }
    curs = cursafe;

  if(l->complex >= FNX)
   if(r != Z && r->complex >= FNX)
    switch(o) {
    default:
        if(cond(o) && typesuv[l->type->etype])
            break;

        regret(&nod, r);
        cgen(r, &nod);

        regsalloc(&nod1, r);
        gmove(&nod, &nod1);

        regfree(&nod);
        nod = *n;
        nod.right = &nod1;

        cgen(&nod, nn);
        return;

    case OFUNC:
    case OCOMMA:
    case OANDAND:
    case OOROR:
    case OCOND:
    case ODOT:
        break;
    }

    hardleft = l->addable < INDEXED || l->complex >= FNX;
    switch(o) {
    default:
        diag(n, "unknown op in cgen: %O", o);
        break;

    case ONEG:
    case OCOM:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        regalloc(&nod, l, nn);
        cgen(l, &nod);
        gopcode(o, n->type, Z, &nod);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OAS:
        if(typefd[n->type->etype]) {
            cgen(r, &fregnode0);
            if(nn != Z)
                gins(AFMOVD, &fregnode0, &fregnode0);
            if(l->addable < INDEXED) {
                reglcgen(&nod, l, Z);
                gmove(&fregnode0, &nod);
                regfree(&nod);
            } else
                gmove(&fregnode0, l);
            if(nn != Z)
                gmove(&fregnode0, nn);
            return;
        }
        if(l->op == OBIT)
            goto bitas;
        if(!hardleft) {
            if(nn != Z || r->addable < INDEXED) {
                if(r->complex >= FNX && nn == Z)
                    regret(&nod, r);
                else
                    regalloc(&nod, r, nn);
                cgen(r, &nod);
                gmove(&nod, l);
                if(nn != Z)
                    gmove(&nod, nn);
                regfree(&nod);
            } else
                gmove(r, l);
            break;
        }
        if(l->complex >= r->complex) {
            if(l->op == OINDEX && r->op == OCONST) {
                gmove(r, l);
                break;
            }
            reglcgen(&nod1, l, Z);
            if(r->addable >= INDEXED) {
                gmove(r, &nod1);
                if(nn != Z)
                    gmove(r, nn);
                regfree(&nod1);
                break;
            }
            regalloc(&nod, r, nn);
            cgen(r, &nod);
        } else {
            regalloc(&nod, r, nn);
            cgen(r, &nod);
            reglcgen(&nod1, l, Z);
        }
        gmove(&nod, &nod1);
        regfree(&nod);
        regfree(&nod1);
        break;

    bitas:
        n = l->left;
        regalloc(&nod, r, nn);
        if(l->complex >= r->complex) {
            reglcgen(&nod1, n, Z);
            cgen(r, &nod);
        } else {
            cgen(r, &nod);
            reglcgen(&nod1, n, Z);
        }
        regalloc(&nod2, n, Z);
        gmove(&nod1, &nod2);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;

    case OBIT:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        bitload(n, &nod, Z, Z, nn);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(r->op == OCONST) {
            if(r->vconst == 0) {
                cgen(l, nn);
                break;
            }
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            if(o == OASHL && r->vconst == 1)
                gopcode(OADD, n->type, &nod, &nod);
            else
                gopcode(o, n->type, r, &nod);
            gmove(&nod, nn);
            regfree(&nod);
            break;
        }

        /*
         * get nod to be D_CX
         */
        if(nodreg(&nod, nn, D_CX)) {
            regsalloc(&nod1, n);
            gmove(&nod, &nod1);
            cgen(n, &nod);		/* probably a bug */
            gmove(&nod, nn);
            gmove(&nod1, &nod);
            break;
        }
        reg[D_CX]++;
        if(nn->op == OREGISTER && nn->reg == D_CX)
            regalloc(&nod1, l, Z);
        else
            regalloc(&nod1, l, nn);
        if(r->complex >= l->complex) {
            cgen(r, &nod);
            cgen(l, &nod1);
        } else {
            cgen(l, &nod1);
            cgen(r, &nod);
        }
        gopcode(o, n->type, &nod, &nod1);
        gmove(&nod1, nn);
        regfree(&nod);
        regfree(&nod1);
        break;

    case OADD:
    case OSUB:
    case OOR:
    case OXOR:
    case OAND:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(typefd[n->type->etype])
            goto fop;
        if(r->op == OCONST) {
            if(r->vconst == 0 && o != OAND) {
                cgen(l, nn);
                break;
            }
        }
        if(n->op == OADD && l->op == OASHL && l->right->op == OCONST
        && (r->op != OCONST || r->vconst < -128 || r->vconst > 127)) {
            c = l->right->vconst;
            if(c > 0 && c <= 3 && nareg(1) >= 4) {
                if(l->left->complex >= r->complex) {
                    regalloc(&nod, l->left, nn);
                    cgen(l->left, &nod);
                    if(r->addable < INDEXED) {
                        regalloc(&nod1, r, Z);
                        cgen(r, &nod1);
                        genmuladd(&nod, &nod, 1 << c, &nod1);
                        regfree(&nod1);
                    }
                    else
                        genmuladd(&nod, &nod, 1 << c, r);
                }
                else {
                    regalloc(&nod, r, nn);
                    cgen(r, &nod);
                    regalloc(&nod1, l->left, Z);
                    cgen(l->left, &nod1);
                    genmuladd(&nod, &nod1, 1 << c, &nod);
                    regfree(&nod1);
                }
                gmove(&nod, nn);
                regfree(&nod);
                break;
            }
        }
        if(r->addable >= INDEXED) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            gopcode(o, n->type, r, &nod);
            gmove(&nod, nn);
            regfree(&nod);
            break;
        }
        if(l->complex >= r->complex) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            regalloc(&nod1, r, Z);
            cgen(r, &nod1);
            gopcode(o, n->type, &nod1, &nod);
        } else {
            regalloc(&nod1, r, nn);
            cgen(r, &nod1);
            regalloc(&nod, l, Z);
            cgen(l, &nod);
            gopcode(o, n->type, &nod1, &nod);
        }
        gmove(&nod, nn);
        regfree(&nod);
        regfree(&nod1);
        break;

    case OLMOD:
    case OMOD:
    case OLMUL:
    case OLDIV:
    case OMUL:
    case ODIV:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        if(typefd[n->type->etype])
            goto fop;
        if(r->op == OCONST) {
            SET(v);
            switch(o) {
            case ODIV:
            case OMOD:
                c = r->vconst;
                if(c < 0)
                    c = -c;
                v = log2(c);
                if(v < 0)
                    break;
                /* fall thru */
            case OMUL:
            case OLMUL:
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                switch(o) {
                case OMUL:
                case OLMUL:
                    mulgen(n->type, r, &nod);
                    break;
                case ODIV:
                    sdiv2(r->vconst, v, l, &nod);
                    break;
                case OMOD:
                    smod2(r->vconst, v, l, &nod);
                    break;
                }
                gmove(&nod, nn);
                regfree(&nod);
                goto done;
            case OLDIV:
                c = r->vconst;
                if((c & 0x80000000) == 0)
                    break;
                regalloc(&nod1, l, Z);
                cgen(l, &nod1);
                regalloc(&nod, l, nn);
                zeroregm(&nod);
                gins(ACMPL, &nod1, nodconst(c));
                gins(ASBBL, nodconst(-1), &nod);
                regfree(&nod1);
                gmove(&nod, nn);
                regfree(&nod);
                goto done;
            }
        }

        if(o == OMUL) {
            if(l->addable >= INDEXED) {
                t = l;
                l = r;
                r = t;
                goto imula;
            }
            else if(r->addable >= INDEXED) {
            imula:
/* should favour AX */
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                gopcode(OMUL, n->type, r, &nod);
            }
            else {
/* should favour AX */
                regalloc(&nod, l, nn);
                cgen(l, &nod);
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                gopcode(OMUL, n->type, &nod1, &nod);
                regfree(&nod1);
            }
            gmove(&nod, nn);
            regfree(&nod);
            goto done;
        }

        /*
         * get nod to be D_AX
         * get nod1 to be D_DX
         */
        if(nodreg(&nod, nn, D_AX)) {
            regsalloc(&nod2, n);
            gmove(&nod, &nod2);
            v = reg[D_AX];
            reg[D_AX] = 0;

            if(isreg(l, D_AX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_AX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod);
            reg[D_AX] = v;
            break;
        }
        if(nodreg(&nod1, nn, D_DX)) {
            regsalloc(&nod2, n);
            gmove(&nod1, &nod2);
            v = reg[D_DX];
            reg[D_DX] = 0;

            if(isreg(l, D_DX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_DX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod1);
            reg[D_DX] = v;
            break;
        }
        reg[D_AX]++;

        if(r->op == OCONST) {
            switch(o) {
            case ODIV:
                reg[D_DX]++;
                if(l->addable < INDEXED) {
                    regalloc(&nod2, l, Z);
                    cgen(l, &nod2);
                    l = &nod2;
                }
                sdivgen(l, r, &nod, &nod1);
                gmove(&nod1, nn);
                if(l == &nod2)
                    regfree(l);
                goto freeaxdx;
            case OLDIV:
                reg[D_DX]++;
                if(l->addable < INDEXED) {
                    regalloc(&nod2, l, Z);
                    cgen(l, &nod2);
                    l = &nod2;
                }
                udivgen(l, r, &nod, &nod1);
                gmove(&nod1, nn);
                if(l == &nod2)
                    regfree(l);
                goto freeaxdx;
            }
        }

        if(l->complex >= r->complex) {
            cgen(l, &nod);
            reg[D_DX]++;
            if(o == ODIV || o == OMOD)
                gins(ACDQ, Z, Z);
            if(o == OLDIV || o == OLMOD)
                zeroregm(&nod1);
            if(r->addable < INDEXED || r->op == OCONST) {
                regsalloc(&nod3, r);
                cgen(r, &nod3);
                gopcode(o, n->type, &nod3, Z);
            } else
                gopcode(o, n->type, r, Z);
        } else {
            regsalloc(&nod3, r);
            cgen(r, &nod3);
            cgen(l, &nod);
            reg[D_DX]++;
            if(o == ODIV || o == OMOD)
                gins(ACDQ, Z, Z);
            if(o == OLDIV || o == OLMOD)
                zeroregm(&nod1);
            gopcode(o, n->type, &nod3, Z);
        }
        if(o == OMOD || o == OLMOD)
            gmove(&nod1, nn);
        else
            gmove(&nod, nn);
    freeaxdx:
        regfree(&nod);
        regfree(&nod1);
        break;

    case OASLSHR:
    case OASASHL:
    case OASASHR:
        if(r->op == OCONST)
            goto asand;
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype])
            goto asfop;

        /*
         * get nod to be D_CX
         */
        if(nodreg(&nod, nn, D_CX)) {
            regsalloc(&nod1, n);
            gmove(&nod, &nod1);
            cgen(n, &nod);
            if(nn != Z)
                gmove(&nod, nn);
            gmove(&nod1, &nod);
            break;
        }
        reg[D_CX]++;

        if(r->complex >= l->complex) {
            cgen(r, &nod);
            if(hardleft)
                reglcgen(&nod1, l, Z);
            else
                nod1 = *l;
        } else {
            if(hardleft)
                reglcgen(&nod1, l, Z);
            else
                nod1 = *l;
            cgen(r, &nod);
        }

        gopcode(o, l->type, &nod, &nod1);
        regfree(&nod);
        if(nn != Z)
            gmove(&nod1, nn);
        if(hardleft)
            regfree(&nod1);
        break;

    case OASAND:
    case OASADD:
    case OASSUB:
    case OASXOR:
    case OASOR:
    asand:
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype]||typefd[r->type->etype])
            goto asfop;
        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            if(r->op != OCONST) {
                regalloc(&nod1, r, nn);
                cgen(r, &nod1);
                gopcode(o, l->type, &nod1, &nod);
                regfree(&nod1);
            } else
                gopcode(o, l->type, r, &nod);
        } else {
            regalloc(&nod1, r, nn);
            cgen(r, &nod1);
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            gopcode(o, l->type, &nod1, &nod);
            regfree(&nod1);
        }
        if(nn != Z)
            gmove(&nod, nn);
        if(hardleft)
            regfree(&nod);
        break;

    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASMUL:
    case OASDIV:
    case OASMOD:
        if(l->op == OBIT)
            goto asbitop;
        if(typefd[n->type->etype]||typefd[r->type->etype])
            goto asfop;
        if(r->op == OCONST) {
            SET(v);
            switch(o) {
            case OASDIV:
            case OASMOD:
                c = r->vconst;
                if(c < 0)
                    c = -c;
                v = log2(c);
                if(v < 0)
                    break;
                /* fall thru */
            case OASMUL:
            case OASLMUL:
                if(hardleft)
                    reglcgen(&nod2, l, Z);
                else
                    nod2 = *l;
                regalloc(&nod, l, nn);
                cgen(&nod2, &nod);
                switch(o) {
                case OASMUL:
                case OASLMUL:
                    mulgen(n->type, r, &nod);
                    break;
                case OASDIV:
                    sdiv2(r->vconst, v, l, &nod);
                    break;
                case OASMOD:
                    smod2(r->vconst, v, l, &nod);
                    break;
                }
            havev:
                gmove(&nod, &nod2);
                if(nn != Z)
                    gmove(&nod, nn);
                if(hardleft)
                    regfree(&nod2);
                regfree(&nod);
                goto done;
            case OASLDIV:
                c = r->vconst;
                if((c & 0x80000000) == 0)
                    break;
                if(hardleft)
                    reglcgen(&nod2, l, Z);
                else
                    nod2 = *l;
                regalloc(&nod1, l, nn);
                cgen(&nod2, &nod1);
                regalloc(&nod, l, nn);
                zeroregm(&nod);
                gins(ACMPL, &nod1, nodconst(c));
                gins(ASBBL, nodconst(-1), &nod);
                regfree(&nod1);
                goto havev;
            }
        }

        if(o == OASMUL) {
/* should favour AX */
            regalloc(&nod, l, nn);
            if(r->complex >= FNX) {
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                r = &nod1;
            }
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(r->addable < INDEXED) {
                if(r->complex < FNX) {
                    regalloc(&nod1, r, Z);
                    cgen(r, &nod1);
                }
                gopcode(OASMUL, n->type, &nod1, &nod);
                regfree(&nod1);
            }
            else
                gopcode(OASMUL, n->type, r, &nod);
            if(r == &nod1)
                regfree(r);
            gmove(&nod, &nod2);
            if(nn != Z)
                gmove(&nod, nn);
            regfree(&nod);
            if(hardleft)
                regfree(&nod2);
            goto done;
        }

        /*
         * get nod to be D_AX
         * get nod1 to be D_DX
         */
        if(nodreg(&nod, nn, D_AX)) {
            regsalloc(&nod2, n);
            gmove(&nod, &nod2);
            v = reg[D_AX];
            reg[D_AX] = 0;

            if(isreg(l, D_AX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_AX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod);
            reg[D_AX] = v;
            break;
        }
        if(nodreg(&nod1, nn, D_DX)) {
            regsalloc(&nod2, n);
            gmove(&nod1, &nod2);
            v = reg[D_DX];
            reg[D_DX] = 0;

            if(isreg(l, D_DX)) {
                nod3 = *n;
                nod3.left = &nod2;
                cgen(&nod3, nn);
            } else
            if(isreg(r, D_DX)) {
                nod3 = *n;
                nod3.right = &nod2;
                cgen(&nod3, nn);
            } else
                cgen(n, nn);

            gmove(&nod2, &nod1);
            reg[D_DX] = v;
            break;
        }
        reg[D_AX]++;
        reg[D_DX]++;

        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(r->op == OCONST) {
                switch(o) {
                case OASDIV:
                    sdivgen(&nod2, r, &nod, &nod1);
                    goto divdone;
                case OASLDIV:
                    udivgen(&nod2, r, &nod, &nod1);
                divdone:
                    gmove(&nod1, &nod2);
                    if(nn != Z)
                        gmove(&nod1, nn);
                    goto freelxaxdx;
                }
            }
            if(o == OASDIV || o == OASMOD)
                gins(ACDQ, Z, Z);
            if(o == OASLDIV || o == OASLMOD)
                zeroregm(&nod1);
            if(r->addable < INDEXED || r->op == OCONST ||
               !typeil[r->type->etype]) {
                regalloc(&nod3, r, Z);
                cgen(r, &nod3);
                gopcode(o, l->type, &nod3, Z);
                regfree(&nod3);
            } else
                gopcode(o, n->type, r, Z);
        } else {
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
            if(hardleft)
                reglcgen(&nod2, l, Z);
            else
                nod2 = *l;
            cgen(&nod2, &nod);
            if(o == OASDIV || o == OASMOD)
                gins(ACDQ, Z, Z);
            if(o == OASLDIV || o == OASLMOD)
                zeroregm(&nod1);
            gopcode(o, l->type, &nod3, Z);
            regfree(&nod3);
        }
        if(o == OASMOD || o == OASLMOD) {
            gmove(&nod1, &nod2);
            if(nn != Z)
                gmove(&nod1, nn);
        } else {
            gmove(&nod, &nod2);
            if(nn != Z)
                gmove(&nod, nn);
        }
    freelxaxdx:
        if(hardleft)
            regfree(&nod2);
        regfree(&nod);
        regfree(&nod1);
        break;

    fop:
        if(l->complex >= r->complex) {
            cgen(l, &fregnode0);
            if(r->addable < INDEXED) {
                cgen(r, &fregnode0);
                fgopcode(o, &fregnode0, &fregnode1, 1, 0);
            } else
                fgopcode(o, r, &fregnode0, 0, 0);
        } else {
            cgen(r, &fregnode0);
            if(l->addable < INDEXED) {
                cgen(l, &fregnode0);
                fgopcode(o, &fregnode0, &fregnode1, 1, 1);
            } else
                fgopcode(o, l, &fregnode0, 0, 1);
        }
        gmove(&fregnode0, nn);
        break;

    asfop:
        if(l->complex >= r->complex) {
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
            cgen(r, &fregnode0);
        } else {
            cgen(r, &fregnode0);
            if(hardleft)
                reglcgen(&nod, l, Z);
            else
                nod = *l;
        }
        if(!typefd[l->type->etype]) {
            gmove(&nod, &fregnode0);
            fgopcode(o, &fregnode0, &fregnode1, 1, 1);
        } else
            fgopcode(o, &nod, &fregnode0, 0, 1);
        if(nn != Z)
            gins(AFMOVD, &fregnode0, &fregnode0);
        gmove(&fregnode0, &nod);
        if(nn != Z)
            gmove(&fregnode0, nn);
        if(hardleft)
            regfree(&nod);
        break;

    asbitop:
        regalloc(&nod4, n, nn);
        if(l->complex >= r->complex) {
            bitload(l, &nod, &nod1, &nod2, &nod4);
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
        } else {
            regalloc(&nod3, r, Z);
            cgen(r, &nod3);
            bitload(l, &nod, &nod1, &nod2, &nod4);
        }
        gmove(&nod, &nod4);

        if(typefd[nod3.type->etype])
            fgopcode(o, &fregnode0, &fregnode1, 1, 1);
        else {
            Node onod;

            /* incredible grot ... */
            onod = nod3;
            onod.op = o;
            onod.complex = 2;
            onod.addable = 0;
            onod.type = tfield;
            onod.left = &nod4;
            onod.right = &nod3;
            cgen(&onod, Z);
        }
        regfree(&nod3);
        gmove(&nod4, &nod);
        regfree(&nod4);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;

    case OADDR:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        lcgen(l, nn);
        break;

    case OFUNC:
        l = uncomma(l);
        if(l->complex >= FNX) {
            if(l->op != OIND)
                diag(n, "bad function call");

            regret(&nod, l->left);
            cgen(l->left, &nod);
            regsalloc(&nod1, l->left);
            gmove(&nod, &nod1);
            regfree(&nod);

            nod = *n;
            nod.left = &nod2;
            nod2 = *l;
            nod2.left = &nod1;
            nod2.complex = 1;
            cgen(&nod, nn);

            return;
        }
        gargs(r, &nod, &nod1);
        if(l->addable < INDEXED) {
            reglcgen(&nod, l, nn);
            nod.op = OREGISTER;
            gopcode(OFUNC, n->type, Z, &nod);
            regfree(&nod);
        } else
            gopcode(OFUNC, n->type, Z, l);
        if(REGARG>=0 && reg[REGARG])
            reg[REGARG]--;
        if(nn != Z) {
            regret(&nod, n);
            gmove(&nod, nn);
            regfree(&nod);
        } else
        if(typefd[n->type->etype])
            gins(AFMOVDP, &fregnode0, &fregnode0);
        break;

    case OIND:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        regialloc(&nod, n, nn);
        r = l;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r)) {
            v = r->vconst;
            r->vconst = 0;
            cgen(l, &nod);
            nod.xoffset += v;
            r->vconst = v;
        } else
            cgen(l, &nod);
        regind(&nod, n);
        gmove(&nod, nn);
        regfree(&nod);
        break;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OLO:
    case OLS:
    case OHI:
    case OHS:
        if(nn == Z) {
            nullwarn(l, r);
            break;
        }
        boolgen(n, 1, nn);
        break;

    case OANDAND:
    case OOROR:
        boolgen(n, 1, nn);
        if(nn == Z)
            patch(p, pc);
        break;

    case ONOT:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        boolgen(n, 1, nn);
        break;

    case OCOMMA:
        cgen(l, Z);
        cgen(r, nn);
        break;

    case OCAST:
        if(nn == Z) {
            nullwarn(l, Z);
            break;
        }
        /*
         * convert from types l->n->nn
         */
        if(nocast(l->type, n->type) && nocast(n->type, nn->type)) {
            /* both null, gen l->nn */
            cgen(l, nn);
            break;
        }
        if(typev[l->type->etype]) {
            cgen64(n, nn);
            break;
        }
        regalloc(&nod, l, nn);
        cgen(l, &nod);
        regalloc(&nod1, n, &nod);
        gmove(&nod, &nod1);
        gmove(&nod1, nn);
        regfree(&nod1);
        regfree(&nod);
        break;

    case ODOT:
        sugen(l, nodrat, l->type->width);
        if(nn == Z)
            break;
        warn(n, "non-interruptable temporary");
        nod = *nodrat;
        if(!r || r->op != OCONST) {
            diag(n, "DOT and no offset");
            break;
        }
        nod.xoffset += (long)r->vconst;
        nod.type = n->type;
        cgen(&nod, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        cgen(r->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        cgen(r->right, nn);
        patch(p1, pc);
        break;

    case OPOSTINC:
    case OPOSTDEC:
        v = 1;
        if(l->type->etype == TIND)
            v = l->type->link->width;
        if(o == OPOSTDEC)
            v = -v;
        if(l->op == OBIT)
            goto bitinc;
        if(nn == Z)
            goto pre;

        if(hardleft)
            reglcgen(&nod, l, Z);
        else
            nod = *l;

        if(typefd[n->type->etype])
            goto fltinc;
        gmove(&nod, nn);
        gopcode(OADD, n->type, nodconst(v), &nod);
        if(hardleft)
            regfree(&nod);
        break;

    case OPREINC:
    case OPREDEC:
        v = 1;
        if(l->type->etype == TIND)
            v = l->type->link->width;
        if(o == OPREDEC)
            v = -v;
        if(l->op == OBIT)
            goto bitinc;

    pre:
        if(hardleft)
            reglcgen(&nod, l, Z);
        else
            nod = *l;
        if(typefd[n->type->etype])
            goto fltinc;
        gopcode(OADD, n->type, nodconst(v), &nod);
        if(nn != Z)
            gmove(&nod, nn);
        if(hardleft)
            regfree(&nod);
        break;

    fltinc:
        gmove(&nod, &fregnode0);
        if(nn != Z && (o == OPOSTINC || o == OPOSTDEC))
            gins(AFMOVD, &fregnode0, &fregnode0);
        gins(AFLD1, Z, Z);
        if(v < 0)
            fgopcode(OSUB, &fregnode0, &fregnode1, 1, 0);
        else
            fgopcode(OADD, &fregnode0, &fregnode1, 1, 0);
        if(nn != Z && (o == OPREINC || o == OPREDEC))
            gins(AFMOVD, &fregnode0, &fregnode0);
        gmove(&fregnode0, &nod);
        if(hardleft)
            regfree(&nod);
        break;

    bitinc:
        if(nn != Z && (o == OPOSTINC || o == OPOSTDEC)) {
            bitload(l, &nod, &nod1, &nod2, Z);
            gmove(&nod, nn);
            gopcode(OADD, tfield, nodconst(v), &nod);
            bitstore(l, &nod, &nod1, &nod2, Z);
            break;
        }
        bitload(l, &nod, &nod1, &nod2, nn);
        gopcode(OADD, tfield, nodconst(v), &nod);
        bitstore(l, &nod, &nod1, &nod2, nn);
        break;
    }
done:
    cursafe = curs;
}
@


<<function reglcgen>>=
void
reglcgen(Node *t, Node *n, Node *nn)
{
    Node *r;
    long v;

    regialloc(t, n, nn);
    if(n->op == OIND) {
        r = n->left;
        while(r->op == OADD)
            r = r->right;
        if(sconst(r)) {
            v = r->vconst;
            r->vconst = 0;
            lcgen(n, t);
            t->xoffset += v;
            r->vconst = v;
            regind(t, n);
            return;
        }
    }
    lcgen(n, t);
    regind(t, n);
}
@

<<function lcgen>>=
void
lcgen(Node *n, Node *nn)
{
    Prog *p1;
    Node nod;

    if(debug['g']) {
        prtree(nn, "lcgen lhs");
        prtree(n, "lcgen");
    }

    if(n == Z || n->type == T)
        return;
    if(nn == Z) {
        nn = &nod;
        regalloc(&nod, n, Z);
    }
    switch(n->op) {
    default:
        if(n->addable < INDEXED) {
            diag(n, "unknown op in lcgen: %O", n->op);
            break;
        }
        gopcode(OADDR, n->type, n, nn);
        break;

    case OCOMMA:
        cgen(n->left, n->left);
        lcgen(n->right, nn);
        break;

    case OIND:
        cgen(n->left, nn);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        lcgen(n->right->left, nn);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        lcgen(n->right->right, nn);
        patch(p1, pc);
        break;
    }
}
@

<<function uncomma>>=
Node*
uncomma(Node *n)
{
    while(n != Z && n->op == OCOMMA) {
        cgen(n->left, Z);
        n = n->right;
    }
    return n;
}
@

\section{[[bcomplex()]]}

<<function bcomplex>>=
int
bcomplex(Node *n, Node *c)
{
//    Node *b, nod;

    complex(n);
    if(n->type != T)
    if(tcompat(n, T, n->type, tnot))
        n->type = T;
    if(n->type == T) {
        gbranch(OGOTO);
        return 0;
    }
    if(c != Z && n->op == OCONST && deadheads(c))
        return 1;

    /* this is not quite right yet, so ignore it for now */
//    if(0 && newvlongcode && typev[n->type->etype] && machcap(Z)) {
//        b = &nod;
//        b->op = ONE;
//        b->left = n;
//        b->right = new(0, Z, Z);
//        *b->right = *nodconst(0);
//        b->right->type = n->type;
//        b->type = types[TLONG];
//        cgen(b, Z);
//        return 0;
//    }

    bool64(n);
    boolgen(n, 1, Z);
    return 0;
}
@


\section{[[boolgen()]]}

<<function boolgen>>=
void
boolgen(Node *n, int true, Node *nn)
{
    int o;
    Prog *p1, *p2;
    Node *l, *r, nod, nod1;
    long curs;

    if(debug['g']) {
        prtree(nn, "boolgen lhs");
        prtree(n, "boolgen");
    }

    curs = cursafe;
    l = n->left;
    r = n->right;
    switch(n->op) {

    default:
        if(typev[n->type->etype]) {
            testv(n, true);
            goto com;
        }
        o = ONE;
        if(true)
            o = OEQ;
        if(typefd[n->type->etype]) {
            if(n->addable < INDEXED) {
                cgen(n, &fregnode0);
                gins(AFLDZ, Z, Z);
                fgopcode(o, &fregnode0, &fregnode1, 1, 1);
            } else {
                gins(AFLDZ, Z, Z);
                fgopcode(o, n, &fregnode0, 0, 1);
            }
            goto com;
        }
        /* bad, 13 is address of external that becomes constant */
        if(n->addable >= INDEXED && n->addable != 13) {
            gopcode(o, n->type, n, nodconst(0));
            goto com;
        }
        regalloc(&nod, n, nn);
        cgen(n, &nod);
        gopcode(o, n->type, &nod, nodconst(0));
        regfree(&nod);
        goto com;

    case OCONST:
        o = vconst(n);
        if(!true)
            o = !o;
        gbranch(OGOTO);
        if(o) {
            p1 = p;
            gbranch(OGOTO);
            patch(p1, pc);
        }
        goto com;

    case OCOMMA:
        cgen(l, Z);
        boolgen(r, true, nn);
        break;

    case ONOT:
        boolgen(l, !true, nn);
        break;

    case OCOND:
        bcgen(l, 1);
        p1 = p;
        bcgen(r->left, true);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        bcgen(r->right, !true);
        patch(p2, pc);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OANDAND:
        if(!true)
            goto caseor;

    caseand:
        bcgen(l, true);
        p1 = p;
        bcgen(r, !true);
        p2 = p;
        patch(p1, pc);
        gbranch(OGOTO);
        patch(p2, pc);
        goto com;

    case OOROR:
        if(!true)
            goto caseand;

    caseor:
        bcgen(l, !true);
        p1 = p;
        bcgen(r, !true);
        p2 = p;
        gbranch(OGOTO);
        patch(p1, pc);
        patch(p2, pc);
        goto com;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        o = n->op;
        if(typev[l->type->etype]) {
            if(!true)
                n->op = comrel[relindex(o)];
            cgen64(n, Z);
            goto com;
        }
        if(true)
            o = comrel[relindex(o)];
        if(l->complex >= FNX && r->complex >= FNX) {
            regret(&nod, r);
            cgen(r, &nod);
            regsalloc(&nod1, r);
            gmove(&nod, &nod1);
            regfree(&nod);
            nod = *n;
            nod.right = &nod1;
            boolgen(&nod, true, nn);
            break;
        }
        if(typefd[l->type->etype]) {
            if(l->complex >= r->complex) {
                cgen(l, &fregnode0);
                if(r->addable < INDEXED) {
                    cgen(r, &fregnode0);
                    o = invrel[relindex(o)];
                    fgopcode(o, &fregnode0, &fregnode1, 1, 1);
                } else
                    fgopcode(o, r, &fregnode0, 0, 1);
            } else {
                o = invrel[relindex(o)];
                cgen(r, &fregnode0);
                if(l->addable < INDEXED) {
                    cgen(l, &fregnode0);
                    o = invrel[relindex(o)];
                    fgopcode(o, &fregnode0, &fregnode1, 1, 1);
                } else
                    fgopcode(o, l, &fregnode0, 0, 1);
            }
            goto com;
        }
        if(l->op == OCONST) {
            o = invrel[relindex(o)];
            /* bad, 13 is address of external that becomes constant */
            if(r->addable < INDEXED || r->addable == 13) {
                regalloc(&nod, r, nn);
                cgen(r, &nod);
                gopcode(o, l->type, &nod, l);
                regfree(&nod);
            } else
                gopcode(o, l->type, r, l);
            goto com;
        }
        if(l->complex >= r->complex) {
            regalloc(&nod, l, nn);
            cgen(l, &nod);
            if(r->addable < INDEXED) {
                regalloc(&nod1, r, Z);
                cgen(r, &nod1);
                gopcode(o, l->type, &nod, &nod1);
                regfree(&nod1);
            } else
                gopcode(o, l->type, &nod, r);
            regfree(&nod);
            goto com;
        }
        regalloc(&nod, r, nn);
        cgen(r, &nod);
        if(l->addable < INDEXED || l->addable == 13) {
            regalloc(&nod1, l, Z);
            cgen(l, &nod1);
            if(typechlp[l->type->etype])
                gopcode(o, types[TINT], &nod1, &nod);
            else
                gopcode(o, l->type, &nod1, &nod);
            regfree(&nod1);
        } else
            gopcode(o, l->type, l, &nod);
        regfree(&nod);

    com:
        if(nn != Z) {
            p1 = p;
            gmove(nodconst(1L), nn);
            gbranch(OGOTO);
            p2 = p;
            patch(p1, pc);
            gmove(nodconst(0L), nn);
            patch(p2, pc);
        }
        break;
    }
    cursafe = curs;
}
@



<<function bcgen>>=
void
bcgen(Node *n, int true)
{

    if(n->type == T)
        gbranch(OGOTO);
    else
        boolgen(n, true, Z);
}
@

\section{[[relxxx()]]}

<<function relindex>>=
int
relindex(int o)
{

    switch(o) {
    default:
        diag(Z, "bad in relindex: %O", o);
    case OEQ: return 0;
    case ONE: return 1;
    case OLE: return 2;
    case OLS: return 3;
    case OLT: return 4;
    case OLO: return 5;
    case OGE: return 6;
    case OHS: return 7;
    case OGT: return 8;
    case OHI: return 9;
    }
}
@


<<global comrel>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
char	comrel[12] =
{
    ONE, OEQ, OGT, OHI, OGE, OHS, OLT, OLO, OLE, OLS,
};
@

<<global invrel>>=
char	invrel[12] =
{
    OEQ, ONE, OGE, OHS, OGT, OHI, OLE, OLS, OLT, OLO,
};
@

<<global logrel>>=
char	logrel[12] =
{
    OEQ, ONE, OLS, OLS, OLO, OLO, OHS, OHS, OHI, OHI,
};
@


\section{[[sugen()]]}

<<function sugen>>=
void
sugen(Node *n, Node *nn, long w)
{
    Prog *p1;
    Node nod0, nod1, nod2, nod3, nod4, *h, *l, *r;
    Type *t;
    int c, v, x;

    if(n == Z || n->type == T)
        return;
    if(debug['g']) {
        prtree(nn, "sugen lhs");
        prtree(n, "sugen");
    }

    if(nn == nodrat)
        if(w > nrathole)
            nrathole = w;
    switch(n->op) {
    case OIND:
        if(nn == Z) {
            nullwarn(n->left, Z);
            break;
        }

    default:
        goto copy;

    case OCONST:
        if(n->type && typev[n->type->etype]) {
            if(nn == Z) {
                nullwarn(n->left, Z);
                break;
            }

            if(nn->op == OREGPAIR) {
                loadpair(n, nn);
                break;
            }
            else if(!vaddr(nn, 0)) {
                t = nn->type;
                nn->type = types[TLONG];
                reglcgen(&nod1, nn, Z);
                nn->type = t;

                gmove(lo64(n), &nod1);
                nod1.xoffset += SZ_LONG;
                gmove(hi64(n), &nod1);
                regfree(&nod1);
            }
            else {
                gins(AMOVL, lo64(n), nn);
                nn->xoffset += SZ_LONG;
                gins(AMOVL, hi64(n), nn);
                nn->xoffset -= SZ_LONG;
                break;
            }
            break;
        }
        goto copy;

    case ODOT:
        l = n->left;
        sugen(l, nodrat, l->type->width);
        if(nn == Z)
            break;
        warn(n, "non-interruptable temporary");
        nod1 = *nodrat;
        r = n->right;
        if(!r || r->op != OCONST) {
            diag(n, "DOT and no offset");
            break;
        }
        nod1.xoffset += (long)r->vconst;
        nod1.type = n->type;
        sugen(&nod1, nn, w);
        break;

    case OSTRUCT:
        /*
         * rewrite so lhs has no fn call
         */
        if(nn != Z && side(nn)) {
            nod1 = *n;
            nod1.type = typ(TIND, n->type);
            regret(&nod2, &nod1);
            lcgen(nn, &nod2);
            regsalloc(&nod0, &nod1);
            cgen(&nod2, &nod0);
            regfree(&nod2);

            nod1 = *n;
            nod1.op = OIND;
            nod1.left = &nod0;
            nod1.right = Z;
            nod1.complex = 1;

            sugen(n, &nod1, w);
            return;
        }

        r = n->left;
        for(t = n->type->link; t != T; t = t->down) {
            l = r;
            if(r->op == OLIST) {
                l = r->left;
                r = r->right;
            }
            if(nn == Z) {
                cgen(l, nn);
                continue;
            }
            /*
             * hand craft *(&nn + o) = l
             */
            nod0 = znode;
            nod0.op = OAS;
            nod0.type = t;
            nod0.left = &nod1;
            nod0.right = nil;

            nod1 = znode;
            nod1.op = OIND;
            nod1.type = t;
            nod1.left = &nod2;

            nod2 = znode;
            nod2.op = OADD;
            nod2.type = typ(TIND, t);
            nod2.left = &nod3;
            nod2.right = &nod4;

            nod3 = znode;
            nod3.op = OADDR;
            nod3.type = nod2.type;
            nod3.left = nn;

            nod4 = znode;
            nod4.op = OCONST;
            nod4.type = nod2.type;
            nod4.vconst = t->offset;

            ccom(&nod0);
            acom(&nod0);
            xcom(&nod0);
            nod0.addable = 0;
            nod0.right = l;

            /* prtree(&nod0, "hand craft"); /* */
            cgen(&nod0, Z);
        }
        break;

    case OAS:
        if(nn == Z) {
            if(n->addable < INDEXED)
                sugen(n->right, n->left, w);
            break;
        }

        sugen(n->right, nodrat, w);
        warn(n, "non-interruptable temporary");
        sugen(nodrat, n->left, w);
        sugen(nodrat, nn, w);
        break;

    case OFUNC:
        if(nn == Z) {
            sugen(n, nodrat, w);
            break;
        }
        h = nn;
        if(nn->op == OREGPAIR) {
            regsalloc(&nod1, nn);
            nn = &nod1;
        }
        if(nn->op != OIND) {
            nn = new1(OADDR, nn, Z);
            nn->type = types[TIND];
            nn->addable = 0;
        } else
            nn = nn->left;
        n = new(OFUNC, n->left, new(OLIST, nn, n->right));
        n->type = types[TVOID];
        n->left->type = types[TVOID];
        cgen(n, Z);
        if(h->op == OREGPAIR)
            loadpair(nn->left, h);
        break;

    case OCOND:
        bcgen(n->left, 1);
        p1 = p;
        sugen(n->right->left, nn, w);
        gbranch(OGOTO);
        patch(p1, pc);
        p1 = p;
        sugen(n->right->right, nn, w);
        patch(p1, pc);
        break;

    case OCOMMA:
        cgen(n->left, Z);
        sugen(n->right, nn, w);
        break;
    }
    return;

copy:
    if(nn == Z) {
        switch(n->op) {
        case OASADD:
        case OASSUB:
        case OASAND:
        case OASOR:
        case OASXOR:

        case OASMUL:
        case OASLMUL:

        case OASASHL:
        case OASASHR:
        case OASLSHR:
            break;

        case OPOSTINC:
        case OPOSTDEC:
        case OPREINC:
        case OPREDEC:
            break;

        default:
            return;
        }
    }

    if(n->complex >= FNX && nn != nil && nn->complex >= FNX) {
        t = nn->type;
        nn->type = types[TLONG];
        regialloc(&nod1, nn, Z);
        lcgen(nn, &nod1);
        regsalloc(&nod2, nn);
        nn->type = t;

        gins(AMOVL, &nod1, &nod2);
        regfree(&nod1);

        nod2.type = typ(TIND, t);

        nod1 = nod2;
        nod1.op = OIND;
        nod1.left = &nod2;
        nod1.right = Z;
        nod1.complex = 1;
        nod1.type = t;

        sugen(n, &nod1, w);
        return;
    }

    x = 0;
    v = w == 8;
    if(v) {
        c = cursafe;
        if(n->left != Z && n->left->complex >= FNX
        && n->right != Z && n->right->complex >= FNX) {
//			warn(n, "toughie");
            regsalloc(&nod1, n->right);
            cgen(n->right, &nod1);
            nod2 = *n;
            nod2.right = &nod1;
            cgen(&nod2, nn);
            cursafe = c;
            return;
        }
        if(cgen64(n, nn)) {
            cursafe = c;
            return;
        }
        if(n->op == OCOM) {
            n = n->left;
            x = 1;
        }
    }

    /* botch, need to save in .safe */
    c = 0;
    if(n->complex > nn->complex) {
        t = n->type;
        n->type = types[TLONG];
        if(v) {
            regalloc(&nod0, n, Z);
            if(!vaddr(n, 0)) {
                reglcgen(&nod1, n, Z);
                n->type = t;
                n = &nod1;
            }
            else
                n->type = t;
        }
        else {
            nodreg(&nod1, n, D_SI);
            if(reg[D_SI]) {
                gins(APUSHL, &nod1, Z);
                c |= 1;
                reg[D_SI]++;
            }
            lcgen(n, &nod1);
            n->type = t;
        }

        t = nn->type;
        nn->type = types[TLONG];
        if(v) {
            if(!vaddr(nn, 0)) {
                reglcgen(&nod2, nn, Z);
                nn->type = t;
                nn = &nod2;
            }
            else
                nn->type = t;
        }
        else {
            nodreg(&nod2, nn, D_DI);
            if(reg[D_DI]) {
                gins(APUSHL, &nod2, Z);
                c |= 2;
                reg[D_DI]++;
            }
            lcgen(nn, &nod2);
            nn->type = t;
        }
    } else {
        t = nn->type;
        nn->type = types[TLONG];
        if(v) {
            regalloc(&nod0, nn, Z);
            if(!vaddr(nn, 0)) {
                reglcgen(&nod2, nn, Z);
                nn->type = t;
                nn = &nod2;
            }
            else
                nn->type = t;
        }
        else {
            nodreg(&nod2, nn, D_DI);
            if(reg[D_DI]) {
                gins(APUSHL, &nod2, Z);
                c |= 2;
                reg[D_DI]++;
            }
            lcgen(nn, &nod2);
            nn->type = t;
        }

        t = n->type;
        n->type = types[TLONG];
        if(v) {
            if(!vaddr(n, 0)) {
                reglcgen(&nod1, n, Z);
                n->type = t;
                n = &nod1;
            }
            else
                n->type = t;
        }
        else {
            nodreg(&nod1, n, D_SI);
            if(reg[D_SI]) {
                gins(APUSHL, &nod1, Z);
                c |= 1;
                reg[D_SI]++;
            }
            lcgen(n, &nod1);
            n->type = t;
        }
    }
    if(v) {
        gins(AMOVL, n, &nod0);
        if(x)
            gins(ANOTL, Z, &nod0);
        gins(AMOVL, &nod0, nn);
        n->xoffset += SZ_LONG;
        nn->xoffset += SZ_LONG;
        gins(AMOVL, n, &nod0);
        if(x)
            gins(ANOTL, Z, &nod0);
        gins(AMOVL, &nod0, nn);
        n->xoffset -= SZ_LONG;
        nn->xoffset -= SZ_LONG;
        if(nn == &nod2)
            regfree(&nod2);
        if(n == &nod1)
            regfree(&nod1);
        regfree(&nod0);
        return;
    }
    nodreg(&nod3, n, D_CX);
    if(reg[D_CX]) {
        gins(APUSHL, &nod3, Z);
        c |= 4;
        reg[D_CX]++;
    }
    gins(AMOVL, nodconst(w/SZ_LONG), &nod3);
    gins(ACLD, Z, Z);
    gins(AREP, Z, Z);
    gins(AMOVSL, Z, Z);
    if(w & (SZ_LONG-1)) {
        /* odd length of packed structure */
        gins(AMOVL, nodconst(w & (SZ_LONG-1)), &nod3);
        gins(AREP, Z, Z);
        gins(AMOVSB, Z, Z);
    }
    if(c & 4) {
        gins(APOPL, Z, &nod3);
        reg[D_CX]--;
    }
    if(c & 2) {
        gins(APOPL, Z, &nod2);
        reg[nod2.reg]--;
    }
    if(c & 1) {
        gins(APOPL, Z, &nod1);
        reg[nod1.reg]--;
    }
}
@

\section{Cast}

<<function nocast>>=
/*
 * a cast that generates no code
 * (same size move)
 */
bool
nocast(Type *t1, Type *t2)
{
    int i, b;

    if(t1->nbits)
        return false;
    i = 0;
    if(t2 != T)
        i = t2->etype;
    b = 1<<i;
    i = 0;
    if(t1 != T)
        i = t1->etype;
    if(b & ncast[i])
        return true;
    return false;
}
@

%>>

\section{Multiplication}

<<function mulgen>>=
void
mulgen(Type *t, Node *r, Node *n)
{
    if(!mulgen1(r->vconst, n))
        gopcode(OMUL, t, r, n);
}
@


<<struct Malg>>=
struct	Malg
{
    char	vals[10];
};
@

<<struct Mparam>>=
struct	Mparam
{
    ulong	value;
    char	alg;
    char	neg;
    char	shift;
    char	arg;
    char	off;
};
@

<<global multab>>=
static	Mparam	multab[32];
@

<<global mulptr>>=
static	int	mulptr;
@

<<global malgs>>=
static	Malg	malgs[]	=
{
    {0, 100},
    {-1, 1, 100},
    {-9, -5, -3, 3, 5, 9, 100},
    {6, 10, 12, 18, 20, 24, 36, 40, 72, 100},
    {-8, -4, -2, 2, 4, 8, 100},
};
@

<<function lowbit>>=
/*
 * return position of lowest 1
 */
int
lowbit(ulong v)
{
    int s, i;
    ulong m;

    s = 0;
    m = 0xFFFFFFFFUL;
    for(i = 16; i > 0; i >>= 1) {
        m >>= i;
        if((v & m) == 0) {
            v >>= i;
            s += i;
        }
    }
    return s;
}
@

<<function genmuladd>>=
void
genmuladd(Node *d, Node *s, int m, Node *a)
{
    Node nod;

    nod.op = OINDEX;
    nod.left = a;
    nod.right = s;
    nod.scale = m;
    nod.type = types[TIND];
    nod.xoffset = 0;
    xcom(&nod);
    gopcode(OADDR, d->type, &nod, d);
}
@

<<function mulparam>>=
void
mulparam(ulong m, Mparam *mp)
{
    int c, i, j, n, o, q, s;
    int bc, bi, bn, bo, bq, bs, bt;
    char *p;
    long u;
    ulong t;

    bc = bq = 10;
    bi = bn = bo = bs = bt = 0;
    for(i = 0; i < nelem(malgs); i++) {
        for(p = malgs[i].vals, j = 0; (o = p[j]) < 100; j++)
        for(s = 0; s < 2; s++) {
            c = 10;
            q = 10;
            u = m - o;
            if(u == 0)
                continue;
            if(s) {
                o = -o;
                if(o > 0)
                    continue;
                u = -u;
            }
            n = lowbit(u);
            t = (ulong)u >> n;
            switch(i) {
            case 0:
                if(t == 1) {
                    c = s + 1;
                    q = 0;
                    break;
                }
                switch(t) {
                case 3:
                case 5:
                case 9:
                    c = s + 1;
                    if(n)
                        c++;
                    q = 0;
                    break;
                }
                if(s)
                    break;
                switch(t) {
                case 15:
                case 25:
                case 27:
                case 45:
                case 81:
                    c = 2;
                    if(n)
                        c++;
                    q = 1;
                    break;
                }
                break;
            case 1:
                if(t == 1) {
                    c = 3;
                    q = 3;
                    break;
                }
                switch(t) {
                case 3:
                case 5:
                case 9:
                    c = 3;
                    q = 2;
                    break;
                }
                break;
            case 2:
                if(t == 1) {
                    c = 3;
                    q = 2;
                    break;
                }
                break;
            case 3:
                if(s)
                    break;
                if(t == 1) {
                    c = 3;
                    q = 1;
                    break;
                }
                break;
            case 4:
                if(t == 1) {
                    c = 3;
                    q = 0;
                    break;
                }
                break;
            }
            if(c < bc || (c == bc && q > bq)) {
                bc = c;
                bi = i;
                bn = n;
                bo = o;
                bq = q;
                bs = s;
                bt = t;
            }
        }
    }
    mp->value = m;
    if(bc <= 3) {
        mp->alg = bi;
        mp->shift = bn;
        mp->off = bo;
        mp->neg = bs;
        mp->arg = bt;
    }
    else
        mp->alg = -1;
}
@

<<function m0>>=
int
m0(int a)
{
    switch(a) {
    case -2:
    case 2:
        return 2;
    case -3:
    case 3:
        return 2;
    case -4:
    case 4:
        return 4;
    case -5:
    case 5:
        return 4;
    case 6:
        return 2;
    case -8:
    case 8:
        return 8;
    case -9:
    case 9:
        return 8;
    case 10:
        return 4;
    case 12:
        return 2;
    case 15:
        return 2;
    case 18:
        return 8;
    case 20:
        return 4;
    case 24:
        return 2;
    case 25:
        return 4;
    case 27:
        return 2;
    case 36:
        return 8;
    case 40:
        return 4;
    case 45:
        return 4;
    case 72:
        return 8;
    case 81:
        return 8;
    }
    diag(Z, "bad m0");
    return 0;
}
@

<<function m1>>=
int
m1(int a)
{
    switch(a) {
    case 15:
        return 4;
    case 25:
        return 4;
    case 27:
        return 8;
    case 45:
        return 8;
    case 81:
        return 8;
    }
    diag(Z, "bad m1");
    return 0;
}
@

<<function m2>>=
int
m2(int a)
{
    switch(a) {
    case 6:
        return 2;
    case 10:
        return 2;
    case 12:
        return 4;
    case 18:
        return 2;
    case 20:
        return 4;
    case 24:
        return 8;
    case 36:
        return 4;
    case 40:
        return 8;
    case 72:
        return 8;
    }
    diag(Z, "bad m2");
    return 0;
}
@

<<function shiftit>>=
void
shiftit(Type *t, Node *s, Node *d)
{
    long c;

    c = (long)s->vconst & 31;
    switch(c) {
    case 0:
        break;
    case 1:
        gopcode(OADD, t, d, d);
        break;
    default:
        gopcode(OASHL, t, s, d);
    }
}
@

<<function mulgen1>>=
static int
mulgen1(ulong v, Node *n)
{
    int i, o;
    Mparam *p;
    Node nod, nods;

    for(i = 0; i < nelem(multab); i++) {
        p = &multab[i];
        if(p->value == v)
            goto found;
    }

    p = &multab[mulptr];
    if(++mulptr == nelem(multab))
        mulptr = 0;

    mulparam(v, p);

found:
//	print("v=%.lx a=%d n=%d s=%d g=%d o=%d \n", p->value, p->alg, p->neg, p->shift, p->arg, p->off);
    if(p->alg < 0)
        return 0;

    nods = *nodconst(p->shift);

    o = OADD;
    if(p->alg > 0) {
        regalloc(&nod, n, Z);
        if(p->off < 0)
            o = OSUB;
    }

    switch(p->alg) {
    case 0:
        switch(p->arg) {
        case 1:
            shiftit(n->type, &nods, n);
            break;
        case 15:
        case 25:
        case 27:
        case 45:
        case 81:
            genmuladd(n, n, m1(p->arg), n);
            /* fall thru */
        case 3:
        case 5:
        case 9:
            genmuladd(n, n, m0(p->arg), n);
            shiftit(n->type, &nods, n);
            break;
        default:
            goto bad;
        }
        if(p->neg == 1)
            gins(ANEGL, Z, n);
        break;
    case 1:
        switch(p->arg) {
        case 1:
            gmove(n, &nod);
            shiftit(n->type, &nods, &nod);
            break;
        case 3:
        case 5:
        case 9:
            genmuladd(&nod, n, m0(p->arg), n);
            shiftit(n->type, &nods, &nod);
            break;
        default:
            goto bad;
        }
        if(p->neg)
            gopcode(o, n->type, &nod, n);
        else {
            gopcode(o, n->type, n, &nod);
            gmove(&nod, n);
        }
        break;
    case 2:
        genmuladd(&nod, n, m0(p->off), n);
        shiftit(n->type, &nods, n);
        goto comop;
    case 3:
        genmuladd(&nod, n, m0(p->off), n);
        shiftit(n->type, &nods, n);
        genmuladd(n, &nod, m2(p->off), n);
        break;
    case 4:
        genmuladd(&nod, n, m0(p->off), nodconst(0));
        shiftit(n->type, &nods, n);
        goto comop;
    default:
        diag(Z, "bad mul alg");
        break;
    comop:
        if(p->neg) {
            gopcode(o, n->type, n, &nod);
            gmove(&nod, n);
        }
        else
            gopcode(o, n->type, &nod, n);
    }

    if(p->alg > 0)
        regfree(&nod);

    return 1;

bad:
    diag(Z, "mulgen botch");
    return 1;
}
@



\section{Division}

% sdiv vs sdiv2, ??

<<function TN>>=
/*
 * Based on: Granlund, T.; Montgomery, P.L.
 * "Division by Invariant Integers using Multiplication".
 * SIGPLAN Notices, Vol. 29, June 1994, page 61.
 */

#define	TN(n)	((uvlong)1 << (n))
@
% >>

<<constant T31>>=
#define	T31	TN(31)
@

<<constant T32>>=
#define	T32	TN(32)
@

<<function multiplier>>=
int
multiplier(ulong d, int p, uvlong *mp)
{
    int l;
    uvlong mlo, mhi, tlo, thi;

    l = topbit(d - 1) + 1;
    mlo = (((TN(l) - d) << 32) / d) + T32;
    if(l + p == 64)
        mhi = (((TN(l) + 1 - d) << 32) / d) + T32;
    else
        mhi = (TN(32 + l) + TN(32 + l - p)) / d;
    assert(mlo < mhi);
    while(l > 0) {
        tlo = mlo >> 1;
        thi = mhi >> 1;
        if(tlo == thi)
            break;
        mlo = tlo;
        mhi = thi;
        l--;
    }
    *mp = mhi;
    return l;
}
@

<<function sdiv>>=
int
sdiv(ulong d, ulong *mp, int *sp)
{
    int s;
    uvlong m;

    s = multiplier(d, 32 - 1, &m);
    *mp = m;
    *sp = s;
    if(m >= T31)
        return 1;
    else
        return 0;
}
@

<<function udiv>>=
int
udiv(ulong d, ulong *mp, int *sp, int *pp)
{
    int p, s;
    uvlong m;

    s = multiplier(d, 32, &m);
    p = 0;
    if(m >= T32) {
        while((d & 1) == 0) {
            d >>= 1;
            p++;
        }
        s = multiplier(d, 32 - p, &m);
    }
    *mp = m;
    *pp = p;
    if(m >= T32) {
        assert(p == 0);
        *sp = s - 1;
        return 1;
    }
    else {
        *sp = s;
        return 0;
    }
}
@

<<function sdivgen>>=
void
sdivgen(Node *l, Node *r, Node *ax, Node *dx)
{
    int a, s;
    ulong m;
    vlong c;

    c = r->vconst;
    if(c < 0)
        c = -c;
    a = sdiv(c, &m, &s);
//print("a=%d i=%ld s=%d m=%lux\n", a, (long)r->vconst, s, m);
    gins(AMOVL, nodconst(m), ax);
    gins(AIMULL, l, Z);
    gins(AMOVL, l, ax);
    if(a)
        gins(AADDL, ax, dx);
    gins(ASHRL, nodconst(31), ax);
    gins(ASARL, nodconst(s), dx);
    gins(AADDL, ax, dx);
    if(r->vconst < 0)
        gins(ANEGL, Z, dx);
}
@

<<function udivgen>>=
void
udivgen(Node *l, Node *r, Node *ax, Node *dx)
{
    int a, s, t;
    ulong m;
    Node nod;

    a = udiv(r->vconst, &m, &s, &t);
//print("a=%ud i=%ld p=%d s=%d m=%lux\n", a, (long)r->vconst, t, s, m);
    if(t != 0) {
        gins(AMOVL, l, ax);
        gins(ASHRL, nodconst(t), ax);
        gins(AMOVL, nodconst(m), dx);
        gins(AMULL, dx, Z);
    }
    else if(a) {
        if(l->op != OREGISTER) {
            regalloc(&nod, l, Z);
            gins(AMOVL, l, &nod);
            l = &nod;
        }
        gins(AMOVL, nodconst(m), ax);
        gins(AMULL, l, Z);
        gins(AADDL, l, dx);
        gins(ARCRL, nodconst(1), dx);
        if(l == &nod)
            regfree(l);
    }
    else {
        gins(AMOVL, nodconst(m), ax);
        gins(AMULL, l, Z);
    }
    if(s != 0)
        gins(ASHRL, nodconst(s), dx);
}
@

<<function sext>>=
void
sext(Node *d, Node *s, Node *l)
{
    if(s->reg == D_AX && !nodreg(d, Z, D_DX)) {
        reg[D_DX]++;
        gins(ACDQ, Z, Z);
    }
    else {
        regalloc(d, l, Z);
        gins(AMOVL, s, d);
        gins(ASARL, nodconst(31), d);
    }
}
@

<<function sdiv2>>=
void
sdiv2(long c, int v, Node *l, Node *n)
{
    Node nod;

    if(v > 0) {
        if(v > 1) {
            sext(&nod, n, l);
            gins(AANDL, nodconst((1 << v) - 1), &nod);
            gins(AADDL, &nod, n);
            regfree(&nod);
        }
        else {
            gins(ACMPL, n, nodconst(0x80000000));
            gins(ASBBL, nodconst(-1), n);
        }
        gins(ASARL, nodconst(v), n);
    }
    if(c < 0)
        gins(ANEGL, Z, n);
}
@

<<function smod2>>=
void
smod2(long c, int v, Node *l, Node *n)
{
    Node nod;

    if(c == 1) {
        zeroregm(n);
        return;
    }

    sext(&nod, n, l);
    if(v == 0) {
        zeroregm(n);
        gins(AXORL, &nod, n);
        gins(ASUBL, &nod, n);
    }
    else if(v > 1) {
        gins(AANDL, nodconst((1 << v) - 1), &nod);
        gins(AADDL, &nod, n);
        gins(AANDL, nodconst((1 << v) - 1), n);
        gins(ASUBL, &nod, n);
    }
    else {
        gins(AANDL, nodconst(1), n);
        gins(AXORL, &nod, n);
        gins(ASUBL, &nod, n);
    }
    regfree(&nod);
}
@
% >> >> >>

\section{Initializers}

\section{Strings}

<<global symstring>>=
Sym*	symstring;
@


<<function outlstring>>=
long
outlstring(TRune *s, long n)
{
    char buf[sizeof(TRune)];
    uint c;
    int i;
    long r;

    if(suppress)
        return nstring;
    while(nstring & (sizeof(TRune)-1))
        outstring("", 1);
    r = nstring;
    while(n > 0) {
        c = *s++;
        if(align(0, types[TCHAR], Aarg1)) {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*(sizeof(TRune) - i - 1));
        } else {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*i);
        }
        outstring(buf, sizeof(TRune));
        n -= sizeof(TRune);
    }
    return r;
}
@

\section{Sizes}
%x86!

% TODO use [xx] extension instead of those comments?
%  but then more complicated to bootstrap with other C compiler?
<<global ewidth>>=
schar	ewidth[NTYPE] =
{
    -1,		/*[TXXX]*/	
    SZ_CHAR,	/*[TCHAR]*/	
    SZ_CHAR,	/*[TUCHAR]*/
    SZ_SHORT,	/*[TSHORT]*/
    SZ_SHORT,	/*[TUSHORT]*/
    SZ_INT,		/*[TINT]*/
    SZ_INT,		/*[TUINT]*/
    SZ_LONG,	/*[TLONG]*/
    SZ_LONG,	/*[TULONG]*/
    SZ_VLONG,	/*[TVLONG]*/
    SZ_VLONG,	/*[TUVLONG]*/
    SZ_FLOAT,	/*[TFLOAT]*/
    SZ_DOUBLE,	/*[TDOUBLE]*/
    SZ_IND,		/*[TIND]*/
    0,		/*[TFUNC]*/
    -1,		/*[TARRAY]*/
    0,		/*[TVOID]*/
    -1,		/*[TSTRUCT]*/
    -1,		/*[TUNION]*/
    SZ_INT,		/*[TENUM]*/
};
@

<<constant SZ_CHAR>>=
/*
 * 8c/386
 * Intel 386
 */
#define	SZ_CHAR		1
@

<<constant SZ_SHORT>>=
#define	SZ_SHORT	2
@

<<constant SZ_INT>>=
#define	SZ_INT		4
@

<<constant SZ_LONG>>=
#define	SZ_LONG		4
@

<<constant SZ_IND>>=
#define	SZ_IND		4
@

<<constant SZ_FLOAT>>=
#define	SZ_FLOAT	4
@

% 64 bits!
<<constant SZ_VLONG>>=
#define	SZ_VLONG	8
@

<<constant SZ_DOUBLE>>=
#define	SZ_DOUBLE	8
@

\section{Alignment}

<<enum axxx>>=
enum axxx
{
    Axxx,

    Ael1,
    Ael2,
    Asu2,
    Aarg0,
    Aarg1,
    Aarg2,
    Aaut3,

    NALIGN,
};
@

<<global bnames>>=
char*	bnames[NALIGN];
@

<<global bnamesinit>>=
Init	bnamesinit[] =
{
    Axxx,	0,	"Axxx",

    Ael1,	0,	"el1",
    Ael2,	0,	"el2",
    Asu2,	0,	"su2",
    Aarg0,	0,	"arg0",
    Aarg1,	0,	"arg1",
    Aarg2,	0,	"arg2",
    Aaut3,	0,	"aut3",
    -1,	0,	0,
};
@



% called for fields of structures/unions

<<function sualign>>=
//@Scheck: not dead, used by cc.y
void sualign(Type *t)
{
    Type *l;
    long o, w;

    o = 0;
    switch(t->etype) {

    case TSTRUCT:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->nbits) {
                if(l->shift <= 0) {
                    l->shift = -l->shift;
                    w = round(w, tfield->width);
                    o = w;
                    w += tfield->width;
                }
                l->offset = o;
            } else {
                if(l->width < 0 ||
                   l->width == 0 && l->down != T)
                    if(l->sym)
                        diag(Z, "incomplete structure element: %s",
                            l->sym->name);
                    else
                        diag(Z, "incomplete structure element");
                w = align(w, l, Ael1);
                l->offset = w;
                w = align(w, l, Ael2);
            }
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    case TUNION:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->width <= 0)
                if(l->sym)
                    diag(Z, "incomplete union element: %s",
                        l->sym->name);
                else
                    diag(Z, "incomplete union element");
            l->offset = 0;
            l->shift = 0;
            o = align(align(0, l, Ael1), l, Ael2);
            if(o > w)
                w = o;
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    default:
        diag(Z, "unknown type in sualign: %T", t);
        break;
    }
}
@

\chapter{Object Generation}

% 8c -S

% coupling with 8.out.h, but mostly autogenerated enam.c file?
<<global anames>>=
char*	anames[] =
{
    "XXX",
    "AAA",
    "AAD",
    "AAM",
    "AAS",
    "ADCB",
    "ADCL",
    "ADCW",
    "ADDB",
    "ADDL",
    "ADDW",
    "ADJSP",
    "ANDB",
    "ANDL",
    "ANDW",
    "ARPL",
    "BOUNDL",
    "BOUNDW",
    "BSFL",
    "BSFW",
    "BSRL",
    "BSRW",
    "BTL",
    "BTW",
    "BTCL",
    "BTCW",
    "BTRL",
    "BTRW",
    "BTSL",
    "BTSW",
    "BYTE",
    "CALL",
    "CLC",
    "CLD",
    "CLI",
    "CLTS",
    "CMC",
    "CMPB",
    "CMPL",
    "CMPW",
    "CMPSB",
    "CMPSL",
    "CMPSW",
    "DAA",
    "DAS",
    "DATA",
    "DECB",
    "DECL",
    "DECW",
    "DIVB",
    "DIVL",
    "DIVW",
    "ENTER",
    "GLOBL",
    "GOK",
    "HISTORY",
    "HLT",
    "IDIVB",
    "IDIVL",
    "IDIVW",
    "IMULB",
    "IMULL",
    "IMULW",
    "INB",
    "INL",
    "INW",
    "INCB",
    "INCL",
    "INCW",
    "INSB",
    "INSL",
    "INSW",
    "INT",
    "INTO",
    "IRETL",
    "IRETW",
    "JCC",
    "JCS",
    "JCXZ",
    "JEQ",
    "JGE",
    "JGT",
    "JHI",
    "JLE",
    "JLS",
    "JLT",
    "JMI",
    "JMP",
    "JNE",
    "JOC",
    "JOS",
    "JPC",
    "JPL",
    "JPS",
    "LAHF",
    "LARL",
    "LARW",
    "LEAL",
    "LEAW",
    "LEAVEL",
    "LEAVEW",
    "LOCK",
    "LODSB",
    "LODSL",
    "LODSW",
    "LONG",
    "LOOP",
    "LOOPEQ",
    "LOOPNE",
    "LSLL",
    "LSLW",
    "MOVB",
    "MOVL",
    "MOVW",
    "MOVBLSX",
    "MOVBLZX",
    "MOVBWSX",
    "MOVBWZX",
    "MOVWLSX",
    "MOVWLZX",
    "MOVSB",
    "MOVSL",
    "MOVSW",
    "MULB",
    "MULL",
    "MULW",
    "NAME",
    "NEGB",
    "NEGL",
    "NEGW",
    "NOP",
    "NOTB",
    "NOTL",
    "NOTW",
    "ORB",
    "ORL",
    "ORW",
    "OUTB",
    "OUTL",
    "OUTW",
    "OUTSB",
    "OUTSL",
    "OUTSW",
    "POPAL",
    "POPAW",
    "POPFL",
    "POPFW",
    "POPL",
    "POPW",
    "PUSHAL",
    "PUSHAW",
    "PUSHFL",
    "PUSHFW",
    "PUSHL",
    "PUSHW",
    "RCLB",
    "RCLL",
    "RCLW",
    "RCRB",
    "RCRL",
    "RCRW",
    "REP",
    "REPN",
    "RET",
    "ROLB",
    "ROLL",
    "ROLW",
    "RORB",
    "RORL",
    "RORW",
    "SAHF",
    "SALB",
    "SALL",
    "SALW",
    "SARB",
    "SARL",
    "SARW",
    "SBBB",
    "SBBL",
    "SBBW",
    "SCASB",
    "SCASL",
    "SCASW",
    "SETCC",
    "SETCS",
    "SETEQ",
    "SETGE",
    "SETGT",
    "SETHI",
    "SETLE",
    "SETLS",
    "SETLT",
    "SETMI",
    "SETNE",
    "SETOC",
    "SETOS",
    "SETPC",
    "SETPL",
    "SETPS",
    "CDQ",
    "CWD",
    "SHLB",
    "SHLL",
    "SHLW",
    "SHRB",
    "SHRL",
    "SHRW",
    "STC",
    "STD",
    "STI",
    "STOSB",
    "STOSL",
    "STOSW",
    "SUBB",
    "SUBL",
    "SUBW",
    "SYSCALL",
    "TESTB",
    "TESTL",
    "TESTW",
    "TEXT",
    "VERR",
    "VERW",
    "WAIT",
    "WORD",
    "XCHGB",
    "XCHGL",
    "XCHGW",
    "XLAT",
    "XORB",
    "XORL",
    "XORW",
    "FMOVB",
    "FMOVBP",
    "FMOVD",
    "FMOVDP",
    "FMOVF",
    "FMOVFP",
    "FMOVL",
    "FMOVLP",
    "FMOVV",
    "FMOVVP",
    "FMOVW",
    "FMOVWP",
    "FMOVX",
    "FMOVXP",
    "FCOMB",
    "FCOMBP",
    "FCOMD",
    "FCOMDP",
    "FCOMDPP",
    "FCOMF",
    "FCOMFP",
    "FCOML",
    "FCOMLP",
    "FCOMW",
    "FCOMWP",
    "FUCOM",
    "FUCOMP",
    "FUCOMPP",
    "FADDDP",
    "FADDW",
    "FADDL",
    "FADDF",
    "FADDD",
    "FMULDP",
    "FMULW",
    "FMULL",
    "FMULF",
    "FMULD",
    "FSUBDP",
    "FSUBW",
    "FSUBL",
    "FSUBF",
    "FSUBD",
    "FSUBRDP",
    "FSUBRW",
    "FSUBRL",
    "FSUBRF",
    "FSUBRD",
    "FDIVDP",
    "FDIVW",
    "FDIVL",
    "FDIVF",
    "FDIVD",
    "FDIVRDP",
    "FDIVRW",
    "FDIVRL",
    "FDIVRF",
    "FDIVRD",
    "FXCHD",
    "FFREE",
    "FLDCW",
    "FLDENV",
    "FRSTOR",
    "FSAVE",
    "FSTCW",
    "FSTENV",
    "FSTSW",
    "F2XM1",
    "FABS",
    "FCHS",
    "FCLEX",
    "FCOS",
    "FDECSTP",
    "FINCSTP",
    "FINIT",
    "FLD1",
    "FLDL2E",
    "FLDL2T",
    "FLDLG2",
    "FLDLN2",
    "FLDPI",
    "FLDZ",
    "FNOP",
    "FPATAN",
    "FPREM",
    "FPREM1",
    "FPTAN",
    "FRNDINT",
    "FSCALE",
    "FSIN",
    "FSINCOS",
    "FSQRT",
    "FTST",
    "FXAM",
    "FXTRACT",
    "FYL2X",
    "FYL2XP1",
    "END",
    "DYNT",
    "INIT",
    "SIGNAME",
    "FCOMI",
    "FCOMIP",
    "FUCOMI",
    "FUCOMIP",
    "CMPXCHGB",
    "CMPXCHGL",
    "CMPXCHGW",
    "CMOVLCC",
    "CMOVLCS",
    "CMOVLEQ",
    "CMOVLGE",
    "CMOVLGT",
    "CMOVLHI",
    "CMOVLLE",
    "CMOVLLS",
    "CMOVLLT",
    "CMOVLMI",
    "CMOVLNE",
    "CMOVLOC",
    "CMOVLOS",
    "CMOVLPC",
    "CMOVLPL",
    "CMOVLPS",
    "CMOVWCC",
    "CMOVWCS",
    "CMOVWEQ",
    "CMOVWGE",
    "CMOVWGT",
    "CMOVWHI",
    "CMOVWLE",
    "CMOVWLS",
    "CMOVWLT",
    "CMOVWMI",
    "CMOVWNE",
    "CMOVWOC",
    "CMOVWOS",
    "CMOVWPC",
    "CMOVWPL",
    "CMOVWPS",
    "FCMOVCC",
    "FCMOVCS",
    "FCMOVEQ",
    "FCMOVHI",
    "FCMOVLS",
    "FCMOVNE",
    "FCMOVNU",
    "FCMOVUN",
    "LAST",
};
@


<<struct Htab>>=
struct Htab { 
  Sym *sym; 
  short type; 
};
@

<<function outcode>>=
void
outcode(void)
{
    Prog *p;
    Sym *s;
    int f, sf, st, t, sym;
    Biobuf b;
    struct Htab h[NSYM];

    if(debug['S']) {
        for(p = firstp; p != P; p = p->link)
            if(p->as != ADATA && p->as != AGLOBL)
                pc--;
        for(p = firstp; p != P; p = p->link) {
            print("%P\n", p);
            if(p->as != ADATA && p->as != AGLOBL)
                pc++;
        }
    }
    f = open(outfile, OWRITE);
    if(f < 0) {
        diag(Z, "cannot open %s", outfile);
        return;
    }
    Binit(&b, f, OWRITE);
    Bseek(&b, 0L, 2);
    outhist(&b);
    for(sym=0; sym<NSYM; sym++) {
        h[sym].sym = S;
        h[sym].type = 0;
    }
    sym = 1;
    for(p = firstp; p != P; p = p->link) {
    jackpot:
        sf = 0;
        s = p->from.sym;
        while(s != S) {
            sf = s->sym;
            if(sf < 0 || sf >= NSYM)
                sf = 0;
            t = p->from.type;
            if(t == D_ADDR)
                t = p->from.index;
            if(h[sf].type == t)
            if(h[sf].sym == s)
                break;
            s->sym = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            sf = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            break;
        }
        st = 0;
        s = p->to.sym;
        while(s != S) {
            st = s->sym;
            if(st < 0 || st >= NSYM)
                st = 0;
            t = p->to.type;
            if(t == D_ADDR)
                t = p->to.index;
            if(h[st].type == t)
            if(h[st].sym == s)
                break;
            s->sym = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            st = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            if(st == sf)
                goto jackpot;
            break;
        }
        Bputc(&b, p->as);
        Bputc(&b, p->as>>8);
        Bputc(&b, p->lineno);
        Bputc(&b, p->lineno>>8);
        Bputc(&b, p->lineno>>16);
        Bputc(&b, p->lineno>>24);
        zaddr(&b, &p->from, sf);
        zaddr(&b, &p->to, st);
    }
    Bflush(&b);
    close(f);
    firstp = P;
    lastp = P;
}
@


<<global pathname>>=
char*	pathname;
@

<<function outhist>>=
void
outhist(Biobuf *b)
{
    Hist *h;
    char *p, *q, *op, c;
    Prog pg;
    int n;

    pg = zprog;
    pg.as = AHISTORY;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = utfrune(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(b, ANAME);
                Bputc(b, ANAME>>8);
                Bputc(b, D_FILE);
                Bputc(b, 1);
                Bputc(b, '<');
                Bwrite(b, p, n);
                Bputc(b, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        pg.lineno = h->line;
        pg.to.type = zprog.to.type;
        pg.to.offset = h->offset;
        if(h->offset)
            pg.to.type = D_CONST;

        Bputc(b, pg.as);
        Bputc(b, pg.as>>8);
        Bputc(b, pg.lineno);
        Bputc(b, pg.lineno>>8);
        Bputc(b, pg.lineno>>16);
        Bputc(b, pg.lineno>>24);
        zaddr(b, &pg.from, 0);
        zaddr(b, &pg.to, 0);
    }
}
@

<<function zname>>=
void
zname(Biobuf *b, Sym *s, int t)
{
    char *n;
    ulong sig;

    if(debug['T'] && t == D_EXTERN && s->sig != SIGDONE && s->type != types[TENUM] && s != symrathole){
        sig = sign(s);
        Bputc(b, ASIGNAME);
        Bputc(b, ASIGNAME>>8);
        Bputc(b, sig);
        Bputc(b, sig>>8);
        Bputc(b, sig>>16);
        Bputc(b, sig>>24);
        s->sig = SIGDONE;
    }
    else{
        Bputc(b, ANAME);	/* as */
        Bputc(b, ANAME>>8);	/* as */
    }
    Bputc(b, t);			/* type */
    Bputc(b, s->sym);		/* sym */
    n = s->name;
    while(*n) {
        Bputc(b, *n);
        n++;
    }
    Bputc(b, 0);
}
@

<<function zaddr>>=
void
zaddr(Biobuf *b, Adr *a, int s)
{
    long l;
    int i, t;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    default:
        t |= T_TYPE;
    case D_NONE:
        if(a->offset != 0)
            t |= T_OFFSET;
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    }
    Bputc(b, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(b, a->index);
        Bputc(b, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(b, s);
    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        l = e.h;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(b, *n);
            n++;
        }
        return;
    }
    if(t & T_TYPE)
        Bputc(b, a->type);
}
@


\chapter{AST-level Optimisations}
% archi independent

% see compcert list of optimisations? there are all of them here too?
% and more?

\section{AST simplifications}

% using a visitor would be better, to avoid boilerplate

\subsection{[[ccom()]]}

% called from complex(), after tcom()

% cc/com.c
<<function ccom>>=
/*
 *	general rewrite
 *	(IND(ADDR x)) ==> x
 *	(ADDR(IND x)) ==> x
 *	remove some zero operands
 *	remove no op casts
 *	evaluate constants
 */
void
ccom(Node *n)
{
    Node *l, *r;
    int t;

loop:
    if(n == Z)
        return;

    l = n->left;
    r = n->right;

    switch(n->op) {

    case OAS:
    case OASXOR:
    case OASAND:
    case OASOR:
    case OASMOD:
    case OASLMOD:
    case OASLSHR:
    case OASASHR:
    case OASASHL:
    case OASDIV:
    case OASLDIV:
    case OASMUL:
    case OASLMUL:
    case OASSUB:
    case OASADD:
        ccom(l);
        ccom(r);
        if(n->op == OASLSHR || n->op == OASASHR || n->op == OASASHL)
          if(r->op == OCONST) {
            t = n->type->width * 8;	/* bits per byte */
            if(r->vconst >= t || r->vconst < 0)
                warn(n, "stupid shift: %lld", r->vconst);
        }
        break;

    case OCAST:
        ccom(l);
        if(l->op == OCONST) {
            evconst(n);
            if(n->op == OCONST)
                break;
        }
        if(nocast(l->type, n->type) &&
           (!typefd[l->type->etype] || typeu[l->type->etype] && 
           typeu[n->type->etype])) {
            l->type = n->type;
            *n = *l;
        }
        break;

    case OCOND:
        ccom(l);
        ccom(r);
        if(l->op == OCONST)
            if(vconst(l) == 0)
                *n = *r->right;
            else
                *n = *r->left;
        break;

    case OREGISTER:
    case OINDREG:
    case OCONST:
    case ONAME:
        break;

    case OADDR:
        ccom(l);
        l->etype = TVOID;
        if(l->op == OIND) {
            l->left->type = n->type;
            *n = *l->left;
            break;
        }
        goto common;

    case OIND:
        ccom(l);
        if(l->op == OADDR) {
            l->left->type = n->type;
            *n = *l->left;
            break;
        }
        goto common;

    case OEQ:
    case ONE:

    case OLE:
    case OGE:
    case OLT:
    case OGT:

    case OLS:
    case OHS:
    case OLO:
    case OHI:
        ccom(l);
        ccom(r);
        if(compar(n, 0) || compar(n, 1))
            break;
        relcon(l, r);
        relcon(r, l);
        goto common;

    case OASHR:
    case OASHL:
    case OLSHR:
        ccom(l);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        ccom(r);
        if(vconst(r) == 0) {
            *n = *l;
            break;
        }
        if(r->op == OCONST) {
            t = n->type->width * 8;	/* bits per byte */
            if(r->vconst >= t || r->vconst <= -t)
                warn(n, "stupid shift: %lld", r->vconst);
        }
        goto common;

    case OMUL:
    case OLMUL:
        ccom(l);
        t = vconst(l);
        if(t == 0 && !side(r)) {
            *n = *l;
            break;
        }
        if(t == 1) {
            *n = *r;
            goto loop;
        }
        ccom(r);
        t = vconst(r);
        if(t == 0 && !side(l)) {
            *n = *r;
            break;
        }
        if(t == 1) {
            *n = *l;
            break;
        }
        goto common;

    case ODIV:
    case OLDIV:
        ccom(l);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        ccom(r);
        t = vconst(r);
        if(t == 0) {
            diag(n, "divide check");
            *n = *r;
            break;
        }
        if(t == 1) {
            *n = *l;
            break;
        }
        goto common;

    case OSUB:
        ccom(r);
        if(r->op == OCONST) {
            if(typefd[r->type->etype]) {
                n->op = OADD;
                r->fconst = -r->fconst;
                goto loop;
            } else {
                n->op = OADD;
                r->vconst = -r->vconst;
                goto loop;
            }
        }
        ccom(l);
        goto common;

    case OXOR:
    case OOR:
    case OADD:
        ccom(l);
        if(vconst(l) == 0) {
            *n = *r;
            goto loop;
        }
        ccom(r);
        if(vconst(r) == 0) {
            *n = *l;
            break;
        }
        goto commute;

    case OAND:
        ccom(l);
        ccom(r);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        if(vconst(r) == 0 && !side(l)) {
            *n = *r;
            break;
        }

    commute:
        /* look for commutative constant */
        if(r->op == OCONST) {
            if(l->op == n->op) {
                if(l->left->op == OCONST) {
                    n->right = l->right;
                    l->right = r;
                    goto loop;
                }
                if(l->right->op == OCONST) {
                    n->right = l->left;
                    l->left = r;
                    goto loop;
                }
            }
        }
        if(l->op == OCONST) {
            if(r->op == n->op) {
                if(r->left->op == OCONST) {
                    n->left = r->right;
                    r->right = l;
                    goto loop;
                }
                if(r->right->op == OCONST) {
                    n->left = r->left;
                    r->left = l;
                    goto loop;
                }
            }
        }
        goto common;

    case OANDAND:
        ccom(l);
        if(vconst(l) == 0) {
            *n = *l;
            break;
        }
        ccom(r);
        goto common;

    case OOROR:
        ccom(l);
        if(l->op == OCONST && l->vconst != 0) {
            *n = *l;
            n->vconst = 1;
            break;
        }
        ccom(r);
        goto common;

    default:
        if(l != Z)
            ccom(l);
        if(r != Z)
            ccom(r);

    common:
        if(l != Z)
          if(l->op != OCONST)
            break;
        if(r != Z)
          if(r->op != OCONST)
            break;

        evconst(n);
    }
}
@


<<function side>>=
bool
side(Node *n)
{

loop:
    if(n != Z)
    switch(n->op) {
    case OCAST:
    case ONOT:
    case OADDR:
    case OIND:
        n = n->left;
        goto loop;

    case OCOND:
        if(side(n->left))
            break;
        n = n->right;

    case OEQ:
    case ONE:
    case OLT:
    case OGE:
    case OGT:
    case OLE:
    case OADD:
    case OSUB:
    case OMUL:
    case OLMUL:
    case ODIV:
    case OLDIV:
    case OLSHR:
    case OASHL:
    case OASHR:
    case OAND:
    case OOR:
    case OXOR:
    case OMOD:
    case OLMOD:
    case OANDAND:
    case OOROR:
    case OCOMMA:
    case ODOT:
        if(side(n->left))
            break;
        n = n->right;
        goto loop;

    case OSIGN:
    case OSIZE:
    case OCONST:
    case OSTRING:
    case OLSTRING:
    case ONAME:
        return false;
    }
    return true;
}
@





<<function relcon>>=
/*
 * try to cast a constant down
 * rather than cast a variable up
 * example:
 *	if(c == 'a')
 */
void
relcon(Node *l, Node *r)
{
    vlong v;

    if(l->op != OCONST)
        return;
    if(r->op != OCAST)
        return;
    if(!nilcast(r->left->type, r->type))
        return;
    switch(r->type->etype) {
    default:
        return;
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
        v = convvtox(l->vconst, r->type->etype);
        if(v != l->vconst)
            return;
        break;
    }
    l->type = r->left->type;
    *r = *r->left;
}
@

<<function nilcast>>=
/*
 * a cast that has a noop semantic
 * (small to large, convert)
 */
bool
nilcast(Type *t1, Type *t2)
{
    int et1, et2;

    if(t1 == T)
        return false;
    if(t1->nbits)
        return false;
    if(t2 == T)
        return false;
    et1 = t1->etype;
    et2 = t2->etype;
    if(et1 == et2)
        return true;
    if(typefd[et1] && typefd[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return true;
        return false;
    }
    if(typechlp[et1] && typechlp[et2]) {
        if(ewidth[et1] < ewidth[et2])
            return true;
        return false;
    }
    return false;
}
@

\subsubsection{[[compar()]]}

% could be moved in Checking section?

<<struct Big>>=
/* 128-bit numbers */
struct Big
{
    vlong a;
    uvlong b;
};
@

%ctor
<<function big>>=
Big
big(vlong a, uvlong b)
{
    Big x;

    x.a = a;
    x.b = b;
    return x;
}
@


<<function cmp>>=
static int
cmp(Big x, Big y)
{
    if(x.a != y.a){
        if(x.a < y.a)
            return -1;
        return 1;
    }
    if(x.b != y.b){
        if(x.b < y.b)
            return -1;
        return 1;
    }
    return 0;
}
@

<<function add>>=
static Big
add(Big x, int y)
{
    uvlong ob;
    
    ob = x.b;
    x.b += y;
    if(y > 0 && x.b < ob)
        x.a++;
    if(y < 0 && x.b > ob)
        x.a--;
    return x;
} 
@



<<global cmps>>=
/*	OEQ, ONE, OLE, OLS, OLT, OLO, OGE, OHS, OGT, OHI */
static char *cmps[12] = 
{
    "==", "!=", "<=", "<=", "<", "<", ">=", ">=", ">", ">",
};
@

<<function compar>>=
int
compar(Node *n, int reverse)
{
    Big lo, hi, x;
    int op;
    char xbuf[40], cmpbuf[50];
    Node *l, *r;
    Type *lt, *rt;

    /*
     * The point of this function is to diagnose comparisons 
     * that can never be true or that look misleading because
     * of the `usual arithmetic conversions'.  As an example 
     * of the latter, if x is a ulong, then if(x <= -1) really means
     * if(x <= 0xFFFFFFFF), while if(x <= -1LL) really means
     * what it says (but 8c compiles it wrong anyway).
     */

    if(reverse){
        r = n->left;
        l = n->right;
        op = comrel[relindex(n->op)];
    }else{
        l = n->left;
        r = n->right;
        op = n->op;
    }

    /*
     * Skip over left casts to find out the original expression range.
     */
    while(l->op == OCAST)
        l = l->left;
    if(l->op == OCONST)
        return 0;
    lt = l->type;
    if(l->op == ONAME && l->sym->type){
        lt = l->sym->type;
        if(lt->etype == TARRAY)
            lt = lt->link;
    }
    if(lt == T)
        return 0;
    if(lt->etype == TXXX || lt->etype > TUVLONG)
        return 0;
    
    /*
     * Skip over the right casts to find the on-screen value.
     */
    if(r->op != OCONST)
        return 0;
    while(r->oldop == OCAST && !r->xcast)
        r = r->left;
    rt = r->type;
    if(rt == T)
        return 0;

    x.b = r->vconst;
    x.a = 0;
    if((rt->etype&1) && r->vconst < 0)	/* signed negative */
        x.a = ~0ULL;

    if((lt->etype&1)==0){
        /* unsigned */
        lo = big(0, 0);
        if(lt->width == 8)
            hi = big(0, ~0ULL);
        else
            hi = big(0, (1LL<<(l->type->width*8))-1);
    }else{
        lo = big(~0ULL, -(1LL<<(l->type->width*8-1)));
        hi = big(0, (1LL<<(l->type->width*8-1))-1);
    }

    switch(op){
    case OLT:
    case OLO:
    case OGE:
    case OHS:
        if(cmp(x, lo) <= 0)
            goto useless;
        if(cmp(x, add(hi, 1)) >= 0)
            goto useless;
        break;
    case OLE:
    case OLS:
    case OGT:
    case OHI:
        if(cmp(x, add(lo, -1)) <= 0)
            goto useless;
        if(cmp(x, hi) >= 0)
            goto useless;
        break;
    case OEQ:
    case ONE:
        /*
         * Don't warn about comparisons if the expression
         * is as wide as the value: the compiler-supplied casts
         * will make both outcomes possible.
         */
        if(lt->width >= rt->width && debug['w'] < 2)
            return 0;
        if(cmp(x, lo) < 0 || cmp(x, hi) > 0)
            goto useless;
        break;
    }
    return 0;

useless:
    if((x.a==0 && x.b<=9) || (x.a==~0LL && x.b >= -9ULL))
        snprint(xbuf, sizeof xbuf, "%lld", x.b);
    else if(x.a == 0)
        snprint(xbuf, sizeof xbuf, "%#llux", x.b);
    else
        snprint(xbuf, sizeof xbuf, "%#llx", x.b);
    if(reverse)
        snprint(cmpbuf, sizeof cmpbuf, "%s %s %T",
            xbuf, cmps[relindex(n->op)], lt);
    else
        snprint(cmpbuf, sizeof cmpbuf, "%T %s %s",
            lt, cmps[relindex(n->op)], xbuf);
    if(debug['y']) 
        prtree(n, "strange");
    warn(n, "useless or misleading comparison: %s", cmpbuf);
    return 0;
}
@
% >> >> >>

\subsection{Constant evaluation, [[evconst()]]}

<<[[Node]] other fields>>=
// enum<node_kind>
char	oldop;
@


% evaluate constant statically
<<function evconst>>=
void
evconst(Node *n)
{
    Node *l, *r;
    int et, isf;
    vlong v;
    double d;

    if(n == Z || n->type == T)
        return;

    et = n->type->etype;
    isf = typefd[et];

    l = n->left;
    r = n->right;

    d = 0;
    v = 0;

    switch(n->op) {
    // how knows l is a constant? no recursive call to evconst?
    case ONEG:
        if(isf)
            d = -l->fconst;
        else
            v = -l->vconst;
        break;

    case OCOM:
        v = ~l->vconst;
        break;

    case OCAST:
        if(et == TVOID)
            return;
        et = l->type->etype;
        if(isf) {
            if(typefd[et])
                d = l->fconst;
            else
                d = l->vconst;
        } else {
            if(typefd[et])
                v = l->fconst;
            else
                v = convvtox(l->vconst, n->type->etype);
        }
        break;

    case OCONST:
        break;

    // assume have done explicit cast and balancing before?
    case OADD:
        if(isf)
            d = l->fconst + r->fconst;
        else {
            v = l->vconst + r->vconst;
        }
        break;

    case OSUB:
        if(isf)
            d = l->fconst - r->fconst;
        else
            v = l->vconst - r->vconst;
        break;

    case OMUL:
        if(isf)
            d = l->fconst * r->fconst;
        else {
            v = l->vconst * r->vconst;
        }
        break;

    case OLMUL:
        v = (uvlong)l->vconst * (uvlong)r->vconst;
        break;


    case ODIV:
        if(vconst(r) == 0) {
            warn(n, "divide by zero");
            return;
        }
        if(isf)
            d = l->fconst / r->fconst;
        else
            v = l->vconst / r->vconst;
        break;

    case OLDIV:
        if(vconst(r) == 0) {
            warn(n, "divide by zero");
            return;
        }
        v = (uvlong)l->vconst / (uvlong)r->vconst;
        break;

    case OMOD:
        if(vconst(r) == 0) {
            warn(n, "modulo by zero");
            return;
        }
        v = l->vconst % r->vconst;
        break;

    case OLMOD:
        if(vconst(r) == 0) {
            warn(n, "modulo by zero");
            return;
        }
        v = (uvlong)l->vconst % (uvlong)r->vconst;
        break;

    case OAND:
        v = l->vconst & r->vconst;
        break;

    case OOR:
        v = l->vconst | r->vconst;
        break;

    case OXOR:
        v = l->vconst ^ r->vconst;
        break;

    case OLSHR:
        v = (uvlong)l->vconst >> r->vconst;
        break;

    case OASHR:
        v = l->vconst >> r->vconst;
        break;

    case OASHL:
        v = l->vconst << r->vconst;
        break;

    case OLO:
        v = (uvlong)l->vconst < (uvlong)r->vconst;
        break;

    case OLT:
        if(typefd[l->type->etype])
            v = l->fconst < r->fconst;
        else
            v = l->vconst < r->vconst;
        break;

    case OHI:
        v = (uvlong)l->vconst > (uvlong)r->vconst;
        break;

    case OGT:
        if(typefd[l->type->etype])
            v = l->fconst > r->fconst;
        else
            v = l->vconst > r->vconst;
        break;

    case OLS:
        v = (uvlong)l->vconst <= (uvlong)r->vconst;
        break;

    case OLE:
        if(typefd[l->type->etype])
            v = l->fconst <= r->fconst;
        else
            v = l->vconst <= r->vconst;
        break;

    case OHS:
        v = (uvlong)l->vconst >= (uvlong)r->vconst;
        break;

    case OGE:
        if(typefd[l->type->etype])
            v = l->fconst >= r->fconst;
        else
            v = l->vconst >= r->vconst;
        break;

    case OEQ:
        if(typefd[l->type->etype])
            v = l->fconst == r->fconst;
        else
            v = l->vconst == r->vconst;
        break;

    case ONE:
        if(typefd[l->type->etype])
            v = l->fconst != r->fconst;
        else
            v = l->vconst != r->vconst;
        break;

    case ONOT:
        if(typefd[l->type->etype])
            v = !l->fconst;
        else
            v = !l->vconst;
        break;

    case OANDAND:
        if(typefd[l->type->etype])
            v = l->fconst && r->fconst;
        else
            v = l->vconst && r->vconst;
        break;

    case OOROR:
        if(typefd[l->type->etype])
            v = l->fconst || r->fconst;
        else
            v = l->vconst || r->vconst;
        break;

    default:
        return;

    }

    if(isf) {
        n->fconst = d;
    } else {
        n->vconst = convvtox(v, n->type->etype);
    }
    n->oldop = n->op;
    n->op = OCONST;
}
@




\subsection{Comma hoisting, [[comma()]]}

<<struct Com>>=
struct Com
{
    int	n;
    Node	*t[500];
};
@

% called by complex()
<<function comma>>=
static void
comma(Node *n)
{
    Com com;
    Node *nn;

    com.n = 0;
    nn = commas(&com, n);

    if(com.n > 0){

if(debug['y'])print("n=%d\n", com.n);
if(debug['y']) prtree(nn, "res");

        if(nn != n)
            *n = *nn;
        while(com.n > 0){

if(debug['y']) prtree(com.t[com.n-1], "tree");

            nn = new1(OXXX, Z, Z);
            *nn = *n;
            n->op = OCOMMA;
            n->type = nn->type;
            n->left = com.t[--com.n];
            n->right = nn;
            n->lineno = n->left->lineno;
        }
if(debug['y']) prtree(n, "final");

    }else if(n != nn)
        fatal(n, "odd tree");
}
@


<<function commas>>=
static Node*
commas(Com *com, Node *n)
{
    Node *t;

    if(n == Z)
        return n;
    switch(n->op){
    case OREGISTER:
    case OINDREG:
    case OCONST:
    case ONAME:
    case OSTRING:
        /* leaf */
        return n;

    case OCOMMA:
        t = commas(com, n->left);
        if(com->n >= nelem(com->t))
            fatal(n, "comma list overflow");
        com->t[com->n++] = t;
        return commas(com, n->right);

    case OFUNC:
        n->left = commas(com, n->left);
        n->right = comargs(com, n->right);
        return n;

    case OCOND:
        n->left = commas(com, n->left);
        comma(n->right->left);
        comma(n->right->right);
        return n;

    case OANDAND:
    case OOROR:
        n->left = commas(com, n->left);
        comma(n->right);
        return n;

    case ORETURN:
        comma(n->left);
        return n;
    }
    n->left = commas(com, n->left);
    if(n->right != Z)
        n->right = commas(com, n->right);
    return n;
}
@


<<function comargs>>=
/*
 * hoist comma operators out of expressions
 *	(a,b) OP c => (a, b OP c)
 *	OP(a,b) =>	(a, OP b)
 *	a OP (b,c) => (b, a OP c)
 */

static Node*
comargs(Com *com, Node *n)
{
    if(n != Z && n->op == OLIST){
        n->left = comargs(com, n->left);
        n->right = comargs(com, n->right);
    }
    return commas(com, n);
}
@




\section{Arithmetic}
% see also 8c -m, print add/mul/sub trees


% "acom is Aho and Ullman's acommute (with all the exercises done).
% basically it does code improvements taking advantage of
% associative-commutative operations, and extends that to look for
% further optimisations mentioned in Thompson's paper on the compiler.
% Ritchie's PDP-11 C compiler did something similar (but he called it
% acommute and distrib). comments such as "bust terms out" and "look
% for factorable terms c1*i + c1*c2*j -> c1*(i + c2*j) suggest what
% it's doing). essentially it flattens levels of an expression tree
% using associative and commutative operators into an array and
% rearranges them." - fortsith

\subsection{[[Term]]}

<<constant NTERM>>=
#define	NTERM		10
@

<<struct Term>>=
struct	Term
{
    vlong	mult;
    Node	*node;
};
@

<<global term>>=
Term	term[NTERM];
@

<<global nterm>>=
int	nterm;
@


\subsection{[[acom()]]}
% cc/scon.c ??

<<function acom>>=
void
acom(Node *n)
{
    Type *t;
    Node *l, *r;
    int i;

    switch(n->op)
    {

    case ONAME:
    case OCONST:
    case OSTRING:
    case OINDREG:
    case OREGISTER:
        return;

    case ONEG:
        l = n->left;
        if(addo(n) && addo(l))
            break;
        acom(l);
        return;

    case OADD:
    case OSUB:
    case OMUL:
        l = n->left;
        r = n->right;
        if(addo(n)) {
            if(addo(r))
                break;
            if(addo(l))
                break;
        }
        acom(l);
        acom(r);
        return;

    default:
        l = n->left;
        r = n->right;
        if(l != Z)
            acom(l);
        if(r != Z)
            acom(r);
        return;
    }

    /* bust terms out */
    t = n->type;
    term[0].mult = 0;
    term[0].node = Z;
    nterm = 1;
    acom1(1, n);

    if(debug['m'])
     for(i=0; i<nterm; i++) {
        print("%d %3lld ", i, term[i].mult);
        prtree1(term[i].node, 1, 0);
    }

    if(nterm < NTERM)
        acom2(n, t);
    n->type = t;
}
@
% hmm 'm' already used for macro debugging => use M instead? or n?

<<function addo>>=
int
addo(Node *n)
{

    if(n != Z)
    if(!typefd[n->type->etype])
    if(!typev[n->type->etype] || ewidth[TVLONG] == ewidth[TIND])
    switch(n->op) {

    case OCAST:
        if(nilcast(n->left->type, n->type))
            return 1;
        break;

    case ONEG:
    case OADD:
    case OSUB:
        return 1;

    case OMUL:
        if(n->left->op == OCONST)
            return 1;
        if(n->right->op == OCONST)
            return 1;
    }
    return 0;
}
@


<<function acom1>>=
void
acom1(vlong v, Node *n)
{
    Node *l, *r;

    if(v == 0 || nterm >= NTERM)
        return;
    if(!addo(n)) {
        if(n->op == OCONST)
        if(!typefd[n->type->etype]) {
            term[0].mult += v*n->vconst;
            return;
        }
        term[nterm].mult = v;
        term[nterm].node = n;
        nterm++;
        return;
    }
    switch(n->op) {

    case OCAST:
        acom1(v, n->left);
        break;

    case ONEG:
        acom1(-v, n->left);
        break;

    case OADD:
        acom1(v, n->left);
        acom1(v, n->right);
        break;

    case OSUB:
        acom1(v, n->left);
        acom1(-v, n->right);
        break;

    case OMUL:
        l = n->left;
        r = n->right;
        if(l->op == OCONST)
        if(!typefd[n->type->etype]) {
            acom1(v*l->vconst, r);
            break;
        }
        if(r->op == OCONST)
        if(!typefd[n->type->etype]) {
            acom1(v*r->vconst, l);
            break;
        }
        break;

    default:
        diag(n, "not addo");
    }
}
@



<<function acast>>=
static Node*
acast(Type *t, Node *n)
{
    if(n->type->etype != t->etype || n->op == OBIT) {
        n = new1(OCAST, n, Z);
        if(nocast(n->left->type, t))
            *n = *n->left;
        n->type = t;
    }
    return n;
}
@



<<function acomcmp1>>=
int
acomcmp1(const void *a1, const void *a2)
{
    vlong c1, c2;
    Term *t1, *t2;

    t1 = (Term*)a1;
    t2 = (Term*)a2;
    c1 = t1->mult;
    if(c1 < 0)
        c1 = -c1;
    c2 = t2->mult;
    if(c2 < 0)
        c2 = -c2;
    if(c1 > c2)
        return 1;
    if(c1 < c2)
        return -1;
    c1 = 1;
    if(t1->mult < 0)
        c1 = 0;
    c2 = 1;
    if(t2->mult < 0)
        c2 = 0;
    if(c2 -= c1)
        return c2;
    if(t2 > t1)
        return 1;
    return -1;
}
@

<<function acomcmp2>>=
int
acomcmp2(const void *a1, const void *a2)
{
    vlong c1, c2;
    Term *t1, *t2;

    t1 = (Term*)a1;
    t2 = (Term*)a2;
    c1 = t1->mult;
    c2 = t2->mult;
    if(c1 > c2)
        return 1;
    if(c1 < c2)
        return -1;
    if(t2 > t1)
        return 1;
    return -1;
}
@

<<function acom2>>=
void
acom2(Node *n, Type *t)
{
    Node *l, *r;
    Term trm[NTERM];
    int et, nt, i, j;
    vlong c1, c2;

    /*
     * copy into automatic
     */
    c2 = 0;
    nt = nterm;
    for(i=0; i<nt; i++)
        trm[i] = term[i];
    /*
     * recur on subtrees
     */
    j = 0;
    for(i=1; i<nt; i++) {
        c1 = trm[i].mult;
        if(c1 == 0)
            continue;
        l = trm[i].node;
        if(l != Z) {
            j = 1;
            acom(l);
        }
    }
    c1 = trm[0].mult;
    if(j == 0) {
        n->oldop = n->op;
        n->op = OCONST;
        n->vconst = c1;
        return;
    }
    et = t->etype;

    /*
     * prepare constant term,
     * combine it with an addressing term
     */
    if(c1 != 0) {
        l = new1(OCONST, Z, Z);
        l->type = t;
        l->vconst = c1;
        trm[0].mult = 1;
        for(i=1; i<nt; i++) {
            if(trm[i].mult != 1)
                continue;
            r = trm[i].node;
            if(r->op != OADDR)
                continue;
            r->type = t;
            l = new1(OADD, r, l);
            l->type = t;
            trm[i].mult = 0;
            break;
        }
        trm[0].node = l;
    }
    /*
     * look for factorable terms
     * c1*i + c1*c2*j -> c1*(i + c2*j)
     */
    qsort(trm+1, nt-1, sizeof(trm[0]), acomcmp1);
    for(i=nt-1; i>=0; i--) {
        c1 = trm[i].mult;
        if(c1 < 0)
            c1 = -c1;
        if(c1 <= 1)
            continue;
        for(j=i+1; j<nt; j++) {
            c2 = trm[j].mult;
            if(c2 < 0)
                c2 = -c2;
            if(c2 <= 1)
                continue;
            if(c2 % c1)
                continue;
            r = trm[j].node;
            if(r->type->etype != et)
                r = acast(t, r);
            c2 = trm[j].mult/trm[i].mult;
            if(c2 != 1 && c2 != -1) {
                r = new1(OMUL, r, new(OCONST, Z, Z));
                r->type = t;
                r->right->type = t;
                r->right->vconst = c2;
            }
            l = trm[i].node;
            if(l->type->etype != et)
                l = acast(t, l);
            r = new1(OADD, l, r);
            r->type = t;
            if(c2 == -1)
                r->op = OSUB;
            trm[i].node = r;
            trm[j].mult = 0;
        }
    }
    if(debug['m']) {
        print("\n");
        for(i=0; i<nt; i++) {
            print("%d %3lld ", i, trm[i].mult);
            prtree1(trm[i].node, 1, 0);
        }
    }

    /*
     * put it all back together
     */
    qsort(trm+1, nt-1, sizeof(trm[0]), acomcmp2);
    l = Z;
    for(i=nt-1; i>=0; i--) {
        c1 = trm[i].mult;
        if(c1 == 0)
            continue;
        r = trm[i].node;
        if(r->type->etype != et || r->op == OBIT)
            r = acast(t, r);
        if(c1 != 1 && c1 != -1) {
            r = new1(OMUL, r, new(OCONST, Z, Z));
            r->type = t;
            r->right->type = t;
            if(c1 < 0) {
                r->right->vconst = -c1;
                c1 = -1;
            } else {
                r->right->vconst = c1;
                c1 = 1;
            }
        }
        if(l == Z) {
            l = r;
            c2 = c1;
            continue;
        }
        if(c1 < 0)
            if(c2 < 0)
                l = new1(OADD, l, r);
            else
                l = new1(OSUB, l, r);
        else
            if(c2 < 0) {
                l = new1(OSUB, r, l);
                c2 = 1;
            } else
                l = new1(OADD, l, r);
        l->type = t;
    }
    if(c2 < 0) {
        r = new1(OCONST, 0, 0);
        r->vconst = 0;
        r->type = t;
        l = new1(OSUB, r, l);
        l->type = t;
    }
    *n = *l;
}
@





\section{[[xcom()]]}

% 8c/sgen.c

% "xcom, which is machine-dependent, also has a comment. it assigns an
% index of complexity to a sub-expression, which is usually expressed
% as the number of registers needed to compute it (and good luck with
% that on an x86), but it's also a good place to look for
% machine-dependent aspects of machine addressing, such as indexing,
% double-indexing, scaling, etc and it sets values in each tree node
% to mark that." - forsith


<<function xcom>>=
/*
 *	calculate addressability as follows
 *		NAME ==> 10/11		name+value(SB/SP)
 *		REGISTER ==> 12		register
 *		CONST ==> 20		$value
 *		*(20) ==> 21		value
 *		&(10) ==> 13		$name+value(SB)
 *		&(11) ==> 1		$name+value(SP) $
 *		(13) + (20) ==> 13	fold constants
 *		(1) + (20) ==> 1	fold constants
 *		*(13) ==> 10		back to name
 *		*(1) ==> 11		back to name
 *
 *		(20) * (X) ==> 7	multiplier in indexing
 *		(X,7) + (13,1) ==> 8	adder in indexing (addresses)
 *		(8) ==> &9(OINDEX)	index, almost addressable
 *
 *	calculate complexity (number of registers)
 * 
 */
void
xcom(Node *n)
{
    Node *l, *r;
    int g;

    if(n == Z)
        return;
    l = n->left;
    r = n->right;
    n->complex = 0;
    n->addable = 0;
    switch(n->op) {
    case OCONST:
        n->addable = 20;
        break;

    case ONAME:
        n->addable = 10;
        if(n->class == CPARAM || n->class == CAUTO)
            n->addable = 11;
        break;

    case OEXREG:
        n->addable = 12;
        break;

    case OREGISTER:
        n->addable = 12;
        break;

    case OINDREG:
        n->addable = 12;
        break;

    case OADDR:
        xcom(l);
        if(l->addable == 10)
            n->addable = 13;
        else
        if(l->addable == 11)
            n->addable = 1;
        break;

    case OADD:
        xcom(l);
        xcom(r);
        if(n->type->etype != TIND)
            break;

        switch(r->addable) {
        case 20:
            switch(l->addable) {
            case 1:
            case 13:
            commadd:
                l->type = n->type;
                *n = *l;
                l = new(0, Z, Z);
                *l = *(n->left);
                l->xoffset += r->vconst;
                n->left = l;
                r = n->right;
                goto brk;
            }
            break;

        case 1:
        case 13:
        case 10:
        case 11:
            /* l is the base, r is the index */
            if(l->addable != 20)
                n->addable = 8;
            break;
        }
        switch(l->addable) {
        case 20:
            switch(r->addable) {
            case 13:
            case 1:
                r = n->left;
                l = n->right;
                n->left = l;
                n->right = r;
                goto commadd;
            }
            break;

        case 13:
        case 1:
        case 10:
        case 11:
            /* r is the base, l is the index */
            if(r->addable != 20)
                n->addable = 8;
            break;
        }
        if(n->addable == 8 && !side(n)) {
            indx(n);
            l = new1(OINDEX, idx.basetree, idx.regtree);
            l->scale = idx.scale;
            l->addable = 9;
            l->complex = l->right->complex;
            l->type = l->left->type;
            n->op = OADDR;
            n->left = l;
            n->right = Z;
            n->addable = 8;
            break;
        }
        break;

    case OINDEX:
        xcom(l);
        xcom(r);
        n->addable = 9;
        break;

    case OIND:
        xcom(l);
        if(l->op == OADDR) {
            l = l->left;
            l->type = n->type;
            *n = *l;
            return;
        }
        switch(l->addable) {
        case 20:
            n->addable = 21;
            break;
        case 1:
            n->addable = 11;
            break;
        case 13:
            n->addable = 10;
            break;
        }
        break;

    case OASHL:
        xcom(l);
        xcom(r);
        indexshift(n);
        break;

    case OMUL:
    case OLMUL:
        xcom(l);
        xcom(r);
        g = vlog(l);
        if(g >= 0) {
            n->left = r;
            n->right = l;
            l = r;
            r = n->right;
        }
        g = vlog(r);
        if(g >= 0) {
            n->op = OASHL;
            r->vconst = g;
            r->type = types[TINT];
            indexshift(n);
            break;
        }
commute(n);
        break;

    case OASLDIV:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASLSHR;
            r->vconst = g;
            r->type = types[TINT];
        }
        break;

    case OLDIV:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OLSHR;
            r->vconst = g;
            r->type = types[TINT];
            indexshift(n);
            break;
        }
        break;

    case OASLMOD:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASAND;
            r->vconst--;
        }
        break;

    case OLMOD:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OAND;
            r->vconst--;
        }
        break;

    case OASMUL:
    case OASLMUL:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASASHL;
            r->vconst = g;
        }
        break;

    case OLSHR:
    case OASHR:
        xcom(l);
        xcom(r);
        indexshift(n);
        break;

    default:
        if(l != Z)
            xcom(l);
        if(r != Z)
            xcom(r);
        break;
    }
brk:
    if(n->addable >= 10)
        return;
    if(l != Z)
        n->complex = l->complex;
    if(r != Z) {
        if(r->complex == n->complex)
            n->complex = r->complex+1;
        else
        if(r->complex > n->complex)
            n->complex = r->complex;
    }
    if(n->complex == 0)
        n->complex++;

    if(com64(n))
        return;

    switch(n->op) {

    case OFUNC:
        n->complex = FNX;
        break;

    case OLMOD:
    case OMOD:
    case OLMUL:
    case OLDIV:
    case OMUL:
    case ODIV:
    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASMUL:
    case OASDIV:
    case OASMOD:
        if(r->complex >= l->complex) {
            n->complex = l->complex + 3;
            if(r->complex > n->complex)
                n->complex = r->complex;
        } else {
            n->complex = r->complex + 3;
            if(l->complex > n->complex)
                n->complex = l->complex;
        }
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
    case OASLSHR:
    case OASASHL:
    case OASASHR:
        if(r->complex >= l->complex) {
            n->complex = l->complex + 2;
            if(r->complex > n->complex)
                n->complex = r->complex;
        } else {
            n->complex = r->complex + 2;
            if(l->complex > n->complex)
                n->complex = l->complex;
        }
        break;

    case OADD:
    case OXOR:
    case OAND:
    case OOR:
        /*
         * immediate operators, make const on right
         */
        if(l->op == OCONST) {
            n->left = r;
            n->right = l;
        }
        break;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        /*
         * compare operators, make const on left
         */
        if(r->op == OCONST) {
            n->left = r;
            n->right = l;
            n->op = invrel[relindex(n->op)];
        }
        break;
    }
}
@
%$



<<function vlog>>=
int
vlog(Node *n)
{
    if(n->op != OCONST)
        goto bad;
    if(typefd[n->type->etype])
        goto bad;

    return log2(n->vconst);

bad:
    return -1;
}
@



\chapter{Assembly-level Optimisations}

\section{Peep optimizer}

\section{Register allocation}
% 8c -r? registerization

\subsection{[[Bits]]}

<<constant BITS>>=
#define	BITS	5
@


<<struct Bits>>=
struct	Bits
{
    ulong	b[BITS];
};
@

<<global zbits>>=
Bits	zbits;
@


<<function bor>>=
Bits
bor(Bits a, Bits b)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = a.b[i] | b.b[i];
    return c;
}
@

<<function bany>>=
/*
Bits
bnot(Bits a)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = ~a.b[i];
    return c;
}
*/

int
bany(Bits *a)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a->b[i])
            return 1;
    return 0;
}
@

<<function beq>>=
int
beq(Bits a, Bits b)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a.b[i] != b.b[i])
            return 0;
    return 1;
}
@

<<function bnum>>=
int
bnum(Bits a)
{
    int i;
    long b;

    for(i=0; i<BITS; i++)
        if(b = a.b[i])
            return 32*i + bitno(b);
    diag(Z, "bad in bnum");
    return 0;
}
@

<<function blsh>>=
Bits
blsh(uint n)
{
    Bits c;

    c = zbits;
    c.b[n/32] = 1L << (n%32);
    return c;
}
@

<<function bset>>=
//@Scheck: also defined as a macro in gc.h, TODO fix that!
int bset(Bits a, uint n)
{
    if(a.b[n/32] & (1L << (n%32)))
        return 1;
    return 0;
}
@


%<<function band>>=
%//Bits
%//band(Bits a, Bits b)
%//{
%//    Bits c;
%//    int i;
%//
%//    for(i=0; i<BITS; i++)
%//        c.b[i] = a.b[i] & b.b[i];
%//    return c;
%//}
%@

\subsection{[[Var]]}

<<constant NVAR>>=
#define	NVAR	(BITS*sizeof(ulong)*8)
@

<<global nvar>>=
int	nvar;
@

<<global var>>=
Var	var[NVAR];
@

<<struct Var>>=
struct	Var
{
    long	offset;
    Sym*	sym;
    char	name;
    char	etype;
};
@

\subsection{[[Reg]]}


<<struct Reg>>=
struct	Reg
{
    long	pc;
    long	rpo;		/* reverse post ordering */

    Bits	set;
    Bits	use1;
    Bits	use2;

    Bits	refbehind;
    Bits	refahead;
    Bits	calbehind;
    Bits	calahead;
    Bits	regdiff;
    Bits	act;

    long	regu;
    long	loop;		/* could be shorter */

    Reg*	log5;
    long	active;

    Reg*	p1;
    Reg*	p2;
    Reg*	p2link;
    Reg*	s1;
    Reg*	s2;
    Reg*	link;
    Prog*	prog;
};
@

<<constant R>>=
#define	R	((Reg*)nil)
@



\section{Dominators}


\chapter{Linking Support}

\section{[[#pragma lib]] and automagic linking}

\section{Safe linking with type signatures}


% md5sum like in ocaml!

% signature! for safe linking
<<enum sigxxx>>=
enum{
    SIGNONE = 0,
    SIGDONE = 1,
    SIGINTERN = 2,

    // ???
    SIGNINTERN = 1729*325*1729,
};
@

<<[[Sym]] other fields>>=
// enum<sigxxx>
char	sig;
@
% SIGNINTERN does not fit in a char ...


<<global thash1>>=
ulong	thash1	= 0x2edab8c9;
@

<<global thash2>>=
ulong	thash2	= 0x1dc74fb8;
@

<<global thash3>>=
ulong	thash3	= 0x1f241331;
@

<<global thash>>=
ulong	thash[NALLTYPES];
@

<<global thashinit>>=
Init	thashinit[] =
{
    TXXX,		0x17527bbd,	0,

    TCHAR,		0x5cedd32b,	0,
    TUCHAR,		0x552c4454,	0,
    TSHORT,		0x63040b4b,	0,
    TUSHORT,		0x32a45878,	0,
    TINT,		0x4151d5bd,	0,
    TUINT,		0x5ae707d6,	0,
    TLONG,		0x5ef20f47,	0,
    TULONG,		0x36d8eb8f,	0,
    TVLONG,		0x6e5e9590,	0,
    TUVLONG,		0x75910105,	0,
    TFLOAT,		0x25fd7af1,	0,
    TDOUBLE,		0x7c40a1b2,	0,

    TIND,		0x1b832357,	0,
    TFUNC,		0x6babc9cb,	0,
    TARRAY,		0x7c50986d,	0,
    TVOID,		0x44112eff,	0,
    TSTRUCT,		0x7c2da3bf,	0,
    TUNION,		0x3eb25e98,	0,
    TENUM,		0x44b54f61,	0,

    TFILE,		0x19242ac3,	0,
    TOLD,		0x22b15988,	0,
    TDOT,		0x0204f6b3,	0,

    -1,		0,		0,
};
@


<<struct Typetab>>=
struct Typetab {
    int n;
    Type **a;
};
@

<<function sigind>>=
static int
sigind(Type *t, Typetab *tt)
{
    int n;
    Type **a, **na, **p, **e;

    n = tt->n;
    a = tt->a;
    e = a+n;
    /* linear search seems ok */
    for(p = a ; p < e; p++)
        if(sametype(*p, t))
            return p-a;
    if((n&15) == 0){
        na = malloc((n+16)*sizeof(Type*));
        memmove(na, a, n*sizeof(Type*));
        free(a);
        a = tt->a = na;
    }
    a[tt->n++] = t;
    return -1;
}
@

<<function signat>>=
static ulong
signat(Type *t, Typetab *tt)
{
    int i;
    Type *t1;
    long s;

    s = 0;
    for(; t; t=t->link) {
        s = s*thash1 + thash[t->etype];
        if(t->garb&GINCOMPLETE)
            return s;
        switch(t->etype) {
        default:
            return s;
        case TARRAY:
            s = s*thash2 + 0;	/* was t->width */
            break;
        case TFUNC:
            for(t1=t->down; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            break;
        case TSTRUCT:
        case TUNION:
            if((i = sigind(t, tt)) >= 0){
                s = s*thash2 + i;
                return s;
            }
            for(t1=t->link; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            return s;
        case TIND:
            break;
        }
    }
    return s;
}
@

<<function signature>>=
ulong
signature(Type *t)
{
    ulong s;
    Typetab tt;

    tt.n = 0;
    tt.a = nil;
    s = signat(t, &tt);
    free(tt.a);
    return s;
}
@

<<function sign>>=
ulong
sign(Sym *s)
{
    ulong v;
    Type *t;

    if(s->sig == SIGINTERN)
        return SIGNINTERN;
    if((t = s->type) == T)
        return 0;
    v = signature(t);
    if(v == 0)
        v = SIGNINTERN;
    return v;
}
@


\chapter{Debugging Support}

\section{Acid, [[8c -a]]}

% 8c -a to print acid declarations
%  -n print acid to file
%  -s print structure offsets


\subsection{Entities}

% called e.g. for enum constants in doenum() and dodecl()
% exported in cc.h
<<function acidvar>>=
void
acidvar(Sym *s)
{
    int n;
    Io *i;
    Type *t;
    Sym *s1, *s2;

    if(!debug['a'] || debug['s'])
        return;
    if(debug['a'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    t = s->type;
    while(t && t->etype == TIND)
        t = t->link;
    if(t == T)
        return;
    if(t->etype == TENUM) {
        Bprint(&outbuf, "%s = ", amap(s->name));
        if(!typefd[t->etype])
            Bprint(&outbuf, "%lld;\n", s->vconst);
        else
            Bprint(&outbuf, "%f\n;", s->fconst);
        return;
    }
    if(!typesu[t->etype])
        return;
    s1 = acidsue(t->link);
    if(s1 == S)
        return;
    switch(s->class) {
    case CAUTO:
    case CPARAM:
        s2 = acidfun(thisfn);
        if(s2)
            Bprint(&outbuf, "complex %s %s:%s;\n",
                amap(s1->name), amap(s2->name), amap(s->name));
        break;
    
    case CSTATIC:
    case CEXTERN:
    case CGLOBL:
    case CLOCAL:
        Bprint(&outbuf, "complex %s %s;\n",
            amap(s1->name), amap(s->name));
        break;
    }
}
@


<<function acidsue>>=
Sym*
acidsue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<function acidfun>>=
Sym*
acidfun(Type *t)
{
    int h;
    Sym *s;

    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->type == t)
                return s;
    return 0;
}
@



<<global kwd>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$builtin", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
% compared to Pickle.kwd ? $builtin en plus?

<<function amap>>=
char*
amap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@









\subsection{Structure/union definitions}

% called from sualign, so for struct and union
% exported in cc.h
<<function acidtype>>=
void
acidtype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['a'])
        return;
    if(debug['a'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = acidsue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = amap(s->name);
        Bprint(&outbuf, "sizeof%s = %ld;\n", an, t->width);
        Bprint(&outbuf, "aggr %s\n{\n", an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 1);
        Bprint(&outbuf, "};\n\n");

        Bprint(&outbuf, "defn\n%s(addr) {\n\tcomplex %s addr;\n", an, an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 0);
        Bprint(&outbuf, "};\n\n");
        break;
    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;
    }
}
@

<<global acidchar>>=
char	acidchar[NTYPE];
@

<<global acidcinit>>=
Init	acidcinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,	'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,	'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function acidinit>>=
static void
acidinit(void)
{
    Init *p;

    for(p=acidcinit; p->code >= 0; p++)
        acidchar[p->code] = p->value;

    acidchar[TINT] = acidchar[TLONG];
    acidchar[TUINT] = acidchar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        acidchar[TINT] = acidchar[TSHORT];
        acidchar[TUINT] = acidchar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "acidmember int not long or short");
    }
    if(types[TIND]->width == types[TUVLONG]->width)
        acidchar[TIND] = 'Y';
    
}
@

<<function acidmember>>=
void
acidmember(Type *t, long off, int flag)
{
    Sym *s, *s1;
    Type *l;
    static bool acidcharinit = false;

    if(acidcharinit == false) {
        acidinit();
        acidcharinit = true;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            break;
        if(flag) {
            for(l=t; l->etype==TIND; l=l->link)
                ;
            if(typesu[l->etype]) {
                s1 = acidsue(l->link);
                if(s1 != S) {
                    Bprint(&outbuf, "	'A' %s %ld %s;\n",
                        amap(s1->name),
                        t->offset+off, amap(s->name));
                    break;
                }
            }
        } else {
            Bprint(&outbuf,
                "\tprint(\"\t%s\t\", addr.%s\\X, \"\\n\");\n",
                amap(s->name), amap(s->name));
            break;
        }

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
    case TARRAY:
        if(s == S)
            break;
        if(flag) {
            Bprint(&outbuf, "	'%c' %ld %s;\n",
            acidchar[t->etype], t->offset+off, amap(s->name));
        } else {
            Bprint(&outbuf, "\tprint(\"\t%s\t\", addr.%s, \"\\n\");\n",
                amap(s->name), amap(s->name));
        }
        break;

    case TSTRUCT:
    case TUNION:
        s1 = acidsue(t->link);
        if(s1 == S)
            break;
        if(flag) {
            if(s == S) {
                Bprint(&outbuf, "	{\n");
                for(l = t->link; l != T; l = l->down)
                    acidmember(l, t->offset+off, flag);
                Bprint(&outbuf, "	};\n");
            } else {
                Bprint(&outbuf, "	%s %ld %s;\n",
                    amap(s1->name),
                    t->offset+off, amap(s->name));
            }
        } else {
            if(s != S) {
                Bprint(&outbuf, "\tprint(\"%s %s {\\n\");\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\t%s(addr.%s);\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            } else {
                Bprint(&outbuf, "\tprint(\"%s {\\n\");\n",
                    amap(s1->name));
                Bprint(&outbuf, "\t\t%s(addr+%ld);\n",
                    amap(s1->name), t->offset+off);
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            }
        }
        break;
    }
}
@




\section{Pickle, [[8c -Z]]}

% 8c -Z  and -n create _picke.c


<<global kwd (cc/pickle.c)>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
%$

<<global picklestr>>=
static char picklestr[] = "\tpickle(s, un, ";
@

<<function pmap>>=
static char*
pmap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@

<<function picklesue>>=
Sym*
picklesue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<global picklechar>>=
char	picklechar[NTYPE];
@

<<global picklecinit>>=
Init	picklecinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,		'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,		'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function pickleinit>>=
static void
pickleinit(void)
{
    Init *p;

    for(p=picklecinit; p->code >= 0; p++)
        picklechar[p->code] = p->value;

    picklechar[TINT] = picklechar[TLONG];
    picklechar[TUINT] = picklechar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        picklechar[TINT] = picklechar[TSHORT];
        picklechar[TUINT] = picklechar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "picklemember int not long or short");
    }
    
}
@

<<function picklemember>>=
void
picklemember(Type *t, long off)
{
    Sym *s, *s1;
    static int picklecharinit = 0;

    if(picklecharinit == 0) {
        pickleinit();
        picklecharinit = 1;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            Bprint(&outbuf,
                "%s\"p\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, t->offset+off, t->width);
        else
            Bprint(&outbuf,
                "%s\"p\", &addr->%s);\n",
                picklestr, pmap(s->name));
        break;

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
        if(s == S)
            Bprint(&outbuf, "%s\"%c\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, picklechar[t->etype], t->offset+off, t->width);
        else
            Bprint(&outbuf, "%s\"%c\", &addr->%s);\n",
                picklestr, picklechar[t->etype], pmap(s->name));
        break;
    case TARRAY:
        Bprint(&outbuf, "\tfor(_i = 0; _i < %ld; _i++) {\n\t",
            t->width/t->link->width);
        picklemember(t->link, t->offset+off);
        Bprint(&outbuf, "\t}\n\t_i = 0;\n\tUSED(_i);\n");
        break;

    case TSTRUCT:
    case TUNION:
        s1 = picklesue(t->link);
        if(s1 == S)
            break;
        if(s == S) {
            Bprint(&outbuf, "\tpickle_%s(s, un, (%s*)((char*)addr+%ld+_i*%ld));\n",
                pmap(s1->name), pmap(s1->name), t->offset+off, t->width);
        } else {
            Bprint(&outbuf, "\tpickle_%s(s, un, &addr->%s);\n",
                pmap(s1->name), pmap(s->name));
        }
        break;
    }
}
@

<<function pickletype>>=
void
pickletype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['P'])
        return;
    if(debug['P'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = picklesue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = pmap(s->name);

        Bprint(&outbuf, "void\npickle_%s(void *s, int un, %s *addr)\n{\n\tint _i = 0;\n\n\tUSED(_i);\n", an, an);
        for(l = t->link; l != T; l = l->down)
            picklemember(l, 0);
        Bprint(&outbuf, "}\n\n");
        break;
    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;
    }
}
@

%<<function picklefun>>=
%//Sym*
%//picklefun(Type *t)
%//{
%//    int h;
%//    Sym *s;
%//
%//    for(h=0; h<nelem(hash); h++)
%//        for(s = hash[h]; s != S; s = s->link)
%//            if(s->type == t)
%//                return s;
%//    return 0;
%//}
%@
%
%<<function picklevar>>=
%//void
%//picklevar(Sym *s)
%//{
%//    int n;
%//    Io *i;
%//    Type *t;
%//    Sym *s1, *s2;
%//
%//    if(!debug['P'] || debug['s'])
%//        return;
%//    if(debug['P'] > 1) {
%//        n = 0;
%//        for(i=iostack; i; i=i->link)
%//            n++;
%//        if(n > 1)
%//            return;
%//    }
%//    t = s->type;
%//    while(t && t->etype == TIND)
%//        t = t->link;
%//    if(t == T)
%//        return;
%//    if(t->etype == TENUM) {
%//        Bprint(&outbuf, "%s = ", pmap(s->name));
%//        if(!typefd[t->etype])
%//            Bprint(&outbuf, "%lld;\n", s->vconst);
%//        else
%//            Bprint(&outbuf, "%f\n;", s->fconst);
%//        return;
%//    }
%//    if(!typesu[t->etype])
%//        return;
%//    s1 = picklesue(t->link);
%//    if(s1 == S)
%//        return;
%//    switch(s->class) {
%//    case CAUTO:
%//    case CPARAM:
%//        s2 = picklefun(thisfn);
%//        if(s2)
%//            Bprint(&outbuf, "complex %s %s:%s;\n",
%//                pmap(s1->name), pmap(s2->name), pmap(s->name));
%//        break;
%//    
%//    case CSTATIC:
%//    case CEXTERN:
%//    case CGLOBL:
%//    case CLOCAL:
%//        Bprint(&outbuf, "complex %s %s;\n",
%//            pmap(s1->name), pmap(s->name));
%//        break;
%//    }
%//}
%@


\chapter{Profiling Support}

% actually always true, only way to disable it is via pragma locally
<<global profileflg>>=
bool	profileflg;
@

\chapter{Advanced Topics}

\section{C extensions}


\section{[[typestr]]}
% ???

<<function dclfunct>>=
void
dclfunct(Type *t, Sym *s)
{
    Funct *f;
    Node *n;
    Type *f1, *f2, *f3, *f4;
    int o, i, c;
    char str[100];

    if(t->funct)
        return;

    // recognize generated tag of dorm _%d_
    if(t->tag == S)
        goto bad;
    for(i=0; c = t->tag->name[i]; i++) {
        if(c == '_') {
            if(i == 0 || t->tag->name[i+1] == 0)
                continue;
            break;
        }
        if(c < '0' || c > '9')
            break;
    }
    if(c == 0)
        goto bad;

    f = alloc(sizeof(*f));
    for(o=0; o<sizeof(f->sym); o++)
        f->sym[o] = S;

    t->funct = f;

    f1 = typ(TFUNC, t);
    f1->down = copytyp(t);
    f1->down->down = t;

    f2 = typ(TFUNC, types[TINT]);
    f2->down = copytyp(t);
    f2->down->down = t;

    f3 = typ(TFUNC, t);
    f3->down = typ(TIND, t);
    f3->down->down = t;

    f4 = typ(TFUNC, t);
    f4->down = t;

    for(i=0;; i++) {
        o = ftabinit[i].op;
        if(o == OXXX)
            break;
        sprint(str, "%s_%s_", t->tag->name, ftabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->sym[o] = n->sym;
        switch(ftabinit[i].typ) {
        default:
            diag(Z, "dclfunct op missing %d\n", ftabinit[i].typ);
            break;

        case 1:	// T f(T,T)	+
            dodecl(xdecl, CEXTERN, f1, n);
            break;

        case 2:	// int f(T,T)	==
            dodecl(xdecl, CEXTERN, f2, n);
            break;

        case 3:	// void f(T*,T)	+=
            dodecl(xdecl, CEXTERN, f3, n);
            break;

        case 4:	// T f(T)	~
            dodecl(xdecl, CEXTERN, f4, n);
            break;
        }
    }
    for(i=0;; i++) {
        o = gtabinit[i].etype;
        if(o == TXXX)
            break;

        /*
         * OCAST types T1 _T2_T1_(T2)
         */
        sprint(str, "_%s%s_", gtabinit[i].name, t->tag->name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castto[o] = n->sym;

        f1 = typ(TFUNC, t);
        f1->down = types[o];
        dodecl(xdecl, CEXTERN, f1, n);

        sprint(str, "%s_%s_", t->tag->name, gtabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castfr[o] = n->sym;

        f1 = typ(TFUNC, types[o]);
        f1->down = t;
        dodecl(xdecl, CEXTERN, f1, n);
    }
    return;
bad:
    diag(Z, "dclfunct bad %T %s\n", t, s->name);
}
@


% why not use Init?
<<struct Ftab>>=
struct	Ftab
{
    char	op;
    char*	name;
    char	typ;
};
@

% why not use Init?
<<struct Gtab>>=
struct	Gtab
{
    char	etype;
    char*	name;
};
@

<<global gtabinit>>=
Gtab	gtabinit[NTYPE] =
{
    TCHAR,		"c",
    TUCHAR,		"uc",
    TSHORT,		"h",
    TUSHORT,		"uh",
    TINT,		"i",
    TUINT,		"ui",
    TLONG,		"l",
    TULONG,		"ul",
    TVLONG,		"v",
    TUVLONG,		"uv",
    TFLOAT,		"f",
    TDOUBLE,		"d",

    TXXX
};
@

<<global ftabinit>>=
Ftab	ftabinit[OEND] =
{
    OADD,		"add",		1,
    OAND,		"and",		1,
    OASHL,		"ashl",		1,
    OASHR,		"ashr",		1,
    ODIV,		"div",		1,
    OLDIV,		"ldiv",		1,
    OLMOD,		"lmod",		1,
    OLMUL,		"lmul",		1,
    OLSHR,		"lshr",		1,
    OMOD,		"mod",		1,
    OMUL,		"mul",		1,
    OOR,		"or",		1,
    OSUB,		"sub",		1,
    OXOR,		"xor",		1,

    OEQ,		"eq",		2,
    OGE,		"ge",		2,
    OGT,		"gt",		2,
    OHI,		"hi",		2,
    OHS,		"hs",		2,
    OLE,		"le",		2,
    OLO,		"lo",		2,
    OLS,		"ls",		2,
    OLT,		"lt",		2,
    ONE,		"ne",		2,

    OASADD,		"asadd",	3,
    OASAND,		"asand",	3,
    OASASHL,	"asashl",	3,
    OASASHR,	"asashr",	3,
    OASDIV,		"asdiv",	3,
    OASLDIV,	"asldiv",	3,
    OASLMOD,	"aslmod",	3,
    OASLMUL,	"aslmul",	3,
    OASLSHR,	"aslshr",	3,
    OASMOD,		"asmod",	3,
    OASMUL,		"asmul",	3,
    OASOR,		"asor",		3,
    OASSUB,		"assub",	3,
    OASXOR,		"asxor",	3,

    OPOS,		"pos",		4,
    ONEG,		"neg",		4,
    OCOM,		"com",		4,
    ONOT,		"not",		4,

//	OPOSTDEC,
//	OPOSTINC,
//	OPREDEC,
//	OPREINC,

    OXXX,
};
@



\section{Float}

<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@




<<function allfloat>>=
/*
 * look into tree for floating point constant expressions
 */
bool
allfloat(Node *n, int flag)
{

    if(n != Z) {
        if(n->type->etype != TDOUBLE)
            return true;
        switch(n->op) {
        case OCONST:
            if(flag)
                n->type = types[TFLOAT];
            return true;
        case OADD:	/* no need to get more exotic than this */
        case OSUB:
        case OMUL:
        case ODIV:
            if(!allfloat(n->right, flag))
                break;
        case OCAST:
            if(!allfloat(n->left, flag))
                break;
            if(flag)
                n->type = types[TFLOAT];
            return true;
        }
    }
    return false;
}
@

\section{64 bits operations}

\subsection{[[cc/com64.c]]}
% portable part, cc/com64.c
% vlong is 64 bits, so how do on 32 bits?
% do via builtins _xxxv, e.g. _addv, _mulv in lib_core/libc/xxx/vlop.c

<<constant FNX>>=
/*
 * this is machine dependent, but it is totally
 * common on all of the 64-bit symulating machines.
 */

#define	FNX	100	/* botch -- redefinition */
@

<<global nodaddv>>=
Node*	nodaddv;
@

<<global nodsubv>>=
Node*	nodsubv;
@

<<global nodmulv>>=
Node*	nodmulv;
@

<<global noddivv>>=
Node*	noddivv;
@

<<global noddivvu>>=
Node*	noddivvu;
@

<<global nodmodv>>=
Node*	nodmodv;
@

<<global nodmodvu>>=
Node*	nodmodvu;
@

<<global nodlshv>>=
Node*	nodlshv;
@

<<global nodrshav>>=
Node*	nodrshav;
@

<<global nodrshlv>>=
Node*	nodrshlv;
@

<<global nodandv>>=
Node*	nodandv;
@

<<global nodorv>>=
Node*	nodorv;
@

<<global nodxorv>>=
Node*	nodxorv;
@

<<global nodnegv>>=
Node*	nodnegv;
@

<<global nodcomv>>=
Node*	nodcomv;
@

<<global nodtestv>>=
Node*	nodtestv;
@

<<global nodeqv>>=
Node*	nodeqv;
@

<<global nodnev>>=
Node*	nodnev;
@

<<global nodlev>>=
Node*	nodlev;
@

<<global nodltv>>=
Node*	nodltv;
@

<<global nodgev>>=
Node*	nodgev;
@

<<global nodgtv>>=
Node*	nodgtv;
@

<<global nodhiv>>=
Node*	nodhiv;
@

<<global nodhsv>>=
Node*	nodhsv;
@

<<global nodlov>>=
Node*	nodlov;
@

<<global nodlsv>>=
Node*	nodlsv;
@

<<global nodf2v>>=
Node*	nodf2v;
@

<<global nodd2v>>=
Node*	nodd2v;
@

<<global nodp2v>>=
Node*	nodp2v;
@

<<global nodsi2v>>=
Node*	nodsi2v;
@

<<global nodui2v>>=
Node*	nodui2v;
@

<<global nodsl2v>>=
Node*	nodsl2v;
@

<<global nodul2v>>=
Node*	nodul2v;
@

<<global nodsh2v>>=
Node*	nodsh2v;
@

<<global noduh2v>>=
Node*	noduh2v;
@

<<global nodsc2v>>=
Node*	nodsc2v;
@

<<global noduc2v>>=
Node*	noduc2v;
@

<<global nodv2f>>=
Node*	nodv2f;
@

<<global nodv2d>>=
Node*	nodv2d;
@

<<global nodv2ui>>=
Node*	nodv2ui;
@

<<global nodv2si>>=
Node*	nodv2si;
@

<<global nodv2ul>>=
Node*	nodv2ul;
@

<<global nodv2sl>>=
Node*	nodv2sl;
@

<<global nodv2uh>>=
Node*	nodv2uh;
@

<<global nodv2sh>>=
Node*	nodv2sh;
@

<<global nodv2uc>>=
Node*	nodv2uc;
@

<<global nodv2sc>>=
Node*	nodv2sc;
@

<<global nodvpp>>=
Node*	nodvpp;
@

<<global nodppv>>=
Node*	nodppv;
@

<<global nodvmm>>=
Node*	nodvmm;
@

<<global nodmmv>>=
Node*	nodmmv;
@

<<global nodvasop>>=
Node*	nodvasop;
@

<<global etconv>>=
char	etconv[NTYPE];	/* for _vasop */
@

<<global initetconv>>=
Init	initetconv[] =
{
    TCHAR,		1,	0,
    TUCHAR,		2,	0,
    TSHORT,		3,	0,
    TUSHORT,	4,	0,
    TLONG,		5,	0,
    TULONG,		6,	0,
    TVLONG,		7,	0,
    TUVLONG,	8,	0,
    TINT,		9,	0,
    TUINT,		10,	0,
    -1,		0,	0,
};
@

<<global fntypes>>=
Type*	fntypes[NTYPE];
@

<<function fvn>>=
Node*
fvn(char *name, int type)
{
    Node *n;

    n = new(ONAME, Z, Z);
    n->sym = slookup(name);
    n->sym->sig = SIGINTERN;
    if(fntypes[type] == 0)
        fntypes[type] = typ(TFUNC, types[type]);
    n->type = fntypes[type];
    n->etype = type;
    n->class = CGLOBL;
    n->addable = 10;
    n->complex = 0;
    return n;
}
@

<<function com64init>>=
void
com64init(void)
{
    Init *p;

    nodaddv = fvn("_addv", TVLONG);
    nodsubv = fvn("_subv", TVLONG);
    nodmulv = fvn("_mulv", TVLONG);
    noddivv = fvn("_divv", TVLONG);
    noddivvu = fvn("_divvu", TVLONG);
    nodmodv = fvn("_modv", TVLONG);
    nodmodvu = fvn("_modvu", TVLONG);
    nodlshv = fvn("_lshv", TVLONG);
    nodrshav = fvn("_rshav", TVLONG);
    nodrshlv = fvn("_rshlv", TVLONG);
    nodandv = fvn("_andv", TVLONG);
    nodorv = fvn("_orv", TVLONG);
    nodxorv = fvn("_xorv", TVLONG);
    nodnegv = fvn("_negv", TVLONG);
    nodcomv = fvn("_comv", TVLONG);

    nodtestv = fvn("_testv", TLONG);
    nodeqv = fvn("_eqv", TLONG);
    nodnev = fvn("_nev", TLONG);
    nodlev = fvn("_lev", TLONG);
    nodltv = fvn("_ltv", TLONG);
    nodgev = fvn("_gev", TLONG);
    nodgtv = fvn("_gtv", TLONG);
    nodhiv = fvn("_hiv", TLONG);
    nodhsv = fvn("_hsv", TLONG);
    nodlov = fvn("_lov", TLONG);
    nodlsv = fvn("_lsv", TLONG);

    nodf2v = fvn("_f2v", TVLONG);
    nodd2v = fvn("_d2v", TVLONG);
    nodp2v = fvn("_p2v", TVLONG);
    nodsi2v = fvn("_si2v", TVLONG);
    nodui2v = fvn("_ui2v", TVLONG);
    nodsl2v = fvn("_sl2v", TVLONG);
    nodul2v = fvn("_ul2v", TVLONG);
    nodsh2v = fvn("_sh2v", TVLONG);
    noduh2v = fvn("_uh2v", TVLONG);
    nodsc2v = fvn("_sc2v", TVLONG);
    noduc2v = fvn("_uc2v", TVLONG);

    nodv2f = fvn("_v2f", TFLOAT);
    nodv2d = fvn("_v2d", TDOUBLE);
    nodv2sl = fvn("_v2sl", TLONG);
    nodv2ul = fvn("_v2ul", TULONG);
    nodv2si = fvn("_v2si", TINT);
    nodv2ui = fvn("_v2ui", TUINT);
    nodv2sh = fvn("_v2sh", TSHORT);
    nodv2uh = fvn("_v2ul", TUSHORT);
    nodv2sc = fvn("_v2sc", TCHAR);
    nodv2uc = fvn("_v2uc", TUCHAR);

    nodvpp = fvn("_vpp", TVLONG);
    nodppv = fvn("_ppv", TVLONG);
    nodvmm = fvn("_vmm", TVLONG);
    nodmmv = fvn("_mmv", TVLONG);

    nodvasop = fvn("_vasop", TVLONG);

    for(p = initetconv; p->code >= 0; p++)
        etconv[p->code] = p->value;
}
@

<<function com64>>=
int
com64(Node *n)
{
    Node *l, *r, *a, *t;
    int lv, rv;

    if(n->type == 0)
        return 0;

    l = n->left;
    r = n->right;

    lv = 0;
    if(l && l->type && typev[l->type->etype])
        lv = 1;
    rv = 0;
    if(r && r->type && typev[r->type->etype])
        rv = 1;

    if(lv) {
        switch(n->op) {
        case OEQ:
            a = nodeqv;
            goto setbool;
        case ONE:
            a = nodnev;
            goto setbool;
        case OLE:
            a = nodlev;
            goto setbool;
        case OLT:
            a = nodltv;
            goto setbool;
        case OGE:
            a = nodgev;
            goto setbool;
        case OGT:
            a = nodgtv;
            goto setbool;
        case OHI:
            a = nodhiv;
            goto setbool;
        case OHS:
            a = nodhsv;
            goto setbool;
        case OLO:
            a = nodlov;
            goto setbool;
        case OLS:
            a = nodlsv;
            goto setbool;

        case OANDAND:
        case OOROR:
            if(machcap(n))
                return 1;

            if(rv) {
                r = new(OFUNC, nodtestv, r);
                n->right = r;
                r->complex = FNX;
                r->op = OFUNC;
                r->type = types[TLONG];
            }

        case OCOND:
        case ONOT:
            if(machcap(n))
                return 1;

            l = new(OFUNC, nodtestv, l);
            n->left = l;
            l->complex = FNX;
            l->op = OFUNC;
            l->type = types[TLONG];
            n->complex = FNX;
            return 1;
        }
    }

    if(rv) {
        if(machcap(n))
            return 1;
        switch(n->op) {
        case OANDAND:
        case OOROR:
            r = new(OFUNC, nodtestv, r);
            n->right = r;
            r->complex = FNX;
            r->op = OFUNC;
            r->type = types[TLONG];
            return 1;
        case OCOND:
            return 1;
        }
    }

    if(typev[n->type->etype]) {
        if(machcap(n))
            return 1;
        switch(n->op) {
        default:
            diag(n, "unknown vlong %O", n->op);
        case OFUNC:
            n->complex = FNX;
        case ORETURN:
        case OAS:
        case OIND:
        case OLIST:
        case OCOMMA:
            return 1;
        case OADD:
            a = nodaddv;
            goto setbop;
        case OSUB:
            a = nodsubv;
            goto setbop;
        case OMUL:
        case OLMUL:
            a = nodmulv;
            goto setbop;
        case ODIV:
            a = noddivv;
            goto setbop;
        case OLDIV:
            a = noddivvu;
            goto setbop;
        case OMOD:
            a = nodmodv;
            goto setbop;
        case OLMOD:
            a = nodmodvu;
            goto setbop;
        case OASHL:
            a = nodlshv;
            goto setbop;
        case OASHR:
            a = nodrshav;
            goto setbop;
        case OLSHR:
            a = nodrshlv;
            goto setbop;
        case OAND:
            a = nodandv;
            goto setbop;
        case OOR:
            a = nodorv;
            goto setbop;
        case OXOR:
            a = nodxorv;
            goto setbop;
        case OPOSTINC:
            a = nodvpp;
            goto setvinc;
        case OPOSTDEC:
            a = nodvmm;
            goto setvinc;
        case OPREINC:
            a = nodppv;
            goto setvinc;
        case OPREDEC:
            a = nodmmv;
            goto setvinc;
        case ONEG:
            a = nodnegv;
            goto setfnx;
        case OCOM:
            a = nodcomv;
            goto setfnx;
        case OCAST:
            switch(l->type->etype) {
            case TCHAR:
                a = nodsc2v;
                goto setfnxl;
            case TUCHAR:
                a = noduc2v;
                goto setfnxl;
            case TSHORT:
                a = nodsh2v;
                goto setfnxl;
            case TUSHORT:
                a = noduh2v;
                goto setfnxl;
            case TINT:
                a = nodsi2v;
                goto setfnx;
            case TUINT:
                a = nodui2v;
                goto setfnx;
            case TLONG:
                a = nodsl2v;
                goto setfnx;
            case TULONG:
                a = nodul2v;
                goto setfnx;
            case TFLOAT:
                a = nodf2v;
                goto setfnx;
            case TDOUBLE:
                a = nodd2v;
                goto setfnx;
            case TIND:
                a = nodp2v;
                goto setfnx;
            }
            diag(n, "unknown %T->vlong cast", l->type);
            return 1;
        case OASADD:
            a = nodaddv;
            goto setasop;
        case OASSUB:
            a = nodsubv;
            goto setasop;
        case OASMUL:
        case OASLMUL:
            a = nodmulv;
            goto setasop;
        case OASDIV:
            a = noddivv;
            goto setasop;
        case OASLDIV:
            a = noddivvu;
            goto setasop;
        case OASMOD:
            a = nodmodv;
            goto setasop;
        case OASLMOD:
            a = nodmodvu;
            goto setasop;
        case OASASHL:
            a = nodlshv;
            goto setasop;
        case OASASHR:
            a = nodrshav;
            goto setasop;
        case OASLSHR:
            a = nodrshlv;
            goto setasop;
        case OASAND:
            a = nodandv;
            goto setasop;
        case OASOR:
            a = nodorv;
            goto setasop;
        case OASXOR:
            a = nodxorv;
            goto setasop;
        }
    }

    if(typefd[n->type->etype] && l && l->op == OFUNC) {
        switch(n->op) {
        case OASADD:
        case OASSUB:
        case OASMUL:
        case OASLMUL:
        case OASDIV:
        case OASLDIV:
        case OASMOD:
        case OASLMOD:
        case OASASHL:
        case OASASHR:
        case OASLSHR:
        case OASAND:
        case OASOR:
        case OASXOR:
            if(l->right && typev[l->right->etype]) {
                diag(n, "sorry float <asop> vlong not implemented\n");
            }
        }
    }

    if(n->op == OCAST) {
        if(l->type && typev[l->type->etype]) {
            if(machcap(n))
                return 1;
            switch(n->type->etype) {
            case TDOUBLE:
                a = nodv2d;
                goto setfnx;
            case TFLOAT:
                a = nodv2f;
                goto setfnx;
            case TLONG:
                a = nodv2sl;
                goto setfnx;
            case TULONG:
                a = nodv2ul;
                goto setfnx;
            case TINT:
                a = nodv2si;
                goto setfnx;
            case TUINT:
                a = nodv2ui;
                goto setfnx;
            case TSHORT:
                a = nodv2sh;
                goto setfnx;
            case TUSHORT:
                a = nodv2uh;
                goto setfnx;
            case TCHAR:
                a = nodv2sc;
                goto setfnx;
            case TUCHAR:
                a = nodv2uc;
                goto setfnx;
            case TIND:	// small pun here
                a = nodv2ul;
                goto setfnx;
            }
            diag(n, "unknown vlong->%T cast", n->type);
            return 1;
        }
    }

    return 0;

setbop:
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setfnxl:
    l = new(OCAST, l, 0);
    l->type = types[TLONG];
    l->complex = l->left->complex;

setfnx:
    n->left = a;
    n->right = l;
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setvinc:
    n->left = a;
    l = new(OADDR, l, Z);
    l->type = typ(TIND, l->left->type);
    l->complex = l->left->complex;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setbool:
    if(machcap(n))
        return 1;
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    n->type = types[TLONG];
    return 1;

setasop:
    if(l->op == OFUNC) {
        l = l->right;
        goto setasop;
    }

    t = new(OCONST, 0, 0);
    t->vconst = etconv[l->type->etype];
    t->type = types[TLONG];
    t->addable = 20;
    r = new(OLIST, t, r);

    t = new(OADDR, a, 0);
    t->type = typ(TIND, a->type);
    r = new(OLIST, t, r);

    t = new(OADDR, l, 0);
    t->type = typ(TIND, l->type);
    t->complex = l->complex;
    r = new(OLIST, t, r);

    n->left = nodvasop;
    n->right = r;
    n->complex = FNX;
    n->op = OFUNC;

    return 1;
}
@

<<function bool64>>=
void
bool64(Node *n)
{
    Node *n1;

    if(machcap(Z))
        return;
    if(typev[n->type->etype]) {
        n1 = new(OXXX, 0, 0);
        *n1 = *n;

        n->right = n1;
        n->left = nodtestv;
        n->complex = FNX;
        n->addable = 0;
        n->op = OFUNC;
        n->type = types[TLONG];
    }
}
@

%<<function convvtof>>=
%/*
% * more machine depend stuff.
% * this is common for 8,16,32,64 bit machines.
% * this is common for ieee machines.
% */
%//double
%//convvtof(vlong v)
%//{
%//    double d;
%//
%//    d = v;		/* BOTCH */
%//    return d;
%//}
%@
%
%<<function convftov>>=
%//vlong
%//convftov(double d)
%//{
%//    vlong v;
%//
%//
%//    v = d;		/* BOTCH */
%//    return v;
%//}
%@
%
%<<function convftox>>=
%//double
%//convftox(double d, int et)
%//{
%//
%//    if(!typefd[et])
%//        diag(Z, "bad type in castftox %s", tnames[et]);
%//    return d;
%//}
%@



<<function convvtox>>=
vlong
convvtox(vlong c, int et)
{
    int n;

    n = 8 * ewidth[et];
    c &= MASK(n);
    if(!typeu[et])
        if(c & SIGN(n))
            c |= ~MASK(n);
    return c;
}
@

\subsection{[[8c/cgen64.c]]}


<<function zeroregm>>=
void
zeroregm(Node *n)
{
    gins(AMOVL, nodconst(0), n);
}
@

<<function vaddr>>=
/* do we need to load the address of a vlong? */
int
vaddr(Node *n, int a)
{
    switch(n->op) {
    case ONAME:
        if(a)
            return 1;
        return !(n->class == CEXTERN || n->class == CGLOBL || n->class == CSTATIC);

    case OCONST:
    case OREGISTER:
    case OINDREG:
        return 1;
    }
    return 0;
}
@

<<function hi64v>>=
long
hi64v(Node *n)
{
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        return (long)(n->vconst) & ~0L;
    else
        return (long)((uvlong)n->vconst>>32) & ~0L;
}
@

<<function lo64v>>=
long
lo64v(Node *n)
{
    if(align(0, types[TCHAR], Aarg1))	/* isbigendian */
        return (long)((uvlong)n->vconst>>32) & ~0L;
    else
        return (long)(n->vconst) & ~0L;
}
@

<<function hi64>>=
Node *
hi64(Node *n)
{
    return nodconst(hi64v(n));
}
@

<<function lo64>>=
Node *
lo64(Node *n)
{
    return nodconst(lo64v(n));
}
@

<<function anonreg>>=
static Node *
anonreg(void)
{
    Node *n;

    n = new(OREGISTER, Z, Z);
    n->reg = D_NONE;
    n->type = types[TLONG];
    return n;
}
@

<<function regpair>>=
static Node *
regpair(Node *n, Node *t)
{
    Node *r;

    if(n != Z && n->op == OREGPAIR)
        return n;
    r = new(OREGPAIR, anonreg(), anonreg());
    if(n != Z)
        r->type = n->type;
    else
        r->type = t->type;
    return r;
}
@

<<function evacaxdx>>=
static void
evacaxdx(Node *r)
{
    Node nod1, nod2;

    if(r->reg == D_AX || r->reg == D_DX) {
        reg[D_AX]++;
        reg[D_DX]++;
        /*
         * this is just an optim that should
         * check for spill
         */
        r->type = types[TULONG];
        regalloc(&nod1, r, Z);
        nodreg(&nod2, Z, r->reg);
        gins(AMOVL, &nod2, &nod1);
        regfree(r);
        r->reg = nod1.reg;
        reg[D_AX]--;
        reg[D_DX]--;
    }
}
@

<<function instpair>>=
/* lazy instantiation of register pair */
static int
instpair(Node *n, Node *l)
{
    int r;

    r = 0;
    if(n->left->reg == D_NONE) {
        if(l != Z) {
            n->left->reg = l->reg;
            r = 1;
        }
        else
            regalloc(n->left, n->left, Z);
    }
    if(n->right->reg == D_NONE)
        regalloc(n->right, n->right, Z);
    return r;
}
@

<<function zapreg>>=
static void
zapreg(Node *n)
{
    if(n->reg != D_NONE) {
        //prtree(n, "zapreg");
        regfree(n);
        n->reg = D_NONE;
    }
}
@

<<function freepair>>=
static void
freepair(Node *n)
{
    regfree(n->left);
    regfree(n->right);
}
@

<<function loadpair>>=
/* n is not OREGPAIR, nn is */
void
loadpair(Node *n, Node *nn)
{
    Node nod;

    instpair(nn, Z);
    if(n->op == OCONST) {
        gins(AMOVL, lo64(n), nn->left);
        n->xoffset += SZ_LONG;
        gins(AMOVL, hi64(n), nn->right);
        n->xoffset -= SZ_LONG;
        return;
    }
    if(!vaddr(n, 0)) {
        /* steal the right register for the laddr */
        nod = regnode;
        nod.reg = nn->right->reg;
        lcgen(n, &nod);
        n = &nod;
        regind(n, n);
        n->xoffset = 0;
    }
    gins(AMOVL, n, nn->left);
    n->xoffset += SZ_LONG;
    gins(AMOVL, n, nn->right);
    n->xoffset -= SZ_LONG;
}
@

<<function storepair>>=
/* n is OREGPAIR, nn is not */
static void
storepair(Node *n, Node *nn, int f)
{
    Node nod;

    if(!vaddr(nn, 0)) {
        reglcgen(&nod, nn, Z);
        nn = &nod;
    }
    gins(AMOVL, n->left, nn);
    nn->xoffset += SZ_LONG;
    gins(AMOVL, n->right, nn);
    nn->xoffset -= SZ_LONG;
    if(nn == &nod)
        regfree(&nod);
    if(f)
        freepair(n);
}
@

<<enum _anon_ (8c/cgen64.c)>>=
enum
{
/* 4 only, see WW */
    WNONE	= 0,
    WCONST,
    WADDR,
    WHARD,
};
@

<<function whatof>>=
static int
whatof(Node *n, int a)
{
    if(n->op == OCONST)
        return WCONST;
    return !vaddr(n, a) ? WHARD : WADDR;
}
@

<<function reduxv>>=
/* can upgrade an extern to addr for AND */
static int
reduxv(Node *n)
{
    return lo64v(n) == 0 || hi64v(n) == 0;
}
@

<<function cond>>=
bool
cond(int op)
{
    switch(op) {
    case OANDAND:
    case OOROR:
    case ONOT:
        return true;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        return true;
    }
    return false;
}
@

<<function vfunc>>=
/*
 * for a func operand call it and then return
 * the safe node
 */
static Node *
vfunc(Node *n, Node *nn)
{
    Node *t;

    if(n->op != OFUNC)
        return n;
    t = new(0, Z, Z);
    if(nn == Z || nn == nodret)
        nn = n;
    regsalloc(t, nn);
    sugen(n, t, 8);
    return t;
}
@

<<function getreg>>=
/* try to steal a reg */
static int
getreg(Node **np, Node *t, int r)
{
    Node *n, *p;

    n = *np;
    if(n->reg == r) {
        p = new(0, Z, Z);
        regalloc(p, n, Z);
        gins(AMOVL, n, p);
        *t = *n;
        *np = p;
        return 1;
    }
    return 0;
}
@

<<function snarfreg>>=
static Node *
snarfreg(Node *n, Node *t, int r, Node *d, Node *c)
{
    if(n == Z || n->op != OREGPAIR || (!getreg(&n->left, t, r) && !getreg(&n->right, t, r))) {
        if(nodreg(t, Z, r)) {
            regalloc(c, d, Z);
            gins(AMOVL, t, c);
            reg[r]++;
            return c;
        }
        reg[r]++;
    }
    return Z;
}
@

<<enum _anon_ (8c/cgen64.c)2>>=
enum
{
    Vstart	= OEND,

    Vgo,
    Vamv,
    Vmv,
    Vzero,
    Vop,
    Vopx,
    Vins,
    Vins0,
    Vinsl,
    Vinsr,
    Vinsla,
    Vinsra,
    Vinsx,
    Vmul,
    Vshll,
    VT,
    VF,
    V_l_lo_f,
    V_l_hi_f,
    V_l_lo_t,
    V_l_hi_t,
    V_l_lo_u,
    V_l_hi_u,
    V_r_lo_f,
    V_r_hi_f,
    V_r_lo_t,
    V_r_hi_t,
    V_r_lo_u,
    V_r_hi_u,
    Vspazz,
    Vend,

    V_T0,
    V_T1,
    V_F0,
    V_F1,

    V_a0,
    V_a1,
    V_f0,
    V_f1,

    V_p0,
    V_p1,
    V_p2,
    V_p3,
    V_p4,

    V_s0,
    V_s1,
    V_s2,
    V_s3,
    V_s4,

    C00,
    C01,
    C31,
    C32,

    O_l_lo,
    O_l_hi,
    O_r_lo,
    O_r_hi,
    O_t_lo,
    O_t_hi,
    O_l,
    O_r,
    O_l_rp,
    O_r_rp,
    O_t_rp,
    O_r0,
    O_r1,
    O_Zop,

    O_a0,
    O_a1,

    V_C0,
    V_C1,

    V_S0,
    V_S1,

    VOPS	= 5,
    VLEN	= 5,
    VARGS	= 2,

    S00	= 0,
    Sc0,
    Sc1,
    Sc2,
    Sac3,
    Sac4,
    S10,

    SAgen	= 0,
    SAclo,
    SAc32,
    SAchi,
    SAdgen,
    SAdclo,
    SAdc32,
    SAdchi,

    B0c	= 0,
    Bca,
    Bac,

    T0i	= 0,
    Tii,

    Bop0	= 0,
    Bop1,
};
@

<<global testi>>=
/*
 * _testv:
 * 	CMPL	lo,$0
 * 	JNE	true
 * 	CMPL	hi,$0
 * 	JNE	true
 * 	GOTO	false
 * false:
 * 	GOTO	code
 * true:
 * 	GOTO	patchme
 * code:
 */

static uchar	testi[][VLEN] =
{
    {Vop, ONE, O_l_lo, C00},
    {V_s0, Vop, ONE, O_l_hi, C00},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {Vend},
};
@

<<global shll00>>=
/* shift left general case */
static uchar	shll00[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vinsl, ASHLL, O_r, O_l_rp},
    {Vins, ASHLL, O_r, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, ASHLL, O_r, O_l_lo},
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, V_p0, Vend},
};
@

<<global shllc0>>=
/* shift left rp, const < 32 */
static uchar	shllc0[][VLEN] =
{
    {Vinsl, ASHLL, O_r, O_l_rp},
    {Vshll, O_r, O_l_lo, Vend},
};
@

<<global shllc1>>=
/* shift left rp, const == 32 */
static uchar	shllc1[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, Vend},
};
@

<<global shllc2>>=
/* shift left rp, const > 32 */
static uchar	shllc2[][VLEN] =
{
    {Vshll, O_r, O_l_lo},
    {Vins, AMOVL, O_l_lo, O_l_hi},
    {Vzero, O_l_lo, Vend},
};
@

<<global shllac3>>=
/* shift left addr, const == 32 */
static uchar	shllac3[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo, Vend},
};
@

<<global shllac4>>=
/* shift left addr, const > 32 */
static uchar	shllac4[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vshll, O_r, O_t_hi},
    {Vzero, O_t_lo, Vend},
};
@

<<global shll10>>=
/* shift left of constant */
static uchar	shll10[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vins, ASHLL, O_r, O_t_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {V_l_lo_t, Vins, ASHLL, O_r, O_t_hi},
    {Vzero, O_t_lo, V_p0, Vend},
};
@

<<global shlltab>>=
static uchar	(*shlltab[])[VLEN] =
{
    shll00,
    shllc0,
    shllc1,
    shllc2,
    shllac3,
    shllac4,
    shll10,
};
@

<<global shrl00>>=
/* shift right general case */
static uchar	shrl00[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vinsr, ASHRL, O_r, O_l_rp},
    {Vins, O_a0, O_r, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, O_a0, O_r, O_l_hi},
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {V_p0, Vend},
};
@

<<global shrlc0>>=
/* shift right rp, const < 32 */
static uchar	shrlc0[][VLEN] =
{
    {Vinsr, ASHRL, O_r, O_l_rp},
    {Vins, O_a0, O_r, O_l_hi, Vend},
};
@

<<global shrlc1>>=
/* shift right rp, const == 32 */
static uchar	shrlc1[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {Vend},
};
@

<<global shrlc2>>=
/* shift right rp, const > 32 */
static uchar	shrlc2[][VLEN] =
{
    {Vins, O_a0, O_r, O_l_hi},
    {Vins, AMOVL, O_l_hi, O_l_lo},
    {V_T1, Vzero, O_l_hi},
    {V_F1, Vins, ASARL, C31, O_l_hi},
    {Vend},
};
@

<<global shrlac3>>=
/* shift right addr, const == 32 */
static uchar	shrlac3[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrlac4>>=
/* shift right addr, const > 32 */
static uchar	shrlac4[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {Vins, O_a0, O_r, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrl10>>=
/* shift right of constant */
static uchar	shrl10[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vins, O_a0, O_r, O_t_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_l_hi_t, Vins, O_a0, O_r, O_t_lo},
    {V_l_hi_u, V_S1},
    {V_T1, Vzero, O_t_hi, V_p0},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vend},
};
@

<<global shrltab>>=
static uchar	(*shrltab[])[VLEN] =
{
    shrl00,
    shrlc0,
    shrlc1,
    shrlc2,
    shrlac3,
    shrlac4,
    shrl10,
};
@

<<global asshllgen>>=
/* shift asop left general case */
static uchar	asshllgen[][VLEN] =
{
    {V_a0, V_a1},
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsla, ASHLL, O_r, O_r0},
    {Vins, ASHLL, O_r, O_r0},
    {Vins, AMOVL, O_r1, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vins, ASHLL, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_hi, V_p0},
    {V_f0, V_f1, Vend},
};
@

<<global asshllclo>>=
/* shift asop left, const < 32 */
static uchar	asshllclo[][VLEN] =
{
    {V_a0, V_a1},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsla, ASHLL, O_r, O_r0},
    {Vshll, O_r, O_r0},
    {Vins, AMOVL, O_r1, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_f0, V_f1, Vend},
};
@

<<global asshllc32>>=
/* shift asop left, const == 32 */
static uchar	asshllc32[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asshllchi>>=
/* shift asop left, const > 32 */
static uchar	asshllchi[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vzero, O_l_lo},
    {Vshll, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asdshllgen>>=
/* shift asop dest left general case */
static uchar	asdshllgen[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vins, ASHLL, O_r, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_l_lo},
    {Vins, ASHLL, O_r, O_t_hi},
    {Vzero, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, V_p0},
    {Vend},
};
@

<<global asdshllclo>>=
/* shift asop dest left, const < 32 */
static uchar	asdshllclo[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsl, ASHLL, O_r, O_t_rp},
    {Vshll, O_r, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vend},
};
@

<<global asdshllc32>>=
/* shift asop dest left, const == 32 */
static uchar	asdshllc32[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vend},
};
@

<<global asdshllchi>>=
/* shift asop dest, const > 32 */
static uchar	asdshllchi[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_hi},
    {Vzero, O_t_lo},
    {Vshll, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asshlltab>>=
static uchar	(*asshlltab[])[VLEN] =
{
    asshllgen,
    asshllclo,
    asshllc32,
    asshllchi,
    asdshllgen,
    asdshllclo,
    asdshllc32,
    asdshllchi,
};
@

<<global asshrlgen>>=
/* shift asop right general case */
static uchar	asshrlgen[][VLEN] =
{
    {V_a0, V_a1},
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsra, ASHRL, O_r, O_r0},
    {Vinsx, Bop0, O_r, O_r1},
    {Vins, AMOVL, O_r0, O_l_lo},
    {Vins, AMOVL, O_r1, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {Vinsx, Bop0, O_r, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_p0, V_f0, V_f1, Vend},
};
@

<<global asshrlclo>>=
/* shift asop right, const < 32 */
static uchar	asshrlclo[][VLEN] =
{
    {V_a0, V_a1},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r1},
    {Vinsra, ASHRL, O_r, O_r0},
    {Vinsx, Bop0, O_r, O_r1},
    {Vins, AMOVL, O_r0, O_l_lo},
    {Vins, AMOVL, O_r1, O_l_hi},
    {V_f0, V_f1, Vend},
};
@

<<global asshrlc32>>=
/* shift asop right, const == 32 */
static uchar	asshrlc32[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asshrlchi>>=
/* shift asop right, const > 32 */
static uchar	asshrlchi[][VLEN] =
{
    {V_a0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {V_T1, Vzero, O_l_hi},
    {Vinsx, Bop0, O_r, O_r0},
    {Vins, AMOVL, O_r0, O_l_lo},
    {V_F1, Vins, ASARL, C31, O_r0},
    {V_F1, Vins, AMOVL, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global asdshrlgen>>=
/* shift asop dest right general case */
static uchar	asdshrlgen[][VLEN] =
{
    {Vop, OGE, O_r, C32},
    {V_s0, Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vinsx, Bop0, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, Vgo},
    {V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {Vinsx, Bop0, O_r, O_t_lo},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vins, AMOVL, O_t_hi, O_l_hi, V_p0},
    {Vend},
};
@

<<global asdshrlclo>>=
/* shift asop dest right, const < 32 */
static uchar	asdshrlclo[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsr, ASHRL, O_r, O_t_rp},
    {Vinsx, Bop0, O_r, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asdshrlc32>>=
/* shift asop dest right, const == 32 */
static uchar	asdshrlc32[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asdshrlchi>>=
/* shift asop dest, const > 32 */
static uchar	asdshrlchi[][VLEN] =
{
    {Vins, AMOVL, O_l_hi, O_t_lo},
    {V_T1, Vzero, O_t_hi},
    {Vinsx, Bop0, O_r, O_t_lo},
    {V_T1, Vins, AMOVL, O_t_hi, O_l_hi},
    {V_T1, Vins, AMOVL, O_t_lo, O_l_lo},
    {V_F1, Vins, AMOVL, O_t_lo, O_t_hi},
    {V_F1, Vins, ASARL, C31, O_t_hi},
    {V_F1, Vins, AMOVL, O_t_lo, O_l_lo},
    {V_F1, Vins, AMOVL, O_t_hi, O_l_hi},
    {Vend},
};
@

<<global asshrltab>>=
static uchar	(*asshrltab[])[VLEN] =
{
    asshrlgen,
    asshrlclo,
    asshrlc32,
    asshrlchi,
    asdshrlgen,
    asdshrlclo,
    asdshrlc32,
    asdshrlchi,
};
@

<<global shrlargs>>=
static uchar	shrlargs[]	= { ASHRL, 1 };
@

<<global sarlargs>>=
static uchar	sarlargs[]	= { ASARL, 0 };
@

<<global incdec>>=
/* ++ -- */
static uchar	incdec[][VLEN] =
{
    {Vinsx, Bop0, C01, O_l_lo},
    {Vinsx, Bop1, C00, O_l_hi, Vend},
};
@

<<global incdecpre>>=
/* ++ -- *p */
static uchar	incdecpre[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, C01, O_t_lo},
    {Vinsx, Bop1, C00, O_t_hi},
    {Vins, AMOVL, O_t_lo, O_l_lo},
    {Vins, AMOVL, O_t_hi, O_l_hi, Vend},
};
@

<<global incdecpost>>=
/* *p ++ -- */
static uchar	incdecpost[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, C01, O_l_lo},
    {Vinsx, Bop1, C00, O_l_hi, Vend},
};
@

<<global binop00>>=
/* binop rp, rp */
static uchar	binop00[][VLEN] =
{
    {Vinsx, Bop0, O_r_lo, O_l_lo},
    {Vinsx, Bop1, O_r_hi, O_l_hi, Vend},
    {Vend},
};
@

<<global binoptmp>>=
/* binop rp, addr */
static uchar	binoptmp[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_lo, O_r0},
    {Vinsx, Bop0, O_r0, O_l_lo},
    {Vins, AMOVL, O_r_hi, O_r0},
    {Vinsx, Bop1, O_r0, O_l_hi},
    {V_f0, Vend},
};
@

<<global binop11>>=
/* binop t = *a op *b */
static uchar	binop11[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop1, O_r_hi, O_t_hi, Vend},
};
@

<<global add0c>>=
/* binop t = rp +- c */
static uchar	add0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_lo_f, Vamv, Bop0, Bop1},
    {Vinsx, Bop1, O_r_hi, O_l_hi},
    {Vend},
};
@

<<global and0c>>=
/* binop t = rp & c */
static uchar	and0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_lo_f, Vins, AMOVL, C00, O_l_lo},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_l_hi},
    {V_r_hi_f, Vins, AMOVL, C00, O_l_hi},
    {Vend},
};
@

<<global or0c>>=
/* binop t = rp | c */
static uchar	or0c[][VLEN] =
{
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_l_lo},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_l_hi},
    {Vend},
};
@

<<global sub10>>=
/* binop t = c - rp */
static uchar	sub10[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_lo, O_r0},
    {Vinsx, Bop0, O_r_lo, O_r0},
    {Vins, AMOVL, O_l_hi, O_r_lo},
    {Vinsx, Bop1, O_r_hi, O_r_lo},
    {Vspazz, V_f0, Vend},
};
@

<<global addca>>=
/* binop t = c + *b */
static uchar	addca[][VLEN] =
{
    {Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {V_l_lo_f, Vamv, Bop0, Bop1},
    {Vins, AMOVL, O_r_hi, O_t_hi},
    {Vinsx, Bop1, O_l_hi, O_t_hi},
    {Vend},
};
@

<<global andca>>=
/* binop t = c & *b */
static uchar	andca[][VLEN] =
{
    {V_l_lo_t, Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {V_l_lo_f, Vzero, O_t_lo},
    {V_l_hi_t, Vins, AMOVL, O_r_hi, O_t_hi},
    {V_l_hi_t, Vinsx, Bop1, O_l_hi, O_t_hi},
    {V_l_hi_f, Vzero, O_t_hi},
    {Vend},
};
@

<<global orca>>=
/* binop t = c | *b */
static uchar	orca[][VLEN] =
{
    {Vins, AMOVL, O_r_lo, O_t_lo},
    {V_l_lo_t, Vinsx, Bop0, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_r_hi, O_t_hi},
    {V_l_hi_t, Vinsx, Bop1, O_l_hi, O_t_hi},
    {Vend},
};
@

<<global subca>>=
/* binop t = c - *b */
static uchar	subca[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global addac>>=
/* binop t = *a +- c */
static uchar	addac[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {V_r_lo_f, Vamv, Bop0, Bop1},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global orac>>=
/* binop t = *a | c */
static uchar	orac[][VLEN] =
{
    {Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {Vins, AMOVL, O_l_hi, O_t_hi},
    {V_r_hi_t, Vinsx, Bop1, O_r_hi, O_t_hi},
    {Vend},
};
@

<<global andac>>=
/* binop t = *a & c */
static uchar	andac[][VLEN] =
{
    {V_r_lo_t, Vins, AMOVL, O_l_lo, O_t_lo},
    {V_r_lo_t, Vinsx, Bop0, O_r_lo, O_t_lo},
    {V_r_lo_f, Vzero, O_t_lo},
    {V_r_hi_t, Vins, AMOVL, O_l_hi, O_t_hi},
    {V_r_hi_t, Vinsx, Bop0, O_r_hi, O_t_hi},
    {V_r_hi_f, Vzero, O_t_hi},
    {Vend},
};
@

<<global ADDargs>>=
static uchar	ADDargs[]	= { AADDL, AADCL };
@

<<global ANDargs>>=
static uchar	ANDargs[]	= { AANDL, AANDL };
@

<<global ORargs>>=
static uchar	ORargs[]	= { AORL, AORL };
@

<<global SUBargs>>=
static uchar	SUBargs[]	= { ASUBL, ASBBL };
@

<<global XORargs>>=
static uchar	XORargs[]	= { AXORL, AXORL };
@

<<global ADDtab>>=
static uchar	(*ADDtab[])[VLEN] =
{
    add0c, addca, addac,
};
@

<<global ANDtab>>=
static uchar	(*ANDtab[])[VLEN] =
{
    and0c, andca, andac,
};
@

<<global ORtab>>=
static uchar	(*ORtab[])[VLEN] =
{
    or0c, orca, orac,
};
@

<<global SUBtab>>=
static uchar	(*SUBtab[])[VLEN] =
{
    add0c, subca, addac,
};
@

<<global mulc32>>=
/* mul of const32 */
static uchar	mulc32[][VLEN] =
{
    {V_a0, Vop, ONE, O_l_hi, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vins, AMOVL, O_l_hi, O_r0},
    {Vmul, O_r_lo, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global mulc64>>=
/* mul of const64 */
static uchar	mulc64[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_hi, O_r0},
    {Vop, OOR, O_l_hi, O_r0},
    {Vop, ONE, O_r0, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vmul, O_r_lo, O_l_hi},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vmul, O_r_hi, O_r0},
    {Vins, AADDL, O_l_hi, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global mull>>=
/* mul general */
static uchar	mull[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_r_hi, O_r0},
    {Vop, OOR, O_l_hi, O_r0},
    {Vop, ONE, O_r0, C00},
    {V_s0, Vins, AMOVL, O_r_lo, O_r0},
    {Vins, AMULL, O_r0, O_Zop},
    {Vgo, V_p0, V_s0},
    {Vins, AIMULL, O_r_lo, O_l_hi},
    {Vins, AMOVL, O_l_lo, O_r0},
    {Vins, AIMULL, O_r_hi, O_r0},
    {Vins, AADDL, O_l_hi, O_r0},
    {Vins, AMOVL, O_r_lo, O_l_hi},
    {Vins, AMULL, O_l_hi, O_Zop},
    {Vins, AADDL, O_r0, O_l_hi},
    {V_f0, V_p0, Vend},
};
@

<<global castrp>>=
/* cast rp l to rp t */
static uchar	castrp[][VLEN] =
{
    {Vmv, O_l, O_t_lo},
    {VT, Vins, AMOVL, O_t_lo, O_t_hi},
    {VT, Vins, ASARL, C31, O_t_hi},
    {VF, Vzero, O_t_hi},
    {Vend},
};
@

<<global castrpa>>=
/* cast rp l to addr t */
static uchar	castrpa[][VLEN] =
{
    {VT, V_a0, Vmv, O_l, O_r0},
    {VT, Vins, AMOVL, O_r0, O_t_lo},
    {VT, Vins, ASARL, C31, O_r0},
    {VT, Vins, AMOVL, O_r0, O_t_hi},
    {VT, V_f0},
    {VF, Vmv, O_l, O_t_lo},
    {VF, Vzero, O_t_hi},
    {Vend},
};
@

<<global netab0i>>=
static uchar	netab0i[][VLEN] =
{
    {Vop, ONE, O_l_lo, O_r_lo},
    {V_s0, Vop, ONE, O_l_hi, O_r_hi},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {Vend},
};
@

<<global netabii>>=
static uchar	netabii[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_lo, O_r0},
    {Vop, ONE, O_r0, O_r_lo},
    {V_s0, Vins, AMOVL, O_l_hi, O_r0},
    {Vop, ONE, O_r0, O_r_hi},
    {V_s1, Vgo, V_s2, Vgo, V_s3},
    {VF, V_p0, V_p1, VT, V_p2},
    {Vgo, V_p3},
    {VT, V_p0, V_p1, VF, V_p2},
    {V_f0, Vend},
};
@

<<global cmptab0i>>=
static uchar	cmptab0i[][VLEN] =
{
    {Vopx, Bop0, O_l_hi, O_r_hi},
    {V_s0, Vins0, AJNE},
    {V_s1, Vopx, Bop1, O_l_lo, O_r_lo},
    {V_s2, Vgo, V_s3, Vgo, V_s4},
    {VT, V_p1, V_p3},
    {VF, V_p0, V_p2},
    {Vgo, V_p4},
    {VT, V_p0, V_p2},
    {VF, V_p1, V_p3},
    {Vend},
};
@

<<global cmptabii>>=
static uchar	cmptabii[][VLEN] =
{
    {V_a0, Vins, AMOVL, O_l_hi, O_r0},
    {Vopx, Bop0, O_r0, O_r_hi},
    {V_s0, Vins0, AJNE},
    {V_s1, Vins, AMOVL, O_l_lo, O_r0},
    {Vopx, Bop1, O_r0, O_r_lo},
    {V_s2, Vgo, V_s3, Vgo, V_s4},
    {VT, V_p1, V_p3},
    {VF, V_p0, V_p2},
    {Vgo, V_p4},
    {VT, V_p0, V_p2},
    {VF, V_p1, V_p3},
    {V_f0, Vend},
};
@

<<global NEtab>>=
static uchar	(*NEtab[])[VLEN] =
{
    netab0i, netabii,
};
@

<<global cmptab>>=
static uchar	(*cmptab[])[VLEN] =
{
    cmptab0i, cmptabii,
};
@

<<global GEargs>>=
static uchar	GEargs[]	= { OGT, OHS };
@

<<global GTargs>>=
static uchar	GTargs[]	= { OGT, OHI };
@

<<global HIargs>>=
static uchar	HIargs[]	= { OHI, OHI };
@

<<global HSargs>>=
static uchar	HSargs[]	= { OHI, OHS };
@

<<function biggen>>=
/* Big Generator */
static void
biggen(Node *l, Node *r, Node *t, int true, uchar code[][VLEN], uchar *a)
{
    int i, j, g, oc, op, lo, ro, to, xo, *xp;
    Type *lt;
    Prog *pr[VOPS];
    Node *ot, *tl, *tr, tmps[2];
    uchar *c, (*cp)[VLEN], args[VARGS];

    if(a != nil)
        memmove(args, a, VARGS);
//print("biggen %d %d %d\n", args[0], args[1], args[2]);
//if(l) prtree(l, "l");
//if(r) prtree(r, "r");
//if(t) prtree(t, "t");
    lo = ro = to = 0;
    cp = code;

    for (;;) {
        c = *cp++;
        g = 1;
        i = 0;
//print("code %d %d %d %d %d\n", c[0], c[1], c[2], c[3], c[4]);
        for(;;) {
            switch(op = c[i]) {
            case Vgo:
                if(g)
                    gbranch(OGOTO);
                i++;
                break;

            case Vamv:
                i += 3;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                if(g)
                    args[c[i - 1]] = args[c[i - 2]];
                break;

            case Vzero:
                i += 2;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 1;
                goto op;

            case Vspazz:	// nasty hack to save a reg in SUB
//print("spazz\n");
                if(g) {
//print("hi %R lo %R t %R\n", r->right->reg, r->left->reg, tmps[0].reg);
                    ot = r->right;
                    r->right = r->left;
                    tl = new(0, Z, Z);
                    *tl = tmps[0];
                    r->left = tl;
                    tmps[0] = *ot;
//print("hi %R lo %R t %R\n", r->right->reg, r->left->reg, tmps[0].reg);
                }
                i++;
                break;

            case Vmv:
            case Vmul:
            case Vshll:
                i += 3;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 2;
                goto op;

            case Vins0:
                i += 2;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                gins(c[i - 1], Z, Z);
                break;

            case Vop:
            case Vopx:
            case Vins:
            case Vinsl:
            case Vinsr:
            case Vinsla:
            case Vinsra:
            case Vinsx:
                i += 4;
                if(i > VLEN) {
                    diag(l, "bad Vop");
                    return;
                }
                j = i - 2;
                goto op;

            op:
                if(!g)
                    break;
                tl = Z;
                tr = Z;
                for(; j < i; j++) {
                    switch(c[j]) {
                    case C00:
                        ot = nodconst(0);
                        break;
                    case C01:
                        ot = nodconst(1);
                        break;
                    case C31:
                        ot = nodconst(31);
                        break;
                    case C32:
                        ot = nodconst(32);
                        break;

                    case O_l:
                    case O_l_lo:
                        ot = l; xp = &lo; xo = 0;
                        goto op0;
                    case O_l_hi:
                        ot = l; xp = &lo; xo = SZ_LONG;
                        goto op0;
                    case O_r:
                    case O_r_lo:
                        ot = r; xp = &ro; xo = 0;
                        goto op0;
                    case O_r_hi:
                        ot = r; xp = &ro; xo = SZ_LONG;
                        goto op0;
                    case O_t_lo:
                        ot = t; xp = &to; xo = 0;
                        goto op0;
                    case O_t_hi:
                        ot = t; xp = &to; xo = SZ_LONG;
                        goto op0;
                    case O_l_rp:
                        ot = l;
                        break;
                    case O_r_rp:
                        ot = r;
                        break;
                    case O_t_rp:
                        ot = t;
                        break;
                    case O_r0:
                    case O_r1:
                        ot = &tmps[c[j] - O_r0];
                        break;
                    case O_Zop:
                        ot = Z;
                        break;

                    op0:
                        switch(ot->op) {
                        case OCONST:
                            if(xo)
                                ot = hi64(ot);
                            else
                                ot = lo64(ot);
                            break;
                        case OREGPAIR:
                            if(xo)
                                ot = ot->right;
                            else
                                ot = ot->left;
                            break;
                        case OREGISTER:
                            break;
                        default:
                            if(xo != *xp) {
                                ot->xoffset += xo - *xp;
                                *xp = xo;
                            }
                        }
                        break;
                    
                    default:
                        diag(l, "bad V_lop");
                        return;
                    }
                    if(tl == nil)
                        tl = ot;
                    else
                        tr = ot;
                }
                if(op == Vzero) {
                    zeroregm(tl);
                    break;
                }
                oc = c[i - 3];
                if(op == Vinsx || op == Vopx) {
//print("%d -> %d\n", oc, args[oc]);
                    oc = args[oc];
                }
                else {
                    switch(oc) {
                    case O_a0:
                    case O_a1:
                        oc = args[oc - O_a0];
                        break;
                    }
                }
                switch(op) {
                case Vmul:
                    mulgen(tr->type, tl, tr);
                    break;
                case Vmv:
                    gmove(tl, tr);
                    break;
                case Vshll:
                    shiftit(tr->type, tl, tr);
                    break;
                case Vop:
                case Vopx:
                    gopcode(oc, types[TULONG], tl, tr);
                    break;
                case Vins:
                case Vinsx:
                    gins(oc, tl, tr);
                    break;
                case Vinsl:
                    gins(oc, tl, tr->right);
                    p->from.index = tr->left->reg;
                    break;
                case Vinsr:
                    gins(oc, tl, tr->left);
                    p->from.index = tr->right->reg;
                    break;
                case Vinsla:
                    gins(oc, tl, tr + 1);
                    p->from.index = tr->reg;
                    break;
                case Vinsra:
                    gins(oc, tl, tr);
                    p->from.index = (tr + 1)->reg;
                    break;
                }
                break;

            case VT:
                g = true;
                i++;
                break;
            case VF:
                g = !true;
                i++;
                break;

            case V_T0: case V_T1:
                g = args[op - V_T0];
                i++;
                break;

            case V_F0: case V_F1:
                g = !args[op - V_F0];
                i++;
                break;

            case V_C0: case V_C1:
                if(g)
                    args[op - V_C0] = 0;
                i++;
                break;

            case V_S0: case V_S1:
                if(g)
                    args[op - V_S0] = 1;
                i++;
                break;

            case V_l_lo_f:
                g = lo64v(l) == 0;
                i++;
                break;
            case V_l_hi_f:
                g = hi64v(l) == 0;
                i++;
                break;
            case V_l_lo_t:
                g = lo64v(l) != 0;
                i++;
                break;
            case V_l_hi_t:
                g = hi64v(l) != 0;
                i++;
                break;
            case V_l_lo_u:
                g = lo64v(l) >= 0;
                i++;
                break;
            case V_l_hi_u:
                g = hi64v(l) >= 0;
                i++;
                break;
            case V_r_lo_f:
                g = lo64v(r) == 0;
                i++;
                break;
            case V_r_hi_f:
                g = hi64v(r) == 0;
                i++;
                break;
            case V_r_lo_t:
                g = lo64v(r) != 0;
                i++;
                break;
            case V_r_hi_t:
                g = hi64v(r) != 0;
                i++;
                break;
            case V_r_lo_u:
                g = lo64v(r) >= 0;
                i++;
                break;
            case V_r_hi_u:
                g = hi64v(r) >= 0;
                i++;
                break;

            case Vend:
                goto out;

            case V_a0: case V_a1:
                if(g) {
                    lt = l->type;
                    l->type = types[TULONG];
                    regalloc(&tmps[op - V_a0], l, Z);
                    l->type = lt;
                }
                i++;
                break;

            case V_f0: case V_f1:
                if(g)
                    regfree(&tmps[op - V_f0]);
                i++;
                break;

            case V_p0: case V_p1: case V_p2: case V_p3: case V_p4:
                if(g)
                    patch(pr[op - V_p0], pc);
                i++;
                break;

            case V_s0: case V_s1: case V_s2: case V_s3: case V_s4:
                if(g)
                    pr[op - V_s0] = p;
                i++;
                break;

            default:
                diag(l, "bad biggen: %d", op);
                return;
            }
            if(i == VLEN || c[i] == 0)
                break;
        }
    }
out:
    if(lo)
        l->xoffset -= lo;
    if(ro)
        r->xoffset -= ro;
    if(to)
        t->xoffset -= to;
}
@

<<function IMM>>=
#define	IMM(l, r)	((l) | ((r) << 1))
@

<<function WW>>=
#define	WW(l, r)	((l) | ((r) << 2))
@

<<function cgen64>>=
int
cgen64(Node *n, Node *nn)
{
    Type *dt;
    uchar *args, (*cp)[VLEN], (**optab)[VLEN];
    int li, ri, lri, dr, si, m, op, sh, cmp, true;
    Node *c, *d, *l, *r, *t, *s, nod1, nod2, nod3, nod4, nod5;

    if(debug['g']) {
        prtree(nn, "cgen64 lhs");
        prtree(n, "cgen64");
        print("AX = %d\n", reg[D_AX]);
    }
    cmp = 0;
    sh = 0;

    switch(n->op) {
    case ONEG:
        d = regpair(nn, n);
        sugen(n->left, d, 8);
        gins(ANOTL, Z, d->right);
        gins(ANEGL, Z, d->left);
        gins(ASBBL, nodconst(-1), d->right);
        break;

    case OCOM:
        if(!vaddr(n->left, 0) || !vaddr(nn, 0))
            d = regpair(nn, n);
        else
            return 0;
        sugen(n->left, d, 8);
        gins(ANOTL, Z, d->left);
        gins(ANOTL, Z, d->right);
        break;

    case OADD:
        optab = ADDtab;
        args = ADDargs;
        goto twoop;
    case OAND:
        optab = ANDtab;
        args = ANDargs;
        goto twoop;
    case OOR:
        optab = ORtab;
        args = ORargs;
        goto twoop;
    case OSUB:
        optab = SUBtab;
        args = SUBargs;
        goto twoop;
    case OXOR:
        optab = ORtab;
        args = XORargs;
        goto twoop;
    case OASHL:
        sh = 1;
        args = nil;
        optab = shlltab;
        goto twoop;
    case OLSHR:
        sh = 1;
        args = shrlargs;
        optab = shrltab;
        goto twoop;
    case OASHR:
        sh = 1;
        args = sarlargs;
        optab = shrltab;
        goto twoop;
    case OEQ:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case ONE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLT:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OGE:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OGT:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OHI:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OHS:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLO:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;
    case OLS:
        cmp = 1;
        args = nil;
        optab = nil;
        goto twoop;

twoop:
        dr = nn != Z && nn->op == OREGPAIR;
        l = vfunc(n->left, nn);
        if(sh)
            r = n->right;
        else
            r = vfunc(n->right, nn);

        li = l->op == ONAME || l->op == OINDREG || l->op == OCONST;
        ri = r->op == ONAME || r->op == OINDREG || r->op == OCONST;


        lri = IMM(li, ri);

        /* find out what is so easy about some operands */
        if(li)
            li = whatof(l, sh | cmp);
        if(ri)
            ri = whatof(r, cmp);

        if(sh)
            goto shift;

        if(cmp)
            goto cmp;

        /* evaluate hard subexps, stealing nn if possible. */
        switch(lri) {
        case IMM(0, 0):
        bin00:
            if(l->complex > r->complex) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, n);
                sugen(l, t, 8);
                l = t;
                t = regpair(Z, n);
                sugen(r, t, 8);
                r = t;
            }
            else {
                t = regpair(Z, n);
                sugen(r, t, 8);
                r = t;
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, n);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(0, 1):
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 0):
            if(n->op == OSUB && l->op == OCONST && hi64v(l) == 0) {
                lri = IMM(0, 0);
                goto bin00;
            }
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(r, t, 8);
            r = t;
            break;
        case IMM(1, 1):
            break;
        }

        d = Z;
        dt = nn->type;
        nn->type = types[TLONG];

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, 0, binop00, args);
            break;
        case IMM(0, 1):
            switch(ri) {
            case WNONE:
                diag(r, "bad whatof\n");
                break;
            case WCONST:
                biggen(l, r, Z, 0, optab[B0c], args);
                break;
            case WHARD:
                reglcgen(&nod2, r, Z);
                r = &nod2;
                /* fall thru */
            case WADDR:
                biggen(l, r, Z, 0, binoptmp, args);
                if(ri == WHARD)
                    regfree(r);
                break;
            }
            break;
        case IMM(1, 0):
            if(n->op == OSUB) {
                switch(li) {
                case WNONE:
                    diag(l, "bad whatof\n");
                    break;
                case WHARD:
                    reglcgen(&nod2, l, Z);
                    l = &nod2;
                    /* fall thru */
                case WADDR:
                case WCONST:
                    biggen(l, r, Z, 0, sub10, args);
                    break;
                }
                if(li == WHARD)
                    regfree(l);
            }
            else {
                switch(li) {
                case WNONE:
                    diag(l, "bad whatof\n");
                    break;
                case WCONST:
                    biggen(r, l, Z, 0, optab[B0c], args);
                    break;
                case WHARD:
                    reglcgen(&nod2, l, Z);
                    l = &nod2;
                    /* fall thru */
                case WADDR:
                    biggen(r, l, Z, 0, binoptmp, args);
                    if(li == WHARD)
                        regfree(l);
                    break;
                }
            }
            break;
        case IMM(1, 1):
            switch(WW(li, ri)) {
            case WW(WCONST, WHARD):
                if(r->op == ONAME && n->op == OAND && reduxv(l))
                    ri = WADDR;
                break;
            case WW(WHARD, WCONST):
                if(l->op == ONAME && n->op == OAND && reduxv(r))
                    li = WADDR;
                break;
            }
            if(li == WHARD) {
                reglcgen(&nod3, l, Z);
                l = &nod3;
            }
            if(ri == WHARD) {
                reglcgen(&nod2, r, Z);
                r = &nod2;
            }
            d = regpair(nn, n);
            instpair(d, Z);
            switch(WW(li, ri)) {
            case WW(WCONST, WADDR):
            case WW(WCONST, WHARD):
                biggen(l, r, d, 0, optab[Bca], args);
                break;

            case WW(WADDR, WCONST):
            case WW(WHARD, WCONST):
                biggen(l, r, d, 0, optab[Bac], args);
                break;

            case WW(WADDR, WADDR):
            case WW(WADDR, WHARD):
            case WW(WHARD, WADDR):
            case WW(WHARD, WHARD):
                biggen(l, r, d, 0, binop11, args);
                break;

            default:
                diag(r, "bad whatof pair %d %d\n", li, ri);
                break;
            }
            if(li == WHARD)
                regfree(l);
            if(ri == WHARD)
                regfree(r);
            break;
        }

        nn->type = dt;

        if(d != Z)
            goto finished;

        switch(lri) {
        case IMM(0, 0):
            freepair(r);
            /* fall thru */;
        case IMM(0, 1):
            if(!dr)
                storepair(l, nn, 1);
            break;
        case IMM(1, 0):
            if(!dr)
                storepair(r, nn, 1);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    shift:
        c = Z;

        /* evaluate hard subexps, stealing nn if possible. */
        /* must also secure CX.  not as many optims as binop. */
        switch(lri) {
        case IMM(0, 0):
        imm00:
            if(l->complex + 1 > r->complex) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
                t = &nod1;
                c = snarfreg(l, t, D_CX, r, &nod2);
                cgen(r, t);
                r = t;
            }
            else {
                t = &nod1;
                c = snarfreg(nn, t, D_CX, r, &nod2);
                cgen(r, t);
                r = t;
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(0, 1):
        imm01:
            if(ri != WCONST) {
                lri = IMM(0, 0);
                goto imm00;
            }
            if(dr)
                t = nn;
            else
                t = regpair(Z, n);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 0):
        imm10:
            if(li != WCONST) {
                lri = IMM(0, 0);
                goto imm00;
            }
            t = &nod1;
            c = snarfreg(nn, t, D_CX, r, &nod2);
            cgen(r, t);
            r = t;
            break;
        case IMM(1, 1):
            if(ri != WCONST) {
                lri = IMM(1, 0);
                goto imm10;
            }
            if(li == WHARD) {
                lri = IMM(0, 1);
                goto imm01;
            }
            break;
        }

        d = Z;

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, 0, optab[S00], args);
            break;
        case IMM(0, 1):
            switch(ri) {
            case WNONE:
            case WADDR:
            case WHARD:
                diag(r, "bad whatof\n");
                break;
            case WCONST:
                m = r->vconst & 63;
                s = nodconst(m);
                if(m < 32)
                    cp = optab[Sc0];
                else if(m == 32)
                    cp = optab[Sc1];
                else
                    cp = optab[Sc2];
                biggen(l, s, Z, 0, cp, args);
                break;
            }
            break;
        case IMM(1, 0):
            /* left is const */
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, r, d, 0, optab[S10], args);
            regfree(r);
            break;
        case IMM(1, 1):
            d = regpair(nn, n);
            instpair(d, Z);
            switch(WW(li, ri)) {
            case WW(WADDR, WCONST):
                m = r->vconst & 63;
                s = nodconst(m);
                if(m < 32) {
                    loadpair(l, d);
                    l = d;
                    cp = optab[Sc0];
                }
                else if(m == 32)
                    cp = optab[Sac3];
                else
                    cp = optab[Sac4];
                biggen(l, s, d, 0, cp, args);
                break;

            default:
                diag(r, "bad whatof pair %d %d\n", li, ri);
                break;
            }
            break;
        }

        if(c != Z) {
            gins(AMOVL, c, r);
            regfree(c);
        }

        if(d != Z)
            goto finished;

        switch(lri) {
        case IMM(0, 0):
            regfree(r);
            /* fall thru */
        case IMM(0, 1):
            if(!dr)
                storepair(l, nn, 1);
            break;
        case IMM(1, 0):
            regfree(r);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    cmp:
        op = n->op;
        /* evaluate hard subexps */
        switch(lri) {
        case IMM(0, 0):
            if(l->complex > r->complex) {
                t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
                t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
            }
            else {
                t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                t = regpair(Z, l);
                sugen(l, t, 8);
                l = t;
            }
            break;
        case IMM(1, 0):
            t = r;
            r = l;
            l = t;
            ri = li;
            op = invrel[relindex(op)];
            /* fall thru */
        case IMM(0, 1):
            t = regpair(Z, l);
            sugen(l, t, 8);
            l = t;
            break;
        case IMM(1, 1):
            break;
        }

        true = 1;
        optab = cmptab;
        switch(op) {
        case OEQ:
            optab = NEtab;
            true = 0;
            break;
        case ONE:
            optab = NEtab;
            break;
        case OLE:
            args = GTargs;
            true = 0;
            break;
        case OGT:
            args = GTargs;
            break;
        case OLS:
            args = HIargs;
            true = 0;
            break;
        case OHI:
            args = HIargs;
            break;
        case OLT:
            args = GEargs;
            true = 0;
            break;
        case OGE:
            args = GEargs;
            break;
        case OLO:
            args = HSargs;
            true = 0;
            break;
        case OHS:
            args = HSargs;
            break;
        default:
            diag(n, "bad cmp\n");
            SET(optab);
        }

        switch(lri) {
        case IMM(0, 0):
            biggen(l, r, Z, true, optab[T0i], args);
            break;
        case IMM(0, 1):
        case IMM(1, 0):
            switch(ri) {
            case WNONE:
                diag(l, "bad whatof\n");
                break;
            case WCONST:
                biggen(l, r, Z, true, optab[T0i], args);
                break;
            case WHARD:
                reglcgen(&nod2, r, Z);
                r = &nod2;
                /* fall thru */
            case WADDR:
                biggen(l, r, Z, true, optab[T0i], args);
                if(ri == WHARD)
                    regfree(r);
                break;
            }
            break;
        case IMM(1, 1):
            if(li == WHARD) {
                reglcgen(&nod3, l, Z);
                l = &nod3;
            }
            if(ri == WHARD) {
                reglcgen(&nod2, r, Z);
                r = &nod2;
            }
            biggen(l, r, Z, true, optab[Tii], args);
            if(li == WHARD)
                regfree(l);
            if(ri == WHARD)
                regfree(r);
            break;
        }

        switch(lri) {
        case IMM(0, 0):
            freepair(r);
            /* fall thru */;
        case IMM(0, 1):
        case IMM(1, 0):
            freepair(l);
            break;
        case IMM(1, 1):
            break;
        }
        return 1;

    case OASMUL:
    case OASLMUL:
        m = 0;
        goto mulop;

    case OMUL:
    case OLMUL:
        m = 1;
        goto mulop;

    mulop:
        dr = nn != Z && nn->op == OREGPAIR;
        l = vfunc(n->left, nn);
        r = vfunc(n->right, nn);
        if(r->op != OCONST) {
            if(l->complex > r->complex) {
                if(m) {
                    t = l;
                    l = r;
                    r = t;
                }
                else if(!vaddr(l, 1)) {
                    reglcgen(&nod5, l, Z);
                    l = &nod5;
                    evacaxdx(l);
                }
            }
            t = regpair(Z, n);
            sugen(r, t, 8);
            r = t;
            evacaxdx(r->left);
            evacaxdx(r->right);
            if(l->complex <= r->complex && !m && !vaddr(l, 1)) {
                reglcgen(&nod5, l, Z);
                l = &nod5;
                evacaxdx(l);
            }
        }
        if(dr)
            t = nn;
        else
            t = regpair(Z, n);
        //print("dr=%d ", dr); prtree(t, "t");
        c = Z;
        d = Z;
        if(!nodreg(&nod1, t->left, D_AX)) {
            if(t->left->reg != D_AX){
                t->left->reg = D_AX;
                reg[D_AX]++;
            }else if(reg[D_AX] == 0)
                fatal(Z, "vlong mul AX botch");
        }
        if(!nodreg(&nod2, t->right, D_DX)) {
            if(t->right->reg != D_DX){
                t->right->reg = D_DX;
                reg[D_DX]++;
            }else if(reg[D_DX] == 0)
                fatal(Z, "vlong mul DX botch");
        }
        //prtree(t, "t1"); print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(m)
            sugen(l, t, 8);
        else
            loadpair(l, t);
        //prtree(t, "t2"); print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(t->left->reg != D_AX) {
            c = &nod3;
            regsalloc(c, t->left);
            gmove(&nod1, c);
            gmove(t->left, &nod1);
            zapreg(t->left);
        }
        //print("reg/ax = %d reg/dx = %d\n", reg[D_AX], reg[D_DX]);
        if(t->right->reg != D_DX) {
            d = &nod4;
            regsalloc(d, t->right);
            gmove(&nod2, d);
            if(t->right->reg == D_AX && c != nil){
                /* need previous value of AX in DX */
                gmove(c, &nod2);
            }else
                gmove(t->right, &nod2);
            zapreg(t->right);
        }
        if(c != Z || d != Z) {
            s = regpair(Z, n);
            s->left = &nod1;
            s->right = &nod2;
        }
        else
            s = t;
        reg[D_AX]++;	/* don't allow biggen to allocate AX or DX (smashed by MUL) as temp */
        reg[D_DX]++;
        if(r->op == OCONST) {
            if(hi64v(r) == 0)
                biggen(s, r, Z, 0, mulc32, nil);
            else
                biggen(s, r, Z, 0, mulc64, nil);
        }
        else
            biggen(s, r, Z, 0, mull, nil);
        instpair(t, Z);
        reg[D_AX]--;
        reg[D_DX]--;
        if(c != Z) {
            gmove(&nod1, t->left);
            gmove(&nod3, &nod1);
        }
        if(d != Z) {
            gmove(&nod2, t->right);
            gmove(&nod4, &nod2);
        }

        if(r->op == OREGPAIR)
            freepair(r);
        if(!m)
            storepair(t, l, 0);
        if(l == &nod5)
            regfree(l);

        if(!dr) {
            if(nn != Z)
                storepair(t, nn, 1);
            else
                freepair(t);
        }
        return 1;

    case OASADD:
        args = ADDargs;
        goto vasop;
    case OASAND:
        args = ANDargs;
        goto vasop;
    case OASOR:
        args = ORargs;
        goto vasop;
    case OASSUB:
        args = SUBargs;
        goto vasop;
    case OASXOR:
        args = XORargs;
        goto vasop;

    vasop:
        l = n->left;
        r = n->right;
        dr = nn != Z && nn->op == OREGPAIR;
        m = 0;
        if(l->complex > r->complex) {
            if(!vaddr(l, 1)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
            if(!vaddr(r, 1) || nn != Z || r->op == OCONST) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                m = 1;
            }
        }
        else {
            if(!vaddr(r, 1) || nn != Z || r->op == OCONST) {
                if(dr)
                    t = nn;
                else
                    t = regpair(Z, r);
                sugen(r, t, 8);
                r = t;
                m = 1;
            }
            if(!vaddr(l, 1)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
        }
        if(nn != Z) {
            if(n->op == OASSUB)
                biggen(l, r, Z, 0, sub10, args);
            else
                biggen(r, l, Z, 0, binoptmp, args);
            storepair(r, l, 0);
        }
        else {
            if(m)
                biggen(l, r, Z, 0, binop00, args);
            else
                biggen(l, r, Z, 0, binoptmp, args);
        }
        if(l == &nod1)
            regfree(&nod1);
        if(m) {
            if(nn == Z)
                freepair(r);
            else if(!dr)
                storepair(r, nn, 1);
        }
        return 1;

    case OASASHL:
        args = nil;
        optab = asshlltab;
        goto assh;
    case OASLSHR:
        args = shrlargs;
        optab = asshrltab;
        goto assh;
    case OASASHR:
        args = sarlargs;
        optab = asshrltab;
        goto assh;

    assh:
        c = Z;
        l = n->left;
        r = n->right;
        if(r->op == OCONST) {
            m = r->vconst & 63;
            if(m < 32)
                m = SAclo;
            else if(m == 32)
                m = SAc32;
            else
                m = SAchi;
        }
        else
            m = SAgen;
        if(l->complex > r->complex) {
            if(!vaddr(l, 0)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
            if(m == SAgen) {
                t = &nod2;
                if(l->reg == D_CX) {
                    regalloc(t, r, Z);
                    gmove(l, t);
                    l->reg = t->reg;
                    t->reg = D_CX;
                }
                else
                    c = snarfreg(nn, t, D_CX, r, &nod3);
                cgen(r, t);
                r = t;
            }
        }
        else {
            if(m == SAgen) {
                t = &nod2;
                c = snarfreg(nn, t, D_CX, r, &nod3);
                cgen(r, t);
                r = t;
            }
            if(!vaddr(l, 0)) {
                reglcgen(&nod1, l, Z);
                l = &nod1;
            }
        }

        if(nn != Z) {
            m += SAdgen - SAgen;
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, r, d, 0, optab[m], args);
            if(l == &nod1) {
                regfree(&nod1);
                l = Z;
            }
            if(r == &nod2 && c == Z) {
                regfree(&nod2);
                r = Z;
            }
            if(d != nn)
                storepair(d, nn, 1);
        }
        else
            biggen(l, r, Z, 0, optab[m], args);

        if(c != Z) {
            gins(AMOVL, c, r);
            regfree(c);
        }
        if(l == &nod1)
            regfree(&nod1);
        if(r == &nod2)
            regfree(&nod2);
        return 1;

    case OPOSTINC:
        args = ADDargs;
        cp = incdecpost;
        goto vinc;
    case OPOSTDEC:
        args = SUBargs;
        cp = incdecpost;
        goto vinc;
    case OPREINC:
        args = ADDargs;
        cp = incdecpre;
        goto vinc;
    case OPREDEC:
        args = SUBargs;
        cp = incdecpre;
        goto vinc;

    vinc:
        l = n->left;
        if(!vaddr(l, 1)) {
            reglcgen(&nod1, l, Z);
            l = &nod1;
        }
        
        if(nn != Z) {
            d = regpair(nn, n);
            instpair(d, Z);
            biggen(l, Z, d, 0, cp, args);
            if(l == &nod1) {
                regfree(&nod1);
                l = Z;
            }
            if(d != nn)
                storepair(d, nn, 1);
        }
        else
            biggen(l, Z, Z, 0, incdec, args);

        if(l == &nod1)
            regfree(&nod1);
        return 1;

    case OCAST:
        l = n->left;
        if(typev[l->type->etype]) {
            if(!vaddr(l, 1)) {
                if(l->complex + 1 > nn->complex) {
                    d = regpair(Z, l);
                    sugen(l, d, 8);
                    if(!vaddr(nn, 1)) {
                        reglcgen(&nod1, nn, Z);
                        r = &nod1;
                    }
                    else
                        r = nn;
                }
                else {
                    if(!vaddr(nn, 1)) {
                        reglcgen(&nod1, nn, Z);
                        r = &nod1;
                    }
                    else
                        r = nn;
                    d = regpair(Z, l);
                    sugen(l, d, 8);
                }
//				d->left->type = r->type;
                d->left->type = types[TLONG];
                gmove(d->left, r);
                freepair(d);
            }
            else {
                if(nn->op != OREGISTER && !vaddr(nn, 1)) {
                    reglcgen(&nod1, nn, Z);
                    r = &nod1;
                }
                else
                    r = nn;
//				l->type = r->type;
                l->type = types[TLONG];
                gmove(l, r);
            }
            if(r != nn)
                regfree(r);
        }
        else {
            if(typeu[l->type->etype] || cond(l->op))
                si = TUNSIGNED;
            else
                si = TSIGNED;
            regalloc(&nod1, l, Z);
            cgen(l, &nod1);
            if(nn->op == OREGPAIR) {
                m = instpair(nn, &nod1);
                biggen(&nod1, Z, nn, si == TSIGNED, castrp, nil);
            }
            else {
                m = 0;
                if(!vaddr(nn, si != TSIGNED)) {
                    dt = nn->type;
                    nn->type = types[TLONG];
                    reglcgen(&nod2, nn, Z);
                    nn->type = dt;
                    nn = &nod2;
                }
                dt = nn->type;
                nn->type = types[TLONG];
                biggen(&nod1, Z, nn, si == TSIGNED, castrpa, nil);
                nn->type = dt;
                if(nn == &nod2)
                    regfree(&nod2);
            }
            if(!m)
                regfree(&nod1);
        }
        return 1;

    default:
        if(n->op == OREGPAIR) {
            storepair(n, nn, 1);
            return 1;
        }
        if(nn->op == OREGPAIR) {
            loadpair(n, nn);
            return 1;
        }
        return 0;
    }
finished:
    if(d != nn)
        storepair(d, nn, 1);
    return 1;
}
@

<<function testv>>=
void
testv(Node *n, int true)
{
    Type *t;
    Node *nn, nod, *b;

    if(machcap(Z)) {
        b = &nod;
        b->op = true ? ONE : OEQ;
        b->left = n;
        b->right = new(0, Z, Z);
        *b->right = *nodconst(0);
        b->right->type = n->type;
        b->type = types[TLONG];
        cgen64(b, Z);
        return;
    }

    switch(n->op) {
    case OINDREG:
    case ONAME:
        biggen(n, Z, Z, true, testi, nil);
        break;

    default:
        n = vfunc(n, n);
        if(n->addable >= INDEXED) {
            t = n->type;
            n->type = types[TLONG];
            reglcgen(&nod, n, Z);
            n->type = t;
            n = &nod;
            biggen(n, Z, Z, true, testi, nil);
            if(n == &nod)
                regfree(n);
        }
        else {
            nn = regpair(Z, n);
            sugen(n, nn, 8);
            biggen(nn, Z, Z, true, testi, nil);
            freepair(nn);
        }
    }
}
@


\section{Endianness}
% 8c -l, just for mips => switch from vc to 0c


\section{Processing multiple files}

\chapter{Conclusion}

\appendix

\chapter{Debugging}

<<global debug>>=
char	debug[256];
@

\section{[[Fmt]]}

\subsection{[[cc/]]}

<<[[cinit()]] fmtinstall>>=
fmtinstall('O', Oconv);
fmtinstall('T', Tconv);
fmtinstall('F', FNconv);
fmtinstall('L', Lconv);
fmtinstall('Q', Qconv);
fmtinstall('|', VBconv);
@

<<function Oconv>>=
// enum<node_kind> -> string
int Oconv(Fmt *fp)
{
    int a;

    a = va_arg(fp->args, int);
    if(a < OXXX || a > OEND)
        return fmtprint(fp, "***badO %d***", a);

    return fmtstrcpy(fp, onames[a]);
}
@

<<global onames>>=
char*	onames[OEND+1];
@

<<global onamesinit>>=
Init	onamesinit[] =
{
    OXXX,		0,	"OXXX",
    OADD,		0,	"ADD",
    OADDR,		0,	"ADDR",
    OAND,		0,	"AND",
    OANDAND,	0,	"ANDAND",
    OARRAY,		0,	"ARRAY",
    OAS,		0,	"AS",
    OASI,		0,	"ASI",
    OASADD,		0,	"ASADD",
    OASAND,		0,	"ASAND",
    OASASHL,	0,	"ASASHL",
    OASASHR,	0,	"ASASHR",
    OASDIV,		0,	"ASDIV",
    OASHL,		0,	"ASHL",
    OASHR,		0,	"ASHR",
    OASLDIV,	0,	"ASLDIV",
    OASLMOD,	0,	"ASLMOD",
    OASLMUL,	0,	"ASLMUL",
    OASLSHR,	0,	"ASLSHR",
    OASMOD,		0,	"ASMOD",
    OASMUL,		0,	"ASMUL",
    OASOR,		0,	"ASOR",
    OASSUB,		0,	"ASSUB",
    OASXOR,		0,	"ASXOR",
    OBIT,		0,	"BIT",
    OBREAK,		0,	"BREAK",
    OCASE,		0,	"CASE",
    OCAST,		0,	"CAST",
    OCOMMA,		0,	"COMMA",
    OCOND,		0,	"COND",
    OCONST,		0,	"CONST",
    OCONTINUE,	0,	"CONTINUE",
    ODIV,		0,	"DIV",
    ODOT,		0,	"DOT",
    ODOTDOT,	0,	"DOTDOT",
    ODWHILE,	0,	"DWHILE",
    OENUM,		0,	"ENUM",
    OEQ,		0,	"EQ",
    OFOR,		0,	"FOR",
    OFUNC,		0,	"FUNC",
    OGE,		0,	"GE",
    OGOTO,		0,	"GOTO",
    OGT,		0,	"GT",
    OHI,		0,	"HI",
    OHS,		0,	"HS",
    OIF,		0,	"IF",
    OIND,		0,	"IND",
    OINDREG,	0,	"INDREG",
    OINIT,		0,	"INIT",
    OLABEL,		0,	"LABEL",
    OLDIV,		0,	"LDIV",
    OLE,		0,	"LE",
    OLIST,		0,	"LIST",
    OLMOD,		0,	"LMOD",
    OLMUL,		0,	"LMUL",
    OLO,		0,	"LO",
    OLS,		0,	"LS",
    OLSHR,		0,	"LSHR",
    OLT,		0,	"LT",
    OMOD,		0,	"MOD",
    OMUL,		0,	"MUL",
    ONAME,		0,	"NAME",
    ONE,		0,	"NE",
    ONOT,		0,	"NOT",
    OOR,		0,	"OR",
    OOROR,		0,	"OROR",
    OPOSTDEC,	0,	"POSTDEC",
    OPOSTINC,	0,	"POSTINC",
    OPREDEC,	0,	"PREDEC",
    OPREINC,	0,	"PREINC",
    OPROTO,		0,	"PROTO",
    OREGISTER,	0,	"REGISTER",
    ORETURN,	0,	"RETURN",
    OSET,		0,	"SET",
    OSIGN,		0,	"SIGN",
    OSIZE,		0,	"SIZE",
    OSTRING,	0,	"STRING",
    OLSTRING,	0,	"LSTRING",
    OSTRUCT,	0,	"STRUCT",
    OSUB,		0,	"SUB",
    OSWITCH,	0,	"SWITCH",
    OUNION,		0,	"UNION",
    OUSED,		0,	"USED",
    OWHILE,		0,	"WHILE",
    OXOR,		0,	"XOR",
    OPOS,		0,	"POS",
    ONEG,		0,	"NEG",
    OCOM,		0,	"COM",
    OELEM,		0,	"ELEM",
    OTST,		0,	"TST",
    OINDEX,		0,	"INDEX",
    OFAS,		0,	"FAS",
    OREGPAIR,	0,	"REGPAIR",
    OEXREG,		0,	"EXREG",
    OEND,		0,	"END",
    -1,		0,	0,
};
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<struct Atab>>=
struct Atab
    {
        Hist*	incl;	/* start of this include file */
        long	idel;	/* delta line number to apply to include */
        Hist*	line;	/* start of this #line directive */
        long	ldel;	/* delta line number to apply to #line */
};
@

% location?
<<function Lconv>>=
// int -> string?
int
Lconv(Fmt *fp)
{
    char str[STRINGSZ], s[STRINGSZ];
    Hist *h;
    long l, d;
    int i, n;
    struct Atab  a[HISTSZ];

    l = va_arg(fp->args, long);
    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset != 0) {		/* #line directive, not #pragma */
                if(n > 0 && n < HISTSZ && h->offset >= 0) {
                    a[n-1].line = h;
                    a[n-1].ldel = h->line - h->offset + 1;
                }
            } else {
                if(n < HISTSZ) {	/* beginning of file */
                    a[n].incl = h;
                    a[n].idel = h->line;
                    a[n].line = 0;
                }
                n++;
            }
            continue;
        }
        n--;
        if(n > 0 && n < HISTSZ) {
            d = h->line - a[n].incl->line;
            a[n-1].ldel += d;
            a[n-1].idel += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    str[0] = 0;
    for(i=n-1; i>=0; i--) {
        if(i != n-1) {
            if(fp->flags & ~(FmtWidth|FmtPrec))	/* BUG ROB - was f3 */
                break;
            strcat(str, " ");
        }
        if(a[i].line)
            snprint(s, STRINGSZ, "%s:%ld[%s:%ld]",
                a[i].line->name, l-a[i].ldel+1,
                a[i].incl->name, l-a[i].idel+1);
        else
            snprint(s, STRINGSZ, "%s:%ld",
                a[i].incl->name, l-a[i].idel+1);
        if(strlen(s)+strlen(str) >= STRINGSZ-10)
            break;
        strcat(str, s);
        l = a[i].incl->line - 1;	/* now print out start of this file */
    }
    if(n == 0)
        strcat(str, "<eof>");
    return fmtstrcpy(fp, str);
}
@

<<function Tconv>>=
// option<Type> -> string
int
Tconv(Fmt *fp)
{
    char str[STRINGSZ+20], s[STRINGSZ+20];
    Type *t, *t1;
    int et;
    long n;

    str[0] = 0;
    for(t = va_arg(fp->args, Type*); t != T; t = t->link) {
        et = t->etype;
        if(str[0])
            strcat(str, " ");
        if(t->garb&~GINCOMPLETE) {
            sprint(s, "%s ", gnames[t->garb&~GINCOMPLETE]);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        sprint(s, "%s", tnames[et]);
        if(strlen(str) + strlen(s) < STRINGSZ)
            strcat(str, s);
        if(et == TFUNC && (t1 = t->down)) {
            sprint(s, "(%T", t1);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
            while(t1 = t1->down) {
                sprint(s, ", %T", t1);
                if(strlen(str) + strlen(s) < STRINGSZ)
                    strcat(str, s);
            }
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, ")");
        }
        if(et == TARRAY) {
            n = t->width;
            if(t->link && t->link->width)
                n /= t->link->width;
            sprint(s, "[%ld]", n);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(t->nbits) {
            sprint(s, " %d:%d", t->shift, t->nbits);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(typesu[et]) {
            if(t->tag) {
                strcat(str, " ");
                if(strlen(str) + strlen(t->tag->name) < STRINGSZ)
                    strcat(str, t->tag->name);
            } else
                strcat(str, " {}");
            break;
        }
    }
    return fmtstrcpy(fp, str);
}
@

<<global tnames>>=
char*	tnames[NALLTYPES];
@

<<global tnamesinit>>=
Init	tnamesinit[] =
{
    TXXX,		0,	"TXXX",

    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,	0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,	0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,	0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,	0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",
    TFILE,		0,	"FILE",
    TOLD,		0,	"OLD",
    TDOT,		0,	"DOT",

    -1,		0,	0,
};
@



<<function FNconv>>=
// option<Node identifier cases> -> string
int
FNconv(Fmt *fp)
{
    char *str;
    Node *n;

    n = va_arg(fp->args, Node*);
    str = "<indirect>";
    if(n != Z && (n->op == ONAME || n->op == ODOT || n->op == OELEM))
        str = n->sym->name;
    return fmtstrcpy(fp, str);
}
@

<<function Qconv>>=
// ??
int
Qconv(Fmt *fp)
{
    char str[STRINGSZ+20], *s;
    long b;
    int i;

    str[0] = 0;
    for(b = va_arg(fp->args, long); b;) {
        i = bitno(b);
        if(str[0])
            strcat(str, " ");
        s = qnames[i];
        if(strlen(str) + strlen(s) >= STRINGSZ)
            break;
        strcat(str, s);
        b &= ~(1L << i);
    }
    return fmtstrcpy(fp, str);
}
@

<<function VBconv>>=
// ??
int
VBconv(Fmt *fp)
{
    char str[STRINGSZ];
    int i, n, t, pc;

    n = va_arg(fp->args, int);
    pc = 0;	/* BUG: was printcol */
    i = 0;
    while(pc < n) {
        t = (pc+4) & ~3;
        if(t <= n) {
            str[i++] = '\t';
            pc = t;
            continue;
        }
        str[i++] = ' ';
        pc++;
    }
    str[i] = '\0';

    return fmtstrcpy(fp, str);
}
@

\subsection{[[8c/]]}

% similar to Assembler.tex.nw?

<<function listinit>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('B', Bconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('D', Dconv);
    fmtinstall('R', Rconv);
}
@

<<function Bconv>>=
// Bits -> string
int
Bconv(Fmt *fp)
{
    char str[STRINGSZ], ss[STRINGSZ], *s;
    Bits bits;
    int i;

    str[0] = 0;
    bits = va_arg(fp->args, Bits);
    while(bany(&bits)) {
        i = bnum(bits);
        if(str[0])
            strcat(str, " ");
        if(var[i].sym == S) {
            snprint(ss, sizeof(ss), "$%ld", var[i].offset); //$
            s = ss;
        } else
            s = var[i].sym->name;
        if(strlen(str) + strlen(s) + 1 >= STRINGSZ)
            break;
        strcat(str, s);
        bits.b[i/32] &= ~(1L << (i%32));
    }
    return fmtstrcpy(fp, str);
}
@
% >>

% for assembly generation?
<<function Pconv>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    if(p->as == ADATA)
        snprint(str, sizeof(str), "	%A	%D/%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else if(p->as == ATEXT)
        snprint(str, sizeof(str), "	%A	%D,%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else
        snprint(str, sizeof(str), "	%A	%D,%D",
            p->as, &p->from, &p->to);
    return fmtstrcpy(fp, str);
}
@
% why not switch?

<<function Aconv>>=
// enum<opcode_kind> -> string
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@
% anames in Assembly section

<<function Dconv>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[40], s[20];
    Adr *a;
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;
    if(i >= D_INDIR) {
        if(a->offset)
            snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
        else
            snprint(str, sizeof(str), "(%R)", i-D_INDIR);
        goto brk;
    }
    switch(i) {

    default:
        if(a->offset)
            snprint(str, sizeof(str), "$%ld,%R", a->offset, i); // $
        else
            snprint(str, sizeof(str), "%R", i);
        break;

    case D_NONE:
        str[0] = '\0';
        break;

    case D_BRANCH:
        snprint(str, sizeof(str), "%ld(PC)", a->offset-pc);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<>+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;

    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;


    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset); //$
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$(%.17e)", a->dval); //$
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->sval); //$
        break;


    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a); //$
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;
    }
brk:
    if(a->index != D_NONE) {
        fmtstrcpy(fp, str);
        snprint(s, sizeof(s), "(%R*%d)", (int)a->index, (int)a->scale);
        return fmtstrcpy(fp, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@

<<global regstr>>=
char*	regstr[] =
{
    "AL",	/*[D_AL]*/	
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",	/*[D_AX]*/
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",	/*[D_F0]*/
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",	/*[D_CS]*/
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",	/*[D_GDTR]*/
    "IDTR",	/*[D_IDTR]*/
    "LDTR",	/*[D_LDTR]*/
    "MSW",	/*[D_MSW] */
    "TASK",	/*[D_TASK]*/

    "CR0",	/*[D_CR]*/
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",	/*[D_DR]*/
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",	/*[D_TR]*/
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",	/*[D_NONE]*/
};
@

<<function Rconv>>=
// enum<operand_kind(register-only)> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@

<<function Sconv>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@


\section{[[xxxnames]]}

% already seen onames before, anames, etc


<<global cnames>>=
char*	cnames[NCTYPES];
@

<<global cnamesinit>>=
Init	cnamesinit[] =
{
    CXXX,		0,	"CXXX",
    CAUTO,		0,	"AUTO",
    CEXTERN,		0,	"EXTERN",
    CGLOBL,		0,	"GLOBL",
    CSTATIC,		0,	"STATIC",
    CLOCAL,		0,	"LOCAL",
    CTYPEDEF,		0,	"TYPEDEF",
    CTYPESTR,		0,	"TYPESTR",
    CPARAM,		0,	"PARAM",
    CSELEM,		0,	"SELEM",
    CLABEL,		0,	"LABEL",
    CEXREG,		0,	"EXREG",
    -1,			0,	0,
};
@


<<global qnames>>=
char*	qnames[NALLTYPES];
@

<<global qnamesinit>>=
Init	qnamesinit[] =
{
    TXXX,		0,	"TXXX",

    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,		0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,		0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,		0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,		0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",

    TAUTO,		0,	"AUTO",
    TEXTERN,		0,	"EXTERN",
    TSTATIC,		0,	"STATIC",
    TTYPEDEF,		0,	"TYPEDEF",
    TTYPESTR,		0,	"TYPESTR",
    TREGISTER,		0,	"REGISTER",
    TCONSTNT,		0,	"CONSTNT",
    TVOLATILE,		0,	"VOLATILE",
    TUNSIGNED,		0,	"UNSIGNED",
    TSIGNED,		0,	"SIGNED",
    TDOT,		0,	"DOT",
    TFILE,		0,	"FILE",
    TOLD,		0,	"OLD",

    -1,		0,	0,
};
@




<<global gnames>>=
char*	gnames[NGTYPES];
@

<<global gnamesinit>>=
Init	gnamesinit[] =
{
    GXXX,		0,	"GXXX",
    GCONSTNT,		0,	"CONST",
    GVOLATILE,		0,	"VOLATILE",
    GVOLATILE|GCONSTNT,	0,	"CONST-VOLATILE",
    -1,			0,	0,
};
@

\section{AST dumper, [[prtree()]]}

<<function prtree>>=
void
prtree(Node *n, char *s)
{

    print(" == %s ==\n", s);
    prtree1(n, 0, false);
    print("\n");
}
@

<<function prtree1>>=
void
prtree1(Node *n, int d, bool f)
{
    int i;

    if(f)
      for(i=0; i<d; i++)
        print("   ");
    if(n == Z) {
        print("Z\n");
        return;
    }
    if(n->op == OLIST) {
        prtree1(n->left, d, false);
        prtree1(n->right, d, true);
        return;
    }
    d++;
    print("%O", n->op);
    i = 3; // 1 || 2

    switch(n->op) {
    case ONAME:
        print(" \"%F\"", n);
        print(" %ld", n->xoffset);
        i = 0;
        break;

    case OINDREG:
        print(" %ld(R%d)", n->xoffset, n->reg);
        i = 0;
        break;

    case OREGISTER:
        if(n->xoffset)
            print(" %ld+R%d", n->xoffset, n->reg);
        else
            print(" R%d", n->reg);
        i = 0;
        break;

    case OSTRING:
        print(" \"%s\"", n->cstring);
        i = 0;
        break;

    case OLSTRING:
        if(sizeof(TRune) == sizeof(Rune))
            print(" \"%S\"", (Rune*)n->rstring);
        else
            print(" \"...\"");
        i = 0;
        break;

    case ODOT:
    case OELEM:
        print(" \"%F\"", n);
        break;

    case OCONST:
        if(typefd[n->type->etype])
            print(" \"%.8e\"", n->fconst);
        else
            print(" \"%lld\"", n->vconst);
        i = 0;
        break;
    }
    if(n->addable != 0)
        print(" <%d>", n->addable);
    if(n->type != T)
        print(" %T", n->type);
    if(n->complex != 0)
        print(" (%d)", n->complex);

    print(" %L\n", n->lineno);

    if(i & 2)
        prtree1(n->left, d, true);
    if(i & 1)
        prtree1(n->right, d, true);
}
@


\section{[[8c -v]], verbose mode}

% see diag(), with -v it will print == diagnostic == and then the ast dump
% via prtree()

\section{[[8c -m]], macro debugging}

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[8c -f]], line information debugging}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(offset)
            print("%4ld: %s (#line %d)\n", lineno, f, offset);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

\section{[[8c -L]], printing names}

\section{[[8c -d]], printing declarations}
% useful to debug, potentially useful to build tools too! e.g. tags file

% labels
<<function dbgdecl>>=
void
dbgdecl(Sym *s)
{
    print("decl \"%s\": C=%s [B=%d:O=%ld] T=%T\n",
        s->name, cnames[s->class], s->block, s->offset, s->type);
}
@


\section{[[8c -t]], printing type trees}

\section{[[8c -i]], printing initializations}

\section{[[8c -m]], printing arithmetic trees}

\section{[[8c -r]], printing registerization}

\section{[[8c -g]], ???}
% for cgen, print lhs and rhs

\chapter{Error Managment}

<<global nerrors>>=
int	nerrors;
@

<<function errorexit>>=
void
errorexit(void)
{
    if(outfile)
        remove(outfile);
    exits("error");
}
@


<<function yyerror>>=
void
yyerror(char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(fmt, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", lineno, buf);
    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@


<<function diag>>=
void
diag(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
      if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@


\chapter{Libc}

\section{Memory managment}
% same in Linker/assembler, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<constant NHUNK>>=
#define	NHUNK		50000L
@

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk;
@

<<global thunk>>=
long	thunk;
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@

<<constant MAXALIGN>>=
#define	MAXALIGN	7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }
    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {
        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;
    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


<<function malloc>>=
/*
 * fake mallocs
 */
void*
malloc(ulong n)
{
    return alloc(n);
}
@

% hmm so no free ... maybe ok in a compiler context?
<<function free>>=
void
free(void*)
{
}
@

<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void*, ulong)
{
}
@


\section{String managment}

% STRINGSZ here

\section{Bit operations}

% see also Bits structure

<<function topbit>>=
int
topbit(ulong v)
{
    int i;

    for(i = -1; v; i++)
        v >>= 1;
    return i;
}
@

<<function bitno>>=
int
bitno(long b)
{
    int i;

    for(i=0; i<32; i++)
        if(b & (1L<<i))
            return i;
    diag(Z, "bad in bitno");
    return 0;
}
@
% >>

<<function SIGN>>=
#define	SIGN(n)		(1ULL<<(n-1))
@
% >>
<<function MASK>>=
#define	MASK(n)		(SIGN(n)|(SIGN(n)-1))
@

\section{Mathematic functions}

% use diag so could not really be put in libc
<<function round>>=
long
round(long v, int w)
{
    int r;

    if(w <= 0 || w > 8) {
        diag(Z, "rounding by %d", w);
        w = 1;
    }
    r = v%w;
    if(r)
        v += w-r;
    return v;
}
@



<<function log2>>=
/*
 * return log(n) if n is a power of 2 constant
 */
int
log2(uvlong v)
{
    int s, i;
    uvlong m;

    s = 0;
    m = MASK(8*sizeof(uvlong));
    for(i=32; i; i>>=1) {
        m >>= i;
        if(!(v & m)) {
            v >>= i;
            s += i;
        }
    }
    if(v == 1)
        return s;
    return -1;
}
@

\section{Key/value}

% mostly helper structure to build a  hash<enum<xxx>,string> to debug
%  enums values
% most of the time value is 0 and unused as people just want a int -> string
<<struct Init>>=
struct	Init			/* general purpose initialization */
{
    int		code;
    ulong	value;
    char*	s;
};
@

\section{Portability}

<<enum os>>=
enum os				/* also in ../{8a,0a}.h */
{
    Plan9	= 1<<0,
    Unix	= 1<<1,
    //Windows	= 1<<2,
};
@

\chapter{Extra Code}

\ifallcode
#include "Compiler_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
SUE = Structure/Union/Enum
SU  = Structure/Union
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
