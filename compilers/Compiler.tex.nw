\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   saw cc/pgen.c depends on gc.h! so not same category than cc/bits.c => cc2/
%   (harder to understand non layered code)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)
% - use scheck to remove deadcode useless export, or mv as forward decl
%   (harder to understand big interface files)
% - see duplication between cc.h and aa.h

%thx to this manual, better understand compilers:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - TODO distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog to see what flows into fields
% - TODO nullify, boolify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 C Compiler
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a C compiler.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present 8c, aka kencc, from ken thompson!

% some cons though: no IL ... very imperative ... harder case to defend
% than for the other software (8a, 8l, kernel, rio)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item tiger
% not real, not C, but more educatif and better written for teaching purpose
% (actually can refer to govereau book?)
\item lcc 
%maybe better actually, but already a book on it
% also use a grammar? or handwritten?
\item compcert
% harder to understand coq :)
\item tinycc, fbcc
\item gcc
%big
\item clang
%cleaner but still very big
% nice single binary that can cross compile for multiple targets, nice
% interface (cleaner than 8c, 5c, vc, etc, interfaces are better!)
\end{itemize}

% TODO bench 8c vs gcc and clang on benchmarks!

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

% ken :)
% mireille ducasse, marie jo pedrono
% Aho, appel

\chapter{Overview}

\section{Compiler principles}

% from high level to low level (asm). 
% expression like x+y*z decomposed into multi mov, add, etc. Fortran!
% same for data, complex decomposed into smaller bytes, with symbolic names
%  for subparts, e.g. fields.
% statements, more structured forms than jmp.
% types! type checking!

% innovation of C vs fortran/pascal/algol? simpler?

\section{[[8c]] services}

% see all the flags, put here main flags

\section{[[helloworld.c]]}

\section{Input C language}

% mostly ANSI C. a few extension
% see K&R book

\section{Output object format}

% assembly x86 object code. Not really machine code, and not asm
% (even though can get asm via 8c -S)

% put code for helloworld.c? (at least put an arithmetic expression?)

\section{x86}

\section{Code organization}

% use a lot 386/8.out.h
% and actually stuff defined in 8.out.h are used
% exclusively by 8c e.g. enum misc3 with REGRET, REGTMP, etc

% cc.h (vs gc.h (not garbage collector, g for? nongeneric? hmmm))
% no lex (handcrafted lex.c), yacc (cc.y, y.tab.h, y.tab.c)
%  (why no lex? to avoid bootstrapping issues?)
%  mac.c = macro (included cpp)
% globals.c, utils.c, compat.c

% sub.c = subroutines, helpers to build ast (and more?)

% bits.c, 
% pickle.c

% acid.c = debugger support

% dpchk.c? pragma related? dpchk? check something? directive pragma check?

% com.c = compile (not comment), com64 for 64 bits specific stuff
%  dcl.c = declaration
%  funct.c = function
%  swt.c = switch? (pswt = portable part of switch handling)
%   (but then why outcode, outhist is in this file? TODO move it elsewhere!)
%  scon.c =  ?

% -----------

% gc.h (g??)
% globals2.c
% list.c = fmt.c (TODO rename)
% machcap.c, omachcap.c = machine capability (attempt to have interface)

% txt.c?
% peep = peep optimizer?
% xxxgen = sgen? cgen? (pgen.c = portable part of gen? sgen? cgen?)
% mul.c, div.c
% reg.c = register?

\section{Architecture overview}

% see lex.c#main()! have command line flags in comment

% lexer -> preprocessor -> parser -> ast -> visit and gen
% with optimisations done?
% no IL? register allocator? peep optimizer?
% vs tiger book?


%###############################################################################

\chapter{Core Data Structures}

\section{AST}

% vs what I have in ast_c.ml?

\subsection{[[Node]]}
% = expr + stmt + decl?

% LP reorg, purely internal to cc, not marshalled, so safe (as opposed to 8a)
<<enum node_kind>>=
enum node_kind
{
    OXXX,

    OADD,
    OADDR,
    OAND,
    OANDAND,
    OARRAY,
    OAS,
    OASI,
    OASADD,
    OASAND,
    OASASHL,
    OASASHR,
    OASDIV,
    OASHL,
    OASHR,
    OASLDIV,
    OASLMOD,
    OASLMUL,
    OASLSHR,
    OASMOD,
    OASMUL,
    OASOR,
    OASSUB,
    OASXOR,
    OBIT,
    OBREAK,
    OCASE,
    OCAST,
    OCOMMA,
    OCOND,
    OCONST,
    OCONTINUE,
    ODIV,

    ODOT,

    ODOTDOT,
    ODWHILE,
    OENUM,
    OEQ,
    OFOR,
    OFUNC,
    OGE,
    OGOTO,
    OGT,
    OHI,
    OHS,
    OIF,
    OIND,
    OINDREG,
    OINIT,
    OLABEL,
    OLDIV,
    OLE,
    OLIST, // of stmts, labels, etc
    OLMOD,
    OLMUL,
    OLO,
    OLS,
    OLSHR,
    OLT,
    OMOD,
    OMUL,

    ONAME,

    ONE,
    ONOT,
    OOR,
    OOROR,
    OPOSTDEC,
    OPOSTINC,
    OPREDEC,
    OPREINC,
    OPROTO,
    OREGISTER,
    ORETURN,
    OSET,
    OSIGN,
    OSIZE,
    OSTRING,
    OLSTRING,
    OSTRUCT,
    OSUB,
    OSWITCH,
    OUNION,
    OUSED,
    OWHILE,
    OXOR,
    ONEG,
    OCOM,
    OPOS,

    OELEM,

    OTST,		/* used in some compilers */
    OINDEX,
    OFAS,
    OREGPAIR,
    OEXREG,

    OEND
};
@

% ONAME, ODOT, OELEM => use FNconv

% char -> byte? or actually char sometimes when use '+' ?
% hmm get some warnings though when do that, but maybe should fix those 
% warnings anyway
<<struct Node>>=
struct	Node
{
    // enum<node_kind>
    char	op;

    // option<ref_own<Node>>
    Node*	left;
    // option<ref_own<Node>>
    Node*	right;

    long	lineno;

    <<[[Node]] other fields>>
};
@
% left/right used for many things, for left/right branch in e.g.
% arithmetic trees (a+b), but also for linked list (e.g. OLIST) with
% double chaining

<<[[Node]] other fields>>=
void*	label;

long	pc;
int		reg;
long	xoffset;
double	fconst;		/* fp constant */
vlong	vconst;		/* non fp const */
char*	cstring;	/* character string */
TRune*	rstring;	/* rune string */

Sym*	sym;
char	oldop;
char	class;
char	etype;

// (ab)used as bool for marker of label def (true) vs use (false),
// FNX special value, register allocation value, etc
char	complex; 
// (ab)used as bool for marker of use of label, special 10, 11, 20 values
char	addable;

char	scale;
char	garb;
@


<<constant Z>>=
#define	Z	((Node*)nil)
@


% int -> char ... for op, hmmm
<<function new>>=
Node*
new(int t, Node *l, Node *r)
{
    Node *n;

    n = alloc(sizeof(Node));
    n->op = t;
    n->left = l;
    n->right = r;

    if(l && t != OGOTO)
        n->lineno = l->lineno;
    else if(r)
        n->lineno = r->lineno;
    else
        n->lineno = lineno;

    newflag = true;
    return n;
}
@

<<global lineno>>=
long	lineno;
@


<<global nearln>>=
long	nearln;
@

<<function new1>>=
Node*
new1(int o, Node *l, Node *r)
{
    Node *n;

    n = new(o, l, r);
    n->lineno = nearln;
    return n;
}
@

\subsection{[[Type]]}

% split?
<<enum type_kind>>=
enum type_kind
{
    TXXX,

    TCHAR,
    TUCHAR,
    TSHORT,
    TUSHORT,
    TINT,
    TUINT,
    TLONG,
    TULONG,
    TVLONG,
    TUVLONG,
    TFLOAT,
    TDOUBLE,

    TIND,
    TFUNC,
    TARRAY,
    TVOID,
    TSTRUCT,
    TUNION,
    TENUM,

    TDOT,
    NTYPE,

    TAUTO	= NTYPE,

    TEXTERN,
    TSTATIC,
    TTYPEDEF,
    TTYPESTR,
    TREGISTER,
    TCONSTNT,
    TVOLATILE,
    TUNSIGNED,
    TSIGNED,

    TFILE,
    TOLD,

    NALLTYPES,

    /* adapt size of Rune to target system's size */
    TRUNE = sizeof(TRune)==4? TUINT: TUSHORT,
};
@

% char -> byte? but get some warnings (but we should fix that too)
<<struct Type>>=
struct	Type
{
    // enum<type_kind>
    char	etype;

    // ??
    Type*	link;
    // ??
    Type*	down;

    long	lineno;

    <<[[Type]] other fields>>
};
@

<<[[Type]] other fields>>=
Sym*	sym;

long	width;

long	offset;
schar	shift;
char	nbits;
char	garb;

Sym*	tag;
Funct*	funct;
@

<<constant T>>=
#define	T	((Type*)nil)
@

<<function typ>>=
Type*
typ(int et, Type *d)
{
    Type *t;

    t = alloc(sizeof(Type));
    t->etype = et;
    t->link = d;
    t->down = T;
    t->sym = S;
    t->width = ewidth[et];
    t->offset = 0;
    t->shift = 0;
    t->nbits = 0;
    t->garb = 0;
    return t;
}
@
% see Size section for ewidth, LP split!

<<function copytyp>>=
Type*
copytyp(Type *t)
{
    Type *nt;

    nt = typ(TXXX, T); // could just do alloc(sizeof(Type))
    *nt = *t;
    return nt;
}
@

\subsection{[[Decl]]}

<<enum dxxx>>=
enum dxxx
{
    DMARK,
    DAUTO,
    DSUE,
    DLABEL,
};
@

% for? 
% - labels
% locals? func?, params? typedefs? all entities?
<<struct Decl>>=
struct	Decl
{
    Sym*	sym;
    Type*	type;

    long	varlineno;

    // enum<dxxx>
    short	val;

    long	offset;
    ushort	block;
    char	class;
    char	aused;

    // Extra fields
    <<[[Decl]] extra fields>>
};
@

<<global dclstack>>=
// list<ref_own<Decl>> (next = Decl.link)
Decl*	dclstack;
@

<<[[Decl]] extra fields>>=
// list<ref_own<Decl> of dclstack
Decl*	link;
@

<<constant D>>=
#define	D	((Decl*)nil)
@

<<function push>>=
Decl*
push(void)
{
    Decl *d;

    d = alloc(sizeof(Decl));
    d->link = dclstack;
    dclstack = d;
    return d;
}
@


\section{[[Token]]}

% from cc.y
<<token declarations>>=
%token  <sym>   LNAME LTYPE
%token  <vval>  LCONST LLCONST LUCONST LULCONST LVLCONST LUVLCONST
%token  <dval>  LFCONST LDCONST
%token  <sval>  LSTRING LLSTRING
@

<<token declarations>>=
%token  LAUTO LBREAK LCASE LCHAR LCONTINUE LDEFAULT LDO
%token  LDOUBLE LELSE LEXTERN LFLOAT LFOR LGOTO
%token  LIF LINT LLONG LREGISTER LRETURN LSHORT LSIZEOF LUSED
%token  LSTATIC LSTRUCT LSWITCH LTYPEDEF LTYPESTR LUNION LUNSIGNED
%token  LWHILE LVOID LENUM LSIGNED LCONSTNT LVOLATILE LSET LSIGNOF
%token  LRESTRICT LINLINE
@

% LXXX  Lexer XXX? Lexeme XXX?
% so have LDOUBLE and TDOUBLE

<<union yacc>>=
%union  {
    Sym*    sym;
    vlong   vval;
    double  dval;
    struct
    {
        char*   s;
        long    l;
    } sval;

   <<[[union yacc]] other fields>>
}
@

% seems used by sub.c simpleg()
<<[[union yacc]] other fields>>=
long    lval;
@


\section{[[Sym]] and [[hash]]}
% Symbol table

% similar to Assembler. Diffs?
% another symbol table!

<<struct Sym>>=
struct	Sym
{
    // for? keywords? locals? parameters? struct/union? all names? fields?
    char	*name;

    <<[[Sym]] other fields>>

    Type*	type;
    Type*	suetag;
    Type*	tenum;

    char*	macro;

    long	varlineno;
    long	offset;
    vlong	vconst;
    double	fconst;


    ushort	lexical;
    ushort	block;
    ushort	sueblock;
    char	class;
    char	sym;
    char	aused;
    char	sig;

    // Extra
    <<[[Sym]] extra fields>>
};
@

<<constant NHASH>>=
#define	NHASH		1024
@

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@

<<constant S>>=
#define	S	((Sym*)nil)
@





<<constant NSYMB>>=
#define	NSYMB		1500
@

<<global symb>>=
char	symb[NSYMB];
@


<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    ulong h;
    char *p;
    int c, n;

    h = 0;
    for(p=symb; *p;) {
        h = h * 3;
        h += *p++;
    }
    n = (p - symb) + 1;
    if((long)h < 0)
        h = ~h;
    h %= NHASH;

    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(strcmp(s->name, symb) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(n);
    memmove(s->name, symb, n);

    strcpy(s->name, symb);
    s->link = hash[h];
    hash[h] = s;
    syminit(s);

    return s;
}
@



<<function syminit>>=
void
syminit(Sym *s)
{
    s->lexical = LNAME;
    s->block = 0;
    s->offset = 0;
    s->type = T;
    s->suetag = T;
    s->class = CXXX;
    s->aused = 0;
    s->sig = SIGNONE;
}
@

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@


\section{[[Prog]] and [[p]]}

% see also opcode and operand_kind in Assembler.tex.nw
% (and Aconv, Rconv, Dconv, ... in this file)

% see also enum misc3 of 8.out.h with REGARG, REGRET, REGSP, REGTMP

<<struct Prog>>=
struct	Prog
{
    // enum<opcode>
    short	as;

    Adr	from;
    Adr	to;

    long	lineno;

    // Extra
    <<[[Prog]] extra fields>>
};
@

<<[[Prog]] extra fields>>=
Prog*	link;
@

<<constant P>>=
#define	P	((Prog*)nil)
@


<<struct Adr>>=
struct	Adr
{
    long	offset;
    double	dval;
    char	sval[NSNAME];
    Sym*	sym;

    uchar	type;
    uchar	index;
    uchar	etype;
    uchar	scale;	/* doubles as width in DATA op */
};
@

<<constant A>>=
#define	A	((Adr*)nil)
@


<<global zprog>>=
Prog	zprog;
@


<<global pc>>=
long	pc;
@

<<global p>>=
Prog*	p;
@

<<global firstp>>=
Prog*	firstp;
@

<<global lastp>>=
Prog*	lastp;
@


<<function nextpc>>=
void
nextpc(void)
{

    p = alloc(sizeof(Prog));
    *p = zprog;
    p->lineno = nearln;
    pc++;

    if(firstp == P) {
        firstp = p;
        lastp = p;
        return;
    }
    lastp->link = p;
    lastp = p;
}
@

\chapter{[[main()]]}

<<global thechar>>=
int	thechar;
@

<<global thestring>>=
char*	thestring;
@



<<global outfile>>=
char*	outfile;
@


<<function main>>=
/*
 * known debug flags
 *	-a		acid declaration output
 *	-A		!B
 *	-B		non ANSI
 *	-d		print declarations
 *	-D name		define
 *	-F		format specification check
 *	-i		print initialization
 *	-I path		include
 *	-l		generate little-endian code
 *	-L		print every NAME symbol
 *	-M		constant multiplication
 *	-m		print add/sub/mul trees
 *	-n		print acid to file (%.c=%.acid) (with -a or -aa)
 *	-o file		output file
 *	-p		use standard cpp ANSI preprocessor (not on windows)
 *	-r		print registerization
 *	-s		print structure offsets (with -a or -aa)
 *	-S		print assembly
 *	-t		print type trees
 *	-V		enable void* conversion warnings
 *	-v		verbose printing
 *	-w		print warnings
 *	-X		abort on error
 *	-.		Inhibit search for includes in source directory
 */

//@Scheck: not dead, entry point :)
void main(int argc, char *argv[])
{
    char **defs, **np, *p;
    int nproc, nout, status, i, c, ndef, maxdef;

    memset(debug, 0, sizeof(debug));

    tinit();
    cinit();
    ginit();
    arginit();

    profileflg = true;	/* #pragma can turn it off */
    tufield = simplet((1L<<tfield->etype) | BUNSIGNED);
    maxdef = 0;
    ndef = 0;
    outfile = nil;
    defs = nil;
    setinclude(".");

    ARGBEGIN {
    case 'o':
        outfile = ARGF();
        break;

    case 'D':
        p = ARGF();
        if(p) {
            // realloc, growing array
            if(ndef >= maxdef){
                maxdef += 50;
                np = alloc(maxdef * sizeof *np);
                if(defs != nil)
                    memmove(np, defs, (maxdef - 50) * sizeof *np);
                defs = np;
            }
            defs[ndef++] = p;
            dodefine(p);
        }
        break;

    case 'I':
        p = ARGF();
        if(p)
            setinclude(p);
        break;

    case 'l':			/* for little-endian mips */
        if(thechar != 'v'){
            print("can only use -l with vc");
            errorexit();
        }
        thechar = '0';
        thestring = "spim";
        break;

    default:
        c = ARGC();
        if(c >= 0 && c < sizeof(debug))
            debug[c]++;
        break;


    } ARGEND

    if(argc < 1 && outfile == nil) {
        print("usage: %cc [-options] files\n", thechar);
        errorexit();
    }

    if(argc > 1) {
        nproc = 1;
        /*
         * if we're writing acid to standard output, don't compile
         * concurrently, to avoid interleaving output.
         */
        if(((!debug['a'] && !debug['Z']) || debug['n']) &&
            (p = getenv("NPROC")) != nil)
            nproc = atol(p);	/* */
        c = 0;
        nout = 0;
        for(;;) {
            while(nout < nproc && argc > 0) {
                i = myfork();
                if(i < 0) {
                    i = mywait(&status);
                    if(i < 0) {
                        print("cannot create a process\n");
                        errorexit();
                    }
                    if(status)
                        c++;
                    nout--;
                    continue;
                }
                if(i == 0) {
                    fprint(2, "%s:\n", *argv);
                    if (compile(*argv, defs, ndef))
                        errorexit();
                    exits(0);
                }
                nout++;
                argc--;
                argv++;
            }
            i = mywait(&status);
            if(i < 0) {
                if(c)
                    errorexit();
                exits(0);
            }
            if(status)
                c++;
            nout--;
        }
    }

    if(argc == 0)
        c = compile("stdin", defs, ndef);
    else
        c = compile(argv[0], defs, ndef);

    if(c)
        errorexit();
    exits(0);
}
@

<<function compile>>=
int
compile(char *file, char **defs, int ndef)
{
    char ofile[400], incfile[20];
    char *p, **av, opt[256];
    int i, c, fd[2];
    static int first = 1;

    strcpy(ofile, file);
    p = utfrrune(ofile, pathchar());
    if(p) {
        *p++ = 0;
        if(!debug['.'])
            include[0] = strdup(ofile);
    } else
        p = ofile;

    if(outfile == nil) {
        outfile = p;
        if(outfile) {
            if(p = utfrrune(outfile, '.'))
                if(p[1] == 'c' && p[2] == 0)
                    p[0] = 0;
            p = utfrune(outfile, 0);
            if(debug['a'] && debug['n'])
                strcat(p, ".acid");
            else if(debug['Z'] && debug['n'])
                strcat(p, "_pickle.c");
            else {
                p[0] = '.';
                p[1] = thechar;
                p[2] = 0;
            }
        } else
            outfile = "/dev/null";
    }

    if(p = getenv("INCLUDE")) {
        setinclude(p);
    } else {
        if(systemtype(Plan9)) {
            sprint(incfile, "/%s/include", thestring);
            setinclude(strdup(incfile));
            setinclude("/sys/include");
        }
    }
    if (first)
        Binit(&diagbuf, 1, OWRITE);
    /*
     * if we're writing acid to standard output, don't keep scratching
     * outbuf.
     */
    if((debug['a'] || debug['Z']) && !debug['n']) {
        if (first) {
            outfile = nil;
            Binit(&outbuf, dup(1, -1), OWRITE);
            dup(2, 1);
        }
    } else {
        c = mycreat(outfile, 0664);
        if(c < 0) {
            diag(Z, "cannot open %s - %r", outfile);
            outfile = nil;
            errorexit();
        }
        Binit(&outbuf, c, OWRITE);
    }
    newio();
    first = 0;

    /* Use an ANSI preprocessor */
    if(debug['p']) {
        if(myaccess(file) < 0) {
            diag(Z, "%s does not exist", file);
            errorexit();
        }
        if(mypipe(fd) < 0) {
            diag(Z, "pipe failed");
            errorexit();
        }
        switch(myfork()) {
        case -1:
            diag(Z, "fork failed");
            errorexit();
        case 0:
            close(fd[0]);
            mydup(fd[1], 1);
            close(fd[1]);
            av = alloc((3 + ndef + ninclude + 2) * sizeof *av);
            av[0] = CPP;
            i = 1;
            if(debug['.'])
                av[i++] = strdup("-.");
            /* 1999 ANSI C requires recognising // comments */
            av[i++] = strdup("-+");
            for(c = 0; c < ndef; c++) {
                sprint(opt, "-D%s", defs[c]);
                av[i++] = strdup(opt);
            }
            for(c = 0; c < ninclude; c++) {
                sprint(opt, "-I%s", include[c]);
                av[i++] = strdup(opt);
            }
            if(strcmp(file, "stdin") != 0)
                av[i++] = file;
            av[i] = 0;
            if(debug['p'] > 1) {
                for(c = 0; c < i; c++)
                    fprint(2, "%s ", av[c]);
                fprint(2, "\n");
            }
            myexec(av[0], av);
            fprint(2, "can't exec C preprocessor %s: %r\n", CPP);
            errorexit();
        default:
            close(fd[1]);
            newfile(file, fd[0]);
            break;
        }
    } else {
        if(strcmp(file, "stdin") == 0)
            newfile(file, 0);
        else
            newfile(file, -1);
    }
    yyparse();
    if(!debug['a'] && !debug['Z'])
        gclean();
    return nerrors;
}
@


\chapter{Input}
% similar to Assembler, could reuse

% lineno in Node section

<<global peekc>>=
int	peekc;
@

<<constant EOF>>=
#define	EOF	(-1)
@

<<constant IGN>>=
#define	IGN	(-2)
@

\section{Files managment}

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

<<struct Io>>=
struct	Io
{
    char	b[BUFSIZ];

    short	f;

    char*	p;
    short	c;

    Io*	link;
};
@

<<global iostack>>=
Io*	iostack;
@

<<global iofree>>=
Io*	iofree;
@

<<global ionext>>=
Io*	ionext;
@

<<constant I>>=
#define	I	((Io*)nil)
@


<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        i = alloc(sizeof(*i));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@

<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    if(debug['e'])
        print("%L: %s\n", lineno, s);

    i = ionext;
    i->link = iostack;
    iostack = i;
    i->f = f;
    if(f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%cc: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

\section{Buffer managment}

<<struct Fi>>=
struct Fi
{
    char*	p;
    int	c;
};
@

<<global fi>>=
struct Fi fi;
@

<<function GETC>>=
#define	GETC()	((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff))
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0] & 0xff;

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++ & 0xff;
}
@

\chapter{Lexing}

% why not using lex? why handwritten?

\section{[[yylex()]]}

<<function yylex>>=
//@Scheck: not dead, called by yyparse
long yylex(void)
{
    vlong vv;
    long c, c1, t;
    char *cp;
    Rune rune;
    Sym *s;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c >= Runeself) {
        /*
         * extension --
         *	all multibyte runes are alpha
         */
        cp = symb;
        goto talph;
    }
    if(isspace(c)) {
        if(c == '\n')
            lineno++;
        goto l0;
    }
    if(isalpha(c)) {
        cp = symb;
        if(c != 'L')
            goto talph;
        *cp++ = c;
        c = GETC();
        if(c == '\'') {
            /* L'x' */
            c = escchar('\'', 1, 0);
            if(c == EOF)
                c = '\'';
            c1 = escchar('\'', 1, 0);
            if(c1 != EOF) {
                yyerror("missing '");
                peekc = c1;
            }
            yylval.vval = convvtox(c, TRUNE);
            return LUCONST;
        }
        if(c == '"') {
            goto caselq;
        }
        goto talph;
    }
    if(isdigit(c))
        goto tnum;
    switch(c)
    {

    case EOF:
        peekc = EOF;
        return -1;

    case '_':
        cp = symb;
        goto talph;

    case '#':
        domacro();
        goto l0;

    case '.':
        c1 = GETC();
        if(isdigit(c1)) {
            cp = symb;
            *cp++ = c;
            c = c1;
            c1 = 0;
            goto casedot;
        }
        break;

    case '"':
        strcpy(symb, "\"<string>\"");
        cp = alloc(0);
        c1 = 0;

        /* "..." */
        for(;;) {
            c = escchar('"', 0, 1);
            if(c == EOF)
                break;
            if(c & ESC) {
                cp = allocn(cp, c1, 1);
                cp[c1++] = c;
            } else {
                rune = c;
                c = runelen(rune);
                cp = allocn(cp, c1, c);
                runetochar(cp+c1, &rune);
                c1 += c;
            }
        }
        yylval.sval.l = c1;
        do {
            cp = allocn(cp, c1, 1);
            cp[c1++] = 0;
        } while(c1 & MAXALIGN);
        yylval.sval.s = cp;
        return LSTRING;

    caselq:
        /* L"..." */
        strcpy(symb, "\"L<string>\"");
        cp = alloc(0);
        c1 = 0;
        for(;;) {
            c = escchar('"', 1, 0);
            if(c == EOF)
                break;
            cp = allocn(cp, c1, sizeof(TRune));
            *(TRune*)(cp + c1) = c;
            c1 += sizeof(TRune);
        }
        yylval.sval.l = c1;
        do {
            cp = allocn(cp, c1, sizeof(TRune));
            *(TRune*)(cp + c1) = 0;
            c1 += sizeof(TRune);
        } while(c1 & MAXALIGN);
        yylval.sval.s = cp;
        return LLSTRING;

    case '\'':
        /* '.' */
        c = escchar('\'', 0, 0);
        if(c == EOF)
            c = '\'';
        c1 = escchar('\'', 0, 0);
        if(c1 != EOF) {
            yyerror("missing '");
            peekc = c1;
        }
        vv = c;
        yylval.vval = convvtox(vv, TUCHAR);
        if(yylval.vval != vv)
            yyerror("overflow in character constant: 0x%lx", c);
        else
        if(c & 0x80){
            nearln = lineno;
            warn(Z, "sign-extended character constant");
        }
        yylval.vval = convvtox(vv, TCHAR);
        return LCONST;

    case '/':
        c1 = GETC();
        if(c1 == '*') {
            for(;;) {
                c = getr();
                while(c == '*') {
                    c = getr();
                    if(c == '/')
                        goto l0;
                }
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '/') {
            for(;;) {
                c = getr();
                if(c == '\n')
                    goto l0;
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '=')
            return LDVE;
        break;

    case '*':
        c1 = GETC();
        if(c1 == '=')
            return LMLE;
        break;

    case '%':
        c1 = GETC();
        if(c1 == '=')
            return LMDE;
        break;

    case '+':
        c1 = GETC();
        if(c1 == '+')
            return LPP;
        if(c1 == '=')
            return LPE;
        break;

    case '-':
        c1 = GETC();
        if(c1 == '-')
            return LMM;
        if(c1 == '=')
            return LME;
        if(c1 == '>')
            return LMG;
        break;

    case '>':
        c1 = GETC();
        if(c1 == '>') {
            c = LRSH;
            c1 = GETC();
            if(c1 == '=')
                return LRSHE;
            break;
        }
        if(c1 == '=')
            return LGE;
        break;

    case '<':
        c1 = GETC();
        if(c1 == '<') {
            c = LLSH;
            c1 = GETC();
            if(c1 == '=')
                return LLSHE;
            break;
        }
        if(c1 == '=')
            return LLE;
        break;

    case '=':
        c1 = GETC();
        if(c1 == '=')
            return LEQ;
        break;

    case '!':
        c1 = GETC();
        if(c1 == '=')
            return LNE;
        break;

    case '&':
        c1 = GETC();
        if(c1 == '&')
            return LANDAND;
        if(c1 == '=')
            return LANDE;
        break;

    case '|':
        c1 = GETC();
        if(c1 == '|')
            return LOROR;
        if(c1 == '=')
            return LORE;
        break;

    case '^':
        c1 = GETC();
        if(c1 == '=')
            return LXORE;
        break;

    default:
        return c;
    }
    peekc = c1;
    return c;

talph:
    /*
     * cp is set to symb and some
     * prefix has been stored
     */
    for(;;) {
        if(c >= Runeself) {
            for(c1=0;;) {
                cp[c1++] = c;
                if(fullrune(cp, c1))
                    break;
                c = GETC();
            }
            cp += c1;
            c = GETC();
            continue;
        }
        if(!isalnum(c) && c != '_')
            break;
        *cp++ = c;
        c = GETC();
    }
    *cp = 0;
    if(debug['L'])
        print("%L: %s\n", lineno, symb);
    peekc = c;
    s = lookup();
    if(s->macro) {
        newio();
        cp = ionext->b;
        macexpand(s, cp);
        pushio();
        ionext->link = iostack;
        iostack = ionext;
        fi.p = cp;
        fi.c = strlen(cp);
        if(peekc != IGN) {
            cp[fi.c++] = peekc;
            cp[fi.c] = 0;
            peekc = IGN;
        }
        goto l0;
    }
    yylval.sym = s;
    if(s->class == CTYPEDEF || s->class == CTYPESTR)
        return LTYPE;
    return s->lexical;

tnum:
    c1 = 0;
    cp = symb;
    if(c != '0') {
        c1 |= Numdec;
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            goto dc;
        }
    }
    *cp++ = c;
    c = GETC();
    if(c == 'x' || c == 'X')
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            if(c >= 'a' && c <= 'f')
                continue;
            if(c >= 'A' && c <= 'F')
                continue;
            if(cp == symb+2)
                yyerror("malformed hex constant");
            goto ncu;
        }
    if(c < '0' || c > '7')
        goto dc;
    for(;;) {
        if(c >= '0' && c <= '7') {
            *cp++ = c;
            c = GETC();
            continue;
        }
        goto ncu;
    }

dc:
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;

ncu:
    if((c == 'U' || c == 'u') && !(c1 & Numuns)) {
        c = GETC();
        c1 |= Numuns;
        goto ncu;
    }
    if((c == 'L' || c == 'l') && !(c1 & Numvlong)) {
        c = GETC();
        if(c1 & Numlong)
            c1 |= Numvlong;
        c1 |= Numlong;
        goto ncu;
    }
    *cp = 0;
    peekc = c;
    if(mpatov(symb, &yylval.vval))
        yyerror("overflow in constant");

    vv = yylval.vval;
    if(c1 & Numvlong) {
        if((c1 & Numuns) || convvtox(vv, TVLONG) < 0) {
            c = LUVLCONST;
            t = TUVLONG;
            goto nret;
        }
        c = LVLCONST;
        t = TVLONG;
        goto nret;
    }
    if(c1 & Numlong) {
        if((c1 & Numuns) || convvtox(vv, TLONG) < 0) {
            c = LULCONST;
            t = TULONG;
            goto nret;
        }
        c = LLCONST;
        t = TLONG;
        goto nret;
    }
    if((c1 & Numuns) || convvtox(vv, TINT) < 0) {
        c = LUCONST;
        t = TUINT;
        goto nret;
    }
    c = LCONST;
    t = TINT;
    goto nret;

nret:
    yylval.vval = convvtox(vv, t);
    if(yylval.vval != vv){
        nearln = lineno;
        warn(Z, "truncated constant: %T %s", types[t], symb);
    }
    return c;

casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c != 'e' && c != 'E')
        goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    if(!isdigit(c))
        yyerror("malformed fp constant exponent");
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    if(c == 'L' || c == 'l') {
        c = GETC();
        c1 |= Numlong;
    } else
    if(c == 'F' || c == 'f') {
        c = GETC();
        c1 |= Numflt;
    }
    *cp = 0;
    peekc = c;
    yylval.dval = strtod(symb, nil);
    if(isInf(yylval.dval, 1) || isInf(yylval.dval, -1)) {
        yyerror("overflow in float constant");
        yylval.dval = 0;
    }
    if(c1 & Numflt)
        return LFCONST;
    return LDCONST;
}
@

\section{Comments}

\section{Keywords and identifiers}

<<global itab>>=
struct
{
    char	*name;
    ushort	lexical;
    // option<enum<Type>>
    ushort	type;
} itab[] =
{
    "auto",		LAUTO,		0,
    "break",		LBREAK,		0,
    "case",		LCASE,		0,
    "char",		LCHAR,		TCHAR,
    "const",		LCONSTNT,	0,
    "continue",		LCONTINUE,	0,
    "default",		LDEFAULT,	0,
    "do",		LDO,		0,
    "double",		LDOUBLE,	TDOUBLE,
    "else",		LELSE,		0,
    "enum",		LENUM,		0,
    "extern",		LEXTERN,	0,
    "float",		LFLOAT,		TFLOAT,
    "for",		LFOR,		0,
    "goto",		LGOTO,		0,
    "if",		LIF,		0,
    "inline",		LINLINE,	0,
    "int",		LINT,		TINT,
    "long",		LLONG,		TLONG,
    "register",		LREGISTER,	0,
    "restrict",		LRESTRICT,	0,
    "return",		LRETURN,	0,
    "SET",		LSET,		0,
    "short",		LSHORT,		TSHORT,
    "signed",		LSIGNED,	0,
    "signof",		LSIGNOF,	0,
    "sizeof",		LSIZEOF,	0,
    "static",		LSTATIC,	0,
    "struct",		LSTRUCT,	0,
    "switch",		LSWITCH,	0,
    "typedef",		LTYPEDEF,	0,
    "typestr",		LTYPESTR,	0,
    "union",		LUNION,		0,
    "unsigned",		LUNSIGNED,	0,
    "USED",		LUSED,		0,
    "void",		LVOID,		TVOID,
    "volatile",		LVOLATILE,	0,
    "while",		LWHILE,		0,
    0
};
@

% extension: SET/USED

\section{Typedef trick}

%LTYPE!!

% typestr?

\section{Numbers}

\subsection{Decimals}

\subsection{Floats}

\section{Characters}

\section{Escaping characters}

<<function escchar>>=
long
escchar(long e, int longflg, bool escflg)
{
    long c, l;
    int i;

loop:
    c = getr();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            c = EOF;
        return c;
    }
    c = getr();
    if(c == 'x') {
        /*
         * note this is not ansi,
         * supposed to only accept 2 hex
         */
        i = 2;
        if(longflg)
            i = 6;
        l = 0;
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '9') {
                l = l*16 + c-'0';
                continue;
            }
            if(c >= 'a' && c <= 'f') {
                l = l*16 + c-'a' + 10;
                continue;
            }
            if(c >= 'A' && c <= 'F') {
                l = l*16 + c-'A' + 10;
                continue;
            }
            unget(c);
            break;
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    if(c >= '0' && c <= '7') {
        /*
         * note this is not ansi,
         * supposed to only accept 3 oct
         */
        i = 2;
        if(longflg)
            i = 8;
        l = c - '0';
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                continue;
            }
            unget(c);
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return '\a';
    case 'v':	return '\v';
    }
    return c;
}
@

\section{Strings}



\section{[[getc()]], [[unget()]], [[getnsc()]]}

<<function getc>>=
int
getc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@

<<function unget>>=
void
unget(int c)
{

    peekc = c;
    if(c == '\n')
        lineno--;
}
@

<<function getnsc>>=
int
getnsc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    for(;;) {
        if(c >= Runeself || !isspace(c))
            return c;
        if(c == '\n') {
            lineno++;
            return c;
        }
        c = GETC();
    }
}
@


\section{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@
% 4 = sizeof Rune?

\section{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

\chapter{Preprocessing}

% builtin preprocessor integrated with lexer (benefit? faster? no fork?)
% see also 8c -p

% dupe with Assembler.tex.nw, should try to factorize at some point

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",	nil,	/* macif(2) */

    "line",	maclin,
    "define",	macdef,
    "include",	macinc,
    "undef",	macund,

    "pragma",	macprag,
    "endif",	macend,
    0
};
@

% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really

<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]] and [[-I]]}

\subsection{Include path}

% was using fixed array in assembler
<<global include>>=
char**	include;
@

<<global ninclude>>=
int	ninclude;
@

<<function setinclude>>=
void
setinclude(char *p)
{
    int i;
    char *e, **np;

    while(*p != 0) {
        e = strchr(p, ' ');
        if(e != 0)
            *e = '\0';

        for(i=0; i < ninclude; i++)
            if(strcmp(p, include[i]) == 0)
                break;

        if(i >= ninclude){
            if(i >= maxinclude){
                maxinclude += 20;
                np = alloc(maxinclude * sizeof *np);
                if(include != nil)
                    memmove(np, include, (maxinclude - 20) * sizeof *np);
                include = np;
            }
            include[ninclude++] = p;
        }

        if(e == 0)
            break;
        p = e+1;
    }
}
@

\subsection{Tracing}

<<struct Hist>>=
struct	Hist
{
    char*	name;

    long	line;
    long	offset;

    Hist*	link;
};
@

<<constant H>>=
#define	H	((Hist*)nil)
@

<<global hist>>=
Hist*	hist;
@

<<global ehist>>=
Hist*	ehist;
@

<<global newflag>>=
bool	newflag;
@


<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    /*
     * overwrite the last #line directive if
     * no alloc has happened since the last one
     */
    if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
        if(f && ehist->name && strcmp(f, ehist->name) == 0) {
            ehist->line = lineno;
            ehist->offset = offset;
            return;
        }
    <<[[linehist()]] debug>>

    newflag = false;

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@

\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@


% LP split, and factorize code with gethunk
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]] and [[-D]]}

\subsection{[[-D]]}

% no Dlist here, instead pass the defs to compile()

<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;

    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@

% LP split macro field of Sym


\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

%<<[[yylex()]] if macro symbol>>=

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);
    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro()
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0) {
        c0 = getnsc();
        if(c0 != '"') {
            c = c0;
            if(c0 != '<')
                goto bad;
            c0 = '>';
        }
        for(hp = symb;;) {
            c = getc();
            if(c == c0)
                break;
            if(c == '\n')
                goto bad;
            *hp++ = c;
        }
        *hp = '\0';
        c = getcom();
        if(c != '\n')
            goto bad;
    
        /*
         * put pragma-line in as a funny history 
         */
        c = strlen(symb) + 1;
        while(c & 3)
            c++;
    
        while(nhunk < c)
            gethunk();
        hp = hunk;
        memcpy(hunk, symb, c);
        nhunk -= c;
        hunk += c;
    
        h = alloc(sizeof(Hist));
        h->name = hp;
        h->line = lineno;
        h->offset = -1;

        h->link = H;
        if(ehist == H) {
            hist = h;
            ehist = h;
            return;
        }
        ehist->link = h;
        ehist = h;

        return;

bad:
        unget(c);
        yyerror("syntax in #pragma lib");
        macend();

    } else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded except #pragma lib, so
% I removed it (could have aslo simplified by calling prag_do_nothing()).
% is it because code was shared with cc? or because it's in aa/
% and other archi do different things?
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

% useful for code generator, to report error to original file, not generated
% code, e.g. for lex&yacc

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@



\chapter{Parsing}

\section{Overview}

% I assume you understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.tex.nw :) )
% compared to ocamlyacc can have actions in the middle, and they count
% as indexable elements for the $xxx ($1, $2, etc)

<<cc/cc.y>>=
%{
#include "cc.h"
%}
<<union yacc>>
<<token declarations>>
<<priority and associativity declarations>>
<<type declarations>>
%%
<<grammar>>
%%
@

% have seen Token declaration in Core Data structures chapter already.

% do not LP split, order matters!
<<priority and associativity declarations>>=
%left   ';'
%left   ','
%right  '=' LPE LME LMLE LDVE LMDE LRSHE LLSHE LANDE LXORE LORE
%right  '?' ':'
%left   LOROR
%left   LANDAND
%left   '|'
%left   '^'
%left   '&'
%left   LEQ LNE
%left   '<' '>' LLE LGE
%left   LLSH LRSH
%left   '+' '-'
%left   '*' '/' '%'
%right  LMM LPP LMG '.' '[' '('
@


<<[[union yacc]] other fields>>=
Node*   node;
@

% see Node also in Core data structure section, with Z, left/right, new(), etc


<<type declarations>>=
%type   <node>  zarglist arglist zcexpr
%type   <node>  name block stmnt cexpr expr xuexpr pexpr
%type   <node>  zelist elist adecl slist uexpr string lstring
%type   <node>  xdecor xdecor2 labels label ulstmnt
%type   <node>  adlist edecor tag qual qlist
%type   <node>  abdecor abdecor1 abdecor2 abdecor3
%type   <node>  zexpr lexpr init ilist forexpr
@

% in what follows a few conventions: 
% zxxx means zero or more e.g. zctlist means list of ctl 0 or more

% note that all terminal chars like ')' are acutally Node* too
% so can pass them to warn() to get accurate error location

<<grammar>>=
prog:
  /* empty */
|   prog xdecl

<<external declarator rules>>
<<automatic declarator rules>>
<<parameter declarator rules>>
<<abstract declarator rules>>
<<structure element declarator rules>>

<<statements rules>>

<<expressions rules>>
<<initializers rules>>

<<types rules>>
<<complex types rules>>

<<names rules>>

<<extra grammar rules>>
<<ebnf grammar rules>>
@

\section{Declarations and definitions, part one}

<<external declarator rules>>=
/*
 * external declarator
 */
xdecl:
    zctlist ';'          { dodecl(xdecl, lastclass, lasttype, Z); }
|   zctlist xdlist ';'
<<xdecl function definition case>>
@

% do that because C sucks? but my parser_c.mly was also complicated
% when it come to declaration handling
<<global lastclass>>=
//@Scheck: y.tab.c
char	lastclass;
@

<<global lasttype>>=
//@Scheck: y.tab.c
Type*	lasttype;
@

% dodecl() modify especially this global.
% hmm why Type* and not Decl*? rename lastdcltype?
<<global lastdcl>>=
Type*	lastdcl;
@



\section{Function definition}


<<global firstdcl>>=
Decl*	firstdcl;
@


<<global thisfn>>=
Type*	thisfn;
@



<<xdecl function definition case>>=
|   zctlist xdecor
    {
        lastdcl = T;
        firstarg = S;
        dodecl(xdecl, lastclass, lasttype, $2);
        if(lastdcl == T || lastdcl->etype != TFUNC) {
            diag($2, "not a function");
            lastdcl = types[TFUNC];
        }
        thisfn = lastdcl;
        markdcl();
        firstdcl = dclstack;
        argmark($2, 0);
    }
    pdecl
    {
        argmark($2, 1);
    }
    block
    {
        Node *n;

        n = revertdcl();
        if(n)
            $6 = new(OLIST, n, $6);

        if(!debug['a'] && !debug['Z'])
            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!
    }
@

\subsection{Parameters}

<<global firstarg>>=
Sym*	firstarg;
@

<<global firstargtype>>=
Type*	firstargtype;
@

<<global autoffset>>=
long	autoffset;
@

<<global stkoff>>=
long	stkoff;
@


% pass is 0 or 1
<<function argmark>>=
//@Scheck: not dead, used by cc.y
void argmark(Node *n, int pass)
{
    Type *t;

    autoffset = align(0, thisfn->link, Aarg0);
    stkoff = 0;
    for(; n->left != Z; n = n->left) {
        if(n->op != OFUNC || n->left->op != ONAME)
            continue;
        walkparam(n->right, pass);
        if(pass != 0 && anyproto(n->right) == OLDPROTO) {
            t = typ(TFUNC, n->left->sym->type->link);
            t->down = typ(TOLD, T);
            t->down->down = ofnproto(n->right);
            tmerge(t, n->left->sym);
            n->left->sym->type = t;
        }
        break;
    }
    autoffset = 0;
    stkoff = 0;
}
@

<<function walkparam>>=
void
walkparam(Node *n, int pass)
{
    Sym *s;
    Node *n1;

    if(n != Z && n->op == OPROTO && n->left == Z && n->type == types[TVOID])
        return;

loop:
    if(n == Z)
        return;
    switch(n->op) {
    default:
        diag(n, "argument not a name/prototype: %O", n->op);
        break;

    case OLIST:
        walkparam(n->left, pass);
        n = n->right;
        goto loop;

    case OPROTO:
        for(n1 = n; n1 != Z; n1=n1->left)
            if(n1->op == ONAME) {
                if(pass == 0) {
                    s = n1->sym;
                    push1(s);
                    s->offset = -1;
                    break;
                }
                dodecl(pdecl, CPARAM, n->type, n->left);
                break;
            }
        if(n1)
            break;
        if(pass == 0) {
            /*
             * extension:
             *	allow no name in argument declaration
            diag(Z, "no name in argument declaration");
             */
            break;
        }
        dodecl(NODECL, CPARAM, n->type, n->left);
        pdecl(CPARAM, lastdcl, S);
        break;

    case ODOTDOT:
        break;
    
    case ONAME:
        s = n->sym;
        if(pass == 0) {
            push1(s);
            s->offset = -1;
            break;
        }
        if(s->offset != -1) {
            if(autoffset == 0) {
                firstarg = s;
                firstargtype = s->type;
            }
            autoffset = align(autoffset, s->type, Aarg1);
            s->offset = autoffset;
            autoffset = align(autoffset, s->type, Aarg2);
        } else
            dodecl(pdecl, CXXX, types[TINT], n);
        break;
    }
}
@



<<parameter declarator rules>>=
/*
 * parameter declarator
 */
pdecl:
  /* empty */
|   pdecl ctlist pdlist ';'

pdlist:
    xdecor              { dodecl(pdecl, lastclass, lasttype, $1); }
|   pdlist ',' pdlist
@
%$
% this is old style? pre-ansi?


<<function pdecl>>=
void
pdecl(int c, Type *t, Sym *s)
{
    if(s && s->offset != -1) {
        diag(Z, "not a parameter: %s", s->name);
        return;
    }
    t = paramconv(t, c==CPARAM);
    if(c == CXXX)
        c = CPARAM;
    if(c != CPARAM) {
        diag(Z, "parameter cannot have class: %s", s->name);
        c = CPARAM;
    }
    if(typesu[t->etype] && t->width <= 0)
        diag(Z, "incomplete structure: %s", t->tag->name);
    adecl(c, t, s);
}
@





% called arg ... hmmm ... should be renamed zparamlist
<<parameter declarator rules>>=
zarglist:
  /* empty */   { $$ = Z; }
|   arglist     { $$ = invert($1); }


arglist:
    name
|   tlist abdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
|   tlist xdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
|   '.' '.' '.'          { $$ = new(ODOTDOT, Z, Z); }
|   arglist ',' arglist  { $$ = new(OLIST, $1, $3); }
@
%$



\section{Statements}

<<statements rules>>=
stmnt:
    ulstmnt
|   labels ulstmnt { $$ = new(OLIST, $1, $2); }
|   error ';'      { $$ = Z; }
@

<<statements rules>>=
<<ulstmnt rule>>
@

<<ulstmnt rule>>=
ulstmnt:
    zcexpr ';'
@

<<ebnf grammar rules>>=
labels:
    label
|   labels label  { $$ = new(OLIST, $1, $2); }
@

<<statements rules>>=
<<label rule>>
@

\subsection{Blocks}

<<ulstmnt rule>>=
|   {
        markdcl();
    }
    block
    {
        $$ = revertdcl();
        if($$)
            $$ = new(OLIST, $$, $2);
        else
            $$ = $2;
    }
@
% will explain later revertdcl() in Declaration section
% originally in comment //  if($2 != Z) $$ = new(OLIST, $2, $$);



<<statements rules>>=
block:
 '{' slist '}'
    {
        $$ = invert($2);
        if($$ == Z)
            $$ = new(OLIST, Z, Z);
    }

slist:
  /* empty */      { $$ = Z;    }
|   slist adecl    { $$ = new(OLIST, $1, $2); }
|   slist stmnt    { $$ = new(OLIST, $1, $2); }
@
%$


\subsection{Conditionals}

<<ulstmnt rule>>=
|   LIF '(' cexpr ')' stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, Z));
        if($5 == Z)
            warn($3, "empty if body");
    }
|   LIF '(' cexpr ')' stmnt LELSE stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, $7));
        if($5 == Z)
            warn($3, "empty if body");
        if($7 == Z)
            warn($3, "empty else body");
    }
@
%$

\subsection{Switch}

<<ulstmnt rule>>=
|   LSWITCH '(' cexpr ')' stmnt
    {
        $$ = new(OCONST, Z, Z);
        $$->vconst = 0;
        $$->type = types[TINT];
        $3 = new(OSUB, $$, $3);

        $$ = new(OSWITCH, $3, $5);
    }
@
% padfix: the 4 lines were copy pasted

% note that labels so can have case 1: case 2: ...

<<label rule>>=
label:
    LCASE expr ':'  { $$ = new(OCASE, $2, Z); }
|   LDEFAULT ':'    { $$ = new(OCASE, Z, Z); }
@
%$

\subsection{Control flow jumps}

<<ulstmnt rule>>=
|   LRETURN zcexpr ';'
    {
        $$ = new(ORETURN, $2, Z);
        $$->type = thisfn->link;
    }
|   LBREAK ';'     { $$ = new(OBREAK, Z, Z); }
|   LCONTINUE ';'  { $$ = new(OCONTINUE, Z, Z); }
@
%$


\subsection{Loops}

<<ulstmnt rule>>=
|   { 
        markdcl(); 
    } 
    LFOR '(' forexpr ';' zcexpr ';' zcexpr ')' stmnt
    {
        $$ = revertdcl();
        if($$){
            if($4)
                $4 = new(OLIST, $$, $4);
            else
                $4 = $$;
        }
        $$ = new(OFOR, new(OLIST, $6, new(OLIST, $4, $8)), $10);
    }
|   LWHILE '(' cexpr ')' stmnt          { $$ = new(OWHILE, $3, $5); }
|   LDO stmnt LWHILE '(' cexpr ')' ';'  { $$ = new(ODWHILE, $5, $2); }
@

% C extension for(int i; ... ?)
<<statements rules>>=
forexpr:
    zcexpr
|   ctlist adlist { $$ = $2; }
@
%$

\subsection{Labels}

<<label rule>>=
|   LNAME ':'       { $$ = new(OLABEL, dcllabel($1, true), Z); }
@
%$

<<ulstmnt rule>>=
|   LGOTO ltag ';' { $$ = new(OGOTO, dcllabel($2, false), Z); }
@
%$


<<[[Sym]] other fields>>=
Node*	label;
@

% flag is true for label definition context, false for use (e.g. in goto)
% TODO cleanup abuse of complex/addable, do like in scheck field for used
<<function dcllabel>>=
//@Scheck: used by cc.y
Node* dcllabel(Sym *s, bool f)
{
    Decl *d, d1;
    Node *n;

    n = s->label;
    if(n != Z) {
        if(f) {
            if(n->complex)
                diag(Z, "label reused: %s", s->name);
            n->complex = 1;	// declared
        } else
            n->addable = 1;	// used
        return n;
    }

    d = push();
    d->sym = s;
    d->val = DLABEL;

    dclstack = d->link;

    d1 = *firstdcl;
    *firstdcl = *d;
    *d = d1;

    firstdcl->link = d;
    firstdcl = d;

    n = new(OXXX, Z, Z);
    n->sym = s;
    n->complex = f;
    n->addable = !f;

    s->label = n;

    if(debug['d'])
        dbgdecl(s);
    return n;
}
@

\section{Expressions}

<<expressions rules>>=
expr:
    xuexpr

|   expr '*' expr { $$ = new(OMUL, $1, $3); }
|   expr '/' expr { $$ = new(ODIV, $1, $3); }
|   expr '%' expr { $$ = new(OMOD, $1, $3); }
|   expr '+' expr { $$ = new(OADD, $1, $3); }
|   expr '-' expr { $$ = new(OSUB, $1, $3); }
|   expr LRSH expr { $$ = new(OASHR, $1, $3); }
|   expr LLSH expr { $$ = new(OASHL, $1, $3); }
|   expr '<' expr  { $$ = new(OLT, $1, $3); }
|   expr '>' expr  { $$ = new(OGT, $1, $3); }
|   expr LLE expr  { $$ = new(OLE, $1, $3); }
|   expr LGE expr  { $$ = new(OGE, $1, $3); }
|   expr LEQ expr  { $$ = new(OEQ, $1, $3); }
|   expr LNE expr  { $$ = new(ONE, $1, $3); }
|   expr '&' expr  { $$ = new(OAND, $1, $3); }
|   expr '^' expr  { $$ = new(OXOR, $1, $3); }
|   expr '|' expr  { $$ = new(OOR, $1, $3); }
|   expr LANDAND expr { $$ = new(OANDAND, $1, $3); }
|   expr LOROR expr   { $$ = new(OOROR, $1, $3); }

|   expr '?' cexpr ':' expr { $$ = new(OCOND, $1, new(OLIST, $3, $5)); }

|   expr '=' expr  { $$ = new(OAS, $1, $3); }
|   expr LPE expr  { $$ = new(OASADD, $1, $3); }
|   expr LME expr  { $$ = new(OASSUB, $1, $3); }
|   expr LMLE expr { $$ = new(OASMUL, $1, $3); }
|   expr LDVE expr { $$ = new(OASDIV, $1, $3); }
|   expr LMDE expr { $$ = new(OASMOD, $1, $3); }
|   expr LLSHE expr { $$ = new(OASASHL, $1, $3); }
|   expr LRSHE expr { $$ = new(OASASHR, $1, $3); }
|   expr LANDE expr { $$ = new(OASAND, $1, $3); }
|   expr LXORE expr { $$ = new(OASXOR, $1, $3); }
|   expr LORE expr  { $$ = new(OASOR, $1, $3); }
@
%$

<<expressions rules>>=
xuexpr:
    uexpr
|   '(' tlist abdecor ')' xuexpr
    {
        $$ = new(OCAST, $5, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcl;
        $$->xcast = true;
    }
<<xuexpr other cases>>
@
%$

% extended unary expr? = cast expr

<<[[Node]] other fields>>=
bool 	xcast;
@

<<xuexpr other cases>>=
|   '(' tlist abdecor ')' '{' ilist '}' /* extension */
    {
        $$ = new(OSTRUCT, $6, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcl;
    }
@
%$


% unary expr
<<expressions rules>>=
uexpr:
    pexpr

|   '*' xuexpr { $$ = new(OIND, $2, Z); }
|   '&' xuexpr { $$ = new(OADDR, $2, Z); }

|   '+' xuexpr { $$ = new(OPOS, $2, Z); }
|   '-' xuexpr { $$ = new(ONEG, $2, Z); }
|   '!' xuexpr { $$ = new(ONOT, $2, Z); }
|   '~' xuexpr { $$ = new(OCOM, $2, Z); }
|   LPP xuexpr { $$ = new(OPREINC, $2, Z); }
|   LMM xuexpr { $$ = new(OPREDEC, $2, Z); }

|   LSIZEOF uexpr { $$ = new(OSIZE, $2, Z); }
|   LSIGNOF uexpr { $$ = new(OSIGN, $2, Z); }
@
% signof?

<<expressions rules>>=
<<pexpr rule>>
@

% primary expr
<<pexpr rule>>=
pexpr:
    '(' cexpr ')' { $$ = $2; }
@
%$

<<pexpr rule>>=
|   LSIZEOF '(' tlist abdecor ')'
    {
        $$ = new(OSIZE, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcl;
    }
|   LSIGNOF '(' tlist abdecor ')'
    {
        $$ = new(OSIGN, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcl;
    }
@
%$
% again sizeof but this time not uexpr, but types!

<<pexpr rule>>=
|   pexpr '(' zelist ')'
    {
        $$ = new(OFUNC, $1, Z);
        if($1->op == ONAME)
        if($1->type == T)
            dodecl(xdecl, CXXX, types[TINT], $$);
        $$->right = invert($3);
    }
@

<<ebnf grammar rules>>=
zelist:
  /* empty */ { $$ = Z; }
|   elist
@


<<expressions rules>>=
elist:
    expr
|   elist ',' elist { $$ = new(OLIST, $1, $3); }
@


<<pexpr rule>>=
|   pexpr '[' cexpr ']' { $$ = new(OIND, new(OADD, $1, $3), Z); }
@

<<pexpr rule>>=
|   pexpr LMG ltag
    {
        $$ = new(ODOT, new(OIND, $1, Z), Z);
        $$->sym = $3;
    }
|   pexpr '.' ltag
    {
        $$ = new(ODOT, $1, Z);
        $$->sym = $3;
    }
@

<<pexpr rule>>=
|   pexpr LPP { $$ = new(OPOSTINC, $1, Z); }
|   pexpr LMM { $$ = new(OPOSTDEC, $1, Z); }
@

<<pexpr rule>>=
|   name
@

<<pexpr rule>>=
|   LCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LUCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LULCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TULONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LDCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TDOUBLE];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
|   LFCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TFLOAT];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
|   LVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LUVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@

<<pexpr rule>>=
|   string
|   lstring
@

<<expressions rules>>=
string:
    LSTRING
    {
        $$ = new(OSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TCHAR]);
        $$->type->width = $1.l + 1;
        $$->cstring = $1.s;
        $$->sym = symstring;
        $$->etype = TARRAY;
        $$->class = CSTATIC;
    }
|   string LSTRING
    {
        char *s;
        int n;

        n = $1->type->width - 1;
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->cstring, n);
        memcpy(s+n, $2.s, $2.l);
        s[n+$2.l] = 0;

        $$ = $1;
        $$->type->width += $2.l;
        $$->cstring = s;
    }

lstring:
    LLSTRING
    {
        $$ = new(OLSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TRUNE]);
        $$->type->width = $1.l + sizeof(TRune);
        $$->rstring = (TRune*)$1.s;
        $$->sym = symstring;
        $$->etype = TARRAY;
        $$->class = CSTATIC;
    }
|   lstring LLSTRING
    {
        char *s;
        int n;

        n = $1->type->width - sizeof(TRune);
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->rstring, n);
        memcpy(s+n, $2.s, $2.l);
        *(TRune*)(s+n+$2.l) = 0;

        $$ = $1;
        $$->type->width += $2.l;
        $$->rstring = (TRune*)s;
    }
@


<<expressions rules>>=
zexpr:
  /* empty */ { $$ = Z; }
|   lexpr

lexpr:
    expr
    {
        $$ = new(OCAST, $1, Z);
        $$->type = types[TLONG];
    }

cexpr:
    expr
|   cexpr ',' cexpr { $$ = new(OCOMMA, $1, $3); }
@
%$
% cexpr = comma expr

<<ebnf grammar rules>>=
zcexpr:
  /* empty */ { $$ = Z; }
|   cexpr
@


\section{Initializers}

<<initializers rules>>=
init:
    expr
|   '{' ilist '}' { $$ = new(OINIT, invert($2), Z); }

ilist:
    qlist
|   init
|   qlist init { $$ = new(OLIST, $1, $2); }

qlist:
    init ','
|   qlist init ','  { $$ = new(OLIST, $1, $2); }
|   qual
|   qlist qual      { $$ = new(OLIST, $1, $2); }

qual:
    '[' lexpr ']' { $$ = new(OARRAY, $2, Z); }
|   '.' ltag
    {
        $$ = new(OELEM, Z, Z);
        $$->sym = $2;
    }
|   qual '='
@
%$


\section{Types}

\subsection{Simple types}

<<[[union yacc]] other fields>>=
struct
{
    Type*   t;
    uchar   c;
} tycl;
@

<<type declarations>>=
%type   <tycl>  types
@

<<types rules>>=
types:
    complex
    {
        $$.t = $1;
        $$.c = CXXX;
    }
|   tname
    {
        $$.t = simplet($1);
        $$.c = CXXX;
    }
|   gcnlist
    {
        $$.t = simplet($1);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   complex gctnlist
    {
        $$.t = $1;
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
        if($2 & ~BCLASS & ~BGARB)
            diag(Z, "duplicate types given: %T and %Q", $1, $2);
    }
|   tname gctnlist
    {
        $$.t = simplet(typebitor($1, $2));
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
    }
|   gcnlist complex zgnlist
    {
        $$.t = $2;
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1|$3);
    }
|   gcnlist tname
    {
        $$.t = simplet($2);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   gcnlist tname gctnlist
    {
        $$.t = simplet(typebitor($2, $3));
        $$.c = simplec($1|$3);
        $$.t = garbt($$.t, $1|$3);
    }
@

% sizeof, cast, context
<<extra grammar rules>>=
tlist:
    types
    {
        $$ = $1.t;
        if($1.c != CXXX)
            diag(Z, "illegal combination of class 4: %s", cnames[$1.c]);
    }
@

<<[[union yacc]] other fields>>=
Type*   type;
@

<<type declarations>>=
%type   <type>  tlist sbody complex
@

\subsection{Structures and unions}

<<type declarations>>=
%type   <sym>   ltag
@

<<names rules>>=
tag:
    ltag
    {
        $$ = new(ONAME, Z, Z);
        $$->sym = $1;
        $$->type = $1->type;
        $$->etype = TVOID;
        if($$->type != T)
            $$->etype = $$->type->etype;
        $$->xoffset = $1->offset;
        $$->class = $1->class;
    }

ltag:
    LNAME
|   LTYPE
@

<<complex types rules>>=
complex:
    LSTRUCT ltag
    {
        dotag($2, TSTRUCT, 0);
        $$ = $2->suetag;
    }
|   LSTRUCT ltag
    {
        dotag($2, TSTRUCT, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        sualign($$);
    }
|   LSTRUCT sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TSTRUCT, autobn);
        $$->link = $2;
        sualign($$);
    }
|   LUNION ltag
    {
        dotag($2, TUNION, 0);
        $$ = $2->suetag;
    }
|   LUNION ltag
    {
        dotag($2, TUNION, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        sualign($$);
    }
|   LUNION sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TUNION, autobn);
        $$->link = $2;
        sualign($$);
    }
|   LENUM ltag
    {
        dotag($2, TENUM, 0);
        $$ = $2->suetag;
        if($$->link == T)
            $$->link = types[TINT];
        $$ = $$->link;
    }
|   LENUM ltag
    {
        dotag($2, TENUM, autobn);
    }
    '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum '}'
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        if(en.tenum == T) {
            diag(Z, "enum type ambiguous: %s", $2->name);
            en.tenum = types[TINT];
        }
        $$->link = en.tenum;
        $$ = en.tenum;
    }
|   LENUM '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum '}'
    {
        $$ = en.tenum;
    }
|   LTYPE { $$ = tcopy($1->type); }



sbody:
    '{'
    {
        $<tyty>$.t1 = strf;
        $<tyty>$.t2 = strl;
        $<tyty>$.t3 = lasttype;
        $<tyty>$.c = lastclass;
        strf = T;
        strl = T;
        lastbit = 0;
        firstbit = 1;
        lastclass = CXXX;
        lasttype = T;
    }
    edecl 
    '}'
    {
        $$ = strf;
        strf = $<tyty>2.t1;
        strl = $<tyty>2.t2;
        lasttype = $<tyty>2.t3;
        lastclass = $<tyty>2.c;
    }

@
%$

<<[[union yacc]] other fields>>=
struct
{
    Type*   t1;
    Type*   t2;
    Type*   t3;
    uchar   c;
} tyty;
@


<<structure element declarator rules>>=
/*
 * structure element declarator
 */
edecl:
    tlist
    {
        lasttype = $1;
    }
    zedlist ';'
|   edecl tlist
    {
        lasttype = $2;
    }
    zedlist ';'

zedlist:                    /* extension */
 /* empty */
    {
        lastfield = 0;
        edecl(CXXX, lasttype, S);
    }
|   edlist

edlist:
    edecor            { dodecl(edecl, CXXX, lasttype, $1); }
|   edlist ',' edlist

edecor:
    xdecor
    {
        lastbit = 0;
        firstbit = 1;
    }
|   tag ':' lexpr   { $$ = new(OBIT, $1, $3); }
|   ':' lexpr       { $$ = new(OBIT, Z, $2); }
@
%$

<<global lastfield>>=
long	lastfield;
@

<<global lastbit>>=
long	lastbit;
@

\subsection{Enum}

<<complex types rules>>=
enum:
    LNAME           { doenum($1, Z); }
|   LNAME '=' expr  { doenum($1, $3); }
|   enum ','
|   enum ',' enum
@
%$

\section{Declarations and definitions, part two}

<<global blockno>>=
int	blockno;
@

<<global autobn>>=
int	autobn;
@


<<function markdcl>>=
//@Scheck: used by cc.y
void markdcl(void)
{
    Decl *d;

    blockno++;

    d = push();
    d->val = DMARK;
    d->offset = autoffset;
    d->block = autobn;

    autobn = blockno;
}
@

<<function revertdcl>>=
//@Scheck: used by cc.y
Node* revertdcl(void)
{
    Decl *d;
    Sym *s;
    Node *n, *n1;

    n = Z;
    for(;;) {
        d = dclstack;
        if(d == D) {
            diag(Z, "pop off dcl stack");
            break;
        }
        dclstack = d->link;
        s = d->sym;
        switch(d->val) {
        case DMARK:
            autoffset = d->offset;
            autobn = d->block;
            return n;

        case DAUTO:
            if(debug['d'])
                print("revert1 \"%s\"\n", s->name);
            if(s->aused == 0) {
                nearln = s->varlineno;
                if(s->class == CAUTO)
                    warn(Z, "auto declared and not used: %s", s->name);
                if(s->class == CPARAM)
                    warn(Z, "param declared and not used: %s", s->name);
            }
            if(s->type && (s->type->garb & GVOLATILE)) {
                n1 = new(ONAME, Z, Z);
                n1->sym = s;
                n1->type = s->type;
                n1->etype = TVOID;
                if(n1->type != T)
                    n1->etype = n1->type->etype;
                n1->xoffset = s->offset;
                n1->class = s->class;

                n1 = new(OADDR, n1, Z);
                n1 = new(OUSED, n1, Z);
                if(n == Z)
                    n = n1;
                else
                    n = new(OLIST, n1, n);
            }
            s->type = d->type;
            s->class = d->class;
            s->offset = d->offset;
            s->block = d->block;
            s->varlineno = d->varlineno;
            s->aused = d->aused;
            break;

        case DSUE:
            if(debug['d'])
                print("revert2 \"%s\"\n", s->name);
            s->suetag = d->type;
            s->sueblock = d->block;
            break;

        case DLABEL:
            if(debug['d'])
                print("revert3 \"%s\"\n", s->name);
            if(s->label && s->label->addable == 0)
                warn(s->label, "label declared and not used \"%s\"", s->name);
            s->label = Z;
            break;
        }
    }
    return n;
}
@






<<function xdecl>>=
void
xdecl(int c, Type *t, Sym *s)
{
    long o;

    o = 0;
    switch(c) {
    case CEXREG:
        o = exreg(t);
        if(o == 0)
            c = CEXTERN;
        if(s->class == CGLOBL)
            c = CGLOBL;
        break;

    case CEXTERN:
        if(s->class == CGLOBL)
            c = CGLOBL;
        break;

    case CXXX:
        c = CGLOBL;
        if(s->class == CEXTERN)
            s->class = CGLOBL;
        break;

    case CAUTO:
        diag(Z, "overspecified class: %s %s %s", s->name, cnames[c], cnames[s->class]);
        c = CEXTERN;
        break;

    case CTYPESTR:
        if(!typesuv[t->etype]) {
            diag(Z, "typestr must be struct/union: %s", s->name);
            break;
        }
        dclfunct(t, s);
        break;
    }

    if(s->class == CSTATIC)
        if(c == CEXTERN || c == CGLOBL) {
            warn(Z, "overspecified class: %s %s %s", s->name, cnames[c], cnames[s->class]);
            c = CSTATIC;
        }
    if(s->type != T)
        if(s->class != c || !sametype(t, s->type) || t->etype == TENUM) {
            diag(Z, "external redeclaration of: %s", s->name);
            Bprint(&diagbuf, "	%s %T %L\n", cnames[c], t, nearln);
            Bprint(&diagbuf, "	%s %T %L\n", cnames[s->class], s->type, s->varlineno);
        }
    tmerge(t, s);
    s->type = t;
    s->class = c;
    s->block = 0;
    s->offset = o;
}
@


<<function dodecl>>=
Node*
dodecl(void (*f)(int,Type*,Sym*), int c, Type *t, Node *n)
{
    Sym *s;
    Node *n1;
    long v;

    nearln = lineno;
    lastfield = 0;

loop:
    if(n != Z)
    switch(n->op) {
    default:
        diag(n, "unknown declarator: %O", n->op);
        break;

    case OARRAY:
        t = typ(TARRAY, t);
        t->width = 0;
        n1 = n->right;
        n = n->left;
        if(n1 != Z) {
            complex(n1);
            v = -1;
            if(n1->op == OCONST)
                v = n1->vconst;
            if(v <= 0) {
                diag(n, "array size must be a positive constant");
                v = 1;
            }
            t->width = v * t->link->width;
        }
        goto loop;

    case OIND:
        t = typ(TIND, t);
        t->garb = n->garb;
        n = n->left;
        goto loop;

    case OFUNC:
        t = typ(TFUNC, t);
        t->down = fnproto(n);
        n = n->left;
        goto loop;

    case OBIT:
        n1 = n->right;
        complex(n1);
        lastfield = -1;
        if(n1->op == OCONST)
            lastfield = n1->vconst;
        if(lastfield < 0) {
            diag(n, "field width must be non-negative constant");
            lastfield = 1;
        }
        if(lastfield == 0) {
            lastbit = 0;
            firstbit = 1;
            if(n->left != Z) {
                diag(n, "zero width named field");
                lastfield = 1;
            }
        }
        if(!typei[t->etype]) {
            diag(n, "field type must be int-like");
            t = types[TINT];
            lastfield = 1;
        }
        if(lastfield > tfield->width*8) {
            diag(n, "field width larger than field unit");
            lastfield = 1;
        }
        lastbit += lastfield;
        if(lastbit > tfield->width*8) {
            lastbit = lastfield;
            firstbit = 1;
        }
        n = n->left;
        goto loop;

    case ONAME:
        if(f == NODECL)
            break;
        s = n->sym;
        (*f)(c, t, s);
        if(s->class == CLOCAL)
            s = mkstatic(s);
        firstbit = 0;
        n->sym = s;
        n->type = s->type;
        n->xoffset = s->offset;
        n->class = s->class;
        n->etype = TVOID;
        if(n->type != T)
            n->etype = n->type->etype;
        if(debug['d'])
            dbgdecl(s);
        acidvar(s);
        s->varlineno = lineno;
        break;
    }
    lastdcl = t;
    return n;
}
@






<<external declarator rules>>=
xdlist:
    xdecor  { dodecl(xdecl, lastclass, lasttype, $1); }
|   xdecor
    {
        $1 = dodecl(xdecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        doinit($1->sym, $1->type, 0L, $4);
    }
|   xdlist ',' xdlist

xdecor:
    xdecor2
|   '*' zgnlist xdecor
    {
        $$ = new(OIND, $3, Z);
        $$->garb = simpleg($2);
    }

xdecor2:
    tag
|   '(' xdecor ')'             { $$ = $2;   }
|   xdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
|   xdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }
@
%$

<<ebnf grammar rules>>=
zctlist:
 /* empty */
    {
        lastclass = CXXX;
        lasttype = types[TINT];
    }
|   ctlist
@

<<extra grammar rules>>=
ctlist:
    types
    {
        lasttype = $1.t;
        lastclass = $1.c;
    }
@

<<automatic declarator rules>>=
/*
 * automatic declarator
 */
adecl:
    ctlist ';'        { $$ = dodecl(adecl, lastclass, lasttype, Z); }
|   ctlist adlist ';' { $$ = $2; }

adlist:
    xdecor
    {
        dodecl(adecl, lastclass, lasttype, $1);
        $$ = Z;
    }
|   xdecor
    {
        $1 = dodecl(adecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        long w;

        w = $1->sym->type->width;
        $$ = doinit($1->sym, $1->type, 0L, $4);
        $$ = contig($1->sym, $$, w);
    }
|   adlist ',' adlist
    {
        $$ = $1;
        if($3 != Z) {
            $$ = $3;
            if($1 != Z)
                $$ = new(OLIST, $1, $3);
        }
    }
@
%$


<<abstract declarator rules>>=
/*
 * abstract declarator
 */
abdecor:
  /* empty */ { $$ = (Z); }
|   abdecor1

abdecor1:
    '*' zgnlist
    {
        $$ = new(OIND, (Z), Z);
        $$->garb = simpleg($2);
    }
|   '*' zgnlist abdecor1
    {
        $$ = new(OIND, $3, Z);
        $$->garb = simpleg($2);
    }
|   abdecor2

abdecor2:
    abdecor3
|   abdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
|   abdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }

abdecor3:
    '(' ')'           { $$ = new(OFUNC, (Z), Z); }
|   '[' zexpr ']'     { $$ = new(OARRAY, (Z), $2); }
|   '(' abdecor1 ')'  { $$ = $2; }
@
%$

\subsection{Local variables}


\subsection{Other}



\section{Names}

<<names rules>>=
name:
    LNAME
    {
        $$ = new(ONAME, Z, Z);
        if($1->class == CLOCAL)
            $1 = mkstatic($1);
        $$->sym = $1;
        $$->type = $1->type;
        $$->etype = TVOID;
        if($$->type != T)
            $$->etype = $$->type->etype;
        $$->xoffset = $1->offset;
        $$->class = $1->class;
        $1->aused = 1;
    }
@

<<type declarations>>=
%type   <lval>  tname cname gname   gcname   gctname
@

<<names rules>>=
tname:  /* type words */
    LCHAR     { $$ = BCHAR; }
|   LSHORT    { $$ = BSHORT; }
|   LINT      { $$ = BINT; }
|   LLONG     { $$ = BLONG; }
|   LSIGNED   { $$ = BSIGNED; }
|   LUNSIGNED { $$ = BUNSIGNED; }
|   LFLOAT    { $$ = BFLOAT; }
|   LDOUBLE   { $$ = BDOUBLE; }
|   LVOID     { $$ = BVOID; }

cname:  /* class words */
    LAUTO     { $$ = BAUTO; }
|   LSTATIC   { $$ = BSTATIC; }
|   LEXTERN   { $$ = BEXTERN; }
|   LTYPEDEF  { $$ = BTYPEDEF; }
|   LTYPESTR  { $$ = BTYPESTR; }
|   LREGISTER { $$ = BREGISTER; }
|   LINLINE   { $$ = 0; }

gname:  /* garbage words */
    LCONSTNT  { $$ = BCONSTNT; }
|   LVOLATILE { $$ = BVOLATILE; }
|   LRESTRICT { $$ = 0; }
@


<<names rules>>=
gctname:
    tname
|   gname
|   cname

gcname:
    gname
|   cname
@

<<type declarations>>=
%type   <lval>  gctnlist gcnlist zgnlist
@

<<names rules>>=
gctnlist:
    gctname
|   gctnlist gctname { $$ = typebitor($1, $2); }

zgnlist:
 /* empty */       { $$ = 0; }
|   zgnlist gname  { $$ = typebitor($1, $2); }

gcnlist:
    gcname
|   gcnlist gcname { $$ = typebitor($1, $2); }
@

\section{Helpers}

% invert in place
<<function invert>>=
Node*
invert(Node *n)
{
    Node *i;

    if(n == Z || n->op != OLIST)
        return n;
    i = n;
    for(n = n->left; n != Z; n = n->left) {
        if(n->op != OLIST)
            break;
        i->left = n->right;
        n->right = i;
        i = n;
    }
    i->left = n;
    return i;
}
@


\chapter{Checking}

\section{Overview}

\section{Printing warnings, [[8c -w]], [[8c -W]]}

% 8c -w? 
% -W give full verbose diagnostic

<<function warn>>=
void
warn(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    if(debug['w'] || debug['W']) {
        va_start(arg, fmt);
        vseprint(buf, buf+sizeof(buf), fmt, arg);
        va_end(arg);
        if(debug['W']) {
            diag(n, "%s", buf);
            return;
        }
        Bprint(&diagbuf, "warning: %L %s\n", (n==Z)? nearln : n->lineno, buf);

        if(n != Z)
          if(debug['v'])
            prtree(n, "warning");
    }
}
@

<<function fatal>>=
void
fatal(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
      if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    errorexit();
}
@

\section{Symbol resolution}

\section{Typechecking}

<<global types>>=
Type*	types[NTYPE];
@

<<[[Node]] other fields>>=
Type*	type;
@

\section{Lint checks}

% 8c -V enable void* conversion warnings
% 8c -w print warnings


\subsection{[[SET/USED]]}

<<ulstmnt rule>>=
|   LUSED '(' zelist ')' ';' { $$ = new(OUSED, $3, Z); }
|   LSET '(' zelist ')' ';'  { $$ = new(OSET, $3, Z); }
@


<<function usedset>>=
void
usedset(Node *n, int o)
{
    if(n->op == OLIST) {
        usedset(n->left, o);
        usedset(n->right, o);
        return;
    }
    complex(n);
    switch(n->op) {
    case OADDR:	/* volatile */
        gins(ANOP, n, Z);
        break;
    case ONAME:
        if(o == OSET)
            gins(ANOP, Z, n);
        else
            gins(ANOP, n, Z);
        break;
    }
}
@

\chapter{Code Generation}


\section{Overview}
% intermediate language? RTL?

% gbranch, gmove, etc?
% nextpc()?
% gxxx = generate Prog (=~ assembly code)


% remember in cc.y for function definition case:
%        if(!debug['a'] && !debug['Z'])
%            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!

\section{Sizes}
%x86!

% TODO use [xx] extension instead of those comments?
%  but then more complicated to bootstrap with other C compiler?
<<global ewidth>>=
schar	ewidth[NTYPE] =
{
    -1,		/*[TXXX]*/	
    SZ_CHAR,	/*[TCHAR]*/	
    SZ_CHAR,	/*[TUCHAR]*/
    SZ_SHORT,	/*[TSHORT]*/
    SZ_SHORT,	/*[TUSHORT]*/
    SZ_INT,		/*[TINT]*/
    SZ_INT,		/*[TUINT]*/
    SZ_LONG,	/*[TLONG]*/
    SZ_LONG,	/*[TULONG]*/
    SZ_VLONG,	/*[TVLONG]*/
    SZ_VLONG,	/*[TUVLONG]*/
    SZ_FLOAT,	/*[TFLOAT]*/
    SZ_DOUBLE,	/*[TDOUBLE]*/
    SZ_IND,		/*[TIND]*/
    0,		/*[TFUNC]*/
    -1,		/*[TARRAY]*/
    0,		/*[TVOID]*/
    -1,		/*[TSTRUCT]*/
    -1,		/*[TUNION]*/
    SZ_INT,		/*[TENUM]*/
};
@

<<constant SZ_CHAR>>=
/*
 * 8c/386
 * Intel 386
 */
#define	SZ_CHAR		1
@

<<constant SZ_SHORT>>=
#define	SZ_SHORT	2
@

<<constant SZ_INT>>=
#define	SZ_INT		4
@

<<constant SZ_LONG>>=
#define	SZ_LONG		4
@

<<constant SZ_IND>>=
#define	SZ_IND		4
@

<<constant SZ_FLOAT>>=
#define	SZ_FLOAT	4
@

<<constant SZ_VLONG>>=
#define	SZ_VLONG	8
@

<<constant SZ_DOUBLE>>=
#define	SZ_DOUBLE	8
@

\section{Alignment}

\chapter{Optimisations}

% see compcert list of optimisations? there are all of them here too?

\section{Dominators}

\section{Register allocation}
% 8c -r? registerization

\section{Peep optimizer}

\section{Copy propagation}


\section{Arithmetic}
% see also 8c -m, print add/mul/sub trees


\chapter{Object Generation}
%x86!

% target language = Adr, Prog, as, etc, like in Linker and assembler

% outcode, like in Assembler?

\chapter{Assembly Generation}

% 8c -S

% coupling with 8.out.h, but mostly autogenerated enam.c file?
<<global anames>>=
char*	anames[] =
{
    "XXX",
    "AAA",
    "AAD",
    "AAM",
    "AAS",
    "ADCB",
    "ADCL",
    "ADCW",
    "ADDB",
    "ADDL",
    "ADDW",
    "ADJSP",
    "ANDB",
    "ANDL",
    "ANDW",
    "ARPL",
    "BOUNDL",
    "BOUNDW",
    "BSFL",
    "BSFW",
    "BSRL",
    "BSRW",
    "BTL",
    "BTW",
    "BTCL",
    "BTCW",
    "BTRL",
    "BTRW",
    "BTSL",
    "BTSW",
    "BYTE",
    "CALL",
    "CLC",
    "CLD",
    "CLI",
    "CLTS",
    "CMC",
    "CMPB",
    "CMPL",
    "CMPW",
    "CMPSB",
    "CMPSL",
    "CMPSW",
    "DAA",
    "DAS",
    "DATA",
    "DECB",
    "DECL",
    "DECW",
    "DIVB",
    "DIVL",
    "DIVW",
    "ENTER",
    "GLOBL",
    "GOK",
    "HISTORY",
    "HLT",
    "IDIVB",
    "IDIVL",
    "IDIVW",
    "IMULB",
    "IMULL",
    "IMULW",
    "INB",
    "INL",
    "INW",
    "INCB",
    "INCL",
    "INCW",
    "INSB",
    "INSL",
    "INSW",
    "INT",
    "INTO",
    "IRETL",
    "IRETW",
    "JCC",
    "JCS",
    "JCXZ",
    "JEQ",
    "JGE",
    "JGT",
    "JHI",
    "JLE",
    "JLS",
    "JLT",
    "JMI",
    "JMP",
    "JNE",
    "JOC",
    "JOS",
    "JPC",
    "JPL",
    "JPS",
    "LAHF",
    "LARL",
    "LARW",
    "LEAL",
    "LEAW",
    "LEAVEL",
    "LEAVEW",
    "LOCK",
    "LODSB",
    "LODSL",
    "LODSW",
    "LONG",
    "LOOP",
    "LOOPEQ",
    "LOOPNE",
    "LSLL",
    "LSLW",
    "MOVB",
    "MOVL",
    "MOVW",
    "MOVBLSX",
    "MOVBLZX",
    "MOVBWSX",
    "MOVBWZX",
    "MOVWLSX",
    "MOVWLZX",
    "MOVSB",
    "MOVSL",
    "MOVSW",
    "MULB",
    "MULL",
    "MULW",
    "NAME",
    "NEGB",
    "NEGL",
    "NEGW",
    "NOP",
    "NOTB",
    "NOTL",
    "NOTW",
    "ORB",
    "ORL",
    "ORW",
    "OUTB",
    "OUTL",
    "OUTW",
    "OUTSB",
    "OUTSL",
    "OUTSW",
    "POPAL",
    "POPAW",
    "POPFL",
    "POPFW",
    "POPL",
    "POPW",
    "PUSHAL",
    "PUSHAW",
    "PUSHFL",
    "PUSHFW",
    "PUSHL",
    "PUSHW",
    "RCLB",
    "RCLL",
    "RCLW",
    "RCRB",
    "RCRL",
    "RCRW",
    "REP",
    "REPN",
    "RET",
    "ROLB",
    "ROLL",
    "ROLW",
    "RORB",
    "RORL",
    "RORW",
    "SAHF",
    "SALB",
    "SALL",
    "SALW",
    "SARB",
    "SARL",
    "SARW",
    "SBBB",
    "SBBL",
    "SBBW",
    "SCASB",
    "SCASL",
    "SCASW",
    "SETCC",
    "SETCS",
    "SETEQ",
    "SETGE",
    "SETGT",
    "SETHI",
    "SETLE",
    "SETLS",
    "SETLT",
    "SETMI",
    "SETNE",
    "SETOC",
    "SETOS",
    "SETPC",
    "SETPL",
    "SETPS",
    "CDQ",
    "CWD",
    "SHLB",
    "SHLL",
    "SHLW",
    "SHRB",
    "SHRL",
    "SHRW",
    "STC",
    "STD",
    "STI",
    "STOSB",
    "STOSL",
    "STOSW",
    "SUBB",
    "SUBL",
    "SUBW",
    "SYSCALL",
    "TESTB",
    "TESTL",
    "TESTW",
    "TEXT",
    "VERR",
    "VERW",
    "WAIT",
    "WORD",
    "XCHGB",
    "XCHGL",
    "XCHGW",
    "XLAT",
    "XORB",
    "XORL",
    "XORW",
    "FMOVB",
    "FMOVBP",
    "FMOVD",
    "FMOVDP",
    "FMOVF",
    "FMOVFP",
    "FMOVL",
    "FMOVLP",
    "FMOVV",
    "FMOVVP",
    "FMOVW",
    "FMOVWP",
    "FMOVX",
    "FMOVXP",
    "FCOMB",
    "FCOMBP",
    "FCOMD",
    "FCOMDP",
    "FCOMDPP",
    "FCOMF",
    "FCOMFP",
    "FCOML",
    "FCOMLP",
    "FCOMW",
    "FCOMWP",
    "FUCOM",
    "FUCOMP",
    "FUCOMPP",
    "FADDDP",
    "FADDW",
    "FADDL",
    "FADDF",
    "FADDD",
    "FMULDP",
    "FMULW",
    "FMULL",
    "FMULF",
    "FMULD",
    "FSUBDP",
    "FSUBW",
    "FSUBL",
    "FSUBF",
    "FSUBD",
    "FSUBRDP",
    "FSUBRW",
    "FSUBRL",
    "FSUBRF",
    "FSUBRD",
    "FDIVDP",
    "FDIVW",
    "FDIVL",
    "FDIVF",
    "FDIVD",
    "FDIVRDP",
    "FDIVRW",
    "FDIVRL",
    "FDIVRF",
    "FDIVRD",
    "FXCHD",
    "FFREE",
    "FLDCW",
    "FLDENV",
    "FRSTOR",
    "FSAVE",
    "FSTCW",
    "FSTENV",
    "FSTSW",
    "F2XM1",
    "FABS",
    "FCHS",
    "FCLEX",
    "FCOS",
    "FDECSTP",
    "FINCSTP",
    "FINIT",
    "FLD1",
    "FLDL2E",
    "FLDL2T",
    "FLDLG2",
    "FLDLN2",
    "FLDPI",
    "FLDZ",
    "FNOP",
    "FPATAN",
    "FPREM",
    "FPREM1",
    "FPTAN",
    "FRNDINT",
    "FSCALE",
    "FSIN",
    "FSINCOS",
    "FSQRT",
    "FTST",
    "FXAM",
    "FXTRACT",
    "FYL2X",
    "FYL2XP1",
    "END",
    "DYNT",
    "INIT",
    "SIGNAME",
    "FCOMI",
    "FCOMIP",
    "FUCOMI",
    "FUCOMIP",
    "CMPXCHGB",
    "CMPXCHGL",
    "CMPXCHGW",
    "CMOVLCC",
    "CMOVLCS",
    "CMOVLEQ",
    "CMOVLGE",
    "CMOVLGT",
    "CMOVLHI",
    "CMOVLLE",
    "CMOVLLS",
    "CMOVLLT",
    "CMOVLMI",
    "CMOVLNE",
    "CMOVLOC",
    "CMOVLOS",
    "CMOVLPC",
    "CMOVLPL",
    "CMOVLPS",
    "CMOVWCC",
    "CMOVWCS",
    "CMOVWEQ",
    "CMOVWGE",
    "CMOVWGT",
    "CMOVWHI",
    "CMOVWLE",
    "CMOVWLS",
    "CMOVWLT",
    "CMOVWMI",
    "CMOVWNE",
    "CMOVWOC",
    "CMOVWOS",
    "CMOVWPC",
    "CMOVWPL",
    "CMOVWPS",
    "FCMOVCC",
    "FCMOVCS",
    "FCMOVEQ",
    "FCMOVHI",
    "FCMOVLS",
    "FCMOVNE",
    "FCMOVNU",
    "FCMOVUN",
    "LAST",
};
@


<<struct Htab>>=
struct Htab { 
  Sym *sym; 
  short type; 
};
@

<<function outcode>>=
void
outcode(void)
{
    Prog *p;
    Sym *s;
    int f, sf, st, t, sym;
    Biobuf b;
    struct Htab h[NSYM];

    if(debug['S']) {
        for(p = firstp; p != P; p = p->link)
            if(p->as != ADATA && p->as != AGLOBL)
                pc--;
        for(p = firstp; p != P; p = p->link) {
            print("%P\n", p);
            if(p->as != ADATA && p->as != AGLOBL)
                pc++;
        }
    }
    f = open(outfile, OWRITE);
    if(f < 0) {
        diag(Z, "cannot open %s", outfile);
        return;
    }
    Binit(&b, f, OWRITE);
    Bseek(&b, 0L, 2);
    outhist(&b);
    for(sym=0; sym<NSYM; sym++) {
        h[sym].sym = S;
        h[sym].type = 0;
    }
    sym = 1;
    for(p = firstp; p != P; p = p->link) {
    jackpot:
        sf = 0;
        s = p->from.sym;
        while(s != S) {
            sf = s->sym;
            if(sf < 0 || sf >= NSYM)
                sf = 0;
            t = p->from.type;
            if(t == D_ADDR)
                t = p->from.index;
            if(h[sf].type == t)
            if(h[sf].sym == s)
                break;
            s->sym = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            sf = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            break;
        }
        st = 0;
        s = p->to.sym;
        while(s != S) {
            st = s->sym;
            if(st < 0 || st >= NSYM)
                st = 0;
            t = p->to.type;
            if(t == D_ADDR)
                t = p->to.index;
            if(h[st].type == t)
            if(h[st].sym == s)
                break;
            s->sym = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            st = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            if(st == sf)
                goto jackpot;
            break;
        }
        Bputc(&b, p->as);
        Bputc(&b, p->as>>8);
        Bputc(&b, p->lineno);
        Bputc(&b, p->lineno>>8);
        Bputc(&b, p->lineno>>16);
        Bputc(&b, p->lineno>>24);
        zaddr(&b, &p->from, sf);
        zaddr(&b, &p->to, st);
    }
    Bflush(&b);
    close(f);
    firstp = P;
    lastp = P;
}
@

<<function outhist>>=
void
outhist(Biobuf *b)
{
    Hist *h;
    char *p, *q, *op, c;
    Prog pg;
    int n;

    pg = zprog;
    pg.as = AHISTORY;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = utfrune(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(b, ANAME);
                Bputc(b, ANAME>>8);
                Bputc(b, D_FILE);
                Bputc(b, 1);
                Bputc(b, '<');
                Bwrite(b, p, n);
                Bputc(b, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        pg.lineno = h->line;
        pg.to.type = zprog.to.type;
        pg.to.offset = h->offset;
        if(h->offset)
            pg.to.type = D_CONST;

        Bputc(b, pg.as);
        Bputc(b, pg.as>>8);
        Bputc(b, pg.lineno);
        Bputc(b, pg.lineno>>8);
        Bputc(b, pg.lineno>>16);
        Bputc(b, pg.lineno>>24);
        zaddr(b, &pg.from, 0);
        zaddr(b, &pg.to, 0);
    }
}
@

<<function zname>>=
void
zname(Biobuf *b, Sym *s, int t)
{
    char *n;
    ulong sig;

    if(debug['T'] && t == D_EXTERN && s->sig != SIGDONE && s->type != types[TENUM] && s != symrathole){
        sig = sign(s);
        Bputc(b, ASIGNAME);
        Bputc(b, ASIGNAME>>8);
        Bputc(b, sig);
        Bputc(b, sig>>8);
        Bputc(b, sig>>16);
        Bputc(b, sig>>24);
        s->sig = SIGDONE;
    }
    else{
        Bputc(b, ANAME);	/* as */
        Bputc(b, ANAME>>8);	/* as */
    }
    Bputc(b, t);			/* type */
    Bputc(b, s->sym);		/* sym */
    n = s->name;
    while(*n) {
        Bputc(b, *n);
        n++;
    }
    Bputc(b, 0);
}
@

<<function zaddr>>=
void
zaddr(Biobuf *b, Adr *a, int s)
{
    long l;
    int i, t;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    default:
        t |= T_TYPE;
    case D_NONE:
        if(a->offset != 0)
            t |= T_OFFSET;
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    }
    Bputc(b, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(b, a->index);
        Bputc(b, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(b, s);
    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        l = e.h;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(b, *n);
            n++;
        }
        return;
    }
    if(t & T_TYPE)
        Bputc(b, a->type);
}
@


\chapter{Debugging Support}

\section{Acid, [[8c -a]]}

% 8c -a to print acid declarations
%  -n print acid to file
%  -s print structure offsets

\section{Pickle, [[8c -Z]]}

% 8c -Z  and -n create _picke.c

\chapter{Profiling Support}

% actually always true, only way to disable it is via pragma locally
<<global profileflg>>=
bool	profileflg;
@

\chapter{Advanced Topics}

\section{[[#pragma lib]] and automagic linking}

\section{Float}

<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@


\section{64 bits}

\section{Endianness}
% 8c -l, just for mips => switch from vc to 0c


\section{Processing multiple files}

\chapter{Conclusion}

\appendix

\chapter{Debugging}

<<global debug>>=
char	debug[256];
@

\section{[[Fmt]]}

\subsection{[[cc/]]}

<<function Oconv>>=
// enum<node_kind> -> string
int Oconv(Fmt *fp)
{
    int a;

    a = va_arg(fp->args, int);
    if(a < OXXX || a > OEND)
        return fmtprint(fp, "***badO %d***", a);

    return fmtstrcpy(fp, onames[a]);
}
@

<<global onames>>=
char*	onames[OEND+1];
@

<<global onamesinit>>=
Init	onamesinit[] =
{
    OXXX,		0,	"OXXX",
    OADD,		0,	"ADD",
    OADDR,		0,	"ADDR",
    OAND,		0,	"AND",
    OANDAND,	0,	"ANDAND",
    OARRAY,		0,	"ARRAY",
    OAS,		0,	"AS",
    OASI,		0,	"ASI",
    OASADD,		0,	"ASADD",
    OASAND,		0,	"ASAND",
    OASASHL,	0,	"ASASHL",
    OASASHR,	0,	"ASASHR",
    OASDIV,		0,	"ASDIV",
    OASHL,		0,	"ASHL",
    OASHR,		0,	"ASHR",
    OASLDIV,	0,	"ASLDIV",
    OASLMOD,	0,	"ASLMOD",
    OASLMUL,	0,	"ASLMUL",
    OASLSHR,	0,	"ASLSHR",
    OASMOD,		0,	"ASMOD",
    OASMUL,		0,	"ASMUL",
    OASOR,		0,	"ASOR",
    OASSUB,		0,	"ASSUB",
    OASXOR,		0,	"ASXOR",
    OBIT,		0,	"BIT",
    OBREAK,		0,	"BREAK",
    OCASE,		0,	"CASE",
    OCAST,		0,	"CAST",
    OCOMMA,		0,	"COMMA",
    OCOND,		0,	"COND",
    OCONST,		0,	"CONST",
    OCONTINUE,	0,	"CONTINUE",
    ODIV,		0,	"DIV",
    ODOT,		0,	"DOT",
    ODOTDOT,	0,	"DOTDOT",
    ODWHILE,	0,	"DWHILE",
    OENUM,		0,	"ENUM",
    OEQ,		0,	"EQ",
    OFOR,		0,	"FOR",
    OFUNC,		0,	"FUNC",
    OGE,		0,	"GE",
    OGOTO,		0,	"GOTO",
    OGT,		0,	"GT",
    OHI,		0,	"HI",
    OHS,		0,	"HS",
    OIF,		0,	"IF",
    OIND,		0,	"IND",
    OINDREG,	0,	"INDREG",
    OINIT,		0,	"INIT",
    OLABEL,		0,	"LABEL",
    OLDIV,		0,	"LDIV",
    OLE,		0,	"LE",
    OLIST,		0,	"LIST",
    OLMOD,		0,	"LMOD",
    OLMUL,		0,	"LMUL",
    OLO,		0,	"LO",
    OLS,		0,	"LS",
    OLSHR,		0,	"LSHR",
    OLT,		0,	"LT",
    OMOD,		0,	"MOD",
    OMUL,		0,	"MUL",
    ONAME,		0,	"NAME",
    ONE,		0,	"NE",
    ONOT,		0,	"NOT",
    OOR,		0,	"OR",
    OOROR,		0,	"OROR",
    OPOSTDEC,	0,	"POSTDEC",
    OPOSTINC,	0,	"POSTINC",
    OPREDEC,	0,	"PREDEC",
    OPREINC,	0,	"PREINC",
    OPROTO,		0,	"PROTO",
    OREGISTER,	0,	"REGISTER",
    ORETURN,	0,	"RETURN",
    OSET,		0,	"SET",
    OSIGN,		0,	"SIGN",
    OSIZE,		0,	"SIZE",
    OSTRING,	0,	"STRING",
    OLSTRING,	0,	"LSTRING",
    OSTRUCT,	0,	"STRUCT",
    OSUB,		0,	"SUB",
    OSWITCH,	0,	"SWITCH",
    OUNION,		0,	"UNION",
    OUSED,		0,	"USED",
    OWHILE,		0,	"WHILE",
    OXOR,		0,	"XOR",
    OPOS,		0,	"POS",
    ONEG,		0,	"NEG",
    OCOM,		0,	"COM",
    OELEM,		0,	"ELEM",
    OTST,		0,	"TST",
    OINDEX,		0,	"INDEX",
    OFAS,		0,	"FAS",
    OREGPAIR,	0,	"REGPAIR",
    OEXREG,		0,	"EXREG",
    OEND,		0,	"END",
    -1,		0,	0,
};
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

% location?
<<function Lconv>>=
// int -> string?
int
Lconv(Fmt *fp)
{
    char str[STRINGSZ], s[STRINGSZ];
    Hist *h;
    long l, d;
    int i, n;
    struct Atab  a[HISTSZ];

    l = va_arg(fp->args, long);
    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset != 0) {		/* #line directive, not #pragma */
                if(n > 0 && n < HISTSZ && h->offset >= 0) {
                    a[n-1].line = h;
                    a[n-1].ldel = h->line - h->offset + 1;
                }
            } else {
                if(n < HISTSZ) {	/* beginning of file */
                    a[n].incl = h;
                    a[n].idel = h->line;
                    a[n].line = 0;
                }
                n++;
            }
            continue;
        }
        n--;
        if(n > 0 && n < HISTSZ) {
            d = h->line - a[n].incl->line;
            a[n-1].ldel += d;
            a[n-1].idel += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    str[0] = 0;
    for(i=n-1; i>=0; i--) {
        if(i != n-1) {
            if(fp->flags & ~(FmtWidth|FmtPrec))	/* BUG ROB - was f3 */
                break;
            strcat(str, " ");
        }
        if(a[i].line)
            snprint(s, STRINGSZ, "%s:%ld[%s:%ld]",
                a[i].line->name, l-a[i].ldel+1,
                a[i].incl->name, l-a[i].idel+1);
        else
            snprint(s, STRINGSZ, "%s:%ld",
                a[i].incl->name, l-a[i].idel+1);
        if(strlen(s)+strlen(str) >= STRINGSZ-10)
            break;
        strcat(str, s);
        l = a[i].incl->line - 1;	/* now print out start of this file */
    }
    if(n == 0)
        strcat(str, "<eof>");
    return fmtstrcpy(fp, str);
}
@

<<function Tconv>>=
// option<Type> -> string
int
Tconv(Fmt *fp)
{
    char str[STRINGSZ+20], s[STRINGSZ+20];
    Type *t, *t1;
    int et;
    long n;

    str[0] = 0;
    for(t = va_arg(fp->args, Type*); t != T; t = t->link) {
        et = t->etype;
        if(str[0])
            strcat(str, " ");
        if(t->garb&~GINCOMPLETE) {
            sprint(s, "%s ", gnames[t->garb&~GINCOMPLETE]);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        sprint(s, "%s", tnames[et]);
        if(strlen(str) + strlen(s) < STRINGSZ)
            strcat(str, s);
        if(et == TFUNC && (t1 = t->down)) {
            sprint(s, "(%T", t1);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
            while(t1 = t1->down) {
                sprint(s, ", %T", t1);
                if(strlen(str) + strlen(s) < STRINGSZ)
                    strcat(str, s);
            }
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, ")");
        }
        if(et == TARRAY) {
            n = t->width;
            if(t->link && t->link->width)
                n /= t->link->width;
            sprint(s, "[%ld]", n);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(t->nbits) {
            sprint(s, " %d:%d", t->shift, t->nbits);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(typesu[et]) {
            if(t->tag) {
                strcat(str, " ");
                if(strlen(str) + strlen(t->tag->name) < STRINGSZ)
                    strcat(str, t->tag->name);
            } else
                strcat(str, " {}");
            break;
        }
    }
    return fmtstrcpy(fp, str);
}
@

<<global tnames>>=
char*	tnames[NALLTYPES];
@

<<global tnamesinit>>=
Init	tnamesinit[] =
{
    TXXX,		0,	"TXXX",

    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,	0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,	0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,	0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,	0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",
    TFILE,		0,	"FILE",
    TOLD,		0,	"OLD",
    TDOT,		0,	"DOT",

    -1,		0,	0,
};
@



<<function FNconv>>=
// option<Node identifier cases> -> string
int
FNconv(Fmt *fp)
{
    char *str;
    Node *n;

    n = va_arg(fp->args, Node*);
    str = "<indirect>";
    if(n != Z && (n->op == ONAME || n->op == ODOT || n->op == OELEM))
        str = n->sym->name;
    return fmtstrcpy(fp, str);
}
@

<<function Qconv>>=
// ??
int
Qconv(Fmt *fp)
{
    char str[STRINGSZ+20], *s;
    long b;
    int i;

    str[0] = 0;
    for(b = va_arg(fp->args, long); b;) {
        i = bitno(b);
        if(str[0])
            strcat(str, " ");
        s = qnames[i];
        if(strlen(str) + strlen(s) >= STRINGSZ)
            break;
        strcat(str, s);
        b &= ~(1L << i);
    }
    return fmtstrcpy(fp, str);
}
@

<<function VBconv>>=
// ??
int
VBconv(Fmt *fp)
{
    char str[STRINGSZ];
    int i, n, t, pc;

    n = va_arg(fp->args, int);
    pc = 0;	/* BUG: was printcol */
    i = 0;
    while(pc < n) {
        t = (pc+4) & ~3;
        if(t <= n) {
            str[i++] = '\t';
            pc = t;
            continue;
        }
        str[i++] = ' ';
        pc++;
    }
    str[i] = '\0';

    return fmtstrcpy(fp, str);
}
@

\subsection{[[8c/]]}

% similar to Assembler.tex.nw?

<<function listinit>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('B', Bconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('D', Dconv);
    fmtinstall('R', Rconv);
}
@

<<function Bconv>>=
// Bits -> string
int
Bconv(Fmt *fp)
{
    char str[STRINGSZ], ss[STRINGSZ], *s;
    Bits bits;
    int i;

    str[0] = 0;
    bits = va_arg(fp->args, Bits);
    while(bany(&bits)) {
        i = bnum(bits);
        if(str[0])
            strcat(str, " ");
        if(var[i].sym == S) {
            snprint(ss, sizeof(ss), "$%ld", var[i].offset); //$
            s = ss;
        } else
            s = var[i].sym->name;
        if(strlen(str) + strlen(s) + 1 >= STRINGSZ)
            break;
        strcat(str, s);
        bits.b[i/32] &= ~(1L << (i%32)); // >>
    }
    return fmtstrcpy(fp, str);
}
@

% for assembly generation?
<<function Pconv>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    if(p->as == ADATA)
        snprint(str, sizeof(str), "	%A	%D/%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else if(p->as == ATEXT)
        snprint(str, sizeof(str), "	%A	%D,%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else
        snprint(str, sizeof(str), "	%A	%D,%D",
            p->as, &p->from, &p->to);
    return fmtstrcpy(fp, str);
}
@
% why not switch?

<<function Aconv>>=
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@
% anames in Assembly section

<<function Dconv>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[40], s[20];
    Adr *a;
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;
    if(i >= D_INDIR) {
        if(a->offset)
            snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
        else
            snprint(str, sizeof(str), "(%R)", i-D_INDIR);
        goto brk;
    }
    switch(i) {

    default:
        if(a->offset)
            snprint(str, sizeof(str), "$%ld,%R", a->offset, i); // $
        else
            snprint(str, sizeof(str), "%R", i);
        break;

    case D_NONE:
        str[0] = '\0';
        break;

    case D_BRANCH:
        snprint(str, sizeof(str), "%ld(PC)", a->offset-pc);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<>+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;

    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;


    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset); //$
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$(%.17e)", a->dval); //$
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->sval); //$
        break;


    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a); //$
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;
    }
brk:
    if(a->index != D_NONE) {
        fmtstrcpy(fp, str);
        snprint(s, sizeof(s), "(%R*%d)", (int)a->index, (int)a->scale);
        return fmtstrcpy(fp, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@

<<global regstr>>=
char*	regstr[] =
{
    "AL",	/*[D_AL]*/	
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",	/*[D_AX]*/
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",	/*[D_F0]*/
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",	/*[D_CS]*/
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",	/*[D_GDTR]*/
    "IDTR",	/*[D_IDTR]*/
    "LDTR",	/*[D_LDTR]*/
    "MSW",	/*[D_MSW] */
    "TASK",	/*[D_TASK]*/

    "CR0",	/*[D_CR]*/
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",	/*[D_DR]*/
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",	/*[D_TR]*/
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",	/*[D_NONE]*/
};
@

<<function Rconv>>=
// enum<operand_kind(register-only)> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@

<<function Sconv>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@


\section{[[prxxx()]]}

<<function prtree>>=
void
prtree(Node *n, char *s)
{

    print(" == %s ==\n", s);
    prtree1(n, 0, false);
    print("\n");
}
@

<<function prtree1>>=
void
prtree1(Node *n, int d, bool f)
{
    int i;

    if(f)
      for(i=0; i<d; i++)
        print("   ");
    if(n == Z) {
        print("Z\n");
        return;
    }
    if(n->op == OLIST) {
        prtree1(n->left, d, false);
        prtree1(n->right, d, true);
        return;
    }
    d++;
    print("%O", n->op);
    i = 3; // 1 || 2
    switch(n->op) {
    case ONAME:
        print(" \"%F\"", n);
        print(" %ld", n->xoffset);
        i = 0;
        break;

    case OINDREG:
        print(" %ld(R%d)", n->xoffset, n->reg);
        i = 0;
        break;

    case OREGISTER:
        if(n->xoffset)
            print(" %ld+R%d", n->xoffset, n->reg);
        else
            print(" R%d", n->reg);
        i = 0;
        break;

    case OSTRING:
        print(" \"%s\"", n->cstring);
        i = 0;
        break;

    case OLSTRING:
        if(sizeof(TRune) == sizeof(Rune))
            print(" \"%S\"", (Rune*)n->rstring);
        else
            print(" \"...\"");
        i = 0;
        break;

    case ODOT:
    case OELEM:
        print(" \"%F\"", n);
        break;

    case OCONST:
        if(typefd[n->type->etype])
            print(" \"%.8e\"", n->fconst);
        else
            print(" \"%lld\"", n->vconst);
        i = 0;
        break;
    }
    if(n->addable != 0)
        print(" <%d>", n->addable);
    if(n->type != T)
        print(" %T", n->type);
    if(n->complex != 0)
        print(" (%d)", n->complex);

    print(" %L\n", n->lineno);

    if(i & 2)
        prtree1(n->left, d, true);
    if(i & 1)
        prtree1(n->right, d, true);
}
@


\section{[[8c -v]], verbose mode}

% see diag(), with -v it will print == diagnostic == and then the ast dump

\section{[[8c -m]], macro debugging}

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[8c -f]], line information debugging}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(offset)
            print("%4ld: %s (#line %d)\n", lineno, f, offset);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

\section{[[8c -L]], printing names}

\section{[[8c -d]], printing declarations}
% useful to debug, potentially useful to build tools too! e.g. tags file

% labels
<<function dbgdecl>>=
void
dbgdecl(Sym *s)
{
    print("decl \"%s\": C=%s [B=%d:O=%ld] T=%T\n",
        s->name, cnames[s->class], s->block, s->offset, s->type);
}
@


\section{[[8c -t]], printing type trees}

\section{[[8c -i]], printing initializations}

\section{[[8c -m]], printing arithmetic trees}

\section{[[8c -r]], printing registerization}

\chapter{Error Managment}

<<global nerrors>>=
int	nerrors;
@

<<function errorexit>>=
void
errorexit(void)
{
    if(outfile)
        remove(outfile);
    exits("error");
}
@


<<function yyerror>>=
void
yyerror(char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(fmt, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", lineno, buf);
    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@


<<function diag>>=
void
diag(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
      if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@


\chapter{Libc}

\section{Memory managment}
% same in Linker/assembler, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<constant NHUNK>>=
#define	NHUNK		50000L
@

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk;
@

<<global thunk>>=
long	thunk;
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }
    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {
        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;
    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


<<function malloc>>=
/*
 * fake mallocs
 */
void*
malloc(ulong n)
{
    return alloc(n);
}
@

% hmm so no free ... maybe ok in a compiler context?
<<function free>>=
void
free(void*)
{
}
@

<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void*, ulong)
{
}
@


\section{String managment}

% STRINGSZ here

\section{Mathematic functions}

<<function log2>>=
/*
 * return log(n) if n is a power of 2 constant
 */
int
log2(uvlong v)
{
    int s, i;
    uvlong m;

    s = 0;
    m = MASK(8*sizeof(uvlong));
    for(i=32; i; i>>=1) {
        m >>= i;
        if(!(v & m)) {
            v >>= i;
            s += i;
        }
    }
    if(v == 1)
        return s;
    return -1;
}
@

\chapter{Extra Code}

\ifallcode
#include "Compiler_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

