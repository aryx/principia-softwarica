\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   saw cc/pgen.c depends on gc.h! so not same category than cc/bits.c => cc2/
%   (harder to understand non layered code)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)
% - use scheck to remove deadcode useless export, or mv as forward decl
%   (harder to understand big interface files)
% - see duplication between cc.h and aa.h

%thx to this manual, better understand compilers:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog to see what flows into fields
% - TODO nullify, boolify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 C Compiler
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a C compiler.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present 8c, aka kencc, from ken thompson!

% some cons though: no IL ... very imperative ... harder case to defend
% than for the other software (8a, 8l, kernel, rio)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item tiger
% not real, not C, but more educatif and better written for teaching purpose
% (actually can refer to govereau book?)
\item lcc 
%maybe better actually, but already a book on it
% also use a grammar? or handwritten?
\item compcert
% harder to understand coq :)
\item tinycc, fbcc
\item gcc
%big
\item clang
%cleaner but still very big
% nice single binary that can cross compile for multiple targets, nice
% interface (cleaner than 8c, 5c, vc, etc, interfaces are better!)
\end{itemize}

% TODO bench 8c vs gcc and clang on benchmarks!

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

% ken :)
% mireille ducasse, marie jo pedrono
% Aho, appel

\chapter{Overview}

\section{Compiler principles}

% from high level to low level (asm). 
% expression like x+y*z decomposed into multi mov, add, etc. Fortran!
% same for data, complex decomposed into smaller bytes, with symbolic names
%  for subparts, e.g. fields.
% statements, more structured forms than jmp.
% types! type checking!

% innovation of C vs fortran/pascal/algol? simpler?

\section{[[8c]] services}

% see all the flags, put here main flags

\section{[[helloworld.c]]}

\section{Input C language}

% mostly ANSI C. a few extension
% see K&R book

\section{Output object format}

% assembly x86 object code. Not really machine code, and not asm
% (even though can get asm via 8c -S)

% put code for helloworld.c? (at least put an arithmetic expression?)

\section{x86}

\section{Code organization}

% use a lot 386/8.out.h
% and actually stuff defined in 8.out.h are used
% exclusively by 8c e.g. enum misc3 with REGRET, REGTMP, etc

% cc.h (vs gc.h (not garbage collector, g for? nongeneric? hmmm))
% no lex (handcrafted lex.c), yacc (cc.y, y.tab.h, y.tab.c)
%  (why no lex? to avoid bootstrapping issues?)
%  mac.c = macro (included cpp)
% globals.c, utils.c, compat.c

% sub.c = subroutines, helpers to build ast (and more?)

% bits.c, 
% pickle.c

% acid.c = debugger support

% dpchk.c? pragma related? dpchk? check something? directive pragma check?

% com.c = compile (not comment), com64 for 64 bits stuff (for vlong)
%  dcl.c = declarations (dodecl, xdecl, adecl, markdcl/revertdcl, etc)
%  funct.c = ?? seems related to typestr
%  swt.c = switch? (pswt = portable part of switch handling)
%   (but then why outcode, outhist is in this file? TODO move it elsewhere!)
%  scon.c =  ? constants expr? s?

% -----------

% gc.h (g??)
% globals2.c
% list.c = fmt.c (TODO rename)
% machcap.c, omachcap.c = machine capability (attempt to have interface)

% txt.c?
% peep = peep optimizer?
% xxxgen = sgen? cgen? (pgen.c = portable part of gen? sgen? cgen?)
% mul.c, div.c
% reg.c = register?



% a few conventions? see glossary?
% SUE = struct union enum

\section{Architecture overview}

% see lex.c#main()! have command line flags in comment

% lexer -> preprocessor -> parser -> ast -> visit and gen
% with optimisations done?
% no IL? register allocator? peep optimizer?
% vs tiger book?

% main -> compile -> yyparse -> yylex -> macxxx
%                            -> codgen (portable) -> gen


%###############################################################################

\chapter{Core Data Structures}

\section{Abstract syntax tree, [[Node]] and [[Type]]}

% vs what I have in ast_c.ml?

\subsection{[[Node]]}
% = expr + stmt + type defs + decl + func def?

% todo: LP reorg, purely internal to cc, not marshalled, so safe to reorder
% (as opposed to 8a)
<<enum node_kind>>=
enum node_kind
{
    OXXX,

    OADD,
    OADDR,
    OAND,
    OANDAND,

    OARRAY, // used for array decl and designator initializer array

    OAS,
    OASI,
    OASADD,
    OASAND,
    OASASHL,
    OASASHR,
    OASDIV,
    OASHL,
    OASHR,
    OASLDIV,
    OASLMOD,
    OASLMUL,
    OASLSHR,
    OASMOD,
    OASMUL,
    OASOR,
    OASSUB,
    OASXOR,
    OBIT,
    OBREAK,
    OCASE, // for default too, in which case Node.left is null
    OCAST,
    OCOMMA,
    OCOND,
    OCONST,
    OCONTINUE,
    ODIV,

    ODOT,

    ODOTDOT,
    ODWHILE,
    OENUM,
    OEQ,
    OFOR,

    OFUNC, // used for calls but also proto decls :(

    OGE,
    OGOTO,
    OGT,
    OHI,
    OHS,
    OIF,
    OIND,
    OINDREG,
    OINIT,
    OLABEL,
    OLDIV,
    OLE,
    OLIST, // of stmts, labels, sometimes also used for pairs, triples, etc
    OLMOD,
    OLMUL,
    OLO,
    OLS,
    OLSHR,
    OLT,
    OMOD,
    OMUL,

    ONAME,

    ONE,
    ONOT,
    OOR,
    OOROR,
    OPOSTDEC,
    OPOSTINC,
    OPREDEC,
    OPREINC,
    OPROTO,

    OREGISTER, // after parsing only?

    ORETURN,
    OSET,
    OSIGN,
    OSIZE,
    OSTRING,
    OLSTRING,
    OSTRUCT,
    OSUB,
    OSWITCH,
    OUNION,
    OUSED,
    OWHILE,
    OXOR,
    ONEG,
    OCOM,
    OPOS,

    OELEM, // field designator

    OTST,		/* used in some compilers */
    OINDEX,
    OFAS,
    OREGPAIR,
    OEXREG,

    OEND
};
@

% ONAME, ODOT, OELEM => use FNconv

% char -> byte? or actually char sometimes when use '+' ?
% hmm get some warnings though when do that, but maybe should fix those 
% warnings anyway
<<struct Node>>=
struct	Node
{
    // enum<node_kind>
    char	op;

    // option<ref_own<Node>>
    Node*	left;
    // option<ref_own<Node>>
    Node*	right;

    // could be put in a union
    vlong	vconst;		/* non fp const */ // abused in switch?
    double	fconst;		/* fp constant */

    char*	cstring;	/* character string */ // also used for ints
    TRune*	rstring;	/* rune string */

    long	lineno;

    <<[[Node]] other fields>>
};
@
% see also prtree() in debugging section to dump the ast

% left/right used for many things, for left/right branch in e.g.
% arithmetic trees (a+b), but also for linked list (e.g. OLIST) with
% double chaining

% important field! typechecking! set in parsing when can
% (e.g. for cast where have type, for return where have also spec)
<<[[Node]] other fields>>=
Type*	type;
@
% so it's more than an AST actually, have semantic info attached to it
% by other phases

% inline of type->etype? char->byte?
<<[[Node]] other fields>>=
// enum<type_kind>, inline of Node.type->etype?
char	etype;
@


% storage class
<<enum cxxx>>=
enum
{
    CXXX, // nothing specified
    CAUTO,
    CEXTERN,
    CGLOBL,
    CSTATIC,

    CLOCAL,

    CTYPEDEF,
    CTYPESTR,

    CPARAM,
    CSELEM,
    CLABEL,

    CEXREG, // extern register, kencc ext (used in kernel for mips)

    NCTYPES,
};
@
% CSTATIC vs TSTATIC vs BSTATIC

<<global cnames>>=
char*	cnames[NCTYPES];
@

<<global cnamesinit>>=
Init	cnamesinit[] =
{
    CXXX,		0,	"CXXX",
    CAUTO,		0,	"AUTO",
    CEXTERN,		0,	"EXTERN",
    CGLOBL,		0,	"GLOBL",
    CSTATIC,		0,	"STATIC",
    CLOCAL,		0,	"LOCAL",
    CTYPEDEF,		0,	"TYPEDEF",
    CTYPESTR,		0,	"TYPESTR",
    CPARAM,		0,	"PARAM",
    CSELEM,		0,	"SELEM",
    CLABEL,		0,	"LABEL",
    CEXREG,		0,	"EXREG",
    -1,			0,	0,
};
@


<<[[Node]] other fields>>=
// enum<cxxx>
char	class;
@


% when the node involves a symbol (entity used, field access, ONAME ODOT)
% (and should have mutual reciproque?)
<<[[Node]] other fields>>=
Sym*	sym; 
@
% see Sym later










<<constant Z>>=
#define	Z	((Node*)nil)
@


% int -> char ... for op, hmmm
<<function new>>=
Node*
new(int t, Node *l, Node *r)
{
    Node *n;

    n = alloc(sizeof(Node));
    n->op = t;
    n->left = l;
    n->right = r;

    if(l && t != OGOTO)
        n->lineno = l->lineno;
    else if(r)
        n->lineno = r->lineno;
    else
        n->lineno = lineno;

    newflag = true;
    return n;
}
@

<<global lineno>>=
long	lineno;
@


<<global nearln>>=
long	nearln;
@

<<function new1>>=
Node*
new1(int o, Node *l, Node *r)
{
    Node *n;

    n = new(o, l, r);
    n->lineno = nearln;
    return n;
}
@






<<[[Node]] other fields>>=
void*	label;

long	pc;
int	reg;
long	xoffset;

char	oldop;

// (ab)used as bool for marker of label def (true) vs use (false),
// FNX special value, register allocation value, etc
char	complex; 

char	scale;
char	garb;
@




\subsection{[[Type]]}

% split? hmm but would not work with enum<bxxx> then, ugly but
% because of the way they handle type/qualifier/storage they all
% have to be in the same enum (ugly)
<<enum type_kind>>=
enum type_kind
{
    TXXX,

    // type cases
    TCHAR,
    TUCHAR,
    TSHORT,
    TUSHORT,
    TINT,
    TUINT,
    TLONG,
    TULONG,
    TVLONG,
    TUVLONG,
    TFLOAT,
    TDOUBLE,

    TIND,
    TFUNC,
    TARRAY,
    TVOID,
    TSTRUCT,
    TUNION,
    TENUM,

    TDOT, // ??
    NTYPE,

    // storage class cases
    TAUTO	= NTYPE,

    TEXTERN,
    TSTATIC,
    TTYPEDEF, // ugly, not really a storage class
    TTYPESTR,
    TREGISTER,

    // qualifier cases
    TCONSTNT,
    TVOLATILE,

    // other cases
    TUNSIGNED,
    TSIGNED,

    // ????
    TFILE,
    TOLD,

    NALLTYPES,

    /* adapt size of Rune to target system's size */
    TRUNE = sizeof(TRune)==4? TUINT: TUSHORT,
};
@

<<global qnames>>=
char*	qnames[NALLTYPES];
@

<<global qnamesinit>>=
Init	qnamesinit[] =
{
    TXXX,		0,	"TXXX",

    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,		0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,		0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,		0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,		0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",

    TAUTO,		0,	"AUTO",
    TEXTERN,		0,	"EXTERN",
    TSTATIC,		0,	"STATIC",
    TTYPEDEF,		0,	"TYPEDEF",
    TTYPESTR,		0,	"TYPESTR",
    TREGISTER,		0,	"REGISTER",
    TCONSTNT,		0,	"CONSTNT",
    TVOLATILE,		0,	"VOLATILE",
    TUNSIGNED,		0,	"UNSIGNED",
    TSIGNED,		0,	"SIGNED",
    TDOT,		0,	"DOT",
    TFILE,		0,	"FILE",
    TOLD,		0,	"OLD",

    -1,		0,	0,
};
@



% see also enum bxxx which is used only in grammar I think,
% and seems to be a 64 bits bitset of the types above

% char -> byte? but get some warnings (but we should fix that too)
<<struct Type>>=
struct	Type
{
    // enum<type_kind>  (the type cases only?)
    char	etype;

    // option<ref_own<Type>, e.g. for '*int' have TIND -link-> TINT
    Type*	link;

    // ??
    Type*	down;

    long	lineno;

    <<[[Type]] other fields>>
};
@
%link is empty at first for structure tag forward decl, but set when
% have the actual structure def fields
% contain storage class info too? and qualifier too?

% for TFUNC, how is the return and how are the parameters? via link and
% down?

% gxxx for 'garbage' but should be renamed qualifier
<<enum gxxx>>=
enum gxxx
{
    GXXX		= 0,
    GCONSTNT	= 1<<0,
    GVOLATILE	= 1<<1,

    NGTYPES		= 1<<2,
    GINCOMPLETE	= 1<<2,
};
@
% >> >> >> >>

<<global gnames>>=
char*	gnames[NGTYPES];
@

<<global gnamesinit>>=
Init	gnamesinit[] =
{
    GXXX,		0,	"GXXX",
    GCONSTNT,		0,	"CONST",
    GVOLATILE,		0,	"VOLATILE",
    GVOLATILE|GCONSTNT,	0,	"CONST-VOLATILE",
    -1,			0,	0,
};
@



%// garbage? rename qualifier?
<<[[Type]] other fields>>=
char	garb;
@

% storage class is not there! should be in Decl instead?

% when type involves a symbol, e.g. for tags in struct/union/enum
<<[[Type]] other fields>>=
Sym*	sym;
@



<<constant T>>=
#define	T	((Type*)nil)
@

% constructor
<<function typ>>=
Type*
typ(int et, Type *d)
{
    Type *t;

    t = alloc(sizeof(Type));
    t->etype = et;
    t->link = d;
    t->down = T;
    t->garb = 0;
    t->sym = S;

    t->width = ewidth[et];
    t->offset = 0;
    t->shift = 0;
    t->nbits = 0;

    return t;
}
@
% see Size section for ewidth, LP split!

<<function copytyp>>=
Type*
copytyp(Type *t)
{
    Type *nt;

    nt = typ(TXXX, T); // could just do alloc(sizeof(Type))
    *nt = *t;
    return nt;
}
@


<<global types>>=
Type*	types[NTYPE];
@


<<[[cinit()]] types initialization>>=
types[TXXX] = T;

types[TCHAR] = typ(TCHAR, T);
types[TUCHAR] = typ(TUCHAR, T);
types[TSHORT] = typ(TSHORT, T);
types[TUSHORT] = typ(TUSHORT, T);
types[TINT] = typ(TINT, T);
types[TUINT] = typ(TUINT, T);
types[TLONG] = typ(TLONG, T);
types[TULONG] = typ(TULONG, T);
types[TVLONG] = typ(TVLONG, T);
types[TUVLONG] = typ(TUVLONG, T);
types[TFLOAT] = typ(TFLOAT, T);
types[TDOUBLE] = typ(TDOUBLE, T);
types[TVOID] = typ(TVOID, T);
types[TENUM] = typ(TENUM, T);
types[TFUNC] = typ(TFUNC, types[TINT]);
types[TIND] = typ(TIND, types[TVOID]);
@


<<global tfield>>=
Type*	tfield;
@
% and init code in cinit or tinit

<<global tufield>>=
Type*	tufield;
@




<<global typei>>=
char	typei[NTYPE];
@

<<global typeiinit>>=
int	typeiinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TVLONG, TUVLONG, -1,
};
@


<<global typeu>>=
char	typeu[NTYPE];
@

<<global typeuinit>>=
int	typeuinit[] =
{
    TUCHAR, TUSHORT, TUINT, TULONG, TUVLONG, TIND, -1,
};
@



<<global typeilp>>=
char	typeilp[NTYPE];
@

<<global typeilpinit>>=
int	typeilpinit[] =
{
    TINT, TUINT, TLONG, TULONG, TIND, -1
};
@



<<global typechlpfd>>=
char	typechlpfd[NTYPE];
@

<<global typechlpfdinit>>=
int	typechlpfdinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TFLOAT, TDOUBLE, TIND, -1,
};
@





<<global typec>>=
char	typec[NTYPE];
@

<<global typecinit>>=
int	typecinit[] =
{
    TCHAR, TUCHAR, -1
};
@



<<global typeh>>=
char	typeh[NTYPE];
@

<<global typehinit>>=
int	typehinit[] =
{
    TSHORT, TUSHORT, -1,
};
@




<<global typeil>>=
char	typeil[NTYPE];
@

<<global typeilinit>>=
int	typeilinit[] =
{
    TINT, TUINT, TLONG, TULONG, -1,
};
@



<<global typev>>=
char	typev[NTYPE];
@

<<global typevinit>>=
int	typevinit[] =
{
    TVLONG,	TUVLONG, -1,
};
@





<<global typefd>>=
char	typefd[NTYPE];
@

<<global typefdinit>>=
int	typefdinit[] =
{
    TFLOAT, TDOUBLE, -1,
};
@



<<global typeaf>>=
char	typeaf[NTYPE];
@

<<global typeafinit>>=
int	typeafinit[] =
{
    TFUNC, TARRAY, -1,
};
@




<<global typesu>>=
char	typesu[NTYPE];
@

<<global typesuinit>>=
int	typesuinit[] =
{
    TSTRUCT, TUNION, -1,
};
@





% set of type supported for switch argument
% todo use array of bool instead
<<global typeswitch>>=
// set<txxx>
char*	typeswitch;
@

<<global typeword>>=
// set<txxx>
char*	typeword;
@

% set of complex types
<<global typecmplx>>=
// set<txxx>
char*	typecmplx;
@

%    /* 32-bit defaults */
%    typeword = typechlp;
%    typeswitch = typechl;
%    typecmplx = typesuv;



<<global typechl>>=
char	typechl[NTYPE];
@

<<global typechlv>>=
char	typechlv[NTYPE];
@

<<global typechlvp>>=
char typechlvp[NTYPE];
@

<<global typechlinit>>=
int	typechlinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, -1,
};
@






<<global typechlp>>=
char	typechlp[NTYPE];
@

<<global typechlpinit>>=
int	typechlpinit[] =
{
    TCHAR, TUCHAR, TSHORT, TUSHORT, TINT, TUINT, TLONG, TULONG, TIND, -1,
};
@
% added TIND!




<<global typesuv>>=
// bool
char	typesuv[NTYPE];
@

<<global typesuvinit>>=
int	typesuvinit[] =
{
    TVLONG, TUVLONG, TSTRUCT, TUNION, -1,
};
@






<<function sametype>>=
bool
sametype(Type *t1, Type *t2)
{

    if(t1 == t2)
        return true;
    return rsametype(t1, t2, 5, 1);
}
@

% n = depth? so equal modulo a certain depth?? hmmm
<<function rsametype>>=
bool
rsametype(Type *t1, Type *t2, int n, int f)
{
    int et;

    n--;
    for(;;) {
        if(t1 == t2)
            return true;
        if(t1 == T || t2 == T)
            return false;
        if(n <= 0)
            return true;
        et = t1->etype;
        if(et != t2->etype)
            return false;

        if(et == TFUNC) {
            if(!rsametype(t1->link, t2->link, n, 0))
                return false;
            t1 = t1->down;
            t2 = t2->down;
            while(t1 != T && t2 != T) {
                if(t1->etype == TOLD) {
                    t1 = t1->down;
                    continue;
                }
                if(t2->etype == TOLD) {
                    t2 = t2->down;
                    continue;
                }
                while(t1 != T || t2 != T) {
                    if(!rsametype(t1, t2, n, 0))
                        return false;
                    t1 = t1->down;
                    t2 = t2->down;
                }
                break;
            }
            return true;
        }
        if(et == TARRAY)
            if(t1->width != t2->width && t1->width != 0 && t2->width != 0)
                return false;
        if(typesu[et]) {
            if(t1->link == T)
                snap(t1);
            if(t2->link == T)
                snap(t2);
            if(t1 != t2 && t1->link == T && t2->link == T){
                /* structs with missing or different tag names aren't considered equal */
                if(t1->tag == nil || t2->tag == nil ||
                   strcmp(t1->tag->name, t2->tag->name) != 0)
                    return false;
            }
            t1 = t1->link;
            t2 = t2->link;
            for(;;) {
                if(t1 == t2)
                    return true;
                if(!rsametype(t1, t2, n, 0))
                    return false;
                t1 = t1->down;
                t2 = t2->down;
            }
        }
        t1 = t1->link;
        t2 = t2->link;
        if((f || !debug['V']) && et == TIND) {
            if(t1 != T && t1->etype == TVOID)
                return true;
            if(t2 != T && t2->etype == TVOID)
                return true;
        }
    }
}
@

<<function snap>>=
void
snap(Type *t)
{
    if(typesu[t->etype])
    if(t->link == T && t->tag && t->tag->suetag) {
        t->link = t->tag->suetag->link;
        t->width = t->tag->suetag->width;
    }
}
@

%-------------------






<<[[Type]] other fields>>=
long	width; // ewidth[Type.etype]

long	offset;
schar	shift;
char	nbits;
@

%-------------------

<<[[Type]] other fields>>=
Funct*	funct;
@

<<struct Funct>>=
struct	Funct
{
    Sym*	sym[OEND];
    Sym*	castto[NTYPE];
    Sym*	castfr[NTYPE];
};
@

<<function isfunct>>=
int
isfunct(Node *n)
{
    Type *t, *t1;
    Funct *f;
    Node *l;
    Sym *s;
    int o;

    o = n->op;
    if(n->left == Z)
        goto no;
    t = n->left->type;
    if(t == T)
        goto no;
    f = t->funct;

    switch(o) {
    case OAS:	// put cast on rhs
    case OASI:
    case OASADD:
    case OASAND:
    case OASASHL:
    case OASASHR:
    case OASDIV:
    case OASLDIV:
    case OASLMOD:
    case OASLMUL:
    case OASLSHR:
    case OASMOD:
    case OASMUL:
    case OASOR:
    case OASSUB:
    case OASXOR:
        if(n->right == Z)
            goto no;
        t1 = n->right->type;
        if(t1 == T)
            goto no;
        if(t1->funct == f)
            break;

        l = new(OXXX, Z, Z);
        *l = *n->right;

        n->right->left = l;
        n->right->right = Z;
        n->right->type = t;
        n->right->op = OCAST;

        if(!isfunct(n->right))
            prtree(n, "isfunc !");
        break;

    case OCAST:	// t f(T) or T f(t)
        t1 = n->type;
        if(t1 == T)
            goto no;
        if(f != nil) {
            s = f->castfr[t1->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        f = t1->funct;
        if(f != nil) {
            s = f->castto[t->etype];
            if(s == S)
                goto no;
            n->right = n->left;
            goto build;
        }
        goto no;
    }

    if(f == nil)
        goto no;
    s = f->sym[o];
    if(s == S)
        goto no;

    /*
     * the answer is yes,
     * now we rewrite the node
     * and give diagnostics
     */
    switch(o) {
    default:
        diag(n, "isfunct op missing %O\n", o);
        goto bad;

    case OADD:	// T f(T, T)
    case OAND:
    case OASHL:
    case OASHR:
    case ODIV:
    case OLDIV:
    case OLMOD:
    case OLMUL:
    case OLSHR:
    case OMOD:
    case OMUL:
    case OOR:
    case OSUB:
    case OXOR:

    case OEQ:	// int f(T, T)
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLE:
    case OLO:
    case OLS:
    case OLT:
    case ONE:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, n->left, n->right);
        break;

    case OAS:	// structure copies done by the compiler
    case OASI:
        goto no;

    case OASADD:	// T f(T*, T)
    case OASAND:
    case OASASHL:
    case OASASHR:
    case OASDIV:
    case OASLDIV:
    case OASLMOD:
    case OASLMUL:
    case OASLSHR:
    case OASMOD:
    case OASMUL:
    case OASOR:
    case OASSUB:
    case OASXOR:
        if(n->right == Z)
            goto bad;
        t1 = n->right->type;
        if(t1 == T)
            goto bad;
        if(t1->funct != f)
            goto bad;
        n->right = new(OLIST, new(OADDR, n->left, Z), n->right);
        break;

    case OPOS:	// T f(T)
    case ONEG:
    case ONOT:
    case OCOM:
        n->right = n->left;
        break;


    }

build:
    l = new(ONAME, Z, Z);
    l->sym = s;
    l->type = s->type;
    l->etype = s->type->etype;
    l->xoffset = s->offset;
    l->class = s->class;
    tcomo(l, 0);

    n->op = OFUNC;
    n->left = l;
    n->type = l->type->link;
    if(tcompat(n, T, l->type, tfunct))
        goto bad;
    if(tcoma(n->left, n->right, l->type->down, 1))
        goto bad;
    return 1;

no:
    return 0;

bad:
    diag(n, "cant rewrite typestr for op %O\n", o);
    prtree(n, "isfunct");
    n->type = T;
    return 1;
}
@



\section{Symbol table, [[Sym]] and [[hash]]}
% similar to Assembler. Diffs?
% another symbol table!

<<struct Sym>>=
struct	Sym
{
    // for? keywords? locals? parameters? struct/union? all names? fields?
    // macros
    char	*name;

    long	varlineno;

    <<[[Sym]] other fields>>

    // Extra
    <<[[Sym]] extra fields>>
};
@


<<constant NHASH>>=
#define	NHASH		1024
@

<<global hash>>=
// hash<string, ref_own?<Sym>>, (next in bucket = Sym.link)
Sym*	hash[NHASH];
@

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (next = Sym.link) bucket of hashtbl 'hash'
Sym*	link;
@

<<constant S>>=
#define	S	((Sym*)nil)
@





<<constant NSYMB>>=
#define	NSYMB		1500
@

<<global symb>>=
char	symb[NSYMB];
@


<<function lookup>>=
Sym*
lookup(void)
{
    Sym *s;
    ulong h;
    char *p;
    int c, n;

    h = 0;
    for(p=symb; *p;) {
        h = h * 3;
        h += *p++;
    }
    n = (p - symb) + 1;
    if((long)h < 0)
        h = ~h;
    h %= NHASH;

    c = symb[0];
    for(s = hash[h]; s != S; s = s->link) {
        if(s->name[0] != c)
            continue;
        if(strcmp(s->name, symb) == 0)
            return s;
    }
    s = alloc(sizeof(*s));
    s->name = alloc(n);
    memmove(s->name, symb, n);

    strcpy(s->name, symb);
    s->link = hash[h];
    hash[h] = s;
    syminit(s);

    return s;
}
@


<<[[Sym]] other fields>>=
Type*	type;
// enum<cxxx>?
char	class;
@
% similar to Node.type Decl.type, and now Sym.type

<<[[Sym]] other fields>>=
ushort	block;
@
% see also Decl.block


% for cpp macro
<<[[Sym]] other fields>>=
char*	macro;
@

% see also later suetag for tag.
% how handle namespace? can have struct x x;
% it can be the same symbol, but in a struct context we will use
% Sym.suetag, in other context Sym.type!
% same for Sym.sueblock vs Sym.block

<<function syminit>>=
void
syminit(Sym *s)
{
    s->lexical = LNAME;
    s->block = 0;
    s->offset = 0;

    s->type = T;
    s->suetag = T;

    s->class = CXXX;
    s->aused = false;
    s->sig = SIGNONE;
}
@

<<function slookup>>=
Sym*
slookup(char *s)
{

    strcpy(symb, s);
    return lookup();
}
@














%???
<<[[Sym]] other fields>>=
long	offset;

vlong	vconst;
double	fconst;

ushort	lexical;

char	sym;
@


\section{Nested scope, [[Decl]]}

% block, nested language

<<enum dxxx>>=
enum dxxx
{
    DMARK,

    DAUTO,
    DSUE, // struct/union/enum?
    DLABEL,
};
@
% DAUTO, TAUTO, LAUTO, CAUTO, hmmm

% for? 
% - labels
% locals? func?, params? typedefs? all entities?
<<struct Decl>>=
struct	Decl
{
    Sym*	sym;

    // enum<dxxx>
    short	val;

    Type*	type;
    // enum<cxxx> storage class
    char	class;

    long	varlineno;

    <<[[Decl]] other fields>>

    // Extra fields
    <<[[Decl]] extra fields>>
};
@


% stack because nested scopes
<<global dclstack>>=
// list<ref_own<Decl>> (next = Decl.link)
Decl*	dclstack;
@
% but should have a list of list?
% ugly but do ia via DMARK

<<[[Decl]] extra fields>>=
// list<ref_own<Decl> of dclstack
Decl*	link;
@

<<constant D>>=
#define	D	((Decl*)nil)
@

<<function push>>=
Decl*
push(void)
{
    Decl *d;

    d = alloc(sizeof(Decl));
    d->link = dclstack;
    dclstack = d;
    return d;
}
@


% save old value of a symbol, will be restored by revertdcl
<<function push1>>=
Decl*
push1(Sym *s)
{
    Decl *d;

    d = push();
    d->sym = s;
    d->val = DAUTO;
    d->type = s->type;
    d->class = s->class;
    d->offset = s->offset;
    d->block = s->block;
    d->varlineno = s->varlineno;
    d->aused = s->aused;
    return d;
}
@



% nested language! block number, to allow multiple blocks to use
% similar local names
<<[[Decl]] other fields>>=
ushort	block;
@
% where does dealloc things? e.g. end of functions all labels
% attached to Sym of that name should be freed



% ????
<<[[Decl]] other fields>>=
long	offset;
@






% for statements, but also for structs

<<global blockno>>=
int	blockno;
@

<<global autobn>>=
int	autobn;
@

%autoffset?

<<function markdcl>>=
//@Scheck: used by cc.y
void markdcl(void)
{
    Decl *d;

    blockno++;

    d = push();

    d->val = DMARK;
    d->offset = autoffset;
    d->block = autobn;

    autobn = blockno;
}
@

% means end of scope so need to revert the decl of all local
% entities? why return a node?
% related: dodecl()?
<<function revertdcl>>=
//@Scheck: used by cc.y
Node* revertdcl(void)
{
    Decl *d;
    Sym *s;
    Node *n, *n1;

    n = Z;
    for(;;) {
        d = dclstack;
        if(d == D) {
            diag(Z, "pop off dcl stack");
            break;
        }
        dclstack = d->link;

        s = d->sym;
        switch(d->val) {
        case DMARK:
            autoffset = d->offset;
            autobn = d->block;
            return n;

        case DAUTO:
            if(debug['d'])
                print("revert1 \"%s\"\n", s->name);

            if(s->aused == false) {
                nearln = s->varlineno;
                if(s->class == CAUTO)
                    warn(Z, "auto declared and not used: %s", s->name);
                if(s->class == CPARAM)
                    warn(Z, "param declared and not used: %s", s->name);
            }

            if(s->type && (s->type->garb & GVOLATILE)) {
                n1 = new(ONAME, Z, Z);
                n1->sym = s;
                n1->type = s->type;
                n1->etype = TVOID;
                if(n1->type != T)
                    n1->etype = n1->type->etype;
                n1->xoffset = s->offset;
                n1->class = s->class;

                n1 = new(OADDR, n1, Z);
                n1 = new(OUSED, n1, Z);
                if(n == Z)
                    n = n1;
                else
                    n = new(OLIST, n1, n);
            }

            // restore
            s->type = d->type;
            s->class = d->class;
            s->offset = d->offset;
            s->block = d->block;
            s->varlineno = d->varlineno;
            s->aused = d->aused;

            break;

        case DSUE:
            if(debug['d'])
                print("revert2 \"%s\"\n", s->name);

            s->suetag = d->type;
            s->sueblock = d->block;

            break;

        case DLABEL:
            if(debug['d'])
                print("revert3 \"%s\"\n", s->name);

            if(s->label && s->label->addable == 0)
                warn(s->label, "label declared and not used \"%s\"", s->name);
            s->label = Z;
            break;
        }
    }
    return n;
}
@

\section{[[Token]]}

<<union yacc>>=
%union  {
    Sym*    sym;
    vlong   vval;
    double  dval;
    struct
    {
        char*   s;
        long    l;
    } sval;

   <<[[union yacc]] other fields>>
}
@

% from cc.y
<<token declarations>>=
%token  <sym>   LNAME LTYPE
%token  <vval>  LCONST LLCONST LUCONST LULCONST LVLCONST LUVLCONST
%token  <dval>  LFCONST LDCONST
%token  <sval>  LSTRING LLSTRING
@

<<token declarations>>=
%token  LAUTO LBREAK LCASE LCHAR LCONTINUE LDEFAULT LDO
%token  LDOUBLE LELSE LEXTERN LFLOAT LFOR LGOTO
%token  LIF LINT LLONG LREGISTER LRETURN LSHORT LSIZEOF LUSED
%token  LSTATIC LSTRUCT LSWITCH LTYPEDEF LTYPESTR LUNION LUNSIGNED
%token  LWHILE LVOID LENUM LSIGNED LCONSTNT LVOLATILE LSET LSIGNOF
%token  LRESTRICT LINLINE
@

% LXXX  Lexer XXX? Lexeme XXX?
% so have LDOUBLE and TDOUBLE


% seems used by sub.c simpleg()
<<[[union yacc]] other fields>>=
long    lval;
@


\section{Assembly output, [[Prog]] and [[p]]}

% see also opcode and operand_kind in Assembler.tex.nw
% (and Aconv, Rconv, Dconv, ... in this file)

% see also enum misc3 of 8.out.h with REGARG, REGRET, REGSP, REGTMP

<<struct Prog>>=
struct	Prog
{
    // enum<opcode>, from 8.out.h
    short	as;

    Adr	from;
    Adr	to;

    long	lineno;

    // Extra
    <<[[Prog]] extra fields>>
};
@

<<[[Prog]] extra fields>>=
Prog*	link;
@

<<constant P>>=
#define	P	((Prog*)nil)
@


<<struct Adr>>=
struct	Adr
{
    long	offset;
    double	dval;
    char	sval[NSNAME];
    Sym*	sym;

    uchar	type;
    uchar	index;
    uchar	etype;
    uchar	scale;	/* doubles as width in DATA op */
};
@

<<constant A>>=
#define	A	((Adr*)nil)
@


<<global zprog>>=
Prog	zprog;
@


<<global pc>>=
long	pc;
@

% current? see nextpc()?
<<global p>>=
Prog*	p;
@

<<global firstp>>=
Prog*	firstp;
@

<<global lastp>>=
Prog*	lastp;
@


<<function nextpc>>=
void
nextpc(void)
{

    p = alloc(sizeof(Prog));
    *p = zprog;
    p->lineno = nearln;
    pc++;

    if(firstp == P) {
        firstp = p;
        lastp = p;
        return;
    }
    lastp->link = p;
    lastp = p;
}
@

\chapter{[[main()]]}

<<global thechar>>=
int	thechar;
@

<<global thestring>>=
char*	thestring;
@



<<global outfile>>=
char*	outfile;
@


<<function main>>=
/*
 * known debug flags
 *	-a		acid declaration output
 *	-A		!B
 *	-B		non ANSI
 *	-d		print declarations
 *	-D name		define
 *	-F		format specification check
 *	-i		print initialization
 *	-I path		include
 *	-l		generate little-endian code
 *	-L		print every NAME symbol
 *	-M		constant multiplication
 *	-m		print add/sub/mul trees
 *	-n		print acid to file (%.c=%.acid) (with -a or -aa)
 *	-o file		output file
 *	-p		use standard cpp ANSI preprocessor (not on windows)
 *	-r		print registerization
 *	-s		print structure offsets (with -a or -aa)
 *	-S		print assembly
 *	-t		print type trees
 *	-V		enable void* conversion warnings
 *	-v		verbose printing
 *	-w		print warnings
 *	-X		abort on error
 *	-.		Inhibit search for includes in source directory
 */

//@Scheck: not dead, entry point :)
void main(int argc, char *argv[])
{
    char **defs, **np, *p;
    int nproc, nout, status, i, c, ndef, maxdef;

    memset(debug, 0, sizeof(debug));

    tinit();
    cinit();
    ginit();
    arginit();

    profileflg = true;	/* #pragma can turn it off */
    tufield = simplet((1L<<tfield->etype) | BUNSIGNED);
    maxdef = 0;
    ndef = 0;
    outfile = nil;
    defs = nil;
    setinclude(".");

    ARGBEGIN {
    case 'o':
        outfile = ARGF();
        break;

    case 'D':
        p = ARGF();
        if(p) {
            // realloc, growing array
            if(ndef >= maxdef){
                maxdef += 50;
                np = alloc(maxdef * sizeof *np);
                if(defs != nil)
                    memmove(np, defs, (maxdef - 50) * sizeof *np);
                defs = np;
            }
            defs[ndef++] = p;
            dodefine(p);
        }
        break;

    case 'I':
        p = ARGF();
        if(p)
            setinclude(p);
        break;

    case 'l':			/* for little-endian mips */
        if(thechar != 'v'){
            print("can only use -l with vc");
            errorexit();
        }
        thechar = '0';
        thestring = "spim";
        break;

    default:
        c = ARGC();
        if(c >= 0 && c < sizeof(debug))
            debug[c]++;
        break;


    } ARGEND

    if(argc < 1 && outfile == nil) {
        print("usage: %cc [-options] files\n", thechar);
        errorexit();
    }

    if(argc > 1) {
        nproc = 1;
        /*
         * if we're writing acid to standard output, don't compile
         * concurrently, to avoid interleaving output.
         */
        if(((!debug['a'] && !debug['Z']) || debug['n']) &&
            (p = getenv("NPROC")) != nil)
            nproc = atol(p);	/* */
        c = 0;
        nout = 0;
        for(;;) {
            while(nout < nproc && argc > 0) {
                i = fork();
                if(i < 0) {
                    i = mywait(&status);
                    if(i < 0) {
                        print("cannot create a process\n");
                        errorexit();
                    }
                    if(status)
                        c++;
                    nout--;
                    continue;
                }
                if(i == 0) {
                    fprint(2, "%s:\n", *argv);
                    if (compile(*argv, defs, ndef))
                        errorexit();
                    exits(0);
                }
                nout++;
                argc--;
                argv++;
            }
            i = mywait(&status);
            if(i < 0) {
                if(c)
                    errorexit();
                exits(0);
            }
            if(status)
                c++;
            nout--;
        }
    }

    if(argc == 0)
        c = compile("stdin", defs, ndef);
    else
        c = compile(argv[0], defs, ndef);

    if(c)
        errorexit();
    exits(0);
}
@

<<global outbuf>>=
Biobuf	outbuf;
@

<<global diagbuf>>=
Biobuf	diagbuf;
@



<<function compile>>=
int
compile(char *file, char **defs, int ndef)
{
    char ofile[400], incfile[20];
    char *p, **av, opt[256];
    int i, c, fd[2];
    static int first = 1;

    strcpy(ofile, file);
    p = utfrrune(ofile, pathchar());
    if(p) {
        *p++ = 0;
        if(!debug['.'])
            include[0] = strdup(ofile);
    } else
        p = ofile;

    if(outfile == nil) {
        outfile = p;
        if(outfile) {
            if(p = utfrrune(outfile, '.'))
                if(p[1] == 'c' && p[2] == 0)
                    p[0] = 0;
            p = utfrune(outfile, 0);
            if(debug['a'] && debug['n'])
                strcat(p, ".acid");
            else if(debug['Z'] && debug['n'])
                strcat(p, "_pickle.c");
            else {
                p[0] = '.';
                p[1] = thechar;
                p[2] = 0;
            }
        } else
            outfile = "/dev/null";
    }

    if(p = getenv("INCLUDE")) {
        setinclude(p);
    } else {
        if(systemtype(Plan9)) {
            sprint(incfile, "/%s/include", thestring);
            setinclude(strdup(incfile));
            setinclude("/sys/include");
        }
    }
    if (first)
        Binit(&diagbuf, 1, OWRITE);
    /*
     * if we're writing acid to standard output, don't keep scratching
     * outbuf.
     */
    if((debug['a'] || debug['Z']) && !debug['n']) {
        if (first) {
            outfile = nil;
            Binit(&outbuf, dup(1, -1), OWRITE);
            dup(2, 1);
        }
    } else {
        c = mycreat(outfile, 0664);
        if(c < 0) {
            diag(Z, "cannot open %s - %r", outfile);
            outfile = nil;
            errorexit();
        }
        Binit(&outbuf, c, OWRITE);
    }
    newio();
    first = 0;

    <<[[compile()]] use ANSI preprocessor>>
    else {
        if(strcmp(file, "stdin") == 0)
            newfile(file, 0);
        else
            newfile(file, -1);
    }
    yyparse();
    if(!debug['a'] && !debug['Z'])
        gclean();
    return nerrors;
}
@

% main -> compile -> yyparse -> yylex -> macxxx
%                            -> codgen (portable) -> gen






<<function cinit>>=
void
cinit(void)
{
    Sym *s;
    int i;
    Type *t;

    nerrors = 0;
    lineno = 1;
    iostack = I;
    iofree = I;
    peekc = IGN;
    nhunk = 0;

    <<[[cinit()]] types initialization>>

    for(i=0; i<NHASH; i++)
        hash[i] = S;
    for(i=0; itab[i].name; i++) {
        s = slookup(itab[i].name);
        s->lexical = itab[i].lexical;
        if(itab[i].type != 0)
            s->type = types[itab[i].type];
    }

    blockno = 0;
    autobn = 0;
    autoffset = 0;

    t = typ(TARRAY, types[TCHAR]);
    t->width = 0;
    symstring = slookup(".string");
    symstring->class = CSTATIC;
    symstring->type = t;

    t = typ(TARRAY, types[TCHAR]);
    t->width = 0;

    nodproto = new(OPROTO, Z, Z);
    dclstack = D;

    pathname = allocn(pathname, 0, 100);
    if(getwd(pathname, 99) == 0) {
        pathname = allocn(pathname, 100, 900);
        if(getwd(pathname, 999) == 0)
            strcpy(pathname, "/???");
    }
    <<[[cinit()]] fmtinstall>>
}
@


\chapter{Input}
% similar to Assembler, could reuse

% lineno in Node section

<<global peekc>>=
int	peekc;
@

<<constant EOF>>=
#define	EOF	(-1)
@

<<constant IGN>>=
#define	IGN	(-2)
@

\section{Files managment}

<<constant BUFSIZ>>=
#define	BUFSIZ		8192
@

<<struct Io>>=
struct	Io
{
    char	b[BUFSIZ];

    short	f;

    char*	p;
    short	c;

    Io*	link;
};
@

<<global iostack>>=
Io*	iostack;
@

<<global iofree>>=
Io*	iofree;
@

<<global ionext>>=
Io*	ionext;
@

<<constant I>>=
#define	I	((Io*)nil)
@


<<function newio>>=
void
newio(void)
{
    Io *i;
    static int pushdepth = 0;

    i = iofree;
    if(i == I) {
        pushdepth++;
        if(pushdepth > 1000) {
            yyerror("macro/io expansion too deep");
            errorexit();
        }
        i = alloc(sizeof(*i));
    } else
        iofree = i->link;
    i->c = 0;
    i->f = -1;
    ionext = i;
}
@

<<function newfile>>=
void
newfile(char *s, int f)
{
    Io *i;

    if(debug['e'])
        print("%L: %s\n", lineno, s);

    i = ionext;
    i->link = iostack;
    iostack = i;
    i->f = f;
    if(f < 0)
        i->f = open(s, 0);
    if(i->f < 0) {
        yyerror("%cc: %r: %s", thechar, s);
        errorexit();
    }
    fi.c = 0;
    linehist(s, 0);
}
@

\section{Buffer managment}

<<struct Fi>>=
struct Fi
{
    char*	p;
    int	c;
};
@

<<global fi>>=
struct Fi fi;
@

<<function GETC>>=
#define	GETC()	((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff))
@

<<function filbuf>>=
int
filbuf(void)
{
    Io *i;

loop:
    i = iostack;
    if(i == I)
        return EOF;
    if(i->f < 0)
        goto pop;
    fi.c = read(i->f, i->b, BUFSIZ) - 1;
    if(fi.c < 0) {
        close(i->f);
        linehist(0, 0);
        goto pop;
    }
    fi.p = i->b + 1;
    return i->b[0] & 0xff;

pop:
    iostack = i->link;
    i->link = iofree;
    iofree = i;
    i = iostack;
    if(i == I)
        return EOF;
    fi.p = i->p;
    fi.c = i->c;
    if(--fi.c < 0)
        goto loop;
    return *fi.p++ & 0xff;
}
@

\chapter{Lexing}

% why not using lex? why handwritten?

\section{[[yylex()]]}

<<constant ESC>>=
#define	ESC	(Runemask+1)		/* Rune flag: a literal byte */
@


<<function yylex>>=
//@Scheck: not dead, called by yyparse
long yylex(void)
{
    vlong vv;
    long c, c1, t;
    char *cp;
    Rune rune;
    Sym *s;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
        goto l1;
    }
l0:
    c = GETC();

l1:
    if(c >= Runeself) {
        /*
         * extension --
         *	all multibyte runes are alpha
         */
        cp = symb;
        goto talph;
    }
    if(isspace(c)) {
        if(c == '\n')
            lineno++;
        goto l0;
    }
    if(isalpha(c)) {
        cp = symb;
        if(c != 'L')
            goto talph;
        *cp++ = c;
        c = GETC();
        if(c == '\'') {
            /* L'x' */
            c = escchar('\'', 1, 0);
            if(c == EOF)
                c = '\'';
            c1 = escchar('\'', 1, 0);
            if(c1 != EOF) {
                yyerror("missing '");
                peekc = c1;
            }
            yylval.vval = convvtox(c, TRUNE);
            return LUCONST;
        }
        if(c == '"') {
            goto caselq;
        }
        goto talph;
    }
    if(isdigit(c))
        goto tnum;
    switch(c)
    {

    case EOF:
        peekc = EOF;
        return -1;

    case '_':
        cp = symb;
        goto talph;

    case '#':
        domacro();
        goto l0;

    case '.':
        c1 = GETC();
        if(isdigit(c1)) {
            cp = symb;
            *cp++ = c;
            c = c1;
            c1 = 0;
            goto casedot;
        }
        break;

    case '"':
        strcpy(symb, "\"<string>\"");
        cp = alloc(0);
        c1 = 0;

        /* "..." */
        for(;;) {
            c = escchar('"', 0, 1);
            if(c == EOF)
                break;
            if(c & ESC) {
                cp = allocn(cp, c1, 1);
                cp[c1++] = c;
            } else {
                rune = c;
                c = runelen(rune);
                cp = allocn(cp, c1, c);
                runetochar(cp+c1, &rune);
                c1 += c;
            }
        }
        yylval.sval.l = c1;
        do {
            cp = allocn(cp, c1, 1);
            cp[c1++] = 0;
        } while(c1 & MAXALIGN);
        yylval.sval.s = cp;
        return LSTRING;

    caselq:
        /* L"..." */
        strcpy(symb, "\"L<string>\"");
        cp = alloc(0);
        c1 = 0;
        for(;;) {
            c = escchar('"', 1, 0);
            if(c == EOF)
                break;
            cp = allocn(cp, c1, sizeof(TRune));
            *(TRune*)(cp + c1) = c;
            c1 += sizeof(TRune);
        }
        yylval.sval.l = c1;
        do {
            cp = allocn(cp, c1, sizeof(TRune));
            *(TRune*)(cp + c1) = 0;
            c1 += sizeof(TRune);
        } while(c1 & MAXALIGN);
        yylval.sval.s = cp;
        return LLSTRING;

    case '\'':
        /* '.' */
        c = escchar('\'', 0, 0);
        if(c == EOF)
            c = '\'';
        c1 = escchar('\'', 0, 0);
        if(c1 != EOF) {
            yyerror("missing '");
            peekc = c1;
        }
        vv = c;
        yylval.vval = convvtox(vv, TUCHAR);
        if(yylval.vval != vv)
            yyerror("overflow in character constant: 0x%lx", c);
        else
        if(c & 0x80){
            nearln = lineno;
            warn(Z, "sign-extended character constant");
        }
        yylval.vval = convvtox(vv, TCHAR);
        return LCONST;

    case '/':
        c1 = GETC();
        if(c1 == '*') {
            for(;;) {
                c = getr();
                while(c == '*') {
                    c = getr();
                    if(c == '/')
                        goto l0;
                }
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '/') {
            for(;;) {
                c = getr();
                if(c == '\n')
                    goto l0;
                if(c == EOF) {
                    yyerror("eof in comment");
                    errorexit();
                }
            }
        }
        if(c1 == '=')
            return LDVE;
        break;

    case '*':
        c1 = GETC();
        if(c1 == '=')
            return LMLE;
        break;

    case '%':
        c1 = GETC();
        if(c1 == '=')
            return LMDE;
        break;

    case '+':
        c1 = GETC();
        if(c1 == '+')
            return LPP;
        if(c1 == '=')
            return LPE;
        break;

    case '-':
        c1 = GETC();
        if(c1 == '-')
            return LMM;
        if(c1 == '=')
            return LME;
        if(c1 == '>')
            return LMG;
        break;

    case '>':
        c1 = GETC();
        if(c1 == '>') {
            c = LRSH;
            c1 = GETC();
            if(c1 == '=')
                return LRSHE;
            break;
        }
        if(c1 == '=')
            return LGE;
        break;

    case '<':
        c1 = GETC();
        if(c1 == '<') {
            c = LLSH;
            c1 = GETC();
            if(c1 == '=')
                return LLSHE;
            break;
        }
        if(c1 == '=')
            return LLE;
        break;

    case '=':
        c1 = GETC();
        if(c1 == '=')
            return LEQ;
        break;

    case '!':
        c1 = GETC();
        if(c1 == '=')
            return LNE;
        break;

    case '&':
        c1 = GETC();
        if(c1 == '&')
            return LANDAND;
        if(c1 == '=')
            return LANDE;
        break;

    case '|':
        c1 = GETC();
        if(c1 == '|')
            return LOROR;
        if(c1 == '=')
            return LORE;
        break;

    case '^':
        c1 = GETC();
        if(c1 == '=')
            return LXORE;
        break;

    default:
        return c;
    }
    peekc = c1;
    return c;

talph:
    /*
     * cp is set to symb and some
     * prefix has been stored
     */
    for(;;) {
        if(c >= Runeself) {
            for(c1=0;;) {
                cp[c1++] = c;
                if(fullrune(cp, c1))
                    break;
                c = GETC();
            }
            cp += c1;
            c = GETC();
            continue;
        }
        if(!isalnum(c) && c != '_')
            break;
        *cp++ = c;
        c = GETC();
    }
    *cp = 0;
    if(debug['L'])
        print("%L: %s\n", lineno, symb);
    peekc = c;
    s = lookup();
    if(s->macro) {
        newio();
        cp = ionext->b;
        macexpand(s, cp);
        pushio();
        ionext->link = iostack;
        iostack = ionext;
        fi.p = cp;
        fi.c = strlen(cp);
        if(peekc != IGN) {
            cp[fi.c++] = peekc;
            cp[fi.c] = 0;
            peekc = IGN;
        }
        goto l0;
    }
    yylval.sym = s;
    if(s->class == CTYPEDEF || s->class == CTYPESTR)
        return LTYPE;
    return s->lexical;

tnum:
    c1 = 0;
    cp = symb;
    if(c != '0') {
        c1 |= Numdec;
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            goto dc;
        }
    }
    *cp++ = c;
    c = GETC();
    if(c == 'x' || c == 'X')
        for(;;) {
            *cp++ = c;
            c = GETC();
            if(isdigit(c))
                continue;
            if(c >= 'a' && c <= 'f')
                continue;
            if(c >= 'A' && c <= 'F')
                continue;
            if(cp == symb+2)
                yyerror("malformed hex constant");
            goto ncu;
        }
    if(c < '0' || c > '7')
        goto dc;
    for(;;) {
        if(c >= '0' && c <= '7') {
            *cp++ = c;
            c = GETC();
            continue;
        }
        goto ncu;
    }

dc:
    if(c == '.')
        goto casedot;
    if(c == 'e' || c == 'E')
        goto casee;

ncu:
    if((c == 'U' || c == 'u') && !(c1 & Numuns)) {
        c = GETC();
        c1 |= Numuns;
        goto ncu;
    }
    if((c == 'L' || c == 'l') && !(c1 & Numvlong)) {
        c = GETC();
        if(c1 & Numlong)
            c1 |= Numvlong;
        c1 |= Numlong;
        goto ncu;
    }
    *cp = 0;
    peekc = c;
    if(mpatov(symb, &yylval.vval))
        yyerror("overflow in constant");

    vv = yylval.vval;
    if(c1 & Numvlong) {
        if((c1 & Numuns) || convvtox(vv, TVLONG) < 0) {
            c = LUVLCONST;
            t = TUVLONG;
            goto nret;
        }
        c = LVLCONST;
        t = TVLONG;
        goto nret;
    }
    if(c1 & Numlong) {
        if((c1 & Numuns) || convvtox(vv, TLONG) < 0) {
            c = LULCONST;
            t = TULONG;
            goto nret;
        }
        c = LLCONST;
        t = TLONG;
        goto nret;
    }
    if((c1 & Numuns) || convvtox(vv, TINT) < 0) {
        c = LUCONST;
        t = TUINT;
        goto nret;
    }
    c = LCONST;
    t = TINT;
    goto nret;

nret:
    yylval.vval = convvtox(vv, t);
    if(yylval.vval != vv){
        nearln = lineno;
        warn(Z, "truncated constant: %T %s", types[t], symb);
    }
    return c;

casedot:
    for(;;) {
        *cp++ = c;
        c = GETC();
        if(!isdigit(c))
            break;
    }
    if(c != 'e' && c != 'E')
        goto caseout;

casee:
    *cp++ = 'e';
    c = GETC();
    if(c == '+' || c == '-') {
        *cp++ = c;
        c = GETC();
    }
    if(!isdigit(c))
        yyerror("malformed fp constant exponent");
    while(isdigit(c)) {
        *cp++ = c;
        c = GETC();
    }

caseout:
    if(c == 'L' || c == 'l') {
        c = GETC();
        c1 |= Numlong;
    } else
    if(c == 'F' || c == 'f') {
        c = GETC();
        c1 |= Numflt;
    }
    *cp = 0;
    peekc = c;
    yylval.dval = strtod(symb, nil);
    if(isInf(yylval.dval, 1) || isInf(yylval.dval, -1)) {
        yyerror("overflow in float constant");
        yylval.dval = 0;
    }
    if(c1 & Numflt)
        return LFCONST;
    return LDCONST;
}
@

\section{Comments}

\section{Keywords and identifiers}

<<global itab>>=
struct
{
    char	*name;
    ushort	lexical;
    // option<enum<Type>>
    ushort	type;
} itab[] =
{
    "auto",		LAUTO,		0,
    "break",		LBREAK,		0,
    "case",		LCASE,		0,
    "char",		LCHAR,		TCHAR,
    "const",		LCONSTNT,	0,
    "continue",		LCONTINUE,	0,
    "default",		LDEFAULT,	0,
    "do",		LDO,		0,
    "double",		LDOUBLE,	TDOUBLE,
    "else",		LELSE,		0,
    "enum",		LENUM,		0,
    "extern",		LEXTERN,	0,
    "float",		LFLOAT,		TFLOAT,
    "for",		LFOR,		0,
    "goto",		LGOTO,		0,
    "if",		LIF,		0,
    "inline",		LINLINE,	0,
    "int",		LINT,		TINT,
    "long",		LLONG,		TLONG,
    "register",		LREGISTER,	0,
    "restrict",		LRESTRICT,	0,
    "return",		LRETURN,	0,
    "SET",		LSET,		0,
    "short",		LSHORT,		TSHORT,
    "signed",		LSIGNED,	0,
    "signof",		LSIGNOF,	0,
    "sizeof",		LSIZEOF,	0,
    "static",		LSTATIC,	0,
    "struct",		LSTRUCT,	0,
    "switch",		LSWITCH,	0,
    "typedef",		LTYPEDEF,	0,
    "typestr",		LTYPESTR,	0,
    "union",		LUNION,		0,
    "unsigned",		LUNSIGNED,	0,
    "USED",		LUSED,		0,
    "void",		LVOID,		TVOID,
    "volatile",		LVOLATILE,	0,
    "while",		LWHILE,		0,
    0
};
@

% extension: SET/USED

\section{Typedef trick}

%LTYPE!!

% typestr?

\section{Numbers}

<<enum numxxx>>=
enum numxxx
{
    Numdec		= 1<<0,
    Numlong		= 1<<1,
    Numuns		= 1<<2,
    Numvlong	= 1<<3,
    Numflt		= 1<<4,
};
@

<<function mpatov>>=
/*
 * convert a string, s, to vlong in *v
 * return conversion overflow.
 * required syntax is [0[x]]d*
 */
int
mpatov(char *s, vlong *v)
{
    vlong n, nn;
    int c;

    n = 0;
    c = *s;
    if(c == '0')
        goto oct;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            nn = n*10 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

oct:
    s++;
    c = *s;
    if(c == 'x' || c == 'X')
        goto hex;
    while(c = *s++) {
        if(c >= '0' || c <= '7')
            nn = n*8 + c-'0';
        else
            goto bad;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
    goto out;

hex:
    s++;
    while(c = *s++) {
        if(c >= '0' && c <= '9')
            c += 0-'0';
        else
        if(c >= 'a' && c <= 'f')
            c += 10-'a';
        else
        if(c >= 'A' && c <= 'F')
            c += 10-'A';
        else
            goto bad;
        nn = n*16 + c;
        if(n < 0 && nn >= 0)
            goto bad;
        n = nn;
    }
out:
    *v = n;
    return 0;

bad:
    *v = ~0;
    return 1;
}
@


\subsection{Decimals}

\subsection{Floats}

\section{Characters}

\section{Escaping characters}

<<function escchar>>=
long
escchar(long e, int longflg, bool escflg)
{
    long c, l;
    int i;

loop:
    c = getr();
    if(c == '\n') {
        yyerror("newline in string");
        return EOF;
    }
    if(c != '\\') {
        if(c == e)
            c = EOF;
        return c;
    }
    c = getr();
    if(c == 'x') {
        /*
         * note this is not ansi,
         * supposed to only accept 2 hex
         */
        i = 2;
        if(longflg)
            i = 6;
        l = 0;
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '9') {
                l = l*16 + c-'0';
                continue;
            }
            if(c >= 'a' && c <= 'f') {
                l = l*16 + c-'a' + 10;
                continue;
            }
            if(c >= 'A' && c <= 'F') {
                l = l*16 + c-'A' + 10;
                continue;
            }
            unget(c);
            break;
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    if(c >= '0' && c <= '7') {
        /*
         * note this is not ansi,
         * supposed to only accept 3 oct
         */
        i = 2;
        if(longflg)
            i = 8;
        l = c - '0';
        for(; i>0; i--) {
            c = getc();
            if(c >= '0' && c <= '7') {
                l = l*8 + c-'0';
                continue;
            }
            unget(c);
        }
        if(escflg)
            l |= ESC;
        return l;
    }
    switch(c)
    {
    case '\n':	goto loop;
    case 'n':	return '\n';
    case 't':	return '\t';
    case 'b':	return '\b';
    case 'r':	return '\r';
    case 'f':	return '\f';
    case 'a':	return '\a';
    case 'v':	return '\v';
    }
    return c;
}
@


<<function getr>>=
long
getr(void)
{
    int c, i;
    char str[UTFmax+1];
    Rune rune;


    c = getc();
    if(c < Runeself)
        return c;
    i = 0;
    str[i++] = c;

loop:
    c = getc();
    str[i++] = c;
    if(!fullrune(str, i))
        goto loop;
    c = chartorune(&rune, str);
    if(rune == Runeerror && c == 1) {
        nearln = lineno;
        diag(Z, "illegal rune in string");
        for(c=0; c<i; c++)
            print(" %.2x", *(uchar*)(str+c));
        print("\n");
    }
    return rune;
}
@

\section{Strings}



\section{[[getc()]], [[unget()]], [[getnsc()]]}

<<function getc>>=
int
getc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    if(c == '\n')
        lineno++;
    if(c == EOF) {
        yyerror("End of file");
        errorexit();
    }
    return c;
}
@

<<function unget>>=
void
unget(int c)
{

    peekc = c;
    if(c == '\n')
        lineno--;
}
@

<<function getnsc>>=
int
getnsc(void)
{
    int c;

    if(peekc != IGN) {
        c = peekc;
        peekc = IGN;
    } else
        c = GETC();
    for(;;) {
        if(c >= Runeself || !isspace(c))
            return c;
        if(c == '\n') {
            lineno++;
            return c;
        }
        c = GETC();
    }
}
@


\section{[[getsym()]]}
% mv with Keywords and identifier section?

<<function getsym>>=
Sym*
getsym(void)
{
    int c;
    char *cp;

    c = getnsc();
    if(!isalpha(c) && c != '_' && c < Runeself) {
        unget(c);
        return S;
    }
    for(cp = symb;;) {
        if(cp <= symb+NSYMB-4)
            *cp++ = c;
        c = getc();
        if(isalnum(c) || c == '_' || c >= Runeself)
            continue;
        unget(c);
        break;
    }
    *cp = 0;
    if(cp > symb+NSYMB-4)
        yyerror("symbol too large: %s", symb);
    return lookup();
}
@
% 4 = sizeof Rune?

\section{[[getcom()]]}
% mv with Comments section above?

<<function getcom>>=
int
getcom(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c != '/')
            break;
        c = getc();
        if(c == '/') {
            while(c != '\n')
                c = getc();
            break;
        }
        if(c != '*')
            break;
        c = getc();
        for(;;) {
            if(c == '*') {
                c = getc();
                if(c != '/')
                    continue;
                c = getc();
                break;
            }
            if(c == '\n') {
                yyerror("comment across newline");
                break;
            }
            c = getc();
        }
        if(c == '\n')
            break;
    }
    return c;
}
@

\chapter{Preprocessing}

<<constant CPP>>=
#define	CPP	"/bin/cpp"
@

<<[[compile()]] use ANSI preprocessor>>=
/* Use an ANSI preprocessor */
if(debug['p']) {
    if(myaccess(file) < 0) {
        diag(Z, "%s does not exist", file);
        errorexit();
    }
    if(pipe(fd) < 0) {
        diag(Z, "pipe failed");
        errorexit();
    }
    switch(fork()) {
    case -1:
        diag(Z, "fork failed");
        errorexit();

    case 0:
        close(fd[0]);
        dup(fd[1], 1);
        close(fd[1]);
        av = alloc((3 + ndef + ninclude + 2) * sizeof *av);
        av[0] = CPP;
        i = 1;
        if(debug['.'])
            av[i++] = strdup("-.");
        /* 1999 ANSI C requires recognising // comments */
        av[i++] = strdup("-+");
        for(c = 0; c < ndef; c++) {
            sprint(opt, "-D%s", defs[c]);
            av[i++] = strdup(opt);
        }
        for(c = 0; c < ninclude; c++) {
            sprint(opt, "-I%s", include[c]);
            av[i++] = strdup(opt);
        }
        if(strcmp(file, "stdin") != 0)
            av[i++] = file;
        av[i] = 0;
        if(debug['p'] > 1) {
            for(c = 0; c < i; c++)
                fprint(2, "%s ", av[c]);
            fprint(2, "\n");
        }

        exec(av[0], av);
        fprint(2, "can't exec C preprocessor %s: %r\n", CPP);
        errorexit();

    default:
        close(fd[1]);
        newfile(file, fd[0]);
        break;
    }
}
@


% builtin preprocessor integrated with lexer (benefit? faster? no fork?)
% see also 8c -p

% dupe with Assembler.tex.nw, should try to factorize at some point

<<global mactab>>=
struct
{
    char	*macname;
    void	(*macf)(void);
} mactab[] =
{
    "ifdef",	nil,	/* macif(0) */
    "ifndef",	nil,	/* macif(1) */
    "else",	nil,	/* macif(2) */

    "line",	maclin,
    "define",	macdef,
    "include",	macinc,
    "undef",	macund,

    "pragma",	macprag,
    "endif",	macend,
    0
};
@

% dispatcher, should rename because it's not just about macro =>
% parse_and_dispatch_pp_directive?
<<function domacro>>=
void
domacro(void)
{
    int i;
    Sym *s;

    s = getsym();
    if(s == S)
        s = slookup("endif");

    for(i=0; mactab[i].macname; i++)
        if(strcmp(s->name, mactab[i].macname) == 0) {
            if(mactab[i].macf)
                // dispatcher!
                (*mactab[i].macf)();
            else
                macif(i);
            return;
        }
    yyerror("unknown #: %s", s->name);
    macend();
}
@
% abuse getsym just to get an ident, don't have to go through
% lookup really

<<function macend>>=
void
macend(void)
{
    int c;

    for(;;) {
        c = getnsc();
        if(c < 0 || c == '\n')
            return;
    }
}
@
% I don't think c can be < 0 here.

\section{[[#include]] and [[-I]]}

\subsection{Include path}

% was using fixed array in assembler
<<global include>>=
char**	include;
@

<<global ninclude>>=
int	ninclude;
@

<<global maxinclude>>=
int	maxinclude;
@


<<function setinclude>>=
void
setinclude(char *p)
{
    int i;
    char *e, **np;

    while(*p != 0) {
        e = strchr(p, ' ');
        if(e != 0)
            *e = '\0';

        for(i=0; i < ninclude; i++)
            if(strcmp(p, include[i]) == 0)
                break;

        if(i >= ninclude){
            if(i >= maxinclude){
                maxinclude += 20;
                np = alloc(maxinclude * sizeof *np);
                if(include != nil)
                    memmove(np, include, (maxinclude - 20) * sizeof *np);
                include = np;
            }
            include[ninclude++] = p;
        }

        if(e == 0)
            break;
        p = e+1;
    }
}
@

\subsection{Tracing}

<<struct Hist>>=
struct	Hist
{
    char*	name;

    long	line;
    long	offset;

    Hist*	link;
};
@

<<constant H>>=
#define	H	((Hist*)nil)
@

<<global hist>>=
Hist*	hist;
@

<<global ehist>>=
Hist*	ehist;
@

<<global newflag>>=
bool	newflag;
@


<<function linehist>>=
void
linehist(char *f, int offset)
{
    Hist *h;

    /*
     * overwrite the last #line directive if
     * no alloc has happened since the last one
     */
    if(newflag == false && ehist != H && offset != 0 && ehist->offset != 0)
        if(f && ehist->name && strcmp(f, ehist->name) == 0) {
            ehist->line = lineno;
            ehist->offset = offset;
            return;
        }
    <<[[linehist()]] debug>>

    newflag = false;

    h = alloc(sizeof(Hist));
    h->name = f;
    h->line = lineno;
    h->offset = offset;
    h->link = H;
    if(ehist == H) {
        hist = h;
        ehist = h;
        return;
    }
    ehist->link = h;
    ehist = h;
}
@

\subsection{[[#include]]}

<<constant STRINGSZ>>=
#define	STRINGSZ	200
@


% LP split, and factorize code with gethunk
<<function macinc>>=
void
macinc(void)
{
    int c0, c, i, f;
    char str[STRINGSZ], *hp;

    c0 = getnsc();
    if(c0 != '"') {
        c = c0;
        if(c0 != '<')
            goto bad;
        c0 = '>';
    }
    for(hp = str;;) {
        c = getc();
        if(c == c0)
            break;
        if(c == '\n')
            goto bad;
        *hp++ = c;
    }
    *hp = 0;

    c = getcom();
    if(c != '\n')
        goto bad;

    f = -1;
    for(i=0; i<ninclude; i++) {
        if(i == 0 && c0 == '>')
            continue;
        strcpy(symb, include[i]);
        strcat(symb, "/");
        if(strcmp(symb, "./") == 0)
            symb[0] = 0;
        strcat(symb, str);

        f = open(symb, 0);
        if(f >= 0)
            break;

    }
    if(f < 0)
        strcpy(symb, str);
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    hp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    newio();
    pushio();
    newfile(hp, f);
    return;

bad:
    unget(c);
    yyerror("syntax in #include");
    macend();
}
@


<<function pushio>>=
void
pushio(void)
{
    Io *i;

    i = iostack;
    if(i == I) {
        yyerror("botch in pushio");
        errorexit();
    }
    i->p = fi.p;
    i->c = fi.c;
}
@

\section{[[#define]] and [[-D]]}

\subsection{[[-D]]}

% no Dlist here, instead pass the defs to compile()

<<function dodefine>>=
void
dodefine(char *cp)
{
    Sym *s;
    char *p;
    long l;

    strcpy(symb, cp);
    p = strchr(symb, '=');
    if(p) {
        *p++ = 0;
        s = lookup();
        l = strlen(p) + 2;	/* +1 null, +1 nargs */
        while(l & 3)
            l++;

        while(nhunk < l)
            gethunk();
        *hunk = 0;
        strcpy(hunk+1, p);
        s->macro = hunk;
        hunk += l;
        nhunk -= l;

    } else {
        s = lookup();
        s->macro = "\0001";	/* \000 is nargs */
    }
    <<[[dodefine()]] debug>>
}
@

% LP split macro field of Sym


\subsection{[[#define]]}

<<constant NARG>>=
#define	NARG	25
@

% wow, this is complicated
<<function macdef>>=
void
macdef(void)
{
    Sym *s, *a;
    char *args[NARG], *np, *base;
    int n, i, c, len, dots;
    int ischr;

    s = getsym();
    if(s == S)
        goto bad;
    if(s->macro)
        yyerror("macro redefined: %s", s->name);
    c = getc();
    n = -1;
    dots = 0;
    if(c == '(') {
        n++;
        c = getnsc();
        if(c != ')') {
            unget(c);
            for(;;) {
                a = getsymdots(&dots);
                if(a == S)
                    goto bad;
                if(n >= NARG) {
                    yyerror("too many arguments in #define: %s", s->name);
                    goto bad;
                }
                args[n++] = a->name;
                c = getnsc();
                if(c == ')')
                    break;
                if(c != ',' || dots)
                    goto bad;
            }
        }
        c = getc();
    }
    if(isspace(c))
        if(c != '\n')
            c = getnsc();
    base = hunk;
    len = 1;
    ischr = 0;
    for(;;) {
        if(isalpha(c) || c == '_') {
            np = symb;
            *np++ = c;
            c = getc();
            while(isalnum(c) || c == '_') {
                *np++ = c;
                c = getc();
            }
            *np = 0;
            for(i=0; i<n; i++)
                if(strcmp(symb, args[i]) == 0)
                    break;
            if(i >= n) {
                i = strlen(symb);
                base = allocn(base, len, i);
                memcpy(base+len, symb, i);
                len += i;
                continue;
            }
            base = allocn(base, len, 2);
            base[len++] = '#';
            base[len++] = 'a' + i;
            continue;
        }
        if(ischr){
            if(c == '\\'){ 
                base = allocn(base, len, 1);
                base[len++] = c;
                c = getc();
            }else if(c == ischr)
                ischr = 0;
        }else{
            if(c == '"' || c == '\''){
                base = allocn(base, len, 1);
                base[len++] = c;
                ischr = c;
                c = getc();
                continue;
            }
            if(c == '/') {
                c = getc();
                if(c == '/'){
                    c = getc();
                    for(;;) {
                        if(c == '\n')
                            break;
                        c = getc();
                    }
                    continue;
                }
                if(c == '*'){
                    c = getc();
                    for(;;) {
                        if(c == '*') {
                            c = getc();
                            if(c != '/')
                                continue;
                            c = getc();
                            break;
                        }
                        if(c == '\n') {
                            yyerror("comment and newline in define: %s", s->name);
                            break;
                        }
                        c = getc();
                    }
                    continue;
                }
                base = allocn(base, len, 1);
                base[len++] = '/';
                continue;
            }
        }
        if(c == '\\') {
            c = getc();
            if(c == '\n') {
                c = getc();
                continue;
            }
            else if(c == '\r') {
                c = getc();
                if(c == '\n') {
                    c = getc();
                    continue;
                }
            }
            base = allocn(base, len, 1);
            base[len++] = '\\';
            continue;
        }
        if(c == '\n')
            break;
        if(c == '#')
        if(n > 0) {
            base = allocn(base, len, 1);
            base[len++] = c;
        }
        base = allocn(base, len, 1);
        base[len++] = c;
        c = ((--fi.c < 0)? filbuf(): (*fi.p++ & 0xff));
        if(c == '\n')
            lineno++;
        if(c == -1) {
            yyerror("eof in a macro: %s", s->name);
            break;
        }
    }
    do {
        base = allocn(base, len, 1);
        base[len++] = 0;
    } while(len & 3);

    *base = n+1;
    if(dots)
        *base |= VARMAC;
    s->macro = base;
    <<[[macdef()]] debug>>
    return;

bad:
    if(s == S)
        yyerror("syntax in #define");
    else
        yyerror("syntax in #define: %s", s->name);
    macend();
}
@

<<constant VARMAC>>=
#define VARMAC 0x80
@


<<function getsymdots>>=
Sym*
getsymdots(int *dots)
{
    int c;
    Sym *s;

    s = getsym();
    if(s != S)
        return s;

    c = getnsc();
    if(c != '.'){
        unget(c);
        return S;
    }
    if(getc() != '.' || getc() != '.')
        yyerror("bad dots in macro");
    *dots = 1;
    return slookup("__VA_ARGS__");
}
@

\subsection{Macro Expansion}

%<<[[yylex()]] if macro symbol>>=

% wow, complicated too
<<function macexpand>>=
void
macexpand(Sym *s, char *b)
{
    char buf[2000];
    int n, l, c, nargs;
    char *arg[NARG], *cp, *ob, *ecp, dots;

    ob = b;
    if(*s->macro == 0) {
        strcpy(b, s->macro+1);
        if(debug['m'])
            print("#expand %s %s\n", s->name, ob);
        return;
    }
    
    nargs = (char)(*s->macro & ~VARMAC) - 1;
    dots = *s->macro & VARMAC;

    c = getnsc();
    if(c != '(')
        goto bad;
    n = 0;
    c = getc();
    if(c != ')') {
        unget(c);
        l = 0;
        cp = buf;
        ecp = cp + sizeof(buf)-4;
        arg[n++] = cp;
        for(;;) {
            if(cp >= ecp)
                goto toobig;
            c = getc();
            if(c == '"')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '"')
                        break;
                }
            if(c == '\'')
                for(;;) {
                    if(cp >= ecp)
                        goto toobig;
                    *cp++ = c;
                    c = getc();
                    if(c == '\\') {
                        *cp++ = c;
                        c = getc();
                        continue;
                    }
                    if(c == '\n')
                        goto bad;
                    if(c == '\'')
                        break;
                }
            if(c == '/') {
                c = getc();
                switch(c) {
                case '*':
                    for(;;) {
                        c = getc();
                        if(c == '*') {
                            c = getc();
                            if(c == '/')
                                break;
                        }
                    }
                    *cp++ = ' ';
                    continue;
                case '/':
                    while((c = getc()) != '\n')
                        ;
                    break;
                default:
                    unget(c);
                    c = '/';
                }
            }
            if(l == 0) {
                if(c == ',') {
                    if(n == nargs && dots) {
                        *cp++ = ',';
                        continue;
                    }
                    *cp++ = 0;
                    arg[n++] = cp;
                    if(n > nargs)
                        break;
                    continue;
                }
                if(c == ')')
                    break;
            }
            if(c == '\n')
                c = ' ';
            *cp++ = c;
            if(c == '(')
                l++;
            if(c == ')')
                l--;
        }
        *cp = 0;
    }
    if(n != nargs) {
        yyerror("argument mismatch expanding: %s", s->name);
        *b = 0;
        return;
    }
    cp = s->macro+1;
    for(;;) {
        c = *cp++;
        if(c == '\n')
            c = ' ';
        if(c != '#') {
            *b++ = c;
            if(c == 0)
                break;
            continue;
        }
        c = *cp++;
        if(c == 0)
            goto bad;
        if(c == '#') {
            *b++ = c;
            continue;
        }
        c -= 'a';
        if(c < 0 || c >= n)
            continue;
        strcpy(b, arg[c]);
        b += strlen(arg[c]);
    }
    *b = 0;
    if(debug['m'])
        print("#expand %s %s\n", s->name, ob);

    return;

bad:
    yyerror("syntax in macro expansion: %s", s->name);
    *b = 0;
    return;

toobig:
    yyerror("too much text in macro expansion: %s", s->name);
    *b = 0;
}
@

\section{[[#undef]]}

<<function macund>>=
void
macund(void)
{
    Sym *s;

    s = getsym();
    macend();
    if(s == S) {
        yyerror("syntax in #undef");
        return;
    }
    s->macro = nil;
}
@

\section{[[#ifdef]]}

% 0 = ifdef, 1 = ifndef, 2 = else, see mactab and domacro()
<<function macif>>=
void
macif(int f)
{
    int c, l;
    bool bol;
    Sym *s;

    if(f == 2)
        goto skip;
    s = getsym();
    if(s == S)
        goto bad;
    if(getcom() != '\n')
        goto bad;
    if((s->macro != nil) ^ f)
        return;

skip:
    bol = true;
    l = 0;
    for(;;) {
        c = getc();
        if(c != '#') {
            if(!isspace(c))
                bol = false;
            if(c == '\n')
                bol = true;
            continue;
        }
        if(!bol)
            continue;
        s = getsym();
        if(s == S)
            continue;
        if(strcmp(s->name, "endif") == 0) {
            if(l) {
                l--;
                continue;
            }
            macend();
            return;
        }
        if(strcmp(s->name, "ifdef") == 0 || strcmp(s->name, "ifndef") == 0) {
            l++;
            continue;
        }
        if(l == 0 && f != 2 && strcmp(s->name, "else") == 0) {
            macend();
            return;
        }
    }

bad:
    yyerror("syntax in #if(n)def");
    macend();
}
@

\section{[[#pragma]]}

% effect of #pragma lib in .s ??

<<function macprag>>=
void
macprag(void)
{
    Sym *s;
    int c0, c;
    char *hp;
    Hist *h;

    s = getsym();

    if(s && strcmp(s->name, "lib") == 0) {
        c0 = getnsc();
        if(c0 != '"') {
            c = c0;
            if(c0 != '<')
                goto bad;
            c0 = '>';
        }
        for(hp = symb;;) {
            c = getc();
            if(c == c0)
                break;
            if(c == '\n')
                goto bad;
            *hp++ = c;
        }
        *hp = '\0';
        c = getcom();
        if(c != '\n')
            goto bad;
    
        /*
         * put pragma-line in as a funny history 
         */
        c = strlen(symb) + 1;
        while(c & 3)
            c++;
    
        while(nhunk < c)
            gethunk();
        hp = hunk;
        memcpy(hunk, symb, c);
        nhunk -= c;
        hunk += c;
    
        h = alloc(sizeof(Hist));
        h->name = hp;
        h->line = lineno;
        h->offset = -1;

        h->link = H;
        if(ehist == H) {
            hist = h;
            ehist = h;
            return;
        }
        ehist->link = h;
        ehist = h;

        return;

bad:
        unget(c);
        yyerror("syntax in #pragma lib");
        macend();

    } else {
        while(getnsc() != '\n')
            ;
        return;
    }
}
@


% most pragma seems to be discarded except #pragma lib, so
% I removed it (could have aslo simplified by calling prag_do_nothing()).
% is it because code was shared with cc? or because it's in aa/
% and other archi do different things?
%
%    if(s && strcmp(s->name, "pack") == 0) {
%        pragpack();
%        return;
%    }
%    if(s && strcmp(s->name, "fpround") == 0) {
%        pragfpround();
%        return;
%    }
%    if(s && strcmp(s->name, "profile") == 0) {
%        pragprofile();
%        return;
%    }
%    if(s && strcmp(s->name, "varargck") == 0) {
%        pragvararg();
%        return;
%    }
%    if(s && strcmp(s->name, "incomplete") == 0) {
%        pragincomplete();
%        return;
%    }
%
%old:
%<<function pragpack>>=
%void
%pragpack(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragvararg>>=
%void
%pragvararg(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragfpround>>=
%void
%pragfpround(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragprofile>>=
%void
%pragprofile(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@
%
%<<function pragincomplete>>=
%void
%pragincomplete(void)
%{
%    while(getnsc() != '\n')
%        ;
%}
%@


\section{[[#line]]}

% useful for code generator, to report error to original file, not generated
% code, e.g. for lex&yacc

<<function maclin>>=
void
maclin(void)
{
    char *cp;
    int c;
    long n;

    n = getnsn();
    c = getc();
    if(n < 0)
        goto bad;

    for(;;) {
        if(c == ' ' || c == '\t') {
            c = getc();
            continue;
        }
        if(c == '"')
            break;
        if(c == '\n') {
            strcpy(symb, "<noname>");
            goto nn;
        }
        goto bad;
    }
    cp = symb;
    for(;;) {
        c = getc();
        if(c == '"')
            break;
        *cp++ = c;
    }
    *cp = 0;
    c = getcom();
    if(c != '\n')
        goto bad;

nn:
    c = strlen(symb) + 1;
    while(c & 3)
        c++;

    while(nhunk < c)
        gethunk();
    cp = hunk;
    memcpy(hunk, symb, c);
    nhunk -= c;
    hunk += c;

    linehist(cp, n);
    return;

bad:
    unget(c);
    yyerror("syntax in #line");
    macend();
}
@

% could move with the other getxxx()
<<function getnsn>>=
long
getnsn(void)
{
    long n;
    int c;

    c = getnsc();
    if(c < '0' || c > '9')
        return -1;
    n = 0;
    while(c >= '0' && c <= '9') {
        n = n*10 + c-'0';
        c = getc();
    }
    unget(c);
    return n;
}
@



\chapter{Parsing}

\section{Overview}

% I assume you understand yacc! if not read classic book on lex&yacc
%  or docs/doc/unix/yacc.pdf (or read CompilerGenerator.tex.nw :) )
%(compared to ocamlyacc can have actions in the middle, and they count
% as indexable elements for the $xxx ($1, $2, etc))

<<cc/cc.y>>=
%{
#include "cc.h"
%}
<<union yacc>>
<<token declarations>>
<<priority and associativity declarations>>
<<type declarations>>
%%
<<grammar>>
%%
@

% have seen Token declarations in Core Data structures chapter already.

% do not LP split, order matters!
<<priority and associativity declarations>>=
%left   ';'
%left   ','
%right  '=' LPE LME LMLE LDVE LMDE LRSHE LLSHE LANDE LXORE LORE
%right  '?' ':'
%left   LOROR
%left   LANDAND
%left   '|'
%left   '^'
%left   '&'
%left   LEQ LNE
%left   '<' '>' LLE LGE
%left   LLSH LRSH
%left   '+' '-'
%left   '*' '/' '%'
%right  LMM LPP LMG '.' '[' '('
@


<<[[union yacc]] other fields>>=
Node*   node;
@

% see Node also in Core data structure section, with Z, left/right, new(), etc

<<type declarations>>=
%type   <node>  zarglist arglist zcexpr
%type   <node>  name block stmnt cexpr expr xuexpr pexpr
%type   <node>  zelist elist adecl slist uexpr string lstring
%type   <node>  xdecor xdecor2 labels label ulstmnt
%type   <node>  adlist edecor tag qual qlist
%type   <node>  abdecor abdecor1 abdecor2 abdecor3
%type   <node>  zexpr lexpr init ilist forexpr
@

% in what follows a few conventions: 
% zxxx means zero or more e.g. zctlist means list of ctl 0 or more

% note that all terminal chars like ')' are acutally Node* too
% so can pass them to warn() to get accurate error location

<<grammar>>=
prog:
  /* empty */
|   prog xdecl

<<declarator rules>>
<<statements rules>>
<<expressions rules>>
<<initializers rules>>
<<types rules>>
<<names rules>>

<<extra grammar rules>>
<<ebnf grammar rules>>
@



<<constant YYMAXDEPTH>>=
//@Scheck: used in t.tab.c probably
#define YYMAXDEPTH	1500
@

\section{Declarations and definitions, part one}

<<declarator rules>>=
<<external declarator rules>>
<<automatic declarator rules>>
<<parameter declarator rules>>
<<abstract declarator rules>>
<<structure element declarator rules>>
@

<<external declarator rules>>=
/*
 * external declarator
 */
xdecl:
    zctlist ';'          { dodecl(xdecl, lastclass, lasttype, Z); }
|   zctlist xdlist ';'
<<xdecl function definition case>>
@

% do that because C sucks? but my parser_c.mly was also complicated
% when it come to declaration handling
<<global lastclass>>=
// enum<cxxx>
//@Scheck: y.tab.c
char	lastclass;
@

<<global lasttype>>=
//@Scheck: y.tab.c
Type*	lasttype;
@

% dodecl() modify especially this global.
% hmm why Type* and not Decl*? rename lastdcltype?
<<global lastdcl>>=
Type*	lastdcl;
@



\section{Function definition}


<<global firstdcl>>=
Decl*	firstdcl;
@


%rename thisfntype?
<<global thisfn>>=
Type*	thisfn;
@



<<xdecl function definition case>>=
|   zctlist xdecor
    {
        lastdcl = T;
        firstarg = S;
        dodecl(xdecl, lastclass, lasttype, $2);
        if(lastdcl == T || lastdcl->etype != TFUNC) {
            diag($2, "not a function");
            lastdcl = types[TFUNC];
        }
        thisfn = lastdcl;
        markdcl();
        firstdcl = dclstack;
        argmark($2, 0);
    }
    pdecl
    {
        argmark($2, 1);
    }
    block
    {
        Node *n;

        n = revertdcl();
        if(n)
            $6 = new(OLIST, n, $6);

        if(!debug['a'] && !debug['Z'])
            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!
    }
@

% markdcl(), revertdcl(), see next section

\subsection{Parameters}

<<global firstarg>>=
Sym*	firstarg;
@

<<global firstargtype>>=
Type*	firstargtype;
@

% ?
<<global autoffset>>=
long	autoffset;
@

% ?
<<global stkoff>>=
long	stkoff;
@


% pass is 0 or 1
<<function argmark>>=
//@Scheck: not dead, used by cc.y
void argmark(Node *n, int pass)
{
    Type *t;

    autoffset = align(0, thisfn->link, Aarg0);
    stkoff = 0;
    for(; n->left != Z; n = n->left) {
        if(n->op != OFUNC || n->left->op != ONAME)
            continue;
        walkparam(n->right, pass);
        if(pass != 0 && anyproto(n->right) == OLDPROTO) {
            t = typ(TFUNC, n->left->sym->type->link);
            t->down = typ(TOLD, T);
            t->down->down = ofnproto(n->right);
            tmerge(t, n->left->sym);
            n->left->sym->type = t;
        }
        break;
    }
    autoffset = 0;
    stkoff = 0;
}
@

<<function tmerge>>=
void
tmerge(Type *t1, Sym *s)
{
    Type *ta, *tb, *t2;

    t2 = s->type;
/*print("merge	%T; %T\n", t1, t2);/**/
    for(;;) {
        if(t1 == T || t2 == T || t1 == t2)
            break;
        if(t1->etype != t2->etype)
            break;
        switch(t1->etype) {
        case TFUNC:
            ta = t1->down;
            tb = t2->down;
            if(ta == T) {
                t1->down = tb;
                break;
            }
            if(tb == T)
                break;
            while(ta != T && tb != T) {
                if(ta == tb)
                    break;
                /* ignore old-style flag */
                if(ta->etype == TOLD) {
                    ta = ta->down;
                    continue;
                }
                if(tb->etype == TOLD) {
                    tb = tb->down;
                    continue;
                }
                /* checking terminated by ... */
                if(ta->etype == TDOT && tb->etype == TDOT) {
                    ta = T;
                    tb = T;
                    break;
                }
                if(!sametype(ta, tb))
                    break;
                ta = ta->down;
                tb = tb->down;
            }
            if(ta != tb)
                diag(Z, "function inconsistently declared: %s", s->name);

            /* take new-style over old-style */
            ta = t1->down;
            tb = t2->down;
            if(ta != T && ta->etype == TOLD)
                if(tb != T && tb->etype != TOLD)
                    t1->down = tb;
            break;

        case TARRAY:
            /* should we check array size change? */
            if(t2->width > t1->width)
                t1->width = t2->width;
            break;

        case TUNION:
        case TSTRUCT:
            return;
        }
        t1 = t1->link;
        t2 = t2->link;
    }
}
@

<<function ofnproto>>=
Type*
ofnproto(Node *n)
{
    Type *tl, *tr, *t;

    if(n == Z)
        return T;
    switch(n->op) {
    case OLIST:
        tl = ofnproto(n->left);
        tr = ofnproto(n->right);
        if(tl == T)
            return tr;
        tl->down = tr;
        return tl;

    case ONAME:
        t = copytyp(n->sym->type);
        t->down = T;
        return t;
    }
    return T;
}
@

% TODO enum with bitset 1<<0, 1<<1
<<constant ANSIPROTO>>=
#define	ANSIPROTO	1
@

<<constant OLDPROTO>>=
#define	OLDPROTO	2
@





<<function fnproto>>=
Type*
fnproto(Node *n)
{
    int r;

    r = anyproto(n->right);
    if(r == 0 || (r & OLDPROTO)) {
        if(r & ANSIPROTO)
            diag(n, "mixed ansi/old function declaration: %F", n->left);
        return T;
    }
    return fnproto1(n->right);
}
@

<<function anyproto>>=
int
anyproto(Node *n)
{
    int r;

    r = 0;

loop:
    if(n == Z)
        return r;
    switch(n->op) {
    case OLIST:
        r |= anyproto(n->left);
        n = n->right;
        goto loop;

    case ODOTDOT:
    case OPROTO:
        return r | ANSIPROTO;
    }
    return r | OLDPROTO;
}
@

<<function fnproto1>>=
Type*
fnproto1(Node *n)
{
    Type *t;

    if(n == Z)
        return T;
    switch(n->op) {
    case OLIST:
        t = fnproto1(n->left);
        if(t != T)
            t->down = fnproto1(n->right);
        return t;

    case OPROTO:
        lastdcl = T;
        dodecl(NODECL, CXXX, n->type, n->left);
        t = typ(TXXX, T);
        if(lastdcl != T)
            *t = *paramconv(lastdcl, 1);
        return t;

    case ONAME:
        diag(n, "incomplete argument prototype");
        return typ(TINT, T);

    case ODOTDOT:
        return typ(TDOT, T);
    }
    diag(n, "unknown op in fnproto");
    return T;
}
@


<<function paramconv>>=
Type*
paramconv(Type *t, int f)
{

    switch(t->etype) {
    case TARRAY:
        t = typ(TIND, t->link);
        t->width = types[TIND]->width;
        break;

    case TFUNC:
        t = typ(TIND, t);
        t->width = types[TIND]->width;
        break;

    case TFLOAT:
        if(!f)
            t = types[TDOUBLE];
        break;

    case TCHAR:
    case TSHORT:
        if(!f)
            t = types[TINT];
        break;

    case TUCHAR:
    case TUSHORT:
        if(!f)
            t = types[TUINT];
        break;
    }
    return t;
}
@



<<function walkparam>>=
void
walkparam(Node *n, int pass)
{
    Sym *s;
    Node *n1;

    if(n != Z && n->op == OPROTO && n->left == Z && n->type == types[TVOID])
        return;

loop:
    if(n == Z)
        return;
    switch(n->op) {
    default:
        diag(n, "argument not a name/prototype: %O", n->op);
        break;

    case OLIST:
        walkparam(n->left, pass);
        n = n->right;
        goto loop;

    case OPROTO:
        for(n1 = n; n1 != Z; n1=n1->left)
            if(n1->op == ONAME) {
                if(pass == 0) {
                    s = n1->sym;
                    push1(s);
                    s->offset = -1;
                    break;
                }
                dodecl(pdecl, CPARAM, n->type, n->left);
                break;
            }
        if(n1)
            break;
        if(pass == 0) {
            /*
             * extension:
             *	allow no name in argument declaration
            diag(Z, "no name in argument declaration");
             */
            break;
        }
        dodecl(NODECL, CPARAM, n->type, n->left);
        pdecl(CPARAM, lastdcl, S);
        break;

    case ODOTDOT:
        break;
    
    case ONAME:
        s = n->sym;
        if(pass == 0) {
            push1(s);
            s->offset = -1;
            break;
        }
        if(s->offset != -1) {
            if(autoffset == 0) {
                firstarg = s;
                firstargtype = s->type;
            }
            autoffset = align(autoffset, s->type, Aarg1);
            s->offset = autoffset;
            autoffset = align(autoffset, s->type, Aarg2);
        } else
            dodecl(pdecl, CXXX, types[TINT], n);
        break;
    }
}
@



% TODO remove? old style decl?
<<parameter declarator rules>>=
/*
 * parameter declarator
 */
pdecl:
  /* empty */
|   pdecl ctlist pdlist ';'

pdlist:
    xdecor              { dodecl(pdecl, lastclass, lasttype, $1); }
|   pdlist ',' pdlist
@
%$
% this is old style? pre-ansi?


<<function pdecl>>=
void
pdecl(int c, Type *t, Sym *s)
{
    if(s && s->offset != -1) {
        diag(Z, "not a parameter: %s", s->name);
        return;
    }
    t = paramconv(t, c==CPARAM);
    if(c == CXXX)
        c = CPARAM;
    if(c != CPARAM) {
        diag(Z, "parameter cannot have class: %s", s->name);
        c = CPARAM;
    }
    if(typesu[t->etype] && t->width <= 0)
        diag(Z, "incomplete structure: %s", t->tag->name);
    adecl(c, t, s);
}
@





% called arg ... hmmm ... should be renamed zparamlist
<<parameter declarator rules>>=
zarglist:
  /* empty */   { $$ = Z; }
|   arglist     { $$ = invert($1); }


arglist:
    name
|   tlist abdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
|   tlist xdecor
    {
        $$ = new(OPROTO, $2, Z);
        $$->type = $1;
    }
|   '.' '.' '.'          { $$ = new(ODOTDOT, Z, Z); }
|   arglist ',' arglist  { $$ = new(OLIST, $1, $3); }
@
%$



\section{Statements}

% block, labels, stmts

% seen 'block' for func def, block is a list of stmnt
<<statements rules>>=
block:
 '{' slist '}'
    {
        $$ = invert($2);
        if($$ == Z)
            $$ = new(OLIST, Z, Z);
    }

slist:
  /* empty */      { $$ = Z;    }
|   slist adecl    { $$ = new(OLIST, $1, $2); }
|   slist stmnt    { $$ = new(OLIST, $1, $2); }
@
%$


% can have labels before stmts
<<statements rules>>=
stmnt:
    ulstmnt
|   labels ulstmnt { $$ = new(OLIST, $1, $2); }
|   error ';'      { $$ = Z; }
@

% ul = no label? unlabeled?
<<statements rules>>=
<<ulstmnt rule>>
@

<<ulstmnt rule>>=
ulstmnt:
    zcexpr ';'
@

<<ebnf grammar rules>>=
labels:
    label
|   labels label  { $$ = new(OLIST, $1, $2); }
@

<<statements rules>>=
<<label rule>>
@

\subsection{Blocks}

<<ulstmnt rule>>=
|   {
        markdcl();
    }
    block
    {
        $$ = revertdcl();
        if($$)
            $$ = new(OLIST, $$, $2);
        else
            $$ = $2;
    }
@
% will explain later revertdcl() in Declaration section
% originally in comment //  if($2 != Z) $$ = new(OLIST, $2, $$);



\subsection{Conditionals}

<<ulstmnt rule>>=
|   LIF '(' cexpr ')' stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, Z));
        if($5 == Z)
            warn($3, "empty if body");
    }
|   LIF '(' cexpr ')' stmnt LELSE stmnt
    {
        $$ = new(OIF, $3, new(OLIST, $5, $7));
        if($5 == Z)
            warn($3, "empty if body");
        if($7 == Z)
            warn($3, "empty else body");
    }
@
%$

% cexpr means  comma expr

\subsection{Switch}

<<ulstmnt rule>>=
|   LSWITCH '(' cexpr ')' stmnt
    {
        $$ = new(OCONST, Z, Z);
        $$->vconst = 0;
        $$->type = types[TINT];
        $3 = new(OSUB, $$, $3);

        $$ = new(OSWITCH, $3, $5);
    }
@
% bug padfix: the 4 lines were copy pasted :) rob pike confirmed it :)

% note that 'labels' with an 's' before, so can have case 1: case 2: ...

<<label rule>>=
label:
    LCASE expr ':'  { $$ = new(OCASE, $2, Z); }
|   LDEFAULT ':'    { $$ = new(OCASE, Z, Z); }
@
%$

\subsection{Control flow jumps}

<<ulstmnt rule>>=
|   LRETURN zcexpr ';'
    {
        $$ = new(ORETURN, $2, Z);
        $$->type = thisfn->link;
    }
|   LBREAK ';'     { $$ = new(OBREAK, Z, Z); }
|   LCONTINUE ';'  { $$ = new(OCONTINUE, Z, Z); }
@
%$


\subsection{Loops}

<<ulstmnt rule>>=
|   { 
        markdcl(); 
    } 
    LFOR '(' forexpr ';' zcexpr ';' zcexpr ')' stmnt
    {
        $$ = revertdcl();
        if($$){
            if($4)
                $4 = new(OLIST, $$, $4);
            else
                $4 = $$;
        }
        $$ = new(OFOR, new(OLIST, $6, new(OLIST, $4, $8)), $10);
    }
|   LWHILE '(' cexpr ')' stmnt          { $$ = new(OWHILE, $3, $5); }
|   LDO stmnt LWHILE '(' cexpr ')' ';'  { $$ = new(ODWHILE, $5, $2); }
@

% C extension for(int i; ... ?) hence the markdcl? for scope?
<<statements rules>>=
forexpr:
    zcexpr
|   ctlist adlist { $$ = $2; }
@
%$

\subsection{Labels and goto}

<<label rule>>=
|   LNAME ':'       { $$ = new(OLABEL, dcllabel($1, true), Z); }
@
%$

<<ulstmnt rule>>=
|   LGOTO ltag ';' { $$ = new(OGOTO, dcllabel($2, false), Z); }
@
%$


<<[[Sym]] other fields>>=
Node*	label;
@

% flag is true for label definition context, false for use (e.g. in goto)
% TODO cleanup abuse of complex/addable, do like in scheck field for used
<<function dcllabel>>=
//@Scheck: used by cc.y
Node* dcllabel(Sym *s, bool f)
{
    Decl *d, d1;
    Node *n;

    n = s->label;
    if(n != Z) {
        if(f) {
            if(n->complex)
                diag(Z, "label reused: %s", s->name);
            n->complex = true;	// declared
        } else
            n->addable = true;	// used
        return n;
    }

    d = push();
    d->sym = s;
    d->val = DLABEL;

    dclstack = d->link;

    d1 = *firstdcl;
    *firstdcl = *d;
    *d = d1;

    firstdcl->link = d;
    firstdcl = d;

    n = new(OXXX, Z, Z);
    n->sym = s;
    n->complex = f;
    n->addable = !f;

    s->label = n;

    if(debug['d'])
        dbgdecl(s);
    return n;
}
@

\section{Expressions}

% e.g. in array def context, can have an int or nothing, TODO rename zlexpr?
<<expressions rules>>=
zexpr:
  /* empty */ { $$ = Z; }
|   lexpr
@

<<expressions rules>>=
lexpr:
    expr
    {
        $$ = new(OCAST, $1, Z);
        $$->type = types[TLONG];
    }
@
%$

<<expressions rules>>=
cexpr:
    expr
|   cexpr ',' cexpr { $$ = new(OCOMMA, $1, $3); }
@
%$
% cexpr = comma expr


<<ebnf grammar rules>>=
zcexpr:
  /* empty */ { $$ = Z; }
|   cexpr
@


\subsection{Binary expressions}

<<expressions rules>>=
expr:
    xuexpr

|   expr '*' expr { $$ = new(OMUL, $1, $3); }
|   expr '/' expr { $$ = new(ODIV, $1, $3); }
|   expr '%' expr { $$ = new(OMOD, $1, $3); }
|   expr '+' expr { $$ = new(OADD, $1, $3); }
|   expr '-' expr { $$ = new(OSUB, $1, $3); }
|   expr LRSH expr { $$ = new(OASHR, $1, $3); }
|   expr LLSH expr { $$ = new(OASHL, $1, $3); }
|   expr '<' expr  { $$ = new(OLT, $1, $3); }
|   expr '>' expr  { $$ = new(OGT, $1, $3); }
|   expr LLE expr  { $$ = new(OLE, $1, $3); }
|   expr LGE expr  { $$ = new(OGE, $1, $3); }
|   expr LEQ expr  { $$ = new(OEQ, $1, $3); }
|   expr LNE expr  { $$ = new(ONE, $1, $3); }
|   expr '&' expr  { $$ = new(OAND, $1, $3); }
|   expr '^' expr  { $$ = new(OXOR, $1, $3); }
|   expr '|' expr  { $$ = new(OOR, $1, $3); }
|   expr LANDAND expr { $$ = new(OANDAND, $1, $3); }
|   expr LOROR expr   { $$ = new(OOROR, $1, $3); }

|   expr '?' cexpr ':' expr { $$ = new(OCOND, $1, new(OLIST, $3, $5)); }

|   expr '=' expr  { $$ = new(OAS, $1, $3); }
|   expr LPE expr  { $$ = new(OASADD, $1, $3); }
|   expr LME expr  { $$ = new(OASSUB, $1, $3); }
|   expr LMLE expr { $$ = new(OASMUL, $1, $3); }
|   expr LDVE expr { $$ = new(OASDIV, $1, $3); }
|   expr LMDE expr { $$ = new(OASMOD, $1, $3); }
|   expr LLSHE expr { $$ = new(OASASHL, $1, $3); }
|   expr LRSHE expr { $$ = new(OASASHR, $1, $3); }
|   expr LANDE expr { $$ = new(OASAND, $1, $3); }
|   expr LXORE expr { $$ = new(OASXOR, $1, $3); }
|   expr LORE expr  { $$ = new(OASOR, $1, $3); }
@
%$

\subsection{Cast}

<<expressions rules>>=
xuexpr:
    uexpr
|   '(' tlist abdecor ')' xuexpr
    {
        $$ = new(OCAST, $5, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcl;
        $$->xcast = true;
    }
<<xuexpr other cases>>
@
%$

% extended unary expr? = cast expr

<<[[Node]] other fields>>=
bool 	xcast;
@

% kenccext and gccext, struct constructor
<<xuexpr other cases>>=
|   '(' tlist abdecor ')' '{' ilist '}' /* extension */
    {
        $$ = new(OSTRUCT, $6, Z);
        dodecl(NODECL, CXXX, $2, $3);
        $$->type = lastdcl;
    }
@
%$


\subsection{Unary expressions}

% unary expr
<<expressions rules>>=
uexpr:
    pexpr

|   '*' xuexpr { $$ = new(OIND, $2, Z); }
|   '&' xuexpr { $$ = new(OADDR, $2, Z); }

|   '+' xuexpr { $$ = new(OPOS, $2, Z); }
|   '-' xuexpr { $$ = new(ONEG, $2, Z); }
|   '!' xuexpr { $$ = new(ONOT, $2, Z); }
|   '~' xuexpr { $$ = new(OCOM, $2, Z); }
|   LPP xuexpr { $$ = new(OPREINC, $2, Z); }
|   LMM xuexpr { $$ = new(OPREDEC, $2, Z); }

|   LSIZEOF uexpr { $$ = new(OSIZE, $2, Z); }
|   LSIGNOF uexpr { $$ = new(OSIGN, $2, Z); }
@
% signof?

\subsection{Primary expressions}

<<expressions rules>>=
<<pexpr rule>>
@

% primary expr
<<pexpr rule>>=
pexpr:
    '(' cexpr ')' { $$ = $2; }
@
%$

<<pexpr rule>>=
|   LSIZEOF '(' tlist abdecor ')'
    {
        $$ = new(OSIZE, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcl;
    }
|   LSIGNOF '(' tlist abdecor ')'
    {
        $$ = new(OSIGN, Z, Z);
        dodecl(NODECL, CXXX, $3, $4);
        $$->type = lastdcl;
    }
@
%$
% again sizeof but this time not uexpr, but types!

% funcall!
<<pexpr rule>>=
|   pexpr '(' zelist ')'
    {
        $$ = new(OFUNC, $1, Z);
        if($1->op == ONAME)
          if($1->type == T)
            dodecl(xdecl, CXXX, types[TINT], $$);
        $$->right = invert($3);
    }
@
% no forward decl of entity name, so assumes return an int?
% TODO should warn instead about undeclared symbol? cleaner!

<<ebnf grammar rules>>=
zelist:
  /* empty */ { $$ = Z; }
|   elist
@


<<expressions rules>>=
elist:
    expr
|   elist ',' elist { $$ = new(OLIST, $1, $3); }
@
% elist really? should be expr no? or have a %left for ',' ?

% unsugar x[y] as *(x+y) :)
<<pexpr rule>>=
|   pexpr '[' cexpr ']' { $$ = new(OIND, new(OADD, $1, $3), Z); }
@

% unsugar x->y as (*x).y
<<pexpr rule>>=
|   pexpr '.' ltag
    {
        $$ = new(ODOT, $1, Z);
        $$->sym = $3;
    }
|   pexpr LMG ltag
    {
        $$ = new(ODOT, new(OIND, $1, Z), Z);
        $$->sym = $3;
    }
@

<<pexpr rule>>=
|   pexpr LPP { $$ = new(OPOSTINC, $1, Z); }
|   pexpr LMM { $$ = new(OPOSTDEC, $1, Z); }
@

\subsection{Entities}

<<pexpr rule>>=
|   name
@

% use (def of entities use 'tag' instead, in xdecor2, not 'name')
<<names rules>>=
name:
    LNAME
    {
        $$ = new(ONAME, Z, Z);
        if($1->class == CLOCAL)
            $1 = mkstatic($1);
        $$->sym = $1;
        $$->type = $1->type;

        $$->etype = TVOID;
        if($$->type != T)
            $$->etype = $$->type->etype;

        $$->xoffset = $1->offset;
        $$->class = $1->class;

        $1->aused = true;
    }
@
% similar to tag rule

% rename mkstatic_if_local?
% rename locals in global symbol table so have unique name with the block
<<function mkstatic>>=
Sym*
mkstatic(Sym *s)
{
    Sym *s1;

    if(s->class != CLOCAL)
        return s;

    snprint(symb, NSYMB, "%s$%d", s->name, s->block);
    s1 = lookup();

    if(s1->class != CSTATIC) {
        s1->type = s->type;
        s1->offset = s->offset;
        s1->block = s->block;
        s1->class = CSTATIC;
    }
    return s1;
}
@

\subsection{Numeric Constants}

<<pexpr rule>>=
|   LCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@

<<pexpr rule>>=
|   LUCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUINT];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LULCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TULONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
|   LUVLCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TUVLONG];
        $$->vconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$

<<pexpr rule>>=
|   LFCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TFLOAT];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
|   LDCONST
    {
        $$ = new(OCONST, Z, Z);
        $$->type = types[TDOUBLE];
        $$->fconst = $1;
        $$->cstring = strdup(symb);
    }
@
%$

\subsection{String constants}
% char constant? unsugard in yylex?

<<pexpr rule>>=
|   string
|   lstring
@

<<expressions rules>>=
string:
    LSTRING
    {
        $$ = new(OSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TCHAR]);
        $$->etype = TARRAY;
        $$->type->width = $1.l + 1;
        $$->cstring = $1.s;
        $$->sym = symstring;
        $$->class = CSTATIC;
    }
|   string LSTRING
    {
        char *s;
        int n;

        n = $1->type->width - 1;
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->cstring, n);
        memcpy(s+n, $2.s, $2.l);
        s[n+$2.l] = '\0';

        $$ = $1;
        $$->type->width += $2.l;
        $$->cstring = s;
    }
@

% unicode
<<expressions rules>>=
lstring:
    LLSTRING
    {
        $$ = new(OLSTRING, Z, Z);
        $$->type = typ(TARRAY, types[TRUNE]);
        $$->etype = TARRAY;
        $$->type->width = $1.l + sizeof(TRune);
        $$->rstring = (TRune*)$1.s;
        $$->sym = symstring;
        $$->class = CSTATIC;
    }
|   lstring LLSTRING
    {
        char *s;
        int n;

        n = $1->type->width - sizeof(TRune);
        s = alloc(n+$2.l+MAXALIGN);

        memcpy(s, $1->rstring, n);
        memcpy(s+n, $2.s, $2.l);
        *(TRune*)(s+n+$2.l) = 0;

        $$ = $1;
        $$->type->width += $2.l;
        $$->rstring = (TRune*)s;
    }
@


\section{Initializers}

% in decl?:
%    '=' init
%    {
%        doinit($1->sym, $1->type, 0L, $4);
%    }

<<initializers rules>>=
init:
    expr
|   '{' ilist '}' { $$ = new(OINIT, invert($2), Z); }

ilist:
    qlist
|   init
|   qlist init { $$ = new(OLIST, $1, $2); }

qlist:
    init ','
|   qlist init ','  { $$ = new(OLIST, $1, $2); }
|   qual
|   qlist qual      { $$ = new(OLIST, $1, $2); }

qual:
    '[' lexpr ']' { $$ = new(OARRAY, $2, Z); }
|   '.' ltag
    {
        $$ = new(OELEM, Z, Z);
        $$->sym = $2;
    }
|   qual '='
@
%$
% alternate syntax qual =


% in decl?:
%    '=' init
%    {
%        doinit($1->sym, $1->type, 0L, $4);
%    }

<<global initlist>>=
Node*	initlist;
@

<<function doinit>>=
Node*
doinit(Sym *s, Type *t, long o, Node *a)
{
    Node *n;

    if(t == T)
        return Z;
    if(s->class == CEXTERN) {
        s->class = CGLOBL;
        if(debug['d'])
            dbgdecl(s);
    }
    if(debug['i']) {
        print("t = %T; o = %ld; n = %s\n", t, o, s->name);
        prtree(a, "doinit value");
    }


    n = initlist;
    if(a->op == OINIT)
        a = a->left;
    initlist = a;

    a = init1(s, t, o, 0);
    if(initlist != Z)
        diag(initlist, "more initializers than structure: %s",
            s->name);
    initlist = n;

    return a;
}
@


% could be made a static local of init1?
<<global nodcast>>=
Node*	nodcast;
@


<<function init1>>=
Node*
init1(Sym *s, Type *t, long o, int exflag)
{
    Node *a, *l, *r, nod;
    Type *t1;
    long e, w, so, mw;

    a = peekinit();
    if(a == Z)
        return Z;

    if(debug['i']) {
        print("t = %T; o = %ld; n = %s\n", t, o, s->name);
        prtree(a, "init1 value");
    }

    if(exflag && a->op == OINIT)
        return doinit(s, t, o, nextinit());

    switch(t->etype) {
    default:
        diag(Z, "unknown type in initialization: %T to: %s", t, s->name);
        return Z;

    case TCHAR:
    case TUCHAR:
    case TINT:
    case TUINT:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
    case TIND:
    single:
        if(a->op == OARRAY || a->op == OELEM)
            return Z;

        a = nextinit();
        if(a == Z)
            return Z;

        if(t->nbits)
            diag(Z, "cannot initialize bitfields");
        if(s->class == CAUTO) {
            l = new(ONAME, Z, Z);
            l->sym = s;
            l->type = t;
            l->etype = TVOID;
            if(s->type)
                l->etype = s->type->etype;
            l->xoffset = s->offset + o;
            l->class = s->class;

            l = new(OASI, l, a);
            return l;
        }

        complex(a);
        if(a->type == T)
            return Z;

        if(a->op == OCONST) {
            if(vconst(a) && t->etype == TIND && a->type && a->type->etype != TIND){
                diag(a, "initialize pointer to an integer: %s", s->name);
                return Z;
            }
            if(!sametype(a->type, t)) {
                /* hoop jumping to save malloc */
                if(nodcast == Z)
                    nodcast = new(OCAST, Z, Z);
                nod = *nodcast;
                nod.left = a;
                nod.type = t;
                nod.lineno = a->lineno;
                complex(&nod);
                if(nod.type)
                    *a = nod;
            }
            if(a->op != OCONST) {
                diag(a, "initializer is not a constant: %s",
                    s->name);
                return Z;
            }
            if(vconst(a) == 0)
                return Z;
            goto gext;
        }
        if(t->etype == TIND) {
            while(a->op == OCAST) {
                warn(a, "CAST in initialization ignored");
                a = a->left;
            }
            if(!sametype(t, a->type)) {
                diag(a, "initialization of incompatible pointers: %s\n%T and %T",
                    s->name, t, a->type);
            }
            if(a->op == OADDR)
                a = a->left;
            goto gext;
        }

        while(a->op == OCAST)
            a = a->left;
        if(a->op == OADDR) {
            warn(a, "initialize pointer to an integer: %s", s->name);
            a = a->left;
            goto gext;
        }
        diag(a, "initializer is not a constant: %s", s->name);
        return Z;

    gext:
        gextern(s, a, o, t->width);

        return Z;

    case TARRAY:
        w = t->link->width;
        if(a->op == OSTRING || a->op == OLSTRING)
        if(typei[t->link->etype]) {
            /*
             * get rid of null if sizes match exactly
             */
            a = nextinit();
            mw = t->width/w;
            so = a->type->width/a->type->link->width;
            if(mw && so > mw) {
                if(so != mw+1)
                    diag(a, "string initialization larger than array");
                a->type->width -= a->type->link->width;
            }

            /*
             * arrange strings to be expanded
             * inside OINIT braces.
             */
            a = new(OUSED, a, Z);
            return doinit(s, t, o, a);
        }

        mw = -w;
        l = Z;
        for(e=0;;) {
            /*
             * peek ahead for element initializer
             */
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM && t->link->etype != TSTRUCT)
                break;
            if(a->op == OARRAY) {
                if(e && exflag)
                    break;
                a = nextinit();
                r = a->left;
                complex(r);
                if(r->op != OCONST) {
                    diag(r, "initializer subscript must be constant");
                    return Z;
                }
                e = r->vconst;
                if(t->width != 0)
                    if(e < 0 || e*w >= t->width) {
                        diag(a, "initialization index out of range: %ld", e);
                        continue;
                    }
            }

            so = e*w;
            if(so > mw)
                mw = so;
            if(t->width != 0)
                if(mw >= t->width)
                    break;
            r = init1(s, t->link, o+so, 1);
            l = newlist(l, r);
            e++;
        }
        if(t->width == 0)
            t->width = mw+w;
        return l;

    case TUNION:
    case TSTRUCT:
        /*
         * peek ahead to find type of rhs.
         * if its a structure, then treat
         * this element as a variable
         * rather than an aggregate.
         */
        if(isstruct(a, t))
            goto single;

        if(t->width <= 0) {
            diag(Z, "incomplete structure: %s", s->name);
            return Z;
        }
        l = Z;

    again:
        for(t1 = t->link; t1 != T; t1 = t1->down) {
            if(a->op == OARRAY && t1->etype != TARRAY)
                break;
            if(a->op == OELEM) {
                if(t1->sym != a->sym)
                    continue;
                nextinit();
            }
            r = init1(s, t1, o+t1->offset, 1);
            l = newlist(l, r);
            a = peekinit();
            if(a == Z)
                break;
            if(a->op == OELEM)
                goto again;
        }
        if(a && a->op == OELEM)
            diag(a, "structure element not found %F", a);
        return l;
    }
}
@

<<function newlist>>=
Node*
newlist(Node *l, Node *r)
{
    if(r == Z)
        return l;
    if(l == Z)
        return r;
    return new(OLIST, l, r);
}
@

<<function isstruct>>=
int
isstruct(Node *a, Type *t)
{
    Node *n;

    switch(a->op) {
    case ODOTDOT:
        n = a->left;
        if(n && n->type && sametype(n->type, t))
            return 1;
    case OSTRING:
    case OLSTRING:
    case OCONST:
    case OINIT:
    case OELEM:
        return 0;
    }

    n = new(ODOTDOT, Z, Z);
    *n = *a;

    /*
     * ODOTDOT is a flag for tcom
     * a second tcom will not be performed
     */
    a->op = ODOTDOT;
    a->left = n;
    a->right = Z;

    if(tcom(n))
        return 0;

    if(sametype(n->type, t))
        return 1;
    return 0;
}
@

<<function peekinit>>=
/*
 * get next major operator,
 * dont advance initlist.
 */
Node*
peekinit(void)
{
    Node *a;

    a = initlist;

loop:
    if(a == Z)
        return a;
    if(a->op == OLIST) {
        a = a->left;
        goto loop;
    }
    return a;
}
@

<<function nextinit>>=
/*
 * consume and return next element on
 * initlist. expand strings.
 */
Node*
nextinit(void)
{
    Node *a, *b, *n;

    a = initlist;
    n = Z;

    if(a == Z)
        return a;
    if(a->op == OLIST) {
        n = a->right;
        a = a->left;
    }
    if(a->op == OUSED) {
        a = a->left;
        b = new(OCONST, Z, Z);
        b->type = a->type->link;
        if(a->op == OSTRING) {
            b->vconst = convvtox(*a->cstring, TCHAR);
            a->cstring++;
        }
        if(a->op == OLSTRING) {
            b->vconst = convvtox(*a->rstring, TRUNE);
            a->rstring++;
        }
        a->type->width -= b->type->width;
        if(a->type->width <= 0)
            initlist = n;
        return b;
    }
    initlist = n;
    return a;
}
@

\section{Types and storage classes}

% bitset, because need to aggregate keywords to form the final thing.
% to transform from 'unsigned char' -> TUCHAR?
% pre: Txxx must have less than 64 cases? 1L => long => long enum
<<enum bxxx>>=
enum bxxx
{
    BCHAR		= 1L<<TCHAR,
    BUCHAR		= 1L<<TUCHAR,
    BSHORT		= 1L<<TSHORT,
    BUSHORT		= 1L<<TUSHORT,
    BINT		= 1L<<TINT,
    BUINT		= 1L<<TUINT,
    BLONG		= 1L<<TLONG,
    BULONG		= 1L<<TULONG,
    BVLONG		= 1L<<TVLONG,
    BUVLONG		= 1L<<TUVLONG,
    BFLOAT		= 1L<<TFLOAT,
    BDOUBLE		= 1L<<TDOUBLE,

    BIND		= 1L<<TIND,
    BFUNC		= 1L<<TFUNC,
    BARRAY		= 1L<<TARRAY,
    BVOID		= 1L<<TVOID,
    BSTRUCT		= 1L<<TSTRUCT,
    BUNION		= 1L<<TUNION,
    BENUM		= 1L<<TENUM,

    BFILE		= 1L<<TFILE,
    BDOT		= 1L<<TDOT,

    BCONSTNT	= 1L<<TCONSTNT,
    BVOLATILE	= 1L<<TVOLATILE,

    BUNSIGNED	= 1L<<TUNSIGNED,
    BSIGNED		= 1L<<TSIGNED,

    BAUTO		= 1L<<TAUTO,
    BEXTERN		= 1L<<TEXTERN,
    BSTATIC		= 1L<<TSTATIC,

    BTYPEDEF	= 1L<<TTYPEDEF,
    BTYPESTR	= 1L<<TTYPESTR,
    BREGISTER	= 1L<<TREGISTER,


    BINTEGER	= BCHAR|BUCHAR|BSHORT|BUSHORT|BINT|BUINT|
                BLONG|BULONG|BVLONG|BUVLONG,
    BNUMBER		= BINTEGER|BFLOAT|BDOUBLE,

/* these can be overloaded with complex types */

    BCLASS		= BAUTO|BEXTERN|BSTATIC|BTYPEDEF|BTYPESTR|BREGISTER,
    BGARB		= BCONSTNT|BVOLATILE,
};
@

% see also enum<cxxx> and enum<type_kind>


% bitset<enum<bxxx> > actually
<<type declarations>>=
%type   <lval>  tname cname gname
@

<<types rules>>=
tname:  /* type words */
    LCHAR     { $$ = BCHAR; }
|   LSHORT    { $$ = BSHORT; }
|   LINT      { $$ = BINT; }
|   LLONG     { $$ = BLONG; }
|   LSIGNED   { $$ = BSIGNED; }
|   LUNSIGNED { $$ = BUNSIGNED; }
|   LFLOAT    { $$ = BFLOAT; }
|   LDOUBLE   { $$ = BDOUBLE; }
|   LVOID     { $$ = BVOID; }
@

<<types rules>>=
cname:  /* class words */
    LAUTO     { $$ = BAUTO; }
|   LSTATIC   { $$ = BSTATIC; }
|   LEXTERN   { $$ = BEXTERN; }
|   LTYPEDEF  { $$ = BTYPEDEF; }
|   LTYPESTR  { $$ = BTYPESTR; }
|   LREGISTER { $$ = BREGISTER; }
|   LINLINE   { $$ = 0; }
@

% garbage?
<<types rules>>=
gname:  /* garbage words */
    LCONSTNT  { $$ = BCONSTNT; }
|   LVOLATILE { $$ = BVOLATILE; }
|   LRESTRICT { $$ = 0; }
@


<<type declarations>>=
%type   <lval>   gcname   gctname
@

<<names rules>>=
gctname:
    tname
|   gname
|   cname

gcname:
    gname
|   cname
@



% type and class
<<[[union yacc]] other fields>>=
struct
{
    Type*   t;
    // enum<cxxx>
    byte   c;
} tycl;
@

<<[[union yacc]] other fields>>=
Type*   type;
@


<<type declarations>>=
%type   <tycl>  types
@


<<types rules>>=
<<types rule>>
@

% sizeof, cast, context
<<extra grammar rules>>=
tlist:
    types
    {
        $$ = $1.t;
        if($1.c != CXXX)
            diag(Z, "illegal combination of class 4: %s", cnames[$1.c]);
    }
@
% do not allow to specify storage class
% (hmmm could have done via grammar?)

<<type declarations>>=
%type   <type> tlist
@


\subsection{Simple types}

<<types rule>>=
types:
   tname
    {
        $$.t = simplet($1);
        $$.c = CXXX;
    }
@
%$


<<types rule>>=
|   gcnlist
    {
        $$.t = simplet($1);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   tname gctnlist
    {
        $$.t = simplet(typebitor($1, $2));
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
    }
|   gcnlist tname
    {
        $$.t = simplet($2);
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1);
    }
|   gcnlist tname gctnlist
    {
        $$.t = simplet(typebitor($2, $3));
        $$.c = simplec($1|$3);
        $$.t = garbt($$.t, $1|$3);
    }
@

<<function typebitor>>=
//@Scheck: used by cc.y
long typebitor(long a, long b)
{
    long c;

    c = a | b;
    if(a & b)
        if((a & b) == BLONG)
            c |= BVLONG;		/* long long => vlong */
        else
            warn(Z, "once is enough: %Q", a & b);
    return c;
}
@


<<type declarations>>=
%type   <lval>  gctnlist gcnlist zgnlist
@

<<types rules>>=
gctnlist:
    gctname
|   gctnlist gctname { $$ = typebitor($1, $2); }

zgnlist:
 /* empty */       { $$ = 0; }
|   zgnlist gname  { $$ = typebitor($1, $2); }

gcnlist:
    gcname
|   gcnlist gcname { $$ = typebitor($1, $2); }
@




<<function simplet>>=
Type*
simplet(long b)
{

    b &= ~BCLASS & ~BGARB;
    switch(b) {
    case BCHAR:
    case BCHAR|BSIGNED:
        return types[TCHAR];

    case BCHAR|BUNSIGNED:
        return types[TUCHAR];

    case BSHORT:
    case BSHORT|BINT:
    case BSHORT|BSIGNED:
    case BSHORT|BINT|BSIGNED:
        return types[TSHORT];

    case BUNSIGNED|BSHORT:
    case BUNSIGNED|BSHORT|BINT:
        return types[TUSHORT];

    case 0:
    case BINT:
    case BINT|BSIGNED:
    case BSIGNED:
        return types[TINT];

    case BUNSIGNED:
    case BUNSIGNED|BINT:
        return types[TUINT];

    case BLONG:
    case BLONG|BINT:
    case BLONG|BSIGNED:
    case BLONG|BINT|BSIGNED:
        return types[TLONG];

    case BUNSIGNED|BLONG:
    case BUNSIGNED|BLONG|BINT:
        return types[TULONG];

    case BVLONG|BLONG:
    case BVLONG|BLONG|BINT:
    case BVLONG|BLONG|BSIGNED:
    case BVLONG|BLONG|BINT|BSIGNED:
        return types[TVLONG];

    case BVLONG|BLONG|BUNSIGNED:
    case BVLONG|BLONG|BINT|BUNSIGNED:
        return types[TUVLONG];

    case BFLOAT:
        return types[TFLOAT];

    case BDOUBLE:
    case BDOUBLE|BLONG:
    case BFLOAT|BLONG:
        return types[TDOUBLE];

    case BVOID:
        return types[TVOID];
    }

    diag(Z, "illegal combination of types %Q", b);
    return types[TINT];
}
@


<<function simplec>>=
//@Scheck: used by cc.y
int simplec(long b)
{

    b &= BCLASS;
    switch(b) {
    case 0:
    case BREGISTER:
        return CXXX;
    case BAUTO:
    case BAUTO|BREGISTER:
        return CAUTO;
    case BEXTERN:
        return CEXTERN;
    case BEXTERN|BREGISTER:
        return CEXREG;
    case BSTATIC:
        return CSTATIC;
    case BTYPEDEF:
        return CTYPEDEF;
    case BTYPESTR:
        return CTYPESTR;
    }
    diag(Z, "illegal combination of classes %Q", b);
    return CXXX;
}
@


<<function garbt>>=
//@Scheck: used by cc.y
Type* garbt(Type *t, long b)
{
    Type *t1;

    if(b & BGARB) {
        t1 = copytyp(t);
        t1->garb = simpleg(b);
        return t1;
    }
    return t;
}
@

<<function simpleg>>=
int
simpleg(long b)
{

    b &= BGARB;
    switch(b) {
    case BCONSTNT:
        return GCONSTNT;
    case BVOLATILE:
        return GVOLATILE;
    case BVOLATILE|BCONSTNT:
        return GCONSTNT|GVOLATILE;
    }
    return GXXX;
}
@

\subsection{Complex types}

<<types rule>>=
|  complex
    {
        $$.t = $1;
        $$.c = CXXX;
    }
|  complex gctnlist
    {
        $$.t = $1;
        $$.c = simplec($2);
        $$.t = garbt($$.t, $2);
        if($2 & ~BCLASS & ~BGARB)
            diag(Z, "duplicate types given: %T and %Q", $1, $2);
    }
|   gcnlist complex zgnlist
    {
        $$.t = $2;
        $$.c = simplec($1);
        $$.t = garbt($$.t, $1|$3);
    }
@
%$

<<types rules>>=
<<complex rule>>
@

<<type declarations>>=
%type   <type>  complex
@

\subsection{Typedefs}

% uses
<<complex rule>>=
complex:
    LTYPE { $$ = tcopy($1->type); }
@
%$

<<function tcopy>>=
/*
 * make a copy of a typedef
 * the problem is to split out incomplete
 * arrays so that it is in the variable
 * rather than the typedef.
 */
Type*
tcopy(Type *t)
{
    Type *tl, *tx;
    int et;

    if(t == T)
        return t;
    et = t->etype;
    if(typesu[et])
        return t;
    tl = tcopy(t->link);
    if(tl != t->link ||
      (et == TARRAY && t->width == 0)) {
        tx = copytyp(t);
        tx->link = tl;
        return tx;
    }
    return t;
}
@


% defs ?



\subsection{Structures and unions}

<<type declarations>>=
%type   <sym>   ltag
@

%use
<<complex rule>>=
|   LSTRUCT ltag
    {
        dotag($2, TSTRUCT, 0);
        $$ = $2->suetag;
    }
|   LUNION ltag
    {
        dotag($2, TUNION, 0);
        $$ = $2->suetag;
    }
@

% when the name refers to a tag, lookup its final def
% sue? structure union enum?
<<[[Sym]] other fields>>=
Type*	suetag;
@
% rename sue_tag_type?

<<[[Type]] other fields>>=
Sym*	tag;
@
% mutual ref


% depth of struct
<<[[Sym]] other fields>>=
ushort	sueblock;
@

% LP split bn != 0
<<function dotag>>=
//@Scheck: used by cc.y
Type* dotag(Sym *s, int et, int bn)
{
    Decl *d;

    if(bn != 0 && bn != s->sueblock) {
        d = push();
        d->sym = s;
        d->val = DSUE;
        d->type = s->suetag;
        d->block = s->sueblock;
        s->suetag = T;
    }

    if(s->suetag == T) {
        s->suetag = typ(et, T);
        s->sueblock = autobn;
    }
    if(s->suetag->etype != et)
        diag(Z, "tag used for more than one type: %s",
            s->name);

    if(s->suetag->tag == S)
        s->suetag->tag = s;
    return s->suetag;
}
@


<<names rules>>=
tag:
    ltag
    {
        $$ = new(ONAME, Z, Z);
        $$->sym = $1;

        $$->type = $1->type;
        $$->etype = TVOID;
        if($$->type != T)
            $$->etype = $$->type->etype;

        $$->xoffset = $1->offset;
        $$->class = $1->class;
    }
@
% similar to name rule

<<names rules>>=
ltag:
    LNAME
|   LTYPE
@


% defs
<<complex rule>>=
|   LSTRUCT ltag
    {
        dotag($2, TSTRUCT, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        sualign($$);
    }
|   LUNION ltag
    {
        dotag($2, TUNION, autobn);
    }
    sbody
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        $$->link = $4;
        sualign($$);
    }
@
%$

% sualign() explained later in code gen chapter, alignment section


<<global taggen>>=
//@Scheck: used by cc.y
int	taggen;
@

% anon defs
<<complex rule>>=
|   LSTRUCT sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TSTRUCT, autobn);
        $$->link = $2;
        sualign($$);
    }
|   LUNION sbody
    {
        taggen++;
        sprint(symb, "_%d_", taggen);
        $$ = dotag(lookup(), TUNION, autobn);
        $$->link = $2;
        sualign($$);
    }
@





<<type declarations>>=
%type   <type> sbody
@

<<[[union yacc]] other fields>>=
struct
{
    Type*   t1;
    Type*   t2;
    Type*   t3;
    uchar   c;
} tyty;
@

<<global strf>>=
Type*	strf;
@

<<global strl>>=
Type*	strl;
@

<<global firstbit>>=
long	firstbit;
@

<<global lastbit>>=
long	lastbit;
@

<<types rule>>=
sbody:
    '{'
    {
        $<tyty>$.t1 = strf;
        $<tyty>$.t2 = strl;
        $<tyty>$.t3 = lasttype;
        $<tyty>$.c = lastclass;
        strf = T;
        strl = T;
        lastbit = 0;
        firstbit = 1;
        lastclass = CXXX;
        lasttype = T;
    }
    edecl 
    '}'
    {
        $$ = strf;
        strf = $<tyty>2.t1;
        strl = $<tyty>2.t2;
        lasttype = $<tyty>2.t3;
        lastclass = $<tyty>2.c;
    }

@
%$




<<structure element declarator rules>>=
/*
 * structure element declarator
 */
edecl:
    tlist
    {
        lasttype = $1;
    }
    zedlist ';'
|   edecl tlist
    {
        lasttype = $2;
    }
    zedlist ';'

zedlist:                    /* extension */
 /* empty */
    {
        lastfield = 0;
        edecl(CXXX, lasttype, S);
    }
|   edlist

edlist:
    edecor            { dodecl(edecl, CXXX, lasttype, $1); }
|   edlist ',' edlist

edecor:
    xdecor
    {
        lastbit = 0;
        firstbit = 1;
    }
|   tag ':' lexpr   { $$ = new(OBIT, $1, $3); }
|   ':' lexpr       { $$ = new(OBIT, Z, $2); }
@
%$

<<global lastfield>>=
long	lastfield;
@


<<function edecl>>=
//@Scheck: used by cc.y
void edecl(int c, Type *t, Sym *s)
{
    Type *t1;

    if(s == S) {
        if(!typesu[t->etype])
            diag(Z, "unnamed structure element must be struct/union");
        if(c != CXXX)
            diag(Z, "unnamed structure element cannot have class");
    } else
        if(c != CXXX)
            diag(Z, "structure element cannot have class: %s", s->name);
    t1 = t;
    t = copytyp(t1);
    t->sym = s;
    t->down = T;
    if(lastfield) {
        t->shift = lastbit - lastfield;
        t->nbits = lastfield;
        if(firstbit)
            t->shift = -t->shift;
        if(typeu[t->etype])
            t->etype = tufield->etype;
        else
            t->etype = tfield->etype;
    }
    if(strf == T)
        strf = t;
    else
        strl->down = t;
    strl = t;
}
@


\subsection{Enum}

<<struct En>>=
struct En
{
    Type*	tenum;		/* type of entire enum */

    Type*	cenum;		/* type of current enum run */

    vlong	lastenum;	/* value of current enum */
    double	floatenum;	/* value of current enum */ // for floats enums
};
@
% vlong! so can have 64 bitsets

<<global en>>=
struct En en;
@


% same dotag than for struct/union, cos same namespace
<<complex rule>>=
|   LENUM ltag
    {
        dotag($2, TENUM, 0);
        $$ = $2->suetag;
        if($$->link == T)
            $$->link = types[TINT];
        $$ = $$->link;
    }
|   LENUM ltag
    {
        dotag($2, TENUM, autobn);
    }
    '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum 
     '}'
    {
        $$ = $2->suetag;
        if($$->link != T)
            diag(Z, "redeclare tag: %s", $2->name);
        if(en.tenum == T) {
            diag(Z, "enum type ambiguous: %s", $2->name);
            en.tenum = types[TINT];
        }
        $$->link = en.tenum;
        $$ = en.tenum;
    }
|   LENUM '{'
    {
        en.tenum = T;
        en.cenum = T;
    }
    enum '}'
    {
        $$ = en.tenum;
    }
@

<<types rules>>=
enum:
    LNAME           { doenum($1, Z); }
|   LNAME '=' expr  { doenum($1, $3); }
|   enum ','
|   enum ',' enum
@
%$



% ref to type of enum for each constants symbols of the enum?
<<[[Sym]] other fields>>=
// ref<Type>
Type*	tenum;
@


% n = optional expression for the value of the enum constant
<<function doenum>>=
//@Scheck: used by cc.y
void doenum(Sym *s, Node *n)
{

    if(n) {
        complex(n);
        if(n->op != OCONST) {
            diag(n, "enum not a constant: %s", s->name);
            return;
        }
        en.cenum = n->type;
        en.tenum = maxtype(en.cenum, en.tenum);

        if(!typefd[en.cenum->etype])
            en.lastenum = n->vconst;
        else
            en.floatenum = n->fconst;
    }
    if(dclstack)
        push1(s);
    xdecl(CXXX, types[TENUM], s);

    if(en.cenum == T) {
        en.tenum = types[TINT];
        en.cenum = types[TINT];
        en.lastenum = 0;
    }
    s->tenum = en.cenum;

    if(!typefd[s->tenum->etype]) {
        s->vconst = convvtox(en.lastenum, s->tenum->etype);
        en.lastenum++;
    } else {
        s->fconst = en.floatenum;
        en.floatenum++;
    }

    if(debug['d'])
        dbgdecl(s);
    acidvar(s);
}
@

<<function maxtype>>=
/*
 * this routine is very suspect.
 * ansi requires the enum type to
 * be represented as an 'int'
 * this means that 0x81234567
 * would be illegal. this routine
 * makes signed and unsigned go
 * to unsigned.
 */
Type*
maxtype(Type *t1, Type *t2)
{

    if(t1 == T)
        return t2;
    if(t2 == T)
        return t1;
    if(t1->etype > t2->etype)
        return t1;
    return t2;
}
@


\section{Declarations and definitions, part two}

<<constant NODECL>>=
#define	NODECL	((void(*)(int, Type*, Sym*))nil)
@

<<function dodecl>>=
Node*
dodecl(void (*f)(int,Type*,Sym*), int c, Type *t, Node *n)
{
    Sym *s;
    Node *n1;
    long v;

    nearln = lineno;
    lastfield = 0;

loop:
    if(n != Z)
    switch(n->op) {
    default:
        diag(n, "unknown declarator: %O", n->op);
        break;

    case OARRAY:
        t = typ(TARRAY, t);
        t->width = 0;
        n1 = n->right;
        n = n->left;
        if(n1 != Z) {
            complex(n1);
            v = -1;
            if(n1->op == OCONST)
                v = n1->vconst;
            if(v <= 0) {
                diag(n, "array size must be a positive constant");
                v = 1;
            }
            t->width = v * t->link->width;
        }
        goto loop;

    case OIND:
        t = typ(TIND, t);
        t->garb = n->garb;
        n = n->left;
        goto loop;

    case OFUNC:
        t = typ(TFUNC, t);
        t->down = fnproto(n);
        n = n->left;
        goto loop;

    case OBIT:
        n1 = n->right;
        complex(n1);
        lastfield = -1;
        if(n1->op == OCONST)
            lastfield = n1->vconst;
        if(lastfield < 0) {
            diag(n, "field width must be non-negative constant");
            lastfield = 1;
        }
        if(lastfield == 0) {
            lastbit = 0;
            firstbit = 1;
            if(n->left != Z) {
                diag(n, "zero width named field");
                lastfield = 1;
            }
        }
        if(!typei[t->etype]) {
            diag(n, "field type must be int-like");
            t = types[TINT];
            lastfield = 1;
        }
        if(lastfield > tfield->width*8) {
            diag(n, "field width larger than field unit");
            lastfield = 1;
        }
        lastbit += lastfield;
        if(lastbit > tfield->width*8) {
            lastbit = lastfield;
            firstbit = 1;
        }
        n = n->left;
        goto loop;

    case ONAME:
        if(f == NODECL)
            break;
        s = n->sym;
        (*f)(c, t, s);
        if(s->class == CLOCAL)
            s = mkstatic(s);
        firstbit = 0;
        n->sym = s;
        n->type = s->type;
        n->xoffset = s->offset;
        n->class = s->class;
        n->etype = TVOID;
        if(n->type != T)
            n->etype = n->type->etype;
        if(debug['d'])
            dbgdecl(s);
        acidvar(s);
        s->varlineno = lineno;
        break;
    }

    lastdcl = t;
    return n;
}
@



<<function xdecl>>=
void
xdecl(int c, Type *t, Sym *s)
{
    long o;

    o = 0;
    switch(c) {
    case CEXREG:
        o = exreg(t);
        if(o == 0)
            c = CEXTERN;
        if(s->class == CGLOBL)
            c = CGLOBL;
        break;

    case CEXTERN:
        if(s->class == CGLOBL)
            c = CGLOBL;
        break;

    case CXXX:
        c = CGLOBL;
        if(s->class == CEXTERN)
            s->class = CGLOBL;
        break;

    case CAUTO:
        diag(Z, "overspecified class: %s %s %s", s->name, cnames[c], cnames[s->class]);
        c = CEXTERN;
        break;

    case CTYPESTR:
        if(!typesuv[t->etype]) {
            diag(Z, "typestr must be struct/union: %s", s->name);
            break;
        }
        dclfunct(t, s);
        break;
    }

    if(s->class == CSTATIC)
        if(c == CEXTERN || c == CGLOBL) {
            warn(Z, "overspecified class: %s %s %s", s->name, cnames[c], cnames[s->class]);
            c = CSTATIC;
        }
    if(s->type != T)
        if(s->class != c || !sametype(t, s->type) || t->etype == TENUM) {
            diag(Z, "external redeclaration of: %s", s->name);
            Bprint(&diagbuf, "	%s %T %L\n", cnames[c], t, nearln);
            Bprint(&diagbuf, "	%s %T %L\n", cnames[s->class], s->type, s->varlineno);
        }
    tmerge(t, s);
    s->type = t;
    s->class = c;
    s->block = 0;
    s->offset = o;
}
@





\subsection{External declarator}

<<external declarator rules>>=
xdlist:
    xdecor  { dodecl(xdecl, lastclass, lasttype, $1); }
|   xdecor
    {
        $1 = dodecl(xdecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        doinit($1->sym, $1->type, 0L, $4);
    }
|   xdlist ',' xdlist

xdecor:
    xdecor2
|   '*' zgnlist xdecor
    {
        $$ = new(OIND, $3, Z);
        $$->garb = simpleg($2);
    }

xdecor2:
    tag
|   '(' xdecor ')'             { $$ = $2;   }
|   xdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
|   xdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }
@
%$

<<ebnf grammar rules>>=
zctlist:
 /* empty */
    {
        lastclass = CXXX;
        lasttype = types[TINT];
    }
|   ctlist
@

<<extra grammar rules>>=
ctlist:
    types
    {
        lasttype = $1.t;
        lastclass = $1.c;
    }
@
% it's not really types, it's types_and_storage really

\subsection{Automatic declarator}

<<automatic declarator rules>>=
/*
 * automatic declarator
 */
adecl:
    ctlist ';'        { $$ = dodecl(adecl, lastclass, lasttype, Z); }
|   ctlist adlist ';' { $$ = $2; }

adlist:
    xdecor
    {
        dodecl(adecl, lastclass, lasttype, $1);
        $$ = Z;
    }
|   xdecor
    {
        $1 = dodecl(adecl, lastclass, lasttype, $1);
    }
    '=' init
    {
        long w;

        w = $1->sym->type->width;
        $$ = doinit($1->sym, $1->type, 0L, $4);
        $$ = contig($1->sym, $$, w);
    }
|   adlist ',' adlist
    {
        $$ = $1;
        if($3 != Z) {
            $$ = $3;
            if($1 != Z)
                $$ = new(OLIST, $1, $3);
        }
    }
@
%$


<<function adecl>>=
void
adecl(int c, Type *t, Sym *s)
{

    if(c == CSTATIC)
        c = CLOCAL;
    if(t->etype == TFUNC) {
        if(c == CXXX)
            c = CEXTERN;
        if(c == CLOCAL)
            c = CSTATIC;
        if(c == CAUTO || c == CEXREG)
            diag(Z, "function cannot be %s %s", cnames[c], s->name);
    }
    if(c == CXXX)
        c = CAUTO;
    if(s) {
        if(s->class == CSTATIC)
            if(c == CEXTERN || c == CGLOBL) {
                warn(Z, "just say static: %s", s->name);
                c = CSTATIC;
            }
        if(s->class == CAUTO || s->class == CPARAM || s->class == CLOCAL)
        if(s->block == autobn)
            diag(Z, "auto redeclaration of: %s", s->name);
        if(c != CPARAM)
            push1(s);
        s->block = autobn;
        s->offset = 0;
        s->type = t;
        s->class = c;
        s->aused = 0;
    }
    switch(c) {
    case CAUTO:
        autoffset = align(autoffset, t, Aaut3);
        stkoff = maxround(stkoff, autoffset);
        s->offset = -autoffset;
        break;

    case CPARAM:
        if(autoffset == 0) {
            firstarg = s;
            firstargtype = t;
        }
        autoffset = align(autoffset, t, Aarg1);
        if(s)
            s->offset = autoffset;
        autoffset = align(autoffset, t, Aarg2);
        break;
    }
}
@



<<function contig>>=
//@Scheck: used by cc.y
Node* contig(Sym *s, Node *n, long v)
{
    Node *p, *r, *q, *m;
    long w;
    Type *zt;

    if(debug['i']) {
        print("contig v = %ld; s = %s\n", v, s->name);
        prtree(n, "doinit value");
    }

    if(n == Z)
        goto no;
    w = s->type->width;

    /*
     * nightmare: an automatic array whose size
     * increases when it is initialized
     */
    if(v != w) {
        if(v != 0)
            diag(n, "automatic adjustable array: %s", s->name);
        v = s->offset;
        autoffset = align(autoffset, s->type, Aaut3);
        s->offset = -autoffset;
        stkoff = maxround(stkoff, autoffset);
        symadjust(s, n, v - s->offset);
    }
    if(w <= ewidth[TIND])
        goto no;
    if(n->op == OAS)
        diag(Z, "oops in contig");
/*ZZZ this appears incorrect
need to check if the list completely covers the data.
if not, bail
 */
    if(n->op == OLIST)
        goto no;
    if(n->op == OASI)
        if(n->left->type)
        if(n->left->type->width == w)
            goto no;
    while(w & (ewidth[TIND]-1))
        w++;
/*
 * insert the following code, where long becomes vlong if pointers are fat
 *
    *(long**)&X = (long*)((char*)X + sizeof(X));
    do {
        *(long**)&X -= 1;
        **(long**)&X = 0;
    } while(*(long**)&X);
 */

    for(q=n; q->op != ONAME; q=q->left)
        ;

    zt = ewidth[TIND] > ewidth[TLONG]? types[TVLONG]: types[TLONG];

    p = new(ONAME, Z, Z);
    *p = *q;
    p->type = typ(TIND, zt);
    p->xoffset = s->offset;

    r = new(ONAME, Z, Z);
    *r = *p;
    r = new(OPOSTDEC, r, Z);

    q = new(ONAME, Z, Z);
    *q = *p;
    q = new(OIND, q, Z);

    m = new(OCONST, Z, Z);
    m->vconst = 0;
    m->type = zt;

    q = new(OAS, q, m);

    r = new(OLIST, r, q);

    q = new(ONAME, Z, Z);
    *q = *p;
    r = new(ODWHILE, q, r);

    q = new(ONAME, Z, Z);
    *q = *p;
    q->type = q->type->link;
    q->xoffset += w;
    q = new(OADDR, q, 0);

    q = new(OASI, p, q);
    r = new(OLIST, q, r);

    n = new(OLIST, r, n);

no:
    return n;
}
@


<<function symadjust>>=
void
symadjust(Sym *s, Node *n, long del)
{

    switch(n->op) {
    default:
        if(n->left)
            symadjust(s, n->left, del);
        if(n->right)
            symadjust(s, n->right, del);
        return;

    case ONAME:
        if(n->sym == s)
            n->xoffset -= del;
        return;

    case OCONST:
    case OSTRING:
    case OLSTRING:
    case OINDREG:
    case OREGISTER:
        return;
    }
}
@


\subsection{Abstract declarator}

<<abstract declarator rules>>=
/*
 * abstract declarator
 */
abdecor:
  /* empty */ { $$ = Z; }
|   abdecor1

abdecor1:
    '*' zgnlist
    {
        $$ = new(OIND, (Z), Z);
        $$->garb = simpleg($2);
    }
|   '*' zgnlist abdecor1
    {
        $$ = new(OIND, $3, Z);
        $$->garb = simpleg($2);
    }
|   abdecor2

abdecor2:
    abdecor3
|   abdecor2 '(' zarglist ')'   { $$ = new(OFUNC, $1, $3); }
|   abdecor2 '[' zexpr ']'      { $$ = new(OARRAY, $1, $3); }

abdecor3:
    '(' ')'           { $$ = new(OFUNC, Z, Z); }
|   '[' zexpr ']'     { $$ = new(OARRAY, Z, $2); }
|   '(' abdecor1 ')'  { $$ = $2; }
@
%$




\section{Helpers}

% invert in place
<<function invert>>=
Node*
invert(Node *n)
{
    Node *i;

    if(n == Z || n->op != OLIST)
        return n;
    i = n;
    for(n = n->left; n != Z; n = n->left) {
        if(n->op != OLIST)
            break;
        i->left = n->right;
        n->right = i;
        i = n;
    }
    i->left = n;
    return i;
}
@


\chapter{Checking}

\section{Overview}

% - symbol resolution (use/def matching correctly)
% - scoping rules
% - typechecking rules
% - lint rules (e.g. unused and dead code)

\section{Printing warnings, [[8c -w]], [[8c -W]]}

% 8c -w
% 8c -W give full verbose diagnostic

<<function warn>>=
void
warn(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    if(debug['w'] || debug['W']) {
        va_start(arg, fmt);
        vseprint(buf, buf+sizeof(buf), fmt, arg);
        va_end(arg);

        if(debug['W']) {
            diag(n, "%s", buf);
            return;
        }

        Bprint(&diagbuf, "warning: %L %s\n", (n==Z)? nearln : n->lineno, buf);

        if(n != Z)
          if(debug['v'])
            prtree(n, "warning");
    }
}
@

<<function fatal>>=
void
fatal(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
      if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    errorexit();
}
@

\section{Symbol resolution}
% done in parsing, as C force to forward decl everything
% (and actual linking is done in linker to find inconsistencies)

\section{Scoping}

% see Decl section and markdcl and revertdecl

\section{Typechecking}
% and scoping and symbol resolution?

% remember type field in Node


% complex? compile lexical?
<<function complex>>=
void
complex(Node *n)
{

    if(n == Z)
        return;

    nearln = n->lineno;

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "pre complex");

    if(tcom(n))
        return;



    //if(debug['y'] || true)
    comma(n);

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "t complex");

    ccom(n);

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "c complex");

    acom(n);

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "a complex");

    xcom(n);

    if(debug['t'])
        if(n->op != OCONST)
            prtree(n, "x complex");
}
@

<<struct Com>>=
struct Com
{
    int	n;
    Node	*t[500];
};
@



\subsection{[[tcom()]]}
% cc/com.c

<<enum _anon_ (cc/com.c)>>=
/*
 * evaluate types
 * evaluate lvalues (addable == 1)
 */
enum
{
    ADDROF	= 1<<0,
    CASTOF	= 1<<1,
    ADDROP	= 1<<2,
};
@


% true means error
<<function tcom>>=
bool
tcom(Node *n)
{

    return tcomo(n, ADDROF);
}
@

% true means error
<<function tcomo>>=
bool
tcomo(Node *n, int f)
{
    Node *l, *r;
    Type *t;
    int o;
    static TRune zer;

    if(n == Z) {
        diag(Z, "Z in tcom");
        errorexit();
    }
    n->addable = 0;
    l = n->left;
    r = n->right;

    switch(n->op) {
    case ODOTDOT:
        /*
         * tcom has already been called on this subtree
         */
        *n = *n->left;
        if(n->type == T)
            goto bad;
        break;

    case OCAST:
        if(n->type == T)
            break;
        if(n->type->width == types[TLONG]->width) {
            if(tcomo(l, ADDROF|CASTOF))
                goto bad;
        } else
            if(tcom(l))
                goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, n->type, tcast))
            goto bad;
        break;

    case ORETURN:
        if(l == Z) {
            if(n->type->etype != TVOID)
                warn(n, "null return of a typed function");
            break;
        }
        if(tcom(l))
            goto bad;
        typeext(n->type, l);
        if(tcompat(n, n->type, l->type, tasign))
            break;
        constas(n, n->type, l->type);
        if(!sametype(n->type, l->type)) {
            l = new1(OCAST, l, Z);
            l->type = n->type;
            n->left = l;
        }
        break;

    case OASI:	/* same as as, but no test for const */
        n->op = OAS;
        o = tcom(l);
        if(o | tcom(r))
            goto bad;

        typeext(l->type, r);
        if(tlvalue(l) || tcompat(n, l->type, r->type, tasign))
            goto bad;
        if(!sametype(l->type, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = l->type;
            n->right = r;
        }
        n->type = l->type;
        break;

    case OAS:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext(l->type, r);
        if(tcompat(n, l->type, r->type, tasign))
            goto bad;
        constas(n, l->type, r->type);
        if(!sametype(l->type, r->type)) {
            r = new1(OCAST, r, Z);
            r->type = l->type;
            n->right = r;
        }
        n->type = l->type;
        break;

    case OASADD:
    case OASSUB:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        if(tcompat(n, l->type, r->type, tasadd))
            goto bad;
        constas(n, l->type, r->type);
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        break;

    case OASMUL:
    case OASLMUL:
    case OASDIV:
    case OASLDIV:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        if(tcompat(n, l->type, r->type, tmul))
            goto bad;
        constas(n, l->type, r->type);
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        if(typeu[n->type->etype]) {
            if(n->op == OASDIV)
                n->op = OASLDIV;
            if(n->op == OASMUL)
                n->op = OASLMUL;
        }
        break;

    case OASLSHR:
    case OASASHR:
    case OASASHL:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        n->type = l->type;
        n->right = new1(OCAST, r, Z);
        n->right->type = types[TINT];
        if(typeu[n->type->etype]) {
            if(n->op == OASASHR)
                n->op = OASLSHR;
        }
        break;

    case OASMOD:
    case OASLMOD:
    case OASOR:
    case OASAND:
    case OASXOR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        t = l->type;
        arith(n, 0);
        while(n->left->op == OCAST)
            n->left = n->left->left;
        if(!sametype(t, n->type) && !mixedasop(t, n->type)) {
            r = new1(OCAST, n->right, Z);
            r->type = t;
            n->right = r;
            n->type = t;
        }
        if(typeu[n->type->etype]) {
            if(n->op == OASMOD)
                n->op = OASLMOD;
        }
        break;

    case OPREINC:
    case OPREDEC:
    case OPOSTINC:
    case OPOSTDEC:
        if(tcom(l))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, types[TINT], tadd))
            goto bad;
        n->type = l->type;
        if(n->type->etype == TIND)
        if(n->type->link->width < 1) {
            snap(n->type->link);
            if(n->type->link->width < 1)
                diag(n, "inc/dec of a void pointer");
        }
        break;

    case OEQ:
    case ONE:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        typeext(l->type, r);
        typeext(r->type, l);
        if(tcompat(n, l->type, r->type, trel))
            goto bad;
        arith(n, 0);
        n->type = types[TINT];
        break;

    case OLT:
    case OGE:
    case OGT:
    case OLE:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        typeext1(l->type, r);
        typeext1(r->type, l);
        if(tcompat(n, l->type, r->type, trel))
            goto bad;
        arith(n, 0);
        if(typeu[n->type->etype])
            n->op = logrel[relindex(n->op)];
        n->type = types[TINT];
        break;

    case OCOND:
        o = tcom(l);
        o |= tcom(r->left);
        if(o | tcom(r->right))
            goto bad;
        if(r->right->type->etype == TIND && vconst(r->left) == 0) {
            r->left->type = r->right->type;
            r->left->vconst = 0;
        }
        if(r->left->type->etype == TIND && vconst(r->right) == 0) {
            r->right->type = r->left->type;
            r->right->vconst = 0;
        }
        if(sametype(r->right->type, r->left->type)) {
            r->type = r->right->type;
            n->type = r->type;
            break;
        }
        if(tcompat(r, r->left->type, r->right->type, trel))
            goto bad;
        arith(r, 0);
        n->type = r->type;
        break;

    case OADD:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tadd))
            goto bad;
        arith(n, 1);
        break;

    case OSUB:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tsub))
            goto bad;
        arith(n, 1);
        break;

    case OMUL:
    case OLMUL:
    case ODIV:
    case OLDIV:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tmul))
            goto bad;
        arith(n, 1);
        if(typeu[n->type->etype]) {
            if(n->op == ODIV)
                n->op = OLDIV;
            if(n->op == OMUL)
                n->op = OLMUL;
        }
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        n->right = Z;
        arith(n, 1);
        n->right = new1(OCAST, r, Z);
        n->right->type = types[TINT];
        if(typeu[n->type->etype])
            if(n->op == OASHR)
                n->op = OLSHR;
        break;

    case OAND:
    case OOR:
    case OXOR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        arith(n, 1);
        break;

    case OMOD:
    case OLMOD:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, l->type, r->type, tand))
            goto bad;
        arith(n, 1);
        if(typeu[n->type->etype])
            n->op = OLMOD;
        break;

    case OPOS:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        r = l;
        l = new(OCONST, Z, Z);
        l->vconst = 0;
        l->type = types[TINT];
        n->op = OADD;
        n->right = r;
        n->left = l;

        if(tcom(l))
            goto bad;
        if(tcompat(n, l->type, r->type, tsub))
            goto bad;
        arith(n, 1);
        break;

    case ONEG:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        if(!machcap(n)) {
            r = l;
            l = new(OCONST, Z, Z);
            l->vconst = 0;
            l->type = types[TINT];
            n->op = OSUB;
            n->right = r;
            n->left = l;

            if(tcom(l))
                goto bad;
            if(tcompat(n, l->type, r->type, tsub))
                goto bad;
        }
        arith(n, 1);
        break;

    case OCOM:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;

        if(!machcap(n)) {
            r = l;
            l = new(OCONST, Z, Z);
            l->vconst = -1;
            l->type = types[TINT];
            n->op = OXOR;
            n->right = r;
            n->left = l;

            if(tcom(l))
                goto bad;
            if(tcompat(n, l->type, r->type, tand))
                goto bad;
        }
        arith(n, 1);
        break;

    case ONOT:
        if(tcom(l))
            goto bad;
        if(isfunct(n))
            break;
        if(tcompat(n, T, l->type, tnot))
            goto bad;
        n->type = types[TINT];
        break;

    case OANDAND:
    case OOROR:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        if(tcompat(n, T, l->type, tnot) |
           tcompat(n, T, r->type, tnot))
            goto bad;
        n->type = types[TINT];
        break;

    case OCOMMA:
        o = tcom(l);
        if(o | tcom(r))
            goto bad;
        n->type = r->type;
        break;


    case OSIGN:	/* extension signof(type) returns a hash */
        if(l != Z) {
            if(l->op != OSTRING && l->op != OLSTRING)
                if(tcomo(l, 0))
                    goto bad;
            if(l->op == OBIT) {
                diag(n, "signof bitfield");
                goto bad;
            }
            n->type = l->type;
        }
        if(n->type == T)
            goto bad;
        if(n->type->width < 0) {
            diag(n, "signof undefined type");
            goto bad;
        }
        n->op = OCONST;
        n->left = Z;
        n->right = Z;
        n->vconst = convvtox(signature(n->type), TULONG);
        n->type = types[TULONG];
        break;

    case OSIZE:
        if(l != Z) {
            if(l->op != OSTRING && l->op != OLSTRING)
                if(tcomo(l, 0))
                    goto bad;
            if(l->op == OBIT) {
                diag(n, "sizeof bitfield");
                goto bad;
            }
            n->type = l->type;
        }
        if(n->type == T)
            goto bad;
        if(n->type->width <= 0) {
            diag(n, "sizeof undefined type");
            goto bad;
        }
        if(n->type->etype == TFUNC) {
            diag(n, "sizeof function");
            goto bad;
        }
        n->op = OCONST;
        n->left = Z;
        n->right = Z;
        n->vconst = convvtox(n->type->width, TINT);
        n->type = types[TINT];
        break;

    case OFUNC:
        o = tcomo(l, 0);
        if(o)
            goto bad;
        if(l->type->etype == TIND && l->type->link->etype == TFUNC) {
            l = new1(OIND, l, Z);
            l->type = l->left->type->link;
            n->left = l;
        }
        if(tcompat(n, T, l->type, tfunct))
            goto bad;
        if(o | tcoma(l, r, l->type->down, 1))
            goto bad;
        n->type = l->type->link;
        if(!debug['B'])
            if(l->type->down == T || l->type->down->etype == TOLD) {
                nerrors--;
                diag(n, "function args not checked: %F", l);
            }
        dpcheck(n);
        break;

    case ONAME:
        if(n->type == T) {
            diag(n, "name not declared: %F", n);
            goto bad;
        }
        if(n->type->etype == TENUM) {
            n->op = OCONST;
            n->type = n->sym->tenum;
            if(!typefd[n->type->etype])
                n->vconst = n->sym->vconst;
            else
                n->fconst = n->sym->fconst;
            break;
        }
        n->addable = 1;
        if(n->class == CEXREG) {
            n->op = OREGISTER;
            if(thechar == '8')
                n->op = OEXREG;
            n->reg = n->sym->offset;
            n->xoffset = 0;
            break;
        }
        break;

    case OLSTRING:
        if(n->type->link != types[TRUNE]) {
            o = outstring(0, 0);
            while(o & 3) {
                outlstring(&zer, sizeof(TRune));
                o = outlstring(0, 0);
            }
        }
        n->op = ONAME;
        n->xoffset = outlstring(n->rstring, n->type->width);
        n->addable = 1;
        break;

    case OSTRING:
        if(n->type->link != types[TCHAR]) {
            o = outstring(0, 0);
            while(o & 3) {
                outstring("", 1);
                o = outstring(0, 0);
            }
        }
        n->op = ONAME;
        n->xoffset = outstring(n->cstring, n->type->width);
        n->addable = 1;
        break;

    case OCONST:
        break;

    case ODOT:
        if(tcom(l))
            goto bad;
        if(tcompat(n, T, l->type, tdot))
            goto bad;
        if(tcomd(n))
            goto bad;
        break;

    case OADDR:
        if(tcomo(l, ADDROP))
            goto bad;
        if(tlvalue(l))
            goto bad;
        if(l->type->nbits) {
            diag(n, "address of a bit field");
            goto bad;
        }
        if(l->op == OREGISTER) {
            diag(n, "address of a register");
            goto bad;
        }
        n->type = typ(TIND, l->type);
        n->type->width = types[TIND]->width;
        break;

    case OIND:
        if(tcom(l))
            goto bad;
        if(tcompat(n, T, l->type, tindir))
            goto bad;
        n->type = l->type->link;
        n->addable = 1;
        break;

    case OSTRUCT:
        if(tcomx(n))
            goto bad;
        break;

    default:
        diag(n, "unknown op in type complex: %O", n->op);
        goto bad;

    }


    t = n->type;
    if(t == T)
        goto bad;
    if(t->width < 0) {
        snap(t);
        if(t->width < 0) {
            if(typesu[t->etype] && t->tag)
                diag(n, "structure not fully declared %s", t->tag->name);
            else
                diag(n, "structure not fully declared");
            goto bad;
        }
    }
    if(typeaf[t->etype]) {
        if(f & ADDROF)
            goto addaddr;
        if(f & ADDROP)
            warn(n, "address of array/func ignored");
    }
    return false;

addaddr:
    if(tlvalue(n))
        goto bad;
    l = new1(OXXX, Z, Z);
    *l = *n;
    n->op = OADDR;
    if(l->type->etype == TARRAY)
        l->type = l->type->link;
    n->left = l;
    n->right = Z;
    n->addable = 0;
    n->type = typ(TIND, l->type);
    n->type->width = types[TIND]->width;
    return false;

bad:
    n->type = T;
    return true;
}
@


\section{Lint checks}

% 8c -V enable void* conversion warnings
% 8c -w print warnings

<<[[Sym]] other fields>>=
bool	aused;
@

<<[[Decl]] other fields>>=
bool	aused;
@

% hmmm but correct? handle well the different namespace?
% what if struct and local with same name?

\subsection{[[SET/USED]]}

<<ulstmnt rule>>=
|   LUSED '(' zelist ')' ';' { $$ = new(OUSED, $3, Z); }
|   LSET '(' zelist ')' ';'  { $$ = new(OSET, $3, Z); }
@


% called by gen() (statement code generator) 

<<function usedset>>=
void
usedset(Node *n, int o)
{
    if(n->op == OLIST) {
        usedset(n->left, o);
        usedset(n->right, o);
        return;
    }

    complex(n);

    switch(n->op) {
    case OADDR:	/* volatile */
        gins(ANOP, n, Z);
        break;
    case ONAME:
        if(o == OSET)
            gins(ANOP, Z, n);
        else
            gins(ANOP, n, Z);
        break;
    }
}
@

\chapter{Code Generation}

\section{Overview}
% intermediate language? RTL? seems not :(
% maybe lcc is cleaner

% gbranch, gmove, gins, etc?
% nextpc()?
% gxxx = generate Prog (=~ assembly code)


% remember in cc.y for function definition case:
%        if(!debug['a'] && !debug['Z'])
%            codgen($6, $2); // !!!!!!!!!!!!!!!!!!!!!


\section{Functions}

<<global cursafe>>=
long	cursafe;
@

<<global curarg>>=
long	curarg;
@

<<global maxargsafe>>=
long	maxargsafe;
@

<<global hasdoubled>>=
int	hasdoubled;
@




% not set anywhere?
<<global nodret>>=
Node*	nodret;
@





%REGARG from 8.out.h = -1 => no register for first argument,
% everything in the stack. AX is used for return though

% cc2/pgen.c  n = node of the blocks OLIST, nn = node of the ident ONAME
<<function codgen>>=
//@Scheck: used by cc.y
void codgen(Node *n, Node *nn)
{
    Prog *sp;
    Node *n1, nod, nod1;

    cursafe = 0;
    curarg = 0;
    maxargsafe = 0;
    hasdoubled = 0;

    /*
     * isolate name
     */
    for(n1 = nn;; n1 = n1->left) {
        if(n1 == Z) {
            diag(nn, "cant find function name");
            return;
        }
        if(n1->op == ONAME)
            break;
    }
    nearln = nn->lineno;
    gpseudo(ATEXT, n1->sym, nodconst(stkoff));
    sp = p;

    if(typecmplx[thisfn->link->etype]) {
        if(nodret == nil) {
            nodret = new(ONAME, Z, Z);
            nodret->sym = slookup(".ret");
            nodret->class = CPARAM;
            nodret->type = types[TIND];
            nodret->etype = TIND;
            nodret = new(OIND, nodret, Z);
        }
        n1 = nodret->left;
        if(n1->type == T || n1->type->link != thisfn->link) {
            n1->type = typ(TIND, thisfn->link);
            n1->etype = n1->type->etype;
            nodret = new(OIND, n1, Z);
            complex(nodret);
        }
    }

    /*
     * isolate first argument
     */
    if(REGARG >= 0) {	
        if(typecmplx[thisfn->link->etype]) {
            nod1 = *nodret->left;
            nodreg(&nod, &nod1, REGARG);
            gmove(&nod, &nod1);
        } else
        if(firstarg && typeword[firstargtype->etype]) {
            nod1 = znode;
            nod1.op = ONAME;
            nod1.sym = firstarg;
            nod1.type = firstargtype;
            nod1.class = CPARAM;
            nod1.xoffset = align(0, firstargtype, Aarg1);
            nod1.etype = firstargtype->etype;
            xcom(&nod1);
            nodreg(&nod, &nod1, REGARG);
            gmove(&nod, &nod1);
        }
    }

    canreach = true;
    warnreach = true;

    gen(n);

    if(canreach && thisfn->link->etype != TVOID){
        if(debug['B'])
            warn(Z, "no return at end of function: %s", n1->sym->name);
        else
            diag(Z, "no return at end of function: %s", n1->sym->name);
    }

    noretval(3);

    gbranch(ORETURN);

    if(!debug['N'] || debug['R'] || debug['P'])
        regopt(sp);
    
    if(thechar=='6' || thechar=='7' || thechar=='9' || hasdoubled)	/* [sic] */
        maxargsafe = round(maxargsafe, 8);
    sp->to.offset += maxargsafe;
}
@


% 8c/sgen.c
<<function noretval>>=
void
noretval(int n)
{

    if(n & 1) {
        gins(ANOP, Z, Z);
        p->to.type = REGRET;
    }
    if(n & 2) {
        gins(ANOP, Z, Z);
        p->to.type = FREGRET;
    }
    if((n&3) == 3)
    if(thisfn && thisfn->link && typefd[thisfn->link->etype])
        gins(AFLDZ, Z, Z);
}
@

\section{Statements}

<<global canreach>>=
bool	canreach;
@

<<global warnreach>>=
bool	warnreach;
@

% turn into a static local?
<<global ncontin>>=
int	ncontin;
@

% seems dead, never set to true or valid in other archi?
<<global newvlongcode>>=
bool	newvlongcode;
@


<<function gen>>=
void
gen(Node *n)
{
    Node *l, nod, rn;
    Prog *sp, *spc, *spb;
    Case *cn;
    long sbc, scc;
    int snbreak, sncontin;
    int f, o, oldreach;

loop:
    if(n == Z)
        return;
    nearln = n->lineno;
    o = n->op;
    if(debug['G'])
        if(o != OLIST)
            print("%L %O\n", nearln, o);

    if(!canreach) {
        switch(o) {
        case OLABEL:
        case OCASE:
        case OLIST:
        case OCOMMA:
        case OBREAK:
        case OFOR:
        case OWHILE:
        case ODWHILE:
            /* all handled specially - see switch body below */
            break;
        default:
            if(warnreach) {
                warn(n, "unreachable code %O", o);
                warnreach = 0;
            }
        }
    }

    switch(o) {

    default:
        complex(n);
        cgen(n, Z);
        break;

    case OLIST:
    case OCOMMA:
        gen(n->left);

    rloop:
        n = n->right;
        goto loop;

    case ORETURN:
        canreach = false;
        warnreach = !suppress;
        complex(n);
        if(n->type == T)
            break;
        l = uncomma(n->left);
        if(l == Z) {
            noretval(3);
            gbranch(ORETURN);
            break;
        }
        if(typecmplx[n->type->etype]) {
            nod = znode;
            nod.op = OAS;
            nod.left = nodret;
            nod.right = l;
            nod.type = n->type;
            nod.complex = l->complex;
            cgen(&nod, Z);
            noretval(3);
            gbranch(ORETURN);
            break;
        }
        if(newvlongcode && !typefd[n->type->etype]){
            regret(&rn, n);
            regfree(&rn);
            nod = znode;
            nod.op = OAS;
            nod.left = &rn;
            nod.right = l;
            nod.type = n->type;
            nod.complex = l->complex;
            cgen(&nod, Z);
            noretval(2);
            gbranch(ORETURN);
            break;
        }
        regret(&nod, n);
        cgen(l, &nod);
        regfree(&nod);
        if(typefd[n->type->etype])
            noretval(1);
        else
            noretval(2);
        gbranch(ORETURN);
        break;

    case OLABEL:
        canreach = true;
        l = n->left;
        if(l) {
            l->pc = pc;
            if(l->label)
                patch(l->label, pc);
        }
        gbranch(OGOTO);	/* prevent self reference in reg */
        patch(p, pc);
        goto rloop;

    case OGOTO:
        canreach = false;
        warnreach = !suppress;
        n = n->left;
        if(n == Z)
            return;
        if(n->complex == 0) {
            diag(Z, "label undefined: %s", n->sym->name);
            return;
        }
        if(suppress)
            return;
        gbranch(OGOTO);
        if(n->pc) {
            patch(p, n->pc);
            return;
        }
        if(n->label)
            patch(n->label, pc-1);
        n->label = p;
        return;

    case OCASE:
        canreach = true;
        l = n->left;
        if(cases == C)
            diag(n, "case/default outside a switch");
        if(l == Z) {
            casf();
            cases->val = 0;
            cases->def = 1;
            cases->label = pc;
            cases->isv = 0;
            goto rloop;
        }
        complex(l);
        if(l->type == T)
            goto rloop;
        if(l->op != OCONST || !typeswitch[l->type->etype]) {
            diag(n, "case expression must be integer constant");
            goto rloop;
        }
        casf();
        cases->val = l->vconst;
        cases->def = 0;
        cases->label = pc;
        cases->isv = typev[l->type->etype];
        goto rloop;

    case OSWITCH:
        l = n->left;
        complex(l);
        if(l->type == T)
            break;
        if(!typeswitch[l->type->etype]) {
            diag(n, "switch expression must be integer");
            break;
        }

        gbranch(OGOTO);		/* entry */
        sp = p;

        cn = cases;
        cases = C;
        casf();

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        gbranch(OGOTO);
        spb = p;

        gen(n->right);		/* body */
        if(canreach){
            gbranch(OGOTO);
            patch(p, breakpc);
            nbreak++;
        }

        patch(sp, pc);
        regalloc(&nod, l, Z);
        /* always signed */
        if(typev[l->type->etype])
            nod.type = types[TVLONG];
        else
            nod.type = types[TLONG];
        cgen(l, &nod);
        doswit(&nod);
        regfree(&nod);
        patch(spb, pc);

        cases = cn;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == false)
            warnreach = !suppress;
        nbreak = snbreak;
        break;

    case OWHILE:
    case ODWHILE:
        l = n->left;
        gbranch(OGOTO);		/* entry */
        sp = p;

        scc = continpc;
        continpc = pc;
        gbranch(OGOTO);
        spc = p;

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        gbranch(OGOTO);
        spb = p;

        patch(spc, pc);
        if(n->op == OWHILE)
            patch(sp, pc);
        bcomplex(l, Z);		/* test */
        patch(p, breakpc);
        if(l->op != OCONST || vconst(l) == 0)
            nbreak++;

        if(n->op == ODWHILE)
            patch(sp, pc);
        gen(n->right);		/* body */
        gbranch(OGOTO);
        patch(p, continpc);

        patch(spb, pc);
        continpc = scc;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == false)
            warnreach = !suppress;
        nbreak = snbreak;
        break;

    case OFOR:
        l = n->left;
        if(!canreach && l->right->left && warnreach) {
            warn(n, "unreachable code FOR");
            warnreach = 0;
        }
        gen(l->right->left);	/* init */
        gbranch(OGOTO);		/* entry */
        sp = p;

        /* 
         * if there are no incoming labels in the 
         * body and the top's not reachable, warn
         */
        if(!canreach && warnreach && deadheads(n)) {
            warn(n, "unreachable code %O", o);
            warnreach = 0;
        }

        scc = continpc;
        continpc = pc;
        gbranch(OGOTO);
        spc = p;

        sbc = breakpc;
        breakpc = pc;
        snbreak = nbreak;
        nbreak = 0;
        sncontin = ncontin;
        ncontin = 0;
        gbranch(OGOTO);
        spb = p;

        patch(spc, pc);
        gen(l->right->right);	/* inc */
        patch(sp, pc);	
        if(l->left != Z) {	/* test */
            bcomplex(l->left, Z);
            patch(p, breakpc);
            if(l->left->op != OCONST || vconst(l->left) == 0)
                nbreak++;
        }
        canreach = true;
        gen(n->right);		/* body */
        if(canreach){
            gbranch(OGOTO);
            patch(p, continpc);
            ncontin++;
        }
        if(!ncontin && l->right->right && warnreach) {
            warn(l->right->right, "unreachable FOR inc");
            warnreach = 0;
        }

        patch(spb, pc);
        continpc = scc;
        breakpc = sbc;
        canreach = nbreak!=0;
        if(canreach == false)
            warnreach = !suppress;
        nbreak = snbreak;
        ncontin = sncontin;
        break;

    case OCONTINUE:
        if(continpc < 0) {
            diag(n, "continue not in a loop");
            break;
        }
        gbranch(OGOTO);
        patch(p, continpc);
        ncontin++;
        canreach = false;
        warnreach = !suppress;
        break;

    case OBREAK:
        if(breakpc < 0) {
            diag(n, "break not in a loop");
            break;
        }
        /*
         * Don't complain about unreachable break statements.
         * There are breaks hidden in yacc's output and some people
         * write return; break; in their switch statements out of habit.
         * However, don't confuse the analysis by inserting an 
         * unreachable reference to breakpc either.
         */
        if(!canreach)
            break;
        gbranch(OGOTO);
        patch(p, breakpc);
        nbreak++;
        canreach = false;
        warnreach = !suppress;
        break;

    case OIF:
        l = n->left;
        if(bcomplex(l, n->right)) {
            if(typefd[l->type->etype])
                f = !l->fconst;
            else
                f = !l->vconst;
            if(debug['c'])
                print("%L const if %s\n", nearln, f ? "false" : "true");
            if(f) {
                canreach = true;
                supgen(n->right->left);
                oldreach = canreach;
                canreach = true;
                gen(n->right->right);
                /*
                 * treat constant ifs as regular ifs for 
                 * reachability warnings.
                 */
                if(!canreach && oldreach && debug['w'] < 2)
                    warnreach = 0;
            }
            else {
                canreach = true;
                gen(n->right->left);
                oldreach = canreach;
                canreach = true;
                supgen(n->right->right);
                /*
                 * treat constant ifs as regular ifs for 
                 * reachability warnings.
                 */
                if(!oldreach && canreach && debug['w'] < 2)
                    warnreach = 0;
                canreach = oldreach;
            }
        }
        else {
            sp = p;
            canreach = true;
            if(n->right->left != Z)
                gen(n->right->left);
            oldreach = canreach;
            canreach = true;
            if(n->right->right != Z) {
                gbranch(OGOTO);
                patch(sp, pc);
                sp = p;
                gen(n->right->right);
            }
            patch(sp, pc);
            canreach = canreach || oldreach;
            if(canreach == false)
                warnreach = !suppress;
        }
        break;

    case OSET:
    case OUSED:
        usedset(n->left, o);
        break;
    }
}
@

\subsection{Switch}

<<function swcmp>>=
int
swcmp(const void *a1, const void *a2)
{
    C1 *p1, *p2;

    p1 = (C1*)a1;
    p2 = (C1*)a2;
    if(p1->val < p2->val)
        return -1;
    return p1->val > p2->val;
}
@

<<function doswit>>=
void
doswit(Node *n)
{
    Case *c;
    C1 *q, *iq, *iqh, *iql;
    long def, nc, i, j, isv, nh;
    Prog *hsb;
    Node *vr[2];
    int dup;

    def = 0;
    nc = 0;
    isv = 0;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def) {
            if(def)
                diag(n, "more than one default in switch");
            def = c->label;
            continue;
        }
        isv |= c->isv;
        nc++;
    }
    if(typev[n->type->etype])
        isv = 1;
    else if(isv){
        warn(n, "32-bit switch expression with 64-bit case constant");
        isv = 0;
    }

    iq = alloc(nc*sizeof(C1));
    q = iq;
    for(c = cases; c->link != C; c = c->link) {
        if(c->def)
            continue;
        if(c->isv && !isv)
            continue;	/* can never match */
        q->label = c->label;
        if(isv)
            q->val = c->val;
        else
            q->val = (long)c->val;	/* cast ensures correct value for 32-bit switch on 64-bit architecture */
        q++;
    }
    qsort(iq, nc, sizeof(C1), swcmp);

    if(debug['K'])
     for(i=0; i<nc; i++)
        print("case %2ld: = %.8llux\n", i, (vlong)iq[i].val);
 
   dup = 0;
    for(i=0; i<nc-1; i++)
        if(iq[i].val == iq[i+1].val) {
            diag(n, "duplicate cases in switch %lld", (vlong)iq[i].val);
            dup = 1;
        }
    if(dup)
        return;
    if(def == 0) {
        def = breakpc;
        nbreak++;
    }
    if(!isv || ewidth[TIND] > ewidth[TLONG] || n->op == OREGISTER) {
        swit1(iq, nc, def, n);
        return;
    }

    /*
     * 64-bit case on 32-bit machine:
     * switch on high-order words, and
     * in each of those, switch on low-order words
     */
    if(n->op != OREGPAIR)
        fatal(n, "internal: expected register pair");
    if(thechar == '8'){	/* TO DO: need an enquiry function */
        vr[0] = n->left;	/* low */
        vr[1] = n->right;	/* high */
    }else{
        vr[0] = n->right;
        vr[1] = n->left;
    }
    vr[0]->type = types[TLONG];
    vr[1]->type = types[TLONG];
    gbranch(OGOTO);
    hsb = p;
    iqh = alloc(nc*sizeof(C1));
    iql = alloc(nc*sizeof(C1));
    nh = 0;
    for(i=0; i<nc;){
        iqh[nh].val = iq[i].val >> 32;
        q = iql;
        /* iq is sorted, so equal top halves are adjacent */
        for(j = i; j < nc; j++){
            if((iq[j].val>>32) != iqh[nh].val)
                break;
            q->val = (long)iq[j].val;
            q->label = iq[j].label;
            q++;
        }
        qsort(iql,  q-iql, sizeof(C1), swcmp);
                //if(0){for(int k=0; k<(q-iql); k++)print("nh=%ld k=%d h=%#llux l=%#llux lab=%ld\n", nh, k, (vlong)iqh[nh].val,  (vlong)iql[k].val, iql[k].label);}
        iqh[nh].label = pc;
        nh++;
        swit1(iql, q-iql, def, vr[0]);
        i = j;
    }
    patch(hsb, pc);
        //if(0){for(int k=0; k<nh; k++)print("k*=%d h=%#llux lab=%ld\n", k, (vlong)iqh[k].val,  iqh[k].label);}
    swit1(iqh, nh, def, vr[1]);
}
@

<<function casf>>=
void
casf(void)
{
    Case *c;

    c = alloc(sizeof(*c));
    c->link = cases;
    cases = c;
}
@


\section{Expressions}


\section{Initializers}

\section{Strings}

<<global symstring>>=
Sym*	symstring;
@


<<function outlstring>>=
long
outlstring(TRune *s, long n)
{
    char buf[sizeof(TRune)];
    uint c;
    int i;
    long r;

    if(suppress)
        return nstring;
    while(nstring & (sizeof(TRune)-1))
        outstring("", 1);
    r = nstring;
    while(n > 0) {
        c = *s++;
        if(align(0, types[TCHAR], Aarg1)) {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*(sizeof(TRune) - i - 1));
        } else {
            for(i = 0; i < sizeof(TRune); i++)
                buf[i] = c>>(8*i);
        }
        outstring(buf, sizeof(TRune));
        n -= sizeof(TRune);
    }
    return r;
}
@

\section{Sizes}
%x86!

% TODO use [xx] extension instead of those comments?
%  but then more complicated to bootstrap with other C compiler?
<<global ewidth>>=
schar	ewidth[NTYPE] =
{
    -1,		/*[TXXX]*/	
    SZ_CHAR,	/*[TCHAR]*/	
    SZ_CHAR,	/*[TUCHAR]*/
    SZ_SHORT,	/*[TSHORT]*/
    SZ_SHORT,	/*[TUSHORT]*/
    SZ_INT,		/*[TINT]*/
    SZ_INT,		/*[TUINT]*/
    SZ_LONG,	/*[TLONG]*/
    SZ_LONG,	/*[TULONG]*/
    SZ_VLONG,	/*[TVLONG]*/
    SZ_VLONG,	/*[TUVLONG]*/
    SZ_FLOAT,	/*[TFLOAT]*/
    SZ_DOUBLE,	/*[TDOUBLE]*/
    SZ_IND,		/*[TIND]*/
    0,		/*[TFUNC]*/
    -1,		/*[TARRAY]*/
    0,		/*[TVOID]*/
    -1,		/*[TSTRUCT]*/
    -1,		/*[TUNION]*/
    SZ_INT,		/*[TENUM]*/
};
@

<<constant SZ_CHAR>>=
/*
 * 8c/386
 * Intel 386
 */
#define	SZ_CHAR		1
@

<<constant SZ_SHORT>>=
#define	SZ_SHORT	2
@

<<constant SZ_INT>>=
#define	SZ_INT		4
@

<<constant SZ_LONG>>=
#define	SZ_LONG		4
@

<<constant SZ_IND>>=
#define	SZ_IND		4
@

<<constant SZ_FLOAT>>=
#define	SZ_FLOAT	4
@

% 64 bits!
<<constant SZ_VLONG>>=
#define	SZ_VLONG	8
@

<<constant SZ_DOUBLE>>=
#define	SZ_DOUBLE	8
@

\section{Alignment}

<<enum axxx>>=
enum axxx
{
    Axxx,

    Ael1,
    Ael2,
    Asu2,
    Aarg0,
    Aarg1,
    Aarg2,
    Aaut3,

    NALIGN,
};
@

<<global bnames>>=
char*	bnames[NALIGN];
@

<<global bnamesinit>>=
Init	bnamesinit[] =
{
    Axxx,	0,	"Axxx",

    Ael1,	0,	"el1",
    Ael2,	0,	"el2",
    Asu2,	0,	"su2",
    Aarg0,	0,	"arg0",
    Aarg1,	0,	"arg1",
    Aarg2,	0,	"arg2",
    Aaut3,	0,	"aut3",
    -1,	0,	0,
};
@



% called for fields of structures/unions

<<function sualign>>=
//@Scheck: not dead, used by cc.y
void sualign(Type *t)
{
    Type *l;
    long o, w;

    o = 0;
    switch(t->etype) {

    case TSTRUCT:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->nbits) {
                if(l->shift <= 0) {
                    l->shift = -l->shift;
                    w = round(w, tfield->width);
                    o = w;
                    w += tfield->width;
                }
                l->offset = o;
            } else {
                if(l->width < 0 ||
                   l->width == 0 && l->down != T)
                    if(l->sym)
                        diag(Z, "incomplete structure element: %s",
                            l->sym->name);
                    else
                        diag(Z, "incomplete structure element");
                w = align(w, l, Ael1);
                l->offset = w;
                w = align(w, l, Ael2);
            }
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    case TUNION:
        t->offset = 0;
        w = 0;
        for(l = t->link; l != T; l = l->down) {
            if(l->width <= 0)
                if(l->sym)
                    diag(Z, "incomplete union element: %s",
                        l->sym->name);
                else
                    diag(Z, "incomplete union element");
            l->offset = 0;
            l->shift = 0;
            o = align(align(0, l, Ael1), l, Ael2);
            if(o > w)
                w = o;
        }
        w = align(w, t, Asu2);
        t->width = w;
        acidtype(t);
        pickletype(t);
        return;

    default:
        diag(Z, "unknown type in sualign: %T", t);
        break;
    }
}
@

\chapter{Optimisations}

% see compcert list of optimisations? there are all of them here too?

\section{AST rewriting}


\subsection{[[ccom()]]}
% cc/com.c

% called from complex(), after tcom()

<<function ccom>>=
/*
 *	general rewrite
 *	(IND(ADDR x)) ==> x
 *	(ADDR(IND x)) ==> x
 *	remove some zero operands
 *	remove no op casts
 *	evaluate constants
 */
void
ccom(Node *n)
{
    Node *l, *r;
    int t;

loop:
    if(n == Z)
        return;
    l = n->left;
    r = n->right;
    switch(n->op) {

    case OAS:
    case OASXOR:
    case OASAND:
    case OASOR:
    case OASMOD:
    case OASLMOD:
    case OASLSHR:
    case OASASHR:
    case OASASHL:
    case OASDIV:
    case OASLDIV:
    case OASMUL:
    case OASLMUL:
    case OASSUB:
    case OASADD:
        ccom(l);
        ccom(r);
        if(n->op == OASLSHR || n->op == OASASHR || n->op == OASASHL)
        if(r->op == OCONST) {
            t = n->type->width * 8;	/* bits per byte */
            if(r->vconst >= t || r->vconst < 0)
                warn(n, "stupid shift: %lld", r->vconst);
        }
        break;

    case OCAST:
        ccom(l);
        if(l->op == OCONST) {
            evconst(n);
            if(n->op == OCONST)
                break;
        }
        if(nocast(l->type, n->type) &&
           (!typefd[l->type->etype] || typeu[l->type->etype] && typeu[n->type->etype])) {
            l->type = n->type;
            *n = *l;
        }
        break;

    case OCOND:
        ccom(l);
        ccom(r);
        if(l->op == OCONST)
            if(vconst(l) == 0)
                *n = *r->right;
            else
                *n = *r->left;
        break;

    case OREGISTER:
    case OINDREG:
    case OCONST:
    case ONAME:
        break;

    case OADDR:
        ccom(l);
        l->etype = TVOID;
        if(l->op == OIND) {
            l->left->type = n->type;
            *n = *l->left;
            break;
        }
        goto common;

    case OIND:
        ccom(l);
        if(l->op == OADDR) {
            l->left->type = n->type;
            *n = *l->left;
            break;
        }
        goto common;

    case OEQ:
    case ONE:

    case OLE:
    case OGE:
    case OLT:
    case OGT:

    case OLS:
    case OHS:
    case OLO:
    case OHI:
        ccom(l);
        ccom(r);
        if(compar(n, 0) || compar(n, 1))
            break;
        relcon(l, r);
        relcon(r, l);
        goto common;

    case OASHR:
    case OASHL:
    case OLSHR:
        ccom(l);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        ccom(r);
        if(vconst(r) == 0) {
            *n = *l;
            break;
        }
        if(r->op == OCONST) {
            t = n->type->width * 8;	/* bits per byte */
            if(r->vconst >= t || r->vconst <= -t)
                warn(n, "stupid shift: %lld", r->vconst);
        }
        goto common;

    case OMUL:
    case OLMUL:
        ccom(l);
        t = vconst(l);
        if(t == 0 && !side(r)) {
            *n = *l;
            break;
        }
        if(t == 1) {
            *n = *r;
            goto loop;
        }
        ccom(r);
        t = vconst(r);
        if(t == 0 && !side(l)) {
            *n = *r;
            break;
        }
        if(t == 1) {
            *n = *l;
            break;
        }
        goto common;

    case ODIV:
    case OLDIV:
        ccom(l);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        ccom(r);
        t = vconst(r);
        if(t == 0) {
            diag(n, "divide check");
            *n = *r;
            break;
        }
        if(t == 1) {
            *n = *l;
            break;
        }
        goto common;

    case OSUB:
        ccom(r);
        if(r->op == OCONST) {
            if(typefd[r->type->etype]) {
                n->op = OADD;
                r->fconst = -r->fconst;
                goto loop;
            } else {
                n->op = OADD;
                r->vconst = -r->vconst;
                goto loop;
            }
        }
        ccom(l);
        goto common;

    case OXOR:
    case OOR:
    case OADD:
        ccom(l);
        if(vconst(l) == 0) {
            *n = *r;
            goto loop;
        }
        ccom(r);
        if(vconst(r) == 0) {
            *n = *l;
            break;
        }
        goto commute;

    case OAND:
        ccom(l);
        ccom(r);
        if(vconst(l) == 0 && !side(r)) {
            *n = *l;
            break;
        }
        if(vconst(r) == 0 && !side(l)) {
            *n = *r;
            break;
        }

    commute:
        /* look for commutative constant */
        if(r->op == OCONST) {
            if(l->op == n->op) {
                if(l->left->op == OCONST) {
                    n->right = l->right;
                    l->right = r;
                    goto loop;
                }
                if(l->right->op == OCONST) {
                    n->right = l->left;
                    l->left = r;
                    goto loop;
                }
            }
        }
        if(l->op == OCONST) {
            if(r->op == n->op) {
                if(r->left->op == OCONST) {
                    n->left = r->right;
                    r->right = l;
                    goto loop;
                }
                if(r->right->op == OCONST) {
                    n->left = r->left;
                    r->left = l;
                    goto loop;
                }
            }
        }
        goto common;

    case OANDAND:
        ccom(l);
        if(vconst(l) == 0) {
            *n = *l;
            break;
        }
        ccom(r);
        goto common;

    case OOROR:
        ccom(l);
        if(l->op == OCONST && l->vconst != 0) {
            *n = *l;
            n->vconst = 1;
            break;
        }
        ccom(r);
        goto common;

    default:
        if(l != Z)
            ccom(l);
        if(r != Z)
            ccom(r);
    common:
        if(l != Z)
        if(l->op != OCONST)
            break;
        if(r != Z)
        if(r->op != OCONST)
            break;
        evconst(n);
    }
}
@


\section{[[xcom()]]}

% 8c/sgen.c

<<[[Node]] other fields>>=
// (ab)used as bool for marker of use of label, special 10, 11, 20 values
char	addable;
@


<<function xcom>>=
/*
 *	calculate addressability as follows
 *		NAME ==> 10/11		name+value(SB/SP)
 *		REGISTER ==> 12		register
 *		CONST ==> 20		$value
 *		*(20) ==> 21		value
 *		&(10) ==> 13		$name+value(SB)
 *		&(11) ==> 1		$name+value(SP) $
 *		(13) + (20) ==> 13	fold constants
 *		(1) + (20) ==> 1	fold constants
 *		*(13) ==> 10		back to name
 *		*(1) ==> 11		back to name
 *
 *		(20) * (X) ==> 7	multiplier in indexing
 *		(X,7) + (13,1) ==> 8	adder in indexing (addresses)
 *		(8) ==> &9(OINDEX)	index, almost addressable
 *
 *	calculate complexity (number of registers)
 * 
 */
void
xcom(Node *n)
{
    Node *l, *r;
    int g;

    if(n == Z)
        return;
    l = n->left;
    r = n->right;
    n->complex = 0;
    n->addable = 0;
    switch(n->op) {
    case OCONST:
        n->addable = 20;
        break;

    case ONAME:
        n->addable = 10;
        if(n->class == CPARAM || n->class == CAUTO)
            n->addable = 11;
        break;

    case OEXREG:
        n->addable = 12;
        break;

    case OREGISTER:
        n->addable = 12;
        break;

    case OINDREG:
        n->addable = 12;
        break;

    case OADDR:
        xcom(l);
        if(l->addable == 10)
            n->addable = 13;
        else
        if(l->addable == 11)
            n->addable = 1;
        break;

    case OADD:
        xcom(l);
        xcom(r);
        if(n->type->etype != TIND)
            break;

        switch(r->addable) {
        case 20:
            switch(l->addable) {
            case 1:
            case 13:
            commadd:
                l->type = n->type;
                *n = *l;
                l = new(0, Z, Z);
                *l = *(n->left);
                l->xoffset += r->vconst;
                n->left = l;
                r = n->right;
                goto brk;
            }
            break;

        case 1:
        case 13:
        case 10:
        case 11:
            /* l is the base, r is the index */
            if(l->addable != 20)
                n->addable = 8;
            break;
        }
        switch(l->addable) {
        case 20:
            switch(r->addable) {
            case 13:
            case 1:
                r = n->left;
                l = n->right;
                n->left = l;
                n->right = r;
                goto commadd;
            }
            break;

        case 13:
        case 1:
        case 10:
        case 11:
            /* r is the base, l is the index */
            if(r->addable != 20)
                n->addable = 8;
            break;
        }
        if(n->addable == 8 && !side(n)) {
            indx(n);
            l = new1(OINDEX, idx.basetree, idx.regtree);
            l->scale = idx.scale;
            l->addable = 9;
            l->complex = l->right->complex;
            l->type = l->left->type;
            n->op = OADDR;
            n->left = l;
            n->right = Z;
            n->addable = 8;
            break;
        }
        break;

    case OINDEX:
        xcom(l);
        xcom(r);
        n->addable = 9;
        break;

    case OIND:
        xcom(l);
        if(l->op == OADDR) {
            l = l->left;
            l->type = n->type;
            *n = *l;
            return;
        }
        switch(l->addable) {
        case 20:
            n->addable = 21;
            break;
        case 1:
            n->addable = 11;
            break;
        case 13:
            n->addable = 10;
            break;
        }
        break;

    case OASHL:
        xcom(l);
        xcom(r);
        indexshift(n);
        break;

    case OMUL:
    case OLMUL:
        xcom(l);
        xcom(r);
        g = vlog(l);
        if(g >= 0) {
            n->left = r;
            n->right = l;
            l = r;
            r = n->right;
        }
        g = vlog(r);
        if(g >= 0) {
            n->op = OASHL;
            r->vconst = g;
            r->type = types[TINT];
            indexshift(n);
            break;
        }
commute(n);
        break;

    case OASLDIV:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASLSHR;
            r->vconst = g;
            r->type = types[TINT];
        }
        break;

    case OLDIV:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OLSHR;
            r->vconst = g;
            r->type = types[TINT];
            indexshift(n);
            break;
        }
        break;

    case OASLMOD:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASAND;
            r->vconst--;
        }
        break;

    case OLMOD:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OAND;
            r->vconst--;
        }
        break;

    case OASMUL:
    case OASLMUL:
        xcom(l);
        xcom(r);
        g = vlog(r);
        if(g >= 0) {
            n->op = OASASHL;
            r->vconst = g;
        }
        break;

    case OLSHR:
    case OASHR:
        xcom(l);
        xcom(r);
        indexshift(n);
        break;

    default:
        if(l != Z)
            xcom(l);
        if(r != Z)
            xcom(r);
        break;
    }
brk:
    if(n->addable >= 10)
        return;
    if(l != Z)
        n->complex = l->complex;
    if(r != Z) {
        if(r->complex == n->complex)
            n->complex = r->complex+1;
        else
        if(r->complex > n->complex)
            n->complex = r->complex;
    }
    if(n->complex == 0)
        n->complex++;

    if(com64(n))
        return;

    switch(n->op) {

    case OFUNC:
        n->complex = FNX;
        break;

    case OLMOD:
    case OMOD:
    case OLMUL:
    case OLDIV:
    case OMUL:
    case ODIV:
    case OASLMUL:
    case OASLDIV:
    case OASLMOD:
    case OASMUL:
    case OASDIV:
    case OASMOD:
        if(r->complex >= l->complex) {
            n->complex = l->complex + 3;
            if(r->complex > n->complex)
                n->complex = r->complex;
        } else {
            n->complex = r->complex + 3;
            if(l->complex > n->complex)
                n->complex = l->complex;
        }
        break;

    case OLSHR:
    case OASHL:
    case OASHR:
    case OASLSHR:
    case OASASHL:
    case OASASHR:
        if(r->complex >= l->complex) {
            n->complex = l->complex + 2;
            if(r->complex > n->complex)
                n->complex = r->complex;
        } else {
            n->complex = r->complex + 2;
            if(l->complex > n->complex)
                n->complex = l->complex;
        }
        break;

    case OADD:
    case OXOR:
    case OAND:
    case OOR:
        /*
         * immediate operators, make const on right
         */
        if(l->op == OCONST) {
            n->left = r;
            n->right = l;
        }
        break;

    case OEQ:
    case ONE:
    case OLE:
    case OLT:
    case OGE:
    case OGT:
    case OHI:
    case OHS:
    case OLO:
    case OLS:
        /*
         * compare operators, make const on left
         */
        if(r->op == OCONST) {
            n->left = r;
            n->right = l;
            n->op = invrel[relindex(n->op)];
        }
        break;
    }
}
@
%$

\section{Dominators}

\section{Register allocation}
% 8c -r? registerization

\subsection{[[Bits]]}

<<constant BITS>>=
#define	BITS	5
@


<<struct Bits>>=
struct	Bits
{
    ulong	b[BITS];
};
@

<<global zbits>>=
Bits	zbits;
@


<<function bor>>=
Bits
bor(Bits a, Bits b)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = a.b[i] | b.b[i];
    return c;
}
@

<<function bany>>=
/*
Bits
bnot(Bits a)
{
    Bits c;
    int i;

    for(i=0; i<BITS; i++)
        c.b[i] = ~a.b[i];
    return c;
}
*/

int
bany(Bits *a)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a->b[i])
            return 1;
    return 0;
}
@

<<function beq>>=
int
beq(Bits a, Bits b)
{
    int i;

    for(i=0; i<BITS; i++)
        if(a.b[i] != b.b[i])
            return 0;
    return 1;
}
@

<<function bnum>>=
int
bnum(Bits a)
{
    int i;
    long b;

    for(i=0; i<BITS; i++)
        if(b = a.b[i])
            return 32*i + bitno(b);
    diag(Z, "bad in bnum");
    return 0;
}
@

<<function blsh>>=
Bits
blsh(uint n)
{
    Bits c;

    c = zbits;
    c.b[n/32] = 1L << (n%32);
    return c;
}
@

<<function bset>>=
//@Scheck: also defined as a macro in gc.h, TODO fix that!
int bset(Bits a, uint n)
{
    if(a.b[n/32] & (1L << (n%32)))
        return 1;
    return 0;
}
@


%<<function band>>=
%//Bits
%//band(Bits a, Bits b)
%//{
%//    Bits c;
%//    int i;
%//
%//    for(i=0; i<BITS; i++)
%//        c.b[i] = a.b[i] & b.b[i];
%//    return c;
%//}
%@

\subsection{[[Var]]}

<<constant NVAR>>=
#define	NVAR	(BITS*sizeof(ulong)*8)
@

<<global nvar>>=
int	nvar;
@

<<global var>>=
Var	var[NVAR];
@

<<struct Var>>=
struct	Var
{
    long	offset;
    Sym*	sym;
    char	name;
    char	etype;
};
@

\subsection{[[Reg]]}


<<struct Reg>>=
struct	Reg
{
    long	pc;
    long	rpo;		/* reverse post ordering */

    Bits	set;
    Bits	use1;
    Bits	use2;

    Bits	refbehind;
    Bits	refahead;
    Bits	calbehind;
    Bits	calahead;
    Bits	regdiff;
    Bits	act;

    long	regu;
    long	loop;		/* could be shorter */

    Reg*	log5;
    long	active;

    Reg*	p1;
    Reg*	p2;
    Reg*	p2link;
    Reg*	s1;
    Reg*	s2;
    Reg*	link;
    Prog*	prog;
};
@

<<constant R>>=
#define	R	((Reg*)nil)
@



\section{Peep optimizer}

\section{Copy propagation}


\section{Arithmetic}
% see also 8c -m, print add/mul/sub trees


\subsection{[[Term]]}

<<constant NTERM>>=
#define	NTERM		10
@

<<struct Term>>=
struct	Term
{
    vlong	mult;
    Node	*node;
};
@

<<global term>>=
Term	term[NTERM];
@

<<global nterm>>=
int	nterm;
@


\subsection{[[acom()]]}
% cc/scon.c ??

% arithmetic compile? arithmetic specific checks?

<<function acom>>=
void
acom(Node *n)
{
    Type *t;
    Node *l, *r;
    int i;

    switch(n->op)
    {

    case ONAME:
    case OCONST:
    case OSTRING:
    case OINDREG:
    case OREGISTER:
        return;

    case ONEG:
        l = n->left;
        if(addo(n) && addo(l))
            break;
        acom(l);
        return;

    case OADD:
    case OSUB:
    case OMUL:
        l = n->left;
        r = n->right;
        if(addo(n)) {
            if(addo(r))
                break;
            if(addo(l))
                break;
        }
        acom(l);
        acom(r);
        return;

    default:
        l = n->left;
        r = n->right;
        if(l != Z)
            acom(l);
        if(r != Z)
            acom(r);
        return;
    }

    /* bust terms out */
    t = n->type;
    term[0].mult = 0;
    term[0].node = Z;
    nterm = 1;
    acom1(1, n);

    if(debug['m'])
     for(i=0; i<nterm; i++) {
        print("%d %3lld ", i, term[i].mult);
        prtree1(term[i].node, 1, 0);
    }

    if(nterm < NTERM)
        acom2(n, t);
    n->type = t;
}
@







\chapter{Object Generation}
%x86!

% target language = Adr, Prog, as, etc, like in Linker and assembler

% outcode, like in Assembler?

\chapter{Assembly Generation}

% 8c -S

% coupling with 8.out.h, but mostly autogenerated enam.c file?
<<global anames>>=
char*	anames[] =
{
    "XXX",
    "AAA",
    "AAD",
    "AAM",
    "AAS",
    "ADCB",
    "ADCL",
    "ADCW",
    "ADDB",
    "ADDL",
    "ADDW",
    "ADJSP",
    "ANDB",
    "ANDL",
    "ANDW",
    "ARPL",
    "BOUNDL",
    "BOUNDW",
    "BSFL",
    "BSFW",
    "BSRL",
    "BSRW",
    "BTL",
    "BTW",
    "BTCL",
    "BTCW",
    "BTRL",
    "BTRW",
    "BTSL",
    "BTSW",
    "BYTE",
    "CALL",
    "CLC",
    "CLD",
    "CLI",
    "CLTS",
    "CMC",
    "CMPB",
    "CMPL",
    "CMPW",
    "CMPSB",
    "CMPSL",
    "CMPSW",
    "DAA",
    "DAS",
    "DATA",
    "DECB",
    "DECL",
    "DECW",
    "DIVB",
    "DIVL",
    "DIVW",
    "ENTER",
    "GLOBL",
    "GOK",
    "HISTORY",
    "HLT",
    "IDIVB",
    "IDIVL",
    "IDIVW",
    "IMULB",
    "IMULL",
    "IMULW",
    "INB",
    "INL",
    "INW",
    "INCB",
    "INCL",
    "INCW",
    "INSB",
    "INSL",
    "INSW",
    "INT",
    "INTO",
    "IRETL",
    "IRETW",
    "JCC",
    "JCS",
    "JCXZ",
    "JEQ",
    "JGE",
    "JGT",
    "JHI",
    "JLE",
    "JLS",
    "JLT",
    "JMI",
    "JMP",
    "JNE",
    "JOC",
    "JOS",
    "JPC",
    "JPL",
    "JPS",
    "LAHF",
    "LARL",
    "LARW",
    "LEAL",
    "LEAW",
    "LEAVEL",
    "LEAVEW",
    "LOCK",
    "LODSB",
    "LODSL",
    "LODSW",
    "LONG",
    "LOOP",
    "LOOPEQ",
    "LOOPNE",
    "LSLL",
    "LSLW",
    "MOVB",
    "MOVL",
    "MOVW",
    "MOVBLSX",
    "MOVBLZX",
    "MOVBWSX",
    "MOVBWZX",
    "MOVWLSX",
    "MOVWLZX",
    "MOVSB",
    "MOVSL",
    "MOVSW",
    "MULB",
    "MULL",
    "MULW",
    "NAME",
    "NEGB",
    "NEGL",
    "NEGW",
    "NOP",
    "NOTB",
    "NOTL",
    "NOTW",
    "ORB",
    "ORL",
    "ORW",
    "OUTB",
    "OUTL",
    "OUTW",
    "OUTSB",
    "OUTSL",
    "OUTSW",
    "POPAL",
    "POPAW",
    "POPFL",
    "POPFW",
    "POPL",
    "POPW",
    "PUSHAL",
    "PUSHAW",
    "PUSHFL",
    "PUSHFW",
    "PUSHL",
    "PUSHW",
    "RCLB",
    "RCLL",
    "RCLW",
    "RCRB",
    "RCRL",
    "RCRW",
    "REP",
    "REPN",
    "RET",
    "ROLB",
    "ROLL",
    "ROLW",
    "RORB",
    "RORL",
    "RORW",
    "SAHF",
    "SALB",
    "SALL",
    "SALW",
    "SARB",
    "SARL",
    "SARW",
    "SBBB",
    "SBBL",
    "SBBW",
    "SCASB",
    "SCASL",
    "SCASW",
    "SETCC",
    "SETCS",
    "SETEQ",
    "SETGE",
    "SETGT",
    "SETHI",
    "SETLE",
    "SETLS",
    "SETLT",
    "SETMI",
    "SETNE",
    "SETOC",
    "SETOS",
    "SETPC",
    "SETPL",
    "SETPS",
    "CDQ",
    "CWD",
    "SHLB",
    "SHLL",
    "SHLW",
    "SHRB",
    "SHRL",
    "SHRW",
    "STC",
    "STD",
    "STI",
    "STOSB",
    "STOSL",
    "STOSW",
    "SUBB",
    "SUBL",
    "SUBW",
    "SYSCALL",
    "TESTB",
    "TESTL",
    "TESTW",
    "TEXT",
    "VERR",
    "VERW",
    "WAIT",
    "WORD",
    "XCHGB",
    "XCHGL",
    "XCHGW",
    "XLAT",
    "XORB",
    "XORL",
    "XORW",
    "FMOVB",
    "FMOVBP",
    "FMOVD",
    "FMOVDP",
    "FMOVF",
    "FMOVFP",
    "FMOVL",
    "FMOVLP",
    "FMOVV",
    "FMOVVP",
    "FMOVW",
    "FMOVWP",
    "FMOVX",
    "FMOVXP",
    "FCOMB",
    "FCOMBP",
    "FCOMD",
    "FCOMDP",
    "FCOMDPP",
    "FCOMF",
    "FCOMFP",
    "FCOML",
    "FCOMLP",
    "FCOMW",
    "FCOMWP",
    "FUCOM",
    "FUCOMP",
    "FUCOMPP",
    "FADDDP",
    "FADDW",
    "FADDL",
    "FADDF",
    "FADDD",
    "FMULDP",
    "FMULW",
    "FMULL",
    "FMULF",
    "FMULD",
    "FSUBDP",
    "FSUBW",
    "FSUBL",
    "FSUBF",
    "FSUBD",
    "FSUBRDP",
    "FSUBRW",
    "FSUBRL",
    "FSUBRF",
    "FSUBRD",
    "FDIVDP",
    "FDIVW",
    "FDIVL",
    "FDIVF",
    "FDIVD",
    "FDIVRDP",
    "FDIVRW",
    "FDIVRL",
    "FDIVRF",
    "FDIVRD",
    "FXCHD",
    "FFREE",
    "FLDCW",
    "FLDENV",
    "FRSTOR",
    "FSAVE",
    "FSTCW",
    "FSTENV",
    "FSTSW",
    "F2XM1",
    "FABS",
    "FCHS",
    "FCLEX",
    "FCOS",
    "FDECSTP",
    "FINCSTP",
    "FINIT",
    "FLD1",
    "FLDL2E",
    "FLDL2T",
    "FLDLG2",
    "FLDLN2",
    "FLDPI",
    "FLDZ",
    "FNOP",
    "FPATAN",
    "FPREM",
    "FPREM1",
    "FPTAN",
    "FRNDINT",
    "FSCALE",
    "FSIN",
    "FSINCOS",
    "FSQRT",
    "FTST",
    "FXAM",
    "FXTRACT",
    "FYL2X",
    "FYL2XP1",
    "END",
    "DYNT",
    "INIT",
    "SIGNAME",
    "FCOMI",
    "FCOMIP",
    "FUCOMI",
    "FUCOMIP",
    "CMPXCHGB",
    "CMPXCHGL",
    "CMPXCHGW",
    "CMOVLCC",
    "CMOVLCS",
    "CMOVLEQ",
    "CMOVLGE",
    "CMOVLGT",
    "CMOVLHI",
    "CMOVLLE",
    "CMOVLLS",
    "CMOVLLT",
    "CMOVLMI",
    "CMOVLNE",
    "CMOVLOC",
    "CMOVLOS",
    "CMOVLPC",
    "CMOVLPL",
    "CMOVLPS",
    "CMOVWCC",
    "CMOVWCS",
    "CMOVWEQ",
    "CMOVWGE",
    "CMOVWGT",
    "CMOVWHI",
    "CMOVWLE",
    "CMOVWLS",
    "CMOVWLT",
    "CMOVWMI",
    "CMOVWNE",
    "CMOVWOC",
    "CMOVWOS",
    "CMOVWPC",
    "CMOVWPL",
    "CMOVWPS",
    "FCMOVCC",
    "FCMOVCS",
    "FCMOVEQ",
    "FCMOVHI",
    "FCMOVLS",
    "FCMOVNE",
    "FCMOVNU",
    "FCMOVUN",
    "LAST",
};
@


<<struct Htab>>=
struct Htab { 
  Sym *sym; 
  short type; 
};
@

<<function outcode>>=
void
outcode(void)
{
    Prog *p;
    Sym *s;
    int f, sf, st, t, sym;
    Biobuf b;
    struct Htab h[NSYM];

    if(debug['S']) {
        for(p = firstp; p != P; p = p->link)
            if(p->as != ADATA && p->as != AGLOBL)
                pc--;
        for(p = firstp; p != P; p = p->link) {
            print("%P\n", p);
            if(p->as != ADATA && p->as != AGLOBL)
                pc++;
        }
    }
    f = open(outfile, OWRITE);
    if(f < 0) {
        diag(Z, "cannot open %s", outfile);
        return;
    }
    Binit(&b, f, OWRITE);
    Bseek(&b, 0L, 2);
    outhist(&b);
    for(sym=0; sym<NSYM; sym++) {
        h[sym].sym = S;
        h[sym].type = 0;
    }
    sym = 1;
    for(p = firstp; p != P; p = p->link) {
    jackpot:
        sf = 0;
        s = p->from.sym;
        while(s != S) {
            sf = s->sym;
            if(sf < 0 || sf >= NSYM)
                sf = 0;
            t = p->from.type;
            if(t == D_ADDR)
                t = p->from.index;
            if(h[sf].type == t)
            if(h[sf].sym == s)
                break;
            s->sym = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            sf = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            break;
        }
        st = 0;
        s = p->to.sym;
        while(s != S) {
            st = s->sym;
            if(st < 0 || st >= NSYM)
                st = 0;
            t = p->to.type;
            if(t == D_ADDR)
                t = p->to.index;
            if(h[st].type == t)
            if(h[st].sym == s)
                break;
            s->sym = sym;
            zname(&b, s, t);
            h[sym].sym = s;
            h[sym].type = t;
            st = sym;
            sym++;
            if(sym >= NSYM)
                sym = 1;
            if(st == sf)
                goto jackpot;
            break;
        }
        Bputc(&b, p->as);
        Bputc(&b, p->as>>8);
        Bputc(&b, p->lineno);
        Bputc(&b, p->lineno>>8);
        Bputc(&b, p->lineno>>16);
        Bputc(&b, p->lineno>>24);
        zaddr(&b, &p->from, sf);
        zaddr(&b, &p->to, st);
    }
    Bflush(&b);
    close(f);
    firstp = P;
    lastp = P;
}
@


<<global pathname>>=
char*	pathname;
@

<<function outhist>>=
void
outhist(Biobuf *b)
{
    Hist *h;
    char *p, *q, *op, c;
    Prog pg;
    int n;

    pg = zprog;
    pg.as = AHISTORY;
    c = pathchar();
    for(h = hist; h != H; h = h->link) {
        p = h->name;
        op = 0;
        if(p && p[0] != c && h->offset == 0 && pathname){
            if(pathname[0] == c){
                op = p;
                p = pathname;
            }
        }
        while(p) {
            q = utfrune(p, c);
            if(q) {
                n = q-p;
                if(n == 0){
                    n = 1;	/* leading "/" */
                    *p = '/';	/* don't emit "\" on windows */
                }
                q++;
            } else {
                n = strlen(p);
                q = 0;
            }
            if(n) {
                Bputc(b, ANAME);
                Bputc(b, ANAME>>8);
                Bputc(b, D_FILE);
                Bputc(b, 1);
                Bputc(b, '<');
                Bwrite(b, p, n);
                Bputc(b, 0);
            }
            p = q;
            if(p == 0 && op) {
                p = op;
                op = 0;
            }
        }
        pg.lineno = h->line;
        pg.to.type = zprog.to.type;
        pg.to.offset = h->offset;
        if(h->offset)
            pg.to.type = D_CONST;

        Bputc(b, pg.as);
        Bputc(b, pg.as>>8);
        Bputc(b, pg.lineno);
        Bputc(b, pg.lineno>>8);
        Bputc(b, pg.lineno>>16);
        Bputc(b, pg.lineno>>24);
        zaddr(b, &pg.from, 0);
        zaddr(b, &pg.to, 0);
    }
}
@

<<function zname>>=
void
zname(Biobuf *b, Sym *s, int t)
{
    char *n;
    ulong sig;

    if(debug['T'] && t == D_EXTERN && s->sig != SIGDONE && s->type != types[TENUM] && s != symrathole){
        sig = sign(s);
        Bputc(b, ASIGNAME);
        Bputc(b, ASIGNAME>>8);
        Bputc(b, sig);
        Bputc(b, sig>>8);
        Bputc(b, sig>>16);
        Bputc(b, sig>>24);
        s->sig = SIGDONE;
    }
    else{
        Bputc(b, ANAME);	/* as */
        Bputc(b, ANAME>>8);	/* as */
    }
    Bputc(b, t);			/* type */
    Bputc(b, s->sym);		/* sym */
    n = s->name;
    while(*n) {
        Bputc(b, *n);
        n++;
    }
    Bputc(b, 0);
}
@

<<function zaddr>>=
void
zaddr(Biobuf *b, Adr *a, int s)
{
    long l;
    int i, t;
    char *n;
    Ieee e;

    t = 0;
    if(a->index != D_NONE || a->scale != 0)
        t |= T_INDEX;
    if(s != 0)
        t |= T_SYM;

    switch(a->type) {
    default:
        t |= T_TYPE;
    case D_NONE:
        if(a->offset != 0)
            t |= T_OFFSET;
        break;
    case D_FCONST:
        t |= T_FCONST;
        break;
    case D_SCONST:
        t |= T_SCONST;
        break;
    }
    Bputc(b, t);

    if(t & T_INDEX) {	/* implies index, scale */
        Bputc(b, a->index);
        Bputc(b, a->scale);
    }
    if(t & T_OFFSET) {	/* implies offset */
        l = a->offset;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
    }
    if(t & T_SYM)		/* implies sym */
        Bputc(b, s);
    if(t & T_FCONST) {
        ieeedtod(&e, a->dval);
        l = e.l;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        l = e.h;
        Bputc(b, l);
        Bputc(b, l>>8);
        Bputc(b, l>>16);
        Bputc(b, l>>24);
        return;
    }
    if(t & T_SCONST) {
        n = a->sval;
        for(i=0; i<NSNAME; i++) {
            Bputc(b, *n);
            n++;
        }
        return;
    }
    if(t & T_TYPE)
        Bputc(b, a->type);
}
@


\chapter{Linking Support}

\section{[[#pragma lib]] and automagic linking}

\section{Safe linking with type signatures}


% md5sum like in ocaml!

% signature! for safe linking
<<enum sigxxx>>=
enum{
    SIGNONE = 0,
    SIGDONE = 1,
    SIGINTERN = 2,

    // ???
    SIGNINTERN = 1729*325*1729,
};
@

<<[[Sym]] other fields>>=
// enum<sigxxx>
char	sig;
@
% SIGNINTERN does not fit in a char ...


<<global thash1>>=
ulong	thash1	= 0x2edab8c9;
@

<<global thash2>>=
ulong	thash2	= 0x1dc74fb8;
@

<<global thash3>>=
ulong	thash3	= 0x1f241331;
@

<<global thash>>=
ulong	thash[NALLTYPES];
@

<<global thashinit>>=
Init	thashinit[] =
{
    TXXX,		0x17527bbd,	0,

    TCHAR,		0x5cedd32b,	0,
    TUCHAR,		0x552c4454,	0,
    TSHORT,		0x63040b4b,	0,
    TUSHORT,		0x32a45878,	0,
    TINT,		0x4151d5bd,	0,
    TUINT,		0x5ae707d6,	0,
    TLONG,		0x5ef20f47,	0,
    TULONG,		0x36d8eb8f,	0,
    TVLONG,		0x6e5e9590,	0,
    TUVLONG,		0x75910105,	0,
    TFLOAT,		0x25fd7af1,	0,
    TDOUBLE,		0x7c40a1b2,	0,

    TIND,		0x1b832357,	0,
    TFUNC,		0x6babc9cb,	0,
    TARRAY,		0x7c50986d,	0,
    TVOID,		0x44112eff,	0,
    TSTRUCT,		0x7c2da3bf,	0,
    TUNION,		0x3eb25e98,	0,
    TENUM,		0x44b54f61,	0,

    TFILE,		0x19242ac3,	0,
    TOLD,		0x22b15988,	0,
    TDOT,		0x0204f6b3,	0,

    -1,		0,		0,
};
@


<<struct Typetab>>=
struct Typetab {
    int n;
    Type **a;
};
@

<<function sigind>>=
static int
sigind(Type *t, Typetab *tt)
{
    int n;
    Type **a, **na, **p, **e;

    n = tt->n;
    a = tt->a;
    e = a+n;
    /* linear search seems ok */
    for(p = a ; p < e; p++)
        if(sametype(*p, t))
            return p-a;
    if((n&15) == 0){
        na = malloc((n+16)*sizeof(Type*));
        memmove(na, a, n*sizeof(Type*));
        free(a);
        a = tt->a = na;
    }
    a[tt->n++] = t;
    return -1;
}
@

<<function signat>>=
static ulong
signat(Type *t, Typetab *tt)
{
    int i;
    Type *t1;
    long s;

    s = 0;
    for(; t; t=t->link) {
        s = s*thash1 + thash[t->etype];
        if(t->garb&GINCOMPLETE)
            return s;
        switch(t->etype) {
        default:
            return s;
        case TARRAY:
            s = s*thash2 + 0;	/* was t->width */
            break;
        case TFUNC:
            for(t1=t->down; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            break;
        case TSTRUCT:
        case TUNION:
            if((i = sigind(t, tt)) >= 0){
                s = s*thash2 + i;
                return s;
            }
            for(t1=t->link; t1; t1=t1->down)
                s = s*thash3 + signat(t1, tt);
            return s;
        case TIND:
            break;
        }
    }
    return s;
}
@

<<function signature>>=
ulong
signature(Type *t)
{
    ulong s;
    Typetab tt;

    tt.n = 0;
    tt.a = nil;
    s = signat(t, &tt);
    free(tt.a);
    return s;
}
@

<<function sign>>=
ulong
sign(Sym *s)
{
    ulong v;
    Type *t;

    if(s->sig == SIGINTERN)
        return SIGNINTERN;
    if((t = s->type) == T)
        return 0;
    v = signature(t);
    if(v == 0)
        v = SIGNINTERN;
    return v;
}
@


\chapter{Debugging Support}

\section{Acid, [[8c -a]]}

% 8c -a to print acid declarations
%  -n print acid to file
%  -s print structure offsets


\subsection{Entities}

% called e.g. for enum constants in doenum() and dodecl()
% exported in cc.h
<<function acidvar>>=
void
acidvar(Sym *s)
{
    int n;
    Io *i;
    Type *t;
    Sym *s1, *s2;

    if(!debug['a'] || debug['s'])
        return;
    if(debug['a'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    t = s->type;
    while(t && t->etype == TIND)
        t = t->link;
    if(t == T)
        return;
    if(t->etype == TENUM) {
        Bprint(&outbuf, "%s = ", amap(s->name));
        if(!typefd[t->etype])
            Bprint(&outbuf, "%lld;\n", s->vconst);
        else
            Bprint(&outbuf, "%f\n;", s->fconst);
        return;
    }
    if(!typesu[t->etype])
        return;
    s1 = acidsue(t->link);
    if(s1 == S)
        return;
    switch(s->class) {
    case CAUTO:
    case CPARAM:
        s2 = acidfun(thisfn);
        if(s2)
            Bprint(&outbuf, "complex %s %s:%s;\n",
                amap(s1->name), amap(s2->name), amap(s->name));
        break;
    
    case CSTATIC:
    case CEXTERN:
    case CGLOBL:
    case CLOCAL:
        Bprint(&outbuf, "complex %s %s;\n",
            amap(s1->name), amap(s->name));
        break;
    }
}
@


<<function acidsue>>=
Sym*
acidsue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<function acidfun>>=
Sym*
acidfun(Type *t)
{
    int h;
    Sym *s;

    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->type == t)
                return s;
    return 0;
}
@



<<global kwd>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$builtin", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
% compared to Pickle.kwd ? $builtin en plus?

<<function amap>>=
char*
amap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@









\subsection{Structure/union definitions}

% called from sualign, so for struct and union
% exported in cc.h
<<function acidtype>>=
void
acidtype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['a'])
        return;
    if(debug['a'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = acidsue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = amap(s->name);
        Bprint(&outbuf, "sizeof%s = %ld;\n", an, t->width);
        Bprint(&outbuf, "aggr %s\n{\n", an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 1);
        Bprint(&outbuf, "};\n\n");

        Bprint(&outbuf, "defn\n%s(addr) {\n\tcomplex %s addr;\n", an, an);
        for(l = t->link; l != T; l = l->down)
            acidmember(l, 0, 0);
        Bprint(&outbuf, "};\n\n");
        break;
    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;
    }
}
@

<<global acidchar>>=
char	acidchar[NTYPE];
@

<<global acidcinit>>=
Init	acidcinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,	'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,	'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function acidinit>>=
static void
acidinit(void)
{
    Init *p;

    for(p=acidcinit; p->code >= 0; p++)
        acidchar[p->code] = p->value;

    acidchar[TINT] = acidchar[TLONG];
    acidchar[TUINT] = acidchar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        acidchar[TINT] = acidchar[TSHORT];
        acidchar[TUINT] = acidchar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "acidmember int not long or short");
    }
    if(types[TIND]->width == types[TUVLONG]->width)
        acidchar[TIND] = 'Y';
    
}
@

<<function acidmember>>=
void
acidmember(Type *t, long off, int flag)
{
    Sym *s, *s1;
    Type *l;
    static bool acidcharinit = false;

    if(acidcharinit == false) {
        acidinit();
        acidcharinit = true;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            break;
        if(flag) {
            for(l=t; l->etype==TIND; l=l->link)
                ;
            if(typesu[l->etype]) {
                s1 = acidsue(l->link);
                if(s1 != S) {
                    Bprint(&outbuf, "	'A' %s %ld %s;\n",
                        amap(s1->name),
                        t->offset+off, amap(s->name));
                    break;
                }
            }
        } else {
            Bprint(&outbuf,
                "\tprint(\"\t%s\t\", addr.%s\\X, \"\\n\");\n",
                amap(s->name), amap(s->name));
            break;
        }

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
    case TARRAY:
        if(s == S)
            break;
        if(flag) {
            Bprint(&outbuf, "	'%c' %ld %s;\n",
            acidchar[t->etype], t->offset+off, amap(s->name));
        } else {
            Bprint(&outbuf, "\tprint(\"\t%s\t\", addr.%s, \"\\n\");\n",
                amap(s->name), amap(s->name));
        }
        break;

    case TSTRUCT:
    case TUNION:
        s1 = acidsue(t->link);
        if(s1 == S)
            break;
        if(flag) {
            if(s == S) {
                Bprint(&outbuf, "	{\n");
                for(l = t->link; l != T; l = l->down)
                    acidmember(l, t->offset+off, flag);
                Bprint(&outbuf, "	};\n");
            } else {
                Bprint(&outbuf, "	%s %ld %s;\n",
                    amap(s1->name),
                    t->offset+off, amap(s->name));
            }
        } else {
            if(s != S) {
                Bprint(&outbuf, "\tprint(\"%s %s {\\n\");\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\t%s(addr.%s);\n",
                    amap(s1->name), amap(s->name));
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            } else {
                Bprint(&outbuf, "\tprint(\"%s {\\n\");\n",
                    amap(s1->name));
                Bprint(&outbuf, "\t\t%s(addr+%ld);\n",
                    amap(s1->name), t->offset+off);
                Bprint(&outbuf, "\tprint(\"}\\n\");\n");
            }
        }
        break;
    }
}
@




\section{Pickle, [[8c -Z]]}

% 8c -Z  and -n create _picke.c


<<global kwd (cc/pickle.c)>>=
static char *kwd[] =
{
    "$adt", "$aggr", "$append", "$complex", "$defn",
    "$delete", "$do", "$else", "$eval", "$head", "$if",
    "$local", "$loop", "$return", "$tail", "$then",
    "$union", "$whatis", "$while",
};
@
%$

<<global picklestr>>=
static char picklestr[] = "\tpickle(s, un, ";
@

<<function pmap>>=
static char*
pmap(char *s)
{
    int i, bot, top, new;

    bot = 0;
    top = bot + nelem(kwd) - 1;
    while(bot <= top){
        new = bot + (top - bot)/2;
        i = strcmp(kwd[new]+1, s);
        if(i == 0)
            return kwd[new];

        if(i < 0)
            bot = new + 1;
        else
            top = new - 1;
    }
    return s;
}
@

<<function picklesue>>=
Sym*
picklesue(Type *t)
{
    int h;
    Sym *s;

    if(t != T)
    for(h=0; h<nelem(hash); h++)
        for(s = hash[h]; s != S; s = s->link)
            if(s->suetag && s->suetag->link == t)
                return s;
    return 0;
}
@

<<global picklechar>>=
char	picklechar[NTYPE];
@

<<global picklecinit>>=
Init	picklecinit[] =
{
    TCHAR,		'C',	0,
    TUCHAR,		'b',	0,
    TSHORT,		'd',	0,
    TUSHORT,		'u',	0,
    TLONG,		'D',	0,
    TULONG,		'U',	0,
    TVLONG,		'V',	0,
    TUVLONG,	'W',	0,
    TFLOAT,		'f',	0,
    TDOUBLE,		'F',	0,
    TARRAY,		'a',	0,
    TIND,		'X',	0,
    -1,		0,	0,
};
@

<<function pickleinit>>=
static void
pickleinit(void)
{
    Init *p;

    for(p=picklecinit; p->code >= 0; p++)
        picklechar[p->code] = p->value;

    picklechar[TINT] = picklechar[TLONG];
    picklechar[TUINT] = picklechar[TULONG];
    if(types[TINT]->width != types[TLONG]->width) {
        picklechar[TINT] = picklechar[TSHORT];
        picklechar[TUINT] = picklechar[TUSHORT];
        if(types[TINT]->width != types[TSHORT]->width)
            warn(Z, "picklemember int not long or short");
    }
    
}
@

<<function picklemember>>=
void
picklemember(Type *t, long off)
{
    Sym *s, *s1;
    static int picklecharinit = 0;

    if(picklecharinit == 0) {
        pickleinit();
        picklecharinit = 1;
    }
    s = t->sym;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "	T%d\n", t->etype);
        break;

    case TIND:
        if(s == S)
            Bprint(&outbuf,
                "%s\"p\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, t->offset+off, t->width);
        else
            Bprint(&outbuf,
                "%s\"p\", &addr->%s);\n",
                picklestr, pmap(s->name));
        break;

    case TINT:
    case TUINT:
    case TCHAR:
    case TUCHAR:
    case TSHORT:
    case TUSHORT:
    case TLONG:
    case TULONG:
    case TVLONG:
    case TUVLONG:
    case TFLOAT:
    case TDOUBLE:
        if(s == S)
            Bprint(&outbuf, "%s\"%c\", (char*)addr+%ld+_i*%ld);\n",
                picklestr, picklechar[t->etype], t->offset+off, t->width);
        else
            Bprint(&outbuf, "%s\"%c\", &addr->%s);\n",
                picklestr, picklechar[t->etype], pmap(s->name));
        break;
    case TARRAY:
        Bprint(&outbuf, "\tfor(_i = 0; _i < %ld; _i++) {\n\t",
            t->width/t->link->width);
        picklemember(t->link, t->offset+off);
        Bprint(&outbuf, "\t}\n\t_i = 0;\n\tUSED(_i);\n");
        break;

    case TSTRUCT:
    case TUNION:
        s1 = picklesue(t->link);
        if(s1 == S)
            break;
        if(s == S) {
            Bprint(&outbuf, "\tpickle_%s(s, un, (%s*)((char*)addr+%ld+_i*%ld));\n",
                pmap(s1->name), pmap(s1->name), t->offset+off, t->width);
        } else {
            Bprint(&outbuf, "\tpickle_%s(s, un, &addr->%s);\n",
                pmap(s1->name), pmap(s->name));
        }
        break;
    }
}
@

<<function pickletype>>=
void
pickletype(Type *t)
{
    Sym *s;
    Type *l;
    Io *i;
    int n;
    char *an;

    if(!debug['P'])
        return;
    if(debug['P'] > 1) {
        n = 0;
        for(i=iostack; i; i=i->link)
            n++;
        if(n > 1)
            return;
    }
    s = picklesue(t->link);
    if(s == S)
        return;
    switch(t->etype) {
    default:
        Bprint(&outbuf, "T%d\n", t->etype);
        return;

    case TUNION:
    case TSTRUCT:
        if(debug['s'])
            goto asmstr;
        an = pmap(s->name);

        Bprint(&outbuf, "void\npickle_%s(void *s, int un, %s *addr)\n{\n\tint _i = 0;\n\n\tUSED(_i);\n", an, an);
        for(l = t->link; l != T; l = l->down)
            picklemember(l, 0);
        Bprint(&outbuf, "}\n\n");
        break;
    asmstr:
        if(s == S)
            break;
        for(l = t->link; l != T; l = l->down)
            if(l->sym != S)
                Bprint(&outbuf, "#define\t%s.%s\t%ld\n",
                    s->name,
                    l->sym->name,
                    l->offset);
        break;
    }
}
@

%<<function picklefun>>=
%//Sym*
%//picklefun(Type *t)
%//{
%//    int h;
%//    Sym *s;
%//
%//    for(h=0; h<nelem(hash); h++)
%//        for(s = hash[h]; s != S; s = s->link)
%//            if(s->type == t)
%//                return s;
%//    return 0;
%//}
%@
%
%<<function picklevar>>=
%//void
%//picklevar(Sym *s)
%//{
%//    int n;
%//    Io *i;
%//    Type *t;
%//    Sym *s1, *s2;
%//
%//    if(!debug['P'] || debug['s'])
%//        return;
%//    if(debug['P'] > 1) {
%//        n = 0;
%//        for(i=iostack; i; i=i->link)
%//            n++;
%//        if(n > 1)
%//            return;
%//    }
%//    t = s->type;
%//    while(t && t->etype == TIND)
%//        t = t->link;
%//    if(t == T)
%//        return;
%//    if(t->etype == TENUM) {
%//        Bprint(&outbuf, "%s = ", pmap(s->name));
%//        if(!typefd[t->etype])
%//            Bprint(&outbuf, "%lld;\n", s->vconst);
%//        else
%//            Bprint(&outbuf, "%f\n;", s->fconst);
%//        return;
%//    }
%//    if(!typesu[t->etype])
%//        return;
%//    s1 = picklesue(t->link);
%//    if(s1 == S)
%//        return;
%//    switch(s->class) {
%//    case CAUTO:
%//    case CPARAM:
%//        s2 = picklefun(thisfn);
%//        if(s2)
%//            Bprint(&outbuf, "complex %s %s:%s;\n",
%//                pmap(s1->name), pmap(s2->name), pmap(s->name));
%//        break;
%//    
%//    case CSTATIC:
%//    case CEXTERN:
%//    case CGLOBL:
%//    case CLOCAL:
%//        Bprint(&outbuf, "complex %s %s;\n",
%//            pmap(s1->name), pmap(s->name));
%//        break;
%//    }
%//}
%@


\chapter{Profiling Support}

% actually always true, only way to disable it is via pragma locally
<<global profileflg>>=
bool	profileflg;
@

\chapter{Advanced Topics}

\section{[[typestr]]}
% ???

<<function dclfunct>>=
void
dclfunct(Type *t, Sym *s)
{
    Funct *f;
    Node *n;
    Type *f1, *f2, *f3, *f4;
    int o, i, c;
    char str[100];

    if(t->funct)
        return;

    // recognize generated tag of dorm _%d_
    if(t->tag == S)
        goto bad;
    for(i=0; c = t->tag->name[i]; i++) {
        if(c == '_') {
            if(i == 0 || t->tag->name[i+1] == 0)
                continue;
            break;
        }
        if(c < '0' || c > '9')
            break;
    }
    if(c == 0)
        goto bad;

    f = alloc(sizeof(*f));
    for(o=0; o<sizeof(f->sym); o++)
        f->sym[o] = S;

    t->funct = f;

    f1 = typ(TFUNC, t);
    f1->down = copytyp(t);
    f1->down->down = t;

    f2 = typ(TFUNC, types[TINT]);
    f2->down = copytyp(t);
    f2->down->down = t;

    f3 = typ(TFUNC, t);
    f3->down = typ(TIND, t);
    f3->down->down = t;

    f4 = typ(TFUNC, t);
    f4->down = t;

    for(i=0;; i++) {
        o = ftabinit[i].op;
        if(o == OXXX)
            break;
        sprint(str, "%s_%s_", t->tag->name, ftabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->sym[o] = n->sym;
        switch(ftabinit[i].typ) {
        default:
            diag(Z, "dclfunct op missing %d\n", ftabinit[i].typ);
            break;

        case 1:	// T f(T,T)	+
            dodecl(xdecl, CEXTERN, f1, n);
            break;

        case 2:	// int f(T,T)	==
            dodecl(xdecl, CEXTERN, f2, n);
            break;

        case 3:	// void f(T*,T)	+=
            dodecl(xdecl, CEXTERN, f3, n);
            break;

        case 4:	// T f(T)	~
            dodecl(xdecl, CEXTERN, f4, n);
            break;
        }
    }
    for(i=0;; i++) {
        o = gtabinit[i].etype;
        if(o == TXXX)
            break;

        /*
         * OCAST types T1 _T2_T1_(T2)
         */
        sprint(str, "_%s%s_", gtabinit[i].name, t->tag->name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castto[o] = n->sym;

        f1 = typ(TFUNC, t);
        f1->down = types[o];
        dodecl(xdecl, CEXTERN, f1, n);

        sprint(str, "%s_%s_", t->tag->name, gtabinit[i].name);
        n = new(ONAME, Z, Z);
        n->sym = slookup(str);
        f->castfr[o] = n->sym;

        f1 = typ(TFUNC, types[o]);
        f1->down = t;
        dodecl(xdecl, CEXTERN, f1, n);
    }
    return;
bad:
    diag(Z, "dclfunct bad %T %s\n", t, s->name);
}
@


% why not use Init?
<<struct Ftab>>=
struct	Ftab
{
    char	op;
    char*	name;
    char	typ;
};
@

% why not use Init?
<<struct Gtab>>=
struct	Gtab
{
    char	etype;
    char*	name;
};
@

<<global gtabinit>>=
Gtab	gtabinit[NTYPE] =
{
    TCHAR,		"c",
    TUCHAR,		"uc",
    TSHORT,		"h",
    TUSHORT,		"uh",
    TINT,		"i",
    TUINT,		"ui",
    TLONG,		"l",
    TULONG,		"ul",
    TVLONG,		"v",
    TUVLONG,		"uv",
    TFLOAT,		"f",
    TDOUBLE,		"d",

    TXXX
};
@

<<global ftabinit>>=
Ftab	ftabinit[OEND] =
{
    OADD,		"add",		1,
    OAND,		"and",		1,
    OASHL,		"ashl",		1,
    OASHR,		"ashr",		1,
    ODIV,		"div",		1,
    OLDIV,		"ldiv",		1,
    OLMOD,		"lmod",		1,
    OLMUL,		"lmul",		1,
    OLSHR,		"lshr",		1,
    OMOD,		"mod",		1,
    OMUL,		"mul",		1,
    OOR,		"or",		1,
    OSUB,		"sub",		1,
    OXOR,		"xor",		1,

    OEQ,		"eq",		2,
    OGE,		"ge",		2,
    OGT,		"gt",		2,
    OHI,		"hi",		2,
    OHS,		"hs",		2,
    OLE,		"le",		2,
    OLO,		"lo",		2,
    OLS,		"ls",		2,
    OLT,		"lt",		2,
    ONE,		"ne",		2,

    OASADD,		"asadd",	3,
    OASAND,		"asand",	3,
    OASASHL,	"asashl",	3,
    OASASHR,	"asashr",	3,
    OASDIV,		"asdiv",	3,
    OASLDIV,	"asldiv",	3,
    OASLMOD,	"aslmod",	3,
    OASLMUL,	"aslmul",	3,
    OASLSHR,	"aslshr",	3,
    OASMOD,		"asmod",	3,
    OASMUL,		"asmul",	3,
    OASOR,		"asor",		3,
    OASSUB,		"assub",	3,
    OASXOR,		"asxor",	3,

    OPOS,		"pos",		4,
    ONEG,		"neg",		4,
    OCOM,		"com",		4,
    ONOT,		"not",		4,

//	OPOSTDEC,
//	OPOSTINC,
//	OPREDEC,
//	OPREINC,

    OXXX,
};
@



\section{Float}

<<function ieeedtod>>=
void
ieeedtod(Ieee *ieee, double native)
{
    double fr, ho, f;
    int exp;

    if(native < 0) {
        ieeedtod(ieee, -native);
        ieee->h |= 0x80000000L;
        return;
    }
    if(native == 0) {
        ieee->l = 0;
        ieee->h = 0;
        return;
    }
    fr = frexp(native, &exp);
    f = 2097152L;		/* shouldnt use fp constants here */
    fr = modf(fr*f, &ho);
    ieee->h = ho;
    ieee->h &= 0xfffffL;
    ieee->h |= (exp+1022L) << 20;
    f = 65536L;
    fr = modf(fr*f, &ho);
    ieee->l = ho;
    ieee->l <<= 16;
    ieee->l |= (long)(fr*f);
}
@




<<function allfloat>>=
/*
 * look into tree for floating point constant expressions
 */
bool
allfloat(Node *n, int flag)
{

    if(n != Z) {
        if(n->type->etype != TDOUBLE)
            return true;
        switch(n->op) {
        case OCONST:
            if(flag)
                n->type = types[TFLOAT];
            return true;
        case OADD:	/* no need to get more exotic than this */
        case OSUB:
        case OMUL:
        case ODIV:
            if(!allfloat(n->right, flag))
                break;
        case OCAST:
            if(!allfloat(n->left, flag))
                break;
            if(flag)
                n->type = types[TFLOAT];
            return true;
        }
    }
    return false;
}
@

\section{64 bits}


% portable part, cc/com64.c
% vlong is 64 bits, so how do on 32 bits?
% do via builtins _xxxv, e.g. _addv, _mulv in lib_core/libc/xxx/vlop.c

<<constant FNX>>=
/*
 * this is machine dependent, but it is totally
 * common on all of the 64-bit symulating machines.
 */

#define	FNX	100	/* botch -- redefinition */
@

<<global nodaddv>>=
Node*	nodaddv;
@

<<global nodsubv>>=
Node*	nodsubv;
@

<<global nodmulv>>=
Node*	nodmulv;
@

<<global noddivv>>=
Node*	noddivv;
@

<<global noddivvu>>=
Node*	noddivvu;
@

<<global nodmodv>>=
Node*	nodmodv;
@

<<global nodmodvu>>=
Node*	nodmodvu;
@

<<global nodlshv>>=
Node*	nodlshv;
@

<<global nodrshav>>=
Node*	nodrshav;
@

<<global nodrshlv>>=
Node*	nodrshlv;
@

<<global nodandv>>=
Node*	nodandv;
@

<<global nodorv>>=
Node*	nodorv;
@

<<global nodxorv>>=
Node*	nodxorv;
@

<<global nodnegv>>=
Node*	nodnegv;
@

<<global nodcomv>>=
Node*	nodcomv;
@

<<global nodtestv>>=
Node*	nodtestv;
@

<<global nodeqv>>=
Node*	nodeqv;
@

<<global nodnev>>=
Node*	nodnev;
@

<<global nodlev>>=
Node*	nodlev;
@

<<global nodltv>>=
Node*	nodltv;
@

<<global nodgev>>=
Node*	nodgev;
@

<<global nodgtv>>=
Node*	nodgtv;
@

<<global nodhiv>>=
Node*	nodhiv;
@

<<global nodhsv>>=
Node*	nodhsv;
@

<<global nodlov>>=
Node*	nodlov;
@

<<global nodlsv>>=
Node*	nodlsv;
@

<<global nodf2v>>=
Node*	nodf2v;
@

<<global nodd2v>>=
Node*	nodd2v;
@

<<global nodp2v>>=
Node*	nodp2v;
@

<<global nodsi2v>>=
Node*	nodsi2v;
@

<<global nodui2v>>=
Node*	nodui2v;
@

<<global nodsl2v>>=
Node*	nodsl2v;
@

<<global nodul2v>>=
Node*	nodul2v;
@

<<global nodsh2v>>=
Node*	nodsh2v;
@

<<global noduh2v>>=
Node*	noduh2v;
@

<<global nodsc2v>>=
Node*	nodsc2v;
@

<<global noduc2v>>=
Node*	noduc2v;
@

<<global nodv2f>>=
Node*	nodv2f;
@

<<global nodv2d>>=
Node*	nodv2d;
@

<<global nodv2ui>>=
Node*	nodv2ui;
@

<<global nodv2si>>=
Node*	nodv2si;
@

<<global nodv2ul>>=
Node*	nodv2ul;
@

<<global nodv2sl>>=
Node*	nodv2sl;
@

<<global nodv2uh>>=
Node*	nodv2uh;
@

<<global nodv2sh>>=
Node*	nodv2sh;
@

<<global nodv2uc>>=
Node*	nodv2uc;
@

<<global nodv2sc>>=
Node*	nodv2sc;
@

<<global nodvpp>>=
Node*	nodvpp;
@

<<global nodppv>>=
Node*	nodppv;
@

<<global nodvmm>>=
Node*	nodvmm;
@

<<global nodmmv>>=
Node*	nodmmv;
@

<<global nodvasop>>=
Node*	nodvasop;
@

<<global etconv>>=
char	etconv[NTYPE];	/* for _vasop */
@

<<global initetconv>>=
Init	initetconv[] =
{
    TCHAR,		1,	0,
    TUCHAR,		2,	0,
    TSHORT,		3,	0,
    TUSHORT,	4,	0,
    TLONG,		5,	0,
    TULONG,		6,	0,
    TVLONG,		7,	0,
    TUVLONG,	8,	0,
    TINT,		9,	0,
    TUINT,		10,	0,
    -1,		0,	0,
};
@

<<global fntypes>>=
Type*	fntypes[NTYPE];
@

<<function fvn>>=
Node*
fvn(char *name, int type)
{
    Node *n;

    n = new(ONAME, Z, Z);
    n->sym = slookup(name);
    n->sym->sig = SIGINTERN;
    if(fntypes[type] == 0)
        fntypes[type] = typ(TFUNC, types[type]);
    n->type = fntypes[type];
    n->etype = type;
    n->class = CGLOBL;
    n->addable = 10;
    n->complex = 0;
    return n;
}
@

<<function com64init>>=
void
com64init(void)
{
    Init *p;

    nodaddv = fvn("_addv", TVLONG);
    nodsubv = fvn("_subv", TVLONG);
    nodmulv = fvn("_mulv", TVLONG);
    noddivv = fvn("_divv", TVLONG);
    noddivvu = fvn("_divvu", TVLONG);
    nodmodv = fvn("_modv", TVLONG);
    nodmodvu = fvn("_modvu", TVLONG);
    nodlshv = fvn("_lshv", TVLONG);
    nodrshav = fvn("_rshav", TVLONG);
    nodrshlv = fvn("_rshlv", TVLONG);
    nodandv = fvn("_andv", TVLONG);
    nodorv = fvn("_orv", TVLONG);
    nodxorv = fvn("_xorv", TVLONG);
    nodnegv = fvn("_negv", TVLONG);
    nodcomv = fvn("_comv", TVLONG);

    nodtestv = fvn("_testv", TLONG);
    nodeqv = fvn("_eqv", TLONG);
    nodnev = fvn("_nev", TLONG);
    nodlev = fvn("_lev", TLONG);
    nodltv = fvn("_ltv", TLONG);
    nodgev = fvn("_gev", TLONG);
    nodgtv = fvn("_gtv", TLONG);
    nodhiv = fvn("_hiv", TLONG);
    nodhsv = fvn("_hsv", TLONG);
    nodlov = fvn("_lov", TLONG);
    nodlsv = fvn("_lsv", TLONG);

    nodf2v = fvn("_f2v", TVLONG);
    nodd2v = fvn("_d2v", TVLONG);
    nodp2v = fvn("_p2v", TVLONG);
    nodsi2v = fvn("_si2v", TVLONG);
    nodui2v = fvn("_ui2v", TVLONG);
    nodsl2v = fvn("_sl2v", TVLONG);
    nodul2v = fvn("_ul2v", TVLONG);
    nodsh2v = fvn("_sh2v", TVLONG);
    noduh2v = fvn("_uh2v", TVLONG);
    nodsc2v = fvn("_sc2v", TVLONG);
    noduc2v = fvn("_uc2v", TVLONG);

    nodv2f = fvn("_v2f", TFLOAT);
    nodv2d = fvn("_v2d", TDOUBLE);
    nodv2sl = fvn("_v2sl", TLONG);
    nodv2ul = fvn("_v2ul", TULONG);
    nodv2si = fvn("_v2si", TINT);
    nodv2ui = fvn("_v2ui", TUINT);
    nodv2sh = fvn("_v2sh", TSHORT);
    nodv2uh = fvn("_v2ul", TUSHORT);
    nodv2sc = fvn("_v2sc", TCHAR);
    nodv2uc = fvn("_v2uc", TUCHAR);

    nodvpp = fvn("_vpp", TVLONG);
    nodppv = fvn("_ppv", TVLONG);
    nodvmm = fvn("_vmm", TVLONG);
    nodmmv = fvn("_mmv", TVLONG);

    nodvasop = fvn("_vasop", TVLONG);

    for(p = initetconv; p->code >= 0; p++)
        etconv[p->code] = p->value;
}
@

<<function com64>>=
int
com64(Node *n)
{
    Node *l, *r, *a, *t;
    int lv, rv;

    if(n->type == 0)
        return 0;

    l = n->left;
    r = n->right;

    lv = 0;
    if(l && l->type && typev[l->type->etype])
        lv = 1;
    rv = 0;
    if(r && r->type && typev[r->type->etype])
        rv = 1;

    if(lv) {
        switch(n->op) {
        case OEQ:
            a = nodeqv;
            goto setbool;
        case ONE:
            a = nodnev;
            goto setbool;
        case OLE:
            a = nodlev;
            goto setbool;
        case OLT:
            a = nodltv;
            goto setbool;
        case OGE:
            a = nodgev;
            goto setbool;
        case OGT:
            a = nodgtv;
            goto setbool;
        case OHI:
            a = nodhiv;
            goto setbool;
        case OHS:
            a = nodhsv;
            goto setbool;
        case OLO:
            a = nodlov;
            goto setbool;
        case OLS:
            a = nodlsv;
            goto setbool;

        case OANDAND:
        case OOROR:
            if(machcap(n))
                return 1;

            if(rv) {
                r = new(OFUNC, nodtestv, r);
                n->right = r;
                r->complex = FNX;
                r->op = OFUNC;
                r->type = types[TLONG];
            }

        case OCOND:
        case ONOT:
            if(machcap(n))
                return 1;

            l = new(OFUNC, nodtestv, l);
            n->left = l;
            l->complex = FNX;
            l->op = OFUNC;
            l->type = types[TLONG];
            n->complex = FNX;
            return 1;
        }
    }

    if(rv) {
        if(machcap(n))
            return 1;
        switch(n->op) {
        case OANDAND:
        case OOROR:
            r = new(OFUNC, nodtestv, r);
            n->right = r;
            r->complex = FNX;
            r->op = OFUNC;
            r->type = types[TLONG];
            return 1;
        case OCOND:
            return 1;
        }
    }

    if(typev[n->type->etype]) {
        if(machcap(n))
            return 1;
        switch(n->op) {
        default:
            diag(n, "unknown vlong %O", n->op);
        case OFUNC:
            n->complex = FNX;
        case ORETURN:
        case OAS:
        case OIND:
        case OLIST:
        case OCOMMA:
            return 1;
        case OADD:
            a = nodaddv;
            goto setbop;
        case OSUB:
            a = nodsubv;
            goto setbop;
        case OMUL:
        case OLMUL:
            a = nodmulv;
            goto setbop;
        case ODIV:
            a = noddivv;
            goto setbop;
        case OLDIV:
            a = noddivvu;
            goto setbop;
        case OMOD:
            a = nodmodv;
            goto setbop;
        case OLMOD:
            a = nodmodvu;
            goto setbop;
        case OASHL:
            a = nodlshv;
            goto setbop;
        case OASHR:
            a = nodrshav;
            goto setbop;
        case OLSHR:
            a = nodrshlv;
            goto setbop;
        case OAND:
            a = nodandv;
            goto setbop;
        case OOR:
            a = nodorv;
            goto setbop;
        case OXOR:
            a = nodxorv;
            goto setbop;
        case OPOSTINC:
            a = nodvpp;
            goto setvinc;
        case OPOSTDEC:
            a = nodvmm;
            goto setvinc;
        case OPREINC:
            a = nodppv;
            goto setvinc;
        case OPREDEC:
            a = nodmmv;
            goto setvinc;
        case ONEG:
            a = nodnegv;
            goto setfnx;
        case OCOM:
            a = nodcomv;
            goto setfnx;
        case OCAST:
            switch(l->type->etype) {
            case TCHAR:
                a = nodsc2v;
                goto setfnxl;
            case TUCHAR:
                a = noduc2v;
                goto setfnxl;
            case TSHORT:
                a = nodsh2v;
                goto setfnxl;
            case TUSHORT:
                a = noduh2v;
                goto setfnxl;
            case TINT:
                a = nodsi2v;
                goto setfnx;
            case TUINT:
                a = nodui2v;
                goto setfnx;
            case TLONG:
                a = nodsl2v;
                goto setfnx;
            case TULONG:
                a = nodul2v;
                goto setfnx;
            case TFLOAT:
                a = nodf2v;
                goto setfnx;
            case TDOUBLE:
                a = nodd2v;
                goto setfnx;
            case TIND:
                a = nodp2v;
                goto setfnx;
            }
            diag(n, "unknown %T->vlong cast", l->type);
            return 1;
        case OASADD:
            a = nodaddv;
            goto setasop;
        case OASSUB:
            a = nodsubv;
            goto setasop;
        case OASMUL:
        case OASLMUL:
            a = nodmulv;
            goto setasop;
        case OASDIV:
            a = noddivv;
            goto setasop;
        case OASLDIV:
            a = noddivvu;
            goto setasop;
        case OASMOD:
            a = nodmodv;
            goto setasop;
        case OASLMOD:
            a = nodmodvu;
            goto setasop;
        case OASASHL:
            a = nodlshv;
            goto setasop;
        case OASASHR:
            a = nodrshav;
            goto setasop;
        case OASLSHR:
            a = nodrshlv;
            goto setasop;
        case OASAND:
            a = nodandv;
            goto setasop;
        case OASOR:
            a = nodorv;
            goto setasop;
        case OASXOR:
            a = nodxorv;
            goto setasop;
        }
    }

    if(typefd[n->type->etype] && l && l->op == OFUNC) {
        switch(n->op) {
        case OASADD:
        case OASSUB:
        case OASMUL:
        case OASLMUL:
        case OASDIV:
        case OASLDIV:
        case OASMOD:
        case OASLMOD:
        case OASASHL:
        case OASASHR:
        case OASLSHR:
        case OASAND:
        case OASOR:
        case OASXOR:
            if(l->right && typev[l->right->etype]) {
                diag(n, "sorry float <asop> vlong not implemented\n");
            }
        }
    }

    if(n->op == OCAST) {
        if(l->type && typev[l->type->etype]) {
            if(machcap(n))
                return 1;
            switch(n->type->etype) {
            case TDOUBLE:
                a = nodv2d;
                goto setfnx;
            case TFLOAT:
                a = nodv2f;
                goto setfnx;
            case TLONG:
                a = nodv2sl;
                goto setfnx;
            case TULONG:
                a = nodv2ul;
                goto setfnx;
            case TINT:
                a = nodv2si;
                goto setfnx;
            case TUINT:
                a = nodv2ui;
                goto setfnx;
            case TSHORT:
                a = nodv2sh;
                goto setfnx;
            case TUSHORT:
                a = nodv2uh;
                goto setfnx;
            case TCHAR:
                a = nodv2sc;
                goto setfnx;
            case TUCHAR:
                a = nodv2uc;
                goto setfnx;
            case TIND:	// small pun here
                a = nodv2ul;
                goto setfnx;
            }
            diag(n, "unknown vlong->%T cast", n->type);
            return 1;
        }
    }

    return 0;

setbop:
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setfnxl:
    l = new(OCAST, l, 0);
    l->type = types[TLONG];
    l->complex = l->left->complex;

setfnx:
    n->left = a;
    n->right = l;
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setvinc:
    n->left = a;
    l = new(OADDR, l, Z);
    l->type = typ(TIND, l->left->type);
    l->complex = l->left->complex;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    return 1;

setbool:
    if(machcap(n))
        return 1;
    n->left = a;
    n->right = new(OLIST, l, r);
    n->complex = FNX;
    n->op = OFUNC;
    n->type = types[TLONG];
    return 1;

setasop:
    if(l->op == OFUNC) {
        l = l->right;
        goto setasop;
    }

    t = new(OCONST, 0, 0);
    t->vconst = etconv[l->type->etype];
    t->type = types[TLONG];
    t->addable = 20;
    r = new(OLIST, t, r);

    t = new(OADDR, a, 0);
    t->type = typ(TIND, a->type);
    r = new(OLIST, t, r);

    t = new(OADDR, l, 0);
    t->type = typ(TIND, l->type);
    t->complex = l->complex;
    r = new(OLIST, t, r);

    n->left = nodvasop;
    n->right = r;
    n->complex = FNX;
    n->op = OFUNC;

    return 1;
}
@

<<function bool64>>=
void
bool64(Node *n)
{
    Node *n1;

    if(machcap(Z))
        return;
    if(typev[n->type->etype]) {
        n1 = new(OXXX, 0, 0);
        *n1 = *n;

        n->right = n1;
        n->left = nodtestv;
        n->complex = FNX;
        n->addable = 0;
        n->op = OFUNC;
        n->type = types[TLONG];
    }
}
@

%<<function convvtof>>=
%/*
% * more machine depend stuff.
% * this is common for 8,16,32,64 bit machines.
% * this is common for ieee machines.
% */
%//double
%//convvtof(vlong v)
%//{
%//    double d;
%//
%//    d = v;		/* BOTCH */
%//    return d;
%//}
%@
%
%<<function convftov>>=
%//vlong
%//convftov(double d)
%//{
%//    vlong v;
%//
%//
%//    v = d;		/* BOTCH */
%//    return v;
%//}
%@
%
%<<function convftox>>=
%//double
%//convftox(double d, int et)
%//{
%//
%//    if(!typefd[et])
%//        diag(Z, "bad type in castftox %s", tnames[et]);
%//    return d;
%//}
%@



<<function convvtox>>=
vlong
convvtox(vlong c, int et)
{
    int n;

    n = 8 * ewidth[et];
    c &= MASK(n);
    if(!typeu[et])
        if(c & SIGN(n))
            c |= ~MASK(n);
    return c;
}
@


\section{Endianness}
% 8c -l, just for mips => switch from vc to 0c


\section{Processing multiple files}

\chapter{Conclusion}

\appendix

\chapter{Debugging}

<<global debug>>=
char	debug[256];
@

\section{[[Fmt]]}

<<[[cinit()]] fmtinstall>>=
fmtinstall('O', Oconv);
fmtinstall('T', Tconv);
fmtinstall('F', FNconv);
fmtinstall('L', Lconv);
fmtinstall('Q', Qconv);
fmtinstall('|', VBconv);
@

\subsection{[[cc/]]}

<<function Oconv>>=
// enum<node_kind> -> string
int Oconv(Fmt *fp)
{
    int a;

    a = va_arg(fp->args, int);
    if(a < OXXX || a > OEND)
        return fmtprint(fp, "***badO %d***", a);

    return fmtstrcpy(fp, onames[a]);
}
@

<<global onames>>=
char*	onames[OEND+1];
@

<<global onamesinit>>=
Init	onamesinit[] =
{
    OXXX,		0,	"OXXX",
    OADD,		0,	"ADD",
    OADDR,		0,	"ADDR",
    OAND,		0,	"AND",
    OANDAND,	0,	"ANDAND",
    OARRAY,		0,	"ARRAY",
    OAS,		0,	"AS",
    OASI,		0,	"ASI",
    OASADD,		0,	"ASADD",
    OASAND,		0,	"ASAND",
    OASASHL,	0,	"ASASHL",
    OASASHR,	0,	"ASASHR",
    OASDIV,		0,	"ASDIV",
    OASHL,		0,	"ASHL",
    OASHR,		0,	"ASHR",
    OASLDIV,	0,	"ASLDIV",
    OASLMOD,	0,	"ASLMOD",
    OASLMUL,	0,	"ASLMUL",
    OASLSHR,	0,	"ASLSHR",
    OASMOD,		0,	"ASMOD",
    OASMUL,		0,	"ASMUL",
    OASOR,		0,	"ASOR",
    OASSUB,		0,	"ASSUB",
    OASXOR,		0,	"ASXOR",
    OBIT,		0,	"BIT",
    OBREAK,		0,	"BREAK",
    OCASE,		0,	"CASE",
    OCAST,		0,	"CAST",
    OCOMMA,		0,	"COMMA",
    OCOND,		0,	"COND",
    OCONST,		0,	"CONST",
    OCONTINUE,	0,	"CONTINUE",
    ODIV,		0,	"DIV",
    ODOT,		0,	"DOT",
    ODOTDOT,	0,	"DOTDOT",
    ODWHILE,	0,	"DWHILE",
    OENUM,		0,	"ENUM",
    OEQ,		0,	"EQ",
    OFOR,		0,	"FOR",
    OFUNC,		0,	"FUNC",
    OGE,		0,	"GE",
    OGOTO,		0,	"GOTO",
    OGT,		0,	"GT",
    OHI,		0,	"HI",
    OHS,		0,	"HS",
    OIF,		0,	"IF",
    OIND,		0,	"IND",
    OINDREG,	0,	"INDREG",
    OINIT,		0,	"INIT",
    OLABEL,		0,	"LABEL",
    OLDIV,		0,	"LDIV",
    OLE,		0,	"LE",
    OLIST,		0,	"LIST",
    OLMOD,		0,	"LMOD",
    OLMUL,		0,	"LMUL",
    OLO,		0,	"LO",
    OLS,		0,	"LS",
    OLSHR,		0,	"LSHR",
    OLT,		0,	"LT",
    OMOD,		0,	"MOD",
    OMUL,		0,	"MUL",
    ONAME,		0,	"NAME",
    ONE,		0,	"NE",
    ONOT,		0,	"NOT",
    OOR,		0,	"OR",
    OOROR,		0,	"OROR",
    OPOSTDEC,	0,	"POSTDEC",
    OPOSTINC,	0,	"POSTINC",
    OPREDEC,	0,	"PREDEC",
    OPREINC,	0,	"PREINC",
    OPROTO,		0,	"PROTO",
    OREGISTER,	0,	"REGISTER",
    ORETURN,	0,	"RETURN",
    OSET,		0,	"SET",
    OSIGN,		0,	"SIGN",
    OSIZE,		0,	"SIZE",
    OSTRING,	0,	"STRING",
    OLSTRING,	0,	"LSTRING",
    OSTRUCT,	0,	"STRUCT",
    OSUB,		0,	"SUB",
    OSWITCH,	0,	"SWITCH",
    OUNION,		0,	"UNION",
    OUSED,		0,	"USED",
    OWHILE,		0,	"WHILE",
    OXOR,		0,	"XOR",
    OPOS,		0,	"POS",
    ONEG,		0,	"NEG",
    OCOM,		0,	"COM",
    OELEM,		0,	"ELEM",
    OTST,		0,	"TST",
    OINDEX,		0,	"INDEX",
    OFAS,		0,	"FAS",
    OREGPAIR,	0,	"REGPAIR",
    OEXREG,		0,	"EXREG",
    OEND,		0,	"END",
    -1,		0,	0,
};
@

<<constant HISTSZ>>=
#define	HISTSZ		20
@

<<struct Atab>>=
struct Atab
    {
        Hist*	incl;	/* start of this include file */
        long	idel;	/* delta line number to apply to include */
        Hist*	line;	/* start of this #line directive */
        long	ldel;	/* delta line number to apply to #line */
};
@

% location?
<<function Lconv>>=
// int -> string?
int
Lconv(Fmt *fp)
{
    char str[STRINGSZ], s[STRINGSZ];
    Hist *h;
    long l, d;
    int i, n;
    struct Atab  a[HISTSZ];

    l = va_arg(fp->args, long);
    n = 0;
    for(h = hist; h != H; h = h->link) {
        if(l < h->line)
            break;
        if(h->name) {
            if(h->offset != 0) {		/* #line directive, not #pragma */
                if(n > 0 && n < HISTSZ && h->offset >= 0) {
                    a[n-1].line = h;
                    a[n-1].ldel = h->line - h->offset + 1;
                }
            } else {
                if(n < HISTSZ) {	/* beginning of file */
                    a[n].incl = h;
                    a[n].idel = h->line;
                    a[n].line = 0;
                }
                n++;
            }
            continue;
        }
        n--;
        if(n > 0 && n < HISTSZ) {
            d = h->line - a[n].incl->line;
            a[n-1].ldel += d;
            a[n-1].idel += d;
        }
    }
    if(n > HISTSZ)
        n = HISTSZ;
    str[0] = 0;
    for(i=n-1; i>=0; i--) {
        if(i != n-1) {
            if(fp->flags & ~(FmtWidth|FmtPrec))	/* BUG ROB - was f3 */
                break;
            strcat(str, " ");
        }
        if(a[i].line)
            snprint(s, STRINGSZ, "%s:%ld[%s:%ld]",
                a[i].line->name, l-a[i].ldel+1,
                a[i].incl->name, l-a[i].idel+1);
        else
            snprint(s, STRINGSZ, "%s:%ld",
                a[i].incl->name, l-a[i].idel+1);
        if(strlen(s)+strlen(str) >= STRINGSZ-10)
            break;
        strcat(str, s);
        l = a[i].incl->line - 1;	/* now print out start of this file */
    }
    if(n == 0)
        strcat(str, "<eof>");
    return fmtstrcpy(fp, str);
}
@

<<function Tconv>>=
// option<Type> -> string
int
Tconv(Fmt *fp)
{
    char str[STRINGSZ+20], s[STRINGSZ+20];
    Type *t, *t1;
    int et;
    long n;

    str[0] = 0;
    for(t = va_arg(fp->args, Type*); t != T; t = t->link) {
        et = t->etype;
        if(str[0])
            strcat(str, " ");
        if(t->garb&~GINCOMPLETE) {
            sprint(s, "%s ", gnames[t->garb&~GINCOMPLETE]);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        sprint(s, "%s", tnames[et]);
        if(strlen(str) + strlen(s) < STRINGSZ)
            strcat(str, s);
        if(et == TFUNC && (t1 = t->down)) {
            sprint(s, "(%T", t1);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
            while(t1 = t1->down) {
                sprint(s, ", %T", t1);
                if(strlen(str) + strlen(s) < STRINGSZ)
                    strcat(str, s);
            }
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, ")");
        }
        if(et == TARRAY) {
            n = t->width;
            if(t->link && t->link->width)
                n /= t->link->width;
            sprint(s, "[%ld]", n);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(t->nbits) {
            sprint(s, " %d:%d", t->shift, t->nbits);
            if(strlen(str) + strlen(s) < STRINGSZ)
                strcat(str, s);
        }
        if(typesu[et]) {
            if(t->tag) {
                strcat(str, " ");
                if(strlen(str) + strlen(t->tag->name) < STRINGSZ)
                    strcat(str, t->tag->name);
            } else
                strcat(str, " {}");
            break;
        }
    }
    return fmtstrcpy(fp, str);
}
@

<<global tnames>>=
char*	tnames[NALLTYPES];
@

<<global tnamesinit>>=
Init	tnamesinit[] =
{
    TXXX,		0,	"TXXX",

    TCHAR,		0,	"CHAR",
    TUCHAR,		0,	"UCHAR",
    TSHORT,		0,	"SHORT",
    TUSHORT,	0,	"USHORT",
    TINT,		0,	"INT",
    TUINT,		0,	"UINT",
    TLONG,		0,	"LONG",
    TULONG,		0,	"ULONG",
    TVLONG,		0,	"VLONG",
    TUVLONG,	0,	"UVLONG",
    TFLOAT,		0,	"FLOAT",
    TDOUBLE,	0,	"DOUBLE",
    TIND,		0,	"IND",
    TFUNC,		0,	"FUNC",
    TARRAY,		0,	"ARRAY",
    TVOID,		0,	"VOID",
    TSTRUCT,	0,	"STRUCT",
    TUNION,		0,	"UNION",
    TENUM,		0,	"ENUM",
    TFILE,		0,	"FILE",
    TOLD,		0,	"OLD",
    TDOT,		0,	"DOT",

    -1,		0,	0,
};
@



<<function FNconv>>=
// option<Node identifier cases> -> string
int
FNconv(Fmt *fp)
{
    char *str;
    Node *n;

    n = va_arg(fp->args, Node*);
    str = "<indirect>";
    if(n != Z && (n->op == ONAME || n->op == ODOT || n->op == OELEM))
        str = n->sym->name;
    return fmtstrcpy(fp, str);
}
@

<<function Qconv>>=
// ??
int
Qconv(Fmt *fp)
{
    char str[STRINGSZ+20], *s;
    long b;
    int i;

    str[0] = 0;
    for(b = va_arg(fp->args, long); b;) {
        i = bitno(b);
        if(str[0])
            strcat(str, " ");
        s = qnames[i];
        if(strlen(str) + strlen(s) >= STRINGSZ)
            break;
        strcat(str, s);
        b &= ~(1L << i);
    }
    return fmtstrcpy(fp, str);
}
@

<<function VBconv>>=
// ??
int
VBconv(Fmt *fp)
{
    char str[STRINGSZ];
    int i, n, t, pc;

    n = va_arg(fp->args, int);
    pc = 0;	/* BUG: was printcol */
    i = 0;
    while(pc < n) {
        t = (pc+4) & ~3;
        if(t <= n) {
            str[i++] = '\t';
            pc = t;
            continue;
        }
        str[i++] = ' ';
        pc++;
    }
    str[i] = '\0';

    return fmtstrcpy(fp, str);
}
@

\subsection{[[8c/]]}

% similar to Assembler.tex.nw?

<<function listinit>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('B', Bconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('D', Dconv);
    fmtinstall('R', Rconv);
}
@

<<function Bconv>>=
// Bits -> string
int
Bconv(Fmt *fp)
{
    char str[STRINGSZ], ss[STRINGSZ], *s;
    Bits bits;
    int i;

    str[0] = 0;
    bits = va_arg(fp->args, Bits);
    while(bany(&bits)) {
        i = bnum(bits);
        if(str[0])
            strcat(str, " ");
        if(var[i].sym == S) {
            snprint(ss, sizeof(ss), "$%ld", var[i].offset); //$
            s = ss;
        } else
            s = var[i].sym->name;
        if(strlen(str) + strlen(s) + 1 >= STRINGSZ)
            break;
        strcat(str, s);
        bits.b[i/32] &= ~(1L << (i%32)); // >>
    }
    return fmtstrcpy(fp, str);
}
@

% for assembly generation?
<<function Pconv>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    if(p->as == ADATA)
        snprint(str, sizeof(str), "	%A	%D/%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else if(p->as == ATEXT)
        snprint(str, sizeof(str), "	%A	%D,%d,%D",
            p->as, &p->from, p->from.scale, &p->to);
    else
        snprint(str, sizeof(str), "	%A	%D,%D",
            p->as, &p->from, &p->to);
    return fmtstrcpy(fp, str);
}
@
% why not switch?

<<function Aconv>>=
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@
% anames in Assembly section

<<function Dconv>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[40], s[20];
    Adr *a;
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;
    if(i >= D_INDIR) {
        if(a->offset)
            snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
        else
            snprint(str, sizeof(str), "(%R)", i-D_INDIR);
        goto brk;
    }
    switch(i) {

    default:
        if(a->offset)
            snprint(str, sizeof(str), "$%ld,%R", a->offset, i); // $
        else
            snprint(str, sizeof(str), "%R", i);
        break;

    case D_NONE:
        str[0] = '\0';
        break;

    case D_BRANCH:
        snprint(str, sizeof(str), "%ld(PC)", a->offset-pc);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<>+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;

    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;


    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset); //$
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$(%.17e)", a->dval); //$
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->sval); //$
        break;


    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a); //$
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;
    }
brk:
    if(a->index != D_NONE) {
        fmtstrcpy(fp, str);
        snprint(s, sizeof(s), "(%R*%d)", (int)a->index, (int)a->scale);
        return fmtstrcpy(fp, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@

<<global regstr>>=
char*	regstr[] =
{
    "AL",	/*[D_AL]*/	
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",	/*[D_AX]*/
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",	/*[D_F0]*/
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",	/*[D_CS]*/
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",	/*[D_GDTR]*/
    "IDTR",	/*[D_IDTR]*/
    "LDTR",	/*[D_LDTR]*/
    "MSW",	/*[D_MSW] */
    "TASK",	/*[D_TASK]*/

    "CR0",	/*[D_CR]*/
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",	/*[D_DR]*/
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",	/*[D_TR]*/
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",	/*[D_NONE]*/
};
@

<<function Rconv>>=
// enum<operand_kind(register-only)> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@

<<function Sconv>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@


\section{[[prxxx()]]}

<<function prtree>>=
void
prtree(Node *n, char *s)
{

    print(" == %s ==\n", s);
    prtree1(n, 0, false);
    print("\n");
}
@

<<function prtree1>>=
void
prtree1(Node *n, int d, bool f)
{
    int i;

    if(f)
      for(i=0; i<d; i++)
        print("   ");
    if(n == Z) {
        print("Z\n");
        return;
    }
    if(n->op == OLIST) {
        prtree1(n->left, d, false);
        prtree1(n->right, d, true);
        return;
    }
    d++;
    print("%O", n->op);
    i = 3; // 1 || 2
    switch(n->op) {
    case ONAME:
        print(" \"%F\"", n);
        print(" %ld", n->xoffset);
        i = 0;
        break;

    case OINDREG:
        print(" %ld(R%d)", n->xoffset, n->reg);
        i = 0;
        break;

    case OREGISTER:
        if(n->xoffset)
            print(" %ld+R%d", n->xoffset, n->reg);
        else
            print(" R%d", n->reg);
        i = 0;
        break;

    case OSTRING:
        print(" \"%s\"", n->cstring);
        i = 0;
        break;

    case OLSTRING:
        if(sizeof(TRune) == sizeof(Rune))
            print(" \"%S\"", (Rune*)n->rstring);
        else
            print(" \"...\"");
        i = 0;
        break;

    case ODOT:
    case OELEM:
        print(" \"%F\"", n);
        break;

    case OCONST:
        if(typefd[n->type->etype])
            print(" \"%.8e\"", n->fconst);
        else
            print(" \"%lld\"", n->vconst);
        i = 0;
        break;
    }
    if(n->addable != 0)
        print(" <%d>", n->addable);
    if(n->type != T)
        print(" %T", n->type);
    if(n->complex != 0)
        print(" (%d)", n->complex);

    print(" %L\n", n->lineno);

    if(i & 2)
        prtree1(n->left, d, true);
    if(i & 1)
        prtree1(n->right, d, true);
}
@


\section{[[8c -v]], verbose mode}

% see diag(), with -v it will print == diagnostic == and then the ast dump
% via prtree()

\section{[[8c -m]], macro debugging}

<<[[dodefine()]] debug>>=
if(debug['m'])
    print("#define (-D) %s %s\n", s->name, s->macro+1);
@

<<[[macdef()]] debug>>=
if(debug['m'])
    print("#define %s %s\n", s->name, s->macro+1);
@

\section{[[8c -f]], line information debugging}

<<[[linehist()]] debug>>=
if(debug['f'])
    if(f) {
        if(offset)
            print("%4ld: %s (#line %d)\n", lineno, f, offset);
        else
            print("%4ld: %s\n", lineno, f);
    } else
        print("%4ld: <pop>\n", lineno);
@

\section{[[8c -L]], printing names}

\section{[[8c -d]], printing declarations}
% useful to debug, potentially useful to build tools too! e.g. tags file

% labels
<<function dbgdecl>>=
void
dbgdecl(Sym *s)
{
    print("decl \"%s\": C=%s [B=%d:O=%ld] T=%T\n",
        s->name, cnames[s->class], s->block, s->offset, s->type);
}
@


\section{[[8c -t]], printing type trees}

\section{[[8c -i]], printing initializations}

\section{[[8c -m]], printing arithmetic trees}

\section{[[8c -r]], printing registerization}

\chapter{Error Managment}

<<global nerrors>>=
int	nerrors;
@

<<function errorexit>>=
void
errorexit(void)
{
    if(outfile)
        remove(outfile);
    exits("error");
}
@


<<function yyerror>>=
void
yyerror(char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    /*
     * hack to intercept message from yaccpar
     */
    if(strcmp(fmt, "syntax error") == 0) {
        yyerror("syntax error, last name: %s", symb);
        return;
    }
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", lineno, buf);
    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@


<<function diag>>=
void
diag(Node *n, char *fmt, ...)
{
    char buf[STRINGSZ];
    va_list arg;

    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    Bprint(&diagbuf, "%L %s\n", (n==Z)? nearln: n->lineno, buf);

    if(debug['X']){
        Bflush(&diagbuf);
        abort();
    }
    if(n != Z)
      if(debug['v'])
        prtree(n, "diagnostic");

    nerrors++;
    if(nerrors > 10) {
        Bprint(&diagbuf, "too many errors\n");
        errorexit();
    }
}
@


\chapter{Libc}

\section{Memory managment}
% same in Linker/assembler, not sure why they just don't use malloc?
% to avoid dependencies to libc? for bootstrapping reasons?

<<constant NHUNK>>=
#define	NHUNK		50000L
@

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk;
@

<<global thunk>>=
long	thunk;
@


<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 10L*NHUNK)
        nh = 10L*NHUNK;

    h = (char*)sbrk(nh);
    if(h == (char*)-1) {
        yyerror("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@

<<constant MAXALIGN>>=
#define	MAXALIGN	7
@

<<function alloc>>=
/*
 * real allocs
 */
void*
alloc(long n)
{
    void *p;

    while((uintptr)hunk & MAXALIGN) {
        hunk++;
        nhunk--;
    }
    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

<<function allocn>>=
void*
allocn(void *p, long on, long n)
{
    void *q;

    q = (uchar*)p + on;
    if(q != hunk || nhunk < n) {
        while(nhunk < on+n)
            gethunk();
        memmove(hunk, p, on);
        p = hunk;
        hunk += on;
        nhunk -= on;
    }
    hunk += n;
    nhunk -= n;
    return p;
}
@


<<function malloc>>=
/*
 * fake mallocs
 */
void*
malloc(ulong n)
{
    return alloc(n);
}
@

% hmm so no free ... maybe ok in a compiler context?
<<function free>>=
void
free(void*)
{
}
@

<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void*, ulong)
{
}
@


\section{String managment}

% STRINGSZ here

\section{Bit operations}

% see also Bits structure

<<function topbit>>=
int
topbit(ulong v)
{
    int i;

    for(i = -1; v; i++)
        v >>= 1;
    return i;
}
@

<<function bitno>>=
int
bitno(long b)
{
    int i;

    for(i=0; i<32; i++)
        if(b & (1L<<i))
            return i;
    diag(Z, "bad in bitno");
    return 0;
}
@
% >>

<<function SIGN>>=
#define	SIGN(n)		(1ULL<<(n-1))
@
% >>
<<function MASK>>=
#define	MASK(n)		(SIGN(n)|(SIGN(n)-1))
@

\section{Mathematic functions}

% use diag so could not really be put in libc
<<function round>>=
long
round(long v, int w)
{
    int r;

    if(w <= 0 || w > 8) {
        diag(Z, "rounding by %d", w);
        w = 1;
    }
    r = v%w;
    if(r)
        v += w-r;
    return v;
}
@



<<function log2>>=
/*
 * return log(n) if n is a power of 2 constant
 */
int
log2(uvlong v)
{
    int s, i;
    uvlong m;

    s = 0;
    m = MASK(8*sizeof(uvlong));
    for(i=32; i; i>>=1) {
        m >>= i;
        if(!(v & m)) {
            v >>= i;
            s += i;
        }
    }
    if(v == 1)
        return s;
    return -1;
}
@

\section{Key/value}

<<struct Init>>=
struct	Init			/* general purpose initialization */
{
    int		code;
    ulong	value;
    char*	s;
};
@

\section{Portability}

<<enum os>>=
enum os				/* also in ../{8a,0a}.h */
{
    Plan9	= 1<<0,
    Unix	= 1<<1,
    //Windows	= 1<<2,
};
@

\chapter{Extra Code}

\ifallcode
#include "Compiler_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
